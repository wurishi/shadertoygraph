{"ver":"0.1","info":{"id":"Dty3Wd","date":"1685634493","viewed":280,"name":"Lascaille's Shroud 2","username":"thepinkpanzer","description":"New and improved version of https://www.shadertoy.com/view/ctGGWy, with god rays and depth maps! ","likes":13,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","space","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bloom p2\n    vec4 bloom = vec4(0.0);\n    for (float n = -BLOOMSIZE; n < BLOOMSIZE+1.; n++)\n    {\n        bloom += texture(iChannel1, (fragCoord + vec2(0,1)*n)/iResolution.xy)*exp(-(4.*n*n)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    bloom /= BLOOMSIZE;\n    \n    // PSF\n    vec4 psf = vec4(0.0);\n    for (float n = -PSFSIZE; n < PSFSIZE+1.; n++)\n    {\n        float falloff = (PSFSIZE-n)*(PSFSIZE+n)*(0.2*PSFSIZE/(0.2*PSFSIZE+abs(n)))/(PSFSIZE*PSFSIZE*log(PSFSIZE)*4.);\n        psf += texture(iChannel0, (fragCoord + vec2(1,0)*n)/iResolution.xy)*falloff;\n        psf += texture(iChannel0, (fragCoord + vec2(0,1)*n)/iResolution.xy)*falloff;\n    }\n    \n    // put it all together\n    fragColor = tanh(bloom*0.4 + psf*0.6 + 0.2*texture(iChannel0, fragCoord/iResolution.xy));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nLascaille's Shroud 2\nConcept is as follows:\n• Buffer A runs through from the camera view and estimates a depth map for the Shroud\n - This is then used to make marching more efficient\n• Buffer B creates a similar depth map but radial, looking in\n - This is used for beams\n• Cubemap A creates the background, since it only runs once it can be quite fancy\n• Buffer D and Image then do a Gaussian blur bloom\n• Image can also do PSF\n• Since this is overall more efficient and allows for smaller steps, i can do fancy stuff too!\n*/\n\n// pi\n#define PI          3.1415927\n// gravitational lensing coefficient (+ is repulsive, - is attractive)\n#define GRAVLENSING 0.15\n// number of jumps in buffer A (depth buffer)\n#define NJUMPSA      15\n// number of jumps in buffer B (god rays buffer)\n#define NJUMPSB      10\n// number of jumps in buffer C (final image)\n#define NJUMPSC      400\n// camera distance from origin\n#define CAMERADIS    4.5\n// bloom width\n#define BLOOMSIZE    20.\n// point-spread function; makes stars into + shape\n#define PSFSIZE      10.\n\n#define LIGHTNING\n//#define USEDEPTH","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"vec2 renormalize(vec2 uv, float w)\n{\n    return (uv/w);\n}\nfloat sharp(float v, float s)\n{\n    v = 1. + (v-1.)*s;\n    return max(0., v);\n}\n// starry background\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame <= 30)\n    {\n        vec3 rd = abs(rayDir);\n        vec2 uv;\n        if (max(rd.x, max(rd.y, rd.z)) == rd.x)\n        {\n            uv = renormalize(vec2(rayDir.y, rayDir.z), rayDir.x);\n        }\n        else if (max(rd.x, max(rd.y, rd.z)) == rd.y)\n        {\n            uv = renormalize(vec2(rayDir.x, rayDir.z), rayDir.y);\n        }\n        else\n        {\n            uv = renormalize(vec2(rayDir.x, rayDir.y), rayDir.z);\n        }\n        float galplane = dot(rayDir, vec3(1,2.4,0.5));\n        galplane = 1./(1.+galplane*galplane);\n        fragColor  = vec4(sharp(1.-pow(texture(iChannel0, uv*0.2).r*2., 2.), 14.            ))*10.;\n        fragColor += vec4(sharp(1.-pow(texture(iChannel0, uv*0.3).g*2., 2.), 14.-6.*galplane))*2.;\n        fragColor += vec4(0.04,0.08,0.12,0)*galplane*(2.+1.*texture(iChannel2, uv*0.2).r)*(1.-0.5*galplane*galplane);\n    }\n    else\n    {\n        fragColor = texture(iChannel1, rayDir);\n    }\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nThis buffer is for camera-based depth perception\n*/\n\n// Approximate distance field for opaque-density clouds\nfloat DistanceField(vec3 pos)\n{\n    vec3 scaledPos = pos*(1.+0.05*sin(iTime*0.5));\n    float ra = texture(iChannel0, (scaledPos+vec3( 0.1, 0.04, 0.08)*0.2*iTime)/4.).g;\n    float rb = texture(iChannel0, (scaledPos+vec3(-0.1,-0.2, 0.1)*0.1*iTime)/6.).g;\n    ra *= ra;\n    rb *= rb;\n    float rq  = (max(length(pos), 1.0-length(pos)) - ((1.-ra) + (1.-rb))*0.37);\n    return rq;\n}\n\n// Checks if a ray (launched from position, in direction) hits a sphere (with radius) on the origin.\nbool SphereHit(float radius, vec3 position, vec3 direction)\n{\n    return (dot(position, direction)*dot(position, direction) > dot(direction, direction)*(dot(position, position)) - radius*radius);\n}\n// Calculates the distance to the near part of the sphere\nfloat SphereDist(float radius, vec3 position, vec3 direction)\n{\n    float d = -dot(position, direction) - sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\nfloat SphereThrough(float radius, vec3 position, vec3 direction)\n{\n    float d = 2.*sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\n// Calculates the normal on the surface of the sphere (equivalent to the position, for a unit sphere)\nvec3 SphereNormal(float radius, vec3 position, vec3 direction)\n{\n    return normalize(vec3(position + direction*SphereDist(radius, position, direction)));\n}\nvoid mainImage( out vec4 depth, in vec2 fragCoord )\n{\n    #ifdef USEDEPTH\n        float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n        float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n\n        // CAMERA\n        vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n        vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n        vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n\n        vec3 iCameraPosition= -CAMERADIS*iCameraFwd;\n\n        float m = 1.0;\n\n        vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n        iViewDirection      = normalize(iViewDirection);\n\n        // RAYMARCH\n        depth = vec4(CAMERADIS+3.);\n        if (SphereHit(1.0, iCameraPosition, iViewDirection))\n        {\n            depth = vec4(0);\n            vec3 pos  = iCameraPosition + iViewDirection*SphereDist(1.0, iCameraPosition, iViewDirection);\n            vec3 dir  = iViewDirection;\n            depth += SphereDist(1.0, iCameraPosition, iViewDirection);\n            for (int n = 0; n < NJUMPSA; n++)\n            {\n                float dis = 0.5*DistanceField(pos);\n                dir   += GRAVLENSING*dis*normalize(pos)/(0.2+dot(pos,pos));\n                dir    = normalize(dir);\n                pos   += dis*dir;\n                depth += dis;\n                if (length(pos) > 1.01)\n                {\n                    depth = vec4(CAMERADIS+3.);\n                    break;\n                }\n            }\n        }\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nRadial heightmap for GOD RAYS WOOOOOO!!!!!!!!!!!!!!!!!\n*/\nfloat DistanceField(vec3 pos)\n{\n    vec3 scaledPos = pos*(1.+0.05*sin(iTime*0.5));\n    float ra = texture(iChannel0, (scaledPos+vec3( 0.1, 0.04, 0.08)*0.2*iTime)/4.).g;\n    float rb = texture(iChannel0, (scaledPos+vec3(-0.1,-0.2, 0.1)*0.1*iTime)/6.).g;\n    ra *= ra;\n    rb *= rb;\n    float rq  = (max(length(pos), 1.05-length(pos)) - ((1.-ra) + (1.-rb))*0.37);\n    return rq;\n}\nvoid mainImage( out vec4 depth, in vec2 fragCoord )\n{\n    float theta = 2.*PI*fragCoord.x/iResolution.x;\n    float   phi =    PI*fragCoord.y/iResolution.y;\n    \n    vec3 iViewDirection = vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi));\n    vec3 iCameraPosition= -iViewDirection;\n    \n    depth    = vec4(0);\n    vec3 pos = iCameraPosition;\n    for (int n = 0; n < NJUMPSB; n++)\n    {\n        float dis = 0.5*DistanceField(pos);\n        depth += dis;\n        pos   += dis*iViewDirection;\n    }\n    //depth = vec4(pos, 0);\n    depth = max(vec4(0.),1.-depth);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\nActual marching to get color\n*/\n// Density field\nfloat Density(vec3 pos)\n{\n    // Sheathing the solid mass in smoke\n    vec3 scaledPos = pos*(1.+0.05*sin(iTime*0.5));\n    float ra   = texture(iChannel2, (scaledPos+vec3( 0.1, 0.04, 0.08)*0.2*iTime)/4.).g;\n    float rb   = texture(iChannel2, (scaledPos+vec3(-0.1,-0.2, 0.1)*0.1*iTime)/6.).g;\n    ra        *= ra;\n    rb        *= rb;\n    float rq   = (max(length(pos), 1.05-length(pos)) - ((1.-ra) + (1.-rb))*0.37);\n    \n    float rs   = smoothstep(-0.15,-0.1,-rq)*10.;\n    \n    // Swirls\n    vec3 r0    = texture(iChannel2, (scaledPos+vec3(  0.06, 0.07,-0.05)*0.2*iTime)/4.).rgb;\n    r0        += texture(iChannel2, (scaledPos+vec3( -0.05, -0.1, 0.02)*0.2*iTime)/6.).rgb;\n    r0        -= 1.;\n    scaledPos += 0.5*r0;\n    \n    float r1   = texture(iChannel2, (scaledPos)/4. ).a;\n    r1        += texture(iChannel2, (scaledPos)/6. ).a;\n    r1        += texture(iChannel2, (scaledPos)/12.).a;\n    r1        += texture(iChannel2, (scaledPos)/25.).a;\n    \n    r1        *= 1./pow(1. + dot(pos,pos), 2.);\n    \n    return rs*10.+exp(8.*r1-5. - rq);\n}\n\n/*\nColor is governed by four interactions:\n1) Emission (standard glow stuff)\n2) Absorption (again pretty standard)\n3) Reflection (in this case, from the ambient light - stars and whatnot)\n4) God rays (reflection of self-emitted light)\n*/\nvec4 Emit(vec3 pos, float density)\n{\n    vec4 core = vec4(1)*0.01/(0.01+dot(pos, pos));\n    vec4 halo = vec4(0.15, 0.8, 1.6, 0)*2.*pow(max(0., density*(3.-density)/3.), 8.)*9.;\n    vec4 total = core + halo;\n    #ifdef LIGHTNING\n        // 1) Create 3D lightning volume\n        // 2) Sample (other) 3D noise\n        // 3) Multiply and return\n        vec4 noise1 = (texture(iChannel2, pos*0.3+0.2));\n        float r1 = 1.-abs(0.5-noise1.g);\n        float r2 = 1.-abs(0.5-noise1.a);\n        float lightning = pow(r1*r2, 30.);\n        float r3 = abs(0.5-(texture(iChannel2, pos*0.12+0.026*iTime)).r);\n        float r4 = abs(0.5-(texture(iChannel2, pos*0.08-0.023*iTime)).g);\n        float noise2 = (max(0., 1.-20.*r3));\n        noise2      *= (max(0., 1.-20.*r4));\n        noise2      *= step(2., density)*step(-3., -density);\n        total += lightning*5000.*vec4(0.1,0.3,1.,0)*noise2;\n    #endif\n    return total;\n}\nvec4 Absorb(vec3 pos, float density)\n{\n    return vec4(0.3,0.4,0.7,0)*density*1.6;\n}\nvec4 Reflect(vec3 pos, float density)\n{\n    return vec4(0.2,0.15,0.1,0)*tanh(density)*max(0.,dot(pos, pos)-0.5);\n}\nvec4 GodRays(vec3 pos, vec3 dir, float density)\n{\n    float r = length(pos);\n    // Convert to iChannel1 UV\n    pos = -normalize(pos);\n    float theta = atan(pos.y, pos.x);\n    float phi   = atan(length(pos.xy), pos.z);\n    vec2  uv    = fract(vec2(theta/(2.*PI), phi/PI));\n    \n    // Sample iChannel1 depth:\n    float depth = texture(iChannel1, uv).r;\n    \n    // Emitted light reaching us\n    float lightIntensity = 0.015/(0.015+depth*depth);\n    \n    // Anisotropy (boosting beams towards camera)\n    float anisotropy = 1.3/(1.-0.6*dot(pos, dir));\n    \n    // Color\n    vec4 innerCol = vec4(1, 0.8, 0.5,0);\n    vec4 outerCol = vec4(0.7, 0.9, 1,0);\n    \n    return mix(innerCol, outerCol, (r-0.6)*6.) *(density + sqrt(density))*lightIntensity*anisotropy*0.6/(r*r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition= -CAMERADIS*iCameraFwd;\n    \n    float m = 1.0;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    fragColor          = vec4(0);\n    vec4 transmittance = vec4(1);\n    #ifdef USEDEPTH\n        // while depth map is done with far fewer steps, we trust it to be accurate\n        float depth    = texture(iChannel0, fragCoord/iResolution.xy).r - (CAMERADIS-1.);\n    #else\n        float depth    = 2.;\n    #endif\n    vec3  pos          = iCameraPosition;\n    vec3  dir          = iViewDirection;\n    float dis          = depth / float(NJUMPSC);\n    pos += (CAMERADIS-1.)*dir;\n    float density;\n    for (int n = 0; n < NJUMPSC; n++)\n    {\n        dir += GRAVLENSING*dis*normalize(pos)/(0.2+dot(pos,pos));\n        pos += dir*dis;\n        density = Density(pos);\n        transmittance*= exp(-dis*Absorb(pos, density));\n        fragColor    += dis*transmittance*(Reflect(pos, density) + Emit(pos, density) + GodRays(pos, dir, density));\n    }\n    if (depth < 2.)\n    {\n        fragColor += transmittance*(Reflect(pos, density));\n    }\n    else\n    {\n        fragColor += transmittance*texture(iChannel3, dir);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bloom step 1\n    fragColor = vec4(0.0);\n    for (float n = -BLOOMSIZE; n < BLOOMSIZE+1.; n++)\n    {\n        vec4 col   = texture(iChannel0, (fragCoord + vec2(1,0)*n)/iResolution.xy);\n        fragColor += pow(col/length(col), vec4(2.))*col*exp(-(4.*n*n)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor /= BLOOMSIZE;\n}","name":"Buffer D","description":"","type":"buffer"}]}