{"ver":"0.1","info":{"id":"Ds23DD","date":"1667619700","viewed":173,"name":"Noise Tunnels","username":"antovsky","description":"Tunnels by making a 3d sdf from two 2d sdfs the base of which is a noise.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*====================================================*/\n/*                                                    */\n/*                  The Field                         */\n/*                                                    */\n/*====================================================*/\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat hashToFloat(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat gradNoise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdCircle(in vec2 v, float r)\n{\n    return length(v) - r;\n}\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\nfloat sdSphere(in vec3 pos, float rad)\n{\n    return length(pos) - rad;\n}\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdfNoise(vec3 pos_in_world) {\n    // scale of the noise\n    float s = 1.0;\n    pos_in_world*=s;\n    \n    float d_ret = 10000.0; // any huge number\n    vec3 col_ret = vec3(1.0);\n    \n    const int r = 1;\n    for (int x = -r; x <= +r; ++x)\n    for (int y = -r; y <= +r; ++y)\n    for (int z = -r; z <= +r; ++z) {\n        vec3 c = fract((pos_in_world+vec3(x,y,z)));\n        vec3 i = floor((pos_in_world+vec3(x,y,z)));\n        vec3 j = vec3(hashToFloat(i),hashToFloat(i+vec3(7.0,13.0,17.0)), hashToFloat(i+vec3(33.0, 47.0, 57.0)))*2.0 - 1.0;\n        const float jitter_amount = 0.5; // how jittery the stars are\n        vec3 shape_in_world = (i+0.5+j*jitter_amount);\n        \n        vec3 pos_in_shape = pos_in_world-shape_in_world;\n        float shape_size = mix(0.4,0.5,hashToFloat(i));\n        \n        float d = sdSphere(pos_in_shape, shape_size);\n        \n        //d_ret = d;\n        d_ret = sminCubic(d, d_ret, 0.5);\n    }\n    return d_ret;\n}\n//---------------------------------------------------------------------\n//  Field: Compute the SDF to be raymarched.\n//---------------------------------------------------------------------\n\n#define noise sdfNoise\n\nfloat labField(vec3 pos) {\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    float d = 10000.0;\n    //vec2 baseSd = vec2(noise(vec3(pos.x, pos.z, 0.0f)), pos.y);\n    float r = 2.0;\n    vec2 baseSd = vec2(length(pos) - r, noise(normalize(pos)*r));\n    //baseSd.xy = baseSd.yx;\n    //vec2 baseSd = vec2(noise(normalize(pos)*r + vec3(iTime*0.5)), length(pos) - r);\n    //vec2 baseSd = vec2(noise(normalize(pos)), length(pos.xz) - 1.0);\n    //d = min(d, sdCircle(baseSd, 0.05));\n    //d = min(d, sdHexagon(baseSd, 0.05));\n    //d = min(d, sdBox(baseSd, vec2(0.05)));\n    d = min(d, sdBox(baseSd, vec2(0.05, 0.1)));\n    \n    \n    return d;\n}\n\n//---------------------------------------------------------------------\n//  Visualize: Add some debug visuals.\n//---------------------------------------------------------------------\n\nvoid labVisuals(inout LabSample S)\n{\n}\n\n//---------------------------------------------------------------------\n//  Main: Setup Lab and output final pixel color.\n//---------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    LabInput args = labInputDefault();\n    args.pixel_idx = fragCoord;\n    args.resolution = iResolution.xy;\n    args.world_from_camera_rot = quat_rot(vec3(-0.4, 0.0, 0.0));\n    args.world_from_camera_pos = quat_mul(args.world_from_camera_rot, vec3(0.0, 0.0, 16.0));\n\n    LabOutput lab_out = labRender(args);\n\n    // Output to screen\n    fragColor = vec4(lab_out.col);\n}\n\n/* \n   TODO:\n   - Built in camera controls\n   - Field slices\n   - Slider/Radio/Checkbox\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*====================================================*/\n/*                                                    */\n/*                Core Library                        */\n/*                                                    */\n/*====================================================*/\n\n// Configuration: Uncomment defines to provide custom overrides of various functions\n//#define CUSTOM_FIELD_SHADE // labFieldShade\n\n// ----------------[ Quaternion ]----------------------  \n\nvec4 quat_i() { return vec4(0.0, 0.0, 0.0, 1.0); }\nvec4 quat_axisangle(vec3 axis, float angle) { return vec4(axis*sin(angle*0.5), cos(angle*0.5)); }\nvec4 quat_conj(vec4 q) { return vec4(-q.xyz, q.w); }\nvec4 quat_mul(vec4 q1, vec4 q2) {\n\treturn vec4(\n\t\tq1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,\n\t\tq1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,\n\t\tq1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,\n\t\tq1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\nvec3 quat_mul(vec4 q, vec3 v) { return v + 2.0*cross(q.xyz, cross(q.xyz, v) + q.w*v); }\nvec4 quat_rot(vec3 rot) { // from 3 consecutive rotations, in order x,y,z (if interpreted as world_from_quat)\n\tvec4 qx = vec4(vec3(sin(rot.x * 0.5f), 0, 0), cos(rot.x * 0.5f));\n\tvec4 qy = vec4(vec3(0, sin(rot.y * 0.5f), 0), cos(rot.y * 0.5f));\n\tvec4 qz = vec4(vec3(0, 0, sin(rot.z * 0.5f)), cos(rot.z * 0.5f));\n\treturn quat_mul(qz, quat_mul(qy, qx));\n}\n\n\n// ----------------[ Raytracer ]-----------------------         \n\n// Configuration\n#define SUPERSAMPLE 2\n\n\n// Use this to configure the trace\nstruct LabInput {\n    vec3 world_from_camera_pos;\n    vec4 world_from_camera_rot;\n\tfloat camera_tan_half_y_fov_rad;\n    vec2 pixel_idx;\n    vec2 resolution;\n};\n\nstruct LabSample {\n    // In/Out\n    vec4  col;      // Current value of this sample\n    float Tmin;     // Current minimum T value along the ray\n    \n    // Constant\n    vec3 Ro;        // Ray origin\n    vec3 Rd;        // Ray direction\n    vec3 Cz;        // Camera z axis\n    \n};\n\nstruct LabOutput {\n    vec4 col;\n};\n\n\n// Implement these callbacks in your code:\nfloat labField(vec3 pos);\n\nvoid  labVisuals(inout LabSample S);\n\nLabInput labInputDefault() {\n\tLabInput args;\n\targs.world_from_camera_pos = vec3(0.0);\n\targs.world_from_camera_rot = quat_i();\n\targs.camera_tan_half_y_fov_rad = tan(1.39);\n\treturn args;\n}\n\n#ifndef CUSTOM_FIELD_SHADE\nvec3 labFieldShade(vec3 pos, vec3 nor, vec3 vie) {\n    return nor * 0.5 + 0.5;\n}\n#else\nvec3  labFieldShade(vec3 pos, vec3 nor, vec3 vie);\n#endif\n\nfloat labFieldTrace(vec3 ray_ori, vec3 ray_dir,\n            float t_min, float t_max,\n            int max_iter) {\n\t\n    float t = t_min;\n    for (int i = 0; i < max_iter; ++i) {\n\t\tvec3 pos = ray_ori + ray_dir*t;\n        float f = labField(pos);\n        if (f < 0.001) return t;\n        if (t > t_max) return -1.0;\n        t += f;\n    }\n    return -1.0;\n}\n\nvec3 labFieldGradient(in vec3 pos) {\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    vec3 g = k.xyy*labField( pos + k.xyy*h ) + \n             k.yyx*labField( pos + k.yyx*h ) + \n             k.yxy*labField( pos + k.yxy*h ) + \n             k.xxx*labField( pos + k.xxx*h );\n    return g / (h*4.0);\n}\n\nvec3 labFieldNormal(in vec3 pos) {\n    return normalize(labFieldGradient(pos));\n}\n\nfloat labRayTraceField(vec3 ray_ori, vec3 ray_dir, out vec3 col) {\n    float t = labFieldTrace(ray_ori, ray_dir, 0.0, 100.0, 128);\n    if (t > 0.0) {\n        vec3 pos = ray_ori + ray_dir * t;\n        vec3 nor = labFieldNormal(pos);\n        col = labFieldShade(pos, nor, -ray_dir);\n    }\n    else {\n        col = vec3(0.0);\n    }\n    return t;\n}\n\nvec4 labRaySample(vec3 ray_ori, vec3 ray_dir) {\n    LabSample S;\n    S.col = vec4(0.0);\n    S.Tmin = 1000000.0;\n    S.Ro = ray_ori;\n    S.Rd = ray_dir;\n\n    vec3 field_col;\n    float field_t = labRayTraceField(ray_ori, ray_dir, field_col);\n\n    if (field_t > 0.0) {\n        S.col += vec4(field_col, 1.0);\n        S.Tmin = field_t;\n    }\n\n    labVisuals(S);\n\n    return S.col;\n}\n\nLabOutput labRender(LabInput args) {\n\tLabOutput ret;\n\n\tvec3 ray_ori = args.world_from_camera_pos;\n\n\tret.col = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 frag = vec2(args.pixel_idx) + 0.5;\n\n\tfor (int m = 0; m < SUPERSAMPLE; m++) {\n\t\tfor (int n = 0; n < SUPERSAMPLE; n++) {\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(SUPERSAMPLE) - 0.5;\n\t\t\tvec2 p = (-args.resolution.xy + 2.0 * (frag + o)) / args.resolution.y;\n\t\t\tvec3 ray_dir = quat_mul(args.world_from_camera_rot, normalize(vec3(p.x, p.y, -args.camera_tan_half_y_fov_rad)));\n            ret.col += labRaySample(ray_ori, ray_dir);\n\t\t}\n    }\n\tret.col /= float(SUPERSAMPLE * SUPERSAMPLE);\n\n\treturn ret;\n}\n\n//---------------------------------------------------------------------\n//                     Maths\n//---------------------------------------------------------------------\n\n\n//---------------------------------------------------------------------\n//                  Intersectors\n// https://iquilezles.org/articles/intersectors\n//---------------------------------------------------------------------\nfloat sphereIntersect(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w;\n\tfloat h = b * b - c;\n\tif (h < 0.0) return -1.0;\n\treturn -b - sqrt(h);\n}\nvec3 sphereNormal(in vec3 pos, in vec4 sph)\n{\n\treturn normalize(pos - sph.xyz);\n}\nfloat capsuleIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h >= 0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y <= 0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - ra*ra;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nvec3 capsuleNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n//---------------------------------------------------------------------\n//                     Pretty Colors\n//---------------------------------------------------------------------\n\n\n#define RED       vec3(1.00, 0.40, 0.40)\n#define GREEN     vec3(0.50, 1.00, 0.40)\n#define BLUE      vec3(0.20, 0.40, 1.00)\n#define YELLOW    vec3(1.00, 1.00, 0.40)\n#define GREY      vec3(0.20, 0.20, 0.20)\n\n//---------------------------------------------------------------------\n//                     Visualization\n//---------------------------------------------------------------------\n\nvoid visSphereX(inout LabSample S, vec3 pos, float rad, vec3 col) {\n    vec4 sph = vec4(pos, rad);\n    float t = sphereIntersect(S.Ro, S.Rd, sph);\n    if (t > 0.0) {\n        vec3 pos = S.Ro + S.Rd * t;\n        vec3 nor = sphereNormal(pos, sph);\n        float f = (1.0-1.5*dot(nor, -S.Rd));\n        S.col = mix(S.col, vec4(col, 1.0), clamp(f, 0.0, 1.0));\n    }    \n}\n\nvoid visCapsuleF(inout LabSample S, vec3 pos0, vec3 pos1, float rad, vec3 col) {\n    float t = capsuleIntersect(S.Ro, S.Rd, pos0, pos1, rad);\n    if (t > 0.0) {\n        vec3 pos = S.Ro + S.Rd * t;\n        vec3 nor = capsuleNormal(pos, pos0, pos1, rad);\n        float f = dot(nor, -S.Rd);\n        S.col = vec4(col*f, 1.0);\n    }    \n}\n\nvoid visCapsuleX(inout LabSample S, vec3 pos0, vec3 pos1, float rad, vec3 col) {\n    float t = capsuleIntersect(S.Ro, S.Rd, pos0, pos1, rad);\n    if (t > 0.0) {\n        vec3 pos = S.Ro + S.Rd * t;\n        vec3 nor = capsuleNormal(pos, pos0, pos1, rad);\n        float f = (1.0-1.5*dot(nor, -S.Rd));\n        S.col = mix(S.col, vec4(col, 1.0), clamp(f, 0.0, 1.0));\n    }    \n}\n\n\n\n\n//---------------------------------------------------------------------\n//             Dirty Shadertoy Hackery\n// see: https://twitter.com/iquilezles/status/1415488691519123457?s=20\n//---------------------------------------------------------------------\n\n#ifndef HW_PERFORMANCE\nfloat labField(vec3 pos) { return 0.0; }\n#ifdef CUSTOM_FIELD_SHADE\nvec3  labFieldShade(vec3 pos, vec3 nor, vec3 vie) { return vec3(0.0); }\n#endif\nvoid  labVisuals(inout LabSample S) { }\n#endif","name":"Common","description":"","type":"common"}]}