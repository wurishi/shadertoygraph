{"ver":"0.1","info":{"id":"Ns3yzS","date":"1662112708","viewed":50,"name":"SDF playground Mike288","username":"mike228","description":"Signed Distance Function (SDF) sphere with phong lighting.\nhttps://en.wikipedia.org/wiki/Signed_distance_function","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst int MAX_MARCHING_STEPS = 255;\n\n/*float sdfSphere(vec3 point, vec3 camera, float radius) {\n    return length(camera + point) - radius;\n}*/\nfloat sdfSphere(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\nvec3 directionVector(float fieldOfView, vec2 size, vec2 point) {\n    vec2 uv = (point - size * 0.5);\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(uv, -z));\n}\n\nfloat shortestDistanceToSphere(vec3 camera, vec3 rayDir, float start, float end) {\n    float depth = start;\n    for (int i=0; i<MAX_MARCHING_STEPS; i++) {\n        float dist = sdfSphere(camera + rayDir * depth, 1.0f);\n        if(dist < EPSILON) {\n            return depth;\n        }\n\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5f)/iResolution.y;\n    vec3 camera = vec3(0.0f, 0.0f, 1.0f);\n\n    // Time varying pixel color\n    float col = sdfSphere(vec3(uv.xy, 1.0f), camera, 0.3f);\n    float colFrag = 0.0f;\n    if (col < 0.0f) {\n        colFrag = 1.0f;\n    }\n\n    // Output to screen\n    fragColor = vec4(colFrag, colFrag, colFrag,1.0);\n}\n*/\nvec3 estimateNormal(vec3 point) {\n    return normalize(vec3(\n        sdfSphere(vec3(point.x + EPSILON, point.y, point.z), 1.0) - sdfSphere(vec3(point.x - EPSILON, point.y, point.z), 1.0),\n        sdfSphere(vec3(point.x, point.y + EPSILON, point.z), 1.0) - sdfSphere(vec3(point.x, point.y - EPSILON, point.z), 1.0),\n        sdfSphere(vec3(point.x, point.y, point.z + EPSILON), 1.0) - sdfSphere(vec3(point.x, point.y, point.z - EPSILON), 1.0)\n    ));\n}\n\nvec3 phongContribution(vec3 kd, vec3 ks, float alpha, vec3 point, vec3 camera, vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 L = normalize(lightPos - point);\n    vec3 N = estimateNormal(point);\n    vec3 R = normalize(reflect(-L, N));\n    vec3 V = normalize(camera - point);\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (kd * dotLN);\n    }\n    \n    \n    //return (vec3(dot(L, N)) + vec3(dot(R, V))) * alpha * lightIntensity;\n    return lightIntensity * (kd * dotLN + ks * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 ka, vec3 kd, vec3 ks, vec3 point, vec3 camera, float shinniness) {\n    const vec3 ambient = vec3(1.0, 1.0, 1.0) * 0.5;\n    vec3 color = ambient * ka;\n    \n    vec3 lightPosition = vec3(4.0 * sin(iTime), 3.0, 4.0 * cos(iTime));\n    vec3 lightIntensity = vec3(0.4, 0.4, 0.);\n    \n    color += phongContribution(kd, ks, shinniness, point, camera, lightPosition, lightIntensity);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (fragCoord-iResolution.xy*0.5f)/iResolution.y;\n    vec3 camera = vec3(0.0, 0.0, 5.0f);\n\n    // Time varying pixel color\n    // float col = sdfSphere(vec3(uv.xy, 1.0f), camera, 0.3f);\n    // float col = sdfSphere(camera+vec3(uv.xy, 1.0f), 0.3f);\n    vec3 direction = directionVector(45.0, iResolution.xy, fragCoord);\n    float rayMarching = shortestDistanceToSphere(camera, direction, MIN_DIST, MAX_DIST);\n    //vec3 col = vec3(0.0, 0.0, 1.0);\n    if (rayMarching > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    // vec3 surfaceNormal = estimateNormal(col);\n    vec3 p = camera + direction * rayMarching;\n    vec3 K_a = vec3(1.0, 1.0, 1.0);\n    vec3 K_d = vec3(1.0, 1.0, 1.0);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    \n    vec3 col = phongIllumination(K_a, K_d, K_s, p, camera, 100.0);\n    \n\n    // Output to screen\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]}