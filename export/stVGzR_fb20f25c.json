{"ver":"0.1","info":{"id":"stVGzR","date":"1637087800","viewed":112,"name":"Glowing lights and SDFs","username":"lGuy","description":"SDF objects swinging around lights","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Creates the inverse of the view matrix\nmat4 invLookAt(in vec3 eye, in vec3 center, in vec3 up) {\n    vec3 f = vec3(normalize(center - eye));\n    vec3 s = vec3(normalize(cross(f, up)));\n    vec3 u = vec3(cross(s, f));\n\n    mat4 m = mat4(1.0);\n    m[0][0] = s.x;\n    m[0][1] = s.y;\n    m[0][2] = s.z;\n    m[1][0] = u.x;\n    m[1][1] = u.y;\n    m[1][2] = u.z;\n    m[2][0] =-f.x;\n    m[2][1] =-f.y;\n    m[2][2] =-f.z;\n    \n    m[3][0] = dot(s, eye);\n    m[3][1] = dot(u, eye);\n    m[3][2] =-dot(f, eye);\n    \n    return m;\n}\n\n// Creates a view matrix\nmat4 look_at(vec3 eye, vec3 center,vec3 up) {\n    vec3 f = vec3(normalize(center - eye));\n    vec3 s = vec3(normalize(cross(f, up)));\n    vec3 u = vec3(cross(s, f));\n\n    mat4 m = mat4(1.0f);\n    m[0][0] = s.x;\n    m[1][0] = s.y;\n    m[2][0] = s.z;\n    m[0][1] = u.x;\n    m[1][1] = u.y;\n    m[2][1] = u.z;\n    m[0][2] =-f.x;\n    m[1][2] =-f.y;\n    m[2][2] =-f.z;\n    m[3][0] =-dot(s, eye);\n    m[3][1] =-dot(u, eye);\n    m[3][2] = dot(f, eye);\n    return m;\n}\n\nfloat sdSphere( in vec3 p, in float r ) {\n    return length(p)-r;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n// Scene geometry\nfloat map(in vec3 wRayPos) {\n    float d = 1e10;\n    \n    float sphereD0, sphereD1, sphereD2;\n    \n    { // Sphere0\n        vec3 wSpherePosition = 4.0 * vec3(sin(iTime), 0.0, cos(iTime));\n        sphereD0 = sdSphere(wRayPos - wSpherePosition, 1.0);\n    }\n    \n    { // Sphere1\n        vec3 wSpherePosition = vec3(2.0, sin(iTime) * 2.0, cos(iTime));\n        sphereD1 = sdSphere(wRayPos - wSpherePosition, 2.0);\n    }\n    \n    { // Sphere2\n        vec3 wSpherePosition = vec3(cos(iTime) * 2.0, sin(iTime) * 2.0, 4.0 * cos(iTime));\n        sphereD2 = sdSphere(wRayPos - wSpherePosition, 1.5);\n    }\n    \n    d = min(d, smoothUnion(sphereD0, sphereD1, 0.6));\n    d = min(d, smoothUnion(d, sphereD2, 0.6));\n    \n    return d;\n}\n\n// Calculates the normal of a point on a surface.\nvec3 calcNormal(in vec3 pos) {\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\nstruct Light {\n    vec3 wPosition;\n    vec3 color;\n    float strength;\n    float speed;\n};\n\nconst int NUM_LIGHTS = 4;\nLight lights[NUM_LIGHTS];\n\n// Calculates the pixel coordinate of a 3D point in the world\nvec2 calcPixelCoord(in vec3 wPosition, in mat4 viewMatrix) {\n    float nearPlane = -1.0;\n\n    vec3 vPosition = (viewMatrix * vec4(wPosition, 1.0)).xyz;\n    \n    float ratio = nearPlane / vPosition.z;\n    \n    vec2 screenPos = -ratio * vPosition.xy;\n    \n    return screenPos;\n}\n\n// Calculates the diffuse\nvec3 calcSurfaceLighting(\n    in float dist,\n    in vec3 wPixelPosition, \n    in vec3 wRayDirection,\n    in Light light) {\n    vec3 wHitPosition = wPixelPosition + wRayDirection * dist;\n    vec3 wNormal = calcNormal(wHitPosition);\n        \n    float diffuse = dot(wNormal, normalize(light.wPosition - wHitPosition));\n    diffuse = clamp(diffuse, 0.1, 1.0);\n        \n    return vec3(diffuse) * light.color * 15.0;\n}\n\n// Classic raymarching\nfloat raymarch(\n    in vec3 wRayStart, \n    in vec3 wRayDirection) {\n    float stride = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 wCurrent = wRayStart + wRayDirection * stride;\n        \n        float field = map(wCurrent);\n        \n        if (abs(field) < 0.001) {\n            // We hit an object\n            return stride;\n        }\n        else {\n            // Keep marching\n            stride += field;\n        }\n        \n        if (stride > 10000.0) {\n            return -1.0;\n        }\n    }\n    \n    return -1.0;\n}\n\n// Calculates the light glow (this depends on the 2D coordinate of the light on the screen).\nvec4 screenLight(\n    vec2 p, \n    vec3 vLightPos,\n    vec2 center, \n    float strength, \n    vec4 color,\n    in mat4 invViewMatrix) {\n    // We need to see if this light is being occluded\n    vec3 vPixelPosition = vec3(center, -1.0);\n    vec3 vRayDirection = normalize(vPixelPosition);\n    \n    vec3 wPixelPosition = (invViewMatrix * vec4(vPixelPosition, 1.0)).xyz;\n    vec3 wRayDirection = (invViewMatrix * vec4(vRayDirection, 0.0)).xyz;\n\n    float dist = raymarch(wPixelPosition, wRayDirection);\n\n    if (dist == -1.0 || dist < length(vLightPos)) {\n        return strength * color / dot(p - center, p - center);\n    }\n    else {\n        return vec4(0.0);\n    }\n}\n\nstruct LightContribution {\n    vec3 bleed;\n    vec3 diffuse;\n};\n\n// Calculates both the diffuse contribution and light bleeding (glow)\nLightContribution calcLightContrib(\n    in Light light,\n    in mat4 viewMatrix,\n    in mat4 invViewMatrix,\n    in vec2 fragCoord,\n    in float dist,\n    in vec3 wPixelPosition,\n    in vec3 wRayDirection) {\n    LightContribution contrib;\n    contrib.bleed = vec3(0.0);\n    contrib.diffuse = vec3(0.0);\n\n    vec2 pLightPosition = calcPixelCoord(light.wPosition, viewMatrix);\n    vec3 vLightPosition = (viewMatrix * vec4(light.wPosition,1.0)).xyz;\n    contrib.bleed = screenLight(\n        fragCoord,\n        vLightPosition,\n        pLightPosition, \n        light.strength, \n        vec4(light.color, 1.0),\n        invViewMatrix).rgb;\n        \n    if (dist == -1.0) {\n        contrib.diffuse = vec3(0.0);\n    }\n    else {\n        contrib.diffuse = calcSurfaceLighting(dist, wPixelPosition, wRayDirection, light);\n    }\n    \n    return contrib;\n}\n\n// Calculates the color of a pixel (includes raymarching, lighting etc...)\nvec3 render(\n    in vec3 wPixelPosition, \n    in vec3 wRayDirection, \n    in mat4 invViewMatrix, \n    in mat4 viewMatrix, \n    in vec2 fragCoord) {\n    float dist = raymarch(wPixelPosition, wRayDirection);\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        LightContribution contrib = calcLightContrib(\n            lights[i],\n            viewMatrix,\n            invViewMatrix,\n            fragCoord,\n            dist,\n            wPixelPosition,\n            wRayDirection);\n            \n        finalColor += contrib.diffuse + contrib.bleed;\n    }\n    \n    return finalColor;\n}\n\n// Hashing function used for move\nvec2 hash( vec2 x ) {\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// Given an n, a unique varying position is produced\nvec3 move(int n, float speed) {\n    float h = hash(vec2(float(n))).x;\n    \n    return vec3(\n        cos(speed * iTime / 10.0 - h) * 0.7, \n        sin(speed * iTime / 20.0 + h) * 0.2,\n        sin(speed * iTime / 15.0 + h) * 0.5);\n}\n\n// Light parameters configuration\nvoid configureLights() {\n    lights[0].color = vec3(0.4, 0.2, 0.7);\n    lights[0].strength = 0.1;\n    lights[0].speed = 13.0;\n    \n    lights[1].color = vec3(0.1, 0.2, 0.8);\n    lights[1].strength = 0.1;\n    lights[1].speed = 8.0;\n    \n    lights[2].color = vec3(0.4, 0.6, 0.8);\n    lights[2].strength = 0.1;\n    lights[2].speed = 10.0;\n    \n    lights[3].color = vec3(0.9, 1.2, 0.6);\n    lights[3].strength = 0.1;\n    lights[3].speed = 7.0;\n}\n\n// Calculates the final color of the pixel with a given exposure\nvec3 calcFinalColor(vec3 color, float exposure) {\n    vec3 one = vec3(1.0);\n    vec3 expValue = exp(-color / vec3(1.0) * exposure);\n    vec3 diff = one - expValue;\n    vec3 gamma = vec3(1.0 / 2.2);\n    return pow(diff, gamma);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Sets up the light parameters\n    configureLights();\n\n    // Calculates the next positions of the lights\n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        lights[i].wPosition = move(i, lights[i].speed) * 10.0;\n    }\n\n    // Set up world space properties fo the camera\n    //vec3 wEyePosition = vec3(0.0, 5.0, 15.0);\n    vec3 wEyePosition = vec3(0.0, 0.0, 1.0) * 15.0;\n    vec3 wEyeDirection = normalize(vec3(0.0) - wEyePosition);\n    vec3 wUp = normalize(vec3(sin(iTime * 0.5), cos(iTime * 0.4) + 1.1, 0.0));\n    \n    // Matrix will be used to convert world space positions of the SDF objects\n    // into view space coordinates (which the view ray will be in).\n    mat4 viewMatrix = invLookAt(wEyePosition, wEyePosition + wEyeDirection, wUp);\n    mat4 invViewMatrix = invLookAt(wEyePosition, wEyePosition + wEyeDirection, wUp);\n\n    // View space\n    vec3 vPixelPosition = vec3((fragCoord - 0.5*iResolution.xy)/iResolution.y, -1.0);\n    vec3 vRayDirection = normalize(vPixelPosition);\n    \n    // World space\n    vec3 wPixelPosition = (invViewMatrix * vec4(vPixelPosition, 1.0)).xyz;\n    vec3 wRayDirection = (invViewMatrix * vec4(vRayDirection, 0.0)).xyz;\n    \n    vec3 color = render(wPixelPosition, wRayDirection, invViewMatrix, viewMatrix, vPixelPosition.xy);\n    \n    // Final color\n    fragColor.rgb = calcFinalColor(color, 0.06);\n}\n","name":"Image","description":"","type":"image"}]}