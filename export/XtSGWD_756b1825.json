{"ver":"0.1","info":{"id":"XtSGWD","date":"1433251273","viewed":2380,"name":"Descent","username":"mhnewman","description":"Procedurally generated night scene.","likes":89,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","night","city","lights","neon","skyline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const int buildingCount = 40;\nconst float buildingLifeTime = 5.0;\nconst float buildingSpread = 1.2;\n\nconst float topCurve = 0.9;\nconst float topOvershoot = 1.2;\n\nconst vec3 backgroundFog = vec3(0.2, 0.2, 0.3);\nconst vec3 streetGlow = vec3(0.3, 0.15, 0.4);\n\nconst float buildingScale = buildingLifeTime / (float(buildingCount) - 1.0);\nconst float buildingLeft = -0.5 * (buildingSpread - 1.0);\n\nfloat hash11(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash12(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nfloat hash13(vec3 p) {\n\tp = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.zxy, p.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(p.x * p.y * p.z * 95.4337);\n}\n\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nfloat noise12(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(hash12(i + vec2(0.0, 0.0)), \n                               hash12(i + vec2(1.0, 0.0)), u.x),\n                           mix(hash12(i + vec2(0.0, 1.0)), \n                               hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat screenWidth = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.y;\n    \n    float idOffset = floor(iTime / buildingScale);\n    \n    vec3 color = backgroundFog;\n    for (int i = 0; i < buildingCount; ++i) {\n        float id = idOffset + float(i);\n        float time = (iTime - buildingScale * id) / buildingLifeTime + 1.0;\n        \n        \n        //\tBuilding\n        vec2 hash = hash21(id);        \n        float top = topOvershoot * (topCurve * (time - time * time) + time);\n        float center = screenWidth * (buildingLeft + buildingSpread * hash.x);\n        vec3 buildingColor = (top - uv.y) * streetGlow;\n        \n        vec2 border = 0.02 + 0.03 * hash21(id);\n        vec2 outerWindow = vec2(0.01, 0.015) + vec2(0.02, 0.005) * hash21(id + 0.1);\n        vec2 innerWindow = 0.25 * hash21(id + 0.2);\n        float innerWidth = outerWindow.x * floor(0.2 * (0.5 + hash.y) / outerWindow.x);\n        float outerWidth = innerWidth + border.x;\n        \n        vec2 pos = (uv - vec2(center, top - border.y)) / outerWindow;\n        vec2 local = mod(pos, 1.0);\n        vec2 index = floor(pos);\n        \n        vec3 windowColor = vec3(0.85) + 0.15 * hash31(id);\n        float window = hash13(vec3(index, id)) - 0.2 * hash11(id + 0.3);\n        window = smoothstep(0.62, 0.68, window);\n        window *= step(innerWindow.x, local.x) * step(local.x, 1.0 - innerWindow.x);\n        window *= step(innerWindow.y, local.y) * step(local.y, 1.0 - innerWindow.y);\n        \n        window *= step(index.y, -0.5);\n        window *= step(uv.x, center + innerWidth) * step(center - innerWidth, uv.x);\n        buildingColor = mix(buildingColor, windowColor, window);\n        \n        buildingColor = mix(buildingColor, backgroundFog, time);\n        \n        float inside = step(uv.y, top);\n        inside *= step(uv.x, center + outerWidth);\n        inside *= step(center - outerWidth, uv.x);\n        \n        color = mix(color, buildingColor, inside);\n        \n        //\tSign\n        hash = hash21(id + 0.5);\n        vec2 signCenter = vec2(center + outerWidth * (2.0 * hash.x - 1.0), top - 0.2 - 0.2 * hash.y);\n\n        hash = hash21(id + 0.6);\n        float charSize = 0.01 + 0.04 * hash.x;\n        float charCount = floor(1.0 + 8.0 * hash.y);\n        \n        vec2 halfSize = 0.5 * vec2(charSize, charSize * charCount);\n        float outline = length(max(abs(uv - signCenter) - halfSize, 0.0));\n        \n        vec3 signColor = hash31(id + 0.1);\n        signColor = signColor / max(max(signColor.r, signColor.g), signColor.b);\n        signColor = clamp(vec3(0.2) + signColor, 0.0, 1.0);\n        signColor = mix(signColor, backgroundFog, time * time);\n        \n        vec2 charPos = (uv - signCenter + halfSize) / charSize;\n\t\tfloat char = 1.5 + 4.0 * noise12(id + 6.0 * charPos);\n        charPos = fract(charPos);\n        char *= smoothstep(0.0, 0.4, charPos.x) * smoothstep(1.0, 0.6, charPos.x);\n        char *= smoothstep(0.0, 0.4, charPos.y) * smoothstep(1.0, 0.6, charPos.y);\n        char *= step(outline, 0.001);\n        signColor = mix(backgroundFog * time, signColor, clamp(char, 0.0, 1.0));\n\t    color = mix(color, signColor, step(outline, 0.01));\n        \n        vec3 outlineColor = hash31(id + 0.2);\n        outlineColor = outlineColor / max(max(outlineColor.r, outlineColor.g), outlineColor.b);\n        outlineColor = clamp(vec3(0.2) + outlineColor, 0.0, 1.0);\n        outlineColor = mix(outlineColor, backgroundFog, time * time);\n        \n        outline = smoothstep(0.0, 0.01, outline) * smoothstep(0.02, 0.01, outline);\n        color = mix(color, outlineColor, outline);\n        \n        //\tBalls\n        hash = hash21(id + 0.8);\n        float radius = 0.005 + 0.01 * hash.y;\n        float gap = radius + 0.015 * hash.x;\n        \n        hash = hash21(id + 0.9);\n        float ballX = gap * (floor(uv.x / gap) + 0.5);\n        float ballOffset = ballX - center;\n        float ballY = top - 0.4 - 0.7 * hash.y + (0.03 + 0.05 * hash.x) * ballOffset * ballOffset;\n        float ball = length(uv - vec2(ballX, ballY)) / radius;\n        color = mix(color, outlineColor, smoothstep(1.0, 0.0, ball));\n    }\n    fragColor = vec4(color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}