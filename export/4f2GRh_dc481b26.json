{"ver":"0.1","info":{"id":"4f2GRh","date":"1703824114","viewed":45,"name":"Geometric Carousel","username":"Aurcereal","description":"barely held together, fullscreen is best","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","monochrome"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 80\n#define MAXDIST 10.0\n#define SDEPS 0.005\n#define NORMEPS 0.01\n\n//#define VV vec2(1., 0.)\n\nfloat t;\n\nfloat sdhexNPrism(vec3 p, float sideCount, float r, float depth)\n{\n    p.xy = toPolar(p.xy);\n    \n    float repSize = TAU/sideCount;\n    \n    p.y = mod(p.y, repSize) - .5*repSize;\n    p.xy = toCartesian(p.xy);\n    \n    vec3 dist = vec3(p.x - r, abs(p.y) - r*tan(.5*repSize), abs(p.z) - depth*.5);\n    float s = sqrt(max(0., sign(dist.x)*dist.x*dist.x) + max(0., sign(dist.y)*dist.y*dist.y) + max(0., sign(dist.z)*dist.z*dist.z));\n    \n    return step(s, 0.) * max(dist.x, max(dist.y, dist.z)) + s;\n}\n\nfloat sdHexBall(vec3 p, float r, float depth, float spd, float timeOffset, float n)\n{\n    \n    float o1 = timeOffset + spd*t;\n    float o2 = timeOffset*2. + spd*.8*t;\n    #if 0\n    vec3 fo = vec3(sin(o1), 0., cos(o1));\n    vec3 up = vec3(0., 1., 0.);\n    fo = fo * cos(o2) + up * sin(o2);\n    vec3 ri = normalize(cross(fo, up+1.));\n    up = cross(fo, ri);\n    \n    #else\n    vec3 ri = vec3(1.,0.,0.);\n    vec3 up = vec3(0., cos(o1), sin(o1));\n    vec3 fo = cross(up, ri);\n    #endif\n    \n    p = vec3(dot(p, ri), dot(p, up), dot(p, fo));\n    \n    return sdhexNPrism(p.zyx, n, r, depth);\n    \n    //return min(100.+sdhexNPrism(p.xyz, 3., r, depth), min(\n    //           100.+sdhexNPrism(p.xzy, 3., r, depth),\n    //           sdhexNPrism(p.zyx, 5., r, depth)));\n}\n\nfloat sdPillar(vec3 p)\n{\n    return 1.;\n}\n\nfloat sdCircus(vec3 p, int pillarCount, float pillarHeight,  float capHeight) \n{\n    \n    \n    // Private parameters\n    float circusRadius = 1.4;\n    float pillarRadialOffset = 1.2;\n    float pillarRadius = 0.05*.5*2.;\n    \n    p.y -= capHeight + pillarHeight*.5;\n    \n    // Cap\n    vec3 cp = p - vec3(0., -capHeight*.5, 0.);\n    float cpr = length(cp.xz); //cp.y -= .1*smoothstep(circusRadius*.7, circusRadius*.2, cpr);\n    float sdCap = sdhexNPrism(cp.xzy, 8., circusRadius, capHeight);//sdCylinder(cp, circusRadius, capHeight);\n    float newCap = sdCylinder(cp, circusRadius*vec2(0.8,1.), capHeight*1.5);\n    //sdCap = min(sdCap, newCap);\n    \n    // Pillars (maybe make them more like the bird cage type thing)\n    vec3 lp = p; //lp.y -= capHeight;\n    vec2 polar = toPolar(lp.xz); vec2 lpolar = polar; vec2 centerLinePolar = lpolar;\n    \n    float repTheta = TAU/float(pillarCount);\n    lpolar.y = mod(lpolar.y, repTheta) - repTheta*.5; float thetaID = polar.y - lpolar.y - repTheta*.5;\n    centerLinePolar.y = mod(polar.y + repTheta*.5, repTheta) - repTheta*.5;\n    \n    lp.xz = toCartesian(lpolar);\n    //lp.xy = rot(lp.xy, 0.3);\n    \n    float sdPillar = sdLineCapped(lp, vec3(pillarRadialOffset, 0., 0.), vec3(pillarRadialOffset, -pillarHeight*5., 0.), pillarRadius);\n    float hexBallVertical = -pillarHeight*.5 - .4 + .2*sin(1.1*t + thetaID*1.2);\n    float hexSeparation = 0.7;\n    lp = lp - vec3(pillarRadialOffset, hexBallVertical, 0.); vec3 hlp = lp;\n    hlp.y = abs(hlp.y) - hexSeparation*.5;\n    \n    float shapeAlt = step(abs(mod(thetaID/repTheta, 2.) - 1.), .5);\n    \n    sdPillar = min(sdPillar, sdHexBall(hlp, .1, .1, 2., thetaID*100., 3. + shapeAlt*2.));\n    \n    #if 1 //mabe ok for standalone but probably not as the background of a game\n    float rl = .3+.05;\n    float sl = .15;\n    lp.y = mod(lp.y + thetaID*100. + t*.7*(shapeAlt*2.-1.), rl) - rl*.5; sdPillar = min(sdPillar, sdCylinder(lp, pillarRadius*vec2(1.02,1.04), sl*.5));\n    #endif\n    \n    vec3 clp = vec3(toCartesian(centerLinePolar), p.y).xzy; clp.y -= -pillarHeight*.2;\n    float sdCenterLine = sdhexNPrism(clp.zyx, 4., .005, 20.);\n    sdCenterLine = min(sdCenterLine, sdhexNPrism((p - vec3(0., -pillarHeight*.2, 0.)).xzy, float(pillarCount), 0.13, 0.01));//sdHexBall(p - vec3(0., -pillarHeight*.2, 0.), .1, .1, 2., 1000.)\n    \n    float sd = min(sdPillar, sdCap);\n    return min(sd, sdCenterLine);\n    \n}\n\nfloat sdOuterRows(vec3 p, float spd)\n{\n   \n   \n   //\n   float c = 1.;\n   \n   float repSize = 1.5*c;\n   float stripeSize = .2*c;\n   \n   float radius = 2.5*c;\n   float thickness = .01*c;\n   \n   //\n   float offset = t*spd*c;\n   \n   p.y = mod(p.y - offset, repSize) - repSize*.5;\n   \n   return max(sdhexNPrism(p.xzy, 8., radius+thickness, stripeSize), -sdhexNPrism(p.xzy, 8., radius, 100.));\n   return sdCylinder(p, vec2(radius, radius+thickness), stripeSize);\n    \n}\n\nfloat sdf(vec3 p)\n{\n\n    // Circus\n    float upOffset = .4*.4*sin(1.3*t);\n    float groundRotation = 1.2*t;\n    \n    vec3 up = vec3(-sin(upOffset), cos(upOffset), 0.);\n    vec3 fo = vec3(cos(groundRotation), 0., sin(groundRotation)); fo -= up * dot(fo, up); fo = normalize(fo);\n    vec3 ri = cross(fo, up); //assume perp\n    vec3 lp = vec3(dot(p, ri), dot(p, up), dot(p, fo));\n    \n    float sd = sdCircus(lp, 8+7*0, 1.4, .1);\n    sd = min(sd, sdOuterRows(lp, 2.));\n    \n    return sd + 0.1*step(length(p - vec3(0.,0.,-1.1)), 0.1);\n\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(NORMEPS, 0.0);\n\n    return normalize(\n        vec3(sdf(p + e.xyy) - sdf(p - e.xyy),\n             sdf(p + e.yxy) - sdf(p - e.yxy),\n             sdf(p + e.yyx) - sdf(p - e.yyx)\n             ));\n             \n}\n\nint stepCount;\nfloat minDist;\nfloat distAtFirstMin = MAXDIST;\nfloat trace(vec3 ro, vec3 rd)\n{\n    minDist = MAXDIST;\n    stepCount = 0;\n    float d = 0.0, sd;\n    \n    for(int i=0; i<MAXSTEPS; i++)\n    {\n        stepCount++;\n        sd = sdf(ro+rd*d);\n        d += sd;\n        \n        minDist = min(minDist, sd);\n        if(sd <= 0.015) distAtFirstMin = min(distAtFirstMin, d);\n    \n        if(abs(sd) < SDEPS || d >= MAXDIST) {return d;}\n    }\n    return d;\n}\n\nvec3 currentSkyboxColor;\nvoid calculateSkyboxColor(vec3 rd, vec2 sp)\n{\n    float rl = .025;\n    float sl = .01;\n    float along = dot(sp, vec2(1.)/sqrt(2.));\n    along = mod(along, rl) - rl*.5; float isStripe = step(abs(along), sl*.5);\n\n    currentSkyboxColor = vec3(isStripe*.03);\n}\n\nvec3 shade(vec3 camPos, vec3 camFo, vec3 p, vec3 norm, float marchCount, float d, vec2 sp)\n{\n    \n    //\n    /*\n    float dist = dot(p - camPos, camFo);\n    \n    // Diffuse\n    vec3 col = vec3(1., 1., 1.);\n    vec3 lightDir = normalize(vec3(.5, .5, 1.));\n    float diffuseFalloff = min(1., max(0.5, dot(norm, -lightDir)+.1));\n    diffuseFalloff -= mod(diffuseFalloff, 0.4) - 0.4;\n    vec3 diffuseCol = col*diffuseFalloff;\n    \n    // Specular\n    vec3 reflectDir = normalize(reflect(p - camPos, norm));\n    vec3 specSample = texture(iChannel0, reflectDir).rgb;\n    vec3 specLightCol = col*pow(max(0., dot(reflectDir, -lightDir)), 16.);\n    \n    // Fog\n    float fogOffset = 1.5; float fogFalloffSpeed = 1.;\n    float fogMultiplier = min(1., exp(-fogFalloffSpeed*(dist - fogOffset)));\n    \n    // AO\n    float aoMultiplier = 1.-min(1., marchCount/128.);\n    */\n    // Composite\n    if(d - distAtFirstMin > .3) return vec3(1.) * step(minDist, 0.015);\n    \n    //\n    float rl = .025;\n    float sl = .01;\n    float along = dot(sp, vec2(1.)/sqrt(2.));\n    along = mod(along, rl) - rl*.5; float isStripe = step(abs(along), sl*.5);\n    \n    return vec3(0.);//mix((diffuseCol*1.3 + specSample*.1 + specLightCol*.2) * aoMultiplier, currentSkyboxColor, 1.-fogMultiplier);\n}\n\nvec3 render(vec2 fragCoord)\n{\n       \n    t = iTime;\n    \n    //cam specs\n    float theta = PI*.5;\n    float phi = 0.;\n    \n    vec3 fo = vec3(cos(phi) * cos(theta), sin(phi), cos(phi) * sin(theta)), up = vec3(0.0, 1.0, 0.0);\n    vec3 ri = normalize(cross(up, fo));\n    up = cross(fo, ri);\n    \n    float fovMultX = 1.0, fovMultY = .57735;                                           //HARDCODE fov TRIG\n    vec3 camPos = vec3(0.0, 0.0, -1.1);                                                //HARDCODE cam pos\n    \n    \n    //make rayWS\n    vec3 ray = normalize(vec3(((fragCoord/iResolution.xy)*2.0-1.0) * vec2(fovMultX, fovMultY), 1.0));\n    ray = ray.z * fo + ray.y * up + ray.x * ri;\n    \n    //trace\n    float dist = trace(camPos, ray);\n    \n    //skybox\n    calculateSkyboxColor(ray, (fragCoord/iResolution.xy)*vec2(iResolution.x/iResolution.y, 1.));\n    \n    #if 0\n    if(dist >= MAXDIST) return currentSkyboxColor;//{ return acos(-ray.y) * vec3(.2, .1, .4); }\n    \n    //hit\n    return normal(camPos+ray*dist)*.5+.5;\n    #else\n    float glowMultiplier = .5*.8;\n    if(dist >= MAXDIST) return currentSkyboxColor + vec3(1.)*step(minDist, 0.015) + vec3(glowMultiplier)/(pow(minDist+.1,2.)*300.);\n    \n    //hit\n    return shade(camPos, fo, camPos+ray*dist, normal(camPos + ray*dist), float(stepCount), dist, (fragCoord/iResolution.xy)*vec2(iResolution.x/iResolution.y, 1.));\n    #endif\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord -= mod(fragCoord, 2.);\n    fragColor = vec4(render(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define D2R .0174533\n#define R2D 57.29578\n#define PI 3.14159265\n#define TAU 6.283185\n\nfloat sb(float d) { return step(d, 0.); }\nfloat saturate(float f) { return clamp(f, 0., 1.); }\n\nfloat choose(float i1, float i2, float s)\n{\n    return i1 * (s-1.) + i2 * s;\n}\n\nvec2 rot(vec2 v, float o)\n{\n    return mat2(cos(o), sin(o), -sin(o), cos(o)) * v;\n}\n\nvec2 toPolar(vec2 cart)\n{\n    return vec2(length(cart), mod(atan(cart.y, cart.x), TAU));\n}\n\nvec2 toCartesian(vec2 polar)\n{\n    return polar.x * vec2(cos(polar.y), sin(polar.y));\n}\n\nvec2 perp(vec2 v)\n{\n    return mat2(0., 1., -1., 0.) * v;\n}\n\nfloat sdBox(vec2 p, vec2 fo, vec2 dim)\n{\n    p = abs(vec2(dot(p, fo), dot(p, perp(fo)))) - dim*.5;\n    float s = sqrt(max(0., p.x*p.x*sign(p.x)) + max(0., p.y*p.y*sign(p.y)));\n    return step(s, 0.) * max(p.x, p.y) + s;\n}\n\nfloat sdBox(vec2 p, vec2 dim)\n{\n    p = abs(p) - dim*.5;\n    float s = sqrt(max(0., p.x*p.x*sign(p.x)) + max(0., p.y*p.y*sign(p.y)));\n    return step(s, 0.) * max(p.x, p.y) + s;\n}\n\nfloat sdLineCapped(vec3 p, vec3 start, vec3 end, float thickness)\n{\n    float len = length(end - start);\n    \n    p -= start;\n\n    vec3 fo = normalize(end - start);\n    vec3 up = normalize(cross(fo, cross(fo, p)));\n    \n    vec2 lp = vec2(dot(p, fo), dot(p, up));\n    \n    lp.x = lp.x - len*.5;\n    \n    return sdBox(lp, vec2(len, thickness));\n}\n\nfloat sdCylinder(vec3 p, float r, float height)\n{\n    vec2 dist = vec2(abs(p.y) - height*.5, length(p.xz) - r);\n    float s = sqrt(max(0., sign(dist.x)*dist.x*dist.x) + max(0., sign(dist.y)*dist.y*dist.y));\n    return step(s, 0.) * max(dist.x, dist.y) + s;\n}\n\nfloat sdCylinder(vec3 p, vec2 rRange, float height)\n{\n    vec2 dist = vec2(abs(p.y) - height*.5, abs(length(p.xz) - (rRange.x+rRange.y)*.5) - (rRange.y-rRange.x)*.5);\n    float s = sqrt(max(0., sign(dist.x)*dist.x*dist.x) + max(0., sign(dist.y)*dist.y*dist.y));\n    return step(s, 0.) * max(dist.x, dist.y) + s;\n}","name":"Common","description":"","type":"common"}]}