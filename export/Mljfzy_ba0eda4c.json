{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define PI 3.1415926535\n#define HALF_PI 1.57079632679\n\nfloat speedMoon = 0.01;\nfloat speedSun = 0.25;\n\nvec3 sphereNormals(in vec2 uv) {\n  uv = fract(uv) * 2.0 - 1.0;\n  vec3 ret;\n  ret.xy = sqrt(uv * uv) * sign(uv);\n  ret.z = sqrt(abs(1.0 - dot(ret.xy, ret.xy)));\n  ret = ret * 0.5 + 0.5;\n  return mix(vec3(0.0), ret, smoothstep(1.0, 0.98, dot(uv, uv)));\n}\n\nvec2 sphereCoords(vec2 _st, float _scale) {\n  float maxFactor = sin(1.570796327);\n  vec2 uv = vec2(0.0);\n  vec2 xy = 2.0 * _st.xy - 1.0;\n  float d = length(xy);\n  if (d < (2.0 - maxFactor)) {\n    d = length(xy * maxFactor);\n    float z = sqrt(1.0 - d * d);\n    float r = atan(d, z) / 3.1415926535 * _scale;\n    float phi = atan(xy.y, xy.x);\n    uv.x = r * cos(phi) + 0.5;\n    uv.y = r * sin(phi) + 0.5;\n  } else {\n    uv = _st.xy;\n  }\n  return uv;\n}\n\nvec4 sphereTexture(in sampler2D _tex, in vec2 _uv) {\n  vec2 st = sphereCoords(_uv, 1.0);\n  float aspect = iChannelResolution[0].y / iChannelResolution[0].x;\n  st.x = fract(st.x * aspect + iTime * speedMoon);\n  return textureLod(_tex, st, -16.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy / iResolution.xy;\n  st = (st - .5) * 1.0 + .5;\n  if (iResolution.y > iResolution.x) {\n    st.y *= iResolution.y / iResolution.x;\n    st.y -= (iResolution.y * .5 - iResolution.x * .5) / iResolution.x;\n  } else {\n    st.x *= iResolution.x / iResolution.y;\n    st.x -= (iResolution.x * .5 - iResolution.y * .5) / iResolution.y;\n  }\n\n  vec4 color = vec4(1.0);\n\n  color *= sphereTexture(iChannel0, st);\n\n  // Calculate sun direction\n  vec3 sunPos = normalize(vec3(cos(iTime * speedSun - HALF_PI), 0.0,\n                               sin(speedSun * iTime - HALF_PI)));\n  vec3 surface = normalize(sphereNormals(st) * 2.0 - 1.0);\n\n  // Add Shadows\n  color *= dot(sunPos, surface);\n\n  // Blend black the edge of the sphere\n  float radius = 1.0 - length(vec2(0.5) - st) * 2.0;\n  color *= smoothstep(0.001, 0.02, radius);\n\n  fragColor = color;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mljfzy","date":"1516381554","viewed":846,"name":"Organic Planet","username":"homerjam","description":"From GLSLCanvas example: http://patriciogonzalezvivo.github.io/glslCanvas/","likes":8,"published":3,"flags":0,"usePreview":0,"tags":["space","planet"],"hasliked":0,"parentid":"","parentname":""}}