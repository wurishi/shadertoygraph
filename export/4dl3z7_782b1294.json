{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Haunted forest shader\n//\n// Created by Frank Hugenroth /frankenburgh/ 04/2013\n\n#define V2 1\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 2d noise function\nfloat noise( in vec2 x )\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.2;\n  f += 0.2500*noise( p ); p = m*p*1.3;\n  f += 0.1666*noise( p ); p = m*p*1.4;\n  f += 0.0834*noise( p );\n  return f;\n}\n\n\n\n\nfloat branch(in float ang, in vec2 uv, in float len, in float th, in float sharpness )\n{\n\tfloat x = sin(ang*2.*3.14159);\n\tfloat y = cos(ang*2.*3.14159);\n\n\tfloat ans2 = y*uv.x-x*uv.y;\n\tbool hit2 = ans2>=0. && ans2< len;\n\tif (!hit2)\n\t\treturn 1.0;\n\n\tfloat ans = x*uv.x+y*uv.y;\n\n\tfloat t = pow(1.-ans2/len, .25)*th + (1.0-ans2/len)*.01;\n#ifdef V2\n\tans += texture(iChannel0, vec2(ans2/len*.008+.74, th+.3)).r * 0.13;\n\tans += texture(iChannel0, vec2(ans2/len*.01+.91, th+.3)).r * 0.06;\n\tans += texture(iChannel0, vec2(ans2/len*.03+.5 , th+.4)).g * 0.06;\n\tans += texture(iChannel0, vec2(ans2/len*.03+.51, th+.4)).g * 0.03;\n#else\n\tans += texture(iChannel0, vec2(ans2/len*.02+.74, th+.3)).r * 0.17;\n\tans += texture(iChannel0, vec2(ans2/len*.02+.91, th+.3)).r * 0.09;\n\tans += texture(iChannel0, vec2(ans2/len*.07+.5 , th+.4)).g * 0.09;\n\tans += texture(iChannel0, vec2(ans2/len*.07+.51, th+.4)).g * 0.05;\n#endif\n\tfloat val = clamp(pow(abs(ans) / abs(t), 1.), 0.0, 1.0);\n\n\tval = pow(val, sharpness);\n\treturn val;\n}\n\n\nfloat trunk(in float ang, in vec2 uv, in float len, in float strength, in float sharpness )\n{\n\tfloat x = sin(ang*2.*3.14159);\n\tfloat y = cos(ang*2.*3.14159);\n\n\tfloat ans2 = y*uv.x-x*uv.y;\n\tbool hit2 = ans2>=0. && ans2< len;\n\tif (!hit2)\n\t\treturn 1.0;\n\n\tfloat ans = x*uv.x+y*uv.y;\n\n\tfloat t = pow(1.-ans2/len, .25)*strength + (1.0-ans2/len)*texture(iChannel0, vec2(ans2/len*.3, len*.8)).r*.025;\n#ifdef V2\n\tans += texture(iChannel0, vec2(ans2/len*.1, strength)).r * 0.04;\n#else\n\tans += texture(iChannel0, vec2(ans2/len*.2, strength)).r * 0.08;\n#endif\n\n\tfloat val = clamp(pow(abs(ans) / abs(t), 1.), 0.0, 1.0);\n\n\tval = pow(val, sharpness);\n\treturn val;\n}\n\n\nfloat fir(in float ang, in vec2 uv, in float len, in float strength, in float sharpness )\n{\n\tfloat x = sin(ang*2.*3.14159);\n\tfloat y = cos(ang*2.*3.14159);\n\n\tfloat ans2 = y*uv.x-x*uv.y;\n\tbool hit2 = ans2>=0. && ans2< len;\n\tif (!hit2)\n\t\treturn 1.0;\n\n\tfloat ans = x*uv.x+y*uv.y;\n\n\tfloat t = pow(1.-ans2/len, .25)*strength + (1.0-ans2/len)*texture(iChannel0, vec2(ans2/len*.3, len*.8)).r*.15;\n\tans += texture(iChannel0, vec2(ans2/len*.2, strength)).r * 0.04;\n\n\tfloat val = clamp(pow(abs(ans) / abs(t), 1.), 0.0, 1.0);\n\n\tval = pow(val, sharpness);\n\treturn val;\n}\n\n\nfloat tree2(in float ang, in vec2 uv, in float len, in float th, in float sharpness)\n{\n\tfloat val = 1.;\n\t// mid\n\tfloat x = sin(ang*2.*3.14159);\n\tfloat y = cos(ang*2.*3.14159);\n\tvec2 uvl = uv + vec2(-y*len*0.42 +x*len*+0.01 , x*len*0.42 +y*len*+0.01 );\n\tvec2 uvr = uv + vec2(-y*len*0.37 +x*len*-0.01 , x*len*0.37 +y*len*-0.01 );\n\tval *= branch(ang, uv, len, th, sharpness) * branch(ang-.095, uvl, len*.7, th*.3, sharpness) * branch(ang+.075, uvr, len*0.8, th*.2, sharpness);\n\treturn val;\n}\n\n\nfloat tree1(in float ang, in vec2 uv, in float len, in float th, in float sharpness)\n{\n\tfloat val = 1.;\n\t// mid\n\tfloat x = sin(ang*2.*3.14159);\n\tfloat y = cos(ang*2.*3.14159);\n#ifdef V2\n\tvec2 uvl = uv + vec2(-y*len*0.60 -x*len*0.09 , x*len*0.60 -y*len*0.09 );\n\tvec2 uvr = uv + vec2(-y*len*0.59 -x*len*0.12 , x*len*0.59 -y*len*0.12 );\n\tval *= trunk(ang, uv, len, .024, sharpness) * branch(ang-.13, uvl, len*.7, .008, sharpness) * branch(ang+.125, uvr, len*1.2, .005, sharpness);\n\t// left\n\tfloat ang1 = ang-.1; float len1 = len*.7; vec2 uv1 = uvl;\n\tx = sin(ang1*2.*3.14159);y = cos(ang1*2.*3.14159);\n\tvec2 uvl1 = uv1 + vec2(-y*len1*0.01+x*len*-0.022, x*len1*0.01+y*len*-0.022);\n\tvec2 uvr1 = uv1 + vec2(-y*len1*0.5 +x*len* 0.01 , x*len1*0.5 +y*len* 0.01);\n\tval *= branch(ang1-.1, uvl1, len1*.7, .003, sharpness) * branch(ang1+.13, uvr1, len1*.6, 0.005, sharpness);\n\t// right\n\tfloat ang2 = ang+.13; float len2 = len*.6; vec2 uv2 = uvr;\n\tx = sin(ang2*2.*3.14159);y = cos(ang2*2.*3.14159);\n\tvec2 uvl2 = uv2 + vec2(-y*len2*0.6 +x*len*-0.04, x*len2*0.6 +y*len*-0.04);\n\tvec2 uvr2 = uv2 + vec2(-y*len2*0.5 +x*len*+0.045, x*len2*0.5 +y*len*+0.045);\n\tval *= branch(ang2-.072, uvl2, len2*.8, 0.001, sharpness) * branch(ang2+.13, uvr2, len2*.6, 0.003, sharpness);\n#else\n\tvec2 uvl = uv + vec2(-y*len*0.60 -x*len*0.11 , x*len*0.60 -y*len*0.11 );\n\tvec2 uvr = uv + vec2(-y*len*0.59 -x*len*0.15 , x*len*0.59 -y*len*0.15 );\n\tval *= trunk(ang, uv, len, .024, sharpness) * branch(ang-.13, uvl, len*.7, .008, sharpness) * branch(ang+.125, uvr, len*1.2, .005, sharpness);\n\t// left\n\tfloat ang1 = ang-.1; float len1 = len*.7; vec2 uv1 = uvl;\n\tx = sin(ang1*2.*3.14159);y = cos(ang1*2.*3.14159);\n\tvec2 uvl1 = uv1 + vec2(-y*len1*0.01+x*len*+0.00, x*len1*0.01+y*len*+0.00);\n\tvec2 uvr1 = uv1 + vec2(-y*len1*0.4 +x*len* 0.02 , x*len1*0.4 +y*len* 0.02);\n\tval *= branch(ang1-.1, uvl1, len1*.7, .003, sharpness) * branch(ang1+.13, uvr1, len1*.6, 0.005, sharpness);\n\t// right\n\tfloat ang2 = ang+.13; float len2 = len*.6; vec2 uv2 = uvr;\n\tx = sin(ang2*2.*3.14159);y = cos(ang2*2.*3.14159);\n\tvec2 uvl2 = uv2 + vec2(-y*len2*0.6 +x*len*-0.08, x*len2*0.6 +y*len*-0.08);\n\tvec2 uvr2 = uv2 + vec2(-y*len2*0.5 +x*len*-0.022, x*len2*0.5 +y*len*-0.022);\n\tval *= branch(ang2-.032, uvl2, len2*.8, 0.001, sharpness) * branch(ang2+.13, uvr2, len2*.6, 0.003, sharpness);\n#endif\n\treturn val;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 0.1;\n\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tuv -= vec2(.25, 0.);\n\n\tfloat val1 = 1.;\n\tfloat val2 = 1.;\n\tfloat val3 = 1.;\n\tfloat val4 = 1.;\n\n\t// trees\n\tval2 *= tree1(0.79+sin(time*5.+.0 )*0.006, uv                ,  .75, 0.024, 9.);\n\tval2 *= tree1(0.73+sin(time*5.+.1 )*0.006, uv+vec2(-1.15, 0.),  .99, 0.024, 9.);\n\tval3 *= tree2(0.73+sin(time*5.-.3 )*0.006, uv+vec2(-0.85, 0.), 1.00, 0.014, 8.);\n\tval3 *= tree2(0.78+sin(time*5.+.2 )*0.006, uv+vec2(0.182, 0.), 1.00, 0.014, 8.);\n#if 1\n\t// trunks front\n\tval1 *= trunk(0.79+sin(time*5.+.4 )*0.008, uv+vec2(.2  , 0.), 1.2, .054, 4.);\n\tval1 *= trunk(0.77+sin(time*5.+.47)*0.004, uv+vec2(.27 , 0.), 1.2, .024, 8.);\n\tval1 *= trunk(0.72+sin(time*5.+.6 )*0.003, uv+vec2(-1.5, 0.), 2.2, .094, 3.);\n\tval1 *= trunk(0.72+sin(time*5.+.8 )*0.006, uv+vec2(-1.3, 0.), 2.2, .034, 10.);\n\t// trunks far\n\tval2 *= trunk(0.78+sin(time*5.-.64)*0.008, uv+vec2(.03 , 0.), 0.9, .013, 9.);\n\tval2 *= trunk(0.76+sin(time*5.-.27)*0.007, uv+vec2(.15 , 0.), 1.1, .030, 9.);\n\tval3 *= trunk(0.78+sin(time*5.-.37)*0.007, uv+vec2(-.15, 0.), 0.8, .010, 8.);\n\tval3 *= trunk(0.72+sin(time*5.+.37)*0.007, uv+vec2(-1.04,0.), 0.7, .013, 4.);\n#endif\n#if 1\n\t// far firs#1\n    float bb = 0.;\n\tfor (int b=0; b<7; b++)\n\t{\n    \tfloat rand = hash(bb*10.);\n\t    val3 *= fir(0.77+sin(time*5.+.37+rand)*0.007-bb*.010, uv+vec2(-.18-bb*.14-rand*.13 ,0.), 0.28+rand*.3,.011+rand*.003, 3.);\tbb += 1.;\n\t}\n\t// very far firs#2\n\tbb = 0.;\n\tfor (int b=0; b<7; b++)\n\t{\n    \tfloat rand = hash(bb*10.);\n\t    val3 *= fir(0.77+sin(time*5.-.37+rand*1.41)*0.004-bb*.009, uv+vec2(-.20-bb*.10-rand*.08 ,0.), 0.22+rand*.3,.007+rand*.003, 1.);\tbb += 1.;\n\t}\n#endif\t\n\t\n\tvec3 col  = vec3(0., 0., 0.);\n\tvec3 tcol = vec3(0., 0., 0.);\n\t\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tvec2 s = xy*vec2(1.75,1.2);\n\t\n\t// get camera position and view direction\n\tvec3 campos = vec3(0.0, 0.0, 0.0);\n\tvec3 camtar = vec3(0.0, 0.35, 1.0);\n\t\n\tvec3 light       = normalize( vec3(  0.1, 0.55,  0.9 ) );\n\t\n\tfloat roll = 0.0;\n\tvec3 cw = normalize(camtar-campos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw );\n\tfloat sundot = clamp(dot(rd,light),0.0,1.0);\n\n\tif (val2<.99)\n\t\ttcol = 0.8*vec3(1.0,1.0,1.0)*pow( sundot, 300.0 );\n\n\t// render sky\n    float t = pow(1.0-0.7*rd.y, 1.0);\n    col += vec3(.1, .2, .4)*(1.0-t);\n    // moon\n    col += 0.30*min(vec3(2.0, 2.0, 2.0), vec3(2.0,2.0,2.0)*pow( sundot, 350.0 ));\n    // moon haze\n    col += 0.6*vec3(0.8,0.9,1.0)*pow( sundot, 6.0 );\n    // stars\n\tvec3 stars = vec3(0.,0.,0.);\n\tif (t<1.0)\n\t{\n\t\tvec3 scol = clamp(vec3(1.2, 1.0, 0.8) * pow(noise(uv*120.), 120.) * 50. * (.5-pow(t,20.)), 0.0, 1.0);\n\t\tscol += clamp(vec3(1.2, 1.0, 0.8) * pow(noise(uv*160.), 300.) * 40. * (.5-pow(t,20.)), 0.0, 1.0);\n\n\t\tfloat st = 100.;\n\t\tfloat grow = .0;\n\t\tfor (int i=0; i<12; i++)\n\t\t{\n        \tfloat sundot2 = clamp(dot(rd,normalize( vec3( 2.*noise(vec2(st, 0.))-1., noise(vec2(st, 1876.))+.3,  0.9 ) )),0.0,1.0);\n\t    \tscol += 0.200*vec3(6.0,5.0,2.0)*pow( sundot2, 190000.0-grow );\n\t\t\tst += 11.;\n\t\t\tgrow += 9000.;\n\t\t}\n\t\tstars = scol * (.3+.7*fbm(vec3(time*80., 10.0*uv.x+55.0*uv.y, 0.)));\n\t}\t\n\t\n\t// Clouds\n    vec2 shift = vec2( time*200.0, time*280.0 );\n    vec4 sum = vec4(0,0,0,0); \n#if 1\n\tfor (int q=1000; q<1060; q++) // 120 layers\n    {\n      if (sum.w>0.999) break;\n      float c = (float(q-1000)*10.0+350.0-campos.y) / rd.y; // cloud height\n      vec3 cpos = campos + c*rd + vec3(831.0+shift.x, 321.0+float(q-1000)*.15-shift.x*0.2, 1330.0+shift.y); // cloud position\n      float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.0015 ))*.9; // fractal cloud density\n      vec3 localcolor = mix(vec3( 1.1, 1.05, 1.0 ), 0.7*vec3( 0.4,0.4,0.3 ), alpha); // density color white->gray\n      alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer's density, the more the higher layers will be hidden)\n      sum += vec4(localcolor*alpha, alpha); // sum up weightened color\n    }\n#endif\n\tfloat alpha = smoothstep(0.7, 1.0, sum.w);\n    sum.rgb /= sum.w+0.0001;\n    sum.rgb -= 0.6*vec3(0.8, 0.75, 0.7) * pow(sundot,10.0)*alpha;\n    sum.rgb += 0.2*vec3(1.2, 1.2, 1.2) * pow(sundot,5.0)*(1.0-alpha);\n\n\tif (t<1.)\n    \tcol = mix( col, sum.rgb , 1.0*sum.w*pow(sundot,3.0)*(1.0-pow(t,10.)) );\n\n\t\n\t// stars\n\tcol += 1.0*stars*(1.-sum.w*sum.w);\n\n\t// trees #3\n    col = col*val3 + (1.-t*.8)*vec3(0.3, 0.4, 0.5)*(1.0-val3);\n\t// trees #2\n    col = col*val2 + (1.-t*.8)*vec3(0.1, 0.2, 0.3)*(1.0-val2);\n\t\n\t// moving fog\n    float c = 650.0 / (rd.x-1.1);\n    vec3 cpos = campos + c*rd + vec3(831.0-time*1000., 321.0, 0.0);\n    col += fbm( cpos*0.0015 )*.3 - .10;\n\n\t// trees #1\n\tcol *= val1; // trees\n\t// tree-moon glow\n\tcol += 1.2*tcol*(1.-sum.w*sum.w);\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dl3z7","date":"1367186507","viewed":7892,"name":"Haunted Forest","username":"frankenburgh","description":"Some 'naked' trees in a dark, foggy moonshine with flickering stars... Sorry, trees are only 2d objects and 'hard' coded. Some DOF at front-trees.","likes":112,"published":1,"flags":0,"usePreview":1,"tags":["clouds","dof","sky","fog","tree","forest","stars","moon"],"hasliked":0,"parentid":"","parentname":""}}