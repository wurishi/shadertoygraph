{"ver":"0.1","info":{"id":"sdyGRh","date":"1644800834","viewed":68,"name":"Lean Rasterization","username":"pk2016","description":"矩阵转换","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"7s33DB","parentname":"translation"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141593;\nconst float Deg2Rad = 0.01745329;\n\nstruct vertex\n{\n    vec3 pos;\n    vec3 col;\n};\n\nint vertexIndex = 0;\nint triangleIndex = 0;\nvertex allVertex[300];\nint allTriangle[300];\nvec3 viewportVertex[300];\n\n\nmat4 getModelMatrix(vec3 position, vec3 rotation, vec3 scale)\n{\n    rotation *= Deg2Rad;\n    \n    float cx = cos(rotation.x);\n    float cy = cos(rotation.y);\n    float cz = cos(rotation.z);\n    \n    float sx = sin(rotation.x);\n    float sy = sin(rotation.y);\n    float sz = sin(rotation.z);\n    \n    mat4 rx = mat4(1);\n    mat4 ry = mat4(1);\n    mat4 rz = mat4(1);\n    \n    rx[1][1] = cx;\n    rx[1][2] = sx;\n    rx[2][1] = -sx;\n    rx[2][2] = cx;\n\n    ry[0][0] = cy;\n    ry[0][2] = -sy;\n    ry[2][0] = sy;\n    ry[2][2] = cy;\n    \n    rz[0][0] = cz;\n    rz[0][1] = sz;\n    rz[1][0] = -sz;\n    rz[1][1] = cz;\n    \n    mat4 scaleMat = mat4(1);\n    scaleMat[0][0] = scale.x;\n    scaleMat[1][1] = scale.y;\n    scaleMat[2][2] = scale.z;\n    \n    mat4 posMat = mat4(1);\n    posMat[3] = vec4(position,1);\n    \n    return posMat * scaleMat * rz * ry * rx;\n}\n\nmat4 getViewMatrix(vec3 pos, vec3 forward, vec3 up)\n{\n    mat4 posMat = mat4(1);\n    posMat[3] = vec4(-pos,1);\n    \n    vec3 fXu = cross(forward,up);\n    mat4 rotaMat = mat4(\n    fXu.x,up.x,-forward.x,0,\n    fXu.y,up.y,-forward.y,0,\n    fXu.z,up.z,-forward.z,0,\n    0,0,0,1);\n    \n    return rotaMat * posMat;\n}\n\nmat4 getProjectionMatrix(float fovy, float aspectRatio, float near, float far)\n{\n    \n    float up = tan(fovy * Deg2Rad*0.5) * abs(near);\n    float down = -up;\n    float n = near;\n    float f = far;\n    float right = aspectRatio * up;\n    float left = -right;\n    mat4 moveMat = mat4(1);\n    moveMat[3] = vec4(-(left+right)*0.5,-(up+down)*0.5,-(n+f)*0.5,1);\n    \n    mat4 scaleMat = mat4(1);\n    scaleMat[0][0] = 2./(right - left);\n    scaleMat[1][1] = 2./(up - down);\n    scaleMat[2][2] = 2./(n - f);\n    mat4 pMat = mat4(\n    n,0,0,0,\n    0,n,0,0,\n    0,0,n+f,1,\n    0,0,-n*f,0);\n    return scaleMat * moveMat * pMat;\n}\n\nmat4 getViewportMatrix()\n{\n    //将NDC转换到视口空间\n    float halfW = iResolution.x*0.5;\n    float halfH = iResolution.y*0.5;\n    return mat4(\n    halfW,0,0,0,\n    0,halfH,0,0,\n    0,0,-0.5,0,\n    halfW,halfH,0.5,1);\n}\n\nbool insideTriangle(in vec2 fragCoord,in vec3 ta,in vec3 tb,in vec3 tc)\n{\n    vec3 a = vec3(ta.xy,1);\n    vec3 b = vec3(tb.xy,1);\n    vec3 c = vec3(tc.xy,1);\n\n    vec3 d = vec3(fragCoord,1);\n    \n    vec3 x = cross(a-b, a-d);\n    vec3 y = cross(b-c, b-d);\n    vec3 z = cross(c-a, c-d);\n    \n    if(dot(x,y) > 0. && dot(y,z) > 0.)//x.z > 0.0 && \n    {\n        return true;\n    }\n\n    return false;\n}\n\nvoid addVertex(in vec4 pos, in vec3 col)\n{\n    vertex v;\n    v.pos = pos.xyz;\n    v.col = col;\n    allVertex[vertexIndex++] = v;\n}\n\nvoid addTriangle(int a, int b, int c)\n{\n    allTriangle[triangleIndex++] = a;\n    allTriangle[triangleIndex++] = b;\n    allTriangle[triangleIndex++] = c;\n}\n\nvoid addTriangleModel(in mat4 mv)\n{\n    int startIndex = vertexIndex;\n    addVertex(mv* vec4(0,0,0,1), vec3(1,0,0));\n    addVertex(mv* vec4(1,0,1,1), vec3(0,1,0));\n    addVertex(mv* vec4(1,0,-1,1), vec3(0,0,1));\n    addTriangle(startIndex, startIndex+1,startIndex+2);\n}\n\nvoid createModel(in mat4 viewMat)\n{\n    float m = sin(iTime*3.0);\n    float t = 45.* m;\n    mat4 m0 = getModelMatrix(vec3(0,-m,0),vec3(0,0,t),vec3(1));\n    mat4 m1 = getModelMatrix(vec3(0,-m,0),vec3(0,180,-t),vec3(1));\n    addTriangleModel(viewMat * m0);\n    addTriangleModel(viewMat * m1);\n}\n\n// pvp = viewport * projection\nvoid transToViewport(in mat4 pvp)\n{\n    for(int i = 0; i < vertexIndex;i++)\n    {\n        vec4 v = pvp * vec4(allVertex[i].pos,1);\n        viewportVertex[i] = (v/v.w).xyz;\n    }\n}\n\nvec3 computeBarycentric2D(float x, float y, in vec3 a, in vec3 b, in vec3 c)\n{\n    vec3 bary = vec3(0);\n    bary.x = (x*(b.y - c.y) + (c.x - b.x)*y + b.x*c.y - c.x*b.y) / (a.x*(b.y - c.y) + (c.x - b.x)*a.y + b.x*c.y - c.x*b.y);\n    bary.y = (x*(c.y - a.y) + (a.x - c.x)*y + c.x*a.y - a.x*c.y) / (b.x*(c.y - a.y) + (a.x - c.x)*b.y + c.x*a.y - a.x*c.y);\n    bary.z = (x*(a.y - b.y) + (b.x - a.x)*y + a.x*b.y - b.x*a.y) / (c.x*(a.y - b.y) + (b.x - a.x)*c.y + a.x*b.y - b.x*a.y);\n    return bary;\n}\n\nfloat getTriangleDepth(in vec2 frag, int t)\n{\n    int index0 = allTriangle[t];\n    int index1 = allTriangle[t + 1];\n    int index2 = allTriangle[t + 2];\n    \n    vec3 a = viewportVertex[index0];\n    vec3 b = viewportVertex[index1];\n    vec3 c = viewportVertex[index2];\n    \n    // 判断范围是否正确\n    vec3 minP = min(min(a,b),c);\n    vec3 maxP = max(max(a,b),c);\n    \n    if(minP.x > frag.x || maxP.x < frag.x \n    || minP.y > frag.y || maxP.y < frag.y\n    || minP.z > 1.0 || maxP.z < 0.0)\n    {\n        return 1.0;\n    }\n    \n    if(insideTriangle(frag, a, b, c))\n    {\n        //利用重心坐标插值出 深度\n        vec3 bary = computeBarycentric2D(frag.x, frag.y, a,b,c);\n        \n        float z0 = allVertex[index0].pos.z;\n        float z1 = allVertex[index1].pos.z;\n        float z2 = allVertex[index2].pos.z;\n        //深度矫正\n        float z = 1.0/( bary.x / z0 + bary.y / z1 + bary.z / z2);\n        float zp = a.z * bary.x /z0 +  b.z * bary.y/z1  +  c.z * bary.z/z2;\n        zp *= z;\n        return zp;\n    }\n    \n    return 1.0;\n}\n\nvec3 getTriangleColor(in vec3 pos, int t)\n{\n    vertex va = allVertex[allTriangle[t]];\n    vertex vb = allVertex[allTriangle[t+1]];\n    vertex vc = allVertex[allTriangle[t+2]];\n\n    vec3 bary = computeBarycentric2D(pos.x, pos.y, va.pos,vb.pos,vc.pos);\n\n    vec3 color = va.col * bary.x  +  vb.col * bary.y  +  vc.col * bary.z;\n    return color;\n    //vec3 normal = normalize(va.normal * bary.x  +  vb.normal * bary.y  +  vc.normal * bary.z);\n    //return phongShader(pos,normal,color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n    float zNear = -0.3;\n    float zFar = -1000.0;\n    \n    float fovY = 50.0+ 15.* sin(iTime);\n    vec3 camPos = vec3(4.*cos(iTime),-1,4.*sin(iTime));\n    vec3 camForward = normalize(-camPos);\n    vec3 camUp = normalize(cross(camForward,vec3(-sin(iTime),0,cos(iTime))));\n    \n    mat4 mat = getViewportMatrix() * getProjectionMatrix(fovY, aspectRatio, zNear, zFar);\n    createModel(getViewMatrix(camPos, camForward, camUp));\n    transToViewport(mat);\n    \n    //计算环境光\n    float k = iResolution.y/(2.0*tan(fovY * Deg2Rad*0.5));\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec3 dir = normalize(camForward*k + uv.y* camUp*iResolution.y + iResolution.x*uv.x * cross(camForward, camUp));\n    vec3 col = texture(iChannel0,dir).xyz;\n    \n    float depth = 1.0;\n    for(int i = 0; i < triangleIndex; i+=3)\n    {\n        float newDepth = getTriangleDepth(fragCoord, i);\n        if(newDepth < depth)\n        {\n            depth = newDepth;\n            vec4 pos = inverse(mat)*vec4(fragCoord,depth,1);\n            col = getTriangleColor((pos/pos.w).xyz, i);\n        }\n    }\n        \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}