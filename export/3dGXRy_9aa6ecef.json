{"ver":"0.1","info":{"id":"3dGXRy","date":"1574269861","viewed":316,"name":"Geometric Tiles","username":"saidwho12","description":"Fork of https://www.shadertoy.com/view/3sKSDD with AO, Vignette and AA.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","simplex","hexagon","vignette","ao","aa","pattern","pattern","tile","geometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Functions: hex_tile & hexagon Borrowed From: https://www.shadertoy.com/view/wtXSR4\n// Function: simplexGrid Borrowed From: https://thebookofshaders.com/11/\n// Not trying to reinvent the Wheel...\n\n// Idea Came From: https://www.sketchuptextureclub.com/textures/architecture/tiles-interior/marble-tiles/marble-geometric-patterns/geometric-marble-tiles-patterns-texture-seamless-21151\n\n// There'd be situations where you'd prefer the hexagons to be oriented to a flat\n// top postion, which means making some simple changes.\n//#define FLAT_TOP_HEXAGON\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 s = vec2(1.7320508, 1);\n#else\nconst vec2 s = vec2(1, 1.7320508);\n#endif\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453); }\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    // Below is equivalent to:\n    //return max(p.x*.866025 + p.y*.5, p.y); \n\n    return max(dot(p, s*.5), p.y); // Hexagon.\n    #else\n    // Below is equivalent to:\n    //return max(p.x*.5 + p.y*.866025, p.x); \n\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    #endif\n    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p)\n{\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    #else\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    #endif\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    #ifdef FLAT_TOP_HEXAGON\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(1, .5));\n    #else\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1));\n    #endif\n}\n\n#define PRIMARY_COLOR vec3(0.3)\n#define SECONDARY_COLOR vec3(0.8)\n#define TERNARY_COLOR vec3(1)\n\n#define AA(t, s) smoothstep(s, 0., (t))\n\nvec3 simplexGrid(vec2 st){\n \tvec2 r = vec2(0.0);\n    vec3 xyz = vec3(0.0);\n    \n    // Skew\n    r.x = 1.1547 * st.x;\n    r.y = st.y + .5 * r.x;\n    \n    // Simplex\n    vec2 p = fract(r);\n    if (p.x > p.y){\n        xyz.xy = 1. - vec2(p.x, p.y-p.x);\n        xyz.z = p.y;\n    } else {\n        xyz.yz = 1. - vec2(p.x-p.y, p.y);\n        xyz.x = p.x;\n    }\n       \n    return fract(xyz);\n}\n\nfloat renderTiles(inout vec4 outColor, in vec2 p, in float inverseScl)\n{\n    vec2 uv = getHex(p).xy;\n    \n    //outColor.rgb = vec3(uv, 0);\n    //return 0.;\n    \n \t// UV's for Y Cut Out\n    vec2 hv2 = uv;\n    hv2.x -= .57735, hv2.y += .3334;\n    vec2 hv3 = uv;\n    hv3.x += .57735, hv3.y += .3334;\n    vec2 hv4 = uv;\n    hv4.y -= .6667;\n    \n    // Y Cut out\n    float yt1 = hex(hv2) - 0.4;\n    float yt2 = hex(hv3) - 0.4;\n    float yt3 = hex(hv4) - 0.4;\n    \n    float yt = min(min(yt1, yt2), yt3) * inverseScl;\n    float ay = AA(yt, 3.);\n    \n    float t1 = -(hex(uv) - .366) * inverseScl;\n    float a1 = AA(t1, 3.);\n    \n    float t2 = max(hex(uv) - .502, -(hex(uv) - .42)) * inverseScl;\n   \tfloat a2 = AA(t2, 3.);\n    \n    // Simplex Grid\n    vec2 sg = p/3.;\n    sg *= 3.*1.73;\n    vec3 sg1 = simplexGrid(sg);\n    \n    // Grid Lines\n    float tg1 = (min(min(sg1.x, sg1.y), sg1.z) - 0.015) * inverseScl;\n    float gl = AA( tg1 , 3.);\n    \n    float t3 = inverseScl * (abs(p.x) - .1);\n    float a3 = gl;//AA(t3, 3.);\n    \n    outColor.rgb = mix(outColor.rgb, PRIMARY_COLOR, a1 * ay);\n    outColor.rgb = mix(outColor.rgb, SECONDARY_COLOR, a2 * ay);\n    //outColor.rgb = mix(outColor.rgb, TERNARY_COLOR, a3 * ay * a2);\n    \n    float tg2 = max(tg1,0.) * 0.3;\n    outColor.rgb = mix(outColor.rgb, TERNARY_COLOR, a3 * ay * a1);\n    //outColor.rgb *= 1. - .8 * exp(-4. * tT) * (1.-aT);\n    \n    return max(t1, yt);\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy, p = (u+u-R)/R.y, w = u/R;\n    \n    O = vec4(1);\n    \n    \n   \tfloat t = renderTiles(O, p, R.y);\n   \tt = min(t, renderTiles(O, p - vec2(.1111, .064)*4.5, R.y) );\n   \tt = min(t, renderTiles(O, p - vec2(0, .128)*4.5, R.y) );\n    \n    // Ambient occlusion from tiles\n    \n    float alpha = smoothstep(3.0, 0.0, t);\n    O.rgb *= 1. - clamp(exp(-0.3 * t), 0.0, 1.0) * (1.-alpha);\n    //O.rgb = vec3(alpha);\n    \n    // Vignette effect\n    float vign = w.x * (1.-w.x) * w.y * (1.-w.y);\n    O.rgb *= 1. - .6 * exp(-120.*vign);\n}","name":"Image","description":"","type":"image"}]}