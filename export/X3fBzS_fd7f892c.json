{"ver":"0.1","info":{"id":"X3fBzS","date":"1728572113","viewed":70,"name":"misis logo animated","username":"den_vologda","description":"this is the logo of misis university :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["logo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(55.0/255.0, 235.0/255.0, 255.0/255.0)\n#define blue12 vec3(60.0/510.0, 300.0/510.0, 495.0/510.0)\n#define blue2 vec3(5.0/255.0, 65.0/255.0, 240.0/255.0)\n\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n\nfloat get_rot_x(vec2 uv, vec2 c, float pi_round) {\n    //return 0.6;\n    float oh_x = uv.x-c.x;\n    float oh_y = uv.y-c.y;\n    float rot_x = oh_x*cos(pi_round)-oh_y*sin(pi_round);\n    return rot_x;\n}\n\nfloat get_rot_y(vec2 uv, vec2 c, float pi_round) {\n    return 0.7;\n    float oh_x = uv.x-c.x;\n    float oh_y = uv.y-c.y;\n    float rot_y = oh_y*cos(pi_round)+oh_x*sin(pi_round);\n    return rot_y;\n}\n\n\nfloat right_angle(vec2 uv, vec2 center) {\n    if (uv.x >= center.x) return atan((center.y-uv.y)/(center.x-uv.x));\n    else return (atan((center.y-uv.y)/(center.x-uv.x)) + M_PI);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width, float angle_from, float angle_to)\n{\n    float r = length(uv - center);\n\n    if (!((right_angle(uv, center) >= angle_from && right_angle(uv, center) <= angle_to) \\\n       || (right_angle(uv, center)+2.0*M_PI >= angle_from && right_angle(uv, center)+2.0*M_PI <= angle_to) \n       || (right_angle(uv, center)+4.0*M_PI >= angle_from && right_angle(uv, center)+4.0*M_PI <= angle_to)\n       || (right_angle(uv, center)+6.0*M_PI >= angle_from && right_angle(uv, center)+6.0*M_PI <= angle_to)\n       // if you reading this, please, send us a photo of your cat :)\n       || (right_angle(uv, center)-2.0*M_PI >= angle_from && right_angle(uv, center)-2.0*M_PI <= angle_to)\n       || (right_angle(uv, center)-4.0*M_PI >= angle_from && right_angle(uv, center)-4.0*M_PI <= angle_to)\n       || (right_angle(uv, center)-6.0*M_PI >= angle_from && right_angle(uv, center)-6.0*M_PI <= angle_to))) return 0.0;\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n    \n    vec2 uv = fragCoord.xy;\n    vec2 c = iResolution.xy/2.0;\n\n    float pi_round = -1.0 * (iTime*2.0 - float(int(iTime*2.0 / 4.0 / M_PI)) * 4.0 * M_PI);\n    \n    float rad1_x = get_rot_x(uv, c, (-pi_round*2.0) + M_PI - M_PI/4.0) / 90.0;\n    float rad1_y = 0.5; \n    vec3 grad1 = vec3(clamp((rad1_x) + (rad1_y), blue2[0], blue1[0]),\n                     clamp((rad1_x) + (rad1_y), blue2[1], blue1[1]),\n                     clamp((rad1_x) + (rad1_y), blue2[2], blue1[2]));\n    \n    float rad2_x = get_rot_x(uv, c, 3.0*(-pi_round/2.0) - M_PI/4.0) / 150.0;\n    float rad2_y = 0.4; \n    vec3 grad2 = vec3(clamp((rad2_x) + (rad2_y), blue2[0], blue1[0]),\n                     clamp((rad2_x) + (rad2_y), blue2[1], blue1[1]),\n                     clamp((rad2_x) + (rad2_y), blue2[2], blue1[2]));\n    \n    float rad3_x = get_rot_x(uv, c, (-pi_round/2.0 + M_PI/2.0)) / 200.0;\n    float rad3_y = 0.35; \n    vec3 grad3 = vec3(clamp((rad3_x) + (rad3_y), blue2[0], blue1[0]),\n                     clamp((rad3_x) + (rad3_y), blue2[1], blue1[1]),\n                     clamp((rad3_x) + (rad3_y), blue2[2], blue1[2]));\n    \n    float rad4_x = get_rot_x(uv, c, -pi_round-M_PI/2.0) / 200.0;\n    float rad4_y = 0.35; \n    vec3 grad4 = vec3(clamp((rad4_x) + (rad4_y), blue2[0], blue1[0]),\n                     clamp((rad4_x) + (rad4_y), blue2[1], blue1[1]),\n                     clamp((rad4_x) + (rad4_y), blue2[2], blue1[2]));\n\n    finalColor += ( circle(uv, c, 20.0, 40.0, pi_round, pi_round + 2.0*M_PI) * grad1 +\n                    circle(uv, c, 60.0, 40.0, 3.0*pi_round/2.0, 3.0*pi_round/2.0 + 3.0*M_PI/2.0) * grad2 +\n                    circle(uv, c, 100.0, 40.0, pi_round / 2.0 - M_PI/2.0, pi_round / 2.0 + M_PI/2.0) * grad3 + \n                    circle(uv, c, 140.0, 40.0, pi_round + M_PI/2.0, pi_round + 3.0*M_PI/2.0) * grad4) ;\n\n    fragColor = vec4( finalColor, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}