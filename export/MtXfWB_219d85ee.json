{"ver":"0.1","info":{"id":"MtXfWB","date":"1513117821","viewed":195,"name":"Inverse smoothstep sample","username":"aardappel","description":"Added trippy variation to https://www.shadertoy.com/view/ldsSRX which uses an inverse smoothstep instead of fwidth, which gives an interesting \"compromise\" between bilinear and nn.\nCan be optimized I'm sure :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["texture","sampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 saturate(vec2 x)\n{\n\treturn clamp(x, 0.0, 1.0);   \n}\n\nvec2 inverse_smoothstep(vec2 x) {\n    return x + (x - (x * x * (3.0f - 2.0f * x)));\n}\n\nvec2 smoothnn(vec2 uv)\n{\n    uv *= iChannelResolution[0].xy; \n    return (inverse_smoothstep(inverse_smoothstep(fract(uv))) + floor(uv)) / iChannelResolution[0].xy;\n}\n\nvec2 magnify(vec2 uv)\n{\n    uv *= iChannelResolution[0].xy; \n    return (saturate(fract(uv) / saturate(fwidth(uv))) + floor(uv) - 0.5) / iChannelResolution[0].xy;\n}\n\nvec2 quantize(vec2 uv)\n{\n    return (floor(uv * iChannelResolution[0].xy) + 0.5) / iChannelResolution[0].xy;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 sc = fragCoord / iResolution.xy;\n    \n\tvec2 uv = vec2(sc.x * 0.1 - 0.05, 0.1) / (sc.y - 1.0);\n\tuv *= mat2(sin(iTime * 0.1), cos(iTime * 0.1), -cos(iTime * 0.1), sin(iTime * 0.1));\n\t\t\t\n\tvec2 uvMod = sc.x < 0.25 ? uv : sc.x < 0.50 ? smoothnn(uv) : sc.x < 0.75 ? magnify(uv) : quantize(uv);\n\n\tfragColor = textureGrad(iChannel0, uvMod, dFdx(uv), dFdy(uv));\n}","name":"Image","description":"","type":"image"}]}