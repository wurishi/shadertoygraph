{"ver":"0.1","info":{"id":"ddcGD7","date":"1677353262","viewed":70,"name":"3d or 2d ?","username":"Masqualero","description":"specular lighting in 2.5 dimensions","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["25d","mode7"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate2d(vec2 p, float a){\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\n//direction of surface along unit sphere\nvec3 get_normal(vec2 p){\n\n    //height calculation\n    float bz  = texture(iChannel0, p.xy).x+\n                texture(iChannel0, p.xy + vec2(0.01, 0.0)).y+\n                texture(iChannel0, p.xy + vec2(0.0, 0.01)).z;\n    bz /= 3.0;\n    \n    //difference of x\n    float bx  = texture(iChannel0, p.xy).x -\n                texture(iChannel0, p.xy + vec2(0.01, 0.0)).x;\n    bx = clamp(bx * 4.0, -1.0, 1.0);\n    \n    //difference of y\n    float by  = texture(iChannel0, p.xy).x -\n                texture(iChannel0, p.xy + vec2(0.0, 0.01)).x;\n    by = clamp(by * 4.0, -1.0, 1.0);\n    \n    \n    return normalize( vec3(bx, by, bz) );\n    \n}\n\n//coincedince of reflected light ray, and camera\nfloat get_spec(vec3 p, vec3 rd, vec3 lpos){\n    vec3 vl = -normalize(lpos - p);\n    vec3 r = reflect( vl, get_normal(p.xy * 0.5) );\n    float spec = dot(rd, r);\n    return pow(clamp(spec, 0.0, 1.0), 2.0) * 0.5;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy - 0.5 );\n    \n    //distort camera along parabolic curve\n    uv.y -= (1.0 - uv.x * uv.x) * 0.15;\n    \n    //move camera on vertical axis\n    uv.y += sin(iTime * 2.0) *0.5 - 0.1 ;\n    \n    //rotate around forward axis\n    uv = rotate2d(uv, sin(iTime) * 0.5) ;\n    \n    //camera position in 3d space\n    vec3 spacepos = vec3(iTime, iTime,  1.0);\n    \n    //position of ray in 3d space, as per mode 7\n    //add focal length to y element\n    //and, and a small value to z element to prevent division by zero\n    vec3 pos = vec3(uv.x, abs(uv.y) + 1.0, abs(uv.y) + 0.01);\n    \n    //rotate around vertical axis\n    //sepereate from other rotation because its easier\n    pos.xy = rotate2d(pos.xy, iTime * 0.8);\n    \n    //weak perspective projection\n    vec2 proj = pos.xy / pos.z;\n    \n    //shifts texture by the x and y space components\n    proj += spacepos.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 lightpos = vec3(-4, 4, 3) ;\n    \n    //if below horizon\n    if (uv.y<0.0){\n    \n        col = texture(iChannel0, proj * 0.5).xyz;\n        \n        //ground height is estimated to be 0.0\n        col  += get_spec( vec3( proj.xy, 0.0), normalize(vec3(uv, 1.0)), spacepos + lightpos) * pos.z;\n    \n    }\n    else col = texture(iChannel1, pos.xzy * vec3(3, 1.5, 2)).xyz;\n    \n    //fog :)\n    col = mix(vec3(0.3, 0.4, 0.5), col, pos.z);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}