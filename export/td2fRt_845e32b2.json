{"ver":"0.1","info":{"id":"td2fRt","date":"1590635523","viewed":82,"name":"Twisted sand","username":"tono","description":"sand","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sand"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M(x,y) mod(x,y) - y/2.\n#define saturate(x) clamp(x,0.,1.)\n#define hclamp(x) clamp(x,-0.5,0.5)\n\nmat2 rot(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere(vec3 p,float size)\n{\n    return length(p) - size;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n//----------------------------------------------\n\n//http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat random2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n//-------------------------------------------------------------\n\n\nfloat Noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float v00 = random2(p+vec2(0.,0.));\n    float v10 = random2(p+vec2(1.,0.));\n    float v01 = random2(p+vec2(0.,1.));\n    float v11 = random2(p+vec2(1.,1.));\n\n    return mix( mix( dot( vec2(v00), f - vec2(0.,0.) ), dot( vec2(v10), f - vec2(1.,0.) ), u.x ),\n                 mix( dot( vec2(v01), f - vec2(0.,1.) ), dot( vec2(v11), f - vec2(1.,1.) ), u.x ), \n                 u.y)+0.5;\n}\n\nfloat fbm (vec2 st) \n{\n    float f = 0.;\n    vec2 q = st;\n    for(int i = 1 ;i < 4;i++){\n        f += Noise(q)/pow(2.,float(i) );\n        q = q * (2.00+float(i)/100.);\n    }\n\n    return f;\n}\n\nfloat meltIce(vec3 p ,float tdist, float size)\n{\n    vec3 sp = p;\n    float s = sdEllipsoid(sp,vec3(0.5,0.2,0.5) * size);\n    \n    vec3 b=p + vec3(0.,tdist,0.) ; \n    b.xz *= rot(p.y * 20. + iTime * 2.4 );\n    b.yx *= rot(p.x * 15. );\n    b.zy *= rot(p.z * 10.);\n    \n    float box = sdBox(b ,vec3(0.1)*size);\n    s = smin(box,s,1.5);\n    return s;\n}\n\nfloat map(vec3 p)\n{\n    p.y -= 1.;\n    vec4 n = vec4(0.0, 1.0, 0.0, 0.9);\n    vec3 pp = p;\n    pp.y += fbm(pp.xz*2. +vec2(2.,-1.1)*iTime);\n    float plane = sdPlane(pp,n);\n    \n    vec3 mIp = p - vec3(0.,0.5,0.);\n    \n    vec2 areaID = floor(mIp.xz/5.);\n    mIp.xz = mod(mIp.xz,5.) - 0.5 * 5.;\n    float mI = meltIce(mIp + vec3(0.,0.5,0.) , 0.8,1.0);\n    vec3 ppp = p;\n    vec2 pillerSize = vec2(.8,0.2);\n    pillerSize.x -=saturate( sin(iTime) )/2.;\n    ppp.xz = mod(ppp.xz,5.)-5./2.;\n    ppp.yz *= rot(acos(-1.)/2.);\n    float piller = sdCone(ppp,pillerSize);\n    float hashid = random2(areaID);\n    for(int i = 1 ; i<7 ; i+=2)\n    {\n        mIp += vec3(2.,0.,2.) * (random2(vec2(float(i)) ) - 0.5) ;\n        \n        float h =  saturate(sin(iTime/float(i) + float(i)*8. + 6.*hashid ) + 0.5);\n        h = h * h * h + sin(iTime*2.+hashid*11.)/10.;\n        mIp.y += h;\n        mIp.xz *= rot(0.1 + float(i)* 3.);\n        mI = smin(mI,meltIce(mIp,0.8,0.4 + float(i)/15.),0.3);\n    }\n   // mI = smin(mI,piller,0.9);\n    return smin(mI,plane,0.9) + 0.09;\n}\n\nvec2 castRay(vec3 ro,vec3 rd)\n{\n    float c = 0.;\n    float cyc = 0.;\n    for(int i = 0; i < 100; i ++)\n    {\n        vec3 rp = ro + c * rd;\n        float d = map(rp);\n        float dist = length(ro - rp);\n        if(d < 0.00001){\n            break;\n        }\n        c += d;\n        cyc += 1.;\n    }\n    if(c > 20.){c = -1.;}\n\treturn vec2(c,cyc);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 -iResolution.xy) / min(iResolution.x, iResolution.y);\n    p.y = -p. y;\n\tvec3 co = vec3(-0.8,0.,-12.);\n    co.z *= hclamp(sin(iTime/16.))*2.;\n    co.y += hclamp( cos(iTime/4.) )*hclamp( cos(iTime/4.) )*.5;\n    \n    co.xz *= rot(iTime/35.);\n    vec3 target = vec3(0.,8.5,0.);\n    target.y += 34.*(hclamp(sin(iTime/6.)));\n    vec3 cd = normalize(target - co);\n    vec3 cu = vec3(0.,1.,0.);\n    vec3 cs = normalize(cross(cu , cd));\n    cu = normalize(vec3(cross(cs,cd)));\n    \n    float fov = (1. - dot(p,vec2(1.3,1.9)*p))/2.;\n    \n    vec3 rd = normalize(vec3(p.x * cs + p.y * cu + fov * cd));\n    \n    vec3 skycolor = vec3(0.6,0.3,0.4);\n    vec3 color = skycolor;\n    vec2 cr = castRay(co,rd) ;\n    \n    float crp = cr.y/90.;\n    \n    //http://sayachang-bot.hateblo.jp/entry/2019/11/30/205926\n    if(cr.x > 0.)\n    {\n    \tvec3 N = calcNormal(co + cr.x  * rd);\n        vec3 mate=vec3(.18);\n        \n        vec3 sun_dir=normalize(vec3(.8,.4,.2));\n        sun_dir.xz *= rot(iTime/2.);\n        float sun_dif=clamp(dot(N,sun_dir),.0,1.);\n        float sun_sha=step(castRay(co+cr.x *rd+N*.001,sun_dir).x,.0);\n        float sky_dif=clamp(.5+.5*dot(N,vec3(.0,1.,.0)),.0,1.);\n        float bou_dif=clamp(.5+.5*dot(N,vec3(.0,-1.,.0)),.0,1.);\n        \n        color=mate*vec3(7.,4.5,3.)*sun_dif*sun_sha;\n        color+=mate*vec3(.5,.8,.9)*sky_dif;\n        color+=mate*vec3(.7,.3,.2)*bou_dif;\n        color = mix(color , skycolor, crp * crp * crp);\n    }\n    \n    color=pow(color, vec3(.4545));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}