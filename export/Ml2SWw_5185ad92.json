{"ver":"0.1","info":{"id":"Ml2SWw","date":"1444279638","viewed":608,"name":"CatmullRom Implicit & Parametric","username":"lebek","description":"Figuring out splines and implicitization. Some stuff I used:\nhttps://www.cs.cmu.edu/~fp/courses/graphics/asst5/catmullRom.pdf\nhttp://140.129.20.249/~jmchen/ana/docs/resultant/implicitization-sederbeg.pdf\nSymPy to calculate the resultant","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","spline","curve","implicit","catmullrom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nfloat onCurve(float x,float y,vec2 P0,vec2 P1, vec2 P2, vec2 P3) {\n    /* Not used. My plan was to find the root of the implicit polynomials\n     * and use that to determine if we're between P1 and P2 - then only draw \n     * that part of the curve. Doesn't work because pixels don't lie exactly \n     * on the curve.\n     */\n    float t = 0.5;\n    float a0 = P1.x;\n    float a1 = (P2.x-P0.x)*t;\n    float a2 = 2.0*t*P0.x+(t-3.0)*P1.x+(3.0-2.0*t)*P2.x-t*P3.x;\n    float a3 = -t*P0.x+(2.0-t)*P1.x+(t-2.0)*P2.x+t*P3.x;\n    float b0 = P1.y;\n    float b1 = (P2.y-P0.y)*t;\n    float b2 = 2.0*t*P0.y+(t-3.0)*P1.y+(3.0-2.0*t)*P2.y-t*P3.y;\n    float b3 = -t*P0.y+(2.0-t)*P1.y+(t-2.0)*P2.y+t*P3.y;\n \tfloat tt = (-pow(abs(a0),3.0)*b1*b3 + pow(abs(a0),3.0)*pow(abs(b2),2.0) + pow(abs(a0),2.0)*a1*b0*b3 - pow(abs(a0),2.0)*a1*b1*b2 - pow(abs(a0),2.0)*a1*b3*y - 2.0*pow(abs(a0),2.0)*a2*b0*b2 + pow(abs(a0),2.0)*a2*pow(abs(b1),2.0) + 2.0*pow(abs(a0),2.0)*a2*b2*y + pow(abs(a0),2.0)*a3*b0*b1 - pow(abs(a0),2.0)*a3*b1*y + 3.0*pow(abs(a0),2.0)*b1*b3*x - 3.0*pow(abs(a0),2.0)*pow(abs(b2),2.0)*x + a0*pow(abs(a1),2.0)*b0*b2 - a0*pow(abs(a1),2.0)*b2*y - a0*a1*a2*b0*b1 + a0*a1*a2*b1*y - a0*a1*a3*pow(abs(b0),2.0) + 2.0*a0*a1*a3*b0*y - a0*a1*a3*pow(abs(y),2.0) - 2.0*a0*a1*b0*b3*x + 2.0*a0*a1*b1*b2*x + 2.0*a0*a1*b3*x*y + a0*pow(abs(a2),2.0)*pow(abs(b0),2.0) - 2.0*a0*pow(abs(a2),2.0)*b0*y + a0*pow(abs(a2),2.0)*pow(abs(y),2.0) + 4.0*a0*a2*b0*b2*x - 2.0*a0*a2*pow(abs(b1),2.0)*x - 4.0*a0*a2*b2*x*y - 2.0*a0*a3*b0*b1*x + 2.0*a0*a3*b1*x*y - 3.0*a0*b1*b3*pow(abs(x),2.0) + 3.0*a0*pow(abs(b2),2.0)*pow(abs(x),2.0) - pow(abs(a1),2.0)*b0*b2*x + pow(abs(a1),2.0)*b2*x*y + a1*a2*b0*b1*x - a1*a2*b1*x*y + a1*a3*pow(abs(b0),2.0)*x - 2.0*a1*a3*b0*x*y + a1*a3*x*pow(abs(y),2.0) + a1*b0*b3*pow(abs(x),2.0) - a1*b1*b2*pow(abs(x),2.0) - a1*b3*pow(abs(x),2.0)*y - pow(abs(a2),2.0)*pow(abs(b0),2.0)*x + 2.0*pow(abs(a2),2.0)*b0*x*y - pow(abs(a2),2.0)*x*pow(abs(y),2.0) - 2.0*a2*b0*b2*pow(abs(x),2.0) + a2*pow(abs(b1),2.0)*pow(abs(x),2.0) + 2.0*a2*b2*pow(abs(x),2.0)*y + a3*b0*b1*pow(abs(x),2.0) - a3*b1*pow(abs(x),2.0)*y + b1*b3*pow(abs(x),3.0) - pow(abs(b2),2.0)*pow(abs(x),3.0))/(pow(abs(a0),3.0)*b2*b3 - pow(abs(a0),2.0)*a1*b1*b3 - pow(abs(a0),2.0)*a2*b0*b3 + pow(abs(a0),2.0)*a2*b3*y - pow(abs(a0),2.0)*a3*b0*b2 + pow(abs(a0),2.0)*a3*pow(abs(b1),2.0) + pow(abs(a0),2.0)*a3*b2*y - 3.0*pow(abs(a0),2.0)*b2*b3*x + a0*pow(abs(a1),2.0)*b0*b3 - a0*pow(abs(a1),2.0)*b3*y - a0*a1*a3*b0*b1 + a0*a1*a3*b1*y + 2.0*a0*a1*b1*b3*x + a0*a2*a3*pow(abs(b0),2.0) - 2.0*a0*a2*a3*b0*y + a0*a2*a3*pow(abs(y),2.0) + 2.0*a0*a2*b0*b3*x - 2.0*a0*a2*b3*x*y + 2.0*a0*a3*b0*b2*x - 2.0*a0*a3*pow(abs(b1),2.0)*x - 2.0*a0*a3*b2*x*y + 3.0*a0*b2*b3*pow(abs(x),2.0) - pow(abs(a1),2.0)*b0*b3*x + pow(abs(a1),2.0)*b3*x*y + a1*a3*b0*b1*x - a1*a3*b1*x*y - a1*b1*b3*pow(abs(x),2.0) - a2*a3*pow(abs(b0),2.0)*x + 2.0*a2*a3*b0*x*y - a2*a3*x*pow(abs(y),2.0) - a2*b0*b3*pow(abs(x),2.0) + a2*b3*pow(abs(x),2.0)*y - a3*b0*b2*pow(abs(x),2.0) + a3*pow(abs(b1),2.0)*pow(abs(x),2.0) + a3*b2*pow(abs(x),2.0)*y - b2*b3*pow(abs(x),3.0));\n\treturn tt;\n}\n\nfloat det(float x,float y,vec2 P0,vec2 P1, vec2 P2, vec2 P3) {\n    float t = 0.5;\n    float a0 = P1.x;\n    float a1 = (P2.x-P0.x)*t;\n    float a2 = 2.0*t*P0.x+(t-3.0)*P1.x+(3.0-2.0*t)*P2.x-t*P3.x;\n    float a3 = -t*P0.x+(2.0-t)*P1.x+(t-2.0)*P2.x+t*P3.x;\n    float b0 = P1.y;\n    float b1 = (P2.y-P0.y)*t;\n    float b2 = 2.0*t*P0.y+(t-3.0)*P1.y+(3.0-2.0*t)*P2.y-t*P3.y;\n    float b3 = -t*P0.y+(2.0-t)*P1.y+(t-2.0)*P2.y+t*P3.y;\n\treturn -pow(abs(a0),3.0)*pow(abs(b3),3.0) + pow(abs(a0),2.0)*a1*b2*pow(abs(b3),2.0) + 2.0*pow(abs(a0),2.0)*a2*b1*pow(abs(b3),2.0) - pow(abs(a0),2.0)*a2*pow(abs(b2),2.0)*b3 + 3.0*pow(abs(a0),2.0)*a3*b0*pow(abs(b3),2.0) - 3.0*pow(abs(a0),2.0)*a3*b1*b2*b3 + pow(abs(a0),2.0)*a3*pow(abs(b2),3.0) - 3.0*pow(abs(a0),2.0)*a3*pow(abs(b3),2.0)*y + 3.0*pow(abs(a0),2.0)*pow(abs(b3),3.0)*x - a0*pow(abs(a1),2.0)*b1*pow(abs(b3),2.0) - 3.0*a0*a1*a2*b0*pow(abs(b3),2.0) + a0*a1*a2*b1*b2*b3 + 3.0*a0*a1*a2*pow(abs(b3),2.0)*y + a0*a1*a3*b0*b2*b3 + 2.0*a0*a1*a3*pow(abs(b1),2.0)*b3 - a0*a1*a3*b1*pow(abs(b2),2.0) - a0*a1*a3*b2*b3*y - 2.0*a0*a1*b2*pow(abs(b3),2.0)*x + 2.0*a0*pow(abs(a2),2.0)*b0*b2*b3 - a0*pow(abs(a2),2.0)*pow(abs(b1),2.0)*b3 - 2.0*a0*pow(abs(a2),2.0)*b2*b3*y - a0*a2*a3*b0*b1*b3 - 2.0*a0*a2*a3*b0*pow(abs(b2),2.0) + a0*a2*a3*pow(abs(b1),2.0)*b2 + a0*a2*a3*b1*b3*y + 2.0*a0*a2*a3*pow(abs(b2),2.0)*y - 4.0*a0*a2*b1*pow(abs(b3),2.0)*x + 2.0*a0*a2*pow(abs(b2),2.0)*b3*x - 3.0*a0*pow(abs(a3),2.0)*pow(abs(b0),2.0)*b3 + 3.0*a0*pow(abs(a3),2.0)*b0*b1*b2 + 6.0*a0*pow(abs(a3),2.0)*b0*b3*y - a0*pow(abs(a3),2.0)*pow(abs(b1),3.0) - 3.0*a0*pow(abs(a3),2.0)*b1*b2*y - 3.0*a0*pow(abs(a3),2.0)*b3*pow(abs(y),2.0) - 6.0*a0*a3*b0*pow(abs(b3),2.0)*x + 6.0*a0*a3*b1*b2*b3*x - 2.0*a0*a3*pow(abs(b2),3.0)*x + 6.0*a0*a3*pow(abs(b3),2.0)*x*y - 3.0*a0*pow(abs(b3),3.0)*pow(abs(x),2.0) + pow(abs(a1),3.0)*b0*pow(abs(b3),2.0) - pow(abs(a1),3.0)*pow(abs(b3),2.0)*y - pow(abs(a1),2.0)*a2*b0*b2*b3 + pow(abs(a1),2.0)*a2*b2*b3*y - 2.0*pow(abs(a1),2.0)*a3*b0*b1*b3 + pow(abs(a1),2.0)*a3*b0*pow(abs(b2),2.0) + 2.0*pow(abs(a1),2.0)*a3*b1*b3*y - pow(abs(a1),2.0)*a3*pow(abs(b2),2.0)*y + pow(abs(a1),2.0)*b1*pow(abs(b3),2.0)*x + a1*pow(abs(a2),2.0)*b0*b1*b3 - a1*pow(abs(a2),2.0)*b1*b3*y + 3.0*a1*a2*a3*pow(abs(b0),2.0)*b3 - a1*a2*a3*b0*b1*b2 - 6.0*a1*a2*a3*b0*b3*y + a1*a2*a3*b1*b2*y + 3.0*a1*a2*a3*b3*pow(abs(y),2.0) + 3.0*a1*a2*b0*pow(abs(b3),2.0)*x - a1*a2*b1*b2*b3*x - 3.0*a1*a2*pow(abs(b3),2.0)*x*y - 2.0*a1*pow(abs(a3),2.0)*pow(abs(b0),2.0)*b2 + a1*pow(abs(a3),2.0)*b0*pow(abs(b1),2.0) + 4.0*a1*pow(abs(a3),2.0)*b0*b2*y - a1*pow(abs(a3),2.0)*pow(abs(b1),2.0)*y - 2.0*a1*pow(abs(a3),2.0)*b2*pow(abs(y),2.0) - a1*a3*b0*b2*b3*x - 2.0*a1*a3*pow(abs(b1),2.0)*b3*x + a1*a3*b1*pow(abs(b2),2.0)*x + a1*a3*b2*b3*x*y + a1*b2*pow(abs(b3),2.0)*pow(abs(x),2.0) - pow(abs(a2),3.0)*pow(abs(b0),2.0)*b3 + 2.0*pow(abs(a2),3.0)*b0*b3*y - pow(abs(a2),3.0)*b3*pow(abs(y),2.0) + pow(abs(a2),2.0)*a3*pow(abs(b0),2.0)*b2 - 2.0*pow(abs(a2),2.0)*a3*b0*b2*y + pow(abs(a2),2.0)*a3*b2*pow(abs(y),2.0) - 2.0*pow(abs(a2),2.0)*b0*b2*b3*x + pow(abs(a2),2.0)*pow(abs(b1),2.0)*b3*x + 2.0*pow(abs(a2),2.0)*b2*b3*x*y - a2*pow(abs(a3),2.0)*pow(abs(b0),2.0)*b1 + 2.0*a2*pow(abs(a3),2.0)*b0*b1*y - a2*pow(abs(a3),2.0)*b1*pow(abs(y),2.0) + a2*a3*b0*b1*b3*x + 2.0*a2*a3*b0*pow(abs(b2),2.0)*x - a2*a3*pow(abs(b1),2.0)*b2*x - a2*a3*b1*b3*x*y - 2.0*a2*a3*pow(abs(b2),2.0)*x*y + 2.0*a2*b1*pow(abs(b3),2.0)*pow(abs(x),2.0) - a2*pow(abs(b2),2.0)*b3*pow(abs(x),2.0) + pow(abs(a3),3.0)*pow(abs(b0),3.0) - 3.0*pow(abs(a3),3.0)*pow(abs(b0),2.0)*y + 3.0*pow(abs(a3),3.0)*b0*pow(abs(y),2.0) - pow(abs(a3),3.0)*pow(abs(y),3.0) + 3.0*pow(abs(a3),2.0)*pow(abs(b0),2.0)*b3*x - 3.0*pow(abs(a3),2.0)*b0*b1*b2*x - 6.0*pow(abs(a3),2.0)*b0*b3*x*y + pow(abs(a3),2.0)*pow(abs(b1),3.0)*x + 3.0*pow(abs(a3),2.0)*b1*b2*x*y + 3.0*pow(abs(a3),2.0)*b3*x*pow(abs(y),2.0) + 3.0*a3*b0*pow(abs(b3),2.0)*pow(abs(x),2.0) - 3.0*a3*b1*b2*b3*pow(abs(x),2.0) + a3*pow(abs(b2),3.0)*pow(abs(x),2.0) - 3.0*a3*pow(abs(b3),2.0)*pow(abs(x),2.0)*y + pow(abs(b3),3.0)*pow(abs(x),3.0);\n}\n\nvoid catmullCoefficients(vec2 P0,vec2 P1, vec2 P2, vec2 P3,inout vec2[4] c) {\n    float t = 0.5*(sin(iTime)*0.1+1.0);\n    c[0] = vec2(P1.x,P1.y);\n    c[1] = vec2((P2.x-P0.x)*t,(P2.y-P0.y)*t);\n    c[2] = vec2(2.0*t*P0.x+(t-3.0)*P1.x+(3.0-2.0*t)*P2.x-t*P3.x,2.0*t*P0.y+(t-3.0)*P1.y+(3.0-2.0*t)*P2.y-t*P3.y);\n    c[3] = vec2(-t*P0.x+(2.0-t)*P1.x+(t-2.0)*P2.x+t*P3.x,-t*P0.y+(2.0-t)*P1.y+(t-2.0)*P2.y+t*P3.y);\n}\n\n// Here trying the parametric form (for testing)\nvec2 catmullRomPoint(float u, vec2[4] c) {\n    return vec2(c[0].x+c[1].x*u+c[2].x*pow(u,2.0)+c[3].x*pow(u,3.0), \n                c[0].y+c[1].y*u+c[2].y*pow(u,2.0)+c[3].y*pow(u,3.0));\n}\n\n\nbool onCatmullRom(vec2 fragCoord,vec2 P0,vec2 P1, vec2 P2, vec2 P3) {\n    float x = fragCoord.x;\n    float y = fragCoord.y;\n\tfloat d = sign(det(x,y,P0,P1,P2,P3));\n    d += sign(det(x+1.0,y,P0,P1,P2,P3));\n    d += sign(det(x-1.0,y,P0,P1,P2,P3));\n    d += sign(det(x,y+1.0,P0,P1,P2,P3));\n    d += sign(det(x,y-1.0,P0,P1,P2,P3));\n    \n    return (d != 5.0 && d != -5.0);\n}\n\nbool isPoint(vec2 p, vec2 fragCoord) {\n    return (fragCoord.x > p.x-5.0 && fragCoord.x < p.x+5.0 &&\n       fragCoord.y > p.y-5.0 && fragCoord.y < p.y+5.0);\n}\n\nfloat perpDistToLine(vec2 p0, vec2 p1, vec2 p2) {\n\treturn abs((p2.y-p1.y)*p0.x-(p2.x-p1.x)*p0.y+p2.x*p1.y-p2.y*p1.x)/sqrt(pow(abs(p2.y-p1.y),2.0)+pow(abs(p2.x-p1.x),2.0));\n}\n\nfloat distAlongLineFn(vec2 p, vec2 p1, vec2 p2) {\n\treturn ((p2.x-p1.x)*(p.x-p1.x)+(p2.y-p1.y)*(p.y-p1.y))/sqrt(pow(abs(p2.y-p1.y),2.0)+pow(abs(p2.x-p1.x),2.0));\n}\n\nfloat dist(vec2 p1, vec2 p2) {\n    return sqrt(pow(abs(p2.y-p1.y),2.0)+pow(abs(p2.x-p1.x),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //P0.y = 100.0+100.0*sin(iTime/100.0);\n    //P0.x = 200.0-100.0*cos(iTime/100.0);\n    //P0.y += sin(iTime-10.0)*20.0;\n    //P3.x = iMouse.x;\n    bool drawStepMarks = false;\n    vec2 points[5];\n    points[0] = vec2(-10.0, 100.0);\n    points[1] = vec2(40.0, 190.0);\n    points[2] = vec2(300.0, 170.0);\n    points[3] = vec2(450.0, 90.0);\n    points[4] = vec2(600.0, 950.0);\n    \n    points[2].y = iMouse.y;\n    points[2].x = iMouse.x;\n    \n    for (int i = 0; i < 5; i++) { \n        if (isPoint(points[i], fragCoord)) {\n            fragColor = vec4(1,1,1,1.0);\n            return;\n        }\n    }\n    \n    \n    for (int j = 0; j < 5-3; j++) {\n        vec2 seg1_coef[4];\n        catmullCoefficients(points[j],points[j+1],points[j+2],points[j+3],seg1_coef);\n\n        vec2 last_pt = points[j+1];\n        vec2 this_pt;\n        for (int i = 0; i <= 100; i++) {\n            this_pt = catmullRomPoint(float(i)/100.0,seg1_coef);\n            \n            if (drawStepMarks && isPoint(this_pt, fragCoord)) {\n                fragColor = vec4(1,1,1,1.0);\n                return;\n            }\n\n            float distToLine = perpDistToLine(fragCoord, last_pt, this_pt);\n            float distAlongLine = distAlongLineFn(fragCoord, last_pt, this_pt);\n            float distFromLastPt = dist(last_pt, this_pt);\n            bool onSegment = distAlongLine > 0.0 && distAlongLine < distFromLastPt;\n            if (distToLine <= 1.6 && onSegment) {\n                fragColor = vec4(1,1,1,1.0);\n                return;\n            } else if (distToLine > 0.6 && distToLine < 1.6 && onSegment) {\n                //float grad = 1.0-(distToLine-0.6);\n                //fragColor = vec4(0.5+(0.5*grad),(fragCoord.y/iResolution.y)+(1.0-(fragCoord.y/iResolution.y))*grad,grad,1.0);\n                //return;\n            }\n\n            last_pt = this_pt;\n        }\n    }\n    \n    //if (onCatmullRom(fragCoord,pp0,pp1,pp2,pp3) || onCatmullRom(fragCoord,pp1,pp2,pp3,pp4)) {\n    //    fragColor = vec4(0.0,0.0,0.0,1.0);\n    //    return;\n    //}\n\n\tfragColor = vec4(0.5,fragCoord.y/iResolution.y,1.0,1.0);\n}\t","name":"","description":"","type":"image"}]}