{"ver":"0.1","info":{"id":"wtcXWH","date":"1581039738","viewed":148,"name":"Hinge Redux","username":"spalmer","description":"golfing and fixing some other hinge/wedge codes.\nI made it handle concave vertices; iq did a lot of the heavy lifting.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fixing and reducing https://shadertoy.com/view/4tsSRr\n\n// allow me to explain what I mean by \"fixing\"\n\n// it's fine... but it's only intended for convex polygons apparently,\n// so did bad things when the situation becomes concave.\n// So since I needed it to handle this concave situation properly,\n// I wound up implementing a completely different \"shape\"\n// than original sdTriangle or iq's new sdWedge where he toyed with it.\n// \"Wedge - distance\"   https://shadertoy.com/view/wldXWB\n\n// for an interactive editor testbed, see https://shadertoy.com/view/tltXWS\n\n\n// partial seg2 - dir from closest point on seg\nvec2 rseg(vec2 v, vec2 e)\n{\n    return v - e*clamp(dot(v,e)/dot(e,e), 0., 1.);\n}\n\n// perp dot product (iq calls cross2)\nfloat pdot(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// FIXME iq seems to prefer sdXxxx prefix naming convention\n// and tends to put the query point first in the argument list.\n// I should try to conform to the shadertoy.com convention.\n\n// trying again, starting from iq's last suggestion, \n// where he inlined rseg\n// as his setup is much cleaner than mine by now.\n// effing idk what to call these anymore; it's a team effort.\n// iq did most of this but I redid the sign logic\nfloat triwedge3iqsp(vec2 b, vec2 c, vec2 a, vec2 q)\n{\n    q -= c, a -= c, b -= c;\n    float qq = dot(q,q);\n    float qa = dot(q,a);\n    float qb = dot(q,b);\n    float aa = dot(a,a);\n    float bb = dot(b,b);    \n    float h1 = clamp(qa/aa, 0.0, 1.0);\n    float h2 = clamp(qb/bb, 0.0, 1.0);\n    // this d was coming out slightly less than 0.0, causing problems!\n    float d = max(0., qq + min(\n        h1*(h1*aa - 2.0*qa),\n        h2*(h2*bb - 2.0*qb)));\n    float q1 = pdot(q,a)\n        , q2 = pdot(b,q)\n        , qs = pdot(a,b);\n\tfloat t = qs >= 0. ? max(q1,q2) : min(q1,q2);\n    return sqrt(d) * ((t>=0.0) ? 1.0 : -1.0);\n}\n\n// similar but copied iq's setup, made branchless and\n// took more of his advice.  iq should get credit for this too.\nfloat triwedge3sp2(vec2 a, vec2 c, vec2 b, vec2 q)\n{\n    q -= c; a -= c; b -= c;\n    vec2  o1 = rseg(q, a)\n\t\t, o2 = rseg(q, b);\n    float d = sqrt(min(dot(o1, o1), dot(o2, o2)));\n    bool  q1 = pdot(q, a) >= 0.\n        , q2 = pdot(b, q) >= 0.\n        , qs = pdot(b, a) >= 0.;\n    return (q1 && q2) || (q1 && !qs) || (q2 && !qs)\n        ? -d : d;\n}\n\n// bunch of other attempts in #if 0 .. #endif in Common tab\n\n\n// only for spinning demo points\nvec2 cossin(float r)\n{\n    const float halfpi = 1.5707963;\n    return cos(vec2(r, r - halfpi));\n}\n\n\n// \"standard\" sdf gradient debugging    \nvec3 DebugSDF(float d)\n{\n    vec3 col = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tcol *= 1. - exp(-2.*abs(d));\n\tcol *= .8 + .2*cos(120.*d);\n    return mix(col, vec3(1), 1.-smoothstep(.0,.02,abs(d))); // white at zero\n}\n// just had to get it out of main; hey, now it's re-usable!\n\nvoid mainImage(out vec4 c, vec2 s)\n{\n\tvec2 R = iResolution.xy\n        , q = (s+s-R)/R.y;\n\n    float t = 2.+.02*iTime;\n\tvec2 v1 = cossin(0.*t) * .5;\n\tvec2 v2 = cossin(1.*t) * .5;\n\tvec2 v3 = cossin(2.*t) * .5;\n    if (iMouse.z >= 0. && dot(iMouse.xy,vec2(1)) > 1.1) \n        v2 = (iMouse.xy*2.-R)/R.y;\n\n    #if 0\n    // collinear test case for ollj scenario\n    v1 = vec2(-.1,.1); v2 = vec2(0); v3 = vec2(.1,-.1);\n    #endif\n    \n\tfloat d = // uncomment only one call\n      triwedge3iqsp\n//      triwedge3sp2\n        (v1, v2, v3, q);\n\n    c.rgb = DebugSDF(d); // colorize\n    c.rgb = pow(c.rgb, vec3(.4545)); // gamma-corrected \n\tc.a = 1.;\n}\n\n// can try these from Common tab also if you enable them:\n\n// work but don't do precisely what I need\n// regarding handling both convex and concave cases:\n//     triwedge3iqCW  // direct from iq\n//     triwedge3iqCCW  // optimized but at what cost?\n//     triwedge3iq  // bestest!  iq wins again!  hold on though... it now flips signs concave vs. convex\n//     triwedge3iq_original  // hmm guess it was always reversing signs concave vs. convex\n//     sdTriangle // original busts interior when acute/concave\n\n// work but are just old backups now:\n//     triwedge3sp // not bad\n//     triwedge3exp // old\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// somehow certain comments after preprocessor lines cause syntax errors on Android\n\n// iq took several stabs at it\n#if 0\n// iq optimized it some more... removed qs\n\n// these wound up being posted by iq himself over at\n// \"Wedge - distance\"   https://shadertoy.com/view/wldXWB\n\n// now only handles vertices specified in clockwise/CCW winding order properly\n\n// they basically only handle convex situations\n\n// here's my attempt at reconstructing iq's posted comment snippet: wound up implementing CCW winding order :)\nfloat triwedge3iqCCW(vec2 a, vec2 c, vec2 b, vec2 q)\n{\n    q -= c, a -= c, b -= c;\n    float qq = dot(q,q);\n    float qa = dot(q,a);\n    float qb = dot(q,b);\n    float aa = dot(a,a);\n    float bb = dot(b,b);    \n    float h1 = clamp(qa/aa, 0.0, 1.0);\n    float h2 = clamp(qb/bb, 0.0, 1.0);\n    float d = qq + min(h1*(h1*aa - 2.0*qa),\n                       h2*(h2*bb - 2.0*qb));\n    float q1 = pdot(q,a),\n          q2 = pdot(q,b);\n    return sqrt(d) * ((max(q1,-q2)>=0.0)?1.0:-1.0); // no dice - without qs, not having desired effect from what I see\n}\n// this is what iq posted later (he called it triwedge3iqPos but that name was for when it was coming out unsigned, so... renamed)\n// expects vertices specified in clockwise winding order\nfloat triwedge3iqCW(vec2 b, vec2 c, vec2 a, vec2 q)\n{\n    q -= c, a -= c, b -= c;\n    float qq = dot(q,q);\n    float qa = dot(q,a);\n    float qb = dot(q,b);\n    float aa = dot(a,a);\n    float bb = dot(b,b);    \n    float h1 = clamp(qa/aa, 0.0, 1.0);\n    float h2 = clamp(qb/bb, 0.0, 1.0);\n    float d = qq + min(h1*(h1*aa - 2.0*qa),\n                       h2*(h2*bb - 2.0*qb));\n    float q1 = pdot(q,a);\n    float q2 = pdot(b,q);\n\n    return sqrt(d) * ((max(q1,q2)>=0.0)?1.0:-1.0);\n}\n#endif\n\n#if 0\n// iq's from comments\n// apparently it flips the signs when angle goes from convex to concave\n// which is not the *original* bug, but still a bug for my purposes\nfloat triwedge3iq(vec2 a, vec2 c, vec2 b, vec2 q)\n{\n    q -= c, a -= c, b -= c;\n\n    vec2 o1 = rseg(q, a),\n         o2 = rseg(q, b);\n\n    float d = min(dot(o1, o1),\n                  dot(o2, o2));\n\n    float q1 = pdot(q,a),\n          q2 = pdot(q,b),\n          qs = pdot(a,b);\n\n    return sqrt(d) * ((max(qs*q1,-qs*q2)>=0.0)?1.0:-1.0);\n}\n#endif\n// iq's the man!  superb.\n\n// apparently GLES sign(denormalized) isn't reliable!\n\n#if 0\n// same issue but with sign(denormalized) buglet\nfloat triwedge3iq_original(vec2 a, vec2 c, vec2 b, vec2 q)\n{\n    q -= c, a -= c, b -= c;\n\n    vec2 o1 = rseg(q, a), \n         o2 = rseg(q, b);\n    \n    float d = min(dot(o1, o1), \n                  dot(o2, o2));\n    \n    float q1 = pdot(q,a),\n          q2 = pdot(q,b),\n          qs = pdot(a,b);\n    \n    return sqrt(d)*sign(max(qs*q1,-qs*q2));\n}\n#endif\n\n\n// I took several stabs at it :)  beast just won't die\n\n#if 0\n// my older version works but is awkward and has a branch\nfloat triwedge3sp(vec2 a, vec2 c, vec2 b, vec2 q)\n{\n    vec2 e0 = b - a, e1 = c - b, e2 = a - c\n       , v0 = q - a, v1 = q - b, v2 = q - c;\n    vec2  o1 = rseg(v1, e1)\n\t\t, o2 = rseg(v2, e2);\n    float d = min(min(dot(v0, v0)\n                     ,dot(o1, o1))\n                     ,dot(o2, o2));\n    d = sqrt(d);\n    bool  q1 = pdot(v1, e1) >= 0.\n        , q2 = pdot(v2, e2) >= 0.\n        , qs = pdot(e1, e0) >= 0.;\n    if ((q1 && q2) || (q1 && !qs) || (q2 && !qs))\n        d = -d;\n    return d;\n}\n#endif\n\n#if 0\n// stopping working on this copy so I'll have a kind of backup\n// WORKS but FIXME needs logic cleaned and re-optimized\n// the interface is terrible too; I was originally \n// kind of rolling with how the original sdTriangle did things,\n// just relativizing it, but unsure winding up here was the best approach.\n// anyway it *works* properly.  That's an important place to start.\nfloat wedge3b(vec2 e0, vec2 e1, vec2 e2, vec2 v0, vec2 v1, vec2 v2)\n{\n\tvec2  o1 = rseg(v1, e1)\n\t\t, o2 = rseg(v2, e2);\n    float d = min(min(dot(v0, v0)\n                     ,dot(o1, o1))\n                     ,dot(o2, o2));\n    bool  q1 = pdot(v1,e1) >= 0.\n        , q2 = pdot(v2,e2) >= 0.\n        , qs = pdot(e1,e0) >= 0.\n    \t, qo = q1 || q2\n        , qa = q1 && q2;\n    bool q = qs ? qa : qo;\n    // well the bool logic simplifier I used spit out something\n    // which seems less than helpful, but we'll try it\n    //bool q = (qa && qo) || (qa && !qs) || (qo && !qs); // I'm sorry, I was wrong, but it was working anyway.. hmm.\n    // but see wedge3 for a version that did successfully eliminate the need for qo and qa\n    d = sqrt(d);\n    return q ? -d : d;\n}\n#endif\n\n#if 0\n// yeah it has the original bugs too\nfloat wedge3_unopt(vec2 e0, vec2 e1, vec2 e2, vec2 v0, vec2 v1, vec2 v2)\n{\n\tvec2  o1 = rseg(v1, e1)\n\t\t, o2 = rseg(v2, e2);\n    vec2 d = min(min(vec2(dot(v0, v0), 1.),\n                     vec2(dot(o1, o1), pdot(v1,e1))),\n                     vec2(dot(o2, o2), pdot(v2,e2)));\n\treturn -sqrt(d.x)*sign(d.y);\n}\n#endif\n\n#if 0\n// now that I have a backup safely squirreled away as wedge3b,\n// I can feel safe destroying this one in pursuit of optimality.\n// TODO I think if I cleaned up this interface it'd be good.\n// I may decide against pre-relativizing after all, don't think it helped.\nfloat wedge3(vec2 e0, vec2 e1, vec2 e2, vec2 v0, vec2 v1, vec2 v2)\n{\n    vec2  o1 = rseg(v1, e1)\n\t\t, o2 = rseg(v2, e2);\n    float d = min(min(dot(v0, v0)\n                     ,dot(o1, o1))\n                     ,dot(o2, o2));\n    bool  q1 = pdot(v1,e1) >= 0.\n        , q2 = pdot(v2,e2) >= 0.\n        , qs = pdot(e1,e0) >= 0.;\n    d = sqrt(d);\n    if ((q1 && q2) || (q1 && !qs) || (q2 && !qs))\n        d = -d;\n    return d;\n}\n\n// *c* is the corner vertex; a and b are adjacent vertices sharing an edge\nfloat triwedge3exp(vec2 a, vec2 c, vec2 b, vec2 q)\n{\n    return\n        wedge3 //wedge3b //wedge3_unopt //\n        (b - a, c - b, a - c\n       , q - a, q - b, q - c);\n}\n#endif\n\n\n// idk if I need to keep this around anymore\n// you can find it on the original page\n#if 0\n// from https://shadertoy.com/view/4tsSRr\n\n// The MIT License\n// Copyright 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// they obviously intend p2 to be the corner vertex; I rearranged 'em.\n\n// original signed distance to hinge, based on iq's 2d tri SDF - has bugs\nfloat sdTriangle( in vec2 p0, in vec2 p2, in vec2 p1, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0;\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), 1.0 ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n#endif\n\n","name":"Common","description":"","type":"common"}]}