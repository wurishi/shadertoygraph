{"ver":"0.1","info":{"id":"NlscWX","date":"1648808669","viewed":145,"name":"CG HW1","username":"hkristof03","description":"Ray tracing with material properties.","likes":30,"published":1,"flags":48,"usePreview":1,"tags":["reflection","refraction","raytrace","materials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 2. * texelFetch(iChannel0, ivec2(fragCoord), 0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\n// small threshold to consider two vectors parallel\nconst float pthreshold = 1e-8;\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;    // normal\n    int matid;\n};\n\nstruct Triangle {\n    // normal is computed on the fly\n    vec3 v0, v1, v2;\n    int matid;\n};\n\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int triangleNo = 18;\nTriangle triangles[triangleNo];\n\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int matid;\n};\n\n// materials\n\nstruct Material\n{\n    vec3 ambient;\n\tvec3 diffuse;\n    vec3 specular;\n    float shininess;\n    float ior;\n};\n\nconst Material list_materials[] = Material[](\n\n    // source: http://devernay.free.fr/cours/opengl/materials.html?fbclid=IwAR3vtB3F0ZeDS9TOvDrUYP97sB7eNpV5OPWEs9oRAhNikPinjA0Mpu_MXx0\n    // emerald - 0\n\tMaterial(vec3(0.0215, 0.1745, 0.0215), vec3(0.07568, 0.61424, 0.07568), vec3(0.633, 0.727811, 0.633), 0.6, 1.565),\n    // cyan rubber - 1\n    Material(vec3(0.0, 0.05, 0.05), vec3(0.4, 0.5, 0.5), vec3(0.04, 0.7, 0.7), 0.78125, 1.5189),\n    // chrome - 2\n    Material(vec3(0.25, 0.25, 0.25), vec3(0.4, 0.4, 0.4), vec3(0.774597, 0.774597, 0.774597), 0.3, 3.2120),\n    // pearl - 3\n    Material(vec3(0.25, 0.20725, 0.20725), vec3(1., 0.829, 0.829), vec3(0.296648, 0.296648, 0.296648), 0.088, 1.52),\n    // ruby - 4\n    Material(vec3(0.1745, 0.01175, 0.01175), vec3(0.61424, 0.04136, 0.04136), vec3(0.727811, 0.626959, 0.626959), 0.6, 1.762),\n    // turquoise - 5\n    Material(vec3(0.1, 0.18725, 0.1745), vec3(0.396, 0.74151, 0.69102), vec3(0.297254, 0.30829, 0.306678), 0.1, 1.61),\n    // copper - 6\n    Material(vec3(0.19125, 0.0735, 0.0225), vec3(0.7038, 0.27048, 0.0828), vec3(0.256777, 0.137622, 0.086014), 0.1, 0.23883),\n    // white plastic - 7\n    Material(vec3(0.0, 0.0, 0.0), vec3(0.55, 0.55, 0.55), vec3(0.70, 0.70, 0.70), 0.25, 1.3),\n    // jade - 8\n    Material(vec3(0.135,0.2225,0.1575),\tvec3(0.54,0.89,0.63), vec3(0.316228,0.316228,0.316228),\t0.1, 1.652),\n    // brass - 9\n    Material(vec3(0.329412,0.223529,0.027451), vec3(0.780392,0.568627,0.113725), vec3(0.992157,0.941176,0.807843), 0.21794872, 0.46192),\n    // green rubber - 10\n    Material(vec3(0.0,0.05,0.0), vec3(0.4,0.5,0.4), vec3(0.04,0.7,0.04), 0.078125, 1.5189),\n    // silver - 11\n    Material(vec3(0.19225,0.19225,0.19225),\tvec3(0.50754,0.50754,0.50754), vec3(0.508273,0.508273,0.508273), 0.4, 0.13511),\n    // black plastic - 12\n    Material(vec3(0.0,0.0,0.0), vec3(0.01,0.01,0.01), vec3(0.50,0.50,0.50), .25, 1.6)\n);\n\n// https://www.shadertoy.com/view/4lSGRV\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a), ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-4.5,0.1,1.5);\n\nconst int MAX_DEPTH = 1;\nconst float air_ior = 1.0;\n\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 1.0;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0 - ray.p0, plane.n) / dot(ray.v, plane.n);\n    return TraceResult(plane.n, t, plane.matid);\n}\n\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle)\n{\n    // MÃ¶ller-Trumbore algorithm\n    vec3 v0v1 = triangle.v1 - triangle.v0;\n    vec3 v0v2 = triangle.v2 - triangle.v0;\n    vec3 pv = cross(ray.v, v0v2);\n    float det = dot(v0v1, pv);\n    \n    // ray and triangle are parallel if the determinant is close to 0\n    \n    if (abs(det) < pthreshold)\n        return TraceResult(vec3(0), ray.tmax, -1);\n    \n    float invd = 1. / det;\n    vec3 tv = ray.p0 - triangle.v0;\n    float u = dot(tv, pv) * invd;\n    \n    // no intersection if u, v < 0 or u, v > 1 or u + v > 1\n    \n    if (u < 0. || u > 1.)\n        return TraceResult(vec3(0), ray.tmax, -1);\n        \n    vec3 qv = cross(tv, v0v1);\n    float v = dot(ray.v, qv) * invd;\n    \n    if (v < 0. || u + v > 1.)\n        return TraceResult(vec3(0), ray.tmax, -1);\n        \n    float t = dot(v0v2, qv) * invd;\n    vec3 tn = normalize(cross(v0v1, v0v2));\n\n    return TraceResult(tn, t, triangle.matid);\n}\n\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, -1);\n\n    for (int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if (res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for (int i = 0; i < triangleNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if (res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    return res;\n}\n\n\n// Computing the amount of reflected light using Fresnel equations\nfloat reflectionWithFresnel(vec3 incident, vec3 normal, float n1, float n2)\n{\n    float n = n1 / n2;\n    float cosI = -dot(normal, incident);\n    float sinT2 = pow(n, 2.) * (1. - pow(cosI, 2.));\n    \n    // total internal reflection\n    if (sinT2 > 1.0)\n        return 1.0;\n    \n    float cosT = sqrt(1.0 - sinT2);\n    float Fpar = pow((n2 * cosI - n1 * cosT) / (n1 * cosT + n2 * cosI), 2.);\n    float Fper = pow((n1 * cosI - n2 * cosT) / (n1 * cosI + n2 * cosT), 2.);\n    \n    float Frefl = clamp((Fpar + Fper) / 2., 0., 1.);\n    \n    return Frefl;\n}\n\n// Computing the amount of reflected light using Schlick's approximation\nfloat reflectionWithSchlick(vec3 incident, vec3 normal, float n1, float n2)\n{\n    float r0 = pow((n1 - n2) / (n1 + n2), 2.);\n    float cosT = dot(incident, normal);\n    float Srefl = clamp(r0 + (1. - r0) * pow((1. - cosT), 5.), 0., 1.);\n    \n    return Srefl;\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\n\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos)\n{\n    vec3 p = ray.p0 + ray.v * tr.t;\n    vec3 n = tr.n;\n    \n    vec3 l = lightPos - p;\n    float lightDist = length(l);\n    l /= lightDist; // normalized direction to the light\n    \n    // Use material data\n    int mid = tr.matid;\n    Material mat = list_materials[mid];\n\n    Ray shadowray = Ray(p + 0.001 * n, 0.001, l, lightDist);\n                      /*     p0  , tmin , v,    tmax  */\n    TraceResult res = raycast(shadowray);\n    \n    vec3 col = vec3(0); // remains 0 if in shadow\n    \n    if(res.t >= shadowray.tmax)\n    {\n        vec3 v = -ray.v;\n\n        // ambience\n        vec3 ambient = dot(n, v) * mat.ambient;\n    \n        // diffuse\n        float costheta = max(dot(n, l), 0.);\n        vec3 k_d = vec3(mat.diffuse/pi);\n   \n        // specular\n        vec3 toLight = normalize(lightPos - p);\n        vec3 toEye = -ray.v;\n        vec3 k_s = vec3(mat.specular);\n\n        vec3 h = normalize(toLight + toEye);\n        float si = pow(clamp(dot(h, n), 0., 1.), 100.);\n        //sum\n        col = ambient + (k_d + si * k_s) * costheta;\n    }\n    \n    return vec4(col, 1.);\n}\n\n\nvec4 computeReflectionUntilMaxDepth(Ray ray, TraceResult result, vec3 lightPos, int max_depth)\n{\n    vec3 p = ray.p0 + ray.v * result.t;\n    vec3 refractionRayOrigin;\n    vec3 refractionDir;\n    float ior = list_materials[result.matid].ior;\n    \n    float reflectance = reflectionWithFresnel(p, result.n, air_ior, ior);\n    bool outside = dot(ray.v, result.n) < 0.;\n    vec4 refractionColor = vec4(0.);\n    \n    if (reflectance < 1.)\n    {\n\n        refractionRayOrigin = p - 0.001;\n        refractionDir = refract(p, -result.n, air_ior / ior);\n\n        Ray refractionRay = Ray(refractionRayOrigin, 0.001, refractionDir, 500.);\n        \n        TraceResult refractionRes = raycast(refractionRay);\n        \n        vec3 refractionP = refractionRay.p0 + refractionRay.v * refractionRes.t;\n        \n        refractionColor += (1. - reflectance) * hitColor(refractionRay, refractionRes, refractionP);\n    }\n\n    vec4 hc = reflectance * hitColor(ray, result, lightPos) + refractionColor;\n    \n    vec3 l = lightPos - p;\n    vec3 R = reflect(-l, result.n);\n    Ray refray = Ray(p + 0.001 * result.n, 0.001, R, 500.);\n    TraceResult refres = raycast(refray);\n    p = refray.p0 + refray.v * refres.t;\n    int counter = 0;\n    vec3 normal;\n\n    while (counter < max_depth)\n    {\n        if(refray.tmax <= refres.t)\n        {\n            break;\n        }\n        \n        ior = list_materials[refres.matid].ior;\n        outside = dot(refray.v, refres.n) < 0.;\n        \n        if (outside == true)\n        {\n            normal = refres.n;\n            reflectance = reflectionWithFresnel(p, normal, air_ior, ior);\n        }\n        else\n        {\n            normal = -refres.n;\n            reflectance = reflectionWithFresnel(p, normal, ior, air_ior);\n        }\n        refractionColor = vec4(0.);\n        \n        if (reflectance < 1.)\n        {\n            if (outside == true)\n            {\n                refractionRayOrigin = p - 0.001;\n                refractionDir = refract(p, -result.n, air_ior / ior);\n            }\n            else\n            {\n                refractionRayOrigin = p + 0.001;\n                refractionDir = refract(p, result.n, ior / air_ior);\n            }\n            Ray refractionRay = Ray(refractionRayOrigin, 0.001, refractionDir, 500.);\n\n            TraceResult refractionRes = raycast(refractionRay);\n\n            vec3 refractionP = refractionRay.p0 + refractionRay.v * refractionRes.t;\n\n            refractionColor += (1. - reflectance) * hitColor(refractionRay, refractionRes, refractionP);\n        }\n        \n        hc += reflectance * hitColor(ray, result, lightPos) + refractionColor;\n        p = refray.p0 + refray.v * refres.t;\n        l = lightPos - p;\n        R = reflect(-l, normal);\n        refray = Ray(p + 0.001 * result.n, 0.001, R, 500.);\n        refres = raycast(refray);\n        counter += 1;\n    }\n    return hc;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sinTime = sin(iTime);\n    \n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)), 6);\n\n    // pyramid 1\n    int pbh = 2; // base height\n    int ppk = 14; // peak height\n    int px1 = 6;\n    int px2 = 18;\n    int pz1 = 2;\n    int pz2 = 14;\n    int pcx = (px1 + px2) / 2;\n    int pcz = (pz1 + pz2) / 2;\n    // the order in which the vertices defined is important because it scews up the shading\n    triangles[0] = Triangle(vec3(px2, pbh, pz1), vec3(px1, pbh, pz1), vec3(pcx, ppk, pcz), 11); //front\n    triangles[1] = Triangle(vec3(px1, pbh, pz2), vec3(px2, pbh, pz2), vec3(pcx, ppk, pcz), 10); // back\n    triangles[2] = Triangle(vec3(px1, pbh, pz1), vec3(px1, pbh, pz2), vec3(pcx, ppk, pcz), 6); // left\n    triangles[3] = Triangle(vec3(px2, pbh, pz2), vec3(px2, pbh, pz1), vec3(pcx, ppk, pcz), 5); // right\n    triangles[4] = Triangle(vec3(px1, pbh, pz1), vec3(px2, pbh, pz1), vec3(px2, pbh, pz2), 2); // bottom right\n    triangles[5] = Triangle(vec3(px1, pbh, pz1), vec3(px2, pbh, pz2), vec3(px1, pbh, pz2), 2); // bottom left\n    \n    for (int i = 0; i < 6; ++i)\n    {\n        triangles[i].v0 = rotateY(triangles[i].v0, .5 * iTime);\n        triangles[i].v1 = rotateY(triangles[i].v1, .5 * iTime);\n        triangles[i].v2 = rotateY(triangles[i].v2, .5 * iTime);\n    }\n    \n    // pyramid 2\n    pbh = 8;\n    ppk = 28;\n    px1 = 10;\n    px2 = 30;\n    pz1 = 60;\n    pz2 = 80;\n    pcx = (px1 + px2) / 2;\n    pcz = (pz1 + pz2) / 2;\n    \n    triangles[6] = Triangle(vec3(px2, pbh, pz1), vec3(px1, pbh, pz1), vec3(pcx, ppk, pcz), 8);\n    triangles[7] = Triangle(vec3(px1, pbh, pz2), vec3(px2, pbh, pz2), vec3(pcx, ppk, pcz), 9);\n    triangles[8] = Triangle(vec3(px1, pbh, pz1), vec3(px1, pbh, pz2), vec3(pcx, ppk, pcz), 10);\n    triangles[9] = Triangle(vec3(px2, pbh, pz2), vec3(px2, pbh, pz1), vec3(pcx, ppk, pcz), 11);\n    triangles[10] = Triangle(vec3(px1, pbh, pz1), vec3(px2, pbh, pz1), vec3(px2, pbh, pz2), 2);\n    triangles[11] = Triangle(vec3(px1, pbh, pz1), vec3(px2, pbh, pz2), vec3(px1, pbh, pz2), 2);\n    \n    for (int i = 6; i < 12; ++i)\n    {\n        triangles[i].v0 = rotateY(triangles[i].v0, 0.1 * sinTime * pi) + vec3(0,5.*sinTime,0);\n        triangles[i].v1 = rotateY(triangles[i].v1, 0.1 * sinTime * pi) + vec3(0,5.*sinTime,0);\n        triangles[i].v2 = rotateY(triangles[i].v2, 0.1 * sinTime * pi)+ vec3(0,5.*sinTime,0);\n    }\n    \n    // pyramid 3\n    pbh = 2;\n    ppk = 22;\n    px1 = -60;\n    px2 = -42;\n    pz1 = 26;\n    pz2 = 46;\n    pcx = (px1 + px2) / 2;\n    pcz = (pz1 + pz2) / 2;\n    \n    triangles[12] = Triangle(vec3(px2, pbh, pz1), vec3(px1, pbh, pz1), vec3(pcx, ppk, pcz), 4);\n    triangles[13] = Triangle(vec3(px1, pbh, pz2), vec3(px2, pbh, pz2), vec3(pcx, ppk, pcz), 4);\n    triangles[14] = Triangle(vec3(px1, pbh, pz1), vec3(px1, pbh, pz2), vec3(pcx, ppk, pcz), 4);\n    triangles[15] = Triangle(vec3(px2, pbh, pz2), vec3(px2, pbh, pz1), vec3(pcx, ppk, pcz), 4);\n    triangles[16] = Triangle(vec3(px1, pbh, pz1), vec3(px2, pbh, pz1), vec3(px2, pbh, pz2), 4);\n    triangles[17] = Triangle(vec3(px1, pbh, pz1), vec3(px2, pbh, pz2), vec3(px1, pbh, pz2), 4);\n\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax <= result.t)\n        fragColor = missColor(ray);    \n    else\n    {\n        vec3 lightPos1 = vec3(15.*cos(iTime),40.,15.*sinTime);\n        vec3 lightPos2 = vec3(-70.*abs(sinTime),30.,34.);\n        \n        vec4 hitcolor1 = computeReflectionUntilMaxDepth(ray, result, lightPos1, MAX_DEPTH);\n        vec4 hitcolor2 = computeReflectionUntilMaxDepth(ray, result, lightPos2, MAX_DEPTH);\n\n        fragColor = hitcolor1 + hitcolor2;\n    }\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3 * prev + 0.7 * fragColor;   // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye - EyeStartPosition;\n    \n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}