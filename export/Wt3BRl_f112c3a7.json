{"ver":"0.1","info":{"id":"Wt3BRl","date":"1613204943","viewed":240,"name":"Alchemical symbols - AT","username":"athibaul","description":"Drawing some symbols inspired from alchemy/astrology using distance functions.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","symbols"],"hasliked":0,"parentid":"3scyWN","parentname":"Alchemical symbols"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat alchemicalSymbol( vec2 p, vec4 type )\n{\n    // Just making up some imaginary symbols\n    // Inspired by stuff like:\n    // https://en.wikipedia.org/wiki/Alchemical_symbol\n    // https://en.wikipedia.org/wiki/Astrological_symbols\n    \n    // Orientation\n    if(type.w < 0.5)\n        p.y = -p.y;\n    \n    vec2 chargeCenter = vec2(0);\n    float d = 100.;\n    \n    float nBase = 4.5;\n    float nCharge = 4.;\n    float nAdj = 4.;\n    type.xyz *= vec3(1.2*nBase, 2.0*nCharge, 2.0*nAdj);\n    \n    if(type.z < nAdj && type.x < nBase) \n        // If we have a base and adjunction, shift the symbol\n    \tp -= vec2(0., 0.618);\n    if(type.x >= nBase)\n    {\n        // If we have no base, make sure we have a charge (most of the time)\n        // and no adjunction\n        type.y *= 0.6;\n        type.z = nAdj;\n    }\n    \n    // Base symbol\n    if(type.x < 1.)\n    {\n        // Circle\n        d = min(d, abs(length(p) - 1.0));\n    }\n    else if(type.x < 2.)\n    {\n        // Triangle\n        vec2 q = p;\n        if(fract(type.x) >= 0.5)\n        {\n            // Down triangle\n            chargeCenter = vec2(0, 1./3.);\n            q = -p+chargeCenter;\n        }\n        else\n        {\n            // Up triangle\n        \tchargeCenter = vec2(0, -1./3.);\n            q = p-chargeCenter;\n        }\n        q.x = abs(q.x);\n        vec2 q2 = reflect(q, vec2(1./2., sqrt(3.)/2.));\n        q = q2.y < q.y ? q2 : q;\n        \n        q.y += 2./3.;\n        d = min(d, length(max(abs(q)-vec2(2./sqrt(3.),0.), 0.)));\n    }\n    else if(type.x < 3.)\n    {\n        // Diamond\n        vec2 q = abs(p);\n        q = sqrt(0.5) * vec2(q.x+q.y, q.x-q.y);\n        q.x -= sqrt(.5);\n        d = min(d, length(max(abs(q)-vec2(0.,sqrt(.5)), 0.)));\n    }\n    else if(type.x < 4.)\n    {\n        // Moon\n        float orientation = floor(3.0*(type.x-3.));\n        vec2 q = p;\n        if(orientation < 1.)\n        {\n            q = p.yx;\n            chargeCenter += vec2(0.5*0.618, 0.);\n        }\n        else if(orientation < 2.)\n        {\n            q = p;\n        \tchargeCenter += vec2(0., 0.5*0.618);\n        }\n        else\n        {\n            q = -p.yx;\n            chargeCenter += vec2(-0.5*0.618, 0.);\n        }\n        vec2 tip = vec2(0.618,sqrt(1.-0.618*0.618));\n        q = vec2(abs(q.x), q.y);\n        float d1 = (-q.x*tip.y+q.y*tip.x > 0.) ? length(q-tip) : abs(length(q) - 1.0);\n        d = min(d, d1);\n        q -= vec2(0., 0.5*0.618);\n        tip -= vec2(0., 0.5*0.618);\n        d1 = (-q.x*tip.y+q.y*tip.x > 0.) ? length(q-tip) : abs(length(q) - length(tip));\n        d = min(d, d1);\n    }\n    else if(type.x < 4.5)\n    {\n        // 4. \"Ascending/descending node\" - Omega\n        vec2 q = p;\n        float r0 = 1.1;\n        float w1 = 0.6;\n        float r1 = 0.5*0.618;\n        vec2 tip = r0*vec2(w1,sqrt(1.-w1*w1));\n        float orientation = (type.x < 4.5) ? 1.0 : -1.0;\n        chargeCenter = vec2(0,-(1.0-r0+r1)*orientation);\n        vec2 q0 = vec2(q.x, q.y*orientation+(1.0-r0+r1));\n        q = vec2(abs(q0.x), q0.y);\n        bool b = (-q.x*tip.y+q.y*tip.x > 0.);\n        float d1 = b ? length(q-tip) : abs(length(q) - r0);\n        d1 = abs(d1 - r1);\n        vec2 tip2 = tip * (r0+r1)/r0;\n        //d1 = max(d1, length(q-tip2));\n        \n        float l = length(q);\n        if(l > 1. && !b)\n        {\n            d1 = min(l-(1.-r1), length(q - tip2));\n        }\n        \n        d = min(d, d1);\n    }\n    \n    // Charge layered onto the symbol\n    if(type.y < 1.)\n    {\n        // Horizontal stroke\n        p.xy = type.x < nBase ? p.xy : p.yx;\n        d = min(d, length(max(abs(p)-vec2(1.,0.), 0.)));\n    } \n\telse if(type.y < 2.)\n    {\n        // \"Sun\" dot\n        d = min(d, length(p-chargeCenter)-0.15);\n    }\n    else if(type.y < 3.)\n    {\n        // \"Sextile\" / asterisk\n        vec2 q = abs(p - chargeCenter).yx;\n        vec2 q2 = reflect(q, vec2(-0.5, sqrt(3.)/2.));\n        q = (q2.y < q.y) ? q2 : q;\n        d = min(d, length(max(abs(q) - vec2(0.618*0.5,0), 0.)));\n    }\n    else if(type.y < 4.)\n    {\n        // Small triangle\n        vec2 q = (p-chargeCenter)*sign(fract(type.y)-0.5);\n        q.x = abs(q.x);\n        vec2 q2 = reflect(q, vec2(1./2., sqrt(3.)/2.));\n        q = q2.y < q.y ? q2 : q;\n    \t// When applicable, make it a triforce\n        float size = (1.5 < type.x && type.x < 2.0) ? 1. : 0.5;\n        q.y += size/3.;\n        d = min(d, length(max(abs(q)-vec2(size/sqrt(3.),0.), 0.)));\n    }\n    \n    // Adjonction below the symbol\n    vec2 q = p - vec2(0,-1.618);\n    if(type.z < 1.)\n    {\n        // \"Venus\" cross\n        q = abs(q);\n        q.xy = q.x < q.y ? q.xy : q.yx;\n        d = min(d, length(max(abs(q)-vec2(0.,0.618), 0.)));\n    }\n    else if(type.z < 2.)\n    {\n        // \"Mars\" arrow\n        q.x = abs(q.x);\n        d = min(d, length(max(abs(q)-vec2(0.,0.618),0.)));\n        q.y += 0.618;\n        q.xy = sqrt(0.5) * vec2(q.x+q.y, q.x-q.y);\n        q.x -= 0.5*0.618;\n        d = min(d, length(max(abs(q)-vec2(0.5*0.618,0.),0.)));\n    }\n    else if(type.z < 3.)\n    {\n        // \"Mercury\" wings\n        q = vec2(abs(q.x), -q.y);\n        vec2 tip = 0.618*vec2(0.618,sqrt(1.-0.618*0.618));\n        float d1 = (-q.x*tip.y+q.y*tip.x > 0.) ? length(q-tip) : abs(length(q) - length(tip));\n        d = min(d, d1);\n    }\n    else if(type.z < 4.)\n    {\n        // Double underline, 'cause why not?\n        q = abs(q) - vec2(0, 0.618*1./3.);\n        d = min(d, length(max(abs(q) - vec2(0.618,0.), 0.)));\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    #if 0\n    // DEBUG\n    uv *= 3.0;\n    float d = alchemicalSymbol(uv, vec4(0.7,0.9,0.9,0.5));\n    // For debugging distance field:\n    vec3 col = vec3(fract(10.0*(d))) * smoothstep(1.5, 0.0, d);\n    \n    \n    #else\n    \n    float th = 0.2*sin(iTime*0.3);\n    uv *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    uv += vec2(iTime, 5.0*cos(iTime*0.2));\n    uv *= 10.0;\n    vec2 scale = vec2(0.66*4.0, 4.5);\n    vec2 uv_c = scale*round(uv/scale);\n    vec2 p = uv - uv_c;\n    \n    float d = alchemicalSymbol(p, hash42(uv_c));\n    \n    // Add horizontal lines\n    d = min(d, abs(abs(p.y) - 0.5*scale.y + 0.2));\n    float thickness = 0.08;\n    \n    // Antialias\n    float dth = 0.7*length(fwidth(uv));\n    float x = smoothstep(thickness+dth,thickness-dth, d);\n    vec3 col = vec3(x);\n    \n    /*\n\tfloat d1 = max(d,0.);\n    float x2 = d < thickness ? 1.0 - d1*d1/(thickness*thickness) : 0.;\n    \n    vec2 nxy = vec2(dFdx(x2), dFdy(x2)) * iResolution.y / 300.;\n    vec3 n = vec3(nxy, sqrt(1.-nxy.x*nxy.x-nxy.y*nxy.y));\n    //col = 0.5 + 0.5*n;\n    vec3 sun = normalize(vec3(1.,1.,2.));\n    \n    vec3 col = texture(iChannel0, uv*0.05,0.).rgb;\n    col = mix(col, vec3(1.), texture(iChannel0, uv.yx*0.05, 2.5).rgb);\n    col = mix(col, pow(clamp(dot(n,sun),0.,1.),10.)+vec3(0.), x);\n    */\n\t\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}","name":"Common","description":"","type":"common"}]}