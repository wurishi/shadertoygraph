{"ver":"0.1","info":{"id":"wlfyDs","date":"1593421549","viewed":132,"name":"Tileable Cell Noise","username":"ming","description":"Tileable Cell Noise","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","worley","tileable","cell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 HashTex(in vec3 p, in float numCells)\n{\n    p = mod(p, numCells);;\n    \n    vec2 uv = (p.xy + vec2(37.0,17.0) * p.zz);\n\treturn texture( iChannel0, (uv+0.5)/256.0).grb;\n}\n\nfloat CellNoise(in vec3 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            for (int zo = -1; zo <= 1; zo++)\n\t\t    {\n\t\t\t    vec3 tp = floor(p) + vec3(xo, yo, zo);\n\t\t\t    tp = p - tp - HashTex(tp, numCells);\n\t\t\t    d = min(d, dot(tp, tp));\n            }\n\t\t}\n\t}\n    float r = 1.0 - sqrt(d);\n    //float r = 1.0 - d;// ...Bubbles\n\treturn -1.0 + 2.0 * r;\n}\n\nfloat NoiseFBM(in vec3 p, float numCells, int octaves)\n{\n\tfloat f = 0.0;\n    \n\t// Change starting scale to any integer value...\n    p = mod(p, vec3(numCells));\n\tfloat amp = 0.5;\n    float sum = 0.0;\n\t\n\tfor (int i = 0; i < octaves; i++)\n\t{\n\t\tf += CellNoise(p, numCells) * amp;\n        sum += amp;\n\t\tamp *= 0.5;\n\n\t\t// numCells must be multiplied by an integer value...\n\t\tnumCells *= 2.0;\n\t}\n\n\treturn f / sum;\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//#define SHOW_2D_VERSION 1\n#ifdef SHOW_2D_VERSION\n    // uv should be within 0-1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // debug for tiling\n    //uv *= 2.0;\n    \n    float c = NoiseFBM(vec3(uv, 0.5), 2.0, 5) * 0.5 + 0.5;\n    c = c * c;\n    fragColor = vec4(c, c, c , 1.0);\n#else\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n\t\tf = NoiseFBM(pos, 4.0, 3);\n\t\tcol = vec3(f * 0.5 + 0.5);\n\t}\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n    \n#endif\n}","name":"Image","description":"","type":"image"}]}