{"ver":"0.1","info":{"id":"ltdcWf","date":"1534518978","viewed":332,"name":"Raymarched Time Vortex","username":"_polymath","description":"Clearly I wasn't done tinkering because this is now looking pretty nice.\n\nAnnoyingly the rays still all cast backwards because fixing that seemed hard.\n\ni mean all the rays cast backwards because i am an idiot ¯\\_(ツ)_/¯","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","doctorwho"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXITERS 1000\n#define LENFACTOR 0.9\n#define NDELTA 0.001\n#define MAXSTEP 0.05\n#define NDELTAX vec3(NDELTA, 0., 0.)\n#define NDELTAY vec3(0., NDELTA, 0.)\n#define NDELTAZ vec3(0., 0., NDELTA)\n\n// Turn on (and rewind shader) to watch the Tardis vanish off down the vortex\n//#define TARDISMOTION 0.5\n\n// Turn this on to reflect some time-vortex plasma in the glass windows.\n// It should be better but somehow it doesn't quite work for me.\n// I think the motion distracts from the reflectioniness\n// and it just looks like plasma drawn on the screen.\n//#define PLASMAWINDOWS\n\n/* This is a clssic plasma effect used for the tunnel.\n\nIt uses a bunch of particles to generate a scalar field,\nand the colour is based on the cosine of that field\nwhich gives you the 'contour lines' effect\nwhere you see wildly moving lines\nrather than the underlying, gently undulating, field.\n\nThis is a 3D plasma that the tunnel surface intersects;\nthe particles just swim around in the x/y plane, but they always\nmove towards the camera in z, giving the illusion of the camera\nmoving forward through the tunnel.\n\nParticles pop out of existence behind the camera, and back in far enough\nin the distance that you won't notice.*/\nvec4 plasma(vec3 uv)\n{\n    float d = 0.0;\n    for (float i = 0.0; i < 50.0; ++i)\n        d += cos( max(0.0, 3.14 - distance(uv, vec3(\n            sin(i + iTime * mod(i * 2633.2363, 0.42623)) * 3.0,\n            cos(i * 0.617 + iTime * mod(i * 36344.2363, 0.52623)) * 3.0,\n            mod(i * 1.617 + iTime * 40. * mod(i * 45634.53453, 0.34544), 28.0) - 24.0\n        ))));\n    float r = cos(d * 6.0), g = cos(d * 3.0), b = cos(d * 1.5);\n    return vec4((r+g*0.8+b*0.4) + 1.5,\n                r*0.8+g*0.6+b*0.2 + 0.2,\n                r*0.4+g*0.3+b*0.1, 1.0);\n}\n\n/* This is a classic raymarcher.\n\nThe Tardis is 95% cuboids so fairly easy to compute. */\n\nfloat addCuboid(float d, vec3 p, vec3 c, vec3 r) {\n    vec3 cd = r - abs(p - c);\n \treturn max(d, min(cd.x, min(cd.y, cd.z)));\n}\n\nfloat scene(vec3 p, vec3 tardisPos, mat3 tardisRot) {\n    // tube\n    float d = length(p.xy) - 2.;\n    #ifndef TARDISMOTION\n    if (p.z < -4.) return d;\n    #endif\n    // tardis\n    p = (p - tardisPos) * tardisRot;\n    // body\n    d = addCuboid(d,p, vec3(0., .0, 0.), vec3(.18, .38, .18));\n    // bottom\n    d = addCuboid(d,p, vec3(0., -.4, 0.), vec3(.22, .02, .22));\n    // top\n    d = addCuboid(d,p, vec3(0., 0.41, 0.), vec3(.22, .04, .22));\n    d = addCuboid(d,p, vec3(0., .44, 0.), vec3(.18, .05, .18));\n    d = addCuboid(d,p, vec3(0., 0.5, 0.), vec3(.03, .09, .03));\n    // This bit is the pitched roof:\n    float h = max(abs(p.x), abs(p.z));\n    if (h < 0.18 && p.y > 0.49)\n        d = max(d, (0.543- p.y) - h * 0.3);\n    // corner struts\n    d = addCuboid(d,p, vec3(-.18, 0., 0.18), vec3(.02, .4, .02));\n    d = addCuboid(d,p, vec3(.18, 0., 0.18), vec3(.02, .4, .02));\n    d = addCuboid(d,p, vec3(-.18, 0., -0.18), vec3(.02, .4, .02));\n    d = addCuboid(d,p, vec3(.18, 0., -0.18), vec3(.02, .4, .02));\n    // centre struts\n    d = addCuboid(d,p, vec3(0., 0., 0.), vec3(.19, .4, .02));\n    d = addCuboid(d,p, vec3(0., 0., 0.), vec3(.02, .4, .19));\n    // horizontal struts\n    d = addCuboid(d,p, vec3(0., -0.2, 0.), vec3(.19, .02, .19));\n    d = addCuboid(d,p, vec3(0., 0., 0.), vec3(.19, .02, .19));\n    d = addCuboid(d,p, vec3(0., 0.2, 0.), vec3(.19, .02, .19));\n    return d;\n}\n\n/* I picked up this trick for calculating normals from yx.\nIt's maybe a silly approach for a bunch of cuboids, but it works.\nIf think if I did this again I might raytrace the Tardis\nand raymarch the tunnel only if the ray misses it completely. */\n\nvec3 sceneNormal(vec3 p, vec3 tardisPos, mat3 tardisRot) {\n    return normalize(vec3(\n        scene(p + NDELTAX, tardisPos, tardisRot) - scene(p - NDELTAX, tardisPos, tardisRot),\n        scene(p + NDELTAY, tardisPos, tardisRot) - scene(p - NDELTAY, tardisPos, tardisRot),\n        scene(p + NDELTAZ, tardisPos, tardisRot) - scene(p - NDELTAZ, tardisPos, tardisRot)\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.yy;\n    vec3 ray = normalize(vec3(uv, 1.));\n    vec3 cam = vec3(0., 1., -1.);\n    \n    // Calculate the Tardis rotation matrix once per pixel,\n    // and reuse it for every step along the ray.\n    \n    vec3 tardisPos = vec3(sin(iTime) * 0.25, cos(iTime) * 0.25 + 1.,\n                #ifdef TARDISMOTION\n                    -1. - iTime * TARDISMOTION);\n                #else\n                   \t-3.);\n    \t\t\t#endif\n    float sx = sin(iTime), sy = sin(iTime * 0.83), sz = sin(iTime * 0.51),\n              cx = cos(iTime), cy = cos(iTime * 0.83), cz = cos(iTime * 0.51);\n    mat3 tardisRot = mat3(cx, -sx, 0, sx, cx, 0, 0, 0, 1)\n        * mat3(1, 0, 0, 0, cy, -sy, 0, sy, cy)\n        * mat3(cz, 0, sz, 0, 1, 0, -sz, 0, cz);\n    \n    // Raymarch...\n    \n    vec3 pos = cam;\n    for (int i = 0; i < MAXITERS; ++i) {\n        float dist = scene(pos, tardisPos, tardisRot);\n        dist = min(dist, MAXSTEP);\n        /* This is a bit of a fudge but an interesting one.\n\t\tRather than bend the tunnel, we bend the rays.\n\t\tThis has the advantage of locking the near-end\n\t\twhile allowing the far end to swing around interestingly\n\t\tand looking a bit less like a pile of sine waves,\n\t\tbut has the disadvantage of requiring many short steps\n\t\trather than a few long ones. That said, the raycast\n\t\tis cheap; the plasma is the main processing job here.*/\n        ray.x += (sin(iTime * 0.6 + pos.z * 0.4) * 0.02\n            + sin(iTime * 0.83 + pos.z * 0.37) * 0.0312) * dist;\n        ray.y += (cos(iTime * 1.12 + pos.z * 0.2) * 0.035\n            + cos(iTime * 1.42 + pos.z * 0.51) * 0.024) * dist;\n        ray = normalize(ray);\n        pos += ray * dist * LENFACTOR;\n        if (dist > -0.0001) break;\n    }\n    \n    // Check if we've hit the tube, and if so, render that.\n    // The texture is some plasma, lit slightly non-physically\n    // (purely based on what seemed to look good) by a light that\n    // swings back and forth along the tunnel mostly to give some variety.\n    // Also add in some space texture at the far end\n    // (just so there's no blank space)\n    if (dot(pos.xy, pos.xy) > 3.9) {\n    \tvec3 light = vec3(cos(iTime * 0.72) * 1.8,\n                          cos(iTime * 0.34) * 1.8,\n                          sin(iTime * 0.72) * 5. - 10.);\n    \tvec3 toLight = light - pos;\n    \tfloat brightness = 1.5;\n    \t// I've not checked but I'm guessing inverse-square-law here:\n    \tbrightness /= pow(length(toLight), 0.5);\n        brightness += 0.3;\n    \tfragColor =  max(vec4(0.), plasma(pos)) * brightness\n            * vec4(vec3(-dot(sceneNormal(pos, tardisPos, tardisRot),\n                             normalize(toLight) )) * brightness, 1.)\n            + texture(iChannel0, uv)*pow(length(pos),2.)*0.003;\n    } else {\n        // We hit the Tardis. It's made of four materials:\n        vec3 p = (pos - tardisPos) * tardisRot,\n            n = sceneNormal(pos, tardisPos, tardisRot);\n        float l = -n.z;\n        if (p.y < 0.2 || p.y > 0.4 || p.x > .181 || p.z > .181 || p.x < -.181 || p.z < -.181\n                 || fract((p.x)*18.) > 0.96\n           \t\t || fract((p.z)*18.) > 0.96\n            \t || ( p.y > 0.298 && p.y < 0.302 )) {\n            // If we got here, we missed the windows and hit a matte section:\n            if ((p.z > 0. && p.x < -0.05 && p.x > -0.15 && p.y > 0.04 && p.y < 0.16) ||\n                    (p.y > 0.385 && p.y < 0.435) && min(abs(p.x), abs(p.z)) < 0.2) {\n                // We hit a white section. Although \"white\" is 80% grey really:\n                l *= 0.8;\n                if (p.x > -0.13 && p.x < -0.07 && p.y > 0.06 && p.y < 0.14 && fract(p.y * 50.) > 0.5)\n                    // We hit the writing on the door sign so go \"black\"\n                    l *= 0.4;\n                fragColor = vec4(l,l,l,1.);\n            } else {\n                // We hit a blue section.\n\t            if (p.y >= -0.42 && p.y <= 0.42)\n                    // This line applies the wood texture\n                    // if we hit between the base and the roof.\n                    // (There's no good direction for the grain elsewhere.)\n    \t            l *= 0.5 + texture(iChannel1, (p.yx + p.yz) * vec2(1., 3.)).r *  .8;\n        \t\tfragColor = vec4(0.,0.,l,1.);\n            }\n        } else {\n            // This is the windows:\n            #ifdef PLASMAWINDOWS\n        \t\tfragColor = vec4(l,l,l,1.) * 0.6 +\n                \tplasma(reflect(normalize(ray), n)\n                           * 2.5 + vec3(0.,0.,-4.)) * 0.2;\n            #else\n        \t\tfragColor = vec4(l,l,l,1.) * 0.3 +\n                \ttexture(iChannel2, reflect(ray, n)) *\n                    vec4(0.8, 0.5, 0.2, 0.7);\n            #endif\n        }\n    }\n    //fragColor = vec4(fract(pos), 1.);\n    //fragColor = vec4(sceneNormal(pos, tardisPos, tardisRot) * 0.5 + 0.5, 1.);\n}","name":"Image","description":"","type":"image"}]}