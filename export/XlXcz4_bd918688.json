{"ver":"0.1","info":{"id":"XlXcz4","date":"1503563667","viewed":193,"name":"Hat in CCTV","username":"archibate","description":"ray marching cone + sphere = hat\ncool with cctv noises.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","noise","ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define mainImage iqtvImage\n\nhighp float rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid cctvImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uvR = uv;\n    uvR.x += rand(vec2(iTime * .03, uv.y * .42)) * .001;\n    \t\t+ sin(rand(vec2(iTime * .2, uv.y))) * .0009;\n    vec2 uvG = uv;\n    uvG.x += rand(vec2(iTime * .004, uv.y * .002)) * .004;\n    \t\t+ sin(iTime * 9.) * .0009;\n    vec2 uvB = uv;\n    uvB.x += rand(vec2(iTime * .004, uv.y * .002)) * .004;\n    \t\t+ sin(rand(vec2(iTime * .5, uv.y))) * .009;\n    \n\tfloat r = texture(iChannel0, uvR).r;\n\tfloat g = texture(iChannel0, uvG).g;\n\tfloat b = texture(iChannel0, uvB).b;\n    \n    fragColor = vec4(r, g, b, 0);\n}\n\nvoid mytvImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 coor = fragCoord.xy;\n    float size = 6.;\n    float horz = 6.;\n    float modx = mod(coor.x, size) / size * 3.;\n    float mody = mod(coor.y, horz) / horz * 3.;\n    modx = float(int(modx) + int(mody));\n    if (modx < 1.1) {\n        fragColor = vec4(0, 0, texture(iChannel0, uv).b, 1);\n    } else if (modx < 2.1) {\n        fragColor = vec4(0, texture(iChannel0, uv).g, 0, 1);\n    } else {\n        fragColor = vec4(texture(iChannel0, uv).r, 0, 0, 1);\n    }\n}\n\nvoid normalImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}\n\n\nvoid iqtvImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col;\n\n    //col.r = texture(iChannel0,vec2(uv.x+0.003,-uv.y),2.0).r;\n    //col.g = texture(iChannel0,vec2(uv.x+0.000,-uv.y),1.0).g;\n    //col.b = texture(iChannel0,vec2(uv.x-0.003,-uv.y),2.4).b;\n    col.r = texture(iChannel0,vec2(uv.x+0.003,uv.y+0.000)).r;\n    col.g = texture(iChannel0,vec2(uv.x+0.000,uv.y+0.001)).g;\n    col.b = texture(iChannel0,vec2(uv.x-0.003,uv.y+0.000)).b;\n\n    col = clamp(col*0.5+0.5*col*col*1.2,0.0,1.0);\n\n    col *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y);\n\n    col *= vec3(0.95,1.05,0.95);\n\n    col *= 0.9+0.1*sin(10.0*iTime+uv.y*1000.0);\n\n    col *= 0.99+0.01*sin(110.0*iTime);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*{{{*\\ vim: ft=glsl ts=4 sts=4 sw=4 ai et fdm=marker\n *\n * Copyfuck (C) 2017 archibate <207773419@qq.com>\n * \n * All Fuck Reserved\n *\n \\*}}}*/\n\n#define PC\t// perspective correction\n#define EPS 1e-3\n#define INF 1e5\n#define DIFFER 2e-3\n#define BIGGER 2e3\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz) - r, abs(p.y) - h);\n}\n\nfloat sdCone(vec3 p, float r, float h)\n{\n    //p.y = abs(p.y);\n    return max((length(p.xz) - p.y * r) * inversesqrt(1. + r * r), p.y - h);\n}\n\nfloat sdPlane(vec3 p, vec3 n)\n{\n    return dot(p, n);\n}\n\nfloat sdf(vec3 p)\n{\n    return min(sdCone(p, 1., .5),\n               min(sdPlane(p - vec3(1., -1., 0.), vec3(0,1,0)),\n                   sdSphere(p - vec3(0., 0., 0.), .3)\n                  ));\n}\n\nvec3 normat(vec3 p)\n{\n    return normalize(vec3(\n                sdf(p + vec3(DIFFER,0,0)) - sdf(p - vec3(DIFFER,0,0)),\n                sdf(p + vec3(0,DIFFER,0)) - sdf(p - vec3(0,DIFFER,0)),\n                sdf(p + vec3(0,0,DIFFER)) - sdf(p - vec3(0,0,DIFFER))));\n}\n\nvec4 trace(vec3 p, vec3 d)\n{\n    float t = 0.;\n    for (int k = 0; k < 150; ++k) {\n        float h = sdf(p);\n        if (h < EPS)\n            return vec4(p, t);\n        if (t >= BIGGER)\n            break;\n        t += h;\n        p += d * h;\n    }\n    return vec4(p, INF);\n}\n\nmat3 setCamera(vec3 at, vec3 up)\n{\n    vec3 f = normalize(at);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s,u,f);\n}\n\nvoid rotate(inout vec3 v, vec2 a)\n{\n    v.yz = cos(a.y) * v.yz + sin(a.y) * vec2(-1,1) * v.zy;\n    v.xz = cos(a.x) * v.xz + sin(a.x) * vec2(-1,1) * v.zx;\n}\n\nfloat phong(vec3 eye, vec3 p, vec3 n, vec3 l) {\n   vec3 ld = normalize(l-p);\n   vec3 cd = normalize(eye-p);\n\n   float ka = 0.3;\n   float kd = 3.0;\n   float ks = 1.0;\n   vec3 r = 2.0*dot(ld,n)*n - ld;\n   r = normalize(r);\n   float ds = dot(r, cd);\n   float res = ka + kd*dot(ld, n);\n   return res + ks*pow(clamp(dot(r, cd),0.0,1.0), 50.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 me = iMouse.xy == vec2(0) ? vec2(0) : 3. * iMouse.xy / iResolution.xy - 1.5;\n    vec3 eye = vec3(0,0,2);\n    vec3 target = vec3(me, 0);\n    mat3 cam = setCamera(target - eye, vec3(0,1,0));\n    uv *= 0.3;\n#ifndef PC\n    vec3 dir = cam * normalize(vec3(uv, 1));\n#else\n    vec3 dir = cam * vec3(0,0,1);\n    rotate(dir, uv);\n#endif\n    vec4 res = trace(eye, dir);\n    vec3 norm = normat(res.xyz);\n    vec3 color = vec3(.8*max(phong(eye,res.xyz,norm,vec3(2,1,3)),0.)/(res.w*res.w));\n    fragColor = vec4(color, 1);\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define mainImage cctvImage\n\nhighp float rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid cctvImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uvR = uv;\n    uvR.x += rand(vec2(iTime * .03, uv.y * .42)) * .001;\n    \t\t+ sin(rand(vec2(iTime * .2, uv.y))) * .0009;\n    vec2 uvG = uv;\n    uvG.x += rand(vec2(iTime * .004, uv.y * .002)) * .004;\n    \t\t+ sin(iTime * 9.) * .0009;\n    vec2 uvB = uv;\n    uvB.x += rand(vec2(iTime * .004, uv.y * .002)) * .004;\n    \t\t+ sin(rand(vec2(iTime * .5, uv.y))) * .009;\n    \n\tfloat r = texture(iChannel0, uvR).r;\n\tfloat g = texture(iChannel0, uvG).g;\n\tfloat b = texture(iChannel0, uvB).b;\n    \n    fragColor = vec4(r, g, b, 0);\n}\n\nvoid mytvImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 coor = fragCoord.xy;\n    float size = 6.;\n    float horz = 6.;\n    float modx = mod(coor.x, size) / size * 3.;\n    float mody = mod(coor.y, horz) / horz * 3.;\n    modx = float(int(modx) + int(mody));\n    if (modx < 1.1) {\n        fragColor = vec4(0, 0, texture(iChannel0, uv).b, 1);\n    } else if (modx < 2.1) {\n        fragColor = vec4(0, texture(iChannel0, uv).g, 0, 1);\n    } else {\n        fragColor = vec4(texture(iChannel0, uv).r, 0, 0, 1);\n    }\n}\n\nvoid normalImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}\n\n\nvoid iqtvImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col;\n\n    //col.r = texture(iChannel0,vec2(uv.x+0.003,-uv.y),2.0).r;\n    //col.g = texture(iChannel0,vec2(uv.x+0.000,-uv.y),1.0).g;\n    //col.b = texture(iChannel0,vec2(uv.x-0.003,-uv.y),2.4).b;\n    col.r = texture(iChannel0,vec2(uv.x+0.003,uv.y+0.000)).r;\n    col.g = texture(iChannel0,vec2(uv.x+0.000,uv.y+0.001)).g;\n    col.b = texture(iChannel0,vec2(uv.x-0.003,uv.y+0.000)).b;\n\n    col = clamp(col*0.5+0.5*col*col*1.2,0.0,1.0);\n\n    col *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y);\n\n    col *= vec3(0.95,1.05,0.95);\n\n    col *= 0.9+0.1*sin(10.0*iTime+uv.y*1000.0);\n\n    col *= 0.99+0.01*sin(110.0*iTime);\n\n    fragColor = vec4(col,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}