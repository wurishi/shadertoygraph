{"ver":"0.1","info":{"id":"mtl3DN","date":"1671813154","viewed":80,"name":"3D SDF Study","username":"Trospy_Study","description":"3D SDF Study\nLeft Click : Move Cube\nreference : https://iquilezles.org/articles/distfunctions/\n                https://www.shadertoy.com/view/Ml3fWj","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3dsdfstudy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==0\n#define AA 2\n#else\n#define AA 3\n#endif\n\n#define RADIUS 1.5f\n#define OFFSET 1.1\n#define R 0.05f\n#define K 2.5f\n\nfloat sphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat rectangle(vec3 point, float offset, float r)\n{\n  vec3 q = abs(point) - offset;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) -r;\n}\n\nfloat smoothMax(float a, float b, float k)\n{\n    return log(exp(k*a) + exp(k*b))/k;\n}\n\nfloat smoothMin(float a, float b , float k)\n{\n    return -smoothMax(-a, -b, k);\n}\n\nfloat map(vec3 point)\n{\n    float d = 0.0;\n    float sphere = sphere(point, RADIUS);\n    vec2 mouse = vec2(0.0,0.0);\n    mouse += -4.5*(2.0f*iMouse.xy - iResolution.xy) / iResolution.xy;\n    vec3 mPos = vec3(vec2(-1.0,-1.0) + mouse,0.0);\n    float rectangle = rectangle(point+mPos, OFFSET, R);\n    d = smoothMin(sphere, rectangle, K);\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.001;\n    vec2 e = vec2(1.0f,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,3.0,6.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.0),-2.0));\n\n      // ray marching\n        float t = 5.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.0001f || t>10.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<10.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 L_dir = vec3(0.5333-0.5333*(sin(iTime)), 0.5333, 0.5333);\n            \n            // dot(nor, L_dir) = Apply normal direction to surface\n            // this equation render 2D circle to 3D Sphere\n            float dif = clamp(dot(nor,L_dir),0.0,1.0);\n            \n            col = vec3(0.025,0.05,0.08) + dif*vec3(1.0,0.9,0.8);\n        }\n\n        col = sqrt( clamp(col,0.0,1.0) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}