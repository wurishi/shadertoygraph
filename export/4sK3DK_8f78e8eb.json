{"ver":"0.1","info":{"id":"4sK3DK","date":"1457131624","viewed":304,"name":"Swiss SBB Clock","username":"TambakoJaguar","description":"I tried to recreate an authentic Swiss SBB Clock, which are installed in every train station of Switzerland. Thanks to the structures and their parameter, you can change the design of the clock at line 124, there are three examples! And use your mouse!","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["reflection","time","clock","swiss","glasss","hands","ticks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Swiss SBB Clock\" by Emmanuel Keller aka Tambako - March 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// Much code adapted from https://www.shadertoy.com/view/Xds3zN, thanks iq to let us use it! :)\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n//#define shadow\n#define reflections\n#define ambocc\n#define show_glass\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n    \nstruct ClockHand\n{\n\tvec2 size;\n    float angle;\n    float ypos;\n    float frontLength;\n    float backLength;\n    vec2 cap;\n    int capShape;    // 0: no cap, 1: disk, 2: square, 3: arrow, 4: inverse arrow\n    float timeFactor;\n    float rotationFactor;\n    bool continuous;\n    vec2 tickMovement;\n    vec3 color;\n    bool metallic;\n    int object;\n    bool visible;\n};\n\nstruct FaceTicks\n{\n    float outPos;\n    vec2 size;\n    float tstep;\n    vec3 color;\n    int type;    // 0: not visible, 1: line, 2: circle\n};\n    \nstruct Clock\n{\n    float diameter;\n    float height;\n    float caseThickness;\n    float facePos;\n    float glassTickness;\n    vec2 axisSize;\n    vec3 caseColor;\n    vec3 faceColor;\n    vec3 glassColor;\n    vec3 axisColor;\n    ClockHand secondsHand;\n    ClockHand minutesHand;\n    ClockHand hoursHand;\n    FaceTicks minuteTicks;\n    FaceTicks hourTicks;\n};\n    \n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define CASE_OBJ        1\n#define FACE_OBJ        2\n#define SHAND_OBJ       3\n#define MHAND_OBJ       4\n#define HHAND_OBJ       5\n#define AXIS_OBJ        6\n#define GLASS_OBJ       7\n    \nClock SBBClock;\nClock DesignClock;\nClock LuxuryClock;\nClock cClock;\nvoid initClock()\n{\n    ClockHand secondsHand = ClockHand(vec2(0.025, 0.02), 0., 0.06, 0.615, 0.25, vec2(0.615, 0.09), 1, 1., 60./58., true, vec2(80., 250.), vec3(1., 0.08, 0.08), false, SHAND_OBJ, true);\n    ClockHand minutesHand = ClockHand(vec2(0.085, 0.02), 0.55, 0.04, 0.88, 0.19, vec2(0.0, 0.0), 0, 60., 1., false, vec2(75., 200.), vec3(0.03, 0.03, 0.03), false, MHAND_OBJ, true);\n    ClockHand hoursHand = ClockHand(vec2(0.115, 0.02), 0.55, 0.02, 0.647, 0.19, vec2(0.0, 0.0), 0, 60.*12., 1., true, vec2(75., 150.), vec3(0.03, 0.03, 0.03), false, HHAND_OBJ, true);\n\n    FaceTicks minuteTicks = FaceTicks(0.93, vec2(0.07, 1.4), 6., vec3(0., 0., 0.), 1);\n    FaceTicks hourTicks = FaceTicks(0.93, vec2(0.22, 4.), 30., vec3(0., 0., 0.), 1);\n    \n    SBBClock = Clock(3., 1., 0.06, 0.8, 0.08, vec2(0.04, 0.1), vec3(0.85, 0.83, 0.81), vec3(0.98, 0.98, 0.98), vec3(0.96, 0.99, 0.96), vec3(0.83, 0.03, 0.03), secondsHand, minutesHand, hoursHand, minuteTicks, hourTicks);\n    \n    secondsHand = ClockHand(vec2(0.035, 0.02), 0., 0.07, 0.6, 0.25, vec2(0.6, 0.09), 3, 1., 1., false, vec2(50., 100.), vec3(0.3, 0.6, 0.87), false, SHAND_OBJ, true);\n    minutesHand = ClockHand(vec2(0.08, 0.02), 0., 0.045, 0.7, 0.15, vec2(0.0, 0.0), 0, 60., 1., true, vec2(50., 100.), vec3(0.8, 0.85, 0.93), false, MHAND_OBJ, true);\n    hoursHand = ClockHand(vec2(0.08, 0.02), 0., 0.02, 0.55, 0.15, vec2(0.0, 0.0), 0, 60.*12., 1., true, vec2(50., 100.), vec3(0.6, 0.72, 0.91), false, HHAND_OBJ, true);\n\n    minuteTicks = FaceTicks(0.9, vec2(0.1, 1.), 6., vec3(1., 1., 1.), 1);\n    hourTicks = FaceTicks(0.94, vec2(0.2, 1.), 30., vec3(1., 1., 1.), 1);\n    \n    DesignClock = Clock(3., .8, 0.03, 0.9, 0., vec2(0.06, 0.13), vec3(0.5, 0.7, 1.0), vec3(0.05, 0.05, 0.09), vec3(0.96, 0.99, 0.96), vec3(0.96, 0.96, 0.96), secondsHand, minutesHand, hoursHand, minuteTicks, hourTicks);\n    \n    secondsHand = ClockHand(vec2(0.025, 0.025), 0., 0.09, 0.82, 0.25, vec2(0., 0.), 0, 1., 1., false, vec2(75., 150.), vec3(0.8, 0.82, 0.84), true, SHAND_OBJ, true);\n    minutesHand = ClockHand(vec2(0.04, 0.025), -4.5, 0.055, 0.7, 0.05, vec2(0.742, 0.085), 3, 60., 1., true, vec2(50., 100.), vec3(0.8, 0.67, 0.3), true, MHAND_OBJ, true);\n    hoursHand = ClockHand(vec2(0.06, 0.025), -7., 0.02, 0.5, 0.05, vec2(0.55, 0.1), 3, 60.*12., 1., true, vec2(50., 100.), vec3(0.8, 0.67, 0.3), true, HHAND_OBJ, true);\n\n    minuteTicks = FaceTicks(0.91, vec2(0.06, 1.3), 6., vec3(0., 0., 0.), 2);\n    hourTicks = FaceTicks(0.91, vec2(0.1, 3.4), 30., vec3(0.8, 0.67, 0.3), 2);\n    \n    LuxuryClock = Clock(3., 0.55, 0.02, 0.7, 0.05, vec2(0.04, 0.18), vec3(0.81, 0.83, 0.86), vec3(0.8, 0.8, 0.8), vec3(0.96, 0.99, 0.96), vec3(0.8, 0.67, 0.3), secondsHand, minutesHand, hoursHand, minuteTicks, hourTicks);\n    \n    cClock = SBBClock; // You can choose one of the three defined watches: SBBClock, DesignClock or LuxuryClock\n}\n    \nLamp lamps[3];\n\n// Campera options\nvec3 campos = vec3(0., 0., 9.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 5.2;\nfloat angle;\nfloat angle2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.05;\n\n// Shading options\nconst float specint = 0.22;\nconst float specshin = 70.;\nconst float aoint = 0.55;\nconst float shi = 2.85;\nconst float shf = 1.4;\n    \n// Tracing options\nconst float normdelta = 0.0001;\nconst float maxdist = 40.;\nconst int nbref = 2;\nconst int nbrefr = 2;\nconst float glass_ior = 1.5;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\n// 1D hash function\nfloat hash(float n){\n\treturn fract(sin(n)*3538.5453);\n}\n\n// 2D hash function\nvec2 hash2(vec2 n){\n\treturn fract(vec2(sin(n.x)*3538.5453, sin(n.y)*2753.8256));\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Difference operation from iq\nfloat opS(float d1, float d2)\n{\n    return max(-d2,d1);\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat getStepImpulse(float t, float a, float s, float f)\n{\n    return a*cos(t*f)*exp(-s*t);\n}\n\nvec2 map_hand(vec3 pos, float angle, ClockHand hand)\n{\n    if (!hand.visible)\n        return vec2(maxdist*2., hand.object);\n    pos.xz = rotateVec(pos.xz, radians(angle));\n    pos.y/= cClock.height;\n    pos.y-= hand.ypos + cClock.facePos - 0.25;\n    pos.xz/= cClock.diameter/2. - cClock.caseThickness;\n    float handd = max(max(abs(pos.x) + tan(radians(hand.angle))*pos.z - hand.size.x/2., \n                      max(pos.y - hand.size.y, -pos.y)), \n                      max(pos.z - hand.frontLength, -pos.z + -hand.backLength));\n    //0: no cap, 1: disk, 2: square, 3: arrow, 4: inverse arrow\n    if (hand.cap.x!=0. && hand.cap.x!=0. && hand.capShape>0)\n    {\n        float cap;\n        if (hand.capShape==1)\n            cap = sdCylinder(pos - vec3(0., hand.size.y/2., hand.cap.x), vec2(hand.cap.y, hand.size.y/2.));\n        if (hand.capShape==2)\n            cap = sdBox(pos - vec3(0., hand.size.y/2., hand.cap.x), vec3(hand.cap.y, hand.size.y/2., hand.cap.y));\n        if (hand.capShape==3)\n            cap = sdTriPrism((pos - vec3(0., hand.size.y/2., hand.cap.x)).xzy, vec2(hand.cap.y, hand.size.y/2.));\n        if (hand.capShape==4)\n            cap = sdTriPrism((pos - vec3(0., hand.size.y/2., hand.cap.x)).xzy*vec3(1., -1., 1.), vec2(hand.cap.y, hand.size.y/2.));\n        handd = min(handd, cap);\n    }\n    return vec2(handd, hand.object);\n}\n\nvec2 map(vec3 pos)\n{\n    pos = pos.xzy;\n    pos = rotateVec2(pos);\n    \n    float secondsAngle = clamp(mod(iDate.w*6./cClock.secondsHand.timeFactor, 360.)*cClock.secondsHand.rotationFactor, 0., 360.);\n    float minutesAngle = clamp(mod(iDate.w*6./cClock.minutesHand.timeFactor, 360.)*cClock.minutesHand.rotationFactor, 0., 360.);\n    float hoursAngle = clamp(mod(iDate.w*6./cClock.hoursHand.timeFactor, 360.)*cClock.hoursHand.rotationFactor, 0., 360.);\n    \n    if (!cClock.secondsHand.continuous)\n        secondsAngle = 6.*floor(secondsAngle/6.) - getStepImpulse(fract(secondsAngle/6.), 6., cClock.secondsHand.tickMovement.x*cClock.secondsHand.timeFactor, cClock.secondsHand.tickMovement.y);\n    if (!cClock.minutesHand.continuous)\n        minutesAngle = 6.*floor(minutesAngle/6.) - getStepImpulse(fract(minutesAngle/6.), 6., cClock.secondsHand.tickMovement.x*cClock.minutesHand.timeFactor, cClock.secondsHand.tickMovement.y*cClock.secondsHand.timeFactor);   \n    if (!cClock.hoursHand.continuous)\n        hoursAngle = 30.*floor(hoursAngle/30.) - getStepImpulse(fract(hoursAngle/6.), 6., cClock.secondsHand.tickMovement.x*cClock.hoursHand.timeFactor, cClock.secondsHand.tickMovement.y*pow(cClock.secondsHand.timeFactor, 2.));\n    \n    vec2 dSecondsHand = map_hand(pos, -secondsAngle, cClock.secondsHand);\n    vec2 dMinutesHand = map_hand(pos, -minutesAngle, cClock.minutesHand);\n    vec2 dHoursHand = map_hand(pos, -hoursAngle, cClock.hoursHand);\n    vec2 hands = opU(opU(dSecondsHand, dMinutesHand), dHoursHand);\n    \n    float ccase = opS(sdCylinder(pos - vec3(0., cClock.height/4., 0), vec2(cClock.diameter/2., cClock.height/2.)),\n                     sdCylinder(pos - vec3(0., cClock.height/4. + cClock.caseThickness, 0.), vec2(cClock.diameter/2. - cClock.caseThickness, cClock.height/2.)));               \n    vec2 clockd = opU(vec2(ccase, CASE_OBJ), hands);\n    \n    float face = sdCylinder(pos + vec3(0., cClock.height*(1./4. - cClock.facePos/2.), 0), vec2(cClock.diameter/2. - 0.01, cClock.height*cClock.facePos/2. - 0.01));\n    clockd = opU(vec2(face, FACE_OBJ), clockd);\n    \n    float axis = sdCylinder(pos - vec3(0., cClock.height*cClock.facePos + cClock.axisSize.y*0.5 - 0.25, 0), cClock.axisSize*vec2(1, 0.5));\n    clockd = opU(vec2(axis, AXIS_OBJ), clockd);\n    \n    #ifdef show_glass\n    if (cClock.glassTickness>0.)\n    {\n       float glass = sdCylinder(pos - vec3(0., cClock.height*0.75 - cClock.glassTickness*0.5 - 0.002, 0), vec2(cClock.diameter/2. - 0.01, cClock.glassTickness*0.5));\n       clockd = opU(vec2(glass, GLASS_OBJ), clockd);\n    }\n    #endif\n    \n    return clockd;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 0.02;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 128; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = inside?-res.x:res.x;\n        if (dist>maxdist || abs(dist)<0.000005)\n            break;\n        t+= dist*0.5;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec2 q = vec2(0, e);\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n\tvec3 rc = 1.5*texture(iChannel0, ray).rgb;\n    return rc;\n}\n\n// Gets the color of the sky\nvec3 sky_color_s(vec3 ray)\n{\n\tvec3 rc = 0.2 + vec3(4.5, 4.9, 4.5)*texture(iChannel1, ray).rgb;\n    return rc;\n}\n\nbool isInTick(vec3 pos, FaceTicks ticks)\n{\n    if (ticks.type==0)\n        return false;\n    else if (ticks.type==1)\n    {\n        float l = length(pos.xz)/(cClock.diameter/2. - cClock.caseThickness);\n        float angle = mod(atan(pos.x, pos.z) - 0.259, radians(ticks.tstep));\n        return (2.*abs(angle - radians(ticks.tstep)/2.)<radians(ticks.size.y)*(1. + (1./l - 1.)) && l<ticks.outPos && l>ticks.outPos-ticks.size.x);\n    }\n    else\n    {\n        float angle = mod(atan(pos.x, pos.z) + radians(ticks.tstep)/2., radians(ticks.tstep)) - radians(ticks.tstep)/2.;\n        //ticks.outPos*(cClock.diameter/2. - cClock.caseThickness)\n        vec2 pos2 = length(pos.xz)*vec2(cos(angle), sin(angle));\n        return distance(pos2, vec2(ticks.outPos*(cClock.diameter/2. - cClock.caseThickness), 0.))*60.<ticks.size.y;\n    }\n}\n\nvec3 getTicksColor(vec3 pos, Clock clock)\n{\n    return isInTick(pos, clock.hourTicks)?clock.hourTicks.color:(isInTick(pos, clock.minuteTicks)?clock.minuteTicks.color:clock.faceColor);\n    //return isInTick(pos, clock.hourTicks)?vec3(0.1):vec3(0.9);\n}\n    \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr)\n{\n    pos = pos.xzy;\n    pos = rotateVec2(pos);\n    \n    vec3 col = objnr==CASE_OBJ?cClock.caseColor:(\n               objnr==FACE_OBJ?getTicksColor(pos, cClock):(\n               objnr==AXIS_OBJ?cClock.axisColor:(\n               objnr==SHAND_OBJ?cClock.secondsHand.color:(\n               objnr==MHAND_OBJ?cClock.minutesHand.color:(\n               objnr==HHAND_OBJ?cClock.hoursHand.color:vec3(0.))))));\n    return col;\n}\n\n// Gets the flares of the lamps (kind of non-reflective specular...)\nvec3 getFlares(vec3 ray)\n{\n\tvec3 rc = vec3(0.);\n    #ifdef bulb\n    rc+= 1.6*clamp(normalize(lamps[1].color)*lamps[1].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[1].position - campos))), 150.), 0., 1.);\n    #endif\n    return rc;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN, but I changed the code\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<50; i++)\n    {\n    \tfloat h = map(ro + rd*t).x;\n        res = min(res, 10.0*h/t + 0.02*float(i));\n        t += 0.8*clamp(h, 0.01, 0.35);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<6; i++)\n    {\n        float hr = 0.01 + 0.12*float(i)/9.0;\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos).x;\n        occ+= -(dd - hr)*sca;\n        sca*= 0.85;\n    }\n    occ = 2.*smoothstep(0.06, 0.5, occ);\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dot(norm, pli));\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(vec3(lamp.position.x, 4.9, lamp.position.z) - pos), shf, 100.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside, bool reflect)\n{\n    vec2 tr = trace(tpos, ray, maxdist, inside);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    lamps[0] = Lamp(vec3(-2., 5., 20.), vec3(1., 1., 1.), 1.8, 0.01);\n    lamps[1] = Lamp(vec3(-5., 3, -12.), vec3(1., .95, .75), 0.9, 0.01);\n    lamps[2] = Lamp(vec3(16., 5., -8.), vec3(1., .6, .5), 0.7, 0.01);\n    \n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        col = getColor(norm, pos, objnr);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm));\n        //col = vec3(calcAO(pos, norm));\n        #endif\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        if (reflect)\n        \tcol = sky_color_s(ray);\n        else\n            col = sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections\nvec4 render(vec2 fragCoord)\n{   \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \n  RenderData traceinf = trace0(campos, ray, maxdist, false, false);\n  vec3 col = traceinf.col; // + getFlares(ray);\n  #ifdef reflections\n  for (int i=0; i<nbref; i++)\n  {\n      vec3 refray = reflect(ray, traceinf.norm);\n  \t  if (traceinf.objnr==CASE_OBJ || (traceinf.objnr==SHAND_OBJ && cClock.secondsHand.metallic) || (traceinf.objnr==MHAND_OBJ && cClock.minutesHand.metallic) || (traceinf.objnr==HHAND_OBJ && cClock.hoursHand.metallic))\n      {     \n          RenderData traceinf_ref = trace0(traceinf.pos, refray, 20., false, traceinf.objnr==CASE_OBJ);\n          float r = 0.5;\n          col = mix(col, col*traceinf_ref.col, r);  \n\n          ray = refray;\n          traceinf = traceinf_ref;\n      }\n  }\n  #endif\n  #ifdef show_glass\n  bool inside = true;\n  float cior = glass_ior;\n  vec3 glassf = vec3(1.);\n  if (traceinf.objnr==GLASS_OBJ)\n  {\n  \t\tvec3 norm = traceinf.norm;\n        vec3 ray_r = refract(ray, traceinf.norm, 1./glass_ior);\n        vec3 ray_r2;\n        \n        int n2;\n        for (int n=0; n<nbrefr; n++)\n        {\n            vec3 posr = traceinf.pos;\n        \ttraceinf = trace0(posr, ray_r, 20., inside, false);\n                \n            if (inside)\n                glassf*= cClock.glassColor;\n            else\n                traceinf.col+= getFlares(ray_r);\n\n            col+= traceinf.col*glassf;\n            col = clamp(col, 0., 1.);\n            \n            if (traceinf.objnr==GLASS_OBJ)\n            {\n      \t\t    ray_r2 = refract(ray_r, traceinf.norm, cior);\n        \t    if (length(ray_r2)!=0.)\n                {\n                    inside = !inside;\n                    cior = 1./cior;\n                }\n                else\n                    ray_r2 = reflect(ray_r, traceinf.norm);\n            }\n            else\n            {\n                col = traceinf.col*glassf;\n                break;\n            }\n            ray_r = ray_r2;\n            n2 = n;\n        }\n      \n        if ((traceinf.objnr==SHAND_OBJ && cClock.secondsHand.metallic) || (traceinf.objnr==MHAND_OBJ && cClock.minutesHand.metallic) || (traceinf.objnr==HHAND_OBJ && cClock.hoursHand.metallic))\n        {\n           vec3 refray = reflect(ray_r, traceinf.norm);\n           float r = 0.5;\n           col = mix(col, col*sky_color(refray), r); \n        }\n        // Outer reflection\n        float r = fresnel(ray, norm, glass_ior);\n        col = mix(col, sky_color(reflect(ray, norm)), r);\n  }\n  #endif\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initClock();\n    \n    vec2 iMouse2;\n    if (iMouse.x==0. && iMouse.y==0.)\n       iMouse2 = iResolution.xy*vec2(0.5, 0.5);\n    else\n       iMouse2 = iMouse.xy;\n    angle = 2.*pi*(iMouse2.x/iResolution.x - 0.5);\n    angle2 = -2.*pi*(iMouse2.y/iResolution.y - 0.5);\n    \n    // Antialiasing.\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = vs/vec4(aasamples*aasamples);\n}","name":"Image","description":"","type":"image"}]}