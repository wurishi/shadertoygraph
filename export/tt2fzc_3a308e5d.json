{"ver":"0.1","info":{"id":"tt2fzc","date":"1599551961","viewed":135,"name":"First Test Ray Marching ","username":"Utopia42","description":"JUST practice","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarcher based on https://www.shadertoy.com/view/lsBBDt\n\n\n#define PI 3.141592653589493238462643\nvec3 cylinder2cartesian(float r, float phi, float z)\n{\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nfloat dist_estimator(in vec3 pos)\n{\n    float r = length(pos);\n    float phi = atan(pos.y, pos.x);\n    float r1 = sin(1.5 * phi) + 1.5;\n    float z1 = cos(1.5 * phi);\n    float r2 = sin(1.5 * phi + PI) + 1.5;\n    float z2 = cos(1.5 * phi + PI);\n    vec3 p1 = cylinder2cartesian(r1, phi, z1);\n    vec3 p2 = cylinder2cartesian(r2, phi, z2);\n    return (min(distance(pos, p1), distance(pos, p2)) - 0.2) / 4.0;\n}\n\nfloat intersects(in vec3 src, in vec3 drt)\n{\n    float t;\n    for (int i = 0; i < 255; ++i)\n    {\n        float delta = dist_estimator(src + t * drt);\n        t += delta;\n        if (delta < 1e-5)\n            return t;\n    }\n    return 1e+5;\n}\n\nvec4 trace(in vec3 src, in vec3 dst)\n{\n    vec3 drt = normalize(dst - src);\n    vec3 light = vec3(1.5, 0.3, 0.3);\n    float t = intersects(src, drt);\n    if (t <= 1e+4)\n    {\n        vec3 surface_pos = src+ drt * t;\n        float strenth = dot(-drt, normalize(light - surface_pos));\n        return vec4(1, 1, 1, 1) * strenth;\n    }\n    else\n        return vec4(0, 0, 0, 1);\n}\nvec3 camera(in vec3 src, in vec3 lookat, in vec3 up, in vec2 uv)\n{\n    vec3 lookat_ = normalize(lookat - src);\n    vec3 right_ = normalize(cross(lookat_, up));\n    vec3 up_ = normalize(cross(right_, lookat_));\n    return src + lookat_ + (right_ * uv.x + up_ * uv.y) * 0.4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (vec2(fragCoord.x - iResolution.x / 2.0, fragCoord.y - iResolution.y / 2.0) / max(iResolution.x, iResolution.y)) * 2.0;\n    vec3 src = vec3(6.0 * cos(iTime / 2.0), 6.0 * sin(iTime / 2.0), 12.0);\n    vec3 dst = vec3(4.0, uv * 0.4);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = trace(src, camera(src, lookat, up, uv));\n    fragColor.rgb *= col;\n    \n}","name":"Image","description":"","type":"image"}]}