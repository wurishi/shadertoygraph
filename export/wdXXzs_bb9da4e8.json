{"ver":"0.1","info":{"id":"wdXXzs","date":"1552251687","viewed":65,"name":"Ray marching 2019","username":"vadim_kotov","description":"328 группа Котов Вадим","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP_NUM 500\n#define EPS 0.01\n#define MIN_STEP 0.01\n#define MAX_REFL_DEPTH 5\n\nvec3 cam;\n\nstruct Light\n{\n\tvec3 pos;\n    float intens;\n    vec3 color;\n};\n    \nLight[] lights = Light[](\n    \t\t\t\t\t\tLight(vec3(-300.0, 100.0, -300.0), 190000.0, vec3(1,0.6,0.6)),\n    \t\t\t\t\t\tLight(vec3(150.0, 150.0, -25.0), 100000.0, vec3(0.6, 1,0.6)), \n    \t\t\t\t\t\t//Light(vec3(100.0, -100.0, -50.0), 10000.0, vec3(0.6, 0.6, 1)),\n                        \tLight(vec3(0.0, 0.0, 0.0), 0.0, vec3(0,0,0))\n                        );\n\nstruct Ray\n{\n\tvec3 pos;\n    vec3 dir;\n};\n\nstruct Material\n{\n    vec3 diff_color;\n    vec3 spec_color;\n    float shine;\n\tvec3 reflection;\n    vec3 refraction;\n    float eta;\n};\n \nstruct Hit\n{\n\tint exist;\n    vec3 point;\n    float t;\n    vec3 normal;\n    Material material;\n};\n    \nmat2 Rot(float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n    \nvec4 Bilinear(sampler2D tex, vec2 texCoord, float texSize) \n{\n   vec2 trTexCoord = texCoord*texSize;\n   vec2 texf = floor(trTexCoord);\n   vec2 ratio = trTexCoord - texf;\n   vec2 opposite = 1.0 - ratio;\n   vec4 result = (texture(tex, texf/texSize) * opposite.x  + texture(tex, (texf+vec2(1, 0))/texSize)   * ratio.x) * opposite.y + \n                   (texture(tex, (texf+vec2(0, 1))/texSize) * opposite.x + texture(tex, (texf+vec2(1, 1))/texSize) * ratio.x) * ratio.y;\n   return result;\n}\n    \nfloat sdSphere(vec3 p)\n{\n    vec3 pos = vec3(0.0, 170.0, 100.0);\n    float r = 100.0;\n    \n\treturn length(pos - p) - r;\n}\n    \nHit hit_sdSphere( vec3 p)\t\t\t\t//dist(t),material\n{\n    Hit hit;\n    \n\thit.t = sdSphere(p);\n    \n    if(hit.t < EPS)\n    {\n        hit.material.diff_color = vec3(0.1, 0.1, 0.1);\n        hit.material.spec_color = vec3(0.5, 0.5, 0.5);\n        hit.material.shine = 50.0;\n        hit.material.reflection = vec3(0.1, 0.1, 0.1);\n        hit.material.refraction = vec3(0.0);\n        \n        vec2 e = vec2(EPS, 0.0);\n        \n        float Fx = (sdSphere(p + e.xyy) - sdSphere(p - e.xyy)) / 2.0*EPS;\n        float Fy = (sdSphere(p + e.yxy) - sdSphere(p - e.yxy)) / 2.0*EPS;\n        float Fz = (sdSphere(p + e.yyx) - sdSphere(p - e.yyx)) / 2.0*EPS;\n    \thit.normal = normalize(vec3(Fx, Fy, Fz));\n    }\n    \n    return hit;\n}\n\nfloat Plane(vec3 p)\n{\n  \tfloat height = -200.0;\n    \n\treturn p.y - height;\n}\n    \nHit hit_Plane( vec3 p)\t\t\t\t//dist(t),material\n{\n    Hit hit;\n    \n\thit.t = Plane(p);\n    \n    if(hit.t < EPS)\n    {\n        vec2 texCoord = fract(vec2(p.x/1024.0, p.z/1024.0));\n        float texSize = 1024.0;\n        //hit.material.diff_color = texture(iChannel0, texCoord).rgb;\tбез фильтрации\n        hit.material.diff_color = Bilinear(iChannel0, texCoord, texSize).rgb; //билинейная фильтрация\n        hit.material.spec_color = vec3(0, 0, 0);\n        hit.material.shine = 1.0;\n        hit.material.reflection = vec3(0.0);\n        hit.material.refraction = vec3(0.0);\n        \n        vec2 e = vec2(EPS, 0.0);\n        \n       /* float Fx = (sdSphere(p + e.xyy) - sdSphere(p - e.xyy)) / 2.0*EPS;\n        float Fy = (sdSphere(p + e.yxy) - sdSphere(p - e.yxy)) / 2.0*EPS;\n        float Fz = (sdSphere(p + e.yyx) - sdSphere(p - e.yyx)) / 2.0*EPS;\n    \thit.normal = normalize(vec3(Fx, Fy, Fz));*/\n        hit.normal = vec3(0, 1, 0);\n    }\n    \n    return hit;\n}\n\nfloat udBox(vec3 p, vec3 pos, vec3 b)\n{\n    float a_xz = -0.5;\n    \n    p -= pos;\n    p.xz *= Rot(a_xz);\n    vec3 d = abs(p) - b;\n\tfloat e = length(max(d, 0.0));\n    float i = min(max(max(d.x, d.y), d.z), 0.0);\n    return e + i;\n}\n    \nvec3 BoxColor(vec3 p, vec3 c, vec3 b)\n{\n   \n\tvec3 a = p - c;\n    a.xz *= Rot(-0.5);\n    a += b;\n    float size = 2.0*b.x;\n    a.x = float(int(floor(a.x)) % int(size/4.0));\n    a.z = float(int(floor(a.z)) % int(size/4.0));\n    if(max(a.x, a.z) <= size/8.0 || min(a.x, a.z) > size/8.0)\n        return vec3(0.5,0,0);\n    return vec3(0.5,0.5,0.5);\n}\n\nHit hit_udBox( vec3 p)\t\t\t\t//dist(t),material\n{\n    Hit hit;\n    \n    vec3 c = vec3(0.0, -175, 500);\n    vec3 b = vec3(600.0, 25.0, 600.0);\n\thit.t = udBox(p, c, b);\n    \n    if(hit.t < EPS)\n    {\n        hit.material.diff_color = BoxColor(p, c, b);\n        hit.material.spec_color = vec3(0.0, 0.0, 0.0);\n        hit.material.shine = 50.0;\n        hit.material.reflection = vec3(0.8, 0.8, 0.8);\n        hit.material.refraction = vec3(0.0);\n        \n        vec2 e = vec2(EPS, 0.0);\n        \n        float Fx = (udBox(p + e.xyy, c, b) - udBox(p - e.xyy, c, b)) / 2.0*EPS;\n        float Fy = (udBox(p + e.yxy, c, b) - udBox(p - e.yxy, c, b)) / 2.0*EPS;\n        float Fz = (udBox(p + e.yyx, c, b) - udBox(p - e.yyx, c, b)) / 2.0*EPS;\n    \thit.normal = normalize(vec3(Fx, Fy, Fz));\n    }\n    \n    return hit;\n}\n\n/***********************************************************************************/\n\nfloat CQCone(vec3 p, vec3 pos, vec2 c)\n{\n    p -= pos;\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\nfloat CQBox(vec3 p, vec3 pos, vec3 b)\n{\n     p -= pos;\n  \n    vec3 d = abs(p) - b;\n\tfloat e = length(max(d, 0.0));\n    float i = min(max(max(d.x, d.y), d.z), 0.0);\n    return e + i;\n}\n\nfloat CQSphere5(vec3 p)\n{\n\tvec3 pos = vec3(0.0, 173.0, 0.0);\n   \tfloat r = 10.0;\n    \n\treturn length(pos - p) - r;\n}\n\nfloat CQBox4(vec3 p)\n{\n\tvec3 pos = vec3(0,0,0);\n    vec3 b = vec3(100, 18,100);\n    return CQBox(p, pos, b);\n}\n\nfloat CQCone4(vec3 p)\n{\n    vec3 pos = vec3(0,50,0);\n\tvec2 c = normalize(vec2(3,1));\n    return CQCone(p, pos, c);\n}\n\nfloat CQCappedCone4(vec3 p)\n{\n    vec3 pos = vec3(0, 145, 0);\n    p -= pos;\n    p.yz *= Rot(3.14);\n\tfloat d1 = CQCone4(p);\n    float d2 = CQBox4(p);\n    return max(d1, d2);\n}\n\nfloat CQCone3(vec3 p)\n{\n    vec3 pos = vec3(0,30,0);\n \tvec2 c = normalize(vec2(2, 1));\n\treturn CQCone(p, pos, c);\n}\n\nfloat CQBox3(vec3 p)\n{\n    vec3 pos = vec3(0, 0, 0);\n    vec3 b = vec3(100, 10, 100);\n    \n\treturn CQBox(p, pos, b);\n}\n\nfloat CQCappedCone3(vec3 p)\n{\n    vec3 pos = vec3(0, 117, 0);\n    p -= pos;\n\tfloat d1 = CQCone3(p);\n    float d2 = CQBox3(p);\n    return max(d1, d2);\n}\n\nfloat CQCone2(vec3 p)\n{\n    vec3 pos = vec3(0,100,0);\n \tvec2 c = normalize(vec2(7, 1));\n\treturn CQCone(p, pos, c);\n}\n\nfloat CQBox2(vec3 p)\n{\n    vec3 pos = vec3(0, 0, 0);\n    vec3 b = vec3(100, 40, 100);\n    \n\treturn CQBox(p, pos, b);\n}\n\nfloat CQCappedCone2(vec3 p)\n{\n    vec3 pos = vec3(0, 68, 0);\n    p -= pos;\n\tfloat d1 = CQCone2(p);\n    float d2 = CQBox2(p);\n    return max(d1, d2);\n}\n\nfloat CQSphere1(vec3 p)\n{\n\tvec3 pos = vec3(0.0, 0.0, 0.0);\n   \tfloat r = 35.0;\n    \n\treturn length(pos - p) - r;\n}\n\nfloat CQBox1(vec3 p)\n{\n\tvec3 pos = vec3(0, 15, 0);\n    vec3 b = vec3(100, 15, 100);\n     \n\treturn CQBox(p, pos, b);\n}\n\nfloat CQCappedSphere1(vec3 p)\n{\n    float d1 = CQSphere1(p);\n    float d2 = CQBox1(p);\n    return max(d1, d2);\n}\n\nfloat ChessQueen(vec3 p)\n{\n    vec3 pos = vec3(-155, -150, -00);\n    p -= pos;\n    \n\tfloat d1 = CQCappedSphere1(p);\n   \tfloat d2 = CQCappedCone2(p);\n    float d3 = CQCappedCone3(p);\n    float d4 = CQCappedCone4(p);\n    float d5 = CQSphere5(p);\n    return min(min(min(min(d1, d2), d3), d4), d5);\n}\n    \nHit hit_ChessQueen( vec3 p)\t\t\t\t//dist(t),material\n{\n    Hit hit;\n    \n\thit.t = ChessQueen(p);\n    \n    if(hit.t < EPS)\n    {\n        hit.material.diff_color = vec3(0.01, 0.01, 0.02);\n        hit.material.spec_color = vec3(0.5, 0.5, 0.5);\n        hit.material.shine = 50.0;\n        hit.material.reflection = vec3(0.0);\n        hit.material.refraction = vec3(0.0);\n        \n        vec2 e = vec2(EPS, 0.0);\n        \n        float Fx = (ChessQueen(p + e.xyy) - ChessQueen(p - e.xyy)) / 2.0*EPS;\n        float Fy = (ChessQueen(p + e.yxy) - ChessQueen(p - e.yxy)) / 2.0*EPS;\n        float Fz = (ChessQueen(p + e.yyx) - ChessQueen(p - e.yyx)) / 2.0*EPS;\n    \thit.normal = normalize(vec3(Fx, Fy, Fz));\n    }\n    \n    return hit;\n}\n\n/**********************************************************************************/\n\nHit hit_Cone( vec3 p)\t\t\t\t//dist(t),material\n{\n    Hit hit;\n    \n    vec3 pos = vec3(300, -70, -160);\n    vec2 c = normalize(vec2(1,1));\n    \n\thit.t = CQCone(p, pos, c);\n    \n    if(hit.t < EPS)\n    {\n        hit.material.diff_color = vec3(0.0, 0.1, 0.4);\n        hit.material.spec_color = vec3(1.0, 1.0, 1.0);\n        hit.material.shine = 70.0;\n        hit.material.reflection = vec3(0.0);\n        hit.material.refraction = vec3(0.5, 0.5, 0.5);\n        hit.material.eta = 1.33;\n        \n        vec2 e = vec2(EPS, 0.0);\n        \n        float Fx = (CQCone(p + e.xyy, pos, c) - CQCone(p - e.xyy, pos, c)) / 2.0*EPS;\n        float Fy = (CQCone(p + e.yxy, pos, c) - CQCone(p - e.yxy, pos, c)) / 2.0*EPS;\n        float Fz = (CQCone(p + e.yyx, pos, c) - CQCone(p - e.yyx, pos, c)) / 2.0*EPS;\n    \thit.normal = normalize(vec3(Fx, Fy, Fz));\n    }\n    \n    return hit;\n}\n\nHit DistToScene(vec3 pos)\t\t\t//min(dist(t))\n{    \n    Hit m = hit_Plane(pos);\n    Hit b = hit_sdSphere(pos);\n    if(b.t < m.t)\n    \tm = b;\n    b = hit_udBox(pos);\n    if(b.t < m.t)\n        m = b;\n  \tb = hit_Cone(pos);\n    if(b.t < m.t)\n        m = b;\n    b = hit_ChessQueen(pos);\n    if(b.t < m.t)\n        m = b;\n        \n   \treturn m;\n}\n\nHit RaySceneIntersection(Ray ray)\t//exist,point\n{\n    Hit hit;\n    \n    hit.exist = 0;\n    \n    for(int i = 0; i < MAX_STEP_NUM; i++)\n    {\n        hit = DistToScene(ray.pos);\n        if(abs(hit.t) < EPS)\n        {\n        \thit.exist = 1;\n            hit.point = ray.pos;\n            return hit;\n        }\n        \n        if(hit.t > MIN_STEP)\n        \tray.pos += ray.dir*hit.t;\n        else\n            ray.pos += MIN_STEP;\n    }\n    return hit;\n}\n\nHit Visible(vec3 point, vec3 l_pos)\n{\n    vec3 dir = normalize(l_pos - point);\n\treturn RaySceneIntersection(Ray(point, dir));\n}\n\nvec3 Shade(Hit hit, Light l)\n{\n    \n    float Diff = clamp(dot(normalize(l.pos - hit.point), hit.normal), 0.0, 1.0);\n    vec3 K = l.intens*l.color/pow(length(l.pos - hit.point), 2.0);\n    \n    float Spec = pow(clamp(dot(normalize(cam - hit.point), reflect(-normalize(l.pos - hit.point), hit.normal)), 0.0, 1.0), hit.material.shine);\n    \n    return (Diff*hit.material.diff_color + Spec*hit.material.spec_color)*K;\n}\n\nRay ray_reflect(Ray ray, Hit hit)\n{\n\tray.dir = reflect(ray.dir, hit.normal);\n    ray.pos = hit.point + ray.dir*EPS*2.0;\n    return ray;\n}\n\nRay ray_refract(Ray ray, Hit hit)\n{\n    vec3 n;\n    float eta;\n    \n    float cosr = dot(ray.dir, hit.normal);\n    if(cosr < 0.0)\n    {\n   \t\tn = -hit.normal;\n    \teta = 1.0/hit.material.eta;\n    }\n    else\n    {\n\t\tn = hit.normal;\n        eta = hit.material.eta;\n    }\n    \n    ray.dir = refract(ray.dir, n, eta);\n    ray.pos = hit.point + ray.dir*EPS*5.0;\n    return ray;\n}\n\nvec3 RayTrace(Ray ray)\n{\n\tvec3 bg_color = vec3(0, 0.1, 0.1);\n    vec3 color = vec3(0.0);\n    vec3 k = vec3(1.0, 1.0, 1.0);\n    vec3 refl;\n    vec3 refr;\n    \n    for(int r = 0; r < MAX_REFL_DEPTH; r++)\n    {\n    \n\t\tHit hit = RaySceneIntersection(ray);\n\t\tif (hit.exist == 0)\n\t\t\treturn color + k*bg_color;\n    \n    \tvec3 Amb = vec3(0.1,0.1,0.1);\n    \tcolor += k*Amb*hit.material.diff_color;\n    \n    \tfor(int i = 0; ; i++)\n    \t{\n    \t\tif(lights[i].intens == 0.0)\n            \tbreak;\n        \n        \tHit V = Visible(hit.point + hit.normal*EPS*2.0, lights[i].pos);\n        \tif(V.exist == 0 || distance(hit.point, lights[i].pos) < distance(hit.point, V.point))\n        \t{\n            \tcolor += k*Shade(hit, lights[i]);\n        \t}\n        }\n        \n        refl = hit.material.reflection;\n        if(max(max(refl.x, refl.y), refl.z) > 0.0)\n        {\n            k *= refl;\n            ray = ray_reflect(ray, hit);\n            continue;\n        }\n        \n       \n\t/*\trefr = hit.material.refraction;\n\t\tif(max(max(refr.x, refr.y), refr.z) > 0.0)\n        {\n         \tk *= refr;\n            ray = ray_refract(ray, hit);\n            continue;\n        }*/\n        \n        break;\n    }\n    \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy;\n\n    Ray p_ray;\n    \n    cam = vec3(0, 0, -(iResolution.x/2.0));\n\n    p_ray.pos = cam;\n    \n    vec3 xyz = vec3(fragCoord.x - iResolution.x/2.0, fragCoord.y - iResolution.y/2.0, 0);\n    \n    p_ray.dir = normalize(xyz - cam);\n    vec3 col = RayTrace(p_ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}