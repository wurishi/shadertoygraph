{"ver":"0.1","info":{"id":"lfXGDX","date":"1703625761","viewed":75,"name":"Cloud test 2.1","username":"roey_shap","description":"Sebastian Lague inspired","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WHITE vec3(1.0)\n#define BLACK vec3(0.0)\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n#define numDayColors 6\n\nvec3 colors[numDayColors] = vec3[numDayColors](\n    vec3(1.0, 1.0, 0.1),  // morn\n    vec3(0.2, 0.3, 0.8),  // mid\n    vec3(1.0, 0.0, 0.2),  // eve\n    vec3(0.15, 0.2, 0.45),  // twilight\n    vec3(0.05, 0.15, 0.3),   // night\n    vec3(0.4, 0.1, 0.45)   // dawn    \n);\n\n// these are overwritten later //\nvec3 lightPos = vec3(1.0, 1.5, -1.0);\n\nvec3 spherePos = vec3(0.0, -1.0, -1.0);\nfloat sphereRad = 2.0;\n\nvec3 cloudScale = vec3(2.0);\nvec3 cloudOffset = vec3(0.0, 0.0, 0.0);\n//                             //\n\n\n\nfloat map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\n\nvec2 getSphereIntersectionDistances(vec3 rayOrigin, vec3 rayDirection, \n                                    vec3 sphereCenter, float radius)\n{\n    float radiusSquared = radius * radius;\n    vec3 originToSphere = sphereCenter - rayOrigin;\n    float distToSphereCenter = length(originToSphere);\n    float inside = float(distToSphereCenter < radius);\n    float distOrigChordMid = dot(originToSphere, rayDirection);\n    float distCenterToChordMidSquared = (distToSphereCenter * distToSphereCenter) - (distOrigChordMid * distOrigChordMid);\n    float halfChordLength = radiusSquared - distCenterToChordMidSquared;\n    if (halfChordLength > 0.0)\n    {\n        halfChordLength = sqrt(halfChordLength);\n        float t0 = mix(distOrigChordMid - halfChordLength, 0.0, inside);\n        float t1 = distOrigChordMid + halfChordLength;\n        return vec2(t0, t1);\n    } \n       \n    return vec2(0, -1);\n}\n\n// from https://www.shadertoy.com/view/XslGRr\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n    x = p + f;\n    return (textureLod(iChannel0,(x+0.5)/32.0,0.0).x*2.0-1.0);\n}\n\nfloat cloudDensity(in vec3 x)\n{\n    x = cloudOffset + (x * cloudScale / (sphereRad * sphereRad));\n    int numIters = 3;\n    float factorInit = 2.0;\n    float factor = factorInit;\n    float d = noise(x);\n    for (int i = 0; i < numIters; i++)\n    {\n        d += noise(x * factor) / factor;\n        factor *= factorInit;\n    }\n    \n    return 0.5 - d;\n}\n\nfloat lightAtPoint(in vec3 p)\n{\n    vec3 toLightDir = normalize(lightPos - p);\n    vec2 sphereDistances = getSphereIntersectionDistances(p, toLightDir, spherePos, sphereRad);\n    float sphereIntDist = sphereDistances.y - sphereDistances.x;\n\n    if (sphereIntDist < 0.0)\n    {\n        return 0.0;\n    }\n    \n    float totalDensity = 0.0;\n    int numSteps = 3;\n    \n    float stepSize = sphereIntDist / float(numSteps);\n    vec3 samplePosition = p;\n    for (int i = 0; i < numSteps; i++)\n    {\n        //float sqDis = sphereRad / length(samplePosition - spherePos);\n        //sqDis = pow(sqDis, 5.0);\n        //float radiusDensity = sphereRad * (1.0 - (1.0 / (sqDis + 0.001)));\n        //radiusDensity = map(0.0, 1.0, radiusDensity, 0.0, 1.0);\n        float density = cloudDensity(samplePosition);// * radiusDensity;\n        totalDensity += max(0.0, density * stepSize);\n        samplePosition += toLightDir;\n    }\n\n    float transmittance = exp(-totalDensity);\n    \n    return transmittance;\n}\n\nvec3 getDayCol(int i)\n{\n    i = i < 0 ? i + numDayColors : i;\n    i %= numDayColors;\n    return colors[i];\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float dayDuration = 10.0;   // seconds\n    float globalTime = fract(iTime / dayDuration);   // 'days'\n    lightPos = vec3(10.0 * cos(globalTime * TWO_PI), 10.0 * sin(globalTime * TWO_PI), 0.0);\n    spherePos = vec3(0.0, -0.5, -1.0);\n    sphereRad = 1.7; //map(-1.0, 1.0, sin(iTime * 3.0), 1.0, 4.0);\n    cloudScale = vec3(2.0);\n    cloudOffset = vec3(0.0, 0.0, iTime * cloudScale);\n   \n    float focalDistance = 1.0;\n    vec3 camPos = vec3(0.0, 0.0, 2.0);\n    vec2 uv2D = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 pixelPosition = vec3(uv2D, camPos.z - focalDistance);\n    vec3 viewRayDir = normalize(pixelPosition - camPos);\n    \n    float dayCycleColorSection = 0.0;\n    \n    \n    vec3 lightColor = vec3(1.0);\n    vec3 skyColor;\n    float nearestFraction = floor(globalTime * float(numDayColors)) / float(numDayColors);\n    float fracBetweenN = (globalTime - nearestFraction) * float(numDayColors);\n    int n = int(nearestFraction * float(numDayColors));\n    vec3 c1 = getDayCol(n-1);\n    vec3 c2 = getDayCol(n);\n    vec3 target1 = mix(c1, c2, fracBetweenN);\n    vec3 c3 = getDayCol(n+1);\n    vec3 target2 = mix(c2, c3, fracBetweenN);\n    skyColor = mix(target1, target2, map(-1.0, 1.0, dot(viewRayDir, normalize(lightPos - (viewRayDir * 0.2))), 0.0, 1.0));\n    vec3 col = skyColor;\n    \n    vec2 sphereDistances = getSphereIntersectionDistances(camPos, viewRayDir, spherePos, sphereRad);\n    float sphereIntDist = sphereDistances.y - sphereDistances.x;\n\n    float transmittance = 1.0;\n    float lightEnergy = 0.0;\n    int numSteps = 10;\n    if (sphereIntDist > 0.0)\n    {\n        float stepSize = sphereIntDist / float(numSteps);\n        vec3 samplePosition = camPos + (viewRayDir * sphereDistances.x * 1.0001); // <- to fix edge discrepencies\n        for (int i = 0; i < numSteps; i++)\n        {\n            //float sqDis = sphereRad / length(samplePosition - spherePos);\n            //sqDis = pow(sqDis, 5.0);\n            //float radiusDensity = sphereRad * (1.0 - (1.0 / (sqDis + 0.001)));\n            //radiusDensity = map(0.0, 1.0, radiusDensity, 0.0, 1.0);\n            float density = cloudDensity(samplePosition);// * radiusDensity;\n            if (density > 0.0)\n            {\n                float lightTransmittance = lightAtPoint(samplePosition);\n                float stepDensity = density * stepSize;\n                lightEnergy += stepDensity * transmittance * lightTransmittance;\n                transmittance *= exp(-stepDensity);\n                \n                if (transmittance < 0.01)\n                {\n                    break;\n                }\n            }\n            \n            samplePosition += viewRayDir * stepSize;\n        }\n        \n        vec3 cloudColor = lightEnergy * lightColor * 1.1;\n        vec3 backgroundColor = transmittance * skyColor;\n        \n        col = cloudColor + backgroundColor;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}