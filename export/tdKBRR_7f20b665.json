{"ver":"0.1","info":{"id":"tdKBRR","date":"1606447173","viewed":86,"name":"candleflames","username":"Ezra_Szanton","description":"trying to make some fire","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//hash function taken from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat smoothNoise(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv * lv * (3. - 2.*lv);\n    \n    float bl = hash12(id);\n    float br = hash12(id + vec2(1., 0.));\n    \n    float b = mix(bl, br, lv.x);\n    \n    \n    float tl = hash12(id + vec2(0., 1.));\n    float tr = hash12(id + vec2(1., 1.));\n    \n    float t = mix(tl, tr, lv.x);\n    \n    float c = mix(b,t, lv.y);\n    return c;\n}\n\nfloat perlin(vec2 uv)\n{\n    \n    float c = smoothNoise(uv * 4.* sin(iTime * 0.01 + .113));\n    c += smoothNoise(uv * 8. * sin(iTime * 0.12)) * 0.5;\n    c += smoothNoise(uv * 16. * sin(iTime * 0.1 + 1.213)) * 0.25;\n    c += smoothNoise(uv * 32.* sin(iTime * 0.042 + .213)) * 0.125;\n    c += smoothNoise(uv * 64. * sin(iTime * 0.0037 + .113)) * 0.0625;\n    c /= 2.;\n    return c;\n}\nfloat circle(vec2 uv, vec2 center, float max, float min)\n{\n    return smoothstep(max, min, length(uv - center));\n}\n\nvec3 fireGradient(float normalized)\n{\n    vec3 blue = vec3(0.35, 0.45, 1.);\n    vec3 yellow = vec3(0.95, 0.85, 0.2);\n    vec3 red = vec3(0.85, 0.45, 0.2);\n    vec3 black = vec3(0.1,0.1,0.1);\n    \n    if(normalized < 0.3)\n    {\n    \treturn mix(black, red, smoothstep(0., 0.3, normalized));   \n    } else if(normalized < 0.4)\n    {\n    \treturn mix(red, yellow, smoothstep(0.3, 0.4, normalized));   \n    } else if(normalized >= 0.)\n    {\n    \treturn mix(yellow, blue, smoothstep(0.4, 1., normalized));   \n    }\n    \n    return black;\n}\n\nfloat spark(vec2 uv, float x, float modulo, float max, float i)\n{\n    return circle(uv + (i * 0.1), vec2(x, mod(iTime, modulo - i * 0.1) - .6), max + (i * 0.1), 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.*iResolution.xy)/iResolution.y;\n    \n    uv *= 1.5;\n    //uv.y += 0.5;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float verticalHeat = 1. - uv.y;\n    float heat = 0.;\n    \n    float perlinDisplacement = perlin(uv) * 0.3;\n    uv += vec2(perlinDisplacement * 1.5, perlinDisplacement * 0.2);\n    \n    float circleHeat = 0.;\n    \n    for(float i = 1.; i < 6.; i += 1.){\n\n    circleHeat += spark(uv, 0.8, 4.4, 0.5, i) * (1. / i);\n    circleHeat += spark(uv, 0.2, 5., 0.2, i) * (1. / i);\n    circleHeat += spark(uv, 1.2, 2.5, 0.3, i) * (1. / i);\n    circleHeat += spark(uv, 2.1, 6.1, 0.4, i) * (1. / i);\n    circleHeat += spark(uv, 2.5, 11., 0.6, i) * (1. / i);\n    circleHeat += spark(uv, 0.6, 3.3, 0.2, i) * (1. / i);\n        \n       \n    }\n    \n    heat += circleHeat * 0.5;\n    heat += verticalHeat * 0.5;\n    heat += perlin(uv) * perlin(uv) * 0.5;\n    \n    heat *= verticalHeat;\n    //heat *= verticalHeat;\n    \n    heat *= (sin(uv.x * 5. + iTime) + sin(uv.x * 3.) + sin(uv.x * 7.)) / 3.;\n    \n    col += fireGradient(heat);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}