{"ver":"0.1","info":{"id":"4s2BDc","date":"1502545959","viewed":206,"name":"Quasicrystal dipole zoom","username":"ttoinou","description":"Tweaked [url=https://www.shadertoy.com/view/4tcXDl]Quasicrystal zoom[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["quasicrystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Number of plane waves\nconst int K = 5;\n\n// Number of stripes per wave\nconst int NUM_STRIPES = 7;\n\nconst int NUM_FREQUENCIES = 10;\n\n// The main (central) spatial frequency\nfloat MEAN_FREQUENCY = 2.;\n\n// The spread of the spatial frequency envelope\nconst float SIGMA = 2.;\n\nconst float PERIOD = 4.;\n\nconst float PI = 4.0 * atan(1.0);\n\nfloat mean;\n\nfloat gaussian(float x) {\n    x -= mean;\n    return exp(-x * x / 2.) / SIGMA;\n}\n\n// Adjust the  wavelengths for the current spatial scale\nfloat wavelength(int i, float sc) {\n    return pow(2., float(i)) * sc;\n}\n\n// Modulate each wavelength by a Gaussian envelope in log\n// frequency, centered around aforementioned mean with defined\n// standard deviation\nfloat weight(int i, float sc) {\n    return gaussian(log(wavelength(i, sc)));\n}\n\n// 7-th order smoothstep function:\n// https://en.wikipedia.org/wiki/Smoothstep\n// https://gist.github.com/kylemcdonald/77f916240756a8cfebef\nfloat superSmooth(float x) {\n\tfloat xSquared = x * x;\n\treturn xSquared * xSquared * (x * (x * (x * -20. + 70.) - 84.) + 35.);\n}\n\nfloat quasi(in vec2 uv, float rotation) {\n\tfloat scale = pow(0.5, fract(iTime / PERIOD));\n\n    float weightSum = 0.;\n    for (int l = 0; l < NUM_FREQUENCIES; l++) {\n        weightSum += weight(l, scale);\n    }\n    \n    // Cartesian coordinates\n\tvec2 coords = uv * 2. * PI * float(NUM_STRIPES);\n\n    float c = 0.;  // Accumulator\n    \n    // Iterate over all k plane waves\n    for (int t = 0; t < K; t++) {\n    \tfloat tScaled = ( float(t) / float(K) + rotation ) * PI;\n        vec2 omega = vec2(cos(tScaled), sin(tScaled));\n\n        // Compute the phase of the plane wave\n        float ph = dot(coords, omega);\n\n        // Take a weighted sum over the different spatial scales\n        for (int l = 0; l < NUM_FREQUENCIES; l++) {\n\t\t\tc += cos(ph * wavelength(l, scale)) * weight(l, scale);\n        }\n    }\n    // Convert the summed waves to a [0,1] interval\n    // and then convert to color\n    return superSmooth((c / (weightSum * float(K)) + 1.) / 2.);\n\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 uv = (coord.xy - iResolution.xy / 2.) / iResolution.x;\n    vec2 dipole = vec2(.2,.0);\n    float rot = iTime/17.;\n    MEAN_FREQUENCY = 2.;\n    mean = MEAN_FREQUENCY * log(2.);\n        \n    col =vec4(.0);\n    col.r +=  quasi(uv-dipole,rot)*.8;\n    \n    MEAN_FREQUENCY *= sqrt(2.);\n    mean = MEAN_FREQUENCY * log(2.);\n    col.b += quasi(uv+dipole,-rot*sqrt(3./2.));\n    \n    col.g = (col.r+col.b)/2.;\n}","name":"Image","description":"","type":"image"}]}