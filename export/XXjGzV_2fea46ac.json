{"ver":"0.1","info":{"id":"XXjGzV","date":"1708630757","viewed":42,"name":"Jay's first Rayarching","username":"JayFoDra","description":"My first try in dealing with raymarching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float t) {\n    vec3 a = vec3(0.375, 0.771, 0.740); \n    vec3 b = vec3(0.070, 0.542, 0.599);\n    vec3 c = vec3(1.053, 1.265, 1.005);\n    vec3 d = vec3(0.208, 4.148, 5.118);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nfloat map(vec3 p) {\n    vec3 sPos = vec3(1.0 * sin(iTime), 1.0 * cos(iTime), -1.25 + iTime*1.0);\n    vec3 bPos = vec3(0.0, 0.0, 0.0);\n    \n    float sphere = sdSphere(p - sPos, .5);\n    float ground = sdPlane(p, vec3(0.0, 1.0, 0.0), .75);\n    \n    vec3 q = p;    \n    q = mod(q, 1.0) - 0.5; //equal to fract(q) - 0.5\n    \n    q.xz *= rot2D(iTime);\n    \n    float box = sdBox(q - bPos, vec3(0.2));\n    \n    return min(opSmoothUnion(sphere, ground, 0.25), opSmoothUnion(opSmoothSubtraction(sphere, box, 1.0), ground, 0.25));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //init\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float fov = 2.0;\n\n    vec3 ro = vec3(0.0, 0.0, -3.0 + iTime*1.0);     //ray origin\n    vec3 rd = normalize(vec3(uv * fov, 1.0)); //ray direction\n    vec3 col = vec3(0.0);\n\n    int s = 0; //marching stepcount\n    float t = 0.0; //total distance\n    \n    float md = 100.0; //max ray distance\n    float e = 0.001;  //epsylon\n    \n    //raymarching\n    while(t < md){\n        vec3 p = ro + rd * t;\n        \n        float d = map(p);\n        \n        t += d;\n        s++;\n        \n        if(d <= e) break;\n    }\n    \n    // cloloring\n    col = vec3(palette(t * .15 + float(s) * 0.003));\n    \n    fragColor = vec4(col * t, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// SDF primitives\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n\n// smooth combination\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//rotation\nvec3 rot3D(vec3 p, vec3 axis, float rad) {\n    // Rodrigues' rotation\n    return mix(dot(axis, p) * axis, p, cos(rad) + cross(axis, p) * sin(rad));\n}\n\nmat2 rot2D(float rad){\n    float s = sin(rad);\n    float c = cos(rad);\n    return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"}]}