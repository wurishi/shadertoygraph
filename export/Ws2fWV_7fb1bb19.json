{"ver":"0.1","info":{"id":"Ws2fWV","date":"1590869963","viewed":2155,"name":"N64 bilinear filter (3-point)","username":"cyrb","description":"Demonstrates the 3-point bilinear filtering used on the RDP on Nintendo 64.\n\nPort of DKO's 3point GLSL shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["filter","bilinear","n64","3point","nintendo64"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// to use on shadertoy.com\n// DKO's 3point GLSL shader\n\nvec2 norm2denorm(sampler2D tex, vec2 uv)\n{\n    return uv * vec2(textureSize(tex, 0)) - 0.5;\n}\n\nivec2 denorm2idx(vec2 d_uv)\n{\n    return ivec2(floor(d_uv));\n}\n\nivec2 norm2idx(sampler2D tex, vec2 uv)\n{\n    return denorm2idx(norm2denorm(tex, uv));\n}\n\nvec2 idx2norm(sampler2D tex, ivec2 idx)\n{\n    vec2 denorm_uv = vec2(idx) + 0.5;\n    vec2 size = vec2(textureSize(tex, 0));\n    return denorm_uv / size;\n}\n\nvec4 texel_fetch(sampler2D tex, ivec2 idx)\n{\n    vec2 uv = idx2norm(tex, idx);\n    return texture(tex, uv);\n}\n\n#if 0\nfloat find_mipmap_level(in vec2 texture_coordinate) // in texel units\n{\n    vec2  dx_vtc        = dFdx(texture_coordinate);\n    vec2  dy_vtc        = dFdy(texture_coordinate);\n    float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));\n    float mml = 0.5 * log2(delta_max_sqr);\n    return max( 0, mml ); // Thanks @Nims\n}\n#endif\n\n\n/*\n * Unlike Nintendo's documentation, the N64 does not use\n * the 3 closest texels.\n * The texel grid is triangulated:\n *\n *     0 .. 1        0 .. 1\n *   0 +----+      0 +----+\n *     |   /|        |\\   |\n *   . |  / |        | \\  |\n *   . | /  |        |  \\ |\n *     |/   |        |   \\|\n *   1 +----+      1 +----+\n *\n * If the sampled point falls above the diagonal,\n * The top triangle is used; otherwise, it's the bottom.\n */\n\nvec4 texture_3point(sampler2D tex, vec2 uv)\n{\n    vec2 denorm_uv = norm2denorm(tex, uv);\n    ivec2 idx_low = denorm2idx(denorm_uv);\n    vec2 ratio = denorm_uv - vec2(idx_low);\n\n#define FLIP_DIAGONAL\n\n#ifndef FLIP_DIAGONAL\n    // this uses one diagonal orientation\n    #if 0\n    // using conditional, might not be optimal\n    bool lower_flag = 1.0 < ratio.s + ratio.t;\n    ivec2 corner0 = lower_flag ? ivec2(1, 1) : ivec2(0, 0);\n    #else\n    // using step() function, might be faster\n    int lower_flag = int(step(1.0, ratio.s + ratio.t));\n    ivec2 corner0 = ivec2(lower_flag, lower_flag);\n    #endif\n    ivec2 corner1 = ivec2(0, 1);\n    ivec2 corner2 = ivec2(1, 0);\n#else\n    // orient the triangulated mesh diagonals the other way\n    #if 0\n    bool lower_flag = ratio.s - ratio.t > 0.0;\n    ivec2 corner0 = lower_flag ? ivec2(1, 0) : ivec2(0, 1);\n    #else\n    int lower_flag = int(step(0.0, ratio.s - ratio.t));\n    ivec2 corner0 = ivec2(lower_flag, 1 - lower_flag);\n    #endif\n    ivec2 corner1 = ivec2(0, 0);\n    ivec2 corner2 = ivec2(1, 1);\n#endif\n    ivec2 idx0 = idx_low + corner0;\n    ivec2 idx1 = idx_low + corner1;\n    ivec2 idx2 = idx_low + corner2;\n\n    vec4 t0 = texel_fetch(tex, idx0);\n    vec4 t1 = texel_fetch(tex, idx1);\n    vec4 t2 = texel_fetch(tex, idx2);\n\n    // This is standard (Crammer's rule) barycentric coordinates calculation.\n    vec2 v0 = vec2(corner1 - corner0);\n    vec2 v1 = vec2(corner2 - corner0);\n    vec2 v2 = ratio   - vec2(corner0);\n    float den = v0.x * v1.y - v1.x * v0.y;\n    /*\n     * Note: the abs() here is necessary because we don't guarantee\n     * the proper order of vertices, so some signed areas are negative.\n     * But since we only interpolate inside the triangle, the areas\n     * are guaranteed to be positive, if we did the math more carefully.\n     */\n    float lambda1 = abs((v2.x * v1.y - v1.x * v2.y) / den);\n    float lambda2 = abs((v0.x * v2.y - v2.x * v0.y) / den);\n    float lambda0 = 1.0 - lambda1 - lambda2;\n\n    return lambda0*t0 + lambda1*t1 + lambda2*t2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/1024.0;\n#if 0\n    //regular texture mapping\n    vec3 col = texture(iChannel0, uv).rgb;\n#else\n    // 3-point filtering\n    vec3 col = texture_3point(iChannel0, uv).rgb;\n#endif\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}