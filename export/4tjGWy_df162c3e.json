{"ver":"0.1","info":{"id":"4tjGWy","date":"1432046026","viewed":1439,"name":"Pixellated Plasma + mouse","username":"104","description":"just playing around with a_to_color(), a simple plasma function, and pixellation effect. Use mouse to move highlight and change pixellation size","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["2d","plasma","pixellate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// sin() that returns 0-1\nfloat nsin(float a)\n{\n    return (sin(a)+1.)/2.;\n}\nfloat ncos(float a)\n{\n    return (cos(a)+1.)/2.;\n}\n\n\n// return 0-1\nfloat plasma_a(vec2 uv, float t, vec2 lbound, vec2 ubound)\n{\n    vec2 p1 = vec2(nsin(t * 1.3), nsin(t * 1.9));\n    vec2 p2 = vec2(nsin(t * 1.2), nsin(t * 2.2));\n    p1 = (p1 * (ubound - lbound)) + lbound;\n    p2 = (p2 * (ubound - lbound)) + lbound;\n\n    return\n        (nsin(length(p1 - uv))\n        + nsin(length(p2 - uv))\n        + nsin(uv.x / 3.)\n        + nsin(uv.y / 2.)\n        ) / 4.\n        ;\n}\n\n// like smootherstep, but returns 0.0 at both edges, and 1.0 in the center (instead of a ramp, it's a hill)\nfloat tri_step(float lbound, float ubound, float val)\n{\n    float halfRange = (ubound - lbound) / 2.0;\n    val -= lbound;// shift down to 0.0 - range\n    val -= halfRange;// shift down to -halfrange - halfrange\n    val = abs(val);// make inverted triangle\n    val = halfRange - val;// invert it so it's the kind of triangle we want (0 at the ends)\n\tval = val / halfRange;// scale triangle to 0-1\n    val = clamp(val, 0.0, 1.0);\n    return val;\n}\n\n\n// convert a 1D value to color, mixing channels\nvec3 a_to_color(float a)\n{\n    return vec3(\n        tri_step(0.,0.75, 1.-a),\n        tri_step(0.12,0.95, 1.-a),\n        tri_step(0.4,1.0, 1.-a)\n    );\n}\n\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize, out float vignetteAmt)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    \n    // vignette. return 0-1\n    vec2 vignetteCenter = vec2(0.5, 0.5);// only makes sense 0-1 values here\n    if(iMouse.z > 0.)\n        vignetteCenter = vec2(iMouse.x / iResolution.x, (iResolution.y - iMouse.y) / iResolution.y);// ret is now 0-1 in both dimensions;\n\tvignetteAmt = 1.0 - distance(ret, vignetteCenter);\n//    vignetteAmt = pow(vignetteAmt, 1.);\n    \n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 lbound = vec2(0., 0.);\n    vec2 ubound = vec2(10., 10.);\n    float vignetteAmt;\n\tvec2 uv = getuv_centerX(fragCoord, vec2(0.), vec2(10.), vignetteAmt);\n\n    // background\n    fragColor = vec4(1.,1.,1.,1.);\n\n    // pixellate effect\n    //const float pixelCount = 18.;\n    float pixelSize = 44./iResolution.x * ubound.x;// pixels wide always.\n        \n    if(iMouse.x > 0.)\n        pixelSize = (iMouse.x+12.)/iResolution.x * ubound.x;// pixels wide always.\n    \n    vec2 plasma_uv = floor((uv / pixelSize) + 0.5) * pixelSize;// pixellated uv coords\n\n    // plasma\n    float a = plasma_a(plasma_uv, iTime, lbound, ubound);\n    fragColor = vec4(a_to_color(a), 1.0);\n    \n    // distance to pixel center\n    const float pi2 = 3.14159 * 2.0;\n    float pixelBorderFX = ncos(uv.x / pixelSize * pi2);\n    pixelBorderFX = min(pixelBorderFX, ncos(uv.y / pixelSize * pi2));\n    pixelBorderFX = pow(pixelBorderFX, 0.1);\n    fragColor.rgb *= pixelBorderFX;\n    \n    // apply vignette\n    fragColor.rgb *= ((vignetteAmt + 0.1) * 2.) - 0.3;\n    fragColor.rgb = clamp(fragColor.rgb, 0.,1.);\n}\n\n\n","name":"","description":"","type":"image"}]}