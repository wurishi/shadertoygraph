{"ver":"0.1","info":{"id":"WtVyWz","date":"1610825876","viewed":91,"name":"Ray Marching 2D Concept","username":"m1ke","description":"A representation of the concept of raymarching in two dimensions.\nClick and drag to move around the view ray.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","visualisation","concept"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//VARS\nvec2 CamPos = vec2(50,50);\nvec2 middle = vec2(512,288) / 2.0f;\n\nstruct Circle\n{\n    vec2 pos;\n    float radius;\n    vec3 col;\n};\n\n//OBJECTS\nint number = 3;\nCircle circles[] = Circle[] \n(\n    Circle(vec2(200,50), 20.0f, vec3(1,0,0)),\n    Circle(vec2(50,150), 23.0f, vec3(0,1,0)),\n    Circle(vec2(200,200), 10.0f, vec3(0,0,1))\n);\nfloat InCircle(vec2 uv, Circle c)\n{\n    float d = length(c.pos-uv);\n    return smoothstep(d, 0.9f*d, c.radius);\n}\nvoid DrawCircle(inout vec3 col, vec2 uv, Circle c)\n{\n    float b = InCircle(uv,c);\n    col = mix(c.col, col, b);\n}\nvoid DrawRing(inout vec3 col, vec2 uv, Circle r, float t)\n{\n    vec3 prevCol = col;\n    DrawCircle(col, uv, Circle(r.pos,r.radius+t,r.col));\n    DrawCircle(col, uv, Circle(r.pos,r.radius,prevCol));\n}\nstruct Line\n{\n    vec2 a;\n    vec2 b;\n    float t;\n};\nfloat dstToLine(vec2 P, Line l)\n{\n    vec2 g = l.b - l.a;\n    vec2 h = P - l.a;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(l.t, 0.5*l.t, d);\n}\nbool InBoundBox(vec2 a, vec2 b, vec2 p)\n{\n    vec2 mi = vec2(min(a.x,b.x), min(a.y,b.y));\n    vec2 ma = vec2(max(a.x, b.x), max(a.y,b.y));\n    return p.x<ma.x && p.y<ma.x && p.x>mi.x && p.y>mi.y;\n}\nvoid DrawLine(inout vec3 col, vec2 uv, Line l)\n{\n    float intensity = dstToLine(uv, l);\n    col = mix(col, vec3(1), intensity);\n}\n\n//SDFs\nfloat SDFcircle(vec2 p, Circle c)\n{\n    return length(p-c.pos) - (c.radius);\n}\nfloat SDFScene(vec2 p)\n{\n    float m = SDFcircle(p, circles[0]);\n    for (int i = 1; i < number; i++)\n    {\n        m = min(m, SDFcircle(p, circles[i]));\n    }\n    \n    return m;\n}\nvec2 RayAngle(float a)\n{\n    a*=2.0f*3.14f;\n    return normalize(vec2(sin(a), cos(a)));\n}\nCircle C1 = Circle(vec2(0,0), 100.0f, vec3(1,0,0));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 middle = iResolution.xy/2.0f;\n    vec2 ray = normalize(iMouse.xy-CamPos);//RayAngle(angle);\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    //OBJECTS\n    for (int i = 0; i < number; i++)\n    {\n        DrawCircle(col, fragCoord, circles[i]);\n    }\n    \n    vec2 samplePoint = CamPos;\n    vec2 hitPoint = CamPos;\n    float totaldst = 0.0f;\n    \n    for (int i = 0; i < 10; i++)\n    {\n        float closest = SDFScene(samplePoint);\n        Circle R = Circle(samplePoint, closest, vec3(1));\n        totaldst+=closest;\n        DrawRing(col, fragCoord, R, 2.0f);\n        if (closest < 2.0)\n        {\n            hitPoint = CamPos+(ray*totaldst);\n            Circle hC = Circle(hitPoint, 2.0f, vec3(1));\n            DrawCircle(col, fragCoord, hC);\n            break;\n        }\n        samplePoint += ray*closest;\n    }\n    \n    \n    //RAY LINE\n    Line viewLine = Line(CamPos, hitPoint, 2.0f);\n    DrawLine(col, fragCoord, viewLine);\n    \n    //HIT CIRCLE\n    Circle hitCircle = Circle(hitPoint, 5.0f, vec3(1));\n    DrawCircle(col, fragCoord, hitCircle);\n    \n    //ORIGIN CIRCLE\n    Circle camCircle = Circle(CamPos, 5.0f, vec3(1));\n    DrawCircle(col, fragCoord, camCircle);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}