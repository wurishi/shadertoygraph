{"ver":"0.1","info":{"id":"XdjcRt","date":"1493343779","viewed":1112,"name":"Reflection","username":"MondayHopscotch","description":"Intended to mimic 2d water reflections.\n\nThanks to @dmmn for his normal-mapifying of the pebble texture: https://www.shadertoy.com/view/MsScRt","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getHeight(vec2 uv) {\n  return texture(iChannel1, uv).r;\n}\n\nvec4 bumpFromDepth(vec2 uv, vec2 resolution, float scale) {\n  vec2 step = 1. / resolution;\n    \n  float height = getHeight(uv);\n    \n  vec2 dxy = height - vec2(\n      getHeight(uv + vec2(step.x, 0.)), \n      getHeight(uv + vec2(0., step.y))\n  );\n    \n  return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\nvec4 getAsBump(vec2 coord) {    \n    // this is the waves moving under the texture\n    float textureOffset = iTime / 9.0;\n    vec2 waveOne = coord.xy + vec2(textureOffset, textureOffset);\n    \n    vec4 sampleOne = vec4(bumpFromDepth(waveOne, iResolution.xy, .1).rgb * .5 + .2, 1.);\n        \n    textureOffset += iTime / 14.0;\n    vec2 waveTwo = coord.xy - vec2(textureOffset, -textureOffset);\n    vec4 sampleTwo = vec4(bumpFromDepth(waveTwo, iResolution.xy, .1).rgb * .5 + .2, 1.);\n    \n    return sampleOne + sampleTwo;\n}\n\nvec3 getDistortedSample(vec2 baseLoc, float distanceFromShore, vec2 offset, bool rough) {\n    float cleanRange = 0.1;\n    \n    //offset -= 0.5;\n    \n    // if it's too close to shore, reduce distortion\n    if (rough || distanceFromShore < cleanRange) {\n        //offset *= distanceFromShore / cleanRange;   \n    }\n    \n    if (offset.x > 1.0) {\n        //offset.x = 1.0;\n    }\n    \n    // this is our distortion from the wave bumps\n    baseLoc.x += (offset.x) * 0.02;\n    baseLoc.y += (offset.y) * 0.02;\n    \n    return texture(iChannel0, baseLoc).xyz + vec3(0,0,0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float edgeOfWater = 0.25f;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (abs(uv.y - edgeOfWater) < 0.003) {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    vec4 resolvedColor;\n    \n    if (uv.y < edgeOfWater) {\n        // in water\n        \n        vec2 bumpNormal =  getAsBump(uv).xy;\n        \n        float angleRate = 1.8;\n        \n        float distFromEdge = edgeOfWater - uv.y;\n        vec2 mirrorCoords = vec2(uv.x, edgeOfWater + distFromEdge * angleRate);\n        resolvedColor = texture(iChannel1, mirrorCoords);\n        \n        vec3 distortedSample = getDistortedSample(mirrorCoords, distFromEdge, bumpNormal, false);\n        \n        resolvedColor.xyz = distortedSample;\n    } else {\n        // above water\n        resolvedColor = texture(iChannel0, uv);\n    }\n    fragColor.xyz = resolvedColor.xyz;\n}","name":"Image","description":"","type":"image"}]}