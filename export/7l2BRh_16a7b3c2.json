{"ver":"0.1","info":{"id":"7l2BRh","date":"1651793841","viewed":272,"name":"MyFirstRayMarcher","username":"TheKraai","description":"wish me luck","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","metaballs","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// yes, I know things like Camera Matrices and Quaternions exist..\n// but this is just how the math lives in my head..\n\nconst float CAM_FOV = 2.0;        // field of view\nconst vec3 CAM_POS = vec3(0);     // coordinates of camera\nconst vec3 CAM_DIR = vec3(0,0,-1); // unit vector pointing in cam direction\nconst vec3 CAM_UP  = vec3(0,1,0); // unit vector pointing up\nconst vec3 CAM_RIGHT = cross(CAM_DIR, CAM_UP);\n\nfloat sceneSDF( vec3 pos ) {\n   float sdf = 1e10;\n\n   //sdf = min(sdf, sphereSDF(pos, vec3(0,0,-10), 4.));\n   //sdf = min(sdf, sphereSDF(pos, vec3(3,0,-5), 1.));\n   \n   const int balls = 12;\n   for (int i=0; i<balls; i++) {\n       float seed = mod(float(i)/float(balls) + 0.003 * iTime, 6.28318);\n       vec2 seedvec = 0.8 * vec2(cos(seed), sin(seed));\n       vec3 r = texture(iChannel0, seedvec).xyz;\n       r.x = mix(-8.,8.,r.x);\n       r.y = mix(-8.,8.,r.y);\n       r.z = -mix(5.,20.,r.z);\n       sdf = smin(sdf, sphereSDF(pos, r, 1.5), 2.);\n   }\n\n   return sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    // CALCULATE DIRECTION OF RAY\n\n    vec2 angle_offset = CAM_FOV * (fragCoord - iResolution.xy / 2.) / iResolution.xx; \n    vec3 ray  = CAM_DIR;\n         ray += angle_offset.x * CAM_RIGHT;\n         ray += angle_offset.y * CAM_UP;\n    ray = normalize(ray);\n    \n    \n    vec3 pos = CAM_POS;\n    vec3 normal;\n    fragColor = vec4(0,0,0,1);\n    \n    float part = 1.;\n\n\n    for (int i=0; i<40; i++) {\n\n        // MARCH FORWARD\n        float dist = sceneSDF(pos);\n        pos += ray * dist;\n\n        if (dist < 0.01) {\n            // GET NORMAL\n\n            vec2 eps = vec2(0.01,0);\n\n            normal.x = sceneSDF( pos + eps.xyy ) - sceneSDF( pos - eps.xyy );\n            normal.y = sceneSDF( pos + eps.yxy ) - sceneSDF( pos - eps.yxy );\n            normal.z = sceneSDF( pos + eps.yyx ) - sceneSDF( pos - eps.yyx );\n            normal = normalize(normal);\n\n            // REFLECT\n\n            fragColor.rgb += part * (normal + 1.) / 2.;\n\n            ray = reflect(ray, normal);\n            pos += 0.02 * ray;\n            \n            part *= 0.3;\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float sphereSDF( vec3 pos, vec3 center, float radius )\n{\n    return length(center - pos) - radius;\n}\n\n// this function is from https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n","name":"Common","description":"","type":"common"}]}