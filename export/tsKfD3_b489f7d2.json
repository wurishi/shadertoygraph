{"ver":"0.1","info":{"id":"tsKfD3","date":"1608159249","viewed":137,"name":"Understanding FBM","username":"Dudeguy18","description":"Understanding Fractal Brownian Motion\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This was made to help me understand the basics \n// of generating random numbers, Perlin Noise, \n// Fractal Brownian Motion, and Domain Warping.\n\nfloat scale = 20.0;\n\n\n// Calculates Random Number\nfloat hash(vec2 p){\n    p = fract(p * vec2(125.76, 473.82));\n    p += dot(p, p + 86.12);\n    return fract(p.x * p.y);\n}\n\n// Perlin Noise\nfloat noise (vec2 st) {\n    vec2 i = floor(st); // Index\n    vec2 f = fract(st); // Fraction\n\n    // Four corners in 2D of a tile\n    float a = hash(i + vec2(0.0, 0.0));\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Calculate value to interpolate between corners\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // Interpolate\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\n// Fractal Brownian Motion\nfloat fbm(vec2 x, float amplitude, float frequency, float lacunarity, float gain, int iterations){\n\n    float y = 0.0;\n    \n    mat2 rot = mat2(cos(0.87), sin(0.87), -sin(0.87), cos(0.87));\n    for(int i=0; i < iterations; i++){\n\n        y += amplitude * noise(x * frequency); // Calculate Noise Layer\n        x *= rot;                              // rotate next iteration\n        frequency *= lacunarity;               // adjust lacunarity for next iteration\n        amplitude *= gain;                     // adjust gain for next iteration\n    }\n    \n\n    return y;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Create Color Variable\n    vec3 col = vec3(0.0);\n    \n    // Get uv in screen coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y; // -1.0 to 1.0\n    //uv = fragCoord.xy/iResolution.xy;\n    \n    float t = iTime * 0.1;\n    \n  \n    float lacunarity = 1.4;\n    float gain = 0.588;\n   \n    // First Box\n    if(uv.x < -0.5 && uv.y >= 0.0){\n        \n        // Random Noise\n        uv.x -= t; // Move to the left\n        vec2 i = floor(uv.xy * scale);\n        vec2 f = fract(uv.xy * scale);\n        \n        col.r = hash(i);\n        \n    // Second Box\n    }else if(uv.x >= -0.5 && uv.x <= 0.0 && uv.y >= 0.0){\n    \n        // Random Noise Smoothed over X values\n        uv.x -= t; // Move to the left\n        vec2 i = floor(uv.xy * scale);\n        vec2 f = fract(uv.xy * scale);\n        \n        float a = hash(i + vec2(0.0, 0.0)); // Bottom left point\n        float b = hash(i + vec2(1.0, 0.0)); // Bottom right point\n        \n        vec2 u = f * f * (3.0 - 2.0 * f); // Cubic Interpolation\n        \n        col.r = mix(a, b, u.x); // Interpolate\n        \n    // Third Box\n    }else if(uv.x >= 0.0 && uv.x < 0.5 && uv.y >= 0.0){\n    \n        // Fractal Brownian Motion with 1 iteration\n        uv.x -= t; // Move to the left\n        col.r = fbm(uv.xy, 1.0, scale, lacunarity, gain, 1);\n        \n        \n    // Fourth Box\n    }else if(uv.x >= 0.5 && uv.y >= 0.0){\n    \n        // Fractal Brownian Motion\n        uv.x -= t; // Move to the left\n        col.r = fbm(uv.xy, 0.5, scale, lacunarity, gain, int(sin(iTime + 1.0) * 8.0 + 8.0 + 1.0));\n        \n        \n    // Fifth Box\n    }else{\n\n        //Domain Warping - https://thebookofshaders.com/13/\n        vec2 q = vec2(0.);\n        vec2 r = vec2(0.);\n        \n        scale *= 0.1;\n        gain = 0.2;\n        \n        \n        q.x = fbm(uv.xy + vec2(0.0,t), 1.0, scale, lacunarity, gain, 8);\n        q.y = fbm(uv.xy + vec2(-t,1.3), 1.0, scale, lacunarity, gain, 8);\n        \n        \n        r.x = fbm(uv.xy + 4.0*q + vec2(t,9.2), 1.0, scale, lacunarity, gain, 8);\n        r.y = fbm(uv.xy + 4.0*q + vec2(8.3,-t), 1.0, scale, lacunarity, gain, 8);\n        \n        col.r = fbm(uv.xy + 4.0*r, 1.0, scale, lacunarity, gain, 8);\n        col.g = col.r;\n        col.b = col.r;\n\n    }\n    \n \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}