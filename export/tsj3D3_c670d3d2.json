{"ver":"0.1","info":{"id":"tsj3D3","date":"1550181569","viewed":825,"name":"Sphere grid movement","username":"noby","description":"Regular infinite grid of spheres, with a random path moving inbetween them","likes":49,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","sphere","spheres","random","infinite","path","spheretraching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(uint n){\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash(vec3 p3){\n    p3 = fract(p3*.1031);\n\tp3 += dot(p3,p3.yzx+19.19);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nvec3 cellid;\nvoid repeat(inout vec3 p, vec3 dim){\n    cellid = floor((p )/(dim));\n    p = mod(p, dim)-dim*0.5;\n}\n\nconst float spacing = 3.0;\nvec3 targetpos;\nvec3 targetactual;\n\nfloat target(vec3 p){\n    return sphere(p-targetactual, 1.0);\n}\n\nfloat map(vec3 p){\n    float t = target(p);\n    repeat(p, vec3(spacing));\n    return min(t, sphere(p, 0.5));\n}\n\nvec3 normal(vec3 p){\n    float c = map(p);\n    const float e = 0.001;\n    return normalize(vec3(c-map(p-vec3(e,0,0)), c-map(p-vec3(0,e,0)), c-map(p-vec3(0,0,e))));\n}\n\nfloat intersect(vec3 cam, vec3 ray){\n    float d = 0.0;\n    const int steps = 99;\n    for(int i = 0; i < steps; ++i){\n        float t = map(cam+ray*d);\n        d += t;\n        if(t < 0.002 || d > 50.0)\n        \tbreak;\n    }\n    \n    return min(d, 50.0);\n}\n\nvec3 shade(vec3 cam, vec3 ray, vec3 pos, vec3 n, vec3 rv, float anim){\n    const vec3 rc = vec3(0.9,0.1,0.05);\n    if(target(pos) < 0.01)\n        return rc;\n    \n    vec3 emit = vec3(0);\n    if(hash(cellid) > 0.75)\n        emit = vec3(0.9)*(1.0-smoothstep(5.5, 6.0, distance(floor(targetactual), floor(pos))));\n    \n    vec3 light = targetactual;\n    vec3 lv = normalize(light-pos);\n#if 1\n    float lambert = 0.1*max(0.0, dot(n, lv));\n    float spec = 0.5*pow(max(0.0, dot(lv, rv)), 100.0);\n    \n    float ld = distance(pos, light);\n    float falloff = pow(1.0-smoothstep(1.0, 14.0, ld), 6.0);\n    vec3 surface = mix(vec3(1), rc, 0.25)*vec3(lambert+spec)*(falloff);\n    if(hash(-cellid) > 0.5)\n        surface *= 0.0;\n# else\n\tvec3 surface = vec3(0);\n#endif\n    float spacing = 2.0+6.0*hash(cellid+9999.);\n    emit += step(0.5, mod(pos.y*spacing+iTime*(-1.0+2.0*hash(cellid+999.)), 1.0))*falloff * step(0.8, hash(-cellid));\n    surface += emit;\n    \n    \n    \n    return surface;\n}\n\nvec3 getpoint(uint index){\n    float a = floor(0.5+4.5*hash(index));\n    float b = floor(0.5+4.5*hash(index+1U));\n    float c = floor(0.5+4.5*hash(index+2U));\n    \n    vec3 p = vec3(a,b,c);\n    switch( int(mod(float(index), 3.0)) ){\n        case 0:\n        \treturn p.xyz;\n        case 1:\n        \treturn p.zxy;\n        case 2:\n        \treturn p.yzx;\n    }\n}\n\nvec3 path(float time){\n    uint index = uint(time);\n    return spacing*mix(getpoint(index), getpoint(index+1U), smoothstep(0.0, 1.0, mod(time, 1.0)));\n}\n\nmat3 lookat(vec3 cam, vec3 target){\n\tvec3 ww = normalize(target - cam);\n\tvec3 uu = normalize(cross(ww, normalize(vec3(1e-4,1.0-1e-4,1e-4))));\n\tvec3 vv = normalize(cross(uu, ww));\n\treturn mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 cum = vec3(0);\n    const int samples = 3;\n    for(int y = 0; y < samples; ++y)\n        for(int x = 0; x < samples; ++x){\n            vec2 p = -1.0 + 2.0 * (uv + (-1.0+2.0*(vec2(x, y)/float(samples)))/iResolution.xy);\n            p.y *= iResolution.y/iResolution.x;\n            \n            float anim = 10.0+iTime-texelFetch(iChannel0, ivec2(mod(fragCoord*float(samples)+vec2(x,y),1024.)),0).r/48.0;\n\n            // cam setup\n            vec3 cam = vec3(0,0,0) + path(anim);\n            targetpos = path(anim+2.25);\n            targetactual = path(anim+2.35);\n            float fov = mix(0.5, 5.0, smoothstep(5.0, 20.0, distance(cam, targetpos)));\n            vec3 ray = normalize(vec3(p, fov));\n            ray = lookat(cam, targetpos) * ray;\n\n            // primary ray and shading\n            float dist = intersect(cam, ray);\n            \n            if(dist < 50.0){\n                vec3 pos = cam+ray*dist;\n                vec3 n = normal(pos);\n                vec3 rv = reflect(ray, n);\n                vec3 col = shade(cam, ray, pos, n, rv, iTime);\n\t\t\t\t\n                // reflection ray\n                float rd = intersect(pos+n*0.01, rv);\n                vec3 rpos = pos+rv*rd;\n                vec3 rn = normal(rpos);\n                vec3 rrv = reflect(rv, rn);\n\n                // reflection shading\n                vec3 rcol = shade(pos, rv, rpos, rn, rrv, iTime);\n                float fresnel = pow(1.0-max(0.0, dot(n, -ray)), 5.0);\n                col = mix(col, rcol, fresnel);\n                //col += fresnel/pow(distance(cam, pos), 2.0);\n\t\t\t\t\n                cum += col;\n            }\n    }\n    \n    cum /= float(samples*samples);\n    \n    cum *= 1.0+0.1*(-1.0+2.0*hash(vec3(fragCoord, iTime)));\n    \n    cum = mix(cum, mix(vec3(0.82,0.99,0.82)*0.02, vec3(0.99,0.92,0.85), cum), 0.1);\n    cum = pow(cum, vec3(1.0/2.2));\n    cum = smoothstep(-0.2, 1.05, cum);\n    fragColor.rgb = cum;\n    \n}","name":"Image","description":"","type":"image"}]}