{"ver":"0.1","info":{"id":"csdGWr","date":"1677149012","viewed":93,"name":"Pudding Car 2021","username":"tono","description":"Euro Beat","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["puddingcar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = acos(-1.);\nmat2 rot(float a ){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n#define PUDDING 0.\n#define SARA    1.\n#define WHEEL   2.\n#define TIRE    3.\n#define ROAD    4.\n\nvec2 pmod(vec2 p, float r) {\n    float a =  atan(p.x, p.y) + pi/r;\n    float n = (pi * 2.) / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n//https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//-----------------------------------\n\nfloat bo( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat road( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  //return length(max(q,0.0)) + min(max(q.y,q.z),0.0);\n  return max(q.z , q.y);  \n}\n\nvec2 min2(vec2 a, vec2 b)\n{\n    if(a.x > b.x) a = b;\n    return a;\n}\n\nvec2 pudding(vec3 p)\n{\n    float plate = length(p / vec3(1.,.3,1.)) - 1.3;\n    plate = max(-plate , length((p +vec3(0.,-0.2,0.) )/ vec3(1.,.3,1.)) - 1.1);\n    float o = plate * .2;\n    \n    float tt = floor(iTime) + pow(fract(iTime) ,1.2);\n    p.x += sin(tt * pi + p.y*1.4)/10.;\n    p.xz = pmod(p.xz,12.);\n    p.z = p.z - 0.2;\n    float s = 1.;\n    float w = 1.3;\n    float pud = length(p / vec3(w * p.y + s,1.8,w * p.y +s) ) - .3;\n    pud = max(pud , p.y - .4);\n    pud = max(pud , -p.y- .24);\n    \n    float id = SARA;\n    if(o > pud)\n    {\n        o = pud;\n        id = PUDDING;\n    }\n    \n    return vec2(o,id);\n}\n\nvec2 mPolar(vec2 p){\n  float a = atan(p.y,p.x);\n  float r = 0.;\n  r = length(p);\n  return vec2(a/pi, r);\n}\n\nvec2 wheel(vec3 p,float px)\n{\n    \n    //p /= .8;\n    vec2 o = vec2(10.);\n    //p.xy *= rot(time);\n    float dir = -sign(step(0.,px) - .5);\n    p.xy *= rot(iTime * dir * 10.);\n    vec3 p2 = p;\n    p.xy = pmod(p.xy,8.);\n    float scale = 5.;\n    p.y -= .7/scale;\n    o.x = sdBoxFrame(p , vec3(.2,.3,.3)/scale , .05/scale);\n    o.y = WHEEL;\n    p2.yz *= rot(pi / 2.);\n    float tire = sdTorus(p2 ,vec2(.7 , .25) / (scale / 1.4));\n    if(tire < 1.)\n    {\n        vec2 mpol = mPolar(p2.xz);\n        tire -= sin(mpol.y * mpol.x * 90. * pi)/300.;\n    }\n    o = min2(o , vec2(tire,TIRE));\n    return o;\n}\n\nvec2 puddingCar(vec3 p)\n{\n    vec2 o = vec2(10.);\n    \n    o = pudding(p);\n    p.y -= 0.55;\n    p.z = abs(p.z) - .8;\n    float ppx = p.x;\n    p.x = abs(p.x) - .7;\n    o = min2(o,wheel(p,ppx));\n    return o;\n}\n\nvec2 rainbowroad(vec3 p)\n{\n    vec2 o = vec2(10.);\n    p.y -= .9;\n    p.z += sin(-iTime * .2 + p.x/100.) * 1.;\n    o.x = road(p , vec3(1.,0.1,4.));\n    o.y = ROAD;\n    return o;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 o = vec2(10.);\n    vec3 pud = p;\n    pud.z += sin(sin(iTime) * pi/2.);\n    pud.x += sin(sin(sin(iTime/3.) * 3.) * 2.6);\n    //pud.y += sin(-time);\n    o = puddingCar(pud);\n    //p.y += sin(-time + p.x/10.);\n    o = min2(o,rainbowroad(p));\n    \n    o.x *= 1.1;\n    return o;\n}\n\nvec2 march(vec3 cp, vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 200; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 40.)break;\n        depth += d.x;\n    }\n    return vec2(-depth,0.);\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    return ((clamp(abs(fract(hsv.x+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*hsv.y+1.)*hsv.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat resol = 90. ;\n    p = floor(p * resol)/resol;\n    vec3 cp = vec3(6.,-2.,-4.);\n  //  cp.yz *= rot(-pi * 1.1 );\n    float t = floor(iTime / mix(8.,40.,abs(sin(floor(iTime/3.5))) ));\n    cp.xz *= rot(t * 3.14);\n    cp.z = mix(-9. ,-2.,(sin(t + iTime) + 1.)/2. );\n    cp.y = mix(-2. ,-0.,abs(cos(t) + 1.)/2. );\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 3.5;\n    vec3 rd = normalize(fov * cd + cs * p.x + cu * p.y);\n    vec3 col = vec3(0.,0.,0.);\n    //プリン　極座標\n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.01);\n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        sun.xz *= rot(iTime);\n        \n        //float shadow = step(march(pos + N * 0.1 ,-sun).x,0.);\n        float rim = (1. - abs(dot(rd,N)) );\n        if(d.y == SARA)\n        {\n            //sara\n            float diff = mix(max(0.,dot(sun,N)),1.,.1 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,30.);\n        \tfloat cstep = 5.;\n            col =  floor( diff * vec3(.7) * cstep) /cstep;\n            col += floor( sp * 2.5 * vec3(1.) * cstep)/cstep;\n            col += floor( rim * vec3(1.) * cstep) / cstep;\n        }\n        else if(d.y == PUDDING)\n        {\n            //pud\n            float diff = mix(max(0.,dot(sun,N)),1.,.7 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,13.);\n        \tcol =  diff * mix( vec3(1.,.5,.4),vec3(0.), step(pos.y,-.2) );\n            float cstep = 6.;\n            col =  floor(col * cstep) / cstep;\n            col += floor( sp * vec3(1.) * cstep ) / cstep;\n            col += floor( vec3(1.) * clamp(map(pos+1.2*rd).x*1.1,.0,1.) * diff * cstep) / cstep;\n            col += floor( rim * vec3(.5,.4,.1) * cstep ) /cstep;\n        }else if(d.y == WHEEL)\n        {\n            float diff = mix(max(0.,dot(sun,N)),1.,.4 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,30.) * 3.5;\n            rim = pow(rim , 30.);\n        }else if(d.y == TIRE)\n        {\n            float diff = mix(max(0.,dot(sun,N)),1.,.4 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,1.) ;\n            rim = pow(rim , 30.);\n            col = diff * vec3(0.2) + sp * vec3(.2);// + rim * vec3(.3);\n        }else if(d.y == ROAD)\n        {\n            float diff = mix(max(0.,dot(sun,N)),1.,.5 ) * 3.;\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,10.) ;\n            rim = pow(rim , 30.);\n            vec3 mat = hsv2rgb(vec3(pos.x/10. - iTime * 5.,1.,1.));\n            col = diff * mat + sp * mat;// + rim * vec3(.3);\n        }\n        \n        \n        col += (clamp(map(pos-2.4*rd).x*.8,.0,1.)-.5) * vec3(.5,.4,.1);\n        float dd = 1.-exp(-0.00003 * d.x * d.x * d.x);\n    \tcol = mix(col,vec3(0.), dd);\n    }else{\n        //p = sin(p * 10. + t );\n        //col += pow(1. - dot(p,p) * (sin(p.x * p.y) + 1.),10. );\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}