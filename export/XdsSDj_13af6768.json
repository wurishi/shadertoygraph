{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"////////////////////////////////////////\n// XBE\n// Linescape Remix \n// Terrain Rendering with slices\n\n//////////////////////////////////////\n// Noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404;\n\tconst float K2 = 0.211324865;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//////////////////////////////////////\n// Musgrave's noise function\n\nfloat multifractal(vec2 point)\n{\n\tfloat value = 1.0;\n\tfloat rmd = 0.0;\n\tfloat pwHL = pow(2., -0.5);\n\tfloat pwr = pwHL;\n\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tvalue *= pwr*noise(2.*point) + 0.65;\n\t\tpoint *= 2.;\n\t\tpwr *= pwHL;\n\t}\n\n\treturn value;\n}\n\nfloat hybridMultiFractal(in vec2 point)\n{\n\tfloat value = 1.0;\n\tfloat signal = 0.0;\n\tfloat pwHL = pow(3., -0.25);\n\tfloat pwr = pwHL;\n\tfloat weight = 0.;\n\n\t/* get first octave of function */\n\tvalue = pwr*(noise(2.*point)+0.05);\n\tweight = value;\n\tpoint *= 3.;\n\tpwr *= pwHL;\n\n\t/* spectral construction inner loop, where the fractal is built */\n\tfor (int i=1; i<4; i++)\n\t{\n\t\tweight = weight>1. ? 1. : weight;\n\t\tsignal = pwr * (noise(2.*point) + 0.05);\n\t\tvalue += weight*signal;\n\t\tweight *= signal;\n\t\tpwr *= pwHL;\n\t\tpoint *= 3.;\n\t}\n\n\treturn value;\n}\n\nfloat heteroTerrain(vec2 point)\n{\n\tfloat value = 1.;\n\tfloat increment = 0.;\n\tfloat pwHL = pow(2., -0.5);\n\tfloat pwr = pwHL;\n\n\tvalue = pwr*(0.05 + noise(2.*point));\n\tpoint *= 2.;\n\tpwr *= pwHL;\n\n\tfor (int i=1; i<4; i++)\n\t{\n\t\tincrement = (noise(2.*point) + 0.05) * pwr * value;\n\t\tvalue += increment;\n\t\tpoint *= 2.;\n\t\tpwr *= pwHL;\n\t}\n\n\treturn value;  \n}\n\nfloat heightfield(in vec2 p)\n{\n//    return fbm4(0.125*p);\n//    return multifractal(0.0625*p);\n    return hybridMultiFractal(0.125*p);\n//    return heteroTerrain(0.0625*p);\n}\n\n//////////////////////////////////////\n/// Ray-Primitive intersections\n\nstruct Inter {\n\tvec3 p;\t\t//pos\n\tvec3 n; \t//normal\n\tvec3 vd;\t// viewdir\n\tfloat d;\t//distance\n    float dn;  // noise\n};\n\nvoid intPlane(vec3 ro, vec3 rd, vec3 p, vec3 n, inout Inter i)\n{\n\tfloat d = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t{\n\t\td = (dot(n, p) + dot(n,ro)) / dpn;\n\t\tif (d>0.)\n\t\t{\n            vec3 ip = ro+d*rd;\n//            float no = heightfield(0.25*vec2(ip.x, ip.z + 0.25*iTime));\n            float no = heightfield(ip.xz);\n            float dn = ip.y + no;\n            if ((dn<0.01)&&(i.d<0.))\n            {\n                i.p = ip;\n                i.n = n;\n                i.d = d;\n                i.dn = abs(dn);\n                i.vd = -rd;\n            }\n\t\t}\n\t}\n}\n\n////////////////////////////////////\n// Raytracing\n\nvec3 raytrace( vec3 ro, vec3 rd, vec3 sky, vec3 ld)\n{\n\tInter i;\n\ti.p = vec3(0.,0.,0.);\n\ti.n = vec3(0.,0.,0.);\n\ti.d = -1.;\n    i.dn = -1.;\n\ti.vd = vec3(0.,0.,0.);\n\t//\n\tvec3 col = vec3(0.1,0.1,0.1);\n\tvec3 p = vec3(0.,0.,1.25);\n    p.z -= ro.z;\n\tvec3 n = vec3(0.,0.,-1.);\n    float inc = 0.125;\n    for (int k=0; k<36; k++)\n    {\n\t\tintPlane( ro, rd, p, n, i);\n        if (i.d>0.) break;\n        p.z += inc; inc += 0.01; \n    }\n\t//\n\t//\n\tif (i.d>0.)\n\t{\n        col = vec3(0.45, 0.25, 0.05)*exp(-2.*abs(i.dn-i.p.y)) + vec3( i.dn<0.1?smoothstep(1.,0.,i.dn*128.):0. );\n//        col *= exp(-0.01*i.d*i.d);\n//\t\tcol *= exp(-0.001*i.d);\n\t\t// lighting\n        float n1 = heightfield(vec2(i.p.x-0.001, i.p.z));\n        float n2 = heightfield(vec2(i.p.x+0.001, i.p.z));\n        vec3 n = normalize(vec3( -(n2-n1), 0.002, 0.0 ));\n\t\tcol *= 0.1 + dot(n, ld);\n        // Background\n        col = mix( col, sky, 1.0-exp(-0.00125*i.d*i.d*i.d) );\n\t}\n    else\n        col = sky;\n\treturn clamp(col,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\t// camera\t\n\tvec3 ro = vec3( 0., 1.25, -1. );\n\tvec3 ta = vec3( 0.0, 0.9, 0.0 );\n\tro.y += 0.25*sin(0.25*iTime);\n\tta.x += 0.25*cos(0.2*iTime);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    ro.z += iTime;\n    \n\tvec3 lig = normalize(vec3(-2., 2., 1.));\n//    lig.x = sin(0.33*iTime);\n//    vec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    vec3 sky = vec3(0.86,0.86,0.88) - rd.y*0.6;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n    sky += 0.5*vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n    sky *= 0.9;\n    // Render planes\n//    vec3 bkg = vec3(0.86,0.86,0.88) + p.y*0.1;\n    vec3 col = raytrace( ro, rd, sky, lig );\n    \n\t// Vignetting\n\tvec2 r = -1.0 + 2.0*(q);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.05 + 0.95*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdsSDj","date":"1407084128","viewed":639,"name":"Linescape Remix","username":"xbe","description":"Linescape remix in 3D slicing terrain along z axis... Use raytracing to intersect vertical planes rejecting points over noise value. Maybe quite inefficient way of achieving this, but was fun doing it... It is missing some other objects to look better. \n","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","terrain","slices"],"hasliked":0,"parentid":"","parentname":""}}