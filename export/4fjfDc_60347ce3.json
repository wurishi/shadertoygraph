{"ver":"0.1","info":{"id":"4fjfDc","date":"1725651078","viewed":12,"name":"Shaded Round Box","username":"Thor","description":"help","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["epicshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized y pixel coordinates (from 0 to 1)    \n    // apply same scale to x pixels\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 Mouseuv = iMouse.xy/iResolution.yy;\n    \n    //subtracting 0.5 moves origin to middle of window\n    //however x is at a different scale, so we need to scale\n    //based on aspect ratio\n    uv.x = uv.x - 0.5*(iResolution.x/iResolution.y);\n    uv.y = uv.y - 0.5;\n    \n    Mouseuv.x = Mouseuv.x - 0.5*(iResolution.x/iResolution.y);\n    Mouseuv.y = Mouseuv.y - 0.5;\n\n    //set background color\n    vec3 col = vec3(0.0);\n    \n    //distance along ray\n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    \n    //small distance to offset point\n    float d = 0.0001f;\n    \n    //position and size of the sdf sphere\n    vec3 boxPos = vec3(0.0,0.0,10.0);\n    vec3 boxDim = vec3(0.25,0.25,0.25);\n    float boxRad = 0.125f;\n    \n    vec3 lightPos = vec3(Mouseuv, 0.0);\n    \n    \n    //starting point of ray and the direction it follows\n    vec3 pt = vec3(uv.x, uv.y, 0.0);\n    vec3 ptdx = vec3(uv.x+d, uv.y, 0.0);\n    vec3 ptdy = vec3(uv.x, uv.y+d, 0.0);\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n     \n    //loop that allows us to keep moving along the ray \n    //until we hit the sphere or until we run out of \n    //loop iterations (and hit nothing)\n    for( int i = 0; i < 25; i++){\n    \n        //calc positions from view rays\n        vec3 pos = pt + dir * t;\n        vec3 posdx = ptdx + dir * tdx;\n        vec3 posdy = ptdy + dir * tdy;\n            \n        \n        //get distance from position to sphere\n        //subtract spherePos from pos allows us to \"move\"\n        // the position of the sphere in the world\n        //otherwise it is stuck at the world origin\n        float dist = sdRoundBox(pos - boxPos, boxDim, boxRad);\n        float distdx = sdRoundBox(posdx - boxPos, boxDim, boxRad);\n        float distdy = sdRoundBox(posdy - boxPos, boxDim, boxRad);\n              \n        if(dist < 0.000001 &&\n            distdx < 0.000001 &&\n            distdy < 0.000001){ //point on ray is close enough\n                        //we'll call this a \"hit\"\n                        \n            vec3 normal = normalize(cross(\n                normalize(posdx - pos),\n                normalize(pos - posdy)));\n                        \n            col = vec3(1.0)*dot(normal, normalize(lightPos - pos));  //lets color this fragment\n            //col = normal;\n                              // a \"sphere color\"\n            break;  //stop checking\n            \n        }\n        //update distance along ray if haven't hit yet\n        t += dist;\n        tdx += distdx;\n        tdy += distdy;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}