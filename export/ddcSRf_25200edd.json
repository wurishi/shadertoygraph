{"ver":"0.1","info":{"id":"ddcSRf","date":"1680166413","viewed":1368,"name":"GPT4 shader (sphere + box)","username":"sebbbi","description":"* write me a shadertoy shader with a SDF sphere and box next to each other\n* the distBox line is incorrect in the above shader. Please fix it\n* could you make the box smaller and have sharp corners instead of round?\n* please fix the aspect ratio","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","sphere","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy glsl shader with SDF sphere and box\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    vec3 cameraPos = vec3(0.0, 0.0, -3.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraPos);\n    vec3 cameraRight = normalize(cross(cameraUp, cameraDir));\n    vec3 cameraPlaneUp = cross(cameraDir, cameraRight);\n    vec3 rayDir = normalize(cameraDir + uv.x * cameraRight + uv.y * cameraPlaneUp);\n    \n    vec3 rayOrigin = cameraPos;\n    vec3 currentPosition = rayOrigin;\n    float totalDistance = 0.0;\n    const int maxIterations = 128;\n    const float maxDistance = 100.0;\n    const float epsilon = 1e-4;\n\n    for (int i = 0; i < maxIterations; i++)\n    {\n        float distSphere = length(currentPosition - vec3(-1.0, 0.0, 0.0)) - 1.0;\n        float distBox = length(max(abs(currentPosition - vec3(1.0, 0.0, 0.0)) - vec3(0.5, 0.5, 0.5), 0.0));\n        float distance = min(distSphere, distBox);\n        totalDistance += distance;\n        currentPosition = rayOrigin + totalDistance * rayDir;\n\n        if (distance < epsilon || totalDistance > maxDistance)\n        {\n            break;\n        }\n    }\n\n    vec3 baseColor;\n    if (totalDistance < maxDistance)\n    {\n        vec3 normal;\n        float distSphere = length(currentPosition - vec3(-1.0, 0.0, 0.0)) - 1.0;\n        float distBox = length(max(abs(currentPosition - vec3(1.0, 0.0, 0.0)) - vec3(0.5, 0.5, 0.5), 0.0));\n        if (distSphere < distBox)\n        {\n            baseColor = vec3(0.5, 0.1, 0.9);\n            normal = normalize(currentPosition - vec3(-1.0, 0.0, 0.0));\n        }\n        else\n        {\n            baseColor = vec3(0.1, 0.8, 0.2);\n            vec3 boxGradient = vec3(\n                (currentPosition.x - 1.0) / 1.0,\n                (currentPosition.y - 0.0) / 1.0,\n                (currentPosition.z - 0.0) / 1.0\n            );\n            normal = normalize(boxGradient);\n        }\n\n        vec3 lightPos = vec3(0.0, 5.0, -5.0);\n        vec3 lightDir = normalize(lightPos - currentPosition);\n        float lightIntensity = max(dot(normal, lightDir), 0.0);\n        vec3 ambient = vec3(0.1, 0.1, 0.1);\n        vec3 diffuse = baseColor * lightIntensity;\n        vec3 color = ambient + diffuse;\n\n        // Specular reflection\n        vec3 viewDir = normalize(rayOrigin - currentPosition);\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n        vec3 specular = vec3(1.0, 1.0, 1.0) * spec;\n\n        color += specular;\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        // Background color\n        vec3 backgroundColor = vec3(0.2, 0.2, 0.2);\n        fragColor = vec4(backgroundColor, 1.0);\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}