{"ver":"0.1","info":{"id":"4ldfDN","date":"1539700272","viewed":101,"name":"Voronoi-diagram-ask58-3d","username":"acalc79","description":"renders a Voronoi diagram on a surface in 3d space based on a constant array of co-ordinates and colors","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","voronoi","ask58","compscitripos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI  = 3.14159265358979323846264;\nconst float TAU = 2.0 * PI;\n\n// for 3d\nconst Camera CAMERA =\n    Camera(vec3(0,0.5,6),\n           TAU / 6.0);\nconst vec3 TOTAL = vec3(1,1,1); // total reflection\nconst Material DEFAULT_MATERIAL = Material(TOTAL, TOTAL, 0.5 * TOTAL, 10.0); // id 0\nconst Sphere SPHERE = \n    Sphere(vec3(0,0,0),\n           1.0,\n           1);\nconst Plane PLANE =\n    Plane(vec3(0,-1,0),\n          vec3(1,0,0),\n          normalize(vec3(-0.15,1,0.25)),\n          0);\nconst vec3 SKY_COLOR = vec3(0.2,0.8,1.0);\n// lighting\nconst vec3 AMBIENT_LIGHT = TOTAL * 0.1;\nconst int LIGHT_NUM = 3;\nconst Light[LIGHT_NUM] INITIAL_LIGHTS =\n    Light[](\n        Light(vec3(0,10,0),vec3(1,1,1),30.0), // white from the top\n        Light(vec3(8,2,5),vec3(1,0,0),40.0), // red from the right\n        Light(vec3(-2,-1,2),vec3(0,0,1),2.0) // blue from the bottom left\n        );\n\n// points and their movement\nconst float DISTANCE = 0.2;\nconst int NUM_POINTS = 20;\n// expressed in spherical coordinates\nconst vec2[NUM_POINTS] INITIAL_POINTS = \n    vec2[](\n        vec2(0.1, 0.001) * TAU, \n        vec2(0.1, 0.1) * TAU,\n        vec2(0.1, 0.2) * TAU,\n        vec2(0.1, 0.3) * TAU,\n        vec2(0.1, 0.4) * TAU,\n        vec2(0.1, 0.5) * TAU,\n        vec2(0.1, 0.6) * TAU,\n        vec2(0.1, 0.7) * TAU,\n        vec2(0.1, 0.8) * TAU,\n        vec2(0.1, 0.9) * TAU,\n        vec2(-0.1, 0.001) * TAU, \n        vec2(-0.1, 0.1) * TAU,\n        vec2(-0.1, 0.2) * TAU,\n        vec2(-0.1, 0.3) * TAU,\n        vec2(-0.1, 0.4) * TAU,\n        vec2(-0.1, 0.5) * TAU,\n        vec2(-0.1, 0.6) * TAU,\n        vec2(-0.1, 0.7) * TAU,\n        vec2(-0.1, 0.8) * TAU,\n        vec2(-0.1, 0.9) * TAU\n        );\nconst float POINT_RADIUS = 0.015;\nconst float EPOCH_LENGTH = 1.5;\n\n// polar to 3d and back on unit sphere\nvec2 toPolar(in vec3 v)\n{\n    return vec2(asin(v.y), atan(-v.z, v.x));\n}\nvec3 fromPolar(in vec2 thetaPhi)\n{\n    float theta = thetaPhi[0];\n    float phi = thetaPhi[1];\n    float r = cos(theta);\n    return vec3(r * cos(phi), sin(theta), -r * sin(phi));\n}\n\n// random\n// from: https://stackoverflow.com/a/4275343\n// ideally: add a floating point 'seed' parameter\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// movement\nvec2 epochDirection(vec2 p0, int n, float seed)\n{\n    float fn = float(n);\n    float nseed = (fn + seed) * seed + fn * fn * fn;\n    float phiDir = 2.0 * rand(vec2(5151.51, 151.15) * nseed) - 1.0;\n    float thetaTarget = (0.5 * rand(vec2(1325.62, 9725.56) * nseed) - 0.25) * TAU;\n    float thetaDir = (thetaTarget - p0[0]) / (0.5 * TAU);\n    vec2 res = normalize(vec2(thetaDir, phiDir));\n    return res;\n}\nvec2 epochDisplacement(vec2 p0, float t, int n, float seed)\n{\n    if (t < 0.0 ||t > 1.0)\n    {\n        return p0;\n    }\n    vec2 dir = epochDirection(p0, n, seed);\n    float term = 2.0 * t - 1.0;\n    float term5 = term * term * term * term * term;\n    float dist = DISTANCE * (t - 0.1 * (term5 + 1.0)); // by solving v ~ 1 - (2t-1)^4\n    return dir * dist;\n}\nvec2 epochTotalDisplacement(vec2 p0, int n, float seed)\n{\n    vec2 dir = epochDirection(p0, n, seed);\n    return DISTANCE * 0.8 * dir; // by solving v ~ 1 - (2t-1)^4 between t=0 and t=1\n}\nvec2 getPos(float t, vec2 p0, float seed)\n{\n    int epoch = int(floor(t));\n    float dt = fract(t);\n    vec2 p = p0;\n    for (int i=0; i<epoch; ++i)\n    {\n        p += epochTotalDisplacement(p, i, seed);\n    }\n    p += epochDisplacement(p, dt, epoch, seed);\n    return p;\n}\n\n// color generation\nconst int NUM_COLORS = 9;\nconst vec3[NUM_COLORS] colors =\n    vec3[](\n        vec3(1,0,0),\n        vec3(1,0.5,0),\n        vec3(1,1,0),\n        vec3(0,1,0),\n        vec3(0,0.5,0),\n        vec3(0,1,1),\n        vec3(0,0,1),\n        vec3(0,0,0.5),\n        vec3(1,0,1)\n        );\nvec3 rainbow(float f)\n{\n    float colorspaceExactIndex = float(NUM_COLORS - 1) * f;\n    int index = int(colorspaceExactIndex);\n    if (index + 1 < NUM_COLORS)\n    {\n        vec3 col1 = colors[index];\n        vec3 col2 = colors[index+1];\n        float blend = colorspaceExactIndex - float(index);\n        return mix(col1, col2, blend);\n    }\n    else\n    {\n        return colors[index];\n    }\n}\n// random color without continuity of rainbow\nvec3 distinct(float f)\n{\n    return rainbow(fract(f*13161.36));\n}\n\n// voronoid diagram texture\nvoid findClosestPoint(in vec3 coord, \n                         in vec3[NUM_POINTS] points, \n                         out int closestPoint, \n                         out float closestDist)\n{\n    closestPoint = 0;\n    closestDist = distance(coord, points[0]);\n    for (int i=1; i<NUM_POINTS; ++i)\n    {\n        float dist = distance(coord, points[i]);\n        if (dist < closestDist)\n        {\n            closestDist = dist;\n            closestPoint = i;\n        }\n    }\n}\nvec3 voronoiColor(in vec2 coord)\n{\n    // move points\n    vec3[NUM_POINTS] points;\n    for (int i=0; i<NUM_POINTS; ++i)\n    {\n        float iSeed = 553.3252 * rand(1326.532 * INITIAL_POINTS[i]);\n        points[i] = fromPolar(getPos(iTime / EPOCH_LENGTH, INITIAL_POINTS[i], iSeed));\n    }\n    \n    // get closest point\n    int index;\n    float dist;\n    findClosestPoint(fromPolar(coord), points, index, dist);\n    \n    // set color\n    vec3 col = vec3(0,0,0);\n    if (dist > POINT_RADIUS)\n    {\n        float fraction = float(index) / float(NUM_POINTS - 1);\n        col = rainbow(fraction);\n    }\n    return col;\n}\n\n/**\n * Material atlas, implemented as a map\n */\nMaterial getMaterial(int id, vec2 uv)\n{\n    Material m = DEFAULT_MATERIAL;\n    switch (id)\n    {\n    case 0:\n        return m;\n    case 1:\n        vec3 col = voronoiColor(uv);\n        return Material(m.kAmbient * col, m.kDiffuse * col, m.kSpecular * col, m.shininess);\n    default:\n        return m;\n    }\n}\n\nvoid sphereIntersect(in Sphere sphere, in Ray ray, out bool isHit, out Intersection hit)\n{\n    // change coordinates so that we can treat \n    // sphere as unit sphere centered at (0,0,0)\n    // note that neither translation nor uniform scaling changes ray direction\n    ray.origin -= sphere.pos;\n    ray.origin /= sphere.r;\n    \n    // coefficients in quadratic equation for ray-sphere intersection\n    float a = 1.0;\n    float b = 2.0 * dot(ray.origin, ray.dir);\n    float c = dot(ray.origin, ray.origin) - 1.0;\n    float delta = b*b - 4.0*a*c;\n    \n    isHit = delta >= 0.0;\n    if (!isHit)\n    {\n        return;\n    }\n    \n    float term1 = -b/(2.0*a);\n    float term2 = sqrt(delta)/(2.0*a);\n    \n    float k = term1 - term2;\n    if (k < 0.0)\n    {\n        k = term1 + term2;\n    }\n    vec3 onSphere = ray.origin + k * ray.dir;\n    vec3 normal = onSphere; // true for unit sphere centered at (0,0,0) ;)\n    hit = Intersection(onSphere * sphere.r + sphere.pos, // transform back to original coordinates\n                       k,\n                       normal,\n                       getMaterial(sphere.materialId, toPolar(onSphere)));\n}\nvoid planeIntersect(in Plane plane, in Ray ray, out bool isHit, out Intersection hit)\n{\n    // change coordinates so that plane goes through (0,0,0)\n    ray.origin -= plane.origin;\n    \n    float denom = dot(plane.normal, ray.dir);\n    if (denom == 0.0)\n    {\n        // ray parallel to the plane\n        isHit = false;\n    }\n    else\n    {\n        // by solving equation for ray-plane intersection\n        float k = dot(plane.normal, -ray.origin) / denom;\n        isHit = k > 0.0;\n        if (isHit)\n        {\n            vec3 point = ray.origin + k * ray.dir;\n            vec3 zAxis = cross(plane.normal, plane.xAxis);\n            vec2 uv = vec2(dot(point, plane.xAxis), dot(point, zAxis));\n            hit = Intersection(point+ plane.origin,\n                               k,\n                               plane.normal,\n                               getMaterial(plane.materialId, uv));\n        }\n    }\n}\n/** \n * Hit types\n */\nvoid raytrace(in Ray ray,\n              out bool isHit,\n              out Intersection hit)\n{\n    bool isSphereHit, isPlaneHit;\n    Intersection sphereHit, planeHit;\n    \n    sphereIntersect(SPHERE, ray, isSphereHit, sphereHit);\n    planeIntersect(PLANE, ray, isPlaneHit, planeHit);\n    \n    isHit = isSphereHit || isPlaneHit;\n    if (isHit)\n    {\n        if (isSphereHit && sphereHit.dist < planeHit.dist)\n        {\n            hit = sphereHit;\n        }\n        else if (isPlaneHit)\n        {\n            hit = planeHit;\n        }\n    }\n}\n\n/**\n * Ray casting camera \n * centered at (0,0,0) \n * looking in -z direction \n * with +y being vertically up\n * assumes whole viewport (iResolution) is seen\n * \n * returns direction of the ray from camera center to 'coord' in image plane\n */\nRay castRay(in Camera camera,\n            in vec2 coord)\n{\n    // translate FOV into distance to image (in image coord units)\n    float imgPlaneDistance = iResolution.x / 2.0 / tan(camera.horizontalFOVangle / 2.0);\n    \n    // center viewport at (0,0)\n    coord -= 0.5 * iResolution.xy;\n    return Ray(camera.pos, normalize(vec3(coord, -imgPlaneDistance)));\n}\n\n/**\n * Components of lighting in the Pong model\n */\nvec3 ambient(in Intersection hit)\n{\n    return AMBIENT_LIGHT * hit.material.kAmbient;\n}\nvec3 diffuse(in Light light, in Intersection hit)\n{\n    vec3 pointToLight = light.pos - hit.pos;\n    float dist = length(pointToLight);\n    float geometricFactor = dot(pointToLight / dist, hit.normal);\n    // no contribution if light on the wrong side\n    if (geometricFactor <= 0.0)\n    {\n        return vec3(0,0,0);\n    }\n    else\n    {\n    \tvec3 materialFactor = hit.material.kDiffuse;\n    \tvec3 lightFactor = light.col * light.i;\n        float distanceFactor = 1.0 / (dist * dist);\n        return geometricFactor * distanceFactor * materialFactor * lightFactor;\n    }\n}\nvec3 specular(in Camera camera, in Light light, in Intersection hit)\n{\n    vec3 pointToLight = light.pos - hit.pos;\n    float dist = length(pointToLight);\n    vec3 pointToLightDir = pointToLight / dist;\n    // no contribution if light on the wrong side\n    if (dot(pointToLightDir, hit.normal) <= 0.0)\n    {\n        return vec3(0,0,0);\n    }\n    else\n    {\n        vec3 reflection = reflect(-pointToLightDir, hit.normal);\n        vec3 pointToCameraDir = normalize(camera.pos - hit.pos);\n        float geometricFactor = pow(dot(reflection, pointToCameraDir), hit.material.shininess);\n        // no contribution if camera on the wrong side\n        if (geometricFactor <= 0.0)\n        {\n            return vec3(0,0,0);\n        }\n        else\n        {\n            vec3 materialFactor = hit.material.kSpecular;\n            vec3 lightFactor = light.col * light.i;\n            float distanceFactor = 1.0 / (dist * dist);\n            return geometricFactor * distanceFactor * materialFactor * lightFactor;\n        }\n    }\n}\n\n/**\n * Lighting put all together\n */\nvec3 lighting(in Intersection hit)\n{\n    vec3 color = ambient(hit);\n    for (int i=0; i<LIGHT_NUM; ++i)\n    {\n        color += diffuse(INITIAL_LIGHTS[i], hit);\n        color += specular(CAMERA, INITIAL_LIGHTS[i], hit);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    bool isHit;\n    Intersection hit;\n    \n    // fragColor = voronoiColor(fragCoord);\n    Ray ray = castRay(CAMERA, fragCoord);\n    raytrace(ray, isHit, hit);\n    if (isHit)\n    {\n        fragColor = vec4(lighting(hit), 1);\n    }\n    else\n    {\n        fragColor = vec4(SKY_COLOR,1);\n    }\n    // fragColor = vec4(abs(rayDirection.xy), -0.3*rayDirection.z, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// structs for 3d graphics\nstruct Material\n{\n    vec3 kAmbient;\n    vec3 kDiffuse;\n    vec3 kSpecular;\n    float shininess; // specular exponent\n};\nstruct Sphere\n{\n    vec3 pos; // center\n    float r; // radius\n    int materialId;\n};\nstruct Plane\n{\n    vec3 origin;\n    vec3 xAxis; // assumed to be normalized\n    vec3 normal;\n    // yAxis = cross(normal, xAxis)\n    int materialId;\n};\nstruct Intersection\n{\n    vec3 pos;\n    float dist; // distance from ray origin\n    vec3 normal;\n    Material material;\n};\nstruct Ray\n{\n    vec3 origin; // assumed to be normalized\n    vec3 dir; // direction\n};\nstruct Camera\n{\n    vec3 pos;\n    // TODO: add camera viewing direction,\n    // currently set to -z\n    // with +y being vertically up\n    float horizontalFOVangle;\n};\nstruct Light\n{\n    vec3 pos;\n    vec3 col;\n    float i; // intensity\n};","name":"Common","description":"","type":"common"}]}