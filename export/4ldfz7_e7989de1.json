{"ver":"0.1","info":{"id":"4ldfz7","date":"1539094679","viewed":404,"name":"Exploded Mandelbulb","username":"efairbanks","description":"A tweaked mandelbulb with sparser geometry. Easier to see some detail. Mouse X value controls the exponent.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 look(vec2 xy, vec3 origin, vec3 target)\n{\n\tvec3 up=normalize(vec3(0.,1.,0.));\n    vec3 fwd=normalize(target-origin);\n    vec3 right=normalize(cross(fwd,up));\n    up=normalize(cross(fwd,right));\n    return normalize(fwd+right*xy.x+up*xy.y);\n}\nfloat map(vec3 pos)\n{\n    float Power=(1.-iMouse.x/iResolution.x)*8.6+1.;\n   \tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 80 ; i++) {\n\t\tr = length(z);\n        // if the length of the vector escapes toward\n        // infinity, we're not hitting this thing\n\t\tif (r>100.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r*1.0,Power)+0.2;\n\t\ttheta = theta*Power+46.57;\n\t\tphi = phi*Power+53.37;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        \n        // add the original point to the new one and recurse/repeat\n\t\tz+=pos;\n\t}\n    // fudge distance estimation from fractal\n    // using some calculus-y math I don't quite understand\n\treturn 0.5*log(r)*r/dr;\n}\n#define MAX_DISTANCE 14.\n#define MAX_STEPS 40\nfloat march(vec3 origin,vec3 ray,int steps)\n{\n    float t=.05;\n    for(int i=0;i<MAX_STEPS; i++)\n    {\n\t\tfloat d=map(origin+ray*t);\n        if(d<0.0005||d>=MAX_DISTANCE||i>=steps) break;\n        t+=d*0.95;\n    }\n    return min(t,MAX_DISTANCE);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 normal(vec3 p,float epsilon){vec2 e=vec2(epsilon,0.);return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx)));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // let's render!\n    vec2 uv=(fragCoord/iResolution.xy-.5)*2.;\n\tuv.x=uv.x*iResolution.x/iResolution.y;   \n    vec3 camera=vec3(1.);\n    camera=vec3(sin(iTime/4.),sin(iTime/4.),cos(iTime/4.))*1.2;\n    vec3 ray=look(uv,camera,vec3(0.));\n\tfloat dist=march(camera,ray,MAX_STEPS);\n    vec3 hit=camera+ray*dist;\n    float ao=pow(1.-dist/MAX_DISTANCE,20.);\n    float diffuse=clamp(dot(normal(hit,0.01*dist),normalize(camera)),0.5,1.);\n    float shade=diffuse*ao*0.5+ao*0.5;\n    vec3 color=hsv2rgb(vec3(length(hit)*.5+0.6,sin(length(hit*ao)*50.)*0.2+.8,shade*2.));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}