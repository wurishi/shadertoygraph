{"ver":"0.1","info":{"id":"lc3Xz4","date":"1713633174","viewed":73,"name":"Camer orbit","username":"palm82","description":"a basic camera orbit tool, uses buffer to store the state of the camera rotation/transformation. still has a few kinks that need to be worked out","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["camera","orbit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// #iChannel0 \"file://./bufferA.glsl\"\n\nfloat sdBox( vec3 p, vec3 b, mat3 transform )\n{\n\n  vec3 q = abs(p * transform) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nmat3 rotate(vec3 angles) {\n\n    if (angles == vec3(0)) {\n        return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n    }\n\n    float yawCos = cos(angles.y);\n    float yawSin = sin(angles.y);\n    mat3 ry =  mat3(\n        vec3(yawCos, 0, yawSin),\n        vec3(0, 1, 0),\n        vec3(-yawSin, 0, yawCos)\n    );\n\n    float pitchCos = cos(angles.z);\n    float pitchSin = sin(angles.z);\n    mat3 rz = mat3(\n        vec3(pitchCos, -pitchSin, 0),\n        vec3(pitchSin, pitchCos, 0),\n        vec3(0, 0, 1)\n    );\n\n    float rollCos = cos(angles.x);\n    float rollSin = sin(angles.x);\n    mat3 rx = mat3(\n        vec3(1, 0, 0),\n        vec3(0, rollCos, -rollSin),\n        vec3(0, rollSin, rollCos)\n    );\n\n    // Ry * Rz * Rx\n    return ry * rz * rx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 m = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    vec3 ro = vec3(0, 0, -3);         // ray origin\n    ro *= rotate(-vec3(m.yx, 0.));\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    vec3 col = vec3(0);               // final pixel color\n\n    rd *= rotate(vec3(-m.yx, 0.));\n    float t = 0.; // total distance travelled\n\n    // Raymarching\n    for (int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t;     // position along the ray\n\n        float d = sdBoxFrame(p, vec3(1.), .05 );       // current distance to the scene\n\n        t += d;                   // \"march\" the ray\n    \n        if (d < .001) break;      // early stop if close enough\n        if (t > 100.) break;      // early stop if too far\n    }\n\n    // Coloring\n    col = vec3(t * .05);           // color based on distance\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// #iChannel0 \"file://self\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 col = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    if (iMouse.z > 0.) {\n        vec2 diff = iMouse.xy-abs(iMouse.zw);\n        diff = (diff.xy) / iResolution.y;\n        col += clamp(diff, -0.5, 0.5)/40.;\n    }\n    fragColor = vec4(col,0.,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}