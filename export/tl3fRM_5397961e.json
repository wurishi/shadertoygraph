{"ver":"0.1","info":{"id":"tl3fRM","date":"1612407910","viewed":127,"name":"analytical_spiral","username":"Ecter","description":"used to answer following SE question. https://gamedev.stackexchange.com/q/188814/,  creates Archimedes spirals, left is spiral length varying based on time, right is theta length varying based on time. EDIT: Now restarts after 24 seconds. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi \t= 3.1415926535897932384626433832795;\nconst float sqrt3 = 1.7320508075688772935274463415059;\nconst float sqrt2 = 1.4142135623730950488016887242096;\nconst float inf = uintBitsToFloat(0x7F800000u);\n\n\n//takes uv in 0->1 coordinates and turns it into normalized cordinates centered at 0,0. \nvec2 center_corrected_uv(vec2 uv, vec2 resolution){\n    vec2 uvn = (uv - 0.5);\n    //this accounts for aspect ratio, so the spiral is not skewed. \n     if(iResolution.y > iResolution.x){\n        uvn.y *= resolution.y/resolution.x;\n    }else{\n        uvn.x *= resolution.x/resolution.y;\n    }\n    return uvn; \n}\n//\"atan + normalized\" (0 -> 2*pi)\nfloat atann(float y, float x){\n    float theta = atan(y, x);\n    //we add 2*pi because the result of atan in GLSL is pi -> -pi, and we want 0 -> 2*pi\n    if(theta < 0.0){\n        theta += 2.0*pi;\n    }\n    return theta; \n}\n\n\nbool approx_eq(float a, float b, float threshold){\n    return abs(a - b) < threshold; \n}\n\n\n\n//this is the same thing as the spiral length function, mathematically, I just wasn't sure if this was more or less performant. \n//these functions are basically the analytic integral of r = coef*theta, the equation of an archimedes spiral (a spiral with evenly spaced rings). \nfloat spiral_length_sinh(float theta, float coef){\n    //integral from https://math.stackexchange.com/a/424722/\n    //and from wolfram alpha\n    return coef*(1.0/2.0) * (sqrt(theta*theta + 1.0)*theta + asinh(theta));\n}\n\nfloat spiral_length(float theta, float coef){\n    //integral from https://math.stackexchange.com/a/424722/\n    //and from wolfram alpha\n    float sqrt_theta_1 = sqrt(theta*theta + 1.0);\n    return coef*(1.0/2.0) * (sqrt_theta_1*theta + log(sqrt_theta_1 + theta));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //increase this to \"zoom out\"\n    const float image_scale = 100.0;\n    //increase this to increase the speed of the spiral. \n    const float speed = 100.0; \n    //*decrease* this to INCREASE fade length\n    const float fade = 0.3; \n    //need a seperate additional fade modifier for the right side\n    //otherwise will be transparent. \n    const float right_fade_mod = 4.0; \n    //decrease this to increase fade spacing. \n    //pi gaurantees filled in distance, going smaller will make a \"gapped\" spiral. \n    const float swirl_radius = pi;\n    //this controls the swirl of the marker (the white line that shows up periodically)\n    const float marker_swirl_radius = 0.05*pi; \n    //time before whole animation restarts. \n    const float restart_interval_s = 24.0;\n    //time interval for blinking spiral line. \n    const float blink_interval_s = 4.0; \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color (this is what will display as the background if we make swirl radius even smaller). \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    //I want to display two different types of swirls, one which increases with spiral length, and one that increases with theta. \n    bool display_right = uv.x > 0.5; \n    if(display_right){\n        uv.x -= 0.5; \n    }\n    uv.x /= 0.5;\n    //divide resolution by two to account for split screen. \n    vec2 uvn = center_corrected_uv(uv, vec2(iResolution.x/2.0, iResolution.y)) * image_scale; \n    float r = length(uvn)*1.0;\n    float theta = 1.0*atann(uvn.y, uvn.x); \n\n    //theta needs to be incresed to with r increasing value, ever 2pi r we need to add 2 pi to theta, since it will reset to zero. \n    // we assume every 2*pi r we want to wrap around, our r = coef*theta is actually r = 1.0*theta.  \n    // This would need to change to account for a different coeff. \n    float theta_fixed = theta + 2.0*pi*floor(r/(2.0*pi)); \n\n    float time = mod(iTime,restart_interval_s) * speed; \n    //right side too fast if we don't do this\n    if(display_right){\n        time *= 0.1; \n    }\n    //if we only check for the distance from the adjusted theta we'll get this odd semi circular pattern,\n    //because inner radii will not pass the threshold for the next theta, so we need to look at 2*pi back \n    //and forward to actually get the proper distance to spiral line from current pixel \n    bool theta_the_eq = approx_eq(r, theta_fixed, swirl_radius);\n    bool theta_min_eq = approx_eq(r, theta_fixed - 2.0*pi,swirl_radius);\n    bool theta_max_eq = approx_eq(r, theta_fixed + 2.0*pi,swirl_radius);\n    bool within_swirl_radius = theta_the_eq || theta_min_eq || theta_max_eq;\n    float relative_theta; \n    if(theta_the_eq){\n        relative_theta = theta_fixed;\n    }else if(theta_min_eq){\n        relative_theta = theta_fixed - 2.0*pi;\n    }else if(theta_max_eq){\n        relative_theta = theta_fixed + 2.0*pi;\n     }\n    \n    if(theta_the_eq || theta_min_eq || theta_max_eq){\n        float final_value = 0.0;\n        \n        if(display_right){\n        //on the right, we show theta used as the time/distance modifier.  \n        // Notice that it appears to get \"faster\" the further out it goes.  \n        // This is because it is covering larger amounts of spiral length in the same angle space (theta). \n        // this may or may not be the effect you want. \n        //Notice, we have to use the appropriate theta which passed the approximate equal threshold, for similar reasons to why\n        //we needed to test three different distance metrics in the first place. \n        \n            //we use log in addition to the fade coefficient to create a more athsetically pleasing fade, but this isn't actually necessary. \n            //using only fade will still work, just with a linear ramp up to color. \n            col = vec3(fade*right_fade_mod*log(-(relative_theta - time)));\n        }else{ \n        //on the LEFT, we show the actual spiral distance used as the time/distance modifier.  \n        // Notice that it appears to get \"slower\" the further out it goes.  \n        // This is because it is covering larger amounts of spiral length, and as it gets further out theres more spiral to cover per angle area. \n        // this may or may not be the effect you want. \n        //Notice, we have to use the appropriate theta which passed the approximate equal threshold, for similar reasons to why\n        //we needed to test three different distance metrics in the first place. \n\n            //we use log in addition to the fade coefficient to create a more athsetically pleasing fade, but this isn't actually necessary. \n            //using only fade will still work, just with a linear ramp up to color. \n            col = vec3(fade*log(-(spiral_length(relative_theta, 1.0) - time)));\n        }\n    }\n\n    // this is used to display the white line, so you can be sure this is an archimedes spiral (again, an equally ringed distance spiral), \n    //if you removed this code, it would not display the line. \n    if(approx_eq(r, theta_fixed, marker_swirl_radius) \n    || approx_eq(r, theta_fixed - 2.0*pi,marker_swirl_radius) \n    || approx_eq(r, theta_fixed + 2.0*pi, marker_swirl_radius)){\n    //we blink this to show this is only temporary. \n        if(mod(mod(iTime,restart_interval_s), blink_interval_s) < 2.0){\n            col = vec3(1.0);\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}