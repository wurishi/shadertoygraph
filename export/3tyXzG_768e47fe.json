{"ver":"0.1","info":{"id":"3tyXzG","date":"1582927893","viewed":437,"name":"Pyre Crystal","username":"DmC","description":"Fanart / Inspired by a certain stage of Pyre by Supergiant Games.\nMusic is in Buffer B -> iChannel0 -> soundcloud . If it isn't playing automatically just confirm the URL in there and give it a kick.\n","likes":29,"published":1,"flags":96,"usePreview":0,"tags":["music","parallax","fanart","pyre"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.001\n#define RAY_STEPS 48\n\nstruct Intersection {\n    vec3 normal;\n    vec3 point;\n    bool valid;\n    float t;\n};\n \n\n    \nfloat l2 (in vec3 a, in vec3 b) {\n\tfloat x = a.x-b.x;\n    float y = a.y-b.y;\n    float z = a.z-b.z;\n    \n    return x*x+y*y+z*z;\n        \n}\n    \nIntersection groundPlane(in vec3 ro, in vec3 rd, in float h) \n{\n\tIntersection isect;\n    isect.valid = false;\n    isect.point = vec3(0);\n    isect.normal = vec3(0, 1, 0);\n    isect.t = -1.0;\n    \n    vec3 p0 = vec3(0, h, 0);\n    vec3 N = vec3(0, 1, 0);\n    \n    ro.y -= h;\n    \n    if (dot(-rd, N) < 0.001) return isect;\n    \n    float t = dot(p0 - ro, N) / dot(rd, N);\n \tvec3 p = ro+vec3(0.0, h, 0.0) + t * rd;\n\n    \n    isect.t = t;\n    isect.point = p;\n    isect.valid = true;\n    return isect;\n}\n\n\n// IQ\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n// IQ\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat map(in vec3 pos) {\n    pos -= vec3(0.19,0.1, 0.10);\n    pos = vec3(0.99619469809  * pos.x + 0.08715574274 * pos.z, pos.y, 0.99619469809  * pos.z - 0.08715574274 * pos.x);   \n    pos = vec3(0.98480775301 * pos.x + 0.17364817766 * pos.y, 0.98480775301 * pos.y - 0.17364817766 * pos.x, pos.z);\n    vec3 saved = pos;\n    pos = vec3(pos.x, pos.z, pos.y);\n    float m = sdHexPrism(pos, vec2(1.4, 3.0));\n    pos = vec3(0.70710678118 * pos.x + 0.70710678118  * pos.y, 0.70710678118 * pos.y - 0.70710678118 * pos.x, pos.z);\n    pos = vec3(0.98480775301 * pos.x + 0.17364817766 * pos.z, pos.y, 0.98480775301 * pos.z - 0.17364817766 * pos.x);\n    m = max(m-0.02, sdHexPrism(pos, vec2(1.55, 2.5))-0.02);\n    m = max(m, sdBox(saved, vec3(1.3, 2.55, 1.4)-0.02));  \n    return m-0.02;\n}\n\n\nvec3 getNormal(in vec3 pos) {\n\tvec2 d = vec2(EPS, 0.0);\n\treturn normalize(vec3(map(pos + d.xyy) - map(pos - d.xyy),\n\t\tmap(pos + d.yxy) - map(pos - d.yxy),\n\t\tmap(pos + d.yyx) - map(pos - d.yyx)));\n}\n\n// from Nimitz, \"Cheap curvature\"\nfloat curv(in vec3 p, in float n)\n{\n    vec2 e = vec2(-1., 1.)*(0.05+n*0.05);   \n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .25/e.y*(t1 + t2 + t3 + t4 - 4.0*map(p))*n*n;\n}\n\n\nvec3 musicColor(in vec3 pos) {\n\tvec4 m = texture(iChannel2, pos.xz*0.075+0.5);   \n    return m.w * m.xyz;\n}\n\n\nfloat getTerrain(in vec3 pos) { \n    pos *= 0.03;\n    pos += 0.5;\n    return texture(iChannel3, pos.xz).w;    \n}\n\nvec3 getTerrainN(in vec3 pos) {\n    pos *= 0.03;\n    pos += 0.5;\n    return texture(iChannel3, pos.xz).xzy;    \n}\n\nfloat march (in vec3 ro, in vec3 rd) {\n    float t = 0.01;   \n    for (int i = 0; i < RAY_STEPS; i++) {\n        vec3 pos = ro + t * rd;\n        float m = map(pos);\n        if (m < 0.01) {\n            return t;\n        }\n        t += m;\n    }\n    \n\treturn -1.0;    \n}\n\n\n\nvec3 cameraRay ( in vec3 camPos, in vec3 camTar, in vec2 uv, in vec3 F, in vec3 R, in vec3 U) {\n\tvec3 ref = camPos + 0.1 * F;\n    float len = 0.1;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 fuv = 2.0 * uv - 1.0;\n    vec3 p = ref + aspect * fuv.x * len * 0.41421356237 * R + fuv.y * len * 0.41421356237 * U;\n    return normalize(p - camPos);\n}\n\nfloat segment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec2 v = pa - ba*h;\n    \n    return v.x*v.x+v.y*v.y; \n} \n\nfloat logo (in vec2 uv) {\n    float d = segment(uv, vec2(-0.3, -0.45), vec2(-0.3, 0.8));\n    d = min(d, segment(uv, vec2(0.3, -0.3), vec2(-0.3, 0.8)));\n    d = min(d, segment(uv, vec2(0.3, -0.3), vec2(-0.7, 0.4)));\n    d = min(d, segment(uv, vec2(0.7, 0.4), vec2(-0.7, 0.4)));\n    d = min(d, segment(uv, vec2(0.7, 0.4), vec2(0.09, 0.09)));\n    d = min(d, segment(uv, vec2(0.09, 0.9), vec2(0.09, 0.09)));\n    float n = texture(iChannel1, 0.025 * (uv + iTime * vec2(-0.2, 2.0))).x;\n    return 0.8*smoothstep(0.005*n, 0.0, d) + 0.2*smoothstep(0.03*n, 0.0, d);\n}\n\nvec3 renderWater(in vec3 ro, in vec3 rd, in float maxDist, in vec3 startCol) {\n\tIntersection bound = groundPlane(ro, rd, 1.0);\n    Intersection water = groundPlane(ro, rd, 0.5);\n    \n    vec2 res = vec2(0.1, 0.1);\n    vec3 texMarch = ro+rd*bound.t;\n    bool hitWater = false;\n    float fog = 0.0;\n    float lh = 0.0f;\n    float ly = 0.0f;\n    vec3 refr = refract(rd, vec3(0, 1, 0), 0.712);\n    vec3 fogCol = vec3(0.0);\n    float dist = bound.t;\n    float dt = 0.02;\n    for (int i = 0; i < 210; ++i) {\n        if (dist > maxDist) return startCol + fogCol;\n        vec3 m = texture(iChannel1, texMarch.xz*0.025 - 0.005*iTime).xyz;\n        vec3 m2 = texture(iChannel1, -texMarch.xz*0.005 + 0.0025*iTime).xyz;\n        float k = getTerrain(texMarch);\n        if (texMarch.y > 0.5) {\n        \tvec3 music = length(texMarch.xz*texMarch.xz)*0.025*\n            \tmusicColor(texMarch)*step(0.5, texMarch.y)*smoothstep(2.0, 0.5, texMarch.y*texMarch.y);\n        \tfogCol += 0.3*music*(0.5+0.5*m2.x*m.y);\n        \tfogCol += vec3(0.1, 0.07, 0.001) * m2.y*m2.x* \n            \tsmoothstep(1.0, 0.99, texMarch.y) * smoothstep(4.0, 0.0, length(texMarch)/(texMarch.y+0.1));\n        \tfogCol += mix(vec3(0.005, 0.02, 0.016), vec3(0.005, 0.015, 0.03), smoothstep(0.3, 0.7, m2.x)) *\n           \t\tsmoothstep(0.0, 1.0, 0.2*length(texMarch.xz))*m2.x*m.y*m2.y*m2.z*(smoothstep(0.1, 0.0, k*k*k));\n        } else {\n            rd = refr;\n            dt += 0.002;\n        }\n        \n        if (texMarch.y < k) {\n            // IQ parallax height interpolation\n            texMarch += rd * (0.02 + 0.02*(lh-ly)/( texMarch.y-ly-k+lh));\n            break;   \n        }\n        \n        lh = k;\n        ly = texMarch.y;\n        dist += dt;\n        texMarch += rd*dt;\n    }\n    \n    vec3 m = texture(iChannel1, texMarch.xz*0.005+iTime*0.005).xyz;\n    \n    float hFinal = getTerrain(texMarch);\n    vec3 waterPt = ro+rd*water.t;\n    float w =clamp(0.1*length(waterPt- texMarch), 0.0, 1.0);\n    float k = m.x;\n    \n    vec3 n = getTerrainN(texMarch);\n    vec3 col = (vec3(0.25, 0.15, 0.3) * smoothstep(-0.3, 0.3,m.z*m.y) + \n                vec3(0.35, 0.05, 0.1) * \n                smoothstep(0.2, 0.4,  0.2*(m.x-0.5)+dot(n, normalize(vec3(0.0, 1.5, 0.0) - texMarch))))*\n               mix(vec3(0,0.1,0.5), vec3(1), exp(-0.025*l2(waterPt, vec3(0)))*(0.25+0.75*smoothstep(0.35, 0.75, hFinal)));\n    \n     \n    col = mix(col, mix(vec3(0.05, 0.01, 0.1), vec3(0.1, 0.2, 0.5), 1.0-mix(hFinal, w, m.x)), smoothstep(0.5+0.1*m.z, 0.49-0.1*m.z, hFinal));\n    col += fogCol;\n    vec3 drop = 0.5*texture(iChannel1, floor(waterPt.xz)*0.211).xyz+0.25 + vec3(floor(waterPt.xz),0.0);\n    vec3 dn = 2.0*(texture(iChannel1, waterPt.xz/(drop.z+0.2)).xyz - 0.5);\n    float ll = length(waterPt.xz-drop.xy);\n    vec3 ripple = vec3(0.0, m.y, m.y) * \n        smoothstep(0.1, 0.0, ll*drop.z) *\n        smoothstep(0.1, 0.8, m.x*drop.z*sin(drop.z*drop.z*iTime))*\n        step(hFinal, 0.49)*\n        smoothstep(0.2, 0.6*m.y+0.2, (0.5+0.5 *dot(normalize(waterPt.xz-drop.xy), dn.xy)) * sin(-5.0*drop.z*iTime +3000.0*drop.z+ (abs(sin(drop.z*6.28))+0.1)*80.0*ll));\n    col += ripple * (1.0+ripple + smoothstep(0.4, 0.41, hFinal)*smoothstep(0.5, 0.49, hFinal));\n    col = mix(vec3(0, 0.1, 0.2), col*vec3(1.1,1,1), exp(-0.003*min(l2(texMarch,ro),l2(waterPt,ro))));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 cam = vec3(5.75+0.75*sin(iTime*0.1), 9.5, 5.75+0.75*cos(iTime*0.2));\n    vec3 tar = vec3(0.0, 0.5, 0.0);\n    \n    vec3 F = normalize(tar - cam);\n    vec3 R = normalize(cross(F, vec3(0.0, 1.0, 0.0)));\n    vec3 U = normalize(cross(R, F));         \n\n    vec3 rd = cameraRay(cam, tar, uv, F, R, U);\n    vec3 col;\n \n    \n    \n    // hacky acceleration... trace in a limited uv window\n    float t = step(abs(uv.x-0.5), 0.15)*step(abs(uv.y - 0.55), 0.25) > 0.0 ? march(cam, rd) : -1.0;\n    if (t > 0.0) {\n    \tvec3 p = cam + t * rd;\n        vec3 n = getNormal(p);\n        vec3 r1 = reflect(F, n);\n        vec3 r2 = refract(F, n, 1.0/2.4);\n        col = mix(vec3(0.3,0.08,0.04), vec3(0.6, 0.6, 0.5), smoothstep(-0.1, 0.1, dot(r1, r2)));\n        \n        float noise = texture(iChannel1, iTime*0.002 + r1.xz*0.2).x;\n        float c = curv(p, noise+0.2);\n        col /= 1.0 - 0.5*smoothstep(0.3, 0.4, noise);\n        float glow = dot(-normalize(p), r2);\n        glow = glow*glow;\n        glow = glow*glow;\n        glow = glow*glow;\n        \n        vec2 luv = ((uv-vec2(0.0,0.05))*2.0-1.0)*vec2(iResolution.x/iResolution.y,1.0)*6.0;\n        float s = sin(iTime + 3.0*dot(r2, U) + 3.0*dot(r2, R));\n        luv -= 0.02*s;\n        luv /= (1.1 + 0.05 * s);\n        col += (0.7 + 0.3 * cos(0.3*iTime)) * mix(vec3(2.0, 1.0, 0.2), vec3(0.4, 0.4, 0.8), (s*0.5+0.5)) * logo(luv);\n        // fake internal faceting / refraction\n        col = mix(col, col*col, 0.5*smoothstep(abs(fract(4.0*r2.x+4.0*uv.x)-0.5), abs(fract(r2.y+2.0*uv.y)-0.5),0.5)); \n        col += texture(iChannel2, r1.xz*0.075+0.5).xyz*(glow + 1.0-exp(-20.0*c*c*c));\n        col += abs(r1.y*r1.y*r1.y + 0.1*r1.x*r1.z);\n        float t = getTerrain(p);\n        col = mix(vec3(0.19, 0.1, 0.19), col, 1.0-smoothstep(t+0.3, t-0.05, p.y));\n        \n    }\n    \n    col = renderWater(cam, rd, t > 0.0 ? t : 1000.0, col);\n\n    // final color adjustments, vignette and fade in\n    col = 1.0-exp(-2.0*col);\n    uv -= 0.5;\n    col *= (1.0 - 1.5*dot(uv, uv)) * smoothstep(1.0, 5.0, iTime);\n    col = pow(smoothstep(0.0, 1.0, col), vec3(0.65));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// precalculating heightmap\nfloat h(in vec2 uv) {\n\tfloat base = texture(iChannel0, uv / 0.35 * vec2(1.1, 0.7)).x;\n    float b1 = base;\n    base = mix(base, texture(iChannel0, uv / 1.0 * vec2(1.1, 0.9)).x, 0.2);\n    vec3 noise = texture(iChannel1, uv / 2.0).xyz;\n    base = dot(vec3(0.5, 0.3, 0.2), \n               vec3(smoothstep(0.25, 0.325, base + 0.1 * (noise.y-0.5)), smoothstep(0.45, 0.9, base), smoothstep(0.35, 0.7, base)));\n    \n    base = smoothstep(0.05, 0.15, length(uv-0.5)) * \n        smoothstep(0.1, 0.9, (noise.y*0.5+0.5)*smoothstep(0.2, 0.8, base));\n    return max(base, smoothstep(0.1, 0.9, (0.8+0.3*b1)*smoothstep(0.11, 0.02, 0.9*length(uv - 0.497))));\n     \n}\n\n// simple sobel normal\nvec3 n(in vec2 uv, in vec2 d) {\n\t\n    const float skx[9] = float[9](1.0f, 0.0f, -1.0f, 2.0f, 0.0f, -2.0f, 1.0f, 0.0f, -1.0f);\n    const float sky[9] = float[9](1.0f, 2.0f, 1.0f, 0.0f, 0.0f, 0.0f, -1.0f, -2.0f, -1.0f);\n    float gx = 0.0f;\n    float gy = 0.0f;\n    \n    vec2 g = vec2(0.0);\n    g += vec2( 1.0,  1.0) * h(uv - d);\n    g += vec2( 0.0,  2.0) * h(uv + vec2( 0.0, -1.0) * d);\n    g += vec2(-1.0,  1.0) * h(uv + vec2( 1.0, -1.0) * d);\n    g += vec2( 2.0,  0.0) * h(uv + vec2(-1.0,  0.0) * d);\n    g += vec2(-2.0,  0.0) * h(uv + vec2( 1.0,  0.0) * d);\n    g += vec2( 1.0, -1.0) * h(uv + vec2(-1.0,  1.0) * d);\n    g += vec2( 0.0, -2.0) * h(uv + vec2( 0.0,  1.0) * d);\n    g += vec2(-1.0, -1.0) * h(uv + d);\n\n    float gz = 1.0;\n    vec3 nor = vec3(g, gz);\n    \n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y);\n    vec4 c = texture(iChannel2, uv);\n    // bigger delta helps smooth out the noise for softer look\n    vec2 d = 2.0 / iResolution.xy;\n    float h = h(uv);\n    fragColor = vec4(n(uv, d), h);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MlB3Rm","filepath":"https://soundcloud.com/zaramoth/pyre-original-soundtrack-moon-touched","previewfilepath":"https://soundcloud.com/zaramoth/pyre-original-soundtrack-moon-touched","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// buffer B is a simplified / modified version of KitVanDeBunt's https://www.shadertoy.com/view/Xlj3Dt\n// below citations transferred from above shader\n// https://www.shadertoy.com/view/XdX3z2\n// atan2: http://http.developer.nvidia.com/Cg/index_stdlib.html\n\n#define bars 50.0\t\t\t\t// How many buckets to divide spectrum into\n#define barSize 1.0 / bars\t\t// Constant to avoid division in main loop\n#define barGap 0.15 * barSize\t// 0.1 represents gap on both sides, so a bar is\n#define PI 3.14159265359\n#define circleRadius 0.5;\n\n\n\nfloat atan2(float y, float x)\n{\n  float t0, t1, t2, t3, t4;\n\n  t3 = abs(x);\n  t1 = abs(y);\n  t0 = max(t3, t1);\n  t1 = min(t3, t1);\n  t3 = float(1) / t0;\n  t3 = t1 * t3;\n\n  t4 = t3 * t3;\n  t0 =         - float(0.013480470);\n  t0 = t0 * t4 + float(0.057477314);\n  t0 = t0 * t4 - float(0.121239071);\n  t0 = t0 * t4 + float(0.195635925);\n  t0 = t0 * t4 - float(0.332994597);\n  t0 = t0 * t4 + float(0.999995630);\n  t3 = t0 * t3;\n\n  t3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;\n  t3 = (x < 0.0) ?  float(3.141592654) - t3 : t3;\n  t3 = (y < 0.0) ? -t3 : t3;\n\n  return t3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y);\n    vec2 center = vec2(0.5);\n    float deltaYFromCenter = center.y - uv.y;\n    float deltaXFromCenter = center.x - uv.x;\n\tvec4 musicMap;\n    float angleFromCenter = atan2(deltaYFromCenter,deltaXFromCenter);  \n    musicMap.r = fract((angleFromCenter+PI-iTime*0.05)/(PI*2.0));\n    float distFromCenter = sqrt((deltaYFromCenter*deltaYFromCenter)+(deltaXFromCenter*deltaXFromCenter));\n    float circleFromCenter = (distFromCenter*3.0);\n    circleFromCenter = circleFromCenter-circleRadius;\n    musicMap.b = circleFromCenter;\n    \n    vec4 col = vec4(0.0);\n\n    float musicChannelnput = texture( iChannel0, vec2( musicMap.r,0.0)).r;\n    float barStart = floor(musicMap.r * bars) / bars;\n    float intensity = texture(iChannel0, vec2(barStart+0.01, 0.0)).r;\n    // want to set a minimum + bias for higher frequencies and volume\n    intensity = 0.1 + (0.5 + 1.5 * barStart) * intensity * intensity;\n    intensity *= smoothstep(barStart, barStart+barGap, musicMap.r-barGap);\n    intensity *= 1.0-musicMap.b;\n\n    float onOff = musicMap.b - intensity;\n    onOff = clamp(onOff,-0.5,0.5); \n    onOff = smoothstep(0.99, 1.0, onOff+1.0);\n    col.w = smoothstep(0.0, 0.3, intensity)*(1.0-onOff)*smoothstep(0.0, 0.05, musicMap.b);\n    \n    float rotAxis = cos(iTime)*(uv.y-0.5)+sin(iTime)*(uv.x-0.5)+0.5;\n    float noise = texture(iChannel1, 0.05 * (uv+0.1*iTime)).x-0.5;\n    col.xyz = pow(mix(vec3(1.0, 0.9, 0.2), vec3(0.2, 0.7, 1.0), smoothstep(0.3, 0.7, rotAxis + 0.2*noise)), vec3(4.0));\n\n    fragColor = vec4(col);\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"}]}