{"ver":"0.1","info":{"id":"wlSSW1","date":"1565734924","viewed":81,"name":"Skrollin sädeaskellusmoottori","username":"jnalanko","description":"Skrolli 2019.3. sädeaskellusjutun esimerkkimoottori.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","skrolli"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdf(vec3 p){ // Donitsi\n    vec3 offset = vec3(0.0, 1.3, -1.8);\n    p.yz = vec2(p.y/sqrt(2.0)+p.z/sqrt(2.0),p.y/sqrt(2.0)-p.z/sqrt(2.0)); \n    p += offset;\n    return length(vec2(length(p.xz)-1.0,p.y)) - 0.3;\n}\n\nvec3 get_normal(vec3 pos){ // Numeerinen approksimaatio pinnan normaalille\n    vec3 eps = vec3(0.01,0,0);\n    return normalize(vec3(\n        sdf(pos + eps.xyy) - sdf(pos - eps.xyy),\n        sdf(pos + eps.yxy) - sdf(pos - eps.yxy),\n        sdf(pos + eps.yyx) - sdf(pos - eps.yyx)\n    ));\n}\n\nvec4 get_color(vec3 surface){ // Pikselin väri Phongin valaistusmallilla\n    vec3 normal = get_normal(surface);\n    vec3 l = vec3(-1,-1,-0.2); // Valon tulosuunta\n    vec3 l_prime = l + 2.0*dot(l,normal)*normal;\n    float cos_angle = max(dot(-l_prime, -surface),0.0)/(length(l_prime) * length(-surface));\n    vec3 specular = vec3(1.0,1.0,1.0) * 0.8 * pow(cos_angle,2.5);\n    vec3 diffuse = vec3(1.0,0.0,0.0) * 0.2 * max(dot(normal, -l),0.0);\n    vec3 ambient = vec3(1.0,0.0,0.0) * 0.3;\n    return vec4(clamp(diffuse + specular + ambient,0.0,1.0), 1.0);\n}\n\nvoid mainImage(out vec4 outputColor, in vec2 fragCoord){\n    // Skaalataan pikseleiden koordinaatit välille [-1,1]\n    vec2 pixel_pos = (fragCoord.xy / iResolution.xy - vec2(0.5,0.5)) * 2.0;\n    pixel_pos.x *= 16.0/9.0; // Kuvasuhde\n    // Luodaan säde kamerasta yhden yksikön päässä leijuvan \n    // kuvitteellisen ikkunan läpi annetun pikselin kohdalta\n    vec3 ray = normalize(vec3(pixel_pos.x, pixel_pos.y,-1));\n    // Tehdään 50 iteraatiota sädeaskellusta etäisyyskentän avulla\n    vec3 pos = vec3(0.0,0.0,0.0);\n    for(int step = 0; step < 50; step++) pos += ray * sdf(pos);\n    if(sdf(pos) > 0.01) // Ei osumaa\n        outputColor = vec4(0,0,0,1);\n    else // Osuma\n        outputColor = get_color(pos);\n}","name":"Image","description":"","type":"image"}]}