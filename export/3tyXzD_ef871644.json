{"ver":"0.1","info":{"id":"3tyXzD","date":"1582259211","viewed":166,"name":"Menger Sponge Cinematic","username":"RaySoldier","description":"Ray-marched rendering of the Menger Sponge: https://en.wikipedia.org/wiki/Menger_sponge\n\nEdit: I found a more efficient SDF resulting in doubled performance. Also added DOF and music.\n\nOptimized for NVIDIA GeForce GTX 1060 Direct3D11","likes":2,"published":1,"flags":96,"usePreview":0,"tags":["fractal","ray","menger","marcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mlj3RD","filepath":"https://soundcloud.com/orthodoxofficial/frou-frou-let-go-orthodox","previewfilepath":"https://soundcloud.com/orthodoxofficial/frou-frou-let-go-orthodox","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//# define DEBUG\n\n# define BLUR_DETAIL 5.\n\n# define APER 0.004\n# define FOC 0.024\n\nvec3 dof(sampler2D tex, vec2 uv, float strength){\n    \n    float f = texture(tex, vec2(0.5f)).w;\n    float d = texture(tex, uv).w;\n    \n    float b = abs(APER * FOC * (f - d))/(f * (f - FOC))*strength;\n    \n    float blur = min(b, 0.005) / BLUR_DETAIL;\n    \n    vec4 t = texture(tex, uv);\n    \n    for(int n = 1; n <= int(BLUR_DETAIL) + 1; n++){\n        \n        t += texture(tex, uv + float(n) * blur * vec2(1, 0));\n        t += texture(tex, uv + float(n) * blur * vec2(-1, 0));\n        t += texture(tex, uv + float(n) * blur * vec2(0, 1));\n        t += texture(tex, uv + float(n) * blur * vec2(0, -1));\n        \n        t += texture(tex, uv + float(n) * blur * vec2(0.7, 0.7));\n        t += texture(tex, uv + float(n) * blur * vec2(-0.7, 0.7));\n        t += texture(tex, uv + float(n) * blur * vec2(0.7, -0.7));\n        t += texture(tex, uv + float(n) * blur * vec2(-0.7, -0.7));\n    }\n    \n    return t.xyz / (1. + 8. * BLUR_DETAIL);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    \n    int iter = int(iTime/PAN_INTERVAL);\n    \n    float angle1 = mod(float(nextRand(iter)), 2. * 3.14159);\n    float angle2 = mod(float(nextRand(iter+1)), 2. * 3.14159);\n    \n    angle1 -= iTime*ROTATION_SPEED;\n    angle2 -= iTime*ROTATION_SPEED;\n    \n    float time = mod(iTime, PAN_INTERVAL);\n    \n    vec3 cam1 = generatePosition(iter, time);\n    vec3 cam2 = generatePosition(iter + 1, time - PAN_INTERVAL);\n    vec3 dir1 = vec3(sin(angle1), 0, cos(angle1));\n    vec3 dir2 = vec3(sin(angle2), 0, cos(angle2));\n    \n    float w = 1. - min(1.0, (PAN_INTERVAL - time) / FADE_TIME);\n    \n    vec3 col1 = render(uv, cam1 * SCALE, dir1, vec3(0, 1, 0), 1.);\n    vec3 col2 = vec3(0);\n    \n    if(w > 0.0001){\n        col2 = render(uv, cam2 * SCALE, dir2, vec3(0, 1, 0), 1.);\n    }\n    \n    vec3 col = mix(col1, col2, w);\n    \n    fragColor = vec4(col, 1);*/\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n#ifdef DEBUG\n    \n    if(uv.x < 0.1 && uv.y < 0.1){\n        fragColor = texture(iChannel1, vec2(0)).wwww;\n        return;\n    }\n    \n    if(uv.x > 0.5 && uv.y < 0.5){\n        fragColor = texture(iChannel0, uv).wwww / 50.;\n        return;\n    }\n    \n#endif\n    \n    // Rediculously bad, but cheap, AA\n    vec3 e = vec3(vec2(1, 1) / iResolution.xy, 0);\n    \n    vec3 col =     dof(iChannel0, uv, 50.);\n    col = min(col, dof(iChannel0, uv + e.xz, 50.));\n    col = min(col, dof(iChannel0, uv + e.zy, 50.));\n    col = min(col, dof(iChannel0, uv + e.xy, 50.));\n    \n    col *= 1.0 - clamp(1.2 * length(uv - vec2(0.5)), 0.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n# define SUN\n# define LIGHTING\n# define SHADOWS\n\n# define MIN_LIGHT 0.003\n\n# define MAX_STEPS 500\n# define SURF_DIST 0.0001\n# define MAX_DIST 250.\n\n// Menger Sponge Settings\n\n# define DETAIL_LEVEL 9\n# define SCALE 27.\n\n// Camera Settings\n\n# define TRAVEL_DETAIL 6\n# define PAN_INTERVAL 6.9465\n# define ROTATION_SPEED 0.2\n# define FADE_TIME 1.\n\nvec3 getCam(vec2 uv, vec3 forward, vec3 up, float fov){\n    \n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + normalize(forward) / fov);\n}\n\nfloat box(vec3 p, vec3 c, vec4 s){\n    vec3 q = abs(p - c) - s.xyz;\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-s.w;\n}\n\nfloat menger(vec3 p, int i){\n    \n    p += vec3(3);\n    \n    float d = MAX_DIST;\n    \n    for(int n = 0; n < i; n++){\n    \n    \t/*d = min(d, box(p, vec3(3, 3, 3), vec4(1, 1, 4, 0)));\n    \td = min(d, box(p, vec3(3, 3, 3), vec4(4, 1, 1, 0)));\n    \td = min(d, box(p, vec3(3, 3, 3), vec4(1, 4, 1, 0)));*/\n        \n        vec3 q = abs(p - vec3(3));\n        \n        d = min(d, min(max(q.x, q.y), min(max(q.x, q.z), max(q.y, q.z))) - 1.);\n        \n        p *= 3.;\n        \n        p = vec3(6) - abs(vec3(3) - abs(p - vec3(9)));\n        \n        d *= 3.;\n\t}\n    \n    return d/pow(3., float(i));\n}\n\nfloat sdScene(vec3 p){\n    \n    p /= SCALE;\n    \n    float d = max(box(p, vec3(0), vec4(3, 3, 3, 0)), -menger(p, DETAIL_LEVEL));\n    \n    //d =  max(d, sphere(p, vec4(0, -3, 0, 8)));\n    \n    return d * SCALE;\n}\n\nvec3 nScene(vec3 p){\n    vec2 e = vec2(0, 0.001);\n    vec3 nrml = normalize(vec3(sdScene(p + e.yxx),\n                               sdScene(p + e.xyx),\n                               sdScene(p + e.xxy)) - \n                         vec3(sdScene(p)));\n    return nrml;\n}\n\nfloat rayMarch(vec3 rO, vec3 rD, out int n){\n    \n    float d = 0.1;\n    n = 0;\n    \n    for(; n < MAX_STEPS; n++){\n        \n        vec3 p = rO + d * rD;\n        \n        float stp = sdScene(p);\n        \n        d += stp;\n        \n        if(d > MAX_DIST || stp < SURF_DIST) break;\n    }\n    return d;\n}\n\nfloat softShadow(vec3 rO, vec3 rD, float iD, float mD, float w){\n    \n    float d = iD;\n    \n    float soft = 1.0;\n    \n    for(int n = 0; n < MAX_STEPS; n++){\n        \n        vec3 p = rO + d * rD;\n        \n        float stp = sdScene(p);\n        \n        soft = min(soft, 0.5+0.5*stp/(w*d));\n        \n        d += stp;\n        \n        if(d > mD || stp < SURF_DIST) break;\n    }\n    \n    soft = soft * soft * (3.0 - 2.0*soft);\n    \n    return soft * 2. - 1.;\n}\n\nvec3 pLight(vec3 p, vec4 lightPos){\n    \n    vec3 lightD = lightPos.xyz - p;\n    float lightR = length(lightD);\n    lightD /= lightR;\n    \n    if(lightPos.w / (lightR * lightR) < MIN_LIGHT){\n        return vec3(0.0);\n    }\n\n    vec3 nrml = nScene(p);\n    \n    float light = dot(nrml, lightD) / lightR /lightR * lightPos.w;\n    \n    if(light < 0.0){\n        return vec3(0.);\n    }\n    \n#ifdef SHADOWS\n    light *= softShadow(p, lightD, SURF_DIST / dot(lightD, nrml) * 5.0, lightR, 0.1);\n#endif\n    \n    light = clamp(light, 0., 5.);\n    \n    return light * vec3(1.);\n}\n\nvec3 dLight(vec3 p, vec3 lightD){\n\n\n    vec3 nrml = nScene(p);\n    \n    float light = dot(nrml, lightD);\n    \n    if(light < 0.0){\n        return vec3(0.);\n    }\n    \n#ifdef SHADOWS\n    light *= softShadow(p, lightD, SURF_DIST / dot(lightD, nrml) * 5.0, MAX_DIST, 0.1);\n#endif\n    \n    light = clamp(light, 0., 5.);\n    \n    return light * vec3(1.);\n    \n}\n\nvec3 iLight(vec3 p, int iter){\n    \n    return 0.1 * vec3(0.6, 0.8, 1.0) * pow(0.98, float(iter));\n}\n\nvec3 getLighting(vec3 p, int iter, vec3 camPos){\n    \n    vec3 light = vec3(0);\n    \n    light += iLight(p, iter);\n    \n    //light += pLight(p, vec4(camPos, 0.3));\n    \n#ifdef LIGHTING\n    light += dLight(p, normalize(vec3(1, 0.2, 0.6)));\n#endif\n    \n    return light;\n}\n\nint nextRand(int prev){\n    return int(mod(float(prev*15454357 + 847263), 576243.));\n}\n\nvec2[8] list = vec2[](vec2(-1, -1), vec2(0, -1), vec2(1, -1), vec2(-1, 0), vec2(1, 0), vec2(-1, 1), vec2(0, 1), vec2(1, 1));\n\nvec3 generatePosition(int seed, float time){\n    \n    float delta = 2.;\n    \n    vec2 pos = vec2(0);\n        \n    seed = nextRand(seed);\n    \n    int rep = int(mod(float(seed), float(TRAVEL_DETAIL)));\n    \n    for(int n = 0; n < rep; n++){\n        \n        seed = nextRand(seed);\n        \n        pos += delta * list[int(mod(float(seed), 8.))];\n        \n        delta /= 3.;\n    }\n    \n    vec3 p = vec3(pos, sin(float(seed * 30)) + time * 4. / PAN_INTERVAL - 2.);\n    \n    return p;\n}\n\nvec3 getAlbedo(vec3 p){\n    \n    return vec3(1.0);\n    \n    /*vec3 n = abs(nScene(p));\n    \n    float m = max(n.x, max(n.y, n.z));\n    \n    vec2 uv;\n    \n    if(m == n.x){\n    \tuv = p.yz;\n    }\n    if(m == n.y){\n    \tuv = p.xz;\n    }\n    if(m == n.z){\n    \tuv = p.xy;\n    }\n    \n    vec3 col1 = texture(iChannel0, uv/9.).xyz;\n    vec3 col2 = texture(iChannel0, uv).xyz;\n    \n    return mix(col1, col2, 0.5);*/\n}\n\nvec4 render(vec2 uv, vec3 camPos, vec3 camForward, vec3 camUp, float fov){\n    \n    vec3 rD = getCam(uv, camForward, camUp, fov);\n    \n    int ao;\n    \n    float dist = rayMarch(camPos, rD, ao);\n    \n    if(dist > MAX_DIST){\n        return vec4(mix(vec3(0.2), vec3(0.6, 0.7, 0.9), dot(rD, vec3(0, 1, 0)) * .5 + .5), MAX_DIST);\n    }\n    \n    vec3 p = camPos + dist * rD;\n    \n    vec3 col = getLighting(p, ao, camPos) * getAlbedo(p);\n    \n    return vec4(pow(col, vec3(1./2.2)), dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    \n    float t = mod(iTime, 277.86);\n    \n    int iter = int(t/PAN_INTERVAL);\n    \n    float angle1 = 0.;//mod(float(nextRand(iter)), 2. * 3.14159);\n    float angle2 = 0.;//mod(float(nextRand(iter+1)), 2. * 3.14159);\n    \n    float time = mod(t, PAN_INTERVAL);\n    \n    vec3 cam1 = generatePosition(iter, time);\n    vec3 cam2 = generatePosition(iter + 1, time - PAN_INTERVAL);\n    \n    angle1 -= t*ROTATION_SPEED*sign(cam1.x);\n    angle2 -= t*ROTATION_SPEED*sign(cam2.x);\n    \n    vec3 dir1 = vec3(sin(angle1), 0, cos(angle1));\n    vec3 dir2 = vec3(sin(angle2), 0, cos(angle2));\n    \n    float w = 1. - min(1.0, (PAN_INTERVAL - time) / FADE_TIME);\n    \n    vec4 col1 = render(uv, cam1 * SCALE, dir1, vec3(0, 1, 0), 1.);\n    vec4 col2 = vec4(0);\n    \n    if(w > 0.0001){\n        col2 = render(uv, cam2 * SCALE, dir2, vec3(0, 1, 0), 1.);\n    }\n    \n    fragColor = mix(col1, col2, w);\n}","name":"Buffer A","description":"","type":"buffer"}]}