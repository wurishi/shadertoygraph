{"ver":"0.1","info":{"id":"WdjBR1","date":"1589494451","viewed":204,"name":"ShATI - Vitalit√©","username":"Flopine","description":"My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 11th subject: vitality :)\nAlso made during a twitch session you can re-watch here:  https://www.twitch.tv/flopine","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoise","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define time iTime\n#define TAU 6.2831853071\n#define dt mod(time,TAU)\n\nvec2 hash22 (vec2 x)\n{return fract(sin(vec2(dot(x,vec2(12.4,16.4)),dot(x,vec2(23.4,28.37))))*12.4);}\n\nvec3 voronoise (vec2 uv)\n{\n    vec2 uv_id = floor(uv);\n    vec2 uv_cell = fract(uv);\n    vec2 bpoint, bneigh, bdiff;\n    float bdist = 10.;\n    for (int i=-1; i<=1; i++)\n    {\n        for (int j=-1; j<=1; j++)\n        {\n            vec2 neigh = vec2(float(i),float(j));\n            vec2 point = hash22(uv_id+neigh);\n            vec2 diff = neigh + point - uv_cell;\n            float dist = length(diff);\n            if (dist < bdist)\n            {\n                bneigh = neigh;\n                bpoint = point;\n                bdiff = diff;\n                bdist = dist;\n            }\n        }\n    }\n\n    bdist = 10.;\n    for (int i=-2; i<=2; i++)\n    {\n        for (int j=-2; j<=2; j++)\n        {\n            if (i==0 && j==0) continue;\n            vec2 neigh = bneigh + vec2(float(i), float (j));\n            vec2 point = hash22(uv_id+neigh);\n            vec2 diff = neigh + point - uv_cell;\n            float dist = dot(0.5*(bdiff+diff),normalize(diff-bdiff));\n            bpoint = point;\n            bdist = min(dist, bdist);\n        }\n    }\n    return vec3(bpoint,bdist);\n}\n\nvec3 voro;\nvec2 ground (vec3 p)\n{\n    voro = voronoise(p.xz);\n    float d = abs(p.y)\n        - smoothstep(0.01,0.05,voro.z)*0.1; \n    return vec2(d, 1.);\n}\n\nvec2 water (vec3 p)\n{\n    p.y += 0.01;\n    float d = abs(p.y)-smoothstep(0.08,0.01-(sin(length(voro.xy*.5)+dt)*0.5+0.5), voro.z)*0.2;\n    return vec2 (d,2.);\n}\n\nvec2 mat_min (vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\nvec2 SDF (vec3 p)\n{return mat_min(ground(p),water(p));}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.05,0.);\n    return normalize(SDF(p).x-vec3(SDF(p-eps.xyy).x,SDF(p-eps.yxy).x,SDF(p-eps.yyx).x));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.,4.,-3.),\n        rd = getcam(ro,vec3(0.),uv),\n        p = ro,\n        l = normalize(vec3(1.,2., -2.)),\n        col = vec3(0.);\n\n    float shad;\n    vec2 d;  \n\n    for (float i=0.; i<20.; i++)\n    {\n        d = SDF(p);\n        if (d.x<0.01) break;\n        p += d.x*rd*0.3;\n    }\n\n    float t = length(ro-p);\n    vec3 n = getnorm(p);\n    float light = max(dot(n,l),0.);\n\n    if (d.y == 1.) col = mix(vec3(0.2,0.02,0.01),vec3(0.7,0.5,0.3),light);\n    else if (d.y == 2.) col = mix(vec3(0.0,0.0,0.08),vec3(0.1,0.7,0.9),light);\n\n        col = mix(col, vec3(0.9,0.8,0.5),1.-exp(-0.008*t*t));\n\n    fragColor = vec4(sqrt(col),1.);\n}","name":"Image","description":"","type":"image"}]}