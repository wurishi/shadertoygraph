{"ver":"0.1","info":{"id":"wd2cRD","date":"1631535458","viewed":361,"name":"Laser Floyd","username":"spalmer","description":"replicating the Pink Floyd album cover\nwound up hacking the crap out of [url=https://shadertoy.com/view/Ndc3DN]Sunbeam Diffraction[/url] by [url=http://users.shadertoy.com/mdb]mdb[/url] which was pretty darn close already","likes":11,"published":1,"flags":32,"usePreview":1,"tags":["spectrum","light","prism","pathtracing","art","diffraction","spectral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tuned to approximate the Dark Side of the Moon album cover\n// https://en.wikipedia.org/wiki/The_Dark_Side_of_the_Moon#/media/File:Dark_Side_of_the_Moon.png\n\n// see BufferA, this just dithers and presents to the window\nvoid mainImage(out vec4 o, vec2 q)\n{\n\to = texelFetch(iChannel0, ivec2(q), 0); // fetch BufferA output\n\tfloat bluenoise = texelFetch(iChannel1, ivec2(q) % ivec2(textureSize(iChannel1, 0)), 0).r;\n\tbluenoise = bluenoise * 2. - 1.;\n\to += 1./512. * bluenoise; // dither just in case there might possibly be color bands\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// maybe now my dream of replicating this image will stop haunting me\n\n// I found a nice toy and decided to fork it to get started\n// Sunbeam Diffraction https://shadertoy.com/view/Ndc3DN by mdb\n\n// draws the image and blends it over time\n\n// TODO at some point I want to try to simplify back to RGB\n// instead of taking a foray through XYZ color space\n\n// I might work on it some more, but it's looking pretty good rn\n\n// first thing is to collapse into one tab!\n\n// was Common\n\n#define R iResolution.xy\n\nstruct Triangle { vec2 a, b, c; };\n\nTriangle[] scene = Triangle[] (\n\tTriangle(.5*vec2(0, 1),\n\t\t\t .5*vec2( sqrt(3.)*.5, -.5),\n\t\t\t .5*vec2(-sqrt(3.)*.5, -.5))\n\t);\n\nfloat Isegment(vec2 ro, vec2 rd, vec2 p0, vec2 p1, out vec2 n)\n{\n\tvec2 v1 = ro - p0,\n         v2 = p1 - p0,\n         v3 = vec2(-rd.y, rd.x);\n\tfloat d = dot(v2, v3);\n\tif (d == 0.) return -1.;\n\tfloat t1 = -((v1.x*v2.y) - (v1.y*v2.x)) / d,\n          t2 = dot(v1, v3) / d;\n\tif (t1 >= 0. && (t2 >= 0. && t2 <= 1.)) {\n\t\tn = normalize(vec2(-v2.y, v2.x));\n\t\tn *= -sign(dot(n, rd));\n\t\treturn t1;\n\t}\n\treturn -1.;\n}\n\nfloat Itriangle(vec2 ro, vec2 rd, Triangle tri, out vec2 n)\n{\n\tvec2 n2;\n\tfloat tmin = Isegment(ro, rd, tri.a, tri.b, n),\n\tt = Isegment(ro, rd, tri.a, tri.c, n2);\n\tif (t >= 0. && (t < tmin || tmin < 0.)) { tmin = t; n = n2; }\t\n\tt = Isegment(ro, rd, tri.b, tri.c, n2);\n\tif (t >= 0. && (t < tmin || tmin < 0.)) { tmin = t; n = n2; }\n\treturn tmin; \n\n}\n\nfloat tScene(vec2 ro, vec2 rd, out vec2 normal)\n{\n\tfloat tmin = -1.;\n\tfor (int i = 0; i < scene.length(); ++i) {\n\t\tTriangle tri = scene[i];\n\t\tvec2 n;\n\t\tfloat t = Itriangle(ro, rd, tri, n);\n\t\tif (t >= 0. && (t < tmin || tmin < 0.)) { tmin = t; normal = n; }\n\t}\n\treturn tmin;\n}\n// iq's originally - just factored the sqrt out\nfloat dSeg2(vec2 p, vec2 a, vec2 b)\n{\n\tp -= a; b -= a;\n\tp -= b * clamp(dot(p, b) / dot(b, b), 0., 1.);\n\treturn dot(p, p);\n}\n// just for the outline <sigh>\nfloat dScene(vec2 q)\n{\n\tfloat d = 3.4e38;\n\tfor (int j = 0; j < scene.length(); ++j) {\n\t\tTriangle t = scene[j];\n\t\td = min(d, dSeg2(q, t.a, t.b));\n\t\td = min(d, dSeg2(q, t.b, t.c));\n\t\td = min(d, dSeg2(q, t.c, t.a));\n\t}\n\treturn sqrt(abs(d)) * sign(d);\n}\n\n// wavelength stuff\n\n// table wavelength to XYZ\n// from https://shadertoy.com/view/7tjSDh\n// http://cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[81] =\n\tvec3[81] (\n\tvec3(0.001368, 0.000039, 0.006450), // 380 nm\n\tvec3(0.002236, 0.000064, 0.010550), // 385 nm\n\tvec3(0.004243, 0.000120, 0.020050), // 390 nm\n\tvec3(0.007650, 0.000217, 0.036210), // 395 nm\n\tvec3(0.014310, 0.000396, 0.067850), // 400 nm\n\tvec3(0.023190, 0.000640, 0.110200), // 405 nm\n\tvec3(0.043510, 0.001210, 0.207400), // 410 nm\n\tvec3(0.077630, 0.002180, 0.371300), // 415 nm\n\tvec3(0.134380, 0.004000, 0.645600), // 420 nm\n\tvec3(0.214770, 0.007300, 1.039050), // 425 nm\n\tvec3(0.283900, 0.011600, 1.385600), // 430 nm\n\tvec3(0.328500, 0.016840, 1.622960), // 435 nm\n\tvec3(0.348280, 0.023000, 1.747060), // 440 nm\n\tvec3(0.348060, 0.029800, 1.782600), // 445 nm\n\tvec3(0.336200, 0.038000, 1.772110), // 450 nm\n\tvec3(0.318700, 0.048000, 1.744100), // 455 nm\n\tvec3(0.290800, 0.060000, 1.669200), // 460 nm\n\tvec3(0.251100, 0.073900, 1.528100), // 465 nm\n\tvec3(0.195360, 0.090980, 1.287640), // 470 nm\n\tvec3(0.142100, 0.112600, 1.041900), // 475 nm\n\tvec3(0.095640, 0.139020, 0.812950), // 480 nm\n\tvec3(0.057950, 0.169300, 0.616200), // 485 nm\n\tvec3(0.032010, 0.208020, 0.465180), // 490 nm\n\tvec3(0.014700, 0.258600, 0.353300), // 495 nm\n\tvec3(0.004900, 0.323000, 0.272000), // 500 nm\n\tvec3(0.002400, 0.407300, 0.212300), // 505 nm\n\tvec3(0.009300, 0.503000, 0.158200), // 510 nm\n\tvec3(0.029100, 0.608200, 0.111700), // 515 nm\n\tvec3(0.063270, 0.710000, 0.078250), // 520 nm\n\tvec3(0.109600, 0.793200, 0.057250), // 525 nm\n\tvec3(0.165500, 0.862000, 0.042160), // 530 nm\n\tvec3(0.225750, 0.914850, 0.029840), // 535 nm\n\tvec3(0.290400, 0.954000, 0.020300), // 540 nm\n\tvec3(0.359700, 0.980300, 0.013400), // 545 nm\n\tvec3(0.433450, 0.994950, 0.008750), // 550 nm\n\tvec3(0.512050, 1.000000, 0.005750), // 555 nm\n\tvec3(0.594500, 0.995000, 0.003900), // 560 nm\n\tvec3(0.678400, 0.978600, 0.002750), // 565 nm\n\tvec3(0.762100, 0.952000, 0.002100), // 570 nm\n\tvec3(0.842500, 0.915400, 0.001800), // 575 nm\n\tvec3(0.916300, 0.870000, 0.001650), // 580 nm\n\tvec3(0.978600, 0.816300, 0.001400), // 585 nm\n\tvec3(1.026300, 0.757000, 0.001100), // 590 nm\n\tvec3(1.056700, 0.694900, 0.001000), // 595 nm\n\tvec3(1.062200, 0.631000, 0.000800), // 600 nm\n\tvec3(1.045600, 0.566800, 0.000600), // 605 nm\n\tvec3(1.002600, 0.503000, 0.000340), // 610 nm\n\tvec3(0.938400, 0.441200, 0.000240), // 615 nm\n\tvec3(0.854450, 0.381000, 0.000190), // 620 nm\n\tvec3(0.751400, 0.321000, 0.000100), // 625 nm\n\tvec3(0.642400, 0.265000, 0.000050), // 630 nm\n\tvec3(0.541900, 0.217000, 0.000030), // 635 nm\n\tvec3(0.447900, 0.175000, 0.000020), // 640 nm\n\tvec3(0.360800, 0.138200, 0.000010), // 645 nm\n\tvec3(0.283500, 0.107000, 0.000000), // 650 nm\n\tvec3(0.218700, 0.081600, 0.000000), // 655 nm\n\tvec3(0.164900, 0.061000, 0.000000), // 660 nm\n\tvec3(0.121200, 0.044580, 0.000000), // 665 nm\n\tvec3(0.087400, 0.032000, 0.000000), // 670 nm\n\tvec3(0.063600, 0.023200, 0.000000), // 675 nm\n\tvec3(0.046770, 0.017000, 0.000000), // 680 nm\n\tvec3(0.032900, 0.011920, 0.000000), // 685 nm\n\tvec3(0.022700, 0.008210, 0.000000), // 690 nm\n\tvec3(0.015840, 0.005723, 0.000000), // 695 nm\n\tvec3(0.011359, 0.004102, 0.000000), // 700 nm\n\tvec3(0.008111, 0.002929, 0.000000), // 705 nm\n\tvec3(0.005790, 0.002091, 0.000000), // 710 nm\n\tvec3(0.004109, 0.001484, 0.000000), // 715 nm\n\tvec3(0.002899, 0.001047, 0.000000), // 720 nm\n\tvec3(0.002049, 0.000740, 0.000000), // 725 nm\n\tvec3(0.001440, 0.000520, 0.000000), // 730 nm\n\tvec3(0.001000, 0.000361, 0.000000), // 735 nm\n\tvec3(0.000690, 0.000249, 0.000000), // 740 nm\n\tvec3(0.000476, 0.000172, 0.000000), // 745 nm\n\tvec3(0.000332, 0.000120, 0.000000), // 750 nm\n\tvec3(0.000235, 0.000085, 0.000000), // 755 nm\n\tvec3(0.000166, 0.000060, 0.000000), // 760 nm\n\tvec3(0.000117, 0.000042, 0.000000), // 765 nm\n\tvec3(0.000083, 0.000030, 0.000000), // 770 nm\n\tvec3(0.000059, 0.000021, 0.000000), // 775 nm\n\tvec3(0.000042, 0.000015, 0.000000)  // 780 nm\n);\n// nice rainbow, but this table is huge, surely can be\n// done algorithmically using Boltzmann stuff!\nfloat standardObserver1931_w_min = 380.;\nfloat standardObserver1931_w_max = 780.;\nint standardObserver1931_length = 81;\n\nvec3 WavelengthToXYZLinear(float fWavelength)\n{\n\tfloat fPos = (fWavelength - standardObserver1931_w_min) / (standardObserver1931_w_max - standardObserver1931_w_min);\n\tfloat fIndex = fPos * float(standardObserver1931_length);\n\tfloat fFloorIndex = floor(fIndex);\n\tfloat fBlend = clamp(fIndex - fFloorIndex, 0., 1.);\n\tint iIndex0 = int(fFloorIndex);\n\tint iIndex1 = iIndex0 + 1;\n\tiIndex1 = min(iIndex1, standardObserver1931_length - 1);\n\treturn mix(standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend);\n}\n\n// but isn't this actually going to RGB not sRGB?  because gamma.\nvec3 XYZtosRGB(vec3 XYZ)\n{\n\t// XYZ to sRGB\n\t// http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\tmat3 m = mat3(\n\t\t3.2404542, -1.5371385, -0.4985314,\n\t   -0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252);\t\n\treturn XYZ * m;\n}\n\nfloat BlackBody(float t, float w_nm) // temperature in Kelvin, wavelength in nanometers\n{\n\tfloat h = 6.6e-34 // Planck constant\n\t, k = 1.4e-23 // Boltzmann constant\n\t, c = 3e8 // Speed of light\n\t, w = w_nm * 1e-9\n\t// Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\t\n\t, w5 = w*w*w*w*w;\t\n\treturn 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.));\n}\n\n// how bright do we want this thing to be?\n// was originally 6000K, which is very bright \n// 4000K is reddish, at 3000K can no longer see blue\nvec3 waveLengthToXYZ(float w) \n{\n\tfloat bb = 1e-13 * BlackBody(6000., w);\n\tvec3 XYZ = WavelengthToXYZLinear(w);\n\treturn bb * XYZ;\n}\n\t\n//vec3 waveLengthToRGB(float w) \n//{\n//\treturn XYZtosRGB(waveLengthToXYZ(w));\n//}\n\n// was BufferA\n\nuint seed;\n\nfloat random() \n{\n\tseed ^= 2747636419u;\n\tseed *= 2654435769u;\n\tseed ^= seed >> 16;\n\tseed *= 2654435769u;\n\tseed ^= seed >> 16;\n\treturn float(seed *= 2654435769u) / 4294967295.;\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n\tseed = uint(q.y*R.x + q.x) + uint(R.x*R.y) * uint(iFrame); // initRandomGenerator\t\n\tvec2 normal, uv = (q + q - R) * .5 / R.y; uv.y += .1;\n\tfloat dmain = dScene(uv);\n\tvec3 c = vec3(0); // color accumulated in XYZ gamut\n\t// 3 is pretty close to the album cover,\n    // but I prefer 4's symmetry.  2 doesn't exit.\n    // rn 4th bounce is so dim you can't see it anyway.\n\tconst int laserBounces = 3; //4; //\n\t// who needs frame rate anyway? especially on first frame.\n\tint SPP = iFrame == 0 ? 64 : 8; // uses uniform already // + min(0, iFrame)\n\t// please don't unroll, takes too long to compile\n\tfor (int j = SPP; j-- > 0; ) {   \n\t\t// laser color\n\t\tfloat rng = random();\n\t\tfloat w = mix(380., 780., rng);\n\t\tconst float A = 1.2280;\n\t\tconst float B = .09;\n\t\tfloat n2 =  A + B/(w*w*1e-6);\n\t\tvec3 cXYZ = waveLengthToXYZ(w);\n\n\t\tfloat n1 = 1.; // vaccuum IoR - air would be like 1.003\n\t\tfloat R0 = pow((n1 - n2) / (n1 + n2), 2.);\n\n\t\t// laser setup\n\t\tvec2 p0 = vec2(-2., -.5); // beam emit location\n\t\tfloat k = .339; // beam emit angle\n\t\tvec2 rd = vec2(cos(k), sin(k));\n\t\tfloat inside = -1.;\n\t\tfor (int b = laserBounces /*+ min(0, iFrame)*/; b-- > 0; ) {\n\t\t\t// intersect\n\t\t\tfloat tmin = tScene(p0, rd, normal);\n\n\t\t\tfloat t = tmin;\n\t\t\tif (t < 0.) t = 1e7;\n\n\t\t\t// color according to alignment of ray w pixel\n\t\t\tvec2 nrd = vec2(-rd.y, rd.x); // perpendicular vector to ray, for sine of angle ray vs. pixel? seems overcomplicated for such purpose..\n\t\t\tfloat d2 = dot(rd, uv - p0); // distance to pixel along ray\n\t\t\tif (d2 > 0. && d2 < t) // is pixel along this bounce?\n\t\t\t\tc += 40. * cXYZ * exp(-300.*abs(dot(nrd, uv - p0))); // much narrower focus than original\n\t\t\tvec2 p2 = p0 + rd * t; // hit point\n\n\t\t\t// skip fog/shadow to speed it up and actually looks better for my purposes,\n\t\t\t// trying to match the album art, which does not scatter (much) and is very stylized and sharp.\n\t\t\t#if 0\n\t\t\tvec2 uvp2 = p2 - uv;\n\t\t\tfloat l = length(uvp2) + 1e-3;\n\t\t\t// trace shadow ray toward pixel, for fog? replaces nrd with hit scene normal also\n\t\t\tfloat shadow = tScene(uv, uvp2/l, nrd);\n\t\t\tif (abs(shadow - l) < .01) \n\t\t\t\tc += .2 * cXYZ * (.01 + .01*step(0., dot(normal, -uvp2))) / (dot(uvp2, uvp2) + 0.07);\n\t\t\t#endif\n\t\t\t\n\t\t\t// next ray setup\n\t\t\tfloat r = R0 - (1. - R0) * dot(normal, rd); // probability of reflection at incidence angle\n\t\t\tif (random() < 1. - r) {\n\t\t\t\trd = reflect(rd, normal);\n                cXYZ *= .006; // very little light gets reflected here, for artsy purposes\n\t\t\t} else {\n\t\t\t\trd = refract(rd, normal, pow(n2, inside));\n\t\t\t\tinside = -inside; // if we flipped n2 instead of inside, we wouldn't need the pow above, but may need compensated for elsewhere\n\t\t\t}\n\t\t\t//rd = normalize(rd); // original didn't have it... guess it isn't needed\n\n\t\t\tp0 = p2 + rd * .00001; // skip past the surface\n\t\t\tif (tmin < 0.) break;\n\t\t}\n\t}\n\tc /= float(SPP);\n\tc = XYZtosRGB(c); // once at end\n\tc = max(c, 0.);\n\tc += .2 * exp2(-400. * dmain); // outline shape dim white\n\tc /= c + .26; // reinhard tone map\n\tc *= 2.; // brightness\n\tc *= 1. - exp2(2.*(min(0., length(uv * vec2(.6,.8)) - .5))); // vignette\n\tc = min(c, 1.);\n\to = vec4(c, 1);\n\tif (iFrame > 0)\n        o = mix(texelFetch(iChannel0, ivec2(q), 0), o, .016); // accumulate color over time\n}\n\t//c = pow(c, vec3(1./2.2)); // sRGB gamut - meh the reinhard already punched it up well enough\n\t\t//exp2(-256.*iTimeDelta)); // variable framerate makes it flicker though","name":"Buffer A","description":"","type":"buffer"}]}