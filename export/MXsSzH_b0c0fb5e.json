{"ver":"0.1","info":{"id":"MXsSzH","date":"1715973633","viewed":118,"name":"Fork Ripple wat Shader_Noo 335","username":"Shader_Noob2023","description":"asda","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["rain","ripple"],"hasliked":0,"parentid":"M3lSzH","parentname":"Ripple water shader"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define pi 3.141\n#define heightMapResolution iChannelResolution[0]\n#define pixelToTexelRatio (iResolution.xy/heightMapResolution.xy)\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 hToNormal(float tex) \n{\n    \n    return -vec2(dFdx(tex), dFdy(tex)) * pixelToTexelRatio;\n}\n\nfloat Hash21(vec2 p) { //Thanks  The Art of Code https://www.shadertoy.com/view/tlyGW3\n    p = fract(p*vec2(23.345, 456.21));\n    p += dot(p, p+235.32);\n    return fract(p.x*p.y);\n}\n\nfloat wave (vec2 pos, float scale, vec2 uv, float vel, float freq, float amp) {\n\n    uv += pos;\n    uv = uv*scale;\n    \n    float circle = length(uv); // Desenha um Circulo\n    \n    float alpha = (1.0 - length(((uv)*2.1))); // Desenha um Circulo\n    \n    alpha = clamp(alpha, 0.0, 1.0); // \n\n    float loop = fract(time*vel)-0.5; // Time loop que vai de -0,5 a 0,5\n   \n    amp *= alpha; // Amplitude diminui conforme chega às bordas\n    \n    float alpha2 = 1.0-length(uv*2.0*(1.0-loop));\n    \n    \n    circle = amp*sin(circle*freq-(loop*pi*3.));\n    \n    //circle = mix(0., circle, alpha);\n    \n    //circle *= alpha;\n    circle *= smoothstep(0.0, 1.0, alpha);\n    \n    //return alpha2;\n    \n    return mix(0.0, circle, loop);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv2 = fragCoord/iResolution.xy; \n    vec2 uv = (fragCoord - 0.5/iResolution.xy)/iResolution.y;   // Cria, Centraliza a UV e deixa Quadrada\n    vec2 uv3 = (fragCoord - 0.5/iResolution.xy)/iResolution.y;\n    \n    uv *= Rot(1.);\n    \n    float scale = 10.5; // Escala\n    uv *= scale;\n    \n    float scale3 = 1.5; // Escala\n    uv3 *= scale3;\n    \n    \n    uv3 *= Rot(0.54);\n    vec2 offset = vec2(0.5,0.2)*1.0;\n    uv3 += offset;\n    \n    vec2 dv = fract(uv) - 0.5; // Cria e Centraliza as UVs repetidas\n    vec2 id = floor(uv); // Cria a ID de cada Tile\n    \n    \n    vec2 dv3 = fract(uv3) - 0.5; // Cria e Centraliza as UVs repetidas\n    vec2 id3 = floor(uv3); // Cria a ID de cada Tile\n    \n    float rand3 = Hash21(id3); // valor aleatorio entre 0-1\n    float rand4 = fract(rand3*321.876); // outro Valor aleatório baseado no anterior\n    \n   \n    float rand = Hash21(id); // valor aleatorio entre 0-1\n    float rand2 = fract(rand*123.321); // outro Valor aleatório baseado no anterior\n    \n  \n\n    vec2 pos = vec2((rand-0.5)*0.95, (rand2-0.5))*0.95;\n    \n    vec2 pos2 = vec2((rand3-0.5)*0.55, (rand4-0.5))*0.45;\n    \n    float circle = wave(pos, (2.*rand+1.2)*1.5, dv, rand2+1.1, 3.+ 3.*(rand2), 0.1 + rand*0.55);\n    circle += wave(pos2, (rand3+1.5)*1.1, dv3, 1.2*(rand4+0.9), 25.+ 05.*(rand4), 0.8 + rand3*0.3);\n\n\n    vec2 normal = hToNormal(circle);\n    \n    normal *= 8.0;\n    normal += 0.5;\n    \n       \n    // Output to screen\n    fragColor = vec4(normal, 1.0 ,1.0);\n    \n     \n    //fragColor = texture(iChannel0, uv2+normal);\n    \n\n    //if (dv.x>0.49 || dv.y> 0.49) fragColor.r = 1.0;\n    //if (dv3.x>0.49 || dv3.y> 0.49) fragColor.g = 1.0;\n    \n}","name":"Image","description":"","type":"image"}]}