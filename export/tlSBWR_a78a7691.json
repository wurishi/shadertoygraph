{"ver":"0.1","info":{"id":"tlSBWR","date":"1598654145","viewed":129,"name":"Pathtracing in the Basilica","username":"athibaul","description":"Pathtracing a simple scene according to iq's tutorial","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","gi","globalillumination","iq","pathtracing","tonemapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pathtracing a simple scene\n// Inspired by iq's tutorial\n// https://iquilezles.org/articles/simplepathtracing\n\n// TODO Improve the scene\n// TODO Add better control of materials\n\n\n#define T_MIN 0.001\n#define T_MAX 100.0\n\n#define SAMPLES 10\n#define BOUNCES 4\n\n// Hash function by Dave Hoskin\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat seed = 42.0;\nvec2 random2f()\n{\n    seed += 1.0;\n    return hash21(seed);\n}\n\n\nvec2 sphereIntersect( in vec3 ro, in vec3 rd,\n                      in vec3 c, in float r,\n                      out vec3 normal)\n{\n    // Closest and farthest point of intersection with the sphere\n    // If no intersection, both are -1.\n    ro -= c;\n    float rord = dot(ro, rd);\n    float Delta_prime = rord*rord + r*r - dot(ro, ro);\n    float dt = sqrt(Delta_prime);\n    float tmin = -rord-dt, tmax = -rord+dt;\n    if(Delta_prime < 0.0 || tmax < 0.0) return vec2(-1.0); // no intersection\n    normal = normalize(ro + tmin * rd);\n    return vec2(tmin, tmax);\n}\n\nvec2 boxIntersect( in vec3 ro, in vec3 rd,\n                   in vec3 c, in vec3 r,\n                   out vec3 normal )\n{\n    ro -= c;\n    rd += 1e-20; // Avoid errors when ray is aligned with an axis\n    vec3 m = 1.0/rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * r;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    \n    float tmin = max(t1.x, max(t1.y, t1.z));\n    float tmax = min(t2.x, min(t2.y, t2.z));\n    \n    if(tmax < tmin || tmax < 0.0) return vec2(-1.0); // no intersection\n    \n    normal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2(tmin, tmax);\n}\n\n\nvec3 sphPos;\nvec3 boxPos;\n\nvoid worldMoveObjects( in float ctime )\n{\n    sphPos = vec3(2.5, 0.0, 0.0)*cos(ctime);\n    boxPos = sin(ctime)*vec3(0.0,2.5,0.0);\n}\n\nvec2 worldIntersect( in vec3 ro, in vec3 rd,\n                     out vec3 normal,\n                     out vec3 color )\n{\n    vec3 cnorm;\n    vec2 t = vec2(T_MAX, -1.0);\n    \n    vec2 t1 = sphereIntersect(ro, rd, sphPos, 1.0, cnorm);\n    if(t1.y > 0.0 && t1.x < t.x)\n    {\n        normal = cnorm;\n        color = vec3(0.9, 0.2, 0.7);\n        t.x = t1.x;\n        t.y = max(t1.x, t.y);\n    }\n    t1 = boxIntersect(ro, rd, boxPos, vec3(0.8), cnorm);\n    if(t1.y > 0.0 && t1.x < t.x)\n    {\n        normal = cnorm;\n        color = vec3(0.5, 0.9, 0.3);\n        t.x = t1.x;\n        t.y = max(t1.x, t.y);\n    }\n    t1 = boxIntersect(ro, rd, vec3(0.0), vec3(0.1,2.6,0.1), cnorm);\n    if(t1.y > 0.0 && t1.x < t.x)\n    {\n        normal = cnorm;\n        color = vec3(0.5, 0.5, 0.5);\n        t.x = t1.x;\n        t.y = max(t1.x, t.y);\n    }\n    t1 = boxIntersect(ro, rd, vec3(0.0), vec3(2.6,0.1,0.1), cnorm);\n    if(t1.y > 0.0 && t1.x < t.x)\n    {\n        normal = cnorm;\n        color = vec3(0.5, 0.5, 0.5);\n        t.x = t1.x;\n        t.y = max(t1.x, t.y);\n    }\n    t1 = boxIntersect(ro, rd, vec3(0.0,0.0,-1.0), vec3(5.0,5.0,0.1), cnorm);\n    if(t1.y > 0.0 && t1.x < t.x)\n    {\n        normal = cnorm;\n        color = vec3(0.8, 0.8, 0.8);\n        t.x = t1.x;\n        t.y = max(t1.x, t.y);\n    }\n    return t;\n}\n\nfloat worldShadow( vec3 ro, vec3 rd, float dist )\n{\n    vec3 n, c;\n    vec2 tres = worldIntersect(ro, rd, n, c);\n    return (tres.y < 0.0 || tres.x > dist) ? 1.0 : 0.0;\n}\n\nvec3 worldGetBackground( in vec3 rd )\n{\n    return texture(iChannel0, rd.xzy).rgb;\n}\n\nmat4x3 worldMoveCamera( in float ctime )\n{\n    float th = 3.*cos(0.2*ctime)+3.14159/2.;\n    vec3 camPos = vec3(3.0*cos(th), 5.0*sin(th), 1.2);\n    //vec3 camPos = vec3(0.0, 0.0, 0.212);\n    vec3 camFwd = normalize(vec3(0.0) - camPos);\n    vec3 camRight = normalize(cross(camFwd, vec3(0.0, 1e-10, 1.0)));\n    vec3 camUp = cross(camRight, camFwd);\n    return mat4x3(camPos, camFwd, camRight, camUp);\n}\n\nvec3 worldDirectLighting( vec3 pos, vec3 nor, float fre )\n{\n    //return vec3(0.);\n    \n    pos += T_MIN * nor;\n    vec3 l1pos = normalize(vec3(0.5,0.6,0.8)); // sun\n    vec3 l1col = vec3(0.9, 0.8, 0.7);\n    float l1 = clamp(dot(nor, l1pos), 0.0, 1.0) * worldShadow( pos, l1pos, T_MAX);\n    vec3 l2pos = vec3(-2.0,-2.0,1.0); // light in scene\n    vec3 l2dir = normalize(l2pos - pos);\n    float l2dist = length(l2pos - pos);\n    float l2 = clamp(dot(nor, l2dir), 0.0, 1.0) * worldShadow( pos, l2dir, l2dist );\n    vec3 l2col = 6.0*vec3(0.8,0.7,0.9) / (l2dist*l2dist);\n    //vec3 l3pos = vec3(-0.8,0.0,-0.6);\n    //float l3 = clamp(dot(nor, l3pos), 0.0, 1.0) * worldShadow( pos, l3pos );\n    //vec3 l3col = vec3(0.7,0.8,0.9);\n    vec3 diff = l1*l1col + l2*l2col/* + l3*l3col*/;\n    \n    return diff * (1.-fre);\n}\n\nvec3 cosineDirection( vec3 nor )\n{\n    vec4 q; // quaternion to rotate from z axis to normal\n\tq.xyz = cross(vec3(0.0,0.0,1.0), nor);\n\tq.w = 1.0 + nor.z;\n    q = normalize(q);\n    vec2 rand = random2f();\n    rand = vec2( 2.0*3.14159*rand.x, acos(sqrt(rand.y)) );\n    vec3 r = vec3(cos(rand.x)*rand.y, sin(rand.x)*rand.y, 1.0); // TODO\n    // Rotate it toward the normal\n    // Rotated vector is v' = qvq^-1\n    r = q.w * r + cross(q.xyz, r);\n    r = q.w * r + cross(r, -q.xyz);\n    return normalize(r);\n}\n\nvec3 worldGetBRDFRay( in vec3 pos, in vec3 nor, in vec3 eye, float fre )\n{\n    if( random2f().x > fre )\n    {\n        return cosineDirection( nor );\n    }\n    else\n    {\n        return reflect(eye, nor);\n    }\n}\n\n\nvec3 rendererCalculateColor( vec3 ro, vec3 rd )\n{\n    vec3 normal;\n    \n    vec3 tcol = vec3(0.0);\n    vec3 fcol = vec3(1.0);\n    \n    for(int i=0; i<BOUNCES; i++)\n    {\n        vec3 scol;\n        vec2 intersec = worldIntersect(ro, rd, normal, scol);\n\t\t\n        if(intersec.y < 0.0)\n        {\n            tcol += fcol*worldGetBackground(rd);\n            break;\n        }\n\t\telse\n        {\n            // When we meet a material, we compute separately the\n            // direct and indirect lighting\n            float fre = 0.04 + 0.96 * pow(1.-clamp(dot(normal,-rd),0.,1.), 5.);\n        \tvec3 pos = ro + rd * intersec.x;\n        \tvec3 dcol = worldDirectLighting(pos, normal, fre);\n\t\t\t// Add direct lighting\n            fcol *= scol;\n            tcol += fcol * dcol;\n            // And then bounce for gathering the next level of indirect lighting\n            ro = pos + 1e-4*normal;\n            rd = worldGetBRDFRay(pos, normal, rd, fre);\n        }\n    }\n    return tcol;\n    //vec3 bounce = reflect(rd, normal);\n    //col = worldGetBackground(normalize(bounce)) * scolor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = texelFetch(iChannel1, ivec2(mod(fragCoord, 256.)), 0).x + iTime;\n    //seed = 0.0;\n    float frameTime = iTime;\n    float shutterAperture = 1.0*max(iTimeDelta, 1./24.); // in seconds\n    float lensSize = 0.12;\n    float focusDistance = 1.0;\n    \n    \n    vec3 col;\n    for(int i=0; i<SAMPLES; i++)\n    {\n        // Screen coord with antialiasing\n    \tvec2 uv = (2.*(fragCoord+random2f())-iResolution.xy)/iResolution.y;\n        // Several time samples for motion blur\n        float ctime = frameTime + shutterAperture*float(i)/float(SAMPLES);\n    \tworldMoveObjects(ctime);\n    \n        mat4x3 cam = worldMoveCamera(ctime);\n        float fov = 0.7;\n        vec3 ro = cam[0];\n        vec3 rd = normalize(cam[1] + fov * (uv.x * cam[2] + uv.y * cam[3]));\n        \n        // Depth of field\n        focusDistance = min(length(sphPos - ro), length(boxPos - ro)-1.0);\n        //focusDistance = length(ro);\n        vec3 sharpPoint = ro + focusDistance*rd;\n        vec2 lensPoint = lensSize * random2f();\n        ro += lensPoint.x * cam[2] + lensPoint.y * cam[3];\n        rd = normalize(sharpPoint - ro);\n        \n        col += rendererCalculateColor(ro, rd);\n        //col += cosineDirection(rd);\n        //col += rd;\n    }\n    \n    col /= float(SAMPLES);\n    \n    // Tone mapping\n    // Uniform version preserves color but softens the bright spots too much\n    /*float amp = max(col.x, max(col.y, col.z));\n    float amp2 = (amp<2./3.)? amp : 1.0-4./27./(amp*amp);\n    col *= amp2/amp;*/\n    // Per-channel version lets it get close to white\n    col = mix(col, 1.0-0.148148/(col*col), step(0.667,col));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}