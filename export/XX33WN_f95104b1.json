{"ver":"0.1","info":{"id":"XX33WN","date":"1716569173","viewed":76,"name":"Raymarcher EE","username":"Saw8888","description":"IDK","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define KEY_W 87\n#define KEY_S 83\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nconst int gridS = 4;\n\nint grid[gridS*gridS*gridS];\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nfloat SDFSmokeBox(vec3 p, vec3 pos, vec3 size) {\n    vec3 translatedP = p - pos;\n    vec3 d = abs(translatedP) - size;\n    float outsideDistance = length(max(d, 0.0));\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    return outsideDistance+insideDistance;\n}\nfloat SDFshpere(vec3 p, vec3 pos, float d){\n    return distance(p,pos) - d;\n}\n\nfloat SDFBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0)\n    );\n}\n\nfloat SDFBoxFrameGrid(vec3 p, vec3 b, float e, int gridSize) {\n    float minDist = 1e10;\n    for (int x = 0; x < gridSize; x++) {\n        for (int y = 0; y < gridSize; y++) {\n            for (int z = 0; z < gridSize; z++) {\n                int i = x + y * gridS + z * gridS * gridS;\n                vec3 boxPos = vec3(\n                    float(x) - (float(gridSize) / 2.0) + 0.5,\n                    float(y) - (float(gridSize) / 2.0) + 0.5,\n                    float(z) - (float(gridSize) / 2.0) + 0.5\n                );\n                if (grid[i] == 0) {\n                    float dist = SDFBoxFrame(p - boxPos, b, e);\n                    minDist = min(minDist, dist);\n                }\n                if (grid[i] == 1) {\n                    vec3 voxelPos = vec3(\n                        float(x) - (float(gridSize) / 2.0),\n                        float(y) - (float(gridSize) / 2.0),\n                        float(z) - (float(gridSize) / 2.0)\n                    );\n                    float dist = SDFSmokeBox(p, voxelPos, b / 2.0);\n                    minDist = min(minDist, dist);\n                }\n            }\n        }\n    }\n    return minDist;\n}\n\nfloat map(vec3 p) {\n    //float circle = SDFshpere(p, vec3(0., 0., 0.), 1.0);\n    float square = SDFSmokeBox(p, vec3(0.), vec3(1.0, 1.0, 1.0));\n\n    //float grid = SDFBoxFrameGrid(p, vec3(1.0), 0.005, gridS);\n    return square;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy; //This normalizes the canvas so that it ranges from 0-1 not from 0 to sizeX\n    uv = (uv - 0.5)*2.0;//Makes (0,0) the center of the screen\n    uv.x *= iResolution.x / iResolution.y;//Makes the image be the same no matter the aspect ratio\n    \n    float up = texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).x;\n    float down = texelFetch(iChannel0, ivec2(KEY_DOWN, 0), 0).x;\n    float keyW = texelFetch(iChannel0, ivec2(KEY_W, 0), 0).x;\n    float keyS = texelFetch(iChannel0, ivec2(KEY_S, 0), 0).x;\n    float zoom = 3.;\n    if(down > 0.) zoom*=2.;\n\n    if(up > 0.) zoom/=1.3;\n    \n    if(keyW > 0.) zoom/=1.3;\n    \n    if(keyS > 0.) zoom*=2.;\n\n    int pos = int(mod(iTime*10., float(gridS*gridS*gridS)));\n    grid[pos] = 1;\n    grid[pos-1] = 0;\n\n    \n    \n    vec3 rayOrigin = vec3(0,0,zoom);\n    vec3 lookPoint = vec3(0,0,0);//Looking at the center\n\n        \n\n    vec2 mouseUV = iMouse.xy/iResolution.xy;if (mouseUV == vec2(0.0)||iFrame<1) mouseUV = vec2(0.5);float cameraRadius = 1.;rayOrigin.yz = rayOrigin.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));rayOrigin.xz = rayOrigin.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lookPoint.x, lookPoint.z);\n    vec3 rayDir= camera(rayOrigin, lookPoint) * normalize(vec3(uv,-1));\n    \n    float totalDist = 0.; //Distance traveled by the ray\n    float d;\n    float d1;\n    vec3 col = vec3(0.);\n    float transmittance;\n      \n    for(int i=0; i < 80; i++){\n        //Raymarching\n        vec3 p = rayOrigin + rayDir * totalDist; // Computes the distance of the furthest point, the point starts at 0\n        d = map(p);\n        \n        totalDist+=d;\n        if(d>0.){\n            d1 += d;\n        }\n        if(totalDist > 500.) break;\n    }\n    transmittance = exp(-abs(d1)*0.4);\n    col = vec3(0.,1.*transmittance,(3./totalDist)*transmittance);\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}