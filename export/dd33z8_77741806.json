{"ver":"0.1","info":{"id":"dd33z8","date":"1676961743","viewed":266,"name":"sunShine","username":"iOSZzy","description":"sun,light,Illumination","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// reference https://www.shadertoy.com/view/slVXDW\n//           https://www.shadertoy.com/view/Xlc3D2\n#define USE_TEX 1\n\n#define time iTime\n\nconst float PI = 3.1415925358;\n\nfloat safety_sin( in float x ) { return sin( mod( x, PI ) ); }\n\nfloat saturate( in float x ) { return clamp( x, 0., 1. ); }\nvec3  saturate( in vec3  x ) { return clamp( x, 0., 1. ); }\n\nvec2 rotate( in vec2 p, float r )\n{\n\tfloat s = sin( r );\n\tfloat c = cos( r );\n\treturn mat2( c, -s, s, c ) * p;\n}\n\n\nfloat noise( in vec2 x )\n{\n\n    float tex_size = 128.0;\n    float n = texture( iChannel0, x / tex_size ).x;\n    n = saturate( pow( n, 1.5 ) * 1.2 );// modified color\n    return n;\n\n}\n\nfloat noise( in vec2 x, in float t )\n{\n\n    vec4 seed = vec4( 12.3456, 2.3456, 3.4567, 45.6789 );\n    vec2 t2 = mod( vec2( t ) * vec2( 0.05, 30.0 ), 2.0*PI );\n    t2.x = sin( t2.x );\n    float n0 = noise( x + seed.xy - t2.x );\n    float n1 = noise( x + seed.zw + t2.x );\n    float w  = sin( noise( x ) * 2.0*PI + t2.y ) * 0.5 + 0.5;\n    float n  = mix( n0, n1, w );\n    return n;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat star_burst( in vec2 p, in vec2 center )\n{\n    float c0 = 0.5;\n    float c1 = 2.0;\n    float c2 = 6.0;\n    float c3 = 12.0;\n    float c4 = 2.0;\n    float c5 = 6.2;\n    float c6 = 4.0;\n    float c7 = 0.1;\n    float c8 = 6.2;\n    float t  = dot( center, vec2( 0.25 ) );\n    float l  = length( p );\n    float l2 = pow( l, c0 );\n    float n0 = noise( vec2( atan(  p.y,  p.x ) * c1, l2 ) * c2, t );\n    float n1 = noise( vec2( atan( -p.y, -p.x ) * c1, l2 ) * c2, t );\n    float n  = pow( max( n0, n1 ), c3 ) * pow( saturate( 1.0 - l * c4 ), c5 );\n    n += pow( saturate( 1.0 - ( l * c6 - c7 ) ), c8 );// glare\n    return n;\n}\n\n\nfloat halo( in vec2 p, in vec2 center, in float r, in float offset )\n{\n    float c0 = 0.5;\n    float c1 = 32.0;\n    float c2 = 12.0;\n    float c3 = 2.0;\n    float c4 = 1.0;// 1.0 == blur\n    float c5 = 4.0;// 0.0 == like glare\n    float c6 = 1.2;\n    float c7 = 0.5;\n    float c8 = 1.5;\n    float c9 = 0.25;\n\n    float t  = dot( center, vec2( c9 ) );\n    float l  = length( p );\n    float l1 = abs( l - r );\n    float l2 = pow( l, c0 );\n    float n0 = noise( vec2( atan(  p.y,  p.x ) * c1, l2 ) * c2, t );\n    float n1 = noise( vec2( atan( -p.y, -p.x ) * c1, l2 ) * c2, t );\n    float n  = mix( pow( max( n0, n1 ), c3 ), 1.0, c4 ) * pow( saturate( 1.0 - l1 * c5 ), c6 );\n    return n * 0.2 * saturate( pow(\n        saturate( pow( length( center ), c7 ) ),\n        ( length( p - center ) / r ) * c8\n    ) );\n}\n\nvec3 ghost3( in vec2 p, in vec2 center, float focus, in float r, in float offset )\n{\n    float shape_factor = 0.7;   // 0.0 == Circular aperture(like digital camera)\n                                // 1.0 == Six blades aperture(like old camera)\n    p -= center * offset;\n    vec2 p2 = rotate( p, 0.25 );\n    float d0 = mix( sdCircle( p2 * 0.85, r ), sdHexagon( p2 * 0.85, r ), shape_factor );\n    float d1 = mix( sdCircle( p2,        r ), sdHexagon( p2,        r ), shape_factor );\n    float d2 = mix( sdCircle( p2 * 1.15, r ), sdHexagon( p2 * 1.15, r ), shape_factor );\n    return mix(\n        vec3(\n            halo( p * 1.05, center, r, offset ),\n            halo( p * 1.0,  center, r, offset ),\n            halo( p * 0.95, center, r, offset )\n        ) * vec3( 2.0, 1.5, 1.0 )*2.,\n        pow( saturate( 1.0 - vec3( d0, d1, d2 ) ), vec3( 200. ) ),\n        focus\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord / iResolution.xy - 0.5;\n    p.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    // Light position\n    float t0 = mod( time * 1.5, 2.0*PI );\n    float t1 = mod( time * 0.4, 2.0*PI );\n    //vec2 center = vec2( cos( t0 ), sin( t0 ) ) * 0.4 * ( sin( t1 ) * 0.5 + 0.5 );\n    //if( iMouse.z >= .5 )\n\t//{\n        vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n        mouse.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\t\tvec2 center = mouse.xy;\n\t//}\n   \n    // Background\n    //vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    vec3 col = vec3(0.);\n    vec3 sun = mix(vec3(0.3, 0.2, 0.02)/0.9, vec3(0.2, 0.5, 0.8), p.y)*3.-0.52*sin(iTime);\n    vec3 circColor = vec3(0.9, 0.2, 0.1);\n    vec3 circColor2 = vec3(0.3, 0.1, 0.9);\n    float a = atan(p.y-center.y, p.x-center.x);\n    float l = max(1.0-length(p-center)-0.84, 0.0);\n    float bright = 0.1;//+0.1/abs(sin(iTime/3.))/3.;//add brightness based on how the sun moves so that it is brightest\n    //when it is lined up with the center\n    \n    //add the sun with the frill things\n    sun += max(0.1/pow(length(p-center)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n    sun += max(0.1/pow(length(p-center)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    sun += (max(bright/pow(length(p-center)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;\n       // * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));\n    \t\n    //multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that\n    //there is a sharper roll of of the light decay from the sun. \n     sun*= exp(1.0-length(p-center))/5.;\n    \n    // Flare( glare + star burst )\n\tcol += sun;\n    \n    // Ghost\n    //col += ghost3( p, center, 0.0,  1.5,   1.2  );// halo\n    col += ghost3( p, center, 0.0,  1.5,   1.2 ) ;// halo\n    col += ghost3( p, center, 0.3,  .105, 0.5 /1.5 ) * vec3( 0.5, 0.1, -0.05 );\n    col += ghost3( p, center, 0.3,  .11,  .8 ) * vec3( 0.1, 0.6, -0.05 );\n    col += ghost3( p, center, 0.3,  .11,  0.3 /1.5 ) * vec3( 0.05, -0.05, 0.45 );\n    col += ghost3( p, center, 0.2,  .13,  -0.8 /3.5 ) * vec3( 0.5, 0.1, -0.05 );\n    col += ghost3( p, center, 0.05, .11,  -1.2 /3.5 ) * vec3( 0.0, 0.5, -0.05 );\n    col += ghost3( p, center, 0.2,  .17,  -2.0 /3.5 ) * vec3( 0.05, -0.05, 0.45 );\n    col += ghost3( p, center, 0.25, .14,  -3.15/3.5 ) * vec3( 0.0, 0.4, 0.2 );\n    col += ghost3( p, center, 0.15, .185, -3.75/3.5 ) * vec3( 0.0, 0.2, 0.05 );\n    col += ghost3( p, center, 0.05, .16,  -4.5 /3.5 ) * vec3( 0.05, -0.05, 0.45 );\n    col += ghost3( p, center, 0.20, .13,  -5.75/3.5 ) * vec3( 0.0, 0.3,  0.5 );\n    col += ghost3( p, center, 0.08, .12,  -5.95/3.5 ) * vec3( 0.05, 0.2, 0.05 );\n    col += ghost3( p, center, 0.04, .11, -6.15/3.5 ) * vec3( 0.1, -0.05, 0.65 );\n\n    // Streak\n    // (nothing)\n    \n    // Lens dust\n    // (nothing)\n\n    // Output to screen\n  //  col = pow( col, vec3( 1.0 / 2.2 ) );\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}