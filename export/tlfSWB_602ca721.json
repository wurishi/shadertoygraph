{"ver":"0.1","info":{"id":"tlfSWB","date":"1564055649","viewed":332,"name":"amiga rubbervector","username":"cdyk","description":"'rubber vector' is an old-school amiga demo-effect was produced by using older frames the further down you were on the screen (easy with copper).  Here, I just increment the animation time using y-scanline, but the result is quite similar. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["amiga","rasterize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Rubber vector' is an old-school demo effect, which was produced by\n// keeping a tail of frames and displaying older frames the further down\n// on the screen.\n//\n// While experimenting with implementing triangle rasterization in ShaderToy,\n// I thought about this, and implemented it by adjusting time using the\n// Y-component of the screen space position.\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        x*x*(1.0-c) +   c, y*x*(1.0-c) + z*s, x*z*(1.0-c) - y*s, 0,\n        x*y*(1.0-c) - z*s, y*y*(1.0-c) +   c, y*z*(1.0-c) + x*s, 0,\n        y*z*(1.0-c) + y*s, y*z*(1.0-c) - x*s, z*z*(1.0-c) +   c, 0,\n        0,                                 0,                 0, 1\n\t);\n}\n\nmat4 translationMatrix(vec3 o)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0, \n        0, 0, 1, 0,\n        o.x, o.y, o.z, 1\n    );\n}\n    \n\nmat4 frustumMatrix(float l, float r, float b, float t, float n, float f)\n{\n    return mat4(\n        2.0*n/(r-l), 0, 0, 0,\n        0, 2.0*n/(t-b), 0, 0,\n        (r+l)/(r-l), (t+b)/(t-b), -(f+n)/(f-n), -1,\n        0, 0, -2.0*f*n/(f-n), 0\n    );\n}\n\n\nfloat cross2(vec2 a, vec2 b)\n{\n\treturn cross(vec3(a, 0), vec3(b, 0)).z;   \n}\n\nvoid rasterizeTriangle(inout float depth,\n                       inout vec3 normal,\n                       in vec4 a, in vec4 b, in vec4 c,\n                       in vec2 p,\n                       in vec3 n)\n{\n    vec2 ab = b.xy - a.xy;\n    vec2 bc = c.xy - b.xy;\n    vec2 ca = a.xy - c.xy;\n    \n    vec2 ap = p - a.xy;\n    vec2 bp = p - b.xy;\n    vec2 cp = p - c.xy;\n    \n    // Back-face culling\n    float area_abc = cross2(ab, bc);\n    if(area_abc <= 0.0) return;\n\n    // Point-in-triangle test\n    float area_abp = cross2(ab, bp);\n    float area_bcp = cross2(bc, cp);\n    float area_cap = cross2(ca, ap);\n    if(area_abc <= 0.0 || area_abp < 0.0 || area_bcp < 0.0 || area_cap < 0.0) return;\n    \n    // shape is convex and backface culled, so we don't need depth beyond flagging\n    // that it is not background.\n    depth = 0.0;\n    normal = n;\n}\n\nvec4 perspectiveDivide(vec4 h)\n{\n    return (1.0/h.w)*vec4(h.xyz, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord/iResolution.xy - vec2(1);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float t = iTime + sin(iTime)*uv.y;\n    \n    mat4 M =\n        rotationMatrix(vec3(0,0,1), 0.3*t) *\n        rotationMatrix(vec3(0,1,0), 0.7*t) *\n        rotationMatrix(vec3(0,0,1), 1.1*t);\n\n    float aspect = iResolution.x/iResolution.y;\n    mat4 P =\n        frustumMatrix(-0.2*aspect, 0.2*aspect,\n                      -0.2,  0.2,\n                       0.2, 30.0) *\n        translationMatrix(vec3(0,0,-2.5));\n        \n    \n    mat4 PM = P * M;\n    \n    vec4 c000 = perspectiveDivide(PM*vec4(-1,-1, -1, 1));\n    vec4 c100 = perspectiveDivide(PM*vec4( 1,-1, -1, 1));\n    vec4 c010 = perspectiveDivide(PM*vec4(-1, 1, -1, 1));\n    vec4 c110 = perspectiveDivide(PM*vec4( 1, 1, -1, 1));\n    vec4 c001 = perspectiveDivide(PM*vec4(-1,-1,  1, 1));\n    vec4 c101 = perspectiveDivide(PM*vec4( 1,-1,  1, 1));\n    vec4 c011 = perspectiveDivide(PM*vec4(-1, 1,  1, 1));\n    vec4 c111 = perspectiveDivide(PM*vec4( 1, 1,  1, 1));\n\n    vec3 n_x = mat3(M)*vec3(1,0,0);\n    vec3 n_y = mat3(M)*vec3(0,1,0);\n    vec3 n_z = mat3(M)*vec3(0,0,1);\n    \n    vec3 normal = vec3(0,0,0);\n\tfloat depth = 200.0;\n    \n    rasterizeTriangle(depth, normal, c100, c000, c110, uv, -n_z);\n    rasterizeTriangle(depth, normal, c110, c000, c010, uv, -n_z);\n    rasterizeTriangle(depth, normal, c001, c101, c111, uv, n_z);\n    rasterizeTriangle(depth, normal, c001, c111, c011, uv, n_z);\n        \n    rasterizeTriangle(depth, normal, c000, c100, c001, uv, -n_y);\n    rasterizeTriangle(depth, normal, c100, c101, c001, uv, -n_y);\n    rasterizeTriangle(depth, normal, c110, c010, c011, uv, n_y);\n    rasterizeTriangle(depth, normal, c111, c110, c011, uv, n_y);\n\n    rasterizeTriangle(depth, normal, c010, c000, c011, uv, -n_x);\n    rasterizeTriangle(depth, normal, c011, c000, c001, uv, -n_x);\n    rasterizeTriangle(depth, normal, c100, c110, c111, uv, n_x);\n    rasterizeTriangle(depth, normal, c100, c111, c101, uv, n_x);\n\n        \n    \n    // Output to screen\n    fragColor = vec4(depth == 0.0 ? normal : vec3(0),1.0);\n}","name":"Image","description":"","type":"image"}]}