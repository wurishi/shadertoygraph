{"ver":"0.1","info":{"id":"Ns2yDD","date":"1643824577","viewed":227,"name":"approximate_dof","username":"shinraigo","description":"A very simple dof sample with BRDF lighting","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["dof"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//===============================================\n// A very simple sample of brdf and dof\n// Drag mouse Up&Down to control focus distance\n// Enable Simple ver. by enable SIMPLE_MODE define in Common\n//===============================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; //TODO: add AA\n    \n#ifdef SIMPLE_MODE\n    // dof using one blur pic\n    vec4 originalColor = texture( iChannel0, uv );    \n    vec4 blurredColor =  texture( iChannel2, uv );\n#ifdef USE_DEPTH\n    float focusDistance = GetFocusDistance(iMouse.y / iResolution.y);\n    float CoC = clamp(ApertureDiameter * ( originalColor.a - focusDistance) / FocalDistance, -ApertureDiameter, ApertureDiameter);\n#else\n    float CoC = originalColor.a;\n#endif\n    vec3 result = mix(originalColor.xyz, blurredColor.xyz, abs(CoC) / ApertureDiameter);    \n#else\n    // dof based on approximated circle of confusion\n    vec3 result = texture( iChannel2, uv ).xyz;    \n#endif\n\n    fragColor = vec4(sqrt(result.xyz), 1.0f); //linear->srgb\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//===============================================\n// A very simple sample of brdf and dof\n// Drag mouse Up&Down to control focus distance\n// Enable Simple ver. by enable SIMPLE_MODE define in Common\n// Disable Simple ver to get a more specific result\n//===============================================\n//#define SIMPLE_MODE         // using one blurd result to approximate fast result\n#define ENALBE_FRONT_BLUR   //make the edge of object at front to be soft and natural\n#define USE_DEPTH           //with more soft edge\n\n#define PI 3.1415926f\n\n#define NonMetallicF0 vec3(0.04f)\n\n#define ApertureDiameter 0.02f /*-->F */\n#define FocalDistance 2.0f\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Ray\n{\n    vec3 startPos;\n    vec3 dir;\n    float rayLength;\n    int hitId;\n};\n\nstruct Sphere\n{\n    vec3 centerPos;\n    float radius;\n};\n\nstruct Material\n{\n    vec2 uv;\n    vec3 normal;\n    vec3 baseColor;\n    float roughness;\n    float metallic;\n    bool isFar;\n};\n\nstruct DirDotsSet\n{\n    float NdotH;\n    float LdotH;\n    float VdotH;\n    float NdotV;\n    float NdotL;\n};\n\nstruct LightingResult\n{\n    vec3 direct;\n    vec3 indirect;\n};\n\n#define CenterPos_Sphere1 vec3(0.0f, 0.0f, 0.0f)\n#define Radius_Sphere1 1.0f\n#define CenterPos_Sphere2 vec3(0.0f, 0.0f, 3.0f)\n#define Radius_Sphere2 1.0f\n#define CenterPos_Sphere3 vec3(0.0f, 0.0f, 6.0f)\n#define Radius_Sphere3 1.0f\n#define CenterPos_Sphere4 vec3(0.0f, 0.0f, 9.0f)\n#define Radius_Sphere4 1.0f\n#define GroundHeight -1.0f\nSphere sphere1 = Sphere(CenterPos_Sphere1, Radius_Sphere1);\nSphere sphere2 = Sphere(CenterPos_Sphere2, Radius_Sphere2);\nSphere sphere3 = Sphere(CenterPos_Sphere3, Radius_Sphere3);\nSphere sphere4 = Sphere(CenterPos_Sphere4, Radius_Sphere4);\n\n//================================================\nbool IsRayHitSphere(Sphere sphere, Ray ray)\n{\n    vec3 toCenterDir = sphere.centerPos - ray.startPos;\n    float dToCenterSq = dot(toCenterDir, toCenterDir);\n    float cosTheta = dot(toCenterDir, ray.dir);\n    if(cosTheta < 0.0f)\n        return false;\n    float perpendicularSq = dToCenterSq - cosTheta * cosTheta;\n    if(perpendicularSq <= sphere.radius * sphere.radius)\n        return true;\n    else\n        return false;\n}\n\nfloat GetRayDistanceToSphere(Sphere sphere, Ray ray)\n{\n    //get pos directly, faster than ray march\n    vec3 toCenterDir = sphere.centerPos - ray.startPos;\n    float dToCenterSq = dot(toCenterDir, toCenterDir);\n    float cosTheta = dot(toCenterDir, ray.dir);\n    float perpendicularSq = dToCenterSq - cosTheta * cosTheta;\n    float rayLength = sqrt(dToCenterSq - perpendicularSq) - sqrt(sphere.radius * sphere.radius - perpendicularSq);\n    return rayLength;\n}\n\nfloat GetPerpendicularSqToSphere(Sphere sphere, Ray ray)\n{\n    vec3 toCenterDir = sphere.centerPos - ray.startPos;\n    float dToCenterSq = dot(toCenterDir, toCenterDir);\n    float cosTheta = dot(toCenterDir, ray.dir);\n    float perpendicularSq = dToCenterSq - cosTheta * cosTheta;    \n    return perpendicularSq;\n}\n\nbool IsRayHitPlane(float height, Ray ray)\n{\n    float cosTheta = dot(vec3(0.0f, -1.0f, 0.0f), ray.dir);\n    if(cosTheta > 0.0f)\n        return true;\n    else\n        return false;\n}\n\nfloat GetRayDistanceToPlane(float height, Ray ray)\n{\n    float cosTheta = dot(vec3(0.0f, -1.0f, 0.0f), ray.dir);\n    float dist = (ray.startPos.y - height) / max(cosTheta, 1e-8f);\n    return dist;\n}\n\nSphere CreateSphere(vec3 centerPos, float radius)\n{\n    Sphere object;\n    object.centerPos = centerPos;\n    object.radius = radius;\n    return object;\n}\n\nRay CreateRay(vec3 rayStartPos, vec3 rayDir)\n{\n    Ray ray;\n    ray.startPos = rayStartPos;\n    ray.dir = rayDir;\n    ray.rayLength = 99.0f;\n    ray.hitId = -1;\n    return ray;\n}\n\n//=============================================\nfloat saturate(float v)\n{\n    return clamp(v, 0.0f, 1.0f);\n}\n\nvec3 saturate(vec3 v)\n{\n    return vec3(saturate(v.x),saturate(v.y),saturate(v.z));\n}\n\nfloat rcp(float v)\n{\n    return 1.0f / v;\n}\nfloat remap(float v, float oldMin, float oldMax, float newMin, float newMax)\n{\n    return (v - oldMin) / (oldMax - oldMin) * (newMax - newMin) + newMin;\n}\n\n\n//=========================================================\nDirDotsSet CalDots( vec3 normal, vec3 viewDir, vec3 lightDir)\n{\n    vec3 halfDir = normalize(lightDir + viewDir);\n    DirDotsSet result;\n    result.NdotH = saturate(dot(normal, halfDir));\n    result.LdotH = saturate(dot(lightDir, halfDir));\n    result.VdotH = saturate(dot(viewDir, halfDir));\n    result.NdotV = abs(dot(normal, viewDir)) + 1e-5f;\n    result.NdotL = saturate(dot(normal, lightDir));\n    return result;\n}\n\nvec3 FresnelSpecular(vec3 f0Color, float VdotH)\n{\n    //Schlick\n    return f0Color + (1.0f - f0Color) * pow(1.0f - VdotH, 5.0f);\n}\n\n#if 0\nvec3 FresnelDiffuse(vec3 f0Color, float NdotL)\n{\n    //Schlick's approximation\n    return f0Color + (1.0f - f0Color) * pow(1.0f - NdotL, 5.0f);\n}\n#endif\n\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 f0Color, float roughness)\n{\n    //attention!!\n    return f0Color + (max(vec3(1.0 - roughness), f0Color) - f0Color) * pow(1.0 - cosTheta, 5.0);\n}  \n\nvec3 FresnelLerp(vec3 f0Color, vec3 albedo, float NdotV)\n{\n    return mix(f0Color, albedo, pow(1.0f - NdotV, 5.0f));\n}\n\n\nfloat SmithGGXCorrelated(float alpha, float NdotL, float NdotV)\n{\n    float alphaSq = alpha * alpha;\n    float NdotLSq = NdotL * NdotL;\n    float NdotVSq = NdotV * NdotV;\n    float GGXV = NdotL * sqrt(NdotV * (1.0f - alphaSq) * NdotV + alphaSq);\n    float GGXL = NdotV * sqrt(NdotL * (1.0f - alphaSq) * NdotL + alphaSq);    \n    return 0.5f / (GGXV + GGXL);    \n}\n\nfloat DistributionGGX(float alpha, float NdotH)\n{\n    float alphaSq = alpha * alpha;\n    float t = (NdotH * alphaSq - NdotH) * NdotH + 1.0f;\n    return alphaSq * rcp(PI * t * t);\n}\n\nvec3 SpecularBRDF(vec3 f0Color, float roughness, DirDotsSet dots)\n{\n    float alpha = max(roughness * roughness, 1e-3f);\n    vec3 F = FresnelSpecular(f0Color, dots.LdotH);\n    float G = SmithGGXCorrelated(alpha, dots.NdotL, dots.NdotV);\n    //float Vis = G / max(4.0f * dots.NdotL * dots.NdotV, 1e-5f);\n    float D = DistributionGGX(alpha, dots.NdotH);\n    \n    return F * G * D;\n}\n\n\nvec3 LambertDiffuse(vec3 baseColor, float NdotL)\n{\n    return baseColor * NdotL / PI;\n}\n\n\n//=========================================================\n#define CloseClip 1.0f\n#define LookAtPosition vec3(0.0f, 0.0f, 1.5f)\nCamera CreateCamera(const vec2 fragCoord, const vec2 iResolution, float t)\n{\n    vec2 uv = fragCoord/iResolution;\n    vec2 screenPosition = uv - 0.5f;\n    screenPosition.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraOffset = vec3(cos(t * 0.5f), 0.0f, sin(t * 0.5f));\n    vec3 cameraPos = vec3(  3.0f, 0.0f , -2.5f ) + cameraOffset;\n    vec3 lookAt = LookAtPosition;\n    \n    vec3 forwardV = normalize(lookAt - cameraPos);\n    vec3 rightV = cross(vec3(0.0f, 1.0f, 0.0f ), forwardV);\n    vec3 cameraUpV = cross(forwardV, rightV);\n   \n    vec3 centerOfScreen = cameraPos + forwardV * CloseClip;\n    vec3 intersectionPoint = centerOfScreen + screenPosition.x * rightV + screenPosition.y * cameraUpV;\n    vec3 cameraDir = intersectionPoint - cameraPos;\n\n    Camera result;\n    result.pos = cameraPos;\n    result.dir = normalize(cameraDir);\n    return result;\n}\n\n\n//=========================================================\nvec3 GetDirectionalLightDirection(float t)\n{\n    return normalize(vec3(cos(t ) * 0.5f, -1.0f, sin(t ) * 0.5f));\n}\n\n\n//=========================================================\nfloat GetBoxKernel()\n{\n    return 1.0f;\n}\n\nfloat GetGaussianKernel(float idx, float sigma)\n{\n    return 1.0f; // just use box\n    //return ( 1.0f / (sigma * sqrt(2.0f * PI)) * exp(- idx * idx * 0.5f / (sigma * sigma)));\n}\n\nfloat GetFocusDistance(float inputV)\n{\n    return 2.0f + inputV * 8.0f;\n}\n\nfloat GetCoC(float focusDistance, float rayLength)\n{\n    return clamp(ApertureDiameter * ( rayLength - focusDistance) / FocalDistance, -ApertureDiameter, ApertureDiameter);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAY_HIT_GROUND 0\n#define RAY_HIT_SPHERE_1 1\n#define RAY_HIT_SPHERE_2 2\n#define RAY_HIT_SPHERE_3 3\n#define RAY_HIT_SPHERE_4 4\n\nvoid DetectRayHitResult(inout Ray ray)\n{\n    //get pos directly, faster than ray march\n    if(IsRayHitSphere(sphere1, ray))\n    {\n        float distanceToSphere = GetRayDistanceToSphere(sphere1, ray);\n        if(distanceToSphere < ray.rayLength)\n        {\n            ray.rayLength = distanceToSphere;\n            ray.hitId = RAY_HIT_SPHERE_1;\n        }\n    }\n\n    if(IsRayHitSphere(sphere2, ray))\n    {\n        float distanceToSphere = GetRayDistanceToSphere(sphere2, ray);\n        if(distanceToSphere < ray.rayLength)\n        {\n            ray.rayLength = distanceToSphere;\n            ray.hitId = RAY_HIT_SPHERE_2;\n        }\n    }\n\n    if(IsRayHitSphere(sphere3, ray))\n    {\n        float distanceToSphere = GetRayDistanceToSphere(sphere3, ray);\n        if(distanceToSphere < ray.rayLength)\n        {\n            ray.rayLength = distanceToSphere;\n            ray.hitId = RAY_HIT_SPHERE_3;\n        }\n    }\n    \n    if(IsRayHitSphere(sphere4, ray))\n    {\n        float distanceToSphere = GetRayDistanceToSphere(sphere4, ray);\n        if(distanceToSphere < ray.rayLength)\n        {\n            ray.rayLength = distanceToSphere;\n            ray.hitId = RAY_HIT_SPHERE_4;\n        }\n    }\n\n    \n    if(IsRayHitPlane(GroundHeight, ray))\n    {\n        float distanceToPlane = GetRayDistanceToPlane(GroundHeight, ray);\n        if(distanceToPlane < ray.rayLength)\n        {\n            ray.rayLength = distanceToPlane;\n            ray.hitId = RAY_HIT_GROUND;\n        }\n    }\n}\n\n\nMaterial CalculateMaterialForSphere(in vec3 pos, Sphere obj)\n{\n    vec3 dirToCenter = normalize(obj.centerPos - pos);\n    Material material;\n    material.uv.y = 1.0f - fract(0.5f + (atan(dirToCenter.x, dirToCenter.z) / PI));\n    material.uv.x = 1.0f - fract(0.5f - (asin(dirToCenter.y) / PI));\n    material.normal = -dirToCenter;\n    vec4 baseColor = texture( iChannel1, material.uv );\n    material.baseColor = (baseColor * baseColor).xyz; // srgb->linear\n    material.roughness = material.baseColor.x;\n    material.metallic = 0.0f;\n    return material;\n}\n\nMaterial CalculateMaterialForPlane(in vec3 pos)\n{\n    Material material;\n    material.normal = vec3(0.0f, 1.0f, 0.0f);\n    material.uv = vec2(fract(pos.x * 0.2f), fract(pos.z * 0.2f));\n    vec4 baseColor = texture( iChannel0, material.uv );\n    material.baseColor = (baseColor * baseColor).xyz; // srgb->linear\n    material.roughness = material.baseColor.z;\n    material.metallic = 0.0f;\n    return material;\n}\n\nMaterial GetMaterialResult(in Ray ray, in Camera camera)\n{\n    vec3 currPos = ray.rayLength * camera.dir + camera.pos;\n    \n    Material result;\n    switch(ray.hitId)\n    {\n    case RAY_HIT_GROUND:\n    result = CalculateMaterialForPlane(currPos);\n    break;\n    case RAY_HIT_SPHERE_1:\n    result = CalculateMaterialForSphere(currPos, CreateSphere(CenterPos_Sphere1, Radius_Sphere1));\n    result.roughness = saturate(result.roughness * 1.2f);\n    break;\n    case RAY_HIT_SPHERE_2:\n    result = CalculateMaterialForSphere(currPos, CreateSphere(CenterPos_Sphere2, Radius_Sphere2));\n    result.baseColor = vec3(0.7f, 0.6f, 0.5f);\n    result.metallic = 1.0f;\n    break;\n    case RAY_HIT_SPHERE_3:\n    result = CalculateMaterialForSphere(currPos, CreateSphere(CenterPos_Sphere3, Radius_Sphere3));\n    break;\n    case RAY_HIT_SPHERE_4:\n    result = CalculateMaterialForSphere(currPos, CreateSphere(CenterPos_Sphere4, Radius_Sphere4));\n    result.baseColor = vec3(0.7f, 0.6f, 0.5f);\n    break;\n    default:\n    result.isFar = true;\n    }\n    return result;\n}\n\nfloat ApproximateSoftShadow(Sphere sphere, Ray ray)\n{\n    // check the perpendicular distance for ray to center of the sphere it hit\n    // to fake a soft edge for shadow\n    float perpendSq = GetPerpendicularSqToSphere(sphere, ray);\n    float edgeAspect = smoothstep(0.8, 1.0f, perpendSq / (sphere.radius * sphere.radius));\n    return edgeAspect;\n}\n\nfloat CalculateShadow(in vec3 pos)\n{\n    vec3 dirToLight = -GetDirectionalLightDirection(iTime);\n    Ray ray = CreateRay(pos, normalize(dirToLight)); \n    float shadow = 1.0f;\n    \n    //check if ray from pos to light will hit something\n    if(IsRayHitSphere(sphere1, ray))\n        shadow *= ApproximateSoftShadow(sphere1, ray);        \n    if(IsRayHitSphere(sphere2, ray))\n        shadow *= ApproximateSoftShadow(sphere2, ray);\n    if(IsRayHitSphere(sphere3, ray))\n        shadow *= ApproximateSoftShadow(sphere3, ray);\n    if(IsRayHitSphere(sphere4, ray))\n        shadow *= ApproximateSoftShadow(sphere4, ray);\n    return shadow;\n}\n\n\nfloat CalculateApproximateAO(in Ray ray, in Material mat, in Camera cam)\n{\n    // one bounce along normal as a fake AO\n    vec3 pos = ray.rayLength * cam.dir + cam.pos;    \n    Ray rayNext = CreateRay(pos + 0.1f * mat.normal, mat.normal);\n    DetectRayHitResult(rayNext);\n    return saturate(remap(rayNext.rayLength, 0.0f, 0.9f, 0.0f, 1.0f));\n}\n\n\nvec3 GetDirectionalLightIntensity()\n{\n    // to keep get a natural result, use ibl's color as directional light\n    vec3 iblIntensity = texture(iChannel3, vec3(0.0f, 1.0f, 0.0f)).xyz;\n    return iblIntensity * iblIntensity * 2.0f;\n}\n\n\n//Direct Lighting\nvec3 CalDirectLight(in Ray ray, in Material mat, in DirDotsSet dots)\n{\n    vec3 f0 = mix(NonMetallicF0, mat.baseColor, mat.metallic);\n    vec3 diffuseColor = (1.0f - mat.metallic) * mat.baseColor;\n\n    vec3 directResult = vec3(0.0f);\n    directResult += LambertDiffuse( diffuseColor, dots.NdotL);\n    directResult += SpecularBRDF(f0, mat.roughness, dots);\n    directResult *= GetDirectionalLightIntensity();\n    return directResult;\n}\n\n\n//Indirect Lighting\nvec3 EnvSpecular(const in Material mat, const in Ray ray, const in DirDotsSet dots)\n{\n    //https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?sessionInvalidated=true\n    vec3 sampleDir = reflect(ray.dir,mat.normal);\n    float percetualRoughness = mat.roughness * (1.7f - 0.7f * mat.roughness);\n    float Mip = percetualRoughness * 6.0f; // 6Layer MIPMAP CUBMAP\n\n    vec3 iblSpecular = textureLod(iChannel3, sampleDir, Mip).rgb;\n    iblSpecular = iblSpecular * iblSpecular; //srgb -> linear\n    \n    vec3 f0Color = mix(NonMetallicF0, mat.baseColor, mat.metallic);\n\n\tvec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tvec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = mat.roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * dots.NdotV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn (f0Color * vec3(AB.x) + vec3(AB.y)) * iblSpecular;\n}\n\nvec3 EnvDiffuse(const in Material mat, const in Ray ray, const in DirDotsSet dots)\n{\n    //Unity's method with faked sh result\n    vec3 sampleDir = reflect(ray.dir,mat.normal);\n    float percetualRoughness = mat.roughness * (1.7f - 0.7f * mat.roughness);\n    float Mip = percetualRoughness * 6.0f; // 6Layer MIPMAP CUBMAP\n    vec3 iblDiffuse = textureLod(iChannel2, sampleDir, 6.0f).rgb; //-> 6.0f is approximate\n    iblDiffuse = iblDiffuse * iblDiffuse;\n    \n    vec3 f0Color = mix(NonMetallicF0, mat.baseColor, mat.metallic);\n    vec3 fresnelRoughness = FresnelSchlickRoughness(dots.NdotV, f0Color, mat.roughness); //https://seblagarde.wordpress.com/2011/08/17/hello-world/\n    vec3 OneMinusReflectivityFromMetallic = ( 1.0f - fresnelRoughness) * (1.0f - mat.metallic);\n\n    return iblDiffuse * OneMinusReflectivityFromMetallic * mat.baseColor;\n}\n\nvec3 CalIndirectLight(in Material mat, in Ray ray, DirDotsSet dots)\n{\n    vec3 indirectResult = vec3(0.0f);\n    indirectResult += EnvSpecular( mat, ray, dots);\n    indirectResult += EnvDiffuse( mat, ray, dots);\n    return indirectResult;\n}\n\n\nLightingResult Lighting(in Ray ray, in Material mat)\n{\n    DirDotsSet dots = CalDots(normalize(mat.normal), -normalize(ray.dir), -GetDirectionalLightDirection(iTime));\n    LightingResult resultL;\n    resultL.direct = CalDirectLight(ray, mat, dots);\n    resultL.indirect = CalIndirectLight(mat, ray, dots);\n    return resultL;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera camera = CreateCamera(fragCoord, iResolution.xy, iTime);    \n    Ray ray = CreateRay(camera.pos, camera.dir); \n    \n    DetectRayHitResult(ray);\n    \n\tvec3 bgColor = texture(iChannel3, camera.dir).xyz;\n    vec3 resultColor = bgColor * bgColor;    \n\n    Material material = GetMaterialResult(ray, camera);\n    if(!material.isFar)\n    {\n        float shadow = CalculateShadow(ray.rayLength * camera.dir + camera.pos);  //directional light shadow\n        float ao = CalculateApproximateAO(ray, material, camera);\n        LightingResult resultL = Lighting(ray, material);\n        resultColor = resultL.direct * shadow + resultL.indirect * ao;\n\n    }\n    \n#ifdef USE_DEPTH\n    fragColor = vec4(resultColor, ray.rayLength);  \n#else\n    float CoC = GetCoC(GetFocusDistance(iMouse.y / iResolution.y), ray.rayLength);\n    fragColor = vec4(resultColor, CoC);  \n#endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//first blur pass, col\nvoid UniformBlurCol(in int range, in vec2 screenPos, inout vec4 color)\n{\n    float w = 0.0f;\n    \n    for(int i = 1; i < range; i++)\n    {\n        float blurW = GetBoxKernel();\n        vec2 offsetPos = screenPos + vec2(i) * vec2(0.0f, 1.0f);\n        color += texelFetch(iChannel0, ivec2(offsetPos), 0) * blurW;\n\n        offsetPos = screenPos + vec2(i) * vec2(0.0f, -1.0f);\n        color += texelFetch(iChannel0, ivec2(offsetPos), 0) * blurW;\n        w += blurW * 2.0f;\n    }\n    color /= vec4(w + 1.0f);\n}\n\n\nvoid AccumulateColorUseCoC(in int idx, in vec2 dir, in vec2 uv, in float blurW, in float sampleStep, in float CoC, inout float totalWeight, inout vec4 color)\n{\n    vec2 uvOffset = uv + float(idx) * sampleStep * dir;\n    vec4 tempColor = texture(iChannel0, uvOffset);\n    //add approx bilaterial to detect edge\n#ifdef ENALBE_FRONT_BLUR\n    float bilaterialW = CoC > tempColor.a ? 1.0f : saturate(1.0f - abs(CoC - tempColor.a) / ApertureDiameter);\n#else\n    float bilaterialW = saturate(1.0f - abs(CoC - tempColor.a) / ApertureDiameter);\n#endif\n    color += tempColor * blurW * bilaterialW;\n    totalWeight += blurW * bilaterialW;\n}\n\n\nvoid AccumulateColorUseDepth(in int idx, in vec2 dir, in vec2 uv, in float blurW, in float sampleStep, in float rayLength, inout float totalWeight, inout vec4 color)\n{\n    vec2 uvOffset = uv + float(idx) * sampleStep * dir;\n    vec4 tempColor = texture(iChannel0, uvOffset);\n    //add approx bilaterial to detect edge\n#ifdef ENALBE_FRONT_BLUR\n    float bilaterialW = rayLength < tempColor.a ?\n    1.0f :\n    saturate(1.0f - abs(rayLength - tempColor.a) / 99.0f);\n#else\n    float bilaterialW = saturate(1.0f - abs(rayLength - tempColor.a) / 99.0f);\n#endif\n    color += tempColor * blurW * bilaterialW;\n    totalWeight += blurW * bilaterialW;\n}\n\n\n#ifdef USE_DEPTH\nvoid DofBlurCol(vec2 resolution, vec2 uv, float CoC, float rayLength, inout vec4 color)\n#else\nvoid DofBlurCol(vec2 resolution, vec2 uv, float CoC, inout vec4 color)\n#endif\n{\n    int pixelRange = int(( abs(CoC) * resolution.x) / 2.0f); //TODO: change to circle sampling\n    float sampleStep = 1.0f / resolution.x;\n    float w = 0.0f;\n    for(int i = 1; i < pixelRange; i++)\n    {\n        float blurW = GetBoxKernel();\n#ifdef USE_DEPTH\n        AccumulateColorUseDepth(i, vec2(0.0f, 1.0f), uv, blurW, sampleStep, rayLength, w, color);\n        AccumulateColorUseDepth(i, vec2(0.0f, -1.0f), uv, blurW, sampleStep, rayLength, w, color);\n#else\n        AccumulateColorUseCoC(i, vec2(0.0f, 1.0f), uv, blurW, sampleStep, CoC, w, color);\n        AccumulateColorUseCoC(i, vec2(0.0f, -1.0f), uv, blurW, sampleStep, CoC, w, color);\n#endif\n    }\n    color /= vec4(w + 1.0f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel0, uv);    \n#ifdef USE_DEPTH\n    float rayLength = color.a;\n    float focusDistance = GetFocusDistance(iMouse.y / iResolution.y);\n    float CoC = GetCoC(focusDistance, rayLength);\n#else\n    float CoC = color.a;\n#endif    \n    \n#ifdef SIMPLE_MODE\n    UniformBlurCol( int(ApertureDiameter * iResolution.y) / 2, fragCoord.xy, color);\n\n#else\n#ifdef USE_DEPTH\n    DofBlurCol(iResolution.xy, uv, CoC, rayLength, color);\n#else\n    DofBlurCol(iResolution.xy, uv, CoC, color);\n#endif\n#endif\n\n    fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//second blur pass, row\nvoid UniformBlurCol(in int range, in vec2 screenPos, inout vec4 color)\n{\n    float w = 0.0f;\n    \n    for(int i = 1; i < range / 2; i++)\n    {\n        float blurW = GetBoxKernel();\n        vec2 offsetPos = screenPos + vec2(i) * vec2(1.0f, 0.0f);\n        color += texelFetch(iChannel0, ivec2(offsetPos), 0) * blurW;\n\n        offsetPos = screenPos + vec2(i) * vec2(-1.0f, 0.0f);\n        color += texelFetch(iChannel0, ivec2(offsetPos), 0) * blurW;\n        w += blurW * 2.0f;\n    }\n    color /= vec4(w + 1.0f);\n}\n\n\nvoid AccumulateColorUseCoC(in int idx, in vec2 dir, in vec2 uv, in float blurW, in float sampleStep, in float CoC, inout float totalWeight, inout vec4 color)\n{\n    vec2 uvOffset = uv + float(idx) * sampleStep * dir;\n    vec4 tempColor = texture(iChannel0, uvOffset);\n    //add approx bilaterial to detect edge\n#ifdef ENALBE_FRONT_BLUR\n    float bilaterialW = CoC > tempColor.a ? 1.0f : saturate(1.0f - abs(CoC - tempColor.a) / ApertureDiameter);\n#else\n    float bilaterialW = saturate(1.0f - abs(CoC - tempColor.a) / ApertureDiameter);\n#endif\n    color += tempColor * blurW * bilaterialW;\n    totalWeight += blurW * bilaterialW;\n}\n\n\nvoid AccumulateColorUseDepth(in int idx, in vec2 dir, in vec2 uv, in float blurW, in float sampleStep, in float rayLength, inout float totalWeight, inout vec4 color)\n{\n    vec2 uvOffset = uv + float(idx) * sampleStep * dir;\n    vec4 tempColor = texture(iChannel0, uvOffset);\n    //add approx bilaterial to detect edge\n#ifdef ENALBE_FRONT_BLUR\n    float bilaterialW = rayLength < tempColor.a ?\n    1.0f :\n    saturate(1.0f - abs(rayLength - tempColor.a) / 99.0f);\n#else\n    float bilaterialW = saturate(1.0f - abs(rayLength - tempColor.a) / 99.0f);\n#endif\n    color += tempColor * blurW * bilaterialW;\n    totalWeight += blurW * bilaterialW;\n}\n\n\n#ifdef USE_DEPTH\nvoid DofBlurRow(vec2 resolution, vec2 uv, float CoC, float rayLength, inout vec4 color)\n#else\nvoid DofBlurRow(vec2 resolution, vec2 uv, float CoC, inout vec4 color)\n#endif\n{\n    int pixelRange = int(( abs(CoC) * resolution.y) / 2.0f); //TODO: change to circle sampling\n    float sampleStep = 1.0f / resolution.y;\n    float w = 0.0f;\n    for(int i = 1; i < pixelRange; i++)\n    {\n        float blurW = GetBoxKernel();        \n#ifdef USE_DEPTH\n        AccumulateColorUseDepth(i, vec2(1.0f, 0.0f), uv, blurW, sampleStep, rayLength, w, color);\n        AccumulateColorUseDepth(i, vec2(-1.0f, 0.0f), uv, blurW, sampleStep, rayLength, w, color);\n#else\n        AccumulateColorUseCoC(i, vec2(1.0f, 0.0f), uv, blurW, sampleStep, CoC, w, color);\n        AccumulateColorUseCoC(i, vec2(-1.0f, 0.0f), uv, blurW, sampleStep, CoC, w, color);\n#endif\n    }\n    color /= vec4(w + 1.0f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n \n    vec4 color = texture(iChannel0, uv);\n#ifdef USE_DEPTH\n    float rayLength = texture(iChannel0, uv).a;\n    float focusDistance = GetFocusDistance(iMouse.y / iResolution.y);\n    float CoC = GetCoC(focusDistance, rayLength);\n#else\n    float CoC = color.a;\n#endif  \n\n#ifdef SIMPLE_MODE\n    UniformBlurCol( int(ApertureDiameter * iResolution.x) / 2, fragCoord.xy, color);\n\n#else\n#ifdef USE_DEPTH\n    DofBlurRow(iResolution.xy, uv, CoC, rayLength, color);\n#else\n    DofBlurRow(iResolution.xy, uv, CoC, color);\n#endif\n\n#endif\n    \n    fragColor = color;    \n}","name":"Buffer C","description":"","type":"buffer"}]}