{"ver":"0.1","info":{"id":"ctcczf","date":"1700165464","viewed":155,"name":"+Panels","username":"Aurcereal","description":"Inspired by https://www.shadertoy.com/view/DtcczX and like all of their shaders lol","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n\nfloat iT;\nfloat isInvertBack = 0.;\n\nvec2 rot(vec2 v, float o) { return mat2(cos(o), sin(o), -sin(o), cos(o)) * v; }\n\nfloat plusUi(vec2 p, float lowestScale, float fRep, vec2 fDim, float gRepMult, float gThick, float coldSpace, float seed, vec2 vel, inout float cover\n               , float stripeRep, float stripeSize, float rotPerStripe, float stripeSpeed)\n{\n    \n    p += vel*iT;\n\n    ////\n    float gRep = fRep*gRepMult;\n    \n    vec2 glp = p;\n    glp = mod(glp.xy, gRep) - gRep*.5;\n    vec2 gid = p - glp;\n    \n    float snapCount = gRep/(2.*fRep);\n    \n    vec2 scale = lowestScale+(1.-lowestScale)*.85*(1.+(-fRep/gRep - coldSpace)*1.)*hash22(gid+.01+seed*2.);\n    float gRot = 0.;//hash21(gid+seed*200.+200.)*1000. + iT;\n    \n    scale = scale - mod(scale, 1./snapCount);\n    scale += fRep/gRep + coldSpace;\n    scale *= gRep;\n    \n    vec2 dim = scale;\n    vec2 pos = (hash22(gid*2.+2.+seed)-.5)*(.8-.2)*(gRep-scale-gThick*2.); //pos = sign(pos) * (abs(pos) - mod(abs(pos), fRep));\n    \n    glp -= pos; glp = rot(glp, gRot); p = rot(p-(gid+pos), gRot) + gid+pos; glp = abs(glp);\n    float xBars = step(abs(glp.x - dim.x*.5), gThick*.5) * step(glp.y, (dim.y+gThick)*.5);\n    float yBars = step(abs(glp.y - dim.y*.5), gThick*.5) * step(glp.x, (dim.x+gThick)*.5);\n    float bglp = saturate(xBars+yBars);\n    cover = max(cover, step(glp.x, (dim.x+gThick)*.5)*step(glp.y, (dim.y+gThick)*.5));\n    \n    ////\n    vec2 flp = p;\n    flp = mod(flp - (gid+pos) - fRep*.5, fRep) - fRep*.5;\n    vec2 fid = p - flp;\n    \n    float stripe = dot(fid, vec2(-1.,1.)/sqrt(2.)) + stripeSpeed*iT + seed*1000.;\n    float lstripe = mod(stripe, stripeRep); float stripeID = (stripe - lstripe)/stripeRep;\n    float rotIntensity = (stripeID + smoothstep(stripeRep - stripeSize, stripeRep, lstripe)) * rotPerStripe;\n    flp = rot(flp, rotIntensity);\n    \n    fid = mod(fid, gRep) - gRep*.5; fid -= pos; fid = abs(fid);\n    float withinRect = step(fid.x, dim.x*.5-gThick*.5) * step(fid.y, dim.y*.5-gThick*.5);\n    \n    flp = abs(flp);\n    flp -= vec2(-1., 1.) * sqrt(2.) * min(0., dot(flp, vec2(-1., 1.)/sqrt(2.)));\n    float bflp = withinRect * step(flp.x, fDim.x*.5) * step(flp.y, fDim.y*.5);\n    \n    ////\n    return saturate(bflp+bglp);\n    \n}\n\nfloat crossShape(vec2 p, float stripeSharpness, float stripeSize, float stripeSideSize)\n{\n    vec2 lp = p;\n\n    lp = abs(lp);\n    float sharpHeight = stripeSharpness*(stripeSideSize*.5 - lp.x);\n    float exists = step(lp.y, min(sharpHeight, stripeSize*.5));\n    \n    return exists;\n}\n\nfloat crossBGUi(vec2 p, inout float cover)\n{\n    //\n    float stripeRep = .4;\n    float stripeSize = .125;\n    float stripeSharpness = .5;\n    \n    float stripeSideRep = .9;\n    float stripeSideSize = .67;\n    \n    float spd = 3.*.05;\n    \n    float stripesPer = 3.;\n    \n    //\n    p = vec2(dot(p, vec2(1.)/sqrt(2.)), dot(p, vec2(-1.,1.)/sqrt(2.)));;\n    p += vec2(.02, .14) * iT*.2;\n    vec2 lp = p;\n    lp.y = mod(lp.y, stripeRep)-stripeRep*.5; \n    float yID = (p.y - lp.y - stripeRep*.5)/stripeRep; float yAlt = step(abs(mod(yID,2.) - 1.), .5); yAlt = yAlt*2.-1.;\n    lp.x = mod(lp.x + yAlt*spd*iT, stripeSideRep) - stripeSideRep*.5;\n    \n    float outer = crossShape(lp, stripeSharpness, stripeSize, stripeSideSize);\n    float innerCut = 1.-crossShape(lp*vec2(1.06, 1.2), stripeSharpness, stripeSize, stripeSideSize);\n    float inner = crossShape(1.3*lp*vec2(.89, 1.2), stripeSharpness, stripeSize, stripeSideSize);\n    \n    //\n    float lineRep = 1.1;\n    float lineHeight = .028;\n    vec2 lineCutPart = vec2(.4, .45); // ~[0., .5]\n    float lineSpd = 3.*.05;\n    \n    vec2 cp = vec2(p.x, lp.y); cp.x = mod(cp.x + yAlt*lineSpd*iT, lineRep) - lineRep*.5;\n    cp = abs(cp);\n    float line = step(cp.y, .015) * saturate(step(cp.x, lineRep*lineCutPart.x) + step(lineRep*lineCutPart.y, cp.x));\n    \n    float isOther = step(mod(p.y, stripeRep*stripesPer*2.), stripeRep*stripesPer);\n    \n    cover = max(cover, choose(outer, line, isOther));\n    \n    //\n    float slow = .25*.5*.5*.25;\n    float invertSize = 240.*slow*2.;\n    float nonInvertSize = 240.*slow*2.;\n    float featherSize = .5;\n    float iSpd = 49.*slow;\n    float repSize = .08*1.6;\n    \n    vec2 dp = mod(p, repSize) - repSize*.5; vec2 did = p - dp; dp = abs(dp);\n    float size = repSize*smoothstep((invertSize+featherSize)*.5, (invertSize-featherSize)*.5, abs(mod(did.x - iSpd * iT, invertSize+nonInvertSize) - (invertSize+nonInvertSize)*.5));\n    isInvertBack = step(dp.x, size*.5) * step(dp.y, size*.5) * (1.-isOther);\n    \n    /*float iCoord = abs(mod(p.x - iSpd*iT, invertSize+nonInvertSize) - (invertSize+nonInvertSize)*.5);\n    isInvertBack = saturate(smoothstep((invertSize+featherSize)*.5, (invertSize-featherSize)*.5, iCoord))*(1.-isOther);*/\n    \n    return choose(outer*(innerCut+inner), line, isOther);\n}\n\nfloat boxBGUi(vec2 p, float cover)\n{\n    float repSize = .4;\n    \n    vec2 boxSizeRange = vec2(.3);\n    float outlineSize = .03; // size of gap and outline\n    \n    vec2 lp = mod(p, repSize) - repSize*.5; vec2 id = p - lp;\n    lp = abs(lp);\n    \n    float size = boxSizeRange.x; //temp\n    \n    float outerFill = step(lp.x, size*.5) * step(lp.y, size*.5);\n    float outerCut = 1.-step(lp.x, size*.5-outlineSize) * step(lp.y, size*.5-outlineSize);\n    float innerFill = step(lp.x, size*.5-2.*outlineSize) * step(lp.y, size*.5-2.*outlineSize);\n    \n    float exists = saturate(outerFill*outerCut + innerFill);\n\n    return exists;\n    //outline boxes with a gap between outline and box, domain repeated regular, has a size up down wave, the size wave may also be a rot wave\n    //would probably be vulnerable to the inversion\n    //im thinking separate size up wave\n}\n\nfloat outerUi(vec2 p)\n{\n    float repLen = .03;\n    vec2 distRange = vec2(0.05, 0.18)-.1;\n\n    vec2 end = vec2(iResolution.x/iResolution.y, 1.);\n    \n    p = end - abs(p); return step(min(p.x, p.y), .01);\n    vec2 lp = mod(p, repLen) - repLen*.5; vec2 id = p - lp;\n    \n    float size = repLen * smoothstep(distRange.y, distRange.x, min(id.x, id.y));\n    \n    lp = abs(lp);\n    float exists = step(lp.x, size*.5) * step(lp.y, size*.5);\n    \n    return exists;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    iT = iTime+60.;\n    \n    vec2 sp = ((fragCoord/iResolution.xy)*2.-1.)*vec2(iResolution.x/iResolution.y, 1.);\n    vec2 p = sp*2.;\n    \n    float cover = 0.;\n    \n    float thickMult = 1.;\n    \n    float bPlus1 = plusUi(p, .0, .2, vec2(.02, .14), 7., .02*thickMult, .03, 0., vec2(1.4, 1.), cover, 14., 4.*1.5, 3.25*PI, 6.);\n    float bPlus2 = (1.-cover)*(.4+.1)*plusUi(p, .2, .1, .5*vec2(.02, .14), 21., .015*thickMult, .03, 0.3, vec2(1.4,1.)*.1, cover, 8., 2.4, 2.25*PI, 3.4);\n\n    float frontCover = cover;\n\n    float bCross = .8*(1.-cover)*crossBGUi(p, cover); //*2., 1.5?\n    \n    float bPlus3 = (1.-cover)*.2*plusUi(p, .5, .07, .3*vec2(.02, .14), 40., .01*thickMult*1.3, .06, 0.7, vec2(1.4,1.)*.03, cover, 6., 2.5, 2.25*PI, 1.9);\n    \n    float bBox = .1*.5*(1.-cover)*boxBGUi(p, cover);\n    \n    \n    \n    float finalIntensity = max(bPlus1, max(bPlus2, invChoi(max(bPlus3, max(bCross, bBox)), isInvertBack*(1.-frontCover))));\n    //finalIntensity += outerUi(sp);\n    \n    fragColor = vec4(vec3(finalIntensity), 1.);\n    \n}\n\n//add feathering inversion, square feather dither\n\n// every 3 stripes alternate between diamond and big dotted line gaps\n\n// some repeated object between the 2nd and 3rd layer back\n\n//looking straight at it perspective 3d and sometimes blocks of it get pushed out\n\n//third wave high lowest scl, waves are sequential like back wave, and wave, front\n\n//usual (1,1) stripe, domain repeat that stripe and scroll it and the further you are inside the stripe the more rotated your plus is\n//so you have waves of rotation happen sometimes, big slow waves in the back and consistent kinda medium size waves in front\n\n//look at from iso angle and boxes are being pushed up with the screen and a kinda metallic shader\n//on the sides of the cubes\n\n//domain repeat boxes, big domain repeat big boxes, ranodm siez rectangle snapped to grid, rectangle contains the little boxes, try to make adjacent to other rectangles with some invariant, small outline contain slittle pluses\n//random mid edges of the big domani repetition have a hash in terms of position to say 'snap here' or 'dont care' binary\n//black and white can combine with 3dgrpahictstest or cylinder\n//square dither out on the sides into ui!!!\n\n//domain repetition fractal to voxel staircase, mincase break\n\n//smaller, more gray, slower, copy with different seeds in the back like a double layered parallax sort of deal","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Hashes from https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p -= mod(p, 0.001);\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash21(vec2 p)\n{\n    p -= mod(p, 0.001);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n    p -= mod(p, 0.001);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//\nfloat choose(float c1, float c2, float s)\n{\n    return c1 + (c2-c1)*s;\n}\nfloat saturate(float f) {return clamp(f, 0., 1.);}\nvec2 saturate(vec2 v) {return vec2(saturate(v.x),saturate(v.y));}\nfloat invChoi(float v, float should) { return (v + (1.-2.*v) * should); }","name":"Common","description":"","type":"common"}]}