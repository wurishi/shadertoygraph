{"ver":"0.1","info":{"id":"llfSWs","date":"1440558260","viewed":3741,"name":"Nebulaz","username":"randomekek","description":"Raymarched fbm. Use mouse to change view angle. For higher quality","likes":67,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d","raymarching","star","volumetric","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variables that influence quality\nconst int drift_count = 5; // decrease for more fps\nconst float step_size = 0.23; // increase for more fps\n\nconst float pi = 3.1415926;\nconst float field_of_view = 1.4;\nconst float camera_radius = 7.0;\nconst float nebula_radius = 6.0;\n\nfloat noise3d(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).xy;\n    return mix(rg.y, rg.x, f.z);\n}\n\nvec2 noise3d2(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec4 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0);\n    return vec2(mix(rg.y, rg.x, f.z), mix(rg.w, rg.z, f.z));\n}\n\nfloat fbm3d_low(in vec3 x) {\n    float f = 0.0;\n    f += 0.50000*noise3d(x); x = x*2.01;\n    f += 0.25000*noise3d(x); x = x*2.02;\n    f += 0.12500*noise3d(x); x = x*2.03;\n    f += 0.06250*noise3d(x);\n    return f;\n}\n\nfloat fbm3d(in vec3 x) {\n    float f = 0.0;\n    f += 0.50000*noise3d(x); x = x*2.01;\n    f += 0.25000*noise3d(x); x = x*2.02;\n    f += 0.12500*noise3d(x); x = x*2.03;\n    f += 0.06250*noise3d(x); x = x*2.04;\n    f += 0.03125*noise3d(x); x = x*2.01;\n    f += 0.01562*noise3d(x);\n    return f;\n}\n\nvec4 noise3d4_discontinuous(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    return texture(iChannel0, (uv + 0.5)/256.0, -100.0);\n}\n\nvec4 noise2d4(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return texture(iChannel0, (p + f + 0.5)/256.0, -100.0);\n}\n\nvec3 star_color(in float noise) {\n    // based on: http://www.vendian.org/mncharity/dir3/starcolor/\n    // constant distribution and linear interpolation\n    const vec3 coolest = vec3(0.615, 0.706, 1.000);\n    const vec3 middle  = vec3(0.984, 0.972, 1.000);\n    const vec3 hottest = vec3(1.000, 0.733, 0.482);\n    return mix(mix(coolest, middle, smoothstep(0.0, 0.5, noise)),\n               mix(middle, hottest, smoothstep(0.5, 1.0, noise)), step(0.5, noise));\n}\n\nvec3 only_mix(in vec3 src, in vec3 dst, in float start, in float end, in float amount) {\n    return mix(src, dst, smoothstep(start, end, amount)) * step(start, amount) * step(-end, -amount);\n}\n\nvec3 nebula_color(in float noise) {\n    // colors sampled from the Keyhole Nebula\n    // https://commons.wikimedia.org/wiki/File:Keyhole_Nebula_-_Hubble_1999.jpg#/media/File:Keyhole_Nebula_-_Hubble_1999.jpg\n    noise = clamp(noise, 0.0, 1.0);\n    const vec3 blue   = vec3(0.635, 0.827, 0.996);\n    const vec3 yellow = vec3(1.000, 0.823, 0.459);\n    const vec3 red    = vec3(0.945, 0.584, 0.502);\n    const vec3 orange = vec3(0.553, 0.231, 0.086);\n    const vec3 brown  = vec3(0.360, 0.137, 0.062);\n    const vec3 black  = vec3(0.095, 0.023, 0.043);\n    return max(max(max(max(\n           only_mix(blue, yellow,  0.0, 0.4, noise),\n           only_mix(yellow, red,   0.4, 0.5, noise)),\n           only_mix(red, orange,   0.5, 0.7, noise)),\n           only_mix(orange, brown, 0.7, 0.8, noise)),\n           only_mix(brown, black,  0.8, 1.0, noise));\n}\n\nvec3 star_field(in vec3 x, in float grid_size, out vec3 star_pos, out float star_brightness) {\n    // a tiled randomly positioned dot, looks like stars.\n    vec3 grid = floor(x * grid_size);\n    vec3 pos = fract(x * grid_size);\n    vec4 noise = noise3d4_discontinuous(grid);\n    vec3 center = noise.xxy * 0.5 + 0.25;\n    vec3 to_center = center - pos;\n    vec3 out_of_plane = x * dot(to_center, x);\n    float len = length(to_center - out_of_plane);\n    float brightness = noise.w;\n    float radius = mix(0.003, 0.009, pow(brightness, 9.0)) * grid_size;\n    float show = step(0.8, noise.y);\n    \n    star_pos = (grid + center) / grid_size;\n    star_brightness = show * brightness;\n    return 2.0 * star_color(noise.z) * show * smoothstep(radius, 0.0, len);\n}\n\nvec2 screen_space(in vec3 x, in vec3 vx, in vec3 vy, in vec3 vz) {\n    vec3 rescaled = field_of_view / dot(vz, x) * x;\n    return vec2(dot(vx, rescaled), dot(vy, rescaled));\n}\n\nvec3 lens_flare(in vec2 x, in vec2 center, in float brightness) {\n    // renders a lens flare at center\n    // quantization might be unnecessary, it prevents flickering\n    const float quantization = 500.0;\n    const float flare_size = 0.5;\n    vec2 to_x = (floor((x - center) * quantization) + 0.5) / quantization;\n    float shape = max(0.0, 0.005 / pow(abs(to_x.x * to_x.y), flare_size) - 0.3);\n    float radial_fade = smoothstep(0.04, 0.0, length(to_x));\n    float brightness_fade = smoothstep(0.75, 1.0, brightness);\n    return vec3(1.0) * shape * radial_fade * brightness_fade;\n}\n\nvec3 haze(in vec3 x, in vec3 background) {\n    // add grainy star background (illusion of infinite stars)\n    const float structure_size = 1.9;\n    const float background_radiation = 0.2;\n    float base_structure = fbm3d_low(x * structure_size);\n    float star_structure = mix(smoothstep(0.35, 0.8, base_structure), 1.0, background_radiation);\n    vec3 haze_color = 3.0 * vec3(0.058, 0.047, 0.096);\n    float grain = mix(2.0, 2.0*noise3d(x * 800.0), 0.5);\n    vec3 haze = haze_color * grain * smoothstep(0.1, 0.9, base_structure);\n    return star_structure * background + haze;\n}\n\nvec3 drift_field(in vec3 x) {\n    // provide a velocity field to drift the nebula (makes it streaky)\n    // generate a divergence free field to make it look like fluid flow\n    x = x * pi / nebula_radius;\n    vec3 outwards = normalize(x) * 0.2;\n    vec3 div_free = vec3(0.0);\n    div_free += 0.50*sin(1.00*x+7.85).yzx;\n    div_free += 0.25*cos(2.48*x+6.13).zxy;\n    div_free += 0.12*cos(4.12*x+11.49).yzx;\n    div_free += 0.06*sin(7.83*x+11.82).zxy;\n    return outwards + div_free;\n}\n\nvec3 drift(in vec3 x, in float speed, out vec3 direction) {\n    // drift backwards in time to sample the original nebula\n    // keep the last velocity to help sample velocity aligned noise\n    direction = drift_field(x);\n    x -= direction * speed;\n    for(int i=0; i<drift_count-1; i++) {\n    \tx -= drift_field(x) * speed;\n    }\n    return x;\n}\n\nvec4 nebula(in vec3 x) {\n    // opacity via fbm\n    float drift_speed = 0.2 * noise3d(x * 0.5 + 1.24);\n    vec3 drift_velocity;\n    vec3 x_drifted = drift(x, drift_speed, drift_velocity) * 0.7;\n    float density = 0.01 + 0.2 * smoothstep(0.50, 0.90, fbm3d(x_drifted + 23.6));\n    float radial_fade = smoothstep(nebula_radius, nebula_radius * 0.7, length(x));\n\n    // color via mix of global noise and drift aligned noise\n    float color_noise = noise3d(x_drifted);\n    float aligned_noise = noise3d(10.0 * (x - dot(x, normalize(drift_velocity))));\n    float noise = mix(color_noise, aligned_noise, 0.1);\n    float brightness = 0.1 * 0.9 + smoothstep(0.0, 1.0, noise);\n    vec3 color = mix(1.0, brightness, 0.7) * nebula_color(1.0 - noise);\n    \n    return vec4(color, radial_fade * density);\n}\n\nvec4 ray_trace(in vec3 origin, in vec3 ray) {\n    const float loop_max = 1.5 * nebula_radius + camera_radius;\n    const float fudge_factor = 2.1;\n    vec4 acc = vec4(0.0);\n    for(float i=0.0; i<loop_max; i+=step_size) {\n        vec3 pos = origin + i * ray;\n        vec4 samplez = nebula(pos);\n        // TODO: accumulator is not step_size independent... why?\n        // TODO: remove the fudge factor exp(w * step_size)\n        acc = acc + (1.0 - acc.w) * vec4(samplez.xyz * samplez.w, samplez.w);\n    }\n    acc.xyz *= fudge_factor;\n    return acc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = -1.0 + 2.0 * fragCoord / iResolution.xy;\n    pixel.x *= iResolution.x / iResolution.y;\n    vec2 mouse = pi * ((iMouse.xy + 0.001) / iResolution.xy * vec2(-2.0, 1.0));\n\n    // camera\n    const float motion_speed = 1.0;\n    float motion = (0.3 * cos(motion_speed * iTime * 0.2) + 0.7);\n    mouse += mod(motion_speed * iTime * 0.1, 2.0 * pi);\n    vec3 origin = camera_radius * motion * normalize(vec3(cos(mouse.x) * sin(mouse.y), cos(mouse.y), sin(mouse.x) * sin(mouse.y)));\n    vec3 target = vec3(0.0);\n    // orthonormal basis\n    vec3 vz = normalize(target - origin);\n    vec3 vx = normalize(cross(vec3(0.0, 1.0, 0.0), vz));\n    vec3 vy = normalize(cross(vz, vx));\n    // ray \n    vec3 ray = normalize(vx*pixel.x + vy*pixel.y + vz*field_of_view);\n    vec4 trace = ray_trace(origin, ray);\n\n    vec3 star_pos;\n    float star_brightness;\n    // stars\n    fragColor = vec4(haze(ray, star_field(ray, 18.0, star_pos, star_brightness)), 1.0);\n    // stars with lens flare\n    fragColor += vec4(star_field(ray, 4.0, star_pos, star_brightness), 1.0);\n    // lens flares\n    fragColor += vec4(lens_flare(pixel, screen_space(star_pos, vx, vy, vz), star_brightness*1.6), 1.0);\n    // nebula\n    fragColor = vec4(mix(fragColor.xyz, trace.xyz, trace.w), 1.0);\n}","name":"Image","description":"","type":"image"}]}