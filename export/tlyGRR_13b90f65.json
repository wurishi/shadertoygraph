{"ver":"0.1","info":{"id":"tlyGRR","date":"1584204797","viewed":319,"name":"Verlet 2d","username":"spalmer","description":"hackjob of iq's mighty fine shader [url]https://shadertoy.com/view/4dG3R1[/url]\nneeds friction and stuff","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["physics","verlet","softbody"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// derived from https://shadertoy.com/view/4dG3R1\n\n// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash1(vec2 p) { float n = dot(p,vec2(127.1,311.7)); return fract(sin(n)*153.4353); }\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h);\n}\n\nvec4 getParticle(ivec2 id)\n{\n    return texelFetch(iChannel0, id, 0); //texture(iChannel0, (id+.5)/iResolution.xy);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 f = vec3(0);\n    for (int j = 0; j <= limy; ++j)\n    for (int i = 0; i <= limx; ++i)\n    {\n        ivec2 id = ivec2(i,j); //vec2(float(i), float(j));\n        vec4 p = getParticle(id);\n\n        float d = 1.;\n        \n        #if 1 // draw links\n        if (i<limx)        d = min(d, sdSegment(uv, p.xy, getParticle(id+ivec2(1,0)).xy));\n        if (j<limy)        d = min(d, sdSegment(uv, p.xy, getParticle(id+ivec2(0,1)).xy));\n        if (i<limx && j<limy) d = min(d, sdSegment(uv, p.xy, getParticle( id+ivec2(1,1)).xy));\n        if (i>0 && j<limy) d = min(d, sdSegment(uv, p.xy, getParticle(id+ivec2(-1,1)).xy));\n        f = mix(f, vec3(.4,.6,.8), 1.-smoothstep(0., 1.*size, d));\n        #endif\n        \n        d = length(uv - p.xy) - size; //.035;\n        vec3 col = .6 + .4*sin(hash1(vec2(id))*30. + vec3(0,1,2));\n        col *= .8 + .2*smoothstep(-.1, .1, sin(d*400.));\n        f = mix(f, col, 1.-smoothstep( -.001, .001, d));\n    }\n    \n\tf = pow(f, vec3(1./2.2)); // to srgb gamma\n    fragColor = vec4(f,1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int pcountx = 3;\nconst int pcounty = 7;\n\nconst int limx = pcountx-1;\nconst int limy = pcounty-1;\n\nconst float spacing = .05;\n\nconst float stiffness = .2; // careful, they're undamped\n\nconst float size = .015;\n\n// would share hash1 but it's not identical","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash1(vec2 p) \n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453);\n}\n\nvec4 getParticle(ivec2 id)\n{\n    return texelFetch(iChannel0, ivec2(id), 0);\n}\n\nvec4 getParticle(vec2 id)\n{\n    // this is cleverly used elsewhere to interpolate quantities between particles iirc.  or not?\n    return texture(iChannel0, (id + .5) / iResolution.xy);\n    \t//getParticle(ivec2(id)); // won't work quite the same\n}\n\n// compute p's spring forcereaction to other particle qid given spring rest length\nvec4 react(vec4 p, ivec2 qid, float rl)\n{\n    vec4 q = getParticle(qid);\n    vec2 di = q.xy - p.xy  // relative pos\n        , w = q.zw - p.zw; // relative vel\n    float l = length(di), dt = 1.; //iTimeDelta; //\n  //  p.xy += stiffness * (l - rl) / l * di;\n    vec2 e = di / max(l, 1e-3); // unit length more or less direction to other\n    vec2 f = stiffness * (l - rl) * e; // simple undamped spring force\n    float j = .3*stiffness; // ok, don't use too much relative stiffness!\n    // seems this is doing impulses, actually\n    f -= j * dot(w, e) * e; // damping force (euler integration's unstable without it)\n    p.zw -= f * dt; //p.xy += f * dt; // idk why adding to xy works better than adding to zw!  seems other way would be more stable, but it's way more unstable!\n    return p;\n}\n\nvec4 solveConstraints(ivec2 id, vec4 p)\n{\n    // TODO vector compare\n    if (id.x > 0   )  p = react(p, id + ivec2(-1, 0), spacing);\n    if (id.x < limx)  p = react(p, id + ivec2( 1, 0), spacing);\n    if (id.y > 0   )  p = react(p, id + ivec2( 0,-1), spacing);\n    if (id.y < limy)  p = react(p, id + ivec2( 0, 1), spacing);\n\tfloat r2s = spacing * sqrt(2.);\n    if (id.x > 0    && id.y > 0   )  p = react(p, id + ivec2(-1, -1), r2s);\n    if (id.x > 0    && id.y < limy)  p = react(p, id + ivec2(-1,  1), r2s);\n    if (id.x < limx && id.y > 0   )  p = react(p, id + ivec2( 1, -1), r2s);\n    if (id.x < limx && id.y < limy)  p = react(p, id + ivec2( 1,  1), r2s);\n\n    return p;\n}\n\nvec4 move(vec4 p, ivec2 id)\n{\n    const float g = .6; // gravity\n    \n    float dt = iTimeDelta;\n\n    // gravity acceleration\n    p.xy += dt * dt * vec2(0,-g);\n    \n    // collide screen\n    if (p.x < 0.   + size) p.x = 0.   + size;\n    if (p.x > 1.77 - size) p.x = 1.77 - size;\n    if (p.y < 0.   + size) p.y = 0.   + size;        \n    if (p.y > 1.   - size) p.y = 1.   - size;\n    \n    // constraints\n    p = solveConstraints(id, p);\n        \n    #if 0\n    if (id.y > limy) p.xy = .05 + spacing*vec2(id);\n    #endif\n    \n    vec2 x = p.xy; // particle position\n    vec2 v = p.xy - p.zw; // / iTimeDelta; // velocity * old timestep\n    // usually verlet stuff assumes the iTimeDelta never changes\n    // verlet inertia\n    vec2 np = v + x; //2. * p.xy - p.zw; // p2 = (p1 - p0) + p1\n    //p.zw = p.xy;\n    // this damping is on the point masses, not the springs, so barely helps with the instability.\n    // Simulates \"wind resistance\"\n    v *= exp2(-.2 * dt);\n    if (iMouse.z >= 0. && length(iMouse.xy) > 1.5) {\n        vec2 mrel = (iMouse.xy/iResolution.y - x);\n        float l2 = dot(mrel, mrel);\n        if (l2 > 1e-3) {\n            v += .2*size*dt * mrel / l2;\n        }\n    }\n    p.zw = np - v; //mix(np, p.xy, exp2(-.2*iTimeDelta)); // damping applies to *old* position because only affects velocity, not new position (takes effect next frame)\n    p.xy = np;\n\n    return p;\n}\n\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    ivec2 id = ivec2(floor(q)); //-.4);\n    \n    if (id.x > limx || id.y > limy) discard;\n    \n    vec4 p = getParticle(id);\n    \n    if (iFrame == 0) {\n        vec2 v = vec2(hash1(vec2(id)+iDate.w)\n                    , hash1(vec2(id.yx)-iDate.w))\n        *1.-.25; //.5+.5*;\n        p.xy = .05 + spacing * vec2(id); // + vec2(5,0);\n        p.zw = p.xy - .8*size*v; // some initial velocity, random\n    } else {\n    \tp = move(p, id);\n    }\n\n    o = p;\n}\n\n\n// TODO iMouse interaction\n\n","name":"Buffer A","description":"","type":"buffer"}]}