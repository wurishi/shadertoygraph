{"ver":"0.1","info":{"id":"mdXBDn","date":"1688611924","viewed":54,"name":"Reino das Rosquinhas","username":"joao","description":"rosquinhas","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rosquinhas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n\n// Rotation matrix.\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct Surface {\n    float sd; \n    vec3 col; \n};\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; \n  return obj1;\n}\nSurface maxWithColorDif(Surface obj1, Surface obj2) {\n  obj1.sd*=-1.;\n  if (obj2.sd > obj1.sd) return obj2; \n  return obj1;\n}Surface maxWithColor(Surface obj1, Surface obj2) {\n  \n  if (obj2.sd > obj1.sd) return obj2; \n  return obj1;\n}\n\n\n// SDF of a torus at the origin given its two radius.\nSurface dTorus(vec3 p, vec2 r,vec3 col) {\n    float x = length(p.xz) - r.x;\n    float sd =length(vec2(x, p.y)) - r.y;\n    Surface suf ;\n    suf.col= col/255.;\n    suf.sd= sd;\n    return suf;\n}\n\n\n\n// B + A\nSurface unionSDF (Surface sda, Surface sdb) {\n     return minWithColor(sda, sdb);\n    \n}\n\n// B * A\nSurface intersectionSDF (Surface sda, Surface sdb) {\n     return maxWithColor(sda, sdb);\n}\n\n// B - A\nSurface differenceSDF (Surface sda, Surface sdb) {\n    \n    return maxWithColorDif(sda, sdb);\n    \n}\n\n\n// Blend A and B\nSurface blendSDF(Surface sda, Surface sdb, float k,vec3 col) {\n    float h = clamp(0.5 + 0.5 * (sdb.sd - sda.sd) / k, 0.0, 1.0);\n     Surface suf ;\n    suf.col=col/255.;\n    suf.sd= mix(sdb.sd, sda.sd, h) - k * h * (1.0 - h);\n    return suf;\n}\n\n// Scene SDF: signed distance function.\nSurface getDist(vec3 p) {\n    Surface planeDist;\n    planeDist.sd= p.y;\n    planeDist.col=  vec3(250, 235, 215)/255.;\n    \n    float s = sin(iTime);\n    \n   \n    vec3 rosquinhaPosition= p - vec3(-2.6, 1.0, 5.1);\n    vec3 rosquinha2Position= p - vec3(-2.6, 1.0, 4.1);\n    \n    vec3 rosquinha3Position = p - vec3(2.6, 1.0, 4.1);\n    vec3 rosquinha4Position = p - vec3(2.6, 1.0, 5.1);\n    \n    \n    vec3 rosquinha5Position = p - vec3(0, 2, 4);\n    vec3 rosquinha6Position = p - vec3(0, 2, 4);\n   \n    vec3 rosquinha7Position= p - vec3(-5, 3, 10);\n    vec3 rosquinha8Position= p - vec3(5, 3, 10);\n    \n    rosquinhaPosition.x+= 0.999*sin(iTime);\n    rosquinhaPosition.yz*= Rot(-iTime);\n    \n    rosquinha2Position.yz*= Rot(iTime);\n    rosquinha2Position.x+= 0.999*sin(iTime);\n    \n    rosquinha3Position.yz*= Rot(-iTime);\n    rosquinha3Position.x+= 0.999*-sin(iTime);\n    \n    rosquinha4Position.yz*= Rot(iTime);\n    rosquinha4Position.x+= 0.999*-sin(iTime);\n    \n    rosquinha5Position.yz*= Rot(iTime);\n    rosquinha5Position.z+= 0.999*-sin(iTime);\n    \n    rosquinha6Position.yz*= Rot(iTime);\n    rosquinha6Position.z+= 0.999*sin(iTime);\n    \n    rosquinha7Position.x+= 0.999*cos(iTime);\n    rosquinha7Position.yz*= Rot(-iTime);\n    \n    rosquinha8Position.x+= 0.999*-cos(iTime);\n    rosquinha8Position.yz*= Rot(-iTime);\n    \n    float displacement2 = sin(70. * p.x)  *  0.01;\n    \n    float displacement3 = sin(5.0 * p.x) * sin(6.0 * p.y) * sin(4.0 * p.z) * sin(iTime)* 0.15;\n\n    Surface rosquinhaDistance= dTorus(rosquinhaPosition, vec2(0.15, 0.08),vec3(250, 50, 233));\n    Surface rosquinha2Distance= dTorus(rosquinha2Position, vec2(0.15, 0.08),vec3(250, 50, 233));\n    Surface rosquinha3Distance= dTorus(rosquinha3Position, vec2(0.15, 0.08),vec3(250, 50, 233));\n    Surface rosquinha4Distance= dTorus(rosquinha4Position, vec2(0.15, 0.08),vec3(250, 50, 233));\n    Surface rosquinha5Distance= dTorus(rosquinha5Position+displacement3, vec2(0.4, 0.1),vec3(250, 50, 233));\n    Surface rosquinha6Distance= dTorus(rosquinha6Position+displacement3, vec2(0.4, 0.1),vec3(250, 50, 233));\n    Surface rosquinha7Distance= dTorus(rosquinha7Position, vec2(0.15, 0.08),vec3(250, 50, 233));\n    Surface rosquinha8Distance= dTorus(rosquinha8Position, vec2(0.15, 0.08),vec3(250, 50, 233));\n    \n  // Surface rosquinhaDistance2= dTorus(rosquinhaPosition2+displacement3, vec2(0.4, 0.1),vec3(250, 50, 233));\n\n    Surface d = minWithColor( planeDist,differenceSDF(rosquinhaDistance,rosquinha2Distance));    \n    d= minWithColor(d,rosquinhaDistance);\n    d= minWithColor(d,rosquinha2Distance);\n    d= minWithColor(d,rosquinha3Distance);\n    d= minWithColor(d,rosquinha4Distance);\n    d= minWithColor(d,rosquinha5Distance);\n    d= minWithColor(d,rosquinha6Distance);\n    d= minWithColor(d,rosquinha7Distance);\n    d= minWithColor(d,rosquinha8Distance);\n    \n   \n    \n\n   \n    \n    \n\n   \n    \n    return d;\n}\n\n// Walk through empty spheres until the ray hits an object\n// or is beyond MAX_DIST, meaning no hit. \nSurface rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    Surface suf;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        Surface distsuf= getDist(p);\n        suf.col= distsuf.col;\n        float dS = distsuf.sd;\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    suf.sd= dO;\n    return suf;\n}\n\n// The normal is the gradient of the SDF scalar field at point p.\n// By using finite difference: \n// https://en.wikipedia.org/wiki/Finite_difference#Relation_with_derivatives \nvec3 getNormal(vec3 p) {\n    // arbitrary â€” should be smaller than any surface detail in your distance function, \n    // but not so small as to get lost in float precision\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = \n        vec3(\n        getDist(p + e.xyy).sd,\n        getDist(p + e.yxy).sd,\n        getDist(p + e.yyx).sd) - \n        vec3(\n        getDist(p - e.xyy).sd,\n        getDist(p - e.yxy).sd,\n        getDist(p - e.yyx).sd);\n        \n    return normalize(n);\n}\n\n// Phong illumination model, given a point and camera position.\nfloat getLight(vec3 p, vec3 ro) {\n    vec3 lightPos = vec3(-2, 5, 0);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 1.;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    vec3 r = reflect(-l,n);\n    \n    // ambient component\n    float amb = 0.1;\n    // ambient reflection coefficient\n    float ka = 1.0;\n    \n    // diffuse component - apply Lambert's cosine law\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    // diffuse reflection coefficient\n    float kd = 0.8;\n    \n    // specular component\n    float shininess = 200.;\n    vec3 v = normalize(ro-p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec,shininess);\n    // specular reflection coefficient\n    float ks = 1.0;\n    \n    // slightly move point p in the direction of the normal,\n    // so the distance is not zero. Otherwise, the first hit \n    // will be at the plane.\n    Surface d = rayMarch(p + 2. * n * SURF_DIST , l);\n    \n    // cast a ray to the light\n    if (d.sd < length(lightPos - p)) {\n        // point in the shadow\n        dif *= 0.1;\n        spec *= 0.5;\n    }\n    \n    // ambient + diffuse + specular components\n    return ka * amb + kd * dif + ks * spec;\n}\n\n// Fragment shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera position\n    vec3 ro = vec3(0, 2, 0);\n    \n    // projection plane z = 1\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Rotate camera down about the x-axis\n    rd.yz *= Rot(PI * 10. / 180.); \n    \n    Surface d = rayMarch(ro, rd);\n    \n    // point hit by the ray\n    vec3 p = ro + rd * d.sd;\n    \n    // illumination at point p\n    float light_intensity = getLight(p, ro);\n    \n    // dark grey\n    // vec3 background_color = vec3(.2, .2, .2);\n    vec3 background_color = texture(iChannel0, uv*vec2(1.,2.)).rgb;\n    \n    // Antique White color #FAEBD7\n    vec3 surface_color = vec3(250, 235, 215) / 255.;\n    \n    // pixel color\n    vec3 color;\n    \n    if (d.sd < MAX_DIST) \n        // modulate surface color by the light intensity\n        color = d.col * vec3(light_intensity);\n    else \n        color = background_color;\n\n    // output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}