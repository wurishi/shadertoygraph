{"ver":"0.1","info":{"id":"Dl2BWG","date":"1694480347","viewed":62,"name":"Sketch #14: 3D Cubes","username":"MOONtyzoo","description":"Based on tutorial here: https://www.scratchapixel.com/lessons/3d-basic-rendering/get-started/gentle-introduction-to-computer-graphics-programming.htm\n\nOoooooh magical floating cubes ooooOOOOh","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat3 rotateX(float angle)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(angle), -sin(angle),\n                0.0, sin(angle), cos(angle));\n}\n\nmat3 rotateY(float angle)\n{\n    return mat3(cos(angle), 0.0, -sin(angle),\n                0.0, 1.0, 0.0,\n                sin(angle), 0.0, cos(angle));\n}\n\nmat3 rotateZ(float angle)\n{\n    return mat3(cos(angle), -sin(angle), 0.0,\n                sin(angle), cos(angle), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Returns 1 inside the point and 0 outside\nfloat drawVertex(in vec2 p, in vec3 screenVertex)\n{\n    return 1.0 - smoothstep(0.0, 0.005, length(screenVertex.xy - p) - 0.05/screenVertex.z);\n}\n\n// Returns 1 inside the edge and 0 outside (sv is screenVertex)\nfloat drawEdge(in vec2 p, in vec3 sv1, in vec3 sv2)\n{\n    vec2 lineVec = vec2(sv2.x - sv1.x, sv2.y - sv1.y);\n    vec2 pVec = vec2(p.x - sv1.x, p.y - sv1.y);\n    \n    float distToLine = length(cross(vec3(normalize(lineVec), 0.0), vec3(pVec, 0.0)));\n    float distAlongLine = dot(lineVec, pVec)/dot(lineVec, lineVec); // 0 at sv1 and 1 at sv2\n    \n    float depth = (1.0-distAlongLine)*sv1.z + distAlongLine*sv2.z;\n    \n    float val = 1.0 - smoothstep(0.0, 0.005, distToLine - 0.005/depth);\n    val *= step(0.0, distAlongLine)*step(distAlongLine, 1.0);\n    return val;\n}\n\n// -------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    /*\n        Control variables\n    */\n    float cubeSize = 1.0;\n    int cubeNum = 6;\n    \n    /*\n        Cube vertex/edge data\n    */\n    \n    // Creates a 1x1 cube at the origin\n    vec3[8] cubeVertices;\n    cubeVertices[0] = vec3(0.0, 0.0, 0.0);\n    cubeVertices[1] = vec3(1.0, 0.0, 0.0);\n    cubeVertices[2] = vec3(0.0, 1.0, 0.0);\n    cubeVertices[3] = vec3(0.0, 0.0, 1.0);\n    cubeVertices[4] = vec3(1.0, 1.0, 0.0);\n    cubeVertices[5] = vec3(1.0, 0.0, 1.0);\n    cubeVertices[6] = vec3(0.0, 1.0, 1.0);\n    cubeVertices[7] = vec3(1.0, 1.0, 1.0);\n    \n    // Pairs of vertex indexes which should be connected\n    ivec2[12] cubeEdges;\n    cubeEdges[0] = ivec2(0, 1);\n    cubeEdges[1] = ivec2(0, 2);\n    cubeEdges[2] = ivec2(0, 3);\n    cubeEdges[3] = ivec2(1, 4);\n    cubeEdges[4] = ivec2(1, 5);\n    cubeEdges[5] = ivec2(2, 4);\n    cubeEdges[6] = ivec2(2, 6);\n    cubeEdges[7] = ivec2(3, 5);\n    cubeEdges[8] = ivec2(3, 6);\n    cubeEdges[9] = ivec2(4, 7);\n    cubeEdges[10] = ivec2(5, 7);\n    cubeEdges[11] = ivec2(6, 7);\n    \n    /*\n        Draw cubes\n    */\n    \n    vec3 outColor = vec3(0.0);\n    \n    // Iterate through each cube and add output to outColor\n    for (int i = 0; i < cubeNum; i++)\n    {\n        // Each cube gets it's own color\n        vec3 cubeColor = hsv2rgb(vec3(float(i)/float(cubeNum), 1.0, 1.0));\n        \n        // Each cube is offset in time\n        float cubeTime = iTime - float(i);\n        \n        vec3[8] screenVertices; // Used as a vec2 but the third comp gives the depth for scaling points\n        for (int j = 0; j < 8; j++)\n        {\n            vec3 vertex = cubeVertices[j];\n            // Center the cube coordinates\n            vertex -= vec3(0.5);\n\n            // Scale cube size\n            vertex *= cubeSize;\n\n            // Spin\n            vertex = vertex * rotateY(cubeTime);\n            vertex = vertex * rotateX(1.3*cubeTime);\n\n            // Translate cube to view range\n            vertex.z -= 4.0;\n\n            // Move cube around screen\n            vertex.x += 5.0*cos(1.1*cubeTime);\n            vertex.z -= 4.0*(0.5*sin(1.1*cubeTime)+0.5);\n            vertex.y += 2.0*sin(2.0*cubeTime)*cos(cubeTime+1.0);\n\n            // Project world coordinate to screen coordinate\n            screenVertices[j].x = -vertex.x/vertex.z;\n            screenVertices[j].y = -vertex.y/vertex.z;\n            screenVertices[j].z = -vertex.z;\n        }\n        \n        // val determines if the color shows (1 or 0)\n        float val = 1.0;\n        for (int j = 0; j < 8; j++)\n        {\n            val *= 1.0-drawVertex(uv, screenVertices[j]);\n        }\n        for (int j = 0; j < 12; j++)\n        {\n            vec3 sv1 = screenVertices[cubeEdges[j].x];\n            vec3 sv2 = screenVertices[cubeEdges[j].y];\n            val *= 1.0-drawEdge(uv, sv1, sv2);\n        }\n        val = 1.0-val;\n        \n        outColor += val*cubeColor;\n        \n    }\n    \n    fragColor = vec4(outColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}