{"ver":"0.1","info":{"id":"fsVfRh","date":"1657738357","viewed":115,"name":"Fork I Have a Q dryfit 363","username":"dryfit","description":"Here is my question: \nHow is it that in between the vertex and fragment shader of a graphics program, the hardware is able to rasterize millions of triangles in parallel? \nThis just seems like an impossible task and always feels like magic.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["triangles","reflections"],"hasliked":0,"parentid":"4s3fDH","parentname":"I Have a Question!"},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415927\n#define phi 1.61803398875\n#define reflections 13\n\nmat3 rot (vec3 u) {\n\t\tvec3 s = sin(u), c = cos(u);\n\t\tmat3 x = mat3(1,0,0, \t\t0,c.x,s.x, \t\t0,-s.x,c.x);\n\t\tmat3 y = mat3(c.y,0,s.y, \t0,1,0, \t\t\t-s.y,0,c.y);\n\t\tmat3 z = mat3(s.z,c.z,0,\t-c.z,s.z,0,\t\t0,0,1);\n\t\treturn x*y*z;\n}\n\nvoid tri (vec3 p, vec3 d, mat3 tr, inout vec4 col, inout float depth, inout vec3 norm, int outtie) {\n    \n    //vec3 n = normalize(cross(tr[1]-tr[0],tr[2]-tr[0]));\n    vec3 n = normalize(cross(tr[1]-tr[0],tr[2]-tr[0]));\n    \n    if ( dot(n,-d) <0. ) n *= -1.;\n    \n    mat3 nn = mat3(\n    \tnormalize(cross(n,tr[2]-tr[1])),\n    \tnormalize(cross(n,tr[0]-tr[2])),\n    \tnormalize(cross(n,tr[1]-tr[0]))\n    );\n    \n    vec3 w = p - tr[0];\n    \n    //float x = -dot(w,n)/dot(d,n);\n    float x = -dot(w,n) / dot(d,n);\n    \n    if (x < -100.) return;\n    \n    //vec3 i = p + d*x;\n    vec3 i = p + d * x;\n    //vec3 ipol = vec3( dot(nn[0], i-tr[1]), dot(nn[1],i-tr[2]),dot(nn[2],i-tr[0]))/vec3(dot(nn[0],tr[0]-tr[1]),dot(nn[1],tr[1]-tr[2]),dot(nn[2],tr[2]-tr[0]));\n    \n    vec3 ipol = vec3( \n    dot(nn[0],i-tr[1]), \n    dot(nn[1],i-tr[2]),\n    dot(nn[2],i-tr[0])\n    )/vec3(\n    dot(nn[0],tr[0]-tr[1]),\n    dot(nn[1],tr[1]-tr[2]),\n    dot(nn[2],tr[2]-tr[0])\n    );//dividing gives wire frames \n    \n    vec4 c = vec4(1);\n    //c.w *= step(0.,ipol.x);\n    //c.w *= step(0.,ipol.y);\n    //c.w *= step(0.,ipol.z);\n    \n    c.w *= step(-0.0,ipol.x);//makes the triangles touch each other\n    c.w *= step(-0.0,ipol.y);\n    c.w *= step(-0.0,ipol.z);\n    \n    if (c.w == 0.0) return;\n    //if (c.w == 0.) x=1000.;\n    if(outtie==0){\n        \n        if (x < depth ) {\n            \n            vec3 u = normalize(reflect(p-i, n));\n\n            float p1 = .004;//default .02;\n            float p2 = p1 +.001;//default .025;\n            \n            c.xyz =  ( texture( iChannel0,u ).xyz * abs(u) ) - 1. + ((smoothstep(p1,p2,ipol.x) * smoothstep(p1,p2,ipol.y) * smoothstep(p1,p2,ipol.z)) );\n\n            col.x = c.x*1.1;\n            col.y = c.x*1.;\n            col.z = c.x*.5;\n\n            col = (1.0 - col) * 1.;\n            depth = x;\n            norm = n;\n\n        }\n        \n    }else{\n    \n        if (x < depth ) {\n            \n            vec3 u = normalize(reflect(p-i, n));\n\n            float p1 = .004;//default .02;\n            float p2 = p1 +.001;//default .025;\n            \n            c.xyz =  ( texture( iChannel0,u ).xyz * abs(u) ) - 1. + ((smoothstep(p1,p2,ipol.x) * smoothstep(p1,p2,ipol.y) * smoothstep(p1,p2,ipol.z)) );\n\n            col.x = c.x*1.1;\n            col.y = c.x*1.;\n            col.z = c.x*.5;\n\n            //col = (1.0 - col) * 1.;\n            depth = x;\n            norm = n;\n\n        }\n        \n    }\n}\n\nvoid sph (vec3 p, vec3 d, vec4 cr, inout vec4 col, inout float depth, inout vec3 norm) {\n\tvec3 w = p-cr.xyz;\n    float B = 2.*dot(w,d);\n    float C = dot(w,w)-cr.w*cr.w;\n    float dl = B*B-4.*C;\n    if (dl < 0.) return;\n    float x = 0.5*(-B-sqrt(dl));\n    if (x < 0.) return;\n    vec3 i = p + d*x;\n    vec4 c = vec4(1);\n    if (x < depth) {\n        norm = normalize(i-cr.xyz);\n        vec3 r = normalize(reflect(p-i,norm));\n    \tc.xyz = abs(r)*texture(iChannel0,r).xyz;\n    \tcol = c;\n        depth = x;\n    }\t\n}\nvoid scene (inout vec3 p, inout vec3 d, inout vec4 col, float i) {\n\tfloat depth = 1e3;\n    vec3 norm=vec3(0);\n    vec4 c = vec4(0);\n    float t = iTime/pi;\n    for (int i = 0; i < 4; i++) {\n        tri(p,d, //top triangle\n            rot(pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n            //rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n               \t4,0,0,\n                0,4,0,\n                0,0,4\n            )\n        ,c,depth,norm,0);\n    \ttri(p,d,\n            rot(pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n            //rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n               \t-4,0,0,\n                0,-4,0,\n                0,0,-4\n            )\n        ,c,depth,norm,0);\n        \n        //tri(p,d,\n            //rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n               //\t1,0,0,\n               // 0,1,0,\n               // 0,0,1\n            //)\n       // ,c,depth,norm);\n        //tri(p,d,\n            //rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n               //\t-1,0,0,\n               // 0,-1,0,\n                //0,0,-1\n            //)\n        //,c,depth,norm);\n        \n        //sph (p,d,vec4(sin(t+float(i)),cos(t+float(i)),sin(phi*t+float(i*i)),.2), c, depth, norm);\n    } \n    p = p + d * depth;\n    d = reflect(d,norm);\n    p += 0.1*(d);\n    col += 0.8 * c / ( 2.8 + 2. * (i) );\n    \n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord)/iResolution.xy*2.-1.)*iResolution.xy/iResolution.yy;\n\tmat3 m = rot(vec3(iTime*.2,-0.2,0.));\n    vec3 p = m*vec3(0,0,-3.+sin(iTime*.4)*4.);\n    //vec3 p = m*vec3(0,0,-.1);\n    vec3 d = m*normalize(vec3(uv,1));\n    \n    vec4 col = vec4(0.,0.,0.0,0);\n    \n    for (int i = 0; i < reflections; i++) scene (p,d,col,float(i));\n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}