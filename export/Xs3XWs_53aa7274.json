{"ver":"0.1","info":{"id":"Xs3XWs","date":"1462034568","viewed":238,"name":"Clouds Blackhole","username":"avol","description":"Clouds","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// quality\nconst float steps \t\t= 150.0;\nconst float stepSize \t= 20.0;\n\nconst float density \t= 0.0001;\nconst float base \t\t= 0.25;\n\nconst vec3 sunDir \t\t= vec3(0, 0.0, -1.0);\n\n\nconst vec4 skyColor \t= vec4(0.0, 0.5, 0, 1);\nconst vec4 sunColor\t\t= -vec4(5);\nconst vec4 waterColor\t= vec4(0.0, 5.0, 8.0, 3.0)*10.0;\nconst vec4 cloudsColor\t= vec4(1.0, 2.0, 6.0, 3.0)*10.0;\n\nconst float cloudOccStr\t= 3.0;\nconst float waterOccStr\t= 1.0;\n\nconst float cloudSpeed  = 0.7;\nconst float waterSpeed \t= 0.2;\n\nconst float cloudDens \t= 0.00005;\nconst float waterDens \t= 0.0001;\n\n\nconst float sunSize   \t= 0.01;\nconst float auraSize\t= 0.02;\n\n// LUT based 3d noise\nfloat noise( in vec3 x, sampler2D noiseMap )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( noiseMap, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n// map noise\nfloat map3( in vec3 p, float speed, bool invert, sampler2D noiseMap )\n{\n\tvec3 q = p - vec3(0.0,0.0,-1.0) * (iTime * speed);\n    \n    if (invert)\n        p.y *= -1.0;\n    \n\tfloat f;\n    f  = 0.50000*noise( q, noiseMap ); q = q*2.02;\n    f += 0.25000*noise( q, noiseMap ); q = q*2.03;\n    f += 0.12500*noise( q, noiseMap );\n    \n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\n// Computes sky color\n// @ rd - camera ray direction\n// @ str - smoke strength inverse\nvec4 sky(vec3 rd, float str)\n{\n    float intensity = (dot(rd, sunDir) + 1.0) * 0.5;\n    \n    vec4 fragment \t= skyColor * intensity * str;\n    //if (rd.y < 0.0)\n    //    fragment = vec4(1) * str;\n    \n    // if in sun range.\n    float pulsingSun = sunSize * ( abs( sin(iTime * 1.5))* 0.1 + 0.9 ) ;\n    if (intensity > 1.0 - pulsingSun)\n    {\n        float current = intensity - (1.0 - pulsingSun);\n        float fc \t= pow(current / pulsingSun, 2.0);\n        \n        fragment.rgb += sunColor.rgb * fc;\n        \n       \n    }\n    \n    return fragment;\n}\n\n\n//\n//\n//\nvec4 computeClouds(vec3 ta, vec3 rd)\n{\n    \n    vec4 cloudTint \t\t\t= vec4(0);\n    vec3 position  \t\t\t= ta + rd;\n\n    float occ\t \t\t\t= 0.0;\n    float volDensity\t\t= 0.0;\n    \n    // accumulate\n    for (float i=0.0; i < steps; i++) \n    {\n        // increment position\n        rd = normalize(rd + sunDir * sqrt(i/steps)*0.01);\n        position += rd * (i * stepSize);\n        \n        // calculate occlusion clouds\n        float ps1 = 0.0; float ps2 = 0.0;\n        if (position.y > -5000.0) {\n        \tps1 \t= map3( position * cloudDens, cloudSpeed, true, iChannel1 );\n        \tps2 \t= map3( position * cloudDens + sunDir * 0.5, waterSpeed, true, iChannel1 );\n        }\n            \n\n        // calculate occlusion water\n        float pw1 = 0.0; float pw2 = 0.0;\n        float occ = 0.0;\n        if (position.y < 5000.) {\n        \t\n        \tpw1 \t= map3( position * waterDens, waterSpeed, false, iChannel1 );\n        \tpw2 \t= map3( position * waterDens + sunDir * 0.5, waterSpeed, false, iChannel1 );\n        }\n        \n        // occlusion intensities\n        float os\t= max(ps1 - ps2, 0.0);\n        float ow\t= max(pw1 - pw2, 0.0);\n        \n\t\t// apply directional occlusion\n        vec4 vals = vec4(ps1);\n        vals *= cloudsColor;\n        vals.rgb *= (os) * cloudOccStr;\n        \n        vec4 valw = vec4(pw1);\n        valw *= waterColor;\n        valw.rgb *= (ow) * waterOccStr;\n        \n        //volDensity += 0.0;\n        \n        //if (position.y < -15000.0)\n        //    val = vec4(0,0,0,1)*10.0;\n\n        // sum\n        cloudTint += clamp(vals, 0.0, 1.0);\n        cloudTint += clamp(valw, 0.0, 1.0);\n        cloudTint += base;\n       \n    }\n    \n    cloudTint /= steps;\n    \n    return cloudTint;\n}\n\n\n// @ro - ray origin\n// @rd - ray dir\n// @sp - sphere pos\n// @sr - sphere radius\n/*float intersectSphere(vec3 ro, vec3 rd, vec3 sp, float sr)\n{\n    vec3 oc = ro - sp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - sr*sr;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return -1.0;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n\n    // if t1 is less than zero, the object is in the ray's negative direction\n    // and consequently the ray misses the sphere\n    if (t1 < 0.0)\n        return -1.0;\n\n    // if t0 is less than zero, the intersection point is at t1\n    if (t0 < 0.0) {\n        return t1;\n    } else {\n        return t0; \n    }\n}*/\n\n// raymarched fur method.\n/*vec4 computeFur(vec3 rd, vec3 ta)\n{\n    const float ballSize \t= 700.0;\n    \n    const float prec \t\t= 10.0;\n    const float threshold \t= 0.5;\n    \n    const vec4 furColor \t= vec4(1.0);\n    const float furSteps \t= 15.0;\n    const float furStepSize = ballSize / furSteps;\n    \n    const vec3 pShere = vec3(0,0,-steps*stepSize);\n   \n    vec4 color = vec4(0.0);\n    \n    float t = intersectSphere( ta, rd, pShere, ballSize );\n      \n    if ( t != -1.0 )\n    {\n        float ang = iTime * 0.1;\n        float x\t  = ang;\n        float y\t  = -ang;\n        \n        for (float i=0.0; i < furSteps; i++)\n        {              \n        \tvec3 p = ta + rd*t + normalize(rd) * i * furStepSize;\n            \n            vec3 d = normalize(pShere - p);\n            float r = length(pShere - p);\n            \n            if ( r > ballSize )\n                return color;\n               // return vec4(1, 0, 0, 1);\n            \n            float intensity = pow(r, 2.0) / ballSize;\n            if ( r / ballSize <= 0.99 )\n                intensity = 0.1;\n            \n            //if (intensity > 500000000000000000.0)\n           //     return vec4(0);\n                \n            float U = ((-d.z/abs(d.x)) + 1.0)/2.0 + x;\n            float V = ((-d.y/abs(d.x)) + 1.0)/2.0 + y;\n            \n            if ( U*prec - floor(U * prec) >= threshold )\n            {\n                if ( V*prec - floor(V * prec) >= threshold )\n                {\n                    //vec4 temp = furColor;// * (1.0 / furSteps);\n                    //temp.rgb *= intensity;\n               \t\tcolor += furColor * (intensity);\n                    \n                    break;\n                    //color += furColor * furSteps;\n                    //return color; //vec4(100000.0);\n                }\n            }\n            \n            //if (color.a > 1.0)\n            //    return vec4(1);\n\n        }\n        \n    }\n    \n    return color;\n}*/\n\n\n\n// Camera to world transformation\n// @ ro - rotation\n// @ ta - translation\n// @ cr - 0.0\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // aquire frag & mouse coords\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// set camera rotation\n\tvec3 ro \t= vec3(mo.x * 5.0, mo.y * 5.0, 1) * 150.0;\n\n    // camera translation\n    vec3 ta \t= vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca \t= setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd \t= ca * normalize( vec3(p.xy,2.0) );\n    \n    // raymarch clouds\n    vec4 clouds = computeClouds(ta, rd);\n    \n    // gen sky\n    vec4 sk\t\t= sky(rd, 1.0 - clouds.a);\n    \n    // raymarch fur\n    //vec4 fur \t= computeFur(rd, ta);\n    //fur.a = 1.0;\n    \n    // sum colors\n    fragColor   = clamp(clouds + sk, 0.0, 1.0);// + fur;\n\n}","name":"Image","description":"","type":"image"}]}