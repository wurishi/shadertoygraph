{"ver":"0.1","info":{"id":"3ljBDG","date":"1599754144","viewed":196,"name":"like waterfall?","username":"blue1784","description":"colorful lines falling down...","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)));\n\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nconst float F2 = 0.5f *(sqrt(3.0) - 1.0);\nconst float G2 = (3.0-sqrt(3.0))/6.0;\n\nfloat simplex_noise_2d(vec2 p) \n{\n    float n0, n1, n2; \n    \n    float s = (p.x + p.y) * F2; \n    vec2 pi = floor(p + vec2(s));\n    float t = (pi.x + pi.y) * G2;\n    vec2 pf = p - (pi - vec2(t));\n\n    vec2 dp;\n    if(pf.x > pf.y) {dp.x=1.; dp.y=0.;}\n    else {dp.x = 0.; dp.y=1.;}      \n    vec2 pf1 = pf - dp + vec2(G2);\n    vec2 pf2 = pf - vec2(1.0 - 2.0 * G2);\n\n    float t0 = 0.5 - pf.x * pf.x - pf.y * pf.y;\n    if(t0<0.) n0 = 0.0;\n    else {\n      t0 *= t0;\n      n0 = t0 * t0 * dot(hash22(pi), pf);\n    }\n    float t1 = 0.5 - pf1.x * pf1.x - pf1.y * pf1.y;\n    if(t1 < 0.) n1 = 0.0;\n    else {\n      t1 *= t1;\n      n1 = t1 * t1 * dot(hash22(pi + dp), pf1);\n    }\n    float t2 = 0.5 - pf2.x * pf2.x -pf2.y * pf2.y;\n    if(t2<0.) n2 = 0.0;\n    else {\n      t2 *= t2;\n      n2 = t2 * t2 * dot(hash22(pi + vec2(1.0)), pf2);\n    }\n    return 70.0 * (n0 + n1 + n2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // making colorful lines\n    float lines = float(int(fragCoord.x) / 20);\n    float blackLines = step(10.1, float(int(fragCoord.x) % 20));\n    float seed = sin(lines + iTime);\n    // may better way to transform float to RGB instead?\n    vec3 color = vec3(seed, 4. * seed * (1. - seed), 1. - seed) * seed * blackLines;\n    \n    float noise = mix(0., 1., simplex_noise_2d(vec2(lines, 2.)));\n    float another_noise = mix(0., .5, simplex_noise_2d(vec2(lines, 3.)));\n   \n    float maxLen = 1.;\n    // edit to change line falling speed\n    float fallSpeed = .3;\n    // randomize line start position and move line start position down by time\n  \tfloat lineStart = fract(noise - iTime * fallSpeed) * maxLen;\n    // randomize line end position\n    float lineEnd = .4 + another_noise;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float len = uv.y;\n    float upper = step(len, lineStart);\n    float deltaLen = abs(len - lineStart);\n    // distance from current y to line start\n    deltaLen = upper * (maxLen - deltaLen) + (1. - upper) * deltaLen;\n    // interpolate attenuation by distance \n    float attenuation = mix(1., 0., min(deltaLen, lineEnd) / lineEnd);\n    color *= attenuation;\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}