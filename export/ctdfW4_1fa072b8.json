{"ver":"0.1","info":{"id":"ctdfW4","date":"1702149632","viewed":18,"name":"Projet-Cécile","username":"Cecile89","description":"Projet du cours de Graphisme","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["projetpersonnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    vec3 vertical = vec3(0,0,1);\n    C.Obs = Obs;\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(vertical,C.View));\n    C.Up = normalize(cross(C.View,C.Horiz));\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = (C.H/2.) / tan(aperture/360.*3.14);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   vec3 p = C.Obs + C.z*C.View + (XY.x - C.W/2.)*C.Horiz + (XY.y - C.H/2.)*C.Up;\n   r.Dir = p - C.Obs;\n   return r;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n   vec3 color;\n};\n\nstruct Plan { //horizontal infini\n    vec3 Origin;\n    vec3 Dir;\n    float H;\n    vec3 Normale;\n    vec3 color;\n};\n\nstruct Disque{\n    vec3 Origin;\n    vec3 Normale;\n    float R;\n    vec3 color;\n};\n\nstruct Lumiere {\n   vec3 Center;\n   vec3 Color;\n};\n\nstruct Cylindre {\n    vec3 Origin;\n    vec3 Dir;\n    float H;\n    float R;\n    vec3 color_ext;\n    vec3 color_int;\n};\n\nstruct Dome { //sphère avec normale\n   vec3 Center;\n   float R;\n   vec3 normale;\n   vec3 color;\n};\n\nstruct Ellipse {\n    vec3 Origin;\n    vec3 d1;\n    vec3 d2;\n    vec3 normale;\n    float demi_longueur; //grand axe\n    float demi_largeur; //petit axe\n    vec3 color;\n};\n\n//Nb de chaque type d'objet\nconst int nb_lum = 2;\nconst int nb_sph = 4;\nconst int nb_plan = 1;\nconst int nb_dis = 6;\nconst int nb_cyl = 7;\nconst int nb_dome = 1;\nconst int nb_el = 1;\n\n//Fonctions d'intersection des objets (doivent être mises en premier pour pouvoir les utiliser après)\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    float a = pow(length(R.Dir),2.);\n    float b = 2.*dot(R.Dir,R.Origin-S.Center);\n    float c = pow(length(R.Origin-S.Center),2.)-pow(S.R,2.);\n    float discriminant = pow(b,2.)-4.*a*c;\n    if (discriminant >= 0.){\n        //toujours prendre t1 (point qu'on rencontre en premier)\n        t = (-b - sqrt(discriminant)) / (2.*a); //distance entre C.Obs et point M d'intersection entre la sphère et R.Dir\n        if (t < 0.){\n            t=0.;\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n\nbool intersect_plan_horizontal_infini(in Ray R, in Plan plan, out float tp) {\n    if (abs(dot(R.Dir,plan.Normale))<=0.0001){ //si le rayon et le plan sont parallèles\n        return false;\n    }\n    tp = (plan.H-R.Origin.z)/R.Dir.z; //distance du plan par rapport à l'origine du rayon\n    if (tp > 0.){\n          return true;\n    }  \n    return false;\n}\n\nbool intersect_disque(in Ray R, in Disque d,out float td){\n    if (dot(R.Dir,normalize(d.Normale)) == 0.){ //si plan parallèle au rayon (de plus X inversible si n.dr != 0)\n        return false;\n    }\n    \n    //Eq intersection entre droite et plan\n    td = -(dot(d.Normale,R.Origin) - dot(d.Normale,d.Origin))/(dot(R.Dir,d.Normale));\n    \n    if (td > 0.){\n          vec3 Md = R.Origin+td*R.Dir; //point du plan que je regarde\n          if (length(Md-d.Origin)<=d.R){ //si le point est dans le rayon du cercle\n              return true;\n          }\n    }\n    td = 0.; //sinon le plan a une ombre sur les autres objets alors qu'il n'existe pas à cet endroit là quand t > 0. mais ne répond pas à la 2e condition\n    return false;\n}\n\nbool intersect_cylindre(in Ray R, in Cylindre Cyl, out float t1, out float t2) {\n    vec3 x = R.Dir - (dot(Cyl.Dir,R.Dir)*Cyl.Dir);\n    vec3 y = R.Origin - Cyl.Origin - (dot((R.Origin-Cyl.Origin),Cyl.Dir)*Cyl.Dir);\n    \n    float a = dot(x,x); \n    float b = 2.*dot(x,y); \n    float c = dot(y,y) - pow(Cyl.R,2.);\n    \n    float determinant = pow(b,2.) - 4.*a*c;\n    \n    if (determinant >= 0.){\n        t1 = (-b - sqrt(determinant))/(2.*a);\n        t2 = (-b + sqrt(determinant))/(2.*a);\n        if (t1 >= 0.){\n            vec3 M = R.Origin + t1*R.Dir; //point que je regarde\n            vec3 Mproj = Cyl.Origin + dot(Cyl.Dir,M-Cyl.Origin)*Cyl.Dir; //projeté de M sur l'axe du cylindre\n            if (length(Mproj-Cyl.Origin) < Cyl.H/2.){\n                return true;\n            }\n            else{ //sinon c'est comme si le cylindre était là alors que non : quand t1 est trop grand, il est toujours pris en compte par la lumière car c'est vu comme le premier objet qu'on rencontre\n                t1 = 0.;\n            }\n        }\n        if(t2 >= 0.){\n            vec3 M = R.Origin + t2*R.Dir;\n            vec3 Mproj = Cyl.Origin + dot(Cyl.Dir,M-Cyl.Origin)*Cyl.Dir; //projeté de M sur l'axe du cylindre\n            if (length(Mproj-Cyl.Origin) < Cyl.H/2.){\n                return true;\n            }\n            else{\n                t2 = 0.;\n            }\n        }\n    }\n    return false;\n}\n\nbool intersect_dome(in Ray R, in Dome D, out float t) {\n    //Même équation que la sphère\n    float a = pow(length(R.Dir),2.);\n    float b = 2.*dot(R.Dir,R.Origin-D.Center);\n    float c = pow(length(R.Origin-D.Center),2.)-pow(D.R,2.);\n    float discriminant = pow(b,2.)-4.*a*c;\n    if (discriminant >= 0.){\n        t = (-b - sqrt(discriminant)) / (2.*a);\n        if (t < 0.){\n            t=0.;\n            return false;\n        }\n        vec3 Md = R.Origin+t*R.Dir; //point du dome que je regarde\n        vec3 OM = Md-D.Center;\n        if (dot(D.normale,OM) > 0.){ //on garde que la moitié de la sphère pour faire un dome\n            return true;\n        }\n        else{\n            t = 0.; //on est pas dans le dome, t ne doit pas avoir d'effet\n        }\n    }\n    return false;\n}\n\nbool intersect_ellipse(in Ray R, in Ellipse e, out float te) {\n    vec3 normale = cross(e.d1,e.d2);\n    if (dot(normale,R.Dir)==0.){ //X inversible si n.dr != 0\n        return false;\n    }\n    mat3 X = mat3(R.Dir,-e.d1,-e.d2);\n    vec3 V0 = e.Origin - R.Origin;\n    vec3 C = inverse(X)*V0;\n    te = C.x; //distance du plan par rapport à l'origine du rayon\n    if (te > 0.){\n          vec3 Me = R.Origin+te*R.Dir; //point du plan que je regarde\n          vec3 OM = (Me-e.Origin);\n          if (pow(Me.x/e.demi_longueur,2.) + pow(Me.y/e.demi_largeur,2.) <= 1. && dot(e.d2,OM) >= 0.){//si on est dans l'ellipse et dans une des moitiés selon l'axe des y (d2=(0,1,0))\n              return true;\n          }\n          else{ //on est pas sur l'ellipse, t ne doit pas avoir d'effet\n              te = 0.;\n          }\n    }\n    return false;\n}\n\n//Fonctions d'interaction avec la lumière\n\nbool in_shadow(in vec3 M, in Sphere liste_spheres[nb_sph],in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis],in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],in Lumiere Lum){\n    //traitement des ombres\n    //Nouveau rayon entre le point qu'on regarde et lumière\n    Ray R; R.Origin = M; R.Dir = Lum.Center - M; //si pas normalisé, c la distance entre ma source de lumière et S    \n    float tx;\n    float tbis;\n    \n    //On regarde si un objet se trouve entre la lumière et le point M qu'on regarde\n    \n    //on regarde par rapport aux sphères\n    for (int i = 0; i < liste_spheres.length(); i++){\n        if (intersect_sphere(R,liste_spheres[i],tx)){\n            if (.0001 < tx && tx < 1.){\n                return true;\n            }\n        }\n    }\n    \n    //on regarde par rapport aux plans\n    for (int i = 0; i < liste_plans.length(); i++){\n        if (intersect_plan_horizontal_infini(R,liste_plans[i],tx)){\n            if (.0001 < tx && tx < 1.){\n                return true;\n            }\n        }\n    }\n    \n    //on regarde par rapport aux disques\n    for (int i = 0; i < liste_disques.length(); i++){\n        if (intersect_disque(R,liste_disques[i],tx)){\n            if (.0001 < tx && tx < 1.){\n                return true;\n            }\n        }\n    }\n    \n    //on regarde par rapport aux cylindres\n    //pas d'ombre sur la sphère mais je n'arrive pas à régler le pb\n    //pt prendre en compte tbis mais ça fait du bruit noir dès que je le mets...\n    for (int i = 0; i < liste_cylindres.length(); i++){\n        if (intersect_cylindre(R,liste_cylindres[i],tx,tbis)){\n            Cylindre cyl = liste_cylindres[i];\n            if (.0001 < tx && tx < 1.){\n                return true;\n            }\n        }    \n    }\n    \n    //on regarde par rapport aux domes\n    for (int i = 0; i < liste_domes.length(); i++){\n        if (intersect_dome(R,liste_domes[i],tx)){\n            if (.0001 < tx && tx < 1.){\n                return true;\n            }\n        }\n    }\n    \n    //on regarde par rapport aux ellipses\n    for (int i = 0; i < liste_ellipses.length(); i++){\n        if (intersect_ellipse(R,liste_ellipses[i],tx)){\n            if (.0001 < tx && tx < 1.){\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nvec3 interact_lum_sphere(in Ray R, in Lumiere liste_lumieres[nb_lum], in Sphere S, in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis], in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],in float t){ //définir la bonne couleur\n    vec3 col_s;\n    vec3 M = R.Origin + t*R.Dir; //point de l'objet que je regarde\n    vec3 n = normalize(M-S.Center);\n    for (int i = 0; i < liste_lumieres.length();i++){ //pour chaque lumière\n        vec3 d = normalize(liste_lumieres[i].Center-M); \n\n        float cosTheta = dot(n,d);\n        //si angle < 0 ou un objet fait de l'ombre\n        if ((cosTheta < 0.) || in_shadow(M,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,liste_lumieres[i])){\n            cosTheta = 0.;\n        }    \n        //sinon couleur en fonction de celle des différentes lumières et angle\n        col_s += S.color*liste_lumieres[i].Color*cosTheta;\n    }\n    return col_s;\n}\n\nvec3 interact_lum_plan(in Ray R, in Lumiere liste_lumieres[nb_lum], in Plan plan, in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis], in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],in float t){ //définir la bonne couleur\n    vec3 col_s;\n    vec3 M = R.Origin + t*R.Dir; //point du plan que je regarde\n    vec3 n = normalize(plan.Normale);\n    for (int i = 0; i < liste_lumieres.length();i++){\n        vec3 d = normalize(liste_lumieres[i].Center-M); \n\n        float cosTheta = dot(n,d);\n        if ((cosTheta < 0.) || in_shadow(M,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,liste_lumieres[i])){\n            cosTheta = 0.;\n        }    \n        col_s += plan.color*liste_lumieres[i].Color*cosTheta;\n    }\n    return col_s;\n}\n\nvec3 interact_lum_disque(in Ray R, in Lumiere liste_lumieres[nb_lum], in Disque disque,in Sphere liste_spheres[nb_sph],in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis], in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],in float t){ //définir la bonne couleur\n    vec3 col_s;\n    vec3 M = R.Origin + t*R.Dir; //point du plan que je regarde\n    vec3 n = normalize(disque.Normale);\n    for (int i = 0; i < liste_lumieres.length();i++){\n        vec3 d = normalize(liste_lumieres[i].Center-M); \n\n        float cosTheta = dot(n,d);\n        if ((cosTheta < 0.) || in_shadow(M,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,liste_lumieres[i])){\n            cosTheta = 0.;\n        }  \n        col_s += disque.color*liste_lumieres[i].Color*cosTheta;\n    }\n    return col_s;\n}\n\nvec3 interact_lum_cylindre_empty_outside(in Ray R, in Lumiere liste_lumieres[nb_lum], in Cylindre Cyl, in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis],in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],in float t){ //définir la bonne couleur\n    vec3 col_s;\n    vec3 M = R.Origin + t*R.Dir; //point de l'objet que je regarde\n    vec3 Mproj = Cyl.Origin + dot(Cyl.Dir,M-Cyl.Origin)*Cyl.Dir; //projeté de M sur l'axe du cylindre\n    vec3 n = normalize(M-Mproj); //normale qui va vers l'extérieur\n    for (int i = 0; i < liste_lumieres.length();i++){\n        vec3 d = normalize(liste_lumieres[i].Center-M); \n\n        float cosTheta = dot(n,d);\n        if ((cosTheta < 0.) || in_shadow(M,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,liste_lumieres[i])){\n            cosTheta = 0.;\n        }    \n        col_s += Cyl.color_ext*liste_lumieres[i].Color*cosTheta;\n    }\n    return col_s;\n}\n\nvec3 interact_lum_cylindre_empty_inside(in Ray R, in Lumiere liste_lumieres[nb_lum], in Cylindre Cyl, in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis],in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],in float t){ //définir la bonne couleur\n    vec3 col_s;\n    vec3 M = R.Origin + t*R.Dir; //point de l'objet que je regarde\n    vec3 Mproj = Cyl.Origin + dot(Cyl.Dir,M-Cyl.Origin)*Cyl.Dir; //projeté de M sur l'axe du cylindre\n    vec3 n = -normalize(M-Mproj); //normale qui va vers l'intérieur\n    \n    for (int i = 0; i < liste_lumieres.length();i++){//pour chaque lumière\n        Lumiere lum_x = liste_lumieres[i];\n        vec3 d = normalize(lum_x.Center-M);\n        float cosTheta = dot(n,d);\n        \n        //Regarde si la lumière en question éclaire l'intérieur du cylindre\n        Ray Rayon; Rayon.Origin = lum_x.Center; Rayon.Dir = -d; //rayon du centre de la lumière au point M\n        float tc1; float tc2;\n        bool isvisible_Cyl = intersect_cylindre(Rayon,Cyl,tc1,tc2);\n        \n        //conditions habituelles + si la lumière rencontre deux points => dans l'ombre\n        if ((cosTheta < 0.) || (tc1>0. && tc2>0.) || in_shadow(M,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,lum_x)){\n            cosTheta = 0.;\n        }    \n        col_s += Cyl.color_int*lum_x.Color*cosTheta;\n    }\n    return col_s;\n}\n\nvec3 interact_lum_Dome(in Ray R, in Lumiere liste_lumieres[nb_lum], in Dome D, in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis],in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],in float t){ //définir la bonne couleur\n    vec3 col_s;\n    vec3 M = R.Origin + t*R.Dir; //point de l'objet que je regarde\n    vec3 n = normalize(M-D.Center);\n    for (int i = 0; i < liste_lumieres.length();i++){\n        vec3 d = normalize(liste_lumieres[i].Center-M); \n\n        float cosTheta = dot(n,d);\n        if ((cosTheta < 0.) || in_shadow(M,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,liste_lumieres[i])){\n            cosTheta = 0.;\n        }    \n        col_s += D.color*liste_lumieres[i].Color*cosTheta;\n    }\n    return col_s;\n}\n\nvec3 interact_lum_ellipse(in Ray R, in Lumiere liste_lumieres[nb_lum], in Ellipse ellipse, in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis],in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],in float t){ //définir la bonne couleur\n    vec3 col_s;\n    vec3 M = R.Origin + t*R.Dir; //point du plan que je regarde\n    vec3 n = normalize(ellipse.normale);\n    for (int i = 0; i < liste_lumieres.length();i++){\n        vec3 d = normalize(liste_lumieres[i].Center-M); \n\n        float cosTheta = dot(n,d);\n        if ((cosTheta < 0.) || in_shadow(M,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,liste_lumieres[i])){\n            cosTheta = 0.;\n        }    \n        col_s += ellipse.color*liste_lumieres[i].Color*cosTheta;\n    }\n    return col_s;\n}\n\n//Fonctions pour factoriser code\n\nvoid show_cylindre(in Cylindre Cyl,in Ray R,out float min_t,in Lumiere liste_lumieres[nb_lum],in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis],in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],out vec4 fragColor){\n    float tc1; float tc2;\n    bool isvisible_Cyl = intersect_cylindre(R,Cyl,tc1,tc2);\n\n    if (isvisible_Cyl){\n        if (tc1 > 0. && tc1 < min_t){ //rayon rencontre l'extérieur du cylindre\n            min_t = tc1;\n            vec3 color = interact_lum_cylindre_empty_outside(R,liste_lumieres,Cyl,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,tc1);\n            fragColor = vec4(color,1.);\n        }\n        else if (tc2 > 0. && tc2 < min_t){ //rayon rencontre l'intérieur du cylindre\n            min_t = tc2;\n            vec3 color = interact_lum_cylindre_empty_inside(R,liste_lumieres,Cyl,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,tc2);\n            fragColor = vec4(color,1.);\n        }\n    }  \n}\n\nvoid show_sphere(in Sphere S,in Ray R,out float min_t,in Sphere lune,in Lumiere liste_lumieres[nb_lum],in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis],in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],out vec4 fragColor){\n    float ts;\n    bool isVisible_S = intersect_sphere(R,S,ts);\n    \n    if (S != lune && isVisible_S && ts < min_t){ //la lune a un traitement spécial à cause de la texture\n        min_t = ts;\n        vec3 col_S = interact_lum_sphere(R,liste_lumieres,S,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,ts);\n        fragColor = vec4(col_S,1.);\n    }\n}\n\nvoid show_disque(in Disque D,in Ray R,out float min_t,in Lumiere liste_lumieres[nb_lum],in Sphere liste_spheres[nb_sph], in Plan liste_plans[nb_plan],in Disque liste_disques[nb_dis],in Cylindre liste_cylindres[nb_cyl],in Dome liste_domes[nb_dome],in Ellipse liste_ellipses[nb_el],out vec4 fragColor){\n    float td;\n    bool isVisible_disque = intersect_disque(R,D,td);\n  \n    if (isVisible_disque && td < min_t){ // si le disque est le plus proche à ce point donné, il est affiché\n        min_t = td;\n        vec3 col_d = interact_lum_disque(R,liste_lumieres,D,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,td);\n        fragColor = vec4(col_d,1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {//appliquée sur chacun des pixels\n//langage = GLSL\n\n   //Caméra\n   Camera C = camera(\n       vec3(cos(iTime*.25)*8.5,+sin(iTime*.25)*8.5, 4.5),\n       vec3(0., 0., 3.5),\n       50.0       \n   );\n   \n  vec2 uv = fragCoord/iResolution.xy;\n  fragColor = vec4(0.,0.1,0.6,1.); //couleur du fond\n  \n  //Rayon\n  Ray R = launch(C,fragCoord);\n  float min_t = 9999999999999999999999999999999999999.; //distance du plus proche objet, initialisée très grande\n \n  //Lumière(s)\n  Lumiere liste_lumieres[nb_lum]; //Lum1.Center = vec3(-3.,-3.,4.5);\n  Lumiere Lum1; Lum1.Center = vec3(0.,-1200.,800.); Lum1.Color = vec3(0.9,0.4,0.);\n  Lumiere Lum2; Lum2.Center = vec3(-2.,4.,4.5); Lum2.Color = vec3(1.,1.,.9);\n  liste_lumieres[0]=Lum1;\n  liste_lumieres[1]=Lum2;\n  \n  \n  //Sphère(s)\n  Sphere lune; lune.Center = vec3(0.,20.,10.5+cos(iTime*1.25)); lune.R = 2.; lune.color = vec3(.9,.9,.9);\n  \n  Sphere tete; tete.Center = vec3(0.,0.,3.1); tete.R = .6; tete.color = vec3(1.,0.9,0.9);\n \n  Sphere oeil_g; oeil_g.Center = vec3(-.235,.5,tete.Center.z+.17); oeil_g.R = .05; oeil_g.color = vec3(0.,0.,0.);\n  \n  Sphere oeil_d; oeil_d.Center = vec3(.235,.5,tete.Center.z+.17); oeil_d.R = .05; oeil_d.color = vec3(0.,0.,0.);\n  \n  //source de lumière matérialisée\n  Sphere orbe; orbe.Center = Lum2.Center; orbe.R = .3; orbe.color = Lum2.Color;\n  \n  Sphere liste_spheres[nb_sph];\n  liste_spheres[0]=lune;\n  liste_spheres[1]=tete;\n  liste_spheres[2]=oeil_g;\n  liste_spheres[3]=oeil_d;\n  //on ne met pas l'orbe car elle ne fait pas d'ombre et n'a pas d'effet sur les autres objets\n  \n  //Cylindre(s)\n  Cylindre anneau;\n  anneau.Origin = lune.Center;\n  anneau.Dir = normalize(vec3(0.,cos(iTime*.7),sin(iTime*.7))); //normaliser sinon c'est bizarre\n  anneau.H = 0.2;\n  anneau.R = 3.5;\n  anneau.color_ext = vec3(1.,.5,0.);\n  anneau.color_int = vec3(1.,1.,1.);\n  \n  //tous les cylindres représentant le corps du personnage sont directement ou indirectement liés aux coordonnées de la tête\n  Cylindre cou;\n  cou.H = .3;\n  cou.R = .24;\n  cou.Origin = vec3(tete.Center.x,tete.Center.y,tete.Center.z-tete.R-(cou.H/2.)+.1);\n  cou.Dir = normalize(vec3(0.,0.,1.)); //normaliser sinon c'est bizarre\n  cou.color_ext = tete.color;\n  cou.color_int = vec3(0.,0.,0.);\n  \n  Cylindre bras_gauche;\n  bras_gauche.H = 2.6;\n  bras_gauche.R = .2;\n  bras_gauche.Dir = normalize(vec3(-1.,0.,1.));\n  bras_gauche.Origin = vec3(cou.Origin.x-.61, cou.Origin.y, cou.Origin.z-.3)+(bras_gauche.Dir);\n  bras_gauche.color_ext = vec3(.5,0.,.5);\n  bras_gauche.color_int = vec3(0.,0.,0.);\n  \n  Cylindre bras_droit;\n  bras_droit.H = bras_gauche.H;\n  bras_droit.R = bras_gauche.R;\n  bras_droit.Dir = normalize(vec3(1.,0.,1.));\n  bras_droit.Origin = vec3(cou.Origin.x+.61, cou.Origin.y, cou.Origin.z-.3) + (bras_droit.Dir);\n  bras_droit.color_ext = bras_gauche.color_ext;\n  bras_droit.color_int = bras_gauche.color_int;\n  \n  Cylindre torse;\n  torse.H = 2.;\n  torse.R = .5;\n  torse.Origin = vec3(cou.Origin.x,cou.Origin.y,cou.Origin.z-((cou.H/2.)+(torse.H/2.)));\n  torse.Dir = cou.Dir;\n  torse.color_ext = vec3(.5,0.,.5);\n  torse.color_int = vec3(0.,0.,0.);\n  \n  Cylindre jambe_gauche;\n  jambe_gauche.H = 2.6;\n  jambe_gauche.R = .2;\n  jambe_gauche.Dir = normalize(vec3(0.,1.,-1.));\n  jambe_gauche.Origin = vec3(torse.Origin.x-.28, torse.Origin.y+.2, torse.Origin.z-(torse.H/2.))+(jambe_gauche.Dir);\n  jambe_gauche.color_ext = vec3(0.,.5,.5);\n  jambe_gauche.color_int = vec3(0.,0.,0.);\n  \n  Cylindre jambe_droite;\n  jambe_droite.H = jambe_gauche.H;\n  jambe_droite.R = jambe_gauche.R;\n  jambe_droite.Dir = normalize(vec3(0.,-1.,-1.));\n  jambe_droite.Origin = vec3(torse.Origin.x+.28, torse.Origin.y-0.2, torse.Origin.z-(torse.H/2.)) + (jambe_droite.Dir); //quand bras vers l'avant\n  jambe_droite.color_ext = jambe_gauche.color_ext;\n  jambe_droite.color_int = jambe_gauche.color_int;\n  \n  Cylindre liste_cylindres[nb_cyl];\n  liste_cylindres[0] = anneau;\n  liste_cylindres[1] = cou;\n  liste_cylindres[2] = bras_gauche;\n  liste_cylindres[3] = bras_droit;\n  liste_cylindres[4] = jambe_gauche;\n  liste_cylindres[5] = jambe_droite;\n  liste_cylindres[6] = torse;\n\n  //Plan(s)\n  Plan sol; sol.H = -1.5; sol.Origin = vec3(0.,0.,sol.H);\n  sol.Normale = normalize(vec3(0.,0.,1.));\n  sol.Dir = vec3(1.,0.,0.);\n  sol.color = vec3(0.3,0.5,0.4);\n   \n  Plan liste_plans[nb_plan];\n  liste_plans[0]=sol;\n  \n  \n  //Disque(s)\n  Disque soleil; soleil.Origin = vec3(0.,-1500.,0.); soleil.R = 200.;soleil.Normale=vec3(0.,1.,0.);\n  soleil.color=Lum1.Color;\n  \n  //Disques pour fermer le cylindre représentant le torse\n  Disque haut_torse;\n  haut_torse.Origin = vec3(torse.Origin.x,torse.Origin.y,torse.Origin.z+(torse.H/2.));\n  haut_torse.R = torse.R;\n  haut_torse.Normale = vec3(0.,0.,1.); //normalisée dans les calculs, produit est pas commutatif\n  haut_torse.color = torse.color_ext;\n  \n  Disque bas_torse;\n  bas_torse.Origin = vec3(torse.Origin.x,torse.Origin.y,torse.Origin.z-(torse.H/2.));\n  bas_torse.R = torse.R;\n  bas_torse.Normale = haut_torse.Normale; //normalisée dans les calculs, produit est pas commutatif\n  bas_torse.color = torse.color_ext;\n  \n  //Disques pour fermer les cylindres ouverts représentant les bras et les jambes\n  Disque jg;\n  jg.Origin = jambe_gauche.Origin+normalize(jambe_gauche.Dir)*(jambe_gauche.H/2.);\n  jg.Normale = -jambe_gauche.Dir;\n  jg.R = jambe_gauche.R;\n  jg.color = jambe_gauche.color_ext;\n  \n  Disque jd;\n  jd.Origin = jambe_droite.Origin+normalize(jambe_droite.Dir)*(jambe_droite.H/2.);\n  jd.Normale = -jambe_droite.Dir;\n  jd.R = jambe_droite.R;\n  jd.color = jambe_droite.color_ext;\n  \n  Disque mg;\n  mg.Origin = bras_gauche.Origin+normalize(bras_gauche.Dir)*(bras_gauche.H/2.);\n  mg.Normale = bras_gauche.Dir;\n  mg.R = bras_gauche.R;\n  mg.color = bras_gauche.color_ext;\n  \n  Disque md;\n  md.Origin = bras_droit.Origin+normalize(bras_droit.Dir)*(bras_droit.H/2.);\n  md.Normale = bras_droit.Dir;\n  md.R = bras_droit.R;\n  md.color = bras_droit.color_ext;\n  \n  \n  Disque liste_disques[nb_dis];\n  liste_disques[0]=haut_torse;\n  liste_disques[1]=bas_torse;\n  liste_disques[2]=jg;\n  liste_disques[3]=jd;\n  liste_disques[4]=mg;\n  liste_disques[5]=md;\n  //on met pas le soleil pour pas qu'il ait d'ombre et ne fasse d'ombre\n\n  \n  //Ellipse(s)\n  Ellipse E;\n  E.Origin = vec3(tete.Center.x,tete.Center.y,tete.Center.z+0.35);\n  E.d1 = vec3(1.,0.,0.); E.d2 = vec3(0.,1.,0.);\n  E.normale = cross(E.d1,E.d2); //produit est pas commutatif, intervient dans intersect et interact_lum\n  \n  //Equation : (x/demi-longueur)**2 + (y/demi-largeur)**2 = 1\n  //Axe x du référentiel de l'ellipse est l'axe y global, et axe y de l'ellipse est l'axe x global pour E\n  //Plutôt que de calculer les coordonnées de M par rapport au référentiel de l'ellipse, comme je manque de temps\n  //et qu'il suffit d'inverser le x et y pour cette ellipse, j'inverse les valeurs des demi-longueur/largeur.\n  E.demi_longueur=tete.R; E.demi_largeur=1.1;\n  E.color = vec3(.4,.3,.3);\n  \n  Ellipse liste_ellipses[nb_el];\n  liste_ellipses[0]=E;\n  \n  \n  //Dome(s)\n  Dome haut_casquette;\n  haut_casquette.Center = E.Origin; haut_casquette.R = tete.R; haut_casquette.normale=E.normale; \n  haut_casquette.color = E.color;\n   \n  Dome liste_domes[nb_dome];\n  liste_domes[0]=haut_casquette;\n  \n  \n  //Affichage plan\n  float tsol;\n  bool isVisible_sol = intersect_plan_horizontal_infini(R,sol,tsol);\n  if (isVisible_sol && tsol < min_t){ //si le plan est visible par la caméra et est le plus proche à ce point donné\n      min_t = tsol;\n      //détermination de la couleur du pixel en rapport avec la couleur de l'objet, les lumières et les ombres des autres objets\n      vec3 col_p = interact_lum_plan(R,liste_lumieres,sol,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,tsol);\n      fragColor = vec4(col_p,1.);\n  }\n  \n  //Affichage sphères\n  for (int i = 0; i < liste_spheres.length(); i++){\n      show_sphere(liste_spheres[i],R,min_t,lune,liste_lumieres,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,fragColor);\n  }\n \n  //Orbe de lumière\n  float to;\n  bool isVisible_orbe = intersect_sphere(R,orbe,to);\n    \n  if (isVisible_orbe && to < min_t){ //si visible par la caméra et c'est objet le plus proche\n      min_t = to;\n      fragColor = vec4(orbe.color,1.); //on l'affiche sans ombre\n  }\n  \n  float tlune;\n  bool isVisible_lune = intersect_sphere(R,lune,tlune);\n  if (isVisible_lune && tlune < min_t){\n      min_t = tlune;\n      vec3 Mlune = R.Origin + tlune*R.Dir; //point de la lune que je regarde\n      \n      //Conversion des coord du point d'intersection M en coordonnées sphériques\n      float theta = atan(Mlune.y - lune.Center.y, Mlune.x - lune.Center.x);\n      float phi = acos((Mlune.z - lune.Center.z) / lune.R);\n\n      //Conversion des coordonnées sphériques en coordonnées UV = on mappe les coord sphériques sur les coord UV\n      float PI = 3.14159265359;\n      vec2 sphereUV = vec2(theta / (2.0 * PI), phi / PI);\n\n      //Texture\n      vec3 textureColor = texture(iChannel0, sphereUV).xyz;\n\n      // On donne la couleur finale\n      lune.color = mix(textureColor, lune.color,.6);\n      vec3 finalColor = interact_lum_sphere(R,liste_lumieres,lune,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,tlune);\n      fragColor = vec4(finalColor,1.);\n  }\n  \n  //Affichage cylindres ouverts\n  for (int i = 0; i < liste_cylindres.length(); i++){\n      show_cylindre(liste_cylindres[i],R,min_t,liste_lumieres,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,fragColor);\n  }\n  \n  //Affichage disques\n  for (int i = 0; i < liste_disques.length(); i++){\n      show_disque(liste_disques[i],R,min_t,liste_lumieres,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,fragColor);\n  }\n  \n  float tsoleil;\n    bool isVisible_soleil = intersect_disque(R,soleil,tsoleil);\n  \n    if (isVisible_soleil && tsoleil < min_t){ // si le disque est le plus proche à ce point donné, il est affiché\n        min_t = tsoleil;\n        vec3 col_soleil = interact_lum_disque(R,liste_lumieres,soleil,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,tsoleil);\n        fragColor = vec4(col_soleil,1.);\n    }\n  \n  //Affichage ellipse\n  float te;\n  bool isVisible_ellipse = intersect_ellipse(R,E,te);\n  if (isVisible_ellipse && te < min_t){\n      min_t = te;\n      vec3 col_p = interact_lum_ellipse(R,liste_lumieres,E,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,te);\n      fragColor = vec4(col_p,1.);\n  }\n    \n  //Affichage dome\n  float td;\n  bool isVisible_dome = intersect_dome(R,haut_casquette,td);\n  if (isVisible_dome && td < min_t){\n      min_t = td;\n      vec3 col_p = interact_lum_Dome(R,liste_lumieres,haut_casquette,liste_spheres,liste_plans,liste_disques,liste_cylindres,liste_domes,liste_ellipses,td);\n      fragColor = vec4(col_p,1.);\n  }\n}","name":"Image","description":"","type":"image"}]}