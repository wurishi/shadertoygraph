{"ver":"0.1","info":{"id":"MlBBRm","date":"1515153264","viewed":376,"name":"Normal Map Extraction","username":"kalkas","description":"Homework, 4th, normal map extraction from black&white texture","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["normalmap","heightmap","homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightPosition = vec3( 0.0, 5.0, 1.0 );\nfloat aspect_ratio;\n\nvec3 rotateZ( vec3 _vector, float _a )\n{\n    return mat3( cos( _a ), -sin( _a ), 0.0, sin( _a ), cos( _a ), 0.0, 0.0, 0.0, 1.0 ) * _vector;\n}\n\nvec2 SampleSimplest( vec2 _pos )\n{\n    vec2 curentPos;\n    vec2 uv;\n    vec2 gradient = vec2( 0.0 );\n    float offset = 0.002;\n    float factor = 10.0;\n\n    curentPos = _pos;\n    uv = curentPos / iResolution.xy;\n    uv.x *= aspect_ratio;\n    \n    gradient.x =\n        texture( iChannel0, uv + vec2( -offset, 0.0 ) ).r * factor -\n        texture( iChannel0, uv + vec2(  offset, 0.0 ) ).r * factor;\n    \n    gradient.y =\n        texture( iChannel0, uv + vec2( 0.0, -offset ) ).r * factor -\n        texture( iChannel0, uv + vec2( 0.0,  offset ) ).r * factor;\n\n    return gradient;\n}\n\n// Sobel Filter [ 3x3 | 5x5 | 7x7 ]\n// ---------------------------------\nvec2 Sample3( vec2 _pos )\n{\n    vec2 curentPos;\n    vec2 uv;\n    float sample3[ 9 ];\n    \n    float filterX[ 9 ] = float[]\n    (\n         3.0, 0.0,  -3.0,\n        10.0, 0.0, -10.0,\n         3.0, 0.0,  -3.0\n    );\n\n    float filterY[ 9 ] = float[]\n    (\n        -3.0, -10.0, -3.0,\n         0.0,   0.0,  0.0,\n         3.0,  10.0,  3.0\n    );\n\n    int i = 0;\n    for( float y = 1.0; y >= -1.0; y -= 1.0 )\n    {\n        for( float x = -1.0; x <= 1.0; x += 1.0 )\n        {\n            curentPos = _pos + vec2( x * 1.0, y * 1.0 );\n            uv = curentPos / iResolution.xy;\n            uv.x *= aspect_ratio;\n            sample3[ i ] = texture( iChannel0, uv ).r;\n            i++;\n        }\n    }\n\n    vec2 gradient = vec2( 0.0 );\n    for( int j = 0; j < 9; j++ )\n    {\n        gradient.x = gradient.x + filterX[ j ] * sample3[ j ];\n        gradient.y = gradient.y + filterY[ j ] * sample3[ j ];\n    }\n\n    return gradient;\n}\n\nvec2 Sample5( vec2 _pos )\n{\n    vec2 curentPos;\n    vec2 uv;\n    float sample3[ 25 ];\n    float filterX[25] = float[]\n    (\n        2.0, 1.0, 0.0, -1.0, -2.0,\n        3.0, 2.0, 0.0, -2.0, -3.0,\n        4.0, 3.0, 0.0, -3.0, -4.0,\n        3.0, 2.0, 0.0, -2.0, -3.0,\n        2.0, 1.0, 0.0, -1.0, -2.0\n    );\n\n    float filterY[25] = float[]\n    (\n        -2.0, -3.0, -4.0, -3.0, -2.0,\n        -1.0, -2.0, -3.0, -2.0, -1.0,\n         0.0,  0.0,  0.0,  0.0,  0.0,\n         1.0,  2.0,  3.0,  2.0,  1.0,\n         2.0,  3.0,  4.0,  3.0,  2.0\n    );\n    \n    /*float filterX[ 25 ] = float[]\n    (\n         5.0,  4.0, 0.0,  -4.0,  -5.0,\n         8.0, 10.0, 0.0, -10.0,  -8.0,\n        10.0, 20.0, 0.0, -20.0, -10.0,\n         8.0, 10.0, 0.0, -10.0,  -8.0,\n         5.0,  4.0, 0.0,  -4.0,  -5.0\n    );\n\n    float filterY[ 25 ] = float[]\n    (\n        -5.0,  -8.0, -10.0,  -8.0, -5.0,\n        -4.0, -10.0, -20.0, -10.0, -4.0,\n         0.0,   0.0,   0.0,   0.0,  0.0,\n         4.0,  10.0,  20.0,  10.0,  4.0,\n         5.0,   8.0,  10.0,   8.0,  5.0\n    );*/\n\n    int i = 0;\n    for( float y = 2.0; y >= -2.0; y -= 1.0 )\n    {\n        for( float x = -2.0; x <= 2.0; x += 1.0 )\n        {\n            curentPos = _pos + vec2( x, y );\n            uv = curentPos / iResolution.xy;\n            uv.x *= aspect_ratio;\n            sample3[ i ] = texture( iChannel0, uv ).r;\n            i++;\n        }\n    }\n\n    vec2 gradient = vec2( 0.0 );\n    for( int j = 0; j < 25; j++ )\n    {\n        gradient.x = gradient.x + filterX[ j ] * sample3[ j ];\n        gradient.y = gradient.y + filterY[ j ] * sample3[ j ];\n    }\n\n    return gradient;\n}\n\nvec2 Sample7( vec2 _pos )\n{\n    vec2 curentPos;\n    vec2 uv;\n    float sample3[ 49 ];\n    \n    float filterX[ 49 ] = float[]\n    (\n        3.0, 2.0, 1.0, 0.0, -1.0, -2.0, -3.0,\n        4.0, 3.0, 2.0, 0.0, -2.0, -3.0, -4.0,\n        5.0, 4.0, 3.0, 0.0, -3.0, -4.0, -5.0,\n        6.0, 5.0, 4.0, 0.0, -4.0, -5.0, -6.0,\n        5.0, 4.0, 3.0, 0.0, -3.0, -4.0, -5.0,\n        4.0, 3.0, 2.0, 0.0, -2.0, -3.0, -4.0,\n        3.0, 2.0, 1.0, 0.0, -1.0, -2.0, -3.0\n    );\n\n    float filterY[ 49 ] = float[]\n    (\n        -3.0, -4.0, -5.0, -6.0, -5.0, -4.0, -3.0,\n        -2.0, -3.0, -4.0, -5.0, -4.0, -3.0, -2.0,\n        -1.0, -2.0, -3.0, -4.0, -3.0, -2.0, -1.0,\n         0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,\n         1.0,  2.0,  3.0,  4.0,  3.0,  2.0,  1.0,\n         2.0,  3.0,  4.0,  5.0,  4.0,  3.0,  2.0,\n         3.0,  4.0,  5.0,  6.0,  5.0,  4.0,  3.0\n    );\n\n    int i = 0;\n    for( float y = 3.0; y >= -3.0; y -= 1.0 )\n    {\n        for( float x = -3.0; x <= 3.0; x += 1.0 )\n        {\n            curentPos = _pos + vec2( x, y );\n            uv = curentPos / iResolution.xy;\n            uv.x *= aspect_ratio;\n            sample3[ i ] = texture( iChannel0, uv ).r;\n            i++;\n        }\n    }\n\n    vec2 gradient = vec2( 0.0 );\n    for( int j = 0; j < 49; j++ )\n    {\n        gradient.x = gradient.x + filterX[ j ] * sample3[ j ];\n        gradient.y = gradient.y + filterY[ j ] * sample3[ j ];\n    }\n\n    return gradient;\n}\n//------------------------------------------------------------------------\n\nvec3 computeNormal( vec2 _pos )\n{\n    // Change filter here\n    vec2 gradient = Sample5( _pos );\n    return normalize( vec3( gradient, 1.0 - length( gradient ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aspect_ratio = iResolution.x / iResolution.y;\n    lightPosition = rotateZ( lightPosition, iTime );\n\n    vec3 fragPos3D = vec3( ( fragCoord - iResolution.xy / 2.0 ) / ( iResolution.xy / 2.0 ), 0.0 );\n    fragPos3D.x *= aspect_ratio;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= aspect_ratio;\n\n    vec3 fragNormal = computeNormal( fragCoord );\n    fragColor = texture( iChannel0, uv ).rrra;\n\n    float lightFactor = dot( normalize( lightPosition - fragPos3D ), fragNormal );\n    fragColor *= lightFactor;\n\n    // Uncomment this to see the normal map\n    //fragColor = vec4(fragNormal, 1.0);\n}","name":"Image","description":"","type":"image"}]}