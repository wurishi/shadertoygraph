{"ver":"0.1","info":{"id":"ssXGDH","date":"1615959570","viewed":149,"name":"Origami2D","username":"plosique","description":"Given a sequence of one sided reflections corresponding origami image is produced","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","geometry","origami"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool isTransformed(vec2 xy,reflection R,out float det){\n    //only transform points to the left of the Reflection \n    vec2 Rvec=R.second-R.first;\n    xy-=R.first;\n    det = Rvec.y*xy.x-Rvec.x*xy.y;\n    \n    return det<0.; \n}\n\nint rectF(vec2 xy,const rect rt){\n    //1 for inside rect\n    //2 for on border\n    //3 for near border\n    //4 for outside rect\n    const float tol=.01;\n    if(rt.h0<=xy.y && xy.y<=rt.h1 && rt.w0<=xy.x && xy.x<=rt.w1){\n           bool onborder = xy.y<=rt.h0+tol || rt.h1-tol<=xy.y || xy.x<=rt.w0+tol || rt.w1-tol<=xy.x;\n           return onborder ? 2 : 1; \n    }\n    bool nearborder =rt.h0-tol<=xy.y && xy.y<=rt.h1+tol && rt.w0-tol<=xy.x && xy.x<=rt.w1+tol;\n    return nearborder ? 3 : 4; \n}\n\n\n\nvec2 BaseTransform(vec2 xy,reflection R){\n    //reflect a point across reflection line  \n    vec2 Rvec=R.second-R.first;\n    xy-=R.first;\n    vec2 h = ((dot(Rvec,xy)/dot(Rvec,Rvec))*Rvec)-xy;//shortest length vec from point to line\n    xy+=2.*h;\n    xy+=R.first;\n    return xy; \n    \n}\n\n//float reflDist(vec2 xy,reflection rf){\n    \n//     vec2 vecRep = rf.second-rf.first; \n//     xy-=rf.first;\n//     vec2 h = ((dot(vecRep,xy)/dot(vecRep,vecRep))*vecRep)-xy;\n//     return length(h);  \n//}\n\nint f(vec2 xy,const rect rt,int n){\n    //xy is point to be checked\n    //rt is the initial origami shape\n    //n is the index of the last origami reflection to do \n    //runs based on stack-based recursion.\n    //https://www.shadertoy.com/view/XsjczG by FabriceNeyret2 is helpful for \n    //stack based recursion\n    \n    //The recursive form in c++ just checking if a point is in the resulting origami\n    //would look something like this\n    //bool f(point xy,int n){\n    // if(n==-1){\n    //    return inRect(xy);\n    //  }\n    // if(isTransformed(xy,origami[n])){\n    //    point xyT=BaseTransform(xy,origami[n]);\n    //    return f(xyT,n-1) or f(xy,n-1);\n    //  }\n    //return false; \n    //}\n    \n    \n    //stack setup\n    const int maxStack = 64;\n    stackVec arr[maxStack]; \n    \n    //initialize stack \n    arr[0] = stackVec(xy,n-1,false);\n    int t = 0; //how many iterations of the while loop have occured\n    int s = 0; //the current index in the stack \n    \n    \n    do{\n        stackVec Sxy = arr[s];\n        if(Sxy.nt == -1){ //All transformations have been applied\n            int num = rectF(Sxy.xy,rt);  \n            if(num==1 || num ==2){  //check if point is in original image\n                const int front_color  = 1;\n                const int edge_color   = 3;\n                const int back_color   = 2;\n                const int crease_color = 4;\n                if(s==0){           //has not been.transformed so use front colors\n                    if(num==1){\n                        return front_color;\n                    }else{\n                        return edge_color; \n                    }\n                }\n               \n               if(arr[s].isCrease){\n                   return crease_color; \n               }\n               if(s==1 && num==2){ //one transform means edge color still possible\n                     return edge_color; \n               }\n               return back_color;  \n                \n            }else{\n                s--;//pop stack \n \n            }\n        }else{\n            float det; \n            const float tol = .01;\n            if(isTransformed(Sxy.xy,origami[Sxy.nt],det)){\n                vec2 xyT = BaseTransform(Sxy.xy, origami[Sxy.nt]);\n                Sxy.nt--;\n                arr[s] = Sxy; \n                s++;\n                arr[s] = stackVec(xyT, Sxy.nt,false);//push to stack\n                if(det>-tol){//reflection was close to happening so presume crease\n                   arr[s].isCrease = true;\n                }\n            }else{\n                s--;//pop stack \n            }\n        }\n        \n    }while(t++<100 && s<maxStack && s>=0);\n    return 0; \n        \n}\n    \n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup(); //sets up origami array\n    vec2 uv = fragCoord/iResolution.y;\n    uv = 2.*vec2(uv.x - .5*iResolution.x/iResolution.y,uv.y-0.5); \n    uv.x+=0.5;\n    uv.y+=0.5; \n    \n    rect unit=rect(0.,1.,0.,1.); //initializes rect centered on origin via previous transformations \n    \n    int n = abs(numTransform -(int(iTime)%(2*numTransform)));\n    int colNum = f(uv,unit,n); \n\n    vec3 col = black;\n    if(colNum == 1){\n        col = red;\n    }else if(colNum == 2){\n        col= blue; \n    }else if(colNum == 3){\n        col = green;\n    }else if(colNum == 4){\n        col = purple; \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 red=vec3(1.,0.,0.);\nvec3 blue=vec3(0.,0.,1.);\nvec3 green=vec3(0.,1.,0.);\nvec3 purple=vec3(1.,0.,1.); \nvec3 black = vec3(0.);\n\nstruct reflection{\n    //two points to represent reflection line \n    vec2 first; \n    vec2 second;\n};\n\nstruct rect{\n    float w0,w1;\n    float h0,h1; \n};\n\nstruct stackVec{\n    vec2 xy;\n    int  nt;//origami array index \n    bool isCrease; \n    \n\n    \n};\n\n//const int numTransform=2; \n//reflection[] origami = reflection[] (reflection(vec2(1.,0.),vec2(0.,1.)),reflection(vec2(.0,.1),vec2(.1,0.)));\n\n//const int numTransform = 1; \n//reflection[] origami = reflection[] (reflection(vec2(0.,.1),vec2(.1,0.)));\n\nconst int numTransform = 6; \nreflection origami[numTransform];\n\nvoid setup(){\n    origami[0] = reflection(vec2(0.5,1.),vec2(0.,0.5));\n    origami[1] = reflection(vec2(1.,0.5),vec2(0.5,1.)); \n    origami[2] = reflection(vec2(0.5,0.),vec2(1.,0.5)); \n    origami[3] = reflection(vec2(0.,0.5),vec2(0.5,0.));\n    origami[4] = reflection(vec2(1.-.25,0.), vec2(1.-.25,1.)); \n    origami[5] = reflection(vec2(.25,1.), vec2(.25,0.)); \n    //origami[1] = reflection(vec2(.2,1.), vec2(.2,0.)); \n\n    \n }\n","name":"Common","description":"","type":"common"}]}