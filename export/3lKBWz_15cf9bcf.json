{"ver":"0.1","info":{"id":"3lKBWz","date":"1614184105","viewed":76,"name":"Railz","username":"JBOY","description":"testrail","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nvec2 uVec2(vec2 s1, vec2 s2)\n{\n    return (s1.x < s2.x) ? s1 : s2;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 opSmoothUnion( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n// ****** MAP ******\nvec2 map(vec3 pos)\n{\n    vec2 sphere = vec2(sdSphere(pos + vec3(0.,-1.,-0.), 1.0), 0.0);\n    \n    vec2 ground = vec2(pos.y+1.0, 1.0);\n    \n    vec2 rail1 = vec2(sdRoundBox(pos, vec3(2.,0.1,0.), 0.1),3.);\n    \n    vec2 rail2 = vec2(sdRoundBox(pos + vec3(0.,0.,-1.5), vec3(2.,0.1,0.1), 0.1),3.);\n    \n    vec2 railVert1 = vec2(sdRoundBox(pos + vec3(1.5,0.,-0.75), vec3(0.1,0.1,0.5), 0.1),3.);\n    \n    vec2 railVert2 = vec2(sdRoundBox(pos + vec3(0.,0.,-0.75), vec3(0.1,0.1,0.5), 0.1),3.);\n    \n    vec2 railVert3 = vec2(sdRoundBox(pos + vec3(-1.5,0.,-0.75), vec3(0.1,0.1,0.5), 0.1),3.);\n    \n    \n    vec2 railVertso = opSmoothUnion( railVert1, railVert2, 0.1 );\n    \n    vec2 railVerts = opSmoothUnion( railVertso, railVert3, 0.1 );\n    \n    vec2 railh = opSmoothUnion( rail1, rail2, 0.1 );\n    \n    vec2 rails = opSmoothUnion( railh, railVerts, 0.1 );\n    \n    ground = opSmoothUnion( ground, rails, 0.5 );\n    \n    //ground.x += rail1.x;\n    \n    vec2 world = uVec2(sphere, ground);\n    \n    return world;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0; // si y a contact, \"c\" va stocker sa distance\n    \n    for(int i=0; i<64; i++)\n    {\n        vec2 ray = map(ro + rd * c); // POUR LE MOMENT, on va changer aprÃ¨s\n    \n        if(ray.x < (0.0001*c))\n        {\n            return vec2(c, ray.y);\n        }\n        \n        c += ray.x;\n    }\n    \n    // si la marche est trop longue, ca renvoit -1.0\n    return vec2(-1.0);\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = 0.001*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t).x;\n        if (dist < 0.001) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).x, \n        map(p + e.yxy).x, \n        map(p + e.yyx).x) - c);\n}\n\nvec4 boxmap (sampler2D s, vec3 p, vec3 n, float k)\n{\n    vec4 x = texture( s, p.yz);\n    vec4 y = texture( s, p.zx);\n    vec4 z = texture( s, p.xy);\n    \n    vec3 w = pow( abs(n), vec3(k) );\n    \n    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);\n}\n\nfloat Checker(vec2 uv, vec2 s)\n{\n    return sign(sin(uv.x*s.x))*sign(sin(uv.y*s.y));;\n}\n\nvec3 render(vec3 ro, vec3 rd) // ray origin & ray direction)\n{\n    // *** RAYMARCHING\n    vec2 contact = CastRay(ro, rd); // ici on ajoutera le raymarching\n    // simulation de raymarching\n    \n    vec3 pos = ro + rd * contact.x;\n    vec3 nor = GetNormal(pos);\n    \n    vec3 lp = vec3(sin(iTime), -1.0, cos(iTime))*5.0;\n    vec3 lt = vec3(0.0);\n    vec3 ld = normalize(lt - lp);\n    \n    float lambert = clamp(dot(nor, ld), 0.0, 1.0);\n    \n    float shade = GetShadow(pos, -lp, 16.0);\n    \n    // *** Traitement du contact\n    vec3 col = vec3(0.0);\n    \n    if(contact.x == -1.0)\n    {\n        // y a pas de contact\n        col = vec3(0.0);\n    }\n    else\n    {\n        if(contact.y == 0.0)\n        {\n            col = boxmap(iChannel0, pos, nor, 1.0).rgb;\n\n        }\n        else if (contact.y == 1.0)\n        {\n            col = boxmap(iChannel0, pos*0.3, nor, 1.0).rgb;\n\n        }\n        else if (contact.y == 3.0)\n        {\n            col = boxmap(iChannel1, pos*0.3, nor, 1.0).rgb;\n\n        }\n        col *= lambert*0.5+0.5;\n        \n    }\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centrer camera\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera\n    vec3 translation = vec3(0.0, 0.0, 0.0);\n    vec3 cameraPos = vec3(0.0, 5.0, 5.0) + translation;\n    //cameraPos.z -= iTime;\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0) + translation;\n    \n    // view Direction / Ray Direction\n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + forward * 2.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(uv.x, uv.y, 0.0);\n\n    col = render(cameraPos, viewDir);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}