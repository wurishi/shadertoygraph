{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\nvec2 rotate(vec2 v, float alpha)\n{\n\tfloat vx = v.x*cos(alpha)-v.y*sin(alpha);\n\tfloat vy = v.x*sin(alpha)+v.y*cos(alpha);\n\tv.x = vx;\n\tv.y = vy;\n\treturn v;\n}\n\n// lineVecor must be normalized\nfloat distancePointLine(vec2 linePoint, vec2 lineVector, vec2 point)\n{\n\tvec2 linePointToPoint = point-linePoint;\n\tfloat projectionDistance = dot(lineVector,linePointToPoint);\n\treturn length(lineVector*projectionDistance-linePointToPoint);\n}\n\nfloat distToLineSquare(vec2 p1, vec2 p2, vec2 p, float thickness)\n{\n\tp -= p1;\n\tvec2 lineVector = p2-p1;\n\t\t\n\tfloat angle = -atan(lineVector.y,lineVector.x);\n\tp = rotate(p,angle);\n\t\n\tfloat dx = 0.0;\n\tif(p.x<0.0)\n\t\tdx = abs(p.x);\n\telse if(p.x>length(lineVector))\n\t\tdx = abs(p.x) - length(lineVector);\n\t\t\n\treturn thickness/(dx+abs(p.y));\n}\n\nfloat distToLineRound(vec2 p1, vec2 p2, vec2 p, float thickness)\n{\n\tfloat d = length(p-p2);\n\tp -= p1;\n\tvec2 lineVector = p2-p1;\n\t\t\n\tfloat angle = -atan(lineVector.y,lineVector.x);\n\tp = rotate(p,angle);\n\n\tif(p.x<0.0)\n\t\td = length(p);\n\telse if(p.x<length(lineVector))\n\t\td = abs(p.y);\n\t\t\n\treturn thickness/d;\n}\n\nfloat squareDrop(vec2 p1, vec2 p2, vec2 p, float thickness)\n{\n\tfloat d = 1.0; //length(p-p2);\n\tp -= p1;\n\tvec2 lineVector = p2-p1;\n\t\t\n\tfloat angle = -atan(lineVector.y,lineVector.x);\n\tp = rotate(p,angle);\n\n\tfloat llv = length(lineVector);\n\tif(p.x<0.0)\n\t\td = 0.1*length(p);\n\telse if(p.x<llv)\n\t\td = (llv/(llv-p.x)*0.1)*abs(p.y);\n\t\t\n\treturn thickness/d;\n}\n\nfloat expDrop(vec2 p1, vec2 p2, vec2 p, float thickness)\n{\n\tfloat d = 1.0; //length(p-p2);\n\tp -= p1;\n\tvec2 lineVector = p2-p1;\n\t\t\n\tfloat angle = -atan(lineVector.y,lineVector.x);\n\tp = rotate(p,angle);\n\n\tfloat llv = length(lineVector);\n\tif(p.x<0.0)\n\t\td = 0.06*length(p);\n\telse if(p.x<llv)\n\t\td = exp(10.0*(p.x-0.05))*(llv/(llv-p.x)*0.1)*abs(p.y);\n\t\t\n\treturn thickness/d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xx;\n\tvec2 m = iMouse.xy / iResolution.xx;\n\tp -= vec2(0.5,0.5*iResolution.y/iResolution.x);\n\tm -= vec2(0.5,0.5*iResolution.y/iResolution.x);\n\t\n\tvec2 o1 = vec2(0.15,0.15);\n\tvec2 o2 = vec2(0.15,0.1);\n\tvec2 o3 = vec2(0.4,0.0);\n\tvec2 o4 = vec2(0.25,0.0);\n\t\n\tfloat angle = 1.0*iTime;\n\to1 = rotate(o1,angle);\n\t\n\t\n\tangle = 2.0*iTime;\n\to2 = rotate(o2,angle);\n\tfloat thickness = 0.01;\n\tfloat dist = 0.0;\n\tdist += distToLineSquare(o1,o2,p,thickness);\n\tdist += distToLineSquare(o1,-o2,p,thickness);\n\to1.y *= -1.0;\n\to2.y *= -1.0;\n\tdist += distToLineRound(o1,o2,p,thickness);\n\tdist += distToLineRound(o1,-o2,p,thickness);\n\tdist += squareDrop(o3,o4,p,thickness*0.5);\n\tdist += expDrop(-o3,-o4*0.5,p,thickness*0.35);\n\tfragColor = vec4(dist*vec3(0.36,0.32,0.45),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdB3zK","date":"1390852369","viewed":5969,"name":"Segment","username":"arthursw","description":"A simple function to draw a segment defined by two points, with square or rounded end.","likes":55,"published":1,"flags":0,"usePreview":0,"tags":["line","segment"],"hasliked":0,"parentid":"","parentname":""}}