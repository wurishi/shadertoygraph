{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec2 warpCoords(vec2 uv, float fact) {\n    return uv / (1.0 + fact * (1.0 - uv.y));\n}\n\nconst vec3 rainbow[7] = vec3[](\n    vec3(1.0, 0.0, 0.0), // Red\n    vec3(1.0, 0.5, 0.0), // Orange\n    vec3(1.0, 1.0, 0.0), // Yellow\n    vec3(0.0, 1.0, 0.0), // Green\n    vec3(0.0, 0.0, 1.0), // Blue\n    vec3(0.29, 0.0, 0.51), // Indigo\n    vec3(0.56, 0.0, 1.0)  // Violet\n);\n\nvec3 getColour(float h) {\n    vec3 c = vec3(0.);\n    if (h < 1.) {\n        c = vec3(0.469, 0.492, 0.751);\n    }\n    else if (h == 1.) {\n        c = vec3(0.671, 0.667, 0.510);\n    } else {\n        c = mix(rainbow[int(h)%7], vec3(0.541, 0.537, 0.475), 0.9);\n    }\n    return c;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 tuv = uv;\n    vec2 t = vec2(.5, .01);\n    uv -= t;\n    vec3 col = texture(iChannel1, tuv).rgb; \n    float fact = 0.99;\n    float n = 100.;\n    float w = 45.;\n    float wm = 38.;\n    \n    for( int i = int(n); i >= int(wm); i--) {\n        vec2 wuv = uv;\n        \n        wuv = warpCoords(wuv * pow(fact, float(i)), 1.);\n        \n        int maximum = int(ceil(texture(iChannel0, wuv + t).r*n));\n        vec2 s = vec2(-0.002, 0.002);\n        int shadowMaximum = int(ceil(texture(iChannel0, wuv + t + s).r*n));\n        if (i > int(w)){\n            if (i <= maximum) {\n                col = getColour(float(i) - w);\n                if (i < shadowMaximum) {\n                    col *= .5;\n                }\n                break;\n            }\n        } else if (i == int(w)) {\n            vec2 noise = texture(iChannel2, wuv + t + iTime*0.00001).rg - 0.5;\n            if (i <= int(ceil(texture(iChannel0, wuv + t + noise*0.01).r*n))) {\n                col = vec3(1.)*0.5 + texture(iChannel1, wuv + t).rgb*0.5;\n                break;\n            } else {\n                col = texture(iChannel1, wuv + t).rgb;\n            }\n            \n        }\n        if (i <= int(w)) {\n            vec3 waterCol = getColour(float(i) - w);\n            if (i <= maximum) {\n                if (i < shadowMaximum) {\n                    waterCol *= .5;\n                }\n                col = mix(col, waterCol, \n                smoothstep(wm, w, float(i))*0.7);\n                \n                break;\n            }\n            \n        }\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"// Voronoi\n\n\n\n\nvec2 getPoint(vec2 t) {\n    return hash22(t);\n}\n\nfloat voronoi2D(vec2 uv, float tileCount) {\n    vec2 t = floor(vec2(uv*tileCount));\n    vec2 tuv = fract(vec2(uv*tileCount));\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    float dist = 1.;\n    int scanDist = 1;\n    for (int x = -scanDist; x <= scanDist; x++) {\n        for (int y = -scanDist; y <= scanDist; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 point = getPoint(t + offset) + offset;\n            float oldDist = dist;\n            dist = length(tuv - point);\n            dist = min(dist, oldDist);\n        }\n        \n    }\n    \n    return dist;\n}\n\nfloat fbm(vec2 uv, int n, float t) {\n    float ampFact = 0.8;\n    float freqFact = 1.2;\n    float amp = 1.;\n    float freq = 2.;\n    float maxAmp = 0.;\n    float dist = 0.;\n    for (int i = 0; i < n; i++) {\n        amp *= ampFact;\n        freq *= freqFact;\n        dist += amp*voronoi2D(uv, freq);\n        maxAmp += amp;\n    }\n    \n    float normalized = dist / maxAmp;\n    float minVal = 0.0;\n    float maxVal = 1.0;\n    return (normalized - minVal) / (maxVal - minVal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x += iTime*0.03;\n    fragColor = vec4(fbm(uv, 29, iTime));\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#define PI 3.14159\n#define TAU 6.28318\nvec2 hash22(vec2 p) {\n    p = fract(p * vec2(0.1031, 0.11369));\n    p += dot(p, p.yx + vec2(33.33, 71.17));\n    return fract(sin(p) * vec2(43758.5453123, 22578.1459123));\n}\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(0.1031, 0.11369));\n    p += dot(p, p.yx + vec2(33.33, 71.17));\n    return fract(sin(dot(p, vec2(43758.5453123, 22578.1459123))));\n}\n\nvec2 hash12(float p) {\n    vec2 k = vec2(0.1031, 0.11369);\n    p = fract(p * 0.1031);\n    p += dot(vec2(p, p), k);\n    return fract(sin(vec2(p, p + 33.33)) * vec2(43758.5453123, 22578.1459123));\n}\n\nfloat hash11(float x) {\n    x = fract(x * 0.61803398875);\n    x *= x;\n    return fract(x * 43758.5453123);\n}\n\nmat2 rot2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[],"code":"vec3 fbmWave(vec2 uv, int n, float t, float offset) {\n    float ampFact = 0.912421;\n    float freqFact = 1.21232;\n    float amp = 1.0;\n    float freq = 0.9;\n    vec3 derivative = vec3(0.0);\n\n    for (int i = 0; i < n; i++) {\n        amp *= ampFact;\n        freq *= freqFact;\n        vec2 ruv = uv;\n        ruv.x += offset;\n        ruv *= rot2D(hash11(float(i)) * TAU);\n\n        float g = ruv.x * freq * 30.0 + ruv.y * freq * 30.0 + t;\n        float sinG = sin(g);\n        float cosG = cos(g);\n\n        vec2 gradG = vec2(freq * 30.0 * rot2D(hash11(float(i)) * TAU));;\n        \n        vec3 cDerivative = amp*vec3(-amp * cosG * gradG.x, 60., -amp * cosG * gradG.y);\n\n        derivative += cDerivative;\n        uv += cDerivative.xz*0.0003*amp;\n    }\n\n    return normalize(derivative);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float offset = iTime*0.03;\n    //uv.x += offset;\n    vec3 sunPos = normalize(vec3(0., 1., 1.));\n    vec3 waveDerivative = fbmWave(uv,10, iTime, offset);\n    float diffuseFact = clamp(dot(sunPos, waveDerivative), 0., 1.);\n    vec3 diffuseCol = vec3(0.369, 0.392, 0.651);\n    vec3 ambientCol = vec3(0.05, 0.1, 0.3);\n    vec3 col = mix(ambientCol, diffuseCol, diffuseFact);\n\n    fragColor = vec4(col, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MXcyRr","date":"1734736387","viewed":62,"name":"The Voronoi Isles","username":"GarlicGraphix","description":"Having fun with Voronoi Noise.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","waves","fbm","ocean"],"hasliked":0,"parentid":"XfyBDt","parentname":"Rainbow Mountains"}}