{"ver":"0.1","info":{"id":"Xstcz4","date":"1518132222","viewed":210,"name":"Cut cube","username":"sidsuk","description":"cut cube, case study, CIS566\nanimation reference: https://camo.githubusercontent.com/4f8139b56f24036d9273eafebd71fae2bf95e7df/68747470733a2f2f692e696d6775722e636f6d2f735a61325050492e676966","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// CIS566 cut cube\n/// SDF reference: https://iquilezles.org/articles/distfunctions\n\n#define DEPTH 30\n#define END 1000.0\n#define EPSILON 0.0075\n#define EPSILON2 0.0005\n#define PI 3.14159265359\n\n#define WIREFRAME\n\n\n// signed distance function of cube\n\nvec2 unionSDF(vec2 v1, vec2 v2) {\n    if(v1.x < v2.x) {\n        return v1;\n    } else {\n        return v2;\n    }\n}\n\n\nvec2 boxSDF(vec3 p, vec3 b) {\n    p /= 1.5;\n    //b /= 1.5;\n    vec3 d = abs(p) - b;\n  \tfloat dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    \n    float e = 0.0;\n    \n    float c1 = step(b.x - EPSILON, abs(p.x));\n    float c2 = step(b.y - EPSILON, abs(p.y));\n    float c3 = step(b.z - EPSILON, abs(p.z));\n    \n    if(c1 + c2 + c3 > 1.5)\n    {\n        e = 1.0;\n    }    \n    dist *= 1.5;\n    return vec2(dist, e);\n}\n\n\nmat4 rotate(vec3 axis, float angle) {\n    axis = normalize(axis);\n    angle = radians(angle);\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    \n    return transpose(mat4(\n        t * pow(axis.x, 2.0) + c, t * axis.x * axis.y - s * axis.z, t * axis.x * axis.z + s * axis.y, 0.0,\n        t * axis.x * axis.y + s * axis.z, t * pow(axis.y, 2.0), t * axis.y * axis.z - s * axis.x, 0.0,\n        t * axis.x * axis.z - s * axis.y, t * axis.y * axis.z + s * axis.x, t * pow(axis.z, 2.0), 0.0,\n        0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 rotateY(float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0);  \n}\n\nmat4 rotateX(float t) {\n\tfloat cost = cos(radians(t));\n\tfloat sint = sin(radians(t));\n\treturn mat4(\n\t\t1.0, 0.0, 0.0, 0.0,   // first column\n\t\t0.0, cost, sint, 0.0, // second column\n\t\t0.0, -sint, cost, 0.0, // third column\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 rotateZ(float t) {\n\tfloat cost = cos(radians(t));\n\tfloat sint = sin(radians(t));\n\treturn mat4(\n\t\tcost, sint, 0.0, 0.0,   // first column\n\t\t-sint, cost, 0.0, 0.0, // second column\n\t\t0.0, 0.0, 1.0, 0.0, // third column\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 translate(vec3 t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0\n        );\n}\n\n\n// scene builder\nvec2 scene(vec3 p) {\n    \n    float offset = floor(0.75 * iTime) + max(0.0, 4.0 * fract(0.75 * iTime) - 3.0);\n    \n    mat4 m1 = rotateY(45.0 + offset * 90.0);\n    vec3 p1 = vec3(inverse(m1) * vec4(p, 1.0));\n    \n    vec2 dist = boxSDF(p1, vec3(0.1, 0.1, 0.1));\n    \n    mat4 m2 = rotateY(45.0) * translate(vec3(0.0, 0.0, 0.3));\n    vec3 p2 = vec3(inverse(m2) * vec4(p, 1.0));\n    \n    float bounce = 0.075 * pow(sin(iTime * PI * 2.0 * 0.75) + 1.0, 1.0 / 3.0);\n    \n    int num = 6;\n    \n    for(int i = 0; i < num; ++i) {\n        for(int j = 0; j < 6; ++j) {\n            \n            float lag = float(i) / 10.0;\n            \n            offset = floor(0.75 * (iTime - lag)) + max(0.0, 4.0 * fract(0.75 * (iTime - lag)) - 3.0) + floor(0.75 * lag);\n            \n            m1 = rotateY(45.0 + 90.0 * offset);\n            \n            mat4 rotation;\n            if(j < 4) {\n                float angle = 90.0 * float(j);\n                rotation = rotateY(angle);\n            } else if(j == 4) {\n                float angle = -90.0;\n                rotation = rotateX(angle);\n            } else {\n                float angle = 90.0;\n                rotation = rotateX(angle);\n            }\n                \n            rotation = m1 * rotation;\n\n            vec3 trans = vec3(0.0, 0.0, 0.3 + pow(float(i), 1.0 / 1.5) * 0.2 + bounce);\n\n            mat4 transform = rotation * translate(trans);\n\n            vec3 pos = vec3(inverse(transform) * vec4(p, 1.0));\n\n            vec2 d = boxSDF(pos, vec3(0.1, 0.1, 0.001));\n\n            dist = unionSDF(dist, d);\n                                 \n        }\n    }\n\n    return dist;\n}\n\nvec2 rayMarching(vec3 origin, vec3 dir, float start) {\n    float t = start;\n\tfor(int i = 0; i < DEPTH; ++i) {\n\t\tvec3 curP = origin + dir * t;\n\t\tvec2 step = scene(curP);\n\t\tt += step.x;\n\t\tif(step.x < EPSILON2) {\n\t\t\treturn vec2(t, step.y);\n\t\t}\n\t\tif(t >= END){\n\t\t\treturn vec2(END, 0.0);\n\t\t}\t\n\t}\n\treturn vec2(END, 0.0);\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON2, p.y, p.z)).x - scene(vec3(p.x - EPSILON2, p.y, p.z)).x,\n\t\tscene(vec3(p.x, p.y + EPSILON2, p.z)).x - scene(vec3(p.x, p.y - EPSILON2, p.z)).x,\n\t\tscene(vec3(p.x, p.y, p.z + EPSILON2)).x - scene(vec3(p.x, p.y, p.z - EPSILON2)).x\n\t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 spos = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0.0, 5.0, 8.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(target - eye);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(dir, up);\n    up = cross(right, dir);\n    \n    vec3 lightpos = vec3(0.0, 2.0, 1.0);\n    \n    vec3 pos = eye + right * spos.x + up * spos.y;\n    \n    vec2 final_t = rayMarching(pos, dir, 0.001);\n    \n    if(final_t.x > END) {\n        fragColor = vec4(0.0);\n        return;\n    } \n    \n    #ifdef WIREFRAME\n    fragColor = vec4(vec3(final_t.y), 1.0);\n    #endif\n    \n    #ifndef WIREFRAME\n    vec3 intersection = pos + final_t.x * dir;\n    vec3 normal = getNormal(intersection);\n    float diffuse = dot(normalize(lightpos - intersection),normal);\n    fragColor = vec4(vec3(diffuse), 1.0);\n    #endif\n    \n      \n}","name":"Image","description":"","type":"image"}]}