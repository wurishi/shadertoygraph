{"ver":"0.1","info":{"id":"fdt3zX","date":"1630359463","viewed":121,"name":"Mandelbrot - AT","username":"athibaul","description":"Just a simple old Mandelbrot set, and some fun with coloring.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","complex","set","coloring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouseUV = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float ITER = 100.;\n    \n    if(iMouse.z > 0.)\n    {\n        // Magnification around the mouse position\n        uv = mouseUV + 0.1*uv;\n        ITER = 200.;\n    }\n\n    vec2 z = vec2(0);\n    float zz;\n    vec2 zmin = z;\n    float zzmin = 1000.;\n    float i;\n    for(i=0.; i<ITER; i++)\n    {\n        // The loop to determine whether a point is inside or outside\n        z = cmul(z, z) + uv;\n        zz = dot(z,z);\n        //zzmin = min(zz, zzmin);\n        if(zz < zzmin)\n        {\n            zzmin = zz;\n            zmin = z;\n        }\n        if(zz > 1000.) break;\n    }\n    \n    vec3 col;\n    if(i < ITER)\n    {\n        // We're outside!\n        // Color outside according to the rate of exit\n        // https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set#Continuous_(smooth)_coloring\n        float phi = log2(zz)/exp2(i);\n        col = 0.5 + 0.5*cos(log2(phi) + vec3(0,1,2) - iTime);\n        col *= smoothstep(0.8,0.,phi);\n    }\n    else\n    {\n        //col = 0.5 + 0.5*cos(0.5*round(iTime+6.*z.xyx)+vec3(0,1,2));\n        //col = 0.5 + 0.5*cos(iTime+3.*z.xyx+vec3(0,1,2));\n        \n        // Color inside according to smallest absolute value of the orbit\n        col = 0.5 + 0.5*cos(iTime+log(zzmin) + vec3(0,1,2));\n        //col = (0.5 + 0.5*cos(iTime+log(zzmin))) * vec3(0.1,0.5,1.);\n        \n        // Color according to the point whose orbit goes nearest the origin\n        vec3 col2 = 0.5 + 0.5*cos(iTime+zmin.yyy/zzmin+vec3(0,1,2));\n        //col += (0.5 + 0.5*cos(iTime+5.*zmin.yyy)) * vec3(1., 0.5, 0.1);\n        \n        float limit = 0.1 + 0.09*cos(0.618*iTime + uv.x);\n        col = mix(col, col2, smoothstep(0.0,limit,zzmin));\n        \n        //col = sqrt(1.-exp(-col));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}