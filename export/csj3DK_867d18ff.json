{"ver":"0.1","info":{"id":"csj3DK","date":"1668417581","viewed":118,"name":"Box Raycasting Exact","username":"magician0809","description":"Box (AABB) Raycasting Exact.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray","raycast","box","aabb","cast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdRay(vec2 p, vec2 rd)\n{\n    return length(p - rd * max(dot(p, rd), 0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nbool boxIntersection(vec2 ro, vec2 rd, vec2 rad)\n{\n    vec2 m = 1.0/rd;\n    vec2 n = m*ro;\n    vec2 k = abs(m)*rad;\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n    float tN = max( t1.x, t1.y );\n    float tF = min( t2.x, t2.y );\n    return tN<=tF && tF>=0.0;\n}\n\n// This can directly handle the case that the ray is parallel to the coordinate axis without \"if\".\n// (R+)/0=>Inf, (R+)*Inf=>Inf, Inf+Inf=>Inf\n// 0/0=>NaN, 0*Inf=>NaN, Inf/Inf=>NaN, Inf-Inf=>NaN\n// (R)/Inf=>0\n// max((R),NaN)=>NaN, max(NaN,(R))=>(R)\nbool boxIntersection2(vec2 ro, vec2 rd, vec2 rad)\n{\n    vec2 m = 1.0 / rd;\n    vec2 n = ro;\n    //vec2 k = rad * sign(m);\n    vec2 k = vec2(rd.x >= 0.0 ? rad.x : -rad.x,\n                  rd.y >= 0.0 ? rad.y : -rad.y);\n\tvec2 t1 = (-n - k) * m;\n\tvec2 t2 = (-n + k) * m;\n    float tN = max(t1.x, t1.y);\n\tfloat tF = min(t2.x, t2.y);\n\treturn tN <= tF && tF >= 0.0;\n}\n\n//============================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= aspect;\n\n    // ray\n    float t = iTime * 0.8;\n    vec2 ro = vec2(cos(t), sin(t)) * 0.5;\n    ro.x += 0.75;\n    vec2 rd = normalize(vec2(1.0, 0.0));\n    vec2 ro2 = vec2(-ro.x, ro.y);\n    vec2 rd2 = vec2(-rd.x, rd.y);\n\n    // aabb\n    vec2 aabbPos = vec2(0.75, 0.0);\n    vec2 aabbRad = vec2(0.35);\n    vec2 aabbPos2 = vec2(-aabbPos.x, aabbPos.y);\n    vec2 aabbRad2 = aabbRad;\n    \n    // signed distance\n    float d, d1, d2;\n    d = sdRay(uv - ro, rd);\n    d = min(d, sdRay(uv - ro2, rd2));\n    d = min(d, d1 = sdBox(uv - aabbPos, aabbRad));\n    d = min(d, d2 = sdBox(uv - aabbPos2, aabbRad2));\n\n    // color from https://www.shadertoy.com/view/3ltSW2\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    // ray cast aabb\n    if (boxIntersection(ro - aabbPos, rd, aabbRad) && d1 < -0.01 ||\n        boxIntersection2(ro2 - aabbPos2, rd2, aabbRad2) && d2 < -0.01)\n    {\n        col.b *= 0.0;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}