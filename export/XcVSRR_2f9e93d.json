{"ver":"0.1","info":{"id":"XcVSRR","date":"1714707555","viewed":51,"name":"image fitting to screen","username":"hahnzhu","description":"different ways of fitting image to the screen","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["objectfit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fit image to screen\nvec3 fitScreen(\n    vec2 imgSize,     // image resolution in pixel\n    vec2 resolution,  // screen resolution in pixel\n    sampler2D image,  // image sample you want to display on screen\n    int fitMode,      // how do image fit the screen (0:fill  1:cover  2:contain)\n    int alignMode,    // pivot point of the alignment (0~8: from left to right, bottom to top)\n    int repeatMode,   // should repeat the image when exceeding coordinate boundaries (0:repeat  1:norepeat)\n    vec3 fillColor    // when repeatMode=1, set a color for the blank space\n  ) {\n  vec3 color = vec3(0.0);\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec2 st = uv;\n\n  float r1 = resolution.x / resolution.y;\n  float r2 = imgSize.x / imgSize.y;\n\n  st.x /= fitMode == 1 && r2 > r1 ? r2 / r1 : 1.0;\n  st.x += fitMode == 1 && r2 > r1 && alignMode % 3 == 1 ? 0.5 - r1 / r2 * 0.5 : 0.0;\n  st.x += fitMode == 1 && r2 > r1 && alignMode % 3 == 2 ? 1.0 - r1 / r2 : 0.0;\n\n  st.y *= fitMode == 2 && r2 > r1 ? r2 / r1 : 1.0;\n  st.y -= fitMode == 2 && r2 > r1 && alignMode >= 3 && alignMode <= 5 ? (r2 / r1 - 1.0) / 2.0 : 0.0;\n  st.y -= fitMode == 2 && r2 > r1 && alignMode >= 6 && alignMode <= 8 ? r2 / r1 - 1.0 : 0.0;\n\n  st.y /= fitMode == 1 && r2 < r1 ? r1 / r2 : 1.0;\n  st.y += fitMode == 1 && r2 < r1 && alignMode >=3 && alignMode <= 5 ? 0.5 - (r2 / r1) * 0.5 : 0.0;\n  st.y += fitMode == 1 && r2 < r1 && alignMode >=6 && alignMode <= 8 ? 1.0 - r2 / r1 : 0.0;\n\n  st.x *= fitMode == 2 && r2 < r1 ? r1 / r2 : 1.0;\n  st.x -= fitMode == 2 && r2 < r1 && alignMode % 3 == 1 ? (r1 / r2 - 1.) / 2.0 : 0.0;\n  st.x -= fitMode == 2 && r2 < r1 && alignMode % 3 == 2 ? r1 / r2 - 1.0 : 0.0;\n\n  color = texture(image, st).rgb;\n  float axis = r2 > r1 ? st.y : st.x;\n  vec3 mask = vec3(step(0.0, axis) - step(1.0, axis));\n  vec3 maskColor = (1.0 - mask) * fillColor;\n  color = fitMode == 2 && repeatMode == 1 ? color * mask + maskColor : color;\n\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 imageSize = vec2(512., 512.);\n    \n    \n    // fit mode (0:fill  1:cover  2:contain)\n    // how do image fit the screen\n    int fitMode = 2;\n    \n    // alignMode: pivot point of the alignment\n    // | 6 | 7 | 8 |\n    // |---|---|---|\n    // | 3 | 4 | 5 |\n    // |---|---|---|\n    // | 0 | 1 | 2 |\n    int alignMode = 4;\n    \n    // repeatMode (0:repeat 1:norepeat)\n    // should repeat the image when exceeding coordinate boundaries\n    int repeatMode = 1;\n    \n    // fill color when repeatMode=1\n    vec3 fillColor = vec3(0.5, 0.0, 0.0);\n    \n    // show image with different ways\n    vec3 color = fitScreen(imageSize, iResolution.xy, iChannel0, fitMode, alignMode, repeatMode, fillColor);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}