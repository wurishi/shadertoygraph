{"ver":"0.1","info":{"id":"tl3GWf","date":"1577731145","viewed":203,"name":"TPB-07-FX-04","username":"superplek","description":"Superplek/Bypass vs. Ravity/Solar ","likes":0,"published":1,"flags":33,"usePreview":0,"tags":["tpb07"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nfloat2x2 rot2(float rot)\n{\n    float sinRot;\n    float cosRot;\n    sincos(rot, sinRot, cosRot);\n    return float2x2(cosRot, -sinRot, sinRot, cosRot);\n}*/\n\n/*\n\tTPB-07 effect: the non-stop Hoplite experience\n\n\tCredits:\n\t- Superplek\n\t- Thorsten\n\t- Ravity (post proc.)\n\t- Various Shadertoy users\n\n    Blur inspired by David Hoskins, flares inspired by John Chapman\n    Effect (backup?) for TPB-07\n\n\t13/01/2020:\n\t- Added crude VR support, it's not clear when it does or does not use the VR function \n\t  (to me) yet. I've changed defines in buffer C to eliminate artifacts in VR, they don't show\n\t  up in 2D so revert those for regular use.\n*/\n\n#define BLUR_ITERATIONS 64\n#define GOLDEN_ANGLE 2.39996\n\n// -- Superplek's stuff --\n\n#define time iTime\n#define sat(x) clamp(x,0.0,1.0)\n\nmat2 fRot(float theta)\n{\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\n// Hash functions (for noise)\nvec4 h4(vec4 p4)\n{\n\tp4 = fract(p4 * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfloat h1(vec4 p){return h4(p).x;}\n\n// -- Unity logo --\n\n// Source: https://www.shadertoy.com/view/ld3XDse \n// Edited it to rotate and scale to a corner for this specific shader.\n\nfloat a(vec2 uv)\n{\n    uv.y = abs(uv.y);\n    vec4 ss = vec4(uv.xy, .11, .79) - uv.yxyy + vec4(1.5,-1.2,0,0);\n    return min(min(min(ss.x,ss.w),-uv.x),max(ss.y,ss.z));\n}\n\nvec4 fUnityLogo(in vec2 fragCoord)\n{\n    mat2 mrot = fRot(time*0.3);\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * 16. / iResolution.y,\n         sup = vec2(-.5, .866),\n         supo = vec2(.866, .5);\n    \n    // EDIT: move to corner\n    uv.x -= 12.;\n    uv.y -= 6.;\n            \n    // improved s by Fabrice! Thanx!\n    // EDIT: added rotation\n    float s = max(a(mrot*uv),max(a(mrot*uv*mat2(-.5,.866,.866,.5)),a(-mrot*uv*mat2(.5,.866,.866,-.5))));\n\n    float logo = smoothstep(-fwidth(uv.x)*1.9,.0,s)*0.7;\n    vec4 col = vec4(.13,.17,.22,logo) + logo; \n\n    float i = smoothstep(.5,1.,sin(time*2.7 + uv.x + uv.y));\n    \n    // EDIT: made it much brighter\n    col *= 0.9+(vec4(1)*s*.2+0.2*i);\n   \n    return clamp(col,.0,1.);\n}\n\n// To do: optimalization comparison between uniform and const\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n// David Hoskins' Bokeh method optimzed for size (and cutting corners)\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius)\n{\n    vec2 angle = vec2(0.0 ,radius * 0.01 / sqrt(float(BLUR_ITERATIONS)));    \n\tvec3 color = vec3(0);\n    vec3 div = vec3(0);\n\n    float r = 1.0;\n    for (int i = 0; i < BLUR_ITERATIONS; i++, r += 1.0 / r, angle *= rot)\n    {\n\t\tvec3 c = texture(tex, uv + r * angle).xyz;\n        vec3 contrast = pow(c, vec3(4));       \n        color += c * c * 2.0 * contrast;\n        div += contrast;\n    }\n    \n    return color / div;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    \n    float vignette = 0.2 + 0.8 * pow(10.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.15);\n    vignette = clamp(vignette + 0.1, 0.0, 1.0);\n    \n    float mixBokeh = 0.14;\n    float mixFlare = 1.33;\n    \n    vec3 bokeh = Bokeh(iChannel2, uv, (1.-vignette)*3.) * vec3(mixBokeh);\n    \n    vec2 direction = normalize(vec2(1.0) - uv - vec2(0.5));\n    vec2 aberrated = 0.0006 * pow(direction, vec2(4.0));\n\n    vec3 col = vec3(texture(iChannel0, uv - aberrated).r,\n                    texture(iChannel0, uv).g,\n                    texture(iChannel0, uv + aberrated).b);\n\n\tvec3 dofColors = col * vec3(mixFlare);\n\n\tvec3 finalCol3 = max(dofColors, bokeh)*vignette;\n    \n    // shit film grain (by Trevor :))\n    finalCol3 += (h1(vec4(fragCoord.x,fragCoord.y,time,col.z)) - 0.5) * 0.025;\n \n    vec4 finalCol4 = vec4(finalCol3, 1.0);\n\n    // Add Unity logo, deal with 'em!\n    vec4 unity = fUnityLogo(fragCoord.xy);\n    finalCol4 = mix(finalCol4, unity, unity.w);\n    finalCol4.z += unity.w*0.214;\n\n    fragColor = finalCol4;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\n\tTPB-07 effect: Superplek ft. Thorsten's #HWSHADERGP19 round #1 entry (20m. live coding competition)\n*/\n\n// -- Taken from newer shader(s) --\n\n#define time (iTime*0.628)\n#define sat(x) clamp(x,0.0,1.0)\n\n// Thanks, Trevor!\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return sat((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\n// One of my own; I derived it from NTSC weights as far as I can remember\nvec3 fDesaturate(vec3 color, float amount)\n{\n    return mix(color, vec3(dot(color, vec3((1.-(0.21+0.71)), 0.21, 0.71))), amount);\n}\n\n// Trevor's function\nvec3 fVignette(vec3 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *=  1. - uv.yx;\n    float vignetting = uv.x*uv.y * 25.;\n    vignetting = sat(pow(vignetting, .25));\n    return color*vignetting;\n}\n\nmat2 fRot(float theta)\n{\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\n// -- HWGP shader (99% as-is) --\n\nfloat laura(vec3 p)\n{\n\tfloat cosgrid = dot(cos(p), sin(p.zxy)) + 1.0;\n    \n  //  float cosgrid = cos(p.x)+cos(p.y*0.8628)+cos(p.z);\n   // return cosgrid;\n\n   \n    // ** this was in the plans but now that I look at it, well, doesn't do a whole lot of good **\n    // Blobs (optional, just remember p-offset, like with normals, then 1/dist per axis)\n    vec3 dx = p-vec3(1.,0.3*cos(time*0.5),0.);\n    vec3 dy = p-vec3(0.,1.,0.);\n    vec3 dz = p-vec3(0.,0., 1. + .08*sin(time*0.3));\n    float bx = 1./length(dx);\n    float by = 0.8/length(dy);\n    float bz = 0.8/length(dz);\n    \n    float result = cosgrid+bx*by*bz;\n    return result;\n}\n\nmat2 laurarot(float theta)\n{\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n                \nvec3 lauranormal(vec3 p)\n{                    \n\tfloat mid = laura(p);\n    float eps = 0.1;\n    vec3 normal;\n    normal.x = laura(vec3(p.x+eps, p.y, p.z))-mid;\n    normal.y = laura(vec3(p.x, p.y+eps, p.z))-mid;\n    normal.z = laura(vec3(p.x, p.y, p.z+eps))-mid;\n    return normalize(normal);\n}\n\nvec3 laurapath(float t)\n{\n    return vec3(0.4*sin(t*3.), 0.3*cos(t*1.66), t*-4.);\n}\n\n// Try to memorize this equation\nfloat lauraspec(vec3 eye, vec3 hit, vec3 normal, vec3 ldir)\n{\n    vec3 v = normalize(eye-hit);\n\tvec3 h = normalize(ldir+v);\n    float spec = pow(max(dot(normal, h), 0.), 8.);\n    return spec;\n}\n\n// -- Disregard this one --\nfloat laurapoint(vec3 hit, vec3 lpos, vec3 normal)\n{\n    float distance = length(hit-lpos);\n    vec3 dir = normalize(lpos);\n    \n    float constant = 0.1;\n    float linear = 0.5;\n    float exp = 2.;\n    \n    float att = constant + linear*distance + exp*distance*distance;\n    return 1./att;\n}\n\nfloat random(float t)\n{\n    return 0.23423423*sin(t*4.23423);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Calculate P which is [-1..1] on 2 axis\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = -1. + 2. * fragCoord.xy/iResolution.xy;\n\n    // Final color (RGB), reset\n    vec3 col = vec3(0.);\n    \n    // Eye position\n    vec3 eye = laurapath(time);\n    \n    // Main direction vector\n    vec3 dir = vec3(p.x, p.y, 1.);\n    \n\t// Rotate that vector\n    // ** SYNC **\n    mat2 mrot1 = laurarot(time*0.8);\n    mat2 mrot2 = laurarot(time*0.23);\n    dir.yx *= mrot1;\n    dir.zy *= mrot2;\n    dir =  normalize(dir);\n    \n\t// Light position (REMEMBER: add eye pos.)    \n    vec3 lpos = vec3(dir.x, dir.y, 0.);\n    lpos += eye;\n    \n    // March shape + calculate normal \n\tfloat total = 0.;\n    float march;\n    vec3 hit = vec3(0.);\n    for (int i = 0; i < 96; ++i)\n    {\n        march = laura(hit);\n        total += march;\n        hit = eye + dir*total;\n    }\n    \n    vec3 normal = lauranormal(hit);\n\n    // March reflection (copy paste from previous march)\n    vec3 reflhit = hit;\n    float refltotal = total; // IMPORTANT: do *not* set to 0!\n    vec3 refldir = reflect(dir, normal); // IMPORTANT: order matters! DIR, NORMAL!\n    vec3 refleye = hit;\n    for (int i = 0; i < 32; ++i)\n    {\n        float march = laura(reflhit);\n        refltotal += march;\n        if (refltotal > 32.)\n            break;\n        reflhit = refleye + refldir*refltotal;\n    }\n\n    vec3 r_normal = lauranormal(reflhit);\n\n    // Lighting for reflection\n    vec3 r_ldir = normalize(lpos-reflhit);\n    float r_diffuse = max(0., dot(r_normal, r_ldir));\n    float r_fresnel = pow(max(0., dot(r_normal, r_ldir)), 8.);\n\n    // Main color\n    vec3 albedo =vec3(0.2, 0.6, 1.);\n        \n    // Lighting for main shape\n    vec3 ldir = normalize(lpos-hit);\n    float diffuse = max(0., dot(normal, ldir));\n\tfloat fresnel = lauraspec(eye, hit, normal, ldir);\n    \n    // Rim lighting (IMPORTANT)\n    float rim = diffuse*diffuse;\n    rim = clamp((rim-0.13)*32., 0., 1.);\n\n    // This is a powerful part, easy to memorize, just recalculate the normal\n    // using hit position and wobble it, then use it to influence yMod for stripes\n    vec3 funk = lauranormal(hit + cos(time*0.3));\n    float ymod = 0.5 + 0.5*sin(hit.y*4. + funk.x*22. + funk.y+cos(time*0.4));\n    diffuse *= ymod;\n    ymod *= 0.628;\n    ymod *= ymod;\n    diffuse += ymod;\n    // ^ Many variations of this work\n \n    // Lighting (fudge fest)\n    col = albedo*diffuse;\n    col += albedo*diffuse*r_fresnel + fresnel;\n    col = mix(col, albedo*r_diffuse*r_fresnel*ymod, rim*diffuse);\n    \n    // Ambient\n    col += vec3(0.1, 0.1, 0.1);\n    \n    // Add fog (can colorize without artifacts)\n    float fog = 1.-(exp(-0.0005*total*total*total));\n    col = mix(col, albedo, fog); // vec3(0., 0., 0.), fog); // COLOR YOUR FOG!\n\n    // Toning\n    col = col*0.8 + 0.2*ACESFilm(col);\n    col = fDesaturate(col, 1.3);\n\n    // Use new vignette\n    col = fVignette(col, fragCoord);\n        \n    // Output to screen/target\n    fragColor = vec4(col,1.);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\t// Calculate P which is [-1..1] on 2 axis\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = -1. + 2. * fragCoord.xy/iResolution.xy;\n\n    // Final color (RGB), reset\n    vec3 col = vec3(0.);\n    \n    // Eye position\n    vec3 eye = fragRayOri + laurapath(time);\n    \n    // Main direction vector\n    vec3 dir = fragRayDir; // vec3(p.x, p.y, 1.);\n    \n\t// Rotate that vector\n    // ** SYNC **\n    // mat2 mrot1 = laurarot(time*0.8);\n    // mat2 mrot2 = laurarot(time*0.23);\n    // dir.yx *= mrot1;\n    // dir.zy *= mrot2;\n    dir =  normalize(dir);\n    \n\t// Light position (REMEMBER: add eye pos.)    \n    vec3 lpos = vec3(dir.x, dir.y, 0.);\n    lpos += eye;\n    \n    // March shape + calculate normal \n\tfloat total = 0.;\n    float march;\n    vec3 hit = vec3(0.);\n    for (int i = 0; i < 96; ++i)\n    {\n        march = laura(hit);\n        total += march;\n        hit = eye + dir*total;\n    }\n    \n    vec3 normal = lauranormal(hit);\n\n    // March reflection (copy paste from previous march)\n    vec3 reflhit = hit;\n    float refltotal = total; // IMPORTANT: do *not* set to 0!\n    vec3 refldir = reflect(dir, normal); // IMPORTANT: order matters! DIR, NORMAL!\n    vec3 refleye = hit;\n    for (int i = 0; i < 32; ++i)\n    {\n        float march = laura(reflhit);\n        refltotal += march;\n        if (refltotal > 32.)\n            break;\n        reflhit = refleye + refldir*refltotal;\n    }\n\n    vec3 r_normal = lauranormal(reflhit);\n\n    // Lighting for reflection\n    vec3 r_ldir = normalize(lpos-reflhit);\n    float r_diffuse = max(0., dot(r_normal, r_ldir));\n    float r_fresnel = pow(max(0., dot(r_normal, r_ldir)), 8.);\n\n    // Main color\n    vec3 albedo =vec3(0.2, 0.6, 1.);\n        \n    // Lighting for main shape\n    vec3 ldir = normalize(lpos-hit);\n    float diffuse = max(0., dot(normal, ldir));\n\tfloat fresnel = lauraspec(eye, hit, normal, ldir);\n    \n    // Rim lighting (IMPORTANT)\n    float rim = diffuse*diffuse;\n    rim = clamp((rim-0.13)*32., 0., 1.);\n\n    // This is a powerful part, easy to memorize, just recalculate the normal\n    // using hit position and wobble it, then use it to influence yMod for stripes\n    vec3 funk = lauranormal(hit + cos(time*0.3));\n    float ymod = 0.5 + 0.5*sin(hit.y*4. + funk.x*22. + funk.y+cos(time*0.4));\n    diffuse *= ymod;\n    ymod *= 0.628;\n    ymod *= ymod;\n    diffuse += ymod;\n    // ^ Many variations of this work\n \n    // Lighting (fudge fest)\n    col = albedo*diffuse;\n    col += albedo*diffuse*r_fresnel + fresnel;\n    col = mix(col, albedo*r_diffuse*r_fresnel*ymod, rim*diffuse);\n    \n    // Ambient\n    col += vec3(0.1, 0.1, 0.1);\n    \n    // Add fog (can colorize without artifacts)\n    float fog = 1.-(exp(-0.0005*total*total*total));\n    col = mix(col, albedo, fog); // vec3(0., 0., 0.), fog); // COLOR YOUR FOG!\n\n    // Toning\n    col = col*0.8 + 0.2*ACESFilm(col);\n    col = fDesaturate(col, 1.3);\n\n    // Use new vignette\n    col = fVignette(col, fragCoord);\n        \n    // Output to screen/target\n    fragColor = vec4(col,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Ravity:\n// This pass blurs the brightest parts of the framebuffer and flips the output horizontally and vertically\n\n#define SCALE 3.28\n#define BIAS -0.59\n\nvec4 threshold(vec4 color, float bias, float scale)\n{\n     return max(vec4(0.0), color + vec4(bias)) * vec4(scale);    \n}\n\n// Fastblur taken from 'fast hacky blur' by williammalo2\nvec4 fastBlur(sampler2D tex,vec2 p, float res)\n{\n    vec2 pixelSize = 1.0 / iResolution.xy;\n\tfloat pixSize = pow(1.7, res);\n    \n    vec4 blurred =\n\tpow(threshold(texture(tex,(p + pixSize * vec2(-1.5,-0.5)) * pixelSize, res + 1.0), BIAS, SCALE), vec4(2.2)) * 4.0 +\n    pow(threshold(texture(tex,(p + pixSize * vec2( 0.5,-1.5)) * pixelSize, res + 1.0), BIAS, SCALE), vec4(2.2)) * 4.0 +\n    pow(threshold(texture(tex,(p + pixSize * vec2( 1.5, 0.5)) * pixelSize, res + 1.0), BIAS, SCALE), vec4(2.2)) * 4.0 +\n    pow(threshold(texture(tex,(p + pixSize * vec2(-0.5, 1.5)) * pixelSize, res + 1.0), BIAS, SCALE), vec4(2.2)) * 4.0 +\n    pow(threshold(texture(tex,p * pixelSize,res+1.0),BIAS, SCALE),vec4(2.2));\n    blurred *= 0.058823529;\n    \n    return pow(blurred,vec4(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n\tvec2 uv = fragCoord;\n    vec3 col = fastBlur(iChannel0, uv, 0.8).xyz;\n    fragColor = vec4(col, length(col));\n}\n\nvoid mainImageVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tvec2 uv = fragCoord;\n    vec3 col = fastBlur(iChannel0, uv, 2.8).xyz;\n    fragColor = vec4(col, length(col));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// Ravity:\n// This pass samples the blurred highlights along a vector crossing the center of the screen\n// I kind of botched the halo but it looked nice so I just left it there\n\n// <superplek> Use DISTORTION sparingly, especially in VR.\n\n// Good for VR:\n#define NUM_GHOSTS 1 \n#define SPACING 0.1 \n#define WEIGHT 2.28 \n#define DISTORTION 0. \n\n/*\n// Perfect for 2D\n#define NUM_GHOSTS 1\n#define SPACING 0.4\n#define WEIGHT 3.28\n#define DISTORTION 4.314\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenTexCoord = fragCoord.xy / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, screenTexCoord);\n  \n    vec2 uv = screenTexCoord - vec2(0.5);\n    for (int i = 0; i < NUM_GHOSTS; i++) \n    { \n    \tcol += texture(iChannel0, SPACING * -uv / float(i) + vec2(0.5));\n    }\n    \n    col = col * pow(1.0 - length(uv), WEIGHT);\n\n   vec2 texelSize = vec2(1.0) / iResolution.xy;\n   vec3 distortion = vec3(-texelSize.x * DISTORTION, 0.0, texelSize.x * DISTORTION) * 10.0;\n   vec2 direction = normalize((vec2(0.5) - screenTexCoord) * SPACING);\n   float dist = pow(length(vec2(0.5) - screenTexCoord), 2.6f);\n   col.xyz += texture(iChannel0, screenTexCoord + direction * vec2(DISTORTION)).xyz * dist * 0.7;\n    \n   fragColor = vec4(clamp(col, 0.0, 1.0));\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}