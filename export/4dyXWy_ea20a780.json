{"ver":"0.1","info":{"id":"4dyXWy","date":"1466464463","viewed":4372,"name":"Simple efficient godrays","username":"tomator","description":"Use the mouse to move the small ring around.\n\nSimple godray effect using dithering to allow for much lower sample counts. An actual implementation in a game could use a small blur filter over the dithered result for a smoother image at a slight cost.","likes":63,"published":1,"flags":32,"usePreview":0,"tags":["rays","godrays","postprocess","lightrays","dithering","crepuscular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHER\t\t\t//Dithering toggle\n#define QUALITY\t\t0\t//0- low, 1- medium, 2- high\n\n#define DECAY\t\t.974\n#define EXPOSURE\t.24\n#if (QUALITY==2)\n #define SAMPLES\t64\n #define DENSITY\t.97\n #define WEIGHT\t\t.25\n#else\n#if (QUALITY==1)\n #define SAMPLES\t32\n #define DENSITY\t.95\n #define WEIGHT\t\t.25\n#else\n #define SAMPLES\t16\n #define DENSITY\t.93\n #define WEIGHT\t\t.36\n#endif\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 coord = uv;\n    vec2 lightpos = texture(iChannel0, uv).zw;\n   \t\n    float occ = texture(iChannel0, uv).x; //light\n    float obj = texture(iChannel0, uv).y; //objects\n    float dither = texture(iChannel1, fragCoord/iChannelResolution[1].xy).r;    \n        \n    vec2 dtc = (coord - lightpos) * (1. / float(SAMPLES) * DENSITY);\n    float illumdecay = 1.;\n    \n    for(int i=0; i<SAMPLES; i++)\n    {\n        coord -= dtc;\n        #ifdef DITHER\n        \tfloat s = texture(iChannel0, coord+(dtc*dither)).x;\n        #else\n        \tfloat s = texture(iChannel0, coord).x;\n        #endif\n        s *= illumdecay * WEIGHT;\n        occ += s;\n        illumdecay *= DECAY;\n    }\n        \n\tfragColor = vec4(vec3(0., 0., obj*.333)+occ*EXPOSURE,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float circle( vec2 pos, float r, vec2 uv )\n{\n    return distance(uv, pos) < r ? 1. : 0.;\n}\n\nvec3 sun( vec2 uv, vec2 p ) //x is result, yz are position in normalized coords.\n{\t\t\t\t\t\t\t //This is just a quick hack for this shader only.\n    vec3 res;\n    float di = distance(uv, p);\n    res.x =  di <= .3333 ? sqrt(1. - di*3.) : 0.;\n    \n    res.yz = p;\n    res.y /= (iResolution.x / iResolution.y);\n    res.yz = (res.yz+1.)*.5;\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy)*2.-1.; //coords to -1..1;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    vec2 mousep = (iMouse.xy / iResolution.xy)*2.-1.;\n    mousep.x *= aspect;\n    \n    float occluders = circle(vec2(-.66, 0.), .366, uv) -circle(vec2(-.75, -.1), .18, uv);\n    occluders += circle(vec2(.66, .222), .23, uv);\n    occluders += circle(mousep, .15, uv) - circle(mousep, .07, uv);\n    occluders = min(occluders, 1.);\n    \n    vec3 light = min(sun(uv, vec2(sin(iTime), sin(iTime*2.)*.5)), 1.);\n    float col = max(light.x - occluders, 0.);\n        \n    fragColor = vec4(col,occluders,light.yz); //Gross hack to pass light pos as B and A values\n}","name":"Buf A","description":"","type":"buffer"}]}