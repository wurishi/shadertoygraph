{"ver":"0.1","info":{"id":"DtGBz3","date":"1702308374","viewed":55,"name":"pine cone 2","username":"Efim","description":"this is last shader in series of \"pine cones\"","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","repetition","cone","pine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright (c) 2023 Efim Manevich\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n\n#define PI  3.14159265359\n#define TAU 6.28318530718\n\nconst float dist_infin = 10.0;\n#define nn 128\nconst float eps = 0.001;\n\n\nmat3 rotateX(float f) {\n    return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(f), -sin(f)), vec3(.0, sin(f), cos(f)));\n}\n\nmat3 rotateZ(float f) {\n    return mat3(vec3(cos(f), -sin(f), 0.0), vec3(sin(f), cos(f), 0.0), vec3(0.0, 0.0, 1.0));\n\n}\n\nmat3 rotateY(float f) {\n    return mat3(vec3(cos(f), 0.0, sin(f)), vec3(0.0, 1.0, 0.0), vec3(-sin(f), 0.0, cos(f)));\n}\n\n\nvec3 sdfColor;\nvec3 resColor;\nvec3 col1 = vec3(0.5019607843137255, 0.6705882352941176, 0.34509803921568627);\nvec3 col2 = vec3(0.4588235294117647, 0.16862745098039217, 0.21176470588235294);\nvec3 col3 = vec3(0.13333333333333333, 0.3254901960784314, 0.08235294117647059);\nvec3 col4 = vec3(0.4, 0.6509803921568628, 0.10588235294117647);\n\nfloat petalPine(vec3 pos, float w, float h)\n{\n    float rs = 4.*cos(iTime) + 8.;\n    vec3 p = rotateX(PI/rs)*pos;\n    float y = clamp(p.y/h, 0., 1.);\n    float lh = .5;\n    float yh = clamp((y - 1. + lh)/lh, 0., 1.); \n    float d = cos(yh*PI/2.)/2.0;\n    float x = clamp(p.x/w, 0.5-d, 0.5+d);\n    float midh = sin((0.5 - abs(x - 0.5))/0.5*PI/2.2)*(w+h)*0.03;\n    float z = 0.;\n    if (y < 1.-lh)\n        z = midh*y/(1.-lh);\n    else\n    {\n        float yyh = acos(2.*abs(x - 0.5))*2./PI*lh;\n        z = midh*((yyh + (1.-lh))-y)/(yyh + 0.001);\n    }\n    z*=(1. + y)*(1. + y);\n    \n    sdfColor = mix(col3, col1, vec3(y));\n    float pst = smoothstep(0.1, -0.1, (length(vec2(x-0.5, y - 0.5)) - 0.15));\n    z += pst*.01*(h+w);\n    sdfColor = mix(sdfColor, pow(col4, vec3(0.7)), pst);\n    return length(p - vec3(x*w, y*h, z))*0.4 - 0.005*(h+w);\n}\n\n\nfloat sdCosNp(vec2 p, float a) {\n    \n    float fi = atan(p.y, p.x);\n    float L = length(p.xy);\n    float d = dist_infin;\n    float r = a * cos(2. * fi);\n    if(p.x < 0.)\n        r = -.5;\n    d = min(abs(L - r), d);\n    float f = acos(L / a) / 2.;\n    d = min(2.0 * abs(sin((fi - f) / 2.0)) * L, d);\n    d = min(2.0 * abs(sin((fi + f) / 2.0)) * L, d);\n    return d;\n}\n\nfloat sdConePine3D(vec3 p, float a)\n{\n    float l = length(p.xy);\n    float h = -p.z + a/2.;\n    float d = sdCosNp(vec2(h, l), a);\n    \n    float n = 13.;\n    float m = 8.;\n    float st = 0.5;\n    float y = 1.0 - h/a;\n    float x = mod(atan(p.y, p.x), TAU)/TAU;\n    float row = floor(y*n);\n    y = y*n - row;\n    float shift = mod(st*row, 1.0);\n    x = mod(x - shift/m, 1.0);\n    x = fract(x*m);\n    \n    float rh = 2.*a/n;\n    float rw = (l-d)*TAU/m;\n    float x1 = x;\n    float y1 = y*0.5 + 0.5;\n    float x2 = mod(x - st, 1.0);\n    float y2 = y*0.5;\n    \n    float dl1 = petalPine(vec3(x1*rw, y1*rh, d), rw, rh);\n        resColor = sdfColor;\n    float dl2 = petalPine(vec3(x2*rw, y2*rh, d), rw, rh);\n    if (dl2 < dl1)\n        resColor = sdfColor;\n\n    float dl = min(dl1, dl2);\n    \n    d*=0.3;\n    if (d < dl)\n        resColor = col3;\n    d = min(d, dl);\n    return d;\n}\n\n\nfloat map(in vec3 pos) {\n   return sdConePine3D(pos, 2.);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos) {\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map(pos + k.xyy * h) +\n        k.yyx * map(pos + k.yyx * h) +\n        k.yxy * map(pos + k.yxy * h) +\n        k.xxx * map(pos + k.xxx * h));\n}\n\nstruct HIT {\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\nconst HIT hit_inf = HIT(dist_infin, vec3(0.0), vec3(0.0));\n\nHIT giper3D(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for(int i = 0; i < nn; i++) {\n        vec3 pos = ro + rd * t;\n        float h = map(pos);\n        if(h < eps || t >= dist_infin)\n            break;\n        t += h;\n    }\n\n    if(t >= dist_infin)\n        return hit_inf;\n\n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    return HIT(t, nor, pos);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p), r = normalize(cross(vec3(0, 1, 0), f)), u = cross(f, r), c = f * z, i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\n\nvec3 calccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n        col *= clamp(difu, 0.3, 1.0);\n    return col;   \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 light = normalize(vec3(0.0, 1.0, -2.5)); //light\n    vec3 light2 = normalize(vec3(0.0, -1.0, 2.5)); //light\n    float t = iTime / 3.;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n        m = (-iResolution.xy + 2.0 * (iMouse.xy)) / iResolution.y;\n        t = 0.;\n    }\n    vec3 ro = vec3(0.0, 0.0, 2.); // camera\n    ro = rotateY(-m.x * TAU) * rotateX(-m.y * PI) * ro; //camera rotation\n\n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n    mat3 rota  = rotateX(-PI/2.0)*rotateY(-t);\n    mat3 rota_1  = rotateY(t)*rotateX(PI/2.0);\n    \n\n    vec3 tot = vec3(0.0);\n\n    //antiblick\n    for(int m = 0; m < AA; m++) for(int n = 0; n < AA; n++) {\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n            vec3 rd = GetRayDir(p, ro, vec3(0, 0., 0), fl); //ray direction\n            vec3 col = vec3(1.); // background  \n\n            HIT giper = giper3D(rota * ro, rota * rd);\n            if(giper.dist < dist) {\n                vec3 nor = rota_1 * giper.nor;\n\n                col = resColor;\n                \n                \n                //float dif = clamp(dot(nor, light), 0.4, 1.0);\n                //float amb = 0.2 + 0.5 * dot(nor, light2);\n                //col = vec3(0.2, 0.3, 0.4) * amb + vec3(0.85, 0.75, 0.65) * dif;\n                col = calccolor(col, col, -rd, light, light2, nor);\n                col = pow( col, vec3(0.7));\n            }\n        // gamma        \n            //col = sqrt(col);\n            tot += col;\n        }\n    //antiblick\n    tot /= float(AA * AA);\n    fragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}