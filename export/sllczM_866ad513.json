{"ver":"0.1","info":{"id":"sllczM","date":"1648825490","viewed":116,"name":"Linear Regression AA","username":"harry7557558","description":"Showcase an anti-aliasing technique I developed for a raymarching demo.\nRead the comments for details. Mouse click to show image without AA.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["antialiasing","aa","leastsquare","linearregression"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Linear Regression Anti-Aliasing\n// Mouse click to show image without AA\n\n// Motivation:\n// I need to anti-alis renderings of user-input scalar field.\n// The usual AA technique for raymarching may not work well\n// because the SDF can be very ill-conditioned.\n// I tried to find a way to anti-alias arbitrary images\n// without supersampling or blurring the image.\n\n// Outline of the method:\n//  - Calculate image gradient and store in a buffer\n//  - For each pixel, find the line of best fit to pixels with high gradient\n//  - Determine the color at both sides of the line\n//  - Render the line separating the colors on the pixel using an AA technique\n\n// Works well for simple geometric shapes,\n// Not so good for thin lines and noisy pixels.\n// May be improved using quadratic regression (which is more expensive)\n\n// Set this number to 3 or 4 for images without thin lines/angles\n// (or images with a higher resolution):\n#define AA_RADIUS 2\n\n// Used in this (still incomplete) raymarching demo:\n// https://harry7557558.github.io/tools/raymarching-implicit/index.html\n// (AA_RADIUS is set to 3)\n\n\n// get image\n#define sv(p) texelFetch(iChannel0, p, 0).xyz\n// get magnitude of gradient\n#define sg(p) texelFetch(iChannel1, p, 0).xyz\n\n\n// for comparison\nvec3 boxBlur(ivec2 p0, int r) {\n    vec3 c = vec3(0.0);\n    for (int dx=-r; dx<=r; dx++) {\n    for (int dy=-r; dy<=r; dy++) {\n        c += sv(p0+ivec2(dx,dy));\n    }}\n    return c / float((2*r+1)*(2*r+1));\n}\n\n\n// linear regression AA\nvec3 aaLinreg(ivec2 p0, int r) {\n    //if (dot(sg(p0),vec3(1)) < 0.03) return sv(p0);\n\n    // find the line of best fit to the gradient\n    // https://www.desmos.com/calculator/cs4faizltl\n    float s1=0., sx=0., sy=0., sx2=0., sxy=0., sy2=0.;\n    for (int dx=-r; dx<=r; dx++) {\n    for (int dy=-r; dy<=r; dy++) {\n        vec3 g = sg(p0+ivec2(dx,dy));\n        float w = dot(g, vec3(1));\n        s1 += w;\n        sx += w*float(dx);\n        sy += w*float(dy);\n        sx2 += w*float(dx*dx);\n        sy2 += w*float(dy*dy);\n        sxy += w*float(dx*dy);\n    }}\n    float ml = s1*sxy-sx*sy;\n    if (ml==0.) return sv(p0); // no variance\n    float kl = (s1*sx2-s1*sy2+sy*sy-sx*sx)/ml;\n    vec2 ab = vec2(kl-sign(ml)*sqrt(kl*kl+4.), 2.);\n    float c = (ab.x*sx+ab.y*sy)/s1;\n    float abl = length(ab);\n    c /= abl, ab /= abl;\n    //return vec3(0,1,0);  // debug\n\n    // rasterize the line with AA\n    float ck = 0.5-1.0*c;\n    if (ck<0. || ck>1.) return sv(p0);\n    vec3 c0=vec3(0.), c1=vec3(0.); // color of two sides\n    float w0=0., w1=0.;\n    for (int dx=-r; dx<=r; dx++) {\n    for (int dy=-r; dy<=r; dy++) if (dx*dx+dy*dy<r*r) {\n        float d = dot(ab,vec2(dx,dy));\n        if (abs(d)>1.) continue; // prevent blurring\n        vec3 col = sv(p0+ivec2(dx,dy));\n        if (d<c) c0+=col, w0+=1.;\n        else c1+=col, w1+=1.;\n    }}\n    if (w0==0. || w1==0.) return sv(p0);\n    //return vec3(0,1,0);  // debug\n    return mix(c0/w0, c1/w1, clamp(ck,0.,1.)); // AA\n}\n\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    vec3 col = aaLinreg(p, AA_RADIUS);\n\n    // uncomment lines to compare\n    if (iMouse.z > 0.) {\n        //col = boxBlur(p, 1);\n        col = sv(p).xyz;\n        //col = vec3(dot(sg(p),vec3(1)));\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// render an aliased image\n\nvec3 scene1(vec2 uv) {\n    float k = abs(abs(length(uv)-0.5)-0.25)-0.12;\n    vec3 col = k>0. ? sin(20.*(uv.x*uv.y))>0. ? vec3(.8,.8,.2) : vec3(.2,.2,.8)\n        : vec3(1,0.5,0)*(0.5*sqrt(-k)+0.8+uv.x*uv.y);\n    return mix(col, vec3(step(dot(col,vec3(1)),1.5)), 0.6);\n}\n\nvec3 scene2(vec2 uv) {\n    uv *= 4.;\n    float a=uv.y-uv.x+4., b=uv.y+uv.x+4.;\n    float k = sin(min(a*sin(b),b*sin(a)))-cos(max(a*cos(b),b*cos(a)))-0.1;\n    return vec3(step(k,0.));\n}\n\nvec3 scene3(vec2 uv) {\n    float t = -4.0 / (uv.y-0.8); if (t<0.) return vec3(0.);\n    vec2 xy = uv * t;\n    return (sin(xy.x)*sin(xy.y)>0. ? vec3(0.8): vec3(0.2))*exp(-0.05*t);\n}\n\nvec3 scene4(vec2 uv) {\n    uv = (uv-vec2(1.,-1.2))/40.0;\n    return step(texture(iChannel0,uv).xyz, vec3(0.3));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 ci = 2.0 * coord / iResolution.xy;\n    vec2 pi = floor(ci);\n    vec2 uv = 2.0 * fract(ci) - 1.0;\n    if (pi==vec2(0,0)) col.xyz = scene3(uv);\n    if (pi==vec2(1,0)) col.xyz = scene2(uv);\n    if (pi==vec2(0,1)) col.xyz = scene1(uv);\n    if (pi==vec2(1,1)) col.xyz = scene4(uv);\n    col = vec4(clamp(col.xyz,0.,1.),1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// calculate the magnitude of image gradient\n\n#define s(p) texelFetch(iChannel0, p, 0).xyz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p0 = ivec2(gl_FragCoord.xy);\n    vec3 sx = s(p0+ivec2(1,0))-s(p0-ivec2(1,0));\n    vec3 sy = s(p0+ivec2(0,1))-s(p0-ivec2(0,1));\n    vec3 su = s(p0+ivec2(1,1))-s(p0-ivec2(1,1));\n    vec3 sv = s(p0+ivec2(1,-1))-s(p0-ivec2(1,-1));\n    vec3 g = 0.25*(sx*sx+sy*sy+su*su+sv*sv);\n    fragColor = vec4(g, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}