{"ver":"0.1","info":{"id":"ttlfWr","date":"1596518353","viewed":93,"name":"SlimeBox","username":"lechuga","description":"Im still learning, please let me know your feedback!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["random","box","generator","cuanticmslime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MD 200.\n#define MOD 20.\n\n#define speed time * 0.45\n\nfloat time;\nvec3 lpos;\nvec3 l;\nbool isFOV;\nfloat blue,purple;\n\nfloat slm;\n\nvec3 rep(in vec3 p, in float s, in float r){\n \treturn fract((p/s-r))*s-r;\n}\n\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat esf(in vec3 p, in float r){\n    return length(p)*0.4-r;\n}\n\nfloat cil(in vec3 p, in float r){\n \treturn length(p.xz)-r;\n}\n\nfloat box(in vec3 p, in float s){\n \treturn length(max(abs(p)-s, 0.));\n}\n\nfloat map(in vec3 p){\n    float t = time;\n    float r3 = 1.5+(sin(t+p.x)*cos(t*cos(t*.5)+p.y)*cos(t+p.z))*.6;\n\n    float scene = esf(p, r3);\n  \n    vec3 p1 = p;\n    p1.xz *= rot(cos(p1.y*0.02+time)*1.);\n    p1.zy *= rot(sin(p1.x*0.02+time)*1.);\n    \n    vec3 p2 = rep(p1-vec3(speed,0,speed), 2., 1.);\n    p2.xz *= rot(p2.y*0.02+time*0.2);\n    //p2.zy *= rot(p2.x*0.02+time);\n\tvec3 p3 = abs(p2);\n    p3.xz *= rot(p3.z*.2+cross(p3, p2).z)+speed*0.15+2.;\n    \n    \n    float\n        e1 = box(p1, 2.6),\n        e2 = cil(p3, 0.00001)*0.2,\n        e3 = esf(p1, r3)*2.;\n    purple += .2/(.05+e1);\n    blue += .1/(.05+e2);\n    \n    scene = max(-scene, e2);\n    scene = min(scene, e1);\n    scene = min(scene, e3);\n    \n    l+= smoothstep(0., 1.,p1+speed*.5)*0.4;\n    lpos -= cos(speed+p1)*0.5;\n    \n    slm = e3;\n    \n    return scene;\n}\n\nvec3 normals(in vec3 p){\n    vec2 e = vec2(.01, 0.);\n    vec3 n = p - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n    return normalize(n);\n}\n\nvec3 cam(vec3 ro, vec2 uv){\n    float FOV = .2;\n    vec3 lt = vec3(0.);\n    \n    vec3 f = normalize(lt-ro);\n    vec3 r = cross(vec3(0.,1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro+f*FOV;\n\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    return i-ro; // rd\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = (mod(iTime, MOD));\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv *= iResolution.xy/iResolution.x;\n    \n    vec3 ro = vec3(1., 1., -7.);\n    \n    vec3 rd = cam(ro, uv);\n    \n    vec3 rv;\n    float d;\n    for(float i = 0.; i < MD; i++){\n        vec3 p = ro+rd*d;\n        d += map(p);\n        if((slm <= .08)){\n            vec3 n = normals(p);\n            rd = refract(p,n, .5)*0.03;\n    \t}\n        else if(d < 0.00001) break;\n    }\n\n    vec3 p = ro+rd*d;\n    l = normalize(lpos-p);\n    vec3 n = normals(p);\n    \n    float dif = (clamp((dot(n,l)*cos(speed*0.3)*.5), 0.4, 1.));\n    \n    vec3 col = vec3(dif*1.1);\n    col += rv;\n    col += blue * 0.01 * vec3(.02, 0.213, 0.3985);\n    col += purple * 0.05 * vec3(0.2, 0.1, 0.35);\n\n    col -= 1.-length(uv)*.2;\n    col += exp(col-.55);\n    col = pow(col, vec3(.5));\n    \n    fragColor = vec4(col, .1);\n}","name":"Image","description":"","type":"image"}]}