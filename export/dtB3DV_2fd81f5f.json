{"ver":"0.1","info":{"id":"dtB3DV","date":"1674898728","viewed":78,"name":"try fluid 02","username":"cailuming","description":"try the 2d fluid without conservation, when enlarge the force, the fluid will break. Thus the conservation is necessary.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["2dfluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from iq's article https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec4 fluidInfo = texture(iChannel0,uv);\n    vec3 bgcolor = texture(iChannel1,uv-fluidInfo.xy/iResolution.xy+fluidInfo.w).xyz;\n    vec3 col =  palette((1.0-smoothstep(0.0,4.0,fluidInfo.w))*0.4,vec3(0.0,0.3,0.5),vec3(1.0,1.0,1.0),vec3(0.4,1.0,1.0),vec3(1.0,0.0,0.0));\n  \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//try to understand how multi buffer works and how to process basic velocity and\n//pressure changes.there is still no conservation.\n#define PI 3.1415926\n\nmat2 rot2D(float v){\n   float c = cos(v);\n   float s = sin(v);\n   return mat2(c,s,-s,c);\n}\n\nconst uint k = 1103515245U;  // GLIB C\n \nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n//heart shape\nfloat Heart(vec2 uv,vec2 c,float as,float r1)\n{\n     uv-=c;\n     uv.x*=as; \n    \n     uv*=6.0;\n     uv*=rot2D(PI*0.5);\n     float theta = atan(uv.y,uv.x);\n     float cur_arc = mod(abs(theta),PI);\n     //modem the heart shape\n     float inter =sin(cur_arc*0.07)*(4.+sin(5.0+cur_arc*2.)*0.5+sin(iTime*5.+cur_arc*2.)*0.2);\n    \n     vec2 formula = vec2(r1*inter*cos(theta),r1*inter*sin(theta));\n   \n     float v = length(uv-formula);\n     v = 0.01/v;\n     v = pow(v,2.7);\n     return smoothstep(0.0,1.0,v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    vec2 up = vec2(0,1)/iResolution.xy;\n    vec2 right =  vec2(1,0)/iResolution.xy;\n    //////////////////////////////////\n    //For clamp the uv not to exceed\n    //////////////////////////////////\n    vec2 uvx = uv+right; uvx.x = clamp(uvx.x,0.0,1.0);\n    vec2 uvy = uv+up;    uvx.y = clamp(uvx.y,0.0,1.0);\n    \n    //xy is velocity,z is pressure,w is density or temperature\n    vec4 fluidInfo = texture(iChannel0,uv);\n    \n    ///////////////irrelevant to fluid,just make some fun/////////\n    if(iMouse.z > 0.2){fluidInfo.w += 0.11*Heart(uv,muv,aspect,0.5);}\n    if(mod(float(iFrame),3.0)<=0.8){\n       fluidInfo.w += 3.5*Heart(uv,hash(uvec3(fluidInfo.xw,iTime)).xy,aspect,0.5);\n    }\n    ////////////////////////////////////////////////////////////\n    \n    fluidInfo.x += fluidInfo.z - texture(iChannel0,uvx).z;\n    fluidInfo.y += fluidInfo.z - texture(iChannel0,uvy).z;\n    \n    fluidInfo.y -=0.001*fluidInfo.w;\n     \n    fluidInfo.xy = fluidInfo.xy*0.999;\n    if(uv.x>=0.998||uv.y>=0.998||uv.x<=0.001||uv.y<=0.002) fluidInfo.xy = vec2(0,0);\n    // Output to screen\n    fragColor = fluidInfo;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 up = vec2(0,1)/iResolution.xy;\n    vec2 right = vec2(1,0)/iResolution.xy;\n    \n    \n    vec4 fluidInfo = texture(iChannel0,uv);\n    vec2 uvx = uv-right; uvx.x = clamp(uvx.x,0.0,1.0);\n    vec2 uvy = uv-up;    uvx.y = clamp(uvx.y,0.0,1.0);\n    \n    fluidInfo.z -= (fluidInfo.x-texture(iChannel0,uvx).x)*0.5;\n    fluidInfo.z -= (fluidInfo.y-texture(iChannel0,uvy).y)*0.5;\n    \n    // Output to screen\n    fragColor = fluidInfo;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //xy is velocity,z is pressure,w is density\n    vec4 fluidInfo = texture(iChannel0,uv);\n     \n    // Output to screen\n    fragColor = texture(iChannel0,clamp(uv-fluidInfo.xy/iResolution.xy,0.0,1.0));\n}","name":"Buffer C","description":"","type":"buffer"}]}