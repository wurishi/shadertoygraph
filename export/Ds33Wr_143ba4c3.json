{"ver":"0.1","info":{"id":"Ds33Wr","date":"1677126945","viewed":113,"name":"Creepy dude!","username":"ianertson","description":"Nothing serious, look around with the mouse :)","likes":5,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","creepy","human"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\n\nvec3 getAvg(vec2 uv) {\n    vec2 tex = 1.0 / R.xy;\n    vec3 center = getColor(uv);\n    vec3 right = getColor(uv + (vec2(1, 0)*tex));\n    vec3 left = getColor(uv + (vec2(-1, 0)*tex));\n    vec3 up = getColor(uv + (vec2(0, 1)*tex));\n    vec3 down = getColor(uv + (vec2(0, -1)*tex));\n    \n    return (center + right + left + up + down) / 5.0;\n}\n\nvec3 getSmooth(vec2 uv, float f) {    \n    vec2 dx = dFdx(uv) * (f+0.5) * 3.;\n    vec2 dy = dFdy(uv) * (f+0.5) * 3.;\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    vec3 c = getAvg(uv);\n    \n    return mix(mix(a, b, 0.5), c, 0.5);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n\n    col = mix(col, getSmooth(uv, depth*1.6), clamp(depth*2., 0.0, 1.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T ((iTime+2.9))\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define IDQ vec4(0, 0, 0, 1)\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a, b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, o_, id_) if (var < dist) { data.id = id_; data.o = o_; dist = var; }\n#define TEXTURE_SIGNATURE in vec2 uv, inout Material m\n\n#define EST_NORM_FOR(TEXFUNC, UV, N, M, COMPFUNC, RADI, Z, CLR, MIX, VAR)\\\n{\\\n    float a = COMPFUNC(CLR);\\\n    float e = RADI;\\\n    VAR = fixNormal(N, normalize(a - vec3(\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, 0), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(0, e), M)),\\\n        Z\\\n    )), MIX);\\\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(0.1, dot(wn, n))));\n}\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nstruct Material {\n    float rough;\n    float spec;\n    float refl;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Object {\n    vec3 p;\n    vec4 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), IDQ)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    Object o;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, NEW_OBJECT, NEW_MATERIAL)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: {\n            float d = distance(light.p, p);\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(d, 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            const float cutoff = 0.8;\n            vec3 ld = normalize(light.d);\n            vec3 sd = normalize(light.p - p);\n            float cone = dot(sd, ld);\n            float amp = smoothstep(cutoff, 1.0, cone);\n            return light.c * light.s * amp;\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\nvec3 pointQuat(vec3 v, vec4 q){ \n\treturn v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);\n}\n\nvec2 uvBox(in vec3 p, in vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    return uv;\n}\n\nvec2 uvBoxAbs(in vec3 p, in vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, round(adot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, round(adot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, round(adot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nvec2 uvSphere(in vec3 p) {\n    vec2 uv = vec2(0.0);\n    uv.y = acos(p.x);\n    uv.x = atan(p.y, p.z);\n    uv = uv * 2.0 - 1.0;\n    uv.x = 0.5 + uv.x / (M_PI);\n    uv.y = 0.5 - uv.y / M_PI;\n    return uv;\n}\n\nfloat hash21(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    uvec2 w = (~p) >> 2U;\n    p += (s);\n    p ^= (p << 17U) << s;\n    s ^= ((p.x << 3U) ^ (p.y >> 3U) << (w.x+w.y));\n    p ^= (p >> 9U) << (~s);\n    w ^= (p << 7U);\n    p ^= (p << 5U) << (~s >> 3U);\n    uint n = ((((p.x^w.y) >> 3U) + ((p.y^w.x) << 3U)) << 2U) ^ (((~p.y^w.x) ^ (~p.x^w.y)));\n    return float(n*503339U) / float(0xFFFFFFFFU);\n}\n\nvec3 hash23(in vec2 ip, in float seed) {\n    return vec3(hash21(ip, seed), hash21(ip, seed+seed+0.321), hash21(ip, seed+seed+seed+0.9828));\n}\n\nfloat hash31(in vec3 ip, in float seed) {\n    uvec3 p = uvec3(floatBitsToUint(ip.x), floatBitsToUint(ip.y), floatBitsToUint(ip.z));\n    uint s = floatBitsToUint(seed);\n    p ^= (p << 17U) + p.z;\n    s ^= ((p.x << 3U) ^ (p.y >> 3U) ^ (p.z << 3U));\n    p ^= (p >> 5U);\n    p ^= (p << 3U);\n    p = (p + (s >> 14U));\n    uint n = (((p.x >> 3U) + (p.y << 3U) + (p.z >> 3U)) << 2U) ^ ((~p.y ^ ~p.x ^ ~p.z));\n    return float(n*503339U) / float(0xFFFFFFFFU);\n}\n\nvec3 hash33(in vec3 ip, in float seed) {\n    return vec3(\n        hash31(ip, seed),\n        hash31(ip, seed+seed+0.321),\n        hash31(ip, seed+seed+seed+0.9828)\n     );\n}\n\nfloat noise21(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x), lv.y);\n}\n\nfloat noise21(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    #define ADV n += amp * noise21(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV\n    \n    return n / div;\n    \n}\n\nvec3 noise23(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(mix(hash23(id, seed), hash23(id+vec2(1, 0), seed), lv.x),\n        mix(hash23(id+vec2(0, 1), seed), hash23(id+vec2(1, 1), seed), lv.x), lv.y);\n}\n\nvec3 noise23(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    #define ADV n += amp * noise23(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV\n    \n    return n / div;\n    \n}\n\n\n\n\n\nfloat noise31(in vec3 p, in float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return \n        mix(\n            mix(\n                mix(hash31(id+vec3(0, 0, 0), seed), hash31(id+vec3(1, 0, 0), seed), lv.x),\n                mix(hash31(id+vec3(0, 1, 0), seed), hash31(id+vec3(1, 1, 0), seed), lv.x),\n                lv.y\n            ),\n             mix(\n                mix(hash31(id+vec3(0, 0, 1), seed), hash31(id+vec3(1, 0, 1), seed), lv.x),\n                mix(hash31(id+vec3(0, 1, 1), seed), hash31(id+vec3(1, 1, 1), seed), lv.x),\n                lv.y\n            ),\n            lv.z\n        );\n}\n\nfloat noise31(in vec3 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    #define ADV n += amp * noise31(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV\n    \n    return n / div;\n}\n\nvec3 noise33(in vec3 p, in float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return \n        mix(\n            mix(\n                mix(hash33(id+vec3(0, 0, 0), seed), hash33(id+vec3(1, 0, 0), seed), lv.x),\n                mix(hash33(id+vec3(0, 1, 0), seed), hash33(id+vec3(1, 1, 0), seed), lv.x),\n                lv.y\n            ),\n             mix(\n                mix(hash33(id+vec3(0, 0, 1), seed), hash33(id+vec3(1, 0, 1), seed), lv.x),\n                mix(hash33(id+vec3(0, 1, 1), seed), hash33(id+vec3(1, 1, 1), seed), lv.x),\n                lv.y\n            ),\n            lv.z\n        );\n}\n\nvec3 noise33(in vec3 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    #define ADV n += amp * noise33(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV\n    \n    return n / div;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sclamp(float v, float mi, float ma, float k) {\n    return smax(mi, smin(ma, v, k), k);\n}\n\nfloat sabs(float a, float k) {\n    return smax(-a, a, k);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\nfloat onCycle(float from, float to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\n\nvec4 quatFor(vec3 dir, vec3 up)\n{\n    if (abs(length(dir)) <= 0.000002) return IDQ;\n    vec3 axis = normalize(cross(up, dir));\n    float angle = acos(dot(dir, up));\n    float halfAngle = angle * 0.5;\n    float s = sin(halfAngle);\n    vec4 q = vec4(axis * s, cos(halfAngle));\n    return normalize(q);\n}\nvec4 quatMul(vec4 q1, vec4 q2) {\n    vec4 q = IDQ;\n    q.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    q.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    q.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    q.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return normalize(q);\n}\n\nvec4 quatInv(vec4 q) {\n    float n = sqrt(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);\n    \n    return vec4(\n        -q.x / (n*n),\n        -q.y / (n*n),\n        -q.z / (n*n),\n        -q.w / (n*n)\n    );\n}\n\nvec3 pointMat(vec3 p, mat4 m) {\n    return (vec4(p, 1.0) * m).xyz;\n}\nmat4 quatMat(vec4 q)\n{\n    float xx = q.x * q.x;\n    float xy = q.x * q.y;\n    float xz = q.x * q.z;\n    float xw = q.x * q.w;\n\n    float yy = q.y * q.y;\n    float yz = q.y * q.z;\n    float yw = q.y * q.w;\n\n    float zz = q.z * q.z;\n    float zw = q.z * q.w;\n\n    mat4 result = mat4(1.0);\n    result[0][0] = 1.0 - 2.0 * (yy + zz);\n    result[1][0] = 2.0 * (xy - zw);\n    result[2][0] = 2.0 * (xz + yw);\n    result[3][0] = 0.0;\n\n    result[0][1] = 2.0 * (xy + zw);\n    result[1][1] = 1.0 - 2.0 * (xx + zz);\n    result[2][1] = 2.0 * (yz - xw);\n    result[3][1] = 0.0;\n\n    result[0][2] = 2.0 * (xz - yw);\n    result[1][2] = 2.0 * (yz + xw);\n    result[2][2] = 1.0 - 2.0 * (xx + yy);\n    result[3][2] = 0.0;\n\n    result[0][3] = 0.0;\n    result[1][3] = 0.0;\n    result[2][3] = 0.0;\n    result[3][3] = 1.0;\n\n    return result;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 79.0\n#define STEPS 86\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_HUMAN 2\n#define ID_HUMAN_EYE 3\n#define ID_HUMAN_HEAD 4\n#define ID_HUMAN_NECK 5\n#define ID_HUMAN_TORSO 6\n#define ID_HUMAN_LEG 7\n#define ID_HUMAN_ARM 8\n#define ID_HUMAN_SHOE 9\n#define ID_HUMAN_PALM 10\n\n\n#define DEBUG_HEAD 0\n#define HUMAN_MOVE_T (T*0.5)\n#define HUMAN_MOVE_LEG_T (HUMAN_MOVE_T*M_PI)\n\nObject getHuman() {\n    Object o = NEW_OBJECT;\n    float Y = 1.1;\n    vec3 origin = vec3(0, Y, 0);\n    vec3 pos = origin;\n    \n    float time = T*0.5;\n    float nrSteps = 3.0;\n    float transTime = 0.9;\n    float frame = 1.0;\n    \n  //  pos = onCycle(pos, vec3(2.0, Y, 0.0), time, nrSteps, transTime, frame);\n   // frame += 1.0;\n    \n  //  pos = onCycle(pos, vec3(3.0, Y, 1.0), time, nrSteps, transTime, frame);\n    //frame += 1.0;\n    \n //   pos = onCycle(pos, origin, time, nrSteps, transTime, frame);\n    //frame += 1.0;\n    \n    vec3 vel = vec3(cos(HUMAN_MOVE_T), 0, sin(HUMAN_MOVE_T));\n    pos += vel*2.;\n    vec4 q = IDQ;\n    \n    q = quatFor(vel, vec3(-1, 0, 0));\n    \n   // if () {\n      \n      //  q = quatFor(dir, vec3(0, 0, 1));\n   // }\n    \n   // vec4 q = quatFor(vec3(cos(time), 0.0, sin(time)), vec3(0, 0, 1));\n    \n    o.p = pos;\n    o.q = q;\n    return o;\n}\n\nvec3 fnoise(in vec2 p, in float seed) {\n    p = (p + (seed * 16.09238165)) / 256.0;\n    return textureLod(iChannel3, p, 0.0).xyz;\n}\n\nvec3 fnoise(in vec2 p, in float seed, in float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * fnoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV\n    \n    return n / div;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat cylSDF(in vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);   \n    return e + i;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat humanSDF(in vec3 p, inout int id, inout Object oHuman) {\n    id = ID_HUMAN_TORSO;\n    float dist = FAR;\n    Object ooHuman = oHuman;\n    \n    p = pointQuat(p, oHuman.q);\n    \n    vec3 pNor = normalize(p);\n    vec3 op = p;\n    \n   // p.xz *= rot(T);\n    \n    float height = 1.77;\n    float width = 0.25;\n    float thick = 0.2;\n    float torsoHeight = height / 5.5;\n    float torsoThick = thick * 0.5;\n    float legHeight = height / 2.5;\n    float legThick = thick / 2.4;\n    float shoeHeight = thick / 2.3;\n    float shoeThick = thick / 2.2;\n    float armThick = thick / 2.9;\n    float armHeight = legHeight*0.9;\n    float palmThick = armThick/1.2;\n    float neckHeight = torsoHeight / 4.0;\n    float neckThick = thick / 2.3;\n    float headR = thick / 1.3;\n    \n    float shoulder = smoothstep(0.12, 0.9, max(0.0, abs(p.x) -max(0.0, -p.y)));\n    float legMerge = smoothstep(0.19, 0.5, max(0.0, abs(p.x) -max(0.0, p.y)));\n    \n    float waist = smoothstep(0.0, 1.0, max(0.0, abs(p.x)*smoothstep(0.5, 0.0, abs(p.y+0.1))));\n   \n\n    float torso = boxSDF(p, vec3(max(0.03, width-waist), max(0.20, torsoHeight - (shoulder + legMerge)), torsoThick));\n    \n    float rad = 0.27;\n    float fea = rad*0.3;\n    torso += cdot(pNor, vec3(0, 0, -1)) * clamp(-p.z*16., 0.0, 1.0) * 0.09*max(0.0, 1.0 - smoothstep(rad-fea, rad+fea, distance(p, vec3(0, -torsoHeight/4., thick+0.01))));\n    torso /= 2.1;\n    \n    float legMuscle = ((0.5+sin((p.y-legHeight/2.)*6.28)) * 0.5)*0.04;\n    \n    float leg = FAR;\n    float shoe = FAR;\n    \n    vec3 legPos = vec3(abs(-width/2.3), -(torsoHeight + legHeight),abs(-((thick/2.0) - legThick)));\n  //  float legAngle = radians(mix(-10.0, 10.0, 0.5+(0.5*cos(T + floor(p.x*(width+shoeThick))))));\n\n    \n    Object oLeg = NEW_OBJECT;\n    Object oLegLeft = NEW_OBJECT;\n    Object oLegRight = NEW_OBJECT;\n    // Object(HUMAN_POS + vec3(-width/2.3, 0., (thick/2.0) - legThick), vec4(sin(legAngleLeft), 0, 0, cos(legAngleLeft)))\n    float legLeft = FAR;\n    float legRight = FAR;\n    float shoeLeft = FAR;\n    float shoeRight = FAR;\n    \n   /* {\n        vec3 p = op;\n        p = pointQuat(p, oLeg.q);\n        float leg = cylSDF(\n            vec3(abs(p.x), p.y, abs(p.z)) -\n            legPos,\n            vec3(0, 0, 0), vec3(0, legHeight, 0),\n            (legThick + legMuscle)/1.2\n        );\n    \n    \n        shoe = cylSDF(\n            vec3(abs(p.x), p.y, p.z) - vec3(abs(-width/2.3), -(torsoHeight + legHeight + shoeHeight), 0.0),\n            vec3(0, 0, 0),\n            vec3(0, shoeHeight, 0),\n            shoeThick + max(0.0, sclamp(((-p.z) - (0.8*sabs(0.1-sabs(p.x, 0.01), 0.2))), 0.0, 0.12, 0.09))\n        );\n    \n    }*/\n    \n     {\n         float legAngleLeft = radians(mix(-10.0, 10.0, 0.5+(0.5*cos(HUMAN_MOVE_LEG_T))));\n        oLegLeft = Object(oHuman.p + vec3(-width/2.3, 0., (thick/2.0) - legThick), vec4(sin(legAngleLeft), 0, 0, cos(legAngleLeft)));\n       // oLegLeft.q = quatMul(oLegLeft.q, oHuman.q);\n        vec3 p = op;\n\n        p = pointQuat(p, oLegLeft.q);\n        oLegLeft.q = quatMul((oHuman.q), oLegLeft.q);\n        legLeft = cylSDF(\n            vec3((p.x), p.y, (p.z)) -\n            vec3((-width/2.3), -(torsoHeight + legHeight),(-((thick/2.0) - legThick))),\n            vec3(0, 0, 0), vec3(0, legHeight, 0),\n            (legThick + legMuscle)/1.2\n        );\n    \n    \n        shoeLeft = cylSDF(\n            vec3((p.x), p.y, p.z) - vec3((-width/2.3), -(torsoHeight + legHeight + shoeHeight), 0.0),\n            vec3(0, 0, 0),\n            vec3(0, shoeHeight, 0),\n            shoeThick + max(0.0, sclamp(((-p.z) - (0.8*sabs(0.1-sabs(p.x, 0.01), 0.2))), 0.0, 0.12, 0.09))\n        );\n    \n    }\n    \n    {\n        float rightAngle = radians(mix(-10.0, 10.0, 0.5+(0.5*sin(HUMAN_MOVE_LEG_T))));\n        oLegRight = Object(oHuman.p + vec3(-width/2.3, 0., (thick/2.0) - legThick), vec4(sin(rightAngle), 0, 0, cos(rightAngle)));\n        //oLegRight.q = quatMul(oLegRight.q, oHuman.q);\n        vec3 p = op;\n        p = pointQuat(p, oLegRight.q);\n                oLegRight.q = quatMul((oHuman.q), oLegRight.q);\n\n        legRight = cylSDF(\n            vec3((p.x), p.y, (p.z)) -\n            vec3((width/2.3), -(torsoHeight + legHeight),(-((thick/2.0) - legThick))),\n            vec3(0, 0, 0), vec3(0, legHeight, 0),\n            (legThick + legMuscle)/1.2\n        );\n    \n    \n        shoeRight = cylSDF(\n            vec3((p.x), p.y, p.z) - vec3((width/2.3), -(torsoHeight + legHeight + shoeHeight), 0.0),\n            vec3(0, 0, 0),\n            vec3(0, shoeHeight, 0),\n            shoeThick + max(0.0, sclamp(((-p.z) - (0.8*sabs(0.1-sabs(p.x, 0.01), 0.2))), 0.0, 0.12, 0.09))\n        );\n    \n    }\n    \n    if (legRight < legLeft) {\n        leg = legRight;\n        oLeg = oLegRight;\n    } else {\n        leg = legLeft;\n        oLeg = oLegLeft;\n    }\n    \n    if (shoeRight < shoeLeft) {\n        shoe = shoeRight;\n    } else {\n        shoe = shoeLeft;\n    }\n\n   // shoe += (abs(dot(pNor, vec3(1, 0, 0))) * max(0.0, 1.0 - (abs(p.z)+abs(p.y*0.9))));\n    \n    float armMuscle = clamp((1.0-smoothstep(0.1, 0.5, abs(p.x))) - max(0.0, -(p.z*16.)), 0.0, 1.0);\n    armMuscle *= max(0.0, p.y*2.5);\n    \n    vec3 armPos = vec3(abs(-width/2.), torsoHeight / 1.9, 0);\n    \n    float arm = cylSDF(\n        vec3(abs(p.x), p.y, p.z) - armPos,\n        vec3(0, 0, 0),\n        vec3(abs(-armHeight), 0, 0),\n        armThick + (0.06*armMuscle)\n    );\n    \n    float palm = cylSDF(\n        vec3(abs(p.x), p.y, p.z) - (armPos + vec3(armHeight + (palmThick/2.), 0, -palmThick/2.)),\n        vec3(0, 0, 0),\n        vec3(0, 0, palmThick*1.1),\n        palmThick\n    );\n    \n    float neck = cylSDF(\n        p - vec3(0, (torsoHeight), 0),\n        vec3(0, 0, 0),\n        vec3(0, neckHeight, 0),\n        neckThick\n    );\n    \n    \n    \n    vec3 headPos = vec3(0, torsoHeight + headR + (neckHeight/2.), 0);\n    \n    float headAngle = radians(mix(-30.0, 30.0, 0.5+(0.5*cos(T))));\n    Object oHead = Object(headPos + oHuman.p, vec4(0, sin(headAngle), 0, cos(headAngle)));\n    \n    p = pointQuat(p, oHead.q);\n                    oHead.q = quatMul((oHuman.q), oHead.q);\n\n    \n    \n    float headShape = max(0.01, headR - (smoothstep(0.06, 0.9,abs(p.x)) + smoothstep(0.05, 0.9, max(0.0, p.z))));\n    \n    vec3 pHead = p - headPos;\n    vec3 pn = normalize(pHead);\n\n    headShape += pow(max(0.0, dot(pn, vec3(0, 0, -1))), 86.0)*0.04;\n  //  headShape -= (pow(adot(pn, vec3(1, 0, 0)), 4.0)*0.11) * smoothstep(-0.03, 0.09, smax(0.0, -pHead.y, 0.05))*1.6;\n    \n    headShape -= smoothstep(0.0, 0.16, smax(0.0, -pHead.z, 0.1)) * (\n        (\n            smoothstep(0.07, 0.29, abs(pHead.x)) *\n            smoothstep(0.0, 0.06, smax(0.0, pHead.y, 0.1))\n        ) +\n        (\n            smoothstep(0.05, 0.16, abs(pHead.x)) *\n            smoothstep(0.07, 0.3, smax(0.0, -(p.y-headPos.y*1.1), 0.2))\n        )\n    ) / 2.2;\n    \n    headShape += smoothstep(0.0, 0.16, smax(0.0, -pHead.z, 0.1)) * \n        smoothstep(0.02, 0.09, max(0.0, -pHead.y))*0.03*\n        smoothstep(0.1, 0.0, abs(pHead.x));\n    \n    \n    float head = sphereSDF(\n        p - headPos,\n        max(0.06, headShape)\n    );\n    \n    head += sabs(dot(pNor, vec3(1, 0, 0)), 0.2)*0.1;\n    \n    vec3 eyePos = (headPos + vec3(abs(-0.04), 0.03, -headR));\n    \n    float eye = sphereSDF(\n       vec3(abs(p.x), p.y, p.z) - eyePos,\n        0.03 \n    );\n    \n    float eyeBall = sphereSDF(\n        vec3(abs(p.x), p.y, p.z) - (eyePos + vec3(0, 0, 0.03)),\n        0.016\n    );\n    \n    vec3 mouthPos = vec3(0, -0.06, -(headR+0.02));\n    \n    float upperLipY = 0.01+((0.5*(0.5+cos(T*6.)))*0.009);\n    float mouthY = 0.016;\n    float upperLip = (0.5 + max(0.01, 1.0 - smoothstep(0.0, upperLipY, smax(0.0, (pHead.y - mouthY) - (mouthPos.y), 0.02))));\n    float lowerLip = (0.5 + max(0.01, 1.0 - smoothstep(0.0, upperLipY, smax(0.0, (mouthPos.y-mouthY) - (pHead.y-mouthY), 0.02))));\n    float mouth = sphereSDF(\n        (p - (headPos + mouthPos)) - vec3(0.0, mouthY, 0.0),\n        0.03 * smin(upperLip, lowerLip, 0.8)\n    );\n\n    \n    head = smax(head, -eye, 0.02);\n    head = smax(head, -mouth, 0.01);\n    head /= 2.6;\n    \n    dist = torso;\n    \n    \n   // if (arm < dist) { dist = arm; }\n    if (neck < dist) { dist = neck; id = ID_HUMAN_NECK; }\n    \n    \n    if (eyeBall < dist) { dist = eyeBall; id = ID_HUMAN_EYE; }\n   // if (palm < dist) { dist = palm; }\n    arm = smin(arm, palm, 0.09);\n    \n    if (arm < dist) { id = ID_HUMAN_ARM; }\n    dist = smin(dist, arm, 0.33*max(0.0, p.y));\n    \n    if (head < dist) { dist = head; id = ID_HUMAN_HEAD; oHuman = oHead; } else { oHuman = ooHuman; }\n    if (leg < dist) { dist = leg; id = ID_HUMAN_LEG; oHuman = oLeg; }\n    if (shoe < dist) { dist = shoe; id =  ID_HUMAN_SHOE; oHuman = oLeg; }\n  //  if (palm <= dist) { id = ID_HUMAN_PALM; }\n    return dist;\n}\n\nfloat groundSDF(in vec3 p) {\n    float h = noise21(p.xz, 0.7767221, 0.1);\n    h *= 2.0;\n    \n    float amp = smoothstep(4.0, 16.0, distance(p.xz, vec2(0.0)));\n    \n    h *= amp*2.;\n    \n    return p.y - h;\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n \n    int humanId = 0;\n    Object oHuman = getHuman();//Object(HUMAN_POS, IDQ);\n    float human = humanSDF(p - oHuman.p, humanId, oHuman);\n    SAMPLE(human, oHuman, humanId);\n    \n    SAMPLE(ground, o, ID_GROUND);\n    \n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.d = dist;\n    \n    float f = 0.001;\n    vec2 e = vec2(f, 0.0);\n    \n    data.n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    \n    data.uv = uvBox(pointQuat(data.p - data.o.p, data.o.q), pointQuat(data.n, data.o.q));\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far) {\n    float dist = 0.0;\n    \n    Data data = NEW_DATA;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= min(far, FAR)) return 1.0;\n    }\n    \n    return clamp(abs(dist) / (0.2+abs(near)), 0.0, 0.77);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd, in Light light) {\n    vec2 uv = rd.xz / rd.y;\n    \n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    vec3 c1 = rgb(136, 195, 229);\n    vec3 c2 = rgb(16, 72, 157);\n    \n    vec3 col = mix(c1, c2, dotup);\n    \n    vec2 shift = vec2(cos(T*0.1), sin(T*0.1));\n    \n    float reg = noise21(uv + (shift * 9.), 0.582731, 0.25);\n    \n    shift += vec2(sin(reg*2.), cos(reg*2.))*0.06;\n    \n    float cloudsLow = noise21(uv + shift, 0.982733, 1.0);\n    cloudsLow = pow(cloudsLow, 2.0);\n    \n    float cloudsHigh = noise21(uv - shift, 0.782731, 20.0);\n    cloudsHigh = pow(cloudsHigh, 2.0);\n    \n    float clouds = mix(cloudsLow, cloudsHigh, reg*(0.5+(0.5*sin((T*0.07)+(reg*10.)))));\n    \n    clouds = pow(clouds, 2.0);\n    \n    col += clouds;\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE skinTexture\n\n//#define DEBUG_TEXTURE jeansTexture\n\nvec3 jeansTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(85, 108, 148);\n    vec3 c2 = rgb(171, 183, 207);\n    vec3 c3 = rgb(47, 72, 112);\n    \n    vec3 alt = fnoise(uv, 7.029143, 128.0);\n    \n    col += c1 * alt.x;\n    col += c2 * alt.y;\n    col += c3 * alt.z;\n    \n    vec2 lv = floor(uv*256.);\n    float g = mod((lv.x-lv.y)+ceil(alt.x-0.3), 2.0);\n    \n    col += c2 * g * alt.y;\n    \n    col = pow(col, vec3(1.0 / 0.4));\n    \n    return col;\n}\n\nvec3 fabricTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    const float gridSize = 8.0;\n    vec2 id = floor(uv*gridSize);\n    vec2 lv = fract(uv*gridSize);\n    vec2 sv = lv*lv*(3.0-2.0*lv);\n    \n    vec3 c1 = rgb(120, 20, 7);\n    vec3 c2 = rgb(180, 53, 19);\n    vec3 c3 = rgb(45, 68, 70);\n    vec3 c4 = rgb(229, 195, 155);\n    \n    vec3 alt = fnoise(uv, 5.32156, 128.0);\n    vec3 pat = vec3(mod((id.x-id.y) + ceil(alt.x-0.36), 2.0)*fnoise(id*16., 0.3821592, 9.));\n    \n    col += c1*alt.x;\n    col += c4*alt.y;\n    col += c3*alt.z;\n    \n\n\n    vec3 ra = fnoise(uv, 3.2145, 3.0);\n    float angle = ra.x*TAU;\n    \n    float angular = max(0.0, cos(angle*1.6*atan(lv.x*2.0-1.0, lv.y*2.0-1.0)));\n    col += clamp(c3 * angular * 4., 0.0, 1.0); \n    float g = max(0.0, 1.0 - ceil(min(lv.x + ra.y*0.02, lv.y + ra.z*0.02)-(0.03*(0.5+ra.y*1.6))));\n    \n    col += (g * (ra.x+ra.y+ra.z)/3.)*c2;\n    \n    col = mix(col, pat, 0.9);\n    \n    col += pow(alt.y, 6.0);\n    \n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE leatherTexture\n\nvec3 leatherTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(105, 55, 36);\n    vec3 c2 = rgb(42, 30, 25);\n    vec3 c3 = rgb(49, 33, 24);\n    vec3 c4 = rgb(172, 118, 83);\n    \n    vec3 alt = fnoise(uv, 0.92715, 100.0);\n    vec3 pat = fnoise(uv, 3.29144, 16.0);\n    \n    col += c1 * alt.x;\n    col += c2 * alt.y;\n    col += c3 * alt.z;\n    \n    float strips = abs(pat.x - pat.y);\n    strips = smoothstep(0.04, 0.0, strips);\n\n    col += c4*strips * max(0.1, cos((alt.x+alt.y+alt.z)*TAU*2.));\n    \n    col = pow(col, vec3(1.0 / 0.5));\n    col = mix(col, vec3(0.0), 0.7*clamp(alt.x+alt.y+abs(pat.y - pat.z)*3., 0.0, 1.0));\n    \n    return col;\n}\n\nvec3 skinTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(206, 166, 143);\n    vec3 c2 = rgb(229, 194, 161);\n    vec3 c3 = rgb(185, 123, 95);\n    \n    vec3 alt = fnoise(uv, 1.2814569, 96.0);\n    \n    col += c1 * alt.x;\n    col += c2 * alt.y;\n    col += c3 * alt.z;\n    \n    vec3 c4 = rgb(230, 128, 125);\n    \n    float regions = noise21(uv, 1.927153, 8.);\n    \n    regions = pow(regions, 3.0)*2.;\n    \n    col += c4 * regions;\n    \n    col = pow(col, vec3(1.0 / 0.5));\n    \n    return col;\n}\n\nvec3 snowTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 base = fnoise(uv, 0.29381, 3.5);//noise23(uv, 0.29381, 3.5);\n    vec3 sp = fnoise(uv, 0.55541, 40.0);\n    float sparks = sp.x;//noise21(uv, 0.55541, 40.0);\n    \n    vec3 c1 = rgb(181, 185, 188);\n    vec3 c2 = vec3(1.0);\n    vec3 c3 = rgb(191, 194, 196);\n    \n    col = mix(col, c1, base.x);\n    col = mix(col, c3, base.z);\n    col = mix(col, c2, base.y);\n    col += pow(sparks, 2.0)/2.;\n    \n    m.refl = 1.0;\n    m.spec = pow(sparks, 2.0);\n    \n   // col += (luma(col)*col)/2.;\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.p.xz;//data.uv;\n    vec3 col = vec3(0.0);\n    \n    col = snowTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(snowTexture, uv, data.n, data.m, luma, 0.01, 0.6, col, 1.0, bump);\n    data.n = bump;\n    return col;\n}\n\nvec3 getAlbedoHumanEye(inout Data data) {\n    vec2 uv = data.p.xz;//data.uv;\n    vec3 col = vec3(1.);\n    //vec3 p = data.p;\n    vec3 n = pointQuat(data.n, data.o.q);\n    \n    float pupilFactor = clamp(pow(max(0.0, dot(n, pointQuat(vec3(0, 0, -1), data.o.q))), 16.0)*6., 0.0, 1.0);\n    \n    col = mix(col, vec3(0.2, 0.5, 0.3), pupilFactor);\n    \n    return col;\n}\n\nvec3 getAlbedoHumanHead(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0);\n    \n    uv = uvSphere(pointQuat(data.n, data.o.q));\n    uv *= 4.0;\n\n    col = skinTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(skinTexture, uv, data.n, data.m, luma, 0.8, 0.5, col, 1.0, bump);\n    data.n = bump;\n    \n    return col;\n}\n\n\nvec3 getAlbedoHumanTorso(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0);\n      \n    uv = uvBoxAbs(pointQuat(data.p-data.o.p, data.o.q), pointQuat(data.n, data.o.q));\n    col = fabricTexture(uv, data.m);\n    \n    \n    return col;\n}\n\nvec3 getAlbedoHumanLeg(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0);\n      \n    uv = uvBoxAbs(pointQuat(data.p - data.o.p, data.o.q), pointQuat(data.n, data.o.q));\n    col = jeansTexture(uv, data.m);\n    \n    \n    return col;\n}\n\nvec3 getAlbedoHumanArm(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0);\n    vec3 p = pointQuat(data.p-data.o.p, data.o.q);\n      \n    uv = uvBoxAbs(p, pointQuat(data.n, data.o.q));\n    \n    Material mFabric = NEW_MATERIAL;\n    vec3 fabric = fabricTexture(uv, mFabric);\n    \n    Material mSkin = NEW_MATERIAL;\n    vec3 skin = skinTexture(uv, mSkin);\n    \n    col = fabric;\n    \n    col = mix(col, skin, step(1.0-abs(p.x), 0.36));\n    \n    \n    return col;\n}\n\nvec3 getAlbedoHumanNeck(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0);\n      \n\n    col = skinTexture(uv, data.m);\n    \n    \n    return col;\n}\n\nvec3 getAlbedoHumanShoe(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0);\n      \n\n    col = leatherTexture(uv, data.m);\n    \n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_HUMAN_EYE: return getAlbedoHumanEye(data); break;\n        case ID_HUMAN_HEAD: return getAlbedoHumanHead(data); break;\n     //   case ID_HUMAN_PALM: return getAlbedoHumanPalm(data); break;\n        case ID_HUMAN_TORSO: return getAlbedoHumanTorso(data); break;\n        case ID_HUMAN_LEG: return getAlbedoHumanLeg(data); break;\n        case ID_HUMAN_ARM: return getAlbedoHumanArm(data); break;\n        case ID_HUMAN_NECK: return getAlbedoHumanNeck(data); break;\n        case ID_HUMAN_SHOE: return getAlbedoHumanShoe(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    light.c = mix(light.c, vec3(1.0), data.m.refl);\n    vec3 att = getLightAtt(light, p, n);\n    \n    float shadow = getShadow(p+(n*NEAR*2.0), L, data.d, (\n        light.type == LIGHT_AMBIENT ? FAR : distance(p, light.p)\n    ));\n    \n    \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    \n    float dotup = cdot(rd, vec3(0, 1, 0));\n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.92, 0.79, 0.67), 2.0, LIGHT_AMBIENT);\n    \n    if (march(data, ro, rd)) {\n        depth = data.d;\n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            \n            col += forEachLight(data, light, ro, rd);\n        }\n    } else {\n        col += getSky(ro, rd, lights[0]);\n    }\n    \n    float dd = depth / FAR;\n    \n    col += (smoothstep(0.1, 1.0, dd) * max(0.0, 1.0 - dotup*2.))*0.7;\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 1, -3.5);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if DEBUG_HEAD\n    ro.z = -0.6;\n    ro.y = 2.4;\n  //  rd = look(uv, HUMAN_POS + vec3(0, 0.6, 0), ro);\n    #endif\n\n   // #else\n    \n    if ((abs(m.x) > 0.0001 || abs(m.y) > 0.0001) && m.z > 0.001) {\n       \n       ro.yz *= rot(m.y*TAU);\n       ro.xz *= rot(m.x*TAU);\n\n       rd.yz *= rot(m.y*TAU);\n       rd.xz *= rot(m.x*TAU);\n    } else {\n        vec3 center = vec3(0, 1, 0);\n        Object human = getHuman();\n        vec3 lookp = center;\n        \n        float time = T*0.3;\n        float nrSteps = 7.0;\n        float frame = 1.0;\n        float transTime = 0.9;\n        vec3 orig = vec3(0, 1, -3.5);\n        vec3 pos = orig;\n        mat4 ma = quatMat(human.q);\n        \n        lookp = onCycle(lookp, human.p, time, nrSteps, transTime, frame);\n        pos = onCycle(pos, (human.p - pointMat(vec3(1.5, 0, 5.0), inverse(ma))) + vec3(1.5, 2, 0.0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, human.p + vec3(0, 0.3, 0), time, nrSteps, transTime, frame);\n        pos = onCycle(pos, (human.p - pointMat(vec3(0, 0, 0.5), inverse(ma))) + vec3(0, 0.4, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, human.p + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n        pos = onCycle(pos, (human.p - pointMat(vec3(0, 0, 0.5), inverse(ma))) + vec3(0, 0.6, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, human.p + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n        pos = onCycle(pos, (human.p - pointMat(vec3(0, 0, 0.5), inverse(ma))) + vec3(0, 0.6, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, human.p, time, nrSteps, transTime, frame);\n        pos = onCycle(pos, human.p - pointMat(vec3(0, 0, 4.0), inverse(ma)), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, human.p, time, nrSteps, transTime, frame);\n        pos = onCycle(pos, (human.p - pointMat(vec3(0, 0, 6.0), inverse(ma))) + vec3(0, 4, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, center, time, nrSteps, transTime, frame);\n        pos = onCycle(pos, orig, time, nrSteps, transTime, frame);\n\n        frame += 1.0;\n        \n        ro = pos;\n        rd = look(uv, lookp, ro);\n    }\n    \n\n    \n    ro.y = max(0.5, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec4 m = iMouse;\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    m.xy = (m.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float depth = FAR;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    #endif\n    \n    col += (col*luma(col));\n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(clamp(col, 0.0, 1.0), depth / FAR);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}