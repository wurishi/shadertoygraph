{"ver":"0.1","info":{"id":"l3XXRl","date":"1709820035","viewed":201,"name":"BlockWorld VFX","username":"Eboman","description":"Mouse x = FX amount\nMouse y = FX parameter control\nPress key 1 to 8 on keyboard = FX parameter on/off\nFX parameter descriptions in top shader comment","likes":9,"published":1,"flags":16,"usePreview":0,"tags":["vfx","block","world"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\nCONTROLS_________________:\n\nMouse x = FX amount\nMouse y = FX parameter control\nPress key 1 to 8 on keyboard = FX parameter on/off\n\nFX parameters:\n1 Light effect\n2 Move tex x 0.5\n3 Scale tex x 0.5\n4 Fog level\n5 Box length 0.2\n6 Z Glitchy rotate\n7 y Glitchy rotate\n8 Mess up RayMarch\n\n\nCREDITS__________________:\n\nBased on the Cypher shader by dila  \nhttps://www.shadertoy.com/view/MlsGRS\n\nRemixed into a video effect by:\nwww.eboman.com\n\n*/\n\n#define uMzero  (0.98-(iMouse.x/iResolution.x))\n#define uMone   (iMouse.y/iResolution.y) * kp(49) + (0.7 *(1.-kp(49))) \n#define uMtwo   ((iMouse.y/iResolution.y)*2.) * kp(50) + (1. *(1.-kp(50)))\n#define uMthree (iMouse.y/iResolution.y) * kp(51) + (0.5 *(1.-kp(51)))\n#define uMfour  (iMouse.y/iResolution.y) * kp(52) + (1. *(1.-kp(52)))\n#define uMfive  (iMouse.y/iResolution.y) * kp(53) + (0. *(1.-kp(53)))\n#define uMsix   (iMouse.y/iResolution.y) * kp(54) + (0. *(1.-kp(54)))\n#define uMseven (iMouse.y/iResolution.y) * kp(55) + (0. *(1.-kp(55)))\n#define uMeight (iMouse.y/iResolution.y) * kp(56) + (1. *(1.-kp(56)))\n\n#define PI 3.14159\n\nfloat kp(int k){\n    float kp = texelFetch( iChannel1, ivec2(k,2), 0 ).x;\n    return kp;\n}\n\nfloat expStep( float x, float k, float n ){\n    return exp( -k*pow(x,n) );\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec4 map(vec3 pos)\n{\n    float speed = 1.0;\n    vec3 grid = floor(pos);\n    vec3 gmod = mod(grid, 2.0);\n    vec3 rmod = mod(grid, 4.0) - 2.0;\n    float tm = fract(iTime * speed);\n    rmod *= (cos(tm*PI)-1.0);\n    \n    float g = floor(mod(iTime*speed,3.0));\n    if (g==2.0){\n        if (gmod.y*gmod.x==1.0) {\n            pos.z += rmod.y*rmod.x*0.5;\n        }\n    } else if (g==0.0){\n        if (gmod.y*gmod.z==1.0) {\n            pos.x += rmod.y*rmod.z*0.5;\n        }\n    } else if (g==1.0){\n        if (gmod.z*gmod.x==1.0) {\n            pos.y += rmod.z*rmod.x*0.5;\n        }\n    }\n        \n    grid = floor(pos);\n    pos = pos - grid;\n    pos = pos * 2.0 - 1.0;\n\n    pos.xy *= Rot(PI*(uMsix*uMzero));\n    pos.xz *= Rot(PI*(uMseven*uMzero));\n\n    float len = 0.9;\n\n    float d = sdBox(pos,vec3(len)*((1.-uMfive)));\n\n    bool skip = false;\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.y,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.z,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.y,2.0)==0.0 && mod(grid.z,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (skip) {\n        d = 100.0;\n        vec3 off = vec3(2.0,0.0,0.0);\n        for (int i = 0; i < 3; ++i) {\n            float a = sdBox(pos + off,vec3(len));\n            float b = sdBox(pos - off,vec3(len));\n            d = min(d,min(a,b));\n            off = off.zxy;\n        }\n        d *= 0.5*(uMeight*(1.-kp(56)));\n    } else {\n        d *= 0.8 ;   \n    }\n    \n    vec2 uv = vec2(atan(pos.x, pos.z)/6.2832, pos.y/3.)+.5;\n    float disp = texture(iChannel0, uv).r;\n    disp *= smoothstep(1.4, 1., abs(pos.y));\n    \n    d -= disp*0.;\n    \n    return vec4(pos, d);\n}\n\nvec3 surfaceNormal(vec3 pos) {\n    vec3 delta = vec3(0.001*uMzero, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz).w - map(pos - delta.xyz).w;\n    normal.y = map(pos + delta.yxz).w - map(pos - delta.yxz).w;\n    normal.z = map(pos + delta.zyx).w - map(pos - delta.zyx).w;\n    return normalize(normal);\n}\n\nfloat aoc(vec3 origin, vec3 ray)\n{\n    float delta = 0.05;\n    const int samples = 8;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n        vec3 pos = origin + ray * t;\n        float dist = map(pos).w;\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float mx = iMouse.x/iResolution.x;\n    float my = pow(iMouse.y/iResolution.y, 0.5);\n    \n    vec3 posse = vec3 (0.);\n\n    vec3 eye = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n    vec3 origin = vec3(0.0);\n    \n    eye = eye * yrot(iTime) * xrot(iTime);                       //<----\n    \n    float speed = 0.5;\n    \n    float j = iTime * speed;                                     //<----\n    \n    float f = fract(j);\n    float g = 1.0 - f;\n    f = f*f * g + (1.0-g*g) * f;\n    f = f * 2.0 - 1.0;\n    float a = floor(j) + f * floor(mod(j,2.0));\n    float b = floor(j) + f * floor(mod(j+1.0,2.0));\n    \n    origin.x += 0.5 + a;\n    origin.y += 0.5;\n    origin.z += -0.5 + b;\n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    for (int i = 0; i < 32; ++i){\n        vec3 pos = origin + eye * t;\n        d = map(pos).w;\n        t += d;\n        posse = map(pos).xyz;\n    }\n    \n    vec3 worldPos = origin + eye * t;\n\n    float aspect = iResolution.x/iResolution.y; \n    posse.x /= 1.+((pow(uMthree, 3.)*30.)-0.95)*kp(51);\n    vec3 posse2 = posse*(0.5*(2.*mix(0.5, 0.5, uMzero)+0.01))+(0.5*(uMtwo+0.01));\n\n    uv*=vec2(iResolution.y / iResolution.x, 1)*0.5;\n    vec4 videoXZ=texture(iChannel0, mix(uv+0.5, fract(posse2.xz), uMzero));\n    vec4 videoYZ=texture(iChannel0, mix(uv+0.5, fract(posse2.yz), uMzero));\n    vec4 videoXY=texture(iChannel0, mix(uv+0.5, fract(posse2.xy), uMzero));\n    vec4 videoclean=texture(iChannel0, uv+0.5);\n\n    vec3 norm = surfaceNormal(posse2);\n    vec3 n = abs(norm);\n    vec4 video = videoYZ*n.x + videoXZ*n.y + videoXY*n.z;\n\n    \n    float amb = 0.0;\n    float shade = pow(max(1.0 - amb, 0.0), 4.0); \n    float fog = 1.0 / (1.0 + t * t * 0.2) * shade;  \n    fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 finalwithfog = video.rgb * fog/mix(1., fog, pow(1.-uMzero, 0.25));\n    vec3 videowithfogmix = vec3(mix(video.rgb, finalwithfog, uMfour));\n    vec3 finalwithcleanbeginning = mix(videoclean.rgb, videowithfogmix,max((1.-expStep((uMzero),30.,1.)), 0.));\n    \n    vec3 fcolif = finalwithcleanbeginning / pow(abs(mix(1.,posse.z, sin(iTime*1.6)*(1.*(10.*((1.-(uMone*1.))*uMzero)*(sin(iTime)))))),max(0.4, floor(1.-(0.3)))* 1.+(pow(0.3, 2.)/5.)) +0.05 ;\n\n    // Interface\n   \n    vec2 uvif = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uvif -= 0.5; \n    uvif /= vec2(iResolution.y / iResolution.x, 1);\n    \n    //vec3 fcolif = finalwithcleanbeginning;\n    \n    fcolif = mix( fcolif, vec3(0.,1.,1.), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.45))*15.))*(1.-mx) );\n    fcolif = mix( fcolif, vec3(0.,1.,1.), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.45))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.38))*15.))*kp(49)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(49)+0.5,1.0*(kp(49)*-1.5)+0.5,1.0*(kp(49)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.38))*15.-0.3))));\n\n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.31))*15.))*kp(50)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(50)+0.5,1.0*(kp(50)*-1.5)+0.5,1.0*(kp(50)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.31))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.24))*15.))*kp(51)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(51)+0.5,1.0*(kp(51)*-1.5)+0.5,1.0*(kp(51)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.24))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.17))*15.))*kp(52)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(52)+0.5,1.0*(kp(52)*-1.5)+0.5,1.0*(kp(52)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.17))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.10))*15.))*kp(53)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(53)+0.5,1.0*(kp(53)*-1.5)+0.5,1.0*(kp(53)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.10))*15.-0.3))));\n\n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,0.03))*15.))*kp(54)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(54)+0.5,1.0*(kp(54)*-1.5)+0.5,1.0*(kp(54)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,0.03))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,-0.04))*15.))*kp(55)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(55)+0.5,1.0*(kp(55)*-1.5)+0.5,1.0*(kp(55)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,-0.04))*15.-0.3))));\n        \n    fcolif = mix( fcolif, vec3(1.0*my,0.0,0.0), \n        (1.-smoothstep(0.3,0.31,length(uvif-vec2(-0.84,-0.11))*15.))*kp(56)*my );\n    fcolif = mix( fcolif, vec3(1.0*kp(56)+0.5,1.0*(kp(56)*-1.5)+0.5,1.0*(kp(56)*-1.5)+0.5), \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-vec2(-0.84,-0.11))*15.-0.3))));\n    \n    // Final output\n\n    fragColor = vec4(fcolif, 1.);\n\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}