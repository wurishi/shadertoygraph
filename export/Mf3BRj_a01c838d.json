{"ver":"0.1","info":{"id":"Mf3BRj","date":"1733258881","viewed":85,"name":"Ammann-Beenker - another calc2","username":"Elsio","description":"\"All I've done is rearrange things a little and utilize it.\"\n\nEsta versão foi baseada no shader do @knighty em 2018\nhttps://www.shadertoy.com/view/MddfzH \n\nMeu primeiro shader sobre o assunto está em\nhttps://www.shadertoy.com/view/lftfDM\n\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","quasicrystal","pattern","tesselation","cutandproject","prototiles"],"hasliked":0,"parentid":"lfdfzB","parentname":"Ammann-Beenker - 340ch"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define a vec4(cos(pi / 4.), .5, 0, -.5)\n//#define b vec4(0, .5, cos(pi / 4.), .5)\n//#define pi acos(-1.)\n\n// fabrice sugestions\n#define e vec4(1./sqrt(2.), .5, -.5, 0)\n#define T mat4x2(e.xwyy, e.wxzy)\n\nfloat sq(vec2 p){\n    p = abs(p) - .5;\n    return max(p.x, p.y);\n}\n\nfloat section(vec2 u, vec2 h, vec2 s) {\n    int i = int(h.x); \n    int j = int(h.y); \n    \n    //mat2 m = inverse(mat2(a[i], b[i], a[j], b[j]));\n    mat2 m = inverse(mat2(T[i], T[j]));\n    \n    //vec4 p4 = 2. * (u.x * a + u.y * b),\n    vec4 p4 = 2. * u * T,\n         id = round(p4);\n    \n    vec2 p = (vec2(id[i], id[j]) - s + .5) * m;\n    \n            //vec4 q = round(p.x * a + p.y * b), \n            vec4 q = round(p * T), \n                 ofs = p4 - q;\n\n            ofs[i] += q[i] - id[i] + s.x;\n            ofs[j] += q[j] - id[j] + s.y;\n        \n    //p = m * vec2(dot(ofs, a), dot(ofs, b)) - .5;\n    p = m * T * ofs - .5;\n    \n    return sq(p);\n}\n\n\nfloat comb(vec2 u, vec2 h){\n    vec2 s = vec2(0, 1);\n    \n    float \n    d =        section(u, h, s.xx);\n    d = min(d, section(u, h, s.xy));\n    d = min(d, section(u, h, s.yx));\n    d = min(d, section(u, h, s.yy));\n    \n    return d;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy; o *= 0.;    \n    u = 3. * (u + u - r) / r.y + iTime;\n    vec4 h = vec4(0, 1, 2, 3);\n\n    float \n        d =        comb(u, h.xy);\n        d = min(d, comb(u, h.xw));\n        d = min(d, comb(u, h.yz));\n        d = min(d, comb(u, h.zw));\n        //d = min(d, comb(u, h.xz));\n        //d = min(d, comb(u, h.yw));\n\n    o += smoothstep(14. / r.y, 0., d + .08);\n}\n\n\n\n\n\n/*\n#define pi acos(-1.)\n#define a vec4(cos(pi / 4.), .5, 0, -.5)\n#define b vec4(0, .5, cos(pi / 4.), .5)\n\nfloat sq(vec2 p){\n    p = abs(p) - .5;\n    return max(p.x, p.y);\n}\n\nfloat section(vec2 u, vec2 h, vec2 s) {\n    int i = int(h.x); \n    int j = int(h.y); \n    \n    mat2 m = inverse(mat2(a[i], b[i], a[j], b[j]));\n    \n    vec4 p4 = 2. * (u.x * a + u.y * b),\n         id = round(p4);\n    \n    vec2 p = (vec2(id[i], id[j]) - s + .5) * m;\n    \n            vec4 q = round(p.x * a + p.y * b), \n                 ofs = p4 - q;\n\n            ofs[i] += q[i] - id[i] + s.x;\n            ofs[j] += q[j] - id[j] + s.y;\n        \n    p = m * vec2(dot(ofs, a), dot(ofs, b)) - .5;\n    \n    return sq(p);\n}\n\n\nfloat comb(vec2 u, vec2 h){\n    vec2 s = vec2(0, 1);\n    \n    float \n    d =        section(u, h, s.xx);\n    d = min(d, section(u, h, s.xy));\n    d = min(d, section(u, h, s.yx));\n    d = min(d, section(u, h, s.yy));\n    \n    return d;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy; o *= 0.;    \n    u = 3. * (u + u - r) / r.y + iTime;\n    vec4 h = vec4(0, 1, 2, 3);\n\n    float \n        d =        comb(u, h.xy);\n        d = min(d, comb(u, h.xw));\n        d = min(d, comb(u, h.yz));\n        d = min(d, comb(u, h.zw));\n        //d = min(d, comb(u, h.xz));\n        //d = min(d, comb(u, h.yw));\n\n    o += smoothstep(14. / r.y, 0., d + .08);\n}\n*/","name":"Image","description":"","type":"image"}]}