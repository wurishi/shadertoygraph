{"ver":"0.1","info":{"id":"3tf3Df","date":"1557824462","viewed":127,"name":"Plane symmetry","username":"madware","description":"Simple example of symmetrical reflection matrix","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","reflection","plane","matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h(n) fract(sin(n)*753.5453)\n\nconst vec3 gray  = vec3(0.5, 0.5, 0.5);\nconst vec3 black = vec3(0.0, 0.0, 0.0);\nconst vec3 white = vec3(1.0, 1.0, 1.0);\nconst vec3 cyan  = vec3(0.0, 1.0, 1.0);\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3. - 2. * f);\n\t\n    float n = p.x + p.y*157. + 113.;\n    return mix(mix( h(n+ 0.), h(n+ 1.),f.x),\n               mix( h(n+63.), h(n+64.),f.x),f.y);\n}\n\n// simple dot plotter\nfloat circle_test(in vec2 uv, in vec2 p, in float rad)\n{\n    vec2 puv = uv - p;;\n    return smoothstep( rad + .000001, rad - 0.000001, dot(puv, puv));\n}\n\n// reflects point p symmetrically around a\n// plane defined with a point p0 and normal n \nmat2x3 get_symmetrical_transform(in vec2 p0, in vec2 n)\n{\n    // p' = p - 2.0 * n * dot(n, p - p0)\n    //\n    // Expands to \n    //\n    // p'.x = p.x * (-1.0 + 2.0 * n.y * n.y) +\n    //        p.y * (-2.0 * n.x * n.y) +\n    //        1.0 * n.x * dot(n, p0) * 2.0\n    //\n    // p'.y = p.x * (-2.0 * n.x * n.y) +\n    //        p.y * (1.0 - 2.0 * n.y * n.y) +\n    //        1.0 * n.y * dot(n, p0) * 2.0\n    //\n    // which nicely maps to 2x3 matrix\n    \n    vec2 o_offs = n * dot(n, p0) * 2.0;\n    float k1 = dot(n, vec2(n.x, -n.y)); // originally 1.0 - 2.0 * n.y * n.y.\n    float k2 = -dot(n, n.yx);           // originally -2.0 * n.x * n.y\n    \n    return mat2x3\n    (\n        -k1,  k2, o_offs.x,\n         k2,  k1, o_offs.y\n    );\n}\n\n// reflects point p symmetrically around a\n// plane defined with a point p0 and normal n \nmat2x3 get_symmetrical_transform2(in vec2 p0, in vec2 n)\n{\n    vec4 k = vec4\n    (\n        0.5 - (n.y * n.y),\n        -(n.x * n.y),\n        n * dot(n, p0)\n    ) * 2.0;\n    \n    return mat2x3\n    (\n        -k.x, k.yz,\n         k.yxw\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get coords scaled to be in range of [0..1]\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    //preparing point and normal of a plane\n    vec2 pPlane = iMouse.xy / iResolution.xy;\n    pPlane.y *= iResolution.y / iResolution.x;  \n    float a = iTime;\n    vec2 dir = vec2(cos(a), sin(a));       \n    \n    //draw gray background \n    vec3 col = gray;\n    float uvPlaneProj = dot(dir, uv - pPlane);       \n    float planeDist = abs(uvPlaneProj);\n    col = mix(col, cyan, smoothstep(.0025, 0.0015, planeDist) * .5);\n    \n    //prepare a symmetrical reflection matrix\n    mat2x3 mtx = get_symmetrical_transform(pPlane, dir);\n    \n    //draw black dots along with their white reflections\n    for(float i = -0.8; i < 0.8; i += 0.2)\n    {\n        for(float j = -0.8; j < 0.8; j += 0.2)\n        {\n            vec2 p = vec2(i, j);\n            vec2 disturbed = (p + vec2(noise(p), noise(p.yx))) / 2.0 + vec2(.25, .125);\n            vec2 reflected = vec3(disturbed, 1.0) * mtx;\n                        \n            col = mix(col, black, circle_test(uv, disturbed, 0.00002));            \n            col = mix(col, white, circle_test(uv, reflected, 0.00002));\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}