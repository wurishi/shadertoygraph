{"ver":"0.1","info":{"id":"4c2fzh","date":"1724649181","viewed":17,"name":"practiceee2","username":"changjin2211","description":"prac2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 2D 회전 행렬 생성 함수\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// 거리 추정 함수 (SDF)\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// 패턴 생성 함수\nfloat pattern(vec3 p) {\n    p.xy *= rot(iTime * 0.3);\n    p.yz *= rot(iTime * 0.2);\n    \n    float d = sdSphere(p, 1.0);\n    \n    for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n        p = abs(p) - vec3(0.8 + sin(time * 0.7) * 0.2);\n        p.xy *= rot(time * 0.3 + fi);\n        p.yz *= rot(time * 0.3 + fi);\n        \n        d = min(d, sdBox(p, vec3(0.2)));\n    }\n    \n    return d;\n}\n\n// 레이마칭 함수\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = pattern(p);\n        if (d < 0.001 || t > 20.0) break;\n        t += d;\n    }\n    return t;\n}\n\n// 법선 계산 함수\nvec3 calcNormal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * pattern(p + k.xyy * h) +\n                     k.yyx * pattern(p + k.yyx * h) +\n                     k.yxy * pattern(p + k.yxy * h) +\n                     k.xxx * pattern(p + k.xxx * h));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    float t = raymarch(ro, rd);\n    vec3 p = ro + rd * t;\n    vec3 n = calcNormal(p);\n    \n    vec3 col = vec3(0);\n    if (t < 20.0) {\n        vec3 light = normalize(vec3(1, 1, -1));\n        float diff = max(dot(n, light), 0.0);\n        float spec = pow(max(dot(reflect(-light, n), -rd), 0.0), 32.0);\n        col = vec3(1, 0.8, 0.6) * diff + vec3(0.8, 0.9, 1.0) * spec;\n    }\n    \n    // 감마 보정\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}