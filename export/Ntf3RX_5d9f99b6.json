{"ver":"0.1","info":{"id":"Ntf3RX","date":"1622477119","viewed":199,"name":"Volumetric tetrahedron","username":"stduhpf","description":"I'm trying to implement delaunay tetrahedrisation, and i needed to find the bounding sphere of a tetrahedron and a simple test to know if a point is inside the tetrhedron, so i made this to check if my functions are correct.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["geometry","volumetrics","tertahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 intersectSphere(vec3 ro, vec3 rd, vec3 c,float r){\n    vec3 origin = ro-c;\n    float demi_b = dot(rd,origin);\n    float moins_c = r*r-dot(origin,origin);\n    float quart_delta = demi_b*demi_b+moins_c;\n    return (moins_c>=0. || demi_b<=0. && quart_delta>=0.)?-demi_b+vec2(-1,1)*sqrt(quart_delta):vec2(1e6);\n}\n\nvec4 sphereNormal(vec3 ro, vec3 rd, vec3 c,float r){\n    float d = intersectSphere(ro,rd,c,r).x;\n    return vec4(normalize(ro+d*rd-c),d);\n}\n\nvec3 toSphere(vec2 a) {\n    const float TAU = 2.*acos(-1.);\n    a *= vec2(TAU, TAU * .5);\n    return vec3(cos(a.x) * sin(a.y), sin(a.x) * sin(a.y), cos(a.y));\n}\n\nvec3 toBall(vec3 a) {\n    vec3 sphere = toSphere(a.xy);\n    return sphere * pow(a.z,1./3.);\n}\n\nvec3 hash32(vec2 p){\n    p.x+=floor(iTime);\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\n\nvec4 getSphere(mat4x3 tertahedron){\n    vec3 o = tertahedron[3];\n    mat3 M = mat3(tertahedron)-mat3(o,o,o);\n    mat3 iM = inverse(M);\n    // the center g of the bounding sphere is the intersection point of all the perpendicular bisectors (planes in the 3D case) of each edge.\n    // we only need 3 edges to find the center, so we can use all the edges that have the origin \"o\" as vertex\n    // the perpendicular bisector of the edge [o, M[i,:]] is othogonal to (M[i,:]-o) and pass by (M[i,:]+o)/2    \n    // so whe have (g-.(M[i,:]+o)/2).(M[i,:]-o) = 0\n    // by having the origin to the point o, we can simplify:\n    // (g-.M[i,:]/2).M[i,:] = 0 \n    // <=> g.M[i,:] - M[i,:].M[i,:]/2=0\n    // <=> g.M[i,:] = M[i,:].M[i,:]/2\n    // <=> g*M = vec3(M[0,:].M[0,:]/2, M[1,:].M[1,:]/2, M[2,:].M[2,:]/2) = k\n    // <=> g = k*(1/M)\n    \n    vec3 k = vec3(dot(M[0],M[0]),dot(M[1],M[1]),dot(M[2],M[2]))*.5;\n    vec3 g = k*iM;\n    \n    return vec4(g+o,length(g));\n}\n\nbool contains(mat4x3 tertahedron,vec3 p){\n    //get coordinates of p in the base induced by the tetrahedron, to quickly check if it's inside\n    vec3 o = tertahedron[3];\n    mat3 M = mat3(tertahedron)-mat3(o,o,o);\n    mat3 iM = inverse(M);\n    vec3 c = iM*(p-o);\n    return c == abs(c) && dot(c,vec3(1))<=1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 mse =(iMouse.xy-.5*iResolution.x)/360.;\n    if(iMouse.xy==vec2(0))\n        mse*=0.;\n    mat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\n    mat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n    mat3 rot = rdroty*rdrotx;\n    \n    vec3 ro = vec3(0,0,-2)*rot;\n    vec3 projPos = (vec3(2.*fragCoord-iResolution.xy,iResolution.y*1.5)+ro)*rot;\n    \n    vec3 rd = normalize(projPos-ro);\n    \n    vec3 p1 = toBall(hash32(vec2(1)))*.5;\n    vec3 p2 = toBall(hash32(vec2(2)))*.5;\n    vec3 p3 = toBall(hash32(vec2(3)))*.5;\n    vec3 p4 = toBall(hash32(vec2(4)))*.5;\n    \n    mat4x3 points = mat4x3(p1,p2,p3,p4);\n    \n    vec3 lightDir = normalize(vec3(.5,1,-1));\n    vec3 lightCol = vec3(1.,.95,.9)*.75;\n    vec3 ambiant = vec3(.1,.11,.15);\n    \n    \n    fragColor = vec4(texture(iChannel0,rd).rgb*.1,1e6);\n    for(int i=0;i<4;i++){\n        vec4 n = sphereNormal(ro,rd,points[i],.02);\n        fragColor=n.a<fragColor.a?vec4(max(0.,dot(n.rgb,lightDir))*lightCol+ambiant,n.a):fragColor;\n    }\n    \n    vec4 sph = getSphere(points);\n    vec2 i = intersectSphere(ro,rd,sph.xyz,sph.a);\n    if(i.y<fragColor.a)\n        fragColor.rgb = mix(fragColor.rgb,vec3(.02,.025,.1),.3);\n    i.y = min(i.y,fragColor.a);\n    bool surf = i.x<fragColor.a;\n    i.x = min(i.x,fragColor.a);\n    //fragColor.rgb = mix(ambiant*3.,fragColor.rgb,exp2(1.3*min(0.,i.x-i.y)));\n    const int steps = 128;\n    if(i.y>i.x){\n        float s =(i.x-i.y)/float(steps+1);\n        vec3 p = ro+(i.y + s*texture(iChannel1,fragCoord/iChannelResolution[1].xy)[iFrame%4])*rd;\n\n\n        for(int j =0;j<steps;j++){\n            bool inside = contains(points,p);\n            fragColor.rgb = mix(inside?vec3(0,1,0):vec3(.1,0,0),fragColor.rgb,exp2(s));\n            p+=s*rd;\n        }\n    }\n    if(surf)\n        fragColor.rgb = mix(fragColor.rgb,vec3(.02,.025,.1),.3);\n\n    fragColor = sqrt(fragColor);\n}","name":"Image","description":"","type":"image"}]}