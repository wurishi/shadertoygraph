{"ver":"0.1","info":{"id":"Xff3R4","date":"1702796581","viewed":72,"name":"Toon Rim Light Comparison","username":"SL0ANE","description":"通常非后处理做边缘光的话会算法线和视角方向的点乘（左），\n但是这通常只能在球面上会有比较好的效果，尝试做了额外的march把边缘光限制在看上去的边缘。\n不过还是会有看上去不理想的情况。","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","cartoon","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define MAX_DISTANCE 1024.0\n# define MIN_STEP 64\n# define MAX_STEP 256\n# define MAX_RIM_STEP 32\n# define BACKGROUND_COLOR vec4(0.81, 0.68, 0.76, 1.0)\n# define ADVANCED_COLOR vec4(0.68, 0.81, 0.76, 1.0)\n# define SLOANE_COLOR vec4(0.98, 0.52, 0.52, 1.0)\n\n# define LIGHT_DIRECTION vec3(-2.0, -4.0, 3.0)\n# define LIGHT_COLOR vec4(1.0, 0.98, 0.94, 1.0)\n# define LIGHT_THRESHOLD 0.28\n# define LIGHT_THICKNESS 0.36\n# define LIGHT_STRENGTH 1.0\n# define RIMLIGHT_STRENGTH 0.25\n# define LIGHT_SPREAD 1.2\n# define SHADOW_COLOR vec4(0.8, 0.60, 0.82, 1.0)\n# define DIFFUSE_STEP 16.0\n# define SPECULAR_STEP 2.0\n\n# define ELLI_SHAPE vec3(0.8, 0.24, 0.8)\n# define CUBE_SHAPE vec3(0.48, 0.48, 0.48)\n# define SPHE_SHAPE 0.6\n\n# define OUTLINE_STRENGTH 0.06\n# define OUTLINE_THRESHOLD 1.0\n# define OUTLINE_COLOR vec4(64.0, 32.0, 32.0, 255.0) / 255.0\n\n// Pre\nfloat sceneMap(vec3 point);\nvec4 quaternionMul(vec4 left, vec4 right);\n\n// Camera Config\nfloat cameraFov = 60.0f;\n\n// Bone\n\nvec3 positionLocal_Root = vec3(0.0, 0.0, 8.0);\nvec4 rotationLocal_Root = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Root;\nvec4 rotationWorld_Root;\n\n\n// Util\nvec3 getNormal(vec3 point)\n{\n    vec3 deltaX = vec3(TOLERANCE, 0.0, 0.0);\n    vec3 deltaY = vec3(0.0, TOLERANCE, 0.0);\n    vec3 deltaZ = vec3(0.0, 0.0, TOLERANCE);\n    \n    float x = sceneMap(point + deltaX) - sceneMap(point - deltaX);\n    float y = sceneMap(point + deltaY) - sceneMap(point - deltaY);\n    float z = sceneMap(point + deltaZ) - sceneMap(point - deltaZ);\n    \n    return normalize(vec3(x, y, z));\n}\n\nvec3 getRoughNormal(vec3 point, float curDis)\n{\n    vec3 deltaX = vec3(TOLERANCE, 0.0, 0.0);\n    vec3 deltaY = vec3(0.0, TOLERANCE, 0.0);\n    vec3 deltaZ = vec3(0.0, 0.0, TOLERANCE);\n    \n    float x = sceneMap(point + deltaX) - curDis;\n    float y = sceneMap(point + deltaY) - curDis;\n    float z = sceneMap(point + deltaZ) - curDis;\n    \n    return normalize(vec3(x, y, z));\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for(float t = mint; t < maxt;)\n    {\n        float h = sceneMap(ro + rd * t);\n        if(h < TOLERANCE)\n            return 0.0;\n        res = min(res, k * h/t);\n        t += h;\n    }\n    return res;\n}\n\n// Shape\nfloat sdSphere(vec3 p, vec3 sdf_pos, float sdf_rad)\n{\n    return distance(p, sdf_pos) - sdf_rad;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 sdf_pos, vec4 sdf_rot, vec3 sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(sdf_rot));\n    float k0 = length(transPoint / sdf_rad);\n    float k1 = length(transPoint / (sdf_rad * sdf_rad));\n    return k0 * (k0-1.0) / k1;\n}\n\nfloat sdBox(vec3 p, vec3 sdf_pos, vec4 sdf_rot, vec3 sdf_bound)\n{\n    vec3 transPoint = p - sdf_pos;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(sdf_rot));\n    \n    vec3 q = abs(transPoint) - sdf_bound;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule(vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad)\n{\n    vec3 pa = p - sdf_pos_0, ba = sdf_pos_1 - sdf_pos_0;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length( pa - ba*h ) - sdf_rad;\n}\n\n// Project\n\nfloat sceneMap(vec3 point)\n{\n    float distance = 0.0;\n    distance = min(min(\n               sdEllipsoid(point, positionWorld_Root + vec3(0.0, 1.5, 0.0), rotationWorld_Root, ELLI_SHAPE),\n               sdBox(point, positionWorld_Root + vec3(0.0, 0.0, 0.0), rotationWorld_Root, CUBE_SHAPE)),\n               sdSphere(point, positionWorld_Root + vec3(0.0, -1.5, 0.0), SPHE_SHAPE));\n    return distance;\n}\n\nfloat sceneMap(vec3 point, float offset)\n{\n    return sceneMap(point) + offset;\n}\n\nvoid march(vec3 start, vec3 ray, inout vec3 pos, inout vec3 normal, inout float len, inout int outline)\n{\n    len = 0.0;\n    outline = 0;\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    int hit = 0;\n    float lenWhenHit;\n    float disWhenHit;\n    int stepCount = 0;\n    \n    while(len < MAX_DISTANCE && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        \n        dis = sceneMap(curPos);\n        pos = curPos;\n        \n        if(dis <= TOLERANCE)\n        {\n            normal = getNormal(curPos);\n            if(hit == 2)\n            {\n                if(mix(0.0, TOLERANCE + OUTLINE_STRENGTH, clamp((len - lenWhenHit) / OUTLINE_THRESHOLD, 0.0, 1.0)) >= disWhenHit) outline = 1;\n            }\n            else if(hit == 1)\n            {\n                // if(disWhenHit <= dis + OUTLINE_STRENGTH) outline = 1;\n            }\n            return;\n        }\n        \n        if(hit == 0)\n        {\n            // 第一次到范围内\n            if(dis <= TOLERANCE + OUTLINE_STRENGTH) hit = 1;\n            lenWhenHit = len;\n            disWhenHit = dis;\n        }\n        else if(hit == 1)\n        {\n            if(dis <= TOLERANCE + OUTLINE_STRENGTH)\n            {\n                // 持续在描边范围内，记录最小距离\n                if(disWhenHit > dis)\n                {\n                    disWhenHit = dis;\n                    lenWhenHit = len;\n                }\n            }\n            else hit = 2;\n        }\n        \n        len += dis;\n        stepCount += 1;\n    }\n    normal = getRoughNormal(curPos, dis);\n    if(hit == 2)\n    {\n        if(mix(0.0, TOLERANCE + OUTLINE_STRENGTH, clamp((len - lenWhenHit) / OUTLINE_THRESHOLD, 0.0, 1.0)) >= disWhenHit) outline = 1;\n    }\n    return;\n}\n\nvoid marchForRim(vec3 start, vec3 ray, float offset, inout float minDis)\n{\n    float len = 0.0;\n    float dis = 0.0;\n    minDis = offset;\n    vec3 curPos = vec3(0.0);\n\n    int stepCount = 0;\n    \n    while(len < MAX_DISTANCE && stepCount <= MAX_RIM_STEP)\n    {\n        curPos = len * ray + start;\n        \n        dis = sceneMap(curPos, offset);\n        \n        if(dis < minDis)\n        {\n            minDis = dis;\n        }\n        \n        if(dis <= TOLERANCE)\n        {\n            minDis = -0.0; // 表示经过了偏移后的范围，不作为轮廓光处理\n            return;\n        }\n        else if(dis >= offset + 2.0 * TOLERANCE) return;\n        \n        len += dis / 8.0;\n        stepCount += 1;\n    }\n    return;\n}\n\nvoid sceneBaseMaterial(vec3 point, out vec4 baseColor, out int materialIndex)\n{\n    baseColor = SLOANE_COLOR;\n    materialIndex = 0;\n    return;\n}\n\nvoid updateBone()\n{\n    float angle;\n    \n    // 根\n    positionWorld_Root = positionLocal_Root;\n    rotationLocal_Root = vec4(0.271, 0.216, 0.043, 0.937);\n    rotationLocal_Root = quaternionMul(load(POINTER_ROT), rotationLocal_Root);\n    rotationWorld_Root = rotationLocal_Root;\n    positionWorld_Root = positionLocal_Root;\n}\n\nfloat getRimLightPower(vec3 lightDir, float rimSpread, float rimThreshold, vec3 normal, vec3 view)\n{\n    // 这部分决定强度\n    float power = dot(normalize(-normal - dot(-normal, view) * view), normalize(lightDir - dot(lightDir, view) * view));\n    power = clamp(1.0 - 1.0 / (power + rimSpread), 0.0, 1.0);\n    \n    // 这部分决定形状\n    power *= (1.0 - abs(dot(view, normal))) / rimThreshold - 1.0;\n    power = clamp(power, 0.0, 1.0 - TOLERANCE);\n    \n    return power;\n}\n\nfloat getRimLightPowerAdvanced(vec3 lightDir, float rimSpread, float rimThreshold, float rimThickness, vec3 pos, vec3 normal, vec3 view)\n{\n    // 这部分决定形状\n    float dis;\n    marchForRim(pos, view, rimThickness, dis);\n    float power = dis / rimThickness;\n    \n    // 这部分决定强度\n    power *= getRimLightPower(lightDir, rimSpread, rimThreshold, normal, view);\n    power = clamp(power, 0.0, 1.0 - TOLERANCE);\n    \n    return power;\n}\n\nvec4 mainLightShading(vec3 lightDir, float rimSpread, float rimThreshold, float strength, vec4 lightColor, vec4 shadowColor, float diffuseStep, float specularStep, vec4 baseColor, int material, vec3 pos, vec3 normal, vec3 view)\n{\n    float smoothness = 0.0;\n    float expSmoothness = pow(2.7, 5.0 * smoothness + 1.0);\n    \n    float shodow = 1.0;\n    float lightLevel = min(clamp(dot(-normal, lightDir), 0.0, 1.0), shodow);\n    \n    vec4 diffuse = baseColor * mix(shadowColor, lightColor, multiStep(lightLevel, diffuseStep, 0.0, 0.5)) * strength;\n    \n    float split = pow(1.0 - smoothness, 3.0) / 2.0;\n    float scale = pow(smoothness, 0.4);\n    \n    float res_0 = dot(normalize(mix(lightDir, view, 0.5 - split)), -normal);\n    float res_1 = dot(normalize(mix(lightDir, view, 0.5 + split)), -normal);\n    lightLevel = max(pow(clamp(res_0, 0.0, 1.0), expSmoothness), pow(clamp(res_1, 0.0, 1.0), expSmoothness) * scale);\n    \n    vec4 specular = lightColor * multiStep(lightLevel, specularStep, 0.0, 0.0) * shodow * pow(smoothness, 1.2) * strength;\n    \n    return diffuse + specular;\n}\n\nvec4 rimLightShading(vec3 lightDir, float rimSpread, float rimThreshold, float strength, vec4 lightColor, float lightStep, vec4 baseColor, int material, vec3 pos, vec3 normal, vec3 view)\n{\n    float power = getRimLightPower(lightDir, rimSpread, rimThreshold, normal, view);\n    \n    power = multiStep(power, lightStep, 0.0, 0.0);\n    \n    return vec4(mix(baseColor.rgb, baseColor.rgb + power * lightColor.rbg, strength), baseColor.a);\n}\n\nvec4 rimLightShadingAdvanced(vec3 lightDir, float rimSpread, float rimThreshold, float rimThickness, float strength, vec4 lightColor, float lightStep, vec4 baseColor, int material, vec3 pos, vec3 normal, vec3 view)\n{\n    float power = getRimLightPowerAdvanced(lightDir, rimSpread, rimThreshold, rimThickness, pos, normal, view);\n    \n    power = multiStep(power, lightStep, 0.0, 0.0);\n    \n    return vec4(mix(baseColor.rgb, baseColor.rgb + power * lightColor.rbg, strength), baseColor.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    updateBone();\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    float delta = 1.0 / iResolution.x;\n    float tanFov = tan(cameraFov / 360.0 * PI);\n    vec3 ray;\n    \n    // 开两个窗口\n    if(uv.x < 0.0) ray = normalize(vec3(uv + vec2(0.25, 0.0), 0.5 / tanFov));\n    else ray = normalize(vec3(uv - vec2(0.25, 0.0), 0.5 / tanFov));\n    \n    vec3 pos;\n    vec3 normal;\n    float len;\n    int outline;\n    \n    \n    march(vec3(0.0), ray, pos, normal, len, outline);\n    \n    if(outline > 0)\n    {\n        fragColor = OUTLINE_COLOR;\n        return;\n    }\n    else if(len >= MAX_DISTANCE)\n    {\n        if(uv.x < 0.0) fragColor = BACKGROUND_COLOR;\n        else fragColor = ADVANCED_COLOR;\n        return;\n    }\n    \n    \n    vec4 baseColor;\n    int mIndex;\n    sceneBaseMaterial(pos, baseColor, mIndex);\n    \n    vec4 outputColor = mainLightShading(normalize(LIGHT_DIRECTION), LIGHT_SPREAD, LIGHT_THRESHOLD, LIGHT_STRENGTH, LIGHT_COLOR, SHADOW_COLOR, DIFFUSE_STEP, SPECULAR_STEP, baseColor, mIndex, pos, normal, ray);\n    if(uv.x < 0.0) outputColor = rimLightShading(normalize(LIGHT_DIRECTION), LIGHT_SPREAD, LIGHT_THRESHOLD, RIMLIGHT_STRENGTH, LIGHT_COLOR, SPECULAR_STEP, outputColor, mIndex, pos, normal, ray);\n    else outputColor = rimLightShadingAdvanced(normalize(LIGHT_DIRECTION), LIGHT_SPREAD, LIGHT_THRESHOLD, LIGHT_THICKNESS, RIMLIGHT_STRENGTH, LIGHT_COLOR, SPECULAR_STEP, outputColor, mIndex, pos, normal, ray);\n    fragColor = outputColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"# define RECOVER_TIME 2.0\n# define SENSITIVE 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 curRot = load(POINTER_ROT);\n    float time = load(POINTER_TIME).x;\n    float press = load(POINTER_PRESS).x;\n    vec4 mouse = load(POINTER_MOUSE);\n    float reset = load(POINTER_RESETCAM).x;\n    if(curRot == vec4(0.0)) curRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iMouse.z > 0.0)\n    {\n        if(press < 1.0)\n        {\n            press = 1.0;\n            mouse = iMouse;\n        }\n        \n        vec2 curAng = vec2(PI * SENSITIVE * (iMouse.x - mouse.x) / iResolution.x, PI * SENSITIVE * (mouse.y - iMouse.y) / iResolution.x); \n        curRot = quaternionMul(quaternionMul(vec4(sin(curAng.y / 2.0), 0.0, 0.0, cos(curAng.y / 2.0)), vec4(0.0, sin(curAng.x / 2.0), 0.0, cos(curAng.x / 2.0))), curRot);\n        mouse = iMouse;\n        \n        time = 0.0;\n        reset = 0.0;\n    }\n    else if(keyDown(81)) {\n        float curAng = PI * SENSITIVE * iTimeDelta;\n        curRot = -quaternionMul(vec4(0.0, 0.0, sin(curAng / 2.0), cos(curAng / 2.0)), curRot);\n        reset = 0.0;\n        time = 0.0;\n    }\n    else if(keyDown(81)) {\n        float curAng = PI * SENSITIVE * iTimeDelta;\n        curRot = -quaternionMul(vec4(0.0, 0.0, sin(curAng / 2.0), cos(curAng / 2.0)), curRot);\n        reset = 0.0;\n        time = 0.0;\n    }\n    else if(keyClick(82)) {\n        reset = 1.0;\n        time = 0.0;\n    }\n    else\n    {\n        press = 0.0;\n        time += iTimeDelta;\n    }\n    \n    if(reset > 0.0) {\n        float progress = time / RECOVER_TIME;\n        curRot = quaternionLerp(curRot, vec4(0.0, 0.0, 0.0, 1.0), clamp(progress, 0.0, 1.0));\n        time += iTimeDelta;\n        \n        if(progress >= 1.0) reset = 0.0;\n    }\n    \n    store(POINTER_ROT, curRot);\n    store(POINTER_TIME, vec4(time));\n    store(POINTER_PRESS, vec4(press));\n    store(POINTER_MOUSE, mouse);\n    store(POINTER_RESETCAM, vec4(reset));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"# define PI 3.1415926535897932384626433832795\n# define TOLERANCE 0.0001\n\n# define POINTER_ROT ivec2(0, 1)\n# define POINTER_TIME ivec2(0, 2)\n# define POINTER_PRESS ivec2(0, 3)\n# define POINTER_MOUSE ivec2(0, 4)\n# define POINTER_RESETCAM ivec2(0, 5)\n\n# define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n# define load(P) texelFetch(iChannel2, ivec2(P), 0)\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n// Util\nvec4 conjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quaternionInverse(vec4 q) {\n    return conjugate(q) / dot(q, q);\n}\n\nvec4 quaternionMul(vec4 left, vec4 right)\n{\n    float w = left.w*right.w - left.x*right.x - left.y*right.y - left.z * right.z;\n    float x = left.w*right.x + left.x*right.w + left.z*right.y - left.y * right.z;\n    float y = left.w*right.y + left.y*right.w + left.x*right.z - left.z * right.x;\n    float z = left.w*right.z + left.z*right.w + left.y*right.x - left.x * right.y;\n    \n    return vec4(x, y, z, w);\n}\n\nvec4 quaternionLerp(vec4 starting, vec4 ending, float t)\n{\n    float cosa = starting.x *ending.x + starting.y * ending.y + starting.z *ending.z  + starting.w * ending.w;\n    \n    if (cosa < 0.0) \n    {\n        ending.x = -ending.x;\n        ending.y = -ending.y;\n        ending.z = -ending.z;\n        ending.w = -ending.w;\n        cosa = -cosa;\n    }\n    \n    float k0, k1;\n    \n    if (cosa > 0.9995f) \n    {\n        k0 = 1.0 - t;\n        k1 = t;\n    }\n    else \n    {\n        float sina = sqrt(1.0 - cosa * cosa);\n        float a = atan(sina, cosa);\n        k0 = sin((1.0 - t) * a) / sina;\n        k1 = sin(t * a) / sina;\n    }\n    \n    vec4 result;\n    \n    result.x = starting.x * k0 + ending.x * k1;\n    result.y = starting.y * k0 + ending.y * k1;\n    result.z = starting.z * k0 + ending.z * k1;\n    result.w = starting.w * k0 + ending.w * k1;\n    \n    return result;\n}\n\nvec3 rotatePoint(vec3 p, vec3 center, vec4 q) {\n    vec4 pQuaternion = vec4(p - center, 0.0);\n\n    vec4 rotatedP = quaternionMul(quaternionMul(q , pQuaternion), conjugate(q));\n    vec3 rotatedPoint = rotatedP.xyz;\n    \n    rotatedPoint += center;\n    \n    return rotatedPoint;\n}\n\nfloat multiStep(float value, float level, float minValue, float offset)\n{\n    if(level <= 1.0) return 1.0;\n    \n    float curLevel = value * level;\n    float curOffset = floor(curLevel) / (level - 1.0);\n    curLevel = floor(curLevel + mix(offset, 0.0, curOffset));\n    \n    curOffset = curLevel / (level - 1.0);\n    curLevel += mix(minValue, 1.0, curOffset);\n    \n    return curLevel / level;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}","name":"Common","description":"","type":"common"}]}