{"ver":"0.1","info":{"id":"lcyyWK","date":"1732373583","viewed":44,"name":"Rainy rays variation #2","username":"cesio","description":"Shadows, sdf, rain drop","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","shadow","rain","union"],"hasliked":0,"parentid":"4c3cWN","parentname":"Rainy rays"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define EPSILON 0.0005\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 50. \n#define PRECISION 0.001\n#define MERGE_RADIUS 5.1\n\nstruct Material {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float alpha;\n};\n\nMaterial black() {\n  vec3 ambientColor = 0.45 * vec3(0., 0., 0.);\n  vec3 diffuseColor = 0.1 * vec3(0.9);\n  vec3 specularColor = 0.99 * vec3(1, 1, 1);\n  float alpha = 45.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial orange() {\n  vec3 ambientColor = 0.45 * vec3(0.9, 0.15, 0.);\n  vec3 diffuseColor = 0.1 * vec3(0.9);\n  vec3 specularColor = 0.99 * vec3(1, 1, 1);\n  float alpha = 45.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\n\nMaterial red() {\n  vec3 ambientColor = 0.45 * vec3(0.9, 0., 0.);\n  vec3 diffuseColor = 0.2* vec3(0.9);\n  vec3 specularColor = 0.99 * vec3(1, 1, 1);\n  float alpha = 15.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial green() {\n  vec3 ambientColor = 0.45 * vec3(0., 0.9, 0.);\n  vec3 diffuseColor = 0.3 * vec3(0.9);\n  vec3 specularColor = 0.9 * vec3(1, 1, 1);\n  float alpha = 50.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\n\nMaterial blue() {\n  vec3 ambientColor = 0.45 * vec3(0., 0., 0.9);\n  vec3 diffuseColor = 0.3 * vec3(0.9);\n  vec3 specularColor = 0.9 * vec3(1, 1, 1);\n  float alpha = 50.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial silver() {\n  vec3 ambientColor = 0.45 * vec3(0.8);\n  vec3 diffuseColor = 0.3 * vec3(0.3);\n  vec3 specularColor = 0.9 * vec3(1, 1, 1);\n  float alpha = 5.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial checkboard(vec3 p) {\n  vec3 ambientColor = 0.35 * vec3(0.3 + 1.*mod((floor(p.x) + floor(p.z)) , 2.0));\n  vec3 diffuseColor =  vec3(0.3);\n  vec3 specularColor = vec3(0.2);\n  float alpha = 1.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nstruct Surface {\n    Material m; // material\n    float d; // distance\n};\n\n// return a distance from point p and a sphere with center c and radius r and tm (transform matrix)\nSurface sdSphere(vec3 p, vec3 c, float r, Material m, mat3 tm) {\n    return Surface(m, length(p * tm - c) - r);\n}\n    \n    \n// return a distance from a point p and a floow at a height y (height of which the floor starts)\nSurface sdFloor(vec3 p, float y, Material m) {\n    return Surface(m, p.y + y);\n}\n\n// based on  https://iquilezles.org/articles/distfunctions/\nSurface sdTorus(vec3 pr, vec2 t, Material m, mat3 tm) {\n  vec3 p = pr * tm;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Surface(m, length(q)-t.y);\n}\n\n\nSurface minSurface(Surface s1, Surface s2) {\n    Surface res = s1;\n    if (res.d > s2.d) res = s2;\n    return res;\n}\n\n\n\nSurface roundMerge(Surface surface1, Surface surface2, float radius) {\n    float item1 = surface1.d;\n    float item2 = surface2.d;\n    float touchDistance = abs(item1 - item2);\n    \n    \n    vec2 intersection = vec2(item1 - radius, item2 - radius);\n    intersection = min(intersection, 0.0);\n    float insideDistance = length(intersection);\n    float simpleUnion = min(item1, item2);\n    float outsideDistance = max(simpleUnion, radius);\n    Surface res; res.d = outsideDistance - insideDistance;\n    \n    \n    if (touchDistance >= radius) {\n        if (item1 <= item2) res.m = surface1.m; else res.m = surface2.m;\n    } else {\n        float rr = touchDistance / MERGE_RADIUS;\n        if (surface1.d < surface2.d) {\n            res.m = Material(mix(surface2.m.ambientColor, surface1.m.ambientColor, rr), \n                             mix(surface2.m.diffuseColor, surface1.m.diffuseColor, rr), \n                             mix(surface2.m.specularColor, surface1.m.specularColor, rr), \n                             mix(surface2.m.alpha, surface1.m.alpha, rr));\n        } else {\n            res.m = surface2.m;\n        }\n    }\n    \n\n    return  res;\n}\n\n \nSurface scene(vec3 pr) {\n    //vec3 p = mod(pr + 0.5 * c, c) - 0.5 * c;\n    float sTime = iTime / 2.;\n\n    Surface sphere1 = sdSphere(pr + vec3(0., -1.1, -2.0), vec3(0.), 2., red(), identity());\n    Surface sphere2 = sdSphere(pr + vec3(-3.4, -0.1, -1.0), vec3(0.), 1., gold(), identity());\n    Surface sphere3 = sdSphere(pr + vec3(3.4, -0.1, -1.0), vec3(0.), 1., green(), identity());\n   // Surface sphere3 = sdSphere(vec3(pr.x, pr.y + sin(sTime) * 6., pr.z - 5.), vec3(0.), 1., blue(), identity());\n   // Surface res = roundMerge(sphere1, sphere2, MERGE_RADIUS);\n    //res = roundMerge(res, sphere3, MERGE_RADIUS);\n\n\n    //float tR1 = 3.2;\n   // Surface torus1 = sdTorus(vec3(pr.x, pr.y, pr.z - 1.), vec2(3.2, 0.4), silver(), rotateY(sTime) * rotateX(PI / 4.) * rotateZ(sTime));\n    //res = roundMerge(res, torus1, MERGE_RADIUS);\n    \n    Surface res = minSurface(sphere1, sphere2);\n    res = minSurface(res, sphere3);\n    //res = roundMerge(res, torus1, 0.4);\n    res = roundMerge(res,sdFloor(pr, 1., checkboard(pr)), 0.4);\n    return res;\n}\n\n\n// vector normal to sphere with cener c and radius r\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n  return normalize(\n    e.xyy * scene(p + e.xyy).d +\n    e.yyx * scene(p + e.yyx).d +\n    e.yxy * scene(p + e.yxy).d +\n    e.xxx * scene(p + e.xxx).d);\n}\n\n\nstruct RaymarchRes {\n    Surface s;\n    vec3 p; // surface hit point\n    float d; // distance\n};\n\nvec2 calculateRainDrop(vec2 p) {\n    float t = iTime * 1.;\n    float cols = 12.; float rows = 6.; float radius = 0.17; // radius of a droplet\n    vec2 s = p.xy / iResolution.xy;\n    s.y += t * 0.092;\n    float i = floor(s.x * cols);\n    float j = floor(s.y * rows);\n    \n    //s.y += fract(sin(i * 198.1) * 146.1) * 3.13;\n    t += fract(sin(i * 612.1 + j * 822.22) * 525.9) * 13.981;\n\n    vec2 cr = vec2(cols, rows); // how many columns and rows (of droplets)\n    vec2 r = fract(s * cr);\n\n    r -= 0.5; r.y -= 0.5 - radius;\n    r *= iResolution.xy / iResolution.y;\n    r.x *= rows / cols;\n    float td = 0.9; //time delta\n    float y1 = r.y + sin(t + sin(t + sin(t) * 0.1)) * (0.5 - radius) + (0.5 - radius);\n    t -= td;\n    float y2 = r.y + sin(t + sin(t + sin(t) * 0.1)) * (0.5 - radius) + (0.5 - radius);\n    t -= td;\n    float y3 = r.y + sin(t + sin(t + sin(t) * 0.1)) * (0.5 - radius) + (0.5 - radius);\n    t -= td;\n    float y4 = r.y + sin(t + sin(t + sin(t) * 0.1)) * (0.5 - radius) + (0.5 - radius);\n\n    r.y = y1; float d1 = smoothstep(radius, 0.,length(r));\n    vec2 r2 = r; r2.y = y2;\n    float d2 = smoothstep(radius * 0.74, 0.,length(r2));\n    vec2 r3 = r; r3.y = y3;\n    float d3 = smoothstep(radius * 0.5, 0.,length(r3));\n    vec2 r4 = r; r4.y = y4;\n    float d4 = smoothstep(radius * 0.34, 0.,length(r4));\n    vec2 bf = vec2(50., 50.);\n    \n    vec2 col = vec2(d1 * r * bf + d2 * r2 * bf + d3 * r3 * bf + d4 * r4 * bf);\n    return col;\n}\n\nRaymarchRes raymarch(vec3 ro, vec3 rd) {\n    float t = MIN_DISTANCE; \n    RaymarchRes res;\n    res.d = MAX_DISTANCE;\n        \n    for (int i = 0; i < 255; i++) {\n        vec3 p = ro + t * rd;\n        Surface sf = scene(p); \n        t += sf.d;\n        \n        if (sf.d < PRECISION) { // we hit the surface at point p\n            res.p = p;\n            res.s = sf;\n            break;\n        } else if (sf.d > MAX_DISTANCE) break; // we did not hit anything but are to far away from camera \n    }\n    \n    res.d = t;\n    return res;\n}\n    \nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\n\nvec3 calculateCameraPosition(vec3 lookAt, vec2 uv) {     \n    return vec3(0., 0., -5.);;\n}\n\nvec3 calculateLightPosition() {\n    // calculate position of the light\n    float lightTime = iTime * 1.;\n    float lightRadius = 2.;\n    vec3 lightVector;\n    lightVector.x = lightRadius * sin(lightTime) * 2.;\n    lightVector.y = -3.2;\n    lightVector.z = 1.;//2. + lightRadius * sin(lightTime); \n    \n    //lightVector = vec3(-2.0, 2.0, 5.0);\n    \n    return lightVector;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt){ // source: https://www.shadertoy.com/view/ltyXD3\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t).d;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > maxt) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 calculateLight(vec2 fragCoord, RaymarchRes rr, vec3 rd, vec3 lo) {\n    vec3 normalToSurfaceVector = calcNormal(rr.p);\n    vec3 l = normalize(-lo + rr.p); // light direction\n    \n    vec3 diffusion = clamp(dot(l, normalToSurfaceVector), 0.0, 1.) * rr.s.m.diffuseColor; // diffusion light\n    vec3 newRayOrigin = rr.p + normalToSurfaceVector * PRECISION * 2. ;\n    float dotRV = clamp(dot(reflect(l, normalToSurfaceVector), -rd), 0., 1.);\n    vec3 specular =  pow(dotRV, rr.s.m.alpha) * rr.s.m.specularColor; // specular light\n    float shadowMask = softShadow(rr.p, -lo, 0.02, 2.5);\n    vec3 color = rr.s.m.ambientColor + specular;\n    color *= diffusion * 25. * shadowMask;\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    color = vec3(color * pow(20. * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.2)); // vigniete\n    color = mix(color, vec3(0.0,0.0,0.0), 1.0 - exp(-0.0002*rr.d*rr.d*rr.d)); // fog to black\n    \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 rdd = calculateRainDrop(fragCoord * 1.); // rain drop distortion\n    uv -= rdd;\n    //rdd = vec4(0.);\n    vec3 lookAt = vec3(0.0,0.2, 0.);\n\n    vec3 ro = calculateCameraPosition(lookAt, uv);\n    vec3 rd = camera(ro, lookAt) * normalize(vec3(uv, -1.));\n    vec3 lo = calculateLightPosition();\n\n    vec4 backgroundColor = vec4(mix(vec3(0., 0.1, .2), vec3(0., 0., 0.), uv.y) * 1.1, 1.0);\n \n    \n    RaymarchRes rr = raymarch(vec3(ro.x, ro.y, ro.z), rd);\n    \n    vec3 normalToSurfaceVector = calcNormal(rr.p);\n    fragColor = (rr.d < MAX_DISTANCE) ? vec4(calculateLight(fragCoord, rr, rd, lo), 1.0) : backgroundColor;    \n    \n    //fragColor = vec4(calculateRainDrop(fragCoord), 0., 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n","name":"Common","description":"","type":"common"}]}