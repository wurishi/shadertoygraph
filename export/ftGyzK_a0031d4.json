{"ver":"0.1","info":{"id":"ftGyzK","date":"1661854720","viewed":751,"name":"Pathtraced Voxels - Traversal","username":"Poisson","description":"A pathtraced voxel terrain using traversal algorithm.\n\nFeatures:\n- motion blur\n- depth of field\n- antialiasing\n- global illumination\n- reflections\n- shadows\n- chromatic aberration","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","raytracer","ray","terrain","voxels","raycasting","voxel","reflections","pathtracing","pathtracer","path","traversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // chromatic aberration\n    vec2 ab = (uv-.5)*.005;\n    float colr = texture(iChannel0, uv+ab).r;\n    float colg = texture(iChannel0, uv).g;\n    float colb = texture(iChannel0, uv-ab).b;\n    \n    vec3 col = vec3(colr,colg,colb);\n    col = pow(col,vec3(.4545)); // gamma correction\n    col = smoothstep(0.,1.,col); // contrast\n     \n    // vignetting\n    vec2 p = fragCoord / iResolution.xy;\n    col *= .5+.5*clamp(pow(120. * p.x*p.y*(1.-p.x)*(1.-p.y), .1), 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// thanks to iq for the voxel algorithm\n// https://www.shadertoy.com/view/4dfGzs\n\n#define PI 3.141592\n#define TAU 6.283185\n#define SAMPLES 4\n#define ANTIALIAS\n#define MOTION_BLUR\n#define DEPTH_OF_FIELD\n\n#define MAX_BOUNCES 4\n#define MAX_DIST 40.\n\nfloat seed;\n\n// hash functions by Nimitz: https://www.shadertoy.com/view/Xt3cDn\n\nuint hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)*(1./float(0xffffffffU));\n}\n\nvec2 hash2(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash31(vec3 p) {\n    p = fract(p*vec3(234.342, 123.432, 432.234));\n    p += dot(p, p+118.432);\n    return fract(p.x*p.y*p.z);\n}\n\n// rotation function\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// random functions by reinder: https://www.shadertoy.com/view/XlGcWh\n\nvec2 random2D(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,TAU);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi), cos(phi));\n}\n\nvec3 random3D(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,TAU,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi), cos(phi)), h.x);\n}\n\nstruct Ray {\n    vec3 o, d; // origin and direction\n};\n\nstruct Camera {\n    vec3 o, d; // origin and direction\n    float z, a; // zoom and aperture\n};\n\n// simple camera system\nRay getRay(vec2 uv, Camera c, float aspect) {\n    float lensRad = c.a * .5;\n    float focDist = length(c.o - c.d);\n    float hh = tan(radians(c.z)*.5);\n    float hw = aspect * hh;\n\n    vec3 f = normalize(c.o - c.d);\n    vec3 s = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f, s);\n    \n    vec3 r = c.o - hw*focDist*s - hh*focDist*u - focDist*f;\n    vec3 h = 2.*hw*focDist*s;\n    vec3 v = 2.*hh*focDist*u;\n    \n    vec2 d = lensRad*random2D(seed);\n    vec3 o = s*d.x + u*d.y;\n    \n    vec3 i = normalize(r + uv.x*h + uv.y*v - c.o - o);\n    \n    return Ray(c.o + o, i);\n}\n\n#define LAMB 0\n#define METAL 1\n\nstruct Material {\n    int type; // metal or lambertian\n    vec3 col; // color of the object\n    float k; // roughness\n};\n\n// touching terrain at point p\nbool map(vec3 p) {\n    return p.y*abs(1.*sin(.5*p.y)) < -4.-4.*sin(.35*p.x)*sin(.35*p.z) + 2.5*sin(.5*p.x)*sin(.5*p.z) || p.y < -7.;\n}\n\n// intersections function\n\nfloat intersect(Ray r, out vec3 n, out Material mat) {\n    vec3 p = floor(r.o);\n    vec3 m = 1./r.d;\n    \n    vec3 s = sign(r.d);\n    vec3 q = (p - r.o + .5+.5*s) * m;\n    \n    float t;\n    for (int i=0; i<128; i++) {\n        vec3 v = step(q.xyz, q.yzx) * step(q.xyz, q.zxy);\n        q += v * m * s;\n        p += v * s;\n        n = v * -s;\n        \n        vec3 d = (p - r.o + .5-.5*s) / r.d;\n        t = max(d.x, max(d.y, d.z));\n        \n        if (map(p) || t > MAX_DIST) break;\n    }\n    \n    float v = hash31(p);\n    if (v < .5) {\n        mat = Material(LAMB, vec3(1,.8,.6), 0.);\n    } else if (v > .5) {\n        mat = Material(METAL, vec3(1,.3,.3), 0.);\n    } else {\n        mat = Material(METAL, vec3(.4,.6,1), .5);\n    }\n    if (p.y < -7.) {\n        mat = Material(METAL, vec3(.4,.5,.8), .05);\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 tot = vec3(0);\n    for (int i = 0; i < SAMPLES; i++) {\n    \n        // antialiasing code by Reinder: https://www.shadertoy.com/view/llVcDz\n\n        seed = float(hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+float(i);\n        \n        #ifdef ANTIALIAS\n        vec2 o = hash2(seed) - .5;\n        #else\n        vec2 o = vec2(0);\n        #endif\n        \n        vec2 uv = (fragCoord + o) / iResolution.xy;\n        \n        #ifdef MOTION_BLUR\n        float time = iTime + .03*(hash1(seed)-.5);\n        #else\n        float time = iTime;\n        #endif\n        time += 10.*mouse.x;\n\n        // setup camera\n        \n        #ifdef DEPTH_OF_FIELD\n        Camera c = Camera(vec3(-.5,6.+2.*cos(time),-8), vec3(0,0,0), 90., .5);\n        #else\n        Camera c = Camera(vec3(-.5,6.+2.*cos(time),-8), vec3(0,0,0), 90., .0);\n        #endif\n        \n        c.o.xz *= rot(.25*sin(time));\n\n        Ray r = getRay(uv, c, iResolution.x/iResolution.y);\n        r.o.x += 5.*cos(time);\n        r.o.z += 7.*time;\n\n        vec3 n;\n        Material mat;\n    \n        vec3 col = vec3(1);\n        \n        // pathtrace\n        \n        for (int j = 0; j < MAX_BOUNCES; j++) {\n            float t = intersect(r, n ,mat);\n            if (t < MAX_DIST) {\n                vec3 p = r.o + r.d * t;\n                col *= mat.col;\n                r.o = p;\n            \n                if (mat.type == LAMB) { // diffuse\n                    r.d = normalize(n + normalize(random3D(seed)));\n                } else if (mat.type == METAL) { // reflection\n                    r.d = normalize(reflect(r.d, n) + mat.k*random3D(seed));\n                }\n                \n                // cast shadow\n                \n                vec3 lig = normalize(vec3(4,8,4));\n                Ray s = Ray(p + n*.0001, normalize(lig + .01*random3D(seed)));\n                Material mm;\n                if (intersect(s, n, mm) < MAX_DIST) {\n                    col *= .1+mix(mat.col, vec3(.1,.2,.4), .5);\n                }\n            } else { // sky\n                vec3 sky = mix(vec3(1), vec3(.5,.7,1), .5+.5*r.d.y);\n                col *= sky;\n            \n                break;\n            }\n        }\n        \n        tot += col;\n    }\n    tot /= float(SAMPLES);\n    \n    // output\n    \n    fragColor = vec4(tot,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}