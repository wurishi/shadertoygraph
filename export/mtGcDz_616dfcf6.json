{"ver":"0.1","info":{"id":"mtGcDz","date":"1700103454","viewed":70,"name":"Imposing SDFs with local UVs","username":"skittss","description":"Imposing sdf primitives onto one another: arrow head and segment onto a ring.\n\nThe behaviour of isolines suffers as a result, but perhaps can be fixed.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","uv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code based off of Inigo Quilez's 2D SDF Primitive demos:\n// https://www.shadertoy.com/playlist/MXdSRf\n\n// Modified from below to include t-value.\n// iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float r, out float t ) \n{\n    float closest_p_theta = atan(p.y, p.x) + 3.14159265;\n    t = closest_p_theta / (2.0 * 3.14159265); // the \"v\" \n    \n    return length(vec2(p.x, p.y))-r;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n// iquilezles.org/articles/distfunctions2d\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    // constant setup\n    const float k = 3.0;   // arrow head ratio\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    // pixel setup\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    // === distance (four segments) === \n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n    //----\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n    //----\n    if( p.x<w1 ) // conditional is optional\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n    //----\n    if( pz.x>0.0 ) // conditional is optional\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    // === sign === \n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 ) //if( p.x>0.0 && z>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\nfloat sdImpose( in vec2 p, in float r, in float l, in float w )\n{\n    float rt = 0.0f;\n\tfloat d = sdCircle(p, r, rt);\n        \n    vec2 segUV = vec2(d, rt * l);\n    d = sdArrow(segUV, vec2(0.0, 0.0), vec2(0.0, l), w, 2.0*w);\n    //d = sdSegment(segUV, vec2(0.0, 0.0), vec2(0.0, l)) - w;\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float d = sdImpose(p, 0.5, 0.8, 0.05);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdImpose(m, 0.5, 0.8, 0.05);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    \n    //vec3 acol = vec3(rt);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}