{"ver":"0.1","info":{"id":"MdXyz8","date":"1611122548","viewed":174,"name":"Dedsec Server Room","username":"Ramocles","description":"After finally shipping Watch Dogs Legion I wanted to do a little tribute to the old Ubi logo on a hacker style server room. It is becoming a tradition for me to build a shadertoy related to my personal work projects. ( I know it is the old logo :P ) ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Ramon Viladomat\n\n#define PI 3.1415\n#define STEP_REDUCTION  0.8\n#define NUM_ITERATIONS  150\n#define NUM_REFLECTIONS 2\n\nvec3 lightDir \t= normalize(vec3(-0.5,2.0,-1.0));\nvec3 lightColor = vec3(1.0);\n\n// MORPHOLOGY\n//--------------------------------------------------------------------------\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//--------------------------------------------------------------------------\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\n//--------------------------------------------------------------------------\nvec2 mapUbi( in vec3 p )\n{  \n    //global mask\n    float mask = max(length(p)-0.96,-p.z);\n    \n    //spheres\n    float cl = abs(length(p)-0.9)-0.06;\n    float c2 = abs(length(p + vec3(0.0,0.105,0.0))-0.37)-0.034;\n    float c3 = abs(length(p + vec3(-0.07 ,0.18,0.0))-0.223)-0.028;\n    float c4 = length(p + vec3(-0.075,0.12,0.0))-0.14;\n\n    //Arc\n    vec2 arcpos = p.xy*vec2(1.0,0.94) + vec2(mix(0.0,-0.1,smoothstep(0.5,-1.0,p.y)),0.0);\n    float arcplus  = length(arcpos + vec2(-0.165,0.08))- 0.61; \n    vec2 arcpos2 = p.xy * vec2(1.0,mix(1.0,0.8,smoothstep(0.0,-0.4,p.y)));\n    float arcminus = length(arcpos2 + vec2(-0.15,0.13))- 0.53;\n\n    float arc = max(arcplus,-arcminus);\n    \n    float logobg = -p.z + 0.1;\n    \n    //mix shapes\n    float dist = min(min(cl,c2),min(c3,c4));\n    dist = min(arc,dist);\n    \n    dist = max(smin(dist,logobg,-50.0),mask);\n    \n    return vec2(dist,0.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 mapLogoBox( in vec3 p)\n{\n   float box     = length(max(abs(p-vec3(0.0,0.0,0.65))-vec3(1.0,1.4,0.5),0.0))-0.2;\n   box           = max(box,-(length(p)-0.96)); //Hole\n   return vec2(box,1.0);\n}\n\n//--------------------------------------------------------------------------\nfloat signedBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//--------------------------------------------------------------------------\nvec2 mapServers( in vec3 p)\n{\n    float wall    = -p.z+0.5;       \n    \n    float bottom  = length(max(abs(vec3(p.x,abs(p.y-0.7),p.z)-vec3(0.0,7.0,0.6))-vec3(50.0,3.0,0.5),0.0))-0.05;\n    wall          = min(wall,bottom);\n    \n    vec3 lightpos = p; \n    lightpos.xy   = mod(p.xy,0.3);\n    \n    float light   = length(lightpos-vec3(0.15,0.15,0.5))-0.03;\n    \n    vec2 ret = vec2(wall,1.0); \n    if ( light < wall ) ret = vec2(light,2.0);\n    \n    //Holes\n    vec3 holePos  = p; \n    holePos.x     = mod(holePos.x,5.0);\n    holePos       -= vec3(2.5,0.0,0.0);\n    float hole    = signedBox(holePos,vec3(0.3,10.0,3.0));\n    \n    holePos.x     = abs(holePos.x);    \n    ret.x         = max(ret.x,-hole);\n    \n    float border  = length(max(abs(holePos-vec3(0.3,0.0,10.3))-vec3(0.0,10.0,10.0),0.0))-0.05;\n    \n    if (ret.x > border ) ret = vec2(border,3.0);\n       \n    return ret;\n}\n\n//--------------------------------------------------------------------------\nvec2 mapRoom( in vec3 p )\n{\n    float ret    = p.z+40.0;\n    ret          = min(ret,p.x+22.8);\n    ret          = min(ret,-p.x+22.8);\n    ret          = min(ret,p.y+5.0);\n    ret          = min(ret,-p.y+7.0);   \n    \n    return vec2(ret,1.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 map( in vec3 p )\n{    \n   vec2 ret     = mapUbi(p);\n   vec2 box     = mapLogoBox(p);\n   vec2 servers = mapServers(p);\n   vec2 room    = mapRoom(p);\n    \n   if (ret.x > box.x) ret = box;\n   if (ret.x > servers.x) ret = servers; \n   if (ret.x > room.x) ret = room; \n   return ret;\n}\n\n//--------------------------------------------------------------------------\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 100.0;\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<NUM_ITERATIONS; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;\n        t += h*STEP_REDUCTION;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n// MATERIALS\n//--------------------------------------------------------------------------\nvec4 calcColorUbi( in vec3 pos )\n{\n    vec3 colorBack = vec3(0.2);\n    \n    vec3 colorA = vec3(0.2);\n    vec3 colorB = vec3(0.05,0.05,0.2);\n    vec3 ubicolor = mix(colorA,colorB,clamp(10.0*abs(pos.z),0.0,1.0));\n    ubicolor = mix(colorBack,ubicolor,step(length(pos),0.96));\n\treturn vec4(ubicolor,0.2);\n}\n\n//--------------------------------------------------------------------------\nvec4 calcColorLed( in vec3 pos)\n{\n    vec2 position = vec2(float(int((pos.x+40.0)/0.3)),float(int((pos.y+40.0)/0.3)));\n    float rand = hash(position);\n                       \n    float led = clamp(sin(20.0*(iTime+10.0)*rand),0.0,1.0);\n    \n    float colorChose = rand*4.0; \n    if (colorChose < 2.9) return led*vec4(1.0,0.0,0.0,0.0);\n    if (colorChose < 3.8) return led*vec4(0.1,1.0,0.0,0.0);\n    \n    return led*vec4(0.0,0.0,1.0,0.0);\n}\n\n//--------------------------------------------------------------------------\n\nfloat distToLine( in vec2 pos, in vec2 origin, in vec2 end )\n{\n    vec2 dir     = end - origin;\n    vec2 toPos   = pos - origin; \n    vec2 nDir    = normalize(dir);\n    vec2 projPos = origin+clamp(dot(toPos,nDir),0.0,length(dir))*nDir;\n    return length(pos-projPos);\n}\n\n//--------------------------------------------------------------------------\nfloat wathcdogsDist( in vec2 pos )\n{\n    pos.x = abs(pos.x);\n           \n    vec2 a = vec2(0.0,0.8);\n    vec2 b = vec2(1.0,-1.0);\n    vec2 c = vec2(1.0,1.0);\n    vec2 d = vec2(0.0,-1.4);\n    \n    float dist1 = distToLine(pos,a,b);\n    float dist2 = distToLine(pos,b,c);\n    float dist3 = distToLine(pos,c,d);   \n    \n    return min(dist1,min(dist2,dist3));\n}\n\n//--------------------------------------------------------------------------\nfloat HashNoise( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n//--------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( HashNoise(n+  0.0), HashNoise(n+  1.0),f.x),\n                   mix( HashNoise(n+ 57.0), HashNoise(n+ 58.0),f.x),f.y),\n               mix(mix( HashNoise(n+113.0), HashNoise(n+114.0),f.x),\n                   mix( HashNoise(n+170.0), HashNoise(n+171.0),f.x),f.y),f.z);\n}\n\n//--------------------------------------------------------------------------\nfloat Fbm(in vec3 p)\n{\n\tfloat f;\n    f  = 0.5000*Noise( p ); p = p*2.02;\n    f += 0.2500*Noise( p ); p = p*2.03;\n    f += 0.1250*Noise( p ); p = p*2.01;\n    f += 0.0625*Noise( p );\n\treturn f*2.0- 1.0; \n}\n\n//--------------------------------------------------------------------------\nvec4 CalcWallColor( in vec3 pos, in vec3 nor)\n{\n    float groundFactor = 1.0-(clamp(pos.y+5.0,0.0,0.1)*10.0);\n    float midBandFactor = 1.0-(clamp(abs(pos.x),5.0,5.1)-5.0)*10.0;\n       \n    float dist = 1.0-clamp(wathcdogsDist(0.3*pos.xz+vec2(0.0,1.4)),0.0,0.06)*(1.0/0.06);     \n    \n    float dirt = 0.6*(1.0-Fbm(pos*0.2))+0.4;\n    \n    vec4 floor = mix(vec4(vec3(0.0),0.2),vec4(vec3(0.05,0.0,0.0),0.05),dist); \n       \n    vec4 col = mix(vec4(0.05),floor,groundFactor*midBandFactor);\n    \n    return col*dirt;\n}\n\n//--------------------------------------------------------------------------\nvec4 calcColor( in vec3 pos, in vec3 nor, float matID, out vec3 normalmod )\n{\n    normalmod = vec3(0.0);\n    if (matID < 0.5 )  return calcColorUbi(pos);\n    if (matID < 1.5 )  return CalcWallColor(pos, nor);\n    if (matID < 2.5 )  return calcColorLed(pos);\n    else return vec4(0.0,0.0,0.1,0.2);\n}\n\n//--------------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos) \n{\n    vec3 e = vec3(0.0,0.0002,0.0);\n\tfloat d = map(pos).x;\n    return normalize(vec3( map(pos+e.yxx).x-d, map(pos+e.xyx).x-d, map(pos+e.xxy).x-d) );\t\n}\n\n//--------------------------------------------------------------------------\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<45; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.04, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n//--------------------------------------------------------------------------\n//IQ ray-marched ambient occlusion algorithm \nfloat ambientOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 2.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 0.6*totao, 0.0, 1.0 );\n}\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n    float defaultCameraAngle = PI*0.88;\n    float defaultCameraDist = 20.0;\n    float inputCamAngle = 3.1415*(1.5-mousePos.x);\n    float inputCamDist = 2.0+((1.0-mousePos.y)*22.0); \n    \n\tfloat camAngle = mix(defaultCameraAngle,inputCamAngle,clamp(iMouse.z,0.0,1.0));\n\tfloat camDist = mix(defaultCameraDist, inputCamDist, clamp(iMouse.z,0.0,1.0));\n\t\n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), 0.0, cos(camAngle)));\n    vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\n\t// render\n    vec3 color = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int k=0; k<NUM_REFLECTIONS; k++ )\n\t{\n        // raymarch\n        vec2 tmat = intersect(camPosition,rayDir);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 position \t= camPosition + tmat.x*rayDir;\n            vec3 normal \t= calcNormal(position);\n            vec3 reflDir \t= reflect(rayDir,normal);\n\n            float occlusion = ambientOcclusion(position,normal);\n            \n            // material\n            vec3 normalmod = vec3(0.0);\n            vec4 mate = calcColor( position, normal, tmat.y, normalmod );\n            normal = normalize( normal + normalmod );\n\n            // shading       \n            float ambient  \t\t= 0.7 + 0.3*normal.y;\n\t\t\tvec3 ambientColor   = ambient*mate.rgb;\n\t\t\t\n\t\t\tfloat diffuse = max(dot(lightDir,normal),0.0); \n\t\t\tfloat darkRim = smoothstep(0.0,0.5,max(dot(-rayDir,normal),0.0));\n\t\t\tfloat shadow  = softShadow(position, lightDir, 0.01, 10.0); \n            \n            float specular = pow(clamp(dot(lightDir,reflDir),0.0,1.0),3.0);\n            \n\t\t\tvec3 diffuseColor = darkRim*diffuse*lightColor*mate.rgb;\n\t\t\tvec3 ilumColor = occlusion*shadow*(diffuseColor+pow(specular,30.0)); //TODO ~ remove specular and do it via reflection\n\t\t\t\t\n\t\t\t// mixing lights\n\t\t\tcolor += attenuation*mix(ambientColor,ilumColor,0.6);\n            \n            attenuation *= mate.w;\n            camPosition = position + 0.001*normal;\n            rayDir = reflDir;\n        }\n    \telse\n    \t{\n            color += attenuation*vec3(0.02,0.02,0.05); \n            attenuation = 0.0; \n        }\n\t}\n\t\n\t// desat\n\tcolor = mix( color, vec3(dot(color,vec3(0.33))), 0.3 );\n\t\n    // gamma\n\tcolor = pow( color, vec3(0.45) );\n\n\t// tint\n\tcolor *= vec3(1.0,1.04,1.0);\n\n    fragColor = vec4( color,1.0 );\n}","name":"Image","description":"","type":"image"}]}