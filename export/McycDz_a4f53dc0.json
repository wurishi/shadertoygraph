{"ver":"0.1","info":{"id":"McycDz","date":"1731705710","viewed":52,"name":"Unreal Ordered Dithering","username":"MichaelPohoreski","description":"Unreal used ordered dithering in texture space for software rendering to provide a fake bi-linear blur.\nMouse Up/Down = zoom in/out\nCol 1 Bilinear\nCol 2 Unreal's Ordered Dithering\nCol 3 Nearest Neighbor\nCol 4 Unreal's Ordered Dither at zoomed resolution\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dither","dithering","texturemapping","ordered","software"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nUnreal (1998) Ordered Dithering\nCopyleft {c} 2024 Michael Pohoreski\n\nThe first Unreal had software rendering for texture mapping.\nIt used ordered dithering in texture space.\n\nRe-implemented from:\n\n* https://www.vogons.org/viewtopic.php?t=54603 (Quake 2 with Unreal-like dithering)\n\n    uniform sampler2D uTexture;\n    uniform vec2      uTexelSize;\n    uniform vec2      uUnrealCoords[4];\n     \n    void main()\n    {\n        vec2 m = mod(gl_FragCoord.xy - 0.5, 2.0);\n        int idx = int(m.x + 2.0 * m.y);\n        gl_FragColor = texture2D(uTexture, gl_TexCoord[0].xy + uUnrealCoords[idx] * uTexelSize);\n    }\n\nAlso see:\n* https://www.hugi.scene.org/online/coding/hugi%2020%20-%20cobil.htm\n* https://www.mobygames.com/game/330/unreal/\n\nNearest Neighbor sampling\n* https://www.shadertoy.com/view/MlB3D3\n\nTim Sweeney, who wrote the graphics code in Unreal, left a comment\non how the UV coordinates were used:\n* https://www.flipcode.com/archives/Texturing_As_In_Unreal.shtml\n*/\nvec2 vUnrealCoords[4] = vec2[4](\n    vec2( 0.25, 0.00 ), vec2( 0.50, 0.75 ),\n    vec2( 0.75, 0.50 ), vec2( 0.00, 0.25 )\n);\n\n//#define GAMMA_CORRECTION 2.2 // uncomment to enable\n\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\nconst vec2 gvFontSize = vec2(8.0, 15.0); // Multiples of 4x5 work best\n\nfloat DigitBin(const in int x)\n{\n    if (x < 10)\n        return // originals glyphs\n           x==0 ? 480599.0\n          :x==1 ? 143906.0 // Note: Original '1' without top-left serif: 139810.0\n          :x==2 ? 476951.0\n          :x==3 ? 476999.0\n          :x==4 ? 350020.0\n          :x==5 ? 464711.0\n          :x==6 ? 464727.0\n          :x==7 ? 476228.0\n          :x==8 ? 481111.0\n          :       481095.0;\n    else\n    if (x < 78)\n        return // Glyphs added by Michael Pohoreski\n           x==42 ?  21072.0 // *\n          :x==45 ?   3840.0 // -\n          :x==61 ?  61680.0 // =\n          :x==65 ? 434073.0 // A\n          :x==66 ? 497559.0 // B\n          :x==67 ? 921886.0 // C\n          :x==68 ? 498071.0 // D\n          :x==69 ? 988959.0 // E\n          :x==70 ? 988945.0 // F\n          :x==71 ? 925086.0 // G\n          :x==72 ? 630681.0 // H\n          :x==73 ? 467495.0 // I\n          :x==74 ? 559239.0 // J\n          :x==75 ? 611161.0 // K\n          :x==76 ?  69919.0 // L\n          :        653721.0 // M\n          ;\n    else\n    if (x < 91)\n        return // Glyphs added by Michael Pohoreski\n           x==78 ? 638361.0 // N\n          :x==79 ? 432534.0 // O\n          :x==80 ? 497425.0 // P\n          :x==81 ? 432606.0 // Q\n          :x==82 ? 497561.0 // R\n          :x==83 ? 923271.0 // S\n          :x==84 ? 467490.0 // T\n          :x==85 ? 629142.0 // U\n          :x==86 ? 349474.0 // V\n          :x==87 ? 629241.0 // W\n          :x==88 ? 628377.0 // X\n          :x==89 ? 348706.0 // Y\n          :        475671.0;// Z\n    return 0.0;\n}\n\nvec2 gvPrintCharXY = vec2( 0.0, 0.0 );\nvec3 Char( vec3 backgroundColor, vec3 textColor, vec2 fragCoord, float fValue)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - gvPrintCharXY) / gvFontSize;\n    if ((vStringCharCoords.y <  0.0) || \n        (vStringCharCoords.y >= 1.0) || \n        (vStringCharCoords.x <  0.0))\n    {\n        return backgroundColor;\n    }\n\n    float fCharBin = float(vStringCharCoords.x < 1.0) * DigitBin(int(fValue));\n\n    float fAdvance = 2.0;\n    gvPrintCharXY.x += gvFontSize.x + fAdvance;\n        \n    float a = floor(\n        mod(\n            (fCharBin / pow(\n                2.0, \n                floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), \n            2.0)\n    );\n    return mix( backgroundColor, textColor, a );\n}\n\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n#define COLOR_HEADER_BG  vec3( 0.0, 0.4, 1.0 )\n#define COLOR_TITLE_FG   vec3( 1.0, 1.0, 1.0 )\n\nvec3 drawTitle( in vec2 fragCoord, \n               float mx0, \n               float mx1, \n               float mx2, \n               float mx3)\n{\n    vec3 color = COLOR_HEADER_BG;\n    \n    float scale  = iResolution.x;\n    float center = (mx1 - mx0) * 0.5 * scale;\n\n    gvPrintCharXY.y = iResolution.y - gvFontSize.y - 1.;\n    \n    gvPrintCharXY.x = mx0*scale - center;\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 66. ); // B\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 73. ); // I\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 76. ); // L\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 73. ); // I\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 78. ); // N\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 69. ); // E\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 65. ); // A\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 82. ); // R\n\n    gvPrintCharXY.x = mx1*scale - center;\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 85. ); // U\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 78. ); // N\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 82. ); // R\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 69. ); // E\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 65. ); // A\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 76. ); // L\n\n    gvPrintCharXY.x = mx2*scale - center;\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 78. ); // N\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 69. ); // E\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 65. ); // A\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 82. ); // R\n\n    gvPrintCharXY.x = mx3*scale;\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 85.); // U\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 78.); // N\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 82.); // R\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 69.); // E\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 65.); // A\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 76.); // L\n    gvPrintCharXY.x += gvFontSize.x + 2.0;\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 78.); // N\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 69.); // E\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 65.); // A\n    color = Char( color, COLOR_TITLE_FG, fragCoord, 82.); // R\n\n\n    return color;\n}\n\n// ==================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy    / iResolution.xy; // 0..1\n    vec2 p = fragCoord.xy / iResolution.xy; // 0..1\n    vec2 vTexelSize = vec2(1.0) / iChannelResolution[0].xy;\n\n    float vertScale  = 16.0 - floor(m.y * 15.0);\n    vec2 scale       = (fragCoord.xy / vertScale);\n    vec2 uv          = scale * vTexelSize;\n    vec2 vTexCoord   = mod( fragCoord.xy - 0.5, 2.0 );\n    int  nDitherIdx  = int( vTexCoord.x + 2.0*vTexCoord.y );\n\n    vec2 nn          = floor(scale) + 0.5; // nearest neighbor\n    vec2 st          = nn * vTexelSize;\n    vec2 vTexCoord3  = mod( nn.xy - 0.5, 2.0 );\n    int  nDitherIdx3 = int( vTexCoord3.x + 2.0*vTexCoord3.y );\n\n    vec2 uvOriginal  = uv;\n    vec2 uvUnreal    = uv + (vUnrealCoords[ nDitherIdx ] * vTexelSize);\n    vec2 uvNearest   = st; // Alt. (floor(q1) + min(fract(q1) / fwidth(q1), 1.0) - 0.5) * vTexelSize;\n    vec2 uvUnrealest = st + (vUnrealCoords[ nDitherIdx3 ] * vTexelSize);\n    vec3 col;\n\n    float col0 = m.x - 0.4;\n    float col1 = m.x      ;\n    float col2 = m.x + 0.4;\n    float col3 = m.x + 0.6;\n\n    if (fragCoord.y > (iResolution.y - gvFontSize.y - 2.0)) // header\n    {\n        col = drawTitle( fragCoord, col0, col1, col2, col3 );\n    }\n    else // body\n    {\n                if (p.x < col0 )  col = texture( iChannel0, uvOriginal ).rgb;\n         else   if (p.x < col1 )  col = texture( iChannel0, uvUnreal   ).rgb;\n         else   if (p.x < col2 )  col = texture( iChannel0, uvNearest  ).rgb;\n         else /*               */ col = texture( iChannel0, uvUnrealest).rgb;\n     }\n\n#ifdef GAMMA_CORRECTION\n\tconst float invGamma = 1. / GAMMA_CORRECTION;\n\tcol = vec3(pow(col, vec3(invGamma)));\n#endif\n\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep( 0.002, 0.003, abs( p.x - col0 )));\n    col = mix( col, vec3(0.0,1.0,0.0), 1.0-smoothstep( 0.002, 0.003, abs( p.x - col1 )));\n    col = mix( col, vec3(0.0,0.0,1.0), 1.0-smoothstep( 0.002, 0.003, abs( p.x - col2 )));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}