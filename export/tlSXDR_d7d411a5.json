{"ver":"0.1","info":{"id":"tlSXDR","date":"1565558150","viewed":132,"name":"Multi-Julia Fractal","username":"DonKarlssonSan","description":"Multi-Julia\nz^6\n\nDRAG THE MOUSE TO EXPLORE!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Complex power\n// Let z = r(cos θ + i sin θ)\n// Then z^n = r^n (cos nθ + i sin nθ)\nvec2 cx_pow(vec2 a, float n) {\n    float angle = atan(a.y, a.x);\n    float r = length(a);\n    float real = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(real, im);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float xmin = -1.9;\n    float ymin = -1.3;\n    float xmax = 1.9;\n    float ymax = 1.3;\n    float xDelta;\n    float yDelta;\n    xDelta = (xmax - xmin) / iResolution.x;\n    yDelta = (ymax - ymin) / iResolution.y;\n    int iteration = 0;\n    const int max_iteration = 100;\n    vec2 l = (iMouse.xy / iResolution.xy - 0.5) * 4.0;\n    float x = xmin + fragCoord.x * xDelta;\n    float y = ymin + fragCoord.y * yDelta;\n    // while loop not supported on iPhone !!\n    // Using a for loop with break condition instead.\n    for (int i = 0; i < max_iteration; i++) {\n        vec2 p = cx_pow(vec2(x, y), 6.0);\n        float xtemp = p.x + l.x;\n        y = p.y + l.y;\n        x = xtemp;\n        iteration = i;\n        if(x*x + y*y > 16.0) break;\n    }\n \n    float log_zn;\n    float nu;\n    float sm = float(iteration);\n    float s = 0.0;\n    float v = 0.0;\n    if (iteration < max_iteration ) {\n        // sqrt of inner term removed using log simplification rules.\n        log_zn = log( x*x + y*y ) / 2.0;\n        nu = log( log_zn / log(2.0) ) / log(2.0);\n        // Rearranging the potential function.\n        // Dividing log_zn by log(2) instead of log(N = 1<<8)\n        // because we want the entire palette to range from the\n        // center to radius 2, NOT our bailout radius.\n        sm = float(iteration) + 1.0 - nu;\n        s = 1.0;\n        v = 0.5;\n    }\n    \n    float hue = sm / float(max_iteration) * 2.0 + iTime / 20.0;\n    vec3 hsv = hsv2rgb(vec3(hue, s, v));    \n    fragColor = vec4(hsv, 1.0);\n}","name":"Image","description":"","type":"image"}]}