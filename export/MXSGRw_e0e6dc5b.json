{"ver":"0.1","info":{"id":"MXSGRw","date":"1708294454","viewed":59,"name":"Gravity pixels","username":"5weetdev","description":"This shader gives each pixel gravity and paints it based on where it will end up","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment to enable\n//#define ENABLE_GRAVITY_FOR_OTHER_POINTS\n#define DELTA_TIME 100.0 // Decrease for accuracy\n#define ITERATIONS 100   // Increase for accuracy\n// Distance threshold to any spcae body\n#define VOID_DISTANCE_TRESHOLD 100.0\n\n// Space body structure\nstruct Body\n{\n    vec2 position;\n    vec2 velocity;\n    float mass;\n};\n\n// Define functions\nvec2 calculateGravitationalForce(Body body1, Body body2);\nvec2 applyForce(Body body, vec2 force, float deltaTime);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Change that to move and zoom camera\n    vec2 zoom = vec2(1.0);\n    vec2 trans = vec2(0.0, 0.0);\n    \n    // Creates body in fragment coordinates\n    Body Point1;\n    Point1.position = vec2((fragCoord.x + trans.x) * zoom.x, (fragCoord.y + trans.y) * zoom.y);\n    Point1.velocity = vec2(0.0, 0.0);\n    Point1.mass = 1.0;\n    \n    // Create body on mouse position coordinates\n    Body Point2;\n    Point2.position = vec2(iMouse.x, iMouse.y);\n    Point2.velocity = vec2(0.0, 0.0);\n    Point2.mass = 10.0;\n\n    // Static point\n    Body Point3;\n    Point3.position = vec2(iResolution.x * 0.25, iResolution.y * 0.25);\n    Point3.velocity = vec2(0.0, 1.0); // Moves up\n    Point3.mass = 10.0;\n    \n    // Moving point\n    Body Point4;\n    Point4.position = vec2(iResolution.x * 0.75, iResolution.y * 0.25);\n    Point4.velocity = vec2(0.0, 0.0);\n    Point4.mass = 10.0;\n\n    for(int i = 0; i < ITERATIONS; i++){\n        // point 1\n        vec2 force2 = calculateGravitationalForce(Point1, Point2);\n        vec2 force3 = calculateGravitationalForce(Point1, Point3);\n        vec2 force4 = calculateGravitationalForce(Point1, Point4);\n\n        Point1.velocity += applyForce(Point1, force2, DELTA_TIME);\n        Point1.velocity += applyForce(Point1, force3, DELTA_TIME);\n        Point1.velocity += applyForce(Point1, force4, DELTA_TIME);\n\n#ifdef ENABLE_GRAVITY_FOR_OTHER_POINTS\n        // point 2\n        force2 = calculateGravitationalForce(Point2, Point1);\n        force3 = calculateGravitationalForce(Point2, Point3);\n        force4 = calculateGravitationalForce(Point2, Point4);\n\n        Point2.velocity += applyForce(Point2, force2, DELTA_TIME);\n        Point2.velocity += applyForce(Point2, force3, DELTA_TIME);\n        Point2.velocity += applyForce(Point2, force4, DELTA_TIME);\n\n        // point 3\n        force2 = calculateGravitationalForce(Point3, Point2);\n        force3 = calculateGravitationalForce(Point3, Point1);\n        force4 = calculateGravitationalForce(Point3, Point4);\n\n        Point3.velocity += applyForce(Point3, force2, DELTA_TIME);\n        Point3.velocity += applyForce(Point3, force3, DELTA_TIME);\n        Point3.velocity += applyForce(Point3, force4, DELTA_TIME);\n\n        // point 4\n        force2 = calculateGravitationalForce(Point4, Point2);\n        force3 = calculateGravitationalForce(Point4, Point3);\n        force4 = calculateGravitationalForce(Point4, Point1);\n\n        Point4.velocity += applyForce(Point4, force2, DELTA_TIME);\n        Point4.velocity += applyForce(Point4, force3, DELTA_TIME);\n        Point4.velocity += applyForce(Point4, force4, DELTA_TIME);\n#endif\n\n        // Apply position\n        Point1.position += Point1.velocity;\n        Point2.position += Point2.velocity;\n        Point3.position += Point3.velocity;\n        Point4.position += Point4.velocity;\n    }\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float dist2 = distance(Point1.position / iResolution.xy, Point2.position / iResolution.xy);\n    float dist3 = distance(Point1.position / iResolution.xy, Point3.position / iResolution.xy);\n    float dist4 = distance(Point1.position / iResolution.xy, Point4.position / iResolution.xy);\n\n    // Color fragments based on distance \n    if (\n        dist2 < VOID_DISTANCE_TRESHOLD &&\n        dist3 < VOID_DISTANCE_TRESHOLD &&\n        dist4 < VOID_DISTANCE_TRESHOLD)\n    {\n        //col += vec3(1.0) - vec3(dist2, dist3, dist4);\n        if(dist2 < dist3 && dist2 < dist4)\n        {\n            col += vec3(dist2, 0.0, 0.0);\n        }\n        if(dist3 < dist2 && dist3 < dist4)\n        {\n            col += vec3(0.0, dist3, 0.0);\n        }\n        if(dist4 < dist3 && dist4 < dist2)\n        {\n            col += vec3(0.0, 0.0, dist3);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// Calculate gravitational force between two bodies\nvec2 calculateGravitationalForce(Body body1, Body body2) {\n    const float G = 1.0; // Gravitational constant\n    \n    vec2 r = body2.position - body1.position; // Vector from body1 to body2\n    float distanceSquared = dot(r, r); // Square of the distance between the bodies\n    \n    // Avoid division by zero\n    if (distanceSquared < 0.0001) {\n        return vec2(0.0); // Return zero force if the bodies are too close\n    }\n    \n    float forceMagnitude = (G * body1.mass * body2.mass) / distanceSquared; // Magnitude of the force\n    vec2 forceDirection = normalize(r); // Direction of the force\n    \n    vec2 force = forceDirection * forceMagnitude; // Calculate the force vector\n    return force;\n}\n\n// Apply force to a body and update its velocity\nvec2 applyForce(Body body, vec2 force, float deltaTime) {\n    vec2 acceleration = force / body.mass; // Calculate acceleration using Newton's second law (F = ma)\n    return acceleration * deltaTime;\n}","name":"Image","description":"","type":"image"}]}