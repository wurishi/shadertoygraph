{"ver":"0.1","info":{"id":"lsXfW4","date":"1496164399","viewed":522,"name":"OJ - Ljusf√§rd, scene 4","username":"rammoskar","description":"Full demo: https://www.youtube.com/watch?v=-helx-SxnJo","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","lightning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TIME mod(iTime, 26.0)\n#define drum pow(1.0 - 2.0 * mod(TIME, 0.5), 5.0)\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz)-r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nmat3 rot(float x, float y, float z)\n{\n\tfloat cx = cos(x);\n\tfloat sx = sin(x);\n\tfloat cy = cos(y);\n\tfloat sy = sin(y);\n\tfloat cz = cos(z);\n\tfloat sz = sin(z);\n\tmat3 xm = mat3(1, 0, 0,\n\t\t\t\t\t0, cx, -sx,\n\t\t\t\t\t0, sx, cx);\n\tmat3 ym = mat3(cy, 0, sy,\n\t\t\t  \t\t0, 1, 0,\n\t\t\t  \t\t-sy, 0, cy);\n\tmat3 zm = mat3(cz, -sz, 0,\n\t\t\t\t\tsz, cz, 0,\n\t\t\t\t\t0, 0, 1);\n\treturn xm * ym * zm;\n}\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n\n\nfloat smin( float a, float b)\n{\n\tfloat k = 0.5;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\n#define TEX 0.2\n#define SIZE 8.0\n#define PI 3.1415\n\n#define MAT_WALL 1.0\n#define MAT_SPIN 2.0\n#define MAT_GROUND 3.0\n\n\nvec2 ground(vec3 p) {\n\tp -= vec3(0,0,5);\n\tp.y += 10.0*TIME;\n\tfloat s = 1.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\n\tq.z += sin(p.x) * 0.5;\n\tq.z += sin(p.y) * 0.5;\n\tfloat d = udRoundBox(q, vec3(s * 0.3), s * 0.3);\n\treturn vec2(d, MAT_GROUND);\n}\n\nvec2 spin(vec3 p, vec3 rd, float dir) {\n\tp.x = p.x == 0.0 ? 0.00001 : p.x;\n\n\tfloat len = length(p.xy);\n\tfloat lenSize = 6.0;\n\tfloat lenY = mod(len, lenSize) - lenSize * 0.5;\n\tfloat lenPart = floor(len / lenSize);\n\tif (lenPart < 0.5 || lenPart > 2.5) {\n\t\treturn vec2(99999,  MAT_SPIN);\n\t}\n\tfloat angle = atan(p.y, p.x);\n\tfloat numParts =  floor( 5.5*lenPart);\n\tfloat partSize = PI / numParts;\n\tangle += PI;\n\tfloat r = dir * sign(cos(lenPart*PI))* TIME * 0.4 / lenPart;\n\tfloat part = floor(mod(angle + r + (lenPart < 1.5 ? partSize / 2.0 : 0.0), PI * 2.0) / partSize);\n\n\tangle = mod(0.3*lenPart + angle + r, partSize) + partSize * 0.5 * max(0.0, numParts - 1.0);\n\n\n\tvec3 newPos = vec3(len * cos(angle), lenY * sin(angle), p.z);\n\tfloat d = sdSphere(newPos, 1.0);\n\treturn vec2(d, MAT_SPIN);\n}\n\n\n\nvec2 map(vec3 p, vec3 rd) {\n\tvec2 res = spin(p ,rd, 1.0);\n\tres = un(ground(p - vec3(0, 0, 0)), res);\n \treturn res;\n}\n\nvec4 roofLight(vec3 p) {\n\tfloat music = drum; \n\tfloat s = 15.0;\n\tp.y += 10.0*TIME;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tq *= rot(0.0,0.0,TIME * 5.0 + p.x*0.1 + p.z*0.1);\n\tvec3 lightCol = vec3(0.5 + 0.5 * sin(p.x), 0.5 + 0.5 * sin(p.y), 0.1);\n\tfloat dis = sdCappedCylinder(q.zxy - vec3(-10, 0, 0), vec2(0.05, 5.0));\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = lightCol * 5.0/(0.1*distanceToL + 0.3*distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec4 sunLight(vec3 pos) {\n\tvec3 lightCol = vec3(1.0,0.8, 0.5*(cos(TIME) + 1.0));\n\n\tfloat music = drum;\n\tfloat mdis = sdSphere(pos - vec3(0.0,0.0,0.5*sin(10.0*TIME)), 0.8 + 0.8 * music);\n\n\n\tfloat distanceToL = max(0.0001, mdis);\n\tvec3 point = lightCol * (80.0 + 80.0 * music)/(distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\n\nvec3 evaluateLight(vec3 pos, inout float dis)\n{\n\tvec4 sun = sunLight(pos);\n\tvec4 rl = roofLight(pos);\n\tdis = min(sun.w, rl.w);\n\treturn sun.xyz + rl.xyz;\n}\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {\n\tvec3 lpos = vec3(0, 0,0);\n\n\tfloat dis = length(lpos - pos);\n\tvec3 invLight = normalize(lpos - pos);\n\tfloat diffuse = max(0.0, dot(invLight, normal));\n\tfloat spec = specular(normal, -invLight, normalize(eye - pos), 220.0);\n\n\tfloat str = 1.0/(0.1 + 0.01*dis + 0.1*dis*dis);\n\tfloat tmp = 0.0;\n\tstr = 1.0;\n\tcolor =  color * (0.0 + 0.8*diffuse*evaluateLight(pos, tmp).xyz) + spec*str;\n}\n\n\n\nvec3 getNormal(vec3 p, vec3 rd)\n{\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz, rd).x - map(p - ep.xyz, rd).x;\n    normal.y = map(p + ep.yxz, rd).x - map(p - ep.yxz, rd).x;\n    normal.z = map(p + ep.yzx, rd).x - map(p - ep.yzx, rd).x;\n    return normalize(normal);\n\n}\n\nfloat occlusion(vec3 p, vec3 normal, vec3 rd)\n{\n\tfloat o = clamp(2.0*map(p + normal * 0.5, rd).x, 0.0, 1.0);\n\treturn 0.2 + 0.8*o;\n}\n\n\n\nvec3 raymarch(vec3 ro, vec3 rd, inout vec3 finalPos, vec3 eye) {\n\tfloat t = 0.0;\n\tconst int maxIter = 100;\n\tconst float maxDis = 300.0;\n\tfloat d = 0.0;\n\tvec3 p = vec3(-1.0, -1.0, -1.0);\n\tvec3 col = vec3(0);\n\tconst int jumps = 3;\n\tfloat ref = 1.0;\n\tvec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n\tfor (int j = 0; j < jumps; j++) {\n\t\tfor (int i = 0; i < maxIter; i++) {\n\t\t\tp = ro + rd * t;\n\n\t\t\tvec2 res = map(p, rd);\n\t\t\td = res.x;\n\t\t\tfloat fogAmount = 0.01;\n\t\t\tfloat lightDis = -1.0;\n\t\t\tvec3 light = evaluateLight(p, lightDis);\n\t\t\td = min(min(d, 1.0), max(lightDis, 0.05));\n\t\t\tvec3 lightIntegrated = light - light * exp(-fogAmount * d);\n\t\t\tscatteredLight += transmittance * lightIntegrated;\n\t\t\ttransmittance *= exp(-fogAmount * d);\n\n\t\t\tt += d;\n\t\t\tfloat m = res.y;\n\t\t\tbool end = i == maxIter - 1 ||t > maxDis;\n\t\t\tif (d < 0.01 || end) {\n\t\t\t\tvec3 c = vec3(1);\n\t\t\t\tvec3 normal = getNormal(p, rd);\n\t\t\t\tif (m == MAT_WALL) {\n\t\t\t\t\tc = vec3(1,0,0);\n\t\t\t\t} else if (m == MAT_SPIN) {\n\t\t\t\t\tc = vec3(0.5);\n\t\t\t\t} else if (m == MAT_GROUND) {\n\t\t\t\t\tvec3 q = floor(p);\n\t\t\t\t\tc = vec3(0.3,0.3,1);\n\t\t\t\t}\n\n\t\t\t\tc *= occlusion(p, normal, rd);\n\t\t\t\taddLightning(c, normal, eye, p);\n\t\t\t\tif (end) {\n\t\t\t\t\ttransmittance = 0.0;\n\t\t\t\t}\n\t\t\t\tcol = mix(col, transmittance * c + scatteredLight, ref);\n\t\t\t\tif (m == MAT_SPIN) {\n\t\t\t\t\tref *= 0.8;\n\t\t\t\t} else {\n\t\t\t\t\tref = 0.0;\n\t\t\t\t}\n\t\t\t\trd = reflect(rd, getNormal(p, rd));\n\t\t\t\tro = p + rd*0.05;\n\t\t\t\tt = 0.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t > maxDis) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ref < 0.1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinalPos = p;\n\treturn col;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (9.0/ 16.0);//* (iResolution.y/iResolution.x);\n\n    float t = TIME;\n    vec3 start = vec3(0.3*sin(t), -24.0 + 2.0*cos(t) , -4.0 );\n\n    float alpha = smoothstep(200.0, 201.0, TIME);\n\tvec3 tar = vec3(0); //eye + vec3(0.0, 0.0, 1.0);\n    vec3 eye = start + alpha*(tar - start);\n    vec3 lol = vec3(0, 1, 0);\n\n      if (t > 16.0) {\n    \teye = vec3(0.0, 0.0, -(TIME + 4.0)*3.0 + 55.0);\n    \ttar = vec3(0.1);\n    \tlol = vec3(0, 0, -1);\n\n        float alpha = smoothstep(25.0, 26.0, TIME);\n        eye = eye + alpha*(tar - eye);\n    } else if(t > 8.0) {\n    \teye = vec3(11.0*cos(0.4*t + 1.0),11.0*sin(0.4*t+1.0),-0.0);\n    \ttar = vec3(0.1, 1.0, 0.0);\n    \tlol = vec3(0.0, 0.0, -1.0);\n    }\n\n\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(lol, dir));\n\tvec3 up = cross(dir, right);\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\n\tvec3 light = vec3(0.0, 0.0, 26.0 );\n\n\tvec3 finalPos = vec3(-1.0, -1.0, -1.0);\n\tfloat material = -1.0;\n\tvec3 color = raymarch(ro, rd, finalPos, eye);\n\n    fragColor = vec4(color, 1.0);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0));\n}\n","name":"Image","description":"","type":"image"}]}