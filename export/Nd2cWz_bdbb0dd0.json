{"ver":"0.1","info":{"id":"Nd2cWz","date":"1643501950","viewed":104,"name":"Orbiting tricorns and mbrots","username":"c0rymcg","description":"The Mandelbrot set formula with two reflections interrupting the regular orbits. The reflection planes rotate slowly, as well as move in and out to create an array of fractal variants.\nwith log-potential smooth coloring","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","tricorn"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//based on https://www.shadertoy.com/view/WlcXR4\n\n#define PI 3.14159\n#define TAU 6.28318\n#define reflectionRecursion 3\n#define maxIterations 128\n#define AA 2\n\nvec2 f(vec2 z, vec2 c) {\n    return mat2(z,-z.y,z.x)*z + c;\n}\n\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( TAU*(c*loc+d) );\n}\n\nfloat logPotential(float d,float i){\n  \n\tfloat base=log(2.);\n\treturn i-(log(log(d)/base)/base);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 aacol=vec3(0.);\n    float time = iTime;\n\n    //create orbit reflectors\n    vec2 a1 = vec2(cos(time/4.),sin(-time/4.));\n    vec2 a2 = vec2(cos(time/5.),sin(time/5.));\n    vec2 a3 = vec2(cos(time/6.),sin(time/6.));\n    \n    float refldist = (cos(time/7.)+1.)*2.+0.25;\n    \n    vec2 rpos1 = -a1 * refldist;\n    vec2 rpos2 = -a2 * refldist;\n    vec2 rpos3 = -a3 * refldist;\n       \n    \n    //vector elements represent a, b, and c in the line formula ax+by+c\n    vec3 reflector1 = vec3(a1.x, a1.y, (a1.x*a1.x*refldist + a1.y*a1.y*refldist));\n    vec3 reflector2 = vec3(a2.x, a2.y, (a2.x*a2.x*refldist + a2.y*a2.y*refldist));\n    vec3 reflector3 = vec3(a3.x, a3.y, (a3.x*a3.x*refldist + a3.y*a3.y*refldist));\n    \n    \n    float zoom = (1. + refldist);\n    \n    int u_maxIterations = 200;\n    \n    vec2 c = vec2(0.);\n    vec2 z = vec2(0.);\n    \n    \n    \n    //aa code here\n    for (int aax=0; aax<AA; aax++){\n    for (int aay=0; aay<AA; aay++){\n        vec2 c = vec2(0.);\n      vec2 z = vec2(0.);\n    \n    vec2 uv = (fragCoord + vec2(aax,aay)/float(AA))/iResolution.xy;\n    uv -= 0.5;uv *= 1.3;uv += 0.5;\n    \n    c.x = 3.0 * (uv.x - 0.5) * zoom;\n    c.y = 2.0 * (uv.y - 0.5) * zoom;\n    int escaped = -1;\n    int iterations;\n    \n    \n    \n    for (int i = 0; i < maxIterations; i++) {\n        iterations = i;\n        z = f(z, c);\n        \n            \n        float d, x, y = 0.;\n        //handle reflections\n        //loop to control multiple bounces. Ideally bouncing would continue until the orbit is within the two reflection planes.\n        for(int r = 0; r < reflectionRecursion+1; r++){\n        if(reflector1.x * z.x + reflector1.y * z.y+reflector1.z < 0.) {\n            //find closest point on line ax+by+c to Z\n             d = -(reflector1.y * z.x - reflector1.x * z.y);\n             x = -(reflector1.y * d + reflector1.x*reflector1.z);//divisor;\n             y = -(reflector1.y * reflector1.z - reflector1.x*d);///divisor;\n\n            //reflect _z across point x, y\n            z = vec2(2.*x - z.x, 2. * y - z.y);\n\t\t\t\n\t\t}\n        if (reflector2.x * z.x + reflector2.y * z.y +reflector2.z < 0.){\n            //find closest point on line ax+by+c to Z\n             d = -(reflector2.y * z.x - reflector2.x * z.y);\n             x = -(reflector2.y * d+reflector2.x * reflector2.z);///divisor;\n             y = -(reflector2.y * reflector2.z - reflector2.x*d);///divisor;\n\n            //reflect _z across point x, y\n            z = vec2(2.*x - z.x, 2. * y - z.y);\n\t\t\t\n\t\t}\n        \n        if (reflector3.x * z.x + reflector3.y * z.y +reflector3.z < 0.){\n            //find closest point on line ax+by+c to Z\n             d = -(reflector3.y * z.x - reflector3.x * z.y);\n             x = -(reflector3.y * d+reflector3.x * reflector3.z);///divisor;\n             y = -(reflector3.y * reflector3.z - reflector3.x*d);///divisor;\n\n            //reflect _z across point x, y\n            z = vec2(2.*x - z.x, 2. * y - z.y);\n\t\t\t\n\t\t}\n        }\n\n       \n        \n        if (dot(z,z) > 80.0) {\n            escaped = i;\n            break;\n        }\n    }\n    float ang = atan(z.x, z.y)/TAU;\n\t\t\t\n    float potential=logPotential(length(z),float(escaped));\n    vec3 iterationCol = vec3(palette(potential/20., vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.0),vec3(0.3, 0.2, 0.2)));\n\t\t\n\n    aacol+= vec3((escaped>=0) ? iterationCol : vec3(0.));\n    }\n    }\n    fragColor=vec4(aacol.xyz/4.,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}