{"ver":"0.1","info":{"id":"MltBRj","date":"1540320989","viewed":762,"name":"unit quaternion as rotation","username":"GraphicsFromScratch","description":"quaternion","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["quaternion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T_MAX 15.0\n\nstruct point_light\n{\n    vec3 p;\n    vec3 i;\n};\n\nvec4 quat(in vec3 v, in float a)\n{\n    return vec4(v * sin(a / 2.0), cos(a / 2.0));\n}\n\nvec4 quat_inv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 p2q(in vec3 p)\n{\n    return vec4(p, 0);\n}\n\nvec4 q_mul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 v, in float a)\n{\n    vec4 q = quat(v, a);\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\nvec3 rotateq(in vec3 p, in vec4 q)\n{\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n    \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat obj_sdf(in vec3 p)\n{\n    vec4 r1 = quat(vec3(0,1,0), 0.0);\n    vec4 r2 = quat(vec3(0,1,0), 1.7);\n    vec4 r = normalize(mix(r1, r2, 0.5 + 0.5*sin(iTime)));\n    p = rotateq(p, r);\n    \n    vec3 dp = vec3(0, 1, 0);\n\tfloat sphere_sdf = length(p - dp) - 1.0;\n    float box_sdf = sdBox(p - dp, vec3(0.8));\n    float res = max(-sphere_sdf, box_sdf);\n    return res;\n}\n\nfloat sdf(in vec3 p, out int matid)\n{\n    float obj_sdf = obj_sdf(p);\n    float floor_sdf = abs(p.y);\n    \n    float sdf = min(obj_sdf, floor_sdf);\n    if (sdf == obj_sdf)\n    {\n        matid = 1;\n    }\n    else\n    {\n        matid = 0;\n    }\n    \n    return sdf;\n}\n\nvec3 sdf_n(in vec3 p)\n{\n    vec3 res = vec3(0);\n    \n    int ignored;\n    res.x = sdf(p + vec3(0.001, 0, 0), ignored) - sdf(p, ignored);\n    res.y = sdf(p + vec3(0, 0.001, 0), ignored) - sdf(p, ignored);\n    res.z = sdf(p + vec3(0, 0, 0.001), ignored) - sdf(p, ignored);\n    \n    return normalize(res);\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out int matid)\n{\n\tfloat t = 0.0;\n    matid = -1;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > T_MAX)\n        {\n            break;\n        }\n        \n        int curr_matid = -1;\n\t\tfloat d = sdf(ro + t*rd, curr_matid);\n        if (d < 0.0001)\n        {\n            matid = curr_matid;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\nfloat dir_shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 8.0 * d / t);\n    }\n    \n    return res;\n}\n\nfloat point_shadow(in vec3 p, in vec3 light_p)\n{\n    vec3 l = normalize(light_p - p);\n        \n    float t = 0.15;\n    float t_max = distance(light_p, p);\n    \n    float res = 1.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int ignored;\n        float d = sdf(p + t*l, ignored);\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 64.0 * d / t);\n    }\n    \n    return res;\n}\n\nfloat ao(in vec3 p, in vec3 n)\n{\n    float e = 0.1;\n    float res = 0.0;\n    \n#define AO_ITER 5\n    \n    int ignored;\n    float weight = 0.5;\n    for (int i = 1; i <= AO_ITER; ++i)\n    {\n        float d = e * float(i);\n        res += weight * (1.0 - (d - sdf(p + d * n, ignored)));\n        weight *= 0.5;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec2 fragCoord)\n{\n   \tvec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n     \n    float cam_d = 3.0;\n    float time = 0.6;\n    vec3 ro = vec3(cam_d*sin(time), 2.5, cam_d*cos(time));\n    vec3 at = vec3(0, 1, 0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.73 * cam_z);\n\t\n    vec3 sky = vec3(0.02);\n    vec3 col = vec3(0);\n    \n    int matid = -1;\n    float t = intersect(ro, rd, matid);\n    if (matid != -1)\n    { \n        vec3 p = ro + t*rd;\n        vec3 n = sdf_n(p);\n        \n#define PLIGHT_COUNT 1 \n        point_light plights[PLIGHT_COUNT];\n        plights[0] = point_light(vec3(2, 1, 1), vec3(20));\n\n        vec3 direct_light = vec3(0);\n        for (int plight_index = 0; plight_index < PLIGHT_COUNT; ++plight_index)\n        {\n            vec3 light_i = plights[plight_index].i;\n            vec3 light_p = plights[plight_index].p;\n        \tfloat light_r = dot(light_p - p, light_p - p);\n        \tvec3 l = normalize(light_p - p);\n        \n        \tdirect_light += point_shadow(p, light_p) * max(0.0, dot(n, l)) * light_i / (light_r * light_r);\n        }\n\n        vec3 indirect_light = ao(p, n) * sky;\n        \n        vec3 albedo = vec3(0.9);      \n\t\tcol = albedo * (0.7 * direct_light + indirect_light);\n        \n        col = mix(col, vec3(0), clamp(pow(t / T_MAX, 2.0), 0.0, 1.0));\n    }\n    \n    return col;\n}\n\nvec3 tonemap(in vec3 col)\n{\n    return col / (1.0 + col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    vec3 col = tonemap(render(fragCoord));\n#else\n    vec3 col = vec3(0);\n    col += tonemap(render(fragCoord + vec2(0.25, 0.25)));\n    col += tonemap(render(fragCoord + vec2(0.25, -0.25)));\n    col += tonemap(render(fragCoord + vec2(-0.25, -0.25)));\n    col += tonemap(render(fragCoord + vec2(-0.25, 0.25)));\n    col /= 4.0;\n#endif\n    \n    col = sqrt(col);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}