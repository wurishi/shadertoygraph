{"ver":"0.1","info":{"id":"Xc2cRG","date":"1722518598","viewed":31,"name":"ss2","username":"aezakku","description":"ss2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ss2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 BACKGROUND_COLOR = vec3(1.f, 1.f, 1.f);\n\nfloat INF = 100000000.f;\n\nstruct Viewport {\n    vec2 size;\n};\n\nstruct Camera {\n    vec3 position;\n    float znear;\n    float zfar;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec3 color;\n    bool exist;\n};\n\nvoid intersectRaySphere(vec3 camera_position, vec3 direction, \n                        Sphere s, out float t1, out float t2) {\n    \n    float r = s.radius;\n    vec3 sdir = camera_position - s.position;\n    \n    float a = dot(direction, direction);\n    float b = 2.f * dot(sdir, direction);\n    float c = dot(sdir, sdir) - r*r;\n    \n    float discriminant = b * b - 4.f * a * c;\n    if (discriminant < 0.f) {\n        t1 = INF;\n        t2 = INF;\n        return;\n    }\n    \n    t1 = (-b + sqrt(discriminant)) / (2.f*a);\n    t2 = (-b - sqrt(discriminant)) / (2.f*a);\n}\n\nViewport getViewport() {\n    Viewport v;\n    v.size = vec2(1.f, 1.f);\n    return v;\n}\n\nCamera getCamera() {\n    Camera c;\n    c.position = vec3(0.f, 0.f, 0.f);\n    c.znear = 0.1f;\n    c.zfar = INF;\n    return c;\n}\n\nvec3 canvas_to_viewport(vec2 coord) {\n    Camera c = getCamera();\n    Viewport v = getViewport();\n    vec2 uv = coord.xy / iResolution.xy;\n    vec3 res = vec3(uv.xy, c.znear);\n    return res;\n    \n}\n\nSphere[4] getSpheres() {\n    Sphere[4] ret;\n    float dx = 1.1f;\n    float initial_x = 2.f;\n    float dcolor = 0.2f;\n    vec3 base_color = vec3(0.1f, 0.1f, 0.1f);\n    for (int i = 0; i < 4; i++) {\n        Sphere s;\n        s.position = vec3(initial_x, 5.f, 4.f);\n        s.radius = 3.f;\n        s.color = base_color;\n        s.exist = true;\n        initial_x = initial_x + dx;\n        base_color = base_color + dcolor;\n        ret[i] = s;\n    }\n    return ret;\n}\n\nbool inRange(float tmin, float tmax, float t) {\n    return t > tmin && t < tmax;\n}\n\nvec3 traceRay(vec3 cameraPosition, vec3 direction, float tmin, float tmax) {\n   float closest_t = INF;\n   Sphere closest_sphere;\n   closest_sphere.exist = false;\n   Sphere[4] spheres = getSpheres();\n   for (int i = 0; i < 4; i++) {\n       float t1, t2;\n       intersectRaySphere(cameraPosition, direction, spheres[i], t1, t2);\n       if (inRange(tmin, tmax, t1) && t1 < closest_t) {\n           closest_t = t1;\n           closest_sphere = spheres[i];\n       }\n       if (inRange(tmin, tmax, t2) && t2 < closest_t) {\n           closest_t = t2;\n           closest_sphere = spheres[i];\n       }\n       \n   }\n   if (!closest_sphere.exist) {\n       return BACKGROUND_COLOR;\n   }\n   return closest_sphere.color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 d = canvas_to_viewport(fragCoord);\n    Camera c = getCamera();\n    \n    vec3 color = traceRay(c.position, d, c.znear, c.zfar);\n    fragColor = vec4(color.xyz, 1.f);\n}","name":"Image","description":"","type":"image"}]}