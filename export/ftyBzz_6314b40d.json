{"ver":"0.1","info":{"id":"ftyBzz","date":"1681866154","viewed":36,"name":"bouncing ball matrix","username":"Angramme","description":"test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["t"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define MAX_STEPS 4000\n#define MIN_DIST .0001\n#define MAX_DIST 400.\n\n#define M_PI 3.1415926535897932384626433832795\n\n#define Iterations 10000\n#define Bailout .00001\n#define Power 2.\n\n\n#define MRG .25\n#define PRD 2.5\n#define RST 1.7\nfloat GetDist(vec3 p){\n    vec2 gc = floor(p.xz / (1.+2.*MRG));\n    p.xz = mod(p.xz, 1.+2.*MRG);\n    \n    float hole = distance(p, vec3(.5+MRG, 0, .5+MRG)) - .5;\n    float flr = max(p.y, -hole);\n    float phase = max(0., mod(sin(gc.y*.6)*.3+gc.x*.25+iTime*2., PRD+RST)-RST)/PRD;\n    float sph_y = 4.*max(0., -phase*phase +phase);\n    float sph = distance(p, vec3(.5+MRG, sph_y, .5+MRG))-.4;\n    \n    return min(sph, flr);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    for(int i = 0; i<MAX_STEPS; i++){\n        vec3 p = d0 * rd + ro;\n        float d = GetDist(p);\n        \n        d0 += d;\n        if(d < MIN_DIST || d0 > MAX_DIST)break;\n    }\n    return d0;\n}\n\nvec3 GetNormal(vec3 p){\n    //vec2 eps = vec2(MIN_DIST + 0.001, 0);\n    vec2 eps = vec2(.001, 0);\n    return (vec3(\n        GetDist(p+eps.xyy),\n        GetDist(p+eps.yxy),\n        GetDist(p+eps.yyx)\n        ) - GetDist(p)) / eps.x;\n}\n\nvec3 GetSky(vec3 d){\n    return vec3(.8-d.y, .8-d.y, 1.);\n}\n\n\nstruct Material{\n    vec3 color;\n    vec2 refl;\n    float shininess;\n};\n\nMaterial GetMaterial(vec3 p, vec3 n){\n    return Material(\n        n*.5+.5,\n        //vec3(.9,1.,1.), \n        //vec2(0), \n        vec2(.2,.02),\n        300.);\n}\n\nvec3 ComputeMaterial(vec3 p, vec3 n, vec3 rd, Material M){\n    return n * .5 + .5;\n    \n    vec3 color = vec3(0);\n    \n    vec3[] lights = vec3[]( //position, color, pos....\n        vec3(250, 150, -200), vec3(1., .7, .7) //sun \n        );\n    \n    for(int i=0; i<lights.length(); i+=2){\n        vec3 lp = lights[i];\n        vec3 lc = lights[i+1];\n        vec3 L = normalize(lp - p);\n        float shadow = RayMarch(p + n*MIN_DIST*1000., L) > MAX_DIST ? 1. : .0;\n        //float shadow = 1.;\n        \n        //diffuse\n        color += max(0., dot(n, L)) * lc * M.color * shadow;\n        \n        //specular\n        color += .5 * min(pow(max(0., dot(reflect(L, n), rd)), M.shininess),1.) * lc * shadow * M.color;\n    }\n\t\n    \n    //sky\n    color += (max(0., dot(vec3(0,1,0), n))*.5+.5)*vec3(.05,.05,.1) * M.color;\n    \n    //sky reflection\n    color += max(0., dot(vec3(0,-1,0), n)) *vec3(.08,.05,.02) * M.color;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec3 col = vec3(0);\n    \n    float a;\n    vec3 ro;\n    if(m.z > 0.){\n        float xr = -m.x * 2.*M_PI + M_PI;\n        const float a = 4.;\n        float R = 7. + ((exp(a*(.5-m.y))-1.)/(exp(a)-1.))*23.;\n        ro = vec3(cos(xr) * R, 10.5+m.y*-11., sin(xr) * R);\n    }else{\n        a = iTime * .2;\n        // ro = vec3(sin(a) * 6., 2., cos(a) * 6. + 2.);\n        // ro = vec3(7., 2.5, 9.);\n        float x = cos(min(mod(iTime, 3.5*3.14159), 2.*3.14159))*4. + 4.0001;\n        ro = vec3(x, 5.5 - .2*x, x);\n    }\n    \n    vec3 lookat = vec3(0);\n    vec3 ww = normalize(lookat - ro);\n    vec3 uu = -normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = -normalize(cross(uu, ww));\n    vec3 rd = normalize(vec3(uv.x * uu + uv.y * vv + 1. * ww));\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d < MAX_DIST){\n        \n        vec3 p = ro + rd*d;\n        vec3 n = GetNormal(p);\n        \n        //n += textureLod(iChannel0, p*.5, 0.).xyz * .02;\n        \n        Material M = GetMaterial(p, n);\n\n        col += ComputeMaterial(p, n, rd, M);\n        \n        /*\n\t\t//reflecions\n        if(M.refl.x + M.refl.y > 0.){\n            vec3 r = reflect(rd, n);\n            float d2 = RayMarch(p + n * MIN_DIST*1.1, r);\n            vec3 p2 = p + r * d2;\n            vec3 n2 = GetNormal(p2);\n            Material M2 = GetMaterial(p2);\n\n            col += ComputeMaterial(p2, n2, r, M2)\n                * mix(M.refl.x, M.refl.y, max(0., dot(-rd, n)))\n                * M.color;\n        }\n\t\t*/\n\t\t\n        \n        //fog\n        float f = min(1., 1. / (pow(d*.01,2.) *4.*M_PI));\n        col = (1.-f)*GetSky(rd) + f*col;\n    }else{\n        \n        col += GetSky(rd);\n    }\n    \n    float gamma = 2.2;\n    col = pow(col, vec3(1.0/gamma));\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}