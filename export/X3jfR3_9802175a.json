{"ver":"0.1","info":{"id":"X3jfR3","date":"1729823118","viewed":38,"name":"psychodelic blobs ","username":"JJtheJet","description":"just making some blobs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blobs","learning","psychodelic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Generates a grainy texture effect based on a position vector\nfloat grain(vec2 st) {\n    return fract(iTime + sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.543123);\n}\n\n// Voronoise function and supporting hash function by iq (https://www.shadertoy.com/view/Xd23Dh)\nvec3 hash3(vec2 p) {\n    vec3 q = vec3(\n        dot(p, vec2(127.1, 311.7)), \n        dot(p, vec2(269.5, 183.3)), \n        dot(p, vec2(419.2, 371.9))\n    );\n    return fract(sin(q) * 43758.5453);\n}\n\n// Voronoise function with adjustable parameters\nfloat voronoise(vec2 p, float u, float v) {\n    float k = 1.0 + 63.0 * pow(1.0 - v, 6.0);\n\n    vec2 i = floor(p);   // integer part of input coordinates\n    vec2 f = fract(p);    // fractional part of input coordinates\n\n    vec2 a = vec2(0.0);\n    for (int y = -2; y <= 2; y++) {\n        for (int x = -2; x <= 2; x++) {\n            vec2 g = vec2(x, y);\n            vec3 o = hash3(i + g) * vec3(u, u, 1.0);\n            vec2 d = g - f + o.xy;\n            float w = pow(1.0 - smoothstep(0.0, 1.414, length(d)), k);\n            a += vec2(o.z * w, w);\n        }\n    }\n    return a.x / a.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates centered and scaled to maintain aspect ratio\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv.x += iTime * 0.1;\n\n    // Grid coordinates and local position within each cell\n    vec2 uv_i = floor(uv * 3.7);\n    vec2 uv_f = fract(uv * 3.7) - 0.5;\n\n    // Generate grain and voronoise effects\n    float grainVal = grain(uv_i - iTime) / 8.0;\n    float p = 0.314, v = 0.02718;\n    float voroNoise = voronoise(uv_i, p, v);\n\n    // Sound data access from texture (512x2)\n    // Row 0 = frequency data, Row 1 = waveform data\n    int tx = int(clamp(uv_i.x, 0.0, 1.0) * 512.0);\n    float fft = texelFetch(iChannel0, ivec2(tx, 0), 0).x * 10.0;   // frequency data\n    float wave = texelFetch(iChannel0, ivec2(tx, 1), 0).x;         // waveform data\n\n    // Circle shape configuration\n    float radius = 0.001;\n    float edgeSmoothness = 0.15;\n\n    vec3 color = vec3(0.0);\n\n    // Define oscillating movement based on sound\n    float offsetX = sin(iTime + uv_i.x * 3.14 + uv_i.y) * 0.2;\n    float offsetY = cos(iTime + uv_i.y * 2.718 + uv_i.x) * 0.2;\n    vec2 center = vec2(offsetX, offsetY);\n\n    // Calculate circular blobs with sound-based size modulation\n    float circle = smoothstep(radius + edgeSmoothness, radius, length(uv_f - center));\n    circle += smoothstep(radius + edgeSmoothness, radius, length(uv_f - vec2(cos(iTime + uv_i * voroNoise) / 10.0)));\n    circle += smoothstep(radius + edgeSmoothness, radius, length(uv_f - vec2(sin(iTime + uv_f * voroNoise) / 8.5)));\n\n    // Combine grain, FFT, and voronoise to vary blending between shapes\n    circle = smoothstep(0.001, 1.0 - (grainVal * fft * voroNoise), circle);\n\n    // Accumulate color with dynamic effects\n    for (float i = 0.0; i < 8.0; i++) {\n        color += circle * (0.5 + 0.5 * cos(iTime + uv_i.xyx + vec3(2.0, 2.0, 4.0) + fft / 2.0));\n    }\n\n    // Output final color\n    fragColor = vec4(color - grainVal * 0.05, 0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}