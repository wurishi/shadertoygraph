{"ver":"0.1","info":{"id":"4tcXzB","date":"1480339329","viewed":436,"name":"sinus clouds","username":"zguerrero","description":"trying volumetric clouds using sinus based noise. The render get strange with high value of iGlobaleTime, if anyone know the cause of the problem, and the solution if there is one, let me know!","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["noise","ray","cloud","volumetric","sinus","trace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sharpenDist = 1.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n\tvec4 buff = texture(iChannel0, uv)*5.0;\n    vec4 buff1 = texture(iChannel0, uv+vec2(1.0/iResolution.x,0.0)*sharpenDist)*-1.0;\n    vec4 buff2 = texture(iChannel0, uv+vec2(-1.0/iResolution.x,0.0)*sharpenDist)*-1.0;\n    vec4 buff3 = texture(iChannel0, uv+vec2(0.0,1.0/iResolution.y)*sharpenDist)*-1.0;\n    vec4 buff4 = texture(iChannel0, uv+vec2(0.0,-1.0/iResolution.y)*sharpenDist)*-1.0;\n    vec4 res = buff + buff1 + buff2 + buff3 + buff4;\n\tfragColor = res;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float viewDistance = 20.0;\nfloat cloudDensity = 1.0;\nvec3 noiseScale1 = vec3(0.7);\nvec3 noiseScale2 = vec3(0.3);\nvec3 noiseSpeed = vec3(2.0);\nvec3 cameraOrigin = vec3(0.0,1.5,0.0);\nvec3 cameraTarget = vec3(0.0,0.5,100.0);\nvec3 moveSpeed = vec3(0.0,0.0,7.0);\nvec4 skyColor1 = vec4(1.0,0.9,0.8,1.0);\nvec4 skyColor2 = vec4(1.0,0.97,0.95,0.0);\nvec4 skyColor3 = vec4(0.4,0.4,0.8,0.0);\nvec3 skyColorsPlacement = vec3(-0.75, -0.25, 1.25);\nvec3 color1 = vec3(1.0,1.0,0.9);\nvec3 color2 = vec3(0.5,0.3,0.7);\nvec2 densitySmoothstep = vec2(0.0,0.5);\nvec2 colorsPlacement = vec2(0.0,2.0);\n\n//from https:www.shadertoy.com/view/XsBXWt\nmat2 rot(float a) \n{\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 rotationX(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = pos.x;\n    rotPos.y = c * pos.y - s * pos.z;\n\trotPos.z = s * pos.y + c * pos.z;\n    \n    return rotPos;\n}\n\n\nvec3 rotationY(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = c * pos.x + s * pos.z;\n    rotPos.y = pos.y;\n\trotPos.z = -s * pos.x + c * pos.z;\n    \n    return rotPos;\n}\n\nvec3 rotationZ(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = c * pos.x - s * pos.y;\n    rotPos.y = c * pos.x + s * pos.y;\n\trotPos.z = pos.z;\n    \n    return rotPos;\n}\n\nfloat sinNoise(vec3 pos)\n{\n    float s = sin(pos.z+sin(pos.y+sin(pos.x)));\n    return s*0.5+0.5;\n}\n\nfloat sinNoiseCombine(vec3 pos, vec3 speed)\n{\n    float res = 0.0;\n    const float iMax = 4.0;\n    for(float i = 0.0; i < iMax; i++)\n    {\n        res += sinNoise(rotationY(pos * (1.0 + i*0.4) + vec3(speed), i*10.0));\n    }\n    res /= iMax;\n    return res;\n}\n\nvec4 rayCast(vec3 rayDir, vec3 cameraOrigin)\n{\n    const float iterations = 60.0;\n\tvec3 p = cameraOrigin;\n    float density = 0.0;\n    for(float i = 0.0; i < iterations; i++)\n\t{\n        float n = sinNoiseCombine(p*noiseScale1, vec3(iTime*noiseSpeed));\n        float cloudLimit = clamp(smoothstep(n*4.0,n*3.5,p.y) + 0.2,0.0,1.0);\n        float f = i / iterations;\n        float n2 = sinNoiseCombine(p*noiseScale2, vec3(n)*7.0);\n\t\tdensity += min(n,n2)*cloudLimit;\n\t\tp = cameraOrigin + rayDir * f * viewDistance;\n\t}\n    density *= cloudDensity/iterations;\n    density = clamp(density,0.0,1.0);\n    float density2 = smoothstep(densitySmoothstep.x, densitySmoothstep.y, density);\n    vec3 color = density2 * mix(color1, color2, smoothstep(colorsPlacement.x, colorsPlacement.y, density+(-p.y*0.05))); \n    return vec4(color, density2);\n}\n\nvec4 skyBox(vec3 rayDir)\n{\n    return mix(skyColor1, mix(skyColor2, skyColor3, smoothstep(skyColorsPlacement.y, skyColorsPlacement.z, rayDir.y)), smoothstep(skyColorsPlacement.x, skyColorsPlacement.y, rayDir.y));\n}\n\n//from https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 mInput = vec2((iMouse.x/iResolution.x)*2.0-1.0, (iMouse.y/iResolution.y)*2.0-1.0)*10.0;\n    cameraOrigin += vec3(0.0, sin(iTime*0.5)*3.0, 0.0) + moveSpeed*iTime;\n    vec3 ct = cameraOrigin;\n\t\n    if(iMouse.z/iResolution.x > 0.0)\n    {\n    \tct += vec3(sin(-mInput.x), 0.0, cos(mInput.x))*1.5;\n        vec3 upMove = vec3(0.0, mInput.y, 0.0);\n        ct += upMove*0.9;\n        cameraOrigin += upMove;\n    }\n    else\n    {\n        ct += cameraTarget + vec3(sin(iTime*0.5),sin(iTime*0.7),0.0)*2.0;\n    }\n\tvec2 screenPos = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n\tmat3 cam = setCamera(cameraOrigin, ct, sin(iTime*0.35)*0.5);\n    \n    vec3 rayDir = cam* normalize( vec3(screenPos.xy,0.75) );\n    vec4 effect = rayCast(rayDir, cameraOrigin);\n    \n    vec4 sky = skyBox(rayDir);\n\n    vec4 res = sky*(1.0-effect.w) + vec4(effect.xyz,0.0);\n\tfragColor = vec4(res);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 cameraOrigin = vec3(0.0,1.5,0.0);\nvec3 cameraTarget = vec3(0.0,0.5,100.0);\nfloat lightShaftDistance = -0.03;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 mInput = vec2((iMouse.x/iResolution.x)*2.0-1.0, (iMouse.y/iResolution.y)*2.0-1.0)*10.0;\n    cameraOrigin += vec3(0.0, sin(iTime*0.5)*3.0, 0.0);\n    vec3 ct = cameraOrigin;\n\t\n    if(iMouse.z/iResolution.x > 0.0)\n    {\n    \tct += vec3(sin(-mInput.x), mInput.y, cos(mInput.x))*1.5;\n    }\n    else\n    {\n        ct += cameraTarget + vec3(sin(iTime*0.5),sin(iTime*0.7),0.0)*2.0;\n    }\n    \n    vec3 cameraDir = normalize(ct - cameraOrigin);\n    \n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n\tvec4 buff = texture(iChannel0, uv);\n    \n    vec2 center = vec2(0.5, (cameraDir.y)-1.0);\n    vec3 lightShaft = vec3(0.0);\n    \n    for(float i = 0.0; i < 20.0; i++)\n    {\n        vec4 t = texture(iChannel0, (uv - center) * (1.0 + i * lightShaftDistance) + center);\n        lightShaft += t.xyz*t.a*t.a;\n    }\n    \n\tfragColor = vec4(buff*buff + lightShaft.xyzz*0.025);\n}","name":"Buf B","description":"","type":"buffer"}]}