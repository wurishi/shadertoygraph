{"ver":"0.1","info":{"id":"mstSWj","date":"1680456772","viewed":448,"name":"SDF Collision V4","username":"mikolalysenko","description":"Variant on test collision 3 using a new method to find the minimum point in the intersection.  Working a bit better, but still a bit slow.  Direction seems promising!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["collision","sdf","intersection","separation","contact"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Contact detection code by Mikola Lysenko\n//\n//\n// Rendering code based on \"RayMarching starting point\" https://www.shadertoy.com/view/WtGXDD\n//      Martijn Steinrucken aka The Art of Code/BigWings - 2020\n\n\n#define CONTACT_ITERS 10\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\n// animation state\nfloat offset = 0.;\nbool hit = false;\nvec3 posA = vec3(0., 0., 0.);\nmat3 rotA = mat3(\n    1., 0., 0.,\n    0., 1., 0.,\n    0., 0., 1.);\n\nvec3 posB = vec3(0., 0., 0.);\nmat3 rotB = mat3(\n    1., 0., 0.,\n    0., 1., 0.,\n    0., 0., 1.);\nvec3 qA = vec3(0);\nvec3 qB = vec3(0);\nvec3 ab = vec3(0.);\n\nvec3 minHit = vec3(0.);\n\n\n// standard sdf stuff\nfloat sdSphere( vec3 p, vec3 c, float s ) {\n  return length(p - c)-s;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdPlane (vec3 p) {\n    return p.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// shape signed distance functions\nfloat sdA (vec3 p) {\n    // return sdBox(rotA * (p - posA), vec3(1.));\n    return sdTorus(rotA * (p - posA), vec2(1.2, 0.35));\n    // return sdPlane(p + 0.5);\n}\nfloat sdB (vec3 p) {\n    return sdBox(rotB * (p - posB), vec3(1.));\n    // return sdTorus(rotB * (p - posB), vec2(1.2, 0.35));\n    // return sdSphere(p, posB, 0.3);\n}\n\n\n// boilerplate: gradients for shape sdfs\nvec3 gradA (vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = sdA(p) - \n        vec3(sdA(p-e.xyy), sdA(p-e.yxy),sdA(p-e.yyx));    \n    return normalize(n);\n}\nvec3 gradB (vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = sdB(p) - \n        vec3(sdB(p-e.xyy), sdB(p-e.yxy),sdB(p-e.yyx));    \n    return normalize(n);\n}\n\n\n//\n// begin actually interesting code\n//\nvec3 projIntersect (vec3 p, vec3 shift, float depth) {\n    for (int i = 0; i < 3; ++i) {\n        float fa = sdA(p) + depth;\n        float fb = sdB(p + shift) + depth;\n        if (fa > fb) {\n            if (fa > 0.) {\n                p -= fa * gradA(p);\n            } else {\n                break;\n             }\n        } else if (fb > 0.) {\n            p -= fb * gradB(p + shift);\n        } else {\n            break;\n        }\n    }\n    return p;\n}\n\nvec3 findMin(vec3 p, vec3 k) {\n    vec3 minPos = p;\n    float minDepth = 0.;\n    float lo = 0.;\n    float hi = 1.;\n    for (int i = 0; i < 8; ++i) {\n        float testDepth = 0.5 * (lo + hi);\n        p = projIntersect(p, k, testDepth);\n        float d = max(sdA(p), sdB(p + k));\n        if (d < minDepth) {\n            minDepth = d;\n            minPos = p;\n            lo = testDepth;\n        } else {\n            hi = testDepth;\n        }\n    }\n    return minPos;\n}\n\nvoid solveContact () {\n    vec3 shift = vec3(0.);\n    for (int i = 0; i < 8; ++i) {\n        minHit = 0.5 * (posA + posB - shift);\n        vec3 shift0 = shift;\n        for (int outerIter = 0; outerIter < 5; ++outerIter) {\n            minHit = findMin(minHit, shift);\n            float fa = sdA(minHit);\n            float fb = sdB(minHit + shift);\n            float rad = max(fa, fb);\n            if (rad > 0.) {\n                break;\n            }\n            hit = true;\n            vec3 d = normalize(fa * gradA(minHit) - fb * gradB(minHit + shift));\n\n            shift -= 2. * rad * d;\n       }\n       if (length(shift0 - shift) < 0.01) {\n           break;\n       }\n   }\n\n   if (hit) {\n       minHit = findMin(0.5 * (posA + posB), vec3(0.));\n   }\n   qA = minHit - 0.5 * shift;\n   qB = minHit + 0.5 * shift;\n   ab = shift;\n}\n//\n// end actually interesting code\n//\n\n\n// standard rendering stuff.  do 3 passes for each of the transparent layers, whatever.\nfloat GetDistSolid(vec3 p) {\n    float d = 10000.;\n    if (hit) {\n        d = min(d, sdSphere(p, qA, 0.05));\n        d = min(d, sdSphere(p, qB, 0.005));\n        d = min(d, sdCapsule(p, qA, qB, 0.005));\n        d = min(d, sdSphere(p, minHit, 0.07));\n    }\n    return d;\n}\nfloat RayMarchSolid(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistSolid(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalSolid(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistSolid(p) - \n        vec3(GetDistSolid(p-e.xyy), GetDistSolid(p-e.yxy),GetDistSolid(p-e.yyx));    \n    return normalize(n);\n}\n\nfloat GetDistAlphaC(vec3 p) {\n    return max(sdA(p), sdB(p));\n}\nfloat RayMarchAlphaC(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistAlphaC(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalAlphaC(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistAlphaC(p) - \n        vec3(GetDistAlphaC(p-e.xyy), GetDistAlphaC(p-e.yxy),GetDistAlphaC(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetDistAlpha(vec3 p) {\n    float d = min(sdA(p) - offset, sdB(p + ab) - offset);\n    return d;\n}\nfloat RayMarchAlpha(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistAlpha(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalAlpha(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistAlpha(p) - \n        vec3(GetDistAlpha(p-e.xyy), GetDistAlpha(p-e.yxy),GetDistAlpha(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// camera\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // update animation\n    float tt = 0.1 * iTime;\n    posB = vec3(3. * cos(tt), sin(3.3 * tt), 0.);\n    mat2 rr = Rot(tt * 0.5);\n    rotB = mat3(\n        rr[0].x, rr[0].y, 0.,\n        rr[1].x, rr[1].y, 0.,\n        0., 0., 1.);\n    mat2 qq = Rot(tt * 0.311);\n    rotB = rotB * mat3(\n        qq[0].x, 0., qq[0].y,\n        0., 1., 0.,\n        qq[1].x, 0., qq[1].y);\n\n    // solve for intersections\n    solveContact();\n    \n    // do the usual rendering stuff\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n    \n    float dSolid = RayMarchSolid(ro, rd);\n    if (dSolid < MAX_DIST) {\n        col = vec3(2., 0., 0.);\n    } else {\n        dSolid = MAX_DIST;\n    }\n    float dAlpha0 = RayMarchAlphaC(ro, rd);\n    if(dAlpha0<dSolid) {\n        vec3 p = ro + rd * dAlpha0;\n        vec3 n = GetNormalAlphaC(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        if (hit) {\n            col = mix(col, dif * vec3(1., 0.5, 0.2), 0.4);\n        } else {\n            col = mix(col, dif * vec3(0., 1., 1.), 0.3);\n        }\n    }\n    float dAlpha1 = RayMarchAlpha(ro, rd);\n    if(dAlpha1<dSolid) {\n        vec3 p = ro + rd * dAlpha1;\n        vec3 n = GetNormalAlpha(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = mix(col, vec3(dif), 0.2);\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}