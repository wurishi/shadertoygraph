{"ver":"0.1","info":{"id":"wdKXDy","date":"1574930370","viewed":168,"name":"Sequence (scene control)","username":"gaz","description":"sample https://qiita.com/gaziya5/private/0dacfdcbc8029b21ff1e\nI use a translation app for comments. There may be funny phrases.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sequence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// sample https://qiita.com/gaziya5/private/0dacfdcbc8029b21ff1e\n// ++++++++++++++++++++++++++++\n// シーケンス関係のマクロ\n// Sequence-related macros\n\n// world timeはmod()でループさせて、制御範囲を決める。\n// The world time is looped with mod () to determine the control range.\n#define worldTime mod(iTime,30.0)\n\nfloat TIME=0.0,SAM=0.0;\nint ID=-1;\n\n#define S(a)\\\n    TIME=max(TIME,(1.0-step(SAM+a,worldTime))*(worldTime-SAM));\\\n    ID+=int(step(SAM,worldTime));\\\n    SAM+=a;\n\n// シーンの順番\n// Scene order\n#define SceneID int[](3,0,1,2,1,3,2,0)[ID]\n\n// +++++++++++++++++++++++++++++\n// 良く使いまわすマクロ\n// Frequently used macros\n#define PI acos(-1.0)\n#define TAU PI*2.0\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n// https://twitter.com/phi16_/status/1143451702219042816\n#define hue(t) (cos((vec3(0,2,-2)/3.0+t)*TAU)*0.5+0.5)\n// https://twitter.com/phi16_/status/1151731126580338688\n#define hsv(h,s,v) mix(vec3(1),hue(h),s)*v\n// https://qiita.com/7CIT/items/4126d23ffb1b28b80f27\n#define lpNorm(p,n) pow(dot(pow(abs(p),vec2(n)),vec2(1)),1.0/n)\n// 超テキトーな乱数取得関数。\n// Cheap random number acquisition function.\n#define hash(n) fract(sin(n)*5555.0)\n// https://twitter.com/iquilezles/status/1177461747625553921\n#define opRepLim(p,s,lim) p-s*clamp(round(p/s),0.0,lim)\n\n// +++++++++++++++++++++++++++++\n// scene 0 で、使ってる関数\n// Function used in scene 0\n//\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n// pmod()のスムース版\n// https://www.shadertoy.com/view/WlBSRR\nvec2 polarSmoothFold(vec2 p,float n)\n{\n    float h=floor(log2(n));\n    float a =TAU*exp2(h)/n;\n    for(int i=0; i<int(h)+2; i++)\n    {\n        vec2 v = vec2(-cos(a),sin(a));  \n \t\tp-=2.0*smin(0.0,dot(p,v),0.05)*v;\n        a*=0.5;\n    }\n    return p;\n}\n\n// +++++++++++++++++++++++++++++\n// scene 1 で、使ってる関数\n// Function used in scene 1\n//\nfloat normalizeTime(float time, float startTime, float useTime)\n{\n    return clamp((time-startTime)/useTime, 0.0, 1.0);\n}\n\n\n// +++++++++++++++++++++++++++++\n// scene 2 で、使ってる関数\n// Function used in scene 2\n//\n// https://neort.io/art/bj2225k3p9f9psc9ovf0\n// イージング関数を一部抜粋。\nfloat ease_in_quad(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn c*(t/=d)*t + b;\n}\n\nfloat ease_in_sine(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn -c * cos(t/d * (3.14159265359/2.)) + c + b;\n}\n\n// +++++++++++++++++++++++++++++\n// scene 3 で、使ってる関数\n// Function used in scene 3\n// https://qiita.com/gaziya5/items/e58f8c1fce3f3f227ca7\n// リズムシーケンスを少し改造\n// Slightly modified rhythm sequence\n//\n\n#define Rhythm2Int(v,a)v=0;for(int i=0;i<16;i++)v+=a[i]<<i;\n\nfloat rhythmSequence(int s,float time, float a)\n{\n  float n =mod(time,a);\n  for(int i=0;i<16;i++){\n    if((s>>(int(time/a)-i)%16&1)==1)break;\n    n+=a;\n  }\n  return n;\n}\n\n// +++++++++++++++++++++++++++++\n// int A[26]は、アルファベットのデータだが、わかりずらいので、マクロを使用。\n// int A [26] is alphabetic data, but it is difficult to understand, so use macros.\n// int N[10]は、数字のデータ。インデックスが、そのまま数字なので、マクロを省略。\n// int N [10] is numeric data. Since the index is a number as it is, the macro is omitted.\n#define _A 0\n#define _B 1\n#define _C 2\n#define _D 3\n#define _E 4\n#define _F 5\n#define _G 6\n#define _H 7\n#define _I 8\n#define _J 9\n#define _K 10\n#define _L 11\n#define _M 12\n#define _N 13\n#define _O 14\n#define _P 15\n#define _Q 16\n#define _R 17\n#define _S 18\n#define _T 19\n#define _U 20\n#define _V 21\n#define _W 22\n#define _X 23\n#define _Y 24\n#define _Z 25\n\nint A[26]=int[](7325,53709,35217,53705,36241,3217,39317,7196,49601,39176,11282,35088,6202,14392,39321,3229,47513,11421,37285,16577,39192,2578,14872,8738,16418,33667);\nint N[10]=int[](39835,4106,36237,38285,5148,38293,40341,643,40349,38301);\n\n// 16セグメントの距離関数。\n// 16 segment distance function.\n// intをデータとして使用。bit演算でデータを取り出す。\n// Use int as data. Extract data by bit operation.\nfloat de16Seg(vec2 p,int n)\n{\n\tfloat e=2.;\n\tmat2 m=mat2(0,-1,1,0);\n    for(int i=0;i<16;i++){\n\t\tint j=i&3;\n\t\tif(j==0)m*=mat2(0,1,-1,0);\n\t\tif((n>>i&1)==1){\n\t\t\tvec2 a=m*vec2(26>>j&1,19>>j&1)*vec2(0.6,1);\n\t\t\tvec2 b=m*vec2(13>>j&1,9>>j&1)*vec2(0.6,1);\n            a.x+=0.2*a.y;\n            b.x+=0.2*b.y;\n            vec2 c=p-a,d=b-a;\n\t\t\te=min(e,length(c-d* clamp(dot(c,d)/dot(d,d), 0.0, 1.0)));\n\t\t}\n\t}\n\treturn e;\n}\n\n// debug用マクロのフラグ。 -1で通常。0~3でシーンを指定。\n// Flag for macro for debug. Usually at -1. Specify the scene with 0 ~ 3.\n#define TEST_ID -1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.15);\n\n    // これでシーンの切り替え時間を設定する。\n    // This sets the scene switching time.\n    S(3.0)S(5.0)S(3.0)S(4.0)S(4.0)S(5.0)S(3.0)S(3.0)\n        \n    // switchのcaseの後にブロックは、無くても良いにですが、変数名の衝突が、面倒なのでブロックを使ってます。\n    // There is no need to have a block after the switch case, but the variable name conflict is cumbersome, so the block is used.\n#if TEST_ID < 0\n    switch(SceneID)\n#else\n    switch(TEST_ID)\n#endif\n    {\n        case 0:\n        {\n            // シーケンスを使ってない奴。\n            // A guy who doesn't use sequences.\n            p*=8.0;\n            for(int i=0; i<3; i++)\n            {\n                p=polarSmoothFold(p,8.0);\n                p-=0.7+sin(TIME)*0.1;\n                p*=rot(hash(2.3+float(i)+floor(TIME*1.5)));\n                p=polarSmoothFold(p,5.0);\n                p.x-=0.3+sin(TIME)*0.1;\n                p*=0.6;  \n            }\n            float de=abs(lpNorm(p,5.0)-0.3);\n            de = min(de,abs(dot(p,rot(sin(TIME)*0.5+1.7)*vec2(0,1))));\n            col=mix(vec3(0),col,smoothstep(0.03,0.031,de));\n            col=mix(hsv(atan(p.x,p.y)*0.5+TIME,0.7,0.8),col,smoothstep(0.02,0.021,de));\n            break;\n        }\n        case 1:\n        {\n            // 個別のシーケンス\n            // Individual sequence\n            float de;\n            vec3 q;\n            \n            float itr=35.0;\n            float num=15.0;\n            \n            for(float i=0.0;i<num;i+=num/itr)\n            {\n                vec2 coord=vec2(hash(i+133.125),hash(i+320.123))*2.0-1.0;\n                coord.x*=iResolution.x/iResolution.y;\n                float t=normalizeTime(TIME, hash(i+456.123)*5.0, hash(i+789.123));\n                t=smoothstep(0.0,1.0,smoothstep(0.0, 1.0, t)); // easing\n                float r=mix(0.05,0.5,t);\n                de=abs(lpNorm(p-coord*0.7,8.0)-r);\n            \tcol=mix(vec3(0),col,smoothstep(0.02,0.021,de));\\\n            \tcol=mix(hsv(hash(i+74221.123),0.7,0.8),col,smoothstep(0.01,0.011,de));\n            }\n            break;\n        }\n        case 2:\n        {\n            // 累積時間をつかったシーケンス\n            // Sequence using accumulated time\n            // ここで使うならworld timeは、TIMEになる。注意。\n            // Caution. If used here, the world time will be TIME. \n            float T=0.0,SAM1=0.0;\n\t\t\t#define Q(a) T=clamp((TIME-SAM1)/a, 0.0, 1.0);SAM1+=a;\n            #define DSP2(c)\\\n            \tcol=mix(vec3(0),col,smoothstep(0.03,0.031,de));\\\n            \tcol=mix(c,col,smoothstep(0.02,0.021,de));\n\t\t\tfloat de,r;\n            vec2 coord;\n            \n            // shape 1\n            SAM1=0.0; // init\n            coord=vec2(0);\n            r=0.0;\n            Q(0.5)\n            \tT=ease_in_quad(T); // easing\n                r+=0.5*T;\n            Q(0.5)\n            Q(0.5)\n            Q(0.5)\n            \tT=ease_in_sine(T); // easing\n            \tr-=0.3*T;\n            de=abs(length(p-coord)-r);\n            DSP2(hsv(0.0,0.8,0.7))\n                \n            // shape 2\n            SAM1=0.0; // init\n            coord=vec2(0);\n            r=0.0;\n            Q(0.5)\n            Q(0.5)\n                T=ease_in_quad(T); // easing\n            \tr+=0.15*T; \n                coord+=vec2(0.7,0)*T;\n            Q(0.5)\n            \tT=ease_in_sine(T); // easing\n            \tcoord *=rot(T*TAU);\n            de=abs(length(p-coord)-r);\n            DSP2(hsv(0.5,0.8,0.7))\n            de=abs(length(p+coord)-r);\n            DSP2(hsv(0.5,0.8,0.7))          \n            break;\n        }\n        case 3:\n        {\n            // music shader シーケンスからの応用\n            // Application from music shader sequence\n\t\t\tfloat bpm=120.0;\n\t\t\tfloat beat=15.0/bpm;\n            int rhytm;\n    \t\tRhythm2Int(rhytm, int[]( 1,0,0,0, 0,0,0,1, 1,0,1,0, 0,0,0,0 ))\n            float localTime=rhythmSequence(rhytm,worldTime,beat);\n\t\t\tfloat value=exp(-localTime*3.0); //envelope\n            \n            #define DSP3(c)\\\n            \tcol=mix(vec3(0),col,smoothstep(0.03,0.031,de));\\\n            \tcol=mix(c,col,smoothstep(0.02,0.021,de));\n        \t\n            float de;\n            vec2 q=vec2(atan(p.x,p.y), length(p)-0.3);\n            q.y=opRepLim(q.y,0.2,floor(5.0*value));\n            float s=TAU/4.0;\n            q.x=mod(q.x,s)-0.5*s;\n            q.x-=clamp(q.x,-0.2,0.2);\n            de=length(q);\n            DSP3(mix(vec3(1),vec3(1,0,0),0.8))\n            float h=length(p)*0.5;\n            for(float i=0.0;i<3.0;i++) p=abs(p)-0.2/exp2(i);\n            if(p.x<p.y) p=p.yx;\n\t\t\tp.x-=clamp(p.x,0.0,value);\n\t\t\tde=length(p);\n            DSP3(hsv(h,0.7,0.8))\n            break;\n        }\n    }\n    \n    // デバック用の文字列\n    // String for debugging\n    // わざわざブロックを作ってる理由は、ブロック内だと変数名が重複しても、\n    // エラーが出ず、ブロック内の変数名が優先されるからです。\n    // The reason for making a block purposely is that if a variable name is duplicated within a block, \n    // an error will not occur and the variable name within the block will be given priority.\n    // デバック用なので、気楽に書きたいからですね。\n    // Because it is for debugging, I want to write it easily.\n\t{\n        vec2 p=fragCoord/iResolution.y;\n    \tp*=50.0;\n\n    \t#define ALF(a) idx=A[a];de=min(de,de16Seg(p,idx));p.x-=2.0;\n    \t#define NUM(a) idx=N[a];de=min(de,de16Seg(p,idx));p.x-=2.0;\n        #define DSP(c)\\\n        \tcol=mix(vec3(0),col,smoothstep(0.4,0.41,de));\\\n    \t\tcol=mix(c,col,smoothstep(0.15,0.16,de));\n        \n    \tint idx;\n   \t\tfloat de=2.0;\n    \tp-=vec2(35,10);\n    \tALF(_S)ALF(_C)ALF(_E)ALF(_N)ALF(_E)\n    \tDSP(vec3(1))\n        p.x-=1.0;\n        de=2.0;\n    \tNUM(SceneID)\n    \tDSP(vec3(1,0,0))\n    \tp-=vec2(-13,-4);\n        de=2.0;\n    \tALF(_L)ALF(_O)ALF(_C)ALF(_A)ALF(_L)\n        p.x-=1.0;\n    \tALF(_T)ALF(_I)ALF(_M)ALF(_E)\n        DSP(vec3(1))\n        p.x-=1.0;\n        de=2.0;\n    \tNUM(int(TIME)/10)\n        NUM(int(TIME)%10)\n    \tDSP(vec3(1,0,0))\n        de=2.0;\n        ALF(_S)\n    \tDSP(vec3(1))\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}