{"ver":"0.1","info":{"id":"ttdGDn","date":"1576064521","viewed":148,"name":"Optimum Unified Theory","username":"gforce1362","description":"Optimum Unified Equation\n\nClick = add energy\nW+click = neutralize energy\nS = zoom scale\nQ = pause, allows for adding energy in paused state\nR = switch between energy visualization and vector visualization\nSHIFT = add negative energy","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["optimumunifiedequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//const float SCALE = 0.35;\n//const float SCALE = 0.25;\nconst int KEY_S = 83; \nconst int KEY_R = 82;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float keys = \n        texelFetch( iChannel1, ivec2(KEY_S,2), 0 ).x;\n    float keyr = \n        texelFetch( iChannel1, ivec2(KEY_R,2), 0 ).x;\n    if (keys == 1.) {\n    \tuv -= 0.5;\n    \tuv *= SCALE;\n    \tuv += 0.5;\n    }\n    vec2 um = iMouse.xy/iResolution.xy;\n    vec3 pix = texture(iChannel0,uv).rgb;\n    if (keyr == 1.) {\n    \tpix = texture(iChannel3,uv).rgb;\n    }\n    vec3 col = texture(iChannel2,uv).rgb;\n    //col = hsv2rgb(col);\n    float p = texture(iChannel0,uv).r;\n    if (keyr == 1.) {\n    \tp = texture(iChannel3,uv).r;\n    }\n    float c = abs(p);\n    float b = 1.;\n    if (p > 0.) {\n        p = 0.;\n    } else {\n        p = 0.715;\n    }\n    //p = abs(p);\n    //p = fract(p);\n    if (c < 100.) {\n    //\tc = 0.;\n    }\n    \n    col = normalize(col);\n    pix = hsv2rgb(pix+abs(col-0.1));\n    pix = mix(pix,col,0.1);\n    //pix = col;\n    pix -= 0.4;\n    pix *= 1.7;\n    fragColor = vec4(pix,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//const float SCALE = 0.35;\n//const float SCALE = 0.25;\nconst int KEY_S = 83; \n//#define iTime iTime*28.\n\nfloat get(int x, int y) {\n    vec2 co = (gl_FragCoord.xy + vec2(x, y))/iResolution.xy;\n    float keys = \n        texelFetch( iChannel1, ivec2(KEY_S,2), 0 ).x;\n    /*if (keys == 1.) {\n        co -= 0.5;\n    \tco *= SCALE;\n    \tco += 0.5;\n    }*/\n    return texture(iChannel0, co).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    /*float keys = \n        texelFetch( iChannel1, ivec2(KEY_S,2), 0 ).x;\n    if (keys == 1.) {\n    \tuv -= 0.5;\n    \tuv *= SCALE;\n    \tuv += 0.5;\n    }*/\n    float s = get(0,0);\n    //col = vec3(c);\n    float d = get(0,1);\n    float u = get(0,-1);\n    float r = get(-1,0);\n    float l = get(1,0);\n    float rd = get(-1,1);\n    float ld = get(1,1);\n    float ru = get(-1,-1);\n    float lu = get(1,-1);\n    float csid = d+u+r+l;\n    //vec2 um = iMouse.xy/iResolution.xy;\n    vec3 pix = texture(iChannel0,uv).rgb;\n    float p = texture(iChannel0,uv).r;\n    //pix = vec3(1.);\n    float hue = 0.;\n    if (l > r) {\n        hue = 0.;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }\n    if (d > u) {\n        hue += 0.15;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    } \n    if (r > l) {\n        hue += 0.12;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }\n    if (u > d) {\n        hue = 0.21;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }\n    /*if (lu > ru) {\n        hue += 0.4;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }\n    if (rd > ld) {\n        hue += 0.2;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }\n    if (ld > rd) {\n        hue += 0.6;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }\n    if (ru > lu) {\n        hue += 0.7;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }*/\n    if (ld > ru) {\n        hue -= 0.22;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }\n    if (rd > lu) {\n        hue -= 0.35;\n    \t//pix = hsv2rgb(vec3(0.1,1.,1.));\n    }\n    //hue *= .6;\n    hue += 0.0;\n    //hue += iTime*2.;\n    pix = hsv2rgb(vec3(hue,1.,1.));\n    //pix *= abs(csid);\n    fragColor = vec4(pix,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//const float SCALE = 0.35;\n//const float SCALE = 0.25;\nconst int KEY_S = 83; \n\n\nfloat get(int x, int y) {\n    vec2 co = (gl_FragCoord.xy + vec2(x, y))/iResolution.xy;\n    float keys = \n        texelFetch( iChannel1, ivec2(KEY_S,2), 0 ).x;\n    /*if (keys == 1.) {\n        co -= 0.5;\n    \tco *= SCALE;\n    \tco += 0.5;\n    }*/\n    return texture(iChannel0, co).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = get(0,0);\n    float d = get(0,1);\n    float u = get(0,-1);\n    float r = get(-1,0);\n    float l = get(1,0);\n    float rd = get(-1,1);\n    float ld = get(1,1);\n    float ru = get(-1,-1);\n    float lu = get(1,-1);\n    float csid = d+u+r+l;\n    vec3 pix = texture(iChannel0,uv).rgb;\n    float p = texture(iChannel0,uv).r;\n    float c = abs(p);\n    float b = 1.;\n    if (p > 0.) {\n        p = 0.;\n    } else {\n        p = 0.715;\n    }\n    //p = abs(p);\n    //p = fract(p);\n    if (c < 100.) {\n    //\tc = 0.;\n    }\n    if (abs(s) > abs(d) && \n        abs(s) > abs(u) && \n        abs(s) > abs(r) && \n        abs(s) > abs(l)) {\n    //if (abs(s) > abs(csid/4.)) {\n  \t\tc = 1.;\n    } else {\n        b *= 0.15;\n    }\n    //p = mod(0.01, p*0.00001);\n    pix = vec3(p,c,b);\n    //pix = vec3(p,c,1.);\n    //vec3 se = texture(iChannel2,uv).rgb;\n    //pix = mix(pix,se,0.99);\n    //pix = hsv2rgb(vec3(p,c*0.05,1.));\n    //pix = hsv2rgb(vec3(p*0.01+iTime*0.05,1.,1.));\n    //pix = hsv2rgb(vec3(p*0.0001,1.,p));\n    //pix = hsv2rgb(vec3(p*0.01,1.,p));\n    //pix *= 1000.;\n    //pix -= 400.;\n    /*if (pix.r > 0.){\n    \tpix = vec3(1.);\n    } else {\n        pix = vec3(0.0);\n    }*/\n    //pix -= vec3(0.5);\n    //pix *= 100.;\n    //pix += vec3(0.5*100.);\n    fragColor = vec4(pix,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//const float SCALE = 0.35;\n//const float SCALE = 0.25;\nconst int KEY_W = 87; \nconst int KEY_S = 83;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int SHIFT = 16;\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat get(int x, int y) {\n    return texture(iChannel0, (gl_FragCoord.xy + vec2(x, y))/iResolution.xy).r;\n}\n         \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 rv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\trv = 2.0 * rv.xy / iResolution.y;\n    vec2 um = iMouse.xy/iResolution.xy;\n    vec2 rm = vec2( iMouse.xy - 0.5*iResolution.xy );\n\trm = 2.0 * rm.xy / iResolution.y;\n    float keys = \n        texelFetch( iChannel1, ivec2(KEY_S,2), 0 ).x;\n    if (keys == 1.) {\n        um -= 0.5;\n    \tum *= SCALE;\n    \tum += 0.5;\n    }\n    uvec2 p = uvec2(fragCoord);\n    float ra = hash1( p.x + 1920U*p.y + (1920U*1080U)*uint(iFrame) );\n    \n    vec3 col = vec3(0.0);\n    \n    float c = get(0,0);\n    //col = vec3(c);\n    float d = get(0,1);\n    float u = get(0,-1);\n    float r = get(-1,0);\n    float l = get(1,0);\n    float rd = get(-1,1);\n    float ld = get(1,1);\n    float ru = get(-1,-1);\n    float lu = get(1,-1);\n    float csid = d+u+r+l;\n    float dsid = (rd/2.)+(ld/2.)+(ru/2.)+(lu/2.);\n    //float dsid = 0.;\n    float sid = d+u+r+l+rd+ld+ru+lu+c;\n    float f = csid+dsid;\n    float sint = sin(iTime);\n    if (sint < 0.) {\n    \tsint = 0.00001;\n    }\n    float qv = 0.;\n    float keyr = \n        texelFetch( iChannel1, ivec2(KEY_R,1), 0 ).x;\n    if (keyr == 1.) {\n    \tqv = 10.1;\n        //qv = 0.00001;\n    }\n    if (iFrame % 2 == 0) {\n    \tqv = 100000./(iTime*iTime);\n    }\n    //float qv = 111.1/(iTime*iTime*iTime);\n    //float qv = 10000./(iTime*11111011110.);\n    //float qv = abs(sin(iTime*0.5)*1000.);\n    float dv = 6.99;\n    float amnt = 1111110.;\n    float shift = \n        texelFetch( iChannel1, ivec2(SHIFT,0), 0 ).x;\n    float keyw = \n        texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x;\n    float keyq = \n        texelFetch( iChannel1, ivec2(KEY_Q,2), 0 ).x;\n    float sped = iTime*4.;\n    vec2 mv = vec2(sin(sped),cos(sped));\n    if (keyq == 1.) {\n        col += c;\n        if (distance(rv,rm) < 0.01 && \n            iMouse.z > 0.) {\n            //col += vec3(uv.x-0.5)*11.;\n            //col += vec3(100.*sin(iTime*1.));\n            if (shift == 1.) {\n                col += vec3(-amnt);\n            } else {\n                col += vec3(amnt);\n            }\n        }\n    \tfragColor = vec4(col,1.);\n        return;\n    }\n    col = vec3(csid+dsid+c+((ra-0.5)*qv))/dv;\n\tmv *= 0.05;\n    mv += 0.5;\n\trv += 0.5;\n    rm += 0.5;\n    if (distance(rv,rm) < 0.02 && \n        iMouse.z > 0. && \n        keyw != 1.  ) {\n        if (shift == 1.) {\n        \tcol += vec3(-amnt);\n        } else {\n        \tcol += vec3(amnt);\n        }\n    } else if (distance(rv,mv) < 0.01) {\n        //col += vec3(amnt*sin(sped*0.5));\n        //col += vec3(amnt*sin(sped*0.5)*0.01*iTime);\n    } else if (keyw == 1.) {\n        if ((distance(rv,rm) < 0.31  ) \n            && iMouse.z > 0.) {\n            col *= 0.5185;\n        }\n    } \n\n    if (iFrame < 10) {\n    \tcol = vec3(0.0);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float SCALE = 0.4725;\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n","name":"Common","description":"","type":"common"}]}