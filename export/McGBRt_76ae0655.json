{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define TWOPI 6.2831\n\n\nfloat interval(float semition) {\n    return pow(2., semition / 12.);\n}\n\n\nvec2 soundX(float c, float t){\n    vec2 sound1 =vec2(0.)\n    \n    return sound1+vec2(sin(TWOPI * 440. * interval(c) * (t + 3.)) * exp(5. * t));\n    \n}\n\nvec2 mainSound(int samp, float time) {\n    // 设定交替的周期时间（例如 0.5秒，表示每0.5秒切换一次）\n    float period = 0.5;  \n    \n    // 每0.5秒的周期\n    float t = mod(time, period);  // 用mod将时间限制在周期内\n\n    // 用于创建两个不同声音的频率和衰减\n    //vec2 sound1 = vec2(sin(TWOPI * 440. * interval(i.) * (t + 3.)) * exp(5. * t));\n    vec2 sound2 = vec2(sin(TWOPI * 440. * interval(-22.) * (t + period * 0.5)) * exp(.1 * t));\n\n    vec2 flow = vec2(0.);\n\n    // 根据时间来交替选择声音信号\n    if (mod(floor(time / period), 2.0) < 1.0) {\n        for(int i = 0; i<=7; i++){\n            flow += sound1(float(i));  // 每个周期前半段播放 sound1\n        }\n        \n    } else {\n        flow += sound2;  // 每个周期后半段播放 sound2\n    }\n\n    return flow;\n}\n","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McGBRt","date":"1734336251","viewed":60,"name":"C调自然音阶","username":"yumi","description":"C","likes":1,"published":1,"flags":8,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""}}