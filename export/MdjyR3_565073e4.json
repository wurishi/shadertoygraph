{"ver":"0.1","info":{"id":"MdjyR3","date":"1493142338","viewed":105,"name":"Final Practice Shader","username":"hamiltonaaronw","description":"Sphere rotates in ellipse in front of a rippled checkerboard background, revealing a scene within a specific radius inside the sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ripples","checkerboard","reveal","rotatingsphere","kernels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// rotating sphere ----------------------------------------------------\n// size and brightness of sphere\nfloat sphereScale = 0.7;\nfloat sphereShine = 0.5;\n\n// sets diffuse, specular and initial specular point position\nvec3 sphereDiff = vec3(0.5, 0.0, .05);\nvec3 sphereSpec = vec3(1.0, 1.0, 1.0);\nvec2 specPoint = vec2(0.2, -0.1);\nvec2 specPoint2 = vec2(0.2, -0.1);\n// end rotating sphere -------------------------------------------------------------\n\n\n// checkerboard ----------------------------------------------------------------\nfloat board(vec2 uv)\n{\n \tuv = floor(uv * 2.0);\n    \n    return mod(uv.x + uv.y, 2.0);\n}\n// end checkerboard ---------------------------------------------------------------\n\n// reveal ------------------------------------------------\n// kernels\nmat3 blur = mat3(\n    0.111, 0.111, 0.111,\n    0.111, 0.111, 0.111,\n    0.111, 0.111, 0.111\n    );\n\nmat3 sharpen = mat3 (\n    0.0, -1.0, 0.0,\n    -1.0, 5.0, -1.0,\n    0.0, -1.0, 0.0\n    );\n\nmat3 edge = mat3 (\n    -1.0, -1.0, -1.0,\n    -1.0, 8.0, -1.0,\n    -1.0, -1.0, -1.0\n    );\n\nmat3 gaussBlur = mat3 ((1.0 / 16.0) * (\n    1.0, 2.0, 1.0,\n    2.0, 4.0, 2.0, \n    1.0, 2.0, 1.0\n    ));\n\nvec3 sample0(const int x, const int y, in vec2 fragCoord)\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;    \n    uv = (uv + vec2(x, y)) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv).xyz;\n}\n\nvec3 filter0(in vec2 fragCoord, mat3 kernel)\n{\n    vec3 sum = sample0(-1, -1, fragCoord) * kernel[0][0]\n        + sample0(-1, 0, fragCoord) * kernel[0][1]\n        + sample0(-1, 1, fragCoord) * kernel[0][2]\n        + sample0(0, -1, fragCoord) * kernel[1][0]\n        + sample0(0, 0, fragCoord) * kernel[1][1]\n        + sample0(0, 1, fragCoord) * kernel[1][2]\n        + sample0(1, -1, fragCoord) * kernel[2][0]\n        + sample0(1, 0, fragCoord) * kernel[2][1]\n        + sample0(1, 1, fragCoord) * kernel[2][2];\n    \n    return sum;\n}\n\nuniform vec2 mouse;\nfloat revealRadius = 0.5;\nvec2 center;\n\n// end reveal -------------------------------------------------------------\n\n// ripples -----------------------------------------------------------------\n\nvec2 rippleCenter = vec2(0.5, 0.5);\nfloat rippleSpeed = 0.035;\n\n// end ripples -------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //ripples\n    float invAr = iResolution.y / iResolution.x;\n    vec3 rippleColor = vec4(uv, 0.5 + 0.5*sin(iTime), 1.0).xyz;\n    vec3 texColor;\n    \n    float rippleX = (rippleCenter.x - uv.x);\n    float rippleY = (center.y - uv.y) * invAr;\n    \n    float rippleR = -((rippleX * rippleX) + (rippleY * rippleY));\n    float rippleZ = 1.0 + 0.5 * sin((rippleR + iTime*rippleSpeed) / 0.013);\n    // end ripples\n  \t  \n    vec3 checkerBoard = vec3(board(uv));\n    \n    checkerBoard.x = rippleZ;\n    checkerBoard.y = rippleZ;  \n    \n    // declarting kernel variables\n    vec2 fc = fragCoord.xy;\n    vec3 cfBlur = filter0(fc, blur);\n    vec3 cfSharp = filter0(fc, sharpen);\n    vec3 cfEdge = filter0(fc, edge);\n    vec3 cfGauss = filter0(fc, gaussBlur);\n    \n    // layers\n    vec4 midLayer0 = vec4(cfBlur, 0.7);\n    vec4 midLayer1 = vec4(cfSharp, 0.7);\n    vec4 midLayer2 = vec4(cfEdge, 0.7);\n    vec4 midLayer3 = vec4(cfGauss, 0.7);\n    \n    // shader pixel coordinates\n    vec2 p = uv * 2.3 - 1.0;\n    vec2 p2 = uv * 2.3 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    p2.x *= iResolution.x / iResolution.y;\n    \n    // rotates sphere in an ellipse\n//    p.x += cos(-iTime) * 0.75;\n//    p.y += -sin(-iTime) * 0.35;\n    \n    float a = atan(p.y, p.x);\n    \n    // rotates sphere in a figure-8\n    p.x += cos(a * 0.5) * cos(iTime) * 0.75;\n    p.y -= sin(a * 0.5);\n    p2.x = 2.0 * p.x;\n    p2.y = p.y;\n    //p.x += cos(iTime) * cos(-a * 0.5) * 0.75;\n    //p.y += sin(iTime) * sin(-a * 0.25) * 0.35;\n    \n    // rotates specular point with the sphere\n    //specPoint.x += cos(-iTime) * 0.35;\n    //specPoint.y += sin(-iTime) * 0.35;\n    specPoint.x += cos(iTime) * cos(a * 0.5) * 0.75;\n    specPoint.y += sin(iTime) * sin(a * 0.25) * 0.35;\n    specPoint2.x = 2.0 * specPoint.x;\n    specPoint2.y = specPoint.y;\n    \n    \n    // set radius of sphere to middle of screen\n    float radius = sqrt(dot(p, p));\n    float radius2 = sqrt(dot(p2, p2));\n    \n    // checkerboard\n    vec3 col = checkerBoard;\n    vec3 sphere2;\n    \n    // set initial dark shadow around edge of sphere\n    float f = smoothstep(sphereScale * 0.9, sphereScale, length(p + specPoint));\n    col -= mix(col, vec3(0.0), f) * 0.2;\n    float f2 = smoothstep(sphereScale * 0.9, sphereScale, length(p2 + specPoint2));\n    sphere2 -= mix(sphere2, vec3(0.0), f2) * 0.2;\n    \n    // only carries out logic if radius is less than the scale\n    if (radius < sphereScale) {\n     \tvec3 bg = col;\n     \n       // set diffuse of sphere\n        col = sphereDiff;\n        sphere2 = sphereDiff;\n        \n        // adds smooth dark borders\n        f = smoothstep(sphereScale * 0.7, sphereScale, radius);\n        col = mix(col, sphereDiff * 0.45, f);\n        f2 = smoothstep(sphereScale * 0.7, sphereScale, radius2);\n        sphere2 = mix(sphere2, sphereDiff * 0.45, f2);\n        \n        // adds specular glow\n        f = 1.0 - smoothstep(-0.2, 0.6, length(p - specPoint));\n        col += f * sphereShine * sphereSpec;\n        f2 = 1.0 - smoothstep(-0.2, 0.6, length(p2 - specPoint2));\n        sphere2 += f2 * sphereShine * sphereSpec;\n        \n        // smoothes edge of sphere\n        f = smoothstep(sphereScale - 0.01, sphereScale, radius);\n        col = mix(col, bg, f);\n       \tf2 = smoothstep(sphereScale - 0.1, sphereScale, radius2);\n        sphere2 = mix(sphere2, bg, f2);\n    }\n    \n    vec4 bgLayer = vec4(col + sphere2, 1.0);\n    \n    if (radius > revealRadius)\n        fragColor = bgLayer;\n    else {\n        fragColor = mix(bgLayer, midLayer2, 0.5);\n\n    }\n}","name":"Image","description":"","type":"image"}]}