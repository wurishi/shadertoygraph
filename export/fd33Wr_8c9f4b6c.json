{"ver":"0.1","info":{"id":"fd33Wr","date":"1629485723","viewed":924,"name":"Atmosphere with absorption lut","username":"lowellcamp","description":"An implementation of Bruneton et al's Precomputed Atmospheric Scattering (single scattering).\nThe main advantage of this method is that it allows you to integrate absorption with arbitrary density functions, and cache the result.","likes":23,"published":1,"flags":32,"usePreview":1,"tags":["atmosphere","lut","precomputed","neyret","bruneton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sqr2 1.41421356237\n// Krzysztof Narkowicz's approximate ACES tonemap\nvec3 ACES(vec3 v) {\n   v *= 0.6;\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n#define VIEW 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if VIEW == 1\n        // View from the surface (1km elevation)\n        vec2 uv = (fragCoord / iResolution.xy) - .5;\n        vec3 X = vec3(0., 1., 0.);\n        float sinX = sin((uv.x + 0.25) * PI * 2.);\n        float cosX = cos((uv.x + 0.25) * PI * 2.);\n        float cosY = cos(uv.y * PI);\n        vec3 V = vec3(sinX * cosY, sin(uv.y * PI), cosX * cosY);\n    #elif VIEW == 2\n        // View from space (full planet)\n        vec2 uv = fragCoord/iResolution.x - vec2(.5, .5 * iResolution.y / iResolution.x);\n        vec3 X = vec3(0, -A_r, 4.0 * A_R);\n        vec3 V = normalize(vec3(uv.yx, -1.));\n    #elif VIEW == 3\n        // View from space (close orbit)\n        vec2 uv = fragCoord/iResolution.x - vec2(.5, .5 * iResolution.y / iResolution.x);\n        vec3 X = vec3(0, 0.8 * (A_R - A_r), 0.3 * A_r);\n        vec3 V = normalize(vec3(uv, -1.));\n    #elif VIEW == 4\n        // View from space (close orbit)\n        vec2 uv = fragCoord/iResolution.x - vec2(.5, .5 * iResolution.y / iResolution.x);\n        vec3 X = vec3(-0.3 * A_r, 0.8 * (A_R - A_r), 0.);\n        vec3 V = normalize(vec3(1., uv.y, -uv.x));\n    #endif\n    \n    vec3 S = vec3(0, -sin((iTime - 10.5) * 0.25), cos((iTime - 10.5) * 0.25));\n    \n    float mu;\n    float mu_s;\n    float r;\n    bool intersects_ground;\n    float d;\n    float sunMu;\n    float nu;\n    bool hit = getIntersectionInfo(X, V, S, mu, mu_s, r, intersects_ground, d, nu);\n    \n    vec3 t = vec3(0.);\n    \n    if (hit) {\n        float jitter = texture(iChannel1, uv).r;\n        vec3 rayleigh;\n        vec3 mie;\n        calcSingleScattering(r, mu, mu_s, d, nu, intersects_ground, iChannel0, iResolution.xy, jitter, rayleigh, mie);\n        rayleigh *= RayleighPhaseFunction(nu);\n        mie *= MiePhaseFunction(0.7, nu);\n        t = (rayleigh + mie) * 50.;\n        //t = vec3(jitter);\n        // Uncomment to see transmittance applied to the globe\n        //t = getTransmittance(mu, r, d, intersects_ground, iChannel0, iResolution.xy);\n    }\n    \n    fragColor = vec4(ACES(t), 1.);\n    // Uncomment to see the raw transmittance LUT\n    //fragColor = vec4(texture(iChannel0, fragCoord / iResolution.xy).xyz, 1.);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float r;\n    float mu;\n    uv2muR(uv, mu, r, iResolution.xy);\n    fragColor = vec4(calcTransmittanceToAtmTop(mu, r), 1);   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Based on https://hal.inria.fr/inria-00288758/document\n// Reference implementation github:\n// https://github.com/ebruneton/precomputed_atmospheric_scattering\n// Absorption implementation used as base:\n// https://www.shadertoy.com/view/fls3Dr\n\n#define PLANET_SIZE 6371.\n#define ATMOSPHERE_THICKNESS 32.\n#define LUT_SAMPLES 16\n#define SCATTER_SAMPLES 24\n#define PI 3.14159265359\n\nconst float A_r = PLANET_SIZE; // Atmosphere bottom radius\nconst float A_R = PLANET_SIZE + ATMOSPHERE_THICKNESS; // Atmosphere top radius\n\nconst float length_unit_in_meters = 1000.; // Kilometer\n\nconst float density = 100. * 10e-6; // 100 times denser than earth atmosphere\n\nconst float rayleigh_scale_height = 1. * 8000.0;\nconst float mie_scale_height      = 1. * 1200.0;\nconst float ozone_scale_height    = 1. * 15000.;\nconst float ozone_height          = 1. * 25000.;\n\nconst float sun_angular_radius = 0.05;\n\n// Scattering, Absorption and Extinction coefficients //\n\n// Rayleigh\nconst vec3 ray_s = vec3(5.802, 13.558, 33.1) * density;\nconst vec3 ray_a = vec3(0.);\nconst vec3 ray_e = ray_s + ray_a;\n\n// Mie\nconst vec3 mie_s = vec3(3.996) * density;\nconst vec3 mie_a = vec3(1., 2., 4.4) * density;\nconst vec3 mie_e = mie_s + mie_a;\n\n// Ozone\nconst vec3 ozo_s = vec3(0.);\nconst vec3 ozo_a = vec3(0.65, 1.881, 0.085) * density;\nconst vec3 ozo_e = ozo_s + ozo_a;\n\nstruct DensityProfileLayer {\n  float width;\n  float exp_term;\n  float exp_scale;\n  float linear_term;\n  float constant_term;\n};\n\nstruct DensityProfile {\n    DensityProfileLayer layers[2];\n};\n\n\nconst DensityProfile rayleigh_density = DensityProfile(\n    DensityProfileLayer[](\n        DensityProfileLayer(0.0,0.0,0.0,0.0,0.0),\n        DensityProfileLayer(\n            0.,\n            1.,\n            -length_unit_in_meters / rayleigh_scale_height,\n            0.,\n            0.\n        )\n    )\n);\n\nconst DensityProfile mie_density = DensityProfile(\n    DensityProfileLayer[](\n        DensityProfileLayer(0.0,0.0,0.0,0.0,0.0),\n        DensityProfileLayer(\n            0.,\n            1.,\n            -length_unit_in_meters / mie_scale_height,\n            0.,\n            0.\n        )\n    )\n);\n\nconst DensityProfile absorption_density = DensityProfile(\n    DensityProfileLayer[](\n        DensityProfileLayer(\n            ozone_height / length_unit_in_meters,\n            0.,\n            0.,\n            length_unit_in_meters / ozone_scale_height,\n            -2. / 3.),\n        DensityProfileLayer(\n            0.,\n            0.,\n            0.,\n            -length_unit_in_meters / ozone_scale_height,\n            8. / 3.)\n    )\n);\n\nfloat clampCosine(float mu) {\n  return clamp(mu, -1.0, 1.0);\n}\n\nfloat clampDistance(float d) {\n  return max(d, 0.0);\n}\n\nfloat clampRadius(float r) {\n  return clamp(r, A_r, A_R);\n}\n\nfloat safeSqrt(float a) {\n  return sqrt(max(a, 0.0));\n}\n\nfloat distToExitAtmosphere(float mu, float r) {\n    float discriminant = r * r * (mu * mu - 1.0) + A_R * A_R;\n    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);\n}\n\nfloat distToEnterPlanet(float mu, float r) {\n    float discriminant = r * r * (mu * mu - 1.0) + A_r * A_r;\n    return max(-r * mu - sqrt(max(discriminant, 0.)), 0.);\n}\n\nfloat distToExitPlanet(float mu, float r) {\n    float discriminant = r * r * (mu * mu - 1.0) + A_r * A_r;\n    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);\n}\n\nfloat unitRange2texCoord(float x, float tex_size) {\n    return .5 / tex_size + x * (1. - 1. / tex_size);\n}\n\nfloat texCoord2unitRange(float u, float tex_size) {\n    return (u - .5 / tex_size) / (1. - 1. / tex_size);\n}\n\n\nfloat getLayerDensity(const DensityProfileLayer layer, float h) {\n    float density = (\n        layer.exp_term * exp(layer.exp_scale * h) +\n        layer.linear_term * h + layer.constant_term);\n       return clamp(density, 0., 1.);\n}\n\nfloat getProfileDensity(const DensityProfile profile, float h) {\n    return h < profile.layers[0].width ?\n        getLayerDensity(profile.layers[0], h) :\n        getLayerDensity(profile.layers[1], h);\n}\n\nfloat opticalLengthToAtmTop(const DensityProfile profile, float mu, float r) {\n    float dx = distToExitAtmosphere(mu, r) / float(LUT_SAMPLES);\n    float res = 0.;\n    for (int i = 0; i <= LUT_SAMPLES; ++i) {\n        float d_i = float(i) * dx;\n        float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);\n        float y_i = getProfileDensity(profile, r_i - A_r);\n        float w_i = i == 0 || i == LUT_SAMPLES ? 0.5 : 1.0;\n        res += y_i * w_i * dx;\n    }\n    return res;\n}\n\nvec3 calcTransmittanceToAtmTop(float mu, float r) {\n    return exp(-(\n        ray_e *\n        opticalLengthToAtmTop(rayleigh_density, mu, r) +\n        mie_e *\n        opticalLengthToAtmTop(mie_density, mu, r) +\n        ozo_e *\n        opticalLengthToAtmTop(absorption_density, mu, r)\n    ));\n}\n\nvec2 muR2uv(float mu, float r, vec2 tex_size) {\n    float H     = sqrt(A_R * A_R - A_r * A_r);\n    float rho   = sqrt(r * r - A_r * A_r);\n    float d     = distToExitAtmosphere(mu, r);\n    float d_min = A_R - r;\n    float d_max = rho + H;\n    float x_mu  = (d - d_min) / (d_max - d_min);\n    float x_r   = rho / H;\n        \n    return vec2(\n        unitRange2texCoord(x_mu, tex_size.x),\n        unitRange2texCoord(x_r, tex_size.y)\n    );\n}\n\nvoid uv2muR(vec2 uv, out float mu, out float r, vec2 tex_size) {\n    float x_mu  = texCoord2unitRange(uv.x, tex_size.x);\n    float x_r   = texCoord2unitRange(uv.y, tex_size.y);\n    float H     = sqrt(A_R * A_R - A_r * A_r);\n    float rho = H * x_r;\n    r = sqrt(rho * rho + A_r * A_r);\n    float d_min = A_R - r;\n    float d_max = rho + H;\n    float d = d_min + x_mu * (d_max - d_min);\n    mu = d == 0.0 ? 1. : (H * H - rho * rho - d * d) / (2. * r * d);\n    mu = clamp(mu, -1., 1.);\n}\n\nbool getIntersectionInfo(vec3 cameraPos, vec3 viewDir, vec3 sunDir,\n        out float mu,\n        out float mu_s,\n        out float r,\n        out bool intersects_ground,\n        out float d,\n        out float nu\n) {\n    vec3 pos = cameraPos + vec3(0.0, A_r, 0.0);\n    float t_closest = -dot(viewDir, pos);\n    vec3 x_closest = pos + viewDir * t_closest;\n    float d_closest = length(x_closest);\n    \n    if (d_closest > A_R) return false;\n    \n    r = length(pos);\n    bool inside_atmosphere = r < A_R;\n    \n    // Step ray forward to atmosphere border\n    if (!inside_atmosphere && t_closest > 0.0) {\n        float a = sqrt(A_R * A_R - d_closest * d_closest);\n        pos += viewDir * (t_closest - a);\n        r = A_R;\n        intersects_ground = false;\n        d = 2. * a;\n    }\n    mu = dot(pos, viewDir) / r;\n    mu_s = dot(pos, sunDir) / r;\n    nu = dot(viewDir, sunDir);\n    \n    intersects_ground = d_closest < A_r && t_closest > 0.0;\n    \n    if (intersects_ground) {\n        d = distToEnterPlanet(mu, r);\n    } else {\n        d = distToExitAtmosphere(mu, r);\n    }\n    return d > 0.;\n}\n\nvec3 getTransmittanceToAtmTop(float mu, float r, sampler2D lut, vec2 lutRes) {\n    vec2 uv = muR2uv(mu, r, lutRes);\n    return texture(lut, uv).xyz;\n}\n\nvec3 getTransmittance(float mu, float r, float d, bool intersects_ground, sampler2D lut, vec2 lutRes) {\n    float r_d = clamp(sqrt(d * d + 2. * r * mu * d + r * r), A_r, A_R);\n    float mu_d = clamp((r * mu + d) / r_d, -1., 1.);\n        \n    if (intersects_ground) {\n        return min(\n            getTransmittanceToAtmTop(-mu_d, r_d, lut, lutRes) /\n            getTransmittanceToAtmTop(-mu, r, lut, lutRes),\n            vec3(1.)\n        );\n    } else {\n        return min(\n            getTransmittanceToAtmTop(mu, r, lut, lutRes) /\n            getTransmittanceToAtmTop(mu_d, r_d, lut, lutRes),\n            vec3(1.)\n        );\n    }\n}\n\nvec3 getTransmittanceToSun(float r, float mu_sun, sampler2D lut, vec2 lutRes) {\n    float sin_theta_h = A_r / r;\n    float cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));\n    \n    float sunVisibility = smoothstep(-sin_theta_h * sun_angular_radius, sin_theta_h * sun_angular_radius, mu_sun - cos_theta_h);\n    \n    return sunVisibility * getTransmittanceToAtmTop(mu_sun, r, lut, lutRes);\n      \n}\n\nvoid calcLuminanceIntegrand(float r, float mu, float mu_s, float nu, float d, bool intersects_ground, \n    sampler2D lut, vec2 lutRes,\n    out vec3 rayleigh,\n    out vec3 mie\n) {\n    float r_d = clampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));\n    float mu_s_d = clampCosine((r * mu_s + d * nu) / r_d);\n    \n    vec3 transmittance = getTransmittance(mu, r, d, intersects_ground, lut, lutRes) * getTransmittanceToSun(r_d, mu_s_d, lut, lutRes);\n    rayleigh = transmittance * getProfileDensity(rayleigh_density, r_d - A_r);\n    mie = transmittance * getProfileDensity(mie_density, r_d - A_r);\n}\n\nvoid calcSingleScattering(float r, float mu, float mu_s, float d, float nu, bool intersects_ground, sampler2D lut, vec2 lutRes, float jitter,\n        out vec3 rayleigh,\n        out vec3 mie\n) {\n    float dx = d / float(SCATTER_SAMPLES);\n    vec3 rayleigh_sum = vec3(0.);\n    vec3 mie_sum = vec3(0.);\n    \n    for (int i = 0; i < SCATTER_SAMPLES; i++) {\n        float d_i = (float(i) + jitter) * dx;\n        vec3 rayleigh_i;\n        vec3 mie_i;\n        calcLuminanceIntegrand(r, mu, mu_s, nu, d_i, intersects_ground, lut, lutRes, rayleigh_i, mie_i);\n        // Sample weight (from the trapezoidal rule).\n        float weight_i = (i == 0 || i == SCATTER_SAMPLES) ? 0.5 : 1.0;\n        rayleigh_sum += rayleigh_i * weight_i;\n        mie_sum += mie_i * weight_i;\n    }\n    rayleigh = rayleigh_sum * dx * ray_s;\n    mie = mie_sum * dx * mie_s;\n    //rayleigh = vec3(dx / A_R);\n    //mie = vec3(dx / A_R);\n}\n\nfloat RayleighPhaseFunction(float nu) {\n    //return .125;\n  float k = 3.0 / (16.0 * PI);\n  return k * (1.0 + nu * nu);\n}\n\nfloat MiePhaseFunction(float g, float nu) {\n  float k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);\n  return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);\n}","name":"Common","description":"","type":"common"}]}