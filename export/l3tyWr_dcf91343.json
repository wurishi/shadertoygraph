{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//===========================================================\n// Final Image Composition\n//===========================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    vec2 R = iResolution.xy;\n    vec2 worldPos = (2.0 * fragCoord - R) / R.y;\n\n    const float BASE_RADIUS = 0.05;\n    float baseRadius = BASE_RADIUS;\n    float maxRadius = baseRadius * 2.0;\n    const float PI = 3.14159265359;\n    float fillPercentage = 0.80;\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 bounds = vec2(aspect, 1.0);\n   \n    float area = bounds.x * 2.0 * bounds.y * 2.0;\n    float particleArea = PI * maxRadius * maxRadius;\n    int MAX_PARTICLES = int(floor((area / particleArea) * fillPercentage));\n  \n    float pixelWidth = 3.0 / iResolution.y;\n    float centerRadius = 0.01;\n    \n    float oscillation = 0.5 + 0.5 * sin(iTime);\n    float size = mix(baseRadius * 0.5, baseRadius * 2.0, oscillation);\n\n    for(int index = 0; index < MAX_PARTICLES; index++){\n        ivec2 pixel = ivec2(index % 18, index / 18);\n        vec4 posVel = texelFetch(iChannel0, pixel, 0);\n        vec4 colorData = texelFetch(iChannel2, pixel, 0);\n        vec2 pos = posVel.xy;\n        \n        float attractionRadius = size * 2.0;\n        float d = length(worldPos - pos);\n\n        vec3 attractionCircleColor = vec3(0.9, 0.9, 0.9);\n        float attractionCircle = smoothstep(attractionRadius + pixelWidth, attractionRadius, d);\n        color = mix(color, attractionCircleColor, attractionCircle * 0.2);\n            \n        float circle = smoothstep(size + pixelWidth, size, d);\n        vec3 particleColor = colorData.rgb;\n            \n        float point = smoothstep(centerRadius, centerRadius - pixelWidth, d);\n\n        color = mix(color, particleColor, circle);\n        color = mix(color, vec3(0.0), point);\n    }\n\n    ivec2 I = ivec2(fragCoord);\n    float voronoiId = texelFetch(iChannel1, I, 0).x;\n    \n    #define T(i, j) texelFetch(iChannel1, ivec2(fragCoord + vec2(i, j)), 0).x\n    \n    if(I.x > 0 && I.y > 0 && I.x < int(iResolution.x) - 1 && I.y < int(iResolution.y) - 1) {\n        float voronoiLeftId = T(-1, 0);\n        float voronoiRightId = T(1, 0);\n        float voronoiUpId = T(0, -1);\n        float voronoiDownId = T(0, 1);\n    \n        if(voronoiId != voronoiLeftId || voronoiId != voronoiRightId ||\n           voronoiId != voronoiUpId || voronoiId != voronoiDownId) {\n            color = mix(color, vec3(1.0), 0.8);\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//===========================================================\n// Buffer A: Particle State\n//===========================================================\n\n// The simple hash function used for initializing positions.\nfloat hash(float n) { \n    return fract(sin(n) * 43758.5453123); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 pixel = ivec2(fragCoord);\n    float aspect = iResolution.x / iResolution.y;\n    vec2 bounds = vec2(aspect, 1.0);\n    const float BASE_RADIUS = 0.05;\n    float maxRadius = BASE_RADIUS * 2.0;\n    const float PI = 3.14159265359;\n    float fillPercentage = 0.80;\n    float area = bounds.x * 2.0 * bounds.y * 2.0;\n    float particleArea = PI * maxRadius * maxRadius;\n    int MAX_PARTICLES = int(floor((area / particleArea) * fillPercentage));\n    \n    int index = pixel.y * 18 + pixel.x;\n    \n    if(index < MAX_PARTICLES) {\n        vec2 pos;\n        \n        if(iFrame == 0) {\n            float seed = float(index);\n            pos = vec2(\n                (hash(seed) * 2.0 - 1.0) * bounds.x,\n                (hash(seed + 1.0) * 2.0 - 1.0)\n            );\n        } else {\n            vec4 prevState = texelFetch(iChannel0, pixel, 0);\n            pos = prevState.xy;\n        }\n        \n        float offset = float(index) * 0.7853;\n        float oscillation = 0.5 + 0.5 * sin(iTime * 2.0 + offset);\n        float radius = mix(BASE_RADIUS * 0.5, BASE_RADIUS * 2.0, oscillation);\n        \n        vec2 newPos = pos;\n        bool hasInteraction = false;\n        \n        for(int otherIndex = 0; otherIndex < MAX_PARTICLES; otherIndex++) {\n            if(otherIndex == index) continue;\n            \n            vec4 otherState = texelFetch(iChannel0, ivec2(otherIndex % 18, otherIndex / 18), 0);\n            vec2 otherPos = otherState.xy;\n            float otherOffset = float(otherIndex) * 0.7853;\n            float otherOscillation = 0.5 + 0.5 * sin(iTime * 2.0 + otherOffset);\n            float otherRadius = mix(BASE_RADIUS * 0.5, BASE_RADIUS * 2.0, otherOscillation);\n            \n            float dist = distance(pos, otherPos);\n            float interactionRange = (radius + otherRadius) * 3.0;\n            \n            if(dist < interactionRange) {\n                hasInteraction = true;\n                vec2 dir = normalize(pos - otherPos);\n                float desiredDist = radius + otherRadius;\n                \n                if(dist < desiredDist) {\n                    newPos += dir * (desiredDist - dist) * 0.5;\n                } else if(oscillation < 0.5 && dist < interactionRange) {\n                    newPos -= dir * 0.01;\n                }\n            }\n        }\n        \n        pos = hasInteraction ? newPos : pos;\n        \n        // Apply periodic boundaries\n        if(pos.x < -bounds.x) pos.x += bounds.x * 2.0;\n        if(pos.x >  bounds.x) pos.x -= bounds.x * 2.0;\n        if(pos.y < -bounds.y) pos.y += bounds.y * 2.0;\n        if(pos.y >  bounds.y) pos.y -= bounds.y * 2.0;\n        \n        fragColor = vec4(pos, 0.0, 0.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//===========================================================\n// Buffer B: Distance Field\n//===========================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 worldPos = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    const float BASE_RADIUS = 0.05;\n    float maxRadius = BASE_RADIUS * 2.0;\n    const float PI = 3.14159265359;\n    float fillPercentage = 0.60;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 bounds = vec2(aspect, 1.0);\n    float area = bounds.x * 2.0 * bounds.y * 2.0;\n    float particleArea = PI * maxRadius * maxRadius;\n    int MAX_PARTICLES = int(floor((area / particleArea) * fillPercentage));\n\n    float minDist = 1000.0;\n    int minIndex = -1;\n\n    // Start from index 1 to skip the problematic first particle position\n    for(int y = 0; y < 18; y++) {\n        for(int x = 0; x < 18; x++) {\n            int index = y * 18 + x;\n            if(index == 0) continue;  // Skip index 0 explicitly\n            if(index >= MAX_PARTICLES) continue;\n            \n            vec4 data = texelFetch(iChannel0, ivec2(x, y), 0);\n            if(length(data.xy) > 0.0) {  // Only consider non-zero positions\n                float d = distance(worldPos, data.xy);\n                if(d < minDist) {\n                    minDist = d;\n                    minIndex = index;\n                }\n            }\n        }\n    }\n    \n    // If no valid particle found, use a special value\n    if(minIndex == -1) {\n        fragColor = vec4(-1.0, 0.0, 0.0, 1.0);  // Indicates no particle was found\n    } else {\n        fragColor = vec4(float(minIndex) / float(MAX_PARTICLES), 0.0, 0.0, 1.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//===========================================================\n// Buffer C: Color Storage (Synchronized)\n//===========================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 pixel = ivec2(fragCoord);\n    const int PARTICLE_GRID_SIZE = 18;\n    \n    if(pixel.x < PARTICLE_GRID_SIZE && pixel.y < PARTICLE_GRID_SIZE) {\n        vec3 flashyOrange = vec3(1.0, 0.5, 0.0); // Flashy orange color\n        fragColor = vec4(flashyOrange, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"l3tyWr","date":"1734970477","viewed":165,"name":"Voro Boro Fire Balls","username":"Chimel","description":"Particles have an oscillation in size, and a pull force when they shrink vs push when they expand.","likes":9,"published":3,"flags":32,"usePreview":0,"tags":["voronoi","collision","oscilations"],"hasliked":0,"parentid":"","parentname":""}}