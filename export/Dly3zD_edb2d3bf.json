{"ver":"0.1","info":{"id":"Dly3zD","date":"1683811907","viewed":76,"name":"Earth with atmosphere","username":"martin878","description":"Procedural Earth using Perlin noise\n* Click and drag left mouse button to move sunlight","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float radius = 0.5;\nconst uint seed_snow = 0x578437adU;\nconst uint seed_land = 0x178537adU;\nconst float pi_over_2 = 1.5708; // radians\nbool done_background = false;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sun_angle = (iMouse.x / iResolution.x - 0.5) * 3.0;\n\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.x;\n    \n    // Outer circle\n    float optical_ratio = (uv.x*uv.x + uv.y*uv.y) / (radius*radius);\n    if(optical_ratio > 1.0)\n    {\n        if(!done_background)\n        {\n            // Stars\n            if (hash(uint(fragCoord.x), uint(fragCoord.y)) < 1000000u)\n                fragColor = vec4(1);\n            else\n                fragColor = vec4(0);\n            done_background = true;\n        }\n        return;\n    }\n\n    // Model\n    float latitude = asin(uv.y/radius);\n    float longitude = asin(uv.x/radius/cos(latitude));\n    float incidence = sun_angle - longitude;\n    float cos_incidence = cos(incidence);\n    float irradiance = 0.0;\n    if (cos_incidence > 0.0)\n        irradiance = cos_incidence * cos(latitude);\n    float noise_snow = perlinNoise(uv*4.0+2.0, 1, 6, 0.5, 2.0, seed_snow);\n    float noise_land = perlinNoise(uv*4.0+2.0, 1, 6, 0.5, 2.0, seed_land);\n    vec3 col = vec3(0, 0, 0.4);\n    if (noise_land > 0.0)\n        col = vec3(0, 0.6, 0.4);\n    \n    // Snow\n    if (abs(uv.y) + noise_snow*0.1 > 0.4)\n        col = vec3(1,1,1);\n        \n    // Atmosphere\n    float atmos = optical_ratio*optical_ratio;\n    col *= (1.0-atmos);\n    col += vec3(0,0.8,1) * atmos;\n\n    // Output to screen\n    fragColor = vec4(col*irradiance, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n","name":"Common","description":"","type":"common"}]}