{"ver":"0.1","info":{"id":"Xslyzn","date":"1486732600","viewed":248,"name":"Distance Bounds & Operations","username":"plabatut","description":"Play with signed distance bounds and operations. Click and move the mouse: horizontally for the divider between standard and isolevel rendering, vertically for the plane. A choice of distance bounds is available at the stop of the code (SDF macro).","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO: Add missing primitive(s): capped cone\n\n#define SDF_SPHERE              0\n#define SDF_BOX                 1\n#define SDF_ROUND_BOX           2\n\n#define SDF_TETRAHEDRON         3\n#define SDF_CUBE                4\n#define SDF_OCTAHEDRON          5\n#define SDF_DODECAHEDRON        6\n#define SDF_ICOSAHEDRON         7\n\n#define SDF_TORUS               8\n#define SDF_CYLINDER            9\n#define SDF_CONE                10\n#define SDF_ELLIPSOID           11\n\n#define SDF_CAPPED_CYLINDER     12\n#define SDF_CAPPED_CONE         13 // TODO\n#define SDF_CAPSULE             14\n\n#define SDF_TORUS_8_2           15 // FIXME: Shadow\n#define SDF_TORUS_8_8           16 // FIXME: Shadow\n\n#define SDF_UNION               17\n#define SDF_INTERSECTION        18\n#define SDF_DIFFERENCE          19\n#define SDF_SMOOTH_UNION        20\n#define SDF_SMOOTH_INTERSECTION 21\n#define SDF_SMOOTH_DIFFERENCE   22\n\n#define SDF_UNION_CAPSULES      23\n#define SDF_PIPE_CYLINDERS      24\n\n#define SDF_POLAR_CYLINDERS     25\n#define SDF_TRIANGULAR_CYLINDER 26\n#define SDF_HEXAGONAL_CYLINDER  27\n\n#define SDF_DISPLACEMENT        28\n#define SDF_TWIST               29\n#define SDF_BEND                30\n#define SDF_BOX_MINUS_CYLINDERS 31\n\n#define SDF_STAR                32\n\n\n#define SDF SDF_BOX_MINUS_CYLINDERS\n\n\nconst float Pi = 3.14159265358;\nconst int MaxNumSteps = 256;\nconst float MaxT = 1024.0;\nconst float Epsilon = 0.001;\nconst int MaxNumSamples = 4;\n\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\n\nfloat vmin(vec3 v) {\n    return min(v.x, min(v.y, v.z));\n}\n\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\n\nfloat length8(vec2 v) {\n    float x = v.x;\n    float y = v.y;\n\n    float x2 = x * x;\n    float y2 = y * y;\n\n    float x4 = x2 * x2;\n    float y4 = y2 * y2;\n\n    float x8 = x4 * x4;\n    float y8 = y4 * y4;\n\n    return sqrt(sqrt(sqrt(sqrt(x8 + y8))));\n}\n\n\nfloat length8(vec3 v) {\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n\n    float x4 = x2 * x2;\n    float y4 = y2 * y2;\n    float z4 = z2 * z2;\n\n    float x8 = x4 * x4;\n    float y8 = y4 * y4;\n    float z8 = z4 * z4;\n\n    return pow(x8 + y8 + z8, 0.0625);\n}\n\n\n// See: https://en.wikipedia.org/wiki/Platonic_solid#Cartesian_coordinates\n\nconst float Phi = 0.5 * (1.0 + sqrt(5.0));\n\n// See: Generalized Distance Functions, Akleman and Chen, 1999\nconst vec3 gdfN01 = vec3(1.0, 0.0, 0.0);\nconst vec3 gdfN02 = vec3(0.0, 1.0, 0.0);\nconst vec3 gdfN03 = vec3(0.0, 0.0, 1.0);\n\nconst vec3 gdfN04 = normalize(vec3( 1.0,  1.0,  1.0));\nconst vec3 gdfN05 = normalize(vec3(-1.0,  1.0,  1.0));\nconst vec3 gdfN06 = normalize(vec3( 1.0, -1.0,  1.0));\nconst vec3 gdfN07 = normalize(vec3( 1.0,  1.0, -1.0));\n\n// Phi^2 = Phi + 1\n// (1 / Phi, Phi) ~ (1, Phi + 1)\nconst vec3 gdfN08 = normalize(vec3(       0.0,       1.0, Phi + 1.0));\nconst vec3 gdfN09 = normalize(vec3(       0.0,      -1.0, Phi + 1.0));\nconst vec3 gdfN10 = normalize(vec3( Phi + 1.0,       0.0,       1.0));\nconst vec3 gdfN11 = normalize(vec3(-Phi - 1.0,       0.0,       1.0));\nconst vec3 gdfN12 = normalize(vec3(       1.0, Phi + 1.0,       0.0));\nconst vec3 gdfN13 = normalize(vec3(      -1.0, Phi + 1.0,       0.0));\n\nconst vec3 gdfN14 = normalize(vec3( 0.0,  Phi, 1.0));\nconst vec3 gdfN15 = normalize(vec3( 0.0, -Phi, 1.0));\nconst vec3 gdfN16 = normalize(vec3( 1.0,  0.0, Phi));\nconst vec3 gdfN17 = normalize(vec3(-1.0,  0.0, Phi));\nconst vec3 gdfN18 = normalize(vec3( Phi,  1.0, 0.0));\nconst vec3 gdfN19 = normalize(vec3(-Phi,  1.0, 0.0));\n\n\nfloat sdfTetrahedron(vec3 P, float R) {\n    const vec3 n1 = normalize(vec3( 1.0,  1.0,  1.0));\n    const vec3 n2 = normalize(vec3(-1.0, -1.0,  1.0));\n    const vec3 n3 = normalize(vec3( 1.0, -1.0, -1.0));\n    const vec3 n4 = normalize(vec3(-1.0,  1.0, -1.0));\n\n    R /= sqrt(3.0);\n\n    float d = dot(n1, P) - R;\n    d = max(d, dot(n2, P) - R);\n    d = max(d, dot(n3, P) - R);\n    d = max(d, dot(n4, P) - R);\n\n    return d;\n}\n\n\nfloat sdfCube(vec3 P, float R) {\n    const vec3 n1 = gdfN01;\n    const vec3 n2 = gdfN02;\n    const vec3 n3 = gdfN03;\n\n    float d = abs(dot(n1, P));\n    d = max(d, abs(dot(n2, P)));\n    d = max(d, abs(dot(n3, P)));\n\n    return d - R;\n}\n\n\nfloat sdfOctahedron(vec3 P, float R) {\n    const vec3 n1 = gdfN04;\n    const vec3 n2 = gdfN05;\n    const vec3 n3 = gdfN06;\n    const vec3 n4 = gdfN07;\n\n    float d = abs(dot(n1, P));\n    d = max(d, abs(dot(n2, P)));\n    d = max(d, abs(dot(n3, P)));\n    d = max(d, abs(dot(n4, P)));\n\n    return d - R;\n}\n\n\nfloat sdfDodecahedron(vec3 P, float R) {\n    const vec3 n1 = gdfN14;\n    const vec3 n2 = gdfN15;\n    const vec3 n3 = gdfN16;\n    const vec3 n4 = gdfN17;\n    const vec3 n5 = gdfN18;\n    const vec3 n6 = gdfN19;\n\n    float d = abs(dot(n1, P));\n    d = max(d, abs(dot(n2, P)));\n    d = max(d, abs(dot(n3, P)));\n    d = max(d, abs(dot(n4, P)));\n    d = max(d, abs(dot(n5, P)));\n    d = max(d, abs(dot(n6, P)));\n\n    return d - R;\n}\n\n\nfloat sdfIcosahedron(vec3 P, float R) {\n    const vec3 n1 = gdfN04;\n    const vec3 n2 = gdfN05;\n    const vec3 n3 = gdfN06;\n    const vec3 n4 = gdfN07;\n    const vec3 n5 = gdfN08;\n    const vec3 n6 = gdfN09;\n    const vec3 n7 = gdfN10;\n    const vec3 n8 = gdfN11;\n    const vec3 n9 = gdfN12;\n    const vec3 n10 = gdfN13;\n\n    float d = abs(dot(n1, P));\n    d = max(d, abs(dot(n2, P)));\n    d = max(d, abs(dot(n3, P)));\n    d = max(d, abs(dot(n4, P)));\n    d = max(d, abs(dot(n5, P)));\n    d = max(d, abs(dot(n6, P)));\n    d = max(d, abs(dot(n7, P)));\n    d = max(d, abs(dot(n8, P)));\n    d = max(d, abs(dot(n9, P)));\n    d = max(d, abs(dot(n10, P)));\n\n    return d - R;\n}\n\n\nfloat sdfTorus(vec3 P, float R1, float R2) {\n    vec2 d = vec2(length(P.xy) - R1, P.z);\n    return length(d) - R2;\n}\n\n\nfloat sdfTorus82(vec3 P, float R1, float R2) {\n    vec2 d = vec2(length(P.xy) - R1, P.z);\n    return length8(d) - R2;\n}\n\n\nfloat sdfTorus88(vec3 P, float R1, float R2) {\n    vec2 d = vec2(length8(P.xy) - R1, P.z);\n    return length8(d) - R2;\n}\n\n\nfloat sdfSphere(vec3 P, float R) {\n    return length(P) - R;\n}\n\n\nfloat sdfBox2(vec3 P, vec3 s) {\n    return vmax(abs(P) - s);\n}\n\n\nfloat sdfBox(vec3 P, vec3 s) {\n    vec3 d = abs(P) - s;\n    return length(max(d, 0.0)) + min(vmax(d), 0.0);\n}\n\n\nfloat sdfRoundBox(vec3 P, vec3 s, float R) {\n    return sdfBox(P, s) - R;\n}\n\n\nfloat sdfPlane(vec3 P, vec3 n, float o) {\n    return dot(n, P) - o;\n}\n\n\nfloat sdfEllipsoid(vec3 P, vec3 s) {\n    return vmin(s) * (length(P / s) - 1.0);\n}\n\n\nfloat sdfEllipsoid8(vec3 P, vec3 s) {\n    return vmin(s) * (length8(P / s) - 1.0);\n}\n\n\nfloat sdfCapsule(vec3 P, vec3 P1, vec3 P2, float R) {\n    vec3 u = P - P1;\n    vec3 v = P2 - P1;\n\n    float d = clamp(dot(u, v) / dot(v, v), 0.0, 1.0);\n\n    return length(u - d * v) - R;\n}\n\n\nfloat sdfCylinder(vec3 P, float R) {\n    return length(P.xy) - R;\n}\n\n\nfloat sdfCappedCylinder(vec3 P, float R, float h) {\n    vec2 d = abs(vec2(length(P.xy), P.z)) - vec2(R, h);\n    return min(vmax(d), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat sdfCone(vec3 P, vec2 u) {\n    float d = length(P.xy);\n    return dot(u, vec2(d, P.z));\n}\n\n\nfloat sdfCappedCone(vec3 P, vec2 u, float size) {\n    float d = length(P.xy);\n    return dot(u, vec2(d, P.z));\n}\n\n\nfloat sdfTriangularCylinder(vec3 P, float R) {\n    const float s2 = sqrt(2.0);\n    const float s3 = sqrt(3.0);\n\n    const vec2 n1 = vec2(0.0, 1.0);\n    const vec2 n2 = 0.5 * vec2(-s3, -1.0);\n    const vec2 n3 = 0.5 * vec2( s3, -1.0);\n\n    R /= s3; // FIXME: ?\n\n    float d = dot(n1, P.xy) - R;\n    d = max(d, dot(n2, P.xy) - R);\n    d = max(d, dot(n3, P.xy) - R);\n\n    return d;\n}\n\n\nfloat sdfBoxCylinder(vec3 P, vec2 s) {\n    vec2 d = abs(P.xy) - s;\n    return length(max(d, 0.0)) + min(vmax(d), 0.0);\n}\n\n\nfloat sdfHexagonalCylinder(vec3 P, float R) {\n    const float s3 = sqrt(3.0);\n\n    const vec2 n1 = 0.5 * vec2(1.0, s3);\n    const vec2 n2 = 0.5 * vec2(-1.0, s3);\n    const vec2 n3 = vec2(-1.0, 0.0);\n\n    float d = abs(dot(n1, P.xy));\n    d = max(d, abs(dot(n2, P.xy)));\n    d = max(d, abs(dot(n3, P.xy)));\n\n    return d - R;\n}\n\n\nfloat sdfSmoothMin(float d1, float d2, float f) {\n    float t = clamp(0.5 - 0.5 * (d2 - d1) / f, 0.0, 1.0);\n\n    return mix(d1, d2, t) - f * t * (1.0 - t);\n}\n\n\nfloat sdfSmoothMax(float d1, float d2, float f) {\n    return -sdfSmoothMin(-d1, -d2, f);\n}\n\n\nfloat sdfSmoothDifference(float d1, float d2, float f) {\n  //return sdfSmoothMax(d1, -d2, f);\n    return -sdfSmoothMin(-d1, d2, f);\n}\n\n\nfloat sdfBackground(vec3 P, float p) {\n    return sdfPlane(P, vec3(0.0, 0.0, 1.0), p);\n}\n\n\nvec3 spTwist(vec3 P, float f) {\n    float c = cos(f * P.z);\n    float s = sin(f * P.z);\n\n    mat2 R = mat2(c, -s, s, c);\n\n    return vec3(R * P.xy, P.z);\n}\n\n\nvec3 spBend(vec3 P, float f) {\n    float c = cos(f * P.z);\n    float s = sin(f * P.z);\n\n    mat2 R = mat2(c, -s, s, c);\n\n    return vec3(R * P.xz, P.y);\n}\n\n\nfloat sdfForeground(vec3 P) {\n#if SDF == SDF_SPHERE\n    return sdfSphere(P, 1.0);\n#elif SDF == SDF_BOX\n  //return sdfBox2(P, vec3(0.5, 0.75, 1.0));\n    return sdfBox(P, vec3(0.5, 0.75, 1.0));\n#elif SDF == SDF_ROUND_BOX\n    return sdfRoundBox(P, vec3(0.375, 0.5, 0.75), 0.125);\n#elif SDF == SDF_TETRAHEDRON\n    return sdfTetrahedron(P, 1.0);\n#elif SDF == SDF_CUBE\n    return sdfCube(P, 1.0);\n#elif SDF == SDF_OCTAHEDRON\n    return sdfOctahedron(P, 0.5);\n#elif SDF == SDF_DODECAHEDRON\n    return sdfDodecahedron(P, 0.75);\n#elif SDF == SDF_ICOSAHEDRON\n    return sdfIcosahedron(P, 0.75);\n#elif SDF == SDF_TORUS\n    return sdfTorus(P, 1.0, 1.0 / 2.5);\n#elif SDF == SDF_CYLINDER\n    return sdfCylinder(P, 1.0);\n#elif SDF == SDF_CONE\n    return sdfCone(P, normalize(vec2(1.0, 1.0)));\n#elif SDF == SDF_ELLIPSOID\n    return sdfEllipsoid(P, vec3(1.5, 0.75, 1.0));\n#elif SDF == SDF_CAPPED_CYLINDER\n    return sdfCappedCylinder(P, 0.75, 1.0);\n#elif SDF == SDF_CAPPED_CONE\n    return sdfCappedCone(P, 1.0, 0.25); // TODO\n#elif SDF == SDF_CAPSULE\n    return sdfCapsule(P,\n                      vec3(-1.0, 0.0, 0.0),\n                      vec3( 1.0, 0.0, 0.0),\n                      0.5);\n#elif SDF == SDF_TORUS_8_2\n    return sdfTorus82(P, 1.0, 1.0 / 2.5);\n#elif SDF == SDF_TORUS_8_8\n    return sdfTorus88(P, 1.0, 1.0 / 2.5);\n#elif SDF == SDF_UNION\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return min(d1, d2);\n#elif SDF == SDF_INTERSECTION\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return max(d1, d2);\n#elif SDF == SDF_DIFFERENCE\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return max(d1, -d2);\n#elif SDF == SDF_SMOOTH_UNION\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return sdfSmoothMin(d1, d2, 0.5);\n#elif SDF == SDF_SMOOTH_INTERSECTION\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return sdfSmoothMax(d1, d2, 0.5);\n#elif SDF == SDF_SMOOTH_DIFFERENCE\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return sdfSmoothDifference(d1, d2, 0.5);\n#elif SDF == SDF_UNION_CAPSULES\n    float d1 = sdfCapsule(P,\n                          vec3(-1.0,  0.0,  0.0),\n                          vec3( 1.0,  0.0,  0.0),\n                          0.25);\n    float d2 = sdfCapsule(P,\n                          vec3( 0.0, -1.0,  0.0),\n                          vec3( 0.0,  1.0,  0.0),\n                          0.25);\n    float d3 = sdfCapsule(P,\n                          vec3( 0.0,  0.0, -1.0),\n                          vec3( 0.0,  0.0,  1.0),\n                          0.25);\n    return min(d1, min(d2, d3));\n#elif SDF == SDF_PIPE_CYLINDERS\n    float d1 = sdfCylinder(P, 0.75);\n    float d2 = sdfCylinder(P.yzx - vec3(0.75, 0.0, 0.0), 0.75);\n  //float d3 = sdfCylinder(P.zxy, 0.75);\n\n  //return min(d1, d2);\n    return length(vec2(d1, d2)) - 0.25;\n  //return length(vec3(d1, d2, d3)) - 0.25;\n#elif SDF == SDF_POLAR_CYLINDERS\n    float theta = atan(P.y, P.x);\n    theta = mod(theta + Pi / 6.0, Pi / 3.0) - Pi / 6.0;\n    float r = length(P.xy);\n\n    P.xy = r * vec2(cos(theta), sin(theta));\n\n    return sdfCylinder(P.yzx, 0.5);\n#elif SDF == SDF_TRIANGULAR_CYLINDER\n    return sdfTriangularCylinder(P, 1.0);\n#elif SDF == SDF_HEXAGONAL_CYLINDER\n    return sdfHexagonalCylinder(P, 1.0);\n#elif SDF == SDF_DISPLACEMENT\n    float d1 = sdfSphere(P, 1.0);\n  //float d2 = 0.05 * sin(12.0 * P.x);\n  //float d2 = 0.05 * sin(12.0 * P.x) * sin(12.0 * P.y) * sin(12.0 * P.z);\n    float d2 = 0.05 * sin(12.0 * P.x) * sin(12.0 * P.y) * sin(12.0 * P.z);\n  //float d2 = 0.05 * sin(12.0 * P.x + sin(6.0 * iTime)) * sin(12.0 * P.y + sin(6.0 * iTime)) * sin(12.0 * P.z + sin(6.0 * iTime));\n\n    return d1 + d2;\n#elif SDF == SDF_TWIST\n    P = spTwist(P, 1.0);\n    return sdfRoundBox(P, vec3(0.375, 0.5, 0.75), 0.125);\n#elif SDF == SDF_BEND\n    P = spBend(P, 0.25);\n    return sdfRoundBox(P, vec3(0.375, 0.5, 0.75), 0.125);\n#elif SDF == SDF_BOX_MINUS_CYLINDERS\n    P = P.xzy;\n\n    float d1 = sdfRoundBox(P, vec3(2.25, 0.75, 0.5), 0.125);\n    float d2 = sdfCylinder(P -vec3(1.5, 0.0, 0.0), 0.5);\n    float d3 = sdfBoxCylinder(P, vec2(0.5));\n  //float d3 = sdfTriangularCylinder(P, 0.5);\n    float d4 = sdfHexagonalCylinder(P + vec3(1.5, 0.0, 0.0), 0.5);\n\n    float d234 = -min(d2, min(d3, d4));\n\n  //return max(d1, d234);\n    float r = 0.0625;\n    vec2 u = max(vec2(r + d1, r + d234), vec2(0.0));\n    return min(-r, max(d1, d234)) + length(u);\n#elif SDF == SDF_STAR\n    float theta = atan(P.x, P.z); // - iTime;\n    theta = mod(theta + Pi / 5.0, Pi / 2.5) - Pi / 5.0;\n    float r = length(P.xz);\n    P.zx = r * vec2(cos(theta), sin(theta));\n\n    P.xy = abs(P.xy);\n    float d = sdfPlane(P, normalize(vec3(3.0, 5.0, 1.0)), 0.2);\n\n    return d;\n#endif // SDF\n}\n\n\nvec2 sdf(vec3 P, float p) {\n    float d1 = sdfBackground(P, p);\n    float d2 = sdfForeground(P);\n\n    float d = min(d1, d2);\n\n    return vec2(d, d1 <= d2 ? 0.0 : 1.0);\n}\n\n\nvec3 sdfNormal(vec3 P, float s) {\n    const vec3 h = Epsilon * vec3(1.0, 0.0, 0.0);\n\n    return normalize(vec3(sdf(P + h.xyz, s).x - sdf(P - h.xyz, s).x,\n                          sdf(P + h.zxy, s).x - sdf(P - h.zxy, s).x,\n                          sdf(P + h.yzx, s).x - sdf(P - h.yzx, s).x));\n}\n\n\nvec2 intersect(vec3 O, vec3 d, float p) {\n    float t = 0.0;\n\n    for (int i = 0; i < MaxNumSteps; ++i) {\n        vec3 P = O + t * d;\n        vec2 result = sdf(P, p);\n        float distance_ = result.x;\n\n        if (distance_ < Epsilon)\n            return vec2(t, result.y);\n\n        t += distance_;\n    }\n\n    return vec2(MaxT, 0.0);\n}\n\n\nmat3 makeRotation(float theta, vec3 u) {\n    mat3 I = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    mat3 K = mat3(0.0, u.z, -u.y, -u.z, 0.0, u.x, u.y, -u.x, 0.0);\n    return I + sin(theta) * K + (1.0 - cos(theta)) * K * K;\n}\n\n\nvoid makeRay(vec2 xy, out vec3 O, out vec3 d) {\n    O = vec3(0.0, 0.0, 5.0);\n    d = normalize(vec3(xy, -1.0));\n\n    float theta = Pi / 24.0 + mod(iTime / 50.0, 2.0 * Pi);\n\n    mat3 Rz = makeRotation(theta, vec3(0.0, 0.0, 1.0));\n    mat3 Rx = makeRotation(Pi / 3.0, vec3(1.0, 0.0, 0.0));\n    mat3 R = Rz * Rx;\n\n    O = R * O;\n    d = R * d;\n}\n\n\nconst vec3 LightVector = -normalize(vec3(1.0, 1.0, -1.0));\n\n\nfloat intersectShadow(vec3 O, vec3 d,\n                      float tmin, float tmax,\n                      float k, float p) {\n    float t = tmin;\n    float s = 1.0;\n    float distance_ = 0.0;\n\n    if (t >= tmax)\n        return s;\n    \n    for (int i = 0; i < MaxNumSteps; ++i) {\n        vec3 P = O + t * d;\n        float distance_ = sdf(P, p).x;\n\n        if (distance_ < Epsilon)\n            return 0.0;\n\n        s = min(s, k * distance_ / t);\n        t += distance_;\n\n        if (t >= tmax)\n            return s;        \n    }\n\n    return s;\n}\n\n\nfloat shadow(vec3 P, float p) {\n#if SDF == SDF_PIPE_CYLINDERS || SDF_DISPLACEMENT || SDF == SDF_TWIST || SDF == SDF_BEND || SDF_STAR\n    float tmin = 0.5;\n#else\n    float tmin = 0.01;\n#endif\n    vec3 l = LightVector;\n\n    return intersectShadow(P, l, tmin, 8.0, 2.0, p);\n}\n\n\nvec3 sampleTexture(vec3 T) {\n    float d = sdfForeground(T);\n\n    vec3 fgColor1 = vec3(0.125, 0.125, 0.625);\n    vec3 fgColor0 = vec3(0.625, 0.625, 0.125);\n\n    float fgAlpha = exp(-0.1875 * floor(2.0 * d));\n    vec3 fgColor = mix(fgColor0, fgColor1, fgAlpha);\n\n    vec3 bgColor = vec3(0.0, 0.0, 0.0);\n    float x = mod(2.0 * d + 0.5, 1.0) - 0.5;\n    float sigma = 0.02;\n    float alpha = exp(-x * x / (sigma * sigma));\n\n    return mix(fgColor, bgColor, alpha);\n}\n\n\nvec3 sampleTexture(vec3 T, vec3 dTdx, vec3 dTdy) {\n    const float MaxSize = float(MaxNumSamples);\n    const float Scale = 48.0;\n\n    ivec2 size = ivec2(clamp(1.0 + Scale * length(dTdx), 1.0, MaxSize),\n                       clamp(1.0 + Scale * length(dTdy), 1.0, MaxSize));\n\n    vec3 T0 = T;\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < MaxNumSamples; ++i) {\n        for (int j = 0; j < MaxNumSamples; ++j) {\n            if (i >= size.x || j >= size.y)\n                continue;\n\n            vec2 xy = vec2(i, j) / vec2(size);\n            vec3 T = T0 + xy.x * dTdx + xy.y * dTdy;\n\n            color += sampleTexture(T);\n        }\n    }\n\n    return color / float(size.x * size.y);\n}\n\n\nvec3 shade(vec3 P, vec3 n, vec3 d, float m, float p) {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n\n    if (m == 0.0) {\n        float i = floor(P.x);\n        float j = floor(P.y);\n        float c = mod(i + j, 2.0);\n\n        ambient = c == 0.0 ? vec3(0.1) : vec3(0.2);\n        diffuse = vec3(0.5);\n        specular = vec3(0.1);\n        shininess = 10.0;\n    } else if (m == 1.0) {\n        ambient = vec3(0.05, 0.075, 0.1);\n        diffuse = vec3(0.15, 0.3, 0.5);\n        specular = vec3(0.4, 0.4, 0.4);\n        shininess = 20.0;\n    } else if (m == 2.0) {\n        vec3 T = P;\n        vec3 dTdx = dFdx(T);\n        vec3 dTdy = dFdy(T);\n\n      //ambient = sampleTexture(T);\n        ambient = sampleTexture(T, dTdx, dTdy);\n        diffuse = vec3(0.5);\n        specular = vec3(0.1);\n        shininess = 10.0;\n    } else if (m == 3.0) {\n        float i = floor(2.0 * P.x);\n        float j = floor(2.0 * P.y);\n        float k = floor(2.0 * P.z);\n        float c = mod(i + j + k, 2.0);\n\n        ambient = c == 0.0 ? vec3(0.6) : vec3(0.2);\n        diffuse = vec3(0.2);\n        specular = vec3(0.4);\n        shininess = 20.0;\n    }\n\n    vec3 l = LightVector;\n    vec3 r = reflect(d, n);\n\n    return ambient\n        + shadow(P, p) * (diffuse * max(dot(n, l), 0.0)\n                        + specular * pow(max(dot(r, l), 0.0), shininess));\n}\n\n\nvec3 applyFog(vec3 color, float distance_) {\n    const vec3 FogColor = vec3(0.05);\n    float t = 1.0 - exp(-0.001 * distance_ * distance_);\n\n    return mix(color, FogColor, t);\n}\n\n\nvec2 normalizeCoord(vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = normalizeCoord(fragCoord);\n    vec2 mouse = normalizeCoord(iMouse.xy);\n\n    vec3 O, d;\n    makeRay(xy, O, d);\n\n    float p = -1.0;\n\n    if (iMouse.y > 0.0 && iMouse.y < iResolution.y)\n        p = mouse.y * iResolution.x / iResolution.y;\n\n    vec2 result = intersect(O, d, p);\n    float t = result.x;\n\n    if (t >= MaxT)\n        return;\n\n    vec3 P = O + t * d;\n    vec3 n = sdfNormal(P, p);\n    float m = result.y;\n\n    float x0 = 0.0;\n\n    if (iMouse.x > 0.0 && iMouse.x < iResolution.x)\n        x0 = mouse.x;\n\n    if (xy.x >= x0)\n        m += 2.0;\n\n    vec3 color = shade(P, n, d, m, p);\n    color = applyFog(color, t);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}