{"ver":"0.1","info":{"id":"tl2GWm","date":"1559858312","viewed":264,"name":"[TWITCH] Sugar Rush","username":"Flopine","description":"Meet Susan the Unicorn! Based on an idea that I had with Jasmin68k during Outline :)\nMade during a Twitch stream here: https://www.twitch.tv/flopine ","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","specular","balloon","unicorn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\nfloat ITER = 100.;\nfloat PI = acos(-1.);\n\n#define time iTime\n\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\n// iq modeling function\nfloat capsule (vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p-a; vec3 ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.,1.);\n    return length(pa - ba*h) - r+smoothstep(0.1,0.6,abs(h-.5))*0.08;\n}\n\nfloat cutesule (vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a; vec3 ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.,1.);\n    return length(pa - ba*h) - mix(r1,r2, h);\n}\n\nfloat body (vec3 p)\n{\n    return capsule (p, vec3(.65,0.,0.), vec3(-.65,0.,0.),0.5);\n}\n\nfloat neck (vec3 p)\n{\n    p.x += sin(p.y*2.)*0.2; \n    return cutesule (p-vec3(.9,.3,0.), vec3(0.), vec3(0.5,0.7,0.), 0.3, 0.45); \n}\n\nfloat face (vec3 p)\n{\n    return cutesule(p-vec3(1.4,1.,0.), vec3(0.), vec3(.6,-0.3,0.), 0.4,0.25);\n}\n\nfloat legs (vec3 p)\n{\n    p.z = abs(p.z)-0.5;\n    vec3 pp = p;\n\n    p.x += sin (p.y*2.)*0.1;\n    float l1 = capsule (p-vec3(.7,-1.3,0.), vec3(0.), vec3(0.,1.,-.2), 0.3);\n\n    p = pp;\n    p.x -= sin (p.y*2.)*0.2;\n    float l2 = capsule (p-vec3(-.7,-1.4,0.), vec3(0.), vec3(0.,1.2,-.2), 0.28);\n    return min(l2,l1);\n}\n\nfloat mane (vec3 p)\n{\n    p.z = abs(p.z)-0.15;\n    p -= vec3(.4,.5,0.);\n    p.xy *= rot(-PI/4.);\n    p.x += sin(p.y*2.)*0.3; \n    float s1 = length(p-vec3(0.,1.,0.))-0.3;\n    float s2 = length(p-vec3(0.,.6,0.))-0.25;\n    float s3 = length(p-vec3(0.,.3,0.))-0.2;\n    float s4 = length(p-vec3(0.,.05,0.))-0.1;\n    return min(min(s4,s2),min(s1, s3));\n}\n\nfloat tail (vec3 p)\n{\n    p += vec3(1.6,.8,0.);\n    p.xy *= rot(-PI/4.);\n    p.x += sin(p.y*2.)*0.3; \n    float s1 = length(p-vec3(0.,1.,0.))-0.4;\n    float s2 = length(p-vec3(0.,.4,0.))-0.35;\n    float s3 = length(p-vec3(0.,.1,0.))-0.3;\n    float s4 = length(p-vec3(0.,-0.2,0.))-0.2;\n\n    return min(min(s4,s2),min(s1, s3));\n}\n\nfloat horn (vec3 p)\n{\n    p.xy -= vec2(1.2);\n    p.xy *= rot(-PI/4.);\n    return cutesule(p, vec3(0.), vec3(0.,1.,0.), 0.25,0.08);\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    float per = 5.5;\n    p.yz *= rot(mix(PI/10., -PI/10., floor(sin(time*2.)+1.)));\n    p.x -= time;\n    p.y -= -.3+abs(sin(time*2.));\n    p.x = mod(p.x-per*0.5, per)-per*0.5;\n\n    float prim1 = min(min(body(p),legs(p)), min(neck(p),face(p)));\n    float prim2 = horn(p);\n    float prim3 = min(mane(p),tail(p));\n\n    float d =  min(min(prim1, prim2),prim3);\n\n    if (d == prim1) mat_id =1;\n    if (d == prim2) mat_id =2;\n    if (d == prim3) mat_id =3;\n\n    return d;\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p) - vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\n// iq shader: https://www.shadertoy.com/view/lsccR8\nfloat sdfStar5( in vec2 p )\n{\n    // repeat domain 5x\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n\n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float per = 3.;\n    vec2 uu = mod(uv*10.,per)-per*0.5;\n    uu *= rot(sin(time*2.)*0.5);\n\n    vec3 ro = vec3(0.001,0.001,-6.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = clamp(vec3(smoothstep(0.1,0.11,sdfStar5(uu)))+vec3(0.8,0.6,0.8),0.,1.);\n\n    float shad = 0.; bool hit = false;\n\n    for(float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p+=d*rd*0.7;\n    }\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        vec3 l = normalize(vec3(1.,2.,-8.));\n        vec3 albedo;\n        if (mat_id == 1) albedo = palette(dot(n, -rd),vec3(0.5), vec3(0.5), vec3(0.5), vec3(0.,0.37,0.73));\n        if (mat_id == 2) albedo = palette(dot(n, -rd),vec3(0.5), vec3(0.5), vec3(3.), vec3(0.,0.37,0.73));\n        if (mat_id == 3) albedo = palette(dot(n, -rd),vec3(0.5), vec3(0.5), vec3(0.9), vec3(0.,0.37,0.73));\n\n        col = albedo + vec3(pow(max(0.,dot(reflect(rd,n), l)), 15.));\n        col *= vec3(1.-shad);\n    }\n\n\n    fragColor = vec4(pow(col, vec3(0.4545)),1.);\n}","name":"Image","description":"","type":"image"}]}