{"ver":"0.1","info":{"id":"4fcfRj","date":"1733657122","viewed":71,"name":"halftonings","username":"rbottura","description":"trying some functions to halftone","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["halptone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Function to rotate coordinates by a specific angle\nvec2 rotate(vec2 coord, float angle) {\n    float rad = radians(angle);\n    float sinAngle = sin(rad);\n    float cosAngle = cos(rad);\n    return vec2(\n        coord.x * cosAngle - coord.y * sinAngle,\n        coord.x * sinAngle + coord.y * cosAngle\n    );\n}\n\n// Halftone dot function with a density factor (control dot size and spacing)\nfloat halftone(vec2 coord, float intensity, float angle, float density) {\n    // Adjust cell size by the density factor (higher value = more dense)\n    float cellSize = 8.0 / density; // Smaller cell size increases the density of dots\n    \n    // Rotate coordinates for proper CMYK angle\n    vec2 rotatedCoord = rotate(coord, angle);\n\n    // Calculate position of the current cell\n    vec2 cellPos = floor(rotatedCoord / cellSize) * cellSize; // Adjust the cell size here\n    // Calculate the center of the cell\n    vec2 cellCenter = cellPos + 0.5 * cellSize;\n    \n    // Distance to center of the cell\n    float distanceToCenter = length(rotatedCoord - cellCenter);\n    \n    // Radius of the dot based on intensity (dots become smaller for higher intensity)\n    float radius = 0.5 * cellSize * intensity;\n    \n    // Return 1.0 (dot) if inside radius, 0.0 (background) otherwise\n    return distanceToCenter <= radius ? 1.0 : 0.0;\n}\n\n\n// ShaderToy version\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    resolution.x = resolution.x *0.4;\n    // vec2 resolution = (297.0, 420.0) \n    vec2 screenCoord = fragCoord.xy;\n\n    // Get the texture color at the current pixel\n    vec4 texColor = texture(iChannel0, fragCoord / resolution);\n    \n    // CMYK intensities (using inverted RGB)\n    float c = 1.0 - texColor.r; // Cyan\n    float m = 1.0 - texColor.g; // Magenta\n    float y = 1.0 - texColor.b; // Yellow\n    float k = min(c, min(m, y)); // Black\n\n    // Halftone layers for each CMYK color\n    float cyan = halftone(screenCoord, c, 15.0, 4.0);     // Cyan layer at 15째 with smaller cell size (density factor)\n    float magenta = halftone(screenCoord, m, 75.0, 4.0);  // Magenta layer at 75째 with smaller cell size (density factor)\n    float yellow = halftone(screenCoord, y, 0.0, 4.0);    // Yellow layer at 0째 with smaller cell size (density factor)\n    float black = halftone(screenCoord, k, 45.0, 4.0);    // Black layer at 45째 with smaller cell size (density factor)\n\n    // Composite CMYK layers (subtractive blending)\n    vec3 finalColor = vec3(1.0); // Start with white background\n\n    // Combine the CMYK channels by subtracting the corresponding color\n    finalColor.r -= cyan * 1.0;    // Subtract Cyan from Red channel\n    finalColor.g -= magenta * 1.0; // Subtract Magenta from Green channel\n    finalColor.b -= yellow * 1.0;  // Subtract Yellow from Blue channel\n    finalColor -= vec3(k) * black; // Subtract Black from all channels\n\n    // Ensure the final color is clamped between 0 and 1\n    finalColor = clamp(finalColor, 0.0, 1.0);\n\n    // Output the final color\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}