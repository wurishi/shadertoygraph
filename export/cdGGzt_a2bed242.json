{"ver":"0.1","info":{"id":"cdGGzt","date":"1678909763","viewed":59,"name":"cel sdf","username":"aaaaaa123456","description":"yay","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_STEPS = 50;\nconst float EPSILON = 0.0001;\nconst float NORMAL_DELTA = 0.001;\nconst float FOV = 3.0;\n\nconst vec3 LIGHT_POS = vec3(0.0, 1.0, -4.0);\n\nvec3 rotate(vec3 p, float alpha, float beta, float gamma) {\n    float as = sin(alpha);\n    float ac = cos(alpha);\n    \n    float bs = sin(beta);\n    float bc = cos(beta);\n    \n    float gs = sin(gamma);\n    float gc = cos(gamma);\n    \n    mat3 mat = mat3(\n        ac * bc, ac * bs * gs - as * gc, ac * bs * gc + as * gs,\n        as * bc, as * bs * gs + ac * gc, as * bs * gc - ac * gs,\n        -bs, bc * gs, bc * gc\n    );\n    \n    return p * mat;\n}\n\nfloat torus_sdf(vec3 p, vec2 t) {\n      vec3 j = p;\n      vec2 q = vec2(length(j.xz) - t.x,j.y);\n      return length(q) - t.y;\n}\n\nfloat y_plane_sdf(vec3 p, float f) {\n    return p.y - f;\n}\n\nvec3 transform(vec3 p, vec3 r, vec3 t) {\n    return rotate(p + t, r.x, r.y, r.z);\n}\n\nvec3 cast_ray(vec3 o, vec3 d, float l) {\n    return o + d * l;\n}\n\nfloat world_sdf(vec3 p) {\n    p = transform(p,\n        vec3(0.0, 0.0, -0.5),\n        vec3(0.0, 3.0, 5.0)\n    );\n\n    float t_a = torus_sdf(\n        transform(p, \n            vec3(0.0, 0.0, 2.2),\n            vec3(0.0, 0.0, 7.0)\n        ),\n        vec2(1.0, 0.5)\n    );\n\n    float t_b = torus_sdf(\n        transform(p, \n            vec3(2.3, 0.0, 0.0),\n            vec3(-4.0, 0.0, 6.0)\n        ),\n        vec2(1.0, 0.5)\n    );\n   \n    float plane = y_plane_sdf(p, -0.0);\n    if (plane < min(t_a, t_b)) return plane;\n  \n    float k = 2.0;\n    float h = clamp( 0.5 + 0.5*(t_b-t_a)/k, 0.0, 1.0 );\n    return mix( t_b, t_a, h ) - k*h*(1.0-h);\n}\n\nfloat shadow_march(vec3 o, vec3 d, float t) {\n    // @TODO: better method of avoiding self-shadowing\n    float l = 0.001;\n    for (int i = 0; i < MAX_STEPS; i ++) {\n        vec3 p = cast_ray(o, d, l);\n        float dist = world_sdf(p);\n        \n        if (dist < EPSILON) return 0.0;\n        l += dist;\n    }\n    \n    return 1.0;\n }\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 get_normal(vec3 p) {\n    const vec2 k = vec2(1, -1);\n    return normalize(\n        k.xyy * world_sdf(p + k.xyy * NORMAL_DELTA) +\n        k.yyx * world_sdf(p + k.yyx * NORMAL_DELTA) +\n        k.yxy * world_sdf(p + k.yxy * NORMAL_DELTA) +\n        k.xxx * world_sdf(p + k.xxx * NORMAL_DELTA)\n    );\n}\n\nvec3 light(vec3 p, vec3 r) {\n    // Uniforms\n    vec3 normal = get_normal(p);\n    vec3 light = normalize(LIGHT_POS - p);\n    vec3 view = normalize(-p);\n    \n    // Lighting\n    float diffuse = max(0.0, dot(normal, light)) - 0.0;\n    float rim = 1.0 - dot(view, normal);\n    rim *= 0.2;\n    \n    // Specular\n    vec3 halfs = (light + view) / 2.0;\n    float specular = dot(normal, halfs);\n    specular = specular * pow(specular, 3.0) / 3.0;\n    \n    // Shadow\n    float shadow = shadow_march(p, light, distance(p, LIGHT_POS));\n    \n    // Reflection\n    vec3 re = reflect(r, normal);\n    \n    float total = (diffuse + rim + specular) * shadow;\n    return vec3(0.2784, 0.2784, 0.9294) * total;\n}\n\nvec3 march(vec3 r_o, vec3 r_d) {\n    float r_l = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i ++) {\n        vec3 p = cast_ray(r_o, r_d, r_l);\n        float dist = world_sdf(p);\n        \n        if (dist < EPSILON) return light(p, r_d);\n        r_l += dist;\n    }\n\n    return vec3(0.0);\n}\n\nvec3 uvmarch(vec2 uv) {\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uvc = (uv - 0.5) * 2.0;\n    \n    return march(vec3(0.0), normalize(vec3(uvc.x, uvc.y, -FOV)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(uvmarch(fragCoord / iResolution.xy), 1.0);\n}","name":"Image","description":"","type":"image"}]}