{"ver":"0.1","info":{"id":"3tf3W8","date":"1556132071","viewed":64,"name":"First steps: Basic utilities","username":"endymion","description":"First steps at adapting basic utilities from The Book of Shaders","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["geometry","utilities"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n/**\n * Draw helper for better portability between environments \n */\nvec4 draw(vec2 coordinate, vec2 resolution, float time) {\n    float zoom = 4.;\n    vec2 zoomVector = vec2(resolution.x / resolution.y * zoom, zoom); // Tile in squares\n    \n    vec2 uv = normalizedCoordinates(coordinate.xy, resolution.xy);\n    uv = tile(uv, zoomVector);\n    uv = rotate2d(uv, PI * 0.25);\n    uv = scale(uv, vec2(sin(time)+1.5));\n    uv = rotateTilePattern(uv);\n    \n    vec3 color = 0.5 + 0.5 * cos(time + uv.xyx + vec3(0, 2, 4)); // Rotating color by time\n    // vec3 color = vec3(box(uv, vec2(0.7),0.01)); // Boxes\n    // vec3 color = vec3(distanceField(uv, 4));\n    return vec4(color, 1.0);\n}\n\n/**\n * Main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = draw(fragCoord, iResolution.xy, iTime);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Utilities\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n/**\n * Pseudo-random\n * @src https://thebookofshaders.com/10/\n * @param coordinate {vec2}\n * @return {float}\n */\nfloat random (vec2 coordinate) {\n    return fract(\n        sin(dot(\n            coordinate,\n            vec2(12.9898, 78.233)\n        )) \n    * 43758.5453123);\n}\n\n/**\n * Normalize coordinates\n * @param coordinate {vec2}\n * @param resolution {vec2}\n * @return {vec2} - coordinates normalized to 0-1 by resolution\n */\nvec2 normalizedCoordinates(vec2 coordinate, vec2 resolution) {\n    return coordinate / resolution;\n}\n\n/**\n * Tile coordinate system by zoom level\n * @param coordinates {vec2}\n * @param zoom {float}\n * @return {vec2} - coordinates scaled and tiled by zoom level\n */\nvec2 tile(vec2 coordinate, vec2 zoom) {\n    return fract(coordinate * zoom);\n}\n\n/**\n * Rotate coordinate system from the center by angle\n * @src https://thebookofshaders.com/08/\n * @param coordinates {vec2}\n * @param angle {float} - angle in radians (360 degrees = 2 * PI)\n * @return {vec2}\n */\nvec2 rotate2d(vec2 coordinate, float angle){\n    coordinate -= 0.5; // Move coordinate to center \n    coordinate = mat2(\n        cos(angle),\n        -sin(angle),\n        sin(angle),\n        cos(angle)\n    ) * coordinate; // Rotate coordinate\n    coordinate += 0.5; // Reset coordinate from center \n    return coordinate;\n}\n\n/**\n * Scale coordinate system\n * @src https://thebookofshaders.com/08/\n * @param coordinate {vec2}\n * @param scale {vec2}\n * @return {vec2}\n */\nvec2 scale(vec2 coordinate, vec2 scale){\n    coordinate -= 0.5; // Move coordinate to center \n    coordinate = mat2(scale.x, 0.0, 0.0, scale.y) * coordinate; // Scale coordinate\n    coordinate += 0.5; // Reset coordinate from center \n    return coordinate;\n}\n\n/**\n * Box color at coordinate\n * @src https://thebookofshaders.com/07/\n * @param coordinate {vec2}\n * @param size {vec2}\n * @param smoothEdges {float}\n * @return {float}\n */\nfloat box(vec2 coordinate, vec2 size, float smoothEdges){\n    size = vec2(0.5) - size * 0.5; // Center size\n    \n    vec2 aa = vec2(smoothEdges * 0.5);\n    \n    vec2 uv = smoothstep(size, size + aa, coordinate);\n    uv *= smoothstep(size, size + aa, vec2(1.0) - coordinate);\n    \n    return uv.x * uv.y;\n}\n\n\n/**\n * Distance field\n * @src https://thebookofshaders.com/07/\n * @param coordinate {vec2} - normalized (0-1, 0-1) coordinate\n * @param sides {int} - Number of sides of your shape\n * @return {float}\n */\nfloat distanceField(vec2 coordinate, int sides) {\n    // Remap the space to -1. to 1.\n    vec2 uv = coordinate * 2. - 1.;\n\n    // Angle and radius from the current pixel\n    float a = atan(uv.x, uv.y) + PI;\n    float r = TWO_PI / float(sides);\n\n    // Shaping function that modulate the distance\n    float d = cos(floor( .5 + a / r) * r - a) * length(uv);\n    return d;\n}\n\n/**\n * Rotate tile pattern\n * @src https://thebookofshaders.com/09/\n * @param coordinate {vec2} - normalized (0-1, 0-1) coordinate\n * @return {vec2}\n */\nvec2 rotateTilePattern(vec2 coordinate){\n\n    //  Scale the coordinate system by 2x2\n    coordinate *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(coordinate.x,2.0));\n    index += step(1., mod(coordinate.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    coordinate = fract(coordinate);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        coordinate = rotate2d(coordinate, PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        coordinate = rotate2d(coordinate, PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        coordinate = rotate2d(coordinate, PI);\n    }\n\n    return coordinate;\n}","name":"Common","description":"","type":"common"}]}