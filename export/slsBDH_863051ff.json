{"ver":"0.1","info":{"id":"slsBDH","date":"1650838259","viewed":126,"name":"Tunnel with water","username":"gest","description":"experiment","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define u_texture0 iChannel0\n#define u_time iTime\n#define u_canvas iResolution\n#define texture2D texture\n\nconst float PI = radians(180.);\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat   steps;\t\t//Число приближений к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat swing;\t\t//Колебание шага приближения 0...1\n\tfloat steps;\t\t//Максимальное число итераций\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n//Функция трехмерного смешивания. Основано на старом учебнике Nvidia.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n//    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n = max(abs(n), 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n\treturn (texture2D(tex, p.yz)*n.x + texture2D(tex, p.zx)*n.y + texture2D(tex, p.xy)*n.z).xyz;\n}\n\nvec2 path(in float z){ \n\t#if 1\n\t\tfloat x = sin(z/24.)*cos(z/12.); \n\t\tfloat y = 0.1*cos(z/24.)*sin(z/12.); \n\t#else\n\t\t//float x = sin(z/24.)*sin(z/12.); \n\t\t//float y = 0.1*cos(z/24.)*sin(z/12.); \n\t\tfloat x = sin(z/24.)*cos(z/12.)*sin(z/6.); \n\t\tfloat y = clamp(0.1*sin(z/24.)*sin(z/12.)*sin(z/6.), -0.075,1.); \n\t#endif\n\treturn vec2(x, y)*12.; \n}\n\nbool flagWater = true;\n\nfloat map(vec3 p, inout Object object) {\n\tobject.distance = 1e6;\n\tobject.id = -1.;\n\n\t//Пропорция тоннеля\n\t#if 0\n\t\tvec2 size = vec2(0.5, 1);\n\t#else\n\t\tvec2 size = vec2(1);\n\t#endif\n\t\n\tfloat d;\n\tvec3 q;\t\n\tq.xy = (p.xy - path(p.z))*size;\n\tvec3 q1 = q;\n\tvec3 q2 = q;\n\n\t//Перевернутое сердце\n\tq.y = q.y + abs(q.x);\n\td = 1.0 - length(q.xy);\n\n\tif (d < object.distance) {\n\t\tobject.distance = d;\n\t\tobject.id = 0.;\n\t}\n\n\t//Вырез \n\tq1.x = mod(p.z, 4.);\n\tq1.xy -= vec2(0.2);\t\n\td = 1. - max(abs(q1.x*0.5), abs(q1.y));\n\t\n\tif (d > object.distance) {\n\t\tobject.distance = d;\n\t\tobject.id = 0.;\n\t}\n\t\n\t//Трубы\n\tvec3 p2 = q2;\n\tp2.x = abs(p2.x) - 1.;\n\tp2.y = abs(p2.y) - 1.;\n\tp2.z = mod(p2.z, 4.);\n\td = length(p2)-0.05;\n\tif (d < object.distance) {\n\t\tobject.distance = d;\n\t\tobject.id = 2.;\n\t}\n\t\n\n\tif (flagWater) {\n\t\t//Поверхность воды\n\t\tfloat h = -1.;\n\t\td = p.y - h;\n\n\t\tif (d < object.distance) {\n\t\t\tobject.distance = d;\n\t\t\tobject.id = 1.;\n\t\t}\n\t}\n\t\n\treturn object.distance;\n}\nfloat map(vec3 p ) {\n\tObject object;\n\treturn map(p, object);\n}\n\nvec3 mapNormal(vec3 p, float eps){\n\tmat3 e = mat3(eps);\n\treturn normalize( vec3(\n\t\tmap( p + e[0]) - map(p - e[0]),\n\t\tmap( p + e[1]) - map(p - e[1]),\n\t\tmap( p + e[2]) - map(p - e[2])\n\t));\n}\n\nvoid rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tray.object.steps = 1.;\n\tfor (float i = 0.; i < 200.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = abs(ray.object.distance) < ray.epsilon;\n\t\tif(ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif(ray.distance>ray.far) break;\n\t\tray.object.steps++;\n\t\tif(ray.object.steps>ray.steps) break;\n\t}\n\tray.distance = min(ray.distance, ray.far);\n}\n\n//Оттенки серого\nfloat getGrey(vec3 p){ \n\treturn p.x*0.299 + p.y*0.587 + p.z*0.114; \n}\n\n// Рельеф текстуры. Всего четыре трехплоскостных поиска или 12 текстурных поисков.\nvec3 doBumpMap( sampler2D tex, vec3 p, vec3 n){\n    const float eps = 0.001;\n\tfloat bumpfactor = 0.025;\n\tmat3 m = mat3(eps);\n    float ref = getGrey(tex3D(tex,  p , n));                 \n    vec3 grad = vec3( \n\t\tgetGrey(tex3D(tex, p-m[0], n)) - ref,\n        getGrey(tex3D(tex, p-m[1], n)) - ref,\n        getGrey(tex3D(tex, p-m[2], n)) - ref \n\t)/eps;\n    grad -= n*dot(n, grad);          \n    return normalize( n + grad*bumpfactor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = fragCoord.xy/u_canvas.xy;\n\tuv = uv - 0.5;\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 90.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3(0,0, u_time*3.);\n\t\tcam.target  = cam.origin + vec3(0,0,1);\n\t\tcam.target.xy += path(cam.target.z);\n\t\tcam.origin.xy += path(cam.origin.z);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= 100.;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.; //0.8 + 0.1 * rnd(uv)\n\t\tray.steps \t= 200.;\n\t}\n\t\n\tflagWater = true;\n\trayMarch(ray);\n\t\n\tvec3 color = vec3(0);\n\t// Коэффициент масштаба текстуры.\n\tconst float tSize = 0.5;\n\t//Цвет воды\n\tconst vec3 color_water = vec3(0.1,0.3,0.9);\n\n\tif (ray.distance<ray.far) {\n\t\t//Нормаль поверхности\n\t\tray.normal = mapNormal(ray.position, 0.01);\n\t\t//Цвет поверхности\n\t\tvec3 mCol;\n\t\tif (ray.object.id==0.) {\n\t\t\t//Стены\n\t\t\tray.normal = doBumpMap(u_texture0, ray.position*tSize, ray.normal); // Floor.\n\t\t\tmCol = tex3D(u_texture0, ray.position*tSize, ray.normal);\n\t\t} else if (ray.object.id==1.) {\n\t\t\t//Вода\n\t\t\t//Рябь\n\t\t\tvec3 normal_water = doBumpMap(u_texture0, ray.position*0.005*sin(0.2 + 0.01*u_time), ray.normal);\n\t\t\tRay ray1 = ray;\n\t\t\t{\n\t\t\t\tray1.origin \t= ray.position;\n\t\t\t\tray1.direction \t= refract(ray.direction, normal_water, 0.95);\n\t\t\t\tray1.steps = 50.;\n\t\t\t}\n\t\t\tflagWater = false;\n\t\t\trayMarch(ray1);\n\t\t\t\n\t\t\tray1.normal = mapNormal(ray1.position, 0.01);\n\t\t\t\n\t\t\tif (ray1.object.id==2.) {\n\t\t\t\tif (ray.position.y>0.) {\n\t\t\t\t\tmCol = vec3(0.9,0.2,0.1);\n\t\t\t\t} else {\n\t\t\t\t\tmCol = vec3(0.9,0.9,0.1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmCol = tex3D(u_texture0, ray1.position*tSize, ray1.normal);\n\t\t\t}\n\t\t\tmCol = mix(color_water, mCol, 0.5);\n\n\t\t\tray.normal = ray1.normal;\n\t\t} else if (ray.object.id==2.) {\n\t\t\tif (ray.position.y>0.5) {\n\t\t\t\tmCol = vec3(0.9,0.2,0.1);\n\t\t\t} else {\n\t\t\t\tmCol = vec3(0.9,0.9,0.1);\n\t\t\t}\n\t\t}\n\t\t//Направление света\n\t\tvec3 ldir = -ray.direction;\n\t\t//Диффузия\n\t\tfloat diff = max(0.0, dot(ray.normal, ldir));\n\t\t//Цвет фрагмента\n\t\tcolor = mCol * (diff + 0.2);\n\t\tcolor = clamp(color, 0., 1.);\n\t}\n\t\n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}