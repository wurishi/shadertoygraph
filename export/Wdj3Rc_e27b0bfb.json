{"ver":"0.1","info":{"id":"Wdj3Rc","date":"1549557472","viewed":123,"name":"2019-02-07","username":"Justaway","description":"2019-02-07","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["20190207"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SETS 8\nfloat[30*NUM_SETS] coef = float[30*NUM_SETS](\n    -1.017237, -0.903984, -0.512759, 0.476637, 0.271241, -1.150559, 0.560693, 0.097803, -0.407286, 0.882287, 0.180914, -0.420358, -1.081892, 0.498610, 1.087361, 0.243611, 0.331453, -0.502525, -0.359248, 1.084326, 0.834692, -0.634044, 0.660750, 1.096257, -0.059903, 0.350534, 0.602114, 0.025440, 0.993483, -0.476214, \n    -0.786305, -0.298404, 0.372053, 0.756946, 0.353847, -0.400713, -0.932856, 0.917608, 0.942425, -1.004183, 0.381193, 0.093966, -0.324366, -0.402953, -0.055247, 0.244378, -0.013363, 0.294876, 1.054206, 0.307839, -0.879138, -0.464629, -0.686187, 0.719042, -0.490385, 0.648228, 0.471379, 1.016690, 0.300288, 0.150001,\n    0.803768, 0.661441, -0.424644, -0.470243, 0.050267, 0.514802, -0.649469, -0.705689, -0.561211, 0.101740, -1.175427, -0.765153, -0.490339, -0.606044, 0.322624, 0.003870, -0.050577, 0.528116, -0.553878, 0.284891, -1.128502, 0.028663, -0.758520, 0.874346, -0.594991, -0.932099, -0.740500, 0.732730, 0.706501, 0.123612,\n    -0.562382, -0.825137, -1.091844, 0.935173, 0.601242, -0.918670, 1.099101, -0.671295, 0.738957, 1.030110, -1.097903, 0.612579, -0.473047, 0.018712, -0.357112, 0.799581, 0.887695, -0.229816, -0.074310, 0.315690, -0.276303, -0.932574, -0.477739, 0.275418, -0.853308, -0.168254, 1.003870, -0.000951, -0.250323, 0.2687860,\n    -0.309574, 0.807723, 1.025505, 0.573068, 0.683365, -0.181145, 0.211926, 0.113968, -0.376128, 0.349162, 0.928868, -0.210045, 0.710791, -0.298831, -0.512152, -0.401817, -1.091119, 0.196270, 0.055377, -0.082567, -0.349668, 0.714866, 0.824623, 0.354524, -0.234629, 0.597942, -0.974828, 0.301032, -0.329624, 0.257103,\n    0.910843, 0.497447, 0.897955, 0.122985, -0.363504, 1.046468, 0.737447, -0.728952, -0.390985, -0.050037, 0.555775, 1.001503, 0.337579, -0.599918, 0.161471, -1.068861, -0.708915, -0.480711, -0.591640, 0.913434, 0.496210, -1.178109, -0.016749, -1.072668, 0.135254, 1.178998, -0.457025, 0.273666, 0.353600, 0.821535, \n    -0.172477, -0.055175, 0.630376, -0.418818, -0.587702, 0.292670, 0.355657, -0.705739, -0.472009, 0.419189, 0.587554, -0.142814, 0.094523, 0.889469, 0.656007, 0.185450, 0.865860, -0.245562, 0.878038, 0.449732, 0.336955, 0.256571, -0.563523, 0.665381, 0.152538, 0.562831, -0.713084, 0.001681, 0.537751, 0.111259,\n    -0.110493, 0.867670, 0.816344, -1.035664, 0.518601, 0.971636, 0.412624, -0.022961, -1.112663, 0.371931, 0.800081, 0.640390, -0.718583, 0.053005, -0.602554, 0.670707, 0.581050, 0.503452, 0.579796, -0.394368, 0.271451, 1.083272, -0.469859, -0.923139, 0.163897, 1.190899, -0.552614, -0.471609, -0.999791, -0.105114);\n\nfloat[30] c;\n\nvec3 Dmap(vec3 v, vec3 d){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0] + c[3]*y + c[5]*z + 2.0*c[6]*x*d.x + 1.0;\n    newV.y = c[11] + c[13]*x +c[14]*z + 2.0*c[17]*y*d.y + 1.0;\n    newV.z = c[22] + c[24]*y + c[25]*x + 2.0*c[28]*z*d.z + 1.0;\n    return newV;\n}\n\nvec3 map(vec3 v){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0]*x  + c[1]*y  + c[2]*z  + c[3]*xy  +c[4]*yz  + c[5]*xz  + c[6]*xx  + c[7]*yy  + c[8]*zz  + c[9];\n    newV.y = c[10]*x + c[11]*y + c[12]*z + c[13]*xy +c[14]*yz + c[15]*xz + c[16]*xx + c[17]*yy + c[18]*zz + c[19];\n    newV.z = c[20]*x + c[21]*y + c[22]*z + c[23]*xy +c[24]*yz + c[25]*xz + c[26]*xx + c[27]*yy + c[28]*zz + c[29];\n    return newV;\n}\n\nfloat mod2(vec3 V)\n{\n    return V.x*V.x+V.y*V.y+V.z*V.z;\n}\n\nfloat permute(float x) {\n  return mod(x*1693.0+241.0,493.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    \n    vec3 V = vec3(0.0);\n    int index[2];\n    int iNext[2];\n    float T[2];\n    float t, t2;\n    float perm;\n    float T2[2];\n    vec3 av = vec3(0.0);\n    int i;\n    \n    #define TIME_ADJUST 10.0\n    \n    T[0] = float(floor(iTime/TIME_ADJUST));\n    T[1] = T[0]+1.0;\n    t = smoothstep(0.0,1.0,fract(iTime/TIME_ADJUST));\n    perm = permute(permute(T[0]));\n    index[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    index[1] = int(mod(perm,30.0));\n    perm = permute(permute(T[1]));\n    iNext[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    iNext[1] = int(mod(perm,30.0));\n    \n    \n    T2[0] = floor(iTime/TIME_ADJUST);\n    T2[1] = T2[0] + 1.0;\n    t2 = smoothstep(0.0,1.0,fract(iTime/TIME_ADJUST));\n    perm = permute(permute(T2[0]));\n    int coefIndex[2];\n    coefIndex[0] = int(mod(perm, float(NUM_SETS)));\n    perm = permute(permute(T2[1]));\n    coefIndex[1] = int(mod(perm, float(NUM_SETS)));\n    \n    for(int i = 0; i < 30; i++){\n        c[i] = coef[coefIndex[0]*30+i] * (1.0-t2);\n        c[i] += coef[coefIndex[1]*30+i] * t2;\n    }\n    \n    uv*=10.0;\n    c[index[0]] += (1.0-t)*uv.x;\n    c[index[1]] += (1.0-t)*uv.y;\n    c[iNext[0]] += t*uv.x;\n    c[iNext[1]] += t*uv.y;\n    \n    #define ITER 100\n    for(i = 0; i < ITER; i++)\n    {\n        V = map(V);\n        av += normalize(V);\n        if(length(V)>1.7e9f) break;\n    };\n    av = normalize(av);\n\n    vec4 col;\n    \n    float m = length(V);\n    float mu = float(i) - log(log(m))/log(2.0);\n    \n    col = vec4((sin(mu)+1.0)/2.0);\n    col.x = min(col.x,abs(av.x));\n    col.y = min(col.y,abs(av.y));\n    col.z = min(col.z,abs(av.z));\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}