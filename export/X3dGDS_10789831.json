{"ver":"0.1","info":{"id":"X3dGDS","date":"1717035394","viewed":127,"name":"Procedural Earth 2","username":"ArchaicVirus","description":"Procedural earth-like planet with psuedo-3D clouds & atmosphere. *Now includes 3D rotation on line 33","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raycasting","earth","space","planet","procgen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) {\n    return fract(sin(n) * 53738.14534123);\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n    return mix(\n        mix(hash(ip.x + ip.y * 57.0), hash(ip.x + 1.0 + ip.y * 57.0), u.x),\n        mix(hash(ip.x + (ip.y + 1.0) * 57.0), hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0), u.x),\n        u.y\n    );\n}\n\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    float halfAngle = angle * 0.5;\n    float s = sin(halfAngle);\n    return vec4(axis * s, cos(halfAngle));\n}\n\nvec3 rotate(vec3 v, vec4 q) {\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves) {\n    float n = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, quatFromAxisAngle(normalize(vec3(1.0, 0.5, 0.0)), radians(45.0)));\n    }\n    return n;\n}\n\nfloat sphere(vec3 ro, vec3 rd, float radius) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec3 colorBanding(float n) {\n    vec3 color = vec3(0);\n    if (n > 0.95) return vec3(0.0, 0.1, 0.5);\n    else if (n > 0.85) color = vec3(0.0, 0.3, 0.7);\n    else if (n > 0.75) color = vec3(0.0, 0.5, 0.8);\n    else if (n > 0.65) color = vec3(0.0, 0.7, 0.7);\n    else if (n > 0.55) color = vec3(0.8, 0.6, 0.4);\n    else if (n > 0.45) color = vec3(0.0, 0.6, 0.0);\n    else color = vec3(0.4, 0.6, 0.1);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ro_planet = vec3(0.0, 0.0, 2.4);\n    vec3 ro_clouds = vec3(0.0, 0.0, 2.3);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t_planet = sphere(ro_planet, rd, 1.0);\n    float t_clouds = sphere(ro_clouds, rd, 1.0);\n    if (t_clouds < 0.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        vec3 pos = ro_planet + t_planet * rd;\n        vec4 q = quatFromAxisAngle(normalize(vec3(1.0, 1.0, 0.0)), iTime);\n        pos = rotate(pos, q);\n        vec3 norm = normalize(pos);\n        float noiseValue = layeredNoise(norm * 3.1415, 0.75, 1.0, 0.5, 8);\n        vec4 color = vec4(colorBanding(noiseValue), 1.0);\n\n        if (t_planet < 0.0) {\n            color = vec4(0.0);\n        }\n\n        vec3 pos2 = ro_clouds + t_clouds * rd;\n        vec4 q2 = quatFromAxisAngle(normalize(vec3(0.7, 0.5, 0.0)), iTime);\n        pos2 = rotate(pos2, q2);\n        vec3 norm2 = normalize(pos2);\n        float noiseValue2 = layeredNoise(norm2 * 3.311, 1.0, 1.0, 0.5, 8);\n        float noiseValueFinal = pow(noiseValue2, 1.05) - 1.0;\n        vec4 color2 = vec4(vec3(noiseValueFinal), min(noiseValue2 - 0.5, 0.1));\n        fragColor = mix(color, color2 + vec4(0.0, 0.22, 0.75, 1.0), noiseValue2) + color;\n    }\n}","name":"Image","description":"","type":"image"}]}