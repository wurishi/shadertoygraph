{"ver":"0.1","info":{"id":"7tBGRm","date":"1623549376","viewed":115,"name":"Psychedelic Nip Corridor","username":"Makeavoy","description":"Ray marching tube of sorts, really rotten code experimenting based on \"Art of Code\" ray marching examples ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"NtB3R1","parentname":"Test @Makeavoy"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Most foundational code built from the Art of Code tutorials https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash33(vec3 p) { \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\nfloat smin(float a,float b, float smoothing){\n    float slope=clamp(.5+.5*(b-a)/smoothing,0.,1.);\n    //float ease=slope*(1.-slope); //good boolean intersect\n    //return slope*a+(1.-slope)*b-ease*.5;\n    return mix(b,a,slope) - smoothing*slope*(1.-slope);\n}\n\nmat2 rot(float a){\n    float s=sin(a);float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z){\n//l.x+=6.*sin(p.z*14.2);\n    //z=sin(p.y)*4.; warpy\n    vec3 f = normalize(l-p),\nr=normalize(cross(vec3(0,1,0),f)),\nu=cross(f,r),\nc=f*z,\ni=c+uv.x*r + uv.y*u,\nd=normalize(i);\nreturn d;\n}\n\n\nfloat sdPill(vec3 p,vec3 a, vec3 b, float r){\n    //float v=floor(sin(p.x*4.)*2.)*(1.+cos(iTime));//floor(sin(p.x*2.)*4.)*2;\n    vec3 offset=vec3(0,0,0);//+vec3(round(1.*abs(cos(iTime+p.x*2.))),0,0);\n    a+=offset;\n    b+=offset;\n    vec3 ab=b-a;\n    vec3 ap=p-a;\n    float t = dot(ab,ap) /dot(ab,ab); //length(ab) works too but doestn connect\n    t=clamp(t,0.,1.);\n    vec3 c = a+ t*ab;\n    return length(p-c) -r;\n}\n\nfloat sdTube(vec3 p,float r){\n    //p.x-=cos(p.z*.2)*3.;\n    //p.y+=sin(iTime*.8)*3.;\n    vec3 a=vec3(0,0,90.);\n    vec3 b = vec3(0,0,-90); //make this -900 for a cool effect\n    vec3 ab=b-a;\n    vec3 ap=p-a;\n    float t = dot(ab,ap) /dot(ab,ab); //length(ab) works too but doestn connect\n    t=clamp(t,0.,1.);\n    vec3 c = a+ t*ab;\n    float moving=p.z*.2+iTime*10.;\n    float zWave=atan(p.y,(p.x));\n    float m=6.;//floor(abs(sin(moving*.1))*6.);\n    float scale=sin(zWave*m);//(sin(moving));\n    r-=2.*scale*(cos(t*p.z*.6 +iTime*10.));\n    return length(p-c) -r;\n}\n\nfloat sdSphere(vec3 p,vec3 a, float r){\nreturn length(p-a) - r;\n}\n\nfloat sdTorus(vec3 p,vec2 r){\n    float i=length(p.xy)-r.x;\n    return length(vec2(i,p.z)) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n    p=abs(p)-s;\n    return length(max(p,0.))+min(max(p.x, max(p.y, p.z)),0.);\n}\n\nfloat getDist(vec3 p){\n    \n    vec3 a=vec3(0.,1.,.4);//vec3(cos((p.y+iTime)*20.)/8.,sin(p.y*3.+iTime*3.)*2.+1.,6); //vec3(0,1,4);//\n    vec3 b=vec3(0,-2.*sin(iTime),8);\n    //float sphereD=sdPill(p,a,b,1.);\n    //vec3 t=vec3(cos(p.x*1.),p.y+(sin(iTime-cos(p.x))*2.),cos(p.z));\n    //float torusD=sdTorus(b,vec2(1.5,.5));\n    float planeDist=p.y+10.;\n    //float sp1=sdSphere(p,a,1.);\n    \n    float tube=sdTube(p,20.);\n    float tubei=sdTube(p,7.5);\n    tube=max(tube,-tubei);\n    //float box=sdBox(p+vec3(0,-1,2),vec3(1,1,1));\n    //float d=min(tube,planeDist);\n    float d=tube;\n   // float d=min(torusD,planeDist);\n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float dO=0.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p = ro +rd*dO;\n        float dS =getDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST || dS<SURF_DIST)break;\n    }\n    return dO;\n}\n\nvec3 getNormal(vec3 p){\n    float dist=getDist(p);\n    vec2 e=vec2(0.01,0);\n    vec3 n = dist - vec3(getDist(p-e.xyy),getDist(p-e.yxy),getDist(p-e.yyx));\n    n=normalize(n);\n    /*n*=pow(n,vec3(10.));\n    n=normalize(n);*/\n    /*\n    vec3 o=n*10.;\n    vec3 guv=abs(fract(o)-.5);\n    \n    guv.x+=cos(iTime*2.)-sin(iTime*2.);\n    guv.z-=cos(iTime*2.)+sin(iTime*2.);\n    \n    vec3 id=floor(o);\n    float sp=sdSphere(p,guv,.1)/2.;\n    n+=vec3(sp);//dot(sp,sp);\n    n=normalize(n);*/\n    //n+=dot(guv,guv);\n    \n    return n;\n}\n\nvec3 getLight(vec3 p,vec2 uv){\n    vec3 lightPos=vec3(cos(iTime)*3.,5,0); // 0 5 6 \n    vec3 l =normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    n=abs(n);\n    p.z-=2.;//iTime;\n    //p.z+=iTime*10.;\n   \n   /*\n    n*=pow(n,vec3(10.));\n    //n/=n.x+n.y+n.z;\n    n=normalize(n);\n    vec3 c=texture(iChannel1,p.xy*.5 +.5).rgb*n.z \n    +texture(iChannel1,p.xz*.5 +.5).rgb*n.y\n    +texture(iChannel1,p.yz*.5 +.5).rgb*n.x;*/\n    \n    vec2 i =vec2(floor(p.z*.01),floor(length(p.xy)*1.4));\n    \n    vec2 v=hash22(i);\n    vec3 t=p;\n    float val=length(v);\n    //vec3 c=vec3(length(v));//-vec3(length(t));\n    vec3 c=vec3(val*.6+.8,val*1.,1.-val);\n    //vec3 c=abs(fract(p*.4)-0.);\n    \n    //float id=floor((c.z+.2)*2.)*.2;\n    //c=vec3((c.z-(id)));\n    \n    float c1=.3+floor(c.z*3.)*.3;\n    \n    //c=n;\n    //c=vec3(c1);\n    \n    \n    //c.xy-=v;\n    //c.z*=.5;\n    //c=normalize(c);\n    ///c.g=length(c);\n    \n    //c.b+=c1;\n    //c=normalize(c);\n    \n    /*float near=0.;\n    for(float i=-1.;i<-2.;i++){\n    for(float i=-1.;i<-2.;i++){\n    \n    }\n    }*/\n    \n    //c=(c*.34567);\n    //c=getNormal(n);\n    //c=n;\n    float diff=clamp(dot(l,c),0.,1.);\n    //c=vec3(diff);\n    float dist=rayMarch(p+n*SURF_DIST*2.,l);\n    //diff=smoothstep(0.,texture(iChannel1,p.xy).r,diff);\n    if(dist<length(lightPos -p)) diff*=0.6;\n    return c;\n\n}\n\n/*\nfloat checkers( in vec3 p )\n{\n    vec2 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m=iMouse.xy/iResolution.xy;\n    \n    //camera 1\n   // vec3 ro=vec3(sin(iTime*.2)*2.,0.,cos(iTime*.2));//cos(iTime),5,sin(iTime)+iTime*1.);\n    vec3 ro=vec3(sin(iTime*1.2)*2.,cos(iTime*.5)*.8,5.);//cos(iTime),5,sin(iTime)+iTime*1.);\n    //ro.x-=2.+sin(3.14*rd.z*.06)*10.;\n    \n    //ro.yz*= rot(-m.y*3.14+1.);\n    //ro.xz*= rot(-m.x*6.28);\n       //ray diff\n    vec3 rd=getRayDir(uv,ro,vec3(0),1.);//normalize(vec3(uv.x,uv.y,1));\n    //rd.x-=2.+sin(3.14*rd.z*.06)*10.;\n    float dist=rayMarch(ro,rd);\n    \n    \n    vec3 point = ro +rd*dist;\n    vec3 diffuse=getLight(point,uv);\n\n    // Time varying pixel color\n    vec3 col = diffuse;//getNormal(point);//.99,.6,4.);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n        //col=vec3(diffuse);\n    //col=mix(col,vec3(1),vec3(diffuse));\n      // col.rg=texture(iChannel1,uv).rg;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}