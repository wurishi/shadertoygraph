{"ver":"0.1","info":{"id":"mdVyRG","date":"1696544048","viewed":231,"name":"Volumetric Raymarcher / Tracer","username":"Kryolyz","description":"Attempt at volumetric raymarching\nNo major optimizations besides texture lookup for noise. Could need some though\nRaytracing of light spheres and ground\nRaymarching of an SDF compound\n","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = texture(iChannel0, x).r * 1.5;\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\n\nfloat SDF(vec3 pos, float iTime)\n{    \n    vec3 fbmCoord = (pos + 2.0 * vec3(iTime * 6.0f, 0.0, iTime * 2.0)) / 120.0f;\n    float sdfValue = sdSphere(pos, vec3(0.0, 5.0, 0), 5.0) + 10.0 * fbm_4(fbmCoord);\n    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos), 35.0);\n    return sdfValue;\n}\n\nvec3 SDFNormal(vec3 pos, float iTime) {\n    vec2 e = vec2(SDF_NORMAL_DELTA, 0.0);\n    return normalize(vec3(\n        SDF(pos + e.xyy, iTime) - SDF(pos - e.xyy, iTime),\n        SDF(pos + e.yxy, iTime) - SDF(pos - e.yxy, iTime),\n        SDF(pos + e.yyx, iTime) - SDF(pos - e.yyx, iTime)\n    ));\n}\n\nfloat FindVolumeBoundary(Ray ray, float maxT, float iTime, out vec3 normal)\n{\n    float t = 0.0f;\n    float lastResult;\n    for(int i = 0; i < MAX_STEPS_SDF; ++i)\n    {\n\t    lastResult = SDF( ray.origin + ray.direction * t, iTime) * 1.5;\n        if( lastResult < (SURFACE_DIST) || t > maxT ) break;\n        t += lastResult;\n    }\n    \n    if (t >= maxT || lastResult > SURFACE_DIST)\n        return -1.0f;\n    else\n    {\n        normal = SDFNormal(ray.origin + ray.direction * t, iTime);\n        return t;\n    }\n}\n\nfloat GetLightVisiblity(Ray ray, float maxT, float iTime)\n{\n    float t = 0.0f;\n    float lightVisibility = 1.0f;\n    float signedDistance = 0.0;\n    for(int i = 0; i < MAX_STEPS_VOLUME_LIGHT; i++)\n    {                       \n        t += max(MARCH_STEP_SIZE_LIGHT, signedDistance);\n        if(t > maxT || lightVisibility < ABSORPTION_CUTOFF) break;\n\n        vec3 position = ray.origin + t * ray.direction;\n\n        signedDistance = SDF(position, iTime);\n        if(signedDistance < 0.0)\n        {\n            lightVisibility *= BeerLambert(ABSORPTION_COEFF * GetFogDensity(position, signedDistance), MARCH_STEP_SIZE_LIGHT);\n        }\n    }\n    return lightVisibility;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material mat;\n    mat = materials[materialID];\n    \n    switch (materialID)\n    {\n        case MATERIAL_GROUND:\n        {\n            vec2 uv = position.xz / 30.0;\n            uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n            if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n            {\n                mat.color = vec3(1, 1, 1) * 0.3;\n            }\n        }\n        break;\n    }\n   \n    return mat;    \n}\n\nvoid DepthCheck(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\n\nfloat TraceOpaqueObjects(Ray ray, out int materialID, out vec3 normal)\n{\n    float t = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n    \n    for (int i = 0; i < NUMBER_LIGHTS; ++i)\n    {\n        LightSource light = GetLight(i, iTime);\n        \n        DepthCheck(\n        t, \n        SphereIntersection(ray, light.position, light.radius, intersectionNormal),\n        intersectionNormal,\n        MATERIAL_LIGHT + i,\n        normal,\n        materialID);\n    }\n    \n    DepthCheck(\n        t,\n        PlaneIntersection(ray, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),\n        intersectionNormal,\n        MATERIAL_GROUND,\n        normal,\n        materialID);\n    \n    return t;\n}\n\n\nvec3 GammaCorrect(vec3 color) \n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvec3 Render(Ray ray)\n{\n    vec3 normal;\n    int materialID = MATERIAL_INVALID;\n    float t = TraceOpaqueObjects(ray, materialID, normal);\n    float depth = LARGE_NUMBER;\n    \n    if (materialID != MATERIAL_INVALID)\n    {\n        depth = t;\n    }\n    \n    vec3 volumeNormal;\n    float volumeDepth = FindVolumeBoundary(ray, depth, iTime, volumeNormal);\n    float opaqueVisibility = 1.0f;\n    vec3 volumeColor = vec3(0);\n    if (volumeDepth > 0.0f)\n    {\n        opaqueVisibility = 1.0f;\n        vec3 position = ray.origin + volumeDepth * ray.direction;\n        vec3 materialColor = GetMaterial(MATERIAL_VOLUME, position).color;\n        float distanceInVolume = 0.0f;\n        float signedDistance = 0.0;\n        for(int i = 0; i < MAX_STEPS_VOLUME; i++)\n        {\n            volumeDepth += max(MARCH_STEP_SIZE, signedDistance);\n            if(volumeDepth > depth || opaqueVisibility < ABSORPTION_CUTOFF) break;\n            \n            position = ray.origin + volumeDepth * ray.direction;\n\n            signedDistance = SDF(position, iTime);\n            if(signedDistance < 0.0f)\n            {\n                distanceInVolume += MARCH_STEP_SIZE;\n                float previousOpaqueVisiblity = opaqueVisibility;\n                opaqueVisibility *= BeerLambert(ABSORPTION_COEFF * GetFogDensity(position, signedDistance), MARCH_STEP_SIZE);\n                float absorptionFromMarch = previousOpaqueVisiblity - opaqueVisibility;\n                \n                for(int lightIndex = 0; lightIndex < NUMBER_LIGHTS; lightIndex++)\n    \t\t\t{\n                    float lightVolumeDepth = 0.0f;\n                    vec3 lightDirection = (GetLight(lightIndex, iTime).position - position);\n                    float lightDistance = length(lightDirection);\n                    lightDirection /= lightDistance;\n                    \n                    vec3 lightColor = GetLight(lightIndex, iTime).color * AttenuateLight(lightDistance); \n                    if(IsColorInsignificant(lightColor)) continue;\n                    \n                    Ray rayToLight = Ray(position, lightDirection);\n                    float lightVisiblity = GetLightVisiblity(rayToLight, lightDistance, iTime); \n                    volumeColor += absorptionFromMarch * lightVisiblity * materialColor * lightColor;\n                }\n                volumeColor += absorptionFromMarch * materialColor * GetAmbientLight();\n            }\n        }\n    }\n\n    vec3 color = vec3(0);\n    \n    if (materialID != MATERIAL_INVALID && opaqueVisibility > ABSORPTION_CUTOFF)\n    {\n        vec3 position = ray.origin + t * ray.direction;\n        Material material = GetMaterial(materialID, position);\n        \n        if((material.flags & MATERIAL_LIGHT_FLAG) != 0)\n        {\n            color = min(material.color, vec3(1.0));\n        }       \n        else\n        {\n            vec3 reflectionDirection = reflect( ray.direction, normal);\n            CalculateLighting(position, normal, reflectionDirection, material, iTime, color);\n        }\n    }\n    return color * opaqueVisibility + min(volumeColor, 1.0f);\n}\n\nCameraDescription Camera = CameraDescription(\n    vec3(0, 3, 100),\n    vec3(0, 3, 0),\n    2.0,\n    7.0\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    materials[MATERIAL_GROUND] = Material(vec3(1), 0);\n    materials[MATERIAL_VOLUME] = Material(vec3(1,1,1) * 0.8, 0);\n    for(int i = 0; i < NUMBER_LIGHTS; ++i)\n    {\n        LightSource light = GetLight(i, iTime);\n        materials[MATERIAL_LIGHT + i] = Material(light.color, MATERIAL_LIGHT_FLAG);\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - Camera.Position;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    mat3 viewMatrix = GetViewMatrix(iMouse, iResolution);\n    CameraView = CameraView * viewMatrix;\n    vec3 lensPoint = Camera.LookAt - CameraView * ViewLength;\n    \n    vec3 CameraRight = normalize(cross(CameraView, vec3(0, 1, 0)));    \n    vec3 CameraUp = normalize(cross(CameraRight, CameraView));\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    Ray ray;\n    ray.origin = focalPoint;\n    ray.direction = normalize(lensPoint - focalPoint);\n    \n    vec3 color = Render(ray);\n    fragColor = vec4( GammaCorrect(clamp(color, 0.0, 1.0)), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define EPSILON 1e-6\n#define SDF_NORMAL_DELTA 1e-3\n#define LARGE_NUMBER 1e20\n#define MATERIAL_GROUND 0\n#define MATERIAL_VOLUME 1\n#define MATERIAL_LIGHT 2\n#define MATERIAL_INVALID -1\n#define MATERIAL_LIGHT_FLAG 1\n#define NUMBER_LIGHTS 3\n#define NUMBER_MATERIALS NUMBER_LIGHTS+2\n\n// Play around with these\n#define AMBIENT_LIGHT_STRENGTH 0.0\n#define LIGHT_ATTENUATION_FACTOR 2.0f\n#define LIGHT_INTENSITY_MULTIPLIER 20.0f\n#define MAX_STEPS_SDF 20\n#define SURFACE_DIST 0.5\n#define MAX_STEPS_VOLUME 40\n#define ABSORPTION_CUTOFF 0.05\n#define ABSORPTION_COEFF 0.4\n#define MAX_FOG_DENSITY 1.0\n#define MAX_STEPS_VOLUME_LIGHT 6\n#define MARCH_SIZE_MULTIPLIER 1.0\n#define MARCH_STEP_SIZE 0.6 * MARCH_SIZE_MULTIPLIER\n#define MARCH_STEP_SIZE_LIGHT 0.65 * MARCH_SIZE_MULTIPLIER\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n\nmat3 GetViewMatrix(vec4 iMouse, vec3 iResolution)\n{\n    float camRotX = iMouse.x / iResolution.x;\n    float camRotY = iMouse.y / iResolution.y;\n    float xRotation = (( - camRotX * 2.0 + 1.0)) * PI;\n    float yRotation = ((camRotY * 0.29 - 0.2)) * PI;\n    mat3 cameraRotX = mat3(\n                cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n    mat3 cameraRotY = mat3( 1.0,           0.0, 0.0,\n                 0.0, cos(yRotation), -sin(yRotation),\n                 0.0, sin(yRotation), cos(yRotation));\n    mat3 viewMatrix = cameraRotY * cameraRotX;\n    return viewMatrix;\n}\n\nstruct Material\n{\n    vec3 color;\n    int flags;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct LightSource\n{  \n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\n// some random matrix for fbm\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(Ray ray, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) \n{ \n    float t = -1.0f;\n    normal = planeNormal;\n    float denom = dot(-planeNormal, ray.direction);\n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - ray.origin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n\n// http://kylehalladay.com/blog/tutorial/math/2013/12/24/Ray-Sphere-Intersection.html\nfloat SphereIntersection(Ray ray, in vec3 sphereCenter, in float sphereRadius, out vec3 normal)\n{\n      vec3 L = sphereCenter - ray.origin;\n      float tc = dot(L, ray.direction);\n      \n      if (tc < 0.0f)\n          return -1.0f;\n          \n      float d2 = dot(L,L) - (tc*tc);\n      float radius2 = sphereRadius * sphereRadius;\n      \n      if ( d2 > radius2)\n          return -1.0f;\n          \n      float t1c = sqrt( radius2 - d2 );\n      float t1 = tc - t1c;\n          \n      normal = normalize(ray.origin + ray.direction * t1 - sphereCenter);\n      return t1;\n}\n\nLightSource GetLight(int index, float iTime)\n{\n    LightSource orbLight;\n    \n    switch(index % NUMBER_LIGHTS)\n    {\n        case 0:\n            orbLight.color = vec3(0, 1.0, 1.0);\n            orbLight.position = vec3(6.0 + sin(1.0 * iTime) * 10.0, 20.0 + sin(iTime * 1.5) * 5.0, 4.0 + cos(iTime) * 5.0);\n            break;\n        case 1:\n            orbLight.color = vec3(1.0, 1.0, 0.0);\n            orbLight.position = vec3(-19, 20.0 + sin(2.0 * iTime) * 10.0,-1.0 + cos(2.0 * iTime) * 10.0);\n            break;\n        case 2:\n            orbLight.color = vec3(1.0, 0.0, 1.0);\n            orbLight.position = vec3(15.0 + sin(2.0 * iTime) * 5.0, 12.0, cos(2.0 * iTime) * 5.0);\n            break;\n    } \n\n    orbLight.radius = 0.8f;\n    orbLight.color *= LIGHT_INTENSITY_MULTIPLIER;\n    return orbLight;\n}\n\n\nMaterial materials[NUMBER_MATERIALS];\n\n\nfloat AttenuateLight(float d)\n{\n    return 1.0 / pow(d, LIGHT_ATTENUATION_FACTOR);\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvec3 GetAmbientLight()\n{\n\treturn AMBIENT_LIGHT_STRENGTH * vec3(0.03, 0.018, 0.018);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, float iTime, inout vec3 color)\n{\n    for(int i = 0; i < NUMBER_LIGHTS; ++i)\n    {\n        vec3 lightDirection = (GetLight(i, iTime).position - position);\n        float lightDistance = length(lightDirection);\n        lightDirection /= lightDistance;\n\n        vec3 lightColor = GetLight(i, iTime).color * AttenuateLight(lightDistance); \n        \n        color += lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n        color += lightColor * Diffuse(normal, lightDirection, material.color);\n    \n    }\n    color += GetAmbientLight() * material.color;\n}\n\nfloat sdSphere(vec3 p, vec3 origin, float s)\n{\n  p = p - origin;\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat BeerLambert(float absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nfloat GetFogDensity(vec3 position, float sdfDistance)\n{\n    bool insideSDF = sdfDistance < 0.0;\n    return insideSDF ? min(abs(sdfDistance), MAX_FOG_DENSITY) : 0.0;\n}\n\nfloat Luminance(vec3 color)\n{\n    return (color.r * 0.3) + (color.g * 0.59) + (color.b * 0.11);\n}\n\nbool IsColorInsignificant(vec3 color)\n{\n    const float minValue = 0.005;\n    return Luminance(color) < minValue;\n}\n","name":"Common","description":"","type":"common"}]}