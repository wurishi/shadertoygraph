{"ver":"0.1","info":{"id":"WsscDl","date":"1585853122","viewed":290,"name":"hollow","username":"JabberSnatch","description":"yet another experiment","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["noise","volume","clouds","fire","glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//https://gizma.com/easing/\nfloat ease(float a, float b, float t)\n{\n\tt *= 2.0;\n\tif (t < 1.0) return (b-a)/2.0*t*t*t + a;\n\tt -= 2.0;\n\treturn (b-a)/2.0*(t*t*t + 2.0) + a;\n}\n\nfloat pulse(float time, float bpm, float signature, float offset)\n{\n\treturn fract((time * bpm) / (60.0 * signature) - offset);\n}\n\nfloat cycle(float time, float bpm, float signature, float release, float offset)\n{\n\tfloat pulse = pulse(time, bpm, signature, offset);\n\treturn step(pulse, release) * (pulse / release);\n}\n\nfloat envelope(float t, float attack, float decay, float sustain)\n{\n\tfloat attack_segment = (t / attack) * step(t, attack);\n\tfloat decay_segment = mix(1.0, sustain, (t-attack)/decay) * step(t-attack, decay) * step(attack, t);\n\tfloat sustain_segment = sustain * step(decay, t-attack);\n\treturn attack_segment + decay_segment + sustain_segment;\n}\n\n\nvec3 hash3(vec3 p)\n{\n    mat3 seed = mat3(742.342, 823.457, 242.086,\n                     247.999, 530.343, 634.112,\n                     437.652, 139.485, 484.348);\n\n    return fract(seed * sin(p)) * 2.0 - vec3(1.0);\n}\n\n\nfloat noise3(vec3 p)\n{\n    float f = (sqrt(4.0) - 1.0) / 3.0;\n    mat3 skew = mat3(1.0 + f, f, f,\n                     f, 1.0 + f, f,\n\t\t\t\t\t f, f, 1.0 + f);\n    float g = (1.0 - 1.0/sqrt(4.0)) / 3.0;\n    mat3 invskew = mat3(1.0-g, -g, -g,\n                        -g, 1.0-g, -g,\n\t\t\t\t\t\t-g, -g, 1.0-g);\n\n    vec3 sp = skew * p;\n    vec3 cell = floor(sp);\n    vec3 d0 = fract(sp);\n\n    float x0 = step(d0.x, d0.y);\n\tfloat x1 = step(d0.y, d0.z);\n\tfloat x2 = step(d0.z, d0.x);\n    vec3 s0 = vec3(x2*(1.-x0), x0*(1.-x1), x1*(1.-x2));\n    vec3 s1 = min(vec3(1.0), vec3(1.0) + vec3(x2-x0, x0-x1, x1-x2));\n\n    vec3 sv[4] = vec3[4](cell,\n                         cell + s0,\n                         cell + s1,\n                         cell + vec3(1.0));\n    vec3 wv[4] = vec3[4](invskew * sv[0],\n                         invskew * sv[1],\n                         invskew * sv[2],\n                         invskew * sv[3]);\n    vec3 d[4] = vec3[4](p - wv[0],\n                        p - wv[1],\n                        p - wv[2],\n                        p - wv[3]);\n\n    vec4 weights = max(vec4(0.0), vec4(0.6) - vec4(dot(d[0], d[0]),\n                                                   dot(d[1], d[1]),\n                                                   dot(d[2], d[2]),\n                                                   dot(d[3], d[3])));\n    weights = weights * weights * weights * weights;\n\n    return (dot(hash3(sv[0]), d[0]) * weights[0] +\n            dot(hash3(sv[1]), d[1]) * weights[1] +\n            dot(hash3(sv[2]), d[2]) * weights[2] +\n            dot(hash3(sv[3]), d[3]) * weights[3]) * 16.0;\n}\n\nvec3 target_half_diagonal_hfov(float n, float alpha, float aspect)\n{\n\tfloat half_width = tan(alpha * 0.5) * n;\n\tfloat half_height = half_width * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\nvec3 target_half_diagonal_vfov(float n, float alpha, float aspect)\n{\n\tfloat half_height = tan(alpha * 0.5) * n;\n\tfloat half_width = half_height * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\n\nvec3 compute_ray_plane(vec3 half_diagonal, vec2 clip_coord)\n{\n\tvec3 target = half_diagonal * vec3(clip_coord, 1.0);\n\treturn normalize(target);\n}\n\nfloat sample_noise(vec3 p, float octave)\n{\n    float cv = (cycle(iTime, 60.0, 1.0, 0.5, 0.5) + cycle(iTime, 13.44, 1.0, 1.0, 0.25))/2.0;\n    float ev = ease(19.0, 20.0, envelope(cv, 0.25, 0.4, 0.4));\n\n    float density = 0.0;\n    float max_i = exp2(octave);\n    float bd = ev;\n    float expo = 0.3;\n    float scale = 4.5;\n    float offset = +0.115;\n    float of = 1.2;\n\n    vec3 d2 = hash3(vec3(-1.0, -13.0, 0.0)) * iTime * 2.25;\n\n    for (float i = 1.0; i < max_i; i *= 2.0)\n        density += (bd * pow((noise3(((p*scale + d2/(i*of))*i)) + offset), expo)) / i;\n\n    return max(0.0, density);\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n\tfloat aspect_ratio = iResolution.y / iResolution.x;\n\tfloat fov = 85.0 * 3.1415926536 / 180.0;\n\tfloat near = 0.1;\n\tvec3 half_diagonal = target_half_diagonal_vfov(near, fov, 1.0/aspect_ratio);\n\tvec2 clip_coord = ((frag_coord / iResolution.xy) - 0.5) * 2.0;\n\n    mat3 view = mat3(cos(iTime), -sin(iTime), 0.0,\n                     sin(iTime), cos(iTime), 0.0,\n                     0.0, 0.0, 1.0);\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n\tvec3 rd = compute_ray_plane(half_diagonal, clip_coord);\n\n    vec3 pc = ro + dot(rd, -ro) * rd;\n    float x0 = length(pc);\n    float x1 = 1.0 - x0*x0;\n    float x2 = length(pc - ro) - x1;\n\n    vec3 i0 = ro + rd*x2;\n    vec3 i1 = i0 + 2.0*(pc - i0);\n\n    float t0 = x2;\n    float t1 = length(ro - i1);\n\n    float stepcount = 8.0;\n    float dt0 = (t1-t0)/stepcount;\n    float t = 0.0;\n    float density = 0.0;\n    float i;\n\n    //vec3 Ld = normalize(vec3(0.2 * cos(iTime), 0.2 * sin(iTime), 0.1));\n    //vec3 Ld = normalize(vec3(0.0, 0.1, 0.1));\n    vec3 Ld = normalize(vec3(0.2 * cos(1.0), 1.0, 0.2 * sin(1.0)));\n\n    vec3 Lo = vec3(0.0);\n\n    vec3 Li_sky = vec3(0.7, 0.35, 0.12) * 1.2;\n    vec3 Li_light = vec3(0.97, 0.95, 0.92) * 1.5;\n\n    float st0_count = stepcount + 1.0;\n    float Tr0 = 1.0;\n    float St0 = 0.0;\n\n    for (i = 0.0; i < st0_count; i += 1.0)\n    {\n        float tx = iTime;\n        float bpm = 20.0;\n        float cv =(\n            cycle(tx, bpm, 1.0, 0.05, 0.6) +\n            //cycle(tx, bpm, 1.0, 0.2, 0.0) +\n            cycle(tx, bpm, 1.33, 0.05, 0.1)) / 3.0;\n        float ev0 = ease(0.05, 3.0, envelope(cv, 0.1, 0.8, 0.003));\n\n        t = t0 + dt0*i*\n            (1.0 -\n             hash3(vec3(fract(frag_coord*iTime*1.5), iTime*20.0)).y\n             *ev0);\n        vec3 p = ro + t*rd;\n\n        float st0 = sample_noise(p, 3.0);\n        St0 += st0 * dt0;\n\n        float t_max = 2.0;\n        {\n            vec3 pc = p + dot(Ld, -p) * Ld;\n            float x0 = length(pc);\n            float x1 = 1.0 - x0*x0;\n            float x2 = length(pc - p) - x1;\n            vec3 i0 = ro + rd*x2;\n            vec3 i1 = i0 + 2.0*(pc - i0);\n            float t0 = x2;\n            float t1 = length(ro - i1);\n            t_max = t1/2.0;\n        }\n\n        float st1_count = 64.0;\n        float dt1 = (t_max / st1_count);\n        float Tr1 = 1.0;\n        float St1 = 0.0;\n        for (float j = 0.0; j < st1_count; ++j)\n        {\n            float st1_t = (j + 1.0 + 0.152*(hash3(vec3(frag_coord*0.001, 0.0)).x * 0.5 + 0.5))*dt1;\n\n            vec3 p1 = p + Ld*st1_t;\n            float st1 = 0.0;\n            if (length(p1) <= 1.0)\n                st1 = sample_noise(p1, 1.0);\n            else\n            {\n                float Tr2 = exp(-(St1+St0));\n                Lo += (Tr2 * Li_sky * st0 * dt0);\n                break;\n            }\n\n            St1 += st1 * dt1;\n        }\n\n        Tr1 = exp(-(St1+St0));\n        Lo += (Tr1 * Li_light * st0 * dt0);\n    }\n\n    Tr0 = exp(-St0);\n    Lo += (Tr0 * Li_sky);\n\n    frag_color.xyz = Lo;\n}\n\n","name":"Image","description":"","type":"image"}]}