{"ver":"0.1","info":{"id":"ctcBRn","date":"1700839496","viewed":73,"name":"WaterPool","username":"rubatotree","description":"A Swimming Pool made with noises","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise","voronoinoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float get_height(vec3 uvt) { return perlin_fbm(uvt, 2, 3, 0.4); }\n\nvec2 get_gredient(vec3 uvt)\n{\n    const float prec = 0.01;\n    float   h = get_height(uvt),\n            xh = get_height(uvt + vec3(prec, 0.0, 0.0)),\n            yh = get_height(uvt + vec3(0.0, prec, 0.0));\n    return -vec2((xh - h) / prec, (yh - h) / prec);\n}\n\nvec2 coord_to_uv(vec2 coord) { return coord / max(iResolution.x, iResolution.y); }\n\nvec3 light_mix(vec3 col, float lightness) { return col * (lightness * 1.2 + 0.3); }\n\nfloat convex_and_clip(float t, float ind)\n{\n    if(t <= 0.0) return 0.0;\n    if(t >= 1.0) return 1.0;\n    return 1.0 - abs(pow(t - 1.0, ind));\n}\n\nfloat ring_curve(float t)\n{\n    return convex_and_clip((abs(1.0 / sin(t)) - 1.0) * 0.05, 1.0);\n}\n\nfloat voronoi_cut(float t)\n{\n    return t * 1.4;\n}\n\n\nvec3 poolColor(vec2 uv)\n{\n    vec3 uv_t = vec3(uv, 0.0);\n\n    float grid_size = 1.0 / 20.0;\n    vec2 grid = floor(uv / grid_size);\n    vec2 coord = uv / grid_size - grid;\n    vec3 noise_coord = vec3(coord, grid.x + grid.y * 327.0) * 1.1;\n    vec4 voronoi_region = voronoi_with_region(noise_coord, 1);\n    float val = hash33(voronoi_region.yzw).x * 0.5 + 0.1 * voronoi_region.x;\n    vec3 base_col1 = vec3(11.0, 74.0, 172.0) / 255.0;\n    vec3 base_col2 = vec3(131.0, 175.0, 224.0) / 255.0 * 0.5 + vec3(0.8);\n    vec3 col = hsv2rgb(rgb2hsv(hash33(voronoi_region.xyz)) * vec3(0.1, 0.3, 0.2) + vec3(0.56, 0.2, 0.6));\n    if(min(coord.x, coord.y) <= 0.1) col = vec3(1.0);\n    //vec3 reg = voronoi_with_region(uv_t, 4).yzw;\n    //col = hash33(reg);\n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = coord_to_uv(fragCoord);\n    vec2 uv_mouse = coord_to_uv(iMouse.xy);\n    vec3 uvt = vec3(uv.x * 1.6, uv.y * 2.0 + iTime * 0.3, iTime * 0.3);\n    float height = get_height(uvt);\n    vec2 shake = get_gredient(uvt * 0.4) * 0.005;\n    vec3 dlight = normalize(vec3(0.0, -0.8, 0.9));\n    vec3 normal = normalize(vec3(get_gredient(uvt * 2.0), 20.0));\n    float lightness = dot(dlight, normal);\n\n    vec3 col = poolColor((uv + shake) * 0.5 + 0.25);\n    //vec3 col = texture(iChannel0, uv + shake).rgb;\n    col += voronoi_cut(voronoi(vec3(uv.x * 0.8, uv.y, iTime * 0.5), 4)) * 0.3;\n\n    col += vec3(1.0) * step(1.2, lightness + height) * 0.9;\n    col += vec3(clamp(height - 0.3, -0.3, 1.0) * 0.5);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//copy from https://zhuanlan.zhihu.com/p/599263679\nfloat hash11(float p) { p = fract(p * .1031); p *= p + 33.33; p *= p + p; return fract(p); }\nfloat hash21(vec2 p) { vec3 p3  = fract(vec3(p.xyx) * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nfloat hash31(vec3 p3) { p3  = fract(p3 * .1031); p3 += dot(p3, p3.zyx + 31.32); return fract((p3.x + p3.y) * p3.z); }\nvec2 hash12(float p) { vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.xx+p3.yz)*p3.zy); }\nvec2 hash22(vec2 p) { vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx+33.33); return fract((p3.xx+p3.yz)*p3.zy); }\nvec2 hash32(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx+33.33); return fract((p3.xx+p3.yz)*p3.zy); }\nvec3 hash13(float p) { vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx+33.33); return fract((p3.xxy+p3.yzz)*p3.zyx); }\nvec3 hash23(vec2 p) { vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz+33.33); return fract((p3.xxy+p3.yzz)*p3.zyx); }\nvec3 hash33(vec3 p3){ p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz+33.33); return fract((p3.xxy + p3.yxx)*p3.zyx); }\nvec4 hash14(float p) { vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099)); p4 += dot(p4, p4.wzxy+33.33); return fract((p4.xxyz+p4.yzzw)*p4.zywx); }\nvec4 hash24(vec2 p) { vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099)); p4 += dot(p4, p4.wzxy+33.33); return fract((p4.xxyz+p4.yzzw)*p4.zywx); }\nvec4 hash34(vec3 p) { vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099)); p4 += dot(p4, p4.wzxy+33.33); return fract((p4.xxyz+p4.yzzw)*p4.zywx); }\nvec4 hash44(vec4 p4) { p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099)); p4 += dot(p4, p4.wzxy+33.33); return fract((p4.xxyz+p4.yzzw)*p4.zywx); }\n\nfloat luminance(vec3 col) { return dot(vec3(0.2125, 0.7154, 0.0721), col); }\n\n vec3 rgb2hsv(vec3 col) {\n    float h = 0.0;\n    float s = 0.0;\n    float v = 0.0;\n    float min = min( min(col.r, col.g), col.b );\n    float max = max( max(col.r, col.g), col.b );\n    v = max;\n\n    float delta = max - min;\n    if( max != 0.0 )\n        s = delta / max;       // s\n    else {\n         // r = g = b = 0       // s = 0, v is undefined\n        s = 0.0;\n        h = -1.0;\n        return vec3(h, s, v);\n     }\n     if( col.r == max )\n         h = ( col.g - col.b ) / delta;     // between yellow & magenta\n     else if( col.g == max )\n         h = 2.0 + ( col.b - col.r ) / delta;   // between cyan & yellow\n     else\n         h = 4.0 + ( col.r - col.g ) / delta;   // between magenta & cyan\n\n     h = h * 60.0;              // degrees\n\n     if( h < 0.0 )\n         h += 360.0;\n\n     return vec3(h / 360.0, s, v);\n }\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat smooth_curve(float x) { return 6.0 * x * x * x * x * x - 15.0 * x * x * x * x + 10.0 * x * x * x; }\n\nfloat Gauss(float dist) { return exp(-10.0 * dist * dist); }\nfloat Gauss_sq(float dist_sq) { return exp(-10.0 * dist_sq); }\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nconst vec3 SHIFT_LIST_3[8] = vec3[8](\n    vec3(0.0, 0.0, 0.0),\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 1.0, 1.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 1.0, 1.0)\n);\n\n\nvec3 NOISE_mod3(vec3 src, float modn) { return fract(src / modn) * modn; }\n\nfloat perlin(vec3 uvt, int grid_n)\n{\n    vec3 grid = floor(uvt * float(grid_n)), coord = fract(uvt * float(grid_n));\n    float val = 0.0;\n    float prod[8] = float[8](0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 vpos = grid + SHIFT_LIST_3[i];\n        #ifdef TILED\n        vpos = NOISE_mod3(vpos, float(grid_n));\n        #endif\n        vec3 vgrad = hash33(vpos) * 2.0 - vec3(1.0);\n        vec3 vdir = coord - SHIFT_LIST_3[i];\n        prod[i] = dot(vgrad, vdir);\n    }\n    vec3 coord_smooth = vec3(smooth_curve(coord.x), smooth_curve(coord.y), smooth_curve(coord.z));\n    val = mix(\n        mix(\n            mix(prod[0], prod[1], coord_smooth.x),\n            mix(prod[2], prod[4], coord_smooth.x),\n            coord_smooth.y\n        ),\n        mix(\n            mix(prod[3], prod[6], coord_smooth.x),\n            mix(prod[5], prod[7], coord_smooth.x),\n            coord_smooth.y\n        ),\n        coord_smooth.z\n    );\n    return val * 2.0;\n}\n\nfloat perlin_fbm(vec3 uv, int grid_n, int steps, float presistance)\n{\n    float val = 0.0, sum = 0.0, ampl = 1.0;\n    int freq = grid_n;\n    for(int i = 0; i < steps; i++)\n    {\n        sum += ampl;\n        val += perlin(uv * float(freq), grid_n) * ampl;\n        freq *= 2;\n        ampl *= presistance;\n    }\n    return val / sum;\n}\n\nvec4 voronoi_with_region(vec3 uvt, int grid_n)\n{\n    vec3 grid = floor(uvt * float(grid_n)), coord = fract(uvt * float(grid_n));\n    float val = 0.0;\n    float min_dist = 100.0;\n    vec3 min_sample;\n    for(int i = -1; i <= 1; i++)\n        for(int j = -1; j <= 1; j++)\n            for(int k = -1; k <= 1; k++)\n            {\n                vec3 shift = vec3(i, j, k);\n                vec3 vpos = grid + shift;\n                #ifdef TILED\n                vpos = mod3(vpos, float(grid_n));\n                #endif\n                \n                vec3 sample_point = hash33(vpos);\n                float dist = length(shift + sample_point - coord);\n                if(dist < min_dist)\n                {\n                    min_sample = vpos;\n                    min_dist = dist;\n                }\n            }\n    return vec4(min_sample, min_dist);\n}\n\nfloat voronoi(vec3 uvt, int grid_n) { return voronoi_with_region(uvt, grid_n).w; }\n\nfloat voronoi_fbm(vec3 uv, int grid_n, int steps, float presistance)\n{\n    float val = 0.0, sum = 0.0, ampl = 1.0;\n    int freq = grid_n;\n    for(int i = 0; i < steps; i++)\n    {\n        sum += ampl;\n        val += voronoi(uv * float(freq), grid_n) * ampl;\n        freq *= 2;\n        ampl *= presistance;\n    }\n    return val / sum;\n}\n","name":"Common","description":"","type":"common"}]}