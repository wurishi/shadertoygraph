{"ver":"0.1","info":{"id":"7tBSRt","date":"1628343511","viewed":142,"name":"PT Specular Material","username":"playbyan1453","description":"Blazing fast, most basic one using montecarlo intergration without direct light sampling or multiple importance sampling or russian roulettes.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    col = max(col, 0.0);\n    col = pow(col/(col+1.0), vec3(0.5));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Monterman code is easy to follow and made path tracing is easy for me\n// This shader is going trough alot of revision, more improvement soon.\n// Monterman's Original code: https://www.shadertoy.com/view/4dyBRK\n#define tmax 1e19\n#define epsilon 1e-4\n#define bounces 4\n#define depthoffield\n\nstruct material {\n    vec3 albedo;\n    vec3 emission;\n    float specular;\n    float roughness;\n};\n\n// Checkboard pattern\nfloat checkboard(vec2 p) {\n    p = floor(p);\n    return mod(p.x + p.y, 2.0);\n}\n\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p) {\n    p = 1103515245u*((p >> 1u)^(p.yx));\n    uint h32 = 1103515245u*((p.x)^(p.y>>3u));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=0.1,seed+=0.1)));\n    return float(n)/float(0xffffffffu);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=0.1,seed+=0.1)));\n    uvec2 rz = uvec2(n, n*48271u);\n    return vec2(rz.xy & uvec2(0x7fffffffu))/float(0x7fffffff);\n}\n\n// Intersectors by iq\nfloat sphere(vec3 ro, vec3 rd, vec3 p, float r, out vec3 n) {\n    vec3 o = ro - p;\n    float b = dot(o, rd);\n    float c = dot(o, o) - r * r;\n    float d = b * b - c;\n    if(d < 0.0) return tmax;\n    d = sqrt(d);\n    float f = c > epsilon ? 1.0 : -1.0;\n    float t = -b - f * d;\n    n = normalize(o + rd * t) * f;\n    return t;\n}\n\nfloat plane(vec3 ro, vec3 rd, float h, inout vec3 n) {\n    float d = dot(rd, n);\n    float t = -(dot(ro, n) - h) / d;\n    n = d > 0.0 ? -n : n;\n    return t;\n}\n\n// Fizzer's lambert without tangent: http://www.amietia.com/lambertnotangent.html\nvec3 lambertDistrib(vec3 nor, inout float seed) {\n    vec2 uv = hash2(seed) * vec2(2.0, 6.283185307179586) - vec2(1, 0);\n    vec3 spherePoint = vec3(sqrt(1.0 - uv.x * uv.x) * vec2(cos(uv.y), sin(uv.y)), uv.x);\n    return normalize(nor + spherePoint);\n}\n\n// Random in disk\nvec2 randInUnitDisk(inout float seed) {\n    vec2 uv = hash2(seed) * vec2(1.0, 6.283185307179586);\n    return sqrt(uv.x) * vec2(sin(uv.y), cos(uv.y));\n}\n\nvec3 skyCol(vec3 rd) {\n    return pow(texture(iChannel1, rd).xyz, vec3(2));\n}\n\nvec3 pathtrace(vec3 ro, vec3 rd, inout float seed) {       \n    vec3 col = vec3(0);\n    vec3 atten = vec3(1);\n    vec3 nor;\n    // added 2 more bounces in case 0 bounces results in black output\n    for(int i = 0; i < bounces+2; i++) {\n        float tmin = tmax;\n        material mat;\n        vec3 s0Pos = vec3(0);\n        vec3 s0N;\n        float s0 = sphere(ro, rd, s0Pos, 1.0, s0N);\n        if(s0 > epsilon && tmin > s0) {\n            tmin = s0;\n            nor = s0N;\n            mat = material(vec3(0.95), vec3(0), 1.0, 0.5);\n        }\n        vec3 s1Pos = vec3(3.5, 2.8,-0.5);\n        vec3 s1N;\n        float s1 = sphere(ro, rd, s1Pos, 1.0, s1N);\n        if(s1 > epsilon && tmin > s1) {\n            tmin = s1;\n            nor = s1N;\n            mat = material(vec3(0), vec3(10), 0.0, 0.0);\n        }\n        vec3 p0N = normalize(vec3(0, 1, 0));\n        float p0 = plane(ro, rd,-1.0, p0N);\n        if(p0 > epsilon && tmin > p0) {\n            tmin = p0;\n            nor = p0N;\n            mat = material(mix(vec3(0.55), vec3(0.95), checkboard((ro+rd*p0).xz)), vec3(0), 0.0, 0.0);\n        }\n        if(tmin > epsilon && tmin < tmax) {\n            col += atten * mat.emission;\n            atten *= mat.albedo;\n            vec3 dif = lambertDistrib(nor, seed);\n            \n            ro = ro + rd * tmin;\n            rd = hash1(seed) < mat.specular ? normalize(mix(reflect(rd, nor), dif, mat.roughness*mat.roughness)) : dif;\n        } else {\n            col += atten * skyCol(rd);\n            break;\n        }\n    }\n    return col;\n}\n\nmat3 cam(vec3 at, vec3 ro) {\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    float seed = float(baseHash(floatBitsToUint(uv) - uint(iFrame)))/float(0xffffffffu);\n    vec2 rnd = randInUnitDisk(seed);\n    uv += 1.5 * rnd / max(iResolution.x, iResolution.y);\n    \n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = vec3(0, 0,-6);\n    mat3 ca = cam(at, ro);\n    vec3 rd = ca * normalize(vec3(uv, 1));\n    \n    #ifdef depthoffield\n    // DOF correct focus plane\n    vec3 p = normalize(at - ro);\n    float d = -(dot(p, ro - p) + 6.8);\n    float t = -(dot(ro, p) + d) / dot(rd, p);\n    vec3 fp = ro + rd * t;\n    ro += ca * vec3(rnd, 0) * 0.05;\n    rd = normalize(fp - ro);\n    #endif\n    \n    vec3 prev_col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    vec3 col = pathtrace(ro, rd, seed);\n    \n    fragColor = vec4((prev_col * float(iFrame) + col) / float(iFrame + 1), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}