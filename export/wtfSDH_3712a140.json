{"ver":"0.1","info":{"id":"wtfSDH","date":"1562718870","viewed":280,"name":"Pixel Particle Engine","username":"rory618","description":"Jump flood based pixel drawing, now with colored particles. Demonstrating the engine with a pseudo 3D color histogram based on https://www.shadertoy.com/view/XlG3Dz by flyguy but with greater resolution.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["3d","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n\n    O = texture(iChannel3,I/R.xy);\n    if(O.w>=1.){ O /= O.w;} else { O += .3*texture(iChannel2,I/R.xy);}\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define cam (vec3(0.,0.,.21))\n#define theta ((iMouse.yx/iResolution.yx-.5)*vec2(-4,4))\n#define transform (mat4(1,0,-cam.x/cam.z,0,0,1,-cam.y/cam.z,0,0,0,1,0,0,0,-1./cam.z,1)*(mat4(cos(theta.y),0,-sin(theta.y),0,0,1,0,0,sin(theta.y),0,cos(theta.y),0,0,0,0,1)*mat4(1,0,0,0,0,cos(theta.x),sin(theta.x),0,0,-sin(theta.x),cos(theta.x),0,0,0,0,1)))\n\n\n//Particle buffer\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec3 c = texture(iChannel0, I/R.xy).xyz;\n    vec2 coord = R.xy*(((vec4(c-.5,1)*(transform))).xyz*vec3(R.y/R.x,1,-1)+.5).xy;\n    particle p = particle(false, coord, c);\n    O.xy = packParticle(p);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define iR ivec3(R)\n#define uR uvec3(R)\n#define IHash3(x,y,z) IHash(int(x)^IHash(int(y)^IHash(int(z))))\n#define dot2(o) dot((o),(o))\n#define tx(ch,p,R) texelFetch(ch, Zmod(p,iR.xy),0)\n\n//Roboust/universal integer modulus function\n#define Zmod(x,y) (((x)+(y)+(y)+(y))-(((x)+(y)+(y)+(y))/(y))*(y))\n//#define Zmod(x,y) ((x+y*10)%y)\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nstruct particle {\n    bool nil;\n    vec2 coord;\n    vec3 color;\n};\n    \nvec2 packParticle(particle p){\n    uvec2 px = uvec2(p.coord);\n    uvec3 c = uvec3(p.color * 7000. + 1000.);\n    uint n = uint(p.nil);\n    uint x = px.x & 0x7FFu;\n    uint y = px.y & 0x7FFu;\n    uint r = c.r & 0x1FFFu;\n    uint g = c.g & 0x1FFFu;\n    uint b = c.b & 0x1FFFu;\n    uint A = (b >> 9) | (g << 4) | (r << 17) | (n << 30);\n    uint B = (y) | (x << 11) | ((b & 0x1FFu) << 22);\n    return vec2(uintBitsToFloat(A),uintBitsToFloat(B));\n}\nparticle unpackParticle(vec2 p){\n    uint A = floatBitsToUint(p.x);\n    uint B = floatBitsToUint(p.y);\n    uint n = (A >> 30) & 0x1u;\n    uint r = (A >> 17) & 0x1FFFu;\n    uint g = (A >> 4) & 0x1FFFu;\n    uint b = ((B >> 22) & 0x1FFu) | ((A & 0xFu) << 9);\n    uint y = B & 0x7FFu;\n    uint x = (B >> 11) & 0x7FFu;\n    return particle(bool(n), vec2(x,y)+.5,(vec3(r,g,b)-1000.)/7000.);\n}\n\n#define mapping_iters 2\nvec2 forward_mapping(vec2 Z,vec3 R, int seed){\n    int p = int(R.x);\n    int q = int(R.y);\n    \n    int x=int(Z.x);\n    int y=int(Z.y);\n    \n    for(int i = 0; i < mapping_iters; i++){\n        x = Zmod(x + IHash(y^seed)%p,p);\n        y = Zmod(y + IHash(x^seed)%q,q);\n    }\n        \n    return vec2(x,y)+.5;\n    \n}\nvec2 reverse_mapping(vec2 Z,vec3 R, int seed){\n    \n    int p = int(R.x);\n    int q = int(R.y);\n    \n    int x=int(Z.x);\n    int y=int(Z.y);\n    \n    for(int i = 0; i < mapping_iters; i++){\n        x = Zmod(x - IHash(y^seed)%p,p);\n        y = Zmod(y - IHash(x^seed)%q,q);\n    }\n        \n    return vec2(x,y)+.5;\n}\n\nfloat score(particle p, vec2 I, vec3 R, int seed){\n    if(p.nil) return 1e6;\n    \n    vec2 Z = forward_mapping(p.coord, R, seed);\n    \n    vec2 D = Z-I;\n    D = mod(D+R.xy/2.,R.xy)-R.xy/2.;\n    return max(abs(D.x),abs(D.y));\n    \n}\n\n//Update ranking, save a list of two particle xy indices. O.xy is better particle, O.zw is a different not as good one\nvoid updateRank2x(particle n, inout vec4 O, inout float s0, inout float s1, vec2 I, vec3 R,int seed){\n    float sn = score(n,I,R,seed);\n    if(sn<s0){\n        //Shift down the line\n        s1=s0;\n        O.zw=O.xy;\n        s0=sn;\n        O.xy=packParticle(n);\n    } else if(sn<s1){\n        //Bump off the bottom one\n        s1=sn;\n        O.zw=packParticle(n);\n        \n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    //Split frames into 7 stages\n    int stage = iFrame%7;\n    int seed = iFrame/7;\n    int size = int(.5+pow(3.,float(6-stage)));\n    \n    \n    float s0;\n    float s1;\n    //init with top left corner and center\n    if(stage==0){\n        vec2 u0 = tx(iChannel0, ivec2(I)-size,R).xy;\n        vec2 u1 = tx(iChannel0, ivec2(I),R).xy;\n        particle p0 = unpackParticle(u0);\n        particle p1 = unpackParticle(u1);\n                                                                         \n        s0 = score(p0,I,R,seed);\n        s1 = score(p1,I,R,seed);\n        \n        O.xy=u0;\n        O.zw=u1;\n        \n        //Select the better one, make sure scores are in order with s0<s1\n        if(s0>s1){\n            vec2 _ = O.xy;\n            O.xy = O.zw;\n            O.zw = _;\n            _.x = s0;\n            s0 = s1;\n            s1 = _.x;\n        }\n    } else {\n        O = tx(iChannel1, ivec2(I)-size,R );\n        particle p0 = unpackParticle(O.xy);\n        particle p1 = unpackParticle(O.zw);\n        s0 = score(p0,I,R,seed);\n        s1 = score(p1,I,R,seed);\n    }\n    for(int i = 1; i < 9; i++){\n        if(stage==0){\n        \tvec2 u = tx(iChannel0,ivec2(I)-size+size*ivec2(i/3,i%3),R).xy;\n            particle p = unpackParticle(u);\n            updateRank2x(p,O,s0,s1,I,R,seed);\n            \n        } else {\n        \tvec4 t;\n            vec4 u = tx(iChannel1,ivec2(I)-size+size*ivec2(i/3,i%3),R); \n            particle p0 = unpackParticle(u.xy);\n            particle p1 = unpackParticle(u.zw);\n            updateRank2x(p0,O,s0,s1,I,R,seed);\n            updateRank2x(p1,O,s0,s1,I,R,seed);\n        }\n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    O = texture(iChannel0,I/R.xy);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void splat(inout vec4 O, vec2 I, particle p){\n    if(floor(I) == floor(p.coord) && !p.nil){\n        O += vec4(p.color,1); \n    }\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n\n    O = vec4(0);\n    int seed = iFrame/7;\n    \n    if(iFrame%7==6){\n        for(int i = 0; i < 9; i++){\n            vec2 ip = forward_mapping(I-1.+vec2(i/3,i%3),R,seed);\n            vec4 t = texelFetch(iChannel1,ivec2(ip),0);\n            \n\n            splat(O,I,unpackParticle(t.xy));\n            splat(O,I,unpackParticle(t.zw));\n\n\n        }\n    } else {\n        O = texture(iChannel3,I/R.xy);\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}