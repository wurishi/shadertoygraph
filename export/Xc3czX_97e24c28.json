{"ver":"0.1","info":{"id":"Xc3czX","date":"1730977370","viewed":99,"name":"Link tunnel","username":"Chriscamplin","description":"Concentric link, domain repeated along the z-axis","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","repetition"],"hasliked":0,"parentid":"lf3czB","parentname":"PBR Concentric tori"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.0001\n\n#define PI 3.14159265359\n\n\n// Custom gradient - https://iquilezles.org/articles/palettes/\nvec3 palette(float t) {\n        return .5+.5*cos((PI*2.0)*(t+vec3(.4,.2,.1)));\n}\n\n//sdLink - exact=https://iquilezles.org/articles/distfunctions/\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n// Rotation function for 3D vectors around an arbitrary axis\nvec3 rotate3d(vec3 p, vec3 axis, float angle) {\n    axis = normalize(axis);\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return p * cosAngle + cross(axis, p) * sinAngle + axis * dot(axis, p) * (1.0 - cosAngle);\n}\n\n// Smooth min function (smin)\nfloat smin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n// 3D rotation around the X-axis\nmat3 rotationX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n\n// 3D rotation around the Y-axis\nmat3 rotationY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\n\n// 3D rotation around the Z-axis\nmat3 rotationZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n// 2D rotation function\nmat2 rot2D(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\nfloat BASE_Y = -.7;\nfloat CONE_HEIGHT = 3.5;\nfloat CONE_Y = .75;\nfloat CONE_VOL = 1.125;\nfloat SMIN_BLEND = 0.333;\nfloat RIPPLE_AMOUNT = 2.;\n// Scene function, combining the objects with smooth union (smin)\nfloat sceneSDF(vec3 p, out vec3 color) {\n    float teet = (1.5*abs(sin(iTime*.125)))+.1;\n    p.z -= iTime * 1.; // Forward movement\n    // Space repetition\n    p.z = fract(p.z) - .5;     // spacing: 1\n\n    p.xy*=rot2D((PI*.5));\n    float link = sdLink(p, 2.,2.5, .2);\n    vec3 col = palette(p.z*p.y);//*vec3(.7+abs(cos(iTime*.1)), .5+(abs(sin(p.y+iTime))*.666), 0.97);\n    // Color the sphere white\n    color = col;\n\n    return link;\n}\n\n// Scene function without color (for normal calculation)\nfloat sceneSDF(vec3 p) {\n    float teet = (1.5*abs(sin(iTime*.125)))+.1;\n    p.z -= iTime * 1.; // Forward movement\n    // Space repetition\n    p.z = fract(p.z) - .5;     // spacing: 1\n\n    p.xy*=rot2D((PI*.5));\n    float link = sdLink(p, 2.,2.5, .2);\n    return link;\n}\n\n\n\n\n\n// Normal calculation for lighting\nvec3 getNormal(vec3 p) {\n    float d = sceneSDF(p); // Use the version without the color output\n    vec2 e = vec2(0.01, 0.0);\n    vec3 n = d - vec3(\n        sceneSDF(p - e.xyy),\n        sceneSDF(p - e.yxy),\n        sceneSDF(p - e.yyx)\n    );\n    return normalize(n);\n}\n\n// Fresnel-Schlick approximation\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Distribution function for specular reflection (GGX/Trowbridge-Reitz)\nfloat distributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = 3.14159 * denom * denom; // Ï€ * denom^2\n    return num / denom;\n}\n\n// Geometry function (Smith's Schlick-GGX)\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\n// Geometry term (combination of both view and light shadowing)\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = geometrySchlickGGX(NdotV, roughness);\n    float ggx2 = geometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n\n// Cook-Torrance BRDF\nvec3 cookTorranceBRDF(vec3 N, vec3 V, vec3 L, vec3 F0, float roughness, vec3 albedo, float metallic) {\n    vec3 H = normalize(V + L);\n    float NDF = distributionGGX(N, H, roughness);  // Normal Distribution Function\n    float G = geometrySmith(N, V, L, roughness);   // Geometry function\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0); // Fresnel term\n\n    float NdotL = max(dot(N, L), 0.0);\n    float NdotV = max(dot(N, V), 0.0);\n    \n    // Specular component\n    vec3 numerator = NDF * G * F;\n    float denominator = 4.0 * NdotV * NdotL + 0.0001; // Avoid division by zero\n    vec3 specular = numerator / denominator;\n\n    // Diffuse component (Lambertian)\n    vec3 kD = vec3(1.0) - F;  // Fresnel term reduces diffuse contribution\n    kD *= (1.0 - metallic);   // No diffuse component for metals\n    vec3 diffuse = kD * albedo / 3.14159;\n\n    // Final outgoing light (radiance)\n    return (diffuse + specular) * NdotL;\n}\n\n// PBR lighting function\nvec3 pbrLighting(vec3 p, vec3 V, vec3 L, vec3 albedo, float metallic, float roughness) {\n    vec3 N = getNormal(p); // Surface normal\n    vec3 F0 = mix(vec3(0.04), albedo, metallic); // Fresnel reflectance at normal incidence\n    // Light intensity adjustment (increase this factor to make the light brighter)\n    float lightIntensity = 6.0; // Increase this value to brighten the light\n\n    // Cook-Torrance BRDF\n    vec3 radiance = cookTorranceBRDF(N, V, L, F0, roughness, albedo, metallic);\n\n    return radiance * lightIntensity;\n}\n// Raymarching function\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 color, float s) {\n    float dist = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + dist * rd;\n        p.x += sin(dist*.15)*2.75;  // wiggle ray\n        p.y -= cos(dist*.1)*.75;  // wiggle ray\n        p.xy *= rot2D(PI*(dist*.025)+iTime*.25);\n        float d = sceneSDF(p, color);\n        if (d < SURF_DIST) {\n            return dist;\n        }\n        dist += d;\n        if (dist > MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 snd = texture(iChannel0, uv).rgb;\n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, 2.0);  // Ray origin (camera position)\n    vec3 rd = normalize(vec3(uv, -1.)); // Ray direction\n    // Rotate the scene by applying the rotation matrices\n    //ro = rotationX(-0.125) * rotationY(.15333) * ro;\n   // rd = rotationY(0.5) * rotationX(-.333) * rd;\n\n    // Perform raymarching\n    vec3 objColor;\n    float d = rayMarch(ro, rd, objColor, snd.x);\n\n    vec3 color = vec3(0.0);\n    if (d < MAX_DIST) {\n        // Compute position of hit\n        vec3 p = ro + d * rd;\n        p.x += sin(d*.15)*2.75;  // wiggle ray\n        p.y -= cos(d*.1)*.75;  // wiggle ray\n        p.xy *= rot2D(PI*(d*.025)+iTime*.25);\n        // PBR material parameters\n        objColor = palette(p.z*.0665);//*vec3(.7+abs(cos(iTime*.1)), .5+(abs(sin(p.y+iTime))*.666), 0.97);\n\n        float metallic = .24;  // Non-metallic surface\n        float roughness = .4; // Mid-level roughness\n        //p.yz *= rot2D(iTime*.125);     // rotate ray around z-axis\n        // Lighting parameters\n        vec3 lightPos = vec3(10.0, 2.0, 5.0);\n        vec3 L = normalize(lightPos - p);\n        vec3 V = normalize(ro - p);\n\n        // Apply PBR lighting\n        color = pbrLighting(p, V, L, objColor, metallic, roughness);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}