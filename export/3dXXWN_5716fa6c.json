{"ver":"0.1","info":{"id":"3dXXWN","date":"1551250966","viewed":571,"name":"FFT Fluid - half scale","username":"rory618","description":"Halved version of FFT fluid for extra performance and room for more features, forking from cleaned up version from fabrice :)\nMouse click fluid drag function copied from wyatt\nKeys: X (visc) ,Z (cons) ,C (boost), Space (toggle FFT)\n","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["fluid","diffusion","advection","fourier","multipass","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"FFT Fluid - analysis rory618 cod\" by FabriceNeyret2. https://shadertoy.com/view/tdfSR4\n// 2019-02-27 05:43:59\n\n// Four step seperated FFT, factored horizontally, vertically, and over major and minor axis for each of x and y\n// Total worst case for 1024*1024 image is 2 (x and y) times 4 (factored into 4) 32pt dft's where each pixel/thread \n// must compute one bin of its corresponding dft. Pipelining through A-B-C-D means fft of the whoe screen only takes one frame.\n// Both the x and y of the feild need to be fft'd so it takes up all 4 channels to do an fft, so every other frame\n// the fft direction is swapped to compute the inverse, and overall the simulation runs at one step per two frames\n\n\n//Scaling is one half here, meaning that I am running the FFT fluid algorithm at size R/2 for cost.\n//Show channel A to see paint advection and a half scale FFT stage packed in one buffer\n//    O = texture(iChannel0, I/R.xy);\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = texture(iChannel0, I/R.xy/2.+vec2(.5,0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Data structure:\n\n//   O.xyzw contains either V.xy or ^V.xy (even vs odd frames) \n//   that are complex numbers: O.xy = Vx and O.zw = Vy (0 if world velocity)\n\n\n// Fourier calculation:\n\n// - done independently on Vx and Vy\n// - 2D Fourier = Fy(Fx(image)): BufA,B do Fx, BufC,D do Fy\n// - 1D Fourier is done by incomplete FFT: Cooley-Tukey on DFT blocks\n//   - Data structure:\n//       Buf A,B = N0x horizontal blocks of size N1x (NO.N1 = R)\n//                 equiv to array(N0x,N1x)\n//       Buf C,D = N0y vertical blocks of size N1y \n//                 equiv to array(N0y,N1y)\n//   - Algo:\n//       Buf A,C : DTF along N0\n//       Buf B,D : DTF along N1\n\n\n// Fluid calculation:\n\n// Forward:  (odd frames)\n// - advect velocity (bufA) \n// - Fourier transform V (BuffA,B,C,D) -> ^V\n// - apply mass conservation + viscosity in Fourier, see Jos Stam paper http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/jgt01.pdf\n// - display only if Fourier required (Image)\n// Backward: (even frames)\n// - Fourier transform ^V (BuffA,B,C,D) -> V\n// - Apply forces (mouse control) (BuffD)\n// - display fluid (density faked from velocity turbulent features) (Image)\n\n#define viscosity 1e-4 // 1e-7: turbulent 1e-5: some diffusion\n\n#define imod(x,y) (((x)+(y))-(((x)+(y))/(y))*(y))\n\n#define pi 3.14159265\n#define R  iResolution\n#define iR ivec3(R)\n#define T(x,y) texelFetch(iChannel0, imod(ivec2(x,y),(iR.xy/2)), 0)\n#define keypressed(c) (texelFetch(iChannel2,ivec2(c,2),0).x > .5)\n\n// --- (i)FFT sum on blocks\n                            // FFT vs iFFT at even vs odd frame\n#define FFT_DIR float((iFrame%2)*2-1)\n#define FORWARD 1.\n#define BACKWARD -1.\n                             // exp( s* 2iPi k/N )\n#define W(k,n) cexp(vec2(0,FFT_DIR*(2.*pi*float(k)/float(n))))\n\n/**/\n                             // partial DFT on blocks\n#define SUM(v,n0,n2, V)                  \\\n    setRadix(R);                      \\\n    int x = int(I.x),                    \\\n        y = int(I.y),                    \\\n        n = v/n0;  v = v%n0;             \\\n    O = vec4(0);                         \\\n    for(int i = 0; i < 32; i++){         \\\n        if (i >= n2) break;              \\\n        vec2 w = W(i*n,n2);              \\\n        O.xy += cprod(V.xy,w);           \\\n        O.zw += cprod(V.zw,w);           \\\n    }\n/**\nvec2 sum;                    // sum(expr) on blocks\n#define SUM(expr, ind, len)            \\\n    sum = vec2(0);                     \\\n    for(int ind = 0; ind < 64; ind++){ \\\n        if (ind >= len) break;         \\\n        sum += expr;                   \\\n    }\n/**/\n\n// --- radix calculation:\n// partial FFT on blocks N0,N1 close to sqrt(R) with N1.N2=R\n// more understanding needed (e.g. N0,N1 vs 64)\n// See https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\nint x_N0, x_N1,\n    y_N0, y_N1;\n\nint factor(float x){ // find largest f<sqrt(x) such that f*g = x\n    int i = int(x),  // (isn't it costly to do that for each pixel*frame*buffer ?)\n        f = int(sqrt(x));\n    while( i % f > 0 ) f--;\n    return f;\n  //return float(i)/float(f);\n}\n\nvoid setRadix(vec3 R){  \n    x_N0 = factor(R.x/2.);\n    y_N0 = factor(R.y/2.);\n    x_N1 = int(R.x/2.)/x_N0;\n    y_N1 = int(R.y/2.)/y_N0;\n    \n}\n\n// --- complex arithmetics\n\nvec2 cprod(vec2 a, vec2 b){\n    return mat2(a,-a.y,a.x) * b;\n}\n\nvec2 cis(float t){\n    return cos(t - vec2(0,pi/2.));\n}\nvec2 cexp(vec2 z) {\n    return exp(z.x)*cis(z.y);\n}\n\nfloat dot2(vec2 x) { return dot(x,x); }\n\n// --- random numbers\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn float(a) / float(0x7FFFFFFF);\n}\n\n#define Ihash3(x,y,z) IHash((x)^IHash((y)^IHash(z)))\n    \nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// apply advection and proceed 1st step of block-FFTx\n\nvec4 inp(int x, int y);\nvoid mainImage( out vec4 O, vec2 I ) // --- block-FFTx\n{\n    if(I.x<R.x/2.&&I.y<R.y/2.){\n        SUM( x, x_N1, x_N0, inp( x+i*x_N1, y ) );\n\n        O.xy = (cprod(O.xy, W(x*n,iR.x/2)));\n        O.zw = (cprod(O.zw, W(x*n,iR.x/2)));\n    }\n    //Advect some paint\n    if(I.x>R.x/2.&&I.y<R.y/2.){\n        vec2 v = T(I.x, I.y).xz;\n        ivec2 px = ivec2(floor(I)-v/4.+rand2(Ihash3(int(I.x),int(I.y),iFrame)));\n        px = imod(px,(iR.xy/2))+ivec2(iR.x/2,0);\n        O = texelFetch(iChannel1,ivec2(px),0);\n        \n        px = ivec2(floor(I)-v/8.+.5 );\n        px = imod(px,(iR.xy/2))+ivec2(iR.x/2,0);\n        O += texelFetch(iChannel1,ivec2(px),0);\n        O /= 2.;\n        \n        vec4 mo = texture(iChannel3,vec2(1));\n        float l = ln(I,iMouse.xy/2.+vec2(R.x/2.,0),mo.xy/2.+vec2(R.x/2.,0));\n        O.w*=.99;\n        if (mo.z > 0.) O = mix(O,(.5+.5*cos(iTime*vec4(4,5,6,0)*.1)),exp(-l/3.));\n    }\n}\n\n\nvec4 inp(int x, int y){\n    if(FFT_DIR==FORWARD){ // space domain: --- apply advection \n        vec2 v = T(x, y).xz;                  // rand: stochastic interpolation better for low velocity\n        return texture(iChannel0,mod(( vec2(x, y) -v/2. + rand2(Ihash3(x,y,iFrame)) ) / R.xy,.5 ));\n    } else\n        return T(x, y);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// proceed 2nd step of block-FFTx\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    if(I.x<R.x/2.&&I.y<R.y/2.){\n    \tSUM( x, x_N0, x_N1, T( x*x_N1+i, y ) );\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// proceed 1st step of block-FFTy\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    if(I.x<R.x/2.&&I.y<R.y/2.){\n        SUM( y, y_N1, y_N0, T( x, y+i*y_N1 ) );\n\n        O.xy = (cprod(O.xy, W(y*n,iR.y/2)));\n        O.zw = (cprod(O.zw, W(y*n,iR.y/2)));\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// proceed 2nd step of block-FFTy\n// and apply forces, viscosity, mass conservation, \n// See http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/jgt01.pdf\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    if(I.x<R.x/2.&&I.y<R.y/2.){\n        SUM( y, y_N0, y_N1, T( x, y*y_N1+i ) );  // --- block-FFTy\n\n        O /= sqrt(R.x*R.y/4.);\n\n\n        vec2 C = mod(I+R.xy/4.,R.xy/2.)-R.xy/4.;    // --- forces+conservation\n\n        if(FFT_DIR==FORWARD){\n            if (!keypressed(88))                 // X\n                // apply viscosity \n                O*=exp(-dot2( C )*viscosity);\n            if( /* length(C)>0. && */ !keypressed(90) ){ // Z\n                // mass conservation: reprojection on circle\n                float lx = length(O.xz),\n                      ly = length(O.yw);\n                // Oxy = ^Vx , O.zw = ^Vy , C = ^(x,y) \n                // ^( div(V)=0 ) <=> ^x.^Vx + ^y.^Vy = 0\n                // -> reproj: ^V -= dot(^V,^(x,y)). ^(x,y) / ||^2\n                // do it for real part, then imaginary part:\n                O.xz -= dot(C,O.xz) *C /dot(C,C);\n                O.yw -= dot(C,O.yw) *C /dot(C,C);\n                if (!keypressed(67)) {              // C\n                    // restore length\n                    O.xz *= lx / (1e-3+length(O.xz));\n                    O.yw *= ly / (1e-3+length(O.yw));\n                }\n             }\n            if( floor(C) == vec2(0) ) O *= 0.; // no DC: kills global drift\n        } else {\n            // apply forces\n          //O.xz += .01*(iMouse.xy-iMouse.zw)*exp(-10.*length(iMouse.xy-I)/R.y); // true forces\n            //O.xz += .01*(iMouse.xy-R.xy*.5)*exp(-.1/(1.+length(I-R.xy*.25))*dot2(I-R.xy*.25));\n            \n            vec4 mo = texture(iChannel3,vec2(1));\n            float l = ln(I,iMouse.xy/2.,mo.xy/2.);\n            if (mo.z > 0. && l < R.y/20.) O.xz += 10.*vec2((R.y/20.-l)*(iMouse.xy-mo.xy)/R.y);\n            \n            //Apply bouyancy based on decaying w channel in buf A, which is basically temperature and gets advected\n            //As well as heated by the mouse\n            vec4 A = texture(iChannel1, I/R.xy+vec2(.5,0));\n            O.z += 5.*A.w;\n            \n        }\n    }\n    \n    if(I.x+1.>R.x&&I.y+1.>R.y){\n        O = texture(iChannel3,1.-vec2(1,0)/R.xy);\n    } else if(I.x+2.>R.x&&I.y+1.>R.y){\n        O = iMouse;\n    }\n    if(iFrame<6 && FFT_DIR==BACKWARD) // --- init\n        O=vec4(0);\n}","name":"Buffer D","description":"","type":"buffer"}]}