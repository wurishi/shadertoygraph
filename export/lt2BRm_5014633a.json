{"ver":"0.1","info":{"id":"lt2BRm","date":"1515165933","viewed":3256,"name":"perlin watercolor","username":"ws","description":"Inspired by https://blog.paytonturnage.com/water_color, but using perlin noise instead of polygons.","likes":61,"published":1,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// perlin noise from https://www.shadertoy.com/view/XdcXzH\n#define _PerlinPrecision 8.0\n#define _PerlinOctaves 8.0\n#define _PerlinSeed 0.0\n\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\nfloat inter(float a, float b, float x)\n{\n    //return a*(1.0-x) + b*x; // Linear interpolation\n\n    float f = (1.0 - cos(x * 3.1415927)) * 0.5; // Cosine interpolation\n    return a*(1.0-f) + b*f;\n}\nfloat perlin(vec2 uv)\n{\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\t\t\t\t\t// Final heightmap value\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta----b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|    |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc----d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\nconst mat4 fg_cols = mat4(0.,110.,202.,256., // blue\n\t\t\t\t\t\t232., 141., 122.,256., // red\n\t\t\t\t\t\t90., 188., 94.,256., // green\n\t\t\t\t\t\t161., 90., 188. ,256.  )/256.; // purple \nconst vec4 bg_col = vec4(229.,204.,175.,256.)/256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = fragCoord.xy / iResolution.xy - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    float r = length(p);\n    float seed = floor(iTime*0.5);\n    \n    // fg_col = fg_cols[seed%4] logically, but this is a compatability workaround.\n    vec4 fg_col = vec4(0.);\n    fg_col += float(mod(seed,4.)==0.)*fg_cols[0];\n\tfg_col += float(mod(seed-1.,4.)==0.)*fg_cols[1];\n\tfg_col += float(mod(seed-2.,4.)==0.)*fg_cols[2];\n\tfg_col += float(mod(seed-3.,4.)==0.)*fg_cols[3];\n    \n    float noise_scale = 0.15+0.075*mod(seed, 3.);\n    float num_layers = 3.+2.*mod(seed, 5.);\n    seed *= num_layers;\n    \n    float v = 0.;\n    \n    for (float i = 0.; i < num_layers; i++) {\n        float h = noise_scale*perlin(p+vec2(i+seed))+r;\n        if (h < 0.4) { v += 1./num_layers; }\n    }\n    \n\n    fragColor = mix(bg_col, fg_col, v); \n}","name":"Image","description":"","type":"image"}]}