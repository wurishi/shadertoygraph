{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define time (iTime*0.4)\n\n#define width  iResolution.x\n#define height iResolution.y\nconst float delta  = 0.02;\nconst float PI =  3.14159265;\n\nfloat sphere(vec3 position, float r)\n{\n        return length(position) - r ;//+ 0.53*sin(position.y*1.1 + mod(time*0.2, 2.0*PI)-PI)\n        //+ 0.17*sin(position.z*2.2 + mod(time*0.02, 2.0*PI)-PI);\n}\n\n\nvec3 rotateX(vec3 pos, float alpha) {\n\tmat4 trans= mat4(1.0, 0.0, 0.0, 0.0,\n\t\t\t\t0.0, cos(alpha), -sin(alpha), 0.0,\n\t\t\t\t0.0, sin(alpha), cos(alpha), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\t\t\t\t\n\t\t\t\t\n\treturn vec3(trans * vec4(pos, 1.0));\n}\n\nvec3 rotateY(vec3 pos, float alpha) {\n\n\t\t\t\t\n\tmat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0,\n\t\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t\t-sin(alpha), 0.0, cos(alpha), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\t\t\t\t\n\treturn vec3(trans2 * vec4(pos, 1.0));\n}\n\nvec3 translate(vec3 position, vec3 translation) {\n\treturn position - translation;\n}\n\n\nfloat cube(vec3 pos,float size){\n    return max(max(abs(pos.x)-size,abs(pos.y)-size),abs(pos.z)-size) ;//+ 0.17*sin(pos.z*2.2 + mod(time*0.02, 2.0*PI)-PI);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n/*\nfloat function(vec3 position) {\n\t\n\n\treturn  sdTorus(\n\t\t\t\n\t\t\trotateX(\n\t\t\trotateY(\n\t\t\t\n\t\t\ttranslate(position.xyz,vec3(0.0,0.0,20.0))\n\t\t\t,\n\t\t\ttime* 2.3),position.x*0.8 + time* 0.1)\n\t\t\t\n\t\t\t, vec2(4.0,2.0));\n}*/\n\n\t\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q ,0.46);\n}\n\n\tvec3 opRep2( vec3 p, vec3 c )\n{\n   return mod(p,c)-0.5*c;\n\n}\n\nfloat wonderCube(vec3 position) {\n\nvec3 disp = vec3(0.0,0.0,6.0);\n\nvec3 newPos = rotateY(rotateX(translate(position.xyz,disp),1.3*time),1.0*time);\nreturn opS( opRep(newPos, vec3(1.3,1.3,1.3)),udRoundBox(newPos, vec3(8.2,6.2,9.2), 0.5))\n;\n}\n\nfloat opCheapBend( vec3 p )\n{\n\n\t\n\n    float c = cos(0.9*(1.0+sin(time*0.2))+p.y*0.018);\n    float s = sin(0.9*(1.0+sin(time*0.2))+p.y*0.018);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n\tfloat alpha =//(1.0+sin(time*1.0))/4.0;\n0.38;//(1.0+sin(time*1.0))/4.0;\n\nvec3 disp = vec3(0.0,0.0,6.0);\n\nvec3 newPos = rotateY(rotateX(translate(q.xyz,disp),1.3*time),1.0*time);\n   // newPos = opRep2(newPos, vec3(8.0));\n    return wonderCube(q)*(1.0-alpha) + sdTorus(newPos, vec2(0.3,0.001))*alpha;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(0.90*p.y);\n    float s = sin(0.90*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return wonderCube(q);\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = sdTorus(p, vec2(4.0,2.0));\n    float d2 = (sin(p.x*3.0) + sin(p.y*5.0)) *0.2;\n    return d1+d2;\n}\n\n\nfloat opBlend( vec3 position )\n{\nvec3 disp = vec3(0.0+4.0*sin(time*2.2+3.0),0.0+2.0*sin(time*1.3),8.0+0.3*sin(time*1.5));\n\nvec3 newPos = rotateY(rotateX(translate(position.xyz,disp),2.3*time),1.8*time);\n    float d1 = wonderCube(position);\n\tvec3 p = position;\n    float d2 = sin(0.800*p.x)*sin(0.800*p.y)*sin(0.800*p.z) ;\n \n    return d1+d2;\n}\n\n//////////\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n///////////\n\n\nint colorIndex = 0;\n\n#define pi 3.14159265\nfloat perlin(vec3 p) {\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*pi)*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\n\nvec3 n1 = vec3(1.000,0.000,0.000);\nvec3 n2 = vec3(0.000,1.000,0.000);\nvec3 n3 = vec3(0.000,0.000,1.000);\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\nvec3 n8 = vec3(0.000,0.357,0.934);\nvec3 n9 = vec3(0.000,-0.357,0.934);\nvec3 n10 = vec3(0.934,0.000,0.357);\nvec3 n11 = vec3(-0.934,0.000,0.357);\nvec3 n12 = vec3(0.357,0.934,0.000);\nvec3 n13 = vec3(-0.357,0.934,0.000);\nvec3 n14 = vec3(0.000,0.851,0.526);\nvec3 n15 = vec3(0.000,-0.851,0.526);\nvec3 n16 = vec3(0.526,0.000,0.851);\nvec3 n17 = vec3(-0.526,0.000,0.851);\nvec3 n18 = vec3(0.851,0.526,0.000);\nvec3 n19 = vec3(-0.851,0.526,0.000);\n\nfloat spikeball(vec3 p) {\n\tp = rotateX(p-vec3(0.0,0.0,6.0),time*3.0);\n   vec3 q=p;\n   p = normalize(p);\n   vec4 b = max(max(max(\n      abs(vec4(dot(p,n16), dot(p,n17),dot(p, n18), dot(p,n19))),\n      abs(vec4(dot(p,n12), dot(p,n13), dot(p, n14), dot(p,n15)))),\n      abs(vec4(dot(p,n8), dot(p,n9), dot(p, n10), dot(p,n11)))),\n      abs(vec4(dot(p,n4), dot(p,n5), dot(p, n6), dot(p,n7))));\n   b.xy = max(b.xy, b.zw);\n   b.x = pow(max(b.x, b.y), 140.);\n   return length(q)-1.75*pow(1.5,b.x*(1.-mix(.3, 1., sin(time*2.)*.5+.5)*b.x)) + 0.04* perlin(p*6.0);\n}\n\nfloat function(vec3 position) {\n\t\n\t///float a = opCheapBend(position);\n\t\t\n\tfloat a =udRoundBox(position-vec3(0.0,-4.0,2.2), vec3(15.0,0.01,15.0),0.0);//cube(position+vec3(0.0,6.3,-3.2), 3.0);\n\tvec3 pos = vec3(0.5*sin(time*3.0)*3.0,2.0,0.5*cos(time*3.0)*3.0);\n\tfloat b = //udRoundBox(rotateY(rotateX(position+vec3(0.0,-1.4,-3.4)+pos,time*3.0),time*3.0), vec3(1.4,1.4,1.4), 0.3);\nopS( opRep(rotateY(rotateX(position+vec3(0.0,-1.4,-3.4)+pos,time*3.0),time*3.0), vec3(0.95,0.95,0.95)),udRoundBox(rotateY(rotateX(position+vec3(0.0,-1.4,-3.4)+pos,time*3.0),time*3.0), vec3(1.4,1.4,1.4), 0.3));// - 0.03* perlin(position*3.8);\n//\tfloat c = udRoundBox(position+vec3(0,0,-16), vec3(25.6,15.6,0.6), 0.2 );\n\n\tcolorIndex = 0;\n//\tif(b < a) colorIndex = 1;\n//\tfloat dist =opU(a,b);\n\tif( b <a) colorIndex = 1;\n\n\tfloat dist = opU(a,b);\n\treturn dist;\n\t\n\n//\tif(c < dist) colorIndex =2;\n\n//\treturn opU(dist,c) ;\n\n//return opBlend(position);\n\n}\n\n\n\n\n\nvec3 ray(vec3 start, vec3 direction, float t) {\n\treturn start + t * direction;\n}\n\nvec3 gradient(vec3 position) {\n\n\treturn vec3(function(position + vec3(delta, 0.0, 0.0)) - function(position - vec3(delta, 0.0, 0.0)),\n\tfunction(position + vec3(0.0,delta, 0.0)) - function(position - vec3(0.0, delta, 0.0)),\n\tfunction(position + vec3(0.0, 0.0, delta)) - function(position - vec3(0.0, 0.0, delta)));\n\n\t\n}\n\nvec4 plasma(vec2 fragCoord) {\n vec2 p = -1.0 +2.0 * fragCoord.xy / vec2(640, 360);\nfloat cossin1 = ((cos(p.x * 2.50 +time*2.5) +sin(p.y*3.70-time*4.5) +sin(time*2.5))+3.0)/6.0;\nfloat cossin2 = (cos(p.y * 2.30 +time*3.5) +sin(p.x*2.90-time*1.5) +cos(time)+3.0)/6.0;\nfloat cossin3 = (cos(p.x * 3.10 +time*5.5) +0.5*sin(p.y*2.30-time) +cos(time*3.5)+3.0)/6.0;\nreturn vec4(vec3(cossin1, cossin2, cossin3)*0.6, 1.0);\n\n}\n\nvec3 lightPosition;\n\nfloat aoScale = 0.3; // smaller aoScale = more AO\nfloat computeAO(vec3 position, vec3 normal) {\n\t\nfloat sum = 0.0;\nfloat stepSize = 0.015;\nfloat t = stepSize;\n\n\tfor(int i=0; i < 8; i++) {\n\t\tposition = ray(position, normal, t);\n\t\tsum += max(function(position),0.0);\n\t\tt+=stepSize;\n\t}\n\treturn 1.0-clamp(1.0 -(sum * aoScale),0.0, 1.0);\n}\n\nfloat computeShadow(vec3 pos) {\n\n\tfloat t = 0.0;\n\tfloat distance;\nvec3 position;\nfloat res = 1.0;\nfloat k = 20.0;\n\tfor(int i=0; i < 64; i++) {\n\t\tposition = ray(pos,normalize(lightPosition-pos) , t);\n\t\tdistance = function(position);\n\n\t\tres = min(res, k*distance/t);\t\n\t\tt = t + distance ;\n\t}\n\n\treturn res;\n}\n\nfloat computeShadow2(vec3 pos) {\n\n\tfloat t = 0.0;\n\tfloat distance;\nvec3 position;\n\tvec3 startPos = lightPosition +normalize(pos-lightPosition)*0.;\nfloat k = 400.0;\n\tfloat res = 1.0;\n\tfor(int i=0; i < 64; i++) {\n\n\t\tposition = ray(startPos,normalize(pos-lightPosition) , t);\n\t\tdistance = function(position);\n\n\t\tif(abs(distance) < 0.009) {\n\t\t\treturn 0.0;\n\t\t}\n\tres = min(res, k*distance/t);\n\t\tt = t + distance;\n\t\tif(  t >(length(pos - lightPosition))-0.0) return 1.0;\n\t}\n\n\treturn 0.0;\n}\nvec4 checker(vec2 pos) {\n\n//return vec4((sin(pos.x*10.0)+1.0)/2.0*0.5 +0.5,(sin(pos.y*10.0)+1.0)/2.0*0.5 +0.5,0.0,1.0);\nreturn vec4(vec3(clamp((cos(pos.x) + cos(pos.y)) * 1000., 0.1, 1.)),1.0)+vec4(vec3((1.0+cnoise(vec3(pos*0.8,1.0))))/2.0*0.3,0.0);\n}\n\n\nvec4 computeReflection(vec3 pos, vec3 viewDirection) {\n\tfloat t = 0.0;\n\tfloat distance;\n\tvec3 position;\n       vec3 cameraPosition = pos;\n\tvec4  color = vec4(16.0/255.0,25.0/255.0,27.0/255.0,1.0);//vec4(0.0,0.2,0.0,1);\n\tvec3 normal;\n\tvec3 up = normalize(vec3(-0.0, 1.0,0.0));\n\t\n\tfor(int i=0; i < 32; i++) {\n\t\tposition = ray(cameraPosition,\tviewDirection, t);\n\t\tdistance = function(position);\n\t\t\n\tif(position.z > 7.5) break;\n\t\t\n\t\tif(distance < 0.002 || i ==31) {\n\t\t\t\n\t\t\t\t\n\t\tnormal = normalize(gradient(position));\n\t\t\t\nvec4 color3;\n\t\tif(colorIndex==0) {\n\t\t\tfloat alpha = (1.0-min(pow(length((position.xyz -vec3(0.0,-4.2,4.0))*vec3(1.0*0.3,1.0,1.0*0.8))/3.0,2.0),1.0));\n\t\t\t//color =  vec4(color1.xyz*alpha +(1.0-alpha)*color.xyz ,1.0);\n\t\t\tcolor = checker(position.xz*4.0)*1.0*alpha +(1.0-alpha)*vec4(16.0/255.0,25.0/255.0,27.0/255.0,1.0);\n\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(colorIndex == 1) color3 = vec4(float(121)/255.0,float(132)/255.0,float(125)/255.0,1.0);\n\t\t\tif(colorIndex == 2) color3 = vec4(float(0xAD)/255.0,float(0xFF)/255.0,float(0x2F)/255.0,1.0);\n\n\n\t\t\t//float shad = computeShadow(position+normalize(lightPosition-position)*0.009);\n\t\t\t\n\t\t\tcolor = color3 * max(dot(normal, normalize(lightPosition-position)),0.0);\n\t\t\tcolor += color3 *0.2 ;\n\n\t\t\t// SPECULAR HIGHLIGHTS\n\t\t\tvec3 E = normalize(cameraPosition - position);\n\t\t\tvec3 R = reflect(-normalize(lightPosition-position), normal);\n\t\t\tfloat specular = pow(max(dot(R, E), 0.0), 12.0);\n\n\t\t\t// compute final color\t\t\n\t\t\tcolor =vec4(color.xyz , 1.0);\n\n\t\t\t\n\t\t\t//color = color*0.4+ refl*0.6;\n\t\t\tcolor +=vec4(1.0, 1.0,1.0,0.0)*specular*1.0;\n\n\t\t\t// interation glow\n\t\t\tcolor += vec4(vec3(1.0, 0.5,0.1)*pow(float(i)/32.0*1.2, 2.0) *1.0,1.0);\n\t\t\tbreak;\n\t\t}\n\t\t//color += 0.6*vec4(vec3(0.4, 0.9,0.1)*pow(float(i)/64.0*2.6, 2.0) *1.0,1.0);\n\t\t\tt = t + distance * 1.0;\n\t}\n\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t  \n\treturn color;\t\t\t\t\t\t\t\t  \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    lightPosition = vec3(3.0*sin(time*0.2),0.5,3.0*cos(time*0.2))-vec3(0.0,-0.5,-2.0);\n    \n\tvec3 cameraPosition = vec3(0.0, -0.0, -1.0+0.30);\n\t\n\tfloat aspect = width/height;\n\tvec3 nearPlanePosition = vec3((fragCoord.x - 0.5 * width) / width * 2.0* aspect,\n\t\t\t\t\t\t\t      (fragCoord.y - 0.5 * height) / height *2.0,\n\t\t\t\t\t\t\t       -0.2+0.30);\n\n\t\t\t\t\t\t\t  \n\tvec3 viewDirection = normalize(nearPlanePosition - cameraPosition);\n\t\n\tfloat t = 0.0;\n\tfloat distance;\n\tvec3 position;\n\t// background color\n\tvec4 color = vec4(16.0/255.0,25.0/255.0,27.0/255.0,1.0);// plasma();//vec4(0.0,0.2,0.0,1);\n\n\tvec3 up = normalize(vec3(-0.0, 1.0,0.0));\n\n\t// update light\n\tlightPosition = vec3(0.0,1.4, -1.0);\n\t\n\tfor(int i=0; i < 64; i++) {\n\n\t\tposition = ray(cameraPosition,\tviewDirection, t);\n\t\tif(position.z > 7.5) break;\n\n\t\tdistance = function(position);\t\n\t\t\n\t\tif(abs(distance) < 0.0006 || i ==63) {\n\t\t\t\n\t\t\tvec3 normal;\n\t\t\tnormal = normalize(gradient(position));\n\t\t\t\n\t\t\tvec4 color1 = vec4(1.0,1.0,1.0,1.0);\n\t\t\tvec4 color2 = vec4(1.0, 0.1, 0.1,1.0);\n\n\t\t\t\nvec4 color3 ;\n\t\n\t\t\t//vec4 color3 =\n\t\t\tif(colorIndex==0) {\n\t\t\tfloat alpha = (1.0-min(pow(length((position.xyz -vec3(0.0,-4.2,4.0))*vec3(1.0*0.3,1.0,1.0*0.8))/3.0,3.0),1.0));\n\t\t\t//color =  vec4(color1.xyz*alpha +(1.0-alpha)*color.xyz ,1.0);\nvec4 refl = computeReflection(position+normal *0.004, reflect(viewDirection, normal));\n\t\t\tcolor = refl*alpha*0.5;\n\t\t\tcolor += checker(position.xz*4.0)*0.5*alpha +(1.0-alpha)*vec4(16.0/255.0,25.0/255.0,27.0/255.0,1.0);\n\n\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\n\t\t\tif(colorIndex == 1) color3 = vec4(float(121)/255.0,float(132)/255.0,float(125)/255.0,1.0);\n\t\t\tif(colorIndex == 2) color3 = vec4(float(0xAD)/255.0,float(0xFF)/255.0,float(0x2F)/255.0,1.0);\n\n\n\t\t\t//float shad = computeShadow(position+normalize(lightPosition-position)*0.009);\n\t\t\t\n\t\t\tcolor = color3 * max(dot(normal, normalize(lightPosition-position)),0.0);\n\t\t\tcolor += color3 *0.07 ;\n\n\t\t\t// SPECULAR HIGHLIGHTS\n\t\t\tvec3 E = normalize(cameraPosition - position);\n\t\t\tvec3 R = reflect(-normalize(lightPosition-position), normal);\n\t\t\tfloat specular = pow(max(dot(R, E), 0.0), 12.0);\n\n\t\t\t// compute final color\t\t\n\t\t\tcolor =vec4(color.xyz , 1.0);\n\n\t\t\t\n//color = color*0.4+ refl*0.6;\n\t\t\tcolor +=vec4(1.0, 1.0,1.0,0.0)*specular*1.0;\n\n\t\t\t// interation glow\n\t\t\tcolor += vec4(vec3(1.0, 0.5,0.1)*pow(float(i)/64.0*1.2, 2.0) *1.0,1.0);\n//color = color * alpha + plasma() *(1.0 -alpha);\n\t\t\t\n\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\tt = t + distance;\n\t}\n\t\t\t\t//color = computeColor(position, viewDirection, cameraPosition);\t\t\t\t  \n\t\t\t\t\t\t\t\t  \n\tfragColor = color;\t\t\t\t\t\t\t\t  \n\t//discard;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsf3DH","date":"1368615951","viewed":909,"name":"reflecting floor","username":"triggerHLM","description":"see iq's tutorials","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["simple","spheretracing"],"hasliked":0,"parentid":"","parentname":""}}