{"ver":"0.1","info":{"id":"Ms3Bz7","date":"1524499540","viewed":351,"name":"Cellular automaton(s) sandbox","username":"kloumpt","description":"An attempt to make a easy to use sandbox for cellular automatons.\n\nCurrent automaton:\nClassic game of life where cell belong to 3 types and are either assigned a type at each reset or when revived by neighbor cells which give their type to the cell.","likes":4,"published":1,"flags":96,"usePreview":0,"tags":["cellular","conway","gameoflife","automaton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdSXzK","filepath":"https://soundcloud.com/gael-b-gneu/weeping-pirate","previewfilepath":"https://soundcloud.com/gael-b-gneu/weeping-pirate","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture (iChannel0, fragCoord.xy / iResolution.xy);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 p (vec2 cell_id, float property_index) {\n    cell_id = mod(cell_id, MAP_SIZE);\n    return texelFetch (iChannel0, cell_property_uv (cell_id, property_index), 0);\n}\n\n\n\n\nvec4 compute (vec2 fragCoord, vec2 cell_id, float property_index, bool reset) {\n\n\n    float type = p(cell_id, P_TYPE).x;\n    float new_type = type;\n        \n    \t\n    float[3] neighbours_type;\n\n    neighbours_type[int(p (cell_id + vec2(-1.0, -1.0), P_TYPE).x)] += p (cell_id + vec2(-1.0, -1.0), P_LIFE).x;\n    neighbours_type[int(p (cell_id + vec2(-1.0,  0.0), P_TYPE).x)] += p (cell_id + vec2(-1.0,  0.0), P_LIFE).x;\n    neighbours_type[int(p (cell_id + vec2(-1.0, +1.0), P_TYPE).x)] += p (cell_id + vec2(-1.0, +1.0), P_LIFE).x;\n    \n    neighbours_type[int(p (cell_id + vec2(+1.0, -1.0), P_TYPE).x)] += p (cell_id + vec2(+1.0, -1.0), P_LIFE).x;\n    neighbours_type[int(p (cell_id + vec2(+1.0,  0.0), P_TYPE).x)] += p (cell_id + vec2(+1.0,  0.0), P_LIFE).x;\n    neighbours_type[int(p (cell_id + vec2(+1.0, +1.0), P_TYPE).x)] += p (cell_id + vec2(+1.0, +1.0), P_LIFE).x;\n                        \n    neighbours_type[int(p (cell_id + vec2( 0.0, +1.0), P_TYPE).x)] += p (cell_id + vec2( 0.0, +1.0), P_LIFE).x;\n    neighbours_type[int(p (cell_id + vec2( 0.0, -1.0), P_TYPE).x)] += p (cell_id + vec2( 0.0, -1.0), P_LIFE).x;\n\n\t\n\n\n\n\n\n\n\n    float life = p (cell_id, P_LIFE).x;\n    float new_life = life;\n    \n    float neighbours_alive = 0.0;\n\n    neighbours_alive  += p (cell_id + vec2(-1.0, -1.0), P_LIFE).x;\n    neighbours_alive  += p (cell_id + vec2(-1.0,  0.0), P_LIFE).x;\n    neighbours_alive  += p (cell_id + vec2(-1.0, +1.0), P_LIFE).x;\n\n    neighbours_alive  += p (cell_id + vec2(+1.0, -1.0), P_LIFE).x;\n    neighbours_alive  += p (cell_id + vec2(+1.0,  0.0), P_LIFE).x;\n    neighbours_alive  += p (cell_id + vec2(+1.0, +1.0), P_LIFE).x;\n\n    neighbours_alive  += p (cell_id + vec2( 0.0, +1.0), P_LIFE).x;\n    neighbours_alive  += p (cell_id + vec2( 0.0, -1.0), P_LIFE).x;\n\n\n    if (life == 1.0) {\n        if (neighbours_alive < 2.0) {\n            // Death of isolated cell\n            new_life = 0.0;\n        } else  if (neighbours_alive >= 2.0 && neighbours_alive <= 3.0) {\n            // Continued life of a living cell\n            new_life = 1.0;\n        } else if (neighbours_alive > 3.0) {\n            // death of a suffocated cell\n            new_life = 0.0;\n        }\n    } else if (neighbours_alive == 3.0) {\n        // Revival of a death cell\n        new_life = 1.0;\n        if (neighbours_type [0] > neighbours_type [1] && neighbours_type [0] > neighbours_type [2]) {\n            new_type = 0.0;\n        } else if (neighbours_type [1] > neighbours_type [2]) {\n            new_type = 1.0;\n        } else {\n            new_type = 2.0;\n        }\n            \n    }\n\n    \n\n    \n    if (reset) {\n        new_type = floor(texture(iChannel1, vec2(1.0) - cell_id / MAP_SIZE).x * 3.0);\n\n\t   float treshold = 0.5;\n        if (iMouse.z > 0.0) {\n            treshold = 1.0 - iMouse.y / iResolution.y;\n        }\n        new_life = step(treshold, texture(iChannel1, cell_id / MAP_SIZE).x);\n\n    }\n    \n    \n    \n    if (property_index == P_TYPE) {\n        return vec4(new_type);\n    }else if (property_index == P_LIFE) {\n        \n        return vec4(new_life);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(1.0);\n    \n    if (fragCoord.x < MAP_SIZE * BLOCK_SIZE && fragCoord.y < MAP_SIZE * BLOCK_SIZE){\n        vec2 cell_id = floor (fragCoord.xy / BLOCK_SIZE);\n        vec2 property_uv = fragCoord.xy - cell_id * BLOCK_SIZE;\n        \n    \t// TODO: Find why the property index must be shifted backwards\n        float property_index = floor(property_uv.y * BLOCK_SIZE + property_uv.x) - 1.0;\n        //property_index = P_LIFE;\n           \n        bool reset = iFrame % (60 * (3 * 60)) == 30 || iMouse.z > 0.0;\n        \n    \tfragColor = compute(fragCoord, cell_id, property_index, reset);\n    }\n    \n    if (iFrame%1 != 0) {\n        \n    \tfragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 p (vec2 cell_id, float property_index) {\n    cell_id = mod(cell_id, MAP_SIZE);\n    return texelFetch (iChannel0, cell_property_uv (cell_id, property_index), 0);\n}\n\nvec4 color (vec2 fragCoord, vec2 cell_id) {\n    float life = p (cell_id.xy, P_LIFE).x;\n    float type = p (cell_id.xy, P_TYPE).x;\n    \n    if (type == 0.0) {\n    \treturn vec4(life * vec3(1.0, 0.5, 0.0), 1.0);\n    } else if (type == 1.0) {\n    \treturn vec4(life * vec3(0.0, 1.0, 0.0), 1.0);\n    } else if (type == 2.0) {\n    \treturn vec4(life * vec3(0.0, 0.5, 1.0), 1.0);\n    }\n        \n    return vec4(life * vec3(1., 0., 1.), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col,1.0);\n    \n    if (\n           fragCoord.x >= MAP_MARGIN * BLOCK_SIZE \n     \t&& fragCoord.y >= MAP_MARGIN * BLOCK_SIZE\n     \t&& fragCoord.x < (MAP_MARGIN + MAP_SIZE) * BLOCK_SIZE \n     \t&& fragCoord.y < (MAP_MARGIN + MAP_SIZE) * BLOCK_SIZE\n    ){\n        vec2 cell_id = floor (fragCoord.xy / BLOCK_SIZE - vec2(MAP_MARGIN) );\n        \n        vec4 cell_color = color (fragCoord, cell_id);\n        \n    \tfragColor = mix(vec4(mix(fragColor.rgb, vec3(0.0), 0.75), fragColor.a), cell_color, max(cell_color.r, max(cell_color.g, cell_color.b)));\n    }\n    \n    vec4 fragColor_last = texture(iChannel1, uv);\n    fragColor = mix(fragColor, fragColor_last, max(0.5, step(0.5, fragColor_last.r - fragColor_last.r)));\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BLOCK_SIZE 2.\n#define MAP_MARGIN 4.\n#define MAP_SIZE (floor(iResolution.y / BLOCK_SIZE) - 2. * MAP_MARGIN)\n\nivec2 cell_property_uv (vec2 cell_id, float property_index) {    \n    vec2 cell_uv = cell_id * BLOCK_SIZE;\n    vec2 property_uv = vec2(\n        mod (property_index, BLOCK_SIZE), \n        floor (property_index / BLOCK_SIZE)\n    );\n    \n    return ivec2(cell_uv + property_uv);\n}\n\n\n\n#define P_TYPE 0.0\n#define P_LIFE 1.0\n\n","name":"Common","description":"","type":"common"}]}