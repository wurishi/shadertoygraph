{"ver":"0.1","info":{"id":"lsXyz7","date":"1487454104","viewed":395,"name":"Array of Spheres","username":"Emil","description":"Simple fakery of spheres not using any fancy raymarching or distancefields.., Just mathing out the normals of a sphere shape","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","fake","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.141592653;\n\t\tvec2 uv = (fragCoord.xy-iResolution.xy*.5)*4. / iResolution.y,\n        mousePos = (iMouse.xy-iResolution.xy*.5)*4. / iResolution.y;\n    \n    mousePos = vec2(sin(iTime*4.), cos(iTime*4.))*1.8 -uv; // comment me out for manual lightposition\n    \n    \n    // modding the uvs for repetition of spheres\n    uv = ( fract(uv*2.)-.5 ) * 1.8;\n    \n    \n    \n    // Normals of a sphere\n    vec3 normals = normalize(vec3(sin(uv.x),sin(uv.y),sqrt(cos(2.*length(uv)))));\n    \n    // reflect vector r=d−2(d⋅n)n\n    vec3 camDir = vec3(0.0,0.0,1.0);\n    vec3 reflectVector = reflect(camDir, normals);\n    \n    // light from mouse\n    vec3 lightdir = vec3(mousePos,sin(iTime));\n    \n    // diffuse light\n    vec3 diffuse = vec3(1.)*clamp(dot(normals,normalize (lightdir)),0.0,1.0);\n    diffuse += vec3(0.1,0.4,0.9)*0.7*clamp(dot(normals,normalize (-lightdir))+0.8,0.0,1.0); // backlight\n    \n    // highlight reflection\n    vec3 highlight = vec3(-1.)*pow(dot(reflectVector,normalize (lightdir)),9.0);\n    highlight = clamp(highlight, 0.0, 1.0);\n    \n    // spherical projection for texture (how do I transform the result to another rotation?, using matrices?)\n    vec2 sphereUV = vec2(atan(normals.x,normals.y)/(2.*PI)+.5, (asin(normals.z)/PI)+(0.5));\n    \n    // compositing\n    diffuse *= texture(iChannel0,sphereUV).rgb;\n    diffuse += highlight*0.4;\n    \n    \n    \n    fragColor = vec4(diffuse,0.)*smoothstep(1.01,1.0,distance(uv,vec2(0.,0.)));\n    //fragColor = vec4(reflectVector,0.)*smoothstep(1.01,1.0,distance(uv,vec2(0.,0.)));\n}","name":"Image","description":"","type":"image"}]}