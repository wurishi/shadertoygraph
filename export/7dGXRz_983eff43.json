{"ver":"0.1","info":{"id":"7dGXRz","date":"1634908039","viewed":32,"name":"Bead1","username":"katemekker","description":"assignement","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["pass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    const int k = 0;\n    fragColor = vec4(0);\n    ivec2 pixel = ivec2(fragCoord);\n    for(int i=-k; i<=k; i++)\n    for(int j=-k; j<=k; j++)\n    {\n        fragColor += texelFetch(iChannel0,pixel+ivec2(i,j),0);\n    }\n    \n    fragColor /= float((2*k+1)*(2*k+1));\n    //fragColor += texelFetch(iChannel0,ivec2(fragCoord),0).wwww/15.;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n//---------------------------------------\n\nstruct Material {\n    vec3 color;        // [0, 1/pi]\n    float roughness;   // [0,~7]\n    vec3 emission;     // [0, inf]\n    float metalness;   // 0.02-0.05 for non-mertals, 0.6-0.9 for metals\n    \n};\n\nMaterial mat[10];\n\nstruct Value {\n    float sdf;\n    int id;\n};\n\nfloat Unite(float,float);     // union on the original sdf representation\nValue Unite(Value,Value);     // same union but also carrying mat id\nValue Unite(Value,float,int); // creates a Value from the (float,int) \nValue Unite(float,Value,int); // pairs and calls Unite(Value,Value)\n\nfloat Unite(float d,float t) {\n    return min(d,t);\n}\nValue Unite(Value a,Value b) {\n    return Value(min(a.sdf, b.sdf), min(a.sdf, b.sdf) == a.sdf ? a.id : b.id);\n}\nValue Unite(Value a,float d,int i) { //--\n    float sdf = min(a.sdf, d);\n    int id = (sdf == a.sdf ? a.id : i) ;\n    return Value(sdf, id);\n}\nValue Unite(float d,Value a,int i) {\n    return Unite(a, Value(d, i));\n}\n\nfloat Inter(float,float);     // union on the original sdf representation\nValue Inter(Value,Value);     // same union but also carrying mat id\nValue Inter(Value,float,int); // creates a Value from the (float,int) \nValue Inter(float,Value,int); // pairs and calls Unite(Value,Value)\n\nfloat Inter(float d,float t) {\n    return max(d,-t);\n}\nValue Inter(Value a,Value b) {\n    return Value(max(a.sdf, -b.sdf), a.id);\n}\nValue Inter(Value a,float d,int i) { \n    return Value(max(d, -a.sdf), i);\n}\nValue Inter(float d,Value a,int i) {\n    return Inter(Value(d, i), a);\n}\n\n///SDF\n\nValue sdf(in vec3 p) // itt kell megadni az alakzatokat.\n{\n    /*p-=vec3(0,0,2);\n    float f = sdSphere(p, 1.);\n    float g = sdBox(p-vec3(2,0,0),vec3(1,1,1));\n    return min(min(f,g),p.y+1.);*/\n    \n    //float d = p.y+1.0; // talaj\n    Value d = Value(p.y+1.0, 1);\n    /*d = min(d, sdBox(p-vec3(0,1,0),vec3(0.7,0.5,1)));\n    d = max(d, -sdBox(p-vec3(0,1,0),vec3(0.7,0.5,1)-0.05));\n    d = max(d, -sdBox(p-vec3(0,1,0),vec3(0.2,0.4,2)));\n    float roof = max( sdSphere(p-vec3(0,1.5,0),1.f),-(p.y-1.5));\n    d = min(d, roof);*/\n    \n    //d = min(d, sdBox(p-vec3(0,0,0),vec3(1,1,1))); // létrehoz\n    //d = max(d, -sdBox(p-vec3(0,0,0),vec3(1,1,1))); // kivon\n    \n    // snow man\n    d = Unite(d, sdSphere(p-vec3(0,1.,0),2.f), 1);\n    d = Unite(d, sdSphere(p-vec3(0,4.,0),1.5), 1);\n    d = Unite(d, sdSphere(p-vec3(0,6.2,0),1.f), 1);\n    \n    d = Unite(d, sdSphere(p-vec3(1.4,0.5,1.4), 0.1), 2); // gombok\n    d = Unite(d, sdSphere(p-vec3(1.2,2,1.3), 0.1), 2);\n        \n    d = Unite(d, sdSphere(p-vec3(1.1,3.8,1.1), 0.1), 2);\n    d = Unite(d, sdSphere(p-vec3(1.,4.7,1.), 0.1), 2);\n\n    d = Unite(d, sdRoundCone(p-vec3(0.,0.,0.), vec3(0.6,6.4,0.6), vec3(1.3,6.5,1.5), 0.2, 0.1), 3); // répa\n    \n    d = Unite(d, sdEllipsoid(p-vec3(0.8,6.8,0.2), vec3(0.03,0.04,0.05)), 4); // szem\n    d = Unite(d, sdEllipsoid(p-vec3(0.2,6.8,0.8), vec3(0.05,0.04,0.03)), 4);\n    \n    float szaj = sdTorus(p-vec3(0.5,6.9,0.9), vec2(1.,0.1)); // száj\n    szaj = Inter(szaj, sdBox(p-vec3(1.1,7.1,1), vec3(2.,1.,2.) ));\n    \n    //d = Unite(d, szaj, 1);\n    \n\n    return d;\n    \n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file contains the \n// ---- SPHERE TRACING ----\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\n\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    Value d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d.sdf;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td.sdf\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d.sdf <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nTraceResult sphere_trace2(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    Value d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d.sdf;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td.sdf\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d.sdf <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)).sdf,sdf(p+vec3(0,eps,0)).sdf,sdf(p+vec3(0,0,eps)).sdf);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)).sdf,sdf(p-vec3(0,eps,0)).sdf,sdf(p-vec3(0,0,eps)).sdf);\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\n\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,1.,1.,1.);\n}\n\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    int id = sdf(p).id;\n    \n    Material m = Material(vec3(1./pi), 1., vec3(0.), 0.03);\n    \n    if(id == 1){ // snow\n        m.color = vec3(1.);\n    }\n    else if ( id == 2 ){ // coal\n        m.color == vec3(0., 0., 0.);\n    }\n    else if ( id == 3 ){ // répa\n        m.color == vec3(1., 0.0078, 0.);\n    }\n    else if ( id == 4 ){ // kék\n        m.color == vec3(0., 0., 1.);\n    }\n    \n    vec3 lightPos1=vec3(10.,10.,10.); \n    vec3 lightPos2=vec3(10.,10.,-10.);\n    vec3 lightPos3=vec3(-10.,10.,10.);\n    vec3 lightPos4=vec3(-10.,10.,-10.);\n    \n    vec3 v = -ray.V;\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 l3 = normalize(lightPos3-p);\n    vec3 l4 = normalize(lightPos4-p);\n    \n    //diffuse\n    float costheta1 = max(dot(n,l1),0.);\n    float costheta2 = max(dot(n,l2),0.);\n    float costheta3 = max(dot(n,l3),0.);\n    float costheta4 = max(dot(n,l4),0.);\n    //vec3 k_d = vec3(1./pi); // diffuse color\n    //vec3 k_d = vec3(0.,0.,0.);\n    vec3 k_d = m.color/pi;\n    \n    //specular\n    vec3 toLight1 = normalize(lightPos1 - p);\n    vec3 toLight2 = normalize(lightPos2 - p);\n    vec3 toLight3 = normalize(lightPos3 - p);\n    vec3 toLight4 = normalize(lightPos4 - p);\n    vec3 toEye = -ray.V;\n    vec3 k_s = vec3(0.4); // fényerősség\n    \n    vec3 h1 = normalize(toLight1+toEye);\n    vec3 h2 = normalize(toLight2+toEye);\n    vec3 h3 = normalize(toLight3+toEye);\n    vec3 h4 = normalize(toLight4+toEye);\n    float si1 = pow(clamp(dot(h1,n),0.,1.),2000.);\n    float si2 = pow(clamp(dot(h2,n),0.,1.),2000.);\n    float si3 = pow(clamp(dot(h3,n),0.,1.),2000.);\n    float si4 = pow(clamp(dot(h4,n),0.,1.),2000.);\n    \n    //sum\n    vec3 col = (k_d + si1*k_s)*costheta1;\n    col += (k_d + si2*k_s)*costheta2;\n    col += (k_d + si3*k_s)*costheta3;\n    col += (k_d + si4*k_s)*costheta4;\n    \n    return vec4(col,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int Q    = 81;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-4.5,0.1,1.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    /*if(iMouse.z>=0. && isKeyHeld(Q)){\n        Ray save_ray = Ray(eye, 0.5, normalize(w+px.x*u+px.y*v), 500.);\n    }*/\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\nRay get_ray(){\n    Ray savedray = Ray(vec3(0.), 0.5, vec3(0.), 500.);\n    savedray.P = texelFetch(iChannel0, ivec2(2,0), 0).yzw;\n    savedray.V = texelFetch(iChannel0, ivec2(2,0), 0).yzw;\n    return savedray;\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    Ray savedray = get_ray();\n\n    \n    if(iMouse.z>=0. && isKeyHeld(Q)){\n        savedray = Camera(iMouse.xy, eye, data);\n    }\n    \n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.006, 102);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    \n    \n    /* //Debug\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    \n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T);\n    //else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n    vec3 prevcol = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    float lambda = 0.3;\n    fragColor.rgb = (1.-lambda)*fragColor.rgb + lambda*prevcol;\n\n    fragColor.w = result.T;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n    if(fragCoord.x == 2.5 && fragCoord.y == 0.5){ // pixel (2,0)\n        fragColor.yzw = vec3(savedray.P);\n    }\n    if(fragCoord.x == 3.5 && fragCoord.y == 0.5){ //pixel (3,0)\n        fragColor.yzw = vec3(savedray.V);\n    }\n    \n\n}","name":"Buffer A","description":"","type":"buffer"}]}