{"ver":"0.1","info":{"id":"clB3Rm","date":"1672993825","viewed":67,"name":"Floating Points 5","username":"electrocnic","description":"floating point","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["trippy"],"hasliked":0,"parentid":"mt23RW","parentname":"Floating Points 4"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float M_E = 2.71828182845904523536028747135266250;\n\nfloat get_factor_for_line_drawing(float thickness, float pos_offset, float pos_input) {\n    return 1. - pow(M_E, -thickness * pow(pos_input - pos_offset,8.));\n}\n\nfloat get_factor_for_point(float thickness_mod, float pos_offset_x, float pos_offset_y, float pos_input_x, float pos_input_y) {\n    float factor_x = get_factor_for_line_drawing(thickness_mod, pos_offset_x, pos_input_x);\n    float factor_y = get_factor_for_line_drawing(thickness_mod, pos_offset_y, pos_input_y);\n    float final_line_fac = 1. - (factor_x + factor_y);\n    return max(0.0, min(final_line_fac, 1.));\n}\n\nfloat get_direction_from_index(float i, float a, float p) {\n    return (4.*a / p) * abs(mod((i - p/4.), p) - p/2.) - a;\n}\n\nfloat get_x_dir(int i, float p) {\n    return get_direction_from_index(float(i), 1., p);\n}\n\nfloat get_y_dir(int i, float p) {\n    return get_direction_from_index(float(i) + 0.25*p, 1., p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv -= 0.5;\n    float res_fac = iResolution.x/iResolution.y;\n    uv.x *= res_fac;\n\n    float thickness_mod = 200000000000000000.;\n    \n    int point_count = 50;\n    int angle_count = 8;\n    float stop_at = 0.2; // between 0.0 and 0.5\n    float speed = 30.;\n    float x_drift = 0.25;\n\n    float final_fac = 0.;\n    \n    for (int i=0; i<angle_count; i++) { // for each angle\n        float x_dir = get_x_dir(i, float(angle_count));\n        float y_dir = get_y_dir(i, float(angle_count));\n        for (int j=0; j<point_count; j++) { // for each point per angle\n            float pos_offset_x = (0.5*res_fac + x_dir*x_drift*res_fac*sin(speed/float(point_count)*iTime)); // TODO: find equi speed independent of point count.\n            float pos_offset_y = (0.5 + y_dir*0.5*sin(speed/float(point_count)*iTime));\n            pos_offset_x = min((1.-stop_at)*res_fac, pos_offset_x);\n            pos_offset_x = max(stop_at*res_fac, pos_offset_x);\n            pos_offset_y = min((1.-stop_at), pos_offset_y);\n            pos_offset_y = max(stop_at, pos_offset_y);\n            final_fac += get_factor_for_point(thickness_mod, pos_offset_x, pos_offset_y, uv.x, uv.y);\n        }\n    }\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(final_fac*col,1.0);\n}","name":"Image","description":"","type":"image"}]}