{"ver":"0.1","info":{"id":"slKGWd","date":"1638561895","viewed":190,"name":"BoidsBuffer1","username":"ASchneidman","description":"Simple boids","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nvec3 hsv2rgb(vec3 c)\n{\n    // from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for (float i = 0.0; i < N_BOIDS; i++) {\n        vec4 p_v = get_boid(int(floor(i)), iChannel0);\n        vec2 pos = p_v.xy;\n        vec2 dir = normalize(p_v.zw);\n        \n        float rot = acos(dir.y) * sign(dir.x);\n        \n        if (distance(pos, fragCoord) < BOID_SIZE) {\n            vec3 color = hsv2rgb(vec3((rot + PI) / 2.*PI, 0.7, 1.0));\n            fragColor = vec4(color, 1.0);\n            return;\n        }\n    }\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 clamp_vec(vec2 v, float max_norm) {\n    if (length(v) < max_norm) {\n        return v;\n    }\n    return normalize(v) * max_norm;\n}\n\nvec2 wrap(vec2 v) {\n    float x = mod(v.x, iResolution.x);\n    if (x < 0.) {\n        x += iResolution.x;\n    }\n    float y = mod(v.y, iResolution.y);\n    if (y < 0.) {\n        y += iResolution.y;\n    }\n       \n    return vec2(x, y);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if (fragCoord.x >= N_BOIDS || fragCoord.y > 0.5) {\n        discard;\n    }\n    \n    int id = int(floor(fragCoord.x));\n    \n    vec2 pos, vel;\n    if (iFrame < 2) {\n        pos = wrap(vec2(rand(fragCoord), rand(fragCoord + 1.0)));\n        vel = clamp_vec(vec2(rand(fragCoord - 1.0), rand(fragCoord + 2.0)), MAX_VELOCITY);\n        \n        fragColor = vec4(pos.x, pos.y, vel.x, vel.y);\n        return;\n    }\n    \n    vec4 p_v = get_boid(id, iChannel0);\n    pos = p_v.xy;\n    vel = p_v.zw;\n   \n     \n    vec2 forceCollision = vec2(0.0);\n    vec2 flockCenter = vec2(0.0);\n    vec2 forceAlign = vec2(0.0);\n    float flockSize = 0.0;\n\n    for (float i = 0.0; i < N_BOIDS; i++) {\n        int otherId = int(floor(i));\n        if (otherId == id)\n            continue;\n        \n        vec4 p_v = get_boid(otherId, iChannel0);\n        vec2 otherPos = p_v.xy;\n        vec2 otherVel = p_v.zw;\n        float dist = distance(otherPos, pos);\n        if (dist < INFLUENCE) {\n            flockSize += 1.0;\n            flockCenter += otherPos;\n            forceAlign += otherVel;\n            \n            forceCollision += (1.0 / (dist + 1e-3)) * normalize(pos - otherPos);\n        }\n    }\n    \n    forceAlign /= flockSize;\n    flockCenter /= flockSize;\n    \n    vec2 forcePos = (flockCenter - pos);\n        \n    vec2 force = forcePos * POSITION_WEIGHT + forceCollision * COLLISION_WEIGHT + forceAlign * ALIGN_WEIGHT;\n\n    vel += clamp_vec(force * dt, MAX_ACC);\n    vel = clamp_vec(vel, MAX_VELOCITY);\n    \n    vec2 change = dt * vel;\n    \n    if ((pos + change).x < 0.0 || (pos + change).x >= iResolution.x) {\n        vel *= vec2(-1.0, 1.0);\n        change = dt * vel;\n    }\n    if ((pos + change).y < 0.0 || (pos + change).y >= iResolution.y) {\n        vel *= vec2(1.0, -1.0);\n        change = dt * vel;\n    }\n    \n    pos += dt * vel;\n    \n    fragColor = vec4(wrap(pos), vel);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define N_BOIDS 100.0\n#define BOID_SIZE 10.\n#define INFLUENCE 50.\n\n#define ALIGN_WEIGHT .3\n#define POSITION_WEIGHT .3\n#define COLLISION_WEIGHT 100.0\n\n#define MAX_ACC 100.\n#define MAX_VELOCITY 15.0\n\n#define dt 0.3\n\n\nvec4 get_boid(int id, sampler2D channel) {\n    return texelFetch(channel, ivec2(id, 0), 0);\n}","name":"Common","description":"","type":"common"}]}