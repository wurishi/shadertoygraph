{"ver":"0.1","info":{"id":"3dXyW2","date":"1585556298","viewed":93,"name":"Ray marching hard shadows","username":"arnauaguilaremanuel","description":"test to raymarch and shadows","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nvec3 spherePos = vec3(0.,0.,0.);\nvec3 cubePos = vec3(0.,0.,0.);\n\n\nfloat smothMin(float distA, float distB, float k){\n\tfloat h = max(k-abs(distA-distB),0.)/k;\n    return min(distA, distB)- h*h*h*k/1./6.0;\n}\n\nfloat signedDistanceBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat signedDistanceSphere(vec3 currentPoint, vec3 pos, float rad){\n\treturn length(currentPoint - pos) - rad;\n}\n\nfloat sdPlane( vec3 p, float height )\n{\n\treturn p.y - height;\n}\n\nfloat getDist(vec3 currentPoint){\n\tvec3 pos = spherePos + vec3(1,0,0)*sin(iTime/2.);\n    float distSphere = signedDistanceSphere(currentPoint, pos, .2);\n    \n   \tpos = cubePos- vec3(1,0,0)*(sin(iTime));\n    float distCube = signedDistanceBox(currentPoint, vec3(.1,.5,.5));\n    \n    float distFloor = sdPlane(currentPoint,-1.);\n    \n    return min(smothMin(distSphere, distCube,1.), distFloor);\n\n}\n\n\n\n// raymarching-------------------------------------------\nfloat shortestDistance(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        //distformula for one sphere\n        float dist = getDist(eye + depth * marchingDirection);\n        \n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec3 getRayDir(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n//--------------------------------------------------------------\n// phong--------------------------------------------------------\n\nvec3 shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    vec3 p;\n    for( float t=mint; t<maxt; )\n    {\n        p=ro + rd*t;\n        float h = getDist(ro + rd*t);\n        if( h<0.001 )\n            return p;\n        t += h;\n    }\n    return p;\n}\n\nvec3 estimateNormal(vec3 p) {// aproximated normal(screen space)\n    return normalize(vec3(\n        getDist(vec3(p.x + EPSILON, p.y, p.z)) - getDist(vec3(p.x - EPSILON, p.y, p.z)),\n        getDist(vec3(p.x, p.y + EPSILON, p.z)) - getDist(vec3(p.x, p.y - EPSILON, p.z)),\n        getDist(vec3(p.x, p.y, p.z  + EPSILON)) - getDist(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, float shadowInfo) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN)  * shadowInfo;\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha)) * shadowInfo;\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, float shadowInfo) {\n    vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    \n    vec3 light1Pos = vec3(4.* sin(iTime),\n                          2.,\n                          4.* cos(iTime));\n    vec3 light1Intensity = vec3(0.6, 0.6, 0.6);\n    \n    color += phongLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity,\n                       \t\t\t\tshadowInfo); \n    \n    return color;\n}\n//--------------------------------------------------------------\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = getRayDir(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(sin(iTime/3.)* 7., 1., cos(iTime/3.)* 7.);\n    dir = ( viewMatrix(eye, vec3(0), vec3(0,1.,0))*vec4(dir,0)).xyz;\n    \n    float dist = shortestDistance(eye, dir, MIN_DIST, MAX_DIST);\n    \n    \n    if (dist > MAX_DIST - EPSILON) {// nothing on the way\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n     vec3 light1Pos = vec3(4.* sin(iTime),\n                          2.,\n                          4.* cos(iTime));\n    vec3 lightDir = p - light1Pos;\n    \n    vec3 shadowPoint = shadow(light1Pos, normalize(lightDir),0.,255.);\n    float shadowInfo = 0.;\n    \n    if(length(shadowPoint -p)<0.05)\n        shadowInfo = 1.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,shadowInfo);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}