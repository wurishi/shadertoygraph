{"ver":"0.1","info":{"id":"DtsXDH","date":"1677016674","viewed":115,"name":"Gabor Volcano","username":"enuyeel","description":"Gabor Volcano by Yune '23 (twitter: @yuneismyname / website: https://yuneismyname.com)\n\nA breakdown of @guil's volcano-ish (in cross-section) 2D heightmap texture generation logic demonstrated in the submission 'Gavoronoise'.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","texture","heightmap","gabor","volcano","crater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gabor Volcano\n// by Yune 2023 (twitter: @yuneismyname / website: https://yuneismyname.com)\n// https://www.shadertoy.com/view/DtsXDH\n\n/*\n    A breakdown of @guil's volcano-ish (in cross-section) 2D heightmap texture \n    generation logic demonstrated in the submission 'Gavoronoise'\n    [https://www.shadertoy.com/view/llsGWl]. Its 3D variant also appears in \n    multitudes of submissions and is used to calculate normals for cratered\n    planets. Use LaTeX editor for viewing any formulas you come across.\n    Also, refer to the following link for the cross-section ;)\n    https://graphtoy.com/?f1(x,t)=1.0*exp(-abs(x)*0.5*(1/.3535533905932738)*(1/.3535533905932738))&v1=false&f2(x,t)=sin(5.0*PI*sqrt(abs(x)))&v2=false&f3(x,t)=f1(x,t)*f2(x,t)&v3=true&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0.2868719358167833,0.2482971235567538,1.6215668511724775    \n    \n    References:\n        - [https://www.shadertoy.com/view/llSGRw] Mercury craters by @guil\n        - [https://www.shadertoy.com/view/4tB3RR] Gavoronoise 3d  by @guil\n        - [https://www.shadertoy.com/view/MtjGRD] Moon craters    by @guil\n        - [https://www.shadertoy.com/view/XsBGDc] Gabor2          by @FabriceNeyret2\n        \n    TODO:\n        - Add 'cell variability', and update vec2(i, j)-0.5 as lattice points\n        to better follow the original code.\n        \n    Updated:\n*/\n\nfloat gavor2(in vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    \n    float sigma = .3535533905932738; //original code; -0.125*0.5 yields -4.0, sqrt(0.125) ~ .0353553\n    \n    float wt = 0.0;\n    float va = 0.0;\n    //float v = 0.3; \n\n    for (int i = -1; i <= 1; ++i)\n    for (int j = -1; j <= 1; ++j)\n    {\n        //random displacement (from the lattice);\n        //vec2(i, j) + rd is the random volcano's center\n        vec2 rd = hash22(ip + vec2(i, j));\n        //displacement vector;\n        //between the volcano's center and the current input point: [0, 2]\n        vec2 dv = vec2(i, j) + rd - fp; //verbose; (ip + vec2(i, j) + rd) - (ip + fp);\n        \n        //lattice point is offsetted by 0.5\n        //vec2 o = vec2(i, j) - 0.5;\n        //random displacement (from the lattice)\n        //vec2 rp = hash22(ip - o);       \t\t\n        //vec2 d = fp + o - v * rp;\n        \n        //distance squared; [0, 8]\n        float dd = dot(dv, dv);\n        \n        /*\n          Gaussian function (1D)\n          \n          a\\hspace{1mm}exp(\\frac{-(x-b)^2}{2c^2})\n        \n          a: the height of the curve's peak\n        \n          b: the position of the center of the peak; (x - b)^2 is the offset from the center squared,\n          which basically means how far off the current (input) point is to the randomly located\n          volcano's center.\n        \n          c: the standard deviation (sigma), controls the width of the \"bell\"; smaller sigma means- \n          more cluster around the mean, and it should create a more steeper slope from the plateau\n          to the ground.\n        */\n        \n        //Gaussian function (2D)\n        //a\\hspace{1mm}exp(\\frac{-((x-b)^2+(y-b)^2)}{2c^2})\n        float g = 1.0 * exp(-dd * 0.5 * (1.0/sigma) * (1.0/sigma));\n        \n        /*\n          Gabor filter (definition from Wikipedia)\n          \"(...) a sinusoidal wave multiplied by a Gaussian function.\"\n          \n          Real Component:\n          g(x,y;\\lambda,\\theta,\\psi,\\sigma,\\gamma)=\n          exp(-\\frac{x'^2 + \\gamma^2y'^2}{2\\sigma^2})\\hspace{1mm}cos(2\\pi\\frac{x'}{\\lambda}+\\psi)\n          \n          Imaginary Component:\n          g(x,y;\\lambda,\\theta,\\psi,\\sigma,\\gamma)=\n          exp(-\\frac{x'^2 + \\gamma^2y'^2}{2\\sigma^2})\\hspace{1mm}sin(2\\pi\\frac{x'}{\\lambda}+\\psi)\n          \n          x'=x\\hspace{1mm}cos\\theta+y\\hspace{1mm}sin\\theta\n          y'=-x\\hspace{1mm}sin\\theta+y\\hspace{1mm}cos\\theta\n          \n          gamma : spatial aspect ratio;\n \n          lambda : wavelength of the sinusoidal factor\n        \n          psi: phase offset\n        \n          sigma: sigma/standard deviation of the Gaussian envelope\n        */\n\n        /* Above is the by-the-book definition for Gabor function, but really it's just a sinusoid\n           multiplied by a Gaussian function.\n           \n           We might be able to come up with a parameterized sinusoid to really try matching the\n           definition, but I'll just leave the original implementation by @guil here.\n           \n           One thing to keep in mind, is how 'dd' is not a 2D, but a 1D value. It's fed into sinusoid \n           (and a Gaussian function), and it's the key to orienting sinusoid to the (random) point.\n           \n           Why picking imaginary component (sin) over real (cos)?\n           It has much to do with the shape of the volcano!\n        */\n        va += g * sin(5.0 * M_PI * sqrt(dd));\n        \n        //normalization?; sin():[-1.0, 1.0], g:[0.0, a]\n        wt += g;\n    }\n    \n    return va / wt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / min(iResolution.x, iResolution.y);\n    float uvScale = 5.0;\n    float uvOffset = 0.0;\n    uv *= uvScale;\n    uv += uvOffset;\n    uv += vec2(iTime);\n\n    vec3 color = vec3(gavor2(uv));\n    \n    //color = color / (color + vec3(1.0)); //Reinhard Tonemapping\n    //color = pow(color, vec3(INV2P2));    //Gamma Correction\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.141592653589793238\n#define INV2P2 0.4545454545454545\n#define SQRT8 2.82842712474619\n\n//----------------------------------------------------------------------------------------\n// [https://www.shadertoy.com/view/4djSRW]\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n// by @Dave_Hoskins\n\n//  1 out, 2 in...\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n//----------------------------------------------------------------------------------------\n","name":"Common","description":"","type":"common"}]}