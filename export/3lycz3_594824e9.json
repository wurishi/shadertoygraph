{"ver":"0.1","info":{"id":"3lycz3","date":"1611411659","viewed":172,"name":"JFA coastal flow","username":"ming","description":"Generate coastal flow map using JFA\n- Click on the left portion: show flow map\n- Click on the right portion: show distance","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","flow","jfa","dt"],"hasliked":0,"parentid":"WlGyR3","parentname":"Jump Flooding DT"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original shader https://www.shadertoy.com/view/4syGWK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // calculate the distance to the nearest neighbour\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    \n    float lum = 1.0;\n    \n    if (iMouse.z > 0.0) {\n        \n        // click on left, show the flow map\n        if (iMouse.z < iResolution.x / 2.) {\n            fragColor = vec4(data.xy * data.z, 0.0, 0.0);\n            return;\n        }\n        \n        // click on right, show the distance field\n        lum *= data.w;\n    }\n    \n\n    vec2 flow = (data.xy * 2.0 - 1.0) * data.z;\n    \n    // some fake lighting\n    lum *= dot(flow, flow) * 0.375 + 0.625;\n    \n    // standrad flow map rendering\n    vec2 distort = flow * 0.5;\n    float scaletime = (iTime) * 0.25;\n    float flow_t0 = fract(scaletime);\n    float flow_t1 = fract(scaletime + .5);\n    float alternate = abs((flow_t0 -.5) * 2.);\n\n\n    vec4 samp0 = texture(iChannel1, uv + distort * flow_t0); \n    vec4 samp1 = texture(iChannel1, uv + distort * flow_t1);\n\n    vec4 color = mix(samp0, samp1, alternate) * lum;\n    \n    // 2.2 Gamma compensation\n    fragColor = pow(color, vec4(0.4545));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pass = pass_id();\n    \n    if (pass < 0.5) {\n        // init\n        vec2 uv = sprite_uv(fragCoord, iResolution.xy, iTime * 5.0);\n        vec4 color = texture(iChannel1, uv);\n        \n        // store the coordinate for non-empty pixels, otherwise zero\n        if (is_solid(color.rgb)) {\n            store(fragColor, vec4(fragCoord,0.0,0.0));\n        } else {\n            store(fragColor, vec4(0.0));\n        }\n    } else {\n        // JFA passes (for up to 4096x4096, 0 - 11)\n        float level = clamp(pass - 1.0, 0.0, 11.0);\n        int stepwidth = int(exp2(11.0 - level)+0.5);\n        \n        ivec2 tc = ivec2(fragCoord + 0.5);\n        \n        float best_dist = 999999.0;\n        vec2 best_coord = vec2(0.0);\n        vec2 center = vec2(tc);\n        \n        // search the 3x3 neighbours\n        for (int y = -1; y <= 1; ++y) {\n            for (int x = -1; x <= 1; ++x) {\n                ivec2 fc = tc + ivec2(x,y)*stepwidth;\n\t\t        vec2 ntc = load0(fc).xy;\n                \n                if ((ntc.x != 0.0) && (ntc.y != 0.0)) {\n                    // compare the squared distance\n                    vec2 diff = ntc - center;\n                    float d = dot(diff, diff);\n                    if (d < best_dist) {\n                        best_dist = d;\n                        best_coord = ntc;\n                    }\n                }\n            }\n        }        \n        store(fragColor,vec4(best_coord,0.0,0.0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// 4096 = 2^12; and 1 init step\n#define pass_id() mod(float(iFrame),13.0);\n#define last_pass_id 12.0\n\nvec2 sprite_uv( in vec2 coord, in vec2 resolution, in float time )\n{\n    vec2 uv = coord / resolution.xy;\n    uv.x = clamp(uv.x * resolution.x / resolution.y - 0.3, 0.0, 1.0);\n    float ww = 40.0/256.0;\n    return floor(mod(time, 6.0)) * vec2(ww,0.0) + vec2(ww,1.0) * uv;\n}\n\nbool is_solid(vec3 color) {\n    float lum = dot(color.rgb,vec3(0.299, 0.587, 0.114));\n    return (lum < 0.4);\n}\n\n\nvoid store(out vec4 t, vec4 v) {\n    t = v;\n}\n\nvec4 load(sampler2D channel, vec2 res, ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / res;\n    return texture(channel, uv);\n}\n\n#define load0(p) load(iChannel0, iChannelResolution[0].xy, p)\n#define load1(p) load(iChannel1, iChannelResolution[1].xy, p)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 getFlow(vec2 center, ivec2 tc)\n{\n    vec2 nearest = load0(tc).xy;\n        \n    vec2 diff = center - nearest;\n\n    if (abs(diff).x < 1.0 && abs(diff).y < 1.0) {\n        return vec2(0.0, 0.0);\n    }\n    else {\n        vec2 flow = diff;\n        return flow;\n    }\n}\n\nfloat getD(vec2 center)\n{\n    ivec2 tc = ivec2(center + 0.5);\n    \n    vec2 nearest = load0(tc).xy;\n        \n    vec2 diff = nearest - center;\n    return length(diff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pass = pass_id();\n    \n    if (pass == last_pass_id) {\n        // update from Buffer A in every last pass in each iteration\n        vec2 center = fragCoord;\n        \n        float inv_width = 1.0 / 128.0;\n        float s = 10.0;\n        vec4 dxdy;\n        dxdy.x = getD(center + vec2(-s, 0.0)); //-x\n        dxdy.y = getD(center + vec2( s, 0.0)); //+x\n        dxdy.z = getD(center + vec2( 0.0,-s)); //-y\n        dxdy.w = getD(center + vec2( 0.0, s)); //+y\n        \n        dxdy = min(vec4(1.0), dxdy * inv_width);\n        \n        float d = min(1.0, getD(center) * inv_width); \n        \n        // flow = gradient\n        vec2 flow = vec2(dxdy.x - dxdy.y, dxdy.z - dxdy.w);\n        \n        // safe normalize\n        float len = length(flow);\n        \n        if (len > 1e-7)\n            flow = flow / len;\n        else\n            flow = vec2(0.0, 0.0);\n            \n        // fade out the flow\n        float falloff = 1.0 - d;\n        \n        store(fragColor, vec4(flow * 0.5 + 0.5, falloff * falloff, d));\n    }\n    else {\n        // otherwise keeps Buffer B's cached results\n        store(fragColor, load1(ivec2(fragCoord + 0.5)));\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}