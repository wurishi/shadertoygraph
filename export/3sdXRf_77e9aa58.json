{"ver":"0.1","info":{"id":"3sdXRf","date":"1572518778","viewed":271,"name":"Mirror Crystal ","username":"ankd","description":"IFS and reflection","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = acos(-1.);\n\nmat2 rotate(in float r) { float c=cos(r), s=sin(r); return mat2(c,-s,s,c); }\nvec2 rotate(in vec2 p, in float r) { return p * rotate(r); }\nvec3 rotate(in vec3 p, in vec3 r) { p.xy = rotate(p.xy, r.z); p.yz = rotate(p.yz, r.x); p.zx = rotate(p.zx, r.y); return p; }\nvec3 rotate(in vec3 p, in float r) { return rotate(p, vec3(r)); }\n\nfloat sphere(in vec3 p, in float r) { return length(p)-r; }\nfloat box(in vec3 p, in vec3 b) { vec3 d = abs(p)-b; return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.); }\nfloat box(in vec3 p, in float b) { return box(p, vec3(b));}\n\nfloat map(in vec3 p) {\n    float r = 1.5;\n    vec3 q = p;\n    vec3 c = vec3(4.0);\n    q = mod(q-0.5*c, c) - 0.5*c;\n    \n    float d = sphere(q, .5);\n\tfor(int i=0;i<6;i++) {\n    \tfloat fi = float(i);\n        q = abs(q) - r;\n        q.xyz = q.zxy;\n        q = rotate(q, PI/4.);\n        r *= mix(0.55, 0.6, 0.5+0.5*sin(iTime*0.04));\n    }\n    d = max(-d, box(q,r));\n\treturn d;\n}\n\n#define MARCH_THR 5e-4\nfloat trace(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tfloat t = tmm.x;\n    for(int i=0;i<100;i++) {\n    \tfloat tmp = map(ro + rd*t);\n        if(tmp<MARCH_THR || tmm.y<t) break;\n        t += tmp;\n    }\n    return t;\n}\n\n\nvec3 normal(in vec3 p) {\n\tvec2 e = vec2(1., -1.)*1e-4;\n    return normalize(\n    \te.xyy*map(p+e.xyy) +\n    \te.yxy*map(p+e.yxy) +\n    \te.yyx*map(p+e.yyx) +\n    \te.xxx*map(p+e.xxx)\n    );\n}\n\n\n#define MATERIAL_COLOR vec3(0.8,0.9,1.0)\n#define MATERIAL_BRIGHTNESS 2.0\n#define BACKGROUND_COLOR vec3(0.)\n#define REFLECTION 0.5+0.3*sin(iTime*0.25*PI)\nvec3 render(in vec3 ro, in vec3 rd, in vec2 tmm) {\n    vec3 res = vec3(0.);\n    \n\tfloat t = trace(ro, rd, tmm);\n    if(tmm.y<t) return BACKGROUND_COLOR;\n    \n\tvec3 pos = ro + rd*t;\n\tvec3 nor = normal(pos);\n    vec3 ref = reflect(rd, nor);\n    \n    vec3 lp = vec3(-1.);\n    //lp = ro;\n    vec3 ld = normalize(lp-pos);\n    \n    vec3 col = MATERIAL_COLOR * MATERIAL_BRIGHTNESS;\n    col *= clamp(dot(nor, ld)-exp(-1.*length(lp-pos)), 0., 1.);\n    col += pow(clamp(dot(ref, ld), 0., 1.), 30.);\n\n    res += col;\n\n    \n    float theta = 0.5*PI - acos(dot(ref, nor));\n    float tmmx = MARCH_THR / sin(theta);\n    \n    t = trace(pos, ref, vec2(tmmx, tmm.y));\n    if(tmm.y<t) {\n    \tcol = BACKGROUND_COLOR;\n    } else {\n        pos = pos + nor*t;\n        nor = normal(pos);\n        ref = reflect(rd, nor);\n\n        col =  MATERIAL_COLOR * MATERIAL_BRIGHTNESS;\n        col *= clamp(dot(nor, ld), 0., 1.);\n        col += pow(clamp(dot(ref, ld), 0., 1.), 50.);\n    }\n\n    res = mix(res, col, REFLECTION);\n    \n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord.xy*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat t = iTime + 50.;\n    //vec3 ro = 4.*vec3(cos(iTime*0.02), 0., sin(iTime*0.02));\n    //ro = vec3(0., 0., 4.*sin(iTime*0.05));\n    vec3 ro = .25*vec3(cos(t*0.4), 0., sin(t*0.4));\n    //vec3 ta = sin(iTime*vec3(0.43, 0.23, 0.33));\n    vec3 ta = 0.25*vec3(cos(-t*0.3), sin(t*0.1*PI), sin(-t*0.3));\n\n    float cr = (t*0.02);\n    vec3 cz = normalize(ta - ro);\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n    \n    vec3 col = render(ro, rd, vec2(0., 10.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}