{"ver":"0.1","info":{"id":"7ldBzl","date":"1663537002","viewed":64,"name":"Voronoi Snap","username":"lassiter","description":"Voronoi back and forth","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// glslify blows up unless first line is comment or empty\n#define PI 3.1415926535897932384626433832795\n\nvec2 rotate(in vec2 p, in float a) {\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat rand(in float n) {\n\treturn fract(sin(n) * 43758.5453123);\n}\n\nvec2 rand2(in vec2 p) {\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat noise1(in float p) {\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// voronoi distance noise, based on iq's articles\nfloat voronoi(in vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tvec2 res = vec2(8.0);\n\tfor(int j = -1; j <= 1; j ++) {\n\t\tfor(int i = -1; i <= 1; i ++) {\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + rand2(p + b);\n\n\t\t\t// chebyshev distance, one of many ways to do this\n\t\t\tfloat d = max(abs(r.x), abs(r.y));\n\n\t\t\tif(d < res.x) {\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = d;\n\t\t\t} else if (d < res.y) {\n\t\t\t\tres.y = d;\n\t\t\t}\n\t\t}\n\t}\n\treturn res.y - res.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy  - 0.5;\n\t// voronoi noise\n\t//vec2 uv = fragCoord - 0.5;\n\tfloat phase = sin(iTime * PI);\n\tfloat phaseSm = iTime * 0.1;\n\tfloat v = 0.0;\n\tfloat a = 0.6, f = 2.0;\n\tvec2 dom = uv * phase;\n\tfor(int i = 1; i < 3; i ++) {\n\t\tfloat motion = phaseSm * float(i);\n\t\tfloat v1 = voronoi(dom * f + 5.0);\n\n\t\t// moving electrons-effect\n\t\tfloat v2 = voronoi(uv * f * 0.75 + 50.0);\n\n\t\tfloat va = 1.0 - smoothstep(0.0, 0.2, v1);\n\t\tfloat vb = 1.0 - smoothstep(0.0, 0.08, v2);\n\t\tv += a * pow(va * (0.0 + vb), 4.0);\n\n\t\t// make sharp edges\n\t\tv1 = 1.0 - smoothstep(0.0, 0.2, v1);\n\n\t\t// noise is used as intensity map\n\t\tv2 = a * (noise1(1.0 * 5.5 + 0.1));\n\n\t\tv *= 4.0 * phase;\n\n\t\tf *= 2.0;\n\t\ta *= 0.5;\n\t}\n\n\t// vignette\n\tfloat vignette = max(0.0, 1.0 - length(uv) * 2.0);\n\tv *= vignette;\n\tvec3 voronoiColor = vec3(v * 2.0);\n\n\t// prismatic color gradient\n\tvec3 colorShift = vec3(uv, 0.5 + 0.5 * sin(iTime));\n\n\tfragColor = vec4(voronoiColor + voronoiColor * colorShift, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}