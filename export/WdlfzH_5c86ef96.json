{"ver":"0.1","info":{"id":"WdlfzH","date":"1587822441","viewed":211,"name":"Starry blur 2","username":"vegardno","description":"Playing around.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["blur","artistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Starry blur 2 by vegardno\n// based on:\n//\n// Starry blur by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/tsXBRH\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 q = fragCoord/iResolution.xy;\n\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).bgr;\n    \n    col = col*smoothstep(-0.25,.9,q.y)*1.35;\n\tcol *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15)*0.4 + 0.6;\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//MIT licensed 2d gradient noise and analytic derivatives from iq (see: https://www.shadertoy.com/view/4dffRH)\n\nvec2 hash( in vec2 x )\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0); \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\n\tUsing 2d noise derivatives to displace texture fetches by the curl of a field\n\tnormalizing the resulting vector to get uniform displacement.\n*/\n\nconst float numTap = 15.;\n\nvec2 getField(vec2 p)\n{\n    float e = 1e-4;\n    return vec2(noised(p + vec2(e, 0)).x - noised(p - vec2(e, 0)).x,\n                noised(p + vec2(0, e)).x - noised(p - vec2(0, e)).x);\n}\n\nvec2 rotate(float a, vec2 v)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c) * v;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n\n    if (iFrame < 10) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 p = q*vec2(iResolution.x/iResolution.y, 1.);\n    \n    vec2 dsp = normalize(getField(3. * p));\n\n    vec3 old_col = textureLod(iChannel0, q, 0.).rgb;\n    vec3 new_col = textureLod(iChannel1, q + .1 * rotate(radians(90.), dsp) / iResolution.y, 0.).rgb;\n\n    vec3 col = mix(old_col, new_col, float(rand(fragCoord + iTime) < .991));\n\n    fragColor = vec4(col, 1.);\n    return;\n\n}","name":"Buffer A","description":"","type":"buffer"}]}