{"ver":"0.1","info":{"id":"wsXBzr","date":"1587595276","viewed":388,"name":"DNA Helis","username":"jaszunio15","description":"Trying to create very simple and nice visual effect.\n\nThanks to @FabriceNeyret2 and @tb for useful tips :)\n\nYou can find first version of this shader at the bottom of the code :)\n\n//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","fake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n#define TIME (iTime)\n#define SIN_DENSITY 0.4\n#define COLOR_DIFFERENCE 0.8\n\nfloat linearstep(float a, float b, float x)\n{\n \treturn clamp((b - x) / (b - a), 0.0, 1.0);\n}\n\n\n//x - circle alpha\n//y - circle color\n//Thanks to FabriceNeyret2 for this idea\nvec2 circle(vec2 uv, float pixelSize, float sinDna, float cosDna, float _sign)\n{\n    float height = _sign * sinDna;\n    float depth = abs((_sign * 0.5 + 0.5) - (cosDna * 0.25 + 0.5));\t//this 0.25 is quite bad here\n    float size = 0.2 + depth * 0.1;\n    float alpha = 1.0 - smoothstep(size - pixelSize, \n                                   size + pixelSize, \n                                   distance(uv, vec2(0.5, height)));\n    \n    return vec2(\n        alpha, \n        depth * COLOR_DIFFERENCE + (1.0 - COLOR_DIFFERENCE)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    //scale\n\tuv *= 5.0;\n    \n    //rotation for angle=0.3\n    //optimized version of uv *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle)); by FabriceNeyret2\n    float angle = 0.3;\n    uv *= mat2(cos(angle + vec4(0,11,33,0)));\n\n    //move over time\n    uv.x -= TIME * 0.5;\n    \n    //basic variables\n    float pixelSize = 10.0 / iResolution.y;\n    vec2 baseUV = uv;\n    uv.x = fract(uv.x);\n    float lineIndex = floor(baseUV.x);\n    float dnaTimeIndex = lineIndex * SIN_DENSITY + TIME;\n    float sinDna = sin(dnaTimeIndex) * 2.0;\n    float cosDna = cos(dnaTimeIndex) * 2.0;\n    \n    //draw straight line\n    float lineSDF = abs(uv.x - 0.5);\n    float line = smoothstep(pixelSize * 2.0, 0.0, lineSDF);\n    \n    //cut upper part of the lines\n    float sinCutLineUp = abs(sinDna);\n    float sinCutMaskUp = smoothstep(sinCutLineUp + pixelSize, sinCutLineUp - pixelSize, uv.y);\n    \n    //cut lower part of the lines\n    float sinCutLineDown = -abs(sinDna);\n    float sinCutMaskDown = smoothstep(sinCutLineDown - pixelSize, sinCutLineDown + pixelSize, uv.y);\n    \n    //Create first side of dna circles\n    vec2 circle1 = circle(uv, pixelSize, sinDna, cosDna, 1.0);\n    \n    //Second side of dna circles\n    vec2 circle2 = circle(uv, pixelSize, sinDna, cosDna, -1.0);\n    \n    //Calculating line gradient for depth effect\n    //Thanks to @tb for this 3D effect idea\n    float lineGradient = linearstep(sinCutLineUp, sinCutLineDown, uv.y);\n    if (sin(lineIndex * SIN_DENSITY + TIME) > 0.0) lineGradient = 1.0 - lineGradient;\n    lineGradient = mix(circle1.y, circle2.y, lineGradient);\n    \n    //rendering line\n    float helis = 0.0;\n    \n    //rendering circles \n    if (circle1.y < circle2.y)\n    {\n        helis = mix(helis, circle1.y, circle1.x);\n        helis = mix(helis, lineGradient, line * sinCutMaskUp * sinCutMaskDown);\n    \thelis = mix(helis, circle2.y, circle2.x);\n    }\n    else\n    {\n        helis = mix(helis, circle2.y, circle2.x);\n        helis = mix(helis, lineGradient, line * sinCutMaskUp * sinCutMaskDown);\n        helis = mix(helis, circle1.y, circle1.x);\n    }\n    \n    fragColor = vec4(helis);\n}\n\n/* Before refactor\n#define TIME (iTime)\n#define SIN_DENSITY 0.4\n#define COLOR_DIFFERENCE 0.8\n\nfloat linearstep(float a, float b, float x)\n{\n \treturn clamp((b - x) / (b - a), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    //scale\n\tuv *= 5.0;\n    \n    //rotation\n    float angle = 0.3;\n    uv *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    \n    //move over time\n    uv.x -= TIME * 0.5;\n    \n    //basic variables\n    float pixelSize = fwidth(uv.x);\n    vec2 baseUV = uv;\n    uv.x = fract(uv.x);\n    float lineIndex = baseUV.x - fract(baseUV.x);\n    \n    //draw straight line\n    float lineSDF = abs(uv.x - 0.5);\n    float line = 1.0 - smoothstep(0.0, pixelSize * 2.0, lineSDF);\n    \n    //dna time\n    float dnaTimeIndex = lineIndex * SIN_DENSITY + TIME;\n    \n    //cut upper part of the lines\n    float sinCutLineUp = abs(sin(dnaTimeIndex) * 2.0);\n    float sinCutMaskUp = 1.0 - smoothstep(sinCutLineUp, sinCutLineUp + pixelSize, uv.y);\n    \n    //cut lower part of the lines\n    float sinCutLineDown = -abs(-sin(dnaTimeIndex) * 2.0);\n    float sinCutMaskDown = smoothstep(sinCutLineDown, sinCutLineDown + pixelSize, uv.y);\n    \n    //create circles\n    float firstCircleCenter = sin(dnaTimeIndex) * 2.0;\n    float firstCircleDistance = cos(lineIndex * SIN_DENSITY + TIME) * 0.5 + 0.5;\n    float firstCircleSize = 0.1 + firstCircleDistance * 0.2;\n    float firstCircle = 1.0 - smoothstep(firstCircleSize, \n                                         firstCircleSize + pixelSize * 2.0, \n                                         distance(uv, vec2(0.5, firstCircleCenter)));\n    \n    //create other\n    float secondCircleCenter = -sin(dnaTimeIndex) * 2.0;\n    float secondCircleDistance = -cos(dnaTimeIndex) * 0.5 + 0.5;\n    float secondCircleSize = 0.1 + secondCircleDistance * 0.2;\n    float secondCircle = 1.0 - smoothstep(secondCircleSize, \n                                          secondCircleSize + pixelSize * 2.0, \n                                          distance(uv, vec2(0.5, secondCircleCenter)));\n    \n    //Calculating line gradient for depth effect\n    float lineGradient = linearstep(sinCutLineUp, sinCutLineDown, uv.y);\n    if (sin(lineIndex * SIN_DENSITY + TIME) > 0.0) lineGradient = 1.0 - lineGradient;\n    firstCircleDistance = firstCircleDistance * COLOR_DIFFERENCE + (1.0 - COLOR_DIFFERENCE);\n    secondCircleDistance = secondCircleDistance * COLOR_DIFFERENCE + (1.0 - COLOR_DIFFERENCE);\n    lineGradient = mix(firstCircleDistance, secondCircleDistance, lineGradient);\n    \n    //rendering line\n    float helis = line * sinCutMaskUp * sinCutMaskDown * lineGradient;\n    \n    //rendering circles \n    if (firstCircleDistance < secondCircleDistance)\n    {\n        helis = mix(helis, firstCircleDistance, firstCircle);\n    \thelis = mix(helis, secondCircleDistance, secondCircle);\n    }\n    else\n    {\n        \n    \thelis = mix(helis, secondCircleDistance, secondCircle);\n        helis = mix(helis, firstCircleDistance, firstCircle);\n    }\n    \n    \n    fragColor = vec4(helis);\n}\n*/\n\n/* Firstest version\n#define TIME (iTime)\n#define SIN_DENSITY 0.4\n#define COLOR_DIFFERENCE 0.8\n\nfloat linearstep(float a, float b, float x)\n{\n \treturn clamp((b - x) / (b - a), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    //scale\n\tuv *= 5.0;\n    \n    //rotation\n    float angle = 0.3;\n    uv *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    \n    //move over time\n    uv.x -= TIME * 0.5;\n    \n    //basic variables\n    float pixelSize = fwidth(uv.x);\n    vec2 baseUV = uv;\n    uv.x = fract(uv.x);\n    float lineIndex = baseUV.x - fract(baseUV.x);\n    \n    //draw straight line\n    float lineSDF = abs(uv.x - 0.5);\n    float line = 1.0 - smoothstep(0.0, pixelSize * 2.0, lineSDF);\n    \n    //dna time\n    float dnaTimeIndex = lineIndex * SIN_DENSITY + TIME;\n    \n    //cut upper part of the lines\n    float sinCutLineUp = abs(sin(dnaTimeIndex) * 2.0);\n    float sinCutMaskUp = 1.0 - smoothstep(sinCutLineUp, sinCutLineUp + pixelSize, uv.y);\n    \n    //cut lower part of the lines\n    float sinCutLineDown = -abs(-sin(dnaTimeIndex) * 2.0);\n    float sinCutMaskDown = smoothstep(sinCutLineDown, sinCutLineDown + pixelSize, uv.y);\n    \n    //create circles\n    float firstCircleCenter = sin(dnaTimeIndex) * 2.0;\n    float firstCircleSize = 0.1 + (cos(dnaTimeIndex) * 0.5 + 0.5) * 0.2;\n    float firstCircle = 1.0 - smoothstep(firstCircleSize, \n                                         firstCircleSize + pixelSize * 2.0, \n                                         distance(uv, vec2(0.5, firstCircleCenter)));\n    \n    //create other\n    float secondCircleCenter = -sin(dnaTimeIndex) * 2.0;\n    float secondCircleSize = 0.1 + (-cos(dnaTimeIndex) * 0.5 + 0.5) * 0.2;\n    float secondCircle = 1.0 - smoothstep(secondCircleSize, \n                                          secondCircleSize + pixelSize * 2.0, \n                                          distance(uv, vec2(0.5, secondCircleCenter)));\n    \n\n    //rendering line\n    float helis = line * sinCutMaskUp * sinCutMaskDown;\n\thelis += firstCircle;\n\thelis += secondCircle;\n\n    fragColor = vec4(helis);\n}\n*/\n","name":"Image","description":"","type":"image"}]}