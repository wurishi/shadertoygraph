{"ver":"0.1","info":{"id":"3tVyzw","date":"1610696620","viewed":147,"name":"Gradient Noise and Perlin Noise","username":"tomoe","description":"Gradient noises generated by different selections of gradient\nLeft: random direction (Up: 3D, Down: 2D)\nRight: restricted direction (Perlin noise) (Up: 3D, Down: 2D)\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bd202101"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nvec2 fragCoord_;  //set as a uniform variable\nvec3[12] gtable3 = vec3[](\n    vec3(1.0, 1.0, 0.0),\n    vec3(1.0, -1.0, 0.0),\n    vec3(-1.0, 1.0, 0.0),\n    vec3(-1.0, -1.0, 0.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 0.0, -1.0),\n    vec3(-1.0, 0.0, 1.0),\n    vec3(-1.0, 0.0, -1.0),\n    vec3(0.0, 1.0, 1.0),\n    vec3(0.0, 1.0, -1.0),\n    vec3(0.0, -1.0, 1.0),\n    vec3(0.0, -1.0, -1.0)\n);\nvec2[8] gtable2 = vec2[](   //0.92387953 = cos(pi/8), 0.38268343 = cos(pi/8)\n    vec2(0.92387953, 0.38268343),\n    vec2(0.38268343, 0.92387953),\n    vec2(-0.92387953, 0.38268343),\n    vec2(-0.38268343, 0.92387953),\n    vec2(0.92387953, -0.38268343),\n    vec2(0.38268343, -0.92387953),\n    vec2(-0.92387953, -0.38268343),\n    vec2(-0.38268343, -0.92387953)\n);\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k.x;\n}\nuvec2 hash22u(uvec2 n) {\n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    if(fragCoord_.x < 0.5 * iResolution.x){\n        //down-left\n        uvec2 n = uvec2(p);\n        vec2 v = vec2(hash22u(n)) / vec2(max32);\n        return normalize(2.0 * v - vec2(1.0));\n    } else {\n        //down-right\n        \n        uint n = hash11u(hash11u(uint(p.x)) + uint(p.y));\n        n = n >> 29;\n        n = n % 8u;\n        return gtable2[n];\n    }\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nvec3 hash33(vec3 p) {\n    if(fragCoord_.x < 0.5 * iResolution.x){\n        //up-left\n        uvec3 n = uvec3(p);\n        vec3 v = vec3(hash33u(n)) / vec3(max32);\n        return normalize(2.0 * v - vec3(1.0));\n    } else {\n        //up-right\n        uint n = hash11u(hash11u(hash11u(uint(p.x)) + uint(p.y)) + uint(p.z));\n        n = n >> 28;\n        n = n % 12u;\n        return gtable3[n] * 0.70710678; //0.70710678 = 1/sqrt(2)\n    }\n}\nfloat gnoise21(vec2 p) {\n    vec2 f = fract(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v + 0.5;\n}\nfloat gnoise31(vec3 p) {\n    vec3 f = fract(p);\n    vec3 g000 = hash33(p);\n    vec3 g001 = hash33(p + vec3(0.0, 0.0, 1.0));\n    vec3 g010 = hash33(p + vec3(0.0, 1.0, 0.0));\n    vec3 g011 = hash33(p + vec3(0.0, 1.0, 1.0));\n    vec3 g100 = hash33(p + vec3(1.0, 0.0, 0.0));\n    vec3 g101 = hash33(p + vec3(1.0, 0.0, 1.0));\n    vec3 g110 = hash33(p + vec3(1.0, 1.0, 0.0));\n    vec3 g111 = hash33(p + vec3(1.0, 1.0, 1.0));\n\n    float v000 = dot(g000, f);\n    float v001 = dot(g001, f - vec3(0.0, 0.0, 1.0));\n    float v010 = dot(g010, f - vec3(0.0, 1.0, 0.0));\n    float v011 = dot(g011, f - vec3(0.0, 1.0, 1.0));\n    float v100 = dot(g100, f - vec3(1.0, 0.0, 0.0));\n    float v101 = dot(g101, f - vec3(1.0, 0.0, 1.0));\n    float v110 = dot(g110, f - vec3(1.0, 1.0, 0.0));\n    float v111 = dot(g111, f - vec3(1.0, 1.0, 1.0));\n     f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float xy0 = mix(mix(v000, v100, f.x), mix(v010, v110, f.x), f.y);\n    float xy1 = mix(mix(v001, v101, f.x), mix(v011, v111, f.x), f.y);\n    return 0.5 * mix(xy0, xy1, f.z) + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy / min(iResolution.x, iResolution.y);\n    pos *= 20.0;\n    pos += iTime;\n    float v;\n    if(fragCoord.y < 0.5 * iResolution.y){\n        v = gnoise21(pos);  //down\n    } else {\n        v = gnoise31(vec3(pos, iTime));   //up \n    }\n    fragColor = vec4(vec3(v), 1.0);\n}","name":"Image","description":"","type":"image"}]}