{"ver":"0.1","info":{"id":"NsycRK","date":"1715620136","viewed":53,"name":"Marching Whatever","username":"vladeeer","description":"1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TAU (2.*PI)\n\nconst float FOV = 1.0;\nconst int MAX_STEPS = 256;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.001;\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n    p = cos(a)*p + sin(a) * vec2(p.y, -p.x);\n}\n\nvec2 fOpUnionID(vec2 res1, vec2 res2)\n{\n    return (res1.x < res2.x) ? res1 : res2;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0.))) + vmax(min(d, vec3(0.)));\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nvec2 map(vec3 p)\n{\n    // Plane\n    float planeDist = fPlane(p, vec3(0, 1, 0), 14.0);\n    float planeID = 2.0;\n    vec2 plane = vec2(planeDist, planeID);\n   \n   \n    // Sphere\n    float sphereDist = fSphere(p, 1.0);\n    float sphereID = 1.0;\n    vec2 sphere = vec2(sphereDist, sphereID);\n    \n    // Box\n    float boxDist = fBox(p, vec3(3., 9., 4.));\n    float boxID = 3.0;\n    vec2 box = vec2(boxDist, boxID);\n    \n    vec2 res;\n    res = box;\n    res = fOpUnionID(res, plane);\n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    vec2 hit, object;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + object.x * rd;\n        hit = map(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p).x) - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 rd, vec3 color)\n{\n    vec3 lightPos = vec3(20.0, 40.0, -30.0);\n    vec3 L = normalize(lightPos - p);\n    vec3 N = getNormal(p);\n    vec3 V = -rd;\n    vec3 R = reflect(-L, N);\n    \n    vec3 specColor = vec3(0.5);\n    vec3 specular = specColor * pow(clamp(dot(R, V), 0.0, 1.0), 10.0);\n    vec3 diffuse = color * clamp(dot(L, N), 0.0, 1.0);\n    vec3 ambient = color * 0.05;\n    \n    // Shadows\n    float d = rayMarch(p + N * 0.01, normalize(lightPos)).x;\n    if (d < length(lightPos - p)) return ambient;\n    return diffuse + ambient + specular;\n}\n\nvec3 getMaterial(vec3 p, float id)\n{\n    vec3 m;\n    switch(int(id)) \n    {\n    case 1:\n    m = vec3(0.9, 0.0, 0.0); break;\n    case 2:\n    m = vec3(0.2 + 0.4*mod(floor(p.x) + floor(p.z), 2.0)); break;\n    }\n    return m;\n}\n\nmat3 getCam(vec3 ro, vec3 lookAt)\n{\n    vec3 camF = normalize(vec3(lookAt - ro));\n    vec3 camR = normalize(cross(camF, vec3(0., 1., 0.)));\n    vec3 camU = cross(camR, camF);\n    \n    return mat3(camR, camU, camF);\n}\n\nvoid mouseControl(inout vec3 ro)\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n    pR(ro.yz, m.y * PI * 0.5 - 0.5);\n    pR(ro.xz, m.x * TAU);\n}\n\nvoid render(inout vec3 col, in vec2 uv)\n{\n    vec3 ro = vec3(10.0, 10.0, -3.0);\n    mouseControl(ro);\n    vec3 lookAt = vec3(0., 0., 0.);\n    vec3 rd = getCam(ro, lookAt) * normalize(vec3(uv, FOV));\n    \n    vec2 object = rayMarch(ro, rd);\n    \n    vec3 background = vec3(0.5, 0.8, 0.9);\n    if (object.x < MAX_DIST)\n    {\n        vec3 p = ro + object.x * rd;\n        vec3 material = getMaterial(p, object.y);\n        col += getLight(p, rd, material);\n        // fog\n        col = mix(col, background, 1.0 - exp(- 0.0008 * object.x * object.x));\n    } else {\n        col += background - max(0.95 * rd.y, 0.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    vec3 col;\n    render(col, uv);\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}