{"ver":"0.1","info":{"id":"XsyyDG","date":"1523044182","viewed":285,"name":"Strauss Lighting Model","username":"PrzemyslawZaworski","description":"  ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["lighting","spheretracing","lambert","strauss"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Reference book: \n//A. Boreskov, E. Shikin - \"Computer Graphics: From Pixels to Programmable Graphics Hardware\"\n\n#define strauss_lightmodel\n\nfloat _smoothness=0.05,_metalness=1.0,_transparency=0.05;\n\nfloat fresnel(float x) \n{\n\tfloat kf = 1.12;\t\t\n\tfloat dx = x - kf;\n\tfloat d1 = 1.0 - kf;\n\tfloat kf2 = kf * kf;\n\tfloat n = 1.0/(dx*dx)-1.0/kf2;\n\tfloat m = 1.0/(d1*d1)-1.0/kf2;\n\treturn n/m;\n}\n\nfloat shadow(float x) \n{\n\tfloat ks = 1.01;\t\t\t\n\tfloat dx = x - ks;\n\tfloat d1 = 1.0 - ks;\n\tfloat ks2 = ks * ks;\n\tfloat n = 1.0/(d1*d1)-1.0/(dx*dx);\n\tfloat m = 1.0/(d1*d1)-1.0/ks2;\n\treturn n/m;\n}\n\nvec4 strauss(vec3 n, vec3 v, vec3 l, vec3 _color) \n{\n\tvec3 h = reflect(l, n);\n\tfloat nl = dot(n, l);\n\tfloat nv = dot(n, v);\n\tfloat hv = dot(h, v);\n\tfloat f = fresnel(nl);\n\tfloat s3 = _smoothness * _smoothness * _smoothness;\n\tfloat Rd = (1.0 - s3) * (1.0 - _transparency);\n\tfloat d = (1.0 - _metalness * _smoothness);\n\tvec3 diffuse = nl * d * Rd * _color.rgb;\n\tfloat r = (1.0 - _transparency) - Rd;\n\tfloat j = f * shadow(nl) * shadow(nv);\n\tfloat k = 0.1;\n\tfloat reflect = min(1.0, r + j * (r + k));\n\tvec3 C1 = vec3(1.0, 1.0, 1.0);\n\tvec3 Cs = C1 + _metalness * (1.0 - f) * (_color.rgb - C1);\n\tvec3 specular = Cs * reflect;\n\tspecular *= pow(-hv, 3.0 / (1.0 - _smoothness));\n\tdiffuse = max(vec3(0.0,0.0,0.0), diffuse);\n\tspecular = max(vec3(0.0,0.0,0.0), specular);\n\treturn vec4(diffuse + specular, 1.0);\t\t\t\n}\t\t\t\n\nvec4 hexagon (vec3 p, vec3 c, vec2 h)\n{\n\tvec3 q = abs(p+c);\n\tvec3 m = vec3 (1.0,0.0,0.0);\n\treturn vec4 (m,max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x));\n}\n\t\t\t\nvec4 sphere (vec3 p,vec3 c,float r)\n{\n\tvec3 m = vec3 (0.0,0.0,1.0);\n\treturn vec4 (m,length (p-c)-r);\n}\n\nvec4 ring (vec3 p, vec3 c, vec2 t)\n{\n\tvec3 m = vec3(1.0,0.64,0.0);\n\tvec2 q = vec2(sqrt((p.x-c.x)*(p.x-c.x)+(p.z-c.z)*(p.z-c.z))-t.x,p.y-c.y);\n\tq=q*q; q=q*q; q=q*q;\n\treturn vec4(m,pow( q.x + q.y, 0.125 )-t.y);\n}\n\t\t\t\t\t\nvec4 map (vec3 p)\n{\n\tvec4 a = hexagon(p,vec3(3,0,0),vec2(1,1));\n\tvec4 b = sphere(p,vec3(3,0,0),1.0);\n\tvec4 c = ring(p,vec3(0,3,0),vec2(1,0.25));\n\tvec4 solid = mix (a,b,step(b.w,a.w));\n\treturn mix (c, solid, step(solid.w,c.w ));\n}\n\t\t\t\nvec3 set_normal (vec3 p)\n{\n\tvec3 x = vec3 (0.01,0.00,0.00);\n\tvec3 y = vec3 (0.00,0.01,0.00);\n\tvec3 z = vec3 (0.00,0.00,0.01);\n\treturn normalize(vec3(map(p+x).w-map(p-x).w,map(p+y).w-map(p-y).w,map(p+z).w-map(p-z).w)); \n}\n\t\nvec3 cubemap(vec3 p) \n{\n\tp.y = max(0.3-p.y,0.0);\n\treturn vec3(pow(1.0-p.y,2.0), pow(1.0-p.y,2.0), 0.0);\n}\t\n\t\t\t\nvec3 lighting (vec3 p, vec3 rd)\n{\n\tvec3 ReflectionDirection=reflect(rd,set_normal(p));\n\tvec3 LightDirection = ReflectionDirection;\n\tvec3 LightColor = cubemap(ReflectionDirection);\n\tvec3 NormalDirection = set_normal(p);\n    #ifdef strauss_lightmodel\n\treturn strauss(NormalDirection,rd,LightDirection,LightColor).rgb;\n    #endif\n    return (max(dot(LightDirection, NormalDirection),0.0) * LightColor);\n}\n\nvec4 raymarch (vec3 ro, vec3 rd)\n{\n\tfor (int i=0; i<128; i++)\n\t{\n\t\tfloat t = map(ro).w;\n\t\tvec3 m = map(ro).xyz;\n\t\tif (t < 0.001) \n\t\t\treturn vec4 (lighting(ro,rd),1.0); \n\t\telse \n\t\t\tro+=t*rd; \n\t}\n\treturn vec4(cubemap(rd),1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3 (0.0,0.2,-8.0);\n\tvec3 rd = normalize(vec3(p,2.0));\n    fragColor = raymarch(ro,rd);\n}","name":"Image","description":"","type":"image"}]}