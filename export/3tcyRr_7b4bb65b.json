{"ver":"0.1","info":{"id":"3tcyRr","date":"1609434753","viewed":78,"name":"fake transparency","username":"CY5","description":"he purpose of demo is to create fake transparency with 2 point light","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["transparency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// RayMarching lookup angles,plane, box ,sphere map and rand \n// in below src code taken from iq shadertoy demo\n//https://iquilezles.org/articles/distfunctions\n\n\n//The purpose of demo is to create fake transparency\n//2 point light source demo  c = c0+1/(kc+kl*d+kq*d*d)\n//https://www.shadertoy.com/view/wdKBRt\n\n\n#define PTL  1\n#define SPH   2\n#define PLN   3\n#define CUBE  4\n\n\n/*vec3  ptLight1Col = vec3(0.764,0.413,0.294);//cyan\nvec3  ptLight2Col = vec3(0.464,0.213,0.294);//magento*/\n\nvec3  ptLight1Col = vec3(1.0,0.0,0.0);//red\nvec3  ptLight2Col = vec3(0.0,0.8,0.0);//green\n\nvec2 randState;\n\nfloat rand()\n{\n   randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n   randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);        \n    \n   return randState.x;\n}\n\n\nstruct PointLight\n{\n    vec3 pos;\n    vec3 col;\n};\n\nstruct Ob\n{\n    float t;\n    vec3  c;\n    PointLight  ptL; \n    int prop;\n};\n\nfloat mapPlane(vec3 p)\n{\n    float r = 0.5;\n    float l = p.y + (r);\n    return l;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat quadEq(float t)\n{\n    return 1.0*t*t+t+0.01;\n}\nfloat mapCube(vec3 p, float r)\n{\n    //p=p-vec3(0.5,0.47,2.0);\n    p = p - vec3(0.4,0.4,0.4);\n    vec3 t = vec3(quadEq(p.x),quadEq(p.y),quadEq(p.z));\n    return length(t)-r;\n}\nfloat map(vec3 p)\n{\n    \n\tfloat sp = sdBox(p,vec3(0.5,0.5,0.5));\n    return sp;\n}\n\nOb map1(vec3 p)\n{\n    Ob o;\n    float tme = iTime*0.5;\n    vec3 pt2 = vec3(0.1*cos(tme),0.0,0.3*sin(tme));\n    vec3 pt1 = vec3(0.3*sin(tme),0.0,0.1*cos(tme));\n    \n    vec3 mov = p-pt1;\n    vec3 mov1 =  p-pt2;\n\tfloat sp = mapCube(p,0.25);\n    float p1 = length(mov)-0.02;\n    float p2 =  length(mov1)-0.02;\n    \n    o.t = min(min(p1,p2),sp);\n    \n    o.ptL.pos = min(mov,mov1);\n    \n    vec3 A= ptLight2Col*(1.0-p2)+ptLight1Col*p2;\n    vec3 B= ptLight1Col*(1.0-p1)+ptLight2Col*p1;\n    \n    o.ptL.col = mix(A,B,0.5);\n    \n    if (sp < p1 && sp < p2)\n    {\n        o.c = vec3(0.1,0.1,0.2);\n        o.prop = CUBE;\n    \n    }\n    if (p1 < sp  && p1 < p2)\n    {\n        o.c = ptLight1Col;\n        o.prop = PTL;\n        \n    }\n    else if (p2 < sp && p2 < p1)\n    {\n        o.c = ptLight2Col;\n        o.prop = PTL;\n    }\n    return o;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec2 e = vec2(0.0001,0.0);\n\treturn normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n\t\t\t\t\t\t  map(pos+e.yxy)-map(pos-e.yxy),\n\t\t\t\t\t\t  map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\n\nfloat inCastRay(in vec3 ro, vec3 rd)\n{\n\tfloat t =0.0;\n\tfor(int i=0;i<100;i++)\n\t{\n\t\tvec3 pos = ro+t*rd;\n\t\tfloat h = map(pos);\n\t\tif (h<0.001)\n\t\t\tbreak;\n\t\tt+=h;\n\t\tif (t>20.0) break;\n\t}\n\tif (t>20.0) t=-0.1;\n\treturn t;\n}\n\nvoid castRay(in vec3 ro, vec3 rd,inout Ob o)\n{\n    float t =0.0;\n    for(int i=0;i<100;i++)\n    {\n        vec3 pos = ro+t*rd;\n        o = map1(pos);\n        float h = o.t;\n        if (h<0.001)\n            break;\n        t+=h;\n        if (t>20.0) break;\n    }\n    if (t>20.0) t=-0.1;\n    o.t =t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n\trandState = (2.0*fragCoord-iResolution.xy)/iResolution.y ;\n\n\t/*float an = 10.0*iMouse.x/iResolution.x;\n\tvec3 ro = vec3(2.0*cos(an),-0.3,2.0*sin(an));*/\n    \n    float an = 10.0*fract(0.05*iTime)+iMouse.x/iResolution.x;\n    float up = cos(iTime)-an;\n    vec3 ro = vec3(2.0*cos(an),-0.3*up,2.0*sin(an));\n    \n\tvec3 ta = vec3(0.0,0.0,0.0);\n    \n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n                        \n\tvec3 rd = normalize(p.x*uu+p.y*vv+1.5*ww);\n    \n    vec3 col = vec3(0.0)-0.7*rd.y;\n    \n\tfloat t = inCastRay(ro, rd);\n\t\n    if (t > 0.0) \n\t{\n        vec3 pos = ro + t*rd;\n        \n        Ob o;\n        castRay(pos-rd, rd,o);\n        if (o.t > 0.0)\n        {\n            float d = length(o.ptL.pos);\n            float kc=0.1, kl=0.5,kq = 0.05;\n            vec3 oc = o.ptL.col;\n            col  = ((1.0/(kc+kl*d+kq*d*d))*oc) ;\n            \n        }\n    \n        vec3 nor = calcNormal(pos);\n        \n        nor +=normalize(vec3(0.0,0.0,0.5));\n        vec3 sun_light=vec3(0.3,0.5,0.1);\n\t\tvec3 mate = vec3(0.8,0.5,0.5);\n        float sun_dif = clamp(dot(nor,sun_light),0.0,1.0);\n        float sky_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n        float boun_dif = clamp(0.9-0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n\n        col = mix(mate,col,0.5);\n\t}\n    \n    \n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}