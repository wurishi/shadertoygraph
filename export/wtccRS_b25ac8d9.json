{"ver":"0.1","info":{"id":"wtccRS","date":"1609339895","viewed":142,"name":"C64 Webcam","username":"Corstiaan","description":"If the C64 had a webcam","likes":3,"published":1,"flags":2,"usePreview":0,"tags":["c64","commodore","webcam","pixels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Fork of \"Stippling with AA patterns\" by joeedh. https://shadertoy.com/view/MdtGD7\n// 2020-12-30 13:33:54\n\n// pallette stuf from https://www.shadertoy.com/view/4llBDf\n#define RGB(r, g, b) vec3(float(r)/255., float(g)/255., float(b)/255.)\n\n// C64 palette: http://unusedino.de/ec64/technical/misc/vic656x/colors/\n#define NUM_COLORS 16\nvec3 palette[NUM_COLORS];\n\nvoid InitPalette()\n{\n    palette[0]  = RGB(0, 0, 0);\n    palette[1]  = RGB(255, 255, 255);\n    palette[2]  = RGB(116, 67, 53);\n    palette[3]  = RGB(124, 172, 186);\n    palette[4]  = RGB(123, 72, 144);\n    palette[5]  = RGB(100, 151, 79);\n    palette[6]  = RGB(64, 50, 133);\n    palette[7]  = RGB(191, 205, 122);\n    palette[8]  = RGB(123, 91, 47);\n    palette[9]  = RGB(79, 69, 0);\n    palette[10] = RGB(163, 114, 101);\n    palette[11] = RGB(80, 80, 80);\n    palette[12] = RGB(120, 120, 120);\n    palette[13] = RGB(164, 215, 142);\n    palette[14] = RGB(120, 106, 189);\n    palette[15] = RGB(159, 159, 150);\n}\n\nvec3 EuclidDist(vec3 c, vec3[NUM_COLORS] pal)\n{\n    int idx = 0;\n    float nd = distance(c, pal[0]);\n\n    for(int i = 1; i < NUM_COLORS; i++)\n    {\n        float d = distance(c, pal[i]);\n        \n        if(d < nd)\n        {\n            nd = d;\n            idx = i;\n        }\n    }\n    return palette[idx];\n}\n\nvec2 stepnoise(vec2 p, float size) {\n    p += 10.0;\n    float x = floor(p.x/size)*size;\n    float y = floor(p.y/size)*size;\n    \n    x = fract(x*0.1) + 1.0 + x*0.0002;\n    y = fract(y*0.1) + 1.0 + y*0.0003;\n    \n    float a = fract(1.0 / (0.000001*x*y + 0.00001));\n    a = fract(1.0 / (0.000001234*a + 0.00001));\n    \n    float b = fract(1.0 / (0.000002*(x*y+x) + 0.00001));\n    b = fract(1.0 / (0.0000235*b + 0.00001));\n    \n    return vec2(a, b);\n    \n}\n\nfloat tent(float f) {\n    return 1.0 - abs(fract(f)-0.5)*2.0;\n}\n\n#define SEED1 -0.5775604999999985\n#define SEED2 6.440483302499992\n\nfloat mask(vec2 p) {\n    p += stepnoise(p, 8.423424);\n    \n    float f1 = tent(p.x * SEED1 + p.y / (SEED1 + 0.5));\n    float f2 = tent(p.y * SEED2 + p.x / (SEED2 + 0.5));\n    return sqrt(f1 * f2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitPalette();\n\n\tvec2 uv = fragCoord.xy;\n    vec2 uv2 = fragCoord.xy / iResolution.x;\n    vec2 mosaic = vec2(floor(uv.x / 20.) * 20., floor(uv.y / 10.) * 10.);\n        \n    vec3 f = texture(iChannel0, mosaic / iResolution.xy).rgb;\n    //float c = mask(mosaic);\n\n    //float slide = tent(uv2.x * 0.5);\n    // if (uv2.y < 0.1) { f = slide; }\n    \n    //c = floor(f * 16.) / 16.;\n    vec3 c = EuclidDist(f, palette);\n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}