{"ver":"0.1","info":{"id":"MfsSRf","date":"1705539504","viewed":69,"name":"cool spheres","username":"Angramme","description":"f","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["f"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\n\nvec3 magma(float t) {\n\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvec2 walk(float t, float seed){\n    vec3 h = vec3(sin(3453.510*seed), fract(43.1415893892*seed)*cos(.3498*seed), sin(10.+sin(1.347*seed)+385.34*seed));\n    return 0.3*vec2(\n        sin(t+h.x + sin(t))*cos(t*h.z),\n        0.5*cos(t*h.y+h.z)+0.3*cos((h.x+h.z)*t+sin(h.x*t))\n        );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat map2(vec2 p){\n    float d = distance(p, vec2(-0.3, -0.2)) - 0.13;\n    const float rep = 0.3;\n    const float R = 0.07;\n    float gp = fract((p.x + iTime*0.2)/rep);\n    vec2 p2 = vec2(gp*rep, p.y + 0.02*sin(10.*p.x + 4.2*iTime));\n    float d2 = distance(p2, vec2(0.5*rep, 0.)) - R;\n    if(gp < 0.5) d2 = opSmoothUnion(d2, distance(p2+rep*vec2(1,0), vec2(0.5*rep, 0.)) - R, 0.2);\n    else d2 = opSmoothUnion(d2, distance(p2-rep*vec2(1,0), vec2(0.5*rep, 0.)) - R, 0.2);\n    \n    return opSmoothUnion(d, d2, 0.3) + 0.02*sin(10.*p.x+iTime);\n}\n\nfloat map(vec2 p){\n    const float R = 0.11;\n    float d = 100000.;\n    for(float i=0.; i<5.; i++){\n        float dd = distance(p, walk(iTime, i)) - R;\n        d = opSmoothUnion(d, dd, 0.2);\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x - vec2(0.5, 0.5*iResolution.y/iResolution.x);\n\n    // Time varying pixel color\n    float d = map(uv);\n    \n    vec3 col = vec3(1.);\n    if(d > 0.) col = vec3(1.);\n    else col = magma(exp(30.*d));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}