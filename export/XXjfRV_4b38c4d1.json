{"ver":"0.1","info":{"id":"XXjfRV","date":"1729698599","viewed":233,"name":"Interactive Lens Refraction","username":"chronos","description":"WASD / up left down right move\nQ/E  zoom in out\nClick and drag to trace ray path through lenses.","likes":31,"published":1,"flags":48,"usePreview":0,"tags":["2d","refraction","lens","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Interactive Lens Refraction by chronos et al\n    --------------------------------------------------------------------------------------------\n    \n    Significant chunks of the code is by\n    Nguyen2007 (https://www.shadertoy.com/user/Nguyen2007)\n    and\n    ArmandB (https://www.shadertoy.com/user/ArmandB)\n    \n    Based in part on my previous shader: 2D Refraction (https://www.shadertoy.com/view/l3KSRz)\n\n    Lenses and intersection logic by Nguyen, additional light and intersection code by ArmandB\n    \n    Camera controls, mouse click path visualization and additional code by me.\n    \n    \n    Controls:\n    -------------------------------------------------\n    WASD / up left down right         move\n    Q/E                               zoom in out\n    \n    Click and drag to trace ray path through lenses.\n    \n    \n    --------------------------------------------------------------------------------------------\n    \n    Self link: https://www.shadertoy.com/view/XXjfRV\n    \n    --------------------------------------------------------------------------------------------\n\n    See also:\n        Fake \"Real\" Camera by Nguyen2007 (https://www.shadertoy.com/view/4X2BRV)\n*/\n\n\n\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n      \n      \nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n  p-=a; b-=a;\n  return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufA = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec3 col = bufA.rgb / max(bufA.a, 1.); \n\n\n    vec4 camera_controls = texelFetch(iChannel3, ivec2(0), 0);\n    float zoom = exp(camera_controls.z*zoom_speed);\n    vec2 screen_position = camera_controls.xy;\n        \n    col.rgb+=camera_controls.a*0.1;    \n        \n    vec2 uv = zoom * (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = zoom * (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse1 = zoom * (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.y;\n    float ps = zoom * 2. / iResolution.y;\n\n    uv += screen_position / iResolution.y;\n    mouse += screen_position / iResolution.y;\n    mouse1 += screen_position / iResolution.y;\n    \n    // Draw grid\n    #if 1\n    vec2 grid = fract(uv);\n    vec2 grid_alpha = smoothstep(1.-1.5*ps, 1.-ps*.5, grid);\n    grid_alpha = max(grid_alpha, smoothstep(1.-1.5*ps, 1.-ps*.5, 1.-grid));\n    col = mix(col, vec3(1), max(grid_alpha.x, grid_alpha.y)*.125);\n    #endif\n    \n    vec2 ro = mouse1;\n\n    float time = iTime*.3;\n    vec2 rd = normalize(mouse - mouse1);//vec2(cos(time), sin(time));\n\n    ray2D r = ray2D(ro, rd);\n\n    vec2 nodes[int(num_bounces)];\n    \n    for(int i = 0; i < int(num_bounces); i++) nodes[i] = vec2(0);\n    \n    nodes[0] = ro;\n    int num_nodes = 1;\n\n    float beam_alpha = 0.;\n    float beam_dot_alpha = 0.;\n    \n    if(iMouse.z > .5)\n    for(float j = 0.; j < num_bounces; j++)\n    {\n        // Cast ray\n\n        // If intersects light, add light contribution and terminate ray\n        #if 1\n        float light_t = get_closest_hit(ray_box_intersect(r.o, r.d, light_pos, light_size));\n        #else\n        float light_t = get_closest_hit(ray_circle_intersect(r.o, r.d, light_pos, 0.1));\n        #endif\n        \n        float cover1_t = get_closest_hit(ray_box_intersect(r.o, r.d, cover1_pos, cover1_size));\n        float cover2_t = get_closest_hit(ray_box_intersect(r.o, r.d, cover2_pos, cover2_size));\n\n        hitRecord2D rec;\n        rec.obj_index = -1;\n        \n        if(iLenses(r, 2e-4, 1e5, rec)\n            && rec.t > 0.\n            && (rec.t < light_t || light_t <= 0.)\n            && (rec.t < cover1_t || cover1_t <= 0.)\n            && (rec.t < cover2_t || cover2_t <= 0.)\n            )\n        {\n            if(dot(rec.n, r.d) > 0.)\n            {\n                rec.n = -rec.n;\n            }\n\n            \n            beam_alpha = max(beam_alpha, smoothstep(2.*ps, ps, seg(nodes[num_nodes-1], rec.p, uv)));\n\n            nodes[num_nodes] = rec.p;\n            num_nodes+=1;\n            float d = length(uv-rec.p);\n            float a = smoothstep(2.*ps, ps, d-3.*ps);\n            beam_dot_alpha += a*.5;\n\n            r.o = rec.p;\n            r.d = normalize(refract(r.d, rec.n, rec.IOR));\n            \n            //if (r.d == vec2(0)) break;\n            \n        } \n        else \n        if (\n                (light_t >= 0. && light_t < 1000.) // We hit the light\n            && (light_t < cover1_t || cover1_t <= 0.)\n            && (light_t < cover2_t || cover2_t <= 0.)\n            )\n        {\n            vec2 P = r.o + r.d * light_t;\n            \n            beam_alpha = max(beam_alpha, smoothstep(2.*ps, ps, seg(nodes[num_nodes-1], P, uv)));\n        \n            nodes[num_nodes] = P;\n            num_nodes+=1;\n            break;\n        } \n        else if((cover1_t > 0. && cover1_t < 1000.))\n        {\n            vec2 P = r.o + r.d*cover1_t;\n            \n            beam_alpha =  max(beam_alpha, smoothstep(2.*ps, ps, seg(nodes[num_nodes-1], P, uv)));\n            \n            nodes[num_nodes] = r.o + r.d*cover1_t;\n            num_nodes+=1;\n            float d = length(uv-(r.o + r.d*cover1_t));\n            float a = smoothstep(6.*ps, 4.*ps, d);\n            col = mix(col, vec3(1,0,0), a*.2);\n            break;\n        }\n        else if(cover2_t > 0. && cover2_t < 1000.)\n        {\n            vec2 P = r.o + r.d*cover2_t;\n            \n            beam_alpha =  max(beam_alpha, smoothstep(2.*ps, ps, seg(nodes[num_nodes-1], P, uv)));\n            \n            nodes[num_nodes] = P;\n            num_nodes+=1;\n            float d = length(uv-P);\n            float a = smoothstep(2.*ps, ps, d-3.*ps);\n            col = mix(col, vec3(0,1,0), a*.2);\n            break;\n        }\n        else \n        {\n            vec2 P = r.o + 10. * r.d;\n            \n            beam_alpha = max(beam_alpha, smoothstep(2.*ps, ps, seg(nodes[num_nodes-1], P, uv)));\n            \n            nodes[num_nodes] = r.o + 10. * r.d;\n            num_nodes+=1;\n            break;\n        }\n    }\n    \n    col = mix(col, vec3(1), beam_alpha);\n    col = mix(col, vec3(0,0,1), beam_dot_alpha);\n    \n    \n    vec2 cov1 = (uv - cover1_pos)/cover1_size;\n    vec2 cov2 = (uv - cover2_pos)/cover2_size;\n    col += float(cov1.x > -1. && cov1.x < 1. && cov1.y > -1. && cov1.y < 1.) * .1;\n    col += float(cov2.x > -1. && cov2.x < 1. && cov2.y > -1. && cov2.y < 1.) * .1;\n    \n    #if 0\n    // Draw origin dot\n    float d = length(uv);\n    float a = smoothstep(2.*ps, ps, d-0.01);\n    col = mix(col, vec3(1), a*.2);\n    #endif\n    \n    #if 0\n    col = sRGBencode(col);\n    #endif\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat zoom_speed = 0.02;\nvec2 light_pos = vec2(-5.5, 0);\nvec2 light_size = vec2(0.1,0.7);\n\n\n\nconst vec2 cover1_pos  = vec2(.5+0.225, .07+.39375);\nconst vec2 cover1_size = vec2(0.7,0.1);\n\nvec2 cover2_pos = cover1_pos * vec2(1, -1.);\nvec2 cover2_size = cover1_size;\n\nconst float TAU    = 6.283185307,\n            PI     = 3.14159265;\n\nstruct ray3D\n{\n    vec3 o, d;\n};\n\nstruct ray2D\n{\n    vec2 o, d;\n};\n\nvec2 _3Dto2D(vec3 v3D) { return v3D.zy; }\nvec3 _2Dto3D(vec2 v2D) { return vec3(0, v2D.yx); }\n\nstruct hitRecord\n{\n    float IOR, t;\n    vec3 p, n;\n    bool isVolume;\n    int obj_index; \n};\n\nstruct hitRecord2D\n{\n    float IOR, t;\n    vec2 p, n;\n    bool isVolume;\n    int obj_index; \n};\n\n//hitRecord2D _3Dto2D(hitRecord3D rec3D) { return v3D.zy; }\n//hitRecord3D _2Dto3D(hitRecord2D rec2D) { return vec3(0, v2D.yx); }\n\nfloat sdArc(vec2 p, vec2 sc, float ra, float rb )\n{\n    p.x = abs(p.x);\n    return (sc.y * p.x > sc.x * p.y ? length(p - sc * ra) : \n                                      abs(length(p) - ra)) - rb;\n}\n\nfloat sdLens(vec2 p, float h, float r)\n{\n    p.x = (r - p.x) * sign(r);\n    r = abs(r);\n    return sdArc(p.yx, vec2(h /= r, sqrt(1. - h * h)), r, .01);\n}\n\nvec2 iSphere2(vec3 ro, vec3 rd, float ra)\n{\n    float b = dot( ro, rd );\n    vec3 qc = ro - b*rd;\n    float h = ra*ra - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nbool iLens(mat4 txx, float h, float R, ray3D r, float tmin, float tmax, inout hitRecord rec)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz;\n    \n    bool hit = false;\n    \n    vec3 oc = ro - vec3(0, 0, R), p;\n    \n    vec2 t = iSphere2(oc, rd, R);\n    \n    float sign = sign(R);\n    \n    float b = R * R - h * h;\n    \n    if(b < 0.) return false;\n    \n    if(t.x > tmin && t.x < tmax)\n    {\n        p = oc + rd * t.x;\n        if(sign * p.z < -sqrt(b))\n        {\n            rec.t = t.x;\n            rec.p = r.o + r.d * t.x;\n            rec.n = (inverse(txx) * vec4( p / R, 0)).xyz;\n            return true;\n        }\n    }\n    \n    if(t.y > tmin && t.y < tmax)\n    {\n        p = oc + rd * t.y;\n        if(sign * p.z < -sqrt(b))\n        {\n            rec.t = t.y;\n            rec.p = r.o + r.d * t.y;\n            rec.n = (inverse(txx) * vec4(-p / R, 0)).xyz;\n            return true;\n        }\n    }\n\t\n\treturn false;\n}\n\nconst float scale = 1.,\n\n            r1  =   0.836,\n            r2  =   3.210,\n            r3  =   0.448,\n            r4  = -11.500,\n            r5  =   0.283,\n            r6  = - 0.385,\n            r7  =   0.505,\n            r8  = - 0.532,\n            r9  =   1.060,\n            r10 = - 1.200,\n            \n            d1 = 0.1075,\n            d2 = 0.0165,\n            d3 = 0.1555,\n            d4 = 0.0505,\n            d5 = 0.1890,\n            d6 = 0.0505,\n            d7 = 0.2122,\n            d8 = 0.0097,\n            d9 = 0.1390,\n            \n            N1 = 1.64238,\n            N2 = 1.62306,\n            N3 = 1.57566,\n            N4 = 1.67270,\n            N5 = 1.64238,\n            N6 = 1.64238,\n            \n            V1 = 48.0,\n            V2 = 56.9,\n            V3 = 41.2,\n            V4 = 32.2,\n            V5 = 48.0,\n            V6 = 48.0,\n            \n            A  = 0.4444 * scale,\n            AD = 0.4506 * scale,\n            I  = 1.3 * scale,\n            ss = .432 * scale;\n\nstruct lens\n{\n    float R; // Radius\n    float d; // Thickness\n    float N; // IOR\n    float V; // Abbe number\n    float h; // Semi-Diameter\n};\n\nconst int numLenses = 10;\nlens[numLenses] lenses = lens[numLenses](lens(r1,  d1, N1, V1, .36),\n                                         lens(r2,  d2, 1., 0., .36),\n                                         lens(r3,  d3, N2, V2, .32),\n                                         lens(r4,  d4, N3, V3, .32),\n                                         lens(r5,  d5, 1., 0., .22),\n                                         lens(r6,  d6, N4, V1, .22),\n                                         lens(r7,  d7, N5, V1, .29),\n                                         lens(r8,  d8, 1., 0., .29),\n                                         lens(r9,  d9, N6, V1, .29),\n                                         lens(r10, 0., 1., 0., .29));\n\n#define translate(p) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -(p), 1)\n\nbool iLenses(ray2D _r, float tmin, float tmax, inout hitRecord2D _rec)\n{\n    ray3D r;\n    r.o = vec3(0, _r.o.y, _r.o.x);\n    r.d = vec3(0, _r.d.y, _r.d.x);\n    \n    hitRecord rec;\n    rec.p = _2Dto3D(_rec.p);\n    rec.n = _2Dto3D(_rec.n);\n    rec.t = _rec.t;\n    rec.IOR = _rec.IOR;\n    rec.isVolume = _rec.isVolume;\n    rec.obj_index = _rec.obj_index;\n\n    rec.t = tmax;\n    bool hit = false;\n    \n    float z = 0., rmax = 0.;\n    \n    for(int i = 0; i < 10; i++)\n    {\n        lens l = lenses[i];\n        \n        l.R *= scale;\n        l.d *= scale;\n        l.h *= scale;\n        \n        int previous_i = i - 1;\n        \n        if(iLens(translate(vec3(0, 0, z)), l.h, l.R, r, tmin, rec.t, rec))\n            \n            hit = true,\n            rec.obj_index = i,\n            rec.IOR = (i > 0 ? lenses[previous_i].N : 1.) / l.N;\n        \n        if(r.d.z < 0.) rec.IOR = 1. / rec.IOR;\n        \n        z += l.d;\n    }\n    \n    _rec.p = _3Dto2D(rec.p);\n    _rec.n = _3Dto2D(rec.n);\n    _rec.t = rec.t;\n    _rec.IOR = rec.IOR;\n    _rec.isVolume = rec.isVolume;\n    _rec.obj_index = rec.obj_index;\n    \n    return hit;\n    \n}\n\n\nvec2 ray_box_intersect( in vec2 ro, in vec2 rd, vec2 boxOrigin, vec2 boxSize ) \n{\n    ro -= boxOrigin;\n    vec2 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec2 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec2 k = abs(m)*boxSize;\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n    float tN = max( t1.x, t1.y );\n    float tF = min( t2.x, t2.y );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\nvec2 ray_circle_intersect(vec2 ro, vec2 rd, vec2 center, float radius)\n{\n    ro-=center;\n    \n    //vec2 p = t * rd + ro;\n    //dot(t * rd + ro, t * rd + ro) - radius * radius = 0.;\n    //t * t * dot(rd, rd) + 2. * dot(rd, ro) * t + dot(ro, ro) - radius * radius = 0.;\n    \n    float t = dot(0. - ro, rd)/dot(rd,rd);\n    \n    vec2 p = t * rd + ro; // project origin onto ray.\n    \n    float x2 = radius*radius - dot(p,p);\n    \n    if(x2 < 0.) return vec2(-1);\n    \n    float x = sqrt(x2);\n    \n    return t + vec2(-x,x);\n}\n\nfloat get_closest_hit(vec2 hitresults)\n{\n    if(hitresults.x < 0. && hitresults.y < 0.) return -1.;\n    else if(hitresults.x > 0. && hitresults.y > 0.) return min(hitresults.x, hitresults.y);\n    else return max(hitresults.x, hitresults.y);\n}\n\nconst float num_bounces = 30.;\n\nconst float golden = sqrt(5.)*.5+.5;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 camera_controls = texelFetch(iChannel3, ivec2(0), 0);\n    float zoom = exp(camera_controls.z*zoom_speed);\n    vec2 screen_position = camera_controls.xy;\n\n    vec2 uv = zoom * (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float ps = zoom * 2. / iResolution.y;\n    \n    \n    uv += screen_position / iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    vec4 bufA = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    if(iFrame == 0 || bool(camera_controls.a>=1.)) // uncomment to reset on mouse click, for resetting in fullscreen\n        { fragColor = vec4(0); bufA.a = 0.; }\n    \n    else\n    col += bufA.rgb;\n    \n    float angle = TAU * (bufA.a * golden + 1. * texture(iChannel0, fract(fragCoord/1024.)).b);\n\n    vec2 ro = uv;\n\n    #if 1\n    // Suggestion by @fad to jitter starting position within the pixel\n    ro += ps * (-.5 + texture(iChannel0, fract(fragCoord/1024. + bufA.a/100.))).rg; \n    #endif\n\n    vec2 rd = vec2(cos(angle), sin(angle));\n\n    ray2D r = ray2D(ro, rd);\n\n    for(float j = 0.; j < num_bounces; j++)\n    {\n        // Cast ray\n\n        // If intersects light, add light contribution and terminate ray\n        \n        #if 1\n        float light_t = get_closest_hit(ray_box_intersect(r.o, r.d, light_pos, light_size));\n        #else\n        float light_t = get_closest_hit(ray_circle_intersect(r.o, r.d, light_pos, 0.1));\n        #endif\n        float cover1_t = get_closest_hit(ray_box_intersect(r.o, r.d, cover1_pos, cover1_size));\n        float cover2_t = get_closest_hit(ray_box_intersect(r.o, r.d, cover2_pos, cover2_size));\n\n        hitRecord2D rec;\n\n        if(iLenses(r, 2e-4, 1e5, rec) \n            && rec.t > 0.\n            && (rec.t < light_t || light_t < 0.)\n            && (rec.t < cover1_t || cover1_t < 0.)\n            && (rec.t < cover2_t || cover2_t < 0.)\n        ) {\n            if(dot(rec.n, r.d) > 0.)\n            {\n                rec.n = -rec.n;\n            }\n\n            r.o = rec.p;\n            r.d = normalize(refract(r.d, rec.n, rec.IOR));\n            if (r.d == vec2(0)) break;\n        } \n        else if (   \n            (light_t >= 0. && light_t < 1000.) // We hit the light\n            && (light_t < cover1_t || cover1_t < 0.)\n            && (light_t < cover2_t || cover2_t < 0.)\n            ) \n        {\n            vec3 light_col = texture(iChannel1, vec2(0,(r.o.y + r.d.y * light_t - light_pos.y)*0.1 + 0.25)).rgb;\n            col += TAU * light_col;\n            break;\n        }\n        else if((cover1_t >= 0. && cover1_t < 1000.) || (cover2_t >= 0. && cover2_t < 1000.))\n        {\n            break;\n        }\n        else break;\n    }\n\n    fragColor = vec4(col, bufA.a + 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 keyboard =  texelFetch(iChannel1, ivec2(fragCoord.x, 3.*fragCoord.y/iResolution.y), 0);\n\n    float left  = texelFetch(iChannel1, ivec2(37, 0), 0).r;\n    float up    = texelFetch(iChannel1, ivec2(38, 0), 0).r;\n    float right = texelFetch(iChannel1, ivec2(39, 0), 0).r;\n    float down  = texelFetch(iChannel1, ivec2(40, 0), 0).r;\n    \n    float W = texelFetch(iChannel1, ivec2(87, 0), 0).r;\n    float A = texelFetch(iChannel1, ivec2(65, 0), 0).r;\n    float S = texelFetch(iChannel1, ivec2(83, 0), 0).r;\n    float D = texelFetch(iChannel1, ivec2(68, 0), 0).r;\n    \n    float E = texelFetch(iChannel1, ivec2(69, 0), 0).r;\n    float Q = texelFetch(iChannel1, ivec2(81, 0), 0).r;\n    \n    vec2 pos = vec2(0);\n    float zoom_scale = 0.;\n    \n    fragColor = vec4(0,0,0,0);\n    \n    if(iFrame > 0)\n    {\n        vec4 bufB = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        pos = bufB.xy;\n        zoom_scale = bufB.z;\n    }\n    \n    \n    vec4 camera_controls = texelFetch(iChannel3, ivec2(0), 0);\n    float zoom = exp(camera_controls.z*zoom_speed);\n    vec2 screen_position = camera_controls.xy;\n                \n    vec2 uv = zoom * (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = zoom * (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse1 = zoom * (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.y;\n    float ps = zoom * 2. / iResolution.y;\n    \n    if(ivec2(fragCoord) == ivec2(0))\n    {\n        vec2 delta = vec2(0);\n        if(left > 0.5  || A > .5 || iTime < .75) delta += vec2( -1,  0);\n        if(up > 0.5    || W > .5) delta += vec2(  0,  1);\n        if(right > 0.5 || D > .5) delta += vec2(  1,  0);\n        if(down > 0.5  || S > .5) delta += vec2(  0, -1);\n\n        float zoom_delta = 0.;\n        if(E > 0.5 || iTime < .75) zoom_delta += 1.;\n        if(Q > 0.5) zoom_delta += -1.;\n        \n        float speed = 20.;\n        pos += delta * speed * exp(zoom_scale*zoom_speed);\n        zoom_scale += zoom_delta;\n\n        fragColor = vec4(pos, zoom_scale, length(delta)>0.5 || abs(zoom_delta) != 0.);\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}