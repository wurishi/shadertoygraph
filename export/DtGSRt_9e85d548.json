{"ver":"0.1","info":{"id":"DtGSRt","date":"1686518615","viewed":339,"name":"GM Shader Chromatic Aberration","username":"Xor","description":"Written for my [url=https://mini.gmshaders.com]mini tutorial series[/url].","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","tutorial","tut","gmshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Chromatic Aberration\" by @XorDev\n    \n    Here's a super simple \"Chromatic Aberration\" effect that you can\n    easily add as a post-process effect to other shaders.\n    \n    Mini tut: https://mini.gmshaders.com/p/gm-shaders-mini-chromatic-aberration\n    \n    Used here: https://www.shadertoy.com/view/mdfGRs\n*/\n#define CONTRAST 2.0\n//Must be an even number\n#define SAMPLES 20.0\n\n#define MODE RADIAL\n\n#define LINEAR 0\n#define RADIAL 1\n#define TWIST  2\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 res = iResolution.xy;\n    //Compute uv coordinates from frag coordinates\n    vec2 uv = fragCoord / res;\n    vec2 m = iMouse.z>0.? iMouse.xy/res.xy-.5 : cos(iTime*vec2(2))*.4;\n    //Color output starts at 0.\n\tvec4 color_sum = vec4(0);\n    vec4 weight_sum = vec4(0);\n    \n    //Iterate 20 times from 0 to 1\n\tfor(float i = 0.0; i<=1.0; i+=1.0/SAMPLES)\n    {\n        //Add a texture sample approaching the center (0.5, 0.5)\n        //This center could moved to change how the direction of aberation\n        //The mix amount determines the intensity of the aberration smearing\n        vec2 coord = uv;\n        \n        #if MODE==LINEAR\n            coord = uv+0.04*(i-.5)*m;\n        #elif MODE==RADIAL\n            coord = mix(uv, vec2(.5), (i-.5)*.1*m.x);\n        #elif MODE==TWIST\n            vec2 ratio = res.yx/res.y;\n            coord = uv+vec2(uv.y-.5, .5-uv.x)*ratio*ratio*(i-.5)*.1*m.x;\n        #endif\n        \n        vec4 weight = vec4(i,1.-abs(i+i-1.),1.-i,.5);\n        weight = mix(vec4(.5), weight,  CONTRAST);\n        \n        vec4 color = texture(iChannel0, coord);\n\t\tcolor_sum += color * color * weight;\n        //This makes each sample have a different color from red to green to blue\n        //The total should be multiplied by the 2/number of samples, (e.g. 0.1)\n        weight_sum += weight;\n     }\n        \n\t\n    //Output the resulting color\n    fragColor = sqrt(color_sum / weight_sum);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Truchet based on: https://www.shadertoy.com/view/Nljyzh\n*/\nvoid mainImage( out vec4 O, vec2 p)\n{\n    //Y-resolution for scaling\n    vec2 r = iResolution.yy/4.,\n    //Cell coordinates\n    c = ceil(p=(p/r-3.)/(1.-p/r/2e1).y+iTime),\n    //Signed vec2\n    s = sign(cos(c*c.y)),\n    //fractional-cell coordinates (-0.5 to +0.5)\n    f = (c-p-.5)*s,\n    //Truchet distance * checkerboard * sign flips\n    i = (length(f+.5-ceil(f.x+f.y))-.5)*(mod(c.x+c.y,2.)-.5)*s*s.y;\n    //Color and shading\n    O = abs(clamp((.1-abs(i))*r,.05,1.).xxxx*(1.-i*i*5e1).x);\n}","name":"Buffer A","description":"","type":"buffer"}]}