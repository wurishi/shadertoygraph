{"ver":"0.1","info":{"id":"lcfSRl","date":"1705669336","viewed":713,"name":"Fast Atmosphere","username":"Fewes","description":"Fast semi-physical atmospheric scattering with planet view and aerial perspective.\nTerrain render is cached in Buffer A (depth + normal).\nThe shader is significantly faster if effects in Buffer B are disabled, but should run well regardless.","likes":48,"published":1,"flags":32,"usePreview":0,"tags":["sky","scattering","atmosphericscattering","atmosphere","mit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sample Buffer A (terrain) and Buffer B (god rays/shadow/ambient occlusion),\n// then composite with atmosphere from Common and apply color grading.\n\n// Disable these four to view only the atmosphere function.\n#define TERRAIN\n#define STARS\n#define CELESTIAL_BODIES\n#define LENS_FLARE\n#define MOON_LIGHT\n//#define HEIGHT_FOG // Enable this to showcase the fog fade feature\n\n#define AUTO_EXPOSURE\n#define TONEMAP\n#define GAMMA\n#define DITHER\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x)\n{\n    const uint k = 1103515245U;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid GetCamera(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(0, 3000, 0);\n    float aspect = iResolution.x / iResolution.y;\n    rd = normalize(vec3((uv - 0.5) * vec2(aspect, 1.0), 1.0));\n}\nvec3 ExpandPackedNormal(vec2 normalXZ)\n{\n    vec3 n = vec3(normalXZ.x, 0, normalXZ.y);\n    n.y = sqrt(1.0 - clamp(dot(n.xz, n.xz), 0.0, 1.0));\n    return n;\n}\n\nvec3 TonemapACES(vec3 color)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (color * (a * color + b)) / (color * (c * color + d) + e);\n}\n\n#define BLADE_COUNT1    4.0\n#define BLADE_COUNT2    8.0\n#define BLADE_COUNT3    16.0\n#define THICKNESS       2.0 // Controls the thickness of the limbs. Values below 2 will cause aliasing.\n#define GLARE_INTENSITY 0.9 // Strength of rainbow circle glare.\n#define GLARE_WIDTH     0.1 // Size of rainbow circle glare.\n#define GLOW_INTENSITY  0.2 // Intensity of rainbow circle glare.\n#define FACE_DIRECTION      // Rotate the flare to face the input direction\n\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\nfloat remap (float x, float a, float b, float c, float d) { return saturate(c + (((x - a) / (b - a)) * (d - c))); }\nfloat remap01 (float x, float a, float b) { return saturate((x - a) / (b - a)); }\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract((p+1.0)*0.1031);\n    p *= p+33.33;\n    return fract(p*p*2.0);\n}\n// https://www.shadertoy.com/view/XljGzV\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n// https://www.shadertoy.com/view/Xc2XR1\nfloat GetFlareBlades(float x, float y, float count, float size, float roll, float offset, float k)\n{\n    float x0 = x;\n    x = fract(x + 1.0 / count);\n    y = remap01(y, 0.0, size);\n    float s = x * count;\n    float hash = hash11(float(int(s) % int(count / 2.0)) + offset);\n    float blade = abs(fract(s + 0.5) - 0.5) * 2.0;\n    float aa = mix(fwidth(x * count), fwidth(fract(x + 0.5) * count), step(fract(x + 0.25), 0.5));\n    blade = remap01(blade, 1.0 - aa * THICKNESS, 1.0);\n    float l = cos(hash * 2.0 * PI + roll * 4.0) * 0.4 + 0.6;\n    return blade * remap01(y, l * 0.5, 0.0);\n}\n\nvec3 GetFlare(vec2 uv, vec2 toCenter, float visibility)\n{\n    float roll = atan(-toCenter.y, toCenter.x);\n    \n    vec2 dir = (uv - 0.5) * 2.0;\n    float y = length(dir);\n    dir /= y;\n    float theta = atan(dir.y, dir.x);\n#ifdef FACE_DIRECTION\n    theta += roll;\n#endif\n    float x = theta / (2.0 * PI) + 0.125;\n    float flare = \n        GetFlareBlades(x + 0.000, y, BLADE_COUNT1, visibility * 1.0, roll, 0.0,   40.0) * 0.4 +\n        GetFlareBlades(x + 0.125, y, BLADE_COUNT2, visibility * 0.6, roll, 10.0,  20.0) * 0.1 +\n        GetFlareBlades(x + 0.125, y, BLADE_COUNT3, visibility * 0.4, roll, 100.0, 2.0)  * 0.05;\n        \n    float glare = pow(saturate(1.0 - y), 4.0 + (1.0 - visibility) * 4.0) * 0.1;\n    vec3 n = vec3((uv - vec2(0.5)) * 2.0, 0.0);\n    n = normalize(vec3(n.xy, sqrt(1.0 - saturate(dot(n.xy, n.xy)))));\n    float glareSize = length(toCenter);\n    float glareWidth = GLARE_WIDTH;\n    float glareY = y - glareSize;\n    glare = saturate(dot(vec3(-toCenter, 0.5), n)) * smoothstep(glareWidth, 0.0, abs(glareY));\n    glare *= 0.5 + cos(theta * floor(500.0 * glareSize)) * 0.5;\n    float glareColorKey = (glareY / glareWidth + 0.5) * 0.5;\n    float r = (1.0 - glareColorKey);\n    float g = 1.0 - abs(glareColorKey - 0.5) * 2.0;\n    float b = glareColorKey;\n    vec3 glareColor = vec3(r, g, b) * glareSize * GLARE_INTENSITY;\n    \n    float glow = saturate(1.0 - y);\n    glow = glow*glow*GLOW_INTENSITY;\n    \n    return (flare + glow) / (y + 1e-5) + glare * glareColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.xyxy;\n    float time = -iTime * 0.2 + 3.5;\n    vec2 sunPos = 0.5 + vec2(cos(time) * 0.4, sin(time) * 0.45);\n    if (iMouse.x > 10.0)\n    {\n        sunPos = mouse.xy;\n    }\n    vec3 sunDir;\n    vec3 foo;\n    GetCamera(sunPos, foo, sunDir);\n    \n    vec3 sunRadiance = vec3(1, 1, 1);\n    \n    const vec3 moonDir = normalize(vec3(0.5, 0.25, 1));\n    const vec3 moonCenter = moonDir * 384400e3;\n    const float moonRadius = 1737e3 * SUN_DISC_SIZE * 0.9; // Scale moon size with sun size\n    vec3 moonRadiance = vec3(0.01) * (dot(sunDir, -moonDir) * 0.5 + 0.5);\n    \n    sunRadiance *= mix(1.0, smoothstep(1.0, 0.99985, dot(sunDir, moonDir)), 0.999); // Eclipse\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float dither = textureLod(iChannel2, uv * iResolution.xy / vec2(1024), 0.0).x;\n    dither = fract(dither + (0.61803398875 * float(iFrame & 255)));\n    \n    vec3 ro, rd;\n    GetCamera(uv, ro, rd);\n    \n    float rl = INFINITY;\n    \n    vec3 color = vec3(0.0);\n    \n    float atmosphereOcclusion = 1.0;\n    \n#ifdef TERRAIN\n    vec4 occlusionTex = texture(iChannel1, uv);\n    atmosphereOcclusion = occlusionTex.x;\n    float shadow = pow8(occlusionTex.y);\n    float ambientOcclusion = pow4(occlusionTex.z);\n    \n    // Sample terrain screen buffer\n    vec4 terrain = texture(iChannel0, uv);\n    if (terrain.x > 0.0)\n    {\n        // Terrain shading below\n        \n        rl = terrain.x;\n        vec3 p = ro + rd * rl;\n        \n        vec3 n = ExpandPackedNormal(terrain.yz);\n        \n        vec4 terrain1 = texture(iChannel0, uv + vec2(1, 0) / iResolution.xy);\n        vec4 terrain2 = texture(iChannel0, uv + vec2(0, 1) / iResolution.xy);\n        vec3 n1 = ExpandPackedNormal(terrain1.yz);\n        vec3 n2 = ExpandPackedNormal(terrain2.yz);\n        float edge = 1.0 - pow(min(dot(n, n1), dot(n, n2)) * 0.5 + 0.5, 50.0);\n        \n        vec3 albedo = vec3(0.2, 0.22, 0.25); // Cliffs\n        albedo = mix(albedo, vec3(0.55, 0.54, 0.53), edge); // Edge wear\n        albedo = mix(albedo, vec3(0.95), smoothstep(0.7, 0.75, n.y)); // Snow\n        \n        // Color light by transmittance\n        vec3 lt = GetLightTransmittance(p, sunDir, 1.0);\n        \n        // Direct\n        float ndotl = dot(n, sunDir);\n        color += albedo * clamp(ndotl, 0.0, 1.0) * sunRadiance * lt * shadow / PI;\n    #ifdef MOON_LIGHT\n        lt = GetLightTransmittance(p, moonDir, 1.0);\n        ndotl = dot(n, moonDir);\n        color += albedo * clamp(ndotl, 0.0, 1.0) * moonRadiance * lt / PI;\n    #endif\n        \n        // Ambient\n        vec3 an = mix(vec3(0, 1, 0), n, 0.25); // Biased ambient sample dir\n        vec3 al = GetAtmosphere(p, an, INFINITY, sunDir, sunRadiance);\n    #ifdef MOON_LIGHT\n        al += GetAtmosphere(ro, rd, rl, moonDir, moonRadiance);\n    #endif\n        color += albedo * al * ambientOcclusion;\n        \n        // Specular\n        vec3 r = reflect(rd, (n + n1 + n2) / 3.0); // Average normal for some slight specular AA\n        vec3 rl = GetAtmosphere(p, r, INFINITY, sunDir, sunRadiance);\n    #ifdef MOON_LIGHT\n        rl += GetAtmosphere(p, r, INFINITY, moonDir, moonRadiance);\n    #endif\n        float fresnel = pow(1.0 - clamp(dot(rd, -n), 0.0, 1.0), 5.0);\n        color += rl * (0.05 + fresnel * 0.95) * ambientOcclusion / PI;\n        \n        //fragColor = vec4(albedo, 1.0); return; // Debug albedo\n    }\n#else\n    float occlusion = 1.0;\n#endif\n    \n    // Get atmosphere (sun)\n    vec4 transmittance;\n#ifdef HEIGHT_FOG\n    float altitude = max(0.0, (ro + rd * rl).y);\n    float fogFactor = (1.0 - exp(-rl * 1e-4)) * exp(-sq(altitude) * 5e-7);\n#else\n    float fogFactor = 0.0;\n#endif\n    vec3 scattering = GetAtmosphere(ro, rd, rl, sunDir, sunRadiance, transmittance, fogFactor) * atmosphereOcclusion;\n    \n#ifdef TERRAIN\n    transmittance.w *= terrain.x < 0.0 ? 1.0 : 0.0;\n#endif\n\n#ifdef STARS\n    // Stars\n    vec2 starCellF = fragCoord / 4.0;\n    uvec2 starCell = uvec2(floor(starCellF));\n    starCellF = fract(starCellF);\n    vec3 starHash = hash(uvec3(starCell, 0));\n    vec3 stars = smoothstep(0.1, 0.0, length(starCellF - starHash.xy)) * vec3(pow(starHash.z, 10.0)) * 1e-2;\n    color += stars * transmittance.w;\n#endif\n   \n#ifdef CELESTIAL_BODIES\n    // Sun celestial body\n    color += GetSunDisc(rd, sunDir) * sunRadiance * 1000.0 * transmittance.w;\n    \n    // Moon celestial body\n    vec2 moonT = SphereIntersection(ro, rd, moonCenter, moonRadius);\n    if (moonT.x > 0.0)\n    {\n        vec3 moonNormal = normalize(ro + rd * moonT.x - moonCenter);\n        color = clamp(dot(moonNormal, sunDir), 0.0, 1.0) * sunRadiance / PI;\n    }\n#endif\n    \n    // Apply atmosphere (sun)\n    color = color * transmittance.xyz + scattering;\n\n#ifdef LENS_FLARE\n    vec4 flareTransmittance;\n    GetAtmosphere(ro, sunDir, INFINITY, sunDir, sunRadiance, flareTransmittance);\n    #ifdef TERRAIN\n    flareTransmittance.w *= step(texture(iChannel0, sunPos).x, 0.0);\n    #endif\n    #ifdef CELESTIAL_BODIES\n    flareTransmittance.w *= step(SphereIntersection(ro, sunDir, moonCenter, moonRadius).x, 0.0);\n    #endif\n    vec2 flareUV = uv - sunPos + vec2(0.5);\n    float aspect = iResolution.x / iResolution.y;\n    flareUV.x = (flareUV.x - 0.5) * aspect + 0.5;\n    flareUV = (flareUV - vec2(0.5)) * 1.0 + vec2(0.5);\n    vec2 toCenter = vec2(0.5) - sunPos;\n    color += GetFlare(flareUV, toCenter, 1.0) * flareTransmittance.xyz * flareTransmittance.w;\n#endif\n    \n#ifdef MOON_LIGHT\n    // Apply atmosphere (moon)\n    color += GetAtmosphere(ro, rd, rl, moonDir, moonRadiance);\n#endif\n\n#ifdef AUTO_EXPOSURE\n    // Auto-exposure\n    vec3 radiance = GetAtmosphere(ro, vec3(0, 1, 0), INFINITY, sunDir, sunRadiance) +\n        GetAtmosphere(ro, vec3(0, 1, 0), INFINITY, moonDir, moonRadiance);\n    float lum = dot(radiance, vec3(0.3, 0.59, 0.11));\n    color *= mix(1.0, 0.1 / lum, 0.1);\n#endif\n    \n#ifdef TONEMAP\n    color = TonemapACES(color);\n#endif\n\n#ifdef GAMMA\n    color = pow(color, vec3(1.0 / 2.2));\n#endif\n    \n#ifdef DITHER\n    color += dither / 255.0 * 8.0;\n#endif\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Copyright (c) 2024 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/////////////////////////////////////////////////////////////////////////\n\n// Fast semi-physical atmosphere with planet view and aerial perspective.\n//\n// I have long since dreamed of (and tried making) a function that\n// generates plausible atmospheric scattering and transmittance without\n// expensive ray marching that also supports aerial perspectives and\n// offers simple controls over perceived atmospheric density which do not\n// affect the color of the output.\n//\n// This file represents my latest efforts in making such a function and\n// this time I am happy enough with the result to release it.\n//\n// Big thanks to:\n// Inigo Quilez (https://iquilezles.org) for this site and his great\n// library of shader resources.\n// Sébastien Hillaire (https://sebh.github.io) for his many papers on\n// atmospheric and volumetric rendering.\n\n/////////////////////////////////////////////////////////////////////////\n\n#ifndef FAST_ATMOSPHERE_INCLUDED\n#define FAST_ATMOSPHERE_INCLUDED\n\n// Lazy HLSL -> GLSL porting. Remove if you intend to use it with HLSL.\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define lerp mix\n\n// Config\n#define DRAW_PLANET                // Draw planet ground sphere.\n#define PREVENT_CAMERA_GROUND_CLIP // Force camera to stay above horizon. Useful for certain games.\n#define LIGHT_COLOR_IS_RADIANCE    // Comment out if light color is not in radiometric units.\n#define DENSITY                    1.0 // Atmosphere density. 1 is Earth-like.\n#define AERIAL_SCALE               8.0 // Higher value = more aerial perspective. A value of 1 is tuned to match reference implementation.\n//#define NIGHT_LIGHT                0.01 // Optional, cheap (free) non-physical night lighting. Can also use a 2nd light for moon instead.\n#define SUN_DISC_SIZE              2.0 // 1 is physical sun size (0.5 degrees).\n#define EXPOSURE                   4.0 // Tuned to match reference.\n\n// Math\n#define INFINITY 3.402823466e38\n#define PI       3.14159265359\n\n// Atmosphere\n#define ATMOSPHERE_HEIGHT 100000.0\n#define PLANET_RADIUS     6371000.0\n#define PLANET_CENTER     float3(0, -PLANET_RADIUS, 0)\n#define C_RAYLEIGH        (float3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE             (float3(3.996, 3.996, 3.996) * 1e-6)\n#define C_OZONE           (float3(0.650, 1.881, 0.085) * 1e-6)\n#define RAYLEIGH_MAX_LUM  2.0\n#define MIE_MAX_LUM       0.5\n\n// Magic numbers\n#define M_TRANSMITTANCE       0.75\n#define M_LIGHT_TRANSMITTANCE 1e6\n#define M_MIN_LIGHT_ELEVATION -0.4\n#define M_DENSITY_HEIGHT_MOD  1e-12\n#define M_DENSITY_CAM_MOD     10.0\n\nfloat sq(float x) { return x*x; }\nfloat pow4(float x) { return sq(x)*sq(x); }\nfloat pow8(float x) { return pow4(x)*pow4(x); }\n\n// https://iquilezles.org/articles/intersectors/\nfloat2 SphereIntersection(float3 rayStart, float3 rayDir, float3 sphereCenter, float sphereRadius)\n{\n\tfloat3 oc = rayStart - sphereCenter;\n    float b = dot(oc, rayDir);\n    float c = dot(oc, oc) - sq(sphereRadius);\n    float h = sq(b) - c;\n    if (h < 0.0)\n    {\n        return float2(-1.0, -1.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        return float2(-b-h, -b+h);\n    }\n}\nfloat2 PlanetIntersection(float3 rayStart, float3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS);\n}\nfloat2 AtmosphereIntersection(float3 rayStart, float3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS + ATMOSPHERE_HEIGHT);\n}\nfloat PhaseR(float costh)\n{\n\treturn (1.0+sq(costh))*0.06;\n}\nfloat PhaseM(float costh, float g)\n{\n\t// g = min(g, 0.9381); // Assume validated input by user so we can skip\n\tfloat k = 1.55*g-0.55*sq(g)*g;\n\tfloat a = 1.0-sq(k);\n\tfloat b = 12.57*sq(1.0-k*costh);\n\treturn a/b;\n}\n\nfloat3 GetLightTransmittance(float3 position, float3 lightDir, float multiplier)\n{\n\tfloat lightExtinctionAmount = pow8(smoothstep(1.0, M_MIN_LIGHT_ELEVATION, lightDir.y));\n\treturn exp(-(C_RAYLEIGH + C_MIE + C_OZONE) * lightExtinctionAmount * DENSITY * multiplier * M_LIGHT_TRANSMITTANCE);\n}\nfloat3 GetLightTransmittance(float3 position, float3 lightDir)\n{\n\treturn GetLightTransmittance(position, lightDir, 1.0);\n}\n\nvoid GetRayleighMie(float opticalDepth, float densityR, float densityM, out float3 R, out float3 M)\n{\n    // Approximate marched Rayleigh + Mie scattering with some exp magic.\n    R = (1.0 - exp(-opticalDepth * densityR * C_RAYLEIGH / RAYLEIGH_MAX_LUM)) * RAYLEIGH_MAX_LUM;\n\tM = (1.0 - exp(-opticalDepth * densityM * C_MIE / MIE_MAX_LUM)) * MIE_MAX_LUM;\n}\n\n// Main function\n// Transmittance stores atmospheric transmittance in xyz and planet intersection flag in w.\n// Fog parameter can be used in cases where you want to fade the world out\n// (like in a game with limited far clip plane).\nfloat3 GetAtmosphere(float3 rayStart, float3 rayDir, float rayLength, float3 lightDir,\n\tfloat3 lightColor, out float4 transmittance, float fogFactor)\n{\n#ifdef PREVENT_CAMERA_GROUND_CLIP\n\trayStart.y = max(rayStart.y, 1.0);\n#endif\n\n\t// Planet and atmosphere intersection to get optical depth\n\t// TODO: Could simplify to circle intersection test if flat horizon is acceptable\n\tfloat2 t1 = PlanetIntersection(rayStart, rayDir);\n\tfloat2 t2 = AtmosphereIntersection(rayStart, rayDir);\n    \n    // Note: This only works if camera XZ is at 0. Otherwise, swap for line below.\n    float altitude = rayStart.y;\n    //float altitude = (length(rayStart - PLANET_CENTER) - PLANET_RADIUS);\n    float normAltitude = rayStart.y / ATMOSPHERE_HEIGHT;\n\n\tif (t2.y < 0.0)\n\t{\n\t\t// Outside of atmosphere looking into space, return nothing\n\t\ttransmittance = float4(1, 1, 1, 0);\n\t\treturn float3(0, 0, 0);\n\t}\n    else\n    {\n        // In case camera is outside of atmosphere, subtract distance to entry.\n        t2.y -= max(0.0, t2.x);\n\n#ifdef DRAW_PLANET\n        float opticalDepth = t1.x > 0.0 ? min(t1.x, t2.y) : t2.y;\n#else\n        float opticalDepth = t2.y;\n#endif\n\n        // Optical depth modulators\n        opticalDepth = min(rayLength, opticalDepth);\n        opticalDepth = min(opticalDepth * AERIAL_SCALE, t2.y);\n\n        // Altitude-based density modulators\n        float h = 1.0-1.0/(2.0+sq(t2.y)*M_DENSITY_HEIGHT_MOD);\n        h = pow(h, 1.0+normAltitude*M_DENSITY_CAM_MOD); // Really need a pow here, bleh\n        float sqh = sq(h);\n        float densityR = sqh * DENSITY;\n        float densityM = sq(sqh)*h * DENSITY;\n\n#ifdef NIGHT_LIGHT\n        float nightLight = NIGHT_LIGHT;\n#else\n        float nightLight = 0.0;\n#endif\n\n        // Apply light transmittance (makes sky red as sun approaches horizon)\n        lightColor *= GetLightTransmittance(rayStart, lightDir, h); // h bias makes twilight sky brighter\n\n#ifndef LIGHT_COLOR_IS_RADIANCE\n        // If used in an environment where light \"color\" is not defined in radiometric units\n        // we need to multiply with PI to correct the output.\n        lightColor *= PI;\n#endif\n\n        float3 R, M;\n        GetRayleighMie(opticalDepth, densityR, densityM, R, M);\n\n        float costh = dot(rayDir, lightDir);\n        float phaseR = PhaseR(costh);\n        float phaseM = PhaseM(costh, 0.85);\n        float3 A = phaseR * lightColor + nightLight;\n        float3 B = phaseM * lightColor + nightLight;\n        float3 C = (C_RAYLEIGH * densityR + C_MIE * densityM + C_OZONE * densityR) * pow4(1.0 - normAltitude) * M_TRANSMITTANCE;\n        \n        // Combined scattering\n        float3 scattering = R * A + M * B;\n\n        // View extinction, matched to reference\n        transmittance.xyz = exp(-opticalDepth * C);\n        // Store planet intersection flag in transmittance.w, useful for occluding celestial bodies etc.\n        transmittance.w = step(t1.x, 0.0);\n\n        if (fogFactor > 0.0)\n        {\n            // 2nd sample (all the way to atmosphere exit), used for fog fade.\n            opticalDepth = t2.y;\n            GetRayleighMie(opticalDepth, densityR, densityM, R, M);\n            float3 scattering2 = R * A + M * B;\n            float3 transmittance2 = exp(-opticalDepth * C);\n\n            //scattering2 *= lerp(float3(1, 0, 0), float3(1, 1, 1), sq(fogFactor)); // Fog color test\n            scattering = lerp(scattering, scattering2, fogFactor);\n            transmittance.xyz = lerp(transmittance.xyz, transmittance2, fogFactor);\n        }\n\n        return scattering * EXPOSURE;\n    }\n}\n\n// Overloaded functions in case you are not interested in transmittance/fading\nfloat3 GetAtmosphere(float3 rayStart, float3 rayDir, float rayLength, float3 lightDir,\n\tfloat3 lightColor, out float4 transmittance)\n{\n    return GetAtmosphere(rayStart, rayDir, rayLength, lightDir, lightColor, transmittance, 0.0);\n}\nfloat3 GetAtmosphere(float3 rayStart, float3 rayDir, float rayLength, float3 lightDir, float3 lightColor)\n{\n    float4 transmittance;\n    return GetAtmosphere(rayStart, rayDir, rayLength, lightDir, lightColor, transmittance, 0.0);\n}\n\nfloat3 GetSunDisc(float3 rayDir, float3 lightDir)\n{\n    const float A = cos(0.00436 * SUN_DISC_SIZE);\n\tfloat costh = dot(rayDir, lightDir);\n\tfloat disc = sqrt(smoothstep(A, 1.0, costh));\n\treturn float3(disc, disc, disc);\n}\n\n#endif // FAST_ATMOSPHERE_INCLUDED","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A renders the terrain during the first frame, or whenever the resolution changes.\n\n#define MAX_SAMPLES 200\n#define MAX_DIST 100000.0\n#define TERRAIN_SCALE 8000.0\n#define TERRAIN_OFFSET vec2(0.5, 0.5)\n#define TERRAIN_HEIGHT 2500.0\n\nvoid GetCamera(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(0, 3000, 0);\n    float aspect = iResolution.x / iResolution.y;\n    rd = normalize(vec3((uv - 0.5) * vec2(aspect, 1.0), 1.0));\n}\n\n// http://iquilezles.org/articles/morenoise/\nconst mat2 m = mat2(0.8,-0.6,0.6,0.8);\nvec3 Noised(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat Terrain(vec2 p)\n{\n    p /= TERRAIN_SCALE;\n    p += TERRAIN_OFFSET;\n    float a = 0.0;\n    float b = 1.0;\n    vec2  d = vec2(0.0);\n    for (int i = 0; i < 13; i++)\n    {\n        vec3 n = Noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n        b *= 0.5;\n        p = m*p*2.0;\n    }\n    return a * TERRAIN_HEIGHT;\n}\nvec3 TerrainNormal(vec3 p)\n{\n    float d = 1.0;\n    vec3 p0 = p;\n    vec3 p1 = p + vec3(d, 0, 0);\n    vec3 p2 = p + vec3(0, 0, d);\n    p0.y = Terrain(p0.xz);\n    p1.y = Terrain(p1.xz);\n    p2.y = Terrain(p2.xz);\n    \n    return normalize(cross(p2 - p0, p1 - p0));\n}\nfloat MarchTerrain(vec3 ro, vec3 rd, float maxDist, out vec3 normal)\n{\n    float t = 0.0;\n    float ds = 0.0;\n    for (int i = 0; i < MAX_SAMPLES; i++)\n    {\n        vec3 p = ro + rd * t;\n        float h = p.y - Terrain(p.xz);\n        if (h < 0.0)\n        {\n            t -= ds * 0.5;\n            break;\n        }\n        ds = max(t * 2e-3, h * 0.5);\n        t += ds;\n        if (t > maxDist)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    normal = TerrainNormal(ro + rd * t);\n    return t;\n}\n\nvec4 Render(vec2 pixel)\n{\n    vec2 uv = pixel / iResolution.xy;\n    \n    vec3 ro, rd;\n    GetCamera(uv, ro, rd);\n    \n    vec3 normal;\n    float t = MarchTerrain(ro, rd, MAX_DIST, normal);\n    \n    return vec4(t, normal.xz, iResolution.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 prev = texture(iChannel2, uv);\n    \n    // Render for 10 frames to fix issue where nothing appears when opening the shader otherwise\n    if (iFrame > 10 && iResolution.x == prev.w)\n    {\n        // Terrain already rendered, exit\n        fragColor = prev;\n        return;\n    }\n    \n    fragColor = Render(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B renders god rays, shadows and ambient occlusion\n// (by marching the terrain buffer depth).\n\n// Disabling these three makes the shader very fast\n#define ENABLE_ATMOSPHERE_OCCLUSION\n#define ENABLE_SHADOWS\n#define ENABLE_AMBIENT_OCCLUSION\n\n#define SAMPLE_COUNT 2.0\n#define SHADOW_RANGE 10000.0\n#define AMBIENT_OCCLUSION_RANGE 2000.0\n\nvoid GetCamera(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(0, 3000, 0);\n    float aspect = iResolution.x / iResolution.y;\n    rd = normalize(vec3((uv - 0.5) * vec2(aspect, 1.0), 1.0));\n}\nvec2 GetUV(vec3 rd)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = rd.xy / (rd.z * 1.0) / vec2(aspect, 1.0) + 0.5;\n    return uv;\n}\nvec3 ExpandPackedNormal(vec2 normalXZ)\n{\n    vec3 n = vec3(normalXZ.x, 0, normalXZ.y);\n    n.y = sqrt(1.0 - clamp(dot(n.xz, n.xz), 0.0, 1.0));\n    return n;\n}\n\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\nfloat Random(uint seed)\n{\n    return float(Hash(seed)) / 4294967295.0;\n}\nfloat3 RandomUnitVector(uint seed)\n{\n    float PI2 = 6.28318530718;\n    float z = 1.0 - 2.0 * Random(seed);\n    float xy = sqrt(1.0 - z * z);\n    float r = Random(seed + 1u);\n    float sn = sin(PI2 * r);\n    float cs = cos(PI2 * r);\n    return float3(sn * xy, cs * xy, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.xyxy;\n    float time = -iTime * 0.2 + 3.5;\n    vec2 sunPos = 0.5 + vec2(cos(time) * 0.4, sin(time) * 0.45);\n    if (iMouse.x > 10.0)\n    {\n        sunPos = mouse.xy;\n    }\n    vec3 sunDir;\n    vec3 foo;\n    GetCamera(sunPos, foo, sunDir);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro, rd;\n    GetCamera(uv, ro, rd);\n    \n    float dither = textureLod(iChannel2, uv * iResolution.xy / vec2(1024), 0.0).x;\n    dither = fract(dither + (0.61803398875 * float(iFrame & 255)));\n    \n    float atmosphereOcclusion = 1.0;\n    float shadow = 1.0;\n    float ambientOcclusion = 1.0;\n    \n#ifdef ENABLE_ATMOSPHERE_OCCLUSION\n    atmosphereOcclusion = 0.0;\n    for (float i = 0.0; i < SAMPLE_COUNT; i++)\n    {\n        float delta = (i + dither) / SAMPLE_COUNT;\n        vec2 localUV = mix(uv, sunPos, delta);\n        atmosphereOcclusion += texture(iChannel0, localUV).x > 0.0 ? 0.0 : 1.0;\n    }\n    atmosphereOcclusion /= SAMPLE_COUNT;\n#endif\n\n    vec4 terrain = texture(iChannel0, uv);\n    vec3 p = ro + rd * terrain.x;\n    \n#ifdef ENABLE_SHADOWS\n    if (terrain.x > 0.0)\n    {\n        for (float i = 0.0; i < SAMPLE_COUNT; i++)\n        {\n            float delta = (i + dither) / SAMPLE_COUNT;\n            vec3 localP = p + sunDir * delta * SHADOW_RANGE;\n            vec3 dir = localP - ro;\n            float dist = length(dir);\n            dir /= dist;\n            vec2 localUV = GetUV(dir);\n            vec4 localTerrain = texture(iChannel0, localUV);\n            shadow *= localTerrain.x < 0.0 || localTerrain.x > dist ? 1.0 : 0.0;\n        }\n    }\n#endif\n\n#ifdef ENABLE_AMBIENT_OCCLUSION\n    ambientOcclusion = 1.0;\n    vec3 n = ExpandPackedNormal(terrain.yz);\n    if (terrain.x > 0.0)\n    {\n        ivec2 iFragCoord = ivec2(fragCoord.xy);\n        vec3 sampleDir = RandomUnitVector(uint(iFrame * iFragCoord.x * iFragCoord.y + iFragCoord.x + iFragCoord.y * int(iResolution.x)));\n        sampleDir *= sign(dot(sampleDir, n));\n        for (float i = 0.0; i < SAMPLE_COUNT; i++)\n        {\n            float delta = (i + dither) / SAMPLE_COUNT;\n            vec3 localP = p + sampleDir * dither * AMBIENT_OCCLUSION_RANGE;\n            vec3 dir = localP - ro;\n            float dist = length(dir);\n            dir /= dist;\n            vec2 localUV = GetUV(dir);\n            vec4 localTerrain = texture(iChannel0, localUV);\n            ambientOcclusion *= localTerrain.x < 0.0 || localTerrain.x + 1e2 > dist ? 1.0 : 0.0;\n        }\n    }\n#endif\n    \n    vec4 prev = texture(iChannel1, uv);\n    // Decrease temporal stability whenever sun moves\n    float temporalStability = 0.95 * exp(-abs(sunPos.x + sunPos.y - prev.w) * 20.0);\n    \n    atmosphereOcclusion = mix(atmosphereOcclusion, prev.x, temporalStability);\n    shadow = mix(shadow, prev.y, temporalStability);\n    ambientOcclusion = mix(ambientOcclusion, prev.z, iFrame == 0 ? 0.0 : 0.98); // Ambient occlusion is independent of sun movement\n    \n    fragColor = vec4(atmosphereOcclusion, shadow, ambientOcclusion, sunPos.x + sunPos.y);\n}","name":"Buffer B","description":"","type":"buffer"}]}