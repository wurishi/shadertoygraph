{"ver":"0.1","info":{"id":"wlffzl","date":"1597503665","viewed":171,"name":"Cloudie","username":"hedyla2055","description":"A rapid experiment with rendering a simple volumetirc cloud.\nOriginally, based on Cloudy spikeball by Duke: https://www.shadertoy.com/view/MljXDw\nSome other useful shaders: https://www.shadertoy.com/view/4ldGRf\nOpen to feedback or improvement suggestions.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","volumetricclouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define SKY_COLOR vec4(0.525,0.78,0.86, 1.0)\n#define MAX_DISTANCE 20.\n#define MAX_DENSITY 0.95\n#define THRESHOLD 0.08\n\n// IQ's smooth union\nfloat SmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// IQ's noise\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nfloat FBM(vec3 p) {\n   return Noise(p*.06125)*.5 + Noise(p*.125)*.25 + Noise(p*.25)*0.125;\n}\n\nfloat Ball(vec3 p, vec3 c, float r)\n{\n    return length(p - c) -  r;\n}\n\nfloat Cloud(vec3 p) \n{\n   p.z += 12.;\n           \n   // The upper 4 balls\n   float b1 = Ball(p, vec3(3.2, -0.5, 0.), 2.5) + FBM(p*28.+iTime*15.) * 0.15;\n   float b2 = Ball(p, vec3(-3.9, -1., 0.), 2.) + FBM(p*50.+iTime*15.) * 0.15;\n   float b3 = Ball(p, vec3(1.2, 1.5, 0.), 1.9) + FBM(p*20.+iTime*15.) * 0.18;\n   float b4 = Ball(p, vec3(-1.9, 1., 0.), 2.9) + FBM(p*50.+iTime*15.) * 0.13;\n    \n   // The lower 4 balls\n   float b5 = Ball(p, vec3(0., -1.5, 0.), 2.) + FBM(p*50.+iTime*15.) * 0.25;\n   float b6 = Ball(p, vec3(-2.85, -1.8, 0.), 1.8) + FBM(p*38.+iTime*15.) * 0.15;\n   float b7 = Ball(p, vec3(2.5, -1.8, 0.), 1.8) + FBM(p*28.+iTime*15.) * 0.25;\n   float b8 = Ball(p, vec3(5.1, -2., 0.), 1.5) + FBM(p*78.+iTime*25.) * 0.15;\n\n   // The fusion part\n   float r1 = SmoothUnion(b1, b2, 0.55);\n   float r2 = SmoothUnion(r1, b3, 0.65);\n   float r3 = SmoothUnion(r2, b4, 0.75);\n   float r4 = SmoothUnion(r3, b5, 0.35);\n   float r5 = SmoothUnion(r4, b6, 0.5);\n   float r6 = SmoothUnion(r5, b7, 0.6);\n   return SmoothUnion(r6, b8, 0.9);\n}\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{  \n   vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n   col = SKY_COLOR;\n   col.rgb -= uv.y * vec3(1.0, 0.8, 1.0) * 0.45;\n   \n   vec3 ray_origin = vec3(0., 0., 0.);\n   vec3 ray_dir = normalize(vec3(uv.x, uv.y, -1.0) - ray_origin);  \n\n   float local_density = 0., total_density = 0.;\n   float weight = 0.;\n   vec3 out_color = vec3(0.);\n   float distance_origin = 0.;\n   float distance_surface= 0.;\n\n   for (int i= 0; i < MAX_STEPS; i++) {\n\n      if(!((distance_surface >= 0.001 * distance_origin) &&\n           (distance_origin < MAX_DISTANCE) && \n           (total_density < MAX_DENSITY)))\n          break;\n       \n      vec3 p = ray_origin + ray_dir * distance_origin;\n      distance_surface = Cloud(p);\n      \n      // Check whether we are close enough (step)\n      // Compute local density and weighting factor \n      local_density = (THRESHOLD - distance_surface) *\n          \t\t\t\tstep(distance_surface, THRESHOLD);\n      weight = (1. - total_density) * local_density * 0.5;   \n     \n      out_color += weight;\n      total_density += weight + 1. / 200.;\n      \n      // Enforce minimum stepsize (non-uniform step)\n      distance_surface = max(distance_surface, 0.03);\n\n      distance_origin += distance_surface;\n   }  \n\n   // Simple scattering approximation\n   out_color *= 1. / exp( local_density * 0.3 ) * 1.25;\n\n     \n   // Blend colors to eliminate sharp transition at the edges\n   col.rgb = mix(col.rgb, out_color, \n                 step(2.0, dot(out_color.xyz, out_color.xyz)));\n}","name":"Image","description":"","type":"image"}]}