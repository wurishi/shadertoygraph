{"ver":"0.1","info":{"id":"7dccRl","date":"1654022075","viewed":216,"name":"Red ghost (Long compile time)","username":"LuncyTB","description":"Render a game charactar.","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","modeling","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Copyright (c) 2022 LuncyTB. All rights reserved.\n */\n \nprecision highp float;\n\n#define PI 3.14159\n#define E 2.71828\n#define TIMES 128\n#define MAX_DIS 100.0\n#define MIN_DIS 0.001\n#define e vec2(-0.01, 0.01)\n\nvec3 light = normalize(vec3(0.3, 0.4, -1.2));\nvec3 lightCol = vec3(1.0, 0.97, 0.95) * 1.5;\nvec3 env = vec3(0.7, 0.2, 0.1) * 1.1;\nvec3 cloudCol = vec3(0.7, 0.7, 0.8);\nfloat fog = 0.17;\nfloat fogForce = 0.71;\n#define _ iChannel2\n\nstruct F {\n    vec3 normal;\n    vec3 albedo;\n    vec3 arm; // Alpha Roughness Metallic\n    vec3 emission;\n};\n\nmat4 packLocal(vec3 pos, vec3 rot) {\n    float cx = cos(rot.x), cy = cos(rot.y), cz = cos(rot.z);\n    float sx = sin(rot.x), sy = sin(rot.y), sz = sin(rot.z);\n    return mat4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, cx, -sx, 0.0,\n            0.0, sx, cx, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ) * mat4(\n            cy, 0.0, sy, 0.0, \n            0.0, 1.0, 0.0, 0.0,\n            -sy, 0.0, cy, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ) * mat4(\n            cz, -sz, 0.0, 0.0, \n            sz, cz, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        ) * mat4(\n            1.0, 0.0, 0.0, 0.0, \n            0.0, 1.0, 0.0, 0.0, \n            0.0, 0.0, 1.0, 0.0,\n            -pos.x, -pos.y, -pos.z, 1.0\n        );\n}\n\nfloat hash(in float s) {\n    return fract(sin(s * 34.3201) * 349321.4893 + 0.34);\n}\n\nvec2 noise2(in vec2 uv) {\n    vec2 k = vec2(fract(sin(uv.x * 5.341 + uv.y * 102.7558) * 41234.0123), \n        fract(cos(uv.y * -23.341 + uv.x * 74.0134) * 93481.43217));\n    float r = k.x * PI * 2.0;\n    float l = pow(k.y + 0.001, 0.5);\n    return vec2(cos(r) * l, sin(r) * l);\n}\n\nfloat noise(in vec2 uv) {\n    return fract(sin(dot(uv, vec2(56.7712, 23.0071)) + 0.12) * 82333.132);\n}\n\nfloat cloud1(in vec2 uv, in float size) {\n    vec2 p00 = floor(uv / size);\n    vec2 p01 = floor(uv / size + vec2(0.0, 1.0));\n    vec2 p11 = floor(uv / size + vec2(1.0, 1.0));\n    vec2 p10 = floor(uv / size + vec2(1.0, 0.0));\n    uv = uv / size;\n    vec2 v00 = normalize(noise2(p00));\n    vec2 v01 = normalize(noise2(p01));\n    vec2 v11 = normalize(noise2(p11));\n    vec2 v10 = normalize(noise2(p10));\n    return clamp(mix(\n        mix(dot(v11, uv - p11), dot(v01, uv - p01), cos((uv.x - p00.x) * PI) * 0.5 + 0.5),\n        mix(dot(v10, uv - p10), dot(v00, uv - p00), cos((uv.x - p01.x) * PI) * 0.5 + 0.5),\n        cos((uv.y - p00.y) * PI) * 0.5 + 0.5\n    ) * 0.5 + 0.5, 0.0, 1.0);\n}\n\nfloat cloud(in vec2 uv, in float size, in float times, in float sub) {\n    float c = 0.0;\n    float b = 0.0;\n    float k = 1.0;\n    for (float i = 0.0; i < times; i++) {\n        k = pow(sub, i);\n        c += cloud1(uv * sign(hash(i) - 0.5) + vec2(0.3, 1.3) * i, size * pow(0.5, i)) * k;\n        b += k;\n    }\n    return c / b;\n}\n\nfloat sdfSphere(in vec3 pos, in float r) {\n    float d = length(pos) - r;\n    return d;\n}\n\nfloat replace(in vec3 pos, in float r, in float rp, in sampler2D tex, in float size) {\n    float d = length(pos) - r;\n    if (d < abs(rp) * 8.0 && rp != 0.0) {\n        return rp * textureLod(tex, \n            size * vec2(atan(pos.y, pos.x), atan(pos.z, length(pos.xy))), 0.0).r;\n    }\n    return 0.0;\n}\n\nfloat sdfCone(in vec3 pos, in float h, in float r, in vec3 scl) {\n    pos = pos / scl;\n    if (pos.z < 0.0) {\n        return sqrt(pow(pos.z, 2.0) + pow(min(r, length(pos.xy) - r), 2.0));\n    } else {\n        \n    }\n}\n\nfloat smin(in float a, in float b, in float k) {\n    float m = min(a, b);\n    float d = abs(a - b);\n    return m - pow(sqrt(1.0 / E), d * k) / k;\n}\n\nvec3 tFog(in vec3 col, in float d) {\n    return mix(col, mix(cloudCol, env, fogForce), clamp(log(d) * fog, 0.0, 1.0));\n}\n\nvec3 gamma(in vec3 c, in float base) {\n    return vec3(pow(c.r, 1.0 / base),\n        pow(c.g, 1.0 / base), pow(c.b, 1.0 / base));\n}\n\nvec3 bg(in vec3 ray, in float sub) {\n    vec3 c = vec3(0.0);\n    float d = 0.0;\n    if (ray.z < 0.0) {\n        vec2 guv = ray.xy / ray.z;\n        float k = mod(floor(fract(guv.x) * 2.0) + floor(fract(guv.y) * 2.0), 2.0);\n        c = mix(vec3(0.7, 0.6, 0.2), vec3(0.2, 0.1, 0.1), k);\n        c = c * env + c * lightCol * max(0.0, dot(-light, vec3(0.0, 0.0, 1.0)));\n        d = length(vec3(guv, 1.0));\n    } else if (ray.z >= 0.0) {\n        c = env;\n        d = MAX_DIS;\n        vec2 guv = ray.xy / (ray.z + 0.01) * 3.1;\n        d = length(vec3(guv, 3.1));\n        float l1 = pow(cloud(guv + vec2(iTime, iTime * 0.7), 3.0, sub, 0.5), 3.3) * (1.6 + log(d * 0.1));\n        float l2 = pow(cloud(guv - vec2(iTime * 0.6, -iTime * 1.3), 6.0, sub, 0.5), 3.3) * (1.6 + log(d * 0.1));\n        c = mix(c, cloudCol, pow(l1 * l2, 0.6));\n    }\n    return tFog(c, d);\n}\n\nvec3 background(in vec3 ray, in float size) {\n    float k = size / min(iResolution.x, iResolution.y);\n    vec3 r000 = floor(ray * size);\n    vec3 r001 = floor(ray * size + vec3(0.0, 0.0, 1.0));\n    vec3 r010 = floor(ray * size + vec3(0.0, 1.0, 0.0));\n    vec3 r011 = floor(ray * size + vec3(0.0, 1.0, 1.0));\n    vec3 r100 = floor(ray * size + vec3(1.0, 0.0, 0.0));\n    vec3 r101 = floor(ray * size + vec3(1.0, 0.0, 1.0));\n    vec3 r110 = floor(ray * size + vec3(1.0, 1.0, 0.0));\n    vec3 r111 = floor(ray * size + vec3(1.0, 1.0, 1.0));\n    vec3 ins = 1.0 - fract(ray * size);\n    \n    return mix(\n            mix(mix(bg(r000, size / 87.0), bg(r001, size / 87.0), 0.5 * cos(ins.z * PI) + 0.5), \n                mix(bg(r010, size / 87.0), bg(r011, size / 87.0), 0.5 * cos(ins.z * PI) + 0.5),\n                0.5 * cos(ins.y * PI) + 0.5),\n            mix(mix(bg(r100, size / 87.0), bg(r101, size / 87.0), 0.5 * cos(ins.z * PI) + 0.5), \n                mix(bg(r110, size / 87.0), bg(r111, size / 87.0), 0.5 * cos(ins.z * PI) + 0.5),\n                0.5 * cos(ins.y * PI) + 0.5),\n            0.5 * cos(ins.x * PI) + 0.5);\n}\n\nvec3 M(in vec3 p, in mat4 m) {\n    return (m * vec4(p, 1.0)).xyz;\n}\n\nmat4 m0, m1;\nfloat mouseAni;\n\nfloat scene(in vec3 pos) {\n    float d = MAX_DIS;\n    \n    vec3 p0 = M(pos, m0);\n    if (length(p0) < 2.4) {\n        d = smin(d, sdfSphere(p0, 0.6) - \n            replace(p0, 0.6, 0.1, iChannel0, 0.1) -\n            replace(p0, 0.6, 0.01, iChannel0, 1.8), 22.0);\n        d = smin(d, sdfSphere(p0 + vec3(0.0, 0.2, 0.6 + mouseAni * 0.7), 0.25) -\n            replace(p0 + vec3(0.0, 0.2, 0.6 + mouseAni * 0.7), 0.25, 0.0, _, 0.0), 8.0);\n        d = smin(d, sdfSphere(p0 + vec3(0.0, 0.4, 0.8 + mouseAni), 0.2) -\n            replace(p0 + vec3(0.0, 0.4, 0.8 + mouseAni), 0.2, 0.0, _, 0.0), 22.0);\n        d = smin(d, sdfSphere(p0 + vec3(0.0, 0.4, -0.6), 0.2) -\n            replace(p0 + vec3(0.0, 0.4, -0.6), 0.2, 0.1, iChannel0, 0.55), 6.0);\n\n        vec3 pp0 = vec3(-abs(p0.x), p0.yz);\n        float d1 = smin(MAX_DIS, sdfSphere(pp0 + vec3(0.6, -0.2, 0.4 + mouseAni), 0.3) - \n            replace(pp0 + vec3(0.6, -0.2, 0.4 + mouseAni), 0.3, 0.1, iChannel0, 0.25), 6.0);\n        d1 = smin(d1, sdfSphere(pp0 + vec3(0.8, -0.2, 0.7 + mouseAni), 0.2) - \n            replace(pp0 + vec3(0.8, -0.2, 0.7 + mouseAni), 0.2, 0.1, iChannel0, 0.25), 24.0);\n        d1 = smin(d1, sdfSphere(pp0 + vec3(1.0, -0.1, 0.9 + mouseAni), 0.1) - \n            replace(pp0 + vec3(1.0, -0.1, 0.9 + mouseAni), 0.1, 0.1, iChannel0, 0.25), 24.0);\n        d1 = -min(-d1, sdfSphere(pp0 + vec3(1.4, 0.0, 0.3 + mouseAni), 0.7) - \n            replace(pp0 + vec3(1.4, 0.0, 0.3 + mouseAni), 0.7, 0.1, iChannel0, 0.25));\n        d1 = -min(-d1, sdfSphere(pp0 + vec3(1.0, 0.5, 0.6 + mouseAni), 0.7) - \n            replace(pp0 + vec3(1.0, 0.5, 0.6 + mouseAni), 0.7, 0.1, iChannel0, 0.25));\n\n        d = smin(d, d1, 64.0);\n        \n        float md = min(MAX_DIS, sdfSphere(p0 + vec3(0.0, 0.6 + (0.05 - mouseAni * 0.5), -0.3 + mouseAni), 0.9) -\n            replace(p0 + vec3(0.0, 0.6 + (0.05 - mouseAni * 0.5), -0.3 + mouseAni), 0.9, 0.2, iChannel0, 0.3));\n        md = -min(-md, sdfSphere(p0 + vec3(0.0, 0.6, -0.7), 1.0) - \n            replace(p0 + vec3(0.0, 0.6, -0.7), 1.0, -0.2, iChannel0, 0.3));\n        \n        d = -min(-d, md);\n        \n        float xd = min(MAX_DIS, sdfSphere(pp0 + vec3(0.27, 0.7, -0.3), 0.4) - \n            replace(pp0 + vec3(0.27, 0.7, -0.3), 0.4, 0.05, iChannel0, 1.0));\n        xd = -min(-xd, sdfSphere(pp0 + vec3(0.14, 0.7, -0.46), 0.48) - \n            replace(pp0 + vec3(0.14, 0.7, -0.46), 0.48, 0.05, iChannel0, 1.0));\n        d = -min(xd, -d);\n        \n        xd = min(MAX_DIS, sdfSphere(pp0 + vec3(0.22, 0.7, -0.44), 0.42) - \n            replace(pp0 + vec3(0.22, 0.7, -0.44), 0.42, 0.05, iChannel0, 1.0));\n        xd = -min(-xd, sdfSphere(pp0 + vec3(0.09, 0.7, -0.58), 0.5) - \n            replace(pp0 + vec3(0.09, 0.7, -0.58), 0.5, 0.05, iChannel0, 1.0));\n        d = -min(xd, -d);\n        \n    } else {\n        d = min(d, length(p0) - 1.2);  \n    }\n    \n    vec3 twoBpos = M(vec3(abs(pos.x), pos.yz) + vec3(-1.7, 0.0, 0.0), m1);\n    d = min(d, sdfSphere(twoBpos, 0.4 - abs(cos(iTime * 1.5)) * 0.2) - \n        replace(twoBpos, 0.4, 0.1, iChannel1, 0.2));\n    \n    return d;\n}\n\nvoid hitF(in vec3 pos, out F face) {\n    face.albedo = vec3(0.0); face.arm = vec3(1.0, 0.02, 0.0); face.emission = vec3(0.0);\n    face.albedo = vec3(0.5, 0.14, 0.1);\n    face.normal = normalize(\n        e.yyx * scene(pos + e.yyx) +\n        e.yxy * scene(pos + e.yxy) +\n        e.xyy * scene(pos + e.xyy) +\n        e.xxx * scene(pos + e.xxx)\n    );\n    vec3 p0 = M(pos, m0);\n    vec3 pp0 = vec3(-abs(p0.x), p0.yz);\n\n    float headD = sdfSphere(p0 + vec3(0.0, 0.4, -0.6), 0.3);\n    if (abs(headD) < MIN_DIS * 10.0 + 0.2) {\n        float rd = replace(p0 + vec3(0.0, 0.4, -0.6), 0.2, 0.1, iChannel0, 0.55);\n        face.albedo = mix(vec3(0.4, 0.24, 0.1), face.albedo, headD / (MIN_DIS + 0.2));\n        face.arm.y = 0.5 * (1.0 - headD / (MIN_DIS + 0.2));\n        face.emission = vec3(0.8, 0.21, 0.02) * 4.5 * pow(abs(rd) / 0.1, 3.0) * (1.0 - headD / (MIN_DIS + 0.2));\n    }\n\n    float mouseD = sdfSphere(p0 + vec3(0.0, 0.6 + (0.05 - mouseAni * 0.5), -0.3 + mouseAni), 0.9);\n    if (abs(mouseD) < MIN_DIS * 10.0 + 0.2) {\n        float brd = mouseD - replace(p0 + vec3(0.0, 0.6 + (0.05 - mouseAni * 0.5), -0.3 + mouseAni), 0.9, 0.2, iChannel0, 0.3);\n        if (abs(brd) < MIN_DIS * 10.0 * 3.0) { \n            face.albedo = mix(face.albedo, vec3(0.08, 0.06, 0.03), clamp((1.0 - abs(mouseD) / 0.1) * (1.0 - p0.y * 4.0), 0.0, 1.0));\n        }\n    }\n\n    float mouseD2 = sdfSphere(p0 + vec3(0.0, 0.6, -0.7), 1.0);\n    if (abs(mouseD2) < MIN_DIS * 10.0 + 0.2) {\n        float brd = mouseD2 - replace(p0 + vec3(0.0, 0.6, -0.7), 1.0, -0.2, iChannel0, 0.3);\n        if (abs(brd) < MIN_DIS * 3.0) {\n            face.albedo = mix(face.albedo, vec3(0.08, 0.06, 0.03), clamp((1.0 - abs(mouseD2) / 0.1) * (1.0 - p0.y * 4.0), 0.0, 1.0));\n        }\n    }\n\n    float xD = sdfSphere(pp0 + vec3(0.15, 0.23, -0.1), 0.42);\n    if (xD < 0.0 && mouseD2 < -MIN_DIS * 10.0 - 0.1) { \n        face.emission = vec3(1.1, 0.04, 0.01) * 6.0 * pow((-xD / 0.42), 0.7); \n    };\n\n    float hdlD = sdfSphere(pp0 + vec3(1.0, -0.5, 0.8 + mouseAni), 0.9);\n    if (hdlD < MIN_DIS * 10.0) {\n        face.albedo = mix(vec3(0.4, 0.24, 0.1), face.albedo, max(0.0, (hdlD + 0.2) / 0.2));\n        face.emission = vec3(0.8, 0.21, 0.02) * 4.4 * pow(max(0.0, -0.1 - hdlD), 2.3);\n    }\n    \n    vec3 twoBpos = M(vec3(abs(pos.x), pos.yz) + vec3(-1.7, 0.0, 0.0), m1);\n    if (sdfSphere(twoBpos, 0.4 - abs(cos(iTime * 1.5)) * 0.2) - \n            replace(twoBpos, 0.4, 0.1, iChannel1, 0.2) < MIN_DIS * 10.0) {\n        face.albedo = vec3(0.6, 0.48, 0.33) * 1.3;\n        face.arm = vec3(0.0, 0.55 + cos(iTime) * 0.45, 1.0);\n        face.emission = vec3(0.0);\n    }\n}\n\nfloat march(in vec3 org, in vec3 ray, in int times) {\n    float d = 0.0;\n    for (int i = min(0, iFrame); i < times; ++i) {\n        float s = scene(org + ray * d);\n        if (d > MAX_DIS) { return MAX_DIS; }\n        if (s < MIN_DIS * d) { return d; }\n        d += s * 0.5;\n    } \n    return min(d, MAX_DIS);\n}\n\nvec3 render(in F face, in vec3 ray, in float shadow, in vec3 old) {\n    float fnl = mix(pow(1.0 - abs(dot(-ray, face.normal)), 6.0), 1.0, 0.03 + face.arm.z * 0.8);\n    vec3 ref = reflect(ray, face.normal);\n    float sscale = 0.07 + face.arm.y;\n    float postK = pow(max(0.0, dot(-light, ref)), pow(1.0 / sscale, 2.0));\n    return (1.0 - face.arm.z) * face.albedo * background(face.normal, 1.0)\n        + (1.0 - face.arm.z * 0.9) * face.albedo * lightCol * max(0.0, dot(-light, face.normal)) * shadow\n        + mix(vec3(1.0), face.albedo, face.arm.z) * background(ref, (1.0 - face.arm.y) * 6.0 + 1.0) * (0.8 + face.arm.z * 0.2) * fnl * mix(1.0 - face.arm.y, 1.0, face.arm.z)\n        + lightCol * postK * (0.4 + face.arm.z * 0.6) * shadow * mix(pow(1.0 - face.arm.y, 2.0), pow(1.0 - face.arm.y * 0.6, 2.0), face.arm.z) \n        + face.emission;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos2D = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(pos2D.x, 1.0, pos2D.y));\n    vec3 pos = vec3(0.1, -4.0, 0.2);\n    \n    m0 = packLocal(vec3(cos(iTime * 0.67) * 0.8, 0.8, 0.0 - cos(iTime * 19.0) * 0.05), \n        vec3(0.1 + cos(iTime * 2.5) * 0.23, 0.0, iMouse.x * 0.03 + cos(iTime * 0.7) + sin(iTime * 0.1) * 10.0));\n    mouseAni = cos(iTime * 19.0 + cos(iTime * 23.0) * 0.2) * 0.05;\n    m1 = packLocal(vec3(0.0), \n        vec3(0.1 + cos(iTime * 2.5) * 0.23, 0.0, iMouse.x * 0.03 + cos(iTime * 0.7) + sin(iTime * 0.1) * 10.0));\n    \n    vec3 col = background(ray, 128.0);\n    \n    float d = march(pos, ray, TIMES);\n    if (d < MAX_DIS) {\n        F face;\n        hitF(pos + ray * d, face);\n        float sd = march(pos + ray * d - light * MIN_DIS * 12.0, -light, TIMES);\n        if (sd < MAX_DIS) {\n            col = render(face, ray, 0.0, col);\n        } else {\n            col = render(face, ray, 1.0, col);\n        }\n    }\n    \n    fragColor = vec4(gamma(col, 2.2), 1.0);\n}","name":"Image","description":"","type":"image"}]}