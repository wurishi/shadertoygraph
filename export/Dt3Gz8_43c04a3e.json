{"ver":"0.1","info":{"id":"Dt3Gz8","date":"1681910598","viewed":80,"name":"Attempt at raytracing","username":"TotoShampoin","description":"After being taught at uni how to do basic raytracing on CPU, I figured I'd adapt it for GPU.\nSo... Here it is!\nI'll try more stuff such as light and reflection and stuff like that, but that'd be in another shadertoy project.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NB_SPHERE 6\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Intersection {\n    vec3 position;\n    vec4 color;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec4 color;\n};\n\nbool intersectSphere(Ray r, Sphere s, inout Intersection i, inout float t) {\n    vec3 rdir = normalize(r.direction);\n    vec3 CO = r.origin - s.position;\n    \n    float a = 1.;\n    float b = 2. * dot(rdir, CO);\n    float c = dot(CO, CO) - s.radius * s.radius;\n    float d = b * b - 4. * a * c;\n    \n    if(d < 0.) return false;\n    \n    float t1 = (-b - sqrt(d))/(2.*a);\n    float t2 = (-b + sqrt(d))/(2.*a);\n    t = min(t1, t2);\n    \n    i.position = r.origin + rdir * t;\n    i.color = s.color;\n    \n    return true;\n}\n\nvoid rayTrace(Sphere s[NB_SPHERE], vec2 uv, inout vec4 fragColor) {\n    Ray r;\n    Intersection i, _i;\n    r.direction = vec3(\n        uv.x,\n        uv.y,\n        -1.\n    );\n    bool touched = false, _touched = false;\n    float t = 0., _t = 0.;\n    for(int n = 0; n < NB_SPHERE; n++) {\n        _touched = intersectSphere(r, s[n], _i, _t);\n        if(_touched) {\n            if(!touched || _t < t) {\n                t = _t;\n                i = _i;\n            }\n            touched = true;\n        }\n    }\n    if(touched) {\n        fragColor = i.color;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.x / iResolution.y;\n    uv -= .5;\n    uv *= 2.;\n    uv.x *= AR;\n    \n    Sphere s[NB_SPHERE];\n    \n    // Beeg initializator\n    // I sure hope there is a better way to do that part\n    \n    s[0].position = vec3(0,0,-3);\n    s[0].radius = 1.;\n    s[0].color = vec4(1,0,0,1);\n    \n    s[1].position = vec3(\n        cos(iTime) * 2.,\n        sin(iTime),\n        -2.5\n     );\n    s[1].radius = .5;\n    s[1].color = vec4(0,1,0,1);\n    \n    s[2].position = vec3(\n        cos(iTime),\n        -sin(iTime),\n        sin(iTime) - 2.\n     );\n    s[2].radius = .5;\n    s[2].color = vec4(0,0,1,1);\n    \n    s[3].position = vec3(\n        -cos(iTime - 2.),\n        sin(iTime),\n        -2\n    );\n    s[3].radius = .5;\n    s[3].color = vec4(1,1,0,1);\n    \n    s[4].position = vec3(\n        cos(iTime * 2. + .5),\n        sin(iTime * 3.),\n        -2\n     );\n    s[4].radius = .5;\n    s[4].color = vec4(0,1,1,1);\n    \n    s[5].position = vec3(\n        0,\n        -sin(iTime),\n        -cos(iTime) - 3.\n     );\n    s[5].radius = .5;\n    s[5].color = vec4(1,0,1,1);\n    \n    fragColor = vec4(0);\n    // And we ray trace everything :D\n    rayTrace(s, uv, fragColor);\n}\n","name":"Image","description":"","type":"image"}]}