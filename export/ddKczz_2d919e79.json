{"ver":"0.1","info":{"id":"ddKczz","date":"1695747397","viewed":57,"name":"TriAngleBarycentric","username":"JackSolace","description":"example of barycentric coordinates as inside-outside check.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["barycentric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Sep 2023\n//Basic Raytrace of a Triangle.\n\n\nstruct Tri{\n    //coords\n    vec3 A;\n    vec3 B;\n    vec3 C;\n    //colors\n    vec4 ac;\n    vec4 bc;\n    vec4 cc;\n};\n\nstruct Plane{\n    vec3 point;\n    vec3 norm;\n};\n\nstruct Ray {\n\tvec3 origin; // Origin\n\tvec3 direction; // Direction\n};\n    \nvec3 getTriNormal(in Tri t){\n    return normalize(cross(t.B - t.A,t.C - t.B));\n}\n\nvoid ScaleTri(inout Tri t, vec3 scale){\n    mat3 S = mat3(scale.x, 0.0, 0.0,\n                 0.0, scale.y, 0.0,\n                 0.0, 0.0, scale.z);\n                 \n    t.A = S*t.A;\n    t.B = S*t.B;\n    t.C = S*t.C;\n    return;\n}\n\nvoid TranslateTri(inout Tri t, vec3 tr){\n    mat4 T = mat4(1.0,0.0, 0.0, 0.0,\n                  0.0,1.0, 0.0, 0.0,\n                  0.0,0.0,1.0,0.0,\n                  tr.x,tr.y,tr.z,1.0);\n    vec4 tA = vec4(t.A,1.0);\n    vec4 tB = vec4(t.B,1.0);\n    vec4 tC = vec4(t.C,1.0);\n    t.A = (T*tA).rgb;\n    t.B = (T*tB).rgb;\n    t.C = (T*tC).rgb;\n    return;\n}\n\nvoid RotateTri(inout Tri t, float theta){\n    \n    mat2 R = mat2(cos(theta), sin(theta),\n                  -sin(theta), cos(theta));\n    \n    t.A.xy *= R;\n    t.B.xy *= R;\n    t.C.xy *= R;\n    \n    return;\n}\n\n// From the Wikipedia page on Line-Plane intersection\nfloat intersectPlane(in Ray ray, in Plane plane) {\n\tfloat denominator = dot(ray.direction,plane.norm);\n    if(abs(denominator) >= 0.01) {//make sure Ray is not parallel to plane (or nearly parallel)\n        return dot((plane.point - ray.origin),plane.norm)/denominator;\n    }\n\treturn -1.0; // Any negative number to indicate no intersect (or intersection from behind)\n}\n\n//Get the 3d point that is depth along the ray\nvec3 calculateIntersectionPoint(in Ray ray, in float depth) {\n\treturn ray.origin + ray.direction*depth;\n}\n    \nPlane getSupportingPlane(in Tri t){\n    return Plane(t.A, getTriNormal(t));\n}\n\nvec3 getBarycentricCoords(in Tri t, in vec3 pos){\n    float area = length(cross(t.B - t.A,t.C - t.B));\n    float alpha = length(cross(t.B - pos, t.C - t.B))/area;\n    float beta = length(cross(t.C - pos, t.A - t.C))/area;\n    float gamma = length(cross(t.A - pos, t.B - t.A))/area;\n    return vec3(alpha,beta,gamma);\n}\n\nfloat intersectTri(in Ray r, in Tri t){\n    float lam = intersectPlane(r, getSupportingPlane(t));\n    if(lam <= 0.0) return -1.0;\n    vec3 bar = getBarycentricCoords(t, calculateIntersectionPoint(r,lam));\n    if(bar[0] + bar[1] + bar[2] > 1.000001) return -1.0;\n    return lam;\n}\n\nvoid TransformTri2D(inout Tri t, vec2 scale, float theta, vec2 trans){\n    mat3 T = mat3(cos(theta) + scale.x, sin(theta), 0.0,\n                  -sin(theta), cos(theta) + scale.y, 0.0,\n                  trans.x, trans.y, 1.0);\n    vec3 a3 = T*vec3(t.A.xy,1.0);\n    vec3 b3 = T*vec3(t.B.xy,1.0);\n    vec3 c3 = T*vec3(t.C.xy,1.0);\n\n\n    t.A.xy = (a3*(1.0/a3.z)).xy;\n    t.B.xy = (b3*(1.0/b3.z)).xy;\n    t.C.xy = (c3*(1.0/c3.z)).xy;\n    return;\n}\n\nvoid TransformTri(inout Tri t, vec3 scale, vec3 rot, vec3 trans){\n    mat4 T = mat4(cos(rot.z)*cos(rot.y) + scale.x, sin(rot.z)*cos(rot.y),-sin(rot.y),0.0,\n        cos(rot.z)*sin(rot.y)*sin(rot.x) - sin(rot.z)*cos(rot.x), sin(rot.z)*sin(rot.y)*sin(rot.x) + cos(rot.z)*cos(rot.x) + scale.y, cos(rot.y)*sin(rot.x), 0.0,\n        cos(rot.z)*sin(rot.y)*cos(rot.x) + sin(rot.z)*sin(rot.y),sin(rot.z)*sin(rot.y)*cos(rot.x)- cos(rot.z)*sin(rot.x),cos(rot.y)*cos(rot.x) + scale.z,0.0,\n        trans.x,trans.y,trans.z,1.0);\n    \n    t.A = (T*vec4(t.A,1.0)).rgb;\n    t.B = (T*vec4(t.B,1.0)).rgb;\n    t.C = (T*vec4(t.C,1.0)).rgb;\n    \n    \n    return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // output a 4d fragment color vector [R,G,B,A]\n    // input is a 2d fragment Co-ordinate vector [X,Y]\n    // can interpret input vector as a pixel (function is called 640x360 times by default per frame)\n    \n\t// Converting all coordinates (x,y) to be in the range [0,1]\n\tfloat u = fragCoord.x / iResolution.x; // iResolution.x is width in pixels\n\tfloat v = fragCoord.y / iResolution.y; // iResolution.y is height in pixels\n\n\t// Now convert from coordinate range [0,1] to [-1,1]\n\t// This moves pixel (0,0) to the middle of the image\n\tu = u * 2.0 - 1.0;\n\tv = v * 2.0 - 1.0;\n\n    //the following line is necessary since the image may not be a square\n    //removing this line results in the x dimension being stretched\n    u *= (iResolution.x/iResolution.y);\n    \n\t// The position of this pixel in 3D space \n    //(imagine a plane centered at the origin perpendicular to the camera, what would be the 3d coordinates of this pixel?)\n\tvec3 pixelPos = vec3(u, v, 0);\n\n    // The camera position in this example is on a fixed loop.\n    // Initialize at 0.0\n    vec3 cameraPos = vec3(0.0, 0.0, -4.0);\n    \n\t// The ray direction is ray from the camera through the pixel\n\tvec3 rayDir = normalize(pixelPos - cameraPos);\n    \n    Tri t = Tri(vec3(-1.0, 0.0, 2.0),vec3(1.0, -0.4, 2.0),vec3(0.0, 0.5, 2.0),vec4(1.0, 0.0, 0.0,1.0),vec4(0.0, 1.0, 0.0,1.0),vec4(0.0, 0.0, 1.0,1.0)); \n    \n    //TranslateTri(t, vec3(sin(iTime),cos(iTime),0.0));\n    //RotateTri(t,iTime);\n    //ScaleTri(t,vec3( 2.0 + cos(iTime), 2.0 + sin(iTime), 1.0));\n    //RotateTri(t,iTime);\n    //TranslateTri(t, vec3(sin(iTime),cos(iTime),0.0));\n    \n    //TransformTri2D(t, vec2(3.0 + cos(iTime), 3.0 + sin(iTime)), iTime, vec2(sin(iTime),cos(iTime)));\n    \n    //TransformTri(t, vec3( 2.0 + cos(iTime), 1.0 + sin(iTime), 0.0), vec3(1.0,0.0,0.0),vec3(sin(iTime),cos(iTime),0.0));\n    \n    //Create Ray struct from origin through current pixel\n    Ray ray = Ray(cameraPos, rayDir);\n    \n\t// Check if the ray from the camera through the pixel intersects the Tri\n\tfloat intersectionDepth = intersectTri(ray, t);\n\n\t// If the depth at which the ray intersects the Tri is positive (in front of camera)\n\tif (intersectionDepth >= 0.0)\n\t{   \n        //Get the ray intersection Point\n        vec3 intersect = calculateIntersectionPoint(ray, intersectionDepth);\n        \n        vec3 bary = getBarycentricCoords(t, intersect);\n        vec4 ambientColor = t.ac*bary[0] + t.bc*bary[1] + t.cc*bary[2];\n\n        fragColor = ambientColor;\n    } else\n        // else draw background color (black)\n\t\tfragColor = vec4(0, 0, 0, 1);\n}","name":"Image","description":"","type":"image"}]}