{"ver":"0.1","info":{"id":"ddGBzV","date":"1698398789","viewed":41,"name":"噪音记录","username":"xuxianbo","description":"测试噪音","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["voronoinoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==============hash库==============\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash2to1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash3to1(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash1to2(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash21(vec2 p){\n    float h = dot(p,vec2(127.1,311.7));    \n    return -1.0 + 2.0 * fract(sin(h)*43758.5453123);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nvec2 hash3to2(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash1to3(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hash2to3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec4 hash1to4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hash2to4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hash3to4(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//==============White Noise白噪声==============\n//xy先点乘不同的数，正弦函数外乘上一个大数再取小数\n//作用：给frag的每个像素生成各自不同的随机数\n//特点：均匀分布\n\nfloat random(vec2 st) \n{\n  return fract(\n    sin(\n      dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n\n//==============Value Noise值噪声==============\n//将一个二维平面分成n*n个小晶格，对每个晶格上的4个顶点分别生成一个[0,1]随机数；\n//4个顶点内的每个片元根据他们的uv用一个新的smoothstep进行二维插值\nfloat value_noise(vec2 p){\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;//相当于fract\n\t\n    //一个类似smoothstep的函数，叫Hermit插值函数，也叫S曲线：S(x) = -2 x^3 + 3 x^2\n    //利用Hermit插值特性：可以在保证函数输出的基础上保证插值函数的导数在插值点上为0，这样就提供了平滑性\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x),\n               mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\n//====================Wave Noise========================\n\nvec2 g( vec2 n ) { return sin(n.x*n.y*vec2(12,17)+vec2(1,2)); }\nfloat WaveNoise(vec2 p)\n{\n    const float kF = 2.0;  // make 6 to see worms\n    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(kF*dot(p,g(i+vec2(0,0)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(sin(kF*dot(p,g(i+vec2(0,1)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\n\n//===================Gradient Noise梯度噪声================\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\n//范围[-1,1]，所以返回值一般需要*0.5+0.5\nfloat GradientNoise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//============普通Perlin Noise，属于梯度噪声============\n\nfloat perlin_noise(vec2 p){\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    //一个类似smoothstep的函数，叫Hermit插值函数，也叫S曲线：S(x) = -2 x^3 + 3 x^2\n    //利用Hermit插值特性：可以在保证函数输出的基础上保证插值函数的导数在插值点上为0，这样就提供了平滑性\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n                   dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n                   dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\n\n\nfloat simplexNoise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    //将输入点进行坐标偏移，向下取整得到原点，转换到超立方体空间\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    //得到转换前输入点到原点距离向量（单形空间下）\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    //确定顶点在哪个三角形内\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    //得到转换前输入点到第二个顶点的距离向量\n    vec2 b = a - o + K2;\n    //得到转换前输入点到第三个顶点的距离向量\n    vec2 c = a - 1.0 + 2.0 * K2;\n    //根据权重计算每个顶点的贡献度\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n    //乘以系数，做归一化处理\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//======================================\n//    Simplex 3D Noise \n//    by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n//=========普通fbm 分形噪声===================\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += simplexNoise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n//============ Voronoi噪声======================\n\nfloat N21(vec2 p)\n{\n \treturn fract(cos(p.x*89.42-p.y*75.7)*343.42);\n}\nvec2 N22(vec2 p)\n{\n \treturn fract(cos(p*mat2(89.4,-75.7,-81.9,79.6))*343.42); \n}\nfloat voronoi(vec2 coord,float s)\n{\n    float col = 0.0;\n    float maxdis = 2.0;\n    for(int x = -1;x<=1;x++)\n        for(int y = -1;y<=1;y++)\n        {\n            vec2 id = floor(coord/s)+vec2(x,y);\n            float d = length(N22(id)+vec2(x,y)-fract(coord/s));\n            if (d<maxdis)\n            {\n                maxdis = d;\n                //col = N21(id);\n                col = d;\n            }\n        }\n    return col;\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // hash库\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float value=0.;\n    \n    \n    value =hash11(uv.x);\n    fragColor = vec4( vec3(value), 1.0 );\n    \n    \n    value = hash2to1(uv);\n    fragColor = vec4( vec3(value), 1.0 );\n\n\n    value = hash3to1( vec3( uv, 1.) );\n    fragColor = vec4( vec3(value), 1.0 );\n\n\n    vec2 valueVec2 = hash1to2(  uv.x  );\n    fragColor = vec4( vec3(valueVec2,1.), 1.0 );\n    //fragColor = vec4( vec3(valueVec2.y), 1.0 );\n\n\n    valueVec2 =hash22(uv);\n    fragColor = vec4( vec3(valueVec2,1.), 1.0 );\n\n    //一维正弦Noise\n    float y = fract(sin(uv.x)*100000.0);\n    fragColor = vec4( vec3(y), 1.0 );\n    \n    // White Noise白噪声\n    value=random(uv);\n    fragColor = vec4( vec3(value), 1.0 );\n    \n    value=hash21(uv);\n    fragColor = vec4( vec3(value), 1.0 );\n\n    value=value_noise(uv)*0.5+0.5;\n    fragColor = vec4( vec3(value), 1.0 );\n    \n    //uv.x+= iTime/10.;\n    value=WaveNoise(uv);\n    fragColor = vec4( vec3(value), 1.0 );\n    \n\n    value=GradientNoise(uv)*0.5+0.5;\n    fragColor = vec4( vec3(value), 1.0 );\n\n\n    value=perlin_noise(uv)*0.5+0.5;\n    fragColor = vec4( vec3(value), 1.0 );\n\n\n    value=simplexNoise(uv);\n    fragColor = vec4( vec3(value), 1.0 );\n\n    value=fbm(uv)*0.5+0.5;\n    fragColor = vec4( vec3(value), 1.0 );\n\n    value=snoise(vec3(uv,1));\n    fragColor = vec4(vec3(value),1.0);\n\n    \n    vec2 tempUV =fragCoord.xy;\n    fragColor = vec4(vec3(voronoi(tempUV,36.0)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}