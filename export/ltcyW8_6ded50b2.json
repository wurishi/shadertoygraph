{"ver":"0.1","info":{"id":"ltcyW8","date":"1532373967","viewed":546,"name":"Dancing Shadow","username":"lgabriel13","description":"Lately, I've been playing with the concept of noise, trying to create a flow effect for a \"static\" water and decided to add a moving circle (the \"shadow\") above it. So, that's how this shader has been created.\n\nHope you like it and thank you.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","distortion","animation","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Random function\nfloat Hash (vec2 p)\n{\n\treturn fract (sin (dot (p, vec2 (12.56, 167.89))) * 6750.21);\n}\n\n//Simple noise\nfloat Noise (vec2 p)\n{\n   \tvec2 lv = fract (p);\n    vec2 index = floor (p);\n    \n    vec2 sm = 6.0 * lv * lv * lv * lv * lv -\n       \t 15.0 * lv * lv * lv * lv + \n         10.0 * lv * lv * lv; //smooth function\n    \n    float bl = Hash (index);\n    float br = Hash (index + vec2 (1.0, 0.0));\n    float b = mix (bl, br, sm.x);\n    float tl = Hash (index + vec2 (0.0, 1.0));\n    float tr = Hash (index + vec2 (1.0, 1.0));\n    float t = mix (tl, tr, sm.x);\n    \n    return mix (b, t, sm.y);   \n}\n\n//Fractal Brownian Motion\nfloat FBM (vec2 p)\n{\n    const int OCTAVES = 6;\n    \n    float result = 0.0;\n    float m = 0.0;\n    \n    float amplitude = 1.0;\n    float freq = 1.0;\n    \n    for (int i=0; i<6; i++)\n    {\n        result += Noise (p * freq) * amplitude;\n        m += amplitude;\n        amplitude *= 0.5; //lacunarity\n        freq *= 2.0; //gain\n    }\n    \n    return result/m;\n}\n\n//Distort the domain.\n//f(p) = fbm( p + fbm( p + fbm( p ) ) )\n//IQ Domain Wraping\n//https://iquilezles.org/articles/warp\nfloat DistortDomain (vec2 p, out vec2 fDstr, out vec2 sDstr)\n{\n\tfDstr = vec2 (\n    \tFBM (p + vec2 (.5, 0.3)),\n        FBM (p + vec2 (2.2, 0.1)  * iTime * 0.03)\n    );\n             \n    sDstr = vec2 (\n        FBM (p + 5.0 * fDstr + vec2 (2.5, 0.2)  * iTime * 0.1),\n        FBM (p + 5.0 * fDstr + vec2 (-0.2, .3)  * iTime * 0.5)\n    );\n             \n   \treturn FBM (p + 5.0 * sDstr);\n}\n\n//Draw a circle with a radius/thickness based on a noise\nfloat DrawCircle (vec2 uv, vec2 pos, float r, out vec2 fDstr, out vec2 sDstr)\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x *= aspectRatio;\n    pos.x *= aspectRatio;\n    \n    float noise = DistortDomain (uv, fDstr, sDstr);\n    \n    pos += vec2 (cos(iTime) * .75, sin(iTime) * .3);\n    r += sin (noise * r * 1.2);\n    float d = distance (uv, pos);\n    \n    //Apply a smoothstep\n    float circle = smoothstep (r * noise - 0.15, r * noise, d);\n    return circle * noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 fDistortion;\n    vec2 sDistortion;\n   \t\n    \n    float noise = DrawCircle (uv, vec2 (0.5, 0.5), 0.5, fDistortion, sDistortion);\n    \n    vec3 col1 = mix(vec3(0.11,0.3,0.3),\n                \tvec3(0.23,0.90,0.07),\n                \tclamp((noise*noise)*5.0,0.0,1.0));\n    \n    vec3 col2 =  mix(col1,\n                \t vec3(0.35,0.34,0.87),\n                \t clamp(length(fDistortion),0.0,1.0));\n    \n    vec3 col3 = mix (col2, \n                     vec3 (0.21, 0.63, 0.7),\n                     clamp (length (sDistortion.x), 0.0, 1.0));\n    \n    \n    //Gamma\n    fragColor = pow (vec4((noise * noise * (3.0 - 2.0 * noise)) * col3, 1.), vec4 (1./2.2));            \n}","name":"Image","description":"","type":"image"}]}