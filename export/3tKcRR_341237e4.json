{"ver":"0.1","info":{"id":"3tKcRR","date":"1610334121","viewed":268,"name":"gamma bit loss","username":"Carandiru","description":"Visualization of loss of effectively bits without gamma correction.\nEach step in gradient represents the highest bit (left) to lowest bit (right)\nBuffer A provides color in packed form. I was trying to use floatBitsToUint / uintBitsToFloat .... ","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["gradient","gamma","pow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float packed = texture(iChannel0, uv).r;\n    \n    vec3 color = unpackColor(packed);\n\n    uvec3 ucolor = uvec3(color * 65535.0f);\n    \n    ucolor = ucolor >> uint(uv.x * 15.0);\n    \n    color = vec3(ucolor) / 65535.0f;\n    \n    bool bGamma = bool(mod(iTime, 4.0f) < 2.0f);\n    \n    // text overlay //\n    const float ROW_START = 0.6f;\n\tconst float SPACING = 0.025f;\n\t// Set a general character size...\n    vec2 charSize = vec2(.05, .07) * 0.5f;\n    // and a starting position.\n    vec2 charPos = vec2(ROW_START, 0.96f);\n    // Draw some text!\n    float chr = 0.0;\n\n    uv.y = 1.0f - uv.y; // cause I like it upside down\n    \n    if (bGamma) { //correction applied\n        color = pow(color, vec3(1.0f/2.2f));\n        \n        chr += drawChar( CH_G, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_C, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_C, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += SPACING;\n       \n    }\n    else {\n    \n        charPos.x -= charSize.x * 3.0f;\n        \n        chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += SPACING;\n        \n        chr += drawChar( CH_G, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_C, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_C, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += SPACING;\n        chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += SPACING;\n        \n        //charPos.x += .15;\n        //chr += drawFixed( fract(iTime), 3, charPos, charSize, uv);\n        \n    }\n    color += vec3(chr);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tT = fract(iTime);\n    \n    if (uv.y < 0.333f)\n        color.b = tT;\n    else if (uv.y < 0.666f)\n        color.g = tT;\n    else\n        color.r = tT;\n\n    fragColor = vec4(packColor(color),0.0,0.0,0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\nvec3 unpackColor(in float fetched) {\n\t\n\tuint color_in = uint(fetched);  // how come floatBitsToUint doesn't work here?\n\n\tuvec3 color_out;\n\t// SHADER sees     A B G R\t\t\t(RGBA in reverse) \n\tcolor_out.r = (color_in >> 16u) & 0xFFu;\n\tcolor_out.g = (color_in >> 8u) & 0xFFu;\n\tcolor_out.b = (color_in) & 0xFFu;\n\t\n\treturn(vec3(color_out) * (1.0f/255.0f));\n}\n\nfloat packColor(in vec3 pushed) {\n\t\n\tuvec3 color_in = uvec3(pushed * 255.0f);\n\n\t// SHADER sees     A B G R\t\t\t(RGBA in reverse) \n\tuint color_out = (color_in.r << 16u) | (color_in.g << 8u) | (color_in.b);\n\t\n\treturn(float(color_out)); // how come uintBitsToFloat doesn't work here?\n}\n\n\n\n\n\n// Shader Text Library https://www.shadertoy.com/view/4dtGD2\n\n// usage:\n\n/*\n  // Set a general character size...\n    vec2 charSize = vec2(.03, .0375);\n    // and a starting position.\n    vec2 charPos = vec2(0.05, 0.90);\n    // Draw some text!\n    float chr = 0.0;\n// Shader uptime:\n    charPos = vec2(0.05, .6);\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_G, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_L, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_B, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_L, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_COLN, charPos, charSize, uv); charPos.x += .04;\n    // The uptime itself.\n    charPos.x += .3;\n    chr += drawFixed( iTime, 2, charPos, charSize, uv);\n\n\toutColor = vec4(chr.xxx, 1.0f);\n*/\n\n// Each character is a 4x5 bitmap encoded into a float, where each hex digit convieniently\n// represents one row.\n// License: Creative Commons CC0 1.0 Universal (CC-0) \n\n#define _f float\nconst _f      CH_A    = _f(0x69f99), CH_B    = _f(0x79797), CH_C    = _f(0xe111e),\n       \t  \t  CH_D    = _f(0x79997), CH_E    = _f(0xf171f), CH_F    = _f(0xf1711),\n\t\t  \t  CH_G    = _f(0xe1d96), CH_H    = _f(0x99f99), CH_I    = _f(0xf444f),\n\t\t  \t  CH_J    = _f(0x88996), CH_K    = _f(0x95159), CH_L    = _f(0x1111f),\n\t\t  \t  CH_M    = _f(0x9f999), CH_N    = _f(0x9bd99), CH_O    = _f(0x69996),\n\t\t  \t  CH_P    = _f(0x79971), CH_Q    = _f(0x69b5a), CH_R    = _f(0x79759),\n\t\t  \t  CH_S    = _f(0xe1687), CH_T    = _f(0xf4444), CH_U    = _f(0x99996),\n\t\t  \t  CH_V    = _f(0x999a4), CH_W    = _f(0x999f9), CH_X    = _f(0x99699),\n    \t  \t  CH_Y    = _f(0x99e8e), CH_Z    = _f(0xf843f), CH_0    = _f(0x69996),\n\t\t  \t  CH_1    = _f(0x46444), CH_2    = _f(0x6942f), CH_3    = _f(0x69496),\n\t\t  \t  CH_4    = _f(0x99f88), CH_5    = _f(0xf1687), CH_6    = _f(0x61796),\n\t\t  \t  CH_7    = _f(0xf8421), CH_8    = _f(0x69696), CH_9    = _f(0x69e84),\n\t\t  \t  CH_APST = _f(0x66400), CH_PI   = _f(0x0faa9), CH_UNDS = _f(0x0000f),\n\t\t  \t  CH_HYPH = _f(0x00600), CH_TILD = _f(0x0a500), CH_PLUS = _f(0x02720),\n\t\t  \t  CH_EQUL = _f(0x0f0f0), CH_SLSH = _f(0x08421), CH_EXCL = _f(0x33303),\n\t\t  \t  CH_QUES = _f(0x69404), CH_COMM = _f(0x00032), CH_FSTP = _f(0x00002),\n    \t  \t  CH_QUOT = _f(0x55000), CH_BLNK = _f(0x00000), CH_COLN = _f(0x00202),\n\t\t\t  CH_LPAR = _f(0x42224), CH_RPAR = _f(0x24442);\nconst vec2 MAP_SIZE = vec2(4,5);\n#undef flt\n\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\n\n/*\n\tTrades a float for a character bitmap. Here's to eliminating\n\tbranches with step()!\n*/\nfloat floatToChar( in float x )\n{\n    float res = CH_BLNK;\n    res += (step(-.5,x)-step(0.5,x))*CH_0;\n    res += (step(0.5,x)-step(1.5,x))*CH_1;\n    res += (step(1.5,x)-step(2.5,x))*CH_2;\n    res += (step(2.5,x)-step(3.5,x))*CH_3;\n    res += (step(3.5,x)-step(4.5,x))*CH_4;\n    res += (step(4.5,x)-step(5.5,x))*CH_5;\n    res += (step(5.5,x)-step(6.5,x))*CH_6;\n    res += (step(6.5,x)-step(7.5,x))*CH_7;\n    res += (step(7.5,x)-step(8.5,x))*CH_8;\n    res += (step(8.5,x)-step(9.5,x))*CH_9;\n    return res;\n}\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent [0..1] uv coordinate.\n*/\nfloat drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv-=pos;\n    \n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;    \n    \n    // Create a place to store the result.\n    float res;\n    \n    // Branchless bounding box check.\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    \n    // Go ahead and multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= MAP_SIZE;\n    uv.y = MAP_SIZE.y - uv.y;\n\n    // Get the appropriate bit and return it.\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    return clamp(res,0.0,1.0);\n}\n\n/*\n\tPrints a float as an int. Be very careful about overflow.\n\tThis as a side effect will modify the character position,\n\tso that multiple calls to this can be made without worrying\n\tmuch about kerning.\n*/\nfloat drawIntCarriage( in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int places )\n{\n    // Create a place to store the current values.\n    float res = 0.0,digit = 0.0;\n    // Surely it won't be more than 10 chars long, will it?\n    // (MAX_INT is 10 characters)\n    for( int i = 0; i < 10; ++i )\n    {\n        // If we've run out of film, cut!\n        if(val == 0 && i >= places) break;\n        // The current lsd is the difference between the current\n        // value and the value rounded down one place.\n        digit = float( val-(val/10)*10 );\n        // Draw the character. Since there are no overlaps, we don't\n        // need max().\n        res += drawChar(floatToChar(digit),pos,size,uv);\n        // Move the carriage.\n        pos.x -= size.x*1.2;\n        // Truncate away this most recent digit.\n        val /= 10;\n    }\n    return res;\n}\n\n/*\n\tDraws an integer to the screen. No side-effects, but be ever vigilant\n\tso that your cup not overfloweth.\n*/\nfloat drawInt( in int val, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    vec2 p = vec2(pos);\n    float s = sign(float(val));\n    val *= int(s);\n    \n    float c = drawIntCarriage(val,p,size,uv,1);\n    return c + drawChar(CH_HYPH,p,size,uv)*max(0.0, -s);\n}\n\n/*\n\tPrints a fixed point fractional value. Be even more careful about overflowing.\n*/\nfloat drawFixed( in float val, in int places, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    // modf() sure would be nice right about now.\n    vec2 p = vec2(pos);\n    float res = 0.0;\n    \n    // Draw the floating point part.\n    res = drawIntCarriage( int( fract(abs(val))*pow(10.0,float(places)) ), p, size, uv, places );\n    // The decimal is tiny, so we back things up a bit before drawing it.\n    p.x += size.x*.4;\n    res = max(res, drawChar(CH_FSTP,p,size,uv)); p.x-=size.x*1.2;\n    // And after as well.\n    p.x += size.x *.1;\n    // Draw the integer part.\n    res = max(res, drawIntCarriage(int(floor(abs(val))),p,size,uv,1));\n\n\tfloat s = sign(val);\n\treturn max(res, drawChar(CH_HYPH,p,size,uv)*max(0.0, -s));\n}\n","name":"Common","description":"","type":"common"}]}