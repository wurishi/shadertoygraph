{"ver":"0.1","info":{"id":"7ltfW8","date":"1663390832","viewed":328,"name":"disney bsdf bkup","username":"yys_c","description":"re lief\nMaterial parameters are referenced from https://www.shadertoy.com/view/XdyyDd (markusm)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["v2portpurefloatarray"],"hasliked":0,"parentid":"7ldBWr","parentname":"test disney bsdf"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;\nconst float INV_PI = 1.0 / PI;\nconst float INV_TWO_PI = 0.5 * INV_PI;\nconst vec3 background = vec3(0.0);\nconst vec3 X = vec3(1, 0, 0);\nconst vec3 Y = vec3(0, 1, 0);\nconst vec3 Z = vec3(0, 0, 1);\n#define VNDF\n// obj\n#define TRI 0\n#define SPH 1\n#define RECT 2\n#define OBJ_TYPE(x) objectives[x * 2]\n#define OBJ_ID(x) objectives[x * 2 + 1]\n\n// texture\n#define COL 0\n#define IMG 1\n#define TEX_TYPE(x) textures[x * 2]\n#define TEX_ID(x) textures[x * 2 + 1]\n\n// material\n#define LAMBERTIAN 0\n#define BLINN_PHONG 1\n#define OREN_NAYAR 2\n#define DISNEY_DIFFUSE 3\n#define GGX_MICROFACET 4\n#define GGX_MICROFACET_ANISO 5\n#define GGX_GLASS 6\n#define DISNEY_PRINCIPLED 7\n#define EMISSIVE 8\n#define MAT_TYPE(x) materials[x * 2]\n#define MAT_ID(x) materials[x * 2 + 1]\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// counts\nconst int obj_cnt = 9;\nconst int texture_cnt = 7;\nconst int material_cnt = 8;\n\nstruct ray{\n    vec3 A;\n    vec3 B;\n};\n\nstruct record{\n    float t; \n    vec3 normal;\n    vec3 out_normal; // same side with hit ray\n    bool is_back_face;\n    vec3 pos;\n    int mat_id;\n    int obj_id;\n};\n\nstruct triangle{\n    vec3 p0, p1, p2; // right hand\n    vec3 normal; // flat shading\n    //vec3 n0, n1, n2; \n    //vec2 t0, t1, t2\n    int mat_id;\n};\n\nstruct sphere{\n    vec3 o;\n    float r;\n    int mat_id;\n};\n\nstruct rectangle{\n    vec3 p0, p1, p2, p3;\n    vec3 normal;\n    int mat_id;\n};\n\nstruct lambertian{\n    int diffuse_reflectance_id;\n};\n\nstruct oren_nayar{\n    int diffuse_reflectance_id;\n    float roughness;\n    //float sigma;\n};\n\nstruct blinn_phong{\n    int specular_reflectance_id;\n    float roughness;\n};\n\nstruct microfacet_ggx{\n    int specular_reflectance_id; // F0\n    float roughness;\n};\n\nstruct microfacet_ggx_aniso{\n    int specular_reflectance_id; // F0\n    vec2 roughness;\n};\n\nstruct glass_ggx{\n    int base_color_id;\n    float roughness;\n    float anisotropic;\n    float eta; // 外 -> 内\n};\n\nstruct disney_principled{\n    int baseColor_id; // 基本纹理\n    float subsurface; // 次表面散射程度（用于diffuse和次表面散射之间插值）\n    float roughness; \n    float metallic; // 金属度\n    float specular; // 高光度\n    float specularTint; // 高光向基本颜色靠拢的程度\n    float anisotropic; // \n    float sheen; // 模拟边缘明亮效果\n    float sheenTint; \n    float clearcoat; // 额外的高光项，模拟清漆\n    float clearCoatGloss; // 清漆的光滑度\n    float specular_transmission;\n    float eta;\n};\n\nstruct emissive{\n    int emit_color_id;\n    float strength;\n};\n\n// objects\ntriangle triangles[] = triangle[2](\n    triangle(\n        vec3(-1.0,-0.0,-2.0), // p0\n        vec3(1.0,-0.0,-2.0), // p1\n        vec3(0.0,3.0,-2.0), // p2\n        vec3(0, 0, 1), // flat normal\n        1 // mat_id\n    ),\n    triangle(\n        vec3(3,-0.5,-2.0), // p0\n        vec3(3,-0.5,2.0), // p1\n        vec3(3, 2,0.0), // p2\n        vec3(-1, 0, 0), // flat normal\n        2 // mat_id\n    )\n);\n\nsphere spheres[] = sphere[6](\n    sphere(\n        vec3(-1.25, 0.2, 0.0), 0.2, 2\n    ),\n    sphere(\n        vec3(-.75, 0.2, 0.0), 0.2, 3\n    ),\n    sphere(\n        vec3(-.25, 0.2, 0.0), 0.2, 4\n    ),\n    sphere(\n        vec3(.25, 0.2, 0.0), 0.2, 5\n    ),\n    sphere(\n        vec3(.75, 0.2, 0.0), 0.2, 6\n    ),\n    sphere(\n        vec3(1.25, 0.2, 0.0), 0.2, 7\n    )\n);\n\nrectangle rectangles[] = rectangle[3](\n    rectangle(\n        vec3(0.5, 1.2, -0.5),\n        vec3(0.5, 1.2, 0.5),\n        vec3(-0.5, 1.2, 0.5),\n        vec3(-0.5, 1.2, -0.5),\n        vec3(0, -1, 0),\n        0\n    ),\n    rectangle(\n        vec3(-5, 5, -1.5),\n        vec3(-5, -0.1, -1.5),\n        vec3(5, -0.1, -1.5),\n        vec3(5, 5, -1.5),\n        vec3(0, 0, 1),\n        1\n    ),\n    rectangle(\n        vec3(-5, -0.1, -1.5),\n        vec3(-5, -0.1, 5),\n        vec3(5, -0.1, 5),\n        vec3(5, -0.1, -1.5),\n        vec3(0, 1, 0),\n        1\n    )\n    \n);\n\nint objectives[] = int[obj_cnt * 2](\n    RECT, 0,\n    RECT, 1,\n    RECT, 2,\n    SPH, 0,\n    SPH, 1,\n    SPH, 2,\n    SPH, 3,\n    SPH, 4,\n    SPH, 5\n);\n\n// textures\nvec3 constant_colors[] = vec3[7](\n    vec3(.8, .8, .8),\n    vec3(0.815, .00418501512, .00180012),\n    vec3(0.815, .418501512, .00180012),\n    vec3(0.815, .00418501512, .00180012),\n    vec3(0.9, 0.4,0.3),\n    vec3(0.5, .1501512, .80012),\n    vec3(0.025, .2501512, .0180012)\n);\n\nint textures[] = int[texture_cnt * 2](\n    COL, 0,\n    COL, 1,\n    COL, 2,\n    COL, 3,\n    COL, 4,\n    COL, 5,\n    COL, 6\n);\n\n// materials\nlambertian lambertian_array[] = lambertian[4](\n    lambertian(0),\n    lambertian(1),\n    lambertian(2),\n    lambertian(3)\n);\n\nemissive emissive_array[] = emissive[1](\n    emissive(0, 3.)\n);\n\nblinn_phong blinn_phong_array[] = blinn_phong[3](\n    blinn_phong(4, 0.01),\n    blinn_phong(4, 0.05),\n    blinn_phong(4, 0.1)\n);\n\noren_nayar oren_nayar_array[] = oren_nayar[1](\n    oren_nayar(0, 1.0)\n);\n\nmicrofacet_ggx microfacet_ggx_array[] = microfacet_ggx[3](\n    microfacet_ggx(4, 0.01),\n    microfacet_ggx(4, 0.05),\n    microfacet_ggx(4, 0.1)\n);\n\nmicrofacet_ggx_aniso microfacet_ggx_aniso_array[] = microfacet_ggx_aniso[1](\n    microfacet_ggx_aniso(4, vec2(0.3, 0.1))\n);\n\nglass_ggx glass_ggx_array[] = glass_ggx[1](\n    glass_ggx(4, 0.3, 0.1, 1.0 / 2.4)\n);\n\ndisney_principled disney_principled_array[] = disney_principled[6](\n    disney_principled(\n        1, // base color\n        0.0, // subsurface \n        1.0, // roughness\n        0.0, // metallic\n        0.0, // specular\n        0.0, // specularTint\n        0.0, // anisotropic\n        1., // sheen\n        0., // sheenTint\n        0., // clearcoat\n        0.0, // clearCoatGloss\n        0.0, // specular_transmission\n        1. / 1. // eta\n    ),\n    disney_principled(\n        2, // base color\n        0.0, // subsurface \n        0.53, // roughness\n        1.0, // metallic\n        0.0, // specular\n        0.0, // specularTint\n        0.0, // anisotropic\n        1., // sheen\n        0., // sheenTint\n        0., // clearcoat\n        0.0, // clearCoatGloss\n        0.0, // specular_transmission\n        1. / 1. // eta\n    ),\n    disney_principled(\n        3, // base color\n        1.0, // subsurface \n        1.0, // roughness\n        0.0, // metallic\n        0.0, // specular\n        0.0, // specularTint\n        0.0, // anisotropic\n        1., // sheen\n        0., // sheenTint\n        0., // clearcoat\n        0.0, // clearCoatGloss\n        0.0, // specular_transmission\n        1. / 1. // eta\n    ),\n    disney_principled(\n        4, // base color\n        0.0, // subsurface \n        0.9, // roughness\n        1.0, // metallic\n        0.1, // specular\n        0.0, // specularTint\n        1.0, // anisotropic\n        1., // sheen\n        0., // sheenTint\n        0., // clearcoat\n        0.0, // clearCoatGloss\n        0.0, // specular_transmission\n        1. / 1. // eta\n    ),\n    disney_principled(\n        5, // base color\n        0.0, // subsurface \n        0.1, // roughness\n        0.0, // metallic\n        0.1, // specular\n        0.0, // specularTint\n        0.0, // anisotropic\n        1., // sheen\n        0., // sheenTint\n        0., // clearcoat\n        1.0, // clearCoatGloss\n        0.0, // specular_transmission\n        1. / 1. // eta\n    ),\n    disney_principled(\n        6, // base color\n        0.1, // subsurface \n        1.0, // roughness\n        0.0, // metallic\n        0.1, // specular\n        0.0, // specularTint\n        0.0, // anisotropic\n        1., // sheen\n        0., // sheenTint\n        1., // clearcoat\n        1.0, // clearCoatGloss\n        0.0, // specular_transmission\n        1. / 1. // eta\n    ) \n);\n\nint materials[] = int[material_cnt * 2](\n    EMISSIVE, 0,\n    LAMBERTIAN, 0,\n    DISNEY_PRINCIPLED, 0,\n    DISNEY_PRINCIPLED, 1,\n    DISNEY_PRINCIPLED, 2,\n    DISNEY_PRINCIPLED, 3,\n    DISNEY_PRINCIPLED, 4,\n    DISNEY_PRINCIPLED, 5\n);\n\nfloat seed;\n\nfloat rnd() { \n    return fract(sin(seed++)*43758.5453123); \n}\n\nvec3 uniform_hemi(vec2 uv){\n    float z = uv.x;\n    float r = sqrt(max(0.0, 1.0 - z * z));\n    float phi = 2.0 * PI * uv.y;\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nvec2 uniform_disk(vec2 uv){\n    float r = sqrt(uv.x);\n    float theta = 2.0 * PI * uv.y;\n    return r * vec2(cos(theta), sin(theta));\n}\n\nvec3 cosine_hemi(vec2 uv){\n    vec2 uv1 = uniform_disk(uv);\n    float z = sqrt(max(0.0, 1.0 - uv1.x * uv1.x - uv1.y * uv1.y));\n    return vec3(uv1, z);\n}\n\nvec4 qmul(vec4 r, vec4 s){\n    vec4 res;\n    res.x=(r[0]*s[0]-r[1]*s[1]-r[2]*s[2]-r[3]*s[3]);\n    res.y=(r[0]*s[1]+r[1]*s[0]-r[2]*s[3]+r[3]*s[2]);\n    res.z=(r[0]*s[2]+r[1]*s[3]+r[2]*s[0]-r[3]*s[1]);\n    res.w=(r[0]*s[3]-r[1]*s[2]+r[2]*s[1]+r[3]*s[0]);\n    return res;\n}\n\nvec3 rotate_vec(vec3 v, vec3 axis, float theta){\n    vec4 q = vec4(cos(theta * 0.5), sin(theta * 0.5) * axis);\n    vec4 q_inv = vec4(q.x, -q.yzw);\n    vec4 p = vec4(0, v);\n    vec4 res = qmul(qmul(q_inv, p),q);\n    return res.yzw;    \n}\n\nvec3 reoriant(vec3 n1, vec3 n2, vec3 x){\n    //vec3 Y = vec3(0, 1, 0);\n    float dotv = clamp(dot(n1, n2), -1.0, 1.0);\n    float dotv_abs = abs(dotv);\n    if(dotv_abs == 1.0) return dotv * x;\n    vec3 axis = normalize(cross(n1, n2));\n    float theta = acos(dotv);\n    return rotate_vec(x, axis, theta);\n}\n\nvec3 to_gamma(vec3 c){\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec3 to_linear(vec3 c){\n    return pow(c, vec3(2.2));\n}\n\nvec3 at(ray r, float t){\n    return r.A + t * r.B;\n}\n\nfloat sqr(float a){\n    return a * a;\n}\n\nvec3 pick_texture(int x){\n    if(TEX_TYPE(x) == COL) return constant_colors[TEX_ID(x)];\n}\n\nfloat beckmann_alpha_to_phong_shininess(float a){\n    return 2.0 / min(0.9999, max(0.0002, (a * a))) - 2.0;\n}\n\nfloat beckmann_alpha_to_oren_nayar_sigma(float a){\n    return 0.7071067 * atan(a);\n}\n\nfloat ggx_ndf(float a2, float NoH) {\n\tfloat b = ((a2 - 1.0f) * NoH * NoH + 1.0);\n\treturn a2 / (PI * b * b);\n}\nfloat ggx_ndf_aniso(vec2 a, vec3 h){ // in local space\n    float part1 = PI * a.x * a.y;\n    float part2 = pow(h.x / a.x, 2.) + pow(h.y / a.y, 2.) + h.z;\n    return 1. / (part1 * part2 * part2);\n}\nfloat smith_shadowing_g1(float a2, float NoX) {\n    NoX = max(NoX, 0.0001);\n    float NoX2 = max(NoX * NoX, 0.0001);\n\treturn 2.0 * NoX / (sqrt(a2 * (1.0 - NoX2) + NoX2) + NoX);\n}\nfloat smith_shadowing_g1_aniso(vec2 a, vec3 x){ // local space\n    float b = sqrt(\n        1. + (sqr(a.x * x.x) + sqr(a.y * x.y)) / sqr(x.z)\n    );\n    return 2. / (1. + b);\n}\nfloat fresnel_schlick(float VoH){\n    float t = 1.0 - VoH;\n    float p5 = t * t;\n    p5 *= p5 * t;\n\treturn p5;\n}\nfloat vndf_wi_pdf(float a, float NoH, float VoH) {\n\tNoH = max(0.00001, NoH);\n\tVoH = max(0.00001, VoH);\n    float a2 = max(0.00001, a * a);\n\treturn (ggx_ndf(a2, NoH) * smith_shadowing_g1(a2, VoH)) / (4.0 * VoH);\n}\nfloat vndf_wi_pdf_aniso(vec2 a, vec3 h_local, vec3 v_local) {\n    float VoH = dot(v_local, h_local);\n\treturn (ggx_ndf_aniso(a, h_local) * smith_shadowing_g1_aniso(a, v_local)) / (4.0 * VoH);\n}\nvec3 sample_ggx_vndf(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2){\n\tvec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\tvec3 T1 = lensq > 0. ? vec3(-Vh.y, Vh.x, 0.) * inversesqrt(lensq) : vec3(1,0,0);\n\tvec3 T2 = cross(Vh, T1);\n\tfloat r = sqrt(U1);\n\tfloat phi = 2.0 * PI * U2;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = 0.5 * (1.0 + Vh.z);\n\tt2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\tvec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2))*Vh;\n\tvec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0, Nh.z)));\n\treturn Ne;\n}\nvec3 sample_ggx_importance(vec2 uv, float a2){ // sample isotropic H\n    float cosine_theta = sqrt(max(\n        (1. - uv.x) /\n        (uv.x * (a2 - 1.) + 1.)\n    , 0.0001));\n    float sine_theta = sqrt(max(1. - cosine_theta * cosine_theta, 0.0001));\n    float phi = TWO_PI * uv.y;\n    return vec3(sine_theta * cos(phi), sine_theta * sin(phi), cosine_theta);\n}\n\nvec3 sample_ggx_importance_aniso(vec2 uv, vec2 a){\n    float phi = 0.0;\n    if(uv.x < 0.25) phi = atan(a.y / a.x * tan(TWO_PI * uv.x));\n    else if(uv.x == 0.25 || uv.x == 0.75) phi = 0.5 * PI;\n    else if(uv.x > 0.25 && uv.x < 0.75) phi = atan(a.y / a.x * tan(TWO_PI * uv.x)) + PI;\n    else if(uv.x > 0.75) phi = atan(a.y / a.x * tan(TWO_PI * uv.x)) + TWO_PI;\n    //return vec3(phi / TWO_PI);\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    float inner = uv.y / \n        ((1. - uv.y) * (sqr(cos_phi / a.x) + sqr(sin_phi / a.y)));\n    float theta = atan(sqrt(max(inner, 0.0001)));\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    return vec3(sin_theta * cos_phi, sin_theta * sin_phi, cos_theta);\n}\n\n// ray tracing\nvoid intersect_triangle(ray r, triangle tri, out bool valid, out record rec){\n    const float EPS = 0.000001;\n    vec3 p0 = tri.p0, p1 = tri.p1, p2 = tri.p2;\n    vec3 B = r.B;\n    vec3 A = r.A;\n    vec3 E1 = p1 - p0;\n    vec3 E2 = p2 - p0;\n    vec3 S = A - p0;\n    vec3 S1 = cross(B,E2);\n    vec3 S2 = cross(S,E1);\n    float t = dot(S2,E2) / dot(S1,E1);\n    float b1 = dot(S1,S) / dot(S1,E1);\n    float b2 = dot(S2,B) / dot(S1, E1);\n    if (t < EPS || b1 < EPS || b2 < EPS || b1 + b2 - 1.0 > EPS) return;\n    valid = true;\n    rec.t = t;\n    rec.pos = at(r, rec.t);\n    rec.normal = tri.normal;\n    rec.out_normal = rec.normal;\n    rec.is_back_face = false;\n    if(dot(-r.B, rec.normal) < 0.){\n        rec.out_normal *= -1.;\n        rec.is_back_face = true;\n    }\n    rec.mat_id = tri.mat_id;\n}\n\nbool solve_quadratic(float A, float B, float C, out float t0, out float t1){\n    float discrim = B*B-4.0*A*C;\n    if ( discrim < 0.0 )\n            return false;\n    float rootDiscrim = sqrt(discrim);\n    float Q = (B > 0.0) ? -0.5 * (B + rootDiscrim) : -0.5 * (B - rootDiscrim); \n    float t_0 = Q / A; \n    float t_1 = C / Q;\n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    return true;\n}\n\nvoid intersect_sphere(ray r, sphere sph, out bool valid, out record rec){\n    const float EPS = 0.0001;\n\tfloat t0, t1, t = -1.0;\n\tvec3 L = r.A - sph.o;\n\tfloat a = dot(r.B, r.B);\n\tfloat b = 2.0 * dot(r.B, L);\n\tfloat c = dot(L, L) - (sph.r * sph.r);\n\tif (!solve_quadratic(a, b, c, t0, t1)) return;\n\tif (t1 > EPS)\n        t = t1;\n\tif (t0 >= EPS)\n\t\tt = t0;\n    if(t != -1.){\n        valid = true;\n        rec.t = t;\n        rec.pos = at(r, rec.t);\n        rec.normal = normalize(rec.pos - sph.o);\n        rec.out_normal = rec.normal;\n        rec.is_back_face = false;\n        if(dot(-r.B, rec.normal) < 0.){\n            rec.out_normal *= -1.;\n            rec.is_back_face = true;\n        }\n        rec.mat_id = sph.mat_id;\n    }\n}\n\nvoid intersect_rectangle(ray r, rectangle rect, out bool valid, out record rec){\n    triangle tri1 = triangle(\n        rect.p0, rect.p1, rect.p2,\n        rect.normal,\n        rect.mat_id\n    );\n    triangle tri2 = triangle(\n        rect.p0, rect.p2, rect.p3,\n        rect.normal,\n        rect.mat_id\n    );\n    intersect_triangle(r, tri1, valid, rec);\n    if(valid) return;\n    intersect_triangle(r, tri2, valid, rec);\n}\n\nvoid intersect(ray r, int i, out bool valid, out record rec){\n    int type = OBJ_TYPE(i);\n    int id = OBJ_ID(i);\n    if(type == TRI)\n        intersect_triangle(r, triangles[id], valid, rec);\n    else if(type == SPH)\n        intersect_sphere(r, spheres[id], valid, rec);\n    else if(type == RECT)\n        intersect_rectangle(r, rectangles[id], valid, rec);\n}\n\nvoid hit(ray r, out record rec, out bool valid){\n    float minv = 0.0001, maxv = 1e18;\n    valid = false;\n    for(int i = 0; i < obj_cnt; i ++){\n        bool flag = false;\n        record temp;\n        intersect(r, i, flag, temp);\n        if(flag && temp.t >= minv && temp.t <= maxv){\n            temp.obj_id = i;\n            rec = temp;\n            maxv = rec.t;\n            valid = true;\n        }\n    }\n}\n\nvec3 sample_phong(vec2 u, float shininess){\n\tfloat cosine = pow(1.0f - u.x, 1.0f / (1.0f + shininess)); // cosine value between r and v\n\tfloat sine = sqrt(1.0f - cosine * cosine);\n\tfloat phi = TWO_PI * u.y;\n\treturn vec3(cos(phi) * sine, sin(phi) * sine, cosine);\n}\n\nvec3 sample_disney_clearcoat(vec2 uv, float a){\n    float cos_theta = sqrt(\n        (1. - pow(a * a, 1. - uv.x)) / (1. - a * a)\n    );\n    float phi = TWO_PI * uv.y;\n    float sin_theta = sqrt(1. - cos_theta * cos_theta);\n    return vec3(sin_theta * cos(phi), sin_theta * sin(phi), cos_theta);\n}\n\nfloat GTR1(float NdotH, float a)\n{\n    if (a >= 1.) return 1./PI;\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return (a2-1.) / (PI*log(a2)*t);\n}\n\nfloat fresnel(float VoH, float LoH, float eta){\n    float Rs = (VoH - eta * LoH) / (VoH + eta * LoH);\n    float Rp = (eta * VoH - LoH) / (eta * VoH + LoH);\n    return 0.5 * (Rs * Rs + Rp * Rp);\n}\n\nbool same_hemi(const in vec3 a, const in vec3 b){\n    return a.z > 0.0 && b.z > 0.0;\n}\n\nbool sample_brdf(out vec3 wi, out vec3 weight, const in vec3 wo, record rec){\n    int type = MAT_TYPE(rec.mat_id);\n    int id = MAT_ID(rec.mat_id);\n    vec3 n = rec.out_normal;\n    vec3 wo_local = reoriant(n, Z, wo);\n    if(type == LAMBERTIAN){ // cosine weighed sample\n        vec3 wi_local = cosine_hemi(vec2(rnd(), rnd()));\n        if(!same_hemi(wi_local, wo_local)) return false;\n        weight = pick_texture(lambertian_array[id].diffuse_reflectance_id);\n        wi = reoriant(Z, n, wi_local);\n    }else if(type == OREN_NAYAR){\n        vec3 wi_local = cosine_hemi(vec2(rnd(), rnd()));\n        if(!same_hemi(wi_local, wo_local)) return false;\n        vec3 diffuse_reflectance = pick_texture(oren_nayar_array[id].diffuse_reflectance_id);\n        float sigma = beckmann_alpha_to_oren_nayar_sigma(oren_nayar_array[id].roughness);\n        float NoL = dot(n, wi);\n        float NoV = dot(n, wo);\n        float theta_l = acos(NoL);\n        float theta_v = acos(NoV);\n        float alpha = max(theta_l, theta_v);\n        float beta = min(theta_l, theta_v);\n        vec3 v = normalize(wo - NoV * n);\n        vec3 l = normalize(wi - NoL * n);\n        float cosine_diff = max(0., dot(v, l));\n        float sigma2 = sigma * sigma;\n        float A = 1.0 - 0.5 * (sigma2 / (sigma2 + 0.33));\n        float B = 0.45 * (sigma2 / (sigma2 + 0.09));\n        weight = diffuse_reflectance * \n               (A + B * cosine_diff * sin(alpha) * tan(beta));\n        wi = reoriant(Z, n, wi_local);\n    }else if(type == BLINN_PHONG){\n        vec3 specular_reflectance = pick_texture(blinn_phong_array[id].specular_reflectance_id);\n        float shininess = \n            beckmann_alpha_to_phong_shininess(blinn_phong_array[id].roughness);\n        vec3 reflect_dir = reflect(-wo, n);\n        vec3 wi_local = sample_phong(vec2(rnd(), rnd()), shininess);\n        if(!same_hemi(wi_local, wo_local)) return false;\n        weight = max(vec3(0.0f, 0.0f, 0.0f), specular_reflectance * dot(wi, n));\n        wi = reoriant(Z, reflect_dir, wi_local);\n    }else if(type == GGX_MICROFACET){\n        float a = microfacet_ggx_array[id].roughness;\n        vec3 specular_reflectance = pick_texture(microfacet_ggx_array[id].specular_reflectance_id);\n        float a2 = a * a;\n#ifdef VNDF\n        vec3 h_local = sample_ggx_vndf(wo_local, a, a, rnd(), rnd());\n        vec3 wi_local = reflect(-wo_local, h_local);\n        if(!same_hemi(wi_local, wo_local)) return false;\n        float VoH = saturate(dot(wo_local, h_local));\n        float NoH = saturate(h_local.z);\n        float NoL = saturate(wi_local.z);\n        vec3 F = mix(specular_reflectance, vec3(1.0), fresnel_schlick(VoH));\n        float D = ggx_ndf(a2, NoH);\n        float G1 = smith_shadowing_g1(a2, NoL);\n        weight = G1 * F;\n        wi = reoriant(Z, n, wi_local);\n#else\n        vec3 h_local = sample_ggx_importance(vec2(rnd(), rnd()), a2);\n        vec3 wi_local = reflect(-wo_local, h_local);\n        if(!same_hemi(wi_local, wo_local)) return false;\n        float VoH = saturate(dot(wo_local, h_local));\n        float NoH = saturate(h_local.z);\n        float NoL = saturate(wi_local.z);\n        float NoV = saturate(wo_local.z);\n        vec3 F = mix(specular_reflectance, vec3(1.0), fresnel_schlick(VoH));\n        float G2 = smith_shadowing_g1(a2, NoL) * smith_shadowing_g1(a2, NoV);\n        if(NoH == 0.0 || NoV == 0.0) weight = vec3(0); \n        else weight = G2 * F * VoH / (NoV * NoH);\n        wi = reoriant(Z, n, wi_local);\n#endif\n    }else if(type == GGX_MICROFACET_ANISO){\n        vec2 a = microfacet_ggx_aniso_array[id].roughness;\n        vec3 specular_reflectance = pick_texture(microfacet_ggx_aniso_array[id].specular_reflectance_id);\n#ifdef VNDF\n        vec3 h_local = sample_ggx_vndf(wo_local, a.x, a.y, rnd(), rnd());\n        vec3 wi_local = reflect(-wo_local, h_local);\n        if(!same_hemi(wi_local, wo_local)) return false;\n        float VoH = saturate(dot(wo_local, h_local));\n        vec3 F = mix(specular_reflectance, vec3(1.0), fresnel_schlick(VoH));\n        float D = ggx_ndf_aniso(a, h_local);\n        float G1 = smith_shadowing_g1_aniso(a, wi_local);\n        weight = G1 * F;\n        wi = reoriant(Z, n, wi_local);\n#else\n        vec3 h_local = sample_ggx_importance_aniso(vec2(rnd(), rnd()), a);\n        vec3 wi_local = reflect(-wo_local, h_local);\n        if(!same_hemi(wi_local, wo_local)) return false;\n        float VoH = saturate(dot(wo_local, h_local));\n        float NoH = saturate(h_local.z);\n        float NoL = saturate(wi_local.z);\n        float NoV = saturate(wo_local.z);\n        vec3 F = mix(specular_reflectance, vec3(1.0), fresnel_schlick(VoH));\n        float G2 = smith_shadowing_g1_aniso(a, wi_local) * smith_shadowing_g1_aniso(a, wo_local);\n        if(NoH <= 0.0 || NoV <= 0.0) weight = vec3(0);\n        else weight = G2 * F * VoH / (NoH * NoV);\n        wi = reoriant(Z, n, wi_local);\n#endif\n    }else if(type == GGX_GLASS){\n        vec3 base_color = pick_texture(glass_ggx_array[id].base_color_id);\n        float roughness = glass_ggx_array[id].roughness;\n        float roughness2 = roughness * roughness;\n        float eta = glass_ggx_array[id].eta;\n        float anisotropic = glass_ggx_array[id].anisotropic;\n        float aspect = sqrt(1. - .9 * anisotropic);\n        float ax = max(0.0001, roughness2 / aspect);\n        float ay = max(0.0001, roughness2 * aspect);\n        vec3 wo_local = reoriant(n, Z, wo); \n        // 普通采样ggx aniso 分布函数\n        // vec3 h_local = sample_ggx_importance_aniso(vec2(rnd(), rnd()), vec2(ax, ay));\n        // vndf采样 ggx aniso 分布函数\n        vec3 h_local = sample_ggx_vndf(wo_local, ax, ay, rnd(), rnd());\n        float VoH = abs(dot(wo_local, h_local));\n        float NoH = saturate(h_local.z);\n        float NoV = saturate(wo_local.z);\n        float F = fresnel_schlick(VoH);\n        if(rec.is_back_face) eta = 1.0 / eta;\n        vec3 wi_local = refract(-wo_local, h_local, eta);\n        if(F > rnd() || wi_local == vec3(0)){ // \n            wi_local = reflect(-wo_local, h_local);\n            if(!same_hemi(wi_local, wo_local)) return false;\n            /*\n            float NoL = saturate(wi_local.z);\n            float G2 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_local) * smith_shadowing_g1_aniso(vec2(ax, ay), wo_local);\n            if(NoH <= 0.0 || NoV <= 0.0) weight = vec3(0);\n            else weight = G2 * base_color * VoH / (NoH * NoV);\n            */\n            float G1 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_local);\n            weight = G1 * base_color;\n            wi = reoriant(Z, n, wi_local);\n        }else{\n            /*\n            float G2 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_local) * smith_shadowing_g1_aniso(vec2(ax, ay), wo_local);\n            float LoH = dot(wi_local, -h_local);\n            if(NoH <= 0.0 || NoV <= 0.0) weight = vec3(0);\n            else weight = G2 * sqrt(base_color) * LoH / (NoH * NoV);\n            */\n            if(!same_hemi(wi_local, -wo_local)) return false;\n            float G1 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_local);\n            weight = G1 * sqrt(base_color);\n            wi = reoriant(Z, n, wi_local);\n        }\n    }else if(type == DISNEY_PRINCIPLED){\n        // 依概率分别采样\n        disney_principled m = disney_principled_array[id];\n        vec3 base_color = pick_texture(m.baseColor_id);\n        float roughness = m.roughness;\n        float roughness2 = roughness * roughness;\n        float subsurface = m.subsurface;\n        float anisotropic = m.anisotropic;\n        float sheenTint = m.sheenTint;\n        float specular = m.specular;\n        float specularTint = m.specularTint;\n        float metallic = m.metallic;\n        float aspect = sqrt(1. - .9 * anisotropic);\n        float ax = max(0.0001, roughness2 / aspect);\n        float ay = max(0.0001, roughness2 * aspect);\n        float eta = rec.is_back_face ? 1.0 / m.eta : m.eta;\n        float clearcoat = m.clearcoat;\n        float clearCoatGloss = m.clearCoatGloss;\n        float specular_transmission = m.specular_transmission;\n        float ag = (1. - clearCoatGloss) * 0.1 + clearCoatGloss * 0.001;\n        vec3 wo_local = reoriant(n, Z, wo);\n        float lum = .3*base_color.x + .6*base_color.y  + .1*base_color.z;\n        vec3 c_tint = base_color / (lum <= 0.0 ? 1. : lum);\n        /*\n            // diffuse sample\n            wi = reoriant(Z, n, cosine_hemi(vec2(rnd(), rnd())));\n            float NoL = dot(n, wi);\n            float NoV = dot(n, wo);\n            vec3 h = normalize(wi + wo);\n            float LoH = dot(wi, h);\n            float FL = fresnel_schlick(NoL), FV = fresnel_schlick(NoV);\n            float Fd90 = 0.5 + 2. * LoH*LoH * roughness;\n            float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n            float Fss90 = LoH*LoH*roughness;\n            float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n            float ss = 1.25 * (Fss * (1. / (NoL + NoV) - .5) + .5);\n            weight = base_color * mix(Fd, ss, subsurface);\n        */\n        /*\n            // metal sample\n            vec3 v_local = reoriant(n, Z, wo);\n            vec3 h = reoriant(Z, n, sample_ggx_vndf(v_local, ax, ay, rnd(), rnd()));\n            wi = reflect(-wo, h);\n            vec3 h_local = reoriant(n, Z, h);\n            vec3 l_local = reoriant(n, Z, wi);\n            float VoH = dot(wo, h);\n            vec3 F = mix(base_color, vec3(1.0), fresnel_schlick(VoH));\n            float D = ggx_ndf_aniso(vec2(ax, ay), h_local);\n            float G1 = smith_shadowing_g1_aniso(vec2(ax, ay), l_local);\n            weight = G1 * F;\n        */\n        /*\n            // clearcoat sample\n            vec3 h_local = sample_disney_clearcoat(vec2(rnd(), rnd()), ag);\n            vec3 wi_local = reflect(-wo_local, h_local);\n            float VoH = saturate(dot(wo_local, h_local));\n            float NoH = saturate(h_local.z);\n            float NoV = saturate(wo_local.z);\n            float NoL = saturate(wi_local.z);\n            float Dr = GTR1(NoH, mix(.1,.001,clearCoatGloss));\n            float Fr = mix(.04, 1.0, fresnel_schlick(VoH));\n            float Gr = smith_shadowing_g1(.625, NoL) * smith_shadowing_g1(.625, NoV);\n            if(NoV <= 0. || NoH <= 0.) weight = vec3(0);\n            else weight = vec3(Fr * Gr * VoH / (NoH * NoV)); // Fr * Gr * VoH / (v_local.z * h_local.z)\n            wi = reoriant(Z, n, wi_local);\n        */\n        /*\n            if(rec.is_back_face) eta = 1.0 / eta;\n             // glass\n            vec3 h_local = sample_ggx_importance_aniso(vec2(rnd(), rnd()), vec2(ax, ay));\n            float VoH = abs(dot(wo_local, h_local));\n            float NoH = abs(h_local.z);\n            float NoV = abs(wo_local.z);\n            vec3 wi_refract = refract(-wo_local, h_local, eta);\n            vec3 wi_reflect = reflect(-wo_local, h_local);\n            float reflect_prob = fresnel(VoH, dot(wi_reflect, h_local), eta);\n\n            if(reflect_prob > rnd() || wi_refract == vec3(0)){ //\n                float G2 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_reflect) * smith_shadowing_g1_aniso(vec2(ax, ay), wo_local);\n                weight = G2 * base_color * VoH / max(NoH * NoV, 0.0001);\n                wi = reoriant(Z, n, wi_reflect);\n            }else{\n                float G2 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_refract) * smith_shadowing_g1_aniso(vec2(ax, ay), wo_local);\n                float LoH = saturate(dot(wi_refract, -h_local));\n                weight = G2 * sqrt(base_color) * LoH / max(NoH * NoV, 0.0001);\n                wi = reoriant(Z, n, wi_refract);\n            }\n        */\n        /*\n            //sheen\n            vec3 wi_local = cosine_hemi(vec2(rnd(), rnd()));\n            vec3 h_local = normalize(wi_local + wo_local);\n            float lum = .3*base_color.x + .6*base_color.y  + .1*base_color.z;\n            vec3 c_tint = base_color / (lum <= 0.0 ? 1. : lum);\n            vec3 c_sheen = (1. - sheenTint) + sheenTint * c_tint;\n            weight = PI * c_sheen * fresnel_schlick(dot(wi_local, h_local));\n            wi = reoriant(Z, n, wi_local);\n        */\n        \n        float diffuseWeight = (1. - metallic) * (1. - specular_transmission);\n        float metalWeight = (1. - specular_transmission * (1. - metallic));\n        float glassWeight = (1. - metallic) * specular_transmission;\n        float clearcoatWeight = 0.25 * clearcoat;\n        float weight_sum = diffuseWeight + metalWeight + glassWeight + clearcoatWeight;\n        diffuseWeight /= weight_sum;\n        metalWeight /= weight_sum;\n        glassWeight /= weight_sum;\n        clearcoatWeight /= weight_sum;\n        float r = rnd();\n        if(r < diffuseWeight){\n            vec3 wi_local = cosine_hemi(vec2(rnd(), rnd()));\n            if(!same_hemi(wi_local, wo_local)) return false;\n            vec3 h_local = normalize(wi_local + wo_local);\n            float VoH = saturate(dot(wo_local, h_local));\n            float NoL = saturate(wi_local.z);\n            float NoV = saturate(wo_local.z);\n            float FL = fresnel_schlick(NoL), FV = fresnel_schlick(NoV);\n            float Fd90 = 0.5 + 2. * VoH * VoH * roughness;\n            float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n            float Fss90 = VoH * VoH * roughness;\n            float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n            float ss = 1.25 * (Fss * (1. / (NoL + NoV) - .5) + .5);\n            if(rec.is_back_face) weight = vec3(0);\n            else weight = base_color * mix(Fd, ss, subsurface);\n            wi = reoriant(Z, n, wi_local);\n        }else if(r >= diffuseWeight && r < diffuseWeight + metalWeight){\n            vec3 h_local = sample_ggx_vndf(wo_local, ax, ay, rnd(), rnd());\n            vec3 wi_local = reflect(-wo_local, h_local);\n            if(!same_hemi(wi_local, wo_local)) return false;\n            float VoH = dot(wo_local, h_local);\n            vec3 Ks = (1. - specularTint) + specularTint * c_tint;\n            vec3 C0 = specular * pow((eta - 1.) / (eta + 1.), 2.) * (1. - metallic) * Ks + metallic * base_color;\n            vec3 F = mix(base_color, vec3(1.0), fresnel_schlick(VoH));\n            float D = ggx_ndf_aniso(vec2(ax, ay), h_local);\n            float G1 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_local);\n            if(rec.is_back_face) weight = vec3(0);\n            else weight = G1 * F;\n            wi = reoriant(Z, n, wi_local);\n        }else if(r >= diffuseWeight + metalWeight && r < diffuseWeight + metalWeight + glassWeight){\n             // glass\n            vec3 h_local = sample_ggx_importance_aniso(vec2(rnd(), rnd()), vec2(ax, ay));\n            float VoH = abs(dot(wo_local, h_local));\n            float NoH = abs(h_local.z);\n            float NoV = abs(wo_local.z);\n            vec3 wi_refract = refract(-wo_local, h_local, eta);\n            vec3 wi_reflect = reflect(-wo_local, h_local);\n            float reflect_prob = fresnel(VoH, dot(wi_reflect, h_local), eta);\n\n            if(reflect_prob > rnd() || wi_refract == vec3(0)){ //\n                if(!same_hemi(wi_reflect, wo_local)) return false;\n                float G2 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_reflect) * smith_shadowing_g1_aniso(vec2(ax, ay), wo_local);\n                weight = G2 * base_color * VoH / max(NoH * NoV, 0.0001);\n                wi = reoriant(Z, n, wi_reflect);\n            }else{\n                if(!same_hemi(-wi_refract, wo_local)) return false;\n                float G2 = smith_shadowing_g1_aniso(vec2(ax, ay), wi_refract) * smith_shadowing_g1_aniso(vec2(ax, ay), wo_local);\n                float LoH = abs(dot(wi_refract, -h_local));\n                weight = G2 * sqrt(base_color) * LoH / max(NoH * NoV, 0.0001);\n                wi = reoriant(Z, n, wi_refract);\n                //weight = vec3(h_local * 100.);\n            }\n        }else{\n            vec3 h_local = sample_disney_clearcoat(vec2(rnd(), rnd()), ag);\n            vec3 wi_local = reflect(-wo_local, h_local);\n            if(!same_hemi(wi_local, wo_local)) return false;\n            float VoH = abs(dot(wo_local, h_local));\n            float NoH = abs(h_local.z);\n            float NoV = abs(wo_local.z);\n            float NoL = saturate(wi_local.z);\n            float Dr = GTR1(NoH, mix(.1,.001,clearCoatGloss));\n            float Fr = mix(.04, 1.0, fresnel_schlick(VoH));\n            float Gr = smith_shadowing_g1(.625, NoL) * smith_shadowing_g1(.625, NoV);\n            if(rec.is_back_face) weight = vec3(0);\n            else weight = vec3(Fr * Gr * VoH / max(NoH * NoV, 0.0001)); // Fr * Gr * VoH / (v_local.z * h_local.z)\n            wi = reoriant(Z, n, wi_local);\n        }\n    }\n    return true;\n}\n\nvec3 trace(ray r, int max_depth){\n    vec3 color = vec3(0);\n    vec3 throughput = vec3(1);\n    record rec;\n    bool valid;\n    int depth = 0;\n    while(depth < max_depth){\n        hit(r, rec, valid);\n        if(!valid){\n            color += throughput * background;\n            break;\n        }\n        if(MAT_TYPE(rec.mat_id) == EMISSIVE){\n            if(rec.is_back_face) break;\n            int texture_id = emissive_array[MAT_ID(rec.mat_id)].emit_color_id;\n            float strength = emissive_array[MAT_ID(rec.mat_id)].strength;\n            color += throughput * pick_texture(texture_id) * strength;\n            break;\n        }\n        vec3 wo = normalize(-r.B);\n        vec3 wi, weight;\n        if(sample_brdf(wi, weight, wo, rec)){\n            throughput *= weight;\n            r = ray(rec.pos, wi);\n            depth ++;\n        }else{\n            break;\n        }\n    }\n    return color;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int spp = 5;\n// camera\nvec3 cam_pos = vec3(0, 0.5, 2.5); // CPU->GPU\nvec3 right = vec3(1, 0, 0), up = vec3(0, 1, 0); // CPU->GPU\nvec3 dir = normalize(vec3(0, 0, 1)); // CPU\nvec3 left_lower_corner; // CPU->GPU\nfloat aspect_ratio;\nfloat fov = radians(45.); // CPU\nfloat plane_width, plane_height; // CPU\nray get_ray(vec2 uv){ \n    vec3 target;\n    target = left_lower_corner + \n             plane_width * uv.x * right + \n             plane_height * uv.y * up;\n    return ray(cam_pos, target - cam_pos);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    seed = iTime + fragCoord.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    aspect_ratio = iResolution.x / iResolution.y; \n    plane_height = 2.0*tan(fov / 2.0); \n    plane_width = aspect_ratio * plane_height; \n    left_lower_corner = -plane_width / 2.0 * right + (-plane_height / 2.0) * up - dir + cam_pos;\n\n    vec3 color = vec3(0, 0 ,0);\n    for(int i = 0; i < spp; i ++){\n        vec2 uv = (fragCoord + vec2(rnd(), rnd()) - 0.5f)/iResolution.xy;\n        ray r = get_ray(uv);\n        color += trace(r, 20);\n    }\n    if(isnan(color.x) || isnan(color.y) || isnan(color.z)) color = vec3(1, 1, 1);\n    if(isinf(color.x) || isinf(color.y) || isinf(color.z)) color = vec3(1, 1, 1);\n    color /= float(spp);\n    //if(color[0] == color[1] && color[1] == color[2] && color[0] == 0.0) color[0] = 1.0;\n    //if(isnan(color.x) || isnan(color.y) || isnan(color.z)) color = vec3(10000, 1000, 1000);\n    //if(isinf(color.x) || isinf(color.y) || isinf(color.z)) color = vec3(1000, 0, 1000);\n    if(color.x < 0. || color.y < 0. || color.z < 0.) color = vec3(1000, 1000, 1000);\n    //if(color.x == color.y && color.y == color.z && color.z == 0.) color = vec3(1, 1, 0);\n    //color = clamp(color, 0.0, 1.0);\n    // https://www.shadertoy.com/view/tddSz4\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float w = prev.w + 1.0;\n    color = color + to_linear(prev.xyz) * prev.w;\n    color /= w;\n    fragColor = vec4(to_gamma(color), w);\n    //fragColor = vec4(fragCoord / iResolution.xy, 0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}