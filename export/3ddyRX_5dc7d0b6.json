{"ver":"0.1","info":{"id":"3ddyRX","date":"1601407364","viewed":183,"name":"SSS with Spherical Gaussians","username":"athibaul","description":"Testing the approach of approximating Subsurface Scattering with Spherical Gaussians explained in [url=https://therealmjp.github.io/posts/sss-sg/]this blog[/url].\nLeft: Lambertian\nRight: SG-SSS","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sss","subsurface","sg","sphericalgaussians"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Subsurface scattering approximation for use in a raymarcher\n\n// Based on Spherical Gaussians\n// https://therealmjp.github.io/posts/sss-sg/\n\n\nfloat map(vec3 p)\n{\n    float d = p.z+0.5;\n    /*\n    vec3 p0 = round(p);\n    // Row of cubes\n    vec3 offset = vec3(clamp(p0.x,-3.,3.),0,0);\n    //float rounded = (p0.x + 3.)*0.05;\n    float rounded = 0.1;\n    vec3 q = abs(p - offset)-0.4 + rounded;\n    d = min(d, length(max(q,0.)) + min(0.,max(q.x,max(q.y,q.z))) - rounded);\n    \n    q = p - offset + vec3(0,1,0);\n    d = min(d, length(q) -0.05-rounded);\n    \n    q = abs(p - vec3(0.,1.,0.5)) - vec3(1.,0.0,1.0);\n    //d = min(d, length(max(q,0.)) + min(0.,max(q.x,max(q.y,q.z))) - 0.3);\n\n\t*/\n    \n    vec3 p0 = clamp(round(p+0.5), 0., 1.) - 0.5;\n    vec3 q0 = p;\n    q0.x -= p0.x;\n    float rounded = 0.1;\n    vec3 q = abs(q0) - 0.4 + rounded;\n    d = min(d, length(max(q,0.)) + min(0.,max(q.x,max(q.y,q.z))) - rounded);\n    q = q0 - vec3(0,-1,0);\n    d = min(d, length(q) - 0.4);\n    \n    q = abs(p - vec3(0.,1.,1.)) - vec3(1.0,0.0,1.0);\n    d = min(d, length(max(q,0.)) + min(0.,max(p.x,max(q.y,q.z))) - 0.05);\n    return d;\n}\n\n\nvec2 coo;\nvec4 bluenoise()\n{\n    return texture(iChannel0, coo);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd)\n{\n    // Find intersection with the scene\n    float d, t=0.;\n    for(int i=0; i<256; i++)\n    {\n        d = map(ro+t*rd);\n        if(d < 0.001 || t > 100.) break;\n        t += d*0.8;\n    }\n    return ro+t*rd;\n}\n\n\nvec3 calcNormal(vec3 p, float r)\n{\n    // Finite-difference approximation of the normal\n    vec2 e = r*vec2(1,-1);\n    float m = map(p);\n    float mxxx = map(p+e.xxx),\n          mxyy = map(p+e.xyy),\n          myxy = map(p+e.yxy),\n          myyx = map(p+e.yyx);\n    vec3 n = normalize(e.xxx*mxxx\n                      +e.xyy*mxyy\n                      +e.yxy*myxy\n                      +e.yyx*myyx);\n    return n;\n}\n\nfloat calcLaplacian(vec3 p, float r)\n{\n    // Finite-difference approximation of the normal, \n    // and of the Laplacian of the map()\n    vec2 e = r*vec2(1,-1);\n    float m = map(p);\n    float mxxx = map(p+e.xxx),\n          mxyy = map(p+e.xyy),\n          myxy = map(p+e.yxy),\n          myyx = map(p+e.yyx);\n    float lapl = (mxxx+mxyy+myxy+myyx - 4.*m)/(4.*r*r);\n    return lapl;\n}\n\nvec3 sun, sunCol;\n\n//#define mexp(x) mix(1.+x+0.5*x*x, 1./(1.-x+0.5*x*x), step(0.,x))\n#define mexp(x) mix(1./(1.-(x)*(1.-0.5*(x))), 1.+(x)*(1.+0.5*(x)), step(0.,x))\n\nvec3 shadeSSS(vec3 ro, vec3 scatteringDist, vec3 n, float lapl)\n{\n    float sqrtlapl = lapl > 0.01 ? sqrt(lapl) : 0.01;\n    // Apply a Spherical Gaussian lobe, by computing the inner product\n    // of an SG approximating the sun's Lambertian light,\n    // and an SG oriented as the normal, approximating the scattering profile.\n    // Based on\n    // https://therealmjp.github.io/posts/sss-sg/\n    // and previous blog posts on Spherical Gaussians.\n    float sharpness0 = 2.133;\n    float amplitude0 = 1.17;\n    vec3 sharpness1 = vec3(1./(scatteringDist*scatteringDist*max(lapl,0.05)));\n    //return vec3(normalAndLapl.w);\n    //vec3 sharpness1 = vec3(exp(ro.x+1.));\n    // Normalize the Spherical Gaussian\n    vec3 expTerm = 1.-exp(-2.*sharpness1);\n    vec3 amplitude1 = 1./(2.*3.1415926 * expTerm) * sharpness1;\n    /*\n    vec3 umLength = vec3(\n        length(sharpness0*sun + sharpness1.r*n),\n        length(sharpness0*sun + sharpness1.g*n),\n        length(sharpness0*sun + sharpness1.b*n));\n\t*/\n    // Equivalent formula:\n    vec3 umLength = sqrt(sharpness0*sharpness0 + sharpness1*sharpness1\n                         + 2.*sharpness0*sharpness1*dot(n,sun));\n    vec3 innerProduct = 2.*3.1415926*amplitude0*amplitude1*(1.-exp(-2.*umLength))*exp(umLength-sharpness0-sharpness1)/umLength;\n    return innerProduct;\n}\n\nvec3 shadeSSSCheap(vec3 ro, vec3 scatteringDist, vec3 n, float lapl)\n{\n    // Cheaper approximation of SSS shading, with 3 sqrt() and one exp()\n    // Might be non-normalized in some cases.\n    const float sharpness0 = 2.133;\n    const float amplitude0 = 1.17;\n    vec3 sharpness1 = vec3(1./(scatteringDist*scatteringDist*max(lapl,0.05)));\n    vec3 amplitude1 = sharpness1;\n    float LdotN = dot(n, sun);\n    vec3 umLength = sqrt(sharpness0*sharpness0 + sharpness1*sharpness1\n                         + 2.*sharpness0*sharpness1*dot(n,sun));\n    vec3 innerProduct = amplitude0*amplitude1*exp(umLength-sharpness0-sharpness1)/umLength;\n    return innerProduct;\n}\n\n\nfloat softShadow(vec3 p, vec3 sun, float softness, float w0)\n{\n    float shadow = 1.0;\n    float d, t=0.0;\n    for(int i=0; i<50; i++)\n    {\n        d = map(p+t*sun);\n        float w = t*softness + w0;\n        shadow = min(shadow, smoothstep(-w,w,d+w0));\n        if(i < 3)\n        {\n            t += (d+w)*bluenoise().x;\n        }\n        else\n        {\n        \tt += d+w;\n        }\n        if(shadow < 0.001 || length(p) > 10.) break;\n    }\n    return shadow;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    coo = fragCoord/iResolution.xy;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(2.*cos(.3*iTime),-3.,1.5);\n    vec3 target = vec3(0.,-0.5,0.5);\n    vec3 camFwd = normalize(target - ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    vec3 rd = normalize(camFwd + 0.4*(uv.x*camRight+uv.y*camUp));\n    \n    //float th = 0.2*iTime;\n    //float th = 3.1415*0.3 * (1.3 + sin(0.3*iTime));\n    //sun = normalize(vec3(cos(th),-0.5*cos(th),sin(th)));\n    sun = normalize(vec3(cos(0.2*iTime), sin(0.5*iTime), 0.2));\n    //sunCol = vec3(1.)*(vec3(1.,0.5,0.)*sqrt(sun.z) + vec3(0.,0.5,1.)*sun.z);\n    sunCol = vec3(1.,.95,.9) * (1. + 5.*clamp(sun.y,0.,1.));\n    if(sun.z < 0.)\n    {\n        sun = -sun;\n        sunCol = 2.0*vec3(0.2,0.3,0.4)*sqrt(sun.z);\n    }\n    \n    \n    vec3 p = raymarch(ro, rd);\n\tfloat sssRadius = 0.2;\n    vec3 n = calcNormal(p, 0.001);\n    float lapl = calcLaplacian(p, sssRadius);\n    \n    //vec3 col = 0.5 + 0.5*p;\n    vec3 col = vec3(0);\n    float shadowW0 = 0.3*sssRadius;\n    float shadow = softShadow(p, sun, 0.5, shadowW0);\n    vec3 surfaceColor = vec3(1.,0.4,0.25);\n    if(p.z > -0.39 && length(p) < 10.)\n    {\n        if(p.x > 0.)\n        {\n            // Skin-like material\n            // Red travels farther than green and blue.\n            #if 0\n            col = sunCol * surfaceColor * shadeSSS(p, sssRadius*surfaceColor, n, lapl);\n            #else\n            col = sunCol * surfaceColor * shadeSSSCheap(p, sssRadius*surfaceColor, n, lapl);\n            #endif\n            //col += 0.2*(0.5-0.5*dot(n.xy, -sun.xy)) * sunCol;\n        }\n        else\n        {\n            col = sunCol * surfaceColor * clamp(dot(sun, n), 0., 1.);\n        }\n        col *= vec3(shadow);\n    }\n    else if(p.z < 0.)\n    {\n        col = 0.5 * sunCol * pow(clamp(sun.z, 0., 1.),0.3);\n    \tcol *= vec3(shadow) * smoothstep(10.,5.,length(p)+vec3(0.,0.5,1.));\n    }\n    else\n    {\n        col = vec3(0.);\n    }\n    \n    //col = vec3(0.05*lapl);\n    //col = vec3(shadow);\n    \n    \n    // Tone mapping\n    col = mix(col, 1.-(4./27.)/(col*col), step(2./3., col));\n    col = pow(col, vec3(0.45));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}