{"ver":"0.1","info":{"id":"llK3RR","date":"1472834025","viewed":2214,"name":"Lens/Film Chromatic Aberration","username":"Weaseltron","description":"Using Brown/Conrady distortion effect for a lens/film effect.\nDrag mouse left/right to increase/decrease the effect.","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["chromaticaberrationbarreldistortionchromafilterpostlens"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 barrelDistortion( vec2 p, vec2 amt )\n{\n    p = 2.0 * p - 1.0;\n\n    /*\n    const float maxBarrelPower = 5.0;\n\t//note: http://glsl.heroku.com/e#3290.7 , copied from Little Grasshopper\n    float theta  = atan(p.y, p.x);\n    vec2 radius = vec2( length(p) );\n    radius = pow(radius, 1.0 + maxBarrelPower * amt);\n    p.x = radius.x * cos(theta);\n    p.y = radius.y * sin(theta);\n\n\t/*/\n    // much faster version\n    //const float maxBarrelPower = 5.0;\n    //float radius = length(p);\n    float maxBarrelPower = sqrt(5.0);\n    float radius = dot(p,p); //faster but doesn't match above accurately\n    p *= pow(vec2(radius), maxBarrelPower * amt);\n\t/* */\n\n    return p * 0.5 + 0.5;\n}\n\n//note: from https://www.shadertoy.com/view/MlSXR3\nvec2 brownConradyDistortion(vec2 uv, float scalar)\n{\n// AH!!!    uv = uv * 2.0 - 1.0;\n    uv = (uv - 0.5 ) * 2.0;\n    \n    if( true )\n    {\n        // positive values of K1 give barrel distortion, negative give pincushion\n        float barrelDistortion1 = -0.02 * scalar; // K1 in text books\n        float barrelDistortion2 = 0.0 * scalar; // K2 in text books\n\n        float r2 = dot(uv,uv);\n        uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n        //uv *= 1.0 + barrelDistortion1 * r2;\n    }\n    \n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n//    return uv * 0.5 + 0.5;\n   return (uv / 2.0) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float maxDistort = 4.0 * (1.0-iMouse.x/iResolution.x);\n\n    float scalar = 1.0 * maxDistort;\n//    vec4 colourScalar = vec4(2.0, 1.5, 1.0, 1.0);\n    vec4 colourScalar = vec4(700.0, 560.0, 490.0, 1.0);\t// Based on the true wavelengths of red, green, blue light.\n    colourScalar /= max(max(colourScalar.x, colourScalar.y), colourScalar.z);\n    colourScalar *= 2.0;\n    \n    colourScalar *= scalar;\n    \n    vec4 sourceCol = texture(iChannel0, uv);\n\n    const float numTaps = 8.0;\n    \n    \n    fragColor = vec4( 0.0 );\n    for( float tap = 0.0; tap < numTaps; tap += 1.0 )\n    {\n        fragColor.r += texture(iChannel0, brownConradyDistortion(uv, colourScalar.r)).r;\n        fragColor.g += texture(iChannel0, brownConradyDistortion(uv, colourScalar.g)).g;\n        fragColor.b += texture(iChannel0, brownConradyDistortion(uv, colourScalar.b)).b;\n        \n        colourScalar *= 0.99;\n    }\n    \n    fragColor /= numTaps;\n  \n    fragColor.a = 1.0;\n}\n\n","name":"Image","description":"","type":"image"}]}