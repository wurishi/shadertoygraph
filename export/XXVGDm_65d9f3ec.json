{"ver":"0.1","info":{"id":"XXVGDm","date":"1717741324","viewed":104,"name":"CNWO RADAR","username":"zproxy","description":"map","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["earth","map"],"hasliked":0,"parentid":"4lccW4","parentname":"UN world map"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord.xy  / iResolution.xy ;\n \n   // uv1.y *= 1.3;\n  //  uv1.y *= uv1.x/uv1.y;\n    \n     fragColor =texture(iChannel0,  uv1\n                   );\n    //    return;\n    \n    \n\tvec2 uv0 = uv1 - vec2(0.5, 0.5);\n \n      //  uv0.y *= uv0.x/uv0.y;\n\n    vec2 uv2 = uv0 * 2.0;\n    \n    \n    // aspect fixup\n    uv2.x *= iResolution.x/iResolution.y;\n   uv2 *= 0.9;\n    \n    const float pi2=6.283185307179586476925286766559;\n    \n    float azimuth = 0.0;\n    float distance0 = length(uv2);\n    float distance = length(uv2);\n\n\t//float maxdistance = 0.832;\n\tfloat maxdistance = 1.0; // unless we do want the edges\n\tfloat mindistance = 1.0;\n\n   \n\t\tif (distance > maxdistance)\n\t\t\tdistance = maxdistance;\n\n        fragColor = vec4(1.0, 0.0, 0.0,1.0);\n\n        azimuth=atan(-uv2.x,uv2.y);\n    azimuth+= radians(-18.0);\n        \n        \n        if (azimuth<0.0) azimuth+=pi2;\n        if (azimuth>pi2) azimuth-=pi2;\n        \n        \n          // vec4 col2 =texture2D(iChannel0,\n    \n    vec4 col2 =texture(iChannel0,\n                   vec2(azimuth/pi2, 1.0 - distance)\n                   );\n        \n\n\n\t\t// special discard for clouds\n\t\tif (col2.w < 1.0)\n\t\t\tif (distance0 >= maxdistance)\n            {\n                fragColor = vec4(0.0  ,0,0, 1.0);\n                return;\n\t\t\t//\tdiscard;\n            }\n\n\t\tif (distance0 >= 1.0)\n\t\t{\n\t\t\t// to clear alpha would we need another clear program to be used?\n\n\t\t\t// discard exposes the renderer clear color?\n\t\t\t//discard;\n\n\t\t\t//if (uv2.x < 0.0)\n\t\t\t//fragColor = vec4(0,1.0,0, 0.0);\n\t\t\t//else\n\t\t\t//fragColor = vec4(1.0,0,0, 0.0);\n\t\t\t\n\t\t\t// color will bleed on the edge it comes transparent!!\n\t\t\tfragColor = vec4(col2.r,col2.g,col2.b, 0.0);\n\n\t\t\treturn;\n\t\t\t//discard;\n\t\t}\n\n\n\t\tfragColor = vec4(1.0 - col2.y,0,0, 1.0);\n\t\t//fragColor = col2;\n        \n  \n}\n\n#define PI 3.14\n\nfloat random2d(vec2 coord){\n    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2 rotate(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat drawLine(vec2 uv, float offset, float thickness, float angle)\n{\n    float o = 0.0;\n    uv = rotate(angle * 0.0174533) * uv;\n    o = smoothstep(0.5, 0.5, 1.0 - length((uv - vec2(offset, 0.0)) * vec2(thickness, 0.0)));\n    return o;\n}\n\nfloat drawCircle(vec2 position, float radius){\n    return step(radius, length(position - vec2(0.5)));\n}\n\nfloat valueNoise(vec2 uv, float scale)\n{\n    float o = 0.0;\n    vec2 gridUV = fract(uv * scale);\n    vec2 gridID = floor(uv * scale);\n    gridUV = smoothstep(0.0, 1.0, gridUV);\n\n    float bottomLeftPoint  = random2d(gridID);\n    float bottomRightPoint = random2d(gridID + vec2(1.0, 0.0));\n    float b = mix(bottomLeftPoint, bottomRightPoint, gridUV.x);\n\n    float topLeftPoint = random2d(gridID + vec2(0.0, 1.0));\n    float topRightPoint = random2d(gridID + vec2(1.0, 1.0));\n    float t = mix(topLeftPoint, topRightPoint, gridUV.x);\n\n    o = mix(b, t, gridUV.y);\n    return o;\n}\n\nfloat generateNoiseTex(vec2 uv, float scale, float minRange, float maxRange)\n{\n    float o = (\n        (valueNoise(uv, scale) / 1.0) +\n        (valueNoise(uv, scale * 2.0) / 2.0) +\n        (valueNoise(uv, scale * 4.0) / 4.0) +\n        (valueNoise(uv, scale * 6.0) / 6.0) +\n        (valueNoise(uv, scale * 8.0) / 8.0)\n    ) / 2.0;\n    o = clamp(o, 0.0, 1.0);\n    o = mix(minRange, maxRange, o);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //==============================================\n    vec2 texCoords = fragCoord.xy/iResolution.xy;\n    texCoords.x -= 0.2;\n    texCoords *= vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 polarUV = texCoords;\n    vec4 color = vec4(0.0, 1.0, 0.0314, 1.0);\n    //==============================================\n    \n    texCoords.y = 1.0 - texCoords.y;\n    texCoords -= 0.5;\n    polarUV = vec2(sqrt((texCoords.x * texCoords.x) + (texCoords.y * texCoords.y)), atan(texCoords.y, texCoords.x));\n    polarUV.y = fract(polarUV.y / (2.0 * PI)); //dividing y coords with 2PI to make it cover full circle\n\n    polarUV.x *= 1.0;\n    polarUV.y *= 1.0;\n\n    float x1 = polarUV.x - (0.4); //x will act as radius\n    float y1 = polarUV.y - (iTime * 0.04); //y will act as angle\n\n    x1 = fract(x1 * 17.0);\n    y1 = clamp(fract(y1 * 1.0) +(1.0 - drawCircle(texCoords + 0.5, 0.01)), 0.0, 1.0);\n\n    float coordinatesAngle = 1.0;\n\n    float x2 = polarUV.x - (0.403); //x will act as radius\n    float y2 = (1.0 - polarUV.y) - (iTime * 0.1);\n    float y21 = polarUV.y - 0.4;\n    float y22 = polarUV.y - 0.401;\n    x2 = fract(x2 * 17.0);\n    y2 = fract(y2 * 4.0);\n    y21 = fract(y21 * 80.0);\n    y22 = fract(y22 * 80.0);\n\n    float mask1 = 1.0 - drawCircle(texCoords + 0.5, 0.403);\n    float mask2 = 1.0 - drawCircle(texCoords + 0.5, 0.43);\n    float mask3 = 1.0 - drawCircle(texCoords + 0.5, 0.42);\n\n    float dx = clamp((x2 - x1) * 50.0, 0.0, 1.0);\n    float lineThicknes1 = 300.0;\n    float lineThicknes2 = 150.0;\n    float cartesianDivision = clamp(\n        (\n            (\n                drawLine(texCoords, 0.0, lineThicknes1, 0.0) +\n                drawLine(texCoords, 0.0, lineThicknes1, 45.0) +\n                drawLine(texCoords, 0.0, lineThicknes1, -45.0) +\n                drawLine(texCoords, 0.0, lineThicknes1, 90.0)\n            ) * mask1\n        ) +\n        (\n            (\n                drawLine(texCoords, 0.0, lineThicknes2, 0.0) +\n                drawLine(texCoords, 0.0, lineThicknes2, 45.0) +\n                drawLine(texCoords, 0.0, lineThicknes2, -45.0) +\n                drawLine(texCoords, 0.0, lineThicknes2, 90.0)\n            ) *(mask2 - mask1)\n        ) +\n        (\n            y2 * ( 1.0 -drawCircle(texCoords + 0.5, 0.44) - mask2)\n        )+\n        (\n            clamp((y22 - y21) * 50.0, 0.0, 1.0) * (mask3 - mask1)\n        ), \n        0.0, 1.0\n    );\n    float radarMask = pow(y1, 15.0);\n    float radarWireFrame = clamp((dx * mask1 + cartesianDivision), 0.0, 1.0);\n    vec4 radarColor = vec4(0.0, 1.0, 0.0, 0.5) * radarMask * 0.5;\n    \n    //color = mix(vec4(color.rgb, 0.1), vec4(color.rgb, 0.4), radarWireFrame);\n    color = color * 0.3;\n    color += color * radarWireFrame;\n    color += radarColor * mask1;\n\n    vec2 noiseUV = vec2(texCoords.x + 0.5, texCoords.y + 0.5 * iTime * -0.3);\n    vec4 noiseTex = vec4(vec3(color.rgb), 1.0) * clamp(generateNoiseTex(noiseUV, 20.0, -50.0, 50.0) * 0.5 * mask1, 0.0, 1.0) * (polarUV.x * 0.8);\n    noiseTex *= radarMask * mask1;\n    color += noiseTex;\n\n// https://www.shadertoy.com/view/lXGGWw\n\nmainImage0(fragColor,  fragCoord );\nfragColor.r/=2.0;\n    fragColor.r += color.g;\n    fragColor.r*=fragColor.r;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/XsKBzt\n// auto-generated by https://github.com/rkibria/img2shadertoy\nconst vec2 bitmap_size = vec2(160, 72);\nconst int[] palette = int[] ( 0x00010502, 0x00060a07, 0x000c100e, 0x00111412, 0x00151816, 0x00191b1a, 0x001e211f, 0x00252725, 0x002c2e2c, 0x002f3230, 0x00323533, 0x00363937, 0x003c3e3c, 0x00414442, 0x00515452, 0x00ffff00 );\nconst int[] rle = int[] ( 0xaaaaa907, 0x899999a9, 0x00889c89, 0x02999e98, 0x87aaaaaa, 0x888806ff, 0x56776677, 0x85668365, 0x55670577, 0x55443334, 0x77026684, 0x88867777, 0xa9009984, 0xbb84aa84, 0xaa84ab00, 0x89049986, 0x89998888, 0x0f00ff8c, 0x22151183, 0x66554322, 0x56677777, 0x12222224, 0x33443111, 0x66655544, 0x06888477, 0xbaaa9999, 0x84cbbbbb, 0x83dd00cc, 0xbbbb07cc, 0xaaaaabbb, 0x88839999, 0x77777805, 0x8c124256, 0x110024ff, 0x22221111, 0x76655533, 0x45677777, 0xff011223, 0x000fffff, 0x43221100, 0x98888765, 0xbaaa9888, 0x85cbbbbb, 0x0edd85cc, 0xbbbbbbcc, 0x899aaaaa, 0x67777888, 0x8ef14655, 0x210f09ff, 0x43322222, 0x56655555, 0x76126683, 0x000ff001, 0x1110ffff, 0x2111ffff, 0x99888765, 0xbb84a989, 0xbbbccb08, 0xaaaaaaab, 0xcc85bbbb, 0xaaabbb0b, 0x88899aaa, 0x56777788, 0x0fff9122, 0x66655421, 0x22345566, 0x33332222, 0x01211112, 0x5205ff87, 0x89999875, 0x19bb85a9, 0x99999aaa, 0xa8777888, 0xcccbbbba, 0xaabbbccc, 0x889aaaaa, 0x77788888, 0xff99f267, 0x22110f08, 0x21111f22, 0xff871353, 0x76532f09, 0xcccb9878, 0x839bbbcb, 0x78881799, 0x99864346, 0xbccbbbba, 0xaaaaa9ab, 0x8899999a, 0x67777888, 0xff9ef246, 0xf6510f02, 0x1f17ff89, 0x464443ff, 0x54443224, 0x98888766, 0x41f46788, 0xaaaa9986, 0x8388999a, 0x88890799, 0x66666777, 0xff9f3444, 0xff923f00, 0x33ff1f18, 0x56677643, 0x553fff13, 0x77777766, 0x65566667, 0x36777666, 0xffa31232, 0xff95f100, 0x87f04101, 0xf23207ff, 0xf1ffff11, 0xffa71222, 0xfffff100, 0xffbbffff, 0xcdf00f01, 0xce1100ff, 0xf12201ff, 0x2101ffcd, 0x00ffadf1, 0x01ff9e1f, 0xffae022f, 0xff9df100, 0xf0133f02, 0xf100ffa8, 0x4f02ffa2, 0xffa70001, 0xff850f00, 0xff9cf100, 0x00144f03, 0x01ffa6f0, 0xffa22000, 0x00231f03, 0x02ff8d00, 0x90f0211f, 0x000007ff, 0x0000ffff, 0xffa1f010, 0x01144f04, 0xff8cf000, 0x35441f02, 0x1001ff90, 0x00008401, 0x04ffa1f2, 0x00002a3f, 0x03ff8c11, 0xf174422f, 0x1001ff8f, 0x00008411, 0x04ffa2f1, 0x2100008d, 0x03ff8bf1, 0xf2543233, 0x0f00ff8e, 0x00031183, 0xa2f11100, 0x01d904ff, 0x8b211100, 0x334406ff, 0x0fff0133, 0x07ff8bf2, 0x1111110f, 0x01000012, 0xdc05ffa3, 0x21111003, 0x07ff8902, 0x2333441f, 0xf2ffff01, 0x0006ff8c, 0x00111100, 0xffa30010, 0x0013cd05, 0x89022211, 0x333f07ff, 0xff143223, 0xff8d13ff, 0x00100f04, 0xffa31000, 0x002cd506, 0x12121100, 0x3f07ff89, 0x11233344, 0x8e20ff01, 0x000103ff, 0xffa20ff0, 0x02bc6f07, 0x21011110, 0x07ff8921, 0x4433453f, 0x2fff1223, 0x0000ff8f, 0xbf08ffa4, 0x11110012, 0xf0112101, 0x1f05ff88, 0x34344345, 0x08ffb712, 0x00000058, 0x11101110, 0x05ff8811, 0x3232320f, 0xffb70245, 0x00831600, 0x10101003, 0x05ff8800, 0x3222221f, 0xff8c0343, 0xff85f000, 0xa1f33f01, 0x860500ff, 0x05ff8900, 0x52111110, 0xff8b1444, 0xffff1f08, 0xfffff1ff, 0xffa20143, 0x00830600, 0xff8bf000, 0x11111106, 0xf0164452, 0xf106ff8a, 0xf1f000ff, 0xffa410ff, 0x10114305, 0x8b000001, 0x111106ff, 0x14432111, 0x04ff8900, 0x10fff01f, 0x05ffa7f1, 0x1210044f, 0xff8bf010, 0x11111107, 0x11313222, 0x04ff88f0, 0x1ffff0f2, 0x04ffa7f1, 0x1120043f, 0x0bff88f0, 0x10f00000, 0x12211223, 0x01127511, 0xf107ff85, 0xf0ffffff, 0xa6f1ffff, 0x0f0204ff, 0x88000031, 0x111f0cff, 0x11101101, 0x21112111, 0x88124476, 0x830f00ff, 0xf00f01ff, 0x0f03ffa3, 0x8a0fffff, 0x111004ff, 0x84210110, 0xf1750211, 0x00ff842f, 0x00ff8301, 0x01ffa80f, 0xff8bf021, 0x01000f0d, 0x01110001, 0x11223210, 0x84f22062, 0xff1209ff, 0x000fffff, 0xf0ffff10, 0x3f02ffa2, 0xff8df022, 0x0010001b, 0x00111111, 0x21111221, 0xfff1225f, 0x111fffff, 0x1fffffff, 0xfffff101, 0x06ffa1f1, 0xf00f1732, 0x8a2fffff, 0x111017ff, 0x11311111, 0x10112111, 0x11125ff1, 0x1ffffff0, 0xffff1111, 0xffa52111, 0xfff16505, 0x8af0ffff, 0x100f19ff, 0x21110111, 0x11114311, 0x0124f110, 0xffff0000, 0xf0011110, 0xf023322f, 0x4f02ffa3, 0xff8ff167, 0x0010001b, 0x11223521, 0x1f100211, 0xf1001223, 0x11100fff, 0x5120f111, 0xf1010255, 0x05ffa0f3, 0xfff03471, 0xff8c0fff, 0x0111101a, 0x01112210, 0x21101100, 0x2fff0123, 0x01100122, 0x82110000, 0x11112477, 0x0106ffa0, 0xff001455, 0xff8d0fff, 0x11831200, 0x00000115, 0xf1122210, 0x15242651, 0xeed40000, 0x223cdbbd, 0x9ef01001, 0x2f1f07ff, 0x00012345, 0xff8df000, 0x11235219, 0x00f01100, 0x01220ff0, 0x22256700, 0xeec20064, 0x5ddeeeee, 0x9f000131, 0x312f08ff, 0x00012467, 0x8cf00000, 0x331f03ff, 0xff840023, 0x62012208, 0x88725235, 0xee83ed52, 0x02348d06, 0x10ffff00, 0x1f09ff9b, 0x35866423, 0x11000101, 0x01ff8e00, 0xff841221, 0x66111114, 0x65214256, 0xeeedeecc, 0x467adcde, 0x1fff0013, 0xff9a21ff, 0x76762109, 0x00113596, 0x8c011000, 0x121001ff, 0x0118ff83, 0x7545332f, 0x0001ff25, 0x3347dc62, 0x58dda993, 0xffff2444, 0xf0fffff0, 0x430aff99, 0x34877565, 0x00000111, 0xff8bf011, 0xf023211b, 0x22f01fff, 0x65f13ff0, 0x0000ff22, 0x249b8510, 0x33464342, 0x00234544, 0x0aff9c32, 0x56774440, 0x00011124, 0x8c110000, 0x110f1dff, 0x0122f1f2, 0x25fffff0, 0x000000f1, 0x76422110, 0x55444446, 0x00243334, 0x1fff1111, 0x200bff99, 0x12236631, 0x11010111, 0x8b001011, 0x100f1cff, 0x10003433, 0x000f0f02, 0x0000ffff, 0x32111100, 0x57776622, 0x01323344, 0x9af10010, 0x43310dff, 0x01112224, 0x10110011, 0x0fff1011, 0x0f1cff89, 0x11211000, 0x00000111, 0x100ff000, 0x22211100, 0x76477612, 0x12345446, 0x10011012, 0x2f0eff99, 0x11236435, 0x01110011, 0x11110000, 0xff890011, 0x8c0f0001, 0x01110e00, 0x75356430, 0x22233236, 0x11310122, 0x0eff98f0, 0x12254231, 0x00000111, 0x1100f000, 0x88f01111, 0x0ff003ff, 0x00880fff, 0x00841000, 0x4421200e, 0x23342212, 0x01211111, 0x11ffffff, 0xf000ff8f, 0x2f0eff83, 0x11122443, 0x00000111, 0x110ffff0, 0xff8af111, 0x0ffff004, 0x0086ff0f, 0x00851000, 0x1111110e, 0x22434431, 0xfff23332, 0xf110ffff, 0x0013ff8e, 0x1ffffff1, 0x11124433, 0x00111100, 0x0fffffff, 0x8cf10f00, 0x000103ff, 0x0085fff0, 0x00851000, 0x1101100e, 0x11122111, 0xf1211112, 0xf1ffffff, 0x0012ff8d, 0x75220301, 0x11343334, 0x11110000, 0xffffff00, 0xff83f10f, 0x88f33101, 0x113105ff, 0x0f000ff0, 0x10000083, 0x10000085, 0x01091185, 0x22334100, 0x1001f122, 0x1dff8bf2, 0x2211000f, 0x25543323, 0x11110111, 0xff000000, 0x110ffff0, 0x850fffff, 0xffffff18, 0xff84210f, 0x0f011102, 0x10000085, 0x11840085, 0x1000000c, 0x33334221, 0x01222211, 0xff87f010, 0xfff0001c, 0x0111100f, 0x00112211, 0x00111000, 0x01100000, 0x200ffff0, 0x741ffff1, 0xff884568, 0x87121f01, 0x84100000, 0x0c118400, 0x21410001, 0x10122342, 0x01121111, 0x1bff8a11, 0x22111110, 0x01001122, 0x000f0110, 0xf000fff0, 0xf1100ff0, 0x750fffff, 0x36669a98, 0x1f04ff87, 0xf0000111, 0x0017ff83, 0x0000f001, 0x11232100, 0x00000111, 0x01210141, 0x10000000, 0x93111011, 0x000f13ff, 0xf00fff00, 0xf1100000, 0x21ffffff, 0x7aaa9886, 0xff8df022, 0xffff0f03, 0x0900860f, 0x00000011, 0x00000f10, 0xff97f000, 0xff001009, 0x00f0ffff, 0x83f11100, 0x887406ff, 0x36899a99, 0x00ff8e12, 0x00ff83f1, 0x0100840f, 0xff9ff0f0, 0xf0ff0f13, 0x0f0ff0ff, 0x10ffff11, 0x88766332, 0x67788888, 0x00ff8f13, 0x04ff8401, 0x11000f0f, 0x10ffa3f0, 0x012fff0f, 0x22ff1321, 0x87776653, 0x34667778, 0x01ff8502, 0xff8f1110, 0xffa80000, 0x4344110e, 0x22101124, 0x35532222, 0x11111122, 0xffffffff );\n\nconst int rle_len_bytes = rle.length() << 2;\n\nint get_rle_byte( in int byte_index )\n{\n        int long_val = rle[ byte_index >> 2 ];\n        return ( long_val >> ( ( byte_index & 0x03 ) << 3 ) ) & 0xff;\n}\n\nint get_uncompr_byte( in int byte_index )\n{\n        int rle_index = 0;\n        int cur_byte_index = 0;\n        while( rle_index < rle_len_bytes )\n        {\n                int cur_rle_byte = get_rle_byte( rle_index );\n                bool is_sequence = int( cur_rle_byte & 0x80 ) == 0;\n                int count = ( cur_rle_byte & 0x7f ) + 1;\n\n                if( byte_index >= cur_byte_index && byte_index < cur_byte_index + count )\n                {\n                        if( is_sequence )\n                        {\n                                return get_rle_byte( rle_index + 1 + ( byte_index - cur_byte_index ) );\n                        }\n                        else\n                        {\n                                return get_rle_byte( rle_index + 1 );\n                        }\n                }\n                else\n                {\n                        if( is_sequence )\n                        {\n                                rle_index += count + 1;\n                                cur_byte_index += count;\n                        }\n                        else\n                        {\n                                rle_index += 2;\n                                cur_byte_index += count;\n                        }\n                }\n        }\n\n        return 0;\n}\n\n\nint getPaletteIndexXY( in ivec2 fetch_pos )\n{\n        int palette_index = 0;\n        if( fetch_pos.x >= 0 && fetch_pos.y >= 0\n                && fetch_pos.x < int( bitmap_size.x ) && fetch_pos.y < int( bitmap_size.y ) )\n        {\n                int uncompr_byte_index = fetch_pos.y * ( int( bitmap_size.x ) >> 1 )\n                        + ( fetch_pos.x >> 1);\n\n                int uncompr_byte = get_uncompr_byte( uncompr_byte_index );\n\n                int nibble_index = fetch_pos.x & 0x01;\n                palette_index = ( uncompr_byte >> ( nibble_index << 2 ) ) & 0xf;\n        }\n        return palette_index;\n}\n\n\nint getPaletteIndex( in vec2 uv )\n{\n        int palette_index = 0;\n        ivec2 fetch_pos = ivec2( uv * bitmap_size );\n        palette_index = getPaletteIndexXY( fetch_pos );\n        return palette_index;\n}\n\nvec4 getColorFromPalette( in int palette_index )\n{\n        int int_color = palette[ palette_index ];\n        return vec4( float( int_color & 0xff ) / 255.0,\n                                float( ( int_color >> 8 ) & 0xff) / 255.0,\n                                float( ( int_color >> 16 ) & 0xff) / 255.0,\n                                0 );\n}\n\nvec4 getBitmapColor( in vec2 uv )\n{\n        return getColorFromPalette( getPaletteIndex( uv ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   // vec2 uv = fragCoord / bitmap_size;\n    vec2 uv = fragCoord.xy  / iResolution.xy ;\n    \n    fragColor = getBitmapColor( uv );\n    //if (fragCoord.y > 70. || fragCoord.x > 160.) \n       // fragColor = vec4(0,1,1,1);\n}","name":"Buffer A","description":"","type":"buffer"}]}