{"ver":"0.1","info":{"id":"XsGGDW","date":"1454474242","viewed":254,"name":"Constant Step Size Raymarcher","username":"VoidChicken","description":"A simple raymarcher. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define acc 20.0\n#define lac 2.0\nvec4 spheres[5];\nvec2 cyl = vec2(10, -25);\nfloat cyl_rad = 2.0;\n#define FOG vec3(1,1,1)\n#define F false\n#define RLF false\n#define RL true\n#define R false\n#define L false\n#define BOUNCE_COUNT 2\nbool i_sect_cyl(vec3 v, out vec3 norm, out vec3 r_hit) {\n    vec3 pos_c = vec3(cyl.x, v.y, cyl.y);\n    vec3 h = v-pos_c;\n    vec3 n = normalize(h);\n    norm = n;\n    r_hit = pos_c + (n*cyl_rad);\n    norm = normalize(r_hit-pos_c);\n   \treturn length(h)<cyl_rad;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nfloat intensity =50.0;\nvec3 light= vec3(-10, 1, 5);\nbool intersect (vec3 v, out vec3 norm, out vec3 r_hit) {\n    for (int i = 0; i < 5; i++) {\n        if (length(v-spheres[i].xyz)<spheres[i].w) {\n            norm = v-spheres[i].xyz;\n            r_hit = spheres[i].xyz + (norm*spheres[i].w);\n            norm = r_hit-spheres[i].xyz;\n            return true;\n        }\n    }\n    if (v.y < -10.0) {\n        norm = vec3(0, 1, 0);\n        r_hit = vec3(v.x, -10, v.z);\n    \treturn true;   \n    }\n    if (v.y > 10.0) {\n        r_hit = vec3(v.x, 10, v.z);\n        norm = vec3(0, -1, 0);\n    \treturn true;  \n  \n  \t}\n    return i_sect_cyl(v, norm, r_hit);\n}\nbool lray (vec3 start, vec3 direction) {\n    vec3 nd = normalize(direction);\n    for (float i = 1.0; i < 50.0; i+=1.0/lac) {\n    \tvec3 p = start+nd*i;\n        vec3 norm = vec3(0);\n        vec3 r_hit = vec3(0);\n        bool a = intersect(p, norm, r_hit);\n       \tif (a) return true;\n    }\n    return false;\n}\nfloat m1(float a) {\n\treturn a==0.0?1.0:a;   \n}\nbool rayShoot(vec3 str, vec3 dnr, out vec3 hit, out vec3 nor, out float iv) {\n    vec3 nd = normalize(dnr);\n    \n    for (float i = 0.0; i < 50.0; i+=1.0/acc) {\n    \tvec3 p = str+nd*i;\n        vec3 norm = vec3(0);\n        vec3 r_hit = vec3(0);\n        bool a = intersect(p, norm, r_hit);\n        nor = norm;\n        hit = p; iv = i;\n        if (a)return a;\n    }\n    return false;\n}\n//_ray() is ray(). this is so it wont give a recursive function error.\nvec3 _ray(vec3 start, vec3 direction) {\n\t\tvec3 p;\n    \tvec3 norm;\n    \tfloat i;\n    \tbool a = rayShoot(start, direction, p, norm, i);\n        if (a) {\n            \n            bool j = lray(p, light-p);\n            float l = dot(norm,normalize(light-p))*(j?0.0:1.0);\n            l*=(1.0/m1(length(light-p)))*intensity;\n            vec3 fog = FOG*((50.0-i)/50.0); //FOG: new fog\n        \tvec3 ref = texture(iChannel3, reflect(direction,norm)*vec3(1,-1,1)).xyz;\n            if (RLF) return ((ref*l)/2.0)+(fog/2.0); // fog, reflective lighting - fifth\n            if (F) return fog; // fog, alone nothing other - fourth\n            if (R) return ref; //reflective objects, no lighting - first\n            if (RL) return ref*l; //reflective objects, with lighting - second\n            if (L) return l*vec3(1);//diffuse,  lighting - third\n     \t\treturn ref*l;\n        }\n   // return vec3(1);\n    return texture(iChannel3, direction*vec3(1,-1,1)).xyz;\n}\nvec3 ray (vec3 start, vec3 direction) {\n    \tvec3 p;\n    \tvec3 norm;\n    \tfloat i;\n    \tbool a = rayShoot(start, direction, p, norm, i);\n        if (a) {\n            \n            bool j = lray(p, light-p);\n            float l = dot(norm,normalize(light-p))*(j?0.0:1.0);\n            l*=(1.0/m1(length(light-p)))*intensity;\n            vec3 fog = FOG*((50.0-i)/50.0); //FOG: new fog\n        \tvec3 ref = texture(iChannel3, reflect(direction,norm)*vec3(1,-1,1)).xyz;\n            vec3 bounce = vec3(0);\n            for (int i = 0; i < BOUNCE_COUNT; i++) {\n            \tbounce += _ray(p+reflect(direction,norm), reflect(direction,norm));\n            }\n            bounce/= float(BOUNCE_COUNT);\n            if (RLF) return ((ref*l)/2.0)+(fog/2.0)*bounce; // fog, reflective lighting - fifth\n            if (F) return fog; // fog, alone nothing other - fourth\n            if (R) return ref+bounce; //reflective objects, no lighting - first\n            if (RL) return (ref*l+bounce)/float(BOUNCE_COUNT+1); //reflective objects, with lighting - second\n            if (L) return l*vec3(1);//diffuse,  lighting - third\n            return bounce;\n        }\n    \t\n    return texture(iChannel3, direction*vec3(1,-1,1)).xyz;\n}\nfloat moda (float a, float b) {\n\treturn ((a/b)*b) - (a/b);   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0] = vec4(0, 0, 0, 2);\n    spheres[1] = vec4(1, 3, 2, 2);\n    spheres[2] = vec4(2, 6, 2, 3);\n    spheres[3] = vec4(6, 0, -25, 2);\n    spheres[4] = vec4(0, 2, 1, .8);\n    cyl_rad+=sin(time);\n    light.x+=cos(time)*15.0;\n    light.z+=sin(time)*15.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 dir = vec3((uv.xy-vec2(.5, .5))*vec2(1.75, 1), 1);\n    vec4 rotDir = vec4(dir, 1) * rotationMatrix(vec3(0,1,0), time/10.0);\n\tfragColor = vec4(ray(vec3(0, 1, -15.0), vec3(rotDir)), 1);\n}","name":"Image","description":"","type":"image"}]}