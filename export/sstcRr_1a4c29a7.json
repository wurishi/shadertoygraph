{"ver":"0.1","info":{"id":"sstcRr","date":"1652987209","viewed":153,"name":"Voxelized Clifford Torus in S3","username":"Koulatko","description":".","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","raytracing","voxels","torus","sphere","4d","noneuclidean"],"hasliked":0,"parentid":"NdsyW4","parentname":"3spherevoxels"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define chunk_size 16.0\n\nint chunk_in(vec4 p){\n    vec4 a = abs(p);\n    float mcomp = max(a.x, max(a.y, max(a.z, a.w)));\n    if(a.w == mcomp){\n        return 0 + 4*int(max(0.0, sign(-p.w)));\n    }\n    if(a.x == mcomp){\n        return 1 + 4*int(max(0.0, sign(-p.x)));\n    }\n    if(a.y == mcomp){\n        return 2 + 4*int(max(0.0, sign(-p.y)));\n    }\n    if(a.z == mcomp){\n        return 3 + 4*int(max(0.0, sign(-p.z)));\n    }\n}\n\nmat4 chunk_transform(int a, int b){ //from b to a\n    float opp = 1.0;\n    \n    if(a >= 4) {a -= 4; opp *= -1.0;}\n    if(b >= 4) {b -= 4; opp *= -1.0;}\n    \n    mat4 from_pW[4] = mat4[](\n    mat4(1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.,0.,0.,0.,0.,1.),\n    mat4(\n    0.0, 0.0, 0.0,-1.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    1.0, 0.0, 0.0, 0.0\n    ),\n    mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0,-1.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 1.0, 0.0, 0.0\n    ),\n    mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 0.0,-1.0,\n    0.0, 0.0, 1.0, 0.0\n    )\n    );\n    \n    mat4 res = inverse(from_pW[b])*from_pW[a];\n    \n    return opp*res;\n}\nconst vec3 directions[6] = vec3[](\n    vec3(1.,0.,0.),\n    vec3(0.,1.,0.),\n    vec3(0.,0.,1.),\n   -vec3(1.,0.,0.),\n   -vec3(0.,1.,0.),\n   -vec3(0.,0.,1.)\n);\nint antipodal_chunk(int chunk){\n    if(chunk > 3) return chunk-4;\n    return chunk+4;\n}\nint get_neighbor(int chunk, int dir){\n    int table[24] = int[](\n    1,2,3,5,6,7,\n    4,2,3,0,6,7,\n    1,4,3,5,0,7,\n    1,2,4,5,6,0\n    );\n    int ind = 6*chunk+dir;\n    int res = table[ind%24];\n    if(ind >= 24) res = antipodal_chunk(res);\n    return res;\n}\n\nfloat voxelmap(vec3 z, int chunk){\n    //if(chunk != 0) return 0.0;\n    z = floor(z);\n    \n    if(z.x < -chunk_size || z.x > chunk_size-1. || z.y < -chunk_size || z.y > chunk_size-1. || z.z < -chunk_size || z.z > chunk_size-1.) return -1.0;\n    \n    vec4 Z = chunk_transform(chunk, 0)*gnomonic_to_sphere3((z+0.5)/chunk_size);\n    \n    \n    return dot(Z.zw,Z.zw) > 0.5 ? 1. : 0.;\n    \n    \n    float alt = 1.4+0.2*cos(Z.x*10.0);\n    alt = 1.5+0.2*snoise(Z);\n    \n    return alt-acos(Z.w);\n    \n    //return 0.3-length(Z.xy);\n    \n    float A = 0.1*iTime;\n    vec4 spos = vec4(cos(A), 0.0, 0.0, sin(A));\n    return dot(Z, spos)-0.8;\n    \n    //return 3.0-length(z);\n    return length(z)-9.0;\n    \n    vec3 circle = vec3(0.0, 10.0*normalize(vec2(z.yz)));\n    \n    return 3.5 - distance(z, circle);\n}\n\nvec4 ray_voxelmap_euclid(vec3 ro, vec3 rd, int chunk, out int block_type, out vec3 block_rel){\n    const float epsilon = 0.00001;\n    float depth = 0.0;\n    float stepsize = 1.0;\n    for(int i = 0; i < 100; i++){\n        vec3 p = fract(ro + (depth)*rd);\n        vec3 o = 1.0 - max(vec3(0.0), sign(-rd));\n        float q1 = min(\n            -(p.x-o.x)/rd.x,\n            min(\n            -(p.y-o.y)/rd.y,\n            -(p.z-o.z)/rd.z\n            ));\n        float voxelsamp = voxelmap(ro + rd*(depth+q1+epsilon), chunk);\n        if(voxelsamp > 0.0){\n            vec3 N = floor(ro + rd*depth)-floor(ro + rd*(depth+q1+epsilon));\n            block_rel = fract(ro + rd*(depth+q1+epsilon));\n            block_type = int(voxelsamp);\n            return vec4(N, depth+q1-epsilon);\n        }\n        depth += q1+epsilon;\n    }\n    return vec4(0.0);\n}\n\n\n\nS3Hit ray_cell(vec4 ro, vec4 rd, int chunk, out int block_type, out vec3 block_rel){\n    S3Hit h1 = S3Hit(vec4(0.0), 0.0);\n    if(ro.w < 0.0001) return h1;\n    vec3 e_ro = sphere3_to_gnomonic(ro);\n    vec3 e_rd = normalize(sphere3_to_gnomonic_tan(ro, rd));\n\n\n    vec4 eh = (1./chunk_size)*ray_voxelmap_euclid(e_ro*chunk_size, e_rd, chunk, block_type, block_rel);\n    eh.w = abs(eh.w);\n    if(eh.w != 0.0){\n        h1.t = gnomonic_distance(e_ro, e_ro+eh.w*e_rd);\n        h1.N = gnomonic_to_sphere3_tan(e_ro+eh.w*e_rd, eh.xyz);\n    }\n    return h1;\n}\n\nS3Hit ray_blocks(vec4 ro, vec4 rd, out int block_type, out vec3 block_rel){\n    int chunk = chunk_in(ro);\n    \n    ro = chunk_transform(0, chunk)*ro;\n    rd = chunk_transform(0, chunk)*rd;\n    \n    S3Hit h = S3Hit(vec4(0.0), -1.0);\n    \n    float portal_distance_total = 0.0;\n    for(int i = 0; i < 9; i++){\n        S3Hit h1 = S3Hit(vec4(0.0), 0.0);\n\n        h1 = ray_cell(ro, rd, chunk, block_type, block_rel);\n        \n        h1.N = chunk_transform(chunk, 0)*h1.N;\n        \n        if(!(h1.t > 0.0)){\n        \n            float closest_portal_t = 1e20;\n            int hit_portal;\n\n            for(int j = 0; j < 6; j++){\n                vec3 dir = directions[j];\n                vec4 so = vec4(sqrt(0.5)*dir, -sqrt(0.5));\n                S3Hit ph = ray_sphere_spherical(ro, rd, so, 0.5*PI);\n                float pt = ph.t;\n                if(pt < closest_portal_t && ro.w*cos(pt) + rd.w*sin(pt) > 0.0 && dot(ro, so) < 0.0){\n                    closest_portal_t = pt;\n                    hit_portal = j;\n                }\n            }\n            portal_distance_total += closest_portal_t;\n            \n            int next_chunk = get_neighbor(chunk, hit_portal);\n            \n            closest_portal_t -= 0.001;\n            vec4 aeiou = cos(closest_portal_t)*ro + sin(closest_portal_t)*rd;\n            rd = -sin(closest_portal_t)*ro + cos(closest_portal_t)*rd;\n            ro = aeiou;\n            \n            \n            ro = chunk_transform(chunk, next_chunk)*ro;\n            rd = chunk_transform(chunk, next_chunk)*rd;\n            \n            chunk = next_chunk;\n            \n        } else {\n            h = h1;\n            h.t += portal_distance_total;\n            break;\n        }\n    }\n    return h;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0.0);\n    vec2 ss = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec4 ro = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 rd = vec4(normalize(vec3(ss, -0.7)), 0.0);\n    \n    float T = iTime;\n    \n    float t2;\n    \n    mat4 camera_mat = mat4(\n        texelFetch(iChannel0, ivec2(0, 0), 0),\n        texelFetch(iChannel0, ivec2(1, 0), 0),\n        texelFetch(iChannel0, ivec2(2, 0), 0),\n        texelFetch(iChannel0, ivec2(3, 0), 0)\n        );\n        \n    vec4 o_ro = camera_mat*ro;\n    vec4 o_rd = camera_mat*rd;\n    \n\n    S3Hit h;\n    \n    int block_type = -10;\n    vec3 block_rel;\n    \n    S3Hit h1 = ray_blocks(o_ro, o_rd, block_type, block_rel);\n    if(!(h.t > 0.0) || (h1.t < h.t && h1.t > 0.0)) h = h1; \n    \n    float R = 0.4 + 0.05*cos(iTime);\n    \n    //h1 = ray_sphere_spherical(o_ro, o_rd, vec4(0.0, 0.0, 0.0, 1.0), 0.2);\n    if(!(h.t > 0.0) || (h1.t < h.t && h1.t > 0.0)) h = h1;\n    \n    if(h.t > 0.0){\n        col = vec3(0.5*h.t/PI);\n        //col = 0.5+0.5*normalize(vec3(dFdx(h.t), dFdy(h.t), 0.01));\n        col = 0.5+0.5*h.N.xyz;\n        \n        vec4 hpos = o_ro*cos(h.t) + o_rd*sin(h.t);\n        //col += 0.1*mod(floor(hpos.x)+floor(hpos.y)+floor(hpos.z)+floor(hpos.w), 2.0);\n        if(block_type >= 0){\n            col = (0.5+0.3*h.N.x)*(hpos.xyz*0.5+0.5)*mod(floor(block_rel.x*2.0)+floor(block_rel.y*2.0)+floor(block_rel.z*2.0), 2.0);\n        }\n        //col *= max(0.0, 1.0-h.t*h.t/PI);\n    }\n    \n    //col = debug*0.5+0.5;\n    int cam_chunk = chunk_in(o_ro);\n    //col += PrintValue(fragCoord, vec2(20.0), vec2(20.0), float(cam_chunk), 2.0, 0.0);\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// Prints numbers\n\n// Original version: https://www.shadertoy.com/view/4sBSWW\n\n// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Note that the values printed are not always accurate!\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n// Improved version\n//\n// Most important change is dropping everything left of the decimal point ASAP \n// when printing the fractional digits. This is done to bring the magnitule down\n// for the following division and modulo.\n//\n// Another change is to replace the logarithm with a power-of-ten value \n// calculation that is needed later anyway.\n// This change is optional, either one works.\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n\n\n//http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 matrix_from_axis_angle(vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n\n\n\n#define PI 3.14159265358979323\n#define TWOPI (2.0*PI)\n\nstruct S3Hit {\n    vec4 N;\n    float t;\n};\n\nvec3 conformal_disk_to_hyperboloid(vec2 p){\n    float t = 2.0/(1.0-dot(p, p));\n    return t*vec3(p, 1.0) - vec3(0.0, 0.0, 1.0);\n}\n\nvec2 hyperboloid_to_conformal_disk(vec3 H){\n    return H.xy/(H.z+1.0);\n}\n\nvec3 sphere3_to_gnomonic(vec4 p){\n    return p.xyz/p.w;  \n}\n\nvec3 sphere3_to_gnomonic_tan(vec4 p, vec4 d){\n    return (d.xyz*p.w - p.xyz*d.w)/(p.w*p.w);\n}\n\nvec4 gnomonic_to_sphere3(vec3 p){\n    return normalize(vec4(p, 1.0));\n}\nvec4 gnomonic_to_sphere3_tan(vec3 p, vec3 d){ //TODO actually calculate the derivative\n    return normalize(gnomonic_to_sphere3(p+0.0001*d)-gnomonic_to_sphere3(p));\n}\n\n\nfloat gnomonic_distance(vec3 a, vec3 b){\n    vec4 a_s = gnomonic_to_sphere3(a);\n    vec4 b_s = gnomonic_to_sphere3(b);\n    return acos(dot(a_s, b_s));\n}\n\n\n\n\n\n\n\nvec2 solve_sin_cos_linear_combination(float a, float b, float c){\n\tfloat ba = b/a;\n\tfloat A = atan(ba);\n\tfloat B = acos(c/(a*sqrt(1.+ba*ba)));\n\treturn A+vec2(-B, B);\n}\n\nS3Hit ray_sphere_spherical(vec4 ro, vec4 rd, vec4 O, float R){\n    vec2 s = solve_sin_cos_linear_combination(dot(ro, O), dot(rd, O), cos(R));\n    s = mod(s, 2.*PI);\n    float t = min(s.x, s.y);\n    vec4 H = cos(t)*ro + sin(t)*rd;\n    vec4 N = H - O;\n    N -= N*dot(N, H);\n    N = normalize(N);\n    return S3Hit(N, t);\n}\n\nvec4 ray_sphere_euclid(vec3 ro, vec3 rd, vec3 O, float r){\n    ro -= O;\n    float b = -dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float d = b*b-c;\n    if(d < 0.0) return vec4(-1.0);\n    float h = sqrt(d);\n    float t = b < h ? b+h : b-h;\n    return vec4((ro+t*rd)/r, t);\n}\n\nmat4 qmat4(vec4 q){\n    return mat4(\n    q.w*q.w+q.x*q.x-q.y*q.y-q.z*q.z,\n    2.*(q.x*q.y+q.w*q.z),\n    2.*(q.x*q.z-q.w*q.y),\n    0.0,\n    2.*(q.x*q.y-q.w*q.z),\n    q.w*q.w-q.x*q.x+q.y*q.y-q.z*q.z,\n    2.*(q.y*q.z+q.w*q.x),\n    0.0,\n    2.*(q.x*q.z+q.w*q.y),\n    2.*(q.y*q.z-q.w*q.x),\n    q.w*q.w-q.x*q.x-q.y*q.y+q.z*q.z,\n    0.0,\n    0.0,0.0,0.0,1.0\n    );\n}\n\n\nvec4 qmul(vec4 a, vec4 b){\n    return vec4(a.w*b.xyz + b.w*a.xyz + cross(a.xyz, b.xyz), a.w*b.w - dot(a.xyz, b.xyz));\n}\n\nvec3 qapply(vec3 v, vec4 q){\n    return v + 2.*cross(q.xyz, cross(q.xyz, v)+q.w*v);\n}\n\n\nvec4 quat_from_2(vec3 a, vec3 b){\n    vec4 q;\n    vec3 c = cross(a,b);\n    q.xyz = c;\n    q.w = sqrt(dot(a,a) * dot(b,b)) + dot(a,b);\n    return normalize(q);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//TODO figure out a cleaner representation of SO(4) than mat4\n//^finished in another shader but too lazy to implement here\n\nmat4 update_camera_matrix(mat4 cur){\n    mat4 m = mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);\n    if(iFrame == 0){\n        return mat4(\n    0.0, 0.0, 0.0,-1.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    1.0, 0.0, 0.0, 0.0\n    );\n    }\n    \n    \n    float W = texelFetch(iChannel1, ivec2(87, 0), 0).x;\n    float S = texelFetch(iChannel1, ivec2(83, 0), 0).x;\n    float A = texelFetch(iChannel1, ivec2(65, 0), 0).x;\n    float D = texelFetch(iChannel1, ivec2(68, 0), 0).x;\n    float space = texelFetch(iChannel1, ivec2(32, 0), 0).x;\n    float shift = texelFetch(iChannel1, ivec2(16, 0), 0).x;\n    \n    vec4 prev_mouse = texelFetch(iChannel0, ivec2(0, 1), 0);\n    \n    \n    float camera_angular_speed = 0.5*iTimeDelta;\n    if(W > 0.5){\n        m = mat4(\n            1.0, 0.0, 0.0, 0.0, \n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, cos(-camera_angular_speed), -sin(-camera_angular_speed),\n            0.0, 0.0, sin(-camera_angular_speed), cos(-camera_angular_speed)\n        )*m;\n    }\n    if(S > 0.5){\n        m = mat4(\n            1.0, 0.0, 0.0, 0.0, \n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, cos(camera_angular_speed), -sin(camera_angular_speed),\n            0.0, 0.0, sin(camera_angular_speed), cos(camera_angular_speed)\n        )*m;\n    }\n    if(D > 0.5){\n        m = mat4(\n            cos(camera_angular_speed), 0.0, 0.0, -sin(camera_angular_speed), \n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            sin(camera_angular_speed), 0.0, 0.0, cos(camera_angular_speed)\n        )*m;\n    }\n    if(A > 0.5){\n        m = mat4(\n            cos(-camera_angular_speed), 0.0, 0.0, -sin(-camera_angular_speed), \n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            sin(-camera_angular_speed), 0.0, 0.0, cos(-camera_angular_speed)\n        )*m;\n    }\n    \n    \n    vec2 off = - 1.5*vec2(1.0,-1.0)*(iMouse.xy - prev_mouse.xy)/iResolution.y;\n                \n    vec3 right   = vec3(1.0, 0.0, 0.0);\n    vec3 up      = vec3(0.0, 1.0, 0.0);\n    vec3 forward = vec3(0.0, 0.0,-1.0);\n\n    if(off != vec2(0.0) && prev_mouse.z > 0.5){\n        vec3 axis = normalize(off.y*right + off.x*up);\n        float ang = length(off.y*right + off.x*up);\n        m = matrix_from_axis_angle(axis, -ang)*m;\n    }\n    \n    cur = cur*m;\n    \n    vec4 camera_pos = cur*vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 target_down = vec4(0.0, 0.0, 0.0, -1.0);\n    \n    //clifford torus ground\n    target_down = vec4(camera_pos.xy, 0.00001, 0.0);\n    \n    target_down -= camera_pos*dot(camera_pos, target_down);\n    target_down = normalize(target_down);\n    \n    \n    \n    vec4 target_down_rel = inverse(cur)*target_down;\n    \n    vec4 quat = quat_from_2(target_down_rel.xyz*vec3(0.0,1.0,1.0), target_down_rel.xyz);\n    \n    \n    cur = cur*qmat4(quat);\n    \n    return cur;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 fc = ivec2(fragCoord);\n    if(fc.y == 0 && fc.x >= 0 && fc.x < 4){\n        mat4 cur = mat4(\n        texelFetch(iChannel0, ivec2(0, 0), 0),\n        texelFetch(iChannel0, ivec2(1, 0), 0),\n        texelFetch(iChannel0, ivec2(2, 0), 0),\n        texelFetch(iChannel0, ivec2(3, 0), 0)\n        );\n        fragColor = update_camera_matrix(cur)[fc.x];\n    }\n    if(fc == ivec2(0, 1)){\n        fragColor = iMouse;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}