{"ver":"0.1","info":{"id":"DljXRz","date":"1675585992","viewed":76,"name":"fbm marble","username":"sjz1","description":"fbm marble","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fbm","marble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_SMOOTH_NOISE 1  // enable to prevent discontinuities\n\n\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 0\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, fract((p+vec2(0.5,0.5))/256.0), 0.0 ).x;\n\tfloat b = textureLod( iChannel0, fract((p+vec2(1.5,0.5))/256.0), 0.0 ).x;\n\tfloat c = textureLod( iChannel0, fract((p+vec2(0.5,1.5))/256.0), 0.0 ).x;\n\tfloat d = textureLod( iChannel0, fract((p+vec2(1.5,1.5))/256.0), 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\nconst mat2 m4 = mat2(0.8,-0.6,0.6,0.8);\nfloat fbm(vec2 p){\n    float t=0.;\n    const vec2 m1=vec2(-0.1,0.1);\n    const float m2=1.5;\n    const float s1=3.;\n    const float r=0.8;\n    const float m3=(1.-r)*(2.*m2\n        /(length(m1)+sqrt(dot(m1,m1)+m2)));\n    for(int i=0;i<10;i++){\n        vec2 p0=p;\n        vec2 s=noised(p).yz;\n        \n        p-=pow(r,float(i))*(s+m1)/(dot(s,s)+m2);\n        \n        t+=distance(p,p0);\n        p*=m4*s1;\n    \n    }\n    return t*m3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = mix(vec3(0.9),vec3(0.7,0.4,0.1)*0.8,\n        fbm(uv*2.+iTime*0.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}