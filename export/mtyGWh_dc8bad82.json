{"ver":"0.1","info":{"id":"mtyGWh","date":"1683897740","viewed":95,"name":"Simple shading","username":"Rebollo55","description":"Simple shader for basic lighting","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["phong","shadow","lighting","testing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Set mouseOn to 1 to move the camera with the mouse\n#define mouseOn 0\n#define mouseSen 2.f\n#define movingLight 1\n#define NumPlanes 1\n#define NumSpheres 4\n#define t_max 20.f\n#define shadowTh 0.8f\n\n// Constants\n#define Pi 3.14159265359f\n\nstruct Plane{\n    // Horizontal plane heigth\n    float y;\n    \n    vec3 color;\n};\n\nstruct Sphere{\n    // Radius\n    float r;\n    // Center\n    vec3 c;\n    \n    vec3 color;\n};\n\nstruct Camera{\n    // Position\n    vec3 pos;\n    // Projection angle\n    float projAng;\n};\n\nstruct Light{\n    // Position\n    vec3 pos;\n    // Decay\n    float lin;\n    float quad;\n};\n\nstruct Scenary{\n    Plane planes[NumPlanes];\n    Sphere spheres[NumSpheres];\n    Camera camera;\n    Light light;\n};\n\nScenary Scene;\nvoid initializeScene() {\n    Scene.planes[0].y = 0.f;\n    Scene.planes[0].color = vec3(1.0);\n    Scene.spheres[0].r = 0.6f;\n    Scene.spheres[0].c = vec3(-1.f,0.6f,6.f);\n    Scene.spheres[0].color = vec3(1.f,0.f,0.f);\n    Scene.spheres[1].r = 0.6f;\n    Scene.spheres[1].c = vec3(1.f,0.6f,6.f);\n    Scene.spheres[1].color = vec3(0.f,0.f,1.f);\n    Scene.spheres[2].r = 0.6f;\n    Scene.spheres[2].c = vec3(3.f,0.6f,7.f);\n    Scene.spheres[2].color = vec3(0.f,1.f,0.f);\n    Scene.spheres[3].r = 0.6f;\n    Scene.spheres[3].c = vec3(-3.f,0.6f,7.f);\n    Scene.spheres[3].color = vec3(1.f,1.f,0.3f);\n    Scene.camera.pos = vec3(0.0f, 1.2f, -0.2f);\n    Scene.camera.projAng = 45.f*Pi/180.f;\n    if(movingLight == 1){\n        Scene.light.pos = vec3(3.f*cos(iTime), 2.f, 3.f*sin(iTime)) +\n            vec3(0.f, 0.f, 6.f);\n    }\n    else{\n        Scene.light.pos = vec3(1.f, 1.f, 2.0f);\n    }\n    Scene.light.lin = 0.06f;\n    Scene.light.quad = 0.002f;\n}\n\n\nvec3 Render(vec2 uv);\nfloat Phong(vec3 normal, vec3 ldir, vec3 obsdir, float dist);\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initializeScene();\n    \n    if(mouseOn == 1){\n        // Update camera positon with respect to input\n        Scene.camera.pos += \n            vec3((iMouse.xy/iResolution.xy - 0.5f)*mouseSen,-0.f);\n    }\n    \n    // Dimension scaling\n    float sigma = iResolution.y/iResolution.x;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5f;\n    uv.x = uv.x/sigma;\n    \n    // Render the scene\n    vec3 col = Render(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// Returns point color\nvec3 Render(vec2 uv){\n    float tbuff = t_max; // Depth buffer\n    // Distance to render plane\n    float d = 1.f/(2.f * tan(Scene.camera.projAng/2.f));\n    // Origin point\n    vec3 x1 = Scene.camera.pos;\n    // Point to render in the view plane\n    vec3 x2 = vec3(uv + Scene.camera.pos.xy, d + Scene.camera.pos.z);\n    // Intersection point\n    vec3 rCol = vec3(0.1f); // By default to the origin point\n    \n    // Intersect with planes\n    for(int i = 0; i < NumPlanes; i++){\n        float t_int = (Scene.planes[i].y - x1.y)/(x2.y - x1.y);\n        if((t_int < t_max)&&(t_int > 0.f)){\n            vec3 x_int = x1 + (x2 - x1)*t_int;\n            vec3 normal = vec3(0.f, 1.f, 0.f);\n            vec3 ldir = normalize(x_int - Scene.light.pos);\n            vec3 obsdir = normalize(x_int - x1);\n            float dist = length(x_int - Scene.light.pos);\n            rCol = Phong(normal, ldir, obsdir, dist)*Scene.planes[i].color;\n            // Compute shadows\n            for(int j = 0; j < NumSpheres; j++){\n                vec3 c = Scene.spheres[j].c;\n                float r = Scene.spheres[j].r;\n                vec3 lc = Scene.light.pos;\n                vec3 vc = x1 + (x2 - x1)*t_int;\n                // Compute the discriminant\n                float disc = pow(dot((vc-lc),(lc - c)),2.f) -\n                    dot(vc-lc,vc-lc) * (dot(lc-c,lc-c) - pow(r,2.f));\n                float s_int = (-dot(vc-lc,lc-c)-sqrt(disc))/dot(vc-lc,vc-lc);\n                if(disc >= 0.f && s_int > 0.f){\n                    // Smooth the shadow;\n                    rCol = rCol*(1.f-smoothstep(0.f,2.f*shadowTh,disc));\n                }\n            }\n            tbuff = t_int;\n        }\n    }\n    \n    // Intersect with spheres\n    for(int i = 0; i < NumSpheres; i++){\n        vec3 c = Scene.spheres[i].c;\n        float r = Scene.spheres[i].r;\n        // Compute the discriminant\n        float disc = pow(dot((x2-x1),(x1 - c)),2.f) -\n            dot(x2-x1,x2-x1) * (dot(x1-c,x1-c) - pow(r,2.f));\n        if(disc >= 0.f){\n            // Compute the intersection point\n            float t_int = (-dot(x2-x1,x1-c)-sqrt(disc))/dot(x2-x1,x2-x1);\n            if(t_int < tbuff){\n                tbuff = t_int;\n                // Draw and shade sphere\n                vec3 x_int = x1 + (x2 - x1)*t_int;\n                vec3 normal = normalize(x_int - c);\n                vec3 ldir = normalize(x_int - Scene.light.pos);\n                vec3 obsdir = normalize(x_int - x1);\n                float dist = length(x_int - Scene.light.pos);\n                rCol = Phong(normal, ldir, obsdir, dist)*Scene.spheres[i].color;\n                // Compute shadows\n                for(int j = 0; j < NumSpheres; j++){\n                    if(i == j){\n                        continue;\n                    }\n                    vec3 c = Scene.spheres[j].c;\n                    float r = Scene.spheres[j].r;\n                    vec3 lc = Scene.light.pos;\n                    vec3 vc = x1 + (x2 - x1)*t_int;\n                    // Compute the discriminant\n                    float disc = pow(dot((vc-lc),(lc - c)),2.f) -\n                        dot(vc-lc,vc-lc) * (dot(lc-c,lc-c) - pow(r,2.f));\n                    float s_int = (-dot(vc-lc,lc-c)-sqrt(disc))/dot(vc-lc,vc-lc);\n                    if(disc >= 0.f && s_int > 0.f && s_int < 1.f){\n                        // Smooth the shadow;\n                        rCol = rCol*(1.f-smoothstep(0.f,2.f*shadowTh,disc));\n                    }\n                }\n            }\n        }\n    }\n    \n    // Draw light as a white sphere\n    // Generate a smooth effect\n    vec3 c = Scene.light.pos;\n    float r = 0.2f;\n    // Compute the discriminant\n    float disc = pow(dot((x2-x1),(x1 - c)),2.f) -\n        dot(x2-x1,x2-x1) * (dot(x1-c,x1-c) - pow(r,2.f));\n    if(disc >= 0.f){\n        rCol = vec3(1.f)*50.f*disc;\n    }\n    \n    return rCol;\n}\n\n// Apply Phong shading\nfloat Phong(vec3 normal, vec3 ldir, vec3 obsdir, float dist){\n    // Ambient\n    float amb = 0.2f;\n    // Diffuse\n    float diff = 0.6f*max(dot(normal, -ldir),0.f);\n    // Specular\n    vec3 lref = ldir - 2.f*dot(ldir, normal)*normal;\n    float spcbias = max(dot(obsdir,-lref),0.f);\n    float spec = 0.8f*pow(spcbias,8.f);\n    return (amb + diff + spec)/\n    (1.f + Scene.light.lin*dist + Scene.light.quad*pow(dist,2.f));\n}","name":"Image","description":"","type":"image"}]}