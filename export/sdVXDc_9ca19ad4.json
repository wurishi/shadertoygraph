{"ver":"0.1","info":{"id":"sdVXDc","date":"1635463972","viewed":202,"name":"Symbols23","username":"edwardbraed","description":"Method a render ascii (or any others) symbols without texture maps (see drawASCIIChar function).\nWith triplanar postprocess.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["text","triplanar","ascii","fonts","characters","symbols"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#undef __\n\nvec3 sampleBlur(sampler2D tex, vec2 uv, vec2 k)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    vec3 avg = vec3(0.0);\n    vec2 hk = k * 0.5;\n    for(float x = 0.0 - hk.x; x < hk.x; x += 1.0)\n    {\n        for(float y = 0.0 - hk.y; y < hk.y; y += 1.0)\n            avg += texture(tex, uv + s * vec2(x,y)).rgb;\n    }\n    return avg / (k.x * k.y);\n}\n\nvec3 triplanar(sampler2D tex, vec2 uv)\n{\n    const vec2 k = vec2(4.0);\n    vec2 ts = vec2(0.001, 0.004); // texel step\n    float t1 = sampleBlur(tex, uv + vec2( 1.0,  0.0) * ts, k).r;\n    float t2 = sampleBlur(tex, uv + vec2(-1.0,  0.0) * ts, k).r;\n    float t3 = sampleBlur(tex, uv + vec2( 0.0,  1.0) * ts, k).r;\n    float t4 = sampleBlur(tex, uv + vec2( 0.0, -1.0) * ts, k).r;\n    \n    const float p = 2.0;\n    float b1 = 0.3 + (t1 * p - t2 * p); // left bevel\n    float b2 = 0.3 + (t3 * p - t4 * p); // top  bevel\n    \n    vec3 r = (1.0 - b1) * vec3( 1.0,  0.0, 1.0); // triplanar multiply\n    vec3 l =        b1  * vec3(-1.0,  0.0, 1.0);\n    vec3 t = (1.0 - b2) * vec3( 0.0,  1.0, 1.0);\n    vec3 d =        b2  * vec3( 0.0, -1.0, 1.0);\n    \n    return normalize(r + l + t + d); // result normal\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float v = texture(iChannel0, uv).r;\n    \n    vec3 col = vec3(v);\n    float t = (sin(iTime * 0.5) + 1.0);\n    if(t > uv.x || t > uv.y)\n    {\n        vec3 n = triplanar(iChannel0, uv);\n        vec3 ld = vec3(1.0, 0.3, 0.2);\n        float ad = 0.1 + dot(ld, n);\n        col = max(v * 0.8, ad) * vec3(1.0, 0.7, 1.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*   /* 0        */ #define __ 32\n/* ! /* 4329476  */ #define _EXC 33\n/* \" /* 10813440 */ #define _DQT 34\n/* # /* 11512810 */ #define _LAT 35\n/* $ /* 31636111 */ #define _DOL 36\n/* % /* 18092113 */ #define _PER 37\n/* & /* 6339118  */ #define _AMP 38\n/* ' /* 4325376  */ #define _SQT 39\n/* ( /* 4261956  */ #define _LBR 40\n/* ) /* 4464900  */ #define _RBR 41\n/* * /* 12582912 */ #define _AST 42\n/* + /* 145536   */ #define _PLS 43\n/* , /* 130      */ #define _COM 44\n/* - /* 14336    */ #define _HYP 45\n/* . /* 4        */ #define _DOT 46\n/* / /* 17043521 */ #define _SLA 47\n/* 0 /* 33080895 */ #define _0 48\n/* 1 /* 4396164  */ #define _1 49\n/* 2 /* 33061951 */ #define _2 50\n/* 3 /* 33062431 */ #define _3 51\n/* 4 /* 18415120 */ #define _4 52\n/* 5 /* 32570911 */ #define _5 53\n/* 6 /* 32570943 */ #define _6 54\n/* 7 /* 33038468 */ #define _7 55\n/* 8 /* 33095231 */ #define _8 56\n/* 9 /* 33095199 */ #define _9 57\n/* : /* 131200   */ #define _COL 58\n/* ; /* 131202   */ #define _SEM 59\n/* < /* 16911504 */ #define _LES 60\n/* = /* 1016800  */ #define _EQU 61\n/* > /* 1269953  */ #define _GRE 62\n/* ? /* 15216644 */ #define _QUE 63\n/* @ /* 15246428 */ #define _AT 64\n/* A /* 4540401  */ #define _A 65\n/* B /* 16301615 */ #define _B 66\n/* C /* 15238702 */ #define _C 67\n/* D /* 16303663 */ #define _D 68\n/* E /* 32570431 */ #define _E 69\n/* F /* 32570401 */ #define _F 70\n/* G /* 31520302 */ #define _G 71\n/* H /* 18415153 */ #define _H 72\n/* I /* 14815374 */ #define _I 73\n/* J /* 14950662 */ #define _J 74\n/* K /* 18128177 */ #define _K 75\n/* L /* 1082431  */ #define _L 76\n/* M /* 11195953 */ #define _M 77\n/* N /* 18470705 */ #define _N 78\n/* O /* 15255086 */ #define _O 79\n/* P /* 16301089 */ #define _P 80\n/* Q /* 15255000 */ #define _Q 81\n/* R /* 16301617 */ #define _R 82\n/* S /* 31504911 */ #define _S 83\n/* T /* 32641156 */ #define _T 84\n/* U /* 18400814 */ #define _U 85\n/* V /* 18400580 */ #define _V 86\n/* W /* 18405034 */ #define _W 87\n/* X /* 18157905 */ #define _X 88\n/* Y /* 18157700 */ #define _Y 89\n/* Z /* 32772191 */ #define _Z 90\n/* [ /* 6359110  */ #define _LQB 91\n/* \\ /* 1118480  */ #define _ISL 92\n/* ] /* 12853516 */ #define _RQB 93\n/* ^ /* 4521984  */ #define _CIR 94\n/* _ /* 31       */ #define _UNS 95\n/* ` /* 2097152  */ #define _GRA 96\n/* a /* 207306   */ #define _a 97\n/* b /* 1088807  */ #define _b 98\n/* c /* 459822   */ #define _c 99\n/* d /* 17330780 */ #define _d 100\n/* e /* 13203548 */ #define _e 101\n/* f /* 8534148  */ #define _f 102\n/* g /* 4534534  */ #define _g 103\n/* h /* 2169162  */ #define _h 104\n/* i /* 4198532  */ #define _i 105\n/* j /* 401668   */ #define _j 106\n/* k /* 75978    */ #define _k 107\n/* l /* 135300   */ #define _l 108\n/* m /* 513717   */ #define _m 109\n/* n /* 477778   */ #define _n 110\n/* o /* 412236   */ #define _o 111\n/* p /* 477634   */ #define _p 112\n/* q /* 412560   */ #define _q 113\n/* r /* 921732   */ #define _r 114\n/* s /* 12652806 */ #define _s 115\n/* t /* 4657288  */ #define _t 116\n/* u /* 608860   */ #define _u 117\n/* v /* 574788   */ #define _v 118\n/* w /* 579242   */ #define _w 119\n/* x /* 331914   */ #define _x 120\n/* y /* 602242   */ #define _y 121\n/* z /* 991390   */ #define _z 122\n/* { /* 4264004  */ #define _LFB 123\n/* | /* 4329604  */ #define _VLN 124\n/* } /* 4460804  */ #define _RFB 125\n/* ~ /* 87296    */ #define _TIL 126\n\n#define MAX_LENGTH 16\n#define IARR int[MAX_LENGTH]\n\nstruct istr\n{\n    IARR data;\n    int  sz;\n};\n\n#define MKSTR2(c0, c1) istr(IARR(c0, c1, 0,0,0,0,0,0,0,0,0,0,0,0,0,0), 2)\n#define MKSTR3(c0, c1, c2) istr(IARR(c0, c1, c2,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 3)\n#define MKSTR4(c0, c1, c2, c3) istr(IARR(c0, c1, c2, c3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 4)\n#define MKSTR5(c0, c1, c2, c3, c4) istr(IARR(c0, c1, c2, c3, c4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 5)\n#define MKSTR6(c0, c1, c2, c3, c4, c5) istr(IARR(c0, c1, c2, c3, c4, c5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 6)\n#define MKSTR7(c0, c1, c2, c3, c4, c5, c6) istr(IARR(c0, c1, c2, c3, c4, c5, c6, 0, 0, 0, 0, 0, 0, 0, 0, 0), 7)\n#define MKSTR8(c0, c1, c2, c3, c4, c5, c6, c7) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, 0, 0, 0, 0, 0, 0, 0, 0), 8)\n#define MKSTR9(c0, c1, c2, c3, c4, c5, c6, c7, c8) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, c8, 0, 0, 0, 0, 0, 0, 0), 9)\n#define MKSTR10(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, 0, 0, 0, 0, 0, 0), 10)\n#define MKSTR11(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, 0, 0, 0, 0, 0), 11)\n#define MKSTR12(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, 0, 0, 0, 0), 12)\n#define MKSTR13(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, 0, 0, 0), 13)\n#define MKSTR14(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, 0, 0), 14\n#define MKSTR15(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, 0), 15)\n#define MKSTR16(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15) istr(IARR(c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15), 16)\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float drawASCIIChar(vec2 uv, vec2 pos, vec2 sz, int id)\n{\n    id = id - 32; // ascii correction (first 32 chars is invisible!!)\n    // 5x5 bitmaps\n    const int[] glyphs = int[95]\n    ( \n     0, 4329476, 10813440, 11512810, 31636111, 18092113, 6339118, 4325376, 4261956, \n     4464900, 12582912, 145536, 130, 14336, 4, 17043521, 33080895, 4396164, 33061951, \n     33062431, 18415120, 32570911, 32570943, 33038468, 33095231, 33095199, 131200, 131202,\n     17173904, 1016800, 1269953, 15216644, 15246428, 4540401, 16301615, 15238702, 16303663, \n     32570431, 32570401, 31520302, 18415153, 14815374, 14950662, 18128177, 1082431, \n     11195953, 18470705, 15255086, 16301089, 15255000, 16301617, 31504911, 32641156,\n     18400814, 18400580, 18405034, 18157905, 18157700, 32772191, 6359110, 1118480,\n     12853516, 4521984, 31, 2097152, 207306, 1088807, 459822, 17330780, 13203548,\n     8534148, 4534534, 2169162, 4198532, 467206, 75978, 135300, 513717, 477778, 412236, \n     477634, 412560, 921732, 12652806, 4657288, 608860, 574788, 579242, 331914, 602242,\n     991390, 4264004, 4329604, 4460804, 87296 \n    );\n    vec2 pt = (uv - pos) * (vec2(1.0) / sz) - vec2(0.1, 0.1);\n    ivec2 xy = ivec2(round(pt * vec2(4.5, 5.0)));\n    float gv = float((glyphs[id] >> int(xy.y * 5 + xy.x)) & 1);\n    \n\treturn gv * float(pt.x < 1.0 && pt.y < 1.0 &&\n                      uv.x > pos.x && uv.y > pos.y);\n}\n\nfloat drawASCIILine(vec2 uv, vec2 pos, vec2 sz, istr str)\n{\n    float res = 0.0;\n    float s = sz.x * 0.4; // step between glyphs\n    for(int x = 0; x < str.sz; x++)\n    {\n        res += drawASCIIChar(uv, pos, sz, str.data[x]);\n        pos.x += sz.x + s;\n    }\n    return res;\n}\n\nfloat drawASCIIRange(vec2 uv, vec2 pos, vec2 sz, ivec2 rng)\n{\n    float res = 0.0;\n    float s = sz.x * 0.93; // step between glyphs\n    for(int x = rng.x; x < rng.y; x++)\n    {\n        res += drawASCIIChar(uv, pos, sz, x);\n        pos.x += sz.x + s;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float v = 0.0;\n    \n    istr l1 = MKSTR8(_E, _D, _DOT, _B, _R, _A, _E, _D);\n    istr l2 = MKSTR16(_T,_h,_i,_s,__,_t,_e,_x,_t, __, _d, _r, _a, _w, _e, _d);\n    istr l3 = MKSTR16(_w,_i,_t,_h,_o,_u,_t,__,_t, _e, _x, _t, _u, _r, _e, _s);\n    istr l4 = MKSTR2(_COL,_RBR);\n    istr l5 = MKSTR9(_2,_3, _AST, _2, _PLS, _1, _EQU, _4, _7); //23*2+1=47\n    \n    v += drawASCIILine(uv, vec2(0.02, 0.03), vec2(0.014, 0.05), l1);\n    v += drawASCIILine(uv, vec2(0.20, 0.40), vec2(0.014, 0.05), l2);\n    v += drawASCIILine(uv, vec2(0.35, 0.32), vec2(0.014, 0.05), l3);\n    v += drawASCIILine(uv, vec2(0.70, 0.32), vec2(0.014, 0.05), l4);\n    v += drawASCIILine(uv, vec2(0.81, 0.03), vec2(0.014, 0.05), l5);\n    \n    v += drawASCIIRange(uv, vec2(0.02, 0.91), vec2(0.02, 0.06), ivec2(33, 58));\n    v += drawASCIIRange(uv, vec2(0.02, 0.81), vec2(0.02, 0.06), ivec2(58, 83));\n    v += drawASCIIRange(uv, vec2(0.02, 0.71), vec2(0.02, 0.06), ivec2(83, 108));\n    v += drawASCIIRange(uv, vec2(0.02, 0.61), vec2(0.02, 0.06), ivec2(108, 127));\n    \n    // Output to screen\n    fragColor = vec4(v, 0.0, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}