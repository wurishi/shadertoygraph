{"ver":"0.1","info":{"id":"mlBSDh","date":"1675982973","viewed":202,"name":"Disco Dancing","username":"BetaSoftCologne","description":"I started with some ray-marched cubes and then saw some of the audio-rendering shaders on here and began to experiment with fm-synthesis (fascinating stuff!) .. The audio visualisation was actually the most enjoyable coding challenge.","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["music","cube","disco"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: BSC\n// Title: \n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat circle(in vec3 pos, in float radius) {\n    float d = length(pos) - radius;\n    return d;\n}\n\nfloat box(in vec3 pos, in float size) {\n    // by iq\n    vec3 q = abs(pos) - size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rotMatDeg(float theta) {\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\n\nvec4 renderScene(in vec3 pos, in vec2 pix) {\n#if 1\n    // repeat domain\n    float rx = 1.2;\n    float ry = 1.0;\n    float rz = 10.5;\n    pos.x = mod(pos.x + rx, rx * 2.) - rx;\n    pos.y = mod(pos.y + ry, ry * 2.) - ry;\n    pos.z = mod(pos.z + rz, rz * 2.) - rz;\n#endif\n\n    float second = iDate.w;\n    float f = fract(second);\n#if 1\n    if (f < 0.33) {\n        pos.z += (3. + 0.1 * abs(sin(iTime * 5.)));\n    }\n    else if (f > 0.66) {\n        pos.z += (1. + 4.5 * abs(sin(f*5.5)));\n    }\n    \n#endif\n\n#if 0\n    // rotate around center\n    pos.x += sin(iTime * 2.5);\n    pos.y += cos(iTime * 2.5);\n#endif\n\n    float g = 0.2 * abs(sin(iTime * 5.));\n    \n    // rotating box\n    float a = (mod(iTime, 3.1415926));\n    mat2 rot = rotMatDeg(a);\n    vec2 xz = pos.xz*rot;\n    vec3 bpos = vec3(xz.s, pos.y, xz.t);\n    a = box(bpos, 0.5);\n\n    // ball\n    float b = circle(vec3(pos.x,pos.y-1.5,pos.z), .06);\n    \n    // \n    float d = min(a,b);\n    float c = abs(d); // * exp(pos.y) - pos.x; \n    return vec4(c,c,c , d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n\n    // Normalize pixel coordinates (from -1 to 1)    \n    vec2 p = (2. * pos - iResolution.xy) / iResolution.y;\n    \n    // ray origin is a bit outside of the screen\n    // i.e. at the tip of your nose\n    vec3 origin = vec3(0.,0.,3.);\n\n    // ray direction points towards a point on a plane that is\n    // representative of the current pixel in fragCoord  \n    vec3 direction = normalize(vec3(p.xy, -1.5));\n\n    // ray-march the scene\n    float max = 38.0;\n    vec3 col = vec3(0.0235, 0.0471, 0.1608);\n    float dist, t = 0.;\n    vec4 result;\n    for (int i=0; i<20; i++) {\n        vec3 ray = origin + t*direction;\n\n        result = renderScene(ray, p);\n\n        // the distance is in the a-component\n        dist = result.a;\n        if (dist < 0.001) break; // we hit something!\n\n        // advance the current distance   \n        t += dist;\n        // until we went too far\n        if (t>max) break;\n    }\n    \n    if (t<max) {\n        // still in the scene, so we must have hit something. \n        // extract the color of the object that was hit\n        col = result.rgb;\n        \n    }\n    \n    // add graphical equalizer\n    float wavesize = 0.6128;\n    float E = 0.1;\n    if ((p.y < wavesize) && (p.y > -wavesize)) {\n        float x = p.x*0.5 + 1.; // from 0 to 1\n        \n        float t = iTime + x*(1. / 10.);\n        vec2 bass = mainSound(0, t) * 1.5;\n\n        col *= 0.1; // + abs(p.y);\n        float sum = bass.x + bass.y;\n        if (abs(sum - p.y) < E) {\n            col = vec3(1. - sum);\n            col.r *= 0.5;\n            col.b *= 0.2;\n        }\n    }\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat TAU = 6.2831;\n\n\nvec2 pan(float pos) {\n    return normalize(vec2(1.-pos, 1.+pos));\n}\n\nfloat env(float time, float decay, float duration) {\n    float f = mod(time, duration);\n    return exp(-decay*f);\n}\n\n\nfloat fm(float time, float fc, float fm, float iom) {\n    float volume = 0.5;  \n    \n    float t2 = time + 0.5;\n    \n    float oscA = sin(TAU*fc*time + iom*sin(TAU*fm*time)); \n    float offset = 0.5;\n    float factor = 0.5;\n    int echoes = 0;\n    if (echoes > 0) {\n        for (int i=0; i<echoes; i++) {\n            oscA += factor * sin(TAU*fc*offset + iom*sin(TAU*fm*offset));\n            factor *= 0.5;\n        }\n        oscA /= float(echoes);\n    }\n    \n    return oscA * volume;\n}\n\nfloat bassDrum(float time) {\n    float f = mod(time, .5);\n\n    // volume\n    float decay = 6.;\n    float vol = exp(-decay*f);\n\n    // pitch\n    float freq = 400. * exp(-decay*f*4.);\n\n    // calculate waveform\n    return sin(TAU*freq*f)*vol;\n}\n\nfloat sine(float time, float freq) {\n    float volume = 0.5;\n    return sin(TAU*freq*time)*volume;\n}\n\nfloat saw(float time, float freq) {\n    float volume = 0.5;\n    return mod(freq*time, 1.)*2. -1. * volume;\n}\n\nfloat square(float time, float freq) {\n    float volume = 0.5;\n    float x = TAU*freq*time;\n    return sign(sin(x)) * volume;\n}\n\n\nfloat noise(float time) {\n    // TODO\n    float s = iDate.w / 10.;\n    float f = fract(time);\n    float frq = 440. + 10.*f;\n    float r = sin(TAU*frq*f)*0.5;\n    r+= sin(TAU*frq*2.*f)*0.25;\n    r+= sin(TAU*frq*3.*f)*0.125;\n    r+= sin(TAU*frq*4.*f)*0.125;\n    r+= sin(TAU*frq*5.*f);\n    r+= sin(TAU*frq*6.*f);\n    return r / 6.0;\n}\n\nfloat[] notes = float[] (\n    1.0, 1.1, 1.2, 1.3, \n    1.4, 1.5, 1.6, 1.7\n);\n\n\nvec2 metallic_bass(float time){\n    float f1 =  880.;\n    float f2 = 220. + .01 *sin(time*0.5);\n    float iom = 14. + 10.*sin(time*.5);\n    vec2 bass = fm(time*0.25, f1, f2, iom)\n        * env(time, 8., .25)\n        * pan(0.2);\n/*\n    // store samples\n    float i = fract(time) * 100.;\n    snd_buf[int(i)] = bass;\n    SCREEN_COLOR_ADDR[i]\n*/\n    return bass;\n}\n\n\nvec2 mainSound( int samp, float time ) \n{\n    // to vizualize in graphtoy:\n    // 10*exp(-6*mod(t, 1)*0.5)\n    // where: 10 = scale\n    //        -6 = decay\n    //         1 = fraction of time\n    //        .5 = amount of decay to use\n\n    vec2 sig = vec2(0);\n    float f = mod(time, 2.);\n\n    // bass drum\n    float bd = bassDrum(time);\n \n     // some notes\n    vec2 bass;\n    float n = notes[int(mod(time, 8.))];\n    bass = metallic_bass(time);\n    if (f > 1.5) {\n        bass *= saw(time*0.25, n*220.)\n            * env(time, 4., .25) \n            * pan(-0.2) \n            * 0.5;\n    } else {\n        //bass = vec2(square(time*0.25, 440.)) * env(time, 8., .25);\n        //bass = metallic_bass(time);\n    }\n    \n    // mix\n    sig += bd * 0.8;\n    sig += bass;\n\n    float master_vol = 0.5;\n    return sig * master_vol;\n\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"// see Common tab for sound functions\n","name":"Sound","description":"","type":"sound"}]}