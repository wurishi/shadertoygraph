{"ver":"0.1","info":{"id":"WlyGD3","date":"1580179769","viewed":108,"name":"Peter Shirley","username":"feresr","description":"Shader implementation of Peter Shirley's Ray Tracing in One Weekend\n ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray {\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct hit_record {\n\tfloat t;\n    vec3 p;\n    vec3 normal;\n    bool hit;\n    vec3 color;\n    int material;\n};\n    \nstruct sphere {\n\tvec3 center;\n    float radius;\n    vec3 color;\n    int material;\n};\n    \nvec3 walk(ray r, float t) {\n\treturn r.origin + normalize(r.direction) * t;\n}\n\nhit_record hit_sphere(sphere s, const ray r, float t_max, float t_min) {\n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float b = dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius*s.radius;\n    float discriminant = b*b - a*c;\n   \n\tif (discriminant > 0.) {\n        float temp = (-b - sqrt(discriminant)) / a;\n        if (temp < t_max && temp > t_min) {\n            hit_record rec = hit_record(\n                temp,\n                walk(r, temp),\n                (walk(r, temp) - s.center) / s.radius,\n                true,\n                s.color,\n                s.material\n            );\n       \n            return rec;\n        }\n        \n        temp = (-b + sqrt(discriminant)) / a;\n        if (temp < t_max && temp > t_min) {\n            hit_record rec = hit_record(\n            temp,\n            walk(r, temp),\n            (walk(r, temp) - s.center) / s.radius,\n            true,\n                s.color,\n                s.material\n            );\n          \n            return rec;\n        }\n    }\n\n    return hit_record(\n            0.0,\n            vec3(0.0,0.0,0.0),\n            vec3(0.0,0.0,0.0),\n            false,\n        \tvec3(0.0,0.0,0.0),\n        \t0\n           );\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 bounce(ray r, inout sphere[3] spheres) {\n    for(int i = 0; i < spheres.length(); i++) {\n        hit_record t = hit_sphere(spheres[i], r, 100.0, 0.0);\n        if (t.hit == true) {\n            vec3 N = normalize(t.normal);\n            return t.color;\n        }\n    }\n    \n \tvec3 unit_direction = normalize(r.direction);\n    float t = 2.0*(unit_direction.y);\n    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n}\n\nvec3 random_in_unit_sphere(vec3 p) {\n  return normalize(vec3(rand(p.xy * iTime), rand(p.yz / iTime), rand(p.zy + iTime)));\n}\n\n\nvec3 color(ray r, inout sphere[3] spheres) {\n    for(int i = 0; i < spheres.length(); i++) {\n        hit_record t = hit_sphere(spheres[i], r, 100.0, 0.0);\n        if (t.hit == true) {\n            vec3 N = normalize(t.normal);\n            if (t.material == 1) {\n                vec3 reflected = reflect(normalize(t.p), t.normal);\n                ray scattered = ray(t.p, reflected);\n            \treturn .5 * t.color + .5 * bounce(scattered,spheres);\n            } else {\n                vec3 target = t.p + t.normal + random_in_unit_sphere(t.p);\n                ray scattered = ray(t.p, target - t.p);\n            \treturn t.color + .5 * bounce(scattered,spheres);\n            }\n        }\n    }\n    vec3 unit_direction = normalize(r.direction);\n    float t = 2.0*(unit_direction.y);\n    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0); \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 horizontal = \tvec3(1.0, 0.0, 0.0);\n    vec3 vertical \t= \tvec3(0.0, 1.0, 0.0);\n    vec3 origin \t=\tvec3(.2 + cos(iTime * 2.) * .05, sin(iTime) * .01,-.1 - sin(iTime) * .1);\n    vec3 center\t\t=\tvec3(0.0, 0.0, -1.0);\n    \n    \n    // X axis\n    if (uv.y < 0.005 && uv.y > -0.005) {\n    \tfragColor = vec4(1.0,0.0,0.0,1.0);\n        //return;\n    }\n    \n    // Y axis\n    if (uv.x < 0.005 && uv.x > -0.005) {\n    \tfragColor = vec4(0.0,1.0,0.0,1.0);\n        //return;\n    }\n    \n    sphere[3] spheres = sphere[3](\n        sphere(vec3(0.0,0.0,-1.), .25, vec3(.2, 0.1, 0.1), 0),\n        sphere(vec3(.5 + cos(iTime) * .2, -0.15, - 1.2 - sin(iTime) *.1), .10, vec3(.0, 0.0, 0.5), 1),\n        sphere(vec3(0.0,-100.25,-1.), 100.00, vec3(0.2, 0.5, 0.2), 0)\n    );\n    \n    vec3 result = vec3(0.0, 0.0, 0.0);\n\n    int N = 10;\n    \n    for (int i = 0; i < N; i++) {\n        ray r = ray(origin, \n                    center + \n                    uv.x * horizontal \n                    + uv.y * vertical\n                    //Antialiasing\n                    + vec3((cos(float(i)/float(N) * 3.1415) * 0.001), (sin(float(i)/float(N) * 3.1415) * 0.001),0.0)\n                   );\n    \tresult += color(r, spheres);\n    }\n    result /= float(N);\n    \n    fragColor = vec4(result, 1.0);  \n}","name":"Image","description":"","type":"image"}]}