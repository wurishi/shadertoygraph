{"ver":"0.1","info":{"id":"DsGczK","date":"1696428163","viewed":91,"name":"Screen sphere","username":"Krafpy","description":"Experiments on making a glass sphere with a pixelated screen effect.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","reflection","blur","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Use the mouse to move around */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 blr = vec3(0.);\n    float r = 6.;\n    float rr = r*r;\n    float w0 = 0.3780/pow(r,2.);\n    for(float i = -r; i <= r; ++i){\n        for(float j = -r; j <= r; ++j){\n            vec2 uv2 = uv + vec2(i,j)/iResolution.xy;\n            vec3 c = texture(iChannel0, uv2).rgb;\n            c *= step(0.1, length(c));\n            c *= w0*exp((-i*i-j*j)/(2.*rr));\n            blr += c;\n        }\n    }\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    col += blr;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Use the mouse to move around */\n\n#define PI 3.14159265\n#define TWOPI (2.*PI)\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// sphere of size ra centered at point ce\n// by iq\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra ) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n// plane degined by p (p.xyz must be normalized)\n// by iq\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\n// hash functions from: https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat cdot(vec3 a, vec3 b){\n    return max(0., dot(a, b));\n}\n\nfloat fresnel(float r0, vec3 n, vec3 i){\n    return r0 + (1. - r0)*pow(1.-cdot(n,i), 5.);\n}\n\n\n/*float checkers(vec2 p){\n    p = mod(p, 2.);\n    float s1 = step(p.x, 1.);\n    float s2 = step(p.y, 1.);\n    return min(1.,s1+s2)-s1*s2;\n}*/\n\n\nfloat floorLight(vec2 i) {\n    float w = 0.2;\n    float d = 1.;\n    float t = mod(2.*iTime+hash12(i)*100., 2.*w+d+2.);\n    float f = smoothstep(0.,w,t)*smoothstep(w+d+w,w+d,t);\n    return f;\n}\n\n\nvec3 floorColor(vec2 p){\n    float delta = 0.3*iTime;\n    p -= delta;\n    vec2 i = floor(p);\n    vec3 c = normalize(hash32(i+13.));\n    float f = step(length(i+delta),10.);\n    f *= floorLight(i);\n    vec2 r = p-i-0.5;\n    f *= step(sdBox(r,vec2(0.39))-0.1, 0.);\n    f *= smoothstep(1.1,0.,length(r));\n    return vec3(c*f);\n}\n\nvec4 renderFloor(vec3 ro, vec3 rd){\n    float t = plaIntersect(ro, rd, vec4(0.,1.,0.,2.));\n    if(t < 0.){\n        return vec4(-1.);\n    }\n    vec3 p = ro + rd*t;\n    return vec4(vec3(floorColor(p.xz*0.7)*1.), t);\n}\n\n\nfloat sinp(float x){\n    return 0.5+0.5*sin(x);\n}\n\nvec2 cartesianToSpherical(vec3 p){\n    float theta = acos(p.y/length(p));\n    float phi = sign(p.z)*acos(p.x/length(p.xz));\n    return vec2(phi, theta);\n}\n\nvec3 sphericalToCartesian(vec2 sph) {\n    return vec3(\n        sin(sph.y)*cos(sph.x),\n        cos(sph.y),\n        sin(sph.y)*sin(sph.x)\n    );\n}\n\nfloat triangle(vec2 uv, float h, float a){\n    vec2 d1 = normalize(rot(a)*vec2(1.,1.));\n    float f1 = dot(uv, d1);\n    f1 = step(f1, h);\n    \n    vec2 d2 = normalize(rot(-a)*vec2(-1.,1.));\n    float f2 = dot(uv-vec2(1.,0.), d2);\n    f2 = step(f2, h);\n    \n    return f1*f2;\n}\n\n\nvec3 sphereColor(vec3 p){\n    vec2 sph = cartesianToSpherical(p);\n    sph.y /= PI;\n    sph.x = (sph.x/TWOPI) + 0.5;\n    float res = 100.;\n    sph.y = floor(sph.y*(0.5*res))/(0.5*res);\n    sph.x = floor(sph.x*res)/res;\n    \n    \n    vec3 col = vec3(0.);\n    \n    float f;\n    float T = mod(iTime, 5.);\n    \n    vec3 c1 = vec3(1.,1.,0.);\n    \n    if(T < 1.) {\n        f = sinp(sph.x*50.+iTime*10.);\n        f = step(0.1,f);\n        f *= step(sph.y,0.6)*step(0.4,sph.y);\n        col = c1*f;\n    } else if(T < 2.) {\n        float w = 20.;\n        float x = floor(sph.x*w)/w;\n        f = sinp(x*25. + iTime*5.)*0.15+0.4;\n        f = step(f, sph.y);\n        col = c1*f;\n    } else if(T < 4.) {\n        vec2 sph1 = sph;\n        sph1.y *= PI;\n        sph1.x = (sph1.x - 0.5)*TWOPI;\n        p = sphericalToCartesian(sph1);\n        \n        mat2 r = rot(iTime*TWOPI/5.+1.);\n        \n        f = step(0.5, sph.y);\n        vec3 m = vec3(-1.,0.,0.);\n        m.xz *= r;\n        m = normalize(m);\n        f *= step(distance(p,m), 0.5);\n        \n        float er = 0.3;\n        m = normalize(vec3(-1.,0.5,1.));\n        m.xz *= r;\n        f += step(distance(p,m), er);\n        \n        m = normalize(vec3(-1.,0.5,-1.));\n        m.xz *= r;\n        float fl = step(distance(p,m), er);\n        if(T >= 3. && T <= 3.5){\n            fl *= step(0.4, sph.y) * step(sph.y, 0.4);\n        }\n        f += fl;\n        \n        f = min(f, 1.);\n        \n        col = c1*f;\n        \n    } else if(T < 5.) {\n        sph.x = mod(sph.x*5. + iTime*1., 1.);\n        float a = 0.5;\n        f = triangle(sph, 0.75, a) - triangle(sph, 0.65, a);\n        col = c1*f;   \n    }\n    \n    return col;\n}\n\nvec4 renderSphere(vec3 ro, vec3 rd){\n    const vec3 ce = vec3(0.);\n    const float rad = 1.;\n    \n    vec2 hit = sphIntersect(ro, rd, ce, rad);\n    float t = hit.x;\n    if(t < 0.){\n        vec4(-1.);\n    }\n    vec3 p = ro + rd*t;\n    return vec4(sphereColor(p), t);\n}\n\nvec4 closestHit(vec4 h1, vec4 h2){\n    if(h1.w > 0. && h2.w > 0.){\n        return h1.w < h2.w ? h1 : h2;\n    } else {\n        return h1.w > 0. ? h1 : h2;\n    }\n    return vec4(-1.);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    const vec3 sunDir = normalize(vec3(1.));\n    \n    vec4 hitFloor = renderFloor(ro, rd);\n    vec4 hitSphere = renderSphere(ro, rd);\n    \n    vec4 hit = closestHit(hitFloor, hitSphere);\n    if(hit.w < 0.){\n        return vec3(0.);\n    }\n    \n    bool isSph = hit.w == hitSphere.w;\n    if(isSph){\n        float t = hit.w;\n        vec3 p = ro + rd*t;\n        vec3 n = normalize(p);\n        \n        float fres = fresnel(0.05, n, -rd);\n        vec3 ref = reflect(rd, n);\n        hitFloor = renderFloor(ro, ref);\n        vec3 refCol = max(hitFloor.rgb,vec3(0.));\n        \n        return vec3(fres*refCol + (1.-fres)*hit.rgb);\n    }\n    \n    return hit.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 mr = iMouse.xy/iResolution.xy;\n    mr -= 0.5;\n    mr.x *= iResolution.x / iResolution.y;\n    mr *= 3.141592;\n    \n    vec3 ro, rd;\n    ro = vec3(0., 0., -5.);\n    rd = normalize(vec3(uv, 1.));\n    if(iMouse.z > 0.) {\n        ro.yz *= rot(mr.y);\n        rd.yz *= rot(mr.y);\n        ro.xz *= rot(mr.x);\n        rd.xz *= rot(mr.x);\n    }\n    \n    col = render(ro, rd);\n    col = pow(col, vec3(1.0/2.2));\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}