{"ver":"0.1","info":{"id":"43dXR2","date":"1719287665","viewed":46,"name":"Claude 3.5 Sonnet","username":"marcoc2","description":"\"gere um shader glsl compatível com o serviço shader toy e que seja, de novo, um ray tracing em uma esfera onde os raios anteram de intensidade de acordo com a textura da música que vem pelo iChannel0\"","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["aigen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Função para criar ondulações\nvec3 ripple(vec3 p, float time, float freq, float amp) {\n    float f = length(p.xz) * 70.0 - time;\n    return vec3(0, sin(f) * amp, 0) * exp(-freq * length(p.xz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Ray origin and direction\n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    // Sphere properties\n    vec3 sphereCenter = vec3(0, 0, 0);\n    float sphereRadius = 2.0;\n\n    // Ray-sphere intersection\n    vec3 oc = ro - sphereCenter;\n    float b = dot(rd, oc);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float h = b*b - c;\n\n    // Color initialization\n    vec3 col = vec3(0.0);\n\n    if (h >= 0.0) {\n        // Ray hits the sphere\n        float t = -b - sqrt(h);\n        vec3 p = ro + t * rd;\n        vec3 n = normalize(p - sphereCenter);\n\n        // Lighting setup\n        vec3 light = normalize(vec3(1, 1, -1));\n        vec3 viewDir = normalize(ro - p);\n        vec3 halfwayDir = normalize(light + viewDir);\n\n        // Get audio data\n        float audioIntensity = texture(iChannel0, vec2(0.1, 0.0)).r;\n        float lowFreq = texture(iChannel0, vec2(0.1, 0.0)).r;\n        float midFreq = texture(iChannel0, vec2(0.3, 0.0)).r;\n        float highFreq = texture(iChannel0, vec2(0.5, 0.0)).r;\n\n        // Create ripple effect with increased depth\n        vec3 ripple1 = ripple(p, iTime * 2.0 + lowFreq * 10.0, 3.0 + midFreq * 5.0, 0.05 + highFreq * 0.1);\n        vec3 ripple2 = ripple(p.zxy, iTime * 1.5 + midFreq * 8.0, 4.0 + lowFreq * 4.0, 0.04 + midFreq * 0.08);\n        vec3 ripple3 = ripple(p.yzx, iTime * 2.5 + highFreq * 12.0, 5.0 + highFreq * 6.0, 0.03 + lowFreq * 0.06);\n\n        // Combine ripples and apply to normal with increased effect\n        vec3 displacement = ripple1 + ripple2 + ripple3;\n        n = normalize(n + displacement * 2.0);\n\n        // Diffuse lighting\n        float diff = max(dot(n, light), 0.0);\n\n        // Specular lighting\n        float spec = pow(max(dot(n, halfwayDir), 0.0), 32.0);\n\n        // Base color modulated by audio\n        vec3 baseColor = vec3(0.6, 0.3, 0.1) * (1.0 + audioIntensity * 0.5);\n\n        // Create color variation based on ripples and audio data\n        vec3 rippleColor = vec3(lowFreq, midFreq, highFreq) * length(displacement) * 5.0;\n\n        // Combine diffuse, specular, and audio-reactive effects\n        col = baseColor * diff + vec3(1.0) * spec * 0.5;\n        col += rippleColor;\n\n        // Ambient occlusion approximation\n        float ao = 0.5 + 0.5 * n.y;\n        col *= ao;\n    }\n\n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}