{"ver":"0.1","info":{"id":"4t23Dy","date":"1432185983","viewed":396,"name":"Metaballs?","username":"Hamneggs","description":"Just some smooth min balls rumbling about each other.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarched","balls","meta","transparent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define V_STEPS 40\n#define I_STEPS 1000.0\n\n#define EPSILON .01\n\n#define MAXDEPTH 10.\n\nconst vec3 UP = vec3(0.,1.,0.);\n\n#define RAD 1.\n#define BLEND 1.\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, UP)*uv.x + UP*uv.y)-ro);\n}\n\n/*\n\tReturns a Rx*Ry*Rz composite rotation matrix. Man, this is narsty.\n*/\nmat3 var(in float x, in float y, in float z)\n{  \n    x*=.1, y*=.1, z*=.1;\n    #define C cos\n    #define S sin\n\treturn mat3(\n  \tC(y)*C(z), \t\t\t\t  -C(y)*S(z), \t\t\t      S(y),\n\tC(z)*S(x)*S(y)+C(x)*S(z),  C(x)*C(z)-S(x)*S(y)*S(z), -C(y)*S(x),\n    S(x)*S(z)-C(x)*C(z)*S(y),  C(z)*S(x)+C(x)*S(y)*S(z),  C(x)*C(y)\n    );\n    #undef C\n    #undef S\n}\n\n/*\n\tSome simple time -> 3D noise functions.\n*/\nvec3 noise(in float t, in vec3 off){ return 1.5*vec3(cos(t+off.x),sin(-t+off.x),cos(t+off.z)); }\n\n/*\n\tIQ's polynomial smooth minimum.\n*/\nfloat smin(float a, float b)\n{\n    float h = clamp( 0.5+0.5*(b-a)/BLEND, 0.0, 1.0 );\n    return mix( b, a, h ) - BLEND*h*(1.0-h);\n}\n\n/*\n\tThe classic sphere distance function.\n*/\nfloat ball(in vec3 p, in vec3 bp)\n{\n    return length(bp-p)-RAD;\n}\n\n/*\n\tA distance function for some ghetto meta-balls.\n*/\nfloat dist(in vec3 p)\n{\n    #define t iTime*2.0\n    float d = \n        smin( ball( p, \t  noise(t, vec3(.723096, .209298, 2.28507) ) ), \n                 ball( p, noise(t, vec3(.883809, 3.73239, .086730) ) ));\n    d = smin( d, ball( p, noise(t, vec3(2.87799, .033765, 3.70945) ) ));\n    d = smin( d, ball( p, noise(t, vec3(1.80834, 3.47024, 3.32373) ) ));\n    d = smin( d, ball( p, noise(t, vec3(4.84249, 4.67325, 4.58224) ) ));\n    d = smin( d, ball( p, noise(t, vec3(4.93713, .093115, 4.31848) ) ));\n    //d = smin( d, ball( p, noise(t, vec3(2.91957, 4.73089, 1.58224) ) ));\n    //d = smin( d, ball( p, noise(t, vec3(2.67641, 2.97143, 2.58224) ) ));\n    //d = smin( d, ball( p, noise(t, vec3(2.92161, 3.28409, 3.58224) ) ));\n    //d = smin( d, ball( p, noise(t, vec3(2.18357, 2.67325, .588224) ) ));\n    return d;\n    #undef t\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm(vec3 p)\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction dir\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n\tReturns the object ID of the found object.\n*/\nvoid march_ext(inout vec3 p, in vec3 dir)\n{\n\tfloat r = dist(p+dir*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON)\n\t\t\treturn;\n\t\tp += dir*r;\n        r = dist(p);\n\t}\n\treturn;\n}\n\nvoid march_int(in vec3 entry, out vec3 exit, in vec3 dir)\n{\n    vec3 p = entry;\n    for(float i = .0; i < 10.0; i+=10.0/I_STEPS)\n    {\n        if(dist(p) > EPSILON)\n        {\n            exit = p;\n            return;\n        }\n        p = entry + dir*i;\n    }\n    entry = p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    vec3 p, d, e;\n    camera(uv, vec3(0.0,0.0,-6.0), vec3(0.0,0.0,1.0), 1.0, p, d);\n    e = p;\n    \n    march_ext(p, d);\n    if(length(p-e) < MAXDEPTH)\n    {\n        vec3 n = norm(p);\n\n        d = refract(d, n, -.001);\n\n        vec3 otherside;\n\n        march_int(p, otherside, d);\n\n        n = norm(otherside);\n\n        d = refract(d, n, -.001);\n\n        vec3 trans = texture(iChannel0, n).rgb;\n\t\t\n        float opacity = length(p-otherside)/15.50;\n        \n        fragColor = vec4(trans-vec3(1.,0.,1.)*opacity,1.0);\n    }\n    else fragColor = texture(iChannel0, d);\n}","name":"","description":"","type":"image"}]}