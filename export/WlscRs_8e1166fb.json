{"ver":"0.1","info":{"id":"WlscRs","date":"1592828936","viewed":273,"name":"Digit rendering","username":"luluco250","description":"If anyone can figure out why using a `switch` causes the center pixels to not render, I'd be very thankful.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["2d","text","digit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Set to 1 to see a very weird bug when using\n// a switch over a series of ifs.\n#define USE_SWITCH 0\n\nconst ivec2 CharSize = ivec2(3, 5);\nconst int CharArraySize = CharSize.x * CharSize.y;\n\nconst int _0[] = int[CharArraySize](\n\t1, 1, 1,\n    1, 0, 1,\n    1, 0, 1,\n    1, 0, 1,\n    1, 1, 1\n);\n\nconst int _1[] = int[CharArraySize](\n\t0, 0, 1,\n    0, 0, 1,\n    0, 0, 1,\n    0, 0, 1,\n    0, 0, 1\n);\n\nconst int _2[] = int[CharArraySize](\n\t1, 1, 1,\n    0, 0, 1,\n    1, 1, 1,\n    1, 0, 0,\n    1, 1, 1\n);\n\nconst int _3[] = int[CharArraySize](\n    1, 1, 1,\n    0, 0, 1,\n    1, 1, 1,\n    0, 0, 1,\n    1, 1, 1\n);\n\nconst int _4[] = int[CharArraySize](\n    1, 0, 1,\n    1, 0, 1,\n    1, 1, 1,\n    0, 0, 1,\n    0, 0, 1\n);\n\nconst int _5[] = int[CharArraySize](\n    1, 1, 1,\n    1, 0, 0,\n    1, 1, 1,\n    0, 0, 1,\n    1, 1, 1\n);\n\nconst int _6[] = int[CharArraySize](\n    1, 1, 1,\n    1, 0, 0,\n    1, 1, 1,\n    1, 0, 1,\n    1, 1, 1\n);\n\nconst int _7[] = int[CharArraySize](\n    1, 1, 1,\n    0, 0, 1,\n    0, 0, 1,\n    0, 0, 1,\n    0, 0, 1\n);\n\nconst int _8[] = int[CharArraySize](\n    1, 1, 1,\n    1, 0, 1,\n    1, 1, 1,\n    1, 0, 1,\n    1, 1, 1\n);\n\nconst int _9[] = int[CharArraySize](\n    1, 1, 1,\n    1, 0, 1,\n    1, 1, 1,\n    0, 0, 1,\n    1, 1, 1\n);\n\nconst int _Empty[] = int[CharArraySize](\n    0, 0, 0,\n    0, 0, 0,\n    0, 0, 0,\n    0, 0, 0,\n    0, 0, 0\n);\n\nconst int RainbowColorCount = 7;\n\nconst vec3 RainbowColors[] = vec3[RainbowColorCount](\n    vec3(1, 0, 0),\n    vec3(1, 0.5, 0),\n    vec3(1, 1, 0),\n    vec3(0, 1, 0),\n    vec3(0, 1, 1),\n    vec3(0, 0, 1),\n    vec3(0.5, 0, 1)\n);\n\nint[CharArraySize] GetDigitArray(int digit)\n{\n    #if USE_SWITCH\n        switch (digit)\n        {\n            case 0:\n                return _0;\n            case 1:\n                return _1;\n            case 2:\n                return _2;\n            case 3:\n                return _3;\n            case 4:\n                return _4;\n            case 5:\n                return _5;\n            case 6:\n                return _6;\n            case 7:\n                return _7;\n            case 8:\n                return _8;\n            case 9:\n                return _9;\n            default:\n                return _Empty;\n        }\n    #else\n        // I really, really hate OpenGL.\n        //\n        // For some reason using a switch causes the center pixels\n        // of the digits to not render and I have no idea why.\n        //\n        // So for now, we'll use ifs, maybe later use a single\n        // array with all the digits.\n\n        if (digit == 0)\n            return _0;\n\n        if (digit == 1)\n            return _1;\n\n        if (digit == 2)\n            return _2;\n\n        if (digit == 3)\n            return _3;\n\n        if (digit == 4)\n            return _4;\n\n        if (digit == 5)\n            return _5;\n\n        if (digit == 6)\n            return _6;\n\n        if (digit == 7)\n            return _7;\n\n        if (digit == 8)\n            return _8;\n\n        if (digit == 9)\n            return _9;\n\n        return _Empty;\n    #endif\n}\n\nint GetDigitPixel(int digit, ivec2 pos)\n{\n    return GetDigitArray(digit)[pos.x + CharSize.x * pos.y];\n}\n\nvoid RenderDigit(\n    inout vec4 color,\n    vec2 coord,\n    int digit,\n    ivec2 digitOffset,\n    int digitScale,\n    vec4 digitColor)\n{\n    ivec2 pos = ivec2(coord);\n    pos /= digitScale;\n    pos -= digitOffset;\n    \n    if (pos.x < 0 || pos.x >= CharSize.x || pos.y < 0 || pos.y >= CharSize.y)\n        return;\n    \n    float isDigit = float(GetDigitPixel(digit, pos));\n    color.rgb = mix(color.rgb, digitColor.rgb, isDigit * digitColor.a);\n}\n\nvec4 GetDigitColor(int index)\n{\n    index += int(iTime);\n    return vec4(RainbowColors[index % RainbowColorCount], 0.65);\n}\n\nvoid RenderTime(inout vec4 color, vec2 coord)\n{\n    const int Digits = RainbowColorCount;\n    \n    int t = int(iTime);\n    \n    for (int i = Digits - 1; i >= 0; --i)\n    {\n        RenderDigit(\n            color,\n            coord,\n            t % 10,\n            ivec2(i * 4, 0),\n            28,\n            GetDigitColor(i));\n        \n        t /= 10;\n    }\n}\n\nvoid RenderStaticSample(inout vec4 color, vec2 coord)\n{\n    for (int i = 0; i < RainbowColorCount; ++i)\n    {\n        RenderDigit(\n            color,\n            coord,\n            (i + int(iTime)) % 10,\n            ivec2(i * 4, 6),\n            28,\n            GetDigitColor(i));\n    }\n}\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    color = vec4(vec3(0.1), 1.0);\n    \n    // Ugly hack to use normalized coords.\n    vec2 uv = coord / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 450.0;\n    \n    RenderTime(color, uv);\n    \n    RenderStaticSample(color, uv);\n}","name":"Image","description":"","type":"image"}]}