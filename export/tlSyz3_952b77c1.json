{"ver":"0.1","info":{"id":"tlSyz3","date":"1594932363","viewed":91,"name":"Basic : Ford Circles","username":"Gijs","description":"ford circles","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","circles","ford","farey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ford(vec2 p){\n    p.x = fract(p.x);\n    float d = 1e20;\n    \n    //a & b represent the fraction x/y using their x and y components\n\tvec2 a = vec2(0,1);\n    vec2 b = vec2(1,1);\n    \n    for(int i=0; i<20; i++){\n        //get the distance to the ford circle corresponding to the fraction a.x/a.y\n        float ra = 1./(2.*a.y*a.y);\n        vec2  ca = vec2(a.x/a.y, ra);\n        float da = distance(p, ca)-ra;\n        d = min(d, da);\n        \n        //get the distance to the ford circle corresponding to the fraction b.x/b.y\n        float rb = 1./(2.*b.y*b.y);\n        vec2  cb = vec2(b.x/b.y, rb);\n        float bd = distance(p, cb)-rb;\n        d = min(d, bd);\n        \n        //farey algorithm\n        //a&b are two fractions that make an interval in which p.x lays\n        //it turns out that the fraction represented by a+b is also always in this interval\n        //we can use this to home in on p.x Ã  la binary search\n        vec2 c = a+b;\n        if(p.x > c.x/c.y){\n            a = c;\n        }else{\n            b = c;\n        }\n        \n        \n    }\n    \n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Output to screen\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y + vec2(.5,.5);\n    float d = ford(uv);\n    float e = 1./iResolution.y;\n    float c = smoothstep(e*2., e, abs(d));\n    fragColor = vec4(c,c,c,1.0);\n}","name":"Image","description":"","type":"image"}]}