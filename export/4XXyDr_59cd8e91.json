{"ver":"0.1","info":{"id":"4XXyDr","date":"1726018167","viewed":17,"name":"Domain Coloring 124","username":"Devesh_Dayanidhi","description":"Domain Coloring","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["graph","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MATH_PIF 3.141592f\n\nstruct Complex\n{\n    float Re, Im;\n};\n\nComplex CreateComplex()\n{\n    Complex c;\n    c.Re = 0.0f;\n    c.Im = 0.0f;\n    \n    return c;\n}\n\nComplex CreateComplex(float Re)\n{\n    Complex c;\n    c.Re = Re;\n    c.Im = 0.0f;\n\n    return c;\n}\n\nComplex CreateComplex(float Re, float Im)\n{\n    Complex c;\n    c.Re = Re;\n    c.Im = Im;\n    \n    return c;\n}\n\nComplex CreateComplex(vec2 v)\n{\n    Complex c;\n    c.Re = v.x;\n    c.Im = v.y;\n    \n    return c;\n}\n\nfloat Arg(Complex z)\n{\n    //return (atan(z.Im / z.Re) + MATH_PIF) / (2.0f * MATH_PIF);\n    return atan(z.Im / z.Re);\n\n}\n\nfloat Modulus(Complex z)\n{\n    return sqrt(z.Re * z.Re + z.Im * z.Im);\n}\n\nComplex Add(Complex z, Complex w)\n{\n    Complex c;\n    c.Re = z.Re + w.Re;\n    c.Im = z.Im + w.Im;\n    \n    return c;\n}\n\nComplex Subtract(Complex z, Complex w)\n{\n    Complex c;\n    c.Re = z.Re - w.Re;\n    c.Im = z.Im - w.Im;\n    \n    return c;\n}\n\nComplex Multiply(Complex z, Complex w)\n{\n    Complex ret;\n    ret.Re = z.Re * w.Re - z.Im * w.Im;\n    ret.Im = z.Re * w.Im + z.Im * w.Re;\n    \n    return ret;\n}\n\nComplex BrokenDivide(Complex z, Complex w)\n{\n    Complex ret;\n    ret.Re = (z.Re * w.Re + z.Im * w.Im) / Modulus(w);\n    ret.Im = (z.Im * w.Re - z.Re * w.Im) / Modulus(w);\n    \n    return ret;\n}\n\nComplex Divide(Complex z, Complex w)\n{\n    Complex result;\n    \n    float denominator = w.Re * w.Re + w.Im * w.Im;\n    \n    if (denominator == 0.0f) \n    {\n        result.Re = 0.0f;\n        result.Im = 0.0f;\n        return result;\n    }\n    \n    result.Re = (z.Re * w.Re + z.Im * w.Im) / denominator;\n    result.Im = (z.Im * w.Re - z.Re * w.Im) / denominator;\n\n    return result;\n}\n\nComplex IntegerExponentPower(Complex z, float exponent)\n{\n    if (exponent == 0.0f)\n        return CreateComplex(1.0f, 0.0f);\n    if (exponent < 0.0f)\n    {\n        Complex ret = Complex(1.0f, 0.0f);\n        for (float i = 0.0f; i < exponent; i++)\n            ret = Divide(ret, z);\n    \n        return ret;\n    }\n    \n    Complex ret = CreateComplex(1.0f, 0.0f);\n    for (float i = 0.0f; i < exponent; i++)\n        ret = Multiply(ret, z);\n    \n    return ret;\n}\n\nfloat Factorial(float n)\n{\n    float ret = 1.0f;\n    for (float i = n; i > 0.0f; i--)\n        ret = ret * i;\n    \n    return ret;\n}\n\nComplex Exp(Complex z)\n{\n    Complex ret = CreateComplex(0.0f, 0.0f);\n    for (float i = 0.0f; i < 13.0f; i++)\n        ret = Add(ret, Divide(IntegerExponentPower(z, i), CreateComplex(Factorial(i), 0.0f)));\n    \n    return ret;\n}\n\nvec3 HSVToRGB(vec3 hsv)\n{\n    float h = hsv.r;  // Hue\n    float s = hsv.g;  // Saturation\n    float v = hsv.b;  // Value\n    \n    vec3 rgb;\n    \n    // Ensure hue is between 0 and 2*pi radians\n    h = mod(h, 2.0f * MATH_PIF);\n    \n    // Convert HSV to RGB\n    float c = v * s;\n    float x = c * (1.0f - abs(mod(h / (MATH_PIF / 3.0f), 2.0f) - 1.0f));\n    float m = v - c;\n\n    if (0.0f <= h && h < MATH_PIF / 3.0f) {\n        rgb.r = c; rgb.g = x; rgb.b = 0.0f;\n    } else if (MATH_PIF / 3.0f <= h && h < 2.0f * MATH_PIF / 3.0f) {\n        rgb.r = x; rgb.g = c; rgb.b = 0.0f;\n    } else if (2.0f * MATH_PIF / 3.0f <= h && h < MATH_PIF) {\n        rgb.r = 0.0f; rgb.g = c; rgb.b = x;\n    } else if (MATH_PIF <= h && h < 4.0f * MATH_PIF / 3.0f) {\n        rgb.r = 0.0f; rgb.g = x; rgb.b = c;\n    } else if (4.0f * MATH_PIF / 3.0f <= h && h < 5.0f * MATH_PIF / 3.0f) {\n        rgb.r = x; rgb.g = 0.0f; rgb.b = c;\n    } else {\n        rgb.r = c; rgb.g = 0.0f; rgb.b = x;\n    }\n\n    rgb.r += m;\n    rgb.g += m;\n    rgb.b += m;\n    \n    return rgb;\n}\n\nvec3 ComplexToRGB(Complex z)\n{\n    float r = Modulus(z);\n    float theta = Arg(z);\n    \n    vec3 hsv = vec3(theta, r, 1.0f);\n\n    return vec3(r, 0.0f, theta);\n}\n\nComplex Transform(Complex inp)\n{\n    vec2 z = vec2(inp.Re, inp.Im);\n    vec2 c = z;\n    \n    for (float i = 0.0f; i < 64.0f; i++)\n        z = dot(z, z) + c;\n    \n    return CreateComplex(inp.Re * inp.Re, inp.Im * inp.Im);\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    vec2 coord = FragCoord / iResolution.xy;\n    coord = coord * 2.0f - 1.0f;\n    \n    float zoomFactor = 1.0f;\n    vec2 camera = vec2(0.5f);\n    \n    Complex complexCoord = CreateComplex(coord);\n    complexCoord.Re -= camera.x;\n    complexCoord.Im -= camera.y;\n    Complex complexCoordOutput = Transform(Multiply(complexCoord, CreateComplex(zoomFactor, 0.0f)));\n    vec3 complexCoordOutputColor = ComplexToRGB(complexCoordOutput);\n    FragColor = vec4(complexCoordOutputColor, 1.0f);\n}","name":"Image","description":"","type":"image"}]}