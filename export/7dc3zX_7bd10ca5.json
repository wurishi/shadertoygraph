{"ver":"0.1","info":{"id":"7dc3zX","date":"1630333461","viewed":269,"name":"Path Tracing with Ray Marching","username":"DELEE","description":"Use Ray marching (sphere tracing) to do the intersection part of path tracing.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI     3.14159265\n#define MAXSTEP 1000\n#define MAXDIST 1000.\n#define ACCEPTDIST .001\n#define MAXDEPTH 8\n#define FinalGatherCount 4\n#define LightLumen 5.0\n#define Diffuse 0.9\n\n// Scene\nvec4 Sphere1 = vec4(0,1.5,10,1.5);\nvec4 Sphere2 = vec4(0,10,10,5.0); // light\nvec4 Sphere3 = vec4(3,1,10,1);\nvec4 Sphere4 = vec4(-2.8,0.9,10,0.9);\nvec4 Sphere5 = vec4(-1.2,0.5,7,0.5);\n//vec4 Sphere6 = vec4(0.5,0.3,7.5,0.3); // light\n\n// set up Random\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 2.f * PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// Scene distance for ray marching\nfloat SceneMinDistance(vec3 Position)\n{    \n    float Sphere1Dist = length(Position - Sphere1.xyz) - Sphere1.w;\n    float Sphere2Dist = length(Position - Sphere2.xyz) - Sphere2.w;\n    float Sphere3Dist = length(Position - Sphere3.xyz) - Sphere3.w;\n    float Sphere4Dist = length(Position - Sphere4.xyz) - Sphere4.w;\n    float Sphere5Dist = length(Position - Sphere5.xyz) - Sphere5.w;\n    //float Sphere6Dist = length(Position - Sphere6.xyz) - Sphere6.w;\n    float MinSphereDist;\n    MinSphereDist = min(Sphere1Dist, Sphere2Dist);\n    MinSphereDist = min(MinSphereDist, Sphere3Dist);\n    MinSphereDist = min(MinSphereDist, Sphere4Dist);\n    MinSphereDist = min(MinSphereDist, Sphere5Dist);\n    //MinSphereDist = min(MinSphereDist, Sphere6Dist);\n    \n    float Plane1Dist = Position.y;\n    float Plane2Dist = abs(Position.x - 5.f);\n    float Plane3Dist = Position.x + 5.f;\n    float Plane4Dist = abs(Position.z - 20.f);\n    float MinPlaneDist;\n    MinPlaneDist = min(Plane1Dist, Plane2Dist);\n    MinPlaneDist = min(MinPlaneDist, Plane3Dist);\n    MinPlaneDist = min(MinPlaneDist, Plane4Dist);\n    \n    float MinDistance = min(MinSphereDist,MinPlaneDist);\n \n    return MinDistance;\n}\n\nbool LightMinDistance(vec3 Position)\n{       \n    float Sphere2Dist = length(Position - Sphere2.xyz) - Sphere2.w;\n    //float Sphere6Dist = length(Position - Sphere6.xyz) - Sphere6.w;\n    \n    float MinSphereDist;\n    //MinSphereDist = min(Sphere2Dist, Sphere6Dist);\n    MinSphereDist = Sphere2Dist;\n \n    return MinSphereDist < ACCEPTDIST;\n}\n\n\nvec3 GetNormal(vec3 p) {\n    float d = SceneMinDistance(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        SceneMinDistance(p-e.xyy),\n        SceneMinDistance(p-e.yxy),\n        SceneMinDistance(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec4 RayMarch(vec3 Position, vec3 Direction) // return (normal, distance)\n{\n    float Distance = 0.f;\n    for(int step = 0;step < MAXSTEP;step++)\n    {\n        vec3 P = Position + Direction * Distance;\n        float DistanceNext = SceneMinDistance(P);\n        Distance += DistanceNext;\n        if(Distance > MAXDIST) break; // miss\n        if(DistanceNext < ACCEPTDIST) return vec4(GetNormal(Position + Direction * Distance), Distance);\n    }\n    return vec4(vec3(0),10000.);\n}\n\nvec3 PathTracing(vec3 Position, vec3 Direction, inout uint rngState)\n{\n    vec4 Trace = vec4(1);\n    vec3 Radiance = vec3(1);\n    vec3 HitPoint = Position;\n    vec3 NextDirection = Direction;\n    for(int Depth = 0;Depth < MAXDEPTH;Depth ++)\n    {\n        Trace = RayMarch(HitPoint,NextDirection);\n        if(Trace.w > MAXDIST) return vec3(0); // Miss\n        \n        HitPoint += NextDirection * Trace.w;\n        \n        if(LightMinDistance(HitPoint))\n        {\n            // Hit Light\n            Radiance *= vec3(LightLumen);\n            //Radiance *= abs(dot(Trace.xyz, -1.f*NextDirection));\n            return Radiance;\n        }\n        \n        // prepare for next trace\n        Radiance *= vec3(Diffuse) / PI;\n        NextDirection = normalize(Trace.xyz + RandomUnitVector(rngState)); // Random direction\n        HitPoint += 0.01*Trace.xyz; // some monior problem with offseting\n        \n    }\n    return vec3(0); // Still did not hit Light\n}\n\nvec3 NEE(vec3 P, vec3 normal, inout uint rngState)\n{\n    vec3 Position = P;\n    vec3 Radiance = vec3(1.f);\n    vec3 LightPos = Sphere2.xyz + Sphere2.w * RandomUnitVector(rngState);\n    vec3 LightNormal = normalize(LightPos - Sphere2.xyz);\n    vec3 Direction = LightPos - Position;\n    vec3 DirectionNormalize = normalize(Direction);\n    vec4 Trace = RayMarch(Position, DirectionNormalize);\n    Position += DirectionNormalize * Trace.w;\n    if(LightMinDistance(Position))\n    {\n        Radiance *= vec3(LightLumen);\n        Radiance *= abs(dot(LightNormal, -1.f*DirectionNormalize)/(dot(Direction, Direction)+0.001f));\n        Radiance *= dot(normal, DirectionNormalize) * Sphere2.w * Sphere2.w * PI;\n        return Radiance;\n    }\n    return vec3(0.f);\n}\n\nvec3 DirectLight(vec3 Position, vec3 Direction, inout uint rngState)\n{\n    vec4 Trace = vec4(1);\n    vec3 Radiance = vec3(1);\n    vec3 HitPoint = Position;\n    vec3 NextDirection = Direction;\n        \n    Trace = RayMarch(HitPoint,NextDirection);\n    if(Trace.w > MAXDIST) return vec3(0); // Miss\n    HitPoint += NextDirection * Trace.w;\n        \n    if(LightMinDistance(HitPoint))\n    {\n        // Hit Light\n        Radiance *= vec3(LightLumen);\n        //Radiance *= abs(dot(Trace.xyz, -1.f*NextDirection));\n        return Radiance;\n    }\n    \n    HitPoint += 0.01*Trace.xyz; // some monior problem with offseting\n        \n    // NEE\n    Radiance *= vec3(Diffuse)/PI;\n    Radiance *= NEE(HitPoint, normalize(Trace.xyz), rngState);\n        \n    return Radiance;\n}\n\n\nvec3 FinalGather(vec3 Position, vec3 Direction, inout uint rngState)\n{\n    vec4 Trace = vec4(1);\n    vec3 Radiance = vec3(1);\n    vec3 HitPoint = Position;\n    vec3 NextDirection = Direction;\n        \n    Trace = RayMarch(HitPoint,NextDirection);\n    if(Trace.w > MAXDIST) return vec3(0); // Miss\n    HitPoint += NextDirection * Trace.w;\n        \n    if(LightMinDistance(HitPoint))\n    {\n        // Hit Light\n        Radiance *= vec3(LightLumen);\n        return Radiance;\n    }\n    \n    HitPoint += 0.01*Trace.xyz; // some monior problem with offseting\n    vec3 normal = Trace.xyz;\n        \n    // NEE\n    Radiance *= vec3(Diffuse)/PI;\n    \n    vec3 NEERadiance = NEE(HitPoint, normalize(Trace.xyz), rngState);\n    vec3 NextRadiance = vec3(0.f);\n    \n    float SampleCount = 0.f;\n    // Final Gathering\n    for(int i = 0;i < FinalGatherCount;i ++)\n    {\n        NextDirection = normalize(normal + RandomUnitVector(rngState)); // Random direction\n        Trace = RayMarch(HitPoint,NextDirection);\n        vec3 SamplePoint = HitPoint + NextDirection * Trace.w + 0.01*Trace.xyz;\n        if(Trace.w > MAXDIST) continue;\n        SampleCount ++;\n        vec3 tmpRadiance = vec3(Diffuse)/PI;\n        tmpRadiance *= NEE(SamplePoint, normalize(Trace.xyz), rngState);\n        NextRadiance += tmpRadiance;\n    }\n    \n    Radiance *= ((NextRadiance/(SampleCount))+NEERadiance);\n        \n    return Radiance; // Still did not hit Light\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    float jitterSize = 2.;\n    vec2 jitter = jitterSize*vec2(2.*RandomFloat01(rngState)-1.,2.*RandomFloat01(rngState)-1.);\n    vec2 uv = (fragCoord+jitter-0.5*iResolution.xy)/(iResolution.x);\n    \n    // X -> right/left\n    // Y -> up/down\n    // Z -> depth\n    vec3 CameraPosition = vec3(0,1.5,0);\n    float FOV = 100.f;\n    vec3 RayDirection = normalize(vec3(uv,(cos(FOV/(180.f*2.f)*PI)/sin(FOV/(180.f*2.f)*PI))));\n    \n    // Ray March\n    //vec3 color = abs(RayMarch(CameraPosition, RayDirection).xyz);\n    \n    // render\n    vec3 color = PathTracing(CameraPosition, RayDirection, rngState);\n    //vec3 color = FinalGather(CameraPosition, RayDirection, rngState);\n    //vec3 color = DirectLight(CameraPosition, RayDirection, rngState);\n    \n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    float frame = texture(iChannel0, fragCoord / iResolution.xy).a;\n    if(iFrame == 0)\n    {\n        frame = 0.f;\n    }\n    if(iMouse.z > 0.f) // reset average when mouse click\n    {\n        frame = 0.f;\n    }\n    //color = mix(lastFrameColor, color, 1.0f / float(iFrame+1));\n    color = lastFrameColor + ((color - lastFrameColor)/(float(frame+1.f)));\n    \n    fragColor = vec4(color,frame+1.f);\n}","name":"Buffer A","description":"","type":"buffer"}]}