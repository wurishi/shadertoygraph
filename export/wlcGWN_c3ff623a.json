{"ver":"0.1","info":{"id":"wlcGWN","date":"1576348464","viewed":139,"name":"procedural_world_pdf","username":"diogotito","description":"guidelines I followed from a cool PDF on the web","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Point vec2\n#define Color vec4\n\n\nvoid getSkyColor(float x, float y, inout Color color) {\n    float h = max(0.0, 1.4 - y - pow(abs(x - 0.5), 3.0));\n    color.r = pow(h, 3.0);\n    color.g = pow(h, 7.0);\n    color.b = 0.2 + pow(max(0.0, h - 0.1), 10.0);\n}\n\n\n// a one-liner I found on the web somewhere\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat hash(float i) { return rand(vec2(i, i*123.4+245.6)); }\n\n\nfloat noise(float x) {\n    float i = floor(x), f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return 2.0 * mix(hash(i), hash(i + 1.0), u) - 1.0;\n}\n\n\nfloat terrain(float x) {\n    float y = 0.0;\n    for (int octave = 0; octave < 8; ++octave) {\n        float k = pow(2.0, float(octave));\n        y += noise(x * k) / k;\n    }\n    \n    y = y * 0.66 + 0.04;\n    y *= min(exp(x) - 2., 1.);\n    return y;\n}\n\n\nfloat water(float x) {\n    return 0.22 + 0.005 * sin(200.0 * (x + iTime * 0.03));\n}\n\n\nvoid mainImage( out Color color, in Point coord )\n{\n    // Normalized coordinates\n    float x = coord.x / iResolution.x;\n    float y = coord.y / iResolution.y;\n     \n    getSkyColor(x, y, color);\n    \n\tfloat shift = 0.09 * iTime + 0.2;\n    x += shift;\n    \n    float h = max(water(x), terrain(x));\n    if (y < h) { color = Color(0.0); }\n}","name":"Image","description":"","type":"image"}]}