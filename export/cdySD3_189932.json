{"ver":"0.1","info":{"id":"cdySD3","date":"1681739615","viewed":69,"name":"IFSBrot","username":"cancrizans","description":"Known as \"Mandelbrot set for a pair of linear maps\", the (outer black) region is the set of complex parameters r s.t. the IFS generated by the two maps z -> +- 1 + rz is disconnected.\n\nReal axis region hidden because it requires too much memory.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int BUFFER_SIZE_LOG2 = 8;\nconst int BUFFER_SIZE = 1<<BUFFER_SIZE_LOG2;\nconst int BUFFER_MODMASK = BUFFER_SIZE - 1;\n\n// the real exact bound is |r|^2 > .25 and tight, but\n// if you remove the real axis spike you can push it to .4\nconst float inner_r2 = 0.4;\n\n// I think main limiting factor is memory to allocate\n// for this queue. Clever early bailout tricks\n// don't really seem to help...\nvec2 queue [BUFFER_SIZE+2];\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n\nint ifsbrot(vec2 r){\n    if(abs(r.y)<0.05)\n        return BUFFER_SIZE;\n    float r2 = dot(r,r);\n    if(r2 < inner_r2)\n        return 4;\n    \n    if(r2 > .5)\n        return 1;    \n    \n    int pop_idx = 0;\n    int push_idx = 1;\n    \n    vec2 rinv = vec2(r.x,-r.y)/r2;\n    queue[0] = rinv;\n    \n    float bailout = 1./(1.-sqrt(r2));\n    float bailout2 = bailout*bailout;\n    \n    int max_steps = BUFFER_SIZE;\n    \n    for(int it = 0; it < max_steps; it++){\n        vec2 t = queue[pop_idx];\n        pop_idx = (pop_idx+1)&BUFFER_MODMASK;\n \n        vec2 t_over_r = cmul(t,rinv);\n        //really hope this unrolls\n        for(int delta = -1; delta<=1; delta++)\n        {\n          \n            vec2 nt = t_over_r + float(delta) * rinv;\n            if(dot(nt,nt)<bailout2)\n            {\n                queue[push_idx] = nt;\n                push_idx = (push_idx+1)&BUFFER_MODMASK;\n                if(pop_idx==push_idx)\n                    return pop_idx;\n            }\n        }\n    }\n    return 1;\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float th = iTime*.125;\n    vec2 c = 0.65 * vec2(cos(th),sin(th));\n    float scale = exp(-3. + 3.*pow(.5*cos(th)+.5,2.0));\n    vec2 r = c + 1.3*scale*uv;\n    \n    int brot = ifsbrot(r);\n    \n    vec3 col = (0.2 + log(float(brot)) * 0.25) * vec3(1,1,1);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}