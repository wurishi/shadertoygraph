{"ver":"0.1","info":{"id":"ctSSzh","date":"1698406239","viewed":114,"name":"Steel Ball","username":"derangedlines","description":"Steel ball with orbiting shards.\nMy first attempt at creating a moving scene with lighting, textures and multiple objects using raymarching. Original composition by GÃ¡bor Bartis (@gabor.bartis)","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","metal","steel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\n\nvec3 rotateX(vec3 v, float theta) {\n  return vec3(v.x, v.y*cos(theta) - v.z*sin(theta), v.y*sin(theta) + v.z*cos(theta));\n}\nvec3 rotateY(vec3 v, float theta) {\n  return vec3(v.x*cos(theta) + v.z*sin(theta), v.y, -v.x*sin(theta) + v.z*cos(theta));\n}\nvec3 rotateZ(vec3 v, float theta) {\n  return vec3(v.x*cos(theta) - v.y*sin(theta), v.x*sin(theta) + v.y*cos(theta), v.z);\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nfloat SDFSphere(vec3 position, vec3 center, float radius) {\n  return length(position-center)-radius;\n}\n\nfloat SDFBox(vec3 position, vec3 center, vec3 size, float r) {\n    vec3 q = abs(position-center)-0.5*size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 map (in vec3 position, float time) {\n    float d = SDFSphere(position, vec3(0.0), 0.25);\n    for (int i=0; i<24; i++) {\n        float startAngle = 2.0/24.0 * PI * float(i);\n        float fi = startAngle + 2.0*PI*time;\n        float length = 0.5 + pow(sin(float(7.0 * float(i))),2.0);\n        float width = 0.04 + 0.05*pow(sin(float(9.0 * float(i))),2.0);\n        float height = 0.02 + 0.05*pow(sin(float(11.0 * float(i))),2.0);\n        float gap = 0.3 + 0.2*pow(sin(float(i)),2.0);\n        d = min(d, SDFBox(vec3(gap+0.5*length,0.0,0.0)+rotateX(rotateY(position, fi), 1.0+startAngle), \n        vec3(0.0), vec3(length, height, width), 0.003));\n    }\n\n    return vec2(d, 1.0);\n}\n\nvec3 calculateNormal(vec3 p, float time) {\n    float EPS = 0.001;\n    vec3 v1 = vec3(\n      map(p + vec3(EPS, 0.0, 0.0), time).x,\n      map(p + vec3(0.0, EPS, 0.0), time).x,\n      map(p + vec3(0.0, 0.0, EPS), time).x);\n    vec3 v2 = vec3(\n      map(p - vec3(EPS, 0.0, 0.0), time).x,\n      map(p - vec3(0.0, EPS, 0.0), time).x,\n      map(p - vec3(0.0, 0.0, EPS), time).x);\n      \n    return normalize(v1-v2);\n  }\n\n\nvec3 castRay (in vec3 rayOrigin, vec3 rayDirection, float time) {\n    float distance = 0.0;\n    float material = -1.0;\n    int steps = 0;\n    for(; steps<100; steps++) {\n        vec3 rayPosition = rayOrigin + distance * rayDirection;\n        vec2 step = map(rayPosition, time);\n        material = step.y;\n        \n        if(step.x < 0.001)\n            break;\n        \n        distance += step.x;\n        \n        if(step.x > 20.0)\n            return vec3(-1.0);\n    }\n    return vec3(distance, material, steps);\n}\n\nfloat softShadow(in vec3 rayOrigin, vec3 rayDirection, float minDistance, float maxDistance, float hardness, float time)\n{\n    float res = 1.0;\n    float distance = minDistance;\n    while (distance < maxDistance)\n    {\n        vec2 step = map(rayOrigin + distance * rayDirection, time);\n        if(step.x < 0.001)\n            return 0.0;\n        res = min(res, hardness * step.x/distance );\n        distance += step.x;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates (from -1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Main time for animation\n    float time = 0.05 * iTime;\n    \n    // Camera position\n    vec3 rayOrigin = vec3 (0.0, 0.5, -1.0);\n    vec3 cameraDirection = vec3(0.25, 0.0, -0.25);\n    \n    vec3 ww = normalize(cameraDirection - rayOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rayDirection = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    \n    //Background color\n    vec3 color = vec3(0.001);\n    \n    vec3 r = castRay(rayOrigin, rayDirection, time);\n    float distance = r.x;\n    float material = r.y;\n    float steps = r.z;\n    \n    if(distance > 0.0) {\n        // Ray hit\n        vec3 position = rayOrigin + distance * rayDirection;\n        vec3 normal = calculateNormal(position, time);\n        \n        // Material\n        vec3 dark = vec3(0.1, 0.1, 0.1);\n        vec3 light = vec3(0.5, 0.61, 0.7);\n        \n        // Pattern\n        float noise = 1.0;\n        if(length(position) < 0.3) {\n            vec3 rotatingPos = rotateY(rotateZ(position, 0.2), 4.0*PI*time);\n            \n            noise = 0.5+0.8*simplex3d_fractal(20.0*rotatingPos);\n            }\n        else {\n            vec3 rotatingPos = rotateY(position,2.0*PI*time);\n            noise = 0.5+0.8*simplex3d_fractal(20.0*vec3(10.0*atan(rotatingPos.z, rotatingPos.x), pow(pow(rotatingPos.x, 2.0)+pow(rotatingPos.z, 2.0),0.5), 10.0*rotatingPos.y));\n            noise *= 0.8+simplex3d_fractal(10.0*rotatingPos);\n        }\n        color = mix(dark, light, noise);\n        \n         \n        // Diffused light 1\n        vec3 light1Direction = 0.5 * normalize(vec3(0.4, 0.6, -0.2));\n        float diffusedLight1 = clamp(dot(normal, light1Direction),0.0, 1.0);\n        // Specular\n        vec3 half1 = normalize(light1Direction - rayDirection);\n        float specularLight1 = 5.0 * pow(clamp(dot(half1, normal), 0.0, 1.0), 32.0);\n        specularLight1 *= 0.5 + 0.5*pow(1.0-clamp(dot(half1, light1Direction), 0.0, 1.0), 5.0);\n        // Soft shadows\n        float shadow1 = softShadow(position + 0.001*normal, light1Direction, 0.0, 20.0, 4.0, time);\n        \n        // Diffused light 2\n        vec3 light2Direction = normalize(vec3(-2.0, -0.5, -0.5));\n        float light2Strength = 5.0;\n        float diffusedLight2 = clamp(dot(normal, light2Strength*light2Direction),0.0, 1.0);\n        // Specular\n        vec3 half2 = normalize(light2Direction - rayDirection);\n        float specularLight2 = 5.0 * pow(clamp(dot(half2, normal), 0.0, 1.0), 32.0);\n        specularLight2 *= 0.5 + 0.5*pow(1.0-clamp(dot(half2, light2Direction), 0.0, 1.0), 5.0);\n        // Soft shadows\n        float shadow2 = softShadow(position + 0.001*normal, light2Direction, 0.0, 20.0, 4.0, time);\n        \n        // Fake ambient occlusion\n        float occlusion = 1.0;\n        occlusion = clamp(pow((10.0/steps),2.0),0.0, 1.0);\n      \n        // Colors\n        vec3 light1Color = vec3(0.9, 0.95, 0.95);\n        vec3 light2Color = vec3(0.9, 0.95, 0.95);\n        \n        vec3 linear = vec3(0.0);\n        linear += light1Color * diffusedLight1 * shadow1;\n        linear += light2Color * diffusedLight2 * shadow2;\n        color *= linear * occlusion;\n        color += light1Color * specularLight1 * shadow1 * noise;\n        color += light2Color * specularLight2 * shadow2 * noise;\n    }\n    \n    color = pow(color, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}