{"ver":"0.1","info":{"id":"MXSSWD","date":"1710593003","viewed":51,"name":"TP2 Textures","username":"LiQiye","description":"Ensembles de textures régulières, avec turbulence.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["textures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing and noise \n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat Turbulence(vec3 p,float totalSize) {\n float Amplitude;\n float Rotation=1.;\n float LongueurOnde;\n float Bruit;\nint currentOctave;\n float acc=0.;\n  float alpha0=totalSize/14.;\n  float lambda0=1.0;\n  float beta=2.;\n  int totalOctaves=6;\n for(currentOctave=0;currentOctave<totalOctaves;currentOctave++){\n    Amplitude=alpha0*pow(beta,-float(currentOctave));\n    LongueurOnde=alpha0*pow(beta,-float(currentOctave));\n    Bruit=Noise(pow(Rotation,float(currentOctave))*p/LongueurOnde);\n    acc+=Amplitude*Bruit;\n }\n return acc;\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// Camera -----------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(35.0,0.0,15.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n// Texturing\n// Eric Galin\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n\n\n\n// Structure for texture\n// c : Color\n// s : Specular\n// a : ambiant\n// d : diffus\nstruct T {\n    vec3 c;\n    float s;\n    float a;\n    float d;\n};\n\n\n// Structure for objects\n// T texture\n// v : Field value\nstruct V {\n    float v; \n    T color;\n};\n// Shading and lighting ---------------------------------------------------------------------------\n\nT Union(T a,T b)\n{\n    if (length(a.c)>length(b.c))\n        return a;\n    else \n    {\n        return b;\n    }\n}\n\nT CustomUniform(vec3 rgb){\n  float r=clamp(rgb.x,0.,1.);\n  float g=clamp(rgb.y,0.,1.);\n  float b=clamp(rgb.z,0.,1.);\n  return T(vec3(r,g,b),0.5,0.5,0.5);\n}\n\nT White(){\n  return T(vec3(1.,1.,1.),0.5,0.5,0.5);   \n}\n\nT Black(){\n  return T(vec3(0.,0.,0.),0.5,0.5,0.5);   \n}\n\nT Red(){\n    return T(vec3(1.,0.,0.),0.5,0.5,0.); \n}\nT Green(){\n    return T(vec3(0.,1.,0.),0.5,0.,0.); \n}\n\nT Blue(){\n    return T(vec3(0.,0.,1.),0.5,0.5,0.5); \n}\n\nT PlankColor(){\n    return T(vec3(0.8,0.5,0.3),0.5,0.5,0.5);\n}\n\nT Stripes(float axis, float stripeSize, float spaceSize, vec3 colorStripe1, vec3 colorStripe2) {\n    float totalSize = stripeSize + spaceSize;\n    float stripeDist = axis / totalSize;\n    float fr=fract(stripeDist);\n    if (fr<stripeSize/totalSize) {\n        return T(colorStripe1, 0.5,0.5,0.5);\n    } else {\n        return T(colorStripe2, 0.5,0.5,0.5);\n    }\n}\n\nT CircleStripes(vec3 p, vec3 center, float width1, float width2, vec3 colorStripe1, vec3 colorStripe2) {\n    float totalSize = width1 + width2;\n    float dist=distance(p,center);\n    float k=dist/totalSize;\n    k=fract(k);\n    if(k>(width1/totalSize)){\n        return T(colorStripe1, 0.5,0.5,0.5);\n    }\n    else return T(colorStripe2, 0.5,0.5,0.5);\n}\n\n\nT Circle(vec3 p,vec3 center,float r,float width){\n    bool inCircle=false;\n    float dist=distance(p,center);\n    if(dist<=r+width&&dist>=r)inCircle=true;\n    if(inCircle){\n        return T(White().c,0.5,0.5,0.5);\n    }\n    else return T(Black().c,0.5,0.5,0.5);\n}\nT FullCircle(vec3 p,vec3 center,float r,vec3 Color){\n    bool inCircle=false;\n    float dist=distance(p,center);\n    if(dist<=r){\n        return T(Color,0.5,0.5,0.5);\n    }\n}\n\n\nT Grid(vec3 position, float stripeSize, float spaceSize, vec3 colorStripe1, vec3 colorStripe2) {\n    float totalSize = stripeSize + spaceSize;\n    float stripeDistX = position.x / totalSize;\n    float frX=fract(stripeDistX);\n    float stripeDistY = position.y / totalSize;\n    float frY=fract(stripeDistY);\n\n    bool stripe1=(frX < stripeSize/totalSize) || (frY < stripeSize/totalSize);\n    if (stripe1) {\n        return T(colorStripe1, 0.5,0.5,0.5);\n    } else {\n        return T(colorStripe2, 0.5,0.5,0.5);\n    }\n}\n\nT Marbre(vec3 p, float stripeSize, float spaceSize) {\n    p+=spaceSize*Turbulence(p,10.*(spaceSize+stripeSize))/sin(stripeSize*spaceSize);\n     T Grid=Grid(p,stripeSize,spaceSize,vec3(clamp(sin(p.x+p.y),0.4,0.8)),vec3(0.87));\n     Grid.s=1.;\n     Grid.a=0.8;\n     Grid.d=0.8;\n    return Grid;\n}\n\nT Damier(in vec3 p, float tailleCase)\n{\n    vec3 pNorm=p/tailleCase;\n    vec3 pArr = floor(pNorm);\n    float sum = mod(pArr.x + pArr.y + pArr.z, 2.0);\n    return T(vec3(sum), 0.5,0.5,0.5);\n}\n\nT Ecorce(vec3 p,float PlankSize){\n    float detailSize=PlankSize/10.;\n    float turb=Turbulence(p,3.);\n    vec3 Plank1=PlankColor().c*0.6;\n    vec3 Plank2=PlankColor().c*0.4;\n\n    return Stripes(p.z+Turbulence(p,PlankSize*5.),detailSize,detailSize*2.,Plank1,Plank2);\n}\n\n T CircularPlank(vec3 p,vec3 center,float PlankSize){\n     float stripe1Size=PlankSize*0.05;\n     float stripe2Size=PlankSize*0.95;\n     float turb=Turbulence(p,3.);\n     vec3 Plank1=PlankColor().c*1.6;\n      vec3 Plank2=PlankColor().c*1.2;\n      vec3 turbPos=vec3(p.x+Turbulence(p,PlankSize*2.),p.y+Turbulence(p,PlankSize*3.),center.z);\n    return CircleStripes(turbPos,center,stripe1Size,stripe2Size,Plank1,Plank2);\n }\n\n T Sand(vec3 p,float grainSize){\n    float value=clamp(cos((p.x+p.y)/grainSize),0.4,0.8);\n    vec3 yellowSand= vec3(value,value,0);\n    return T(yellowSand,0.5,0.5,0.5);\n }\n\n\n\n\n\n//Tools\nbool isBetweenPoints(vec3 p,vec3 a,vec3 b){\n    vec3 u1 = normalize(b - a);\n    vec3 PA=p-a;\n    float proja=dot(PA,u1);\n    vec3 PB=p-b;\n    float projb=dot(PB,u1);\n    return proja*projb<0.;\n}\nvec3 getProjectionVector(vec3 v, vec3 u) {\n  u=normalize(u);\n  return dot(v,u)*u;\n}\n\nvec3 getRejectionVector(vec3 v, vec3 u) {\n  return v-getProjectionVector(v,u);\n}\nbool inCircleAxe(vec3 p,vec3 center,vec3 normal,float radius){\n  vec3 v=p-center;\n  vec3 rejection=getRejectionVector(v,normal);\n  return length(rejection)<=radius;\n}\n\nvec3 changeLength(vec3 v,float len){\n  return (len/length(v))*v;\n}\n\nmat3 RotationAxis(vec3 axis, float angle) {\n    vec3 a = normalize(axis);\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n\n    return mat3(\n        a.x * a.x + (1. - a.x * a.x) * c,\n        a.x * a.y * (1. - c) - a.z * s,\n        a.x * a.z * (1. - c) + a.y * s,\n        \n        a.x * a.y * (1. - c) + a.z * s,\n        a.y * a.y + (1. - a.y * a.y) * c,\n        a.y * a.z * (1. - c) - a.x * s,\n        \n        a.x * a.z * (1. - c) - a.y * s,\n        a.y * a.z * (1. - c) + a.x * s,\n        a.z * a.z + (1. - a.z * a.z) * c\n    );\n}\nvec3 getNormal(vec3 CommonPoint, vec3 r, vec3 s) {\n    vec3 rb = r - CommonPoint;\n    vec3 sb = s - CommonPoint;\n    return cross(rb, sb);\n}\n\nvec3 getNormal(vec3 v) {\n    float l = length(v);  \n    vec3 n = cross(vec3(1, 0, 0),v);  \n    if (length(n) < 0.01) {  \n        n = cross(v, vec3(0, 0, 1));\n    }\n    return changeLength(n,l);  \n}\n\n\nvec3 getNormal(vec3 d1, vec3 d2) {\n    vec3 n = cross(d1, d2); \n    n = normalize(n); \n    float length_d1 = length(d1);\n    return n * length_d1;\n}\nvec3 RotateAxis(vec3 v,vec3 axis,float degree){\n  return RotationAxis(axis,degree)*v;\n}\n\nvec3 getNormalOpp(vec3 a,vec3 b,vec3 c,vec3 posDot){\n  vec3 v1=a-b;\n  vec3 v2=c-b;\n  vec3 normal=getNormal(v1,v2);\n  vec3 vpos=posDot-b;\n  if(dot(vpos,normal)>0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nvec3 getNormalOpp(vec3 a,vec3 normal,vec3 posDot){\n  vec3 vpos=posDot-a;\n  if(dot(vpos,normal)>0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\n\n\n\nfloat sqr(float a){\n    return a*a;\n}\n\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.color);\n    else \n    {\n        return V(b.v,b.color);\n    }\n}\n\n\n\n\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.color);\n    }\n    else \n    {\n        return V(b.v,a.color);\n    }\n}\n\n\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\n// V Plane(vec3 p, vec3 origin, vec3 normal)\n// {\n//     return V(dot((p-origin),normal),White());\n// }\n\nV Plane(vec3 p,vec3 c, vec3 normal) {\n  vec3 cp=p-c;\n  float resDot=dot(cp,normal);\n  float len=length(getProjectionVector(cp,normal));\n  if(resDot>=0.){\n    return V(len,White());\n  }\n  else return V(-len,White());\n}\n//Renvoie un plan sans épaisseur\nV unsignedPlane(vec3 p, vec3 c, vec3 normal) {\n  vec3 pc=p-c;\n  return V(length(getProjectionVector(pc,normal)),White());\n}\n\nV DamierPlane(vec3 p, vec3 origin, vec3 normal,float squareSize,float turbScale)\n{\n    float turbValue = Turbulence(p,squareSize) * turbScale;\n    return V(dot((p-origin),normal)+turbValue,Damier(p,squareSize));\n}\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nV Sphere(vec3 p, vec3 c,float r)\n{\n  return V(length(p-c)-r,White());\n}\n\nV DamierSphere(vec3 p, vec3 c,float r,int nb,float turbScale)\n{\n  float turbValue = Turbulence(p,2.*r) * turbScale;\n  return V(length(p-c)-r+turbValue,Damier(p,(2.*r)/float(nb)));\n}\n\n// Cube \n// p : point\n// c : center \n// r : radius\nV Cube(vec3 p,vec3 c,float r)\n{\n   vec3 q = abs(p-c) - vec3(r);\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),White());\n}\n\nV Segment(vec3 p, vec3 a, vec3 b) {\n    float distA=distance(p,a);\n    vec3 u1 = normalize(b - a);\n    vec3 PA=p-a;\n    float proja=dot(PA,u1);\n    if(isBetweenPoints(p,a,b)){\n        return V(sqrt(sqr(distA)-sqr(proja)),White());\n    }\n    else{\n      float distB=distance(p,b); \n      return V(min(distA,distB),White());\n    } \n}\n\nV Disc(vec3 p, vec3 center, vec3 normal, float radius) {\n    vec3 hypotenuse=p-center;\n    if(inCircleAxe(p,center,normal,radius)){\n        return unsignedPlane(p,center,normal);\n    }\n    vec3 parallel=getRejectionVector(hypotenuse,normal);\n    return V(distance(p,center+changeLength(parallel,radius)),White()); \n}\n\nV Cylinder(vec3 p, vec3 center1, vec3 center2, float radius) { \n    vec3 axis = center1 - center2;\n    if(isBetweenPoints(p,center1,center2)){\n      return V(Segment(p,center1,center2).v-radius,White());\n    }\n    else return V(min(Disc(p,center1,axis,radius).v,Disc(p,center2,axis,radius).v)-0.01,White());\n}\n\nV EcorceCylinder(vec3 p, vec3 center1, vec3 center2, float radius,float turbScale){\n    V cylinder =Cylinder(p,center1,center2,radius);\n    float turbValue = Turbulence(p, 2.0 * radius) * turbScale;\n    return V(cylinder.v+turbValue*turbScale,Ecorce(p,radius/4.));\n}\n\nV CirclePlankCylinder(vec3 p, vec3 center1, vec3 center2, float radius,float turbScale){\n    V cylinder =Cylinder(p,center1,center2,radius);\n    float turbValue = Turbulence(p, 2.0 * radius) * turbScale;\n    return V(cylinder.v+turbValue*turbScale,CircularPlank(p,(center1+center2)/2.,radius/13.));\n}\n\nV LogCylinder(vec3 p, vec3 center1, vec3 center2, float radius,float turbScale){\n    if(distance(p.xy,center1.xy)>=0.88*radius){\n        return EcorceCylinder(p,center1,center2,radius,turbScale);\n    }\n    else return CirclePlankCylinder(p,center1,center2,radius,0.);\n}\n\nV Cube(vec3 p,vec3 c,float r,vec3 color)\n{\n   vec3 q = abs(p-c) - vec3(r);\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),CustomUniform(color));\n}\n\nV DamierCube(vec3 p, vec3 c, float r, int nb, float turbScale) {\n    V cube=Cube(p,c,r);\n    float turbValue = Turbulence(p,2.*r) * turbScale;\n    return V(cube.v + turbValue, Damier(p, 2.0 * r / float(nb)));\n}\n\nV StripesCube(vec3 p, vec3 c, float r, int nbStripes, float Percentage, float turbScale) {\n    V cube = Cube(p, c, r);\n    float turbValue = Turbulence(p, 2.0 * r) * turbScale;\n    float sameSize = 2.0 * r / float(nbStripes);\n    float stripeSize;\n    float spaceSize;\n    Percentage=clamp(Percentage, 0.0, 1.0);\n    float diff=abs(1.-Percentage-Percentage);\n    if(Percentage>0.5){\n        stripeSize = sameSize + (diff*sameSize);\n        spaceSize = sameSize -(diff*sameSize);\n    }\n    else{\n        stripeSize = sameSize - (diff*sameSize);\n        spaceSize = sameSize + (diff*sameSize);\n    }\n    return V(cube.v + turbValue, Stripes(p.x, stripeSize, spaceSize,vec3(abs(cos(p.x)),abs(cos(p.y)),abs(cos(p.z))),vec3(abs(sin(p.x)),abs(sin(p.y)),abs(sin(p.z)))));\n}\n\nV MarbreCube(vec3 p, vec3 c, float r, int nbStripes, float turbScale) {\n    V cube = Cube(p, c, r);\n    float turbValue = Turbulence(p, 2.0 * r) * turbScale;\n    if(nbStripes<3)nbStripes=3;\n    float sameSize = 2.0 * r / float(nbStripes);\n    float stripeSize;\n    float spaceSize;\n    float Percentage=0.08;\n    Percentage=clamp(Percentage, 0.0, 1.0);\n    float diff=abs(1.-Percentage-Percentage);\n    if(Percentage>0.5){\n        stripeSize = sameSize + (diff*sameSize);\n        spaceSize = sameSize -(diff*sameSize);\n    }\n    else{\n        stripeSize = sameSize - (diff*sameSize);\n        spaceSize = sameSize + (diff*sameSize);\n    }\n    return V(cube.v + turbValue, Marbre(p, stripeSize, spaceSize));\n}\n\nV EcorceCube(vec3 p, vec3 c,float r,float turbScale){\n    V cube =Cube(p,c,r);\n    float turbValue = Turbulence(p, 2.0 * r) * turbScale;\n    return V(cube.v+turbValue*turbScale,Ecorce(p,r/2.));\n}\n\nV CirclePlankCube(vec3 p,vec3 c,float r,float turbScale){\n    V cube=Cube(p,c,r);\n    float turbValue = Turbulence(p,r) * turbScale;\n    return V(cube.v + turbValue, CircularPlank(p,c,r/10.));\n}\n\nV LogCube(vec3 p,vec3 c,float r,float turbScale){\n    if(distance(p.xy,c.xy)>=0.99*r){\n        return EcorceCube(p,c,r,turbScale);\n    }\n    else return CirclePlankCube(p,c,r,turbScale);\n}\n\nV Pyramid(vec3 p,vec3 a,vec3 c,vec3 normal,float height){\n  float distTr1,distTr2,distTr3,distTr4,distBase;\n  vec3 ca=c-a;\n  vec3 mid=(c+a)/2.;\n  vec3 halfdiag=ca/2.;\n  vec3 d=mid+RotateAxis(halfdiag,normal,90.);\n  vec3 b=mid-RotateAxis(halfdiag,normal,90.);\n  vec3 top=mid+changeLength(normal,height);\n  \n  vec3 nabcd=getNormalOpp(d,a,b,top);\n  vec3 nabtop=getNormalOpp(a,b,top,c);\n  vec3 nadtop=getNormalOpp(a,d,top,b);\n  vec3 nbctop=getNormalOpp(b,c,top,d);\n  vec3 ncdtop=getNormalOpp(c,d,top,a);\n  V splane1=Plane(p,a,nabcd);\n  V splane2=Plane(p,a,nabtop);\n  V splane3=Plane(p,a,nadtop);\n  V splane4=Plane(p,b,nbctop);\n  V splane5=Plane(p,c,ncdtop);\n  return Intersection(Intersection(Intersection(Intersection(splane1,splane2),splane3),splane4),splane5);\n}\n\n\nV SandPyramid(vec3 p,vec3 a,vec3 c,vec3 normal,float height,float turbScale){\n V pyr=Pyramid(p,a,c,normal,height);\n     float turbValue = Turbulence(p,height) * turbScale;\n    return V(pyr.v + turbValue, Sand(p,height/1000.));\n}\n\nV StripesPlane(vec3 p,vec3 c,vec3 n,float sizeStripe,float sizeSpace,float turbScale){\n    V plane=Plane(p,c,n);\n    float turbValue = Turbulence(p,sizeStripe+sizeSpace) * turbScale;\n    return V(plane.v + turbValue, Stripes(p.x,sizeStripe,sizeSpace,White().c,Black().c));\n}\n\nV GridPlane(vec3 p,vec3 c,vec3 n,float sizeStripe,float sizeSpace,float turbScale){\n    V plane=Plane(p,c,n);\n    float turbValue = Turbulence(p,sizeStripe+sizeSpace) * turbScale;\n    return V(plane.v + turbValue, Grid(p,sizeStripe,sizeSpace,White().c,Black().c));\n}\n\nV MarbrePlane(vec3 p,vec3 c,vec3 n,float totSize,float turbScale){\n    V plane=Plane(p,c,n);\n    float turbValue = Turbulence(p,totSize) * turbScale;\n    return V(plane.v + turbValue, Marbre(p,totSize*0.1,totSize*0.9));\n}\n\nV PlankPlane(vec3 p,vec3 c,vec3 n,float totSize,float turbScale){\n    V plane=Plane(p,c,n);\n    float turbValue = Turbulence(p,totSize) * turbScale;\n    return V(plane.v + turbValue, Ecorce(p,totSize));\n}\n\nV CirclePlane(vec3 p,vec3 c,vec3 n,float r,float w,float turbScale){\n    V plane=Plane(p,c,n);\n    float turbValue = Turbulence(p,r) * turbScale;\n    return V(plane.v + turbValue, Circle(p,c,r,w));\n}\n\nV CircleStripesPlane(vec3 p,vec3 c,vec3 n,float width1,float width2,float turbScale){\n    V plane=Plane(p,c,n);\n    float turbValue = Turbulence(p,width1+width2) * turbScale;\n    return V(plane.v + turbValue, CircleStripes(p,c,width1,width2,PlankColor().c*0.5,PlankColor().c));\n}\n\nV CirclePlankPlane(vec3 p,vec3 c,vec3 n,float size,float turbScale){\n    V plane=Plane(p,c,n);\n    float turbValue = Turbulence(p,size) * turbScale;\n    return V(plane.v + turbValue, CircularPlank(p,c,size));\n}\n\n\n\n\n\n\n\n\n\n\n\n// Dice \n// p : point\n// c : center \n// r : radius\nV Dice(vec3 p,vec3 c,float r)\n{\n  return Intersection(Cube(p,c,r*0.75),Sphere(p,c,r));\n}\n\nV DamierDice(vec3 p,vec3 c,float r,int nb,float turbScale)\n{\n  return Intersection(DamierCube(p,c,r*0.75,nb,turbScale),DamierSphere(p,c,r,nb,turbScale));\n}\n\n// Potential field of the object\n// p : point\nV object(vec3 p)\n{\n    V trunk=LogCylinder(p,vec3(-5,-5,-2),vec3(-5,-5,2),2.,0.4);\n    V marbre= MarbreCube(p,vec3(-1,-5,0),2.,4,0.);\n    V damier= DamierCube(p,vec3(3.5,0,0),2.,5,0.);\n    V stripes= StripesCube(p,vec3(8,0,0),2.,5,0.7,0.); \n    V grid=GridPlane(p,vec3(0,0,-5),vec3(0,0,1),0.5,2.,0.);\n    V pyr= SandPyramid(p,vec3(-2,5,0),vec3(-5,0,0),getNormal(vec3(5,5,0)),5.,0.2);\n    V u =Union(Union(Union(Union(Union(marbre,trunk),damier),stripes),pyr),grid);\n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.65,0.75,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Direct lighting\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Phong shading\n  float diff = clamp(dot(n, l),0.0,1.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\nif (!h)\n    {\n     return diff;\n    }\n    return 0.0; \n}\n\n\n\n\n// Compute texture \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= object(p);\n    return vp.color;\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    T tex=Color(p,n);\n\n    // Ambient color\n    vec3 ambient = tex.a*tex.c;\n        \n    // Shadow computation\n    float s = Shadow(p+0.01*n,n,l);\n\n// Phong diffuse\n    vec3 diffuse = tex.d * clamp(dot(n, l),0.0,1.0) * tex.c;\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = tex.s * pow(clamp(dot(r,l),0.0,1.0),28.0) * vec3(1.0,1.0,1.0);\n   \n    vec3 c = ambient + s*( diffuse + specular);\n    return c;\n}\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}