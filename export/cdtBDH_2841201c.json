{"ver":"0.1","info":{"id":"cdtBDH","date":"1697478583","viewed":60,"name":"Space 3D","username":"WhiteTophat","description":"\"You are the farthest ever in space. Why me, space? Because you are the best. I'm the best at space? Yes.\"\n           - A Space Enthusiast","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NearClipPlane 0.3\n#define FarClipPlane 120.0\nfloat FogDist = 400.0;\nvec4 FogCol = vec4(vec3(0.0), 1.0);\nfloat renderScene( out vec4 fragColor, in vec2 fragCoord, float Zoom) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv *= 1.0 / Zoom;\n    vec3 cam = normalize(vec3(1, uv));\n    vec3 init = vec3(-3, 0, 0);\n    \n    vec2 mouse = (iMouse.xy - (iResolution.xy / 2.0)) / 90.0;\n    \n    float zrot = mouse.x;\n    float yrot = -mouse.y;\n    cam = erot(cam, vec3(0, 1, 0), yrot);\n    init = erot(init, vec3(0, 1, 0), yrot);\n    cam = erot(cam, vec3(0, 0, 1), zrot);\n    init = erot(init, vec3(0, 0, 1), zrot);\n    \n    cam.z += 0.0;\n    \n    vec3 p = init;\n    bool hit = false;\n    float fog = 0.0;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist;\n        scene(p, dist);\n        hit = dist * dist < 1e-6;\n        p += cam * dist;\n        if (hit) fog = (distance(cam, p) / FogDist) * 1.0;\n        if (distance(p, init) > FarClipPlane || distance(p, init) < NearClipPlane) break;\n    }\n    \n    vec3 n = norm(p);\n    vec3 skyUV = cam;\n    /*\n    if (skyUV.x < 0.0) skyUV.x = 1.0 - abs(skyUV.x);\n    if (skyUV.y < 0.0) skyUV.y = 1.0 - abs(skyUV.y);\n    if (skyUV.z < 0.0) skyUV.z = 1.0 - abs(skyUV.z);\n    if (abs(cam.x) < 0.1 || abs(cam.y) < 0.1 || abs(cam.z) < 0.1) {\n        skyUV.x = mix(skyUV.x, abs(cam.x), 0.5);\n        skyUV.y = mix(skyUV.y, abs(cam.y), 0.5);\n        skyUV.z = mix(skyUV.z, abs(cam.z), 0.5);\n    }\n    */\n    vec3 camUV = abs(cam);\n    vec3 camCross = cross(cam, vec3(0, 1, 0));\n    vec4 sky1 = texture(iChannel2, skyUV.xz);\n    vec4 sky2 = texture(iChannel2, skyUV.yz);\n    vec4 sky3 = texture(iChannel2, skyUV.xz);\n    vec4 sky = sky2 * camUV.x + sky1 * camUV.y + sky3 * camUV.z;\n    sky = pow(sky, vec4(1.8));\n    \n    float fres = fresnel(cam, p, 0.5, 50.0);\n    vec4 fresCol = vec4(1.0);\n    \n    vec4 tex = grayscale(pow(texture3D(p, iChannel0, iChannel1), vec4(1.34)));\n    tex = lerp(tex, fresCol, fres);\n    fragColor = hit ? lerp(tex, FogCol, fog) : sky;\n    //if (uv.x > 0.0) fragColor = hit ? vec4(uv3D(p), 0.0, 1.0) : vec4(camUV, 1.0);\n    return zrot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    renderScene(fragColor, fragCoord, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ToonPosterize 12.0\nconst vec2 size = vec2(2.0,0.0);\nconst ivec3 off = ivec3(-1,0,1);\n\nvec3 moonCenter = vec3(0.0, 0.0, 0.0);\nvec3 sunCenter = vec3(-100.0, 0.0, 0.0);\nvec3 GetLightDir(vec3 p) {\n    return -normalize(p - sunCenter);\n}\nvec3 heightmapToNormal(sampler2D sampler, vec2 uv) {\n    vec4 wave = texture(sampler, uv);\n    float s11 = wave.x;\n    float s01 = textureOffset(sampler, uv, off.xy).x;\n    float s21 = textureOffset(sampler, uv, off.zy).x;\n    float s10 = textureOffset(sampler, uv, off.yx).x;\n    float s12 = textureOffset(sampler, uv, off.yz).x;\n    vec3 va = normalize(vec3(size.xy,s21-s01));\n    vec3 vb = normalize(vec3(size.yx,s12-s10));\n    vec4 bump = vec4( cross(va,vb), s11 );\n    return bump.xyz;\n}\n\n// Quaternions\nmat3 VectorToMatrix(vec3 D, vec3 U) {\n    vec3 S = cross(D, U);\n    vec3 Un = cross(D, S);\n    return mat3(D.x,D.y,D.z, Un.x,Un.y,Un.z, S.x,S.y,S.z);\n}\nvec4 MatrixToQuaternion(mat4 M) {\n    float tr = M[0].x + M[1].y + M[2].z;\n    vec4 q = vec4(0.0);\n    if (tr > 0.0) {\n    \n        float S = sqrt(tr + 1.0) * 2.0; // S = 4 * qw\n        q.w = 0.25 * S;\n        q.x = (M[2].y - M[1].z) / S;\n        q.y = (M[0].z - M[2].x) / S;\n        q.z = (M[1].x - M[0].y) / S;\n        \n    } else if ((M[0].x > M[1].y) && (M[0].x > M[2].z)) {\n        \n        float S = sqrt(1.0 + M[0].x + M[1].y + M[2].z) * 2.0; // S = 4 * qx;\n        q.w = (M[2].y - M[1].z) / S;\n        q.x = 0.25 * S;\n        q.y = (M[0].y + M[1].x) / S;\n        q.z = (M[0].z + M[2].x) / S;\n        \n    } else if (M[1].y > M[2].z) {\n    \n        float S = sqrt(1.0 + M[1].y - M[0].x - M[2].z) * 2.0; // S = 4 * qy;\n        q.w = (M[0].z - M[2].x) / S;\n        q.x = (M[0].y + M[1].x) / S;\n        q.y = 0.25 * S;\n        q.z = (M[1].z + M[2].y) / S;\n        \n    } else {\n        \n        float S = sqrt(1.0 + M[2].z - M[0].x - M[1].y) * 2.0; // S = 4 * qz;\n        q.w = (M[1].x - M[0].y) / S;\n        q.x = (M[0].z + M[2].x) / S;\n        q.y = (M[1].z + M[2].y) / S;\n        q.z = 0.25 * S;\n        \n    }\n    return q;\n}\n\n// Dissolve Shader Tophat\n/* playlist: https://www.shadertoy.com/playlist/sXfSDS */\n\n/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample2DHashUI32(uint x, uint y) {\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * enthropy2 + x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\nfloat valuetNoise2D(float u, float v) {\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n    \n    // Smoothstep.\n    float tU = fractU * fractU * (3.0 - 2.0 * fractU);\n    float tV = fractV * fractV * (3.0 - 2.0 * fractV);\n    \n    // Pseudorandom samples.\n    float sample0 = sample2DHashUI32(uint(u),       uint(v));\n    float sample1 = sample2DHashUI32(uint(u + 1.0), uint(v));\n    float sample2 = sample2DHashUI32(uint(u),       uint(v + 1.0));\n    float sample3 = sample2DHashUI32(uint(u + 1.0), uint(v + 1.0));\n\n    // Bilinear interpolation.\n    return \n        sample0 * (1.0 - tU) * (1.0 - tV) + \n        sample1 * tU         * (1.0 - tV) +\n        sample2 * (1.0 - tU) * tV +\n        sample3 * tU         * tV;\n}\nfloat gradientNoise(vec2 uv) {\n    float _u = uv.x * 6.0f;\n    float _v = uv.y * 6.0f;\n    \n    float gray = valuetNoise2D(_u, _v) * 0.25f;\n    gray += valuetNoise2D(_u * 2.054f, _v * 2.354f) * 0.125f;\n    gray += valuetNoise2D(_u * 4.554f, _v * 4.254f) * 0.125f;\n    gray += valuetNoise2D(_u * 8.554f, _v * 8.754f) * 0.0625f;\n    gray += valuetNoise2D(_u * 9.554f, _v * 9.154f) * 0.025f;\n    gray += valuetNoise2D(_u * 16.554f, _v * 16.854f) * 0.025f;\n    gray += valuetNoise2D(_u * 32.554f, _v * 32.354f) * 0.025f;\n    \n    return gray;\n}\nfloat gradientNoise(vec2 uv, vec2 offset) {\n    return gradientNoise(uv + offset);\n}\nfloat lerp(float a, float b, float t) {\n    return a + ((b - a) * t);\n}\nvec2 lerp (vec2 a, vec2 b, float t) {\n    return vec2(lerp(a.x, b.x, t), lerp(a.y, b.y, t));\n}\nvec3 lerp(vec3 a, vec3 b, float t) {\n    return vec3(lerp(a.xy, b.xy, t), lerp(a.z, b.z, t));\n}\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return vec4(lerp(a.xyz, b.xyz, t), lerp(a.w, b.w, t));\n}\nvec4 dissolve(vec4 a, vec4 b, vec2 uv, float time) {\n    float noise = gradientNoise(uv);\n    return lerp(a, b, step(noise, time));\n}\n\n// Quick Lighting Tech\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\nfloat lighting(vec3 normal, vec3 lightDir) {\n    float shade = dot(normalize(lightDir), normal);\n    return clamp(shade + 0.3, 0.0, 1.0);\n}\nfloat torus(vec3 p, float r1, float r2) {\n    return length(vec2(length(p.xz)-r1, p.y)) - r2;\n}\nfloat super(vec3 x) {\n    return sqrt(length(x*x));\n}\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return super(max(p, 0.0)) + min(0.0, max(max(p.x, p.y), p.z));\n}\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat smin(float a, float b, float k) {\n    float h = max (0.0, k - abs(b - a)) / k;\n    return min(a, b) - h * h * h * k / 6.0;\n}\nvoid scene(vec3 p, out float dist) {\n    vec3 p2 = abs(erot(p - vec3(0, 0, 0.4), vec3(1, 0, 0), radians(45.0)));\n    p2.yz = vec2(-smin(-p2.y, -p2.z, 0.1), smin(p2.y, p2.z, 0.1));\n    float moon = length(p - moonCenter) - 0.5;\n    dist = moon;\n}\n\nfloat scene(vec3 p) {\n    float dist;\n    scene(p, dist);\n    return dist;\n}\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\nvec2 uv3D(vec3 p) {\n    vec2 uv = vec2(0);\n    vec3 n = norm(p);\n    \n    vec2 uvXZ = p.xz * 0.5 + 0.5;\n    vec2 uvYZ = p.yz * 0.5 + 0.5;\n    vec2 uvXY = p.xy * 0.5 + 0.5;\n    \n    n = abs(n);\n    n *= pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n    \n    uv = uvYZ * n.x + uvXZ * n.y + uvXY * n.z;\n    return uv;\n}\nvec4 texture3D(vec3 p, sampler2D sampler, sampler2D heightmap, bool affectedByLight) {\n    vec3 col = vec3(0);\n    vec3 n = norm(p);\n    vec3 lightNorm;\n    float dif;\n    if (affectedByLight) {\n        lightNorm = mix(n, normalize(heightmapToNormal(heightmap, uv3D(p))), 0.5);\n        dif = lighting(lightNorm, GetLightDir(p));\n    }\n    \n    vec3 colXZ = texture(sampler, p.xz * 0.5 + 0.5).rgb;\n    vec3 colYZ = texture(sampler, p.yz * 0.5 + 0.5).rgb;\n    vec3 colXY = texture(sampler, p.xy * 0.5 + 0.5).rgb;\n    \n    n = abs(n);\n    n *= pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n    \n    col = colYZ * n.x + colXZ * n.y + colXY * n.z;\n    if (affectedByLight) col *= clamp(dif, 0.1, 1.0);\n    \n    return vec4(col, 1.0);\n}\nvec4 texture3D(vec3 p, sampler2D sampler, sampler2D heightmap) {\n    return texture3D(p, sampler, heightmap, true);\n}\nvec4 texture3D(vec3 p, sampler2D sampler) {\n    return texture3D(p, sampler, sampler, true);\n}\nvec4 grayscale(vec4 color) {\n    float v = (color.r + color.g + color.b) / 2.5;\n    return vec4(v);\n}\n#define NUM_LAYERS 4.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare) {\n\tfloat d = length(uv);\n    float m = .05/d;\n    \n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*.3*flare;\n    \n    m *= smoothstep(1., .2, d);\n    return m;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv, float time) {\n\tvec3 col = vec3(0);\n\t\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    for(int y=-1;y<=1;y++) {\n    \tfor(int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x, y);\n            \n    \t\tfloat n = Hash21(id+offs); // random between 0 and 1\n            float size = fract(n*345.32);\n            \n    \t\tfloat star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.9, 1., size)*.6);\n            \n            vec3 color = sin(vec3(.2, .3, .9)*fract(n*2345.2)*123.2)*.5+.5;\n            color = color*vec3(1,.25,1.+size)+vec3(.2, .2, .1)*2.;\n            \n            star *= sin(time*3.+n*6.2831)*.5+1.;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\nvec4 FullStars(vec2 uv, float time) {\n    float t = time*.02;\n    uv *= Rot(t);\n    vec3 col = vec3(0);\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n    \tfloat depth = fract(i+t);\n        \n        float scale = mix(20., .5, depth);\n        float fade = depth*smoothstep(1., .9, depth);\n        col += StarLayer(uv*scale+i*453.2, time)*fade;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    return vec4(col,1.0);\n}\n\nfloat fresnel(vec3 cam, vec3 p, float r, float i) {\n    vec3 n = norm(p);\n    vec3 centre = p + (-n * r);\n    return (distance(cam, p) - distance(cam, p)) * i;\n}","name":"Common","description":"","type":"common"}]}