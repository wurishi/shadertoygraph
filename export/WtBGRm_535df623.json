{"ver":"0.1","info":{"id":"WtBGRm","date":"1558792558","viewed":104,"name":"Meta Cubes","username":"jblanper","description":"It uses 4 primitives (2 cubes and 2 spheres, one with some displacement).","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","bw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define EPSILON .001\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sphereSDF (vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sceneSDF (vec3 p) {\n  p.xz *= rotate(iTime * .2);\n  p.yz *= rotate(iTime * .2);\n\n  float s = sphereSDF(p - vec3(0.), 1.);\n  s += sin(cos(iTime) + 5.*p.x) * sin(5.*p.y) * sin(5.*p.z) * .25;\n\n  float c = boxSDF(p - vec3(0.), vec3(.8));\n\n  p.xz *= rotate(iTime * .6);\n  p.yz *= rotate(iTime * .5);\n\n  float s2 = sphereSDF(p - vec3(0.), .3);\n  float c2 = boxSDF(p - vec3(0.), vec3(.25));\n  float d = max(c2, -s2);\n\n  return min(max(c, -s * .4), d);\n}\n\nvec3 getNormal (vec3 p) {\n  float d = sceneSDF(p);\n  vec2 e = vec2(.001, 0.);\n\n  return normalize(d - vec3(\n    sceneSDF(p - e.xyy),\n    sceneSDF(p - e.yxy),\n    sceneSDF(p - e.yyx)));\n}\n\nfloat raymarch (vec3 ro, vec3 rd) {\n  float depth = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float dist = sceneSDF(ro + rd * depth);\n    if (dist < EPSILON) return depth;\n    if (depth >= MAX_DIST) break;\n    depth += dist;\n  }\n  return 0.;\n}\n\nfloat getLight (vec3 lightPos, vec3 p, float britghness) {\n  vec3 light = normalize(lightPos - p) * britghness;\n  vec3 normal = getNormal(p);\n\n  float diff = clamp(dot(normal, light), 0., 1.);\n\n  return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n\n  vec3 ro = vec3(0., 0., -5.);\n  ro.z *= sin(iTime * .2) * .5 + .8;\n  vec3 rd = normalize(vec3(uv, 2.));\n\n  vec3 color = vec3(0.);\n  float d = raymarch(ro, rd);\n  vec3 p = ro + rd * d;\n\n  if (d > 0.) {\n    vec3 light2 = vec3(2., 0., 2.);\n    light2.xz *= rotate(iTime);\n    vec3 light1 = vec3(0., 0., 0.);\n    color += getLight(light1, p, .8);\n    color += getLight(light2, p, 1.);\n  } \n\n  fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}