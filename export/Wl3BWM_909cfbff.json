{"ver":"0.1","info":{"id":"Wl3BWM","date":"1612903085","viewed":360,"name":"Minecraft rendering","username":"kosmaks","description":"Petproject. Attempt to implement rendering of terrain minecraft style","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_STEP (0.001)\n#define MAX_STEP (5.)\n#define MAX_COUNT (200)\n\n#define MAX_HEIGHT (1.)\n#define QF (30.)\n#define QC (1. / QF)\n#define HQC (QC * 0.5)\n#define QUANTIZE(x) (floor((x) * QF) / QF)\n\n#define C_SKY (vec3(0.69, 0.78, 0.81))\n#define C_GRASS (vec3(0.8, 0.9, 0.4))\n#define C_DIRT (vec3(0.48, 0.32, 0.2))\n\nfloat noise(in vec2 uv) {\n    //return texture(iChannel0, uv * 0.9).x;\n    return (cos(uv.x * 10.) + sin(uv.y)) * 0.5 + 0.5;\n    return fract(sin(uv.x * 1233.52 + uv.y * 99.23423) * 324.234);\n}\n\nfloat blocksOld(in vec2 uv) {\n    return (cos(uv.x * 2.) + sin(uv.y)) * 0.5 + 0.5;\n    vec2 uvs = floor(uv);\n    vec2 d = fract(uv);\n    vec2 s = vec2(1., 0.);\n    float tl = noise(uvs);\n    float tr = noise(uvs + s.xy);\n    float bl = noise(uvs + s.yx);\n    float br = noise(uvs + s.xx);\n    float top = mix(tl, tr, d.x);\n    float bottom = mix(bl, br, d.x);\n    float mx = mix(top, bottom, d.y);\n    return max(0., mx);\n}\n\n//#define DEBUG_TERR\nfloat blocks(in vec2 uv) {\n    vec2 bump1Pos = vec2(-0.5, 0.4);\n    float bump1Size = 0.8;\n    \n    vec2 bump2Pos = vec2(0.2, 0.45);\n    float bump2Size = 1.4;\n    \n    vec2 bump3Pos = vec2(0.5, -0.5);\n    float bump3Size = 0.7;\n    \n    float height = 0.;\n    height = bump1Size * max(0., 1. - distance(uv, bump1Pos));\n    height = max(height, bump2Size * max(0., 1. - distance(uv, bump2Pos)));\n    height *= cos(uv.y * 5. - 1.8 + uv.x * 2.) * 0.2 + 0.2 ;\n    \n    height += \n        pow(bump3Size * max(0., 1. - distance(uv, bump3Pos)), 2.)\n        + pow(min(1., distance(uv, bump3Pos)), 4.) * 0.1 - 0.1;\n        \n    height -= HQC;\n    \n    return height;\n}\n\nfloat sdBox(in vec3 p, vec3 size) {\n    return length(max(abs(p) - size, 0.)); \n}\n\nfloat sdSphere(in vec2 p) {\n    return length(p) - HQC;\n}\n\nvec3 boxLocalTerr(in vec2 p) {\n    float h = QUANTIZE(blocks(p));\n    vec3 res = p.xyy + HQC;\n    res.y = h - HQC;\n    return res;\n}\n\nfloat getSurfaceDist(vec3 p) {\n#ifdef DEBUG_TERR\n    return p.y;\n#endif\n\n    vec2 coord = p.xz;\n    vec2 qcoord = QUANTIZE(coord);\n    vec2 center = qcoord + HQC;\n    \n    float h = QUANTIZE(blocks(qcoord));\n    float dist = (p.y - h) * 0.5;\n    \n    vec3 size = vec3(HQC);\n    \n    vec2 dir = sign(coord - center) * QC;\n    vec3 next = boxLocalTerr(qcoord + vec2(0., dir.y));\n    dist = min(dist, sdBox(p - next, size));\n    next = boxLocalTerr(qcoord + vec2(dir.x, 0.));\n    dist = min(dist, sdBox(p - next, size));\n    next = boxLocalTerr(qcoord + dir);\n    dist = min(dist, sdBox(p - next, size));\n    \n    \n    return dist;\n}\n\nvec2 getTree(vec3 pOrig) {\n    vec3 p = pOrig - vec3(0., HQC * 10., 0.);\n    \n    float dist = MAX_STEP;\n    \n    vec3 size = vec3(HQC * 2., HQC * 10., HQC * 2.);\n    \n    dist = sdBox(p, size);\n    \n    float leafs = sdBox(p - vec3(0., 0., 0. ), vec3(HQC) * vec3(6., 2., 6.));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 2., 0. ), vec3(HQC) * vec3(8., 2., 8.)));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 4., 0. ), vec3(HQC) * vec3(6., 2., 6.)));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 6., 0. ), vec3(HQC) * vec3(4., 2., 4.)));\n\n    if (leafs < dist) {\n        return vec2(leafs, 5.);\n    }\n\n    return vec2(dist, 4.);\n}\n\nvec2 getDist(vec3 p) {\n    float surface = getSurfaceDist(p);\n    float water = p.y - abs((\n        sin(p.z * 20. + iTime * 4.) * 0.55 +\n        cos(p.z * 123.3 + p.x * 10.442 + iTime * 10.) * 0.10 +\n        cos(p.x * 10.) * 0.35\n    ) * 0.003) + 0.003;\n    \n    if (water < -0.001) { water = MAX_STEP; }\n\n    \n    float box = sdBox(p - vec3(0., 0.4, 0.), vec3(2.));\n    if (box > surface) {\n        return vec2(box, 2.);\n    }\n    \n    if (water < surface) {\n        return vec2(water, 3.);\n    }\n    \n    vec2 tree = getTree(p + vec3(20., 0., 10.) * QC);\n    if (tree.x < surface) {\n        return tree;\n    }\n    \n    return vec2(surface, 1.);\n}\n\nvec3 getNormal(vec3 p) {\n    float dist = getDist(p).x;\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = dist - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec2 rayCast(vec3 ro, vec3 rd) {\n    float total = 0.;\n    \n    for (int i = 0; i < MAX_COUNT; ++i) {\n        vec2 hit = getDist(ro + rd * total);\n        float d = hit.x;\n        total += d;\n        if ((d) < MIN_STEP) return vec2(total, hit.y);\n        if (total > MAX_STEP) return vec2(total, -1.);\n    }\n    \n    return vec2(MAX_STEP + 1., -1.);\n}\n\nvec3 castToColor(vec3 ro, vec3 rd, out vec2 hit, out vec3 touch, out vec3 n) {\n    hit = rayCast(ro, rd);\n    float d = hit.x;\n    vec3 sunPos = vec3(-5., 5., -5.);\n    vec3 sunPower = vec3(1.) * 100.;\n    vec3 col;\n    \n    if (d < MAX_STEP) {\n        col = vec3(0.8, 0.9, 0.4);\n        touch = ro + rd * d;\n        n = getNormal(touch);\n        \n        if (int(hit.y) == 4) {\n            col = C_DIRT;\n        } else if (int(hit.y) == 5) {\n            col = C_GRASS;\n        } else if (int(hit.y) == 3) {\n            col = vec3(0.1, 0.3, 0.5);\n        } else {\n            col = C_DIRT;\n            \n            float qy = QUANTIZE(touch.y - QC * 0.1);\n            if (touch.y - qy > QC * 0.9) {\n                col = C_GRASS;\n            }\n        }\n        \n        vec3 toSun = sunPos - touch;\n        float distToSun = length(toSun);\n        vec3 toSunNorm = normalize(toSun);\n        float toSunDist = 1. / (distToSun*distToSun);        \n        float shadow = rayCast(touch + toSunNorm * 0.01, toSunNorm).y > 0. ? 0.5 : 1.;\n        \n        col *= sunPower * toSunDist * dot(toSunNorm, n);\n        col = max(vec3(0.2), col);\n        col *= shadow;\n#ifdef DEBUG_TERR\n        col = vec3(QUANTIZE(blocks(QUANTIZE(touch.xz))));\n#endif\n        return col;\n    }\n    \n    return vec3(0.7, 0.8, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vpShift = vec2(iResolution.x/iResolution.y, 1.);\n    vec2 vp = fragCoord/iResolution.y*2. - vpShift;\n    \n    float time = iTime * 0.3;\n    vec3 origin = vec3(sin(time) * 2., 0.5, -2. * cos(time));\n    vec3 target = vec3(0., 0., 0.);\n    vec3 up = vec3(0., 1., 0.);\n     \n    vec3 camPos = origin;\n    vec3 camTarget = target;\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(up, camForward));\n    vec3 camUp = cross(camForward, camRight);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(3.3 * camForward + camRight * vp.x + camUp * vp.y);\n\n    vec2 hit;\n    vec3 normal;\n    vec3 touch;\n    vec3 col = castToColor(ro, rd, hit, touch, normal);\n    \n    if (int(hit.y) == 3) {\n        vec2 h;\n        vec3 t, n;\n        vec3 refl = reflect(rd, normal);\n        vec3 rro = touch + refl * 0.01;\n        vec3 reflCol = castToColor(rro, refl, h, t, n);\n        if (hit.x < MAX_STEP) {\n            col += reflCol * 0.3;\n            col = smoothstep(0., 1., col);\n        }\n        \n        vec3 refr = refract(rd, normal, 0.6);\n        vec3 refrRo = touch + rd * 0.01;\n        vec3 refrCol = castToColor(refrRo, refr, h, t, n);\n        if (hit.x < MAX_STEP) {\n            col += refrCol * 0.2;\n            col = smoothstep(0., 1.2, col);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}