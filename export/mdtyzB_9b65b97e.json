{"ver":"0.1","info":{"id":"mdtyzB","date":"1695217257","viewed":132,"name":"egg box","username":"Efim","description":"https://mathcurve.com/surfaces.gb/boiteaoeufs/boiteaoeufs.shtml","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","surface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU 6.28318530718\n#define nn 70.0\nconst float  eps = 0.05;\n\nmat3 rotateX(float f)\n{\n    return mat3(vec3(1.0,    0.0,      0.0), vec3(0.0,\t cos(f),  -sin(f)), \tvec3(.0, sin(f), cos(f)));\n}\n\nmat3 rotateY(float f)\n{\n    return mat3(vec3(cos(f), 0.0,  sin(f)),vec3(0.0,\t 1.0,  0.0),vec3(-sin(f), 0.0, cos(f)));\n}\n\nmat3 rotateZ(float f)\n{\n    return mat3(vec3(cos(f),    -sin(f),  0.0),vec3(sin(f),\t cos(f),  0.0), \tvec3(0.0, 0.0, 1.0));\n}\n\nvec3 plane(vec3 ro, vec3 rd, vec3 po, vec3 nor)\n{\n    float t = dot(nor, (po - ro)) / dot(nor, rd);\n    return ro + rd*t;\n}\n\n\nfloat sdf(vec3 p)\n{\n    return abs(p.z - sin(p.x) - sin(p.y));\n    //return sdfBezier(p);\n}\n\nvec3 grid(vec3 ro, vec3 rd, float w, float h)\n{\n    vec3 col = vec3(0.0);\n    //x axis\n    vec3 nor = vec3(1.0, 0., 0.);\n    for (float i = 0.; i < nn; i++)\n    {\n        vec3 po = vec3(-w + 2.0*w*i/nn, 0.0, 0.0);\n        vec3 p = plane(ro, rd, po, nor);\n        if (abs(p.y) > h)\n            continue;\n        float pst = smoothstep(eps, 0.0, sdf(p));\n        col = mix(col, vec3(1.0), pst);\n    }\n\n    //y axis\n    nor = vec3(0.0, 1., 0.);\n    for (float i = 0.; i < nn; i++)\n    {\n        vec3 po = vec3(0.0, -h+ 2.0*h*i/nn, 0.0);\n        vec3 p = plane(ro, rd, po, nor);\n        if (abs(p.x) > w)\n            continue;\n        float pst = smoothstep(eps, 0.0, sdf(p));\n        col = mix(col, vec3(1.0), pst);\n    }\n    return col;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float t = iTime/4.0;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n        m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n        //t = 0.;\n    }\n    vec3 ro = vec3(0.0, -10.0, 4.); // camera\n    const float fl = 1.5; // focal length\n    ro = rotateY(-m.x*TAU)*rotateX(-m.y*PI)*ro; //camera rotation\n    vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n    mat3 rota  = rotateZ(t + PI/4.0);\n    float w = 6.;\n    float h = 6.;\n    vec3 col = grid(rota*ro, rota*rd, w, h);\n    fragColor = vec4(col, 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}