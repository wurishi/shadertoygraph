{"ver":"0.1","info":{"id":"4fsBzB","date":"1723944057","viewed":124,"name":"Noise, octaves, fBM & heightmaps","username":"Elsio","description":"estudando procedural surfaces. Tem muita coisa interessante escondida nessas formas de produzir superfícies.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","waves","sea","water","subsurface"],"hasliked":0,"parentid":"Ms2SD1","parentname":"Seascape"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define time (iTime * .3 - iMouse.y * .01)\n//#define AA\n\n\n// --------- noise is fun! ---------\nfloat hash(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p),\n         f = fract(p),\n         c = vec2(1, 0);\n    \n    f *= f * (3. - 2. * f);\n    return mix(\n               mix(\n                   hash(i + c.yy), \n                   hash(i + c.xy), \n                   f.x\n               ), \n               mix(\n                   hash(i + c.yx), \n                   hash(i + c.xx), \n                   f.x\n               ), \n               f.y\n           );\n}\n\n\nfloat gHeight, iter;\n\nfloat octave(\n        vec2 u, float speed, float freq, \n        float choppy, float size, float sgn\n      ){\n      \n    vec2 v = (u + speed + sgn) * freq;\n    v += noise(v) * 4. - 2.;\n    v = cos(v * 2.) * .5 + .5;\n    return size * pow(1. - sqrt(v.x * v.y), choppy);\n}\n\n\nfloat map(vec3 p) {\n    float freq  = .16,\n          amp   = gHeight,\n          speed = .4 * iTime,\n          choppy = 4.,\n          i, d, h;\n    \n    vec2 v, u = p.xz * .75;\n    \n    // fBM?\n    while(i++ < iter) {\n        d = octave(u, .5 * speed, freq, choppy, 2., 1.);\n        d += octave(u, 18. * speed, freq, choppy, 1., -1.);\n        \n        h += d * amp;\n        \n        freq   *= 1.9;\n        amp    *= .22;\n        choppy *= .8;\n        choppy += .2;\n        u *= mat2(1.6, 1.2, -1.2, 1.6);\n    }\n    return p.y - h;\n}\n\n\n\n\n// bisseção adaptativa \n// (um binary search mais inteligente)\nvec3 binaryMarch(vec3 ro, vec3 D) {\n    iter = 3.;\n    float i, steps = 8.,\n          d, s, d1, d2 = 1000.,\n          s1 = map(ro + d1 * D),\n          s2 = map(ro + d2 * D);\n    \n    if(s2 > .0) \n        return ro + d2 * D;\n    \n    vec3 p;\n    while(i++ < steps) {\n        d = mix(\n                d1, \n                d2, \n                s1 / (s1 - s2)\n            );\n        \n        p = ro + d * D;\n        s = map(p);\n        \n        if(s < .0) d2 = d, s2 = s;\n        else d1 = d, s1 = s;\n    }\n    \n    return p;\n}\n\nvec3 getNormal(vec3 p, float eps, float i) {\n    vec2 e = vec2(eps, 0); iter = i; \n    return normalize(vec3(map(p + e.xyy), map(p + e.yxy), map(p + e.yyx)) - map(p));\n}\n\n\nvec3 rot3D(vec3 D) {\n    D.yz *= rot(sin(time * 2.) * .2 + .7);\n    D.xy *= rot(sin(time * 3.) * .2);\n    D.zx *= rot(sin(time * .2 + iMouse.x * .01) * 2.);\n    return D;\n}\n\nvec4 getSkyColor(vec3 D) {\n    D.y = max(D.y, .0) * .64 + .16;\n    return vec4(\n               -D.y * .8 + .8, \n               -D.y * .4 + .4, \n               -D.y * .1 + .1, \n               0\n           );\n}\n\nvec4 getSeaColor(vec3 p, vec3 N, vec3 D, vec3 dist) {\n    vec3 base = vec3(.1, .05, .06),\n         col  = vec3(8, 9, 6) *  .1,\n         ld   = normalize(vec3(0, 1, .8)),\n         diff = pow(dot(N, ld) * .4 + .6, 80.) * col,\n         refr = base + diff * .12, // refr??\n         refl = getSkyColor(reflect(D, N)).xyz;\n         \n    float spec  = pow(max(dot(reflect(D, N), ld), .0), 60.) * .7,\n          fre   = min(pow(1. - max(dot(N, -D), 0.), 5.), .25),\n          atten = max(1. - dot(dist, dist) * .001, .0);\n    \n    return (\n             mix(refr, refl, fre)\n             +  vec3(8, 9, 10) * (p.y - gHeight) * .02 * atten\n             +  spec\n           ).xyzz;\n}\n\nvec4 render(vec2 u) {\n    vec2 r = iResolution.xy;\n         u = (u + u - r) / r.y;\n    \n    vec3 ro = vec3(0, 5., -time * 10.),\n         D = normalize(vec3(u, -2));\n    \n    D.z += length(u) * .04;\n    D = rot3D(normalize(D));\n    \n    vec3 p = binaryMarch(ro, D),\n         d = p - ro,\n         N = getNormal(p, .1 * dot(d, d) / r.y, 5.);\n    \n    return mix(\n               getSkyColor(D), \n               getSeaColor(p, N, D, d),\n               pow(smoothstep(.0, -5. / r.y, D.y), .4)\n            );\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    gHeight -= cos(iTime * .04);\n    o *= 0.;\n    #ifdef AA\n        vec2 v;\n        for(v.x = -1.; v.x < 2.; v.x++) \n            for(v.y = -1.; v.y < 2.; v.y++) \n                o += render(u + v / 3.);\n        o /= 9.;\n    \n    #else\n        o = render(u);\n        \n    #endif\n    \n    o = pow(o, vec4(.45));\n}","name":"Image","description":"","type":"image"}]}