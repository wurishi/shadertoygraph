{"ver":"0.1","info":{"id":"tdcXR7","date":"1571665311","viewed":68,"name":"Bones tracing","username":"levonchic","description":"Falling bones in distance tracing","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tracing","bones","distancetracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.14159265359\n#define PI0 6.28318530718\n#define PI2 1.57079632679\n#define PI4 0.78539816339\n\n// #define FAST\n#define ROTATION\n#define SCALE 6.0\n\n// SQRT\nfloat circle(vec2 v, vec2 center, float radius) {\n    return distance(v, center) - radius;\n}\n\nfloat circle_check(vec2 v, vec2 center, float radius, float a, float b, float far) {\n    vec2 dir = v - center;\n    float angle = PI + atan(dir.x, dir.y);\n    \n    if (a < 0.0) {\n        if (b < 0.0) {\n            if (angle < a + 2.0 * PI || angle > b + 2.0 * PI)\n                return far;\n        } else {\n            if (angle < a + 2.0 * PI && angle > b)\n                return far;\n        }\n    } else if (angle < a || angle > b)\n        return far;\n    \n    return length(dir) - radius;\n}\n\nfloat round_segment_check(vec2 v, vec2 A, vec2 B, float far) {\n    vec2 b = B - A;\n    vec2 a = v - A;\n    float frac = dot(a, b) / dot(b, b);\n    if (frac < 0.0)\n        return distance(v, A);\n    if (frac > 1.0)\n        return distance(v, B);\n    \n    vec2 n  = B - A;\n    vec2 va = A - v;\n    vec2 c  = n * dot(va, n) / dot(n, n);\n    return length(va - c);\n}\n\nvec4 color(float dist) {\n   vec4 c;\n    c.a = 1.0;\n    c.r = c.g = c.b = 1. / pow(2.0 + 0.2 * sin(mod(iTime, PI) * 4.0), dist * 60.);\n    c.r *= 0.962745098;\n    c.g *= 0.939215686;\n    c.b *= 0.903921569;\n    \n    return c;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {    \n    fragCoord.xy = SCALE * fragCoord.xy + vec2(iTime * 500., iTime * 1000.);\n    vec2 quarantOffset = round((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xy);\n    \n    fragCoord += cos(quarantOffset.yx * PI + mod(iTime, PI) * 4.) * iResolution.yx * 0.04;\n    fragCoord.xy = mod(fragCoord.xy, iResolution.xy);\n    \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Scale to fit light\n    uv *= 1.5;\n    uv.y -= 0.017;\n    \n    bool qX = (int(quarantOffset.x) & 1) == 0;\n    bool qY = (int(quarantOffset.y) & 1) == 0;\n    \n    // Invert coords\n    if (qX) \n        uv.y = -uv.y;\n    \n    if (qY) \n        uv.x = -uv.x;\n\n#ifdef ROTATION\n    // Rotation\n    float s = cos((qX && qY ? 1.0 : -1.0) * mod(iTime, PI) * 4.);\n    float c = sin((qX && qY ? 1.0 : -1.0) * mod(iTime, PI) * 4.);\n    mat2 m = mat2(c, -s, s, c);\n    uv = m * uv;\n#endif\n\n#ifdef FAST\n    float d0 = round_segment_check(uv, vec2(0.0, 0.1), vec2(0.1,  0.0), 10.0);\n    float d1 = round_segment_check(uv, vec2(-0.1, 0.0), vec2(0.0, -0.1), 10.0);\n\t\n    float d2 = abs(circle(uv, vec2(0.1 * sqrt(2.0) / 2.0 + 0.1, -0.1 * sqrt(2.0) / 2.0), 0.1)); \n    float d3 = abs(circle(uv, vec2(0.1 * sqrt(2.0) / 2.0, -0.1 * sqrt(2.0) / 2.0 - 0.1), 0.1));\n    \n    float d22 = abs(circle(uv, -vec2(0.1 * sqrt(2.0) / 2.0 + 0.1, -0.1 * sqrt(2.0) / 2.0), 0.1)); \n    float d32 = abs(circle(uv, -vec2(0.1 * sqrt(2.0) / 2.0, -0.1 * sqrt(2.0) / 2.0 - 0.1), 0.1));\n#else\n    float d0 = round_segment_check(uv, vec2(0.0, 0.1), vec2(0.1,  0.0), 10.0);\n    float d1 = round_segment_check(uv, vec2(-0.1, 0.0), vec2(0.0, -0.1), 10.0);\n    \n    float d2 = abs(circle_check(uv, vec2(0.1 * sqrt(2.0) / 2.0 + 0.1, -0.1 * sqrt(2.0) / 2.0), 0.1, -5.0 * PI4, 0.0, 10.0)); \n    float d3 = abs(circle_check(uv, vec2(0.1 * sqrt(2.0) / 2.0, -0.1 * sqrt(2.0) / 2.0 - 0.1), 0.1, -PI2, 3.0 * PI4, 10.0));\n    float d23 = abs(circle(uv, vec2(0.1 + 0.1 * sqrt(2.0) / 2.0, -0.1 - 0.1 * sqrt(2.0) / 2.0), 0.0));\n    \n    float d22 = abs(circle_check(uv, -vec2(0.1 * sqrt(2.0) / 2.0 + 0.1, -0.1 * sqrt(2.0) / 2.0), 0.1, -PI4, PI, 10.0)); \n    float d32 = abs(circle_check(uv, -vec2(0.1 * sqrt(2.0) / 2.0, -0.1 * sqrt(2.0) / 2.0 - 0.1), 0.1, PI2, 7.0 * PI4, 10.0));\n    float d232 = abs(circle(uv, -vec2(0.1 + 0.1 * sqrt(2.0) / 2.0, -0.1 - 0.1 * sqrt(2.0) / 2.0), 0.0));\n#endif\n    \n    //float d5 = segment_check(uv, vec2(-0.5, -0.28), vec2( 0.5, -0.28), 10.0);\n    //float d6 = segment_check(uv, vec2( 0.5, -0.28), vec2( 0.5,  0.28), 10.0);\n    //float d7 = segment_check(uv, vec2( 0.5,  0.28), vec2(-0.5,  0.28), 10.0);\n    //float d8 = segment_check(uv, vec2(-0.5,  0.28), vec2(-0.5, -0.28), 10.0);\n    \n    float mn = min(d0, d1);\n          mn = min(mn, d2);\n          mn = min(mn, d3);\n          mn = min(mn, d22);\n          mn = min(mn, d32);\n#ifndef FAST\n          mn = min(mn, d23);\n          mn = min(mn, d232);\n#endif\n\t\t  \n    //      mn = min(mn, d5);\n    //      mn = min(mn, d6);\n    //      mn = min(mn, d7);\n    //      mn = min(mn, d8);\n    \n    fragColor = color(mn);\n}","name":"Image","description":"","type":"image"}]}