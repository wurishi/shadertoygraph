{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//==RAY MARCHING CONSTANTS=========================================================\n#define EPSILON .001\n#define MAX_VIEW_STEPS 64\n#define MAX_SHADOW_STEPS 128\n#define OCCLUSION_SAMPLES 8.0\n#define OCCLUSION_FACTOR 1.667\n#define MAX_DEPTH 2.0\n#define BUMP_FACTOR .025\n#define TEX_SCALE_FACTOR 1.2\n#define BUMP_SCALE_FACTOR .8\n\n//==SCENE OBJECT CONSTANTS=========================================================\n#define CAM_POS vec3(0.0, 0.8, -0.4)\n#define CAM_DIR vec2(0.1, 1.0)\n#define CAM_BACK 0.5\n#define CAM_ZOOM 1.0\n\n#define ROOM_POS vec3 (0.0, 0.8, 0.0)\n#define ROOM_DIM vec3 (1.5, 0.8, 1.5)\n\n#define STAIR_POS vec3(1.5, 0.8, 0.0)\n#define STAIR_DIM vec3(.8, .01, .05)\n#define STAIR_REPEAT vec3(0.0, -.08, .125)\n\n#define PLANE_NORM vec3(0.0, 1.0, 0.0)\n#define PLANE_HEIGHT 0.0\n\n#define AMBIENT .01\n\n#define LIGHT_POS_A vec3(1.0, 0.05, -0.75)\n#define LIGHT_DIR_A vec3(0.5, 0.7, 0.86)\n#define LIGHT_COLOR_A vec4(1.0, 0.33, 0.0, 1.0)\n#define LIGHT_BRIGHT_A texture(iChannel2, vec2(iTime+.25)).g*1.5+.5\n#define LIGHT_SPREAD_A .15\n#define LIGHT_PENUMBRA_A 16.0\n\n#define LIGHT_POS_B vec3(1.0, 0.8, 1.4)\n#define LIGHT_DIR_B vec3(0.5, 0.0, -0.86)\n#define LIGHT_COLOR_B vec4(.25, .25, .94, 1.0)\n#define LIGHT_BRIGHT_B texture(iChannel2, vec2(iTime)).r*2.0+1.0\n#define LIGHT_SPREAD_B .15\n#define LIGHT_PENUMBRA_B 16.0\n\n#define WALL_BUMP iChannel2\n#define CEIL_BUMP iChannel1\n#define GROUND_BUMP iChannel1\n#define WALL_TEX iChannel0\n#define GROUND_TEX iChannel2\n#define CEIL_TEX iChannel2\n#define STAIR_TEX iChannel3\n\n//==RENDERING STRUCTURES===========================================================\n\n/*\n\tA structure for a spotlight.\n*/\nstruct SpotLight\n{\n\tvec3 position, direction;\n\tvec4 color;\n\tfloat brightness;\n\tfloat spread;\n\tfloat penumbraFactor;\n} under, onlooking;\n\n//==CAMERA FUNCTIONS================================================================\n/*\n\tTEKF https://www.shadertoy.com/view/XdsGDB !!!\n\tSet up a camera looking at the scene.\n\torigin - camera is positioned relative to, and looking at, this point\n\tdist - how far camera is from origin\n\trotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n\tzoom - the relative length of the lens\n*/\nvoid camPolar( out vec3 pos, out vec3 dir, in vec3 origin, in vec2 rotation, in float dist, in float zoom, vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = cos(rotation);\n\tvec4 s;\n\ts.xy = sin(rotation);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tdir.xy = fragCoord.xy - iResolution.xy*.5;\n\tdir.z = iResolution.y*zoom;\n\tdir = normalize(dir);\n\t\n\t// rotate ray\n\tdir.yz = dir.yz*c.x + dir.zy*s.zx;\n\tdir.xz = dir.xz*c.y + dir.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n//==TEXTURING FUNCTIONS=============================================================\n/*\n\tBy Reinder. Takes a 3D coordinate, and returns a texel based on which plane(s)\n\tit lies in.\n*/\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.zx )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n/*\n\tBy Reinder. Takes a 3D coordinate, and returns a texel based on which plane(s)\n\tit lies in.\n*/\nvec4 texRoom( in vec3 pos, in vec3 normal, \n\t\t\t sampler2D wall, sampler2D ground, sampler2D ceiling )\n{\n\tpos *= TEX_SCALE_FACTOR; \n\treturn \ttexture( wall, pos.yz )*abs(normal.x)+\n\t\t\t((normal.y < 0.0)?texture( ceiling, pos.zx ):texture( ground, pos.zx ))*abs(normal.y)+\n\t\t\ttexture( wall, pos.xy )*abs(normal.z);\n}\n\n//==DISTANCE FUNCTIONS==============================================================\n/*\n\tReturns the distance to the surface of a box with the given position and dimensions.\n\tThis also returns a signed distance. If the returned value is negative, you are within\n\tthe box.\n*/\nfloat distRoom(vec3 samplePos, vec3 boxPos, vec3 boxDim)\n{\n\tvec3 d = abs(samplePos-boxPos) - boxDim;\n\treturn -(min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.0)));\n}\n\n/*\n\tConstructs a distance field for the staircase by repeating a box and ceiling its y\n\tvalue based on its z location..\n*/\nfloat distStairs(vec3 samplePos, vec3 stairPos, vec3 stairDim)\n{\n\tsamplePos.z += STAIR_REPEAT.z*.5;\n\tsamplePos.y -= ceil(samplePos.z/STAIR_REPEAT.z)*STAIR_REPEAT.y;\n\tsamplePos.z = mod(samplePos.z, STAIR_REPEAT.z);\n\tsamplePos.z -= STAIR_REPEAT.z*.5;\n\t\n\treturn length(max(abs(stairPos-samplePos)-stairDim,0.0));\n}\n\n/*\n\tReturns the distance to the surface of a box, but a box that's been modified\n\tby a bump map.\n*/\nfloat distRoomBump(vec3 samplePos, vec3 boxPos, vec3 boxDim, \n\t\t\t\t   sampler2D wall, sampler2D ground, sampler2D ceiling)\n{\t\n\tvec3 normal;\n\tfloat bump = 0.0;\n\tif(length(samplePos-boxPos) < length(boxDim))\n\t{\n\t   \tnormal = normalize(samplePos-boxPos);\n \t\tbump = texRoom(samplePos*BUMP_SCALE_FACTOR, normal, wall, ground, ceiling).r*BUMP_FACTOR;\n\t}\n\tvec3 d = abs(samplePos-boxPos) - boxDim;\n\treturn -(min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.0))+bump);\n}\n\nfloat getDist(vec3 samplePos)\n{\n\treturn min(distRoomBump(samplePos, ROOM_POS, ROOM_DIM, WALL_BUMP, GROUND_BUMP, CEIL_BUMP),\n\t\t\t   distStairs(samplePos, STAIR_POS, STAIR_DIM));\n}\n\n//==RAY MARCHING FUNCTIONS=========================================================\n/*\n\t\tMarches the 3D point <pos> along the given direction.\n\tWhen the point is either stepped the maximum number of times,\n\thas passed the maximum distance, or is within a set distance\n\tfrom geometry the function returns. \n\t\tNote that the position is passed by reference and is modified\n\tfor use within the function.\n*/\nvoid marchThroughField(inout vec3 pos, vec3 dir)\n{\n\tfloat dist;\n\tfor(int i = 0; i < MAX_VIEW_STEPS; i++)\n\t{\n\t\tdist = getDist(pos);\n\t\tif(dist < EPSILON || dist > MAX_DEPTH)\n\t\t\treturn;\n\t\telse\t\n\t\t\tpos += dir*dist;\n\t}\n\treturn;\n}\n\n//==LIGHT CALCULATION FUNCTIONS=====================================================\n/*\n\tReturns the surface normal of a point in the distance function.\n*/\nvec3 getNormal(vec3 pos)\n{\n\tfloat d=getDist(pos);\n\treturn normalize(vec3( getDist(pos+vec3(EPSILON,0,0))-d, getDist(pos+vec3(0,EPSILON,0))-d, getDist(pos+vec3(0,0,EPSILON))-d ));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n*/\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = vec3(pos);\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);\n\t\tresult += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-getDist(normalPos);\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\n\n/*\n\tCalculates how much light remains if shadows are considered.\n*/\nfloat calcShadow( vec3 origin, vec3 lightDir, SpotLight light)\n{\n\tfloat dist;\n\tfloat result = 1.0;\n\tfloat lightDist = length(light.position-origin);\n\t\n\tvec3 pos = vec3(origin)+(lightDir*EPSILON*10.0);\n\t\n\tfor(int i = 0; i < MAX_SHADOW_STEPS; i++)\n\t{\n\t\tdist = getDist(pos);\n\t\tif(dist < EPSILON)\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\t\tif(length(pos-origin) > lightDist || length(pos-origin) > MAX_DEPTH)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\tpos+=lightDir*dist;\n\t\tif( length(pos-origin) < lightDist )\n\t\t{\n\t\t\tresult = min( result, light.penumbraFactor*dist / length(pos-origin) );\n\t\t}\n\t}\n\treturn result;\n}\n\n//IQ fog\nvec4 applyFog( in vec4  rgba,      // original color of the pixel\n               in float dist, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n\tfloat b = 3.0, c = .4;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -dist*rayDir.y*b ))/rayDir.y;\n    vec4  fogColor  = vec4(0.005, 0.005, 0.01, 1.0);\n    return mix( rgba, fogColor, fogAmount );\n}\n\n/*\n\tReturns the product of the Phong lighting equation on a point in space given\n\ta (SPOT) light and the surface's material.\n*/\nvec4 calcLighting(vec3 samplePos, vec3 eyeDir, vec3 normal, vec3 reflection, SpotLight light)\n{\n\t\n\tfloat lightDist = length(light.position-samplePos);\n\tvec3 lightDir = normalize(light.position-samplePos);\n\t\n\tfloat specular = 0.0, diffuse = 0.0, ambient = AMBIENT;\n\tfloat attenuation = 0.0, shadow = 0.0, occlusion = 0.0;\n\t\n\tfloat spotCos = dot(-lightDir, light.direction);\n\tfloat spotCoefficient = smoothstep( 1.0-light.spread, 1.0, spotCos );\n\t\n\t// If it's outside of the light's cone we don't need to calculate any terms.\n\tif(spotCos > 1.0-light.spread)\n\t{\n\t\tshadow = calcShadow(samplePos, lightDir, light);\n\t\tif(shadow >= EPSILON)\n\t\t{\n\t\t\tspecular = pow(max( 0.0, dot(lightDir, reflection)*spotCoefficient), 2000.0);\n\t\t\tdiffuse = max( 0.0, dot(lightDir, normal)*spotCoefficient);\n\t\t\tattenuation = min(1.0, (1.0/(lightDist/light.brightness)));\n\t\t}\n\t\t//else occlusion = calcOcclusion(samplePos, normal);\n\t}\n\tocclusion = calcOcclusion(samplePos, normal);\n\t\n\treturn light.color*clamp(((specular+diffuse)*shadow*attenuation), 0.0, 1.0)+(ambient*occlusion);\n}\n\nvec4 calcLights(vec3 samplePos, vec3 eye, vec3 normal, SpotLight a, SpotLight b, vec4 texel)\n{\n\tvec3 eyeDir = normalize(samplePos-eye);\n\tvec3 reflection = normalize(reflect(eyeDir, normal));\n\tvec4 lightingA = calcLighting(samplePos, eyeDir, normal, reflection, a);\n\tvec4 lightingB = calcLighting(samplePos, eyeDir, normal, reflection, b);\n\treturn min(vec4(1.0), (lightingA+lightingB))*texel;\n}\n\t\n\n/*\n\tDetermines the texture of the current surface position.\n*/\nvec4 getSurfaceTexel(vec3 pos, vec3 normal)\n{\n\tif(distRoom(pos, ROOM_POS, ROOM_DIM) <= distStairs(pos, STAIR_POS, STAIR_DIM))\n\t{\n\t\treturn texRoom(pos, normal, WALL_TEX, GROUND_TEX, CEIL_TEX);\n\t}\n\telse\n\t{\n\t\treturn tex3D(pos, normal, STAIR_TEX);\n\t}\n}\n\nvec4 shade(vec3 pos, vec3 dir, vec3 eye, SpotLight a, SpotLight b)\n{                                          \n\tvec3 normal = getNormal(pos);\n\tvec4 texel = getSurfaceTexel(pos, normal);\n\tvec4 color = calcLights(pos, eye, normal, a, b, texel);\n\treturn applyFog(color, length(pos-eye), eye, dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 pos, eye, dir;\n\tcamPolar(pos, dir, CAM_POS, CAM_DIR, CAM_BACK, CAM_ZOOM, fragCoord);\n\teye = vec3(pos);\n\t\n\tunder = SpotLight(LIGHT_POS_A, normalize(LIGHT_DIR_A), LIGHT_COLOR_A, \n\t\t\t\t\t  LIGHT_BRIGHT_A, LIGHT_SPREAD_A, LIGHT_PENUMBRA_A);\n\tonlooking = SpotLight(LIGHT_POS_B, normalize(LIGHT_DIR_B), LIGHT_COLOR_B, \n\t\t\t\t\t  LIGHT_BRIGHT_B, LIGHT_SPREAD_B, LIGHT_PENUMBRA_B);\n\t\n\t\n\tmarchThroughField(pos, dir);\n\tfragColor = shade(pos, dir, eye, under, onlooking);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sj3WG","date":"1398263098","viewed":363,"name":"Staircase","username":"Hamneggs","description":"I always liked how light shining through a staircase looked.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["ray","marching","shadows","bump","mapping","staircase","stairs","multiplelights"],"hasliked":0,"parentid":"","parentname":""}}