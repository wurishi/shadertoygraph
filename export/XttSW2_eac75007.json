{"ver":"0.1","info":{"id":"XttSW2","date":"1481663421","viewed":189,"name":"Bevel Edge Box (9 patch ver.)","username":"bolloxim","description":"Procedural box shader with 9 patch support so that it encompasses the entire rectangle but preserves the edge","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["9patchcurvedshadowboxborderedge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Andi Smithers \n// button shader for smooth border edges\n// includes shadow both internal and drop shadow\n// 9 patch is basically preserving the edge with rectangle and doesnt stretch the image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n    float borderSize = 0.05;\n    float antiAliasSize = 0.03;\n    vec4 borderColor = vec4(1.0,1.0,0.95, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float wobbly = iTime;\n\tfloat rounding = sin(wobbly)*3.0+4.0;\n    vec2 shadowVec = vec2(-0.01, 0.05);\n    float scaleBox = 1.2;\n\n    // alias thickness\n    float aascalar = 1.0 / antiAliasSize;\n    float outerAlias = 1.0 - antiAliasSize;\n    \n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // compute 9patch centre - xaxis\n    float centre = (iResolution.x - iResolution.y)/iResolution.x * 0.5 ;\n    if (abs(iuv.x-0.5)<centre) uv.x=0.5;\n    if(iuv.x>centre+0.5) uv.x-=0.5 + (iResolution.y/iResolution.x) * centre*2.0;\n\n    vec2 uvUnit = (uv*2.0-1.0) * scaleBox;\n    vec2 shadowUnit = uvUnit + shadowVec;\n    \n    // rounded edge - have to abs the value incase shader doesnt support negative powers\n    uvUnit = pow(abs(uvUnit), vec2(rounding));\n    shadowUnit = pow(abs(shadowUnit), vec2(rounding));\n    \n    // compute border\n    float borderEdge = pow(1.0-borderSize, rounding);\n    float borderAlias = borderEdge - antiAliasSize;\n    \n    // edge\n    float edge = length(uvUnit);\n    float outer = 1.0-(clamp(edge, outerAlias, 1.0)-outerAlias) * aascalar;\n    float inner = 1.0-(clamp(edge, borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowInner = 1.0-(clamp(length(shadowUnit), borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowOuter = 1.0-(clamp(length(shadowUnit), outerAlias, 1.0)-outerAlias) * aascalar;\n    \n    // blow out outer then chose minimum this ensures a mask around the alpha output\n    float outermask = min(outer*1000.0, 1.0);\n    \n    // fetch image and poor mans chromakey alpha\n    vec4 image = texture(iChannel0, iuv);\n    float alpha = length(image.rgb-vec3(0,1,0));\n    alpha = alpha> 0.5 ? 1.0 : 0.0;\n\n    // shadow\n    float shade = shadowInner<0.9 ? 0.8 + shadowInner*0.2: 1.0;\n    float shadeOut = shadowOuter>0.5 ? 0.0 + shadowOuter*0.2: 0.0;\n\t\n        \n    // blend inner/outer and image with image alpha\n    vec4 color = (centreColor*inner*(1.0-alpha)+image*alpha*inner)*shade + borderColor*(1.0-inner)*outermask;\n    color.a =  max(outer, shadeOut);\n    \n    // blend against a background texture - because shadertoy\n    vec4 background = texture(iChannel1, iuv);\n        \n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a);\n}","name":"Image","description":"","type":"image"}]}