{"ver":"0.1","info":{"id":"wlSczR","date":"1729826422","viewed":104,"name":"Mandelbub Fractal - Ray Marching","username":"faportero","description":"Deformed Mandelbub fractal with Ray Marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbubfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Referencia : http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n// Visions of Chaos : https://softology.com.au/gallery/gallery.htm\n\nconst float PI = 3.1415926;\nfloat cy = 0.1;\n\nfloat mandelbub(vec3 position)\n{\n            \n    vec3 z = position;\n    float dr = 1.;\n    float r = 0.0;\n    float power = 4.;\n    //float power = iTime*.4;\n    \n    //MATRIZ DE ROTACION\n    //float an = .0;\n    float an = iTime*PI;\n    mat2 rot = mat2(\n        cos(an), -sin(an),\n        sin(an), cos(an)\n    );\n    \n    vec3 q = position;\n    q.xz = rot*q.xz;\n\n    \n    for (int i = 0; i <6; ++i)\n    {\n    r = length(z);\n        if (r > 5.)\n        {\n        break;\n        }\n        \n        float cPower = iTime / 10.0;\n        float theta = acos(z.z /r) * power * cPower ;\n        float phi = atan(z.y, z.x) * power * cPower;\n        float zr = pow(r, power);\n        \n        dr = pow(r, power - 1.0) * power * dr +  1.0;\n        \n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin (theta), cos(theta));\n        z +=.5*q;       \n    }\n    \n    \n        \n    float d2 = length (vec2(q.y+1.5, length(q.xz) - 0.5)) - 0.2;\n    //return d2;\n\treturn  .5 * log(r) * r / dr;\n       \n}\n\n\n// Calculo del gradiente\nvec3 calcNormal(vec3 position)\n{\n    float rbgx, rgby, rgbz;\n\treturn normalize(vec3(\n    \tmandelbub(position + vec3(-0.001, 0.0, 0.0)) -mandelbub(position - vec3(-0.01, 0.0, 0.0)),\n        mandelbub(position + vec3(0.0, -0.0004, 0.0)) + mandelbub(position - vec3(0.0, -0.01, 0.0)),\n        mandelbub(position + vec3(0.0, 0.0, -0.0001)) - mandelbub(position - vec3(0.0, 0.0, -0.003))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screen_pos = ((2.0 * fragCoord.xy - iResolution.xy )/ iResolution.y )+ (0.0,0.0,0.0);\n    \n    //float cam_an = 2.*PI;\n    float cam_an = iTime*0.5;\n    float frec = .5;\n    vec3 cam_orig = vec3 (1.*sin(2.5)+cos(.2), 3.*(sin(.3)+cos(2.4)), -4.0);\n\t//vec3 cam_orig = vec3 (1., 1., .5*(sin(cam_an)+cos(-cam_an)));\n\t\n    //vec3 cam_orig = vec3 (.5*sin(frec*cam_an)+cos(frec*cam_an), .5*sin(cam_an)+cos(cam_an), -2.5*sin(cam_an));\n    \n    \n    float an = .4;\n    //float an = iTime*5.;\n    mat2 rot = mat2(\n        cos(an), sin(an),\n        -sin(an), cos(an)\n    );\n    \n\n\n    \n    \n    vec3 cam_target = vec3(-.5, 0.25, 0.0);    \n\n    vec3 q = cam_target;\n    q.xz = rot*q.xz;\n    \n    vec3 cam_forward = normalize(cam_target - cam_orig);\n    vec3 cam_right = normalize(cross(cam_forward, vec3 (0.0, 1.0, 0.0)));\n    vec3 cam_up = normalize(cross(cam_right, cam_forward));\n    \n    vec3 ro = cam_orig;\n    vec3 rd = normalize(vec3(\n    \tscreen_pos.x * cam_right + \n        screen_pos.y * cam_up + \n        5.0 * cam_forward        \n    ));\n    \n    vec3 col = vec3(0.0);\n    \n    float t = 0.0;\n    \n    for (int step_march = 0; step_march < 200; ++step_march)\n    {\n    \tvec3 p = ro + t * rd;\n        float h = mandelbub(p);\n        if (h < 0.0004)\n        {\n        \tcol = calcNormal(p);\n            //col = vec3(0.0,cy,0.0);\n            break;\n        }\n        \n        t +=h;   \n        \n    }\n    \n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}