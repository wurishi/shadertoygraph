{"ver":"0.1","info":{"id":"ssyfRd","date":"1659737404","viewed":167,"name":"Marching Lost Some Pixels","username":"uiop","description":"wanted to try something out with orthographic raymarching, also doing some post processing with data in a depthbuffer.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","pixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void rotx(inout vec3 p, float a){\np=vec3(p.x,p.y*cos(a)-p.z*sin(a),p.y*sin(a)+p.z*cos(a));\n}\nvoid roty(inout vec3 p, float a){\np=vec3(p.x*cos(a)-p.z*sin(a),p.y,p.x*sin(a)+p.z*cos(a));\n}\n\n\n// iq sdf\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nvoid checkDist(inout float d, float c, inout int obj, int obi){\n    if(c < d){\n        d = c;\n        obj = obi;\n    }\n}\nfloat sdScene(vec3 p, out int obj){\n    float dist = 10000.;\n    obj = -1;\n    checkDist(dist, sdBox(p+vec3(0,1.5,0), vec3(1.0,0.5,1.0)), obj, 1);\n    checkDist(dist, sdBox(p+vec3(0,0.5,0), vec3(0.5,0.5,0.5)), obj, 2);\n    checkDist(dist, sdSphere(p+vec3(0,-0.5,0), 0.5), obj, 3);\n    checkDist(dist, sdSphere(p+vec3(0,5.5,0), 3.5 + 1.0*sin(iTime*2.)), obj, 1);\n    checkDist(dist, sdTorus(p+vec3(0,0.5,0), vec2(1.5 + 1.0*sin(iTime*1.),0.4)), obj, 2);\n    checkDist(dist, sdCapsule(p,vec3(-1.5,0.5,0),vec3(1.5,0.5,0),0.25), obj, 3);\n        float c = 3.0 + 0.5 * sin(iTime);\n\n    vec3 boxloc = vec3(0.0,1.5*sin(iTime*0.5)+1.0,0.0);\n    float innerbox = sdBox(p + boxloc, vec3(9.5,1.5,9.5));\n    float mins = max(innerbox,sdBox(mod((p+boxloc)+0.5*c,c)-0.5*c,vec3(0.4,0.4,0.4)));\n    checkDist(dist, mins, obj, 3);\n        \n    \n    //checkDist(dist, sdBox(mod(p,8.)+vec3(-3.0,0.5,0), vec3(0.5,0.5,0.5)), obj, 3);\n\n    return dist;\n}\nfloat sdScene(vec3 p){\n    int obj = 0;\n    return sdScene(p, obj);\n}\n\nvec3 findNormal(vec3 p, float d){\n    return normalize(vec3(\n        sdScene(p + vec3(d,0,d)) - sdScene(p - vec3(d,0,0)),\n        sdScene(p + vec3(0,d,0)) - sdScene(p - vec3(0,d,0)),\n        sdScene(p + vec3(0,0,d)) - sdScene(p - vec3(0,0,d))));\n}\nfloat shadow(vec3 pos, int maxmarch){\nfloat s = 1.;\nfloat lastd =0.;\nvec3 dir=normalize(vec3(1,1,1));\n    for(int i=0;i<maxmarch;i++){\n    float d = sdScene(pos+lastd*dir);\n    if(d < 0.000003){\n              i = maxmarch;\n              s=1.;\n         }else\n         \n         if(d>200.){\n         i = maxmarch;\n              s = 0.;\n         }else{\n              pos += dir * lastd;\n               lastd =d;\n         }\n    }\n    return s;\n}\n\nvec4 raycast(vec3 pos, vec3 dir, int maxmarch){ // Casts a ray from position in direction, returns color of object. TODO: out direction, materials.\n    vec4 col = vec4(0,0,0,0);\n    float lastd=0.;\n    float totalDist = 0.;\n    int ob = -1;\n    for(int i = 0; i < maxmarch; i++){\n         float d = sdScene(pos + dir * lastd, ob);\n         if(d < 0.000003){\n              i = maxmarch;\n              vec3 norm = findNormal(pos,0.0001);\n\n              float s = shadow(pos , maxmarch);\n              col = vec4(float(ob),norm.x-norm.z,totalDist,s);\n              }else if(d>200.){\n              i = maxmarch;\n              col = vec4(-1,0,2000,0);\n         }else{\n              pos += dir * lastd; // march ray\n              totalDist += lastd;\n              lastd = d;\n\n         }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pix =4.;\n    vec4 outray = vec4(1,1,1,1);\n    if(fragCoord.x <= iResolution.x/pix &&\n    fragCoord.y <= iResolution.y/pix){\n \n    float pit = 0.6154 + sin(iTime * 0.25)*0.6154;\n    float yaw = 0.7853 + iTime*0.5;\n    vec2 uv = (fragCoord-iResolution.xy/pix*0.5);\n   \n    float zoom = 0.05;\n\n    vec3 pos = vec3(uv*zoom,-100); // Screen at x,y,0\n    vec3 dir = normalize(vec3(0,0,1)); // all rays are in the same direction\n    rotx(dir,pit);\n    rotx(pos,pit);\n    roty(dir,yaw);\n    roty(pos,yaw);\n    outray = raycast(pos,dir,350);\n    \n    }\n    // R is Object Index\n    // G is Normal\n    // B is Distance\n    // A is Shadow\n    fragColor = outray;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 getColorFromIndex(int i){\n    vec3 d = vec3(0,0.5,0.8);\n    if (i == 1){\n        d = vec3(1,0,1);\n    }\n    if (i == 2){\n        d = vec3(0,1,1);\n    }\n    if (i == 3){\n        d = vec3(1,1,0);\n    }\n    return d;\n}\nvec3 checkOuter(vec4 a,vec2 fc,float pix){\nvec3 outer = vec3(0,0,0);\n    for(int i = -1; i < 2; i++){\n        for(int j = -1; j < 2; j++){\n \n            if(abs(i) + abs(j) == 1){\n                vec4 b = texelFetch(iChannel0,ivec2(fc/pix) + ivec2(i,j),0);\n                if(a.x != b.x){\n                    if(a.z <= b.z - 0.2){  \n                        outer.x = max(3.,outer.x);\n                    }else if(a.z <= b.z + 0.2){\n                       outer.x = max(2.,outer.x);\n                    }else{\n                        outer.x = max(1.,outer.x);\n                    }\n                }else{\n                    if(!(a.z <= b.z + 0.3)){  \n                        outer.x = max(3.,outer.x);\n                    }\n                }\n                if(a.y != b.y){ // Normals Different\n                    if(a.y <= b.y - 0.3){  \n                        outer.y = max(1.,outer.y);\n                    }else if(a.y <= b.y + 0.3){\n                        outer.y = max(0.,outer.y);\n                    }else{\n                        outer.y = 3.;\n                    }\n                }\n               \n                \n            }\n        }\n    }\n    return outer;\n}\n\n\n\n// Buffer for edge detection & priority/combine\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //buffer a is small, 1/pix in size.\n    float pix = 4.;\n    vec4 prebuf = texelFetch(iChannel0,ivec2(fragCoord/pix),0);\n    \n    vec3 outer = checkOuter(prebuf, fragCoord, pix);\n    vec3 col = getColorFromIndex(int(prebuf.x));\n    \n   if(outer.x == 1.){ // Outline\n       col *= 1.2;\n   }\n   if(outer.x == 2.){ // MeetLine\n       col *= 0.9;\n   }\n   if(outer.x == 3.){ // Inline\n       col *= 0.7;\n   }\n   if(outer.x == 0.){ // Hard edges\n       if(outer.y == 3.){\n           col += 0.4;\n       }\n       if(outer.y == 1.){\n           col += 0.1;\n       }\n   }\n   col *= 1.-prebuf.w*0.3;\n   \n    fragColor = vec4(col.xyz,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}