{"ver":"0.1","info":{"id":"XlcXR2","date":"1480460227","viewed":422,"name":"Harris corner detection","username":"yduf","description":"harris corner detecton","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["harris"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float w = 4.0;\t\t\t// weight of Gaussian\n\n// smooth hessian\nvoid hessian( out vec4 hh, in vec2 uv )\n{\n    hh = vec4( 0.0, 0.0, 0.0, 1.0);\n    hh += texture( iChannel0, uv - vec2(-0.5, -0.5)/iResolution.xy ) / w;      \n    hh += texture( iChannel0, uv - vec2(+0.5, -0.5)/iResolution.xy ) / w;\n    hh += texture( iChannel0, uv - vec2(-0.5, +0.5)/iResolution.xy ) / w;      \n    hh += texture( iChannel0, uv - vec2(+0.5, +0.5)/iResolution.xy ) / w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  // \n  vec4 hh;\n  hessian( hh, uv);\n    \n  // improve contrast before computing harris function\n  float contrast = 10.0;\n  hh *= contrast;\n    \n  float dx2 = hh.x ;\n  float dy2 = hh.y;\n  float dxy = hh.z;\n      \n  // harris\n  float det = dx2*dy2 - dxy*dxy;\t\t// [-1..1]\n  float tr  = dx2 + dy2;\t\t\t\t// [0..2]\t\n    \n  // harris function\n  float alpha = 0.03;\n  float harris = det - alpha*tr*tr;\n    \n  // visualize results\n  float mult = 20000.0;\n  float vis = 0.3;\n    if( harris >= 0.0) {\n        vis += log( 1.05 + harris*mult);\n    }\n    else {\n        vis += exp( harris*mult) - 1.0;\n    }\n    \n  fragColor = vec4( vec3( 1.0 - vis), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// try to implement\n// http://dsp.stackexchange.com/questions/401/how-to-detect-corners-in-a-binary-images-with-opengl\n// as a shader\nconst float w = 2.0;\t\t\t// weight of Gaussian\nvec4 bw = vec4( 0.2125, 0.7154, 0.0721, 0.0) / w;\n\n// one pass x derivative\n// dx\n// input [0..1] => ouput [-1..1]\nfloat dx_blur( in vec2 fragCoord )\n{  \n    float sum = iResolution.x;\n    float dx = 0.0;\n    \n    // \n    dx -= dot( texture( iChannel0, fragCoord - vec2(1.0, -0.5)/sum ), bw);      \n    dx -= dot( texture( iChannel0, fragCoord - vec2(1.0, +0.5)/sum ), bw);\n    \n    //\n    dx += dot( texture( iChannel0, fragCoord + vec2(1.0, -0.5)/sum ), bw); \n    dx += dot( texture( iChannel0, fragCoord + vec2(1.0, +0.5)/sum ), bw);\n    \n    return dx;\n}\n\n// one pass y derivative\n// dy\n// input [0..1] => ouput [-1..1]\nfloat dy_blur( in vec2 fragCoord)\n{  \n    float sum = iResolution.y;\n    float dy = 0.0;\n    \n    // \n    dy -= dot( texture( iChannel0, fragCoord - vec2(-0.5, 1.0)/sum ), bw);      \n    dy -= dot( texture( iChannel0, fragCoord - vec2(+0.5, 1.0)/sum ), bw);\n    \n    //\n    dy += dot( texture( iChannel0, fragCoord + vec2(-0.5, 1.0)/sum ), bw); \n    dy += dot( texture( iChannel0, fragCoord + vec2(+0.5, 1.0)/sum ), bw);\n    \n    return dy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n   \n  // compute derivative\n  mediump float dx = dx_blur( uv);\n  mediump float dy = dy_blur( uv);\n\n  // input[-1..1] => output[0..1]\n  fragColor = vec4( dx*dx,\n                    dy*dy, \n                    abs(dx*dy), \n                    1.0)\n      ;\n}\n","name":"Buf A","description":"","type":"buffer"}]}