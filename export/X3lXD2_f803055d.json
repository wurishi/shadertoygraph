{"ver":"0.1","info":{"id":"X3lXD2","date":"1710014232","viewed":83,"name":"Focal Color","username":"infernalwave","description":"quantized colors from roaming focal points","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["colorful"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nfloat hash(float n) { return fract(sin(n) * 43758.5453); }\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(hash(ip.x+ip.y*57.0),hash(ip.x+1.0+ip.y*57.0),u.x),\n        mix(hash(ip.x+(ip.y+1.0)*57.0),hash(ip.x+1.0+(ip.y+1.0)*57.0),u.x),u.y);\n    return res*res;\n}\n\nvec3 hsb2rgb(vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 quantize(vec3 col, float levels) {\n    return floor(col * levels) / levels;\n}\n\nvec2 getFocalPoint(vec2 p, float time, int index) {\n    float angle = noise(vec2(float(index) * 1.27 + 0.54321 * float(index), time * 1.63 + 0.12345 * float(index))) * 2.0 * PI;\n    float radius = noise(vec2(time * 1.81 + 0.23456 * float(index), float(index) * 2.39 + 0.34567 * float(index))) * 0.4;\n    vec2 noiseOffset = vec2(noise(vec2(float(index) * 0.12, time * 0.78)), noise(vec2(time * 0.34, float(index) * 0.56))) * 2.0 - 1.0;\n    return p + vec2(cos(angle), sin(angle)) * radius + noiseOffset;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    float time = iTime * 0.3; // Time multiplier for movement\n    vec3 col = vec3(0.0);\n\n    const int numFocalPoints = 4; // Number of focal points\n    for(int i = 1; i <= numFocalPoints; i++){\n        vec2 fp = getFocalPoint(p, time, i);\n        float len = length(fp);\n\n        float hue = mod(0.3 + 0.7 * len + time/2.0, 1.0);\n        float saturation = 1.0;\n        float brightness = 0.5 + 0.5 * sin(len * 8.0 + time);\n        col += hsb2rgb(vec3(hue, saturation, brightness));\n    }\n\n    col /= float(numFocalPoints);\n    col = quantize(col, 8.0);\n    col = pow(col, vec3(1.0/2.2));\n\n    // Simple averaging for smoothing (Optional)\n    vec3 avgCol = col;\n    float kernelSize = 1.0; // Size of the averaging kernel\n    for (float dx = -kernelSize; dx <= kernelSize; dx++) {\n        for (float dy = -kernelSize; dy <= kernelSize; dy++) {\n            vec2 offset = vec2(dx, dy) / iResolution.xy;\n            vec2 newP = p + offset;\n            // Repeating main color calculation logic for neighboring pixels\n            vec3 neighborCol = vec3(0.0);\n            for(int i = 1; i <= numFocalPoints; i++){\n                vec2 fp = getFocalPoint(newP, time, i);\n                float len = length(fp);\n                float hue = mod(0.3 + 0.7 * len + time/2.0, 1.0);\n                float saturation = 1.0;\n                float brightness = 0.5 + 0.5 * sin(len * 8.0 + time);\n                neighborCol += hsb2rgb(vec3(hue, saturation, brightness));\n            }\n            neighborCol /= float(numFocalPoints);\n            neighborCol = quantize(neighborCol, 8.0);\n            neighborCol = pow(neighborCol, vec3(1.0/2.2));\n\n            avgCol += neighborCol;\n        }\n    }\n    avgCol /= (2.0 * kernelSize + 1.0) * (2.0 * kernelSize + 1.0);\n\n    fragColor = vec4(avgCol, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}