{"ver":"0.1","info":{"id":"wlVSDm","date":"1583008921","viewed":99,"name":"Ray March 7","username":"baksej","description":"Ray March 7","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void pR(inout vec2 p, float a) {\n    p = cos(a) * p + sin(a) * vec2(p.y, - p.x);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat map(float v, float a, float b, float x, float y) {\n    float n = (v - a) / (b - a);\n    return x + n * (y - x);\n}\n\nfloat ground(vec3 pos) {\n    return pos.y;\n    \n}\nfloat samplesTaken = 0.0;\n\nfloat scene(vec3 pos) {\n    samplesTaken += 1.0 ;\n    vec3 i = floor(pos / 0.3);\n    \n    float s1;\n    {\n        vec3 f = pos;\n        f.xz = mod(pos.xz, 0.3) - 0.15;\n        f.x += sin(iTime + i.z * 6.2 * 0.1) * 0.01;\n        f.z += cos(iTime + i.z * 6.2 * 0.1) * 0.01;\n        f.y += 0.05;\n        s1 = sphere(f, 0.01);\n    }\n    {\n        vec3 f = pos;\n        f.xz = mod(pos.xz, 0.3) - 0.15;\n        f.x += sin(iTime + i.z * 6.2 * 0.1) * 0.05;\n        f.z += cos(iTime + i.z * 6.2 * 0.1) * 0.02;\n        f.y += -0.0;\n        s1 = smin(s1, sphere(f, 0.02), 0.1);\n    }\n    \n    // vec3 pos2 = pos;\n    // pos2.y += 100.0 + 0.1;\n    // pos2.z -= 1.0;\n    // float s2 = sphere(pos2, 100.0);\n    float s2 = pos.y + 0.1;\n    \n    return smin(s1, s2, 0.1);\n}\n\nvec3 estimateNormal(vec3 pos) {\n    \n    return normalize(\n        vec3(\n            scene(pos - vec3(0.001, 0.0, 0.0)) - scene(pos + vec3(0.001, 0.0, 0.0)),\n            scene(pos - vec3(0.0, 0.001, 0.0)) - scene(pos + vec3(0.0, 0.001, 0.0)),\n            scene(pos - vec3(0.0, 0.0, 0.001)) - scene(pos + vec3(0.0, 0.0, 0.001))\n            \n        )\n    );\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, - 1.0) * 0.5773 * 0.0005;\n    return normalize(\n        e.xyy * scene(pos + e.xyy) +\n        e.yyx * scene(pos + e.yyx) +\n        e.yxy * scene(pos + e.yxy) +\n        e.xxx * scene(pos + e.xxx)\n    );\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float w)\n{\n    float s = 1.0;\n    for(float t = mint; t < maxt; )\n    {\n        float h = scene(ro + rd * t);\n        s = min(s, 0.5 + 0.5 * h / (w * t));\n        if (s < 0.0)break;\n        t += clamp(h, 0.01, 1.0);\n    }\n    s = max(s, 0.0);\n    return s * s*(3.0 - 2.0 * s); // smoothstep\n}\n\n// https://iquilezles.org/articles/rmshadows\n// float improvedSoftShadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k)\n// {\n    //     float res = 1.0;\n    //     float ph = 1e20;\n    //     for(float t = mint; t < maxt; )\n    //     {\n        //         float h = scene(ro + rd * t);\n        //         if (h < 0.001)return 0.0;\n        //         float y = h*h / (2.0 * ph);\n        //         float d = sqrt(h * h-y * y);\n        //         res = min(res, k * d / max(0.0, t - y));\n        //         ph = h;\n        //         t += clamp(h, 0.01, 1.0);\n    //     }\n    //     return res;\n// }\nvec3 lightOrigin = vec3(-1.0, - 1.0, 0.0);\n\nvec3 shade(vec3 pos) {\n    float falloff = 0.4;\n    vec3 albedo = vec3(1.0);\n    vec3 diffuseColor = vec3(1.0, 0.8, 0.6);\n    vec3 ambientColor = vec3(0.1, 0.1, 0.2);\n    \n    vec3 nor = calcNormal(pos);\n    vec3 lig = normalize(vec3(-0.6, 1.0, - 0.6));\n    \n    float dif =\n    clamp(dot(nor, lig), 0.0, 1.0) *\n    softshadow(pos, lig, 0.01, 3.0, 0.3);\n    \n    vec3 col = albedo * dif * diffuseColor;\n    col += ambientColor;\n    return col;\n    \n    // vec3 lightDir = normalize(pos - lightOrigin);\n    // float lightIntensity = 1.0 - pow(length(pos - lightOrigin) * falloff, 2.0);\n    // vec3 normal = calcNormal(pos);\n    // float diffuse = clamp(dot(lightDir, normal), 0.0, 1.0);\n    \n    // float s = softshadow(pos, -lightOrigin, 0.01, 3.0, 0.3);\n    \n    // return albedo * (diffuseColor * diffuse * lightIntensity * s + ambientColor);\n}\n\nvec3 trace(vec3 rayOrigin, vec3 rayDir, out float t) {\n    const int maxSteps = 256;\n    const float mint = 0.1;\n    const float maxt = 10.0;\n    \n    for(t = mint; t < maxt; ) {\n        vec3 pos = rayOrigin + rayDir * t;\n        float h = scene(pos);\n        if (h < 0.001) {\n            return shade(pos);\n            //return vec3(0.0);\n        }\n        t += clamp(h, 0.001, 1.0);\n        \n    }\n    return vec3(0.0);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // set up uv coords\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    // position lights\n    // lightOrigin = vec3(sin(iTime), 0.6, - 0.3);\n    \n    // position camera\n    vec3 camOrigin = vec3(0.0, 0.5, - 3.0);\n    float dist;\n    \n    vec3 color = vec3(0.0);\n    float steps = 1.0;\n    float st;\n    for(st = 0.0; st < steps; st ++ ) {\n        \n        vec3 rayOrigin = vec3(camOrigin.xy + uv, camOrigin.z + 3.0);\n        \n        // camOrigin.x += random(rayOrigin.xy + 1.0 / steps) * 0.05;\n        // camOrigin.y += random(rayOrigin.xy + 1.0 / steps + 1.0) * 0.05;\n        \n        vec3 dir = normalize(rayOrigin - camOrigin);\n        pR(dir.xz, 0.3); // yaw camera\n        pR(dir.yz, - 0.2); // pitch camera down\n        \n        color += trace(camOrigin, dir, dist);\n        \n    }\n    color /= st;\n    \n     float fog = clamp(map(dist, 1.0, 9.0, 1.0, 0.0), 0.0, 1.0);\n    color = mix(vec3(0.0), color, fog);\n    \n    vec3 computeColor = vec3(samplesTaken / 256.0);\n    vec3 distColor = vec3(dist * 0.1);\n    \n    color = mix(color, computeColor, step(0.0, uv.x));\n    color = mix(color, distColor, step(0.5, uv.x));\n   \n    \n   \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}