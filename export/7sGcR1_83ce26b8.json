{"ver":"0.1","info":{"id":"7sGcR1","date":"1654391756","viewed":163,"name":"Musical Notation","username":"CharlesVsWorld","description":"A variety of musical score figures drawn in 2D distance.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","music","notes","score"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define antialias 0.08\n\n#define note_size 0.1\n#define note_slant vec2(0.33,0.93496)\n#define note_slant_alt vec2(0.73, 0.73)\n#define note_spacing_32nd 0.017\n\n#define note_type_whole 1\n#define note_type_half 2\n#define note_type_quarter 3\n#define note_type_eighth 4\n#define note_type_sixteenth 5\n#define note_type_thirtysecond 6\n#define note_type_rest_whole 7\n#define note_type_rest_half 8\n#define note_type_rest_quarter 9\n#define note_type_rest_eighth 10\n#define note_type_rest_sixteenth 11\n#define note_type_rest_thirtysecond 12\n\n#define staff_note_spacing 0.03\n#define staff_spacing staff_note_spacing * 2.0\n#define staff_octave_spacing staff_note_spacing * 7.0\n#define staff_pos_x 0.0\n#define staff_pos_y 0.5\n#define staff_pos vec2(staff_pos_x, staff_pos_y)\n#define staff_width 1.0\n#define staff_line_width 0.003\n\n#define decoration_none 0\n#define decoration_flat 1\n#define decoration_natural 2\n#define decoration_sharp 3\n#define decoration_dotted 4\n#define decoration_dotted_flat 5\n#define decoration_dotted_natural 6\n#define decoration_dotted_sharp 7  \n    \n#define NUM_NOTES 32\n#define NUM_KEY_SIG 14\n\nuniform vec2 KeyPositions[NUM_KEY_SIG]; // 0-6 # Sharp, 8-15 b Flat\nuniform vec2 NotePositions[NUM_NOTES];\nuniform int NoteTypes[NUM_NOTES];\nuniform int NoteDecoration[NUM_NOTES];\nuniform vec2 NoteTails[NUM_NOTES];\nuniform float NoteTies[NUM_NOTES];\n\nfloat drawEllipse(in vec2 uv, in vec2 pos, vec2 dim) \n{\n    vec2 d = (uv - pos) / (dim * dim);\n    if (abs( d.x ) <= 1.0 && abs( d.y ) < 1.0 ) \n    {\n        if (dot(d, d) < 1.0) return 1.0;\n    }\n    return 0.0;\n}\n\nfloat drawRotatedEllipse(vec2 uv, vec2 pos, float size, bool altRot)\n{\n    float dim = 70.0;\n    pos *= vec2(dim, dim);\n    vec2 diff = note_slant * size;\n    if (altRot)\n    {\n        diff = note_slant_alt * size;\n    }\n    vec2 l = pos - diff;\n    vec2 r = pos + diff;\n    \n    vec2 coord = uv * vec2(dim, dim);\n    return smoothstep(0.0, antialias, distance(l, r) + 1.0 - (distance(coord, l) + distance(coord, r)));\n}\n\nfloat drawRect(in vec2 uv, in vec2 center, in vec2 wh)\n{\n    vec2 disRec = abs(uv - center) - wh * 0.5;\n    float dis = max(disRec.x, disRec.y);\n    return clamp(float(dis < 0.0), 0.0, 1.0);\n}\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat drawLineRounded(in vec2 uv, in vec2 start, in vec2 end, in float width)\n{\n    return mix(0.0, 1.0, 1.0-smoothstep(width-antialias*0.02,width, distanceToSegment(start, end, uv)));\n}\n\nfloat drawLineSquare(in vec2 uv, in vec2 start, in vec2 end, in float width, bool vertical)\n{\n    float col = drawLineRounded(uv, start, end, width);\n    vec2 clip_box = vec2(0.015, width * 4.0);\n    float leftBox = drawRect(uv, start + vec2(clip_box.x * -0.5, 0.0), clip_box);\n    float rightBox = drawRect(uv, end + vec2(clip_box.x * 0.5, 0.0), clip_box);\n    if (vertical)\n    {\n        clip_box = vec2(width * 4.0, 0.02);\n        leftBox = drawRect(uv, start, clip_box);\n        rightBox = drawRect(uv, end, clip_box);\n    }\n    col -= leftBox + rightBox;\n    return clamp(col, 0.0, 1.0);\n}\n\nfloat drawAccidental(in vec2 uv, in vec2 p, int val, bool note_relative_pos)\n{\n    float col = 0.0;\n    float width = 0.055;\n    float thickness = 0.002;\n    vec2 acc_pos = p;\n    if (note_relative_pos)\n    {\n        acc_pos = p - vec2(0.02, 0.0);\n    }\n    if (val == 0)\n    {\n        // Natural\n        float boxX = 0.01;\n        float boxY = 0.01;\n        col += drawRect(uv, acc_pos + vec2(0.0, -0.005), vec2(0.001, width));\n        col += drawRect(uv, acc_pos - vec2(boxX, -0.02), vec2(0.001, width));\n        col += drawLineSquare(uv, acc_pos + vec2(-boxX, -boxY), acc_pos + vec2(0.0, -0.00), thickness, false);\n        col += drawLineSquare(uv, acc_pos + vec2(-boxX, boxY), acc_pos + vec2(0.0, 0.02), thickness, false);\n    }\n    else if (val == 1)\n    {\n        // Sharp\n        float hashX = 0.02;\n        float hashY = 0.01;\n        col += drawRect(uv, acc_pos - vec2(0.004, 0.0), vec2(0.0025, width));\n        col += drawRect(uv, acc_pos - vec2(0.012, 0.005), vec2(0.0025, width));\n        col += drawLineSquare(uv, acc_pos - vec2(hashX, -0.002), acc_pos + vec2(0.005, 0.023), thickness, false);\n        col += drawLineSquare(uv, acc_pos - vec2(hashX, 0.022), acc_pos + vec2(0.005, -0.003), thickness, false);\n    }\n    \n    else if (val == -1)\n    {\n        // Flat\n        float little_b = drawRect(uv, acc_pos - vec2(0.015, -0.018), vec2(0.002, width));\n        little_b += drawRotatedEllipse(uv, acc_pos - vec2(0.015, 0.0), 0.5, true);\n        little_b -= drawRotatedEllipse(uv, acc_pos - vec2(0.015, 0.0), 0.15, false);\n        little_b -= drawRect(uv, acc_pos - vec2(0.031, 0.0), vec2(0.03, 0.05));\n        col += little_b;\n    }\n    return col;\n}\n\nfloat drawKeySignature(in vec2 uv)\n{\n    float key = 0.0;\n    for (int i = 0; i < NUM_KEY_SIG; ++i)\n    {\n        vec2 p = KeyPositions[i];\n        if (abs(p.x) + abs(p.y) > 0.0)\n        {\n            key += drawAccidental(uv, p, i <= 7 ? 1 : -1, false);\n        }\n    }\n    return key;\n}\n\nfloat drawTie(in vec2 uv, in vec2 start, in vec2 end, bool above)\n{\n    float col = 0.0;\n    vec2 dir = (end - start);\n    float elen = length(dir);\n    vec2 mid = start + (dir * 0.5) + vec2(-0.004, clamp(elen - 0.2, 0.0, 0.1) - 0.035);\n    vec2 dim_lo = vec2(elen * 1.45, elen * 0.99);\n    vec2 dim_hi = vec2(dim_lo.x * 1.15, dim_lo.y * 1.15);\n    vec2 offset_inner = vec2(0.0, elen * 0.12);\n    if (above)\n    {\n        offset_inner = vec2(0.0, elen * -0.12);\n    }\n    col += drawEllipse(uv, mid, dim_lo) - drawEllipse(uv, mid + offset_inner, dim_hi);\n    return clamp(col, 0.0, 1.0);\n}\n\n// hat-size denotes joining between eigth and sixteenth notes\n// hat_size.x component is the length,Y component is the end heigh difference\n// hat_size.x of zero and negative Y means the note has been tied into and does not require a tail\n\n// extra_geo denotes extending the stalk length of a note or forcing it's stalk a direction\n// extra_geo.x of absolute value greater than zero will force the stalk direction, +ve for up, -ve for down\n// extra_geo.y is added onto the default stalk lenghth\nfloat drawNote(in vec2 uv, in vec2 p, in int note_type, in int dec, in vec2 hat_size, in float tie_32s, in vec2 extra_geo) \n{\n    if (note_type == note_type_rest_whole)\n    {\n        return drawRect(uv, vec2(p.x, staff_pos_y + staff_note_spacing * 5.5), vec2(0.035, 0.025));\n    }\n    else if (note_type == note_type_rest_half)\n    {\n        return drawRect(uv, vec2(p.x, staff_pos_y + staff_note_spacing * 4.5), vec2(0.035, 0.025));\n    }\n    else if (note_type == note_type_rest_quarter)\n    {\n        float col = drawLineRounded(uv, vec2(p.x - 0.015, staff_pos_y + 0.22), vec2(p.x - 0.001, staff_pos_y + 0.18), 0.0025);\n        col += drawLineSquare(uv, vec2(p.x-0.006, staff_pos_y + 0.19), vec2(p.x - 0.02, staff_pos_y + 0.11), 0.009, true);\n        col += drawLineRounded(uv, vec2(p.x - 0.025, staff_pos_y + 0.12), vec2(p.x - 0.011, staff_pos_y + 0.072), 0.0025);\n        col += drawEllipse(uv, vec2(p.x - 0.022, staff_pos_y + 0.07), vec2(0.11, 0.14));\n        col -= drawEllipse(uv, vec2(p.x - 0.019, staff_pos_y + 0.062), vec2(0.1, 0.13));\n        return clamp(col, 0.0, 1.0);\n    }\n    else if (note_type >= note_type_rest_sixteenth)\n    {\n        float col = drawLineRounded(uv, vec2(p.x - 0.001, staff_pos_y + 0.173), vec2(p.x - 0.02, staff_pos_y + 0.06), 0.0025);\n        col += drawEllipse(uv, vec2(p.x - 0.024, staff_pos_y + 0.15), vec2(0.105, 0.135));\n        col += drawLineRounded(uv, vec2(p.x - 0.016, staff_pos_y + 0.14), vec2(p.x - 0.003, staff_pos_y + 0.167), 0.003);\n        return col;\n    }\n    \n    vec2 stalk_size = vec2(0.0025, 0.2 + extra_geo.y);\n    float blob_size = staff_note_spacing * 45.0;\n    float blob = drawRotatedEllipse(uv, p, blob_size, false);\n    float decoration = 0.0;\n    float lines = 0.0;\n    int lines_over = 0;\n    int lines_under = 0;\n    bool dotted = dec >= decoration_dotted;\n    bool stalk_dir_down = p.y > staff_pos_y + (staff_note_spacing * 2.0);\n    if (extra_geo.x > 0.0)\n    {\n        stalk_dir_down = false;\n    }\n    else if (extra_geo.x < 0.0)\n    {\n        stalk_dir_down = true;\n    }\n    \n    if (dotted)\n    {\n        decoration += drawEllipse(uv, p + vec2(0.04, 0.0), vec2(0.07, 0.1));\n    }\n    \n    int acc = dec >= decoration_dotted_flat ? dec - decoration_dotted_natural : dec - decoration_natural;\n    if (abs(acc) <= 1)\n    {\n        decoration += drawAccidental(uv, p, acc, true);\n    }\n    \n    float tie = 0.0;\n    if (tie_32s > 0.0)\n    {\n        tie = drawTie(uv, p, p + vec2(note_spacing_32nd * tie_32s, 0.0), stalk_dir_down);\n    }\n    \n    if (note_type <= note_type_half)\n    {\n        blob -= drawRotatedEllipse(uv, p, blob_size * 0.5, true);\n    }\n    \n    float staff_above = (staff_pos_y + staff_note_spacing * 9.0);\n    float staff_below = (staff_pos_y - staff_note_spacing * 2.0);\n    float dist_below = staff_below - p.y;\n    float dist_above = p.y - staff_above;\n    vec2 line_size = vec2(0.055, staff_line_width * 2.0);\n    if (dist_below >= 0.0)\n    {\n        vec2 line_pos = vec2(p.x, staff_below);\n        int num_lines = 1 + int(dist_below / staff_note_spacing / 1.9);\n        for (int i = 0; i < num_lines; ++i)\n        {\n            lines += drawRect(uv, line_pos, line_size);\n            line_pos.y -= staff_note_spacing * 2.0;\n        }\n    }\n    else if (dist_above >= 0.0)\n    {\n        vec2 line_pos = vec2(p.x, staff_above);\n        int num_lines = 1 + int(dist_above / staff_note_spacing / 1.9);\n        for (int i = 0; i < num_lines; ++i)\n        {\n            lines += drawRect(uv, line_pos, line_size);\n            line_pos.y += staff_note_spacing * 2.0;\n        }\n    }\n    \n    if (note_type == note_type_whole)\n    {\n        return clamp(blob + lines + tie + decoration, 0.0, 1.0);\n    }\n\n    float stalk_width = note_size * 0.2;\n    vec2 stalk_pos = vec2(stalk_width - 0.002, stalk_size.y * 0.5);\n    if (stalk_dir_down)\n    {\n        stalk_pos.x -= blob_size * 0.026;\n        stalk_pos.y -= stalk_size.y;\n    }\n    float stalk = drawRect(uv, p + stalk_pos, stalk_size);\n                   \n    if (note_type >= note_type_eighth && hat_size.x <= 0.0 && hat_size.y >= 0.0)\n    {\n        float tail = 0.0;\n        \n        // Single tail\n        if (note_type >= note_type_eighth)\n        {\n            vec2 tail_dim = vec2(0.18, 0.3);\n            vec2 tail_pos = p + stalk_pos + vec2(0.0, (tail_dim.y - stalk_size.y) * 0.1);\n            if (stalk_dir_down)\n            {\n                tail_pos = p + stalk_pos - vec2(0.0, (tail_dim.y - stalk_size.y) * 0.1);\n                tail += drawEllipse(uv, tail_pos, tail_dim);\n                tail -= drawEllipse(uv, tail_pos + vec2(0.0, 0.01), tail_dim - vec2(0.01, 0.008));\n                tail -= drawRect(uv, p + stalk_pos - vec2(0.05, 0.0), vec2(0.1, stalk_size.y)); \n            }\n            else\n            {\n                tail += drawEllipse(uv, tail_pos, tail_dim);\n                tail -= drawEllipse(uv, tail_pos - vec2(0.0, 0.01), tail_dim - vec2(0.01, 0.008));\n                tail -= drawRect(uv, p + stalk_pos - vec2(0.05, 0.0), vec2(0.1, stalk_size.y)); \n            }\n            tail = clamp(tail, 0.0, 1.0);\n        }\n        \n        // Double tail\n        if (note_type >= note_type_sixteenth)\n        {\n        \n        }\n        return clamp(blob + lines + tie + stalk + decoration + tail, 0.0, 1.0);\n    }\n    \n    if (note_type <= note_type_quarter)\n    {\n        return clamp(blob + lines + tie + stalk + decoration, 0.0, 1.0);\n    }\n    \n    // Lines joining quavers and semi quavers\n    float hat = 0.0;\n    if (hat_size.x > 0.0)\n    {\n        float stalk_y_mult = stalk_dir_down ? -0.44 : 0.51;\n        float hat_width = 0.012;\n        vec2 hat_start = p + stalk_pos + vec2(stalk_width * -0.05, (stalk_size.y * stalk_y_mult) - hat_width);\n        vec2 hat_end = hat_start + hat_size + vec2(0.002, 0.0);\n        hat = drawLineSquare(uv, hat_start, hat_end, hat_width, false);\n    }\n    \n    return clamp(blob + lines + tie + stalk + hat + decoration, 0.0, 1.0);   \n}\n\n// Staff reference pos is from the left bottom\nfloat drawStaff(in vec2 uv, in vec2 p)\n{\n    float col = drawRect(uv, p + vec2(0.5 * staff_width, staff_spacing * 2.0), vec2(staff_width, staff_spacing * 4.0)) * 0.25;\n    for (int i = 0; i < 5; ++i)\n    {\n        vec2 start = p + vec2(0.0, float(i) * staff_spacing);\n        vec2 end = start + vec2(staff_width, 0.0);\n        col += mix(0.0, 1.0, 1.0-smoothstep(staff_line_width-antialias*0.01, staff_line_width, distanceToSegment(start, end, uv)));\n    }\n    return clamp(col, 0.0, 1.0);\n}\n\nfloat drawNotes(in vec2 uv)\n{\n    float col = 0.0;\n    vec2 note_pos = vec2(0.05, staff_pos_y + staff_note_spacing * 11.0);\n    vec2 extra_geo = vec2(0.0);\n    float tie = 32.0;\n    \n    note_pos = vec2(0.2, 0.75);\n    \n    // Key signature of Ab\n    col+= drawAccidental(uv, vec2(0.023, 0.5), 1, false);\n    \n    // Quaver with sharp\n    col += drawNote(uv, note_pos, note_type_sixteenth, decoration_natural, vec2(0.0), tie, extra_geo);\n    \n    // High crotchets with other accidentals\n    col += drawNote(uv, note_pos + vec2(0.2, 0.0), note_type_quarter, decoration_flat, vec2(0.0), tie, extra_geo);\n    col += drawNote(uv, note_pos + vec2(0.4, 0.0), note_type_half, decoration_none, vec2(0.0), tie, extra_geo);\n    \n    // Rests\n    col += drawNote(uv, vec2(0.3, 0.0), note_type_rest_sixteenth, 0, vec2(0.0), tie, extra_geo);\n    col += drawNote(uv, vec2(0.43, 0.0), note_type_rest_quarter, 0, vec2(0.0), tie, extra_geo);\n    col += drawNote(uv, vec2(0.64, 0.0), note_type_rest_whole, 0, vec2(0.0), tie, extra_geo);\n    col += drawNote(uv, vec2(0.74, 0.0), note_type_rest_half, 0, vec2(0.0), tie, extra_geo);\n    \n    note_pos = vec2(0.05, staff_pos_y - staff_note_spacing*2.0);\n    \n    tie = 8.0;\n    col += drawNote(uv, note_pos, note_type_sixteenth, decoration_none, vec2(0.0), tie, extra_geo);\n    tie = 0.0;\n    note_pos += vec2(note_spacing_32nd * 8.0, -staff_note_spacing);\n    col += drawNote(uv, note_pos, note_type_quarter, decoration_none, vec2(0.0), tie, extra_geo);\n    note_pos += vec2(note_spacing_32nd * 8.0, -staff_note_spacing);\n    col += drawNote(uv, note_pos, note_type_quarter, decoration_sharp, vec2(0.0), tie, extra_geo);\n\n    note_pos = vec2(0.05, staff_pos_y + staff_note_spacing*8.0);\n    \n    \n    col += drawNote(uv, note_pos, note_type_whole, decoration_dotted, vec2(0.0), tie, extra_geo);\n    note_pos += vec2(note_spacing_32nd * 32.0, 0.0);\n\n    note_pos += vec2(note_spacing_32nd * 16.0, 0.0);\n    \n    col += drawNote(uv, note_pos, note_type_half, decoration_sharp, vec2(0.0), tie, extra_geo);\n    tie = 0.0;\n    note_pos += vec2(note_spacing_32nd * 16.0, 0.0);\n    \n    note_pos = vec2(0.5, staff_pos_y - staff_note_spacing * 4.0);\n    \n    // Four joined quavers\n    tie = 4.0;\n    extra_geo.y += staff_note_spacing;\n    vec2 tail_size = vec2(note_spacing_32nd * 4.0, 0.0);\n    col += drawNote(uv, note_pos, note_type_eighth, decoration_none, tail_size, tie, extra_geo);\n    tie = 0.0;\n    note_pos += vec2(note_spacing_32nd * 4.0, 0.0);\n    col += drawNote(uv, note_pos, note_type_eighth, decoration_none, tail_size, tie, extra_geo);\n    note_pos += vec2(note_spacing_32nd * 4.0, 0.0);\n    col += drawNote(uv, note_pos + vec2(0.0, staff_note_spacing), note_type_eighth, decoration_none, tail_size, tie, vec2(0.0));\n    note_pos += vec2(note_spacing_32nd * 4.0, 0.0);\n    col += drawNote(uv, note_pos, note_type_eighth, decoration_none, vec2(0.0, -1.0), tie, extra_geo);\n    note_pos += vec2(note_spacing_32nd * 10.0, 0.0);\n    \n    // Two joined quavers\n    extra_geo.x = -1.0;\n    col += drawNote(uv, note_pos, note_type_eighth, decoration_none, tail_size + vec2(0.0, 0.04), tie, extra_geo);\n    note_pos += vec2(note_spacing_32nd * 4.0, staff_note_spacing);\n    col += drawNote(uv, note_pos, note_type_eighth, decoration_none, vec2(0.0, -1.0), tie, extra_geo);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{    \n    vec2 p = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.y / iResolution.x;\n    \n    vec4 bg_tex = texture(iChannel0, p);\n    vec4 bg = vec4(bg_tex.xyz, 1.0);\n        \n    float k = drawKeySignature(p);\n    vec4 k4 = vec4(vec3(k * 0.65), k);\n    \n    float s = drawStaff(p, staff_pos);\n    vec4 s4 = vec4(vec3(s * 0.5), s);\n    \n    float n = drawNotes(p);\n    vec3 ncolour = vec3(0.85, 0.85, 0.85);\n    vec4 n4 = vec4(vec3(n * ncolour), 1.0);\n    \n    \n    fragColor = bg + k4 + n4 + s4;\n}","name":"Image","description":"","type":"image"}]}