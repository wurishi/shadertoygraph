{"ver":"0.1","info":{"id":"wtXBzB","date":"1597126962","viewed":620,"name":"Trilights and lights with radius","username":"TomF","description":"An illustration of trilights, and lights with physical radius. See comments for more.\n\nPhase1: env.map plus sunlight (2 trilights)\nPhase2: moonlight with blue backlight (1 trilight)\nPhase3: env.map plus local red light with size (2 trilights)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["lighting","wraparound","trilight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Trilights and lights with a physical radius\n//\n// This shader shows two different types of lighting equations\n// that approximate some interesting effects.\n//\n// * Trilights\n//\n// Trilights are at heart the standard Lambert dot(l,n) lighting,\n// but instead of just being bright on one side, zero at the rim,\n// and clamped to zero on the opposite side,\n// they map three different colours to the three areas.\n//\n// This allows a light that is still cheap to compute (it's just dot(l,n)\n// but that is far more versatile than a regular light.\n//\n// The details are here: http://tomforsyth1000.github.io/papers/trilight/trilight.html\n//\n// * Lights with physical radius\n//\n// Traditional point lights have a problem as they get closer to objects\n// because the 1/d^2 intensity equation blows up to gigantic numbers and\n// causes very sharp highlights.\n//\n// In reality, lights are not infinitely small points, they are a finite\n// volume. As they approach other objects, they start to look like an\n// area light rather than a point, and this softens the intensity rise.\n// It also has the effect that the lighting \"wraps around\" the object -\n// the normals of the object that would be at 90 degrees to a true point\n// light now do face some part of the more realistic area light,\n// casuing the lighting ot \"wrap around\" the object.\n//\n// This effect has been evaluated correctly in the paper:\n// http://www.cemyuksel.com/research/pointlightattenuation/\n//\n// However, an approximation that looks very acceptable is to use a\n// Trilight and blend some of the main light into the rim light as the\n// object appraoches the light's radius, as well as to switch from\n// a 1/d^2 intensity to Cem's version.\n//\n//\n// 99% of this code is just scaffolding for the very simple\n// lighting of the main sphere.\n// Search for \"BANANA\" to get to that bit.\n\n\nvec3 Trilight ( vec3 l, vec3 n, vec3 col0, vec3 col1, vec3 col2 )\n{\n    float ndotl = dot(n,l);\n    if ( ndotl > 0.0 )\n    {\n        //return col0 * ndotl + col1 * (1.0-ndotl);\n        vec3 col01 = col0 - col1;  // this could be precalculated\n        return col1 + col01 * ndotl;\n    }\n    else\n    {\n        //return col1 * (1+ndotl) - col2 * ndotl;\n        vec3 col12 = col1 - col2;  // this could be precalculated\n        return col1 + col12 * ndotl;\n    }\n}\n\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;  \n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    // Figure out viewer position & direction.\n\tvec3 viewPos;\n    vec3 viewDirn;\n    \n    vec2 angles;\n    angles.x = 0.02 * iMouse.x + (0.5*iTime)*0.0;\n    angles.y = 0.02 * iMouse.y;\n    \n    float viewdist = 5.0; // orbiting viewer around the origin.\n    \n\tviewPos.x = viewdist*sin(angles.x) * cos(angles.y);\n\tviewPos.z = viewdist*cos(angles.x) * cos(angles.y);\n    viewPos.y = viewdist*                sin(angles.y);\n    \n\tvec3 lookat = vec3(0.0,0.0,0.0);\n\tvec3 viewz = normalize(lookat-viewPos);\n\tvec3 viewx = normalize(cross(vec3(0.0,1.0,0.0),viewz));\n\tvec3 viewy = normalize(cross(viewz,viewx));\n    \n\tfloat tanfov = 0.6; // field of view.\n    \n    vec2 ndc = fragCoord.xy - 0.5*iResolution.xy;\n    ndc *= 2.0/iResolution.x;\n\tndc *= tanfov;\n\tviewDirn = normalize(viewz + viewx*ndc.x + viewy*ndc.y);\n    \n    \n    \n    // Animation sequencing.\n    float animTime = iTime * 0.1;\n    float animFrac = fract(animTime);\n\tint  animPhase = int( animTime - animFrac );\n    // There's 3 phases of the animation.\n    animPhase = animPhase % 3;\n    \n    // The world is made of spheres!\n    const int SphMain = 0;\n    const int SphLight = 1;\n    const int SphSky = 2;\n    Sphere sphere[3];\n    \n    sphere[SphMain].radius = 1.0;\n    sphere[SphMain].center = vec3(0.0,0.0,0.0);\n    sphere[SphLight].radius = 5.0;\n    sphere[SphLight].center = vec3(10.0,0.0,0.0);\n    sphere[SphSky].radius = 1000000.0;\n    sphere[SphSky].center = vec3(0.0,0.0,0.0);\n    \n    float sunMoonAngle = 3.1415927*2.0*iTime * 0.1;\n    vec3 sunMoonVec = vec3 ( 0.0, cos(sunMoonAngle), sin(sunMoonAngle) );\n    float sunMoonSize = 0.01;\n    vec3 sunMoonColour;\n    vec3 sunMoonFillColour;\n    vec3 skyCol0;\n    vec3 skyCol1;\n    vec3 groundCol0;\n    vec3 groundCol1;\n    skyCol0 = vec3(0.7,0.7,0.7);\n    skyCol1 = vec3(0.0,0.8,1.0);\n    groundCol0 = vec3(0.1,0.1,0.0);\n    groundCol1 = vec3(0.2,0.5,0.1);\n    sunMoonColour = vec3(1.0,1.0,0.0);\n    sunMoonFillColour = vec3(0.0,0.0,0.0); // no backlight for daylight\n    \n    bool blobLightEnable = false;\n    vec3 blobLightColour = vec3(1.0,0.0,0.0);\n    vec3 blobLightVec  = vec3(0.0,1.0,0.0);\n    vec3 blobLightCol0 = vec3(0.0,0.0,0.0);\n    vec3 blobLightCol1 = vec3(0.0,0.0,0.0);\n    vec3 blobLightCol2 = vec3(0.0,0.0,0.0);\n    float sphLightPos;\n    \n    bool groundPlane = false;\n    bool sunMoonLight = false;\n    \n    switch ( animPhase )\n    {\n    case 0:\n        // Daylight with sun.\n        // One trilight with blue sky & green/brown ground.\n        // One trilght with stark sun.\n        sunMoonLight = true;\n        break;\n    case 1:\n        // Moonlit night.\n        // One trilight with moonlight & cinematic blue backlight.\n        skyCol0 = vec3(0.1,0.1,0.1);\n        skyCol1 = vec3(0.0,0.0,0.0);\n        groundCol0 = vec3(0.1,0.1,0.2);\n        groundCol1 = vec3(0.0,0.0,0.0);\n        sunMoonColour = vec3(0.8,0.8,0.8);\n        sunMoonFillColour = vec3(0.0,0.0,0.5); // dramatic blue fill-in for night.\n        sunMoonLight = true;\n        break;\n    case 2:\n        {\n        // A radius light moving around.\n        sunMoonLight = false;\n        blobLightEnable = true;\n            \n        float closestDist = 2.0 * (1.0+sin(20.0*animFrac));\n        sphLightPos = sphere[SphLight].radius + sphere[SphMain].radius + closestDist;\n        sphere[SphLight].center.x = sphLightPos;\n        \n        #if 0 \n\t        // This becomes 1.0 at distance zero, but at long range becomes the standard 1/dist^2\n\t        float intensity = 1.0/(1.0 + sphere[SphLight].radius*closestDist + closestDist*closestDist);\n        #else\n            // Cem Yuksel's version, although without the constant term in front, because this\n            // is not a physically-correct lighting pipeline.\n            float r = sphere[SphLight].radius;\n            float d = closestDist;\n            float intensity = 1.0 - (d / sqrt(d*d+r*r));\n        #endif\n        // Also becomes 1.0 at distance zero, but drops off quickly at range.\n        float wraparound = 1.0/(1.0 + sphere[SphLight].radius*closestDist);\n        \n    \tblobLightVec  = normalize(sphere[SphLight].center);\n     \tblobLightCol0 = intensity * blobLightColour;\n     \tblobLightCol1 = intensity * wraparound * blobLightColour;\n     \tblobLightCol2 = vec3(0.0,0.0,0.0);\n        }\n        break;\n    }\n    \n    // Fade the sun/moon out as it sets below the horizon.\n    float sunMoonFade = clamp(2.0*(sunMoonVec.y+0.2),0.0,1.0);\n    sunMoonColour *= sunMoonFade;\n    \n    vec3 rayOrigin = viewPos;\n    vec3 rayDirn = viewDirn;\n    float nearZ = 1e30;\n    int sphereHit = -1;\n    vec3 sphereNorm = vec3(0.0,0.0,1.0);\n    for ( int sphereNum = 0; sphereNum < 3; sphereNum++ )\n    {\n        vec3 sphereCenter = sphere[sphereNum].center;\n        float sphereRadius = sphere[sphereNum].radius;\n        \n        if ( sphereNum == SphLight )\n        {\n            // This appears to work around an aliasing bug.\n            sphereCenter.x = sphLightPos;\n        }\n        \n        vec3 offset = rayOrigin - sphereCenter;\n        \n        // p = offset + l * dirn;\n        // p.p = r^2;\n        //     = offset.offset + 2 * l * (dirn.offset) + l^2 * dirn.dirn;\n        // So quadratic in l:\n        \n        float a = dot(rayDirn,rayDirn);\n        float b = 2.0*dot(rayDirn,offset);\n        float c = dot(offset,offset) - sphereRadius * sphereRadius;\n        // ...and we don't care baout precision, so use the not-very-good version.\n        \n        float bsqm4ac = b*b - 4.0 * a * c;\n        if ( bsqm4ac > 0.0 )\n        {\n            float z = (-b - sqrt(bsqm4ac))/(2.0*a);\n            \n            // Find the intersection point in the sphere's coordinate system.\n            vec3 pos = offset + z * rayDirn;\n            vec3 norm = normalize(pos);\n            \n            if ( (sphereNum == SphLight) && !blobLightEnable )\n            {\n                z = -100.0;\n            }\n           \n            if ( (z > 0.0 ) && ( z < nearZ ) )\n            {\n                \n                nearZ = z;\n                sphereHit = sphereNum;\n                sphereNorm = norm;\n            }\n        }\n    }\n    \n    // We now know which sphere we hit, so light it.\n    vec3 colour = vec3 (1.0,0.0,1.0);\n    \n    // Some surface texture to help orient people.\n    float texture = 0.5+0.2*(abs(sphereNorm.x)+abs(sphereNorm.y)+abs(sphereNorm.z));\n    texture *= texture * texture * 2.0;\n    texture = clamp(texture,0.0,1.0);\n    \n    switch ( sphereHit )\n    {\n    case SphMain:\n    {\n        vec3 albedo = vec3(1.0,1.0,1.0);\n        // And now the actual lighting algorithm itself. Codeword BANANA\n        //\n        //\n        //  All this support code is just to show you this one bit of lighting code!\n        //\n        //\n\t    vec3 midCol = 0.5*(skyCol0+groundCol0);\n        vec3 lighting = 0.5 * Trilight ( vec3 ( 0.0, 1.0, 0.0 ), sphereNorm, skyCol1, midCol, groundCol1 );\n        if ( sunMoonLight )\n        {\n        \tlighting += Trilight ( sunMoonVec, sphereNorm, sunMoonColour, vec3(0.0,0.0,0.0), sunMoonFillColour );\n        }\n        if ( blobLightEnable )\n        {\n        \tlighting += Trilight ( blobLightVec, sphereNorm, blobLightCol0, blobLightCol1, blobLightCol2 );\n        }\n        colour = lighting * albedo;\n        //\n        //\n        //  There wasn't that simple?\n        //\n        //\n        \n    } break;\n    case SphLight:\n        colour = blobLightColour;\n        break;\n    default:\n        sphereNorm = viewDirn;\n        // ...fallthrough.\n    case SphSky:\n        if ( sphereNorm.y > 0.0f )\n        {\n            // Sky\n            colour = skyCol0 * (1.0-sphereNorm.y) + skyCol1 * sphereNorm.y;\n            // And a sun-blob.\n            if ( sunMoonLight )\n            {\n                float sunDot = dot(sphereNorm,sunMoonVec);\n                float sunShade = 400.0 * (sunDot - (1.0-sunMoonSize));\n                if ( sunShade > 0.0 )\n                {\n                    colour += clamp(sunShade,0.0,1.0) * sunMoonColour;\n                }\n            }\n        }\n        else\n        {\n            // Ground.\n            colour = groundCol0 * (1.0+sphereNorm.y) + groundCol1 * -sphereNorm.y;\n        }\n\t\tbreak;\n    }\n    \n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}