{"ver":"0.1","info":{"id":"ssjGWV","date":"1618749997","viewed":52,"name":"Cherepanova_325","username":"hatifNat","description":"homework","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv)/float(iFrame +1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EMISSION 0x00000000u\n#define DIFFUSE 0x00000001u\n#define REFLECTION 0x00000002u\n#define REFRACTION 0x00000003u\n\nconst float INF = 1e10;\n\nconst vec3 CAMERA_POS =vec3(0.0, 0.5, -6);\nvec3 randDir;\nvec3 randVals;\n\nconst int STEPS = 10;\n\nconst float PI = 3.14159265358979323846;\n\nconst float AIR_N = 1.0;\nconst float GLASS_N = 1.5;\n\nfloat GLASS_R = (AIR_N - GLASS_N)* (AIR_N - GLASS_N) / ((AIR_N + GLASS_N)* (AIR_N + GLASS_N));\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float lum;\n};\n\nstruct Current {\n\n    float minDist;\n    uint material;\n    vec3 color;\n    vec3 normal;\n    vec3 pos;\n    vec3 dir;\n    float nFrom;\n    float nEnter;\n    \n};\n\nstruct Cylinder {\n    vec3 pos;\n    float radius;\n};\n\nstruct Sphere {\n    float radius;\n    vec3 pos;\n};\n\nconst uint LIGHTS_COUNT = 4u;\nLight LIGHTS[LIGHTS_COUNT];\n\n\nCylinder cylinder;\n\nSphere sphere;\n\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal)\n{\n    float t = (-1.2 - pos.y )/dir.y;\n    \n    if (t <=0.0) {\n    \n        return INF;\n    } \n    \n    vec3 worldPos = t * dir + pos;\n        \n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) \n    {\n            return INF;\n    }\n    normal = normalize(vec3(0, 1, 0) + (texture(iChannel0, worldPos.xz * 0.3).rgb * 2.0 - 1.0)* 0.7);\n    \n    return t;\n}\n\nvoid tryPlane(out Current now)\n{\n    vec3 planeNorm;\n    float planeT = tracePlane(now.pos, now.dir, planeNorm);\n    if (planeT < now.minDist)\n    {\n        now.minDist = planeT;\n        now.material = DIFFUSE;\n        vec3 worldPos = now.minDist * now.dir + now.pos;\n        now.color = texture(iChannel0, worldPos.xz * 0.3).rgb;\n        now.normal = planeNorm;\n        if (randVals.y < 0.3)\n        {\n            now.material = REFLECTION;\n        }\n    }\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal)\n{\n    // dot(pos + t*dir, pos + t* dir) == r*r\n    // dot(pos, pos) + 2*t*dot(pos, dir) + t*t*dot(dir, dir) == r*r\n    // t*t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r*r = 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nvoid tryLight(Light light, out Current now)\n{\n    vec3 lNorm;\n    float lightT = traceSphere(now.pos - light.pos, now.dir, light.radius, lNorm);\n        \n    if (lightT < now.minDist)\n    {\n        now.minDist = lightT;\n        now.material = EMISSION;\n        now.color = light.color;\n        now.normal = lNorm;\n    }\n}\n\nvoid trySphere(Sphere sphere, out Current now)\n{\n    vec3 sphNorm;\n    float sphT = traceSphere(now.pos - sphere.pos, now.dir, sphere.radius, sphNorm);\n    if (sphT < now.minDist)\n    {\n        now.minDist = sphT;\n        now.normal = sphNorm;\n        if (randVals.x * 0.1 < GLASS_R)\n        {\n            now.material = REFLECTION;\n        } else \n        {\n            now.material = REFRACTION;\n            if (dot(now.dir, now.normal) > 0.0)\n            {\n                now.nEnter = AIR_N;\n            } else\n            {\n                now.nEnter = GLASS_N;\n            }\n\n        }\n    }\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, Cylinder cylinder, out vec3 normal)\n{\n    float cylT = (cylinder.pos.y - pos.y) / dir.y;\n    vec3 finalPos = pos + dir * cylT;\n    if (dot(finalPos.xz, finalPos.xz) < pow2(cylinder.radius)) {\n        normal = vec3(0, 1, 0);\n    } else {\n        cylT = INF;\n    }\n    if (cylT < 0.0) {\n        cylT = INF;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - pow2(cylinder.radius)) * a;\n    if (D < 0.0) {\n        return cylT;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if ((pos.y + t * dir.y < cylinder.pos.y) && (t > 0.0) && (t < cylT)) {\n        vec3 worldPos = pos + t * dir;\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    t = (-b + sqrt(D)) / a;\n    if ((pos.y + t * dir.y < cylinder.pos.y) && (t > 0.0) && (t < cylT)) {\n        vec3 worldPos = pos + t * dir;\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return cylT;\n}\n\nvoid tryCylinder(Cylinder cylinder, out Current now)\n{\n    vec3 cNorm;\n    float cylinderT = traceCylinder(now.pos  , now.dir, cylinder, cNorm);\n        \n    if (cylinderT < now.minDist)\n    {\n        now.minDist = cylinderT;\n        now.material = DIFFUSE;\n        if (randVals.y * 5.0 < 0.3)\n        {\n            now.material = REFLECTION;\n        }\n        vec3 worldPos = now.minDist * now.dir + now.pos;\n        now.color = texture(iChannel2, worldPos.xz *  worldPos.y).rgb;\n        now.normal = cNorm;\n    }\n}\n\nbool isOccluded(vec3 pos, vec3 target)\n{\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 sphNorm;\n    float sphT = traceSphere(pos - sphere.pos, dir, sphere.radius, sphNorm);\n    if (sphT < dist)\n    {\n        return true;\n    }\n    \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos  , dir, cylinder, cylNorm);\n\n    return (cylT < dist);\n}\n\n//освещение по Ламберту\nvec3 computeLight(vec3 pos, vec3 color,  vec3 normal)\n{\n    vec3 sum = vec3(0);\n    \n    for (uint i = 0u; i < LIGHTS_COUNT; ++i)\n    {\n        vec3 toLight = LIGHTS[i].pos - pos;\n        float distSq = dot(toLight, toLight);\n        float att = isOccluded(pos, LIGHTS[i].pos + randDir * LIGHTS[i].radius) ? 0.0 : LIGHTS[i].lum /distSq;\n        sum += max(0.0, dot(normal, normalize(toLight))) * att * LIGHTS[i].color;\n    }\n    \n    return color * sum + texture(iChannel1, normal).rgb * 0.1;\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2)\n{\n    if (dot(v, normal) < 0.0)\n    {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA*cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB*tang + cosB * normal;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432)))*43758.5453);\n}\n\n\nvec3 moveTexture(vec3 v, float angle, vec3 offset) {\n    vec4 v2 = vec4(v, 1.0);\n    float angle2 = angle * PI / 180.0;\n    mat4 rotMatrix = mat4( cos(angle2), 0, sin(angle2), 0,\n                           0,           1, 0,           0,\n                          -sin(angle2), 0, cos(angle2), 0,\n                           0,           0, 0,           1);\n    v2 = v2 * rotMatrix;\n    return vec3(v2.x, v2.y, v2.z) + offset;\n}\n\n\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.65;\n}\n\nfloat BeerLambert(float absorption, float distanceTraveled)\n{\n    return exp(-absorption * distanceTraveled);\n}\n\nvec3 minecraft (in vec2 fragCoord);\n\nvec4 sampleFog(vec3 pos, vec3 dir, in vec2 uv)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float absorption = 60.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            \n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.1).x\n            + texture(iChannel3, curPos * 0.3).x\n            + texture(iChannel3, curPos * 1.7).x\n            ) * 0.33 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    vec3 color = minecraft(uv);\n    return vec4(color * totalAbs, 1.0 - opacity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //white\n    LIGHTS[0].pos = vec3(-3, 0.7, 5);\n    LIGHTS[0].color = vec3(1, 1, 1);\n    LIGHTS[0].radius = 0.25;\n    LIGHTS[0].lum = 12.0;\n    //pink\n    LIGHTS[1].pos = vec3(2, 0.3, -1);\n    LIGHTS[1].color = vec3(255, 20, 147) /255.0;\n    LIGHTS[1].radius = 0.25;\n    LIGHTS[1].lum = 5.0;\n    //blue\n    LIGHTS[2].pos = vec3(-2, 0.3, -0.8);\n    LIGHTS[2].color = vec3(25, 70, 170)/ 255.0;\n    LIGHTS[2].radius = 0.2;\n    LIGHTS[2].lum = 7.0;\n    // yellow    \n    LIGHTS[3].pos = vec3(1.7, 0.8, 1.5);\n    LIGHTS[3].color = vec3(240, 230, 140) / 255.0;\n    LIGHTS[3].radius = 0.1;\n    LIGHTS[3].lum = 10.0;\n    \n    sphere.radius = 1.0;\n    sphere.pos = vec3(0, 0, 0);\n    \n    cylinder.pos = sphere.pos;\n    cylinder.pos.y -= sphere.radius;\n    cylinder.radius = 0.7;\n\n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n   \n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)* 2.0) /iResolution.x;\n    \n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    \n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    float colorMult = 1.0;\n    \n    Current now;\n    now.pos = CAMERA_POS;\n    now.dir = viewVec;\n    now.nFrom = AIR_N;\n    \n    for (int i = 0 ; i < STEPS; i++)\n    {\n        \n        now.minDist = INF;\n        now.color = vec3(1.);\n        now.normal = vec3(0.);\n        now.nEnter = AIR_N;\n        \n        tryPlane(now);\n        \n        for (uint i = 0u; i < LIGHTS_COUNT; ++i)\n        {\n            tryLight(LIGHTS[i], now);\n        }\n        \n        \n        tryCylinder(cylinder, now);\n        \n        \n        trySphere(sphere, now);\n        \n        if (now.minDist != INF)\n        {\n            vec3 worldPos = now.minDist * now.dir + now.pos;\n            if (now.material == EMISSION)\n            {\n                fragColor.rgb = now.color * colorMult;\n                break;\n            }\n            else if (now.material == DIFFUSE)\n            {\n                fragColor.rgb = mix(fragColor.rgb, computeLight(worldPos, now.color, now.normal), colorMult);\n            }\n            else if (now.material == REFLECTION)\n            {\n                now.dir = reflect(now.dir, now.normal);\n                now.pos = worldPos + now.dir * 1e-5;\n                \n                now.nFrom = now.nEnter;\n                \n            } \n            else if (now.material == REFRACTION)\n            {\n                now.pos = worldPos + now.dir * 1e-5;\n                now.dir = refraction(normalize(now.dir), normalize(now.normal), now.nFrom, now.nEnter);\n                \n                vec4 fog = sampleFog(now.pos, now.dir, fragCoord);\n                fragColor.rgb = mix(fragColor.rgb, fog.rgb, fog.a);\n                colorMult *= 1.0 - fog.a;\n                \n                now.nFrom = now.nEnter;\n                \n            }\n        }\n        else \n        {\n            vec3 textureDir = moveTexture(now.dir, 80.0, vec3(0.0, 0.07, 0.0));\n            fragColor.rgb += texture(iChannel1, textureDir).rgb * 0.5 * colorMult;\n            \n            break;\n        }\n    }\n    \n    \n}\n\n\n// Minecraft. Created by Reinder Nijhoff 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4ds3WS\n//\n// port of javascript minecraft: http://jsfiddle.net/uzMPU/\n// original code by Markus Persson: https://twitter.com/notch/status/275331530040160256\n// combined with voxel-shader by inigo quilez (https://www.shadertoy.com/view/4dfGzs)\n//\n\n#define SEALEVEL -25.\n#define MAXSTEPS 180 \n//#define HOUSE\n\nfloat Time = 176.99;\n\nvec3 sundir = normalize( vec3(-0.5,0.6,0.7) );\n\nfloat hash( in float n ) {\n    return fract(sin(n)*43758.5453);\n}\nfloat hash( in vec3 x ) {\n\tfloat n = dot( x, vec3(1.0,113.0,257.0) );\n    return fract(sin(n)*43758.5453);\n}\nvec3 hash3( vec3 n ) {\n\treturn fract(sin(n)*vec3(653.5453123,4456.14123,165.340423));\n}\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\n}\nfloat sum(vec3 v) { return dot(v, vec3(1.0)); }\n\n// port of minecraft\n\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t// 16x16 tex\n\tvec2 uv = floor( coord );\n\n    float n = uv.x + uv.y*347.0 + 4321.0 * float(i);\n\tfloat h = hash(n);\n\t\t\n    float br = 1. - h * (96./255.);\n\tcolor = vec3( 150./255., 108./255.,  74./255.); // 0x966C4A;\n\t\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\t\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 18.)) {\n\t\t\tcolor = vec3( 106./255., 170./255.,  64./255.); // 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 19.)) {\n\t\t\tbr = br * (2. / 3.);\n\t\t}\n\t}\n\tif (i == 4) {\n\t\tcolor = vec3( 127./255., 127./255., 127./255.); // 0x7F7F7F;\n\t}\t\n\tif (i == 7) {\n\t\tcolor = vec3( 103./255., 82./255.,  49./255.); // 0x675231;\n\t\tif ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\t\n\t}\t\n#ifdef HOUSE\n\tif (i == 5) {\n\t\tcolor = vec3( 181./255.,  58./255.,  21./255.); // 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\tcolor = vec3( 188./255., 175./255., 165./255.); // 0xBCAFA5;\n\t\t}\n\t}\n#endif\n\tif (i == 9) {\n\t\tcolor = vec3(  64./255.,  64./255., 255./255.); // 0x4040ff;\n\t}\t\n\tif (i == 8) {\n\t\tcolor = vec3(  80./255., 217./255.,  55./255.); // 0x50D937;\n\t\tif ( h < 0.5) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (i == 10) {\n\t\tcolor = vec3(0.65,0.68,0.7)*1.35; \n\t\tbr = 1.;\n\t}\n\tcolor *= br;\n\t\n\treturn true;\n}\n\n//=====================================================================\n// Code by inigo quilez - iq/2013:\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat mapTerrain( vec2 p ) {\n\tp *= 0.02;\n\n\tfloat f;\n    f  = 0.500*textureLod( iChannel0, p*0.01, 0. ).x;\n    f += 0.1250*noise( p*4.01 );\n\treturn  max( 50.0*f-30., SEALEVEL);\n}\n\nvec3 gro = vec3(0.0);\n\nbool map(in vec3 c ) {\n\tvec3 p = c + 0.5;\n    \n\tfloat f = mapTerrain( p.xz );\n\n\tvec2 fc = floor( c.xz * 0.05 );\n\tvec3 h = hash3( vec3( fc*vec2(213.123,2134.125), mapTerrain(fc) ) );\t\n\tbool hit = false;\n\t\n\tif( h.z > 0.75 ) {\n\t\tvec2 tp = floor(fc*20.+mod(h.yx*154.43125, 10.)) + 5.5;\n\t\tfloat h = mapTerrain( tp );\n\t\tif( h > SEALEVEL ) {\t\t\n\t\t\tif( all( equal( tp, p.xz ) ) ) hit = c.y < h+4.; // treetrunk\n\t\t\tif( distance( p, vec3( tp.x, h+6., tp.y ) ) < 2.5 ) hit = true; // leaves\n\t\t} \n\t}\n\t\n\thit = c.y < f ? true:hit; // ground\n\t\n\tif( c.y > 8. && \n\t   sin( (c.y-8.)*(3.1415/32.)) * (10./(c.y-7.)) * noise( c*0.08+(0.7*Time)*vec3(0.3, 0.07, 0.12) ) \n\t   > 0.6 ) hit = true; // clouds\n\n#ifdef HOUSE\n\tvec2 hc = abs(c.xz - vec2( 32., 130.)); // house\n\tif( all( lessThan( hc, vec2( 6., 10. ) ) ) && c.y < -hc.x-12. ) {\n\t\thit = true;\n\t\tif( all( lessThan( hc, vec2( 2., 10. ) ) ) && c.y < -18. && c.y > -23. ) {\n\t\t\thit = false;\n\t\t}\n\t\tif( all( lessThan( hc, vec2( 5., 9. ) ) ) && c.y < -18. && c.y > -23. ) {\n\t\t\thit = false;\n\t\t}\n\t}\n#endif\n\t\n\tif( distance( gro, c ) < 1.5 ) return false;\n\t\n\treturn hit;\n}\n\n\nint mapMaterial(in vec3 c ) {\n\tint mat = 0;\n\tvec3 p = c + 0.5;\n    \n\tfloat f = ceil( mapTerrain( p.xz ) ); \n\t\n\tif( p.y <= f ) mat = 1; // ground\n\telse if( p.y < f+3. ) mat = 7; // treetrunk\n\telse if( p.y < f+10. ) mat = 8; // leaves\n\telse mat = 10; // clouds\n\t\n#ifdef HOUSE\n\tvec2 hc = abs(c.xz - vec2( 32., 130.));\n\tif( c.y < 0. && all( lessThan( hc, vec2( 6., 10. ) ) ) ) {\n\t\tmat = 5;\n\t\tif( !map( c+vec3(0.,1.,0.) ) ) mat = 6;\n\t}\n#endif\n\t\n\treturn mat;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ ) \n\t{\n\t\tif( hit ) break;\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t\tif( map(pos) ) { hit = true;}\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn hit?t:0.;\n\n}\n\nfloat castVRay( in vec3 ro, in vec3 rd, in float maxDist ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 1.0;\n\t\n\tfor( int i=0; i<18; i++ ) \n\t{\n\t\tif( map(pos) ) {res=0.0; break; }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\t\n\treturn res;\n}\n\nvec3 path( float t ) {\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, mapTerrain(p)+2.+4.*(1.-cos(Time*0.1)), p.y );\n}\n\n\n//=====================================================================\n// Ambient occlusion \n\nvec4 edges( in vec3 vos, in vec3 nor, in vec3 dir )\n{\n\tvec3 v1 = vos + nor + dir.yzx;\n\tvec3 v2 = vos + nor - dir.yzx;\n\tvec3 v3 = vos + nor + dir.zxy;\n\tvec3 v4 = vos + nor - dir.zxy;\n\n\tvec4 res = vec4(0.0);\n\tif( map(v1) ) res.x = 1.0;\n\tif( map(v2) ) res.y = 1.0;\n\tif( map(v3) ) res.z = 1.0;\n\tif( map(v4) ) res.w = 1.0;\n\n\treturn res;\n}\n\nvec4 corners( in vec3 vos, in vec3 nor, in vec3 dir )\n{\n\tvec3 v1 = vos + nor + dir.yzx + dir.zxy;\n\tvec3 v2 = vos + nor - dir.yzx + dir.zxy;\n\tvec3 v3 = vos + nor - dir.yzx - dir.zxy;\n\tvec3 v4 = vos + nor + dir.yzx - dir.zxy;\n\n\tvec4 res = vec4(0.0);\n\tif( map(v1) ) res.x = 1.0;\n\tif( map(v2) ) res.y = 1.0;\n\tif( map(v3) ) res.z = 1.0;\n\tif( map(v4) ) res.w = 1.0;\n\n\treturn res;\n}\n\n\nvec3 minecraft(in vec2 fragCoord ) {\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*Time + 50.0*mo.x;\n    // camera\n\t\n\tfloat cr = 0.2*cos(0.1*Time);\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+4. );\n\tta.y = ro.y;\n\tgro = ro;\n\t\n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\t\n\tif( t>0.0 ) {\n\t\tvec3 nor = -dir*sign(rd);\n\t\t\n\t\tvec3 pos = ro + rd*t;\n\t\tint mMat = mapMaterial( vos );\t\t\t\n\t\tvec3 mpos = mod( pos * 16., 16. );\n\t\t\n\t\tif( mMat == 1 ) {\n\t\t\tif( map( vos + vec3(0., 1., 0. ) ) ) {\n\t\t\t\tmMat = hash(vos) > 0.5?2:4; \n\t\t\t\tif( map( vos + vec3(0., 2., 0. ) ) ) mMat = 4;\n\t\t\t}\n\t\t\tif ( vos.y < SEALEVEL ) mMat = 9;\t\n\t\t} \n\t\t\n\t\tvec3 mCol;\n\t\tgetMaterialColor( mMat, nor.y!=0.?mpos.xz:nor.x!=0.?-mpos.zy+vec2(32.,32.):-mpos.xy+vec2(32.,32.),mCol );\n\t\t\n\t\t// lighting\n\t\tfloat dif = clamp( dot( nor, sundir ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( dif>0.01) sha=castVRay(pos+nor*0.01,sundir,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n\t\tfloat amb = 1.0;//clamp(0.75 + pos.y/100.0,0.0,1.0);\n\t\t\t\n        // ambient occlusion\n\t\t\n        vec4 ed = edges( vos, nor, dir );\n        vec4 co = corners( vos, nor, dir );\n        vec3 uvw = pos - vos;\n        vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\n        float occ = 0.0; \n        // (for edges)\n        occ += (    uv.x) * ed.x;\n        occ += (1.0-uv.x) * ed.y;\n        occ += (    uv.y) * ed.z;\n        occ += (1.0-uv.y) * ed.w;\n        // (for corners)\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n\t\t\n\t\t\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 4.0*dif*vec3(1.)*(0.5+0.5*occ)*(0.25+0.75*sha);\n\t\tlin += 1.8*bac*vec3(1.0,0.5,1.0)*(0.5+0.5*occ);\n\t\tlin += 4.0*sky*vec3(0.6,0.71,0.75)*occ;\n\t\n\t\t\n\t\tif( mMat == 10 ) {\n\t\t\tcol = mix( col, mCol*lin*0.6, 0.3);\t\t\n\t\t} else {\n\t\t\t// atmospheric\n\t\t\tcol = mix( mCol*lin*0.2, col, 1.0-exp(-0.0000001*t*t*t) );\n\t\t}\t\t\t\n\t}\n\t\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\t\n    // gamma\t\n\tcol = pow( col, vec3(0.45) );\n\t\n\t// contrast\n    col = col* 0.25 + 0.75*col*col*(3.0-2.0*col);\n\t\t\n    col = clamp( col, 0.0, 1.0 );\n\n\t// vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\treturn col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv)+ texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}