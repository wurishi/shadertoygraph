{"ver":"0.1","info":{"id":"ltsXD7","date":"1437350141","viewed":345,"name":"Wavefunctions (redux)","username":"djmkultra","description":"Renders complex-valued 2D functions, (specifically complex waves E^(ix)) as height-fields. ","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["visualization","complexwaves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define HEIGHT_FIELD 1  // Render Fxy (2D function as a height field), otherwise Fxyz volume rendering\n#define COMPONENTS 0  // Toggle between real/im components and magnitude vis.\n\nconst int kMarchSteps = 111; // Adjust this value for better quality or faster rendering.\n\nconst float near = 1.;\nconst float zoom = .002;\nconst vec3 kEye = vec3(5., 10., 10.) * 2.;\nvec3 eye = kEye;\nvec3 at = vec3(0., 0., 0.);\n\nconst vec4 backgroundColor = vec4(0.);\nconst float brightness = 2.;\n\nconst float pi = 3.14159265359;\nconst float twopi = 2. * pi;\n\nvec4 rands = vec4(0.);\n\nvec3 Tone(vec3 hdr, float scale, float base) {\n    vec3 hdrs = max(hdr, 0.) * scale;\n    return hdrs / (vec3(base) + hdrs);\n}\nvec3 Tone(vec3 hdr) { return Tone(hdr, brightness, 1.); }\nvec4 Tone(vec4 hdra) { return vec4(Tone(hdra.rgb), hdra.a); }\n\nvec4 HitXZPlane(vec3 start, vec3 dir) {\n    float t = -start.y / dir.y;\n    return vec4(start + dir * t, t);\n}\n\nvec4 HitXYPlane(vec3 start, vec3 dir) {\n    float t = -start.z / dir.z;\n    return vec4(start + dir * t, t);\n}\n\n// returns xyz pos and t value for the backside of box, neg for no hit\nvec4 HitBox(vec3 minp, vec3 maxp, vec3 start, vec3 dir) {\n \tvec3 tminp = start - minp;\n    vec3 tmaxp = start - maxp;\n    vec3 invdir = -vec3(1.) / dir;\n    tminp *= invdir;\n    tmaxp *= invdir;\n    vec3 tmin = min(tminp, tmaxp);\n    vec3 tmax = max(tminp, tmaxp);\n    float maxt = min(min(tmax.x, tmax.y), tmax.z);\n    float mint = max(max(tmin.x, tmin.y), tmin.z);\n    return vec4(start + dir * mint, maxt < mint ? -1. : (maxt - mint));\n}\n\nvec3 GetRayDir(vec2 uv) {\n\tvec3 up = vec3(0., 1., 0.);\n    vec3 vdir = normalize(at - eye);\n    vec3 xdir = normalize(cross(vdir, up));\n    up = normalize(cross(xdir, vdir));\n    vec3 center = eye + vdir * near;\n    vec2 zuv = (uv - vec2(.5)) * iResolution.xy * zoom;\n    vec3 pix = center + zuv.x * xdir + zuv.y * up;\n    return pix - eye;\n}\n\nvec4 GridColor(vec2 uv) {\n    const float linewidth = .1;\n    //float order = log\n    float tickwidth = 10.;\n \tvec2 duv = fwidth(uv);\n    float fade = clamp(1.1 - max(duv.x, duv.y) / (tickwidth * .6), 0., 1.);\n    vec2 duv2 = duv;\n    duv *= linewidth;\n    duv2 += duv;\n    vec2 ticks = smoothstep(duv2, duv, abs(mod(uv + duv2, vec2(tickwidth)) - duv2)) * fade;\n    vec2 axis = smoothstep(duv2, duv, abs(uv)) * fade;\n    float axisv = max(axis.x, axis.y);\n    vec4 color = vec4(.15, .15, .15, 1.) * max(ticks.x, ticks.y) * (1. - axisv)\n        + vec4(1., .1, .1, 1.) * axisv;\n    return color;\n}\n\nvec4 Blend(vec4 bottom, vec4 top) { return bottom * (1. - top.a) + top; }\n\nfloat ttest(float t) { return step(0., t); }\n\n// E^(i*theta*lambda + phase)\nvec2 CExp(float theta, float lambda, float phase) {\n \tfloat v = theta * lambda + phase;\n    return vec2(cos(v),sin(v));\n}\n\n// ------------------------------------------------------------\n// Complex-valued function of x and y that is the super-position of complex waves.\n\nvec2 DemoWaves(float x, float y) {\n    float theta = atan(x, y);\n \tfloat d = length(vec2(x,y));\n    float t = -iTime;\n    \n    //------------------\n    // This is the place to play with the waves, try altering their direction and phaes etc...\n    \n    // Radial waves\n    vec2 radialwave = 1. * CExp(d, 1., t);\n    radialwave += CExp(d, 2., t * 1.01) * rands.x;\n    radialwave += CExp(-d, 3., t * 1.005) * rands.y;\n    \n    // Angular waves\n    vec2 angularwave = CExp(theta, 2., t * 1.07) * rands.z;\n    angularwave += CExp(-theta, 5., -t) * rands.w;\n    \n    return 1. * radialwave + 1. * angularwave;\n}\n\nvec2 CxyWaves(float x, float y) {\n    return DemoWaves(x, y);\n}\n\n// crappy complex coloring: Real = (red-green), Imaginary = (yellow-blue)\nvec4 CColor(vec2 c, vec2 weight) {  \n    const vec4 rcolor = vec4(1., 0.01, 0.01, 1.);\n    const vec4 rcolorn = vec4(0., 1., 0.01, 1.);\n    const vec4 icolor = vec4(.9, .9, 0.01, 1.);\n    const vec4 icolorn = vec4(0.01, 0.01, 1., 1.);\n\tvec4 realcolor = (rcolor* max(c.x, 0.) + (rcolorn) * max(-c.x, 0.));\n    realcolor.a = 1.;\n    vec4 imagcolor = (icolor * max(c.y, 0.) + (icolorn) * max(-c.y, 0.));\n    imagcolor.a = 1.;\n \tvec4 color = (realcolor * weight.x + imagcolor * weight.y);\n    return color;\n}\n\n// ----------------------------------------------------\n// Height field evaluation for a (complex-valued) function of two variables\nvec4 prevval = vec4(0.);  // used to detect isosurface crossing.\nvec4 Fxy(vec3 xyz) {\n\tconst float thickness = 1.;\n    \n\t// Evaluate the function.\n \tvec2 val = CxyWaves(xyz.x, xyz.z) * vec2(1., 1.);\n    \n    // Compute color.\n#if COMPONENTS\n    // Visualize real and imaginary parts as 2 height fields\n    vec2 dif = val - xyz.yy;\n    vec2 crossing = prevval.xy * dif;\n    vec2 stepwidth = prevval.xy - dif;\n    vec4 w = abs(vec4(prevval.xy, dif) / stepwidth.xyxy);\n    //w = vec4(1., 1., 0., 0.);\n    crossing = step(0.00000001, -crossing);\n    vec4 color = CColor(val * w.xy + prevval.zw * w.zw, crossing * .5) * .8;\n    prevval = vec4(dif, val);\n#else\n    // Visualize the amplitude of the wave function.\n    float d = length(val) - xyz.y;\n    float crossing = (prevval.z * d) < 0. ? 1. : 0.;\n    vec2 w = abs(vec2(prevval.z, d) / (prevval.z - d));\n\tvec4 color = CColor(val * w.x + prevval.xy * w.y, vec2(.5));\n    prevval.xyz = vec3(val, d);\n    color = color * crossing * .8;    \n#endif\n    \n    return color;\n}\n\n// ------------------------------------------------\n// A funtion of x, y, z, returns color. Volume-render 3D function.\n\nvec4 Fxyz(vec3 xyz) {\n    const float scale = 5.;\n    const float d = 1.;\n    float dist = length(xyz);\n    float amp = 1. / (1. + dist * dist);\n\tfloat wave = sin(dist * scale + iTime);\n    vec4 c = max(0., wave) * vec4(1., .1, .1, 1.) + max(0., -wave) * vec4(.1, .1, 1., 1.);\n \treturn  vec4(c.rgb, 1.) * amp;  \n}\n\n\nvec4 March(vec3 start, vec3 dir, float maxd, float dd) {\n    vec4 ddir = vec4(dir, 1.) * dd;\n    vec4 pos = vec4(start, 0.);\n    vec4 color = vec4(0.);\n    prevval = vec4(-pos.y);\n    for (int i = 0; i < kMarchSteps; ++i) {\n        float density = 1.;\n        \n#if HEIGHT_FIELD\n        // 2D height field.\n        vec4 c = Fxy(pos.xyz);\n#else \n        // 3D function volume rendering\n        vec4 c = Fxyz(pos.xyz);\n#endif        \n        \n        // axis clipping\n        //c = pos.z > 0. ? vec4(0.) : c; \n        \n        c = (pos.w > maxd ? vec4(0.) : c); // reject samples outside box\n        c.a = clamp(c.a, 0., 1.);  // insure we have good alpha values.\n        color = color + c * (1. - color.a);  // blending\n        pos += ddir;\n    }\n    return color;\n}\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool one = ReadKey( 49, true );\n    bool two = ReadKey( 50, true );\n    bool three = ReadKey( 51, true );\n\n    float theta = iMouse.x / iResolution.x * twopi;\n    if (one) {  // 1 key toggles orbit\n        theta += iTime * .2;\n    }\n    vec2 cossin = vec2(cos(theta), sin(theta));\n    eye.x = kEye.x * cossin.x - kEye.z * cossin.y;\n    eye.z = kEye.x * cossin.y + kEye.z * cossin.x;\n\n    eye.y -= (iMouse.y > 0. ? 1. : 0.) * (iMouse.y - iResolution.y * .5) * .3;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \t\n    rands = vec4(.5) + .5 * cos(vec4(iTime) * vec4(1., -.997, 1.13, 1.21) * .5 + vec4(13., 17., 19., 23.));\n\t// 2 key toggles random coefficients.\n    rands = two ? vec4(1.) : rands;\n\trands = smoothstep(.3, .6, rands);\n    \n    vec3 ray = GetRayDir(uv);\n    float rayd = length(ray);\n    float invrayd = 1. / rayd;\n\n#if 1\n    // jittering expariment, .\n    vec4 noise = texture(iChannel0, uv / fwidth(uv) / 255.);\n    vec3 jitterStart = ray * invrayd * (.5 - noise.x) * 2.;\n    //jitterStart = mix(vec3(0.), jitterStart, (1. + sin(iTime)) * .5);\n#else\n    vec3 jitterStart = vec3(0.);     \n#endif\n    \n    // Domain grid. (not yet integrated with the sceen correctly)\n    vec4 xzplane = HitXZPlane(eye, ray);\n    vec4 xzgrid = GridColor(xzplane.xz) * ttest(xzplane.w);\n    vec4 xyplane = HitXYPlane(eye, ray);\n    vec4 xygrid = GridColor(xyplane.xy) * ttest(xyplane.w);\n    vec4 gridcolor = Blend(xzgrid * .5, xygrid * .1);\n    \n    // Set up the function domain.\n    float boxscale = 5.;\n    vec3 boxsize = vec3(3., 1., 3.) * boxscale;\n    vec4 boxhit = HitBox(-boxsize, boxsize, eye, ray);\n    \n    // Set up step size and stopping distance\n    float backlen = boxhit.w * rayd; \n   \tfloat dr =  backlen / float(kMarchSteps); //sqrt(2.) * 2. * boxscale / float(kMarchSteps);\n    \n    // March!\n    vec4 marchColor = March(boxhit.xyz + jitterStart * dr, ray * invrayd, backlen, dr) * ttest(boxhit.w);\n\n    fragColor = vec4(Blend(backgroundColor, Blend(gridcolor * 1., Tone(marchColor))));\n}","name":"","description":"","type":"image"}]}