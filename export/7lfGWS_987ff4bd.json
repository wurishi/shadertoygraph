{"ver":"0.1","info":{"id":"7lfGWS","date":"1622810254","viewed":103,"name":"Crawling Quadratics","username":"spr","description":"Raytracing with Quadratics\nExercise for https://s2021.siggraph.org/program/frontiers/ Raytracing Class","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["intersection","class3","rayshpere"],"hasliked":0,"parentid":"7ts3WN","parentname":"Class 2: Intersection:Ray/Sphere"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 1000000.0\n#define EPS 0.00001\n#define PI 3.1415920\n\nfloat seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n\n\n\n\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nmat4 Transform(in vec3 position, in float dilate_factor)\n{\n    mat4 M = mat4(dilate_factor);\n    M[3] = vec4(position, 1);\n    return M;\n}\n\nstruct Plane\n{\n    vec3 N;\n    float level;\n    mat4 M;\n    vec3 color;\n};\n\nstruct Quadratic \n{\n    mat4 Q; // Quadratic\n    mat4 M; // Model Transform\n    vec3 color;\n};\n\n\n\nQuadratic Ellipsoid(in vec3 ellipse, in mat4 M, in vec3 color)\n{\n\n    mat4 Q = mat4(1);\n    Q[0][0] = ellipse.x;\n    Q[1][1] = ellipse.y;\n    Q[2][2] = ellipse.z;\n    Q[3][3] = -1.;\n    return Quadratic(Q,inverse(M),color);\n}\n\nQuadratic Cylinder(in vec2 cylinder, in mat4 M, in vec3 color)\n{\n\n    mat4 Q = mat4(0);\n    Q[0][0] = cylinder.x;\n    Q[2][2] = cylinder.y;\n    Q[3][3] = -1.;\n    return Quadratic(Q,inverse(M),color);\n}\n\n\n\n\nfloat RayPlaneIntersect(in Ray ray, in Plane plane)\n{\n    float parallel_length = dot(ray.direction, plane.N);\n    float t = MAXX;\n    if(abs(parallel_length) > EPS)\n    {\n        t = (plane.level - dot(ray.origin, plane.N))/parallel_length;\n    }\n    return t;\n}\n\nvec3 RayPlaneColor(in Ray ray, in Plane plane, in vec3 hit)\n{\n       float angle = dot(ray.direction, plane.N);\n       return abs(angle)*plane.color;\n}\n\n\n\n\nfloat RayQuadraticIntersect(in Ray ray, in Quadratic quadratic) \n{\n// https://people.cs.clemson.edu/~dhouse/courses/405/notes/quadrics.pdf\n\n    vec4 p = vec4(ray.origin,1.);\n    vec4 u = vec4(ray.direction,0.);\n    \n    \n    vec4 Qp = quadratic.Q*p;\n    vec4 Qu = quadratic.Q*u;\n    \n    float pQp = dot(p,Qp);\n    float uQu = dot(u,Qu);\n    float uQp = dot(u,Qp);\n\n    \n    float disc = uQp*uQp - uQu * pQp;\n    float t = MAXX;\n    float s = MAXX; \n    if (disc > 0.0) \n    {\n        t = (-uQp - sqrt(disc))/uQu;\n        s = (-uQp + sqrt(disc))/uQu;\n        if (t > EPS) \n        {\n            if (s > EPS) \n            {\n                if(s < t)\n                    return s;\n            }\n            return t;\n        }\n        if (s > EPS) \n        {\n            return s;\n        }\n    }\n    return t;\n}\n\n\nvoid MoveQuadratic(inout Quadratic quadratic)\n{\n    quadratic.Q=transpose(quadratic.M)*quadratic.Q*quadratic.M;\n}\n\nvec3 QuadraticNormal(in Quadratic quadratic, in vec3 position)\n{\n    vec4 DQ = 2.*quadratic.Q* vec4(position,1);\n    vec3 normal =( inverse(transpose(quadratic.M))*DQ ).xyz;\n    return normalize(normal);\n}\n\nvec3 RayQuadricColor(in Ray ray, in Quadratic quadratic, in vec3 hit)\n{\n       vec3 normal = QuadraticNormal(quadratic, hit);\n       float angle = dot(ray.direction, normal);\n       return abs(angle)*quadratic.color;\n}\n\n\n\n\n\n\nvec3 rotate(in vec3 axis, in float angle, in vec3 v) \n{\n    return v*cos(angle) + cross(axis, v)* sin(angle) + axis*dot(axis, v)*(1.0-cos(angle));;\n}\n\nmat4 RotationMatrix(in vec3 axis, in float angle)\n{\n    mat4 rot = mat4(1.);\n    rot[0] = vec4(rotate(axis,angle,vec3(1,0,0)),0);\n    rot[1] = vec4(rotate(axis,angle,vec3(0,1,0)),0);\n    rot[2] = vec4(rotate(axis,angle,vec3(0,0,1)),0);\n    return rot;\n}\n\n\n\n\nconst int quadradic_count = 1;\nconst int light_count = 1;\nQuadratic quadratics[quadradic_count];\nLight lights[light_count];\nPlane plane;\n\nvoid makeScene() \n{    \n    \n    lights[0] = Light(vec3(0,0,0),vec3(1,1,1));\n    \n    vec3 green = vec3(0.1,0.8,0.1);\n    vec3 blue = vec3(0.1, 0.1, 0.9);\n    \n    plane = Plane(vec3(0,0,-1), 10.0, mat4(1), blue);\n    \n    // Sphere\n    quadratics[0] = Ellipsoid(vec3(1), Transform(vec3(0, 0, -6),1.15), green);\n    MoveQuadratic(quadratics[0]);\n    // Ellipsoid\n/*    quadratics[1] = Ellipsoid(vec3(0.3,0.5,1.3), Transform(vec3(-0.9, -0.4, -3),0.1), vec3(1, 1, 0.1));\n    MoveQuadratic(quadratics[1]);\n    // Cylinder\n    quadratics[2] = Cylinder(vec2(1,1), Transform(vec3(2, 0, -6),0.3), vec3(0.9, 0.1, 0.1));   \n    MoveQuadratic(quadratics[2]);\n*/\n}\n\n\n//Roach\nconst int roach_pieces_count = 8;\nstruct Roach{\n    Quadratic head;\n    Quadratic body;\n    Quadratic left_leg_front;\n    Quadratic right_leg_front;\n    Quadratic left_leg_back;\n    Quadratic right_leg_back;\n    Quadratic left_leg_mid;\n    Quadratic right_leg_mid;\n    \n    mat4 M; // Model Transform\n};\n\nconst vec3 brown_head = vec3(0.6,0.4,0.1);\nconst vec3 brown_body = vec3(0.6,0.3,0.2);\nconst vec3 brown_leg = vec3(0.4,0.25,0.2);\n\nRoach makeRoach(int f)\n{\n\n    Roach roach;\n    \n    \n    // Crawl around sphere\n    mat4 sphere_offset = Transform(vec3(0.0, 0.0,2.3),-1.);\n    mat4 crawl = RotationMatrix(normalize(vec3(1,0.2,0)), 2.5*float(f)/360.*PI);\n    \n    roach.M = Transform(vec3(0.0, 0.0, -7),0.5)*inverse(sphere_offset)*crawl*sphere_offset;\n    \n    \n    \n    \n    //Head\n    roach.head = Ellipsoid(vec3(20,40,80), roach.M*Transform(vec3(0, 0.5, 0),1.), brown_head);\n    MoveQuadratic(roach.head);\n    //Body\n    roach.body = Ellipsoid(vec3(10,4,50), roach.M*Transform(vec3(0, -0.1, 0),1.), brown_body);\n    MoveQuadratic(roach.body);\n    \n    //Legs\n    const float speed = 20.;\n    \n    //Left Front\n    vec3 leg_pos = vec3(-0.4, 0.3, 0);\n    vec3 leg_axis_rot = vec3(0.2, 1 , 0.);\n    float angle = speed*float(f)/360.*PI;\n    mat4 rotation = RotationMatrix(normalize(vec3(0,0,1)), 1.);\n    mat4 moving_rotation =inverse(Transform(vec3(0,1,0),1.))* RotationMatrix(normalize(leg_axis_rot), angle)* Transform(vec3(0,1,0),1.);\n    \n    roach.left_leg_front = Ellipsoid(vec3(100,1,100), roach.M*Transform(leg_pos,0.2)*rotation*moving_rotation, brown_leg);\n    MoveQuadratic(roach.left_leg_front);\n    \n    //Right Front\n    leg_pos = vec3(0.4, 0.3, 0);\n    leg_axis_rot = vec3(0.2, 1 , 0);\n    angle = speed*float(f)/360.*PI;\n    rotation = RotationMatrix(normalize(vec3(0,0,1)), -1.);\n    moving_rotation =inverse(Transform(vec3(0,1,0),1.))* RotationMatrix(normalize(leg_axis_rot), angle)* Transform(vec3(0,1,0),1.);\n    \n    roach.right_leg_front = Ellipsoid(vec3(100,1,100), roach.M*Transform(leg_pos,0.2)*rotation*moving_rotation, brown_leg);\n    MoveQuadratic(roach.right_leg_front);\n    \n    \n    //Left back\n    leg_pos = vec3(-0.4, -0.4, 0);\n    leg_axis_rot = vec3(0.2, 1 , 0);\n    angle = speed*float(f)/360.*PI;\n    rotation = RotationMatrix(normalize(vec3(0,0,1)), 2.);\n    moving_rotation =inverse(Transform(vec3(0,1,0),1.))* RotationMatrix(normalize(leg_axis_rot), angle)* Transform(vec3(0,1,0),1.);\n    \n    roach.left_leg_back = Ellipsoid(vec3(100,1,100), roach.M*Transform(leg_pos,0.2)*rotation*moving_rotation, brown_leg);\n    MoveQuadratic(roach.left_leg_back);\n    \n    //Right back\n    leg_pos = vec3(0.4, -0.4, 0);\n    leg_axis_rot = vec3(0.2, 1 , 0);\n    angle = speed*float(f)/360.*PI;\n    rotation = RotationMatrix(normalize(vec3(0,0,1)), -2.);\n    moving_rotation =inverse(Transform(vec3(0,1,0),1.))* RotationMatrix(normalize(leg_axis_rot), angle)* Transform(vec3(0,1,0),1.);\n    \n    roach.right_leg_back = Ellipsoid(vec3(100,1,100), roach.M*Transform(leg_pos,0.2)*rotation*moving_rotation, brown_leg);\n    MoveQuadratic(roach.right_leg_back);\n    \n    //Left mid\n    leg_pos = vec3(-0.4, -0.1, 0);\n    leg_axis_rot = vec3(0.2, 1 , 0);\n    angle = speed*float(f)/360.*PI;\n    rotation = RotationMatrix(normalize(vec3(0,0,1)), 1.5);\n    moving_rotation =inverse(Transform(vec3(0,1,0),1.))* RotationMatrix(normalize(leg_axis_rot), angle)* Transform(vec3(0,1,0),1.);\n    \n    roach.left_leg_mid = Ellipsoid(vec3(100,1,100), roach.M*Transform(leg_pos,0.2)*rotation*moving_rotation, brown_leg);\n    MoveQuadratic(roach.left_leg_mid);\n    \n    //Right mid\n    leg_pos = vec3(0.4, -0.1, 0);\n    leg_axis_rot = vec3(0.2, 1 , 0);\n    angle = speed*float(f)/360.*PI;\n    rotation = RotationMatrix(normalize(vec3(0,0,1)), -1.5);\n    moving_rotation =inverse(Transform(vec3(0,1,0),1.))* RotationMatrix(normalize(leg_axis_rot), angle)* Transform(vec3(0,1,0),1.);\n    \n    roach.right_leg_mid = Ellipsoid(vec3(100,1,100), roach.M*Transform(leg_pos,0.2)*rotation*moving_rotation, brown_leg);\n    MoveQuadratic(roach.right_leg_mid);\n    \n    return roach;\n}\n\nQuadratic getBodyPart(Roach roach, in int i)\n{\n    if(i==0) return roach.head;\n    else if(i==1) return roach.body;\n    else if(i==2) return roach.left_leg_front;\n    else if(i==3) return roach.right_leg_front;\n    else if(i==4) return roach.left_leg_back;\n    else if(i==5) return roach.right_leg_back;\n    else if(i==6) return roach.left_leg_mid;\n    else if(i==7) return roach.right_leg_mid;\n}\n\n\n\n\n\n\nint numSamples = 2;\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   makeScene();\n   Roach roach = makeRoach(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       Ray ray = Ray(rayOrigin, rayDirection);\n       \n       \n       float t_min = MAXX;\n       int closest_object = -2;\n       \n       //Hit Plane\n       float t = RayPlaneIntersect(ray, plane);\n       if (t < t_min) {\n           t_min = t;\n           closest_object = -1;\n       }\n       \n       //Hit Quadratics\n       for(int i = 0; i<quadradic_count; ++i){\n           float t = RayQuadraticIntersect(ray, quadratics[i]);\n           if (t < t_min) {\n              t_min = t;\n              closest_object = i;\n           }\n       }\n       \n       //Hit Roach\n       for(int i = 0; i<roach_pieces_count; ++i){\n           float t = RayQuadraticIntersect(ray, getBodyPart(roach,i) );\n           if (t < t_min) {\n              t_min = t;\n              closest_object = i+quadradic_count;\n           }\n       }\n       \n       // Draw closest object\n       if(t_min < MAXX)\n       {\n           vec3 hit = ray.origin + t_min*ray.direction;\n           \n           \n           if(closest_object == -1)  samp += RayPlaneColor(ray, plane, hit);\n           else if(closest_object < quadradic_count)  samp += RayQuadricColor(ray, quadratics[closest_object], hit); \n           else if(closest_object < quadradic_count+roach_pieces_count)  samp += RayQuadricColor(ray, getBodyPart(roach,closest_object-quadradic_count), hit);\n       }\n       \n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}