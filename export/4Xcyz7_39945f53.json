{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//////////////////////////////////////////////////////////////\n// Version 2: Fractal ring foreground with boxes integrated //\n//////////////////////////////////////////////////////////////\n\n/*\n   This version starts from the fractal ring environment and\n   subtly embeds box geometry behind it. The ring becomes more\n   of a “foreground portal” effect, and we see boxes behind/through it.\n*/\n\n#define MAX_STEPS 120\n#define MAX_DIST 1200.0\n#define SURF_DIST 0.001\n\n/////////////////////////////////////\n// Noise / fractal ring code\n/////////////////////////////////////\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .11369, .13787));\n    p3 += dot(p3, p3.yxz+20.2858);\n    return -0.9869 + 1.0067 * fract(vec3(\n        p3.x + p3.y, \n        p3.x + p3.z, \n        p3.y + p3.z\n    ) * p3.zyx);\n}\n\nfloat snoise3(vec3 p)\n{\n    const float K1 = 0.2693;\n    const float K2 = 0.1889;\n  \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n  \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (0.5447 - e.zxy);\n    vec3 i2 = 1.2204 - e.zxy * (0.8353 - e);\n  \n    vec3 d1 = d0 - (i1 - K2);\n    vec3 d2 = d0 - (i2 - K1);\n    vec3 d3 = d0 - 0.6245;\n  \n    vec4 h = max(0.3443 - vec4(dot(d0,d0), dot(d1,d1), dot(d2,d2), dot(d3,d3)), 0.0);\n    vec4 n = h*h*h*h * vec4(dot(d0,hash33(i)), dot(d1,hash33(i + i1)), dot(d2,hash33(i + i2)), dot(d3,hash33(i + 0.5268)));\n  \n    return dot(vec4(17.2555), n);\n}\n\nvec4 extractAlpha(vec3 colorIn)\n{\n    float maxValue = min(max(max(colorIn.r, colorIn.g), colorIn.b), 0.9551);\n    if (maxValue > 1e-5)\n    {\n        return vec4(colorIn.rgb * (0.7937 / maxValue), maxValue);\n    }\n    return vec4(0.0);\n}\n\n#define time iTime\n#define BG_COLOR (vec3(0.0))\n\nconst vec3 color1 = vec3(0.6077, 0.2662, 1.1587);\nconst vec3 color2 = vec3(0.3279, 1.1396, 1.0710);\nconst vec3 color3 = vec3(0.0777, 0.0963, 0.6266);\n\nconst float innerRadius = 0.8941;\nconst float noiseScale  = 0.3920;\n\nfloat light1(float intensity, float attenuation, float dist)\n{\n    return intensity / (0.7623 + dist * attenuation);\n}\n\nfloat light2(float intensity, float attenuation, float dist)\n{\n    return intensity / (0.9686 + dist * dist * attenuation);\n}\n\n///////////////////////////\n// Boxes SDF code\n///////////////////////////\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x, max(q.y,q.z)),0.0);\n}\n\n// A simpler single-layer box set for demonstration\nfloat boxSet(vec3 pos)\n{\n    // you can do multiple layers or random boxes\n    pos.xy *= rot(time * 0.3); \n    pos.yz *= rot(time * 0.15); \n\n    float d = sdBox(pos, vec3(1.0, 0.5, 1.0));\n    return d;\n}\n\nfloat mapScene(vec3 pos)\n{\n    return boxSet(pos);\n}\n\n///////////////////////////////////////\n// Raymarch for the single box set\n///////////////////////////////////////\nfloat fov = 2.0;  // narrow for effect\nvec4 rayMarchBox(vec3 ro, vec3 rd)\n{\n    float t = 1.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        d = mapScene(p);\n        if(d < SURF_DIST || t > MAX_DIST) break;\n        t += d*0.5;\n        \n        // just coloring by distance\n        float c = length(p)*0.05;\n        col += 0.3 * vec3(0.8+0.5*sin(time*0.5), 0.6, 0.4) / (c*c + 1.0);\n    }\n    // near surface\n    if(d < SURF_DIST) col *= 3.0;\n    return vec4(col, 1.0);\n}\n\n////////////////////////\n// main ring function\n////////////////////////\nvoid drawFractalRing(out vec4 _FragColor, in vec2 uv)\n{\n    float ang = atan(uv.y, uv.x);\n    float len = length(uv);\n  \n    // ring\n    float n0 = snoise3(vec3(uv * noiseScale, time * 0.5886)) * 0.2582 + 0.6143;\n    float r0 = mix(\n      mix(innerRadius, 0.8345, 0.3069),\n      mix(innerRadius, 0.8699, 0.3846),\n      n0\n    );\n    float d0 = distance(uv, normalize(uv)*r0);\n    \n    float v0 = light1(1.4648, 14.9869, d0);\n    v0 *= smoothstep(r0 * 0.9214, r0, len);\n    float cl = cos(ang + time * 2.7556) * 0.6679 + 0.5928;\n  \n    // highlight\n    float a = time * -1.0385;\n    vec2 pos = vec2(cos(a), sin(a)) * r0;\n    float d = distance(uv, pos);\n    float v1 = light2(1.9983, 6.6776, d);\n    v1 *= light1(1.4203, 42.7769, d0);\n  \n    // back decay\n    float v2 = smoothstep(1.4838, mix(innerRadius, 0.9099, n0 * 0.2671), len);\n  \n    // hole\n    float v3 = smoothstep(innerRadius, mix(innerRadius, 0.8641, 0.2903), len);\n  \n    // ring color\n    vec3 c = mix(color1, color2, cl);\n    c = mix(color3, c, v0);\n    c = (c + v1) * v2 * v3;\n    c = clamp(c, 0.0, 1.3959);\n\n    _FragColor = extractAlpha(c);\n}\n\n///////////////////////////////////////\n// mainImage combines ring + boxes\n///////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized coords in [-1,1], for ring\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // 1) Fractal ring in front (makes a “portal / ring” in the center)\n    vec4 ringColor;\n    drawFractalRing(ringColor, uv);\n    \n    // 2) Raymarch boxes behind the ring\n    //    Let’s position the camera further away.\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(uv * fov, 1.5));\n    vec4 boxCol = rayMarchBox(ro, rd); \n\n    // 3) Basic blending approach\n    //    Where ring alpha > 0, we show ring color. Otherwise show boxes.\n    //    If you want the ring to “mask out” the center, invert the logic.\n    vec3 finalColor = mix(boxCol.rgb, ringColor.rgb, ringColor.a);\n\n    // A background color behind everything:\n    vec3 bgColor = BG_COLOR;\n    // Mix background wherever both ring & boxes are dark\n    finalColor = mix(bgColor, finalColor, 0.9);\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4Xcyz7","date":"1734855281","viewed":74,"name":"BUBBLE","username":"profmitchell","description":"change max dist to 12 for cell shader look","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["bubble"],"hasliked":0,"parentid":"","parentname":""}}