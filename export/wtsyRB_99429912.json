{"ver":"0.1","info":{"id":"wtsyRB","date":"1592411468","viewed":314,"name":"kleinian skulls","username":"wj","description":"This is a stripped down version of a shader that  I had used on a 2017 web page (see https://youtu.be/InwEtKS59eI  ).\n\nThe basic algorithm is very simular to what was used in boxplorer2 and I thought it might be useful to have it here on shadertoy.","likes":16,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","pseudokleinian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4l23R3","filepath":"https://soundcloud.com/lmanic/mos-techno-logy","previewfilepath":"https://soundcloud.com/lmanic/mos-techno-logy","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// kleinian skulls\n// by wj\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This is a stripped down version of what I am using on my 2017 web \n// page: http://www.wothke.ch/269life (to correctly view that page you may \n// need one of last year's browsers - e.g. no later than Chromium 75 or FireFox 66.0. Sadly \n// KhronosGroup decided to make an incompatible change to their WEBGL GL_EXT_draw_buffers \n// specs which sadly was implemented by most of the browsers in the second half \n// of 2019 and which breaks pages that depend on the original semantics.)\n\n// The code is based on knighty's \"pseudo kleinian\" Fragmentarium stuff with parts\n// pilfered from boxplorer2. More detailed credits can be found below.\n\nprecision highp float;\n\n#define RIM_BLEEDING\t\n\n#define DE_EPS 0.0001\n#define MAX_DIST 10.0\n\n#define MAX_STEPS 137\t// Maximum raymarching stepscoloring\n\t\t\t\t\n#define REFACTOR 0.5\n\n#define TThickness 4.50741e-008\t\t// Change a little the basic d_shape\n#define Ziter 3\n\n#define COLOR_ITERS 7\t\t\t\t\t\t\t\t\t\t\t// Number of fractal iterations for coloring\n#define REFITER 3\t\t\t\t\t\t\t\t\t\t\t\t// reflections\n#define DIST_MULTIPLIER 0.363001\n#define ITERS 11\t\t\t\t\t\t\t\t\t\t\t\t// Number of fractal iterations\t\t\t\n#define CSize vec3(0.808001 ,0.808,1.167)\t\t\t\t\t\t// Size of the box folding cell\n#define Size 1.\t\t\t\t\t\t\t\t\t\t\t\t\t// Size of inversion sphere\n#define C vec3(0,0,0)\t\t\t\t\t\t\t\t\t\t\t// Julia seed\n#define Offset vec3(-4.88759e-007,1.73877e-007,-1.51991e-007)\t// Translation of the basic d_shape\n#define DEoffset 0.\t\t\t\t\t\t\t\t\t\t\t\t// A small value added to the DE - simplify\n#define MAXI 1.0\n\t\t\t\n// \"defines\" used to completely avoid unused calculations\n#define OptionalJuliaSeed p=p;\n#define DEfacScale k\t\t\t\t\n\n#define BLEND 0.543\t \t\t\t\t\t\t\t\t\t\t\t// Blend with 0 trap\n\t\t\t\t\n#define PI_HALF 1.5707963267948966192313216916398\n\n#define ONE_PLUS_ULP 1.000000059604644775390625\n#define ONE_MINUS_ULP 0.999999940395355224609375\n#define ULP 0.000000059604644775390625\n\n#define MIN_NORM 0.00001\n\n#define AO_EPS\t\t0.0499998 \t// Base distance at which ambient occlusion is estimated.\n#define AO_STRENGTH\t0.149624\t// Strength of ambient occlusion.\n\n\nconst vec3 backgroundColor= vec3(0.02, 0.06, 0.16);\nconst float speed= 3.95070000e-004;\nconst float min_dist= 0.000794328;\t\t// Distance at which raymarching stops\nconst float glow_strength= 0.499999;\t// How much glow is applied after MAX_STEPS\nconst float dist_to_color= 0.200951; \t// How is background mixed with the surface color after MAX_STEPS\nconst float time= 0.0;\nconst int preset= 0;\n\n// Colors.\nvec3 specularColor = vec3(1.0, 0.8, 0.4),\n\tglowColor = vec3(0.03, 0.4, 0.4),\n\taoColor = vec3(0, 0, 0);\n\nconst vec3 NORM_LIGHT=  normalize(vec3(1.0,0.5,0.7));\n\n// Compute the distance from `pos` to the PKlein basic shape.\nfloat d_shape(vec3 p) {\n\t// => this is the magic sauce that you want to tinker with :-)\n\t// pearls: nice blue/pearl finish \n   float rxy = (length(p.x));\n   return max(rxy,  -(length(p.xy)*p.z-TThickness) / sqrt(dot(p,p)+abs(TThickness)));\n}\t\n\n// Compute the distance from `pos` to the PKlein.\n\n// stripped down version of knighty's \"pseudo kleinian\" distance \n// estimate.. (see \"Fragmentarium\") - see used \"defines\" to recover standard impl\nfloat d(vec3 p) {\n\tfloat r2;\n\tfloat DEfactor=1.;\n\t\t\t\n\tfor(int i=0; i<ITERS; i++){\t\t\t\t//Box folding (repetition)\n\t\tp=2.*clamp(p, -CSize, CSize)-p;\n\t\t//Inversion\n\t\tr2=dot(p,p);\n\t\tfloat k=max(Size/r2, MAXI);\n\t\tp*=k; DEfactor*= DEfacScale;\n\t\tOptionalJuliaSeed\t\t// use define to completely remove if not used..\n\t\t\t\t\n//\t\tif (!(r2<1.)) break; // add some rectangular beams for menger?\n\t\t\t\t\n\t}\t\t\t\t\n\treturn (DIST_MULTIPLIER*d_shape(p-Offset)/abs(DEfactor)-DEoffset);\n}\n\n// Compute the color (In the original \"Fragmentarium\" impl color would be calculated \n// directly within the above d() function.. and the below impl is repeating the \n// the respective last call of d(p).. still this seems to be faster (e.g. 16fps vs 15fps) than \n// doing the calc for all the d() calls within march() - not counting all the additional d() \n// calls for reflections and AO..\nvec3 color(vec3 p) {\n\tfloat r2=dot(p,p);\n\tfloat DEfactor=1.;\n\tvec4  col=vec4(0.0);\n\tfloat rmin=10000.0;;\n\n\tvec3 Color= vec3(-1.072,5.067, 0.647 );\n\n\tfor(int i=0; i<COLOR_ITERS; i++){\t//Box folding\t\t\t\t\t\n\t\tvec3 p1=2.*clamp(p, -CSize, CSize)-p;\n\t\tcol.xyz+=abs(p-p1);\n\t\tp=p1;\n\t\t//Inversion\n\t\tr2=dot(p,p);\n\t\tfloat k=max(Size/r2, MAXI);\n\t\tcol.w+=abs(k-1.);\n\t\tp*=k; DEfactor*= DEfacScale;;\n\t\tOptionalJuliaSeed\t\t// use define to completely remove if not used..\n\t\t\t\t\n\t\tr2=dot(p,p);\n\t\trmin=min(rmin,r2);\n\t}\t\t\t\t\n\treturn mix(vec3(sqrt(rmin)),(0.5+0.5*sin(col.z*Color)), BLEND);\n}\n\n// Compute the normal at `pos`.\n// `d_pos` is the previously computed distance at `pos` (for forward differences).\nvec3 generateNormal(vec3 pos, float d_pos) {\n\tvec2 Eps = vec2(0, max(d_pos, MIN_NORM));\t\n\treturn normalize(vec3(\n\t\t// calculate the gradient in each dimension from the intersection point\n\t\t-d(pos-Eps.yxx)+d(pos+Eps.yxx),\n\t\t-d(pos-Eps.xyx)+d(pos+Eps.xyx),\n\t\t-d(pos-Eps.xxy)+d(pos+Eps.xxy)\n\t));\n}\n\n// Blinn-Phong shading model (http://en.wikipedia.org/wiki/BlinnPhong_shading_model)\n// `normal` and `view` should be normalized.\nvec3 blinn_phong(vec3 normal, vec3 view, vec3 color) {\n\tvec3 halfLV = normalize(NORM_LIGHT + view);\n\tfloat diffuse= max( dot(normal, halfLV), 0.0 );\n\tfloat specular = pow(diffuse, 32.0 );\t/*specular exponent*/\n\t\t\t\t\t\n#ifdef RIM_BLEEDING\n\t// with rim lighting (diffuse light bleeding to the other side)\n\tdiffuse = dot(normal, NORM_LIGHT); \n#endif\n\treturn color * (diffuse * 0.5 + 0.75) + specular * specularColor;\n}\n\n// FAKE Ambient occlusion approximation. based on\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n// uses current distance estimate as first dist. the size of AO is independent from distance from eye\nfloat ambient_occlusion(vec3 p, vec3 n, float DistAtp, float side) {\n\tfloat ao_ed= DistAtp*AO_EPS/min_dist;\t// Dividing by min_dist makes the AO effect independent from changing min_dist\n\tfloat ao = 1.0, w = AO_STRENGTH/ao_ed;\n\tfloat dist = 2.0 * ao_ed;\n\n\tfor (int i=0; i<5; i++) {\n\t\tfloat D = side * d(p + n*dist);\n\t\tao -= (dist-D) * w;\n\t\tw *= 0.5;\n\t\tdist = dist*2.0 - ao_ed;\n\t}\n\treturn clamp(ao, 0.0, 1.0);\n}\n\nfloat march(inout vec3 p, in vec3 dp, inout float D, inout float totalD, in float side, in float MINDIST_MULT){\n\t// Intersect the view ray with the Mandelbox using raymarching.\n\t// The distance field actually marched is the \"calculated DE\" minus (totalD * min_dist)\n\t// A perfect distance field have a gradient magnitude = 1. Assuming d() gives a perfect DE, \n\t// we have to multiply D with MINDIST_MULT in order to restore a gradient magnitude of 1\n\tint steps= 0;\n\tfor (int dummy=0; dummy<MAX_STEPS; dummy++) {\n\t\ttotalD+=D;\n\t\tD = (side * d(p + totalD * dp) - totalD * min_dist) * MINDIST_MULT;\n\n\t\tsteps++;\t// mimick what any non stupid-WEBGL loop would allow to do in the loop condition\n\t\t\t\t\n\t\tif (!(abs(D)>max(totalD*8192.0*ULP,ULP) && totalD < MAX_DIST)) break;\t\t\t\n\t}\n\tp += (totalD+D) * dp;\n\treturn float(steps);\n}\n\n// original \"noise()\" impl used somewhat cheaper variant of IQ's procedural 2D noise: https://www.shadertoy.com/view/lsf3WH\n// - to reduce GPU load, respective impl has been replaced by a texture-lookup based one (see https://www.shadertoy.com/view/4sfGzS).\nfloat noise3d( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\t f = f*f*(3.0-2.0*f);\n\t\t\t\t\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// By TekF...\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) );\n\tray.z = degree*sqrt(ray.z);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 cameraDirection(vec2 fragCoord) \n{\n\t// Camera direction borrowed from David Hoskins's\n    // https://www.shadertoy.com/view/4s3GW2\n    // I am too lazy to add more sophisticated flight controls for now\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n    mat3 mZ = RotationMatrix(vec3(.0, .0, 1.0), sin(iTime*.2)*.1);\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0),  0.0);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), 0.0);\n    mX = mY * mX * mZ;\n    \n    vec3 dir = vec3(uv.x, uv.y, 1.2);\n    BarrelDistortion(dir, .5);\n    dir = mX * normalize(dir);\n    \n    return dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec3 dir= cameraDirection(fragCoord);\n\tvec3 camera= vec3(1.0+sin(iTime*.13)*.8, 1.4, sin(iTime*.2)*.1);\t\n    \n    \n\tvec3 dp = normalize(dir);\n\tfloat noise =  noise3d(vec3(fragCoord.x, fragCoord.y, 0));\n\n\tvec3 p = camera;\n\n\tfloat totalD = 0.0, D = d(p);\n\t\t\t\t\t\n\tfloat side = sign(D);\n\tD = noise * abs(D);\n\t\t\t\t\t\n\tfloat MINDIST_MULT=1.0/(1.0+min_dist);\n\tD *= MINDIST_MULT;\n\n\tvec3 finalcol= vec3(0.);\n\tfloat refpart= 1.0;\n\n\tbool cont= true;\n\tfloat firstD= 0.;  // save first step for depth buffer\n\t\t\t\t\t\t\n\tfor(int i= 0; i<REFITER; i++){\n\t\tfloat steps= march(p, dp, D, totalD, side, MINDIST_MULT);\n\t\tif (i == 0) { firstD= totalD + D; }\n\t\t\t\t\t\t\n\t\tvec3 col= backgroundColor;\n\n\t\t// We've got a hit or we're not sure.\n\t\tif (totalD < MAX_DIST) {\n\t\t\tfloat D1= min_dist*.5*totalD;\n\t\t\tvec3 n= side * generateNormal(p, max(256.0*ULP, D1));\n\t\t\tcol= color(p);\n\t\t\t\t\t\t\t\n\t\t\tcol= blinn_phong(n, -dp, col);\t\t\t\n\t\t\tcol= mix(aoColor, col, ambient_occlusion(p, n, D1, side));\n\n\t\t\tdp= reflect(dp,n);\t// update the ray\n\n\t\t\tp-= (totalD+D) * dp;\t\t// without this there would be obvious reflection errors..\n\t\t\tD= (9. + noise) * D1;\n\n\t\t\t// We've gone through all steps, but we haven't hit anything.\n\t\t\t// Mix in the background color.\n\t\t\tif (D > max(totalD*8192.0*ULP,ULP)){\n\t\t\t\tfloat dc= clamp(log(D/min_dist) * dist_to_color, 0.0, 1.0);\n\t\t\t\tcol= mix(col, backgroundColor, dc);\n\t\t\t}\n\t\t} else {\n\t\t\tcont= false;\n\t\t}\n\n\t\t// Glow is based on the number of steps.\n\t\tcol= mix(col, glowColor, (float(steps)+noise)/float(MAX_STEPS) * glow_strength);\n\t\tfinalcol+= refpart*col;\n\t\trefpart*= REFACTOR;\n\t\tif (!cont) break;\n\t}\t\t\t\n\n\tfragColor= vec4(finalcol, 1.0);\n}","name":"Image","description":"","type":"image"}]}