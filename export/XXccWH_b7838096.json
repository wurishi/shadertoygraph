{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define M(a,b)    mat2(a, -a.y, a.x) * b\n#define I(z)      vec2((z).x, -(z).y) / dot(z,z)\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n#define iterations 10.0\n#define depth 0.0125\n#define layers 8.0\n#define layersblob 20\n#define step 1.0\n#define far 10000.0\n\nfloat radius=0.25; // radius of Snowflakes. maximum for this demo 0.25.\nfloat zoom=4.0; // use this to change details. optimal 0.1 - 4.0.\n\nvec3 light=vec3(0.0,0.0,1.0);\nvec2 seed=vec2(0.0,0.0);\nfloat iteratorc=iterations;\nfloat powr;\nfloat res;\n\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\n\n vec4 hash4( mediump vec4 n ) { return fract(sin(n)*1399763.5453123); }\n float noise2( mediump vec2 x )\n{\n    vec2 p = floor(x);\n    lowp vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    lowp vec4 h = hash4(vec4(n)+vec4(NC0.xy,NC1.xy));\n    lowp vec2 s1 = mix(h.xy,h.zw,f.xx);\n    return mix(s1.x,s1.y,f.y);\n}\n\n float noise222( mediump vec2 x, mediump vec2 y, mediump vec2 z )\n{\n    mediump vec4 lx = vec4(x*y.x,x*y.y);\n    mediump vec4 p = floor(lx);\n    lowp vec4 f = fract(lx);\n    f = f*f*(3.0-2.0*f);\n    mediump vec2 n = p.xz + p.yw*157.0;\n    lowp vec4 h = mix(hash4(n.xxyy+NC0.xyxy),hash4(n.xxyy+NC1.xyxy),f.xxzz);\n    return dot(mix(h.xz,h.yw,f.yw),z);\n}\n\n float noise3( mediump vec3 x )\n{\n    mediump vec3 p = floor(x);\n    lowp vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    mediump float n = p.x + dot(p.yz,vec2(157.0,113.0));\n    lowp vec4 s1 = mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),f.xxxx);\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\n}\n vec2 noise3_2( mediump vec3 x ) { return vec2(noise3(x),noise3(x+100.0)); }\n\nfloat map(mediump vec2 rad)\n{\n    float a;\n    if (res<0.0015) {\n    //a = noise2(rad.xy*20.6)*0.9+noise2(rad.xy*100.6)*0.1;\n        a = noise222(rad.xy,vec2(20.6,100.6),vec2(0.9,0.1));\n    } else if (res<0.005) {\n        //float a1 = mix(noise2(rad.xy*10.6),1.0,l);\n        //a = texture(iChannel0,rad*0.3).x;\n        a = noise2(rad.xy*20.6);\n        //if (a1<a) a=a1;\n    } else a = noise2(rad.xy*10.3);\n    return (a-0.5);\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv = (C - .5*iResolution.xy ) / iResolution.y;\n    vec2 u= C;\n   \n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n        float c22 = map(p.xy);\n       float t_zoom = iTime * 0.2;  // control the speed of the zoom with this factor\n    float zoom = 0.4 + sin(t_zoom) * 0.5;  // compute the zoom factor, which oscillates between 0.5 and 1.5\n    vec2 R = iResolution.xy;\n    float t_rot = iTime * 0.05;  // control the speed of the rotation with this factor\n    // compute a rotation matrix\n    float angle = t_rot;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    vec2 c = zoom * 1.75 * ( rot * (u+u - R) ) / R.y,\n         z = c;\n   \n    float s2 = 0.,i2=s;\n   \n    for (; i < 1.; i+=.015 ) {  \n     \n        s -= 2.5* log( pow(2.,-2./3.) * dot(z,z) );\n        z = I(M(z,z)) + c;      \n         \n    }  \n        a=30.*c22;\n   \n        p=mod(p-a,a*2.)-a;\n        s=2.;\n\n        for(int i=0;i++<10;){\n       \n            p=.7-abs(p+c22);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.7+sin(iTime*.1)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 );\n         }\n         g+=e=length(p.yzzz)/s;\n    }\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n    O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.85)*5., 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XXccWH","date":"1734986397","viewed":107,"name":"shining star 3","username":"nayk","description":"fractal 62 remake and cheap star and other","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["fractal","star"],"hasliked":0,"parentid":"","parentname":""}}