{"ver":"0.1","info":{"id":"XcjXzc","date":"1706813913","viewed":237,"name":"Above the clouds sea","username":"Toiture","description":"Simple cloud layer, lightning based on Iq method. Uses a Buffer to make the clouds texture. \n","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","clouds","3dnoise","2dnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SunColor mix(vec3(1.,0.95,0.9),vec3(1.,0.7,0.5), exp(-(Sun.y-0.2)*5.))\n\nfloat cloudDensity(vec3 p) {\n    float density =0.;\n    p/=50.;\n    \n    p.xz /=50. ;\n    if(p.y<0.)return 1. ;\n    \n    float big = texture(iChannel0, p.xz).r;\n    float big2=texture(iChannel0, p.xz*5.).r;\n    //big2 = smoothstep(0.3,0.7,big2)*big2;\n    \n    float height = smoothstep(1.,0.,length(p.y)/(max(big*0.8, max(big2*0.3, 0.1)))) ;\n    density+=height;\n    return density*0.7;\n} \nfloat lightMarch(vec3 ro, vec3 rd){\n    float t = 0. ;\n    \n    float d = 0. ;\n    float steps = 5. ;\n    float stepL = 1. ;\n    for(float i = 0. ; i < steps ; i++) {\n        vec3 p = ro+rd*d;\n        \n        float dE = cloudDensity(p) ;\n        if(dE > 0.) {\n            t+=dE*stepL ;\n        } \n        stepL*=2.;\n        d+=stepL;\n    } \n    \n    return exp(-t)*(1.-exp(-t));\n} \nvec4 rayMarch(vec3 ro, vec3 rd) {\n    float t = 1. ;\n    vec3 l = vec3(0.);\n    \n    float a = plaIntersection(ro, rd, vec3(0.,1.,0.),25.);\n    float b = plaIntersection(ro, rd, vec3(0.,1.,0.),0.);\n    float dI = b-a;\n    \n    if(a<0.)return vec4(0.,0.,0.,1.);\n    float steps = 15. ;\n    float stepL = clamp(dI/steps,0.,100.) ;\n    \n    ro+=rd*(a-rand(rd, 63.263)*stepL);\n    \n    float d = 0. ;\n    for(float i = 0. ; i<steps;i++) {\n        vec3 p = ro+rd*d;\n        \n        float dE = cloudDensity(p) ;\n        float local = exp(-stepL*dE) ;\n        \n        //lightning calculations\n        if(dE > 0.){\n            //iq technic\n            float amb = clamp((dE-cloudDensity(p+vec3(0.,1.,0.)*6.))*0.5,0.,1.);\n            float s = clamp((dE-cloudDensity(p+Sun*4.))*0.5,0.,1.);\n            s+=clamp((dE-cloudDensity(p+Sun))*1.8, 0.,1.);\n            s+=clamp((dE-cloudDensity(p+Sun*10.))*0.1,0.,1.);\n            \n            //s=lightMarch(p, Sun)*0.4 ;\n            vec3 r = amb*2.*vec3(0.2,0.1,0.2)+ s*SunColor*phase(0.5,-0.2,dot(rd,Sun));\n            l+= t*(r-r*local) /dE;\n            //l+=(vec3(0.2,0.1,0.2)*2.*amb + s*vec3(1.,0.7,0.5)*phase(0.4,-0.2,dot(rd,Sun)))*stepL*t;\n            \n        } \n        \n        t*=local;\n        if(t<0.05)break;\n        \n        d+=stepL ;\n    } \n    \n    //atmos fog\n    float aBeer = exp(-a*0.002) ;\n    t=mix(1.,t,aBeer);\n    return vec4(l, t) ;\n} \nvec4 planarClouds(vec3 ro, vec3 rd) {\n    float a = plaIntersection(ro, rd, vec3(0.,-1.,0.),600.);\n    float t = 1. ;\n    vec3 l = vec3(0.);\n    \n    if(a<0.)return vec4(0.,0.,0.,1.);\n    \n    vec3 p = ro+rd*a ;\n    float d = texture(iChannel0, p.xz/vec2(13000., 5000.) ).r*0.5;\n    \n    t*=exp(-d) ;\n    p.xz+=Sun.xz*200.;\n    if(t<1. ){\n        l+=clamp((d-texture(iChannel0, p.xz/vec2(13000.,5000.) ).r*0.5)*4.,0.,1.)*vec3(1.,0.7,0.5)*phase(0.6,-0.2,dot(rd,Sun))+ vec3(0.2,0.1,0.2);\n    } \n    l=vec3(t)*phase(0.5,-0.2,dot(rd,Sun))*2. ;\n    float aBeer = exp(-a*0.0005);\n    t= mix(1.,t,aBeer);\n    return vec4(l,t) ;\n} \nvec3 skyColor(vec3 rd) {\n    float mixer = exp(-abs(rd.y)*4.) ;\n    vec3 up = vec3(0.6,0.8,1.);\n    vec3 down = SunColor*0.8;\n    \n    vec3 sun = 0.03/(length(rd-Sun)/0.5)*vec3(1., 0.7,0.6);\n    vec3 sunHalo = 0.1/length(rd-Sun)*vec3(1.,0.6,0.4)*0.3;\n    float sunRing = smoothstep(0.5,0.49,length(rd-Sun)/0.5)-smoothstep(0.5,0.45,length(rd-Sun)/0.49) ;\n    return mix(up,down, mixer)+sun+sunHalo +sunRing*SunColor*0.2;\n    //return vec3(mixer) ;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y ;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.3, 0.8, 1.);\n    \n    \n    vec3 ro = vec3(0.,50.,0.);\n    //ro.x+=sin(iTime*0.3)*300.;\n    ro.x+=iTime*75.;\n    ro.z+=sin(iTime*0.2)*100.;\n    ro.y+=sin(iTime*0.7)*10.;\n    vec3 rd = normalize(vec3(uv,-1.));\n    \n    col = skyColor(rd) ;\n    //test zone\n    \n    //uv+=iTime ;\n    vec3 p = vec3(uv,iTime);\n    \n    //col+=cloudDensity(p+0.5) ;\n    \n    ///////\n    vec4 c = rayMarch(ro,rd);\n    col=mix(c.rgb,col,c.a);\n    vec4 c2 = planarClouds(ro, rd) ;\n    col = mix(c2.rgb,col,c2.a);\n    \n    col+=(rand(col, 6.2727)*2.-1.)*0.05;\n    col=pow(col, vec3(0.8));\n    \n    col*=smoothstep(1.,0.,length(uv))*0.3+0.7;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float basicNoise(vec2 uv) {\n    float noise = texture(iChannel0, uv).r;\n    noise += texture(iChannel0, uv*2.).r*0.5;\n    noise += texture(iChannel0, uv*4.).r*0.25; \n    noise += texture(iChannel0, uv*8.).r*0.125;\n    noise += texture(iChannel0, uv*16.).r*0.0612;\n    noise/=1.+0.5+0.25+0.125+0.0612 ;\n    return smoothstep(0.3,0.6,noise)*noise ;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 col = vec3(0.);\n    \n    col.r = basicNoise(uv) ;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define Sun normalize(vec3(0.,(sin(iTime*0.1)*0.2+0.4) ,-1.))\nfloat plaIntersection(vec3 ro, vec3 rd, vec3 normal,float shift )\n{\n    float dis = dot(normal,rd);\n    if (-dis > 0.001){\n        float t = dot(vec3(shift)-ro,normal)/dis ;\n        return t ;\n    } \n    else return -1. ;\n} \n\nfloat HG( float g, float sundotrd) {\n\n\tfloat gg = g * g;\treturn (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);}\n\n\nfloat phase(float f, float b, float costh) {\n\n    return mix(HG(f, costh),HG(b,costh ),0.5 ); \n\n} \nfloat rand(vec3 c, float seed) {\n    return fract(sin(dot(c, vec3(0.4772))*637.372)*7.3728*seed);\n} ","name":"Common","description":"","type":"common"}]}