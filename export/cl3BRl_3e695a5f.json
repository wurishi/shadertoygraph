{"ver":"0.1","info":{"id":"cl3BRl","date":"1701451175","viewed":68,"name":"Neon star-balls ","username":"nayk","description":"new, starfield, colorful, neon,galaxy, universe,copypast from ozora","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["colorful","galaxy","starfield","new","universe","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*original https://www.shadertoy.com/view/tllfRX original https://www.shadertoy.com/view/dl3XDS  https://www.shadertoy.com/view/ldySDh*/\n \n#define NUM_LAYERS 8.\n#define TAU 6.28318\n#define PI 3.141592\n#define Velocity .025 //modified value to increse or decrease speed, negative value travel backwards\n#define StarGlow 0.525\n#define StarSize 02.\n#define CanvasView 20.\n\n\n#define MULTISAMPLES 3 // Max 4\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nconst float N = 1.33;\nconst float zoom = 2.0;\nconst int max_intersections = 12;\n\nconst float eyedistance = 7.5; // Note: These depend on each other\nconst float min_distance = 3.0;\nconst float max_distance = 10.5;\nconst float min_stepsize = 0.25;\nconst int maxsteps = 30;\n\nconst float pi = 3.1415926536;\n\nvec4 sphere1;\nvec4 sphere2;\nvec4 sphere3;\n\nfloat sq(float x) { return x * x; }\nfloat sq(vec3 x) { return dot(x, x); }\n\nfloat fresnel(float n1, float n2, float cos_theta)\n{\n    float r = sq((n1 - n2) / (n1 + n2));\n    return r + (1.0 - r) * pow(1.0 - clamp(cos_theta, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat f(vec3 p)\n{\n    return 1.0 - (\n        sphere1.w / sq(sphere1.xyz - p) + \n        sphere2.w / sq(sphere2.xyz - p) +\n        sphere3.w / sq(sphere3.xyz - p));\n}\n\nvec3 fd(vec3 p)\n{\n    vec3 d1 = sphere1.xyz - p;\n    vec3 d2 = sphere2.xyz - p;\n    vec3 d3 = sphere3.xyz - p;\n    return 2.0 * (\n        sphere1.w * d1 / sq(sq(d1)) +\n        sphere2.w * d2 / sq(sq(d2)) +\n        sphere3.w * d3 / sq(sq(d3)));\n}\n\nfloat stepsize(vec3 p)\n{\n    float md = sqrt(min(min(\n        sq(p - sphere1.xyz), \n        sq(p - sphere2.xyz)), \n        sq(p - sphere3.xyz)));\n    return max(min_stepsize, abs(md - 1.0) * 0.667);\n}\n\nvec4 ray(vec3 p, vec3 d)\n{\n    float k = min_distance;\n    float nf = 1.0;\n    vec4 c = vec4(0.0);\n    float cr = 1.0;\n    for (int j = 0; j < max_intersections; ++j)\n    {\n        for (int i = 0; i < maxsteps; ++i)\n        {\n            if (k > max_distance)\n                return c  * cr;\n            float ss = stepsize(p + d * k);\n            if (f(p + d * (k + ss)) * nf < 0.0)\n            {\n                k += ss - min_stepsize * 0.5;\n                k += f(p + d * k) / dot(d, fd(p + d * k));\n                k += f(p + d * k) / dot(d, fd(p + d * k));\n                p += d * k;\n                \n                vec3 n = -normalize(fd(p)) * nf;\n                vec3 r = refract(d, n, nf > 0.0 ? 1.0 / N : N);\n\n                if (nf < 0.0)\n                {\n                    float fa = k * 0.025;\n                    c += vec4(0.5, 0.75, 1.0, 1.0) * fa * cr;\n                    cr *= 1.0 - fa;\n                }\n\n                if (r == vec3(0.0))\n                {\n\t                d = reflect(d, n);\n                }\n                else\n                {\n                    float f = nf > 0.0 ? \n                        fresnel(1.0, N, dot(-d, n)) : \n                    \tfresnel(N, 1.0, dot(-d, n));\n                    if (f > 0.5)\n                    {\n                        c +=   (1.0 - f) * cr;\n                        cr *= f;\n                        d = reflect(d, n);\n                    }\n                    else\n                    {                    \n                        c +=  f * cr;\n                        cr *= 1.0 - f;\n                        d = r;\n                        nf *= -1.0;\n                    }\n                }\n                k = 0.0;\n                break;\n            }\n            k += ss;\n        }\n    }\n    return c  * cr;\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);\n  \tfloat m = sin(StarGlow*1.2)/d;  \n    float rays = max(0., .5-abs(uv.x*uv.y*1000.)); \n    m += (rays*flare)*2.;\n    m *= smoothstep(1., .1, d);\n    return m;\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec3 StarLayer(vec2 uv){\n    vec3 col = vec3(0);\n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    for(int y=-1;y<=1;y++){\n        for(int x=-1; x<=1; x++){\n            vec2 offs = vec2(x,y);\n            float n = Hash21(id+offs);\n            float size = fract(n);\n            float star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.1,.9,size)*.46);\n            vec3 color = sin(vec3(.2,.3,.9)*fract(n*2345.2)*TAU)*.25+.75;\n            color = color*vec3(.9,.59,.9+size);\n            star *= sin(iTime*.6+n*TAU)*.5+.5;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = vec2(0);\n        float t = iTime;\n\n    vec4 vs1 = cos(t * vec4(0.87, 1.13, 1.2, 1.0) + vec4(0.0, 3.32, 0.97, 2.85)) * vec4(-1.7, 2.1, 2.37, -1.9);\n    vec4 vs2 = cos(t * vec4(1.07, 0.93, 1.1, 0.81) + vec4(0.3, 3.02, 1.15, 2.97)) * vec4(1.77, -1.81, 1.47, 1.9);\n    vec4 O = fragColor;\n    vec2 C = fragCoord;\n O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1)); \n    \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n    \n   \n    \n        p=g*d;\n        float t = mod(iTime*0.5,4.);\n    \n    if(t<1.){\n       p.z+=tan(iTime*0.5);\n       p.yx*=Rot(-iTime);\n       \n    } else if (t>=1. && t<2.){\n       p.x+=tan(iTime*0.5);\n       p.xz*=Rot(-iTime);\n    } else if (t>=2. && t<3.){\n         p.y+=tan(iTime*0.5);\n          p.xz*=Rot(iTime);\n    } else if (t>=3. && t<4.){\n       p.y+=tan(iTime*0.5);\n   p.yz*=Rot(-iTime);\n        \n        }\n        \n        \n         float t2 = mod(iTime*0.7,4.);\n          if(t2<1.){\n          a=17.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n       \n    } else if (t2>=1. && t2<2.){\n      \n        s=3.;\n         a=15.;\n       }\n       \n        else if (t2>=2. && t2<3.){\n      \n        s=4.;\n        a=14.;\n       \n        } else if (t2>=3. && t2<4.){\n      \n        s=5.;\n        a=11.;\n       }\n         \n         \n       \n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n    }\n    sphere1 = vec4(vs1.x, 0.0, vs1.y, 1.0);\n\tsphere2 = vec4(vs1.z, vs1.w, vs2.z, 0.9);\n\tsphere3 = vec4(vs2.x, vs2.y, vs2.w, 0.8);\n\n    vec2 r2 = -iMouse.yx / iResolution.yx * pi * 2.0;\n\n    vec4 cs = cos(vec4(r2.y, r2.x, r2.y - pi * 0.5, r2.x - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n    vec3 eye = -forward * eyedistance;\n\n\t\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));    \n    vec4 color = ray(eye, dir);\n#if MULTISAMPLES > 1\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\n#if MULTISAMPLES > 2\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\n#if MULTISAMPLES > 3\n    color += ray(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\n#endif\n#endif\n    color /= float(MULTISAMPLES);\n#endif\n    M -= vec2(M.x+sin(iTime*0.22), M.y-cos(iTime*0.22));\n    M +=(iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    float t2 = iTime*Velocity; \n    vec3 col = vec3(0);  \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS){\n        float depth = fract(i+t2);\n        float scale = mix(CanvasView, .5, depth);\n        float fade = depth*smoothstep(1.,.9,depth);\n        col += StarLayer(uv*scale+i*453.2-iTime*.05+M)*color.xyz+O.xyz*fade;}   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}