{"ver":"0.1","info":{"id":"mt2XDt","date":"1676844602","viewed":164,"name":"Fractal fun","username":"jonny_townend","description":"Ray march fractal test. Mouse rotation enabled.\n\nThere is some weirdness going on with cam plane clipping which I will try and fix!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","ray","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MIN_DIST 0.01\n\n// SDFs\nfloat sSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sBox(vec3 p) {\n    p = abs(p);\n    vec3 r = vec3(0.24);\n    vec3 m = max(vec3(0.), sign(p - r));\n    return length(m * (p - r));\n}\n\nfloat sComplex(vec3 p) {\n    float d = sBox(p);\n    d = smin(d, sSphere(p, 0.3), 100.);\n    return d;\n}\n\nfloat sFractal(vec3 p) {\n    float d = sComplex(p);\n    for (int i=0; i<3; i++) {\n        p *= 2.5;\n        p = abs(p) - vec3(0.6);\n        d = smin(d, sComplex(p), 20.);\n    }\n    return d;\n}\n\nfloat sScene(vec3 p) {\n    return sFractal(p);\n}\n\n// Ray march\nvec3 getSurface(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i=0; i<MAX_STEPS; i++) {\n        d = sScene(ro);\n        ro += 0.5 * d * rd;\n        if (d < MIN_DIST) {\n            return ro;\n        }\n    }\n    return 1000. * rd;\n}\n\n// Lighting\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = vec3(\n        sScene(p + e.xyy) - sScene(p - e.xyy),\n        sScene(p + e.yxy) - sScene(p - e.yxy),\n        sScene(p + e.yyx) - sScene(p - e.yyx)\n    );\n    n += 0.0002 * texture(iChannel1, p.xy).xyz;\n    return normalize(n);\n}\n\nvec3 shadeSurface(vec3 p, vec3 rd) {\n    if (length(p) > 900.) {\n        return texture(iChannel0, rd).xyz;\n    }\n\n    vec3 lightPos = vec3(0.5 * sin(0.5 * iTime), .5, -1.5);\n    vec3 n = getNormal(p);\n    \n    // ambient\n    vec3 ambient = 0.1 * vec3(1.);\n    \n    // diffuse\n    vec3 diffuse = vec3(1.) * dot(normalize(lightPos - p), n);\n    diffuse *= 1. / length(lightPos - p);\n    \n    // specular\n    vec3 l = reflect(-normalize(p), n);\n    float specular = dot(normalize(lightPos - p), l);\n    specular = 0.3 * smoothstep(0.99, 1., specular);\n    \n    return (ambient + diffuse + specular) * vec3(1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.5;\n    vec3 camPos = vec3(0., 0., -0.65);\n    vec3 uv = vec3((fragCoord - 0.5*iResolution.xy)/iResolution.x, 0.);\n    vec3 ro = vec3(0., 0., -zoom);\n    \n    uv += camPos;\n    ro += camPos;\n    \n    mat3 rotX = rotateQ(normalize(vec3(0., 1., 0.)), (iMouse.x / iResolution.x) - 0.5);\n    mat3 rotY = rotateQ(normalize(vec3(1., 0., 0.)), -(iMouse.y / iResolution.y) + 0.5);\n    uv *= rotX * rotY;\n    ro *= rotX * rotY;\n    \n    vec3 rd = normalize(uv - ro);\n\n    vec3 p = getSurface(ro, rd);\n    vec3 col = shadeSurface(p, rd);\n    \n    // reflection\n    if (length(p) < 900.) {\n        vec3 n = getNormal(p);\n        vec3 i = reflect(-normalize(ro), n);\n        float fresnel = dot(normalize(ro), n);\n        fresnel = 1. - pow(fresnel, 1.);\n        p = getSurface(p + 0.1*n, i);\n        col = (fresnel * col) + ((1. - fresnel) * shadeSurface(p + 0.1*n, i));\n        //col = shadeSurface(p + 0.1*n, i);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Helpers\nmat3 rotateQ(vec3 axis, float rad) {\n    float hr = rad / 2.0;\n    float s = sin( hr );\n    vec4 q = vec4(axis * s, cos( hr ));\n    vec3 q2 = q.xyz + q.xyz;\n    vec3 qq2 = q.xyz * q2;\n    vec2 qx = q.xx * q2.yz;\n    float qy = q.y * q2.z;\n    vec3 qw = q.w * q2.xyz;\n\n    return mat3(\n        1.0 - (qq2.y + qq2.z),  qx.x - qw.z,            qx.y + qw.y,\n        qx.x + qw.z,            1.0 - (qq2.x + qq2.z),  qy - qw.x,\n        qx.y - qw.y,            qy + qw.x,              1.0 - (qq2.x + qq2.y)\n    );\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat smax1(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nvec2 toPolar(vec3 dir) {\n    float azimuth = atan(dir.y, dir.x);\n    float elevation = asin(dir.z);\n    return vec2(azimuth, elevation);\n}","name":"Common","description":"","type":"common"}]}