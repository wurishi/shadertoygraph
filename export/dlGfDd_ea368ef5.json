{"ver":"0.1","info":{"id":"dlGfDd","date":"1702639314","viewed":26,"name":"raytracer something idk","username":"theStartOfGreatJourney","description":"raytracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define the maximum number of steps for ray marching\n#define MAX_STEPS 100\n\n// Define a structure for representing a ray in 3D space\nstruct Ray {\n    vec3 origin;      // The starting point of the ray\n    vec3 direction;   // The direction in which the ray is pointing\n};\n\n// Function to compute ray-sphere intersection\nfloat raySphereIntersection(Ray ray, vec3 sphereCenter, float sphereRadius) {\n    vec3 oc = ray.origin - sphereCenter;                      // Vector from the sphere center to the ray origin\n    float a = dot(ray.direction, ray.direction);              // Dot product of ray direction with itself\n    float b = 2.0 * dot(oc, ray.direction);                   // Dot product of oc (sphere center to ray origin) and ray direction\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;      // Square of the distance from the ray origin to the sphere center minus sphere radius squared\n    float discriminant = b * b - 4.0 * a * c;                 // Discriminant of the quadratic equation\n\n    if (discriminant < 0.0) {\n        return -1.0; // No intersection\n    }\n\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);        // First intersection point\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);        // Second intersection point\n\n    float t = min(t1, t2);                                    // Choose the smaller positive intersection point\n\n    if (t >= 0.0) {\n        return t; // Intersection\n    }\n\n    return -1.0; // No positive intersection point\n}\n\n// Structure to store information about a ray-sphere intersection\nstruct HitInfo {\n    float t;        // Parameter along the ray where the intersection occurs\n    vec3 normal;    // Normal vector at the point of intersection\n};\n\n// Function to cast a ray and check for intersection with a sphere\nHitInfo castRay(Ray ray) {\n    vec3 sphereCenter = vec3(0.0, 0.0, 0.0);    // Center of the sphere\n    float sphereRadius = 1.0;                     // Radius of the sphere\n\n    float t = raySphereIntersection(ray, sphereCenter, sphereRadius);\n    \n    if (t > 0.0) {\n        vec3 pos = ray.origin + t * ray.direction;     // Compute the position of intersection\n        vec3 normal = normalize(pos - sphereCenter);   // Compute the normal at the point of intersection\n        return HitInfo(t, normal);                      // Return intersection information\n    }\n\n    return HitInfo(-1.0, vec3(0.0)); // No intersection information\n}\n\n// Main function for rendering the scene\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;  // Normalized screen coordinates\n    float an = iTime;                                               // Time variable for animation\n\n    vec3 ta = vec3(0.0, 0.2, 0.0);                                  // Target position for the camera\n    vec3 ro = vec3(3.5 * sin(an), 0.0, 3.5 * cos(an));        // Camera position (animated)\n    vec3 ww = normalize(ta - ro);                                   // Forward direction of the camera\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));          // Right direction of the camera\n   vec3 vv = normalize(cross(uu, ww));                            // Up direction of the camera\n\n    vec3 rd = normalize(vec3(uv.x * uu + uv.y * vv + 0.8 * ww));   // Direction of the primary ray\n\n    Ray ray = Ray(ro, rd);           // Create a ray with the camera position as the origin and the computed direction\n    HitInfo hit = castRay(ray);      // Cast the ray and check for intersection with the sphere\n\n    vec3 col = vec3(0.4, 0.75, 1.2) - 0.7 * rd.y;   // Background color based on ray direction\n    \n    if (hit.t > 0.0) {\n        vec3 pos = ray.origin + hit.t * ray.direction;  // Position of intersection\n        vec3 nor = hit.normal;                           // Normal vector at the point of intersection\n\n        vec3 mate = vec3(0.2, 0.2, 0.2);                  // Material properties\n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));   // Direction of the sun\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);  // Diffuse shading from the sun\n        float sky_dif = clamp(0.5 + 0.5 * dot(nor, vec3(0.0, 0.8, 0.0)), 0.0, 1.0);  // Diffuse shading from the sky\n        float sun_sha = step(castRay(Ray(pos + nor * 0.001, sun_dir)).t, 0.0);      // Shadow from the sun\n        float bou_dif = clamp(0.5 + 0.5 * dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);  // Bounced light\n        \n        col = mate * vec3(8.0, 4.5, 3.0) * sun_dif * sun_sha;   // Direct sunlight contribution\n        col += mate * vec3(0.5, 0.8, 0.9) * sky_dif;           // Sky illumination contribution\n        col += mate * vec3(0.7, 0.4, 0.2) * bou_dif;           // Bounced light contribution\n\n        col = pow(col, vec3(0.4545));   // Apply gamma correction\n    }\n\n    fragColor = vec4(col, 1.0);   // Output the final color\n}\n","name":"Image","description":"","type":"image"}]}