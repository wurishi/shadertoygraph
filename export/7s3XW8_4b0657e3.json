{"ver":"0.1","info":{"id":"7s3XW8","date":"1634052552","viewed":64,"name":"SimpleCheckerBoard","username":"liaozixin","description":"Implement a checkerboard map and apply it to plane","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["checker"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\n\nvec3 Checker(vec3 p)\n{\n    vec3 col = vec3(0.);\n    if(p.y < 0.0001)\n    {\n        vec2 uv = vec2(p.x, p.z);\n        vec2 floor_p = 0.5 * floor(uv);\n        col = vec3(fract(floor_p.x + floor_p.y) * 2.);\n    }\n    return col;\n\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n\n\n\nfloat GetDist(vec3 p)\n{\n    float plane = sdPlane(p);\n    return plane;\n}\n\nfloat RayMarching(Ray r)\n{\n    float d = 0.;\n    vec3 p = r.o;\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        float ds = GetDist(p);\n        d += ds;\n        p = r.o + d * r.d;\n        if(d > MAX_DIST || d < MIN_DIST)\n            break;\n    }\n    return d;\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0, 1, 0);\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 n = vec3(0, 1, 0);\n    \n    float dif = dot(lightDir, n);\n    return dif;\n}\n\n\nRay InitOrbCam(vec3 pos, vec3 dir, float speed)\n{\n    Ray cam_r;\n    cam_r.o = pos;\n    cam_r.d = dir;\n    \n    \n    mat3 m = mat3(\n        cos(iTime * speed), 0, -sin(iTime * speed),\n        0, 1, 0,\n        sin(iTime * speed), 0, cos(iTime * speed)\n    );\n    \n    cam_r.o *= m;\n    cam_r.d *= m;\n    cam_r.d = normalize(cam_r.d);\n    \n    return cam_r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    Ray r = InitOrbCam(vec3(0, 2, -6), \n                    normalize(vec3(uv.x, uv.y, 1)),\n                    0.1);\n \n    \n    float d = RayMarching(r);\n    vec3 p = r.o + d * r.d;\n    \n    float dif = GetLight(p);\n    vec3 col = Checker(p);\n    col *= dif;\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}