{"ver":"0.1","info":{"id":"Dl2yWz","date":"1691674812","viewed":139,"name":"Walking Through Liminal Space","username":"propagant","description":"Simple raymarched scene, featuring infinite and atmospheric liminal spaces with vhs effect. Made just for fun!","likes":6,"published":3,"flags":64,"usePreview":0,"tags":["raymarching","backrooms","liminalspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdcGWN","filepath":"https://soundcloud.com/leylandkirby/01-all-you-are-going-to-want?in=leylandkirby/sets/the-caretaker-an-empty-bliss&si=c941021b310043dcbae70cea878d6a1e&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/leylandkirby/01-all-you-are-going-to-want?in=leylandkirby/sets/the-caretaker-an-empty-bliss&si=c941021b310043dcbae70cea878d6a1e&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Walk through liminal atmospheric spaces written by Matej Vanco, August 2023.\n\nfloat sdfBox(in vec3 c, in vec3 s, in float r)\n{\n\treturn length(max(abs(c),s)-s)-r;\n}\n\nfloat sdfPlane(in vec3 c, in vec3 n, in float h)\n{\n    return dot(c+UP*h,normalize(n));\n}\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      CORE                                  //\n//            SDFs, Raymarching, lighting etc...              //\n////////////////////////////////////////////////////////////////\n\n\nfloat SDF(in vec3 p)\n{\n    vec3 rp = p;\n    rp.xz = opRep(p.xz, 2.5);\n        \n    float box = sdfBox(rp, vec3(.3,1.5,.3), 0.01);\n    float pool = sdfBox(rotateY(rp.x+rp.z) * (rp), vec3(0.8,.5,.6), 0.1);\n    \n    float ground = sdfPlane(p, UP, 0.5);\n    float roof = sdfPlane(p, -UP, -1.5);\n    \n    return opu(box, ops(min(roof,ground), pool, 0.1),0.1);\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 of = vec2(1.e-3,0.);\n    float sdf = SDF(p);\n    return normalize(sdf - vec3(SDF(p - of.xyy), SDF(p - of.yxy), SDF(p - of.yyx)));\n}\n\nfloat rayMarch(in Ray r)\n{\n    float t = 0.;\n    for(int i = 0; i < ITERS; i++)\n    {\n        vec3 cp = r.o + t * r.d;\n        float sdf = SDF(cp);\n        t+=sdf;\n        if(t > MAX_DIST)\n            break;\n    }\n    return t;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = 0.001;\n    float r = 1.;\n    Ray ray;\n    ray.o = ro;\n    \n    for(int i = 0; i < 16; i++)\n    {\n        ray.d = rd * 0.008 * t;\n        float g = rayMarch(ray);\n        r = min(r, b * g / t);\n        t += g;\n        if(g < 0.001)\n            break;\n        \n        if(g >= 16.)\n            break;\n    }\n    return clamp(r,0.5,1.);\n}\n\nfloat lighting(vec3 p)\n{\n    p.xz = opRep(p.xz, 10.);\n    \n    vec3 lp = vec3(1.0,.5,1.);\n    \n    vec3 ld = lp - p;\n    vec3 ldn = normalize(ld);\n    vec3 n = normal(p);\n    \n    float atten = dot(n, ldn) * (.05/length(ld))*150.;\n    \n    atten *= shadow(p, ldn, .5);\n    \n    return clamp(atten - abs(sin(iTime*50.)*0.2),0.,3.);\n}\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      SCENE                                 //\n//                                                            //\n////////////////////////////////////////////////////////////////\n\nvec3 Texture(in vec3 uv)\n{\n    vec2 pp = fract((uv.xz+uv.xy)*15.);\n    return ONE * step(pp.y,0.25);\n}\n\nvec3 renderScene(in vec2 uv, in vec2 uvVHS)\n{\n    Ray r;\n    r.o = vec3(1.25, sin(iTime * 15.) * 0.008, iTime * 0.5);\n    r.d = rotateY(sin(iTime * 0.25)) * vec3(uv + uvVHS * 9.e-3, 1.);\n    \n    float march = rayMarch(r);\n    float depth = 1. / march;\n    vec3 cp = r.o + r.d * march;\n    if(cp.y < -0.55)\n        cp.xz += texture(iChannel1, cp.xz*2.).r*0.5;\n    \n    vec3 color = vec3(0.);\n\n// Depth only\n#if RENDER_MODE == 1\n    color = vec3(depth);\n// Normals only\n#elif RENDER_MODE == 2\n    color = normal(cp);\n// Full render (albedo+lambert+fog)\n#else\n    float light = lighting(cp);\n    vec3 fog = mix(ZERO, vec3(.8,1.,0.1)/5., clamp(pow(depth,1.5),0.,1.));\n    vec3 tex = Texture(cp);\n    \n    color = (tex * 0.5 + light) * fog;\n#endif\n\n    return color;\n}\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      GUI                                   //\n//                                                            //\n////////////////////////////////////////////////////////////////\n\nfloat rect(in vec2 st, in vec2 size)\n{\n    vec2 uv = step(0.25 - size, st * (1.0-st));\n\treturn uv.x * uv.y;\n}\n\nvec3 renderGUI(vec2 uv, in vec2 uvVHS)\n{\n#if GUI == 0\n    return ZERO;\n#endif\n\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 recIcon = vec3(1.,0.2,0.4) * 0.5 * step(length(vec2(uv.x-0.15,uv.y-0.9) + uvVHS * 0.01),0.03);\n    recIcon *= step(fract(iTime*0.5),.5);\n    \n    vec3 panel = ONE * 0.1 * rect(uv-vec2(.5,0.4)+uvVHS * 0.01,vec2(.4,1.e-6));\n    vec3 panel2 = ONE * 0.1 * rect(uv-vec2(.4,-0.4)+uvVHS * 0.01,vec2(.6,1.e-6));\n    \n    return recIcon + panel + panel2;\n}\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      MAIN                                  //\n//                                                            //\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (.5 * iResolution.xy)) / iResolution.y;\n    vec3 color = vec3(0.);\n    \n#if VHS == 1\n    vec2 vhs = fract(vec2(HASH1(uv.y-iTime), uv.y-iTime * HASH1(uv.y) * 0.1) * 20.)*VHSIntens;\n    vec3 sceneColor = renderScene(uv, vhs);\n    color = vec3(renderScene(uv, vhs).r, renderScene(uv+CHROMATIC_ABERRATION, vhs).g, renderScene(uv-CHROMATIC_ABERRATION, vhs).b);\n#else\n    vec2 vhs = vec2(0.);\n    color = renderScene(uv, vhs);\n#endif\n\n    vec3 guiColor = renderGUI(fragCoord / iResolution.xy, vhs);\n\n    fragColor = vec4(color + .1 + guiColor, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Renderer essentials\n\n#define MAX_DIST 64.0\n#define ITERS 32\n\n// 0 = default, 1 = depth, 2 = normals\n#define RENDER_MODE 0\n// 0 = disabled, 1 = enabled\n#define VHS 1\n#define VHSIntens 2.\n#define CHROMATIC_ABERRATION 0.005\n#define GUI 1\n\nstruct Ray\n{\n    vec3 o,d;\n};\n\n// Hashes\n\n#define HASH1(v) fract(sin(v * 1024.32) * 768.4096)\n\n// Transform\n\n#define UP vec3(0.,1.,0.)\n#define FWD vec3(0.,0.,1.)\n#define ONE vec3(1.)\n#define ZERO vec3(0.)\n\nmat3 rotateY(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Operations (iq's solutions)\n\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p + s * 0.5, s) - s * 0.5;\n}\n\nfloat ops(float a, float b, float s)\n{\n    float k = s;\n    float h = clamp( 0.5 - 0.5*(b+a)/k, 0.0, 1.0 );\n    return mix( a, -b, h ) + k*h*(1.0-h);\n}\n\nfloat opu(float a, float b, float s)\n{\n    float k = s;\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}","name":"Common","description":"","type":"common"}]}