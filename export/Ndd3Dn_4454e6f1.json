{"ver":"0.1","info":{"id":"Ndd3Dn","date":"1629579381","viewed":96,"name":"Pseudo Jellyfish","username":"CannaVizion","description":"My first shader in shadertoy! (also anywhere else)\nJust playing around with SDF and taking first steps trying to simulate a jellyfish.\nStill don't know what I'm doing XP","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","learning","jellyfish","creature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Contains pieces of code from: IÃ±igo Quilez(@iq) https://iquilezles.org/articles/distfunctions\n// and from MERCURY http://mercury.sexy/hg_sdf/\n// Also many thanks to Martijn Steinrucken (@BigWings) for his tutorials for dummies like me! \n\n#define MAX_STEPS 200\n#define MAX_DIST 20.\n#define SURF_DIST 0.0001\n\n#define MOUSE 1\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec3 opRepLim( in vec3 p, in float s, in vec3 lim ){\n    return p-s*clamp(round(p/s),-lim,lim);\n}\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nmat2 rotMat(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2 (c,-s,s,c);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+max3(min(p, vec3(0)));\n}\n\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n    return fOpIntersectionRound(a, -b, r);\n}\n\nfloat GetDist (vec3 p){\n    \n    vec3 pJ = p - vec3(0,mod(iTime*1.5+(sin(iTime*2.-PI/2.)*.5+.5),3.),0);\n    vec3 pC1 = vec3(0,.1*sin(iTime*2.),0);\n    vec3 pC2 = vec3(0,.6*cos(iTime*.2)-1.2,0);\n    float r1 =sin(iTime*2.+PI)*.3+.5;\n    float r2 =cos(iTime*2.)*.3+.4;\n    pJ = opRepLim(pJ,3.,vec3(2.,4.,2.));\n    float C = sdRoundCone(pJ,pC1,pC2,r1,r2);\n    C = abs(C)-.02;\n    \n    float Pl = pJ.y+.7;\n    C = max(C,-Pl);\n    \n    vec3 b1P = pJ-vec3(0,-.5,0);\n    pModPolar(b1P.xz,8.);\n    float star = sdBox(b1P,vec3(1.,.5,.01+sin(2.*iTime+PI)*0.09+0.09))*.6-.01;\n    \n    float dist = fOpDifferenceRound (C,star,0.05)*.5;\n    // float dist = star;\n\n    return dist;\n}\n\nfloat RayMarch (vec3 ro, vec3 rd){\n    float dO = 0.;\n\n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n\n    }    \n    return dO;\n}\n\nvec3 GetNormal (vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3 (0.,10.,0.);\n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal (p);\n    float dif = clamp(dot(n,l)*.5+0.5,0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    //if (d<length(lightPos-p)) dif *= .1;  //Shadows\n\n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m  = iMouse.xy/iResolution.xy;\n    vec3 col = smoothstep(0.1,4.,length(uv))*vec3(0,.1,.3)*.3;\n\n    vec3 ro = vec3 (0.,-3.,-4.);\n    \n#if MOUSE\n    ro.yz *= rotMat(m.y*3.14);\n    ro.xz *= rotMat(-m.x*6.2831);\n#endif\n\n    vec3 la = vec3(0,1,1);\n    vec3 rd = R(uv, ro, la,1.);\n\n    float d = RayMarch(ro,rd);\n    if (d<MAX_DIST){\n        vec3 p = ro + rd*d;\n        float difuse = GetLight(p);\n        col= vec3(0.2,.1,difuse*2.);\n\n    }\n\n    vec2 cP = uv + vec2(0,.25);\n    float cross = (1.-step(0.003,abs(cP.x)))*(1.-step(0.03,abs(cP.y)));\n    cross += (1.-step(0.003,abs(cP.y)))*1.-step(0.03,abs(cP.x));\n    vec3 Cross =vec3(cross);\n\n    col = pow(col, vec3(.4545));\n    //col = max(Cross*vec3(1.,0,0), col);\n\n    fragColor = vec4 (col,1);\n\n}","name":"Image","description":"","type":"image"}]}