{"ver":"0.1","info":{"id":"mdjXW1","date":"1670286665","viewed":103,"name":"Octahedral Voronoi on Sphere","username":"dgreensp","description":"Combining a new simple sine-based hash with an octahedral scheme for a Voronoi pattern on a sphere, where each cell has at most 6 neighbors.  See comments for more information.  This code is 100% original and hereby published as CC0.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","sphere","hash"],"hasliked":0,"parentid":"ddSSDR","parentname":"Basic Template dgreensp"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All of this code is 100% original by David Greenspan.  Consider it CC0\n// and use it however you want, no attribution required.  \n\nconst int MODE = 1;\n\n// Set number of hexagons/voronoi cells.  (For values greater than 10, you\n// may start to notice that there are more points along the equator and prime\n// meridians, and fewer in the middle of an octant.)  This constant is referred\n// to as simply \"N\" in comments.\nfloat OCT_N = 7.0; \n\n// dgcombine3 and dghash33 are a fract-sin-based hash.  I created them\n// by squinting at 2D noise fields and trying to make them look uniform\n// (no repeating patterns).  It turns out magic numbers do not seem to be\n// needed.  Inputs should be integers (in float form), positive or\n// negative, ideally each around three digits or less.  Besides being simple\n// and fast, there is a goal of staying within 32-bit float precision for\n// reproducibility across CPU and GPU (I did some tests of this\n// on the 2D version), and different GPUs.\n//\n// Any structures or patterns in the noise seem to be pleasing to the eye.\n\nfloat dgcombine3(vec3 ints) {\n    vec3 a = ints + vec3(0.5, 0.75, 0.25);\n    return mod(a.x * a.y * a.z, 10000.);\n}\n\nvec3 dghash33(vec3 ints)\n{\n    return fract(sin(vec3(0., 1., 2.) + dgcombine3(ints)) * 1000.);\n}\n\n// Noise Demo\n\nfloat dgcombine2(vec2 ints) {\n    vec2 a = ints + vec2(0.5, 0.75);\n    return mod(a.x * a.y, 10000.);\n}\n\nfloat dghash21(vec2 ints)\n{\n    return fract(sin(dgcombine2(ints)) * 1000.);\n}\n\nvec3 NoiseDemo(vec2 uv) {\n   return vec3(dghash21(floor((uv + vec2(iTime*0.1, 0))*100.)));\n}\n\n////\n\n// Hopefully you are familiar with how to make a voronoi texture on a 2D\n// square grid, with one point per square cell, e.g. see:\n// https://www.shadertoy.com/view/MslGD8\n// \n// How can we do this seamlessly on a sphere?  If we use a 3D texture, each\n// cell has 26 neighbors.  That seems like too many, and it will be slow.\n// It would nice to take advantage of the fact that we are on a 2D surface,\n// but the surface of a sphere doesn't lend itself to simple 2D mapping.\n//\n// This approach uses an octahedron.  The plane x + y + z = N is one\n// side of the octahedron, and there is a similar side in each octant.  We\n// can project back and forth between the sphere and the octahedron, with\n// only a little distortion, by just adjusting the length of the vector.\n// The voronoi cells are centered at the lattice points (points with integer\n// coordinates) that exist on the octahedron (so that the absolute values of\n// their coordinates sum to N).\n// For example, for N=3, the lattice points in the first octant\n// are (3,0,0), (2,1,0), (1,2,0), (0,3,0), (2,0,1), (1,1,1), (0,2,1), (1,0,2),\n// (0,1,2), and (0,0,3).  Most cells have six neighbors, but the ones with a 0\n// in their coordinates are on an edge of the octahedron and have two of their\n// six neighbors in other octants, while cells with *two* 0's in their\n// coordinates only have four neighbors.\n//\n// The voronoi cells make a nice hexagonal pattern on the surface\n// of the sphere.\n//\n// This whole demo is designed to be as fast as possible.\n\n// Returns the squared distance from q to the cell at lattice point\n// qcell, with q in unit-sphere coordinates and qcell being a on an\n// octahedron of size N.\nfloat getDist(vec3 q, vec3 qcell, float N) {\n    // Place a voronoi point in the unit cube centered at qcell\n    // (actually we shrink the cube a bit!), project it onto a\n    // sphere, and measure the distance to q.  We need to know N\n    // because q and qcell are in different coordinate systems,\n    // and even if they weren't, we need to know the radius of\n    // the sphere to project onto, relative to the size of a cell.\n    vec3 offset = (dghash33(qcell) - 0.5) * 0.8;\n    vec3 qToPoint = q - normalize((qcell + offset) / N);\n    return dot(qToPoint, qToPoint);\n}\n\n// Takes a vec3 of numbers between 0. and 1. that add up to either\n// 1. or 2., and \"rounds\" them while preserving their sum.\nvec3 roundFroct(vec3 froct) {\n   if (froct.x + froct.y + froct.z < 1.5) {\n      // Sum is 1. so set the highest component to 1., others\n      // to 0.\n      return froct.x > max(froct.y, froct.z) ?\n        vec3(1.,0.,0.) : froct.y > froct.z ?\n          vec3(0.,1.,0.) : vec3(0.,0.,1.);\n   } else {\n       // Sum is 2. so set the highest two components to 1., others\n       // to 0.\n       return froct.x < min(froct.y, froct.z) ?\n         vec3(0.,1.,1.) : froct.y < froct.z ?\n           vec3(1.,0.,1.) : vec3(1.,1.,0.);\n   }\n}\n\n// Given a vector of two integers greater than or equal to 0,\n// which are not both 0, provides the two ways to adjust the integers\n// by at most one each such the sum of their absolute values stays the\n// same. For example, given (2, 5), the two ways are (3, 4) and (1, 6).\n// When one number is 0, things are a bit different.  Given (7, 0),\n// the two ways are (6, 1) and (6, -1).\nvoid getTwoNeighbors(vec2 c, out vec2 n1, out vec2 n2) {\n    if (c.x == 0.) {\n        n1 = vec2(1., c.y - 1.);\n        n2 = vec2(-1., c.y - 1.);\n    } else if (c.y == 0.) {\n        n1 = vec2(c.x - 1., 1.);\n        n2 = vec2(c.x - 1., -1.);\n    } else {\n        n1 = c + vec2(1.,-1.);\n        n2 = c + vec2(-1.,1.);\n    }\n}\n\n// A version of getTwoNeighbors that takes (x,y,z) and applies getTwoNeighbors\n// to (y,z), passing x through.\nvoid getTwoNeighbors(vec3 c, out vec3 n1, out vec3 n2) {\n   n1 = c;\n   n2 = c;\n   getTwoNeighbors(c.yz, n1.yz, n2.yz);\n}\n\nvec3 render(vec2 uv) {\n    // p is the (x,y) position with the origin centered and room to\n    // view a unit sphere\n    vec2 p = (uv - vec2(0.5)) * 2.4;\n    // z2 is the z coordinate for a unit sphere, squared, or\n    // a negative number if the sphere does not overlap that (x,y)\n    float z2 = 1. - dot(p,p);\n    // return early if sphere does not overlap this (x,y)\n    if (z2 < 0.0) {\n        return NoiseDemo(uv);\n    }\n    // q is p with the z coordinate filled in; position on unit sphere\n    vec3 q = vec3(p, sqrt(z2));\n    vec3 absq = abs(q);\n    vec3 signq = sign(q);\n    // octq is absq scaled so its components sum to N\n    vec3 octq = absq / (absq.x + absq.y + absq.z) * OCT_N;\n    vec3 froctq = fract(octq);\n    // \"round\" octq to the nearest lattice point whose components\n    // also sum to N, and restore the sign of q, so that qcell is\n    // in the vicinity of q*N.\n    vec3 absqcell = floor(octq) + roundFroct(froctq);\n    vec3 qcell = absqcell * signq;\n    // Find the distance to the voronoi point in q's own cell (unit cube\n    // if the sphere had radius N)\n    float dist = getDist(q, qcell, OCT_N);\n    // Now compare the distance to the voronoi points in the (up to) six\n    // neighboring cubes.  Note that we work with absqcell for simplicity\n    // and then multiply signq back in.  We hold each component of absqcell\n    // constant, one at a time.  For example, if absqcell is (1,1,1), we first\n    // hold x=1 constant and visit neighbors (1,0,2) and (1,2,0).  getTwoNeighbors\n    // takes care of the special case where y or z is 0, and we take care of\n    // the case where both are 0 (by doing nothing).  By using swizzling together\n    // with \"out\" parameters, we can run the same function (getTwoNeighbors)\n    // with x, y, and z shuffled around.  So after holding x constant and messing\n    // with y and z, we hold y constant and mess with x and z, and so on.\n    vec3 n1, n2;\n    if (absqcell.yz != vec2(0.)) {\n        getTwoNeighbors(absqcell.xyz, n1.xyz, n2.xyz);\n        dist = min(dist, getDist(q, n1*signq, OCT_N));\n        dist = min(dist, getDist(q, n2*signq, OCT_N));\n    }\n    if (absqcell.xz != vec2(0.)) {\n        getTwoNeighbors(absqcell.yxz, n1.yxz, n2.yxz);\n        dist = min(dist, getDist(q, n1*signq, OCT_N));\n        dist = min(dist, getDist(q, n2*signq, OCT_N));\n    }\n    if (absqcell.xy != vec2(0.)) {\n        getTwoNeighbors(absqcell.zxy, n1.zxy, n2.zxy);\n        dist = min(dist, getDist(q, n1*signq, OCT_N));\n        dist = min(dist, getDist(q, n2*signq, OCT_N));\n    }\n    dist = sqrt(dist) * OCT_N;\n    vec3 gray = vec3((3. - dist)/3.);\n    if (MODE == 1) {\n        float t = cos(iTime*0.5);\n        t *= t; t *= t;\n        return mix(gray, dghash33(qcell), t);\n    }\n    return gray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minDimension = min(iResolution.x, iResolution.y);\n    \n    vec2 uv = (fragCoord - (iResolution.xy - minDimension)*0.5) / minDimension;\n    \n\n    vec3 col = any(lessThan(uv, vec2(0.0))) || any(greaterThan(uv, vec2(1.0))) ?\n        vec3(0.0) : render(uv);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}