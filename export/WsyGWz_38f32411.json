{"ver":"0.1","info":{"id":"WsyGWz","date":"1570027601","viewed":212,"name":"Endless Cartoon Droplets","username":"thomasderoo4","description":"Looking to improve speed, now runs at about 26 frames/second on my machine. Maybe add soft shadows instead of hard. Get rid of artifacts around light.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["cartoon","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define SURFACE_DIST .01\n#define FOG_START 4.\n#define FOG_END 10.\n#define MAX_DIST FOG_END + 1.\n#define PI 3.14159265359\n#define LIGHT vec4(0., 5.+sin(iTime*4.3)*.2, -2. + iTime, .03)\n\n// Noise 3 to 1\nfloat N31(vec3 id) {\n id = fract(id * vec3(244.224, 441.211, 521.198));\n id += dot(id, vec3(63.6, 9.1, 55.3))/6.6;\n return fract(id.x * id.y * id.z);\n}\n\n// Noise 3 to 3\nvec3 N33(vec3 id) {\n id = fract(id * vec3(266.234, 881.211, 572.598));\n id += dot(id, vec3(67.6, 981.1, 5.3));\n return vec3(fract(id.x * id.y), fract(id.y * id.z), fract(id.z * id.x));\n}\n\n// Gets distance from point p to capsule a to b with radius r.\nfloat d_capsule(vec3 p, vec3 a, vec3 b, float r, float pinch) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + ab*t;\n    \n    // Make capsule thinner at center\n    float mx = 1.-(cos(t*2.*PI)*.5+.5);\n    \n    return length(p-c)-mix(r, r*.2, mx*pinch);\n}\n\n// Gets a random corner for the cube.\nvec3 RandomCorner(vec3 id) {\n    float s = .65;\n    float r = N31(id);\n    if (r < .25) {\n        return vec3(-s, -s, -s);\n    } else if (r < .5) {\n        return vec3(-s, s, -s);\n    } else if (r < .75) {\n        return vec3(-s, s, s);\n    } else {\n        return vec3(s, s, -s);\n    }\n}\n\n// Get distance to scene\nfloat GetDist(vec3 p, vec3 rd, out float lightdist) {\n    // Get direction so that we don't search in wrong direction\n    float ox = (rd.x > 0.) ? 1. : 0.;\n    float oy = (rd.y > 0.) ? 1. : 0.;\n    float oz = (rd.z > 0.) ? 1. : 0.;\n    \n    float sphere_d = length(p-LIGHT.xyz)-LIGHT.w;\n    \n   \t\n    // square id\n    vec3 id = floor(p / 2.);\n    \n    // Domain repetition\n    p = vec3(mod(p.x, 2.)-1.,mod(p.y, 2.)-1., mod(p.z, 2.)-1.);//, );\n\n    float capsule_d = MAX_DIST;\n    // Search in xyz offset by direction.\n    for(float x = -1.+ox;x<=ox;x++) {\n        for(float y = -1.+oy;y<=oy;y++) {\n            for(float z = -1.+oz;z<=oz;z++) {\n                // Get random corner for this square\n                vec3 v = RandomCorner(id + vec3(x, y, z));\n                \n                // Get capsule distance\n                float d = d_capsule(p, v + vec3(x, y, z) * 2., -v + vec3(x, y, z) * 2., .3, 1.);//mh_length(p-sphere.xyz)-sphere.w;\n                \n                // Calc min\n                capsule_d = min(capsule_d, d);\n            }\n        }\n    }\n    lightdist = sphere_d;\n    return min(capsule_d, sphere_d);\n}\n\n\n\n\n\n// March ray, returns distance and iterations\nfloat RayMarch(vec3 ro, vec3 rd, out int its, out float minlightdist) {\n\tfloat d_o = 0.;  \n    its = 0;\n    minlightdist = MAX_DIST;\n    \n    for(int i=0;i<MAX_STEPS;i++) {\n     \tvec3 c_p = ro + (rd * d_o);\n        float lightdist = 0.;\n        float d_s = GetDist(c_p, rd, lightdist);\n        minlightdist = min(minlightdist, lightdist);\n        d_o+= d_s;\n        its++;\n        if ((d_s < SURFACE_DIST) || (d_o > MAX_DIST)) break;\n    }\n            \n    return d_o;\n}\n\n\n// Guess normal at position p\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(SURFACE_DIST, 0.);\n    float lightdist = 0.;\n    float d = GetDist(p, vec3(0.), lightdist);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, vec3(-1., 0., 0.), lightdist),\n        GetDist(p-e.yxy, vec3(0., -1., 0.), lightdist),\n        GetDist(p-e.yyx, vec3(0., 0., -1.), lightdist)\n    );\n    return normalize(n);\n}\n\n// Get light level at position p\nfloat GetLight(vec3 p) {\n    // light position\n    vec3 lv = normalize(LIGHT.xyz-p);//lightvector\n    vec3 nv = GetNormal(p);//normalvector\n    int its = 0;\n    float lightdist = 0.;\n    // light cutoff\n    float lightlevel = smoothstep(.3,.7,clamp(dot(lv, nv), 0., 1.));\n    float shadow = (RayMarch(p+(nv*SURFACE_DIST*2.), lv, its, lightdist) < (length(LIGHT.xyz-p)-(LIGHT.w*2.))) ? 0. : 1.;\n    return 0.3 + ((lightlevel * shadow) * .7);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0.);\n    // Ray origin, Ray direction\n    vec3 ro = vec3(cos(iTime*0.8)*.4, 5.+sin(iTime*0.8)*.4, -6. + iTime);\n    vec3 rd = normalize(vec3(uv.x-cos(iTime*0.8)*.1, uv.y-sin(iTime*0.8)*.1, 1.));\n\t\n    // get iterations and distance to scene\n\tint its = 0;\n    float lightdist = 0.;\n    float d = RayMarch(ro, rd, its, lightdist);\n    \n    // Get the minimum distance a ray came to a light and create add var.\n    float light_add = pow(smoothstep(LIGHT.w*30., 0., lightdist), 20.);// * (0.7 + ((sin(atan(uv.x, uv.y)*16.)*.5+.5)*0.3));\n   \t\n    // Dont bother if beyond fog reach\n    if(d<FOG_END) {\n        \n        // Make more iterations darker\n        float outline = smoothstep(.75, .65, float(its)/40.);\n        \n        // Get hit position\n        vec3 pos = ro + (rd * d);\n\t\t\n        bool at_light = (length(pos-LIGHT.xyz) < LIGHT.w*2.);\n        \n        // Get random color at position\n   \t\tvec3 posid = floor(pos / 2.);\n    \tvec3 col_at_pos = at_light ? vec3(1.) :  (.2+N33(posid)*.8);\n        \n        // Calculate final pixel color\n        col = col_at_pos * (at_light ? 1. : GetLight(pos)) * smoothstep(FOG_END, FOG_START, d) * outline;\n    }\n\n    fragColor = vec4(mix(col+light_add, vec3(1.), light_add),1.0);\n}","name":"Image","description":"","type":"image"}]}