{"ver":"0.1","info":{"id":"3sjBzW","date":"1589667376","viewed":829,"name":"Triangle mesh renderer","username":"TomF","description":"A basic software renderer for an arbitrary triangle mesh. May be a useful basis for other projects.\n\nThis version generates the entire mesh for every pixel, which is obviously slow!\nNote this rasteriser does not obey the strict fill rules.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["triangles","barycentric","mesh","rasteriser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define BACKFACE_CULL true\n#define TEXTURED true\n\n\nstruct Vertex\n{\n    vec4 Pos;\n    vec2 Uv;\n};\n\n// Test a position against a triangle and return\n// the perspective-correct barycentric coordinates in the triangle\n// Note the z value in the vertex is ignored, it's the w that matters.\n// This is the fast but hard-to-read version.\n// See https://www.shadertoy.com/view/wdjfz1 for the more readable version.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    // 1/w already done by caller\n    vec3 recipw = vec3 ( v1.Pos.w, v2.Pos.w, v3.Pos.w );\n\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    float baryis = ( posv1.x * v31.y - posv1.y * v31.x );\n    float baryjs = ( posv1.y * v21.x - posv1.x * v21.y );\n    float baryks = ( scale - baryis - baryjs );\n    \n    float newis = recipw.y * baryis;\n    float newjs = recipw.z * baryjs;\n    float newws = recipw.x * baryks + newis + newjs;\n    \n    // ...and project back.\n    float rnewws = 1.0/newws;\n    float perspi = newis * rnewws;\n    float perspj = newjs * rnewws;\n        \n    return vec2 ( perspi, perspj );\n}\n\n\nconst int GridW = 5;\nconst int GridH = 5;\nconst int NumVerts = GridH*GridW*2;\nconst int NumTris = (GridH-1)*(GridW-1)*2*2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NDC (-1 to +1)\n    vec2 uv = -1.0 + 2.0f * (fragCoord/iResolution.xy);\n    \n    float wobble = float(iTime);\n    \n    // Create the mesh. This would of course be done offline.\n    Vertex Verts[NumVerts];\n    for ( int w = 0; w < GridW; w++ )\n    {\n        for ( int h = 0; h < GridH; h++ )\n        {\n            Vertex Vert0, Vert1;\n            Vert0.Pos.x = float(w - GridW/2);\n            Vert0.Pos.y = float(h - GridH/2);\n            float wf = -2.0 + float(w);\n            float hf = -3.0 + float(h);\n            float d = sqrt(wf*wf + hf*hf);\n            Vert0.Pos.z = 0.3 * cos (d * 2.0 + wobble);\n            Vert0.Pos.w = 1.0f;\n            Vert0.Uv.x = float(w) / float(GridW-1);\n            Vert0.Uv.y = float(h) / float(GridH-1);\n            \n            Vert1.Pos = Vert0.Pos;\n            Vert1.Pos.z += 1.0f;\n            Vert1.Uv = Vert0.Uv;\n            \n            int Index = (w*GridH+h)*2;\n            Verts[Index+0] = Vert0;\n            Verts[Index+1] = Vert1;\n        }\n    }\n\n    int Indices0[NumTris];\n    int Indices1[NumTris];\n    int Indices2[NumTris];\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        for ( int h = 0; h < GridH-1; h++ )\n        {\n            int VertIndex = (w*GridH+h)*2;\n            int TriIndex = (w + (GridH-1)*h) * 2 * 2;\n            Indices0[TriIndex+0] = VertIndex  ;\n            Indices1[TriIndex+0] = VertIndex  +GridH*2;\n\t\t\tIndices2[TriIndex+0] = VertIndex  +2;\n            Indices0[TriIndex+1] = VertIndex+1;\n            Indices2[TriIndex+1] = VertIndex+1+GridH*2;\n\t\t\tIndices1[TriIndex+1] = VertIndex+1+2;\n            \n            Indices2[TriIndex+2] = VertIndex  +GridH*2;\n            Indices0[TriIndex+2] = VertIndex  +GridH*2+2;\n\t\t\tIndices1[TriIndex+2] = VertIndex  +2;\n            Indices1[TriIndex+3] = VertIndex+1+GridH*2;\n            Indices0[TriIndex+3] = VertIndex+1+GridH*2+2;\n\t\t\tIndices2[TriIndex+3] = VertIndex+1+2;\n        }\n    }\n    \n    float hfov = 0.6;\n    float vfov = hfov * iResolution.y / iResolution.x;\n    float zfar = 10.0f;\n    float znear = 1.0f;\n    float q = zfar/(zfar-znear);\n    \n    mat4 ProjMat;\n    ProjMat[0] = vec4 ( 1.0/hfov, 0.0f, 0.0f, 0.5f );\n    ProjMat[1] = vec4 ( 0.0f, 1.0/vfov, 0.0f, 0.5f );\n    ProjMat[2] = vec4 ( 0.0f, 0.0f, q, 1.0f );\n    ProjMat[3] = vec4 ( 0.0f, 0.0f, -q*znear, 0.0f );\n    \n    \n    mat4 TotalMat;\n    mat4 ObjMat1;\n    mat4 ObjMat2;\n    \n    float a1 = iMouse.x * 0.01;\n    float a2 = iMouse.y * 0.01;\n    float zdist = 8.0;\n    ObjMat1[0] = vec4 ( cos(a1),  sin(a1), 0.0, 0.0 );\n    ObjMat1[1] = vec4 ( sin(a1), -cos(a1), 0.0, 0.0 );\n    ObjMat1[2] = vec4 ( 0.0,          0.0, 1.0, 0.0 );\n    ObjMat1[3] = vec4 ( 0.0,          0.0, 0.0, 1.0 );\n    ObjMat2[0] = vec4 ( 1.0, 0.0,          0.0, 0.0 );\n    ObjMat2[1] = vec4 ( 0.0, cos(a2),  sin(a2), 0.0 );\n    ObjMat2[2] = vec4 ( 0.0, sin(a2), -cos(a2), zdist );\n    ObjMat2[3] = vec4 ( 0.0, 0.0,          0.0, 1.0 );\n    \n    TotalMat = ObjMat1 * ObjMat2;\n    TotalMat = TotalMat * ProjMat;\n\n    // Background colour\n    vec3 col;\n    col.xy = uv.xy;\n    col.z = 0.0;\n\n    Vertex ScreenVert[NumVerts];\n    for ( int VertNum = 0; VertNum < NumVerts; VertNum++ )\n    {\n        vec4 Pos = Verts[VertNum].Pos;\n        \n        vec4 ScrPos = Pos * TotalMat;\n        float rw = 1.0/ScrPos.w;\n        ScrPos.x *= rw;\n        ScrPos.y *= rw;\n        ScrPos.z *= rw;\n        ScrPos.w = rw;\n        \n        ScreenVert[VertNum].Pos = ScrPos;\n        ScreenVert[VertNum].Uv = Verts[VertNum].Uv;\n    }\n    \n    float NearestZ = 10000.0f;\n    for ( int TriNum = 0; TriNum < NumTris; TriNum++ )\n    {\n        Vertex v1 = ScreenVert[Indices0[TriNum]];\n        Vertex v2 = ScreenVert[Indices1[TriNum]];\n        Vertex v3 = ScreenVert[Indices2[TriNum]];\n        vec3 bary;\n        bary.xy = BaryTri3D ( uv, v1, v2, v3 );\n        bary.z = 1.0 - bary.x - bary.y;\n\n        // You need to do the UV coord generation outside all the conditionals,\n        // otherwise you don't get good gradients at the edges.\n        // HOWEVER - what actually happens is the compiler spots you only *use* the UV\n        // values inside the conditionals and drags the calculation inside,\n        // which then breaks the gradients! So to stop this, I added a totally\n        // spurious test of the UV coords to the barycentric test.\n        vec2 uv = bary.z * v1.Uv + bary.x * v2.Uv + bary.y * v3.Uv;\n        \n        if ( ( bary.x >= 0.0 ) &&\n             ( bary.y >= 0.0 ) &&\n             ( bary.z >= 0.0 ) &&\n             ( uv.x + uv.y > -10.0 ) ) // see above\n        {\n            // Interpolate Z\n            // Note this is linear Z, not the strange Z that most rasteriser use\n            // In this case, that's fine.\n            float Z = bary.z * v1.Pos.z + bary.x * v2.Pos.z + bary.y * v3.Pos.z;\n            if ( NearestZ > Z )\n            {\n                NearestZ = Z;\n            \n                if ( TEXTURED )\n                {\n                    vec4 tex = texture ( iChannel0, uv );\n                    col.xyz = tex.xyz;\n                }\n                else\n                {\n                    col.xy = bary.xy;\n                    col.z = 1.0;\n                    if ( fract ( bary.x * 4.0 ) < 0.05 ) { col.z = 0.0; }\n                    if ( fract ( bary.y * 4.0 ) < 0.05 ) { col.z = 0.0; }\n                }\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}