{"ver":"0.1","info":{"id":"wlfcz8","date":"1591389841","viewed":143,"name":"hexagon id test with iMouse(WIP)","username":"ShaderLyf","description":"trying to make a tonnetz grid, this is the start I've made today. I can't figure out how I'd map the rows separated by fifths. I want to use the circles with lines going through as triggers for individual notes and potentially chords for the inner circles","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["wip","hexagon","help","tiling","imouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hexD(vec2 p)\n{\n    p = abs(p);\n    float c = dot(p,normalize(vec2(1,1.73)));\n    c = max(c,p.x);\n    return c;\n}\n\nfloat circle(vec2 uv, float rad)\n{\n    float d = length(uv); //distance function\n    return smoothstep(rad,rad-0.01,d); // circle draw\n}\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530718\nvec2 rotate2D(vec2 uv, float r){ // takes uv co-ords and rotates them by r\n    uv =  mat2(cos(r),-sin(r),\n                sin(r),cos(r)) * uv;\n    return uv;\n}\n\nvec3 triD(vec2 uv,float s)\n{\n    vec2 repeat =vec2 (1.,1.73);\n    vec2 h = repeat*0.5;\n    vec2 a1=mod(uv,repeat)-h; // gridify, but it's offset\n\tvec2 b1=mod(uv-h,repeat)-h; // gridify and center\n    vec2 getv = dot(a1,a1)<dot(b1,b1)?a1:b1;//if else function\n    float d = 0.;\n  \t// Remap the space to -1. to 1.\n  \t//uv = uv * 2.-1.;\n\n  \t// Number of sides of your shape\n  \tint N = 3;\n\n  \t// Angle and radius from the current pixel\n  \tfloat a = atan(getv.x,getv.y)+PI;\n  \tfloat r = TWO_PI/float(N);\n\t\n    vec2 id = getv-uv;\n  \t// Shaping function that modulate the distance\n  \td = cos(floor(.5+a/r)*r-a)*length(getv);\n    vec3 col = vec3(1.0-smoothstep(s,s+0.01,d));//*sin(id.x*id.y+iTime)));\n\n  \treturn col;\n}\n\nvec2 getV(vec2 uv)\n{\n    vec2 repeat =vec2 (1.,1.73);\n    vec2 h = repeat*0.5;\n    vec2 a1=mod(uv,repeat)-h; // gridify, but it's offset\n\tvec2 b1=mod(uv-h,repeat)-h; // gridify and center \n    vec2 getv = dot(a1,a1)<dot(b1,b1)?a1:b1;//if else function without if/else  \n    \n    return getv;\n}    \n\nvec4 hexC (vec2 uv)\n{\n    vec2 repeat =vec2 (1.,1.73);\n    vec2 h = repeat*0.5;\n    vec2 a1=mod(uv,repeat)-h; // gridify, but it's offset\n\tvec2 b1=mod(uv-h,repeat)-h; // gridify and center\n    vec2 getv = dot(a1,a1)<dot(b1,b1)?a1:b1;//if else function without if/else\n    float x = atan(getv.x,getv.y);\n    float y = .5-hexD(getv);\n    vec2 id = uv-getv;\n\n    vec4 co = vec4(x,y,id.x,id.y); // coords and id\n    return co;\n\n}\n\nvec3 hexCircs (vec2 uv)\n{\n    vec2 getv = getV(uv);  \n    vec2 id = uv-getv;\n    float o = circle(getv,0.2);\n    vec3 hx = vec3(id.x,id.y,o);\n    return hx;\n}\n\nvec2 getId(vec2 p)\n{\n    vec2 getv = getV(p);\n    vec2 id = p-getv;\n    return id;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec2 uv2 = uv;\n    vec2 uv3 = uv;\n    \n    vec3 col = vec3(0.);\n    uv *= (1.5); \n    //uv *= (5.*1.1547); \n\n    uv3 = rotate2D(uv3,PI*0.16666);\n    uv2*=(3.*1.1547);// scale of space\n    uv3*=(6.);// scale of space\n\n\tfloat circ = hexCircs(uv).z;\n\n    vec3 vis = hexCircs(uv3);\n    \n    vec4 h = hexC(uv3);\n    vec3 t = triD(uv2,0.29);\n    vec3 t2 = triD(uv2,0.27);\n    float c = smoothstep(0.005,.05,h.y);\n    \n    vec2  m  = iMouse.xy / iResolution.xy;\n    vec2 ar = vec2(1.0, iResolution.y/iResolution.x);\n    m*=ar;\n    m*=6.;\n    vec2 id = getId(m);\n    \n    col+=vis.z;//good circles\n    //col+=vis.y; //visual debug\n\tcol+=t;\n    col-=t2;\n    col+=c;\n//  vec3 trp = vec3(col.x-sin(vis.x*vis.y+iTime*0.9),col.y*sin(vis.x*vis.y+iTime*2.2),col.z*cos(vis.x*vis.y+iTime*0.6));\n\tvec3 trp = vec3(col.x-sin((vis.x*8.+m.x)+(vis.y*14.)),col.y*sin((vis.x*2.5+m.y+iTime)+(vis.y*7.)),col.z);\n     //vec3 ms = vec3(col.x-m.x,col.y*sin((vis.x*2.5+m.y)+(vis.y*7.)),col.z);\n\n     //vec3 trp = vec3(id.x,id.y,col.z);\n\n    \t\n    //vec3 e = vec3(col.x,col.y,col.z);\n\n    fragColor = vec4(trp,1.0);\n}","name":"Image","description":"","type":"image"}]}