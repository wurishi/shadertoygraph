{"ver":"0.1","info":{"id":"msl3RN","date":"1665846398","viewed":276,"name":"Please Sin In","username":"derSchamane","description":"Just a little sketch created by experimenting with my raymarcher and lighting, but worth sharing.\nIf you have performance issues (most likely on fullscreen) deactivate AA at line 22.\nDrag mouse for camera movement. Enjoy\n\n\nSubstance Reference: 3-HO-PCP","likes":19,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","waves","sin","sphere","mk3drmb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//                      = Please Sin In =         \n//                by Maximilian Knape ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 200\n#define STEP_FAC 0.8\n#define MAX_DIST 160.\n#define MIN_DIST 10.\n\n#define SURF_DIST .001\n#define SURF_MUL 100.\n#define SURF_EXP 5.\n\n#define GLOW_INT 1.0\n#define PP_CONT 0.5\n#define PP_VIGN 1.5\n\n#define AA_ENAB true\n#define AA_THRE .05\n\n\n#define iTime iTime*1.0\n#define PI 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 Map(vec3 p) \n{    \n    float d, col, t = mod(iTime, 2.*PI);\n    \n    float l = length(p.xz);\n    float k = pow(l,.8);\n    \n    d = max( p.y + \n             sin(-t + k) * 1.5 + \n             sin(t + k*1000./max(18., k*k)) * 0.5 + \n             l*l/-500., 0.) * \n        \n        (S(1., 50., l)*.25+.1);\n    \n\n    float sphere = (length(p - vec3(0., (sin(t-PI*.3)*.5+.5)*11.-.5, 0.)) - 2.5) *.8; \n    col = sphere < d ? 3.4 : 2.6;    \n    d = min(sphere, d);\n    \n    float drop = length(p - vec3(0., pow(sin(t-PI*.2)*.5+.5, 2.5)*5., 0.)) - .3;\n    col = drop < d ? 2.4 : col;    \n    d = min(drop, d);\n    \n    return vec2(d, col);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(.001, 0);\n    return normalize(Map(p).x - vec3(Map(p-e.xyy).x, Map(p-e.yxy).x,Map(p-e.yyx).x));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (pow(dO/MAX_DIST, SURF_EXP)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(vec3 ro, vec3 lp, float k) //Shane\n{\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i<maxIterationsShad; i++)\n    {\n\n        float h = Map(ro + rd*dist).x;\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.) + .0, 1.); \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) //BigWings\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c ) //iq\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nconst vec3 ambCol = vec3(.01,.02,.03) * 1.0;\nconst vec3 sunCol = vec3(1., .8, .6) * 1.0;\nconst vec3 skyCol = vec3(1., .6, .4) * 0.3;\nconst float specExp = 10.;\n\nvec3 Shade(vec3 col, float mat, vec3 p, vec3 n, vec3 rd, vec3 lP) \n{\n    vec3  lidi = normalize(lP - p);\n    float mafa = max(mat, .0),\n          amoc = 1.,\n          shad = SoftShadow(p + n*.015, lP, 2.),\n          diff = max(dot(n, lidi), 0.) * shad,\n          spec = pow(diff, max(1., specExp * mafa)),\n          refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad,\n          indi = 1.-diff;\n    \n    return mix( indi * mix(ambCol, skyCol, .03) * col * amoc +       //ambient\n                diff * col * sunCol * max(1. - mafa, .0) +           //diffuse\n                (spec * col + refl * mafa) * sunCol * mafa,          //specular\n                \n                col  * S(0., 1., amoc * amoc + .5),                  //emission\n                max(-mat, 0.));\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., 1., 1.);\n        case 1: return vec3(1., .8, .6);\n        case 2: return vec3(.3, .5, 1.);\n        case 3: return hsv2rgb_smooth(vec3(fract(-iTime/36.), .9, 1.))*3.;\n    }\n    return vec3(0.);\n}\n\nvoid Render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.8,.2);\n\n    vec3 ro = vec3(m.x*40.-20., 5., -30.-m.y*30.);\n    ro.yz *= Rot(-(m.y/3.-.42) * PI + PI*.5);\n    vec3 rd = R(uv, ro, vec3(-m.x*20.+10., 8., 0.), 1.);\n    \n    vec3 bg = skyCol;\n    vec3 lPos = vec3(-sin(iTime*PI/10.)*50., sin(iTime*PI/20.)*30.+80., -cos(iTime*PI/10.)*50.);\n    \n    vec3 col = skyCol;\n    vec3 p = vec3(0.);\n    vec3 rmd = RayMarch(ro, rd);\n\n    if(rmd.x < MAX_DIST) \n    {\n        p = ro + rd * rmd.x;\n        vec3 n = Normal(p);\n        \n        float shine = fract(rmd.z)*abs(rmd.z)/rmd.z;\n        col = Palette(int(floor(abs(rmd.z))));\n        col = Shade(col, shine, p, n, rd, lPos);\n    }\n    \n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 1.5));\n    \n    col = mix(col, bg, disFac);\n    col += pow(rmd.y / float(MAX_STEPS), 2.) * normalize(ambCol) * GLOW_INT;\n    col += disFac * pow(max(dot(rd, normalize(lPos-ro)), 0.), specExp) * sunCol;\n    \n    fragColor = vec4(col,1.0);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = clamp((col * (2.51f * col + 0.03f)) / (col * (2.43f * col + 0.59f) + 0.14f), 0.0f, 1.0f);\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) //Fabrice - easy adaptive super sampling | edited by MK\n{\n    Render(O,U);\n    \n    if (AA_ENAB && fwidth(length(O)) > AA_THRE)\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { Render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++; //Show sampled area\n    }\n    \n    O = PP(vec3(O), (U-.5 * iResolution.xy) / iResolution.y);\n}","name":"Image","description":"","type":"image"}]}