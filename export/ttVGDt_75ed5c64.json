{"ver":"0.1","info":{"id":"ttVGDt","date":"1580246939","viewed":133,"name":"PWC (tonemapping)","username":"0x1D","description":"Piecewise compression (tonemapping) operator.\n\nhttps://www.desmos.com/calculator/auiqrzlull","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["scattering","extinction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float n = 0.0;\nconst float m = 0.05;\nconst float p = 0.05;\nconst float f = 0.25;\nconst float q = 0.35;\nfloat pwc_a(float x)\n{\n    return p * pow((x-n)/(m-n),(q-p)*(m-n)/(p*(f-m)));\n}\nfloat pwc_b(float x)\n{\n    return (q-p)/(f-m)*x-m*(q-p)/(f-m)+p;\n}\nfloat pwc_c(float x)\n{\n    return q+(1.0-q)*(q-p)*(x-f)/((q-p)*(x-f)+(f-m)*(1.0-q));\n}\nfloat pwc(float x)\n{\n    if(x < n)\n        return 0.0f;\n    else if(x < m)\n        return pwc_a(x);\n    else if(x < f)\n        return pwc_b(x);\n    else\n        return pwc_c(x);\n}\nvec3 pwc_tonemapping(vec3 c)\n{\n    return vec3(pwc(c.r), pwc(c.g), pwc(c.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    //fragColor.rgb = pwc_tonemapping(fragColor.rgb * 10.0);\n    fragColor.rgb = ACESFitted(fragColor.rgb * 10.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415927;\n\nfloat bayer2(vec2 v)\n{\n    v=floor(v);\n\treturn fract(v.y * v.y * 0.75 + v.x * 0.5);   \n}\n\nfloat bayer4(vec2 v)\n{\n    return bayer2(0.5 * v) * 0.25 + bayer2(v);\n}\n\nfloat bayer8(vec2 v)\n{\n    return bayer4(0.5 * v) * 0.25 + bayer2(v);\n}\n\nfloat bayer16(vec2 v)\n{\n    return bayer8(0.5 * v) * 0.25 + bayer2(v);\n}\n\nvec3 tonemapACESRec709(vec3 x)\n{\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Krzysztof's curve is pre-exposed\n    x *= 0.6;\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 tonemapACESRec2020(vec3 x)\n{\n    x *= 0.6;\n    float a = 15.8;\n    float b = 2.12;\n    float c = 1.2;\n    float d = 5.92;\n    float e = 1.9;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat phaseIso()\n{\n    return 1.0 / (4.0 * pi);\n}\n\nfloat phaseHG(float ct, float g)\n{\n    float af = (1.0 - g*g) / pow(1.0 + g * g - 2.0 * g * ct, 3.0 / 2.0);\n    return phaseIso() * af;\n}\n\nfloat phaseL(float ct, float g)\n{\n    float z = g * pow((1.0 + 8.0 * pi - sqrt(1.0f + 32.0f * pi)) / (8.0 * pi), g * g);\n    return phaseHG(ct, z - 0.00001);\n}\n\nfloat toSRGB(float x)\n{\n\tif(x < 0.0031308 )\n    \tx *= 12.92;\n\telse\n\t\tx = 1.055 * pow(x, 1.0 / 2.4) - 0.055;\n\treturn x;\n}\n\nvec3 toSRGB(vec3 x)\n{\n    return vec3(toSRGB(x.x), toSRGB(x.y), toSRGB(x.z));\n}\n\nfloat toLinear(float x)\n{\n    if(x < 0.04045)\n    \tx /= 12.92;\n    else\n        x = pow((x + 0.055) / 1.055, 2.4);\n    return x;\n}\n\nvec3 toLinear(vec3 x)\n{\n    return vec3(toLinear(x.x), toLinear(x.y), toLinear(x.z));\n}\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nmat3x3 ACESInputMat = mat3x3(\n    vec3(0.59719, 0.35458, 0.04823),\n    vec3(0.07600, 0.90834, 0.01566),\n    vec3(0.02840, 0.13383, 0.83777)\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nmat3x3 ACESOutputMat = mat3x3(\n    vec3( 1.60475, -0.53108, -0.07367),\n    vec3(-0.10208,  1.10813, -0.00605),\n    vec3(-0.00327, -0.07276,  1.07602)\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 scatterLight(vec3 position, float g, vec3 light_position, vec3 light_intensity)\n{\n    vec3 to_light = light_position - position;    \n    vec3 light_dir = normalize(to_light);\n    float light_dist_sq = dot(to_light, to_light);\n    float attenuation = 1.0 / light_dist_sq;    \n    float phase = phaseL(dot(-normalize(position), light_dir), g);        \n    return light_intensity * attenuation * phase;\n}\n\nvoid getMedia(vec3 position,\n    \t\t\t\t\tout float phase_g,    \n    \t\t\t\t\tout float density,\n    \t\t\t\t\tout vec3 absorption,\n\t    \t\t\t\tout vec3 emissive)\n{\n    phase_g = 0.1;\n    density = 0.05;\n    absorption = vec3(0.5, 0.5, 0.5);\n    emissive = vec3(0.0, 0.0, 0.0);\n}\n\nvec3 scatterLights(vec3 position, float g)\n{\n    vec3 light_positions[] =\n    vec3[](\n        vec3(-20.0, 20.0, 20.0 * cos(iTime)),\n        vec3(20.0, 20.0, 20.0 * sin(iTime)),\n        vec3(20.0 * cos(iTime), -20.0, 20.0 * sin(iTime))\n    );\n    vec3 light_intensities[] = \n    vec3[](\n        vec3(10.0, 1000.0, 10.0),\n        vec3(1000.0, 10.0, 10.0),\n        vec3(10.0, 10.0, 1000.0)\n    );\n    vec3 scattering = vec3(0.0);\n    for(uint i = 0u; i < 3u; ++i)\n        scattering += scatterLight(position, g, light_positions[i], light_intensities[i]);\n\treturn scattering;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uvec2 checker_coord = uvec2(fragCoord.xy / 16.0) & 1u;\n    float checker = float(checker_coord.x ^ checker_coord.y);\n    fragColor = vec4(checker);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 huv = uv * 2.0 - 1.0;\n    \n    uint steps = 32u;\n    float dist = 100.0f;\n    float step_dist = dist / float(steps);\n    \n    vec3 extinction = vec3(1.0);\n    vec3 scattering = vec3(0.0);\n    vec3 eye = vec3(0.0, 0.0, -50.0);\n    vec3 start = vec3(0.0);\n    for(uint i = 0u; i < steps; ++i)\n    {    \n        float depth = float(i) * step_dist;\n        vec3 end = vec3(huv * depth, depth);\n        {\n            float step_len = distance(start, end);\n            \n            float noise = bayer16(fragCoord.xy);\n            vec3 position = eye + mix(start, end, noise);\n            \n\t\t\tfloat phase_g;\n    \t\tfloat density;\n    \t\tvec3 absorption;\n\t    \tvec3 emissive;\n            getMedia(position, phase_g, density, absorption, emissive);\n\n\t        vec3 out_scatter = 1.0 - vec3(phaseL(1.0f, phase_g));\n    \t\tvec3 extinction_coeff = density * (absorption + out_scatter);\n        \n        \tvec3 lighting = scatterLights(position, phase_g);\n        \tvec3 in_scatter = density * (emissive + lighting);\n        \n        \tvec3 transmittance = exp(-extinction_coeff * step_len);\n        \tvec3 integrated_in_scatter = in_scatter * (1.0 - transmittance) / extinction_coeff;\n        \n        \textinction *= transmittance;\n\t\t\tscattering += extinction * integrated_in_scatter;\n        }\n        start = end;\n    }\n\n    fragColor.rgb *= extinction;\n    fragColor.rgb += scattering;\n    \n    fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, uv + 0.0 / iResolution.xy).rgb, 0.5);\n}","name":"Buffer A","description":"","type":"buffer"}]}