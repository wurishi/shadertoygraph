{"ver":"0.1","info":{"id":"ddSyWd","date":"1688343463","viewed":134,"name":"Cosine gradient generator polar","username":"Envy24","description":"Recreation of this great site:\nhttp://dev.thi.ng/gradients/\nCartesian part: https://www.shadertoy.com/view/DdBcDc#","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["gradient","polar","cosine","generator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UNIT                      ( 4.0 / iResolution.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvec2 cartesian(vec2 z) { return z.x * vec2(cos(z.y), sin(z.y)); }\nvec2 polar(vec2 z) { return vec2(length(z), atan(z.y, z.x)); } // atan2 implementation: https://www.shadertoy.com/view/csf3Wl\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n/**/\n#define DC_OFFSET  vec3(0.500, 0.500, 0.500)\n#define AMP        vec3(0.500, 0.500, 0.500)\n#define FREQ       vec3(1.000, 1.000, 1.000)\n#define PHASE      vec3(0.000, 0.333, 0.667)\n/**\n#define DC_OFFSET  vec3(0.500, 0.500, 0.500)\n#define AMP        vec3(1.000, 1.000, 1.000)\n#define FREQ       vec3(1.000, 1.000, 1.000)\n#define PHASE      vec3(0.000, 0.333, 0.667)\n/**\n#define DC_OFFSET  vec3(0.000, 0.500, 0.500)\n#define AMP        vec3(0.000, 0.500, 0.500)\n#define FREQ       vec3(0.000, 0.500, 0.333)\n#define PHASE      vec3(0.000, 0.500, 0.667)\n/**\n#define DC_OFFSET  vec3(0.660, 0.560, 0.680)\n#define AMP        vec3(0.718, 0.438, 0.720)\n#define FREQ       vec3(0.520, 0.800, 0.520)\n#define PHASE      vec3(-0.430, -0.397, -0.083)\n/**/\nfloat cosOSC(float x, float DC, float A, float F, float P)\n{\n#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n    return clamp(( DC + A * cos(TAU*P + F*x) ), 0., 1.);\n}\nvec3 palette(float x)\n{\n    return clamp(( DC_OFFSET + AMP * cos(TAU*(PHASE + FREQ*x)) ), 0., 1.);\n}\n\nfloat polarSDF(vec2 NDC, float DC, float A, float F, float P)\n{      \n    float tmin = 0.,\n          tmax = TAU,\n          s = (tmax - tmin) / 300.,\n          min_dist = 99.;\n    \n    for (float i = 0.; i < 300.; i += 1.)\n    {\n        float t = tmin + s * i,            nt = tmin + s * (i + 1.),\n              r = cosOSC(t, DC, A, F, P),  nr = cosOSC(nt, DC, A, F, P);\n              \n        vec2 P = vec2(r * cos(t), r * sin(t)),\n             nP = vec2(nr * cos(nt), nr * sin(nt));\n\n            min_dist = min(min_dist, segmentSDF_L2(NDC, P, nP, 0.));\n    }\n    \n    return min_dist;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1.02, vec2(-0.5, 0.), false);\n\n    NDC.y = -NDC.y; // I don't know why Y axis is flipped in original.\n                    // Maybe i just didn't understand something...\n\n    vec3 color = vec3(1);   \n    //Polar grid visualization.\n    float h = 1. / 4.;\n    for (float i = 1.; i < 5.; i += 1.)\n    {\n        color = mix(color, vec3(0), SMAA(abs(diskSDF_L2(NDC, vec2(0), h*i)))  * 0.2);\n    }\n    float a = 2.*3.141592 / 16.;\n    for (float i = 1.; i < 17.; i += 1.)\n    {\n        float theta = a * i;\n        vec2 E = vec2(cos(theta), sin(theta));\n        \n        color = mix(color, vec3(0), SMAA(segmentSDF_L2(NDC, vec2(0), E, 0.)) * 0.2);\n    }\n    // Functions visualization.\n    float r_dist = polarSDF(NDC, DC_OFFSET.r, AMP.r, FREQ.r, PHASE.r),\n          g_dist = polarSDF(NDC, DC_OFFSET.g, AMP.g, FREQ.g, PHASE.g),\n          b_dist = polarSDF(NDC, DC_OFFSET.b, AMP.b, FREQ.b, PHASE.b);\n    color = mix(color, vec3(1,0,0), SMAA(r_dist));\n    color = mix(color, vec3(0,1,0), SMAA(g_dist));\n    color = mix(color, vec3(0,0,1), SMAA(b_dist));    \n    // Gradient visualization.\n    if (NDC.x >= -1.8 && NDC.x <= -1.6 && NDC.y >= -1.0 && NDC.y <= 1.0)\n    {\n        color = min(palette((NDC.y+1.)*.5), color);     \n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}