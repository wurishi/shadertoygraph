{"ver":"0.1","info":{"id":"wldSWs","date":"1581985315","viewed":98,"name":"Movement Interpolation Schemes","username":"JackSolace","description":"Visual demonstration of several interpolation schemes including linear mix, exp mix, smoothstep (Perlin), and inverse smoothstep.\n\ntiming and slow-in, slow-out prep","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray","sphere","animation","interpolation","march","learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Feb 2020\n//Visual demonstration of several interpolation schemes including linear mix, exp mix, smoothstep (Perlin), and inverse smoothstep.\n\n\n#define PI 3.14159265359\n#define AA 1\n#define LOOP_TIME 2.0\n#define BALLSIZE 0.4\n#define ANIM_RANGE 3.0\n\n//Ray hit struct\nstruct Hit {\n\tvec3 pos;\n    vec3 normal;\n    float mat;\n};\n   \n//ray struct\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\n\n//geometric attenuation (or shadow factor)\nfloat geometric_attenuation(float roughness, float normal_look_angle, float normal_light_angle)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = normal_light_angle * sqrt(normal_look_angle * (normal_look_angle - normal_look_angle * r2) + r2);\n\tfloat gl = normal_look_angle * sqrt(normal_light_angle* (normal_light_angle - normal_light_angle * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\n//microfacets (minute roghness in the surface)\nfloat microfacet_distribution(float roughness, float normal_half_angle){\n\tfloat r2 = roughness * roughness;\n\tfloat d = (normal_half_angle * r2 - normal_half_angle) * normal_half_angle + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\n//Fresnel Reflection coefficient (vector)\nvec3 fresnel_vec(vec3 specular_color,float look_light_angle) {\n\treturn specular_color + (1.0 - specular_color) * pow((1.0 - look_light_angle),5.0);\n}\n\n//Fresnel Reflection coefficient (scalar)\nfloat fresnel_scalar(float f0, float f90, float look_half_angle) {\n    return f0 + (f90 - f0) * pow(1.0 - look_half_angle, 5.0);\n}\n\nfloat Burley(float linearRoughness, float normal_look_vector, float normal_light_angle, float light_half_angle) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * light_half_angle * light_half_angle;\n    float lightScatter = fresnel_scalar(1.0, f90, normal_light_angle);\n    float viewScatter  = fresnel_scalar(1.0, f90, normal_look_vector);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 spherical_harmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 dfg_karis(float roughness, float normal_look_angle) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * normal_look_angle)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//From IQ ellipsoid approximation\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere(vec3 pos, vec3 c, float r) {\n\treturn length(pos - c) - r;\n}\n\n//distance to plane\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n//Interpolation code\n//-------------------------------------------------------------------------------------\n//analytic inverse smoothstep\nfloat invsmoothstep(float a, float b, float i) {\n\ti = clamp(i,0.0,1.0);\n    return mix(a,b,0.5 - sin(asin(1.0 - 2.0*i)/3.0)); \n}\n\n\n//Ken Perlin's smootherstep\n//similar to smoothstep() but higher exponent and 0 1st and 2nd derivatives\nfloat smootherstep(float a, float b, float i) {\n    i = clamp(i,0.0,1.0);\n    return mix(a,b,i*i*i*(i*(i * 6.0 - 15.0) + 10.0));\n    \n}\n\nfloat expmix(float a, float b, float i , float ex) {\n\ti = clamp(i,0.0,1.0);\n    return mix(a,b,pow(i,ex));\n}\n\nfloat lerp(float a, float b, float w){\n    return a*(1.0 - w) - b*w;\n}\n\n//-------------------------------------------------------------------------------------\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\n//x  index is distance, y index is material type (sometimes other meta info)\nvec2 map_the_world(in vec3 p)\n{\n    float time = mod(iTime, LOOP_TIME);\n    vec3 center0 = vec3(lerp(-ANIM_RANGE,ANIM_RANGE,time/LOOP_TIME),0.0,0.0);\n    vec3 center1 = vec3(expmix(-ANIM_RANGE,ANIM_RANGE,time/LOOP_TIME, 2.0),1.0,0.0);\n    vec3 centern1 = vec3(expmix(ANIM_RANGE,-ANIM_RANGE, 1.0 - time/LOOP_TIME, 2.0),-1.0,0.0);\n    vec3 center2 = vec3(smootherstep(-ANIM_RANGE,ANIM_RANGE,time/LOOP_TIME),2.0,0.0);\n    vec3 centern2 = vec3(invsmoothstep(-ANIM_RANGE,ANIM_RANGE,time/LOOP_TIME),-2.0,0.0);\n    \n    //vec3 center0 = vec3(mix(-ANIM_RANGE,ANIM_RANGE,time/LOOP_TIME),0.0,0.0);\n    //vec3 center1 = vec3(expmix(-ANIM_RANGE,ANIM_RANGE,time/LOOP_TIME, 2.0),1.0,0.0);\n    //vec3 centern1 = vec3(expmix(ANIM_RANGE,-ANIM_RANGE, 1.0 - time/LOOP_TIME, 2.0),-1.0,0.0);\n    //vec3 center2 = vec3(smootherstep(-ANIM_RANGE,ANIM_RANGE,time/LOOP_TIME),2.0,0.0);\n    //vec3 centern2 = vec3(invsmoothstep(-ANIM_RANGE,ANIM_RANGE,time/LOOP_TIME),-2.0,0.0);\n    \n    \n    float to_sphere = sdSphere(p, center0 ,BALLSIZE);\n    to_sphere = min(to_sphere,sdSphere(p, center1 ,BALLSIZE));\n    to_sphere = min(to_sphere,sdSphere(p, centern1 ,BALLSIZE));\n    to_sphere = min(to_sphere,sdSphere(p, center2 ,BALLSIZE));\n    to_sphere = min(to_sphere,sdSphere(p, centern2 ,BALLSIZE));\n\n    return vec2(to_sphere, 1.0);\n\n\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ).x );  \n}\n\n//PB Rendering Code\n//-------------------------------------------------------------------------------------\n//Basic RayMarch\nHit march_ray(Ray ray, float tmax) {\n\tfloat t = 0.0;//current depth\n    float m = 0.0;\n    vec3 pos = vec3(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        pos = ray.origin + t*ray.direction;\n        //get dist to nearest surface\n        vec2 h = map_the_world(pos);\n        m = h.y;\n        //if we hit something break\n        if( h.x<0.0001) break;\n        if( t > tmax){m = 0.0; break;}\n        //step forward\n        t += h.x*0.9;\n    }\n    return Hit(pos, calculate_normal(pos), m);\n}\n\nvec3 render_ray(Ray ray) {\n\t// init \"sky\" color\n    vec3 color = vec3(0.5, 0.8, 1.0) * (1.0 + ray.direction.y) * 0.8;\n\n    // raytrace\n    Hit result = march_ray(ray,8.0);\n\n    vec3 light_pos = vec3(10.0);\n    vec3 light_dir = normalize(result.pos - light_pos);\n    vec3 look = -ray.direction;//vector to camera\n    \n    if (result.mat > 0.999){//hit someting\n       \n        vec3 half_vec = normalize(look - light_dir);\n        \n        //important angles\n        float normal_look_angle = clamp(dot(result.normal, look),0.0,1.0);\n        float normal_light_angle = clamp(dot(result.normal, normalize(light_pos)), 0.0,1.0);\n        float look_light_angle = clamp(dot(look, normalize(light_pos)), 0.0,1.0);\n        float normal_half_angle = clamp(dot(result.normal, half_vec), 0.0,1.0);\n        float look_half_angle = clamp(dot(look,half_vec), 0.0,1.0);\n        float light_half_angle = clamp(dot(normalize(light_pos),half_vec), 0.0,1.0);\n        \n        //material constants (play with these)\n        float metallic = 0.0; \n        float reflect_intensity = 1.0;\n        float specular_intensity = 2.5;\n        float roughness = 0.0;\n   \t\t\n        vec3 base_color = vec3(0.0);\n        //shadow check ray\n        Ray shadow_ray = Ray(result.pos+0.01*light_pos, normalize(light_pos));\n       \t//Ray Trace shadow\n        Hit shadow = march_ray(shadow_ray, 8.0);\n            \n        if (result.mat > 1.999) {//plane (play with theses values)\n            //checkerboard\n            base_color = 0.4 + mod(floor(6.0 * result.pos.z) + floor(6.0 * result.pos.x), 2.0)*vec3(0.5);\n            roughness = 0.1;//play with this\n        }else{//sphere (play with these values)\n        \tbase_color = vec3(0.2,0.2,0.2);//sphere color\n            roughness = 0.3;//play with this\n        }\n        \n        \n        \n        float linear_roughness = roughness*roughness;\n        //init specular color\n        vec3 specular_initial = 0.04 * (1.0 - metallic) + base_color*metallic;\n        //init diffuse color\n        vec3 diffuse_initial = (1.0 - metallic) * base_color;\n        // Cook-Torrance\n        vec3 specular = (microfacet_distribution(linear_roughness,normal_half_angle) \n            \t\t* geometric_attenuation(linear_roughness, normal_look_angle, normal_light_angle))\n            \t\t* fresnel_vec(specular_initial,light_half_angle); \n       \t//This is the wierd one (lots of different solutions dpending on what you read)\n        vec3 diffuse = diffuse_initial * Burley(linear_roughness, normal_look_angle, normal_light_angle, light_half_angle);\n        \n        //combine\n        color = diffuse + specular;\n\n        //alter combo by shadows and light angle\n        color *= (specular_intensity * clamp( 1.0 - shadow.mat, 0.0, 1.0) * normal_light_angle);\n        //Reflection Check\n        vec3 ref_dir = reflect(ray.direction, result.normal);\n       \tRay reflected_ray = Ray(result.pos + 0.03*ref_dir,ref_dir);\n        Hit reflected = march_ray(reflected_ray,8.0);\n        \n        \n        //reflected Diffuse calculation\n        vec3 reflected_diffuse = spherical_harmonics(result.normal) * (1.0/PI);\n        //reflected Specular initial\n        vec3 reflected_specular = vec3(0.65, 0.85, 1.0) + reflected_ray.direction.y * 0.8;\n        //what did the reflect hit?\n        if (reflected.mat > 0.999) {\n            if (reflected.mat > 1.999) {\n                //reflected onto the gorund\n            \treflected_specular = 0.4 + mod(floor(6.0 * reflected.pos.z) + floor(6.0 * reflected.pos.x), 2.0)*vec3(0.5);\n            }else{\n                //reflected onto the sphere\n            \treflected_specular = vec3(0.2,0.2,0.2);\n            }\n        }\n        \n        //how to combine the diffuse and specular reflections\n        vec2 dfg = dfg_karis(roughness, normal_look_angle);\n        vec3 spec_color = specular_initial * dfg.x + dfg.y;\n        vec3 reflected_combo = diffuse_initial * reflected_diffuse + reflected_specular * spec_color; \n        //combine 1st and second bounces\n        color += reflected_combo*reflect_intensity;\n        \n    }\n\n    // gamma color calculation    \n    return color;\n}\n\n//-------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n//Camera + Ray Setup\n//----------------------------------------------------------------------\n    // camera movement\t\n\tfloat an = 0.5*(PI);\n\tvec3 ray_origin = vec3( 3.0*cos(an), 0.4, 3.0*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize total color\n    vec3 total = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n    #else  \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    #endif\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.0*ww );\n    \n    Ray ray = Ray(ray_origin, ray_direction);\n    \n//Render Fragment\n//----------------------------------------------------------------------\n    \n\ttotal += render_ray(ray);\n        \n    #if AA>1\n    }\n    total /= float(AA*AA);\n    #endif\n\n    total = pow(total, vec3(1.0/2.2));\n    \n\tfragColor = vec4( total, 1.0 );\n}","name":"Image","description":"","type":"image"}]}