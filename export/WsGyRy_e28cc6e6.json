{"ver":"0.1","info":{"id":"WsGyRy","date":"1603072614","viewed":316,"name":"My Mandelbulb","username":"edorobek","description":"For CPSC479","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","ray","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n\n#define ANIMATE 0\n#define MAX_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n#define AA 3\n\nfloat dot2(in vec2 v) { return dot(v,v); }\n\n\n\n\n\nfloat mandelbulb(vec3 pos) {\n    float Power = 3.0 + 5.0;\n\tfloat ThetaShift = iTime * .2;\n\tfloat PhiShift = iTime * .2;\n    \n    if(length(pos) > 1.5) return length(pos) - 1.2;\n    vec3 z = pos;\n    float dr = 1.0, r = 0.0, theta, phi;\n    for (int i = 0; i < 15; i++) {\n        r = length(z);\n        if (r>1.5) break;\n        dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n        theta = acos(z.z/r) * Power + ThetaShift;\n        phi = atan(z.y,z.x) * Power + PhiShift;\n        float sinTheta = sin(theta);\n        z = pow(r,Power) * vec3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) + pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\n// Combinations\nfloat unionOp(float d1, float d2) { return min(d1,d2); }\nvec2 unionOp(vec2 d1, vec2 d2) { return (d1.x<d2.x) ? d1 : d2; }\nfloat subtractOp(float d1, float d2) { return max(-d1,d2); }\nvec2 subtractOp(vec2 d1, vec2 d2) { return (-d1.x > d2.x) ? -d1 : d2; }\nfloat intersectOp(float d1, float d2) { return max(d1,d2); }\nvec2 intersectOp(vec2 d1, vec2 d2) { return (d1.x > d2.x) ? d1 : d2; }\n\nfloat smoothUnionOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec2 smoothUnionOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvec2 smoothSubOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp(0.5 - 0.5*(d2.x + d1.x)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0 - h); \n}\n\nfloat smotherIntersectOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2 - d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0 - h); \n}\n\nvec2 smotherIntersectOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2.x - d1.x)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*h*(1.0 - h); \n}\n\n\n\n\n/* Experimental smooth minimum function s*/\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminA( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// power smooth min (k = 8);\nfloat sminB( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    \n    \n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n/* Transformations */\n\n// rotation and scaling\nvec3 linearTOp(vec3 p, mat4 transform)\n{\n\treturn (inverse(transform)*vec4(p,1.0)).xyz;\n}\n\nvec3 translateOp(vec3 p, vec3 h)\n{\n\treturn p - h;\n}\n\n// NOTE: YOU MUST MULTIPLY RESULTING DISTANCE BY 's'\nvec3 scaleOp(vec3 p, float s)\n{\n\treturn p / s;\n}\n\n/* Deformations */\n\n// Displacement: SDF(p) + displace(p)\n\n// ALTERATIONS\n\nvec4 elongateOP(vec3 p, vec3 h)\n{\n\tvec3 q = abs(p)-h;\n\treturn vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0));\n}\n\nfloat roundOp(float d, float h)\n{\n    return d - h;\n}\n\nvec3 twistOp(vec3 p, float k)\n{\n\tfloat c = cos(k*p.y);\n\tfloat s = sin(k*p.y);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn vec3(m*p.xz,p.y);\n\t\n}\n\nvec3 bendOp(vec3 p)\n{\n\tconst float k = 10.;\n\tfloat c =  cos(k*p.x);\n\tfloat s = sin(k*p.x);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m*p.xy, p.z);\n}\n\n\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1e10, 0.0);\n\t{\n\t\t// PLANE COLOR CODE MUST BE < 1.5\n\t\tresult = unionOp(result, vec2(mandelbulb(p), 4.1)); \n}\n\t\n\treturn result;\n}\n\nconst float sunIntensity = 1.2;\nconst vec3 sunColor = sunIntensity*vec3(1.30,1.00,0.60);\n\nvec3 background(vec3 q)\n{\n\treturn mix( vec3(0.3,0.3,0.8)*0.5, vec3(0.6, 0.8, 1.0), 0.7 + 0.5*q.y );\n}\n\n\n// intersect ray with the scene\nvec2 raycast(vec3 ro, vec3 rd)\n{\n\tvec2 result = vec2(-1.0);\n\tfloat t = MIN_DIST;\n\tfor (int i =0; i < MAX_STEPS && t < MAX_DIST; i++) {\n\t\tvec2 h = map(ro + t*rd);\n\t\tif (abs(h.x) < (EPSILON*t)) {\n\t\t\tresult = vec2(t, h.y);\n\t\t\tbreak;\n\t\t}\n\t\tt += h.x;\n\t}\n\t\n\treturn result;\n}\n\n// get direction of ray with just device coordinates\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n// calculate the normal via finite differences\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 light = normalize( vec3(-0.5, 0.4, 0.6) );\n\n\nvec3 render(vec3 ro, vec3 rd, vec3 rdx, vec3 rdy)\n{\n\t// background\n\tvec3 col = background(rd);\n\t\n\tvec2 tmat = raycast(ro, rd);\n\tfloat t = tmat.x;\n\tfloat m = tmat.y;\n\tif (m > -1.) {\n\t\n\t\t\n\t\tcol = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n\t\n\t\tvec3 pos = ro + tmat.x*rd;\n\t\tvec3  hal = normalize(light - rd );\n\t\tvec3 norm = (m < 1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n\t\tvec3 ref = reflect( rd, norm );\n\t\t\n\t\tif( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            //vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            //vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            col = vec3(0.30);\n            ks = 0.1;\n        }\n\t\t\n\t\tfloat occ = calcAO(pos, norm); \n\t\tvec3 lin = vec3(0.0);\n\t\t\n\t\t// sun\n\t\t{\n            vec3  hal = normalize( light-rd );\n            float dif = clamp( dot( norm, light ), 0.0, 1.0 );\n        \t      dif *= calcSoftshadow( pos, light, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.16*pow(clamp(1.0-dot(hal,light),0.0,1.0),2.0);\n            lin += col*2.20*dif*sunColor;\n            lin +=     5.00*spe*sunColor*ks;\n        }\n        \n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+1.5*norm.y, 0.0, 1.0 ));\n            dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n            spe *= dif;\n            spe *= 0.04+0.96*pow(clamp(1.0+dot(norm,rd),0.0,1.0), 5.0 );\n            spe *= calcSoftshadow( pos, ref, 0.02, 4.2 );\n            lin += col*0.70*dif*background(rd);\n            lin +=     1.30*spe*background(rd)*ks;\n        }\n        col = lin;\n\n\t\t// falloff (fakes a depth blur)\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.00002*t*t*t ) );\n\t}\n\t\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 tot = vec3(0.);\n    for (int m =0; m < AA; m++)\n    for (int n =0; n < AA; n++)\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord + o);\n    \tvec3 eye = vec3(-2.0, 3.0, 6.0);\n        \n        mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    \tvec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n  \t\t// ray derivatives\n    \tvec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    \tvec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    \tvec3 rdx = (viewToWorld * normalize( vec4(px,2.5, 1.0) )).xyz;\n    \tvec3 rdy = (viewToWorld * normalize( vec4(py,2.5, 1.0) )).xyz;\n    \n    \tvec3 col = render(eye, worldDir, rdx, rdy);\n        tot += col;\n    \n    }\n    \n    tot /= float(AA*AA);\n\n\tfragColor = vec4(tot, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}