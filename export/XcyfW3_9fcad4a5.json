{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// The original palette function as given:\nvec3 palette ( float t ) {\n    vec3 a = vec3 (0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b * cos(6.28318*(c*t + d));\n}\n\n// A simple rotating camera:\nmat3 setCamera(in vec3 ro, in vec3 ta, float roll) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(roll), cos(roll),0.);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Distance function: A repeating pattern of spheres\n// We first apply a fractal transform to the position, similar to the UV transformations in 2D.\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// We create a scene with repeated spheres using fract\n// and a deformation that is somewhat inspired by the original code's approach.\nfloat mapScene(vec3 p, float time) {\n    // Similar to the original codeâ€™s fract transform in 2D,\n    // apply a repeating transformation in 3D:\n    for (float i = 0.0; i < 3.0; i += 0.5) {\n        p = fract(p * 1.5) - 0.5; \n        float d = length(p);\n        // Apply a sinusoidal deformation based on time\n        d = d + (sin(d*12.0 + time)/12.0);\n        // We'll just return the distance to a sphere of small radius, \n        // but influenced by 'd' to get some interesting structure:\n        // To create a pattern, we shift the radius slightly based on i.\n        float sphereDist = sdSphere(p, 0.3 + 0.05*sin(i + time));\n        // We accumulate the minimal distance:\n        if (i == 0.0) {\n            // Initialize the distance with the first iteration\n            p.x += sin(time)*0.1; // slight shift for variation\n            sphereDist = sdSphere(p, 0.3);\n            return sphereDist;\n        } \n    }\n    return sdSphere(p, 0.3);\n}\n\n// Basic normal calculation via numerical gradient\nvec3 calcNormal(vec3 p, float time) {\n    float e = 0.0005;\n    float d = mapScene(p, time);\n    vec3 n = vec3(\n        mapScene(p+vec3(e,0,0), time)-d,\n        mapScene(p+vec3(0,e,0), time)-d,\n        mapScene(p+vec3(0,0,e), time)-d\n    );\n    return normalize(n);\n}\n\n// Simple raymarch\nvec3 raymarch(vec3 ro, vec3 rd, float time) {\n    float t = 0.0;\n    float maxDist = 20.0;\n    for (int i=0; i<100; i++) {\n        vec3 p = ro + rd * t;\n        float dist = mapScene(p, time);\n        if (dist < 0.001) {\n            // Hit something\n            vec3 n = calcNormal(p, time);\n            // Use the palette function based on some combination of p and time.\n            // Let's use length(p) + time as the parameter:\n            vec3 col = palette(length(p) + time * 0.6);\n            // Simple shading with a directional light:\n            vec3 lightDir = normalize(vec3(0.3,0.5,0.7));\n            float diff = clamp(dot(n, lightDir), 0.0, 1.0);\n            col *= diff * 2.0; // enhance brightness\n            return col;\n        }\n        if (t > maxDist) break;\n        t += dist * 0.5;\n    }\n    // Background color\n    return palette(time)*0.2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float time = iTime;\n    \n    // Camera setup\n    vec3 ro = vec3(0.0,0.0,-3.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 cam = setCamera(ro, ta, 0.0);\n    \n    vec3 rd = normalize(cam * vec3(uv.xy,1.5));\n    \n    vec3 col = raymarch(ro, rd, time);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcyfW3","date":"1734498594","viewed":34,"name":"Day 1- nlevin","username":"nlevin","description":"1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""}}