{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define delta 0.00123456f\nconst float pi = radians(180.0f);\n\nfloat partialDerivativeX(vec2 uv , float h ) {\n   \n   float i = texture(iChannel0,uv+vec2(h,0)).s;\n   float f = texture(iChannel0,uv).s;\n\n     float product = (i - f)/h;\n   return product;\n}\nfloat partialDerivativeY(vec2 uv , float h ) {\n   \n   float i = texture(iChannel0,uv+vec2(0,h)).s;\n   float f = texture(iChannel0,uv).s;\n\n     float product = (i - f)/h;\n   return product;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n           \n           float aspect_ratio = iResolution.x/iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 st = uv*2.0f - 1.0f;\n            st.x *= aspect_ratio; \n     \n          uv.x *= aspect_ratio;\n         vec3 blueNoise ;\n           \n       float x = partialDerivativeX(uv,delta);  \n       float y = partialDerivativeY(uv,delta); \n\n     vec3 tangentn = (vec3(1,0,x));\n     vec3 bitange =  (vec3(0,1,y));\n      \n       vec3 normal_m = cross(tangentn,bitange);\n       vec2 tempUV0 = normalize(normal_m+vec3(0,0,30)).xy;\n       normal_m = normalize(normal_m + vec3(0,0,8));\n        \n  \n       float height = texture(iChannel0,uv).s;\n         \n        vec3 worldPosition = vec3(st,height);\n\n        vec3 lightPosition; \n        vec2 mousePos = (iMouse.xy/iResolution.xy)*2.0f - 1.0f;\n           mousePos.x *= aspect_ratio;\n           mousePos.y = 1.0f;\n              lightPosition = (vec3(mousePos.x,1.0f,mousePos.y));\n               lightPosition += blueNoise; \n               lightPosition -= vec3(st.x,0.0,st.y);\n               \n                 vec3 beg = lightPosition;\n                 float relative = pow(length(lightPosition),2.0f); \n                 lightPosition = normalize(lightPosition);\n                 vec3 direction = lightPosition;  \n                   \n                float lm = dot(normal_m,lightPosition);\n                  lm = max(lm,0.0f);\n                   lm /= relative;\n                     lm /= 5.0f;\n          vec3 albedo = texture(iChannel2,tempUV0).rgb * 2.0f;           \n                \n         vec3 col = vec3(6.) * lm;\n          col *= 1.2f;\n          col += 0.0678f;\n          col *= albedo;\n              \n              \n            vec3 compTanspace = clamp(normal_m,vec3(-1),vec3(1))+1.0f; \n              compTanspace /= 2.0f;\n            float rr = Line3D(uv,ivec3(beg),ivec3(direction));\n            \n            vec2 scc = st-min(mousePos,vec2(2,1));\n             bool scc1 = scc.s <0.0; \n            if(scc.x > 0.0f){\n               scc = sin(pi*2.0f/3.0f*scc);\n}           \n              bool trf = scc.s < 0.0;\n                  bool bbf = (float(trf)-float(scc1)) > 0.0;\n           if(trf) {\n      col = col;\n           \n  } else {col = compTanspace;}\n  if((bbf)) {col = normal_m; }       \n                  \n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define RES 128.0\n\n\nfloat visitVoxel (vec2 uv, ivec2 pos)\n{\n\tivec2 pix = ivec2(uv * RES);\n\treturn float((pix == pos));\n}\n\nfloat Line3D(vec2 uv, ivec3 pos, ivec3 dir)  \n{  \n    float c = 0.0;\n\tivec3 s, a, b;\n\t\n    s = sign(dir);\n\n    a = abs(dir);\n\n\tb = a + a;\n\tivec3 e  = ivec3(a.y-a.x,  a.z-a.x, a.y-a.z);\n\t\n    int len = (a.x + a.y);\n\t// This is the traversal...\n    for (int i = 0; i < len; i++)\n\t{\n\t\tc += visitVoxel(uv, pos.xy);  \n\t\tif ( e.x < 0 )\n\t\t{  \n\t\t\tif ( e.y < 0 )\n\t\t\t{  \n\t\t\t\tpos.x += s.x;  \n\t\t\t\te.x += b.y;\n\t\t\t\te.y += b.z;  \n\t\t\t}  \n\t\t\telse\n\t\t\t{  \n\t\t\t\tpos.z += s.z;  \n\t\t\t\te.y -= b.x;\n\t\t\t\te.z += b.y;  \n\t\t\t}  \n\t\t}  \n\t\telse\n\t\t{  \n\t\t\tif ( e.z < 0 )\n\t\t\t{  \n\t\t\t\tpos.z += s.z;  \n\t\t\t\te.y -= b.x;\n\t\t\t\te.z += b.y;  \n\t\t\t}  \n\t\t\telse\n\t\t\t{  \n\t\t\t\tpos.y += s.y;  \n\t\t\t\te.x -= b.x;\n\t\t\t\te.z -= b.z;  \n            }  \n\t\t}  \n    } \n\treturn c;\n} ","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfVfzm","date":"1733902406","viewed":105,"name":"Normal map from tangent and bi","username":"sadekguerrah2","description":"xsc","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["normals"],"hasliked":0,"parentid":"","parentname":""}}