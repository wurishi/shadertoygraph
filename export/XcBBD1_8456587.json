{"ver":"0.1","info":{"id":"XcBBD1","date":"1724856843","viewed":361,"name":"Delaunay SDF To Mesh","username":"luckyballa","description":"relax","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","simulation","particles","specular","edges","jelly","delaunay","corners","voronoitracking","xpbd","selfcollision"],"hasliked":0,"parentid":"4fSBW1","parentname":"Delaunay Love Letter"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y); p *= 2.0;\n\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const uint PARTICLE_COUNT = 500u;\nconst float MAX_VEL = 10.0;\nconst float MOUSE_BRUSH_RADIUS = 96.0;\nconst float DAMPING = 0.5;\n\nconst int MAX_VORONOI_VERTICES = 4; \n\n#define MAX_VELOCITY (MAX_VEL + MAX_VEL * (iMouse.z > 0.0 ?  0.1 : 0.0))\n\n#define pi 3.14159265359\n#define pi2 2.0 * pi\n\nuint hash(inout uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    \n    return x;\n}\n\nfloat randomFloat(inout uint state) {\n    return float(hash(state)) / 4294967296.0;\n} \n\nvec2 randomDir(inout uint state) {\n    float z = randomFloat(state) * 2.0 - 1.0;\n    float a = randomFloat(state) * pi2;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec2(x, y);\n}\n\n#define FLOAT_INF uintBitsToFloat(0x7f800000u)\n#define PI 3.14159265\n\nstruct Entity {\n    vec2 position;\n    vec2 oldPosition;\n};\n\nconst Entity INVALID_ENTITY = Entity(vec2(-FLOAT_INF), vec2(0));\n\n\nuint wrap1d(uint flatId) {\n    return flatId % PARTICLE_COUNT;\n}\n\nvec2 wrap2d(vec2 id, vec2 resolution) {\n    return fract(id / resolution) * resolution;\n}\n\nuint to1d(vec2 id, vec2 resolution) {\n    return uint(id.x + id.y * resolution.x);\n}\n\nivec2 to2d(uint flatId, ivec2 resolution) {\n    return ivec2(flatId, flatId / uint(resolution.x)) % resolution;\n}\n\nEntity decodeEntity(sampler2D sampler, ivec2 id) {\n    vec4 raw = texelFetch(sampler, id, 0);\n    Entity entity;\n    entity.position = raw.rg;\n    entity.oldPosition = raw.ba;\n    return entity;\n}\n\nEntity decodeEntity(sampler2D sampler, uint flatId) {\n    return decodeEntity(sampler, to2d(flatId, textureSize(sampler, 0)));\n}\n\nvec4 encodeEntity(Entity entity) {\n    return vec4(entity.position, entity.oldPosition);\n}\n\nuvec4 fetchClosest(vec2 position, sampler2D voroBuffer) {\n    return floatBitsToUint(texelFetch(voroBuffer, ivec2(wrap2d(position, vec2(textureSize(voroBuffer, 0)))), 0));\n}\n\nuint murmur3( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\nuint rngSeed = 314159265u;\n\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nfloat xorshiftFloat(uint state) {\n    return float(xorshift(state)) / float(0xffffffffU);\n}\n\nuint nextUint() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\n\nfloat nextFloat() {\n    return float(nextUint()) / float(uint(-1));\n}\n\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n\nfloat sdCross( in vec2 p) {\n    vec2 b = vec2(0.625, 0.1);\n    float r = 0.1;\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return (sign(k)*length(max(w,0.0)) + r) - 0.15;\n}\n\nvec2 gsdCross(vec2 p) {\n    const float h = 0.0001;\n    return vec2(\n        sdCross(vec2(p.x + h, p.y)) - sdCross(vec2(p.x - h, p.y)),\n        sdCross(vec2(p.x, p.y + h)) - sdCross(vec2(p.x, p.y - h))\n    ) / (2.0 * h);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint flatID = to1d(floor(fragCoord), vec2(textureSize(iChannel0, 0)));\n    fragColor = encodeEntity(INVALID_ENTITY);\n    if (flatID >= PARTICLE_COUNT)\n        return;\n\n    uint flatSeed = murmur3(flatID); \n    rngSeed = flatSeed;\n\n    Entity current;\n    if (iFrame <= 8) {\n        float angle = nextFloat() * 2.0 * PI;\n        float radius = sqrt(nextFloat()) *  iResolution.x * 0.25;\n    current.position += vec2(cos(angle), sin(angle)) * radius + iResolution.xy * 0.5;\n\n    } else {\n        current = decodeEntity(iChannel0, flatID);\n    }\n\n    vec2 p = (current.position - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y); p *= 2.0;\n\n    uvec4 closest = fetchClosest(current.position, iChannel1);\n    \n    vec2 delta = gsdCross(p);\n    float dist = sdCross(p);\n        \n    if (dist > 0.0) {\n        float cost = dist;\n        float lambda = -cost;\n        vec2 grad = delta / dist;\n        vec2 correction = grad * lambda;\n\n        current.position += correction * 2.0;\n    }\n\n    \n    for (int i = 0; i < 4; i++) {\n        if (closest[i] == flatID || closest[i] == -1u) {\n            continue;\n        }\n\n        Entity other = decodeEntity(iChannel0, closest[i]);\n\n        vec2 delta = current.position - other.position;\n        float dist = length(delta);\n        float dist3 = (dist * dist * dist);\n        \n        vec2 correction = -(1.0 / dist3) * delta;\n            \n        current.position -= correction * 100.0;\n    }\n\n    fragColor = encodeEntity(current);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void sortClosest(\n        inout vec4 distances,\n        inout uvec4 indices, \n        uint index,\n        vec2 center\n        ) {\n    if (index == uint(-1) || any(equal(indices, uvec4(index)))) {\n        return;\n    } \n\n    Entity e = decodeEntity(iChannel0, index);\n    float dist = length(center - e.position);\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);\n        indices = uvec4(index, indices.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); \n        indices = uvec4(indices.x, index, indices.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); \n        indices = uvec4(indices.xy, index, indices.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             \n        indices = uvec4(indices.xyz, index);\n    }\n}\n\nvoid fetchAndSortClosest( inout vec4 distances, inout uvec4 idList, in vec2 samplePoint, in vec2 cellCenter ) {\n    uvec4 ids = fetchClosest(samplePoint, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        sortClosest(distances, idList, ids[i], cellCenter);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec4 closestIndices = uvec4(-1);\n    vec4 bestDistances = vec4(FLOAT_INF);\n    \n    uint seed = uint(iFrame) + uint(fragCoord.x) + uint(fragCoord.y);\n    float rad = 4.0;\n\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    \n    rngSeed = murmur3(uint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n\n    for (int i = 0; i < 16; i++) {\n        sortClosest(bestDistances, closestIndices, wrap1d(nextUint()), fragCoord);\n    }\n\n    fragColor = uintBitsToFloat(closestIndices);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"struct Line {\n    vec2 midpoint;\n    vec2 normal;\n};\n\nstruct VoronoiCell {\n    vec2 vertices[MAX_VORONOI_VERTICES];\n    int vertexCount;\n    float Rk;\n    vec2 triangle[3];\n};\n\nvec2 intersectLines(Line l1, Line l2) {\n    vec2 p1 = l1.midpoint;\n    vec2 p2 = l2.midpoint;\n    vec2 d1 = l1.normal;\n    vec2 d2 = l2.normal;\n    \n    float det = d1.x * d2.y - d1.y * d2.x;\n    if (abs(det) < 1e-6) {\n        return vec2(-1);\n    }\n    \n    float t = ((p2.x - p1.x) * d2.y - (p2.y - p1.y) * d2.x) / det;\n    return p1 + d1 * t;\n}\n\nLine computeBisector(vec2 p1, vec2 p2) {\n    vec2 midpoint = (p1 + p2) * 0.5;\n    vec2 dir = normalize(p2 - p1);\n    vec2 normal = vec2(-dir.y, dir.x);\n    return Line(midpoint, normal);\n}\n\n\nVoronoiCell computeVoronoiCell(vec2 site, uint siteIndex, uvec4 candidates) {\n    VoronoiCell cell;\n    cell.vertexCount = 0;\n    cell.Rk = 0.0; \n    \n    Line bisectors[4];\n    for (int i = 1; i < 4; i++) {\n        vec2 neighbor = decodeEntity(iChannel0, candidates[i]).position;\n        bisectors[i - 1] = computeBisector(site, neighbor);\n    }\n    \n    bisectors[3] = Line(vec2(0), vec2(0, 1));\n    \n    \n    for (int i = 0; i < 3; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            vec2 intersection = intersectLines(bisectors[i], bisectors[j]);\n            if (intersection.x != -1.0) {\n                cell.vertices[cell.vertexCount++] = intersection;\n                if (cell.vertexCount >= MAX_VORONOI_VERTICES) break;\n\n                float distance = length(intersection - site);\n                cell.Rk = max(cell.Rk, distance);\n                \n                uvec4 corenerIndices = floatBitsToUint(texelFetch(iChannel1, ivec2(intersection), 0));\n                uvec3 triangeCandidates = uvec3(candidates[i + 1], candidates[((j + 1) % 4)], siteIndex);\n                if (\n                any(equal(uvec3(corenerIndices[0]),triangeCandidates)) &&\n                any(equal(uvec3(corenerIndices[1]), triangeCandidates)) &&\n                any(equal(uvec3(corenerIndices[2]), triangeCandidates))\n                ) {\n                    cell.triangle[0] = decodeEntity(iChannel0, triangeCandidates.x).position;\n                    cell.triangle[1] = decodeEntity(iChannel0, triangeCandidates.y).position;\n                    cell.triangle[2] = site;\n\n                } \n            }\n        }\n   \n        \n        if (cell.vertexCount >= MAX_VORONOI_VERTICES) break;\n    }\n    \n    return cell;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y); p *= 2.0;\n    uvec4 closestIndices = floatBitsToUint(texelFetch(iChannel1, ivec2(fragCoord), 0));\n    uint seedId = closestIndices[0];\n    vec2 closestPos = decodeEntity(iChannel0, seedId).position;\n    \n    VoronoiCell cell = computeVoronoiCell(closestPos, seedId, closestIndices);\n\n    float crss = sdCross(p);\n    float mdist = 99999.0;\n    for (int i = 0; i < cell.vertexCount; i++) {\n        vec2 current = cell.vertices[i];\n        vec2 next = cell.vertices[(i + 1) % cell.vertexCount];\n\n        mdist = min(mdist, sdSegment(fragCoord, cell.triangle[0], cell.triangle[1]) - 1.0);\n        mdist = min(mdist, sdSegment(fragCoord, cell.triangle[1], cell.triangle[2]) - 1.0);\n        mdist = min(mdist, sdSegment(fragCoord, cell.triangle[2], cell.triangle[0]) - 1.0);\n\n    }\n\n    vec3 col = vec3(0.8);\n    float contour = smoothstep(0.01, 0.0, abs(crss));\n    col = mix(vec3(contour), col, smoothstep(0.5, 0.3, contour));\n    \n     col = mix(col, vec3(0.5), smoothstep(0.7, 0.5, mdist));\n    col = mix(col, vec3(1.0), smoothstep(0.5, 0.3, mdist));\n    col = mix(col, vec3(0.5),  smoothstep(4.0, 3.4, length(closestPos - fragCoord)));\n    col = mix(col, vec3(1.0, 0.5, 0.0),  smoothstep(3.01, 3.0, length(closestPos - fragCoord)));\n\n    fragColor = vec4(col * (crss < 0.0 ? 1.0 : 0.88), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}