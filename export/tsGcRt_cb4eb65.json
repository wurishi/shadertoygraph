{"ver":"0.1","info":{"id":"tsGcRt","date":"1603470174","viewed":255,"name":"Mandelbrot With Lighting","username":"NivBehar","description":"Mandelbrot set with a lighting method i saw here: \nhttps://www.math.univ-toulouse.fr/~cheritat/wiki-draw/index.php/Mandelbrot_set#Normal_map_effect\n\nuse the mouse for different scenes","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define ITERATIONS 150.\n#define COLOR_REPEAT 0.3\n#define time iTime\n#define MANIPULATED 1.\n\nvec2 rot(vec2 p, vec2 pivot, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n    p += pivot;\n\n    return p;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n\n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat TriangleDist(vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\n// calculate light\n// https://www.math.univ-toulouse.fr/~cheritat/wiki-draw/index.php/Mandelbrot_set#Normal_map_effect\nfloat calc_light(vec2 z, vec2 der, float h, float angle)\n{\n    //float h = 1.3;  // height factor of the incoming light  \n    //float angle = PI/5.;// + sin(time)*0.3; // incoming direction of light\n    vec2 v = vec2 (cos(angle), sin(angle)); // unit 2D vector in this direction\n    vec2 u = (1./(der.x*der.x + der.y*der.y))*vec2(z.x*der.x + z.y*der.y, z.y*der.x - z.x*der.y);// = z/der\n    u = u/length(u); // normal vector: (u.re,u.im,1)\n    float t = (u.x*v.x + u.y*v.y) + h; // dot product with the incoming light\n    t = t/(1.+h); // rescale so that t does not get bigger than 1\n    if(t<0.)\n        t = 0.;\n    float light = mix(1.,0.,t);\n    return light;\n}\n\nvec3 iterate(vec2 UV , float distance_type, float manipulated)\n{\n    vec3 col;\n\tvec3 end_col = vec3(0.);\n    float uv_rot_speed = time*0.1;\n\tUV += 0.5*vec2(sin(uv_rot_speed), cos(uv_rot_speed));\n    vec2 z = UV;\n    // shape = z for regular mandelbrot set\n    // a; 0       ; (GOLDEN-2); 0.285; 0.285; 0.45  ; -0.70176; -0.835 ; -0.8 ; -0.7269; -0.754\n    // b; 1-GOLDEN; (GOLDEN-1); 0    ; 0.01 ; 0.1428; -0.3842 ; -0.2321; 0.156; 0.1889; -0.066\n    //float2 shapes[11] = {z, float2(0, 1-GOLDEN), float2(GOLDEN-2, GOLDEN-1), float2(0.285, 0.), float2(0.285, 0.01), float2(0.45, 0.1428), float2(-0.70176, -0.3842), float2(-0.835, -0.2321),\n    //    \t\t\t\t float2(-0.8, 0.156), float2(-0.7269, 0.1889), float2(-0.754, -0.066)};\n    vec2 shape;\n    shape = vec2(0.285, 0.0103);\n    //shape = vec2(-0.70176, -0.3842);\n    //shape = z;\n\n    vec2 dc = vec2(1.,0.);\n    vec2 der = dc;\n    vec2 prev_der;\n    \n    float r = 100.;\n\n    float i;\n    for(i = 0.; i<ITERATIONS; i++ )\n    {\n\n        \n        if(manipulated == MANIPULATED) // left side\n        {\n        \t//vec2 z2 = rot(z, vec2(0.), time*0.4);\n        \t//r = 2. + 1.*HexDist(0.5 + 2.*sin(cos(z2)*0.5)*cos(cos(z2*3.)));\n            vec2 z1 = 10.*z/dot(z+0.2*cos(z+time*0.),z+0.2*sin(z+time*0.));\n            vec2 z2 = rot(z1, vec2(0.), time*0.4);\n            r = 10. + 15.*TriangleDist(sin(cos(z2*PI + PI)*0.5 + 5.)*sin(cos(z2*PI)), vec2(1000.,3.2));\n        }\n        \n        /*float epsilon = 0.09;\n        if(length(der) < epsilon)\n        {\n            end_col = vec3(0.1,0.3,0.6);\n        }*/\n        \n        if(length(z) > r)\n        {\n            break;\n        }\n\n        // calculate derivative\n        der = 2. * vec2(der.x*z.x - der.y*z.y, der.x*z.y + der.y*z.x) + dc;\n        \n        // calculate new z\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + shape;\n    }\n\n    if(i >= ITERATIONS)\n    {\n        end_col *= 0.;\n    }\n    else\n    {\n        float flicker = (0.5+0.7*(cos(sin(time*15.) + sin(cos(11.*time))) + sin(cos(5.*time))));\n        float light = calc_light(z, der, 1.3, PI/5.);\n        float light2 = calc_light(z, der,1.00, 1.5);\n        light2 = pow(light2, 200. + 199.999*flicker);\n        light2 = clamp(0.,1.,light2);\n        float light3 = calc_light(z, der,1.00, 2.5);\n        light3 = pow(light3, 1000. + 999.999*flicker );\n        light3 = clamp(0.,1.,light3);\n        float light4 = calc_light(z, der,1.00, 3.5);\n        light4 = pow(light4, 1000. + 999.999*flicker);\n        light4 = clamp(0.,1.,light4);\n        //light *=(1.-light2)*(1.-light3)*(1.-light4);\n        \n        float fraciter = log2( log(length(z)) / log(r) );\n        float j = i;\n        if(manipulated != MANIPULATED) // right side\n        {\n        \tj -= fraciter;\n        }\n\n        vec3 col1 = col_1(j, COLOR_REPEAT*1., vec3(time*0.3));\n        //vec3 col12 = col_1(j, COLOR_REPEAT*20., vec3(time*3.));\n        //vec3 col13 = col_1(j, COLOR_REPEAT*1.4, vec3(time*0.1));\n        vec3 col2 = col_2(j, COLOR_REPEAT, vec3(time*0.5));\n        //vec3 col22 = col_2(j, COLOR_REPEAT*5., vec3(time));\n        //vec3 col3 = col_3(j, COLOR_REPEAT, vec3(time*0.5));\n        //vec3 col4 = col_4(j, COLOR_REPEAT, vec3(time*0.));\n\n        //end_col = vec3(sqrt(j*0.01));\n        //end_col = col4 * pow(light,1.) + col12*(pow(1.-light,2000.));\n        end_col = col1*light + col2*(light2 + light3 + light4);//col22*light2 + col22*light3;\n        //end_col = vec3(light2);\n        \n        float leaves = smoothstep(0.2,2.,fraciter);\n        //float leaves_edges = smoothstep(0.3,0.,fraciter);\n        //float leaves_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //leaves_edges *= leaves_edges_tips;\n        if(manipulated == MANIPULATED) // left side\n        {\n        \tend_col *= leaves*1.3;\n        }\n    }\n\t\n    return end_col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;// = fragCoord/iResolution.xy;\n    vec2 uv2 = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float a = MANIPULATED;\n    vec2 b = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    if(uv2.x > b.x) {a = 0.;}\n    //if(uv2.y > b.y) {a.y = 1.;}\n    \n    float zoom = 1. + 0.8*sin(sin(time*0.1))*cos(time*0.2);\n\n    #if AA\n    vec3 col = vec3(0.);\n    // anti-aliasing from https://www.shadertoy.com/view/Mss3R8\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\n        uv = (fragCoord+of)/iResolution.xy;\n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n\t   col += iterate( uv, 20., a);\n\t}\n\tcol /= float(AA*AA);\n    \n    #else\n    \n    uv = fragCoord/iResolution.xy;\n    uv*=zoom;\n    uv.x-= zoom/2.;\n    uv.y -= zoom/2.;\n\tvec3 col = iterate(uv, 20., a);\n    \n    #endif\n    \n    float mouseClicked = iMouse.w > 0. ? 0.12 : 0.;\n    vec3 vline = exp(-80.*length(uv2.x-b.x))*vec3(1.,1.,1.); // vertical line\n    /*vec3 lineCol = texture(iChannel1,uv*0.05\n                           + mouseClicked*vec2(time*0.5,time)\n                           + vec2(time*0.01, time*0.02)).xyz;\n    lineCol = (lineCol)*3.*vec3(0.8,1.,0.4);*/\n    col *= 1.-vline;\n    col += vline;\n    //col += vline*lineCol;\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592654\n// Color 1\nvec3 a1 = vec3(0.5, 0.5, 0.5);\nvec3 b1 = vec3(0.75, 0.55, 0.85);\nvec3 d1 = vec3(0.0, 0.1, 0.2);\n// Color 2\nvec3 a2 = vec3(0.5, 0.5, 0.5);\nvec3 b2 = vec3(0.75, 0.55, 0.85);\nvec3 d2 = vec3(0.8, 0.9, 0.3);\n// Color 3 - blue to gray\nvec3 a3 = vec3(0.5, .5, 1.);\nvec3 b3 = vec3(0.5, 0.5, 0.);\nvec3 d3 = vec3(0., 0., 0.);\n// Color 4 - black and white\nvec3 a4 = vec3(1, 1, 1);\nvec3 b4 = vec3(1.0, 1.0, 1.0);\nvec3 d4 = vec3(1.0, 1.0, 1.0);\n\n//vec3 col1 = a1 + b1 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT*5. + d1 + c1));\n\nvec3 col_1(float j, float repeat, vec3 offset)\n{\n    return a1 + b1 * cos(2.*PI*(sqrt(j) * repeat + d1 + offset));\n}\nvec3 col_2(float j, float repeat, vec3 offset)\n{\n    return a2 + b2 * cos(2.*PI*(sqrt(j) * repeat + d2 + offset));\n}\nvec3 col_3(float j, float repeat, vec3 offset)\n{\n    return a3 + b3 * cos(2.*PI*(sqrt(j) * repeat + d3 + offset));\n}\nvec3 col_4(float j, float repeat, vec3 offset)\n{\n    return a4 + b4 * cos(2.*PI*(sqrt(j) * repeat + d4 + offset));\n}","name":"Common","description":"","type":"common"}]}