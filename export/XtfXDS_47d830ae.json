{"ver":"0.1","info":{"id":"XtfXDS","date":"1442733639","viewed":599,"name":"The Machine","username":"mplanck","description":"\"Wanna take a ride ... \"  ","likes":30,"published":1,"flags":64,"usePreview":0,"tags":["distancemarch","sig15"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfXWX","filepath":"https://soundcloud.com/matharish/contact-movie-soundtrack-alan","previewfilepath":"https://soundcloud.com/matharish/contact-movie-soundtrack-alan","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[],"code":"\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n\n#define RINGS_SURFACE_ID 1.\n#define BASE_SURFACE_ID 2.\n#define SKY_SURFACE_ID 3.\n#define WATER_SURFACE_ID 4.\n#define HELI_SURFACE_ID 5.\n\n#define SUN_POSITION vec3(20., 6.5, 80.)\n#define SUN_COLOR vec3(1., .93, .91)\n#define GATE_POSITION vec3(0., 2., 0.)\n\n#define DIST_MARCH_STEPS 50\n#define DIST_MARCH_MAXDIST 30.\n\n// **************************************************************************\n// INLINE MACROS\n\n#define MATCHES_SURFACE_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))\n\n// **************************************************************************\n// DEFINES\n\n// Increase to 5 to anti-alias (and to warm up your GPU)\n#define NUM_AA_SAMPLES 1.\n\n// **************************************************************************\n// GLOBALS\n\nvec4  g_debugcolor  = vec4(0.);\nfloat g_time        = 0.;\n\nfloat g_r0time      = 0.;\nfloat g_r1time      = 0.;\nfloat g_r2time      = 0.;\nfloat g_r3time      = 0.;\n\nvec3  g_helipos     = vec3(0.);\n \nfloat g_gatetime    = 0.;\nfloat g_gateburst   = 0.;\nfloat g_gateradius  = 0.;\nfloat g_exposure    = 1.;\nfloat g_flareamount = .4;\nvec3  g_burstcolor  = vec3(0.);\nfloat g_camshake    = 0.;\n\n// **************************************************************************\n// MATH UTILITIES\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// Approximating a dialectric fresnel effect by using the schlick approximation\n// http://en.wikipedia.org/wiki/Schlick's_approximation. Returns a vec3 in case\n// I want to approximate a different index of reflection for each channel to\n// get a chromatic effect.\nvec3 fresnel(vec3 R, vec3 N, float eta)\n{\n    // assume that the surrounding environment is air on both sides of the \n    // dialectric\n    float ro = (1. - eta) / (1. + eta);\n    ro *= ro;\n    \n    float fterm = pow(max(0., 1. - dot(R, N)), 5.);  \n    return vec3(ro + ( 1. - ro ) * fterm); \n}\n\n// Rotate the input point around the x-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_xaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x,\n                point.y * cosa - point.z * sina,\n                point.y * sina + point.z * cosa);\n}\n\n// Rotate the input point around the y-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where I want to reuse the\n// same angle on different points, so why do the heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_yaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x * cosa  + point.z * sina,\n                point.y,\n                point.x * -sina + point.z * cosa);\n}\n\n// Rotate the input point around the z-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_zaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x * cosa - point.y * sina,\n                point.x * sina + point.y * cosa,\n                point.z);\n}\n\nfloat length4( vec2 p )\n{\n    p = p*p*p*p;\n    return pow( p.x + p.y, 1.0/4.0 );\n}\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal. *Overkill* \n// for intersecting with the x-z plane.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ro,\n                     vec3 rd,\n                     vec3 pn,\n                     vec3 po)\n{\n    float rddn = dot(rd, pn);\n    float intersected = 0.;\n\n    float t = REALLY_BIG_NUMBER;\n    // If the denominator is not a really small number (positive or negative)\n    // then an intersection took place.  If it is really small, then the ray\n    // is close to parallel to the given plane.\n    if (abs(rddn) > REALLY_SMALL_NUMBER) {\n        t = -dot(pn, (ro - po)) / rddn;    \n        if (t > REALLY_SMALL_NUMBER) {\n            intersected = 1.;\n        } else {\n            t = REALLY_BIG_NUMBER;\n        }\n\n    }\n    return vec2(intersected, t);\n}\n\n// intersection for a sphere with a ray. If the ray origin is inside the\n// sphere - no intersection takes place.  So there is gauranteed to be a tmin\n// and tmax return value.\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\nvec3 intersect_sphere(vec3 ro,                 \n                      vec3 rd, \n                      float sphr,\n                      vec3 sphc)\n{\n\n    vec3 oro = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - sphr*sphr;\n    float discr = b*b - a*c; \n    \n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/a;\n    tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmin);\n\n    float outside = step(sphr*sphr, dot(oro, oro));\n    return outside * vec3(hit, tmin, tmax);\n}\n\nfloat flow_noise( in vec3 p )\n{\n    vec3 q = p - vec3(0., .5 * g_time, 0.);\n    float f;\n    f  = 0.50000*noise( q ); q = q*3.02 -vec3(0., .5 * g_time, 0.);\n    f += 0.35000*noise( q ); q = q*3.03;\n    f += 0.15000*noise( q ); q = q*3.01;\n    return f;\n}\n\nfloat map4( in vec3 p )\n{\n    vec3 q = p;\n    float f;\n    \n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n    return f;\n}\n\n//Grabbed and modified from nimitz: https://www.shadertoy.com/view/ltfGDs\nvec2 fold16(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.7071, 0.7071);\n    const vec2 pl2 = vec2(-0.9237, 0.3827);\n    const vec2 pl3 = vec2(-0.9808, 0.1951);\n    \n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    p -= pl3*2.*min(0., dot(p, pl3));\n    \n    return p;\n}\n\n//Grabbed and modified from nimitz: https://www.shadertoy.com/view/ltfGDs\nvec2 fold8(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.7071, 0.7071);\n    const vec2 pl2 = vec2(-0.9237, 0.3827);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    \n    return p;\n}\n\n//Grabbed and modified from nimitz: https://www.shadertoy.com/view/ltfGDs\nvec2 fold4(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.7071, 0.7071);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    \n    return p;\n}\n\n// overlay ca on top of ci and return ci\nvoid composite(inout vec4 ci, vec4 ca)\n{\n    // assume pre-multiplied alpha    \n    ci += ca * (1. - ci.a);\n}\n\n// **************************************************************************\n// DISTANCE FUNC MATH\n\nfloat sphere_df( vec3 p, float r ) { return length( p ) - r; }\nfloat plane_df( vec3 p, vec3 o, vec3 n ) { return abs(dot(p-o, n)); }\nfloat roundbox_df ( vec3 p, vec3 b, float r ) {return length(max(abs(p-vec3(0., b.y, 0.))-b,0.0))-r; }\nfloat ring_df (vec3 p, vec2 r) {return length( vec2(length(p.xz)-r.x,p.y) )-r.y; }\nfloat flatring_df(vec3 p, vec2 r) {return length4( vec2(length(p.xz)-r.x,p.y) )-r.y; }\n\n// **************************************************************************\n// INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct CameraInfo\n{\n    vec3 camera_origin;\n    vec3 ray_look_direction;\n    mat3 camera_transform;\n    vec2 image_plane_uv;\n};\n\n#define INIT_CAMERA_INFO() SurfaceInfo(vec3(0.) /* camera_origin */, vec3(0.) /* ray_look_direction */, mat3(1.) /* camera_transform */, vec2(0.) /* image_plane_uv */)\n\nstruct SurfaceInfo\n{\n    float surface_id;\n    vec3 view_origin;\n    vec3 view_dir;\n    vec3 surface_point;\n    vec3 surface_normal;\n    vec2 surface_uv;\n    float surface_depth;\n    float shade_light;\n};\n#define INIT_SURFACE_INFO(view_origin, view_dir) SurfaceInfo(-1. /* surface_id */, view_origin, view_dir, vec3(0.) /* surface_point */, vec3(0.) /* surface_normal */, vec2(0.) /* surface_uv */, 0. /* surface_depth */, 1. /* shade_light */)\n\nstruct MaterialInfo\n{\n    vec3 bump_normal;\n    vec3 diffuse_color;\n    vec3 reflection_color;  // (aka specular color)    \n    float reflection_glossiness;  // (aka specular exponent)\n    float environment_amount;\n    vec3 ambient_color;\n};\n#define INIT_MATERIAL_INFO(surface_normal) MaterialInfo(surface_normal /* bump_normal */, vec3(0.) /* diffuse_color */, vec3(0.) /* reflection_color */, 1. /* reflection_glossiness */, 0. /* environment_amount */, vec3(0.) /* ambient_color */)\n\n// **************************************************************************\n// SETUP WORLD\n    \nvoid setup_globals()\n{\n    // Way to globally control playback rate.\n    g_time = 1. * iTime;\n    //g_time = .2 * iMouse.x;\n    \n    g_r0time = max(0., g_time - 20.);\n    g_r0time = .0035 * pow(g_r0time, 2.25);\n    \n    g_r1time = max(0., g_time - 15.);\n    g_r1time = .007 * pow(g_r1time, 2.25);\n    \n    g_r2time = max(0., g_time - 10.);\n    g_r2time = .015 * pow(g_r2time, 2.35);\n    \n    g_r3time = max(0., g_time - 5.);\n    g_r3time = .03 * pow(g_r3time, 2.4);\n\n    vec3 heli_orig = vec3(-7.5, .8, -0.2);\n    g_helipos = heli_orig + .5 * g_time * vec3(0.966, 0., .259);    \n    \n    float gate_flicker = noise(vec3(10. * g_time));\n    g_gatetime = max(0., g_time - 30.);\n    float burst_time = max(0., g_gatetime - 45.);\n    g_gateburst = 8. * mod(.8 * burst_time, 3.);\n    float burst_boost = step(REALLY_SMALL_NUMBER, burst_time) * smoothstep(2.5, 0., g_gateburst);\n\tburst_boost *= burst_boost;\n    \n    g_gateradius = min(2.5, .05 * g_gatetime) + 5. * burst_boost;\n    \n    g_burstcolor = (2.5 + 4. * burst_boost)  * smoothstep(0., 30., g_gatetime) * vec3(1., .88, 1.);        \n    g_burstcolor *= .8 + .2 * gate_flicker;\n    \n    g_flareamount = (.4 + 1. * burst_boost) * smoothstep(30., 40., g_gatetime);\n    g_flareamount *= .7 + .3 * gate_flicker;\n\n    g_exposure = .4 + .6 * smoothstep(30., 10., g_gatetime);\n    \n    g_camshake = .1 * cos(40. * g_time) * smoothstep(6., 7., g_gateburst) * smoothstep(10., 8., g_gateburst);\n}\n\n\nCameraInfo setup_camera(vec2 aaoffset)\n{\n    // remap the mouse click ([-1, 1], [-1/AspectRatio, 1/AspectRatio])\n    //vec2 click = iMouse.xy / iResolution.xx;  \n    //click = 2.0 * click - 1.0;  \n    \n    vec3 camera_origin = vec3(0.0, .1, 8.0);\n    \n    //float rotxang    = .01 * g_camshake;\n    //float cosrotxang = cos(rotxang);\n    //float sinrotxang = sin(rotxang);\n    //camera_origin = rotate_xaxis(camera_origin, cosrotxang, sinrotxang);\n    \n    //float rotyang    = TWO_PI * click.x;\n    //float rotyang    = .1 * sin(.1 * g_time + PI_OVER_TWO) + TWO_PI * .71;\n    float rotyang    = .2 * g_camshake + .1 + TWO_PI * .71;\n    float cosrotyang = cos(rotyang);\n    float sinrotyang = sin(rotyang);    \n    camera_origin = rotate_yaxis(camera_origin, cosrotyang, sinrotyang);\n\n    vec3 camera_points_at = vec3(0., 1., 2.);\n\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 image_plane_uv = (gl_FragCoord.xy + aaoffset) / iResolution.xy - .5;\n    image_plane_uv.y *= inv_aspect_ratio;\n\n    // calculate the ray origin and ray direction that represents mapping the\n    // image plane towards the scene.  Assume the camera is facing y-up (0., 1.,\n    // 0.).\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( camera_points_at - camera_origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // project the camera ray through the current pixel being shaded using the\n    // pin-hole camera model.\n    float focus = .5;\n    vec3 ray_look_direction = normalize( image_plane_uv.x * ix + image_plane_uv.y * iy + focus * iz );\n\n    return CameraInfo(camera_origin, ray_look_direction, mat3(ix, iy, iz), image_plane_uv);\n\n}\n\n// **************************************************************************\n// MARCH WORLD\n\nvec2 mergeobjs(vec2 a, vec2 b) { return mix(b, a, step(a.x, b.x)); }\n\nfloat uniondf(float a, float b) { return min(a, b); }\nfloat intersdf(float a, float b) { return max(a, b); }\nfloat diffdf(float a, float b) { return max(a, -b); }\n\nvec2 heli_df( vec3 p )\n{\n    vec3 hp = p;\n    \n    // main body\n    float heli_d = roundbox_df(hp, vec3(.02, .006, .012), .01);\n    \n    // butt piece\n    heli_d = uniondf(heli_d, roundbox_df(hp - vec3(-0.02, .01, 0.), vec3(.03, .0, .0), .005));\n    \n    // rails under heli\n    vec3 rail = hp;\n    rail.z = abs(rail.z) - 0.012;\n    heli_d = uniondf(heli_d, roundbox_df(rail - vec3(0., -0.021, 0.), vec3(.03, .002, .002), .0));\n\n    // tail bar\n    vec3 tail = hp;\n    tail.xy *= mat2(0., 1., -1., 0.);\n    heli_d = uniondf(heli_d, roundbox_df(tail - vec3(.018, -0.02, 0.), vec3(.0, .07, .0), .003));\n    \n    // tail tip\n    heli_d = uniondf(heli_d, roundbox_df(hp - vec3(-.115, 0.01, 0.), vec3(.005, .01, .0), .00));\n    \n    // spinning blade\n    vec3 blade = hp;\n    float t = 50. * g_time;\n    vec2 cs = vec2(cos(t), sin(t));\n    blade.xz *= mat2(cs.x, cs.y, -cs.y, cs.x);\n    heli_d = uniondf(heli_d, roundbox_df(blade - vec3(0., .03, 0.), vec3(.1, .0, .002), .002));        \n            \n    return vec2(heli_d, HELI_SURFACE_ID);\n}\n\nvec2 scene_df( vec3 p )\n{\n    \n    // spinning rings\n    vec3 pc = p - GATE_POSITION;\n    float r1 = flatring_df(pc, vec2(1., .08));\n    r1 = diffdf(r1, sphere_df(pc, 1.02));\n    \n    pc = rotate_yaxis(pc, cos(g_r0time), sin(g_r0time));\n    \n    float ir1 = flatring_df(pc, vec2(1.02, .04));\n    vec3 ipc = pc;\n    ipc.xz = fold16(ipc.xz) - vec2(0., 1.);\n    ir1 = diffdf(ir1, sphere_df(ipc, .06));\n    \n    pc = rotate_zaxis(pc, cos(g_r1time + 1.57), sin(g_r1time + 1.57));\n    float r2 = flatring_df(pc, vec2(.95, .07));\n    r2 = diffdf(r2, sphere_df(pc, .97));\n    \n    pc = rotate_xaxis(pc, cos(g_r2time + 1.57), sin(g_r2time + 1.57));\n    float r3 = flatring_df(pc, vec2(.9, .07));\n    r3 = diffdf(r3, sphere_df(pc, .92));\n        \n    pc = rotate_zaxis(pc, cos(g_r3time + 1.57), sin(g_r3time + 1.57));\n    float r4 = diffdf(flatring_df(pc, vec2(.85, .07)), sphere_df(pc, .87));\n    \n    float innerrings = ir1;\n    \n    float rings = uniondf(uniondf(uniondf(r1, r2), r3), r4);\n    vec2 ring_obj = vec2(rings, RINGS_SURFACE_ID);      \n    \n    vec2 innerrings_obj = vec2(innerrings, RINGS_SURFACE_ID);\n    \n    // supports\n    pc = p;    \n    float sr = flatring_df(pc - vec3(0., 2.03, 0.), vec2(1.1, .035));\n\n    pc.xz = fold4(p.xz) - vec2(0.,1.4);    \n    float supports = uniondf(sr, roundbox_df(pc, vec3(0.02, 1., .13), .01));\n    supports = uniondf(supports, roundbox_df(pc, vec3(.05, 1., .06), .01));\n    \n    vec3 pcb = pc + vec3(0., .2, .0);\n    supports = uniondf(supports, roundbox_df(pcb - vec3(0.,.9,0.), vec3(.1, .05, .17), .02));\n\n    vec3 s1pc = pcb;\n    s1pc.xy *= mat2(.9659, .2588, -.2588, .9659);\n    s1pc -= vec3(0.28, 0., 0.);\n    supports = uniondf(supports, roundbox_df(abs(s1pc), vec3(.08, .41, .06), .01));\n\n    vec3 s2pc = pcb;\n    s2pc.z = abs(s2pc.z);\n    s2pc.yz *= mat2(.9659, -.2588, .2588, .9659);\n    s2pc -= vec3(0.07, 0., 0.3);\n    supports = uniondf(supports, roundbox_df(s2pc, vec3(.03, .41, .08), .01));\n    \n    vec3 tpc = pc - vec3(0., 1.86, 0.);\n    supports = uniondf(supports, roundbox_df(tpc, vec3(.06, .045, .17), .01));\n    tpc.y -= .1;\n    supports = uniondf(supports, roundbox_df(tpc, vec3(.07, .02, .24), .01));\n    tpc -= vec3(0.0, .05, -0.06);\n    supports = uniondf(supports, roundbox_df(tpc, vec3(.07, .02, .34), .01));\n    \n    vec2 supports_obj = vec2(supports, RINGS_SURFACE_ID);\n    \n    // crane\n    pc = p + vec3(-.83, 0., .83);\n    pc.xz *= mat2(.7071, .7071, -.7071, .7071);\n    float crane = roundbox_df(pc, vec3(.03, 1.7, .08), .01);\n    crane = uniondf(crane, roundbox_df(pc , vec3(.06, 1.7, .05), .0));\n    \n    // crane supports\n    pcb = pc - vec3(0., .4, .0);\n    s1pc = pcb;\n    s1pc.x = abs(s1pc.x);\n    s1pc.xy *= mat2(.9659, .2588, -.2588, .9659);\n    s1pc -= vec3(0.2, 0., 0.);\n    crane = uniondf(crane, roundbox_df(abs(s1pc), vec3(.08, .41, .06), .01));\n\n    s2pc = pcb;\n    s2pc.xz = abs(s2pc.xz);\n    s2pc.yz *= mat2(.9659, -.2588, .2588, .9659);\n    s2pc -= vec3(0.03, 0., 0.26);\n    crane = uniondf(crane, roundbox_df(abs(s2pc), vec3(.01, .41, .08), .01));\n        \n    // crane tanks    \n    pcb = pc - vec3(0., 2.6, 0.);\n    pcb.xz = fold8(pcb.xz) - vec2(0., .1);\n    crane = uniondf(crane, roundbox_df(pcb, vec3(.0, .2, .0), .05));    \n      \n    tpc = pc - vec3(0., 3.5, 0.);\n    \n    // beam\n    crane = uniondf(crane, roundbox_df(tpc - vec3(0., 0., .21), vec3(.08, .02, 1.05), .01));\n    crane = uniondf(crane, roundbox_df(tpc - vec3(0., -.02, .21), vec3(.02, .001, 1.05), .03));\n    \n    // pivot\n    crane = uniondf(crane, roundbox_df(tpc - vec3(0., -.1, .0), vec3(.06, .01, .2), .04));\n    crane = uniondf(crane, roundbox_df(tpc - vec3(0., -.2, .0), vec3(.13, .05, .1), .01));\n\n    // counter weight\n    crane = uniondf(crane, roundbox_df(tpc - vec3(0., -0.1, -.8), vec3(.08, .06, .14), .03));\n    \n    // drop pod bay  \n    crane = uniondf(crane, ring_df((tpc - vec3(0., -0.03, 1.2)) * vec3(1., .6, 1.), vec2(.08, .05)));\n\n    vec2 crane_obj = vec2(crane, RINGS_SURFACE_ID);    \n    \n    // base\n    pc = p - vec3(0., .55, 0.);\n    float base = flatring_df(pc * vec3(1., .8, 1.), vec2(.6, .05));\n    \n    pc = p + vec3(.0, 0.1, 0.);\n    pc.xz = fold8(pc.xz) - vec2(0., 1.2);\n    pc.yz *= mat2(.7071, -.7071, .7071, .7071);\n    float base_struts = roundbox_df(pc, vec3(0.1, .45, 0.02), .01);\n    base = uniondf(base, base_struts);\n            \n    vec2 base_obj = vec2(base, RINGS_SURFACE_ID);\n    \n    // ground    \n    vec3 pb = p * vec3(.3, 1., .3) + vec3(0., .15, 0.) * (2.*map4(vec3(2.5) * p)-1.) + vec3(0., 1.3, 0.);\n    vec2 ground_obj = vec2(sphere_df(pb, 1.5), BASE_SURFACE_ID);\n    \n\n    vec2 obj = ring_obj;\n    obj = mergeobjs(obj, ground_obj);\n    obj = mergeobjs(obj, innerrings_obj);\n    obj = mergeobjs(obj, supports_obj);\n    obj = mergeobjs(obj, crane_obj);\n    obj = mergeobjs(obj, base_obj);\n    \n    if (g_helipos.x < 6.)\n    {\n        vec2 heli_obj = heli_df(p - g_helipos);\n        obj = mergeobjs(obj, heli_obj);\n    }\n    \n    return obj;\n}\n\nvec3 calc_normal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.01, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene_df(p + epsilon.xyy).x - scene_df(p - epsilon.xyy).x,\n        scene_df(p + epsilon.yxy).x - scene_df(p - epsilon.yxy).x,\n        scene_df(p + epsilon.yyx).x - scene_df(p - epsilon.yyx).x );\n    return normalize( n );\n}\n\nvec2 intersect_water(vec3 ro, vec3 rd)\n{\n    return intersect_plane(ro, rd, vec3(0., 1., 0.), vec3(0., 0., 0.));\n}\n\nSurfaceInfo march_scene(vec3 ray_origin,\n                        vec3 ray_direction,\n                        float consider_water )\n{\n\n    SurfaceInfo surface = INIT_SURFACE_INFO(ray_origin, ray_direction);\n\n    vec2 water = consider_water * intersect_water(ray_origin, ray_direction);\n    vec3 air_burst = intersect_sphere(ray_origin, ray_direction, g_gateburst, GATE_POSITION);    \n    \n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float total_t = 0.;\n    float curr_t = 0.;\n    \n    vec3 sky_n = normalize(ray_origin);\n    vec3 sky_o = -6. * sky_n ;\n    \n    vec3 ro = ray_origin;\n    vec3 rd = ray_direction;\n    \n    float burst_ior = 1. + .02 * smoothstep(8., 7., g_gateburst);\n    for (int i=0; i < DIST_MARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || curr_t + total_t > DIST_MARCH_MAXDIST ) \n        {\n            break;\n        }        \n\n        vec3 p = ro + curr_t * rd;        \n        vec2 dfresult = scene_df( p );\n        \n        // calculate sky on it's own since it shifts with ray_origin\n        // and normal\n        vec2 sky_obj = vec2(plane_df(p, sky_o, sky_n), SKY_SURFACE_ID);\n        dfresult = mergeobjs(sky_obj, dfresult);\n\n        dist = dfresult.x;        \n        curr_t += dist;\n        surface.surface_id = dfresult.y;\n   \n        // air_burst and water are not distance marched\n        // air_burst because it causes refraction\n        // water as an optimization\n        if (air_burst.x > .5 && curr_t > air_burst.y && air_burst.y < water.y - epsilon )\n        {\n            ro = ro + air_burst.y * rd;\n            // calculate the burst normal to be bent towards the viewing direction to avoid\n            // the refraction revealing the fact that the sky is a camera aligned \n            // textured card\n            \n            // refract the march directions\n            vec3 burst_n = normalize(ro - GATE_POSITION - 2. * rd);\n            rd = refract(rd, burst_n, burst_ior);\n            total_t = air_burst.y;\n            curr_t = 0.;            \n            air_burst *= 0.;\n            \n            water = consider_water * intersect_water(ro, rd);\n            surface.view_dir = rd;\n        }        \n        \n        \n        else if ( water.x > .5 && curr_t > water.y )\n        {\n            surface.surface_id = WATER_SURFACE_ID;\n            curr_t = water.y;\n            break;\n        }   \n\n                                          \n    }\n    \n    surface.surface_point = ro + curr_t * rd;\n    total_t += curr_t;\n    \n    if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        vec3 n = vec3(0., 1., 0.);\n        vec3 u = normalize(-vec3(1., 0., 1.) * ray_origin);\n        vec3 v = cross(n, u);\n        surface.surface_uv = vec2(100., 10.) * vec2( dot(surface.surface_point, u), \n                                                    dot(surface.surface_point, v) );\n\n        n += u * (.2 * flow_noise(surface.surface_uv.xxy) - .1);\n        surface.surface_normal = normalize(n);\n       \n    }    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, SKY_SURFACE_ID))\n    {\n        surface.surface_normal = -rd;\n        surface.surface_uv = surface.surface_point.xz;\n    }\n    else if (surface.shade_light > .5) \n    {        \n        surface.surface_normal = calc_normal( surface.surface_point );\n        surface.surface_uv = surface.surface_point.xz;\n    }\n    \n            \n    surface.surface_depth = total_t;\n\n    return surface;\n}\n\n// **************************************************************************\n// SHADE WORLD\n\nvec3 light_from_point_light(SurfaceInfo  surface,\n                            MaterialInfo material,\n                            vec3 light_position,\n                            vec3 light_color,\n                           float falloff_with_distance,\n                           float specular_sharpen)\n{\n    vec3 light_direction = normalize(light_position - surface.surface_point);\n    vec3 light_reflection_direction = reflect(light_direction, material.bump_normal);\n    \n    // Phong reflection model\n    vec3 reflective_shading = material.reflection_color * pow(max(0., dot(light_reflection_direction, surface.view_dir)), \n        material.reflection_glossiness * specular_sharpen);\n    \n    float ldist = length(surface.surface_point - light_position);\n    float dist_atten = 1./ldist;\n    vec3 diffuse_shading = material.diffuse_color * max(0., dot(light_direction, material.bump_normal)) * mix(1., dist_atten, falloff_with_distance);    \n    vec3 scene_color = light_color * (diffuse_shading + reflective_shading);\n \n    return scene_color;\n\n}\n\n\nvec3 light_from_environment(SurfaceInfo  surface,\n                            MaterialInfo material)\n{\n\n    vec3 surface_reflection_direction = reflect(surface.view_dir, material.bump_normal);\n    vec3 fresnel_color = material.environment_amount * fresnel(surface_reflection_direction, material.bump_normal, .8);\n    vec3 environment_shading = .8 * fresnel_color * texture(iChannel2, surface_reflection_direction).rgb;\n    vec3 ambient_shading = material.ambient_color;\n    vec3 scene_color = ambient_shading + environment_shading;\n \n    return scene_color;\n}\n\nvec4 shade_gate(vec3 ro, vec3 rd, float depth)\n{\n    vec4 gate_rgba = vec4(0.);\n    vec3 cn = normalize(ro);\n    float num_gates = 0.;\n\n    if (g_gatetime <= REALLY_SMALL_NUMBER)\n    {\n        return gate_rgba;\n    }\n            \n    \n    for (float i = 0.; i < 3.; i += 1.)\n    {\n        vec3 cp = cn * (.2  - .2 * i) ;\n        vec2 ch = intersect_plane(ro, rd, cn, cp);\n\n        float t = g_gatetime + i;\n        \n        if (ch.x > .5 && ch.y < depth )\n        {\n            vec3 hp = ro + rd * ch.y;\n            vec3 chp = hp - cp - GATE_POSITION;\n            vec3 uvhp = vec3(length(chp),\n                             atan(chp.z + .3 * (noise(30. * length(chp) - vec3(10. * t)) - .5), chp.y),\n                             5. * t);\n                            \n            float falloff = smoothstep(g_gateradius * (.3 + .7 * map4(vec3(0., 2., 1.4) * uvhp)), 0., uvhp.x);\n            falloff *= falloff;\n            \n            float gate_alpha = .6 * map4(vec3(-3., 1., 1.) * (uvhp - vec3(1. * t, 0., 0.))) * falloff;\n            vec3 gate_color = 4. * vec3(.6, .7, .6 + .5 * i);\n            \n            composite(gate_rgba, vec4(gate_color * gate_alpha, gate_alpha));\n            num_gates += 1.;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    return gate_rgba * smoothstep(0., 1., g_gatetime);\n}\n\nvec3 shade_anamorphicflare(CameraInfo camera)\n{\n    vec3 gate_flare = vec3(0.);\n\n    if (g_gatetime <= REALLY_SMALL_NUMBER)\n    {\n        return gate_flare;\n    }\n    \n    // find the center of the flare based on the burst position in world space    \n    vec3 flare_dir = normalize(GATE_POSITION - camera.camera_origin);    \n    vec2 flare_plane = intersect_plane(camera.camera_origin, \n                                       flare_dir, \n                                      -camera.camera_transform[2],\n                                       0.5 * camera.camera_transform[2] + camera.camera_origin);\n    \n    vec3 flare_hit = flare_plane.y * flare_dir;// + camera.camera_origin;\n    flare_hit -= camera.camera_transform[2];// + camera.camera_origin;\n    \n    vec2 flare_uv_center = vec2(dot(flare_hit, camera.camera_transform[0]), \n                         dot(flare_hit, camera.camera_transform[1]));\n\n    vec2 flare_uv = 10. * (camera.image_plane_uv - flare_uv_center);\n    \n    gate_flare = (1./(.5 * length(flare_uv))) * vec3(1., .8, 1.) * smoothstep(1., .0, pow(abs(flare_uv.y), .5));\n                \n    return gate_flare * g_flareamount;\n}\n\nvec4 shade_clouds(vec3 ro, vec3 rd, float depth)\n{\n    vec4 cloud_rgba = vec4(0.);\n    vec3 cn = normalize(ro);\n    float num_clouds = 0.;\n    \n    for (float i = 0.; i < 4.; i += 1.)\n    {\n        vec3 cp = ro - cn * (1. * i + 0.1) ;\n        vec2 ch = intersect_plane(ro, rd, cn, cp);\n\n        if (ch.x > .5 && ch.y < depth )\n        {\n            vec3 hp = ro + rd * ch.y;\n            vec3 uvhp = vec3(dot(hp - cp, vec3(0.,1.,0.)), \n                             dot(hp - cp, cross(vec3(0., 1, 0.), cn)), \n                                 \n                                 0.);\n                           \n            float height_s = smoothstep(1., 5., hp.y);\n            \n            float cloud_alpha = (.1 + .15 * i) * (.2 + .8 * smoothstep(.4, .75 - .25 * height_s, map4(vec3(1.8, .4, 0.) * uvhp + vec3(3. * i, 5. * i , .05 * g_time))));\n            cloud_alpha *= smoothstep(0., .08, hp.y) * smoothstep(.2 + 1.2 * i, .1, hp.y);\n            vec3 cloud_color = 1.2 * vec3(1.+.09*i,1.,1.);\n            composite(cloud_rgba, vec4(cloud_color * cloud_alpha, cloud_alpha));\n            num_clouds += 1.;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    //g_debugcolor.rgb = vec3(num_clouds * .25);\n    //g_debugcolor.a = 1.;\n    return cloud_rgba;\n}\n\nvec3 shade_reflected_world(SurfaceInfo surface)\n{\n    vec4 scene_color = vec4(0.);\n    \n    MaterialInfo material = INIT_MATERIAL_INFO(surface.surface_normal);\n    if (MATCHES_SURFACE_ID(surface.surface_id, RINGS_SURFACE_ID))\n    {\n\n        material.diffuse_color = .5 * vec3(.65, .62, .68);\n        material.reflection_color = 1.2 * vec3(0.5, 0.6, 0.7);\n        material.reflection_glossiness = 70.;\n\n        material.ambient_color = vec3(.04, .03, .035);\n\n        material.environment_amount = .7;\n    } \n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, BASE_SURFACE_ID))\n    {\n        vec3 surface_color = .2 * vec3(1., .45, .4);        \n\n        material.diffuse_color = surface_color;\n\n        material.ambient_color = .14 * surface_color;\n        material.reflection_color = .1 * surface_color;\n        material.reflection_glossiness = 50.;\n\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, SKY_SURFACE_ID))\n    {\n        vec3 sky_color = .7 * mix(.9 * vec3(.9, .85, .85), \n                                  1.45 * vec3(.58, .58, .7), \n                                    smoothstep(1., 6., surface.surface_point.y));        \n\n        sky_color += .5 * vec3(1.,1.,.9) * pow(max(0., dot(surface.view_dir, normalize(SUN_POSITION - surface.view_origin))), 8.);\n        sky_color += .4 * vec3(1.,1.,.9) * smoothstep(5., 10., surface.surface_point.y);\n        material.ambient_color = sky_color;\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, HELI_SURFACE_ID))\n    {\n        vec3 surface_color = 2. * vec3(.05, .05, .03);        \n\n        material.diffuse_color = surface_color;\n        material.ambient_color = vec3(.02);\n        material.reflection_color = vec3(0.);\n\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        return vec3(0.);\n    }\n\n    if (surface.shade_light > .5)\n    {\n        vec4 gate_rgba = shade_gate(surface.view_origin, surface.view_dir, surface.surface_depth);\n        vec4 clouds_rgba = shade_clouds(surface.view_origin, surface.view_dir, surface.surface_depth);\n\n        vec3 lit_color = light_from_point_light(surface, \n                                                material, \n                                                SUN_POSITION, \n                                                SUN_COLOR, \n                                                0., \n                                                1.);\n        \n        lit_color += light_from_environment(surface, material); \n        \n        lit_color *= g_exposure;\n        clouds_rgba.rgb *= g_exposure;\n\n        lit_color += light_from_point_light(surface, \n                                            material, \n                                            GATE_POSITION, \n                                            g_burstcolor, \n                                            1., \n                                            1.);          \n        \n        scene_color = gate_rgba; \n        composite(scene_color, clouds_rgba);\n        composite(scene_color, vec4(lit_color, 1.));\n    }\n    else\n    {\n        scene_color.rgb = material.diffuse_color + 1.3 * material.ambient_color;\n    }\n    \n    return scene_color.rgb;\n}\n\n\nvec3 shade_world(SurfaceInfo surface)\n{\n\n    vec4 scene_color = vec4(0.);\n    \n    if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        MaterialInfo material = INIT_MATERIAL_INFO(surface.surface_normal);\n        \n        vec3 surface_color = vec3(.07,.08,.1) + mix(vec3(.18, .22, .35),\n                                 vec3(.21, .25, .38), \n                                 flow_noise(surface.surface_uv.xxy));\n\n        material.diffuse_color = .8 * surface_color;\n        material.ambient_color = .15 * surface_color;\n        material.reflection_color = vec3(.8);\n        material.reflection_glossiness = 100.;\n        \n        SurfaceInfo refl_surface = march_scene( surface.surface_point, \n                                                reflect(surface.view_dir, \n                                                        surface.surface_normal), \n                                                0. );\n        refl_surface.shade_light = 0.;\n        vec3 refl_color = shade_reflected_world( refl_surface );\n        \n        // fresnel like falloff to reflection\n        refl_color *= (.3 + .7 * smoothstep(0.3, 2.5, surface.surface_depth));\n\n        // loss of reflection with wave occlusion in the distance\n        refl_color *= (.2 + .8 * smoothstep(3., 1., surface.surface_depth));\n            \n        vec4 gate_rgba = shade_gate(surface.view_origin, surface.view_dir, surface.surface_depth);\n        vec4 clouds_rgba = shade_clouds(surface.view_origin, surface.view_dir, surface.surface_depth);\n        \n        vec3 lit_color = light_from_point_light(surface, \n                                                material, \n                                                SUN_POSITION, \n                                                SUN_COLOR, \n                                                0., 1.);\n        \n        lit_color += light_from_environment(surface, material);    \n        lit_color += .2 * refl_color;\n        \n        lit_color *= g_exposure;      \n        clouds_rgba.rgb *= g_exposure;\n        \n        lit_color += .7 * light_from_point_light(surface, \n                                            material, \n                                            GATE_POSITION, \n                                            g_burstcolor, \n                                            1., \n                                            1. + 6. * smoothstep(2., 0.1, g_gateradius));\n        \n        scene_color = gate_rgba; \n        composite(scene_color, clouds_rgba);\n        composite(scene_color, vec4(lit_color, 1.));\n\n    }\n    else\n    {\n        \n        scene_color.rgb = shade_reflected_world(surface);\n    }\n\n    return scene_color.rgb;\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // ----------------------------------\n    // SETUP GLOBALS\n\n    setup_globals();\n\n    // ----------------------------------\n    // SETUP CAMERA\n\n    float denom = TWO_PI/max(1., NUM_AA_SAMPLES-1.);\n    vec3 scene_color = vec3(0.);\n\n    for (float aa = 0.; aa < NUM_AA_SAMPLES; aa += 1.) \n    {\n\n        vec2 aaoffset = step(.5, aa) * .5 * vec2( cos((aa-1.) * denom ),\n                                                  sin((aa-1.) * denom ) );\n\n        CameraInfo camera = setup_camera( aaoffset );\n        \n        // ----------------------------------\n        // SCENE MARCHING\n\n        SurfaceInfo surface = march_scene( camera.camera_origin,\n         camera.ray_look_direction, 1. );\n        \n        // ----------------------------------\n        // SHADING\n        \n        scene_color += shade_world( surface );\n        \n        // anamorphic lens flare\n        scene_color += shade_anamorphicflare(camera);   \n\n    }\n\n    scene_color /= NUM_AA_SAMPLES;\n\n    // ----------------------------------\n    // POST PROCESSING\n    \n    // Brighten\n    // scene_color *= 1.;\n  \n    // Gamma correct\n    scene_color = pow(scene_color, vec3(.7));\n\n    // Contrast adjust - cute trick learned from iq\n    scene_color = mix( scene_color, vec3(dot(scene_color,vec3(0.333))), -.2 );\n\n    // Color tint\n    scene_color *= .5 + .5 * vec3(.95, 1., 1.);\n      \n    // Vignette - inspired by iq\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    scene_color *= 0.4 + 0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    // Debug color - great debugging tool.  \n    if (g_debugcolor.a > 0.) \n    {\n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scene_color;\n    }\n\n    fragColor.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"}]}