{"ver":"0.1","info":{"id":"mtyyRz","date":"1700463186","viewed":29,"name":"20231113v1","username":"wwwww","description":"snow\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat radius=0.25; \nfloat zoom=4.0; \n// 例として適当な値で初期化\nconst float iterations = 100.0; \nconst float far = 1000.0; \nconst float depth = 100.0; \nconst int layers = 10;\nconst int layersblob = 5;\nfloat step = 0.1; \n\n\nvec3 light=vec3(0.0,0.0,1.0);\nvec2 seed=vec2(0.0,0.0);\nfloat iteratorc=iterations;\nfloat powr;\nfloat res;\n\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\n\nlowp vec4 hash4( mediump vec4 n ) { return fract(sin(n)*1399763.5453123); }\nlowp float noise2( mediump vec2 x )\n{\n    vec2 p = floor(x);\n    lowp vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    lowp vec4 h = hash4(vec4(n)+vec4(NC0.xy,NC1.xy));\n    lowp vec2 s1 = mix(h.xy,h.zw,f.xx);\n    return mix(s1.x,s1.y,f.y);\n}\n\nlowp float noise222( mediump vec2 x, mediump vec2 y, mediump vec2 z )\n{\n    mediump vec4 lx = vec4(x*y.x,x*y.y);\n    mediump vec4 p = floor(lx);\n    lowp vec4 f = fract(lx);\n    f = f*f*(3.0-2.0*f);\n    mediump vec2 n = p.xz + p.yw*157.0;\n    lowp vec4 h = mix(hash4(n.xxyy+NC0.xyxy),hash4(n.xxyy+NC1.xyxy),f.xxzz);\n    return dot(mix(h.xz,h.yw,f.yw),z);\n}\n\nlowp float noise3( mediump vec3 x )\n{\n    mediump vec3 p = floor(x);\n    lowp vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    mediump float n = p.x + dot(p.yz,vec2(157.0,113.0));\n    lowp vec4 s1 = mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),f.xxxx);\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\n}\nlowp vec2 noise3_2( mediump vec3 x ) { return vec2(noise3(x),noise3(x+100.0)); }\n\nlowp float combinedNoise(mediump vec2 x) {\n    // 既存のノイズと新しいノイズ関数を組み合わせる\n    float originalNoise = noise2(x);\n    float newNoise = noise2(x * 5.0); // 新しいノイズを異なるスケールで生成\n    return mix(originalNoise, newNoise, 0.5); // 両方のノイズを混ぜ合わせる\n}\n\n\nfloat map(mediump vec2 rad)\n{\n    float a;\n    if (res<0.0015) {\n    \t\n        a = noise222(rad.xy,vec2(20.6,100.6),vec2(0.9,0.1));\n    } else if (res<0.005) {\n        \n        a = noise2(rad.xy*20.6);\n        //if (a1<a) a=a1;\n    } else a = noise2(rad.xy*10.3);\n    return (a-0.5);\n}\n\nvec3 distObj(vec3 pos,vec3 ray,float r,vec2 seed)\n{   \n    mediump float rq = r*r;\n    mediump vec3 dist = ray*far;\n    \n    mediump vec3 norm = vec3(0.0,0.0,1.0);\n    mediump float invn = 1.0/dot(norm,ray);\n    mediump float depthi = depth;\n    if (invn<0.0) depthi =- depthi;\n    mediump float ds = 2.0*depthi*invn;\n    mediump vec3 r1 = ray*(dot(norm,pos)-depthi)*invn-pos;\n    mediump vec3 op1 = r1+norm*depthi;\n    mediump float len1 = dot(op1,op1);\n    mediump vec3 r2 = r1+ray*ds;\n    mediump vec3 op2 = r2-norm*depthi;\n    mediump float len2 = dot(op2,op2);\n    \n    mediump vec3 n = normalize(cross(ray,norm));\n    mediump float mind = dot(pos,n);\n    mediump vec3 n2 = cross(ray,n);\n    mediump float d = dot(n2,pos)/dot(n2,norm);\n    mediump float invd = 0.2/depth;\n    \n    if ((len1<rq || len2<rq) || (abs(mind)<r && d<=depth && d>=-depth))\n    {        \n        mediump vec3 r3 = r2;\n        mediump float len = len1;\n        if (len>=rq) {\n        \tmediump vec3 n3 = cross(norm,n);\n        \tmediump float a = inversesqrt(rq-mind*mind)*abs(dot(ray,n3));\n            mediump vec3 dt = ray/a;\n        \tr1 =- d*norm-mind*n-dt;\n            if (len2>=rq) {\n                r2 =- d*norm-mind*n+dt;\n            }\n            ds = dot(r2-r1,ray);\n        }\n        ds = (abs(ds)+0.1)/(iterations);\n        ds = mix(depth,ds,0.2);\n        if (ds>0.01) ds=0.01;\n        mediump float ir = 0.35/r;\n        r *= zoom;\n        ray = ray*ds*5.0;\n        \n        for (float m=0.0; m<iterations; m+=1.0) {\n         m += 0.5;\n            if (m>=iteratorc) break;\n           \tmediump float l = length(r1.xy); //inversesqrt(dot(r1.xy,r1.xy));\n            lowp vec2 c3 = abs(r1.xy/l);\n            if (c3.x>0.5) c3=abs(c3*0.5+vec2(-c3.y,c3.x)*0.86602540);\n\t\t\tmediump float g = l+c3.x*c3.x; //*1.047197551;\n\t\t\tl *= zoom;\n            mediump float h = l-r-0.1;\n            l = pow(l,powr)+0.1;\n          \th = max(h,mix(map(c3*l+seed),1.0,abs(r1.z*invd)))+g*ir-0.245; //0.7*0.35=0.245 //*0.911890636\n            if ((h<res*20.0) || abs(r1.z)>depth+0.01) break;\n            r1 += ray*h;\n            ray*=0.99;\n        }\n        if (abs(r1.z)<depth+0.01) dist=r1+pos;\n    }\n    return dist;\n}\n\nvec3 nray;\nvec3 nray1;\nvec3 nray2;\nfloat mxc=1.0;\n\nvec4 filterFlake(vec4 color,vec3 pos,vec3 ray,vec3 ray1,vec3 ray2)\n{\n    vec3 d=distObj(pos,ray,radius,seed);\n    vec3 n1=distObj(pos,ray1,radius,seed);\n    vec3 n2=distObj(pos,ray2,radius,seed);\n\n    vec3 lq=vec3(dot(d,d),dot(n1,n1),dot(n2,n2));\n\tif (lq.x<far || lq.y<far || lq.z<far) {\n    \tvec3 n=normalize(cross(n1-d,n2-d));\n        if (lq.x<far && lq.y<far && lq.z<far) {\n       \t\tnray = n;//normalize(nray+n);\n       \t\t\n        }\n       \tfloat da = pow(abs(dot(n,light)),3.0);\n        vec3 cf = mix(vec3(0.0,0.4,1.0),color.xyz*10.0,abs(dot(n,ray)));\n       \tcf=mix(cf,vec3(2.0),da);\n      \tcolor.xyz = mix(color.xyz,cf,mxc*mxc*(0.5+abs(dot(n,ray))*0.5));\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.2;//*0.1;\n    res = 1.0 / iResolution.y;\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\n\n    vec3 rotate;\n    \n    mat3 mr;\n    \n    vec3 ray = normalize(vec3(p,2.0));\n    vec3 ray1;\n    vec3 ray2;\n    vec3 pos = vec3(0.0,0.0,1.0);\n\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    \n\tnray = vec3(0.0);\n\tnray1 = vec3(0.0);\n\tnray2 = vec3(0.0);\n    \n    vec4 refcolor=vec4(0.0);\n   iteratorc = iterations - float(layers);\n    \n    vec2 addrot = vec2(0.0);\n    if (iMouse.z>0.0) addrot=(iMouse.xy-iResolution.xy*0.5)*res;\n    \n    float mxcl = 1.0;\n    vec3 addpos=vec3(0.0);\n    pos.z = 1.0;\n    mxc=1.0;\n    radius = 0.25;\n    float mzd = (zoom - 0.1) / float(layers);\n    for (int i=0; i<layersblob;i++) {\n        vec2 p2 = p-vec2(0.25)+vec2(0.1*float(i));\n        ray = vec3(p2,2.0)-nray*2.0;\n    \t\n    \tray1 = normalize(ray+vec3(0.0,res*2.0,0.0));\n    \tray2 = normalize(ray+vec3(res*2.0,0.0,0.0));\n        ray = normalize(ray);\n    \tvec2 sb = ray.xy*length(pos)/dot(normalize(pos),ray)+vec2(0.0,time);\n        seed=floor((sb+vec2(0.0,pos.z)))+pos.z;\n        vec3 seedn = vec3(seed,pos.z);\n        sb = floor(sb);\n        if (noise3(seedn)>0.2 && i<int(layers)) {\n            powr = noise3(seedn*10.0)*1.9+0.1;\n            rotate.xy=sin((0.5-noise3_2(seedn))*time*5.0)*0.3+addrot;\n            rotate.z = (0.5-noise3(seedn+vec3(10.0,3.0,1.0)))*time*5.0;\n            seedn.z += time*0.5;\n            addpos.xy = sb+vec2(0.25,0.25-time)+noise3_2(seedn)*0.5;\n            vec3 sins = sin(rotate);\n    \t\tvec3 coss = cos(rotate);\n    \t\tmr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\n\t\t    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;\n            mr=mat3(vec3(coss.z,sins.z,0.0),vec3(-sins.z,coss.z,0.0),vec3(0.0,0.0,1.0))*mr;\n\n            light = normalize(vec3(1.0,0.0,1.0))*mr;\n    \t\t//vec4 cc=filterFlake(fragColor,(pos+addpos)*mr,normalize(ray*mr+nray*0.1),normalize(ray1*mr+nray*0.1),normalize(ray2*mr+nray*0.1));\n            vec4 cc = filterFlake(fragColor,(pos+addpos)*mr,ray*mr,ray1*mr,ray2*mr);\n            \n            fragColor=mix(cc,fragColor,min(1.0,fragColor.w));\n        }\n        seedn = vec3(sb,pos.z)+vec3(0.5,1000.0,300.0);\n        if (noise3(seedn*10.0)>0.4) {\n            float raf = 0.3+noise3(seedn*100.0);\n            addpos.xy = sb+vec2(0.2,0.2-time)+noise3_2(seedn*100.0)*0.6;\n            float l = length(ray*dot(ray,pos+addpos)-pos-addpos);\n            l = max(0.0,(1.0-l*10.0*raf));\n            fragColor.xyzw += vec4(1.0,1.2,3.0,1.0)*pow(l,5.0)*(pow(0.6+raf,2.0)-0.6)*mxcl;\n        }\n       mxc -= 1.1 / float(layers);\n\n       float float_i = float(i);\n        iteratorc += 2.0;\n        mxcl -= 1.1/float(layersblob);\n        zoom-= mzd;\n    }\n    \n    vec3 cr = mix(vec3(0.0),vec3(0.0,0.0,0.4),(-0.55+p.y)*2.0);\n    fragColor.xyz += mix((cr.xyz-fragColor.xyz)*0.1,vec3(0.2,0.5,1.0),clamp((-p.y+1.0)*0.5,0.0,1.0));\n    \n    fragColor = min( vec4(1.0), fragColor );\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}