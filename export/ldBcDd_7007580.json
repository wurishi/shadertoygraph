{"ver":"0.1","info":{"id":"ldBcDd","date":"1494358697","viewed":1149,"name":"hex voxels","username":"mattz","description":"Proof-of-concept demonstrating interesting effects (borders, AO, hard shadows) with hex voxels at decent framerates. ","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["voxels","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* hex voxels, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Idea: raytrace through stacked hexagonal boxes, based on Shane's comment\n   in hexwaves - https://www.shadertoy.com/view/XsBczc\n\n   Define DEBUG_MAP if you want to see the underlying implicit function that defines \n   the scene.\n\n*/\n\n//#define DEBUG_MAP\n\n// square root of 3 over 2\nconst float hex_factor = 0.8660254037844386;\n\n// ratio of cell height to hex radius\nconst float cell_height = 1.75;\n\n// relationship between integer grid cells & sizes\nconst vec3 cell_size = vec3(hex_factor, 1.0, cell_height);\n\n// ambient occlusion falloff - smaller is darker\nconst float ao_falloff = 3.5;\n\n// ambient occlusion strength - bigger is darker\nconst float ao_strength = 0.65;\n\n// higher resolution discretizes more finely but needs more grid steps to render\nconst float resolution = 1.5;\n\n// number of steps to take to render\nconst int grid_steps = 100;\n\n// light direction\nvec3 light_dir = vec3(-3, -2, 5);\n\n\n#define HEX_FROM_CART(p) vec2(p.x / hex_factor, p.y)\n#define CART_FROM_HEX(g) vec2(g.x * hex_factor, g.y)\n\n//////////////////////////////////////////////////////////////////////\n// Used to draw top borders\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    return max(dot(p, vec2(hex_factor, 0.5)), p.y) - 1.0;\n}\n\n//////////////////////////////////////////////////////////////////////\n// Given a 2D position, find integer coordinates of center of nearest\n// hexagon in plane.\n\nvec2 nearestHexCell(in vec2 pos) {\n    \n    // integer coords in hex center grid -- will need to be adjusted\n    vec2 gpos = HEX_FROM_CART(pos);\n    vec2 hex_int = floor(gpos);\n\n    // adjust integer coords\n    float sy = step(2.0, mod(hex_int.x+1.0, 4.0));\n    hex_int += mod(vec2(hex_int.x, hex_int.y + sy), 2.0);\n\n    // difference vector\n    vec2 gdiff = gpos - hex_int;\n\n    // figure out which side of line we are on and modify\n    // hex center if necessary\n    if (dot(abs(gdiff), vec2(hex_factor*hex_factor, 0.5)) > 1.0) {\n        vec2 delta = sign(gdiff) * vec2(2.0, 1.0);\n        hex_int += delta;\n    }\n\n    return hex_int;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Flip normal if necessary to have positive dot product with d\n\nvec2 alignNormal(vec2 h, vec2 d) {\n    return h * sign(dot(h, CART_FROM_HEX(d)));\n}\n\n//////////////////////////////////////////////////////////////////////\n// Intersect a ray with a hexagon wall with normal n\n\nvec3 rayHexIntersect(in vec2 ro, in vec2 rd, in vec2 h) {\n    \n    //return vec3(0);\n\n    vec2 n = CART_FROM_HEX(h);\n\n    // solve for u such that dot(n, ro+u*rd) = 1.0\n    float u = (1.0 - dot(n, ro)) / dot(n, rd);\n    \n    // return the \n    return vec3(h, u);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Choose the vector whose z coordinate is minimal\n\nvec3 rayMin(vec3 a, vec3 b) {\n    return a.z < b.z ? a : b;\n}\n\n//////////////////////////////////////////////////////////////////////\n// Generate a distance field for the voxels. Negative (inside) means \n// filled voxel.\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 p) {\n    \n    float d = p.z;\n    \n    d = min(d, length(p) - 6.0);\n    \n    d = min(d, sdTorus(p.yxz, vec2(12.0, 2.5)));\n    \n    d = min(d, max(40.0 - length(p), p.z - 15.0));\n\n    return d;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Surface shading function. hit_nt holds normal and ray distance,\n// bdist holds distance to voxel edge, ndist holds distance to \n// neighbors (useful for AO).\n\nvec3 shade(vec4 hit_nt, float bdist, float ndist, float diffuse) {\n    \n    // get the normal\n    vec3 n = hit_nt.xyz;\n\n    // gotta deal with borders\n\n    // need to antialias more far away\n    float border_scale = 2.0/iResolution.y;\n\n    const float border_size = 0.01;\n\n    float border = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);\n\n    // don't even try to draw borders too far away\n    border = mix(border, 0.75, smoothstep(18.0, 70.0, hit_nt.w));\n\n    // diffuse + ambient term\n    diffuse = min(diffuse, clamp(dot(n, light_dir), 0.0, 1.0));\n    \n    float diffamb = (diffuse * 0.8 + 0.2);\n\n    // start out white\n    vec3 color = vec3(0.94, 1.0, 0.97);\n    \n    // add in border color\n    color = mix(vec3(0.74, 0.83, 0.76), color, border);\n\n    // multiply by diffuse/ambient\n    color *= diffamb;\n\n    // consider AO\n    color *= 1.0 - ao_strength*exp(-ao_falloff*ndist);\n\n\treturn color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Just for coloring the sky\n\nvec3 sky(vec3 rd) {\n    \n    float s = 0.5*dot(light_dir, rd) + 0.5;\n    return mix(vec3(0.1, 0.2, 0.6), vec3(1.0, 1.0, 0.9), s*s*s);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Compute min distance between point on vertical side of a hexagon \n// and corners of occupied cells. This checks just the four cells \n// needed.\n\nfloat vertEdgeDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {\n \n    // Get difference on integer hex grid\n    vec3 cell_diff = prev_cell - hit_cell;\n    \n    // Normal direction across cell boundary\n    vec2 n = CART_FROM_HEX(cell_diff.xy);\n    \n    // Perpendicular vector, scaled to correct length to check corners\n    vec2 np = vec2(-n.y, n.x) * 0.5 / hex_factor;\n        \n    // Coordinates of cell center\n    vec3 cell_pos = prev_cell * cell_size;\n    \n    // We only care about difference from center when measuring distances\n    p -= cell_pos;\n    \n    // These are \"rotation\" matrices that rotate directions on the\n    // integer hex grid.  \n    const mat2 M0 = mat2(0.5, 0.75, -1.0, 0.5);\n    const mat2 M1 = mat2(0.5, -0.75, 1.0, 0.5);\n    \n    // Get directions to left and right neighbors, along with sign\n    // for perpendicular to normal\n    vec3 h[2];\n    h[0] = vec3(M0 * cell_diff.xy, 1.0);\n    h[1] = vec3(M1 * cell_diff.xy, -1.0);\n    \n    // Initialize distance to large value\n    float rval = 1e5;\n    \n    // For each neighbor direction\n    for (int i=0; i<2; ++i) {\n        \n        // Check below and above on grid\n        for (float d=-1.0; d<=1.0; d+=2.0) {\n            \n            // Get the neighbor cell\n            vec3 neighbor_cell = hit_cell + vec3(h[i].xy, d);\n            vec3 neighbor_pos = neighbor_cell * cell_size;\n            \n            // If it's occupied\n            if (map(neighbor_pos/resolution) < 0.0) {\n                \n                // Get corner with this neighbor                  \n                vec3 corner = 0.5*(vec3(np*h[i].z, cell_height*d) - cell_diff*cell_size);\n                \n                // Check distance to corner\n                rval = min(rval, length(p - corner));\n                \n            }\n        }\n    }\n    \n    return rval;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Get minimum distance to all eight connected neighbors across a \n// face, except for the occupied one (which would have\n// distance of zero).\n\nfloat neighborDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {\n            \n    // Get cell center position\n    vec3 cell_pos = prev_cell * cell_size;\n    \n    // Only care about distances relative to center\n    p -= cell_pos;\n    \n    // Cancel out some multiplication that will happen down below\n    p.z *= 2.0/cell_height;\n    \n    // Set up four neighbors and distances to walls\n    vec4 h[4];\n    \n    h[0] = vec4(0.0,  1.0, 0.0, 1.0);\n    h[1] = vec4(1.0,  0.5, 0.0, 1.0);\n    h[2] = vec4(1.0, -0.5, 0.0, 1.0);\n    h[3] = vec4(0.0,  0.0, 0.5, 0.5*cell_height);\n    \n    // Initialize return value to large number\n    float rval = 1e5;\n   \n    // For each neighbor direction...\n    for (int i=0; i<4; ++i) {\n        \n        // ...and its opposite direction\n        for (float s=-1.0; s<=1.0; s+=2.0) {\n            \n            // Get the neighbor integer grid coords\n            vec3 neighbor_cell = prev_cell + 2.0*s*h[i].xyz;\n            \n            // Ignore the one we already know is occupied\n            if (neighbor_cell != hit_cell) {\n                \n                // Get neighbor center position\n                vec3 neighbor_pos = neighbor_cell * cell_size;\n                \n                // If occupied...\n                if (map(neighbor_pos/resolution) < 0.0) {\n                \n                    // Get normal\n                    vec3 n = s * h[i].xyz * cell_size;\n                    \n                    // Update using distance to neighbor along normal\n                    rval = min(rval, h[i].w - dot(n, p));\n                \n                }   \n            }\n        }\n    }\n    \n    // Return minimum distance\n    return rval;\n    \n}\n\n#ifdef DEBUG_MAP\n\n//////////////////////////////////////////////////////////////////////\n// Just used for debugging map -- based on iq's raymarcher\n\nfloat raymarch( in vec3 ro, in vec3 rd) {\n    \n\tfloat precis = 0.0001;\n    float h = precis*2.0;\n    float t = 0.0;\n    float m = 1.0;\n    const float maxd = 1000.0;\n    \n    for( int i=0; i<100; i++ ) {\n\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    h = map( ro+rd*t );\n        \n    }\n    \n    if (t > maxd) {\n        return -1.0;\n    } else {\n        return t;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Just used for debugging map -- based on iq's code\n\n\nvec3 calcNormal( in vec3 pos ) {\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Just used for debugging map\n\nvec3 ray_shade(vec3 ro, vec3 rd) {\n    \n    float t = raymarch(ro, rd);\n    \n    if (t < 0.0) {\n        \n        return sky(rd);\n        \n    } else {        \n        \n        vec3 p = ro + t * rd;\n        vec2 rdelta = CART_FROM_HEX(nearestHexCell(p.xy));\n        float bdist = hexDist(p.xy - rdelta);\n        vec4 hit_nt = vec4(calcNormal(p), t);\n        float ndist = 1e5;\n        \n        vec3 c = shade(hit_nt, bdist, ndist, 1.0);\n        return c.xyz;\n        \n    }\n    \n}\n\n#else\n\n//////////////////////////////////////////////////////////////////////\n// Return the normal and intersection distance for ray with origin\n// ro and direction rd.\n\nvoid raytrace(in vec3 ro, in vec3 rd,\n              out vec4 hit_nt, \n              out vec3 prev_cell,\n              out vec3 cur_cell) {\n        \n    // find nearest hex cell center to ray origin    \n    cur_cell = vec3(nearestHexCell(ro.xy), floor(ro.z/cell_height + 0.5));\n    \n    // we also will care about the cell we entered in from\n    prev_cell = cur_cell;\n    \n    // current cell center\n    vec3 cur_center = cur_cell * cell_size;\n\n    // see if ray is pointed up or down\n    float dz = rd.z < 0.0 ? -1.0 : 1.0;\n\n    // get the three candidate wall directions for this ray (i.e. the\n    // three hex side directions that correspond to normals with positive\n    // dot products to ray direction)\n    vec2 h0 = alignNormal(vec2(0.0, 1.0), rd.xy);\n    vec2 h1 = alignNormal(vec2(1.0, 0.5), rd.xy);\n    vec2 h2 = alignNormal(vec2(1.0, -0.5), rd.xy);\n\n\t// have we hit a hex yet?    \n    bool hit = false;\n    \n    // initialize normal to zero and intersection distance to negative\n    hit_nt = vec4(0, 0, 0, -1.0);    \n\n    // march along ray, one iteration per cell\n    for (int i=0; i<grid_steps; ++i) {\n        \n        // once we hit we're good\n        if (hit) { continue; }\n        \n        // distance from ray origin to current cell center\n        vec3 rdelta = ro-cur_center;\n        \n        // first, test intersections with sides:\n        // after three tests, ht.xy holds the direction, ht.z holds the\n        // ray distance parameter with intersecting sides\n        vec3 ht = rayHexIntersect(rdelta.xy, rd.xy, h0);\n        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h1));\n        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h2));\n        \n        // next, test intersection with top/bottom \n        float tz = (0.5*dz*cell_height - rdelta.z) / rd.z;\n        \n        // now we will need to figure out how to update the current cell\n        // either horizontally or vertically.\n        \n        // stash the previous cell\n        prev_cell = cur_cell;        \n\n        // variable to hold return value if we do hit\n        vec4 new_nt;\n \n        // check whether we hit top/bottom before side\n        if (tz < ht.z) {\n            \n            // hit top/bottom first, so march vertically\n            cur_cell.z += dz;\n            \n            // set up normal and ray distance for return value\n            new_nt = vec4(0, 0, -dz, tz);\n            \n        } else {\n            \n            // hit side first, so march horizontally\n            cur_cell.xy += 2.0*ht.xy;\n            \n            // set up normal and ray distance for return value\n            new_nt = vec4(-CART_FROM_HEX(ht.xy), 0, ht.z);\n            \n        }\n        \n        // we updated the current cell, now update the cell center position\n        cur_center = cur_cell * cell_size;\n            \n        // see if the new cell center is occupied\n        if (map(cur_center/resolution) < 0.0) {\n            hit = true;\n            hit_nt = new_nt;\n        }\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Return the color for a ray with origin ro and direction rd\n\nvec3 ray_shade(in vec3 ro, in vec3 rd) {\n    \n    // handle resolution scaling\n    ro *= resolution;\n\n    // hit_nt will hold normal and distance\n    vec4 hit_nt;\n    \n    // prev_cell and hit_cell store cell before and after intersection\n    vec3 prev_cell, hit_cell;\n    \n    // do raytrace\n    raytrace(ro, rd, hit_nt, prev_cell, hit_cell);\n    \n    // output color\n    vec3 color;\n    \n    // if ray hit\n    if (hit_nt.w >= 0.0) {\n        \n        // get the cell center where it hit\n        vec3 cell_center = hit_cell * cell_size;\n        \n        // get the intersection point\n        vec3 pintersect = ro + rd * hit_nt.w;\n        \n        // store distance to border, to neighbor cell\n        float bdist, ndist;\n        \n        // see if we hit top/bottom or side\n        if (abs(hit_nt.z) > 0.0) {\n            \n            // was top/bottom\n            bdist = hexDist(pintersect.xy - cell_center.xy);\n            ndist = neighborDist(prev_cell, hit_cell, pintersect); \n            \n        } else {\n            \n            // was side\n            vec2 n = hit_nt.xy;\n            bdist = abs(fract(pintersect.z/cell_height)-0.5)*cell_height;\n                    \n            vec2 p = pintersect.xy - cell_center.xy;\n            p -= n * dot(p, n);\n            bdist = min(bdist, abs(length(p) - 0.5/hex_factor));\n            \n            ndist = neighborDist(prev_cell, hit_cell, pintersect);\n            ndist = min(ndist, vertEdgeDist(prev_cell, hit_cell, pintersect));\n\n        }\n        \n        // default case: assume shadow - note for \"realism\" we would set 0.0 here\n        float diffuse = 0.5;\n        \n        // see if on lit side\n        if (dot(hit_nt.xyz, light_dir) > 0.0) {\n            \n            // shadow ray\n            vec4 shadow_nt;\n            raytrace(pintersect + 0.001*hit_nt.xyz, light_dir, \n                     shadow_nt, prev_cell, hit_cell);\n            \n            // full light if shadow ray missed\n            if (shadow_nt.w < 0.0) { diffuse = 1.0; }\n\n            \n        }\n        \n        // shade the hit point\n        color = shade(hit_nt, bdist, ndist, diffuse);\n\n        \n    } else {\n        \n        // no ray hit, cheesy sky\n       color = sky(rd);\n        \n    }\n    \n\treturn color;\n\t\n}\t\n\n#endif\n\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    light_dir = normalize(light_dir);\n    float ltheta = 0.2*iTime;\n    float c = cos(ltheta);\n    float s = sin(ltheta);\n    light_dir.xy = mat2(c, -s, s, c) * light_dir.xy;\n\t\n\tconst float yscl = 720.0;\n\tconst float f = 500.0;\n\t\n    vec2 uvn = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\tvec2 uv = uvn * yscl;\n\t\n\tvec3 pos = vec3(-18.0, 0.0, 10.0);\n\tvec3 tgt = vec3(0, 0, 4.0);\n\tvec3 up = vec3(0.0, 0.0, 1.0);\n\t\n\tvec3 rz = normalize(tgt - pos);\n\tvec3 rx = normalize(cross(rz,up));\n\tvec3 ry = cross(rx,rz);\n    \n    mat3 R = mat3(rx,ry,rz);\n\t \n\tvec3 rd = normalize(vec3(uv, f));\n\tvec3 ro = pos;\n\n\tfloat thetax = 0.15;\n\tfloat thetay = 0.6;\n\t\n\tif (iMouse.y > 10.0 || iMouse.x > 10.0) { \n\t\tthetax = (iMouse.y - 0.5*iResolution.y) * -1.25/iResolution.y;\n\t\tthetay = (iMouse.x - 0.5*iResolution.x) * 6.28/iResolution.x; \n\t}\n\n\tfloat cx = cos(thetax);\n\tfloat sx = sin(thetax);\n\tfloat cy = cos(thetay);\n\tfloat sy = sin(thetay);\n\t\n\tmat3 Rx = mat3(cx, 0.0, -sx,\n\t\t\t\t   0.0, 1.0, 0.0,\n\t\t\t\t   sx, 0.0, cx);\n\n    \n    mat3 Ry = mat3(cy, -sy, 0.0,\n                   sy, cy, 0.0,\n                  0.0, 0.0, 1.0);\n\n\t\n    ro = Ry*Rx*(pos-tgt) + tgt;\n    rd = Ry*Rx*R*rd;\n\n\tvec3 color;\n    \n    color = ray_shade(ro, rd);\n    \n\tcolor = sqrt(color);\n\n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}