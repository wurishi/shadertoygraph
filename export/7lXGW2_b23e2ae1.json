{"ver":"0.1","info":{"id":"7lXGW2","date":"1622847366","viewed":61,"name":"shpers_and_lights_ex1","username":"qt1","description":"My first shader - based on https://www.shadertoy.com/view/NlX3R2\n\nAn eclectic mix of 2d and 3d animation, light sources, geometry and sound\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["course"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n  \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = 1000000.0; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nSphere spheres[4];\nLight  lights[2];\nint numLights = 2;\nint numSpheres = 2;\n\nmat3 zRotation(float angle) {\n    return mat3(cos(angle),  sin(angle), 0,\n                -sin(angle), cos(angle), 0,\n                0,           0,          1);\n}\n\nvec3 tranformAroundCenter(mat3 transform, vec3 center, vec3 point) {\n    return center + transform * (point - center);\n}\n\n\nvoid makeScene(int f) {\n    spheres[0] = Sphere(0.5, vec3(0, 0, -6), vec3(1, 1, 0.2));\n    spheres[1] = Sphere(0.24, vec3(1, 1, -6), vec3(1, 0.2, 1));\n    //lights[0] = Light(vec3(-1.0, 0.0, -4.0), vec3(1, 1, 1));\n    lights[0] = Light(vec3(10.0*sin(float(f)*0.03), 0.0, 0.0), vec3(1, 0.5, 0));\n    lights[1] = Light(vec3(0.0, 10.0*sin(float(f)*0.01), 0.0), vec3(0, 0.5, 1));\n    numLights = 2;\n    \n    mat3 r = zRotation(float(f)*0.1);\n    \n    spheres[1].center = tranformAroundCenter(r, spheres[0].center, spheres[1].center);\n}\n\nint numSamples = 1;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       float minT = 1000000.0;\n       int minI = 0;\n       \n       for(int i=0; i<numSpheres; i++) {\n           Sphere sphere = spheres[i];\n\n           float t = raySphereIntersect(ray, sphere);\n           if (t < minT) {\n               // TBD: verify hit is behind the screen\n               minT = t;\n               minI = i;\n           }\n       }\n       \n       if(minT<1000000.0) {\n           Sphere sphere = spheres[minI];\n           vec3 hit = ray.origin + minT*ray.direction;\n           vec3 norm = normalize(hit - sphere.center);\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           float rayCAngle = dot(norm, hitPointToEye);\n           for(int l=0;l<numLights; l++) {\n               vec3 hitPointToLight = normalize(lights[l].location-hit);         \n               float lightCAngle = dot(hitPointToLight,norm);          \n               if(lightCAngle>0.0) { /* back is black */\n                  samp = samp + rayCAngle*lightCAngle*(sphere.color * lights[l].color);\n               }\n           }\n       }\n       \n       // 2D overlay\n       //float ampl = 2.0*texture(iChannel0,vec2(0.8,.25)).x;\n       vec2 c = vec2(0.0, 0.0);\n       vec2 xy = vec2(x,y);\n       vec2 dxy = xy-c;\n       float r = length(dxy);\n       float a = atan(dxy.y, dxy.x)+3.1415;\n       float signal = 2.0*texture(iChannel0,vec2(a/2.0/3.1415, 0.75)).x;\n       float R = 0.5;\n       \n       /*spheres[1].radius = wave * 0.24; */\n       if(abs(signal*r-R)< 0.01)\n           samp += vec3(signal*0.5, r, float(iFrame%100)/100.0);\n   }\n   \n   \n/*   float wave = texelFetch( iChannel0, ivec2(float(512), 0),0 ).x;\n   spheres[1].radius = wave * 0.24; \n*/\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}