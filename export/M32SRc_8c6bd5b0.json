{"ver":"0.1","info":{"id":"M32SRc","date":"1710900117","viewed":56,"name":"Blend with premultiplied alpha","username":"nathanli1211","description":"premultiply alpha before blending","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["alphablend"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Color(int c)\n{\n    return float(c) / 255.f;\n}\nvec2 Color2(int a, int b)\n{\n    return vec2(Color(a), Color(b));\n}\nvec3 Color3(int r, int g, int b)\n{\n    return vec3(Color(r), Color(g), Color(b));\n}\nvec4 Color4(int r, int g, int b, int a)\n{\n    return vec4(Color2(r, g), Color2(b, a));\n}\nvec4 ColorMultiplyAlpha(vec4 in_color)\n{\n    return vec4(in_color.rgb * in_color.a, 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color1 = Color4(255,0,0,255);\n    vec4 color2 = Color4(0,255,0,25);\n    vec4 color2_premultiplied = ColorMultiplyAlpha(color2);\n    \n    \n    vec4 blend_wrong = mix(color1, color2, 0.5f);\n    vec4 blend_correct = mix(color1, color2_premultiplied, 0.5f);\n    \n    if ( uv.x < 0.5 && uv.y > 0.5)\n    {\n        fragColor = ColorMultiplyAlpha(color1);\n    }\n    else if (uv.x > 0.5 && uv.y > 0.5)\n    {\n        fragColor = ColorMultiplyAlpha(color2);\n    }\n    else if (uv.x < 0.5 && uv.y < 0.5)\n    {\n        // lower left area\n        // Wrong blinear blend result: Note color2.alpha is 25/255, blend with green should is still (mainly) red.\n        fragColor = blend_wrong;\n    }\n    else\n    {\n        // lower right area\n        // Correct blend result with premultipling alpha before blend\n        fragColor = blend_correct;\n    }\n    \n}","name":"Image","description":"","type":"image"}]}