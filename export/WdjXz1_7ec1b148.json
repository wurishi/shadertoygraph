{"ver":"0.1","info":{"id":"WdjXz1","date":"1552948077","viewed":486,"name":"[twitch] Smoke Screen","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS or VOLUME_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SmokeScreen.glsl","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","volumetric","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS or VOLUME_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SmokeScreen.glsl\n*/\n\n#define MARCH_STEPS 100\n#define VOLUME_STEPS 50\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat box(vec3 p, vec3 r) {\n  vec3 ap=abs(p)-r;\n  return length(max(vec3(0),ap)) + min(0.0, max(ap.x,max(ap.y,ap.z)));\n}\n\nfloat cyl(vec3 p, float r, float s) {\n  return max(length(p.xy)-r,abs(p.z)-s);\n}\n\nfloat map(vec3 p) {\n  \n  float b1 = box(p, vec3(10,8,1));\n  b1 = max(b1, -box(p-vec3(0,0,-1), vec3(9,7,1)));\n  b1 = min(b1, -box(p+vec3(0,0,20), vec3(30,10,20)));\n  \n  vec3 ap=abs(p)-vec3(10,8,0);\n  b1 = min(b1, abs(cyl(ap+vec3(-4,5,0), 1.2, 1.0))-0.2);\n  \n  return b1;\n}\n\nvec3 rnd(float t) {\n  return fract(sin(t*78.65)*vec3(7893.854,5847.655,3874.951));\n}\n\nfloat rnd1(float t) {\n  return fract(sin(t*943.522)*7983.221);\n}\n\nvec3 noise(vec2 p) {\n  vec2 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  p=smoothstep(0.0,1.0,p);\n  p=smoothstep(0.0,1.0,p);\n  vec2 st=vec2(7,133);\n  vec2 val=dot(ip,st)+vec2(0,st.y);\n  vec3 v1 = mix(rnd(val.x), rnd(val.x+st.x), p.x);\n  vec3 v2 = mix(rnd(val.y), rnd(val.y+st.x), p.x);\n  return mix(v1,v2,p.y);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,133,381);\n  vec4 val=dot(ip,st)+vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v1 = mix(fract(sin(val)*4985.655), fract(sin(val+st.x)*4985.655), p.x);\n  vec2 v2 = mix(v1.xz,v1.yw, p.y);\n  return mix(v2.x,v2.y,p.z);\n}\n\nvec3 moving(vec2 p, float t, float d) {\n  float g=t/d;\n  vec3 a=noise(p+rnd1(floor(g))*987.565);\n  vec3 b=noise(p+rnd1(floor(g+1.0)*987.565));\n  return mix(a,b,pow(smoothstep(0.0,1.0,fract(g)),10.0));\n}\n\n\nvec3 window(vec2 p) {\n  \n  p*=rot(time*0.3);\n  p=abs(p)-0.8;\n  p*=rot(time*0.4);\n  p=abs(p)-0.5;\n  \n  vec3 f = moving(p, time, 0.5);\n  \n  f.xy *= rot(p.x);\n  f.yz *= rot(p.y*2.2);\n  \n  f = vec3(0.2,0.5,8.0)*f.x;\n  \n  f += step(sin(length(p.xy)-time*3.0),0.5) * exp(-fract(time*0.5));\n  f=clamp((f-0.7)*10.0,0.0,1.0);\n  \n  return f;\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd1(floor(g)), rnd1(floor(g+1.0)), pow(smoothstep(0.0,1.0,fract(g)),10.0));\n}\n\nfloat masking(vec3 p) {\n  vec2 ap=abs(p.xy)-vec2(10,8);\n  float mask = step(max(ap.x,ap.y),-1.1);\n  \n  mask = max(mask, 5.0*step(length(ap+vec2(-4,5)),1.0));\n  \n  return mask;\n}\n\nvec3 volume(vec3 p) {\n  vec2 p2 = p.xy*3.0/(-1.0+p.z*0.1-curve(time, 0.3)*10.0);\n  vec2 sel = abs(p.xy)-vec2(10,8);\n  float sel2 = max(sel.x,sel.y);\n  p2 = mix(p2, floor(p.xy/10.0), step(0.0,sel2));\n  vec3 val = window(p2);\n  return val * masking(p);\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*vec2(798.655)+uv.yx*vec2(942.642)),vec2(9865.655)));\n}\n\nfloat fractal(vec3 p) {\n  float n=noise(p) * 0.5;\n  float t=time*1.8;\n  p.y+=t*0.7;\n  n += noise(p*2.0)*0.25;\n  p.z+=t*0.5;\n  n += noise(p*4.0)*0.125;\n  p.x+=t*0.7;\n  return n;\n}\n\nfloat cloud(vec3 p) {\n  float n = fractal(p*0.5);\n  n=clamp((n-0.3)*30.0,0.0,1.0);\n  //n=pow(n, 3);\n  return clamp(n*0.12+0.9,0.0,1.0);\n}\n\nvoid cam(inout vec3 p) {\n  float t=time*0.3;\n  p.yz*=rot(0.0+sin(t*0.3)*0.2);\n  p.xz*=rot(sin(t)+0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0,0,-30);\n  vec3 r=normalize(vec3(-uv, 0.7+curve(time, 1.5)*0.7));\n  \n  cam(s);\n  cam(r);\n  \n  s.y += (curve(time,1.5)-0.5)*4.0;\n  \n  float rand = rnd(uv);\n  \n  vec3 col=vec3(0);\n  \n  vec2 off=vec2(0.01,0);\n  \n  \n  vec3 backcol = vec3(0);\n  for(int i=-3;i<3; ++i) {\n    for(int j=-3;j<3; ++j) {  \n      backcol += volume(vec3(i,j,0)*0.5);\n    }\n  }\n  backcol /= 49.0;\n  \n  // First raymarching with distance field, to get first collision (and reflections)\n  vec3 p=s;\n  float dd=0.0;\n  float prod = 1.0;\n  vec3 ray = r;\n  bool first = false;\n  float limit=0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n  \n      vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n      float fog = 1.0-clamp(dd/100.0,0.0,1.0);\n      \n      vec3 l=normalize(vec3(0,0,-5)-p);\n      float aodist=0.5;\n      float ao=clamp(map(p+n*aodist)/aodist,0.0,1.0);\n      float f=pow(1.0-abs(dot(ray,n)),1.0);\n      float mas = 1.0-masking(p);\n      \n      vec3 diff=vec3(noise(p.yz*vec2(0.8,15)).x*0.5+noise(p.yz*vec2(0.8,15)*2.0).x*0.4)*2.0*vec3(0.8,0.7,0.2);\n      diff=mix(diff, vec3(1), step(abs(p.x), 29.9));\n      \n      col += prod * diff*max(0.0, dot(n, l)) * 2.0 * fog * backcol * ao * (mas*0.7+0.3);\n      col += prod * diff*volume(p) * fog;    \n      \n      float size = 2.0;\n      vec3 mat1 = (fract(p/size+0.01)-0.5)*size;\n      float mat=max(mat1.x,max(mat1.y,mat1.z));\n      //col += mat*3;\n      float mas2=step(7.9,p.y);\n      if(mat*mas*mas2>size*0.48) break;\n\n      prod *= f;\n      if(!first) {first=true;limit=dd;}\n      if(prod<0.1) break;\n      ray = reflect(ray, n);\n      d = 0.01;\n      //break;\n    }\n    if(dd>100.0) { dd=100.0; break; }\n    p+=ray*d;\n    dd+=d;\n  }\n    \n  // second raymarching with fixed step size\n  const float maxdist=40.0;\n  const int steps=VOLUME_STEPS;\n  const float fstep = maxdist/float(steps);\n  vec3 or=fstep*r;\n  float prog = rand*fstep;\n  vec3 vp=s+prog*r;\n  vec3 val=vec3(0);\n  float alpha = 1.0;\n  for(int i=0; i<steps; ++i) {\n    if(prog>limit) break;\n    if(alpha<0.01) break;\n    float fade = 1.0-clamp(-(vp.z)/20.0,0.0,1.0);\n    alpha *= cloud(vp);\n    val += alpha * volume(vp)*fade*fade;\n    vp+=or;\n    prog += fstep;\n  }\n  col *= (1.0-alpha*0.7);\n  col += val*0.3*alpha;\n    \n    \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}