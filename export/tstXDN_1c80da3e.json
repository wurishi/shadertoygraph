{"ver":"0.1","info":{"id":"tstXDN","date":"1572038733","viewed":216,"name":"Fast 2 Axis Pixelsorting","username":"SSHantaram","description":"This is an attempt to improve on my previous shader https://www.shadertoy.com/view/WscXDN\nBy using multiple buffer and swapping pixels in bands with different widths i get a considerable speedup ~15x.\nnow in hue and value space. Space bar to reset","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["buffer","pixelsorting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 hvs = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    vec3 col = hsv2rgb(hvs.xzy);\n    fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// using powers of two here might seem like an obvious choice,\n// but because powers of two share lots of factors this leads to blocking an all levels\n// using prime factors close to powers of five surprisingly gives me at least\n// a 10x speedup over even powers of 2 or 4\nconst int SWAP_DISTANCE = 123;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // fetch current pixel from buffer\n    vec4 current = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // values to calculate neighbours in uv space\n    vec2 texel = 1. / iResolution.xy;\n    \n    // init with texture if at first frame or when spave bar is pressed\n    if(\tiFrame <= 10 ||\n      \ttexelFetch(iChannel1, ivec2(SPACE_BAR,0), 0 ).x > 0.1)\n    {\n        vec3 col = texture(iChannel2, uv).rgb;\n        vec3 hvs = rgb2hsv(col).xzy;\n        fragColor = vec4(hvs, 1.0);\n        return;\n    }\n\n    ivec2 pixelOffset;\n    \n    // swapping up, down, left, right is interleaved between frames\n    // idea taken from https://www.shadertoy.com/view/4dcGDf\n    // offets are set based on direction\n    // pixels are swapped in bands of width SWAP_DISTANCE\n    // this makes using multiple buffers effective\n    if (iFrame % 4 < 2) {\n        if ((iFrame*SWAP_DISTANCE + int(fragCoord.y)) % (2*SWAP_DISTANCE) < SWAP_DISTANCE) {\n            pixelOffset = -UP;\n        } else {\n  \t\t\tpixelOffset = UP;\n        }\n    } else {\n        if ((iFrame*SWAP_DISTANCE + int(fragCoord.x)) % (2*SWAP_DISTANCE) < SWAP_DISTANCE) {\n\t\t\tpixelOffset = -RIGHT;\n        } else {\n\t\t\tpixelOffset = RIGHT;\n        }\n    }\n    \n    pixelOffset *= SWAP_DISTANCE;\n    vec2 texelOffset = vec2(pixelOffset)*texel;\n    \n    // calculate other pixel coordinates\n    ivec2 otherFragCoord = ivec2(fragCoord) + pixelOffset;\n    \n    // check if other pixel is inside the bounds of the buffer\n    if (otherFragCoord.x >= 0 &&\n       \totherFragCoord.y >= 0 &&\n       \totherFragCoord.x < int(iResolution.x) &&\n        otherFragCoord.y < int(iResolution.y))\n    {\n        // fetch other pixel from buffer\n        vec4 other = texelFetch(iChannel0, otherFragCoord, 0);\n    \t\n        // calculate difference vectors from red-green uv plane\n        // this is the difference of the pixels red-green components\n        // from its expected position on a red-green uv plane\n        // basically: fragColor = vec4(uv, 0.0, 1.0);\n    \tvec2 diff = current.xy - uv;\n    \tvec2 otherDiff = other.xy - (uv + texelOffset);\n    \t\n        // calculate difference vectors if the pixels were swapped\n    \tvec2 diffSwapped = current.xy - (uv + texelOffset);\n    \tvec2 otherDiffSwapped = other.xy - uv;\n        \n        // calculate sum of sqare distances for unswapped pixels\n        float error = dot(diff, diff);\n        float otherError = dot(otherDiff, otherDiff);\n        float combinedError = error + otherError;\n        \n        // calculate sum of sqare distances for swapped pixels\n        float errorSwapped = dot(diffSwapped, diffSwapped);\n        float otherErrorSwapped = dot(otherDiffSwapped, otherDiffSwapped);\n        float combinedErrorSwitched = errorSwapped + otherErrorSwapped;\n    \t\n        // if the sum of sqare distances goes down, then swap pixels\n        if (combinedError > combinedErrorSwitched)  current = other;\n    }\n    \n    fragColor = current;\t// output to buffer\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// constants to calculte neighbouring pixels\nconst ivec2 UP = ivec2(0, 1);\nconst ivec2 RIGHT = ivec2(1, 0);\n\nconst float eps = 0.0000001;\n\nconst int SPACE_BAR = 32;\n\n// HSV <-> RGB conversion from https://www.shadertoy.com/view/lsS3Wc\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// using powers of two here might seem like an obvious choice,\n// but because powers of two share lots of factors this leads to blocking an all levels\n// using prime factors close to powers of five surprisingly gives me at least\n// a 10x speedup over even powers of 2 or 4\nconst int SWAP_DISTANCE = 23;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // fetch current pixel from buffer\n    vec4 current = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // values to calculate neighbours in uv space\n    vec2 texel = 1. / iResolution.xy;\n    \n    ivec2 pixelOffset;\n    \n    // swapping up, down, left, right is interleaved between frames\n    // idea taken from https://www.shadertoy.com/view/4dcGDf\n    // offets are set based on direction\n    // pixels are swapped in bands of width SWAP_DISTANCE\n    // this makes using multiple buffers effective\n    if (iFrame % 4 < 2) {\n        if ((iFrame*SWAP_DISTANCE + int(fragCoord.y)) % (2*SWAP_DISTANCE) < SWAP_DISTANCE) {\n            pixelOffset = -UP;\n        } else {\n  \t\t\tpixelOffset = UP;\n        }\n    } else {\n        if ((iFrame*SWAP_DISTANCE + int(fragCoord.x)) % (2*SWAP_DISTANCE) < SWAP_DISTANCE) {\n\t\t\tpixelOffset = -RIGHT;\n        } else {\n\t\t\tpixelOffset = RIGHT;\n        }\n    }\n    \n    pixelOffset *= SWAP_DISTANCE;\n    vec2 texelOffset = vec2(pixelOffset)*texel;\n    \n    // calculate other pixel coordinates\n    ivec2 otherFragCoord = ivec2(fragCoord) + pixelOffset;\n    \n    // check if other pixel is inside the bounds of the buffer\n    if (otherFragCoord.x >= 0 &&\n       \totherFragCoord.y >= 0 &&\n       \totherFragCoord.x < int(iResolution.x) &&\n        otherFragCoord.y < int(iResolution.y))\n    {\n        // fetch other pixel from buffer\n        vec4 other = texelFetch(iChannel0, otherFragCoord, 0);\n    \t\n        // calculate difference vectors from red-green uv plane\n        // this is the difference of the pixels red-green components\n        // from its expected position on a red-green uv plane\n        // basically: fragColor = vec4(uv, 0.0, 1.0);\n    \tvec2 diff = current.xy - uv;\n    \tvec2 otherDiff = other.xy - (uv + texelOffset);\n    \t\n        // calculate difference vectors if the pixels were swapped\n    \tvec2 diffSwapped = current.xy - (uv + texelOffset);\n    \tvec2 otherDiffSwapped = other.xy - uv;\n        \n        // calculate sum of sqare distances for unswapped pixels\n        float error = dot(diff, diff);\n        float otherError = dot(otherDiff, otherDiff);\n        float combinedError = error + otherError;\n        \n        // calculate sum of sqare distances for swapped pixels\n        float errorSwapped = dot(diffSwapped, diffSwapped);\n        float otherErrorSwapped = dot(otherDiffSwapped, otherDiffSwapped);\n        float combinedErrorSwitched = errorSwapped + otherErrorSwapped;\n    \t\n        // if the sum of sqare distances goes down, then swap pixels\n    \tif (combinedError > combinedErrorSwitched)  current = other;\n    }\n    \n    fragColor = current;\t// output to buffer\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// using powers of two here might seem like an obvious choice,\n// but because powers of two share lots of factors this leads to blocking an all levels\n// using prime factors close to powers of five surprisingly gives me at least\n// a 10x speedup over even powers of 2 or 4\nconst int SWAP_DISTANCE = 5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // fetch current pixel from buffer\n    vec4 current = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // values to calculate neighbours in uv space\n    vec2 texel = 1. / iResolution.xy;\n    \n    ivec2 pixelOffset;\n    \n    // swapping up, down, left, right is interleaved between frames\n    // idea taken from https://www.shadertoy.com/view/4dcGDf\n    // offets are set based on direction\n    // pixels are swapped in bands of width SWAP_DISTANCE\n    // this makes using multiple buffers effective\n    if (iFrame % 4 < 2) {\n        if ((iFrame*SWAP_DISTANCE + int(fragCoord.y)) % (2*SWAP_DISTANCE) < SWAP_DISTANCE) {\n            pixelOffset = -UP;\n        } else {\n  \t\t\tpixelOffset = UP;\n        }\n    } else {\n        if ((iFrame*SWAP_DISTANCE + int(fragCoord.x)) % (2*SWAP_DISTANCE) < SWAP_DISTANCE) {\n\t\t\tpixelOffset = -RIGHT;\n        } else {\n\t\t\tpixelOffset = RIGHT;\n        }\n    }\n    \n    pixelOffset *= SWAP_DISTANCE;\n    vec2 texelOffset = vec2(pixelOffset)*texel;\n    \n    // calculate other pixel coordinates\n    ivec2 otherFragCoord = ivec2(fragCoord) + pixelOffset;\n    \n    // check if other pixel is inside the bounds of the buffer\n    if (otherFragCoord.x >= 0 &&\n       \totherFragCoord.y >= 0 &&\n       \totherFragCoord.x < int(iResolution.x) &&\n        otherFragCoord.y < int(iResolution.y))\n    {\n        // fetch other pixel from buffer\n        vec4 other = texelFetch(iChannel0, otherFragCoord, 0);\n    \t\n        // calculate difference vectors from red-green uv plane\n        // this is the difference of the pixels red-green components\n        // from its expected position on a red-green uv plane\n        // basically: fragColor = vec4(uv, 0.0, 1.0);\n    \tvec2 diff = current.xy - uv;\n    \tvec2 otherDiff = other.xy - (uv + texelOffset);\n    \t\n        // calculate difference vectors if the pixels were swapped\n    \tvec2 diffSwapped = current.xy - (uv + texelOffset);\n    \tvec2 otherDiffSwapped = other.xy - uv;\n        \n        // calculate sum of sqare distances for unswapped pixels\n        float error = dot(diff, diff);\n        float otherError = dot(otherDiff, otherDiff);\n        float combinedError = error + otherError;\n        \n        // calculate sum of sqare distances for swapped pixels\n        float errorSwapped = dot(diffSwapped, diffSwapped);\n        float otherErrorSwapped = dot(otherDiffSwapped, otherDiffSwapped);\n        float combinedErrorSwitched = errorSwapped + otherErrorSwapped;\n    \t\n        // if the sum of sqare distances goes down, then swap pixels\n    \tif (combinedError > combinedErrorSwitched)  current = other;\n    }\n    \n    fragColor = current;\t// output to buffer\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// using powers of two here might seem like an obvious choice,\n// but because powers of two share lots of factors this leads to blocking an all levels\n// using prime factors close to powers of five surprisingly gives me at least\n// a 10x speedup over even powers of 2 or 4\nconst int SWAP_DISTANCE = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // fetch current pixel from buffer\n    vec4 current = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // values to calculate neighbours in uv space\n    vec2 texel = 1. / iResolution.xy;\n    \n    ivec2 pixelOffset;\n    \n    // swapping up, down, left, right is interleaved between frames\n    // idea taken from https://www.shadertoy.com/view/4dcGDf\n    // offets are set based on direction\n    // pixels are swapped in bands of width SWAP_DISTANCE\n    // this makes using multiple buffers effective\n    if (iFrame % 4 < 2) {\n        if ((iFrame*SWAP_DISTANCE + int(fragCoord.y)) % (2*SWAP_DISTANCE) < SWAP_DISTANCE) {\n            pixelOffset = -UP;\n        } else {\n  \t\t\tpixelOffset = UP;\n        }\n    } else {\n        if ((iFrame*SWAP_DISTANCE + int(fragCoord.x)) % (2*SWAP_DISTANCE) < SWAP_DISTANCE) {\n\t\t\tpixelOffset = -RIGHT;\n        } else {\n\t\t\tpixelOffset = RIGHT;\n        }\n    }\n    \n    pixelOffset *= SWAP_DISTANCE;\n    vec2 texelOffset = vec2(pixelOffset)*texel;\n    \n    // calculate other pixel coordinates\n    ivec2 otherFragCoord = ivec2(fragCoord) + pixelOffset;\n    \n    // check if other pixel is inside the bounds of the buffer\n    if (otherFragCoord.x >= 0 &&\n       \totherFragCoord.y >= 0 &&\n       \totherFragCoord.x < int(iResolution.x) &&\n        otherFragCoord.y < int(iResolution.y))\n    {\n        // fetch other pixel from buffer\n        vec4 other = texelFetch(iChannel0, otherFragCoord, 0);\n    \t\n        // calculate difference vectors from red-green uv plane\n        // this is the difference of the pixels red-green components\n        // from its expected position on a red-green uv plane\n        // basically: fragColor = vec4(uv, 0.0, 1.0);\n    \tvec2 diff = current.xy - uv;\n    \tvec2 otherDiff = other.xy - (uv + texelOffset);\n    \t\n        // calculate difference vectors if the pixels were swapped\n    \tvec2 diffSwapped = current.xy - (uv + texelOffset);\n    \tvec2 otherDiffSwapped = other.xy - uv;\n        \n        // calculate sum of sqare distances for unswapped pixels\n        float error = dot(diff, diff);\n        float otherError = dot(otherDiff, otherDiff);\n        float combinedError = error + otherError;\n        \n        // calculate sum of sqare distances for swapped pixels\n        float errorSwapped = dot(diffSwapped, diffSwapped);\n        float otherErrorSwapped = dot(otherDiffSwapped, otherDiffSwapped);\n        float combinedErrorSwitched = errorSwapped + otherErrorSwapped;\n    \t\n        // if the sum of sqare distances goes down, then swap pixels\n    \tif (combinedError > combinedErrorSwitched)  current = other;\n    }\n    \n    fragColor = current;\t// output to buffer\n}","name":"Buffer D","description":"","type":"buffer"}]}