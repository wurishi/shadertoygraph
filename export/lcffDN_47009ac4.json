{"ver":"0.1","info":{"id":"lcffDN","date":"1723994884","viewed":215,"name":"RIOW but with Disney BSDF + MIS","username":"Nguyen2007","description":"Multiple importance sampling implemented based on [url = https://www.shadertoy.com/view/MfXXzM] RIOW but with Disney BSDF [/url]\nSome color inconsistencies remain, and further refinements are needed. Suggestions for improvement are welcome!","likes":8,"published":3,"flags":32,"usePreview":1,"tags":["3d","raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nInspired by reinder RIOW inplementation (remove classes)\nSky texture (optimized) by AndrewHelmer: https://www.shadertoy.com/view/slSXRW\nChange scene in Common\nScene 1 doesn't work\n\n*/\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    if (ivec2(I) == ivec2(0))\n    {\n        O = vec4(0);\n        return;\n    }\n    \n    O = vec4(tone(texture(iChannel0, I / R.xy).xyz), 1);\n    //O = sqrt(texture(iChannel0, I / R.xy));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SPHERES 1\n#define CORNELL 2\n#define TESTALL 3\n\n#define SCENE 3\n#define SKYTYPE 0 // 0: No sky, 1: Sky used in RIOW, 2: Sky by Andrew\n\n//#define RUSSIAN_ROULETE\n\n#define ZERO min(0, iFrame)\n\n#define R iResolution\n\n#define TAU   6.28318530717958647693\n#define PI    3.14159265358979323846\n#define INVPI  .31830988618379067154\n\nfloat sqr(float x) {return x * x;}\nfloat sqr(vec3 v) {return dot(v, v);}\n\n#define dot2(v) dot(v, v)\n\n#define translate(p) mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -(p), 1)\n\nmat4 rotateX(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4(1, 0,  0, 0,\n                0, c, -s, 0,\n                0, s,  c, 0,\n\t\t\t    0, 0,  0, 1);\n}\n\nmat4 rotateY(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4( c, 0, s, 0,\n                 0, 1, 0, 0,\n                -s, 0, c, 0,\n\t\t\t     0, 0, 0, 1);\n}\n\nmat4 rotateZ(float a)\n{\n    float s = sin(a), c = cos(a);\n\n    return mat4(c, -s, 0, 0,\n                s,  c, 0, 0,\n                0,  0, 1, 0,\n\t\t\t    0,  0, 0, 1);\n}\n\nconst mat4 noTransform = mat4(1);\n\nfloat deNaN (float v)\n{\n    return v != v ? 0. : v;\n}\n\nvec3 deNaN(vec3 v)\n{\n    return vec3(deNaN(v.x), deNaN(v.y), deNaN(v.z));\n}\n\nstruct ray\n{\n    vec3 o, d;\n};\n\nstruct material\n{\n    vec3 baseColor, emission;\n    \n    float anisotropic,\n          metallic,\n          roughness,\n          subsurface,\n          specularTint,\n          sheen,\n          sheenTint,\n          clearcoat,\n          clearcoatRoughness,\n          specTrans,\n          IOR;\n};\n\nconst material initMat = material(vec3(0), vec3(0), 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.);\n\nstruct hitRec\n{\n    float t;\n    vec3 p, n;\n    material mat;\n    bool isSpecular, isVolume;\n};\n\nstruct cam\n{\n    vec3 o, llc, hor, ver, u, v, w;\n    float rad;\n};\n\nuvec4 seed;\n\nvec4 PCG(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    return vec4(v) / 4294967296.;\n}\n\n#define rand  rand4.x\n#define rand2 rand4.xy\n#define rand3 rand4.xyz\n#define rand4 PCG(seed)\n\n\nvec4 hash4(vec4 p)\n{\n\tuvec4 v = floatBitsToUint(p);\n    return PCG(v);\n}\n\nvec4 hash4(float v) {return hash4(vec4(v));}\nvec4 hash4(vec2 v)  {return hash4(v.xyxy);}\nvec4 hash4(vec3 v)  {return hash4(v.xyzx);}\n\n#define hash(v)  hash4(v).x\n#define hash2(v) hash4(v).xy\n#define hash3(v) hash4(v).xyz\n\n#define toWorld(x, y, z, v) mat3(x, y, z) * (v)\n#define toLocal(x, y, z, v) (v) * mat3(x, y, z)\n\nvec2 ranDir()\n{\n    float r = TAU * rand;\n    return vec2(cos(r), sin(r));\n}\n\n#define ranDisk() sqrt(rand) * ranDir()\n\nvec3 ranSph()\n{\n    float h = rand * 2. - 1.;\n\treturn vec3(sqrt(1. - h * h) * ranDir(), h);\n}\n\nvec3 ranCos()\n{\n    float r = rand;\n    return vec3(sqrt(r) * ranDir(), sqrt(1. - r));\n}\n\nvec3 ranTri(vec3 p0, vec3 p1, vec3 p2)\n{\n    return mix(p0, mix(p1, p2, rand), sqrt(rand));\n}\n\nvec3 ranQuad(vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n{\n    float area1 = length(cross(p0 - p1, p0 - p3)),\n          area2 = length(cross(p2 - p1, p2 - p3));\n    \n    return rand * (area1 + area2) < area1 ? ranTri(p0, p1, p3) : ranTri(p2, p1, p3);\n}\n\nfloat gauss()\n{\n    /*\n    float x = rand, w = -log(1. - x * x);\n    if (w < 5.)\n    \n        w -= 2.5,\n        x *= (((((((3.43273939e-7 + 2.81022636e-8 * w) * w - 3.5233877e-6) * w - 4.39150654e-6) * w + .00021858087) * w - .00125372503) * w - .00417768164) * w + .246640727) * w + 1.50140941;\n    \n    else\n    \n        w = sqrt(w) - 3.,\n        x *= (((((((.000100950558 - .000200214257 * w) * w + .00134934322) * w - .00367342844) * w + .00573950773) * w - .0076224613) * w + .00943887047) * w + 1.00167406) * w + 2.83297682;\n    \n    return x;\n    */\n    return .81 * atanh(rand);\n}\n\nvoid onb(vec3 N, out vec3 T, out vec3 B) \n{\n    float s = N.z > 0. ? 1. : -1.,\n          a = s + N.z,\n          b = -N.x * N.y / a;\n    \n    T = s * vec3(s - N.x * N.x / a, b, -N.x);\n    B =     vec3(b, s - N.y * N.y / a, -N.y);\n}\n\n#define luma(v) dot(vec3(.212671, .71516, .072169), v)\n\nfloat GTR1(float NoH, float a)\n{\n    if (a >= 1.) return 1. / PI;\n    a *= a;\n    return (a - 1.) / (PI * log(a) * (1. + (a - 1.) * NoH * NoH));\n}\n\nvec3 sampleGTR1(float a)\n{\n    a *= a;\n    float cosT2 = (1. - pow(a, rand)) / (1. - a);\n    return vec3(sqrt(1. - cosT2) * ranDir(), sqrt(cosT2));\n}\n\nvec3 VNDF(vec3 V, vec2 a)\n{\n    vec2 t   = sqrt(rand) * ranDir();\n         t.y = mix(sqrt(1. - t.x * t.x), t.y, .5 + .5 * V.z);\n    \n    float l = length(V.xy);\n    \n    vec3 T = l > 0. ? vec3(-V.y, V.x, 0) / l : vec3(1, 0, 0),\n         N = t.x * T + t.y * cross(V, T) + sqrt(1. - dot(t, t)) * V;\n\n    return normalize(vec3(a * N.xy, max(0., N.z)));\n}\n\nfloat GTR2Aniso(vec3 H, vec2 a)\n{\n    H.xy /= a;\n    return 1. / (PI * a.x * a.y * sqr(sqr(H)));\n}\n\nfloat smithG(float NoV, float a)\n{\n    a *= a;\n    float b = NoV * NoV;\n    return 2. * NoV / (NoV + sqrt(a + b - a * b));\n}\n\nfloat smithGAniso(vec3 V, vec2 a)\n{\n    V.xy *= a;\n    return 2. * V.z / (V.z + length(V));\n}\n\n#define schlick(v) pow(1. - abs(v), 5.)\n\nfloat fresnel(float cosI, float eta)\n{\n    cosI = abs(cosI);\n    float cosT = (1. - cosI * cosI) * eta * eta;\n\n    if (cosT >= 1.) return 1.;\n\n    cosT = sqrt(1. - cosT);\n\n    return (sqr(.5 - cosI / (eta * cosT + cosI))\n          + sqr(.5 - cosT / (eta * cosI + cosT))) * 2.;\n}\n\nvoid tint(material mat, out float F0, out vec3 Csheen, out vec3 Cspec)\n{\n    float lum = luma(mat.baseColor);\n    vec3 tint = lum > 0. ? mat.baseColor / lum : vec3(1);\n\n    F0 = sqr(2. / (1. + mat.IOR) - 1.);\n    \n    Cspec  = mix(vec3(1), tint, mat.specularTint) * F0;\n    Csheen = mix(vec3(1), tint, mat.sheenTint);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x), f = smoothstep(0., 1., fract(x));\n\t\n    return mix(mix(mix(hash(p                ), \n                       hash(p + vec3(1, 0, 0)), f.x),\n                   mix(hash(p + vec3(0, 1, 0)), \n                       hash(p + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix(hash(p + vec3(0, 0, 1)), \n                       hash(p + vec3(1, 0, 1)), f.x),\n                   mix(hash(p + vec3(0, 1, 1)), \n                       hash(p +            1.), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p, int o)\n{\n    float a = 0., w = 1.;\n     \n    for (int i = 0; i < o; i++)\n    {\n        w *= .5;\n        a += w * noise(p);\n        p *= 2.;\n    }\n    return a;\n}\n\nvec3 tone(vec3 v)\n{\n    mat3 m = mat3(84, 4, 4, 8, 88, 8, 8, 8, 88);\n    \n    v = clamp(log2(m * v) / 16.5 + .35, 0., 1.);\n    \n    v = (((((15.5 * v - 40.14) * v + 31.96) * v - 6.868) * v + .4298) * v + .1191) * v - .00232;\n    \n    v = 1e2 * inverse(m) * (tanh(3. * v * v - 1.5) / 1.81 + .5);\n    \n    //return mix(1.055 * pow(v, vec3(1) / 2.4) - .055, v * 12.92, lessThan(v, vec3(.0031308)));\n    return pow(v, vec3(.45));\n}\n\n#define setup(x) if(SKYTYPE < 2) return; if (vec2(I) == vec2(.5)) { O = R.xyxy; return; } I /= R.xy; if (texelFetch(x, ivec2(0), 0) == R.xyxy) { O = texture(x, I); return; }\n\nvec3 viewPos      = vec3(0, 6.3602, 0),\n     groundAlbedo = vec3(.3);\n\n#define sun(x) vec3(0, x, -sqrt(1. - sqr(x)))\n\n#define sunDir normalize(vec3(20, 1, -1))\n\n#define miePhase      .01627721008 * (1. + sqr(cosTheta)) / pow(1.64 - 1.6 * cosTheta, 1.5)\n\n#define rayleighPhase .05968310365 * (1. + sqr(cosTheta))\n\nvoid getValues(vec3 pos, out vec3 rayleigh, out float mie, out vec3 extinction)\n{\n    float height = 1e3 * length(pos) - 6360.;\n    \n    rayleigh = vec3(5.802, 13.558, 33.1) / exp(height / 8.);\n    \n    mie = exp(-height / 1.2);\n    \n    extinction = rayleigh + 8.396 * mie + vec3(.65, 1.881, .085) * max(0., 1. - abs(height - 25.) / 15.);\n    \n    mie *= 3.996;\n}\n\nfloat iSph(vec3 ro, vec3 rd, float rad)\n{\n    float b = dot(ro, rd),\n          d = rad * rad - sqr(ro - b * rd);\n\n    if (d < 0.) return -1.;\n    \n    d = sqrt(d);\n    \n    return -b > d ? -b - d : -b + d;\n}\n\nvec3 LUT(sampler2D tex, vec3 pos, vec3 sun)\n{\n    float height = length(pos);\n    return texture(tex, vec2(.5 + .5 * dot(sun, pos / height), 10. * height - 63.6)).rgb;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 O, vec2 I)\n{\n    setup(iChannel0)\n    \n    vec3 pos = vec3(0, 6.36 + .1 * I.y, 0),\n         sun = sun(2. * I.x - 1.);\n    \n    float dt = iSph(pos, sun, 6.46) / 40.,\n          t  = .3 * dt;\n    \n    O.xyz = vec3(1);\n    \n    for (int i = 0; i < 40; i++, t += dt)\n    {\n        vec3 rayleigh, extinction;\n        float mie;\n        \n        getValues(pos + t * sun, rayleigh, mie, extinction);\n        \n        O.xyz /= exp((i > 0 ? dt : t) * extinction);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 O, vec2 I)\n{\n    setup(iChannel1)\n    \n    vec3 pos = vec3(0, 6.36 + .1 * I.y, 0),\n         sun = sun(2. * I.x - 1.),\n         fms = vec3(0);\n    \n    O = vec4(0);\n    \n    for (float i = PI / 16.; i < PI; i += PI / 8.)\n    for (float j = .875; j > -1.; j -= .25)\n    {\n        vec3 rd     = vec3(sin(i), j, cos(i));\n             rd.xz *= sqrt(1. - sqr(j));\n\n        float ground   = iSph(pos, rd, 6.36),\n              dt       = ((ground > 0.) ? ground : iSph(pos, rd, 6.46)) / 20.,\n              cosTheta = dot(rd, sun),\n              t        = .3 * dt;\n\n        vec3 trans = vec3(1);\n        \n        for (int k = 0; k < 20; k++, t += dt)\n        {\n            vec3 newPos = pos + t * rd,\n                 rayleigh, extinction;\n            \n            float mie;\n            getValues(newPos, rayleigh, mie, extinction);\n\n            vec3 sampTrans = exp(-(k > 0 ? dt : t) * extinction),\n                 mu        = trans * (1. - sampTrans) / extinction;\n            \n            fms += (rayleigh + mie) * mu;\n\n            O.xyz += (rayleigh * rayleighPhase + mie * miePhase) * LUT(iChannel0, newPos, sun) * mu;\n            \n            trans *= sampTrans;\n        }\n\n        if (ground > 0. && dot(pos, sun) > 0.) O.xyz += trans * groundAlbedo * LUT(iChannel0, normalize(pos + ground * rd) * 6.36, sun);\n    }\n    \n    O.xyz /= 64. - fms;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 O, vec2 I)\n{\n    setup(iChannel2)\n    \n    I.x *= TAU;\n    \n    float height = length(viewPos);\n    \n    I.y = (I.y * 2. - 1.) * abs(I.y * 2. - 1.) * .5 * PI - asin(6.36 / height);\n    \n    vec3 rd     = vec3(-sin(I.x), cos(I.y), cos(I.x)),\n         sun    = sun(dot(sunDir, viewPos / height));\n         rd.xz *= -sin(I.y);\n    \n    float ground   = iSph(viewPos, rd, 6.36),\n          dt       = ((ground < 0.) ? iSph(viewPos, rd, 6.46) : ground) / 32.,\n          t        = .3 * dt,\n          cosTheta = dot(rd, sun);\n    \n\tO = vec4(0);\n    vec3 trans = vec3(1);\n    for (int i = 0; i < 32; i++, t += dt)\n    {\n        vec3 newPos = viewPos + t * rd;\n        \n        vec3 rayleigh, extinction;\n        float mie;\n        getValues(newPos, rayleigh, mie, extinction);\n        \n        vec3 sampTrans = exp(-(i > 0 ? dt : t) * extinction);\n        \n        O.xyz += ((rayleigh * rayleighPhase + mie * miePhase) * LUT(iChannel0, newPos, sun) + (rayleigh + mie) * LUT(iChannel1, newPos, sun)) * (1. - sampTrans) / extinction * trans;\n        \n        trans *= sampTrans;\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"bool volume(float N, float F, float dens, ray r, float tmin, float tmax, inout hitRec rec)\n{\n    N = max(N, tmin);\n    F = min(F, tmax);\n    \n    if (N > F) return false;\n        \n    N -= log(rand) / dens;\n        \n    if (N > F) return false;\n         \n    rec.t = N; \n    rec.p = r.o + r.d * N;\n    rec.n = ranSph();\n    \n    rec.isVolume = true;\n    \n    return true; \n}\n\nbool iSph(mat4 txx, float rad, float dens, ray r, float tmin, float tmax, inout hitRec rec)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz;\n    \n    float b = dot(ro, rd),\n          d = rad * rad - sqr(ro - b * rd);\n\n    if (d < 0.) return false;\n    \n    d = sqrt(d);\n    \n    float N = -b - d,\n          F = -b + d;\n    \n    if(dens > 0.) return volume(N, F, dens, r, tmin, tmax, rec);\n    \n    rec.isVolume = false;\n    \n    float t = N < tmin ? F : N;\n    \n    if(t < tmin || t > tmax) return false;\n    \n    rec.t = t;\n    rec.p = r.o + r.d * t;\n    rec.n = (inverse(txx) * vec4(ro + rd * t, 0) / rad).xyz;\n    \n    return true;\n}\n\nbool sphere(mat4 txx, float rad, ray r, float tmin, float tmax, out float t)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz;\n    \n    float b = dot(ro, rd),\n          d = rad * rad - sqr(ro - b * rd);\n\n    if (d < 0.) return false;\n    \n    d = sqrt(d);\n    \n    float N = -b - d,\n          F = -b + d;\n    \n    t = N < tmin ? F : N;\n    \n    if(t < tmin || t > tmax) return false;\n    \n    return true;\n}\n\nbool iBox(mat4 txx, vec3 rad, float dens, ray r, float tmin, float tmax, inout hitRec rec)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz,\n         \n    k = rad * sign(rd),\n                  \n\tt1 = (-ro - k) / rd,\n\tt2 = (-ro + k) / rd;\n    \n    float N = max(max(t1.x, t1.y), t1.z),\n          F = min(min(t2.x, t2.y), t2.z);\n    \n    if(N > F || F < tmin || N > tmax) return false;\n    \n    if(dens > 0.) return volume(N, F, dens, r, tmin, tmax, rec);\n    \n    rec.isVolume = false;\n\n    vec4 res = (N > tmin) ? vec4(N, step(vec3(N), t1))\n                          : vec4(F, step(t2, vec3(F)));\n    \n    rec.t = res.x;\n    rec.p = r.o + r.d * res.x;\n    rec.n = (inverse(txx) * vec4(-sign(rd) * res.yzw, 0)).xyz;\n\t\n\treturn true;\n}\n\nbool box(mat4 txx, vec3 rad, ray r, float tmin, float tmax, out float t)\n{\n    vec3 ro = (txx * vec4(r.o, 1)).xyz,\n\t     rd = (txx * vec4(r.d, 0)).xyz,\n\n\tk = rad * sign(rd),\n                  \n\tt1 = (-ro - k) / rd,\n\tt2 = (-ro + k) / rd;\n    \n    float N = max(max(t1.x, t1.y), t1.z),\n          F = min(min(t2.x, t2.y), t2.z);\n    \n    if(N > F || F < tmin || N > tmax) return false;\n    \n    t = N > tmin ? N : F;\n\t\n\treturn true;\n}\n\nconst int numSphereLights = 0,\n          numBoxLights = 1;\n\nint sphereLightId = -1,\n    boxLightId = -1;\n\nvec4[max(numSphereLights, 1)] sphereLights;\n\nstruct boxLight\n{\n    mat4 txx;\n    vec3 rad;\n};\n\nboxLight[max(numBoxLights, 1)] boxLights;\n\nbool lSph(mat4 txx, float rad, ray r, float tmin, float tmax, inout hitRec rec)\n{\n    sphereLights[sphereLightId++] = vec4((inverse(txx) * vec4(0, 0, 0, 1)).xyz, rad);\n    return iSph(txx, rad, 0., r, tmin, tmax, rec);\n}\n\nbool lBox(mat4 txx, vec3 rad, ray r, float tmin, float tmax, inout hitRec rec)\n{\n    boxLights[boxLightId++] = boxLight(txx, rad);\n    return iBox(txx, rad, 0., r, tmin, tmax, rec);\n}\n\nmaterial DIFFUSE(vec3 col)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.roughness = 1.;\n    \n    return mat;\n}\n\nmaterial METAL(vec3 col, float fuzz)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.metallic  = 1.;\n    mat.roughness = fuzz;\n    \n    return mat;\n}\n\nmaterial GLASS(vec3 col, float IOR)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    mat.specTrans = 1.;\n    mat.IOR       = IOR;\n    \n    return mat;\n}\n\nmaterial LIGHT(vec3 col)\n{\n    material mat = initMat;\n    mat.emission = col;\n    \n    return mat;\n}\n\nmaterial VOLUME(vec3 col)\n{\n    material mat  = initMat;\n    mat.baseColor = col;\n    \n    return mat;\n}\n\nbool worldHit(ray r, float tmin, float tmax, out hitRec rec)\n{\n    rec.t = tmax;\n    bool hit = false;\n    \n    if (SCENE == 1)\n    {\n        if (iBox(noTransform, vec3(1e3, .01, 1e3), 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = DIFFUSE(vec3(.5));\n        \n        if (iSph(translate(vec3(0, 1, 0)), 1., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = GLASS(vec3(1), 1.5);\n        \n        if (iSph(translate(vec3(-4, 1, 0)), 1., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = DIFFUSE(vec3(.4, .2, .1));\n        \n        if (iSph(translate(vec3(4, 1, 0)), 1., 0., r, tmin, rec.t, rec))\n        \n            hit = true, \n            rec.mat = METAL(vec3(.7, .6, .5), 0.);\n        \n        vec2 ro = r.o.xz, rd = r.d.xz, p = floor(ro), s = sign(rd), m,\n             d = (p - ro + .5 + s * .5) / rd, cen;\n        \n        bool bhit = false;\n        \n        float t;\n        if(box(translate(vec3(0, .2, 0)), vec3(12, .2, 12), r, tmin, rec.t, t))\n        for(int i = ZERO; i < 30; i++)\n        {\n            for(int j = ZERO; j < 4; j++)\n            {\n                cen  = p - vec2(j / 2, j % 2);\n                cen += .2 + .9 * hash2(cen);\n                \n                if (all(lessThan(abs(cen), vec2(12))))\n                if (sqr(abs(abs(cen.x) - 2.) - 2.) + sqr(cen.y) > .8)\n                if (iSph(translate(vec3(cen.x, .2, cen.y)), .2, 0., r, tmin, rec.t, rec))\n                {\n                    bhit = true;\n                    \n                    vec4 ran = hash4(cen);\n                    \n                    if(ran.w < .9)\n                    {\n                        if      (ran.w < .7) rec.mat = DIFFUSE(ran.xyz * ran.xyz * .9 + .1);\n                        else if (ran.w < .8) rec.mat = METAL(.5 * ran.xyz + .5, .5 * hash(ran));\n                        else                 rec.mat = GLASS(.5 * ran.xyz + .5, 1.5);\n                    }\n                \n                    else rec.mat = LIGHT(4. * ran.xyz);\n                }\n            }\n\n            if(bhit)\n            {\n                hit = true;\n                break;\n            }\n            \n            m = step(d, d.yx);\n            d += m / abs(rd);\n            p += m * s;\n        }\n    }\n    \n    if (SCENE == 2)\n    {\n        material red   = DIFFUSE(vec3(.65, .05, .05)),\n                 white = DIFFUSE(vec3(.73)),\n                 green = DIFFUSE(vec3(.12, .45, .15));\n        \n        if (iBox(translate(vec3(-278,    0,   0)), vec3(  1, 278, 278), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = red;\n        if (iBox(translate(vec3(   0, -278,   0)), vec3(278,   1, 278), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = white;\n        if (iBox(translate(vec3(   0,    0, 278)), vec3(278, 278,   1), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = white;\n        if (iBox(translate(vec3( 278,    0,   0)), vec3(  1, 278, 278), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = green;\n        if (iBox(translate(vec3(   0,  278,   0)), vec3(278,   1, 278), 0., r, tmin, rec.t, rec)) hit = true, rec.mat = white;\n        \n        if (SKYTYPE < 1)\n        if (lBox(translate(vec3(0, 278, 0)), vec3(65, 1, 53), r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = LIGHT(vec3(15));\n        \n        if (iBox(rotateY(-.1 * PI) * translate(-vec3(105, 195.5, 82)), vec3(82.5), 0., r, tmin, rec.t, rec))\n            \n            hit     = true, \n            rec.mat = white;\n\n        if (iBox(rotateY(PI / 12.) * translate(vec3(93.5, -113, 71)), vec3(82.5, 165, 82.5), 0., r, tmin, rec.t, rec))\n\n            hit     = true, \n            rec.mat = white;\n    }\n    \n    if (SCENE == 3)\n    {\n        if (SKYTYPE < 1)\n        if (lBox(translate(vec3(273, 555, 279.5)), vec3(150, .1, 132.5), r, tmin, rec.t, rec))\n       \n            hit = true,\n            rec.mat = LIGHT(vec3(7));\n        \n        if (iSph(translate(vec3(4e2 + 30. * rand, 400, 200)), 50., 0., r, tmin, rec.t, rec))\n            \n            hit = true,\n            rec.mat = DIFFUSE(vec3(.7, .3, .1));\n        \n        if (iSph(translate(vec3(260, 150, 45)), 50., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = GLASS(vec3(1), 1.5);\n        \n        if (iSph(translate(vec3(0, 150, 145)), 50., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = METAL(vec3(.8, .8, .9), .5);\n        \n        if (iSph(translate(vec3(220, 280, 300)), 80., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = DIFFUSE(vec3(.5 - .5 * sin(.1 * rec.p.x + 10. * fbm(.1 * rec.p, 7))));\n        \n        if (iSph(translate(vec3(360, 150, 145)), 70., 0., r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = GLASS(vec3(1), 1.5);\n        \n        if (iSph(translate(vec3(360, 150, 145)), 70., .2, r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = VOLUME(vec3(.2, .4, .9));\n        \n        if (iSph(translate(vec3(400, 200, 400)), 1e2, 0., r, tmin, rec.t, rec))\n            \n            hit = true,\n            rec.mat = GLASS(vec3(1), 1.04);\n        \n        if (iSph(translate(vec3(400, 200, 400)), 1e2, .2, r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = VOLUME(vec3(.4, .5, .7));\n        \n        if (iSph(noTransform, 1e3, .0001, r, tmin, rec.t, rec))\n        \n            hit = true,\n            rec.mat = VOLUME(vec3(1));\n        \n        mat4 txx = rotateY(PI / 12.) * translate(vec3(-17.5, 352.5, 477.5));\n        \n        vec3 roo = (txx * vec4(r.o, 1)).xyz,\n             rdd = (txx * vec4(r.d, 0)).xyz;\n\n        float t;\n\n        if (box(noTransform, vec3(100), ray(roo, rdd), tmin, tmax, t))\n        {\n            vec3 ro = roo / 20., s = sign(rdd), m,\n                 p = floor(ro + (all(lessThan(abs(ro), vec3(5))) ? tmin : t) * rdd / 20.),\n                 d = (p - ro + .5 + s * .5) / rdd;\n\n            bool bhit = false;\n            \n            for (int i = ZERO; i < 12; i++)\n            {\n                for(int j = ZERO; j < 27; j++)\n                {\n                    vec3 pos = p + vec3(j / 9, j / 3 % 3, j % 3) - 1.;\n\n                    if (all(lessThan(abs(pos), vec3(4.1))))\n                    if (iSph(translate(20. * pos + 15. * hash(pos) - 7.5), 10., 0., ray(roo, rdd), tmin, rec.t, rec))\n                        bhit = true;\n                }\n\n                if(bhit)\n                {\n                    hit = true;\n                    rec.p = r.o + r.d * rec.t;\n                    rec.n = (inverse(txx) * vec4(rec.n, 0)).xyz;\n                    \n                    rec.mat = DIFFUSE(vec3(.73));\n                    \n                    break;\n                }\n\n                m = step(d, d.yzx) * step(d, d.zxy);\n                d += m / abs(rdd);\n                p += m * s;\n            }\n        }\n        \n        vec2 ro = r.o.xz / 1e2, rd = r.d.xz, p = floor(ro) + .5, m,\n             s = sign(rd), d = (p - ro + s * .5) / rd;\n             \n        for (int i = ZERO; i < 26; i++)\n        {\n            if (all(lessThan(abs(p), vec2(1e3))))\n            if (iBox(translate(1e2 * vec3(p.x, 0, p.y)), vec3(50, 1e2 * hash(p), 50), 0., r, tmin, rec.t, rec))\n            {\n                hit = true;\n\n                rec.mat = DIFFUSE(vec3(.48, .83, .53));\n\n                break;\n            }\n\n            m = step(d, d.yx); \n            d += m / abs(rd);\n            p += m * s;\n        }\n    }\n    \n    rec.mat.roughness = max(rec.mat.roughness, .001);\n    \n    return hit;\n}\n\nvec3 diffuse(material mat, vec3 Csheen, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    float LoH = dot(L, H),\n    \n    Fs = mat.roughness * LoH * LoH,\n\n    Rr = 2. * Fs,\n\n    FL = schlick(L.z),\n    FV = schlick(V.z);\n\n    pdf = L.z / PI;\n    \n    return mix((1. - .5 * FL) * (1. - .5 * FV) + Rr * (FL + FV + FL * FV * (Rr - 1.)),\n                1.25 * (mix(1., Fs, FL) * mix(1., Fs, FV) * (1. / (L.z + V.z) - .5) + .5),\n                mat.subsurface) * mat.baseColor / PI + schlick(LoH) * mat.sheen * Csheen;\n}\n\nvec3 reflection(vec3 V, vec3 L, vec3 H, vec3 F, vec2 a, out float pdf)\n{\n    V.z = abs(V.z);\n    \n    pdf = smithGAniso(V, a) * GTR2Aniso(H, a) / 4. / V.z;\n    \n    return F * pdf * smithGAniso(L, a) / L.z;\n}\n\nvec3 refraction(material mat, vec3 V, vec3 L, vec3 H, vec3 F, vec2 a, out float pdf)\n{\n    float LoH = dot(L, H),\n          VoH = dot(V, H),\n    \n    k = GTR2Aniso(H, a) * smithGAniso(V, a) * abs(LoH) / sqr(LoH + VoH * mat.IOR) / V.z;\n\n    pdf = max(0., VoH) * k;\n    \n    L.z = -L.z;\n    \n    return sqrt(mat.baseColor) * (1. - F) * k * smithGAniso(L, a) * abs(VoH) / L.z * sqr(mat.IOR);\n}\n\nvec3 clearcoat(material mat, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    float VoH = dot(V, H),\n\n    D = GTR1(H.z, mat.clearcoatRoughness);\n    \n    pdf = D * H.z / 4. / VoH;\n    \n    return vec3(mix(.04, 1., schlick(VoH))) * D * smithG(L.z, .25) * smithG(V.z, .25);\n}\n\nvec4 BSDF(material mat, vec3 V, vec3 N, vec3 L, vec2 a)\n{\n    vec3 T, B;\n    \n    onb(N, T, B);\n\n    V = toLocal(T, B, N, V);\n    if (V.z < 0.) return vec4(0);\n    \n    L = toLocal(T, B, N, L);\n\n    vec3 H = normalize(L + V * (L.z > 0. ? 1. : mat.IOR));\n    if (H.z < 0.) H = -H;\n    \n    vec3 Csheen, Cspec;\n    float F0;\n    tint(mat, F0, Csheen, Cspec);\n\n    float dielectW = (1. - mat.metallic) * (1. - mat.specTrans),\n          metalW   = mat.metallic,\n          glassW   = (1. - mat.metallic) * mat.specTrans,\n\n    schlick = schlick(V.z),\n\n    diffP    = dielectW * luma(mat.baseColor),\n    dielectP = dielectW * mix(luma(Cspec), 1., schlick),\n    metalP   = metalW   * mix(luma(mat.baseColor), 1., schlick),\n    glassP   = glassW,\n    clearP   = mat.clearcoat / 4.,\n\n    tmp = 0., VoH = dot(V, H);\n    \n    float pdf = 0.;\n    vec3 f = vec3(0);\n    \n    if(L.z > 0.)\n    {\n        if (diffP > 0.)    f   += diffuse(mat, Csheen, V, L, H, tmp) * dielectW,\n                           pdf += tmp * diffP;\n\n        if (dielectP > 0.) f   += reflection(V, L, H, mix(Cspec, vec3(1), (fresnel(VoH, 1. / mat.IOR) - F0) / (1. - F0)), a, tmp) * dielectW,\n                           pdf += tmp * dielectP;\n\n        if (metalP > 0.)   f   += reflection(V, L, H, mix(mat.baseColor, vec3(1), schlick(VoH)), a, tmp) * metalW,\n                           pdf += tmp * metalP;\n        \n        if (clearP > 0.)   f   += clearcoat(mat, V, L, H, tmp) * clearP,\n                           pdf += tmp * clearP;\n    }\n    \n    if (glassP > 0.)\n    {\n        float F = fresnel(VoH, mat.IOR);\n        \n        if (L.z > 0.) f   += reflection(V, L, H, vec3(F), a, tmp) * glassW,\n                      pdf += tmp * glassP * F;\n                \n        else          f   = refraction(mat, V, L, H, vec3(F), a, tmp) * glassW,\n                      pdf = tmp * glassP * (1. - F);\n    }\n    \n    return vec4(f * abs(L.z), pdf / (diffP + dielectP + metalP + glassP + clearP));\n}\n\nvec4 scatter(inout ray r, inout hitRec rec)\n{\n    if(dot(rec.n, r.d) > 0.) rec.n = -rec.n;\n    else rec.mat.IOR = 1. / rec.mat.IOR;\n    \n    r.o = rec.p;\n    \n    material mat = rec.mat;\n\n    vec3 V, L, N = rec.n, T, B, H;\n    \n    onb(N, T, B);\n    \n    if(rec.isVolume)\n    {\n        r.d = ranSph();\n        return vec4(rec.mat.baseColor, 1);\n    }\n    \n    float aspect = sqrt(1. - .9 * mat.anisotropic);\n    vec2 a = sqr(mat.roughness) * vec2(1. / aspect, aspect);\n\n    V = toLocal(T, B, N, -r.d);\n    \n    vec3 Csheen, Cspec;\n    float F0;\n    tint(mat, F0, Csheen, Cspec);\n\n    float dielectW = (1. - mat.metallic) * (1. - mat.specTrans),\n          metalW   = mat.metallic,\n          glassW   = (1. - mat.metallic) * rec.mat.specTrans,\n\n    schlick = schlick(V.z),\n\n    diffP    = dielectW * luma(mat.baseColor),\n    dielectP = dielectW * mix(luma(Cspec), 1., schlick),\n    metalP   = metalW   * mix(luma(mat.baseColor), 1., schlick),\n    glassP   = glassW,\n    clearP   = mat.clearcoat / 4.,\n    \n    choose = rand * (diffP + dielectP + metalP + glassP + clearP);\n    \n    vec3 cdf;\n    cdf.x = diffP;\n    cdf.y = cdf.x + dielectP + metalP;\n    cdf.z = cdf.y + glassP;\n    \n    rec.isSpecular = true;\n\n    if (choose < cdf.x) L = ranCos(), rec.isSpecular = false;\n    \n    else if (choose < cdf.y) // Dielectric + Metallic reflection\n        \n        H = VNDF(V, a),\n        L = reflect(-V, H);\n    \n    else if (choose < cdf.z) // Glass\n    \n        H = VNDF(V, a),\n        L = (rand < fresnel(dot(V, H), mat.IOR)) ? reflect(-V, H) : refract(-V, H, mat.IOR);\n    \n    else // Clearcoat\n    \n        H = sampleGTR1(mat.clearcoatRoughness),\n        L = reflect(-V, H);\n    \n    r.d = toWorld(T, B, N, L);\n    \n    return BSDF(mat, toWorld(T, B, N, V), N, r.d, a);\n}\n\nvec3 sunWithBloom(vec3 rd)\n{\n    float x = .99995 - dot(rd, sunDir);\n    \n    if (x < 0.) return vec3(1);\n    \n    return vec3(smoothstep(.004, 2., exp(-x * 5e4) + 1. / (1. + x * 15e3)));\n}\n\nvec3 getValFromSkyLUT(vec3 rd, vec3 sun)\n{\n    float height = length(viewPos);\n    \n    vec3 up = viewPos / height;\n    \n    float u = 0., v = asin(6.36 / height) - acos(dot(rd, up));\n    \n    if (abs(v) < .5 * PI)\n    {\n        vec3 right = cross(sun, up), proj = normalize(rd - up * dot(rd, up));\n        u = atan(dot(proj, right), dot(proj, cross(up, right))) / TAU;\n    }\n    \n    return texture(iChannel1, vec2(u, sign(v) * sqrt(abs(v) / TAU)) + .5).rgb;\n}\n\nfloat heuristic(float a, float b)\n{\n    float t = a * a;\n    return t / (t + b * b);\n}\n\nvec3 color(ray r)\n{\n    vec3 col = vec3(1), tot = vec3(0);\n    float pdf;\n    \n\thitRec rec;\n    \n    rec.isSpecular = true;\n    \n    for (int i = ZERO; i < 10; i++)\n    {\n        if (worldHit(r, .01, 1e5, rec))\n        {\n            if(luma(rec.mat.emission) > 0.)\n            {\n                if(rec.isSpecular) tot += col * rec.mat.emission;\n                break;\n            }\n            \n            ray or = r;\n            \n            vec4 bsdf = scatter(r, rec);\n            \n            if(!rec.isSpecular && numSphereLights > 0)\n            {\n                vec4 sph = sphereLights[int(rand * float(numSphereLights))];\n\n                vec3 normal = ranSph(),\n                     ld     = normal * sph.w + sph.xyz - rec.p;\n\n                float dist = length(ld);\n\n                vec3 nld = ld / dist;\n\n                float sine = sqr(sph.w) / dot2(sph.xyz - rec.p);\n\n                float lPdf = 1. / (TAU * (1. - sqrt(clamp(1. - sine, 0., 1.))));\n\n                hitRec rec_;\n                \n                worldHit(ray(rec.p, nld), .01, 1e5, rec_);\n\n                if (abs(rec_.t - dist) < .01)\n                {\n                    vec4 bsdf = BSDF(rec.mat, -or.d, rec.n, nld, vec2(1));\n\n                    if (bsdf.w > 0.) tot += float(numSphereLights) * col * heuristic(lPdf, bsdf.w) * bsdf.xyz * rec_.mat.emission / lPdf;\n                }\n            }\n            \n            if(!rec.isSpecular && numBoxLights > 0)\n            {\n                boxLight box = boxLights[int(rand * float(numBoxLights))];\n                \n                vec3 rad = box.rad;\n                mat4 txx = box.txx;\n                \n                int r = int(rand * 3.);\n                \n                vec3 s = 2. * rand3 - 1.;\n                \n                float area = r < 1 ? 4. * rad.y * rad.z :\n                             r < 2 ? 4. * rad.z * rad.x :\n                                     4. * rad.x * rad.y ;\n                \n                s[r] = sign(s[r]);\n                \n                vec3 samp = rad * s;\n                \n                vec3 normal = (inverse(txx) * vec4(r == 0, r == 1, r == 2, 0)).xyz;\n                \n                vec3 ld = (inverse(txx) * vec4(samp, 1)).xyz - rec.p;\n                \n                float dist = length(ld);\n\n                vec3 nld = ld / dist;\n\n                float lPdf = sqr(dist) / (abs(dot(normal, nld)) * area);\n\n                hitRec rec_;\n                \n                worldHit(ray(rec.p, nld), .01, 1e5, rec_);\n\n                if (abs(rec_.t - dist) < .01)\n                {\n                    vec4 bsdf = BSDF(rec.mat, -or.d, rec.n, nld, vec2(1));\n\n                    if (bsdf.w > 0.) tot += 6. * float(numBoxLights) * col * heuristic(lPdf, bsdf.w) * bsdf.xyz * rec_.mat.emission / lPdf;\n                }\n            }\n            \n            if(bsdf.w > 0.) col *= bsdf.xyz / bsdf.w;\n            \n            #ifdef RUSSIAN_ROULETE\n            float p = 1. - 1. / luma(col + 1.);\n        \tif (rand > p) break;\n            col /= p;\n            #endif\n        }\n        \n        else\n        {\n            if(SKYTYPE == 1) tot += col * (1. - vec3(.25, .15, 0) * (r.d.y + 1.));\n            if(SKYTYPE == 2)\n            {\n                \n                vec3 lum = getValFromSkyLUT(r.d, sunDir);\n                if (iSph(viewPos, r.d, 6.36) < 0.) lum += 2e2 * sunWithBloom(r.d) * LUT(iChannel0, viewPos, sunDir);\n                tot += 30. * col * lum;\n            }\n            \n            break;\n    \t}\n    }\n    \n    return tot;\n}\n\ncam camera(vec3 ro, vec3 lp, vec3 vup, \n           float vfov, float aspect, float aperture, \n           float d)\n{\n    cam c;    \n    c.rad = aperture / 2.;\n    \n    float hh = tan(radians(vfov) / 2.) * d,\n          hw = aspect * hh;\n          \n    c.o = ro;\n    c.w = normalize(ro - lp);\n    c.u = normalize(cross(vup, c.w));\n    c.v = cross(c.w, c.u);\n    c.llc = c.o - hw * c.u - hh * c.v - d * c.w;\n    c.hor = 2. * hw * c.u;\n    c.ver = 2. * hh * c.v;\n    \n    return c;\n}\n\nray getRay(cam c, vec2 uv)\n{\n    vec2 rd = c.rad * ranDisk();\n    \n    c.o += c.u * rd.x + c.v * rd.y;\n    \n    return ray(c.o, normalize(c.llc + uv.x * c.hor + uv.y * c.ver - c.o));\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    \n    if (vec2(I) == vec2(.5))\n    {\n        O = vec4(R.xy, SCENE, SKYTYPE);\n        return;\n    }\n    \n    if (abs(2. * I.x - R.x) * .75 > R.y)\n    {\n        O = vec4(0);\n        return;\n    }\n    \n    seed = uvec4(I, iFrame, I.x * I.y);\n    \n    vec3 col = vec3(0);\n    \n    int samp = 2, i = ZERO;\n    \n    for(; i < samp; i++)\n    {\n        vec2 uv = I + rand2;\n        \n        if(rand < 0.) uv += R.y * ranDir() * gauss() * (rand < .5 ? .03 : .1);\n        \n        uv /= R.xy;\n        vec3 ro, lp;\n        cam c;\n        \n        float aspect = R.x / R.y;\n        \n        if (SCENE == 1) c = camera(vec3(13, 2, 3), vec3(0), vec3(0, 1, 0), 20., aspect, .1, 10.);\n        if (SCENE == 2) c = camera(vec3(0, 0, -1078), vec3(0), vec3(0, 1, 0), 40., aspect, 0., 1.);\n        if (SCENE == 3) c = camera(vec3(478, 278, -600), vec3(278, 278, 0), vec3(0, 1, 0), 40., aspect, 0., 1.);\n        \n        col += color(getRay(c, uv));\n    }\n    \n    col /= vec3(samp);\n    \n    if (texelFetch(iChannel2, ivec2(0), 0) == vec4(R.xy, SCENE, SKYTYPE))\n    {\n        vec4 pre = texture(iChannel2, I / R.xy);\n        O = vec4(mix(pre.rgb, col, pre.a /= pre.a + 1.), pre.a);\n    }\n    \n    else O = vec4(col, 1);\n}","name":"Buffer D","description":"","type":"buffer"}]}