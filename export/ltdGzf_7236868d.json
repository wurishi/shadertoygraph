{"ver":"0.1","info":{"id":"ltdGzf","date":"1470720463","viewed":189,"name":"Some Terrain","username":"dmemes","description":"I have no idea what I'm doing.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 lightDirection = normalize(vec3(.2, -.2, -.5));\nconst vec3 SUN_COLOR = vec3(1.0, .95, .85);\n\nconst float HASH_SCALE = .1031;\nconst mat2 rotate2D = mat2(1.5623, 1.7531, -1.8131, 1.8623);\nconst vec2 add = vec2(1.0, 0.0);\n\nconst float SEA_LEVEL = 0.0;\n\nconst vec3 WATER_COLOR = vec3(0.302,0.694,0.933);\nconst vec3 SKY_COLOR = vec3(0.824,0.894,1.000);\nconst vec3 ROCK_COLOR = vec3(0.275,0.275,0.275);\nconst vec3 GRASS_COLOR = vec3(0.690,0.804,0.588);\nconst vec3 SNOW_COLOR = vec3(0.949,0.949,0.949);\nconst vec3 SAND_COLOR = vec3(0.918,0.812,0.635);\n\n#define MAX_DISTANCE 800.0\n\nfloat hash12(in vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASH_SCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(in vec2 xz)\n{\n\tvec2 f = fract(xz);\n\txz = floor(xz);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn\tmix(mix(hash12(xz), hash12(xz + add.xy), u.x),\n\tmix(hash12(xz + vec2(0.0, 1.0)), hash12(xz + add.xx), u.x), u.y);\n}\nvec3 noiseD(in vec2 x)\n{\n\tx+=4.2;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(1.5-f)*2.0;;\n    \n    float a = hash12(p);\n    float b = hash12(p + add.xy);\n    float c = hash12(p + add.yx);\n    float d = hash12(p + add.xx);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(f-1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\nfloat terrain(in vec2 p)\n{\n    p *= .003;\n    \n    float a = 3.8;\n    float o = -.1;\n    vec2 d = vec2(0);\n\n    for (int i = 0; i < 8; i++)\n    {\n        float v;\n        \n        vec3 nD = noiseD(p);\n        d += nD.yz;\n        v = nD.x/(1.+dot(d,d));\n\n        v = pow(1.0-abs(v-.5)*2., 1.5);\n        o += v * a;\n\n        \n       \tv = noise(p*.1);\n        o-= v*a*.3;\n        \n        a *= -.43;\n        p = rotate2D*p;   \n    }\n    return (1.0-o)*(1.0 - o) * 3.0;\n}\nfloat mapterrain(in vec3 p)\n{\n    return p.y - terrain(p.xz);\n}\n\nfloat cloud(in vec2 p){\n    return terrain(p);\n}\nfloat mapcloud(in vec3 p){\n    float h = noise(p.xz);\n    if (h > 1.0){\n\t\treturn p.y - ((h * 10.0) + 70.0);\n    }else{\n    \treturn 100000.0;\n\t}\n}\n\nfloat map(in vec3 p){\n\treturn mapterrain(p);\n}\n\nbool trace(vec3 o, vec3 r, out float dist)\n{\n    float t = 0.0;\n    float lastH = 0.0;\n    float lastT = 0.0;\n    \n    bool fin = false;\n    for (int i = 0; i < 160; ++i){\n    \tvec3 p = o + r * t;\n        float h = map(p);\n        \n        if (h < .1){\n            fin = true;\n            if (h > map(o + r * (t + h*.5))){\n            \tlastT = t;\n            \tt += h * .5;\n            }\n            break;\n        }\n        \n        lastT = t;\n        t += h * .5;\n        lastH = h;\n        \n        if (t > MAX_DISTANCE) break;\n    }\n    \n    if (fin){ // perform binary subdivision\n        float hT;\n        for (int n = 0; n < 32; n++){\n            if (map(o + r * lastT) < map(o + r * t)){\n                t = (t, lastT) * .5;\n            }else{\n                lastT = (t, lastT) * .5;\n            }\n        }\n        if (map(o + r * lastT) < map(o + r * t)){\n            dist = lastT;\n        }else{\n            dist = t;\n        }\n    }\n    return fin;\n}\nbool traceWater(vec3 o, vec3 r, out float t){\n    t = 0.0;\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float denom = dot(n, r);\n    if (abs(denom) > 0.0001){\n        t = dot(vec3(0.0, SEA_LEVEL, 0.0) - o, n) / denom;\n    }\n    return t > 0.0;\n}\n\nvec3 getNorm(vec3 pos){\n    float p = .1;\n    vec3 v1 = vec3(0.0, terrain(pos.xz), 0.0);\n    vec3 v2 = v1 - vec3(p, terrain(pos.xz + vec2(p, 0.0)), 0.0);\n    vec3 v3 = v1 - vec3(0.0, terrain(pos.xz + vec2(0, -p)), -p);\n    return normalize(cross(v2, v3));\n}\nvec3 getWaterNorm(vec3 pos){\n    vec2 o = pos.xz*1.5 + vec2(cos(iTime*2.0), sin(iTime*2.0));\n    float p = .1;\n    float s = .1;\n    vec3 v1 = vec3(0.0, abs(noise(o)) * s, 0.0);\n    vec3 v2 = v1 - vec3(p, abs(noise(o + vec2(p, 0.0)))*s, 0.0);\n    vec3 v3 = v1 - vec3(0.0, abs(noise(o + vec2(0, -p)))*s, -p);\n    return normalize(cross(v2, v3));\n}\n\nvec3 getSky(in vec3 r, bool sun){\n\tfloat sunAmount = max( dot(r, -lightDirection), 0.0 );\n\tfloat v = pow(1.0-max(r.y,0.0),4.);\n\tvec3  sky = mix(SKY_COLOR, SKY_COLOR * .65, v);\n\tsky = sky + SUN_COLOR * sunAmount * sunAmount * .15;\n\tif (sun) sky = sky + SUN_COLOR * min(pow(sunAmount, 500.0), .6);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nfloat shadow(vec3 pos){\n    /*float t = .1;\n    for (float steps = 0.0; steps < 32.0; steps++){\n        float h = map(pos + -lightDirection * t);\n        \n        if (h < 0.001)\n            return 0.3;\n        t += h;\n    }*/\n    return 1.0;\n}\n\nvec3 getColor(in vec3 pos, in vec3 norm, in vec3 r, in float t){\n    vec3 col = GRASS_COLOR;\n    \n    // snow color\n    if (pos.y > 14.0){\n        col = mix(col, SNOW_COLOR, clamp((pos.y - 14.0) * .2, 0.0, 1.0));\n    } \n\t\n    // beach color\n    if (pos.y < SEA_LEVEL + 2.0){\n        col = mix(col, SAND_COLOR, clamp((1.0 -  (pos.y - SEA_LEVEL)) * .75, 0.0, 1.0));\n    }\n    \n    // rock color\n    if (norm.y < .75)\n        col = mix(col, ROCK_COLOR, clamp((.75 - norm.y) / .3, 0.0, 1.0));\n    \n    // diffuse lighting\n    col *= dot(lightDirection, -norm);\n    \n    // sky\n    col = mix(getSky(r, false), col, exp(-t*.001));\n    \n    return col * shadow(pos);\n}\nvec3 getWaterColor(vec3 pos, vec3 o, vec3 r, vec3 norm, bool reflection){\n    // water reflection\n    vec3 refl = SKY_COLOR;\n\n    vec3 o2 = vec3(pos.x, SEA_LEVEL, pos.z);\n    vec3 r2 = reflect(r, norm);\n    float t2 = 0.0;\n    if (reflection && trace(o2, r2, t2) && distance(o, o2 + r2 * t2) < MAX_DISTANCE){\n        vec3 pos2 = o2 + r2 * t2;\n        vec3 norm2 = getNorm(pos2);\n\n        refl = getColor(pos2, norm2, r2, t2);\n    }else{\n        refl = getSky(reflect(r, norm), false);\n    }\n\t\n    float fresnel = dot(norm, r);\n\t\n    vec3 refr = SAND_COLOR;\n\t\n    vec3 col = mix(mix(refl, refr, fresnel), WATER_COLOR, .2);\n\t\n    // water specular\n    vec3 ref = -normalize(reflect(r, norm));\n    float spec = dot(lightDirection, ref);\n    if (spec > 0.0)\n        col += pow(spec, 40.0);\n    \n    return col * shadow(pos);\n}\n\nvec3 render(vec2 fragCoord, vec3 o, vec3 r){\n    vec3 col = SKY_COLOR;\n    \n    float t = 0.0;\n    if (trace(o, r, t)){\n    \tvec3 pos = o + r * t;\n\t\tvec3 norm = getNorm(pos);\n        \n        if (pos.y < SEA_LEVEL){\n            traceWater(o, r, t);\n            col = getWaterColor(o + r * t, o, r, getWaterNorm(o+r*t), true);\n            \n        }else{\n        \tcol = getColor(pos, norm, r, t);\n        }\n    }else if (o.y > SEA_LEVEL && r.y < 0.0){ // water in the horizon\n        if (traceWater(o, r, t)){\n            vec3 p = o + r * t;\n        \tcol = getWaterColor(p, o, r, getWaterNorm(p), false);\n        }\n    }else{\n        col = getSky(r, true);\n    }\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    Camera camera = load_camera(iChannel0);\n    \n    vec3 dir = vec3(0,0,1.75);\n    dir.xy = (fragCoord + 0.5) / iResolution.xy * 2.0 - vec2(1);\n    dir.x *= iResolution.x / iResolution.y;\n    dir = normalize(dir);\n    dir = euler_yx(camera.euler) * dir;\n    \n    vec3 color = render(fragCoord, camera.position, dir);\n    \n\tfloat CONTRAST = 1.0;\n\tfloat SATURATION = 1.0;\n\tfloat BRIGHTNESS = 1.0;\n\tcolor = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), color*BRIGHTNESS)), color*BRIGHTNESS, SATURATION), CONTRAST);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define M_PI 3.14159265359\n\n// Camera //\nstruct Camera {\n    vec3 position;\n    vec2 euler;\n    vec4 prev_mouse;\n    bool moved;\n};\nCamera load_camera(sampler2D channel) {\n    Camera camera;\n    vec4 p0 = texelFetch(channel, ivec2(0,0), 0);\n    camera.position   = p0.xyz;\n    camera.moved      = p0.w > 0.0;\n    camera.euler      = texelFetch(channel, ivec2(1,0), 0).xy;\n    camera.prev_mouse = texelFetch(channel, ivec2(2,0), 0);\n    return camera;\n}\n\n\n// Utils //\nmat3 euler_yx(vec2 euler) {\n    vec2 sin_euler = sin(euler);\n    vec2 cos_euler = cos(euler);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0,  cos_euler.x, sin_euler.x, \n                     0.0, -sin_euler.x, cos_euler.x);\n    mat3 rotY = mat3(cos_euler.y, 0.0, -sin_euler.y, \n                     0.0, 1.0, 0.0, \n                     sin_euler.y, 0.0,  cos_euler.y);    \n    return rotY * rotX;\n}\nmat3 euler_y(float a) {\n\tmat3 ret = mat3(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// WASD camera\n\nconst int KEY_SPACE = 32;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_S     = 83;\nconst int KEY_W     = 87;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\n\nbool key_down   (int key) { return texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0; }\nbool key_toggled(int key) { return texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0; }\n\nvoid update_camera(inout Camera camera) {\n    float speed = iTimeDelta * 1.5;    \n    if (key_down(KEY_SHIFT))\n        speed *= 10.0;\n    \n    vec3 v = vec3(0.0);\n    if (key_down(KEY_W))     v.z += speed;\n    if (key_down(KEY_S))     v.z -= speed;\n    if (key_down(KEY_A))     v.x -= speed;\n    if (key_down(KEY_D))     v.x += speed;\n    if (key_down(KEY_CTRL))  v.y -= speed;\n    if (key_down(KEY_SPACE)) v.y += speed;\n    \n    camera.position += euler_yx(camera.euler) * v;\n    camera.moved = any(notEqual(v, vec3(0.0)));\n        \n    if (iMouse.z > 0.0 && camera.prev_mouse.z > 0.0) {\n        vec2 d = ((iMouse.xy - camera.prev_mouse.xy) / iResolution.xy) * 2.5;\n        d.y = -d.y;\n    \tcamera.euler += d.yx;\n        camera.euler.x = clamp(camera.euler.x, -M_PI * .5, M_PI * .5);\n        camera.moved = true;\n    }\n    \n    camera.prev_mouse = iMouse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 ipos = ivec2(fragCoord);\n    if (ipos.y == 0 && ipos.x < 3) {\n        Camera camera;\n        if (iFrame == 0) {\n            camera.position = vec3(1000, 40, 0);\n            camera.euler    = vec2(0, 0);\n            camera.prev_mouse = iMouse;\n            camera.moved = true;\n        } else\n            camera = load_camera(iChannel0);\n            \n        update_camera(camera);\n        \n        if      (ipos.x == 0) fragColor = vec4(camera.position, camera.moved ? 1.0 : 0.0);\n        else if (ipos.x == 1) fragColor = vec4(camera.euler, 0.0, 0.0);\n        else if (ipos.x == 2) fragColor = camera.prev_mouse;\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}