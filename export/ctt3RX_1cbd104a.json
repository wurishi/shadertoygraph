{"ver":"0.1","info":{"id":"ctt3RX","date":"1682863860","viewed":165,"name":"Pirate_Broadcast","username":"kinakomoti","description":"This work was submitted to GLSL compo at the demo party \"Sessions\".\nDue to the long compile time, you may not be able to see it in some cases.\n\nYoutube Video : https://youtu.be/51PUSHVuLAI\n","likes":9,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarching","tv","demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0,uv);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define TAU 6.283185307179586476925286766559\n\n#define tv_ID 1\n#define tumami_ID 2\n#define screen_ID 3    \n#define floor_ID 4\n#define light_ID 5\n\n//Scene Time\nfloat worldTime = 0.0;\nfloat TIME = 0.0,SAM = 0.0;\nint ID = -1;\n#define S(a) TIME=max(TIME,step(worldTime,SAM+a-0.01)*(worldTime-SAM));ID+=int(step(SAM,worldTime));SAM+=a;\n\n//main_camera\nvec3 mainCameraP = vec3(0.0);\nvec3 mainCameraD = vec3(0.0);\nvec2 mainCameraUV = vec2(0.0);\n\n//main_object \nvec3 mainObjectP = vec3(0.0);\nint objID = 0;\n\n//sub object\nvec3 subObjectP = vec3(-10.0);\n\n//Debug\nfloat debugfactor = 0.0;\n\n//-------------------------------\n//Debug\n//--------------------------------\n\n//-------------------------------\n//Math\n//-------------------------------\n\n//Rotate\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n//point simetric\nvec2 point_symmetric(vec2 p) {\n    vec2 n = normalize(vec2(-1, 1));\n    return (p.x + p.y > 0.0) ? p : p - 2.0 * n * dot(p,n);\n}\n\n//tangent space\nvoid tangentSpaceBasis(vec3 normal,inout vec3 t,inout vec3 b){\n    if (abs(normal.y) < 0.9)\n    {\n        t = cross(normal, vec3(0, 1, 0));\n    }\n    else\n    {\n        t = cross(normal, vec3(0, 0, -1));\n    }\n    t = normalize(t);\n    b = cross(t, normal);\n    b = normalize(b);\n}\n//basis transformation\nvec3 worldtoLoacal(vec3 v,vec3 lx, vec3 ly,vec3 lz){\n    return vec3(v.x * lx.x + v.y* lx.y + v.z * lx.z,\n                 v.x * ly.x + v.y * ly.y + v.z * ly.z,\n                 v.x * lz.x + v.y * lz.y + v.z * lz.z);\n}\n\nvec3 localToWorld(const vec3 v, const vec3 lx, const vec3 ly,\n                   const vec3 lz)\n{\n    return vec3(v.x * lx.x + v.y * ly.x + v.z * lz.x,\n                 v.x * lx.y + v.y * ly.y + v.z * lz.y,\n                 v.x * lx.z + v.y * ly.z + v.z * lz.z);\n}\n\nbool is_inside(float t, float a, float b){\n    return (t >= a && t <= b);\n}\n\nvec2 kaleido_pmod(vec2 p, float r)\n{\n    float a = atan(-p.x, -p.y) + PI;\n\n    float n = TAU / r;\n    float ID = floor(a / n);\n\n    p.x *= (int(ID) % 2 == 0) ? 1.0 : -1.0;\n    float b = atan(-p.x, -p.y) + PI;\n    ID = floor(b/n);\n    b = ID*n;\n\n    return rotate(p,-b);\n}\n\n//--------------------------------\n//Hash\n//--------------------------------\n\n//Blue Noise\n#define hash(p)  fract(sin(mod(dot(p, vec2(12.9898, 78.233)),6.283)) * 43758.5453)\n\n//hash\nfloat hash11(float s) {\n    return fract(sin(s) * 43758.5453123);\n}\n\nfloat hash21(vec2 s) {\n    return fract(sin(dot(s, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat hash31(vec3 s) {\n    return fract(sin(dot(s, vec3(12.9898, 78.233, 45.164))) * 43758.5453123);\n}\n\nvec2 hash12(float s) {\n    return fract(sin(vec2(s * 194.2, s * 293.2)) * 43758.5453123);\n}\n\nvec2 hash22(vec2 s) {\n    return fract(sin(vec2(dot(s, vec2(12.9898, 78.233)), dot(s, vec2(45.164, 39.645)))) * 43758.5453123);\n}\n\nvec2 hash32(vec3 s) {\n    return fract(sin(vec2(dot(s, vec3(12.9898, 78.233, 45.164)), dot(s, vec3(39.645, 45.164, 12.9898)))) * 43758.5453123);\n}\n\nvec3 hash13(float s) {\n    return fract(sin(vec3(s * 194.2, s * 293.2, s * 394.2)) * 43758.5453123);\n}\n\nvec3 hash23(vec2 s) {\n    return fract(sin(vec3(dot(s, vec2(12.9898, 78.233)), dot(s, vec2(45.164, 39.645)), dot(s, vec2(39.645, 45.164)))) * 43758.5453123);\n}\n\nvec3 hash33(vec3 s) {\n    return fract(sin(vec3(dot(s, vec3(12.9898, 78.233, 45.164)), dot(s, vec3(39.645, 45.164, 12.9898)), dot(s, vec3(45.164, 12.9898, 78.233)))) * 43758.5453123);\n}\n\n\n//-------------------------------\n//Font\n//-------------------------------\n\n#define FontWidth 8\n#define FontHeight 8\n#define LineMaxLength 40\n#define FontSize 37.0\n\nivec2 font_data[37] = ivec2[](\n    ivec2(0x00000000,0x00000000), //space\n    ivec2(0x7e91897e,0x00000000), //0\n    ivec2(0x01ff4121,0x00000000), //1\n    ivec2(0x71898543,0x00000000), //2\n    ivec2(0x6e919142,0x00000000), //3\n    ivec2(0x08ff4838,0x00000000), //4\n    ivec2(0x8e9191f2,0x00000000), //5\n    ivec2(0x0e91916e,0x00000000), //6\n    ivec2(0xc0b08f80,0x00000000), //7\n    ivec2(0x6e91916e,0x00000000), //8\n    ivec2(0x6e919162,0x00000000), //9\n    ivec2(0x7f88887f,0x00000000), //A\n    ivec2(0x6e9191ff,0x00000000), //B\n    ivec2(0x4281817e,0x00000000), //C\n    ivec2(0x7e8181ff,0x00000000), //D\n    ivec2(0x919191ff,0x00000000), //E\n    ivec2(0x909090ff,0x00000000), //F\n    ivec2(0x4685817e,0x00000000), //G\n    ivec2(0xff1010ff,0x00000000), //H\n    ivec2(0x0081ff81,0x00000000), //I\n    ivec2(0x80fe8182,0x00000000), //J\n    ivec2(0x413608ff,0x00000000), //K\n    ivec2(0x010101ff,0x00000000), //L\n    ivec2(0x601060ff,0x000000ff), //M\n    ivec2(0x0c1060ff,0x000000ff), //N\n    ivec2(0x7e81817e,0x00000000), //O\n    ivec2(0x609090ff,0x00000000), //P\n    ivec2(0x7f83817e,0x00000001), //Q\n    ivec2(0x619698ff,0x00000000), //R\n    ivec2(0x4e919162,0x00000000), //S\n    ivec2(0x80ff8080,0x00000080), //T\n    ivec2(0xfe0101fe,0x00000000), //U\n    ivec2(0x0e010ef0,0x000000f0), //V\n    ivec2(0x031c03fc,0x000000fc), //W\n    ivec2(0x340834c3,0x000000c3), //X\n    ivec2(0x300f30c0,0x000000c0), //Y\n    ivec2(0xe1918d83,0x00000081) //Z\n);\n\nvec3 font(vec2 uv,int id){\n    vec2 uv1 = uv;\n    uv = uv * 8.0;\n    ivec2 texel = ivec2(uv);\n    int bit_offset = texel.x * FontWidth + texel.y;\n\n    int s,t;\n    s = font_data[id].x;\n    t = font_data[id].y;\n\n    int tex = 0;\n    \n    if(bit_offset <= 31){\n        s = s >> bit_offset;\n        s = s & 0x00000001;\n        tex = s;\n    }\n    else{\n        t = t >> (bit_offset - 32);\n        t = t & 0x00000001;\n        tex = t;\n    }\n\n    tex = (abs(uv1.x - 0.5) < 0.5 && abs(uv1.y - 0.5) < 0.5) ? tex : 0;\n    return vec3(tex); \n}\n\n//-------------------------------\n//SDF\n//-------------------------------\n\nfloat sdf_union(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat sdf_substract(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat sdf_intersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\n//box\nfloat sdf_box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//sphere\nfloat sdf_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n//cylinder\nfloat sdf_cylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n//ellipsoid\nfloat sdf_ellipsoid(vec3 p, vec3 r) {\n    float k1 = length(p / r);\n    float k2 = length(p / (r * r));\n    return k1 * (k1 - 1.0) / k2;\n}\n\n//plane\nfloat sdf_plane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\n//BoxFrame\nfloat sdf_boxframe( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdf_cylinder_ana(vec3 p, float h,float r,float thin){\n    float d1 = sdf_cylinder(p,h,r);\n    float d2 = sdf_cylinder(p,h + 1.0,r - thin);\n\n    return sdf_substract(d2,d1);\n}\n\n//--------------------------------\n//2D SDF\n//--------------------------------\nfloat d2_sdf_box(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat d2_sdf_sphere(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat d2_sdf_arc(vec2 p,vec2 sc,float ra, float rb )\n{\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat d2_sdf_rhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat d2_sdf_EquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\n\n//-------------------------------\n//Struct\n//-------------------------------\nstruct material_data {\n    int id;\n    vec2 uv;\n    vec3 pos;\n    vec3 normal;\n\n    vec3 c_pos;\n    vec3 c_dir;\n    float d;\n\n    vec2 screen_uv;\n\n    vec3 light_col;\n    float light_dist;\n};\n\n//-------------------------------\n//easing\n//-------------------------------\nfloat beat(float t, float e){\n    float s = sin(t * PI * 2.0 / e);\n    return pow(s,8.0);\n}\n\nfloat saturate(float t){\n    return clamp(t,0.0,1.0);\n}\n\nfloat easeInSine(float t){\n    t = saturate(t);\n    return 1.0 - cos(t * PI * 0.5);\n}\n\nfloat easeOutSine(float t){\n    t = saturate(t);\n    return sin(t * PI * 0.5);\n}\n\nfloat easeInOutSine(float t){\n    t = saturate(t);\n    return -(cos(PI * t) - 1.0) / 2.0;\n}\n\nfloat easeInQuad(float t){\n    t = saturate(t);\n    return t*t;\n}\n\nfloat easeOutQuad(float t){\n    t = saturate(t);\n    return 1.0 - (1.0 - t)*(1.0 - t);\n}\n\nfloat easeInOutQuad(float t){\n    t = saturate(t);\n    return (t < 0.5) ? 2.0*t*t : 1.0 - pow(-2.0*t + 2.0, 2.0) / 2.0;\n}\n\nfloat easeOutCubic(float t){\n    t = saturate(t);\n    return 1.0 - pow(1.0 - t, 3.0);\n}\nfloat easeOutBounce(float t){\n    const float n1 = 7.5625;\n    const float d1 = 2.75;\n    t = saturate(t);\n\n    if (t < 1.0/d1) {\n        return n1*t*t;\n    } else if (t < 2.0/d1) {\n        return n1*(t-=(1.5/d1))*t + 0.75;\n    } else if (t < 2.5/d1) {\n        return n1*(t-=(2.25/d1))*t + 0.9375;\n    } else {\n        return n1*(t-=(2.625/d1))*t + 0.984375;\n    }\n}\n\nfloat easeOutBack(float t){\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n    t = saturate(t);\n    return 1.0 + c3 * pow(t - 1.0, 3.0) + c1 * pow(t - 1.0, 2.0);\n}\n\nfloat easeInOutJump(float t){\n    t = saturate(t);\n    return (t - t * t) / 0.25;\n}\n\nfloat easeInBack(float t){\n    t = saturate(t);\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return c3 * t * t * t  - c1 * t * t;\n}\n\n//--------------------------------\n//Texture\n//--------------------------------\n\nfloat voronoi3d(vec3 p,inout float d1,inout float d2){\n    vec3 sr_i = floor(p);\n    vec3 sr_f = fract(p);\n\n    d1 = 2.0;\n    d2 = 2.0;\n    for(int i = -1; i <= 1; i++){\n        for(int j = -1; j <= 1; j++){\n            for(int k = -1; k <= 1; k++){\n                vec3 cell_idx = vec3(i,j,k);\n                vec3 cell_offset = cell_idx + hash33(cell_idx + sr_i);\n                vec3 point_dist = abs(sr_f - cell_offset);\n                float dist = max(max(point_dist.x,point_dist.y),point_dist.z);\n\n                if(dist < d1){\n                    d2 = d1;\n                    d1 = dist;\n                }\n                else if(dist < d2){\n                    d2 = dist;\n                }\n            }\n        }\n    }\n\n    return d1;\n}\n\nvec3 circuit(vec3 pos,vec3 circuit_color){\n    float d1,d2,d3,d4;\n    vec3 offset = vec3(1) + vec3(0,worldTime * 2.0,0);\n    vec3 scale = vec3(1);\n    voronoi3d(pos,d1,d2);\n    voronoi3d(pos * scale+offset ,d3,d4);\n\n    float clack_1 = d2 - d1;\n    float clack_2 = d4 - d3;\n\n    float line_width = 0.04;\n\n     vec3 col = vec3(0);\n    \n    col = (clack_2 < line_width && clack_1 < 0.01) ?  circuit_color : col;\n    col = (abs(clack_1 - 0.02) < 0.005) ? circuit_color : col; \n\n    return col;\n}\n\n//-------------------------------\n//sequence\n//--------------------------------\n\nfloat time_normalize(float time, float a ,float b){\n    return saturate((time - a) / (b - a));\n}\n\nvoid counter(float t,float a,inout int ID){\n    ID += (t > a) ? 1 : 0;\n}\n\n//-------------------------------\n//Map\n//-------------------------------\n\nfloat brownTV(vec3 p, inout material_data mat) {\n    vec2 screen_size = vec2(0.9, 0.8);\n    vec3 screen_offset = vec3(0.0, -0.2, 1.5);\n\n    vec3 p1 = p;\n    float scale = 1.0 + 0.2 * abs(p.z + 1.0);\n    p1.xy *= scale;\n    float d1 = sdf_box(p1, vec3(1.0, 1.0, 0.8)) / scale;\n\n    vec3 p2 = p + vec3(0, 0, 1.0);\n    float d2 = sdf_box(p2, vec3(1.0, 1.0, 0.4));\n\n    //screen_box\n    vec3 p3 = p + screen_offset;\n    float d3 = sdf_box(p3, vec3(screen_size, 0.4));\n\n    //tumami\n    vec3 tumami_p = p;\n    tumami_p += vec3(-0.7, 0.75, 1.37);\n    tumami_p.yz = rotate(tumami_p.yz, PI * 0.5);\n    float tumami_d1 = sdf_cylinder(tumami_p, 0.1, 0.1);\n    float tumami_d2 = sdf_cylinder(tumami_p + vec3(0.4, 0.0, 0.0), 0.1, 0.1);\n\n    float tumami_d = sdf_union(tumami_d1, tumami_d2);\n\n    //screen\n    vec3 p5 = p + vec3(0.0, -screen_offset.y, 0.9);\n    float d5 = sdf_ellipsoid(p5, vec3(2.0, 2.0, 0.5));\n    float screen_d = sdf_intersect(d5, d3); \n\n    //material ID\n    int tv_id = tv_ID;\n    int tumami_id = tumami_ID;\n    int screen_id = screen_ID;    \n\n    //uv\n    float r_m = max(screen_size.x, screen_size.y);\n    vec2 r_of = p.xy + screen_offset.xy;\n\n    mat.uv = r_of / r_m;\n\n    float d = sdf_union(d1, d2);\n    d = sdf_substract(d3, d);\n    mat.id = tv_id;\n\n    mat.id = (tumami_d < d) ? tumami_id : mat.id;\n    d = sdf_union(tumami_d, d);\n\n    mat.id = (screen_d < d) ? screen_id : mat.id;\n    d = sdf_union(screen_d, d);\n\n    d -= 0.02;\n    return d;\n}\n\nfloat point_box(vec3 p,float s1,float s2,vec2 b,float rot){\n    float dif = s1 - s2;\n    vec3 p1 = p - vec3(0,dif + s2,0.);\n    p1.xz = rotate(p1.xz,p.y * rot);\n    float d = sdf_box(p1,vec3(b.x,dif,b.y));\n    return d;\n}\n\nfloat ifs_box(vec3 p,float time){\n    float d = 1000.0;\n    vec3 p1 = p;\n    p1 -= vec3(0.0,0.0,0.0);\n    p1.xy = rotate(p1.xy,time);\n    p1.yz = rotate(p1.yz,time);\n    \n    p1 = abs(p1) - vec3(1.0,0.0,0.1);\n    p1.xy = rotate(p1.xy,time);\n    p1.yz = rotate(p1.yz,time * 2.0 + 2.1);\n\n    for(int i = 0; i < 4; i++){\n        float dt = sdf_box(p1,vec3(0.2,2.0,0.5));\n        p1 = abs(p1) - vec3(1.0,0.0,0.1);\n        p1.xy = rotate(p1.xy,time);\n        p1.yz = rotate(p1.yz,time * 2.0 + 2.1);\n\n        d = min(dt,d);\n    } \n    return d;\n}\n\nfloat convergence(float x,float a){\n    float x1 = x - a;\n    return (step(0.0,x1) * ( - exp(-x1) + 1.0) + step(x1,0.0) * x1) + a;\n}\n\nfloat light_sdf(vec3 p,inout vec3 light_col){\n    float d = 100.0;\n    vec3 p1;\n\n    vec3 centralP = p - mainObjectP;    \n    light_col = vec3(1.0);\n\n    float beat_ = beat(worldTime,1.0) * 0.5 + 0.5;\n\n    if(ID == 0){\n        p1 = centralP;\n        d = sdf_sphere(p1,1.0);\n        return d;\n    }\n    else if(ID == 1){\n        p1 = centralP;\n        d = sdf_sphere(p1,1.0);\n        return d;\n    }\n    else if(ID == 2){\n        p1 = centralP;\n        d = sdf_sphere(p1,1.0);\n        return d;\n    }\n    else if(ID == 3){\n        vec3 mainObj_light1 = vec3(1.0,1.0,1.0);\n        //--------------------------------\n        float normal_time31 = time_normalize(TIME,13.0,14.5);\n        float normal_time32 = time_normalize(TIME,14.0,15.5);\n        float size31 = (1.0 + beat(worldTime,1.0) * 0.1) / (1.001 - easeInQuad(normal_time31));\n        float size32 = (1.0 + beat(worldTime,1.0) * 0.1) / (easeInQuad(normal_time32) + 0.001);\n        \n        size31 = (1.0 + beat(worldTime,1.0) * 0.1);\n\n        centralP.y -= -4.0 * (easeInQuad(time_normalize(TIME,39.0,40.0)));\n        centralP.xy = rotate(centralP.xy,PI + TIME);\n        centralP.yz = rotate(centralP.yz,PI + TIME);\n        vec3 p311 = centralP;\n        p311 *= size31;\n\n        vec3 p312 = centralP;\n        p312 *= size32;\n\n        float main_d31 = sdf_sphere(p311,1.0) / size31; \n        float main_d32 = sdf_box(p312,vec3(1.0)) / size32;\n\n        float main_d311;\n\n\n        if(objID == 0){\n            mainObj_light1 = vec3(1.0);\n            main_d311 = sdf_sphere(p311,1.0) / size31;\n        }\n        else if(objID == 1){\n            mainObj_light1 = vec3(0.1,0.1,1.0);\n            main_d311 = sdf_boxframe(p311,vec3(1.0),0.1) / size31;\n        }\n        else{\n            mainObj_light1 = vec3(0.1,0.1,1.0);\n            float d331 = sdf_box(p311,vec3(1.0)) / size31;\n            float d332 = sdf_box(abs(p311) - 0.7,vec3(0.6)) / size31;\n\n            mainObj_light1 = (d331 > d332) ? vec3(0.0) : mainObj_light1;\n            main_d311 = min(d331,d332);\n        }\n\n        d = main_d311;\n        light_col = mainObj_light1;\n        //--------------------------------\n        \n        //Pole\n        vec3 p32 = p;\n        p32.x = mod(p32.x, 12.0) - 6.0;\n        p32.z += 10.0;\n\n        float cycle31 = 4.0;\n        float localTime31 = time_normalize(mod(TIME, cycle31),1.0,2.0);\n        float count_cycle31 = float(int(floor((TIME / cycle31))) % 2);\n\n        float s31 = mix(-3.0,10.0,easeInOutQuad(time_normalize(mod(TIME, cycle31),1.0,2.0)));\n        float s32 = mix(-3.0,10.0,easeInOutQuad(time_normalize(mod(TIME - 0.5, cycle31),1.0,2.0)));\n\n        float move_box = point_box(p32,s31,s32,vec2(1.0,1.0),count_cycle31);\n        \n        //Sphere\n        float offset_mask = float(is_inside(TIME,20.0,40.0));\n        float offset_mask1 = float(is_inside(TIME,18.5,20.0) || bool(offset_mask));\n        float ring_mask = float(is_inside(TIME,19.0,40.0));\n\n        float local_time3 = mod(TIME,2.0);\n        float local_time31 = time_normalize(local_time3,0.0,1.0);\n        float ease31 = easeInOutJump(local_time31);\n        float offset31 = ease31 * 2.5;\n        offset31 -= 3.0;\n        \n        float size_offset31 = 0.1 * easeInOutJump(time_normalize(local_time3,1.0,2.0));\n        vec3 size331 = vec3(0.5) + vec3(size_offset31,-size_offset31,size_offset31) * offset_mask1;\n\n        vec3 p33 = p - subObjectP;\n\n        //Loop\n        {\n            p33.y -= offset31 * offset_mask1;\n            p33.y -= size331.y * offset_mask1;\n            p33.x -= easeInOutQuad(local_time31)* 4.0 * offset_mask;\n        }\n\n        vec3 ring_p3 = p - subObjectP;\n        float ring_dis;\n        {\n            float local_time33 = mod(TIME-1.0,2.0);\n            float ease_33 = easeOutCubic(local_time33 * 2.0);\n            \n            float radius = 3.0 * ease_33;\n            float thin = 0.2 * (1.0 - ease_33);\n            float fade = ease_33 * 0.3;\n       \n            ring_p3.x = mod(ring_p3.x,4.0) - 2.0;\n            ring_p3.y -= -4.0;\n\n            ring_p3.y += fade;\n            \n            float ring_d1 = sdf_cylinder_ana(ring_p3,1.0,radius,thin);\n            float ring_d2 = sdf_cylinder_ana(ring_p3 - vec3(4.0,0.0,0.0),1.0,radius,thin);\n            float ring_d3 = sdf_cylinder_ana(ring_p3 + vec3(4.0,0.0,0.0),1.0,radius,thin);\n\n            ring_dis = min(ring_d1,ring_d2);\n            ring_dis = min(ring_dis,ring_d3);\n        }\n\n        p33.x = mod(p33.x, 4.0) - 2.0;\n\n        {\n        p33.xy = rotate(p33.xy,-PI * 4.0 * easeInOutQuad(local_time31) * offset_mask);\n        }\n\n        vec3 p331 = p33 * size31; \n        vec3 p332 = p33 * size32;\n        \n        float subObj_d;\n        vec3 subObj_col;\n        if(objID == 0){\n            subObj_col = vec3(1.0);\n            subObj_d = sdf_sphere(p331,0.5) / size31;\n        }\n        else if(objID == 1){\n            subObj_col = vec3(0.1,0.1,1.0);\n            subObj_d = sdf_box(size331,size331) / size32;\n        }\n        else{\n            subObj_col = vec3(1.0);\n            subObj_d = sdf_box(p331,size331) / size32;\n        }\n\n        light_col = (move_box < d) ? vec3(0.0,0.0,0.0) : light_col;\n        d = sdf_union(d,move_box);\n\n        light_col = (subObj_d < d) ? subObj_col : light_col;\n        d = sdf_union(d,subObj_d);\n\n        d = bool(ring_mask) ? sdf_union(d,ring_dis) : d;\n        \n        light_col *= beat_;\n\n        return d;\n    }\n    else if(ID == 4){\n        float frequent = 4.0;\n        float local_time41 = mod(TIME,4.0);\n\n        vec3 p41 = centralP;\n        vec3 p42 = p;\n\n        float mask_pole1 = float(is_inside(local_time41,2.0,3.0));\n        float mask_pole2 = float(is_inside(local_time41,3.0,4.0));\n        float mask_light = float(is_inside(local_time41,1.0,2.0));\n        \n        vec3 object_light = vec3(1.0) * mask_light;\n        vec3 pole_light1 = vec3(0.2,0.2,0.8) * mask_light;\n        vec3 pole_light2 = vec3(0.8,0.2,0.2) * mask_light;\n\n        //Main Object\n        {\n            float d4_obj = 1000.0;\n            float size1 = 1.0 + beat(worldTime,1.0) * 0.1;\n            p41 *=size1;\n\n            //lastOffset\n        \n            d4_obj = ifs_box(p41,TIME);\n            light_col = (d < d4_obj) ? vec3(1.0) : light_col;\n            d = min(d,d4_obj / size1);\n        }\n\n        vec3 pole_color = vec3(1.0);\n        float pole_dist = 10000.0;\n        //pole\n        {\n            float local_pole_time =  time_normalize(mod(local_time41,1.0),0.0,1.0);\n\n\n            p42.x -= 1.0;\n            p42.x = mod(p42.x, 14.0) - 7.0;\n            p42.z += 2.0 * mask_pole1;\n            p42.z = mod(p42.z, 4.0) - 2.0;\n\n            float y_up = 10.0;\n            float y_down = -8.0;\n\n            float ease_1 = easeInOutQuad(local_pole_time);\n\n            float point_y1;\n            float point_y2;\n\n            point_y1 = (bool(mask_pole1)) ? y_down + ease_1 * (y_up - y_down) : y_up;\n            point_y2 = (bool(mask_pole1)) ? y_down : y_up + ease_1 * (y_down - y_up) ;\n            float d4_pole = point_box(p42,point_y1,point_y2,vec2(0.3,0.3),0.0);\n\n            pole_dist =(is_inside(local_time41,2.0,4.0)) ?  d4_pole : pole_dist;\n            pole_color = mask_pole1 * pole_light1 + mask_pole2 * pole_light2;\n        }        \n\n        light_col = (pole_dist < d) ? pole_color : object_light;\n        d = sdf_union(d,pole_dist);\n\n        light_col *= beat_;\n\n        return d;\n    }\n    else if(ID == 5){\n        float local_time51 = convergence(TIME,5.0);\n        float local_time52 = time_normalize(TIME,8.0,8.0);\n        float local_time53 = time_normalize(TIME,8.0,12.0);\n        \n\n        vec3 p51 = centralP;\n        float size51 = 1.0 + beat(local_time51,1.0) * 0.1;\n\n        p51.z -= 30.0 * easeInBack(local_time53);\n        float offset51 = -20.0;\n        float x5 = p51.z - offset51;\n        size51 += 1.0 / (1.001 - local_time53) - 1.0;\n\n        p51.xy = rotate(p51.xy,p51.z * local_time53 * PI);\n        p51.xy *=size51;\n        \n\n        float main_d51 = ifs_box(p51,local_time51);\n\n        light_col = vec3(1.0);\n\n        d = main_d51;\n        return d;\n    }\n\n}\n\nfloat map(vec3 p, inout material_data mat) {\n    float d;\n\n    vec3 tvp = p;\n    float loop = 2.0;\n    tvp.xy = mod(tvp.xy, loop) - loop * 0.5;\n    d = brownTV(tvp, mat);\n\n    vec3 plane_p = p;\n    float p_d1 = sdf_plane(plane_p, vec3(0, 1, 0), 2.0);\n    float p_d2 = sdf_plane(plane_p, vec3(0, -1, 0), 6.0);\n\n    mat.id = (p_d1 < d) ? floor_ID : mat.id;\n    mat.id = (p_d2 < d) ? floor_ID : mat.id;\n    d = sdf_union(d, p_d1);\n    d = sdf_union(d, p_d2);\n\n    vec3 light_col = vec3(0.0);\n    float light_d = light_sdf(p,light_col);\n    mat.id = (light_d < d) ? light_ID : mat.id;\n    mat.light_col = light_col;\n    mat.light_dist = light_d;\n    d = sdf_union(d, light_d);\n\n    return d;\n}\n\n\nfloat screen2_map(vec3 p, inout material_data mat) {\n    return sdf_sphere(p - mainObjectP, 0.85);\n}\n\nvec3 get_normal(vec3 p) {\n    vec2 epsiron = vec2(0.001, 0.0);\n    material_data dammy;\n    return normalize(vec3(map(p + epsiron.xyy, dammy) - map(p - epsiron.xyy, dammy), map(p + epsiron.yxy, dammy) - map(p - epsiron.yxy, dammy), map(p + epsiron.yyx, dammy) - map(p - epsiron.yyx, dammy)));\n}\n\nvec3 get_normal2(vec3 p) {\n    vec2 epsiron = vec2(0.001, 0.0);\n    material_data dammy;\n    return normalize(vec3(screen2_map(p + epsiron.xyy, dammy) - screen2_map(p - epsiron.xyy, dammy), screen2_map(p + epsiron.yxy, dammy) - screen2_map(p - epsiron.yxy, dammy), screen2_map(p + epsiron.yyx, dammy) - screen2_map(p - epsiron.yyx, dammy)));\n}\n\n//--------------------------------\n//Screens\n//--------------------------------\n\nvec3 white_noise(vec2 uv, float offset) {\n    return vec3(hash21(uv + TIME + offset * 10.0));\n}\n\nvec3 screen_sphere(vec2 uv, float offset) {\n    vec3 col = vec3(0.0);\n\n    vec3 ro = mainCameraP;\n    vec3 rd = normalize(vec3(mainCameraUV, 2.0));\n\n    float t;\n    float d = 0.0;\n    material_data dammy;\n\n    for(int i = 0; i < 20; i++) {\n        t = screen2_map(ro + rd * d, dammy);\n        d += t;\n        if(i < -1) break;\n    }\n\n    if(t < 0.01) {\n        vec3 normal = get_normal2(ro + rd * d);\n        col = normal * 0.5 + 0.5;\n    }\n\n    return col;\n}\n\nvec3 screen_hacking(vec2 uv, float offset) {\n    uv = uv * 0.5 + 0.5;\n    vec2 uv1 = uv * 40.0;\n    \n    uv1.y -= floor(TIME) * 1.2;\n\n    ivec2 index = ivec2(uv1 / vec2(0.8,1.2));\n    uv1.x = mod(uv1.x,0.8);\n    uv1.y = mod(uv1.y,1.2);\n    \n    int isLine = 10 - int(floor(worldTime)) + int((hash11(offset) - 0.5) * 3.0);\n    bool line_mask = (float(LineMaxLength) * fract(TIME) > float(index.x)) ? true : false;\n\n    vec2 rnd_index = vec2(hash11(float(index.y) + offset),hash21(vec2(index) + offset));\n    int max_char = int(rnd_index.x * float(LineMaxLength));\n\n    int char_index = int(rnd_index.y * 37.0);\n    //int char_index = int(rnd_index.y * 100.0); //Bug\n\n    char_index = (index.x < max_char) ? char_index : 0;\n\n    vec3 col = vec3(font(uv1,char_index)); \n\n    if(isLine == index.y) \n    {\n        col *= float(line_mask);\n    }\n    else{\n        col *= float(index.x < LineMaxLength);\n        col *= float(index.y > isLine);\n    }\n\n    return col * vec3(0.1,1.0,0.1);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 screen_kaleidoscope(vec2 uv){\n    uv *= 10.0;\n\n    uv = kaleido_pmod(uv,8.0);\n    uv += vec2(1.0) * sin(TIME);\n    uv = rotate(uv,PI*0.25 * TIME);\n\n    float sum_size = 1.0;\n    float size =1.1;\n    float d = 100.0;\n    float sum = 0.0;\n\n    for(float i = 0.; i < 9.0; i++){\n\n        float td = d2_sdf_rhombus(uv,vec2(0.1 / sum_size,1.0 * sum_size)) / sum_size;\n        float td1 = d2_sdf_box(mod(uv,5.0) - 2.5,vec2(0.03 / sum_size,1.0 * sum_size)) / sum_size;\n        td = min(td,td1);\n\n        uv = abs(uv) - vec2(1.0,1.0 + 0.7 * sin(floor(TIME)));\n        uv = kaleido_pmod(uv,2.0);\n        d = min(td,d);\n\n        uv = rotate(uv,PI*0.25 * floor(TIME));\n\n        uv *= size;\n        sum_size *= size;\n\n        sum += (1.0 - d) / 10.0;\n    }\n\n    vec3 col = palette(sum,vec3(0.5),vec3(0.5),vec3(1.0),vec3(0.0,0.1,0.2));\n    return col;\n}\n\nvec3 start_stop(vec2 p,int id){\n    float d_start = d2_sdf_EquilateralTriangle(rotate(p * 2.5,PI * 1.5)) / 2.5 - 0.01;\n\n    vec2 p1 = abs(p) - vec2(0.15,0.0);\n    float d_stop = d2_sdf_box(p1,vec2(0.05,0.3));\n\n    p.x *= -1.0;\n    float d1 = d2_sdf_EquilateralTriangle(rotate((p-vec2(0.3,0.0)) * 2.5,PI * 1.5)) / 2.5;\n    float d2 = d2_sdf_EquilateralTriangle(rotate((p+vec2(0.3,0.0)) * 2.5,PI * 1.5)) / 2.5;\n    \n    float d_hayaokuri = sdf_union(d1,d2);\n\n    int ID_test = id;\n    float d = d_start;\n    d = (ID_test == 1) ? d_stop : d;\n    d = (ID_test == 2) ? d_hayaokuri : d;\n    \n    return (d < 0.01) ? vec3(1.0) : vec3(0.0);\n}\n\n//color bar\nvec3 color_bar(vec2 uv){\n    vec3 col = vec3(1.0);\n    uv = uv * 0.5 + 0.5;\n\n    int index = int(floor(uv.x * 6.0));\n\n    uv.x = (floor(uv.y * 3.0) >= 1.0 ) ?  uv.x : ((int(floor(uv.x * 8.0)) % 2 == 0) ? 0.95 : - uv.x);\n\n    float R = (int(floor(uv.x * 4.0)) % 2 == 0) ? 0.8 : 0.0;\n    float G = (int(floor(uv.x * 2.0)) % 2 == 0) ? 0.8 : 0.0;\n    float B = (int(floor(uv.x * 8.0)) % 2 == 0) ? 0.8 : 0.0;\n\n    vec3 col1 = vec3(0.0);\n    col1 = (index == 1) ? vec3(0.8) : vec3(0.0);\n    col1 = (index == 0) ? vec3(0.002,0.012,0.05) : col1;\n    col1 = (index == 2) ? vec3(0.025,0.00,0.107) : col1;\n\n    col = (floor(uv.y * 12.0) >= 3.0 ) ? vec3(R,G,B): col1;\n\n    return col;\n}\n\n//Logos\nfloat logo_sdf_S(vec2 p, float thin){\n    vec3 col = vec3(0.0);\n    float angle = 4.2;\n    vec2 uv1 = p;\n    uv1.y -= 0.2 + thin;\n    uv1 = rotate(uv1,angle);\n    float d1 = d2_sdf_arc(uv1,vec2(sin(angle),cos(angle)),0.3,thin);\n    \n    vec2 uv2 = p;\n    uv2.y += 0.2 + thin;\n    uv2 = rotate(uv2,angle + PI);\n    float d2 = d2_sdf_arc(uv2,vec2(sin(angle),cos(angle)),0.3,thin);\n\n    return min(d1,d2);\n}\n\nfloat logo_sdf_E(vec2 p,float thin){\n    vec2 uv1 = vec2(p.x,abs(p.y));\n    float d1 = d2_sdf_box(uv1,vec2(0.4,thin));\n    uv1.y += -0.7 + thin;\n    float d2 = d2_sdf_box(uv1,vec2(0.4,thin));\n\n    float d = min(d1,d2);\n\n    vec2 uv2 = p;\n    float d3 = d2_sdf_box(uv2 + vec2(0.3,0.0),vec2(thin,0.7));\n    \n    d = min(d,d3);\n\n    return d;\n}\n\n\nfloat logo_sdf_N(vec2 p,float thin){\n    vec2 uv1 = abs(p);\n    uv1 += vec2(-0.482,0.0);\n    float d1 = d2_sdf_box(uv1,vec2(thin,0.7));\n\n    vec2 uv2 = p;\n    uv2 = rotate(uv2,PI * 0.2);\n    float d2 = d2_sdf_box(uv2,vec2(thin,0.79));\n    \n    return min(d1,d2); \n}\n\nfloat logo_sdf_I(vec2 p, float thin){\n    return d2_sdf_box(p,vec2(thin,0.7)); \n}\n\nfloat logo_sdf_O(vec2 p, float thin){\n    vec2 uv1 = p;\n    float d1 = d2_sdf_sphere(uv1,0.7);\n    float d2 = d2_sdf_sphere(uv1,0.7 - thin * 2.0);\n    return sdf_substract(d2,d1); \n}\n\nfloat stripe_sdf_I(vec2 p,float thin){\n    vec2 uv3 = p;\n    float d3 = d2_sdf_box(uv3,vec2(thin,0.7));\n    vec2 uv4 = p + 0.27;\n    uv4 = rotate(uv4,PI * 0.75);\n    uv4.y = mod(uv4.y,0.20) - 0.1;\n    float d4 = d2_sdf_box(uv4,vec2(100.0,0.045));\n\n    d3 = sdf_substract(d4,d3);\n    return d3;\n}\n\nvec3 sessions_logo(vec2 uv){\n    vec3 col = vec3(0.0);\n    float thin = 0.1;\n\n    float d1 = logo_sdf_S(uv - vec2(0.35,0.0),thin);\n    float d2 = stripe_sdf_I(uv + vec2(0.35,0.0),thin);\n\n    float d = min(d1,d2);\n\n    col = (d < 0.0) ? vec3(1.0,1.0,1.0) : vec3(0.0);\n    return col;\n}\n\nvec3 sessions_title(vec2 uv){\n    vec3 col = vec3(0.0);\n    float thin = 0.1;\n    uv *= 10.0;\n    uv.x += 3.0;\n\n    float d1 = logo_sdf_S(uv + vec2(1.0,0.0),thin);\n    float d2 = logo_sdf_E(uv,thin);\n    float d3 = logo_sdf_S(uv + vec2(-1.0,0.0),thin);\n    float d4 = logo_sdf_S(uv + vec2(-2.0,0.0),thin);\n    float d5 = logo_sdf_I(uv + vec2(-2.85,0.0),thin);\n    float d6 = logo_sdf_O(uv + vec2(-4.0,0.0),thin);\n    float d7 = logo_sdf_N(uv + vec2(-5.5,0.0),thin);\n    float d8 = logo_sdf_S(uv + vec2(-6.7,0.0),thin);\n\n    float d = d1;\n    d = min(d,d2);\n    d = min(d,d3);\n    d = min(d,d4);\n    d = min(d,d5);\n    d = min(d,d6);\n    d = min(d,d7); \n    d = min(d,d8);\n    \n    col = (d < 0.01) ? vec3(1.0) : vec3(0.0);\n    return col;\n}\n\n//-------------------------------\n//Materialing\n//-------------------------------\n\n//blinn-phong inportance sampling\nvec3 bp_IS(vec2 rnd,float n){\n    float theta = acos(pow(1.0 - rnd.x,1.0 / (1.0 + n)));\n    float phi = 2.0 * PI * rnd.y;\n\n    return vec3(sin(theta) * cos(phi), cos(theta),sin(theta) * sin(phi));\n}\n\nvec3 screen_color(material_data mat){\n    bool s = false;\n    vec2 index = floor(mat.pos.xy * 0.5);\n    vec2 uv = mat.uv;\n    uv *= 1.0 + length(mat.uv)*length(mat.uv) * 0.05;\n    vec3 screen_col = vec3(0.0);\n    float offset = hash21(index);\n\n    //White_Noise\n    vec3 noise = white_noise(uv,offset);\n\n    switch(ID){\n        case 0:\n            screen_col = color_bar(uv);\n\n            break;\n        case 1:\n            vec3 logo = sessions_logo(uv);\n            vec3 hacking = screen_hacking(uv,offset);\n\n            float noise_mask = step(-sin((TIME - 0.0)* TIME),-0.2);\n            bool logo_mask = TIME > 10.0;\n            vec3 logo_col = mix(vec3(0.0),logo,TIME - 13.0);\n\n            bool logo_mask2 = TIME < 15.0;\n\n            screen_col = mix(hacking,noise,noise_mask);\n            screen_col = (logo_mask) ? logo_col : screen_col;\n            \n            break;\n        case 2:\n            screen_col = noise;\n            screen_col = (index.x == 0.0 && index.y == 0.0 && TIME < 10.0) ? screen_sphere(uv,offset) : screen_col;\n\n            screen_col = (TIME < 2.0) ? noise : screen_col;\n            break;\n        \n        case 3: \n            vec3 hacking_3 = screen_hacking(uv,offset);\n            vec3 colorbar = color_bar(uv);\n            float mask_31 = TIME * 10.0 - 30.0;\n            bool mask_32 = is_inside(TIME,3.0,9.0);\n            bool mask_sub = bool(int(index.x + 1.0)%2 == 0 && index.y == 0.0);\n\n            screen_col = (index.x < mask_31) ?  hacking_3 : noise;\n            screen_col = (mask_32 && mask_sub) ? colorbar : screen_col;\n            \n            break;\n        \n        case 4:\n            float local_time4 = mod(TIME,4.0);\n            vec3 kaleido_scope = screen_kaleidoscope((mat.pos.xy - vec2(1.0)) * 0.5 );\n\n            screen_col = vec3(0.0);\n            screen_col = (local_time4 > 2.0) ? kaleido_scope : screen_col;\n\n            break;\n        case 5:\n            screen_col = vec3(0.0);\n            screen_col = mix(screen_col,start_stop((mat.pos.xy - vec2(1.0,2.0) )* 0.2,1),step(4.0,TIME));\n            screen_col = mix(screen_col,start_stop((mat.pos.xy - vec2(1.0,2.0)) * 0.2,2),step(6.0,TIME));\n            screen_col = mix(screen_col,noise,step(13.0,TIME));\n            screen_col = mix(screen_col,sessions_title(mainCameraUV * 0.33),step(15.0,TIME));\n            break;\n\n        default:\n            screen_col = vec3(1.0);\n            break;\n        \n    };\n\n    return screen_col;\n}\n\n//Anbient Occulusion \nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    float maxDist = 1.0;\n    float falloff = 1.0;\n\n    const int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal for self occlusion problems!\n\n        material_data dammy;\n        ao += (l - max(map( p + rd,dammy),0.)) / maxDist * falloff;\n\n        if( ao < - 1.0) break;\n    }\n\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec3 reflect_light(vec3 ro,vec3 rd,vec3 c_pos) {\n    vec3 pos = ro;\n\n    float t = 0.0;\n\n    vec3 col = vec3(0.0);\n    material_data mat;\n    float d;\n    for(int i = 0; i < 100; i++) {\n        d = map(pos, mat);\n        pos += rd * d;\n        t += d;\n        if(i < -1) break;\n    }\n\n    if(d < 0.001) {\n        mat.pos = pos;\n        mat.c_pos = ro;\n        mat.d = t;\n        mat.screen_uv = (pos - c_pos).xy;\n        if(mat.id == screen_ID){\n            col = screen_color(mat);\n        }\n        else if(mat.id == light_ID){\n            col = mat.light_col;\n        }\n    }\n\n    return col * 10.0;\n}\n\nfloat shlick_fresnel(float F0,float c){\n    return F0 + (1.0 - F0) * pow(1.0 - c,5.0);\n}\n\n\nvec3 tvmat(material_data mat) {\n    vec3 col = vec3(0);\n    bool s = false;\n    vec2 index = floor(mat.pos.xy * 0.5);\n    vec2 uv = mat.uv;\n    uv *= 1.0 + length(mat.uv)*length(mat.uv) * 0.05;\n\n    float offset = hash21(index);\n\n    vec3 screen_col = screen_color(mat);\n\n    //--------\n    //Effect\n    //--------\n    float viggnet_power = 0.6;\n    float viggnet = 1.0 - length(uv) * viggnet_power;\n    screen_col *= viggnet;\n\n    float y_bar =float(mod(uv.y + worldTime + offset * 5.0,5.0) < 0.2);\n    screen_col *= 1.0 - y_bar * 0.2;\n\n    //--------\n    //Lighting\n    //--------\n    vec3 col1 = mat.normal * 0.5 + 0.5;\n    vec3 normal = mat.normal;\n    vec3 t,b;\n    tangentSpaceBasis(normal, t, b);\n\n    //AO\n    float ao = ambientOcclusion(mat.pos, normal);\n\n    //reflection \n    float roughness = 10000.0;\n    vec3 ref_col = vec3(0.0);\n    \n    vec3 hd =  bp_IS(hash32(mat.pos + worldTime), roughness);\n    vec3 ref_h = localToWorld(hd, t, normal,b);\n    \n    vec3 ref_rd = reflect(mat.c_dir, ref_h);\n    vec3 ref_ro = mat.pos + ref_rd * 0.01;\n\n    vec3 r_col = reflect_light(ref_ro, ref_rd,mat.c_pos);\n    \n    float nfactor = 8.0 * PI /(roughness + 8.0); \n    float fresnel_factor = shlick_fresnel(0.04,dot(ref_rd,ref_h));\n    ref_col +=  nfactor * r_col * 4.0 * dot(ref_h,ref_rd) * 2.0 * fresnel_factor * 10.0; \n\n    bool mask_circule = is_inside(worldTime,44.0,77.0);\n    vec3 circuit_col = circuit(mat.pos * 0.5,vec3(0.3,0.3,1.0)) * beat(TIME,2.0) * fresnel_factor;\n\n    col = ref_col ;\n    col = (mat.id == screen_ID) ? screen_col : col;\n    col = (mat.id == light_ID) ? mat.light_col * fresnel_factor + col + circuit_col : col;\n\n    return col * ao; \n}\n\n//-------------------------------\n//Raymarching\n//-------------------------------\n\nvec3 Raymarching(vec3 ro, vec3 rd,vec2 uv) {\n    vec3 pos = ro;\n\n    float t = 0.0;\n\n    vec3 col = vec3(0.0);\n    material_data mat;\n    mat.light_dist = 1000.0;\n    vec3 bloom_col = vec3(0.0);\n    float light_d = 1000.0;\n    float d;\n    for(int i = 0; i < 100; i++) {\n        d = map(pos, mat);\n        \n        bloom_col += mat.light_col * exp(-mat.light_dist * 30.0);\n\n        if(d < 0.001) break;\n\n        pos += rd * d;\n        t += d;\n    }\n\n    if(d < 0.001){\n        mat.normal = get_normal(pos);\n        mat.pos = pos;\n        mat.c_pos = ro;\n        mat.c_dir = rd;\n        mat.d = t;\n        mat.screen_uv = (mat.pos - mat.c_pos).xy;\n        col = tvmat(mat) ; \n    }\n\n    return col+ bloom_col;\n}\n\n//--------------------------------\n//Color\n//--------------------------------\n\nvec3 gamma_correction(vec3 col){\n    return pow(col,vec3(1.0/2.2));\n}\n\n//https://www.shadertoy.com/view/lslGzl\nvec3 tone_mapping(vec3 col){\n\tcol = max(vec3(0.), col - vec3(0.004));\n\tcol = (col * (6.2 * col + .5)) / (col * (6.2 * col + 1.7) + 0.06);\n\treturn col;\n}\n\nconst vec4 LIFT = vec4( 0.02, -0.01, 0.09, 0.0 );\nconst vec4 GAMMA = vec4( -0.05, 0.02, -0.08, 0.0 );\nconst vec4 GAIN = vec4( 1.06, 0.96, 1.10, 1.0 );\n\nconst vec3 LUMA = vec3( 0.2126, 0.7152, 0.0722 );\n\nvec3 liftGammaGain( vec3 rgb, vec4 lift, vec4 gamma, vec4 gain ) {\n  vec4 liftt = 1.0 - pow( 1.0 - lift, log2( gain + 1.0 ) );\n\n  vec4 gammat = gamma.rgba - vec4( 0.0, 0.0, 0.0, dot( LUMA, gamma.rgb ) );\n  vec4 gammatTemp = 1.0 + 4.0 * abs( gammat );\n  gammat = mix( gammatTemp, 1.0 / gammatTemp, step( 0.0, gammat ) );\n\n  vec3 col = rgb;\n  float luma = dot( LUMA, col );\n\n  col = pow( col, gammat.rgb );\n  col *= pow( gain.rgb, gammat.rgb );\n  col = max( mix( 2.0 * liftt.rgb, vec3( 1.0 ), col ), 0.0 );\n\n  luma = pow( luma, gammat.a );\n  luma *= pow( gain.a, gammat.a );\n  luma = max( mix( 2.0 * liftt.a, 1.0, luma ), 0.0 );\n\n  col += luma - dot( LUMA, col );\n\n  return col;\n}\n\n//------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ \n\n    worldTime = mod(iTime,139.0); \n    S(10.0); //TV\n    S(20.0); //SceneChange\n    S(11.0); //s\n    S(40.0); //\n    \n    S(32.0); //frash\n    S(25.0); //End\n\n    vec2 uv = ((fragCoord.xy + 0.5 * hash21(fragCoord.xy + worldTime))* 2.0 - iResolution.xy) /  iResolution.y;\n    vec2 suv = fragCoord.xy / iResolution.y;\n    vec2 texuv =fragCoord.xy / iResolution.xy;\n    \n    float viggnet = length(uv);\n\n    float distort_power = 0.05;\n    float distort_r = length(uv);\n    uv *= 1.0 + distort_r * distort_r * distort_power;\n\n    vec2 dx = vec2(2.0 / iResolution.x, 0.0);\n    vec2 dy = vec2(0.0, 2.0 / iResolution.x);\n\n    float floor_x = mod(gl_FragCoord.x * 10.0 / 3.0, 1.0);\n\n    bvec3 isRGB = bvec3(floor_x <= 0.33, floor_x > 0.33 && floor_x < 0.66, floor_x > 0.66);\n\n    vec3 ro = vec3(1., 1.5, -10.0);\n    vec3 rd = normalize(vec3(uv, 2.0));\n    \n    float rtime = PI * 0.0;\n\n    rd.xz = rotate(rd.xz, rtime);\n\n    float debug_t = 0.0;\n    \n    //-------------------------------\n    //MainObject and Camera Move\n    {\n        if(ID == 0){\n            mainObjectP = vec3(0.0,0.0,0.0);\n        }\n        else if(ID == 1){\n            mainObjectP = vec3(0.0,0.0,0.0);\n        }\n        else if(ID == 2){\n            ro = vec3(1.0,1.0,-10.0);\n            mainObjectP = vec3(1.0,1.0,10.0);\n            float st[6] = float[](\n                3.0,5.0,7.0,9.0,11.0,12.0\n            );\n\n            int shot_ID = 0;\n            counter(TIME,st[0],shot_ID);\n            counter(TIME,st[1],shot_ID);\n            counter(TIME,st[2],shot_ID);\n            counter(TIME,st[3],shot_ID);\n            counter(TIME,st[4],shot_ID);\n\n            vec3 offset = vec3(0.0);\n\n\n            if(shot_ID == 1){\n                float offset_bounce = easeOutBounce(time_normalize(TIME,st[0],st[1])) * 10.0;\n\n                offset = vec3(0.0,0.0,-offset_bounce);\n                mainObjectP += offset;\n            }\n            else if(shot_ID == 2){\n                float offset_charge = (1.0 - smoothstep(0.0,1.0,time_normalize(TIME,st[1],st[2]))) * 10.0;\n                offset = vec3(0.0,0.0,-offset_charge);\n                mainObjectP += offset;\n            }\n            else if(shot_ID == 3){\n                float n_time3 = time_normalize(TIME,st[2],st[3]);\n                offset = (hash13(TIME) * 2.0 - 1.0) * 0.05;\n\n                n_time3 = smoothstep(0.0,1.0,n_time3);\n                ro.z += n_time3 * 0.4;\n                rd = normalize(vec3(uv,2.0 + n_time3 * 0.5));\n\n                mainObjectP += offset;\n            }\n            else if(shot_ID == 4){\n                float n_time4 = time_normalize(TIME,st[3],st[4]);\n\n                vec3 pos_end = vec3(1.0,1.0,-20.0);\n                vec3 camera_end = vec3(1.0,1.0,-30.0);\n                float offset_shot = mix(0.0,-20.0,easeOutBack(n_time4));\n\n                mainObjectP = mix(mainObjectP,pos_end,easeOutBack(n_time4));\n                ro = mix(ro,camera_end,easeOutBack(n_time4));\n            }\n        }\n        else if(ID == 3){\n            mainObjectP = vec3(1.0,1.0,-20.0);\n            vec3 sub_basis3 = vec3(1.0,1.0,20.0);\n            ro = vec3(1.0,1.0,-30);\n            float st3[5] = float[](\n                3.0,10.0,40.0,50.0,80.0\n            );\n            int shot_ID3 = 0;\n            counter(TIME,st3[0],shot_ID3);\n            counter(TIME,st3[1],shot_ID3);\n\n            \n            float time_offset = worldTime - 37.0;\n\n            float local_time_31 = time_normalize(TIME - suv.y,16.0,18.0);\n            objID = 0;\n            objID = (local_time_31 > 0.33) ? 1 : objID;\n            objID = (local_time_31 > 0.66) ? 2 : objID;\n            debug_t = local_time_31;\n\n            if(shot_ID3 == 0){\n                mainObjectP.x += time_offset;\n                ro = mainObjectP + vec3(0.0,0.0,-10.0);\n            }\n            else if(shot_ID3 == 1){\n                mainObjectP.x += time_offset;\n                ro = mainObjectP + vec3(0.0,0.0,-10.0);\n                float n_time32 = time_normalize(TIME,st3[0],10.0);\n                subObjectP = vec3(1.0,1.0,-smoothstep(0.0,1.0,n_time32) * 15.0);\n            }\n            else if(shot_ID3 == 2){\n                mainObjectP.x += time_offset;\n                ro = mainObjectP + vec3(0.0,0.0,-10.0);\n                subObjectP = vec3(1.0,1.0,-15.0);\n            }\n        }\n        else if(ID == 4){\n            mainObjectP = vec3(1.0,1.0,-10.0);\n            ro = vec3(1.0,1.0,-30.0);\n        }\n        else if(ID == 5){\n            mainObjectP = vec3(1.0,1.0,-10.0);\n            ro = vec3(1.0,1.0,-30.0);\n            rd = normalize(vec3(uv,2.0));\n        }\n    }\n\n\n    mainCameraP = ro;\n    mainCameraD = rd;\n    mainCameraUV = uv;\n\n    vec3 col = Raymarching(ro, rd, uv);\n    col = tone_mapping(col); \n    col = gamma_correction(col);\n    col *= hash21(uv + TIME) * 0.2 + 0.8;\n    \n    float viggnet_power = 0.2;\n    col *= 1.0 - viggnet * viggnet_power;\n\n    col = liftGammaGain(col,LIFT,GAMMA,GAIN);\n    texuv = texuv * 2.0 - 1.0;\n    vec2 uvR = texuv * (1.0 + length(texuv) * 0.01);\n    vec2 uvG = texuv * (1.0 + length(uvR) * 0.005);\n    vec2 uvB = texuv * (1.0 + length(uvR) * 0.000);\n    \n    float R = texture(iChannel0,uvR * 0.5 + 0.5).x;\n    float G = texture(iChannel0,uvG * 0.5 + 0.5).y;\n    float B = texture(iChannel0,uvB * 0.5 + 0.5).z;\n    \n    col = mix(vec3(R,G,B),col,0.7);\n\n\n    //FadeIn Out\n    col = mix(vec3(0.0),col,time_normalize(worldTime,0.0,4.0));\n    col = mix(col,sessions_title(mainCameraUV * 0.33),time_normalize(worldTime,134.0,137.0));\n   \n    fragColor = vec4(col.xyz,1);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}