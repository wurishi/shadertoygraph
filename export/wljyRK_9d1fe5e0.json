{"ver":"0.1","info":{"id":"wljyRK","date":"1594855515","viewed":294,"name":"feathers with synthwave colors","username":"PinetreeDev","description":"some feathers yay\nBasically the same feathers as the  youtuber The Art of Code did, but with a little tweaks here and there on color blending and feathers.\nAlso some fake parallax with the mouse interaction because why not.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["parallax","relaxing","synthwave","feathers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S smoothstep\n#define T (iTime * .5)\n\nmat2 Rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Feather(vec2 uv)\n{\n    // Vec2 offsets the center, x, y coordinates on the screen\n   \tfloat d = length(uv - vec2(0, clamp(uv.y, -.3, .3)));\n    \n    // The usage of smoothstep here is smoothstep(blur, 0, compareValue - thickness)\n    // This makes it way less cumbersome to use and tidy.\n    // I have a value r for radius of the line, \n    // this gets smaller along the lenght of the fether\n    // Visualize 'radius' by returning it;\n    float r = mix(.1, .01, S(-.3, .3, uv.y));\n    float m = S(.01, .0, d - r);\n    \n    \n    // Returns the value of the sign of uv.x, 0 is the center of the screen,\n    // -1 when negative, +1 when positive\n    float side = sign(uv.x);\n    \n    // X goes from 0 to 1, but our feather is from 0 to r, so we normalize it\n    // The .9 multiplication just makes it not go entirely to 1,\n    // so we don't get jagged edges\n    float x = .9 * abs(uv.x) / r;\n    float wave = (1.0 -x) * sqrt(x) + (1.0 - sqrt(1.0 - x)) * x;\n    float y = (uv.y - wave * .2) * 80.0 + side;\n    \n    float id = floor(y + 20.0);\n    float n = fract(sin(id * 650.2) * 795.); // semi-random number between 0 - 1\n    float shade = mix(.5, 1., n);\n    float strandLength = mix(.6, 1., fract(n * 2.));\n    \n    // fract creates repetition.\n    float strand = S(.6, .0, abs(fract(y) - 0.5) - .3);\n    strand *= S(.3, .0, x - strandLength);\n    \n    d = length(uv - vec2(0, clamp(uv.y, -.45, .2)));\n\tfloat stem = S(.01, 0.0, d + uv.y * .02);\n    \n    // Taking the max of 2 values is better as it will not have hidden information\n    return max(strand*m*shade, stem);\n}\n\nvec3 Transform(vec3 p, float angle)\n{\n    p.xz *= Rot(angle);\n    p.xy *= Rot(angle *.7);\n    return p;\n}\n\nvec4 RayTracedFeather(vec3 rayOrigin, vec3 rayDirection, vec3 position, float angle)\n{\n    \n    vec4 col = vec4(0);\n    float t = dot(position - rayOrigin, rayDirection);\n    vec3 p = rayOrigin + rayDirection * t;\n    \n    float y = length(position - p);\n    \n    // Ray traced sphere\n    if (y < 1.0)\n    {\n    \tfloat x = sqrt(1.0 - y);\n        vec3 pF = rayOrigin + rayDirection * (t - x) - position; // Front intersection\n        \n        pF = Transform(pF, angle);\n        // Cylindrical projection using polar coordinates.\n        vec2 uvF = vec2(atan(pF.x, pF.z), pF.y); // -pi to pi, -1 to 1;\n        uvF *= vec2(.25, .5);\n        float f = Feather(uvF);\n        vec4 front = vec4(vec3(f), S(0., .1, f));\n        \n        vec3 pB = rayOrigin + rayDirection * (t + x) - position; // Back intersection\n        pB = Transform(pB, angle);\n        vec2 uvB = vec2(atan(pB.x, pB.z), pB.y); // -pi to pi, -1 to 1;\n        uvB *= vec2(.25, .5);\n        float b = Feather(uvB);\n        vec4 back = vec4(vec3(b), S(.0, .1, b));\n\n        col = mix(back, front, front.a);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center the uvs and take in account screen x size\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = iMouse.xy / iResolution.xy;\n    vec3 bg = vec3(1, .4, .1) * (uv.y + .5);\n    bg += vec3(1, .16, .45) * (-uv.y + .5);\n    vec4 col = vec4(bg, 0);\n    //col += Feather(uv);\n    \n    // ray tracer\n    vec3 rayOrigin = vec3(0, 0, -3);\n    vec3 rayDir = normalize(vec3(uv, 1));\n    \n    for(float i= 0.0; i < 1.0; i+= 1.0/51.0)\n    {\n        // M.component *i*i creates the parallax effect\n        // The closest they are the stronger the effect,\n        // this happens because of the Z axis being from back to front rendering.\n        float x = mix(-8. , 8., fract(i + T*.1)) + M.x * i * i;\n        float y = mix(-2., 2.,fract(sin(i * 324.5) * 7864.4)) + (M.y * i*i);\n        float z = mix(5., 0., i);\n        float a = T + i *530.35;\n        vec4 feather = RayTracedFeather(rayOrigin, rayDir, vec3(x, y, z), a);\n    \t\n        feather.rg *= i;\n        feather.b += i;\n        feather.rgb = mix(bg.rgb, feather.rgb, mix(.3, 1., i));\n        feather.rgb = sqrt(feather.rgb);\n        col = mix(col, feather, feather.a);\n    }\n    \n    col = pow(col, vec4(.4545)); // gamma correction\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}