{"ver":"0.1","info":{"id":"NltcR7","date":"1719735140","viewed":55,"name":"Ray casting","username":"Cirno","description":"In work","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n\n#define Orthogonal\n\nmat3x3 rotateCamera(float x, float y, float z)\n{\n    float cosz = cos(z);\n    float sinz = sin(z);\n    float cosy = cos(y);\n    float siny = sin(y);\n    float cosx = cos(x);\n    float sinx = sin(x);\n    \n    float cosz_cosy = cosz*cosy;\n    float sinz_cosy = sinz*cosy;\n    float cosz_siny = cosz*siny;\n    float sinz_siny = sinz*siny;\n    return mat3x3(\n        cosz_cosy,sinz_cosy,-siny,\n        cosz_siny*sinx-sinz_cosy,cosz*cosx+sinz_siny*sinx,cosy*sinx,\n        cosz_siny*cosx+sinz_siny,sinz_siny*cosx-sinx*cosz,cosy*cosx\n        );\n}\n\nfloat sqr(float x){return x*x;}\nfloat sqrDist(vec2 x)\n{\n    return x.x*x.x+x.y*x.y;\n}\n\nfloat sphere(vec3 rayPos, float r, vec3 pos)\n{\n    return length(rayPos-pos)-r;\n}\n\nfloat cube(vec3 p,vec3 size) {\n    vec3 q = abs(p) - size;\n    return length(max(q, 0.0));\n}\n\nfloat special(vec3 rayPos,float r)\n{\n    float cx = clamp(rayPos.x,-r,r);\n    float cy = clamp(rayPos.y,-r,r);\n    float z = rayPos.z;\n    //float modelZ = sqrt(min(1.-cx*cx,1.-cy*cy));\n    return \n        max(\n            cube(rayPos,vec3(r)),\n            max(length(vec2(cx,z))-r,length(vec2(cy,z))-r)\n            );\n}\n\nfloat scene(vec3 p)\n{\n    return special(p,1.0f);\n}\n\n\nfloat rayCast(vec3 rayOrg, vec3 rayDir,float minT,float maxT)\n{\n    const int stepCount = 70;\n    float t = minT;\n    for(int i=0;i<stepCount && t<maxT;i++)\n    {\n        float d = scene(rayOrg+rayDir*t);\n        if(abs(d)<t*0.00001)\n        {\n            return t;\n        }\n        t+=d;\n    }\n    return maxT+1e-3;\n}\n\nmat3 rotate(vec3 angles) {\n\n    if (angles == vec3(0)) {\n        return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n    }\n\n    float yawCos = cos(angles.y);\n    float yawSin = sin(angles.y);\n    mat3 ry =  mat3(\n        vec3(yawCos, 0, yawSin),\n        vec3(0, 1, 0),\n        vec3(-yawSin, 0, yawCos)\n    );\n\n    float pitchCos = cos(angles.z);\n    float pitchSin = sin(angles.z);\n    mat3 rz = mat3(\n        vec3(pitchCos, -pitchSin, 0),\n        vec3(pitchSin, pitchCos, 0),\n        vec3(0, 0, 1)\n    );\n\n    float rollCos = cos(angles.x);\n    float rollSin = sin(angles.x);\n    mat3 rx = mat3(\n        vec3(1, 0, 0),\n        vec3(0, rollCos, -rollSin),\n        vec3(0, rollSin, rollCos)\n    );\n\n    // Ry * Rz * Rx\n    return ry * rz * rx;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    float eps = 0.01f;\n    return normalize(vec3(\n        scene(pos+vec3(eps,0.,0.))-scene(pos+vec3(-eps,0.,0.)),\n        scene(pos+vec3(0.,eps,0.))-scene(pos+vec3(0.,-eps,0.)),\n        scene(pos+vec3(0.,0.,eps))-scene(pos+vec3(0.,0.,-eps))));\n}\n\nfloat D_GGX(float NdotH,vec3 N, vec3 H, float roughnessSq) {\n    float NdotH2 = NdotH * NdotH;\n    float denom = (NdotH2 * (roughnessSq - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return roughnessSq / denom;\n}\n\nfloat G_Smith(float NdotV, float NdotL, float roughness) {\n    float k = (roughness +1.0f)*0.5f;\n    k=k*k*0.5f;\n\n    float G_V = NdotV / (NdotV * (1.0 - k) + k);\n    float G_L = NdotL / (NdotL * (1.0 - k) + k);\n\n    return G_V * G_L;\n}\n\nconst float maxDist=10.;\n \n// materials\nconst float metallic =0.7f;\nconst float roughness = 0.06f; \nconst vec3 albedo = vec3(0.188,0.059,0.843);\n\nvec3 F_Schlick(float HdotV, vec3 F0)\n{\n    return F0 + (vec3(1.) - F0) * pow(1. - HdotV , 5.0);\n}\n\nvec3 light(vec3 lightPos, vec3 lightColor, vec3 hitPoint, vec3 normal, vec3 view, float t)\n{\n    const float roughnessSqr = roughness*roughness;\n    //light & view\n    vec3 lightDir = normalize(lightPos - hitPoint);\n    vec3 viewDir = normalize(view - hitPoint); \n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 h=normalize(viewDir + lightDir);\n    \n    //diffuse light\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    float NdotV = max(dot(normal, viewDir), 0.0);\n    float HdotV = max(dot(h, viewDir), 0.0);\n    \n    //specular\n    //float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    float specAngle = max(dot(h, normal), 0.0);\n    float spec = D_GGX(diffuse, normal, h, roughnessSqr) * G_Smith(NdotV, diffuse, roughness ) / (4.0 * max(NdotV*diffuse,0.0001));\n    float specular = specAngle * spec;\n    \n    return  (specular * (1.0 - metallic) + diffuse * metallic) * lightColor / PI + F_Schlick(HdotV, mix(albedo, vec3(metallic),0.04));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 m = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n#ifdef Orthogonal\n    vec3 ro = vec3(uv*2., -4);         // ray origin\n    ro *= rotate(-vec3(m.yx, 0.));\n    vec3 rd = normalize(vec3(0.,0., 1)); // ray direction\n    rd *= rotate(vec3(-m.yx, 0.));\n#else\n    vec3 ro = vec3(0, 0, -3);         // ray origin\n    ro *= rotate(-vec3(m.yx, 0.));\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    rd *= rotate(vec3(-m.yx, 0.));\n#endif\n    vec3 col = vec3(0);               // final pixel color\n    float t = rayCast(ro,rd,0.,maxDist);\n    vec3 hitPoint = t*rd+ro;\n    float factor = step(t,maxDist);\n    vec3 normal = factor*calcNormal(hitPoint);//*sceneNormal(hitPoint);//\n    \n    col += albedo / PI*step(t,maxDist);\n    col += light(vec3(4.0, 2.0, 5.0),vec3(1.0, 1.0, 0.8),hitPoint,normal,ro,t);\n    col += light(vec3(2.0, -2.0, -5.0),vec3(0.4, 0.4, 0.5),hitPoint,normal,ro,t);\n    col *= factor+(1.0-factor)*vec3(0.1,0.1,0.15);\n    // Coloring\n    //col = vec3(t * .2);           // color based on distance\n    //col=normal*0.5+0.5;\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 col = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    if (iMouse.z > 0.) {\n        vec2 diff = iMouse.xy-abs(iMouse.zw);\n        diff = (diff.xy) / iResolution.y;\n        vec2 manipulate = clamp(diff, -0.5, 0.5)/10.;\n        col += vec2(-manipulate.x,-manipulate.y);\n    }\n    fragColor = vec4(col,0.,1.0);\n}\n//copy from https://www.shadertoy.com/view/lc3Xz4","name":"Buffer A","description":"","type":"buffer"}]}