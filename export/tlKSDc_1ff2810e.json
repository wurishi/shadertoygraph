{"ver":"0.1","info":{"id":"tlKSDc","date":"1583885544","viewed":114,"name":"Basic raymarch + phong lights","username":"ilyaev","description":"Basic raymarch + phong lights","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["phong","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n#define MAX_STEPS 256\n#define MIN_DIST 0.001\n#define FAR_DIST 10.\n#define PI 3.1416\n#define PI2 PI*2.\n\nstruct sCamera {\n    vec3 ro;\n    vec3 rd;\n    vec3 lookat;\n    float zoom;\n};\n\n\nsCamera setupCamera(vec2 uv, vec3 ro, vec3 lookat, float zoom) {\n    sCamera camera;\n    camera.ro = ro;\n    camera.lookat = lookat;\n    camera.zoom = zoom;\n\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x*r + uv.y * u;\n    vec3 rd = normalize(i - ro);\n\n    camera.rd = rd;\n\n    return camera;\n}\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(vec3 p, float x, float y) {\n    return p.y - y;\n}\n\nvec3 getAlbedoByMaterial(float material, vec3 p) {\n    vec3 albedo = vec3(1.);\n    if (material == 1.) {\n        albedo = vec3(0., 1., 0);\n    } else if (material == 0.) {\n        float size = 8.;\n        albedo *= step(0.0001, sin(p.x*size)+sin(p.z*size));\n    }\n    return albedo;\n}\n\nvec3 getDist(vec3 p) {\n    float material = 0.;\n    float dS = sdSphere(p - vec3(0., .5 + sin(t*2.)*.5, 0.), .5);\n    float dP = sdPlane(p, 0., -.5);\n    float d = dS;\n    d = min(d, dP);\n    if (d == dS) {\n        material = 1.;\n    }\n    return vec3(d, material, 0.);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = getDist(p).x;\n    vec3 n = d - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec4 trace(vec3 ro, vec3 rd) {\n\n    float dt, d;\n    vec3 p;\n\n    vec3 dist;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * dt;\n        dist = getDist(p);\n        dt += dist.x * .6;\n        if (abs(dist.x) < MIN_DIST || dist.x > FAR_DIST) {\n            break;\n        }\n    }\n\n    return vec4(dist.x, dt, dist.xy);\n}\n\nvec3 getLightColor(vec3 p, vec3 n, vec3 lightPos) {\n    vec3 l = normalize(lightPos - p);\n    float dif = clamp(0., 1., dot(n,l));\n\n    float distanceToLight = trace(p + n * (MIN_DIST*2.), l).x;\n    if (distanceToLight < length(lightPos - p)) {\n        dif *= .5;\n    }\n\n    return vec3(dif);\n}\n\nvec3 getSpecularColor(vec3 p, vec3 n, vec3 lightPos, vec3 viewPos) {\n    vec3 spec = vec3(0.);\n    float specularStrength = 0.5;\n\n    vec3 viewDir = normalize(p - viewPos);\n    vec3 reflectDir = reflect(normalize(lightPos - p), n);\n    float specValue = pow(max(dot(viewDir, reflectDir), 0.), 32.);\n\n\n    return spec + specularStrength * specValue;\n}\n\nvec3 getNormalByMaterial(float material, vec3 p) {\n    vec3 normal = vec3(0., 1., 0.);\n    if (material == 1.) {\n        normal = getNormal(p);\n    }\n    return normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n\n    vec2 uv = fragCoords.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0.);\n\n    sCamera camera = setupCamera(\n        uv, \n        vec3(2.*sin(PI2 * mouse.x + t),cos((PI/2.)*mouse.y),-2.*cos(PI2 * mouse.x + t/3.)), \n        vec3(0.), \n     \t.5\n   \t);\n\n    vec4 tr = trace(camera.ro, camera.rd);\n    \n    float materialID = tr.a;\n    float distanceTo = tr.y;\n\n    vec3 lightPos = vec3(1., 2., -1.5);\n\n    if (tr.x < MIN_DIST) {\n        vec3 p = camera.ro + camera.rd * distanceTo;\n        vec3 normal = getNormalByMaterial(materialID, p);\n        vec3 albedo = getAlbedoByMaterial(materialID, p);\n        vec3 diffuse = getLightColor(p, normal, lightPos);\n        vec3 specular = getSpecularColor(p, normal, lightPos, camera.ro);\n        float ambient = .1;\n        float fade = 1.;// - abs(p.z)/5.;\n        col = clamp((ambient + diffuse + specular) * albedo, 0., 1.) * fade;\n    }\n\n    fragColor = vec4(col, 1.);\n    // fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2)); \n\n}","name":"Image","description":"","type":"image"}]}