{"ver":"0.1","info":{"id":"WsS3Dc","date":"1550154503","viewed":3230,"name":"stained glass","username":"flockaroo","description":"church of britney... ;-)\nmove mouse X to change detail\nagain 13 passes spread over 13 frames, therefore video-fps lower than shader-fps\nrealtime version: [url]https://www.shaderoo.org/?shader=1Sbr70[/url]\n","likes":69,"published":3,"flags":32,"usePreview":0,"tags":["voronoi","glass","kdtree","stained","subdivide"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// create glass and lead finish\n\n#define iPassIndex (iFrame%NumPasses)\n\n#define Res (iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n#define Res3 vec2(textureSize(iChannel3,0))\n\n#define ColorTex iChannel2\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(iChannel1,coord+.003*iTime);\n    c+=texture(iChannel1,coord/2.+.003*iTime)*2.;\n    c+=texture(iChannel1,coord/4.+.003*iTime)*4.;\n    c+=texture(iChannel1,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\nfloat getVal(vec2 pos,float lod)\n{\n    //return textureLod(iChannel0,pos/Res,lod).w;\n    vec4 c=textureLod(iChannel0,pos/Res,lod);\n    float d=c.z;\n    float sc=c.w;\n    return clamp(1.-pow(7.5*d*d/sc,1.2),0.,1.);\n    //return (1.-70.*d*d*d*d/sc/sc);\n}\n\nvec2 getGrad(vec2 pos,float eps)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy,0.)-getVal(pos-d.xy,0.),\n        getVal(pos+d.yx,0.)-getVal(pos-d.yx,0.)\n        )/eps/2.;\n}\n\n#define PI2 6.28318530718\n    \n#ifndef RandTex\n#define RandTex iChannel1\n#endif\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    return uv+.6*sin(uv*res*PI2)/PI2/res;\n}\n\nvec4 getRandSm(vec2 pos)\n{\n    vec2 tres=vec2(textureSize(RandTex,0));\n    //vec2 fr=fract(pos-.5);\n    //vec2 uv=(pos-.7*sin(fr*PI2)/PI2)/tres.xy;\n    vec2 uv=pos/tres.xy;\n    uv=uvSmooth(uv,tres);\n    return textureLod(RandTex,uv,0.);\n}\n\nfloat getValH(vec2 pos, float lod)\n{\n    return abs(getRandSm(pos*.1).x-getRandSm(pos*.1+vec2(17.5,13.5)).x);\n}\n\nvec2 getGradH(vec2 pos,float eps)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getValH(pos+d.xy,0.)-getValH(pos-d.xy,0.),\n        getValH(pos+d.yx,0.)-getValH(pos-d.yx,0.)\n        )/eps/2.;\n}\n\nvec3 getGlassNormal(vec2 pos)\n{\n    vec3 n = normalize(vec3(getGradH(pos,1.4),.5));\n    return n;\n}\n\n\n\n\nvec4 getCol(vec2 uv)\n{\n    #define DRes Res\n    #define SRes vec2(textureSize(ColorTex,0))\n    uv=(uv-.5)*DRes*min(SRes.x/DRes.x,SRes.y/DRes.y)/SRes+.5;\n    return texture(ColorTex,uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cosi=sin(vec2(1.6,0)+.7*iTime);\n \tmat3 rot = mat3(cosi.xyy*vec3(1,0,1),vec3(0,1,0),cosi.yyx*vec3(-1,0,1));\n    float SC=Res.x/600.;\n    float SSC=sqrt(SC);\n    \n    vec2 scr=fragCoord/Res*2.-1.;\n    vec3 vdir=normalize(vec3(scr,-2.));\n\n    vec3 n = normalize(vec3(-getGrad(fragCoord,1.),1));\n    vec3 ng = normalize(vec3(\n         (texture(iChannel1,fragCoord/Res1/1.4).xy-.5)*1.\n        +(texture(iChannel1,fragCoord/Res1/3.).xy-.5)*1.\n        +(texture(iChannel1,fragCoord/Res1/6.).xy-.5)*1.\n        ,0)\n        +vec3(0,0,4.5));\n        \n    ng=getGlassNormal(fragCoord*3./SSC);\n    \n    //vec3 backlight=texture(iChannel1,(refract(vdir,ng,1.5).xy-.7*.5*iTime*vec2(1,0))*.021).xxx*.8+.8;\n    vec3 backlight=texture(iChannel3,rot*refract(vdir,ng,1.5).xyz,-1.5).xyz*1.+.6;\n    //vec3 refl=myenv(vec3(0,0,0.),reflect(vdir,ng).xzy,1.).xyz;\n    vec3 refl=texture(iChannel3,rot*reflect(vdir,ng).xyz,-1.5).xyz;\n    //vec3 leadrefl=myenv(vec3(0,0,0.),reflect(vdir,n).xzy,1.).xyz;\n    \n    vec4 col = texture(iChannel0,fragCoord/Res);\n    float leadH = getVal(fragCoord,0.);\n    float d = col.z;\n    float sc = col.w;\n    col.xyz = getCol(col.xy).xyz;\n    float br=dot(col.xyz,vec3(.3333));\n    col.xyz=clamp((col.xyz-br)*1.3+br*1.+.12,0.,1.);\n\n    //vec3 leadcol=textureLod(iChannel1,(reflect(vdir,n).xy+1.*iTime*vec2(1,0))*.015,0.).xyz*.65;\n    vec3 leadcol=textureLod(iChannel3,rot*reflect(vdir,n).xyz,5.2).xyz*1.;\n    //float lbr=dot(leadcol,vec3(.3333));\n    //leadcol=(leadcol-lbr)*.3+lbr;\n    vec4 col2=texture(iChannel0,((fragCoord+3.5*vec2(-1,1)*SC+SC*3.*sin(iTime*vec2(2,3)))/Res-.5)*1.+.5,2.7+log2(SC));\n    float d2=col2.z;\n    backlight*=.7+1.*smoothstep(0.,8.*SC,d2)*.5*(.7+.3*texture(iChannel2,col2.xy).xyz);\n    float ao=1.;\n    ao*=1.5-.5*clamp(d/(4.*SC),0.,1.);\n    ao*=.5+.5*clamp(d/(2.*SC),0.,1.);\n    //backlight=vec3(1);\n    //leadcol=.5*leadrefl;\n    leadcol*=leadH;\n    //refl=vec3(clamp(ng.x*-ng.y,0.,1.))*(.8+.2*ng);\n    vec3 refl2=vec3(clamp(n.x*-n.y*2.,0.,1.))/**(.8+.2*n)*/;\n    fragColor.xyz = mix(col.xyz*ao*backlight+refl*.3,leadcol,clamp(leadH,0.,1.));\n    \n    //fragColor.xyz=textureLod(iChannel3,rot*reflect(vdir,n).xyz,4.5).xyz;\n    //fragColor.xyz=leadcol;\n    \n    // vignetting\n    if(true)\n    {\n        vec2 scc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n        float vign = 1.-.7*dot(scc,scc);\n        vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n        vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n        fragColor.xyz *= vign;\n    }\n    \n    fragColor.w=1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// emulating multiple passes by dedicating each frame to a different pass\nconst int NumPasses = 13;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// copy every NumPasses'th frame of video to Buffer\n// (emulating multiple passes by dedicating each frame to a different pass)\n\n#define iPassIndex (iFrame%NumPasses)\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n\nvec4 getCol(vec2 pos)\n{\n    vec2 tres = Res0;\n    // use max(...) for fitting full image or min(...) for fitting only one dir\n    vec2 tpos = (pos-.5*Res1)*min(tres.y/Res1.y,tres.x/Res1.x);\n    vec2 uv = (tpos+tres*.5)/tres;\n\tvec4 col=texture(iChannel0,uv);\n\tvec4 bg=texture(iChannel2,((uv-.5)*.9+.5)+.05*sin(.1*iTime*vec2(2,3)),3.7+log2(Res1.x/600.));\n    col=mix(col,bg,dot(col.xyz,vec3(-.8,1.6,-.8)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iPassIndex==0)\n        fragColor=getCol(fragCoord);\n    else\n        fragColor=texture(iChannel1,fragCoord/iResolution.xy);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// recursively find min and max pixel brightness in a certain region\n// going from small scales to higher scales\n// (emulating multiple passes by dedicating each frame to a different pass)\n\n#define iPassIndex (iFrame%NumPasses)\n\n//#define ResMap (vec2(512,256))\n#define ResMap min(pow(vec2(2.),floor(log2(iResolution.xy))),vec2(512,256))\n\n#define Res iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 ResMap\n#define Res2 vec2(textureSize(iChannel2,0))\n\nbool getNBPixPos(ivec2 coord, int level, inout ivec2 pos1, inout ivec2 pos2)\n{\n    if (level==0) { pos1=coord*ivec2(2,1); pos2=pos1+ivec2(1,0); return coord.x<int(Res1.x)/2; }\n    \n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n    \n    ivec2 c = coord-o;\n    pos1=op+c*(dir+1);\n    pos2=pos1+dir;\n    return c.x>=0 && c.x<s.x && c.y>=0 && c.y<s.y;\n}\n\nvec2 getLevelCoords(vec2 coord, int level, inout vec2 frameCoord)\n{\n\n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n\n    vec2 c = coord*vec2(s)+vec2(o);\n    frameCoord=fract(c);\n    return (floor(c)+.5)/Res1;\n}\n\n\nfloat colDist(vec4 c1, vec4 c2)\n{\n    return dot(c1.xyz-c2.xyz,vec3(.3333));\n}\n\nbool isBigger(vec4 c1, vec4 c2)\n{\n    return colDist(c1,c2)>0.;\n}\n\nvec4 getCol(vec2 coord)\n{\n    return texture(iChannel0,coord/Res1.xy);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if( fragCoord.x>Res1.x || fragCoord.y>Res1.y ) discard;\n    if(iPassIndex==0) {vec2 coord=fragCoord; fragColor=vec4(coord,coord); return; }\n    \n    int isVert = (iPassIndex+1)&1;\n    ivec2 dir = (ivec2(0,1)+iPassIndex+1)&1;\n    \n    ivec2 coord=ivec2(fragCoord);\n\n    // copy previous pass\n    fragColor=texelFetch(iChannel1,coord,0);\n    \n    // who are the neighbours?\n    ivec2 pos1, pos2;\n    if (!getNBPixPos(coord,iPassIndex-1,pos1,pos2)) { return; }\n    \n    vec4 coordMinMax1 = texelFetch(iChannel1,pos1,0);\n    vec4 coordMinMax2 = texelFetch(iChannel1,pos2,0);\n    vec4 cmin1=getCol(coordMinMax1.xy);\n    vec4 cmin2=getCol(coordMinMax2.xy);\n    vec4 cmax1=getCol(coordMinMax1.zw);\n    vec4 cmax2=getCol(coordMinMax2.zw);\n    \n    fragColor.xy = isBigger(cmin2,cmin1)?coordMinMax1.xy:coordMinMax2.xy;\n    fragColor.zw = isBigger(cmax1,cmax2)?coordMinMax1.zw:coordMinMax2.zw;\n    // debug pass levels\n    //fragColor.xyz = vec3(0) + float(iPassIndex)/15.;\n    //fragColor.w = 1.;\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// find voronoi cells\n\n// the effect is fast enough for realtime, but the video framerate is reduced due \n// to \"emulated passes\" (1 pass per frame - unfortunetely there's no passes in shadertoy)\n\n#define iPassIndex (iFrame%NumPasses)\n\n//#define ResMap (vec2(512,256))\n#define ResMap min(pow(vec2(2.),floor(log2(iResolution.xy))),vec2(512,256))\n\n#define Res iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 ResMap\n#define Res2 vec2(textureSize(iChannel2,0))\n\nvec2 getLevelCoords(vec2 coord, int level, inout vec2 frameCoord)\n{\n\n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n\n    vec2 c = coord*vec2(s)+vec2(o);\n    frameCoord=fract(c);\n    return (floor(c)+.5)/Res1;\n}\n\n\nvec4 getCol(vec2 uv)\n{\n    return texture(iChannel0,uv);\n}\n\nfloat colDist(vec4 c1, vec4 c2)\n{\n    return dot(c1.xyz-c2.xyz,vec3(.3333));\n}\n\nvoid getCenterScaleColor( vec2 fragCoord, inout vec2 c, inout vec2 s, inout vec4 col )\n{\n    vec2 frameCoord;\n    vec2 fact=ResMap/vec2(512,256);\n    s=iResolution.xy*vec2(.25,.25)/fact;\n    c=(floor(fragCoord/s)+.5)*s;\n    for(int i=11;i>=0;i--)\n    {\n        vec4 coordMinMax=textureLod(iChannel1,getLevelCoords(fragCoord/iResolution.xy,i,frameCoord)*Res1/Res,0.);\n        vec4 mi = getCol(coordMinMax.xy/Res1);\n        vec4 ma = getCol(coordMinMax.zw/Res1);\n        col=mix(mi,ma,1.);\n        //fragColor.xyz=vec3(0)+dot(fragColor.xyz,vec3(.3333));\n        float detail=(iMouse.x>=1.)?1./(1.+25.*iMouse.x/iResolution.x):.3/sqrt(Res.x/600.);\n        vec2 dir=((i&1)==1)?vec2(1,0):vec2(0,1);\n        s *= ((i&1)==0)?vec2(1,.5):vec2(.5,1);\n        c+=s*(step(vec2(0),fragCoord-c)*2.-vec2(1))*dir*.5;\n        if( abs(colDist(mi,ma))<detail /**float(i+10)/30.*/ ) break;\n    }\n}\n\nvec4 getPixRandS(vec2 pos)\n{\n    //return textureLod(iChannel2,(pos)/Res2,0.)-.5;\n    return textureLod(iChannel2,(floor(pos)+.5)/Res2,0.)-.5;\n}\n\nfloat randness = 0.5;\n\nvec4 getRand(vec2 pos)\n{\n    return textureLod(iChannel2,pos/Res2,0.);\n}\n\nvoid mainImageOld( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n    //fragColor=texture(iChannel1,fragCoord/iResolution.xy);\n    //fragColor=texture(iChannel2,fragColor.xy/Res1);\n}\n\n#define sc (iResolution.x/600.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // just render a new frame every NumPasses'th fame, otherwise copy old frame\n    if (iPassIndex!=NumPasses-1) \n    {\n    \tfragColor=texture(iChannel3,fragCoord/Res);\n        return;\n    }\n    \n    vec4 r = getRand(fragCoord*1.2/sqrt(sc))-getRand(fragCoord*1.2/sqrt(sc)+vec2(1,-1)*1.5);\n    fragCoord+=1.5*sqrt(sc)*(getRand(fragCoord*.135).xy-.5+.5*(getRand(fragCoord*.3).xy-.5));\n    vec4 coords=texelFetch(iChannel1,ivec2(fragCoord.xy),0);\n    fragColor = vec4(0);\n    float sum=0.;\n    \n    vec2 c,s,c2,s2;\n    vec4 color=vec4(0);\n    getCenterScaleColor(fragCoord,c,s,color);\n    vec2 p1,p2,p3;\n    p1 = c+getPixRandS(c).xy*s*randness;\n    float d=length(fragCoord-p1);\n    vec2 cellScale=s;\n    p2 = vec2(0);\n    float d2=1000.;\n    p3 = vec2(0);\n    float d3=1000.;\n\n    vec2 dir = vec2(1,0);\n    vec2 edge = vec2(-1,-1);\n    for(int j=0;j<4;j++)\n    {\n        dir =dir.yx *vec2(1,-1);\n        edge=edge.yx*vec2(1,-1);\n        vec2 pos=c+(s*.5+.5)*edge;\n        for(int i=0;i<32;i++)\n        {\n            getCenterScaleColor(pos,c2,s2,color);\n            vec2 point=c2+getPixRandS(c2).xy*s2*randness;\n            float dact=length(fragCoord-point);\n            if (dact<d) {\n                p3=p2; d3=d2; p2=p1; d2=d; d=dact; cellScale=s2; p1=point;\n            }\n            else if (dact<d2) {\n                d3=d2; p3=p2; d2=dact; p2=point;\n            }\n            else if (dact<d3) {\n                d3=dact; p3=point;\n            }\n            pos+=(dot(c2-pos,dir)+abs(dot(s2*.5,dir))+1.)*dir;\n            if (dot(pos-c,dir)>abs(dot(s,dir)*.5)) break;\n        }\n    }\n    d=100.;\n    d=min(d,abs(dot(fragCoord-(p1+p2)*.5,normalize(p1-p2))));\n    d=min(d,abs(dot(fragCoord-(p1+p3)*.5,normalize(p1-p3))));\n    \n    fragColor.xy = p1/Res; \n    fragColor.z = d;\n    fragColor.w = length(cellScale);\n    \n    #if 0\n    float SC=Res.x/700.;\n    float SSC=sqrt(SC);\n    //fragColor.xyz = (cellColor.xyz*1.+.0)*(1.-pow(d/50./SC,1.));\n    fragColor.xyz = getCol(p1/Res).xyz*1.+.0;\n    //fragColor.xyz *= 1.2;\n    fragColor.xyz *= (1.05-.1*smoothstep(0.,16.,10.*d/sqrt(length(cellScale))));\n    fragColor.xyz *= (1.1-.2*smoothstep(0.,8.,10.*d/sqrt(length(cellScale))));\n    fragColor.xyz *= mix(1.,smoothstep(1.,3.,10.*d/sqrt(length(cellScale))),.8-.5*sqrt(length(cellScale)/100.));\n    //fragColor.xyz *= .6+.4*smoothstep(1.,3.,10.*d/sqrt(length(cellScale)));\n    //fragColor.xyz = vec3(d/50.);\n    #endif\n    // vignetting\n    /*if(true)\n    {\n        vec2 scc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n        float vign = 1.1-.5*dot(scc,scc);\n        vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n        vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n        fragColor.xyz *= vign;\n    }*/\n    //fragColor/=sum;\n    //fragColor.w=1.;\n    //coordMinMax=texelFetch(iChannel1,ivec2(fragCoord/Res*Res1),0);\n    \n    //vec2 co=(iMouse.y<Res.y*.5)?coordMinMax.xy:coordMinMax.zw;\n    //fragColor.xyz=vec3(0)+dot(texture(iChannel0,co/Res1).xyz,vec3(.3333));\n    \n    //fragColor=vec4(coordMinMax.xy/256.,0,1);\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// backup last vid frame, so we can do lighting in image tab in realtime\n\n#define iPassIndex (iFrame%NumPasses)\n\n#define Res (iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n#define Res3 vec2(textureSize(iChannel3,0))\n#define Res4 vec2(textureSize(iChannel4,0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iPassIndex!=NumPasses-1) \n    {\n    \tfragColor=texture(iChannel3,fragCoord/Res);\n        return;\n    }\n   \tfragColor=texture(iChannel2,fragCoord/Res);\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}