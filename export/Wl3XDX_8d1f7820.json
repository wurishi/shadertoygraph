{"ver":"0.1","info":{"id":"Wl3XDX","date":"1596148187","viewed":92,"name":"Testing #1","username":"harism","description":"Testing #1","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(in float n) { return fract(sin(n)*43758.5453123); }\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel1, fragCoord.xy / iResolution.xy).rgb;\n\n    //declare stuff\n\tconst int mSize = 11;\n\tconst int kSize = (mSize-1)/2;\n\tfloat kernel[mSize];\n\tvec3 final_colour = vec3(0.0);\n\t\t\n\t//create the 1-D kernel\n\tfloat sigma = 7.0;\n\tfloat Z = 0.0;\n\tfor (int j = 0; j <= kSize; ++j)\n\t{\n\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t}\n\t\t\n\t//get the normalization factor (as the gaussian has been clamped)\n\tfor (int j = 0; j < mSize; ++j)\n\t{\n\t\tZ += kernel[j];\n\t}\n\t\t\n\t//read out the texels\n\tfor (int i=-kSize; i <= kSize; ++i)\n\t{\n\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t{\n\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel1, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\t}\n\t}\n\t\t\n    float noise = hash((hash(fragCoord.x) + fragCoord.y) * iTime) * .055;\t\t\n\tfragColor = vec4(final_colour/(Z*Z) + noise, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 shearX(float theta) {\n   \treturn mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(theta, 0, 1)\n    );\n}\n\nmat3 shearY(float theta) {\n   \treturn mat3(\n        vec3(1, 0, theta),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat subtractionSDF(float d1, float d2 ) {\n    return max(-d1,d2);\n}\n\nfloat sphereSDF(vec3 p, float s) {\n  return length(p) - s;\n}\n\nfloat boxSDF(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat logoSDF(vec3 samplePoint) {\n    float cylinder = cylinderSDF(samplePoint, 3.0, 0.3);\n    float cylinderNeg = cylinderSDF(samplePoint, 2.4, 0.31);\n    \n    float char1 = boxSDF(shearY(0.65) * rotateY(radians(30.0)) * (samplePoint + vec3(1.0, 0.0, -0.3)), vec3(0.3, 0.3, 1.05));\n    float char2 = boxSDF(shearY(-0.6) *  rotateY(radians(-30.0)) * (samplePoint + vec3(0.3, 0.0, -0.3)), vec3(0.3, 0.3, 0.95));\n\n    float char3 = boxSDF(shearY(-0.65) * rotateY(radians(-30.0)) * (samplePoint + vec3(-1.0, 0.0, -0.3)), vec3(0.3, 0.3, 1.05));\n    float char4 = boxSDF(shearY(0.6) * rotateY(radians(30.0)) * (samplePoint + vec3(-0.3, 0.0, -0.3)), vec3(0.3, 0.3, 0.95));\n    \n    float char5 = boxSDF(shearX(0.5) * (samplePoint + vec3(2.71, 0.0, 0.6)), vec3(1.197, 0.3, 0.32));\n    float char6 = boxSDF(samplePoint + vec3(-1.97, 0.0, 0.6), vec3(0.61, 0.3, 0.32));\n    \n    float char7 = boxSDF(samplePoint + vec3(-2.7, 0.0, -0.1), vec3(0.5, 0.31, 0.38));\n    \n    float retVal = subtractionSDF(cylinderNeg, cylinder);\n    retVal = unionSDF(retVal, char1);\n    retVal = unionSDF(retVal, char2);\n    retVal = unionSDF(retVal, char3);\n    retVal = unionSDF(retVal, char4);\n    retVal = unionSDF(retVal, char5);\n    retVal = unionSDF(retVal, char6);\n    retVal = subtractionSDF(char7, retVal);\n    \n    return retVal;\n}\n\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    samplePoint = rotateY(iTime) * samplePoint;\n    \n    float box = sphereSDF(samplePoint, 2.0);\n    float logo = logoSDF(samplePoint);\n    \n    return mix(box, logo, clamp(2.0 * abs(sin(iTime * 0.2)), 0.0, 1.0));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.2, 0.6, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.2, 0.6, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 25.0, 10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.1, 0.3, 0.6, 0.0);\n        return;\n    }\n\n\t// The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n\t// Use the surface normal as the ambient color of the material\n    vec3 K_a = vec3(0.2, 0.6, 1.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 8.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    float scan = mod(dist + iTime, 20.0);\n    scan = max(scan, mod(dist + iTime * 0.226, 20.0));\n    if (scan > 15.0) color.r += color.b * 0.5;\n    \n   \tfragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 texCoord = fragCoord.xy / iResolution.xy;\n    \n\tfloat t = 0.015;\n\t\n\tvec4 c1 = texture(iChannel0, texCoord + vec2(t * .2,.0));\n\tvec4 c2 = texture(iChannel0, texCoord + vec2(t * .5,.0));\n\tvec4 c3 = texture(iChannel0, texCoord + vec2(t * .9,.0));\n\t   \n\tfragColor = vec4(vec3(c1.r, c2.g, c3.b), 1.);\n    fragColor *= 1.0 - distance(vec2(0.5, 0.5), fragCoord / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}