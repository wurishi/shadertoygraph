{"ver":"0.1","info":{"id":"ssXcR2","date":"1642358523","viewed":796,"name":"Shattered Prism","username":"Hyeve","description":"I think my code is getting worse than evvvvil... but the visuals are getting better too! :D","likes":48,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\n\n//NOTE: this style of very compact, hard-to-read code makes\n//things easier for shaders, especially in the view of\n//livecoding compos where you have very limited time to\n//write them, but it would be absolutely awful anywhere else,\n//and I definitely don't recommend doing it outside of shaders like this\n\n\n\n//all the variables that can be are global because it makes things easier and more compact\nvec3 cp,cn,cr,ro,rd,cc,oc,fc,ss,gl;\nfloat tt,cd,sd=1.,ot,ct=1.,iv=1.,io;\n\n//in order: current ray position, normal, ray direction, ray origin,\n//original ray direction, current colour, object colour, final colour,\n//subsurface (colour), glow (color), time, current distance, scene distance,\n//object transmission, current transmission, inversion (for transparency), index of refraction\n\n//cube SDF, inlined\nfloat bx(vec3 p,vec3 s){vec3 q=abs(p)-s;return min(max(q.x,max(q.y,q.z)),0.)+length(max(q,0.));}\n\n//\"shatter\" function - subtracts a bunch of semi-random planes from the object\nfloat sh(vec3 p, float d, float n, float a, float s, float o)\n{\n\tfor(float i=0.;i<n;i++) //loop for each plane\n\t{\n\t\tp.xy*=rot(a);p.xz*=rot(a*0.5);p.yz*=rot(a+a); //apply semi-random rotation\n\t\tfloat c=mod(i,3.)==0.?p.x:mod(i,3.)==1.?p.y:p.z; //pick semi-random axis for plane\n\t\tc=abs(c-o)-s;d=max(d,-c);//subtract plane from object, using onioning and offset\n        //to give the plane thickness and move it away from the centre\n\t}\n\treturn d; //return final sdf value\n}\n\n//scene/map function\nfloat mp(vec3 p)\n{\n    //rotate entire scene slowly\n\tp.xz *= rot(tt*0.03+1.); \n\tp.yz *= rot(tt*0.05+0.5);\n    //create 2 boxes - one is the actual object, one is purely used for my fake subsurface\n\tfloat d=bx(p,vec3(2,2,2))-0.1;\n\tfloat c=bx(p,vec3(1.2,1.2,1.2));\n    //shatter box\n\td=sh(p,d,9.,sin(tt*0.01+0.3)*3.,(cos(tt*0.1)*0.5+0.5)*0.5+0.008,0.4);\n    //set scene distance, add glow\n\tsd=d;gl+=0.001/(0.001+d*d)*normalize(p*p)*0.008;\n    //set object values - doing inside the scene allows for easier and nicer effects!\n\tif(sd<0.001) \n\t{\n\t\toc=vec3(0.5,0.5,0.8);//base colour - changing this will have a big impact\n\t\tss=pow(c,3.)*vec3(0.5, 0.4,0.6);//fake subsurface\n\t\tio=1.5+c*0.1;//index of refraction\n\t\tot=0.8-c*0.2;//object transmission\n\t}\n\treturn sd;//return the distance - this is only used for the normals function\n}\n\n//inlined raymarcher. Mostly standard, but multiplies the scene distance by the inversion factor\nvoid tr(){cd=0.;for(float i=0.;i<222.;i++){mp(ro+rd*cd);sd*=iv;cd+=sd;if(sd<0.00005||cd>16.)break;}}\n//inlined normal calculation. Using this mat3 is actually slightly less compact, but much cleaner\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.0001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));}\n\n//pixel \"shader\" (coloury bits)\nvoid px()\n{\n  cc=vec3(0.3,0.45,0.7)+length(cr*cr)*0.2+gl; //assign current color to background colour + glow\n  if(cd>16.)return;  //return if we just want background\n  //axis-based diffuse lighting\n  vec3 l=vec3(0.7,0.4,0.9);\n  float df=length(cn*l);\n  //very basic fresnel effect and custom specular effect\n  float fr=pow(1.-df,2.)*0.5;\n  float sp=(1.-length(cross(cr,cn)))*0.2;\n  float ao=min(mp(cp+cn*0.5)-0.5,0.3)*0.3; //custom ambient occulusion effect\n  cc=oc*(df+fr+ss)+fr+sp+ao+gl;  //mix it all together\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  tt=mod(iTime+19., 120.);//keep time low to reduce issues\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=0.5;uv/=vec2(iResolution.y/iResolution.x,1.);\n  ro=vec3(0,0,-8);rd=normalize(vec3(uv,1));//ray origin and direction\n  for(int i=0;i<6*2;i++) //compacted transparency loop - depth 6 (2 pass per layer)\n  {\n     tr();cp=ro+rd*cd;nm();cr=rd;ro=cp-cn*(0.01*iv);//trace and calculate values\n     rd=refract(cr,cn*iv,iv>0.?1./io:io);//refract\n     if(length(rd)==0.)rd=reflect(cr,cn*iv);//reflect if refraction failed\n     px();iv*=-1.;if(iv<0.)fc=mix(fc,cc,ct);//get colour and mix it\n     ct*=ot;if(ct<=0.||cd>128.)break;//update trasmission and break if needed\n  }\n  fragColor = vec4(fc,1);//output colour\n}","name":"Image","description":"","type":"image"}]}