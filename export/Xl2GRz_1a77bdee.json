{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n#define time iTime\n\nconst float INTERSECTION_PRECISION = .01;\nconst float MAX_TRACE_DISTANCE     = 10.;\nconst int NUM_TRACE_STEPS          = 100;\n\n\nconst vec3 lightPos = vec3( 3. , 0.  , 0. );\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\n// By NIMITZ  (twitter: @stormoid)\n// good god that dudes a genius...\n\nfloat tri_1_0( float x ){ \n  return abs( fract(x) - .5 );\n}\n\nvec3 tri3_1_1( vec3 p ){\n \n  return vec3( \n      tri_1_0( p.z + tri_1_0( p.y * 1. ) ), \n      tri_1_0( p.z + tri_1_0( p.x * 1. ) ), \n      tri_1_0( p.y + tri_1_0( p.x * 1. ) )\n  );\n\n}\n                                 \n\nfloat triNoise3D_1_2( vec3 p, float spd , float time){\n  \n  float z  = 1.4;\n\tfloat rz =  0.;\n  vec3  bp =   p;\n\n\tfor( float i = 0.; i <= 3.; i++ ){\n   \n    vec3 dg = tri3_1_1( bp * 2. );\n    p += ( dg + time * .1 * spd );\n\n    bp *= 1.8;\n\t\tz  *= 1.5;\n\t\tp  *= 1.2; \n      \n    float t = tri_1_0( p.z + tri_1_0( p.x + tri_1_0( p.y )));\n    rz += t / z;\n    bp += 0.14;\n\n\t}\n\n\treturn rz;\n\n}\n\n\n\nfloat smin_2_3(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\n// exponential smooth min (k = 32);\n/*float smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}*/\n\n\nfloat sdSphere( vec3 p, float s ){\n  \n    return length( p ) - s*( (triNoise3D_1_2( p , .02 , time) + triNoise3D_1_2( p * .1 , .02 , time) * 4.) * .3 + .7);\n\n}\n\n\n\nvoid doCamera( out vec3 camPos , out vec3 camTar , in float time ){\n\n  float an = .3 + 10. * sin( time * .1 );\n  camPos = vec3( 3.5 * sin( an ) , 0. , 3.5 * cos( an ));\n  camTar = vec3( 0. );\n\n}\n\nmat3 calcLookAtMatrix( vec3 camPos , vec3 camTar , float roll ){\n\n  vec3 up = vec3( sin( roll ) ,cos( roll ) , 0. );\n  vec3 ww = normalize( camTar - camPos );\n  vec3 uu = normalize( cross( ww , up ) );\n  vec3 vv = normalize( cross( uu , ww ) );\n\n  return mat3( uu , vv , ww );\n\n}\n\n\nvec2 map( vec3 pos ){\n\n\n  vec2 res = vec2( sdSphere( pos ,  .3) ,1. );\n\n  float fRes = res.x;\n  vec3 p;\n  for( int i = 0; i < 6; i ++ ){\n   \n    //vec3 p  = vec3( \n    p = vec3(\n      .8 * sin( ( float( i )+ time* .1 ) * 2. ) ,\n      .8 * sin( ( float( i )+ time* .1 ) * 5. ) ,\n      .8 * sin( ( float( i )+ time* .1 ) * 9. ) \n    );   \n    vec2 res2 = vec2( sdSphere( pos -p ,  .3) , 2. ); \n\n    fRes = smin_2_3( fRes , res2.x , .8);\n\n  } \n    \n  // fRes = opS( fRes , sdSphere( pos - p , .2 ));\n\n  \n  //float fRes = -1.;\n  \n  //float fRes = smin( res.x , res2.x , 8.);\n\n  return vec2( fRes , 1.);\n\n\n\n}\n\n\n// res = result;\nvec2 calcIntersection( in vec3 ro , in vec3 rd ){\n\n  float h     = INTERSECTION_PRECISION * 2.;\n  float t     = 0.;\n  float res   = -1.;\n  float id    = -1.;\n\n  for( int i = 0; i < NUM_TRACE_STEPS; i++ ){\n      \n    if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n    \n    vec2 m = map( ro + rd * t );\n  \n    h  = m.x;\n    t += h;\n    id = m.y;\n\n  }\n\n  if( t < MAX_TRACE_DISTANCE ) res = t;\n  if( t > MAX_TRACE_DISTANCE ) id = -1.;\n\n  return vec2( res , id ); \n\n}\n\nvec3 calcNormal( vec3 pos ){\n\n  vec3 eps = vec3( 0.01 , 0. , 0. );\n  \n  vec3 nor = vec3(  \n    map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n    map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n    map( pos + eps.yyx ).x - map( pos - eps.yyx ).x\n  );\n\n  return normalize( nor );\n  \n\n}\n\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord){\n\n  vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n  vec3 ro , ta;\n  \n  doCamera( ro , ta , time  );\n\n  mat3 camMat = calcLookAtMatrix( ro , ta , 0. ); \n \n  // z = lens length \n  vec3 rd = normalize( camMat * vec3( p.xy , 2. ) ); \n \n  vec2 res = calcIntersection( ro , rd );\n  vec3 col = vec3( 0. );\n\n  if( res.x > 0. ){\n\n    vec3 pos = ro + rd * res.x;\n\n    vec3 lightDir = normalize( pos - lightPos );\n    vec3 nor = calcNormal( pos );\n\n    float lightMatch = max( 0. , dot( nor , lightDir ) );\n\n    vec3 refl = reflect( lightDir , nor );\n    float reflMatch = max( 0. , dot( refl , rd ) );\n\n    float rimMatch =  1. - max( 0. , dot( nor , -rd ) );\n\n\n    vec3 norCol = (nor * .5 + .5);\n\n    vec3 lambCol = ((nor * .5 + .5)* lightMatch);\n    vec3 ambiCol = ( vec3( 1. ) -norCol )*.1;\n    vec3 specCol = vec3( 1. , .8 , 0. ) * pow( reflMatch , 20. );\n    vec3 rimCol  = vec3( .4 , 1. , .8 ) * pow( rimMatch, 4. );\n    \n    col = lambCol + ambiCol + specCol + rimCol;\n\n  }\n\n  fragColor = vec4( col , 1. );\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xl2GRz","date":"1426656557","viewed":265,"name":"MEATABALLS ","username":"cabbibo","description":"Trying to get some bumpier objects","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","glsl"],"hasliked":0,"parentid":"","parentname":""}}