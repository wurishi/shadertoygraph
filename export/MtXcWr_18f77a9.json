{"ver":"0.1","info":{"id":"MtXcWr","date":"1504301282","viewed":210,"name":"Meta Shape","username":"rebbur","description":"Signed distance field Meta Image Effect, morphs from one shape to another based on luminance","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","metashape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by - Edwin de Koning - Resolume\n// Meta Shape effect that will be part of Resolume 6\n// Wanted to make a Meta Shape with the use of Distance fields\n// Works cool with camera input as well\n\n\nconst float Subd \t= 20.0;\t//Subdivisions\n\nconst int \tShape1 \t= 0;\t//0=Circle, 1=Rectangle, 2=Hexagon, 3=Cross\nconst int \tShape2 \t= 3;\t//0=Circle, 1=Rectangle, 2=Hexagon, 3=Cross\n\nconst int \tFill \t= 2;  \t//0=White, 1=Greyscale, 2-Sampled, 3-Original\nconst int \tScale \t= 1;\t//0=Don't Scale, 1=Scale based on luminance \nconst int \tInvert\t= 0;\t//toggle to invert luminance\nconst int \tMode \t= 0; \t//0=Fill, 1=Outline, 2=Outline Scaled\"\n\nconst float Margin \t= 0.95;\t//\n\n\nconst float SQRT_2 = 1.4142135623730951;\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat innerBorderMask(float dist, float width)\n{\n    //dist += 1.0;\n    float alpha1 = clamp(dist + width, 0.0, 1.0);\n    float alpha2 = clamp(dist, 0.0, 1.0);\n    return alpha1 - alpha2;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat crossDist(vec2 p, float size)\n{\n    float x = SQRT_2/2.0 * (p.x - p.y);\n    float y = SQRT_2/2.0 * (p.x + p.y);\n    float r1 = max(abs(x - size/3.0), abs(x + size/3.0));\n    float r2 = max(abs(y - size/3.0), abs(y + size/3.0));\n    float r3 = max(abs(x), abs(y));\n    float r = max(min(r1,r2),r3);\n    r -= size/2.0;\n    return r;\n}\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\nfloat shapeIt(vec2 pos, vec2 center, float size,  int shape)\n{\n    float result = 1.0;\n    \n    if (shape == 0)\n        result = circleDist(translate(pos, center), size);\n    if (shape == 1)\n        result = boxDist(translate(pos, center), vec2(size), size/20.0);\n    if (shape == 2)\n        result = sdHexPrism(vec3(translate(pos, center), 0.0), vec2(size));\n    if (shape == 3)\n        result = crossDist(translate(pos, center), size*2.0);\n    \n    return result;\n    \n}\nfloat fillIt(float dist, float size, float luminance)\n{\n    if (Mode == 0) //Fill\n        return fillMask(dist);\n    else if (Mode == 1) //Outline\n        return innerBorderMask(dist, size / 8.0 );\n    else if (Mode == 2) //OutLine Scaled, Scale based on Luminance\n        return innerBorderMask(dist, size / max(2.0, (1.0-luminance)*12.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat Aspect = iResolution.x / iResolution.y;    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t//create Tiled position\n    vec2 tiled = uv;\n    \n\tvec2 subDivisions = vec2(ceil(Subd*Aspect), Subd);\n\ttiled *= subDivisions;\n    tiled = floor( tiled );\n    tiled /= subDivisions;\n\n    //sample color of Tile\n    vec4 color = texture( iChannel0, tiled);\n        \n    float luminance = color.r*0.30+color.g*0.59+color.b*0.11;\n    if (Invert == 1)\n        luminance = 1.0-luminance;\n    \n    //current position\n    vec2 pos = gl_FragCoord.xy + vec2(0.5);\n    \n    //calculate size of cell\n    vec2 cellSize = (vec2(1.0) / subDivisions) * iResolution.xy;\n    \n    float minSize = min(cellSize.x, cellSize.y);\n    \n    //determine size of Shape\n    float shapeSize = Scale == 1 ? minSize*Margin*luminance : minSize*Margin;\n\tshapeSize *= 0.5;\n    \n    //find center of this Tile\n\tvec2 center = iResolution.xy * tiled + (cellSize*0.5);\n\n    //calculate Interpolated Shape (Shape1 morphs to Shape2, luminance determines phase)\n    float dst = mix(shapeIt(pos, center, shapeSize, Shape1),\n                    shapeIt(pos, center, shapeSize, Shape2),\n                    luminance);\n    \n    //Determine color of Shape\n    vec4 multiply = vec4(0.0);\n    if (Fill == 0) //White\n        multiply = vec4(vec3(1.0), color.a);\n    if (Fill == 1) //Greyscale\n        multiply = vec4(vec3(luminance), color.a);\n    if (Fill == 2) //Sampled\n        multiply = color;\n    if (Fill == 3) //Original\n        multiply = texture( iChannel0, uv);\n    \n    //fill the Shape\n    fragColor = fillIt(dst, shapeSize, luminance) * multiply;\n}","name":"Image","description":"","type":"image"}]}