{"ver":"0.1","info":{"id":"4d3SWB","date":"1461099301","viewed":639,"name":"Text In Space","username":"akohdr","description":"Rendering 2D text as voxels in 3D voxel space\n(click viewport to see animated text framebuffer)","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["2d","3d","text","voxel","font","ascii","digits","glyph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define SPD_R sin(.2*iTime)\n#define SPD_R .8*sin(cos(1.5*iTime))\n//#define SPD_R iTime/2.\n\n// Cut/Paste begin ------------------------------------------------------------\n#define BOB_H 40.*SPD_R\n#define EYE_D 30.\n#define WORLD_OFFSET vec3(iResolution.x/2., iResolution.y/1.2, -20)\n#define B0 vec4(.0,.0,.0,1.)\n#define B1 vec4(.6,.6,.6,1.)\n#define B2 vec4(.3,.3,.3,1.)\n\n// goal is fast voxel based abstraction returning existence and colour(c) in spacetime(P)\nbool cVoxel(out vec4 c, in vec4 P );\n\nbool VxViewer(out vec4 fc,             // fragColor\n         const in vec2 P,              // fragCoord\n         const in vec3 R,              // iResolution\n        const in float T ) {           // timebase\n    \n    vec2 t = vec2(sin(T), cos(T)),\n         l = P.xx / R.xx - .5;         // vec ops faster than single scalar\n    vec3 r = vec3(l.y*t.y - .8*t.x, \n                  (P.y/R.y - .5)*R.y/R.x, \n                  .8*t.y + l.x*t.x),\n         o = t.xxy * vec3(EYE_D, BOB_H, -EYE_D),\n         h = length(r)/r,\n         q = sign(r),\n         f = floor(o),\n         d = abs(h),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n    \n    for(int i=0;i<200;i++) {\n\n        if(cVoxel(fc,vec4(f + WORLD_OFFSET, T))){\n            fc += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n            return true; // early exit\n        }\n        \n        bvec3 a = lessThan(s,s.yzx),\n              b = lessThanEqual(s,s.zxy);\n              m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n                \n        f += m*q;\n        s += m*d;\n    }\n    return false;\n}\n// Cut/Paste end ------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if(iMouse.z>0.)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else        \n    if(!VxViewer(fragColor, \n                 fragCoord,\n                 iResolution,\n                 SPD_R))          // timebase\n    // we didn't hit voxel\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n}\n\nvec2 prj3Dto2D(const in vec4 p) {    \n    float fpl = 9.;\n    vec2 fOrigin;\n         fOrigin.x = mod(p.z, fpl);\n         fOrigin.y = (p.z/3.) - (fOrigin.x*fpl)-.5;\n    \n    return p.xy + floor(fOrigin) * iResolution.x/5.;\n}\n\nbool cVoxel(out vec4 c,\n             in vec4 P ) {\n    // pull voxel state from 2D map of world slices generated in BufA\n    c = texture(iChannel0, prj3Dto2D(P)/iResolution.xy);\n \treturn c.x+c.y+c.z>.1;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Experiment to pack simple fixed font into mat3 literal glyphs (i.e 3x3 floats)\n// (there are issues on iOS and likely other mobile platforms....)\n\n// font size\n#define DIMS vec2(8,9)\n//#define DIMS vec2(9,10)\n//#define DIMS vec2(16,18)\n\n// really need better construct for mapping\n#define MAP(a,b,c) if(a<b)return c;\n#define DIVMOD(v,d) vec4(floor(v/d),mod(v,d))\n\n#define BLK vec4(.0,.0,.0,1.)\n#define GRY vec4(.5,.5,.5,1.)\n#define WHT vec4(1.,1.,1.,1.)\n#define RED vec4(1.,.0,.0,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define YEL vec4(1.,1.,.0,1.)\n#define ORG vec4(1.,.5,.0,1.)\n#define PNK vec4(1.,.0,.5,1.)\n#define MAG vec4(1.,.0,1.,1.)\n#define CYN vec4(0.,1.,1.,1.)\n#define PRP vec4(.5,.0,.5,1.)\n\n#define glyph glyph_8_9\nmat3 glyph_8_9(float ch);\n\n// pow() has significant issues on iPad\n// quick dirty impls. provide int powers of 2/10 up to 16\n\nfloat pow2_16(float p) {\n    MAP(p,  1., 1.)\n    MAP(p,  2., 2.)\n    MAP(p,  3., 4.)\n    MAP(p,  4., 8.)\n    MAP(p,  5., 16.)\n    MAP(p,  6., 32.)\n    MAP(p,  7., 64.)\n    MAP(p,  8., 128.)\n    MAP(p,  9., 256.)\n    MAP(p, 10., 512.)\n    MAP(p, 11., 1024.)\n    MAP(p, 12., 2048.)\n    MAP(p, 13., 4096.)\n    MAP(p, 14., 8192.)\n    MAP(p, 15., 16384.)\n    MAP(p, 16., 32768.)\n    MAP(p, 17., 65536.)\n    return 0.;\n}\n\nfloat pow10_16(float p) {\n    MAP(p,  1., 1.)\n    MAP(p,  2., 10.)\n    MAP(p,  3., 100.)\n    MAP(p,  4., 1.e3)\n    MAP(p,  5., 1.e4)\n    MAP(p,  6., 1.e5)\n    MAP(p,  7., 1.e6)\n    MAP(p,  8., 1.e7)\n    MAP(p,  9., 1.e8)\n    MAP(p, 10., 1.e9)\n    MAP(p, 11., 1.e10)\n    MAP(p, 12., 1.e11)\n    MAP(p, 13., 1.e12)\n    MAP(p, 14., 1.e13)\n    MAP(p, 15., 1.e14)\n    MAP(p, 16., 1.e15)\n    MAP(p, 17., 1.e16)\n    return 0.;\n}\n\n// digit value from value v at column i (one based) under base b\nfloat modMask(lowp float v, lowp float i, lowp float b) {\n    float f = floor(i),           // forgetting to floor i causes headaches so included\n          p1 = pow(b,f-1.);\n    return (mod(v,pow(b,f))-mod(v,p1))/p1;\n}\n#define hexDigit(v,i) modMask(v,i,16.)\n//#define binDigit(v,i) modMask(v,i,2.)\n//#define decDigit(v,i) modMask(v,i,10.)\n\n// fix for bin/decDigit which were failing on iPad due to issues with pow()\nfloat binDigit(lowp float v, lowp float i) {\n    float f = floor(i),           // forgetting to floor i causes headaches so included\n          p1 = pow2_16(f-1.);\n    return (mod(v,pow2_16(f))-mod(v,p1))/p1;\n}\n\nfloat decDigit(lowp float v, lowp float i) {\n    float f = floor(i),           // forgetting to floor i causes headaches so included\n          p1 = pow10_16(f-1.);\n    return (mod(v,pow10_16(f))-mod(v,p1))/p1;\n}\n\n//=================================================================================\n\nvec4 palette(float a) {\n    MAP(a, 0.5, BLK)\n    MAP(a, 1.5, WHT)    \n    MAP(a, 2.5, RED)\n    MAP(a, 3.5, GRN)    \n    MAP(a, 4.5, BLU)    \n    MAP(a, 5.5, YEL)\n    MAP(a, 6.5, ORG)    \n    MAP(a, 7.5, PRP)    \n    MAP(a, 8.5, CYN)\n    MAP(a, 9.5, GRY)\n    return BLK;\n}\n\nfloat idxMat3(mat3 g, vec2 p) {\n    #define M_IDX(i,r,c) MAP(p.y,i,decDigit(g[r][c],DIMS.x-p.x))\n    float v;\n    // indexing matrix with loop i crashes firefox\n    // we index row/column into matrix by p\n    //   then select dec. digit from element by x (reversed)\n    M_IDX(1.5, 2, 2);\n    M_IDX(2.5, 2, 1);\n    M_IDX(3.5, 2, 0);\n    M_IDX(4.5, 1, 2);\n    M_IDX(5.5, 1, 1);\n    M_IDX(6.5, 1, 0);\n    M_IDX(7.5, 0, 2);\n    M_IDX(8.5, 0, 1);\n    M_IDX(9.5, 0, 0);\n    return v;\n}\n\nfloat framebuffer(vec4 dm) \n{\n    // returns char at location dm\n    \n    // for now we we show all defined chars\n    return mod(dm.y*DIMS.x + dm.x, 91.);\n}\n\nvec4 renderAlpha(vec2 p) \n{\n    vec4  dm = DIVMOD(p,DIMS);  // we only want to div/mod once, expensive\n    float ch = framebuffer(dm);\n    mat3   g = glyph(ch);\n    float pc = idxMat3(g, dm.zw);\n    \n    // modulating font palette color by time to animate 3D text\n    // (black text currently invisible)\n    float t = iTime+12.;\n    vec2 vt = abs(vec2(-sin(t/20.), cos(t/30.)));\n    float mc = mod(vt.y*(t/30.*dm.x)+vt.x*t/30.*dm.y,10.);\n    \n    vec4   c = palette(pc * mc);  // mod colour cycles\n    \n    // modulate the returned palette colour\n//    c *= vec4(vt,vt);\n    c *= 1.3;  // brighten slightly\n    \n    c.w = floor(pc);\t                     // use alpha channel as stencil\n    return c;\n}\n\n//=================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // <FIX>: black stripe boundary on map to prevent 'beam forming'\n    //      There is a sampler setting I think that could help here.\n\tvec3 rl = iResolution-1.;\n    vec2 P = fragCoord;\n    vec4 c = fragColor;\n    if(P.x<1.||P.y<1.) {c = vec4(0); return;}\n    if(P.x>rl.x||P.y>rl.y)  {c = vec4(0); return;}\n    // </FIX>\n\n    fragColor = vec4(0);\n\n    // overlay text field\n    vec4 ac = renderAlpha(fragCoord);\n    if(ac.w>0.) fragColor = ac;\n}\n\n// Use hanging macro for glyph defs\n#define GLYPH(i) if(g<i)return mat3(\n\nmat3 glyph_8_9(float g) {\n    GLYPH(032.5) 0); \n    GLYPH(042.5) \n        00001000.,\n        00101010.,\n        00011100.,\n        00111110.,\n        00011100.,\n        00101010.,\n        00001000.,\n        00000000.,\n        00000000.);\n    GLYPH(046.5) \n        00000000.,\n        00000000.,\n        00000000.,\n        00000000.,\n        00000000.,\n        00011000.,\n        00011000.,\n        00000000.,\n        00000000.);\n    GLYPH(049.5) \n        00011000.,\n        00001000.,\n        00001000.,\n        00001000.,\n        00001000.,\n        00001000.,\n        00011100.,\n        00000000.,\n        00000000.);\n    GLYPH(050.5) \n        00111100.,\n        01000010.,\n        00000010.,\n        00001100.,\n        00110000.,\n        01000000.,\n        01111110.,\n        00000000.,\n        00000000.);\n    GLYPH(051.5) \n        00111100.,\n        01000010.,\n        00000010.,\n        00011100.,\n        00000010.,\n        01000010.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(052.5) \n        01000100.,\n        01000100.,\n        01000100.,\n        00111110.,\n        00000100.,\n        00000100.,\n        00000100.,\n        00000000.,\n        00000000.);\n    GLYPH(053.5) \n        01111110.,\n        01000000.,\n        01111000.,\n        00000100.,\n        00000010.,\n        01000100.,\n        00111000.,\n        00000000.,\n        00000000.);\n    GLYPH(054.5) \n        00111100.,\n        01000010.,\n        01000000.,\n        01011100.,\n        01100010.,\n        01000010.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(055.5) \n        00111110.,\n        01000010.,\n        00000010.,\n        00000100.,\n        00000100.,\n        00001000.,\n        00001000.,\n        00000000.,\n        00000000.);\n    GLYPH(056.5) \n        00111100.,\n        01000010.,\n        01000010.,\n        00111100.,\n        01000010.,\n        01000010.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(057.5) \n        00111100.,\n        01000010.,\n        01000010.,\n        00111110.,\n        00000010.,\n        00000010.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(058.5) \n        00111100.,\n        00100100.,\n        01001010.,\n        01010010.,\n        01010010.,\n        00100100.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(059.5) 0); \n    GLYPH(060.5) 0); \n    GLYPH(061.5) 0); \n    GLYPH(062.5) 0); \n    GLYPH(063.5) 0); \n    GLYPH(064.5) 0); \n    GLYPH(065.5) \n        00011000.,\n        00100100.,\n        01000010.,\n        01111110.,\n        01000010.,\n        01000010.,\n        01000010.,\n        00000000.,\n        00000000.);\n    GLYPH(066.5) \n        11111000.,\n        01000100.,\n        01000100.,\n        01111000.,\n        01000100.,\n        01000100.,\n        11111000.,\n        00000000.,\n        00000000.);\n    GLYPH(067.5) \n        00011100.,\n        00100010.,\n        01000000.,\n        01000000.,\n        01000000.,\n        00100010.,\n        00011100.,\n        00000000.,\n        00000000.);\n    GLYPH(068.5) \n        11111000.,\n        01000100.,\n        01000010.,\n        01000010.,\n        01000010.,\n        01000100.,\n        11111000.,\n        00000000.,\n        00000000.);\n    GLYPH(069.5) \n        01111110.,\n        01000000.,\n        01000000.,\n        01111000.,\n        01000000.,\n        01000000.,\n        01111110.,\n        00000000.,\n        00000000.);\n    GLYPH(070.5) \n        01111110.,\n        01000000.,\n        01000000.,\n        01111000.,\n        01000000.,\n        01000000.,\n        01000000.,\n        00000000.,\n        00000000.);\n    GLYPH(071.5) \n        00111100.,\n        01000010.,\n        01000000.,\n        01001110.,\n        01000010.,\n        01000010.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(072.5) \n        01000010.,\n        01000010.,\n        01000010.,\n        01111110.,\n        01000010.,\n        01000010.,\n        01000010.,\n        00000000.,\n        00000000.);\n    GLYPH(073.5) \n        00111000.,\n        00010000.,\n        00010000.,\n        00010000.,\n        00010000.,\n        00010000.,\n        00111000.,\n        00000000.,\n        00000000.);\n    GLYPH(074.5) \n        01111110.,\n        00000100.,\n        00000100.,\n        00000100.,\n        00000100.,\n        01000100.,\n        00111000.,\n        00000000.,\n        00000000.);\n    GLYPH(075.5) \n        01000100.,\n        01001000.,\n        01010000.,\n        01110000.,\n        01001000.,\n        01000100.,\n        01000010.,\n        00000000.,\n        00000000.);\n    GLYPH(076.5) \n        00100000.,\n        00100000.,\n        00100000.,\n        00100000.,\n        00100000.,\n        00100000.,\n        00111111.,\n        00000000.,\n        00000000.);\n    GLYPH(077.5) \n        01000010.,\n        01100110.,\n        01011010.,\n        01000010.,\n        01000010.,\n        01000010.,\n        01000010.,\n        00000000.,\n        00000000.);\n    GLYPH(078.5) \n        01100010.,\n        01100010.,\n        01010010.,\n        01001010.,\n        01000110.,\n        01000010.,\n        01000010.,\n        00000000.,\n        00000000.);\n    GLYPH(079.5) \n        00111100.,\n        01000010.,\n        01000010.,\n        01000010.,\n        01000010.,\n        01000010.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(080.5) \n        11111100.,\n        01000010.,\n        01000010.,\n        01111100.,\n        01000000.,\n        01000000.,\n        01000000.,\n        00000000.,\n        00000000.);\n    GLYPH(081.5) \n        00111100.,\n        01000010.,\n        01000010.,\n        01000010.,\n        01001010.,\n        01000110.,\n        00111101.,\n        00000000.,\n        00000000.);\n    GLYPH(082.5) \n        01111100.,\n        01000010.,\n        01000010.,\n        01111100.,\n        01001000.,\n        01000100.,\n        01000010.,\n        00000000.,\n        00000000.);\n    GLYPH(083.5) \n        00111100.,\n        01000010.,\n        01000000.,\n        00111100.,\n        00000010.,\n        01000010.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(084.5) \n        01111100.,\n        00010000.,\n        00010000.,\n        00010000.,\n        00010000.,\n        00010000.,\n        00010000.,\n        00000000.,\n        00000000.);\n    GLYPH(085.5) \n        01000010.,\n        01000010.,\n        01000010.,\n        01000010.,\n        01000010.,\n        01000010.,\n        00111100.,\n        00000000.,\n        00000000.);\n    GLYPH(086.5) \n        01000010.,\n        01000010.,\n        01000010.,\n        01000010.,\n        00100100.,\n        00100100.,\n        00011000.,\n        00000000.,\n        00000000.);\n    GLYPH(087.5) \n        01000001.,\n        01000001.,\n        01000001.,\n        01001001.,\n        01001001.,\n        01001001.,\n        00110110.,\n        00000000.,\n        00000000.);\n    GLYPH(088.5) \n        01000100.,\n        01000100.,\n        01000100.,\n        00111000.,\n        00101000.,\n        01000100.,\n        01000100.,\n        00000000.,\n        00000000.);\n    GLYPH(089.5) \n        01000100.,\n        01000100.,\n        01000100.,\n        00111000.,\n        00010000.,\n        00010000.,\n        00010000.,\n        00000000.,\n        00000000.);\n    GLYPH(090.5) \n        01111110.,\n        00000010.,\n        00000100.,\n        00010000.,\n        00110000.,\n        01000000.,\n        01111110.,\n        00000000.,\n        00000000.);\n\t\n    return mat3(0);\n/*\n    // can likely get at least 14 digits accuracy out dec float.\n    GLYPH(256.) \n        00000000000000.,\n        00000000000000.,\n        00000000000000.,\n        00000000000000.,\n        00000000000000.,\n        00000000000000.,\n        00000000000000.,\n        00000000000000.,\n        00000000000000.); \n*/\n}\n","name":"Buf A","description":"","type":"buffer"}]}