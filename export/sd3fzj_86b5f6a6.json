{"ver":"0.1","info":{"id":"sd3fzj","date":"1656771926","viewed":74,"name":"Disapproving lemon","username":"IdeaSquirrel","description":"Was trying to figure out why I as getting a weird mask value from The Art Of Code tut 2 (I was getting mask > 1 rather than mask < 0) so I played around with some values.\n\nLemon here did not approve","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circles","beginner","lol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLUR 1.5/iResolution.y\n#define RADIUS .3\n#define EYE_RADIUS .05\n#define MOUTH_RADIUS .2\n\nfloat Circle(vec2 uv, vec2 pos, float r, float blur) {\n  return smoothstep(r, r + blur, length(uv - pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n/*\n  for posterity\n  \n  \n  // face\n  float mask = Circle(uv, vec2(0.), RADIUS, BLUR);\n\n  // left eye\n  mask += Circle(uv, vec2(-.1, .15), EYE_RADIUS, BLUR);\n\n  // right eye\n  //mask -= Circle(uv, vec2(.1), EYE_RADIUS, BLUR);\n\n  float mouth = Circle(uv, vec2(0.), MOUTH_RADIUS, BLUR);\n  mouth += Circle(uv, vec2(0., .1), MOUTH_RADIUS, BLUR);\n\n  mask += mouth;\n  //mask -= clamp(mouth, 0., 1.);\n\n  // set colour\n  vec3 col = vec3(1., 1., 0.)*(mask);\n\n  if (mask > 1.) {\n    col = vec3(0.,.3,0.);\n  }\n*/  \n  \n  // ok this makes sense, it's just the sum of all the circle parts\n  // turns out I don't need the larger circle\n  // still, think in layers. remember, uvs are across the ENTIRE screen, these accumulate because any uv outside a circle = 1.\n  float mask = Circle(uv, vec2(-.1, .15), EYE_RADIUS, BLUR)\n             + Circle(uv, vec2(0.), MOUTH_RADIUS, BLUR)\n             + Circle(uv, vec2(0., .1), MOUTH_RADIUS, BLUR);\n\n\n  // mix is an interpolation function\n  // whereas smoothstep returns 0 < x < 1 based on parameters\n  // mix will return a value a < x < b based on the weighted step c\n  // this mill blend colour a into colour b, providing antialiasing \n  vec3 col = mix( \n      // black or yellow since min(1., mask) == 0|1 (ignoring interpolated values, think main sections of the circles)\n      vec3(1., 1., 0.)* min(1., mask),\n      \n      // green, obvs\n      vec3(0.,.3,0.), \n      \n      /* \n          we're only interested in the intersections of the circles\n          by clamping this way, we're setting any value < 2 to be between 0 and 1\n          this happens to be any ux within the circle intersections that define the lemon\n          uvs that have a mask >= 2 are set to 1, which is green\n          uvs inside the eye and the body have a mask of 0, which stay at 0 so we don't increment from black/yellow\n          \n          however, since we use a different formula to calculate a\n           => vec3(1., 1., 0.) * min(1., 0.) = vec3(0.)....\n          so that little section of the eye has a colour of black\n          \n          for the rest of the body where mask = 1.\n          our clamp value is STILL 0. => clamp(1. - 1., 0., 0.)\n          but our COLOUR value is yellow\n           => vec3(1., 1., 0.) * min(1., 1.) = vec3(1., 1., 0.)\n           \n          for everywhere else, the clamp value will be 1. which steps the mix function from a to b (green)\n           \n          interpolated values are then between yellow => green\n      */\n      clamp(mask-1.,0.,1.) \n  );\n  \n  // debug\n  //if (mask == 0.) col = vec3(1.,0.,0.);\n  //if (mask == 1.) col = vec3(0.,1.,0.);\n  //if (mask == 2.) col = vec3(0.,0.,1.);\n  //if (mask == 3.) col = vec3(1.,1.,0.);\n    \n  // Output to screen\n  fragColor = vec4(pow(col, vec3(1./2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}