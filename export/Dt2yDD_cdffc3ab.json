{"ver":"0.1","info":{"id":"Dt2yDD","date":"1691790325","viewed":110,"name":"Electric Cosine Flower","username":"ChunderFPV","description":"Another shader using my point flow template.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["grid","flower","cosine","points","transform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define H(a) (cos(radians(vec3(0, 60, 120))+(a)*6.2832)*.5+.5)  // hue\n#define QP(v) P(u.v, l, t, R.y/5e2)*.5  // quick points\n\n// points: xy, overlap, value, size\nfloat P(vec2 u, float l, float t, float r)\n{\n    float i = 0., f = i, c = i;\n    vec2 w = fwidth(u), p;\n    for (; i++<l;)\n    {\n        p.x = round((u.x-i)/l)*l+i; // skip i rows\n        f = mod(trunc(p.x)*t, 1.);  // multiply ints with value\n        p.y = round(u.y-f)+f;       // set as y\n        c = max(c, r/length((u-p)/w));\n        p.y = sin(6.2832*p.x*t);\n        c = max(c, r/length((u-p)/w)*2.);\n    }\n    //c = clamp(c, 0., 1.); // limit brightness\n    c /= max(1., sqrt(abs(u.x))); // darken\n    return c;\n}\n\n// grid: xy, value, scale\nfloat G(vec2 u, float t, float s)\n{\n    vec2 l, g, d, v;\n    l = max(vec2(0), 1.-abs(fract(u+.5)-.5)/fwidth(u)/1.5); // lines\n    g = 1.-abs(sin(3.1416*u)); // glow\n    d = max(vec2(0), 1.-abs(sin(3.1416*round(u)*t))*s); // denominator\n    v = (l+g*.5)*d; // blend\n    return v.x+v.y;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float t = .6+iTime/60.,\n          q = 6.,  // num leafs\n          s = 13., // scale\n          l = 10., // overlap loop (detail)\n          r;\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-.5*R)/R.y*4.;\n    vec3 u = normalize(vec3((U-.5*R)/R.y, 1)),\n         c = .7*vec3(.1, .3, .4) * (1.3 - length(u.xy)/2.); // color\n    if (iMouse.z < 1.) m = -vec2(cos(t*6.2832), sin(t*6.2832*2.)); // figure 8 movement\n    u *= s; // scale coords\n    r = length(u.xy); // radius\n    u.xy = vec2( cos((1.5708+atan(u.y, u.x))*q)+r, r ); // transform\n    u.xy += m*4.;    // move xy with mouse\n    u /= abs(u.yzx); // quotient transform\n    c += QP(xy) + QP(yx) + QP(yz) + QP(zy) + QP(zx) + QP(xz); // points\n    c += G(u.xy, t, s) * .2; // grid\n    c += .4*H(u.z+t)/max(abs(u.x), abs(u.z)); // more color\n    C = vec4(c*c, 1);\n}","name":"Image","description":"","type":"image"}]}