{"ver":"0.1","info":{"id":"fsSfDt","date":"1647336881","viewed":100,"name":"Rose - Polar - For Dummies","username":"raoul","description":"as usual i try step by step to approach a simple adaptation to the rose curve:\nr = a * cos(n * theta)\nhttps://mathworld.wolfram.com/RoseCurve.html\na = length of each petal \nn = number of petal \nif value is odd, we exact n petal \nif n is even we have n * 2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rosepolarfordummies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Map pixel coordinate from -0.5 to 0.5\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; \n    uv.x *= iResolution.x / iResolution.y;\n    \n    //as you can see -270° (or 3/2 PI) are at top, we need to rotate to correspond to our trigo circle\n     //https://i.pinimg.com/736x/a3/fe/96/a3fe96f069ced8ffbf84ed52c7ffe271--trig-circle-blank-unit-circle.jpg\n     //with a very naive start engine\n     if(iTime < 2.){\n         uv = rotate2d( sin(iTime * PI) )  * uv ;\n     }\n     else\n     {\n        uv = rotate2d( mod(iTime*4.  , 2. * PI) )  * uv ;\n    }\n    \n    \n    float angle = atan(uv.y, uv.x) + PI; //atan send me a value {-PI PI} i remap de 0 a 2PI\n    float radius = length(uv) ;\n    vec2 polar = vec2(angle, radius ); \n    vec3 colo = vec3(0.); \n    \n    \n    // we need to draw approx 270° arc and 90° arc \n    //if my x coordinate are beetween some value\n    float res = step((2.98 / 2. * PI), polar.x) * step( polar.x, (3.02 / 2. * PI)); \n    res += step(( PI / 2.02), polar.x) * step( polar.x, (PI /1.98  ));\n   \n    float f = cos(angle*3.);\n    //one minus to invert color my rotor can be 1 and i can do anything with this one\n    //colo = vec3( smoothstep(f+0.02, f  , radius*2.) );\n    //suggestion from elenzil\n    //* in the smoothstep, you may want to factor radius into the smoothing gap size.\n    //* also in smoothstep, it's good to include the screen resolution, so that the amount of anti-aliasing is more or less constant in a tiny window and on fullscreen.\n    \n    colo = vec3(smoothstep(10./ radius / iResolution.y, 0.0, radius*2. - f) );\n     \n\n    // Time varying pixel color reuse of \n    vec3 col =  colo * cos(iTime+uv.xyx+vec3(0,2,4)) + res * -cos(iTime+uv.xyx+vec3(0,2,4)) ;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}