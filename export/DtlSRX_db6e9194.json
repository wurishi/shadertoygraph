{"ver":"0.1","info":{"id":"DtlSRX","date":"1675119711","viewed":52,"name":"cos approx","username":"valalalalala","description":"Attempt at an approximation of cosine (and sine) by gluing two x^2 curves. It does drift quite a lot for larger input input values (easily compensated). It is intended for novelty use only and primarily so I can stop thinking about it :-P","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["2d","sin","approximation","cos","sincos","trigonometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        //////////////////////////////////////////////////////////////////////\n       //                                                                 ////\n      //  \"cos approx\"                                                   // //\n     //                                                                 //  //\n    //  Attempt at an approximation of cosine (and sine) by gluing     //   // \n   //  two x^2 curves. It does drift quite a lot for larger input     //    //\n  // input values. Intended for novelty use only.                    //     //\n //                                                                 //     //\n/////////////////////////////////////////////////////////////////////     //\n//                                                                 //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike           //   //\n// 3.0 Unported License                                            //  //\n//                                                                 // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                               ////\n//                                                                 /// \n/////////////////////////////////////////////////////////////////////\n\n// v1 is pretty wonky, v2 has a sqrt, \n// v3 is a diamond and v4 is a star-thingie\n#define cosa cosaV1\n\nconst float TAU = 99733. / 15873.;\nconst float AUT = TAU * .25;\n\nfloat tauRanger( float x ) {\n    return x = mod( x, TAU ) / TAU;\n}\n\nfloat triangle( float x ) {\n    return 4. * abs( fract( tauRanger( x ) ) - .5 ) -1.;\n}\n\nfloat cosaV2( float x ) {\n    float dp = triangle(x);\n    return sign( dp ) * sqrt( abs( dp ) );\n}\n\nfloat cosaV3( float x ) {\n    return triangle(x);\n}\n\nfloat cosaV4( float x ) {\n    float dp = triangle(x);\n    return sign( dp ) * pow( abs( dp ), 2. );\n}\n\nfloat cosaV1( float x ) {\n    x = tauRanger( x );\n    \n    // using https://www.desmos.com/calculator/kfrjtmvz9d\n    #if 0\n        // long version\n        float i = fract( x * .5 + .0 ); // x2\n        float j = fract( x * .5 + .5 ); // x3\n\n        i = 1. - 4. * pow( i - .5, 2. );\n        j = .0 + 4. * pow( j - .5, 2. );\n    #else\n        float i = 1. - 4. * pow( fract( x * .5 + .0 ) - .5, 2. );\n        float j = .0 + 4. * pow( fract( x * .5 + .5 ) - .5, 2. );\n    #endif  \n        \n    // 1st attempt https://www.desmos.com/calculator/bebf5kb3vx\n    #if 0 \n        i = 1. - pow( 1. - mod( x, 2. ), 2. );\n        j = pow( 1. - mod( x + 1., 2. ), 2. );\n    #endif\n\n    return -8. * ( pow( i - j - .007, 2. ) - .125 );\n}\n\nfloat sina( float x ) {\n    return cosa( x + AUT );\n}\n\nvec2 triga( float x ) {\n    return vec2( cosa( x ), sina( x ) );\n}\nvec2 trig( float x ) {\n    return vec2( cos( x ), sin( x ) );\n}\n\nbool keyToggle( int key, sampler2D keyboardChannel ) {\n    return .0 < texelFetch( keyboardChannel, ivec2(key,2), 0 ).x;\n}\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) /  resolution.y;\n}\nfloat lineDistance( vec2 p, vec2 a, vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n/////////////////////////////////////////////\n// 2 boxes chasing each other, the bluer \n// is the true(r) cosine function\nvec3 drawPath( in vec2 st ) {\n    vec2 p = pixelToUv( st, iResolution.xy );\n    vec3 color = .0 * p.xxx;\n    \n    vec3 nuColor = vec3( 1., 1., .0 );\n    vec3 ogColor = 1. - nuColor;\n\n    float a = mod( iTime, TAU ); \n    float pa = mod( atan( p.y, p.x ), TAU );\n    float r = .011 + .022 * step( abs( pa - a ), .04 );\n                \n    vec2 nu = triga( pa );\n    vec2 og = trig( pa );\n        \n    // error factor is too big for this to work\n    // without pretty large values of r :-/\n    if ( distance( p, nu ) < r ) { \n        color += nuColor;\n    }\n        \n    if ( distance( p, og ) < r ) { \n        color += ogColor;\n    }    \n    \n#if 1\n    // show the entire approximation\n    int count = 33;\n    \n    float f = TAU / float ( count - 1 );\n    vec2 t = triga( f );\n    vec2 current = vec2( 1., .0 ) *.7;\n        \n    vec2 last;\n    for ( int i = 0 ; i < count ; i++ ) {\n        float a = f * float( i );\n\n        #if 1\n            nu = triga( a );\n        #else\n            // this really shows the drift :-P\n            // iq: https://iquilezles.org/articles/sincos/\n            nu = current;\n\n            vec2 next = vec2( \n                t.x * current.x - t.y * current.y,\n                t.y * current.x + t.x * current.y\n            );\n\n            current = next;\n        #endif\n        \n        if ( i > 0 && lineDistance( p, last, nu ) < r ) {\n            color += nuColor;\n            break;\n        }\n        last = nu;\n    }\n#endif\n\n    return color;\n}\n\n// weird attempt to show the side-by-side\nvec3 drawDifference( in vec2 st ) {   \n    \n    vec2 uv = st/iResolution.xy;\n\n    float x = uv.x * ( 7. + 44. * iMouse.x / iResolution.x );\n    \n    float m = .2;\n    float d = .0;\n    \n    if ( keyToggle( 32, iChannel0 ) ) {\n        // cos on top, qos on bottom\n        if ( uv.y > .5 ) {\n            float y = uv.y * 4. - 3.;\n            d = distance( y, cos( x ) );\n        } else {\n\n            float y = uv.y * 4. - 1.;\n            d = distance( y, cosa( x ) );    \n        }\n    } else {\n        // overlay comparison\n        \n        float y = 2. * uv.y - 1.;\n        float d1 = distance( y, cos( x ) );\n        float d2 = distance( y, cosa( x ) );\n        \n        // pressing \"1\" key will toggle the real cos output\n        if ( keyToggle( 49, iChannel0 ) ) {\n            d = d1;\n        } else {\n            // or pressing \"2\" key will toggle the real cos output\n             if ( keyToggle( 50, iChannel0 ) ) {\n                d = d2;\n            } else {\n                // or show the distance\n                d = distance(d1 , d2); \n            }\n        }\n    }\n\n    float f = mod( d, m ) / m;\n    return vec3( d, f,.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 st ) {\n    fragColor = vec4( drawPath( st ) + drawDifference( st ), 1. );\n}","name":"Image","description":"","type":"image"}]}