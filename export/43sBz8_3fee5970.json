{"ver":"0.1","info":{"id":"43sBz8","date":"1728996418","viewed":482,"name":"Concave Heptagon Traversal","username":"Shane","description":"A raymarching traversal of a concave heptagon pattern.","likes":53,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","grid","cross","traversal","extrude","heptagon"],"hasliked":0,"parentid":"4XSyRR","parentname":"Raymarched Cross Traversal"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Concave Heptagon Traversal\n    --------------------------\n    \n    I haven't seen a concave polygon traversal on Shadertoy, so I thought I'd\n    put one together. In fact, I don't recall seeing one anywhere. I'm sure\n    they exist, but they're definitely not commonplace. Technically, this is a \n    raymarched traversal, but still a traversal. The cross pattern it's based \n    off of is concave and not aligned to the grid axis, so this might be the \n    only non axis-aligned traversal as well.\n    \n    Anyway, traversing concave polygons requires a bit more work, but isn't\n    much different to traversing convex ones, with the exception that you need \n    to use a ray line intersection that caters to convexity -- As an aside, the \n    line algorithm works, but there'd have to be better ones around, so if \n    anyone is aware of one, feel free to let me know.\n    \n    This is more of a proof of concept than anything else, so I didn't put a \n    great deal of effort into fine tuning. However, everything works and the\n    frame rate is pretty good on my machine... provided you're in windowed\n    mode. It's not a fullscreen demonstration, that's for sure. :)\n    \n    The scene and lighting is pretty basic, but interesting in the sense that\n    it's not something you commonly see. Anyway, I'll put up something fancier\n    at a later date.\n    \n    \n\n    References:\n\n    // Covering a plane with crosses, then subdividing them through \n    // opposite inner vertices to create a single non-convex heptagon \n    // tiling of the Euclidean plane.\n\tHalf Cross Heptagon Pattern - Shane\n    https://www.shadertoy.com/view/MX2yWV\n\n\n\n*/\n\n\n// Maximum ray distance.\n#define FAR 20.\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n\nconst vec2 scale = vec2(1)/2.;\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); }\n\n// A more haphazard resource-free height function.\n//float hm(vec2 p){ return hash21(p + .121)*.7; }\n\n/*\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return dot(p - ro, n)/dot(rd, n);\n   float dn = dot(rd, n);\n   return dn>0.? dot(p - ro, n)/dn : 1e8;   \n\n} \n*/\n\n// Consider this more of an \"anti-dot-product\" which only works in 2D \n// and just returns the length of the imagined vector, not the actual cross product.\nfloat cross2D(vec2 a, vec2 b)\n{\n\treturn a.x*b.y - a.y*b.x;   \n}\n\n// Return the distance of ray origin to the line intersection point\n// in the direction of the unit direction ray. If the ray falls outside\n// the line between points \"a\" and \"b\", it won't detect a hit... Not\n// all line algorithms work this way. By the way, if anyone know of a\n// faster, more efficient version of this, feel free to let me know.\nfloat rayLineSeg(vec2 ro, vec2 rd, vec2 a, vec2 b){\n\n    vec2 v1 = ro - a;\n    vec2 v2 = b - a;\n    vec2 v3 = vec2(-rd.y, rd.x);\n\n    float dotP = dot(v2, v3);\n    if (abs(dotP)<1e-6) return 1e8; //1e-6\n\n    float t1 = cross2D(v2, v1)/dotP;\n    float t2 = dot(v1, v3)/dotP;\n\n    if (t1 >= 0. && t2 >= 0. && t2 <= 1.) return t1;\n\n    return 1e8;\n}\n\n// IQ's cross distance field.\nfloat sdCross(in vec2 p, in vec2 b, float r){ \n\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y, q.x);\n    vec2  w = (k>0.) ? q : vec2(b.y - p.x, -k);\n    float d = length(max(w, 0.));\n    return ((k>0.)? d: -d) + r;\n}\n\n\n///////////////////////////\n// Cross bound: We don't need a proper distance field to check\n// boundary lines, so we should save ourselves some extra calculations.\n// It was nice to have IQ's proper distance field cross function to \n// refer to when checking the workings. You can find it, here: \n// iquilezles.org/articles/distfunctions2d\n// \n// \"b.x\" represents the height and width of the entire cross, and\n// \"b.y\" the cross thickness.\nfloat bndCross(in vec2 p, in vec2 b){\n     \n    // There's probably a more succinct and faster way to write\n    // this, but it will do.\n    p = abs(p);\n    p = p.x<p.y ? p - b.yx : p - b;\n    return max(p.x, p.y);\n}\n\nvec2 gSc = scale;\n\nvec2 gP;\nvec2[12] gCList;\n//vec2[5] gPList;\n\nvec2 gID;\nfloat gD;\nint gCID;\n\nvec4 pattern(vec2 p){\n    \n    \n    // Overall coordinates and scale.\n    vec2 oP = p;\n    vec2 sc = gSc;\n    \n    // Box vetex and mid-edge IDs. Each are handy to have when working with squares.\n    //const mat4x2 vID = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5));\n    //const mat4x2 eID = mat4x2(vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n    \n    \n    // The cross has thickness, one third of the height, which is evident from\n    // the imagery. If you turn on the grid settings, you'll see that a one to\n    // three ratio triangle is involved, etc.\n    // Cross rotation angle.\n    float a = atan(1., 3.);\n    // Cross height: This follows from the above. Feel free to get out a pen and\n    // paper, or you could take a lazy coder's word for it. :D\n     float ht = sqrt(9./10.);//cos(a);//\n    //a = acos(ht);\n    // The width needs to be one third of the height in order for two equal size\n    // crosses to tile the plane.\n    vec2 si = sc*vec2(ht, ht/3.)/2.;\n    \n    // Cross ID. Only two crosses are needed to tile the plane.\n    int crossID = 0;\n    // Each cross can be subdivided into four pentagons.\n    int pentID = 0;\n    \n    \n    // Square grid setup. Cell ID and local coordinates.\n    vec2 q = p;\n    vec2 iq = floor(q/sc) + .5;\n    q -= (iq)*sc;\n    \n    // More debugging.\n    //float sq = sBox(q, sc/2.);\n    \n    // Copying and rotating local coordinates.\n    mat2 m = rot2(a);\n    //q = m*q; \n    \n    // The cross is rotated, but the local space is not.\n    vec2 lP = q;\n    \n    \n    // The first cross, distance field value and ID.\n    float d2 = bndCross(m*q, si);\n    float d = d2;\n    vec2 id = iq;\n    \n    // Saving the original box ID... Not sure what this is for. Probably debugging.\n    gID = iq;\n    vec2 oID = id;\n    \n    // Next cross.\n    q = oP - sc/2.; //vID[2]*sc\n    iq = floor(q/sc) + .5;\n    q -= (iq)*sc;\n \n    //q = m*q;\n    d2 = bndCross(m*q, si);\n        \n    if(d2<d){\n       d = d2;\n       id = iq + .5;\n       lP = q;\n       crossID = 1;\n      \n    }\n    \n     // Debugging.\n    //d += .01*sc.x;\n    //d = abs(d + .045*sc.x) - sc.x*.045;\n    //d = max(d, sq);\n    \n    gCID = crossID;\n    \n    gP = m*lP;\n    //gD = d; \n    //gD = bndCross(gP, si);\n    gD = sdCross(gP, si - .05, 0.) - .05;\n    \n    \n    // Distance, cross and pentagon ID, and cell ID.\n    return vec4(lP, id);\n}\n\nvoid crossVertices(){\n\n\n    // Rotating the local coordinates to match the rotated crosses.\n    float a = atan(1., 3.);\n    mat2 m = rot2(-a);\n    float ht = sqrt(9./10.);//cos(a);//\n    vec2 sc = gSc;\n    \n    // Box vertex and mid-edge IDs. Each are handy to have when working with squares.\n    const mat4x2 vID = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5));\n    const mat4x2 eID = mat4x2(vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n\n\n    // Four inner vertices.\n    mat4x2 vIn, eIn, vOutA, vOutB;\n    \n    // Precalculating the inner vertices and edges. All are rotated\n    // to match the cross rotation.\n    for(int i = 0; i<4; i++){\n        // Inner vertices.\n        vIn[i] = m*vID[i]*ht/3.*sc.x; // \"ht/3\" is the cross width.\n        eIn[i] = m*eID[i]*2.*ht/3.*sc.x;\n    }\n    \n    for(int i = 0; i<4; i++){\n        // Outer vertices clockwise (two each).\n        vOutA[i] = vIn[i] + eIn[i]; // Inner plus cross-width.\n        vOutB[i] = vIn[(i + 1)%4] + eIn[i]; // Next inner plus cross-width.\n        \n        // Cross list in clockwise order.        \n        gCList[3*i] = vIn[i];\n        gCList[3*i + 1] = vOutA[i];\n        gCList[3*i + 2] = vOutB[i];\n         \n    }\n\n}\n\n\n// Grid cell function.\nvec4 getGrid(vec2 p){\n\n    // Returns the local coordinates and cell center position-based\n    // IDs for the cross pattern.\n    vec4 p4 = pattern(p);\n    return vec4(p4.xy, p4.zw);\n}\n\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n/*\n// This function is better than the one above, but a bit longer. It's a \n// mixture of various people's workings, but I got this one from one of \n// JT's examples. I'll track it down and put the link in later.\n//\nfloat distLineS(vec2 p, vec2 a, vec2 b) {\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    \n    // Just a simple reworking of IQ's line function, from here:\n    // https://iquilezles.org/articles/distfunctions2d/\n    return length(p - b*h)*sign(b.x*p.y - b.y*p.x); // DjinnKahn's workings.\n    //return length(p - b*h)*sign(determinant(mat2(b, p))); // JT's workings.\n}\n*/\n\n///////////////////////////\nvec3 gRd; // Global ray variable.\nfloat gCD; // Global cell boundary distance.\n\n// Used to store some useful distance function values for later use.\nvec4 gVal;\n\n \n// The scene's distance function.\nfloat m(vec3 p){\n    \n\n    // 2D cross local coordinates and ID. The global 2D distance \n    // is recorded too.\n    vec4 h4 = getGrid(p.xy);\n    \n    vec2 q = h4.xy;\n    vec2 cellID = h4.zw;\n  \n    float d;\n    float h;\n    float rCDiv;\n    \n    \n    // Subdividing the cross into heptagons, and returning\n    // the vertices.\n    \n    #define vNum 12\n    vec2[vNum] v = gCList;\n    int start;\n\n    \n    float d2 = gD; //bndCross(q, scale) + .005;\n    \n    int sInd = 0;\n    if(hash21(cellID)<.5){ sInd = 3; }\n    float divLn = distLineS(q, v[sInd], v[sInd + 6]);\n    \n    int n;\n    if(divLn<0.){\n        // Heptagon 1.\n        d2 = smax(d2, divLn, .02); // Smooth maximum, for a bit of rounding.\n        \n        //polyID = 0;\n       \n        vec2 offs = v[sInd].yx*vec2(-1, 1);\n        //d2 = max(d2, -(length(q - offs*scale) - .01));\n        \n        // Moving the position based ID to somewhere resembling the \n        // center of mass, in order to distribute the height better.\n        cellID += offs*2.;\n\n        // Raytracing out to the new boundary.\n        rCDiv = rayLineSeg(q, gRd.xy, v[sInd + 6], v[sInd]);\n        start = sInd + 6;\n    }\n    else{\n        // Heptagon 2.\n        d2 = smax(d2, -divLn, .02);\n        \n        //polyID = 1;\n        \n        vec2 offs = v[sInd + 6].yx*vec2(-1, 1);\n        //d2 = max(d2, -(length(q - offs*scale) - .01));\n        \n        // Moving the position based ID to roughly the center of mass\n        // of the heptagon object.\n        cellID += offs*2.;\n        \n        // Raytracing out to the new boundary.\n        rCDiv = rayLineSeg(q, gRd.xy, v[sInd], v[sInd + 6]);\n        start = sInd;\n\n    }\n    \n    // Putting in some tiny gaps.\n    d2 += .001;\n    \n    // Adding the slits onto the faces.\n    //if(hash21(cellID + .3)<.5) \n    d2 = max(d2, -(d2 + scale.x*.185));\n \n    \n    // Height value for this cell.\n    h = hm(cellID*scale/32.);\n    h = h*2. + .05;\n    // Extrusion.\n    d = opExtrusion(d2, p.z, h, .01);// - smoothstep(.03, .25, -d2)*.1; \n\n    //mat2 m = rot2(atan(1., 3.));\n    //vec2 si = vec2(1, 1./3.)*sqrt(9./10.)*scale/2.;\n    //float d2 = (sdCross(gP, si - .05, 0.)) - .05 + .005;\n    //d2 = max(d2, length(q) - sqrt(9./10.)*scale.x/2. + .005);\n    //float d2 = length(q) - sqrt(9./10.)*scale.x/6.;//\n    \n    // Back plane with a slight triangle cell bevel.\n    float fl = -p.z;// - min(-tr3.z*4., .2)*.05;\n   \n    d += smoothstep(0., .1, abs(fract((p.z + h)*8. + .15) - .5) - .35)*.005;\n    d += max(d2, -.03)*.25;// + d2*.05;\n    \n    //fl += max(d2, -.03)*.25;\n    ///////////\n    \n    // Tracing out a ray from the current cell position in the direction of\n    // the unit direction ray to the cell wall. This will be used as a \n    // ray jump delimiter.\n    gCD = 1e5;\n    \n    // Relative starting position. Adding \"cellID*scale\" to the vertices\n    // would work too.\n    ///vec2 pos = gP.xy - cellID*scale;\n    vec2 pos = q; // If returning relative coordinates.\n    // Iterate through all six sides of the hexagon cell.\n    for(int i = start; i<start + 6; i++){\n    \n       \n       //float rC = rayLine(gP.xy, gRd.xy, v[i], \n       //                   normalize(v[i] - v[(i + 1)%vNum]).yx*vec2(1, -1));\n  \n       // rayLineSeg(vec2 ro, vec2 rd, vec2 a, vec2 b);\n       float rC = rayLineSeg(pos, gRd.xy, v[i%vNum], v[(i + 1)%vNum]);\n\n       \n       // Minimum of all distances, plus not allowing negative distances, which\n       // stops the ray from tracing backwards... or something like that.\n       gCD = min(gCD, rC);\n         \n    }\n    \n    // Overall minimum distance.\n    gCD = max(min(gCD, rCDiv), 0.) + .0015;\n     \n    // Recording some values to be used later.\n    gVal = vec4(d, d2, cellID);\n    ///////////\n    \n   \n    // Object ID.\n    objID = fl<d? 0 : 1 ;\n    \n    // Minimum distance for the scene.\n    return min(fl, d);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash21(r.xy*57. + fract(iTime + r.z))*.5;\n    \n    gRd = rd; // Set the global ray  direction varible.\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += min(d*.9, gCD); \n    }\n\n    return min(t, FAR);\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(min(d, gCD), .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -2.5), l = o + vec3(-1.5, -1, 0);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.6)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n \n    // Precalculate the cross cell vertices.\n    crossVertices();\n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n \n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    int svCID = gCID;\n    \n    vec4 svVal = gVal;\n    \n    c = vec4(0);\n    \n    if(t<FAR){\n    \n    \n        // Very basic lighting.\n        // Hit point and normal.\n        vec3 p = o + r*t, n = nr(p); \n\n\n        // UV texture coordinate holder.\n        vec2 uv = p.xy;\n   \n\n\n        vec4 col1 = vec4(1, .15, .4, 0);\n        vec4 col2 = vec4(.4, .7, 1, 0);\n\n        /*\n        // Extra color. Interesting, but it makes things look creepily anatomical. :)\n        vec2 fID = floor(triID + .5);\n        if(mod(fID.x, 2.)<.5) col1 *= vec4(1, 2.35, 1.5, 0);\n        if(mod(fID.y, 2.)<.5) col1 *= vec4(2, 1.5, 1, 0);\n        if(mod(fID.x, 2.)<.5) col2 *= vec4(1, 1.15, .9, 0).zxyw;\n        if(mod(fID.y, 2.)<.5) col2 *= vec4(1.15, 1, .9, 0).zxyw; \n        */\n\n        // Object color.\n        vec4 oCol;\n\n\n        // Use whatever logic to color the individual scene components. I made it\n        // all up as I went along, but things like edges, textured line patterns,\n        // etc, seem to look OK.\n        //\n        if(gObjID == 0){\n\n           // The floor. It's not really visible here, but included\n           // for completeness.\n           oCol = vec4(.05);\n\n\n        }\n        else {\n\n            // Extruded heptagon pattern.\n          \n            // Random colors.\n            float rnd = hash21(svVal.zw + .1);\n            vec3 sCol = .5 + .45*cos(6.2831853*rnd/4. + vec3(0, 1, 2));\n            \n            \n          \n            // Two crosses per cell, so multiply by two for a checkered pattern.\n            //float check = mod(floor(svVal.z*2.) + floor(svVal.w*2.)*2., 2.);\n            float check = svCID == 0? 0. : 1.;\n            \n            //oCol.xyz = vec3(1);\n            float rnd2 = hash21(svVal.zw + .2);\n            if(rnd2<.35) oCol.xyz = mix(sCol, sCol.xzy, .0);\n            //else if(rnd2<.5) oCol.xyz = mix(sCol, sCol.xzy, .333);\n            else oCol.xyz = vec3(1)*dot(sCol.xyz, vec3(.299, .114, .587));\n            \n            // Debug: Show crosses.\n            //if(check<.5) oCol.xyz = vec3(.2);\n            //else oCol.xyz = vec3(.9);\n            \n            //oCol.xyz = getTex(iChannel1, svVal.zw*scale/32.); //32.\n            //oCol.xyz = smoothstep(0., .5, oCol.xyz);\n            //oCol.xyz *= 2.;\n            \n            // Metallic texture coloring.\n            oCol.xyz *= tex3D(iChannel1, p/2., n) + .05;\n\n        }\n\n\n        // Basic point lighting.   \n        vec3 ld = l - p;\n        float lDist = length(ld);\n        ld /= lDist; // Light direction vector.\n        float at = 3./(1. + lDist*lDist*.125); // Attenuation.\n\n        float sh = softShadow(p, l, n, 8.); // Shadows.\n        float ao = calcAO(p, n); // Ambient occlusion.\n\n        float df = pow(max(dot(n, ld), 0.), 4.)*2.; // Diffuse.\n        float sp = pow(max(dot(reflect(r, n), ld), 0.), 16.); // Specular.//reflect(r, n)\n \n\n        // Specular reflection.\n        vec3 hv = normalize(ld - r); // Half vector.\n        vec3 ref = reflect(r, n); // Surface reflection.\n        vec4 refTx = texture(iChannel2, ref.yzx*vec3(1, -1, 1)); refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, n), 0.), 5.); // Specular reflection.\n        float rf = (gObjID == 0)? .1 : 1.;\n        oCol = oCol*.5 + oCol*spRef*refTx*rf*8.;\n\n\n        // Apply the lighting and shading. \n        c = oCol*(df*sh + vec4(1, .7, .4, 1)*sp*sh*8. + .35)*at*ao;\n    \n    }\n    \n     \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}","name":"Image","description":"","type":"image"}]}