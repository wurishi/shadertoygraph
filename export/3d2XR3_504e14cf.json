{"ver":"0.1","info":{"id":"3d2XR3","date":"1554516528","viewed":157,"name":"Water flow with FBM","username":"toridango","description":"Experiments with Fractional Brownian Motion to simulate water flow\nTried adding reflections but not satisfied with the result","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// pseudo random\nfloat random (vec2 st)\n{\n    return fract(\n        sin(dot(st.xy,vec2(12.9898,78.233))) \n        * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    // integer part\n    vec2 i = floor(p);\n    // fractional part\n    vec2 f = fract(p);\n    \n    float ul = random(i); // + vec2(0.0, 0.0)\n    float ur = random(i + vec2(1.0, 0.0));\n    float ll = random(i + vec2(0.0, 1.0));\n    float lr = random(i + vec2(1.0, 1.0));\n    \n    // mix(x, y, a): lerp between x and y using a: x*(1âˆ’a) + y*a\n    float u = mix(ul, ur, f.x);\n    float l = mix(ll, lr, f.x);\n    \n    float n = mix(u, l, f.y);\n            \n    return n;\n}\n\n\nfloat brownian(vec2 p)\n{\n    int numOctaves = 3;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n\n    float lacunarity = 2.0;\n    float gain = 0.5;\n\n    float result = 0.0;\n    for(int i; i < numOctaves; i++)\n    {\n        result += noise(frequency * p) * amplitude;\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    return result;\n}\n\nfloat getHeight(vec2 p)\n{\n    \n    float b1 = brownian(p)+iTime/1.3;\n    float b2 = brownian(1.2*p);\n\t\n    float fbm1 = brownian(vec2(iTime+p.x, iTime+p.y));\n    float fbm1slow = brownian(vec2(iTime*0.3+p.x, iTime*0.3+p.y));\n\tfloat fbm2 = brownian(vec2(b1, b2));\n\n    \n    return fbm1+fbm1slow+fbm2;\n}\n\nvec3 getNormal(vec2 fragCoord, float zoom)\n{\n    vec3 normal;\n    vec2 thisp = (fragCoord/iResolution.xy) * zoom;\n    vec2 p2    = ((fragCoord + vec2(1.0,0.0))/iResolution.xy) * zoom;\n    vec2 p3    = ((fragCoord + vec2(0.0,1.0))/iResolution.xy) * zoom;\n    \n    /*vec3 thisv \t= vec3(fragCoord.x, \t\tgetHeight(thisp), \tfragCoord.y\t\t\t);\n    vec3 v2 \t= vec3(fragCoord.x + 1.0, \tgetHeight(p2), \t\tfragCoord.y\t\t\t);\n    vec3 v3 \t= vec3(fragCoord.x, \t\tgetHeight(p3), \t\tfragCoord.y + 1.0\t);*/\n    vec3 thisv \t= vec3(thisp.x, getHeight(thisp), thisp.y\t\t\t);\n    vec3 v2 \t= vec3(p2.x, getHeight(p2), p2.y);\n    vec3 v3 \t= vec3(p3.x, getHeight(p3), p3.y);\n    \n    vec3 Vec1 = thisv - v3;\n    vec3 Vec2 = v3 - v2;\n    \n    normal = normalize(cross(Vec1, Vec2));\n    \n    return normal;\n}\n\n\n\nvec3 lightDirection = vec3(0.4, -0.5, 0.4);\nvec3 viewDirection = vec3(0.35, -1.0, 0.5);\nfloat specularPower = 32.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float zoom = 25.0;\n\tvec2 p = zoom * uv;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 dark = vec3(0.1, 0.15, 0.3);\n    vec3 light = vec3(0.1, 0.25, 0.75);\n    \n    float b1 = brownian(p)+iTime/1.3;\n    float b2 = brownian(1.2*p);\n\t\n    float fbm1 = brownian(vec2(iTime+p.x, iTime+p.y));\n    float fbm1slow = brownian(vec2(iTime*0.3+p.x, iTime*0.3+p.y));\n\tfloat fbm2 = brownian(vec2(b1, b2));\n    \n    \n    \n    vec3 colour1 = mix(dark, light, fbm1);\n    vec3 colour1slow = mix(dark, light, fbm1slow);\n    vec3 colour2 = mix(dark, light, fbm2);\n    \n    vec3 colour = clamp(colour1 + colour2, 0.0, 1.0);\n    vec3 colour3 = mix(dark, light, getHeight(p));\n\n    vec3 lightDir = normalize(-lightDirection);\n    vec3 normal = getNormal(fragCoord, zoom);\n    float lightIntensity = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    vec3 reflection = normalize(2.0 * lightIntensity * normal - lightDir);\n    float specular = pow(clamp(dot(reflection, viewDirection), 0.0, 1.0), specularPower);\n    \n    \n    \n    // Output to screen\n    //fragColor = vec4(clamp(colour3, 0.0, 1.0),1.0);\n    fragColor = vec4(clamp(colour3 - vec3(0.1,0.1,0.1)*specular, 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(colour3 + vec3(0.1,0.1,0.1)*specular, 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(colour3 + mix(dark, light, specular), 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(vec3(1.0,1.0,1.0)*specular, 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(normal, 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(getNormal(fragCoord, zoom), 0.0, 1.0),1.0); // Normals visualised look cool\n}","name":"Image","description":"","type":"image"}]}