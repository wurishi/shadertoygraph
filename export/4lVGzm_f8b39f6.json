{"ver":"0.1","info":{"id":"4lVGzm","date":"1473891485","viewed":166,"name":"Hypercomplex Exp #1","username":"Aspect","description":"hypercomplex systems experiments... didn't work out too well so I figured I should pretend it's artistic instead","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","hypercomplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 gradient=vec3(0.0);\nfloat orbitno=0.0;\nvec3 grad=vec3(1.0);\n vec3 xdir=vec3(1.0,0.0,0.0);\n    vec3 ydir=vec3(0.0,1.0,0.0);\n    vec3 zdir=vec3(0.0,0.0,1.0);\n#define PI 3.1415926535\n\nvec3 hsquare(vec3 w)\n{\n vec3 new=vec3(0.0);   \n     new.x=w.x*w.x -1.* (w.y*w.y)+2.*w.y*w.z;\n        new.y= 2.*w.x*w.y- w.z*w.z  ;\n        new.z= 2.*w.x*w.z;\t\n    w=new;\n    return w;\n\n}\n\nvec3 mulpl(vec3 a,vec3 b)\n{\n vec3 new=vec3(0.0);\n    \n   new.x= a.x*b.x- a.y*b.y   - a.z*b.z + a.z*b.y;\n    new.y= a.x*b.y + a.y*b.x;\n    new.z= a.x*b.z + a.z*b.x+ a.y*b.z;\n    \n    return new;\n}\n\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\n\n//from iq's raymarching primitives\n\nvec2 box( vec3 p, vec3 b)\n{\n  //  mat4 rotmat=rotationMatrix(p,10.1*cos(iTime));\n  //  p=(rotmat*vec4(p,1.0)).xyz;\n //   b=b*2.;\n //   p=p*1.0;\n return vec2(length(max(abs(p)-b,0.0))-0.0,-44.0);\n}\n\n\n\nfloat mandel(vec3 pos)\n{\n    float dr=1.0;\n    pos=rotate(pos,cos(0.35*iTime),sin(0.35*iTime),0.0);\n    pos=pos*1.00;\n    float r=1.0;\n    vec3 zeta= pos;\n    vec3 w=pos;\n    float wr=2.0;\n    vec2 mdb=vec2(0.0);\n    vec3 c= vec3(0.0);\n    grad=vec3(1.0);\n    \n    for(int i=0;i<10;++i)\n    {\n        w=rotate(w,15.*cos(0.05*iTime),45.*sin(0.05*iTime),1.);\n      // w=w*(abs(cos(4.*iTime)/24.)+0.8);\n        //c=vec3(cos(iTime),sin(iTime),0.0);\n\n            wr=length(w);\n           if(((wr*wr>2.0)))\n        {\n            orbitno=float(i);\n\n             break;\n        }\n        \n        vec3 new=vec3(0.0);\n                grad=4.*mulpl(mulpl(mulpl(w,w)-w,mulpl(w,w)-w),2.*mulpl(grad,w)-w)+vec3(1.0,1.0,1.0);\n\n        w=mulpl(mulpl(w,w)-w,mulpl(w,w)-w);\n      // w=mulpl(w,w);\n      // w=mulpl(w,w);\n     // w=hsquare(w);\n\n        \n         w+=1.*(pos);     \n\n    }\n      \n    return wr;\n}\n\n\nfloat manDE(vec3 pos)\n{\n    float epsilon=0.0001;\n    orbitno=0.0;\n   float rad=mandel(pos);\n   \n    return 0.5*rad*log(rad)/length(grad);\n}\n\n\nfloat distfunc(vec3 pos)\n{  \n  //return min(box(pos,vec3(0.9,0.9,0.9)),mandel(pos));\n // return mandel(pos);\n    return manDE(pos);\n\n}\n\nvec2 distfunc2(vec3 pos)\n{  \n  return box(pos,vec3(1.05,1.05,1.1));\n//  return mandel(pos);\n //   return manDE(pos);\n\n}\n\n\nvec3 rayMarch2(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 10; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        dist = distfunc2(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n\nvec3 rayMarch(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    for (int i = 0; i < 150; i++)\n    {       \n        if ((dist.x < EPSILON))   continue;   \n        dist.x = distfunc(pos);\n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\nvec3 shadMarch(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 70; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist.x= distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n//https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nvec3 calculateNormal(float EPSILON, vec3 pos,in vec2 dist)\n{\n  \tvec2 eps = vec2(0.0, EPSILON);\nvec3 normal = normalize(vec3(\n    distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n   distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n    distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n      \t//vec2 eps = vec2(0.0, EPSILON);\n//\tvec3 normal = normalize(vec3(\n  //  distfunc(pos + eps.yxx).x -dist.x,\n  // distfunc(pos + eps.xyx).x - dist.x,\n  //  distfunc(pos + eps.xxy).x - dist.x));\n    \n    return normal;\n}\n\n\n\nvoid getRay(vec2 screenPos,out vec3 cameraOrigin,out vec3 rayDir)\n{\n    cameraOrigin = vec3(0.0+0.0*cos(iTime), 0.0+0.0*sin(iTime), 1.9+0.0*cos(iTime));  \n    vec3 cameraTarget = vec3(0.0, 0.0, 1.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(cameraDir,upDirection));\n\tvec3 cameraUp = normalize(cross(cameraRight,cameraDir));\n    rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n   //rayDir=normalize(cameraDir+vec3(screenPos,0.0));\n                  \n\n\n}\n\n\nvec4 render(vec2 ScreenPos)\n{\n    vec3 rayDir=vec3(0.0);\n    vec3 pos=vec3(0.0);\n    getRay(ScreenPos,pos,rayDir);\n    \n \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0; \n    float EPSILON = 0.001;\n    float totalDist = 0.0;\n    vec2 dist = vec2(EPSILON,0.0);\n    vec3 lightpos=vec3(5.0,5.0,5.0);\n\n    //initial march towards objects\n    vec3 dummypos=pos;\n \tpos=rayMarch2(dummypos,rayDir,EPSILON,dist);\n             if (dist.x <EPSILON)\n        {  \n               vec3 color=vec3(0.0);\n\n        vec2 dist = vec2(EPSILON,0.0);\n\t\t\t\t\n   \t\t\t pos=rayMarch(pos,rayDir,EPSILON,dist);\n   \t\t\t\t\n            \n            if (dist.x <EPSILON)\n     \t\t\t{  \n\n\t\t\n\n                EPSILON=0.5;\n\n             pos=pos-0.0001*rayDir;\n            vec3 normal=calculateNormal(EPSILON,pos,dist);\n\t\t\t//\tvec3 normal=normalize(grad);\n\n            vec3  lightdir=   normalize(lightpos-pos);  \n            vec3 halfvec= normalize(lightdir-rayDir);\n            vec3 reflected= normalize(reflect(rayDir,normal));\n\n\n                 //shadow ray \n          //  EPSILON=0.005;\n          //  vec2 shadowdist=vec2(EPSILON,dist.y);\n         //   vec3 shadowpos=shadMarch(pos+0.01*lightdir,lightdir,EPSILON,shadowdist);\n         //   if(shadowdist.x<EPSILON)\n        //    {\n         //      color=vec3(0.0,0.0,0.0);\n\n         //   }\n         //   else\n            {\n\n        \n        \n   \n        \n    float diffuse = max(0.0, dot(lightdir, normal));\n       \n    float specular = pow(dot(normal,halfvec), 16.0);\n        \n        \n        // diffuse=1.0;\n      //  specular=1.0;\n  //      vec3 colz=vec3(0.0);\n     //   colz.x=texture(iChannel0,512.*vec2(5.0,5.0)).x;\n    //            colz.y=texture(iChannel0,512.*vec2(415.0,315.0)).y;\n   //     colz.z=texture(iChannel0,512.*vec2(125.0,625.0)).z;\n\n//            color = vec3(colz*(diffuse + specular));\n\n   // color = vec3(vec3(0.15*fbm(pos*cos(iTime)),0.24*fbm(ScreenPos.xyx*sin(iTime)),0.55*fbm(pos))*(diffuse + specular)*2.1);\n     \n          //  color = vec3(vec3(0.2*noise(pos.xy*cos(iTime)),0.34*noise(ScreenPos.xy*sin(iTime)),0.55*noise(pos.xy))*(diffuse + specular)*14.1);\n\n \t\t\t// color = vec3(vec3(0.1,0.24,0.55)*(diffuse + specular));\n             color = vec3(vec3(0.1,0.24,0.55)*(diffuse + specular));\n                \n                           \n                vec3 bg=vec3(0.0,0.0,0.45);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.0*iTime)+1.55)))*bg;\n                       color+=bg*(orbitno/5.);\n//\n                   \n\n    \t\t}     \n             return vec4(color, 1.0);\n\n\t\t}\n            \n        \nelse{\n    vec3 bg=vec3(0.0,0.0,0.1);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.5*iTime)+1.25)))*bg;\n    return vec4(bg,1.0);\n}\n        }\n            else{\n                \n                vec3 bg=vec3(0.0,0.0,0.1);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.5*iTime)+1.25)))*bg;\n    return vec4(bg,1.0);\n            }\n            \n            \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{         \n\n \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n     screenPos.x *= iResolution.x / iResolution.y; \n\n    vec2 fc2=fragCoord.xy + vec2(-0.125, -0.375); \n\tvec2 fc3=fragCoord.xy + vec2(+0.375, -0.125);\n\tvec2 fc4=fragCoord.xy + vec2(+0.125, +0.375);\n    vec2 fc5=fragCoord.xy + vec2(-0.375, +0.125);\n    \n     vec2 scpos2=-1.0 +2.0*fc2.xy/iResolution.xy;\n     vec2 scpos3=-1.0 +2.0*fc3.xy/iResolution.xy;\n     vec2 scpos4=-1.0 +2.0*fc4.xy/iResolution.xy;\n     vec2 scpos5=-1.0 +2.0*fc5.xy/iResolution.xy;\n    \n    scpos2.x*=iResolution.x / iResolution.y;\n    scpos3.x*=iResolution.x / iResolution.y;\n    scpos4.x*=iResolution.x / iResolution.y;\n    scpos5.x*=iResolution.x / iResolution.y;\n    \n    \n  \n    fragColor=render(screenPos);\n  // fragColor+=render(scpos2)+render(scpos3)+render(scpos4)+render(scpos5);\n //   fragColor/=5.;\n\n}","name":"Image","description":"","type":"image"}]}