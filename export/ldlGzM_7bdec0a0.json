{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float time;\nvec2 t;\n\nvec3 rotateX(float a, vec3 v)\n{\n\treturn vec3(v.x, cos(a) * v.y + sin(a) * v.z,\n\t\t\t\tcos(a) * v.z - sin(a) * v.y);\n}\n\nvec3 rotateY(float a, vec3 v)\n{\n\treturn vec3(cos(a) * v.x + sin(a) * v.z, v.y,\n\t\t\t\tcos(a) * v.z - sin(a) * v.x);\n}\n\nvec2 rotate(float a, vec2 v)\n{\n\treturn vec2(cos(a) * v.x + sin(a) * v.y, cos(a) * v.y - sin(a) * v.x);\n}\n\n// Returns the distance from p to the nearest point on a square\n// of size 2 centered at the origin.\nfloat square(vec2 p)\n{\n\treturn length(max(vec2(0.0), abs(p) - vec2(1.0)));\n}\n\n// Returns two square-shaped masks, one defining the inner region\n// of a window and the other defining the outer region.\nvec2 window(vec2 p, vec2 o, vec2 s)\n{\n\tfloat s0 = square((p - o) / s);\n\tfloat s1 = square((p - o) / (s + 0.1));\n\treturn vec2(step(s0, 1e-3), step(1e-3, s1));\n}\n\n// Returns the line-segment intersection of a ray and a cube of\n// size 2 centered at the origin.\nvec2 cubeInterval(vec3 ro, vec3 rd)\n{\n\tvec3 slabs0 = (vec3(+1.0) - ro) / rd;\n\tvec3 slabs1 = (vec3(-1.0) - ro) / rd;\n\t\n\tvec3 mins = min(slabs0, slabs1);\n\tvec3 maxs = max(slabs0, slabs1);\n\t\n\treturn vec2(max(max(mins.x, mins.y), mins.z), min(min(maxs.x, maxs.y), maxs.z));\n\t\n}\n\n// Returns the line segment interval of the given ray with the scene's geometry,\n// scaled by sc (sc is the reciprocal of the geometry's scale).\nvec2 geom(vec3 ro, vec3 rd, float sc)\n{\n\treturn cubeInterval(ro * sc, rd * sc);\n}\n\n// Returns the image value of the scene (as seen through a window) at the \n// given coordinates.\nfloat scene(vec2 p, int i)\n{\n\tvec3 ro = vec3(0.0, 0.0, 3.0), rd = vec3(p, -1.0);\n\n\tfloat x = time + float(i);\n\tfloat y = time + float(i);\n\t\n\tro = rotateX(x, rotateY(y, ro));\n\trd = rotateX(x, rotateY(y, rd));\n\t\n\tvec2 ci0 = geom(ro, rd, 0.8);\n\tvec2 ci1 = geom(ro, rd, 0.74);\n\t\n\tfloat m0 = step(ci0.x, ci0.y);\n\tfloat m1 = step(ci1.x, ci1.y);\n\t\n\treturn mix(0.5, mix(0.0, 1.0, m0), m1);\n}\n\n// Returns the input value adjusted by a screenspace pattern.\nvec3 tonerise(float c)\n{\n\tvec2 p0 = rotate(-0.1, t.xy * 10.0);\n\tp0.x += 0.5 * mod(floor(p0.y), 2.0);\n\tvec2 p1 = fract(p0);\n\tc += step(distance(p1, vec2(0.5)), 0.4) * 0.07 * c;\n\treturn vec3(c);\n}\n\n// Returns a value representing the current scene configuration in it's\n// integer part and the transition stage in it's floating part.\nfloat transition()\n{\n\treturn time / 5.0 + 0.2;\n}\n\n// Takes an image value and returns a colour based on it. The colour\n// is chosen based on the current scene configuration.\nvec3 colourise(float c)\n{\n\tfloat d = mod(transition(), 3.0); \n\t\n\tvec3 f = mix(vec3(1.0, 1.0, 0.5),\n\t\t\t\t mix(vec3(1.0, 0.5, 1.0),\n\t\t\t\t\t vec3(0.5, 0.5, 1.0), step(2.0, d)), step(1.0, d));\n\t\n\treturn pow(tonerise(c), f);\n}\n\n// Takes a value representing a smoothened border around the final image\n// and uses it to create a mask formed of circles.\nfloat border(float d)\n{\n    d = clamp(d, 0.0, 1.0);\n\t\n\tvec2 p0 = rotate(0.1, t.xy * 9.0);\n\tp0.x += 0.5 * mod(floor(p0.y), 2.0);\n\tvec2 p1 = fract(p0);\n\t\n\treturn step(distance(p1, vec2(0.5)), d);\n}\n\n// Uses the transition value to mask out the final image so that scene configuration\n// switches (alterations to the colours) are not abrupt.\nfloat transitionMask()\n{\n\tfloat m = 1.0;\n\tfloat f = fract(transition());\n\tfloat h = 2.0 - (smoothstep(0.0, 0.05, f) - smoothstep(0.95, 1.0, f)) * 2.0;\n\t\n\tfor(int j = 0; j < 4; ++j)\n\t{\n\t\tvec2 p = rotate(float(j) * 9.0, vec2(0.4, 0.3));\n\t\tm = min(m, step(h, distance(t.xy, p)));\n\t}\n\t\n\treturn m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tt = uv * 2.0 - vec2(1.0);\n\tt.x *= iResolution.x / iResolution.y;\n\ttime = iTime;\n\t\n\tfloat b = 0.2;\n\t\n\t// Accumulate the 5 windows.\n\tfor(int i = 0; i < 5; ++i)\n\t{\n\t\tvec2 p = rotate(float(i) * 123.0, t.xy) * 1.8;\n\t\tfloat f = float(i) * 17.0 + floor(transition());\n\t\tvec2 o = vec2(cos(f) * 0.6, sin(f) * 0.7);\n\t\tvec2 s = vec2(0.5 + 0.2 * cos(f * 8.0), 0.5 + 0.2 * sin(f * 2.0));\n\t\tvec2 w0 = window(p, o, s);\n\t\t\n\t\tb = mix(mix(0.02, scene((p - o) * 2.0, i), w0.x), b, w0.y);\n\t}\n\t\n\tfloat v = clamp(1.0 - dot(t.xy, t.xy) * 0.3, 0.0, 1.0);\n\tfloat c = border(1.0 - pow(min(1.0, abs(t.x)), 4.0) - pow(min(1.0, abs(t.y)), 4.0));\n\t\n\tfragColor.rgb = colourise(b) * v * c * transitionMask();\n\tfragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldlGzM","date":"1366410757","viewed":1022,"name":"Arrangements","username":"fizzer","description":"An experiment in simple shapes with an almost-toon-shaded cube viewed though multiple windows.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["procedural","flat","windows","bold"],"hasliked":0,"parentid":"","parentname":""}}