{"ver":"0.1","info":{"id":"ctsBWs","date":"1693698989","viewed":31,"name":"Space Repetition Test","username":"DiogoMJP","description":"Using raymarching, displacement, and fract function to create an infinite space of repeating objects.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdf_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat smooth_min(float a, float b, float k) {\n    float h = a - b;\n    h = clamp(0.5 + 0.5*h/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nfloat get_distance(vec3 point) {\n    float displacement = sin(5.0*point.x) * sin(5.0*point.y) * sin(5.0*point.z) * 0.2;\n    float dist_1 = sdf_sphere(fract(point), vec3(0.5, 0.5, 0.5), 0.25);\n    \n    return dist_1 + displacement;\n}\n\nvec3 get_normal(vec3 point)\n{\n    vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = get_distance(point + small_step.xyy) - get_distance(point - small_step.xyy);\n    float gradient_y = get_distance(point + small_step.yxy) - get_distance(point - small_step.yxy);\n    float gradient_z = get_distance(point + small_step.yyx) - get_distance(point - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 get_light_value(vec3 point, vec3 normal) {\n    vec3 light_1_pos = vec3(0.0, 30.0, 0.0);\n    vec3 light_1_col = vec3(1.0);\n    vec3 light_2_pos = vec3(0.0, -30.0, 0.0);\n    vec3 light_2_col = vec3(1.0);\n    vec3 ambient_light = vec3(0.4);\n    \n    vec3 light_dir_1 = normalize(light_1_pos - point);\n    vec3 light_dir_2 = normalize(light_2_pos - point);\n    \n    float light_v_1 = max(0.0, dot(normal, light_dir_1));\n    float light_v_2 = max(0.0, dot(normal, light_dir_2));\n    \n    return ambient_light + light_v_1*light_1_col + light_v_2*light_2_col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord / iResolution.xy) - 1.0;\n    \n    float v_angle = 3.14519/4.0;\n    float h_angle = (iResolution.x/iResolution.y) * v_angle;\n    \n    // Origin\n    vec3 origin = vec3(10.0*sin(iTime/3.0), 10.0*sin(iTime/2.0), -4.0 + 2.0*iTime);\n    \n    // Unit Directional Vector\n    v_angle = uv.y*(v_angle/2.0);\n    h_angle = -uv.x*(h_angle/2.0);\n    vec3 v = vec3(sin(h_angle), sin(v_angle), 1.0 - pow(sin(h_angle),2.0) - pow(sin(v_angle),2.0));\n    \n    vec3 point = origin;\n    float dist;\n    do {\n        point += get_distance(point)*v;\n        dist = get_distance(point);\n    } while (dist > 0.001 && length(point - origin) < 20.0);\n    vec3 col;\n    if (dist < 0.001) {\n        vec3 normal = get_normal(point);\n        vec3 light_v = get_light_value(point, normal);\n        col = light_v * normal;\n    } else {col = vec3(0.0, 0.0, 0.0);}\n    \n    fragColor = vec4(col/max(0.5*length(point - origin), 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}