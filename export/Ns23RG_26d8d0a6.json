{"ver":"0.1","info":{"id":"Ns23RG","date":"1617570667","viewed":116,"name":"SDF showcase","username":"HardGaming","description":"Some testscene to showcase what Raymarching SDFs can do","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float InputX()\n{\n    return iMouse.x / iResolution.x;\n}\n\nfloat InputY()\n{\n    return iMouse.y / iResolution.y;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Demo Scenes\n\nfloat sdRoundingScene(vec3 p)\n{\n    //return sdSphere(p, InputX());\n    return sdBox(p, vec3(0.4, 0.3, 0.5)) - InputX() / 10.;\n}\n\nfloat sdEnlongationScene(vec3 p)\n{\n    return sdSphere(p, InputX());\n    return sdBox(opElongate(p, vec3(1, 0, 0) * InputX() / 3.).xyz, vec3(0.4, 0.3, 0.5));\n    return sdBox(opElongate(p, vec3(0, 1, 0) * InputX() / 3.).xyz, vec3(0.4, 0.3, 0.5));\n    return sdBox(opElongate(p, vec3(0, 0, 1) * InputX() / 3.).xyz, vec3(0.4, 0.3, 0.5));\n    \n    return sdSphere(opElongate(p, vec3(1, 0, 0) * InputX() / 3.).xyz, 0.5);\n    return sdSphere(opElongate(p, vec3(0, 1, 0) * InputX() / 3.).xyz, 0.5);\n}\n\nfloat sdCombinationScene(vec3 p)\n{\n    vec3 spherePos = vec3(p.x - InputX() * 2. + 1., p.y, p.z);\n    vec3 cubePos = vec3(p.x, p.y - InputY() * 2. + 1., p.z);\n\n    //return opUnion(sdBox(cubePos, vec3(0.2, 0.3, 0.5)), sdSphere(spherePos, 0.5));\n    //return opSubtraction(sdBox(cubePos, vec3(0.2, 0.3, 0.5)), sdSphere(spherePos, 0.49));\n    //return opIntersection(sdBox(cubePos, vec3(0.2, 0.3, 0.5)), sdSphere(spherePos, 0.5));\n    \n    //return opSmoothUnion(sdBox(cubePos, vec3(0.2, 0.3, 0.5)), sdSphere(spherePos, 0.5), 0.05);\n    return opSmoothSubtraction(sdBox(cubePos, vec3(0.2, 0.3, 0.5)), sdSphere(spherePos, 0.5), 0.05);\n    return opSmoothIntersection(sdBox(cubePos, vec3(0.2, 0.3, 0.5)), sdSphere(spherePos, 0.5), 0.05);\n    \n    //3 combination\n    return \n    opSmoothUnion(\n    opSmoothUnion(\n    sdBox(cubePos, vec3(0.2, 0.3, 0.5)), sdSphere(spherePos, 0.5), 0.05),\n    sdSphere(vec3(p.x -0.5, p.y -0.2, p.z), 0.3), 0.05);\n\n}\n\nfloat map(vec3 p)\n{\n    //return sdRoundingScene(p);\n    return sdCombinationScene(p);\n    return sdEnlongationScene(p);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float Input = iTime;\n     // camera movement\t\n\tfloat an = 3.1415926 / 2.;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}