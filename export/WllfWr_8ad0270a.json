{"ver":"0.1","info":{"id":"WllfWr","date":"1596481824","viewed":225,"name":"Gbuffer and resolve sample","username":"Shcherbakov","description":"Результат написания кода во время первого стрима про gbuffer и resolve с освещением по Фонгу.\nStream: https://www.youtube.com/watch?v=NXemod5o-I8","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phong","gbuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.1, 0.1, 0.2);\nconst float EPS = 1e-3;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, 0, 4);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.2, 0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.35;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-5, -5, 10), vec3(-5, 5, 10), vec3(5, 5, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-5, -5, 10), vec3(5, 5, 10), vec3(5, -5, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(sin(iTime), -3, cos(iTime)));\n    \n    const int SAMPLES_COUNT = 4;\n    vec3 fullLighting;\n    for (int x = 0; x < SAMPLES_COUNT; ++x) {\n        for (int y = 0; y < SAMPLES_COUNT; ++y) {\n            vec2 uv = (fragCoord + vec2(x, y) / float(SAMPLES_COUNT) - iResolution.xy * 0.5)/iResolution.x;\n            vec3 viewVec = normalize(vec3(uv, 1.0));\n            fragColor = vec4(0.0);\n\n            float intersectionDist = FAR_INF;\n            vec3 intersectionColor;\n            vec3 intersectionPos;\n            vec3 intersectionNormal;\n            float intersectionSpecular;\n            for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n                float hitDist = ray_sphere_intersection(SPHERES[i], cameraPos, viewVec);\n                if (hitDist < intersectionDist) {\n                    intersectionDist = hitDist;\n                    intersectionColor = SPHERES[i].color;\n                    intersectionPos = cameraPos + viewVec * intersectionDist;\n                    intersectionNormal = normalize(intersectionPos - SPHERES[i].pos);\n                    intersectionSpecular = SPHERES[i].specular;\n                }\n            }\n\n            for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n                float hitDist = ray_triangle_intersection(TRIANGLES[i], cameraPos, viewVec);\n                if (hitDist < intersectionDist) {\n                    intersectionDist = hitDist;\n                    intersectionColor = TRIANGLES[i].color;\n                    intersectionPos = cameraPos + viewVec * intersectionDist;\n                    intersectionNormal = TRIANGLES[i].normal;\n                    intersectionSpecular = TRIANGLES[i].specular;\n                }\n            }\n\n            vec3 lighting = intersectionColor * SKY_COLOR;\n\n            bool shadow = false;\n            vec3 shadowCastPos = intersectionPos - SUN_DIR * 0.001;\n            for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n                float hitDist = ray_sphere_intersection(SPHERES[i], shadowCastPos, -SUN_DIR);\n                shadow = shadow || hitDist < FAR_INF;\n            }\n\n            for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n                float hitDist = ray_triangle_intersection(TRIANGLES[i], shadowCastPos, -SUN_DIR);\n                shadow = shadow || hitDist < FAR_INF;\n            }\n\n            if (!shadow) {\n                lighting += max(0.0, dot(intersectionNormal, -SUN_DIR)) * intersectionColor;\n                if (intersectionSpecular != 0.0)\n                    lighting += pow(max(0.0, dot(reflect(-SUN_DIR, intersectionNormal), viewVec)), intersectionSpecular);\n            }\n            fullLighting += lighting;\n        }\n    }\n    \n    fragColor.xyz = pow(fullLighting / float(SAMPLES_COUNT) / float(SAMPLES_COUNT), vec3(1.0 / 2.2));\n    \n    // Output to screen\n    //fragColor = vec4(vec3(intersectionDist) / 50.0, 1.0);\n    //fragColor = vec4(intersectionColor, 1.0);\n    //fragColor = vec4(intersectionNormal * 0.5 + 0.5, 1.0);\n}","name":"Image","description":"","type":"image"}]}