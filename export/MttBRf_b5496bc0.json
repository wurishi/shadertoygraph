{"ver":"0.1","info":{"id":"MttBRf","date":"1540570719","viewed":104,"name":"Dungeon!","username":"jkashimura","description":"Environment #2","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Shape{\n  float dist;\n  vec4 color;\n};\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.* s)) - s)));\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n//=======================\n\nShape environment(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  // Coordinate Systems\n  vec3 g = c; // Ground\n  vec3 l = c; // light\n  vec3 ga = c; //Gates\n  vec3 s = c; // Side\n  vec3 t = c; //torch\n  vec3 d = c; //door\n    \n  // Ground\n  vec4 gColor = vec4(1., 0.5, 0.5, 1.0);//purple\n  g.xy *= rot(radians(90.)); //rotate\n  g.y = abs(g.y) - 4.; //mirror\n  g.x = abs(g.x) - 4.5;//mirror\n\n  float ground = fBox(g+vec3(2.,0.,2.), vec3(0.25, 3.25, 2000000.75));\n  \n    \n  // light\n  vec4 lColor = vec4(0.,0.,0.,1.);//black\n  l.xy *= rot(radians(90.)); //rotate\n  l.zy *= rot(radians(90.)); //rotate\n  l.z = abs(l.x) - 5. ;//mirror\n  pMod1(l.y, 2.);//distance\n    \n  \n  \n  float light = fCylinder(l+vec3(1.6,0.9,2.1), 1.,1.); \n    \n  // Gates\n  vec4 gaColor = vec4(0.1, 0.1, 0.1, 1.); //grey \n  ga.z = abs(ga.z) + 5.; //mirror\n  ga.x = abs(ga.x) - cos(iTime)*2.8; //mirror\n  pMod1(ga.z, 8.);//distance\n  ga.xy *= rot(radians(90.));//rotate\n  float gates = fBox(ga+vec3(0.,3.,1.5), vec3(2., 1., 0.)); \n  gates = fOpUnionStairs(ground, gates, 1., 4.);\n    \n  float b1 = fBox(c-vec3(1.,0.,0.), vec3(0.5, 0.1, 0.7));\n  \n    \n  // Side \n  vec4 sColor = vec4(0., .0, .5, 1.0); //blue\n  s.x = abs(s.x) - 6.; //mirror\n  pMod1(s.z, 4.5); //distance\n  float side = fBox(s+vec3(3.,1., -5.), vec3(.2, 1.5, 7.)); \n  side = fOpUnionColumns(ground, side,1., 4.); \n    \n  //Torch\n  vec4 tColor = vec4(1.,0.,0.,1.); //red\n  t.y *= cos(sin(t.y*7.)*1.23);//stretch  \n  //t.z = abs(t.z);//mirror\n  t.x = abs(t.x)-2.8;//mirror\n  pMod1(t.z, 3.);//distance\n  float torch = sphere(t-vec3(0.,0.1,0.), .1);\n    \n  //door\n  s.x = abs(s.x) - 5.; //mirror\n  pMod1(d.z, 5.); //distance\n  float door = fBox(s+vec3(2.,1., 0.), vec3(.5, 0.25, 0.3));\n\n      \n  shape.dist = min(ground, gates);\n  shape.dist = min(shape.dist, side); \n  shape.dist = min(shape.dist, torch);\n  shape.dist = fOpDifferenceStairs(shape.dist, door, .3,2.);  \n    \n  shape.color = mix(shape.color, lColor, mixColors(light, shape.dist, 0.1));\n  shape.color = mix(shape.color, gColor, mixColors(ground, shape.dist, 0.1));\n  shape.color = mix(shape.color, gaColor, mixColors(gates, shape.dist, 0.5));\n  shape.color = mix(shape.color, sColor, mixColors(side, shape.dist, 0.3)); \n  shape.color = mix(shape.color, tColor, mixColors(torch, shape.dist, 1.)); \n\n  return shape; \n}\n\n\nShape map(vec3 c){\n  Shape enviro = environment(c);\n  return enviro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n \n  vec3 cam = vec3(0., 0., iTime*3.);\n  cam.xy *= rot(radians(90.));\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}