{"ver":"0.1","info":{"id":"DscBzS","date":"1697282014","viewed":31,"name":"RayMarching_zjx","username":"Zjx","description":"RayMarching_zjx","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PRECISION 0.01\n#define MAXTIMES 128\n#define TMIN  0.1\n#define TMAX  100.0\n#define AA 3\n\n// sign distance function\n// 空间一点位置，圆心，半径\nfloat SdfSphere(vec3 p, vec3 center, float r)\n{\n    return length(p - center) - r;\n}\n\nfloat SdfBox(vec3 p, vec3 center, vec3 size)\n{\n    //vec3 b = vec3(1.0);\n    vec3 d = abs(p - center) - size;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat SdfPlane(vec3 p)\n{\n    // p.y - plane ypos\n    return p.y - (-0.0);\n}\n\nvec2 SdfAll(vec3 p)\n{\n    // plane 0 sphere 1 box 2\n    vec2 r = vec2(0.0, SdfPlane(p));\n    float sdf = SdfSphere(p, vec3(-1.0, 1.0, 0.0), 1.0);\n    if(sdf <= r.y)\n        r = vec2(1.0, sdf);\n    sdf = SdfBox(p, vec3(2.0, 1.0, 0.0), vec3(1.0));\n    if(sdf <= r.y)\n        r = vec2(2.0, sdf);\n    sdf = SdfBox(p, vec3(0.0, 1.0, -2.0), vec3(4.0, 2.0, 0.1));\n    if(sdf <= r.y)\n        r = vec2(3.0, sdf);\n    return r;\n}\n\nvec2 FixUV(vec2 fragCoord)\n{\n    return (fragCoord - 0.5 * iResolution.xy) / (0.5 * min(iResolution.x,iResolution.y));\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float dx = 0.01;\n    vec2 v = vec2(dx, 0.0);\n    return normalize(vec3(\n    SdfAll(p+v.xyy).y - SdfAll(p).y,\n    SdfAll(p+v.yxy).y - SdfAll(p).y, \n    SdfAll(p+v.yyx).y - SdfAll(p).y));\n}\n\n// 返回前进距离\nvec2 RayMarching(vec3 ro, vec3 rd)\n{\n    float t = TMIN;\n    vec2 sdf = vec2(0.0);\n    for(int i = 0; i < MAXTIMES; ++i)\n    {\n        vec3 p = ro + t * rd;\n        sdf = SdfAll(p);\n        if(sdf.y < PRECISION)\n            return vec2(sdf.x, t);\n        t += sdf.y;\n        if(t > TMAX)\n            return vec2(-1.0, t);\n    }\n    return vec2(sdf.x, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    for(int m = 0; m < AA; m++)\n       for(int n = 0; n < AA; n++) \n       {\n           //vec2 offset = 2.*(vec2(float(m), float(n)) / float(AA) - 0.5);\n           vec2 offset = vec2(float(m)*0.5,float(n)*0.5);\n           vec2 uv = FixUV(fragCoord +  offset);\n           \n           //vec2 uv = FixUV(fragCoord);\n           //camera\n           //vec3 ro = vec3(6.0, 3.0, 6.0);\n           vec3 ro = vec3(6.0*cos(iTime), 4.0, 6.0*sin(iTime));\n           //vec3 ro = vec3(4.0, 4.0, 4.0);\n           \n           vec3 target = vec3(0.0, 1.0, 0.0);\n           vec3 zAxis = normalize(ro - target);\n           vec3 xAxis = normalize(cross(vec3(0.0, 1.0, 0.0), zAxis));\n           vec3 yAxis = normalize(cross(zAxis, xAxis));\n           vec3 rd = normalize(uv.x*xAxis + uv.y*yAxis + (-1.0)*zAxis);\n           \n           vec2 rm = RayMarching(ro, rd);\n           \n           vec3 result = vec3(0.0);\n           \n           vec3 floorColor = vec3(1.0);\n           //vec3 floorColor = vec3(2.0+sin(iTime), 2.0+1.0*sin(iTime), 2.0+1.0*cos(iTime));\n           //vec3 floorColor = vec3(vec2(fract(iTime)), 0.0);\n           \n           //vec3 light = vec3(5.0*cos(iTime), 5.0, 5.0*sin(iTime));\n           vec3 light = vec3(5.0, 10.0, 5.0);\n           \n           if(rm.x >= 0.0)\n           {\n               vec3 baseColor = vec3(0.0);\n               \n               vec3 p = ro + rm.y*rd;               \n               \n               if(rm.x == 0.0)\n               {\n                   baseColor = floorColor;\n                   //p = ro + (ro.y / -rd.y) * rd;\n                   //baseColor = vec3(fract(p.xx), 1.0);\n               }\n               else if(rm.x == 1.0)\n               {\n                   baseColor = vec3(1.0, 0.0, 0.0);\n               }\n               else if(rm.x == 2.0)\n               {\n                   baseColor = vec3(0.0, 1.0, 0.0);\n               }\n               else\n               {\n                   baseColor = vec3(1.0, 1.0, 0.0);\n               }\n               \n               // shadow \n               vec2 s = RayMarching(p - rd*0.01, normalize(light - p));\n               float shadowCoef = 0.0;\n               if(s.x >= 0.0)\n                   shadowCoef = 1.0;\n               \n               vec3 n = GetNormal(p);\n               float diff = clamp(dot(n, normalize(light - p)), 0.0, 1.0);\n               // * (1.0 - shadowCoef)\n               result = vec3(0.8 * baseColor * diff * (1.0 - shadowCoef) + 0.2 * baseColor);   \n               //result = vec3(shadowCoef);\n           }\n           else // 未击中物体\n           if(rd.y < 0.0)\n           {\n               vec3 p = ro + (ro.y / -rd.y) * rd;\n               vec3 baseColor = floorColor;\n               //vec3 baseColor = vec3(fract(p.xx), 1.0);\n               vec3 n = normalize(vec3(0.0, 1.0, 0.0));\n               float diff = clamp(dot(n, normalize(light - p)), 0.0, 1.0);\n               // * (1.0 - shadowCoef)\n               result = vec3(0.8 * baseColor * diff  + 0.2 * baseColor);\n           \n           }\n           /*\n           if(t < TMAX)\n           {\n               vec3 light = vec3(10.0, 15.0, 15.0);\n               vec3 p = ro + t*rd;\n               // shadow \n               float s = RayMarching(p, normalize(light - p));\n               float shadowCoef = 0.0;\n               if(s < TMAX)\n                   shadowCoef = 1.0;\n               \n               vec3 n = GetNormal(p);\n               float diff = clamp(dot(n, normalize(light - p)), 0.0, 1.0);\n               r = vec3(1.0 * diff * 0.8 * (1.0 - shadowCoef) + 0.2);\n           }\n           */\n           /*\n           else if(rd.y < 0.0)\n           {\n               r = vec3(0.5, 0.5, 0.0);\n               r = pow(r, vec3(0.4545));\n               color += vec3(r);\n               continue;\n           }\n           */\n           \n           result = pow(result, vec3(0.4545));\n           \n           color += result;\n       }\n       \n    color /= float(AA*AA);\n    \n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}