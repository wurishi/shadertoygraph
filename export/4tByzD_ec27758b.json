{"ver":"0.1","info":{"id":"4tByzD","date":"1507896506","viewed":177,"name":"Raymarching simple - 1st script","username":"CodingDuff","description":"First implementation of raymarching, Maybe some improvements are needed...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simpleraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**** Constants ****/ \n#define MAXIMUM_RAY_STEPS 255\n#define EPSILON 0.0001\n#define MIN_DIST 0.001\n#define MAX_DIST 300.0\n\nstruct PhongMaterial\n{\n    vec3 diffColor;\n    float spec;\n    bool receiveShadows;\n};\n\n    \n/**** Eye Vector ****/\n/**** uv -> [-1,1]^2, screenspace ****/\n/**** fov -> R, angle in degree   ****/\n/**** returns normalized direction vector through camera ****/\nvec3 getEyeVector(vec2 uv, float fov)\n{\n    float theta = tan(radians(fov/2.0));\n\treturn normalize(vec3(uv.x*theta, uv.y*theta, -1.0));\n}\n\n/**** View Matrix ****/\n/**** https://people.freedesktop.org/~idr/glu3/glu3_8h.html ****/\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 fp = normalize(cross(f, up));\n    vec3 u = cross(fp, f);\n    return mat4(\n        vec4(fp, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n/**** Distance field functions ****/\n/*** https://iquilezles.org/articles/distfunctions ***/\n/**** Sphere SDF ****/\nfloat sdfSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\n/**** RoundBox SDF ****/\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n/**** Smooth Interpolation ****/\n/*** https://iquilezles.org/articles/smin ***/\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n/**** Scene SDF ****/\nfloat sdfScene(vec3 p)\n{\n    float s = sdfSphere(p,((sin(iTime)/2.0)+1.0) );\n    float r = udRoundBox(p, vec3(.5), 0.01);\n    float x = p.y+2.0;\n    \n  \tfloat d = smin(r, s, 10.0);\n    \n    return min(d,x);\n}\n\n/**** Gradient estimated normal ****/ \n/*** https://en.wikipedia.org/wiki/Gradient ***/\nvec3 gradientNormal(vec3 p) \n{\n    return normalize(vec3(\n        sdfScene( vec3( p.x + EPSILON, p.y, p.z )) - sdfScene( vec3( p.x - EPSILON, p.y, p.z )),\n        sdfScene( vec3( p.x, p.y + EPSILON, p.z )) - sdfScene( vec3( p.x, p.y - EPSILON, p.z )),\n        sdfScene( vec3( p.x, p.y, p.z + EPSILON )) - sdfScene( vec3( p.x, p.y, p.z - EPSILON ))\n    ));\n}\n\n/**** Raymarching ****/\nfloat rayMarch(vec3 o, vec3 dir)\n{\n    // Create array of 2 float that store [0] -> current distance value, [1] ->  last distance value\n    vec2 dist = vec2(MIN_DIST,MIN_DIST);\n    \n    for(int i = 0; i < MAXIMUM_RAY_STEPS; i++)\n    { \n        // Get last dist point on the direction array\n        vec3 p = o + dir * dist.y;\n\n        // Determine minimal distance from all objects in the scene\n        dist.x = sdfScene(p);\n        \n        // Are we touching an object ?\n        if(dist.x < EPSILON)\n        {\n           // Yes so return last depth\n           return dist.y;\n        }\n        \n        dist.y += dist.x;\n        \n        // Is there any object in the scene ?\n        if(dist.y >= MAX_DIST)\n        {\n            return MAX_DIST;\n        }\n    }\n    \n    // All steps have been finished without object collision\n    // Then return max distance\n    return MAX_DIST;\n}\n\n/**** Determines Classic Phong lighting calculation ****/ \n/**** https://en.wikipedia.org/wiki/Phong_reflection_model ****/\nvec3 phongIllumination(PhongMaterial mat, vec3 p, vec3 viewDir)\n{\n    /*** Ambient Light ***/\n    vec3 k_a = vec3(1.0); // Ambient reflection constant\n    vec3 c_a = vec3(0.08) * k_a; // Ambient intensity color\n    \n    /*** One non-directionnal light ***/\n    vec3 p_1stLight = vec3(cos(iTime), 1.0, sin(iTime)) * 10.0; // 1st light position\n    vec3 i_1stLight = vec3(.8, .8, .8); // 1st light intensity\n    \n    /*** Angular calculations ***/\n    vec3 N = gradientNormal(p); // Calculate gradient normal\n    vec3 l = p_1stLight - p; // Light direction\n    vec3 L = normalize(l); // Normalized light direction\n    vec3 V = normalize(-viewDir); // Vector p to cam\n    vec3 R = normalize(reflect(-L, N)); // Reflect vector\n    \n    // Diffuse normal\n    vec3 k_d = mat.diffColor;\n    \n    /*** Diffuse ***/\n    float LN = clamp(dot(L, N), 0.0, 1.0);\n    \n    /*** Specular ***/\n    float kSpec = 256.0;\n    float RV = clamp(dot(R, V), 0.0, 1.0);\n    float spec = mat.spec * pow(RV, kSpec);\n    \n    /*** shadows ***/\n    if(mat.receiveShadows)\n    {      \n        vec3 ps = p + N * MIN_DIST * 200.0;\n        float sDist = rayMarch(ps, normalize(p_1stLight - ps));\n        if(sDist < length(ps - p_1stLight) ) k_d *= 0.2;\n    }\n    \n    /*** Attenuation ***/\n   \tfloat dl = length(l);\n    float c_1 = 0.1;\n    float c_2 = 0.0005;\n\tfloat c_3 = 0.000007;\n    \n    float fatt = min(1.0 / (c_1 + c_2*dl + c_3*dl*dl), 1.0);\n    \n    return c_a + i_1stLight * LN * k_d + spec;\n}\n\n/**** Main Function ****/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    /*** Centering ***/\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \tuv*=2.0;\n    uv-=1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    /*** Camera settings ***/\n    vec3 viewDir = getEyeVector(uv, 45.0);\n    vec3 camPos = vec3(0.68, 0.42, 0.60) * 5.0;\n    \n    /*** Camera Transformation ***/\n    mat4 viewToWorld = viewMatrix(camPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\t\n    /*** Raymarching ***/\n    float hitDist = rayMarch(camPos, worldDir);\n\n    /*** Didn't hit anything ***/\n    if ( hitDist > MAX_DIST - EPSILON ) {\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    \n    /*** Sphere mat ***/\n    PhongMaterial sMat;\n    sMat.spec = 0.8;    sMat.diffColor = vec3(0.0, 1.0, .4); sMat.receiveShadows = false;\n\n    /*** Plane mat ***/\n    PhongMaterial pMat;\n    pMat.spec = .0;    pMat.diffColor = vec3(0.176, 0.6, 0.584); pMat.receiveShadows = true;\n   \n    \n    /**** Lighting ***/\n    vec3 p = camPos + worldDir * hitDist;\n    \n    vec3 color;\n    \n    PhongMaterial mat;\n    if(p.y > -2.0+MIN_DIST)\n    {\n        mat = sMat;\n    }\n    else\n    {\n        mat = pMat;\n    }\n    color = phongIllumination(mat, p, worldDir);\n    \n    // vignetting\n//    color *= 1.0-length(uv) * 0.15,\n        \n    fragColor = vec4(color,1.0); \n}","name":"Image","description":"","type":"image"}]}