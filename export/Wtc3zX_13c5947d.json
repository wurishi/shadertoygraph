{"ver":"0.1","info":{"id":"Wtc3zX","date":"1576998322","viewed":237,"name":"NPR_Cool-to-warm shading","username":"lypion","description":"Non-photorealistic rendering, cool-to-warm shading, cartoon-like effect","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["nrp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n---Base---\n\t1. Inspired by Fundamental of Computer Graphics(4th Edition), page240.\n\t2. Based on the Simple 3D_sphere rendering:https://www.shadertoy.com/view/wsGSDG\n\n---Main Content---\n\t1. Non-photorealistic rendering:cool-to-warm shading. Surfaces facing in one direction\n\t   are shaded with a cool color, such as a blue, and surfaces facing in the opposite\n\t   direction are shaded with a warm color, such as orange. Overall this gives a cartoon-\n\t   like effect.\n*/\n\n#define LIGHT_AMBIENT vec3(0.2)\n\n\nvec3 CalDirectLight(DirectLight light, Intersection intersection, vec3 viewPos)\n{   \n    //diffuse\n    //warmth constant. use the dot product between light direction and intersection normal to\n    //calculate the warmth ratio. And map it to [0, 1]\n    float wc = 0.5f * (dot(-light.direction, intersection.normal)) + 0.5;\n    vec3 diffuse = wc * light.warmColor + (1.0 - wc) * light.coolColor;\n    \n    //specular\n    vec3 viewDirect = normalize(viewPos - (intersection.ray.origin + intersection.t * intersection.ray.direction));\n    vec3 h = normalize(-light.direction + viewDirect);\n    vec3 specular = intersection.material.specular * pow(max(0.0, dot(intersection.normal, h)), intersection.material.shininess);\n\t\n    return diffuse + specular;\n}\n\nvec3 RayTracing(Ray ray, DirectLight directLight, Camera camera)\n{\n    Material defultMat = Material(vec3(1.0), vec3(1.0), 0.0);\n    \n\tIntersection intersection = Intersection(ray, vec3(1.0, 0.0, 0.0), defultMat, RAY_MAX, false, false);\n    intersection = IntersectWithSphereFirst(intersection, sphere);    \n    intersection = IntersectWithPlaneFirst(intersection, plane);\n    \n    vec3 color = LIGHT_AMBIENT * intersection.material.ambient;\n    if(intersection.hasIntersect == true)\n    {\n        if(intersection.withOneIntersect)\n            return vec3(0.0);\n    \tcolor += CalDirectLight(directLight, intersection, vec3(0.0));\n        return color;\n    }\n    return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Frustum frustum = Frustum(2.0, 100.0);\n\tvec3 cameraPos = vec3(0.0, 4.0, 0.0);\n\tvec3 cameraTar = vec3(0.0, 4.0, -1.);\n\tCamera camera = Camera(cameraPos, cameraTar, vec3(0.0, 1.0, 0.0), frustum, \n                           80.0 / 180.0 * PI, iResolution.x / iResolution.y);\n    \n    vec3 spherePos = vec3(0.0, 4.1, -12.0);\n    \n    //translate the sphere from self space to world space\n    mat4 sphereTransform = CalWorld2ViewMatrix(camera) * Translate(spherePos); \n    sphere.position = vec3(sphereTransform * vec4(sphere.position, 1.0));  \n    //translate the plane from self space to world space\n    mat4 planeTransform = CalWorld2ViewMatrix(camera); \n    plane.point = (planeTransform * vec4(plane.point, 1.0)).xyz;\n\n    mat4 normalMat = planeTransform;\n    plane.normal = normalize((normalMat * vec4(plane.normal, 0.0)).xyz);\n    \n    vec3 direction = normalize(vec3(cos(iTime * 0.1) * 10.0, -abs(sin(iTime * 0.1)) * 10.0, cos(iTime * 0.1) * 10.0 - 12.));\n    vec3 warmColor = vec3(1.0, 0.5, 0.3);\n    vec3 coolColor = vec3(0.2, 0.2, 1.0);\n    DirectLight directLight = DirectLight(direction, coolColor, warmColor);      \n    directLight.direction = vec3(CalWorld2ViewMatrix(camera) * vec4(directLight.direction, 0.0)).xyz;\n    \n    Ray ray = GenerateRay(camera, uv);   \n    vec3 color = RayTracing(ray, directLight, camera);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//The nearest intersect distance\n#define RAY_MIN 0.0001f\n//The farest intersect distance\n#define RAY_MAX 1.0e20f\n\n#define PI 3.1415\n#define EdgeThreshold 1.5\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n    float tMIN;\n    float tMAX;       \n};\n    \nstruct DirectLight\n{\n\tvec3 direction;\n    //the color of the object is the combination of these two colors\n\tvec3 coolColor;\n    vec3 warmColor;\n};\n  \nstruct Material\n{\n    vec3 ambient;\n    vec3 specular;\n    float shininess;\n};\n    \nstruct Intersection\n{\n    Ray ray;\n    vec3 normal;\n    Material material;\n\tfloat t;\n    bool hasIntersect;\n    //whether the ray intersect with the object with only one intersection point\n    bool withOneIntersect;\n};\n    \nstruct Plane\n{\n\tvec3 point;\n    vec3 normal;\n    Material material;\n};\n    \nstruct Sphere\n{\n\tvec3 position;\n    Material material;\n    float radius;\n};\n    \nstruct Frustum\n{\n    //the distance between near plane and camera\n    float nearestPlane;\n    //the distance between far plane and camera\n    float farestPlane;\n};\n    \nstruct Camera\n{\n\tvec3 position;\n    vec3 target;\n    vec3 upGuide;   //the vector used to calculate the coordinate of camera, not the real up vector of camera\n    Frustum frustum;\n    float fov;\n    float aspectRatio;\n};\n\nmat4 Scale(vec3 param)\n{\n\treturn mat4(vec4(param.x, 0.0, 0.0, 0.0),\n                vec4(0.0, param.y, 0.0, 0.0),\n                vec4(0.0, 0.0, param.z, 0.0),\n                vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 Translate(vec3 param)\n{\n\treturn mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(param, 1.0));\n}\n\nmat4 Rotate(vec3 param)\n{\n\tmat4 xMat = mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                     vec4(0.0, cos(param.x), sin(param.x), 0.0),\n                     vec4(0.0, -sin(param.x), cos(param.x), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 yMat = mat4(vec4(cos(param.y), 0.0, -sin(param.y), 0.0),\n                     vec4(0.0, 1.0, 0.0, 0.0),\n                     vec4(sin(param.y), 0.0, cos(param.y), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 zMat = mat4(vec4(cos(param.z), sin(param.z), 0.0, 0.0),\n                     vec4(-sin(param.z), cos(param.z), 0.0, 0.0),\n                    vec4(0.0, 0.0, 1.0, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    return zMat * yMat * xMat;\n}\n\nmat4 CalWorld2ViewMatrix(Camera camera)\n{\n\tvec3 zDirec = normalize(camera.position - camera.target);\n    vec3 xDirec = normalize(cross(camera.upGuide, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 view2World = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0));\n\t\n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(-camera.position, 1.0));\n    return transpose(view2World) * translateMat;\n}\n\nmat4 CalView2WorldMatrix(Camera camera)\n{\n\tvec3 zDirec = normalize(camera.position - camera.target);\n    vec3 xDirec = normalize(cross(camera.upGuide, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 view2World = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0)); \n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(camera.position, 1.0));\n    return view2World * translateMat;\n}\n\nvec3 CalSphereNormal(Sphere sphere, vec3 point)\n{\n\treturn normalize(point - sphere.position);\n}\n\nSphere sphere = Sphere(vec3(0.0, 0.0, 0.0), Material(vec3(0.2), vec3(0.8), 256.0), 4.0);  \nPlane plane = Plane(vec3(0.0), normalize(vec3(0.0, 1.0, 0.0)), Material(vec3(0.2), vec3(0.5), 16.0));\n\nbool IsIntersectWithSphere(Ray ray, Sphere sphere)\n{\n\tvec3 temp = ray.origin - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.0)\n    {\n        float sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n            \n        if(t2 > ray.tMIN && t2 < ray.tMAX)\n       \t{\n            return true;\n        }\n        else if(t1 > ray.tMIN && t1 < ray.tMAX)\n        {\n        \treturn true;       \n        }\n    }        \n    return false;\n}\n\nbool IsIntersectWithPlane(Ray ray, Plane plane)\n{\n    float denominator = dot(ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return false;\n    \n    float t = dot((plane.point - ray.origin), plane.normal) / denominator;\n\n\tif(t > ray.tMIN && t < ray.tMAX)\n    {\n    \treturn true;\n    }\n    return false;\n}\n\nIntersection IntersectWithSphereFirst(Intersection intersection, Sphere sphere)\n{\n\tvec3 temp = intersection.ray.origin - sphere.position;\n    float a = dot(intersection.ray.direction, intersection.ray.direction);\n    float b = dot(intersection.ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.00001)\n    {\n    \tfloat sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n        \n        if(t1 - t2 < EdgeThreshold)\n        {\n            intersection.withOneIntersect = true;\n        }\n        \n        if(t2 > intersection.ray.tMIN && t2 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t2;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t2;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n            intersection.material = sphere.material;\n        }        \t\n        else if(t1 > intersection.ray.tMIN && t1 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t1;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t1;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n            intersection.material = sphere.material;\n        }        \t\n    }\n    return intersection;\n}\n\nIntersection IntersectWithPlaneFirst(Intersection intersection, Plane plane)\n{\n\tfloat denominator = dot(intersection.ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return intersection; \n    \n    float t = dot((plane.point - intersection.ray.origin), plane.normal) / denominator;\n    if(t > intersection.ray.tMIN && t < intersection.ray.tMAX && t < intersection.t)\n    {\n    \tintersection.t = t;\n        intersection.normal = plane.normal;\n        intersection.hasIntersect = true;\n        intersection.material = plane.material;\n    } \n    return intersection;\n}\n\nRay GenerateRay(Camera camera, vec2 uv)\n{\n    //map the center of the screen as the origin point\n\tuv -= vec2(0.5);\n    float halfHeight = tan(camera.fov / 2.0) * camera.frustum.nearestPlane;\n    vec3 pixelInViewSpace = vec3(0.0, 0.0, -camera.frustum.nearestPlane) + \n                 \t\t\tvec3(2.0 * uv.x * halfHeight * camera.aspectRatio, 0.0, 0.0) + \n                 \t\t\tvec3(0.0, 2.0 * uv.y * halfHeight, 0.0);\n    return Ray(vec3(0.0), normalize(pixelInViewSpace), RAY_MIN, RAY_MAX);\n}","name":"Common","description":"","type":"common"}]}