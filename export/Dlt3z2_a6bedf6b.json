{"ver":"0.1","info":{"id":"Dlt3z2","date":"1682761055","viewed":63,"name":"Sessions live jam 2023 shader","username":"Exca","description":"Shader made during Sessions live jam. I had no idea what I was doing ;D\nAlso audiosync not quite on point as I use a lot of fftIntegrated on bonzomatic.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sessions","jamming"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = texture(iChannel3, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float ffti = 0.0;\nfloat ffts = 0.0;\nfloat fft = 0.0;\n\nfloat txt(vec2 p,float t)\n{\n     vec2 i = vec2(abs(p)*128.);\n     return dot(sin(i),cos(i.yx*t))+(i.x+i.y)/128.;;\n}\n\nvec4 sessions(vec2 uv)\n{\n  uv = mod(uv, vec2(1.0));\n  uv -= 0.5;\n\t\n  float bpm=iTime;\n    \n    vec3 col =vec3(0.);\n    col.r= texture( \n        iChannel1\n        ,clamp(\n        uv*vec2(1.,-1.0)+.5+\n        texture(iChannel0,vec2(floor(bpm*10.0)*.1+txt(uv,1.)\n        ,0.5\n        )).r,\n        0.,\n        1.)\n    ).r;\n    col.gb= texture(iChannel2,clamp((uv*vec2(1.,-1)+.5)+texture(iChannel0,vec2(floor(bpm*10.0)*.1+txt(uv,2.),0.5)).r,0.,1.)).gb;\n    return vec4(col, length(col.rgb));\n}\n\nvec2 rot2d( float a, vec2 p)\n{\n  return mat2( cos(a), -sin(a), sin(a), cos(a)) * p;\n}\n\nfloat smin( float a, float b, float k)\n{\n  float h = clamp( 0.5 + 0.5 * (b - a ) / k, 0.0, 1.0);\n  float dist = mix(b,a,h) - k*h*(1.0-h);\n  return dist;\n}\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam);\n  vec3 right = normalize( cross( vec3( 0,1,0), forward));\n  vec3 up = normalize( cross(forward, right));\n  return normalize( forward*fov + uv.x * right + uv.y*up);\n}\n\nfloat sphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat octahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n \tvec3 q = abs(pos)-size;\n    return length(max(q,0.) + min(max(q.x, max(q.y, q.z)), 0.));\n}\nfloat ibox(vec3 pos, vec3 size)\n{\n \tvec3 q = size-abs(pos);\n    return length(max(q,0.) + min(max(q.x, max(q.y, q.z)), 0.));\n}\n\n\nvec3 unio( vec3 a, vec3 b){\n  if(a.x < b.x) return a;\n  return b;\n}\n\nvec3 map( vec3 p)\n{\n  float spSize = smoothstep(0.0, 0.1,ffts)*1.0;\n  \n  float s1 = sphere( p, 1.0+spSize*5.8);\n  float h1 = hexPrism(p, vec2( 0.5, 1.0+spSize*5.8));\n  float o1 = octahedron(p, 1.0+spSize*5.2);\n  \n  float bt = mod(ffti*5.0, 3.0)/3.0;\n  \n  o1 = mix( smin( \n    mix( o1, h1, smoothstep(0.0, 0.05,ffts)),\n    mix( s1, o1, smoothstep(0.0, 0.05,ffts)), \n    0.3\n  ),smin( \n    mix( o1, s1, smoothstep(0.0, 0.05,ffts)),\n    mix( h1, s1, smoothstep(0.0, 0.05,ffts)), \n    0.3\n  ),bt);\n  \n  \n  \n  float b1 = ibox(p, vec3(4.0,4.0,4.0)*4.0 );\n  \n  vec3 S1 = vec3(o1, 1.0, 0.0);\n  vec3 B1 = vec3(b1, 2.0, 0.0);\n  vec3 OBJ = unio(S1, B1);\n  return OBJ;\n}\n\nvec3 march(vec3 cam, vec3 rd, out vec3 p, out float t)\n{\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam + rd*t;\n    vec3 r = map(p);\n    t+=r.x;\n    if(r.x < 0.001)\n    {\n      return r;\n    }\n    if(t > 50.0){\n      t = 50.0;\n      return vec3(-1.0);\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 normal( vec3 p)\n{\n  vec3 c = map(p);\n  vec2 e = vec2(0.01, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  ) - c.x );\n}\nfloat light( vec3 p, vec3 l, vec3 n)\n{\n  return max(0.0, dot(n, normalize(l-p)));\n}\n\nvec3 col1 = vec3(1.0, 0.5, 0.0);\nvec3 col2 = vec3(0.0, 0.5, 1.0);\nvec3 col3 = vec3(0.25, 1.0, 0.25);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n\tvec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  vec2 ouv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  //FFT \n  ffti = texture(iChannel0, vec2(0.2,0.5)).r*0.0 +iTime*0.05;\n  ffts = texture(iChannel0, vec2(0.2,0.5)).r*0.05 + abs(sin(iTime)*0.010);\n  fft = texture(iChannel0, vec2(0.2,0.5)).r;\n  \n  \n  // Marching\n  vec3 c = vec3(0.0);\n  \n  // Cam\n  float spSize = smoothstep(0.0, 0.1,ffts)* smoothstep(0.0, 0.01,ffts)*50.0;\n  vec3 cam = vec3( \n    sin(ffti + mod(ffti*5.0,2.0))*3.0, \n    cos(ffti + mod(ffti*5.0,3.0))*3.0,\n    sin(ffti*0.3 + mod(ffti*5.0,4.0))*3.0\n  )*(1.0+0.5*spSize);\n  vec3 target = vec3( 0,0,0);\n  float fov = 1.0;\n  fov += smoothstep( 0.0, 0.25, sin(ffti))*3.0 - \n         smoothstep( 0.25, 0.5, sin(ffti))*-2.0 -\n         smoothstep( 0.75, 1.0, sin(ffti))*-0.4; \n         \n        fov = 1.3;\n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  \n  // Lights\n  vec3 light1 = vec3( sin( iTime) * 4.0, 4.0, 0.0);\n  vec3 light2 = vec3( sin( iTime*0.3) * 4.0, 4.0, cos(iTime*0.7) * 4.0);\n  vec3 light3 = vec3( sin( iTime*0.987) * 4.0, sin(iTime*1.4)* 4.0, cos(iTime*0.23) * 4.0);\n  \n  vec3 marchP = cam;\n  float marchT = 0.0;\n  vec3 res = march( cam, rd, marchP, marchT);\n  \n  if(res.y > 1.5){\n    // Cube\n    vec3 n = normal(marchP);\n    float l1 = light( marchP, light1, n);\n    float l2 = light( marchP, light2, n);\n    float l3 = light( marchP, light3, n);\n    c = col1 * l1 + col2 * l2 + col3 * l3;\n    c *= 1.0+ sessions(mod( 0.1*vec2( marchP.x+ marchP.y, marchP.z + marchP.x), vec2(1.0))).rgb;\n  }\n  else if(res.y > 0.5)\n  {\n    // Sphere\n    vec3 n = normal(marchP);\n    float l1 = light( marchP, light1, n);\n    float l2 = light( marchP, light2, n);\n    float l3 = light( marchP, light3, n);\n    c = col1 * l1 + col2 * l2 + col3 * l3;\n  }\n  else\n  {\n    // Bg\n  }\n  \n  // Feedback loop\n  ouv -=0.5;\n  ouv*0.9;\n  ouv +=0.5;\n  vec3 previous = texture(iChannel3, ouv).rgb;\n  \n  c = mix(c*0.5, previous*0.99+c*0.25, smoothstep(0.0, 0.045,ffts)*1.0);\n  \n  c+=sessions(mod(vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y) * sin(iTime) + iTime, vec2(1.0))).rgb*0.1;\n  \n\tfragColor = vec4(c,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}