{"ver":"0.1","info":{"id":"ftS3zV","date":"1624236031","viewed":172,"name":"Line Segment Sine Wave","username":"Yusef28","description":"You can change the number of segments and turn off display of segments in defines at top.\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["wave","line","sine","curve","segment","linesegments","fitting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define numSegments 54.\n#define showSeg\n#define PI 3.141592653589793238462643\n\n#define bgCol   vec3(185., 141., 94.)/255.*0.2;\n#define lineCol vec3(130., 144., 121.)/255.\n#define circleCol vec3(237., 227., 185.)/255.\n\n\nfloat dotLineDist(vec2 A, vec2 B, vec2 p){\n\n    vec2 pa = p - A;\n    vec2 AB = B - A;\n    \n    //clamp = segment!\n    float t = clamp(dot(pa, AB)/dot(AB,AB), 0., 1.);\n    \n    vec2 normal = pa - t*AB;\n    float dist = length(normal);\n   \n    return dist;\n}\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, circleCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col){\n    \n    float dist = dotLineDist(A,B,p);\n    dist = 1.0-smoothstep(0.004, 0.005, dist);\n    //dist = 1.0-smoothstep(0., fwidth(dist), dist - 0.004);\n    return mix(col, lineCol, dist);\n}\n\n\n//loopless version by oneshade using floor to create cells\n//because every point is fixed on the x axis\n//Just need to make it aligned to start and end of screen\n//for any number of segments.\nvec3 drawSegments(vec2 viewDim, vec2 uv) {\n    \n    float aspect = viewDim.x/viewDim.y;\n    vec3 col = bgCol;\n\n    float dt = aspect / numSegments;\n    uv.x += fract(0.5 * numSegments) * dt;\n    col = drawLine(vec2(0.0, -0.25), vec2(0.0, 0.25), uv, col);\n\n    float cell = floor(uv.x / dt) * dt;\n    vec2 p1 = vec2(cell, sin(2.25 * PI * cell + iTime) * 0.25);\n    vec2 p2 = vec2(cell + dt, sin(2.25 * PI * (cell + dt) + iTime) * 0.25);\n    col = drawLine(p1, p2, uv, col);\n\n    #ifdef showSeg\n    col = drawRing(0.01, 0.003, uv, p1, col);\n    col = drawRing(0.01, 0.003, uv, p2, col);\n    #endif\n\n    return col;\n}\n\n//Original version\n/*\n\nvec3 drawSegments(vec2 viewDim, vec2 uv){\n\n    float aspect = viewDim.x/viewDim.y;\n    vec3 col = bgCol;\n    float dx;\n\n    float dt;\n    vec2 lastPoint = vec2(-aspect/2.,sin(0.+iTime)*0.25);\n    \n    #ifdef showSeg\n    col = drawRing(0.01, 0.003, uv, lastPoint, col);\n    #endif\n    \n    float t = 0.;\n    for(float i = 0.; i <= numSegments; i++){\n        \n        dt = (i/numSegments);\n        t = 4.*PI*dt;\n        dx = (aspect*dt-aspect/2.);\n\n        vec2 newPoint = vec2(dx, sin(t+iTime)*0.25);\n        \n        col = drawLine(lastPoint, newPoint, uv, col);\n        \n        #ifdef showSeg\n        col = drawRing(0.01, 0.003, uv, newPoint, col);\n        #endif\n        \n        t+= numSegments;\n        lastPoint = newPoint;\n        \n    }\n    return col;\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    vec3 col = drawSegments(iResolution.xy,uv);\n   \n   //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig,1.0);\n}","name":"Image","description":"","type":"image"}]}