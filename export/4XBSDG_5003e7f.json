{"ver":"0.1","info":{"id":"4XBSDG","date":"1710981453","viewed":150,"name":"Walk On Cat Interpolation ","username":"chronos","description":"walk on spheres interpolation / reconstruction by walking on the grid lattice of pixel centers.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["spheres","image","interpolation","on","kernel","walk","reconstruction","wos","walkonspheres"],"hasliked":0,"parentid":"XXBSDG","parentname":"Walk On Spheres Kernel"},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Walk On Cat Interpolation by chronos\n    \n    \n    Just for fun! :D\n\n\n    Using walk on spheres interpolation (solving laplacian equation) to interpolate pixel centers of an image.\n    \n    What kind of kernel is it I hear you ask? \n    \n    No clue, maybe since it solves the laplace equation Î”f = 0,\n    it can be called harmonic interpolation?\n    https://en.wikipedia.org/wiki/Harmonic_function\n    \n    TODO: Resampling!\n*/\n\n\nvec3 nyan(vec2 grid_id)\n{\n    if(nyanbox(grid_id) > 0.5)\n    {\n        grid_id = (grid_id+vec2(3,0)+16.); \n        vec4 cat = texelFetch(iChannel1, ivec2(grid_id), 0);\n        return pow(cat.rgb, vec3(2.2)) * float(cat.a > 0.);\n    }\n    else\n    {\n        return border_color;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = zoom * (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = zoom * (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    float ps = zoom * 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    if(length(iMouse.xy) < 10.) mouse = vec2(3. * zoom * (smoothstep(2., 1., iTime) + smoothstep(3.5, 4.5, iTime)), 0);\n    \n    vec2 grid_id = floor(uv);\n    vec2 grid_center = grid_id + 0.5;\n    vec2 grid_uv = fract(uv);\n    \n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    if(bufA.a > 0.)\n        color = bufA.rgb / bufA.a;\n    \n    vec3 cat_color = nyan(grid_id).rgb;\n    \n    if(uv.x > mouse.x || iFrame == 0)\n    {\n        color = color * 0. + 0.001;\n        color = mix(color,  cat_color, smoothstep(ps, -ps,length(grid_center - uv) - .125));\n    }\n    \n    color = pow(clamp(color, 0., 1.), vec3(1./2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 nyan(vec2 grid_id)\n{\n    if(nyanbox(grid_id+vec2(.99, 0.)) > 0.5)\n    {\n        grid_id = (grid_id+vec2(3,0)+16.); \n        vec4 cat = texelFetch(iChannel1, ivec2(grid_id), 0);\n        return pow(cat.rgb, vec3(2.2)) * float(cat.a > 0.);\n    }\n    else\n    {\n        return border_color;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = zoom * (2. * fragCoord-iResolution.xy)/iResolution.y;\n    float ps = zoom * 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 grid_id = floor(uv);\n    vec2 grid_center = grid_id + 0.5;\n    vec2 grid_uv = fract(uv);\n\n    float hit_count = 0.;\n    \n    int num_walks = 1;\n    int max_steps = 20;\n    float threshold = 1e-4;\n    \n    for(int k = 0; k < num_walks; k++)\n    {\n        vec2 p = uv;\n        for(int i = 0; i < max_steps; i++)\n        {\n            vec2 cell_id = floor(p);\n            vec2 cell_center = cell_id + 0.5;\n            \n            float dist = length(p - cell_center) * nyanbox(p);\n\n            if(dist < threshold)\n            {   \n                color += nyan(cell_id);\n                hit_count += 1.;\n                break;\n            }\n\n            float rnd = hash(vec3(uv, 0) + vec3(k, i, iFrame));\n            float angle = 2. * PI * rnd;\n            vec2 circle_point = vec2(cos(angle), sin(angle)) * dist;\n\n            p += circle_point;\n        }\n    }\n    \n    //color = mix(color, vec3(val), smoothstep(ps, -ps, length(grid_center - uv) - .5));\n    \n    if(iFrame == 0)\n        fragColor = vec4(0);\n    else\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) + vec4(color, hit_count);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float zoom = 14.;\n\nconst float PI = 3.14159265;\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\nfloat nyanbox(vec2 p)\n{\n    return float(abs(p.x) < 22. && abs(p.y) < 14.); \n}\n\nvec3 border_color = vec3(0.1, 0.0, 0.1);","name":"Common","description":"","type":"common"}]}