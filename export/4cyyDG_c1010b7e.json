{"ver":"0.1","info":{"id":"4cyyDG","date":"1732311235","viewed":20,"name":"Ontwikkeling van het Internet ","username":"Mirtheamvm","description":"Ontwikkeling van het Internet (Late 20e eeuw)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["internet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader for \"Development of the Internet\" with unique digital tones representing connectivity and freedom, enhanced lighting, and new color variation for greater depth and differentiation from previous inventions.\n\n// User parameters\nuniform float tech_input;      // Technology input for sigmoid function\n// Time parameter for animation is defined globally, no redefinition needed           // Time parameter for animation\n// Resolution parameter for the shader is defined globally, no redefinition needed      // Resolution of the shader\n\n#define AA 2  // Set AA to 1 if your machine is too slow\n#define METHOD 3\n\n// Sigmoid function for technology growth\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// Function to compute the quaternion constant c based on the \"Development of the Internet\"\nvec4 computeC(float time) {\n    float health;\n    float freedom;\n    float interconnectivity;\n    float tech_factor = sigmoid(tech_input);\n\n    // CARE values for the \"Development of the Internet\"\n    if (time < 0.33) {  // Early phase\n        health = 5.0;\n        freedom = 4.0;\n        interconnectivity = 6.0;\n    } else if (time < 0.66) {  // Acceleration phase\n        health = 6.0;\n        freedom = 8.0;\n        interconnectivity = 9.0;\n    } else {  // Maturity phase\n        health = 7.0;\n        freedom = 8.0;\n        interconnectivity = 10.0;\n    }\n\n    // Normalize the CARE values and compute the quaternion constant\n    return vec4(\n        (5.0 + min(health, 8.5)) / 10.0 * (5.0 + min(freedom, 8.5)) / 10.0 * (5.0 + min(interconnectivity, 8.5)) / 10.0 * tech_factor,\n        0.8 * (5.0 + health) / 10.0 * sin(time * 0.7),\n        0.8 * (5.0 + freedom) / 10.0 * cos(time * 0.5),\n        0.8 * (5.0 + interconnectivity) / 10.0\n    );\n}\n\nvec4 qsqr(in vec4 a) {\n    return vec4(\n        a.x * a.x - a.y * a.y - a.z * a.z - a.w * a.w,\n        2.0 * a.x * a.y,\n        2.0 * a.x * a.z,\n        2.0 * a.x * a.w\n    );\n}\n\nconst int numIterations = 3000; // Higher number of iterations for richer detail\n\n// Function to map the fractal and limit bailout-radius to avoid disappearing\nfloat map(in vec3 p, out vec4 oTrap, in vec4 c, out float iteration) {\n    vec4 z = vec4(p, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    oTrap = vec4(abs(z.xyz), dot(z, z));\n\n    iteration = 0.0;\n    for (int i = 0; i < numIterations; i++) {\n        md2 *= 4.0 * mz2;\n        z = qsqr(z) + c;\n\n        // Add subtle noise for organic deformation\n        z.xyz += 0.15 * sin(7.0 * z.xyz + iTime * 0.03);\n\n        // Orbit trap to enhance visual detail\n        oTrap = min(oTrap, vec4(abs(z.xyz), dot(z, z)));\n        mz2 = dot(z, z);\n        iteration += 1.0;\n\n        // Adjust bailout threshold to avoid disappearing fractal\n        if (mz2 > 500.0) break;\n    }\n\n    return 0.08 * sqrt(mz2 / md2) * log(mz2);  // Adjusted scaling for more visibility and depth\n}\n\n// Function to get digital colors representing connectivity and freedom\nvec3 getInternetColor(float health, float freedom, float interconnectivity) {\n    float totalCARE = (health + freedom + interconnectivity) / 3.0;\n\n    // Define new, unique digital, internet-inspired colors to differentiate from previous shaders\n    vec3 limeGreen = vec3(0.7, 1.0, 0.3);  // Lime green for vibrancy and energy\n    vec3 aquaBlue = vec3(0.3, 0.9, 1.0);  // Aqua blue for connectivity and flow\n    vec3 pastelPurple = vec3(0.8, 0.6, 1.0);  // Soft purple representing innovation and creativity\n    vec3 vibrantYellow = vec3(1.0, 1.0, 0.3);  // Bright yellow for the spread of information\n    vec3 lightPink = vec3(1.0, 0.7, 0.8);  // Light pink for collaboration and user engagement\n    vec3 softIvory = vec3(1.0, 0.95, 0.85);  // Soft ivory for peak development moments\n\n    // Gradual transitions between internet-inspired colors\n    if (totalCARE <= 5.0) {\n        return mix(limeGreen, aquaBlue, totalCARE / 5.0);  // Transition from lime green to aqua blue\n    }\n    if (totalCARE <= 6.0) {\n        return mix(aquaBlue, pastelPurple, (totalCARE - 5.0));  // Transition from aqua blue to pastel purple\n    }\n    if (totalCARE <= 7.0) {\n        return mix(pastelPurple, vibrantYellow, (totalCARE - 6.0));  // Transition from pastel purple to vibrant yellow\n    }\n    if (totalCARE <= 8.0) {\n        return mix(vibrantYellow, lightPink, (totalCARE - 7.0));  // Transition from vibrant yellow to light pink\n    }\n    return mix(lightPink, softIvory, (totalCARE - 8.0));  // Transition from light pink to soft ivory\n}\n\n// Function to adjust color based on the CARE-scores using internet colors\nvec3 getColor(float iteration, float maxIteration, vec4 oTrap, float health, float freedom, float interconnectivity) {\n    float t = iteration / maxIteration;\n\n    // Get internet-based color depending on CARE values\n    vec3 baseColor = getInternetColor(health, freedom, interconnectivity);\n    \n    // Add orbit trap influence to color for more visual complexity\n    baseColor += 0.35 * vec3(oTrap.x, oTrap.y, oTrap.z) * (1.0 - t);\n    \n    // Add a glow effect for areas with high interconnectivity\n    baseColor += 0.25 * pow(max(0.0, 1.0 - t), 3.0) * vec3(0.8, 1.0, 0.6);\n    \n    return baseColor;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in vec4 c, out vec4 res, out float iteration) {\n    vec4 tmp;\n    float resT = -1.0;\n    float maxd = 150.0;  // Increased maximum distance for better visibility\n    float h = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 3000; i++) {\n        if (h < 0.0001 || t > maxd) break;\n        h = map(ro + rd * t, tmp, c, iteration);\n        t += h;\n    }\n    if (t < maxd) {\n        resT = t;\n        res = tmp;\n    }\n    return resT;\n}\n\n// Function to render the fractal and ensure it remains visible\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c, float health, float freedom, float interconnectivity) {\n    const vec3 sun = vec3(0.577, 0.577, 0.577);\n\n    vec4 tra;\n    float iteration;\n    float t = intersect(ro, rd, c, tra, iteration);\n\n    vec3 col;\n    if (t < 0.0) {\n        // Background gradient with a beige tone\n        col = vec3(0.94, 0.87, 0.78) * (0.7 + 0.3 * rd.y); // Beige background\n    } else {\n        vec3 mate = vec3(0.2, 0.8, 0.5) * 0.3;  // Adjusted material color for better complementing\n        vec3 pos = ro + t * rd;\n        vec3 nor = normalize(pos);  // Normal approximation\n\n        // Get color based on iteration count and orbit trap using internet colors\n        col = getColor(iteration, float(numIterations), tra, health, freedom, interconnectivity);\n\n        // Add some subsurface scattering effect for an organic feel\n        float subsurface = clamp(dot(rd, nor) + 0.5, 0.0, 1.0);\n        col += mate * 0.8 * subsurface;\n\n        // Sun lighting\n        vec3 lig = sun;\n        float dif = clamp(dot(lig, nor), 0.0, 1.0);\n        col += mate * vec3(1.00, 0.95, 0.85) * dif;\n\n        // Stronger shadows for more dramatic contrast\n        float shadow = 0.5 + 0.5 * cos(t + iTime * 0.05);\n        col *= shadow;\n\n        // Add variation in brightness for more depth\n        col *= 0.9 + 0.4 * sin(iTime * 0.1 + iteration);\n    }\n\n    return pow(col, vec3(0.4545));  // Gamma correction for realistic brightness\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Parameters for animation\n    float time = iTime * 0.0025;  // Slower movement for a calmer effect\n    vec4 c = computeC(time);\n\n    // Set up the camera\n    float r = 3.0;  // Adjust zoom level here\n    vec3 ro = vec3(r * cos(0.3 + 0.37 * time), 0.3 + 0.8 * r * cos(1.0 + 0.33 * time), r * cos(2.2 + 0.31 * time)); // Adjusted camera position to match other shaders\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    float cr = 0.1 * cos(0.1 * time);\n\n    // Compute camera direction vectors\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    // Ray direction\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    vec3 rd = normalize(p.x * cu + p.y * cv + 2.0 * cw);\n\n    // CARE parameters for the \"Development of the Internet\"\n    float health, freedom, interconnectivity;\n    if (time < 0.33) {\n        // Early phase\n        health = 5.0;\n        freedom = 4.0;\n        interconnectivity = 6.0;\n    } else if (time < 0.66) {\n        // Acceleration phase\n        health = 6.0;\n        freedom = 8.0;\n        interconnectivity = 9.0;\n    } else {\n        // Maturity phase\n        health = 7.0;\n        freedom = 8.0;\n        interconnectivity = 10.0;\n    }\n\n    // Render the scene with internet-based color scheme\n    vec3 col = render(ro, rd, c, health, freedom, interconnectivity);\n\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}