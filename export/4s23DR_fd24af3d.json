{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"bool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 0.25;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\nbool cylinder(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\n\tfloat a = dot(dir.xy, dir.xy);\n\tfloat b = dot(org.xy, dir.xy);\n\tfloat c = dot(org.xy, org.xy) - 0.25;\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.0 )\n\t\treturn false;\n\n\t// 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.0 / a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t// order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat znear = org.z + near * dir.z;\n\tfloat zfar = org.z + far * dir.z;\n\n\t// top, bottom\n\tvec2 zcap = vec2(0.5, -0.5);\n\tvec2 cap = (zcap - org.z) / dir.z;\n\n\tif ( znear < zcap.y )\n\t\tnear = cap.y;\n\telse if ( znear > zcap.x )\n\t\tnear = cap.x;\n\n\tif ( zfar < zcap.y )\n\t\tfar = cap.y;\n\telse if ( zfar > zcap.x )\n\t\tfar = cap.x;\n\t\n\treturn far > 0.0 && far > near;\n}\n\n// cone inscribed in a unit cube centered at 0\nbool cone(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// scale and offset into a unit cube\n\torg.x += 0.5;\n\tfloat s = 0.5;\n\torg.x *= s;\n\tdir.x *= s;\n\t\n\t// quadratic x^2 = y^2 + z^2\n\tfloat a = dir.y * dir.y + dir.z * dir.z - dir.x * dir.x;\n\tfloat b = org.y * dir.y + org.z * dir.z - org.x * dir.x;\n\tfloat c = org.y * org.y + org.z * org.z - org.x * org.x;\n\t\n\tfloat cap = (s - org.x) / dir.x;\n\t\n\t// linear\n\tif( a == 0.0 )\n\t{\n\t\tnear = -0.5 * c/b;\n\t\tfloat x = org.x + near * dir.x;\n\t\tif( x < 0.0 || x > s )\n\t\t\treturn false; \n\n\t\tfar = cap;\n\t\tfloat temp = min(far, near); \n\t\tfar = max(far, near);\n\t\tnear = temp;\n\t\treturn far > 0.0;\n\t}\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.0 )\n\t\treturn false;\n\n\t// 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.0 / a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t// order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat xnear = org.x + near * dir.x;\n\tfloat xfar = org.x + far * dir.x;\n\n\tif( xnear < 0.0 )\n\t{\n\t\tif( xfar < 0.0 || xfar > s )\n\t\t\treturn false;\n\t\t\n\t\tnear = far;\n\t\tfar = cap;\n\t}\n\telse if( xnear > s )\n\t{\n\t\tif( xfar < 0.0 || xfar > s )\n\t\t\treturn false;\n\t\t\n\t\tnear = cap;\n\t}\n\telse if( xfar < 0.0 )\n\t{\n\t\t// The apex is problematic,\n\t\t// additional checks needed to\n\t\t// get rid of the blinking tip here.\n\t\tfar = near;\n\t\tnear = cap;\n\t}\n\telse if( xfar > s )\n\t{\n\t\tfar = cap;\n\t}\n\t\n\treturn far > 0.0;\n}\n\n// cube() by Simon Green\nbool cube(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0/dir;\n\tvec3 tbot = invR * (-0.5 - org);\n\tvec3 ttop = invR * (0.5 - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tnear = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfar = min(t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0;\n}\n\n// frustum inscribed in a unit cube centered at 0\n#define INF 1.0e38\nbool frustum(vec3 org, vec3 dir, float apex, out float near, out float far)\n{\n\tvec2 dirf = vec2(0.5 - apex, 0.5); \n\tvec3 tbot, ttop;\n\t\n\t// intersection with near and far planes\n\tfloat invdirx = 1.0 / dir.x;\n\ttbot.x = invdirx * (-0.5 - org.x);\n\tttop.x = invdirx * (0.5 - org.x);\n\n\tfloat temp = dirf.y * (org.x-apex);\n\t\n\t// intersection with inclined planes on y\n\ttbot.y = (-temp - dirf.x * org.y) / (dirf.x * dir.y + dirf.y * dir.x);\n\tttop.y = ( temp - dirf.x * org.y) / (dirf.x * dir.y - dirf.y * dir.x);\n\t\n\t// intersection with inclined planes on z\n\ttbot.z = (-temp - dirf.x * org.z) / (dirf.x * dir.z + dirf.y * dir.x);\n\tttop.z = ( temp - dirf.x * org.z) / (dirf.x * dir.z - dirf.y * dir.x);\n\t\n\t// if intersecting behind the apex, set t to ray's end\n\tvec4 tempt = vec4(tbot.yz, ttop.yz);\n\ttempt = mix(tempt, INF * sign(dir.xxxx), step(org.xxxx + tempt * dir.xxxx, vec4(apex)));\n\ttbot.yz = tempt.xy;\n\tttop.yz = tempt.zw;\n\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min(ttop, tbot);\n\tvec3 tmax = max(ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tnear = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfar = min(t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0;\n}\n\nvoid transformray (vec3 ro, vec3 rd, mat2 rotationY, vec3 offset, out vec3 outro, out vec3 outrd)\n{\n\toutro = ro + offset;\n\toutro = vec3(rotationY * outro.xz, outro.y).xzy;\n\toutrd = vec3(rotationY * rd.xz, rd.y).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// camera\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec3 camro = normalize(vec3(1.0, -0.1, 0.0));\n\tvec3 w = -camro;\n\tcamro *= 2.5;\n\tvec3 u = normalize(cross( vec3(0.0, 1.0, 0.0), w ));\n\tvec3 v = normalize(cross(w,u));\n\tvec3 camrd = normalize(p.x * u + p.y * v + 1.5 * w);\n\tfragColor = vec4(0.0);\n\t\n\t// rotation\n\tfloat angle = 5.0 * iMouse.x / iResolution.x;\n\tif( iMouse.z < 0.5 )\n\t\tangle = iTime + 4.7;\n\tfloat ca = cos(angle);\n\tfloat sa = sin(angle);\n\tmat2  m = mat2(ca, -sa, sa, ca);\n\t\n\tfloat far, near;\n\tvec3 ro, rd;\n\t\n\t// cube\n\ttransformray(camro, camrd, m, vec3(0, -0.7, 0.8), ro, rd );\n\tif (cube (ro, rd, near, far))\n\t\tfragColor += vec4(far - max(near, 0.0));\n\t\n\t// frustum\n\ttransformray(camro, camrd, m, vec3(0, -0.7, -0.8), ro, rd);\n\tif (frustum (ro, rd, -1.0, near, far))\n\t\tfragColor += vec4(far - max(near, 0.0));\n\t\n\t// sphere\n\ttransformray(camro, camrd, m, vec3(0, 0.7, 1.5), ro, rd );\n\tif (sphere (ro, rd, near, far))\n\t\tfragColor += vec4(far - max(near, 0.0));\n\n\t// cylinder\n\ttransformray(camro, camrd, m, vec3(0, 0.7, 0.0), ro, rd );\n\tif (cylinder (ro, rd, near, far))\n\t\tfragColor += vec4(far - max(near, 0.0));\n\n\t// cone\n\ttransformray(camro, camrd, m, vec3(0, 0.7, -1.5), ro, rd);\n\tif (cone (ro, rd, near, far))\n\t\tfragColor += vec4(far - max(near, 0.0));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s23DR","date":"1386512965","viewed":2779,"name":"ray/cone & ray/frustum","username":"robertcupisz","description":"Couldn't find any decent implementations of ray/cone and ray/frustum intersection tests, so wrote them here. All handle the case of ray origin being inside the shape as well. Unit box for reference. Any tips on simplifying or speeding up very welcome :)","likes":89,"published":1,"flags":0,"usePreview":0,"tags":["ray","intersection","cone","frustum"],"hasliked":0,"parentid":"","parentname":""}}