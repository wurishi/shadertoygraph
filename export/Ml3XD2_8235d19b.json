{"ver":"0.1","info":{"id":"Ml3XD2","date":"1489121021","viewed":264,"name":"Irradiance CubeMap Commented","username":"fscur","description":"commented shader from Bers to learn about irradiance maps and pbr\nhttps://www.shadertoy.com/view/ls3Szr","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["irradiance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define half_pi\t\t1.570796327\n#define pi\t\t\t3.141592653\n#define two_pi\t\t6.283185307\n#define saturate(x) clamp(x,0.0,1.0)\n\n#define MAX_DIST 500.0\n\nstruct Intersection\n{\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float t;\n    int materialId;\n};\n\nvec2 getUv(in vec3 n)\n{\n    float phi = atan(n.z, n.x);\n    float theta = asin(n.y);\n    float u = 1.0 - (phi + pi) / two_pi;\n    float v = (theta + half_pi) / pi;\n    return vec2(u, v);\n}\n    \nfloat mapSphere(in vec3 center, in float radius)\n{\n\treturn length(center) - radius;\n}\n\nfloat map(in vec3 pos)\n{\n    return mapSphere(pos, 0.5);\n}\n\nIntersection trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    float tmax = MAX_DIST;\n    float dist = MAX_DIST;\n    \n    for(int i = 0; i < 50; i++)\n    {\n\t    dist = map(ro + t * rd);\n        \n        if(abs(dist) < 0.001 || t > MAX_DIST)\n            break;\n        \n        t += dist;\n    }\n    \n    vec3 hitPosition  = ro + t * rd;\n    bool didntHit = (dist > 0.01 || t > MAX_DIST);\n    \n    vec3 normal = normalize(hitPosition);\n    \n    return Intersection(hitPosition, normal, getUv(normal), t, didntHit ? 0 : 1);\n}\n\n//Cubemap folding\nstruct MyCubeMap_FaceInfo\n{\n    vec2 uv; //[0-1]\n    float id; //[0=x+,1=x-,2=y+,3=y-,4=z+,5=z-]\n};\n//Cubemap folding\nvec4 MyCubeMap_cube(vec3 ro, vec3 rd, vec3 pos, vec3 size)\n{\n    ro = ro-pos;\n    float cullingDir = all(lessThan(abs(ro),size))?1.:-1.;\n    vec3 viewSign = cullingDir*sign(rd);\n    vec3 t = (viewSign*size-ro)/rd;\n    vec2 uvx = (ro.zy+t.x*rd.zy)/size.zy; //face uv : [-1,1]\n    vec2 uvy = (ro.xz+t.y*rd.xz)/size.xz;\n    vec2 uvz = (ro.xy+t.z*rd.xy)/size.xy;\n    if(      all(lessThan(abs(uvx),vec2(1))) && t.x > 0.) return vec4(t.x,(uvx+1.)/2.,0.5-viewSign.x/2.0);\n    else if( all(lessThan(abs(uvy),vec2(1))) && t.y > 0.) return vec4(t.y,(uvy+1.)/2.,2.5-viewSign.y/2.0);\n    else if( all(lessThan(abs(uvz),vec2(1))) && t.z > 0.) return vec4(t.z,(uvz+1.)/2.,4.5-viewSign.z/2.0);\n\treturn vec4(2000.0,0,0,-1);\n}\n//Cubemap unfolding\n#define SEAMLESS 1\n//Converts a cube face ID & face uv into 2D texture [0-1] uv mapping\nvec2 MyCubeMap_faceToUV(MyCubeMap_FaceInfo info)\n{\n    const float freq = 2.5;\n    info.id   += (info.id>=4.99 && info.uv.y>0.5)?1.:0.;\n#if SEAMLESS\n    const float eps = 0.003;\n    bool bHalf = (info.id>5.99);\n    if(bHalf)\n    {\n        info.uv.y -= 0.5;\n\t\tinfo.uv.y = min(info.uv.y,0.5-eps);\n    }\n    info.uv = min(info.uv,1.-eps);\n    info.uv = max(info.uv,eps);\n#else\n    info.uv.y -= (info.id>5.99)?0.5:0.;\n#endif    \n    \n    vec2 huv = vec2(info.uv.x+info.id,info.uv.y);\n    huv.y = huv.y/freq+floor(huv.x/freq)/freq;\n    return vec2(fract(huv.x/freq),huv.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;    \n    \n    //position camera\n\tfloat angle = iMouse.x/iResolution.x * two_pi * 2.0;\n\tvec3 ro = vec3(cos(angle), iMouse.y/iResolution.y * 2.0 - 1.0, sin(angle)) * 2.0;\n    //vec3 ro = vec3(cos(angle), 0.0, sin(angle)) * 2.0;\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    // camera matrix\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n\t// create view ray\n\tvec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    //\n    vec3 color = vec3(0.0);\n    vec3 sphereCenter = vec3(0.0, 0.0, 0.0);\n    \n    Intersection intersection = trace(ro, rd);\n        \n    if (intersection.materialId == 1)\n    {\n        vec3 position = intersection.point;\n        vec3 normal = intersection.normal;\n\t\t\n        vec4 rVal = MyCubeMap_cube(vec3(0),normal,vec3(0),vec3(2));\n    \tMyCubeMap_FaceInfo faceInfo = MyCubeMap_FaceInfo(rVal.yz,rVal.w);\n    \tvec3 cHemisphereDiffuse = texture(iChannel0,MyCubeMap_faceToUV(faceInfo),-100.0).rgb;\n        \n        vec3 baseColor = vec3(0.95);\n        vec3 diffuse = baseColor * cHemisphereDiffuse;\n        \n        color += diffuse;\n        color = pow(color, vec3(0.4545));\n        //color += vec3(intersection.t-0.5);\n    }\n    else\n        color += texture(iChannel1, -rd).rgb;\n    \n    //vec2 uv = fragCoord.xy/iResolution.xy;\n    //fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//commented shader from Bers to learn about irradiance maps and pbr\n//https://www.shadertoy.com/view/ls3Szr\n\n//Author : SÃ©bastien BÃ©rubÃ©\n//Buffer A : Hemisphere integration to compute environment diffuse contribution.\n//           The result is \"cubemapped\" and folded into the current buffer output,\n//           using uvToFace() and faceToRay().\n//           \n//           function \"FaceInfo uvToFace(vec2 uv)\" converts a [0-1] uv input into the cubemap face info (face ID + face UV).\n//           function \"vec3 faceToRay(FaceInfo info)\" converts a face info into a 3D direction.\n//           \n//    BufferA :\n//     __________________________________________\n//    |    Face 6      |    Face 6      |        |\n//    |   z- lower     |   z- upper     |MetaData|\n//    |________________|________________|________|\n//    |        |                |                |\n//    |        |                |                |\n//    |Face 3  |     Face 4     |     Face 5     |\n//    |  y+    |       y-       |       z+       |\n//    |________|________________|________________|\n//    |                |                |        |\n//    |                |                |        |\n//    |    Face 1      |    Face 2      |  Face 3|\n//    |      X+        |      X-        |    y+  |\n//    |________________|________________|________|\n// \n\n//#define HIGH_QUALITY //Time needs to be reset when defining this value.\n\n#ifdef HIGH_QUALITY\nconst int SAMPLES_PER_ITERATION = 30;\nconst int CONVERGENCE_FRAME_COUNT = 300;\n#else\nconst int SAMPLES_PER_ITERATION = 5;\nconst int CONVERGENCE_FRAME_COUNT = 100;\n#endif\n\n//Arbitrary axis rotation (around normalized u, cos theta, sin theta)\nmat3 UTIL_axisRotationMatrix( vec3 u, float ct, float st )\n{\n    return mat3(  ct+u.x*u.x*(1.-ct),     u.x*u.y*(1.-ct)-u.z*st, u.x*u.z*(1.-ct)+u.y*st,\n\t              u.y*u.x*(1.-ct)+u.z*st, ct+u.y*u.y*(1.-ct),     u.y*u.z*(1.-ct)-u.x*st,\n\t              u.z*u.x*(1.-ct)-u.y*st, u.z*u.y*(1.-ct)+u.x*st, ct+u.z*u.z*(1.-ct) );\n}\n\n/*\nVector3 Sample::CosineSampleHemisphere(float u1, float u2)\n{\n    const float r = Sqrt(u1);\n    const float theta = 2 * kPi * u2;\n \n    const float x = r * Cos(theta);\n    const float y = r * Sin(theta);\n \n    return Vector3(x, y, Sqrt(Max(0.0f, 1 - u1)));\n}\n*/\n\nvec3 rotateSample(\n    vec3 sampleDir, \n    float phi_range,\n    float theta_range, \n    out float theta)\n{\n    const float PI = 3.14159;  \n    \n    //theta from 0 to 2 PI\n    float phi = 2.0 * PI * phi_range;\n    \n    float cos_theta = sqrt(1.0 - theta_range);\n    float sin_theta = sqrt(theta_range);\n    \n    theta = atan(sin_theta / cos_theta);\n    \n    //create an orthogonal axis and rotate the normal about by theta (0..PI/2)\n\tvec3 notColinear = (abs(sampleDir.y) < 0.8) ? vec3(0, 1, 0) : vec3(1, 0, 0);\n\tvec3 orthogonalAxis = normalize(cross(notColinear, sampleDir));\n\tmat3 m1 = UTIL_axisRotationMatrix(orthogonalAxis, cos_theta, sin_theta);\n    \n    //rotate about the normal by phi (0..2 * PI)\n\tmat3 m2 = UTIL_axisRotationMatrix(sampleDir, cos(phi), sin(phi));\n    \n    return sampleDir * m1 * m2;\n}\n\nvec3 integrateHemisphere(vec3 normal, float progress)\n{\n    //Add some randomness in between progress steps.\n    float ff = 0.5 - \n        (fract(normal.x * 4913.0) + \n         fract(normal.y * 4913.0) +\n         fract(normal.z * 4913.0)) / 6.0;\n    \n    //progress += max(0.0, ff/float(CONVERGENCE_FRAME_COUNT));\n    progress += ff/float(CONVERGENCE_FRAME_COUNT);\n    //progress += 1.0/float(CONVERGENCE_FRAME_COUNT);\n        \n    vec3 sampledColour = vec3(0,0,0);\n    float index = 0.0;\n    float theta = 0.0;\n    float theta_range = progress;\n    \n    //http://www.codinglabs.net/article_physically_based_rendering.aspx\n    for(int j = 0; j < SAMPLES_PER_ITERATION; ++j)\n    {\n        float phi_range = \n            index/float(SAMPLES_PER_ITERATION) + \n            fract(progress * 87316.0)/float(SAMPLES_PER_ITERATION);\n        \n        //uniformly sample random vector over hemisphere around normal\n        vec3 sampleVector = rotateSample(normal, phi_range, theta_range, theta);\n        \n\t\tvec3 linearGammaColor = \n            pow(texture(iChannel1, sampleVector, -100.0).rgb, vec3(2.2));\n        \n\t\tsampledColour += linearGammaColor * cos(theta) * sin(theta);\n\t\tindex++;\n\t}\n\n    return vec3( 3.14159 * sampledColour / index);\n}\n\nstruct FaceInfo\n{\n    vec2 uv; //[0-1]\n    float id; //[0=x+, 1=x-, 2=y+, 3=y-, 4=z+, 5=z-]\n};\n    \n//receives a faceID + uv, which it converts into a 3D direction from cube center to face point.\nvec3 faceToRay(FaceInfo info)\n{\n    //info.id = [0=x+,1=x-, 2=y+,3=y-, 4=z+,5=z-]\n    //fAxis   = [0.01;0.51; 1.01;1.51; 2.01;2.51]\n    \n    float eps = 0.01;              \n    float fAxis = info.id / 2.0 + eps;\n    \n    //0-0, 0-1, 0-2\n    //[0.01;0.51; 1.01;1.51; 2.01;2.51]\n    \n    //id = 0\n   \t//floor(0.01, 0.01, 0.01) = vec3(0.0, 0.0, 0.0)\n    //abs(vec3(0.0, 0.0, 0.0) - vec3(0.0, 1.0, 2.0)) = vec3(0.0, 1.0, 2.0)\n    //lessThan(vec3(0.0, 1.0, 2.0), vec3(0.01, 0.01, 0.01)) = vec3(true, false, false)\n    \n    //id = 1\n   \t//floor(0.51, 0.51, 0.51) = vec3(0.0, 0.0, 0.0)\n    //abs(vec3(0.0, 0.0, 0.0) - vec3(0.0, 1.0, 2.0)) = vec3(0.0, 1.0, 2.0)\n    //lessThan(vec3(0.0, 1.0, 2.0), vec3(0.01, 0.01, 0.01)) = vec3(true, false, false)\n    \n    //id = 2\n   \t//floor(1.01, 1.01, 1.01) = vec3(1.0, 1.0, 1.0)\n    //abs(vec3(1.0, 1.0, 1.0) - vec3(0.0, 1.0, 2.0)) = vec3(1.0, 0.0, 1.0)\n    //lessThan(vec3(0.0, 1.0, 2.0), vec3(0.01, 0.01, 0.01)) = vec3(false, true, false)\n    \n    //id = 3\n   \t//floor(1.51, 1.51, 1.51) = vec3(1.0, 1.0, 1.0)\n    //abs(vec3(1.0, 1.0, 1.0) - vec3(0.0, 1.0, 2.0)) = vec3(1.0, 0.0, 1.0)\n    //lessThan(vec3(0.0, 1.0, 2.0), vec3(0.01, 0.01, 0.01)) = vec3(false, true, false)\n    \n    //id = 4\n   \t//floor(2.01, 2.01, 2.01) = vec3(2.0, 2.0, 2.0)\n    //abs(vec3(2.0, 2.0, 2.0) - vec3(0.0, 1.0, 2.0)) = vec3(2.0, 1.0, 0.0)\n    //lessThan(vec3(2.0, 1.0, 0.0), vec3(0.01, 0.01, 0.01)) = vec3(false, false, true)\n    \n    //id = 5\n   \t//floor(2.51, 2.51, 2.51) = vec3(2.0, 2.0, 2.0)\n    //abs(vec3(2.0, 2.0, 2.0) - vec3(0.0, 1.0, 2.0)) = vec3(2.0, 1.0, 0.0)\n    //lessThan(vec3(2.0, 1.0, 0.0), vec3(0.01, 0.01, 0.01)) = vec3(false, false, true)\n    \n    //so, axis for idx:\n    //0 or 1 = vec3(true, false, false)\n    //2 or 3 = vec3(false, true, false)\n    //4 or 5 = vec3(false, false, true)\n    \n    bvec3 axis  = lessThan(abs(floor(fAxis) - vec3(0,1,2)), vec3(eps));\n    \n    //id = 0 or 1\n    //camD = vec3(1, 0, 0)\n    //camU = vec3(0, 1, 0)\n    //camR = cross(camD, camU) = vec3(0, 0, 1)\n    \n    //id = 2 or 3\n    //camD = vec3(0, 1, 0)\n    //camU = vec3(0, 0, 1)\n    //camR = cross(camD, camU) = vec3(1, 0, 0)\n    \n    //id = 4 or 5\n    //camD = vec3(0, 0, 1)\n    //camU = vec3(0, 1, 0)\n    //camR = cross(-camD, camU) = vec3(1, 0, 0)\n    \n    \n    //direction points to the axis of the face\n    vec3 camD = vec3(axis.x ? 1:0, axis.y ? 1:0, axis.z ? 1:0);\n    \n    //if idx = 2 or 3(y faces) camU = Z axis else Y axis\n    vec3 camU = (axis.y) ? vec3(0, 0, 1) : vec3(0, 1, 0);\n    \n    //right is the \n    vec3 camR = cross(axis.z ? -camD : camD, camU);\n    \n    //info.id   = [ 0=x+  1=x-  2=y+  3=y-  4=z+  5=z-]\n    //axisSign  = [+1.0; -1.0; +1.0; -1.0; +1.0; -1.0;]\n    float axisSign = (fract(fAxis) < 0.5) ? 1.0 : -1.0;\n    \n    //transforms uv range from 0.0..1.0 to -1.0..1.0\n    vec2 uv = info.uv * 2.0 - 1.0;\n    \n    //maps uvs to world directions\n    return normalize(camR * uv.x + camU * uv.y + camD * axisSign);\n}    \n    \n//Converts a 2D texture into its tile uv and its [0..5] index;\nFaceInfo uvToFace(vec2 uv)\n{\n    //huv is the \"horizontally unrolled\" wide uv coord, where u.x=[0-6] and u.y=[0-1].\n    //tuv is the tile uv coord, back to [0-1]. Note: 6th anf 7th tiles are cut in half and combined.\n    \n    //transforms uv to be in the range 0.0..2.5\n    const float freq = 2.5;\n    uv *= freq;\n    \n    //huv.x goes from 0.0 .. 7.5, huv.y from 0.0..0.99\n    vec2 huv = vec2(uv.x + freq * floor(uv.y), fract(uv.y));\n    \n    //get index for each face from 0..6\n    float idx = floor(huv.x);\n    \n    //tile uv: goes from 0.0..1.0 for each face\n    //and if the tile is the last one, with idx == 6, \n    //then sum 0.5 so it becomes the upper half of idx 5\n    //going from 0.5 to 1.0\n    vec2 tuv = vec2(fract(huv.x), huv.y + (idx > 5.1 ? 0.5 : 0.0));\n    \n    //if idx > 5 then idx = 5\n    return FaceInfo(tuv, min(idx, 5.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv in the range 0.0..1.0\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    FaceInfo info = uvToFace(uv);\n    vec3 rayDir = faceToRay(info);\n    \n    //persisted data: resolution and framecount\n    vec3 cBuf = texture(iChannel0, vec2(1), -100.0).xyz;\n    vec2 prevRes = cBuf.xy;\n    float frameCount = cBuf.z;\n\t\n    //last frame accumulated color\n    vec3 accumColor = texture(iChannel0, uv, -100.0).rgb;\n    \n    //timer reset or resolution changed\n    if(iTime < 0.1 || length(prevRes - iResolution.xy) > 1.0)\n    {\n        //Init/reset on resolution change\n        accumColor = vec3(0);\n        frameCount = 0.0;\n    }\n    \n    //percent of total frames to converge\n    float progress = frameCount/float(CONVERGENCE_FRAME_COUNT);\n    \n    \n    //current color\n    vec3 cCurrentContribution = integrateHemisphere(rayDir, progress) / float(CONVERGENCE_FRAME_COUNT);\n    \n    vec3 c = accumColor + ((progress <= 1.0) ? cCurrentContribution : vec3(0.0));\n\t\n    fragColor = vec4(c, 1.0);\n    \n    //Use top-right texture pixel to store computation resolution & frame count.\n    if(length(uv-vec2(1))<0.01)\n    {\n        fragColor.xyz = vec3(iResolution.xy, frameCount + 1.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}