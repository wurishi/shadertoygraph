{"ver":"0.1","info":{"id":"lsySDR","date":"1463730471","viewed":296,"name":"Sans Infinitum","username":"JasonD","description":"Combining my shader...\n(Image: Passage Infinitum -- https://www.shadertoy.com/view/ldKXRm)\n...with an awesome Square region filling from rimbas4 (slight mods):\n(Buf A: sans- https://www.shadertoy.com/view/ldKSzm)","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["square","floor","filling","undertale","sans","ceiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jason Allen Doucette\n// http://xona.com/jason/\n//\n// May 19, 2016\n//\n// SOURCE:\n// 1. Image: Passage Infinitum -- https://www.shadertoy.com/view/ldKXRm -- by JasonD (that's me!)\n// 2. Buf A: sans              -- https://www.shadertoy.com/view/ldKSzm -- by rimbas4\n\n// ---- SETTINGS ----------------------------------------------------------------\n\n// ---- JASON ---- changed ----\n#define X_SCALE 0.95    // size of texture stretch horizontally\n#define Z_SCALE 0.40    // size of texture stretch into screen\n// ---- JASON ---- end ----\n\n#define Z_SPEED     0.3    // speed of motion into screen\n#define X_SPEED_MAX 0.5    // max speed horizontally \n#define X_CYCLE_SPEED 0.1  // cycle of horizontal (left/right) motion switch\n\n#define CAM_YAW_CYCLE_SPEED 0.225     // cycle of camera rotate left/right angle\n#define CAM_YAW_MAX_ANGLE 1.570796    // max camera rotate left/right angle\n\n#define CAM_ROLL_CYCLE_SPEED 0.168    // cycle of camera tilt angle\n#define CAM_ROLL_MAX_ANGLE 0.6642     // max camera rotate tilt angle\n\n#define CEN_POINT_CYCLE_SPEED1 0.562 // how fast the point goes around in a circle\n#define CEN_POINT_CYCLE_SPEED2 0.383 // how fast the point goes around in a circle\n#define CEN_POINT_CYCLE_MAG    0.3   // radius of the circle\n\n#define COLOR_CYCLE 0.25\n#define FADE_POWER 0.3\n\n\n// ---- CONSTANTS ----------------------------------------------------------------\n\n#define PI 3.1415926535897932384626\n\n\n// ---- CODE ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // isotropic scaling, ensuring entire texture fits into the view.\n    // After this, you should consider fragCoord = 0..1, usually,\n    // aside from overflow for wide-screen.\n    float minRes = min(iResolution.x, iResolution.y);\n    fragCoord /= minRes;\n   \n    // center point on screen\n    vec2 center = (iResolution.xy / minRes) / 2.0;    \n\n    // select a point on screen, upon which to rotate the screen\n    //vec2 p = center;\n    float angle1 = CEN_POINT_CYCLE_SPEED1 * iTime;\n    float angle2 = CEN_POINT_CYCLE_SPEED2 * iTime;\n    vec2 p = center + vec2(cos(angle1), sin(angle2)) * CEN_POINT_CYCLE_MAG;\n        \n    \n    // rotate point on screen (rotate entire screen)\n    // around point P\n    float angle = sin(iTime * CAM_ROLL_CYCLE_SPEED) * CAM_ROLL_MAX_ANGLE;\n    float cs = cos(angle);\n    float sn = sin(angle);\n    fragCoord.xy -= p;\n    vec2 newCoord = vec2(\n        fragCoord.x * cs + fragCoord.y * sn,\n        fragCoord.y * cs - fragCoord.x * sn);\n    fragCoord.xy = newCoord;\n    fragCoord.xy += p;\n    \n    // distance from center\n    vec2 dCenter = center - fragCoord.xy;\n    \n    // height of screen\n    float height = (iResolution.y / minRes) / 2.0;\n    \n    // 3D perspective: 1/Z = constant\n    float zCamera = 1.0 / abs(dCenter.y);\n    float xCamera = X_SCALE * dCenter.x * zCamera;\n    float yCamera = Z_SCALE * zCamera;\n\n    // static texture coordinates\n    fragCoord.xy = vec2(xCamera, yCamera);\n    \n    \n    // rotate camera\n    // via rotating texture\n    angle = sin(iTime * CAM_YAW_CYCLE_SPEED) * CAM_YAW_MAX_ANGLE;\n    cs = cos(angle);\n    sn = sin(angle);\n    newCoord = vec2(\n        fragCoord.x * cs + fragCoord.y * sn,\n        fragCoord.y * cs - fragCoord.x * sn);\n    fragCoord.xy = newCoord;    \n\n    // move\n    fragCoord.y += iTime * Z_SPEED;\n    fragCoord.x += cos(iTime * X_CYCLE_SPEED) * X_SPEED_MAX;\n\n    // ---- JASON ---- changed ----\n    // textured\n    vec2 uv;\n    if (dCenter.y > 0.0) {\n        uv = fragCoord.xy;\n    } else {\n        uv = fragCoord.xy;   \n        uv.y *= -1.0;\n    }\n    \n    // wrap texture, since ShaderToy doesn't allow wrapping of manually created textures! ugh!\n    uv.x = mod(uv.x, 1.0);\n    uv.y = mod(uv.y, 1.0);\n    \n\tvec4 sans = texture(iChannel0, uv);\n    fragColor = vec4(0.0, 0.0, 0.1, 1.0);\n    if (sans.w == 1.0) \n    \tfragColor = sans;\n    // ---- JASON ---- end ----\n    \n    \n    // get rainbow color\n    angle = iTime * COLOR_CYCLE; // 0...1...2...\n    angle = mod(angle, 1.0); // 0..1, wraps/repeat\n    float mag = mod(angle, 1.0/6.0) * 6.0; // 0..1\n    //    R G B\n    // 1. +   1\n    // 2. 1   -\n    // 3. 1 +  \n    // 4. - 1  \n    // 5.   1 +\n    // 6.   - 1\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    if (angle < 1.0/6.0) {\n        r = mag;\n        b = 1.;\n    } else if (angle < 2.0/6.0) {\n        r = 1.;\n        b = 1. - mag;\n    } else if (angle < 3.0/6.0) {\n        r = 1.;\n        g = mag;\n    } else if (angle < 4.0/6.0) {\n        r = 1. - mag;\n        g = 1.;\n    } else if (angle < 5.0/6.0) {\n        g = 1.;\n        b = mag;\n    } else {\n        g = 1. - mag;\n        b = 1.;\n    }\n    \n    vec3 fadeColor = vec3(r,g,b);\n        \n\n    // fade into distance\n    // y=1-(1/x)\n    // x=0..infinity, y=0..1=fade\n\n    // 0=no fade, 1=full fade\n    float fade = 1.0 - (1.0 / (1.0 + zCamera * FADE_POWER));\n    fragColor.rgb = mix( fragColor.rgb, fadeColor.rgb, fade );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define scale 0.05\n#define T 1\n#define TW(cy, cx) if (y==cy && sx < cx) fragColor = W;\n//#define Q1(cx,cy,p1,p2,p3,p4,p5,p6,p7,p8) if (cy==y &&(sx==14\n\nconst vec4 B = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 W = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 Y = vec4(1.0, 1.0, 0.25, 1.0);\nconst vec4 C = vec4(0.5, 1.0, 1.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float scale = (sin(iTime)/2.0+0.5)*0.09+0.01;\n    \n    // ---- JASON ---- changed ----\n    //float aspect = iResolution.x / iResolution.y;\n    float aspect = 1.0;\n    // ---- JASON ---- end ----\n\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - vec2(1.0, 1.0);\n    //uv.x *= aspect;\n    // uncomment if you want middle (0, 0) pixel completely centered\n    //uv += vec2(scale*0.5, scale*0.5);\n    \n    // ---- JASON ---- added ----\n    float CYCLE_SPEED = 1.0;\n    float angle = iTime * CYCLE_SPEED;\n    float cs = cos(angle);\n    float sn = sin(angle);\n    vec2 newCoord = vec2(\n        uv.x * cs + uv.y * sn,\n        uv.y * cs - uv.x * sn);\n    uv.xy = newCoord;\n    // ---- JASON ---- end ----\n    \n    int x = int(floor(uv.x * aspect / scale));\n    int y = int(floor(uv.y / scale));\n    \n    int sx = x >= 0 ? x : -x - 1; //easier symmetrical shaping\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // skull shape\n    TW(13, 6) TW(12, 9) TW(11, 11) TW(10, 12)\n    TW(9, 13) TW(8, 14) TW(7, 14)\n\tif (y < 7 && y > -1 && sx < 15) fragColor = W;\n    TW(-1, 14) TW(-2, 14) TW(-3, 13) TW(-4, 13)\n    if (y < -4 && y > -9 && sx < 14) fragColor = W;\n    if (y < -8 && y > -11 && sx < 13) fragColor = W;\n    TW(-11, 12) TW(-12, 11) TW(-13, 9) TW(-14, 6)\n        \n    // eyes\n    if (y == 4 && sx > 3 && sx < 10) fragColor = B;\n    if (y == 3 && sx > 2 && sx < 12) fragColor = B;\n    if (y < 3 && y > -1 && sx > 2 && sx < 13) fragColor = B;\n    if (y == -1 && sx > 3 && sx < 12) fragColor = B;\n    if (y == -2 && sx > 3 && sx < 10) fragColor = B;\n    if (y == -3 && sx == 5) fragColor = B;\n    if (y == -4 && sx > 5 && sx < 8) fragColor = B;\n        \n    //nose\n    if (y < 0 && y > -3 && sx == 0) fragColor = B;\n    if (y < -2 && y > -6 && sx < 2) fragColor = B;\n        \n    //mouth\n    if (y == -5 && sx == 9) fragColor = B;\n    if (y == -6 && ((x < -8 && x > -11) || (x > 8 && x < 11))) fragColor = B;\n    if (y == -7 && sx < 12 && sx > 5 && x != -9 && x != 6) fragColor = B;\n    if (y == -8 && sx < 10 && x != -9 && x != -7 && x != 7) fragColor = B;\n    if (y == -9 && (sx==3 || x==-9 || x==-8 || x==-1 || x==6 || x==8)) fragColor = B;\n    if (y == -10 && (sx==3 || x==-7 || x==-8 || x==-1 || x==6 || x==7)) fragColor = B;\n    if (y == -11 && (sx==3 || x==-6 || x==-5 || x==-1 || x==6 || x==5)) fragColor = B;\n\tif (y == -12 && sx < 5 && x != -5) fragColor = B;  \n        \n    //eye\n    vec4 eye = Y;\n    if (mod(iTime, 2.0) > 1.0) eye = C;\n    if (y == 3 && x > 5 && x < 9 ) fragColor = eye;\n    if (y == 2 && x > 4 && x < 10 ) fragColor = eye;\n    if (y == 1 && x > 3 && x < 11 && x != 7) fragColor = eye;    \n    if (y == 0 && x > 4 && x < 10 ) fragColor = eye;    \n    if (y == -1 && x > 5 && x < 9 ) fragColor = eye;\n    \n}","name":"Buf A","description":"","type":"buffer"}]}