{"ver":"0.1","info":{"id":"3tc3Ws","date":"1578167504","viewed":106,"name":"Molecule Dance","username":"psandahl","description":"Playing around with transformation of simple distance functions. The result is a dance of (fake) molecules.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Molecule Dance - A fun visualization of molecules like objects.\n//\n// Patrik Sandahl, 2020 - patrik.sandahl@gmail.com\n\n#define EPSILON 0.001\n#define DEFAULT_ZOOM 1.0\n\n#define FAR 40.0\n\n#define DEFAULT_COLOR vec3(0.3)\n#define DEFAULT_SHININESS 1.0\n#define DEFAULT_STRENGTH 1.0\n\n#define COLORED_MATERIAL 0\n#define LIGHTED_MATERIAL 1\n#define REFLECTIVE_MATERIAL 2\n\n#define MOLECULE_ORIGO vec3(0.0, 10.0, 0.0)\n\nstruct Intersection {\n    float dist;\n    vec3 color;\n    float shininess;\n    float strength;\n    int material;\n};\n\n// A ray object with origin and direction.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Force normalization of direction when creating a ray.\nRay makeRay(vec3 origin, vec3 direction);\n\n// Calculate a point at distance d along the ray.\nvec3 point(Ray r, float d);\n\n// Generate a primary camera ray given:\n// eye - the camera position.\n// at - the position where the camera is looking.\n// up - the world up position.\n// focalLength - the zoom value for the camera. A greater value zoom in.\n// uv - the uv coordinate for which the ray is produced. It is assumed\n// that uv zero is in the middle of the projection.\n// The camera is assuming an OpenGL like coordinate system.\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv);\n\n// Calculate a normal through central difference.\nvec3 calcNormal(vec3 pos);\n\n// Calculate a 2d rotation matrix.\nmat2 calcRotate2d(float theta);\n\n// Intersect the scene and retrieve the closest distance.\nIntersection intersectScene(vec3 pos);\n\n// Ray march the scene.\nIntersection march(Ray r, float far);\n\n// Distance function for plane.\nfloat plane(vec3 pos);\n\n// Distance function for sphere.\nfloat sphere(vec3 pos, float radius);\n\n// Distance function for cylinder.\nfloat cylinder(vec3 pos, vec3 a, vec3 b, float radius);\n\n// A small sphere.\nfloat smallSphere(vec3 pos);\n\n// A medium sphere.\nfloat mediumSphere(vec3 pos);\n\n// A big sphere.\nfloat bigSphere(vec3 pos);\n\n// A pipe between the two points.\nfloat pipe(vec3 start, vec3 end);\n\n// Generate a random vector.\nvec4 random(vec2 uv);\n\n// Molecule generation.\nfloat molecule(int key, vec3 pos);\n\n// Get the light's position.\nvec3 lightPosition();\n\n// Get the light's color.\nvec3 lightColor();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize the uv such that origo is in the middle and such that\n    // compensation is made for aspect ratio.\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\n    // Make the primary ray.\n    vec3 eye = MOLECULE_ORIGO + vec3(0.0, 12.0, 9.0);\n    vec3 at = MOLECULE_ORIGO;\n    Ray ray = cameraRay(eye, at, vec3(0.0, 1.0, 0.0), DEFAULT_ZOOM, uv);           \n    Intersection intersection = march(ray, FAR);\n    vec3 color = vec3(0.0);\n    \n    switch (intersection.material) {\n        case LIGHTED_MATERIAL:\n        {\n            vec3 pos = point(ray, intersection.dist);\n            vec3 normal = calcNormal(pos);\n            vec3 lightDir = normalize(lightPosition() - pos);            \n            \n            float diffuse = max(0.0, dot(normal, lightDir));\n            float specular = max(0.0, dot(normal, normalize(ray.origin - pos)));\n            \n            specular = pow(specular, intersection.shininess);\n            \n            vec3 diffuseLight = lightColor() * diffuse;\n            vec3 reflectedLight = lightColor() * specular * intersection.strength;\n            \n            color = intersection.color * diffuseLight + reflectedLight;\n        }\n        break;\n        \n        case COLORED_MATERIAL:\n        \t// Just use the color as is from the intersection.\n        \tcolor = intersection.color;\n        break;\n        \n        case REFLECTIVE_MATERIAL:\n        {\n            // Primitive reflection. A ton of code duplication. Fix later.\n            vec3 pos = point(ray, intersection.dist);\n            vec3 normal = calcNormal(pos);            \n            pos += normal * 2.0 * EPSILON;\n            vec3 reflectDir = reflect(ray.direction, normal);\n            \n            Ray reflectRay = makeRay(pos, reflectDir);\n            Intersection reflectIntersect = march(reflectRay, FAR);\n            \n            if (reflectIntersect.material == LIGHTED_MATERIAL) {\n                \n                vec3 reflectPos = point(reflectRay, reflectIntersect.dist);\n                vec3 normal = calcNormal(reflectPos);\n                vec3 lightDir = normalize(lightPosition() - reflectPos);\n                \n                float diffuse = max(0.0, dot(normal, lightDir));\n                \n                color = mix(reflectIntersect.color * lightColor() * diffuse, intersection.color, 0.0);\n            } else {\n                color = intersection.color;\n            }                                    \n        }\n        break;\n        \n        default:\n        \t// Just used the color as set in the shader.\n        break;\n    }    \n\n    // Output to screen\n    fragColor = vec4(min(color, vec3(1.0)), 1.0);\n}\n\nRay makeRay(vec3 origin, vec3 direction)\n{\n    return Ray(origin, normalize(direction));\n}\n\nvec3 point(Ray ray, float d)\n{\n    return ray.origin + ray.direction * d;\n}\n\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv)\n{\n    vec3 z = normalize(at - eye);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = cross(x, z);\n    \n    vec3 center = eye + z * focalLength;\n    vec3 xy = center + uv.x * x + uv.y * y;\n    \n    return makeRay(eye, xy - eye);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    float d = intersectScene(pos).dist;\n    vec2 e = vec2(EPSILON, 0.0);\n    \n    vec3 n = d - vec3(\n        intersectScene(pos - e.xyy).dist,\n        intersectScene(pos - e.yxy).dist,\n        intersectScene(pos - e.yyx).dist\n    );\n    \n    return normalize(n);\n}\n\nmat2 calcRotate2d(float theta)\n{\n    return mat2(vec2(cos(theta), -sin(theta)), vec2(sin(theta), cos(theta)));\n}\n\nIntersection intersectScene(vec3 pos)\n{\n    // Calculate the distance to the bottom plane (at height zero).\n    float pd = plane(pos - vec3(0.0, 0.0, 0.0));\n    \n    // Set the height for the molecule center at its origo.\n    pos -= MOLECULE_ORIGO;\n    \n\t// Rotate the molecule.                \n    pos.xz = calcRotate2d(iTime * 0.5) * pos.xz;\n    \n    // Handle the transitioning between molecules.\n    float tPace = iTime * 0.3;\n    int iPace = int(floor(tPace));\n              \n    // Mix the animated transition.\n    //float md = mix(m[curr], m[next], smoothstep(0.3, 0.7, fract(tPace)));    \n    float md = mix(molecule(iPace, pos), molecule(iPace + 1, pos), smoothstep(0.2, 0.8, fract(tPace)));\n    \n    if (pd < md) {\n        // Return the plane intersection.\n        return Intersection(pd, DEFAULT_COLOR, DEFAULT_SHININESS, DEFAULT_STRENGTH, REFLECTIVE_MATERIAL);\n    } else {\n        \n        // Mix the color for the molecule.\n        float cPace = iTime * 0.04;\n        float cMix = fract(cPace);\n                \n        vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), smoothstep(0.0, 0.17, cMix));\n        color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(0.17, 0.5, cMix));\n        color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(0.5, 0.83, cMix));\n        \n        // Return the molecule intersection.\n        return Intersection(md, color, 128.0, 1.0, LIGHTED_MATERIAL);\n    }        \n}\n\nIntersection march(Ray ray, float far)\n{\n    Intersection intersection = Intersection(0.0, DEFAULT_COLOR, DEFAULT_SHININESS, DEFAULT_STRENGTH, COLORED_MATERIAL);\n    float d0 = 0.0;\n    \n    for (int i = 0; i < 100; ++i) {\n        vec3 pos = point(ray, d0);\n        intersection = intersectScene(pos);        \n        d0 += intersection.dist;\n        \n        if (intersection.dist < EPSILON) break;\n        if (d0 > far) {\n            intersection.color = DEFAULT_COLOR;\n            intersection.shininess = DEFAULT_SHININESS;\n            intersection.strength = DEFAULT_STRENGTH;\n            intersection.material = COLORED_MATERIAL;\n            break;\n        }\n    }\n    \n    intersection.dist = d0;\n    \n    return intersection;\n}\n\nfloat plane(vec3 pos)\n{\n    return pos.y;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat cylinder(vec3 pos, vec3 a, vec3 b, float radius)\n{\n  vec3  ba = b - a;\n  vec3  pa = pos - a;\n  float baba = dot(ba, ba);\n  float paba = dot(pa, ba);\n  float x = length(pa * baba - ba * paba) - radius * baba;\n  float y = abs(paba - baba * 0.5) - baba * 0.5;\n  float x2 = x * x;\n  float y2 = y * y * baba;\n  float d = (max(x,y) < 0.0) ? -min(x2,y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n  return sign(d) * sqrt(abs(d)) / baba;\n}\n\nfloat smallSphere(vec3 pos)\n{\n    return sphere(pos, 0.25);\n}\n\nfloat mediumSphere(vec3 pos)\n{\n    return sphere(pos, 0.35);\n}\n\nfloat bigSphere(vec3 pos)\n{\n    return sphere(pos, 0.45);\n}\n\nfloat pipe(vec3 start, vec3 end)\n{\n    return cylinder(start, vec3(0.0), start - end, 0.04);\n}\n\nvec4 random(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}\n\nfloat molecule(int key, vec3 pos)\n{\n    // A very approximate bounding shpere.\n    if (length(pos) > 10.0) return 10.0;\n    \n    // Generate positions.\n    int numPos = (key % 8) + 1;\n    vec3[8] positions = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0) );    \n    for (int i = 0; i < numPos; ++i) {\n        vec4 dir = random(vec2(float(key * 113 + i) * 134.8, float(key * 671 + i) * 31.33));        \n        positions[i] = pos - normalize(dir.xyz - 0.5) * dir.w * 5.0;\n    }        \n    \n    // Generate spheres.\n    float dist = FAR;\n    for (int i = 0; i < numPos; ++i) {\n        if ((key + i) % 2 == 0) {\n        \tdist = min(dist, mediumSphere(positions[i]));\n        } else if ((key + i) % 5 == 0) {\n            dist = min(dist, bigSphere(positions[i]));\n        } else {\n            dist = min(dist, smallSphere(positions[i]));\n        }\n    }\n    \n    if (numPos == 1) return dist;\n    \n    // Generate connections between closest spheres.\n    for (int i = 0; i < numPos - 1; ++i) {\n        int closestIndex = i + 1;\n        float closestDistance = distance(positions[i], positions[closestIndex]);\n        for (int j = i + 2; j < numPos; ++j) {\n            float d = distance(positions[i], positions[j]);\n            if (d < closestDistance) {\n                closestDistance = d;\n                closestIndex = j;\n            }\n        }\n        \n        dist = min(dist, pipe(positions[i], positions[closestIndex]));\n    }\n        \n    return dist;\n}\n\nvec3 lightPosition()\n{\n    return vec3(100.0, 100.0, 100.0);\n}\n\nvec3 lightColor()\n{\n    return vec3(1.0);\n}","name":"Image","description":"","type":"image"}]}