{"ver":"0.1","info":{"id":"NlyXDV","date":"1642447241","viewed":138,"name":"Projet Pierre Marrec","username":"pmarrec","description":"a","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bidirectionnalpathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n#define INFINITY 9999999.0\n#define PI 3.141592653589\n#define NUM_SAMPLES 64\n#define NUM_BOUNCES 2\n\n#define MAT_UNDEF   0\n#define MAT_DIFFUSE 1\n#define MAT_GLOSSY  2\n#define MAT_EMISSION 3\n\n#define EPSILON 0.00001\n\nfloat g_light_size;\nfloat g_light_area;\n//vec3 light_position = vec3(0, 0.97, 0);\nvec3 g_light_position;\nvec3 g_light_normal;\nint g_seed;\nvec4 g_light_albedo;\nint g_flat_idx;\nfloat g_rho_s = 0.2, g_rho_d = 1., g_alpha = 0.1;\n\nvec3 sphere2_center = vec3(0.5, -0.4,  -0.1);\n\n// Sampling routines\n\nvec2\nsample_disk(vec2 uv)\n{\n\tfloat theta = 2.0 * 3.141592653589 * uv.x;\n\tfloat r = sqrt(uv.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3\nsample_cos_hemisphere(vec2 uv)\n{\n\tvec2 disk = sample_disk(uv);\n\treturn vec3(disk.x, sqrt(max(0.0, 1.0 - dot(disk, disk))), disk.y);\n}\n\nvec3\nsample_light(vec2 rng)\n{\n\treturn g_light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * g_light_size;\n}\n\n\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\n// Routines for random number generation\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\n// return a random 2D vector\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(g_flat_idx, g_seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\n\n// Basic Ray data structures\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\n\n\n// Axis Aligned Bounding Box\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\n// intersection\nstruct its {\n    float t; // distance to intersection\n    int material; // MAT_GLOSSY or MAT_DIFFUSE\n    vec4 albedo; \n    vec3 position;\n    vec3 normal;\n};\n\nstruct Vertex\n{\n    its inter;\n    vec3 pos,normal,albedo;\n};\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\n\n// intersection routines\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\n\n\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 size)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(-size, size), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\t\tp /= size;\n\t\tif(abs(p.x) > abs(p.y)) {\n\t\t\tif(abs(p.x) > abs(p.z)) {\n\t\t\t\tnormal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t\t}\n\t\t}\n\t\telse if(abs(p.y) > abs(p.z)) {\n\t\t\tnormal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\telse {\n\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_light(Ray ray)\n{\n\tfloat t = intersect_plane(ray, g_light_position, g_light_normal);\n\n\tvec3 p = ray_at(ray, t);\n\tif(all(lessThan(abs(g_light_position - p).xz, vec2(g_light_size * 0.5)))) {\n\t\treturn t;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_sphere(in Ray ray, inout float t_max, inout vec3 normal, in vec3 c, in float r)\n{\n   \n    vec3 u = normalize(ray.dir);\n    vec3 o = ray.origin;\n   \n    float l_o_c = length(o-c);\n    \n    float det = dot(u, (o-c))*dot(u, (o-c)) - (l_o_c * l_o_c - r*r);\n    if( det < 0.0 )\n        return INFINITY;\n        \n    float t_min = - dot(u, (o-c)) - sqrt(det);\n    t_max = - dot(u, (o-c)) + sqrt(det);\n    \n    if( t_min > t_max ) {\n        float t1 = t_min;\n        t_min = t_max;\n        t_max = t1;\n    }\n    \n    if( t_min < 0. )\n        return INFINITY;\n    \n    vec3 p = ray_at(ray, t_min);\n    normal = normalize(p - c);\n    \n    return t_min;\n}\n\n\n\n\n// Intersect the scene by visiting each object\n\nits\nintersect(Ray ray)\n{\n\tfloat t_min = INFINITY;\n    its ret_its;\n    \n    ret_its.t = 0.0;\n    ret_its.material = MAT_UNDEF;\n    ret_its.albedo = vec4(0.0);\n\n\t{\n\t\tfloat t = intersect_light(ray);\n\t\tif(t < t_min) {\n\t\t\t//albedo = vec3(100);\n\t\t\tret_its.albedo = g_light_albedo;\n\t\t\t//albedo = vec3(dot(ray.dir, g_light_normal) < 0.0 ? 1.0 : 0.0);\n\t\t\tret_its.normal = g_light_normal;\n\t\t\tt_min  = t;\n\t\t\tret_its.position = ray_at(ray, t);\n            ret_its.material = MAT_EMISSION;\n\t\t}\n\t}\n\n    // small box\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\tray_tmp.origin -= vec3(0.5, -0.75, 0.35);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.25, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tret_its.position = ray_at(ray, t);\n\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tret_its.normal = normal_tmp;\n            ret_its.material = MAT_DIFFUSE;\n            //ret_its.material = MAT_GLOSSY;\n\t\t}\n\t}\n    //small box emission\n    {\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\tray_tmp.origin -= vec3(-0.5,-0.75,1);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.1, 0.1, 0.1));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tret_its.position = ray_at(ray, t);\n\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 2);\n\t\t\tret_its.normal = normal_tmp;\n            ret_its.material = MAT_EMISSION;\n            //ret_its.material = MAT_GLOSSY;\n\t\t}\n\t}\n    \n    // sphere\n    {\n       // vec3 c = vec3(-0.4, -0.4, -0.2);\n       // vec3 c = vec3(-0.0, -0.4, -0.5);\n        vec3 c = vec3(0, 0, 0);\n        float r = 0.4;\n        vec3 normal_tmp;\n     \n\t\tRay ray_tmp = ray;\n        float t_max;\n        \n\t\tfloat t = intersect_sphere(ray_tmp, t_max, normal_tmp, c, r);\n        if(t < t_min) {\n                t_min = t;\n                ret_its.position = ray_at(ray, t);\n                ret_its.albedo = vec4(0.1, 0.5, 0.2, 0);\n                ret_its.normal = normal_tmp;\n                ret_its.material = MAT_DIFFUSE;\n                ret_its.material = MAT_GLOSSY;\n        }\n    }\n\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tret_its.albedo = vec4(0.9, 0.1, 0.1, 0);\n                ret_its.material = MAT_DIFFUSE;\n                ret_its.material = MAT_GLOSSY;\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tret_its.albedo = vec4(0.1, 0.9, 0.1, 0);\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tret_its.normal = normalize(ret_its.normal);\n\n    ret_its.t = t_min;\n    \n\treturn ret_its;\n}\n\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\t\n\tits t_shadow = intersect(r);\n\n\treturn t_shadow.t > distance(p1, p2) - 2.0 * eps;\n}\n\n// BRDF routines\n\n// all vectors wcs\n\nvec3 WorldToLocal( vec3 v, vec3 ss, vec3 ts, vec3 ns)  {\n    \n    return vec3(dot(v, ss), dot(v, ts), dot(v, ns));\n}\n\nvec3 LocalToWorld( vec3 v, vec3 ss, vec3 ts, vec3 ns)  \n{\n    return vec3(ss.x * v.x + ts.x * v.y + ns.x * v.z,\n                    ss.y * v.x + ts.y * v.y + ns.y * v.z,\n                    ss.z * v.x + ts.z * v.y + ns.z * v.z);\n}\n\n// define tangent space; all vectors in *world frame*\nvoid\ndefineTangents(vec3 outdir, vec3 normal, inout vec3 s, inout vec3 t)\n{\n      s = cross(outdir, normal);\n      s = normalize(s);\n      t = cross(s, normal);\n      t = normalize(t);\n}\n\nvec3\ngetOutDir(its inters, vec3 s, vec3 t, vec3 indir, inout float theta, inout float phi)\n{\n    // TODO switch to ours\n    theta = phi = 0.0;\n    mat3 onb = construct_ONB_frisvad(inters.normal);\n    if( inters.material == MAT_DIFFUSE)\n        return normalize(onb * sample_cos_hemisphere(get_random()));\n    else if ( inters.material == MAT_GLOSSY ) {\n        vec2 rv  = get_random(); \n                \n        float phih = atan(tan(2.*PI*rv.y));               \n        float alphasq = g_alpha*g_alpha;\n                \n        float val = cos(phih)*cos(phih)/alphasq + sin(phih)*sin(phih)/alphasq;\n        float thh = atan(sqrt(-log(rv.x) / val));\n                \n        vec3 h = vec3(sin(thh)*cos(phih), sin(thh)*sin(phih), cos(thh)); \n        h = normalize(h);\n        \n        vec3 i = WorldToLocal(-indir, s, t, inters.normal);\n                \n        vec3 local_odir = 2. * (dot(i, h))*h - i;\n                \n        local_odir = normalize(local_odir);\n        \n        theta = thh;\n        phi = phih;\n                \n        vec3 wcs_odir = LocalToWorld(local_odir, s, t, inters.normal);\n        return wcs_odir;\n    }\n}\n\nfloat\ncdot(vec3 v1, vec3 v2)\n{\n    return max (0., dot(v1, v2));\n}\n\n\n// all vectors in local frame !\nfloat\nWardBRDF(vec3 i, vec3 o, float alpha, float rho) \n{\n    vec3 h = normalize(o + i) ; \n    vec3 n = vec3(0,0, 1.);\n    vec3 x = vec3(1., 0, 0);\n    vec3 y = vec3(0, 1., 0);\n    \n    float din = dot(i, n);\n    float don = dot(o, n);\n    \n     if( abs(din) < 0.5 && abs(don) < 0.5 ) din = don = 0.5;\n  \n \n    float denom = 4. * PI * alpha * alpha * sqrt(din*don);\n    \n    float p1 =  dot(h, x)/alpha;\n    float p2 =  dot(h, y)/alpha;\n    \n    float expon = -(p1*p1 + p2*p2)/(dot(h, n)*dot(h, n));\n        \n    float res =  rho / denom * exp(expon);\n     \n   return res ;  \n\n}\n\n\n// in local frame\nfloat\nWardPDF_w(vec3 o, vec3 i)\n{\n    vec3 n = vec3(0, 0, 1.);\n    vec3 h = normalize(i+o);\n    float dotcube = dot(h, n)*dot(h, n) * dot(h, n);\n    \n    float val =  dot(h, i) *(dotcube) * sqrt(dot(o, n)/dot(i, n));    \n    \n    return val;\n}\n\nfloat\nWardPDF(vec3 o, vec3 i, float thh, float phih)\n{\n    vec3 h = normalize(o+i);\n    float alphasq = g_alpha*g_alpha;\n                \n    float val = cos(phih)*cos(phih)/alphasq + sin(phih)*sin(phih)/alphasq;\n    \n    float cos3 = cos(thh)*cos(thh)*cos(thh);\n    \n    float fr = 1./(4.*PI*g_alpha*g_alpha*dot(h,i)*cos3);\n    \n    float rval = fr * exp( -tan(thh)*tan(thh)*val );\n    return  (rval);\n\n\n}\n\n\n\nvec3\nevalBRDF(its inter, inout float brdf_pdf, vec3 wcs_indir, vec3 wcs_outdir, vec3 s, vec3 t, float th, float ph)\n{\n    if( inter.material == MAT_DIFFUSE ) {\n        vec3 brdf = inter.albedo.rgb / PI;\n        brdf_pdf = 1.0 / PI;\n        return brdf;\n    }\n    else if( inter.material == MAT_GLOSSY ) {\n        vec3 local_idir =  normalize( WorldToLocal(wcs_indir, s, t, inter.normal  ));\n        vec3 local_odir =  normalize( WorldToLocal(wcs_outdir, s, t, inter.normal  )); \n  \n        vec3 brdf = g_rho_d * 1./PI * inter.albedo.rgb + g_rho_s * WardBRDF( local_idir, local_odir, g_alpha, g_rho_s);                    \n        brdf_pdf = g_rho_s * WardPDF(-local_odir, local_idir, th, ph);      \n     \n        return brdf;\n    }\n}\n\n// path tracing with MIS\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tvec4 albedo;\n\tits inters = intersect(ray);\n    \n    position = inters.position;\n    normal = inters.normal;\n    albedo = inters.albedo;\n    float t = inters.t;\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(albedo.a > 0.0) { /* hight light source */\n\t\treturn albedo.rgb * albedo.a;\n\t}\n\n    Ray localRay = ray;\n    \n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\t\n\n\t\t{ /* NEE */\n            vec3 pos_ls = sample_light(get_random());\n            \n\t\t\tvec3 l_nee = pos_ls - position;\n            \n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n            \n\t\t\tl_nee /= sqrt(rr_nee);\n            \n\t\t\tfloat G = max(0.0, dot(normal, l_nee)) * max(0.0, -dot(l_nee, g_light_normal)) / rr_nee;\n            \n            vec3 sv, tv;\n            \n            float theta =0.0, phi=0.0;\n        \n            defineTangents(localRay.dir, inters.normal, sv, tv);\n      \n\t\t\tif(G > 10.0) {\n\t\t\t\tfloat light_pdf = 1.0 / (g_light_area * G);\n\t\t\t\tfloat brdf_pdf;\n\n\t\t\t\tfloat w = light_pdf / (light_pdf + brdf_pdf);\n                \n                vec3 h_wcs = normalize(l_nee+localRay.dir);\n                vec3 h_local = WorldToLocal(h_wcs, sv, tv, inters.normal);\n                \n                float theta = acos(h_local.z);\n                float phi = h_local.y/(sin(theta));           \n\n\t\t\t\tvec3 brdf = evalBRDF(inters, brdf_pdf, l_nee, -localRay.dir, sv, tv, theta, phi);\n\n\t\t\t\tif(test_visibility(position, pos_ls)) {\n\t\t\t\t\tvec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n\t\t\t\t\tcontrib += tp * (Le * w * brdf) / light_pdf;\n\t\t\t\t}\t}\n            \n\t\t}\n        \n\t\n\n    { /* brdf */            \n            vec3 sv, tv;\n            \n            defineTangents(-localRay.dir, inters.normal, sv, tv);\n            float theta, phi;\n        \n\t\t\tvec3 dir = getOutDir(inters, sv, tv, localRay.dir, theta, phi);\n            \n        \n\t\t\tRay ray_next = Ray(position, dir);\n\t\t\tray_next.origin += ray_next.dir * 1e-5;\n            \n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tvec4 albedo_next;\n\t\t\tits inters_next = intersect(ray_next);\n            position_next = inters_next.position, normal_next = inters_next.normal, albedo_next = inters_next.albedo;\n            t = inters_next.t;\n           \n            \n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            float brdf_pdf;\n            \n            vec3 brdf = evalBRDF(inters, brdf_pdf, -dir, localRay.dir, sv, tv, theta, phi);\n\n\t\t\tif(albedo_next.a > 0.0) { /* hit light_source */\n\t\t\t\tfloat G = max(0.0, dot(ray_next.dir, normal)) * max(0.0, -dot(ray_next.dir, normal_next)) / (t * t);\n\t\t\t\tif(G <= 0.0) /* hit back side of light source */\n\t\t\t\t\tbreak;\n\n\t\t\t\tfloat light_pdf = 1.0 / (g_light_area * G);\n\n\t\t\t\tfloat w = brdf_pdf / (light_pdf + brdf_pdf);\n\n\t\t\t\tvec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n\t\t\t\tcontrib += tp * (Le * w * brdf) / brdf_pdf;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttp *= brdf / brdf_pdf;\n            \n            localRay = ray_next;\n\n            inters = inters_next;\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\talbedo = albedo_next;\n\t\t} \n\n\t}\n\n\n\treturn contrib;\n}\n\nvec3 l_pt(Ray light,int N,out its final_pos)\n{\n    vec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tvec4 albedo;\n\tits inters = intersect(light);\n    \n    position = inters.position;\n    normal = inters.normal;\n    albedo = inters.albedo;\n    float t = inters.t;\n\n    Ray inv=Ray(position,-light.dir);\n    its inv_l=intersect(inv);\n    vec3 l_norm=inv_l.normal;\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n    Ray localLight = light;\n    \n    // First Intersection\n    \n    vec3 sv, tv;\n            \n    defineTangents(-localLight.dir, inters.normal, sv, tv);\n    float theta, phi;\n\n    vec3 dir = getOutDir(inters, sv, tv, localLight.dir, theta, phi);\n\n\n    Ray light_next = Ray(position, dir);\n    light_next.origin += light_next.dir * 1e-5;\n    \n    \n    \n    \n    float brdf_pdf;\n            \n    vec3 brdf = evalBRDF(inters, brdf_pdf, -dir, localLight.dir, sv, tv, theta, phi);\n    float G = max(0.0, dot(-light.dir,l_norm )) * max(0.0, -dot(-light.dir, normal)) / (t * t);\n    \n    float light_pdf = 1.0 / (g_light_area * G);\n\n    float w = brdf_pdf / (light_pdf + brdf_pdf);\n\n    vec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n    tp = (Le * w * brdf) / brdf_pdf;\n\n    its inters_next = intersect(localLight);\n    vec3 position_next = inters_next.position, normal_next = inters_next.normal;\n    vec4 albedo_next = inters_next.albedo;\n    t = inters_next.t;\n\n    localLight = light_next;\n   \n    inters = inters_next;\n    final_pos=inters;\n    position = position_next;\n    normal = normal_next;\n    albedo = albedo_next;\n\n\tfor(int i = 1; i <N; i++) {\n\n    { /* brdf */            \n\t\t\tvec3 position_next, normal_next;\n\t\t\tvec4 albedo_next;\n\t\t\tits inters_next = intersect(localLight);\n            position_next = inters_next.position, normal_next = inters_next.normal, albedo_next = inters_next.albedo;\n            t = inters_next.t;\n           \n            \n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            float brdf_pdf;\n            \n            vec3 brdf = evalBRDF(inters, brdf_pdf, dir, -localLight.dir, sv, tv, theta, phi);\n\n\t\t\ttp *= brdf / brdf_pdf;\n            \n            localLight = light_next;\n            \n            inters = inters_next;\n            final_pos=inters;\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\talbedo = albedo_next;\n\t\t} \n\n\t}\n    \n\treturn tp;\n}\n\n\nvec3 bdpt_simple(Ray ray,Ray light,int nb_c,int N)\n{\n    vec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tvec4 albedo;\n\tits inters = intersect(ray);\n    \n    position = inters.position;\n    normal = inters.normal;\n    albedo = inters.albedo;\n    float t = inters.t;\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(albedo.a > 0.0) { /* hight light source */\n\t\treturn albedo.rgb * albedo.a;\n\t}\n\n    Ray localRay = ray;\n    \n\tfor(int i = 0; i <nb_c; i++) {\n\n\n    { /* brdf */            \n            vec3 sv, tv;\n            \n            defineTangents(-localRay.dir, inters.normal, sv, tv);\n            float theta, phi;\n        \n\t\t\tvec3 dir = getOutDir(inters, sv, tv, localRay.dir, theta, phi);\n            \n        \n\t\t\tRay ray_next = Ray(position, dir);\n\t\t\tray_next.origin += ray_next.dir * 1e-5;\n            \n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tvec4 albedo_next;\n\t\t\tits inters_next = intersect(ray_next);\n            position_next = inters_next.position, normal_next = inters_next.normal, albedo_next = inters_next.albedo;\n            t = inters_next.t;\n           \n            \n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            float brdf_pdf;\n            \n            vec3 brdf = evalBRDF(inters, brdf_pdf, -dir, localRay.dir, sv, tv, theta, phi);\n\n\t\t\tif(albedo_next.a > 0.0) { /* hit light_source */\n\t\t\t\tfloat G = max(0.0, dot(ray_next.dir, normal)) * max(0.0, -dot(ray_next.dir, normal_next)) / (t * t);\n\t\t\t\tif(G <= 0.0) /* hit back side of light source */\n\t\t\t\t\tbreak;\n\n\t\t\t\tfloat light_pdf = 1.0 / (g_light_area * G);\n\n\t\t\t\tfloat w = brdf_pdf / (light_pdf + brdf_pdf);\n\n\t\t\t\tvec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n\t\t\t\tcontrib += tp * (Le * w * brdf) / brdf_pdf;\n\n\t\t\t\treturn contrib;\n\t\t\t}\n\n\t\t\ttp *= brdf / brdf_pdf;\n            \n            localRay = ray_next;\n\n            inters = inters_next;\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\talbedo = albedo_next;\n\t\t} \n     }\n        // If the camera path doesn't find the light but is in range of light \n        if (nb_c!=N)\n        {\n        vec3 pos_ls = sample_light(get_random());\n            \n        vec3 l_nee = pos_ls - position;\n\n        float rr_nee = dot(l_nee, l_nee);\n\n        l_nee /= sqrt(rr_nee);\n\n        float G = max(0.0, dot(normal, l_nee)) * max(0.0, -dot(l_nee, g_light_normal)) / rr_nee;\n\n        vec3 sv, tv;\n\n        float theta =0.0, phi=0.0;\n\n        defineTangents(localRay.dir, inters.normal, sv, tv);\n\n        if(G > 0.0) \n        {\n            float light_pdf = 1.0 / (g_light_area * G);\n            float brdf_pdf;\n\n            float w = light_pdf / (light_pdf + brdf_pdf);\n\n            vec3 h_wcs = normalize(l_nee+localRay.dir);\n            vec3 h_local = WorldToLocal(h_wcs, sv, tv, inters.normal);\n\n            float theta = acos(h_local.z);\n            float phi = h_local.y/(sin(theta));           \n\n            vec3 brdf = evalBRDF(inters, brdf_pdf, l_nee, -localRay.dir, sv, tv, theta, phi);\n\n            if(test_visibility(position, pos_ls)) \n            {\n                vec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n                contrib += tp * (Le * w * brdf) / light_pdf;\n                return contrib;\n            }\t\n        }\n        }\n        \n        // Apply the light subpath if the camera path doesn't find the light or is in range of light\n        if (nb_c!=N)\n        {\n            its final_pos;\n            vec3 l_tp=l_pt(light,N-nb_c,final_pos);\n\n            vec3 next_pos=final_pos.position;\n            vec3 next_normal=final_pos.normal;\n\n            vec3 l_sub = next_pos - position;\n\n            float rr_sub = dot(l_sub, l_sub);\n\n            l_sub /= sqrt(rr_sub);\n\n            float G = max(0.0, dot(normal, l_sub)) * max(0.0, -dot(l_sub, next_normal)) / rr_sub;\n\n             vec3 sv, tv;\n\n             float theta =0.0, phi=0.0;\n\n            defineTangents(localRay.dir, inters.normal, sv, tv);\n            float brdf_pdfl;\n\n            vec3 brdfl = evalBRDF(inters, brdf_pdfl, l_sub, -localRay.dir, sv, tv, theta, phi);\n\n             if(test_visibility(position, next_pos)) \n            {\n\n                    contrib += tp * l_tp*brdfl/brdf_pdfl;\n                    return contrib;\n            }\t\n        }\n        \n\n}\n\n\n\n    \n   \n\n\n\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    g_light_size = 1.;\n\tg_light_area = g_light_size * g_light_size;\n    \n\t// Uncomment to make light move (comment following line)\n    //g_light_position = vec3(0.5 * sin(iTime), 0.95, 0.5 * cos(iTime));\n    \n    g_light_position = vec3 (0, 0.9, 0 );\n\tg_light_normal = vec3(0, -1, 0);\n\tg_seed = 0;\n\tg_light_albedo = vec4(1, 1, 1, 2.0 / (g_light_size * g_light_size));\n\tg_flat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n    vec4 m = iMouse / iResolution.x;\n\n\tif( m.z>0.0 ) { // button is down\n        sphere2_center = sphere2_center +  vec3(-0.1, 0., 0.3);\n        // move light down\n        g_light_position += vec3(0, -0.4, 0);\n    }\n    \n    // Make image square\n\tvec2 p = fragCoord.xy  / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\tvec3 cam_center = vec3(0, 0, 3.125);\n\n\tvec3 s = vec3(0);\n    \n    // trace NUM_SAMPLES per pixel\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n        \n        Ray light;\n        light.origin=g_light_position;\n        \n        // get random 2-D vector\n\t\tvec2 r = get_random();\n        \n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -1));\n\t\tray.dir = ray_dir;\n        \n         // get the light ray\n        vec2 l = get_random();\n        \n\t\tvec3 l_dir = normalize(vec3(p - r.x * dFdx(p) - r.y * dFdy(p), -1));\n\t\tlight.dir = l_dir;\n        \n        // do path tracing and MIS \n\t\tvec3 c = bdpt_simple(ray,light,6,6);\n       \n        // accumulate color in variable s\n\t\ts += c;\n        }\n\n\tfragColor = vec4(pow(s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}