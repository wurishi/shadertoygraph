{"ver":"0.1","info":{"id":"Mcc3WB","date":"1712747324","viewed":64,"name":"Cell Bombing","username":"Ade0n","description":"Cell bombing implementation from UE5 Matrix Demo (Ocean)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cellbombing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Taken from UE5 Matrix demo, iChannel0 should be a custom voronoi texture, othervise it won't work\n\n\n// May need frac - artifacts in shadertoy if use fract\nvec2 AnimateUV(vec2 UV, float Time, vec2 Speed) {\n    return (UV + Time * Speed);\n}\n\nvec3 Normal4WayMotion(vec2 UV, float Time) {\n    vec3 sampleTR = texture(iChannel1, AnimateUV(UV, Time * 0.1f, vec2(0.1, 0.1))).rgb;\n    vec3 sampleTL = texture(iChannel1, AnimateUV(UV + vec2(0.4181, 0.3548), Time * 0.1f, vec2(-0.1, 0.1))).rgb;\n    vec3 sampleBR = texture(iChannel1, AnimateUV(UV + vec2(0.8648, 0.1483), Time * 0.1f, vec2(0.1, -0.1))).rgb;\n    vec3 sampleBL = texture(iChannel1, AnimateUV(UV + vec2(0.6513, 0.7516), Time * 0.1f, vec2(-0.1, -0.1))).rgb;\n\n    return ((sampleTR + sampleBL) + (sampleTL + sampleBR)) * 0.25f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // In normal usage, uv = world coords\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float globalScale = 1.0f;\n    float patternScale = 1.0f;\n    float cellScale = 0.1f;\n    \n    float randomOffsetVariation = 1.0f;\n\n    \n    uv *= globalScale;\n    uv = fract(uv);\n\n    vec2 baseUV = fract(uv * patternScale);\n    vec2 noiseUV = fract(uv * cellScale);\n    \n    vec4 noise = texture(iChannel0, noiseUV);\n    noise *= randomOffsetVariation;\n    noise.a = 0.0;\n    \n\n    vec3 baseColor = Normal4WayMotion(baseUV, iTime);\n    vec3 noiseColor = Normal4WayMotion(baseUV + noise.xy, iTime);\n    \n    vec3 color = mix(baseColor, noiseColor, noise.a);\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}