{"ver":"0.1","info":{"id":"4fcyWB","date":"1731581549","viewed":205,"name":"Domino Constraint","username":"smjty","description":"Just solving some iterative constraints for fun. You control the red box using the mouse and all other boxs' rotation is calculated.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["2d","box","constraint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Twitter: @smjtyazdi\n#define PI 3.14159265\n#define PI2 1.570796325\n\nconst float scale = 0.06;\n\nconst float a = 4.0;\nconst float b = 0.6;\nconst float L = 1.0;//should be larger than b\nconst float box_count = 10.;\n\nconst float t_min = asin(b/L);\nconst float t_flip = acos((L-b)/a);\nconst float t_sym = acos((L-b)/a/2.);\n\nvec2 rot(vec2 p ,float t){\n    return vec2(p.x*cos(t) + p.y*sin(t), p.y*cos(t)-p.x*sin(t));\n}\n\nfloat box(vec2 p , vec2 s){// smooth 2d box\n    vec2 d = abs(p-vec2(-s.x, s.y)) - vec2(s.x, s.y) + vec2(0.02);\n    float value = length(max(d, 0.0)) + min(max(d.x,d.y), 0.0);\n    return 0.5 + 0.5*cos(clamp(value*30., 0., 1.)*PI);\n}\n\n\nfloat constraint(float t0){   \n    float c0 = cos(t0), s0 = sin(t0);\n    \n    if(t0<t_flip){\n        float g = sqrt(a*a - b*b+L*L - 2.*a*L*c0);\n        float c1 = -g*L + a*g*c0 + a*b*s0;\n        float s1 = b*L - a*b*c0 + a*g*s0;\n        return PI2 - atan(c1, s1);\n    }\n\n    if(t0<t_sym){\n        float c1 = b+a*c0-L;\n        float s1 = a*s0;\n        return PI2 - atan(c1, s1);\n    }\n    \n    if(t0<PI2){\n        float g = c0*(L-b)+sqrt(a*a - s0*s0*(L-b)*(L-b));\n        float c1 = b+c0*g-L;\n        float s1 = g*s0;\n        return PI2 - atan(c1, s1);\n    }\n    \n    {\n        float f = L*s0 - b;\n        float g = c0*L + sqrt(a*a - f*f);\n        float c1 = (c0*g - L + b*s0);\n        float s1 = -b*c0 + g*s0;\n\n        return PI2 - atan(c1 , s1);\n    }\n}\n\n\nvec3 render(vec2 p, float ts){\n    \n    p += vec2(-b/2., 2.);\n\n    vec3 col = vec3(0.);\n\n    bool reflection = p.y<0.;\n    p.y = abs(p.y);\n\n    vec2 bs = vec2(b,a)/2.;\n    \n    float last_theta = 0.;    \n    float theta = PI2 + (PI2-t_min) * cos(ts) ;\n    \n    // c = 0 for boxes on right and c = 1 for boxes on the left\n    for(int c = 0; c<2; c++){\n        for(float n = (c==0)?0.:1.; n<box_count; n+=1.){   \n\n            if(n>0.)theta = (c==0) ? constraint(last_theta) : PI - constraint(PI - last_theta); \n\n            vec2 ps = vec2(n*L, 0.) * ((c==0)?1.:-1.);\n\n            if(theta<PI2) col += box(rot(p - ps, -PI2+ theta), bs);\n            else{\n                vec2 pg = rot(p - ps + vec2(b, 0.), -PI2 + theta);\n                col += box(vec2(-pg.x, pg.y) ,bs);\n            }\n\n            if(n==0.)col.yz*=0.5;\n\n            last_theta = theta;\n        }\n        \n        last_theta = PI2 + (PI2 - t_min) * cos(ts) ;\n    }\n\n    \n    if(reflection) col = mix(vec3(0.3), vec3(0.7), col);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - iResolution.xy/2.0)/(scale*iResolution.y);\n    vec2 mouse_pos = (iMouse.xy - iResolution.xy/2.0)/(iResolution.y);\n\n    float ts = (iMouse.z>.5) ? acos(-clamp(mouse_pos.x * 1.2, -1., 1.)) : iTime*PI2;    \n    \n    fragColor = vec4(render(p, ts),1.0);\n    \n}","name":"Image","description":"","type":"image"}]}