{"ver":"0.1","info":{"id":"wlSSDG","date":"1566915990","viewed":138,"name":"ColoredRayMarchingObjects","username":"Fogrex","description":"PaintedObjects with raymarching\nYou can move the camera by dragging.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PI2 6.28318530718\n\nconst int STEP = 128;\nconst float NEAR = 2.0;\nconst vec3 LIGHT_DIR = normalize(vec3(1.0,-1.0,1.0));\n\nstruct Ray\n{\n    vec3 direction;\n    vec3 origin;\n    vec4 color;\n    bool frag;\n};\n\nstruct Dist\n{\n    float dist;\n    vec4 color;\n};\n\n\n//transform function(inverse)\nvec3 transform(vec3 pos, vec3 move, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * m * p).xyz;\n}\n\nvec3 translate(vec3 pos, vec3 move)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n   \n    return (m * p).xyz;\n}\n\nvec3 rotate(vec3 pos, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * p).xyz;\n}\n\n// distance functions\nDist sphere(vec3 p, float r, vec4 col)\n{\n    Dist d;\n    d.dist = length(p) - r;\n    d.color = col;\n    return d;\n}\n\nDist box(vec3 pos, vec3 size, vec4 col)\n{\n    vec3 dd = abs(pos) - size;\n    Dist d;\n    d.dist = length(max(dd,0.0))+ min(max(dd.x,max(dd.y,dd.z)),0.0);\n    d.color = col;\n    return d;\n}\n\nDist cylinder(vec3 pos, float r, vec4 col)\n{\n    Dist d;\n    d.dist = length(pos.xz) - r;\n    d.color = col;\n    return d;\n}\n\nDist plane(vec3 pos, float h, vec4 col)\n{\n    Dist d;\n    d.dist = pos.y - h;\n    d.color = col;\n    return d;\n}\n\n// mixing shapes\nDist nsUnion(Dist d1, Dist d2)\n{\n    if(d1.dist < d2.dist) return d1;\n    return d2;\n}\nDist nsSubtraction(Dist d1, Dist d2)\n{\n    if(-d1.dist < d2.dist) return d2;\n    d1.dist *= -1.0;\n    return d1;\n}\nDist nsIntersection(Dist d1, Dist d2)\n{\n    if(d1.dist < d2.dist) return d2;\n    return d1;\n}\n\nDist sUnion(Dist d1, Dist d2, float k)\n{\n    Dist d;\n    float h = clamp(0.5 + 0.5*(d2.dist-d1.dist)/k, 0.0, 1.0);\n    d.dist = mix(d2.dist, d1.dist, h) - k*h*(1.0-h);\n    d.color = mix(d2.color, d1.color, h);\n    return d;\n}\n\nDist sSubtraction(Dist d1, Dist d2, float k)\n{\n    Dist d;\n    float h = clamp(0.5 - 0.5*(d2.dist+d1.dist)/k, 0.0, 1.0);\n    d.dist = mix(d2.dist, -d1.dist, h) + k*h*(1.0-h);\n    d.color = mix(d2.color, d1.color, h);\n    return d;\n}\nDist sIntersection(Dist d1, Dist d2, float k)\n{\n    \n    Dist d;\n    float h = clamp(0.5 - 0.5*(d2.dist-d1.dist)/k, 0.0, 1.0);\n    d.dist = mix(d2.dist, d1.dist, h) + k*h*(1.0-h);\n    d.color = mix(d2.color, d1.color, h);\n    return d;\n}\n\n\n//mapping\nDist map(vec3 pos)\n{\n    \n    Dist s1 = sphere(pos, 1.2, vec4(0.0,1.0,0.0,1.0));\n    Dist b1 = box(pos, vec3(1.0,1.0,1.0), vec4(0.0,0.0,1.0,1.0));\n    Dist bss = sSubtraction(s1,b1, 0.5);\n    float r = 0.3;\n    float k = 2.0;\n    float d = 1.5;\n    vec3 rot = vec3(iTime*0.57, iTime*0.73, iTime*1.12)*0.3;\n    vec4 col = vec4(1.0,0.0,0.0,1.0);\n    bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(d,d,d)),r,col),k);\n    bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(d,-d,-d)),r,col),k);\n    bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(-d,d,-d)),r,col),k);\n    bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(-d,-d,d)),r,col),k);\n    \n    bss = sUnion(bss, plane(pos, -3.0, vec4(1.0,1.0,1.0,1.0)),k);\n    return bss;\n    \n}\n\n// calculating normal\nvec3 calcNorm(vec3 pos)\n{\n    float d = 0.0001;\n    float center = map(pos).dist;\n    vec3 grad = vec3(map(pos+vec3(d,0.0,0.0)).dist-center, map(pos+vec3(0.0,d,0.0)).dist-center, map(pos+vec3(0.0,0.0,d)).dist-center);\n    return normalize(grad / d);\n}\n\n// lambert model\nvec4 lambert(vec3 pos)\n{\n    vec3 n = calcNorm(pos);\n    float b = max(0.0, dot(n, -LIGHT_DIR))*0.8+0.2;\n    return vec4(b, b, b, 1.0);\n}\n\nvec4 visualizeNormal(vec3 pos)\n{\n    return vec4(calcNorm(pos),1.0)*0.8 + vec4(1.0,1.0,1.0,1.0)*0.2;\n}\n\n// raymarching\nRay raymarch(Ray r)\n{\n    vec3 pos = r.origin;\n    vec3 dir = r.direction;\n    \n    Dist d;\n    \n    for(int i=0;i<STEP;i++)\n    {\n        d = map(pos);\n        if(d.dist < 0.0001)\n        {\n            \n            r.origin = pos;\n            r.color = d.color * lambert(pos);\n            r.frag = false;\n            return r;\n        }\n        pos = pos + dir * d.dist;\n    }\n    r.frag = true;\n    r.color = texture(iChannel0, dir);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 fc = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(fc, NEAR));\n    vec3 pos = vec3(fc, NEAR);\n    \n    \n    // camera moving\n    pos = translate(pos, vec3(0.0,0.0,10.0));\n    \n    //camera rotating\n    float rx = (iMouse.x/iResolution.x*2.0 - 1.0) * PI;\n    float ry = (iMouse.y/iResolution.y*2.0 - 1.0) * PI * 0.5;\n    pos = rotate(pos, vec3(ry,-rx,0.0));\n    ray = rotate(ray, vec3(ry,-rx,0.0));\n    \n    Ray r;\n    r.direction = ray;\n    r.origin = pos;\n    r.color = vec4(0.0,0.0,0.0,1.0);\n    r.frag = false;\n    \n    \n    r = raymarch(r);\n    fragColor = r.color;\n}","name":"Image","description":"","type":"image"}]}