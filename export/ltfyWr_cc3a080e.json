{"ver":"0.1","info":{"id":"ltfyWr","date":"1504297215","viewed":472,"name":"SIV cellular automaton","username":"JaumeRibas","description":"(Wait a little for the pattern to show up)\n\nDrag mouse to pan, 'Z' zoom in, 'X' zoom out.\n\nAbelian Sandpile lookalike cellular automaton.\n\nDefinition: https://github.com/JaumeRibas/Aether2DImgMaker/wiki/SIV-Cellular-Automaton-Definition","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["2d","cellularautomaton","vonneumannneighborhood","abeliansandpile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tZooming in, mouse panning and mirroring grid\n*/\n\nconst vec4 outOfBoundsColor = vec4(1.,0.,0.,1);\n\nvec2 getSymmetricCoords(vec2 coords) {\n\tif (coords.x < 0.) coords.x = -coords.x;\n    if (coords.y < 0.) coords.y = -coords.y;\n    if (coords.y > coords.x) {\n        float swp = coords.y;\n        coords.y = coords.x;\n        coords.x = swp;\n    }\n    return coords;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 resolution = iChannelResolution[0];\n    float omniZoom = texture(iChannel1, vec2(0.5,0.5)/iChannelResolution[1].xy)[0];\n\tvec2 zoom = vec2(omniZoom,omniZoom);\n    vec2 viewCoords;\n    bool useDefaultViewCoords = \n        texture(iChannel1, vec2(2.5,0.5)/iChannelResolution[1].xy)[2] == 1.;\n    if (useDefaultViewCoords) {\n   \t\tviewCoords = iResolution.xy/2.;\n    } else {\n        viewCoords = iMouse.xy;\n    }\n    vec2 offset = ((viewCoords/iResolution.xy)*((2.*resolution.xy)-(iResolution.xy/zoom)))-resolution.xy;\n    vec2 newCoords = vec2(\n       \tfloor((fragCoord.x/zoom.x) + offset.x), //floor to avoid blending\n      \tfloor((fragCoord.y/zoom.y) + offset.y));\n    newCoords = getSymmetricCoords(newCoords);\n    //+0.5 because actual coords are 0.5, 1.5, 2.5,.. instead of 0, 1, 2,...\n    newCoords += 0.5;\n    vec4 color;\n    if (newCoords.x < -resolution.x || newCoords.x > resolution.x\n        || newCoords.y < -resolution.y || newCoords.y > resolution.y) {\n    \tcolor = outOfBoundsColor;\n    } else {\n    \tcolor = texture(iChannel0, newCoords/resolution.xy);\n    }\n\tfragColor = color; \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tCellular automaton\n*/\n\n//initial configuration\nconst int initialValue = 100000;//increase for a bigger 'thing'\nconst int backgroundValue = 0;\n\nvec4 getPosition(ivec2 coords){\t\n\tvec3 resolution = iChannelResolution[0];\n\tvec4 position = texture(iChannel0, \n      \t//+0.5 because actual coords are 0.5, 1.5, 2.5,.. instead of 0, 1, 2,...\n\t\tvec2((float(coords.x) + 0.5)/resolution.x, \n             (float(coords.y) + 0.5)/resolution.y)\n    );\n    return position;\n}\n\nvec4 getSymmetricPosition(ivec2 coords) {\n\tif (coords.x < 0) coords.x = -coords.x;\n    if (coords.y < 0) coords.y = -coords.y;\n    if (coords.y > coords.x) {\n        int swp = coords.y;\n        coords.y = coords.x;\n        coords.x = swp;\n    }\n\treturn getPosition(coords);\n}\n\n//SIV cellular automaton\nvec4 sivCA(ivec2 coords, int backgroundValue) {\n    vec4 position;\n\tvec3 resolution = iChannelResolution[0];\n\tint self, right, left, up, down;\n\tbool error = false, isEdgingPosition= false;\n\tposition = getSymmetricPosition(coords);\n\terror = position[2] != 0.;\n\tself = int(position[0]);\n\tif (coords.x < int(resolution.x) - 1) {\n\t\tposition = getSymmetricPosition(ivec2(coords.x + 1, coords.y));\n\t\terror = error || position[2] != 0.;\n\t\tright = int(position[0]);\n\t} else {\n\t\tisEdgingPosition = true;\n\t\tright = backgroundValue;\n\t}\n\tposition = getSymmetricPosition(ivec2(coords.x - 1, coords.y));\n\terror = error || position[2] != 0.;\n\tleft = int(position[0]);\n\tif (coords.y < int(resolution.y) - 1) {\n\t\tposition = getSymmetricPosition(ivec2(coords.x, coords.y + 1));\n\t\terror = error || position[2] != 0.;\n\t\tup = int(position[0]);\n\t} else {\n\t\tisEdgingPosition = true;\n\t\tup = backgroundValue;\n\t}\n\tposition = getSymmetricPosition(ivec2(coords.x, coords.y - 1));\n\terror = error || position[2] != 0.;\n\tdown = int(position[0]);\n\tif (self == backgroundValue \n        && right == backgroundValue && left == backgroundValue \n        && up == backgroundValue && down == backgroundValue) {\n\t\tif (error) {\n\t\t\t//position with error\n\t\t\tposition = vec4(0., 0.,1.,0.);\n\t\t} else {\n\t\t\tposition = vec4(backgroundValue, 0.,0.,0.);\n\t\t}\n\t} else {\n\t\tif (error || isEdgingPosition) {\n\t\t\t//position with error\n\t\t\tposition = vec4(0., 0.,1.,0.);\n\t\t} else {\n            //SIV\n\t\t\tint value = self - 4*(self/5) \n\t\t\t\t+ (right/5) + (left/5) + (up/5) + (down/5);\n            \n\t\t\tposition = vec4(value, 0.,0.,0.);\n\t\t}\n\t}\n    return position;\n}\n\nvoid mainImage( out vec4 newPosition, in vec2 floatCoord )\n{\n    ivec2 coords = ivec2(int(floatCoord.x), int(floatCoord.y));    \n    vec4 position;\n    if (coords.x >= coords.y) {\n    \tint value;\n        if (iFrame == 0) {\n            //initial configuration\n            if (coords.x == 0 && coords.y == 0) {\n                value = initialValue;\n            } else {\n                value = backgroundValue;\n            }\n            position = vec4(value, 0.,0.,0.);\n        } else {\n            position = sivCA(coords, backgroundValue);\n        }\n    } else {\n        //exclude symmetric positions\n    \tposition = vec4(0., 1.,0.,0.);\n    }\n    newPosition = position;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\tColor mapping\n*/\n\nconst int min = 0;\nconst vec4 red = vec4(1.,0.,0.,1.);\nconst vec4 white = vec4(1.,1.,1.,1.);\n\n//minBrightness in [0-255] range\nvec4 grayscaleMap(int minBrightness, int minValue, int maxValue, int value) {\n    if (value < minValue || value > maxValue )\n        //error\n        return white;//white goes unnoticed\n    int range = maxValue - minValue;\n\tfloat brightnessIncreasePerUnit;\n\tif (range > 0)\n\t\tbrightnessIncreasePerUnit = float(255 - minBrightness)/float(range);\n\telse\n\t\tbrightnessIncreasePerUnit = 0.;\n    float brightness = (float(value - minValue)*brightnessIncreasePerUnit \n                        + float(minBrightness))/float(255);\n\treturn vec4(brightness, brightness, brightness, 1);\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//hueRange in [0-255] range\nvec4 hueMap(int hueRange, int minValue, int maxValue, int value) {\n    if (value < minValue || value > maxValue )\n        //error\n        return red;\n    int range = maxValue - minValue;\n\tfloat hueIncreasePerUnit;\n\tif (range > 0)\n\t\thueIncreasePerUnit = float(hueRange)/float(range);\n\telse\n\t\thueIncreasePerUnit = 0.;\n    float hue = (float(value - minValue)*hueIncreasePerUnit + float(255 - hueRange))/255.;\n\t\thue = fract(hue + 1./6.);\n\t\thue = 1. - hue;\n\treturn vec4(hsv2rgb(vec3(hue, 1., 1.)), 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 position = texture(iChannel0, uv); \n    int max = int(texture(iChannel1, vec2(1.5, 0.5)/iChannelResolution[1].xy));\n    vec4 color;\n    if (position[1] == 0.) {//not excluded\n        if (position[2] == 0.) {//without error\n            int value = int(position[0]);\n    \t\tcolor = grayscaleMap(0, min, max, value);\n            //color = hueMap(215, min, max, value);\n        } else {\n        \tcolor = red;//should stand out (change according to colormap used)\n        }\n    } else {\n    \tcolor = vec4(0.,0.,0.,1.);\n    }\n    fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n\tGlobals\n*/\n#define ASCII_Z 90\n#define ASCII_X 88\n\nconst float zoomSpeed = 0.1;\n\n//https://www.shadertoy.com/view/lsXXzN\nbool keyClick(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nint getMaxValue() {\n    int max = 0;\n    //ugly trick to find the max value\n    //assumes max value is around center\n    for (float x = 0.5; x <= 2.5; x++) {\n    \tfor (float y = 0.5; y <= 1.5; y++) {\n            vec4 maxPosition = texture(iChannel1, vec2(x, y)/iChannelResolution[1].xy); \n            if (maxPosition[2] == 0.) {\n                int value = int(maxPosition[0]);\n                if (value > max)\n                    max = value;\n            }\n        }\n    }\n    return max;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iFrame == 0) {\n        \tfragColor = vec4(3.,0.,0.,0.);\n        } else {\n            vec2 uv = fragCoord / iResolution.xy;\n            vec4 textel = texture(iChannel0,uv);\n        \tif (keyClick(ASCII_Z)) {\n                float zoom = textel[0];\n                zoom += zoomSpeed;\n                textel[0] = zoom;\n            } else if (keyClick(ASCII_X)) {\n                float zoom = textel[0];\n                if (zoom - zoomSpeed > 0.)\n                    zoom -= zoomSpeed;\n                textel[0] = zoom;\n            }\n            fragColor = textel;\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        vec2 uv = fragCoord / iResolution.xy;\n    \tvec4 textel = texture(iChannel0,uv);\n        textel[0] = float(getMaxValue());\n        fragColor = textel;\n    } else if (fragCoord == vec2(2.5, 0.5)) {\n        if (iFrame == 0) {\n        \tfragColor = vec4(iMouse.xy,1.,0.);\n        } else {\n            vec2 uv = fragCoord / iResolution.xy;\n            vec4 textel = texture(iChannel0,uv);\n            if (iMouse.xy != textel.xy) {\n                textel[2] = 0.;\n            }\n            fragColor = textel;\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}