{"ver":"0.1","info":{"id":"4fy3zc","date":"1713042592","viewed":120,"name":"Fork Simple Water Wave","username":"mehow_one","description":"Experimenting wit simple staggered pressure and velocity grids.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["wavesimulation"],"hasliked":0,"parentid":"3lyczW","parentname":"Simple Water Wave Simulation"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bernoulli Lemniscate: http://mathworld.wolfram.com/Lemniscate.html\n\n\n\nvec3 dispersion(vec2 uv,vec2 rd,vec2 normal){\n    \n    \n    float uIor = 1./1.44;\n    vec3 color = vec3(0.0);\n    float uChromaticAberration = 0.91;\n    float uRefractPower = 0.225;\n    int LOOP = 8;\n    for (int i = 0; i < LOOP; i++) {\n    float slide = (float(i) / float(LOOP)) * 0.1;\n      vec2 refractVec = mix(normal, rd, uIor);\n      float r = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 0.5;\n      float y = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 +\n                 texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y * 2.0 -\n                 texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z) / 6.0;\n      float g = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.0) * uChromaticAberration).y * 0.5;\n      float c = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).y * 2.0 +\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).z * 2.0 -\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).x) / 6.0;\n      float b = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 3.0) * uChromaticAberration).z * 0.5;\n      float p = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z * 2.0 +\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 -\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y) / 6.0;\n\n      float re = r + (2.0*p + 2.0*y - c)/3.0;\n      float gr = g + (2.0*y + 2.0*c - p)/3.0;\n      float bl = b + (2.0*c + 2.0*p - y)/3.0;\n\n      color.r += re;\n      color.g += gr;\n      color.b += bl;\n      //color += remapShadows(vec4(color,1.)).rgb*.000125;\n  \n}\n    color /= float(LOOP);\n    \n    return color;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 wave = texture(iChannel0,uv);\n    vec4 image = vec4(vec3(0.1),0.);//texture(iChannel2,uv + wave.xy/100.0);\n    float light = 0.0;\n    \n    vec2 lightAngle = vec2(-0.5,-0.5);\n    light += pow(max(length(lightAngle) - length(wave.xy - lightAngle),0.0)/(length(lightAngle)+0.02),6.0);\n    vec3 col = dispersion(uv,vec2(0),wave.xy * (wave.z))+light;\n    //col *= (0.8+vec3(smoothstep(0.0, 0.1, pow(max(min(wave.x,wave.y),wave.z)/sqrt(3.0), 2.0)))*.2);\n    fragColor = vec4(col,1.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nx = horizontal velocity\ny = vertical velocity\nz = pressure\n*/\n\n/*\nVery cru\n*/\n\n// http://mathworld.wolfram.com/Lemniscate.html\nvec2 getLemniscate(float t){\n    float a = 1.5;\n    return vec2((a * cos(t)) / (1.0 + (sin(t) * sin(t))), \n                (a * sin(t) * cos(t))/ (1.0 + (sin(t) * sin(t))));\n}\n/*\n\nfloat segment ( vec2 p, vec2 a, vec2 b ) {\n    \n    float h; b = b-a; a = p-a;\n    h = clamp( dot(a,b)/dot(b,b), 0.0, 1.0 );\n    return distance( a, h*b );\n    \n}\n\nreally cool integration from https://www.shadertoy.com/view/dsffzl\nA sine-less vs unrolled\nfloat lemniscate ( vec2 p ) {\n\n    p = abs(p); float a = 0.0, b = 1.0;\n    \n    float H1 = p.x+p.y; float H3 = 3.0*H1;\n    float H2 = p.x-p.y; float H4 = 3.0*H2;\n    \n    for ( int i = 0; i < 6; i ++ ) {\n    \n        float t = (a+b)/2.0;\n        \n        float E = t*(t*(t*t*(t*(t*H2-2.0)+H3)-H4)+2.0)-H1;\n    \n        ( E < 0.0 ) ? a = t : b = t;\n    \n    }; float u = a*a*a, v = b*b*b;\n    \n    vec2 q1 = vec2(a+u,a-u)/(a*u+1.0);\n    vec2 q2 = vec2(b+v,b-v)/(b*v+1.0);\n    \n    return segment(p,q1,q2);\n\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center =  fragCoord/iResolution.xy;\n    vec2 right  = center + vec2(1,0)/iResolution.xy;\n    vec2 up     = center + vec2(0,1)/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 ratio = vec2(iResolution.x / iResolution.y,1.);\n    vec4 t = texture(iChannel0,center);\n    \n    // velocity changes proportional to pressure gradient across point\n    t.x += texture(iChannel0,center).z - texture(iChannel0,right).z; \n    t.y += texture(iChannel0,center).z - texture(iChannel0,up).z; \n    \n    \n    \n    // mouse makes waves\n    if(iMouse.z > 0.5){\n    if(length(mouse * ratio - center * ratio) < 0.05){\n        t.z -= smoothstep(0.0,0.01,length(mouse * ratio - center * ratio))*1.;\n    }\n    }else{\n    \n    vec2 p = getLemniscate(iTime);\n    if(length((p* .25+.5)  * ratio - center * ratio) < .1){ // top left \n        t.z -= 0.1;\n    }\n    \n    /*\n    // optional sine wave sources\n    if(length(vec2(0.25,0.5) * ratio - center * ratio) < .0525){ // top left \n        t.z -= sin(iTime*2.0)*0.1;\n    }\n    \n    if(length(vec2(0.75,0.5) * ratio - center * ratio) < .0525){ // top left \n        t.z -= cos(iTime*2.0)*0.1;\n    }\n    */\n    }\n    fragColor = vec4(t.x ,t.y,t.z,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nx = horizontal velocity\ny = vertical velocity\nz = pressure\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center =  fragCoord/iResolution.xy;\n    vec2 left  = center + vec2(-1,0)/iResolution.xy;\n    vec2 down     = center + vec2(0,-1)/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n \n    \n    vec4 t = texture(iChannel0,center);\n   \n   // pressure changes proportional to the net inflow - outflow of the cell\n   t.z += (texture(iChannel0,left).x - texture(iChannel0,center).x + texture(iChannel0,down).y - texture(iChannel0,center).y) *0.498; // multiplier has to be < 0.5\n   \n   t.z *= 0.998; // optional dissapation factor\n    \n   fragColor = vec4(t.x, t.y, t.z, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}