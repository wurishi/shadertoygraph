{"ver":"0.1","info":{"id":"tscSDs","date":"1584794009","viewed":172,"name":"Simple Ambient Occlusion","username":"jorgemoag","description":"test","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float p)\n{\n    return fract(sin(dot(vec2(p), vec2(12.9898, 78.233))) * 43758.5453);    \n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 pos) {\n\tfloat d = sdOctahedron(pos, 0.5);\n    \n    vec3 centers[4] = vec3[4](\n        vec3(0.4 + 0.2 * sin(2.0*iTime), 0.4 + 0.2 * sin(iTime), 0.0),\n\t\tvec3(-0.4 + 0.3 * cos(3.0*iTime), 0.4 + 0.2 * cos(1.5*iTime), 0.0),\n\t\tvec3(0.4 * cos(iTime), -0.4, 0.4 * sin(iTime)),\n\t\tvec3(-0.4, -0.4, 0.0)\n    );\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        float d2 = sdSphere(pos - centers[i], 0.2);\n        d = min(d, d2);\n    }\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.0001, 0.0);\n    float d = map(pos);\n    return normalize(vec3(\n        map(pos + eps.xyy) - d,\n        map(pos + eps.yxy) - d,\n        map(pos + eps.yyx) - d\n\t));\n}\n\nfloat ambientOcclusion(vec3 pos, float fallout)\n{\n    const int nS = 12; // number of samples\n    const float max_dist = 0.07;\n    vec3 N = calcNormal(pos);\n    \n    float diff = 0.0;\n    for (int i = 0; i < nS; ++i)\n    {        \n        float dist = max_dist * hash(float(i)); // rand len\n        float s_dist = max(0.0, map(pos + dist * N)); // sample\n        \n        diff += (dist - s_dist) / max_dist;\n    }\n    \n    float diff_norm = diff / float(nS);\n    float ao = 1.0 - diff_norm/fallout;\n    \n    return clamp(ao, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec2 mouse = iMouse.xy / iResolution.y;\n    \n    vec3 cam_pos = vec3(sin(3.0 * mouse.x), \n                        cos(3.0 * mouse.y),\n                        cos(3.0 * mouse.x));\n    \n    vec3 cam_target = vec3(0,0,0);\n    vec3 cam_ww = normalize(cam_target - cam_pos);\n    vec3 cam_uu = normalize(cross(cam_ww, vec3(0,1,0)));\n    vec3 cam_vv = normalize(cross(cam_uu, cam_ww));\n    \n    vec3 ro = cam_pos;\n    vec3 rd = normalize(p.x * cam_uu + p.y * cam_vv + 2.0 * cam_ww);\n    \n    float t = 0.0;\n   \tfor (int i = 0; i < 64; ++i)\n    {\n        vec3 pos = ro + t * rd;\n        float h = map(pos);\n        if (h < 0.0001)\n        {\n            break;\n        }\n        t += h;\n        if (t > 20.0)\n        {\n            break;\n        }\n    }\n    \n    if (t < 20.0)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 N = calcNormal(pos);\n        float ao = ambientOcclusion(pos, 0.5);\n        col = vec3(ao) * (0.5 * N + 0.5);\n    }\n    \n    col = clamp(col, vec3(0.0), vec3(1.0));\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}