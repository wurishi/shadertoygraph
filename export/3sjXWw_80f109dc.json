{"ver":"0.1","info":{"id":"3sjXWw","date":"1557418220","viewed":204,"name":"Beto produit vectorielle 3D","username":"msafadi","description":"beto","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["beto"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 X = vec3(1., 0., 0.);\nconst vec3 Y = vec3(0., 1., 0.);\nconst vec3 Z = vec3(0., 0., 1.);\n\n// YOURS\n\nconst vec3 FOOT_O = vec3(0);\nconst vec3 FOOT_X = X;\nconst vec3 FOOT_Y = Y;\nconst vec3 FOOT_Z = Z;\n\nconst vec3 BODY_O = vec3(0,4,0);\nconst vec3 BODY_X = X;\nconst vec3 BODY_Y = Y;\nconst vec3 BODY_Z = Z;\n\nconst vec3 HEAD_O = vec3(0,7,0);\nconst vec3 HEAD_X = X;\nconst vec3 HEAD_Y = Y;\nconst vec3 HEAD_Z = Z;\n\nconst vec3 BUTTON_1_O = vec3(0,4.8,1.8);\nconst vec3 BUTTON_1_X = X;\nconst vec3 BUTTON_1_Y = Y;\nconst vec3 BUTTON_1_Z = Z;\n\nconst vec3 BUTTON_2_O = vec3(0,3.8,1.9);\nconst vec3 BUTTON_2_X = X;\nconst vec3 BUTTON_2_Y = Y;\nconst vec3 BUTTON_2_Z = Z;\n\nconst vec3 EYE_1_O = vec3(-0.5,7.3,1.2);\nconst vec3 EYE_1_X = X;\nconst vec3 EYE_1_Y = Y;\nconst vec3 EYE_1_Z = Z;\n\nconst vec3 EYE_2_O = vec3(0.5,7.3,1.2);\nconst vec3 EYE_2_X = X;\nconst vec3 EYE_2_Y = Y;\nconst vec3 EYE_2_Z = Z;\n\nconst vec3 ARM_1_O = vec3(2.2,4,0);\nconst vec3 ARM_1_X = Y;\nconst vec3 ARM_1_Y = X;\nconst vec3 ARM_1_Z = Z;\n\nconst vec3 ARM_2_O = vec3(-2.2,4,0); // tilt arm by normalizing -X Y, then get orthonormal vector of new Y\nconst vec3 ARM_2_X = X;\nconst vec3 ARM_2_Y = Y;\nconst vec3 ARM_2_Z = Z;\n\nconst vec3 NOZE_O = vec3(0,7,1.2);\nconst vec3 NOZE_X = -X;\nconst vec3 NOZE_Y = Z;\nconst vec3 NOZE_Z = Y;\n\nconst vec3 HAT_O = vec3(0,8,0);\nconst vec3 HAT_X = X;\nconst vec3 HAT_Y = Z;\nconst vec3 HAT_Z = Y;\n\n// ENDOF YOURS\n\n\n\n\n\n\n\n\n\n\n\nconst float Z_NEAR = 1.0;\nconst float Z_FAR  = 400.0;\n\nconst float EPSILON = 0.01;\n\nconst float FOCAL_LENGTH = 2.0;\nconst vec3 EYE_LOOK_POINT = vec3(0, 5, 0);\n\nconst vec3 WHITE = vec3(1, 1, 1);\nconst vec3 BLACK = vec3(0, 0, 0);\nconst vec3 RED =   vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, 1, 0);\nconst vec3 BLUE =  vec3(0, 0, 1);\n\nconst vec3 TOP_BG_COLOR = WHITE;\nconst vec3 BOT_BG_COLOR = GREEN;\nconst vec3 AMBIANT_COLOR = WHITE;\nconst vec3 SPECULAR_COLOR = WHITE;\n\nconst float AMBIANT_RATIO = 0.3;\nconst float DIFFUSE_RATIO = 0.4;\nconst float SPECULAR_RATIO = 0.3;\nconst float SPECULAR_ALPHA = 10.;\n\nconst vec3 LIGHT_DIRECTION = normalize(vec3(1, -1, -1));\n\nvec2 normalizeAndCenter(in vec2 coord) {\n    return (2.0 * coord - iResolution.xy) / iResolution.y;\n}\n\nvec3 rayDirection(vec3 eye, vec2 uv) {    \n    vec3 z = normalize(eye - EYE_LOOK_POINT);\n    vec3 x = normalize(cross(Y, z));\n    vec3 y = cross(z, x);\n    \n    return normalize(\n          x * uv.x \n        + y * uv.y \n        - z * FOCAL_LENGTH);\n}\n\n//\n// Rotations\n//\n\nvec3 rotX(vec3 point, float angle) {\n    mat3 matRotX = mat3(\n        1.0, 0.0, 0.0, \n        0.0, cos(angle), -sin(angle), \n        0.0, sin(angle), cos(angle));\n    return matRotX * point;\n}\n\nvec3 rotY(vec3 point, float angle) {\n    mat3 matRotY = mat3( \n        cos(angle*0.5), 0.0, -sin(angle*0.5),\n        0.0, 1.0, 0.0, \n        sin(angle*0.5), 0.0, cos(angle*0.5));\n    return matRotY * point;\n}\n\nvec3 rotZ(vec3 point, float angle) {\n    mat3 matRotZ = mat3(\n        cos(angle*0.1), -sin(angle*0.1), 0.0, \n        sin(angle*0.1), cos(angle*0.1), 0.0,\n    \t0.0, 0.0, 1.0);\n    return matRotZ * point;\n}\n\n//\n// Positioning\n//\n\nvec3 randomOrtho(vec3 v) {\n    if (v.x != 0. || v.y != 0.) {\n    \treturn normalize(vec3(v.y, -v.x, 0.));\n    } else {\n    \treturn normalize(vec3(0., v.z, -v.y));\n    }\n} \n\nvec3 atPosition(vec3 point, vec3 position) {\n\treturn (point - position);\n}\n\nvec3 atCoordSystem(vec3 point, vec3 center, vec3 dx, vec3 dy, vec3 dz) {\n\tvec3 localPoint = (point - center);\n    return vec3(\n        dot(localPoint, dx),\n        dot(localPoint, dy),\n        dot(localPoint, dz));\n}\n\nvec3 atCoordSystemX(vec3 point, vec3 center, vec3 dx) {\n    vec3 dy = randomOrtho(dx);\n    vec3 dz = cross(dx, dy);\n    \n    return atCoordSystem(point, center, dx, dy, dz);\n}\n\nvec3 atCoordSystemY(vec3 point, vec3 center, vec3 dy) {\n    vec3 dz = randomOrtho(dy);\n    vec3 dx = cross(dy, dz);\n    \n    return atCoordSystem(point, center, dx, dy, dz);\n}\n\nvec3 atCoordSystemZ(vec3 point, vec3 center, vec3 dz) {\n    vec3 dx = randomOrtho(dz);\n    vec3 dy = cross(dz, dx);\n    \n    return atCoordSystem(point, center, dx, dy, dz);\n}\n\n//\n// Shapes\n//\n\nfloat sphere(vec3 coord, float radius) {\n\treturn length(coord) - radius;\n}\n\nfloat capsule(vec3 coord, float height, float radius)\n{\n    coord.y -= clamp( coord.y, 0.0, height );\n    return length( coord ) - radius;\n}\n\nfloat ellipsoid(vec3 coord, vec3 r )\n{\n    float k0 = length(coord/r);\n    float k1 = length(coord/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat roundCone(vec3 coord, in float radiusTop, float radiusBot, float height)\n{\n    vec2 q = vec2( length(coord.xz), coord.y );\n    \n    float b = (radiusBot-radiusTop)/height;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - radiusBot;\n    if( k > a*height ) return length(q-vec2(0.0,height)) - radiusTop;\n        \n    return dot(q, vec2(a,b) ) - radiusBot;\n}\n\nfloat hatt(vec3 coord) {\n    return min(\n        max(\n            ellipsoid(coord, vec3(3., 2., 0.3)),\n            -ellipsoid(coord - vec3(0.,0.,0.2), vec3(3., 1.5, 0.3))),\n        max(sphere(coord, 1.),\n           -sphere(coord + vec3(0.,0.,0.2), 1.)));\n}\n\n//\n// Boolean ops\n//\n\nvec4 shape(float dist, vec3 color) {\n\treturn vec4(color, dist);\n}\n\nvec4 join(vec4 shape1, vec4 shape2) {\n    if (shape1.a < shape2.a) {\n    \treturn shape1;\n    } else {\n    \treturn shape2;\n    }\n}\n\nvec4 join(vec4 shape1, vec4 shape2, vec4 shape3) {\n    return join(join(shape1, shape2), shape3);\n}\n\nvec4 join(vec4 shape1, vec4 shape2, vec4 shape3, vec4 shape4) {\n    return join(join(shape1, shape2, shape3), shape4);\n}\n\n\n//\n// Scene\n//\n\nvec4 dist(in vec3 coord) {\n    float headY = 7.5;\n    float bodyY = 4.5;\n    float footY = 0.;    \n    \n    vec4 hat = shape(hatt(atCoordSystem(coord, HAT_O, HAT_X, HAT_Y, HAT_Z)), GREEN);\n    \n    vec4 head = shape(sphere(atCoordSystem(coord, HEAD_O, HEAD_X, HEAD_Y, HEAD_Z), 1.5), WHITE);\n    vec4 body = shape(sphere(atCoordSystem(coord, BODY_O, BODY_X, BODY_Y, BODY_Z), 2.), WHITE);\n    vec4 foot = shape(sphere(atCoordSystem(coord, FOOT_O, FOOT_X, FOOT_Y, FOOT_Z), 3.), WHITE);\n    \n    vec4 snow = join(hat, head, body, foot);\n            \n    vec4 leftEye = shape(sphere(atCoordSystem(coord, EYE_1_O, EYE_1_X, EYE_1_Y, EYE_1_Z), 0.3), BLUE);\n    vec4 rightEye = shape(sphere(atCoordSystem(coord, EYE_2_O, EYE_2_X, EYE_2_Y, EYE_2_Z), 0.3), BLUE);    \n    vec4 noze = shape(roundCone(atCoordSystem(coord, NOZE_O, NOZE_X, NOZE_Y, NOZE_Z), 0.1, 0.4, 2.), RED);\n    \n    vec4 face = join(leftEye, rightEye, noze);\n       \n    vec4 leftArm = shape(capsule(atCoordSystem(coord, ARM_1_O, ARM_1_X, ARM_1_Y, ARM_1_Z), 5., 0.2), RED);\n    vec4 rightArm = shape(capsule(atCoordSystem(coord, ARM_2_O, ARM_2_X, ARM_2_Y, ARM_2_Z), 5., 0.2), RED);\n    vec4 arms = join(leftArm, rightArm);\n        \n    vec4 buttonTop = shape(sphere(atCoordSystem(coord, BUTTON_1_O, BUTTON_1_X, BUTTON_1_Y, BUTTON_1_Z), 0.3), RED);\n    vec4 buttonBot = shape(sphere(atCoordSystem(coord, BUTTON_2_O, BUTTON_2_X, BUTTON_2_Y, BUTTON_2_Z), 0.3), RED);\n    vec4 buttons = join(buttonTop, buttonBot);\n    \n    return join(snow, face, arms, buttons);\n}\n\n//\n//\n//\n\nbool rayMarching(in vec3 startPoint, in vec3 direction, out vec3 lastPoint, out vec3 color) {\n    lastPoint = startPoint;\n    for (int i = 0; i < 50; ++i) {\n        vec4 d = dist(lastPoint);\n        if (d.a < EPSILON) {\n            color = d.xyz;\n            return true;\n        } else {\n            lastPoint += d.a * direction;\n        }\n        if (lastPoint.z < -Z_FAR) {\n            break;\n        }\n    }    \n    return false;\n}\n\nvec3 norm(in vec3 coord) {\n\tvec3 eps = vec3( EPSILON, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    dist(coord+eps.xyy).a - dist(coord-eps.xyy).a,\n\t    dist(coord+eps.yxy).a - dist(coord-eps.yxy).a,\n\t    dist(coord+eps.yyx).a - dist(coord-eps.yyx).a);\n\treturn normalize(nor);\n}\n\n\nvec3 cellShadingObjColor(vec3 point, vec3 ray, vec3 objColor) {\n    vec3 n = norm(point);\n    \n    float diffuseValue = max(dot(-LIGHT_DIRECTION, n), 0.);\n    float specularValue = pow(max(dot(-reflect(LIGHT_DIRECTION, n), ray), 0.), SPECULAR_ALPHA);        \n    \n    return AMBIANT_COLOR * AMBIANT_RATIO\n        + objColor * DIFFUSE_RATIO * diffuseValue\n        + SPECULAR_COLOR * SPECULAR_RATIO * specularValue;\n}\n\n\nvec3 computeColor(vec2 fragCoord) {\n    vec2 uv = normalizeAndCenter(fragCoord);\n    vec3 eye = rotY(vec3(0, 12, 18), cos(iTime*0.5)*2.);\n        \n    vec3 ray = rayDirection(eye, uv);\n    \n    vec3 intersection;\n    vec3 color;\n    bool intersected = rayMarching(eye, ray, intersection, color);\n    \n    if (intersected) {\n    \treturn cellShadingObjColor(intersection, ray, color);\n    } else {\n    \treturn uv.y > 0. ? TOP_BG_COLOR : BOT_BG_COLOR;\n    }\n}\n\n//#define SUPERSAMPLING\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    #ifdef SUPERSAMPLING\n    fragColor = vec4(0);\n    float count = 0.;\n    for(float dx=-0.5; dx<=0.5; dx+=0.5) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.5) {\n            fragColor += vec4(computeColor(fragCoord + vec2(dx, dy)), 1.0);\n            count += 1.;\n        }\n    }\n    \n    fragColor /= count;\n    \n    #else\n    fragColor = vec4(computeColor(fragCoord),1.0);\n    #endif\n} \n\n","name":"Image","description":"","type":"image"}]}