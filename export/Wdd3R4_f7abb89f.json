{"ver":"0.1","info":{"id":"Wdd3R4","date":"1567958377","viewed":271,"name":"Poincare Disk Transformations","username":"skye_adaire","description":"This is showing a translation of the Poincare disk using complex-valued matrices for the Mobius transform. The hypercomplex functions are my design. I studied the thesis of Martin von Gagern http://mediatum.ub.tum.de/node?id=1210572","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["mobius","complex","disk","transform","hyperbolic","poincare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n//end Hypercomplex\n\n//column-major and complex-valued \n#define ComplexVector2 mat2x2\n#define ComplexMatrix2 mat4x2\n\nComplexMatrix2 identityMob = ComplexMatrix2(1,0, 0,0, 0,0, 1,0); \n\n//inverse of mobius transform with det 1\nComplexMatrix2 M_inverse(ComplexMatrix2 m)\n{\n    return ComplexMatrix2(m[3], -m[1], -m[2], m[0]); \n}\n\nComplexMatrix2 M_multiply(ComplexMatrix2 lhs, ComplexMatrix2 rhs)\n{\n    return ComplexMatrix2(\n        H_multiply(lhs[0], rhs[0]) + H_multiply(lhs[2], rhs[1]),\n        H_multiply(lhs[1], rhs[0]) + H_multiply(lhs[3], rhs[1]),\n        H_multiply(lhs[0], rhs[2]) + H_multiply(lhs[2], rhs[3]),\n        H_multiply(lhs[1], rhs[2]) + H_multiply(lhs[3], rhs[3]));\n}\n\n//complex-valued homogeneous transform\nComplex M_multiply(ComplexMatrix2 m, Complex z)\n{\t\n    return H_divide(H_multiply(m[0], z) + m[2], H_multiply(m[1], z) + m[3]);\n}\n\n//returns the mob mapping z0 -> 0, z1 -> 1, z2 -> inf\nComplexMatrix2 M_mapTripleTo01I(Complex z0, Complex z1, Complex z2)\n{\n    return ComplexMatrix2(\n        z0 - z2,\n        z0 - z1,\n        H_multiply(-z1, z0 - z2),\n        H_multiply(-z2, z0 - z1));\n}\n \n//uses the cross ratio to construct the mob taking the ordered triple a,b,c -> p,q,r\nComplexMatrix2 M_mapTripleToTriple(\n    Complex a, Complex b, Complex c, \n\tComplex p, Complex q, Complex r)\n{\n\treturn M_multiply(M_inverse(M_mapTripleTo01I(p, q, r)), M_mapTripleTo01I(a, b, c));\n}\n\n//mob taking  [-1, 0, 1] to [L, c, R]\nComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)\n{\n    return M_mapTripleToTriple(\n        Complex(-1, 0), Complex(0, 0), Complex(1, 0),\n        L, c, R);\n}\n\n//the euclidean rotation of the plane is an isometry of the disk\nComplexMatrix2 M_rotation(Real a)\n{\n    return ComplexMatrix2(H_versor(0.5 * a), Complex(0, 0), Complex(0, 0), H_versor(-0.5 * a));\n}\n\nComplexMatrix2 M_translateReals(Real t)\n{\n    Real ex = exp(t);\n    Complex exp1 = Complex(ex + 1.0, 0);\n    Complex exm1 = Complex(ex - 1.0, 0);\n    \n    return ComplexMatrix2(exp1, exm1, exm1, exp1);\n}\n\nComplexMatrix2 M_translateDisk(vec2 v)\n{\n    PolarComplex p = H_toPolar(v);\n    ComplexMatrix2 r = M_rotation(p.argument);\n    return M_multiply(r, M_multiply(M_translateReals(p.norm), M_inverse(r)));\n}\n\nstruct Circle\n{\n \tComplex center;\n    Real radius;\n};\n\nCircle M_getCircleBetweenDiskPoints(Complex p, Complex q)\n{\n    Real dp = H_sqnorm(p) + 1.0;\n    Real dq = H_sqnorm(q) + 1.0;\n    Real dpq = 2.0 * (p[0] * q[1] - p[1] * q[0]);\n    Complex center = Complex(q[1] * dp - p[1] * dq, -q[0] * dp + p[0] * dq) / dpq;\n\n    return Circle(center, sqrt(H_sqnorm(center) - 1.0));\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\nbool intersectHypersphere(\n    vec2 rayPosition,\n    vec2 rayDirection,\n    vec2 center,\n    float radius,\n    out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * (dot(rayDirection, rayPosition) - dot(rayDirection, center));\n    float c = dot(rayPosition, rayPosition) - 2.0 * dot(rayPosition, center) + dot(center, center) - H_sq(radius);\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nComplexMatrix2 M_getIdealLine(Complex i0, Complex i1)\n{\n \tCircle c = M_getCircleBetweenDiskPoints(i0, i1);\n    vec2 d = normalize(c.center);\n    \n    float t;\n    intersectHypersphere(vec2(0), d, c.center, c.radius, t);\n    \n    return M_mapRealsToLine(i0, t * d, i1);\n}\n\n//a tile is constructed from half planes\n//the union of these half planes is the fundamental domain\n//we reflect the point about half planes until it is in the domain\nvec2 getPoincareTiling(\n    ComplexMatrix2 transformFromA, ComplexMatrix2 transformToA, \n    ComplexMatrix2 transformFromB, ComplexMatrix2 transformToB, \n    ComplexMatrix2 transformFromC, ComplexMatrix2 transformToC, \n    vec2 z, out vec3 d)\n{\n   for(int i = 0; i < 60; i++)\n   {\n      vec2 t;\n       \n      t = M_multiply(transformToA, z);\n\n      d[0] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromA, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToB, z);\n\n      d[1] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromB, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToC, z);\n\n      d[2] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromC, t);\n         continue;\n      }\n\n      //the point is in the fundamental domain\n      break;\n   }\n\n   return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 p = clip * 1.02;\n    \n    vec3 color;\n    \n    if(length(p) < 1.0)\n    {\n        vec2 z = p;\n        \n        //this transform moves us around \n        //transformation could also be done by complex matrix composition, just like view matrices in R3\n        //since this is a fully proceedural shader, I recompute the translation each frame\n        float time = 0.5 * iTime;\n        vec2 mouse = -(iMouse.xy / iResolution.xy - 0.5) * 5.0;\n        mouse.x *= iResolution.x / iResolution.y;\n        vec2 def = 4.0 * vec2(cos(0.5*time), 0.1*sin(time));                        \n        vec2 v = iMouse.z > 0.0 ? mouse : def;\n        \n        ComplexMatrix2 translation = M_translateDisk(v);\n        z = M_multiply(translation, z);\n         \n        //these transforms comprise the fundamental domain of the tiling\n        ComplexMatrix2 transformFromA = identityMob;\n        ComplexMatrix2 transformToA = M_inverse(transformFromA);\n\n        float angleB = tau32 / 8.0;\n        Complex versorB = H_versor(angleB);\n        ComplexMatrix2 transformFromB = M_mapRealsToLine(versorB, Complex(0,0), -versorB);\n        ComplexMatrix2 transformToB = M_inverse(transformFromB);\n\n        ComplexMatrix2 transformFromC = M_getIdealLine(H_versor(-0.852), H_versor(0.852));\n        ComplexMatrix2 transformToC = M_inverse(transformFromC);\n\n        vec3 distances;\n        z = getPoincareTiling(\n            transformFromA, transformToA,\n            transformFromB, transformToB,\n            transformFromC, transformToC,\n            z, distances);\n\n        distances = vec3(1) - distances;\n        distances = pow(distances, vec3(30.0));\n\n        color = mix(distances, vec3(0.1), smoothstep(0.97, 1.0, length(p)));\n\n        /*\n\t\t//to test individual domain edges\n        vec2 z = M_multiply(transformToB, p);\n        color = vec3(0,0,1.0-abs(z.y));\n        color = pow(color, vec3(30.0));\n        color += vec3(pow(1.0 - length(z), 3.0));\n\t\t*/\n    }\n    else\n    {\n     \tcolor = vec3(0.1);   \n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}