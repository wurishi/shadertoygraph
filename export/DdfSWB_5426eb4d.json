{"ver":"0.1","info":{"id":"DdfSWB","date":"1669440391","viewed":74,"name":"reflections with raymarching","username":"airepods","description":"This is a Glossy-recreated Cornell Box rendered entirely with raymarching. The surfaces are assumed to be glossy (perfectly reflective like a mirror) and the reflections are set up for 2 bounces, meaning just one primary and secondary ray.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflections","glossy","cornelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Specular reflections with raymarching\n// Image Campus 2022\n/*\n-----------------------------------------------------------------------------------------------------------\nThe Cornell Box is a scene used for testing the quality of renderers, now it is also part of the graphics lore.\nThis is a Glossy-recreated Cornell Box rendered entirely with raymarching. The surfaces are assumed to be \nglossy (perfectly reflective like a mirror) and the reflections are set up for 2 ray bounces. Also, \nthe bounces can be modified in the code but be aware that more bounces mean less perfomance (fps).\n\nI wanted to create this with the objective of imitating the effects that a regular raytracing does but with\nraymarching (and sphere tracing to be more specific). Currently the program runs in realtime (>30fps)\nin a 800x450 resolution, try going fullscreen!\nDisclaimer: This is not how a rendering algorithm should work, specially offline renderers that use\nray tracing/path tracing but this was a fun project to do and I guess there still exists room for \nmore optimization.\n-----------------------------------------------------------------------------------------------------------\n*/\n\n\n#define PI 3.14159265359\n\nconst int BOUNCES = 2;\nconst float SHADOW_INTENSITY = 0.5;\n\n// Umbral para parar la marcha del rayo, distancias menores al umbral no se considera\nfloat det=.001;\n// Maxima distancia recorrida por el rayo\nfloat maxdist = 100.;\n// Maximo numero de pasos que va a hacer el rayo durante su recorrido\nint maxsteps = 500;\n\n\n// Estructura para la luz - position e intensity se usan en el caso de luz puntual, para luz direccional\n// solo se requiere de intensity\nstruct LightData\n{\n    vec3 position;\n    vec3 intensity;\n};\n\n// Inicializo la estructura\nLightData light = LightData(vec3(2., 5., -4.), vec3(1.0));\n\n// Modelo de iluminacion de Phong\nvec3 Ia = vec3(1.0);\nvec3 ka = vec3(0.1), kd = vec3(1.0), ks = vec3(0.8);\nfloat phongExp = 30.0;\n\n// funciones utils\n// generar rayo a partir de la camara virtual de \n// https://github.com/electricsquare/raymarching-workshop#raymarching-loop\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget);\n\n// SDFs de https://iquilezles.org/articles/distfunctions/\nfloat sdSphere(vec3 p, float s);\nfloat sdPlane(vec3 p, vec3 n, float h);\nfloat sdBox(vec3 p, vec3 b);\n\nvec3 normal(vec3 p);\n\n// Operador Union para dibujar mas de una primitiva usando la distancia mas cercana\nvec2 opU(vec2 d1, vec2 d2);\n// Patro de ajedrez - https://iquilezles.org/articles/checkerfiltering/\nfloat checkers(vec2 p);\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// Aqui se van a inizializar las primivitas dadas su SDF, funcion de -> x: distancia, y: id de primitiva\nvec2 de(vec3 p)\n{   \n    \n    vec2 d =   vec2(sdSphere(p+vec3(0., 0., 0.), 1.0),                 1.0);  // esfera id 1\n    d = opU(d, vec2(sdSphere(p+vec3(-2.0, 0.,  -1.5), 1.0),            2.0)); // esfera id 2\n    d = opU(d, vec2(sdBox(p+vec3(0., 0., -12.0), vec3(3.5, 3.0, 6.)),  3.0)); // box    id 3\n    d = opU(d, vec2(sdPlane(p, vec3(0., 1., 0.), 1.),                  4.0)); // plano  id 4\n    d = opU(d, vec2(sdBox(p+vec3(4., 0., -1.0), vec3(0.5, 3.0, 5.)),   5.0)); // box    id 5\n    d = opU(d, vec2(sdBox(p+vec3(-4., 0., -1.0), vec3(0.5, 3.0, 5.)),  6.0)); // box    id 6\n    d = opU(d, vec2(sdSphere(p+vec3(2.0, 0.,  -1.5), 1.0),             7.0)); // esfera id 7 \n    \n    return d;\n}\n\n// Obtener el color de la primitiva dada su id\nvec3 getColorByID(float objectid, vec3 p)\n{\n    vec3 color = vec3(0.);\n    if (objectid == 1.0) color = vec3(1., 1., 1.);\n    if (objectid == 2.0) color = vec3(1., 0., 0.);\n    if (objectid == 3.0) color = vec3(0.8, 0.8, 0.8);\n    if (objectid == 4.0) color = vec3(checkers(p.xz)); // para el plano uso el patron de ajedrez\n    if (objectid == 5.0) color = vec3(1., 0., 0.);\n    if (objectid == 6.0) color = vec3(0., 1., 0.);\n    if (objectid == 7.0) color = vec3(0., 1., 0.);\n    \n    return color;\n}\n\n\n// Funcion trace que va a trazar el rayo por pasos (sphere tracing)\n// Esta funcion retorna un vector con t: distancia o punto de interseccion \n// y objectid: id de primitiva intersecada \nvec2 trace(vec3 from, vec3 dir)\n{\n    // d almacena las distancias y las ids\n    vec2 d = vec2(0.);\n    // result es vector a retornar de la funcion\n    vec2 result = vec2(0.);\n    float t = 0.;\n    vec3 p;\n    \n    // por defecto si no hay ninguna primitiva interseca entonces el id sera -1.0\n    float objectid = -1.0;\n    result.y = objectid;\n\n    for(int i=0; i<maxsteps; i++)\n    {\n        p = from + t * dir;\n        d = de(p);\n        \n        if(d.x < det || t > maxdist) break;\n        t+=d.x;        // suma a la marcha al parametro t\n        objectid=d.y;  // almacena el id de primitiva hasta el momento\n        result.x = t;  // almacena la distancia hasta el momento\n    }\n    \n    // si hay interseccion\n    if(d.x < det)\n    {\n        result.x = t;\n        result.y = objectid;\n        return result;\n    } // si no hay interseccion\n    else if(d.x > maxdist)\n    {\n         result.x = -1.0;\n         result.y = -1.0;\n         return result;\n    }\n    \n    // de cualquier otra forma igual retornar result\n    return result;\n}\n\n// Funcion para el shading - iluminacion\nvec3 shade(vec3 p, vec3 dir, vec3 surfaceColor)\n{\n\n    vec3 _p = p;\n    vec3 _dir = dir;\n    vec3 _surfaceColor = surfaceColor;\n    \n    vec3 intensity = vec3(0.);\n    float reflection_factor = 1.;\n    float shadow = 1.;\n    \n    // El shading es iterativo con respecto a la cantidad de \"rebotes\" de los rayos, por defecto\n    // esta configurado en 2, a mas rebotes, el rendimiento cae.\n    for(int i=0; i<BOUNCES; i++)\n    {\n        // PHONG\n        // Se realiza el shading mediante la tecnica de iluminacion de Phong\n        vec3 n = normal(_p);\n        vec3 l = normalize(light.position - _p);\n        vec3 r = reflect(l, n);\n        intensity += (ka * Ia +\n                      kd * light.intensity * max(0., dot(n, l)) * _surfaceColor +\n                      ks * light.intensity * pow(max(0., dot(_dir, r)), phongExp))*reflection_factor;\n        // SOMBRAS\n        // Calculo de un shadow ray para generar sombrar, solo se van a generar sombras para\n        // el primer rebote\n        vec3 shadowRayOrigin = _p + n*0.01; // aqui a p lo desplazo un poco en direccion de la normal\n        vec3 shadowRayDir = l;\n        vec2 shadow_inter = trace(shadowRayOrigin, shadowRayDir); // trace hacia la posicion de la luz\n        // si hay interseccion, es decir, algun id de primitiva ha sido capatada, combinar la intensidad\n        // o color con el factor de intensidad de sombra, el factor es 0.5 por defecto para tener una\n        // sombra no tan pronunciada\n        if(shadow_inter.y != -1.0){ intensity -= SHADOW_INTENSITY*shadow; }\n        \n        // REFLEXION ESPECULAR\n        // Reflexiones tipo espejo perfecto\n        vec3 reflection_vector = normalize(reflect(_dir, n));\n        // trace con el punto de interseccion desplazado un poco en la direccion de la normal\n        vec2 intersection = trace(_p + n*0.01, reflection_vector);\n        // Obtengo el nuevo punto de interseccion captado por el rayo reflejo\n        vec3 from = _p + n*0.01;\n        float t = intersection.x;\n        // deja de ser cero, esto es para controlar que el factor de reflexion solo aplique a partir del\n        // segundo rebote y por ende no modifique el shading en el primer rebote \n        reflection_factor = 0.1;\n        // Es cero porque las sombras solo se van a considerar en el primer rebote\n        shadow = 0.;\n        \n        //UPDATE\n        // Se actualizan el punto de interseccion, la direccion del rayo y el color de la superficie\n        // con el objetivo de generar todo un proceso de trace nuevamente pero a partir del nuevo punto de\n        // interseccion obtenido\n        _p = from + t * reflection_vector;\n        _dir = reflection_vector;\n        _surfaceColor = getColorByID(intersection.y, _p);\n        \n    }\n    \n    // retorna la intensidad -> phong+ reflexion+ sombras\n    return intensity;\n}\n\n// Funcion render, llama a trace y a shade\nvec3 render(vec3 from, vec3 dir)\n{\n    vec3 col = vec3(0.);\n    \n    vec2 result = trace(from, dir); // resultado de trace\n    \n    // almacenar el resultado de trace en t (distancia) y objectid (id de primitiva)\n    float t = result.x;\n    float objectid = result.y;\n    \n    // generar el punto de interseccion a partir de los resultados de trace\n    vec3 p = from + t * dir;\n    // obtener el color de surface \n    vec3 surfaceColor = getColorByID(objectid, p);\n    // shading\n    col = shade(p, dir, surfaceColor);\n    \n    return col; // retorna color de pixel \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordenada normalizadas (from -1 to 1)\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy - 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // resultado final - render\n    vec3 col = vec3(0.); \n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // parametros para la camara\n    vec3 from = vec3(0.01, 2.4, -5.5);\n    vec3 to = vec3(0., 0., 0.);\n    vec3 dir = getCameraRayDir(uv, from, to);   \n    \n    // llamada a raymarching\n    col = render(from, dir);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n// Funcion para crear una camara a partir de 3 parametros\n// https://github.com/electricsquare/raymarching-workshop#raymarching-loop\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0., det);\n    return normalize(vec3(de(p+e.yxx).x, de(p+e.xyx).x, de(p+e.xxy).x) - de(p).x);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat checkers(vec2 p)\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;\n}","name":"Image","description":"","type":"image"}]}