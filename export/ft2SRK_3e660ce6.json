{"ver":"0.1","info":{"id":"ft2SRK","date":"1628083328","viewed":73,"name":"MRR_RaymarchedAnimatedGrid","username":"MiguelRodRic","description":"Grid of raymarched boxes animated using noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 100\n#define MAXDISTANCE 32.0\n#define HITDISTANCE 0.005\n#define SURFACEOFFSET 0.1\n#define GRIDWIDTH 8\n#define GRIDDEPTH 8\n\nvec3 boxes[GRIDWIDTH * GRIDDEPTH];\n\n\n////////////////\n// From IÃ±igo Quilez's Value Noise shader -> https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p)  \n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n////////////////\n\nvoid UpdateBoxGrid(vec4 timeParams)\n{\n    vec2 noiseAspectRatio = vec2(iResolution.x/iResolution.y,1.0);\n    \n    int halfwidth = GRIDWIDTH / 2;\n    for (int x = 0; x < GRIDWIDTH; ++x)\n    {\n        for (int y = 0; y < GRIDDEPTH; ++y)\n        {\n            //Using noise texture \n            \n            //vec2 noiseUV1 = vec2(y,x) * timeParams.z;\n            //vec2 noiseUV2 = vec2(x,y) * timeParams.w;\n            //vec4 noiseTex1 = texture(iChannel3, noiseUV1);\n            //vec4 noiseTex2 = texture(iChannel3, noiseUV2);\n            //float noiseA = noiseTex1.x * noiseTex1.x * 0.4;\n            //float noiseB = noiseTex2.x * noiseTex1.x * 0.4;\n            //vec3 box = vec3((x - halfwidth) * 2, (((noiseA + noiseB)) * float(y)), y * 2);\n\n            //Using IQ's runtime noise\n            \n            vec2 noiseUV = vec2(x,y) * noiseAspectRatio;\n            vec3 box = vec3((x - halfwidth) * 2, 1.0 - (timeParams.x * noise(noiseUV * vec2(4.0)) + timeParams.y * noise(noiseUV * vec2(2.0))) * 0.2 * float(y), y * 2);\n            \n            boxes[(x * GRIDWIDTH) + y] = box;\n        }\n    }     \n}\n\nfloat GetDistanceToBox(vec3 point, vec3 center, float side)\n{\n    vec3 pointTransformed = point - center;\n    float distance = length(max(abs(pointTransformed) - side, .0));\n    \n    return distance;\n}\n\nfloat GetDistanceToSphere(vec3 point, vec3 center, float radius)\n{\n    float distance = length(point - center.xyz) - radius;\n    return distance;\n}\n\nfloat GetDistance(vec3 point)\n{\n    vec4 sphere = vec4(0.0, 2.4, 2.0, 0.3);\n    \n    float sphereDistance = GetDistanceToSphere(point, sphere.xyz, sphere.w);\n    \n    float planeDistance = point.y; //Plane is axis-aligned with y = 0\n    float distance = min(planeDistance, sphereDistance);\n    \n        \n    //Animated Box grid\n    for (int x = 0; x < GRIDWIDTH; ++x)\n    {\n        for (int z = 0; z < GRIDDEPTH; ++z)\n        {\n            float boxDistance = GetDistanceToBox(point, boxes[(x * GRIDWIDTH) + z], 0.95); \n\n            distance = min(boxDistance, distance);\n        }\n    }    \n    \n    return distance;\n}\n\nfloat RayMarch(vec3 rOrigin, vec3 rDirection)\n{\n    float distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAXSTEPS; ++i)\n    {\n        vec3 p = rOrigin + rDirection * distanceFromOrigin;\n        float distanceToScene = GetDistance(p);\n        distanceFromOrigin += distanceToScene;\n        \n        if (distanceFromOrigin > MAXDISTANCE || distanceToScene < HITDISTANCE) break;\n    }\n    \n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 point)\n{\n    float distance = GetDistance(point);\n    vec2 offset = vec2(0.01, 0.0);\n    \n    vec3 normal = distance - vec3(GetDistance(point - offset.xyy), GetDistance(point - offset.yxy),  GetDistance(point - offset.yyx));\n        \n    return  normalize(normal);\n}\n\nfloat GetLight(vec3 point)\n{\n    vec3 lightPosition = vec3(5.0 * sin(iTime), 5.0, 4.0 + cos(iTime) * 6.0);\n    vec3 lightDirection = normalize(lightPosition - point);\n    vec3 surfaceNormal = GetNormal(point);\n    \n    float diffuse = clamp(dot(surfaceNormal, lightDirection), 0.0, 1.0);\n    \n    float shadow = RayMarch(point + (surfaceNormal * SURFACEOFFSET), lightDirection);\n    \n    diffuse -= step(shadow, length(lightPosition - point)) * 0.9;\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rOrigin = vec3(0.0, 3.0, 0.0);\n    vec3 rDirection = normalize(vec3(uv.x, uv.y - 0.5, 1.0));\n\n    //Time Params    \n    float timeSin = sin(iTime);\n    float timeCos = cos(iTime);\n    float timeSinUV = sin(iTime * 0.15) * 0.003;\n    float timeCosUV = cos(iTime * 0.15) * 0.002;\n    vec4 timeParams = vec4(timeSin, timeCos, timeSinUV, timeCosUV);\n    \n    //Animate Box Grid\n    UpdateBoxGrid(timeParams);\n        \n    //Raymarching\n    float d = RayMarch(rOrigin, rDirection);\n\n    vec3 point = rOrigin + rDirection * d;\n    \n    float diffuseLight = clamp(GetLight(point), 0.1, 0.9);\n    \n    vec3 col = vec3(diffuseLight, 0.0, 0.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}