{"ver":"0.1","info":{"id":"WdcBDf","date":"1606129447","viewed":123,"name":"Terrain ice","username":"treize","description":"terrain ice","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","terrain","ice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATION_NUM 50\n\nfloat map(vec3 rayPos) \n{\n    float fbm;\n    FBM24(rayPos.xz, 0.5,2.0,fbm);\n    fbm+=0.2;\n\tfbm*=0.85;\n    fbm=mix(0.2,1.0,fbm);\n\tfloat floor_height\t=  0.25-fbm;\n    float d=sdBox(rayPos, vec3(1.2,0.6,1.2));\n    floor_height+=rayPos.y;\n\td=\topIntersection(d,floor_height); \t\t\t\n\treturn d;\n}\n\nvec3 getnormal(vec3 p)\n{\n    vec2 e =vec2(0.01,0.0);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx)));\n}\nvec3 lighting(vec3 p,vec3 lp,vec3 lc)\n{\n    vec3 normal=getnormal(p);\n    vec3 lightdir=normalize(lp);\n    float NdotL = max(dot(lightdir,normal),0.0);\n    vec3 col = vec3(NdotL)+lc;\n    return col;\n}\n\nvec3 raymarch(vec3 rayOrigin, vec3 rayDirection) \n{\n\tvec3 rayPos, col = vec3(0.0);\n\tfloat depth = 0.0;\n\tfor(int i=0; i<ITERATION_NUM; i++) \n\t{\n        rayPos=rayOrigin+rayDirection*depth;\n\t\tfloat d = map(rayPos);\n\t\tif(d<0.01)\n\t\t{\n            col=lighting( rayPos,vec3(1.0,0.0,-1.0),vec3(0.5,0.5,0.5));\n            if(rayPos.y>0.02)\n            {\n                col+=vec3(0.0,0.2,0.6);\n            }\n            else\n            {\n                col=vec3(0.0,0.4,0.7);\n            }\n\t\t    break;\n\t\t}\n\t\tdepth += d;\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 origin = vec3(1.0, 1.5, 2.0);\n    vec3 target = vec3(0.0);\n    float rotate=0.0;\n    float screen_z=2.0;\n    mat3 camera = SetCamera(origin, target, rotate);\n    vec3 rayDirection = camera * normalize(vec3(p, screen_z));\n\tvec3 col=raymarch(origin , rayDirection);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = acos(-1.0);\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat sphere(vec3 rayPos, float r) \n{\n    float d=length(rayPos)-r;\n\treturn d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\nfloat random_seed2(vec2 uv)\n{\n\treturn fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\nfloat fbm_noise2(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u * u * (3.0 - 2.0 * u);\n\tfloat res = mix(mix(random_seed2(ip), random_seed2(ip + vec2(1.0, 0.0)), u.x), mix(random_seed2(ip + vec2(0.0, 1.0)), random_seed2(ip + vec2(1.0, 1.0)), u.x), u.y);\n\treturn res * res;\n}\nvoid FBM24(vec2 uv, float amplitude, float frequency, out float Out)\n{\n    vec2 p = (uv * 2.0 - 1.0);\n    float result = 0.;\n    float amplitude2 = amplitude;\n    float frequency2 = frequency;\n    for (int i = 0; i < 4; i++)\n    {\n        result += fbm_noise2(p * frequency2) * amplitude2;\n        amplitude2 *= 0.5;\n        frequency2 *= 2.0;\n    }\n    Out = result;\n}\n","name":"Common","description":"","type":"common"}]}