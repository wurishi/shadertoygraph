{"ver":"0.1","info":{"id":"XttGzN","date":"1468201945","viewed":187,"name":"[SH16A] Hamneggs","username":"Hamneggs","description":"I worked down, trying to minify the original as much as I could. Things are macro'd out with extreme prejudice. (Literally, some macros expect vars to pre-exist so they can compare them.) Anyhow, I got down to 1124 characters. I'm pretty happy with it.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["challenge","small","coding","sh16a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I didn't do much beyond minification, except rewriting the if-else\n// blocks as loops.\n\n// Why Z for vec3? Because 3D vectors reach all the way to the Z\n// dimension! ...makes sense to me.\n#define Z vec3\n// 2D coordinates only span into Y.\n#define Y vec2\n// F for float! Too bad there's tons of things that also start with F.\n#define F float\n// Cutting the return keyword down to a single char helps out things.\n#define R return\n// The fact that one needs a keyword for \"void\" doesn't really fit the\n// spirit of void. The return type is void, but the return type token\n// sure isn't. \n#define V void\n// Making the union operation a macro is kind of...pretty looking.\n#define U(a,b) a=(a.x<b.x)?a:b;\n// This defines out the marching loops, and even the incrementation of\n// the distance along the direction vector. (t is that distance. It's\n// defined later as a parameter of the marching functions. Same for e\n// (eye position), and d(direction vector). M is the map function.)\n#define L for(int i=0;i<64;++i)t += M(e+d*t).x;\n// R was already taken, therefore X instead of R for resolution.\n#define X iResolution\n// An underscore is pretty much a \"floor\" emoji. Like what you walk on.\n#define _ floor\n// This is a macro that does the comparisons for normal differentiation.\n// (D for differentiation). It parameterizes the vector term selection.\n#define D(a) M(p+e.a).x-M(p-e.a).x\n\n// Sphere distance function. This (as well as the plane have been inlined.\n//F S( Z p, F s )\n//{\n//    R length(p)-s;\n//}\n\n// Distance function.\nY M( Z p )\n{\n    // So the first thing we do is seed the vec2 we'll be comparing\n    // against. If you look closely, you'll notice that we're initing\n    // this with the distance function of a plane, and the material ID\n    // of the plane. :)\n    Y r = Y( p.y, 13. );\n\n    // The approach here was to define a relationship for each quality\n    // of the spheres in terms of the same variable, and then use those \n    // relationships to condense the if-else block into a for loop using\n    // that variable as the index. It worked, but it sure is messy.\n    // The equations I got were:\n    // X(i) = -2 + floor( i / 5 )\n    // Y(i) = .4 - ( i % 2 ) * .15\n    // Z(i) = -2 + ( i % 5 )\n    // Then for the radius I got:\n    // R \n    for( F i = 0.; i < 25.; ++i )\n        \n        U(r, // Union operation.\n          \n          Y( // vec2 constructor.\n              \n            // The inlined sphere distance function.\n            length(\n                // This mess boils down to:\n                // length( p - vec3( X(i) , Y(i), Z(i) ) ) - ( R(i) )\n                // which is the ol' sphere distance function using\n                // the equations above.\n                p-Z(-2.+_(i/5.),.4-mod(i,2.)*.15,-2.+mod(i,5.))\n            ) - (.4-mod(i,2.)*.15),\n              \n            // The second term of the vec2, the material ID.\n            _(F(i)*.51) \n              \n          ) // Y (vec2)\n          \n        ); // U(union)\n    \n    // Just return the result. Get it out of here. It's tired of\n    // growing up and living in a messy, condensed household. \n    // It needs wide open spaces.\n    R r;\n}\n\n// Ray-marching.\nY C( Z e, Z d, F t )\n{\n    // Do the loop macro and return a fresh vec2 containing\n    // the distance (stored in t by the macro) and the\n    // material ID. For a GLSL line that goes \"L R Y...\"\n    // it's pretty straightforward I'd say.\n    L R Y( t, M(e+d*t).y );\n}\n\n// Shadows.\nF S( Z e, Z d, F t )\n{\n    // Do the loop, and return whether or not the distance\n    // conjured by the loop macro is less than 2.5.\n    \n    // This does shadows differently than I normally would.\n    // Usually I store the nearest distance encountered while\n    // marching toward the light source. This, however, marches\n    // and if it makes it further than 2.5 from the original\n    // surface then it assumes that the point has made it out of\n    // any possible obstruction and returns unshadowed.\n    L R step(2.5,t);\n}\n\n// Normal derivation. The ol' standard differentiate-in-each-dimension\n// method.\nZ N( Z p )\n{\n    // A vec2 containing an epsilon for derivation.\n    // The macro expects this.\n\tY e = Y(.01,.0);\n    // I really like this macro.\n\tR normalize(Z(D(xyy),\n                  D(yxy),\n                  D(yyx)));\n}\n\n// The \"render\" function. Why Q? It's alphabetically close\n// to R for Render.\nZ Q( Z e, Z r )\n{ \n    // The gray color of the squares. We start with this, and\n    // modify it if necesary. This allows us to remove the\n    // \"if(the bland regions of the plane){do this texture}\"\n    // clause.\n    Z c = Z(.4);\n    \n    // Go ahead and do the march, storing distance and material ID.\n    Y g = C(e,r, .0);\n    \n    // Single out the material ID to save characters.\n    F m = g.y;\n    \n    // Move the \"eye\" vec3 to the point marched to, so we can reuse\n    // it for normal generation and shadow marching.\n    e += g.x*r;\n    \n    // Get the normal (using the manipulated eye coordinate.)\n    Z n = N( e );\n    // This value is used to tell which kind of ground tile we're\n    // at.\n    Z q = _(mod(e,2.));\n    \n    // If the material isn't 13 like we started out with, then the\n    // material is that of one of the spheres.\n    if( m< 12.5 )\n        // Again I just discerned equations of a single variable.\n    \tc = Z(1.-.08*m, .03*m, .06*m);\n    \n    // In this case the material is 13, but we're on the fancy noise\n    // tiles.\n    else if(abs(q.x-q.z) > .5)\n        // The traditional esoteric sampling used with those multi-colored\n        // noise textures. I took out the bias term and swapped the texture\n        // mode to \"linear\" to shave a few characters.\n        c = .5 * texture( iChannel0, (_(25.6*e.xz + Y(37.,17.))+ .5)/256. ).yyy;\n        \n    // GOSH DARN FAKE AO I SPENT AN HOUR TRYING TO FIND OUT WHY MY REPLACEMENT\n    // FOR OCCLUSION() (present in the reference shader) WASN'T DOING ANYTHING.\n\tif( max( abs(e.x), abs(e.z)) < 1.5 && e.y <.1 )\n        c *= smoothstep( .0, .5, length(mod(e.xz+.5,1.)-.5) );\n\t\n    // Create a light direction. It's more character-efficient to normalize\n    // it with normalize() rather than pre-compute it.\n    Z  l = normalize( Z(-.6, .7, -.5) );\n    \n    // Use the light direction to calculate a shadow coefficient.\n    F d = dot( n, l )*S( e, l, .01);\n    \n    // Combine a diffuse, ambient and specular term with their respective colors\n    // and return it.\n    R c*Z(1.2*d*Z(1.,.85,.55)+(.25+.25*n.y)*Z(.5,.7,1.)) + pow(max(dot(reflect( r, n ),l),.0),16.)*d*Z(1);\n}\n\n// The main image. \nV mainImage( out vec4 s, Y t )\n{\n    // [-1,1]ify the the fragment coordinate.\n    Y p = -1.+2.*t.xy/X.xy;\n    \n    // Aspect ratio correction.\n\tp.x *= X.x/X.y;\n\n\ts = pow( Q( \n        Z( .851, 2., -2.877 ), \n        // OH YEAH I WORKED OUT THAT CAMERA FUNCTION'S PRODUCT BY HAND\n        // *inhales deeply* *exhales deeper* \"feels good man\"\n        mat3(-.959, .0, -.284,\n             -.168, .806, .567,\n             -.229, -.591, .773) * normalize( Z(p.xy,2.) ) ), \n             Z(.5) ).rgbb;\n}\n","name":"Image","description":"","type":"image"}]}