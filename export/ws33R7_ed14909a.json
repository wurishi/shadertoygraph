{"ver":"0.1","info":{"id":"ws33R7","date":"1568061103","viewed":305,"name":"Naive Area Light","username":"crundle","description":"A naive Implementation of using a SDF as a light source - works fine with simple lights, not so fine with complex setups...\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//#define MULTILIGHT //second light\n#define USESHADOW //shadows only work for simple shapes and get very glitchy with multiple lights\n//#define MULTICOLOR //uncomment this to see the artifacts that happen when multicolored lights interact\n\nvec2 e = vec2(0.0035f,-0.0035f); \nfloat tt,lr=3.0; //lr is light radius\nvec3 ld,fo,glow; //light direction vector, background color, accumulated glow\n\nmat2 r2(float a) { \n\treturn mat2(sin(a + 1.57), sin(a), sin(a + 1.57 * 2.), sin(a + 1.57));\n}\n\nfloat smin(float d1, float d2) { //smooth minimum\n  float h=clamp(.5+.5*(d2-d1)/0.2,0.0,1.0);\n  return mix(d2,d1,h)-0.2*h*(1.-h);\n}\n\nfloat bo(vec3 pos, vec3 b)\n{\n\tvec3 d = abs(pos) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat noi(vec3 p) { //triplanar sampling for some reflection detail\n    float ns = texture(iChannel0,p.xy*.3).r*.3;\n    ns+=texture(iChannel0,p.xz*.3).r*.3;\n    ns+=texture(iChannel0,p.yz*.3).r*.3;\n    return ns;\n}\n\nvec3 getAlbedo(float mi) { // seperated this for convenience\n  if(mi<.4)return vec3(1.,.4,.0);\n  if(mi>.6)return vec3(0,0,1);\n  return vec3(1);\n}\n\nvec4 mp(vec3 p) {//we need extra data for lights, but a vec4 is enough\n\tvec2 l,h,g,t=vec2(p.y,.5); //using evvvvils method for material id's\n\tt.x=min(t.x,bo(abs(p)-vec3(4,0,4),vec3(.5,12.,.5)));\n  t.x=min(t.x,-length(p)+12.);\n\th=vec2(length(p-vec3(0,2,0))-2.3,1.2); //lets add some reflective stuff, just to show we can\n\tt=t.x<h.x?t:h; //how we mix material id's\n\th=vec2(bo(abs(p+vec3(0,-2.6+sin(tt*.4),0))-vec3(0,0,2.9),vec3(4.6,.5,.5)),2.9); //and some transparent stuff, for the same reason\n\tt=t.x<h.x?t:h;\n  vec3 np = p+vec3(0,-6.5,cos(tt*.5)*4.);np.yz*=r2(tt*.3); np.xz*=r2(tt*.2); //make it spin\n\th=vec2(bo(np,vec3(2.5,.2,.2)),10.5); //light geometry, and our lights of course also have materials\n#ifdef MULTILIGHT\n  g=vec2(bo(p+vec3(sin(tt*.5)*3.,-5.,cos(tt*.5)*3.),vec3(.2,.2,4.)),10.1); //more light geometry, define MULTILIGHT to see ...\n#ifndef MULTICOLOR\n  h.x=smin(h.x,g.x); //...soft minimum for smooth transition or...\n#else\n  h=vec2(smin(h.x,g.x),h.x<g.x?h.y:g.y); // ... ugly artifacts when multicolored lights interact since we only guess one light direction\n#endif\n#endif\n  glow+=(0.1/(0.1+pow(abs(h.x),2.))*.5)*getAlbedo(fract(h.y)); //accumulate some glow on our lights for better looks\n  t.x*0.9;h.x*=.9;\n  t=t.x<h.x?t:h; // final mixdown\n  \n\treturn vec4(t,h); //return dist and mat at xy, lights only on zw\n}\n\n\n\nvec3 tr(vec3 p, vec3 r) { //do it all in the trace, lights, materials, shadows, everything\n  vec4 m = vec4(0.001);float t=0.,sig,tf,ff;\n  vec3 no,acc=fo, sr; //some helpers \n  for(int b=0;b<2;b++) { //stay bouncy\n    sig=1.;tf=.75*float(b); //sign (are we inside yet?) and a correction factor for reflections and transparency, because I don't want full transparency or perfect reflections \n    for(int i=0;i<120;i++) {\n      p=p+r*m.x; //baby steps\n      m =abs(mp(p)); //a vec4 because we also need distance to closest light and its material\n      t+=m.x; //total distance\n      if(t>30.) return mix(fo,acc,ff*tf); //we went too far, use the last calculated fog color and correction factor to make sure far reflective objects get fogged correctly\n      if(m.x<0.001f) { //we hit something\n        mat4 drs = mat4(mp(p+e.xyy),mp(p+e.yyx),mp(p+e.yxy),mp(p+e.xxx)); //grab everything we need for normals and area light direction, so we don't need to calculate everything twice\n        no=normalize(e.xyy*drs[0].x+e.yyx*drs[1].x+e.yxy*drs[2].x+e.xxx*drs[3].x); //normals as usual\n        ld=-normalize(e.xyy*drs[0].z+e.yyx*drs[1].z+e.yxy*drs[2].z+e.xxx*drs[3].z); //light direction \n        sr=ld;ld=normalize(no*.05+ld); //store for shadows, then bias by normal to fake away edge cases and pretend our lights have volume\n        float dif=(1.-exp2(-2.*pow(max(0.,lr-m.z/lr),2.)))*max(.0,dot(no,ld)), //our diffuse light, similar to how we do...\n        aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(p+no*aor).x/aor),2.)), //... ambient occlusion!\n\t\tsp=pow(max(dot(reflect(-ld,no),-r),0.),4.), //specular\n        mi=fract(m.y),ri=trunc(fract(m.y*.1)*10.),si=trunc(m.y*.1); //encoded material properties, >10 means luminant, >1 means reflective, >2 means transparent, .1-.9 mark colors... so 11.2 is a reflective white light\n\t\tvec3 lc=getAlbedo(fract(m.w)); //encoded light material\n        vec3 nr,alb=getAlbedo(mi); //we have a helper for albedo, since we also use it for light color and glow\n        if(si>0.){dif=1.;sp=0.;} //luminant material\n        ff=exp(-.00012*t*t*t); //fog factor\n        acc=mix(fo,mix((sp*lc)*dif+alb*(.4*ao+0.6)*(lc*dif)+glow*.1,acc,tf),ri>=1.?ff+tf:ff); //mixdown, respect limits in reflection pass\n        if(ri<1.) {b=1;break;} //are we cool yet?\n        tf=.5; //increase opacity of transparent objects in the next bounce\n\t\tnr=ri<2.?refract(r,-no,1.-.8*noi(p)):refract(r,no*sig,.9-.8*noi(p)); //nope, not cool, so refract or reflect?\n        if(nr.x+nr.y+nr.z==0.){nr=reflect(r,no);ri+=1.;} //handle refraction edge cases\n        r=nr;p=p+r*.05; //our new ray\n        if(ri<2.) break; //reflect\n        sig=-sig; //refract\n      }\n    }\n    #ifdef USESHADOW //soft shadows\n\t//done in the bounce, so we have shadows in reflections and on reflective objects as well\n    vec3 so=p+sr*.01,sco=vec3(1); \n\tfloat st=0., sh = 1.; \n\tvec4 sd=vec4(.01,0,.01,0);\n    if(trunc(m.y*.1)<=0.) { //don't cast shadows on luminant objects\n\t\tfor(int i=0; i<80;i++) {\n\t\t  so=so+sr*sd.x; sd=abs(mp(so)); float ri = trunc(fract(sd.y*.1)*10.); \n\t\t  if(trunc(sd.y*.1)>0.) { break; } //we are close to a light, so bail\n      if(sd.x<.0001) {//we hit geometry and are most likely in total shadow...\n        if(ri>=2.)  { sd.x=0.01; } //... but maybe we hit something transparent\n        else {sh=0.0; break;} \n      } \n\t\t  sh=min(sh,sd.x/st*24.); st+=sd.x; //accumulate shadow\n      if(ri>=2.) { sh=max(sh,.4); sco=mix(getAlbedo(fract(sd.y)),vec3(1),sh); }//make transparency great again\n\t\t  if(st>lr*4.){  break; } //out of light radius, so bail\n\t\t}\n\t\tacc=acc*.5+acc*.5*sh*sco; //keep some ambient\n\t}\n    #endif\n  }\n  return acc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t//basic setup\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\ttt = mod(iTime,3000.0);\n\tvec3 ro=vec3(sin(tt*.25)*10.,4.,cos(tt*.25)*10.),\n\t\tcw=normalize(vec3(0.,1.5+sin(tt*.25)*1.5,0.)-ro),\n\t\tcu=normalize(cross(cw,vec3(0,1,0))),\n\t\tcv=normalize(cross(cu,cw)),\n\t\trd=mat3(cu,cv,cw)*normalize(vec3(uv,.5));\n\tfo=vec3(0.1,.2+uv.y*.2,.3+uv.y*.2); //background fog color\n\tvec3 co = tr(ro,rd); //the grand trace\n\tfragColor = vec4(co,1.f);\n}","name":"Image","description":"","type":"image"}]}