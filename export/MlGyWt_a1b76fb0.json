{"ver":"0.1","info":{"id":"MlGyWt","date":"1538091235","viewed":223,"name":"sharpen no artefacts","username":"SigSegOwl","description":"Used difference of gauss to mask the sharpen filter to prevent artefacts on low freq areas.\nProbably the most overkill solution...\n\nuse mouse x to adjust area\nuse mouse y to adjust strength","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sharpen","gauss","log"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 texSample(const int x, const int y, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;\n\tuv = (uv + vec2(x, y)) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).xyz;       \n}                                         \nvec3 sharpenFilter(in vec2 fragCoord, float strength){\n\tvec3 f =\n\ttexSample(-1,-1, fragCoord) *  -1. +                     \n\ttexSample( 0,-1, fragCoord) *  -1. +                    \n\ttexSample( 1,-1, fragCoord) *  -1. +                      \n\ttexSample(-1, 0, fragCoord) *  -1. +                    \n\ttexSample( 0, 0, fragCoord) *   9. +                     \n\ttexSample( 1, 0, fragCoord) *  -1. +                      \n\ttexSample(-1, 1, fragCoord) *  -1. +                     \n\ttexSample( 0, 1, fragCoord) *  -1. +                     \n\ttexSample( 1, 1, fragCoord) *  -1.\n\t;                                              \n    \n    //use diff as strength\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 diff = texture(iChannel1, uv).xyz;\n\n    float sharpen_strength = abs(diff.r - 0.5) * 2.0 * strength;\n    \n    //use this to see the diff of gauss which is used as sharpen strength\n    //return vec3(sharpen_strength, sharpen_strength, sharpen_strength);\n\treturn mix(texSample( 0, 0, fragCoord), f , sharpen_strength);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n\tvec2 uv = fragCoord/iResolution.xy;                    \n\tvec2 uvMouse = iMouse.xy/iResolution.xy;               \n\tif(uv.x > uvMouse.x){\n\t\tfragColor = vec4(sharpenFilter(fragCoord, uvMouse.y),1.0);             \n\t}else{\n\t\tfragColor = vec4(texSample( 0, 0, fragCoord),1.0);\n    }\n    if(uv.x > uvMouse.x - 0.002 && uv.x < uvMouse.x + 0.002){\n    \tfragColor = vec4(1.0,1.0,1.0,1.0);\n\t}\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//borrowed from https://www.shadertoy.com/view/XdfGDH\n\n//first blur\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\t\n    //declare stuff\n    const int mSize = 3;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    float final_colour = 0.0;\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            vec3 texC = texture(\n                iChannel0, (\n                    fragCoord.xy+vec2(float(i),float(j))\n                ) / iResolution.xy\n            ).rgb;\n            \n            float grayScale = (texC.x + texC.y + texC.z) / 3.0;\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*grayScale;           \n        }\n    }\n\n    float gaussFinal = final_colour/(Z*Z);\n    \n    //original texture\n    vec3 texCOrig = texture(\n        iChannel0, (\n            fragCoord.xy\n        ) / iResolution.xy\n    ).rgb;\n\n    float grayScaleOrig = (texCOrig.x + texCOrig.y + texCOrig.z) / 3.0;\n\n    fragColor = vec4(grayScaleOrig, gaussFinal, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//borrowed from https://www.shadertoy.com/view/XdfGDH\n\n//second blur\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\t\n    //declare stuff\n    const int mSize = 5;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    float final_colour = 0.0;\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            float grayScale = texture(\n                iChannel0, (\n                    fragCoord.xy+vec2(float(i),float(j))\n                ) / iResolution.xy\n            ).g;\n            \n            final_colour += kernel[kSize+j]*kernel[kSize+i]*grayScale;\n                \n\n        }\n    }\n\n    float gaussFinal = final_colour/(Z*Z);\n    \n    //original texture\n    vec3 texCOrig = texture(\n        iChannel0, (\n            fragCoord.xy\n        ) / iResolution.xy\n    ).rgb;\n\n    fragColor = vec4(texCOrig.r,texCOrig.g, gaussFinal, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//difference of gauss\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    \n    float gauss1 = texture(iChannel0, pos).g;\n    float gauss2 = texture(iChannel0, pos).b;\n    \n    \n    fragColor = vec4((gauss2 - gauss1), 0.0, 0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}