{"ver":"0.1","info":{"id":"l3syDj","date":"1726942886","viewed":49,"name":"Water waves propagation","username":"cesio","description":"Water drop propagation effect using finite differences method based on https://www.shadertoy.com/view/4sd3WB","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["waves","water","propagation","method","finite","differences"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n// finite differences method taken from https://www.shadertoy.com/view/4sd3WB\n\n// how strong the distortion due to gradient should be\n#define D 0.7\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the current pixel\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    \n    // \"size\" of a single pixel (to calculate \"neightbours\")\n    float dx = 1. / iResolution.x;\n    float dy = 1. / iResolution.y;\n    \n    // calculation of coordinates of \"neightbours\" of the current \"pixel\"\n    vec2 pixelUp = vec2(uv.x, uv.y - dy);\n    vec2 pixelDown = vec2(uv.x, uv.y + dy);\n    vec2 pixelLeft = vec2(uv.x - dx, uv.y);\n    vec2 pixelRight = vec2(uv.x + dx, uv.y);\n    \n    // get \"wave\" for neightbours\n    float upPixelElevation = texture(iChannel0, pixelUp).x; \n    float leftPixelElevation = texture(iChannel0, pixelLeft).x; \n    float rightPixelElevation = texture(iChannel0, pixelRight).x; \n    float downPixelElevation = texture(iChannel0, pixelDown).x; \n    \n\n    // calculate gradient to understand how to \"distort\" the current pixel\n    vec3 gradient = normalize(vec3(rightPixelElevation - leftPixelElevation, downPixelElevation -  upPixelElevation, 1.));\n    // calculated position of \"shifted\" (distorted) \"pixel\"\n    vec2 shiftedUV = uv +  gradient.xy * D;\n    \n    \n    fragColor = texture(iChannel1, shiftedUV);\n } ","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// damping of the wave\n#define DAMPING 0.97\n\n\n\n// based on https://www.shadertoy.com/view/4sd3WB (!!!)\n// this buffer stores the current elevation/speed of each pixel and \"propagates\" the wave using finite differences method\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float dx = 1. / iResolution.x;\n    float dy = 1. / iResolution.y;\n    \n    // calculation of coordinates of \"neightbours\" of the current \"pixel\"\n    vec2 pixelUp = vec2(uv.x, uv.y - dy);\n    vec2 pixelDown = vec2(uv.x, uv.y + dy);\n    vec2 pixelLeft = vec2(uv.x - dx, uv.y);\n    vec2 pixelRight = vec2(uv.x + dx, uv.y);\n    \n    // read the current values of elevation (x) and velocity (y) of the wave\n    vec2 currentPixel = texture(iChannel0, uv).xy;\n    float currentElevation = currentPixel.x;\n    float currentVelocity = currentPixel.y;\n    \n    // finite differences\n    float leftPixelElevation = texture(iChannel0, pixelLeft).x;\n    float rightPixelElevation = texture(iChannel0, pixelRight).x;\n    float upPixelElevation = texture(iChannel0, pixelUp).x;\n    float downPixelElevation = texture(iChannel0, pixelDown).x;\n \n \n    // calculate new elevation\n    float newElevation = currentElevation + currentVelocity + \n          0.5 * (leftPixelElevation + rightPixelElevation + upPixelElevation + downPixelElevation - 4.0 * currentElevation);\n      \n    newElevation = DAMPING * newElevation;\n    \n    // store elevation and velocity\n    fragColor = vec4(newElevation, newElevation - currentElevation,0.0,0.0);\n    \n   \n   //fragColor = vec4(0.2 + fract(iTime),sin( fract(iTime)),0.8,0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define A 1.2\n#define sqrtA 1.4142135\n\n// this buffer is used to \"add\" drops to the wated\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord.xy / iResolution.xy;\n     fragColor = texture(iChannel0, uv);\n      \n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 st = fragCoord/iResolution.xy;\n     st = st * 2.0 - 1.0;\n     st.x *= iResolution.x/iResolution.y;\n\n        // (x,y) - lemniscate of bernoulli\n        float posX = (A * sqrtA * cos(iTime )) / (1. + pow(sin(iTime ),2.));\n        float posY = (A * sqrtA * cos(iTime ) * sin(iTime )) / (1. + pow(sin(iTime),2.)) * 1.5;\n\n        \n        if (distance(st, vec2(posX, posY)) < 0.01) {\n            fragColor = vec4(0.0,0.2,0.,0.);\n        }\n\n    \n}\n\n\n","name":"Buffer B","description":"","type":"buffer"}]}