{"ver":"0.1","info":{"id":"7sdyzM","date":"1653427562","viewed":217,"name":" WFC Hex 3D","username":"kastorp","description":"3d version","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["map","hex","tiles","generation","wfc"],"hasliked":0,"parentid":"Nsj3Rz","parentname":"WFC Map Hex"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// WFC Hex 3D\n\n\n#define DEBUG 1\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 i = floor(x), f = fract(x);\n    f = f*f*(3.0-2.0*f);\t\n    return mix(mix( hash(i+vec2(0,0)),hash(i+vec2(1,0)),f.x),mix( hash(i+vec2(0,1)),hash(i+vec2(1,1)),f.x),f.y);\n}\n\nvoid map( out vec4 O, in vec2 p)\n{\n    vec4 p0 = HexRep(p);\n    vec3 c= HexD(p0.xy);\n    vec2 d=p0.xy;\n    \n    uvec4 tx = TX(p0.zw);   \n    uint m =tx.x; \n    if(tx.a>1u || DEBUG==0){\n        float br1= noise(p*3.)*.2+.8,br2= noise(p*10.)*.1+.9,br3= noise(p*10.)*.4+.6,br4=mod(floor(d.x*4.)+floor(d.y*4.),2. )*.1+.9;\n\n\n        \n        //terrain\n        for(int i=0;i<6;i++) {\n            uint k= (m & (1u<<(2*i))*3u)>>(2*i);\n            if(int(c.y)==i) O = vec4(k==1u?vec3(.3,.5,0)*br1:k==2u?vec3(0,.5,.5)*br2:k==3u?vec3(.7,.6,0)*br4:vec3(0,.3,0)*br3,0);\n        }\n        \n\n\n        //roads & rivers\n        float db=-1.;\n        for(int i=0;i<6;i++) { \n            \n            uint k= (m & (1u<<(2*i +12))*3u)>>(2*i+12);\n            if(k>0u) db=max(db,.06-abs(c.x));\n            if(k>0u && int(c.y)==i) db= max(db,.05-abs(c.z));\n            \n            O =mix(O, vec4(.6,.3,.1,0.),smoothstep(-TH1,0.,db));\n        }\n       \n        O =mix(O, O*.6, smoothstep(TH2,0.0,abs(db)));\n\n\n\n        // border:\n        O =mix(O,vec4(.3,.3,.3,0),.5*smoothstep(-TH1,0., -.52+abs(c.x)));        \n     \n    } \n    //check\n    #if (DEBUG>0)\n    if(tx.z>0u) O =mix(O,vec4(.8,.8,0,0),smoothstep(-TH1,0., -.4+abs(c.x)));          \n    if(tx.y>COLLAPSE-5u && tx.a==2u) O =mix(O,vec4(.5,.0,0,0),smoothstep(-TH1,0., -.45+abs(c.x)));\n    if(tx.y>COLLAPSE-5u && tx.a<2u) O =mix(O,vec4(1.,.0,0,0),smoothstep(-TH1,0., -.4+abs(c.x)));\n    #endif\n}\n\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 0, 1), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 Q ){\n#if 0\n    //2D version\n    map(O, Q/MZ/2. );\n#else\n    //3D version\n   float an =iMouse.x <= 0. ? T:1.54;\n   vec2 uv = (Q - .5 * R.xy) / R.y;\n   vec3 ro = vec3(R.xy/MZ/2.,10)*50./Z +vec3(M.xy*vec2(-3,3),0), \n        la=  vec3(ro.xy+ 10.* vec2(cos(an),sin(an)),0.),\n        rd=getRayDir(ro,la,uv);\n    \n    if(ro.z>1.5) {ro -= rd*(ro.z-1.5)/rd.z;}\n    vec2 ro_cell = ro.xy - HexRep(ro.xy).xy , cc = ro_cell,n;\n    vec3 pt = ro;\n    for (int i=0; i<100; ++i) {   \n      \n        vec3 ht = HexI(pt.xy-cc,rd.xy);\n        \n        float h = 1.;\n        vec2 id = HexRep(cc).zw;        \n        uvec4 tx = TX(id);\n        uint m =tx.x; \n        for(int i=0;i<6;i++) {\n            uint k= (m & (1u<<(2*i))*3u)>>(2*i);\n             \n                h =  min(h,\n                         k==1u? .1: //grass\n                         k==2u? 0.: //sea\n                         k==3u? .2 : //farm\n                                .3//mountain\n                         );\n        }\n        uint b= (m & (1u<<24)*15u)>>24;\n        if(b==1u) {\n            vec2 t=iBox(ro- vec3(cc,h) ,rd,vec3(.2,.2,.4));\n            if(t.x>0. && t.x<NOHIT &&(ro+rd*t.x).z>h) {\n              O = (ro+t.x*rd).z -h >.3? vec4(1.,0,0,0):vec4(.9) ;\n               \n               O*= .5 + .4* dot(oNor,normalize(vec3(1,0,2)));\n               return;\n            }\n        }\n        if(b==3u) {\n            vec2 t=iSphere(ro- vec3(cc,h) ,rd,.2);\n            if(t.x>0. && t.x<NOHIT &&(ro+rd*t.x).z>h) {\n               O =vec4(.2) ;\n               O*= .5 + .4* dot(oNor,normalize(vec3(1,0,2)));\n               return;\n            }\n        } \n        if(b==2u) {\n            vec4 t=iCappedCone(ro,rd,vec3(cc,h), vec3(cc,h+.7),.3,.1  );\n            if(t.x>0. && t.x<NOHIT &&(ro+rd*t.x).z>h) {\n               O =vec4(0.4,0.5,0.5,0) ;\n               O*= .5 + .4* dot(t.yzw,normalize(vec3(1,0,2)));\n               return;\n            }\n        }   \n        float ph = pt.z + rd.z *ht.z;\n        if(ph <h && pt.z >h){\n            vec2 id2 =HexRep(pt.xy - (pt.z-h)/rd.z*rd.xy).zw;            \n            if(length(id2-id)<.01 ){\n                map(O,(pt.xy - (pt.z-h)/rd.z*rd.xy));\n               //O=vec4(i)/10.;\n                return;\n            }\n\n        }\n        else if(ph <h ){\n            map(O,pt.xy);\n            O*= .5 + .3* dot(n,vec2(1,0));\n            return;\n        }\n        cc +=  ht.xy;\n        pt += rd*(ht.z);\n        n= -normalize(ht.xy);\n        \n    }\n    if(pt.z>0.){\n        pt=  ro - rd*ro.z/rd.z;\n        map(O,pt.xy);\n    }\n    \n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define T iTime*.15\n#define MZ 3. \n#define Z 64.\n#define M (iMouse.x<=0.?R.xy/Z*MZ*(.5 +.2*vec2(cos(T),sin(T))):(iMouse.xy-R.xy)/Z*MZ)\n#define TX(p) floatBitsToUint(texelFetch(iChannel0, ivec2(p)%ivec2(R.xy),0))\n#define DIRS(d,d2) ivec2[4] (ivec2(-d,d2),ivec2(d2,d),ivec2(d,-d2),ivec2(-d2,-d)) \n#define NX(p,nb)  uvec4[6] (TX(p+ivec2(nb[0])),TX(p+ivec2(nb[1])),TX(p+ivec2(nb[2])),TX(p+ivec2(nb[3])),TX(p+ivec2(nb[4])),TX(p+ivec2(nb[5]))) \n#define B 16 //inizialition cell range \n#define COLLAPSE 25u\n#define RETRY 50\n#define RANGE 2\n\n#define TH1 0.05\n#define TH2 0.02\n\n#define slice(n,d) (smoothstep(-TH1,0.,(d.x-d.y)*(n>=4?1.:-1.)) *smoothstep(-TH1,0.,(d.x+d.y)*(n>=2 && n<=5?1.:-1.))*smoothstep(-TH1,0.,d.x*(n>=3&&n<=6?1.:-1.))*smoothstep(-TH1,0.,-d.y*(n>=5||n==0?1.:-1.)) ) \n#define box(d,c,b) smoothstep(-TH2,TH2,-max(abs(d.x-c.x) - b.x,abs(d.y-c.y) - b.y) )\n#define circle(d,c,b) smoothstep(-TH2,TH2,-length(d-c) + b )\n//---------------\n\n//intersectors\nvec3 oNor;\n#define NOHIT 1e5\nvec2 iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return vec2(NOHIT); // no intersection\n    h = sqrt( h );\n    oNor =normalize(ro-(b+h)*rd); \n    return h-b < 0. ? vec2(NOHIT) : -b-h>=0. ?  vec2(-b-h,+b-h): vec2(0.);\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return vec2(NOHIT); // no intersection\n    oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);     \n    return tN<0.? vec2(0.): vec2(tN,tF);\n}\n\n//Iq\nfloat dot2( in vec3 v ) { return dot(v,v); }\nvec4 iCappedCone( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n         if( m1<0.0 ) { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) return vec4(-m1/m3,-ba*inversesqrt(m0)); }\n    else if( m2>0.0 ) { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) return vec4(-m2/m3, ba*inversesqrt(m0)); }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if( y>0.0 && y<m0 ) \n    {\n        return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n    }\n    \n    return vec4(-1.0);\n}\n\n//-----HEX FUNCTIONS-------------\n\n//from https://www.shadertoy.com/view/Nss3Wl\n\n//output: xy= local position,zw=hex integer coordinates\nvec4 HexRep(vec2 U)\n{\n   const float d =sqrt(3.);\n    vec4 c1= vec4(U-vec2(floor(U.x-.5)+1.,floor(U.y/d)*d+d/2.),floor(U.x-.5),floor(U.y/d)*2.),\n         c2= vec4(U-vec2(floor(U.x)+.5,floor(U.y/d-.5)*d+d),floor(U.x),floor(U.y/d-.5)*2.+1.);\n    return dot(c1.xy,c1.xy) <dot(c2.xy,c2.xy) ?c1:c2;\n}\n\n//input: hex coordinates, output: neighbour relative coordinates\nivec2[6] HexNb(ivec2 n)\n{\n   int sh=n.y&1;\n   return  ivec2 [6](ivec2(-1,0),ivec2(-sh,1),ivec2(-sh+1,1),ivec2(1,0),ivec2(-sh+1,-1),ivec2(-sh,-1)); //6 neighbours  \n}\n\n//input: local position, output: x=hex distance, y=sector 0-5 , z=distance from sector center\nvec3 HexD(vec2 p)\n{ \n    float a= mod(floor(-atan(p.y,p.x)/6.283*6.+3.5),6.), aa=a/6.*6.283+1.57;\n    vec2 va=-vec2(sin(aa),cos(aa) );\n    return vec3( dot(p,va), a , p.x*va.y - p.y*va.x   );\n}\n\n\nvec3 rMin(vec3 a, vec3 b) {\n    return a.z < b.z ? a : b;\n}\n\nvec3 HexI(vec2 ro, vec2 rd)\n{ \n const float  h =sqrt(3.), r=.5;\n \n \n float s0= sign( rd.x  ), \n       s1= sign( rd.y *h + rd.x),\n       s2= sign(-rd.y *h + rd.x);\n       \n       \n  //ro -=vec2(0,.078); \n       \n vec2  n0= s0*r*vec2(2.,0),\n       n1= s1*r*vec2(1., h),\n       n2= s2*r*vec2(1.,-h); \n \n float\n       d0=  (r * s0 - ro.x) /rd.x ,\n       d1=  (r* h *s1 - ro.x - ro.y *h+.133*s1)/(rd.x + rd.y*h) ,\n       d2=  (r* h *s2 - ro.x + ro.y *h+.133*s2)/(rd.x - rd.y*h) ;  \n return  rMin(vec3(n0,d0 ),rMin( vec3(n1,d1),vec3(n2,d2)));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nuint rotateMask(uint m, int r0){\n    uint mm =m;\n    int r=(r0%6);\n    \n  \n    uint terr= m & ((1u<<12)-1u),\n        conn = (m>>12)& ((1u<<12)-1u),\n        bui = (m>>24)& ((1u<<4)-1u);\n    terr = (terr>>(2*r))+ ((terr&((1u<<(2*r)) -1u   ))<<(12-2*r));\n    conn = (conn>>(2*r))+ ((conn&((1u<<(2*r)) -1u   ))<<(12-2*r));\n      \n    return terr+ (conn<<12) + (bui<<24);\n}\n\n\n\nfloat hash( in vec3 p ) {\n    p = fract( p * vec3( 19.191, 53.733, 73.761 ) );\n    p += dot( p, p + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( ( p.x +  p.y ) * p.z );\n}\n//get Random mask \nuint getTerrain(vec3 seed) {\n    \n    //road\n    uint rm=0x10000000u, //road cross\n        rm2=0x20000000u; //road start\n    \n    //terrain  5=grass,A=sea, F=farm,0=forest\n    int i=int(hash(seed)*1400.);\n    int k= int(hash(seed*2.)*100.);\n    if( i <40) return rotateMask(0x5AAu, i); //33% Grass - 66% sea\n    else if(i <80) return rotateMask(0x55Au, i); //66% Grass - 33% sea\n    else if(i <100) return rotateMask(0x559u, i); //87% Grass - 16% sea\n    \n    else if(i <160) return rotateMask(0x57Fu, i)+rm; //50% Grass - 50% farm    \n    else if(i <200) return rotateMask(0x55Fu, i)+rm; //66% Grass - 33% farm\n    else if(i <230) return rotateMask(0x557u, i)+rm; //83% Grass - 16% farm\n    else if(i <260) return rotateMask(0x5FFu, i)+rm; //33% Grass - 66% farm\n    \n    \n    else if(i <300) return rotateMask(0x540u, i)+rm; //50% Grass - 50% forest\n    else if(i <360) return rotateMask(0x550u, i)+rm; //66% Grass - 33% forest \n    else if(i <400) return rotateMask(0x500u, i)+rm; //33% Grass - 66% forest\n    else if(i <440) return rotateMask(0x554u, i)+rm; //83% Grass - 16% forest\n    else if(i <460) return rotateMask(0x41Au, i); //33% Grass - 33% forest -33% sea\n    \n\n    else if(i<580) return 0x000555u + (k<8? 0x1000000u +rm2 :rm  ); //grass\n    else if(i<1170) return 0x000AAAu ; //sea\n    else if(i<1310) return 0x0000000u+  (k<5?0x2000000u:k<20? 0x3000000u +rm2 : rm  ); //forest\n    else if(i<1400) return 0x000FFFu+  + (k<8? 0x1000000u +rm2 :rm  );  ; //farm\n    \n}\n\nuint getConnection(vec3 seed,uint rt) {\n    \n    if(rt==0u) return 0u;//no road\n       \n    int j=int(hash(seed*3.1)*100. );\n    if(rt>1u) return j>65? 0u:rotateMask(0x1000u, j); //start road\n    \n    //road\n    uint rm=0u;\n    if(j<5)       rm=rotateMask(0x110000u, j); //turn\n    else if(j<10) rm=rotateMask(0x101000u, j); //turn\n    else if(j<16) rm=rotateMask(0x111000u, j); //intersection\n    else if(j<18) rm=rotateMask(0x005000u, j); //narrow turn\n    else if(j<19) rm=rotateMask(0x150000u, j); //\n    else if(j<20) rm=rotateMask(0x510000u, j); //\n    else if(j<22) rm=rotateMask(0x501000u, j); //\n    else if(j<24) rm=rotateMask(0x105000u, j); //\n    else if(j<26) rm=rotateMask(0x105000u, j); //\n    else if(j<28) rm=rotateMask(0x504000u, j); //\n    else if(j<40) rm=rotateMask(0x104000u, j); //straight \n    return rm;\n    \n}\n//check if mask m is compatible (connection ad terrain) with n mask n on side i\nbvec2 check(uint m, uint n, int i){\n    uint \n        t1= (m & (1u<<(2*i))*3u)>>(2*i),        \n        c1= (m & (1u<<(2*i+12))*3u)>>(2*i+12),\n        b1 =(m & (1u<<(24))*15u)>>(24);\n    int    j=(3+i)%6;\n    uint    t2= (n & (1u<<(2*j))*3u)>>(2*j),     \n        c2= (n & (1u<<(2*j+12))*3u)>>(2*j+12),\n        b2 =(n & (1u<<(24))*15u)>>(24);\n    \n    return  bvec2( t1==t2  && (b1&b2)==0u,   c1==c2   );  \n}\n\nvoid mainImage( out vec4 O, in vec2 Q )\n{\n    ivec2 c = ivec2(Q);\n    uvec4 s=uvec4(0u);\n    uvec4 tx= TX(c);\n    if(any(greaterThan(Q,R.xy/MZ))) discard;\n    //initialize some cells (one every BxB block) with random value\n    if(iFrame==0 || tx.a==0u){\n       s= max(c.x% B,c.y %B)<1 ? uvec4(getTerrain(vec3(Q,T)),0u,0u,3u) :uvec4(0u,0u,0u,1u);\n    } \n    else\n    {       \n        uint m=tx.x, //current mask, -1= void \n            try=tx.y,//current number of failed tentatives\n            lv=tx.a;  //0=reset, 1=empty,2=terrain\n        uvec4[6] N = NX(c,HexNb(c)) ; //neighbours on 6 sides; order: Left Up Right Bottom     \n        float db=0.;\n        \n        if(lv<2u) //EMPTY\n        {\n            int b; //number of non void neighbours\n            bool ch; //=true if candidate matches neghbours\n           \n            uint mm; //candidate mask\n            for(int j=0;j<RETRY;j++){ //each frame, iterate candidate mask search\n                b=0; ch=true;\n                mm=  getTerrain(vec3(Q,T)+float(j)*3.111) ; //set candidate mask if void\n                for(int i = 0;i<6 ;i++) { \n                   if(N[i].a>1u) {\n                       b++;                   \n                       bvec2 chn = check(mm,N[i].x,i); //verify compatibility on current side\n                       ch= ch && chn.x ;//&& chn.y;\n\n                    }\n                }\n                if( ch ) break; // skip if succesfull mask search\n            }  \n            \n            if( b==0) try=0u;\n            else if(ch) { m=mm; lv=2u; try=0u; } //if compatible and connected, set candidate mask         \n            else try=(try+1u)&1023u; \n          \n        }\n        else if(lv<3u) //TERRAIN \n        {\n            \n            int b; //number of non void neighbours\n            \n            bool cht=true, chc=true;\n            uint mm; //candidate mask\n            \n            uint roadT= (m & (1u<<(28))*15u)>>(28);\n            \n            for(int j=0;j<RETRY;j++){ //each frame, iterate candidate mask search\n                b=0; cht=true;chc=true;\n                mm=  ( m & 0xFF000FFFu )+ getConnection(vec3(Q,T)+float(j)*3.111,roadT) ; //set candidate mask if void                \n                for(int i = 0;i<6 ;i++) { \n                   if(N[i].a>1u) {\n                                       \n                       bvec2 chn = check(mm,N[i].x,i); //verify compatibility on current side\n                       cht= cht && chn.x;\n                       if(N[i].a>2u //&&(N[i].x&0xFFF000u)>0u \n                           ) {b++; chc= chc && chn.x && chn.y;}\n                      \n                       \n                    }\n                    if(  N[i].y > COLLAPSE ) {if(N[i].a >1u)  chc=false; else cht=false;}\n                }\n                if( !cht ) break; // skip if succesfull mask search\n                 if( chc ) break;\n            }  \n            \n            \n            if(!cht   ) { \n                //invalidate if not compatible  \n                lv=1u; \n                try=0u; db=1.;\n            } \n            else if(chc) { m=mm; lv=3u; try=0u; } //if compatible and connected, set candidate mask         \n            else if(b==0) try=0u;\n            else try=(try+1u)&1023u; \n            \n            \n        }\n        else if(lv>=3u) // TERRAIN + ROAD\n        {\n                 \n            bool cht=true, chc=true;\n            for(int i = 0;i<6 ;i++) { \n               if(N[i].a>1u) {\n                                 \n                   bvec2 chn = check(m,N[i].x,i); //verify compatibility on current side\n                   cht= cht && chn.x;\n                   if(N[i].a>2u) chc= chc && chn.x && chn.y;\n\n                }\n                // if a neighbour as reached the try limit, invalidate current cell\n                if( N[i].y > COLLAPSE ) {if(N[i].a >1u)  chc=false; else cht=false;}\n            }               \n      \n            if(!chc || !cht ) { \n                if(((c.x+c.y+iFrame)%3)==0){\n\n                    // clean connection\n                    lv=2u; \n                    m = m & 0xFF000FFFu; \n                    try=0u; db=1.;\n                }\n            }\n            \n        }\n        \n        s=uvec4(m,try,db,lv);\n    }\n\n\n    O = uintBitsToFloat(s);\n} ","name":"Buffer A","description":"","type":"buffer"}]}