{"ver":"0.1","info":{"id":"lcSSDK","date":"1707047327","viewed":192,"name":"SDF Monte Carlo Path Tracer","username":"dema","description":"A Monte Carlo Path Tracer for Signed Distance Functions. The implementation is based on the didactic material of the course https://youtube.com/playlist?list=PLujxSBD-JXgnGmsn7gEyN28P1DnRZG7qi&si=VhCSxMNQD6JeUJ7T.\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarch","sdf","pathtracer","montecarlo","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// n is the normal direction, h moves the \n// plane in the negative normal direction\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n#define FOVX (PI/4.)\n#define MAX_DIST 100.\n#define MAX_ITER 70\n#define MIN_DIST 0.01\n#define DEPTH 16\n\n\n#define RAND1 texture(iChannel1,fragCoord.xy/iResolution.xy).x\n#define RAND2 texture(iChannel1,fragCoord.xy/iResolution.xy).y\n#define RAND3 texture(iChannel1,fragCoord.xy/iResolution.xy).z\n\n/*\n* DATA TYPES\n*/\nstruct Object{\n    float sdf;\n    vec3 color;\n    float emission;\n    float refr_index; // only for refractive materials\n    int type; // 0 -> light, 1 -> diffuse, 2 -> specular, 3 -> refractive \n};\n\nstruct Intersection{\n    float t;\n    Object obj;\n};\nstruct Ray{\n    vec3 o;\n    vec3 d;\n};\n\n\n/*\n* SCENE INSTANTIATION\n*/\nObject opU(Object o1, Object o2) {\n    if (o1.sdf <= o2.sdf) return o1; else return o2;\n}\n\nObject map(vec3 pos){\n    Object li = Object(sdSphere(pos - vec3(0.,1.1,0.),.3),vec3(0.,0.,0.),1000.,0.,0);\n    Object s1 = Object(sdSphere(pos - vec3(0.,0.,0.6),0.4),vec3(1.0,1.0,1.0),0.,1.5,3);\n    Object s2 = Object(sdSphere(pos - vec3(-0.6,0.,-0.2),0.4),vec3(1.,0.,0.),0.,0.,2);\n    Object s3 = Object(sdSphere(pos - vec3(0.6,0.,-0.2),0.4),vec3(0.20, 0.48, 0.57),0.,0.,1);\n    Object bo = Object(sdPlane(pos,vec3(0.,1.,0.),.4),vec3(1.,1.,1.),0.,0.,1);\n    Object up = Object(sdPlane(pos,vec3(0.,-1.,0.),1.05),vec3(1.,1.,1.),0.,0.,1);\n    Object ba = Object(sdPlane(pos,vec3(0.,0.,1.),1.05),vec3(1.,1.,1.),0.,0.,1);\n    Object le = Object(sdPlane(pos,vec3(1.,0.,0.),1.3),vec3(0.0549, 0.6392, 0.0),0.,0.,1);\n    Object ri = Object(sdPlane(pos,vec3(-1.,0.,0.),1.3),vec3(0.6314, 0.0, 0.0),0.,0.,1);\n       \n    \n    return opU(opU(opU(opU(opU(opU(opU(opU(li,s1),bo),up),s2),s3),ba),le),ri);\n}\n\n\n/*\n* HELPER FUNCTIONS\n*/\nvec3 crossProductSafe(vec3 a, vec3 b) {\n    float eps = 1e-6;\n    vec3 cr = cross(a, b);\n    if (length(cr) < eps) {\n        // If 'a' and 'b' are nearly parallel, choose a different vector for 'b'\n        b = vec3(b.z, b.x, b.y);\n        cr = cross(a, b);\n    }\n    return cr;\n}\n\nvoid createOrthonormalSystem(vec3 v, out vec3 x_axis, out vec3 y_axis, out vec3 z_axis) {\n    y_axis = normalize(v);\n    // Choose a vector not parallel to 'v' to start with\n    vec3 helper = abs(v.y) < abs(v.x) ? vec3(1, 0, 0) : vec3(0, 0, 1);\n    // Use cross product to find a vector orthogonal to 'v'\n    x_axis = normalize(crossProductSafe(helper, y_axis));\n    // Now find the third axis\n    z_axis = normalize(cross(y_axis, x_axis));\n}\n\nvec3 sampleHemisphere(float u, float v) {\n    // Convert uniform random variables u and v into spherical coordinates\n    float theta = 2.0 * 3.14159265359 * u; // azimuthal angle\n    float phi = acos(1.0 - 2.0 * v); // polar angle\n    // Convert spherical coordinates to a direction vector\n    float x = sin(phi) * cos(theta);\n    float y = cos(phi);\n    float z = sin(phi) * sin(theta);\n\n    return vec3(x, y, z);\n}\n\n\nvec3 calcNormal(vec3 p){\n    vec3 dx = vec3(.001,0.,0.);\n    vec3 dy = vec3(0.,.001,0.);\n    vec3 dz = vec3(0.,0.,.001);\n    float fp = map(p).sdf;\n    return normalize(\n        dx * (map(p+dx).sdf - fp) + \n        dy * (map(p+dy).sdf - fp) +\n        dz * (map(p+dz).sdf - fp)\n    );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nbool validIntersection(Intersection intersection){\n    return intersection.t < MAX_DIST;\n}\n\n/*\n* PATH TRACING\n*/\nIntersection rayMarch(Ray r){\n    float t = 0.;\n    Object current = map(r.o + t*r.d);\n    \n    for(int i = 0; i < MAX_ITER; i++){\n        if (abs(current.sdf) < MIN_DIST || t > MAX_DIST) break;\n        t += abs(current.sdf);\n        current = map(r.o + t*r.d);\n    }\n    return Intersection(t,current);\n}\n\nstruct TraceData{\n    bool valid;\n    Intersection intersection;\n    Ray ray;\n    vec3 hitpoint;\n    vec3 normal;\n};\n\nvec3 trace(Ray ray, float rand1, float rand2, float rand3){\n    TraceData stack[DEPTH];\n    for (int it = 0; it < DEPTH; it ++){\n        if(ray.d == vec3(0.)){\n            TraceData td;\n            td.valid = false;\n            stack[it] = td;\n            continue;\n        }\n\t\tIntersection intersection =  rayMarch(ray);\n\t\tif (!validIntersection(intersection)) {\n\t\t\tray.d = vec3(0.);\n\t\t\tTraceData td;\n\t\t\ttd.valid = false;\n\t\t\tstack[it] = td;\n\t\t\tcontinue;\n\t\t};\n        vec3 hitpoint = ray.o + ray.d * intersection.t;\n        //return 20.*vec3(intersection.t)/MAX_DIST; //DEBUG\n        vec3 normal = calcNormal(hitpoint);\n        //return abs(normal); //DEBUG\n        ray.o = hitpoint + 1.5 * MIN_DIST * normal;\n        \n        if(intersection.obj.type <= 1){\n            vec3 rotx,roty,rotz;\n            createOrthonormalSystem(normal,rotx,roty,rotz);\n            vec3 sampled_dir = sampleHemisphere(rand1,rand2);\n            vec3 rotated_dir;\n            rotated_dir.x = dot(vec3(rotx.x,roty.x,rotz.x),sampled_dir);\n            rotated_dir.y = dot(vec3(rotx.y,roty.y,rotz.y),sampled_dir);\n            rotated_dir.z = dot(vec3(rotx.z,roty.z,rotz.z),sampled_dir);\n            //return abs(rotated_dir); //DEBUG\n\n            ray.d = rotated_dir;\n        }\n        if(intersection.obj.type == 2){\n            float costheta = dot(ray.d,normal);\n            ray.d = (ray.d - normal*(costheta*2.));\n            ray.d = normalize(ray.d);\n        }\n        if(intersection.obj.type == 3){\n            float n = intersection.obj.refr_index;\n            float r0 = (1.0-n)/(1.0+n);\n            r0 = r0 * r0;\n            if (intersection.obj.sdf<0.){\n                normal = -normal;\n                ray.o = hitpoint + 1.5 * MIN_DIST * normal;\n                n = 1./n;\n            }\n            n = 1./n;\n            float cost1 = -dot(normal,ray.d);\n            float cost2 = 1.0 - n*n*(1.0-cost1*cost1);\n            float r_prob = r0 + (1.0-r0)*pow(1.0-cost1,5.0);\n            if (cost2 > 0. && rand3 > r_prob){\n                ray.d = (n*ray.d)+((n*cost1-sqrt(cost2))*normal);\n                ray.d = normalize(ray.d);\n                ray.o = hitpoint + 2.1 * MIN_DIST * - normal;\n            }\n            else{\n                ray.d = ray.d + (2.*cost1)*normal;\n                ray.d = normalize(ray.d);\n            }\n        }\n\t\tTraceData td;\n\t\ttd.intersection = intersection;\n\t\ttd.ray = ray;\n\t\ttd.valid = true;\n\t\ttd.hitpoint = hitpoint;\n\t\ttd.normal = normal;\n\t\tstack[it] = td;\n    }\n    vec3 clr = vec3(0.);\n\tfor(int it = DEPTH-1;it>=0;it--){\n\t\tTraceData td = stack[it];\n\t\tif(td.valid){\n\t\t\tif(td.intersection.obj.type == 0){\n\t\t\t\tfloat emission = td.intersection.obj.emission;\n\t\t\t\tclr = clr + vec3(emission, emission, emission);\n\t\t\t}\n\n\t\t\tif(td.intersection.obj.type == 1) {\n\t\t\t\tfloat cost=dot(td.ray.d,td.normal);\n\t\t\t\tclr = clr * td.intersection.obj.color * cost * 0.1;\n\t\t\t}\n\n\t\t\tif(td.intersection.obj.type == 2) {\n\t\t\t\tclr = clr;\n\t\t\t}\n\t\t\tif(td.intersection.obj.type == 3) {\n\t\t\t\tclr = clr * 1.15;\n\t\t\t}\n\t\t}\n\t}\n    return clr;\n}\n\n\n/*\n* DRAW\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ta = vec3( 0.,0.,0.);\n    vec3 ro = ta + vec3(0.,.5,3.);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    const float fl = 2.5;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = ca * normalize( vec3(p,fl) );\n    \n    Ray ray = Ray(ro,rd);\n    vec3 color = trace(ray,RAND1,RAND2,RAND3);\n    float count = float(iFrame) + 1.0;\n    vec3 old = texture(iChannel0,fragCoord.xy/iResolution.xy).xyz;\n    vec3 new = old + (color - old) / count;\n\n    // Output to screen\n    fragColor = vec4(new,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Noise generator from: https://www.shadertoy.com/view/4lc3WX\n/*\nLinear Feedback Shift Register (LFSR)\n\nA feedback bit is calculated by XORing together bits from selected taps in the register.\nThen all bits in the register are shifted left with the feedback bit being shifted into the LSB.\n\nMSB                          <-- Shift                            LSB\n|-------X------| |-------Y------| |-------Z------| |-------W------|\n1010101010101010 1010101010101010 1010101010101010 1010101010101010<________________________\n|          |                      |                  |      |  ___                           |\n|(63)  (52)|                  (31)|              (13)|   (6)|_|   |    ___                   |\n|          |                      |                  |________|XOR|___|   |    ___           |\n|          |                      |                           |___|  _|XOR|___|   |    ___   |\n|          |                      |_________________________________| |___|  _|XOR|___|   |  |\n|          |________________________________________________________________| |___|  _|XOR|__|(feedback)\n|___________________________________________________________________________________| |___|\n*/\n\n#define BITS_PER_FLOAT 16.0\n\n//Seed registers using a noise texture (prevents patterns in the first few frames).\n#define TEXTURE_SEED\n\n//Returns component 'i' of vec4 'v4'.\nfloat SelectComp(vec4 v4, float i)\n{\n\ti = floor(i);\n    return (i == 0.0) ? v4.w : \n    \t   (i == 1.0) ? v4.z :\n    \t   (i == 2.0) ? v4.y :\n    \t   (i == 3.0) ? v4.x : 0.0;\n}\n\n//Extracts bit 'i' from the 64-bit number in 'i64'.\nbool Bit(vec4 i64, float i)\n{\n    float n = floor(SelectComp(i64, i / BITS_PER_FLOAT));\n    \n    i = mod(floor(i), BITS_PER_FLOAT);\n    \n    return mod(floor(n / exp2(i)), 2.0) == 1.0;  \n}\n\n//Shifts bits left by 1 & inserts 'cin' into the LSB.\nvec4 ShiftLeft(vec4 i64, bool cin)\n{\n    vec4 shifted = vec4(0);\n    \n    shifted.x = i64.x*2.0 + float(Bit(i64, 3.0 * BITS_PER_FLOAT - 1.0));\n    shifted.y = i64.y*2.0 + float(Bit(i64, 2.0 * BITS_PER_FLOAT - 1.0));\n    shifted.z = i64.z*2.0 + float(Bit(i64, 1.0 * BITS_PER_FLOAT - 1.0));\n    shifted.w = i64.w*2.0 + float(cin);\n    \n    shifted = mod(shifted, exp2(BITS_PER_FLOAT));\n    \n    return shifted;\n}\n\n//Calculates the feedback bit by XORing multiple taps together.\nbool Feedback(vec4 i64)\n{\n    bool cin = false;\n    \n    //Taps\n    cin = cin ^^ Bit(i64, 6.0);\n    cin = cin ^^ Bit(i64, 13.0);\n    cin = cin ^^ Bit(i64, 31.0);\n    cin = cin ^^ Bit(i64, 52.0);\n    cin = cin ^^ Bit(i64, 63.0);\n    \n    return cin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 bits = (texture(iChannel0, uv));\n    \n    //Initial seed\n    //Re-initializes if all bits are zero to handle resolution changes.\n    if(iFrame < 10 || bits == vec4(0))\n    {\n        #ifdef TEXTURE_SEED\n        \tbits = texture(iChannel1, fragCoord / iChannelResolution[1].xy);\n        \tbits *= exp2(BITS_PER_FLOAT) - 1.0; \n        \tbits += floor(fragCoord.xyxy + 255.0);\n        #else\n        \tbits.xy += (fragCoord.xy + 255.0);\n        \tbits.z += (fragCoord.x + fragCoord.y);\n        \tbits.w += fragCoord.x * fragCoord.y;\n        #endif\n        \n        bits = mod(bits, exp2(BITS_PER_FLOAT));\n    }\n    \n    bool feedback = Feedback(bits);\n    \n    bits = ShiftLeft(bits, feedback);\n    \n    fragColor = bits;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Noise generator from: https://www.shadertoy.com/view/4lc3WX\n#define BITS_PER_FLOAT 16.0\n\n#define LSB 0      // 1-Bit Noise\n#define GREY 1     // 8-Bit Greyscale\n#define RGB 2\t   // Direct Passthough (normalized to 0-1)\n#define REGISTER 3 // Register Bits (choose register with REGISTER_UV)\n\n#define VIEW_MODE RGB\n\n#define REGISTER_UV 0,0\n\nfloat SelectComp(vec4 v4, float i)\n{\n\ti = floor(i);\n    return (i == 0.0) ? v4.w : \n    \t   (i == 1.0) ? v4.z :\n    \t   (i == 2.0) ? v4.y :\n    \t   (i == 3.0) ? v4.x : 0.0;\n}\n\nbool Bit(vec4 i64, float i)\n{\n    float n = floor(SelectComp(i64, i / BITS_PER_FLOAT));\n    \n    i = mod(floor(i), BITS_PER_FLOAT);\n    \n    return mod(floor(n / exp2(i)), 2.0) == 1.0;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = vec4(0);\n    \n    #if(VIEW_MODE == LSB)\n    \tcolor = vec4(mod(texture(iChannel0, uv).w, 2.0));\n    \n    #elif(VIEW_MODE == GREY)\n   \t\tcolor = vec4(mod(texture(iChannel0, uv).w, 256.0) / 255.0);\n    \n    #elif(VIEW_MODE == RGB) \n    \tcolor = texture(iChannel0, uv) / (exp2(BITS_PER_FLOAT)-1.0);\n    \n    #elif(VIEW_MODE == REGISTER)\n    \tvec4 bits = texture(iChannel0, vec2(REGISTER_UV)/iResolution.xy);\n    \n    \tcolor = vec4(Bit(bits, floor((1.0 - uv.x) * BITS_PER_FLOAT * 4.0)));\n    #endif\n    \n\tfragColor = color;\n}","name":"Buffer C","description":"","type":"buffer"}]}