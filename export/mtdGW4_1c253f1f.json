{"ver":"0.1","info":{"id":"mtdGW4","date":"1682466536","viewed":171,"name":"convoluted tunnel","username":"104","description":"i found this technique fun; maybe something to explore. extra credit if you can ELI5 how the coordinate warping works","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2dtunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(p.xyxy * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 O, in vec2 F)\n{\n    // coord setup\n    vec2 u = (F/iResolution.xy);\n    u.x *= iResolution.x/iResolution.y;\n    u.y+=.5;\n    u *= .5;\n    \n    vec2 c = floor(u); // square cell id (basically ~0,1 whole viewport)\n    vec2 p = u-c; // 2D position in cell\n    float l = length(p-.5); // length from center\n    u /= 2.*max(0.0001,l/7.4); // warp uv based on length accounting for Z\n    u += vec2(u.y,-u.x); // skew coords to correct prev op so we can manip z directly\n    vec2 id = floor(u); // now find a new cell based on new coords.\n    vec4 h = hash42(id.yy); // get random row value\n    u.x += ((mod(id.y,2.)+1.))*iTime*sign(h.z-.5)*3.+(3.*(h.y-.5));// slide rows randomly\n    u.x += iTime*13.; // move forward\n    id = floor(u); // recalc cell after sliding\n    h = hash42(id); // hash of this cell\n    vec2 idp = u-id; // position in the new cell\n    float d = .45-max(abs(idp.x-.5),abs(idp.y-.5)); // distance to edge\n    d = step(h.a* (sin(3.*iTime*h.r)*.5+.5)*.5, d); // stylize squares\n    \n    O = h * d * l * 2.;\n}\n\n","name":"Image","description":"","type":"image"}]}