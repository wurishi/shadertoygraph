{"ver":"0.1","info":{"id":"l3ByRD","date":"1727447025","viewed":33,"name":"Tunnel effect variation","username":"cesio","description":"Old school tunnel variation","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["tunnel","oldschool"],"hasliked":0,"parentid":"43fcWS","parentname":"Waves variation #3"},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// enable or disable stars layer on the tunnel\n#define ENABLE_STARS 1\n#define PI 3.14159265359\n#define SPEED 0.5\n#define SIZE 0.3\n// factor to increase brightness of stars\n#define SB 1.9\n\nvec2 cartesianToPolar(vec2 cartesian) {\n    float r = length(cartesian);          \n    float theta = atan(cartesian.y, cartesian.x); \n    return vec2(theta,r);  \n    \n}\n\n// taken from thebookofshaderx.com\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv += vec2(sin(iTime), cos (iTime * 2.0));\n    vec2 uvBuf = uv;\n\n    // by rotating we are making the tunnel to appear as if rotating\n    uv = rotate2d(iTime) * uv;\n    // by applying scale we are making the tunnel appearing as if being closer/farther\n    uv = scale(vec2(sin(iTime * 1.3) + 1.3)) * uv;\n \n    vec2 polarUV = cartesianToPolar(uv);\n    float correctedTime = iTime * SPEED;\n    polarUV.x = polarUV.x / PI;\n    polarUV.y =  SIZE  / polarUV.y + correctedTime;//* (sin(iTime));\n    \n    //polarUV = vec2( 0.3/cartesianToPolar(uv).y + 0.2*iTime, cartesianToPolar(uv).x/PI );    \n    \n    // naive implementation\n    //vec4 textureColor = texture(iChannel0, polarUV);\n    // 'better' implementation that considers discontinuity\n    vec2 uv2 = vec2(0.);//vec2(polarUV.x, atan(uv.y,abs(uv.x)) / PI);\n    vec4 textureColor = textureGrad(iChannel0, polarUV, dFdx(uv2),dFdy(uv2));\n                                          \n    // multiply by sqrt of radius to make \"farther\" parts of the tunnel (in the center of the window) darker\n    vec4 darknessFactor = vec4(sqrt(1. - (polarUV.y - correctedTime)));\n    fragColor = vec4(textureColor) * darknessFactor ;\n\n\n #if ENABLE_STARS == 1\n    vec2 polarUvStars = cartesianToPolar(uvBuf);\n    polarUvStars.x = polarUvStars.x / PI;\n    polarUvStars.y =  SIZE  / polarUvStars.y;// + correctedTime;//* (sin(iTime));\n    \n    // what we are doing here is to decrease resolution of output texture to make it fit for the entire tunnel\n    polarUvStars /= vec2(2.);\n    polarUvStars += vec2(0.5, 0.0);\n    \n\n    fragColor += texture(iChannel1, polarUvStars) * darknessFactor * SB ;\n    \n #endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A is just to generate flying stars\n\n// a number of seconds - loop\n#define N 12. \n// A coefficient for the spirala formula\n#define A -0.2\n// a ball rad0ius\n#define R 0.05\n// speed of a stars\n#define S 1.\n// a number of stars\n#define NB 50\n// a time slot between stars in seconds, nice pairs of S and TS are: (2., 0.25) or (1., 0.5)\n#define TS 0.5 \n#define PI 3.14159265359\n\nvec4 circle (vec2 st, vec2 pos, float radius,vec3 color){\n    float pct = distance(st,pos);\n    vec3 colorR = vec3(smoothstep(radius,radius * 0.9,pct)) * color;\n //   vec3 colorR = vec3(step(pct,radius)) * color;\n\treturn vec4(colorR, 1.0);\n}\n\n// taken from thebookofshaderx.com\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4 drawEllipse(vec2 st, vec2 center, vec2 radii,vec3 color) {\n    vec2 pos = st - center;\n    vec3 retCol = color;\n    float ellipse = (pos.x * pos.x) / (radii.x * radii.x) +\n                    (pos.y * pos.y) / (radii.y * radii.y);\n\n    return vec4(vec3(step(ellipse, 1.0) * color), 1.);\n  //  return vec4(vec3(smoothstep(ellipse, ellipse * 0.9,pos.x))* color, 1.);\n//return vec4(vec3(smoothstep(vec2(ellipse), vec2(ellipse * 0.9),pos) * color), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Remap the space to -1. to 1.\n    uv = uv * 2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // ### PLAY WITH SPACE START ### move space from the center to the vec2(0.0)\n    //uv -= vec2(0.5);\n    // rotate the space\n    uv = rotate2d( sin(iTime)*PI ) * uv;\n            \n    float ballsOffset = (2.) / float (NB + 1);\n    //vec3 color2 = vec3(0.0, 0.0, 0.0);\n    vec3 color1 = vec3(0.2, 0.2, 1.);\n    \n\n    vec4 col = vec4(0.);\n    \n    for (int i = 0; i < NB; i++) {\n        float offsetTime = iTime - TS * float(i);\n        \n      \n        // check whether it is time to start Nth ball\n        if (offsetTime >= 0.) {\n            // we want to limit time to cycle of N seconds\n            float localTime = mod(offsetTime,float(N));\n            // we want to increase the speed as time passes by\n            float speed = S;//+ pow(1.4, localTime);\n            \n            // we calculate x,y coordinates of the ball using well known formulas\n            float x = -A * localTime * cos(localTime*S);\n            float y = -A * localTime * sin(localTime*S);\n\n            //col += circle(uv, vec2(x,y),R*localTime,vec3(localTime/N) * color1);\n            float ce = localTime/N;\n            float rX = R * localTime;// * (sin(iTime * S * 2.) /2. + 1.);\n            float rY = (R - rX)  / 4.;\n            \n\n\n            col += drawEllipse(uv, vec2(x,y),vec2(rX, rY),vec3(ce) * color1);\n            col = max(col,drawEllipse(uv, vec2(x,y),vec2(rY, rX),vec3(ce) * color1));\n\n           //col += circle(uv, vec2(x,y),R*localTime,vec3(1.));\n        }\n    }\n    \n    // ### PLAY WITH SPACE END ### move the space back to the original place\n    // rotate the space back\n    uv = rotate2d( sin(iTime)*PI ) * uv;\n    //uv += vec2(0.5);\n            \n    // Time varying pixel color\n   // vec3 colBg = 0.3 - 0.2*cos(uv.xxy);\n\n\n    //fragColor = vec4(colBg, 1.);\n    fragColor = col;\n }\n    ","name":"Buffer A","description":"","type":"buffer"}]}