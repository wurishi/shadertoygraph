{"ver":"0.1","info":{"id":"ssBXWW","date":"1620253783","viewed":578,"name":"Voronoi Cell 3D","username":"iapafoto","description":"Extraction of voronoi 3D Cells","likes":37,"published":1,"flags":32,"usePreview":1,"tags":["voronoi","cell","sd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by sebastien durand - 05/2021\n//-------------------------------------------------------------------------------------\n// All shading is copy pase of shane wonderful shaders\n// Background from https://www.shadertoy.com/view/llG3zy by tomkh\n//-------------------------------------------------------------------------------------\n\n\n   \n// go from 30 to .2 fps without this on my gpu    \n#define FULL_PROCEDURAL \n#define ANIMATE_D .3\n#define FAR 24.\n\nfloat gDist;\nvec3 closest;\n\n#ifdef FULL_PROCEDURAL\n// [iq] https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash33(vec3 p ) {\n    uvec3 x = uvec3(p.x+10.,p.y+10.,p.z+10.);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    vec3 o= vec3(x)*(1.0/float(0xffffffffU));\n    return ANIMATE_D*cos(.2*(3.+o)*iTime + o*6.2831853);\n}\n\n#else \n\nvec3 hash33( vec3 x ) {\n\tvec3 o = texture(iChannel1, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0).xyz;\n    return ANIMATE_D*cos(.2*(3.+o)*iTime + o*6.2831853);\n}\n\n#endif\n\n//---------------------------------------------------------------\n// Here is the distance to voronoi3D cell (not exact: over estimate distance on edges)\n//---------------------------------------------------------------\nfloat sdVoronoi( in vec3 x, in vec3 cellId) {\n    float md = 64.0;    \n    vec3 mr = hash33(cellId);\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ) {\n        if (i==0&&j==0&&k==0) continue;  // skip main cell \n        vec3 g = vec3(i,j,k),            // relative cell Id\n             r = g + hash33(cellId + g); // pos of other point\n        md = min(md, dot(.5*(mr+r)-x, normalize(r-mr))); // distance\n    }\n    return -1.2*md;\n}\n\nvec4 min4(vec4 a, vec4 b) { return a.x<b.x ? a :b; }\n\nfloat map(vec3 p) {\n    vec4 d = vec4(999.);\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ) {\n        vec3 g = vec3(i, j, k);\n        float db = length(gDist*g - p)-1.5;\n        d = db>.2 ? min4(d, vec4(db,g)) : min4(d, vec4(sdVoronoi(p - gDist*g,g),g));\n    }\n    closest = d.yzw;\n    return d.x;\n}\n\nvec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { \n    float eps = 3.*3./mix(450., min(850., iResolution.y), .35);\n    float d = map(p);\n    vec3 e = vec3(eps, 0, 0),\n         da = vec3(-2.*d);\n    for(int i = min(iFrame,0); i<3; i++) {\n        for( int j=min(iFrame,0); j<2; j++ )\n            da[i] += map(p + e*float(1-2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\nfloat trace(in vec3 ro, in vec3 rd){\n    float t = 0., tmin=0., tmax=FAR, d;\n    // Do it only on bounding cube\n    if (cube(ro, rd, vec3(.75+2.5*gDist), tmin, tmax)) {\n        t = tmin;\n        tmax = min(tmax, FAR);\n        for(int i = 0; i<64; i++){\n            d = map(ro + rd*t);\n            if(abs(d)<.001*(1. + t*.05) || t > tmax) break;\n            t += d; // the distance field is over estimated\n        }\n        if(t>tmax) t = FAR;\n    }\n    else {\n        t=FAR;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n) {\n\tfloat sca = 4., occ = 0.0;\n    for( int i=1; i<6; i++ ) {\n        float hr = float(i)*.3/5.,       \n              dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n// The iterations should be higher for proper accuracy.\nfloat softShadow(in vec3 ro, in vec3 rd, float t, in float end, in float k){\n    float shade = 1.0;\n    end = end *.2;\n    const int maxIterationsShad = 16;\n    float dist = .001*(1. + t*.05) + .001*abs(hash2(ro.xz).x);\n    float tmin, tmax;\n    if (cube(ro, rd, vec3(.75+2.5*gDist), tmin, tmax)) {\n        end =min(end, tmax);\n    }\n    for (int i = 0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);    \n        dist += clamp(h, .01, .25);        \n        if (h<.001 || dist > end) break; \n    }\n    return min(max(shade, 0.) + .1, 1.); \n}\n\nvec3 envMap(vec3 p){\n    p *= 3.;\n    float n3D2 = noise3D(p*3.);\n    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;\n    c = smoothstep(.25, 1., c); \n    p = vec3(c, c*c, c*c*c);\n    return mix(p, p.zyx, n3D2*.5 + .5);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro),\n         cp = vec3(sin(cr), cos(cr),.0),\n         cu = normalize( cross(cw,cp) ),\n         cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = 3.*iTime;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    gDist= 1. + 1.5*smoothstep(.6,0.,cos(.3*iTime));//2.*iMouse.x/iResolution.x;\n    int id=0; \n\n    \n    float a = mix(.3,3.*cos(.4*time),.5+.5*cos(.2*iTime))+3.14*m.x;\n    \n    // camera\t\n    vec3 ta = vec3(0., -.25, -0.),\n         ro = ta + 2.7*vec3(4.5*cos(a), 3.*cos(.4*iTime) + 4.*m.y, 4.5*sin(a));\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, .1*cos(.123*iTime) );\n\n    vec3 tot = vec3(0.0);\n \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // focal length\n    const float fl = 2.5;\n        \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,fl) );\n    vec3 lp = ro + 3.*vec3(.25, 2, -.1);\n        \n    // Ray march.\n    float t = trace(ro, rd);\n\n    // Background\n    vec2 q = fragCoord/iResolution.xy;\n    vec3 sceneCol = texture(iChannel0, q).xyz; \n\n    if(t < FAR){\n        bool isClosest =  length(closest)<.5;\n        vec3 col = isClosest ? 5.*vec3(.75, 1.5, 1.5) : vec3(.9, .2, .4); // Pink.\n        // Position.\n        vec3 pos = ro + rd*t;\n        float edge = 0., crv = 1.;\n        vec3 nor = calcNormal(pos, edge, crv, t);\n        \n        // Light direction vector.\n        vec3 li = lp - pos;\n        float lDist = max(length(li), .001);\n        li /= lDist;\n        \n        // Light falloff - attenuation.\n        float atten = 1./(1. + lDist*.05 + lDist*lDist*0.025);\n        \n        // Soft shadow and occlusion.\n        float shd = softShadow(pos + nor*.0015, li, t, lDist, 8.); // Shadows.\n        float ao = .3+.7*calcAO(pos, nor);\n        float diff = max(dot(li, nor), .0); // Diffuse.\n        float spec = pow(max(dot(reflect(-li, nor), -rd), 0.), 16.); // Specular.\n        // Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        float od = diff;\n        diff = pow(diff, 4.)*2.; \n        \n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + li)), 0.), 5.0);\n\t\tfloat fre2 = mix(.5, 1., Schlick);\n          \n        float txSz = 1.;\n        vec3 txPos = pos; \n        col *= fbm(txPos*64.*txSz)*.75 + .5;\n        sceneCol = col*(diff + .25); \n        \n        // Fake environment mapping.\n        sceneCol += sceneCol*envMap(reflect(rd, nor))*8.;\n        \n        // Edges.\n        sceneCol *= 1. - edge*.8;\n        sceneCol *= atten* shd*ao; // Applying the light falloff, shadows and AO.\n        if (!isClosest) {\n            sceneCol += .01*dot(nor, -normalize(pos))*vec3(.75, 1.5, 1.5);\n        }\n        sceneCol = mix(sceneCol, COLOR_BACK, .8*smoothstep(.5,.9,t/FAR));\n    }\n    \n    fragColor = vec4(pow(clamp(sceneCol, 0., 1.),vec3(.42)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define COLOR_BACK  vec3(.6, .7, 1)*.045\n\nbool cube(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf){\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn<tf;\n}\n\n\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    float n = mix(h.x, h.y, p.z);\n    return n;\n}\n\nfloat fbm(in vec3 p){\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n}\n\n//-------------------------------------------------\n// https://www.shadertoy.com/view/llG3zy by  tomkh\n\n// How far cells can go off center during animation (must be <= .5)\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\n\n// 2D rotation formula.\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\nvec2 hash2(vec2 p) {\n   // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n//---------------------------------------------------------------\n// Fastest version with 3x3 scan in the second pass\n//---------------------------------------------------------------\n\nvec3 voronoi(in vec2 x) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ) {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( md, mr );\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Background\n    vec2 p = fragCoord/iResolution.y;\n    p=p*(7.+.4*cos(.1*iTime))+vec2(5)*rot2(.04*iTime);\n    vec2 q = fragCoord/iResolution.xy;\n    vec3 sceneCol = COLOR_BACK \n    \t\t + .05*hash(vec3(q,1.));\n                    //     sceneCol = vec3(.6, .7, 1)*.045; // Blue.\n    vec3 voro = voronoi(p);\n    sceneCol *= .85 + .15*smoothstep(.08,.06,voro.x);\n    fragColor = vec4(sceneCol* pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.7f), 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}