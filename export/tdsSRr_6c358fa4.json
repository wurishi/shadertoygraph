{"ver":"0.1","info":{"id":"tdsSRr","date":"1550520690","viewed":225,"name":"faster glitchy julia fog","username":"pde","description":"dynamic jumpsizes... allow a nice frame rate, but give us some (perhaps cool) glitchy artefacts\n\nclick and drag to rotate the camera","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymachedjuliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 cmult(vec2 a, vec2 b)\n{\n    return mat2(a,-a.y,a.x) * b;\n}\n\nvec2 spacify(vec2 p)\n{\n    return ( p - .5 * iResolution.xy ) / iResolution.y;\n}\n\nconst int counts = 160;\nconst float fcount = float(counts);\n\nint julia(in vec2 z0, in vec2 c)\n{\n    vec2 z = z0;\n    if (length(z) > 4.0)\n        return 0;\n    for (int n=0; n <counts; n++) {\n        z = cmult(z,z) +c;\n        if (length(z) > 4.0)\n            return n;\n    }\n    return -1;\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // start at 0,0,z=3, shoot a ray at the plane z=1\n    vec3 camera = vec3(0,0,4.0);\n    vec2 xy = spacify(fragCoord);\n    vec3 coord = vec3(xy.x, xy.y, 3.0);\n    vec3 ray = coord - camera;\n    float radius =  length(xy);\n    \n    vec2 mouse_xy=spacify(iMouse.xy);\n    mat3 rot = rotationMatrix(vec3(mouse_xy.y, mouse_xy.x, 0.0), 2.5 * length(mouse_xy));\n    \n    camera = camera*rot;\n    ray = ray*rot;\n    \n    float col = 0.0;      // integral of collisions with halo fog\n    float core = 0.0;     // integral of collisions with core fog\n    float steps = 50.0;\n    float z2 = sin(iTime/7.0);\n    float corr =cos(iTime/3.1415), jumpphase = pow(sin(iTime/4.0),3.0);\n    vec3 pos=camera; int inc=0; float jumpsize,j1,j2,j0; int n=0;\n    for (float dist=0.0; dist < 5.0; ) {\n        // there are lots of weird artefacts that result from jumpsize selection choices!\n        // j0 is a heuristic choice to step slowly near the julia boundary\n        // watch out for j0 == 0...\n        j0 = (fcount + 1.0 - float(inc)) / (fcount + 1.0);\n        // playing with two variants of it gives a cool banded visual effect\n        j1 = 0.02 + 0.5 * radius * j0;\n        j2 = 0.005 + 0.1 * j0;\n        jumpsize = jumpphase * j1 + (1.0 - jumpphase) * j2;\n\n        pos += jumpsize*ray;\n        dist +=jumpsize;\n        inc = julia(vec2(pos.x+corr, pos.y), vec2(pos.z,z2));\n        \n        if (inc < 0)\n            // collisions with the core of the julia set\n            core += 1.0;\n        else {\n            // collisions with the halo\n            col += float(inc) * jumpsize * 20.0;\n\n        }\n        if (n > 2000) break;\n\n    }\n    // Each of the rgb channels grows increases with halo fog collisions & decreases\n    // with core fog collisions, but with different weights on those two effects\n    float scale = 10.24 * steps, b=2.0*scale;\n    float pen = core / 10.0;\n    fragColor = vec4(col/scale - pen, col/scale-(pen/5.0), col/b - (pen/3.0), 0.0);\n}","name":"Image","description":"","type":"image"}]}