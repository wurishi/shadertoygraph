{"ver":"0.1","info":{"id":"Nt23Dw","date":"1624053337","viewed":121,"name":"[phreax] enter the void","username":"phreax","description":"experimenting with postprocessing","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// color shift from https://www.shadertoy.com/view/XdlBRM\n\nvec2 rotate(vec2 uv, float theta)\n{\n\tvec2 p = uv - 0.5;\n    \n    p = p * mat2(cos(theta), -sin(theta),\n                 sin(theta), cos(theta));\n    p *= 1.0 ;\n    p += 0.5;\n    return p;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float theta = 0.05 * sin(iTime);\n    vec3 col ;\n    col.r = texture(iChannel0,  rotate(uv, -theta)).r;\n    col.g = texture(iChannel0, uv).g;\n    col.b = texture(iChannel0, rotate(uv, theta)).b;\n    \n    fragColor = vec4( col, 1.0);\n    \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n#define PI 3.141592\n#define SIN(x) (sin(x)*.5+.5)\n\nvec3 ro;\nfloat tt;\nfloat cid = 0.0;\nfloat id = 0.0;\n\nvec2 e = vec2(0.0005, -0.0005);\n\n\nfloat cyl(vec2 p, float r) {\n\treturn length(p) -r;\n}\n\nfloat curve(float t, float d) {\n    t /= d;\n    return mix(floor(t), floor(t)+1., pow(smoothstep(0., 1., fract(t)), 10.));\n}\n\n\nfloat box(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return length(max(d, .0)) + min (max(d.x, max(d.y, d.z)), .0);\n}\n\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// from https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nfloat map(vec3 p) {\n\n\n    vec3 bp = p;\n    \n    \n    p.y += 0.3*sin(0.3*p.z);\n    p.z += 3.*tt;\n    cid = pMod1(p.z, 8.);\n\n    float id = mod(cid, 2.)*2.-1.;\n    p.xy *= rot(tt*.2+curve(tt, 4.)*id);\n    \n    pModPolar(p.xy, 6.);\n    for(int i=0; i<6; i++) {\n        p = abs(p) - 0.1 -SIN(.25*tt);\n        p.xz -= 0.1*float(sin(float(i)*.2*tt));\n        p.xy *= rot(tt*.3);\n        p.xz *= rot(tt*.1);\n        p.yz *= rot(tt*.2);\n    }\n    \n    p.xz *= rot(tt);\n    float d = box(p, vec3(.2, .8, .3));\n    \n    d = max(.7*d, -cyl(bp.xy, .9));\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n    \n    tt = iTime;\n    \n    tt = mod(tt, 120.);\n    ro = vec3(0.+.8*sin(tt), 0., -1.5);\n    \n    vec3 rd = normalize(vec3(-uv, .5)),\n         lp = vec3(0, -.3, -3);\n      \n    vec3 col;\n    \n    vec3 p = ro;\n    \n    float d, t = 0.1;\n    float i;\n    float acc, acc2 = 0.0;\n    for(i=0.0; i < 128.; i++) {\n        d = map(p);\n        id = cid; // save id\n        if(d< 0.0001 || t > 40.) break;\n\n        t += d;\n        p += d*rd;\n    }\n    \n    vec3 al = vec3(0.000,0.878,0.776);\n        \n    vec3 al2 = vec3(1.000,0.533,0.000);\n    vec3 bg = vec3(0.847,0.933,0.925);\n    \n    bg *= (1.-.3*length(uv)+.15); // vignette\n    \n    \n    if(d < 0.0001) {\n    \n        vec3 n = normalize(e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                           e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n                  \n                           \n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), 0.);\n        float spec = pow(max(dot(reflect(-rd, n), -l), .0), 44.);\n        float sss = smoothstep(0., 1., map(p+l*.4));\n        float fog = 1.-exp(-.0001*t*t*t);\n        \n        vec3 c = mix(al, al2, mod(id, 2.));\n        col += (dif+sss)*c + spec;\n        col = mix(col, bg, fog);\n\n    } else {\n        col  = bg;\n    }\n\n    col = pow(col*.9, vec3(1.5)); // color contrast\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}