{"ver":"0.1","info":{"id":"4sdczj","date":"1519570210","viewed":116,"name":"Raymarching test - tmiya","username":"tmiya","description":"Raymarching test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#extension GL_OES_standard_derivatives : enable\n\n#if GL_ES\nprecision mediump float;\n#endif\n\n#define EPSILON 0.0001\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define USE_SHADER_TOY 1\n\n#if USE_SHADER_TOY\n#define u_resolution iResolution.xy\n#define u_mouse iMouse.xy\n#define u_time iTime\n#else\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n#endif\n\nvec3 lightDir = normalize(vec3(0.5, 1.0, 1.0));\nvec3 lightColor = vec3(1.0, 0.8, 0.65);\n\nstruct Material\n{\n    vec3 albedo;\n};\n\nstruct RayResult\n{\n    float dist;\n    Material mat;\n};\n\n//-------------------------------------------------------------------------------------\n//  https://iquilezles.org/articles/distfunctions\n//-------------------------------------------------------------------------------------\n\nRayResult sdSphere( vec3 p, float s, Material mat)\n{\n    RayResult result;\n    {\n        result.dist = length(p) - s;\n        result.mat = mat;\n    }\n    return result;\n}\n\nRayResult sdBox( vec3 p, vec3 b, Material mat )\n{\n    RayResult result;\n    {\n        vec3 d = abs(p) - b;\n        result.dist = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n        result.mat = mat;\n    }\n    return result;\n}\n\nRayResult sdTorus( vec3 p, vec2 t, Material mat )\n{\n    RayResult result;\n    {\n        vec2 q = vec2(length(p.xz)-t.x,p.y);\n        result.dist = length(q)-t.y;\n        result.mat = mat;\n    }\n    return result;\n}\n\nRayResult sdPlane( vec3 p, vec4 n, Material mat )\n{\n    RayResult result;\n    {\n        // n must be normalized\n        result.dist = dot(p,n.xyz) + n.w;\n        result.mat = mat;\n    }\n    return result;\n}\n\nRayResult sdTwistTorus(vec3 p, vec2 t, Material mat)\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, t, mat);\n}\n\nRayResult opU( RayResult r1, RayResult r2 )\n{\n    if (r1.dist < r2.dist) {\n        return r1;\n    } else {\n        return r2;\n    }\n}\n\n//-------------------------------------------------------------------------------------\n\n//-------------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/checkerfiltering\n// https://iquilezles.org/articles/distfunctions\nfloat Checkers(in vec2 p)\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nRayResult Raymarch(vec3 pos)\n{\n    RayResult result;\n    result.dist = 1.0;\n    result.mat.albedo = vec3(0.0, 0.0, 0.0);\n\n    // scene define\n    result = opU(result, sdPlane(pos, vec4(0.0, 1.0, 0.0, 0.1), Material(vec3(0.5))));\n    result = opU(result, sdSphere(pos - vec3(0.0, 0, 0), 0.1, Material(vec3(1.0, 0.0, 0.0))));\n    result = opU(result, sdTwistTorus(pos - vec3(-0.3, 0.05, 0), vec2(0.1, 0.05), Material(vec3(0.0, 1.0, 0.0))));\n    result = opU(result, sdBox(pos - vec3(0.3, 0, 0), vec3(.1, .1, .1), Material(vec3(0.0, 0.0, 1.0))));\n\n    return result;\n}\n\nvec3 GetNormal(vec3 pos)\n{\n    return normalize(vec3(\n        Raymarch(pos).dist - Raymarch(vec3(pos.x - EPSILON, pos.y, pos.z)).dist,\n        Raymarch(pos).dist - Raymarch(vec3(pos.x, pos.y - EPSILON, pos.z)).dist,\n        Raymarch(pos).dist - Raymarch(vec3(pos.x, pos.y, pos.z - EPSILON)).dist\n    ));\n}\n\nfloat CalcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for (int i=0 ; i<16 ; i++) {\n\t\tfloat h = Raymarch(ro + rd*t).dist;\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if (h<0.001 || t>tmax) { break; }\n    }\n    return saturate(res);\n}\n\n//-------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);\n\n    // light\n    vec3 L = normalize(lightDir + vec3(sin(u_time), 0.0, cos(u_time)));\n\n    // camera\n    vec3 cam_pos = vec3(-5, 2, 10);\n    vec3 cam_target = vec3(0, 0, 0);\n\n    vec3 front = cam_target - cam_pos;\n    float target_len = length(front);\n    front = normalize(front);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), front);\n    vec3 up = cross(front, right);\n\n    // ray\n    vec3 screen_pos = right * uv.x + up * uv.y + front * target_len;\n    vec3 ray = normalize(screen_pos - cam_pos);\n\n    // color\n    vec3 bg_color = vec3(0.7, 0.9, 1.0);\n    vec3 amb_color = vec3(0.3);    \n    vec3 color = bg_color;\n\n    // ray march\n    const int STEP = 256;\n    vec3 cur_pos = cam_pos;\n    for (int i=0 ; i<STEP ; i++) {\n        RayResult r = Raymarch(cur_pos);\n        if (r.dist < EPSILON)\n        {\n            // lighting\n            {\n                vec3 normal = GetNormal(cur_pos);\n                \n                // diffuse\n                vec3 diff = r.mat.albedo * vec3(saturate(dot(normal, L))) * lightColor;\n                // shadow\n                diff *= CalcSoftshadow( cur_pos, L, 0.02, 2.5 );\n                // ambient\n                vec3 amb  = r.mat.albedo * amb_color;\n                // final color\n                color = saturate(diff + amb);\n            }\n            break;\n        }\n        cur_pos += ray * r.dist;\n    }\n\n    // gamma\n    color.rgb = pow(color.rgb, vec3(1.0/2.2));\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}