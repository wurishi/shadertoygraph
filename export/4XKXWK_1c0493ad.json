{"ver":"0.1","info":{"id":"4XKXWK","date":"1720506208","viewed":37,"name":"ARTS1308 HW5 Shub-Niggurath","username":"lyhokia","description":"Shub-Niggurath","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXITER 20\n\nvec2 mul(vec2 p, vec2 q) {\n    return vec2(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);\n}\n\nvec2 pow_c(vec2 z, int time) {\n    vec2 ret = vec2(1.0);\n    for(int i = 0; i < time; ++i) {\n        ret = mul(ret, z);\n    }\n    return ret;\n}\n\nvec2 div(vec2 p, vec2 q) {\n    vec2 r = vec2(q.x, -q.y);\n    return mul(p, r) / (q.x * q.x - q.y * q.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = 2.0 * fragCoord / iResolution.xy - vec2(1.0);\n    float c = 17.2 + 5.0 * sin(iTime * .8);\n    \n    int iter = 0;\n    \n    while(length(z) < 10. && iter < MAXITER) {\n        vec2 p = 1.5 * pow_c(z, 6) + 7.3 * z;\n        vec2 q = 1.6 * pow_c(z, 2) + c * pow_c(z, 3);\n        z = div(p, q);\n        // As long as the iteration function is rational, we will get a Julia Set.\n        iter += 1;\n    }\n    \n    float color = float(iter) / float(MAXITER);\n    color = (float(iter) + 1. - log(log(length(z)))/log(2.))/(float(MAXITER) + 1. - log(log(length(z)))/log(2.));\n    color = pow(color, .9);\n    fragColor = vec4(vec3(color), 1.);\n    \n}","name":"Image","description":"","type":"image"}]}