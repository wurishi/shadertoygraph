{"ver":"0.1","info":{"id":"XcccWf","date":"1731245289","viewed":316,"name":"Snake in mesh - study","username":"FabriceNeyret2","description":"left-right to control direction \nWIP\n(un)comment buffA#34 for direction strategy: with = no direction memory (last segment=new dir). without = keep target dir","likes":14,"published":3,"flags":48,"usePreview":0,"tags":["procedural","voronoi","random","distance","delaunay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// mesh from https://shadertoy.com/view/MfccD2\n\nfloat line(vec2 a,vec2 b) { \n   b -= a;\n   return length( a + b * clamp( -dot(a, b) / dot(b, b), 0., 1.)); \n}\n\n#define P(x,y)    ( D = vec2(x+k%2,y+k/2) - 1. , .5 + D - fract(p) + T( p + D ).xy )\n                                                // = floor(p)+offs -p +.5 + rand\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  h0,h1,h2,h3, D,\n          p = scale* u / R.y; // + iTime; \n    float d = 9.;\n                                                // --- draw mesh\n/**\n    vec2 P0 = .5-fract(p) + T(p).xy, P1;        // misses intermediate tiles\n    for( int k; k < 9; k+= k==3?2:1 )\n       if ( ( int(T(p).z) & ( 1<< k ) ) > 0 ) \n           D = floor(p) + vec2(k%3,k/3)-1.,\n           P1 = D-p+.5 + T(D).xy,\n           d = min(d, line(P0,P1) );\n/**/ \n    for( int k; k < 4; k++ )\n        h0 = P(0,0), \n        h1 = P(1,0),\n        h2 = P(0,1),         \n        h3 = P(1,1),     \n        d = min( min( line(h0,h1),\n                      line(h0,h2) ),\n              // min( (int(T(p).z)& 1 << ( k%2*2 + k/2*2*3) ) > 0 // why wrong ?\n                 min( length(h0-h3) < length(h1-h2) \n                         ? line(h0,h3) : line(h1,h2), \n                      d ));\n/**/\n    O = max( 1. - d * R.yyyy/scale, 0. );       // draw segment\n    \n   // if ( T(p).w < 0. ) O.g += max(8.- length(.5+T(p).xy-fract(p))*R.y/scale, 0.); // --- draw bounty\n    d = 9.;\n    for( int k; k < 9; k ++ ) {\n        vec2 P = floor(p)+vec2(k%3,k/3) - 1.;\n        if ( T(P).w < 0. ) d = min( d, length(.5+P-p+T(P).xy)); // --- draw bounty\n     }\n     O.g += max(8.- d*R.y/scale, 0.); \n\n                                                // --- draw snake tail\n/** if ( length( T(201).xy - T(SNK).xy ) < 2. )\n        d = line( .5-p + T(SNK).xy + T(T(SNK).xy).xy,  .5-p + T(201).xy  + T(T(201).xy).xy ), // draw snake\n        O.r += max(0., .3-d)*R.y/scale;\n    if ( T(p).w > 0. ) O.r += max(0., .3-length(.5-fract(p) + T(p).xy))*R.y/scale;   // why an extra head ?\n**/ d = 9.;\n    if ( T(p).w > 0. )  \n        for( int k; k < 9; k += k==3?2:1 ) {\n            if ( ( int(T(p).z)&(1<<k) ) < 1 ) continue;  // loop on connections from cell node\n            vec2 P1 = floor(p) + vec2(k%3,k/3) - 1.;\n            if( T(P1).w > 0. ) d = min(d, line( .5-fract(p) + T(p).xy,  .5+P1-p  + T(P1).xy ));\n        }\n    vec2 P1= floor(p) + vec2(1,0), P2, K=vec2(0,1); // test for connections between 4-neighbors\n    for( int k; k++ < 4; K = vec2(-K.y,K) ) {\n         P2 = floor(p) + K;\n         if ( T(P1).w > 0. &&  T(P2).w > 0. && abs(T(P2)-T(P1)).w == 1. ) \n             d = min(d, line( .5+P1-p  + T(P1).xy,  .5+P2-p  + T(P2).xy ));\n         P1 = P2;\n         }\n    O.r +=  max(0., .3 -d)*R.y/scale;\n    \n    O = sqrt(O);\n // O = T(p*2.);                             // debug\n // p = floor(p); O.b += mod(p.x+p.y,2.);    // debug: show tiling\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float   scale = 20.;\nfloat slow = 1./12.;                                  // 1 / speed\nint SNK = 200,                                        // Snake state\n     EV = 202;                                        // events state\n\n#define R       iResolution.xy\n#define T(u)    texelFetch(iChannel0, ivec2(u), 0)\n#define H(v)    fract(1e4*sin( floor(v) * mat2(47, -73, 91, -37)))\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define key(a)        ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)  // LEFT:37  UP:38  RIGHT:39  DOWN:40 \n#define P(u)          sin( 6.3* H(u) ) / 4.                     // random point in cell\n#define S             floor(scale*R/R.y)                        // arena size\n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    u -= .5;\n    O = T(u);\n    float c;                                                    // --- key events management\n    if ( u == vec2(EV) ) c = key(37) ? 1. : key(39) ? 0. : -1., // push events key events during pause\n                         O.z > slow && O.y > 0. ? O.y-- : c,    // once accounted, eat event\n                         c >= 0. ? O.y++, O.x = float(int(c + 2.*O.x) & 0xfff) :c, // 0.x bits = FIFO, 0.y = next slot\n                         O.z += iTimeDelta;                     // to control the pause time\n                         \n    if ( iFrame > 0 && T(EV).z <= slow ) return;                // slow pace\n  //if (T(EV).z <= slow *( T(EV).w!=T(SNK).z  && T(T(SNK).xy).x < 0. ?4. :1. ) ) return;// slow pace (more in turns and eats)\n  //if ( iFrame%10 > 0 ) return;                                // slow down\n    \n    if ( u == vec2(SNK) )                                       // --- snake head control\n        if ( iFrame < 1 ) O = vec4(5,5,.785,10);                // pos, direction angle, tail length\n        else {\n            vec2 d = cos( .785*O.z + vec2(0,11) ), D,           // direction vector\n                 U = O.xy,                                      // cell Id\n                 P0 =  T( U ).xy;                               // random point in cell\n            float m, l; int km;\n            for( int k; k < 9; k += k==3?2:1 ) {\n            if ( ( int(T(U).z)&(1<<k) ) < 1 ) continue;         // loop on connections\n                D = vec2(k%3,k/3) - 1.;\n                l = dot( normalize( D + T(U+D).xy - P0 ), d );\n                if ( l > m ) m = l, km = k;                     // chose connection best align with dir\n            }\n            O.xy += vec2(km%3,km/3) - 1.;                       // step the connection\n            O.xy = mod(O.xy, S );                               // domain wrapping\n            D = vec2(km%3,km/3) - 1.; D += T(U+D).xy - P0; O.z = atan(D.y,D.x)/.785; // variant: segment= new dir\n            \n            c = T(EV).y; if (c > 0.) c = ((int(T(EV))>>int(c-1.))&1) > 0 ? 1. : -1.; // c = pop bufferized action\n            O.z += c; // keyDown(37) - keyDown(39);                   // direction\n            \n            if (T(U).w < 0. ) O.w++;                            // eat bounty: tail +1\n        //  if ( T(U).x > 0. ) O.w = -120.;                     // cross itself: loose !\n        }\n  //if ( u == vec2(201) )  O = T(SNK);                          // prev location  \n    if ( u == vec2(EV) )   O.z = 0.;\n\n    if ( u.y < 200. )                                           // --- terrain\n        if ( iFrame < 1 ) {                      \n            vec2 P0 = O.xy = P(u), s = vec2(0,1), D;            // random point in cell\n            int km = 2+8+32+128;                                // get valid connections. 4 grid dirs ok\n            for( int k; k < 4; k++ ) {                          // test for the diag directions\n               D = vec2(k%2*2,k/2*2)-1.;\n               if ( length( D + P(u+D) - P0 ) < length( D*s + P(u+D*s) - D*s.yx - P(u+D*s.yx)) ) // ok if diag shorter than antidiag\n                   km += 1 << k%2*2 + k/2*2*3; \n             }\n            O.z = float(km);                                    // connections flag\n            if (u == floor( S * H(vec2(iTime+7.)) ) ) O.w = -1.;// bounty\n        } else {                                                // --- runtime:\n            if ( T(T(SNK).xy).w < 0. && u == floor( S * H(vec2(iTime+7.)) ) ) O.w = -1.;// bounty\n            if( length(u - T(SNK).xy) < .1 ) O.w = T(SNK).w;    // set cell under snake head\n            if (O.w > 0.) O.w--;                                // fade snake tail\n        }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}