{"ver":"0.1","info":{"id":"dtsSDB","date":"1675424475","viewed":477,"name":"Radiosity + Analytic Occlusion","username":"Mathis","description":"Improving the analytic 2D occlusion code to be more performant.\nUsing analytic occlusion together with radiosity.\n\nRotate the sun direction with your mouse.","likes":48,"published":1,"flags":32,"usePreview":0,"tags":["2d","global","illumination","radiosity","integrated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nNOTES:\n    Since a matrix equation is not solved anymore, texels only have to be stored once!\n    The light \"function\" on texels is constant, becomes linear when integrated -> smooth lighting\n\nImprovement ideas:\n    Radiosity texel LOD\n        Texels further away has smaller difference in the form factor\n        So they are combined like mipmaps\n        Sampling mipmaps is based on cone tracing\n            The cone radius projected on the line decides which mipmaps to sample\n            This automatically ensures that small texels are sampled when the geometry is close to the pixel\n            Larger coneratios trades lower accuracy for higher performance\n    Integrate incoming light over the whole texel\n        Maybe using monte carlo or temporal -> reduces flicker at shallow angles or for harder shadows\n    Use hat functions instead\n        Texel points would have to be stretched to the boundaries\n        This would definitely give smoother results\n*/\n\nvec3 Integral(vec2 P, float Time) {\n    //Computes the light integral\n    float TotalGeometryAngle = 0.;\n    vec3 I = vec3(0.);\n    int NVParts; float A1,A2,p0,p1,Len;\n    vec2 CX,CY,Tan,UNor,Nor,TanF; vec4 clinep,linep;\n    vec2 VParts[int(NObjects)+1];\n    //Sky and emissive integration\n    for (float i=0.; i<NObjects; i++) {\n        //For each line\n        NVParts = 1;\n        clinep = texture(iChannel0,vec2(0.5+i,0.5)*IRES);\n        //Create coordinate system\n        Len = length(clinep.zw-clinep.xy);\n        TanF = clinep.zw-clinep.xy;\n        Tan = TanF/Len;\n        UNor = vec2(-Tan.y,Tan.x);\n        Nor = vec2(Tan.y,-Tan.x);\n        float NorSign = sign(dot(Nor,P-clinep.xy));\n        if (NorSign==0.) continue; //Parallel\n        Nor *= NorSign;\n        //Coordinate system to clinep.xy\n        CX = normalize(clinep.xy-P);\n        CY = vec2(-CX.y,CX.x);\n        CY *= max(0.,sign(dot(CY,clinep.zw-P)))*2.-1.;\n        VParts[0] = vec2(0.,Len);\n        for (float s=0.; s<NObjects; s++) {\n            //For each other line\n            if (s==i) continue;\n            linep = texture(iChannel0,vec2(0.5+s,0.5)*IRES);\n            //Order\n            A1 = atan(dot(CY,linep.xy-P),dot(CX,linep.xy-P));\n            A2 = atan(dot(CY,linep.zw-P),dot(CX,linep.zw-P));\n            if (A2<A1) linep = linep.zwxy;\n            //Occlusion check\n            vec2 LTan = linep.xy-linep.zw;\n            vec2 LNorm = vec2(LTan.y,-LTan.x);\n            LNorm = LNorm*sign(dot(P-linep.xy,LNorm));\n            float CompDot = dot(clinep.xy-linep.xy,LNorm);\n            if (CompDot==0. || max(0.,sign(CompDot))!=max(0.,sign(dot(clinep.zw-linep.xy,LNorm)))) {\n                //Test linep against clinep instead\n                CompDot = -dot(linep.xy-clinep.xy,Nor);\n            }\n            if (CompDot<0.) {\n                //linep might occlude clinep\n                float t0 = -dot(P-clinep.xy,Nor)*((dot(linep.xy-P,Nor)==0.)?1000000.:1./dot(linep.xy-P,Nor));\n                float t1 = -dot(P-clinep.xy,Nor)*((dot(linep.zw-P,Nor)==0.)?1000000.:1./dot(linep.zw-P,Nor));\n                if (t0>0. || t1>0.) {\n                    //One of the extended lines have a valid intersection\n                    p0 = dot(Tan,P+t0*(linep.xy-P)-clinep.xy);\n                    p1 = dot(Tan,P+t1*(linep.zw-P)-clinep.xy);\n                    if (t0<0.) {\n                        p0 = ((dot(Tan,LNorm)>0.)?-1.:Len+1.);\n                    } else if (t1<0.) {\n                        p1 = ((dot(Tan,LNorm)>0.)?-1.:Len+1.);\n                    }\n                    if (p1<p0) { float tmp = p0; p0 = p1; p1 = tmp; }\n                    int tmpNVParts = NVParts;\n                    for (int vpi=0; vpi<tmpNVParts; vpi++) {\n                        //For each visible part\n                        vec2 CVP = VParts[vpi];\n                        if (CVP.x<0.) continue;\n                        if (p0<=CVP.x && p1>=CVP.y) {\n                            //All is occluded\n                            VParts[vpi] = vec2(-1.);\n                        } else if (p0>=CVP.x && p0<=CVP.y && p1>=CVP.y) {\n                            //Lower part is occluded\n                            VParts[vpi] = vec2(CVP.x,p0);\n                        } else if (p1<=CVP.y && p1>=CVP.x && p0<=CVP.x) {\n                            //Upper part is occluded\n                            VParts[vpi] = vec2(p1,CVP.y);\n                        } else if (p1<=CVP.y && p0>=CVP.x) {\n                            //Middle part is occluded\n                            VParts[vpi] = vec2(CVP.x,p0);\n                            VParts[NVParts] = vec2(p1,CVP.y);\n                            NVParts += 1;\n                        }\n                    }\n                }\n            }\n        }\n        //First integral\n        float Y = dot(Nor,P-clinep.xy);\n        float Z = dot(Tan,P-clinep.xy);\n        for (int ai=0; ai<NVParts; ai++) {\n            vec2 VA = VParts[ai];\n            if (VA.x<-0.5) continue;\n            if (VA.x>VA.y) VA = VA.yx;\n            //Total angle\n            vec2 lp0 = clinep.xy+Tan*VA.x-P;\n            vec2 lp1 = clinep.xy+Tan*VA.y-P;\n            vec2 A12 = vec2(atan(-lp0.y,-lp0.x)+PI,atan(-lp1.y,-lp1.x)+PI);\n            if (A12.x>A12.y) A12 = A12.yx;\n            if (A12.y-A12.x<PI) {\n                I.xyz -= SkyIntegral(A12.x,A12.y,Time,iMouse);\n            } else {\n                I.xyz -= SkyIntegral(0.,A12.x,Time,iMouse);\n                I.xyz -= SkyIntegral(A12.y,PI2,Time,iMouse);\n            }\n            //Radiosity gather\n            vec3 RadiosityI = vec3(0.);\n            float XOffset = ((NorSign>0.5)?0.:RadiosityRES);\n            vec2 gcoord = VA/Len;\n            //First partial pixel\n            if (floor(gcoord.x*RadiosityRES)==floor(gcoord.y*RadiosityRES)) {\n                //Same texel\n                vec2 lp0 = clinep.xy+TanF*gcoord.x-P;\n                vec2 lp1 = clinep.xy+TanF*gcoord.y-P;\n                float AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n                RadiosityI += texture(iChannel0,vec2(floor(gcoord.x*RadiosityRES)+0.5+XOffset,i+1.5)*IRES).xyz*AbsAngle;\n            } else {\n                //Difrerent texels\n                float tmpCeil = clamp(floor(gcoord.x*RadiosityRES)+1.,0.,RadiosityRES);\n                vec2 lp0 = clinep.xy+TanF*gcoord.x-P;\n                vec2 lp1 = clinep.xy+TanF*tmpCeil*IRadiosityRES-P;\n                float AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n                RadiosityI += texture(iChannel0,vec2(tmpCeil-0.5+XOffset,i+1.5)*IRES).xyz*AbsAngle;\n                //Last partial pixel\n                float tmpFloor = clamp(floor(gcoord.y*RadiosityRES),0.,RadiosityRES);\n                lp0 = clinep.xy+TanF*tmpFloor*IRadiosityRES-P;\n                lp1 = clinep.xy+TanF*gcoord.y-P;\n                AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n                RadiosityI += texture(iChannel0,vec2(tmpFloor+0.5+XOffset,i+1.5)*IRES).xyz*AbsAngle;\n                //Middle\n                gcoord *= RadiosityRES;\n                for (float uvx=tmpCeil; uvx<tmpFloor-0.5; uvx++) {\n                    float fractx = uvx*IRadiosityRES;\n                    lp0 = clinep.xy+TanF*fractx-P;\n                    lp1 = clinep.xy+TanF*(fractx+IRadiosityRES)-P;\n                    AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n                    RadiosityI += texture(iChannel0,vec2(uvx+0.5+XOffset,i+1.5)*IRES).xyz*AbsAngle;\n               }\n           }\n           I += RadiosityI*texture(iChannel0,vec2(NObjects+0.5+i,0.5)*IRES).xyz;\n       }\n   }\n   //Sky integral\n   I += SkyIntegral(0.,PI2,Time,iMouse);\n   //Return\n   return I/(2.*PI);\n}\n\nvec4 RenderGeometry(vec2 UV, sampler2D ch0, vec2 ires, vec2 res) {\n    float SDF = 10.;\n    float ssdf; vec3 E = vec3(0.); vec4 linep;\n    for (float i=0.; i<NObjects; i++) {\n        linep = texture(ch0,vec2(0.5+i,0.5)*ires)*res.y;\n        ssdf = LineDF(UV,linep.xy,linep.zw);\n        if (ssdf<SDF) {\n            SDF = ssdf;\n            \n        }\n    }\n    float W = 1.-clamp(0.,1.,SDF-0.5);\n    return vec4(E*W,W);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Color = Integral(fragCoord*IRES.y,iTime);\n    //Render geometry\n    vec4 GeoC = RenderGeometry(fragCoord,iChannel0,IRES,iResolution.xy);\n    Color = mix(Color,GeoC.xyz,GeoC.w);\n    \n    /*\n    vec2 CUV = fragCoord*0.05;\n    if (CUV.x<RadiosityRES*2. && CUV.y<NObjects+1.) {\n        Color = texture(iChannel0,CUV*IRES).xyz;\n    }\n    //*/\n    \n    //Return\n    fragColor = vec4(pow(1.-exp(-1.2*Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Radiosity texels\n\nvec3 Integral(vec2 P, float Time) {\n    //Computes the light integral\n    float TotalGeometryAngle = 0.;\n    vec3 I = vec3(0.);\n    int NVParts; float A1,A2,p0,p1,Len;\n    vec2 CX,CY,Tan,UNor,Nor,TanF; vec4 clinep,linep;\n    vec2 VParts[int(NObjects)+1];\n    //Sky and emissive integration\n    for (float i=0.; i<NObjects; i++) {\n        //For each line\n        NVParts = 1;\n        clinep = texture(iChannel0,vec2(0.5+i,0.5)*IRES);\n        //Create coordinate system\n        Len = length(clinep.zw-clinep.xy);\n        TanF = clinep.zw-clinep.xy;\n        Tan = TanF/Len;\n        UNor = vec2(-Tan.y,Tan.x);\n        Nor = vec2(Tan.y,-Tan.x);\n        float NorSign = sign(dot(Nor,P-clinep.xy));\n        if (NorSign==0.) continue; //Parallel\n        Nor *= NorSign;\n        //Coordinate system to clinep.xy\n        CX = normalize(clinep.xy-P);\n        CY = vec2(-CX.y,CX.x);\n        CY *= max(0.,sign(dot(CY,clinep.zw-P)))*2.-1.;\n        VParts[0] = vec2(0.,Len);\n        for (float s=0.; s<NObjects; s++) {\n            //For each other line\n            if (s==i) continue;\n            linep = texture(iChannel0,vec2(0.5+s,0.5)*IRES);\n            //Order\n            A1 = atan(dot(CY,linep.xy-P),dot(CX,linep.xy-P));\n            A2 = atan(dot(CY,linep.zw-P),dot(CX,linep.zw-P));\n            if (A2<A1) linep = linep.zwxy;\n            //Occlusion check\n            vec2 LTan = linep.xy-linep.zw;\n            vec2 LNorm = vec2(LTan.y,-LTan.x);\n            LNorm = LNorm*sign(dot(P-linep.xy,LNorm));\n            float CompDot = dot(clinep.xy-linep.xy,LNorm);\n            if (CompDot==0. || max(0.,sign(CompDot))!=max(0.,sign(dot(clinep.zw-linep.xy,LNorm)))) {\n                //Test linep against clinep instead\n                CompDot = -dot(linep.xy-clinep.xy,Nor);\n            }\n            if (CompDot<0.) {\n                //linep might occlude clinep\n                float t0 = -dot(P-clinep.xy,Nor)*((dot(linep.xy-P,Nor)==0.)?1000000.:1./dot(linep.xy-P,Nor));\n                float t1 = -dot(P-clinep.xy,Nor)*((dot(linep.zw-P,Nor)==0.)?1000000.:1./dot(linep.zw-P,Nor));\n                if (t0>0. || t1>0.) {\n                    //One of the extended lines have a valid intersection\n                    p0 = dot(Tan,P+t0*(linep.xy-P)-clinep.xy);\n                    p1 = dot(Tan,P+t1*(linep.zw-P)-clinep.xy);\n                    if (t0<0.) {\n                        p0 = ((dot(Tan,LNorm)>0.)?-1.:Len+1.);\n                    } else if (t1<0.) {\n                        p1 = ((dot(Tan,LNorm)>0.)?-1.:Len+1.);\n                    }\n                    if (p1<p0) { float tmp = p0; p0 = p1; p1 = tmp; }\n                    int tmpNVParts = NVParts;\n                    for (int vpi=0; vpi<tmpNVParts; vpi++) {\n                        //For each visible part\n                        vec2 CVP = VParts[vpi];\n                        if (CVP.x<0.) continue;\n                        if (p0<=CVP.x && p1>=CVP.y) {\n                            //All is occluded\n                            VParts[vpi] = vec2(-1.);\n                        } else if (p0>=CVP.x && p0<=CVP.y && p1>=CVP.y) {\n                            //Lower part is occluded\n                            VParts[vpi] = vec2(CVP.x,p0);\n                        } else if (p1<=CVP.y && p1>=CVP.x && p0<=CVP.x) {\n                            //Upper part is occluded\n                            VParts[vpi] = vec2(p1,CVP.y);\n                        } else if (p1<=CVP.y && p0>=CVP.x) {\n                            //Middle part is occluded\n                            VParts[vpi] = vec2(CVP.x,p0);\n                            VParts[NVParts] = vec2(p1,CVP.y);\n                            NVParts += 1;\n                        }\n                    }\n                }\n            }\n        }\n        //First integral\n        float Y = dot(Nor,P-clinep.xy);\n        float Z = dot(Tan,P-clinep.xy);\n        for (int ai=0; ai<NVParts; ai++) {\n            vec2 VA = VParts[ai];\n            if (VA.x<-0.5) continue;\n            if (VA.x>VA.y) VA = VA.yx;\n            //Total angle\n            vec2 lp0 = clinep.xy+Tan*VA.x-P;\n            vec2 lp1 = clinep.xy+Tan*VA.y-P;\n            //float AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n            //TotalGeometryAngle += AbsAngle;\n            \n            \n            vec2 A12 = vec2(atan(-lp0.y,-lp0.x)+PI,atan(-lp1.y,-lp1.x)+PI);\n            if (A12.x>A12.y) A12 = A12.yx;\n            if (A12.y-A12.x<PI) {\n                I.xyz -= SkyIntegral(A12.x,A12.y,Time,iMouse);\n            } else {\n                I.xyz -= SkyIntegral(0.,A12.x,Time,iMouse);\n                I.xyz -= SkyIntegral(A12.y,PI2,Time,iMouse);\n            }\n            //Radiosity gather\n            vec3 RadiosityI = vec3(0.);\n            float XOffset = ((NorSign>0.5)?0.:RadiosityRES);\n            vec2 gcoord = VA/Len;\n            //First partial pixel\n            if (floor(gcoord.x*RadiosityRES)==floor(gcoord.y*RadiosityRES)) {\n                //Same texel\n                vec2 lp0 = clinep.xy+TanF*gcoord.x-P;\n                vec2 lp1 = clinep.xy+TanF*gcoord.y-P;\n                float AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n                RadiosityI += texture(iChannel0,vec2(floor(gcoord.x*RadiosityRES)+0.5+XOffset,i+1.5)*IRES).xyz*AbsAngle;\n            } else {\n                //Difrerent texels\n                float tmpCeil = clamp(floor(gcoord.x*RadiosityRES)+1.,0.,RadiosityRES);\n                vec2 lp0 = clinep.xy+TanF*gcoord.x-P;\n                vec2 lp1 = clinep.xy+TanF*tmpCeil*IRadiosityRES-P;\n                float AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n                RadiosityI += texture(iChannel0,vec2(tmpCeil-0.5+XOffset,i+1.5)*IRES).xyz*AbsAngle;\n                //Last partial pixel\n                float tmpFloor = clamp(floor(gcoord.y*RadiosityRES),0.,RadiosityRES);\n                lp0 = clinep.xy+TanF*tmpFloor*IRadiosityRES-P;\n                lp1 = clinep.xy+TanF*gcoord.y-P;\n                AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n                RadiosityI += texture(iChannel0,vec2(tmpFloor+0.5+XOffset,i+1.5)*IRES).xyz*AbsAngle;\n                //Middle\n                gcoord *= RadiosityRES;\n                for (float uvx=tmpCeil; uvx<tmpFloor-0.5; uvx++) {\n                    float fractx = uvx*IRadiosityRES;\n                    lp0 = clinep.xy+TanF*fractx-P;\n                    lp1 = clinep.xy+TanF*(fractx+IRadiosityRES)-P;\n                    AbsAngle = abs(atan(dot(CY,lp1),dot(CX,lp1))-atan(dot(CY,lp0),dot(CX,lp0)));\n                    RadiosityI += texture(iChannel0,vec2(uvx+0.5+XOffset,i+1.5)*IRES).xyz*AbsAngle;\n               }\n           }\n           I += RadiosityI*texture(iChannel0,vec2(NObjects+0.5+i,0.5)*IRES).xyz;\n       }\n   }\n   //Sky integral\n   I += SkyIntegral(0.,PI2,Time,iMouse);\n   //Return\n   return I/(2.*PI);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (fragCoord.y<1. && fragCoord.x<NObjects) {\n        //Lines - positions\n        if (fragCoord.x<1.) Output = vec2(0.65,0.35).xyxy+vec2(sin(iTime*1.7),cos(iTime*1.7)).xyxy*vec4(-1.,-1.,1.,1.)*0.08;\n        else if (fragCoord.x<2.) Output = vec4(1.499,0.3,1.1,0.3);\n        else if (fragCoord.x<3.) Output = vec4(1.5,0.9,1.5,0.1);\n        else if (fragCoord.x<4.) Output = vec4(1.5,0.099,0.098,0.099);\n        else if (fragCoord.x<5.) Output = vec4(0.1,0.1,0.499,0.9);\n        else if (fragCoord.x<6.) Output = vec4(0.7,0.9,1.35,0.9);\n        else if (fragCoord.x<7.) Output = vec4(0.8,0.899,0.8,0.3);\n        else if (fragCoord.x<8.) Output = vec4(0.799,0.5,0.4,0.5);\n        else if (fragCoord.x<9.) Output = vec2(1.2,0.55).xyxy+vec2(sin(iTime),cos(iTime)).xyxy*vec4(-1.,-1.,1.,1.)*0.2;\n        else if (fragCoord.x<10.) Output = vec4(0.498,0.901,0.6,0.9);\n    } else if (fragCoord.y<1. && fragCoord.x<NObjects*2.) {\n        //Lines - colors\n        Output.xyz = vec3(0.8);\n        if (abs(mod(fragCoord.x,NObjects)-7.5-3.5*0.)<0.1) Output.xyz = vec3(0.4,0.98,0.4);\n        if (abs(mod(fragCoord.x,NObjects)-8.5)<0.1) Output.xyz = vec3(0.98,0.5,0.2);\n    } else if (fragCoord.y<NObjects+1. && fragCoord.x<RadiosityRES*2.) {\n        //Texels\n        float CLineIndex = fragCoord.y-1.5;\n        vec4 CLine = texture(iChannel0,vec2(CLineIndex+0.5,0.5)*IRES);\n        float XCoord = mod(fragCoord.x,RadiosityRES);\n        vec2 Tan = CLine.zw-CLine.xy;\n        vec2 TexPos = CLine.xy+(XCoord*IRadiosityRES)*Tan;\n        vec2 TexNormal = normalize(vec2(Tan.y,-Tan.x))*((fragCoord.x<RadiosityRES)?1.:-1.);\n        //Integrate\n        Output.xyz = Integral(TexPos+TexNormal*0.001,iTime)*float(iFrame>0);\n        //Emissive on the rotated line\n        if (CLineIndex<1.) {\n            //Output.xyz += mix(vec3(1.,0.3,0.05),vec3(0.,0.5,0.8),fragCoord.x*IRadiosityRES)*\n            //              float(mod(fragCoord.x*0.5,2.)<1.)*(sin(iTime*1.6)*0.5+0.5)*2.;\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float NObjects = 10.;\nconst float RadiosityRES = 16.;\nconst float IRadiosityRES = 1./RadiosityRES;\nconst vec3 SkyColor = vec3(0.1,0.225,0.3);\nconst vec3 SunColor = vec3(1.,0.75,0.5)*40.;\nconst float PI = 3.14159265;\nconst float PI2 = PI*2.;\n//Defines\n#define RES iChannelResolution[0].xy\n#define IRES 1./iChannelResolution[0].xy\n\nfloat LineDF(vec2 p, vec2 a, vec2 b) {\n    //Distance Field\n    vec2 ba=b-a;\n    float k=dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nvec3 SkyIntegral(float a0, float a1, float Time, vec4 Mouse) {\n    //Integrates the sky\n    vec3 SI = SkyColor*(a1-a0-0.5*(cos(a1)-cos(a0)));\n    float SunA = 1.5+sin(Time)*1.5;\n        SunA = atan(Mouse.y-540.,Mouse.x-480.)+PI;\n    SI += SunColor*(atan(16.*(SunA-a0))-atan(16.*(SunA-a1)))/16.;\n    return SI;\n}","name":"Common","description":"","type":"common"}]}