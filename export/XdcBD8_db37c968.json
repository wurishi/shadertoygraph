{"ver":"0.1","info":{"id":"XdcBD8","date":"1524839111","viewed":253,"name":"Platonic Stars","username":"gPlatl","description":"Platonic Stars described by Alexandra Fritz & Herwig Hauser \n[url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.168.278&rep=rep1&type=pdf]PDF[/url] .","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["3d","stars","tetrahedron","icosahedron","dodecahedron","octahedron","platonic","hexahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//--------------------------------------------------------------------\n// PlatonicStars_Image.glsl\n//\n//   v1.0  2018-04-27  initial version\n//\n// Raytracer created by yvtjp\n//   https://www.shadertoy.com/view/XsdSR7\n// \n// tags: platonic, stars, 3d, tetrahedron, octahedron, hexahedron, icosahedron, dodecahedron \n//--------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    \n    vec2 offs = vec2(.001 / BloomUndersample) / iResolution.xy;\n    \n    vec2 uv0 = uv / BloomUndersample;\n    for (float x = -0.5; x <= 0.5; x += 0.2)\n        for (float y = -0.5; y <= 0.5; y += 0.2)\n\t\t\tfragColor += texture(iChannel1, uv0 + vec2(x,y)*offs)\n                * (max(0.7 - length(vec2(x,y)), 0.) * .0002);\n    \n    // vignette\n    vec2 vigPos = ((uv.xy - 0.5) * iResolution.xy) / max(iResolution.x, iResolution.y);\n    float vig = 1. - dot(vigPos, vigPos);\n    fragColor.xyz *= vig * vig;\n    \n    fragColor.xyz = sqrt(fragColor.xyz); // gamma correction\n    fragColor.xyz *= 0.7; // exposure\n    fragColor.xyz = mix(fragColor.xyz, smoothstep(0., 1., fragColor.xyz), 0.9); // tone mapping\n    fragColor.w = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//--------------------------------------------------------------------\n// PlatonicStars_BufA.glsl\n//\n// Raytracer created by yvtjp\n//   https://www.shadertoy.com/view/XsdSR7\n//--------------------------------------------------------------------\n\nconst float FarDistance = 12.;\nconst float NearDistance = 4.;\nconst int NumSteps = 48;\t\t// Number of samples per pixel (per frame)\nconst float DerivStep = 0.001;\t// For shading\nconst bool disableProgressiveRefinement = false;\n\nfloat ditherPattern(vec2 coord)\n{\n \tcoord = fract(coord * 0.5);\n    return dot(coord, vec2(0.25, 0.5));\n}\n\nvec3 computeNormalAt(vec3 pos)\n{\n    vec3 v = vec3(\n    \timplicitFunc(pos - vec3(DerivStep, 0., 0.)),\n    \timplicitFunc(pos - vec3(0., DerivStep, 0.)),\n    \timplicitFunc(pos - vec3(0., 0., DerivStep))\n    );\n    vec3 v2 = vec3(\n    \timplicitFunc(pos + vec3(DerivStep, 0., 0.)),\n    \timplicitFunc(pos + vec3(0., DerivStep, 0.)),\n    \timplicitFunc(pos + vec3(0., 0., DerivStep))\n    );\n    return normalize(v - v2);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// from https://github.com/Hyper3D/hyper3d/blob/master/src/renderer/shaders/common/ShadingModel.glsl \nfloat evaluateGGXSpecularDistribution(float nhDot, highp float roughness)\n{\n    // Walter et al. 2007, \"Microfacet models for refraction through rough surfaces\"\n    // http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n    highp float a = roughness * roughness;\n    highp float aa = a * a;\n    highp float t = nhDot * nhDot * (aa - 1.) + 1.;\n    return aa /\n        (t * t + 1.e-20);\n}\n\nfloat evaluateSchlickFresnel(float hlDot)\n{\n    float t = 1. - hlDot;\n    float tt = t * t;\n    return tt * tt * t;\n}\n\nfloat evaluateBeckmannGeometryShadowing(float nlDot, float nvDot, float roughness)\n{\n    // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html\n    float lct = .5 / (roughness * sqrt(1. - nlDot * nlDot) + 0.00001);\n    float vct = .5 / (roughness * sqrt(1. - nvDot * nvDot) + 0.00001);\n    float lc = lct * nlDot, vc = vct * nvDot;\n    float a = 3.353 * lc + 2.181 * lc * lc; // not typo\n    a *= 3.353 * vct + 2.181 * vct * vc;\n    float b = 1. + 2.276 * lc + 2.577 * lc * lc;\n    b *= 1. + 2.276 * vc + 2.577 * vc * vc;\n    return a / b;\n}\nfloat evaluateBeckmannGeometryShadowingSingleSide(float nlDot, float roughness)\n{\n    // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html\n    float lct = .5 / (roughness * sqrt(1. - nlDot * nlDot) + 0.00001);\n    float lc = lct * nlDot;\n    float a = 3.353 * lc + 2.181 * lc * lc; // not typo\n    float b = 1. + 2.276 * lc + 2.577 * lc * lc;\n    return a / b;\n}\n\nvec3 cameraPos;\n\nfloat evaluateAmbient(vec3 pos, vec3 normal)\n{\n    vec3 viewDir = normalize(cameraPos - pos);\n    float nvDot = dot(normal, viewDir);\n    float fresnel = evaluateSchlickFresnel(nvDot);\n    float refl = mix(0.03, 1., fresnel);\n    return 1. - refl;\n}\n\nvec3 evaluatePointLight(vec3 pos, vec3 normal, vec3 lightDir, vec3 albedo)\n{\n    vec3 viewDir = normalize(cameraPos - pos);\n \tvec3 halfVec = normalize(viewDir + lightDir);\n    float nlDot = dot(normal, lightDir);\n    if (nlDot <= 0.) return vec3(0.);\n    float hlDot = dot(halfVec, lightDir);\n    float nhDot = dot(normal, halfVec);\n    float nvDot = dot(normal, viewDir);\n    \n    float fresnel = evaluateSchlickFresnel(nvDot);\n    float refl = mix(0.03, 1., fresnel);\n    float roughness = 0.2;\n    float spec = evaluateGGXSpecularDistribution(nhDot, roughness)\n        * evaluateBeckmannGeometryShadowing(nlDot, nvDot, roughness);\n    return mix(albedo, vec3(spec), refl) * nlDot;\n}\n\nvec3 sampleBackground(vec3 v)\n{\n    v = vec3(v.x, -v.z, v.y);\n    vec3 rgb = texture(iChannel1, v).xyz;\n    return rgb * rgb * 4.; // linearize\n}\t\n\nvec3 evaluateReflection(vec3 pos, vec3 normal)\n{\n    vec3 viewDir = normalize(cameraPos - pos);\n    float nvDot = dot(normal, viewDir);\n    vec3 lightDir = reflect(-viewDir, normal);\n    \n    float fresnel = evaluateSchlickFresnel(nvDot);\n    float refl = mix(0.03, 1., fresnel);\n    float roughness = 0.2;\n    \n    refl *= evaluateBeckmannGeometryShadowingSingleSide(nvDot, roughness);\n    \n    return refl * sampleBackground(lightDir).xyz;\n}\n\nvoid shade(vec3 pos, out vec3 color)\n{\n    vec3 surfNormal = computeNormalAt(pos);\n    \n    float h = pos.x * 0.25;\n    vec3 albedo = hsv2rgb(vec3(h, 0.9, 0.8));\n    \n    // semisphere lighting\n    float dtSky = dot(surfNormal, vec3(0., 0., 1.));\n    vec3 diff = (dtSky * 0.5 + 0.5) * evaluateAmbient(pos, surfNormal)\n        * vec3(0.4, 0.7, 0.4);\n    color.xyz = albedo * diff;\n    \n    // directional lighting\n    color.xyz += evaluatePointLight(pos, surfNormal,\n        normalize(vec3(0.5, 1., 1.)), albedo);\n    \n    // environemntal mapping\n    color.xyz += evaluateReflection(pos, surfNormal);\n}\n\nbool trace(inout vec4 fragColor, vec3 cameraPos, vec3 rayDir, float farDist, float dither)\n{\n    fragColor.w = FarDistance; // reset upper bound\n    \n    // Start sampling\n    float interval = (farDist - NearDistance) / float(NumSteps + 1);\n    float d = interval * dither + NearDistance;\n    vec3 rayPos = vec3(0.);\n    float fval = implicitFunc(cameraPos + rayDir * d);\n    \n    for (int i = 0; i < NumSteps; ++i) {\n        float lastD = d;\n        // vec3 lastRayPos = rayPos;\n        float lastfval = fval;\n        \n       \td += interval;\n        if (i == NumSteps - 1) {\n         \td = farDist;   \n        }\n     \trayPos = cameraPos + rayDir * d;\n        fval = implicitFunc(rayPos);\n        \n        if (fval > 0.) {\n            // refine\n            for (int k = 0; k < 12; ++k) {\n                float midD = mix(lastD, d, 0.5);\n                vec3 midRayPos = cameraPos + rayDir * midD;\n                float midfval = implicitFunc(midRayPos);\n                if (midfval > 0.) {\n                 \td = midD;   \n                } else {\n                 \tlastD = midD;   \n                }\n                rayPos = midRayPos;\n            }\n         \tfragColor.w = lastD;\n            shade(rayPos, fragColor.xyz);\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 lastValue = iFrame == 0 ? vec4(0.) : texture(iChannel0, uv);\n    time = iTime;\n    \n    float yaw = iTime * 0.04;\n    float pitch = 0.3 * sin(iTime * 0.01);\n    if (iMouse.z > 0.) {\n        vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n     \tyaw = mousePos.x * 6.;\n        pitch = mousePos.y * -4.;\n    }\n    cameraPos = vec3(cos(yaw)*cos(pitch),sin(yaw)*cos(pitch),sin(pitch)) * 8.;\n    vec3 cameraDir = normalize(-cameraPos);\n    vec3 cameraUp = vec3(0., 0., 1.);\n    vec3 cameraU = normalize(cross(cameraUp, cameraDir));\n    vec3 cameraV = cross(cameraDir, cameraU);\n    vec2 cameraUV = (uv - 0.5) * 0.5 * vec2(16./9.,1.);\n    vec3 rayDir = cameraDir + cameraU * cameraUV.x + cameraV * cameraUV.y;\n    \n    vec3 background = sampleBackground(rayDir);\n    fragColor = vec4(mix(lastValue.xyz, background, 0.8), 1.0);\n    \n    float farDist = clamp(lastValue.w * 1.003, 0.01, FarDistance);\n    \n    float dither = ditherPattern(fragCoord);\n    dither = fract(dither + 10. * cos(10. * cos(iTime + dot(fragCoord, vec2(11.4, 51.4)))));\n    \n    if (disableProgressiveRefinement || !trace(fragColor, cameraPos, rayDir, farDist, dither)) {\n        // Fail; reset the upper bound\n        trace(fragColor, cameraPos, rayDir, FarDistance, dither);\n    }  \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//--------------------------------------------------------------------\n// PlatonicStars_Common.glsl   by Gerd Platl\n//\n//   v1.0  2018-04-27  initial version\n//\n// Ref: Platonic Stars - Alexandra Fritz & Herwig Hauser - Vienna 2010\n//      https://slideheaven.com/platonic-stars.html\n//      https://medienportal.univie.ac.at/presse/aktuelle-pressemeldungen/detailansicht/artikel/roter-dodekaederstern-fuer-universitaet-wien/\n//--------------------------------------------------------------------\n \nconst float BloomUndersample = 20.;  // undersampling for bloom effect\n\nfloat time = 0.0;\n\n//--------------------------------------------------------------------\n// Ex-1: Dodecahedron Star: 20 vertices, 12 faces, 30 edges\n//--------------------------------------------------------------------\nfloat DodecahedronStar(vec3 pos)\n{\n  float x=pos.x,  y=pos.y,  z=pos.z;\n  float x2=x*x,   y2=y*y,   z2=z*z;\n  float x3=x*x2,  y3=y*y2,  z3=z*z2;\n  float x4=x2*x2, y4=y2*y2, z4=z2*z2;\n\n  float u = x2+y2+z2;         // page 23, formula(2)\n  float v = -z*(2.*x+z)\n            *(x4 -x2*z2 +z4\n              +2.*(x3*z -x*z3)\n              +5.*(y4 -y2*z2)\n              +10.*(x*y2*z-x2*y2));\n\n  float c = -0.3+ 33.3*(pow((0.5+0.5*sin(time)),2.));  // -33.6 .. 33.0 \n  // page 23, formula(1)\n  return pow(1.-u,3.) -5./27.*c*pow(u,3.) +c*v;\n}\n//--------------------------------------------------------------------\n// Ex-2: Octahedral Star: 6 vertices, 12 edges, 8 faces\n//--------------------------------------------------------------------\nfloat OctahedralStar(vec3 pos)\n{\n  float x=pos.x, y=pos.y, z=pos.z;\n  float x2=x*x,  y2=y*y,  z2=z*z;\n\n  // page 27, formula(5)  \n  float u = x2+y2+z2;\n  float v = x2*y2 +y2*z2 +z2*x2;\n  float w = x2*y2*z2;\n\n  float c = -200. +201.0*(1.-pow((0.5+0.5*sin(time)),2.)); // -401 .. 1\n  // page 28, formula(7), a4=0, a6=0 \n  return pow(1.-u,3.) +c*u*v; \n}\n//--------------------------------------------------------------------\n// Ex-2: Hexahedral Star: 8 vertices, 12 edges, 6 faces\n//--------------------------------------------------------------------\nfloat HexahedralStar(vec3 pos)\n{\n  float x=pos.x, y=pos.y, z=pos.z;\n  float x2=x*x,  y2=y*y,  z2=z*z;\n\n  // page 27, formula(5)   \n  float u = x2 +y2 +z2;\n  float v = x2*y2 +y2*z2 +z2*x2;\n  float w = x2*y2*z2;\n\n  float c = 2. -4.* pow((0.5+0.5*sin(time)),2.);\n  // page 28, formula(8)  \n  return 1. -3.*u -(100.+c)*u*u +(9.+300.)*v -27.*w;\n}\n//--------------------------------------------------------------------\n// Ex-2: FourteenStar Star: 14 vertices, 36 edges, 24 faces\n//--------------------------------------------------------------------\nfloat FourteenStar(vec3 pos)\n{\n  float x=pos.x, y=pos.y, z=pos.z;\n  float x2=x*x,  y2=y*y,  z2=z*z;\n\n  // page 27, formula(5)   \n  float u = x2 +y2 +z2;\n  float v = x2*y2 +y2*z2 +z2*x2;\n  float w = x2*y2*z2;\n\n  float c = -3. + 4.* pow((0.5+0.5*sin(time)),2.);\n  // page 28, formula(9)\n  return pow(1.-u,3.) +c*u*v -9.*c*w;\n}\n//--------------------------------------------------------------------\n// Ex-3: Tetrahedral Star: 4 faces, 6 edges, 4 vertices\n//--------------------------------------------------------------------\nfloat TetrahedralStar(vec3 pos)\n{\n  float x=pos.x, y=pos.y, z=pos.z;\n  float x2=x*x,  y2=y*y,  z2=z*z;\n\n  // page 29, formula(10)  \n  float u = x2+y2+z2;\n  float v = x*y*z;\n  float w = x2*y2+y2*z2+z2*x2;\n   \n  float c = -100. +100.* pow((-0.5+0.5*sin(time)),2.);  // -100 .. 0\n  // page 29, formula(11)\n  return 1. -2.*u +c*u*u +8.*v -(3.*c +1.)*w;  \n}\n//--------------------------------------------------------------------\n// Ex-4: Icosahedral Star: 12 vertices, 30 edges, 20 faces \n//--------------------------------------------------------------------\nfloat IcosahedralStar(vec3 pos)\n{\n  float x=pos.x,  y=pos.y,  z=pos.z;\n  float x2=x*x,   y2=y*y,   z2=z*z;\n  float x3=x*x2,  y3=y*y2,  z3=z*z2;\n  float x4=x2*x2, y4=y2*y2, z4=z2*z2;\n\n  // page 23, formula(2)\n  float u = x2+y2+z2;  \n  float v = -z*(2.*x+z)\n            *(x4 -x2*z2 +z4\n              +2.*(x3*z -x*z3)\n              +5.*(y4 -y2*z2)\n              +10.*(x*y2*z-x2*y2));\n      \n  // page 29, formula(12)\n  float w = (4.*x2 +z2 -6.*x*z)           \n           *(z4 -2.*z3*x -x2*z2 +2.*z*x3 +x4 -25.*y2*z2\n             -30.*x*y2*z -10.*x2*y2 +5.*y4)\n           *(z4 +8.*z3*x +14.*x2*z2 -8.*z*x3 +x4 -10.*y2*z2\n             -10.*x2*y2 +5.*y4);\n  \n  float c = -3.8 +4.0*(1.-pow((0.5+0.5*sin(time)),2.));  \n  // page 29, formula(13)  \n  return pow(1.-u,3.) +c*u*u*u +c*v;     \n}\n//--------------------------------------------------------------------\n// algebraic surface function\n//--------------------------------------------------------------------\n#define map1 DodecahedronStar\n#define map2 IcosahedralStar\n#define map3 FourteenStar\n#define map4 HexahedralStar\n#define map5 OctahedralStar\n#define map6 TetrahedralStar\n\nfloat implicitFunc(vec3 pos)\n{ \n  // for single map testing ...\n  //return DodecahedronStar(pos);\n  //return IcosahedralStar(pos);\n  //return FourteenStar(pos);\n  //return OctahedralStar(pos);\n  //return HexahedralStar(pos);\n  //return TetrahedralStar(pos);\n    \n  float t = mod(time, 36.0);\n  if (t <  6.0) return mix(map1(pos), map2(pos), smoothstep( 4.0,  6.0, t));\n  if (t < 12.0) return mix(map2(pos), map3(pos), smoothstep(10.0, 12.0, t));\n  if (t < 18.0) return mix(map3(pos), map4(pos), smoothstep(16.0, 18.0, t));\n  if (t < 24.0) return mix(map4(pos), map5(pos), smoothstep(22.0, 24.0, t));\n  if (t < 30.0) return mix(map5(pos), map6(pos), smoothstep(28.0, 30.0, t));\n  if (t < 36.0) return mix(map6(pos), map1(pos), smoothstep(34.0, 36.0, t));\n  return 1.0;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//--------------------------------------------------------------------\n// PlatonicStars_BufB.glsl\n//\n// Undersampling for bloom effect\n//--------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv *= BloomUndersample;\n  if (uv.x > 1. || uv.y > 1.) \n  {\n    fragColor = vec4(0.);\n    return;\n  }\n  vec2 offs = vec2(20.) / iResolution.xy;\n    \n  fragColor = vec4(0,0,0,1);\n  for (float x = -0.5; x <= 0.5; x += 0.1) \n    for (float y = -0.5; y <= 0.5; y += 0.1) \n      fragColor.xyz += texture(iChannel0, uv + vec2(x,y)*offs).xyz;\n}","name":"Buffer B","description":"","type":"buffer"}]}