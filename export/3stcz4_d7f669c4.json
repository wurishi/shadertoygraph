{"ver":"0.1","info":{"id":"3stcz4","date":"1600535008","viewed":261,"name":"varied area tiles ","username":"danhel95","description":"attempt  to make Shane 's  tiles without loops and conditions!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["grid","tutorial","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// learning tutorial 8\n// tried to make Shane's tiles without loops and if conditions !\n// seems to work\n\n\n// Fabrice version :) shorter !\n\n#define rand21(p)       fract( sin( dot( p, vec2(27.609, 57.583) ) ) * 43758.5453 )\n#define randCol(i)    ( .5 + .5*cos( 6.28 * rand21( (i)*.1 ) + vec3(0, 1, 2)*1.6 ) )\n#define box(p,c,b,f)  ( length( max( abs(p-(c)) - b + f , 0. ) ) - (f) )\n#define S(v)            smoothstep(sf, .0, v)\n#define rCol(p)       ( (0.5 + 0.5 * cos((p.x*p.y) * 6.2831 + vec3(0.0, 1.0, 2.0) )*clamp(1.0 - 0.2 * length(p), 0.0, 1.0) ) )\n#define SCALE  2.\n\nvoid mainImage(out vec4 F, vec2 C) {\n    vec2 R = iResolution.xy,\n         p = SCALE* ( ( C - .5*R ) / R.y + vec2( sin(iTime*.1 ) , 0 ) ),\n        ip = floor(p);\n         p -= ip ;\n\n    float r0 = rand21(ip + 1. )*.5 + .25   ;\n\n    vec2  b = step( r0, p ),\n          S = r0 * b ,\n          B = mix(b ,1.-b, r0 );\n\n    float  d = box( p , S + B/2., B/2., .05*sqrt( min(B.x, B.y) ) ),\n          sf = SCALE/500.;\n    vec2 id = ip + S + B/2. ;\n      vec2 aa = id - exp(-d*d * 50.0);\n    vec3 pCol = rCol( aa ) ;\n    pCol = mix(pCol, pCol.xzy, .2);\n\n    vec3 col = mix(vec3(1), pCol, S( d + SCALE/250.) );\n\n    d = length( abs(p - S - B/2.) - B/2. + .1/SCALE ) - .02/SCALE;\n    col =   mix(col, pCol*.4, S(d) )\n          *( r0*.02 + .8 );\n  float g = .1;\n  col = pow( col + g*g + g*vec3(.2,.5,.4)  , vec3(2.5) );\n\n    F.rgb = pow( col, vec3(1./2.2) );\n}\n\n// original\n\n// #define R iResolution\n\n// float rand21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// vec3 randCol(vec2 id) {\n//     float rnd = rand21(id *.1);\n//     return .3 + .5*cos(6.2831853*rnd + vec3(0, 1, 2)*1.6);\n\n// }\n\n\n// float box(in vec2 p,vec2 c, in vec2 b, in float sf){\n\n//   return length(max(abs(p-c) - b + sf, 0.)) - sf;\n// }\n\n// #define SCALE 2.\n// //or vec2\n// #define SCALE2 vec2(2.,3)\n\n\n// vec4 tiles(in vec2 q){\n//     vec2 p = q * SCALE; // q * SCALE2\n//     vec2 ip = floor(p);\n//     p -= ip ;\n//     vec2 B = vec2(1., 1.);\n//     vec2 S = vec2(0.);\n//     float r0 =  rand21(ip + B )*.5 + .25   ;\n\n//     vec2 b =   step(S + B*r0, p)  ; // or smoothstep( .0 , .00001, p - S - B*r0  )\n//     vec2 r0v = vec2(r0,r0);\n//     S  = r0v * B * b ;\n//     //B  *=  ( 1.- r0v )* b + r0v * (1.- b)  ;\n//     // or simplified\n//     B  *=  mix(r0v ,1.- r0v  ,  b ) ;\n\n//     float rf = min(B.x, B.y);\n//     float d = box(p , S + B/2., B/2., .05*sqrt(rf));\n//     float sf = 1./450.*SCALE;\n//     vec2 id = ip + S + B/2. ;\n\n//     vec3 pCol = randCol(id) ;\n//     pCol = mix(pCol, pCol.xzy, .2);\n\n//     // Rectangular cell border and coloring.\n//     vec3 col = vec3(1.) ;\n//     col = mix(col, pCol, smoothstep(sf, .0, d + .004*SCALE));\n\n//     // Splitting space to produce four rivot-looking dots.\n//     p = abs(p - S - B/2.) - B/2. + .1/SCALE;\n//     float d2 = length(p) - .02/SCALE;\n//     col = mix(col, vec3(pCol*.4), 1. - smoothstep(0., sf, d2)); // Rounded pavers.\n\n\n//     // Return the color and the bump value.\n//     return vec4(col, r0);\n\n// }\n\n// vec3 render(vec2 p) {\n\n//     p.x += sin(iTime*.05 );\n//     //p.x += sin(iTime*.1 + p.y); // curved\n//     vec4 bxD = tiles(p);\n//     vec4 bxD2 = tiles(p.xy - normalize(vec2(.2,5.))*.002);\n//     float b = max(bxD2.w - bxD.w, 0.)/.002;\n//     vec3 col = bxD.xyz*(b*.02 + .8);\n//     return col;\n\n\n\n\n// }\n\n// void mainImage(out vec4 F, in vec2 C) {\n//     vec2 O = (C.xy-.5*R.xy)/R.y;\n//     vec3 col = render(O) ;\n//     col = pow(col, vec3(1. / 2.2));\n//     F = vec4(col,1.);\n// }","name":"Image","description":"","type":"image"}]}