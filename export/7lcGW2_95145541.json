{"ver":"0.1","info":{"id":"7lcGW2","date":"1636813190","viewed":86,"name":"fun_illusion","username":"skaplun","description":"All the spheres actually are of the same color\nMade in 3d, despite it totally can go 2d","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["illusion","animation","loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int SPHERES_CNT = 12;\nconst vec4 SPHERE_CLR = vec4(191., 130., 91., 255.)/255.;\n//const vec4 SPHERE_CLR = vec4(1.);\nconst Sphere[] spheres = Sphere[SPHERES_CNT](\n                Sphere(vec3(3.2, 2.2, 0.), 1.5),\n                Sphere(vec3(-3.5, 1.6, 0.), 1.1),\n                Sphere(vec3(-2.5, -1., 0.), 1.4),\n                Sphere(vec3(-6., 3., 0.), 1.),\n                Sphere(vec3(-5.5, -2.7, 0.), 1.2),\n                Sphere(vec3(-.4, 2.7, 0.), 1.2),\n                Sphere(vec3(.1, -2.7, 0.), 1.2),\n                Sphere(vec3(.6, .2, 0.), 1.3),\n                Sphere(vec3(3.3, -1.5, 0.), 1.6),\n                Sphere(vec3(6., -3., 0.), 1.1),\n                Sphere(vec3(6., .25, 0.), 1.3),\n                Sphere(vec3(6.5, 3., 0.), 1.1));\n\n\nfloat COLOR_STRIPE_H = 8.;\nfloat TOTAL_DUR = 4.5;\nfloat SPH_APP_START = .2;\nfloat SPH_APP_DUR = .6;\nfloat SPH_GONE_START = 4.;\nfloat FADE_OUT_START = 2.5;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = mod(iTime, TOTAL_DUR);\n    vec4 clr = vec4(0.);\n    float sm = mod(fragCoord.y, (COLOR_STRIPE_H * 3.));\n    clr[int(sm/COLOR_STRIPE_H)] = 1.;\n    vec3 lookAt = vec3(0., 0., 0.);\n    vec3 eye = vec3(0., 0., 15.);\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, lookAt, vec3(0., 1., 0.)) * viewDir;\n    Ray cameraRay = Ray(eye, worldDir);\n\n    float dst = MAX_FLOAT;\n    vec3 intPoint = (cameraRay.origin + cameraRay.direction * dst);\n    vec3 nrm = vec3(0.);\n    int id = -1;\n    float app_time_span = SPH_APP_DUR/float(SPHERES_CNT);\n    for(int i=0; i<SPHERES_CNT; i++) {\n        Sphere curSphere = spheres[i];\n        curSphere.rad *= easeOutBack(clamp((t - SPH_APP_START - float(i) * app_time_span) * 2., 0., 1.));//step(float(i) * app_time_span, t);\n        curSphere.rad += max(t - SPH_GONE_START, 0.) * 100.;\n        float tmp = sphere_hit(curSphere, cameraRay);\n        if(tmp >= 0. && tmp < dst) {\n            dst = tmp;\n            intPoint = cameraRay.origin + cameraRay.direction * dst;\n            nrm = normalize(intPoint - curSphere.origin);\n            id = i%3;\n        }\n    }\n    vec3 lp = vec3(5., 10., 20.);\n    if(dst < MAX_FLOAT) {\n        vec3 lightDir = normalize(lp - intPoint);\n        clr = SPHERE_CLR * max(dot(lightDir, nrm), 0.) * .8;\n        vec3 viewDir = normalize(cameraRay.origin - intPoint);\n        vec3 reflectDir = reflect(-lightDir, nrm);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.) * .4;\n        clr += spec;\n        if(int(sm/COLOR_STRIPE_H) == id){\n            vec4 overlayColor = vec4(0.);\n            overlayColor[int(sm/COLOR_STRIPE_H)] = 1.;\n            \n            clr = mix(clr, overlayColor, smoothstep(FADE_OUT_START + .5, FADE_OUT_START, t));\n        }\n    }\n    fragColor = clr;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 1e6\nconst float PI = acos(-1.);\n\nstruct Ray{vec3 origin, direction;};\nstruct Sphere{vec3 origin; float rad;};\n//struct Flare{vec3 dir; float size;};\n//struct Plot{Sphere sphere; Ray cameraRay; Flare flare;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat sphere_hit(const in Sphere sphere, const in Ray inray) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.direction, inray.direction);\n    float b = dot(oc, inray.direction);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        return (-b - sqrt(discriminant))/a;\n    }\n    return -1.;\n}\n\nfloat easeOutBack(float x) {\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return 1. + c3 * pow(x - 1., 3.) + c1 * pow(x - 1., 2.);\n}","name":"Common","description":"","type":"common"}]}