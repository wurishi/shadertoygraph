{"ver":"0.1","info":{"id":"mt3yW7","date":"1702028172","viewed":25,"name":"Ridel Julien - TNCY","username":"PAX076","description":"projet","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["projet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////\n            // STRUCTURES//\n////////////////////////////////////////////            \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Cube {\n    vec3 Min;\n    vec3 Max;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Cylinder {\n    vec3 Center;\n    vec3 Axis; // Le vecteur d'axe du cylindre\n    float Radius;\n    float Height; // La hauteur du cylindre\n};\n\nstruct HalfSphere {\n   vec3 Center;\n   float Radius;\n   vec3 Normal;\n};\n\nstruct Plane {\n    vec3 Normal;\n    float D; // Distance du plan à l'origine\n    float Width; // Largeur du plan\n    float Height; // Hauteur du plan\n};\n\nstruct Disc {\n    vec3 Center;\n    vec3 Normal;\n    //Les deux rayons sont là parce que c'était un anneau à la base\n    float InnerRadius; // Ajout du rayon intérieur\n    float OuterRadius; // Ajout du rayon extérieur\n};\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\n////////////////////////////////////////////\n        // Fonctions de création//\n////////////////////////////////////////////  \n\nDisc disc(in vec3 center, in vec3 normal, in float innerRadius, in float outerRadius) {\n    Disc D;\n    D.Center = center;\n    D.Normal = normalize(normal);\n    D.InnerRadius = innerRadius;\n    D.OuterRadius = outerRadius;\n    return D;\n}\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    C.Obs = Obs;\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(vec3(0, 0, 1), C.View));\n    C.Up = normalize(cross(C.View, C.Horiz));\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H/2.0/tan(aperture * 3.1415 / 180.0 /2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = C.z*C.View + (XY.x - C.W/2.0)*C.Horiz + (XY.y - C.H/2.0)*C.Up;\n   return r;\n}\n\n////////////////////////////////////////////\n      // Fonctions d'intersections//\n//////////////////////////////////////////// \n\n// Fonction pour tester l'intersection entre un rayon et une sphère\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    // Coefficients du polynôme quadratique d'intersection rayon-sphère\n    float a = dot(R.Dir, R.Dir);\n    float b = 2.0 * dot(R.Dir, (R.Origin - S.Center));\n    float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R * S.R;\n\n    // Calcul du discriminant pour déterminer le nombre de solutions\n    float delta = b * b - 4.0 * a * c;\n\n    // Vérification si des solutions réelles existent (delta > 0)\n    if (delta > 0.0) {\n        // Calcul de la première solution (plus proche du point d'origine du rayon)\n        t = (-b - sqrt(delta)) / (2.0 * a);\n    }\n    // Renvoie true si des solutions réelles existent, sinon false\n    return delta > 0.0;\n}\n\n// Fonction pour tester l'intersection entre un rayon et un cube\nbool intersect_cube(in Ray R, in Cube C, out float t) {\n\n    // Calcul des valeurs tmin et tmax pour chaque composante\n    vec3 tmin = (C.Min - R.Origin) / R.Dir;\n    vec3 tmax = (C.Max - R.Origin) / R.Dir;\n\n    // Calcul des valeurs t1 et t2 en utilisant min et max pour chaque composante\n    vec3 t1 = min(tmin, tmax);\n    vec3 t2 = max(tmin, tmax);\n\n    // Calcul des distances le long du rayon pour l'entrée et la sortie du cube\n    float t_near = max(max(t1.x, t1.y), t1.z);\n    float t_far = min(min(t2.x, t2.y), t2.z);\n\n    // Vérification si le point d'entrée est après le point de sortie, ou si le point de sortie est négatif\n    if (t_near > t_far || t_far < 0.0) {\n        // Aucune intersection valide, renvoie false\n        return false;\n    }\n\n    // Mise à jour de la variable t avec la distance du point d'entrée\n    t = t_near;\n\n    // Renvoie true pour indiquer une intersection valide\n    return true;\n}\n\n\n// Fonction pour tester l'intersection entre un rayon et une demi-sphère\nbool intersect_half_sphere(in Ray R, in HalfSphere HS, out float t) {\n    // Vecteur du centre de la demi-sphère à l'origine du rayon\n    vec3 center_to_origin = R.Origin - HS.Center;\n\n    // Coefficients du polynôme quadratique d'intersection rayon-demi-sphère\n    float a = dot(R.Dir, R.Dir);\n    float b = 2.0 * dot(R.Dir, center_to_origin);\n    float c = dot(center_to_origin, center_to_origin) - HS.Radius * HS.Radius;\n\n    // Calcul du discriminant pour déterminer le nombre de solutions\n    float discriminant = b * b - 4.0 * a * c;\n\n    // Vérification si des solutions réelles existent (discriminant >= 0)\n    if (discriminant >= 0.0) {\n        // Calcul des deux solutions possibles\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Vérification si l'une des solutions est positive\n        if (t1 >= 0.0 || t2 >= 0.0) {\n            // Sélection de la plus petite valeur positive\n            t = min(t1, t2);\n\n            // Calcul du point d'intersection\n            vec3 intersection_point = R.Origin + t * R.Dir;\n\n            // Calcul de la normale à la demi-sphère au point d'intersection\n            vec3 normal = normalize(intersection_point - HS.Center);\n\n            // Vérification de l'orientation de la normale par rapport à la normale spécifiée\n            if (dot(normal, HS.Normal) > 0.0) {\n                // Intersection valide si la normale est orientée correctement\n                return true;\n            }\n        }\n    }\n    // Aucune intersection valide trouvée, renvoie false\n    return false;\n}\n\n\n// Fonction pour tester l'intersection entre un rayon et un plan avec des dimensions\nbool intersect_plane(in Ray R, in Plane P, out float t) {\n    // Calcul du produit scalaire entre la normale du plan et la direction du rayon\n    float denom = dot(P.Normal, R.Dir);\n\n    // Vérification si le dénominateur n'est pas proche de zéro\n    if (abs(denom) > 0.0001) {\n        // Calcul de la distance d'intersection le long du rayon\n        t = (P.D - dot(P.Normal, R.Origin)) / denom;\n\n        // Calcul du point d'intersection\n        vec3 intersection_point = R.Origin + t * R.Dir;\n\n        // Demi-largeur et demi-hauteur du plan\n        float half_width = P.Width / 2.0;\n        float half_height = P.Height / 2.0;\n\n        // Vérification si le point d'intersection est à l'intérieur des dimensions du plan\n        if (abs(intersection_point.x) <= half_width && abs(intersection_point.y) <= half_height) {\n            // Intersection valide si à l'intérieur des dimensions du plan et si la distance est positive\n            return t >= 0.0;\n        }\n    }\n\n    // Aucune intersection valide trouvée, renvoie false\n    return false;\n}\n\n// Fonction pour tester l'intersection entre un rayon et un disque\nbool intersect_disc(in Ray R, in Disc D, out float t) {\n    // Calcul du produit scalaire entre la normale du disque et la direction du rayon\n    float denom = dot(D.Normal, R.Dir);\n\n    // Vérification si le dénominateur n'est pas proche de zéro\n    if (abs(denom) > 1e-6) {\n        // Calcul de la distance d'intersection le long du rayon\n        t = dot(D.Center - R.Origin, D.Normal) / denom;\n\n        // Calcul du point d'intersection\n        vec3 p = R.Origin + t * R.Dir;\n\n        // Vecteur entre le centre du disque et le point d'intersection\n        vec3 v = p - D.Center;\n\n        // Calcul de la distance entre le centre du disque et le point d'intersection\n        float distance = length(v);\n\n        // Vérification si le point d'intersection est à l'intérieur des rayons du disque\n        return (distance >= D.InnerRadius) && (distance <= D.OuterRadius) && (t >= 0.0);\n    }\n\n    // Aucune intersection valide trouvée, renvoie false\n    return false;\n}\n\n// Fonction pour tester l'intersection entre un rayon et un cylindre\nbool intersect_cylinder(in Ray R, in Cylinder C, out float t) {\n    // Vecteur du centre du cylindre à l'origine du rayon\n    vec3 OC = R.Origin - C.Center;\n\n    // Coefficients du polynôme quadratique d'intersection rayon-cylindre\n    float A = dot(R.Dir - dot(R.Dir, C.Axis) * C.Axis, R.Dir - dot(R.Dir, C.Axis) * C.Axis);\n    float B = 2.0 * dot(R.Dir - dot(R.Dir, C.Axis) * C.Axis, OC - dot(OC, C.Axis) * C.Axis);\n    float C2 = dot(OC - dot(OC, C.Axis) * C.Axis, OC - dot(OC, C.Axis) * C.Axis) - C.Radius * C.Radius;\n\n    // Calcul du discriminant pour déterminer le nombre de solutions\n    float discriminant = B * B - 4.0 * A * C2;\n\n    // Vérification si des solutions réelles existent (discriminant >= 0)\n    if (discriminant < 0.0) {\n        // Aucune intersection valide trouvée, renvoie false\n        return false;\n    }\n\n    // Calcul des deux solutions possibles\n    float t1 = (-B - sqrt(discriminant)) / (2.0 * A);\n    float t2 = (-B + sqrt(discriminant)) / (2.0 * A);\n\n    // Calcul des points d'intersection\n    vec3 p1 = R.Origin + t1 * R.Dir;\n    vec3 p2 = R.Origin + t2 * R.Dir;\n\n    // Calcul des hauteurs correspondantes sur l'axe du cylindre\n    float h1 = dot(p1 - C.Center, C.Axis);\n    float h2 = dot(p2 - C.Center, C.Axis);\n\n    // Vérification des solutions positives et des hauteurs dans la plage du cylindre\n    if (t1 > 0.0 && h1 >= 0.0 && h1 <= C.Height) {\n        // Sélection de la première solution valide\n        t = t1;\n        return true;\n    }\n\n    if (t2 > 0.0 && h2 >= 0.0 && h2 <= C.Height) {\n        // Sélection de la deuxième solution valide\n        t = t2;\n        return true;\n    }\n\n    // Aucune intersection valide trouvée, renvoie false\n    return false;\n}\n\n\n////////////////////////////////////////////\n     // Gestion de la lumière //\n//////////////////////////////////////////// \n\nfloat lighting(vec3 p, vec3 n, vec3 light) {\n    vec3 light_dir = normalize(light - p);\n    float coef = dot(n, light_dir);\n    return coef;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n \n   //Initialisation des différents éléments\n       Sphere s1 = Sphere(vec3(0.0, 0.0, 0.8), 0.7); //sphère centrale de l'ovni\n       Camera C = camera(vec3(5.0, 2.0, 1.5),vec3(0.5, 0.5, 0.5),50.0); \n   \n   //matrice de rotation de la caméra + gestion de sa rotation\n       float angle = iTime * 0.2;\n       C.Obs = mat3(\n            cos(angle), -sin(angle), 0.0,\n            sin(angle), cos(angle), 0.0,\n            0.0, 0.0, 1.0\n            ) * C.Obs;\n    \n        C.View = normalize(vec3(0.5, 0.5, 0.5) - C.Obs);\n        C.Horiz = normalize(cross(vec3(0, 0, 1), C.View));\n        C.Up = normalize(cross(C.View, C.Horiz));\n        C.H = iResolution.y;\n        C.W = iResolution.x;\n        C.z = C.H/2.0/tan(50.0 * 3.1415 / 180.0 /2.0);   \n   \n   //Gestion de la texture du fond\n       // Calcul des coordonnées de texture\n       vec2 texCoords = fragCoord / iResolution.xy;\n       // Échantillonnage de la couleur de la texture\n       vec4 texColor = texture(iChannel0, texCoords/0.5);\n       vec3 col = texColor.rgb;\n   \n   //Création du rayon en rapport avec la caméra\n       Ray r = launch(C, fragCoord);\n   \n   //Création du cylindre du rayon tracteur\n       Cylinder cyl = Cylinder(vec3(0.0, 0.0, -1.0), normalize(vec3(0.0, 0.0, 20.0)), 0.5, 2.0);\n    \n   //Création de la demi-sphère verte sous l'ovni\n       HalfSphere half_sphere = HalfSphere(vec3(0.0, 0.0, 0.8), 0.72, vec3(0.0, 0.0, -1.0));\n       \n   //Création du disque de l'ovni\n       Disc disc = disc(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.0, 1.0), 0.6, 1.6); \n   \n   //Création de la position de la lumière du soleil\n       vec3 light = vec3(5.0, 2.0, 6.0);\n   \n   //Création du plan représentant le sol de la planète\n       Plane ground_plane;\n       ground_plane.Normal = vec3(0.0, 0.0, 1.0);  // Plan horizontal\n       ground_plane.D = -1.0;  // Réglage de la hauteur du plan\n       ground_plane.Width = 10.0;  // Largeur du plan\n       ground_plane.Height = 10.0;  // Hauteur du plan\n\n    //Création du cylindre du vaisseau\n    Cylinder cylShip = Cylinder(vec3(0.0, 0.0, 1.1), normalize(vec3(0.0, 0.0, 1.0)), 0.3, 0.6);\n\n    //Création de la demi-sphère bleue en haut du vaisseau\n    HalfSphere half_sphereShip = HalfSphere(vec3(0.0, 0.0, 1.7), 0.30, vec3(0.0, 0.0, 1.0));\n\n    //Création du parallélépipède présent sur la structure de l'ovni. Il s'appelle Factory car comme dit dans le rapport, ca aurait dû être une des structures présentes au sol de la planète\n    Cube factory = Cube(vec3(-0.8, -0.8, 0.8), vec3(0.8, 0.8, 0.95)); // Définissez les coins du cube\n    \n    //Création du centre du rayon tracteur\n    Cube cube = Cube(vec3(0.1, 0.1, -2.0), vec3(-0.1, -0.1, 1.0)); \n    \n    //////////////////////////////////////\n    //Rendering des éléments de la scène//\n    //////////////////////////////////////\n    \n    //Rendering de la sphère principale de l'ovni\n       float t = 1e30;\n       float t1;\n       if (intersect_sphere(r, s1, t1) && t1 < t)\n       {\n           t = t1;\n           vec3 p = r.Origin + t1*r.Dir;\n           vec3 n = normalize(p - s1.Center);\n           float coef = lighting(p, n, light);\n           vec3 shadow_ray_dir = normalize(light - p);\n           float t_shadow;\n           bool isShadowed = false;\n           if (intersect_disc(Ray(p, shadow_ray_dir), disc, t_shadow) && t_shadow > 0.0) \n           {\n                isShadowed = true;\n           }\n            if (isShadowed) \n            {\n                col = vec3(0.0, 0.0, 0.0); \n            }else \n            {\n            col = coef * vec3(1.0, 1.0, 1.0);  \n            }\n        }\n    \n       //Rendering du cylindre du vaisseau\n   \n       float t_cylShip;\n        if (intersect_cylinder(r, cylShip, t_cylShip) && t_cylShip < t) {\n            t = t_cylShip;\n            vec3 p = r.Origin + t_cylShip*r.Dir;\n            vec3 n = normalize(p - cylShip.Center);\n            float coef = lighting(p, n, light);\n            col = coef*vec3(1.0, 1.0, 1.0); \n        }\n        \n       //Rendering de la demi-sphère bleue du vaisseau\n        \n        float t_half_sphereShip;\n        if (intersect_half_sphere(r, half_sphereShip, t_half_sphereShip) && t_half_sphereShip < t) \n        {\n           t = t_half_sphereShip;\n           vec3 p = r.Origin + t_half_sphereShip*r.Dir;\n           vec3 n = normalize(p - half_sphereShip.Center);\n           float coef = lighting(p, n, light);\n           col =  coef*vec3(0.2, 0.2, 1.0); \n        }   \n       \n       \n       //Rendering des sphères lévitant dans le rayon tracteur\n       \n        Sphere Levitation1 = Sphere(vec3(0.0, 0.0, -0.1+cos(iTime*0.4)), 0.4); //Sphère minerai\n        //Sphères particules verte\n        Sphere Levitation2 = Sphere(vec3(0.3, 0.0, -0.1+cos(iTime)), 0.02);\n        Sphere Levitation3 = Sphere(vec3(-0.3, 0.0, -0.1+cos(iTime*0.8)), 0.02);\n        Sphere Levitation4 = Sphere(vec3(0.3, 0.3, -0.1+cos(iTime)*0.7), 0.02);\n        Sphere Levitation5 = Sphere(vec3(-0.5, 0.0, -0.1+cos(iTime*0.6)), 0.02);\n        Sphere Levitation6 = Sphere(vec3(0.3, -0.3, -0.1+cos(iTime)*0.5), 0.02);\n        Sphere Levitation7 = Sphere(vec3(-0.4, 0.5, -0.1+cos(iTime*0.4)), 0.02);\n        Sphere Levitation8 = Sphere(vec3(-0.1, 0.5, -0.1+cos(iTime*0.4)), 0.02);\n        Sphere Levitation9 = Sphere(vec3(-0.4, 0.5, -0.2+cos(iTime*0.4)), 0.02);\n        Sphere Levitation10 = Sphere(vec3(-0.2, 0.4, -0.1+cos(iTime*0.6)), 0.02);\n        Sphere Levitation11= Sphere(vec3(0.4, 0.2, -0.1+cos(iTime*0.7)), 0.02);\n        Sphere Levitation12= Sphere(vec3(0.4, -0.5, -0.1+cos(iTime*0.8)), 0.02);\n        Sphere Levitations[12];\n    \n        Levitations[0] = Levitation1;\n        Levitations[1] = Levitation2;\n        Levitations[2] = Levitation3;\n        Levitations[3] = Levitation4;\n        Levitations[4] = Levitation5;\n        Levitations[5] = Levitation6;\n        Levitations[6] = Levitation7;\n        Levitations[7] = Levitation8;\n        Levitations[8] = Levitation9;\n        Levitations[9] = Levitation10;\n        Levitations[10] = Levitation11;\n        Levitations[11] = Levitation12;\n    \n        for (int i = 0; i< 13; i++) \n        {\n            if (intersect_sphere(r, Levitations[i], t1) && t1 < t) \n            {\n               t = t1;\n               vec3 p = r.Origin + t1*r.Dir;\n               vec3 n = normalize(p - Levitations[i].Center);\n               float coef = lighting(p, n, light);\n               vec3 shadow_ray_dir = normalize(light - p);\n               float t_shadow;\n\n               //Gestion de la texture de la sphère minerai\n               vec2 LSphereTexCoords;\n               LSphereTexCoords.x = 0.5 + atan(p.y - Levitations[i].Center.y, p.x - Levitations[i].Center.x) / (2.0 * 3.1415);\n               LSphereTexCoords.y = 0.5 - asin(p.z - Levitations[i].Center.z) / 3.1415;\n               vec4 LSphereTexColor = texture(iChannel1, LSphereTexCoords);\n       \n               if (i == 0) //si sphère minerai\n               {\n                   col = coef * LSphereTexColor.rgb + lighting(p, n, half_sphere.Center)*vec3(0.0,1.0,0.0);  \n               }\n               else\n               {\n                   col = vec3(0.0,1.0,0.0);\n               }\n            }\n        }\n    \n    \n    //Rendering du disque\n        float t_disc;\n        if (intersect_disc(r, disc, t_disc) && t_disc < t) \n        {\n        t = t_disc;\n        vec3 p = r.Origin + t_disc * r.Dir;\n        vec3 n = normalize(disc.Normal);\n\n        // Vérification si la caméra regarde la face arrière du disque\n        if (dot(n, r.Dir) > 0.0) {\n            // La caméra regarde la face arrière du disque, donc ombragez-la\n            col = vec3(0.0, 0.0, 0.0); // Par exemple, une couleur d'ombre grise\n        } \n        else \n        {\n            // La caméra regarde la face avant du disque, calcul de l'éclairage normal\n            vec3 shadow_ray_dirDisc = normalize(light - p);\n            float t_shadowDisc;\n            if (intersect_sphere(Ray(p, shadow_ray_dirDisc), s1, t_shadowDisc) && t_shadowDisc > t_disc) \n            {\n                col = vec3(0.0, 0.0, 0.0);\n            } else \n            {\n                float coef = lighting(p, n, light);\n                col = coef * vec3(0.7, 0.7, 0.7); // Couleur du disque\n            }\n        }\n    }\n    \n    \n    //Gestion de demi-sphères minerais\n    //Pas très esthétique mais fonctionne et compile en peu de seconde\n    //Complexifier cela pourrait rendre la compilation très longue\n        HalfSphere half_Ground1 = HalfSphere(vec3(4.0, 0.0, -1.2), 0.9, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground2 = HalfSphere(vec3(-4.5, 1.0, -1.2), 0.4, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground3 = HalfSphere(vec3(-2.5, 1.5, -1.2), 0.6, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground4 = HalfSphere(vec3(2.5, 3.0, -1.2), 0.4, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground5 = HalfSphere(vec3(-4.0, 2.5, -1.2), 0.8, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground6 = HalfSphere(vec3(-2.5, 3.5, -1.2), 0.5, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground7 = HalfSphere(vec3(2.5, -2.5, -1.2), 0.9, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground8 = HalfSphere(vec3(-4.5, 3.5, -1.2), 0.4, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground9 = HalfSphere(vec3(-2.5, 2.5, -1.2), 0.3, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground10 = HalfSphere(vec3(0.0, 1.5, -1.2), 0.5, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground11 = HalfSphere(vec3(0.0, -2.5, -1.2), 0.6, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground12 = HalfSphere(vec3(2.5, -2.5, -1.2), 0.35, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground13 = HalfSphere(vec3(3.0, -2.5, -1.2), 0.41, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground14 = HalfSphere(vec3(-3.5, -3.5, -1.2), 0.8, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground15 = HalfSphere(vec3(4.0, -2.5, -1.2), 0.6, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground16 = HalfSphere(vec3(-0.8, -1.2, -1.2), 0.4, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground17 = HalfSphere(vec3(0.4, -1.2, -1.2), 0.6, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground18 = HalfSphere(vec3(0.5, -0.5, -1.2), 0.4, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground19 = HalfSphere(vec3(4.0, -0.5, -1.2), 0.2, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground20 = HalfSphere(vec3(1.0, -3.5, -1.2), 0.3, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground21 = HalfSphere(vec3(-3.0, -1.5, -1.2), 0.6, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground22 = HalfSphere(vec3(2.5, 2.8, -1.2), 0.9, vec3(0.0, 0.0, 1.0));\n        HalfSphere half_Ground23 = HalfSphere(vec3(-4.0, -2.5, -1.2), 0.6, vec3(0.0, 0.0, 1.0));\n        HalfSphere Ground[23];\n    \n        Ground[0] = half_Ground1;\n        Ground[1] = half_Ground2;\n        Ground[2] = half_Ground3;\n        Ground[3] = half_Ground4;\n        Ground[4] = half_Ground5;\n        Ground[5] = half_Ground6;\n        Ground[6] = half_Ground7;\n        Ground[7] = half_Ground8;\n        Ground[8] = half_Ground9;\n        Ground[9] = half_Ground10;\n        Ground[10] = half_Ground11;\n        Ground[11] = half_Ground12;\n        Ground[12] = half_Ground13;\n        Ground[13] = half_Ground14;\n        Ground[14] = half_Ground15;\n        Ground[15] = half_Ground23;\n        Ground[16] = half_Ground16;\n        Ground[17] = half_Ground17;\n        Ground[18] = half_Ground18;\n        Ground[19] = half_Ground19;\n        Ground[20] = half_Ground20;\n        Ground[21] = half_Ground21;\n        Ground[22] = half_Ground22;\n\n        for (int i = 0; i< 23; i++) \n        {\n            float t_half_spheresGround;\n            if (intersect_half_sphere(r, Ground[i], t_half_spheresGround) && t_half_spheresGround < t) \n            {\n               t = t_half_spheresGround;\n               vec3 p = r.Origin + t_half_spheresGround*r.Dir;\n               vec3 n = normalize(p - Ground[i].Center);\n               float coef = lighting(p, n, light);\n               \n               //gestion de la texture\n               vec2 LSphereTexCoords;\n               LSphereTexCoords.x = 0.5 + atan(p.y - Ground[i].Center.y, p.x - Ground[i].Center.x) / (2.0 * 3.1415);\n               LSphereTexCoords.y = 0.5 - asin(p.z - Ground[i].Center.z) / 3.1415;\n               vec4 LSphereTexColor = texture(iChannel1, LSphereTexCoords);\n           \n               col =  coef*LSphereTexColor.rgb + lighting(p, n, half_sphere.Center)*vec3(0.0,1.0,0.0); \n            }\n        }\n    \n    \n    //Rendering du parallélépipède au centre de l'ovni\n        float t_facto;\n        if (intersect_cube(r, factory, t_facto) && t_facto < t) \n        {\n            t = t_facto;\n            vec3 p = r.Origin + t_facto * r.Dir;\n            vec3 n = normalize(p - (factory.Min + factory.Max) * 0.5); \n            // Vous pouvez ajouter ici la couleur du cube ou tout autre effet que vous souhaitez.\n            float coef = lighting(p, n, light);\n            col = coef*vec3(1.0,1.0,1.0) ;\n        }\n\n  \n    //Rendering du plan\n        float t3;\n        if (intersect_plane(r, ground_plane, t3) && t3 < t) \n        {\n            vec3 p = r.Origin + t3 * r.Dir;\n            vec3 n = ground_plane.Normal;\n            vec3 shadow_ray_dirGround = normalize(light - p);\n            float coef = lighting(p, n, light);\n            float t_shadowGround;\n        \n            //Vérification pour les ombres sur le plan\n            bool isShadowed = false;\n            if (intersect_sphere(Ray(p, shadow_ray_dirGround), s1, t_shadowGround) && t_shadowGround > 0.0) {\n                isShadowed = true;\n            } else if (intersect_disc(Ray(p, shadow_ray_dirGround), disc, t_shadowGround) && t_shadowGround > 0.0) {\n                isShadowed = true;}\n            else if (intersect_sphere(Ray(p, shadow_ray_dirGround), Levitation1, t_shadowGround) && t_shadowGround > 0.0) {\n                isShadowed = true;\n            }\n            else if (intersect_cube(Ray(p, shadow_ray_dirGround), cube, t_shadowGround) && t_shadowGround > 0.0) {\n                isShadowed = true;\n            }\n        \n            if (isShadowed) {\n                col = vec3(0.0, 0.0, 0.0) + lighting(p, n, half_sphere.Center)*vec3(0.0,1.0,0.0); \n            }else {\n            col = coef * vec3(0.0, 0.0, 0.3) + lighting(p, n, half_sphere.Center)*vec3(0.0,1.0,0.0);  \n            }\n            t = t3;\n        }\n    \n    //Rendering de la demi-sphère verte sous l'ovni\n        float t_half_sphere;\n        if (intersect_half_sphere(r, half_sphere, t_half_sphere) && t_half_sphere < t) \n        {\n           col =  vec3(0.0, 1.0, 0.0);\n        }\n        \n   //Rendering du centre du rayon tracteur \n        float t_cube;\n        if (intersect_cube(r, cube, t_cube) && t_cube < t) \n        {\n            t = t_cube;\n            vec3 p = r.Origin + t_cube * r.Dir;\n            vec3 n = normalize(p - (cube.Min + cube.Max) * 0.5);\n            col = mix(col, vec3(1.0, 1.0, 0.0), 0.5);\n        }\n\n    //Rendering du cylindre du rayon\n        float t_cyl;\n        if (intersect_cylinder(r, cyl, t_cyl) && t_cyl < t) \n        {\n            t = t_cyl;\n            float alpha = 0.3;\n            col = mix(col, vec3(0.0, 1.0, 0.0), alpha);\n        }\n \n \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}