{"ver":"0.1","info":{"id":"wtfSRl","date":"1563882249","viewed":315,"name":"Shine a light","username":"2017301580082","description":"Let's shake it!\nWith the change of the music frequency,not only the shape of some balls will change,but also the light will vibrate with the music.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","ball","volumelight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// Constants.\n//============================================================================\n\n\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nconst int NUM_LIGHTS = 10;\nconst int NUM_MATERIALS = 6;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 17;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.0, 0.0, 0.0 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst float EXPOSURE = 12.0;\nconst float OMNI_LIGHT = 0.1;\nconst float FLOOR_REFLECTION = 0.15;\n\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = 2.0 * PI;\nconst float BIG = 1e30;\nconst float EPSILON = 1e-10;\nconst float THETA = (1.0 + 2.2360679775) / 2.0;\nconst float INV_THETA = 1.0 / THETA;\nstruct Intersection\n{\n    float dist;\n    vec3 normal;\n};\n\nstruct Result\n{\n    Intersection start;\n    Intersection end;\n};\n    \nstruct Range\n{\n\tfloat start;\n    float end;\n};\nmat4 rotateX(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateZ(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat tt;\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n    vec3 d;\n    vec3 c;\n    float a;\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene(in vec2 fragCoord)\n{\n    \n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// first texture row is frequency data\n\tfloat f  = texture( iChannel0, vec2(uv.x,0.25) ).x; \n    float ft  = texture( iChannel0, vec2(0.25,0.25) ).x; \n\n    \n    // Horizontal plane.\n\tPlane[0].A = 0.0;\n\tPlane[0].B = 1.0;\n\tPlane[0].C = 0.0;\n\tPlane[0].D = 0.0;\n\tPlane[0].materialID = 4;\n    \n    //  plane.\n\tPlane[1].A = 1.0;\n\tPlane[1].B = 0.0;\n\tPlane[1].C = 0.0;\n\tPlane[1].D = 8.0;\n\tPlane[1].materialID = 0;\n    \n    \n\n\n\t// Sphere 1\n\tSphere[0].center = vec3(-4.0*sin(1.5*iTime), abs(1.5*sin(iTime))+0.5 , -4.0*cos(1.5*iTime));\n\tSphere[0].radius = 0.2;\n\tSphere[0].materialID = 2;\n\n\t// Sphere 2\n\tSphere[1].center = vec3(2.8, abs(2.0*sin(ft ))-0.35 , 0.0);\n\tSphere[1].radius = 0.35;\n\tSphere[1].materialID = 1;\n\n\t// Sphere 3\n\tSphere[2].center = vec3(-4.0*sin(1.5*iTime + 2.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 2.0*3.1415926535 / 8.0)) + 0.5, -4.0*cos(1.5*iTime + 2.0*3.1415926535 / 8.0));\n\tSphere[2].radius = 0.2;\n\tSphere[2].materialID = 2;\n\n\t// Sphere 4.\n\tSphere[3].center = vec3(2.0, abs(2.0*sin( f )) - 0.35, 2.0);\n\tSphere[3].radius = 0.35;\n\tSphere[3].materialID = 1;\n\n\t// Sphere 5\n\tSphere[4].center = vec3(-4.0*sin(1.5*iTime + 4.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 4.0*3.1415926535 / 8.0)) + 0.5, -4.0*cos(1.5*iTime + 4.0*3.1415926535 / 8.0));\n\tSphere[4].radius = 0.2;\n\tSphere[4].materialID = 2;\n\n\t// Sphere 6\n\tSphere[5].center = vec3(0.0, abs(2.0*sin(ft)) - 0.35, 2.8);\n\tSphere[5].radius = 0.35;\n\tSphere[5].materialID = 1;\n\n\t// Sphere 7\n\tSphere[6].center = vec3(-4.0*sin(1.5*iTime + 6.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 6.0*3.1415926535 / 8.0)) + 0.5, -4.0*cos(1.5*iTime + 6.0*3.1415926535 / 8.0));\n\tSphere[6].radius = 0.2;\n\tSphere[6].materialID = 2;\n\n\t// Sphere 8\n\tSphere[7].center = vec3(-2.0, abs(2.0*sin(f )) - 0.35, 2.0);\n\tSphere[7].radius = 0.35;\n\tSphere[7].materialID = 1;\n\n\t// Sphere 9.\n\tSphere[8].center = vec3(4.0*sin(1.5*iTime), abs(1.5*sin(2.0*iTime)) + 0.5, 4.0*cos(1.5*iTime));\n\tSphere[8].radius = 0.2;\n\tSphere[8].materialID = 2;\n\n\t// Sphere 10\n\tSphere[9].center = vec3(-2.8, abs(2.0*sin(ft )) - 0.35, 0.0);\n\tSphere[9].radius = 0.35;\n\tSphere[9].materialID =1;\n\n\t// Sphere 11\n\tSphere[10].center = vec3(4.0*sin(1.5*iTime + 2.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 2.0*3.1415926535 / 8.0)) + 0.5, 4.0*cos(1.5*iTime + 2.0*3.1415926535 / 8.0));\n\tSphere[10].radius = 0.2;\n\tSphere[10].materialID = 2;\n\n\t// Sphere 12\n\tSphere[11].center = vec3(-2.0, abs(2.0*sin(f )) - 0.35, -2.0);\n\tSphere[11].radius = 0.35;\n\tSphere[11].materialID = 1;\n\n\t// Sphere 13\n\tSphere[12].center = vec3(4.0*sin(1.5*iTime + 4.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 4.0*3.1415926535 / 8.0)) + 0.5, 4.0*cos(1.5*iTime + 4.0*3.1415926535 / 8.0));\n\tSphere[12].radius = 0.2;\n\tSphere[12].materialID = 2;\n\n\t// Sphere 14\n\tSphere[13].center = vec3(-0.0, abs(2.0*sin(ft )) -0.35, -2.8);\n\tSphere[13].radius = 0.35;\n\tSphere[13].materialID = 1;\n\n\t// Sphere 15\n\tSphere[14].center = vec3(4.0*sin(1.5*iTime + 6.0*3.1415926535 / 8.0), abs(1.5*sin(2.0*iTime + 6.0*3.1415926535 / 8.0)) + 0.5, 4.0*cos(1.5*iTime + 6.0*3.1415926535 / 8.0));\n\tSphere[14].radius = 0.2;\n\tSphere[14].materialID = 2;\n\n\t// Sphere 16\n\tSphere[15].center = vec3(2.0, abs(2.0*sin(f)) -0.35, -2.0);\n\tSphere[15].radius = 0.35;\n\tSphere[15].materialID = 1;\n\n\t// Sphere 17\n\tSphere[16].center = vec3(0.0, abs(1.0*sin(iTime))+1.5, 0.0);\n\tSphere[16].radius = 0.8*sin(f*iTime) + 0.5;\n\tSphere[16].materialID = 3;\n\n\n\n\n\t// Silver material.\n\tMaterial[0].k_d = vec3(0.5, 0.5, 0.5);\n\tMaterial[0].k_a = 0.2 * Material[0].k_d;\n\tMaterial[0].k_r = 2.0 * Material[0].k_d;\n\tMaterial[0].k_rg = 0.5 * Material[0].k_r;\n\tMaterial[0].n = 64.0;\n\n\t// Random material.\n\tMaterial[1].k_d = vec3(0.90,0.83,0.37 );\n\tMaterial[1].k_a = 0.2 * Material[1].k_d;\n\tMaterial[1].k_r = 2.0 * Material[1].k_d;\n\tMaterial[1].k_rg = 0.5 * Material[1].k_r;\n\tMaterial[1].n = 64.0;\n\n\t// Random material.\n\tMaterial[2].k_d = vec3(0.5*abs(sin(0.125*iTime)), abs(sin(0.25*iTime + 1.0)), abs(sin(0.25*iTime + 2.0)));\n\tMaterial[2].k_a = 0.2 * Material[2].k_d;\n\tMaterial[2].k_r = vec3(1.0, 1.0, 1.0);\n\tMaterial[2].k_rg = 0.5 * Material[2].k_r;\n\tMaterial[2].n = 128.0;\n\n\t// Random material.\n\tMaterial[3].k_d = vec3(0.6*abs(sin(0.5*iTime)), abs(sin(0.5*iTime + 3.0)), abs(sin(0.5*iTime + 5.0)));\n\tMaterial[3].k_a = 0.2 * Material[2].k_d;\n\tMaterial[3].k_r = vec3(1.0, 1.0, 1.0);\n\tMaterial[3].k_rg = 0.5 * Material[2].k_r;\n\tMaterial[3].n = 128.0;\n    \n    //  material.\n\tMaterial[4].k_d = vec3(0.5, 0.5, 0.5);\n\tMaterial[4].k_a = 0.2 * Material[0].k_d;\n\tMaterial[4].k_r = 2.0 * Material[0].k_d;\n\tMaterial[4].k_rg = 0.5 * Material[0].k_r;\n\tMaterial[4].n = 64.0;\n  \n\n    // Light 0.\n    Light[0].position = vec3( 2.0*sin(iTime), 15.0, 2.0*cos(iTime)-2.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    \n\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n\tmat4 TT=mat4(\n\t\t1.0,0,0,-sph.center.x,\n\t\t0,1,0,-sph.center.y,\n\t\t0,0,1,-sph.center.z,\n\t\t0,0,0,1);\n\tmat4 T=transpose(TT);\n\n\tray.o=vec3(T*vec4(ray.o,1.0));\n\n\n    float a = dot( ray.d, ray.d );\n    float b = 2.0*dot( ray.d, ray.o );\n    float c = dot( ray.o, ray.o )-sph.radius*sph.radius;\n    float d = b*b-4.0*a*c;\n\n    if ( d<0.0 ) return false;\n    \n    float t1 = (-b+sqrt(d) ) / (2.0*a);\n\tfloat t2 = (-b-sqrt(d) ) / (2.0*a);\n    \n\n\t// We have a hit -- output results.\n\n\tif((t1 >= tmin && t1 <= tmax))\n\t{\n\t   if((t2 >= tmin && t2 <= tmax)) t=min(t1,t2);\n\t   else  t=t1;\n\t}\n\telse  t=t2;\n    \n\t\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize( hitPos );\t\n\thitPos=vec3(inverse(T)*vec4(hitPos,1.0));\n\n    if ( (t1 >= tmin && t1 <= tmax) || (t2 >= tmin && t2 <= tmax) ) return true;\n    return false;  \n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n     \n    \n\tmat4 TT=mat4(\n\t\t1.0,0,0,-sph.center.x,\n\t\t0,1,0,-sph.center.y,\n\t\t0,0,1,-sph.center.z,\n\t\t0,0,0,1);\n\n\tmat4 T=transpose(TT);\n    ray.o=vec3(T*vec4(ray.o,1.0));\n\n    float a = dot( ray.d, ray.d );\n    float b = 2.0*dot( ray.d, ray.o );\n    float c = dot( ray.o, ray.o )-sph.radius*sph.radius;\n\tfloat d = b*b-4.0*a*c;\n\n    float t1 = (-b+sqrt(d) ) / (2.0*a);\n\tfloat t2 = (-b-sqrt(d) ) / (2.0*a);\n\n\n    if ( (t1 >= tmin && t1 <= tmax) || (t2 >= tmin && t2 <= tmax) ) return true;\n    return false;  \n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for(int i=0;i<NUM_PLANES;i++)\n    {\n        temp_hasHit=false;\n        temp_hasHit=IntersectPlane(Plane[i],ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if((temp_t<nearest_t) && temp_hasHit)\n        {\n            hasHitSomething = true;\n            nearest_t=temp_t;\n\t\t\ttt=temp_t;\n            nearest_hitNormal=temp_hitNormal;\n            nearest_hitPos=temp_hitPos;\n            nearest_hitMatID=Plane[i].materialID;\n        }\n    }\n    for(int i=0;i<NUM_SPHERES;i++)\n    {\n        temp_hasHit=false;\n\n        temp_hasHit=IntersectSphere(Sphere[i],ray, DEFAULT_TMIN , DEFAULT_TMAX , temp_t , temp_hitPos , temp_hitNormal);\n        if((temp_t<nearest_t) && temp_hasHit)\n        {\n            hasHitSomething = true;\n            nearest_t=temp_t;\n\t\t\ttt=temp_t;\n            nearest_hitNormal=temp_hitNormal;\n            nearest_hitPos=temp_hitPos;\n            nearest_hitMatID=Sphere[i].materialID;\n        }\n\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\tbool k_shadow=false;\n    Ray_t shadowray;\n\t//vec3 I_local=vec3(0.0);\n    \n\tfor(int j=0;j<NUM_LIGHTS;j++)\n\t{\n        shadowray.o=nearest_hitPos;\n\t\tshadowray.d=normalize((Light[j].position-nearest_hitPos));\n\t\tk_shadow=false;\n        \n        for(int i=0;i<NUM_SPHERES;i++)\n\t\t{\n            if(k_shadow)break;\n\n\t\t\tk_shadow=IntersectSphere(Sphere[i],shadowray, DEFAULT_TMIN , distance(nearest_hitPos, Light[j].position));\n\t\t}\n        if(!k_shadow)\n\t\tfor(int i=0;i<NUM_PLANES;i++)\n\t\t{\n             if(k_shadow)break;\n\n\t\t\tk_shadow=IntersectPlane(Plane[i],shadowray, DEFAULT_TMIN , distance(nearest_hitPos, Light[j].position));\n\t\t}\n\n        vec3 L=shadowray.d;\n\t\tvec3 N=normalize(nearest_hitNormal);\n\t\tvec3 V=nearest_hitPos;\n\t\tI_local+=PhongLighting(  L,  N\t,  -normalize(ray.d), k_shadow, \n        \t\tMaterial[nearest_hitMatID],Light[j] );\n\t\n\t}\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat insideCone(vec3 direction, float angle, vec3 o)\n{\n    float oz = dot(o, direction);\n    vec3 oxy = o - direction * oz;\n    float c = dot(oxy, oxy) / (angle * angle) - (oz * oz);\n    return smoothstep(20.0, -50.0, c);\n}\n\nRange cone(vec3 direction, float angle, Ray_t ray)\n{\n    float dz = dot(ray.d, direction);\n    float oz = dot(ray.o, direction);\n    vec3 dxy = ray.d - direction * dz;\n    vec3 oxy = ray.o - direction * oz;\n    \n    float a = dot(dxy, dxy) - (dz * dz * angle * angle);\n    float b = dot(dxy, oxy) - (dz * oz * angle * angle);\n    float c = dot(oxy, oxy) - (oz * oz * angle * angle);\n    \n    float p = 2.0 * b / a;\n    float q = c / a;\n    \n    float r = p * p / 4.0 - q;\n    \n    Range result;\n    result.start = BIG;\n    result.end = -BIG;\n    \n    if (r >= 0.0)\n    {\n        float m = -p / 2.0;\n        float sr = sqrt(r);\n            \n        if (c < 0.0)\n        {\n\t\t\t// Inside\n            if (m + sr < 0.0)\n            {\n                // Both solutions behind us\n                result.start = 0.0;\n                result.end = BIG;\n            }\n            else if (m - sr < 0.0)\n            {\n                // One solution behind us\n                result.start = 0.0;\n                result.end = m + sr;\n            }\n            else\n            {\n                // Both solutions ahead\n                result.start = 0.0;\n            \tresult.end = m - sr;\n            }\n        }\n        else\n        {\n            // Outside\n            if (m + sr < 0.0)\n            {\n                // Both solutions behind us\n                return result;\n            }\n            else if (m - sr < 0.0)\n            {\n                // One solution behind us\n                result.start = m + sr;\n                result.end = BIG;\n            }\n            else\n            {\n                // Both solutions ahead\n                result.start = m - sr;\n            \tresult.end = m + sr;\n            }\n        }\n    }\n    \n    return result;\n}\n\nResult plane(vec3 pos, vec3 normal, Ray_t ray)\n{\n    ray.o -= pos;\n    \n    float rdn = dot(ray.d, normal);\n    float ron = dot(ray.o, normal);\n    \n    Result result;\n    result.start.normal = normal;\n    result.end.normal = normal;\n    \n    if (ron > 0.0)\n    {\n        // Outside\n        result.start.dist = BIG;\n        result.end.dist = -BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n            else\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n        }\n    }\n    else\n    {\n        // Inside\n        result.start.dist = -BIG;\n        result.end.dist = BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n            else\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n        }\n    }\n    return result;\n}\n\nfloat inverseSquare(vec3 p)\n{\n    return 1.0 / dot(p, p);\n}\n\nfloat inverseSquareAntiderivative(Ray_t ray, float t)\n{\n    vec3 o = ray.o;\n    vec3 d = ray.d;\n    \n    // Shoutout to Wolfram Alpha\n    float a = t * dot(d, d) + dot(d, o);\n    float b1 = d.x * d.x * dot(o.yz, o.yz);\n    float b2 = 2.0 * d.x * o.x * dot(o.yz, d.yz);\n    float b3 = o.x * o.x * dot(d.yz, d.yz);\n    float b4 = (o.y * d.z - d.y * o.z) * (o.y * d.z - d.y * o.z);\n    float b = sqrt(b1 - b2 + b3 + b4);\n    return atan(a / b) / b;\n}\n\nfloat inverseSquareIntegral(Ray_t ray, float start, float end)\n{\n    return inverseSquareAntiderivative(ray, end) - inverseSquareAntiderivative(ray, start);\n}\n\nvec3 getLight(vec3 pos)\n{\n    vec3 color = vec3(inverseSquare(pos) * OMNI_LIGHT * 2.0);\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        color += Light[i].c * inverseSquare(pos) * insideCone(Light[i].d, Light[i].a, pos);\n    }\n    return color;\n}\n\nvec3 renderVolumetric(Ray_t ray, float maxDist)\n{\n    vec3 color = vec3(inverseSquareIntegral(ray, 0.0, maxDist) * OMNI_LIGHT);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        Range r = cone(Light[i].d, Light[i].a, ray);\n        r.end = min(r.end, maxDist);\n        \n        if (r.end > r.start)\n        {\n            float boost = mix(1.0, 18.0, insideCone(Light[i].d, Light[i].a, ray.o));\n            \n            color += inverseSquareIntegral(ray, r.start, r.end) * Light[i].c * boost;\n        }\n    }\n    \n    return color;\n}\n\nvec3 floorTexture(vec3 pos)\n{\n    pos.z += pos.x * 0.25;\n    return fract(pos.x * 0.1) > fract(pos.z * 0.1) ? vec3(1.0) : vec3(0.7);\n}\n\nfloat floorGloss(vec3 pos)\n{\n    pos.x += pos.z * 2.0;\n    return texture(iChannel1, pos.xz * 0.2).x * 0.5 + 0.75;\n}\n\nvec3 renderScene(Ray_t ray)\n{\n    Result r = plane(vec3(0.0, -18.0, 0.0), vec3(0.0, 1.0, 0.0), ray);\n    \n    if (r.start.dist > 0.0 && r.start.dist < r.end.dist)\n    {\n        vec3 pos = ray.o + ray.d * r.start.dist;\n        \n        Ray_t reflectedRay;\n        reflectedRay.o = pos;\n        reflectedRay.d = ray.d * vec3(1, -1, 1);\n        \n        vec3 volumetric = renderVolumetric(ray, r.start.dist);\n        vec3 reflectedVolumetric = renderVolumetric(reflectedRay, BIG);\n        \n        vec3 color = -normalize(pos).y * getLight(pos) * 30.0 * floorTexture(pos);\n        float gloss = floorGloss(pos);\n        \n        return volumetric + mix(color, reflectedVolumetric, FLOOR_REFLECTION * gloss);\n    }\n    else\n    {\n    \treturn renderVolumetric(ray, BIG);\n    }\n}\n\nvec3 toneMap(vec3 color)\n{\n    return 1.0 - exp(-color * EXPOSURE);\n}\n\nvoid setUpLights()\n{\n    mat4 m = rotateX(TAU * iTime * 0.05) * rotateY(TAU * iTime * 0.09);\n    \n    Light[0].d = normalize(m * vec4(1, 1, 1, 0)).xyz;\n    Light[1].d = normalize(m * m * vec4(1, 1, -1, 0)).xyz;\n    Light[2].d = normalize(m * vec4(1, -1, 1, 0)).xyz;\n    Light[3].d = normalize(m * m * vec4(1, -1, -1, 0)).xyz;\n    Light[4].d = normalize(m * vec4(0, INV_THETA, THETA, 0)).xyz;\n    Light[5].d = normalize(m * m * vec4(0, INV_THETA, -THETA, 0)).xyz;\n    Light[6].d = normalize(m * vec4(INV_THETA, THETA, 0, 0)).xyz;\n    Light[7].d = normalize(m * m * vec4(INV_THETA, -THETA, 0, 0)).xyz;\n    Light[8].d = normalize(m * vec4(THETA, 0, INV_THETA, 0)).xyz;\n    Light[9].d = normalize(m * m * vec4(-THETA, 0, INV_THETA, 0)).xyz;\n    \n    Light[0].c = normalize(vec3(1, 1, 1) * 0.5 + 0.7);\n    Light[1].c = normalize(vec3(1, 1, -1) * 0.5 + 1.0);\n    //Light[2].c = normalize(vec3(1, -1, 1) * 0.5 + 3.0);\n    Light[3].c = normalize(vec3(1, -1, -1) * 0.5 + 3.0);\n    Light[4].c = normalize(vec3(0, INV_THETA, THETA) * 0.5 + 1.0);\n    //Light[5].c = normalize(vec3(0, INV_THETA, THETA) * 0.7 + 0.8);\n    Light[6].c = normalize(vec3(INV_THETA, THETA, 0) * 0.5 + 0.7);\n    //Light[7].c = normalize(vec3(2.0, 1, 0.5) * 0.5 + 0.5);\n    Light[8].c = normalize(vec3(0.3, 0.9, 0.9) * 0.5 + 0.3 );\n    /*Light[9].c = normalize(vec3(-THETA, 0, INV_THETA) * 0.5 + 1.0);*/\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n       Light[i].a = texture(iChannel0, vec2(float(i) * 0.18, 0.0)).x * 0.3 + 0.05;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    v=v*0.003;\n    \n    InitScene (fragCoord);\n    \n    Material[4].k_d = v;\n    \n     \n\t//////////////////////////////////////////////////////////////////////\n\tsetUpLights();\n    \n    \n   \n\t//////////////////////////////////////////////////////////////////////\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Position the camera.\n    vec3 cam_pos = vec3( 7.5*sin(0.25*iTime), 2.0+sin(0.25*iTime),7.5*cos(0.25*iTime)) ;\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay,Ray;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\tRay.o = vec3(sin(iTime * 0.5) * 5.0, -12.5 + sin(iTime * 0.6) * 2.5, -25.0);\n   \tRay.d = normalize(vec4((fragCoord.xy - iResolution.xy * 0.5) / iResolution.y, 0.7, 0.0)).xyz;\n\t\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\t\t \n        I_result += compounded_k_rg * I_local;\n\t\t\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\tvec3 color = renderScene(Ray);\n    color = toneMap(color);\n\n\tfragColor = vec4(color, 1.0);\n    fragColor += vec4( I_result, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}