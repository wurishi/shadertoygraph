{"ver":"0.1","info":{"id":"dtK3Ww","date":"1684189049","viewed":149,"name":"Jellyfish around glass Remix4","username":"DENFOR","description":"2023.05.16   ad(glass  font  another Jellyfish )        delete box(line 485 vec3(   )*0.\n      Jelly stop (line263 vec3(x *0.,y,z*0. ) ?  camera fixed(line739, line740    => *0. )","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" // https://www.shadertoy.com/view/ttdSWN\n  /*\n    Jellyfish | Creature in Future\n  - Created by SEN ZHENG - 2020/02/08\n  -\n  - 元·宵·快·乐\n*/\n\n#define PI 3.14159265359\n\nstruct Hit {\n    float d;\n    vec2 uv;\n    vec3 col;\n    float ref;\n    float spe;\n    float rough;\n    float lightD;\n    vec3 lightCol;\n    float lightStrength;\n\tfloat sss;\n    float diffuseTex;\n};\n    \nvec2 rotate(vec2 v, float a) {\n    return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\n#define ENABLE_REFRACTION 0\n#define MAX_RAYMARCHING_COUNT 100\n#define PRECISION 0.005\n#define FAR 12.\n#define mouse (iMouse.xy / iResolution.xy)\n#define time (iTime + 4.4)\n\nvec3 ro, rd;\n\n//----------------------------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n//----------------------------------------------------\n\n// The Noise function and SDF functions below are from iq's blog.\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    float res = mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n    return res;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 pa, vec3 ba, float ba2, float r )\n{\n    float h = clamp( dot(pa,ba)/ba2, 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//----------------------------------------------------\n\n// SDF operation functions for Hit struction\n\nHit mixHit(Hit h1, Hit h2, float dres) {\n    float factor = (dres - h1.d)/(h2.d - h1.d);\n    return Hit(dres, \n               mix(h1.uv, h2.uv, factor),\n               mix(h1.col, h2.col, factor),\n               mix(h1.ref, h2.ref, factor),\n               mix(h1.spe, h2.spe, factor),\n               mix(h1.rough, h2.rough, factor),\n               mix(h1.lightD, h2.lightD, factor),\n               mix(h1.lightCol, h2.lightCol, factor),\n               mix(h1.lightStrength, h2.lightStrength, factor),\n               mix(h1.sss, h2.sss, factor),\n               mix(h1.diffuseTex, h2.diffuseTex, factor)\n               );\n}\n\nHit opUnion(Hit h1, Hit h2) {\n\tfloat dres = opUnion(h1.d, h2.d);\n    return mixHit(h1, h2, dres);\n}\n\nHit opSubtraction(Hit h1, Hit h2) {\n\tfloat dres = opSubtraction(h1.d, h2.d);\n    return mixHit(h1, h2, dres);\n}\n\nHit opSmoothUnion(Hit h1, Hit h2, float k) {\n\tfloat dres = opSmoothUnion(h1.d, h2.d, k);\n    return mixHit(h1, h2, dres);\n}\n\nHit opSmoothSubtraction(Hit h1, Hit h2, float k) {\n\tfloat dres = opSmoothSubtraction(h1.d, h2.d, k);\n    return mixHit(h1, h2, dres);\n}\n\n\n//----------------------------------------------------\n\n// circleClone: Clone object by dividing the space into [num] parts according to the angle\n// It is very useful and performance-saving.\n\nvec3 circleClone( vec3 p, float num, out float id ) {\n    vec3 pp = p;\n    float angleArea = PI * 2.0 / num;\n    float originangle = atan( pp.x, pp.z );\n    float angle = mod( originangle, angleArea ) - angleArea * 0.5;\n    id = floor(originangle / angleArea);\n    \n    float shake = cos( pp.y * 2.0 + time * 2.0 + id) * 0.2;\n    pp.xz += normalize( pp.xz ) * shake * smoothstep( -0.3, -1.0, pp.y );\n    float len = length( pp.xz );\n    \n    vec3 modPos = vec3( cos( angle ) * len, p.y, sin( angle ) * len );\n    return modPos;\n}\n\n\n//----------------------------------------------------\n\n// jerryfish: Jerryfish sdf function\n\nHit jerryfish( vec3 p ) {\n     p -=vec3(2.*cos(iTime*0.1),0.,2.*sin(iTime*0.1)) ;\n     \n    vec3 backupPos = p;\n    float shake = sin( p.y * 2.0 + time * 3.6 ) * 0.2;\n    p.xz += normalize( p.xz )*shake;\n\n    float radius = 1.5;\n    \n    // Main Hat\n    vec3 _NoiseScale = vec3( 8.0, 0.2, 8.0 );\n    _NoiseScale.xz -= smoothstep( 0.2, -radius, p.y ) * 3.0;\n    float _NoiseAmp = 0.4 * smoothstep( 0.6, -radius * 0.3, p.y ) * smoothstep(-0.4, 0.2, shake);\n    float n = noise( normalize( p ) * _NoiseScale + time * 0.5 );\n    float d = length( p * vec3( 1.0, 1.4*0.75, 1.0 )) - radius;   // de(1.,1.4,1.)\n    d = max( d, -sdBox( p + vec3( 0.0, 1.0, 0.0 ), vec3( 100.0, 0.5, 100.0 ) ) );\n //   d = opSmoothSubtraction(length( p * vec3( 1.0, 1.4, 1.0 )) - radius * 0.85, d, 0.1);\n    \n    d += n * _NoiseAmp;\n  //  d *= 0.7;\n    \n    // Tentacles \n    float id;\n    vec3 modPos = circleClone( p, 120.0, id );\n    float tentaclesRadius = 0.015 + sin( id ) * 0.008;\n    float tentaclesLength = -4.0 - cos( id ) * 1.0;\n    d = opSmoothUnion( d, 0.5 * sdCapsule( modPos, vec3( radius - 0.25, 0.0, 0.0 ), vec3( radius - 0.25, tentaclesLength, 0.0 ), tentaclesRadius ), 0.1 );\n\n    // Inner Center\n    vec3 pic = circleClone(p, 10.0, id);\n    float adjustFactor = 1.0 + abs(sin(pic.y * 12.0)) * 0.25;\n    adjustFactor += noise(pic * 10.0) * 0.5;\n    float dic = 0.5 * sdCapsule( pic, vec3(0.55, 0.0, 0.0), vec3(0.55, -2.2, 0.0), 0.1 * adjustFactor * smoothstep(-2.2, -1.0, pic.y));\n\n    // Different Material Info\n    float originD = d;\n    d = min( d, dic );\n    \n    float factor = (d - originD)/(dic - originD);\n    float limitHead = smoothstep(-radius*0.7*0.5, radius*0.8, backupPos.y);\n    \n    vec3 col0 = mix(vec3(0.37, 0.73, 0.88), vec3(0.117, 0.145, 0.317), limitHead);\n    vec3 col1 = mix(vec3(0.89*cos(iTime*0.2), 0.31, 0.145), vec3(0.8, 0.31, 0.5*(1.+sin(iTime*0.1))), smoothstep(-1.0, 0.0, backupPos.y));\n    vec3 col = mix(col0, col1, factor);\n    \n    // Dot Light\n    vec3 nor = normalize(p);\n    float a = acos(abs(nor.y) / 1.0);\n    vec2 uv = mod(p.xz * a * 6.0*(0.6+0.5*cos(iTime*0.2 )), vec2(1.0*1.4)) - 0.5*1.4;\n    float dotScale = 15.0 / (0.1 + length(p.xz * a * 6.0));\n    float dotLight = smoothstep(0.08 * dotScale, 0.07 * dotScale, length(uv));\n    dotLight *= (0.6 + 0.4 * sin(p.x * 10.0 + time * 5.6));\n    dotLight *= smoothstep( 0.0, 0.2, p.y );\n                                                        // loop move=>  stop vec3(x*0.,y,z*0. )\n    return Hit( d, vec2( 0.0 ), col, 0.7, 1.0, 0.0, d, vec3(1.0*(0.6 +0.65*cos(iTime*0.2)*0. ),0.2,1.193*cos(iTime*0.1)*0.), dotLight, 0.4, 1.0 );\n}\n\n//----------------------------------------------------\n\n// bubbles: Bubbles sdf function\n\nHit bubbles( vec3 p ) {\n    vec3 backupPos = p;\n    float density = 0.5;\n    p.xz = mod( p.xz, vec2( density, density ) ) - vec2( density * 0.5, density * 0.5 );\n    float id = sin(floor( backupPos.x / density )) + cos(floor( backupPos.z / density ));\n    id *= 10.0;\n    float factor = smoothstep(1.8, 0.0, backupPos.y);\n    float radius = 0.02 + sin( id ) * 0.01;\n    float speed = 2.5 - sin( id ) * 0.5;\n    p.y = mod( p.y + cos( id ) * 10.0 - speed * time, 6.8) - 5.0;\n    p.xz += vec2( cos( time * 2.0 ), sin( time * 2.0 ) ) * sin( id ) * density * 0.2;\n    float d = sdSphere( p, radius );\n    d = opIntersection( d, sdBox( backupPos + vec3( 0.0, 1.6, 0.0 ), vec3( 1.8, 3.4, 1.8 ) ) );\n    return Hit( d, vec2( 0.0 ), vec3(1.0), 1.0, 1.0, 0.0, d, vec3(1.0, 1.05, 1.1), 0.3, 0.0, 0.0 );\n}\n\n//----------------------------------------------------\n\n// Ray-Box intersection\n// https://iquilezles.org/articles/boxfunctions\nvoid iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out vec4 nearInfo, out vec4 farInfo ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) {\n        nearInfo = vec4(9999.0);\n        farInfo = vec4(9999.0);\n        return;\n    }\n\n\tvec3 norN = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\tvec3 norF = -sign(rdd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n\n    // convert to ray space\n\t\n\tnorN = (txi * vec4(norN,0.0)).xyz;\n\tnorF = (txi * vec4(norF,0.0)).xyz;\n    \n    nearInfo = vec4(tN, norN);\n    farInfo = vec4(tF, norF);\n\n}\n\nHit map2(vec3 p) {\n    Hit res = jerryfish(p);\n    res = opUnion(res, bubbles(p));\n    return res;\n}\n\nvec3 calcuNormal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n    return normalize(e.yxx*map2(p + e.yxx).d + e.xxy*map2(p + e.xxy).d + \n                     e.xyx*map2(p + e.xyx).d + e.yyy*map2(p + e.yyy).d );   \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map2( ro + rd*t ).d;\n        res = min( res, 5.0*h/t );\n        t += clamp( h, 0.02, 0.2 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map2( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcThickness( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = -map2( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 getBgCol(vec3 ray) {\n    return vec3(0.05);\n}\n\nvec4 shading(vec3 sp, Hit hitdata, vec3 bgCol, float t) {\n    vec3 col = vec3(0.0);\n\t\n    // Light source\n    vec3 lp = vec3(0.0, 0.25, 0.0);\n    vec3 lCol = vec3(0.98, 0.76, 0.58) * (7.0 + sin(time * 3.6) * 4.0);\n    vec3 sundir = lp - sp;\n    float distToLight = length(sundir);\n    vec3 ld = normalize(sundir);\n    \n    vec3 nor = normalize( calcuNormal( sp ) );\n    float shd = calcSoftshadow( sp, ld, 0.02, FAR );\n    float occ = calcAO( sp, nor );\n    float thickness = calcThickness( sp-nor*0.01, ld);\n    float fresnel = 0.0 + 1.0 * pow( 1.0 - max( dot( -rd, nor ), 0.0), 2.0);\n\n    vec3 hal = normalize( lp - rd );\n    float amb = clamp( 0.3 + 0.7 * nor.y, 0.0, 1.0 );\n    float dif = max( dot( ld, nor ), 0.0);\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 12.0);\n    float bac = clamp( dot( nor, normalize(vec3(lp.x,-lp.y,lp.z))), 0.0, 1.0 );\n\n    // surface color\n    float spot = tex3D(iChannel0, sp, nor).r;\n    col = mix(hitdata.col, vec3(0.4, 0.35 ,0.2), spot * hitdata.diffuseTex);\n    thickness *= spot;\n\n    // Light Falloff\n    lCol *= 1.0 / distToLight;\n\n    vec3 lin = lCol * dif * shd;\n    lin += hitdata.spe * spe * lCol * shd;\n    lin += 0.3 * amb * vec3(1.0);\n    lin += 0.3 * bac * vec3(1.0);\n    col *= lin * occ;\n\n    // Fake SSS\n    float sss = (1.0 - thickness) * hitdata.sss / (0.0001 + pow(distToLight, 2.0));\n    vec3 colWithSSS = mix(col, lCol*hitdata.col, sss);\n    col = colWithSSS;\n\n    // Limit Head Area\n    float limitHead = smoothstep( -0.5, 0.0, sp.y );\n\n    // reflect\n    vec3 r = reflect(rd, nor);\n    col += texture( iChannel1, r ).xyz * hitdata.ref * fresnel * limitHead;\n\n    // Outline Glow\n    vec3 outlineCol = vec3(1.5, 1.1, 1.0) * 2.0;\n    col += pow(fresnel, 5.0) * limitHead * outlineCol;\n    \n    // Emission\n    vec3 emission = hitdata.lightCol * hitdata.lightStrength;\n    col += emission;\n    \n    // Caustics\n    mat3 m1 = mat3(-2.,-1.,2., 3.,-2.,1., 1.,2.,2.);\n    vec3 a1 = vec3( sp.xz * 200. / 4e2, time / 8. ) * m1;\n    vec3 b1 = a1 * m1 * .4;\n    vec3 c1 = b1 * m1 * .3;\n    vec4 k = vec4(pow(\n        min( min( length(.5 - fract( a1 )), \n      \t\t\tlength(.5 - fract(b1))), \n          length(.5 - fract(c1))), \n        8.) * 20.) ;\n    col += k.rgb * vec3(1.05, 1.0, 1.1) * limitHead;\n\n    //col = vec3(sss);\n\n    //col = mix(col, bgCol, smoothstep(0.5, FAR, t));\n    \n    \n    return vec4(col, hitdata.lightStrength);\n}\n\nvec4 render(vec3 ro, vec3 rd) {\n    Hit hitdata;\n    float t = 0.0;\n    float told = t, d;\n    \n    vec4 col = vec4(0.0);\n    vec3 bgCol = getBgCol(rd);\n    float fresnel = 1.0;\n    int isHit = 0;\n    \n    float prec = PRECISION;\n    \n    // Get Front Box Hitdata\n    // Translate box\t\n\tmat4 tra = translate( 0.0, -1.6, 0.0 );\n\tmat4 txi = tra; \n\tmat4 txx = translate( 0.0, 1.6, 0.0 );\n    vec3 nearPoint, nearNor;\n    vec4 nearInfo, farInfo;                        // box delete\n    vec3 box = vec3(1.8, 3.4, 1.8)*(0.6+0.585*sin(iTime*0.2))*0.;      // box size change\n    \n  //  if( mod(iTime,25.)<15. ){\n\tiBox( ro, rd, txx, txi, box, nearInfo, farInfo);  //} //delete iBox()\n    \n    nearPoint = ro + rd * nearInfo.x;\n    nearNor = nearInfo.yzw;\n    \n    if(nearInfo.x < FAR) {\n        // Dirty glass\n        vec3 nor = nearNor;\n        vec3 sc = tex3D(iChannel2, nearPoint*0.5, nor).rgb;\n        col.rgb = texture( iChannel1, reflect(rd, nor) ).xyz;\n        float lCol = ( sin( time * 3.6 ) * 0.5 + 0.5) * 2.0;\n        col.rgb = mix(col.rgb, vec3( max( 0.0, dot( -nor, normalize(-nearPoint) ) ) ) * lCol, 0.2);\n        col.rgb *= vec3(1.0, 1.1, 1.2);\n        float baseF = 0.1 + sc.r * 0.9;\n        fresnel = baseF + (1.0 - baseF) * pow( 1.0 - max( dot( -rd, nor ), 0.0), 2.2);\n        fresnel = smoothstep(0.3, 0.8, fresnel);\n        \n        // Simple HUD\n        vec2 uv;\n        if (nor.x != 0.0) uv = nearPoint.yz;\n       if (nor.y != 0.0) uv = nearPoint.xz;\n        if (nor.z != 0.0) uv = nearPoint.xy;\n        vec2 uv1 = uv * 5.0;\n        float id = sin(floor(uv1.x) * 10.0) + cos(floor(uv1.y) * 10.0);\n        id = sin( id * 10.0 + time * 3.6 );\n        uv1 = mod(uv1, vec2(1.0));\n        \n        float distToBox = length(ro - nearPoint);\n        float lineWidth = mix(0.01, 0.04,  distToBox / 6.0);\n        // Grid\n        float grid = smoothstep(0.97 - lineWidth , 1.0 - lineWidth , max(uv1.x, uv1.y)) * 0.5;\n        // Random Center Dot\n        grid = max( grid, smoothstep( lineWidth * 2.5, lineWidth * 2.5 - 0.01, length(uv1 - vec2(0.5))) * smoothstep(0.5, 1.0, id) );\n        // Active Grid | Filled\n        // grid += smoothstep(0.5, 1.0, id) * 0.3;\n        // Scan Anim\n        grid = max(0.0, min(1.0, grid * sin( time * 1.8 + nearPoint.y * 1.0 ) ) );\n        \n    //    col.rgb += grid * vec3(0.8, 0.9, 1.2);\n        fresnel *= (1.0 - grid);\n        \n        // Reset ro and rd\n        ro = nearPoint;\n        rd = refract(rd, nor, 0.659);\n        \n    } else {\n        col.rgb = bgCol;\n    }\n    \n    \n    for (int i = 0 ; i < MAX_RAYMARCHING_COUNT ; i++) {\n        \n        vec3 sp = ro + rd*t;\n        hitdata = map2(sp);\n        d = hitdata.d;\n        \n        \n        if (d < prec) {\n            vec4 shadingCol = shading( sp, hitdata, bgCol, t );\n            col = mix( col, shadingCol, fresnel );\n        \tvec3 nor = normalize( calcuNormal( sp ) );\n            \n            break;\n            \n        } else if ( t >= FAR || i+1 == MAX_RAYMARCHING_COUNT) {\n            // Get Back Box Hitdata\n            vec3 farPoint, farNor;\n            vec4 nearInfo, farInfo;\n            iBox( ro - rd, rd, txx, txi, box, nearInfo, farInfo);\n            farPoint = ro + rd * farInfo.x;\n            farNor = farInfo.yzw;\n            if(farInfo.x < FAR) {\n                ro = farPoint;\n                vec3 nor = -farNor;\n                vec3 refrCol = texture( iChannel1, refract(rd, nor, 1.52) ).xyz;\n                vec3 reflCol = texture( iChannel1, reflect(rd, nor) ).xyz;\n        \t\tfloat f = pow( 1.0 - max( dot( -rd, nor ), 0.0), 2.2);\n                vec3 shadingCol = mix(refrCol, reflCol, f);\n            \tcol.rgb = mix( col.rgb, shadingCol*0., fresnel );\n                \n            } else {\n            \tcol.rgb = mix( col.rgb, getBgCol(rd), fresnel );\n            }\n            \n            break;\n        }\n        \n        told = t;\n        t += d;\n        t = min(FAR, t);\n    }\n    \n    //col.rgb = pow(col.rgb, vec3(1.2));\n    \n    return col;\n}\n\nmat3 setCamera(vec3 ro, vec3 lookAt, vec3 cp) {\n    vec3 cw = normalize(lookAt-ro);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n////////////////////////////////////////////Font Data Start\nint _= 32; \nint _0 = 48;\nint _1 = 49;\nint\t_2 = 50;\nint\t_3 = 51;\nint\t_4 = 52;\nint _5 = 53;\nint _6 = 54;\nint _7 = 55;\nint _8 = 56;\nint _9 = 57;\nint _A = 65;\nint _B = 66;\nint _C = 67;\nint _D = 68;\nint _E = 69;\nint _F = 70;\nint _G = 71;\nint _H = 72;\nint _I = 73;\nint _J = 74;\nint _K = 75;\nint _L = 76;\nint _M = 77;\nint _N = 78;\nint _O = 79;\nint _P = 80;\nint _Q = 81;\nint _R = 82;\nint _S = 83;\nint _T = 84;\nint _U = 85;\nint _V = 65;\nint _W = 66;\nint _X = 67;\nint _Y = 68;\nint _Z = 69;\nint _a = 97;\nint _b = 98;\nint _c = 99;\nint _d = 100;\nint _e = 101;\nint _f = 102;\nint _g = 103;\nint _h = 104;\nint _i = 105;\nint _j = 106;\nint _k = 107;\nint _l = 108;\nint _m = 109;\nint _n = 110;\nint _o = 111;\nint _p = 112;\nint _q = 113;\nint _r = 114;\nint _s = 115;\nint _t = 116;\nint _u = 117;\nint _v = 118;\nint _w = 119;\nint _x = 120;\nint _y = 121;\nint _z = 122;\n\n/*\nascii table:\nhttp://www.theasciicode.com.ar/american-standard-code-information-interchange/ascii-codes-table.png\n*/\n\n\n\n\n// char size 64*64   16 char per row\nvoid WriteChar(vec2 screenCoord, vec2 pos, float charValue, float fontSize, vec4 fontColor, inout vec4 pixel)\n{\n  if (screenCoord.x >=pos.x && screenCoord.x <=pos.x+fontSize && screenCoord.y >=pos.y && screenCoord.y <=pos.y+fontSize)\n  {\n      // calculate texture grab position of character\n      float col = mod(charValue,16.0);\n      vec2 charPos = vec2(col,(charValue-col)/16.0);\n      charPos *= 64.0;\n      \n      vec2 dist = screenCoord-pos;\n\n      vec2 steps = (vec2(1.0,-1.0) / iChannelResolution[0].xy);\n      vec2 startOffset = charPos *steps;\n      \n      // scale texture uv step by fontSize\n      steps*=(1.0/(fontSize/64.0));\n      dist *=steps;\n      vec4 c = texture(iChannel3,startOffset+dist);\n\n      // Check if texture is a part of the character\n      if(c.r>0.6)\n      {\n        pixel=mix(pixel,fontColor, fontColor.w);\n      }      \n  }\n}\n\n/////////////////////////////////////////// Jellyfish Remix DATA\n#define round(x) floor((x) + 0.5)\n\n//const float PI = 3.141592653589793;\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s*0.9);\n}\n\nvoid twigl(out vec4 o, vec4 FC, vec2 r, float t) {\n    o=vec4(0);\n    float e=0.,g=0.,s;  \n    for(float i=0.;i<2e2;i++){           // g scale factor \n                                               // vec2(x,y)offset //e; z axis position\n        vec3 p=vec3((FC.xy-r*.5)/r.y*0.75 /**g */+vec2( 1.,0.00) ,g+=e);\n        p.y-=t*.05;   // y axis move(up)\n          p.x-=t*0.01 ; p.z -=0.1*t*0. ; // x,z axis move\n          \n         p -=round(p) ; \n    //   p.y-=round(p.y);  p.x -=round(p.x) ;/* p.z -=round(p.z);*/\n        \n        \n        p.xz*=1.+sin(t*PI+(round(g)*0.+p.y)*9.)*.2;\n        e=s=9.*1.;\n        for(int j=0;j<6;j++){\n          //  e=s/2e6+min(e,max(-p.y,abs(length(p)-.2*1.3))/s),p.y+=length(p.xz)*2.,p=.2-abs(p*3.);\n           e=s/2e6+min(e*0.95,max(-p.y,abs(length(p)-.2*1.3))/s) ,\n             p.y+=length(p.xz)*2.,\n           p=.2-abs(p*3.);\n           \n           s+=s;\n        }\n        o.rgb+=hsv(.6+.9/p.y,.9,4e-6/e);\n    }\n}                                      //////Jellyfish Data END\n\n///////////////////////////////////////////////////////// Font Data END\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    float dist = 8.0 + sin(time * 0.4) * 2.0*0.;\n    ro = vec3( sin( time * 0.125*0. + mouse.x * 5.0) * dist, sin( time ) * 0.8 - 0.8-2.*abs(sin(iTime*0.1)) + mouse.y * 5.0, cos( time * 0.125*0. + mouse.x * 5.0 ) * dist);\n    \n    vec3 lookAt = vec3( 0.0, -0.2, 0.0 );\n    vec3 camup = normalize( vec3( sin( time * 0.2 ), 13.0, cos( time * 0.2 )));\n    mat3 viewMat = setCamera( ro, lookAt, camup );\n    rd = viewMat * normalize( vec3( p, 3.0 ) );\n    \n    vec4 col = render( ro, rd );\n    \n    ////////////////////////////////////////////////////// Font Start\n     float frame = radians(iTime)*120.0*0.5 ;  // speed change\n    float cosValue = cos(frame);\n    float sinValue = sin(frame);\n    \n    vec2 screenCoord = vec2(fragCoord.x, iResolution.y-fragCoord.y);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color; \n        \n    // backdrop effect\n    if (mod(screenCoord.x,50.0)+mod(screenCoord.y,50.0) < 50.0)\n    {\n        // color = vec4(0.15);\n    }\n    else\n    {\n       //  color = vec4(0);\n    }\n        \n    // SET TEXT VARIABLES ********************\n    vec2 textPos = vec2(-1150.0+(mod(frame*200.0,2000.0)),40.0+cos(frame+uv.x*5.0)*25.0);\n    float fontSize = 112.0*0.35;\n    float charSpacing = fontSize*0.5;\n    vec4 fontColor = vec4(uv.x,uv.x*4.0, 1.0-uv.x,1.0);\n\n    // write text by storing as an array of ascii values (table above)\n    // A SMALL TEST OF                *************** case (1)\n //   int text[15] = int[](_A,_,_s,_m,_a,_l,_l,_,_T,_E,_S,_T,_,_O,_F);\n    int text[15] = int[](_P,_C,_,_G,_r,_a,_p,_h,_i,_c,_,_C,_l,_u,_b);\n    \n    for(int i=0; i<15; i++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(i)*charSpacing,0.0),float(text[i]),fontSize, fontColor, color);\n    }  \n    \n    \n    \n    // CENTER SCALE TEST      fonts  & **************  case (2)\n /*   textPos = iResolution.xy*0.5;\n    fontSize = 78.0 + (cosValue*32.0);\n    charSpacing = fontSize*0.5;\n    fontColor = vec4(0.5-cosValue*0.5,0.5+cosValue*0.5, uv.x*1.0,1.0);\n    \n    // center text \n    // FONTS &\n    int text2[7] = int[](_f,_o,_n,_t,_s,_,38);\n    textPos.x -= (7.0*charSpacing)*0.5;\n    textPos.y -= fontSize*0.5;\n    \n    for(int i=0; i<7; i++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(i)*charSpacing,0.0),float(text2[i]),fontSize, fontColor, color);\n    }\n  */\n    \n    // NUMBERS AND TRANSPARENCY      # 1234567890   ******** case (3)\n    textPos = vec2(180.0*2.7+cos(frame+uv.x*25.0)*5.0,320.0*1.3+sin(frame+uv.x*25.0)*5.0);\n    fontSize = 76.0*0.4;\n    charSpacing = fontSize*0.5;\n    fontColor = vec4(uv.x*4.0,2.0-uv.x, 2.0*uv.y,0.2);\n    \n    // # 123456789\n  //  int text3[12] = int[](35,_,_1,_2,_3,_4,_5,_6,_7,_8,_9,_0);\n     int text3[19] = int[](35,_,_P,_C,_,_G,_r,_a,_p,_h,_i,_c,_,_C,_l,_u,_b,_,35);\n     \n    for(int i=0; i<19; i++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(i)*charSpacing,0.0),float(text3[i]),fontSize, fontColor, color);\n    }\n    \n   // fragColor = color;\n    \n    \n      \n     ////////////////////////////////////////// jellyfish Remix ad\n       vec4 o =vec4(0); vec4 FC ;  FC.xy = fragCoord ;\n    /* vec3 resolution =iResolution ;*/  float tim =iTime ;\n\n //    twigl(o ,FC, /*iResolution*/resolution.xy, time);\n      twigl(o ,FC, iResolution.xy, tim);\n   //  twigl(o ,FC, iResolution, time);  \n  \n   //  fragColor =vec4( o.rgb, 1.0 ) ;\n      \n      \n    /////////////////////////////////////////////////////// Font END\n    \n    fragColor = col  + color +o ;  // ad font        color\n                                   // ad JellyRemix  o \n   \n    \n}","name":"Image","description":"","type":"image"}]}