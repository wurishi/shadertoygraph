{"ver":"0.1","info":{"id":"wdSfRw","date":"1654869661","viewed":92,"name":"Depth Test 2","username":"JupiterDude","description":"Depth Test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["depth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float stepper(float val, float steps)\n{\n    float v = val * floor(steps);\n    float w = floor(v);\n    w /= floor(steps);\n    return w;\n}\n\nvec2 stepper(vec2 val, float steps)\n{\n    vec2 v = val * floor(steps);\n\tvec2 w = floor(v);\n    w /= floor(steps);\n    return w;\n}\n\n\nfloat timeStepper(float y, float bands, float t)\n{\n    float c = y * bands;\n    c -= t;\n    float d = floor(c) + t;\n    d /= bands;\n    return d;\n}\nvec2 timeStepper(vec2 y, float bands, float t)\n{\n    vec2 c = y * bands;\n    c -= t;\n    vec2 d = floor(c) + t;\n    d /= bands;\n    return d;\n}\n\n\nfloat roller(float z) {\n    return (cos(z * 0.07) * .6 + sin(z*0.03) * .31)*.5;\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat staticy( float size, vec2 p ) {\n    vec2 q = vec2(\n  \t\tfloat( int(p.x/size)),\n        float( int(p.y/size)));\n    return hash(q);\n}\n\nfloat nrand(float z, float a, float b)\n{\n    float r = .5 + .5*sin(a*12323023.0*b*z);\n    return r;\n}\n\nfloat centerDepth(vec2 uv, float depth_of_field, float aspect)\n{\n    vec2 c = uv - vec2(aspect*.5, .5);\n    return length(c) * depth_of_field;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 36.;// + (1. + .5*sin(iTime*4.0)) * 5.0;;\n    //float time_delta_speed = iTime - floor(iTime);\n    //float sspeed = (.5 + .5 * sin(iTime));\n    //float tspeed = stepper(sspeed, 10.0);\n    //speed += tspeed * 1.0;\n    \n    \n    // speed = speed + floor((1. + .5*sin(iTime*4.0)) * 1.0);\n    if (speed > 300.) speed = 300.;\n    float depth_of_field = 20.0;\n    float bands = 22.0;\n    float aspect = iResolution.x / iResolution.y;\n    float max_depth = length(vec2(aspect / 2.0, 0.5));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv - .5;\n    cuv.x *= aspect;\n    \n    cuv.y += (sin(iTime * 6.28 * .1) - cos(iTime * 6.28 * .1)) * .03;\n    cuv.x += (sin(iTime * 6.28 * .1) + cos(iTime * 6.28 * .1)) * .03;\n\n    \n    float depth = 1.0 - max_depth/depth_of_field/(length(cuv));\n    float c = depth; // 1.0 - max_depth/depth_of_field/(length(cuv));\n    \n    float t = iTime / bands;\n    float time_delta = -(speed-(t- floor(t))*speed);\n    \n    \n    float d = timeStepper(c, bands, time_delta) * 1.0;\n    \n    float e = (c - d);\n    e = (e * bands * 2.0);\n    if (e > 1.0) e = 2.0 - e;\n    \n    float f = (e) * (depth);\n    d = f;\n    \n    float dd = (d*2.0);\n    if (dd > 1.0) {\n        // dd = 2.0 - d;\n    }\n    float td = (time_delta);\n    if (td > .5) {\n        // td = 1.0 - td;\n    }\n    \n    float rlim = .5 + .5 * cos((dd - td)  * 1.2);\n    float glim = .5 + .5 * cos((dd - td)  * 3.4);\n    float blim = .5 + .5 * cos((dd - td)  * 5.6);\n    \n    float cr = d * rlim; // (.5 + .5 * cos(d + iTime *depth*1.)) * depth;\n    float cg = d * glim; // (.5 + .5 * cos(d + iTime *depth*2.)) * depth;\n    float cb = d * blim; // (.5 + .5 * cos(d + iTime *depth*4.)) * depth;\n    \n    //if (uv.x > .97 || uv.x < .03 ){\n\t  //  fragColor = vec4( 0.0, 0.0, 1.0, 1.0);\n    //}else{\n    \tfragColor = vec4( cr, cg, cb, 1.0);\n    //}\n}\n","name":"Image","description":"","type":"image"}]}