{"ver":"0.1","info":{"id":"MljcDy","date":"1510076534","viewed":259,"name":"Contour test","username":"pheelicks","description":"Example of calculating contours of a heightfield, showing the artifacts generated when linear texture filtering is used.\n\nExample for https://stackoverflow.com/questions/47165661/artifacts-when-computing-contours-of-a-zoomed-in-texture","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["contour"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TEXTURE_SIZE 512.0\n\nconst vec2 texelSize = vec2( 1.0 / TEXTURE_SIZE, 0.0 );\nvec4 texture_bilinear( const in sampler2D t, in vec2 uv )\n{\n  uv -= 0.5 * texelSize.xx;\n  // Calculate pixels to sample and interpolating factor\n  vec2 f = fract( uv * TEXTURE_SIZE );\n  vec2 uvSnapped = uv - texelSize.xx * f + 0.5 * texelSize.xx;\n\n  // As we are sampling snapped pixels need to override\n  // the mip-map selection by selecting a large negative\n  // bias. Otherwise at boundaries the gradient of\n  // uvSnapped is large and an incorrect mip-level is used\n  // leading to artifacts  \n  float bias = -10.0;\n  vec4 tl = texture(t, uvSnapped, bias);\n  vec4 tr = texture(t, uvSnapped + texelSize, bias);\n  vec4 bl = texture(t, uvSnapped + texelSize.yx, bias);\n  vec4 br = texture(t, uvSnapped + texelSize.xx, bias);\n    \n  vec4 tA = mix( tl, tr, f.x );\n  vec4 tB = mix( bl, br, f.x );\n  return mix( tA, tB, f.y );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.1 + sin(iTime);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = mat2(0.6, 0.4, 0.4, 0.6) * uv;\n    uv = zoom * 0.002 * uv - 0.003 * iMouse.xy / iResolution.xy;\n    \n    // Obtain a height field, both from a standard sampler\n    // as well as implementing bilinear interpolation ourselves\n    float enable = step(0.5 * iResolution.x, fragCoord.x);\n    vec2 grad = vec2(0.004, 0.0);\n    vec4 base = texture(iChannel0, uv);\n\tvec4 base_bilinear = texture_bilinear(iChannel0, uv);\n\tbase = mix(base, base_bilinear, enable);\n    float height = 30.0 * dot(vec3(1.0), base.rgb); \n    \n    // Calculate contours\n    float contourWidth = 0.5;\n    float f = abs( fract( height ) - 0.5 );\n    float df = fwidth( height );\n    float mi = max( 0.0, contourWidth - 1.0 );\n    float ma = max( 1.0 , contourWidth );\n    float contour = clamp( (f - df * mi ) / ( df * ( ma - mi ) ), 0.0, 1.0 );\n    \n    // Display contours\n    fragColor = vec4(contour) * (0.9 + 0.1 * enable);\n}","name":"Image","description":"","type":"image"}]}