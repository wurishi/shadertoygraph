{"ver":"0.1","info":{"id":"mdVXzd","date":"1682774394","viewed":119,"name":"【Sessions 2023】Spawn","username":"ukeyshima","description":"Sessions 2023 GLSL Graphics Compo","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n#define EPS 0.0013\n#define MAX 9999.0\n#define PI 3.14159265359\n#define BPM 50.0\n#define AO_NUM 4.0\n#define MARCHING_NUM 64\n#define CAMERA_DEPTH 1.0\n#define TUNNEL_END vec3(0.0, 0.0, 50.0)\n#define ROOM_POS vec3(0.0, 0.0, 60.0)\n#define FLOOR_CENTER vec3(150.0, 0.0, 0.0)\n#define COLUMN_CENTER vec3(-150.0, 0.0, 0.0)\n\n#define TUNNEL_AREA_MIN vec3(-10.0, -50.0, -10.0)\n#define TUNNEL_AREA_MAX vec3(10.0, 50.0, 50.0)\n#define ROOM_AREA_MIN vec3(-10.0, -50.0, 50.0)\n#define ROOM_AREA_MAX vec3(10.0, 50.0, 70.0)\n#define FLOOR_AREA_MIN vec3(100.0, -100.0, -100.0)\n#define FLOOR_AREA_MAX vec3(200.0, 100.0, 100.0)\n#define COLUMN_AREA_MIN vec3(-200.0, -100.0, -100.0)\n#define COLUMN_AREA_MAX vec3(-100.0, 100.0, 100.0)\n\n#define PHASE0_TIME 0.0\n#define PHASE1_TIME 60.0 / BPM * 4.0 + 60.0 / BPM * 0.5\n#define PHASE2_TIME 60.0 / BPM * 4.0 * 2.0 + 60.0 / BPM * 0.5\n#define PHASE3_TIME 60.0 / BPM * 4.0 * 3.0 + 60.0 / BPM * 0.5\n#define PHASE4_TIME 60.0 / BPM * 4.0 * 6.0 + 60.0 / BPM * 0.5\n#define PHASE5_TIME 60.0 / BPM * 4.0 * 8.0 + 60.0 / BPM * 0.5\n#define PHASE6_TIME 60.0 / BPM * 4.0 * 10.0 + 60.0 / BPM * 0.5\n#define PHASE7_TIME 60.0 / BPM * 4.0 * 15.0 + 60.0 / BPM * 0.5\n#define PHASE8_TIME 120.0\n\n#define PHASE0_POS vec3(0.0)\n#define PHASE1_POS vec3(0.0, 0.0, 60.0)\n#define PHASE2_POS vec3(150.0, 0.0, 0.0)\n#define PHASE3_POS vec3(-158.0, 0.0, -0.5)\n#define PHASE4_POS vec3(0.0)\n#define PHASE5_POS vec3(150.0, 0.0, 0.0)\n#define PHASE6_POS vec3(-160.0, 0.0, 0.0)\n#define PHASE7_POS vec3(0.0, 0.0, 45.0)\n#define PHASE8_POS vec3(0.0, 0.0, 60.0)\n\nstruct surface { float dist; int id; };\n\nfloat Hash(float s) { return fract(sin(12.9898 * s) * 43.54); }\nfloat Noise(float s) { return (mix(Hash(floor(s)),Hash(ceil(s)),smoothstep(0.0, 1.0, fract(s))) * 2.0 - 1.0); }\nmat2 Rotate(float t) { return mat2(cos(t), -sin(t), sin(t), cos(t)); }\n\nfloat randomSeed;\nfloat Random() { return randomSeed = Hash(randomSeed); }\n\nfloat phase1Frag;\nfloat phase2Frag;\nfloat phase3Frag;\nfloat phase4Frag;\nfloat phase5Frag;\nfloat phase6Frag;\nfloat phase7Frag;\nfloat phase8Frag;\n\nfloat Phase1Frag(){ return step(PHASE0_TIME, iTime)  * step(iTime, PHASE1_TIME); }\nfloat Phase2Frag(){ return step(PHASE1_TIME, iTime)  * step(iTime, PHASE2_TIME); }\nfloat Phase3Frag(){ return step(PHASE2_TIME, iTime)  * step(iTime, PHASE3_TIME); }\nfloat Phase4Frag(){ return step(PHASE3_TIME, iTime)  * step(iTime, PHASE4_TIME); }\nfloat Phase5Frag(){ return step(PHASE4_TIME, iTime)  * step(iTime, PHASE5_TIME); }\nfloat Phase6Frag(){ return step(PHASE5_TIME, iTime)  * step(iTime, PHASE6_TIME); }\nfloat Phase7Frag(){ return step(PHASE6_TIME, iTime)  * step(iTime, PHASE7_TIME); }\nfloat Phase8Frag(){ return step(PHASE7_TIME, iTime)  * step(iTime, PHASE8_TIME); }\n\nfloat phaseTime;\nfloat PhaseTime()\n{\n  return phase1Frag * (iTime - PHASE0_TIME) +\n         phase2Frag * (iTime - PHASE1_TIME) + \n         phase3Frag * (iTime - PHASE2_TIME) + \n         phase4Frag * (iTime - PHASE3_TIME) + \n         phase5Frag * (iTime - PHASE4_TIME) + \n         phase6Frag * (iTime - PHASE5_TIME) + \n         phase7Frag * (iTime - PHASE6_TIME) + \n         phase8Frag * (iTime - PHASE7_TIME);\n}\n\nfloat phaseRate;\nfloat PhaseRate()\n{\n  return phaseTime / (phase1Frag * (PHASE1_TIME - PHASE0_TIME) + \n                      phase2Frag * (PHASE2_TIME - PHASE1_TIME) + \n                      phase3Frag * (PHASE3_TIME - PHASE2_TIME) + \n                      phase4Frag * (PHASE4_TIME - PHASE3_TIME) + \n                      phase5Frag * (PHASE5_TIME - PHASE4_TIME) + \n                      phase6Frag * (PHASE6_TIME - PHASE5_TIME) +\n                      phase7Frag * (PHASE7_TIME - PHASE6_TIME) +\n                      phase8Frag * (PHASE8_TIME - PHASE7_TIME));\n}\n\nint scene;\nint Scene()\n{\n  return int(\n         phase1Frag * 2.0 +\n         phase2Frag * 3.0 +\n         phase3Frag * 4.0 +\n         phase4Frag * 1.0 +\n         phase5Frag * 3.0 +\n         phase6Frag * 4.0 +\n         phase7Frag * 2.0 +\n         phase8Frag * 2.0 + 0.1);\n}\n\nfloat beatTime;\nfloat BeatTime()\n{\n    float scaledTime = iTime * BPM / 60.0;\n    return floor(scaledTime) + pow(smoothstep(0.0, 1.0, fract(scaledTime)), 20.0);\n}\n\nvec3 cameraPos;\nvec3 CameraPos()\n{\n  vec3 shake = vec3(Random(),Random(),Random()) * 0.03;\n  \n  return phase1Frag * (PHASE1_POS + shake * 0.2 + vec3(0.6, 0.3, 0.5) * vec3(Noise(phaseTime * 0.7), Noise(phaseTime * 0.3), Noise(phaseTime * 0.4))) +\n         phase2Frag * (PHASE2_POS + shake) +\n         phase3Frag * (PHASE3_POS + shake * (4.0, 2.0, 1.0)) + \n         phase4Frag * (PHASE4_POS + shake * 0.4 + vec3(0.1 * Noise(phaseTime * 2.7), 0.1 * Noise(phaseTime * 2.3), 0.1 * Noise(phaseTime * 2.4) + (phaseTime - 5.8) * 0.5) * smoothstep(5.8, 7.0, phaseTime)) + \n         phase5Frag * (PHASE5_POS + shake + 3.0 * vec3(0.0,0.0,phaseTime) + shake + vec3(5.6, 7.3, 8.5) * vec3(Noise(phaseTime * 0.7), Noise(phaseTime * 0.3), Noise(phaseTime * 0.4))) + \n         phase6Frag * (PHASE6_POS + shake + vec3(0.0,0.0,phaseTime) + shake + vec3(0.6, 0.3, 0.5) * vec3(Noise(phaseTime * 0.7), Noise(phaseTime * 0.3), Noise(phaseTime * 0.4))) + \n         phase7Frag * (\n          ((PHASE7_POS + shake * 0.4 +\n          smoothstep(5.0, 10.0, phaseTime) * vec3(9.0, 9.0, 2.0) * \n          vec3(Noise(phaseTime * 0.3 + 9.0), Noise(phaseTime * 0.2 + 15.0), Noise(phaseTime * 0.4 + 12.0))\n          + vec3(0.0, 0.0, mix(phaseTime, 5.0 + phaseTime * 0.2, smoothstep(5.0, 6.0, phaseTime))))\n          * (1.0 - smoothstep(0.8, 1.0, phaseRate))\n           + smoothstep(0.8, 1.0, phaseRate) * ROOM_POS)\n          ) +\n         phase8Frag * PHASE8_POS;\n}\n\nvec3 cameraDir;\nvec3 CameraDir()\n{\n  return phase1Frag * normalize(ROOM_POS + vec3(0.0, 0.0, 1.0) - cameraPos) +\n         phase2Frag * normalize(vec3(-0.3,-0.5,1.)) +\n         phase3Frag * normalize(vec3(0.4,0.0,1.)) +\n         phase4Frag * normalize(vec3(0.,0.,1.)) +\n         phase5Frag * normalize(vec3(0.,0.,1.)) +\n         phase6Frag * normalize(vec3(0.,0.,1.)) +\n         phase7Frag * (normalize(ROOM_POS - cameraPos + EPS) * (1.0 - smoothstep(0.8, 1.0, phaseRate)) + smoothstep(0.8, 1.0, phaseRate) * normalize(vec3(0.,0.,1.))) +\n         phase8Frag * normalize(vec3(0.,0.,1.));\n}\n\nvec3 cameraUp;\nvec3 CameraUp()\n{\n  return mix(vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.0, -0.1), phase5Frag);\n}\n\nvec3 cameraSide;\nvec3 CameraSide()\n{\n  return -cross(cameraDir,cameraUp);\n}\n\nvec3 HSV2RGB(float h, float s, float v)\n{\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 FoldRotate(vec2 p, float s) \n{\n    float t = PI * 2.0 / s;\n    float a = -atan(p.x, p.y) + PI / 2.0 + t / 2.0;\n    a = mod(a, t) - t / 2.0;\n    a = abs(a);\n    return length(p) * vec2(cos(a), sin(a));\n}\n\nsurface Sponge(vec3 p0, float foldXY, float foldYZ, float offset) \n{\n    vec4 p = vec4(p0, 1.0);\n    int id = int(Hash(floor((p0.y * 0.5 + 0.5) * 3.0)) * 3.0);\n    \n    for (int n = 0; n < 3; n++) \n    {\n        p.xy = FoldRotate(p.xy, foldXY);\n        p.yz = FoldRotate(p.yz, foldYZ);\n        p = abs(p);\n        p *= 3.0; \n        p.xyz -= 2.0;\n        p.z += 1.0;\n        p.z = abs(p.z);\n        p.z -= 1.0;\n    }\n  \n    return surface(Box(p.xyz, vec3(1.0)) / p.w + offset, id);\n}\n\nsurface Map(vec3 p)\n{\n  float t = step(TUNNEL_AREA_MIN.x, p.x) * step(TUNNEL_AREA_MIN.y, p.y) * step(TUNNEL_AREA_MIN.z, p.z) * step(p.x, TUNNEL_AREA_MAX.x) * step(p.y, TUNNEL_AREA_MAX.y) * step(p.z, TUNNEL_AREA_MAX.z);\n  float r = step(ROOM_AREA_MIN.x, p.x) * step(ROOM_AREA_MIN.y, p.y) * step(ROOM_AREA_MIN.z, p.z) * step(p.x, ROOM_AREA_MAX.x) * step(p.y, ROOM_AREA_MAX.y) * step(p.z, ROOM_AREA_MAX.z);\n  float f = step(FLOOR_AREA_MIN.x, p.x) * step(FLOOR_AREA_MIN.y, p.y) * step(FLOOR_AREA_MIN.z, p.z) * step(p.x, FLOOR_AREA_MAX.x) * step(p.y, FLOOR_AREA_MAX.y) * step(p.z, FLOOR_AREA_MAX.z);\n  float c = step(COLUMN_AREA_MIN.x, p.x) * step(COLUMN_AREA_MIN.y, p.y) * step(COLUMN_AREA_MIN.z, p.z) * step(p.x, COLUMN_AREA_MAX.x) * step(p.y, COLUMN_AREA_MAX.y) * step(p.z, COLUMN_AREA_MAX.z);\n\n  float x = mix(4.0, 4.0 + sin(beatTime), t + r);\n  float y = mix(4.0, 8.0 + 3.0 * cos(beatTime), t + r);\n  float z = mix(0.0, abs(Noise(phaseTime * 0.5)) * 0.03, t + r);\n  z = mix(z, abs(Noise(phaseTime * 0.5)) * 0.03, c);\n  \n  \n  z = mix(z, smoothstep(0.4, 0.0, phaseTime * 0.2 + 0.2) , phase1Frag); \n  z = mix(z, smoothstep(0.4, 0.0, phaseTime * 0.2) , phase2Frag); \n  z = mix(z, \n      smoothstep(0.4, 0.0, (phaseTime * 0.2 + 0.05) * step(0.0, p.z) * step(p.z, 3.0)) *\n      smoothstep(0.4, 0.0, (phaseTime * 0.2 - 0.2) * step(3.0, p.z) * step(p.z, 6.0)) *\n      smoothstep(0.4, 0.0, (phaseTime * 0.2 - 0.45) * step(6.0, p.z) * step(p.z, 9.0)) *\n      smoothstep(0.4, 0.0, (phaseTime * 0.2 - 0.7) * step(9.0, p.z) * step(p.z, 12.0)), \n      step(PHASE2_TIME, iTime) * step(iTime, PHASE3_TIME)\n  ); \n  z = mix(z, smoothstep(0.4, 0.0, phaseTime * 0.2 + 0.05) , phase4Frag); \n\n  //Tunnel\n  p.z = mix(p.z, mod(p.z, 2.0) - 1.0, t);\n  p.xy = mix(p.xy, FoldRotate(p.xy, 10.0 + 4.0 * Noise(2.0 + beatTime)), t);\n  p.x -= mix(0.0, (2.0 + 0.5 * Noise(beatTime)), t);\n  \n  //Room\n  p -= mix(vec3(0.0), ROOM_POS, r);\n  p.xy = mix(p.xy, FoldRotate(p.xy, 12.0), r);\n  p.xz = mix(p.xz, FoldRotate(p.xz, 12.0), r);\n  p.x -= mix(0.0, 3.5, r);\n  \n  //Floor\n  p.y = mix(mix(p.y, abs(p.y), f), p.y, phase5Frag) ;\n  p.y -= mix(0.0, 10.0, f);\n  vec2 s = mix(floor((p.xz - mod(p.xz, 2.0))), floor((p.xz - mod(p.xz, 3.5))),phase5Frag);\n  p.xz = mix(mix(p.xz, mod(p.xz, 2.0) - 1.0, f), mod(p.xz, 3.5) - 1.75, phase5Frag);\n  p.y += mix(mix(0.0, 3.0 * Noise((Hash(s.y) + Hash(s.x)) * 20.0 + beatTime) * 2.0 + (Hash(s.y) + Hash(s.x)), f), 0.0, phase5Frag);\n  p.y += mix(0.0, -(Hash(s.y) * Hash(s.x)) * 100.0 + 10.0 + 30. * (Hash(s.y) * Hash(s.y + 0.5) * Hash(s.x) * Hash(s.x + 0.5)) * phaseTime, phase5Frag);\n  p.xz = mix(p.xz, Rotate((Hash(s.y) * Hash(s.x)) * 3.0 * beatTime) * p.xz, phase5Frag);\n  p.xy = mix(p.xy, Rotate((Hash(s.y) + Hash(s.x)) * 3.0 * beatTime) * p.xy, phase5Frag);\n  \n  z = mix(z, smoothstep(0.4, 0.0, (phaseTime + 30.0 + (Hash(s.y) * Hash(s.x)) * 40.0 - 40.0) * 0.2) , phase5Frag); \n  \n  //Column\n  p -= mix(vec3(0.0), COLUMN_CENTER, c);\n  float s1 = floor(p.z - mod(p.z, 3.0));\n  p.x += mix(0., Hash(s1) * 60.0 - 30.0, phase6Frag);\n  p.xy = mix(p.xy, Rotate(PI * Hash(2.4 + s1)) * p.xy, c);\n  p.y = mix(p.y, mod(p.y, 2.0) - 1.0, c);\n  p.z = mix(p.z, mod(p.z, 3.0) - 1.5, c);\n  p *= mix(1.0, 0.5 * (sin(beatTime * PI * 2.0) * 0.5 + 0.5) + 0.5, phase6Frag);\n  \n  return Sponge(p, x, y, z);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPS;\n\n    return normalize(\n            Map(p + e.xyy).dist * e.xyy +\n            Map(p + e.yyx).dist * e.yyx +\n            Map(p + e.yxy).dist * e.yxy +\n            Map(p + e.xxx).dist * e.xxx\n           );\n}\n\nfloat AO(vec3 p, vec3 n)\n{\n  float l = EPS;\n  float h = 0.0;\n  vec3 p2 = p;\n  float s = 1.0;\n\n  for(float i = 0.0; i < AO_NUM; i++)\n  {\n    p2 = p + l * n;\n    l += EPS * 40.0;\n    h += abs(l - Map(p2).dist) * s;\n  }\n  h = 1.0 - clamp(h, 0.0, 1.0);\n  return pow(h, 2.5) * 2.0;\n}\n\nvoid RayMarch(vec2 c, inout vec3 color)\n{\n  float d = 0.0;\n  vec3 r = normalize(cameraSide * c.x + cameraUp * c.y + cameraDir * CAMERA_DEPTH);\n  vec3 p0 = cameraPos;\n  vec3 p = p0;\n  float l = 0.0;\n  float ml = 50.0;\n  for(int i = 0; i < MARCHING_NUM; i++)\n  {\n    surface s = Map(p);\n    d = s.dist;\n\n    color += 0.001 / s.dist * HSV2RGB(beatTime, 0.6, 1.0);\n    \n    if(l > ml)break;\n    \n    if(abs(d) < EPS)\n    {\n      vec3 n = Normal(p + vec3(EPS, 0.0, 0.0));\n      vec3 nx = Normal(p + vec3(EPS, 0.0, 0.0));\n      vec3 ny = Normal(p + vec3(0.0, EPS, 0.0));\n      vec3 nz = Normal(p + vec3(0.0, 0.0, EPS));\n      \n      vec3 ec = HSV2RGB(beatTime, 1.0, 1.0) * abs(sin(phaseTime * 3.0 + p.z));\n      vec3 sc = s.id == 0 ||s.id == 1 ? \n      vec3(0.7, 0.3,0.2) :\n      vec3(0.95, 0.9, 0.75);\n      sc *= AO(p,n);\n   \n      color = length(nx - ny) > EPS || length(ny - nz) > EPS || length(nz - nx) > EPS\n      ? ec\n      : sc;\n     \n     //color = sc;\n\n      color *= iTime > PHASE3_TIME\n      ? 1.0 - HSV2RGB(n.x * n.y * n.z * 10.0, 0.7, 0.7) * smoothstep(0.9, 1.0, abs(sin(iTime * 1.5 + p.z)))\n      : vec3(1.0);\n      \n      color += HSV2RGB(Hash(p.y + phaseTime), 1.0, Hash(Hash(p.x + phaseTime) + p.z / 100.0) - 0.5);\n      \n      break;\n    }\n    \n    l += mix(mix(mix(mix(d, \n    min(min((2.0 * step(0.0, r.x) - mod(p.x, 2.0)) / r.x, (2.0 * step(0.0, r.z) - mod(p.z, 2.0)) / r.z) + EPS, d),\n    phase2Frag),\n    min((3.0 * step(0.0, r.z) - mod(p.z, 3.0)) / r.z + EPS, d),\n    step(PHASE2_TIME, iTime) * step(iTime, PHASE3_TIME)),\n    min(min((3.5 * step(0.0, r.x) - mod(p.x, 3.5)) / r.x, (3.5 * step(0.0, r.z) - mod(p.z, 3.5)) / r.z) + EPS, d),\n    phase5Frag), \n    min((3.0 * step(0.0, r.z) - mod(p.z, 3.0)) / r.z + EPS, d),\n    phase6Frag);\n    \n    p = p0 + r * l;\n  }\n  return;\n}\n\nvoid Glitch(vec2 uv, float threshold, inout vec3 color)\n{\n  for(float i = 0.0; i < 2.0; i++)\n  {\n    uv = (uv * 3.0 + 20.0);\n    float r = Noise(uv.x * Hash(uv.y) + Random()) * 0.5 + 0.5;\n    color *= r > threshold ? vec3(1.0) : HSV2RGB(Hash(r), 1.0, 1.0) * 2.0; \n  }\n}\n\nvoid PostEffect(vec2 uv, inout vec3 color)\n{\n    Glitch(uv * vec2(0.2, 0.0002), 0.5 * step(iTime, PHASE1_TIME) * step(PHASE1_TIME - 0.6, iTime), color);\n    Glitch(uv * vec2(0.2, 0.0002), 0.5 * step(iTime, PHASE2_TIME) * step(PHASE2_TIME - 0.5, iTime), color);\n    Glitch(uv * vec2(0.2, 0.0002), 0.5 * step(iTime, PHASE3_TIME) * step(PHASE3_TIME - 0.5, iTime), color);\n    Glitch(uv * vec2(0.2, 0.0002), 0.5 * step(iTime, PHASE4_TIME) * step(PHASE4_TIME - 0.5, iTime), color);\n    Glitch(uv * vec2(0.2, 0.0002), 0.5 * step(iTime, PHASE5_TIME) * step(PHASE5_TIME - 0.5, iTime), color);\n    Glitch(uv * vec2(0.2, 0.0002), 0.5 * step(iTime, PHASE6_TIME) * step(PHASE6_TIME - 0.5, iTime), color);\n      \n    color *= 1.0 - smoothstep(0.4, 0.8, length(uv- vec2(0.5)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  randomSeed = Hash(iTime);\n  phase1Frag = Phase1Frag();\n  phase2Frag = Phase2Frag();\n  phase3Frag = Phase3Frag();\n  phase4Frag = Phase4Frag();\n  phase5Frag = Phase5Frag();\n  phase6Frag = Phase6Frag();\n  phase7Frag = Phase7Frag();\n  phase8Frag = Phase8Frag();\n  phaseTime = PhaseTime();\n  phaseRate = PhaseRate();\n  scene = Scene();\n  beatTime = BeatTime();\n  cameraPos = CameraPos();\n  cameraDir = CameraDir();\n  cameraUp = CameraUp();\n  cameraSide = CameraSide();\n  \n  vec2 r=iResolution.xy;\n  vec2 c=(gl_FragCoord.xy * 2.0-r)/min(r.x,r.y);\n  vec3 color = HSV2RGB(Hash(c.y + phaseTime), Hash(c.y + phaseTime), Hash(Hash(c.x + phaseTime) + c.x / 100.0) - 0.5) + vec3(0.0, 0.15, 0.25);\n  RayMarch(c, color);\n  vec2 uv = gl_FragCoord.xy/r;\n  PostEffect(uv, color);\n  fragColor=vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}