{"ver":"0.1","info":{"id":"cd2GWG","date":"1668343362","viewed":89,"name":"Graph Quadric Approx","username":"spalmer","description":"Drawing graphs by locally fitting a quadratic bezier and approximating distance to it","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["line","curve","cubic","parabola","parabolic"],"hasliked":0,"parentid":"mdsGDX","parentname":"Parabolic Graph Drawing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of Parabolic Graph Drawing by mla http://shadertoy.com/view/mdsGDX\n// wanted to try my idea from the comments\n// Hughes Hoppe inversion approximation http://hhoppe.com/ravg.pdf\n// using code from http://shadertoy.com/view/dsj3Wy\n// see also http://shadertoy.com/view/3tsczH\n\n#define AVOID_DIVIDE_ZERO 1\n// !DETECT_LINEAR\n\nconst int curve = 1;\n\nfloat F(float x, float t) \n{\n  switch (curve) {\n    case 0: return 1./sin(x+t); // infinity stress test by mla\n    case 1: return 4.*cos(.3*(x+t))*sin(10.*cos(x+.382*t)+t); // main curve by mla\n    case 2: return 8.*abs(fract(.43*(x+t))-.5)-2.; // triangle wave stress test\n    default: return sin(x+t); // easy sinusoid\n  }\n}\n\n// 2x2 determinant = 2d cross product = perpendicular 2d dot product\nfloat det(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } //dot(a, vec2(1,-1)*b.yx); } //\n\n// based on iq http://shadertoy.com/view/MlKcDD\nfloat indexApprox(vec2 a, vec2 b, vec2 c)\n{\n\tvec2 i = a - c,\n         j = c - b,\n         k = b - a,\n         w = j - k;\n\tfloat x = det(a, c),\n          y = det(b, a),\n          z = det(c, b);\n\tvec2 s = 2.*(y*j + z*k) - x*i;\n    // there's a couple ways it could divide by zero\n    float denom1 = dot(s,s);\n  #if AVOID_DIVIDE_ZERO\n    denom1 = max(denom1, 1e-14);\n  #endif\n    float r = (y*z - .25*x*x) / denom1;\n    float denom2 = x+y+z;\n  #if AVOID_DIVIDE_ZERO\n    denom2 = max(abs(denom2), 1e-14) * (denom2 < 0. ? -1. : 1.);\n  #endif\n    return (.5*x + y + r * dot(s,w)) / denom2;\n}\n\n// get vector to origin from closest point to origin\nvec2 vectorApprox(vec2 a, vec2 b, vec2 c)\n{\n    float t = indexApprox(a, b, c);\n    //t = clamp(t, 0., 1.);\n    return mix(mix(a,b,t), mix(b,c,t), t);\n\t//return a + t*(2.*(b - a)+t*(c + a - 2.*b));\n}\n\nfloat distanceApprox(vec2 a, vec2 b, vec2 c)\n{\n    return length(vectorApprox(a, b, c));\n}\n\n// everything's specified relative to x1; h = y1-y0 = y2-y1, (x,y) = query relative to (x1,y1)\nfloat graph2(float x, float y, float h, float y0, float y1, float y2) \n{\n//  return graph0(x, y, h, y0, y1, y2);\n//  return graph1(x, y, h, y0, y1, y2);\n    // convert b from a point on the curve\n    // to its bezier control point cage vertex\n    y1 += y1 - .5 * (y0 + y2);\n    return distanceApprox(vec2(-h-x, y0-y), vec2(-x, y1-y), vec2(h-x, y2-y));\n}\n\n// that parameterization is so wack I had to make a shim\nfloat graph3(vec2 q, vec2 a, vec2 b, vec2 c)\n{\n    float h = .5 * (c.x - a.x);\n  #if DETECT_LINEAR\n    // handle perfectly flat curves (linear equation)\n    vec2 f = b - .5 * (a + c);\n    if (dot(f, f) < 1e-12) //3e-7) // detect linear spline\n        return graph1(q.x-b.x, q.y, h, a.y, b.y, c.y);\n  #endif\n    return graph2(q.x-b.x, q.y, h, a.y, b.y, c.y);\n}\n\nfloat aa(float d)\n{\n    return clamp(1. - d / 4., 0., 1.);\n}\n\n// FIXME so many wrapper layers now, it's like an onion!\n\nvoid graphF(float a, float t, float h, vec2 q, vec3 c, inout vec3 o)\n{\n    float \n        a0 = a-h,\n        a1 = a,\n        a2 = a+h,\n        y0 = F(a0, t),\n        y1 = F(a1, t),\n        y2 = F(a2, t),\n        d = graph3(q, \n            vec2(a0, y0),\n            vec2(a1, y1),\n            vec2(a2, y2));\n    o = mix(o, c, aa(d / h));\n}\n\nvec2 proj(vec2 coord) \n{\n    return 2.*coord - iResolution.xy;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    float t = iTime,\n        h = 6. / iResolution.y;\n    vec2 q = proj(fragCoord) * h,\n        m = vec2(0);\n    if (iMouse.x > 0.)\n        m = proj(iMouse.xy) * h;\n    vec3 c = vec3(.9);\n    graphF(m.x, t, h*4., q, vec3(0,.5,0), c); // scaling h here makes display much more stable\n    graphF(q.x, t, h, q, vec3(0), c);\n    fragColor = vec4(pow(c, vec3(.45)), 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DETECT_LINEAR     0\n\n/*\nfloat sqr(vec2 v) \n{ \n  return dot(v,v);\n}\n*/\n\nfloat seg(vec2 p, vec2 a, vec2 b) \n{\n  p -= a; b -= a;\n  float h = dot(p,b) / dot(b,b);\n  h = clamp(h, 0., 1.);\n  return length(p - b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) \n{\n  p -= a; b -= a;\n  float h = dot(p,b) / dot(b,b);\n  return length(p - b*h);\n}\n\n#if DETECT_LINEAR\nfloat graph0(float x, float y, float h, float f0, float f1, float f2)\n{\n  return min(seg(vec2(x,y),vec2(-h,f0),vec2(0,f1)), seg(vec2(x,y),vec2(0,f1),vec2(h,f2)));\n}\n\nfloat graph1(float x, float y, float h, float f0, float f1, float f2)\n{\n  return line(vec2(x,y),vec2(-h,f0),vec2(h,f2));\n}\n\n#endif\n\n//c = mix(c, vec3(1,0,0), aa(distance(m, uv)-.02));\n","name":"Common","description":"","type":"common"}]}