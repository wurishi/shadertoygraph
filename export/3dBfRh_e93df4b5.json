{"ver":"0.1","info":{"id":"3dBfRh","date":"1589831994","viewed":336,"name":"Boidified","username":"ndeshler","description":"A first pass at implementing the boids algorithm","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["simulation","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// BOIDIFIED by ndeshler\n// https://www.shadertoy.com/view/3dBfRh\n// 05/18/2020\n// --------------------------------------------------------------------------------\n// PROJECT 2: A simple implementation of the boids algorithm.\n// \n// Sources:\n// 1) SIMPLE BOIDS by saduras  (https://www.shadertoy.com/view/MdlfDl)\n// 2) BOIDS PSEUDOCODE by Conrad Parker (http://www.kfish.org/boids/pseudocode.html)\n// ---------------------------------------------------------------------------------\n// Stay safe during COVID-19 everyone!\n\n#define numboids 20.\t\t// number of boids (must be integer value represented as float)\n\nfloat edgeSign(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\n// Point-in-Triangle Test for shading boids\nbool isPointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n{\n    bool b1, b2, b3;\n\n    b1 = edgeSign(pt, v1, v2) < 0.0f;\n    b2 = edgeSign(pt, v2, v3) < 0.0f;\n    b3 = edgeSign(pt, v3, v1) < 0.0f;\n\n    return ((b1 == b2) && (b2 == b3));\n}\n\n// A function that defines whether the screen coordinate uv is inside a boid.\n// boid.xy = boid screenspace coordinate\n// boid.zw = boid velocity\nbool drawBoid(vec2 uv, vec4 boid)\n{\n    vec2 forward = 10. * boid.zw / length(boid.zw);\n    vec2 p1 = boid.xy + forward * 2.0f;\n    vec2 p2 = boid.xy + vec2(forward.y, - forward.x) - forward;\n    vec2 p3 = boid.xy + vec2(-forward.y, forward.x) - forward;\n\n    return isPointInTriangle(uv, p1, p2, p3); \n}\n\nvec4 getBoid(float id) { return texture(iChannel0, vec2(id + .5f,.5f)/iResolution.xy);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    \n    //Background Color\n    fragColor = vec4(0.1f, 0.1f, 0.1f, 1.f);\n    \n    \n    for (float i = 0.f; i < numboids; i++) {\n    \t\n        vec4 boid = getBoid(i);\n        \n        //Boid color\n    \tvec4 col = vec4(boid.x/iResolution.x, 0., boid.y/iResolution.y,1.f);\n    \t\n        if (drawBoid(fragCoord, boid)) fragColor = col;           \n    \n    }\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define numboids 20.\t\t// Number of boids (must be integer value represented as float)\n#define speed 10.0f\t\t\t// Boid speed\n#define a1 0.001f\t\t\t// Collision factor\n#define a2 0.01f\t\t\t// Cohesion factor\t\n#define a3 0.05f\t\t\t// Alignment factor\n\nvec4 getBoid(float id) { return texture(iChannel0, vec2(id + .5f,.5f)/iResolution.xy);}\n\nvec2 hash(float n) { return fract(sin(vec2(n,n*7.))*43758.5f); }\n                        \n// returns true if fragment coordinate maps to boid data\n//bool isBoid(vec2 uv) { return (floor(uv.x) == uv.x) && (uv.x < numboids) && (uv.y == 0.0f);}\t\n\n// Very Strange implementation - We use the buffer as a texture that stores and mantains the boid information at each time step.\n// Then the main image program queries the boid data from this buffer.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.0f,0.0f,0.0f,0.0f);\t\t\t// default data\n    //float id = floor(fragCoord.x)/iResolution.x;\n    \n    if (fragCoord.y > 0.5 || fragCoord.x > numboids) discard;\n    \n    float id = floor(fragCoord.x);\n    \n    // initialize random boid positions and velocities\n    if(iFrame < 5)\n    {\tvec2 init_p = hash(id)*iResolution.xy;\n        vec2 init_v = vec2(sin(id),cos(id));\n     \tinit_v /= speed * length(init_v);\n        fragColor = vec4(init_p, init_v);\n    }\n    else {        \n        \n        // boid of interest\n        vec4 boid = getBoid(id);\n        vec2 p = boid.xy;\t\t// boid position\n        vec2 v = boid.zw;\t\t// boid velocity\n        \n        \n        // initialize velocity update vectors\n        vec2 v_collision,v_cohesion,v_alignment = vec2(0.0f,0.0f);\n\n        // loop over neighboring boids and build update vectors accordingly\n        for (float nid = 0.0f; nid < numboids; nid++) {\n            \n            if (nid != id) {\n                vec4 neighbor = getBoid(nid);\n            \tvec2 p_neighbor = neighbor.xy;\t// nieghboring boid position\n            \tvec2 v_neighbor = neighbor.zw;\t// neighboring boid velocity\n            \t\n                vec2 sep = p_neighbor - p;\n                float ls = length(sep);\n                float r = 50.f;\t\t\t\t// separation radius\n          \n            \t// Collision Update\n                if (ls < r) {\n                \tv_collision -= sep;  \n                }\n            \t\n                // Cohesion Update\n                v_cohesion += sep;\n                \n                // Alignment Update\n                v_alignment += v_neighbor;\n            }\n            \t\t\n            // Perceived values\n            v_cohesion = v_cohesion/(numboids - 1.0f);\n            v_alignment = v_alignment/(numboids - 1.0f) - v;\n\n\n            // Apply position and velocity updates\n            v = v + a1*v_collision + a2*v_cohesion + a3*v_alignment;\n            v = v / length(v) * speed;\t\t// constrain velocity\n            p = p + iTimeDelta * v;\t\t\t// update position\n            \n            \n            \n            // Impose wrapped boundary conditions\n            if (p.x < 0.) {\n            \tp.x = iResolution.x + p.x;        \n            }\n            if (p.x > iResolution.x) {\n            \tp.x = p.x - iResolution.x;       \n            }\n             if (p.y < 0.) {\n            \tp.y = iResolution.y + p.y;       \n            }\n            if (p.y > iResolution.y) {\n            \tp.y = p.y - iResolution.y;       \n            }\n \n\n        \tfragColor = vec4(p,v);\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}