{"ver":"0.1","info":{"id":"cdtGR2","date":"1677559082","viewed":123,"name":"Shiny brick house","username":"ianertson","description":"Use the mouse to look around :)\nYou can also enable the \"WALK\" define in \"Buffer a\" to turn on a first-person controller, then you can walk around using WASD, fly up with space, fly down with shift.","likes":6,"published":1,"flags":48,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","materials","textures","lights","house"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\n\nvec3 blurx(vec2 uv) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = 1.0 / vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    vec3 smo = blurx(uv);\n    col = mix(col, smo, clamp(smoothstep(0.3, 1.0, depth), 0.0, 0.9));\n    col = mix(col, smo, noiseEst*noiseEst);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { dist = var; id = id_; }\n#define TEXTURE_SIGNATURE in vec2 uv, in vec3 p, inout Material m\n#define notzero(V) (abs(V) <= 0.000001 ? 0.01 : V)\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material {\n    float rough;\n    float spec;\n    float metallic;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: {\n            return light.c * NdotL * (pow(light.s, 2.0) /\n                max(0.0001, pow(distance(light.p, p), 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            return light.c * light.s * smoothstep(0.8, 1.0, dot(normalize(light.p - p), L));\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, round(adot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, round(adot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.zy, round(adot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nfloat hash21(in vec2 p, in float seed) {\n    uint s = floatBitsToUint(seed);\n    uvec2 k = uvec2(floatBitsToUint(p.x), floatBitsToUint(p.y));\n    s ^= (~k.x ^ ~k.y) >> 3U;\n    k ^= k << 13;\n    k ^= k >> 17;\n    s ^= ((k.x << k.y) >> 3U);\n    k ^= k << 5;\n    k ^= (s >> 3U);\n    uint n = (((k.x << ~k.y) + (k.y >> ~k.x)) << 503U) + (k.x ^ k.y);\n    return float(n*3028U) / float(0xFFFFFFFFU);\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 lookDir(vec2 uv, vec3 dir, vec3 ro) {\n    vec3 camForward = normalize(dir);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) <= 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    n = normalize((wn*0.03)+n);\n    return normalize(mix(wn, n, mixf*max(0.03, dot(wn, n))));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            speed *= 1.; //+ 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n            speed *= 3.0;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// set to `1` to turn on first-person controller\n#define WALK 0\n\n#define NEAR 0.003\n#define FAR 96.0\n#define STEPS 96\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_HOUSE 3\n#define ID_HOUSE_ROOF 4\n#define ID_LAMP 5\n#define ID_CEIL_LAMP 6\n#define ID_SHINY_BOX 7\n\n#define GROUND_LEVEL 4.0\n#define DEBUG_LIGHTS 0\n\nvec3 noisex(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p+(seed*1.2881823))  / 256., 0.0).xyz;\n}\n\nvec3 bnoise(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noisex(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n / div;\n}\n\nvec3 noise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n        mix(noisex(id, seed), noisex(id+vec2(1, 0), seed), lv.x),\n        mix(noisex(id+vec2(0, 1), seed), noisex(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n / div;\n}\nvec3 noise6(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n / div;\n}\n\nvec3 hemiDir(in vec3 p, in vec3 n) {\n  vec3 tn = abs(n.y) < 0.999 ? cross(n, vec3(0, 1, 0)) : cross(n, vec3(1, 0, 0));\n  tn = normalize(tn);\n  vec3 bt = normalize(cross(n, tn));\n  vec3 r1 = noise6(p.xy/FAR, 0.8281256, 16.0);\n  vec3 r2 = noise6(p.yz/FAR, 1.9929813, 16.0);\n  float u = r1.x;//hash21(p.xy, 0.89822123);\n  float v = r2.y;//hash21(p.yz, 1.93921956);\n  float r = sqrt(u);\n  float theta = 2.0 * M_PI * v;\n  vec3 d = vec3(r * cos(theta), sqrt(max(0.0, 1.0 - u)), r * sin(theta));\n  return normalize(d.x * tn + d.y * n + d.z * bt);\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  vec3 c = a + t * ab;\n  float x = length(p - c) - r;\n  float y = (abs(t - 0.5) - 0.5) * length(ab);\n  float e = length(max(vec2(x, y), 0.0));\n  float i = min(max(x, y), 0.0);\n  return e + i;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat groundSDF(in vec3 p) {\n    float h = 0.0;\n    if (p.y > 16.) return p.y;\n  \n    \n    vec2 f = vec2(sin((p.x/60.)*2.38281+(p.z/60.)), cos((p.z/60.)*2.38281+(p.x/60.)));\n    vec2 f2 = vec2(cos(((p.x+3.92891815)/20.)*2.38281+(p.z/30.)), sin(((p.z+8.88827615)/20.)*2.38281+(p.x/30.)));\n    vec2 f3 = vec2(sin((f.x+p.x/16.)*10.9928813+(f.x+p.z/20.)), cos((f.y+p.z/16.)*10.9928813+(f.y+p.x/20.)));\n    \n    h += (f.x*f.y)*exp(cos(p.x*0.2)-1.);\n    h += (f.x*f.y)*exp(sin(p.z*0.2)-1.);\n    h += exp(cos((p.x*f.x*(0.5+(f.y-f3.x-f3.y)*0.02))*0.1)-1.);\n    h += exp(sin((p.y*f.y*(0.5+(f.x+f3.y-f3.x)*0.02))*0.1)-1.);\n    \n    h += exp(f2.x-1.)*f.y;\n    h += exp(f2.y-1.)*f.x;\n //   float n = gnoise6(p.xz, 1.29381254, 0.05);\n   \n   vec3 nn = noise6(p.xz, 1.29381254, 0.05);\n   float n = nn.x;\n    h *= n;\n    \n    \n    h *= 6.;\n    \n    \n    float area = smoothstep(8., 64.0, distance(p.xz, vec2(0.0)));\n    \n    h *= area;\n    \n    \n    return (p.y - h)/2.2;\n}\n\nfloat houseSDF(in vec3 point, inout int id, in int skip) {\n    float dist = FAR;\n    id = ID_HOUSE;\n    \n    float base = FAR;\n    float roof = FAR;\n    float inside = FAR;\n    float ceilLamp = FAR;\n    vec3 siz = vec3(8, 3, 8);\n    \n    {\n        vec3 size = siz;\n        vec3 p = point;\n        \n        float window1 = boxSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-size.z*0.6), size.y+(size.y*0.2), abs(-size.z)), vec3(size.x/7., size.y*0.4, 1.));\n        \n        float window2 = boxSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-size.x), size.y+(size.y*0.2), abs(-size.x*0.6)), vec3(size.x/7., size.y*0.4, 1.));\n        \n        base = boxSDF(p - vec3(0, size.y, 0), size + vec3(0, 4.0-(abs(p.x)/2.), 0));\n        inside = boxSDF(p - vec3(0, size.y+0.5, 0), size*0.9);\n        float doorHole = boxSDF(p - vec3(0, size.y-0.1, -size.z), vec3(size.x/5., size.y*0.7, 1.));\n\n        \n        \n        \n        base = max(base, -inside);\n        base = max(base, -doorHole);\n        base = max(base, -window1);\n        base = max(base, -window2);\n    }\n    {\n        vec3 size = siz;\n        vec3 p = point;\n        float y = size.y-abs(p.x)/2.;\n        \n        p.y += (smoothstep(0.0, 2.0, max(0.0, size.z-abs(p.z)))/3.);\n\n        \n        float taper = ( smoothstep(0.0, 1.0, max(0.0, p.y))) * smoothstep(0.2, 2.0, abs(p.z)-(size.z-0.9));///float(abs(p.z) >= size.z-0.2);\n        \n        roof = boxSDF(p - vec3(0, size.y+y+4., 0), vec3(size.x, (1.*(1.0-taper)), size.z+1.))-0.1;\n        roof = max(roof, -(inside-0.02));\n        \n        roof /= 1.3;\n    }\n    \n    {\n        vec3 size = siz;\n        vec3 p = point;\n        float lampH = 0.2;\n        float lampR = 0.5;\n        ceilLamp = cylSDF(p - vec3(0, (size.y*2.)-lampH, 0), vec3(0, 0, 0), vec3(0, lampH, 0), lampR);    \n    \n    }\n    \n    SAMPLE(base, ID_HOUSE);\n    SAMPLE(roof, ID_HOUSE_ROOF);\n    SAMPLE(ceilLamp, ID_CEIL_LAMP);\n    \n    return dist;\n}\n\n#define LAMP_POS vec3(-8., 0, -13.)\n#define LAMP_HEIGHT 12.\n\nfloat getDist(inout Data data, in vec3 p) {\n    p.y -= GROUND_LEVEL;\n    float dist = FAR;\n    int id = ID_NONE;\n    int skip = data.skip;\n    \n    float ground = groundSDF(p);\n //   float box = boxSDF(p - vec3(0, 1, 0), vec3(1.0));\n    int houseId = 0;\n    float house = houseSDF(p, houseId, skip);\n    \n    \n    float lamp = cylSDF(p - LAMP_POS, vec3(0, 0, 0), vec3(0, LAMP_HEIGHT, 0), 0.3);\n    float lampHead = boxSDF(p - (LAMP_POS + vec3(0, LAMP_HEIGHT, -0.5)), vec3(0.3, 0.2, 0.8))-0.09;\n    lamp = min(lamp, lampHead);\n    \n    SAMPLE(ground, ID_GROUND);\n //   SAMPLE(box, ID_BOX);\n    SAMPLE(house, houseId);\n    SAMPLE(lamp, ID_LAMP);\n    \n    float shinyBox = boxSDF(p - vec3(0, 1.+0.8, 0.), vec3(1.0));\n    SAMPLE(shinyBox, ID_SHINY_BOX);\n    \n    data.id = id;\n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= (NEAR*(1.0 + (dist*0.5)))) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    data.p = p;\n    data.n = n;\n    data.d = dist;\n    data.uv = uv;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far) {\n    float dist = 0.0;\n    \n    far = min(far, FAR);\n    Data data = NEW_DATA;\n    data.skip = ID_CEIL_LAMP;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= far) return 1.0;\n    }\n    \n    \n    return clamp(dist/far, 0.000332139, 0.9382123);\n}\n\n//#define DEBUG_TEXTURE grassTexture\n\nvec3 grassTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 grass1 = rgb(145, 149, 60);\n    vec3 grass2 = rgb(138, 134, 73);\n    vec3 grass3 = rgb(97, 107, 31);\n    \n    vec3 mud1 = rgb(143, 108, 83);\n    vec3 mud2 = rgb(104, 75, 56);\n    vec3 mud3 = rgb(152, 115, 92);\n    \n    vec3 hf1 = noise6(uv, 0.39828156, 9.5);/*vec3(\n        gnoise(uv, 0.0883215, 9.5),\n        gnoise(uv, 1.2737833, 9.5),\n        gnoise(uv, 7.9821156, 9.5)\n    );*/\n    \n    vec3 hf2 = noise6(uv, 7.23818213, 9.5);/*vec3(\n        gnoise(uv, 7.1111882, 9.5),\n        gnoise(uv, 3.5838883, 9.5),\n        gnoise(uv, 5.1937572, 9.5)\n    );*/\n    \n    vec3 hf3 = normalize(abs(cross(hf1, hf2)));\n    \n    vec3 lf = noise6(uv, 1.1112312, 1.5);\n    vec3 lf2 = noise6(uv, 0.9989271, 0.2);\n    vec3 grain = textureLod(iChannel3, uv*0.1, 0.0).xyz;\n    vec3 grass = mix(mix(grass1, grass2, hf1.x), grass3, hf1.y);\n    vec3 mud = mix(mix(mud1, mud2, hf1.z), mud3, hf2.x);\n    vec3 wf = abs(normalize(reflect(cross(hf3-grain, lf), lf2)));\n    mud *= (0.5+(0.5*wf.y));\n    \n    float grassR = lf.x;\n    grassR = mix(grassR, clamp((lf2.y+lf.z)*0.9, 0.0, 1.0), lf2.y*lf2.y);\n    float mudR = lf.y;\n    mudR = mix(mudR, lf2.z, lf2.x*lf2.x);\n    \n    float tmp = grassR;\n    grassR *= max(0.0, 1.0 - mudR);\n    mudR *= max(0.0, 1.0 - tmp);\n    \n    col += grass * grassR;\n    col += mud * mudR;\n    \n    \n    m.spec = clamp((mudR*hf2.x)-grassR, 0.0, 1.0);\n    \n    float wet = mudR*mudR*3.;\n    \n    m.rough = clamp(1.0 - wet, 0.2, 1.0);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE ceilTexture\n\nvec3 ceilTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    float tile = 4.0;\n    vec2 uuv = uv * tile;\n\n    float iy = floor(uuv.y);\n\n    uuv.x += (iy / (tile / 3.))/2.;\n    \n    vec2 id = floor(uuv);\n    vec2 lv = fract(uuv);\n    \n    \n    \n    vec3 hf = noise6(uv, 0.382814, 16.);\n    vec3 lf = noise6(uv*0.5, 0.9923871, 2.2);\n    vec3 wf = abs(normalize(reflect(cos(hf*6.28), sin(lf*6.28))));\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 wf3 = abs(normalize(reflect(cross(wf, grain), lf-hf)));\n    \n    float kx = cos((lv.x*16.)+wf3.z*1.6+lf.x)*smoothstep(0.0, 1., 1.0-lv.y)*3.;\n    \n    float rid1 = hash21(id, 1.298382);\n    float rid2 = hash21(id, 8.444521);\n    float rid3 = hash21(id, rid1+rid2+23.398815);\n    \n    lv.y += kx/40.;\n    float thick = 0.009 + hf.x*0.1;\n    vec2 alv = abs(lv*2.0-1.0);\n    float g = max(0.0, floor(max(alv.x, alv.y)+thick));\n    \n    vec3 c1 = rgb(160, 137, 111);\n    vec3 c2 = rgb(59, 43, 26);\n    vec3 c3 = rgb(92, 66, 44);\n    vec3 c4 = rgb(153, 150, 113);\n    \n    vec3 tileCol = mix(mix(mix(c1, c2,  rid1), c3, rid2), c4, rid3);\n    col += tileCol;\n    \n    col = mix(col, c2, hf.x*rid2*0.9);\n    \n    g = ((g*0.4)+(0.7*lf.x*g*hf.y*lf.z*lf.z));\n    \n    col = mix(col, c1*c2, g);\n    \n    float cracks = max(0.0, 1.0-smoothstep(0.02, 0.16, abs(wf.x-hf.y)))*max(0.0, 1.0 - g*10.);\n    col = mix(col, col*col, pow(cracks, 3.)*0.3);\n    col = mix(col, col*col, clamp(wf3.x*wf3.y*wf3.z*5., 0.0, 1.0));\n    col = col*col;\n    \n    m.spec = clamp(g+((cracks*0.3)+lf.x*0.5*lf.x), 0.0, 1.0);\n    //float wet = (cracks+wf3.x+wf.y)/3.;\n    m.rough = 1.;//clamp(1.0-wet, 0.2, 1.0);\n    \n    return col;\n}\n//#define DEBUG_TEXTURE rustyMetalTexture\nvec3 rustyMetalTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(141, 142, 137);\n    vec3 c2 = rgb(166, 154, 142);\n    vec3 c3 = rgb(105, 103, 102);\n    \n    vec3 hf = bnoise(uv, 0.3282815, 48.);\n    vec3 hf2 = bnoise(uv, 1.223214, 48.);\n    vec3 hf3 = normalize(abs(cross(hf*2.0-1.0, hf2*2.0-1.0)));\n    vec3 reg = noise6(uv, 0.938216, 3.2);\n    vec3 hf4 = normalize(abs(reflect(cross(reg, hf3), hf2)));\n    \n    vec3 bg = mix(mix(c1, c2, hf.x), c3, hf.y);\n    col += bg;\n    \n    vec3 rust1 = rgb(165, 138, 61);\n    vec3 rust2 = rgb(136, 86, 28);\n    vec3 rust3 = rgb(115, 84, 49);\n    \n    vec3 fg = mix(mix(rust1, rust2, hf2.x), rust3, hf2.y);\n    \n    float rustReg = clamp(pow((reg.x+hf3.y)/1.2, 4.0)*pow(reg.y, 4.)*4., 0.0, 1.0);\n    \n    col = mix(col, fg, rustReg);\n    \n    float cracks = abs((hf3.z*reg.z)-(hf.z*reg.y));\n    cracks = smoothstep(0.02+(hf4.y*0.2), (0.1+(hf4.z*0.2)), cracks);\n    cracks = pow(cracks, 4.0)*reg.z*reg.z;\n    col = mix(col, c2, clamp(cracks*2., 0.0, 1.0));\n    \n    m.spec = clamp(((1.0-rustReg)+(0.2*cracks)), 0.2, 1.0);\n    m.rough = clamp((rustReg+cracks)/2., 0.2, 0.8);\n    \n    return col;\n}\n\nvec3 brickTexture(TEXTURE_SIGNATURE) {\n  vec3 col = vec3(0.0);\n\n  float tile = 4.0;\n  vec2 uuv = uv * tile;\n\n  float iy = floor(uuv.y);\n\n  uuv.x += (iy / (tile / 2.));\n\n  vec2 id = floor(uuv);\n  vec2 lv = fract(uuv);\n  vec2 alv = abs(lv * 2.0 - 1.0);\n\n  vec3 c1 = rgb(106, 60, 48);\n  vec3 c2 = rgb(100, 49, 34);\n  vec3 c3 = rgb(137, 88, 86);\n  vec3 c4 = rgb(64, 29, 20);\n  vec3 c5 = rgb(188, 176, 135);\n\n  float r1 = hash21(id, 2.92913);\n  float r2 = hash21(id * 3.2931, 4.444291);\n  float r3 = hash21(id * 6.62235, 9.923354);\n  float r4 = hash21(id + r1, r1 + r2 + r3 + 3.3333);\n\n  col = mix(mix(mix(c1, c2, r1), c3, r3), c4, r4);\n\n  vec3 hf = noise6(uv, 3.3291254, 32.0);\n  vec3 lf = noise6(uv / 2., 11.29885, 8.);\n  \n  vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n  vec3 hf3 = abs(reflect(cross(grain, hf), lf));\n  vec3 lf2 = abs(abs(lf - hf3) - hf);\n\n  float thick =\n      (((0.01 + (hf.x / 16.) + (lf.z / 24.)) / 2.) + (grain.x / 30.)) *\n      (0.5 + (0.5 * grain.y));\n  float g = max(0.0, floor(max(alv.x, alv.y) + thick));\n\n  float gx = smoothstep(0.4, 0.9, alv.x - 0.2);\n  float gy = smoothstep(0.4, 0.9, alv.y - 0.2);\n  float gs = mix(gx, gy, max(0.0, gy - gx));\n\n  g *= (0.5 + (0.5 * lf.x));\n  gs = mix(gs, gs * grain.y, lf.x);\n\n  col = mix(col, ((c5 + grain.y / 2.)) / 1.3,\n            clamp(g * (hf3.z + hf3.y + hf3.x + (lf.x / 3.)), 0.0, 1.0));\n  col = mix(col, col * col, gs);\n\n  col = mix(col, col * col, hf3.x * lf.y);\n\n  float cracks = smoothstep(0.02, 0.1, lf2.x);\n\n  col = mix(col, col * c5, cracks * grain.x * lf.z);\n\n  m.spec = clamp((g + (gs * 0.3)) + ((pow(cracks, 3.0) * lf.x) / 3.), 0.0, 1.0);\n  \n  m.rough = clamp((grain.y*(1.0-(gs*0.5))) + hf3.x, 0.2, 1.0);\n\n  // return vec3(gs);\n\n  return col;\n}\n\n//#define DEBUG_TEXTURE checkerTexture\n\nvec3 checkerTexture(TEXTURE_SIGNATURE) {\n    vec2 id = floor(uv*2.);\n    return vec3(clamp(mod(id.x-id.y, 2.), 0.0, 1.0));\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.uv * 4.;\n    vec3 p = data.p;\n    \n    vec3 col = grassTexture(uv, p, data.m);\n    \n    float e = 0.01;\n    vec3 bump = normalize(luma(col) - vec3(\n        luma(grassTexture(uv + vec2(e, 0), p, data.m)),\n        luma(grassTexture(uv + vec2(0, e), p, data.m)),\n        0.29\n    ));\n    bump = fixNormal(data.n, bump, 0.9);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec2 uv = data.uv/2.;\n    vec3 p = data.p;\n    \n    return brickTexture(uv, p, data.m);\n}\n\nvec3 getAlbedoHouse(inout Data data) {\n    vec2 uv = data.uv/2.;\n    vec3 p = data.p;\n    \n    vec3 col = brickTexture(uv, p, data.m);\n    \n    float e = 0.007;\n    vec3 bump = normalize(luma(col) - vec3(\n        luma(brickTexture(uv + vec2(e, 0), p, data.m)),\n        luma(brickTexture(uv + vec2(0, e), p, data.m)),\n        0.4\n    ));\n    bump = fixNormal(data.n, bump, 0.9);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoHouseRoof(inout Data data) {\n    vec2 uv = data.uv/2.;\n    uv = vec2(uv.y, uv.x);\n    vec3 p = data.p;\n    \n    vec3 col = ceilTexture(uv, p, data.m);\n    \n    float e = 0.007;\n    vec3 bump = normalize(luma(col) - vec3(\n        luma(ceilTexture(uv + vec2(e, 0), p, data.m)),\n        luma(ceilTexture(uv + vec2(0, e), p, data.m)),\n        0.5\n    ));\n    bump = fixNormal(data.n, bump, 0.9);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoLamp(inout Data data) {\n    vec2 uv = data.uv*0.3;\n    uv = vec2(uv.y, uv.x);\n    vec3 p = data.p;\n    \n    vec3 col = rustyMetalTexture(uv, p, data.m);\n    \n    float e = 0.02;\n    vec3 bump = normalize(luma(col) - vec3(\n        luma(rustyMetalTexture(uv + vec2(e, 0), p, data.m)),\n        luma(rustyMetalTexture(uv + vec2(0, e), p, data.m)),\n        0.5\n    ));\n    bump = fixNormal(data.n, bump, 0.9);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoCeilLamp(inout Data data) {\n    vec2 uv = data.uv*0.3;\n    uv = vec2(uv.y, uv.x);\n    vec3 p = data.p;\n    \n    return rustyMetalTexture(uv, p, data.m);\n}\n\nvec3 getAlbedoShinyBox(inout Data data) {\n    vec2 uv = data.uv*0.3;\n    uv = vec2(uv.y, uv.x);\n    vec3 p = data.p;\n    \n    vec3 col = rustyMetalTexture(uv, p, data.m);\n    \n    data.m.rough = 0.0;\n    data.m.spec = 1.0;\n    data.m.metallic = 1.;//luma(col);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_SHINY_BOX: return getAlbedoShinyBox(data); break;\n        case ID_HOUSE: return getAlbedoHouse(data); break;\n        case ID_HOUSE_ROOF: return getAlbedoHouseRoof(data); break;\n        case ID_LAMP: return getAlbedoLamp(data); break;\n        case ID_CEIL_LAMP: return getAlbedoCeilLamp(data); break;\n    }\n    \n    return checkerTexture(data.uv, data.p, data.m);\n}\n\n\nvec3 getSky(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec2 uv = rd.xz/rd.y;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    \n    vec3 blue = vec3(0.29, 0.66, 0.9);\n    \n    vec3 col = pow(blue, vec3(1.0 + dotup*2.));\n    if (dotup < 0.0) return col;\n    \n    float time = T*0.1;\n    \n    vec2 shift = vec2(cos(time), sin(time));\n    \n    shift -= ro.xz*0.01;\n    \n    float seed = 0.029189815;\n    \n    vec3 lf = noise6(uv + (shift*1.6), seed, 1.5); seed += 0.2828185;\n    shift += (lf.xy*lf.xy)*0.05;\n    time += (lf.x+lf.y+lf.z)*0.1;\n    vec3 hf = noise6(uv - (shift*0.2), seed, 32.0); seed += 0.923337;\n    shift += hf.xz*0.1;\n    time += (hf.x+hf.y+hf.z)*0.05;\n    vec3 mixer = noise6(uv + (shift*0.5), seed, 0.9); seed += 1.09288744;\n    vec3 mixer2 = abs(normalize(reflect(cross(mixer, lf), hf)));\n    vec3 invN = noise6(uv - shift, seed, 2.1); seed += 0.87388222;\n \n    \n    float clouds = 0.0;\n    \n    float low = mix(mix(lf.x, lf.y, mixer.x), lf.z, mixer.y);\n    float high = mix(mix(hf.x, hf.y, mixer.y), hf.z, mixer.z);\n    float inv = mix(mix(invN.x, invN.y, mixer.y), invN.z, mixer.x);\n    inv = clamp(inv*inv*2., 0.0, 1.0);\n    \n    clouds = mix(low, high, mix(mixer2.x, 0.5+(0.5*sin(time+(invN.z*0.1))), mixer.z*(0.5+(0.5*cos(time+1.029828312)))));\n    clouds = mix(clouds, mixer.z*hf.x, mixer.y*hf.z*(0.5+(0.5*sin(time))));\n    clouds = mix(clouds, 0.0, inv);\n  //  clouds = mix(clouds, lf.y, mixer.z);\n  //  clouds = mix(clouds, hf.y, mixer2.x);\n   // clouds = mix(clouds, lf.z, mixer2.y);\n    //clouds = mix(clouds, hf.z, mixer2.z);\n   clouds = clamp(pow(clouds, 1.0+(invN.y*invN.y*2.)), 0.0, 1.0);\n   \n   clouds *= clamp(dotup*40., 0.0, 1.0);\n    \n    col = mix(col + clouds, mix(col, vec3(1.0), clouds), clamp((mixer.x+mixer.y+mixer.z)/3., 0.0, 1.0));\n   // col += clouds;\n    \n    return col;\n}\n\nvec3 lightEffect(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    float diff = abs(distance(ro, light.p) - data.d);\n    float distLight = distance(ro, light.p);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: {\n            col += light.c * light.s * pow(VdotL, 8.);\n            col *= smoothstep(1.1, 16.0+(pow(VdotL, 4.)*8.), data.d);\n        }; break;\n        case LIGHT_POINT: {\n            col += (light.c * light.s * pow(VdotL, 8.)) / max(0.001, pow(distance(light.p, ro), 2.0));\n            float k = 1.0-smoothstep(0.0, 1.0, max(0.0, distLight - data.d));\n            col *= k;\n        }; break;\n        case LIGHT_DIR: {\n            col += (light.c * light.s * pow(max(0.0, dot(rd, normalize(light.p - ro))), 32.));\n            float k = max(0.0, smoothstep(5., 7.2, data.d)) / max(0.0001, distance(light.p, ro));\n            col *= k;\n        }; break;\n    }\n    \n    \n\n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 albedo) {\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p));\n        \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 3\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float dist) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.69), 2.0, LIGHT_AMBIENT);\n    lights[1] = Light(vec3(0, GROUND_LEVEL+5.6, 0), vec3(0.), vec3(0.97, 0.55, 0.33), 9., LIGHT_POINT);\n    lights[2] = Light(\n        LAMP_POS + vec3(0, GROUND_LEVEL+LAMP_HEIGHT-0.5, -1.),\n        vec3(0, 1., 0),\n        vec3(0.97, 0.55, 0.33),\n        4.,\n        LIGHT_DIR\n    );\n    \n    dist = FAR;\n    \n    #if DEBUG_LIGHTS\n    {\n        float ddist = FAR;\n        for (int j = ZERO; j < NUM_LIGHTS; j++) {\n            Light light = lights[j];\n            if (light.type == LIGHT_AMBIENT) continue;\n\n            float dist = 0.0;\n            for (int i = ZERO; i < STEPS; i++) {\n                vec3 p = ro+rd*dist;\n                vec3 pp = p - light.p;\n                float next = length(pp) - 0.2;\n                dist += next;\n                if (abs(next) <= NEAR) break;\n                if (abs(dist) >= FAR) break;\n            }\n            \n            ddist = min(ddist, dist);\n\n        }\n        \n        if (ddist < FAR) {\n            col += 1.;\n        }\n    }\n    #endif\n    \n    vec3 mixf = vec3(1.0);\n    for (int j = ZERO; j < 2; j++) {\n        if (march(data, ro, rd)) {\n            if (j <= 0) {\n                dist = data.d;\n            }\n            vec3 n = data.n;\n            vec3 albedo = getAlbedo(data);\n            vec3 diffuse = albedo / M_PI;\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                col += forEachLight(data, light, ro, rd, albedo) * mixf;\n                col += lightEffect(data, light, ro, rd) * mixf;\n            }\n            float rough = data.m.rough;\n            if (rough >= 0.9999 || length(mixf) <= 0.0) break;\n            \n            \n            vec3 ref = reflect(rd, n);\n            vec3 rdir = hemiDir(data.p, n);\n            ref = normalize(mix(ref, normalize(ref+rdir), pow(rough, 2.5)));\n            rd = ref;\n            \n            \n            float dd = data.d / FAR;\n            float idd = max(0.0, 1.0 - dd);\n            ro = data.p;\n            ro += n*NEAR*2.;\n            data.skip = data.id == ID_HOUSE ? 0 : data.id;\n            mixf *= max(0.0, 1.0 - rough);\n           // mixf = mix(mixf, mixf * 0.872123, rough);\n            \n            float NdotV = abs(dot(n, rd));\n            \n            vec3 f0 = mix(vec3(0.04), diffuse, data.m.metallic);\n            vec3 envBRDF = EnvBRDFApprox(mix(col, diffuse, data.m.metallic), rough*rough, NdotV);\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough);\n            mixf *= (F * envBRDF.x + envBRDF.y);\n            mixf = clamp(mixf, 0.0, 1.0);\n            if (length(mixf) <= 0.00000001) break;\n        } else {\n            col += getSky(data, lights[0], ro, rd) * mixf;\n            col += lightEffect(data, lights[0], ro, rd) * mixf;\n            break;\n        }\n    }\n    \n    float depth = dist / FAR;\n    \n    col += smoothstep(0.19, 1.0, depth) * max(0.0, 1.0 - smoothstep(0.0, 0.33, dotup)) * depth * depth;\n  \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 1., -8.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if WALK\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    \n    ro += walk;\n    ro.y += fly.y;\n    \n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    \n    #else\n    if (length(m.xy) > 0.001 && m.z > 0.001) {\n        ro.z -= 16.;\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        ro.y += 4.0;\n    } else {\n        vec3 oro = vec3(0, 9., -32.);//vec3(cos(T)*32., 5.0, sin(T)*32.);//vec3(0, 5., -32.);\n        \n        ro = oro;\n        vec3 dir = vec3(0, 0, -1);\n        vec3 lookP = vec3(0, 0, 0);\n        vec3 ord = look(uv, lookP, ro);\n        rd = ord;\n        \n        float nrSteps = 21.0;\n        float transTime = 0.78;\n        float time = T*0.63;\n        float frame = 1.0;\n        \n        \n        ro = onCycle(ro, vec3(0, 1., -4.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(0.5, 1., -4.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-4., 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(0.0, 1., -4.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-2., 0, -16.), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, oro, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-3., 0, 1.5), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(-10.0, 4.0, -32.0), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(-16., 10., -32.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(-32., 16., -20.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(-32., 9., 8.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(-24., 5., 10.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(-16., 4, 20.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(12., 3., 10.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(11., 3.5, 7.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(10., 2.9, 6.9), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(8.3, 2., 5.0), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(8.0, 2., 4.9), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(7.7, 2.1, 5.5), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(2., 2.3, 5.6), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(2., 2.4, -2.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-1., 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(2., 1.5, -3.), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-3., 0, -1.), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, vec3(1., 1.5, -3.5), time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-2., 0, -16.), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, oro, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0, 0, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        \n        lookP += (0.5+(0.5*cos(time)))*vec3(cos(time*3.), sin(time*3.), sin(((time+0.982713)*3.)+0.372715))*1.6;\n        ro += (0.5+(0.5*sin(time)))*vec3(sin(time*2.), cos(time*2.), cos((time+1.293818759)*2.))*0.1;\n        \n\n        rd = look(uv, lookP, ro);\n\n    }\n    #endif\n    \n    ro.y += GROUND_LEVEL + 1.;\n    ro.y = max(GROUND_LEVEL+1., ro.y);\n   // ro.z += T*10.;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec4 m = iMouse;\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    m.xy = (m.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float dist = FAR;\n    \n  // col = vec3(gnoise(uv*10.238123, 3.292312, 2.2));\n   // O = vec4(col, 1.);\n    //return;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, dist);\n    col += (col*col*luma(col));\n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n\n    \n    O = vec4(clamp(col, 0.0, 1.0), dist/FAR);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}