{"ver":"0.1","info":{"id":"XtGXzh","date":"1482693510","viewed":222,"name":"#Devember 2016 - day 24","username":"theGiallo","description":"Learning terrain raymarching.\narrows or WASD + C/SPACE and mouse (left)","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["terrain","firstperson","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks Fabrice https://www.shadertoy.com/view/lsXXzN\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n\nconst vec2 PLAYER_POS_PX = vec2(0.0,0.0);\nconst vec2 PLAYER_LOOK_PX = vec2(1.0,0.0);\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_UP    = 38.5 / 256.0;\nconst float KEY_LEFT  = 37.5 / 256.0;\nconst float KEY_DOWN  = 40.5 / 256.0;\nconst float KEY_RIGHT = 39.5 / 256.0;\nconst float KEY_STATUS = 0.5/3.0;\n\n\nvec4\nload_value( in vec2 tx_code )\n{\n    return texture( iChannel1, (tx_code+0.5)/iChannelResolution[1].xy, -100.0 );\n}\n\n#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define RENDER_REFLECTIONS 0\n#define DRAW_ITERATIONS_GRADIENT 0\n#define RAYM_MAX_ITERS 1000\n#define SHADOW_MAX_ITERS 16\n\n#define WALKING 1\n#define HEAD_BOBBING 1\n#define WALK_PERFECT_CENTER 0\n\n#define INVERTED_Y_AXIS 0\n\n#define MPt vec2\n#define distance x\n\n\nconst vec3 point_light_pos = vec3(12.0,0.0,3.8);\nconst float point_light_int = 1.0;\nconst float point_light_radius = 6.0;\nconst vec3 rep = vec3(0.0,3.0,0.0);\nconst int nl = int( ceil( 2.0 * point_light_radius / rep.y ) );\n\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n    \n#define MAT_PLASTIC  0.0\n#define MAT_ORANGE   1.0\n#define MAT_RED      2.0\n#define MAT_GREEN    3.0\n#define MAT_BLUE     4.0\n#define MAT_FLOOR_W  5.0\n#define MAT_FLOOR_B  6.0\n#define MAT_METAL_GRID 7.0\n#define MAT_TUNNEL_WALL_W 8.0\n#define MAT_COUNT    9\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nfloat\nmanhattan( in vec3 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\nfloat\nsum( in vec2 p )\n{\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nsum( in vec3 p )\n{\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\n\n#define pow2(v) (v*v)\n#define pow3(v) (v*v*v)\n\nfloat\npow4( in float v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npow4( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow4( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nfloat\npow6( in float v )\n{\n    float ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow6( in vec2 v )\n{\n    vec2 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec3\npow6( in vec3 v )\n{\n    vec3 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow8( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow8( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npowv( in vec2 v, in float exp )\n{\n    return pow( v, vec2(exp,exp) );\n}\nvec3\npowv( in vec3 v, in float exp )\n{\n    return pow( v, vec3(exp,exp,exp) );\n}\n\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec3\nrgb_from_hsv( vec3 hsv )\n{\n\tvec3 ret;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_SRGB vec3(1.0,0.4,0.0)\n#define ORANGE_RGB powv(vec3(1.0,0.4,0.0),2.2)\n#define T_EPS 0.001\n\nfloat\nminv( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\n\n#define length3( v ) ( pow(sum(pow3(v)),1.0/3.0) )\n#define length4( v ) ( pow(sum(pow3(v)),1.0/4.0) )\n#define length6( v ) ( pow(sum(pow3(v)),1.0/6.0) )\n#define length8( v ) ( pow(sum(pow3(v)),1.0/8.0) )\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rx * Ry * Rz;\n\treturn (vec4(p,1.0)*m).xyz;\n}\nvec3\nrotate_inv( in vec3 r, in vec3 p )\n{\n    r = -r;\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n// NOTE(theGiallo): s.x radius, s.y Y axis rotation, s.z Z axis rotation\nvec3\ncartesian_from_spherical( in vec3 s )\n{\n\tmat4 Ry = mat4(\n\t   vec4(  cos(s.y), 0.0, sin(s.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(s.y), 0.0, cos(s.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(s.z), -sin(s.z), 0.0, 0.0 ),\n\t   vec4( sin(s.z),  cos(s.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Ry * Rz;\n\treturn (vec4(0.0,0.0,s.x,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate_inv( a, p );\n}\n\n#if 0\nvec3\nrepeat( in vec3 rep, in vec3 p )\n{\n    return mod(p,rep) + 0.5*rep;\n}\n#endif\n\nvec3\nrepeated( in vec3 rep, in vec3 p )\n{\n    return mod( p, rep ) - 0.5 * rep;\n}\n\nvec2\nunion_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nintersect_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nsubtract_op( in vec2 p0, in vec2 p1 )\n{\n    p0.x = -p0.x;\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nmix_op_( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    float h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist)/h_max_dist;\n    p1.x = (p1.x-h_max_dist)/h_max_dist;\n    float p02 = p0.x*p0.x;\n    float p12 = p1.x*p1.x;\n    float v = ( p0.x + p1.x )*0.5;\n    vec2 ret = vec2(max_dist * v, p0.y );\n\n    return ret;\n}\nvec2\nmix_op_( in vec2 p0, in vec2 p1, float max_dist, float m0 )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    float h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist)/h_max_dist;\n    p1.x = (p1.x-h_max_dist)/h_max_dist;\n    float v = mix( p0.x, p1.x, m0 );\n    vec2 ret = vec2(max_dist * v, p0.y );\n\n    return ret;\n}\nvec2\nmix_op_( in vec2 p0, in vec2 p1, vec2 max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist.x &&\n                  p1.x > 0.0 && p1.x < max_dist.y;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist.x)/h_max_dist.x;\n    p1.x = (p1.x-h_max_dist.y)/h_max_dist.y;\n    float v = mix( p0.x, p1.x, 0.5 );\n    vec2 ret = vec2(minv(max_dist) * v, p0.y );\n\n    return ret;\n}\n\nvec2\nmix_op_9avg( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 m1 = mix_op_(p0,p1,vec2(max_dist*0.9, max_dist*0.1));\n    vec2 m2 = mix_op_(p0,p1,vec2(max_dist*0.8, max_dist*0.2));\n    vec2 m3 = mix_op_(p0,p1,vec2(max_dist*0.7, max_dist*0.3));\n    vec2 m4 = mix_op_(p0,p1,vec2(max_dist*0.6, max_dist*0.4));\n    vec2 m5 = mix_op_(p0,p1,vec2(max_dist*0.5, max_dist*0.5));\n    vec2 m6 = mix_op_(p0,p1,vec2(max_dist*0.4, max_dist*0.6));\n    vec2 m7 = mix_op_(p0,p1,vec2(max_dist*0.3, max_dist*0.7));\n    vec2 m8 = mix_op_(p0,p1,vec2(max_dist*0.2, max_dist*0.8));\n    vec2 m9 = mix_op_(p0,p1,vec2(max_dist*0.1, max_dist*0.9));\n    #if 0\n    return vec2((m1.x+m2.x+m3.x+m4.x+m5.x+m6.x+m7.x+m8.x+m9.x)/9.0,m9.y);\n    #else\n    return\n    vec2( minv(\n       vec3( minv(vec3(m1.x,m2.x,m3.x)),\n             minv(vec3(m4.x,m5.x,m6.x)),\n             minv(vec3(m7.x,m8.x,m9.x)) ) ), m9.y );\n    #endif\n}\n\nvec2\nmix_op_p2( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 d;\n    d.x = p1.x - pow2( ( max_dist - p0.x ) / max_dist ) * max_dist;\n    d.y = p0.x - pow2( ( max_dist - p1.x ) / max_dist ) * max_dist;\n    return vec2((d.x+d.y)*0.5,p0.y);\n    //return vec2(min(d.x,d.y),p0.y);\n}\n\n// IQ's polynomial smooth min (k = 0.1);\nfloat\nsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2\nsmin_op( in vec2 p0, in vec2 p1, float max_dist )\n{\n    float m = smin(p0.x,p1.x,max_dist);\n    return vec2(m,m-p0.x>=m-p1.x?p0.y:p1.y);\n}\n\nvec2\nmix_op( in vec2 p0, in vec2 p1, float max_dist )\n{\n    if ( mod( iTime, 2.0 ) < 1.0 )\n    {\n        return smin_op(p0,p1,max_dist);\n    } else\n    {\n    \treturn mix_op_9avg(p0,p1,max_dist);\n    }\n#if 0\n\treturn mix_op_p2(p0,p1,max_dist);\n#endif\n}\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( maxv( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\n\nfloat\nhalf_space_sd( in vec3 p )\n{\n    return p.z;\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\nfloat\ncylinder_sd( in float r, in vec3 p )\n{\n    return length( p.xy ) - r;\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );\n}\n\nfloat\nhalf_cone_pos_sd( in vec2 c, in vec3 p )\n{\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncone_sd( in vec2 c, in vec3 p )\n{\n    p = abs(p);\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncapped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )\n{\n    float R1z = (r1*h)/(r2-r1);\n    float R2z = R1z + h;\n    p = at_pos(vec3(0.0,0.0,-R1z),p);\n\tvec2 c = vec2(r2/R2z,1.0);\n\treturn\n\tmax( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),\n         half_cone_pos_sd( c, p )\n       );\n}\n\n// NOTE(theGiallo): d.x is the depth of the prism(or height), d.y the radius\n// NOTE(theGiallo): depth on x axis, diameter on y axis\nfloat\nhex_prism_sd( in vec2 dr, in vec3 p )\n{\n    p = abs(p);\n    return max(p.x-dr.x*0.5,max(p.y*0.866025+p.z*0.5,p.z)-0.866025*dr.y);\n}\n\nfloat\ntri_prism_sd( in vec2 ds, in vec3 p )\n{\n  \tp.xy = abs(p.xy);\n    \n    return max( p.x - ds.x*0.5, max( p.y * 0.866025 + 0.5 * p.z - ds.y * 0.433012702, -p.z ) );\n}\n\nfloat\ntri_prism_bary_sd( in vec2 ds, in vec3 p )\n{\n    p.z += ds.y * 0.288675135;\n    \n    return tri_prism_sd( ds, p );\n}\n\nfloat\ntri_prism_bary_r_sd( in vec2 dr, in vec3 p )\n{\n    dr.y = dr.y * 1.732050808;\n    \n    return tri_prism_bary_sd( dr, p );\n}\n\nfloat\ncline_sd( in vec3 a, in vec3 b, in float r, in vec3 p )\n{\n    vec3 ap = p - a, ab = b - a;\n    float t = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    return length( ap - ab * t ) - r;\n}\n\nfloat\nellipsoid_sd( in vec3 r3, in vec3 p )\n{\n    return ( length( p/r3 ) - 1.0 ) * minv(r3);\n}\n\nfloat\nsphere8_sd( in float sph_r, in vec3 p )\n{\n    return length8( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus82_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus88_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length8(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n\nfloat\nsphere4_sd( in float sph_r, in vec3 p )\n{\n    return length4( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus42_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus44_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length4(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\nfloat\nsphere3_sd( in float sph_r, in vec3 p )\n{\n    return length3(abs(p)) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus32_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus33_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length3(abs(p.xy))-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\nfloat\nspheremh_sd( in float sph_r, in vec3 p )\n{\n    return manhattan(p) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus2mh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmh2_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return manhattan(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmhmh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n        return manhattan(q)-torus.y;\n}\n\n\nfloat\ncapped_cylinder8_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length8( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length8( max(d, 0.0) );\n}\n\nfloat\ncapped_cylindermh_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( manhattan( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + manhattan( max(d, 0.0) );\n}\n    \n//////////\n\nfloat\nheightmap_function( vec2 p )\n{\n    \n    /*\n0.09346\t0.118792\t0.09346\n0.118792\t0.150991\t0.118792\n0.09346\t0.118792\t0.09346\n    */\n\n    float h = -1.0;\n    if ( p.x < -1.0 )\n    {\n        float eps = 1.0;\n        h = 0.1 * ( sin( p.x * TAU ) + cos( p.y * TAU ) ) + 0.5;\n        #if 0\n        vec2 mp_ = p * vec2(11.0,13.0);\n        vec2 mp = floor( mp_ );\n        float dn = 0.01;\n        float n = cos( mod( ( mp.x - eps ) * 65537.0 + 65111.0 * ( mp.y + eps ), PI ) ) * 0.09346  +\n                  cos( mod( ( mp.x       ) * 65537.0 + 65111.0 * ( mp.y + eps ), PI ) ) * 0.118792 +\n                  cos( mod( ( mp.x + eps ) * 65537.0 + 65111.0 * ( mp.y + eps ), PI ) ) * 0.09346  +\n                  cos( mod( ( mp.x - eps ) * 65537.0 + 65111.0 * ( mp.y       ), PI ) ) * 0.118792 +\n                  cos( mod( ( mp.x       ) * 65537.0 + 65111.0 * ( mp.y       ), PI ) ) * 0.150991 +\n                  cos( mod( ( mp.x + eps ) * 65537.0 + 65111.0 * ( mp.y       ), PI ) ) * 0.118792 +\n                  cos( mod( ( mp.x - eps ) * 65537.0 + 65111.0 * ( mp.y - eps ), PI ) ) * 0.09346  +\n                  cos( mod( ( mp.x       ) * 65537.0 + 65111.0 * ( mp.y - eps ), PI ) ) * 0.118792 +\n                  cos( mod( ( mp.x + eps ) * 65537.0 + 65111.0 * ( mp.y - eps ), PI ) ) * 0.09346;\n        n *= dn;\n        h += n;\n        #endif\n    }\n    return h;\n}\n\nvec3\nterrain_normal( in vec3 pos )\n{\n    vec3 eps = vec3( max(0.02,T_EPS),0.0,0.0);\n\treturn normalize( vec3(\n           heightmap_function( pos.xy + eps.xy ) - heightmap_function( pos.xy - eps.xy ),\n           heightmap_function( pos.xy + eps.yx ) - heightmap_function( pos.xy - eps.yx ),\n           2.0 * T_EPS ) );\n}\n\n#define TERRAIN_MAT_IDX_BASE 100\n\nvec2\nraymarch_terrain( in vec3 start, in vec3 dir, in float max_distance )\n{\n    vec2 ret = vec2(-1.0);\n    const float min_t = 0.001;\n\tfloat max_t = max_distance;\n    float delta = 0.01;\n    const int max_iterations = 10000;\n    float t = min_t;\n    float old_h = 0.0, old_pz = 0.0;\n    for ( int it = 0; it != max_iterations; ++it )\n    {\n        vec3 p = start + dir * t;\n        float h = heightmap_function( p.xy );\n        if ( p.z < h )\n        {\n            ret.x = t - delta + delta * ( old_h - old_pz ) / ( p.z - old_pz - h + old_h );\n            ret.y = MAT_METAL_GRID + float(TERRAIN_MAT_IDX_BASE);\n            return ret;\n        }\n        ret.x = t;\n        old_pz = p.z;\n        old_h = h;\n    \tdelta = 0.01*t;\n        t += delta;\n        if ( t > max_t )\n        {\n            ret.x = -1.0;\n            return ret;\n        }\n    }\n    ret = vec2(-1.0);\n    return ret;\n}\n\nvec2\nmap( in vec3 pos )\n{    \n    float angle4 = iTime*TAU*0.25;\n    \n    MPt res;\n    res.distance = 1e38;\n\n    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );\n    res = union_op( MPt( plane_sd( pos ),\n                         MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m ),\n                    res );\n    \n    const float axis_r = 0.05;\n    res = union_op( MPt( sphere_sd( axis_r*2.0, at_pos( vec3(0.0), pos ) ),\n                         MAT_PLASTIC ), res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(1.0,0.0,0.0), axis_r, pos ),\n                         MAT_RED ),res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,1.0,0.0), axis_r, pos ),\n                         MAT_GREEN ),res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,0.0,1.0), axis_r, pos ),\n                         MAT_BLUE ),res );\n    \n    \n    \n    \n    // NOTE(theGiallo): light\n    float lamp_r = 0.2, pole_hh=0.5;\n    vec3 lp = repeated( rep,at_pos( point_light_pos + vec3(0.0,0.0,0.15), pos ));\n    res =\n       union_op(\n           MPt( capped_cylinder_sd( vec2(0.02,pole_hh) , at_pos( vec3(0.0,0.0,lamp_r+pole_hh),lp ) ), MAT_PLASTIC ),\n           res\n       );\n    res =\n       union_op(\n           intersect_op(\n              subtract_op(\n                 MPt( sphere_sd(\n                         lamp_r-0.01, lp\n                      ), MAT_PLASTIC\n                    ),\n                 MPt( sphere_sd(\n                         lamp_r, lp\n                      ), MAT_PLASTIC\n                    )\n               ),\n               MPt( aab_sd( vec3(lamp_r*2.0), at_pos( vec3(0.0,0.0,lamp_r),lp) ), MAT_PLASTIC )\n            ), res );\n    \n    vec3 op = pos;\n    pos = repeated( vec3(0.0,4.0,0.0), pos );\n    \n    // NOTE(theGiallo): tunnel section\n    float X = 12.0;\n    vec3 P = at_pos(vec3(X,0.0,2.5), pos );\n    res =\n       union_op(\n          subtract_op(\n             union_op(\n                MPt( capped_cylinder_sd (vec2(2.0,5.0),\n                                         at_angle( vec3(HPI,0.0,0.0),\n                                                   P ) ), MAT_TUNNEL_WALL_W ),\n                intersect_op(\n                   MPt( capped_cylinder_sd (vec2(2.05,0.25),\n                                            at_angle( vec3(HPI,0.0,0.0),\n                                                      repeated( vec3(0.0,1.0,0.0),\n                                                                P ) ) ), MAT_ORANGE ),\n                   MPt( aab_sd(vec3(5.0,4.0,3.0),at_pos(vec3(0.0,0.0,1.0),P) ), MAT_TUNNEL_WALL_W ) )\n                ),\n             MPt( aab_sd(vec3(5.0,4.05,5.0),P ), MAT_TUNNEL_WALL_W )\n          ),\n          res );\n\n    // NOTE(theGiallo): grid\n    res =\n       union_op(\n          subtract_op(\n             MPt( aab_sd( vec3(0.02,0.02,0.1),\n                          repeated( vec3(0.02,0.02,0.0), at_angle( vec3(0.0,0.0,QPI),\n                                    at_pos( vec3(X,0.0,1.0),\n                                            pos) ) ) ), MAT_METAL_GRID ),\n             MPt( aab_sd(vec3(2.5,4.0,0.02),at_pos(vec3(X,0.0,1.0),pos) ), MAT_METAL_GRID )\n          ),\n          res );\n\n    \n    pos = op;   \n    \n\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\nvec2\nraymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )\n{\n    vec2 mp = vec2(-1.0);\n    for ( int it=0; it!=RAYM_MAX_ITERS; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y = mp.y * 10000.0 + float(it);\n        #endif\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        t += mp.distance * 0.4;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    \n    float max_dist = t == -1.0 ? t_max : t;\n    vec2 terrain_mat =\n    raymarch_terrain( start, dir, max_dist );\n    if ( terrain_mat.x >= 0.0 )\n    {\n        mp = terrain_mat;\n        t = mp.x;\n    }\n    \n    return mp;\n}\n\nfloat\nshadow( in vec3 start, in vec3 dir )\n{\n    float ret = 1.0;\n    float c = 1.0;//step( mod( iTime, 4.0 ), 2.0 );\n    float t = 0.02, t_max = 16.0;\n    MPt mp;\n    \n    #if DRAW_ITERATIONS_GRADIENT\n    int it_;\n    #endif\n    for ( int it=0; it!=SHADOW_MAX_ITERS; ++it )\n    {\n\t    #if DRAW_ITERATIONS_GRADIENT\n\t    it_ = it;\n    \t#endif\n        vec3 here = start + dir * t;\n        mp = map( here );\n        ret = min( ret, 8.0*mp.distance/t);\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        \n        float inc;\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        inc = c * mp.distance * 0.4;\n\t\tinc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );\n        t += inc;\n    }\n    #if DRAW_ITERATIONS_GRADIENT\n    return float(it_);\n    #endif\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );\n\n    if ( t < 0.0 )\n    {\n        return 0.0;\n    }\n    //return 1.0;\n    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );\n    float th = 0.1;\n    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );\n}\n\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvec3\nrender_no_reflections( in Material materials_table[MAT_COUNT],\n                       in vec3 start, in vec3 dir, in float max_dist,\n                       inout float t, out vec3 normal, out int material_index )\n{\n    vec3 ret = rgb_from_hsv(vec3(0.57,0.5,0.7));\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n    vec3 sun_light_dir = normalize( rotate( vec3(0.0,0.0,0.0*iTime*TAU/16.0), vec3( -0.0, 1.0, -1.0 ) ) );\n\n    MPt mp = raymarch( start, dir, t, max_dist );\n    material_index = int(mp.y);\n    bool is_terrain = false;\n    if ( material_index >= TERRAIN_MAT_IDX_BASE )\n    {\n        is_terrain = true;\n        material_index -= TERRAIN_MAT_IDX_BASE;\n    }\n    Material mat;\n    for ( int i = 0; i != MAT_COUNT; ++i )\n    {\n        if ( i == material_index )\n        {\n            mat = materials_table[i];\n        }\n\t}\n\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        if ( is_terrain )\n        {\n        \tnormal = terrain_normal( point );\n        } else\n        {\n            normal = calc_normal( point, t );\n        }\n        // ret = 0.5 + normal * 0.5;return ret;\n        \n\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y += shadow( point, -sun_light_dir );\n        #else\n        float sh = is_terrain ? 1.0 : 1.0 - shadow( point, -sun_light_dir );\n        float diffuse = sh * max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = sh * pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );\n        #endif\n\n        float diffuse_pl = 0.0, spec_pl = 0.0;\n\n        for ( int i=0; i!=nl; ++i )\n        {\n        \tvec3 pld = -at_pos( point_light_pos + float(i)*rep, repeated( rep, point ) );\n        \tfloat ld = length( pld );\n        \tpld /= ld;\n        \tfloat ld2 = ld*ld;\n            float sh_pl = 0.0;\n\n        \t#if DRAW_ITERATIONS_GRADIENT\n        \tmp.y += shadow( point, pld );\n        \t#else\n        \tif ( ld <= point_light_radius )\n        \t{\n\t            sh_pl      = 1.0 - shadow( point, pld );\n\t        \tfloat diffuse_pl_ = sh_pl * max( 0.0, dot( normal, pld ) );\n\t        \tfloat spec_pl_    = sh_pl * pow( max( 0.0, dot( reflect( dir, normal ) , pld ) ), mat.shininess  );\n                diffuse_pl += diffuse_pl_ * point_light_int / ld2;\n                spec_pl    += spec_pl * point_light_int / ld2;\n\t    \t}\n            #endif\n        }\n        \n        #if !DRAW_ITERATIONS_GRADIENT\n        float ambient = 0.3;\n        ret = ( ( diffuse + diffuse_pl ) * mat.diffuse_reflection +\n                  ambient   * mat.ambient_reflection ) * mat.color +\n                ( spec + spec_pl  ) * mat.specular_reflection * sun_specular_color;\n        #endif\n    } else\n    if ( t == 0.0 )\n    {\n        ret = mat.color / ( 1.0 - 20.0 * mp.distance );\n    }\n    #if DRAW_ITERATIONS_GRADIENT\n    material_index = int(mp.y);\n    #endif\n    return ret;\n}\n\nvoid\ncamera_linear_gallery( in vec3 start, in vec3 obj_dist, in float sec_per_obj,\n                       out vec3 camera_pos )\n{\n    const int obj_count = 3;\n\n    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec3 p = vec3(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        p +=\n           ( start + obj_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n    }\n    camera_pos.xyz = p;\n}\n\nvoid\ncamera_radial_gallery_mirror( in vec3 center, in vec2 radial_start, in vec2 obj_radial_dist, in float radius, in float sec_per_obj,\n                       out vec3 camera_pos )\n{\n    const int obj_count = 6;\n\n    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec2 a = vec2(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        a +=\n           ( obj_radial_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n        \n    }\n    camera_pos.xyz = center + cartesian_from_spherical( vec3(radius,radial_start+a) );\n}\nvoid\ncamera_radial_gallery_loop( in vec3 center, in vec2 radial_start, in vec2 obj_radial_dist, in float radius, in float sec_per_obj,\n                       out vec3 camera_pos, out vec3 look )\n{\n    // NOT)theGiallo): set 1+ if you want a complete circle\n    const int obj_count = 9;\n\n    float u = decimal( iTime / ( float(obj_count) * sec_per_obj ) );\n    \n    \n    if ( iMouse.z > 0.0 )\n    {\n    \tvec2 mouse_u = iMouse.xy / iResolution.xy;\n        u = mouse_u.x;\n    }\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec2 a = vec2(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        a +=\n           ( obj_radial_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n        \n    }\n    camera_pos.xyz = cartesian_from_spherical( vec3(radius,radial_start+a) );\n    look = normalize(-camera_pos);\n    camera_pos.xyz += center;\n}\n\nvoid\nfirst_person_camera( in vec3 pos, in vec2 angles0, in vec2 angles, out vec3 camera_pos, out vec3 look )\n{\n    vec2 a = angles*( iMouse.yx/iResolution.yx * 2.0 - 1.0 );\n\t//a = vec2(0.0);\n    a.y = -a.y;\n    #if INVERTED_Y_AXIS\n    a.x = -a.x;\n    #endif\n    a += angles0;\n    \n    camera_pos.xyz = cartesian_from_spherical( vec3(0.075,a) );\n    look = normalize(-camera_pos);\n    camera_pos.xyz = pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col;\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 4.0 );\n\n    float time = iTime * PI * 0.06125;\n\n    vec3 d = vec3(6.0,0.0,0.0);\n    vec3 base = vec3(0.0,4.0,1.3);\n    \n    vec3 camera_pos;\n    vec3 look;\n\n    #if 0\n    \n    vec3 cp = vec3(12.0,0.0,2.8);\n    vec2 angles = vec2(PI*0.4,TAU*1.5);\n    vec2 angles0 = vec2(HPI,HPI);\n    first_person_camera( cp, angles0, angles, camera_pos, look );\n    \n    #if WALKING\n    \tfloat walk_speed = 1.4;\n    \tfloat walked = iTime*walk_speed;\n    \tfloat step_length = 0.6;\n    \tcamera_pos.y = mod(-walked,12.0);\n    \t#if HEAD_BOBBING\n    \tcamera_pos.z += 0.04*cos(walked*TAU/step_length);\n    \tcamera_pos.x += 0.04*cos(walked*TAU/(step_length*2.0));\n    \t#endif\n    \t#if !WALK_PERFECT_CENTER\n    \tcamera_pos.x += 0.2*sin(walked*TAU/64.0);\n    \t#endif\n    #endif\n    \n    #else\n    \n    vec4 player_pos = load_value( PLAYER_POS_PX );\n    camera_pos.xyz = player_pos.xyz;\n    camera_pos.z += 1.8;\n    vec4 player_look = load_value( PLAYER_LOOK_PX );\n    look = player_look.xyz;\n    \n    #endif\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = normalize(cross( look, up ));\n    vec3 img_up = cross( right, look );\n\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n\n    float max_dist = 1e3;\n    float max_dist_reflection = 1e1;\n    float t = 0.0, t1 = 0.0;\n    vec3 normal, normal1;\n    vec3 pos, pos1, dir1;\n\n    Material materials_table[MAT_COUNT];\n\n    materials_table[int(MAT_PLASTIC)].color = rgb_from_hsv( powv(vec3(0.083,0.1,1.0),2.2) );\n    materials_table[int(MAT_PLASTIC)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].specular_reflection = 1.0;\n    materials_table[int(MAT_PLASTIC)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].shininess           = 15.0;\n\n    materials_table[int(MAT_FLOOR_B)].color = vec3(0.7);\n    materials_table[int(MAT_FLOOR_B)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_B)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_B)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_B)].shininess           = 1.0;\n\n    materials_table[int(MAT_FLOOR_W)].color = vec3(1.0);\n    materials_table[int(MAT_FLOOR_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_W)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_W)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_W)].shininess           = 1.0;\n\n    materials_table[int(MAT_ORANGE)] = change_color(materials_table[int(MAT_PLASTIC)], ORANGE_RGB );\n    materials_table[int(MAT_RED   )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(1.0,0.0,0.0) );\n    materials_table[int(MAT_GREEN )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,1.0,0.0) );\n    materials_table[int(MAT_BLUE  )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,0.0,1.0) );\n\n    materials_table[int(MAT_METAL_GRID)].color = rgb_from_hsv( powv(vec3(225.0/360.0,0.06,0.65),2.2) );\n    materials_table[int(MAT_METAL_GRID)].diffuse_reflection  = 0.8;\n    materials_table[int(MAT_METAL_GRID)].specular_reflection = 1.1;\n    materials_table[int(MAT_METAL_GRID)].ambient_reflection  = 0.9;\n    materials_table[int(MAT_METAL_GRID)].shininess           = 16.0;\n\n    materials_table[int(MAT_TUNNEL_WALL_W)].color = rgb_from_hsv( powv(vec3(0.083,0.1,1.0),2.2) );\n    materials_table[int(MAT_TUNNEL_WALL_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_TUNNEL_WALL_W)].specular_reflection = 1.0;\n    materials_table[int(MAT_TUNNEL_WALL_W)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_TUNNEL_WALL_W)].shininess           = 15.0;\n    \n    int material_index;\n    col.rgb = render_no_reflections( materials_table, start, dir, max_dist, t, normal, material_index );\n    #if DRAW_ITERATIONS_GRADIENT\n    float it = mod( float(material_index), 10000.0 ),\n          it1 = 0.0;\n    material_index /= 10000;\n    #endif\n    \n    float max_iters = float(RAYM_MAX_ITERS) + 2.0 * float((1+nl)*SHADOW_MAX_ITERS) + 1.0;\n#if RENDER_REFLECTIONS\n    max_iters += float(RAYM_MAX_ITERS) + 32.0;\n    pos = start + dir * t;\n    float fe = 0.01;\n    float cn = dot(normal,-dir);\n    float sn = 1.0 - cn*cn;\n    if ( t > 0.0 &&\n         ( material_index == int(MAT_FLOOR_W) ||\n           material_index == int(MAT_FLOOR_B) ||\n           material_index == int(MAT_TUNNEL_WALL_W)\n         )\n       )\n    {\n        int material_index1;\n        dir1 = reflect(dir,normal);\n        t1 = 0.01;\n        vec3 reflection;\n    \treflection = render_no_reflections( materials_table, pos, dir1, max_dist_reflection, t1, normal1, material_index1 );\n        \n\t    #if DRAW_ITERATIONS_GRADIENT\n    \tit1 = mod( float(material_index1), 10000.0 );\n    \t#else\n        if ( t1 > 0.0 )\n        {\n            t1 += 1.0;\n        \tfloat a = ( sn*sn * 0.9 / t1 );\n        \tcol.rgb = col.rgb * ( 1.0 - a ) + a * reflection;\n        }\n        #endif\n    }\n#endif\n    #if DRAW_ITERATIONS_GRADIENT\n\t   col.rgb = rgb_from_hsv(vec3(float(it+it1)/(1.0*max_iters),1.0,1.0));\n    #endif\n    \n    // NOTE(theGiallo): gamma correction\n\tcol.rgb = pow( col.rgb, vec3(0.4545) );\n\n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// NOTE(theGiallo): user settings\n#define INVERTED_Y_AXIS 0\n#define PLAYER_SPEED_MPS 1.3\n#define PLAYER_VSPEED_MPS 1.3\n\n// Thanks Fabrice https://www.shadertoy.com/view/lsXXzN\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n\n\nconst vec2 PLAYER_POS_PX = vec2(0.0,0.0);\nconst vec2 PLAYER_LOOK_PX = vec2(1.0,0.0);\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_C = 67.5 / 256.0;\nconst float KEY_UP    = 38.5 / 256.0;\nconst float KEY_LEFT  = 37.5 / 256.0;\nconst float KEY_DOWN  = 40.5 / 256.0;\nconst float KEY_RIGHT = 39.5 / 256.0;\nconst float KEY_SPACE = 32.5 / 256.0;\nconst float KEY_STATUS = 0.5/3.0;\n\n\n#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel1, (uv_code+0.5)/iChannelResolution[1].xy, -100.0 );\n}\n\nfloat\nisInside( vec2 p, vec2 c )\n{\n    vec2 d = abs( p - 0.5 - c ) - 0.5;\n    return - max( d.x, d.y );\n}\nbool\nis_value( in vec2 frag_coord, in vec2 tx_code )\n{\n    return isInside( frag_coord, tx_code ) > 0.0;\n//    return (uv_code+0.5)/iChannelResolution[0].xy == uv;\n}\n\n\n// NOTE(theGiallo): s.x radius, s.y Y axis rotation, s.z Z axis rotation\nvec3\ncartesian_from_spherical( in vec3 s )\n{\n\tmat4 Ry = mat4(\n\t   vec4(  cos(s.y), 0.0, sin(s.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(s.y), 0.0, cos(s.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(s.z), -sin(s.z), 0.0, 0.0 ),\n\t   vec4( sin(s.z),  cos(s.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Ry * Rz;\n\treturn (vec4(0.0,0.0,s.x,1.0)*m).xyz;\n}\n\n\nvoid\nfirst_person_look( in vec2 angles0, in vec2 angles, out vec3 look )\n{\n    vec2 a = angles*( iMouse.yx/iResolution.yx * 2.0 - 1.0 );\n\t//a = vec2(0.0);\n    a.y = -a.y;\n    #if INVERTED_Y_AXIS\n    a.x = -a.x;\n    #endif\n    a += angles0;\n    \n    vec3 camera_pos = cartesian_from_spherical( vec3(0.075,a) );\n    look = normalize(-camera_pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n\tfragColor = vec4(0.0,0.0,0.0,0.0);\n    \n    if ( is_value( fragCoord, PLAYER_POS_PX ) )\n    {\n\n    \tvec4 old_pos = load_value( PLAYER_POS_PX );\n        if ( old_pos.w == 0.0 )\n        {\n            old_pos = vec4(0.0,0.0,1.0,1.0);\n        }\n    \n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n\n    \tvec3 dir = vec3(0.0);\n\t\n\t    if ( texture( iChannel0, vec2(KEY_W, KEY_STATUS) ).x == 1.0\n          || texture( iChannel0, vec2(KEY_UP,KEY_STATUS) ).x == 1.0 )\n\t    {\n\t        dir.y += 1.0;\n\t    }\n\t    if ( texture( iChannel0, vec2(KEY_A,   KEY_STATUS) ).x == 1.0\n          || texture( iChannel0, vec2(KEY_LEFT,KEY_STATUS) ).x == 1.0 )\n\t    {\n\t        dir.x += -1.0;\n\t    }\n\t    if ( texture( iChannel0, vec2(KEY_S,   KEY_STATUS) ).x == 1.0\n          || texture( iChannel0, vec2(KEY_DOWN,KEY_STATUS) ).x == 1.0 )\n\t    {\n\t        dir.y += -1.0;\n\t    }\n\t    if ( texture( iChannel0, vec2(KEY_D,    KEY_STATUS) ).x == 1.0\n          || texture( iChannel0, vec2(KEY_RIGHT,KEY_STATUS) ).x == 1.0 )\n\t    {\n\t        dir.x += 1.0;\n\t    }\n\t    if ( texture( iChannel0, vec2(KEY_C,KEY_STATUS) ).x == 1.0 )\n\t    {\n\t        dir.z = -1.0;\n\t    }\n\t    if ( texture( iChannel0, vec2(KEY_SPACE,KEY_STATUS) ).x == 1.0 )\n\t    {\n\t        dir.z += 1.0;\n\t    }\n\n    \tvec4 old_look = load_value( PLAYER_LOOK_PX );\n        if ( dir.x !=0.0 || dir.y!= 0.0 )\n        {\n            dir.xy = normalize(dir.xy);\n            vec3 Z = vec3(0.0,0.0,1.0);\n            vec3 X = normalize( cross( old_look.xyz, Z ) );\n            vec3 Y = old_look.xyz;\n            dir.xy *= iTimeDelta * PLAYER_SPEED_MPS;\n\t\t    old_pos.xyz += dir.x * X;\n\t\t    old_pos.xyz += dir.y * Y;\n        }\n        if ( dir.z!= 0.0 )\n        {\n            vec3 Z = vec3(0.0,0.0,1.0);\n            dir.z *= iTimeDelta* PLAYER_VSPEED_MPS;\n\t\t    old_pos.z += dir.z;\n        }\n\t\tfragColor = old_pos;\n    } else\n    if ( is_value( fragCoord, PLAYER_LOOK_PX ) )\n    {\n    \tvec2 angles = vec2(PI*0.4,TAU*1.5);\n    \tvec2 angles0 = vec2(HPI,HPI);\n        vec3 look;\n    \tfirst_person_look( angles0, angles, look );\n        fragColor = vec4( look,0.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}