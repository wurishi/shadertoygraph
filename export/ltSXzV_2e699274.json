{"ver":"0.1","info":{"id":"ltSXzV","date":"1444956809","viewed":527,"name":"YPR-Camera","username":"meshula","description":"A simple shader to demonstrate: given yaw, pitch, and roll of the camera, compute the camera matrix. Then, given the camera matrix calculate a ray per pixel. Yaw and Pitch aim the camera, an then roll is applied along the pointing direction.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    // the usual method, copied from\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    //\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nmat3 createCameraYPR(float cameraYaw, float cameraPitch, float cameraRoll )\n{\n    vec3 forward = -normalize(vec3(sin(cameraYaw), sin(cameraPitch), cos(cameraYaw)));\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 cameraRight = normalize( cross(forward, up) );\n\tvec3 cameraUp = normalize( cross(cameraRight, forward) );\n    return rotationMatrix(forward, cameraRoll) * mat3( cameraRight, cameraUp, forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    mat3 cameraMatrix = createCameraYPR(3.0*m.x, 2.0*(m.y-0.5), 0.707);\n    vec3 rayDirection = cameraMatrix * normalize( vec3(p.xy, 1.77));\n    \n    fragColor = texture(iChannel0, rayDirection);\n}\n","name":"","description":"","type":"image"}]}