{"ver":"0.1","info":{"id":"McSyRh","date":"1722219019","viewed":77,"name":"Realistic sea sim2","username":"ShaddyNormals","description":"simulation of waves on the high sea, inspired by \"Seascape\" by Alexander Alekseev aka TDM","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["seasimulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.141592\n#define EPSILON 0.0001\n\nconst int MAX_STEPS = 100;\nconst float MAX_DIST = 100.0;\nconst float SURF_DIST = 0.01;\n\n// Sea constants\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.1,0.4,0.7);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat hash(vec2 p) {\n    float h = dot(p,vec2(127.1,311.7));    \n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);    \n    vec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(hash(i + vec2(0.0,0.0)), \n                 hash(i + vec2(1.0,0.0)), u.x),\n            mix(hash(i + vec2(0.0,1.0)), \n                 hash(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map_sea(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    float d, h = 0.0;    \n    for(int i = 0; i < 4; i++) {        \n        d = sea_octave((uv+SEA_TIME)*freq,choppy);\n        d += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n        uv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 get_normal(vec3 p) {\n    return normalize(vec3(\n        map_sea(vec3(p.x + EPSILON, p.y, p.z)) - map_sea(vec3(p.x - EPSILON, p.y, p.z)),\n        map_sea(vec3(p.x, p.y + EPSILON, p.z)) - map_sea(vec3(p.x, p.y - EPSILON, p.z)),\n        map_sea(vec3(p.x, p.y, p.z + EPSILON)) - map_sea(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat ray_march(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = map_sea(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 get_sky_color(vec3 rd) {\n    float sun = max(dot(rd, normalize(vec3(0.8, 0.4, 0.2))), 0.0);\n    vec3 sky = mix(vec3(0.1, 0.3, 0.6), vec3(0.7, 0.8, 0.9), rd.y * 0.5 + 0.5);\n    return sky + vec3(1.0, 0.6, 0.3) * pow(sun, 32.0);\n}\n\nvec3 get_sea_color(vec3 p, vec3 n, vec3 rd, vec3 light_dir) {\n    float fresnel = clamp(1.0 - dot(n, -rd), 0.0, 1.0);\n    fresnel = pow(fresnel, 3.0) * 0.5;\n    \n    vec3 reflected = get_sky_color(reflect(rd, n));\n    vec3 refracted = SEA_BASE + SEA_WATER_COLOR * 0.12;\n    \n    float diffuse = max(dot(n, light_dir), 0.0);\n    float specular = pow(max(dot(reflect(rd, n), light_dir), 0.0), 60.0);\n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.05;  // Significantly reduce foam intensity\n    color += vec3(specular);\n    \n    return color;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = get_sky_color(rd);\n    \n    float d = ray_march(ro, rd);\n    \n    if(d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = get_normal(p);\n        vec3 light_dir = normalize(vec3(0.8, 0.4, 0.2));\n        \n        if(p.y > 0.0) {\n            col = get_sea_color(p, n, rd, light_dir);\n            \n            // Adding foam with significantly reduced intensity\n            float foam = smoothstep(0.0, 0.05, p.y - SEA_HEIGHT);\n            col = mix(col, vec3(1.0), foam * 0.1);\n        } else {\n            float diffuse = max(dot(n, light_dir), 0.0);\n            float specular = pow(max(dot(reflect(rd, n), light_dir), 0.0), 32.0);\n            \n            vec3 object_color = mix(vec3(0.1, 0.2, 0.3), vec3(0.8, 0.5, 0.3), smoothstep(-1.0, -0.5, p.y));\n            object_color = mix(object_color, vec3(0.1, 0.6, 0.4), smoothstep(-0.5, 0.0, p.y));\n            \n            col = object_color * diffuse + vec3(0.6, 0.8, 1.0) * specular;\n            col = mix(col, SEA_WATER_COLOR, 1.0 - exp(-0.05 * d));\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 2.0, -15.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 forward = normalize(ta - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    \n    vec3 rd = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}