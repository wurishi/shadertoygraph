{"ver":"0.1","info":{"id":"Wt2fR3","date":"1599495209","viewed":283,"name":"Wave equation - AT","username":"athibaul","description":"Just a simple numerical scheme to simulate D'Alembert's wave equation in 2D.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["wave","equation","diffraction","helmholtz","dalembert","acoustics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//******************************//\n// A basic 2D finite-difference //\n//     leap-frog scheme for     //\n//  D'Alembert's wave equation  //\n//******************************//\n\n// TODO Implement von Neumann conditions at the obstacles\n// TODO Implement absorbing boundary conditions at the boundary\n\n\n// Cosine based palette by iq\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*sin( 6.28318*(c*t+d) );\n}\n\nvec4 cmap( in float p )\n{\n    float q = sign(p) * pow(abs(p), 0.5) + 0.5;\n    vec3 col = pal(\n        q,\n        vec3(0.5,0.5,0.5),\n        vec3(0.5,0.5,0.5),\n        vec3(1.0,1.0,1.0),\n        vec3(0.3,0.20,0.20)\n    );\n    //col *= pow(abs(p), 0.5);\n    // Simple tone mapping to reduce banding\n    //col = mix(col, 1.0-(4.0/27.0)/(col*col), step(0.666, col));\n    return vec4(col, 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    fragColor = cmap(p);\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    if(isObstacle(uv))\n    {\n        fragColor = vec4(0.5);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define dt 4e-3\n#define dx 2.0/450.0\n\n\n\nvec4 initCond( in vec2 uv )\n{\n    float sigma2 = 0.1*0.1;\n    //return 10.0*vec4(exp(-dot(uv,uv) / (2.0 * sigma2)), 0.0, 0.0, 0.0);\n    return vec4(0.0);\n}\n\n\nfloat source( in vec2 uv )\n{\n    float t = float(iFrame) * dt;\n    //uv -= vec2(0.5,0.2);\n    //float p_source = 10.0*cos(6.28318*3.0*t) * exp(-dot(uv,uv)/(2.0*1e-2));\n    //float p_source = 20.0*cos(6.28318*5.0*t) * exp(-dot(uv,uv)/(2.0*1e-4));\n    float cx = -0.99;\n    float p_source = 5.0*sin(6.28318*5.0*t) * exp(-(uv.x-cx)*(uv.x-cx)/2e-4);\n    return p_source;\n}\n\nvec4 oneStep( in vec2 fragCoord, in vec2 uv )\n{\n    vec2 ex = vec2(1.0,0.0);\n    vec2 ey = vec2(0.0,1.0);\n    \n\tfloat p_n      = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    float dpdt_nmh = texelFetch(iChannel0, ivec2(fragCoord), 0).y;\n\tfloat p_n_xp   = texelFetch(iChannel0, ivec2(fragCoord+ex), 0).x;\n\tfloat p_n_xm   = texelFetch(iChannel0, ivec2(fragCoord-ex), 0).x;\n\tfloat p_n_yp   = texelFetch(iChannel0, ivec2(fragCoord+ey), 0).x;\n\tfloat p_n_ym   = texelFetch(iChannel0, ivec2(fragCoord-ey), 0).x;\n    \n    float dpdt_nph = dpdt_nmh +\n        dt/(2.0*dx*dx) * (p_n_xp + p_n_xm + p_n_yp + p_n_ym - 4.0*p_n);\n    float p_np1 = p_n + dt * dpdt_nph + dt*source(uv);\n    \n    return vec4(p_np1, dpdt_nph, 0.0, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    if(iFrame == 0 || texelFetch(iChannel0, ivec2(0), 0).a != iResolution.x)\n    {\n        fragColor = initCond(uv);\n\t}\n    else if(isObstacle(uv))\n    {\n        fragColor = vec4(0.0);\n    }\n    else\n    {\n    \tfragColor = oneStep(fragCoord, uv);\n    }\n    \n    if(ivec2(fragCoord) == ivec2(0))\n        fragColor.a = iResolution.x;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nbool isObstacle( in vec2 uv )\n{\n    if(uv.x < -1.0\n       || uv.y < -1.0\n       || uv.x > 1.0\n       || uv.y > 1.0)\n        return true;\n    // Double slit experiment\n    \n    if(abs(uv.x+0.5) < 0.01 && abs(abs(uv.y)-0.2) > 0.05)\n        return true;\n\t\n    // Horn\n    /*\n\tif(uv.x > -0.5 && uv.x < 0.5 && abs(uv.y) > 0.1*exp(2.0*(uv.x+0.5))\n      || uv.x <= -0.5 && abs(uv.y) > 0.1)\n        return true;\n\t*/\n    return false;\n}\n","name":"Common","description":"","type":"common"}]}