{"ver":"0.1","info":{"id":"MtBSWG","date":"1446122257","viewed":128,"name":"simple primitives","username":"nilspin","description":"simple ring","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n///////////////\n// The scene //\n///////////////\n\n\nfloat sceneDist(vec2 p)\n{\n    float PI = 3.14159265359;\n    int samples = 10;\n    vec2 center = vec2(200.0, 200.0);\n    // ring\n    float c1= circleDist(\ttranslate(p, center),30.0);\n    float c2= circleDist(\ttranslate(p, center),50.0);\n    float ring = substract(c1,c2);\n    \n    float l[10];\n\tfloat m=0.0;\n\tfloat step = PI*2.0/float(samples);\n\tfor(int i=0;i<10;++i)\n    {\n    \tl[i] = lineDist(translate(p,center), vec2(0.0,0.0), -100.0*vec2(sin(float(i)*step),cos(float(i)*step)), 10.0);\n    \tm = merge(m,l[i]);\n    }\n\t\n    float l1 = lineDist(translate(p,center), vec2(0.0,0.0), vec2(-100.0,-100.0), 10.0);\n//    float l2 = lineDist(translate(p,center), vec2(-100.0,-100.0), vec2(00.0,00.0), 10.0);\n    \n    float k = substract(l1, ring);\n//    k = substract(l2,k);\n    float i= substract(l[6],ring);\n    float j= substract(l[7],ring);\n    float q= substract(l[8],ring);\n    \n    return intersect(i,q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy;\n\tvec2 c = iResolution.xy / 2.0;\n    vec2 center = vec2(50,50);\n\t\n    vec4 col = vec4(0);\n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p);\n    col = mix(col, vec4(1.0, 0.5, 0.0, 1.0), fillMask(dist));\n    \n\tfragColor = col;//vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"","description":"","type":"image"}]}