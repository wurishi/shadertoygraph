{"ver":"0.1","info":{"id":"3tlcWS","date":"1592945275","viewed":233,"name":"Wandering Love","username":"Flopine","description":"An improved version of a live coding session I did during Pedipanol's chiptune set for Famitracker Bites concert. \nGo listen her awesome gigs :D https://soundcloud.com/pedipanol","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animation","isometric","orthographic","live"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define BPM (150./60.)\n#define cucubspeed (BPM/2.)\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define ITER 64.\n#define time(speed) fract(iTime*speed)\n#define bouncy(speed) sqrt(abs(sin(time(speed)*PI)))\n#define animback(speed) easeInOutBack(abs(-1.+2.*time(speed)))\n#define animcirc(speed) easeInOutCirc(time(speed))\n#define switchanim(speed) floor(sin(time(speed)*2.*PI)+1.)\n\n\nfloat easeInOutCirc(float x)\n{\n    return x < 0.5\n        ? (1. - sqrt(1. - pow(2. * x, 2.))) / 2.\n        : (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nfloat easeInOutBack(float x)\n{\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n\n    return x < 0.5\n        ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) / 2.\n        : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(10.4,32.4))*1284.4));}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat od (vec3 p ,float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat g1 = 0.;\nfloat room (vec3 p, float size)\n{\n    p.z += (floor(iTime*cucubspeed)+animcirc(cucubspeed))*1.6;\n    vec3 pp = p;\n    float d = abs(box(p, vec3(size,3.,1e10)))-0.2;\n    float per = 2.;\n    p.z = mod(p.z, per)-per*0.5;\n    p.x = abs(p.x)-size*0.95;\n    d = stmin(d, cyl(p.xzy, 0.3,3.),0.2,3.);\n\n    p = pp;\n    p.x = abs(p.x)-size*0.6;\n    p.y += 1.5;\n    p.z = mod(p.z-per*.5, per)-per*0.5;\n    p.xz *= rot(time(0.5)*TAU);\n    float gem = od(p,0.5);\n    g1 += 0.01/(0.01+gem*gem);\n    d = min(d,gem);\n\n    p = pp;\n    p.x = abs(p.x)-size*0.6;\n    p.y += 2.5;\n    d = stmin(d,box(p,vec3(0.8,0.2,1e10)),0.5,4.);\n\n    p = pp;\n    d = max(p.y-2.,d);\n    return d;\n}\n\nfloat cucube (vec3 p, float speed)\n{\n    float size = 0.8;\n    p.z -= 2.;\n    p.x = abs(p.x)-(.9+animback(BPM/8.));\n    p.y += 2.5-size;\n    p.y -= bouncy(speed);\n    p.yz *= rot(animcirc(speed)*PI/2.);  \n    return box(p,vec3(size));\n}\n\nfloat rom,cub;\nfloat SDF (vec3 p)\n{\n    vec3 pp = p;\n    p.yz *= rot(-atan(1.));\n    p.xz *= rot(PI/4.);\n    vec3 piso = p;\n    \n    float size = 7.;\n    rom = room(p,size);\n    float d = rom;\n\n    p = piso;\n    cub = cucube(p,cucubspeed);\n    d = min(d,cub);\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat mask (vec2 uv)\n{\n    return smoothstep(0.1,\n                      0.2, \n                      sin(abs(length(uv+vec2(0.1,-0.1))-time(BPM/8.+PI/2.))*PI)\n                     );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(uv*10.,-50.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = normalize(vec3(1.,1.,-1.)),\n        col = vec3(0.,0.01,0.02);\n\n    float shad, d = 0.; bool hit = false;\n\n    for (float i=0.; i<ITER;i++)\n    {\n        d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        rd += (1.-mask(uv))*0.005;\n        d *= 0.9 + dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        if (d == rom) col = vec3(1.);\n        if (d == cub) col = vec3(0.4,0.,0.3);\n        vec3 n = getnorm(p);\n        float lighting = dot(n,l)*.5+.5;\n        col *= mix(vec3(0.3,0.0,0.1),vec3(0.7,0.5,0.8),lighting);\n    }\n    col += g1*vec3(0.1,0.6,0.8)*0.1;\n    fragColor = vec4(sqrt(col),1.);\n}","name":"Image","description":"","type":"image"}]}