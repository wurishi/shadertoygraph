{"ver":"0.1","info":{"id":"wsSGDD","date":"1548954291","viewed":468,"name":"CrashTest","username":"iapafoto","description":"Simple cutting space effect  [Buffer A - line 35 - opCutSpace]","likes":48,"published":1,"flags":32,"usePreview":0,"tags":["text","effect","font","slice","cut","operator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by sebastien durand - 01/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n\n// Buf A: Calculate distance to scene\n// Image: DOF post processing\n\n#define WITH_DOF\n#define WITH_CONE_TEST\n\n\n#ifdef WITH_DOF\n\nconst float aperture = 2.;\n\nconst float cosAngle = cos(radians(aperture/2.));\nconst float GA = 2.399;  // golden angle = 2pi/(1+phi)\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n    \nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn side*dot(normalize(o-p), n) >= cosAngle;\n}\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.08, (2./iResolution.y) * (1.+t));\n}\n\n\nvec3 RD(const vec2 q) {\n    return normalize(vec3((2.* q.x - 1.) * iResolution.x/iResolution.y,  (2.* q.y - 1.), 2.));\n}\n\n\nvec3 dof(sampler2D tex, vec2 uv, float fdist) {\n    \n    const float amount = 1.;\n\tvec4 colMain = texture(tex, uv);\n    \n    fdist = min(30., fdist);\n    float rad = min(.3, coc(abs(colMain.w-fdist))),//.3; // TODO calculate this for Max distance on picture\n    \t  r=2.;\n    \n    vec3 cn = RD(uv),    // Cone axis    \n         co = cn*fdist,  // Cone origin\n         sum = vec3(0.),  \n     \t bokeh = vec3(1),\n         acc = vec3(0),\n         pixPos;\n    vec2 pixScreen,\n         pixel = 1./iResolution.xy,        \n         angle = vec2(0, rad);\n    vec4 pixCol;\n    \n    bool isInCone = false;\n\tfor (int j=0;j<60;j++) {  \n        r += 1./r;\n\t    angle *= rot;\n        pixScreen = uv + pixel*(r-1.)*angle; // Neighbourg Pixel\n        pixCol = texture(tex, pixScreen);    // Color of pixel (w is depth)      \n        pixPos = pixCol.w * RD(pixScreen);   // Position of 3D point in camera base\n#ifdef WITH_CONE_TEST\n        if (inCone(pixPos, co, cn, sign(fdist - pixCol.w))) \n#endif            \n        {        // true if the point is effectivelly in the cone\n            bokeh = pow(pixCol.xyz, vec3(9.)) * amount +.4;\n            acc += pixCol.xyz * bokeh;\t\t\t\n            sum += bokeh;\n            isInCone = true;\n        }\n\t}\n        \n \treturn (!isInCone) ? colMain.xyz : // Enable to deal with problem of precision when at thin begining of the cone\n       acc.xyz/sum;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy;\n    \n    // Animation\n    float anim = mod(iTime,30.)*.1,\n\t\ttMorph = smoothstep(1.09,1.1,anim),\n   \t\ttRot = smoothstep(1.05,1.5,anim),\n    \ttTensionVibre = smoothstep(.4,1.,anim),\n        a = 10. + 4.*anim + 8.*m.x;\n\t\n\t// Configure camera\n\tvec3 ro = (2.7-tRot*1.2)*vec3(tRot*cos(a), 1.2 + tRot*sin(a), 1) + (1.-tMorph)*(tTensionVibre)*hash3( uint(iFrame))*.2;// + .6*f;\n\n  \t// DOF\n    float fdist = length(ro-vec3(0,.4,0));\n    vec3 c = dof(iChannel0,q,fdist); \n    \n    // Vigneting\n    c *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .16); \n    \n    // Flash at end of sequences\n    float xx = mod(iTime,30.),\n    flash = 1.+10.*exp(-abs(xx)*2.);\n    c = flash * c;\n    \n    fragColor = vec4(c,1.);\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 c = texture(iChannel0,uv);\n    c *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .5); // Vigneting\n\tfragColor = c; //*.01; \n}\n\n#endif","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Sebastien Durand - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n//#define AIEKICK  // For cold colors\n\n#ifdef AIEKICK\n  #define COLOR_HOT vec3(0.,.25,1.)\n#else\n  #define COLOR_HOT vec3(1.,.25,0.)\n#endif\n\n#define NB_CUTS 10\n\nfloat tMorph, tTension, gChain;\nint gObjMode, gColorMode;\n\n// SPACE txt\nint[] gtxt = int[] (83,80,65,67,69);\n\n\n// --------------------------------------\n// Space Operators\n// --------------------------------------\n\n// [iq] https://www.shadertoy.com/view/4lyfzw\nfloat opExtrussion( in vec3 p, in float sdf, in float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\n\n// The cut effect is here !!!\n// return distance to the slice of space to remove from scene\nfloat opCutSpace(inout vec3 p, in vec3 n, in float w, in float sp) {\n    float dt = dot(p,n) + w,\n    dcut = abs(dt)-sp;\n    p -= sp*n*sign(dt);\n    return dcut;\n}\n\n// Apply several cut effect to space\nfloat opSuperCut(inout vec3 p) {\n    float ksp = .04*step(0.5,tMorph),\n\t\t  dcut= 999.;\n    uint id = uint(floor(iTime/30.));\n    if (ksp > 0.) {\n        for (int i=0; i<NB_CUTS; i++) {\n            float w = -.4+.8*hash1(id+uint(i+8989)),\n            \t  sp = .02+(ksp * hash1(id+uint(i+1234)));\n            vec3  n = normalize(vec3(2,1,1)*(-1.+2.*hash3(id*100u + uint(i))));\n            dcut = min(dcut, opCutSpace(p, n, w, sp));  \n        }\n    }\n    return dcut;\n}\n\n// --------------------------------------\n// Distance Functions\n// --------------------------------------\n\n// Adapted from [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\nfloat sdFont(in vec2 p, in int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel0, uv, 0.).w - 127./255.);\n}\n\nfloat sdMessage2D(in vec2 p, in int[5] txt, in float scale) { \n    p /= scale;\n \tfloat d = 999., w = .45; // letter width  \n    p.x += w*float(txt.length()-1)*.5; // center text arround 0\n    for (int id = 0; id<5; id++){\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return scale*d;\n}\n\nfloat sdMessage3D(in vec3 p, in int[5] txt, in float scale, in float h) { \n    return opExtrussion(p, sdMessage2D(p.xy, txt, scale), h);\n}\n\n// Distance to chain\nfloat sdChain(inout vec3 p, float r, float l, float w, float da){    \n    p.z += min(0.,-.8*(da+.2)*cos(p.x*.6));\n    p.x *= 1.-.1*da;\n  \tfloat a=(l+r-w)*2., \n        k = a-da*.5,\n        x0 = mod(p.x+k, k+k)-k, \n        x1 = mod(p.x+a-da*.5+k, k+k)-k,\n  \t\td1 = length(vec2(length(vec2(max(abs(x0)-l,0.),p.z))-r,p.y))-w,\n    \td2 = length(vec2(length(vec2(max(abs(x1)-l,0.),p.y))-r,p.z))-w;\n    p.x = (d1 < d2) ? x0 : x1;\n    return min(d1,d2);\n}\n\n// --------------------------------------\n// Distance to scene\n// --------------------------------------\nfloat map(in vec3 p) {\n    float dcut = opSuperCut(p);\n    p.y-=.35;  \n    float dobj = gObjMode == 1 ? \n        min(min(p.z+.55,p.y+.6), sdMessage3D(p,gtxt,2.,.5)): \n        sdChain(p, .3, .3, .15, gChain);\n    return max(dobj, -dcut);\n}\n\n// --------------------------------------\n// Shading Tools\n// --------------------------------------\n// Find initial space position\nvec4 MCol(in vec3 p) {\n    float dcut = opSuperCut(p);\n    p.y -= .35;\n    float dobj = gObjMode == 1 ? \n        min(min(p.z+.55,p.y+.6), sdMessage3D(p,gtxt,2.,.5)): \n        sdChain(p, .3, .3, .15, gChain);\n    return vec4(p, dobj >= -dcut ? 1. : 2.);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .4 * t / iResolution.x;\n    vec2 d = vec2(-1,1) * pitch;\n\tvec3 p0 = p+d.xxx, p1 = p+d.xyy, p2 = p+d.yxy, p3 = p+d.yyx;\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2), f3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\treturn normalize(grad - max(.0, dot(grad,ray))*ray);\n}\n\nfloat SoftShadow(in vec3 ro, in vec3 rd) {\n    float r = 1., h, t = .005+hash13(ro)*.02, dt = .01;\n    for(int i=0; i<48; i++ ) {\n\t\th = map(ro + rd*t);\n\t\tr = min(r, 10.*h/t);\n\t\tt += dt;\n        dt += .0025;\n        if (h<1e-4) break;\n    }\n    return clamp(r, 0., 1.);\n}\n\nfloat CalcAO(in vec3 p, in vec3 n) {\n    float d, h=.01, a=.0, s=1.;\n    for(int i=0; i<4; i++) {\n        d = map(n * h + p);\n        a += (h-d)*s;\n        s *= .8;\n        h += .03;\n    }\n    return clamp(1.-4.*a, 0., 1.);\n}\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 c = clamp( abs(mod(x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.);\t\n\treturn z * mix( vec3(1), c*c*(3.-2.*c), y);\n}\n\n\n//----------------------------------\n// Texture 3D\n//----------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(n*n, .001);\n    n /= n.x + n.y + n.z;  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)) )/e.x; \n    g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n\n//----------------------------------\n// Shading\n//----------------------------------\nvec3 render(in vec3 ro, in vec3 rd, in float res, in vec3 pos, in vec3 n, in vec3 cobj, in vec3 light, vec3 cback, float spec) {\n    float \n         ao = CalcAO(pos, n),\n    \t sh = SoftShadow( pos, light),\n         amb = clamp(.5+.5*n.y, .0, 1.),\n         dif = sh*clamp(dot( n, light ), 0., 1.),\n         pp = clamp(dot(reflect(-light,n), -rd),0.,1.),\n         fre = (.7+.3*dif)* ao*pow( clamp(1.+dot(n,rd),0.,1.), 2.);\n    vec3 brdf = ao*.5*(amb)+ 1.*dif*vec3(1.,.9,.7),\n         sp = spec*sh*pow(pp,9.)*vec3(1., .6, .2),\n\t     col = cobj*(brdf + sp) + fre*(.5*cobj+.5);\n    return mix(cback,col,2.*dot(n,-rd));\n}\n\nfloat isGridLine(vec3 p, vec3 v) {\n    vec3 k = smoothstep(.2,.8,abs(mod(p+v*.5, v)-v*.5)/.01);\n    return k.x * k.y * k.z;\n}\n\n// --------------------------------------\n// Main\n// --------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 r = iResolution.xy, \n         m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, pix = q+q-1.;\n\tpix.x *= r.x/r.y;\n    \n    // Animation\n\tgColorMode   = mod(iTime,120.)>60. ? 1 : 0;\n    gObjMode     = mod(iTime, 60.)>30. ? 1 : 0;\n\n    float anim = mod(iTime,30.)*.1,\n    \t  tRot = smoothstep(1.05,1.5,anim),\n     \t  tTensionCol = smoothstep(.8,1.2,anim),\n     \t  tTensionVibre = smoothstep(.4,1.,anim),\n\t\t  aCam = 10. + 4.*anim + 8.*m.x;\n    \n    tMorph = smoothstep(1.09,1.1,anim);\n    tTension = anim;\n    gChain = 1.2*clamp(-.0,.25,anim<1.1 ? .3*(.3-anim) : .3);\n\n    // Camera\n\tvec3 ro = (2.7-tRot*1.2)*vec3(tRot*cos(aCam), 1.2 + tRot*sin(aCam), 1) + (1.-tMorph)*(tTensionVibre)*hash3( uint(iFrame))*.2,\n\t\t w = normalize(vec3(0,1,0) * .4 - ro), \n         u = normalize(cross(w, vec3(0,1,0))), \n         v = cross(u, w),\n         rd = normalize(pix.x * u + pix.y * v + w+w);\n\t\t\t\n\t// Ray marching\n    float h = .1, t = .01*hash13(q.xyx);\n    for(int i=0;i<164;i++) { \n\t\tif (h<1e-3 || t>24.) break;\n        t += h = map(ro + rd*t);\n    }\n    \n\t// Background color\n\tvec3 c = hsv2rgb_smooth( .5,.35,.2);\n    c *= .5+.5*hash13(q.xyx);   \n    c *= 10.*pow(q.x*q.y*(1.0-q.x)*(1.0-q.y), .838);\n\tc += .2*tTensionCol*(.05 + COLOR_HOT/pow(.1+length(pix),.2));\n\n    vec3 lightPos = vec3(0.,1.2, .7);\n            \n    // Calculate color on point\n\tif (h < 1e-3) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 n = normal(pos,rd,t);\n        \n\t\tvec4 txt = MCol(pos); \t\t\n        vec3 cobj;\n        \n        if (gColorMode == 0) {\n            cobj = txt.w<1.5 ? vec3(.2) : vec3(.5,.4,.4);\n            if (txt.w<1.5) {\n                n = doBumpMap(iChannel1, txt.xyz*2., n, .05);\n            } else {\n                n = doBumpMap(iChannel2, txt.xyz*2., n, .08);\n            }\n            // keep in visible side\n            n = normalize(n - max(.0,dot(n,rd))*rd);\n        } else {            \n            cobj = vec3(1.)*isGridLine(txt.xyz+vec3(0.005,-0.025,.09), vec3(.155));\n        }\n        \n        // Shading\n        c = render(ro, rd, t, pos, n, cobj, normalize(lightPos-pos), c, txt.w<1.5 ? 5. : 20.);\n\n        // Add light\n        c += tTensionCol*(.03+COLOR_HOT/pow(.1+length(pos-vec3(0,.4,0)),1.5));\n\t} \n\n\tfragColor = vec4(clamp(c, vec3(0), vec3(1)), t);\t\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat hash13( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\n// [iq] https://www.shadertoy.com/view/llGSzw\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}","name":"Common","description":"","type":"common"}]}