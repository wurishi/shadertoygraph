{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// positioned color node\nstruct RampNode\n{\n    float Position; // 0 to 1\n    vec3 Color;    \n};\n\n// inter-node interpolation using Ken Perlin's Bias and Gain functions\n// http://blog.demofox.org/2012/09/24/bias-and-gain-are-your-friend/\nstruct Interpolator\n{\n    float Bias; // 0 to 1\n\tfloat Gain; // 0 to 1\n};\n    \n#define NUM_NODES 3\nRampNode ColorRamp[NUM_NODES];\nInterpolator Interpolators[NUM_NODES - 1];\n\nfloat GetBias(float time, float bias)\n{\n\treturn (time / ((((1.0 / bias) - 2.0) * (1.0 - time)) + 1.0));\n}\n\nfloat GetGain(float time, float gain)\n{\n\tif(time < 0.5)\n\t\treturn GetBias(time * 2.0, gain) / 2.0;\n\telse\n\t\treturn GetBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x / iResolution.x;\n       \n    // Node 0 : black\n    ColorRamp[0].Position = 0.25;\n    ColorRamp[0].Color = vec3(0);\n\n    // 0 to 1\n    Interpolators[0].Bias = 0.25;\n\tInterpolators[0].Gain = 0.75;    \n        \n    // Node 1 : purple-ish blue\n    ColorRamp[1].Position = 0.95;    \n    ColorRamp[1].Color = vec3(0.25, 0.0, 1.0);\n    \n\t// 1 to 2\n    Interpolators[1].Bias = 0.25;    \n\tInterpolators[1].Gain = 0.625;    \n        \n    // Node 2 : white\n    ColorRamp[2].Position = 1.0;\n    ColorRamp[2].Color = vec3(1);\n    \n    // anything before the first ramp node takes its color\n    vec3 c = ColorRamp[0].Color; \n    \n   \t// loop through ramp nodes\n    for (int i = 1; i < NUM_NODES; i++)\n    {\n        RampNode last = ColorRamp[i - 1];\n        RampNode current = ColorRamp[i];\n        \n       \tfloat stepInStage = (x - last.Position) / (current.Position - last.Position);\n        \n        if (stepInStage < 0.0 || stepInStage >= 1.0)\n            // not in the range for this node, keep going\n            continue;\n        \n        // interpolate\n        Interpolator interpolator = Interpolators[i - 1];\n        stepInStage = GetBias(stepInStage, interpolator.Bias) * \n\t\t\t\t\t  GetGain(stepInStage, interpolator.Gain);\n        \n        c = mix(last.Color, current.Color, stepInStage);\n    }\n    \n    // anything after the last ramp node takes its color\n    if (x > ColorRamp[NUM_NODES - 1].Position)\n        c = ColorRamp[NUM_NODES - 1].Color;\n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSSDd","date":"1417121158","viewed":1026,"name":"Linear Gradient","username":"renaudbedard","description":"A linear color ramp with interpolation parameters and a pretty straightforward interface","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","gradient","ramp"],"hasliked":0,"parentid":"","parentname":""}}