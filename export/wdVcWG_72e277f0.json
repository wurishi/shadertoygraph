{"ver":"0.1","info":{"id":"wdVcWG","date":"1603678213","viewed":63,"name":"RIOW - 8 - Diffuse","username":"TheMunro","description":"https://raytracing.github.io/books/RayTracingInOneWeekend.html#diffusematerials","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    //divide by the number of samples (w component = sum of samples = 2 in this case)\n    //take square root to gamma correct\n    fragColor = vec4(sqrt(data.rgb/data.w), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA 1\n    \n//constants\nvec3 zero = vec3(0., 0., 0.);\nvec3 one = vec3(1., 1., 1.);\nvec2 seed;\n\nfloat pi = \t3.141592653;\nfloat tau = 6.283185307;\n\nfloat near = 0.0001;\nfloat far = 1e20;\n//wherever you are...\n\nconst int MAX_OBJECTS = 2;\nconst int MAX_ITERATIONS = 10;\n\n//functions\nvec3 random_in_unit_sphere()\n{\n    //https://stackoverflow.com/questions/5408276/sampling-uniformly-distributed-random-points-inside-a-spherical-volume\n    //can probably simplify this with trig identities\n    vec3 rnd = hash_3d(seed) * vec3(tau, 2., 1.) - vec3(0., 1., 0.);\n        \n    float phi = rnd.x;\n    float theta = acos(rnd.y);\n    float r = pow(rnd.z, 1./3.);   \n        \n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n                            \n    return vec3(x, y, z);\n}\n\n////lambertian distribution\n//vec3 random_in_unit_sphere()\n//{\n//    vec2 rnd = hash_2d(seed) * vec2(tau, 2.) - vec2(0., 1.);\n//        \n//    float a = rnd.x;\n//    float z = rnd.y;\n//    float r = sqrt(1. - z*z);   \n//                          \n//    return vec3(r*cos(a), r*sin(a), z);\n//}\n\nbool hit_sphere(in Sphere s, in Ray r, in float t_min, in float t_max, out HitRecord hr)\n{\n    //quadratic solution to sphere-line intersection\n    //N.B. 0/1/2 solutions all possible solutions\n    //0 in complex case\n    //1 in tangent case\n    //2 in full sphere intersection case\n    \n    //vector from ray origin to sphere centre\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float half_b = dot(oc, r.d);\n\tfloat c = dot(oc, oc) - s.r * s.r;\n    \n\tfloat det = half_b*half_b - a*c;\n        \n    if(det < 0.)\n        return false;\n    \n    //closest intersection point calculation\n    float t = (-half_b - sqrt(det)) / a;\n    if(t < t_max && t > t_min) \n    {\n        hr.t = t;\n        hr.p = r.d * t + r.o;\n        hr.n = (hr.p - s.c) / s.r;\n        hr.front_face = dot(hr.n, r.d) < 0.;\n    \treturn true;\n    }\n    \n    //farthest intersection point calculation\n    t = (-half_b + sqrt(det)) / a;\n    if(t < t_max && t > t_min) \n    {\n        hr.t = t;\n        hr.p = r.d * t + r.o;\n        hr.n = (hr.p - s.c) / s.r;\n        hr.front_face = dot(hr.n, r.d) < 0.;\n    \treturn true;\n    }  \n\n    return false;\n}  \n\nbool world_hit(in Ray r, in float t_min, in float t_max, out HitRecord hr) \n{\n    //fix spheres\n    HitRecord tmp;\n    bool hit = false;\n    float t = t_max;\n    \n    const Sphere sphere0 = Sphere(vec3(0., 0., -1.), 0.5);\n    const Sphere sphere1 = Sphere(vec3(0.,-100.5,-1), 100.);\n\n    Sphere[MAX_OBJECTS] s = Sphere[](sphere0, sphere1);\n\n    //checks each intersectable object for hit, updates hr if closer\n    for(int i = 0; i < MAX_OBJECTS; i++) \n    {\n        if(hit_sphere(s[i], r, t_min, t, tmp)) \n        {\n            hit = true;\n            t = tmp.t;\n            hr = tmp;\n        }\n    }\n    \n    return hit;\n}\n\nvec3 trace_ray(in Ray r)\n{\n    HitRecord hr;\n    vec3 col = one;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        if(world_hit(r, near, far, hr)) \n        {\n            //can ignore hr.p, as if it's added here it'll be subtracted from \n            //direction before normalisation, so can remove as unnecessary\n        \t//vec3 nxt = hr.n + random_in_unit_sphere3(hash_1d(seed));\n            vec3 nxt = hr.n + random_in_unit_sphere();\n            \n            //attenuate color\n            col *= 0.5;\n            \n            r.d = normalize(nxt);\n            r.o = hr.p; \n        }\n        else \n        {\n            float t = 0.5 * (r.d.y + 1.);\n            return col * mix(one, vec3(0.5, 0.7, 1.), t);\n        }\n    } \n        \n    return col;\n}\n\n//output\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{    \n    //stores resolution in (0,0) pixel\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = iResolution.xyxy;\n        return;\n    } \n    \n    vec3 col;\n    seed = hash_2d(fragCoord + iTime);//vec2(hrand(fragCoord) + iTime);\n    \n#if AA>1\n    for(int m = 0; m < AA; m++)\n    for(int n = 0; n < AA; n++)\n    {\n        vec2 uv = (2. * fragCoord.xy - iResolution.xy + vec2(float(m),float(n))/float(AA) + hash_2d(seed))/iResolution.y;\n#else      \n        vec2 uv = (2. * fragCoord.xy - iResolution.xy + hash_2d(seed))/iResolution.y;\n#endif\n        \n    \t//position \n        Ray r = Ray(zero, vec3(uv, -1.));\n        col += trace_ray(r);\n        \n#if AA>1\n    }\n    col /= float(AA * AA);\n#endif\n\n    //checks resolution in (0,0) pixel and if matched, sums current with last\n    if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \n        fragColor = vec4(col,1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    } else {        \n        fragColor = vec4(0,0,0,1);\n    }\n}","name":"Buffer @","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//data types\nstruct Ray\n{ \n    vec3 o; \n    vec3 d;\n};\n    \nstruct Sphere\n{ \n    vec3 c; \n    float r;\n};\n    \nstruct HitRecord\n{\n    vec3 p;\n    vec3 n;\n    float t;\n    bool front_face;\n};\n\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nuint base_hash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash_1d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash_2d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash_3d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash_4d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}  \n\nfloat hrand(in vec2 coord) \n{\n    uint hashed_coord = base_hash(floatBitsToUint(coord));\n    return float(hashed_coord)/float(0xFFFFFFFFU);  \n}\n\nfloat length_squared(vec3 v)\n{\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\n// other\nfloat nrand(in vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}","name":"Common","description":"","type":"common"}]}