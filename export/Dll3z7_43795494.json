{"ver":"0.1","info":{"id":"Dll3z7","date":"1671544337","viewed":106,"name":"Bump Mapping (simple)","username":"EisernSchild","description":"Bump Mapping with fake XZ texture displacement.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","simple","bumpmapping","displacementmapping","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bump Mapping (simple)\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n        Bump Mapping (simple)\n        \n        Here we have Bump Mapping with included fake (XZ) displacement provided \n        by a perturbation function.\n        \n        You can see that the displacement leads to texture flaws on the left side\n        since that function has more \"grain\".\n        \n        \n        Noise/Perturbation logic from following sources (with respective licences):\n        \n        \"Evil Membrane\"               by leon  : https://www.shadertoy.com/view/ddX3WB\n        \"cosahedron Triangle Pattern\" by Shane : https://www.shadertoy.com/view/cllGzr\n        Noise generator                        : https://otaviogood.github.io/noisegen/ \n*/\n\n#define HITMIN if ((fTHit < 0.) || (fTHitMin < fTHit)) fTHit = fTHitMin\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n};\n\n// intersection\nstruct Intersection\n{\n    vec4 vTNin;\n    vec4 vTNex;\n};\n\n// following noise functions from \"Evil Membrane\" by leon : https://www.shadertoy.com/view/ddX3WB\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 6; ++i)\n    {\n        // extra spicy twist\n        seed.z += result*.5;\n        \n        // bounce it with abs\n        result += abs(gyroid(seed/a))*a;\n        \n        a /= 2.;\n    }\n    return result;\n}\n\nfloat noise (vec2 p)\n{\n    // improvise 3d seed from 2d coordinates\n    vec3 seed = vec3(p, length(p)) * 1.;\n    \n    // make it slide along the sin wave\n    return sin(fbm(seed)*6.)*.5+.5;\n}\n\n\n// perturbe position by normal\nvec3 Perturbe(in vec3 vPos, in vec3 vOff, in vec3 vNor, in int nBumpIx, in float fBumpScl)\n{\n    float fOffs = 0.f;\n    \n    // scale\n    vec3 vPret = (vPos + vOff);\n    vec3 vP = vPret * fBumpScl;\n    \n    // select material by index\n    if (nBumpIx == 0)\n    {\n        // from \"Evil Membrane\" by leon\n        fOffs = noise(vP.xz);\n    }\n    else if (nBumpIx == 1)\n    {\n        // perturbation from \"cosahedron Triangle Pattern\" by Shane : https://www.shadertoy.com/view/cllGzr\n        fOffs = mix(dot((sin(vP - cos(vP.yzx*2.2/2.4)*1.57)), vec3(.1)), dot((sin(vP*2. - cos(vP.yzx*2.2/2.4*2.)*1.57)), vec3(.1)), .333);\n    }\n    else if (nBumpIx == 3)\n    {\n        // Noise generator from https://otaviogood.github.io/noisegen/ (CC0 licence)\n        // Params: 2D, Seed 833327754, Waves 5, Octaves 3, Smooth 0.5\n        // This is a bit faster if we use 2 accumulators instead of 1.\n        // Timed on Linux/Chrome/TitanX Pascal\n        float wave0 = 0.0;\n        float wave1 = 0.0;\n        wave0 += sin(dot(vP.xz, vec2(2.425, -2.028))) * 0.3041893903;\n        wave1 += sin(dot(vP.xz, vec2(-0.618, -3.773))) * 0.2661512463;\n        wave0 += sin(dot(vP.xz, vec2(-1.933, -4.450))) * 0.2278746412;\n        wave1 += sin(dot(vP.xz, vec2(-1.179, 5.981))) * 0.1980978691;\n        wave0 += sin(dot(vP.xz, vec2(3.981, -7.577))) * 0.1626588094;\n        fOffs = (wave0+wave1) * .4f;\n    }\n    \n    return vPret + vNor * fOffs;\n}\n\n// Plane intersection\nIntersection iPlane(in vec3 vOri, in vec3 vDir)\n{\n    // ortho project up-origin/z-dir\n    float fT = -vOri.y/vDir.y;   \n    \n    return Intersection( vec4(fT, vec3(0., 1., 0.)), \n                         vec4(-fT, vec3(0., -1., 0.)) );    \n}\n\n// Plane intersection... perturbed bump mapping\nIntersection iPlanePerturbBump(in vec3 vOri, in vec3 vDir, in vec3 vOff, in int nBumpIx, in float fBumpScl)\n{\n    // epsilon value and bump factor for normal calculation\n    const vec2 vEps = vec2(.1f , 0);\n    const float fBumpF = .05f;\n    \n    // ortho project up-origin/z-dir\n    float fT = -vOri.y/vDir.y;\n    \n    // get lit point\n    vec3 vPos = vOri + vDir * fT;\n    \n    // perturbe by y axis\n    vPos = Perturbe(vPos, vOff, vec3(0., 1., 0.), nBumpIx, fBumpScl);\n    fT = length(vPos - vOri);\n    \n    // calculate normal by offsets (epsilon)\n    vec3 vPosX = Perturbe(vPos, vOff + vEps.xyy, vec3(0., 1., 0.), nBumpIx, fBumpScl);\n    vec3 vPosZ = Perturbe(vPos, vOff + vEps.yyx, vec3(0., 1., 0.), nBumpIx, fBumpScl);\n    vec3 vNor = normalize(vec3((vPosX.y - vPos.y) * fBumpF / vEps.x, 1., (vPosZ.y - vPos.y) * fBumpF  / vEps.x));\n    return Intersection( vec4(fT, vNor), \n                         vec4(-fT, vec3(vNor.x, -vNor.y, vNor.z)) );    \n}\n\nvoid mainImage(out vec4 cOut, in vec2 vXY )\n{\n    /// ------- CAMERA\n    \n    // get current camera position and lookat matrix\n    float fCamDist = 1.6f;\n    vec4 vCamPos = vec4(sin(iTime) * fCamDist, 7.5f + sin(iTime * .3f) * 3.5f, cos(iTime) * fCamDist, 0.f);\n    vec3 vCamLAt = vec3(0.f, 0.f, 0.f);\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, vCamLAt, vec3(0.f, 1.f, 0.f));\n    \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    \n    /// ------- RAYTRACING\n    \n    // get ray\n    vec3 vOri, vDir;\n    TransformRay(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    // do raytracing\n    bool bLeftRight = ((vXY.x/iResolution.x) < .5f);\n    Intersection sInt = iPlanePerturbBump(vOri, vDir, vec3(0.), bLeftRight ? 0 : 1, bLeftRight ? .75f : 8.5f);\n    float fTHit = sInt.vTNin.x;\n    vec3 vNor = sInt.vTNin.yzw;\n\n    // hit attributes\n    PosNorm sAttr;\n    sAttr.vPosition = vOri + vDir * fTHit;\n    sAttr.vNormal = vNor;\n    \n    \n    /// ------- TEXTURE\n    \n    // simple color triangles for now\n    cOut = vec4(sin(HexTriangleF(sAttr.vPosition.xz)) * .5f + .5f, sin(sAttr.vPosition.x + sAttr.vPosition.y) * .5f + .5f, 1.f);\n    \n    \n    /// ------- LIGHTING \n    \n    // based on \"Bumped Sinusoidal Warp\" by Shane : https://www.shadertoy.com/view/4l2XWK\n        \n\t// light direction, distance\n\tvec3 vLDir = sAttr.vPosition - vCamLAt + vec3(0.f, 7.f, 0.f);\n\tfloat fLDist = max(length(vLDir), .001);\n\tvLDir /= fLDist;\n    \n\t// diffuse factor\n\tfloat fDif = max(dot(sAttr.vNormal, vLDir), 0.);  \n    fDif = pow(fDif, 4.)*.66 + pow(fDif, 8.)*.34;\n    \n    // attenuation, distance occlusion  \n    float fAtt = 1./(1. + fLDist*fLDist*.03);\n    float fOcc = (1. - fTHit * .01);\n    \n\t// specular factor\n\tfloat fSpecular = max(dot(normalize(reflect(vDir, sAttr.vNormal)), vLDir), 0.0);\n    \n    vec3 cLit = cOut.xyz * fDif * fAtt * fOcc + pow(fSpecular, 100.f) * .3f;\n\tcOut = vec4(clamp(cLit, 0.f, 1.f), 1.f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// EisernSchild 3D library\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// uses code with following rights :\n// Copyright (c) Microsoft\n// \n// SPDX-License-Identifier: MIT\n\n// Hex Grid Library #####################################################\n\n/// Cartesian to hex coordinates\nvec2 HexUV(vec2 vXy)\n{\n\t// hex coords       (u, v) = (          .5 * x + .5 * y,        y ) \n\t// hex coord scaled (u, v) = ((sqrt(3.f) * x + y) / 3.f, y / 1.5f )\n\treturn vec2( (sqrt(3.f) * vXy.x + vXy.y) / 3.f, vXy.y / 1.5f );\n}\n\n// cartesian to hex triangle index (float)\nvec2 HexTriangleF(vec2 vXy)\n{\n    // get hex uv global + local\n    vec2 vHUv = HexUV(vXy);\n    vec2 vHUvL = mod(vHUv, 1.);\n    float fIx = floor(vHUv.x) * 2.;\n    fIx += (vHUvL.x > vHUvL.y) ? 1. : 0.;\n    return vec2(fIx, floor(vHUv.y));\n}\n\n// Transform Library #####################################################\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;  \n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid TransformRay(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n","name":"Common","description":"","type":"common"}]}