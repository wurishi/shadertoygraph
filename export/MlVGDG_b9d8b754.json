{"ver":"0.1","info":{"id":"MlVGDG","date":"1476614987","viewed":369,"name":"Mipmapping parameters","username":"kuvkar","description":"Simulation of different behaviours of glTexParameter with mipmaps. See the comments on the code. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["texturefiltering","mipmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simulating different opengl texture filtering parameters in shader with mipmapping.\n\n// References:\n// https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml\n// https://en.wikipedia.org/wiki/Trilinear_filtering\n\n// opengl allows to configure texture filtering different ways via glTexParameter\n\n// Top left   : GL_LINEAR_MIPMAP_LINEAR    linear blending between mipmap levels and bilinear texture filtering\n// Top right  : GL_NEAREST_MIPMAP_NEAREST  nearest neighbor filtering on textures, selecting nearest mipmap level\n\n// Bottom left:  GL_LINEAR_MIPMAP_NEAREST bilinear filtering and choosing nearest mipmap level \n// Bottom right: GL_NEAREST_MIPMAP_LINEAR nearest neighbor filtering, and linearly blending between mipmaps.\n\n// it seems shadertoy is set up with GL_LINEAR_MIPMAP_LINEAR\n\n\n\n// only square shaped textures and geometry work for now.\nvec2 texSize = vec2(256, 256);\nvec2 geomSize = vec2(256, 256);\n\n\nvec2 uvForNearestSampling(in vec2 uv)\n{\n    vec2 pixel = uv * texSize;\n    pixel -= fract(pixel);\n    return (0.5 + pixel) / texSize;\n}\n\n\n// at least for the drivers I have, mipmap level seems to be selected by\n// rounding the level, instead of flooring.\n/*\nfloat round(float level)\n{\n    if (fract(level) > 0.5)\n    {\n    \treturn ceil(level);\n    }\n    return floor(level);\n}\n*/\n// Trilinear filtering works by linearly interpolating between 2 mipmaps.\nvec4 texture_trilinear(in sampler2D sampler, in vec2 uv, float level)\n{\n    vec4 col_curLevel = textureLod(sampler, uv, floor(level));\n    vec4 col_nextLevel = textureLod(sampler, uv, floor(level + 1.0));\n\n    float blend = fract(level);\n    return mix(col_curLevel, col_nextLevel, blend);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    geomSize -= 0.5 * (1.0 + sin(-3.14159 * 0.5 + iTime)) * geomSize.x * 0.95;\n    vec2 fg_centered = fragCoord.xy - iResolution.xy / 2.;\n    vec2 fg = fg_centered + 0.5 * (geomSize - texSize);\n    \n    vec2 uv = ((fg + texSize / 2.) / geomSize); \n    vec2 dx = dFdx(uv);\n    vec4 col = vec4(0.0, 0.1, 0.2, 0.0);\n\n    float texelsPerPixel = dx.x * texSize.x;\n    float level = log2(texelsPerPixel);\n    \n    //col = vec4(round(level) / 1.);\n    \n    if(all(greaterThan(uv, vec2(0.0))) && all(lessThan(uv, vec2(1.0))))\n    {\n        if(uv.x > 0.5)\n        {\n            if (uv.y > 0.5)\n            {\n                col = textureLod(iChannel0, uvForNearestSampling(uv), round(level));\n            }\n            else\n            {\n                col = texture_trilinear(iChannel0, uvForNearestSampling(uv), level);\n            }\n        }\n        else\n        {\n            \n            if (uv.y > 0.5)\n            {\n                col = texture_trilinear(iChannel0, uv, level);\n            }\n            else\n            {\n                col = textureLod(iChannel0, uv, round(level));\n            }\n        }\n    }\n    \n    if(abs(fg_centered.x) < 1.0 || (abs(fg_centered.y) < 1.0))\n    {\n        col = vec4(.4, .0, .0, .0);\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}