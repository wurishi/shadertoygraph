{"ver":"0.1","info":{"id":"Ms2yDt","date":"1494446546","viewed":297,"name":"Yet another mandelbulb raymarche","username":"ichko","description":"Mandelbulb Raymarcher","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","raytracer","mandelbulb","raymarcher","distanceestimator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX = 8;\nconst float PI = 3.1415927;\nconst vec3 BGCOLOR = vec3(0.0);\nconst float INF =  9999999.0;\nvec3 LIGHT_DIR = vec3(0.0, 1.0, 0.5);\n\n\nstruct Sphere {\n    vec3 p;\n    float r;\n};\n\nstruct Ray {\n\tvec3 o;\n\tvec3 d;\n};\n\n\nSphere sphereContainer[MAX];\nint sphereCnt = 0;\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// Src - http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\nfloat MandelBulbDE(vec3 pos) {\n    pos = mod(pos, 4.0) - 2.0;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    int Iterations = 4;\n    float Bailout = 3.0;\n    float Power = 8.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos*(cos(iTime) / 1.5 + 1.2);\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat traceDE(Ray ray) {\n\tfloat totalDistance = 0.0;\n\tint steps;\n    int MaxRaySteps = 50;\n    float MinimumDistance = 0.0005;\n\tfor (steps=0; steps < MaxRaySteps;++steps) {\n\t\tvec3 p = ray.o + totalDistance * ray.d;\n\t\tfloat distance = MandelBulbDE(p);\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t}\n\treturn 1.0 - float(steps) / float(MaxRaySteps);\n}\n\n\nfloat iSphere(Ray ray, Sphere sphere, out vec3 color) {\n    //ray.o = mod(ray.o, 5.0);\n    //ray.d = mod(-ray.d, 5.0);\n    \n    \n    float dx = ray.o.x - sphere.p.x;\n    float dy = ray.o.y - sphere.p.y;\n    float dz = ray.o.z - sphere.p.z;\n    \n    float a = ray.d.x * ray.d.x + ray.d.y * ray.d.y + ray.d.z * ray.d.z;\n    float b = 2.0 * (ray.d.x * dx + ray.d.y * dy + ray.d.z * dz);\n    float c = dx * dx + dy * dy + dz * dz - sphere.r * sphere.r;\n    float d = b * b - 4.0 * a * c;\n\n    if (d > 0.0) {\n        float t0 = (-b + sqrt(d)) / 2.0;\n        float t1 = (-b - sqrt(d)) / 2.0;\n        float t = max(t0, t1);\n        vec3 ip = ray.o + ray.d * t;\n        vec3 normal = normalize(ip - sphere.p);\n\n        vec3 sphereColor = vec3(1.0, 1.0, 0.0);\n        color = clamp(vec3(sphereColor) * dot(normal, LIGHT_DIR), vec3(0.0), vec3(1.0));\n        color += sphereColor * vec3(0.1);\n        return t;\n    }\n\n    return INF;\n}\n\n\nvoid setupScene() {\n    Sphere sphere0;\n    sphere0.p = vec3(0.0, 0.0, 0.0);\n    sphere0.r = 1.0;\n    \n\tsphereContainer[0] = sphere0;\n    sphereCnt = 1;\n    LIGHT_DIR.x = sin(iTime);\n    LIGHT_DIR.y = cos(iTime);\n}\n\nRay getRay(vec2 uv) {\n\tRay ray;\n    float t = iTime / 5.0;\n    mat3 rot = rotationMatrix(vec3(1.0, 1.0, 1.0), t / 10.0);\n    \n    vec3 ro = vec3(sin(t), cos(t / 32.0) * 15.0, sin(t) / 45.0) * 10.0;\n\n\tray.o = ro;\n\tray.d = normalize(vec3(1.0, uv));\n    \n    float angle = t / 5.0;\n    float s = sin(angle), c = cos(angle);\n    mat2 rot2 = mat2(c, -s, s, c);\n    ray.d.xy *= rot2;\n    ray.d.yz *= rot2;\n    \n\treturn ray;\n}\n\nvec3 trace(Ray ray) {\n    vec3 closestColor = BGCOLOR;\n    float closestDist = INF;\n    \n    for(int i = 0;i < sphereCnt;++i) {\n        vec3 currentColor;\n        float currentDist = iSphere(ray, sphereContainer[i], currentColor);\n        if (closestDist > currentDist) {\n            closestDist = currentDist;\n            closestColor = currentColor;\n        }\n    }\n    return closestColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ar = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(ar * 0.5, 0.5);\n\n    \n    setupScene();\n    vec3 colorSum = vec3(0.0);\n    float kernelSize = 2.0;\n    for(float x = 0.0;x < kernelSize;++x) {\n        for(float y = 0.0;y < kernelSize;++y) {\n            vec2 ruv = uv + vec2(x / kernelSize, y / kernelSize) / iResolution.xy;\n    \t\tRay ray = getRay(ruv);\n    \t\tcolorSum += trace(ray);\n        }\n    }\n    colorSum /= kernelSize * kernelSize;\n\t\n    \n    Ray ray = getRay(uv);\n    vec3 mandelbulbColor = vec3(1.0, 0.0, 0.5) * traceDE(ray) * 1.1 + 0.1;\n    \n\tfragColor = vec4(mandelbulbColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}