{"ver":"0.1","info":{"id":"DdsyDX","date":"1687268546","viewed":158,"name":"Cissoid Distance","username":"nr4","description":"Cissoid distance.\nhttps://en.wikipedia.org/wiki/Cissoid_of_Diocles\nThis uses iq's distance visualization code.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","distance","quartic","analytic","signed","cissoid","diocles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Cissoid Distance\n * Copyright (C) 2023 NR4 <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1,0,-1);\nconst float pi = 3.14159;\n\n// Determine zeros of k.x*x^2+k.y*x+k.z\nvec2 quadratic_zeros(vec3 k)\n{\n    if(k.x == 0.) return -k.z/k.y*c.xx;\n    float d = k.y*k.y-4.*k.x*k.z;\n    if(d<0.) return vec2(1.e4);\n    return (c.xz*sqrt(d)-k.y)/(2.*k.x);\n}\n\n// Determine zeros of k.x*x^3+k.y*x^2+k.z*x+k.w\nvec3 cubic_zeros(vec4 k)\n{\n    if(k.x == 0.) return quadratic_zeros(k.yzw).xyy;\n    \n    // Depress\n    vec3 ai = k.yzw/k.x;\n    \n    //discriminant and helpers\n    float tau = ai.x/3., \n        p = ai.y-tau*ai.x, \n        q = -tau*(tau*tau+p)+ai.z, \n        dis = q*q/4.+p*p*p/27.;\n        \n    //triple real root\n    if(dis > 0.) {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, \n            ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return vec3(ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), \n        arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    return c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n}\n\n// Determine zeros of a*x^4+b*x^3+c*x^2+d*x+e\nvec4 quartic_zeros(float a, float b, float cc, float d, float e) {\n    if(a == 0.) return cubic_zeros(vec4(b, cc, d, e)).xyzz;\n    \n    if(b == 0. && d == 0.) {\n        vec2 ta = quadratic_zeros(vec3(a, cc, e));\n        return vec4(sqrt(ta), -sqrt(ta));\n    }\n    \n    // Depress\n    float _b = b/a,\n        _c = cc/a,\n        _d = d/a,\n        _e = e/a;\n        \n    // Helpers\n    float p = (8.*_c-3.*_b*_b)/8.,\n        q = (_b*_b*_b-4.*_b*_c+8.*_d)/8.,\n        r = (-3.*_b*_b*_b*_b+256.*_e-64.*_b*_d+16.*_b*_b*_c)/256.;\n        \n    // Determine available resolvent zeros\n    vec3 res = cubic_zeros(vec4(8.,8.*p,2.*p*p-8.*r,-q*q));\n    \n    // Find nonzero resolvent zero\n    float m = res.x;\n    if(m == 0.) m = res.y;\n    if(m == 0.) m = res.z;\n    \n    // Apply newton iteration to fix numerical artifacts;\n    // Credit goes to NinjaKoala / epoqe :)\n    for(int i=0; i < 2; i++) {\n        float a_2 = p + m;\n        float a_1 = p*p/4.-r + m * a_2;\n        float b_2 = a_2 + m;\n\n        float f = -q*q/8. + m * a_1;\n        float f1 = a_1 + m * b_2;\n\n        m -= f / f1; // Newton iteration step\n    }\n    \n    // Apply Ferrari method\n    return vec4(\n        quadratic_zeros(vec3(1.,sqrt(2.*m),p/2.+m-q/(2.*sqrt(2.*m)))),\n        quadratic_zeros(vec3(1.,-sqrt(2.*m),p/2.+m+q/(2.*sqrt(2.*m))))\n    )-_b/4.;\n}\n\nvec2 xcissoid(float t, float a) {\n    return 2. * a * t * t / (1. + t * t) * vec2(1., t);\n}\n\nfloat dcissoid(vec2 x, float a) {\n    vec4 t = quartic_zeros(\n        -2. * a,\n        x.y,\n        -4. * a,\n        3. * x.y,\n        2. * x.x\n    );\n    return min(\n        length(x),\n        min(\n            min(\n                length(x - xcissoid(t.x, a)),\n                length(x - xcissoid(t.y, a))\n            ),\n            min(\n                length(x - xcissoid(t.z, a)),\n                length(x - xcissoid(t.w, a))\n            )\n        )\n    );\n}\n\nfloat scene(vec2 uv) {\n    return dcissoid(uv, 3.5 + 3.4*cos(iTime*0.31+2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float scale = 12.;\n    vec2 uv = scale * (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = scale * (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    float px = 1.0 / iResolution.y;\n    float d = scene(uv)/scale;\n    vec3 col = (d > 0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65, 0.85, 1.0);\n\tcol *= 1.0 - exp2(-12.0 * abs(d));\n\tcol *= 0.7 + 0.2 * cos(150.0 * d);\n\tcol = mix( col, vec3(1.0), 1.0 - smoothstep(0.0, 3.0 * px, abs(d)));\n    d = scene(mouse);\n    float l = length(uv - mouse);\n    col = mix(col, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 2.0 * px, abs(l - abs(d))-.001 * scale));\n    col = mix(col, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 2.0 * px, l - px*3.0));\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}