{"ver":"0.1","info":{"id":"ss3fRf","date":"1656906932","viewed":170,"name":"[apathyhill] The Princess's Cake","username":"apathyhill","description":"Originally a birthday gift for someone special.\nReally janky code.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\n\n// Distance stuff\nconst int   MAX_STEPS = 100;\nconst float MAX_DIST  = 100.0;\nconst float MIN_DIST  = 0.001;\n\n// Math constants\nconst float TAU = 6.28318530718;\n\n// Colors\nconst vec3 COLOR_TABLE_1    = vec3(1.0, 0.375, 0.5625);\nconst vec3 COLOR_TABLE_2    = vec3(1.0, 0.7, 0.9);\nconst vec3 COLOR_CAKE       = vec3(1.0, 0.75, 0.3);\nconst vec3 COLOR_ICING      = vec3(1.0, 1.0, 0.98);\nconst vec3 COLOR_STRAWBERRY = vec3(1.0, 0.0, 0.1);\nconst vec3 COLOR_STAR       = vec3(1.0, 0.9, 0.0);\nconst vec3 COLOR_PLATE      = vec3(0.98);\nconst vec3 COLOR_CHERRY_1   = vec3(0.8, 0.3, 0.05);\nconst vec3 COLOR_CHERRY_2   = vec3(0.95, 0.65, 0.0);\n\n// Materials\nconst float MTRL_TABLE      = 0.0;\nconst float MTRL_CAKE       = 1.0;\nconst float MTRL_ICING      = 2.0;\nconst float MTRL_STRAWBERRY = 3.0;\nconst float MTRL_STAR       = 4.0;\nconst float MTRL_PLATE      = 5.0;\nconst float MTRL_EYES       = 6.0;\nconst float MTRL_CHERRY     = 7.0;\n\n// Lighting\nconst vec3  LIGHT_DIR = normalize(vec3(0.1, 1.0, -0.1));\nconst float FOG_START = 3.0; \nconst float FOG_END   = 5.0; \n\nfloat remap(float x, float from1, float to1, float from2, float to2) {\n    return (x - from1) / (to1 - from1) * (to2 - from2) + from2;\n}\n\nfloat linearstep(float a, float b, float t) {\n    return clamp((t - a) / (b - a), 0.0, 1.0);\n}\n\n\nmat2 rotate(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nfloat sdStar(vec3 p, vec3 star, vec3 size, float k) {\n    p = p - star;\n    p.x = abs(p.x);\n    \n    float a = TAU/5.0;\n    float d1 = dot(p, vec3(sin(a), cos(a), 0.0));\n    a = 3.0*TAU/5.0;\n    float d2 = dot(p, vec3(sin(a), cos(a), 0.0));\n    a = 2.0*TAU/5.0;\n    float d4 = dot(p, vec3(sin(a), cos(a), 0.0));\n    \n    float d = min(max(d1, d2), max(p.y, d4));\n    return max(d-size.y, abs(p.z) - size.z);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSprinkles(vec3 p) {\n    float a = atan(p.x, p.z);\n    \n    float i = (a / TAU) * 10.0;\n    \n    \n    \n    return a;\n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdNumber(int n, vec3 p, vec3 pos, vec3 size) {\n    p = p - pos;\n    \n    \n    bool s1, s2, s3, s4, s5, s6, s7, s8, s9;\n    \n    float d = MAX_DIST;\n    \n    if (n == 0) { s1 = true; s2 = true; s3 = true; s4 = true; s5 = true; s6 = true; }\n    if (n == 1) { s2 = true; s3 = true; }\n    if (n == 2) { s1 = true; s2 = true; s4 = true; s5 = true; s7 = true; }\n    if (n == 3) { s1 = true; s2 = true; s3 = true; s4 = true; s7 = true; }\n    if (n == 4) { s2 = true; s3 = true; s7 = true; s8 = true; }\n    if (n == 5) { s1 = true; s3 = true; s4 = true; s6 = true; s7 = true; }\n    if (n == 6) { s3 = true; s4 = true; s5 = true; s7 = true; s8 = true; }\n    if (n == 7) { s1 = true; s2 = true; s3 = true; }\n    if (n == 8) { s1 = true; s2 = true; s3 = true; s4 = true; s5 = true; s6 = true; s7 = true; }\n    if (n == 9) { s1 = true; s2 = true; s6 = true; s7 = true; s9 = true; }\n    \n    vec4 s = vec4(vec3(0.5, 1.0, 2.0) * size.xyy, size.z);\n    \n    if (s1) d = min(d, sdCapsule(p, vec3(-s.x+s.w, s.z, 0.0), vec3(s.x-s.w, s.z, 0.0), s.w));\n    if (s2) d = min(d, sdCapsule(p, vec3(s.x, s.y+s.w, 0.0), vec3(s.x, s.z-s.w, 0.0), s.w));\n    if (s3) d = min(d, sdCapsule(p, vec3(s.x, 0.0+s.w, 0.0), vec3(s.x, s.y-s.w, 0.0), s.w));\n    if (s4) d = min(d, sdCapsule(p, vec3(-s.x+s.w, 0.0, 0.0), vec3(s.x-s.w, 0.0, 0.0), s.w));\n    if (s5) d = min(d, sdCapsule(p, vec3(-s.x, 0.0+s.w, 0.0), vec3(-s.x, s.y-s.w, 0.0), s.w));\n    if (s6) d = min(d, sdCapsule(p, vec3(-s.x, s.y+s.w, 0.0), vec3(-s.x, s.z-s.w, 0.0), s.w));\n    if (s7) d = min(d, sdCapsule(p, vec3(-s.x+s.w, s.y, 0.0), vec3(s.x-s.w, s.y, 0.0), s.w));\n    if (s8) d = min(d, sdCapsule(p, vec3(-s.x+s.w, s.y+s.w, 0.0), vec3(s.x-s.w, s.z-s.w, 0.0), s.w));\n    if (s9) d = min(d, sdCapsule(p, vec3(-s.x+s.w, 0.0+s.w, 0.0), vec3(s.x-s.w, s.y-s.w, 0.0), s.w));\n    \n    \n    return d;\n}\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float k) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t*ab;\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = smin(max(x, y), 0., k);\n    \n    return e + i;\n}\n\nfloat sdPlane(vec3 p, vec4 plane) {\n\treturn dot(p, plane.xyz) - plane.w;\n}\n\nvec3 camDirection(vec3 forward, vec2 uv) {\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), forward),\n         up = cross(forward, right);\n    return normalize(forward + right*uv.x + up*uv.y);\n}\n\nvec2 getDist(vec3 p) {\n\tvec2 d;\n    \n    d.x = MAX_DIST;\n    \n    float distStar = min(sdStar(p, vec3(0.0, 2.5, 0.0), vec3(0.2, 0.1, 0.05), 0.1),\n                         sdStar(abs(p), vec3(0.6, 2.3, 0.0), vec3(0.1, 0.05, 0.05), 0.1));              \n    //distStar = min(distStar, sdNumber(2, p, vec3(-0.3, 1.12, -0.9), vec3(0.25, 0.25, 0.05)));\n    //distStar = min(distStar, sdNumber(2, p, vec3(0.3, 1.12, -0.9), vec3(0.25, 0.25, 0.05)));\n    \n    vec3 pEyes = p;\n    pEyes.x = abs(pEyes.x);\n    \n    float distEyes = sdCapsule(pEyes, vec3(0.05, 2.5, -0.05), vec3(0.05, 2.55, -0.05), 0.02);\n    pEyes = pEyes - vec3(0.6, 0.0, 0.0);\n    pEyes.x = abs(pEyes.x);\n    distEyes = min(distEyes, sdCapsule(pEyes, vec3(0.025, 2.31, -0.05), vec3(0.025,2.33, -0.05), 0.015 ));\n    \n                          \n    \n    float distCake = min(sdCylinder(p, vec3(0.0), vec3(0.0, 1.0, 0.0), 1.0, 0.3),\n                         sdCylinder(p, vec3(0.0), vec3(0.0, 2.0, 0.0), 0.7, 0.3));\n                          \n    float icing = -abs(sin(atan(p.x, p.z)*6.0)) * 0.125;\n    float distIcing = min(sdCylinder(p, vec3(0.0, 0.6+icing, 0.0), vec3(0.0, 1.05, 0.0), 1.05, 0.3),\n                          sdCylinder(p, vec3(0.0, 1.6+icing, 0.0), vec3(0.0, 2.05, 0.0), 0.75, 0.3)); \n                          \n    float distTable = sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0));\n    \n    \n    float distStrawberry = MAX_DIST;\n    \n    vec3 p2 = p;\n    float a = mod(atan(p.z, p.x) + TAU*0.125*0.5, TAU*0.125) - TAU*0.125*0.5;\n    p2.x = cos(a) * length(p.xz);\n    p2.z = sin(a) * length(p.xz);\n    float dimples = 0.0;\n    float distBerry = smin(length(p2 - vec3(0.9, 1.25, 0.0)) - 0.1 + dimples,\n                           length(p2 - vec3(0.9, 1.35, 0.0)) - 0.06 + dimples,\n                           0.05);                   \n    distStrawberry = min(distStrawberry, distBerry);\n\n    vec3 pWhipped = vec3(0.9, 1.1, 0.0) - p2;\n    pWhipped.xz *= rotate(pWhipped.y*10.0);\n    distIcing = min(distIcing, sdBox(pWhipped, vec3(0.12)));\n    pWhipped = vec3(0.6, 2.15, 0.0) - p2;\n    pWhipped.xz *= rotate(pWhipped.y*10.0);\n    distIcing = min(distIcing, sdBox(pWhipped, vec3(0.1)));\n    pWhipped = vec3(0.0, 2.1, 0.0) - p;\n    pWhipped.xz *= rotate(pWhipped.y*10.0);\n    distIcing = min(distIcing, sdBox(pWhipped, vec3(0.25)));\n    \n    float distPlate = min(sdCylinder(p, vec3(0.0), vec3(0.0, 0.05, 0.0), 1.75, 0.2),\n                          sdCylinder(p, vec3(0.0), vec3(0.0, 0.1, 0.0), 1.25-icing, 0.1));\n    \n    \n    vec3 pCherry = p;\n    pCherry.xz = abs(pCherry.xz);\n    float distCherry = length(pCherry - vec3(0.3, 2.2, 0.3)) - 0.15;\n    \n    d.x = min(d.x, distTable);\n    d.x = min(d.x, distCake);\n    d.x = min(d.x, distIcing);\n    d.x = min(d.x, distStrawberry);\n    d.x = min(d.x, distStar);\n    d.x = min(d.x, distPlate);\n    d.x = min(d.x, distEyes);\n    d.x = min(d.x, distCherry);\n    \n    if (d.x == distTable)      d.y = MTRL_TABLE;\n    if (d.x == distCake)       d.y = MTRL_CAKE;\n    if (d.x == distIcing)      d.y = MTRL_ICING;\n    if (d.x == distStrawberry) d.y = MTRL_STRAWBERRY;\n    if (d.x == distStar)       d.y = MTRL_STAR;\n    if (d.x == distPlate)      d.y = MTRL_PLATE;\n    if (d.x == distEyes)       d.y = MTRL_EYES;\n    if (d.x == distCherry)     d.y = MTRL_CHERRY;\n    \n    return d;\n}\n\n\nvec2 rayMarch(vec3 rO, vec3 rD) {\n\tvec2 dO;\n    \n    float t;\n\tfor(t = 0.0; t < MAX_DIST;) {\n\t    vec2 dS = getDist(rO + rD * t);\n        t += dS.x;\n        if (dS.x < MIN_DIST) {\n            dO.y = dS.y;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    dO.x = t;\n\treturn dO;\n}\n\n// Get shadow amount\nfloat rayMarchShadow(vec3 rO, vec3 rD, float k) {\n    float res = 1.0;\n\tfor(float t = 0.0; t < MAX_DIST;) {\n\t    float d = getDist(rO + rD * t).x;\n        if (d < MIN_DIST) { return 0.0; } \n        res = min(res, k*d/t);\n        t += d;\n\t}\n\treturn res;\n}\n\n// Get normal of point\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(0.001, 0.0);\n\tvec3 n = getDist(p).x - vec3(\n\t         getDist(p - e.xyy).x, \n\t\t\t getDist(p - e.yxy).x, \n\t\t\t getDist(p - e.yyx).x);\n\n\treturn normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col;\n\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    vec2 dir = vec2(iTime*0.5, 0.5); // Spinning camera\n    if (iMouse.z > 0.0) { // Mouse control\n        dir = vec2((iMouse.x/iResolution.x - 0.5) * TAU, \n                    iMouse.y/iResolution.y);\n    }\n    vec3 rO = vec3(sin(dir.x), dir.y, -cos(dir.x)) * 5.0; // Ray origin\n    vec3 rT = vec3(0.0, 1.2, 0.0); // Ray target\n    vec3 rD = camDirection(normalize(rT - rO), uv); // Ray direction\n    \n    vec2 res = rayMarch(rO, rD);\n    \n    if (res.x < MAX_DIST) {\n        vec3 p = rO + rD * res.x;\n        \n        vec3 n = getNormal(p);\n        vec3 nReflect = reflect(rD, n);\n        float lightSpecular = max(dot(nReflect, LIGHT_DIR), 0.0);\n        \n        \n        bool doLighting = true;\n        \n        if (res.y == MTRL_TABLE) { // Table\n            float v = (floor(mod(p.x*2.0, 2.0)) + floor(mod(p.z*2.0, 2.0))) * 0.5;\n            col = mix(COLOR_TABLE_1, COLOR_TABLE_2, v);\n        } else if (res.y == MTRL_CAKE) { // Cake\n            col = COLOR_CAKE;\n        } else if (res.y == MTRL_ICING) { // Icing\n            col = COLOR_ICING;\n        } else if (res.y == MTRL_STRAWBERRY) { // Strawberry\n            col = COLOR_STRAWBERRY;\n            col += lightSpecular * 0.5;\n        } else if (res.y == MTRL_STAR) { // Star\n            col = COLOR_STAR;\n            doLighting = false;\n        } else if (res.y == MTRL_PLATE) { // Plate\n            col = COLOR_PLATE;\n            col += lightSpecular;\n        } else if (res.y == MTRL_EYES) { // Star eyes\n            col = vec3(0);\n            col += lightSpecular;\n        } else if (res.y == MTRL_CHERRY) { // Cherry\n            col = mix(COLOR_CHERRY_1, COLOR_CHERRY_2, clamp(n.y + 0.5, 0.0, 1.0));\n            col += lightSpecular * 0.25;\n        }\n        \n        col = min(col, 1.0); // Clamp colors\n        \n        // Lighting\n        if (doLighting) {\n            float shade = max(dot(n, LIGHT_DIR), 0.0); // N dot L\n            if (shade > 0.0) shade *= rayMarchShadow(p+n*0.1, LIGHT_DIR, 16.0); // Shadows\n            \n            col *= remap(shade, 0.0, 1.0, 0.8, 1.0);\n        }\n        \n        col *= linearstep(FOG_END, FOG_START, length(p)); // Add \"fog\" fade\n    }\n    \n    fragColor = vec4(col, 1.0); // Final output\n}","name":"Image","description":"","type":"image"}]}