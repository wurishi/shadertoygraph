{"ver":"0.1","info":{"id":"4lS3WG","date":"1431640054","viewed":324,"name":"4d ray marching","username":"ostkaka","description":"Ray marching in 4 dimensions! This is a projection on a 3d slice of 4d.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["4draymarchingtesseractdistortion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define ITERATIONS 64\n#define EPSILON 0.01\n#define FAR 1.0e6\n#define PI 3.1415926535897932384626\n\nfloat hTorus(in vec4 pos, in float r1, in float r2)\n{\n    return length(vec3(length(pos.xz)-r1,pos.y, pos.w))-r2;\n}\n\nfloat tesseract(in vec4 p, in float s)\n{\n    vec4 d = abs(p) - 0.5*s;\n  return min(max(max(d.x, d.y),max(d.z,d.w)),0.0) +\n         length(max(d,0.0));\n}\n\n// Should loook like a sphere\nfloat hCylinder(in vec4 pos, float r)\n{\n\treturn length(pos.xyz)-r;   \n}\n\nfloat hSphere(in vec4 pos, float r)\n{\n    return length(pos)-r;\n}\n\nvec4 repetition(in vec4 p, in vec4 c )\n{\n   return mod(p-0.5*c,c)-0.5*c;\n}\n\n\n\nvec2 map(in vec4 pos)\n{\n    vec4 localPos = repetition(pos, vec4(4, 2, 5, 4));\n    \n    float distance = FAR;\n    float distortedDistance = FAR;\n    \n    distance = min(distance, tesseract(localPos, 1.0));\n    distance = max(distance, -hTorus(localPos, 0.5, 0.5));\n    \n    distance = min(distance, hCylinder(localPos, 0.05));\n    distance = min(distance, hSphere(localPos-vec4(vec3(0.0), 1.0), 0.2));\n    \n\n    \n    vec4 spos = 16.0*pos;\n    distance += 0.01*(sin(spos.x)+sin(spos.y)+sin(spos.z)+sin(spos.w));\n    distortedDistance = distance-0.01;\n    \n    distance = min(distance, pos.y+1.0);\n    \n    return vec2(distance, min(distortedDistance, distance));\n}\n\nvec4 calculateNormal(vec4 pos, float epsilon)\n{\n\tvec4 epsilonVec = vec4(epsilon, 0.0, 0.0, 0.0);\n    vec4 xyyy = vec4(epsilon, 0.0, 0.0, 0.0);\n    vec4 yxyy = vec4(0.0, epsilon, 0.0, 0.0);\n    vec4 yyxy = vec4(0.0, 0.0, epsilon, 0.0);\n    vec4 yyyx = vec4(0.0, 0.0, 0.0, epsilon);\n    \n\tvec4 normal = vec4(\n\t    map(pos+xyyy).x - map(pos-xyyy).x,\n\t    map(pos+yxyy).x - map(pos-yxyy).x,\n\t    map(pos+yyxy).x - map(pos-yyxy).x,\n    \tmap(pos+yyyx).x - map(pos-yyyx).x);\n\treturn normalize(normal);\n}\n\nvec4 castRay(in vec4 pos, in vec4 direction)\n{\n    vec4 rayPos = pos+0.25*direction;\n    vec4 rayDirection = direction;\n    float distance = 0.0;\n    float rayDistance = distance;\n    \n    float iterations = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n        iterations += 1.0;\n        \n        \n        vec2 mapPoint = map(rayPos);\n        distance = max(mapPoint.y, 0.25*mapPoint.x);\n        \n        rayPos += distance*rayDirection;\n        rayDistance += distance;\n        \n        if (mapPoint.x < EPSILON) break;\n        if (rayDistance  > FAR) break;\n        \n    }\n    \n    \n    vec4 lightdir = normalize(vec4(0.0, 0.0, 0.0, 1.0));\n    vec4 normal = calculateNormal(rayPos, EPSILON);\n    \n    \n    vec3 aura = vec3(1.0)*iterations/float(ITERATIONS)/pow(rayDistance*0.0625, 0.5);\n    vec3 color = vec3(0.0, 0.2, 0.0)*(dot(lightdir, normal))/pow(rayDistance*0.25, 0.5);\n    \n    if (distance < 0.1)\n       return vec4(vec3(color+aura-0.25), 1.0);\n    else\n   \t\treturn vec4(vec3(aura-0.25), 1.0);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(-1.0) + 2.0*fragCoord.xy / iResolution.xy;\n    vec2 mouse = 8.0 * (iMouse.xy / iResolution.xy-0.5);\n    mouse.y = clamp(mouse.y, -0.49*PI, 0.49*PI);\n\n    if (iMouse.y == 0.0)\n        mouse.y = 0.0;\n    \n\tfloat time = 1.0 + 0.125*iTime;\n    \n    // camera\t\n\tvec4 pos = vec4(2.0, 0.0, 2.0, 2.0+iTime);\n\tvec3 target = pos.xyz + vec3( cos(mouse.x + time), tan(mouse.y), sin(mouse.x + time) );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( pos.xyz, target, 0.0 );\n    \n    // ray direction\n\tvec3 direction = ca * normalize( vec3(0.5*uv.xy,1.0) );\n    \n \n    time = 0.25+0.25*clamp(cos(0.1*PI*iTime+1.2*PI), -0.95, 0.95)/0.95;\n    vec2 phase = vec2(cos(PI*time), sin(PI*time));\n    \n    vec4 direction4 = vec4(direction.x, direction.y*phase.x, direction.z, 1.0*direction.y*phase.y);\n   \n\tfragColor = clamp(castRay(pos+iTime*vec4(vec3(0.0), 0.1), direction4), 0.0, 1.0);\n}","name":"","description":"","type":"image"}]}