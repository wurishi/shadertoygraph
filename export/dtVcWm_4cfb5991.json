{"ver":"0.1","info":{"id":"dtVcWm","date":"1700310879","viewed":14,"name":"Yet another sphere tracer","username":"serioux666","description":"my first attempts at rendering SDFs using sphere tracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","spheretracing","gouraud","blinn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nconst vec3 c = vec3(1., 0., -1.);\nconst float pi = 3.14159265359;\nconst float EPSILON = 0.00001;\nconst float MAX_DEPTH = 100.0;\nconst int MAX_ITERATIONS = 1000;\n\nvec3 lightPos()\n{\n    return vec3(5.0 * cos(iTime), 0.3 * sin(iTime / 3.), 20. * (sin(iTime * 0.7) - 1.));\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opRepeatedSphere3d(vec3 p, vec3 s)\n{\n    vec3 r = p - s * round(p/s);\n    return sdSphere(r, 0.5);\n}\n\nfloat sceneSdf(vec3 p)\n{\n    //return sdSphere(mod(p, 1.0) - 0.5, .1);\n    //return min(opRepeatedSphere3d(p - 0.4, c.xxx*0.8), sdSphere(p - lightPos(), .1));\n    return min(opRepeatedSphere3d(p - 2., c.xxx*4.), sdPlane(p, c.yxy, 3.0));\n}\n\nvec3 sceneNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSdf(p + EPSILON * c.xyy) - sceneSdf(p - EPSILON * c.xyy),\n        sceneSdf(p + EPSILON * c.yxy) - sceneSdf(p - EPSILON * c.yxy),\n        sceneSdf(p + EPSILON * c.yyx) - sceneSdf(p - EPSILON * c.yyx)));\n}\n\nmat4 perspective(float fov, float near, float far)\n{\n    float S = 1. / tan(fov / 2. * pi / 180.);\n    return mat4(\n    S * c.xyyy,\n    S * c.yxyy,\n    vec4(0., 0., -far / (far - near), -far * near / (far - near)),\n    c.yyzy);\n}\n\nfloat spheretrace(vec3 p0, vec3 dir)\n{\n    float depth = EPSILON;\n    for(int i = 0; i < MAX_ITERATIONS; ++i) {\n        float dist = sceneSdf(p0 + depth * dir);\n        if(dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if(depth > MAX_DEPTH) {\n            return MAX_DEPTH;\n        }\n    }\n    return MAX_DEPTH;\n}\n\nfloat shadowing(vec3 p, vec3 n, vec3 light, float k)\n{\n    float depth = EPSILON;\n    vec3 dir = normalize(light - p);\n    if(dot(dir, n) < 0.) {\n        return 0.;\n    }\n    float lightness = 1.0;\n    float max_depth = length(p - light) - EPSILON;\n    for(int i = 0; i < MAX_ITERATIONS && depth < max_depth; ++i) {\n        float dist = sceneSdf(p + depth * dir);\n        lightness = min(lightness, k * dist / depth);\n        depth += dist;\n    }\n    return lightness;\n}\n\nconst float I_specular = 10.0;\nconst float shininess = 3.;\nconst float decay_specular = -1.3;\nconst float decay_gouraud = -1.7;\nconst float I_gouraud = 20.;\nconst float I_ambient = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - iResolution.xy / 2. ;\n    float z = iResolution.y / tan(50./180.* pi / 2.0);\n    vec3 dir = normalize(vec3(uv, -z));\n    vec3 eye = vec3(0.0, 0.0, 5.);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = c.xyy * 0.5;\n    \n    vec3 light = lightPos();\n    float depth = spheretrace(eye, dir);\n    if(depth < MAX_DEPTH) {\n        vec3 p = eye + depth * dir;\n        vec3 normal = sceneNormal(p);\n        vec3 light_vec = light - p;\n        vec3 L = normalize(light_vec);\n        float light_dist = length(light_vec);\n        float blinn = max(0., pow(dot(-dir + L, normal) / length(-dir + L), shininess) * I_specular);\n        float lit = 1.0;\n        float shadow = shadowing(p, normal, light, 5.);\n        col.xyz = shadow * (c.xxx * dot(L, normal) * I_gouraud * pow(light_dist, decay_gouraud) + c.xxx * pow(light_dist, decay_specular) * blinn) + c.xxx * I_ambient;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}