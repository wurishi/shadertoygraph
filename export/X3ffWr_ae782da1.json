{"ver":"0.1","info":{"id":"X3ffWr","date":"1728319692","viewed":10,"name":"portable dvd screen","username":"secondthumb","description":"dvd screen","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rave","dvd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function to map a value to a custom color gradient\nvec3 colorGradient(float t) {\n    // Ensure t is between 0.0 and 1.0\n    t = clamp(t, 0.0, 1.0);\n\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 purple = vec3(0.5, 0.0, 0.5);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n\n    if (t < 0.5) {\n        // Interpolate between blue and purple\n        return mix(blue, purple, t * 2.0);\n    } else {\n        // Interpolate between purple and yellow\n        return mix(purple, yellow, (t - 0.5) * 2.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;          // Center the coordinates\n    uv.x *= iResolution.x / iResolution.y; // Maintain aspect ratio\n\n    float O = 0.0;                // Initialize the intensity accumulator\n    float n = iTime;              // Time variable for animation\n    float l = length(uv);         // Distance from the center\n    vec2 p = uv;                  // Position vector\n\n    float angle = atan(uv.y, uv.x); // Angle for polar coordinates\n    float radius = l;               // Radius for polar coordinates\n\n    // Create a rotating coordinate system\n    float rotation = n * 0.5;\n    mat2 rot = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n    p *= rot;\n\n    // Loop to create intricate patterns\n    for (float i = 1.0; i < 300.0; i++) {\n        float e;\n        // Modify position vector with complex functions for dynamic patterns\n        p -= sin(i * 0.111 * sin(n) + length(p) * cos(n * 0.5)) \n             * vec2(sin(e = i * 0.07 * sin(n * 1.5) * cos(n - 3.5) + n * 2.0), cos(e));\n        // Accumulate intensity with more dynamic expressions\n        O += pow(\n            0.003 / abs(length(p) + sin(n * 4.0 + i * 0.033 + l + radius * sin(n * 0.3)) * 0.015)\n            * (1.0 + cos(i * 0.02 + l * 2.0 + 3.0 - n * 2.0)), \n            1.2\n        );\n    }\n\n    // Apply custom color gradient\n    float t = (sin(angle * 2.0 + n) + 1.0) * 0.5; // Map to 0.0 - 1.0\n    vec3 color = O * colorGradient(t);\n\n    // Output the final color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}