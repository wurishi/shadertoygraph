{"ver":"0.1","info":{"id":"lfSXDw","date":"1706391484","viewed":134,"name":" Hexa DDA with some filigrane","username":"Elsio","description":"... of course you can't demonstrate a traversal algorithm without adding a filigrane texture and subtle spots of pastel colors\n\n\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["voxel","hexagon"],"hasliked":0,"parentid":"lcjSDD","parentname":"Hexagonal DDA without filigrane"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h31(v)  fract(sin(dot(v, vec3(912.9898,781.233,213.233)))*43758.5453123)\n#define path(z) vec3(z, cos((z) * .085) * 14., sin((z) * .085) * 8.)\n#define HS      vec2[](vec2(0, 1), vec2(1, .5), vec2(1, -.5))\n#define map(p)  length((p).yz - path((p).x).yz)\n#define HEX     vec3(.866, 1, 1.75)\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t = iTime * 5., i, z, border;\n    vec3  R = iResolution, norm, p, q, d, pastel,\n         ro = path(t),\n         cp = vec3(0, 1, 0),\n         fw = normalize(path(t + 1.) - ro),\n         cu = normalize(cross(fw, cp)),\n         cv =          (cross(cu, fw)),\n         D  = mat3(cu, cv, fw) * vec3((u.yx - .5 * R.xy) / R.y, 1.8),\n         rl = abs(D);\n    vec2 k;         \n    //  -------------------------------------------------\n    \n    ro *= 1.5;\n    p = round(ro / HEX);\n    p.xy += \n        mod(\n            p.xy + vec2(0, step(2., mod(p.x + 1., 4.)))\n            , 2.);\n\n    while(i++ < 130. && map(p * HEX / 1.5) < 4.) {\n        q = ro - p * HEX,\n        d = vec3(100);\n        \n        int j;\n        vec2 f,\n             h = (D * HEX).xy,\n             g = (q * HEX).xy;\n             \n        while(j++ < HS.length())\n            k = HS[j - 1],\n            k *= sign(dot(k, h)),\n            z = (1. - dot(k, g)) / dot(k, h),\n            z < d.z ? d = vec3(k * 2., z) : d;\n        \n        z = .5 * HEX.z / abs(D.z) - q.z / D.z;\n        \n        norm = d.z < z\n            ? z = d.z, vec3(1, 1, 0)        // laterals\n            : vec3(0, 0, 1);                // base\n        \n       p += norm *= vec3(d.xy, sign(D.z));\n    }\n    \n    \n    q = ro + z * D;\n    k = (q - (p * HEX)).xy;\n    \n    \n    norm.xy = norm.xy * HEX.xy;\n    \n    border\n        = abs(\n            norm.z != .0  \n                ? max(dot(abs(k), vec2(.866, .5)), abs(k.y)) - 1.3\n                : min(        // laterals\n                      abs(mod(q.z, HEX.z) - HEX.z/2.) + .32, \n                      abs(length(k - dot(k, norm.xy) * norm.xy) - 3.385)\n                  )\n        ) * 3. - 1.;\n    \n    pastel = h31(p) < .2\n                ? floor(norm + sin(p))\n                : vec3(1);\n                \n    o.rgb = (pastel * .2 + .8)\n             * (8./z - .1) \n             * (1. + smoothstep(.0, fwidth(border), border)) / 4.;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}