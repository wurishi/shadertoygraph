{"ver":"0.1","info":{"id":"cljBR3","date":"1694391413","viewed":94,"name":"organic mess","username":"pb","description":"use keys: asdw and cursor keys please","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["fractal","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float[] params =  float[](\n1.01,\n-.182,\n-.1,\n0.,\n0.,\n.6,\n0.,\n.02,\n-.3,\n0.,\n21.,\n0.,\n25.,\n0.02,\n-2.,\n0.,\n-.2,\n1.7,\n2.,\n1.5,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.\n);\n\n\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \n                \n/*       \nfloat[] params =  float[](\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n.1,\n0.,\n0.,\n0.,\n9.,\n0.,\n4.,\n1.,\n-2.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.\n);\n*/\n\n        ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//save 3d position and cumulative rotation matrix in texture so we can fully navigate in 3d with dual\n//axis control,  thanks to Amirk https://www.shadertoy.com/view/7sKBzz for demonstrating how to do it\n//in multi-pass texture method for the 4d Lorentz transformation\n//any other variables whose state we want to be user (and not iTime) controlled should be addede here\n\n#define PI 3.14159265\n\nfloat ca1,sa1,ca2,sa2,caa,saa;\n\nvec4 handleKeyboard() {     \n\n    vec4 ik;\n\n    ik[0] = texelFetch(iChannel1, ivec2(38,0),0).x - texelFetch(iChannel1,ivec2(40,0),0).x;\n    ik[1] = texelFetch(iChannel1, ivec2(37,0),0).x - texelFetch(iChannel1,ivec2(39,0),0).x;\n    ik[2] = texelFetch(iChannel1, ivec2(87,0),0).x - texelFetch(iChannel1,ivec2(83,0),0).x; \n    ik[3] = texelFetch(iChannel1, ivec2(65,0),0).x - texelFetch(iChannel1,ivec2(68,0),0).x;\n    //87, 83 w,s\n    //65, 68 a,d\n    \n    return ik;\n\n}\n\nmat3 next_2d_rotation(vec4 dual_axis) {\n\n    if ( dual_axis[1] != 0. ) {\n\n        if ( dual_axis[1] > 0. ) {caa=ca1,saa=sa1;}\n        else                     {caa=ca2,saa=sa2;}\n \n        return mat3( caa,0,-saa,0,1,0,saa,0,caa);\n    }\n    \n    else if ( dual_axis[2] != 0. ) {\n        if ( dual_axis[2] > 0. ) {caa=ca1,saa=sa1;}\n        else                     {caa=ca2,saa=sa2;}  \n \n        return mat3(1,0,0, 0,caa,-saa, 0,saa,caa);\n\n    }\n  \n    else if ( dual_axis[3] != 0. ) {\n        if ( dual_axis[3] > 0. ) {caa=ca2,saa=sa2;}\n        else                     {caa=ca1,saa=sa1;}  \n \n        return mat3(caa,-saa,0,  saa,caa,0, 0,0,1);\n \n    }\n    \n    \n    else {\n        return mat3(1,0,0,0,1,0,0,0,1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 dual_axis = vec4(0.);\n    dual_axis = handleKeyboard();  //dual_axis -> thrust,yaw,pitch,roll\n   \n    vec3 ro = vec3(.2337,.2,-2.521);  //this will be the initial  position\n    \n    float freq = 500.;\n    \n    //we may have a control to modulate these - that is why they are not just a constant\n    ca1 = cos(PI/freq), sa1=sin(PI/freq);\n    ca2 = cos(-PI/freq), sa2=sin(-PI/freq);\n    \n    mat3 full_rot = mat3(1,0,0,\n                         0,1,0,\n                         0,0,1);\n                        \n    if(dual_axis==vec4(0) ) { //if no keys are pressed we just copy from the previous frame\n\n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n        \n        if(ivec2(fragCoord)==ivec2(4,4)){\n            fragColor= vec4(texelFetch( iChannel0, ivec2(4, 4), 0) );\n        }\n\n        if(iFrame<10){\n        \n            if(ivec2(fragCoord)==ivec2(4,4)){\n                fragColor= vec4(dual_axis);\n            }\n            else if(ivec2(fragCoord)==ivec2(5,5)){\n                fragColor = vec4(ro,0.);\n            }\n            \n            for(int i=1; i<=3; i++)\n                if(ivec2(fragCoord)==ivec2(i,i))\n                    fragColor.r=1.;\n        }\n\n        \n    } else {\n \n\n        if(iFrame>10){\n            \n            ro = texelFetch( iChannel0, ivec2(5, 5), 0).rgb; \n            \n            for(int i=1; i<=3; i++) {\n                for(int j=1; j<=3; j++){\n                    full_rot[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n                }  \n            }\n\n        }\n\n\n        full_rot *= next_2d_rotation(dual_axis);\n        \n        //new \"forward\" direction is always the negative of the\n        //rotation matrix 2nd row which starts out as \"z\"\n        ro += .0006 * -full_rot[2]* dual_axis.x ; // .1*thrust;\n      \n\n        if(ivec2(fragCoord)==ivec2(4,4)){\n            fragColor= vec4(dual_axis);\n        }else if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor = vec4(ro,0.);\n        }else{\n            //StoreMatrix:\n            for(int i=1; i<=3; i++)\n                for(int j=1; j<=3; j++)\n                    if(ivec2(fragCoord)==ivec2(i,j)){\n                        fragColor.r=full_rot[i-1][j-1];\n                    }\n        }      \n        \n        \n         \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nmat3 rot;\n\nvec3  ifs_color, ro;\nconst float maxDist=5.;\n\nconst float mScale = 2.52;\nconst float pi = 3.14159;\n\n\n//get the current Camera View from Buffer A\nmat3 get_full_rot() {\n    mat3 M = mat3(1,0,0,\n                  0,1,0,\n                  0,0,1);\n                  \n    if(iFrame>10){\n        for(int i=1; i<=3; i++)\n           for(int j=1; j<=3; j++)\n              M[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n    }\n    return M;\n}\n\n\nfloat mbox(vec3 p)\n{\n  ifs_color = vec3(0.);\n  vec4 q, q0;\n  float dum = 0.;\n  q0 = vec4 (p, 1.);\n  q = q0;\n\n  for (float n = 0.; n < params[10]; n ++) {\n\n    q.xyz = clamp (q.xyz, -1.-params[5], 1.+params[5]) * (2.+params[2]) \n            - (1.+params[20])*q.xyz - params[21]*vec3(params[22],params[23],params[24]);\n\n    q = q * (mScale+params[1]) / clamp (dot (q.xyz, q.xyz), (.2+params[15])-params[0], 1.+params[0]) + q0;\n    dum ++;\n   \n    if (q.x*q.y > 0. ) ifs_color.x ++;\n    if (q.y*q.z > 0. ) ifs_color.y ++;\n    if (q.z*q.x > 0. ) ifs_color.z ++;  \n\n  }\n\n  ifs_color /= params[10];\n\n  return length (q.xyz) / q.w;\n}\n\nfloat scene(vec3 p)\n{\n  return max( mbox(p), -(length(p - ro) - params[13] ) );\n}\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 1e5 );\n}\n\n\nvec3 gradient(vec3 p)\n{\n\n  float dir,ttt;\n  float tt = mod(iTime*2.,40.);\n  if ( tt < 20. ) ttt = tt; else ttt=40.-tt;\n  \n  const float eps = 1e-3;\n  float expand = params[12] + ttt*3. ;\n  vec3 e = vec3 (eps*expand, -eps*expand, 0.);\n  vec4 v = vec4 ( scene(p + e.xxx), scene(p + e.xyy),\n                  scene(p + e.yxy), scene(p + e.yyx) );\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 camera_direction)\n{\n  vec3 col=vec3(0.), normal, pos=ro;\n\n  const int maxSteps = 100;\n  float totdist=0., d=0.;\n  for (int j = 0; j < maxSteps; j ++) {\n    d = scene(pos);\n    pos += d*rd;\n    totdist += d*.7;\n    if (d < 1e-5*(1.+totdist*10.*params[25]) || totdist > maxDist) break;\n  }\n\n  if (totdist < maxDist) {\n\n    vec3 light01 = normalize(ro + vec3(10.,0.,0.));\n    //vec3 light01 = camera_direction;\n\n    normal = gradient(pos);\n  \n    if ( params[7] > 0. ) {\n\n      col = normalize(vec3( ifs_color.x*cos( params[17]*ifs_color.x ),\n                            ifs_color.y*cos( params[18]*ifs_color.y),\n                            ifs_color.z*cos( params[19]*ifs_color.z) ) )\n                               / (1. + params[7]) ;\n \n      }\n      else if ( params[7] < 0. ) {\n        col = normalize(ifs_color) / (1.+abs(params[7]));\n      }\n      else {\n        col  = vec3(.1,.1,.2);\n      }\n\n      col = col * ( ( 1.0+params[8]) * max (dot (normal, light01), 0.) ) * sqrt(ifs_color.xyz)\n           + .8*sqrt(ifs_color.xyz)*(1.0+params[9]) * \n           pow (max (0., dot (light01, reflect (rd, normal))), 0.6-params[6])\n            ;\n    \n      col *= exp(-totdist*3.);\n\n  }\n\n  return 1.-exp( -clamp (col, 0., 1.) );\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n   \n    //get the current Ray Origin from Buffer A\n    ro = texelFetch( iChannel0, ivec2(5,5), 0).xyz;\n  \n    //get the camera view matrix\n    rot = get_full_rot();\n    \n    vec3 rd = rot*normalize( vec3( uv, params[14] * (1.+.2*sin(iTime/5.) ) ) );\n\n    vec3 dir = rot[2];    \n\n    //if (iMouse.w == 0.) ro -= dir * mod(iTime/60.,.7);\n    \n    vec3 color = ( render(ro,rd,dir) );\n    \n    \n    fragColor = vec4( 3.*color, 0.);\n}","name":"Buffer B","description":"","type":"buffer"}]}