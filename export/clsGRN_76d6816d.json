{"ver":"0.1","info":{"id":"clsGRN","date":"1671412530","viewed":141,"name":"Blorb","username":"4LT","description":"Something worth pondering","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["orb","crystalball","pondering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float speed = 0.02;\nconst float pulseSpeed = 3.0;\nconst float tau = 2.0 * acos(-1.0);\nconst float f = 1.0;\nconst float gamma = 0.4545;\nconst float camDist = 2.7;\nconst vec3 glow = vec3(0.0, 0.4, 0.9);\n\nstruct Hit {\n    vec3 near;\n    vec3 far;\n    float sDist;\n};\n\nHit sphereHit(vec3 cam, vec3 rayDir) {\n    float camDotRay = dot(cam, rayDir);\n    float b = 2.0 * camDotRay;\n    float c = dot(cam, cam) - 1.0;\n    \n    float det = b*b - 4.0*c;\n    \n    Hit hit;\n    hit.sDist = length(cam - rayDir * camDotRay) - 1.0;\n    if (det < 0.0) {\n        hit.near = vec3(0.0);\n        hit.far = vec3(0.0);\n        return hit;\n    } else {\n        vec2 roots = (-b + sqrt(det) * vec2(-1.0, 1.0)) / 2.0;\n        hit.near = cam + rayDir * roots.x;\n        hit.far = cam + rayDir * roots.y;\n        return hit;\n    }\n}\n\nvec3 sRgbToLinear(vec3 srgb) {\n    return pow(srgb, vec3(1.0/gamma));\n}\n\nvec3 linearToSrgb(vec3 linear) {\n    return pow(linear, vec3(gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    float w = 2.0;\n    float h = w / aspect;\n    \n    float theta = tau * speed * iTime;\n    vec3 target = vec3(0.0);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * vec2(w, h) - vec2(w/2.0, h/2.0);\n\n    vec3 cam = vec3(sin(theta), sin(theta * 3.0), cos(theta));\n    cam = normalize(cam) * camDist;\n\n    vec3 lookAt = normalize(target - cam);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(lookAt, up));\n    up = normalize(cross(right, lookAt));\n    \n    vec3 rayDir = normalize(lookAt * f + right * uv.x + up * uv.y);\n    \n    Hit hit = sphereHit(cam, rayDir);\n    \n    vec3 col;\n    if (hit.sDist < 0.0) {\n        float pulse = 0.01 * sin(tau * pulseSpeed * 2.0 * iTime);\n        col = sRgbToLinear(\n            texture(iChannel0, mix(hit.far, rayDir, -3.5)).xyz\n        );\n        col*= pow(dot(-rayDir, hit.near), 2.);\n        col+= sRgbToLinear(\n            texture(iChannel1, reflect(rayDir, hit.near)).xyz\n        ) * pow((1.0 - 0.9*dot(-rayDir, hit.near) + 0.1), 2.5);\n        col = mix(glow, col, max(pow(dot(-rayDir, hit.near), 1.05) - pulse, 0.0));\n    } else {\n        col = sRgbToLinear(texture(iChannel1, rayDir).xyz);\n        float pulse = 0.3 * sin(tau * pulseSpeed * 1.05 * iTime);\n        col = mix(glow, col, min(1.0 - pow(1.0 - hit.sDist, 5.0 + pulse), 1.0));\n    }\n    \n    col = linearToSrgb(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}