{"ver":"0.1","info":{"id":"wtS3Wc","date":"1561339573","viewed":96,"name":"fractal--complex--v6","username":"jorge2017a1","description":"fractal--complex--v6","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractalcomplexv6"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define SCALE 7.5 // plot scale\n\n//hecho por jorge flores p.....23/jun-2019\n\nstruct complex\n{\n    float re;\n    float im;\n}; \n\nconst float M_PI = 3.14159265359;\n\ncomplex complex_set(float re , float im)\n{\n\tcomplex cout;\n    cout.re = re;\n    cout.im = im;\n    return cout;\n}\n    \n\ncomplex complex_neg(complex p) \n{\n    complex cout;\n    cout.re = -p.re;\n    cout.im = -p.im;\n    return cout;\n}\n   \n\ncomplex complex_add(complex c1 , complex c2) \n{\n\t\n    complex cout;\n    cout.re = c1.re + c2.re;\n    cout.im = c1.im + c2.im;\n    return cout;\n}    \n\n\n\ncomplex complex_multiply(complex a, complex b) \n{\n    complex cout;\n\tcout.re= a.re * b.re - a.im * b.im;\n    cout.im =a.im * b.re + a.re * b.im;\n    return cout;\n}\n\n/** Square a complex number. */\ncomplex complex_square(complex a) \n{\n    return complex_multiply(a, a);\n}\n\n\ncomplex complex_sub(complex  c1 ,complex  c2) \n{\n    complex cout;\n\n    cout.re = c1.re - c2.re;\n    cout.im = c1.im - c2.im;\n    return  cout;\n}\n\n\n\n\n/*vec2 cmpxpow(in vec2 c, int p) {\n    vec2 orig = c;\n\tfor (int i = 0; i < p-1; ++i) {\n\t\tc = cmpxmul(c, orig);\n\t}\n    return c;\n}\n*/\n\n\nfloat complex_mag(complex c)\n{\n    \n    return sqrt(c.re * c.re + c.im * c.im);\n}\n\n\n\ncomplex complex_exp(complex z) \n{\n    complex tmp;\n    complex cout;\n    tmp.re= cos(z.im);\n    tmp.im= sin(z.im);\n    \n    cout.re=exp(z.re)*tmp.re;\n    cout.im=exp(z.re)*tmp.im;\n    \n    \n    return cout;\n}\n\n\n\nfloat complex_norm(complex c )\n{\n\tfloat result ;\n    \n    result = c.re * c.re + c.im * c.im;\n        \n    return  result;\n}\n    \n\ncomplex complex_pow(complex a, float b) \n{\n    float r = complex_mag(a);\n    float theta = atan(a.im, a.re);\n    complex tmp;\n    \n    tmp.re=b * log(r);\n    tmp.im=b *  theta;\n    \n    return complex_exp(tmp);\n    \n}\n\nvec3 getColor(float v)\n{\n    /*vec3 col = vec3(0.1) * sin(v);\n    col = mix(col, vec3(0.1, 0.2, 0.4), sin(1.-v));\n    col = mix(col, vec3(0.1, 0.2, 0.7), pow(sin(1.-v),2.));\n    return col;*/\n\t\n    float a = 1.;\n    float b = 0.2357022603955158;  // 1/3*sqrt(2)\n    float c = 0.12452650612453368; // 1/7*3^(1/8)\n    return vec3((1.-cos(a*v))*0.5, (1.-cos(b*v))*0.5, (1.-cos(c*v))*0.5);\n}\n\n\ncomplex complex_sin(complex c )\n{\ncomplex result;\n\n    result.re = sin(c.re) * cosh(c.im);\n    result.im = cos(c.re) * sinh(c.im);\n    return  result;\n\n}\n\n\nvec3 mandelbrot(vec2 frag )\n{\n    \n\n  float maxI; \n  float Bailout;\n  complex z;\n  complex c;\n  float x;\n  float y;\n  float iter; \n  float it;  \n    \n    x=frag.x;\n    y=frag.y;\n    \n    z.re = x; \n    z.im = y;\n    \n    c.re = 0.5*cos(iTime);\n    c.im = 0.0;\n    \n    Bailout = 10.0;\n    \n  maxI=255.0;\n    \n  float tmp;\n    //for(float i = 0.; i < 15.; i++) \n    \n    for( iter = 0.0; iter< maxI; iter++)\n    {\n        // z =complex_add(complex_pow(z, 2.0), c);\n        //z = Sin(z) + Exp(z) + c\n        z= z = complex_add(complex_add(complex_sin(z), complex_exp(z)), c);\n        \n           \n        tmp=abs(z.re);\n        if (tmp > Bailout )\n        {       break;        }\n        \n        tmp=abs(z.im);\n         if ( tmp > Bailout )\n        {    break;    }\n         \n                            \n         if (complex_norm(z) > 100.0 )\n         { break;  }\n    }\n                      \n    \n     if ( abs(z.re) < Bailout )\n     {\n        it = iter / 255.0;\n     }\n     else\n     {\n        it = iter + 1.0;    \n         \n     }\n    \n    \n    \n      if (abs(z.im) < Bailout )\n       {\n     \t\n        it = iter / 255.0;\n       }\n        else\n       {\n        it = iter + 1.0;    \n       }\n\n    \n    \n    \n    vec3 col;\n    //color3 = vec3(it*1.0 / maxI);\n\t//col = vec3(it*1.0 / maxI,it*1.0 / maxI,it*1.0 / maxI);\n    //col = vec3(it*1.0 ,it*1.0 ,it*1.0 );\n\tcol= getColor(it*1.0);\n\t\n         \n    return col;\n}\n    \n\n\n\n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col;                \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //z *= SCALE*0.5 + 5.5*cos(iTime);\n    \n    z *= SCALE;\n    \n    \t\n    col=mandelbrot(z);\n    \n        \n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}