{"ver":"0.1","info":{"id":"stl3DX","date":"1623027583","viewed":90,"name":"CircleSDF __","username":"Envy24","description":"CircleSDF\n\nsource: https://www.shadertoy.com/view/3ltSW2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Returns hash in range [-1.0; 1.0].\n*/\nfloat signedSample1DHashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 12345u;\n    const uint enthropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n    \n    return float(value * value * value) * 4.6566128730773926e-10 - 1.0f;\n}\n\nfloat circleSDF(\n    float x,\n    float y,\n    float cx,\n    float cy, \n    float r)\n{\n    // Sample coordinates relative to circle center.\n    float _x = x - cx;\n    float _y = y - cy;\n    \n    // Signed distance.\n    return sqrt(_x * _x + _y *_y) - r;\n}\n\nfloat smoothCircleSDF(\n    float x,\n    float y,\n    float cx,\n    float cy, \n    float r,\n    float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = x - cx;\n    float _y = y - cy;\n    \n    // Signed distance.\n    float d =  sqrt(_x * _x + _y *_y) - r;\n     \n    // Smoothstep interpolation.\n    return smoothstep(-smoothness, smoothness, d);\n}\n\nfloat left(in vec2 fragCoord, float radius)\n{     \n    float gray = circleSDF(\n            fragCoord.x, fragCoord.y,\n            iResolution.x * 0.16, iResolution.y * 0.5,\n            radius);\n            \n    return (1.0 + cos(gray * 0.9) * 0.4);\n}\n\nfloat middle(in vec2 fragCoord, float radius)\n{     \n    return smoothCircleSDF(\n            fragCoord.x, fragCoord.y,\n            iResolution.x * 0.495, iResolution.y * 0.5,\n            radius,\n            4.0);\n}\n\n\nfloat right(in vec2 fragCoord, float radius)\n{     \n    float gray = circleSDF(\n            fragCoord.x, fragCoord.y,\n            iResolution.x * 0.83, iResolution.y * 0.5,\n            radius);\n            \n    gray = (1.0 + cos(gray * 0.9) * 0.4);\n\n    gray = min(\n        gray, \n        smoothCircleSDF(\n            fragCoord.x, fragCoord.y,\n            iResolution.x * 0.83, iResolution.y * 0.5,\n            radius,\n            4.0));\n            \n    return gray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 c = iResolution.xy * 0.5;\n\n    float radius = 15.0 + (1.0 + sin(iTime * 0.1)) * 60.0;\n\n    float gray = 0.0;\n    \n    float xTreshold0 = 0.33 + signedSample1DHashUI32(uint(fragCoord.y * 7.1)) * 0.00159;\n    float xTreshold1 = 0.66 + signedSample1DHashUI32(uint(fragCoord.y * 7.1)) * 0.00159;\n    \n    if (uv.x < xTreshold0) { gray = left(fragCoord, radius); }\n    else if (uv.x >= xTreshold0 && uv.x < xTreshold1) { gray = middle(fragCoord, radius); }\n    else { gray = right(fragCoord, radius); }\n\n    float yTreshold = 0.5 + signedSample1DHashUI32(uint(fragCoord.x * 7.1)) * 0.00159;\n\n    // Output to screen\n    if (uv.y > yTreshold) { fragColor = vec4(vec3(1.0 - (gray - 0.5) * (gray - 0.5)),1.0); }\n    else { fragColor = vec4(vec3(gray),1.0); }\n}","name":"Image","description":"","type":"image"}]}