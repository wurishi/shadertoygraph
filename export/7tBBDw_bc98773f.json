{"ver":"0.1","info":{"id":"7tBBDw","date":"1652306220","viewed":287,"name":"Voronoi broke the scene","username":"iapafoto","description":"The goal of this Shader was to show that we can create a very simple voronoi cutting operator applicable to any scene with a simple function call (opCutVoronoi ).","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["text","effect","font","slice","cut","operator"],"hasliked":0,"parentid":"wsSGDD","parentname":"CrashTest"},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Sebastien Durand - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// -----------------------------------------------\n// The goal of this Shader was to show that we can create a very simple voronoi cutting operator\n// applicable to any scene with a simple function call (opCutVoronoi ).\n// -----------------------------------------------\n// Other cutting space : [CrashTest] https://www.shadertoy.com/view/wsSGDD\n// -----------------------------------------------\n\n\n#define WITH_EDGE\n\n#define SCALE .75\n\nfloat tOpen;\n\n// SPACE txt\n//int[] gtxt = int[] (83,80,65,67,69);\n// SCENE\nint[] gtxt = int[] (83,67,69,78,69);\n\nvec3 hash33(vec3 p) {   \n\tp = vec3(dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t dot(p,vec3(113.5,271.9,124.6)));\n    return fract(sin(p)*43758.5453123)*.6 - .3;\n}\n\n//---------------------------------------------------------------\n// Here is the distance to voronoi3D cell (not exact: over estimate distance on edges)\n//---------------------------------------------------------------\nfloat sdVoronoi(vec3 x, vec3 cellId) {\n    float md = 64.;    \n    vec3 mr = hash33(cellId);\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ) {\n        if (i==0&&j==0&&k==0) continue;  // skip main cell \n        vec3 g = vec3(i,j,k),            // relative cell Id\n             r = g + hash33(cellId + g); // pos of other point\n        md = min(md, dot(.5*(mr+r)-x, normalize(r-mr))); // distance\n    }\n    return -1.2*md;\n}\n\n// --------------------------------------\n// Space Operators\n// --------------------------------------\n\n// [iq] https://www.shadertoy.com/view/4lyfzw\nfloat opExtrussion(vec3 p, float sdf, float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\n// [iapafoto] https://www.shadertoy.com/view/7tBBDw\nfloat opCutVoronoi(inout vec3 p, float k) {\n//k *= .3+.7*smoothstep(-2.,2.,12.*k+.5*p.y+p.x);\n    k += 1.;\n    float d = 999.;\n    vec3 posTxt = p;\n    for( int z=-1; z<=1; z++)\n    for( int j=-1; j<=1; j++)\n    for( int i=-1; i<=1; i++) {\n         vec3 g = vec3(i,j,z)+floor(p/k);\n         if (length(k*g-p)<1.5) { // do it only on neighbourhood\n             float v = sdVoronoi(p-k*g, g);\n             if (d>v) {\n                 posTxt = p-k*g+g;\n             }\n             d = min(d,v);\n         }\n    }\n    p = posTxt;\n\n    return d;\n}\n\nfloat opSuperCut(inout vec3 p) {\n    if (tOpen > .005) {\n        p /= SCALE;\n        float d = SCALE*opCutVoronoi(p, tOpen);\n        p *= SCALE;\n        return d;\n    } \n    return -999.;\n}\n\n// --------------------------------------\n// Distance Functions\n// --------------------------------------\n\n// Adapted from [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel0, uv, 0.).w - 127./255.);\n}\n\nfloat sdMessage2D(vec2 p, int[5] txt, float scale) { \n    p.y += .1;\n    p /= scale;\n \tfloat d = 999., w = .45; // letter width  \n    p.x += w*float(txt.length()-1)*.5; // center text arround 0\n    for (int id = 0; id<5; id++){\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return scale*d;\n}\n\nfloat sdMessage3D(in vec3 p, int[5] txt, float scale, float h) { \n    return opExtrussion(p, sdMessage2D(p.xy, txt, scale), h);\n}\n\n// --------------------------------------\n// Distance to scene\n// --------------------------------------\nfloat map(vec3 p) {\n    float dcut = opSuperCut(p),\n          dScn = sdMessage3D(p, gtxt,4.,1.);\n    return max(dScn, dcut);\n}\n\n// --------------------------------------\n// Shading Tools\n// --------------------------------------\n// Find initial space position\nvec4 MCol(vec3 p) {\n    float dcut = opSuperCut(p),\n          dScn = sdMessage3D(p, gtxt,4.,1.);\n    return vec4(p, dScn >= dcut ? 1. : 2.);\n}\n\n// Shane - normal + edge\nvec3 normal(vec3 p, vec3 rd, inout float edge, float t) { \n    float eps = 4.5/mix(450., min(850., iResolution.y), .35),\n          d = map(p);\n#ifdef WITH_EDGE\n    vec3 e = vec3(eps, 0, 0),\n         da = vec3(-2.*d);\n    for(int i = min(iFrame,0); i<3; i++) {\n        for( int j=min(iFrame,0); j<2; j++ )\n            da[i] += map(p + e*float(1-2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n#endif\n    vec3 n = vec3(0);\n    for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n - max(.0, dot(n,rd))*rd);\n}\n\n// Box:  https://www.shadertoy.com/view/ld23DV\nbool iBox( vec3 ro, vec3 rd, vec3 sz, inout float tN, inout float tF) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8),\n         n = m*ro,\n         k = abs(m)*sz,\n         t1 = -n - k,\n         t2 = -n + k;\n\ttN = max( max( t1.x, t1.y ), t1.z );\n\ttF = min( min( t2.x, t2.y ), t2.z );\n    return !(tN > tF || tF <= 0.0);\n}\n\n//----------------------------------\n// Texture 3D (Shane)\n//----------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(n*n, .001);\n    n /= n.x + n.y + n.z;  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)) )/e.x; \n    g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n\n//----------------------------------\n// Shading\n//----------------------------------\nvec3 render(vec3 ro, vec3 rd, float res, vec3 pos, vec3 n, vec3 cobj, vec3 light, vec3 cback, float spec) {\n    float \n         amb = clamp(.5+.5*n.y, .0, 1.),\n         dif = clamp(dot( n, light ), 0., 1.),\n         pp = clamp(dot(reflect(-light,n), -rd),0.,1.),\n         fre = (.7+.3*dif)*pow( clamp(1.+dot(n,rd),0.,1.), 2.);\n    vec3 brdf = .5*(amb)+ 1.*dif*vec3(1.,.9,.7),\n         sp = 3.*pow(pp,spec)*vec3(1, .6, .2),\n\t     col = cobj*(brdf + sp) + fre*(.5*cobj+.5);\n    return mix(col, vec3(.02,.2,.2), smoothstep(6.,20.,res));\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float r ) {\n\tvec3 w = normalize(ta-ro),\n         p = vec3(sin(r), cos(r),.0),\n         u = normalize( cross(w,p) ),\n         v =          ( cross(u,w) );\n    return mat3( u, v, w );\n}\n\n\n// --------------------------------------\n// Main\n// --------------------------------------\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n\n    vec2 r = iResolution.xy, \n         m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy;\n \n    tOpen = .5*smoothstep(.6,0.,cos(.3*iTime));\n\n    float a = mix(.3,3.*cos(.4*3.*iTime),.5+.5*cos(.2*iTime))+3.14*m.x;\n    \n    // camera\t\n    vec3 ta = vec3(0),\n         ro = ta + 2.4*vec3(4.5*cos(a), 3.*cos(.4*iTime) + 4.*m.y, 4.5*sin(a));\n    mat3 ca = setCamera( ro, ta, .1*cos(.123*iTime) );\n  \n    // ray direction\n    vec3 rd = ca * normalize( vec3((2.*fragCoord-r.xy)/r.y, 2.5));\n\n    float h = .1, t, tN = 0., tF = 10.;\n    \n    // Background color\n\tvec3 c = .09*vec3(hash33(q.xyx).x + 1.);\n\n    if (iBox(ro, rd, vec3(4.8,1.4,1.2)*(1.+tOpen), tN, tF)) {\t\t\n        t = tN + .05*hash33(q.xyx).x;\n\t// Ray marching\n        for(int i=min(0,iFrame);i<99;i++) { \n            if (h<1e-3 || t>tF) break;\n            t += h = map(ro + rd*t);\n        }\n    \n        // light pos\n        vec3 lp =  ro + 3.*vec3(.25, 2, -.1);\n\n        // Calculate color on point\n        if (t<tF) {\n            vec3 pos = ro + t * rd;\n            float edge = 0.;\n            vec4 txt = MCol(pos); \t\n            vec3 n = normal(pos, rd, edge, t),     \n                 cobj = txt.w<1.5 ? vec3(.7) : 1.5*vec3(.8,.4,.0);\n            if (txt.w<1.5) {\n                n = doBumpMap(iChannel1, txt.xyz*2., n, .01);\n            } else {\n                n = doBumpMap(iChannel2, txt.xyz*2., n, .02);\n            }\n            // keep in visible side\n            n = normalize(n - max(.0,dot(n,rd))*rd);\n            // Shading\n            c = render(ro, rd, t, pos, n, cobj, normalize(lp-pos), c, txt.w<1.5 ? 99. : 16.);\n    #ifdef WITH_EDGE\n            c *= 1. - edge*.8;\n    #endif\n        } \n    }\n    \n    // post prod\n    c = pow(c, vec3(.75));\n    c = vec3(c* pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.7f));\n\tfragColor = vec4(c, t);\t\n}","name":"Image","description":"","type":"image"}]}