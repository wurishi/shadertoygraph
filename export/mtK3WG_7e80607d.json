{"ver":"0.1","info":{"id":"mtK3WG","date":"1709646237","viewed":134,"name":"Spring feelings","username":"kryden","description":"Small gift for March 8","likes":12,"published":1,"flags":64,"usePreview":0,"tags":["spring","flowers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dt3WX","filepath":"https://soundcloud.com/scs4rw55nyue/aleksey-rybnikov-letnee-nastroenie","previewfilepath":"https://soundcloud.com/scs4rw55nyue/aleksey-rybnikov-letnee-nastroenie","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEP_SIZE        0.7\n#define EPSILON          0.001\n#define MAXIMUM_STEPS    500\n#define FAR              200.0\n\n\nfloat getHeight(vec2 p) {\n  float h = 0.5 + 0.2 * sin(p.x) + 0.1 * cos(p.y);\n  h += texture(iChannel0, 0.1 * p).x;\n  return h;\n}\n\nvec2 terrain(vec3 p) {\n  float h = p.y - getHeight(p.xz);\n  return vec2(h, TERRAIN_ID);\n}\n\nvec2 petals(vec3 p) {\n  vec3 q = p;\n  q.zx = abs(q.zx); q.zx *= PI6;\n  q.zx = abs(q.zx); q.zx *= PI6;\n  q.zx = abs(q.zx); q.zx *= PI12;\n  q.zy *= rotate(PI / 12.0 - 0.2 * q.z);\n  float petal = sdPetal(q - vec3(0.0, 0.0, 0.7), vec3(0.7, 0.55, 0.01));\n  return vec2(petal, FLOWER_PETAL_ID);\n}\n\nvec2 flower(vec3 p, vec2 id) {\n  float g = random(id);\n  float h = 5.0 + 5.0 * g;\n  vec3 q = p;\n  q.xy *= rotate(0.015 * sin(iTime) * g * p.y);\n  float body  = sdCapsule(q, vec2(0.05, h));\n  float up    = sdSphere(q - vec3(0.0, h, 0.0), 0.25);\n  vec2 petal = petals(q - vec3(0.0, h, 0.0));\n  vec2 fbody  = vec2(body, FLOWER_BODY_ID); \n  vec2 fup    = vec2(up,   FLOWER_UP_ID);\n  vec2 ret = MIN(fup, MIN(petal, fbody));\n  return ret;\n}\n\nvec2 flowers(vec3 p) {\n  float s = 2.5;\n  vec2 id = round(p.xz / s);\n  vec2  o = sign(p.xz - s * id);\n  vec2 d = vec2(1e20, 0.0);\n  for (int j = 0; j < 2; j++) {\n    for (int i = 0; i < 2; i++) {\n      vec2 rid = id + vec2(i, j) * o;\n      vec2 r = p.xz - s * rid;\n      d = MIN(d, flower(vec3(r.x, p.y, r.y), rid));\n    }\n  }\n  return d;\n}\n\n#define NUM_OCTAVES 4.0\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm(in vec2 x, in float H) {    \n  float t = 0.0;\n  for (float i = 0.0; i < NUM_OCTAVES; i += 1.0) {\n    float f = pow(2.0, i);\n    float a = pow(f, -H);\n    t += a * texture(iChannel1, f * x).x;\n  }\n  return t;\n}\n\nfloat fbmClouds(in vec2 uv) { \n  vec2 pq = uv - 0.1 * vec2(iTime, 0.0);\n  pq *= vec2(0.02, 0.05);\n  float f = fbm(pq, 1.0);\n  return f;\n}\n\n#define SUN_POSITION vec2(0.5, 0.5)\n\nvec3 sky(vec2 uv) {\n  float circle = length(uv - SUN_POSITION);\n  float sun = smoothstep(0.1, 0.02, circle) + 0.05 / (0.01 + abs(circle));\n  vec3 sky = vec3(0.05, 0.15, 0.5 + uv.y); \n  float cloud = fbmClouds(uv);\n  vec3 color = sky + 5.0 * vec3(sun + 0.1, sun + 0.1, sun + 0.3);\n  color += cloud;\n  float foresth = 0.01 * sin(9.0 * uv.x) * texture(iChannel1, 0.5 * uv).x;\n  vec3 forestc = vec3(0.1, 0.3, 0.1) * texture(iChannel3, 5.0 * uv).xyz;\n  color = uv.y < (-0.03 - foresth) ? forestc : color;\n  return color;\n}\n\nvec2 scene(vec3 p) {\n  vec2 flowers = flowers(p);\n  vec2 terrain = terrain(p);\n  vec2 ret = MIN(flowers, terrain);\n  return ret;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(in vec3 p) {\n  const float h = 0.01; \n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(k.xyy * scene(p + k.xyy * h).x + \n                   k.yyx * scene(p + k.yyx * h).x + \n                   k.yxy * scene(p + k.yxy * h).x + \n                   k.xxx * scene(p + k.xxx * h).x);\n}\n\nHit rayMarch(in Ray ray, float near) {\n  Hit hit;\n  hit.id = -1.0;\n  float t = near;\n  for (int i = 0; i < MAXIMUM_STEPS; i++) {\n    vec3 p = ray.origin + ray.direction * t;\n    vec2 d = scene(p);\n    if (d.x < EPSILON) {\n      hit.id = d.y;\n      hit.position = p; hit.normal = getNormal(hit.position);\n      break;\n    }\n    t += STEP_SIZE * d.x;\n    if (t > FAR) { break; }\n  }\n  return hit;\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softShadow(in Ray ray, in float near, int steps) {\n  float ret = 1.0;\n  float t = near;\n  for (int i = 0; i < steps && t < FAR; i++) {\n\t  vec3 p = ray.origin + ray.direction * t;\n    float d = scene(p).x;\n    ret = min(ret, 10.0 * d / t);\n    if (ret < EPSILON) break;\n    t += d;\n  }\n  ret = clamp(ret, 0.0, 1.0);\n  return ret * ret * (3.0 - 2.0 * ret);\n}\n\n// https://www.shadertoy.com/view/4fsSzM\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float aoStep = 0.1;\n  float ao = 0.0;\n  for (float i = 1.0; i < 8.0; i += 1.0) {\n    float d = aoStep * i;\n    ao += max(0.0, (d - scene(p + n * d).x) / d);\n  }\n  return (1.0 - ao * 0.6);\n}\n\nvoid GetResultLight(Ray ray, Hit hit, Material material, inout vec3 color) {\n  Light light;\n  light.color = 4.0 * vec3(1.0, 1.0, 1.0);\n  light.direction = normalize(vec3(1.0, 2.0, -1.0));\n  vec3 result = GetLight(hit.normal, ray, light, material);\n  Ray light_shadow = Ray(hit.position, light.direction);\n  color += result * softShadow(light_shadow, 0.1, 32) * ambientOcclusion(hit.position, hit.normal);\n}\n\nconst float a = 1.2;\nconst float b = 3.0;\n\n// https://iquilezles.org/articles/fog/\nvec3 applyFog(in vec3 color, in float t, in Ray ray) {\n  float fogAmount = (a / b) * exp(-ray.origin.y  * b) * (1.0 - exp(-t * ray.direction.y * b)) / ray.direction.y;\n  vec3  fogColor  = vec3(0.5, 0.6, 0.7);\n  return mix(color, fogColor, fogAmount);\n}\n\nMaterial getMaterial(Hit hit) {\n  Material material;\n  float seed = random(hit.position.xz);\n  if (hit.id == FLOWER_BODY_ID) {\n    material.metallic = 0.4;\n    material.roughness = 0.6;\n    material.albedo = vec3(0.1, 0.2 + 0.2 * hit.position.y, 0.5);\n  } else if (hit.id == FLOWER_PETAL_ID) {\n    float r = float(hit.position.y > 5.0);\n    float b = float(hit.position.y > 6.0);\n    float g = float(hit.position.y > 7.0);\n    material = Material(vec3(r, g, b), 0.5, 0.4);\n  } else if (hit.id == FLOWER_UP_ID) {\n    material = Material(vec3(1.0, 1.0, 0.1), 0.3, 0.7);\n  } else if (hit.id == TERRAIN_ID) {\n    material.metallic = 0.1;\n    material.roughness = 0.8;\n    float h = getHeight(hit.position.xz);\n    if (h < 0.5 + seed) {\n      material.albedo = vec3(0.2, 0.5, 0.1);\n    } else {\n      material.albedo = vec3(0.3, 0.2, 0.1);\n    }\n  }\n  return material;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {      \n  vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.xy;\n  uv.y *= iResolution.y / iResolution.x;\n  vec3 color = vec3(0.0);\n\n  Ray ray;\n  ray.origin = vec3(0.0, 18.0 + 2.0 * sin(iTime), 5.0 - 5.0 * iTime);\n  ray.direction = normalize(vec3(uv, -1.0));\n\n  Hit hit = rayMarch(ray, 0.0);\n\n  Material material;\n\n  if (hit.id != -1.0) {\n    Material material = getMaterial(hit);\n    color = 0.05 * material.albedo;\n    GetResultLight(ray, hit, material, color);\n    float d = distance(hit.position, ray.origin);\n    color = applyFog(color, d, ray);\n  } else {\n    color = sky(uv);\n  }\n\n  color = color / (color + vec3(1.0));\n  color = pow(abs(clamp(color, 0.0, 1.0)), vec3(0.45));\n\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// DEFINES\n\n#define PI 3.141592653589793\n  \n#define SIN_PI6  0.5\n#define COS_PI6  0.8660254037844386\n#define SIN_PI12 0.25881904510252074\n#define COS_PI12 0.9659258262890683\n\n#define PI6     mat2(COS_PI6,  SIN_PI6,  -SIN_PI6,  COS_PI6)\n#define PI12    mat2(COS_PI12, SIN_PI12, -SIN_PI12, COS_PI12)\n\n#define FLOWER_BODY_ID  1.0\n#define FLOWER_PETAL_ID 2.0\n#define FLOWER_UP_ID    3.0\n#define TERRAIN_ID      4.0\n#define CLOUD_ID        5.0\n\nstruct Hit { float id; vec3 normal; vec3 position; };\nstruct Light { vec3 color; vec3 direction; };\nstruct Material { vec3 albedo; float metallic; float roughness; };\nstruct Ray { vec3 origin; vec3 direction; };\n\n#define MDZ(a, b) max(dot(a, b), 0.0)\n\nvec2 MIN(vec2 a, vec2 b) {\n  if (a.x < b.x) return a;\n  return b;\n}\n\n// SDF\n// https://iquilezles.org/articles/distfunctions/\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdCapsule(vec3 p, vec2 rh) {\n  p.y -= clamp(p.y, 0.0, rh.y);\n  return length(p) - rh.x;\n}\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdVesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r * r - d * d);\n  return ((p.y - b) * d > p.x * b) ? length(p - vec2(0.0, +b))\n                                   : length(p - vec2(-d, 0.0)) - r;\n}\n\nfloat sdPetal(in vec3 p, in vec3 rdh) {\n  float d = sdVesica(p.xz, rdh.x, rdh.y);\n  vec2 w = vec2(d, abs(p.y) - rdh.z);\n  return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nmat2 rotate(float a) {\n  return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat repeatAngle(vec2 p, float n) {\n  float sp = 2.0 * PI / n;\n  float an = atan(p.y, p.x);\n  float id = floor(an / sp);\n  return sp * id;\n}\n\n// RANDOM\n\nfloat random(in vec2 p) {\n  float q = dot(p, vec2(12.9898, 78.233));\n  return fract(sin(q) * 43758.5453123);\n}\n\n// LIGHT\n// https://learnopengl.com/PBR/\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float roughness) {\n  float a = pow(roughness, 4.0);\n  float NdotH = MDZ(N, H);\n  float denom = (NdotH * NdotH * (a - 1.0) + 1.0);\n  return a / (PI * denom * denom);\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n  float k = 0.125 * (roughness + 1.0) * (roughness + 1.0);\n  return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat geometrySmith(float NdotV, float NdotL, float roughness) {\n  float ggx2 = geometrySchlickGGX(NdotV, roughness);\n  float ggx1 = geometrySchlickGGX(NdotL, roughness);\n  return ggx1 * ggx2;\n}\n\nvec3 GetLight(vec3 normal, Ray ray, Light light, Material material) {\n  float NdotL = MDZ(normal, light.direction);\n  float NdotV = MDZ(normal, -ray.direction);\n  vec3 halfway_direction = normalize(light.direction - ray.direction);\n  vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);\n  float NDF = distributionGGX(normal, halfway_direction, material.roughness); \n  float G = geometrySmith(NdotV, NdotL, material.roughness);  \n  vec3  F = fresnelSchlick(MDZ(halfway_direction, -ray.direction), F0);\n  vec3 specular = NDF * G * F / (4.0 * NdotV * NdotL + 0.0001);\n  vec3 kD = (vec3(1.0) - F) * (1.0 - material.metallic);\n  vec3 Lo = (kD * material.albedo / PI + specular) * light.color * NdotL;\n  return Lo;\n}","name":"Common","description":"","type":"common"}]}