{"ver":"0.1","info":{"id":"Xc3fRH","date":"1732674602","viewed":58,"name":"SDF Outline v0 (Screen Space)","username":"8InfinityTaco8","description":"If you have any ideas on how i can improve this please let me know lol. I'm starting to get into toon shading and i want to make stylized contours and outlines / line art.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","sdf","cartoon","detection","edge","outline","contour","toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\n#define MAX_STEPS 128\n#define MAX_DIST 128.0\n#define SURF_DIST 0.001\n#define PI 3.141592\n#define OUTLINE_THICKNESS 3.5\n\n// Rotation\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Signed Distance Functions (SDFs) from IQ here: -> https://iquilezles.org/articles/distfunctions/\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat sdPyramid(vec3 p, float h) {\n    float m2 = h*h + 0.25;\n    p.xz = abs(p.xz);\n    p.xz = (p.z > p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n    \n    vec3 q = vec3(p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n    \n    float s = max(-q.x, 0.0);\n    float t = clamp((q.y - 0.5*p.z) / (m2 + 0.25), 0.0, 1.0);\n    \n    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;\n    float b = m2 * (q.x + 0.5*t) * (q.x + 0.5*t) + (q.y - m2*t) * (q.y - m2*t);\n    \n    float d2 = min(q.y, -q.x*m2 - q.y*0.5) > 0.0 ? 0.0 : min(a, b);\n    \n    return sqrt((d2 + q.z*q.z) / m2) * sign(max(q.z, -p.y));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 cp = vec2(length(p.xz) - t.x, p.y);\n    float a = atan(p.x, p.z);\n    cp *= Rot(a * 2.);\n    cp.y = abs(cp.y) - .2;\n    return length(cp) - t.y;\n}\n\n// Scene Distances\nfloat GetDist(vec3 p) {\n    float box = sdBox(p - vec3(-1, 0, 0), vec3(0.5));\n    float sphere = sdSphere(p - vec3(-1, 1.5, 0), 0.6);\n    float cylinder = sdCappedCylinder(p - vec3(1, 0, 0), 0.6, 0.4);\n    float pyramid = sdPyramid(p - vec3(1, 1.0, 0), 1.0);\n    float torus = sdTorus(p - vec3(1, 0, 0), vec2(0.5, 0.2));\n        return min(min(min(min(box, sphere), cylinder), pyramid), torus);\n}\n\n// Raymarch\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n// Outline calculation using SDF suing screen-space constant width outline calculation, \nfloat CalculateConstantOutline(vec3 ro, vec3 rd) {\n    // Get the distance to the scene\n    float sceneDist = RayMarch(ro, rd);\n    \n    // Constant screen-space outline sampling\n    float outline = 0.0;\n    \n    // Sample points using screen-space offset\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec3 offsets[4] = vec3[](\n        vec3(pixelSize.x * OUTLINE_THICKNESS, 0, 0),\n        vec3(-pixelSize.x * OUTLINE_THICKNESS, 0, 0),\n        vec3(0, pixelSize.y * OUTLINE_THICKNESS, 0),\n        vec3(0, -pixelSize.y * OUTLINE_THICKNESS, 0)\n    );\n    \n    for (int i = 0; i < 4; i++) {\n        // Create offset ray in screen space\n        vec3 offsetUV = vec3(rd.xy + offsets[i].xy, rd.z);\n        vec3 offsetRd = normalize(offsetUV);\n        \n        float offsetDist = RayMarch(ro, offsetRd);\n        \n        // Compare only absolute difference, clamped to a maximum value\n        outline += min(abs(sceneDist - offsetDist), 0.5);\n    }\n    \n    // Normalize and adjust outline intensity\n    return smoothstep(0.0, 1.0, outline); // / .5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera \n    vec3 ro = vec3(0, 1, -4);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n   \n   float angle = iTime * 0.5;\n    ro.xz *= Rot(angle);\n    rd.xz *= Rot(angle);\n    \n    vec3 col = vec3(1.0);\n    \n    // Calculate outline\n    float outline = CalculateConstantOutline(ro, rd);\n    \n    float d = RayMarch(ro, rd);\n    \n    // If object is hit, apply outline\n    if(d < MAX_DIST) {\n        col = mix(col, vec3(0.0), outline);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}