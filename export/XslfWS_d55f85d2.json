{"ver":"0.1","info":{"id":"XslfWS","date":"1497897916","viewed":128,"name":"morphing test","username":"rytone","description":"little test","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define FAR 16.0\n#define MAX_STEPS 64\n#define PI 3.14159265359\n#define DEG_TO_RAD PI / 180.0\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\nfloat prim_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat prim_box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p) {\n    float sphere = min(prim_sphere(p - vec3(-1.5, 0.0, 0.0), 1.0), prim_sphere(p - vec3(1.5, 0.0, 0.0), 1.0));\n    float cube = min(prim_box(p - vec3(-1.5, sin(iTime * 4.0) * 0.5, 0.0), vec3(1.0)), prim_box(p - vec3(1.5, 1.0 - sin(iTime * 4.0), 0.0) * 0.5, vec3(1.0)));\n    float shapemix = sin(iTime) * 0.5 + 0.5;\n    return mix(sphere, cube, shapemix);\n}\n\nfloat march_map(vec3 eye, vec3 dir) {\n    float depth = 0.0;\n    vec3 pos = eye;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        float d = map(pos);\n        depth += d;\n        pos += dir * d;\n        \n        if (d < EPSILON) {\n            break;\n        }\n        \n        if (d >= FAR) {\n            return FAR;\n        }\n    }\n    \n    return depth;\n}\n\nvec3 map_nrm(vec3 p) {\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(vec3 p, vec3 n){\n    \n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.;\n    \n    const float maxDist = 1.;\n    for(float i=1.; i<nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\nvec3 draw(vec3 eye, vec3 dir) {\n    vec3 sky = vec3(0.0);\n    float depth = march_map(eye, dir);\n    if (depth >= FAR) {\n        return sky;\n    } else {\n        vec3 hit_pos = eye + dir * depth;\n        vec3 nrm = map_nrm(hit_pos);\n     \tfloat d = depth / FAR;\n        \n        float ao = pow(calculateAO(hit_pos, nrm), 3.0 /* INTENSE */);\n        \n        vec3 diffuse = vec3(198.0 / 255.0, 75.0 / 255.0, 75.0 / 255.0);\n        float light = clamp(dot(nrm, normalize(vec3(0.0, 1.0, -1.0))), 0.0, 1.0);\n        float specular = pow(light, 100.0);\n        light = light * 0.9 + 0.1;\n        diffuse *= vec3(light);\n        diffuse = mix(diffuse, vec3(1.0), specular * 0.5);\n        diffuse *= ao;\n        \n        return mix(diffuse, sky, d*d);\n    }\n}\n\nvec3 dir_from_fov(float fov, vec2 pos, vec2 res) {\n\tvec2 xy = pos - res * 0.5;\n\n\tfloat cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\t\n\tfloat z = res.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 look_at(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 eye = vec3(sin(iTime / 2.0) * 3.0, 2.0, cos(iTime / 2.0) * 3.0);\n    vec3 look = vec3(0.0, 0.0, 0.0);\n    \n    vec3 dir = dir_from_fov(80.0, fragCoord, iResolution.xy);\n    mat3 view = look_at(eye, look, vec3(0, 1, 0));\n    dir = view * dir;\n    \n    fragColor = vec4(draw(eye, dir), 1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    vec3 eye = fragRayOri + vec3(0.0, iTime, 0.0);\n    fragColor = vec4(draw(eye, fragRayDir), 1.0);\n}","name":"Image","description":"","type":"image"}]}