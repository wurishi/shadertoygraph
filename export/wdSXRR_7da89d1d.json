{"ver":"0.1","info":{"id":"wdSXRR","date":"1552652981","viewed":270,"name":"Saiyan Nyancat","username":"Noge","description":"Saiyan Nyancat","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PERLIN\n\nconst int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\n// FOG\n\n\nvec3 CalculateOutlineColor(in vec2 fragCoord, in float outer){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n            \n\t\t\tfloat t = iTime + 100.0;\n            \n            float x = uv.x;\n\t\t\t//float x = ((uv.x - 0.5) * (0.4 + 0.4 * uv.y));\n            \n            //layer1\n\t\t\tfloat x1 = x+t*0.01;\n\t\t\t//float y1 = uv.y+3.0+0.05*cos(t*2.0)+t*0.01;\n\t\t\tfloat noise1 = 0.5+2.0*PerlinNoise2D(x1,uv.y);\n            \n            //layer2\n\t\t\tfloat x2 = x+t*0.2;\n\t\t\t//float y2 = uv.y+3.0+0.1*cos(t);\n\t\t\tfloat noise2 = 0.5+2.0*PerlinNoise2D(x2,uv.y);\n                        \n\t\t\tfloat noise = 1.2*noise1+0.6*noise2;\n            \n            //round noise\n\t\t\tfloat a = floor(noise*10.0)/10.0;\n\n\t\t\tfloat b = floor(noise*50.)/50.;\n\t\t\tfloat c = floor(noise2*50.0);\n            \n\t\t\tfloat final = a;\n            \n            //Add shine\n\t\t\tif((b==0.7||b==0.9||b==0.5||b==1.1||b==0.5)\n\t\t\t   &&noise2>0.50\n\t\t\t){\n\t\t\t\tfinal=0.2+0.2*noise2;\n\t\t\t}\n    \t\tfinal -= outer*0.1;\n\t\t\treturn vec3(2.0-2.0*final,1.0-1.0*final,0.0-2.0*final);\n}\n\n\n\n\n\n// MAIN\n\n\n\nvoid mainImage(out vec4 result, in vec2 fragCoord)\n{\n    float r = min(iResolution.x, iResolution.y);\n    \n\tvec2 uv = fragCoord / r;\n    uv.x /= 8.0;\n    uv.y = 1.0 - uv.y;\n    \n    vec3 c = texture(iChannel0, uv-vec2(iTime*0.03,0)).rgb;\n    \n    float a = texture(iChannel0, uv-vec2(iTime*0.03,0)).a;\n    bool i = bool(step(0.5, a) == 1.0);\n    \n    const int md = 20;\n    const int h_md = md / 2;\n    \n    float d = float(md);\n    \n    for (int x = -h_md; x != h_md; ++x)\n    {\n        for (int y = -h_md; y != h_md; ++y)\n        {\n            vec2 o = vec2(float(x), float(y));\n            vec2 s = (fragCoord + o) / r;\n    \t\ts.x /= 8.0;\n    \t\ts.y = 1.0 - s.y;\n            \n            float o_a = texture(iChannel0, s-vec2(iTime*0.03,0)).a;\n            bool o_i = bool(step(0.5, o_a) == 1.0);\n            \n            if (!i && o_i || i && !o_i)\n                d = min(d, length(o));\n        }\n    }\n    \n    d = clamp(d, 0.0, float(md)) / float(md);\n    \n    if (i)\n        d = -d;\n    \n    d = d * 0.5 + 0.5;\n    d = 1.0 - d;\n    \n    \n    float border_fade_outer = 0.1;\n    float border_fade_inner = 0.01;\n    float border_width = 0.25;\n    vec3 border_color = vec3(1.0, 0.3, 0.0);\n    \n    float outer = smoothstep(0.5 - (border_width + border_fade_outer), 0.5, d);\n    \n    vec3 temp = vec3(0.0, 0.0, 0.0);\n    vec4 border = mix(vec4(temp, 0.0), vec4(CalculateOutlineColor(fragCoord, outer), 1.0), outer);\n    \n    float inner = smoothstep(0.5, 0.5 + border_fade_inner, d);\n    \n    vec4 color = mix(border, vec4(c, 1.0), inner);\n    \n    result = color;\n}\n\n\n","name":"Image","description":"","type":"image"}]}