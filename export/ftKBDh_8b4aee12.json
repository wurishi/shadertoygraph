{"ver":"0.1","info":{"id":"ftKBDh","date":"1664815585","viewed":468,"name":"Dancing Bubbles","username":"coposuke","description":"I tried VolumetricFog, but Bubbles maybe doesn't cast shadow... (it was metal ball when start making)\nIt's Incorrect bubbles.\n\nReference:\n   demofox san's \"Blue Noise Fog\" : WsfBDf (MIT)\n   kaneta san's \"Float with Caustics\" : MttBRS\n","likes":23,"published":1,"flags":32,"usePreview":1,"tags":["water","volumetric","fog","caustics","pom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Dancing Bubbles\n//\n// Reference:\n//    demofox san's \"Blue Noise Fog\" : https://www.shadertoy.com/view/WsfBDf\n//    kaneta san's \"Float with Caustics\" : https://www.shadertoy.com/view/MttBRS\n//\n\n// _/_/_/_/_/_/ Common _/_/_/_/_/_/\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define ZERO int(min(0.0, iTime))\nconst float PI = 3.141592;\nconst float TAU = PI * 2.0;\n\nstruct rayResult\n{\n    float type;\n    vec3 position;\n    vec3 normal;\n    float dist;\n};\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, s, -s, c);\n}\n\nvec2 pmod(in vec2 pos, in float split, in float offset, out float id)\n{\n    float angle = atan(pos.x, pos.y) + PI / split + offset;\n    float n = TAU / split;\n    id = floor(angle / n);\n    angle = id * n;\n    return pos * rotate(-angle + offset);\n}\n\nvec3 waterNormal(in vec2 uv, float height)\n{\n    vec2 epsilon = vec2(0.0, 0.1);\n    vec3 normal = texture(iChannel2, fract(uv)).rgb;\n    normal.y += -abs(height);\n    return normalize(normal);\n}\n\nvec3 waterNormal(in vec3 rayPos, in vec3 rayDir)\n{\n    float waterDist = (4.0 - rayPos.y) / rayDir.y;\n    vec3 waterPosition = rayPos + rayDir * waterDist;\n    return waterNormal(waterPosition.xz * 0.2, 20.0);\n}\n\n// _/_/_/_/_/_/ Map _/_/_/_/_/_/\n\nvec2 opMin(vec2 a, vec2 b)\n{\n    return (a.y <= b.y) ? a : b;\n}\n\nvec2 map(in vec3 rayPos, in vec3 rayDir)\n{\n    vec2 m = vec2(0.0, 1e+3);\n\n    if (rayDir.y < 0.0)\n        m = opMin(m, vec2(2, rayPos.y / -rayDir.y));\n        \n    rayPos.y -= 1.0;\n        \n    float dist = 999.0;\n    float pmodID = 0.0;\n    vec3 pmodPos = rayPos;\n    pmodPos.xz = pmod(pmodPos.xz, 10.0, 0.0, pmodID);\n    dist = min(dist, length(pmodPos - vec3(0, 0, 0.8)) - 0.6);\n    dist = max(-dist, length(rayPos - vec3(0.0)) - 1.0);\n    m = opMin(m, vec2(1, dist));\n    \n    pmodPos = rayPos;\n    pmodPos.xz = pmod(pmodPos.xz, 12.0, iTime * 0.5, pmodID);\n    float bubbleDist = mix(1.2, 3.0, sin(iTime) * 0.5 + 0.5);\n    vec3 bubbleNoise = sin(vec3(rayPos + iTime + pmodID / 6.0) * TAU) * 0.02;\n    float bubble = length(pmodPos - vec3(0, sin(pmodID / 12.0 * TAU) * 0.2, bubbleDist) - bubbleNoise) - 0.3;\n    m = opMin(m, vec2(3, bubble));\n\n    return m;\n}\n\nrayResult raymarch(in vec3 cameraPos, in vec3 cameraDir, int loop)\n{\n    rayResult result = rayResult(0.0, vec3(0.0), vec3(0.0), 1e+2);\n    vec3 rayPos = cameraPos;\n\n    for(int i = ZERO; i < loop; ++i)\n    {\n        vec2 m = map(rayPos, cameraDir);\n        float d = m.y;\n        rayPos += cameraDir * d;\n        \n        if (d <= 1e-3)\n        {\n            vec2 epsilon = vec2(0.0, 1e-3);\n            result.type = m.x;\n            result.dist = distance(cameraPos, rayPos);\n            result.position = rayPos;\n            result.normal = normalize(vec3(\n                map(rayPos + epsilon.yxx, cameraDir).y - map(rayPos - epsilon.yxx, cameraDir).y,\n                map(rayPos + epsilon.xyx, cameraDir).y - map(rayPos - epsilon.xyx, cameraDir).y,\n                map(rayPos + epsilon.xxy, cameraDir).y - map(rayPos - epsilon.xxy, cameraDir).y\n            ));\n            return result;\n        }\n    }\n    \n    return result;\n}\n\nfloat shadow(in vec3 rayPos, in vec3 rayDir)\n{\n    float evalusion = 1.0;\n    float dist = 0.0;\n\n    for(int i = ZERO; i < 50; ++i)\n    {\n        float d = map(rayPos, rayDir).y;\n        rayPos += rayDir * d;\n        dist += d;\n        \n        evalusion = min(evalusion, 10.0 * d / dist);\n        \n        if (d <= 1e-3)\n            return 0.0;\n    }\n    \n    return saturate(evalusion);\n}\n\n// _/_/_/_/_/_/ Ground _/_/_/_/_/_/\n\nfloat getGroundHeight(vec3 rayPos)\n{\n    return smoothstep(0.5, 0.8, length(rayPos.xz)) *\n       ((texture(iChannel3, rayPos.xz * 0.1).r * 0.5 - 0.5) +\n        (texture(iChannel3, rayPos.zx * 0.3).r * 0.05 - 0.05) +\n        (texture(iChannel3, rayPos.xz * 0.2).r * 0.1 - 0.1));\n}\n\nrayResult raymarchGround(in vec3 rayPos, in vec3 rayDir, in rayResult result)\n{\n    const int STEP = 50;\n\n    vec3 rayStartPos = rayPos;\n    float rayDist = 1.0 / max(abs(rayDir.y), 1e-9);\n    vec3 rayStep = rayDir * abs(rayDist / float(STEP));\n    float height = -1.0;\n\n    for(int i = ZERO; i < STEP; ++i)\n    {\n        height = getGroundHeight(rayPos);\n        \n        if(rayPos.y <= height)\n            break;\n        \n        rayPos += rayStep;\n    }\n        \n    vec3 pos0 = rayPos;\n    vec3 pos1 = rayPos - rayStep;\n    float h0 = height - rayPos.y;\n    float h1 = getGroundHeight(pos1) - rayPos.y + rayStep.y;\n    \n    pos0 = mix(pos0, pos1, saturate(h0 / (h0 - h1)));\n    result.position = pos0;\n    result.dist += distance(pos0, rayStartPos);\n    \n    vec2 epsilon = vec2(0.0, 0.1);\n    result.normal.x = getGroundHeight(pos0 - epsilon.yxx) - getGroundHeight(pos0 + epsilon.yxx);\n    result.normal.z = getGroundHeight(pos0 - epsilon.xxy) - getGroundHeight(pos0 + epsilon.xxy);\n    result.normal.y = 0.05;\n    result.normal = normalize(result.normal);\n\n    return result;\n}\n\n// _/_/_/_/_/_/ Volumetric _/_/_/_/_/_/\n\nvec3 volume(in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir, in vec3 sceneColor, in float dist, in vec2 uv)\n{\n    float offset = texture(iChannel1, uv / 1024.0).r;\n\n    float fogLitPercent1 = 0.0;\n    float fogLitPercent2 = 0.0;\n    for (int i = ZERO; i < 10; i++)\n    {\n        vec3 testPos = cameraPos + cameraDir * dist * ((float(i) + offset) / float(10));\n        \n        // ref map\n        rayResult result = raymarch(testPos, lightDir, 20);\n        fogLitPercent1 = mix(fogLitPercent1, (result.type == 0.0) ? 1.0 : 0.0, 1.0 / float(i + 1));\n    }\n    \n    for (int i = ZERO; i < 50; i++)\n    {\n        vec3 testPos = cameraPos + cameraDir * dist * ((float(i) + offset) / float(50));\n        \n        // ceil noise\n        vec3 ceilPos = testPos + lightDir * (5.0 - testPos.y) / lightDir.y;\n        ceilPos += vec3(iTime, 0, 0) * 0.4;\n\n        float n = 0.0;\n        n += texture(iChannel1, ceilPos.xz * 2e-4 + iTime * 5e-4).r * 0.5;\n        n += texture(iChannel1, ceilPos.zx * 1e-3 - iTime * 5e-4).r * 0.7;\n        \n        vec3 waterNormal = waterNormal(ceilPos.xz * 0.2, 0.05);\n        n *= dot(waterNormal, -lightDir) * 1.5;\n        \n        fogLitPercent2 = mix(fogLitPercent2, (0.7 < n) ? 1.0 : 0.0, 1.0 / float(i + 1));\n    }\n    \n    fogLitPercent1 = fogLitPercent1 * 0.8;\n    fogLitPercent2 = fogLitPercent2 * 0.5 * exp(-dist * 1e-2);\n    \n    vec3 fogColor = mix(vec3(0.0), vec3(0.1, 0.6, 1.2) * 0.4, clamp(fogLitPercent1 + fogLitPercent2, 0.0, 1.0));\n    float absorb = exp(-dist * 0.2);\n    return mix(fogColor, sceneColor, absorb);\n}\n\n// _/_/_/_/_/_/ Main _/_/_/_/_/_/\n\nvec3 acesFilm(const vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat vignette(vec2 uv)\n{\n    const float ADJUST = 0.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    uv = mix(vec2(uv.x, uv.y / aspect), vec2(uv.x * aspect, uv.y), ADJUST);\n    \n    const float INTENSITY = 0.0;\n    const float SMOOTHNESS = 0.1;\n    float dist = distance(vec2(0.0), uv);\n    return smoothstep(1.5, 0.5, dist);\n}\n\nvec3 materialize(in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir, inout rayResult result)\n{\n    vec3 color = vec3(0.0);\n    \n    float dotNL = dot(result.normal, lightDir);\n    \n    if(result.type == 0.0)\n    {\n        float d = (4.0 - cameraPos.y) / max(abs(cameraDir.y), 1e-8);\n        result.dist = d;\n        result.position = cameraPos + cameraDir * d;\n        \n        result.normal = waterNormal(result.position, cameraDir);\n        vec3 refractDir = refract(cameraDir, result.normal, 1.333 / 1.0);\n\n        color = texture(iChannel0, refractDir).rgb;\n    }\n    else\n    {\n        switch(int(result.type))\n        {\n        case 1: // Statue\n            color = vec3(dotNL) / PI;\n            break;\n        case 2: // Ground\n            result = raymarchGround(result.position, cameraDir, result);\n            dotNL = dot(result.normal, lightDir);\n            color = vec3(dotNL) / PI;\n            break;\n        case 3: // Bubble\n            color = vec3(dotNL * 0.3 + 0.7) / PI;\n            break;\n        }\n\n        color += textureLod(iChannel0, result.normal, 10.0).rgb * 0.3;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uvNoise = texture(iChannel2, fract(uv * 0.5 + iTime * 0.2)).rb * 1e-2;\n    uvNoise += texture(iChannel2, fract(uv * 2.0 + iTime * 0.2)).rb * 5e-3;\n\n    vec3 cameraPos = vec3(0.0, 0.0, -5.0);\n    vec3 cameraDir = normalize(vec3(uv + uvNoise, 2.0));\n\n    if (1.0 < length(iMouse.xy))\n    {\n        vec2 cameraAngle = (iMouse.xy / iResolution.xy - vec2(0.5, 0.5)) * TAU;\n        cameraPos.yz *= rotate(cameraAngle.y);\n        cameraDir.yz *= rotate(cameraAngle.y);\n        cameraPos.xz *= rotate(cameraAngle.x);\n        cameraDir.xz *= rotate(cameraAngle.x);\n    }\n    cameraPos.y += 1.0;\n    \n    rayResult result = raymarch(cameraPos, cameraDir, 140);\n    \n    vec3 lightDir = normalize(vec3(0.2, 0.8, -0.1));\n    fragColor = vec4(0.0);\n    fragColor.rgb = materialize(cameraPos, cameraDir, lightDir, result);\n\n    // reflection or refraction\n    if (result.type == 3.0 || result.type == 0.0)\n    {\n        // reflection\n        vec3 reflectDir = cameraDir;\n        vec3 reflectColor = vec3(0.0);\n        float reflectDist = 0.0;\n        rayResult reflectResult = result;\n        \n        for(int i = ZERO; i < (result.type == 0.0 ? 1 : 2); ++i)\n        {\n            reflectDir = reflect(reflectDir, reflectResult.normal);;\n            reflectResult = raymarch(reflectResult.position + reflectResult.normal * 1e-2, reflectDir, 50);\n\n            reflectColor = materialize(reflectResult.position, reflectDir, lightDir, reflectResult);\n            reflectColor *= mix(reflectColor, vec3(1.0), saturate(reflectResult.dist * 0.05));\n            \n            reflectDist += reflectResult.dist;\n            \n            if (reflectResult.type != 3.0)\n                break;\n        }\n\n        // refraction\n        if (result.type == 3.0)\n        {\n            vec3 dir = cameraDir;\n        \n            for(int i = ZERO; i < 3; ++i)\n            {\n                vec3 refractDir = refract(dir, result.normal, 1.333 / 1.0);\n                float reflectRatio = smoothstep(-1.0, 0.0, dot(refractDir, result.normal));\n                refractDir = refract(refractDir, result.normal, 1.0 / 1.433); // TODO: no result.normal\n                dir = refractDir;\n\n                rayResult refractResult = raymarch(result.position + cameraDir * 0.9, refractDir, 50);\n                vec3 refractColor = materialize(cameraPos, cameraDir, lightDir, refractResult);\n\n                fragColor.rgb = mix(refractColor, reflectColor, reflectRatio);\n                result.dist += mix(refractResult.dist, reflectDist, reflectRatio);\n                result.position = mix(refractResult.position, reflectResult.position, reflectRatio);\n                result.normal = mix(refractResult.normal, reflectResult.normal, reflectRatio);\n                \n                if (refractResult.type != 3.0)\n                    break;\n            }\n        }\n        else if (result.type == 0.0)\n        {\n            vec3 refractDir = refract(cameraDir, result.normal, 1.333 / 1.0);\n            float reflectRatio = smoothstep(-0.8, -0.5, dot(refractDir, result.normal));\n            fragColor.rgb = mix(fragColor.rgb, reflectColor, reflectRatio);\n            result.dist += mix(0.0, min(reflectDist * 0.2, 1e+3), reflectRatio);\n            result.position = reflectResult.position;\n            result.normal = reflectResult.normal;\n        }\n    }\n\n    // shadow\n    float attenution = shadow(result.position + result.normal * 1e-2, lightDir);\n    if (result.type == 1.0 || result.type == 2.0 || result.type == 3.0)\n        fragColor.rgb *= attenution * 0.7 + 0.3;\n\n    // caustics\n    //if(result.type != 3.0)\n    {\n        vec2 causticsUV = result.position.xz * 0.2;\n        vec3 causticsNormal = waterNormal(causticsUV, 1.0);\n\n        vec3 causticsDir = refract(-lightDir, causticsNormal, 1.0 / 1.333);\n        vec2 causticsPos = result.position.xz + causticsDir.xz * (4.0 / causticsDir.y);\n\n        float beforeArea = length(dFdx(result.position.xz)) * length(dFdy(result.position.xz));\n        float afterArea = length(dFdx(causticsPos)) * length(dFdy(causticsPos));\n        float caustics = beforeArea / afterArea;\n\n        if (1e-8 < beforeArea)\n        {\n            float causticsRatio = smoothstep(-0.7, -0.6, dot(result.normal, vec3(0, 1, 0)));\n            causticsRatio *= clamp(attenution * 10.0, 0.0, 1.0);\n            fragColor.rgb = clamp(fragColor.rgb + caustics * causticsRatio, 0.0, 1.0);\n        }\n    }\n\n    // fog\n    fragColor.rgb = volume(cameraPos, cameraDir, lightDir, fragColor.rgb, result.dist, fragCoord);\n\n    // tonemap\n    fragColor.rgb = acesFilm(fragColor.rgb);\n\n    // vignette\n    fragColor.rgb *= vignette(fragCoord / iResolution.xy);\n\n    // degamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n\n    // debug\n    //fragColor.rgb = result.normal;\n    //fragColor.rgb = result.position;\n    //fragColor.rgb = vec3(waterWave(uv));\n    //fragColor.rgb = vec3(result.dist * 0.001);\n    //fragColor = texture(iChannel2, fract(uv));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Water Wave\n//\n\n#define ZERO int(min(0.0, iTime))\nconst float PI = 3.141592;\nconst float TAU = PI * 2.0;\n\nvec2 hash(in vec2 v)\n{\n    return fract(sin(vec2(dot(vec2(12.9898, 78.233), v), dot(vec2(78.233, 12.9898), v))) * 43758.5453);\n}\n\nfloat waterWave(vec2 uv)\n{\n    const int COUNT = 4;\n    \n    uv = fract(uv);\n\tfloat sum = 0.0;\n\n\tfor(int i = ZERO; i < COUNT; ++i)\n\t{\n\t\tvec2 position = hash(vec2(i)) * 0.5 + 0.5;\n        vec2 helzNoize = hash(vec2(i + COUNT));\n\t\tfloat helz = mix(5.0, 8.0, helzNoize.x) * TAU;\n\t\t\n\t\tfor(float x = -1.0; x <= 1.0; x++)\n\t\t{\n\t\t\tfor(float y = -1.0; y <= 1.0; y++)\n\t\t\t{\n\t\t\t\tfloat dist = distance(uv, position + vec2(x, y));\n\t\t\t\tsum += (sin(dist * helz + iTime * 3.0) * 0.5 + 0.5) * clamp(1.0 - dist, 0.0, 1.0) * helzNoize.y * 2.0;\n\t\t\t}\n\t\t}\n\t}\n    \n    sum += sin(uv.x * TAU + iTime) * 2.0;\n\n\treturn sum / float(COUNT * 2);\n}\n\nvec3 waterNormal(in vec2 uv, float height)\n{\n    vec2 epsilon = vec2(0.0, 0.1);\n    vec3 normal = vec3(0.0);\n    normal.x = waterWave(uv - epsilon.yx) - waterWave(uv + epsilon.yx);\n    normal.z = waterWave(uv - epsilon.xy) - waterWave(uv + epsilon.xy);\n    //normal.y = -abs(height);\n    //normal = normalize(normal);\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = waterNormal(fragCoord / iResolution.xy, 0.3);\n}","name":"Buffer A","description":"","type":"buffer"}]}