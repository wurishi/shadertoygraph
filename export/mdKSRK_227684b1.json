{"ver":"0.1","info":{"id":"mdKSRK","date":"1681521191","viewed":61,"name":"2D lightspeed","username":"HenroKriel","description":"Just like in star wars!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hyperspace","lightspeed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://thebookofshaders.com/10/\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//cite https://www.shadertoy.com/view/lsfGRr\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\n//end cite\n\n//projects v onto s\nvec2 proj(vec2 v, vec2 s)\n{\n    return dot(v, s)/dot(s,s)*s;\n}\n\nfloat lineSDF(vec2 uv, vec2 star, float len)\n{\n    vec2 projection = proj(uv, star);\n    \n    if(projection.x/star.x < 1.0)\n    {\n        return length(star-uv);\n    }\n    \n    vec2 end = star + normalize(star)*len;\n    if(projection.x/end.x > 1.0)\n    {\n        return length(end-uv);\n    }\n    \n    \n    return length(projection-uv);\n}\n\nstruct Space {\n    vec2 uv;\n    float WIDTH;\n    float HEIGHT;\n};\n\nstruct Time {\n    float fadeStart;\n    float fadeLen;\n    float timeMod;\n    float t;\n};\n\nvoid starPart(Space space, Time time, inout vec4 fragColor)\n{\n    const int NUM_STARS = 1500;\n    const float STAR_RADIUS = 0.001;\n    \n    vec2 uv = space.uv;\n    float WIDTH = space.WIDTH;\n    float HEIGHT = space.HEIGHT;\n    float fadeStart = time.fadeStart;\n    float fadeLen = time.fadeLen;\n    float timeMod = time.timeMod;\n    \n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i < NUM_STARS; i++)\n    {\n        vec2 star = vec2(random(vec2(i, 0.0))*WIDTH - WIDTH/2.0, random(vec2(i, 1.0))*HEIGHT - HEIGHT/2.0);\n        float starR = length(star);\n        \n        float trailLength;\n        if(time.t < 2.0*fadeLen)\n        {\n            //backwards stretch at start\n            trailLength = starR*exp(5.0*(3.9 - time.t)-20.0);\n        }\n        else\n        {\n            trailLength = starR*exp(5.0*time.t-28.0);\n        }\n        \n        float dist = lineSDF(uv, star, trailLength);\n        color += vec3(exp(-min(10000.0/trailLength, 1000000.0)*dist*dist));\n    }\n    \n    color = clamp(color, 0.0, 1.0);\n    \n    float r = length(uv);\n    if(time.t < fadeStart)\n    {\n        float fade = (1.0+0.1/r)*(1.0 - smoothstep(0.0, fadeLen, time.t));\n        fragColor = vec4(mix(color, vec3(1.0), fade), 1.0);\n    }\n    else\n    {\n        float fade = (1.0+0.1/r)*smoothstep(fadeStart, fadeStart + fadeLen, time.t);\n        fragColor = vec4(mix(color, vec3(1.0), fade), 1.0);\n    }\n}\n\n#define PI 3.1415926535897932384626433832795\nfloat stitch(float rSeed, float a, float angleOffset, float fbmFreq, float value)\n{\n    const float stitchPortion = 0.05;\n    const float stitchSize = stitchPortion*2.0*PI;\n    float stitchStart = (1.0-stitchPortion)*2.0*PI + angleOffset;\n    \n    if(a + angleOffset >= stitchStart)\n    {\n        float stitchProgress = a + angleOffset - stitchStart;\n        vec2 stitchPolar = vec2(rSeed, angleOffset - stitchSize + stitchProgress);\n        float stitchValue = fbm(fbmFreq*stitchPolar);\n        value = mix(value, stitchValue, stitchProgress/stitchSize);\n    }\n    \n    return value;\n}\n\nvoid swirlyPart(Space space, Time time, inout vec4 fragColor)\n{\n    vec2 uv = space.uv;\n    float WIDTH = space.WIDTH;\n    float HEIGHT = space.HEIGHT;\n    float fadeStart = time.fadeStart;\n    float fadeLen = time.fadeLen;\n    float timeMod = time.timeMod;\n    \n    float r = length(uv);\n    float a = atan(uv.y, uv.x) + PI;\n    \n    float angleOffset = time.t + r;\n    vec2 polar = vec2(r - time.t, a + angleOffset);\n    \n    float fbmFreq = 3.0;\n    float value = fbm(fbmFreq*polar);\n    \n    //stiches ends together to get rid of line\n    value = stitch(polar.x, a, angleOffset, fbmFreq, value);\n    \n    //adds white circle in middle\n    float circleR = 0.01;\n    value = mix(1.0, value, smoothstep(circleR, circleR + 0.1, r));\n    \n    vec3 darkColor = vec3(0.0, 0.1, 0.5);\n    vec3 brightColor = vec3(0.9, 0.95, 1.0);\n    \n    vec3 color = mix(darkColor, brightColor, value);\n    \n    //fade from white\n    if(time.t < timeMod - fadeLen)\n    {\n        float fade = clamp((time.t-fadeStart)/fadeLen, 0.0, 1.0);\n        fragColor = vec4(mix(vec3(1.0), color, fade), 1.0);\n    }\n    //fade to white at the end\n    else\n    {\n        float fade = clamp((time.t-(timeMod-fadeLen))/fadeLen, 0.0, 1.0);\n        fragColor = vec4(mix(color, vec3(1.0), fade), 1.0);\n    }\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    float alpha = 1.0/max(iResolution.x, iResolution.y);\n    float WIDTH = alpha*iResolution.x;\n    float HEIGHT = alpha*iResolution.y;\n    vec2 uv = alpha*fragCoord;\n    //center it\n    uv = uv - vec2(WIDTH, HEIGHT)/2.0;\n    \n    float starFadeStart = 5.65;\n    float starFadeLen = 0.5;\n    \n    float timeMod = starFadeStart + starFadeLen + 5.0;\n    float time = mod(iTime, timeMod);\n    \n    Space space = Space(uv, WIDTH, HEIGHT);\n    \n    if(time <= starFadeStart + starFadeLen)\n    {\n        Time time = Time(starFadeStart, starFadeLen, timeMod, time);\n        starPart(space, time, fragColor);\n    }\n    else\n    {\n        Time time = Time(starFadeStart + starFadeLen, 1.0, timeMod, time);\n        swirlyPart(space, time, fragColor);\n    }\n    \n    //for debugging\n    //if(length(uv) < 0.001)\n    //    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}