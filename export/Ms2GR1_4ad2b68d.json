{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define TRANSPARENCY\n#define SECOND_BOUNCE\n#define ANTIALIAS\n#define ANTIALIAS_4X\n\nstruct tSphere {\n\tvec3 center;\n\tfloat radius;\n\tvec3 color;\n\tfloat spec;\n};\n\n// return ray p,d distance to triangle v0,v1,v2\n// returns -1.0 if no intersection\n// writes UV value to the uv vector\nfloat rayIntersectsTriangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tif (a > -0.00001 && a < 0.00001)\n\t\treturn -1.0;\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tif (u < 0.0 || u > 1.0)\n\t\treturn -1.0;\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\n\tif (v < 0.0 || u + v > 1.0)\n\t\treturn -1.0;\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\tuv = vec2(u, v);\n\t\n\tif (t > 0.00001) // ray intersection\n\t\treturn t;\n\n\telse // this means that there is a line intersection\n\t\t // but not a ray intersection\n\t\t return -1.0;\n\n}\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// rotate by time (ugh, this is kinda slow)\nvec3 rotateTime(float k, vec3 cen)\n{\n\tfloat time = iTime + 450.0;\n\tcen.xy = rotate(cen.xy, time*0.3);\n\tcen.xz = rotate(cen.xz, 0.8*sin(k+time*0.2));\n\treturn cen;\n}\n\n/*\n\n\tif BV intersect\n\t\tif intersect edge BV (1.1x sphere, compare dot(normal) of hit)\n\t\t\tshoot 4xAA rays into edge BV\n\t\telse\n\t\t\tshoot 1 ray into BV\n\telse\n\t\tshoot 1 BG ray\n\n*/\n\nvec3 getCenter(float time, float k, float i) {\n\treturn rotateTime((i+1.0)*0.2, \n\t\tvec3(12.0*cos(time*0.12+i+0.12*k), \n\t\t\t-6.0+k*2.0+i*5.0,\n\t\t\t2.0*sin(time*0.33+k*0.6)+3.0*sin(i+time))\n\t) + vec3(0.0, 0.0, 3.0);\n}\n\nfloat intersect(inout vec3 ray, vec3 dir, inout vec3 nml, inout tSphere sphere, float pick)\n{\n\tfloat dist = 100.0;\n\n\tsphere.radius = -2.0;\n\tsphere.center = vec3(0.0);\n\tnml = normalize(sphere.center - ray-dist*dir);\n\n\tfloat time = iTime + 450.0;\n\t\n\tfloat st = sin(time);\n\tfloat ct = cos(time);\n\tfor (float i=0.0; i<3.0; i++) {\n\t\tfloat r = 1.0;\n\t\tfloat r2 = r*r;\n\t\tfloat k = i*3.0 + 1.0;\n\t\tvec3 cen = getCenter(time, k, i);\n\t\tvec3 px = normalize(rotateTime(k+st+ct, vec3(1.0, 0.0, 0.0)));\n\n\t\tvec3 rc = ray-(cen+px*3.6);\n\t\tfloat b = dot(dir, rc);\n\t\tfloat c = dot(rc, rc) - r2*64.0;\n\t\tfloat d = b*b - c;\n\t\t\n\t\tif (d > 0.0) {\n\t\t\tsphere.radius = max(sphere.radius, -1.0-i*0.2);\n\t\t\tfor (float j=0.0; j<3.0; j++) {\n\t\t\t\tk = i*3.0 + j;\n\t\t\t\t\n\t\t\t\tvec3 cen = getCenter(time, k, i);\n\t\t\t\tvec3 px = normalize(rotateTime(k+st+ct, vec3(1.0, 0.0, 0.0)));\n\t\t\t\tvec3 py = normalize(rotateTime(k+st+ct, vec3(0.0, 1.0, 0.0)));\n\t\n\t\t\t\tvec3 rc = ray-(cen + px*4.25*r - py*r);\n\t\t\t\tfloat b = dot(dir, rc);\n\t\t\t\tfloat c = dot(rc, rc) - r2*12.0;\n\t\t\t\tfloat dSail = b*b - c;\n\n\t\t\t\trc = ray-cen;\n\t\t\t\tb = dot(dir, rc);\n\t\t\t\tc = dot(rc, rc) - r2;\n#ifdef ANTIALIAS_4X\n\t\t\t\tfloat d = b*b - c + r2*1.5;\n#else\n\t\t\t\tfloat d = b*b - c + r2;\n#endif\n\t\t\t\t// BV intersect, let's switch on 4x sampling and check for sail intersect\n\t\t\t\tif (dSail > 0.0) {\n\t\t\t\t\tsphere.radius = max(sphere.radius, 0.0);\n\t\t\t\t\tvec3 pz = normalize(rotateTime(k+st+ct, vec3(0.0, 0.0, 1.0)));\n\t\t\t\t\t\n\t\t\t\t\tvec3 p1 = cen - py*2.25*r + px*2.0*r;\n\t\t\t\t\tvec3 p2 = cen + py*1.25*r + px*2.0*r;\n\t\t\t\t\tvec3 p3 = cen + py*0.25*r + px*7.5*r;\n\t\t\t\t\tvec3 p4 = cen - py*0.25*r + px*7.5*r;\n\t\t\t\t\tvec2 uv;\n\t\t\t\t\tfloat t = rayIntersectsTriangle(ray, dir, p2, p3, p1, uv);\n\t\t\t\t\tif (t < 0.0) {\n\t\t\t\t\t\tt = rayIntersectsTriangle(ray, dir, p4, p1, p3, uv);\n\t\t\t\t\t\tuv = vec2(1.0) - uv;\n\t\t\t\t\t}\n\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\tdist = t;\n\t\t\t\t\t\tsphere.radius = 100.0;\n\t\t\t\t\t\tnml = normalize(pz);\n\t\t\t\t\t\tif(dot(nml, dir) < 0.0) {\n\t\t\t\t\t\t\tnml = -nml;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsphere.center = p1;\n\t\t\t\t\t\tsphere.color = vec3(0.5, 0.1, 0.05); //texture(iChannel0, uv).rgb;\n\t\t\t\t\t\tsphere.spec = 8.0;\n\t\t\t\t\t\tif (k == pick) {\n\t\t\t\t\t\t\tsphere.spec *= -1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// BV intersect, let's switch on 4x sampling and check for sphere intersect\n\t\t\t\tif (d > 0.0) {\n\t\t\t\t\tsphere.radius = max(sphere.radius, 0.0);\n#ifdef ANTIALIAS_4X\n\t\t\t\t\td = b*b - c + r2;\n\t\t\t\t\tif (d > 0.0) {\n#endif\n\t\t\t\t\t\tfloat t = -b - sqrt(d);\n\t\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\t\tdist = t;\n\t\t\t\t\t\t\tsphere.radius = r;\n\t\t\t\t\t\t\tsphere.center = cen;\n\t\t\t\t\t\t\tnml = normalize(sphere.center - ray-dist*dir);\n\t\t\t\t\t\t\tfloat odd = 1.0-mod(j, 2.0);\n\t\t\t\t\t\t\tsphere.color = \n\t\t\t\t\t\t\t\tmix(vec3(0.0), vec3(0.95, 0.8, 0.7), odd);\n\t\t\t\t\t\t\tsphere.spec = mix(64.0, 8.0, odd);\n\t\t\t\t\t\t\tif (k == pick) {\n\t\t\t\t\t\t\t\tsphere.spec *= -1.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#ifdef ANTIALIAS_4X\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\tray += dist*dir;\n\treturn dist;\n}\n\nfloat pick(vec3 ray, vec3 dir)\n{\n\tfloat dist = 100.0;\n\n\tfloat pick = -1.0;\n\tfloat time = iTime + 450.0;\n\t\n\tfloat st = sin(time);\n\tfloat ct = cos(time);\n\tfor (float i=0.0; i<3.0; i++) {\n\t\tfloat r = 1.0;\n\t\tfloat r2 = r*r;\n\t\tfloat k = i*3.0 + 1.0;\n\t\tvec3 cen = getCenter(time, k, i);\n\n\t\tvec3 rc = ray-cen;\n\t\tfloat b = dot(dir, rc);\n\t\tfloat c = dot(rc, rc) - r2*48.0;\n\t\tfloat d = b*b - c;\n\t\t\n\t\tif (d > 0.0) {\n\t\t\tfor (float j=0.0; j<3.0; j++) {\n\t\t\t\tk = i*3.0 + j;\n\t\t\t\t\n\t\t\t\tvec3 cen = getCenter(time, k, i);\n\t\t\n\t\t\t\tvec3 rc = ray-cen;\n\t\t\t\tfloat b = dot(dir, rc);\n\t\t\t\tfloat c = dot(rc, rc) - r2;\n\t\t\t\tfloat d = b*b - c + r2;\n\t\t\n\t\t\t\tif (d > 0.0) {\n\t\t\t\t\tfloat t = -b - sqrt(d);\n\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\tpick = k;\n\t\t\t\t\t\tdist = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pick;\n}\n\n\n\n\n\n\nvec3 shadeBg(vec3 dir, vec3 nml)\n{\nvec3 lightPos = vec3(\n\tcos(iTime*0.1)*-8.5, \n\t5.0, \n\tsin(iTime*0.1)*4.0-5.4\n);\nvec3 bgLight = normalize(lightPos);\n\tvec3 bgCol = vec3(0.35, 0.45, 0.55);\n\tfloat bgDiff = dot(nml, -bgLight);\n\tbgCol *= bgDiff;\n\t//bgCol += max(0.0, -bgDiff) * vec3(0.6, 0.75, 1.0);\n\treturn bgCol;\n}\n\nvec3 shade(vec3 ray, vec3 dir, vec3 nml, float dist, tSphere sphere)\n{\nvec3 lightPos = vec3(\n\tcos(iTime*0.1)*-8.5, \n\t5.0, \n\tsin(iTime*0.1)*4.0-5.4\n);\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\t\n\tif (sphere.radius > 0.0) {\n\t\n\t\t//vec3 shadow = ray-nml*0.0001, snml = vec3(0.0);\n\t\ttSphere s;\n\t\ts.radius = 0.0;\n\t\t//float sdist = intersect(shadow, normalize(lightPos - shadow), snml, s, -1.0);\n\t\t\n\t\tvec3 light = normalize(lightPos - ray);\n\t\tvec3 specCol = sphere.color + vec3(0.3-min(0.29, length(sphere.color)));\n\t\t// lighting\n\t\tcol = sphere.color;\n\t\tfloat diff = max(0.0, dot(nml, -light));\n\t\tvec3 ref = reflect(dir, nml);\n\t\tfloat spec = max(dot(ref, light), 0.0);\n\t\tspec = pow(spec, abs(sphere.spec));\n\t\t\n\t\tcol *= diff;\n\t\t\n\t\tcol = mix(col*0.5, col+spec*specCol*2.0, float(s.radius <= 0.0));\n\t\t\n\t\tfloat a = 1.0 - abs(dot(dir, nml));\n\t\tif (sphere.spec < 0.0) {\n\t\t\tcol += a * vec3(0.7, 0.6, 0.4);\n\t\t}\n\t} else {\n\t\tcol = shadeBg(dir, -nml);\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mUv = iMouse.zw / iResolution.xy;\n\tmUv = 2.0 * mUv - 1.0;\n\tmUv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 eye = vec3(0.0, 1.0, -16.0);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = 2.0 * uv - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\t\n\tvec3 mouseDir = normalize(vec3(mUv, 1.0));\n\n\tvec3 ray = eye;\n\tvec3 nml = vec3(0.0);\n\t\t\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\t\n\ttSphere sphere;\n\t\n\tfloat picked = -1.0;\n\tif (iMouse.z > 1.0) { \n\t\tpicked = pick(ray, mouseDir);\n\t}\n\tfloat k = 0.0;\n#ifdef ANTIALIAS\n\tfor (float x = 0.0; x < 2.0; x++) {\n\t\tfor (float y = 0.0; y < 2.0; y++) {\n#else\n\tfloat x = 0.0, y = 0.0;\n#endif\n\n#ifdef ANTIALIAS\n#ifndef ANTIALIAS_4X\n\t\t\tif (x + y == 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n#endif\n\t\t\tk++;\n\n\t\t\tvec2 d = (vec2(x, y) * 0.5) - vec2(0.5);\n\n\t\t\tray = eye;\n\n\t\t\tuv = (fragCoord.xy+d) / iResolution.xy;\n\t\t\tuv = 2.0 * uv - 1.0;\n\t\t\tuv.x *= iResolution.x / iResolution.y;\n\t\t\tdir = normalize(vec3(uv, 1.0));\n\t\t\n\t\t\tfloat dist = intersect(ray, dir, nml, sphere, picked);\n\t\t\n\t\t\tfloat fog = clamp(dist / 70.0, 0.0, 1.0);\n\t\t\tfog *= fog;\n\t\t\t\n\t\t\tvec3 ref = dir;\n\t\t\tvec3 ncol = vec3(0.1);\n\t\t\tif (sphere.radius > 0.0) {\n\t\t\t\tncol = shade(ray, ref, nml, dist, sphere);\n\t\t\t} else {\n\t\t\t\tncol = shadeBg(ref, -nml);\n\t\t\t}\n\n\t\t\tif(k == 1.0 && sphere.radius > 0.0)\n\t\t\t{\n\t\t\t\tvec3 diff = normalize(sphere.color+vec3(0.01));\n\t\t\t\tref = reflect(ref, nml);\n\t\t\t\t// transparency\n#ifdef TRANSPARENCY\n\t\t\t\tif (sphere.radius < 100.0 && sphere.color.r < 0.2) {\n\t\t\t\t\tvec3 ray2 = ray;\n\t\t\t\t\tvec3 ref2 = refract(dir, nml*0.5, 0.05);\n\t\t\t\t\tray2 += ref2*sphere.radius*1.01;\n\t\t\t\t\tdist = intersect(ray2, dir, nml, sphere, picked);\n\t\t\t\t\tvec3 tcol = shade(ray2, dir, nml, dist, sphere);\n\t\t\t\t\tncol = mix(tcol, ncol, 0.5);\n\t\t\t\t\tdiff *= vec3(0.5);\n\t\t\t\t}\n#endif\n\t\t\t\t// reflection\n\t\t\t\tdist = intersect(ray, ref, nml, sphere, picked);\n\t\t\t\tncol += 0.9 * diff * shade(ray, ref, nml, dist, sphere);\n\t\t\t\t// second reflection\n#ifdef SECOND_BOUNCE\n\t\t\t\tif (sphere.radius > 0.0) {\n\t\t\t\t\tdiff = normalize(diff+sphere.color+vec3(0.01));\n\t\t\t\t\tref = reflect(ref, nml);\n\t\t\t\t\tdist = intersect(ray, ref, nml, sphere, picked);\n\t\t\t\t\tncol += 0.9 * diff * shade(ray, ref, nml, dist, sphere);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t//ncol = (1.0-fog)*ncol + fog*vec3(0.9, 0.6, 0.4);\n\t\t\t\n\t\t\tcol += ncol;\n\t\t\t\n\t\t\tif (sphere.radius < 0.0) {\n\t\t\t\tcol += vec3(0.05)*sphere.radius;\n#ifdef ANTIALIAS\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n#ifdef ANTIALIAS\n\t\t}\n\t}\n#endif\n\t// gamma correction\n\tcol = 1.0 - exp(-col/k * 3.5);\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Ms2GR1","date":"1384043412","viewed":141,"name":"sail sky xxfjf","username":"kig","description":"4x AA with a hacky bounding spheres. Pretty fast at high res as well.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","noobism"],"hasliked":0,"parentid":"","parentname":""}}