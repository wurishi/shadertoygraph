{"ver":"0.1","info":{"id":"ssffRn","date":"1644398336","viewed":90,"name":"BRDF as radial diagram","username":"fxslava","description":"Test BRDF (NDF - GGX, Fresnel approx - Shlink, Smith Joint Masking-Shadowing Function):\nmouse.x - Light source azimute\nmouse.y - roughness [0, 1] (1.0 - top border, 0.0 - bottom border)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["brdf","ggx","shlink"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float BORDER = 10.0f;\nconst float EPSILON = 1E-3;\nconst float M_PI = 3.14159265358979323846264338327950288;\nconst float M_PI_2 = 1.57079632679489661923132169163975144;\nconst float intensityScale = 0.5f;\n\nfloat intensityNorm;\n\nfloat DTerm(float HDotN, float alpha2)\n{\n    float HDotN2 = HDotN * HDotN;\n    float x = (1.0 - (1.0 - alpha2) * HDotN2);\n    float D = alpha2 / (M_PI * x * x);\n    return D;\n}\n\n\nfloat GTerm(float LDotN, float VDotN, float alpha2)\n{\n    float tanThetaLN2 = 1.0 / (LDotN * LDotN) - 1.0;\n    float tanThetaVN2 = 1.0 / (VDotN * VDotN) - 1.0;\n    \n    float lambdaL = 0.5 * sqrt(1.0 + alpha2 * tanThetaLN2) - 0.5;\n    float lambdaV = 0.5 * sqrt(1.0 + alpha2 * tanThetaVN2) - 0.5;\n       \n    return 1.0 / (1.0 + lambdaL + lambdaV);\n}\n\n\nfloat Pow5(float x)\n{\n    float t2 = x * x;\n    float t4 = t2 * t2;\n    return t4 * x;\n}\n\n\nfloat FTerm(float LDotH, float f0)\n{\n    return f0 + (1.0 - f0) * Pow5(1.0 - LDotH);\n}\n\n\nfloat curveFunc(float x)\n{\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    float phi = x;\n    float tht = mouseUV.x * M_PI;\n    float roughness = mouseUV.y;\n    \n    vec2 N = vec2(0.0f, 1.0f);\n    vec2 V = vec2(cos(phi), sin(phi));\n    vec2 L = vec2(cos(tht), sin(tht));\n    vec2 H = normalize(L + V);\n    \n    float VDotN = dot(V, N);\n    float LDotN = dot(L, N);\n    float HDotN = dot(H, N);\n    float LDotH = dot(L, H);\n    \n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n    \n    float D = DTerm(HDotN, alpha2);\n    float G = GTerm(LDotN, VDotN, alpha2);\n    float F = FTerm(LDotH, 0.95);\n    \n    return (intensityNorm * D * G * F) / (4.0 * abs(VDotN) * abs(LDotN));\n}\n\n\nfloat GetPhi(vec2 uv)\n{\n    vec2 n = normalize(uv);\n    float phi = acos(n.x);\n    return (uv.y > 0.0f) ? phi : -phi;\n}\n\n\nfloat borderFunc(float delta)\n{\n    if (delta < 0.0f)\n        return 1.0f;\n    if (delta > BORDER)\n        return 0.0f;\n    return (BORDER - delta) / BORDER;\n}\n\n\nfloat RadialCurveHitTest(vec2 uv, vec2 centre)\n{\n    vec2 dist = uv - centre;\n    float phi = GetPhi(dist);\n    float val = curveFunc(phi);\n    if (dist.y > 0.0f)\n        return borderFunc(length(dist) - val);\n    else\n        return 0.0f;\n}\n\n\nvec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    intensityNorm = min(iResolution.x, iResolution.y) * intensityScale;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Colors\n    vec3 black = vec3(0.0, 0.0, 0.0);    \n    vec3 white = vec3(1.0, 1.0, 1.0);\n    \n    float hit = RadialCurveHitTest(fragCoord, vec2(iResolution) * 0.5f);\n    vec3 col = lerp(black, white, hit);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}