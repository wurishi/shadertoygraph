{"ver":"0.1","info":{"id":"tdlXDl","date":"1552585092","viewed":225,"name":"Ray Marching Distance Field","username":"drichardson","description":"From Ray Marching for Dummies. I changed the code to have spelled out variables names and comments for reference. Also, this only implements ray marching part and visualized the distance field in grayscale.\n\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray Marching implementation using Sphere Tracing.\n// Produces a distance field visualization of the scene.\n//\n// Taken from Ray Marching for Dummies\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n//\n// I changed variable names and added comments to make\n// the purpose of variables and functions more obvious.\n\n// scene description\nconst vec3 CAMERA_POSITION = vec3(0,1,0);\nconst vec3 SPHERE_POSITION = vec3(0, 1, 6);\nconst float SPHERE_RADIUS = 1.;\nconst float PLANE_POSITION_Y = 0.;\n\n// GetDistanceNearestSurface is hard coded for our scene, which is comprised\n// of a plane and a sphere.\n// The plane is axis aligned with the camera and below the camera.\nfloat GetDistanceNearestSurface(vec3 point)\n{\n    float distanceToSphere = length(point-SPHERE_POSITION)-SPHERE_RADIUS;\n    float distanceToPlane = point.y - PLANE_POSITION_Y;\n    float distanceToNearestSurface = min(distanceToSphere, distanceToPlane);\n    return distanceToNearestSurface;\n}\n\nconst int MAX_STEPS = 50;\nconst float MAX_DIST = 100.;\nconst float SURFACE_DIST = 0.1;\n\n// Ray Marching using a Sphere Trace algorithm.\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceFromOrigin = 0.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayOrigin + distanceFromOrigin * rayDirection;\n        float distanceToScene = GetDistanceNearestSurface(p);\n        distanceFromOrigin += distanceToScene;\n        bool foundSurface = distanceToScene < SURFACE_DIST;\n        bool exceededMax = distanceFromOrigin > MAX_DIST;\n        if (foundSurface || exceededMax)\n            break;\n    }\n    return distanceFromOrigin;\n}\n\nfloat VisualizeDistance(float d)\n{   \n    // Uncomment one of the visualization curves below.\n    // https://www.desmos.com/calculator/vs4w8ly9n2\n    //\n    // Linear provides a constant depth resolution but draws\n    // the plane with noticibly curved lines at the horizon.\n    \n    // Logarithmic and Reciprocal provide more depth resolution near\n    // the camera.\n    \n    // The logarithmic and linear functions will clip to white at some\n    // point. The reciprocal will not, at least not mathematically.\n    // Perhaps some floating point value will end up clipping to a\n    // value that produces pure white, but it would be very far\n    // from the camera.\n    \n    // Linear\n    // return d * 0.12;\n    \n    // Logarithmic\n    // return log(d + 1.) / log(20.);\n    \n    // Reciprocal\n    return 1. + (-1. / (0.4 * d + 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv is the fragCoord with (0,0) in the center of the screen.\n    // The division by minres uses the same scaling on both\n    // axis to avoid distortion. The min is not strictly necessary in\n    // ShaderToy, since the aspect ratio is such that the min\n    // is always iResolution.y.\n    float minres = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - .5*iResolution.xy) / minres;\n    \n    // Camera Model\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Compute Distance\n    float distanceToSurface = RayMarch(CAMERA_POSITION, rayDirection);\n    \n    // Visualize\n    float gray = VisualizeDistance(distanceToSurface);\n    fragColor = vec4(gray, gray, gray, 1.);\n}\n","name":"Image","description":"","type":"image"}]}