{"ver":"0.1","info":{"id":"cs2GWd","date":"1668350344","viewed":56,"name":"Fork Fork Fork  Naitronbom 340","username":"Naitronbomb","description":"Domain coloring","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["domaincoloring"],"hasliked":0,"parentid":"cdj3Dt","parentname":"Fork Fork Domai Naitronbom 348"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int iterations = 500;\n\nvec2 cf(vec2 z) {\n    vec2 c = z;\n    vec2 z1 = vec2(0,0);\n    for (int i = 0; i < iterations; i++) {\n        z1 = cm(cs(z1),cexp(vec2(0,iTime))) + cm(c,cexp(vec2(0,-iTime)));\n    }\n    return z1;\n}\n\nconst float scale = 3.0;\n\nconst bool modPhase = true;\nconst bool modMag = true;\nconst float phaseRepeat = 8.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 z0 = scale*(fragCoord-iResolution.xy/2.0)/min(iResolution.x,iResolution.y);\n\n    vec2 z1 = cf(z0);\n    \n    float mag = cabs(z1);\n    \n    float angle = mod(arg(z1),pi*2.0);\n    \n    vec3 colorHSL = vec3(180.0/pi*angle, 1.0, l(mag,modMag));\n    \n    float chroma = (1.0-abs(2.0*colorHSL.z-1.0)) * colorHSL.y;\n    \n    float h1 = colorHSL.x/60.0;\n    \n    float x = chroma * (1.0 - abs(mod(h1,2.0)-1.0));\n    \n    vec3 colorRGB = vec3(0.0,0.0,0.0);\n    \n    if (h1 < 1.0) {\n        colorRGB = vec3(chroma,x,0.0);\n    } else if (h1 < 2.0) {\n        colorRGB = vec3(x,chroma,0.0);\n    } else if (h1 < 3.0) {\n        colorRGB = vec3(0.0,chroma,x);\n    } else if (h1 < 4.0) {\n        colorRGB = vec3(0.0,x,chroma);\n    } else if (h1 < 5.0) {\n        colorRGB = vec3(x,0.0,chroma);\n    } else if (h1 < 6.0) {\n        colorRGB = vec3(chroma,0.0,x);\n    }\n    \n    vec3 m = vec3(colorHSL.z-chroma/2.0);\n    \n    float phaseConst = 0.0;\n    \n    float magConst = 0.0;\n    \n    if (modPhase) {\n        phaseConst = (phaseRepeat/(2.0*pi))*mod(angle,pi/phaseRepeat)+0.5;\n    } else {\n        phaseConst = 1.0;\n    }\n    \n    if (modMag) {\n        float slope = 1.0/pow(2.0,floor(log(mag)/log(2.0)));\n        magConst = (slope*mag-floor(slope*mag))/2.0+0.5;\n    } else {\n        magConst = 1.0;\n    }\n    \n    // Output to screen\n    fragColor = vec4(avg(magConst,phaseConst)*(colorRGB+m),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float pi = 3.14159;\nfloat e = exp(1.0);\n\nfloat avg(float a, float b) {\n    return (a+b)/2.0;\n}\n\nfloat l(float x ,bool b) {\n    if (b) {\n        return 0.5;\n    } else {\n        return 2.0/3.14159*atan(x);\n    }\n}\n\nfloat cabs(vec2 z) {\n    return sqrt(pow(z.x,2.0)+pow(z.y,2.0));\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y,z.x);\n}\n\nvec2 cm(vec2 z1,vec2 z2) {\n    return vec2(z1.x*z2.x-z1.y*z2.y,z1.y*z2.x+z1.x*z2.y);\n}\n\nvec2 cs(vec2 z) {\n    return vec2(pow(z.x,2.0)-pow(z.y,2.0),2.0*z.x*z.y);\n}\n\nvec2 cd(vec2 z1,vec2 z2) {\n    return vec2(z1.x*z2.x+z1.y*z2.y,-z1.x*z2.y+z1.y*z2.x)/(pow(z2.x,2.0)+pow(z2.y,2.0));\n}\n\nvec2 cexp(vec2 z) {\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\n\nvec2 cpow1(float n, vec2 z) {\n    return pow(n,z.x)*vec2(cos(z.y*log(n)),sin(z.y*log(n)));\n}\n\nvec2 cpow2(vec2 z, float n) {\n    return pow(cabs(z),n)*vec2(cos(n*arg(z)),sin(n*arg(z)));\n}\n\nvec2 cpow(vec2 z1, vec2 z2) {\n    return cexp(z2*log(cabs(z1))+cm(vec2(0,arg(z1)),z2));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x)*cosh(z.y),cos(z.x)*sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x)*cosh(z.y),-sin(z.x)*sinh(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x)*cosh(z.y),cosh(z.x)*sinh(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x)*cosh(z.y),sinh(z.x)*sinh(z.y));\n}\n\nvec2 csqrt(vec2 z) {\n    return cpow2(z,0.5);\n}\n\nvec2 cln(vec2 z) {\n    return vec2(log(cabs(z)),arg(z));\n}\n\nvec2 clog(vec2 z, float n) {\n    return cd(cln(z),cln(vec2(n,0)));\n}","name":"Common","description":"","type":"common"}]}