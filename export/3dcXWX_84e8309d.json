{"ver":"0.1","info":{"id":"3dcXWX","date":"1572979081","viewed":394,"name":"Glow with iteration count","username":"munrocket","description":"Invented by me and inspired by this article \"Jussi Harkonen. On Smooth Fractal Coloring Techniques.\"","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["glow","smooth","60fps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License. Â© 2020 munrocket\n\n#define MAX_STEPS 80.\n#define MAX_DIST 15.\n#define DIFF_EPS 0.001\n#define SHAD_EPS 0.005\n\nfloat map(vec3 pos) {\n    float k = 0.1;\n    float d = length(vec3(abs(pos.x), pos.yz) - vec3(0.55, -0.15, 0.)) - 0.48;\n    float d2 = opUnion(d, length(pos - vec3(0., -0.18, 0.)) - 0.45, k);\n    float d3 = opUnion(d2, length(pos - vec3(-0.28, 0.18, 0.)) - 0.4, k);\n    float d4 = opUnion(d3, length(pos - vec3(0.25, 0.35, 0.)) - 0.4, k);\n    return  opSubstr(d4, max(0.05+pos.x, -abs(.04*pos.y*pos.y+0.0175) + abs(.04 - 0.1*fract(0.16+pos.x/0.16))), 0.01);\n}\n\nvec3 normal(vec3 pos) {\n    const vec2 e = vec2(SHAD_EPS, 0.);\n    return normalize(vec3(  \tmap(pos + e.xyy) - map(pos - e.xyy),\n              \t\t\t\t  \tmap(pos + e.yxy) - map(pos - e.yxy),\n              \t\t\t\t\tmap(pos + e.yyx) - map(pos - e.yyx)));\n}\n\nfloat marchGlow(vec3 camera, vec3 dir) {\n    float I, dt, t = 0.;\n    vec3 pos = camera + t * dir;\n    for(float i = 0.; i < MAX_STEPS; i++) {\n      \tpos = camera + t * dir;\n        dt = 0.95 * map(pos);\n        t += dt;\n        I = i;\n        if(dt < DIFF_EPS || t > MAX_DIST) break;\n    }\n    float outer = step(MAX_DIST, t);\n    float k = 1. + dot(normal(pos), dir);\n    \n    // smoothing with guessed constants\n    return I - mix(clamp((.5 + .5 * k) * log2(DIFF_EPS/dt), 0., 1.), 1.2*log2(abs(dt)), outer);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., 0.00, 2.6);\n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.1);\n    dir = rotate(dir, mouse);\n    camera = rotate(camera, mouse);\n    \n    vec3 col = mix(vec3(1., 0.57, 0.), vec3(0.93, 0.14, 0.), 1. - fragCoord.y / iResolution.y);\n    float glow = marchGlow(camera, dir) / 33.;\n    fragColor = vec4(col + glow, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI   3.1415926\n#define TWO_PI 6.2831853\n#define PI_2 1.5707963\n#define PI_4 0.7853982\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, clamp(iMouse.y, 0., 1.)));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), PI - TWO_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), PI * mouse.y - PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\n/* SDF functions */\n\nfloat opUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSubstr(float d2, float d1, float k) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h ) + k*h*(1.0-h);\n}\n\n","name":"Common","description":"","type":"common"}]}