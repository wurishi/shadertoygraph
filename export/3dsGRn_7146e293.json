{"ver":"0.1","info":{"id":"3dsGRn","date":"1544722539","viewed":71,"name":"Egg_Light","username":"JBtheHUT1988","description":"Wanted to make an egg containing a star that would then eggsplode in fiery conclusion.  I was immediately impeded by a number of things.  Now I settled on this raytracing shadow vignette. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["underwhelming"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://github.com/yuichiroharai/glsl-y-rotate/blob/master/rotateY.glsl\n\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotateZ(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, s, 0.0,\n        -s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t\t\n\t);\n}\n\nfloat kEpsilon = 1e-8;\n\nbool triangleTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.001 )\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n\n/*\nbool triangleTraceUV(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir,\n                    out float v, out float t)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n     v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n     t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.0)\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n*/\n\n\n\nbool planeTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n    if(t < 0.001)\n        return false;\n    \n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\nbool planeTraceUV(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\n\n//send a ray toward a sphere?\n//return true if it intersects sphere\n//also set the intersecting 3D Point\n//and reflected Ray direction\n\n\nbool sphereTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 spherePos, in float sphereRadius,\n\tout vec3 intersectPos, out vec3 intersectDir) {\n\n\t//create a vector from ray Starting Point to Sphere Center\n\tvec3 L = spherePos - rayPos;\n\n\t//project that ray onto my ray direction and get its length\n\tfloat tc = dot(L, rayDirection);\n\n\tif (tc < 0.0)\n\t\treturn false;\n\n\t//float d = sqrt(pow(length(L), 2.0) - pow(tc,2.0));\n\tfloat d = sqrt(dot(L, L) - pow(tc, 2.0));\n\tif (d > sphereRadius)\n\t\treturn false;\n\n\tfloat t1c = sqrt(pow(sphereRadius, 2.0) - pow(d, 2.0));\n\n\t//distance from ray Start to hitting the sphere\n\tfloat t1 = tc - t1c;\n\n\t//results in 3D point where ray hits the sphere\n\tintersectPos = rayPos + rayDirection * t1;\n\n\tvec3 normal = normalize(intersectPos - spherePos);\n\n\tintersectDir = reflect(rayDirection, normal);\n\n\treturn true;\n\n}\n\nconst ivec3 CUBE_INDEX[12] = ivec3[12](\n\tivec3(0, 1, 2),\n\tivec3(2, 1, 3),\n\tivec3(2, 3, 4),\n\tivec3(4, 3, 5),\n\tivec3(4, 5, 6),\n\tivec3(6, 5, 7),\n\tivec3(6, 7, 0),\n\tivec3(0, 7, 1),\n\tivec3(1, 7, 3),\n\tivec3(3, 7, 5),\n\tivec3(6, 0, 4),\n\tivec3(4, 0, 2)\n\t);\n\n//verts position\nconst vec3 CUBE_VERTS[8] = vec3[8](\n\tvec3(-0.25, -0.25, 0.25),\n\tvec3(0.25, -0.25, 0.25),\n\tvec3(-0.25, 0.25, 0.25),\n\tvec3(0.25, 0.35, 0.25),\n\tvec3(-0.25, 0.25, -0.25),\n\tvec3(0.25, 0.25, -0.25),\n\tvec3(-0.25, -0.25, -0.25),\n\tvec3(0.25, -0.25, -0.25)\n\t);\n\n//Cone:\n\nconst ivec3 CONE_INDEX[8] = ivec3[8](\n    ivec3( 0 ,  4 ,  3 ), \n    ivec3( 0 ,  1 ,  5 ), \n    ivec3( 1 ,  2 ,  5 ), \n    ivec3( 2 ,  3 ,  5 ), \n    ivec3( 3 ,  4 ,  5 ), \n    ivec3( 4 ,  0 ,  5 ), \n    ivec3( 4 ,  0 ,  5 ), \n    ivec3( 4 ,  0 ,  5 ) \n    );\n\nconst vec3 CONE_VERTS[6] = vec3[6](\n    vec3( 0.309017121792 ,  -1.0 ,  -0.951056599617 ), \n    vec3( -0.809017002583 ,  -1.0 ,  -0.587785363197 ), \n    vec3( -0.809017062187 ,  -1.0 ,  0.587785243988 ), \n    vec3( 0.30901697278 ,  -1.0 ,  0.951056540012 ), \n    vec3( 1.0 ,  -1.0 ,  0.0 ), \n    vec3( 0.0 ,  1.0 ,  0.0 ) \n    );\n\n\n//Cuboid:\nconst vec3 CUBOID_VERTS[12] = vec3[12](\n    vec3( 0.0 ,  0.0 ,  -1.0 ), \n    vec3( 0.723606824875 ,  0.525731086731 ,  -0.447213590145 ), \n    vec3( -0.276393264532 ,  0.850650906563 ,  -0.44721364975 ), \n    vec3( -0.8944272995 ,  -7.81933167104e-08 ,  -0.44721364975 ), \n    vec3( -0.276393294334 ,  -0.850650787354 ,  -0.447213590145 ), \n    vec3( 0.72360676527 ,  -0.525731146336 ,  -0.447213590145 ), \n    vec3( 0.8944272995 ,  0.0 ,  0.44721364975 ), \n    vec3( 0.276393175125 ,  0.850650846958 ,  0.447213590145 ), \n    vec3( -0.72360688448 ,  0.525731086731 ,  0.44721364975 ), \n    vec3( -0.72360676527 ,  -0.52573120594 ,  0.447213590145 ), \n    vec3( 0.276393324137 ,  -0.850650787354 ,  0.447213590145 ), \n    vec3( 0.0 ,  0.0 ,  1.0 ) \n    );\nconst ivec3 CUBOID_INDEX[20] = ivec3[20](\n    ivec3( 0 ,  2 ,  1 ), \n    ivec3( 0 ,  3 ,  2 ), \n    ivec3( 0 ,  4 ,  3 ), \n    ivec3( 0 ,  5 ,  4 ), \n    ivec3( 0 ,  1 ,  5 ), \n    ivec3( 1 ,  2 ,  7 ), \n    ivec3( 2 ,  3 ,  8 ), \n    ivec3( 3 ,  4 ,  9 ), \n    ivec3( 4 ,  5 ,  10 ), \n    ivec3( 5 ,  1 ,  6 ), \n    ivec3( 1 ,  7 ,  6 ), \n    ivec3( 2 ,  8 ,  7 ), \n    ivec3( 3 ,  9 ,  8 ), \n    ivec3( 4 ,  10 ,  9 ), \n    ivec3( 5 ,  6 ,  10 ), \n    ivec3( 6 ,  7 ,  11 ), \n    ivec3( 7 ,  8 ,  11 ), \n    ivec3( 8 ,  9 ,  11 ), \n    ivec3( 9 ,  10 ,  11 ), \n    ivec3( 10 ,  6 ,  11 ) \n    );\n\n\n\nconst vec3 SPHERE_POS[3] = vec3[3](vec3(2.0, 0.5, -1.0),\n\tvec3(0.5, 0.0, 0.0),\n\tvec3(0.55, 0.25, -1.0)\n\n\t);\n\nconst vec3 SPHERE_COLOR[3] = vec3[3](vec3(1.0, 2.0, 01.0),\n\tvec3(0.5, 0.5, 0.0),\n\tvec3(1.0, 0.0, 0.0)\n\t);\n\nconst float SPHERE_RADIUS[3] = float[3](0.5, 0.3, 0.1\n\t);\n\nconst vec3 LIGHT_POS[3] = vec3[3](vec3(1.0, 10.0, 0.0),\n\tvec3(-5.0, 2.5, 5.0),\n\tvec3(2.5, 2.5, 10.0)\n\n\t);\n\nconst vec3 LIGHT_COLOR[3] = vec3[3](vec3(0.0, 0.0, 1.0),\n\tvec3(1.0, 1.0, 1.0),\n\tvec3(1.0, 0.0, 0.0)\n\t);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord / iResolution.y;\n\tuv -= 0.5; //center the uvs\n\n\tvec3 lightloc = vec3(LIGHT_POS[1].x, LIGHT_POS[1].y * sin(iTime) * 3.0 + 10.0, LIGHT_POS[1].z);\n\tvec3 cubePos = vec3(0.5, 0.55, -1.0);//*rotateZ(iTime / 2.0);\n    \n\tvec3 conePos = vec3(3.0, 1.05, -0.5);//*rotateZ(iTime / 2.0);\n    \n\tvec3 cubdPos = vec3(-1.0, 1.05, -0.5);//*rotateZ(iTime / 2.0);\n\n\n\tvec3 lightPos = vec3(0, 10, 0);\n\tvec3 lightPos2 = vec3(5, 0, 5.0);\n\n\t//vec3 rayPos = vec3(uv.x, uv.y + 2.0, 7.0);\n    vec3 rayPos = vec3(0.0,0.5, 3.0); /*rotateY(iTime / 2.0);*/\n\t\n\tvec3 rayDir = normalize(vec3(uv.x*3.0, uv.y *3.0, -3.0));/*rotateY(iTime / 2.0));*/\n\n\tvec3 planePos = vec3(0.0, -0.25, 0.0);\n\tvec3 planeNormal = vec3(0.0, 1.0, 0.0);\n    \n\tvec3 planePos_A = vec3(0.0, 0.0, -2.0);\n\tvec3 planeNormal_A = vec3(0.0, 0.0, 1.0);\n    \n\tvec3 planePos_B = vec3(-1000.5, 0.0, 0.0);\n\tvec3 planeNormal_B = vec3(1.0, 0.0, 0.0);\n\n\n\tvec3 newPos;\n\tvec3 newDir;\n\tvec3 currColor;\n\n\tvec3 col = vec3(0.0);\n\n\t//loop for ray bounces\n\tfor (int r = 0; r <2; r++) {\n\n\t\t//col = vec3(0.0);\n\n\t\tfloat minDist = 999999999.0;\n\t\tvec3 tempNewPos;\n\t\tvec3 tempNewDir;\n\n\t\t//foreach sphere in our scene check if ray hits it\n\t\tfor (int s = 0; s <2 ; s++) {\n\n\t\t\t//check if the current pixel ray (uv) interects with a sphere\n\n\t\t\tif (sphereTrace(rayPos, rayDir,\n\t\t\t\trotateY(iTime*float(s))*SPHERE_POS[s], SPHERE_RADIUS[s],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = SPHERE_COLOR[s];\n\n\t\t\t\t}\n\n\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t}\n\n\t\t}\n        \n        //end of sphere Tracing, still bouncing rays tho\n        \n        \n        /*\n\t\tfor (int f = 0; f < 12; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CUBE_VERTS[CUBE_INDEX[f].x] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].y] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].z] * rotateY(iTime) + cubePos,\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = vec3(0.5,0.0,1.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        */\n        \n        \n        /*\n\t\tfor (int f = 0; f < 8; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CONE_VERTS[CONE_INDEX[f].x] * rotateY(iTime) + conePos,\n                              CONE_VERTS[CONE_INDEX[f].y] * rotateY(iTime) + conePos,\n                              CONE_VERTS[CONE_INDEX[f].z] * rotateY(iTime) + conePos,\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = vec3(0.5,0.0,1.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n\t\tfor (int f = 0; f < 20; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CUBOID_VERTS[CONE_INDEX[f].x] * rotateY(iTime) + cubdPos,\n                              CUBOID_VERTS[CONE_INDEX[f].y] * rotateY(iTime) + cubdPos,\n                              CUBOID_VERTS[CONE_INDEX[f].z] * rotateY(iTime) + cubdPos,\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = texture(iChannel1, newPos.xz/10.0).rrr;//vec3(1.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        */\n        \n        //------------------------------planeTracing------------------------\n        \n\n\t\tif (planeTrace(rayPos, rayDir,\n\t\t\tplanePos, planeNormal,\n\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\tif (dist < minDist) {\n\n\t\t\t\tminDist = dist;\n\n\t\t\t\tnewPos = tempNewPos;\n\t\t\t\tnewDir = tempNewDir;\n\t\t\t\tcurrColor = texture(iChannel1, newPos.xz/10.0).rrr;//vec3(1.0);\n\n\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t}\n\n        \n\t\tif (planeTrace(rayPos, rayDir,\n\t\t\tplanePos_A, planeNormal_A,\n\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\tif (dist < minDist) {\n\n\t\t\t\tminDist = dist;\n\n\t\t\t\tnewPos = tempNewPos;\n\t\t\t\tnewDir = tempNewDir;\n\t\t\t\tcurrColor = vec3(0.05,0.8,2.0);\n\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t}\n\n        \n\t\tif (planeTrace(rayPos, rayDir,\n\t\t\tplanePos_B, planeNormal_B,\n\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\tif (dist < minDist) {\n\n\t\t\t\tminDist = dist;\n\n\t\t\t\tnewPos = tempNewPos;\n\t\t\t\tnewDir = tempNewDir;\n\t\t\t\tcurrColor = vec3(0.5,0.80,0.20);\n\n\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t}\n\n        \n        //------------------------------End planeTracing------------------------\n\n\n\n\t\tif (minDist < 50.0) { //make sure this ray doesn't hit anything\n\n\t\t\trayPos = newPos;\n\t\t\trayDir = newDir;\n\n\n\t\t//\t col = newDir;\n        //    col = vec3(minDist/50.0);\n\n\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t//now let's check if this ray can see the light sources\n\n                vec3 lightDir = normalize(lightloc - rayPos);\n\t\t\t\tfloat lightDist = 9999999.9f;\n\n\n\t\t\t\tfor (int s = 0; s < 3; s++) {\n\n\t\t\t\t\t//check if the current pixel ray (uv) interects with a sphere\n\n\t\t\t\t\tif (sphereTrace(rayPos, lightDir,\n\t\t\t\t\t\trotateY(iTime*float(s))*SPHERE_POS[s], SPHERE_RADIUS[s],\n\t\t\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\t\tlightDist = dist;\n\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int f = 0; f < 12; f++) {\n\t\t\t\t\tif (triangleTrace(rayPos, lightDir,\n\t\t\t\t\t\t\t\tCUBE_VERTS[CUBE_INDEX[f].x] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].y] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].z] * rotateY(iTime) + cubePos,\n                                      tempNewPos, tempNewDir)) {\n\n\t\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\t\tlightDist = dist;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                \n                \n                //likely need the cuboid and cone trace here as well\n\n\t\t\t\tif (planeTrace(rayPos, lightDir,\n\t\t\t\t\tplanePos, planeNormal,\n\t\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\tlightDist = dist;\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t\t}\n\n\n\t\t\t\tif (lightDist > distance(rayPos, lightloc)) {\n\t\t\t\t\tcol += (currColor*0.15 //ambient\n\t\t\t\t\t\t+ clamp(dot(rayDir, lightDir), 0.0, 1.0)*currColor* vec3(10.0, 0.0, 0.0) //diffuse\n\t\t\t\t\t\t+ pow(clamp(dot(rayDir, lightDir), 0.0, 1.0), 50.8) * LIGHT_COLOR[l]\n\n\t\t\t\t\t\t) * (1.0/(float(r) + 1.0))\n\t\t\t\t\t\t* 50.0 / pow(distance(rayPos, lightloc), 2.0);\n\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t}\n    \n\t// Output to screen\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}