{"ver":"0.1","info":{"id":"7syfWy","date":"1658787327","viewed":64,"name":"Tiled Particles","username":"ctrain","description":"Tiling, similar to the way Voronoi is implemented with 27 neighbour lookups for distance to a random point in each cell. The distances are just accumulated instead of taking the minimum distance. Looks similar to Perlin noise, no permutation function.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distance","tiling","cells","neighbours"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Inigo Quilez randomness\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nconst float pi = 3.14159;\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nstruct data {\n    float d1, d2, d3;\n};\n\ndata dist_closest_point(data d, vec3 pos, vec3 pi)\n{\n    for (int x = -1; x < 2; x++) {\n    for (int y = -1; y < 2; y++) {\n    for (int z = -1; z < 2; z++) {\n        vec3 pt = pi + vec3(x, y, z);\n        vec3 rand_nghbr = hash(uvec3(pt));\n        float dist = length(pos - (pt + rand_nghbr));\n        d.d1 = (d.d1 + 1./(1. + 20.*pow(dist,5.)));\n    }}}\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float size = 10.0;\n    \n    vec3 pt = vec3(fragCoord,iTime*5.0);\n    \n    vec3 pi = floor(pt / size);\n    vec3 pf = mod(pt, size)/size;\n    \n    vec3 f = hash(uvec3(pi));\n    \n    data d = data( 0., 0., 0. );\n    data dist = dist_closest_point(d, pi + pf, pi);\n    float c = 1.1*d.d1 + 0.9*d.d2 - 1.1*d.d3;\n    float r = 0.15*c;\n    float g = 0.3*c;\n    float b = 0.5*c + 0.3*(1.-c);\n    // Output to screen\n    fragColor = vec4(0.5*dist.d1, 0., 0., 1.0);\n}","name":"Image","description":"","type":"image"}]}