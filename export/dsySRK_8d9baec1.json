{"ver":"0.1","info":{"id":"dsySRK","date":"1681298102","viewed":47,"name":"Grille et anticrénelage stochast","username":"xiongjian","description":"Grille et anticrénelage stochastique","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//Constantes et structures\n\n/*\nMatériau : définit une structure qui représente les propriétés du matériau, y compris le coefficient de lumière ambiante (Ka), le coefficient de réflexion diffuse (Kd), le coefficient de réflexion spéculaire (Ks) et l'indice de réflexion spéculaire (Kn).\n\nShadeInfo : définit une structure qui représente les informations d'éclairage, y compris la valeur de couleur calculée (shadedCol) et le coefficient de réflexion spéculaire (Ks).\n\nLightInfo : définit une structure qui représente les informations de la source lumineuse, y compris la position (pos), la couleur (col) et la puissance (power).\n\nMAX_NB_BOUNCES : définit le nombre maximal de rebonds utilisés pour contrôler la profondeur de la récursivité.\n\ncameraPos : position de la caméra.\n\ncameraTarget : Le point cible de la caméra.\n\ncameraFovY : champ de vision de la caméra.\n\nspherePos : la position de la sphère.\n\nsphereRadius : Le rayon de la sphère.\n\nsphereCol : la couleur de la sphère.\n\nsphereMat : la propriété matérielle de la sphère.\n\nsphereId : numéro d'identification de la sphère.\n\nskyCol : La couleur du ciel.\n\nskyId : numéro d'identification du ciel.\n\nplanePos : la position de l'avion.\n\nplaneNormal : le vecteur normal du plan.\n\nplaneCol1 : La première couleur du plan.\n\nplaneCol2 : la deuxième couleur du plan.\n\nplaneMat : la propriété matérielle du plan.\n\nplaneId : numéro d'identification de l'avion.\n\nPIXEL_SAMPLING_GRID_SIZE : taille de la grille de sous-pixels par échantillon de pixels.\n\nPIXEL_SAMPLING_SIZE : le nombre d'échantillons par sous-pixel dans la grille de sous-pixels.\n\nambiantCol : La couleur de la lumière ambiante.\n\nlight1Col : La couleur de la source lumineuse 1.\n\nlight1Pos : La position de la source lumineuse 1.\n\nlight1Pow : La puissance de la source lumineuse 1.\n\nlight2Col : La couleur de la source lumineuse 2.\n\nlight2Pos : La position de la source lumineuse 2.\n\nlight2Pow : La puissance de la source lumineuse 2.\n\nNB_LIGHTS : Nombre de sources lumineuses.\n\nlumières : un tableau contenant des informations sur toutes les sources lumineuses\n*/\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0;\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightPos = vec3(8,10,-12);\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 25;\n\n\n\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\n/*\nLorsqu'un rayon coupe une sphère,\nle point d'intersection du rayon et de la sphère et le vecteur normal au point d'intersection sont calculés, \net la distance entre le point d'intersection du rayon et de la sphère et le point de départ du rayon est renvoyée\n*/\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n/*intersection de la lumière et du plan*/\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\n/*La position et la direction du rayon émis depuis la position de la caméra aux coordonnées pixel pixCoord*/\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n//Ce code implémente le modèle d'éclairage Phong\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V)\n{\n    vec3 A = sphereMat.Ka * ambiantCol;\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n\n/*Calcule l'intersection la plus proche d'un rayon \nà partir de la position de la caméra avec tous les objets (sphères et plans) de la scène \net renvoie la distance de l'intersection la plus proche à la caméra\n*/\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n//définit la couleur de chaque boule\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n//Obtenez la couleur du point spécifié sur le plan et jugez de la couleur du point en fonction du fait que la ligne et la colonne où se trouve le point sont des nombres pairs.\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        \tbreak;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        \tbreak;\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        \tbreak;\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\n\n\n\n\n/*\nIl prend une coordonnée de pixel comme argument et renvoie la couleur obtenue par lancer de rayons sur ce pixel. \nPlus précisément, la fonction utilise d'abord la fonction computeCameraRayFromPixel pour calculer le point de départ et la direction d'un rayon à partir de la position de la caméra, \npuis utilise la fonction computeNearestIntersection pour trouver le point d'intersection le plus proche du rayon avec un objet dans la scène et ses informations associées.\nS'il n'y a pas d'intersection, la fonction renvoie skyCol (la couleur du ciel). Sinon, la fonction utilise la fonction getObjectColorAtPoint pour obtenir la couleur et le matériau de l'objet à l'intersection et calcule le facteur d'ombre à l'intersection. \nEnfin, la fonction calcule la couleur finale de ce pixel à l'aide de la fonction computePhongShading, qui calcule le modèle d'ombrage Phong à l'aide d'informations telles que la couleur de l'objet, le matériau, le facteur d'ombrage, la normale à l'intersection,\nla lumière entrante, la lumière réfléchie et la direction de la vue.*/\nvec3 raycastAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    int objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    if(distI <= 0.0)\n        return skyCol;\n    \n    vec3 L = lightPos - intersecI;\n    float Ldist = length(L);\n    L = L / Ldist;\n    \n    vec3 R = 2.0 * dot(normalI,L) * normalI - L;\n    \n    vec3 V = -rayDir;\n    \n    Material objectMat;\n    vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n    \n    float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n    \n    vec3 resCol = computePhongShading(objectCol, objectMat, shadowFactor, normalI, L, R, V);\n    \n    return resCol;\n}\n\n//fonction pour générer du bruit 2D\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n//Une fonction d'animation de scène qui prend du temps comme paramètre d'entrée\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    lightPos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\n\n\n\n\n\n/*\nLe paramètre d'entrée out vec4 fragColor dans la fonction indique la couleur du pixel actuel, et dans vec2 fragCoord indique les coordonnées du pixel actuel à l'écran.\n\nCette fonction obtient d'abord l'heure actuelle et anime la scène via la fonction animateScene.\n\nTransformez ensuite les coordonnées en pixels (via la fonction transform_to_apply) pour les adapter aux différentes résolutions d'écran.\n\nEnsuite, la fonction exécute deux méthodes d'anticrénelage différentes :\n\nAnti-crénelage de maillage : réduit l'apparence du crénelage et des mosaïques en effectuant plusieurs tracés de rayons dans la zone autour d'un pixel et en calculant la moyenne des résultats.\n\nAnticrénelage aléatoire : simule un effet plus réaliste en effectuant plusieurs lancers de rayons dans une zone autour du pixel actuel, en utilisant des valeurs de bruit pour positionner chaque échantillon.\n\nEnfin, définissez le résultat comme la couleur du pixel actuel.*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    animateScene(time*1.0);\n    \n    //Apply change of coordinates from pixel\n    fragCoord = transform_to_apply(fragCoord.xy);\n    \n    vec3 resCol = vec3(0);\n    \n    //Grid antialiasing\n    \n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        for (int j=0; j<PIXEL_SAMPLING_GRID_SIZE; j++) \n        {\n            vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE)*800.),float(j)/(float(PIXEL_SAMPLING_SIZE)*600.));\n\t\t\tresCol += raycastAtPixelCoord(fragCoord + offset);\n      \t}\n    }\n    \n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_GRID_SIZE);\n    \n    //Stochastic antialiasing\n    /*\n    for (int i=0; i<PIXEL_SAMPLING_SIZE; i++) \n    {\n        vec2 q =  vec2(float(i), float(i));\n        vec2 n = noise2( fragCoord , q );\n        vec2 offset = vec2(n.x/800., n.y/600.);\n\t\tresCol += raycastAtPixelCoord(fragCoord + offset);\n    }\n    resCol /= float(PIXEL_SAMPLING_SIZE);*/\n    \n    fragColor = vec4(resCol,1);\n}","name":"Image","description":"","type":"image"}]}