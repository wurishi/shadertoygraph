{"ver":"0.1","info":{"id":"DstSzn","date":"1679384749","viewed":46,"name":"my_test_1","username":"akissing","description":"1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\n\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nstruct Surface {\n  int id;\n  float d;\n  Material material;\n};\n\n\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.d < obj1.d) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdCylinder( vec3 p, float h, float r, vec3 offset, mat3 transform)\n{\n  p -= offset * transform;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  float res =  min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return res;\n}\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdFloor(vec3 p) {\n  float d = p.y + 1.;\n  return d;\n}\n\n\nSurface sdScene(vec3 p) {\n  Surface cLeft = Surface(1, sdCylinder(p, 1., 1., vec3(-2, 0, 0), rotateZ(iTime)), gold());\n  Surface cRight = Surface(2, sdCylinder(p, 1., 1., vec3(2, 0, 0), rotateX(iTime)), gold());\n  \n  Surface res = minWithColor(cLeft, cRight);\n  \n  res.d = opSmoothUnion(cLeft.d, cRight.d, 0.2); // blend objects together\n  \n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface floor = Surface(3, sdFloor(p), checkerboard(p));\n  Surface co = minWithColor(res, floor);\n  \n  \n  return co;\n}\n\n\n\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\n// Inigo Quilez\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < MAX_SHADOW_MARCHING_STEPS; i++) {\n    float h = sdScene(ro + rd * t).d;\n    res = min(res, 8.0*h/t);\n    t += clamp(h, 0.02, 0.10);\n    if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\n\n\n\n\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.d;\n    if (co.d < PRECISION || depth > end) break;\n  }\n  co.d = depth;\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n  float e = 0.0005; // epsilon\n  float r = 1.; // radius of sphere\n  return normalize(vec3(\n    sdScene(vec3(p.x + e, p.y, p.z)).d - sdScene(vec3(p.x - e, p.y, p.z)).d,\n    sdScene(vec3(p.x, p.y + e, p.z)).d - sdScene(vec3(p.x, p.y - e, p.z)).d,\n    sdScene(vec3(p.x, p.y, p.z  + e)).d - sdScene(vec3(p.x, p.y, p.z - e)).d\n  ));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n\n  //https://www.shadertoy.com/view/Ms2SD1\n  float e_y = (max(uv.y,0.0)*0.8+0.2)*0.8;\n  vec3 backgroundColor = vec3(pow(1.0-e_y,2.0), 1.0-e_y, 0.6+(1.0-e_y)*0.4) * 1.1;\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 10, 0); // ray origin that represents camera position  \n  vec3 lp = vec3(0, 0, 0); // lookat point (aka camera target)\n  \n  // Return the offset value from the last frame (zero if it's first frame)\n  //vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n  \n  //ro.x = cos(iTime) * (lp.x + 3.);\n  //ro.y = cos(iTime) * (lp.y + 3.);\n  //ro.z = (sin(iTime) * (lp.z + 3.)) + 6.;\n  \n  float cameraRadius = 1.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(PI/2., 0., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z); // remap mouseUV.x to <-pi, pi> range\n\n  \n  \n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n\n  if (co.d > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.d; // point on sphere we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    \n    \n    // light #1\n    vec3 lightPosition1 = vec3(0, 6, 0);\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    float lightIntensity1 = 0.9;\n\n    // light #2\n    vec3 lightPosition2 = vec3(6, 0, 2);\n    vec3 lightDirection2 = normalize(lightPosition2 - p);\n    float lightIntensity2 = 0.5;\n\n    // final color of object\n    col = lightIntensity1 * phong(lightDirection1, normal, rd, co.material);\n    col += lightIntensity2 * phong(lightDirection2, normal , rd, co.material);\n\n    float shadow = clamp(softShadow(p, lightDirection1, 0.02, 2.5), 0.2, 1.0);\n    float shadow2 = clamp(softShadow(p, lightDirection2, 0.02, 2.5), 0.2, 1.0);\n\n    shadow *= (1./lightIntensity1);\n    shadow2 *= (1./lightIntensity2);\n    if (shadow > 1.) shadow = 1.;\n    if (shadow2 > 1.) shadow2 = 1.;\n    col *= shadow * shadow2;\n    \n    col = mix(col, backgroundColor, 1.0 - exp(-0.00005 * co.d * co.d * co.d)); // fog\n\n  }\n  // Output to screen\n  \n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}