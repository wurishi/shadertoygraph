{"ver":"0.1","info":{"id":"WtGBDd","date":"1615253625","viewed":110,"name":"Ice Lattice","username":"uada","description":"quick ice lattice raymarcher","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","subsurface","ice","bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float max_iter = 200.0;\n\nfloat sdfSphere(vec3 p, vec4 sphere)\n{\n    return distance(p, sphere.xyz) - sphere.w;\n}\n\nvec3 rotate_z(vec3 p, float a)\n{\n    return mat3(\n        vec3(sin(a), cos(a),0),\n        vec3(-cos(a), sin(a),0),\n        vec3(0,0,1)\n    ) * p;\n}\n\nvec3 rotate_y(vec3 p, float a)\n{\n    return mat3(\n        vec3(sin(a), 0, cos(a)),\n        vec3(0,1,0),\n        vec3(-cos(a),0, sin(a))\n    ) * p;\n}\n\n\nfloat subsurf_ndotl(vec3 n, vec3 l, float wrap)\n{\n    return max(0.0, (dot(n,l)+wrap) / (1. + wrap));\n}\n\nvec3 fresnelSchlickR(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}   \n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\n// bump mapping from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat bnoise(in vec3 p)\n{\n    float n = sin(triNoise3d(p*.3,0.0)*11.)*0.6+0.4;\n    n += sin(triNoise3d(p*1.,0.05)*40.)*0.1+0.9;\n    return (n*n)*0.003;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(.005,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*2.5/sqrt(ds));\n    return n;\n}\n\n\nvec3 map(vec3 p)\n{\n    vec4 sphere_1 = vec4(.50,.50,.50,.40);\n    \n    \n    p = mod(p, vec3(2.0));\n    \n    \n    float d1 = sdfSphere(p, sphere_1);\n\n    float d2 = distance(p.xz, vec2(0.5,0.5)) - 0.1;\n    float d3 = distance(p.xy, vec2(0.5,0.5)) - 0.1;\n    float d4 = distance(p.zy, vec2(0.5,0.5)) - 0.1;\n\n\n    float td = min(d1,d2);\n    td = min(td, d3);\n    td = min(td, d4);\n    \n    return vec3(td,0,0);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec4 ray_march(vec3 ro, vec3 rd, float min_d, float max_d, float pres, bool rotate)\n{\n    float dist = 0.0;\n    float total_dist = 0.0;\n    vec3 point = ro;\n    for (float i = 0.0; i < max_iter; i+=1.0)\n    {\n        float dist = map(point).x * pres;\n        if(dist < min_d || total_dist > max_d) break;\n        point += dist*rd;\n        total_dist += dist;\n        if (rotate)\n           rd.xy = cos(0.15*dist)*rd.xy + sin(0.15*dist)*vec2(-rd.y, rd.x);\n    }\n    return vec4(point, total_dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,1,5.0 + iTime);\n    vec3 rd = vec3(uv.x, uv.y, -1);\n    rd = normalize(rd);\n    \n    rd = rotate_y(rd,iTime);\n    rd = rotate_z(rd,iTime*0.5);\n\n    const float min_dist = 0.002;\n    const float max_dist = 100.0;\n    \n    \n    vec4 res = ray_march(ro, rd, min_dist, max_dist, .2570, true);\n    float total_dist = res.w;\n    \n    vec3 world_point = res.xyz;\n    \n    float depth = ray_march(world_point + rd * 0.2 , rd, 0.000001, max_dist, -.01280, true).w;\n    \n    //depth = depth/(1.0+depth);\n    \n    vec3 n = calcNormal(world_point);\n    \n    n = bump(mod(world_point,2.0), n, .510);\n    \n    float ndotv = max(0.0,dot(n, -rd));\n    vec3 fres = fresnelSchlick(ndotv*0.5, vec3(0.04));\n    vec3 mask_1 = 1.0 - fresnelSchlick(ndotv, vec3(0.04)) * 20.0;\n    mask_1 = smoothstep(0.0, .30, mask_1) * 1.6666;\n    \n    \n    vec3 col = vec3(total_dist/5.0);\n    vec3 l = normalize(vec3(1,2,3));\n    float ndotl = subsurf_ndotl(n,l,.50);\n    \n    float lo = ndotl;\n    \n    vec3 c1 = vec3(0.513,0.522,0.98); \n    vec3 c2 = vec3(0.653,0.642,0.98);\n    \n    c1 = pow(c1, vec3(2.2));\n    \n    float fog = total_dist/(1.0+total_dist);\n    \n    col = vec3(c1 + fres);\n\n    col += c2 * max(0.0,exp(-depth));\n\n    col *= vec3(1.0-fog);\n\n    col = pow(col, vec3(2.2));  \n    col = col/(1.0+col);\n    col = pow(col, vec3(1.0/2.2));  \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}