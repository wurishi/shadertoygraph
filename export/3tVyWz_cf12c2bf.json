{"ver":"0.1","info":{"id":"3tVyWz","date":"1610992057","viewed":96,"name":"elisha464 - 3d voronoi","username":"elisha464","description":"3d voronoi visualization using ray marching","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingvoroni"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE 20.0\n#define SURFACE_DIST 0.001\n\nfloat scene(vec3 p) {\n    return length(vec3(p.x+cos(iTime)*3.0, p.y+sin(iTime)*3.0, p.z))-5.0;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    vec3 hitPos = ro;\n    float d = 0.0;\n    while (true) {\n        hitPos = ro + d*rd;\n        \n        float f = scene(hitPos);\n        \n        if (d > MAX_DISTANCE || f < SURFACE_DIST) break;\n        \n        d += f;\n    }\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n\n    float d = scene(p);\n    vec2 e = vec2(SURFACE_DIST, 0.0);\n    \n    return normalize(d - vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx)));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -18.0);\n    vec3 rd = normalize(vec3(p, 1.5));\n    \n    vec3 sunDir = normalize(vec3(sin(iTime), -1.0, cos(iTime)));\n    vec3 sunCol = vec3(0.8, 0.5, 0.2);\n    vec3 ambCol = vec3(0.2, 0.0, 0.5);\n    \n    vec3 col = vec3(0.001);\n    \n    float d = rayMarch(ro, rd);\n    vec3 lighting = sunCol*dot(calcNormal(ro+rd*d), -sunDir);\n    lighting += ambCol;\n    \n    \n    \n    if (d < MAX_DISTANCE) {\n        col += voronoi(ro+rd*d*1.0, 0.03);\n        col *= lighting;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float noise21(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise31(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 4.1414, 24.3364))) * 43758.5453);\n}\n\nvec2 noise22(vec2 p) {\n    return fract(vec2(noise21(p), noise21(p+232.245)));\n}\n\nvec3 noise23(vec2 p) {\n    return fract(vec3(noise21(p), noise21(p+232.245), noise21(p+345.768)));\n}\n\nvec3 noise33(vec3 p) {\n    return fract(vec3(noise31(p), noise31(p+232.245), noise31(p+345.768)));\n}\n\nvec3 voronoi(vec3 p, float edgeWidth) {\n    vec3 id = floor(p);\n    float d = 10.0;\n    vec3 closestPoint = id + noise33(id);\n    float dToEdge = 10.0;\n    \n    // find colsest point\n    for (float i=-1.0; i<=1.0; i++) {\n        for (float j=-1.0; j<=1.0; j++) {\n            for (float k=-1.0; k<=1.0; k++) {\n                vec3 currCellId = id + vec3(i, j, k);\n                vec3 currPoint = (currCellId + noise33(currCellId));\n                float currDistance = length(p - currPoint);\n                if (currDistance < d) {\n                    closestPoint = currPoint;\n                    d = currDistance;\n                }\n            }\n        }\n    }\n    \n    // find distance to edge\n    float distanceToEdge = 10.0;\n    for (float i=-1.0; i<=1.0; i++) {\n        for (float j=-1.0; j<=1.0; j++) {\n            for (float k=-1.0; k<=1.0; k++) {\n                vec3 currCellId = id + vec3(i, j, k);\n                vec3 currPoint = (currCellId + noise33(currCellId));\n\n                if (length(closestPoint - currPoint) < 0.001) continue;\n\n                vec3 currPointDir = currPoint - closestPoint;\n                vec3 midPoint = (currPoint + closestPoint)*0.5;\n\n                distanceToEdge = min(dot(midPoint - p, normalize(currPointDir)), distanceToEdge);\n\n                //vec2 midPoint = id\n            }\n        }\n    }\n\n    float edgeSmooth = 0.02;\n    return smoothstep(edgeWidth-edgeSmooth, edgeWidth, distanceToEdge) * noise33(closestPoint);\n    //return vec3(d);\n}","name":"Common","description":"","type":"common"}]}