{"ver":"0.1","info":{"id":"WssfRM","date":"1587919320","viewed":276,"name":"2D transformations playground","username":"jaszunio15","description":"Shader for learning how 2D transformations based on 3x3 matrices work.\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","learning","playground","transforms","mat3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n#define POINT_SIZE 3.0\n#define PI 3.1419\n\n//creating scaling transformation matrix\nmat3 scaleMat(float scaleX, float scaleY)\n{\n\tmat3 M;\n    M[0] = vec3(scaleX, 0.0, 0.0);\n    M[1] = vec3(0.0, scaleY, 0.0);\n    M[2] = vec3(0.0, 0.0, 1.0);\n    \n    return M;\n}\n\n//creating rotating transformation matrix\nmat3 rotationMat(float angle)\n{\n    angle = angle / 180.0 * PI;\n        \n \tmat3 M;\n    M[0] = vec3(cos(angle), sin(angle), 0.0);\n    M[1] = vec3(-sin(angle), cos(angle), 0.0);\n    M[2] = vec3(0.0, 0.0, 1.0);\n    \n    return M;\n} \n\n//creating offset transformation matrix\nmat3 moveMat(float offsetX, float offsetY)\n{\n \tmat3 M;\n    M[0] = vec3(1.0, 0.0, 0.0);\n    M[1] = vec3(0.0, 1.0, 0.0);\n    M[2] = vec3(offsetX, offsetY, 1.0);\n    \n    return M;\n}  \n\nfloat drawPoint(vec2 uv, vec3 point, mat3 transform)\n{\n    float pixelSize = fwidth(uv.x);\n    \n    //apply transformation to the point\n    point = transform * point;\n    \n    return smoothstep(POINT_SIZE * pixelSize, \n                      POINT_SIZE * pixelSize - pixelSize * 2.0, \n                      distance(uv, point.xy));\n}\n\nfloat drawTriangle(vec2 uv, vec3 vert1, vec3 vert2, vec3 vert3, mat3 transform)\n{\n    float pixelSize = fwidth(uv.x);\n    \n    //apply matrix transformation to all triangle vertices\n    vert1 = transform * vert1;\n    vert2 = transform * vert2;\n    vert3 = transform * vert3;\n    \n    return smoothstep(pixelSize, -pixelSize, sdTriangle(uv, vert1.xy, vert2.xy, vert3.xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uv = vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 1.0);\n    \n    //uv scale\n    uv *= 5.0;\n\n    //triangle vertices\n    vec3 vert1 = vec3(0.0, 0.0, 1.0);\n    vec3 vert2 = vec3(2.0, 0.0, 1.0);\n    vec3 vert3 = vec3(0.0, 2.0, 1.0);\n    \n    //triangle transformation\n    mat3 transformation = \n        rotationMat(iTime * 10.0) *\n        moveMat(2.0, 0.0) * \n        rotationMat(iTime * 100.0) *\n        scaleMat(1.0, 1.2) *\n        moveMat(-2.0, 0.0);\n    \n    //drawing a triangle\n    float triangle = drawTriangle(uv.xy, vert1, vert2, vert3, transformation);\n    \n    //placing a rotating point as a child of the triangle\n    mat3 pointTransformation = \n        transformation * \n        rotationMat(-iTime * 300.0);\n    \n    //drawing the point as a child of the triangle\n    vec3 pointCenter = vec3(0.5, 0.0, 1.0);\n    float point = drawPoint(uv.xy, pointCenter, pointTransformation);\n    \n    //display the triangle and the point with uv grid\n    fragColor = mix(grid(uv.xy), vec4(1.0), triangle);\n    fragColor = mix(fragColor, vec4(0.0, 1.0, 1.0, 0.0), point);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 grid(vec2 uv)\n{\n    float pixelSize = fwidth(uv.x);\n    \n    //OX and OY\n    vec4 mainAxes = vec4(0.5, 1.0, 0.5, 0.0) * smoothstep(pixelSize * 3.0, 0.0, abs(uv.x)) \n        + vec4(1.0, 0.5, 0.5, 0.0) * smoothstep(pixelSize * 3.0, 0.0, abs(uv.y));\n    \n    uv = fract(uv + 0.5) - 0.5;\n    \n    //applying grid\n    vec4 result = vec4(0.5, 1.0, 0.5, 0.0) * smoothstep(pixelSize * 2.0, 0.0, abs(uv.x)) \n        + vec4(1.0, 0.5, 0.5, 0.0) * smoothstep(pixelSize * 2.0, 0.0, abs(uv.y))\n        + mainAxes;\n    \n    return result * 0.5;\n}\n\n//Triangle 2D SDF from iq shader:\n//https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}","name":"Common","description":"","type":"common"}]}