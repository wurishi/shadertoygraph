{"ver":"0.1","info":{"id":"3sdcWH","date":"1601226706","viewed":213,"name":"Basic : Random Rectangle Tiling","username":"Gijs","description":"Randomized rectangle tiling. Inspired by https://www.shadertoy.com/view/Ws3GRs but the implementation is different. This picture should explain the method https://imgur.com/fSn38WM .","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["random","rectangle","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const bool SHOW_GRID = false;\n\n\n//hash in [0,1]\nfloat hash(vec2 p){\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n//returns the min- and max-corners of the rectangle of the crossing 'c'\nvec4 crossingToRectangle(vec2 c){\n    vec4 d = vec4(\n        hash(c + vec2(-1,-1)), \n        hash(c + vec2( 0,-1)), \n        hash(c + vec2( 0, 0)), \n    \thash(c + vec2(-1, 0))\n    );\n\n    // orientation of this crossing\n    int o = int(c.x+c.y) & 1;\n    if(o==1) d = d.wxyz;\n    \n    return d + vec4(c-1.,c);\n}\n\n//find the crossing of the rectangle in which the point 'p' lays\nvec2 getCrossing(vec2 p){\n    \n    // the cell coordinate corresponding to p\n    vec2 i = floor(p);\n    \n    // the coordinates of p relative to its cell\n    vec2 f = p - i;\n    \n    // this variable will tell us the coordinate of the crossing relative to the cell coordinate\n    vec2 c = vec2(0);\n    \n    // orientation of this cell\n    int o = int(i.x+i.y) & 1;\n    // if o=0 then u=1 and vice versa\n    int u = o ^ 1;\n    // on which side of the line in this cell is the current point 'p'\n    bool s = f[o]>hash(i);\n\n    // magic\n    if(s) c[o] = 1.;\n    vec2 n = i;\n    n[o] += s ? 1. : -1.;\n    if(f[u]>hash(n)) c[u] = 1.;\n  \n    return i+c;\n}\n\n//gets the rectangle in which the point 'p' lays\nvec4 getRectangle(vec2 p){\n    return crossingToRectangle(getCrossing(p));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord*.02 + iTime*0.5;\n    \n    vec4 r = getRectangle(p);\n    vec2 mi = r.xy; //min corner\n    vec2 ma = r.zw; //max corner\n    \n    float dmi = min(abs(p-mi).x,abs(p-mi).y); //distance to min corner\n    float dma = min(abs(p-ma).x,abs(p-ma).y); //distance to max corner\n    float d = min(dmi, dma);\n    fragColor = vec4(smoothstep(0.04, 0.02, d));\n         \n    if(SHOW_GRID){\n    \tvec2 f = fract(p);\n        float d = min(f.x, f.y);\n        fragColor = mix(\n            fragColor,\n            vec4(1,0,0, 1),\n            smoothstep(0.04, 0.03, d)\n        );\n    }\n \n}","name":"Image","description":"","type":"image"}]}