{"ver":"0.1","info":{"id":"4tyBz3","date":"1543315153","viewed":230,"name":"2D Light Renderer 2018","username":"pixartist","description":"Have been fiddling with this for a while. Not perfect, but quite okay, and much better performance than my early attempts.\n\nEdit: Still experimenting","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["2d","light","renderer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/** \nDon't use this commercially without my permission\ncontact me @ pixartist.de (at) gmail.com\nto change lights & triangles, go to line ~105\n**/\nconst float PI = 3.14159265359;\nconst float TAU = 2. * PI;\nconst float aniSpeed = .8;\nstruct Line\n{\n    vec2 a;\n   \tvec2 b;\n    vec2 d;\n    float l;\n};\nstruct Triangle\n{\n    vec2 p[3];\n};\nstruct Light\n{\n    vec2 o;\n    float r;\n    vec3 c;\n};\nstruct Slice\n{\n    float start;\n    float end;\n    float delta;\n    bool crossPI;\n};\nstruct LineCircleIntersect\n{\n    bool fw_hit;\n    vec2 fw_point;\n    float fw_n;\n    bool bw_hit;\n    vec2 bw_point;\n    float bw_n;\n};\nstruct Ray\n{\n    vec2 o;\n    vec2 d;\n};\nLine lineAB(vec2 a, vec2 b)\n{\n    Line l;\n    l.a = a;\n    l.b = b;\n    l.d = normalize(b-a);\n    l.l = distance(a,b);\n    return l;\n}\nSlice fromAngles(float a, float b)\n{\n    Slice slice;\n    if(a > b)\n    {\n        float tmp = a;\n        a = b;\n        b = tmp;\n    }\n    slice.start = a;\n    slice.end = b;\n    slice.delta = b-a;\n    if(slice.delta > PI)\n    {\n       \tfloat tmp = slice.start;\n      \tslice.start = slice.end;\n        slice.end = tmp;\n       \tslice.delta = -(slice.delta-TAU);\n       \tslice.crossPI = true;\n    }\n    else\n    {\n        slice.crossPI = false;\n    }\n    return slice;\n}\nSlice fromVectors(vec2 p, vec2 a, vec2 b)\n{\n    vec2 d1 = a-p;\n    vec2 d2 = b-p;\n    return fromAngles(atan(d1.y, d1.x), atan(d2.y, d2.x));\n}\nTriangle triangle(float x1, float y1, float x2, float y2, float x3, float y3)\n{\n    Triangle t;\n    t.p[0] = vec2(x1,y1);\n    t.p[1] = vec2(x2, y2);\n    t.p[2] = vec2(x3, y3);\n    return t;\n}\nLight light(vec2 o, float r, vec3 c)\n{\n    Light l;\n    l.o = o;\n    l.r = r;\n    l.c = c;\n    return l;\n}\n/**\n\nChanges these to modify the layout \n\n**/\nTriangle[3] getTriangles()\n{\n    Triangle[3] t;\n    t[0] = triangle(200., 280., 300., 270., 250., 440.);\n    t[1] = triangle(500., 80., 600., 140., 450., 240.);\n    t[2] = triangle(200., 80., 300., 140., 250., 240.);\n    return t;\n}\nLight[3] getLights()\n{\n    Light[3] l;\n    l[0] = light(vec2(330.+ sin(iTime * 0.3 * aniSpeed) * 250., 290.+ sin(iTime * 0.4 * aniSpeed) * 150.), 2., vec3(7.0, 1.0, 1.0));\n    l[1] = light(vec2(330.+ sin(iTime * 0.5 * aniSpeed) * 250., 290.+ sin(iTime * 0.233 * aniSpeed) * 150.), 10., vec3(1.0, 7.0, 1.0));\n    l[2] = light(vec2(330.+ sin(iTime * 0.25 * aniSpeed) * 250., 290.+ sin(iTime * 0.341 * aniSpeed) * 150.), 30., vec3(1.0, 1.0, 7.0));\n    return l;\n}\nRay rayFromLine(Line l)\n{\n    Ray r;\n    r.o = l.a;\n    r.d = l.d;\n    return r;\n}\nfloat projectExtensionOnRay(vec2 p, Ray r)\n{\n    return dot(p - r.o, r.d);\n}\nLineCircleIntersect intersectRayCircle(Ray ray, Light cr)\n{\n    LineCircleIntersect result;\n    result.fw_hit = false;\n    result.bw_hit = false;\n    \n    vec2 la = ray.o - cr.o;\n    vec2 lb = la-ray.d;\n    vec2 d = -ray.d;\n    const float l2 = 1.0;\n    float D = la.x * lb.y - lb.x * la.y;\n    \n    float s = cr.r * cr.r * l2 - D * D;\n    if(s < 0.0)\n        return result;\n\n    s = sqrt(s);\n    vec2 center = D * vec2(d.y, -d.x);\n    vec2 offset = vec2(sign(d.y) * d.x * s, abs(d.y) * s);\n    if(s >= 0.0)\n    {\n        result.fw_hit = true;\n        result.fw_point =  cr.o + (center + offset) / l2;\n    }\n    if(s > 0.0)\n    {\n        result.bw_hit = true;\n        result.bw_point =  cr.o + (center - offset) / l2;\n    }\n    return result;\n}\nLineCircleIntersect intersectLineCircle(Line l, Light cr)\n{\n    \n    Ray r = rayFromLine(l);\n    LineCircleIntersect result = intersectRayCircle(r, cr);\n    if(result.fw_hit)\n    {\n        result.fw_n = projectExtensionOnRay(result.fw_point, r);\n        if(result.fw_n < 0.0 || result.fw_n > l.l)\n        {\n            result.fw_hit = false;\n        }\n    }\n    if(result.bw_hit)\n    {\n        result.bw_n = projectExtensionOnRay(result.bw_point, r);\n        if(result.bw_n < 0.0 || result.bw_n > l.l)\n        {\n            result.bw_hit = false;\n        }\n    }\n    return result;\n}\nvec2 closestPointOnLine(vec2 p, Line l)\n{\n    float d = dot(p-l.a, normalize(l.b-l.a));\n    d = clamp(d, 0.0, distance(l.b, l.a));\n    return l.a + l.d * d;\n}\nfloat distanceToLine(vec2 p, Line l)\n{\n    return distance(p, closestPointOnLine(p, l));\n}\nfloat angleMinSigned(float a,float b)\n{\n    return atan(sin(b-a), cos(b-a));\n}\nbool isWithin(Slice s, float angle, out float amount)\n{\n    amount = angleMinSigned(s.start, angle);\n    return amount > 0.0 && amount < s.delta;\n}\nfloat overlap(Slice a, Slice b)\n{\n    float j,k;\n    bool w1 = isWithin(a, b.start, j);\n    bool w2 = isWithin(a, b.end, k);\n    if(w1 && w2)\n    {\n        return 1.0;\n    }\n    else if(w1)\n    {\n        return (a.delta-j)/b.delta;\n    }\n    else if(w2)\n    {\n        return k/b.delta;\n    }\n\n    \n    return 0.0;\n}\nbool withinTriangle(vec2 p, Triangle t)\n{\n    vec2 p1 = t.p[0];\n    vec2 p2 = t.p[1];\n    vec2 p3 = t.p[2];\n    float A = ((p2.y - p3.y)*(p.x - p3.x) + (p3.x - p2.x)*(p.y - p3.y)) /\n        ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));\n    float B = ((p3.y - p1.y)*(p.x - p3.x) + (p1.x - p3.x)*(p.y - p3.y)) /\n        ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));\n    float C = 1.-A-B;\n    if(A>1.)\n        A=1.-A;\n    if(B>1.)\n        B=1.-B;\n    if(C>1.)\n        C=1.-C;\n    float px = 1.0 / iResolution.x;\n    //return min(min(c01(px, A), c01(px, B)), c01(px, C));\n    return A >= 0. && A <= 1. && B >= 0. && B <= 1. && C >= 0. && C <= 1.;\n}\nfloat lineObstruction(vec2 p, Line obstructor, Light light)\n{\n    LineCircleIntersect is = intersectLineCircle(obstructor, light);\n    vec2 vl = light.o - p;\n    vl = normalize(vec2(-vl.y, vl.x));\n    vec2 p1 = light.o - vl * light.r;\n    vec2 p2 = light.o + vl * light.r;\n    \n    light.o = (p1+p2) * .5;\n    light.r = distance(p1,p2) * .5;\n    vec2 d1 = obstructor.a - p;\n    vec2 d2 = obstructor.b - p;\n    vec2 d3 = light.o - p;\n    vec2 lp = vec2(-obstructor.d.y, obstructor.d.x);\n    vec2 lm = .5 * (obstructor.a + obstructor.b);\n\tif(sign(dot(lp, light.o - lm)) != sign(dot(lp, p - lm)))\n    if(distanceToLine(p, obstructor) < length(d3))\n    {\n        \n        Slice sa = fromVectors(p, obstructor.a, obstructor.b);\n        Slice sb = fromVectors(p, p1, p2);\n        return overlap(sa, sb);\n    }\n    return 0.0;\n}\n\nfloat triangleObstruction(vec2 p, Triangle t, Light l)\n{\n    if(withinTriangle(l.o, t))\n    \treturn 0.0;\n    float light = 1.0;\n    for(int i = 0; i < 3; i++)\n    {    \t\n        float v = lineObstruction(p, lineAB(t.p[i], t.p[(i+1)%3]), l);\n\t\tlight = min(light, 1.-v);\n    }\n    return max(.0, light);\n}\nfloat c01(float p, float v)\n{\n    return 1. - smoothstep(.5-p, .5, abs(.5-v));\n}\n\n\nvec3 render(vec2 p)\n{\n    vec3 result = vec3(0.);\n    Triangle[] triangles = getTriangles();\n    Light[] lights = getLights();\n    for(int l = 0; l < lights.length(); l++)\n    {\n        float mo = 1.0;\n        for(int t = 0; t < triangles.length(); t++)\n        {\n            bool c = withinTriangle(p, triangles[t]);\n            if(!c)\n            {\n                mo = min(mo, triangleObstruction(p, triangles[t], lights[l]));\n            }\n            else\n            {\n                return vec3(.2);\n            }\n        }\n        float d = sqrt(max(1.0, distance(p, lights[l].o) - lights[l].r));\n        result += lights[l].c * mo / d;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 800.0;\n    float f = scale / iResolution.x;\n    fragColor = vec4(render(fragCoord * f),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}