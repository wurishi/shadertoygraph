{"ver":"0.1","info":{"id":"cldyDj","date":"1699656728","viewed":31,"name":"Projet Synthèse Image","username":"RyuGaro","description":"Raytracing pour l'UE d'Image M1","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Box{\n    vec3 boxMin;\n    vec3 boxMax;\n    int i;\n};\n\nstruct Capsule{\n    vec3 a;\n    vec3 b;\n    vec3 dir;\n    float r;\n    int i;\n};\n\nstruct Cylinder{\n    vec3 a;\n    vec3 b;\n    vec3 dir;\n    vec3 r;\n    int i;\n};\n\nstruct Ellipse{\n    vec3 c;\n    vec3 e; // e(a demi grand axe, b demi petit, c demi distance focale)\n    int i;\n};\n\nstruct Tore{\n    float r;\n    float R;\n    int i;\n};\n\nstruct Material{\n    vec3 diffuse;\n    vec3 specular;\n    vec3 ambient;\n    vec3 reflectionColor; // Couleur de réflexion\n    float reflectionStrength; // Force de réflexion (0.0 pour aucune réflexion, 1.0 pour une réflexion totale)\n};\n\nMaterial normalMaterial(vec3 diff, vec3 spec, vec3 amb){\n    Material mat;\n    mat.diffuse = diff;\n    mat.specular = spec;\n    mat.ambient = amb;\n    mat.reflectionColor = vec3(0.0);\n    mat.reflectionStrength = 0.0;\n    return mat;\n}\n\nMaterial reflectionMaterial(vec3 diff, vec3 spec, vec3 amb, vec3 reflColor, float reflStrength){\n    Material mat;\n    mat.diffuse = diff;\n    mat.specular = spec;\n    mat.ambient = amb;\n    mat.reflectionColor = reflColor;\n    mat.reflectionStrength = reflStrength;\n    return mat;\n}\n\n\nstruct Scene{\n    Sphere spheres[100];\n    int nb_spheres;\n    Plane planes[100];\n    int nb_planes;\n    Ellipse ellipses[100];\n    int nb_ellipses;\n    Cylinder cylinders[100];\n    int nb_cylinders;\n    Capsule capsules[100];\n    int nb_capsules;\n    Box boxes[100];\n    int nb_boxes;\n    Tore tores[100];\n    int nb_tores;\n    vec3[100] lightPositions;\n    int nb_lights;\n};\n\nScene scene;\n\nmat4 Translate(vec3 tr){\n    mat4 translate_matrix = mat4( 1.0   , 0.0   , 0.0   , 0.0,\n                                  0.0   , 1.0   , 0.0   , 0.0,\n                                  0.0   , 0.0   , 1.0   , 0.0,\n                                  tr.x   , tr.y   , tr.z   , 1.0 );\n    return translate_matrix;\n}\n\nmat4 Rotation(vec3 rot, float theta){\n    float s = sin(theta);\n    float c = cos(theta);\n    float compc = 1.-cos(theta);\n    \n    mat4 rotation_matrix = mat4(rot.x*rot.x*compc+c,       rot.x*rot.y*compc-s*rot.z, rot.x*rot.z*compc+s*rot.y, 0.0,\n                                rot.x*rot.y*compc+s*rot.z, rot.y*rot.y*compc+c,       rot.y*rot.z*compc-s*rot.x, 0.0,\n                                rot.x*rot.z*compc-s*rot.y, rot.y*rot.z*compc+s*rot.x, rot.z*rot.z*compc+c,       0.0,\n                                0.0,                       0.0,                       0.0,                       1.0);\n    return rotation_matrix;\n}\n\nvoid RotateCylinder(out Cylinder cyl, vec3 rot, float angle){\n    // Translation du cylindre pour qu'il soit centré autour de l'origine\n    vec3 center = (cyl.b + cyl.a) / 2.0;\n    vec3 newa = cyl.a - center;\n    vec3 newb = cyl.b - center;\n\n    // Rotation dans l'espace local\n    mat4 Rot = Rotation(rot, angle);\n    vec3 newDirA = (Rot * vec4(newa, 0.0)).xyz;\n    vec3 newDirB = (Rot * vec4(newb, 0.0)).xyz;\n\n    // Retranslation pour ramener le cylindre à sa position d'origine\n    newa = newDirA + center;\n    newb = newDirB + center;\n\n    cyl =  Cylinder(newa, newb, newDirA, cyl.r, cyl.i);\n}\n\nvoid RotateCapsule(out Capsule cap, vec3 rot, float angle){\n    // Translation du cylindre pour qu'il soit centré autour de l'origine\n    vec3 center = (cap.b + cap.a) / 2.0;\n    vec3 newa = cap.a - center;\n    vec3 newb = cap.b - center;\n\n    // Rotation dans l'espace local\n    mat4 Rot = Rotation(rot, angle);\n    vec3 newDirA = (Rot * vec4(newa, 0.0)).xyz;\n    vec3 newDirB = (Rot * vec4(newb, 0.0)).xyz;\n\n    // Retranslation pour ramener le cylindre à sa position d'origine\n    newa = newDirA + center;\n    newb = newDirB + center;\n    cap = Capsule(newa, newb, newDirB, cap.r, cap.i);\n}\n\nfloat Checkers(in vec2 p){\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n){\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t){\n    return ray.o+t*ray.d;\n}\n\nvec3 PointRot(vec3 ro, vec3 rd,float t){\n    return ro+t*rd;\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n){\n    vec3 light=normalize(vec3(1,1,1));\n \n    float diff=clamp(dot(n,light),0.,1.);\n    vec3 col=m.diffuse*diff+vec3(.2,.2,.2);\n    return col;\n}\n\nvec3 ColorUniform(Material m, vec3 n){\n    return m.diffuse;\n}\n\nvec3 HSVtoRGB(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 ColorConcentric(vec3 p){\n   // Centre de la texture\n    const vec3 CENTER = vec3(0.0, 0.0, 0.);\n\n    // Distance from the center\n    float distance = length(p - CENTER);\n\n    // Variation with the distance\n    float hue = mod(distance, 1.0); \n    vec3 color = HSVtoRGB(vec3(hue, 1.0, 1.0)); \n    return color;\n}\n\nvec3 ColorRadial(vec3 p){\n    const vec3 AXIS = normalize(vec3(0.0, 0.0, 1.0));\n\n    // Distance from the axis\n    float distanceToAxis = length(cross(p, AXIS));\n\n    // Color variation\n    float hue = distanceToAxis / 2.0;\n\n    float sat = 1.0;\n    float lum = 1.0; \n    \n    vec3 rgbColor = HSVtoRGB(vec3(hue, sat, lum));\n    \n    return rgbColor;\n}\n\nMaterial CheckerboardTexture(vec3 point) {\n    // Définir la taille d'une case du damier\n    float checkerSize = 1.0;\n\n    // Ajouter une petite valeur d'epsilon aux coordonnées du point\n    float epsilon = 0.1; // Ajustez cette valeur si nécessaire\n    point += epsilon;\n\n    // Calculer les indices de cases en x, y et z en utilisant des valeurs en virgule flottante\n    float xIndex = floor(point.x / checkerSize);\n    float yIndex = floor(point.y / checkerSize);\n    float zIndex = floor(point.z / checkerSize);\n\n    vec3 diff, spec, amb;\n    amb = vec3(0.);\n\n    // Alternance des cases diffuses et spéculaires en fonction des indices\n    if ((int(xIndex) + int(yIndex) + int(zIndex))%2== 0) {\n        // Case diffuse\n        diff = vec3(0.8, 0.5, 0.3); \n        spec = vec3(0.1, 0.1, 0.1); \n    } else {\n        // Case spéculaire\n        diff = vec3(0.1, 0.1, 0.1);\n        spec = vec3(0.2, 0.7, 0.8); \n    }\n\n    return normalMaterial(diff, spec, amb);\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i){\n    switch(i){\n        case 0:{                                                        // CHECKBOARD\n            return CheckerboardTexture(p);\n        }\n        case 1: return normalMaterial(vec3(.4,.0,.4),vec3(.2),vec3(.1));      // NORMAL VIOLET\n        case 3: return normalMaterial(ColorConcentric(p),vec3(.0),vec3(.0));  // CONCENTRIC\n        case 4: return normalMaterial(ColorRadial(p),vec3(.2),vec3(.1));      // RADIAL\n        case 5: return normalMaterial(vec3(.8,.8,.8),vec3(.0),vec3(.0));      // UNIFORM\n        case 6: return normalMaterial(vec3(.47,.15,.11),vec3(.1),vec3(.0));   // EARTH\n        case 7: return normalMaterial(vec3(.2,.5,.3),vec3(.0),vec3(.0));      // UNIFORM GREEN\n        case 8: return normalMaterial(vec3(.2,.2,.7),vec3(.0),vec3(.0));      // UNIFORM BLUE\n        case 9: return normalMaterial(vec3(.8,.6,.2),vec3(.0),vec3(.0));      // UNIFORM ORANGE\n        case 10: return reflectionMaterial(vec3(.8,.8,.8),vec3(.0),vec3(.0),vec3(.8,.8,.8),1.0); // REFLECTION\n        default: return normalMaterial(vec3(0),vec3(0),vec3(0));\n    }\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph, out Hit x){\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x){\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),pl.i);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectEllipse(Ray ray, Ellipse e, vec3 rot, float angle, out Hit x) {\n    mat4 Rot = Rotation(normalize(rot), angle);\n    mat4 inv = inverse(Rot);\n    vec3 rotCenter = (inv * vec4(e.c, 1.0)).xyz;\n    vec3 rdd = (inv*vec4(ray.d,0.0)).xyz;\n    vec3 roo = (inv*vec4(ray.o,1.0)).xyz;\n    vec3 oc=roo-rotCenter;\n    float a = dot(rdd/e.e, rdd/e.e);\n    float b = 2.*dot(oc/e.e, rdd/e.e);\n    float c = dot(oc/e.e, oc/e.e) - 1.;\n    float d = b*b-4.*a*c;\n    \n    if(d>0.)\n    {\n        float t=min((-b-sqrt(d))/(2.*a), (-b+sqrt(d))/(2.*a));\n        if(t>0.)\n        {\n            vec3 p=PointRot(roo,rdd,t);            \n            x=Hit(t,normalize((Rot*vec4((p-rotCenter),0.0)).xyz), e.i);\n            return true;\n        }\n    }\n    return false;   \n}\n\nbool IntersectTruncatedCylinder(Ray ray, Cylinder cyl, out Hit x){\n    float d2 = dot(ray.d, ray.d);\n    vec3 u = normalize(cyl.dir);\n    vec3 oa = ray.o - cyl.a;\n    float a = d2 - dot(dot(ray.d, u), dot(ray.d, u));\n    float b = 2.0 * (dot(oa, ray.d) - dot(oa, u) * dot(ray.d, u));\n    float c = dot(oa, oa) - (dot(dot(oa, u), dot(oa, u))) - (dot(cyl.r, cyl.r));\n\n    float delta = b * b - 4.0 * a * c;\n    if (delta > 0.0) {\n        float t1 = (-b - sqrt(delta)) / (2.0 * a);\n        float t2 = (-b + sqrt(delta)) / (2.0 * a);\n\n        float t = min(t1, t2);\n\n        // Vérifier si l'intersection est à l'intérieur du cylindre tronqué\n        vec3 p = Point(ray, t);\n        float height = dot(p - cyl.b, u);\n        if (t > 0.0 && height >= 0.0 && height <= length(cyl.b-cyl.a)) {\n            x = Hit(t, normalize(p - cyl.a - dot(p - cyl.a, u) * u), cyl.i);\n            return true;\n        }\n    }\n\n    // Intersections avec les disques tronqués aux extrémités du cylindre tronqué\n    float tTop = (dot(cyl.b - ray.o, u)) / dot(ray.d, u);\n    float tBottom = (dot(cyl.a - ray.o, u)) / dot(ray.d, u);\n\n    vec3 pTop = Point(ray, tTop);\n    vec3 pBottom = Point(ray, tBottom);\n\n    bool hitTop = false;\n    bool hitBottom = false;\n\n    if (tTop > 0.0 && length(pTop - cyl.b) <= length(cyl.r)) {\n        x = Hit(tTop, normalize(cyl.b - cyl.a), cyl.i);\n        hitTop = true;\n        if (tBottom > 0.0 && length(pBottom - cyl.a) <= length(cyl.r) && tTop > tBottom) {\n            x = Hit(tBottom, normalize(cyl.a - cyl.b), cyl.i);\n        }\n        return true;\n    }\n    if (tBottom > 0.0 && length(pBottom - cyl.a) <= length(cyl.r)) {\n        x = Hit(tBottom, normalize(cyl.a - cyl.b), cyl.i);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x){\n    Hit hitTop, hitBottom;\n    bool hitTopSphere, hitBottomSphere;\n    \n    float d2 = dot(ray.d, ray.d);\n    vec3 u = normalize(cap.dir);\n    vec3 oa = ray.o - cap.a;\n    float a = d2 - dot(dot(ray.d, u), dot(ray.d, u));\n    float b = 2.0 * (dot(oa, ray.d) - dot(oa, u) * dot(ray.d, u));\n    float c = dot(oa, oa) - (dot(dot(oa, u), dot(oa, u))) - (cap.r * cap.r);\n    float delta = b * b - 4.0 * a * c;\n    if (delta > 0.0) {\n        float t1 = (-b - sqrt(delta)) / (2.0 * a);\n        float t2 = (-b + sqrt(delta)) / (2.0 * a);\n\n        float t = min(t1, t2);\n\n        // Vérifier si l'intersection est à l'intérieur du cylindre tronqué\n        vec3 p = Point(ray, t);\n        float height = dot(p - cap.a, u);\n        if (t > 0.0 && height >= 0.0 && height <= length(cap.b-cap.a)) {\n            x = Hit(t, normalize(p - cap.a - dot(p - cap.a, u) * u), cap.i);\n            return true;\n        }\n        vec3 captb = cap.a;\n        bool comp = dot(p,cap.dir) < dot(captb,cap.dir);\n        if(height>length(cap.b-cap.a)){\n            oa = ray.o-cap.b;\n            captb = cap.b;\n            comp = dot(p,cap.dir) > dot(captb,cap.dir);\n        }\n        \n        b=dot(oa, ray.d);\n        c=dot(oa,oa)-cap.r*cap.r;\n        delta=b*b-c;\n        if (delta >0.){\n            float t = -b-sqrt(delta);\n            if (t > 0.)\n            {\n                vec3 p = Point(ray, t);\n                if (comp){\n                    x=Hit(t,normalize(p-captb),cap.i);\n                    return true;\n                }\n            }  \n        }\n    }\n    return false;\n}\n\nbool IntersectBox(Ray ray, Box box, vec3 rot, float angle, out Hit x)\n{\n    mat4 Rot = Rotation(normalize(rot), angle);\n    mat4 inv = inverse(Rot);\n    vec3 center =(box.boxMax-box.boxMin)/2.+box.boxMin;\n    vec3 rotCenter = (inv * vec4(center, 1.0)).xyz;\n    \n    vec3 Mm = (box.boxMax-box.boxMin)/2.;\n    vec3 newMin = rotCenter-Mm;\n    vec3 newMax = rotCenter+Mm;\n    \n    // ray to box\n    vec3 rdd = (inv*vec4(ray.d,0.0)).xyz;\n    vec3 roo = (inv*vec4(ray.o,1.0)).xyz;\n    \n    vec3 invDirection = 1.0 / rdd;\n    vec3 tMin = (newMin - roo) * invDirection;\n    vec3 tMax = (newMax - roo) * invDirection;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    if (tNear > tFar || tFar < 0.0) {\n        return false; \n    }\n    // Calcul normal\n    vec4 normal = (tNear >0.0) ? vec4(tNear,(step(vec3(tNear),t1))) :\n                                vec4(tFar,(step(t2,vec3(tFar))));\n    normal.yzw = normalize((Rot*vec4(-sign(rdd)*normal.yzw,0.0)).xyz);\n    x = Hit(tNear, normal.yzw, 1);\n    return true;\n}\n\nbool IntersectTore(Ray ray, Tore tor, vec3 rot,vec3 trs, float angle, out Hit x){\n    mat4 rt = Rotation(normalize(rot), angle);\n    mat4 tr = Translate(trs);\n    mat4 txi = tr * rt;\n    mat4 txx = inverse(txi);\n    vec3 rdd = (txx*vec4(ray.d,0.0)).xyz;\n    vec3 roo = (txx*vec4(ray.o,1.0)).xyz;\n\n    // vec3 oc = ray.o - tor.ct;\n    // float po = 1.0;\n    float Ra2 = tor.r*tor.r;\n    float ra2 = tor.R*tor.R;\n    // float m = dot(ray.o,ray.o);\n    float m = dot(roo,roo);\n    // float n = dot(ray.o,ray.d);\n    float n = dot(roo,rdd);\n\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n  \n    \n    float k2 = n*n + Ra2*rdd.z*rdd.z + k;\n    float k1 = k*n + Ra2*roo.z*rdd.z;\n    float k0 = k*k + Ra2*roo.z*roo.z - Ra2*ra2;\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if(h<0.0){\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    } else {\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\n    z = c2 - z;\n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4){\n        if(d2<0.0){\n            return false;\n        }\n        d2 = sqrt(d2);\n    } else {\n        if(d1 < 0.0){\n            return false;\n        }\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n    float r = 1e20;\n    h = d1*d1 - z + d2;\n    if(h>0.0){\n        h = sqrt(h);\n        float t1 = -d1 - h - k3;\n        // t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3;\n        // t2 = (po<0.0)?2.0/t2:t2;\n        if(t1>0.0){\n            r=t1;\n        }\n        if(t2>0.0){\n            r=min(r,t2);\n        }\n    }\n    h = d1*d1 - z - d2;\n    if(h>0.0){\n        h=sqrt(h);\n        float t1 = d1 - h - k3;\n        float t2 = d1 + h - k3;\n        if(t1>0.0){\n            r=min(r,t1);\n        }\n        if(t2>0.0){\n            r=min(r,t2);\n        }\n    }\n    // vec3 p = Point(ray,r);\n    vec3 p = roo + r*rdd;\n    vec3 nor = p*(dot(p,p) - tor.R*tor.R - tor.r*tor.r*vec3(1.0,1.0,-1.0));\n    vec4 tmp = vec4(r, nor);\n    tmp.yzw = (txi*vec4(tmp.yzw,0.0)).xyz;\n    x = Hit(tmp.x, normalize(tmp.yzw), tor.i);\n    return true;\n}\n\nvoid addSphereToScene(out Scene sc, Sphere sph){\n    sc.spheres[sc.nb_spheres] = sph;\n    sc.nb_spheres++;\n}\n\nvoid addPlaneToScene(out Scene sc, Plane pl){\n    sc.planes[sc.nb_planes] = pl;\n    sc.nb_planes++;\n}\n\nvoid addEllipseToScene(out Scene sc, Ellipse ell){\n    sc.ellipses[sc.nb_ellipses] = ell;\n    sc.nb_ellipses++;\n}\n\nvoid addCylinderToScene(out Scene sc, Cylinder cyl){\n    sc.cylinders[sc.nb_cylinders] = cyl;\n    sc.nb_cylinders++;\n}\n\nvoid addCapsuleToScene(out Scene sc, Capsule cap){\n    sc.capsules[sc.nb_capsules] = cap;\n    sc.nb_capsules++;\n}\n\nvoid addBoxToScene(out Scene sc, Box box){\n    sc.boxes[sc.nb_boxes] = box;\n    sc.nb_boxes++;\n}\n\nvoid addToreToScene(out Scene sc, Tore tor){\n    sc.tores[sc.nb_tores] = tor;\n    sc.nb_tores++;\n}\n\nvoid addLightToScene(out Scene sc, vec3 position){\n    sc.lightPositions[sc.nb_lights] = position;\n    sc.nb_lights++;\n}\n\nvoid IntersectSpheres(Ray ray, out Hit x, out bool ret, out Hit current){\n    for(int i = 0; i < scene.nb_spheres; i++)\n        if(IntersectSphere(ray,scene.spheres[i],current)&&current.t<x.t){\n            x=current;\n            ret=true;\n        }\n}\n\nvoid IntersectPlanes(Ray ray, out Hit x, out bool ret, out Hit current){\n    for(int i = 0; i < scene.nb_planes; i++)\n        if(IntersectPlane(ray,scene.planes[i],current)&&current.t<x.t){\n            x=current;\n            ret=true;\n        }\n}\n\nvoid IntersectEllipses(Ray ray, out Hit x, out bool ret, out Hit current){\n    for(int i = 0; i < scene.nb_ellipses; i++)\n        if(IntersectEllipse(ray,scene.ellipses[i],vec3(0.0,0.0,1.0),iTime, current)&&current.t<x.t){\n            x = current;\n            ret = true;\n        }\n}\n\nvoid IntersectTruncatedCylinders(Ray ray, out Hit x, out bool ret, out Hit current){\n    for(int i = 0; i < scene.nb_cylinders; i++)\n        if(IntersectTruncatedCylinder(ray,scene.cylinders[i],current)&&current.t<x.t){\n            x=current;\n            ret=true;\n        }\n}\n\nvoid IntersectCapsules(Ray ray, out Hit x, out bool ret, out Hit current){\n    for(int i = 0; i < scene.nb_capsules; i++)\n        if(IntersectCapsule(ray,scene.capsules[i],current)&&current.t<x.t){\n            x=current;\n            ret=true;\n        }\n}\n\nvoid IntersectBoxes(Ray ray, out Hit x, out bool ret, out Hit current){\n    for(int i = 0; i < scene.nb_boxes; i++)\n        if(IntersectBox(ray,scene.boxes[i],vec3(0.0,0.0,1.0),iTime, current)&&current.t<x.t){\n            x = current;\n            ret = true;\n        }\n}\n\nvoid IntersectTore(Ray ray, out Hit x, out bool ret, out Hit current){\n    for(int i = 0; i < scene.nb_tores; i++)\n        if(IntersectTore(ray,scene.tores[i],vec3(-1.0,0.0,0.0), vec3(-2.,-2.,0.), iTime,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n}\n\nvoid RotateScene(out Scene sc, vec3 rot, float angle){\n    for(int i = 0; i < sc.nb_cylinders; i++)\n        RotateCylinder(sc.cylinders[i], rot, angle);\n\n    for(int i = 0; i < sc.nb_capsules; i++)\n        RotateCapsule(sc.capsules[i], rot, angle);\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x){\n    // ROTATION\n    const vec3 ROT = vec3(0.0,0.0,1.0);\n    float angle = iTime;\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n\n    IntersectSpheres(ray, x, ret, current);\n    IntersectPlanes(ray, x, ret, current);\n    IntersectEllipses(ray, x, ret, current);\n    IntersectTruncatedCylinders(ray, x, ret, current);\n    IntersectCapsules(ray, x, ret, current);\n    IntersectBoxes(ray, x, ret, current);\n    IntersectTore(ray, x, ret, current);\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd){\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta){\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\nbool IsInShadow(vec3 p, vec3 lightPosition, Scene scene)\n{\n    vec3 lightDir = normalize(lightPosition - p);\n    Ray shadowRay = Ray(p, lightDir);\n    Hit x;\n    bool idx = Intersect(shadowRay, x);\n    return idx;\n}\n\nvec3 CalculatePhongLighting(vec3 point, Material material, vec3 normal, Scene sc) {\n    vec3 ambient = material.ambient; \n    vec3 diffuse = material.diffuse;\n    vec3 specular = material.specular; \n\n    vec3 totalLighting = vec3(0.0);\n    float epsilon = 0.5; // Add a little shift for precision\n\n    for (int i = 0; i < sc.nb_lights; i++) {\n        vec3 lightDir = normalize(sc.lightPositions[i] - point);\n\n        // corection of precision problem\n        vec3 pointWithEpsilon = point + epsilon * lightDir;\n\n        if(IsInShadow(pointWithEpsilon, sc.lightPositions[i], sc)) {\n            continue; // if in shadow, skip contribution\n        }\n\n        float distance = length(sc.lightPositions[i] - point);\n\n        float coeffLight = 0.25;\n        float attenuation = 1.0 / pow(distance,coeffLight);\n\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        diff *= attenuation;\n\n        // Calculate the reflect direction for the specular component\n        vec3 reflectDir = reflect(-lightDir, normal);\n\n        float specularAttenuation = attenuation;\n\n        // Combine ambient, diffuse, and specular for the current light source\n        vec3 lighting = ambient + diffuse * diff + specular * specularAttenuation;\n\n        totalLighting += lighting;\n    }\n    return totalLighting;\n}\n\nvec3 CalculateReflection(vec3 incidentDir, vec3 normal, vec3 intersectionPoint, Hit intersectionInfo, Scene scene, int maxDepth) {\n    if (maxDepth <= 0) {\n        return vec3(0.0); // Arrêtez les réflexions après un certain nombre d'itérations\n    }\n\n    // Calculer la direction réfléchie\n    vec3 reflectedDir = reflect(incidentDir, normal);\n\n    // Créer un rayon réfléchi à partir du point d'intersection\n    Ray reflectedRay;\n    reflectedRay.o = intersectionPoint;\n    reflectedRay.d = reflectedDir;\n\n    // Recherche d'intersection avec les objets environnants\n    Hit reflectionHit;\n    bool hasReflectionIntersection = Intersect(reflectedRay, reflectionHit);\n\n    // S'il y a une intersection, calculez la couleur de la réflexion récursivement\n    if (hasReflectionIntersection) {\n        Material reflectionMaterial = Texture(intersectionPoint, reflectionHit.i);\n        // Calculez l'éclairage pour le matériau réfléchissant (vous pouvez utiliser CalculatePhongLighting ou autre)\n        vec3 reflectionLighting = CalculatePhongLighting(intersectionPoint, reflectionMaterial, reflectionHit.n, scene);\n\n        // Récursivement calculez la couleur de la réflexion\n        vec3 reflectionColor = reflectionLighting /** CalculateReflection(reflectedDir, reflectionHit.n, intersectionPoint, reflectionHit, scene, maxDepth - 1)*/;\n\n        return reflectionColor;\n    } else {\n        return vec3(0.05); // Pas d'intersection, couleur de fond\n    }\n}\n\n// Rendering\nvec3 Shade(Ray ray){\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx=Intersect(ray,x);\n    \n    if(idx)\n    {\n        vec3 p=Point(ray,x.t);\n        Material mat=Texture(p,x.i);\n    \n        // Calculate Phong lighting\n        vec3 lighting = CalculatePhongLighting(p, mat, x.n, scene);\n\n        // For reflectionMaterial\n        if (mat.reflectionStrength > 0.0) {\n            vec3 reflectionColor = CalculateReflection(ray.d, x.n, p, x, scene, 1);\n            lighting = mix(lighting, reflectionColor, mat.reflectionStrength);\n        }\n\n        return lighting;\n    }\n    else\n        return Background(ray.d);\n    return vec3(0);\n}\n\nvoid initializeScene(out Scene sc){\n    addSphereToScene(sc, Sphere(vec3(5.,-3.,1.5),1.,6));\n    addSphereToScene(sc, Sphere(vec3(0.,0.,4.),1.,10));\n    addPlaneToScene(sc, Plane(vec3(0.,0.,1.),vec3(0.,0.,-2.),0));\n    addEllipseToScene(sc, Ellipse(vec3(-5.,2.,3.0), vec3(2., 3., 1.), 8));\n    addCylinderToScene(sc, Cylinder(vec3(4.,-2.,2), vec3(2.,-2.,2), vec3(1.,0.,0.), vec3(0.,1.,0.),3));\n    addCylinderToScene(sc, Cylinder(vec3(4.,1.,4), vec3(4.,1.,2), vec3(0.,0.,1.), vec3(0.,1.,0.),5));\n    addCapsuleToScene(sc, Capsule(vec3(-1.,3.,1), vec3(-1.,5.,1), vec3(0.,1.,0.), 1.,10));\n    addBoxToScene(sc, Box(vec3(-4.,-4.,4.),vec3(-2.,-2.,2.),9));\n    addToreToScene(sc, Tore(1., 0.5, 9));\n\n    //addLightToScene(sc, vec3(10.,0.,10.));\n    addLightToScene(sc, vec3(0.,5.,7.));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n\n    initializeScene(scene);\n    RotateScene(scene, vec3(0.0,0.0,1.0), iTime);\n    \n    // Render\n    vec3 color=Shade(Ray(ro,rd));\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}