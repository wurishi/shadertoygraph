{"ver":"0.1","info":{"id":"Mt33Wj","date":"1471616552","viewed":733,"name":"Not quite home","username":"xwize","description":"Earth like","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Fast 3D (value) noise by using two cubic-smooth bilinear interpolations in a LUT, \n// which is much faster than its hash based (purely procedural) counterpart.\n//\n// Note that instead of fetching from a grey scale texture twice at an offset of (37,17)\n// pixels, the green channel of the texture is a copy of the red channel offset that amount\n// (thx Dave Hoskins for the suggestion to try this)\n\n#define USE_PROCEDURAL\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\nfloat starFunc(vec3 p)\n{\n\tfloat a = 0.0;\n\tfloat fp = 0.75;\n\tconst int n = 17;\n\tfloat pa = 0.0;\n\t\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tp=abs(p)/dot(p,p)-fp;\n\t\ta+=abs(length(p)-pa);\n\t\tpa=length(p);\n\t}\n\t\n\ta /= float(n);\n\treturn a*a*a*0.625;\n}\n\nvec3 galaxy(vec3 start, vec3 dir)\n{\n    vec3 p = start+dir*100.0;\n    p += vec3(0.0,150.0,0.0);\n   \n    vec3 c = vec3(starFunc(p)) * vec3(1.2,1.0,2.0);\n    p += vec3(10.1,15.2,10.4);\n\tc += vec3(starFunc(p)) * vec3(1.2,1.2,3.0);\n    p += vec3(10.1,15.2,10.5);\n\tc += vec3(starFunc(p)) * vec3(1.2,1.2,1.4);\n    \n\treturn c*0.03;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat cloudForm(vec3 q)\n{\n    q.x += sin(q.y*2.0);\n    q.z += cos(q.x*2.0)*0.3;\n   \n    \n    float f = -0.15 +\n       noise(q) +\n       noise(q*2.0) * 0.5 + \n       noise(q*4.0) * 0.25 +\n       noise(q*8.0) * 0.125 +\n       noise(q*16.0)* 0.05 + \n       noise(q*32.0)* 0.025 +\n       noise(q*64.0)* 0.0125;\n           \n    f = min(pow(abs(f),10.0)*0.5,0.5);\n    return f;\n}\n\nfloat octaves6(vec3 q)\n{\n    float f = 0.0;\n    const int n = 6;\n    for(int i = 0; i < n; ++i)\n    {\n        float ti = pow(2.0,float(i));\n        f += noise(q * ti ) / ti;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5+0.02*iTime;\n\tvec3 ro = vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.7*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\tfloat h = 0.0;\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n    \n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n        float lightIntensity = 4.0;\n        float sunNDL = max(0.0,0.05+0.95*(nor.z));\n        \n        \n\t\t{\n            vec3 oceanBlue = vec3(0.0,0.031,0.11);\n            \n            vec3 q = pos;\n            \n            // Ocean\n            col = oceanBlue;\n            col = col * (0.5 + 0.5*noise(q*4.0));\n\t\t\tcol = col * (0.9 + 0.2*noise(q*8.0));\n            col = col * (0.9 + 0.2*noise(q*16.0));\n            col = col * (0.9 + 0.1*noise(q*32.0));\n            col = col * (0.9 + 0.1*noise(q*64.0));\n            \n            // Land\n            q = m * q * 2.01;\n            \n            float hm = octaves6(q+vec3(137.0)) / 1.5;\n            hm *= hm;\n            \n            f = hm;\n            float landBlend = min(4.0*max(f-0.3,0.0),1.0);\n            \n            float nG = exp(-abs(f-0.4)*20.0);//max(f - 0.4,0.0);\n            float nD = exp(-abs(f-0.6)*20.0);//3.0*max(f - 0.75,0.0);\n            float snowLevel = 0.8+ noise(q*64.0)*0.1;\n            float nS = exp(-abs(f-snowLevel)*20.0);\n            \n            vec3 snow = vec3(0.85,0.85,0.85)/1.85;\n            vec3 desert = vec3(1.5,1.3,1.0)/13.0;\n            vec3 grass = vec3(1.0,1.3,0.5)/12.0;\n            \n\t\t\tfloat normn = nG + nD + nS;\n            \n            float grassD = 1.0 + \n                (noise(q*128.0) + noise(q*64.0) + noise(q*32.0))*0.5;\n            \n            float snowD = 1.0 + (noise(q*vec3(5.0,1.0,1.0)*3.0)\n                + noise(q*16.0)*0.5 + noise(q*64.0)*0.5)*0.25;\n            \n            float desertD = 1.0 + noise(q*vec3(1.0,7.0,1.0)*3.0)\n                + noise(q*32.0)*0.5 + noise(q*64.0)*0.5;\n            \n            vec3 land = (desertD*desert*nD + grassD*grass*nG + snowD*snow*nS)/normn;\n            col = mix(col,land,landBlend);\n            \n            float shore = clamp(1.42*pow(1.0-abs(landBlend-0.4),1.0)-1.2,0.0,1.0);\n            col = mix(col, col + vec3(0.0,0.1,0.05),shore);\n        \n            \n            // Cloud shadows\n            q = m * q * 2.01 + iTime*0.03;\n            vec3 off = vec3(0.1);\n\t\t\tf = cloudForm(q+off);\n            f = 0.2 + 0.8*pow(1.0 - f*0.75,2.0);\n            col = col * f;\n            \n            // Clouds  \n\t\t\tf = cloudForm(q);\n            vec3 cloudCol =\n                vec3(0.2)+\n                0.7*noise(q*2.0) +\n                0.4*noise(q*6.0) +\n                0.2*noise(q*16.0) +\n                0.05*noise(q*32.0) + \n                0.04*noise(q*64.0);\n            cloudCol = (cloudCol + f*0.05)*0.55;\n            float opacityGain = 1.4;\n            float brightnessGain = 0.7;\n            col = mix(col,cloudCol*brightnessGain,min(f*opacityGain,1.0));\n            \n\t\t}\n\t\t\n        // Depth\n        float depth = tmin * 2.7 / 2.0;\n        \n        // Surface Diffuse Lighting\n\t\tcol *= (0.005 + sunNDL * lightIntensity);\n        \n        // Surface Specular\n        vec3 ref = reflect(nor,-vec3(0.0,0.0,-1.0));\n        float sunRDE = max(dot(ref,rd),0.0);\n        float spec = 0.125*pow(sunRDE,512.0);\n        col += spec*mix(col,vec3(1.0),0.05)*sunNDL;\n        \n        // Inner Atmosphere\n        float atm = -max(-1.0,1.1 - depth);\n        vec3 baseAtmCol = vec3(0.0,0.041,0.11)*1.5;\n        col = mix(col,baseAtmCol*sunNDL*lightIntensity,pow(atm,2.0));\n        \n        // Atmosphere glow\n        float glow = 0.0;\n        const int steps = 8;\n        const float di = (128.0/50.0)/float(steps);\n        for(int i = 0; i < steps; ++i)\n        {\n            vec3 px = ro + rd * float(i)*di;\n            vec3 tosc = sc - px;\n            float d = length(tosc);\n            float x = abs(d - 1.0);\n            float n = 0.01+max((-tosc/d).z,0.0);\n            glow += 5.5 * exp(-x*16.0) * n * di;\n        }\n        vec3 glowCol = glow * baseAtmCol;\n        \n\t\t// Background\n        vec3 bckg = galaxy(ro,rd) + glowCol;\n        float isBckg = 1.0-exp( -0.00001*tmin*tmin );\n\t\tcol = mix( col, vec3(bckg), isBckg );\n\t}\n\t\n\tcol = sqrt( col);\n\t\n\t//col *= smoothstep( 0.006, 0.008, abs(p.x) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}