{"ver":"0.1","info":{"id":"lfXyD8","date":"1721062922","viewed":29,"name":"EVO G66","username":"netfetti","description":"multidimensional geometrical ever evolving ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["distortion","shapes","monochrome","geometry","evolving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EVOLUTION_SPEED 0.1\n#define FRACTAL_COMPLEXITY 1.\n#define COLOR_PALETTE 0.8\n#define ZOOM_LEVEL 0.6\n#define SPATIAL_DISTORTION 1.2\n#define ITERATION_DEPTH 5.0\n#define COMPLEX_ITERATIONS 9.0\n\n#define PI 3.14159265359\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 1.5, 1.6), c.y);\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\nfloat sdCrystal(vec3 p, float s) {\n    p = abs(p);\n    float m = max(p.x + p.y, max(p.y + p.z, p.z + p.x));\n    return m - s;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.4, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat scene(vec3 p) {\n    float t = iTime * EVOLUTION_SPEED;\n    \n    p.xy *= rotate2d(t * 0.15);\n    p.yz *= rotate2d(t * 0.05);\n    \n    float d = sdCrystal(p, .5);\n    \n    for (float i = 0.0; i < ITERATION_DEPTH; i++) {\n        float fi = float(i);\n        vec3 offset = vec3(\n            sin(fi * 1.1 + t * COMPLEX_ITERATIONS) * FRACTAL_COMPLEXITY,\n            cos(fi * 1.3 + t * 1.6 * COMPLEX_ITERATIONS) * FRACTAL_COMPLEXITY,\n            sin(fi * 1.7 + t * .1 * COMPLEX_ITERATIONS) * FRACTAL_COMPLEXITY\n        );\n        float shape = sdOctahedron(p - offset, 0.3 + 0.1 * sin(fi + t * COMPLEX_ITERATIONS));\n        d = smin(d, shape, SPATIAL_DISTORTION);\n    }\n    \n    d += sin(p.x * -3.0) * sin(p.y * -3.0) * sin(p.z * -5.0) * 0.5;\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy*scene(p + k.xyy*h) + \n                     k.yyx*scene(p + k.yyx*h) + \n                     k.yxy*scene(p + k.yxy*h) + \n                     k.xxx*scene(p + k.xxx*h));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .8 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    uv *= ZOOM_LEVEL;\n    \n    vec3 ro = vec3(0.3, 1.0, -6.0);\n    vec3 rd = normalize(vec3(uv, 1.4));\n    \n    float t = 0.3;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = scene(p);\n        if(abs(d) < 0.001 || t > 8.0) break;\n        t += d * 0.5;\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 n = calcNormal(p);\n    vec3 light = normalize(vec3(1.9, 1.3, -1.6));\n    \n    float diff = max(dot(n, light), .2);\n    float amb = 0.5 + 0.5 * dot(n, vec3(0.0, 1.0, 0.0));\n    float spec = pow(max(dot(reflect(-light, n), -rd), 0.5), 16.0);\n    float fresnel = pow(1.0 - max(dot(n, -rd), 0.4), 5.0);\n    \n    vec3 color = hsv2rgb(vec3(\n        fract(length(p) * 0.1 + iTime * EVOLUTION_SPEED * 0.1 + COLOR_PALETTE),\n        0.8,\n        diff * 1.1 + 0.033\n    ));\n    \n    color += vec3(1.0) * spec;\n    color += vec3(0.2, 0.3, 0.4) * amb;\n    color += vec3(0.5, 0.7, 1.0) * fresnel * 0.5;\n    \n    color = mix(color, vec3(0.0), 1.0 - exp(-0.05 * t));\n    \n    // Texture blending (optional, using iChannel0)\n    vec2 texCoord = fragCoord.xy / iResolution.xy;\n    vec3 texColor = texture(iChannel1, texCoord).rgb;\n    color = mix(color, texColor, .3);\n\n    fragColor = vec4(color, 2.0);\n}\n\n","name":"Image","description":"","type":"image"}]}