{"ver":"0.1","info":{"id":"MfdSD8","date":"1733176559","viewed":41,"name":"Improved Perlin","username":"dema","description":"2D and 3D perlin noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","3dnoise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==========================================================================================\n// hashes\n//==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\nfloat hash3(vec3 p) {\n    const vec3 k = vec3(0.3183099, 0.3678794, 0.5772157);\n    float n = dot(p, vec3(127.1, 311.7, 74.7));\n    return fract(sin(n) * 43758.5453123);\n}\n\n\n//==========================================================================================\n// perlin\n//==========================================================================================\n\nfloat sInterp(float t) {\n\treturn ((6.0*t - 15.0)*t + 10.0)*t*t*t;\n}\n\nfloat perlin2D(vec2 uv, vec2 grid_size, float seed)\n{\n    uv = uv*grid_size;\n    vec2 vseed = vec2(seed);\n    vec2 bl = floor(uv);\n    vec2 tr = ceil(uv);\n    vec2 tl = vec2(floor(uv.x),ceil(uv.y));\n    vec2 br = vec2(ceil(uv.x),floor(uv.y));\n    \n    vec2 vtl = uv-tl;\n    vec2 vbr = uv-br;\n    vec2 vtr = uv-tr;\n    vec2 vbl = uv-bl;\n    \n    vec2 rv[4] = vec2[4](vec2(1.0,1.0),vec2(1.0,-1.0),vec2(-1.0,-1.0),vec2(-1.0,1.0));\n    tl = rv[int(floor(hash1(tl+vseed)*4.0))];\n    br = rv[int(floor(hash1(br+vseed)*4.0))];\n    tr = rv[int(floor(hash1(tr+vseed)*4.0))];\n    bl = rv[int(floor(hash1(bl+vseed)*4.0))];\n    \n    float g1 = dot(tl,vtl);\n    float g2 = dot(tr,vtr);\n    float g3 = dot(bl,vbl);\n    float g4 = dot(br,vbr);\n    \n    float su = sInterp(fract(uv.x));\n    float sv = sInterp(fract(uv.y));\n\n    float x1 = mix(g1,g2,su);\n    float x2 = mix(g3,g4,su);\n    float n  = mix(x2,x1,sv);\n    return (n + 1.0) / 2.0; \n}\n\nfloat perlin3D(vec3 uvw, vec3 grid_size, float seed)\n{\n    uvw = uvw*grid_size;\n    vec3 vseed = vec3(seed);\n    vec3 nbl = floor(uvw);\n    vec3 ntr = vec3(ceil(uvw.x),ceil(uvw.y),floor(uvw.z));\n    vec3 ntl = vec3(floor(uvw.x),ceil(uvw.y),floor(uvw.z));\n    vec3 nbr = vec3(ceil(uvw.x),floor(uvw.y),floor(uvw.z));\n    \n    vec3 fbl = vec3(floor(uvw.x),floor(uvw.y),ceil(uvw.z));\n    vec3 ftr = ceil(uvw);\n    vec3 ftl = vec3(floor(uvw.x),ceil(uvw.y),ceil(uvw.z));\n    vec3 fbr = vec3(ceil(uvw.x),floor(uvw.y),ceil(uvw.z));\n    \n    vec3 vntl = uvw-ntl;\n    vec3 vnbr = uvw-nbr;\n    vec3 vntr = uvw-ntr;\n    vec3 vnbl = uvw-nbl;\n    \n    vec3 vftl = uvw-ftl;\n    vec3 vfbr = uvw-fbr;\n    vec3 vftr = uvw-ftr;\n    vec3 vfbl = uvw-fbl;\n    \n    vec3 rv[8] = vec3[8](vec3(1.0,1.0,1.0),vec3(1.0,-1.0,1.0),vec3(-1.0,-1.0,1.0),vec3(-1.0,1.0,1.0),\n                         vec3(1.0,1.0,-1.0),vec3(1.0,-1.0,-1.0),vec3(-1.0,-1.0,-1.0),vec3(-1.0,1.0,-1.0));\n    ntl = rv[int(floor(hash3(ntl+vseed)*8.0))];\n    nbr = rv[int(floor(hash3(nbr+vseed)*8.0))];\n    ntr = rv[int(floor(hash3(ntr+vseed)*8.0))];\n    nbl = rv[int(floor(hash3(nbl+vseed)*8.0))];\n    \n    ftl = rv[int(floor(hash3(ftl+vseed)*8.0))];\n    fbr = rv[int(floor(hash3(fbr+vseed)*8.0))];\n    ftr = rv[int(floor(hash3(ftr+vseed)*8.0))];\n    fbl = rv[int(floor(hash3(fbl+vseed)*8.0))];\n    \n    float n1 = dot(ntl,vntl);\n    float n2 = dot(ntr,vntr);\n    float n3 = dot(nbl,vnbl);\n    float n4 = dot(nbr,vnbr);\n    \n    float f1 = dot(ftl,vftl);\n    float f2 = dot(ftr,vftr);\n    float f3 = dot(fbl,vfbl);\n    float f4 = dot(fbr,vfbr);\n    \n    float su = sInterp(fract(uvw.x));\n    float sv = sInterp(fract(uvw.y));\n    float sw = sInterp(fract(uvw.z));\n\n    float nx1 = mix(n1,n2,su);\n    float nx2 = mix(n3,n4,su);\n    float nr  = mix(nx2,nx1,sv);\n    \n    float fx1 = mix(f1,f2,su);\n    float fx2 = mix(f3,f4,su);\n    float fr  = mix(fx2,fx1,sv);\n    \n    float r = mix(nr,fr,sw);\n    return (r + 1.0) / 2.0; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float tres = 128.0;\n    float time = mod(0.01*iTime,tres);\n    float col = perlin3D(vec3(uv,time),vec3(4.0*vec2(ar,1.0),tres),4.0);\n    //float col = perlin2D(uv,4.0*vec2(ar,1.0),4.0);\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}