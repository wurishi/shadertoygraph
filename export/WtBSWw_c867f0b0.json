{"ver":"0.1","info":{"id":"WtBSWw","date":"1566049178","viewed":114,"name":"Blue Tunnel","username":"taso69","description":"Blue Tunnel","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","tunnel","raymarch","halftone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\nfloat speed = 5.0;\nvec3 light;\n\nmat2 rotate(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat hash21( vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n\nfloat sdSphere(vec3 pos, float r){\n    return length(pos) - r;\n}\n\nfloat sdCylinder( vec3 pos, vec3 c ){\n  return length(pos.xy-c.xy)-c.z;\n}\n\nfloat sdBox(vec3 pos, vec3 c){\n    vec3 d = abs(pos) - c ;\n    return length(max(d,0.0)) + min(max(max(d.x,d.y),d.z),0.0);\n}\n\nfloat sdBar(vec3 pos, vec3 c){\n    vec2 d = abs(pos.xy) - c.xy;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 matMin(vec2 a, vec2 b){\n    return (a.x < b.x) ? a : b;\n}\n\n\nvec2 map(vec3 pos){\n    vec2 map = vec2(10000.0,-1.0); \n   \n    vec3  p = pos;\n    float outC = sdCylinder(p,vec3(0.0,0.0,4.0));\n    float inC = sdCylinder(p,vec3(0.0,0.0,3.9));\n    p.xy *= rotate(p.z);\n    float mask = sdBar(p,vec3(4.0,3.8,0.0));\n    float d = max(outC, -inC);\n    d = max(d,mask);\n    map = matMin(map,vec2(d,3.0)); \n\n    p = pos;\n    float pOutC = sdCylinder(p,vec3(0.0,0.0,2.0));\n    float pInC = sdCylinder(p,vec3(0.0,0.0,1.95));\n    float cycle = floor(hash21(vec2(floor(pos.z),-floor(pos.z)))*5.0);\n    p.xy *= rotate(cycle);\n    float t = clamp(mod(iTime,cycle) - (cycle-0.5), 0.0, 1.0)/0.5;\n    float rad =  mix(floor(iTime/cycle),floor(iTime/cycle+1.0),t)*PI/2.0;\n    rad = (mod(cycle,2.0)==0.0) ? rad : -rad;\n    p.xy *= rotate(rad);\n    float pMask = sdBar(p,vec3(0.5,3.0,0.0)); \n    pMask = min(pMask,sdBar(p,vec3(3.0,0.5,0.0)));\n    vec3 q = pos;\n    q.z = mod(q.z,2.0) - 1.0;\n    pMask = min(pMask,sdBox(q,vec3(4.0,4.0,0.5)));\n    float pC = max(pOutC,-pInC);\n    pC = max(pC,-pMask);\n    map = matMin(map,vec2(pC,2.0));\n\n    p = pos;\n    float outC2 = -sdCylinder(p,vec3(0.0,0.0,5.0));\n    map = matMin(map,vec2(outC2,4.0));\n    \n    p = mod(pos,2.0)-1.0;\n    float sp = sdSphere(p,0.2);\n    float box = sdBox(p,vec3(0.2));\n    map = matMin(map,vec2(mix(sp,box,sin(iTime)),1.0));\n    return map;\n}\n\n\nvec3 calcNorm(vec3 pos){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(pos + vec3(  d, 0.0, 0.0)).x - map(pos + vec3( -d, 0.0, 0.0)).x,\n        map(pos + vec3(0.0,   d, 0.0)).x - map(pos + vec3(0.0,  -d, 0.0)).x,\n        map(pos + vec3(0.0, 0.0,   d)).x - map(pos + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nvec3 trace(vec3 ro, vec3 rd,int N){\n    vec3 pos;\n    float dist = 0.0;\n    vec2 m;\n    for(int i = 0; i < N; i++){\n        pos = ro + dist*rd;\n        m = map(pos);\n        //https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        dist += min(min((step(0.0,rd.x)-fract(pos.x))/rd.x, \n            (step(0.0,rd.z)-fract(pos.z))/rd.z)+0.01,m.x)*0.75;\n    }\n    return vec3(dist,m);\n}\n\n\nvec3 lighting(vec3 pos, vec3 N,float mat){\n    vec3 col = vec3(0.0);\n    vec3 L = normalize(light - pos);\n\n    float diffuse = clamp(dot(N,L),0.1,1.0);\n    if(mat == 1.0){\n        col += diffuse * vec3(0.01,0.4,0.6);\n    }else if(mat == 2.0){\n        col += diffuse * vec3(0.8);\n    }else if(mat == 3.0){\n        col += diffuse * vec3(0.4);\n    }else if(mat == 4.0){\n        col += diffuse * vec3(0.4,0.4,0.9)*0.8;\n    }\n    return col;\n}\n\nvec3 getCol(vec3 ro,vec3 rd,vec2 uv){\n    light = vec3(0.0,0.0,0.0-iTime*speed);\n    vec3 col = vec3(0.0);\n\n    vec3 pos;\n    vec2 m; \n    \n    vec3 t = trace(ro,rd,128);\n    pos = ro + t.x*rd;\n    if(abs(t.y) < 0.001){\n        vec3 N = calcNorm(pos);\n        vec3 L = normalize(light - pos);\n        col += lighting(pos,N,t.z);\n        float diff = clamp(dot(N,L),0.0,1.0);\n        float f = (sin(uv.x) * 0.5 + 0.5) + (sin(uv.y) * 0.5 + 0.5);//halftone\n        col +=  mix(0.0,f*0.05,diff);\n        \n        vec3 R = normalize(reflect(rd,N));\n        pos += N*0.001;\n        vec3 rT = trace(pos,R,32);\n        pos += rT.x*R; \n        if(abs(rT.y) < 0.001){\n            vec3 rN = calcNorm(pos);\n            col += lighting(pos,rN,rT.z);\n\n            vec3 rR = normalize(reflect(R,rN));\n            pos += rN*0.001;\n            vec3 rrT = trace(pos,rR,32);\n            pos += rrT.x*rR;\n            if(abs(rrT.x)<0.001){\n                vec3 rrN = calcNorm(pos);\n                col += lighting(pos,rrN,rrT.z);\n            }\n        }\n    }\n\n    col += vec3(0.01)*exp(0.15*t.x);\n    col += vec3(0.002,0.02,0.02)*exp(0.5*sin(iTime)*t.x);\n    return col;\n\n}\n\nmat3 cam(vec3 ro, vec3 ta){\n    vec3 cUp = vec3(0.0,1.0,0.0);\n    vec3 cDir = normalize(ta-ro);\n    vec3 cSide = normalize(cross(cDir,cUp));\n    cUp = normalize(cross(cDir,cSide));\n\n    return mat3(cSide,cUp,cDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = fragCoord.xy*2.0 - iResolution.xy;\n    p /= min(iResolution.x,iResolution.y);\n\n    float z = -iTime*speed; \n    vec3 ro = vec3(0.0,0.0,0.0+z);\n    vec3 ta = vec3(3.0*cos(iTime*1.2),-3.0*sin(iTime*0.8),6.0*cos(iTime*0.5)+z);\n    vec3  rd = normalize(vec3(p,1.0)) * cam(ro,ta);\n\n    vec2 uv = fragCoord;\n    vec3 col = getCol(ro,rd,uv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}