{"ver":"0.1","info":{"id":"tsjBW3","date":"1591021825","viewed":183,"name":"Leafy Shapes 2D","username":"spalmer","description":"working on my tiled leaves idea but in 2D where it's easier.\nthink I have the tiling mostly sorted out, but is fairly obvious still, and the animation doesn't look good yet.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["kerning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D fork of Hedges Maze https://shadertoy.com/view/tlyGzG\n\nconst float tSpace = 1.2\n    , lscale = 1. / 8.\n    , pi = acos(-1.)\n    , phi = .5*(sqrt(5.)+1.);\n\nconst vec3 csky = vec3(.0, .1, .4)\n    , cleaf = vec3(.3,.7,.1)\n    , cbranch = vec3(.1,.03,.0);\n\nvoid rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x / phi) * 25314.67283);\n}\n\nfloat hash(vec2 x)\n{\n\treturn rand(dot(x, vec2(7,5)));\n}\n\nfloat dbranch(vec2 q)\n{\n    return length(vec2(q.x, q.y < 0. ? min(0., q.y + 1.) : q.y)) - .03 + .04*min(q.y, 0.);\n}\n\nfloat dshape(vec2 q)\n{\n    return length(q * vec2(.7,1)) - .95;\n}\n\nfloat dleaf(vec2 q)\n{\n    q.x = abs(q.x); // FIXME use smoothabs\n    q.x = q.x + .25;\n    return length(q) - .5;\n}\n\n// q is world coord, o is tiling offset\nvoid gt(vec2 q, vec2 o, inout float r)\n{\n\tvec2 c = floor((q - o) / tSpace + .5); // tile address (center of tile)\n    vec2 w = (c + o) * tSpace;\n\tfloat h = dshape(w*lscale);\n    if (h > .0) return;\n    q = q - w; // local coord\n//    r = min(r, abs(min(abs(q.x), abs(q.y)) - .5*tSpace) - .02); // DEBUG show cell corners\n    float n0 = pow(max(0., mix(sin(.38*iTime), 1., .501)), 2.)\n    , n1 =  hash(c + /*floor*/(9.*(o.x+o.y))) * 12. * pi\n    , n2 =  (.7*c.x+.2*c.y) + 12.1*sin(iTime) * mix(n0, 1., .1);\n    n1 += n0 * .2 * sin(5.*iTime);\n    vec2 m = vec2(cos(n1),sin(n1)) // random dir used for random rotation\n    , j = vec2(cos(n2),sin(n2)) * mix(n0, 1., .3); // for \"wind\" rippling and basic cell offsets //.yx\n    q += (.5*tSpace - .47) * j; //max(0., tSpace-.75) // the leaf is almost up against the edge of the cell, so *any* offset will require kerning with neighbor cells!\n    rot(q, m);\n    float d = dleaf(q); \n    r = min(r, d);\n}\n\nfloat gd(vec2 p)\n{\n\tfloat r = 3e38; //dist2frame(p, 4.25);\n    // if need more density, could use a quincunx pattern or something\n    // if need more variety, could slightly rotate some layers\n    gt(p, vec2(.5*tSpace), r);\n    gt(p, vec2(0), r);  //.yx\n    // random offsets would be better but this is pretty dense and looks ok-ish for now\n    return r;\n}\n\nfloat dbush(vec2 p)\n{\n    return gd(p/lscale)*lscale;\n}\n\nfloat dworld(vec2 q)\n{\n    float dl = dbush  (q)\n        , db = dbranch(q) + .1\n        , ds = dshape (q) * .001 + .001;\n    return min(min(ds, db), dl);\n}\n\n// FIXME need normal for entire world, not just leaves!\nvec2 nworld(vec2 p, float h)\n{\n    // TODO dFdx,dFdy\n    return normalize((vec2(dworld(p + vec2(h,0)), dworld(p + vec2(0,h))) - dworld(p)) / h);\n}\n    \nfloat lighting(vec2 p, float r)\n{\n    float nw = 1e-5;// * r;\n    vec2 n = nworld(p, nw);\n    float ao = 1.; //clamp(1. * dao / oao, 0., 1.);\n    vec2 L = vec2(.7);\n    float nl = dot(L, n);\n    nl = mix(nl, 1., .6);\n    return clamp(nl, 0., 1.);\n}\n\nvec3 draw(vec2 q)\n{\n    float dl = dbush  (q), cl = clamp(.5 - .5 *iResolution.y*dl, 0., 1.)\n        , db = dbranch(q), cb = clamp(.5 - .25*iResolution.y*db, 0., 1.) // tree trunk :)  TODO branches?\n        , ds = dshape (q), cs = clamp(0. -  4.              *ds, 0., 1.) // filler poofball in the interior of dshape as background\n        , dw = dworld (q)\n    , nl = lighting(q, dw)\n        * clamp(.5 + dot(q, vec2(.4)), 0., 1.)\n        ;\n    return mix(mix(mix(\n        csky, .2*cleaf*nl, cs),\n               cbranch*nl, cb), \n       \t\t\t cleaf*nl, cl);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    c.rgb = draw((p+p-r)/r.y);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n\tc.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"}]}