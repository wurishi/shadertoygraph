{"ver":"0.1","info":{"id":"WdB3Wd","date":"1550271483","viewed":589,"name":"Purple Tiles","username":"polymonster","description":"Animating tiles made from a concept background for a game.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from gold noise\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat rand(vec2 coordinate, float seed)\n{\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\nfloat isolate_tile(vec2 uv, vec2 tile_size2, float isox, float isoy)\n{\n    if(uv.x < tile_size2.x * isox || uv.x > tile_size2.x * isox + tile_size2.x)\n        return 0.0;\n    \n    if(uv.y < tile_size2.y * isoy || uv.y > tile_size2.y * isoy + tile_size2.y)\n        return 0.0;\n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 palette[6];\n    palette[0] = vec3(109.0, 31.0, 165.0) / 255.0;\n    palette[1] = vec3(154.0, 71.0, 203.0) / 255.0;\n    palette[2] = vec3(123.0, 39.0, 143.0) / 255.0;\n    palette[3] = vec3(122.0, 74.0, 235.0) / 255.0;\n    palette[4] = vec3(203.0, 163.0, 255.0) / 255.0;\n    palette[5] = vec3(97.0, 37.0, 143.0) / 255.0;\n    \n    vec3 gradient[4];\n    gradient[0] = vec3(37.0, 6.0, 100.0) / 255.0;\n    gradient[1] = vec3(252.0, 194.0, 255.0) / 255.0;\n    gradient[2] = vec3(188.0, 66.0, 208.0) / 255.0;\n    gradient[3] = vec3(165.0, 110.0, 228.0) / 255.0;\n    \n    // tweakables\n    float tile_size = 0.025;\n    float x_offset = 12.0;\n    float y_tiles = 24.0;\n    float centre_width = 16.0;\n    \n    vec2 aspect = iResolution.xy / iResolution.xx;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    // tile mask\n    vec2 tile_size2 = vec2(tile_size, tile_size) / aspect;\n    vec2 mm = mod(uv * aspect, tile_size);\n    vec2 mv = smoothstep(0.0, tile_size, mm);\n    \n    float edge = 0.025;\n    \n    vec2 tile = step(mv, vec2(edge) * aspect);\n    \n    // tile isolate centre\n    for(int i = 0; i < 70; ++i)\n    {        \n        float ep = 0.00001;\n        float xx = floor(rand(vec2(iTime * ep + float(i), iTime * ep + float(i) * 5.0), float(i)) * centre_width);\n        \n    \tfloat yy = floor(rand(vec2(iTime * ep + float(i) * 3.0, iTime * ep + float(i)), float(i)) * y_tiles);\n    \n\t\tcol.rgb += isolate_tile(uv, tile_size2, x_offset + xx, yy);\n    }\n    \n    // tile isolate sides\n    for(int i = 0; i < 25; ++i)\n    {        \n        float ep = 0.000002;\n        float xx = floor(rand(vec2(iTime * ep + float(i), iTime * ep + float(i) * 5.0), float(i)) * 40.0);\n        \n    \tfloat yy = floor(rand(vec2(iTime * ep + float(i) * 3.0, iTime * ep + float(i)), float(i)) * 16.0);\n    \n\t\tcol.rgb += isolate_tile(uv, tile_size2, xx, yy + 4.0);\n    }\n    \n    // tile animation\n    float yanim = mod(floor(iTime * 30.0), 40.0);\n    for(int i = 0; i < 16; ++i)\n    {\n        for(int j = 0; j < 16; ++j)\n    \t{\n            float xx = floor(rand(vec2(float(j), float(j)), 0.0)* 10.0);\n            float yy = mod(yanim + float(i) + float(j) * 2.0, 40.0);\n        \tcol.rgb += isolate_tile(uv, tile_size2, float(j) + 12.0, yy + xx);\n        }\n    }\n     \n    col.rgb *= clamp(1.0 - (tile.x + tile.y), 0.0, 1.0);\n    vec3 inv_tile = clamp(1.0 - col.rgb * 0.1, 0.0, 1.0);\n    \n    if(length(col.rgb) > 0.99)\n    {        \n        float px = floor(uv.x / tile_size2.x);\n        float py = floor(uv.y / tile_size2.y);\n        float rp = mod( floor(rand(vec2(px, py), 0.0) * 126.0), 6.0);\n        \n        col.rgb = vec3(0);\n        \n        for(int pp = 0; pp < 6; ++pp)\n            if(length(rp - float(pp)) < 0.2)\n        \t\tcol.rgb += palette[pp];\n            \n        col.rgb += (mm.x * 2.0 / tile_size2.x + mm.y * 2.0 / tile_size2.y) * 0.1;\n        col.rgb *= 0.8;\n    }\n    \n    // gradient background\n    vec2 ndc = (uv * 2.0 - 1.0);\n    \n    float r = clamp( 1.0 - length(ndc*aspect), 0.0, 1.0);\n    vec2 r2 = clamp( vec2(r + sin(iTime) * 0.2, r + cos(iTime)), 0.0, 1.0); \n    \n    // col.rgb *= 1.0 - vec3(r2.x, r2.y, r) * 1.0 - inv_tile;\n    \n    vec3 bg = mix(gradient[0], gradient[1], r2.x);\n    bg = mix(gradient[2], bg, r2.y);\n    bg = mix(gradient[0], bg, r);\n    bg = mix(bg, gradient[1], max((1.0 - uv.y) * sin(iTime) * 0.7, 0.0));\n    \n    col.rgb += bg * inv_tile;\n    \n    // tile modulate\n    col.rgb *= 1.0 - bg * (1.0 - inv_tile);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}