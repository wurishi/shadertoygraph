{"ver":"0.1","info":{"id":"MtdBzX","date":"1540572836","viewed":100,"name":"Environment Project- Plants","username":"cake7914","description":"Climbing down a tree","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n// ============================\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n\nShape Plants(vec3 c){\n  Shape shape;\n  \n  c.z = repeat(c.z, 2.); // Repeat\n  c.x = abs(c.x)-0.5; // Mirror\n  c.y = abs(c.y)+.5;\n  c.xy *= rot(c.y*0.1+0.5);\n  // Plants\n  vec3 plantOffset = vec3(1.2, 0.1, 0.);\n\n  \t// Trunks\n    //vec4 fColor = vec4(.3, .1, .1, 1.);\n  \tvec4 sColor = vec4(.3, .2, 0.1, 1.);\n    float pattern = cos(sin(c.x*5.)) / cos(sin(c.z*20.));\n    sColor /= pattern;\n  \tfloat stems = fBox(c-plantOffset, vec3(0.1, 1., 0.2));\n  \t\n    // Branches\n    float branches = fBox(c-vec3(1.2, .5, .2), vec3(.075, .075, .8));\n    \n  \t// Leaves\n    float pattern2 = cos(sin(c.x*.8)) / cos(sin(c.z*20.));\n  \tvec4 lColor = vec4(.1, .7, .1, 1.);\n    lColor /= pattern2;\n  \tfloat leaves1 = sphere(c-vec3(1.2, 1.3, 0.), .2);\n    float leaves2 = sphere(c-vec3(1.2, .5, -.75), .2);\n    float leaves3 = sphere(c-vec3(.75, .75, -.1), .2);\n    \n    // Flowers\n    vec4 fColor = vec4(.8, .2, .2, 1.);\n  \t//float flowers1 = sphere(c-vec3(1.2, 1.5, 0.), .1);\n    float flowers2 = sphere(c-vec3(1., .5, -.75), .1);\n    //float flowers3 = sphere(c-vec3(.6, .75, -.1), .1);\n\n  shape.dist = fOpIntersectionRound(shape.dist, stems, .2);  \n  shape.dist = fOpUnionRound(shape.dist, branches, .3);\n  shape.dist = fOpUnionStairs(shape.dist, leaves1, .35, 1.75);\n  shape.dist = fOpUnionStairs(shape.dist, leaves2, .25, 1.75);\n  shape.dist = fOpUnionColumns(shape.dist, leaves3, .2, 5.);\n  //shape.dist = min(shape.dist, flowers1);\n  shape.dist = min(shape.dist, flowers2);\n  //shape.dist = min(shape.dist, flowers3);\n\n\n  c *= cos(c.y*9.+4.);  \n  shape.color = mix(lColor, sColor, mixColors(stems, leaves1, 0.3));      \n  shape.color = mix(lColor, shape.color, mixColors(shape.dist, leaves2, 0.));      \n  shape.color = mix(lColor, shape.color, mixColors(shape.dist, leaves3, 0.));\n  //shape.color = mix(fColor, shape.color, mixColors(shape.dist, flowers1, 0.));\n  shape.color = mix(fColor, shape.color, mixColors(shape.dist, flowers2, 0.));\n  //shape.color = mix(fColor, shape.color, mixColors(shape.dist, flowers3, 0.));\n  \n  \n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape plants = Plants(c);\n  return plants;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n\n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}","name":"Image","description":"","type":"image"}]}