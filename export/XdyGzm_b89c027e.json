{"ver":"0.1","info":{"id":"XdyGzm","date":"1453822456","viewed":152,"name":"brioche","username":"jcolman","description":"Infinite \"Brio\" train set","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarch","train"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------------------------------\n// Jason Colman Jan 2016\n// \"brioche\"\n// Infinite \"Brio\" train set\n//------------------------------------------------------------------------\n\n/*\nThanks for useful info:\nhttp://www.geeks3d.com/20130524/building-worlds-with-distance-functions-in-glsl-raymarching-glslhacker-tutorial-opengl/\nhttp://www.pouet.net/topic.php?which=7931&page=1\n\nBits of this code are copied or adapted from the many excellent\n examples on shadertoy. These ones particularly:\n\nVery well-commented example of sphere:\nhttps://www.shadertoy.com/view/XtXGzM\n\nAlso I found these useful:\nhttps://www.shadertoy.com/view/llfXRf\nhttps://www.shadertoy.com/view/MsX3WN\n*/\n\n#define PI 3.141592653589793\n\n// Initial value of t in ray equation p0 + t (p1 - p0)\n#define START_T 0.0\n\n// Once ray reaches this length, it won't hit anything in \n//  the scene.\n#define TOO_FAR 10.0\n\n// If distance from point to a surface is <= this, we are \n//  close enough to say we have hit it.\n#define CLOSE_ENOUGH 0.01\n\n// Max number of iterations in ray marching loop, will be\n//  interesting to find realistic value for this. Depends on\n//  number of objects in scene, no?\n// From a quick experiment, more than 100 makes no difference\n//  visually, for this example.\n#define MAX_ITERS 100\n\n#define SPEED 1.8\n\n// Colour constants \n#define SKY_COLOUR vec3(0.0, 0.5, 1.0)\n#define WOOD_COLOUR vec3(0.6, 0.6, 0.1)\n#define FLOOR_COLOUR vec3(0.0, 1.0, 0.0)\n#define WHEEL_COLOUR vec3(0.2, 0.2, 0.2)\n#define TREE_COLOUR vec3(0, 0.3, 0)\n\n#define MAT_FLOOR 0\n#define MAT_TRACK 1\n#define MAT_WHEEL 2\n#define MAT_SHINY 3\n#define MAT_TREE  4\n#define MAT_TRAIN 10\n\n#define NUM_TRAIN 8\n\n#define TRACK_PIECE_LEN 200.6\n#define TRACK_PIECE_WIDTH 0.2\n#define TRACK_PIECE_HEIGHT 0.1\n#define TRAIN_ABOVE_TRACK 0.25\n#define WHEEL_HEIGHT   TRAIN_ABOVE_TRACK * 1.2\n#define TRAIN_WIDTH 0.13\n#define TRAIN_HEIGHT 0.2\n#define TRAIN_LEN 0.4\n\n// Non-moveable camera, with this y-pos.\n#define CAM_HEIGHT 1.5\n\n#define LIGHT_DIR normalize(vec3(1.0, 0.8, 0.1))\n\n//------------------------------------------------------------------------\n// Standard distance to sphere function\nfloat distSphere(in vec3 pos, float radius) \n{\n    return length(pos) - radius;\n}\n\n//------------------------------------------------------------------------\n// Box\n// From:\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(in vec3 p, in vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//------------------------------------------------------------------------\n// Cylinder\n// From:\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//------------------------------------------------------------------------\n// Difference between two objects... maybe not use this\nfloat subtract(float a, float b)\n{\n    return max(a, -b);\n}\n\n//------------------------------------------------------------------------\n// Combine distance functions to give distance to a straight piece of \n//  track\nfloat trackPiece1(in vec3 pos)\n{\n    float mainBlock = sdBox(pos + vec3(0, -TRACK_PIECE_HEIGHT, 0), vec3(TRACK_PIECE_WIDTH, TRACK_PIECE_HEIGHT, TRACK_PIECE_LEN)); \n    float groove1 = sdBox(pos + vec3(-0.15, -2.0 * TRACK_PIECE_HEIGHT, 0), vec3(0.02, TRACK_PIECE_HEIGHT * 0.75, TRACK_PIECE_LEN * 1.5));\n    float groove2 = sdBox(pos + vec3( 0.15, -2.0 * TRACK_PIECE_HEIGHT, 0), vec3(0.02, TRACK_PIECE_HEIGHT * 0.75, TRACK_PIECE_LEN * 1.5));\n    float grooveBlock = subtract(subtract(mainBlock, groove1), groove2);\n    return grooveBlock;\n}\n\n//------------------------------------------------------------------------\nfloat train1(in vec3 pos)\n{\n    float mainBlock = sdBox(pos + vec3(0, -TRAIN_HEIGHT - TRAIN_ABOVE_TRACK, 0), vec3(TRAIN_WIDTH, TRAIN_HEIGHT, TRAIN_LEN)); \n    return mainBlock;\n}\n\n//------------------------------------------------------------------------\nfloat wheel1(in vec3 pos, float f)\n{\n    vec3 p = pos + vec3(0.0, -WHEEL_HEIGHT, 0.0);\n    vec3 p2 = vec3(p.y, p.x, p.z); \n    float d = sdCappedCylinder(p2 + vec3(0.0, f, 0.0), vec2(0.1, 0.025));\n    d = min(d, sdCappedCylinder(p2 + vec3(0.0, -0.05, 0.0), vec2(0.15, 0.01)));\n    return d;\n}\n\nfloat wheels(in vec3 pos)\n{\n    float f = sin(iTime * 10.0) * 0.005;\n    return min(wheel1(pos + vec3( 0.2,  f,  0.2), -0.02), \n           min(wheel1(pos + vec3( 0.2, -f, -0.2), -0.02),\n           min(wheel1(pos + vec3(-0.1,  f, -0.2), -0.08),\n               wheel1(pos + vec3(-0.1, -f,  0.2), -0.08))));\n}\n\nfloat shiny1(in vec3 p)\n{\n    p.x *= 2.0; // squashed spheroid\n    float d = distSphere(p, 0.05);\n    return d;\n}\n\nfloat shiny(in vec3 pos)\n{    \n    return min(shiny1(pos + vec3( 0.2, -WHEEL_HEIGHT,  0.2)),\n           min(shiny1(pos + vec3(-0.2, -WHEEL_HEIGHT,  0.2)),\n           min(shiny1(pos + vec3(-0.2, -WHEEL_HEIGHT, -0.2)),\n               shiny1(pos + vec3( 0.2, -WHEEL_HEIGHT, -0.2)))));\n}\n\nfloat tree(in vec3 p)\n{\n    p.y *= 0.3; // spheroid\n    float d = distSphere(p, 0.5);\n    return d;\n}\n\n//------------------------------------------------------------------------\n// Return shortest distance from pos to an object in the scene.\n// Return type is a { distance, material ID } pair\nvec2 calcDist(in vec3 pos) \n{\n    vec3 pTree = pos;\n    \n    // Move forward\n    pos.z -= iTime * SPEED;\n    \n    // Track curve angle\n    float theta = sin(pos.z * 0.05 + iTime * 0.05) * 0.5;\n    \n    //float s = sin(theta);\n    float c = cos(theta);\n\n    // Make track curve - without this, track is straight\n    pos = pos + vec3(100.0 * c - 95.0, 0.0, 0.0);\n    \n    int material = MAT_FLOOR;\n        \n    // Distance to floor\n    float dist = pos.y;\n    \n    // Trees\n    float dTree = tree(mod(pTree, vec3(0, 0, 60.0)) - vec3(10.0, 0, 2.0));\n    dTree = min(dTree, tree(mod(pTree, vec3(0, 0, 70.0)) - vec3(-10.0, 0, 2.0)));\n    if (dTree < dist)\n    {\n        dist = dTree;\n        material = MAT_TREE;\n    }\n    \n    // Track\n    float dist1 = trackPiece1(pos);\n    \n    if (dist1 < dist)\n    {\n        dist = dist1;\n        material = MAT_TRACK;\n    }\n    \n    // Train\n    for (int i = 0; i < NUM_TRAIN; i++)\n    {\n        float f = sin(iTime * float(i + 3) * 2.0) * 0.005;\n\n        if (i == 0)\n        {\n            // Engine base \n            float dist2 = sdBox(pos + vec3(0, -TRAIN_HEIGHT * 0.4 - TRAIN_ABOVE_TRACK, 0), \n                      vec3(TRAIN_WIDTH, TRAIN_HEIGHT * 0.4, TRAIN_LEN)); \n            // Chimney\n            dist2 = min(dist2, sdCappedCylinder(pos + vec3(0, -TRAIN_HEIGHT * 3.0, -0.2), vec2(0.06, 0.2)));\n            if (dist2 < dist)\n            {\n                dist = dist2;\n                material = MAT_WHEEL;\n            }\n            \n            // Engine body: cylinder and box\n            vec3 p = pos + vec3(0, -TRAIN_HEIGHT * 2.5, 0);\n            p = vec3(p.y, p.z, p.x);\n            float dist3 = sdCappedCylinder(p, vec2(0.14, 0.35));\n            dist3 = min(dist3, sdBox(p + vec3(-0.1, 0.23, 0), vec3(0.2, 0.15, 0.15))); \n\n            // Chop out cylinder at the back\n            dist3 = max(dist3, -sdCappedCylinder(vec3(p.x - 0.1, p.z, p.y + 0.35), vec2(0.1, 0.3)));\n            if (dist3 < dist)\n            {\n                dist = dist3;\n                material = MAT_TRAIN;\n            }            \n        }\n        else\n        {\n            // Trucks\n            float dist2 = train1(pos + vec3(0, f, 0));\n            if (dist2 < dist)\n            {\n                dist = dist2;\n                material = MAT_TRAIN + i;\n            }\n        }\n\n        float dist3 = wheels(pos);\n        if (dist3 < dist)\n        {\n            dist = dist3;\n            material = MAT_WHEEL;\n        }\n    \n        float dist4 = shiny(pos);\n        if (dist4 < dist)\n        {\n            dist = dist4;\n            material = MAT_SHINY;\n        }\n        pos += vec3(0.0, 0.0, 1.0);\n    }\n    \n    return vec2(dist, material);\n}\n\n//------------------------------------------------------------------------\nvec3 calcNormalAtPoint(vec3 pos) \n{\n    float d = 0.001;\n    vec2 u = vec2(1.0, 0.0);\n    return normalize(\n        vec3(\n            calcDist(pos + u.xyy * d).x - calcDist(pos - u.xyy * d).x,\n            calcDist(pos + u.yxy * d).x - calcDist(pos - u.yxy * d).x,\n            calcDist(pos + u.yyx * d).x - calcDist(pos - u.yyx * d).x\n        )\n    );\n}\n\n//------------------------------------------------------------------------\nvec3 calcColour(in vec3 pos, in vec3 rayDir, int material)\n{\n    if (material == MAT_FLOOR)\n    {\n        float stripe = 0.5;\n        if (abs(pos.x) < 18.0)\n        {\n            stripe = clamp(sin(pos.z * 1.0) * 100.0, 0.0, 1.0) * 0.125 + 0.625;\n            //stripe += clamp(sin(pos.x * 0.95) * 100.0, 0.0, 1.0) * 0.125;\n        }\n        return FLOOR_COLOUR * stripe;\n    }\n\n    vec3 normal = calcNormalAtPoint(pos);\n    \n    // Calc diffuse lighting, and add a constant for ambient\n    float nDotL = min(max(0.0, dot(normal, LIGHT_DIR)) + 0.5, 1.0);\n        \n    if (material == MAT_TREE)\n        return TREE_COLOUR * nDotL;\n\n    if (material >= MAT_TRAIN)\n    {\n        int i = material - MAT_TRAIN + 1;\n        float i1 = mod(float(i), 2.0); \n        float i2 = mod(float(i / 2), 2.0); \n        float i3 = mod(float(i / 4), 2.0); \n        return vec3(i1, i2, i3) * nDotL;\n    }\n    \n    if (material == MAT_WHEEL)\n        return WHEEL_COLOUR * nDotL;\n    \n    // Calc specular\n    float spec = clamp(\n        dot( reflect( -LIGHT_DIR, normal ), -rayDir ),\n        0.0, 1.0 );\n    \n    if (material == MAT_TRACK)\n    {\n        float stripe = (sin((pos.x + cos(pos.z * 4.0) + cos(pos.y * 5.0)) * 40.0) + 1.0) * 0.125 + 0.75;\n        return WOOD_COLOUR * stripe * nDotL + vec3(spec);\n    }\n    \n    return vec3(spec + nDotL);\n}\n\n//------------------------------------------------------------------------\n// Raymarch until we hit something, or we realise we will find nothing.\n// Return colour of pixel.\nvec3 render(in vec3 eyePos, in vec3 rayDir)\n{\n    // t is distance along ray so far \n    float t = START_T;\n    \n    vec2 distMat = vec2(0.0, 0.0);\n    \n    // Repeatedly find the closest distance to an object in the\n    //  scene, and add this to t. \n    for( int i = 0; i < MAX_ITERS; i++ ) \n    {\n        // Distance to closest object and its material ID\n        distMat = calcDist(eyePos + rayDir * t);\n        float dist = distMat.x; // x-component is the distance\n\n        if (dist > TOO_FAR)\n            return SKY_COLOUR; // ray has hit nothing, and never will \n        \n        if (dist <= CLOSE_ENOUGH)\n            break; // ray has hit something\n\n        t += dist * 0.9; // advance by this distance and keep marching\n    }\n\n    // Final pos, which is on surface of an object in the scene\n    vec3 pos = eyePos + rayDir * t;    \n    \n    // Now we could use pos to get the normal, then do some \n    //  lighting etc.\n    int material = int(distMat.y);\n    \n    return calcColour(pos, rayDir, material);    \n}\n\n//------------------------------------------------------------------------\n// camera matrix\nmat3 getCameraMatrix( vec3 camFow ) \n{\n    vec3 forward = normalize( camFow );\n    vec3 up = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    vec3 right = normalize( cross( up, forward ) );\n    \n    mat3 mat = mat3( right, up, forward );\n        \n    return mat;\n}\n\n//------------------------------------------------------------------------\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get this pixel coord in range (-1..1)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\n    // Rotate camera in time with track curve, so we look at train\n    float deltaRot = PI - sin(iTime * 0.05) * PI;\n\n    float D = 4.0;\n    float y = cos(iTime * 0.2) + 2.0;\n    float z = iTime * SPEED;\n    vec3 camPos = vec3( -D * cos(deltaRot), y, z + -D * sin(deltaRot) );\n    vec3 camFow = vec3( 1.0 * cos(deltaRot), 0.0, 1.0 * sin(deltaRot) );\n    mat3 camMat = getCameraMatrix( camFow );\n    \n    float viewRatio = iResolution.y / iResolution.x;\n    uv.y *= viewRatio;\n\n    vec3 rayDir = camMat * normalize( vec3( uv, viewRatio * 1.5 ) );\n    \n    // Get colour for pixel\n    vec3 colour = render(camPos, rayDir);\n    \n    fragColor = vec4(colour, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}