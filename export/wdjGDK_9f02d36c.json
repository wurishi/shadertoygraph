{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define MAX_STEPS 50\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define PI 3.141592653589793\n#define SUBSPHERE_COUNT 24\n#define MAINSPHERE vec4(0, 0, 0, 1)\n\nvec4[SUBSPHERE_COUNT] secondaries;\n\n// Hash from Dave_Hoskins\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Noise1D(float x)\n{\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n   \tf = f*f*(3.0-2.0*f);\n\n\treturn mix(hash11(p), hash11(p+1.0), f);\n}\n\nvec3 GetSphericalFibonacciCoord(int ng, int index)\n{\n\tfloat phi = ( 1.0 + sqrt ( 5.0 ) ) / 2.0;\n    \n  \tfloat ngFloat = float(ng);\n\n    float iFloat = float( - ng + 1 + 2 * index);\n    float theta = 2.0 * PI * iFloat / phi;\n    float sphi = iFloat / ngFloat;\n    float cphi = sqrt ( ( ngFloat + iFloat ) * ( ngFloat - iFloat ) ) / ngFloat;\n\n    return vec3(\n        cphi * sin ( theta ),\n        cphi * cos ( theta ),\n\t\tsphi);\n}\n\n// Smooth min function from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p) \n{\n\tvec4 s = MAINSPHERE;\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float d=sphereDist;\n    \n\tfloat sphere2Radius = 0.25;\n\tfor(int i=0;i<SUBSPHERE_COUNT;i++)\n    {\n\t\tvec4 secSpj = secondaries[i] ;\n\t\tfloat secondarySphereDist = length(p- secSpj.xyz - MAINSPHERE.xyz)-secSpj.w;\n\t\td = smin(d, secondarySphereDist, .1);\n    }\n    \n    return d;\n}\n\n// Raytrace inside volume to check for occlusion\nfloat RayMarchOut(vec3 ro, vec3 rd) \n{\n\tfloat dO=0.;\n    \n    for(float i=0.0; i<1.0; i+=0.05) \n\t{\n    \tvec3 p = ro + rd*i;\n        float dS = GetDist(p);\n\t\tdO += 0.05 * step(dS, 0.0);\n    }\n\treturn exp(-dO*1.1);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) \n\t{\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec3 GetLight(vec3 p, vec3 rd, float curd, vec4 noise) \n{\n\tvec3 SScol = vec3(0.8, 0.4, 0.4);\n\n    // Light 1\n\tvec3 lightCol = vec3(1.0, 0.1, 0.1);\n\tfloat d2;\n    \n    vec3 lightPos = vec3(0, 2, 6);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\td2 = RayMarchOut(p+rd*(SURF_DIST*4. + noise.x*0.05), l);\n    float dif = dot(n, l);\n\tfloat invDif = clamp(-dif, 0., 1.); \n    dif = clamp(dif, 0., 1.);\n\n\tvec3 light = (0.5 + dif*0.5)*SScol*d2*lightCol ;\n\tvec3 v = -rd;\n\tvec3 reflect = normalize(2.0 * dif * n - l); \n\tfloat specular = pow(clamp(dot(reflect, v), 0.0, 1.0), 12.0) * dif;\n\tfloat specular2 = pow(clamp(dot(reflect, v), 0.0, 1.0), 5.0) * dif;\n\tlight += (vec3(specular) + specular2 * SScol)*lightCol;\n\n\n    // Light 2\n\tlightCol = vec3(0.1, 0.1, 1.0);\n \tlightPos = vec3(0, -2, -6);\n    l = normalize(lightPos-p);\n  \td2 = RayMarchOut(p+rd*(SURF_DIST*4. + noise.x*0.05), l);\n    dif = dot(n, l);\n\tinvDif = clamp(-dif, 0., 1.); \n    dif = clamp(dif, 0., 1.);\n\t\n\tlight += (0.5 + dif*0.5)*SScol*d2*lightCol ;\n\treflect = normalize(2.0 * dif * n - l); \n\tspecular = pow(clamp(dot(reflect, v), 0.0, 1.0), 12.0) * dif;\n\tspecular2 = pow(clamp(dot(reflect, v), 0.0, 1.0), 5.0) * dif;\n\tlight += (vec3(specular) + specular2 * SScol)*lightCol;\n\n    return light;\n}\n\nvec3 RotateY(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x * cos(angle) - pos.z * sin(angle),\n        pos.y,\n        pos.x * sin(angle) + pos.z * cos(angle)\n    );\n}\n\nvec3 RotateX(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x,\n        pos.y * cos(angle) - pos.z * sin(angle),\n        pos.y * sin(angle) + pos.z * cos(angle)\n    );\n}\n\n// Reinhard Tonemapping\nvec3 ToneMap(vec3 inColor)\n{\n    inColor *= 1.0;  // Hardcoded Exposure Adjustment\n    inColor = inColor/(vec3(1)+inColor);\n    vec3 retColor = pow(inColor,vec3(1.0/2.2));\n    return retColor;\n    \n    return inColor;\n}\n\n// Raymarching inspired by RayMarching for Dummies! from BigWIngs\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Avoid recomputing the sphere pos more than once per pixel\n\tfor(int i=0;i<SUBSPHERE_COUNT;i++)\n    {\n\t\tvec3 ssphPos = GetSphericalFibonacciCoord(SUBSPHERE_COUNT, i).xzy;\n\t\tfloat rndVal = Noise1D(float(i)*0.1+iTime*2.5+ssphPos.y);\n\t\tssphPos *= (.7 + rndVal*.7);\n\t\tsecondaries[i] = vec4(ssphPos, mix(0.5, 0.15, rndVal));\n    }\n\n    vec4 noise = texture(iChannel0, fragCoord/1024.0); \n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 offset =  vec3(0.0, 0.0, 0.0);\n\tfloat angle = mix(iTime, 4.0-iMouse.x/iResolution.x*8.0, step( 0.001, iMouse.z ));\n\n\tvec3 ro = offset + vec3(0.0, 0.0, -8.0);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 2));\n    \n\tro = RotateY(ro, angle);\n\trd = RotateY(rd, angle);\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 col = mix( vec3(0.5, 0.5, 0.5), GetLight(p, rd, d, noise), step(d,50.0));\n        \n    fragColor = vec4(ToneMap(col),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"wdjGDK","date":"1550070806","viewed":1986,"name":"Blobby McFerrite","username":"Gaxil","description":"Experimenting with raymarching and a home made subsurface scattering ... \nThe SSS raycast can be improved by using SDF in a better way ...","likes":70,"published":1,"flags":0,"usePreview":1,"tags":["raymarch","blob"],"hasliked":0,"parentid":"","parentname":""}}