{"ver":"0.1","info":{"id":"ttKSzw","date":"1582547923","viewed":386,"name":"Bijective Weighted 3Gon Sampling","username":"fizzer","description":"Analytic approach to sampling a triangle with linearly-interpolated probability weights at each corner. The derivation of this approach is a little bit involved, so I might write a long-form explanation somewhere else.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["triangle","random","sampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Previous work:\n// \thttps://arxiv.org/pdf/1708.07559.pdf\n//\thttp://www0.cs.ucl.ac.uk/staff/K.Subr/Files/Papers/RT07.pdf\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    int disp_pixels = int(iResolution.x / 6.);\n    \n    float sample_count = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).a;\n    \n\tvec4 col0 = texelFetch(iChannel0, max(ivec2(fragCoord.xy) - ivec2(disp_pixels, 0), 0), 0);\n\tvec4 col1 = texelFetch(iChannel0, min(ivec2(fragCoord.xy) + ivec2(disp_pixels * 2, 0), ivec2(iResolution.xy)), 0);\n\n   \tfragColor.rgb = vec3(col0.r);\n    fragColor.rgb += vec3(col1.g) * col1.b;\n    \n    if(col0.a > 0.)\n    \tfragColor.rgb /= float(sample_count);\n    \n    fragColor.rgb = mix(vec3(.8 + .2 * mod(floor(uv.x * 13.) + floor(uv.y * 13.), 2.)) / 8., fragColor.rgb, step(0.01, fragColor.r));\n    \n    if(abs(uv.x) < .005)\n        fragColor.rgb = vec3(1, .2, .2);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = acos(-1.);\nconst float phi = (sqrt(5.) + 1.) / 2.;\n\n// Tiny Encryption Algorithm for random numbers: \nuvec2 encrypt(uvec2 v)\n{\n    uint k[4],sum=0U,delta=0x9e3779b9U;\n    k[0] = 0xA341316CU;\n    k[1] = 0xC8013EA4U;\n    k[2] = 0xAD90777DU;\n    k[3] = 0x7E95761EU;\n    for(uint i=0U;i<4U;++i)\n    {\n        sum += delta;\n        v.x += ((v.y << 4) + k[0]) ^ (v.y + sum) ^ ((v.y >> 5) + k[1]);\n        v.y += ((v.x << 4) + k[2]) ^ (v.x + sum) ^ ((v.x >> 5) + k[3]);\n    }\n\n    return v;\n}\n\nuvec2 rstate = uvec2(0);\n\nfloat rng()\n{\n    rstate = encrypt(rstate);\n    return float(rstate.x & 0xfffffU) / float(1 << 20);\n}\n\n\n// Solves (a / 3 * x + b / 2) * x * x + d = 0 for x.\n// Note that this is simplified by the fact that there is no linear term.\n// I used Cardano's formula for this: https://proofwiki.org/wiki/Cardano%27s_Formula\nfloat solveCubic(float a, float b, float d)\n{\n    float ba = b / a * .5;\n\n    float Q = -ba * ba;\n    float R = Q * ba - 1.5 * d / a;\n\n    float D = Q * Q * Q + R * R;\n\n    if(D < 0.)\n    {\n        float sQ = sqrt(-Q);\n        \n        // Three real roots.\n        \n        float phi = acos(R / (-Q * sQ)) / 3.;\n        \n        // Search for the root that lies within the needed solution range.\n        // Is there a better way?..\n        \n        for(int i = 0; i < 3; ++i)\n        {\n            float y = 2. * sQ * cos(phi + pi * float(i * 2) / 3.) - ba;\n            \n            if(y >= 0. && y <= 1.)\n                return y;\n        }\n    }\n    else\n    {\n        // One real root.\n        \n        float d0 = R + sqrt(D);\n        float d1 = R - sqrt(D);\n\n        float S = pow(abs(d0), 1. / 3.) * sign(d0);\n        float T = pow(abs(d1), 1. / 3.) * sign(d1);\n\n        return S + T - ba;\n    }\n}\n\nfloat triangleArea(vec2 ta, vec2 tb, vec2 tc)\n{\n    return ((tb.x - ta.x) * (tc.y - ta.y) - (tb.y - ta.y) * (tc.x - ta.x)) / 2.;\n}\n\nvec3 integrateTriangle(vec3 ws, vec2 ts[3])\n{\n    // Sort the weights\n\n    vec3 sort_mask0 = step(ws.xyz, ws.yzx) * step(ws.xyz, ws.zxy);\n    vec3 sort_mask2 = step(ws.yzx, ws.xyz) * step(ws.zxy, ws.xyz);\n    vec3 sort_mask1 = vec3(1) - sort_mask0 - sort_mask2;\n\n    int wi0 = int(dot(sort_mask0, vec3(0, 1, 2)));\n    int wi1 = int(dot(sort_mask1, vec3(0, 1, 2)));\n    int wi2 = int(dot(sort_mask2, vec3(0, 1, 2)));\n    \n    float wa = ws[wi0];\n    float wb = ws[wi1];\n    float wc = ws[wi2];\n\n    // Generate canonical triangle\n\n    float slope1 = wb - wa;\n    float slope2 = wb - wc;\n\n    float tc2 = (wc - wa) / slope1;\n    \n    // Cubic coefficients\n\n    vec2 c0 = vec2(slope1, wa);\n    vec2 c1 = vec2(slope2, wc);\n\n    // Integrals\n    \n    float sum0 = (c0.x / 3. + c0.y / 2.);\n    float sum1 = (c1.x / 3. + c1.y / 2.) * (tc2 - 1.);\n    \n    // Canonical triangle cornerpoints\n    \n    vec2 rtb = vec2(0, 0);\n    vec2 rta = vec2(1, 1);\n    vec2 rtc = vec2(tc2, 0.);\n    \n    float rtri_area = triangleArea(rta, rtb, rtc);\n    float tri_area = triangleArea(ts[0], ts[1], ts[2]);\n    \n    return vec3(tri_area, sum0 + sum1, rtri_area);\n}\n\nvec2 sampleTriangle(vec3 ws, vec2 ts[3], vec2 uv)\n{\n    // Sort the weights\n    \n    vec3 sort_mask0 = step(ws.xyz, ws.yzx) * step(ws.xyz, ws.zxy);\n    vec3 sort_mask2 = step(ws.yzx, ws.xyz) * step(ws.zxy, ws.xyz);\n    vec3 sort_mask1 = vec3(1) - sort_mask0 - sort_mask2;\n\n    int wi0 = int(dot(sort_mask0, vec3(0, 1, 2)));\n    int wi1 = int(dot(sort_mask1, vec3(0, 1, 2)));\n    int wi2 = int(dot(sort_mask2, vec3(0, 1, 2)));\n    \n    float wa = ws[wi0];\n    float wb = ws[wi1];\n    float wc = ws[wi2];\n\n    // Generate canonical triangle\n\n    float slope1 = wb - wa;\n    float slope2 = wb - wc;\n\n    float tc = (wc - wa) / slope1;\n\n    // Cubic coefficients\n\n    vec2 c0 = vec2(slope1, wa);\n    vec2 c1 = vec2(slope2, wc);\n\n    float sum0 = (c0.x / 3. + c0.y / 2.);\n    float sum1 = (c1.x / 3. + c1.y / 2.) * (tc - 1.);\n\n    uv.x *= sum0 + sum1;\n    \n    if(uv.x < sum0)\n    {\n        uv.x = uv.x / sum0;\n\n        // CDF\n        uv.x = solveCubic(c0.x, c0.y, -uv.x * sum0);\n        uv.y *= uv.x;\n    }\n    else\n    {\n        uv.x = 1. - (uv.x - sum0) / sum1;\n\n        sum1 /= tc - 1.;\n\n        // CDF\n        uv.x = solveCubic(c1.x, c1.y, -uv.x * sum1);\n        uv.y *= uv.x;\n        uv.x = tc - uv.x * (tc - 1.);\n    }\n    \n\n    // Map the generated point back to the target triangle space from\n    // the canonical triangle space.\n    \n    uv = inverse(mat2(vec2(1), vec2(tc, 0))) * uv;\n    \n    return ts[wi0] + (ts[wi1] - ts[wi0]) * uv.x + (ts[wi2] - ts[wi0]) * uv.y;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    vec4 prevFragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\n    if(iFrame == 0 || iMouse.z > .5)\n    {\n        prevFragColor = vec4(0);\n    }\n\n    fragColor.rgb = vec3(0);\n    fragColor.a = 1.;\n\n    rstate = uvec2(iFrame * 7, iFrame * 999);\n\n    // Set up the triangle to sample\n\n    vec2 ta, tb, tc;\n    float wa, wb, wc;\n\n    // Choose a different triangle for each quadrant of the viewport\n    \n   \tif(uv.x < 0.15)\n    {\n        if(uv.y < 0.)\n        {\n            ta = vec2(-.5, +.2 - 1.) / 3.;\n            tb = vec2(+.4, +.1 - 1.) / 3.;\n            tc = vec2(+.1, +.5 - 1.) / 3.;\n\n            wb = .04;\n            wc = .9;\n            wa = 1.;\n        }\n        else\n        {\n            ta = vec2(-.5, -.2 + .5) / 3.;\n            tb = vec2(+.4, +.1 + .5) / 3.;\n            tc = vec2(+.1, +.5 + .5) / 3.;\n\n            wc = 1.;\n            wb = .2;\n            wa = .01;\n    \t}\n    }\n    else\n    {\n        if(uv.y < 0.)\n        {\n            ta = vec2(-.5 + 1., +.4 - 1.) / 3.;\n            tb = vec2(+.4 + 1., -.1 - 1.) / 3.;\n            tc = vec2(+.1 + 1., +.9 - 1.) / 3.;\n\n            wb = .9;\n            wc = .8;\n            wa = .71;\n        }\n        else\n        {\n            ta = vec2(-.5 + 1., -.2 + .5) / 3.;\n            tb = vec2(+.4 + 1., +.1 + .5) / 3.;\n            tc = vec2(+.1 + 1., +.5 + .5) / 3.;\n\n            wa = 1.;\n            wb = .02;\n            wc = .01;\n    \t}\n    }\n\n\n    // Normalize the weights\n\n    float inv_wsum = 1. / (wa + wb + wc);\n\n    wa *= inv_wsum;\n    wb *= inv_wsum;\n    wc *= inv_wsum;\n\n\n    // Render the target triangle\n\n    float tri_area = triangleArea(ta, tb, tc);\n\n    float b0 = triangleArea(uv, tb, tc);\n    float b1 = triangleArea(ta, uv, tc);\n    float b2 = triangleArea(ta, tb, uv);\n\n    // Barycentric coordinates\n    vec3 bary = vec3(b0, b1, b2) / tri_area;\n\n    if(b0 > 0. && b1 > 0. && b2 > 0.)\n    {\n        float interpolated_w = dot(bary, vec3(wa, wb, wc));\n        fragColor.r = interpolated_w;\n    }\n\n\n    vec2 ts[3] = vec2[3](ta, tb, tc);\n\n#if 1\n\n    // Sample the triangle using a linear PDF defined by the corner weights.\n    \n    // Splat the sample points and generating a correcting factor to produce\n    // a convergence toward a histogram which (hopefully) matches the original PDF.\n\n    // To make the convergence faster at the expense of a blurred result (which\n    // doesn't matter much in this case) a disc is used as a splatting kernel.\n\n    // The whole point of this is to test that the generated point density does\n    // indeed match the linearly-interpolated weights. If the distribution is as-expected\n    // then the result should be an image of the triangle with the weights linearly interpolated\n    // over it, convolved by the splatting kernel.\n    \n    float splat_radius = .003;\n\n#if 1\n    // Random sampling\n\n    const int N = 128;\n\t\n    for(int i = 0; i < N; ++i)\n    {\n        vec2 u = vec2(rng(), rng());\n        vec2 p = sampleTriangle(vec3(wa, wb, wc), ts, u);\n\n        fragColor.g += step(distance(uv, p), splat_radius);\n    }\n    \n    fragColor.b = 1. / float(N); // Sample count\n    \n#else\n    // Square lattice shifted toroidally along irrational slope\n\n    const int N = 8;\n\n    for(int y = 0; y < N; ++y)\n        for(int x = 0; x < N; ++x)\n        {\n            vec2 u = fract(vec2(float(x) / float(N - 1), float(y) / float(N - 1)) + float(iFrame) * vec2(pi, phi));\n            vec2 p = sampleTriangle(vec3(wa, wb, wc), ts, u);\n\n            fragColor.g += step(distance(uv, p), splat_radius);\n        }\n\n    fragColor.b = 1. / float(N * N); // Sample count\n                           \n#endif\n    \n    vec3 integ = integrateTriangle(vec3(wa, wb, wc), ts);\n\n    fragColor.b *= integ.y; // Integral of PDF over triangle (effectively un-normalize)\n    fragColor.b /= pi * splat_radius * splat_radius; // Splat area\n    fragColor.b *= integ.x / integ.z; // Ratio of target triangle area to canonical triangle area\n\n    fragColor.rg += prevFragColor.rg;\n    fragColor.a = prevFragColor.a + 1.;\n    \n#else\n    // Visual confirmation of the bijectivity of the mapping\n    \n    const int N = 8;\n\n    for(int y = 0; y < N; ++y)\n        for(int x = 0; x < N; ++x)\n        {\n            vec2 u = fract(vec2(float(x) / float(N - 1), float(y) / float(N - 1)) + iTime / 8. * vec2(pi, phi));\n            vec2 p = sampleTriangle(vec3(wa, wb, wc), ts, u);\n\n            fragColor.g += step(distance(uv, p), .005);\n        }\n    \n    fragColor.b = 1.;\n    fragColor.a = 1.;\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}