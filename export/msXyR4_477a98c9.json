{"ver":"0.1","info":{"id":"msXyR4","date":"1686612021","viewed":40,"name":"SDF Shifted Half Taijitu","username":"feeg1","description":"SDF of a tomoe with the shifting tail.  Constructed using sdfs of a circle and a line segment from https://iquilezles.org/articles/distfunctions2d/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"cdXczN","parentname":"Ying Yang Raw"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfCircle(vec2 point, vec2 center, float radius)\n{\n    return length(point-center)-radius;\n}\nfloat sdfSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat scaledCos(float theta, float minimum, float maximum)\n{\n    return ((maximum-minimum)*cos(theta)+(maximum+minimum))*0.5;\n}\n\n//this took way too long\n\nfloat tomoe(vec2 position, vec2 center, float size, float taper)\n{\n    position = position-center;\n    float line = sdfSegment(position,vec2(0.,size),vec2(0.,-size));\n    float circle = sdfCircle(position,vec2(0.),size);\n    //Line is always positive, so we have two cases:\n    // circle is positive:  Then the distance is indeed the distance to the circle\n    //circle is negative:  The distance is either the negative of the line distance, or the distance to circle.  Whichever is lower (closer to zero)\n    float dist = position.x < 0. ? line : max(-line,min(line, circle));\n    dist = min(dist,sdfCircle(position,vec2(0.,size/2.),size/2.));\n    \n    vec2 taperedCircle = vec2(0.,-size/2.-taper);\n    float taperedR = size/2.+taper;\n    \n    dist = max(dist,-sdfCircle(position,vec2(0.,-size/2.-taper),(size/2.+taper)));\n    \n    //Distance to tail point, via intersection between 'negative' circle and bounding circle\n    float b = (0.5*size+taper)*(0.5*size+taper);\n    float a = size*size;\n    float mx = 0.5 * sqrt(max(-a*(a-4.*b)/(b*b),0.));\n    float my = -0.5 * ((a-b)/(b)+1.);\n    dist = min(dist,length(position-taperedR*vec2(mx,my)));\n    return dist;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 uv = uv0-vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    float r = 0.5;\n    const float PI = 3.14159265;\n    float _c = cos(r*iTime);\n    float _s = sin(r*iTime);\n    uv = mat2x2(_c,-_s,_s,_c) * uv;\n    \n    \n    float ta = scaledCos(r*iTime+PI,0.0,0.15);\n    float d = tomoe(uv,vec2(0.),0.2,ta);\n    vec3 col = (d < 0.) ? vec3(1.,0.,0.) : vec3(0.,1.,0.);\n    \n    \n    float e_value = 1.0-exp(-8.*abs(d));\n    float c_value = 0.7 + 0.2*cos(255.*d);\n    \n    fragColor = vec4(mix(e_value*c_value*col,vec3(1.),1.0-smoothstep(0.0,0.005,abs(d))),1.0);\n    //fragColor = vec4(d*vec3(1.),1.);\n\n}","name":"Image","description":"","type":"image"}]}