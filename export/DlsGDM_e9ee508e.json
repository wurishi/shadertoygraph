{"ver":"0.1","info":{"id":"DlsGDM","date":"1671854973","viewed":155,"name":"weaved hex truchet flow","username":"VL","description":"without arbitrary rotation.\nIndex edges of hexagon as shown below and then connect them randomly from left to right.\n  0 /\\  0\n  1|  | 1\n  2 \\/  2\nref : [url=https://www.shadertoy.com/view/llByzz]BigWIngs's Hexagonal Truchet Weaving[/url]","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n\nconst float InvPI = 0.318309886f;\nconst float PId2 = 1.57079632f;\nconst float PI = 3.141592653f;\nconst float PI2 = 6.2831853f;\nconst float MaxDist = 100.f;\nconst float SurfaceDist = 0.0001f;\nconst float FloatMax = 3.402823466e+38F;\n\nfloat4 hash42(float2 p)\n{\n    float4 p4 = frac(float4(p.xyxy) * float4(161.1031, 144.1030, 153.0973, 166.1099));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return frac((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfloat2x2 rot2D(float t)\n{\n    float s, c;\n    sincos(t, s, c);\n    return transpose(float2x2(c, s, -s, c));\n}\n\nvoid swap(inout int a, inout int b)\n{\n    int tmp = a;\n    a = b;\n    b = tmp;\n}\n\nfloat drawLine(float2 uv, int left, int right, out float2 tuv, float t, int rot)\n{\n    bool flipX = false;\n    if(left == 2)\n    {\n        swap(left, right);\n        uv.x = -uv.x;\n        flipX = true;\n    }\n    \n    if(left == 0)\n    {\n        uv = mul(uv, rot2D(PI/3.f)); \n    }\n    \n    tuv.x = (uv.x + sqrt(3.f)/2.f) * (1.f/sqrt(3.f));\n    tuv.x = frac(flipX ? -tuv.x : tuv.x);\n    \n    float hT = t*0.5;\n    tuv.y = (clamp(uv.y,-hT,hT)+hT)/t;\n    tuv.y = frac(tuv.y);    \n        \n    return abs(uv.y);\n}\n\nfloat drawSmallArc(float2 uv, int left, int right, out float2 tuv, float t, int rot)\n{\n    bool flipY = false;\n    if(left == 2)\n    {\n        uv.y = -uv.y;\n        flipY = true;\n    }\n\n    uv.y -= 1.f;\n    \n    tuv.x = (atan2(uv.y, uv.x) + PI/6.f) * (3.f/PI2);\n    tuv.x = frac(tuv.x);\n    \n    float len = length(uv) - 0.5f;\n    float hT = t*0.5;\n    tuv.y = (clamp(len,-hT,hT)+hT)/t;\n    tuv.y = frac(flipY ? tuv.y : -tuv.y);    \n\n    return abs(len);\n}\n\nfloat drawLargeArc(float2 uv, int left, int right, out float2 tuv, float t, int rot)\n{\n    bool flipX = false;\n    if(left == 1)\n    {\n        swap(left, right);\n        uv.x = -uv.x;\n        flipX = true;\n    }\n    \n    bool flipY = false;\n    if(left == 2)\n    {\n        uv.y = -uv.y;\n        flipY = true;\n    }\n    \n    uv -= float2(sqrt(3.f),3.f)*0.5; \n    \n    tuv.x = (atan2(uv.y, uv.x) + PI/6.f)*(3.f/PI);    \n    tuv.x = frac(flipX ? -tuv.x : tuv.x);    \n    \n    float len = length(uv) - 1.5f;\n    float hT = t*0.5;\n    tuv.y = (clamp(len,-hT,hT)+hT)/t;\n    tuv.y = frac(flipY ? tuv.y : -tuv.y);\n\n    return abs(len);\n}\n\nfloat getPattern(float2 uv, int left, int right, out float2 tuv, float t, int rot)\n{\n    if(left + right == 2)\n        return drawLine(uv, left, right, tuv, t, rot);\n    else if(left - right == 0)\n        return drawSmallArc(uv, left, right, tuv, t, rot);\n    else\n        return drawLargeArc(uv, left, right, tuv, t, rot);\n}\n\nfloat3 weavedHexTruchet(float2 p, float thickness, float flow) \n{\n    const float2 k = float2(1.f, sqrt(3.f));\n    \n    float2 pk = p/k;\n    float2 aIdx = floor(pk);\n    float2 a = (pk - aIdx)*k - k*0.5;\n    \n    pk = (p - k*0.5)/k;\n    float2 bIdx = floor(pk);\n    float2 b = (pk - bIdx)*k - k*0.5;\n    \n    float2 hexUv = dot(a,a) < dot(b,b) ? a : b;\n    float2 hexIdx = dot(a,a) < dot(b,b) ? aIdx : (bIdx + 0.5);\n    float4 rand = hash42(hexIdx);\n    \n    int rot = int((rand.x + rand.y) * 0.5f * 3.f); \n    //hexUv = mul(hexUv, rot2D(PI/3.f * float(rot)));\n    \n    float hT = thickness * 0.5f;\n    float2 tuv, tuvTmp;\n    \n    int lRemain[3] = int[3](0,1,2);\n    int rRemain[3] = int[3](0,1,2);\n    \n    int left = int(rand.x * 3.f);\n    int right = int(rand.z * 3.f);\n    \n    hexUv *= k.y;\n    float dist = getPattern(hexUv, lRemain[left], rRemain[right], tuv, thickness, rot) - hT;    \n    \n    swap(lRemain[left], lRemain[2]);\n    swap(rRemain[right], rRemain[2]);    \n    left = int(rand.y*2.f);\n    right = int(rand.w*2.f);\n    \n    float d1 = getPattern(hexUv, lRemain[left], rRemain[right], tuvTmp, thickness, rot) - hT;\n    if(dist > d1 - smoothstep(0.06, 0.f, d1))\n    {\n        dist = d1;\n        tuv = tuvTmp;\n    }\n        \n    float d2 = getPattern(hexUv, lRemain[1 - left], rRemain[1 - right], tuvTmp, thickness, rot) - hT;\n    if(dist > d2 - smoothstep(0.06, 0.f, d2))\n    {\n        dist = d2;\n        tuv = tuvTmp;\n    }\n    \n    return texture(iChannel0,float2(frac(tuv.x-flow)*0.47,tuv.y)).rgb * smoothstep(0.01f,0.f,dist);\n    //return float3(float2(frac(tuv.x-flow),tuv.y)* smoothstep(0.01f,0.f,dist),0.f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.y*4.2+iTime*0.5;    \n    \n    vec3 col =  weavedHexTruchet(uv, 0.55,iTime);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}