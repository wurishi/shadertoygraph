{"ver":"0.1","info":{"id":"mdKczd","date":"1696507293","viewed":97,"name":"inktober 2023 #5 - Map","username":"Shalexder","description":"map","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["map"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SEA vec3(180,225,230)/255.\n#define MAP vec3(220,166,112)/255.\n#define BG vec3(0.)\n//.0*vec3(156,94,54)/255.\n#define RED vec3(207,44,41)/255.\n\nfloat rand(float n){return fract(sin(n*37.382) * 43758.5453123);}\n\nfloat rand(vec2 p){\n    return fract(10.326*sin(p.x*24.7865+p.y*8.5703));\n}\n\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n\nfloat fractalNoise(vec2 p){\n    float r = 0.;\n    float a = 1.;\n    float f = 1.;\n    float s = 0.;\n    for(float i = 0.; i < 3.9; i+=1.){\n        r += noise(p*f)*a;\n        s += a;\n        f *= 2.;\n        a *= .5;\n    }\n    r /= s;\n    return r;\n}\n\n\nvec2 gradient(vec2 p){\n    float h = fractalNoise(p);\n    vec2 e = vec2(.0001, 0.);\n    return normalize(h-vec2(\n        fractalNoise(p-e.xy),\n        fractalNoise(p-e.yx)\n    ));\n}\n\nbool heightLine(vec2 p, float lineHeight, float h){\n    return h < lineHeight && fractalNoise(p+gradient(p)*.01) >= lineHeight;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat dot2(vec2 p){\n    return dot(p, p);\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    float tt = 0.;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        tt = t;\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    if(fract(tt*11.+.4) < .5 || tt > iTime*.4) return 1.;\n    return sqrt( res );\n}\n\nvec2 rotate(vec2 p, float a){\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m*p;\n}\n\nfloat crossSDF(vec2 p){\n\tvec2 p_transform = rotate((p-vec2(0.0, 0.0))/1.0, 0.7853981633974483);\n\tfloat box_transform = sdBox(p_transform, vec2(0.3, 1.8));\n\tfloat box1_transform = sdBox(p_transform, vec2(1.8, 0.3));\n    if(p_transform.x+1.8 > (iTime-2.7)*12.) box1_transform = 1.;\n    if(p_transform.y+1.8 > (iTime-2.7-.5)*12.) box_transform = 1.;\n\tfloat unio_transform = min(box_transform, box1_transform);\n\treturn unio_transform;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 col = BG;\n    float mapDist = sdBox(uv, vec2(.8, .45))+fractalNoise(uv*10.+40.)*.1;\n    if(mapDist < 0.){\n        uv *= 5.;\n        //uv += iTime;\n        float h = fractalNoise(uv);\n        float hn = h;\n        if(hn >= .5) hn = .5;\n        /*if(hn >= .5 && hn < .6) hn = .5;\n        if(hn >= .6 && hn < .7) hn = .6;\n        if(hn >= .7 && hn < .8) hn = .7;*/\n        col = MAP*(.8+.4*h);\n        if(h < .5){\n            col = mix(col, SEA, .5);\n        }\n\n        if(heightLine(uv, .5, h)){\n            col = vec3(0.);\n        }\n\n        if(heightLine(uv, .6, h) || heightLine(uv, .7, h) || heightLine(uv, .8, h)){\n            col = mix(col, vec3(0.), .2);\n        }\n        \n        vec2 a = vec2(-2., -1.4);\n        vec2 b = vec2(0., .96);\n        \n        if(sdBezier(uv, a, vec2(0., -1.8), b) < .04 || crossSDF((uv-b)*7.) < 0.){\n            col = RED;\n        }\n        \n        col = mix(col, MAP*.8, smoothstep(-.03, 0., mapDist));\n    }\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}