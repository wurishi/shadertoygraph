{"ver":"0.1","info":{"id":"3djyWW","date":"1586648072","viewed":1138,"name":"Small way to get random vectors","username":"blackle","description":"on the left is points generated with normalize(V) and on the right is normalize(tan(V))","likes":13,"published":3,"flags":32,"usePreview":0,"tags":["random","vectors","sizecode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//with a random vector V in the range [-1, 1], you can get a relatively\n//uniformly distributed unit vector by doing normalize(tan(V)). this is\n//because normalizing a gaussian distributed vector will give you a\n//uniformly distributed unit vector, and tan(V) will make our vector\n//more gaussian. it's not perfect, but it helps a lot\n\n//on the left is points generated with normalize(V)\n//and on the right is normalize(tan(V))\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 hash3(float a) {\n    float h = hash(a, a+32.23);\n    return vec3(hash(a,h), hash(a+h,h*a), hash(a+h,h));\n}\n\nfloat sphere(vec3 p) {\n    return length(p)-1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x*2.;\n    bool fix = uv.x > 0.;\n    uv.x = fract(uv.x)-0.5;\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-5,0,0);\n    cam = erot(cam, vec3(0,1,0), cos(iTime));\n    init = erot(init, vec3(0,1,0), cos(iTime));\n    cam = erot(cam, vec3(0,0,1), iTime);\n    init = erot(init, vec3(0,0,1), iTime);\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100; i++) {\n        float dist = sphere(p);\n        if (dist*dist < 0.00001) {hit = true; break;}\n        p+=dist*cam;\n    }\n\n    if (hit) {\n        vec2 uv = map_from_sphere(p);\n        if (fix) {\n    \t\tfragColor = texture(iChannel1, uv);\n        } else {\n    \t\tfragColor = texture(iChannel0, uv);\n        }\n    } else {\n        fragColor.xyz = vec3(0.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.141592653;\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x+y)*(y*y-x)+x)/2.14e9;\n}\n\nvec3 randvec(float seed) {\n    float h1 = hash(seed, seed);\n    float h2 = hash(h1, seed);\n    float h3 = hash(h2, seed);\n    return vec3(h1,h2,h3);\n}\n\nvec3 map_to_sphere(vec2 p)\n{\n    float theta = (p.x-0.5)*PI*2.;\n    float phi = (p.y-0.5)*PI*2.;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec2 map_from_sphere(vec3 p)\n{\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}\n\nvec4 bufferImage( vec2 uv, vec4 data, float frame, bool fix ) {\n    for (int i = 0; i < 50; i++) {\n        vec3 rnd = randvec(hash(float(i), frame));\n        if (fix) {\n            rnd = tan(rnd);\n        }\n        rnd = normalize(rnd);\n        vec3 proj = map_to_sphere(uv);\n        data *= smoothstep(0.0, 0.015, distance(rnd, proj));\n    }\n    return data;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iFrame == 0) data = vec4(1.);\n    \n    fragColor = bufferImage(uv, data, float(iFrame), false);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iFrame == 0) data = vec4(1.);\n    \n    fragColor = bufferImage(uv, data, float(iFrame), true);\n}","name":"Buffer B","description":"","type":"buffer"}]}