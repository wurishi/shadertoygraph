{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const float gSpeed = 1.0;\nconst float gSpeedMult = 2.0;\nconst int StarQuality = 70;\nconst int DustQuality = 50;\n\nfloat GetTime()\n{\n    return (iTime+29.) * 60.0 * 3.0 * gSpeed;\n}\n\nvec2 WarpUV(vec2 buv, vec2 uv, float f)\n{\n    return uv; // Comment this line for black hole effect, its not soo good\n    float d = distance(buv / iResolution.xy, vec2(0.5, 0.5));\n    uv *= 1.0 - pow(0.007, d);\n    return uv;\n}\n\nvec4 Noise( in ivec2 x )\n{\n    vec4 noise0 = texture( iChannel0, (vec2(x)+0.5)/256.0, -100.0 );\n\treturn noise0;\n}\n\nmat2 GetRotation()\n{\n    // Reverse the rotation effect\n    float time = GetTime();\n    time *= -0.005;\n    return mat2(cos(time), sin(time), -sin(time), cos(time));\n}\n\nvec2 GetUV(vec2 BaseUV)\n{\n    float time = GetTime();\n    vec2 uv = (BaseUV.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x = (uv.x * iResolution.x / iResolution.y) + sin(time*0.005) * 0.5;\n    uv *= GetRotation();\n    uv = WarpUV(BaseUV, uv, 1.5);\n    return uv;\n}\n\nvec3 GenStarfield(vec2 BaseUV)\n{\n    vec3 r = vec3(GetUV(BaseUV), 1.0);\n    \n    float opac = sin(gSpeed);\n    float mspeed = gSpeed * gSpeedMult;\n    \n    float d = 0.5 * iTime;\n    float s2 = mspeed;\n    float s = s2 + 0.1; // add a small offset\n    \n    d += d*gSpeed*gSpeedMult*0.96;\n    \n    vec3 accum = vec3(0,0,0);\n    vec3 spp = r/max(abs(r.x),abs(r.y));\n    vec3 p = 2.0 * spp + 0.5;\n    \n    for (int i = 0; i < StarQuality; i++)\n    {\n        float z = Noise(ivec2(p.xy)).x;\n\t\tz = fract(z-d);\n\t\tfloat d2 = 50.0*z-p.z;\n\t\tfloat w = pow(max(0.0,1.0-8.0*length(fract(p.xy)-.5)),2.0);\n\t\tvec3 c = max(vec3(0),vec3(1.0-abs(d2+s2*.5)/s,1.0-abs(d2)/s,1.0-abs(d2-s2*.5)/s));\n\t\taccum += 1.5*(1.0-z)*c*w;\n\t\tp += spp;\n    }\n    \n    return pow(accum, vec3(1.0/2.2))*opac;\n}\n\nvec3 GenDust(vec2 BaseUV)\n{\n    float time = GetTime();\n    \n    float s = 0.0;\n    float v = 0.0;\n    vec2 uv = GetUV(BaseUV);\n    vec3 accum = vec3(0);\n    vec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);\n    \n    float intensity = mix(1.0, 10.0, 1.0 - float(DustQuality) / 100.0);\n\tfor (int r = 0; r < DustQuality; r++) \n\t{\n\t\tvec3 p = init + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z, 2.0);\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\taccum +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\n\t\ts += .01;\n\t}\n    \n    return accum*intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 BaseUV =fragCoord.xy;\n    vec3 dust = GenDust(BaseUV);\n\tvec3 stars = GenStarfield(BaseUV);\n    \n    fragColor = vec4(stars + dust, 1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XllGz4","date":"1419240053","viewed":1643,"name":"Warpdriving","username":"migi0027","description":"A simple mix between shaders here at shadertoy and some modifications of my own, some parts of the shader is laughable but its my first try...","likes":34,"published":1,"flags":0,"usePreview":1,"tags":["warp","shader","drive"],"hasliked":0,"parentid":"","parentname":""}}