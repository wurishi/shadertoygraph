{"ver":"0.1","info":{"id":"7sBGzm","date":"1617748128","viewed":118,"name":"sphere_fxaa23","username":"edwardbraed","description":"Simple realization fxaa","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","sphere","fxaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define gray(rgb) (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114)\n\nvec3 fxaa(sampler2D tex, vec2 uv, vec2 ts, float k)\n{\n    float bv = 0.0;\n    float hk = k * 0.5;\n    for(float x = 0.0 - hk; x < hk; x += 1.0)\n    {\n        for(float y = 0.0 - hk; y < hk; y += 1.0)\n        {\n            vec2 buv = uv + ts * vec2(x,y);\n            vec3 t1 = texture(tex, buv + vec2( 1.0,  0.0) * ts).rgb;\n            vec3 t2 = texture(tex, buv + vec2(-1.0,  0.0) * ts).rgb;\n            vec3 t3 = texture(tex, buv + vec2( 0.0,  1.0) * ts).rgb;\n            vec3 t4 = texture(tex, buv + vec2( 0.0, -1.0) * ts).rgb;\n            \n            vec3 r = abs(t1 - t2 + t3 - t4) + abs((t1 + t4) - (t2 + t3));\n\n            bv += round(gray(r) + FXAA_FILTER);\n        }\n    }\n    \n    bv = min(bv, 1.0);\n    //return vec3(bv); // uncomment to see bevel\n    \n    k = k * bv + 1.0;\n    hk = k * 0.5;\n    vec3 avg = vec3(0.0);\n    for(float x = 0.0 - hk; x < hk; x += 1.0)\n    {\n        for(float y = 0.0 - hk; y < hk; y += 1.0)\n            avg += texture(tex, uv + ts * vec2(x,y)).rgb;\n    }\n    return avg / (k * k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv = uv * DOWN_SIZE;\n    vec2 ts = (1.0 / iResolution.xy) * DOWN_SIZE; // texel step\n    \n    vec3 col = texture(iChannel0, suv).rgb;\n    if(uv.x > 0.5)\n        col = fxaa(iChannel0, suv, ts, FXAA_KERNEL);\n        \n    col *= smoothstep(0.0, 0.003, abs(uv.x - 0.5));\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\nvec4 raymarch(vec3 ro, vec3 rd, vec3 lv, float g)\n{\n    float t = 0.0;\n    \n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + rd * t;\n        float d = length(pos) - SPHERE_RADIUS;\n        if(d < 0.001)\n        {\n            vec3 chp = floor(pos / CHECKER_SIZE);\n            float ch = mod(chp.x + chp.y, 2.0) * 0.1;\n    \n            float l = dot(normalize(lv), normalize(pos));\n            return vec4(COLOR * max(l, 0.2) - ch, 1.0);\n        }\n        \n        t += d;\n    }\n    \n    return vec4(g * BACK_COLOR, 0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * (1.0 / DOWN_SIZE);\n    \n    // aspect ratio for correction rays..\n    vec2 aspect = calcAspect(iResolution.xy);\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y) * aspect,\n                   1.0);\n    \n    // origin direction (or pseudo camera position)\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    // light vector\n    vec3 lv = vec3(sin(iTime), 0.5, cos(iTime));\n    // background gradient\n    vec2 chp = floor(uv / BACK_CHECKER_SIZE);\n    float ch = mod(chp.x + chp.y, 2.0) * 0.02;\n    float g = pow(1.0 - distance(uv, vec2(0.5)), 2.0) * 0.7 - ch;\n    \n    // Output to screen\n    fragColor = raymarch(ro, rd, lv, g);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DOWN_SIZE 0.5\n#define FXAA_KERNEL 6.0\n#define FXAA_FILTER 0.45\n\n#define MAX_STEPS_MARCH 64\n#define SPHERE_RADIUS 0.6\n#define COLOR vec3(0.9, 1.0, 0.3)\n#define BACK_COLOR vec3(0.2, 1.0, 0.7)\n\n#define CHECKER_SIZE 0.25\n#define BACK_CHECKER_SIZE vec2(0.03, 0.05)","name":"Common","description":"","type":"common"}]}