{"ver":"0.1","info":{"id":"MclXWl","date":"1707732509","viewed":31,"name":"[inspirnathan] 10 - PhongReflect","username":"hrst4","description":"[inspirnathan] 10 - PhongReflect","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\n#define PART 3\n/*\nBonjour, chers amis ! Bienvenue dans la partie 11 de ma série de tutoriels Shadertoy. \nDans ce tutoriel, nous allons apprendre à rendre nos objets 3D un peu plus réalistes \nen utilisant un modèle d'éclairage amélioré appelé modèle de réflexion Phong.\n\n# Le modèle de réflexion Phong\n\nDans la partie 6 de cette série de tutoriels, nous avons appris à colorer des objets 3D \nen utilisant la réflexion diffuse ou réflexion lambertienne. \nNous avons utilisé ce modèle d'éclairage jusqu'à présent, mais il est un peu limité.\n\nLe modèle de réflexion Phong, nommé d'après son créateur, Bui Tuong Phong, est parfois appelé\n\"éclairage Phong\" ou \"éclairage Phong\". \n\nIl se compose de trois parties : l'éclairage ambiant, la réflexion diffuse (réflexion lambertienne) \net la réflexion spéculaire.\nhttps://inspirnathan.com/_nuxt/img/img-1.56a52b7.png\n\nLe modèle de réflexion de Phong fournit une équation permettant de calculer\nl'éclairement en chaque point d'une surface, I_p.\nhttps://inspirnathan.com/_nuxt/img/img-2.2ebb226.png\n\nCette équation peut sembler complexe, mais je vais en expliquer chaque partie ! \nCette équation est composée de trois parties principales : ambiante, diffuse et spéculaire.\nL'indice \"m\" indique le nombre de lumières dans notre scène.\nPour l'instant, nous supposerons qu'il n'existe qu'une seule lumière.\n\nLa première partie représente le terme de lumière ambiante. \nDans le code GLSL, il peut être représenté par ce qui suit :\n\n\nfloat k_a = 0.6; // a value of our choice, typically between zero and one\nvec3 i_a = vec3(0.7, 0.7, 0); // a color of our choice\n\nvec3 ambient = k_a * i_a;\n\nLa valeur k_a est la constante de réflexion ambiante, le rapport de réflexion du terme ambiant\nprésent en tous points de la scène rendue.\n\nLa valeur i_a contrôle l'éclairage ambiant et est parfois calculée comme une somme des contributions \nde toutes les sources lumineuses.\n\nLa deuxième partie de l'équation de réflexion de Phong représente le terme de réflexion de la diffusion.\nDans le code GLSL, il peut être représenté comme suit :\n\nvec3 p = ro + rd * d; // point on surface found by ray marching\nvec3 N = calcNormal(p); // surface normal\nvec3 lightPosition = vec3(1, 1, 1);\nvec3 L = normalize(lightPosition - p);\n\nfloat k_d = 0.5; // a value of our choice, typically between zero and one\nvec3 dotLN = dot(L, N);\nvec3 i_d = vec3(0.7, 0.5, 0); // a color of our choice\n\nvec3 diffuse = k_d * dotLN * i_d;\n\nLa valeur, k_d, est la constante de réflexion diffuse, le rapport de réflexion du terme diffus\nde la réflectance lambertienne de la lumière entrante. \n\nLa valeur, dotLN, est la réflexion diffuse que nous avons utilisée dans les tutoriels précédents. \nElle représente la réflexion lambertienne. La valeur i_d est l'intensité d'une source lumineuse\ndans votre scène, définie par une valeur de couleur dans notre cas.\n\nLa troisième partie de l'équation de réflexion de Phong est un peu plus complexe.\nElle représente le terme de réflexion spéculaire. \nDans la réalité, les matériaux tels que les métaux et les surfaces polies présentent\nune réflexion spéculaire qui semble plus brillante en fonction de l'angle de la caméra\nou de l'endroit où le spectateur fait face à l'objet. \n\nCe terme est donc fonction de la position de la caméra dans notre scène.\nhttps://inspirnathan.com/_nuxt/img/img-4.44993f1.png\n\nDans le code GLSL, il peut être représenté comme suit :\n\nvec3 p = ro + rd * d; // point on surface found by ray marching\nvec3 N = calcNormal(p); // surface normal\nvec3 lightPosition = vec3(1, 1, 1);\nvec3 L = normalize(lightPosition - p);\n\nfloat k_s = 0.6; // a value of our choice, typically between zero and one\n\nvec3 R = reflect(L, N);\nvec3 V = -rd; // direction pointing toward viewer (V) is just the negative of the ray direction\n\nvec3 dotRV = dot(R, V);\nvec3 i_s = vec3(1, 1, 1); // a color of our choice\nfloat alpha = 10.;\n\nvec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\nLa valeur k_s est la constante de réflexion spéculaire, le rapport de réflexion du terme spéculaire\nde la lumière entrante.\n\nLe vecteur R est la direction que prendrait un rayon de lumière parfaitement réfléchi\ns'il rebondissait sur la surface.\nhttps://inspirnathan.com/_nuxt/img/img-5.52476e5.png\n\nSelon Wikipedia, le modèle de réflexion de Phong calcule la direction du rayon réfléchi\nà l'aide de la formule suivante.\n\nhttps://inspirnathan.com/_nuxt/img/img-6.c1d2bf7.png\n\nComme indiqué précédemment, l'indice \"m\" fait référence au nombre de lumières dans notre scène. \nLe petit chapeau, ^, au-dessus de chaque lettre signifie que nous devons utiliser \nla version normalisée de chaque vecteur.\n\nLe vecteur L fait référence à la direction de la lumière. \nLe vecteur N fait référence à la normale de la surface.\n\nGLSL fournit une fonction pratique appelée reflect qui calcule pour nous la direction \ndu rayon réfléchi à partir du rayon incident. \n\nCette fonction prend deux paramètres : le vecteur de direction du rayon incident et le vecteur normal.\n\nEn interne, la fonction reflect est égale à I - 2.0 * dot(N, I) * N \noù I est la direction du rayon incident et N le vecteur normal.\n\nSi l'on multiplie cette équation par -1, on obtient la même équation que l'équation\nde réflexion de Wikipedia. Tout est une question de conventions d'axes.\n\nLe vecteur V, dans l'extrait de code pour la réflexion spéculaire,\nreprésente la direction pointant vers l'observateur ou la caméra. \n\nIl peut être égal à la valeur négative de la direction du rayon, rd.\n\nLe terme alpha est utilisé pour contrôler le degré de \"brillance\" de la sphère.\nUne valeur plus faible la fait paraître plus brillante.\n\n# La mise en place de l'ensemble\n\nRassemblons dans notre code tout ce que nous avons appris jusqu'à présent. \nNous commencerons avec une simple sphère dans notre scène et utiliserons\nun point d'observation pour notre modèle de caméra, comme nous l'avons appris dans la partie 10.\n\n*/\n#if PART == 0\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 0, 3);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd);\n  \n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * d;\n      vec3 normal = calcNormal(p);\n      vec3 lightPosition = vec3(2, 2, 7);\n      vec3 lightDirection = normalize(lightPosition - p);\n\n      float diffuse = clamp(dot(lightDirection, normal), 0., 1.);\n\n      col = diffuse * vec3(0.7, 0.5, 0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLorsque vous exécutez le code, vous devriez voir une simple sphère dans la scène avec un éclairage diffus.\nhttps://inspirnathan.com/_nuxt/img/img-7.2e46e86.png\n\nMais c'est ennuyeux. Nous voulons une sphère brillante ! \nActuellement, nous ne colorons la sphère qu'en fonction de l'éclairage diffus \nou de la réflexion lambertienne. \n\nAjoutons une composante ambiante et spéculaire pour compléter le modèle de réflexion Phong.\nNous allons également ajuster un peu la direction de la lumière, afin d'obtenir une brillance\nsur la partie supérieure droite de la sphère.\n\n*/\n\n#elif PART == 1\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 0, 3);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd);\n  \n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * d; // point on surface found by ray marching\n      vec3 normal = calcNormal(p); // surface normal\n\n      // light\n      vec3 lightPosition = vec3(-8, -6, -5);\n      vec3 lightDirection = normalize(lightPosition - p);\n\n      // ambient\n      float k_a = 0.6;\n      vec3 i_a = vec3(0.7, 0.7, 0);\n      vec3 ambient = k_a * i_a;\n\n      // diffuse\n      float k_d = 0.5;\n      float dotLN = clamp(dot(lightDirection, normal), 0., 1.);\n      vec3 i_d = vec3(0.7, 0.5, 0);\n      vec3 diffuse = k_d * dotLN * i_d;\n\n      // specular\n      float k_s = 0.6;\n      float dotRV = clamp(dot(reflect(lightDirection, normal), -rd), 0., 1.);\n      vec3 i_s = vec3(1, 1, 1);\n      float alpha = 10.;\n      vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\n      // final sphere color\n      col = ambient + diffuse + specular;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nComme précédemment, nous bloquons le résultat de chaque produit en points, de sorte que la valeur\nsoit comprise entre zéro et un. \nLorsque nous exécutons le code, nous devrions voir la sphère briller un peu dans la partie\nsupérieure droite de la sphère.\nhttps://inspirnathan.com/_nuxt/img/img-8.8f233d3.png\n\n# Plusieurs lumières\n\nVous avez peut-être remarqué que l'équation de réflexion de Phong utilise une sommation \npour les composantes diffuse et spéculaire. \n\nSi vous ajoutez d'autres lumières à la scène, vous aurez une composante diffuse \net une composante spéculaire pour chaque lumière.\nhttps://inspirnathan.com/_nuxt/img/img-2.2ebb226.png\n\nPour faciliter la gestion des lumières multiples, nous allons créer une fonction phong.\nComme cette scène ne colore qu'un seul objet, nous pouvons placer les coefficients de réflexion \n(k_a, k_d, k_s) et les intensités dans la fonction phong également.\n\n\n*/\n\n#elif PART == 2\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd) {\n  // ambient\n  float k_a = 0.6;\n  vec3 i_a = vec3(0.7, 0.7, 0);\n  vec3 ambient = k_a * i_a;\n\n  // diffuse\n  float k_d = 0.5;\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 i_d = vec3(0.7, 0.5, 0);\n  vec3 diffuse = k_d * dotLN * i_d;\n\n  // specular\n  float k_s = 0.6;\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 i_s = vec3(1, 1, 1);\n  float alpha = 10.;\n  vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\n  return ambient + diffuse + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 0, 3);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd);\n  \n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * d; // point on surface found by ray marching\n      vec3 normal = calcNormal(p); // surface normal\n\n      // light #1\n      vec3 lightPosition1 = vec3(-8, -6, -5);\n      vec3 lightDirection1 = normalize(lightPosition1 - p);\n      float lightIntensity1 = 0.6;\n      \n      // light #2\n      vec3 lightPosition2 = vec3(1, 1, 1);\n      vec3 lightDirection2 = normalize(lightPosition2 - p);\n      float lightIntensity2 = 0.7;\n\n      // final sphere color\n      col = lightIntensity1 * phong(lightDirection1, normal, rd);\n      col += lightIntensity2 * phong(lightDirection2, normal , rd);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nNous pouvons multiplier le résultat de la fonction phong par des valeurs d'intensité lumineuse \nafin que la sphère n'apparaisse pas trop brillante.\nLorsque vous exécutez le code, votre sphère devrait être plus brillante !!!\n\n# Coloriage d'objets multiples\nPlacer tous les coefficients de réflexion et les intensités dans la fonction phong n'est pas très pratique. \nVous pouvez avoir plusieurs objets dans votre scène avec différents types de matériaux. \nCertains objets peuvent apparaître brillants et réfléchissants, tandis que d'autres objets n'ont \nque peu ou pas de réflexion spéculaire.\n\nIl est plus logique de créer des matériaux qui peuvent être appliqués à un ou plusieurs objets.\nChaque matériau aura ses propres coefficients pour les composantes ambiantes, diffuses et spéculaires.\nNous pouvons créer une structure pour les matériaux qui contiendra toutes les informations nécessaires\nau modèle de réflexion Phong.\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nEnsuite, nous pourrions créer une autre structure pour chaque surface ou objet de la scène.\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance value from SDF\n  Material mat; // material of object\n}\n\nNous allons créer une scène avec un sol carrelé et deux sphères.\nTout d'abord, nous allons créer trois matériaux. \nNous allons créer une fonction gold qui renvoie un matériau gold, une fonction silver qui renvoie\nun matériau silver, et une fonction checkerboard qui renvoie un motif checkerboard.\nComme vous pouvez vous y attendre, le motif en damier ne sera pas très brillant, mais les métaux le seront !\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nNous allons créer une fonction opUnion qui agira de manière identique à la fonction minWithColor \nque nous avons utilisée dans les tutoriels précédents.\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nNotre scène utilisera la fonction opUnion pour ajouter le sol carrelé et les sphères à la scène :\n\nSurface scene(vec3 p) {\n  Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n  Surface sSphereGold = Surface(2, sdSphere(p - vec3(-2, 0, 0), 1.), gold());\n  Surface sSphereSilver = Surface(3, sdSphere(p - vec3(2, 0, 0), 1.), silver());\n  \n  Surface co = opUnion(sFloor, sSphereGold);\n  co = opUnion(co, sSphereSilver);\n  return co;\n}\n\nNous allons ajouter un paramètre à la fonction phong qui accepte un matériau.\nCe matériau contiendra toutes les valeurs de couleur dont nous avons besoin \npour chaque composant du modèle de réflexion Phong.\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\nDans la fonction mainImage, nous pouvons transmettre le matériau de l'objet le plus proche\nà la fonction phong.\n\n\ncol = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat);\ncol += lightIntensity2 * phong(lightDirection2, normal , rd, co.mat);\n\nEn mettant tout cela ensemble, nous obtenons le code suivant.\n\n*/\n\n#elif PART == 3\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n  Surface sSphereGold = Surface(2, sdSphere(p - vec3(-2, 0, 0), 1.), gold());\n  Surface sSphereSilver = Surface(3, sdSphere(p - vec3(2, 0, 0), 1.), silver());\n  \n  Surface co = opUnion(sFloor, sSphereGold); // closest object\n  co = opUnion(co, sSphereSilver);\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = mix(vec3(1, .341, .2), vec3(0, 1, 1), uv.y) * 1.6;\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 0, 5);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n  \n  if (co.sd > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n      vec3 normal = calcNormal(p); // surface normal\n\n      // light #1\n      vec3 lightPosition1 = vec3(-8, -6, -5);\n      vec3 lightDirection1 = normalize(lightPosition1 - p);\n      float lightIntensity1 = 0.9;\n      \n      // light #2\n      vec3 lightPosition2 = vec3(1, 1, 1);\n      vec3 lightDirection2 = normalize(lightPosition2 - p);\n      float lightIntensity2 = 0.5;\n\n      // final color of object\n      col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat);\n      col += lightIntensity2 * phong(lightDirection2, normal , rd, co.mat);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Conclusion\nDans cette leçon, nous avons appris comment le modèle de réflexion Phong peut réellement améliorer\nl'aspect de notre scène en ajoutant un peu d'éclat ou de brillance à nos objets. \nNous avons également appris à assigner différents matériaux à chaque objet de la scène en utilisant\ndes structures. Créer des shaders est vraiment amusant !\n*/\n\n\n#endif","name":"Image","description":"","type":"image"}]}