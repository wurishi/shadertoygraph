{"ver":"0.1","info":{"id":"ctsSzS","date":"1674970029","viewed":93,"name":"Pi Wine π","username":"ianertson","description":"Would you like some π wine?","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","pi","bottle","wine","piwine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO min(0, int(iTime))\n\n\n#define NEAR 0.03\n#define FAR 100.0\n#define STEPS 64\n\nvec3 noise(vec3 p) {\n    return texture(iChannel3, p).xyz;\n}\n\nfloat noise(vec2 p) {\n    return texture(iChannel3, vec3(p, 1.)).x;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    vec3 spec;\n    float dist;\n    float depth;\n    float ior;\n    int id;\n    int skip;\n    bool shadow;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.);\n    data.normal = vec3(0.);\n    data.uv = vec2(0.);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.id = 0;\n    data.skip = 0;\n    data.ior = 0.0;\n    data.shadow = false;\n    data.spec = vec3(0.);\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat planeSDF(vec3 p, vec3 n) {\n    return dot(p, n)+0.5;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOTTLE 2\n#define ID_BOTTLE_CAP 3\n\nfloat bottleSDF(in int skip, inout int part, vec3 p) {\n    float band1 = 0.3*smoothstep(1.0-(p.y*0.3), 1.7, 1.7/p.y);\n    float bands = band1;\n    float bottle = cylinderSDF(p, vec3(0.), vec3(0, 2., 0), bands);\n    \n    float cap = cylinderSDF(p, vec3(0.0, 2.0, 0.0), vec3(0.0, 2.+0.14, 0.0), 0.05);\n    \n\n    part = ID_BOTTLE;\n    \n    float minDist = FAR;\n    if (skip != ID_BOTTLE_CAP && cap < minDist) { part = ID_BOTTLE_CAP; minDist = cap; };\n    if (skip != ID_BOTTLE && bottle < minDist) { part = ID_BOTTLE; minDist = bottle; };\n    \n    return minDist;\n}\n\n\n\nfloat getDist(inout Data data, vec3 p) {\n    float minDist = FAR;\n    \n    float ground = p.y;\n    \n    int bottlepart = 0;\n    float bottle = bottleSDF(data.skip, bottlepart, p);\n    \n    \n    if (data.skip != ID_GROUND && ground < minDist) { minDist = ground; data.id = ID_GROUND; }\n    if (data.skip != ID_BOTTLE && bottle < minDist) { minDist = bottle; data.id = bottlepart; }\n    \n    return minDist;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    \n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p-e.xyy),\n        getDist(data, p-e.yxy),\n        getDist(data, p-e.yyx)\n    ));\n}\n\nvec2 getUv(in Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    \n    vec2 uv = vec2(0.);\n    uv = mix(uv, p.xz, abs(dot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, abs(dot(n, vec3(1, 0, 0))));\n    uv = mix(uv, p.xy, abs(dot(n, vec3(0, 0, 1))));\n    return uv;\n}\n\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        \n        dist += next;\n        \n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    dist = abs(dist);\n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    data.dist = dist;\n    data.depth = dist / FAR;\n    data.normal = getNormal(data, p);\n    data.uv = getUv(data);\n    \n    return true;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    data.spec = vec3(0.5);\n    vec3 n = noise(vec3(data.uv*0.5, 1.0));\n    \n    \n    vec3 a = vec3(1.0);\n    vec3 b = vec3(0.75, 0.5, 0.3);\n    vec3 c = vec3(0.48);\n  \n    return mix(mix(a, b, n.x), c, n.y);\n    \n    \n    return vec3(n);\n}\n\nvec3 getAlbedoBottle(inout Data data) {\n    float forward = max(0.0, dot(data.normal, vec3(0, 0, -1)));\n    data.spec = vec3(1.);\n    data.ior = 1.47;\n    if (forward > 0.0) {\n        vec2 uv = data.uv;\n      \n        vec3 p = data.point;\n        vec2 pos = vec2(0.2);\n        vec2 siz = vec2(0.4);\n        vec2 mi = pos;\n        vec2 ma = pos+siz;\n        \n        \n        if (p.y < 0.9 && p.y > 0.4) {\n            \n           data.ior = 0.0;\n           uv = p.xy / 16.0;\n           uv.y += 0.005;\n          //  uv.y *= -1.0;\n            uv = uv *2.0 - 1.0;\n            uv.x -= 0.1;\n            vec4 f = texture(iChannel2, uv+vec2(11.0 / 16.0, 6.0 / 16.0)).rgba;\n            \n            data.spec *= max(0.0, f.r*0.25);\n            \n            return mix(vec3(1.0), vec3(0.0), f.r);\n            \n        }\n    }\n    \n    \n    return vec3(0.2, 0.8, 0.1);\n}\n\nvec3 getAlbedoBottleCap(inout Data data) {\n    vec3 n = noise(vec3(data.uv*2., 1.0));\n    return vec3(0.89, 0.79, 0.3) * n.x;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOTTLE: return getAlbedoBottle(data); break;\n        case ID_BOTTLE_CAP: return getAlbedoBottleCap(data); break;\n    }\n    \n    return vec3(1, 0, 0);\n}\n\nbool render(vec3 ro, vec3 rd, inout Data data, inout vec3 col) {\n    bool hit = false;\n    vec3 blue = vec3(0.2, 0.56, 0.9);\n    if (march(ro, rd, data)) {\n        hit = true;\n\n\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n\n        Light light = Light(vec3(1., 6., -1.), vec3(0.7, 0.6, 0.2), 16.);\n\n        vec3 p = data.point;\n        vec3 n = data.normal;\n        vec2 uv = data.uv;\n        vec3 L = normalize(data.point - light.pos)*-1.;\n        vec3 r = reflect(rd, n);\n        float dl = distance(data.point, light.pos);\n\n        float NdotL = max(0.0, dot(n, L));\n        float VdotR = max(0.0, dot(-rd, r));\n\n        float spec = pow(VdotR, 32.0);\n\n        float att = NdotL * (\n            pow(light.strength, 2.0) / max(0.001, pow(dl, 2.0))\n        );\n\n        if (data.shadow) {\n            Data shadowData;\n            dataInit(shadowData);\n            shadowData.skip = data.id;\n            if (march(p, L, shadowData)) {\n                att /= TAU;\n            }\n        }\n\n        col += (diffuse + (data.spec * spec)) * att;\n\n        \n    } else {\n        data.depth = 1.0;\n    }\n    col += mix(vec3(1.0), blue, clamp(M_PI*max(0.0, dot(rd, vec3(0, 1, 0))), 0.0, 1.0)) * data.depth;\n    return hit;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0, 1.0, -3.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n\n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        rd.yz *= rot(m.y*TAU);\n\n        ro.xz *= rot(m.x*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else if (iFrame > 30) {\n        float moveT = T;\n        ro.xz *= rot(moveT);\n        rd.xz *= rot(moveT);\n    }\n    \n    rd = normalize(rd);\n    \n    Data data;\n    dataInit(data);\n    data.shadow = true;\n    \n    if (render(ro, rd, data, col) && data.ior > 0.01) {\n        float IOR = 1.47;\n        vec3 r = normalize(refract(rd, data.normal, 1.0/IOR));\n        \n        \n        vec3 pp = data.point;\n        float band = 0.3*smoothstep(1.0-(pp.y*0.3), 1.7, 1.7/pp.y);\n        float eps = band;\n        vec3 enterColor = vec3(0.);\n        vec3 p = data.point-(data.normal*eps);\n        dataInit(data);\n        data.skip = ID_GROUND;\n\n        if (render(p, r, data, enterColor) || true) {\n            \n            vec3 r = normalize(refract(rd, data.normal, IOR));\n            vec3 p = data.point;\n            dataInit(data);\n            data.skip = ID_BOTTLE;\n\n            vec3 exitColor = vec3(0.0);\n            if (render(p, r, data, exitColor) || true) {\n               //col *= enterColor;\n        \n                col *= pow(enterColor+exitColor, vec3(2.0));\n\n            }\n        }\n    }\n    \n    col /= vec3(0.53818) + col;\n    col = pow(col, vec3(1.0 / 2.0));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}