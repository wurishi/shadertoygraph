{"ver":"0.1","info":{"id":"X3GGW3","date":"1718285854","viewed":378,"name":"yoke 枷锁 - mouse","username":"shadertoyjiang","description":"yoke编织辫链交\nMouse over round spots to see all partitions ","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["mouse","sdf","line","color","rotate","distance","icosahedron","dodecahedron","skin","brush","20","rust","chain","rope","12","braid","siege","yoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 2024-4-23\n// \n#define m0 .0001  // 质量 .01 .001 .0001\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nvec4 clr; int obj;\nivec3 mri ; \n\n\nvoid bk(out vec4 O, vec2 p)\n{\n\tvec2 R = iResolution.xy;    \n\tfloat c = 1.5 - length(p = (p + p - R) / R.y * .7) ,\n\t      f, i,  s = 1.;\n    while(i++<8.)          \n           s /= f = dot(p,p) ,           \n           p = -p.yx / f,            \n           p.x=fract(p.x)-.5,                               \n    f = min( 9., (length(p) - .15) / s * 226. );          \n    O=.4+vec4(clamp(f,0.,1.)-.5)*.1*(mri.x==2?-1.:1.);\n    //\n    if(mri.z==15)  O=clamp(1.-abs(.4-O)*25.,0.,1.)+O;\n    O=clamp(O,0.,1.);\n}\n\n// 铁链\nfloat dlian(vec3 p)\n{\n        p.x = p.x / 3.1415926 ;\n        p.yz *= rot(3.14159265/4.);\n        float r = .05, R=.15, a, b, sz=3.;\n        p.yz /= sz;\n        if(r>.25)r=.25;  if(R>.25-r)R=.25-r;\n        \n        vec4 o,x;o.y=.5;x = p.x+o - round(p.x+o);\n        x = max(abs(x) - (.25-R+r), 0.);x.zw=p.yz;\n        a = length(vec2(length(x.xz)-R, x.w))-r,\n        b = length(vec2(length(x.yw)-R, x.z))-r;\n        return min(a,b)*sz;\n}\n\n// 链子 \nvec3 braid3(vec3 p)\n{        \n        vec3 y = p.y - .6*cos(    p.x+vec3(0,2,4)),\n             z = p.z - .1*cos(p.x+p.x+vec3(1,5,3)),\n             r = y*y+z*z, \n             e = vec3(1),\n             a;\n             \n        r=step(r,r.yzx)*step(r,r.zxy);\n        \n        a=vec3(dot(e, y*r),\n               dot(e, z*r),\n               p.x);\n        return p.yzx-a;\n}        \n\n\nfloat braidx(vec3 p)\n{\n        vec3 v,q=p;\n        float i=0.,n=2., a=2.;\n        if(mri.x==2)n=3.;\n        for(;i++<n;)\n        {\n              v=braid3(q);\n              q.yz-=v.xy;\n              q*=a;\n        }\n        return (length(q.yz)-.5)/(a*++n);\n}\n\nfloat txb(vec3 a, vec3 b, vec3 r, float x)\n{// 辫子表面\n       vec2 u = vec2(a.x, b.x); float m = r.x, y;\n       if(r.y<m)m=r.y, u=vec2(a.y, b.y);\n       if(r.z<m)m=r.z, u=vec2(a.z, b.z);\n       y = atan(u.y, u.x)/6.28+.5;\n       y = y * 20.*1.;\n       x = x * 20.*1.;\n       return 1.-((cos(x)*cos(y))/2.+.5)* 1.;    //.25;              \n}\n\n// \nfloat braid(vec3 p)\n{\n        if(mri.y>1)return braidx(p);\n        if(mri.x==1)return dlian(p);\n        \n        vec3 y = p.y - .6*cos(    p.x+vec3(0,2,4)),\n             z = p.z - .1*cos(p.x+p.x+vec3(1,5,3)),\n             r = sqrt(y*y+z*z)-.2;\n        \n        return min(r.x, min(r.y, r.z)) \n               *(mri.x>0 && mri.x<3 ? txb(y,z,r,p.x) : 1. );\n}\n\n\nfloat sd12(vec3 p)  \n{\n        obj = -1;\n        float rx=length(p)-1.25;if(rx>.1)return rx;\n        vec3 a = normalize(sqrt(vec3(.5-.1*sqrt(5.), 0., .5+.1*sqrt(5.)))),\n             b = a.yzx, \n             c = a.zxy,\n             e = normalize(vec3(1)),  \n             ac = normalize(a-c),\n             ba = normalize(b-a),         \n             n = normalize(cross(c-b, b+c)); // c-b == cross(e, a)\n                \n        float sg = 1., x, y, ang,r = .1, d, d1, d2, d3;\n        \n        // 正二十面体的旋转折叠\n        for(int i;i++<9;n=n.yzx)\n              if(dot(p, n)<0.)p=reflect(p, n),sg=-sg;\n        n=ba; if(dot(p, n)<0.)p=reflect(p, n),sg=-sg;\n        n=ac; if(dot(p, n)<0.)p=reflect(p, n),sg=-sg;\n        n=ba; if(dot(p, n)<0.)p=reflect(p, n),sg=-sg;\n        \n        float aa=2.,  bb=1.08, md;\n        if(mri.y%2<1) aa=.97, bb=3.;\n        md = max(dot(p-e*aa,e),  length(p) //  /pow(dot(normalize(p),e), 1.2*0.*cos(iTime*0.))\n                                            -bb*length(a));obj=3;\n        // 20  20 红表面\n        md += length(p*15.*sg-round(p*15.*sg))*(.02-0.);\n        if(md<m0)return md;\n        \n        for(int i;i++<2;p=p.zxy)\n        {\n                vec3 az = c,\n                     ay = ba ,//= normalize(b-a), \n                     ax = normalize(cross(az, ay)),             \n                     w = vec3(dot(p, ax), dot(p, ay),dot(p, az));\n                \n                ang = atan(w.y, w.x);\n                y = w.z-.8;\n                x = length(w.xy);\n                \n                x = x - .7 - pow(2., .5+.5*sin(sg * ang * 5.+.4))*r;\n                //x = x - .8 - ( .5+.5*sin(sg * ang * 5.+.4))*.2;\n                \n                d = sqrt(x*x+y*y)-r*1.3;//-r*1.3-.3;\n                if(mri.x>2)  if(abs(d)<md)md=abs(d), obj = 1;\n                if(d<.1)\n                {\n                        vec3 c3=(a+b+c)/3.;\n                        vec2 n=normalize(abs(vec2(length(c-c3), length(c3)))),\n                        ct = vec2(x,y) * mat2(n.x, -n.y, n.y, n.x);                                                \n                        d1 =braid(vec3(ang*sg*10.+iTime*7.2368, ct/r))*r;\n                        if(d1<md)md=d1, obj=2;  \n                }else{\n                        md = min(md, d+.1);\n                }\n        }\n        return md; \n}\n\n\n// \nfloat map(vec3 p)\n{\n        float t = (iTime+6.)*.15;\n        p.xy *= rot(t   );\n        p.yz *= rot(t*.7);\n        p.zx *= rot(t*.3);\n        return sd12(p);\n}\n\n\n// 软阴影\nfloat softshadow(vec3 ro, vec3 rd)\n{\n   float res = 1.;\n   float t=.05, k = 1.5;  // .1 1.3\n   for(int i =0;i<126 && t<.5;i++) // 26\n   {\n               float h = map(ro + rd * t);\n               if(obj<2)h=999.;\n               if(h<.003){   return 0.;}\n               res = min(res, k*h/t);               \n               t += h;\n   }\n   return (res+.3)/1.3;\n}\n\n// 鼠标功能\nvoid drawms(inout vec4 O, vec2 U, vec2 M)\n{        \n        \n        float r = .2, p = .1, d, md=1e8;\n        bool inr;\n        vec2 R = iResolution.xy,\n             k = R/R.y,\n             u = (U+U-R)/R.y,v,\n             m = (M+M-R)/R.y,\n             c = (vec2(1,-1)*(1.-(r+p)/k ))*k;\n        \n        md = abs(d=length(u-c)-r);\n        if(length(m-c)<r)\n        {\n              v = abs((u/k*2.-round(u/k*2.)) /2.*k);\n              md = min(md, min(v.x,v.y));\n              if(d<0.)O.x+=.4;\n              mri *= -1;\n              inr=true;\n        }\n        \n        if(d<0.) O.y+=.4;\n        if(inr==true)O +=  1e2*exp(-1e3 * md);\n        else         O.x  += exp(-200. * md);\n        //if(length(m-c)<r) O.yz-=1.-O.x;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        mri = ivec3(iMouse.xyz / iResolution * 4.);  mri.z = mri.y * 4 + mri.x;\n        drawms(O,U,iMouse.xy);\n        O = vec4(.5); clr++;\n        \n        vec2 R = iResolution.xy,\n             u = (U+U - R) / R.y;\n        vec3 eye = vec3(0, 0, -3),\n             dir = normalize(vec3(u, 2)),\n             sun = 5. * ( .12*cos((iTime*0.+11.)*1.+ 0.+vec3(7,11,13)) + vec3(-1,2,-3)/3. ),\n             eps = vec3(0, .0001, 0),\n             nor, p, \n             sp, ep;\n        float d , t, ccc, ln, er, sha=1., sha2=1., lnu = length(u);\n        bool ht;\n        if(lnu>.8)bk(O, U);\n        if(lnu<1.){//04242201 提速大于三分之一\n        for(int i; i++<128 && t<4.;)\n        {\n                p = eye + dir * t;\n                d = map(p);\n                if( d<m0 && obj>1) // if( d<.01)\n                {       // phong 光照模型\n                        sp = normalize(sun-p), ep=normalize(eye-p);\n                        sha = softshadow(p-dir*d, sp);\n                        //sha=sqrt(sha);\n                        nor = normalize(vec3(map(p+eps.yxx), map(p+eps), map(p+eps.xxy))-d); \n                        ln = max(0., dot(nor,sp)),               // light norm\n                        er = max(0., dot(ep, reflect(-sp,nor))); // eye ray\n                //}                \n                //if( d<.01 && obj>1)\n                //{\n                        float ambt=.3, difu=.6, spec=80.;\n                        vec4  lightClr = vec4(er*er,ln*.9, .55, 1);// *.8+.2;// .5, 1) *.8+.2;//*clr;//.zyxw  .5 .55 .6 .53 .65  .53*1+0\n                        if(obj==3)lightClr=vec4(1.5,ln*.75, er*.75, 1)*1.+.3;\n                        O = lightClr *sha*(ambt + (difu*ln + pow(er, spec))) ;O *= clr;                        \n                        if(mri.z==5 && obj==3)O=sqrt(O);\n                        if(mri.z==1)O=sqrt(O);\n                        ht=true;\n                        break;\n                }\n                \n                if(d<m0 && obj==1) \n                                     ccc+=.1-ln*.1, sha2=sha  ;\n                t += max(d * .8, m0); // .02 大了像破碎\n        }\n        O.yz+=ccc*.2*sha2;\n        }\n        if(mri.z== 9 && ht==ht)O*=ln*0.+sha+0.*er+.1,O=pow(O,O)*.99;\n        if(mri.z==14)O=sqrt(O);\n        if(mri.z==13 && ht==true)O=pow(vec4(sha),1.-O);\n        // O=sqrt(O);\n        if(mri.z==0)O = pow(max(O,0.), vec4(.71));\n        drawms(O,U,iMouse.xy);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}