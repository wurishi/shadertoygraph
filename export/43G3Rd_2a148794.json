{"ver":"0.1","info":{"id":"43G3Rd","date":"1718044610","viewed":60,"name":"Subtracting slices wobble","username":"gimulnautti","description":"Wobbling by changing the camera matrix for each row","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","texture"],"hasliked":0,"parentid":"4Xc3R7","parentname":"Row-based wobbler"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),    vec3(.0,ca,sa),   vec3(.0,-sa,ca));}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),   vec3(-sa,.0,ca));}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\n\nvec2 polarCoordinates(in vec3 p, in vec3 up, in vec3 right, in vec3 fwd)\n{\n    vec3 rfPlane = vec3(p.x, 0.0, p.z);\n    vec3 n = normalize(rfPlane);\n \n    float dotnright = dot(n, right);\n    float dotnfwd = dot(n, fwd);\n    \n    float angle = acos(dotnright);\n    if (dotnfwd < 0.0) angle = 6.28 - angle;\n    return vec2(angle / 6.28, p.y + 0.5);\n}\n\nfloat sdTorus(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdInvTorus(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return -(length(q) - t.y);\n}\n\nvec2 sdTorusMapped(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 fwd = vec3(0.0, 0.0, 1.0);\n    \n    return vec2(polarCoordinates(p, up, right, fwd).x, polarCoordinates(vec3(q.x, 0.0, q.y), up, right, fwd).x);\n}\n\nfloat sdSphere(in vec3 p, in float s)\n{\n    return length(p) - s;\n}\n\nvec2 sdSphereMapped(in vec3 p, in float s)\n{\n    return polarCoordinates(p, vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 repeat(in vec3 pos, in vec3 s)\n{\n    return pos - s*round(pos / s);\n}\n\nfloat opSubtraction(in float d1, in float d2)\n{\n    return max(d1,-d2);\n}\n\nfloat map(in vec3 pos )\n{\n    //vec3 s = vec3(1.5, 1.3, 1.3);\n    vec3 rep1 = vec3(6.0,5.0,6.0);\n    float d1 = sdInvTorus(repeat(pos, rep1), vec2(2.5, 1.7));\n    \n    vec3 rep2 = vec3(10.0,10.0,10.0);\n    vec3 bsize = vec3(6.,6.,2.);\n    vec3 boffset = vec3(0., 0., 5. * sin(iTime * 0.3));\n    \n    float d2 = sdBox(repeat(boffset + pos * rotate_x(iTime * 0.1), rep2), bsize);\n    \n    vec3 bsize2 = vec3(2.,6.,6.);\n    float d3 = sdBox(repeat(boffset + pos * rotate_x(iTime * 0.1), rep2), bsize2);\n    \n    float d = opSubtraction(opSubtraction(d1, d2), d3);\n    \n    return d;\n    //return sdInvTorus(pos, vec2(2.5, 2.0));\n    //return sdTorus(repeat(pos, s), vec2(0.4, 0.21));\n    //return sdSphere(repeat(pos, s), 0.5);\n}\n\nvec2 texMap(in vec3 pos)\n{\n    //vec3 s = vec3(1.5, 1.3, 1.3);   \n    vec3 s = vec3(6.0,5.0,6.0);\n    return sdTorusMapped(repeat(pos, s), vec2(2.5, 1.7));\n    return sdTorusMapped(pos, vec2(2.5, 2.0));\n    return sdTorusMapped(repeat(pos, s), vec2(0.4, 0.21));\n    return sdSphereMapped(repeat(pos, s), 0.5);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment position  \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera changes per row\t\n\tfloat an = (iTime * 0.1 + p.y * 0.1);\n\tvec3 ro = vec3( 4.2*cos(an * 2.), 0.4, 4.0*sin(an) );\n    vec3 ta = vec3( 2. * cos(iTime * 0.1 + p.x * 0.5), -0.0, 0.0 );\n    \n    //ro = vec3(-1.0,0.0,-1.9);\n    \n    // camera matrix\n    vec3 up = vec3(0.0,0.6,0.5);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, up) );\n    vec3 vv = normalize( cross(uu, ww) );\n   \n    \n\t// create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.2*ww );\n\n    // uv coordinates\n    vec2 uv = vec2(0.0, 0.0);\n\n    // raymarch\n    const float tmax = 150.0;\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if( h<0.001) {\n            // calculate texture lookup on hit\n            uv = texMap(pos) * 0.3 + sin(iTime * 0.02) * vec2(1.0, 1.0);\n            break;\n        }\n        else if ( t > tmax)\n        {\n            break;\n        }\n        t += h;\n    }     \n    \n    // shading\n    vec3 col = vec3(0.0);\n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        float dif = clamp( dot(nor,vec3(0.7,sin(iTime)*1.6,0.4)), 0.0, 1.0 );\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n                       \n        col = ( vec3(0.3,0.4,0.4)*amb + vec3(0.8,0.7,0.5)*dif );  \n        col *= texture(iChannel0, uv).rgb;\n    }\n\n    // gamma        \n    col = sqrt( col );\n\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}