{"ver":"0.1","info":{"id":"lscBR4","date":"1524318739","viewed":716,"name":"In the sky 2D","username":"Ping2_0","description":"Probably a little too blurry, but I like it like that\n\nmodification of www.shadertoy.com/view/4tdSWr\nBuffer A :  3 clouds textures (back, middle, front) using the code by drift\nImage : blur and mix the 3 textures","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","clouds","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n 2D clouds test\n ORIGINAL CODE www.shadertoy.com/view/4tdSWr drift\n*/\n\n/*\n mode :            0 : final result 1 (first try)\n                   1 : back texture \n                   2 : middle texture\n                   3 : front texture\n                  11 : buffer with the 3 textures and alpha\n\t\t\t\t 110 : buffer with the 3 textures and alpha and lod\n                  22 : middle texture with alpha\n                  33 : front texture with alpha\n                 111 : back texture with lod\n                 222 : middle texture with alpha and lod\n                 333 : front texture with alpha and lod\n                 444 : final result 2 - experimental blur mode\n\t\t\t\t 445 : final result 3 - experimental blur mode\n        other values : full buffer with the 3 textures (no alpha, no lod)\n        \n*/\nconst int mode = 445;\n\nconst float[] lod = float[] (1.8, 1.6, 2.5);\n\n\nvec4 blur(in vec2 uv, in float blur, in float lod) {\n    vec2 tex_offset =  (blur) /   iChannelResolution[0].xy; // gets size of single texel\n    return (\n        \t\ttexture(iChannel0, uv, lod)\n\t    \t\t+texture(iChannel0, uv + tex_offset *  vec2(-1,  0), lod)\n\t\t\t\t+texture(iChannel0, uv + tex_offset *  vec2( 1,  0), lod)\n\t\t\t\t+texture(iChannel0, uv + tex_offset *  vec2( 0, -1), lod)\n\t\t\t\t+texture(iChannel0, uv + tex_offset *  vec2( 0,  1), lod)\n\t\t\t\t+texture(iChannel0, uv + tex_offset *  vec2(-1, -1), lod)\n\t\t\t\t+texture(iChannel0, uv + tex_offset *  vec2(-1,  1), lod)\n\t\t\t\t+texture(iChannel0, uv + tex_offset *  vec2( 1, -1), lod)\n\t\t\t\t+texture(iChannel0, uv + tex_offset *  vec2( 1,  1), lod)\n     )/9.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/ iResolution.xy;\n    \n    if(mode==0) {\n        uv/=2.;\n        vec4 result  = texture(iChannel0, uv,              lod[0]);\n        vec4 result1 = texture(iChannel0, uv+vec2(0, 0.5), lod[1]);\n        vec4 result2 = texture(iChannel0, uv+vec2(0.5, 0), lod[2]);\n        result.rgb  = mix(mix(result.rgb, result1.rgb, result1.a), result2.rgb, result2.a);\n        fragColor = vec4(result.rgb,1.0);\n    } else if (mode==1) {\n        fragColor = texture(iChannel0, uv/2.);\n    } else if (mode==2) {\n        fragColor = texture(iChannel0, uv/2.+vec2(0,0.5));\n    } else if (mode==3) {\n        fragColor = texture(iChannel0, uv/2.+vec2(0.5, 0));\n    } else if (mode==11) {\n        if(uv.x > 0.5 && uv.y>0.5) {\n            vec4 result = texture(iChannel0,  uv+vec2(-0.5, -0.5));\n            vec4 result1 = texture(iChannel0, uv+vec2(-0.5,  0.0));\n            vec4 result2 = texture(iChannel0, uv+vec2( 0.0, -0.5));\n            result.rgb  = mix(mix(result.rgb, result1.rgb, result1.a), result2.rgb, result2.a);\n            fragColor = vec4(result.rgb,1.0);\n        } else {\n\t        vec4 r2 = texture(iChannel0, uv); // texture(iChannel0, uv/2.+vec2(0,0.5));\n    \t    fragColor = vec4(mix(vec3(0,1,0), r2.rgb, r2.a), 1);\n        }\n    } else if (mode==110) {\n        if(uv.x > 0.5 && uv.y>0.5) {\n            vec4 result = texture(iChannel0,  uv+vec2(-0.5, -0.5), lod[0]);\n            vec4 result1 = texture(iChannel0, uv+vec2(-0.5,  0.0), lod[1]);\n            vec4 result2 = texture(iChannel0, uv+vec2( 0.0, -0.5), lod[2]);\n            result.rgb  = mix(mix(result.rgb, result1.rgb, result1.a), result2.rgb, result2.a);\n            fragColor = vec4(result.rgb,1.0);\n        } else {\n            vec2 flo = floor(uv*2.);\n            int indice = int(2.*flo.x+flo.y);\n\t        vec4 r2 = texture(iChannel0, uv, lod[indice]);\n    \t    fragColor = vec4(mix(vec3(0,1,0), r2.rgb, r2.a), 1);\n        }\n    } else if (mode==22) {\n        vec4 r2 = texture(iChannel0, uv/2.+vec2(0,0.5));\n        fragColor = vec4(mix(vec3(0,1,0), r2.rgb, r2.a), 1);\n    } else if (mode==33) {\n        vec4 r2 = texture(iChannel0, uv/2.+vec2(0.5,0));\n        fragColor = vec4(mix(vec3(0,1,0), r2.rgb, r2.a), 1);\n    } else if (mode==111) {\n        fragColor = texture(iChannel0, uv/2., lod[0]);\n    } else if (mode==222) {\n        vec4 r2 = texture(iChannel0, uv/2.+vec2(0,0.5), lod[1]);\n        fragColor = vec4(mix(vec3(0,1,0), r2.rgb, r2.a), 1);\n    } else if (mode==333) {\n        vec4 r2 = texture(iChannel0, uv/2.+vec2(0.5,0), lod[2]);\n        fragColor = vec4(mix(vec3(0,1,0), r2.rgb, r2.a), 1);\n    } else if(mode==444) {\n        uv/=2.;\n        vec4 result  = blur(uv, .5, 1.5); \n        vec4 result1 = blur(uv+vec2(0, 0.5), 1., 1.); \n        vec4 result2 = blur(uv+vec2(0.5, 0), 1.8, 2.);\n        result.rgb  = mix(mix(result.rgb, result1.rgb, result1.a), result2.rgb, result2.a);\n        fragColor = vec4(result.rgb,1.0);\n    } else if(mode==445) {\n        uv/=2.;\n        vec4 result  = blur(uv, 1., 0.);\n        vec4 result1 = blur(uv+vec2(0, 0.5), 0.95, 1.3);\n        vec4 result2 = blur(uv+vec2(0.5, 0), 2., 2.);\n        result.rgb  = mix(mix(result.rgb, result1.rgb, result1.a), result2.rgb, result2.a);\n        fragColor = vec4(result.rgb,1.0); \n    } else {\n        fragColor = texture(iChannel0, uv);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n 2D clouds test\n \n original clouds code www.shadertoy.com/view/4tdSWr by drift\n\n Buffer is separated into 4 rectangles\n part 1 (Bottom Left)  : background clouds and sky (alpha 1)\n part 2 (Top Left)     : middle clouds area (with alpha)\n part 3 (Bottom Right) : front clouds area (with alpha)\n part 4 (Top Right)    : nothing\n\n*/\n\n/************************************************\n * see : www.shadertoy.com/view/4tdSWr\t\t\t*\n \t\t\t\t\t\t\t\t\t\t\t\t*/\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n/**\n *\n * p               : position\n * cscale          : cloudscale;\n * cspeed          : clouds animation speed\n * cdark, clight   : dark and light paramaters (cloudcolour *= (cdark + clight*noise))\n * ccover , calpha : filling amount\n * cskytint        : clouds tint -  vec3(0.34, 0.26, 0.13) / vec3(0.25) ...\n * \n */\nvoid clouds(out vec4 result, const vec2 p, const vec2 ratio, const float cscale, const float cspeed, const float cdark, const float clight, const float ccover, const float calpha, const vec3 cskytint/*const float cskytint, const vec3 skycolour*/) {\n\tvec2 uv = p*ratio;\n\n    float q = fbm(uv * cscale * 0.25); //  0.5->0.25\n\n    vec2 nspeed = vec2(cspeed);\n    vec2 time = iTime * nspeed;\n\n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n\n    //noise shape\n\tfloat f = 0.0;\n    uv = p*ratio;\n\tuv *= cscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\n    f *= r + f;\n    f = ccover + calpha*f*r;\n\n    //noise colour\n    float c = 0.0;\n    time = iTime * nspeed * 2.0;\n    uv = p*ratio;\n\tuv *= cscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * nspeed * 3.0;\n    uv = p*ratio;\n\tuv *= cscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\n    c += c1;\n    vec3 cloudcolour = vec3(1.1, 1.1, .9) * clamp((cdark + clight*c), 0.0, 1.0);\n    result = vec4(clamp(cskytint + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n}\n\t\t\t\t\t\t\t\t\t           /*\n \t\t\t\t\t\t\t\t\t            *\n ************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ratio = vec2(iResolution.x/iResolution.y,1.0);\n    vec2 userPosition = iMouse.xy*.1; // + vec2(-iTime*.1, cos(iTime*.1)*5.);\n\n    // 'cut' buffer into 4 rectangles [0,1]\n    vec2 uv2 = uv*2.;\n    vec2 uv21 = fract(uv2);\n    vec2 flo  = floor(uv2);\n    // indice\n    // 0 : bottom left\n    // 1 : top left\n    // 2 : bottom right\n    // 3 : top right\n    int indice = int(2.*flo.x+flo.y);\n    vec3 skycolour = mix(skycolour2, skycolour1, uv21.y);\n    vec3 skytint = skycolour * 0.5;\n        \n        \n    if(indice == 0) {\n        clouds(fragColor, uv21+vec2(-5,8)+userPosition*.08, ratio, 1.25, 0.018, 0.5, 0.3, -.3, 3.4, skytint);\n        fragColor.rgb = mix(skycolour, fragColor.rgb, fragColor.a);\n        fragColor.a = 1.;\n    } else if (indice == 1)\n        clouds(fragColor, uv21+iTime*.01+vec2(2,11)+userPosition*.09, ratio, 1.2, 0.012, 0.5, 0.3, -2.2, 6.0,  skytint);\n    else if(indice == 2)\n        clouds(fragColor, uv21+iTime*.025+userPosition*.25, ratio, 1.2, 0.05, 0.5, 0.3, -2., 3.50,  skytint);\n}","name":"Buffer A","description":"","type":"buffer"}]}