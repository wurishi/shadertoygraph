{"ver":"0.1","info":{"id":"wl2czh","date":"1593823129","viewed":121,"name":"Inverse Binet","username":"killhour","description":"Explores the inverse complex graph of the Binet algorithm, which identifies the cardinal order of Fibonacci numbers.\nInspired by Matt Parker's awesome video here: https://www.youtube.com/watch?v=ghxQA3vvhsk&t=286s\nEnter toggles Demo mode, 0-9 are presets.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["procedural","colorful","graph","complex","fibonacci","imaginary","binet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n***Enter toggles Demo mode. 0-9 are presets. Spacebar to randomize.***\n\nInstructions:\nThe main window shows the inverse of the Binet algorithm.\nThe smaller window in the top right shows the forward algorithm, to assist with navigation.\nThe shader starts with an imaginary scale of 0, showing only the Binet numbers for Fibonacci numbers on the real number line.\nUp and Down move backwards and forwards along the imaginary number line.\n- and + allow you to see multiple slices of this line at once, coded by color.\nNote that each slice will need to be rerendered after moving, so be patient.\n\n***If you're having framerate issues, try lowering itersPerFrame and depthIterations under Common***\n\nControls:\nUp Arrow - Increase imaginary component\nDown Arrow - Decrease imaginary component\nLeft Arrow - Rotate complex number plane counterclockwise\nRight Arrow - Rotate complex number plane clockwise\n+/= Key - Increase scale along complex number plane\n-/_ Key - Decrease scale along complex number plane\n] Key - Increase constant used for algorithm (default is sqrt(5))\n[ Key - Decrease constant used for algorithm (limited to sqrt(0.1) to avoid imaginary constants)\nEnter Key - Toggle demo mode\n0-9 keys - Select preset\nSpacebar - Randomize variables\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = vec4(texture(iChannel1, uv).xyz, 1.);\n    \n    // minimap view of binet coords\n    if (uv.x > 0.8 && uv.y > 0.8) {\n        fragColor = vec4(texture(iChannel0, (uv - vec2(0.8, 0.8)) * 5. * min(maxMapBufferSize.x / iChannelResolution[0].x, 1.)));\n    }\n    \n    // progress bar\n    if (uv.y < 0.01) {\n        fragColor = vec4(round(texelFetch(iChannel2, ivec2(0, 0), 0).x + 0.5 - uv.x));\n    }\n    \n    //Debug info\n    //fragColor = vec4(texture(iChannel2, uv / 100.).xyz, 1.);\n}  ","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float imaginOffset = texelFetch(iChannel0, ivec2(0,0), 0).z;\n    float rotateOffset = texelFetch(iChannel0, ivec2(0,0), 0).w;\n    float imaginScale = texelFetch(iChannel0, ivec2(1,0), 0).x;\n    float constant = texelFetch(iChannel0, ivec2(1,0), 0).y;\n    \n    vec2 uv = fragCoord / min(iResolution.xy ,maxMapBufferSize);\n    \n    vec2 uvScaled = (uv - mapOffset) * (mapScale + vec2(1, imaginScale)) - vec2(0, imaginOffset);\n    \n    vec2 uvScaledRotated = c_rot(uvScaled, rotateOffset);\n    \n    vec2 rt5 = vec2(sqrt(5. + constant), 0.0); //Sqrt of 5 - complex\n    \n    vec2 a = c_div(c_add(vec2(1., 0.), rt5), vec2(2., 0.));\n    vec2 b = c_div(c_sub(vec2(1., 0.), rt5), vec2(2., 0.));\n    vec2 lhv = c_pow(a, uvScaledRotated);\n    vec2 rhv = c_pow(b, uvScaledRotated);\n    vec2 num = c_sub(lhv, rhv);\n    vec2 o = c_div(num, rt5);\n    \n    fragColor = vec4(o,0.,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec2 offset = vec2(-0.5, -0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Reset\n    if (texelFetch( iChannel1, ivec2(0, 0), 0 ).y < -0.5) {\n        fragColor = vec4(0., 0., 0., 1.);\n        return;\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Copy existing data to persist\n    fragColor = texture(iChannel2, uv);\n    \n    // Scaled pixel coordinates\n    vec2 uvScaled = (uv + offset) * renderScale;\n    \n    //fragColor = vec4(0.,0.,0.,1.);\n    for (int n = 0; n < itersPerFrame; n++) {\n        float offset = float(n) * (float(min(iChannelResolution[0].y, maxMapBufferSize.y)) / float(depthIterations));\n        int i = int(round((1. - (texelFetch(iChannel1, ivec2(0, 0), 0).x + offset)) * float(min(iChannelResolution[0].y, maxMapBufferSize.y))));\n        vec4 color = vec4(hsv2rgb_smooth(vec3(float(i) / float(min(iChannelResolution[0].y, maxMapBufferSize.y)) * 0.8, 1., 1.)),1.);\n        for (int j = 0; j < int(min(iChannelResolution[0].x, maxMapBufferSize.x)); j++) {\n            vec2 val = texelFetch(iChannel0, ivec2(j, float(i)), 0).xy;\n            if (c_abs(c_sub(val, uvScaled)) <= maxDist) {\n                fragColor = color;\n                break;\n            }\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get old data\n    float iteration = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    float state     = texelFetch(iChannel0, ivec2(0, 0), 0).y;\n    float offset    = texelFetch(iChannel0, ivec2(0, 0), 0).z;\n    float rotation  = texelFetch(iChannel0, ivec2(0, 0), 0).w;\n    float scale     = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    float constant  = texelFetch(iChannel0, ivec2(1, 0), 0).y;\n    float lastReset = texelFetch(iChannel0, ivec2(1, 0), 0).z;\n    float demo      = texelFetch(iChannel0, ivec2(1, 0), 0).w;\n    \n    \n    //Increase imaginary plane\n    if (texelFetch( iChannel1, ivec2(KEY_UP, 0), 0 ).x > 0.) {\n        offset -= 0.01;\n\n    }\n\n    //Decrease imaginary plane\n    if (texelFetch( iChannel1, ivec2(KEY_DOWN, 0), 0 ).x > 0.) {\n        offset += 0.01;\n\n    }\n\n    //Rotate complex left\n\n    if (texelFetch( iChannel1, ivec2(KEY_LEFT, 0), 0 ).x > 0.) {\n        rotation -= 0.025;\n    }\n\n    //Rotate complex right\n\n    if (texelFetch( iChannel1, ivec2(KEY_RIGHT, 0), 0 ).x > 0.) {\n        rotation += 0.025;\n    }\n    \n    //Increase scale\n    if (texelFetch( iChannel1, ivec2(KEY_EQUALS , 0), 0).x > 0.) {\n        scale += 0.1;\n    }\n\n    //Decrease scale\n    if (texelFetch( iChannel1, ivec2(KEY_DASH , 0), 0).x > 0.) {\n        scale -= 0.1;\n    }\n\n    //Increase sqrt\n    if (texelFetch( iChannel1, ivec2(KEY_CLSBRKT , 0), 0).x > 0.) {\n        constant += .1;\n    }        \n\n    //Decrease sqrt\n    if (texelFetch( iChannel1, ivec2(KEY_OPNBRKT , 0), 0).x > 0.) {\n        constant = max(constant - .1, -4.9);\n    }\n\n    //Preset 0\n    if (texelFetch( iChannel1, ivec2(KEY_0, 0), 0 ).x > 0.) {\n        offset = 0.;\n        rotation = 0.;\n        scale = 0.;\n        constant = 0.;\n    }\n    \n    //Preset 1\n    if (texelFetch( iChannel1, ivec2(KEY_1, 0), 0 ).x > 0.) {\n        offset = 0.2;\n        rotation = 0.15;\n        scale = 0.3;\n        constant = 0.;\n    }\n    \n    //Preset 2\n    if (texelFetch( iChannel1, ivec2(KEY_2, 0), 0 ).x > 0.) {\n        offset = -3.;\n        rotation = -1.2;\n        scale = 1.;\n        constant = 0.;\n    }\n    \n    //Preset 3\n    if (texelFetch( iChannel1, ivec2(KEY_3, 0), 0 ).x > 0.) {\n        offset = 2.25;\n        rotation = 2.8;\n        scale = 5.;\n        constant = -4.0001;\n    }\n    \n    //Preset 4\n    if (texelFetch( iChannel1, ivec2(KEY_4, 0), 0 ).x > 0.) {\n        offset = 0.;\n        rotation = 0.5;\n        scale = 1.;\n        constant = 3.;\n    }\n    \n    //Preset 5\n    if (texelFetch( iChannel1, ivec2(KEY_5, 0), 0 ).x > 0.) {\n        offset = -0.1;\n        rotation = 3.14;\n        scale = 2.;\n        constant = 6.;\n    }\n    \n    //Preset 6\n    if (texelFetch( iChannel1, ivec2(KEY_6, 0), 0 ).x > 0.) {\n        offset = 3.;\n        rotation = 1.5;\n        scale = 5.;\n        constant = 0.1;\n    }\n    \n    //Preset 7\n    if (texelFetch( iChannel1, ivec2(KEY_7, 0), 0 ).x > 0.) {\n        offset = 1.8;\n        rotation = 0.15;\n        scale = 0.5;\n        constant = 0.;\n    }\n    \n    //Preset 8\n    if (texelFetch( iChannel1, ivec2(KEY_8, 0), 0 ).x > 0.) {\n        offset = 20.;\n        rotation = 4.;\n        scale = 30.;\n        constant = -3.5;\n    }\n    \n    //Preset 9\n    if (texelFetch( iChannel1, ivec2(KEY_9, 0), 0 ).x > 0.) {\n        offset = -10.;\n        rotation = 0.;\n        scale = 30.;\n        constant = -2.85;\n    }\n    \n    //Demo\n    demo = mod(demo + texelFetch( iChannel1, ivec2(KEY_ENTER, 1),0 ).x, 2.);\n    \n    //Random\n    if (texelFetch( iChannel1, ivec2(KEY_SPACE, 0), 0 ).x > 0. || (demo < 0.5 && state < -0.5)) {\n        uint seed = uint(iDate / iTimeDelta) + uint(iFrame);\n        offset = randRange(-1., 5., seed);\n        seed++;\n        rotation = randRange(-pi, pi, seed);\n        seed++;\n        scale = randRange(-15., 40., seed);\n        seed++;\n        constant = randRange(0.01, 10., seed);\n    }\n\n    //Last frame was clear - reset\n    if (state < -0.5) {\n        state = 0.;\n        lastReset = 0.;\n    }\n\n    //Clear command\n    if (\n        texelFetch( iChannel1, ivec2(KEY_SPACE   , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_EQUALS  , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_DASH    , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_CLSBRKT , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_OPNBRKT , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_UP      , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_DOWN    , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_LEFT    , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_RIGHT   , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_0       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_1       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_2       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_3       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_4       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_5       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_6       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_7       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_8       , 0), 0).x > 0. ||\n        texelFetch( iChannel1, ivec2(KEY_9       , 0), 0).x > 0.\n    ) {\n        state = -1.;\n        iteration = 0.;\n        demo = 1.;\n    }\n    \n    if (demo < 0.5 && state > 0.5 && lastReset > demoTime) {\n        state = -1.;\n        iteration = 0.;\n    }\n    \n    lastReset += iTimeDelta;\n        \n        \n    if (fragCoord.x < 1.) {\n        //Reset detected\n        if (state < -0.5) {\n            fragColor = vec4(iteration, state, offset, rotation);\n        \treturn;\n        }\n\n        //Finished processing\n        if (state > 0.5) {\n            fragColor = vec4(1, 1, offset, rotation);\n            return;\n        }\n        \n        //Increase iteration\n        iteration += float(itersPerFrame) / float(depthIterations);\n        if (iteration >= 1.) {\n            fragColor = vec4(1, 1, offset, rotation);\n            return;\n        }\n        fragColor = vec4(iteration, state, offset, rotation);\n        return;\n        \n    } else if (fragCoord.x < 2.) {\n        \n        //Set data\n        fragColor = vec4(scale, constant, lastReset, demo);\n        return;\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Iteration Variables - NOTE: If you're experiencing performance issues, try lowering these.\nconst int depthIterations = 120;\nconst int itersPerFrame = 1;\nconst vec2 maxMapBufferSize = vec2(800, 450);\n//----------------------------\n\nconst float demoTime = 4.;\nconst vec2 mapScale = vec2(10., 0.);\nconst vec2 mapOffset = vec2(0.5, 0.);\nconst float renderScale = 10.;\nconst float maxDist = 0.025;\n\nconst float e = 2.71828183;\nconst float pi = 3.14159265359;\n\nconst int KEY_SPACE    = 32;\nconst int KEY_UP       = 38;\nconst int KEY_DOWN     = 40;\nconst int KEY_LEFT     = 37;\nconst int KEY_RIGHT    = 39;\nconst int KEY_EQUALS   = 187;\nconst int KEY_DASH     = 189;\nconst int KEY_CLSBRKT  = 221;\nconst int KEY_OPNBRKT  = 219;\nconst int KEY_0        = 48;\nconst int KEY_1        = 49;\nconst int KEY_2        = 50;\nconst int KEY_3        = 51;\nconst int KEY_4        = 52;\nconst int KEY_5        = 53;\nconst int KEY_6        = 54;\nconst int KEY_7        = 55;\nconst int KEY_8        = 56;\nconst int KEY_9        = 57;\nconst int KEY_ENTER    = 13;\n\nvec2 c_add(vec2 c1, vec2 c2)\n{\n    return vec2(c1.x + c2.x, c1.y + c2.y);\n}\n\nvec2 c_sub(vec2 c1, vec2 c2)\n{\n    return vec2(c1.x - c2.x, c1.y - c2.y);\n}\n\nvec2 c_mul(vec2 c1, vec2 c2)\n{\n    return vec2(c1.x * c2.x - c1.y * c2.y, c1.y * c2.x + c1.x * c2.y);\n}\n\nvec2 c_div(vec2 c1, vec2 c2)\n{\n    float real = (c1.x * c2.x + c1.y * c2.y) / (c2.x * c2.x + c2.y * c2.y);\n    float imag = (c1.y * c2.x - c1.x * c2.y) / (c2.x * c2.x + c2.y * c2.y);\n    return vec2(real, imag);\n}\n\nfloat c_abs(vec2 c)\n{\n    return sqrt(c.x * c.x + c.y * c.y);\n}\n\nvec2 c_pol(vec2 c)\n{\n    return vec2(c_abs(c), atan(c.y, c.x));\n}\n\nvec2 c_rec(vec2 c)\n{\n    float z = abs(c.x);\n    return vec2(z * cos(c.y), z * sin(c.y));\n}\n\nvec2 c_pow(vec2 base, vec2 exp)\n{\n    vec2 b = c_pol(base);\n    float z = pow(b.x, exp.x) * pow(e, -exp.y * b.y);\n    float fi = exp.y * log(b.x) + exp.x * b.y;\n    return c_rec(vec2(z, fi));\n}\n\nvec2 c_rot(vec2 c, float rad)\n{\n    float x = c.x * cos(rad) - c.y * sin(rad);\n    float y = c.x * sin(rad) + c.y * cos(rad);\n    return vec2(x, y);\n}\n\n//--------------------------\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n//--------------------------\n\n\nfloat randRange(float minimum, float maximum, uint seed) {\n    return mix(minimum, maximum, hash1(seed));\n}\n\n//--------------------------\n// Smooth HSV to RGB conversion\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"}]}