{"ver":"0.1","info":{"id":"XctGzB","date":"1711838276","viewed":122,"name":"Dancing Polka Cubes","username":"Peregrine","description":"Made during the Revision 2024 shader jam w/ h0ffman x Teo. Crashed the distant shader server, so I had to leave the jam early. :'''-(\nModified for Shadertoy.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reactive","dots","uvmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FFT(f) (10. * texture(iChannel0, vec2(f)).x)\n#define PI 3.1415926535897932\n#define T (.5 * iTime)\n#define TAU (2. * PI)\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nmat3 yaw(float a) {\n  float s = sin(a), c = cos(a);\n  return mat3(c, s, 0., -s, c, 0., 0., 0., 1.);\n}\n\nmat3 pitch(float a) {\n  float s = sin(a), c = cos(a);\n  return mat3(c, 0., -s, 0., 1., 0., s, 0., c);\n}\n\nmat3 roll(float a) {\n  float s = sin(a), c = cos(a);\n  return mat3(1., 0., 0., 0., c, s, 0., -s, c);\n}\n\nmat3 rotation(void) {\n  float s = .05;\n  return yaw(T + s * FFT(0.)) * pitch(T + s * FFT(.5)) * roll(T + s * FFT(1.));\n}\n\nvec3 palette(float x) {\n  vec3 a = vec3(.5),\n       b = a,\n       c = vec3(1.),\n       d = vec3(0., 1./3., 2./3.);\n  return a + b * cos(TAU * (c * x + d));\n}\n\nvec3 dots(vec2 uv) {\n  float d = length(uv);\n  uv = fract(20. * uv) - .5;\n  float r = sin(TAU * (T - d)) * .25 + .25;\n  vec3 c = palette(d - FFT(0.));\n  return c * step(0., r - length(uv));\n}\n\nfloat sdf_box(vec3 p, vec3 s, float r) {\n  vec3 q = abs(p) - s + r;\n  return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z))) - r;\n}\n\nfloat sdf(vec3 p) {\n  float d = 1000.;\n  p *= rotation();\n  for (float i = 0.; i < 3.; i++) {\n    for (float j = 0.; j < 3.; j++) {\n      for (float k = 0.; k < 3.; k++) {\n        float c = sdf_box(p + (vec3(i, j, k) - 1.)/.8, vec3(.5), .1);\n        d = min(d, c);\n      }\n    }\n  }\n  return d;\n}\n\nvec3 get_normal(vec3 p) {\n  vec2 e = .01 * vec2(1., -1);\n  return normalize(\n    e.xyy * sdf(p + e.xyy) +\n    e.yxy * sdf(p + e.yxy) +\n    e.yyx * sdf(p + e.yyx) +\n    e.xxx * sdf(p + e.xxx)\n  );\n}\n\nvec3 uv_map(vec3 p, vec3 n, mat3 r, float k) {\n  float scale = 20.;\n  p *= r;\n  n *= r;\n  vec3 x = dots(p.yz);\n  vec3 y = dots(p.xz);\n  vec3 z = dots(p.xy);\n  vec3 w = pow(abs(n), vec3(k));\n  return (x * w.x + y * w.y + z * w.z) / (w.x + w.y + w.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\tvec3 c = vec3(0.),\n       ro = vec3(0., 0., -4.),\n       rd = normalize(vec3(uv, 1.)),\n       p = ro;\n    float d;\n   \n    uv *= rot(FFT(.0));\n    uv *= FFT(.5)/2.;\n    c = .1 * dots(uv);\n  \n    for (int i = 0; i < 128; i++) {\n      d = sdf(p);\n        if (d < .01) {\n          c = uv_map(p, get_normal(p), rotation(), 2.);\n          break;\n        }\n      p += d * rd;\n    }\n  \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}