{"ver":"0.1","info":{"id":"DtXXRM","date":"1674548301","viewed":221,"name":"Fuji Stream","username":"voithos","description":"A shader remix, primarily based on https://www.shadertoy.com/view/tsScRK but also incorporating elements of https://www.shadertoy.com/view/Wt33Wf.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sunset","tesselation","synthwave","fuji","cineshader"],"hasliked":0,"parentid":"tsScRK","parentname":"another synthwave sunset thing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1\n#define SPEED 8.\n#define WAVE\n#define FUJI\n\nconst vec3 SUN_COLOR = vec3(.8, .2, .5);\nconst vec3 HAZE_COLOR = vec3(.4, .5, .8);\n\n// A noise-added time variant.\nfloat noisyTime;\n\nfloat amp(vec2 p) { return smoothstep(1., 10., abs(p.x)); }\n\nfloat pow512(float a) {\n  a *= a;  //^2\n  a *= a;  //^4\n  a *= a;  //^8\n  a *= a;  //^16\n  a *= a;  //^32\n  a *= a;  //^64\n  a *= a;  //^128\n  a *= a;  //^256\n  return a * a;\n}\n\nfloat pow1d5(float a) { return a * sqrt(a); }\n\nfloat hash21(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(1.9898, 7.233))) * 45758.5433);\n}\n\nfloat hash(vec2 uv) {\n  float a = amp(uv);\n#ifdef WAVE\n  float w = a > 0.\n                ? (1. - .8 * pow512(.51 + .49 * sin((.02 * (uv.y + .5 * uv.x) -\n                                                     noisyTime * 0.7) *\n                                                    2.)))\n                : 0.;\n#else\n  float w = 1.;\n#endif\n  return (a > 0. ? a * pow1d5(hash21(uv)) * w : 0.);\n}\n\nfloat edgeMin(float dx, vec2 da, vec2 db) {\n  return min(min((1. - dx) * db.y, da.x), da.y);\n}\n\n// 2D triangular noise, red channel denotes height, green is distance to nearest\n// edge.\nvec2 trinoise(vec2 uv) {\n  const float sq = sqrt(3. / 2.);\n  uv.x *= sq;\n  uv.y -= .5 * uv.x;\n  vec2 d = fract(uv);\n  uv -= d;\n\n  bool c = dot(d, vec2(1)) > 1.;\n\n  vec2 dd = 1. - d;\n  vec2 da = c ? dd : d, db = c ? d : dd;\n\n  float nn = hash(uv + float(c));\n  float n2 = hash(uv + vec2(1, 0));\n  float n3 = hash(uv + vec2(0, 1));\n\n  float nmid = mix(n2, n3, d.y);\n  float ns = mix(nn, c ? n2 : n3, da.y);\n  float dx = da.x / db.y;\n  return vec2(mix(ns, nmid, dx), edgeMin(dx, da, db));\n}\n\nvec2 map(vec3 p) {\n  // Use the XZ plane to sample a triangle mesh plane.\n  vec2 n = trinoise(p.xz);\n  return vec2(p.y - 2. * n.x, n.y);\n}\n\nvec3 gradient(vec3 p) {\n  const vec2 e = vec2(.005, 0);\n  float a = map(p).x;\n  return vec3(map(p + e.xyy).x - a, map(p + e.yxy).x - a,\n              map(p + e.yyx).x - a) /\n         e.x;\n}\n\nvec2 intersectTerrain(vec3 ro, vec3 rd) {\n  float d = 0., h = 0.;\n  // Raymarch. Iteration count empirically determined.\n  for (int i = 0; i < 500; ++i) {\n    vec3 p = ro + d * rd;\n    vec2 s = map(p);\n    h = s.x;\n    d += h * .5;\n    // Stop when we're no longer making much progress.\n    if (abs(h) < .003 * d) return vec2(d, s.y);\n    // Stop if we've gone too far and still haven't hit anything.\n    if (d > 150.0 || p.y > 2.0) break;\n  }\n\n  return vec2(-1);\n}\n\nvoid addsun(vec3 rd, vec3 ld, float haze, inout vec3 col) {\n  const float RADIUS = .3;\n  float sun = smoothstep(RADIUS + 0.02, RADIUS, distance(rd, ld));\n  float bloom = smoothstep(0.7, 0.0, distance(rd, ld));\n\n  if (sun > 0.0) {\n    float uvy = (rd.y - ld.y) + RADIUS;\n    float cut = 3.0 * sin((uvy + noisyTime * 0.2) * 120.0) +\n                clamp(uvy * 20.0 - 4.0, -6.0, 6.0);\n    sun = clamp(sun * cut, 0.0, 1.0);\n\n    col = mix(col, mix(SUN_COLOR, HAZE_COLOR, pow(haze, 3.0) * 0.3), sun);\n  }\n\n  col += SUN_COLOR * bloom * 0.3;\n}\n\nfloat starnoise(vec3 rd) {\n  float c = 0.;\n  vec3 p = normalize(rd) * 200.;\n  for (float i = 0.; i < 4.; i++) {\n    vec3 q = fract(p) - .5;\n    vec3 id = floor(p);\n    float c2 = smoothstep(.5, 0., length(q));\n    c2 *= step(hash21(id.xz / id.y), .06 - i * i * 0.005);\n    c += c2;\n    p = p * .6 +\n        .5 * p * mat3(3. / 5., 0, 4. / 5., 0, 1, 0, -4. / 5., 0, 3. / 5.);\n  }\n  c *= c;\n  float g = dot(sin(rd * 10.512), cos(rd.yzx * 10.512));\n  c *= smoothstep(-3.14, -.9, g) * .6 + .5 * smoothstep(-.3, 1., g);\n  return c * c;\n}\n\nfloat dot2(in vec2 v) { return dot(v, v); }\n\nfloat sdTrapezoid(in vec2 p, in float r1, float r2, float he) {\n  vec2 k1 = vec2(r2, he);\n  vec2 k2 = vec2(r2 - r1, 2.0 * he);\n  p.x = abs(p.x);\n  vec2 ca = vec2(p.x - min(p.x, (p.y < 0.0) ? r1 : r2), abs(p.y) - he);\n  vec2 cb = p - k1 + k2 * clamp(dot(k1 - p, k2) / dot2(k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot2(ca), dot2(cb)));\n}\n\nvec3 gsky(vec3 rd, vec3 ld, bool mask) {\n  float haze = exp2(-6. * (abs(rd.y) - .1 * dot(rd, ld)));\n\n  float stars = mask ? (starnoise(rd)) * (1. - min(haze, 1.)) : 0.;\n  vec3 back =\n      vec3(.4, .1, .4) *\n      (1. - .5 * exp2(-.1 * abs(length(rd.xz) / rd.y)) * max(sign(rd.y), 0.));\n\n  vec3 col = clamp(mix(back, HAZE_COLOR, haze) + stars, 0., 1.);\n\n  if (mask) addsun(rd, ld, haze, col);\n\n#ifdef FUJI\n  float fujiVal = sdTrapezoid(rd.xy * 2.9, 1.95 - rd.y * 3., 0.08, 0.5);\n  if (mask && fujiVal <= 0.0) {\n    // Calculate snow location.\n    float waveVal =\n        rd.y * 1. + sin(rd.x * 100.0 + 2. + iTime * 3.) * 0.01 - 0.1;\n    float waveEdgeThickness = smoothstep(0.0, 0.005, waveVal);\n\n    col = vec3(0.15);\n    // Top snow.\n    col =\n        mix(col, vec3(1.0, 1.0, 1.0), fujiVal <= 0.0 ? waveEdgeThickness : 0.0);\n    // Outline.\n    col =\n        mix(col, vec3(.0, 0.5, 0.8), 1.0 - smoothstep(0.0, 0.02, abs(fujiVal)));\n    // Haze.\n    col = mix(col, HAZE_COLOR, pow(haze * .75, 4.0));\n  }\n  if (mask) {\n    if (fujiVal > 0.0) {\n      col += vec3(.0, .5, 1.) * pow(1.0 - clamp(fujiVal, 0.0, 1.0), 3.0) * .4;\n    }\n  }\n#endif\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Mouse input.\n  vec2 mouseCoords = iMouse.xy / iResolution.xy;\n  vec2 ndcMouse = -1.0 + 2.0 * mouseCoords;\n  vec2 mouseOffset = vec2(0.0);\n  if (iMouse.x > 10.) {\n    mouseOffset = ndcMouse * vec2(1., 0.5);\n  }\n  \n  vec3 result;\n\n  for (float x = 0.0; x < 1.0; x += 1.0 / float(AA)) {\n    for (float y = 0.0; y < 1.0; y += 1.0 / float(AA)) {\n      // Calculate pixel-level sample offset for AA.\n      vec2 sampleOffset = vec2(x, y) - vec2(0.5 / float(AA));\n      vec2 sampleCoord = fragCoord + sampleOffset;\n      vec2 coord = sampleCoord / iResolution.xy;\n      vec2 ndc = -1.0 + 2.0 * coord + mouseOffset;\n      // Fix aspect ratio.\n      ndc.x *= iResolution.x / iResolution.y;\n\n      // Introduce some noise to time.\n      float dt = fract(hash21(sampleCoord) + iTime);\n      // TODO: Why is this clamped?\n      noisyTime = mod(iTime + dt * 0.003, 4000.0);\n\n      // Calculate ray origin and direction.\n      vec3 ro = vec3(0.0 + mouseOffset.x * 0.5, 1.0 + mouseOffset.y * 0.2, (-20000. + noisyTime * SPEED));\n      vec3 rd = normalize(vec3(ndc, 4.0 / 3.0));\n\n      vec2 i = intersectTerrain(ro, rd);\n      float d = i.x;\n\n      // Create light direction.\n      vec3 ld = normalize(vec3(0, .125 + .05 * sin(.1 * noisyTime * 2.), 1));\n\n      vec3 fog = d > 0. ? exp2(-d * vec3(.08, .1, .34)) : vec3(0.);\n      vec3 sky = gsky(rd, ld, d < 0.0);\n\n      vec3 p = ro + rd * d;\n      vec3 n = normalize(gradient(p));\n\n      float diffuse = dot(n, ld) + .1 * n.y;\n      vec3 col = vec3(.1, .1, .18) * diffuse;\n\n      // Calculate reflection.\n      vec3 rfd = reflect(rd, n);\n      vec3 rfcol = gsky(rfd, ld, true);\n\n      col = mix(col, rfcol, .05 + .95 * pow(max(1. + dot(rd, n), 0.), 5.));\n\n      col = mix(col, vec3(.01, .63, .6), smoothstep(.03, .0, i.y));\n      col = mix(sky, col, fog);\n      // Skip tone mapping and gamma for the old-school look.\n\n      result += col;\n    }\n  }\n  result /= float(AA * AA);\n  fragColor = vec4(result, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}