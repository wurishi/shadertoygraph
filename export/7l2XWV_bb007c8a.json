{"ver":"0.1","info":{"id":"7l2XWV","date":"1628704062","viewed":89,"name":"Space Camera","username":"Koulatko","description":"WASDQE - linear thrusters\nIJKLUO - angular thrusters\nSpace - freeze rotation\n\nA bit like KSP but even KSP has some form of auto-stabilization lol","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["quaternion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 sky(vec3 rd){\n    return texture(iChannel0, rd.xzy).xyz;\n}\n\nvec4 ray_plane(vec3 ro, vec3 rd, vec4 p){\n    return vec4(p.xyz, -(dot(ro, p.xyz)-p.w)/dot(rd, p.xyz));\n}\n\nvec4 ray_sphere(vec3 ro, vec3 rd, float r){\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float d = b*b - c;\n    if(d < 0.0) return vec4(-1.0);\n    float t = -b-sqrt(d);\n    return vec4(normalize(ro+t*rd), t);\n}\n\n//https://iquilezles.org/articles/morecheckerfiltering\nvec2 p( in vec2 x )\n{\n    vec2 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\nfloat checkersGradTriangle( in vec2 uv, in vec2 ddx, in vec2 ddy )\n{\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (p(uv+w)-2.0*p(uv)+p(uv-w))/(w*w); // analytical integral (triangle filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nvec3 calc_ray_dir(vec2 fc){\n    vec2 ss = (2.0*fc-iResolution.xy)/iResolution.y;\n    return normalize(vec3(ss.x, ss.y, 1.5));\n}\n\nfloat sinc(float x){\n    if(abs(x) < 0.001) return 1.0;\n    return sin(x)/x;\n}\n\nvec3 sinc(vec3 x){\n    return vec3(sinc(x.x), sinc(x.y), sinc(x.z));\n}\n\nvec3 calc_texture(vec3 p, vec3 ddx, vec3 ddy){\n    vec3 w = abs(ddx)+abs(ddy);\n    vec3 a = 0.8*cos(p)*sinc(w);\n    return 0.7+vec3(0.3)*a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 axis = normalize(vec3(1.0, sin(0.1*iTime), 1.0));\n    \n    vec4 angvel = normalize(vec4(0.1, 0.1, 0.1, 1.0));\n    \n    \n    vec4 c_orr = texelFetch(iChannel3, ivec2(0, 2), 0);\n    \n    \n    vec3 right = rotate_vector(c_orr, vec3(1.0, 0.0, 0.0));\n    vec3 up = rotate_vector(c_orr, vec3(0.0, 1.0, 0.0));\n    vec3 forward = rotate_vector(c_orr, vec3(0.0, 0.0,-1.0));\n    \n    \n    \n    vec3 rd = calc_ray_dir(fragCoord);\n    vec3 rd10 = calc_ray_dir(fragCoord+vec2(1.0, 0.0));\n    vec3 rd01 = calc_ray_dir(fragCoord+vec2(0.0, 1.0));\n    \n    rd   = mat3(right, up, forward)*rd;\n    rd10 = mat3(right, up, forward)*rd10;\n    rd01 = mat3(right, up, forward)*rd01;\n    \n    vec4 cpos_texel = texelFetch(iChannel3, ivec2(0, 1), 0);\n    vec3 ro = cpos_texel.xyz;\n    \n    vec4 h = ray_sphere(ro-vec3(0.0, 0.0, 10.0), rd, 10.0);\n    vec4 h2 = ray_plane(ro, rd, vec4(0.0, 0.0, 1.0, 0.0));\n    \n    if(h2.w > 0.0 && (h2.w < h.w || h.w <= 0.0)) h = h2;\n    \n    vec3 p = ro + h.w*rd;\n    \n    //Calculate derivative by intersecting with tangent plane\n    float t10 = -(dot(h.xyz, ro)-dot(h.xyz, ro+h.w*rd))/dot(h.xyz, rd10);\n    float t01 = -(dot(h.xyz, ro)-dot(h.xyz, ro+h.w*rd))/dot(h.xyz, rd01);\n    \n    vec3 ddx = ro+t10*rd - p;\n    vec3 ddy = ro+t01*rd - p;\n    \n    vec3 aeiou = vec3(0.25, 0.5, 1.0);\n    vec3 col = calc_texture(p, ddx, ddy);\n    //vec3 col = ddx;\n\n    if(h.w <= 0.0) col = vec3(0.2);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\n//https://twistedpairdevelopment.wordpress.com/2013/02/11/rotating-a-vector-by-a-quaternion-in-glsl/\nvec4 qmul(vec4 q1, vec4 q2){\n\treturn vec4(\n\t\tq2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n\t\tq1.w * q2.w - dot(q1.xyz, q2.xyz)\n\t);\n}\n\nvec3 rotate_vector(vec4 q, vec3 v){\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 axis_angle_to_quat(vec4 a){\n    return vec4(a.xyz*sin(a.w/2.0), cos(a.w/2.0));\n}\n\nvec4 quat_to_axis_angle(vec4 q){\n    vec3 axis = normalize(q.xyz);\n    float angle = acos(q.w)*2.0;\n    return vec4(axis, angle);\n}\n\nvec4 qexp(vec4 q, float e){\n    vec4 a = quat_to_axis_angle(q);\n    a.w *= e;\n    return axis_angle_to_quat(a);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 cv = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 nv;\n    ivec2 fc = ivec2(fragCoord);\n    if(fc == ivec2(0, 1)){ //Position\n        vec4 vel_texel = texelFetch(iChannel0, ivec2(1, 1), 0);\n        nv = cv + iTimeDelta*vel_texel;\n        \n        if(iFrame == 0) nv = vec4(0.0, -20.0, 10.0, 0.0);\n    }\n    if(fc == ivec2(1, 1)){ //Linear velocity\n        float W = texelFetch(iChannel1, ivec2(87, 0), 0).x;\n        float S = texelFetch(iChannel1, ivec2(83, 0), 0).x;\n        float A = texelFetch(iChannel1, ivec2(65, 0), 0).x;\n        float D = texelFetch(iChannel1, ivec2(68, 0), 0).x;\n        float Q = texelFetch(iChannel1, ivec2(81, 0), 0).x;\n        float R = texelFetch(iChannel1, ivec2(69, 0), 0).x;\n\n        float F = texelFetch(iChannel1, ivec2(70, 0), 0).x;\n        \n        vec4 c_orr = texelFetch(iChannel0, ivec2(0, 2), 0);\n        \n        vec3 right = rotate_vector(c_orr, vec3(1.0, 0.0, 0.0));\n        vec3 up = rotate_vector(c_orr, vec3(0.0, 1.0, 0.0));\n        vec3 forward = rotate_vector(c_orr, vec3(0.0, 0.0,-1.0));\n        \n        float acc = 4.0;\n        \n        vec3 deltaP = vec3(0.0);\n        \n        if(W > 0.0){\n            deltaP += acc*iTimeDelta*forward;\n        }\n        if(S > 0.0){\n            deltaP -= acc*iTimeDelta*forward;\n        }\n        if(A > 0.0){\n            deltaP -= acc*iTimeDelta*right;\n        }\n        if(D > 0.0){\n            deltaP += acc*iTimeDelta*right;\n        }\n        if(Q > 0.0){\n            deltaP += acc*iTimeDelta*up;\n        }\n        if(R > 0.0){\n            deltaP -= acc*iTimeDelta*up;\n        }\n        \n        nv.xyz = cv.xyz + deltaP;\n    }\n    if(fc == ivec2(0, 2)){ //Orientation\n        if(iFrame <= 1){nv = normalize(vec4(1.0, 0.0, 0.0, 1.0));} else {\n            vec4 angvel = texelFetch(iChannel0, ivec2(1, 2), 0);\n            //angvel = normalize(vec4(0.1, 0.0, 0.0, 1.0));\n            if(angvel != vec4(0.0) && angvel != vec4(0.0, 0.0, 0.0, 1.0)){\n                angvel = normalize(angvel);\n                nv = qmul(qexp(angvel, iTimeDelta), cv);\n            } else {\n                nv = cv;\n            }\n        }\n        //nv = cv;\n    }\n    if(fc == ivec2(1, 2)){ //Angular velocity\n        //40 dn\n        //39 rt\n        //38 up\n        //37 lt\n        \n        float d = texelFetch(iChannel1, ivec2(75, 0), 0).x;\n        float r = texelFetch(iChannel1, ivec2(76, 0), 0).x;\n        float u = texelFetch(iChannel1, ivec2(73, 0), 0).x;\n        float l = texelFetch(iChannel1, ivec2(74, 0), 0).x;\n        float L = texelFetch(iChannel1, ivec2(85, 0), 0).x;\n        float R = texelFetch(iChannel1, ivec2(79, 0), 0).x;\n        \n        vec4 c_orr = texelFetch(iChannel0, ivec2(0, 2), 0);\n        \n        vec3 right = rotate_vector(c_orr, vec3(1.0, 0.0, 0.0));\n        vec3 up = rotate_vector(c_orr, vec3(0.0, 1.0, 0.0));\n        vec3 forward = rotate_vector(c_orr, vec3(0.0, 0.0,-1.0));\n        \n        vec3 o = vec3(0.0);\n        \n        if(l>0.5){\n            o -= vec3(1.0, 0.0, 0.0);\n        }\n        if(r>0.5){\n            o += vec3(1.0, 0.0, 0.0);\n        }\n        if(u>0.5){\n            o += vec3(0.0, 1.0, 0.0);\n        }\n        if(d>0.5){\n            o -= vec3(0.0, 1.0, 0.0);\n        }\n        if(L>0.5){\n            o += vec3(0.0, 0.0, 1.0);\n        }\n        if(R>0.5){\n            o -= vec3(0.0, 0.0, 1.0);\n        }\n        \n        if(o != vec3(0.0)){\n            vec3 axis = normalize(o.y*right + -o.x*up + o.z*forward);\n            \n            vec4 q = axis_angle_to_quat(vec4(axis, iTimeDelta));\n            \n            nv = qmul(q, cv);\n        } else {\n            nv = cv;\n        }\n        if(iFrame == 0 || texelFetch(iChannel1, ivec2(32, 0), 0).x>0.5) nv = vec4(0.0, 0.0, 0.0, 1.0);\n        //nv = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    fragColor = nv;\n}","name":"Buffer D","description":"","type":"buffer"}]}