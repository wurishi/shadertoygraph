{"ver":"0.1","info":{"id":"tdscWS","date":"1585514402","viewed":200,"name":"Packing & unpacking","username":"nilrem","description":"Manual implementation of packUnorm4x8(), unpackUnorm4x8(), packSnorm4x8(), unpackSnorm4x8(), etc.\nHandy due to flaky and/or missing support","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["packing","float","bits","integer","unpacking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//#define VISUALIZE_ERROR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    float packed_s = texel.z;\n    float packed_u = texel.w;\n\t\n    // unpack\n    vec4  unpacked_s = unpackSnorm(packed_s) * 0.5 + 0.5;\n    vec4  unpacked_u = unpackUnorm(packed_u);\n    \n    // visualize error of signed vs unsigned version\n#ifdef VISUALIZE_ERROR\n    vec4 error = abs(unpacked_s - unpacked_u);\n    vec4 color = error * 50.;\n    color += vec4( greaterThan(error, vec4(1./260.)) );\n    fragColor = color;\n#else\n    fragColor = unpacked_u;\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4  unpacked_s = vec4( col, 0 );\n    vec4  unpacked_u = vec4( col * 0.5 + 0.5, 0 );\n    \n    // pack\n   \tfloat packed_s = packSnorm(unpacked_s);\n   \tfloat packed_u = packUnorm(unpacked_u);\n    \n    fragColor = vec4(0, 0, packed_s, packed_u);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Pack and unpack 4 uint8 <-> uint32\nhighp uint packUnorm(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackUnorm(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\n// Pack and unpack 4 floats in [0;1] <-> float (containing uint32)\nfloat packUnorm(  vec4  a) { return uintBitsToFloat(packUnorm(uvec4(round(clamp(a, 0., 1.)*255.)))); }\nvec4  unpackUnorm(float a) { return vec4(unpackUnorm(floatBitsToUint(a))) / 255.; }\n\n// Pack and unpack 4 floats in [-1;1] <-> float (containing uint32)\nfloat packSnorm(  vec4  a) { return uintBitsToFloat(packUnorm(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); }\nvec4  unpackSnorm(float a) { return clamp((vec4(unpackUnorm(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); }\n\n// Try this signed version:\n// It doesn't use the full resolution of 8bit two's complement signed integers, errors are visualized\n//float packSnorm(  vec4  a) { return uintBitsToFloat(packUnorm(uvec4(round(clamp(a, -1., 1.)*127.+127.)))); }\n//vec4  unpackSnorm(float a) { return clamp((vec4(unpackUnorm(floatBitsToUint(a))) - 127.) / 127., -1., 1.); }\n","name":"Common","description":"","type":"common"}]}