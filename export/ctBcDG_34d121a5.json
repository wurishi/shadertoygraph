{"ver":"0.1","info":{"id":"ctBcDG","date":"1692207811","viewed":29,"name":"Ridder's method","username":"Envy24","description":"https://en.wikipedia.org/wiki/Ridders%27_method\nDrag search region with mouse.\nLight grey shows Cauchys bounds for roots.\nPretty good method.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["solver","polynomial","root","method","finder","ridder"],"hasliked":0,"parentid":"ml2cRt","parentname":"Laguerre's method"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 4.0 )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat explicitSDF(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return abs(sdf) / sqrt(1.0 + dfdx * dfdx);\n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat explicit(float x) { return eval_poly(x, pcs, degree); }\nfloat dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return (explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    init_poly_coeffs(iTime);\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :\n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n             \n    // Cauchy's roots bounds.\n    float upper_bound = Cauchys_upper_bound(pcs);\n    float lower_bound = Cauchys_lower_bound(pcs);\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.95) : vec3(1.);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n        \n    color = mix(color, vec3(1,0,0), SMAA(explicitSDF(NDC, explicit(NDC.x), dydx(NDC.x))));\n    \n    /**/\n    float r = 0.2,\n          s = iMouse.z > 0. ? 0. : sinOSC(-1., 1., iTime*.5),\n          x0 = MP.x + s - .5 * r,\n          x1 = MP.x + s + .5 * r,\n          x = RiddersMethod(x0, x1, pcs, degree),\n          y = eval_poly(x, pcs, degree);\n          \n    // Float doesn't have enough precision in cases where slope is close infinity.\n    // As an example set T (in init_poly_coeffs) to 145.93, and look for right root (uncomment condition to see root).\n    //if (abs(y) > 1e-5) { y = 0.; } \n    \n    color = mix(color, vec3(1,0,1), SMAA(diskSDF(NDC, vec2(x, y), 0.05)));\n    color = mix(color, vec3(0,0,1), SMAA(vertical_lineSDF(NDC, x0)+0.018));\n    color = mix(color, vec3(0,0,1), SMAA(vertical_lineSDF(NDC, x1)+0.018));\n    /**/\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Min degree 2.\nconst int degree = 14;\nfloat roots[degree];\nfloat pcs[degree + 1];  // Polynomial coeffitients\n#define TOLERANCE ( 1e-4 )\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvoid init_poly_coeffs(float iTime)\n{\n    float T = iTime;\n    pcs[0] = sinOSC(-1.25, 1.25, T * 0.15);  // a   \n    pcs[1] = sinOSC( -2.0,  2.0, T * 0.6);   // b\n    pcs[2] = sinOSC( -1.0,  1.0, T * 0.45);  // c    \n    pcs[3] = sinOSC( -1.0,  1.0, T * 0.25);  // d\n    pcs[4] = sinOSC( -2.0,  1.0, T * 0.17);  // e\n    pcs[5] = sinOSC( -1.0,  4.0, T * 0.07);  // f    \n    pcs[6] = sinOSC( -1.0,  2.0, T * -0.17); // g\n    pcs[7] = sinOSC( -3.0,  1.0, T * -0.3);  // h\n    pcs[8] = sinOSC( -1.0,  1.0, T * 0.3);   // k\n    pcs[9] = sinOSC( -1.0,  1.0, T * 0.12);  // l\n    pcs[10] = sinOSC( -1.0,  1.0, T * 0.17); // m\n    pcs[11] = sinOSC( -1.0,  1.0, T * 0.22); // n\n    pcs[12] = sinOSC( -4.0,  1.0, T * 0.77); // o\n    pcs[13] = sinOSC( -1.0,  2.0, T * 0.8);  // p\n    pcs[14] = sinOSC( -3.0,  1.0, T * 1.04); // q\n}\n\nfloat Cauchys_upper_bound(float pcs[degree + 1])\n{\n    float inv_a = 1./ pcs[0], m = -pcs[0] * inv_a;\n    \n    for (int i = 0; i < degree; ++i)\n    {\n        m = max(m, -pcs[i + 1] * inv_a);\n    }\n    m = max(0., 1. + m);\n    \n    return m;\n}\nfloat Cauchys_lower_bound(float pcs[degree + 1])\n{\n    float inv_a = 1./ pcs[0], m = pcs[0] * inv_a;\n    \n    for (int i = 0; i < degree; ++i)\n    {\n        m = max(m, pcs[i + 1] * inv_a);\n    }\n    m = max(0., 1. + m);\n    \n    return m;\n}\n\nfloat eval_poly(\n    float x,\n    float pcs[degree+1],\n    int degree)\n{\n    float power = x, p_sum = pcs[degree];\n\n    for (int d = 1; d <= degree; ++d)\n    {\n        p_sum += power * pcs[degree - d];\n        power *= x;\n    }\n\n    return p_sum;\n}\n// Source: https://mathsfromnothing.au/ridders-method/?i=1\nfloat RiddersMethod(\n    float x0,\n    float x1,\n    float pcs[degree + 1],\n    int degree)\n{\n    const float tolerance = 1e-6;\n    float xm = 0.,\n          y0 = eval_poly(x0, pcs, degree),\n          y1 = eval_poly(x1, pcs, degree),\n          ym = 0.;\n          \n    if (y0*y1 > 0.) { return 9e5; }\n\n    bool quit = false;\n    for (int i = 0; i < 64 && quit == false; ++i)\n    {\n      xm = (x0 + x1)*.5;\n      ym = eval_poly(xm, pcs, degree);\n      \n      float xn = xm + sign(y0)*ym*(xm-x0)/sqrt(ym*ym-y0*y1),\n            yn = eval_poly(xn, pcs, degree);\n\n      if (ym*yn < 0.)\n      {\n          x0 = xm; x1 = xn;\n          y0 = ym; y1 = yn;\n      }\n      else\n      {\n        if (sign(yn)==sign(y1)) { x1 = xn; y1 = yn; }\n        else                    { x0 = xn; y0 = yn; }\n      }\n      \n      quit = (yn == 0.) || (abs(x1-x0) < tolerance);\n    }\n    \n    return (x0 + x1) * .5;\n}","name":"Common","description":"","type":"common"}]}