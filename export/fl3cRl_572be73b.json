{"ver":"0.1","info":{"id":"fl3cRl","date":"1660301760","viewed":62,"name":"Legendre Polynomials and Roots","username":"Envy24","description":"https://en.wikipedia.org/wiki/Legendre_polynomials","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["derivative","newton","basis","roots","roots","polynomials","raphson","orthogonal","legendre"],"hasliked":0,"parentid":"sl3yRf","parentname":"Romberg-Richardson Integration"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  3.0 / R.y  )\n#define SMAA(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nfloat LegendrePolynomial(float degree, float x)\n{\n    float L_p = 1., L_c = x, L_n = 0.;\n\n    for (float i = 2.; i <= degree; i += 1.)\n    {\n        float n = i - 1.;\n        L_n = ((2.*n+1.)*x*L_c - n*L_p) / (n + 1.);       \n        \n        L_p = L_c; L_c = L_n;\n    }\n    \n    //float dfdx = (degree / (x*x - 1.)) * (x*L_c - L_p);\n    \n    return \n        degree == 0. ?\n            1. :\n            degree == 1. ?\n                x :\n                L_n;\n}\n\nfloat dfdx(float degree, float x)\n{\n    float L_p = 1., L_c = x, L_n = 0.;\n\n    for (float i = 2.; i <= degree; i += 1.)\n    {\n        float n = i - 1.;\n        L_n = ((2.*n+1.)*x*L_c - n*L_p) / (n + 1.);       \n        \n        L_p = L_c; L_c = L_n;\n    }\n    \n    return (degree / (x*x - 1.)) * (x*L_c - L_p);\n}\n\nvec2 LegendrePolynomialAndFirstDerivative(float degree, float x)\n{\n    float L_p = 1., L_c = x, L_n = 0.;\n\n    for (float i = 2.; i <= degree; i += 1.)\n    {\n        float n = i - 1.;\n        L_n = ((2.*n+1.)*x*L_c - n*L_p) / (n + 1.);       \n        \n        L_p = L_c; L_c = L_n;\n    }\n\n    return vec2(\n        degree == 0. ?                        // Ln(x)\n            1. :\n            degree == 1. ?\n                x :\n                L_n,\n        (degree / (x*x - 1.)) * (x*L_c - L_p) // (dLn/dx)(x)\n    );       \n}\n\nvoid calculateRoots1(\n    inout float xs[16],\n    in float degree)\n{\n    if (degree >= 16.) { return; }\n    \n    const float tolerance = 1e-7;\n    float dAngle = (PI)/(degree + 1.);\n    \n    for (float i = 0.; i < degree; i+= 1.)\n    {\n        int idx = int(i);      \n        xs[idx] = i == 0. ? -1.1 : cos(dAngle * i);\n\n        float f = LegendrePolynomial(degree, xs[idx]),\n              t = LegendrePolynomial(degree-1., xs[idx]),\n              dfdx = (degree / (xs[idx]*xs[idx] - 1.)) * (xs[idx]*f - t);\n        \n        for (int s = 0; (s < 16) && (abs(f) > tolerance); ++s)\n        {\n            xs[idx] -= f / dfdx;\n            \n            f = LegendrePolynomial(degree, xs[idx]);\n            t = LegendrePolynomial(degree-1., xs[idx]);\n            dfdx = (degree / (xs[idx]*xs[idx] - 1.)) * (xs[idx]*f - t);\n        }          \n    }\n}\n\nvoid calculateRoots(\n    inout float xs[16],\n    in float degree)\n{\n    if (degree >= 16.) { return; }\n    \n    const float tolerance = 1e-7;\n    float dAngle = (PI)/(degree + 1.);\n    \n    for (float i = 0.; i < degree; i+= 1.)\n    {\n        int idx = int(i);      \n        xs[idx] = i == 0. ? -1.1 : cos(dAngle * i);\n\n        vec2 v = LegendrePolynomialAndFirstDerivative(degree, xs[idx]);\n        \n        for (int s = 0; (s < 16) && (abs(v.x) > tolerance); ++s)\n        {\n            xs[idx] -= v.x / v.y;\n            \n            v = LegendrePolynomialAndFirstDerivative(degree, xs[idx]);\n        }          \n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 1.0\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.25)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n            \n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         //color -= horizontal_line(NDC, -0.5);\n         //color.rg -= vertical_line(NDC, 1.); color.rg -= vertical_line(NDC, -1.);\n\n    float degree = 0., max_degree = 32.;\n    transition(iFrame, 20, degree);\n    degree = mod(degree, max_degree);\n    \n    if (degree < max_degree * 0.5)\n    {       \n        float y = LegendrePolynomial(degree, NDC.x),\n              dydx = dfdx(degree, NDC.x);\n\n        vec3 c = vec3ui3hash(uint(degree), uint(degree+1.), uint(degree+2.));\n             c = (c + 1.) * 0.5;\n\n        color = mix(color, c, draw_func(NDC, YSCALE*y, YSCALE*dydx));\n        \n        float xs[16];\n        \n        calculateRoots(xs, degree);\n        \n        for (float i = 0.; i < degree; ++i)\n        {\n                y = LegendrePolynomial(degree, xs[int(i)]);\n            color = mix(color, vec3(1, 0, 1), SMAA(diskSDF_L2(NDC, vec2(xs[int(i)], y), UNIT*2.5)));\n        }\n    }\n    else \n    {\n        degree -= max_degree * 0.5;\n        for (float i = 0.; i < max(1., degree); i += 1.)\n        {\n             float y = LegendrePolynomial(i, NDC.x),\n                   dydx = dfdx(i, NDC.x);\n\n             vec3 c = vec3ui3hash(uint(i), uint(i+1.), uint(i+2.));\n                  c = (c + 1.) * 0.5;\n\n             color = mix(color, c, draw_func(NDC, YSCALE*y, YSCALE*dydx));\n        }\n    }\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\n/* Every num_of_frames returns true \nand number of detected transitions. */\nbool transition(\n    in int frame,\n    in int num_of_frames,\n    inout float quotent)\n{\n    // Convert to float.\n    float f = float(frame == 0 ? 1 : frame);\n    float inv = 1.0 / float(num_of_frames);\n    \n    // Calculate previous and current quotents.\n    float prev = floor(f * inv);\n    quotent = floor((f - 1.0) * inv);\n    \n    return quotent < prev;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 vec3ui3hash(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}","name":"Common","description":"","type":"common"}]}