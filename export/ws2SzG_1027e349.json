{"ver":"0.1","info":{"id":"ws2SzG","date":"1560141859","viewed":218,"name":"âœ“scaleMARK (Textureless)","username":"blackle","description":"most of the code for my 4k \"scalemark\"","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["4k"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define MAXDEPTH 6\n\nfloat polarized;// = false;\n\nvec3 ML(float F) {\n    return mat3(1.5,-.2,-.1,-.6,1.1,.2,-.1,.1,1.5)*(.5-.5*cos(2.*F*vec3(5.2,5.7,7.2)));\n}\n\nstruct Ray\n{\n  vec3 m_origin;\n  vec3 m_direction;\n  vec3 m_point;\n  vec3 m_color;\n  float m_attenuation;\n  float m_lag;\n};\n\nfloat sdLine(vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sidecond(vec2 p, vec2 a, vec2 b) {\n    return dot(p-b, (a-b).yx*vec2(-1.,1.));\n}\n\nfloat sdProfile(vec2 p) {\n    vec2 a = vec2(0.0);\n    vec2 c = vec2(0.05, 0.4);\n    vec2 d = vec2(0.05, 5.0);\n    vec2 e = vec2(0.0, 5.0);\n    float dist = min(min(sdLine(p,e,a), sdLine(p,c,d)), sdLine(p,a,c));\n    if (sidecond(p, a, c) < 0.0\n        && sidecond(p, e, a) < 0.0\n        && sidecond(p, c, d) < 0.0) dist *= -1.0;\n    return dist;\n}\nfloat triangle(vec2 pp) {\n    vec2 p = pp + vec2(0.5,4.0);\n    vec2 a = vec2(0.0);\n    vec2 c = vec2(4.0, 0.0);\n    vec2 d = vec2(0.0, 8.0);\n    float dist = min(min(sdLine(p,d,a), sdLine(p,c,d)), sdLine(p,a,c));\n    if (sidecond(p, a, c) < 0.0\n        && sidecond(p, d, a) < 0.0\n        && sidecond(p, c, d) < 0.0) dist *= -1.0;\n    return dist;\n}\n\nfloat half_ring(vec2 p, float radius, float thickness) {\n    return abs(max(length(p)-radius,-0.4-p.x))-thickness;\n}\n\nfloat square(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat scene(vec3 p) {\n    float ruler = sdProfile(vec2(p.z,-square(p.xy, vec2(0.8,4.0))))-0.05;\n    float ruler_hole = min(length(p.xy+vec2(0.0,3.0))-0.3, length(p.xy+vec2(0.0,-4.0))-0.1);\n    vec2 ruler2pos = vec2(-1.0,1.0)*p.xy+vec2(5.5,0.0);\n    float ruler2 = sdProfile(vec2(p.z,-half_ring(ruler2pos, 3.3, 0.7)))-0.05;\n    vec2 ruler3pos = p.xy+vec2(5.0,0.0);\n    float ruler3 = sdProfile(vec2(p.z,-abs(triangle(ruler3pos)+0.5)+0.5))-0.05;\n    return max(min(min(ruler, ruler2),ruler3),-ruler_hole);\n}\n\nfloat stress_blob(vec2 p) {\n    return pow(max(1.0-length(p),0.0),4.0);\n}\n\nfloat stress(vec3 p) {\n    vec2 ruler2pos = vec2(-1.0,1.0)*p.xy+vec2(5.5,0.0);\n    vec2 ruler3pos = p.xy+vec2(5.0,0.0);\n    return (0.5+0.5*sin(p.x*2.0))*0.25 + (0.5+0.5*cos(p.y*0.5))*0.25\n         + max(1.0-sdLine(p.xy, vec2(0.0,3.7), vec2(0.0,-3.7)),0.0)\n         + max(1.0-abs(max(length(ruler2pos)-3.3,-0.4-ruler2pos.x)),0.0)\n         + max(1.0-abs(triangle(ruler3pos)+0.5),0.0)\n         + stress_blob(p.xy+vec2(0.0,3.3))*2.0\n         + stress_blob(p.xy+vec2(0.0,2.7))*2.0\n         + stress_blob(p.xy+vec2(0.3,-4.0))*3.0\n         + stress_blob(p.xy+vec2(-0.3,-4.0))*3.0\n         + stress_blob(p.xy+vec2(-5.2,-2.6))*5.0\n         + stress_blob(p.xy+vec2(-5.2,2.6))*5.0\n         + stress_blob(p.xy+vec2(4.5,0.4))*4.0\n         + stress_blob(p.xy+vec2(4.5,3.0))*4.0\n         + stress_blob(p.xy+vec2(3.2,2.9))*4.0\n         + stress_blob(p.xy+vec2(-6.3,-4.0))\n         + stress_blob(p.xy+vec2(-6.3,4.0))\n         - stress_blob(p.xy+vec2(0.3,3.0))\n         - stress_blob(p.xy+vec2(-0.3,3.0));\n}\nvec3 sceneGrad(vec3 point) {\n    float t = scene(point);\n    return normalize(vec3(\n        t - scene(point + vec3(0.0001,0.0,0.0)),\n        t - scene(point + vec3(0.0,0.0001,0.0)),\n        t - scene(point + vec3(0.0,0.0,0.0001))));\n}\n\nbool castRay(inout Ray ray) {\n    // Cast ray from origin into scene\n    float sgn = sign(scene(ray.m_origin));\n    for (int i = 0; i < 100; i++) {\n        float dist = length(ray.m_point - ray.m_origin);\n        if (dist > 40.0) {\n            return false;\n        }\n\n        float smpl = scene(ray.m_point);\n        \n        if (abs(smpl) < 0.0001) {\n            return true;\n        }\n        \n        if (sgn < 0.0) ray.m_lag -= stress(ray.m_point)*4.0*smpl;\n        \n        ray.m_point += smpl * ray.m_direction * sgn;\n    }\n    ray.m_attenuation*=0.0;\n    return false;\n}\n\n\nvec3 backlight(vec3 dir, float lag) {\n    return ML(0.3+polarized*lag)*3.0*smoothstep(0.0,1.0,-0.8-dir.z*4.0)*(dir.z>-0.1?1.0:pow(min(0.5+0.5*cos(dir.x/dir.z*400.0),0.5+0.5*cos(dir.y/dir.z*400.0)),0.02));\n}\nvoid phongShadeRay(inout Ray ray) {\n        vec3 normal = -sceneGrad(ray.m_point);\n\n        vec3 reflected = reflect(ray.m_direction, normal);\n        float frensel = abs(dot(ray.m_direction, normal));\n        //oh god blackle clean this up\n        ray.m_color += backlight(reflected,ray.m_lag)*0.8* (1.0 - frensel*0.98)*ray.m_attenuation;\n      \n            // ray.m_attenuation*=0.0;\n        \n        // if (normal.z < -0.99 && sin(ray.m_point.y*60.0)>0.8 && ray.m_point.x<-0.6+(sin(ray.m_point.y*60.0/5.0)>0.5?0.1:0.0)) {\n        //     ray.m_attenuation*=0.0;\n        // }\n}\n\nvoid transmitRay(inout Ray ray) {\n\tfloat ior = 1.4;\n    float sgn = sign(scene(ray.m_origin));\n    vec3 normal = -sgn*sceneGrad(ray.m_point);\n    //float frensel = clamp(abs(dot(ray.m_direction, normal))+0.5, 0.0,1.0); //this equation is bullshit\n    ray.m_point -= normal*0.0005;\n    \n    ray.m_direction = refract(ray.m_direction, normal, sgn>0.0?1.0/ior:ior);\n    float frensel = abs(dot(ray.m_direction, normal));\n    ray.m_attenuation *= exp(-length(ray.m_point-ray.m_origin)*0.01)/exp(0.0);\n\n    ray.m_origin=ray.m_point;\n}\n\nvoid recursivelyRender(inout Ray ray) {\n    for (int i = 0; i < MAXDEPTH; i++) {\n        if (castRay(ray)) {\n            phongShadeRay(ray);\n            transmitRay(ray);\n        } else {\n            ray.m_color += (i==0?pow(1.0-polarized,2.0):1.0)*backlight(ray.m_direction, ray.m_lag)*ray.m_attenuation;\n\t\t\treturn;\n        }\n    }\n}\n\nvec2 Nth_weyl(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\n#define SAMPLES 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tpolarized = sqrt(smoothstep(0.0, 1.0,iTime-10.0));\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv_base = (fragCoord/iResolution.xy)*2.0 - vec2(1.0,1.0);\n    uv_base.y *= iResolution.y/iResolution.x;\n    float pixelsize = 1.0/iResolution.x*2.5;\n\n\tvec3 cameraOrigin = vec3(4.0*sin(iTime*0.25), 4.0*cos(iTime*0.25), 5.0*abs(sin(iTime*0.1)))*4.0;\n\tvec3 focusOrigin = vec3(0.0, 0.0, 0.3);\n\tvec3 cameraDirection = normalize(focusOrigin-cameraOrigin);\n\n\tvec3 up = vec3(0.0,0.0,-1.0);\n\tvec3 plateXAxis = normalize(cross(cameraDirection, up));\n\tvec3 plateYAxis = normalize(cross(cameraDirection, plateXAxis));\n\n\tfloat fov = radians(40.0);\n\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < SAMPLES;i++){\n   \t\tvec2 uv = uv_base + Nth_weyl(i)*pixelsize;\n\t\tvec3 platePoint = (plateXAxis * -uv.x + plateYAxis * uv.y) * tan(fov /2.0);\n\n   \t\tRay ray = Ray(cameraOrigin, normalize(platePoint + cameraDirection), cameraOrigin, vec3(0.0), 1.0, 0.0);\n    \trecursivelyRender(ray);\n    \tcol+= ray.m_color/float(SAMPLES);\n    }\n\n    col *= pow(max(1.0 - pow(length(uv_base)*0.7, 4.0), 0.0),3.0); \n    \n    fragColor = vec4(sqrt(log(max(col+vec3(0.01,0.01,0.02),0.0)*.7+1.0))*0.9, 1.0);\n}","name":"Image","description":"","type":"image"}]}