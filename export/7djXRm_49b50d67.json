{"ver":"0.1","info":{"id":"7djXRm","date":"1619951204","viewed":216,"name":"Cuboid Artifact","username":"Hyeve","description":"Collab with @Tater - he likes doing geometry, I like doing lighting, so we combined our skills and made this :>","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","collab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Cuboid Artifact\" by Tater. https://shadertoy.com/view/Nd2SRw\n// 2021-05-02 10:25:29\n\n#define STEPS 256.0\n#define MDIST 250.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p, x) (mod(p,x)-0.5*(x))\nfloat glow = 0.0;\n\n//Geometry by Tater\n//----------------------------------------------------------------\n\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat frame(vec3 p, vec3 s, float e){\n    vec2 h = vec2(e,0);\n    float a = box(p,s);\n    float b = box(p,s*1.01-h.xxy);\n    a = max(-b,a);\n    b = box(p,s*1.01-h.xyx);\n    a = max(-b,a);\n    b = box(p,s*1.01-h.yxx);\n    a = max(-b,a);\nreturn a;\n}\n\nfloat timeRemap (float t,float s1, float s2, float c){\n    return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)+s1*t;  \n}\n\nvoid mo(inout vec2 p){\n  if(p.y>p.x) p = p.yx;\n}\n\nvec2 map(vec3 p){\n    vec3 po2 = p;\n    \n    p.xz*=rot(iTime*0.8);\n    p.xy*=rot(iTime*0.4);\n    vec3 po = p;\n    float t = iTime*0.7;\n    \n    t = timeRemap(t*1.3, 0., 2.3, 0.1);\n    \n    \n    for(float i = 0.0; i< 9.0; i++){\n        p = abs(p)-2.0*i*(vec3(0.35*asin(sin(t*0.15)),0.2*asin(sin(t*0.22)),0.3*asin(sin(t*0.38))));\n        p.xz*=rot(pi/2.0);\n        mo(p.xy);//credit to FMS_CAT for this technique, I still have no idea how he makes it look so good\n        mo(p.zy);\n    }\n    \n    //Inner Cubes\n    p = pmod(p,2.2);\n    vec2 a = vec2(box(p,vec3(0.5)),1.0);\n    a.x = abs(a.x)-0.2;\n    a.x = abs(a.x)-0.1;\n    //Inner Inner glowy Cubes\n    vec2 b = vec2(box(p,vec3(0.45)),2.0);\n    glow+=0.01/(0.01+b.x*b.x);\n    a = (a.x<b.x)?a:b;\n    \n    p = po;\n    p.xy*=rot(pi/4.0);\n    \n    //Boundry Cut Cube\n    vec3 cube = vec3(4,4,4)*vec3(1.2+0.5*sin(t),1.2+0.5*cos(t),1.2+0.5*sin(t));\n    a.x = max(box(p,cube),a.x);\n    //Outer Frame\n    b= vec2(frame(p,cube+0.15,0.45),3.0);\n    a = (a.x<b.x)?a:b;\n    \n    //Repeating Poles\n    po2.y-=iTime*20.0;\n    po2=mod(po2,80.0)-40.0;\n    b.x = length(po2.xz)-2.0;\n    b.x = min(b.x,length(po2.zy)-2.0);\n    b.x = min(b.x,length(po2.xy)-2.0);\n    b.y=4.0;\n    a = (a.x<b.x)?a:b;\n    \n    return a;\n}\n\n\n//----------------------------------------------------------\n\n\n#define ZERO (min(iFrame,0))\nvec3 norm(vec3 p){\n    \n#if 0    \n    vec2 e= vec2(0.01,0);\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n#endif  \n}\n\n\n//Lighting & modified tracing by Drake (me)\n//----------------------------------------------------------------------------\nvec3 tr(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n    float shad = 0.0;\n    vec2 d = vec2(0);\n    \n    for(float i = 0.0; i < STEPS; i++){\n        vec2 s = map(p);\n        d.x += s.x*0.8;d.y=s.y;\n        p = ro+rd*d.x;\n        if(abs(s.x)<0.001||i==STEPS-1.0 ){\n            shad = i/STEPS;\n            break;\n        }\n        if(d.x>MDIST){ break;d.x=MDIST;d.y=0.;};\n    }\n    return vec3(d.x,d.y,shad);\n}\n\nvec3 lit(vec3 p, vec3 h, vec3 rd, vec3 al, vec3 n)\n{\n    vec3 fo = vec3(sin(iTime/10.)*0.5+0.5,cos(iTime/5.)*0.5+0.5,sin(iTime/5.)*0.5+0.5) * 0.1;\n    vec3 col = fo;\n    vec3 sss = vec3(0.5)*smoothstep(0.,1.,map(p+-rd*0.2).x/0.2);\n    float fom = clamp(h.x/MDIST,0.0,1.0);\n    float ffom =fom;\n    \n    //sneaky way to simplify lighting - i use -rd as the light direction, which\n    //makes it as if there's a point light at the camera position, and also makes\n    //fresnel a very simple calculation (essentially just the inverse of the diffuse)\n    float diffs = dot(n, -rd);\n    float diff = max(diffs,0.);\n    float fres = pow(1. - abs(diffs),4.);\n    float spec = pow(max(dot(reflect(-rd,n),rd),0.2),20.)*2.;\n\n    //this is a little bit wacky but works\n    if(h.y==4.){spec = 0.;fres=0.;ffom=0.;diff=0.;}\n    \n    //Definitely not using SSS as intended, but hey, it looks good!\n    col = mix(al * (fres + spec + diff/14.), diff * sss - h.z, ffom);\n    col = mix(col,fo,pow(fom,3.));\n    return col*3.;\n}\n\n//-------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 al = vec3(0);\n    //maybe a bit overkill to have a full camera \n    vec3 ro = vec3(0,2,-20);\n    ro.xz*=rot(iTime*0.2);\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f+uv.x*r+uv.y*cross(f,r);\n    \n    vec3 d = tr(ro,rd);\n    vec3 p = ro+rd*d.x;\n\n    if(d.y==1.0) al = vec3(0.945,0.027,0.027);\n    if(d.y==2.0) al = vec3(0.741,0.059,1.000);\n    if(d.y==3.0) al = vec3(0.000,0.000,0.000);\n    if(d.y==4.0) al = vec3(0.839,0.812,0.780);\n    \n    //More lighting bits\n    vec2 e = vec2(0.01,0);\n    vec3 n = norm(p);\n    vec3 od = d;\n    vec3 op = p;\n    col = lit(p,d,rd,al,n);    \n    vec3 refld = reflect(rd,n);\n    d = tr(p + n*0.01,refld);\n    p = p+refld*d.x;\n    n = norm(p);\n    vec3 refl = lit(p,d,rd,al,n);\n    if(d.y<4.&&d.y>0.&&od.y>0.&&od.y<4.) col = mix(col,refl,0.5);\n    if(d.y>0.&&od.y<3.&&d.y<3.)col+=glow*0.03*vec3(0.741,0.059,1.000);    \n    //----------------\n\n       \n    col = pow(col,vec3(0.75));//Gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}