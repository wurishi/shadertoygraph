{"ver":"0.1","info":{"id":"4XBGWm","date":"1708504264","viewed":82,"name":"Base Study 3d func 2","username":"davidmachadosf","description":"Includes a reset time, \"t\" rey\n","likes":0,"published":1,"flags":48,"usePreview":1,"tags":["math"],"hasliked":0,"parentid":"lXsGR2","parentname":"Base Study 3d func"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n\n\nfloat pi = 3.141592;\n\n// gohu font start\n#define _EXCLAM TXT(p,uvec3(         0,    458240,         0)); // '!'\n#define _QUOTE  TXT(p,uvec3( 939524096,         0,       224)); // '\"'\n#define _SHARP  TXT(p,uvec3(4161339428,4286615583,  37751041)); // '#'\n#define _DOLLAR TXT(p,uvec3( 272908430, 287309585, 236995649)); // '$'\n#define _PRCENT TXT(p,uvec3(1354842114,2349123596, 268476610)); // '%'\n#define _AMP    TXT(p,uvec3(2956722176, 344207888, 285227201)); // '&'\n#define _TICK   TXT(p,uvec3(         0,      7680,         0)); // '''\n#define _LPAREN TXT(p,uvec3(1612578816,   8913944,         4)); // '('\n#define _RPAREN TXT(p,uvec3( 134217728,2248672320,      7681)); // ')'\n#define _TIMES  TXT(p,uvec3(    655428, 268695553,  71305728)); // '*'\n#define _PLUS   TXT(p,uvec3(    262160, 268695553,  16778240)); // '+'\n#define _COMMA  TXT(p,uvec3(         0,    917592,         0)); // ','\n#define _MINUS  TXT(p,uvec3(    262144, 268451841,  16778240)); // '-'\n#define _PERIOD TXT(p,uvec3(         0,    393240,         0)); // '.'\n#define _FSLASH TXT(p,uvec3(  12582912, 201375756,    786624)); // '/'\n#define _0      TXT(p,uvec3( 272596992, 151274514, 266355009)); // '0'\n#define _1      TXT(p,uvec3(1073872896,4278192128,         1)); // '1'\n#define _2      TXT(p,uvec3( 274825216, 285508628, 274743873)); // '2'\n#define _3      TXT(p,uvec3( 270565376, 285492240, 249578561)); // '3'\n#define _4      TXT(p,uvec3(2148270080, 570462210,  33587136)); // '4'\n#define _5      TXT(p,uvec3(2418262016, 151266320, 252723777)); // '5'\n#define _6      TXT(p,uvec3(2420080640, 151266320, 251675201)); // '6'\n#define _7      TXT(p,uvec3( 268451840, 822543360,   3146560)); // '7'\n#define _8      TXT(p,uvec3( 272334848, 285492241, 249578561)); // '8'\n#define _9      TXT(p,uvec3( 268664832, 285492241, 132129857)); // '9'\n#define _COLON  TXT(p,uvec3(         0,2349215744,         1)); // ':'\n#define _SCOLON TXT(p,uvec3(3221225472,    929880,         0)); // ';'\n#define _LT     TXT(p,uvec3(    524288,  67248133,     32897)); // '<'\n#define _EQ     TXT(p,uvec3(1074855936,1140920324,  71307520)); // '='\n#define _GT     TXT(p,uvec3(1082163200,1342316560,      2048)); // '>'\n#define _QMARK  TXT(p,uvec3( 134234112, 277250560,   7340576)); // '?'\n#define _AT     TXT(p,uvec3(3359645951,1116015123, 401623201)); // '@'\n#define _A      TXT(p,uvec3( 276791296, 285230081, 534774848)); // 'A'\n#define _B      TXT(p,uvec3( 276807680, 285492241, 249578561)); // 'B'\n#define _C      TXT(p,uvec3( 272596992,  17040400, 136331329)); // 'C'\n#define _D      TXT(p,uvec3( 276807680,  17040400, 130031745)); // 'D'\n#define _E      TXT(p,uvec3( 276807680, 285492241, 269500481)); // 'E'\n#define _F      TXT(p,uvec3( 276807680, 285230081,   1048640)); // 'F'\n#define _G      TXT(p,uvec3( 272596992, 285475856, 253772865)); // 'G'\n#define _H      TXT(p,uvec3(   8372224, 268451841, 535823360)); // 'H'\n#define _I      TXT(p,uvec3( 268435456,  17300496,         1)); // 'I'\n#define _J      TXT(p,uvec3(   3145728,    262160, 267403265)); // 'J'\n#define _K      TXT(p,uvec3(   8372224,1140891649, 269492352)); // 'K'\n#define _L      TXT(p,uvec3(   8372224,    262160, 268451841)); // 'L'\n#define _M      TXT(p,uvec3(1073775103,  67133440, 535822464)); // 'M'\n#define _N      TXT(p,uvec3(1618984960,1610637312, 535846912)); // 'N'\n#define _O      TXT(p,uvec3( 272596992,  17040400, 266354753)); // 'O'\n#define _P      TXT(p,uvec3( 276807680, 285230081,  14681152)); // 'P'\n#define _Q      TXT(p,uvec3( 272596992,1627653136, 937435201)); // 'Q'\n#define _R      TXT(p,uvec3( 276807680, 822100993, 417338432)); // 'R'\n#define _S      TXT(p,uvec3( 270761984, 285492241, 236995649)); // 'S'\n#define _T      TXT(p,uvec3( 268451841,  17300480,   1048640)); // 'T'\n#define _U      TXT(p,uvec3(   4177920,    262160, 267403265)); // 'U'\n#define _V      TXT(p,uvec3(    245760,2147876871,  15735809)); // 'V'\n#define _W      TXT(p,uvec3(   7340095, 536899586,  66088960)); // 'W'\n#define _X      TXT(p,uvec3(3227566080, 268451846, 405805824)); // 'X'\n#define _Y      TXT(p,uvec3(    196611, 268926977,   3146496)); // 'Y'\n#define _Z      TXT(p,uvec3( 275791872, 151274514, 271597889)); // 'Z'\n#define _LBRKET TXT(p,uvec3(         0,   9436672,     32802)); // '['\n#define _BSLASH TXT(p,uvec3( 805318656, 805318656, 805318656)); // '\\'\n#define _RBRKET TXT(p,uvec3( 134217728,4287103520,         3)); // ']'\n#define _CARET  TXT(p,uvec3( 268468224,  16777728,       128)); // '^'\n#define _UNDER  TXT(p,uvec3(   8389120,    524320, 536903682)); // '_'\n#define _BTICK  TXT(p,uvec3( 268443648,      2048,         0)); // '`'\n#define _a      TXT(p,uvec3(1077411840, 335826961, 528491777)); // 'a'\n#define _b      TXT(p,uvec3(2155864064,  67375120, 260063489)); // 'b'\n#define _c      TXT(p,uvec3(1077805056,  67375120, 142622977)); // 'c'\n#define _d      TXT(p,uvec3(1077805056,  67375120, 536355073)); // 'd'\n#define _e      TXT(p,uvec3(1077805056, 604278802, 327174401)); // 'e'\n#define _f      TXT(p,uvec3(4026531840, 142615071,       544)); // 'f'\n#define _g      TXT(p,uvec3(1077805056,  69472400,2143428873)); // 'g'\n#define _h      TXT(p,uvec3(2155864064,  67112960, 528482560)); // 'h'\n#define _i      TXT(p,uvec3(1073807360,    521728,     16385)); // 'i'\n#define _j      TXT(p,uvec3(  33554432,4255125632,         7)); // 'j'\n#define _k      TXT(p,uvec3(   8380416,1342210050, 268444160)); // 'k'\n#define _l      TXT(p,uvec3( 134217728,    261632, 268451841)); // 'l'\n#define _m      TXT(p,uvec3(1073807868,  67629056, 528482560)); // 'm'\n#define _n      TXT(p,uvec3(1082064896,  67112960, 528482560)); // 'n'\n#define _o      TXT(p,uvec3(1077805056,  67375120, 260063489)); // 'o'\n#define _p      TXT(p,uvec3(2214526976,  67375120, 260063489)); // 'p'\n#define _q      TXT(p,uvec3(1077805056,  67375120,4290781441)); // 'q'\n#define _r      TXT(p,uvec3(2155806720,  67112960,   8388864)); // 'r'\n#define _s      TXT(p,uvec3(1078329344, 604278802, 201345281)); // 's'\n#define _t      TXT(p,uvec3(1073741824,  67370496,     16641)); // 't'\n#define _u      TXT(p,uvec3(   4128768,    262160, 532684801)); // 'u'\n#define _v      TXT(p,uvec3(    458752,2147876870,  29366273)); // 'v'\n#define _w      TXT(p,uvec3(   6291580,1073790980, 130048000)); // 'w'\n#define _x      TXT(p,uvec3(   6488064, 536903685, 415241216)); // 'x'\n#define _y      TXT(p,uvec3(   4128768,   2359440,2143428617)); // 'y'\n#define _z      TXT(p,uvec3(1080098816, 335843348, 272646913)); // 'z'\n#define _LCURL  TXT(p,uvec3(    524320,   9403394,1074331684)); // '{'\n#define _PIPE   TXT(p,uvec3(         0,   2096640,         0)); // '|'\n#define _RCURL  TXT(p,uvec3( 151003136,3742368320,  33556483)); // '}'\n#define _TILDE  TXT(p,uvec3(2147614768, 536887296,  25167872)); // '~'\n#define _        CURSOR.x+=8;\n#define _NEWLINE CURSOR=ivec2(CURSOR_START.x, CURSOR.y-14);\n#define NUM(value) _NUM(p,float(value), 0);\n#define FNUM(value) _NUM(p,value, 6);\nvec3 TXT_COL=vec3(0.0); ivec2 CURSOR_START = ivec2(0), CURSOR = ivec2(0);\nvoid TXT(vec2 p, uvec3 g){_ int x=int(p.x)-CURSOR.x,y=CURSOR.y-int(p.y),b=x*14+y-16;if(x>0&&x<8&&y>=0&&y<14&&b>=0)TXT_COL+=vec3((g[b/32]>>(b&31))&1u); }\nvoid _NUM(vec2 p, float n,int point){\n\n    if(n<0.){_MINUS n=-n;}\n    \n    \n    //for (int i=6,k=100000000,m=int(round(n*100.0));\n    //         i>-3;\n    //         i--,k/=10){\n   \n    \n    if(int(n)==0 && point==0) _0 \n    \n    \n    int ints = 0;\n    while(n>=1.){\n       n/=10.;\n       ints++;        \n    }\n\n\n   \n\n    int d;\n    while(ints>0){\n        \n        n*=10.;\n        d= int(n);\n        \n        if(d==0)_0 \n        if(d==1)_1 \n        if(d==2)_2 \n        if(d==3)_3 \n        if(d==4)_4 \n        if(d==5)_5 \n        if(d==6)_6 \n        if(d==7)_7 \n        if(d==8)_8 \n        if(d==9)_9 \n\n        \n        n -= float(d);\n        ints--;\n    }\n    \n    \n    if(point==0) return;\n\n    _PERIOD \n\n    int decs = 0;\n    while(decs<point){\n        \n        n*=10.;\n        d= int(n);\n        \n        if(d==0)_0 \n        if(d==1)_1 \n        if(d==2)_2 \n        if(d==3)_3 \n        if(d==4)_4 \n        if(d==5)_5 \n        if(d==6)_6 \n        if(d==7)_7 \n        if(d==8)_8 \n        if(d==9)_9 \n\n        \n        n -= float(d);\n        decs++;\n    }\n        \n}\n// gohu font end\n\n\n\nfloat atan2_error(float y, float x){\n\n    if(x==0.) return (pi/2.)*(y>=0.?1.:-1.);\n    \n    float atanYX = atan(y,x);\n    \n    if(x>0.) return atanYX;\n    \n    return atanYX + pi*(y<0.?1.:-1.); \n\n}\n\n\nfloat atan2int( float y, float x )\n{\n    \n    if ( x == 0.0f )\n\t{\n\t\tif ( y > 0.0f ) return pi/2.;\n\t\tif ( y == 0.0f ) return 0.;\n\t\treturn -pi/2.;\n\t}\n\t\n    float z = y/x;\n    float atg = atan(z);\n\t\n    \n\tif (x>0.) {\n\t\treturn atg;\n\t}\n\telse {\n\t\tif ( y < 0. ) return atg - pi;\n        return atg + pi;\n\t}\n    \n}\n\n\n\nfloat uniform_to_widthNanometers (float u){\n    return 380. + 400.*(1.-u);\n}\n\nfloat uniform_to_freqTeraHertz (float u){\n    return (384. + 405.*u)*1.e3;\n}\n\nvec4 paletteReal( float w ) {\n    \n    float red, green, blue;\n\n    if (w >= 380. && w < 440.) {\n        red   = -(w - 440.) / (440. - 380.);\n        green = 0.;\n        blue  = 1.;\n    }\n    else \n    if (w >= 440. && w < 490.) {\n        red   = 0.;\n        green = (w - 440.) / (490. - 440.);\n        blue  = 1.;\n    }\n    else \n    if (w >= 490. && w < 510.) {\n        red   = 0.;\n        green = 1.;\n        blue  = -(w - 510.) / (510. - 490.);\n    }\n    else \n    if (w >= 510. && w < 580.) {\n        red   = (w - 510.) / (580. - 510.);\n        green = 1.;\n        blue  = 0.;\n    }\n    else \n    if (w >= 580. && w < 645.) {\n        red   = 1.;\n        green = -(w - 645.) / (645. - 580.);\n        blue  = 0.;\n    }\n    else \n    if (w >= 645. && w < 781.) {\n        red   = 1.;\n        green = 0.;\n        blue  = 0.;\n    }\n    else {\n        red   = 0.;\n        green = 0.;\n        blue  = 0.;\n    }\n\n\n    // Let the intensity fall off near the vision limits\n    float factor;\n    if (w >= 380. && w < 420.)\n        factor = .3 + .7*(w - 380.) / (420. - 380.);\n    else \n    if (w >= 420. && w < 701.)\n        factor = 1.;\n    else \n    if (w >= 701. && w < 781.)\n        factor = .3 + .7*(780. - w) / (780. - 700.);\n    else\n        factor = 0.;\n\n    float gamma = .8;\n    float R = (red   > 0. ? 255.*pow(red   * factor, gamma) : 0.);\n    float G = (green > 0. ? 255.*pow(green * factor, gamma) : 0.);\n    float B = (blue  > 0. ? 255.*pow(blue  * factor, gamma) : 0.); \n    \n    return vec4(R/255.,G/255.,B/255.,1.);\n}\n\nvec4 paletteRealUniform( float u ) {\n    return paletteReal(uniform_to_widthNanometers(u));\n}\n\nvec4 paletteAlien( float u ) {\n    \n    vec4 pal1 = paletteRealUniform(u);\n    vec4 pal2 = paletteRealUniform(1.-u);    \n    \n    return (pal1+pal2)/2.;\n    \n}\n\n\nvec4 paletteAssimetric( float u ) {\n    \n    vec4 pal1 = paletteAlien(u);\n    vec4 pal2 = paletteRealUniform(u);    \n    \n    return (pal1-pal2);\n    \n}\n\n\nvec4 paletteBars( float u ) {\n    \n    //vec4 pal1 = paletteAlien(u);\n    vec4 pal1 = paletteRealUniform(1.-u);    \n    vec4 pal2 = paletteRealUniform(u); \n    vec4 pal3 = paletteAlien(1.-u);\n    \n    return (pal1*pal2 + pal3)/4.;\n    \n}\n\nvec4 paletteGray( float u ) {\n   if(u>1.) u = 1.;\n   if(u<0.) u = 0.;\n   \n   return vec4(u,u,u,1.);\n}\n\n\nvec4 paletteGold( float u ) {\n   \n   if(u>1.) u = 1.;\n   if(u<0.) u = 0.;\n   \n   vec4 gold = vec4(10.*u/16.,8.*u/16.,2.*u/16.,1.);\n   vec4 red = 1.-(1.-vec4(15.*pow(u,55.)/16.,0.,0.,1.));\n\n   return gold+red;\n}\n\nvec4 paletteCrazy( float u ) {\n    \n    //vec4 pal1 = paletteAlien(u);\n    vec4 pal1 = paletteRealUniform(1.-u*u);    \n    vec4 pal2 = paletteRealUniform(u); \n    vec4 pal3 = paletteGray(pow(sin(10.*u),2.));\n    \n    return (pal3*(pal2 + pal1));\n    \n}\n\n\nvec4 paletteCrazy2( float u ) {\n    \n    //vec4 pal1 = paletteAlien(u);\n    vec4 pal1 = paletteRealUniform(1.-u*u);    \n    vec4 pal2 = paletteRealUniform(pow(u,2.)); \n    vec4 pal3 = paletteGray(pow(sin(10.*u),2.));\n    \n    return (pal3*(pal2 + pal1));\n    \n}\n\nvec4 paletteCrazy3( float u ) {\n    \n    vec4 pal1 = paletteAlien(u);\n    //vec4 pal1 = paletteRealUniform(1.-u*u);    \n    vec4 pal2 = paletteRealUniform(u); \n    vec4 pal3 = paletteGray(pow(sin(50.*u),2.));\n    \n    return (pal3*(pal2 + pal1));\n    \n}\n\nvec4 paletteCrazy4( float u ) {\n    \n    //vec4 pal1 = paletteAlien(u);\n    vec4 pal2 = paletteRealUniform(1.-u*u);    \n    vec4 pal1 = paletteRealUniform(u); \n    vec4 pal3 = paletteGray(pow(sin(10.*u),2.));\n    \n    return (pal3*(pal2 + pal1));\n    \n}\n\nvec4 paletteCrazy5( float u ) {\n    \n    //vec4 pal1 = paletteAlien(u);\n    vec4 pal1 = paletteRealUniform(1.-u*u);    \n    vec4 pal2 = paletteRealUniform(u); \n    vec4 pal3 = paletteGray(pow(cos(10.*u),2.));\n    \n    return (pal3*(pal2 + pal1));\n    \n}\n\nvec4 processPallete(int pall, float u, bool urev){\n    \n    \n    if(urev){\n       u = 1.-u;\n    }\n    \n    \n    switch(pall){\n        case  0: return paletteRealUniform(u);\n        case  1: return paletteGray(u);\n        case  2: return paletteGold(u);\n        case  3: return paletteAlien(u);\n        case  4: return paletteAssimetric(u);\n        case  5: return paletteBars(u);\n        case  6: return paletteCrazy(u);\n        case  7: return paletteCrazy2(u);\n        case  8: return paletteCrazy3(u);\n        case  9: return paletteCrazy4(u);\n        case 10: return paletteCrazy5(u);\n    }\n}\n\n\n// xy are generic 2d coordinates, not necessarily cartesian\n// maybe x:radius y:angle if using polar coordinates\nfloat processFunction(int func, float x, float y, float t){\n\n    // x:radius y:angle, changed variable names for using on polar formulas\n    // not realy necessary but can make the code more clear! ;-)\n    float r = x;\n    float a = y;\n    \n    \n    \n    \n    switch(func){\n        case 0: return sin(x);\n        case 1: return sin(y);\n        case 2: return (sin(x)+sin(y))/2.;\n        case 3: return sin(x)*sin(y);\n        case 4: return sin(x)/sin(y);\n        case 5: return sin(y)/sin(x);\n        \n        \n        case  6: return sin(x)/2. + .5;\n        case  7: return sin(y)/2. + .5;\n        case  8: return (sin(x)+sin(y))/4. + .5;\n        case  9: return (sin(x)*sin(y))/2. + .5;\n        case 10: return abs(sin(x)/sin(y));\n        case 11: return abs(sin(y)/sin(x));\n        \n        case 12: return abs(sin(x));\n        case 13: return abs(sin(y));\n        case 14: return abs(sin(x)+sin(y))/2.;\n        case 15: return abs(sin(x)*sin(y));\n        case 16: return abs(sin(x)/sin(y));\n        case 17: return abs(sin(y)/sin(x));\n        \n        case 18: return 1./log(abs(sin(x)/sin(y)));\n        case 19: return 1./log(abs(sin(y)/sin(x)));\n        \n        \n        case 20: return x;\n        case 21: return y;\n        \n        case 22: return sin(t*pi*y)/2.+.5;\n        case 23: return sin(t*t*pi*y)/2.+.5;\n        case 24: return sin(t*t*pi*y/x)/2.+.5;\n        case 25: return sin(t*t*t*pi*y/x)/2.+.5;\n        \n        \n        \n       \n        case 26: return abs(sin(x*y)/sin(y/x))*(sin(t)/2. + .5);\n        case 27: return abs(sin(y/t+x)/sin(t/x))*(sin(t)/2. + .5);\n        case 28: return abs(sin(x-y)/sin(y-t))*(sin(t)/2. + .5);\n        \n        \n        case 29: return abs(sin(cos(y))/cos(x))*(sin(t+x+y)/2. + .5);\n        \n        \n    \n        case 30: return log(abs(x)) + log(abs(y));\n        case 31: return log(abs(x)) +         y  ;\n        case 32: return         x   + log(abs(y));\n        case 33: return         x   +         y  ;\n        case 34: return         x   +   sin(y)*y ;\n        case 35: return       x*x   +   log(y*y) ;\n        case 36: return  log(x*x)   +       y*y  ;\n        case 37: return     x*x*y   +       y/x  ;\n        case 38: return     x*x*x   +     y*y*y  ;\n        case 39: return   cos(x/y)*x*x*x   + sin(y)*y*y*y  ;\n        case 40: return x*x*x*x*x   + y*y*y*y*y  ;\n        case 41: return      1./x   +      1./y  ;\n        case 42: return  1./(x*x)   -  1./(y/x)  ;\n        case 43: return 1./(x*x*x)  + 1./(y*y*y) ;\n        case 44: return     sin(log(abs(x*y)))   + \n                            cos(log(abs(y/x)))   ;\n        case 45: return (y+x)/cos(x*y*x)  + sin(x-y)/(y*x*y) ;\n        case 46: return sin(abs(atan(y/x)))+y/x;\n        case 47: return sin(log(abs(atan(y/x))))+y/x;\n        \n        case 48: return sin(y/x)*cos(x/y);\n        case 49: return (y+x)/x*cos(x+y);\n        \n        // new funcs\n        case 50: return (y/sin(x))/(y*cos(x/y));\n        case 51: return (1./sin(x))/(y*cos(x/y));\n        case 52: return (y/sin(x))/(x/cos(y));\n        case 53: return (y/sin(atan(x/y)))/(x/cos(atan(y/x)));\n        case 54: return (y+x)*t;\n        case 55: return (y/x)/t;\n        \n        \n        case 56: return .5*sin((r+a)/t+.1);\n        \n        case 57: return (sin(x*y)+sin(x-y));\n        \n        \n        \n        //when none functions mathes\n        default:  return .5;\n    }\n\n}\n\n\n\n\nfloat processFunctionPatterns(int func, float x, float y, float t){\n\n    // x:radius y:angle, changed variable names for using on polar formulas\n    // not realy necessary but can make the code more clear! ;-)\n    float r = x;\n    float a = y;\n    \n    \n    switch(func){\n    \n        case  0: return int(abs(x*10.)+.5)%10==0 ||\n                        int(abs(y*10.)+.5)%10==0 ?1.:0.;\n        case  1: return int(abs(x*10.)+.5)%10==0 &&\n                        int(abs(y*10.)+.5)%10==0 ?1.:0.;        \n        \n        case  2: return int(abs(x*10.)+.5)%10==0?1.:0.;\n        case  3: return int(abs(y*10.)+.5)%10==0?1.:0.;        \n        \n        case  4: return x;\n        case  5: return y;\n        \n        case  6: return sin(x);\n        case  7: return sin(y);\n        case  8: return sin(x+y);\n        case  9: return sin(y/x);\n        case 10: return cos(x/y);\n        \n        //when none functions mathes\n        default:  return .0;\n    }\n\n}\n\n\nvec2 processCoords(int coord, float x, float y, float t){\n\n    switch(coord){\n    \n        case 0: return vec2(x,y);\n        \n        case 1: {\n           float r,a;\n           r = pow(x*x+y*y,.5);\n           a = atan2int(y,x);\n       \n           if(a<0.){\n               a=2.*pi+a;\n           }\n           return vec2(r,a);\n        }\n        \n        case 2: {\n           float r,a;\n           r = pow(x*x+y*y,.5);\n           a = atan2int(y,x);\n       \n           if(a<0.){\n               a+=pi;\n           }\n           return vec2(r,a);\n        }\n        \n        \n       case 3: {\n           float r=x,a=y;\n           \n           x = r*cos(a);\n           y = r*sin(a);\n           \n           return vec2(x,y);\n        }\n        \n         case 4: {\n           float r=x,a=y;\n           \n           x = r*sin(a/t);\n           y = r*sin(a*r);\n           \n           return vec2(x,y);\n        }\n        \n        case 5: {\n           float r=x,a=y;\n           \n           x = a*sin(r);\n           y = a*cos(r);\n           \n           \n           return vec2(x,y);\n        }\n        \n        case 6: {\n           float r=x,a=y;\n           \n           x = r*sin(a);\n           y = a*sin(r);\n           \n           \n           return vec2(x,y);\n        }\n        \n        case 7: {\n           float r=x,a=y;\n           \n           x = r*sin(a/r+t);\n           y = r*cos(a*r/t);\n           \n           \n           return vec2(x,y);\n        }\n        \n        case 8: {\n           float r=x,a=y;\n           \n           x = 1./(a*r)*sin(a/r+t)/cos(a*r/t);\n           y = 1./((r/t)*(cos(a*r/t)+cos(atan(sin(a/r+t))))/2.);\n           \n           \n           return vec2(x,y);\n        }\n        \n        case 9: {\n           float r=x,a=y;\n           \n           x = 1./((a*r)*sin(a/r+t)/cos(a*r/t));\n           y = 1./((r/t)*(cos(a*r/t)+cos(atan(sin(a/r+t))))/2.);\n           \n           \n           return vec2(y-x,x*y+a);\n        }\n        \n        case 10: {\n           \n           float r,a;\n           r = pow(x*x+y*y,.5);\n           a = atan2int(y,x);\n       \n           if(a<0.){\n               a=2.*pi+a;\n           }\n           \n           return vec2(a/t*100.,r/a*2.);\n           //return vec2(pow(cos(r),2.),pow(sin(a*t),2.));\n        }\n        \n        \n        \n        \n        //when none functions mathes\n        default:  return vec2(x,y);\n    }\n    \n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    bool esq = int(fragCoord.y)%2==0; \n    \n    \n    \n    float[5] colors;\n    \n    //\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5,0.);\n    uv *= vec2(iResolution.x/iResolution.y,1.);\n    uv += vec2(.5,0.);\n    //uv *= vec2(iResolution.x/iResolution.y,1.);\n    //uv += vec2(.5,0.);\n    \n    \n    // get parameters\n    float xi   = get(paramXi );\n    float xf   = get(paramXf );\n    float yi   = get(paramYi );\n    float yf   = get(paramYf );\n    float vel  = get(paramVel);\n    \n    float fFunc = get(paramFunc);\n    int func = int(fFunc);\n    \n    bool      cicle = get(paramCicle)>0.;\n    float  velCicle = get(paramVelCicle);\n    float timeCicle = get(paramTimeCicle);\n    float timeBase  = get(paramTimeBase);    \n    float cpow      = get(paramCpow);\n    float paralax   = get(paramParalax);\n    \n    float fPall = get(paramPall);\n    int pall = int(fPall);\n\n\n    float fCoord = get(paramCoord);\n    int coord = int(fCoord);\n    \n    float fReverse = get(paramReverse);\n    float fUrev = get(paramUrev);\n    bool reverse = fReverse>0.;\n    bool urev = fUrev>0.;\n    \n    bool params = get(paramParams)>0.;\n    \n    float x = (xi+(xf-xi)*uv.x);\n    float y = (yi+(yf-yi)*uv.y);\n    \n    \n    float zoom=pow(pow(xf-xi,2.)+pow(yf-yi,2.),.5);\n    \n    \n    //*(.1*pow((y*y+x*x)*1.,.5))/zoom;\n    ;\n    \n    float d, newx, newy;\n    float t = timeCicle;\n\n    \t\n        \n    if(cicle){\n      float dt = (1.*iTime - timeBase)*velCicle;\n      t += dt;        \n    }\n    \n    \n    float xparalax = x + paralax*(esq?-1.:+1.);\n    \n    float unif2 = processFunction(func,xparalax,y,t);\n    if(func>10){\n        unif2 *= processFunctionPatterns(func%11,y+xparalax,xparalax/y,t);\n    }\n   \n    \n    x += paralax*(esq?-1.:+1.)*unif2;    \n    \n    vec2 newCoords = processCoords(coord,x,y,t);\n    x = newCoords[0];\n    y = newCoords[1];\n    \n  \n    \n    \n\n    float unif1 = processFunction(func,x,y,t);\n    float unif = unif1;\n    if(func>10){\n  \n        unif = processFunction(func-11,x,y,t);\n        //unif /= 3.;\n        \n    }\n    \n    \n    \n    if(unif>=.0){\n        fragColor = \n             processPallete(pall,pow(unif,cpow),urev);\n    }\n    else{\n        fragColor = \n             processPallete(pall,pow(-unif,cpow),urev);\n        if(reverse){\n            fragColor = vec4(.999,.999,.999,1.)-fragColor;\n        }\n    }\n    \n    if(reverse){\n        fragColor = vec4(.999,.999,.999,1.)-fragColor;\n    }\n    \n    \n     if(params){\n          CURSOR_START = CURSOR = ivec2(4, int(iResolution.y)/2 - 14);\n          vec2 p = fragCoord * 0.5;\n          \n    // basic text\n    //      _H _e _l _l _o _ _W _o _r _l _d _EXCLAM _NEWLINE _NEWLINE\n    //      _T _h _e _ _q _u _i _c _k _ _b _r _o _w _n _ _f _o _x _ _j _u _m _\n    //      _s _\n    //      _o _v _e _r _ _t _h _e _ _l _a _z _y _ _d _o _g _PERIOD _NEWLINE\n    //      _NEWLINE\n    \n    // display all glyphs\n    //      _A _B _C _D _E _F _G _H _I _J _K _L _M _N _O _P _Q _R _S _T _U _V _W _X _Y _Z _NEWLINE\n    //      _a _b _c _d _e _f _g _h _i _j _k _l _m _n _o _p _q _r _s _t _u _v _w _x _y _z _NEWLINE\n    //      _BTICK _1 _2 _3 _4 _5 _6 _7 _8 _9 _0 _MINUS _EQ _LBRKET _RBRKET _BSLASH _SCOLON _TICK\n    //      _COMMA _PERIOD _FSLASH _NEWLINE\n    //      _TILDE _EXCLAM _AT _SHARP _DOLLAR _PRCENT _CARET _AMP _TIMES _LPAREN _RPAREN _UNDER _PLUS _LCURL _RCURL _PIPE\n     //     _COLON _QUOTE _LT _GT _QMARK _NEWLINE\n     //     _NEWLINE _NEWLINE\n    \n    // example of drawing dynamic content\n    \n    \n   \n    \n    \n          _x _i _EQ FNUM(xi) _COMMA _ \n          _x _f _EQ FNUM(xf) _COMMA _ \n          _y _i _EQ FNUM(yi) _COMMA _ \n          _y _f _EQ FNUM(yf) \n          _NEWLINE\n          \n          _f _u _n _c _EQ NUM(func) _NEWLINE\n          _c _p _o _w _EQ FNUM(cpow) _NEWLINE     \n          _p _a _l _l _EQ NUM(fPall) _NEWLINE\n          _c _o _o _r _d _EQ NUM(fCoord) _NEWLINE\n          \n          _p _a _r _a _l _a _x _EQ FNUM(paralax) _NEWLINE\n          \n          _r _e _v _e _r _s _e _EQ NUM(fReverse) _COMMA _ \n          _u _r _e _v _EQ NUM(fUrev) _NEWLINE\n          \n          \n          _i _T _i _m _e _EQ _ FNUM(iTime) _NEWLINE          \n          _t _EQ _ FNUM(t) _NEWLINE\n          _i _R _e _s _o _l _u _t _i _o _n _ _EQ _ NUM(iResolution.x) _ _x _ NUM(iResolution.y)\n    \n    // output to screen  \n          vec4 textColor = vec4(mix(vec3(.2,.2,.2),vec3(.1,.8,.1),TXT_COL),1.0);\n          \n          if(textColor[1]>.5){\n              fragColor=vec4(.999,.999,.999,1.)-fragColor;\n          }\n          \n    \n    }\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n// parameters (coordinates on texture buffer)\nconst ivec2 paramXi = ivec2(0,0);\nconst ivec2 paramXf = ivec2(0,1);\nconst ivec2 paramYi = ivec2(0,2);\nconst ivec2 paramYf = ivec2(0,3);\n\nconst ivec2 paramVel   = ivec2(1,0);\nconst ivec2 paramFunc  = ivec2(2,0);\n\n\nconst ivec2 paramCicle     = ivec2(3,0);\nconst ivec2 paramVelCicle  = ivec2(3,1);\nconst ivec2 paramTimeCicle = ivec2(3,2);\nconst ivec2 paramTimeBase  = ivec2(3,3);\nconst ivec2 paramParams    = ivec2(3,4);\n\nconst ivec2 paramCpow      = ivec2(4,0);\nconst ivec2 paramPall      = ivec2(4,1);\nconst ivec2 paramCoord     = ivec2(4,2);\nconst ivec2 paramReverse   = ivec2(4,3);\nconst ivec2 paramUrev      = ivec2(4,4);\n\nconst ivec2 paramParalax   = ivec2(4,5);\n\n\n// read and store values as x value on texture pixels\n#define get(var) texelFetch(iChannel0, var, 0).x\n#define set(var, value, fragColor, fragCoord) fragColor=(ivec2(fragCoord)==var?vec4(value,0.,0.,1.):fragColor)\n\n\n// reset to initial parameters\nconst int keyReset = 192; // the \"' key, below Esc\n\n// change image functions\nconst int keyPrev = 33; // PgUp\nconst int keyNext = 34; // PgDown\n\n\n// change position (arrow keys)\nconst int keyNorth = 38;\nconst int keySouth = 40;\nconst int keyEast  = 37;\nconst int keyWest  = 39;\nconst int keyOrig  = 12;\n\n\n// keycodes below are from numeric keyboard\n\n// change scale\nconst int keyZoomOut = 111; // /\nconst int keyZoomIn  = 106; // *\n\n// change scale velocity\nconst int keySlow = 109; // -\nconst int keyFast = 107; // +\n\n// cicle palete over time\nconst int keyCicle = 110; // .\n\n// change cicle velocity\nconst int keyCicleSlow = 36; // Home\nconst int keyCicleFast = 35; // End\n\n\n// change palete pow\nconst int keyPowDec  = 81; // q\nconst int keyPowInc  = 65; // a\nconst int keyPowZero = 90; // z\n\n\n// change palete type\nconst int keyPallInc  = 80; // p\nconst int keyPallDec  = 79; // o\nconst int keyPallZero = 73; // i\n\n// toglr polar/cartesian coordinates\n//const int keyPolar = 45; // insert, 0 on keypad\nconst int keyCoord = 45; // insert, 0 on keypad\n\n// toglr polar/cartesian coordinates\nconst int keyReverse = 82; // r\nconst int keyUrev    = 85; // u\n\n// zero time\nconst int keyZeroTime = 84; // t\n\n// show parameter values\nconst int keyParams = 86; // v\n\n\n\n#define keyToggle(code)  ( texelFetch(iChannel1,ivec2(code,2),0).x > 0.)\n#define keyClick(code)   ( texelFetch(iChannel1,ivec2(code,1),0).x > 0.)\n#define keyDown(code)    ( texelFetch(iChannel1,ivec2(code,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel1,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel1,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel1,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n\n\n/* CODE BANK \n\n/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n\n\n\n\n\nfloat pi = 3.141592;\n\nfloat uniform_to_widthNanometers (float u){\n    return 380. + 400.*(1.-u);\n}\n\nfloat uniform_to_freqTeraHertz (float u){\n    return (384. + 405.*u)*1.e3;\n}\n\nvec4 paletteReal( float w ) {\n    \n    float red, green, blue;\n\n    if (w >= 380. && w < 440.) {\n        red   = -(w - 440.) / (440. - 380.);\n        green = 0.;\n        blue  = 1.;\n    }\n    else \n    if (w >= 440. && w < 490.) {\n        red   = 0.;\n        green = (w - 440.) / (490. - 440.);\n        blue  = 1.;\n    }\n    else \n    if (w >= 490. && w < 510.) {\n        red   = 0.;\n        green = 1.;\n        blue  = -(w - 510.) / (510. - 490.);\n    }\n    else \n    if (w >= 510. && w < 580.) {\n        red   = (w - 510.) / (580. - 510.);\n        green = 1.;\n        blue  = 0.;\n    }\n    else \n    if (w >= 580. && w < 645.) {\n        red   = 1.;\n        green = -(w - 645.) / (645. - 580.);\n        blue  = 0.;\n    }\n    else \n    if (w >= 645. && w < 781.) {\n        red   = 1.;\n        green = 0.;\n        blue  = 0.;\n    }\n    else {\n        red   = 0.;\n        green = 0.;\n        blue  = 0.;\n    }\n\n\n    // Let the intensity fall off near the vision limits\n    float factor;\n    if (w >= 380. && w < 420.)\n        factor = .3 + .7*(w - 380.) / (420. - 380.);\n    else \n    if (w >= 420. && w < 701.)\n        factor = 1.;\n    else \n    if (w >= 701. && w < 781.)\n        factor = .3 + .7*(780. - w) / (780. - 700.);\n    else\n        factor = 0.;\n\n    float gamma = .8;\n    float R = (red   > 0. ? 255.*pow(red   * factor, gamma) : 0.);\n    float G = (green > 0. ? 255.*pow(green * factor, gamma) : 0.);\n    float B = (blue  > 0. ? 255.*pow(blue  * factor, gamma) : 0.); \n    \n    return vec4(R/255.,G/255.,B/255.,1.);\n}\n\nvec4 paletteRealUniform( float u ) {\n    return paletteReal(uniform_to_widthNanometers(u));\n}\n\nvec4 paletteAlien( float u ) {\n    \n    vec4 pal1 = paletteRealUniform(u);\n    vec4 pal2 = paletteRealUniform(1.-u);    \n    \n    return (pal1+pal2)/2.;\n    \n}\n\n\nvec4 paletteAssimetric( float u ) {\n    \n    vec4 pal1 = paletteAlien(u);\n    vec4 pal2 = paletteRealUniform(u);    \n    \n    return (pal1-pal2);\n    \n}\n\n\nvec4 paletteBars( float u ) {\n    \n    //vec4 pal1 = paletteAlien(u);\n    vec4 pal1 = paletteRealUniform(1.-u);    \n    vec4 pal2 = paletteRealUniform(u); \n    vec4 pal3 = paletteAlien(1.-u);\n    \n    return (pal1*pal2 + pal3)/4.;\n    \n}\n\nvec4 paletteGray( float u ) {\n   if(u>1.) u = 1.;\n   if(u<0.) u = 0.;\n   \n   return vec4(u,u,u,1.);\n}\n\n\nvec4 paletteGold( float u ) {\n   \n   if(u>1.) u = 1.;\n   if(u<0.) u = 0.;\n   \n   \n   \n   vec4 gold = vec4(10.*u/16.,8.*u/16.,2.*u/16.,1.);\n   vec4 red = 1.-(1.-vec4(15.*pow(u,55.)/16.,0.,0.,1.));\n   \n   \n   \n   \n   return gold+red;\n}\n\nvec4 paletteCrazy( float u ) {\n    \n    //vec4 pal1 = paletteAlien(u);\n    vec4 pal1 = paletteRealUniform(1.-u*u);    \n    vec4 pal2 = paletteRealUniform(u); \n    vec4 pal3 = paletteGray(pow(sin(10.*u),2.));\n    \n    return (pal3*(pal2 + pal1));\n    \n}\n\n\nvec4 processPallete(int pall, float u, bool urev){\n    \n    \n    if(urev){\n       u = 1.-u;\n    }\n    \n    \n    switch(pall){\n        case 0: return paletteRealUniform(u);\n        case 1: return paletteGray(u);\n        case 2: return paletteGold(u);\n        case 3: return paletteAlien(u);\n        case 4: return paletteAssimetric(u);\n        case 5: return paletteBars(u);\n        case 6: return paletteCrazy(u);\n    }\n}\n\n\n// xy are generic 2d coordinates, not necessarily cartesian\n// maybe x:radius y:angle if using polar coordinates\nfloat processFunction(int func, float x, float y, float t){\n\n    // x:radius y:angle, changed variable names for using on polar formulas\n    // not realy necessary but can make the code more clear! ;-)\n    float r = x;\n    float a = y;\n    \n    \n    \n    \n    switch(func){\n        case 0: return sin(x);\n        case 1: return sin(y);\n        case 2: return (sin(x)+sin(y))/2.;\n        case 3: return sin(x)*sin(y);\n        case 4: return sin(x)/sin(y);\n        case 5: return sin(y)/sin(x);\n        \n        \n        case  6: return sin(x)/2. + .5;\n        case  7: return sin(y)/2. + .5;\n        case  8: return (sin(x)+sin(y))/4. + .5;\n        case  9: return (sin(x)*sin(y))/2. + .5;\n        case 10: return abs(sin(x)/sin(y));\n        case 11: return abs(sin(y)/sin(x));\n        \n        case 12: return abs(sin(x));\n        case 13: return abs(sin(y));\n        case 14: return abs(sin(x)+sin(y))/2.;\n        case 15: return abs(sin(x)*sin(y));\n        case 16: return abs(sin(x)/sin(y));\n        case 17: return abs(sin(y)/sin(x));\n        \n        case 18: return 1./log(abs(sin(x)/sin(y)));\n        case 19: return 1./log(abs(sin(y)/sin(x)));\n        \n        \n        case 20: return x;\n        case 21: return y;\n        \n        case 22: return sin(t*pi*y)/2.+.5;\n        case 23: return sin(t*t*pi*y)/2.+.5;\n        case 24: return sin(t*t*pi*y/x)/2.+.5;\n        case 25: return sin(t*t*t*pi*y/x)/2.+.5;\n        \n        \n        \n       \n        case 26: return abs(sin(x*y)/sin(y/x))*(sin(t)/2. + .5);\n        case 27: return abs(sin(y/t+x)/sin(t/x))*(sin(t)/2. + .5);\n        case 28: return abs(sin(x-y)/sin(y-t))*(sin(t)/2. + .5);\n        \n        \n        case 29: return abs(sin(cos(y))/cos(x))*(sin(t+x+y)/2. + .5);\n        \n        \n    \n        case 30: return log(abs(x)) + log(abs(y));\n        case 31: return log(abs(x)) +         y  ;\n        case 32: return         x   + log(abs(y));\n        case 33: return         x   +         y  ;\n        case 34: return         x   +   sin(y)*y ;\n        case 35: return       x*x   +   log(y*y) ;\n        case 36: return  log(x*x)   +       y*y  ;\n        case 37: return     x*x*y   +       y/x  ;\n        case 38: return     x*x*x   +     y*y*y  ;\n        case 39: return   cos(x/y)*x*x*x   + sin(y)*y*y*y  ;\n        case 40: return x*x*x*x*x   + y*y*y*y*y  ;\n        case 41: return      1./x   +      1./y  ;\n        case 42: return  1./(x*x)   -  1./(y/x)  ;\n        case 43: return 1./(x*x*x)  + 1./(y*y*y) ;\n        case 44: return     sin(log(abs(x*y)))   + \n                            cos(log(abs(y/x)))   ;\n        case 45: return (y+x)/cos(x*y*x)  + sin(x-y)/(y*x*y) ;\n        case 46: return sin(abs(atan(y/x)))+y/x;\n        case 47: return sin(log(abs(atan(y/x))))+y/x;\n        \n        case 48: return sin(y/x)*cos(x/y);\n        case 49: return (y+x)/x*cos(x+y);\n        \n        // new funcs\n        case 50: return (y/sin(x))/(y*cos(x/y));\n        case 51: return (1./sin(x))/(y*cos(x/y));\n        case 52: return (y/sin(x))/(x/cos(y));\n        case 53: return (y/sin(atan(x/y)))/(x/cos(atan(y/x)));\n        case 54: return (y+x)*t;\n        case 55: return (y/x)/t;\n        \n        \n        case 56: return .5*sin((r+a)/t+.1);\n        \n        case 57: return (sin(x*y)+sin(x-y));\n        \n        \n        \n        //when none functions mathes\n        default:  return .5;\n    }\n\n}\n\nfloat atan2_error(float y, float x){\n\n    if(x==0.) return (pi/2.)*(y>=0.?1.:-1.);\n    \n    float atanYX = atan(y,x);\n    \n    if(x>0.) return atanYX;\n    \n    return atanYX + pi*(y<0.?1.:-1.); \n\n}\n\n\nfloat atan2int( float y, float x )\n{\n    \n    if ( x == 0.0f )\n\t{\n\t\tif ( y > 0.0f ) return pi/2.;\n\t\tif ( y == 0.0f ) return 0.;\n\t\treturn -pi/2.;\n\t}\n\t\n    float z = y/x;\n    float atg = atan(abs(z));\n\t\n    \n\tif (x>0.)\n\t{\n\t\treturn atg;\n\t}\n\telse\n\t{\n\t\tif ( y < 0. ) return atg - pi;\n        return atg + pi;\n\t}\n    \n}\n\n\n//float atan2( float y, float x ){\n//    if(x*y<0.) {\n//        return atan2int(-y,-x);\n//    }\n//    return atan2int(y,x);\n//    //\n//}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    \n    float[5] colors;\n    \n    //\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5,0.);\n    uv *= vec2(iResolution.x/iResolution.y,1.);\n    uv += vec2(.5,0.);\n    //uv *= vec2(iResolution.x/iResolution.y,1.);\n    //uv += vec2(.5,0.);\n    \n    \n    // get parameters\n    float xi   = get(paramXi );\n    float xf   = get(paramXf );\n    float yi   = get(paramYi );\n    float yf   = get(paramYf );\n    float vel  = get(paramVel);\n    \n    \n    int func = int(get(paramFunc));\n    \n    bool      cicle = get(paramCicle)>0.;\n    float  velCicle = get(paramVelCicle);\n    float timeCicle = get(paramTimeCicle);\n    float timeBase  = get(paramTimeBase);    \n    float cpow      = get(paramCpow);\n    \n    int pall = int(get(paramPall));\n    \n    bool polar = get(paramPolar)>0.;\n    bool reverse = get(paramReverse)>0.;\n    bool urev = get(paramUrev)>0.;\n    \n    float x = (xi+(xf-xi)*uv.x);\n    float y = (yi+(yf-yi)*uv.y);\n    \n    float d, newx, newy;\n    float t = timeCicle;\n\n    \t\n        \n    if(cicle){\n      float dt = (1.*iTime - timeBase)*velCicle;\n      t += dt;        \n    }\n    \n    \n\n    float r,a;\n   \n    if(polar){\n        // coordenadas polares\n        //float r = pow(x*x+y*y,.5);\n        //float a = abs(atan(x,y));\n        \n        \n        r = pow(x*x+y*y,.5);\n        a = atan2int(y,x)/pi;\n        \n        //if(x<0.) a *= .5;\n        //else a = 1. - a*.5;\n        \n        \n        x=r*t;\n        y=a*(r/t+a);\n    }\n    \n    else{\n       r = x*t;\n       a = y;\n    }\n    \n    \n    \n   \n\n     \n    //d = .2;\n    //for(int i=0;i<5;i++){\n\n        \n            \n        \n        else\n        if(func>26) {\n            d = processFunction(func-26,r/t,a*t,t);\n        }        \n        else\n        if(func<0) {\n            d = processFunction(-func+1,r/a,r*(log(t)),t);\n        }\n        else {\n            //d += processFunction(func,x,y,t)/5.;\n            //d = processFunction(func,(cos(r+t)+1.)/1.,a*float(i)*1.5+.1,t);\n            //d = processFunction(func,(cos(r+t)+1.)/2.,a*float(i)*1.5+.1,t);\n            //d += processFunction(func,(cos(r+t)+1.)/2.,a*float(i)*1.5+.1,t);\n        \n        \n        \n        //float omegax = cos(2.*pi+sin((d+t)*y));\n        //float omegay = sin(2.*pi+cos((d-t)*x));\n\n        \n        //float omegax = y/d + x/sqrt(n) + thetax + 2.*t;\n        //float omegay = x/d + y/sqrt(n) + thetay + .5*t;\n\n        //newx = omegax;\n        //newy = omegay;\n\n        //x = newx;\n        //y = newy;\n        \n        \n        //colors[i]=pow(d,cpow);\n        //colors[i]=pow((sin(d)+1.)/2.,cpow)*255.;//abs(pow(((x/t-y)/2.+1.)/2.,cpow))*255.;\n        \n    //    float color = \n    //        i==4?.5*(cos(d/10.))+.5:            \n    //        i==3?.5*(sin(abs(d)/abs(r/a)))+.5:\n    //        i==2?.5*(sin(d))+.5:\n    //        i==1?.5*(cos(1./d))+.5:\n    //        i==0?.5*(cos((a/r)+r*d))+.5:\n    //        .1*abs(a+d);\n            \n    //    colors[i] = pow(color,cpow);\n    //}\n\t\t\t\n\n    // Output to screen\n    //vec3 col = vec3();\n    \n    \n    \n    //fragColor = vec4(colors[2]/256.,colors[4]/256.,colors[3]/256.,1.0);\n    //float w1 = uniform_to_widthNanometers(colors[1]/256.);\n    //float w2 = uniform_to_widthNanometers(colors[2]/256.);\n    //float w3 = uniform_to_widthNanometers(colors[3]/256.);\n    \n    \n    //float w0 = colors[0];\n    //float w1 = colors[1];\n    //float w2 = colors[2];\n    //float w3 = colors[3];\n    //float w4 = colors[4];\n    \n    //fragColor = (\n    //    processPallete(pall,w1,urev)+\n    //    processPallete(pall,w2,urev)+\n    //    processPallete(pall,w3,urev))/3.;//*((colors[4]+colors[0])/512.);\n    \n    //fragColor /= processPallete(pall,w4, urev); // +colors[0];\n    //fragColor *= processPallete(pall,w0, urev);\n    //\n    //d = processFunction(func,x,y,t);\n    //fragColor = palleteReal(uniform_to_widthNanometers(pow(f,cpow)));\n    //fragColor = processPallete(pall,pow(f,cpow));\n    \n    \n    float unif = .5;\n    fragColor = processPallete(pall,unif,urev);\n    \n    if(reverse){\n        fragColor = vec4(.999,.999,.999,1.)-fragColor;\n    }\n    \n}\n*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n/* MANUAL\n\nKEYS\n    ' : reset\n  (numpad numlock OFF):..\n    ARROWS   : move\n    NUMPAD5  : center 0,0\n    * /      : zoom in/out  \n    + -      : inc/dec zoom vel\n    .        : pause/play time\n    Home End : inc/dec cicle vel\n    PgUp PgDown: Cicle 31 diff f(x,y)\n    q a: change palete gamute\n    \n*/\n\nconst float lastFunc  = 67.;\nconst float lastPall  = 10.;\nconst float lastCoord = 10.;\n\n\n// initial parameter values\nfloat iniXi       =  -1. ;\nfloat iniXf       =   1. ;\nfloat iniYi       =  -1. ;\nfloat iniYf       =   1. ;\nfloat iniVel      =   .01 ;\nfloat iniFunc     =    0. ;\nfloat iniCoord    =    0. ; \n\nfloat iniCicle     =  1.  ; // -1.: FALSE 1.:TRUE\nfloat iniVelCicle  =  1.  ;\nfloat iniTimeCicle =  0.  ;\nfloat iniTimeBase  =  0.  ;\nfloat iniParams    =  1.  ; // -1.: FALSE 1.:TRUE\n\n\nfloat iniCpow = 1. ; \nfloat iniPall = 0. ; \n\nfloat iniParalax = .07;\n\n\nfloat iniReverse = -1.; // -1.: normal colors 1.:reversed colors\nfloat iniUrev    = -1.; // -1.: uniform 0-1 colors: 1. reversed 1-0 uniform scale\n\n\n\nvoid initParameters(inout vec4 fragColor, in vec2 fragCoord){\n    set(paramXi,       iniXi,       fragColor, fragCoord);   \n    set(paramXf,       iniXf,       fragColor, fragCoord);   \n    set(paramYi,       iniYi,       fragColor, fragCoord);   \n    set(paramYf,       iniYf,       fragColor, fragCoord);   \n    set(paramVel,      iniVel,      fragColor, fragCoord);   \n    set(paramFunc,     iniFunc,     fragColor, fragCoord);   \n    \n    set(paramCicle,     iniCicle,     fragColor, fragCoord);   \n    set(paramVelCicle,  iniVelCicle,  fragColor, fragCoord);   \n    set(paramTimeCicle, iniTimeCicle, fragColor, fragCoord);   \n    set(paramTimeBase,  iniTimeBase,  fragColor, fragCoord); \n    set(paramParams,    iniParams,    fragColor, fragCoord); \n    \n    set(paramParalax,    iniParalax,    fragColor, fragCoord); \n\n    \n    set(paramCpow,  iniCpow,  fragColor, fragCoord); \n    set(paramPall,  iniPall,  fragColor, fragCoord); \n    set(paramCoord, iniCoord, fragColor, fragCoord); \n    \n    set(paramReverse, iniReverse, fragColor, fragCoord); \n    set(paramUrev,    iniUrev,    fragColor, fragCoord); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // initialize values\n    if (iFrame==0) {\n        initParameters(fragColor, fragCoord);    \n    }\n\n    else { \n    \n        // get current values\n        float xi       = get(paramXi);   \n        float xf       = get(paramXf);   \n        float yi       = get(paramYi);   \n        float yf       = get(paramYf);   \n        float vel      = get(paramVel);   \n        float func     = get(paramFunc); \n        \n        float cicle     = get(paramCicle);  \n        float velCicle  = get(paramVelCicle);  \n        float timeCicle = get(paramTimeCicle);  \n        \n        float timeBase  = get(paramTimeBase);\n        float params    = get(paramParams);\n        \n        float paralax   = get(paramParalax);\n        \n        float cpow      = get(paramCpow);\n        float pall      = get(paramPall);\n        float coord     = get(paramCoord);\n        float reverse   = get(paramReverse);\n        float urev      = get(paramUrev);\n        \n        // current visible window size\n        float dx = xf-xi;\n        float dy = yf-yi;\n        \n        \n       \n        \n        // move image\n        if(keyDown(keyNorth)){\n            yi+=dy/100.;\n            yf+=dy/100.;\n        }\n        if(keyDown(keySouth)){\n            yi-=dy/100.;\n            yf-=dy/100.;\n        }\n        if(keyDown(keyEast)){\n            xi-=dx/100.;\n            xf-=dx/100.;\n        }\n        if(keyDown(keyWest)){\n            xi+=dx/100.;\n            xf+=dx/100.;\n        }\n        \n        // return to 0,0 (dont change scale)\n        if(keyDown(keyOrig)){\n            xi=-dx/2.;\n            xf=+dx/2.;\n            yi=-dy/2.;\n            yf=+dy/2.;\n        }\n        \n        // zoom controls\n        if(keyDown(keyZoomOut)){\n            xi-=dx*vel;\n            xf+=dx*vel;\n            if(!shift){\n                yi-=dy*vel;\n                yf+=dy*vel;\n            }\n        }        \n        if(keyDown(keyZoomIn)){\n            xi+=dx*vel;\n            xf-=dx*vel;\n            if(!shift){\n                yi+=dy*vel;\n                yf-=dy*vel;\n            }\n        }\n        \n        \n        \n        \n         // change paralax\n        bool changedParalax = false; \n        if(keyDown(keySlow)){\n            if(shift){\n                paralax/=1.01;\n                if(paralax<=.0001){\n                    paralax = .0001;\n                }\n                changedParalax = true;\n            }\n        }\n        \n        if(keyDown(keyFast)){\n            if(shift){\n                paralax*=1.01;\n                if(paralax>=10000.){\n                    paralax = 10000.;\n                }\n                changedParalax = true;\n            }\n        }\n        \n        if(!changedParalax){\n\t\t    // zoom velocity change\n\t\t    if(keyClick(keySlow)){\n\t\t        if(!shift){\n\t\t            vel/=2.;\n\t\t        }\t\t        \n\t\t    }        \n\t\t    if(keyClick(keyFast)){\n\t\t        if(!shift){\n\t\t            vel*=2.;\n\t\t        }\t\t        \n\t\t    }\n        }\n        \n       \n        // restart to initial status\n        if(keyClick(keyReset)){            \n            xi    = iniXi;\n            xf    = iniXf;\n            yi    = iniYi;\n            yf    = iniYf;\n            vel   = iniVel;\n            func  = iniFunc;\n            \n            cicle     = iniCicle;\n            velCicle  = iniVelCicle;  \n            timeCicle = 0.; \n            timeBase  = 1.*iTime;\n            paralax   = iniParalax;\n        }\n        \n        \n        // change f(x,y) function\n        if(keyClick(keyPrev)){\n            func = func-1.;\n            if(func<0.) func = lastFunc;\n        }        \n        if(keyClick(keyNext)){\n            func = func+1.;\n            if(func>lastFunc) func = 0.;\n        }\n        \n        // cicle fase and colors by iTime\n        if(keyClick(keyCicle)){\n            // its a bool, but I must store as float... \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle < 0.){\n                // estava parado                \n                timeBase = fTime;\n            }\n            else{\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = timeCicle;        \n            }\n                        \n            cicle*=-1.;\n        }\n        \n        // cicle velocity change\n        if(keyDown(keyCicleSlow)){\n        \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n        \n            velCicle/=1.01;            \n        }        \n        if(keyDown(keyCicleFast)){\n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n            \n            velCicle*=1.01;            \n        }\n        \n        \n        // change palete power\n        if(keyDown(keyPowDec)){\n            cpow /=1.01;\n        }        \n        if(keyDown(keyPowInc)){\n            cpow *=1.01;\n        }\n        if(keyClick(keyPowZero)){\n            cpow = iniCpow;\n        }      \n        \n        // change palete \n        if(keyClick(keyPallDec)){\n            pall = pall-1.;\n            if(pall<0.) pall = lastPall;\n        }        \n        if(keyClick(keyPallInc)){\n            pall = pall+1.;\n            if(pall>lastPall) pall = 0.;\n        }\n        if(keyClick(keyPallZero)){\n            pall = iniPall;\n        }  \n        \n        // change coords systems\n        if(keyClick(keyCoord)){\n            coord = coord+1.;\n            if(coord>lastCoord) coord = 0.;\n        }\n        \n        // change color normal/reversed\n        if(keyClick(keyReverse)){\n            // its a bool, but I must store as float... \n            reverse*=-1.;\n        }\n        \n        \n        // change pallete mapping 0-1  1-0\n        if(keyClick(keyUrev)){\n            // its a bool, but I must store as float... \n            urev*=-1.;\n        }\n        \n        // zero time\n        if(keyClick(keyZeroTime)){\n            \n           timeCicle = 0.; \n           timeBase  = 1.*iTime;    \n            \n        }\n        \n        \n         // change showParams\n        if(keyClick(keyParams)){\n            // its a bool, but I must store as float... \n            params*=-1.;\n        }\n        \n        \n        \n        // update parameters\n        set(paramXi,       xi,       fragColor, fragCoord);   \n        set(paramXf,       xf,       fragColor, fragCoord);   \n        set(paramYi,       yi,       fragColor, fragCoord);   \n        set(paramYf,       yf,       fragColor, fragCoord);   \n        set(paramVel,      vel,      fragColor, fragCoord);   \n        set(paramFunc,     func,     fragColor, fragCoord);   \n        \n        set(paramCicle,     cicle,     fragColor, fragCoord); \n        set(paramVelCicle,  velCicle,  fragColor, fragCoord); \n        set(paramTimeCicle, timeCicle, fragColor, fragCoord); \n        set(paramTimeBase,  timeBase, fragColor, fragCoord); \n        set(paramParams,    params,    fragColor, fragCoord); \n        \n        set(paramParalax,   paralax,    fragColor, fragCoord); \n     \n        set(paramCpow,  cpow,  fragColor, fragCoord); \n        set(paramPall,  pall,  fragColor, fragCoord); \n        set(paramCoord, coord, fragColor, fragCoord); \n        \n        set(paramReverse, reverse, fragColor, fragCoord); \n        set(paramUrev,    urev,    fragColor, fragCoord); \n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}