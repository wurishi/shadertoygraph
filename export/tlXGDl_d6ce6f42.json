{"ver":"0.1","info":{"id":"tlXGDl","date":"1558024818","viewed":185,"name":"Corfield Imitation 1","username":"nr4","description":"Inspiration:\nhttps://www.instagram.com/p/Bv2EPiADZnX/\nSlow, I know. - How could I speed up the quad tree?","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["geometry","quadtree","constructive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Corfield Imitation 1\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float fsaa = 25.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.;\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n     \t\tcol += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*3./max(bound, 1.)/iResolution.xy).xyz;\n        }\n    col /= fsaa;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Corfield Imitation 1\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Global constants\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.0, 0.0, -1.0);\nfloat a = 1.0;\n\n// Hash function\nvoid rand(in vec2 x, out float num)\n{\n    x += 400.;\n    num = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Extrusion\nvoid zextrude(in float z, in float d2d, in float h, out float d)\n{\n    vec2 w = vec2(-d2d, abs(z)-0.5*h);\n    d = length(max(w,0.0));\n}\n\n// Stroke\nvoid stroke(in float d0, in float s, out float d)\n{\n    d = abs(d0)-s;\n}\n\n// 2D box\nvoid dbox(in vec2 p, in vec2 b, out float dst)\n{\n  \tvec2 d = abs(p) - b;\n  \tdst = length(max(d,0.0)) + min(max(d.x,d.y),0.0); \n}\n\n// 3D box\nvoid dbox3(in vec3 x, in vec3 b, out float d)\n{\n  \tvec3 da = abs(x) - b;\n  \td = length(max(da,0.0)) + min(max(da.x,max(da.y,da.z)),0.0);\n}\n\n// iq's smooth minimum\nvoid smoothmin(in float a, in float b, in float k, out float dst)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    dst = min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// Random Quadtree\nvoid dquadtree(in vec2 x, in float threshold, in float depth, out float d, out float faco)\n{\n    d = 1.;\n    vec2 y = x, \n        yi;\n    float size = .5,\n\t    fac = 1.;\n    faco = 1.;\n    for(float i=0.; i<depth; i+=1.)\n    {\n        vec2 y0 = y;\n        y = mod(y, size)-.5*size;\n        yi = y0-y;\n\t\tfloat r;\n        rand(yi+fac,r);\n        fac *= r*step(r,threshold);\n        faco *= r;\n        if(fac != 0.)\n        {\n            float dd;\n            dbox(y,.5*size*c.xx,dd);\n            //dd = mix(dd,length(y)-.5*size,step(r,threshold));\n            dd = abs(dd);\n            smoothmin(d,dd,.01,d);\n        }\n        \n        size *= .5;\n    }\n    faco += fac*fac;\n}\n\n// Scene\nfloat mat;\nvoid scene(in vec3 x, out vec2 d)\n{\n    d = c.xx;\n    float dbound;\n    dbox3(x,vec3(.33*c.xx, .2),dbound);\n    float da, fac;\n    dquadtree(x.xy-.1*iTime, .71, 5., da, fac);\n    \n    float p = pi/4.;\n    vec2 cs = vec2(cos(p),sin(p));\n    mat2 m = mat2(cs.x,cs.y,-cs.y,cs.x);\n    vec2 y = m*x.xy;\n    float da9, fac9;\n    dquadtree(y-12.-.1*iTime, .41, 4., da9, fac9);\n    smoothmin(da,da9,.01,da);\n    \n    float r;\n    rand(202.*fac*fac9*c.xx+3., r);\n    mat = r;\n    zextrude(x.z,da,r*.3,da9);\n    d.x = min(d.x,da9);\n    \n    stroke(da, .015, da);\n    float db;\n    stroke(da, .003, db);\n   \n    stroke(d.x,.003,d.x);\n    dbox3(x,vec3(.33*c.xx, .02),da);\n    d.x = min(d.x, da);\n    d.x = min(d.x, db);\n    \n    d.x = max(d.x, dbound);\n}\n\n// Normal\nconst float dx = 5.e-4;\nvoid normal(in vec3 x, out vec3 n)\n{\n    vec2 s, na;\n    scene(x,s);\n    scene(x+dx*c.xyy, na);\n    n.x = na.x;\n    scene(x+dx*c.yxy, na);\n    n.y = na.x;\n    scene(x+dx*c.yyx, na);\n    n.z = na.x;\n    n = normalize(n-s.x);\n}\n\n// Texture\nvoid colorize(in vec2 x, out vec3 col)\n{    \n    float phi = .1*iTime;\n    \n    vec3 white = vec3(0.69,0.69,0.69),\n        gray = vec3(0.55,0.55,0.55);\n    float size = .1;\n    \n    \n    vec2 y = mod(x,size)-.5*size;\n    y = abs(y)-.001;\n    \n    float d = min(y.x,y.y);\n\n    \n    col = mix(white, gray, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n}\n\nvoid analytical_box(in vec3 o, in vec3 dir, in vec3 size, out float d)\n{\n    vec3 tlo = min((size-o)/dir,(-size-o)/dir); // Select 3 visible planes\n    vec2 abxlo = abs(o.yz + tlo.x*dir.yz),\n        abylo = abs(o.xz + tlo.y*dir.xz),\n        abzlo = abs(o.xy + tlo.z*dir.xy);\n    vec4 dn = 100.*c.xyyy;\n    \n    dn = mix(dn, vec4(tlo.x,c.xyy), float(all(lessThan(abxlo,size.yz)))*step(tlo.x,dn.x));\n    dn = mix(dn, vec4(tlo.y,c.yxy), float(all(lessThan(abylo,size.xz)))*step(tlo.y,dn.x));\n    dn = mix(dn, vec4(tlo.z,c.yyx), float(all(lessThan(abzlo,size.xy)))*step(tlo.z,dn.x));\n\n    d = dn.r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Set up coordinates\n    a = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n    vec3 col = c.yyy;\n    \n    // Camera setup\n    float pp = .3*iTime;\n    vec3 o = c.yyx+.2*c.yzy,\n        t = c.yyy,\n        dir = normalize(t-o),\n        r = normalize(c.xyy),\n        u = normalize(cross(r,dir)),\n        n,\n        x,\n        l;\n    t += uv.x*r + uv.y*u;\n    dir = normalize(t-o);\n    vec2 s;\n    float d = 0.;// -(o.z-.12)/dir.z;\n    int N = 250,\n        i;\n    \n    // Graph\n    analytical_box(o,dir,vec3(.33*c.xx,.2),d);\n    x = o + d * dir;\n    \n    // Actual Scene\n    if(x.z>0.)\n    {\n\n        // Raymarching\n        for(i=0; i<N; ++i)\n        {\n            x = o + d * dir;\n            scene(x,s);\n            if(s.x < 1.e-4) break;\n            d += min(.0008,s.x);\n        }\n\n        // Illumination\n        l = normalize(x+c.yxx);\n        if(i<N)\n        {\n            normal(x,n);\n            col = mix((.5+.5*mat)*c.xxx,(1.+.8*mat)*vec3(.7,.1,.26),step(x.z,.08));\n            col = mix(col,c.yyy,step(.19,x.z));\n        }\n        else\n        {\n            d = -o.z/dir.z;\n            x = o + d * dir;\n            n = c.yyx;\n            l = vec3(x.xy, .8);\n            colorize(x.xy, col);\n        }\n    }\n    else // Floor with grid\n    {\n        d = -o.z/dir.z;\n        x = o + d * dir;\n        n = c.yyx;\n        l = vec3(x.xy, .8);\n        colorize(x.xy, col);\n    }\n    \n    // Colorize\n    col = .2*col\n        + .9*col*abs(dot(l,n))\n        +.4*col*abs(pow(dot(reflect(-l,n),dir),3.));\n    \n    fragColor = clamp(vec4(col,1.0),0.,1.);\n}","name":"Buf A","description":"","type":"buffer"}]}