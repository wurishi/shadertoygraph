{"ver":"0.1","info":{"id":"fdVGDy","date":"1632140784","viewed":765,"name":"20210920","username":"0b5vr","description":"Inspired by https://www.shadertoy.com/view/7sKGRy\n\nhaha\n","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","cubes","pathtracer"],"hasliked":0,"parentid":"7scGWn","parentname":"20210821"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Present\n\n#define saturate(i) clamp(i,0.,1.)\n\nconst float WEIGHT_1 = 1.0 / 16.0;\nconst float WEIGHT_2 = 2.0 / 16.0;\nconst float WEIGHT_4 = 4.0 / 16.0;\n\nbool isValidUV( vec2 uv ) {\n  return all( lessThan( abs( uv - 0.5 ), vec2( 0.5 ) ) );\n}\n\nvec4 fetch( sampler2D sampler, vec2 uv, float level ) {\n  if ( !isValidUV( uv ) ) {\n    return vec4( 0.0 );\n  }\n\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25, 0.125...\n  vec2 uvt = level < 0.0 ? uv : ( ( 1.0 - p ) + 0.5 * uv * p );\n\n  vec4 tex = texture( sampler, uvt );\n  return tex;\n}\n\nvec4 tap9( sampler2D sampler, vec2 uv, float level ) {\n  vec2 deltaTexel = pow( 2.0, 1.0 + level ) / iResolution.xy;\n\n  // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n  vec4 tex = WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0, -1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  0.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  0.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  0.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  1.0 ), level );\n  return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec2 p = uv * 2.0 - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  \n  #ifdef LETTERBOX\n    if ( abs( p.x ) > LETTERBOX ) {\n      fragColor = vec4( 0.0 );\n      return;\n    }\n  #endif\n\n  vec4 tex = texture( iChannel0, uv );\n\n  vec3 col = saturate( tex.rgb / tex.a );\n  col += tap9( iChannel1, uv, 0.0 ).rgb;\n  col = pow( col, vec3( 0.4545 ) );\n  col *= 1.0 - 0.2 * length( p );\n\n  fragColor = vec4( col, 1 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Scene\n\n#define saturate(i) clamp(i,0.,1.)\n#define fs(i) (fract(sin((i)*114.514)*1919.810))\n#define reso iResolution\n\nconst float PI = acos( -1. );\nconst float TAU = PI * 2.0;\nconst float EPSILON = 1E-3;\nconst float FAR = 30.0;\nconst float INV_4_PI = 0.25 / PI;\nconst float PDF_UNIFORM_SPHERE = INV_4_PI;\n\nvec4 seed;\n\nfloat minV3( vec3 v ) {\n  return min( v.x, min( v.y, v.z ) );\n}\n\nfloat maxV3( vec3 v ) {\n  return max( v.x, max( v.y, v.z ) );\n}\n\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), sin( t ), -sin( t ), cos( t ) );\n}\n\n// Ref: https://cs.uwaterloo.ca/~thachisu/tdf2015.pdf\nfloat random() {\n  const vec4 q = vec4( 1225, 1585, 2457, 2098 );\n  const vec4 r = vec4( 1112, 367, 92, 265 );\n  const vec4 a = vec4( 3423, 2646, 1707, 1999 );\n  const vec4 m = vec4( 4194287, 4194277, 4194191, 4194167 );\n    vec4 beta = floor( seed / q );\n    vec4 p = a * ( seed - beta * q ) - beta * r;\n    beta = ( sign( -p ) + vec4( 1 ) ) * vec4( 0.5 ) * m;\n    seed = ( p + beta );\n    return fract( dot( seed / m, vec4( 1, -1, 1, -1 ) ) );\n}\n\nvec2 random2() {\n  return vec2( random(), random() );\n}\n\nvec3 randomSphere() {\n  float phi = TAU * random();\n  float theta = acos( 1.0 - 2.0 * random() );\n  return vec3(\n    cos( phi ) * sin( theta ),\n    sin( phi ) * sin( theta ),\n    cos( theta )\n  );\n}\n\nvec3 randomHemisphere( vec3 N ) {\n  vec3 d = randomSphere();\n  return dot( N, d ) < 0.0 ? -d : d;\n}\n\nmat3 orthBas( vec3 d ) {\n  vec3 z = normalize( d );\n  vec3 x = normalize( cross(\n    abs( z.y ) < 0.999 ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 ),\n    z\n  ) );\n  return mat3( x, cross( z, x ), z );\n}\n\nvec3 cyclicNoise( vec3 p, vec3 b, float pump ) {\n  mat3 bas = orthBas( b );\n  vec4 sum = vec4( 0.0 );\n\n  for ( int i = 0; i < 6; i ++ ) {\n    p *= bas * 2.0;\n    p += sin( p.yzx );\n    sum = pump * sum + vec4( cross( sin( p.zxy ), cos( p ) ), 1.0 );\n  }\n\n  return sum.xyz / sum.w;\n}\n\nvec3 F_Schlick( vec3 f0, float VdotH ) {\n  float v = 1.0 - VdotH;\n  return mix( f0, vec3( 1.0 ), ( v * v ) * ( v * v ) * v );\n}\n\nfloat G_Smith( float roughness, float NdotV, float NdotL ) {\n  float k = roughness;\n  k = k * k;\n  k /= 2.0;\n\n  float G1V = NdotV / ( NdotV * ( 1.0 - k ) + k );\n  float G1L = NdotL / ( NdotL * ( 1.0 - k ) + k );\n\n  return G1V * G1L;\n}\n\nvec3 importanceSampleLambert( vec3 N ) {\n  float phi = TAU * random();\n  float cosTheta = saturate( sqrt( random() ) );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\nvec3 importanceSampleGGX( float roughness, vec3 N ) {\n  float phi = TAU * random();\n  float cosTheta = random();\n  cosTheta = sqrt( ( 1.0 - cosTheta ) / ( 1.0 + ( pow( roughness, 4.0 ) - 1.0 ) * cosTheta ) );\n  cosTheta = saturate( cosTheta );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\nstruct Material {\n  vec3 albedo;\n  float roughness;\n  float metallic;\n  vec3 emissive;\n};\n\nstruct MarchResult {\n  float d;\n  Material mtl;\n};\n\nstruct RectSubdivResult {\n  float volume;\n  vec3 center;\n  vec3 dimension;\n  vec3 domainMin;\n  vec3 domainMax;\n  float id;\n};\n\nRectSubdivResult nullSubdiv() {\n  RectSubdivResult result;\n\n  result.volume = 0.0;\n  result.center = vec3( 0.0 );\n  result.dimension = vec3( 0.0 );\n  result.domainMin = vec3( 0.0 );\n  result.domainMax = vec3( 0.0 );\n  result.id = 0.0;\n  \n  return result;\n}\n\n/**\n * Ref: https://www.shadertoy.com/view/7sKGRy\n * @param p The input position\n * @param scale scale of the domain of the fractal\n */\nRectSubdivResult rectSubdiv( vec3 p, vec3 scale ) {\n  float t = iTime;\n\n  // several constants\n  const int ITERS = 12;\n  const int MIN_ITERS = 1;\n  const float MIN_SIZE = 0.1;\n  const float BREAK_CHANCE = 0.0;\n\n  // the domain of the fractal being generated\n  // will be modified in the iteration part\n  vec3 domainMin = -scale;\n  vec3 domainMax = scale;\n\n  // id of the individual cube in the fractal\n  float id = 0.0;\n  \n  // random seed of cut positions\n  float seed = GEOMETRY_SEED;//floor( t / 6.0 ) + 0.1;\n\n  // size of the current box determined by domainMin / domainMax\n  vec3 dimension = domainMax - domainMin;\n  \n  for ( int i = 0; i < ITERS; i ++ ) {\n    float fi = float( i );\n\n    // divide the box into eight\n    vec3 divideHash = vec3(\n      fs( dot( vec2( fi + id, seed ), vec2( 1.26, 2.72 ) ) ),\n      fs( dot( vec2( fi + id, seed ), vec2( 1.78, 0.47 ) ) ),\n      fs( dot( vec2( fi + id, seed ), vec2( 0.78, 2.25 ) ) )\n    );\n    vec3 divide = divideHash * dimension + domainMin;\n\n    // let the division line cut the box not too thin\n    divide = clamp( divide, domainMin + MIN_SIZE, domainMax - MIN_SIZE );\n    \n    // does this cut the box to the minimum preferrable size?\n    vec3 minSizeOfAxis = min( abs( domainMin - divide ), abs( domainMax - divide ) );\n    float minSize = minV3( minSizeOfAxis );\n    bool isSmallEnough = minSize <= MIN_SIZE;\n\n    bool willBreak = false;\n    if ( i - 1 > MIN_ITERS && fs( id ) < BREAK_CHANCE ) { willBreak = true; }\n    if ( isSmallEnough && i - 1 > MIN_ITERS || i == ITERS - 1 ) { willBreak = true; }\n    if( willBreak ) {\n      // id = i * 0.1 * seed;\n      break;\n    }\n\n    // update the box domain\n    domainMax = mix( domainMax, divide, step( p, divide ) );\n    domainMin = mix( divide, domainMin, step( p, divide ) );\n\n    // id will be used for coloring and hash seeding\n    vec3 diff = mix( -divide, divide, step( p, divide ) );\n    id = length( diff + 10.0 );\n\n    // recalculate the dimension\n    dimension = domainMax - domainMin;\n  }\n  \n  // calculate volume and center of the box\n  float volume = dimension.x * dimension.y * dimension.z;\n  vec3 center = ( domainMin + domainMax ) / 2.0;\n  \n  // prepare the result\n  RectSubdivResult result;\n  result.volume = volume;\n  result.center = center;\n  result.dimension = dimension;\n  result.domainMin = domainMin;\n  result.domainMax = domainMax;\n  result.id = id;\n  \n  return result;\n}\n\n// Ref: https://iquilezles.org/articles/boxfunctions\nfloat tracebox( vec3 ro, vec3 rd, vec3 s ) {\n  vec3 m = 1.0 / rd;\n  vec3 n = m * ro;\n  vec3 k = abs( m ) * s;\n\t\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n\n  float tN = max( max( t1.x, t1.y ), t1.z );\n  float tF = min( min( t2.x, t2.y ), t2.z );\n\n  if( tN > tF || tF < 0.0 ) { return FAR; }\n\n  return tN;\n}\n\nfloat sdbox( vec3 p, vec3 s ) {\n  vec3 d = abs( p ) - s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nMarchResult map( vec3 p, RectSubdivResult subdiv ) {\n  float d = 1E9, d2;\n  Material mtl;\n  \n  vec3 pt = p;\n  pt -= subdiv.center;\n  \n  if ( fs( subdiv.id + 0.0 ) < GEOMETRY_DENSITY ) {\n    #ifdef GEOMETRY_SPHERE\n      d = length( pt ) - 0.5 * minV3( subdiv.dimension ) + GEOMETRY_MARGIN;\n    #else\n      d = sdbox( pt, 0.5 * subdiv.dimension - GEOMETRY_MARGIN );\n    #endif\n  \n    float diceMtl = fs( subdiv.id + 1.0 );\n  \n    if ( diceMtl < 0.1 ) {\n      mtl.albedo = vec3( 0.8 );\n      mtl.roughness = 0.1;\n      mtl.metallic = 0.0;\n      mtl.emissive = vec3( 11.0, 3.0, 3.0 );\n    } else if ( diceMtl < 0.2 ) {\n      mtl.albedo = vec3( 0.8, 0.1, 0.1 );\n      mtl.roughness = 0.05;\n      mtl.metallic = 0.0;\n      mtl.emissive = vec3( 0.0 );\n    } else {\n      vec3 noise = cyclicNoise( p, vec3( -1.0, 3.0, 4.0 ), 2.0 );\n      float rough = smoothstep( -0.2, 0.7, noise.y );\n\n      mtl.albedo = vec3( 0.1, 0.11, 0.13 ) * ( 1.0 + 0.4 * rough );\n      mtl.roughness = 0.2 + 0.08 * rough;\n      mtl.metallic = 0.0;\n      mtl.emissive = vec3( 0.0 );\n    }\n  }\n\n  if ( GEOMETRY_FRAME > 0.0 ) {\n    d2 = sdbox( pt, 0.5 * subdiv.dimension + GEOMETRY_FRAME );\n    d2 = max( d2, -sdbox( pt, 0.5 * subdiv.dimension + vec3( -1.0, -1.0, 1.0 ) * GEOMETRY_FRAME ) );\n    d2 = max( d2, -sdbox( pt, 0.5 * subdiv.dimension + vec3( 1.0, -1.0, -1.0 ) * GEOMETRY_FRAME ) );\n    d2 = max( d2, -sdbox( pt, 0.5 * subdiv.dimension + vec3( -1.0, 1.0, -1.0 ) * GEOMETRY_FRAME ) );\n    if ( d2 < d ) {\n      d = d2;\n      mtl.albedo = vec3( 0.7, 0.6, 0.1 );\n      mtl.roughness = 0.1;\n      mtl.metallic = 1.0;\n    mtl.emissive = vec3( 0.0 );\n    }\n  }\n  \n  // shoutouts to slerpy for recommending placing this on the floor\n  #ifdef FLOOR\n    d2 = p.y + 1.01;\n    if ( d2 < d ) {\n      d = d2;\n\n      vec3 noise = cyclicNoise( 2.0 * p, vec3( -1.0, 3.0, 4.0 ), 2.0 );\n      float rough = noise.y;\n\n      mtl.albedo = vec3( 0.5, 0.04, 0.04 );\n      mtl.roughness = 0.15 + 0.04 * rough;\n      mtl.metallic = 0.0;\n      mtl.emissive = vec3( 0.0 );\n    }\n  #endif\n  \n  pt = p - vec3( -4.0, 3.0, -4.0 );\n  d2 = sdbox( pt, vec3( 4.0, 0.1, 4.0 ) );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.0 );\n    mtl.roughness = 0.05;\n    mtl.metallic = 0.0;\n    mtl.emissive = 10.0 * vec3( 0.5, 0.62, 1.0 );\n  }\n  \n  pt = p - vec3( -6.0, 2.0, 6.0 );\n  d2 = sdbox( pt, vec3( 4.0, 4.0, 4.0 ) );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.0 );\n    mtl.roughness = 0.05;\n    mtl.metallic = 0.0;\n    mtl.emissive = 5.0 * vec3( 0.6, 0.7, 1.0 );\n  }\n  \n  pt = p - vec3( 8.0, 6.0, 0.0 );\n  d2 = sdbox( pt, vec3( 2.0 ) );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.0 );\n    mtl.roughness = 0.05;\n    mtl.metallic = 0.0;\n    mtl.emissive = 10.0 * vec3( 0.8, 0.9, 1.0 );\n  }\n  \n  MarchResult result;\n  result.d = d;\n  result.mtl = mtl;\n  \n  return result;\n}\n\nvec3 nMap( vec3 p, vec2 d, RectSubdivResult subdiv ) {\n  return normalize( vec3(\n    map( p + d.yxx, subdiv ).d - map( p - d.yxx, subdiv ).d,\n    map( p + d.xyx, subdiv ).d - map( p - d.xyx, subdiv ).d,\n    map( p + d.xxy, subdiv ).d - map( p - d.xxy, subdiv ).d\n  ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / reso.xy;\n\n  seed = texture( iChannel0, uv );\n  seed += float( iFrame );\n  random();\n\n  vec2 p = 2.0 * fragCoord.xy / reso.xy - 1.0;\n  p.x *= reso.x / reso.y;\n  \n  #ifdef LETTERBOX\n    if ( abs( p.x ) > LETTERBOX ) {\n      fragColor = vec4( 0.0 );\n      return;\n    }\n  #endif\n  \n  p += ( 2.0 * random2() - 1.0 ) / reso.xy;\n  \n  vec3 cp = vec3( 5.0, 3.0, 5.0 );\n  vec3 ct = vec3( 0.0 );\n  mat3 cm = orthBas( normalize( cp - ct ) );\n\n  vec3 ro = cm * vec3( 2.0 * p, 5.0 );\n  vec3 rd = cm * vec3( 0, 0, -1 );\n  \n  #ifdef PERSPECTIVE\n    ro = cm * vec3( 0.0, 0.0, 5.0 );\n    rd = cm * normalize( vec3( p, -2.0 ) );\n  #endif\n\n  vec3 col = vec3( 0 );\n  vec3 colRem = vec3( 1 );\n  \n  float rl = EPSILON; // will be instantly shortened to lenToNextGrid\n  vec3 rp;\n  MarchResult result;\n\n  RectSubdivResult subdiv = nullSubdiv();\n  \n  float lenToNextGrid = EPSILON;\n\n  for ( int i = 0; i < ITER; i ++ ) {\n    if ( rl >= lenToNextGrid ) {\n      rl = lenToNextGrid;\n      rp = ro + rd * rl;\n      \n      bool withinBox = all( lessThan( abs( rp + EPSILON * rd ), vec3( 1.0 ) ) );\n\n      if ( !withinBox ) {\n        // trace toward the domain box\n        subdiv = nullSubdiv();\n        float lenToBox = tracebox( rp + EPSILON * rd, rd, vec3( 1.0 ) );\n        lenToNextGrid = rl + lenToBox + EPSILON;\n      } else {\n        // see the distance to the next cell\n        subdiv = rectSubdiv( rp + EPSILON * rd, vec3( 1.0 ) );\n        vec3 edgeOfAxis = mix( subdiv.domainMin, subdiv.domainMax, step( 0.0, rd ) );\n        vec3 distToEdgeOfAxis = abs( rp - edgeOfAxis ) / ( abs( rd ) + EPSILON );\n        float distToEdge = minV3( distToEdgeOfAxis );\n        lenToNextGrid = rl + distToEdge + EPSILON;\n      }\n    }\n    \n    if ( rl >= FAR ) { // miss\n      break;\n    }\n  \n    result = map( rp, subdiv );\n    rl += 0.7 * result.d;\n    rp = ro + rd * rl;\n\n    if ( abs( result.d ) < 1E-3 ) { // hit\n      col += result.mtl.emissive * saturate( colRem );\n    \n      vec3 N = nMap( rp, vec2( 0.0, mix( 1E-4, 3E-3, result.mtl.metallic ) ), subdiv );\n\n      ro = rp + N * EPSILON;\n\n      vec3 albedo = mix( 0.96 * result.mtl.albedo, vec3( 0.0 ), result.mtl.metallic );\n      vec3 f0 = mix( vec3( 0.04 ), result.mtl.albedo, result.mtl.metallic );\n\n      if ( random() < 0.5 ) {\n        // specular\n        // Ref: http://gregory-igehy.hatenadiary.com/entry/2015/02/26/154142\n        vec3 H = importanceSampleGGX( result.mtl.roughness, N );\n        vec3 wo = reflect( rd, H );\n        if ( dot( wo, N ) < 0.0 ) { break; }\n\n        float VdotH = dot( -rd, H );\n        float NdotL = dot( N, wo );\n        float NdotH = dot( N, H );\n        float NdotV = dot( N, -rd );\n        vec3 F = F_Schlick( f0, VdotH );\n        float G = G_Smith( result.mtl.roughness, NdotV, NdotL );\n\n        colRem *= max( F * G * max( 0.0, VdotH ) / NdotH * NdotV, 0.0 );\n        rd = wo;\n      } else {\n        // diffuse\n        vec3 wo = importanceSampleLambert( N );\n        vec3 H = normalize( -rd + wo );\n\n        float VdotH = dot( -rd, H );\n        vec3 F = F_Schlick( f0, VdotH );\n\n        colRem *= ( 1.0 - F ) * albedo;\n        rd = wo;\n      }\n\n      rd = normalize( rd );\n\n      colRem *= 2.0;\n      rl = EPSILON;\n      lenToNextGrid = EPSILON;\n      rp = ro + rd * rl;\n    }\n\n    if ( dot( colRem, colRem ) < EPSILON ) { // run out of effective radiance\n      break;\n    }\n  };\n\n  // very random background\n  col += colRem * mix(\n    vec3( 0.82, 0.03, 0.04 ),\n    vec3( 0.07, 0.08, 0.1 ),\n    0.5 + 0.5 * rd.y\n  );\n  // col += colRem * pow( texture( iChannel1, rd ).xyz, vec3( 2.2 ) );\n\n  fragColor = vec4( col, 1.0 );\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Accumulate\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  // accumulate using backbuffer\n  fragColor = texture( iChannel0, uv );\n\n  if ( iFrame > 1 && iMouse.w < 0.5 ) {\n    fragColor += texture( iChannel1, uv );\n  }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Bloom downsample\n\nconst float WEIGHT_1 = 1.0;\nconst float WEIGHT_2 = 2.0;\nconst float WEIGHT_4 = 4.0;\nconst vec3 LUMA = vec3( 0.299, 0.587, 0.114 );\n\nbool isValidUV( vec2 uv ) {\n  return all( lessThan( abs( uv - 0.5 ), vec2( 0.5 ) ) );\n}\n\nvec4 fetch( sampler2D sampler, vec2 uv, float level ) {\n  if ( !isValidUV( uv ) ) {\n    return vec4( 0.0 );\n  }\n\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25, 0.125...\n  vec2 uvt = level < 0.0 ? uv : ( ( 1.0 - p ) + 0.5 * uv * p );\n\n  vec4 tex = texture( sampler, uvt );\n  vec3 col = tex.rgb / tex.a;\n  float luma = dot( LUMA, col );\n  return vec4( col, 1.0 + 0.5 * luma );\n  // return vec4( tex.xyz, 1.0 + luma );\n}\n\nvec4 tap13( sampler2D sampler, vec2 uv, float level ) {\n  vec2 deltaTexel = pow( 2.0, 1.0 + level ) / iResolution.xy;\n\n  // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n  vec4 tex = WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0, -1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0, -1.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2( -0.5, -0.5 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.5, -0.5 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  0.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  0.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  0.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2( -0.5,  0.5 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.5,  0.5 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  1.0 ), level );\n  return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n  float level = floor( -log2( 1.0 - uv.x ) );\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25...\n\n  vec2 uv0 = vec2( 1.0 - p );\n  vec2 uv1 = uv0 + 0.5 * p;\n  uv = ( uv - uv0 ) / ( uv1 - uv0 );\n\n  if ( !isValidUV( uv ) ) {\n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec4 tex;\n  if ( level == 0.0 ) {\n    tex = tap13( iChannel0, uv, level - 1.0 );\n  } else {\n    tex = tap13( iChannel1, uv, level - 1.0 );\n  }\n\n  vec3 col = tex.w > 1E-3 ? tex.rgb / tex.w : vec3( 0.0 );\n\n  if ( level == 0.0 ) {\n    float brightness = dot( LUMA, col );\n    vec3 normalized = brightness < 1E-4 ? vec3( brightness ) : col / brightness;\n    col = max( 0.0, brightness - 1.0 ) * normalized;\n  }\n\n  fragColor = vec4( col, 1.0 );\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Bloom upsample\n\nconst float WEIGHT_1 = 1.0 / 16.0;\nconst float WEIGHT_2 = 2.0 / 16.0;\nconst float WEIGHT_4 = 4.0 / 16.0;\n\nbool isValidUV( vec2 uv ) {\n  return all( lessThan( abs( uv - 0.5 ), vec2( 0.5 ) ) );\n}\n\nvec4 fetch( sampler2D sampler, vec2 uv, float level ) {\n  if ( !isValidUV( uv ) ) {\n    return vec4( 0.0 );\n  }\n\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25, 0.125...\n  vec2 uvt = level < 0.0 ? uv : ( ( 1.0 - p ) + 0.5 * uv * p );\n\n  vec4 tex = texture( sampler, uvt );\n  return tex;\n}\n\nvec4 tap9( sampler2D sampler, vec2 uv, float level ) {\n  vec2 deltaTexel = pow( 2.0, 1.0 + level ) / iResolution.xy;\n\n  // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n  vec4 tex = WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0, -1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  0.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  0.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  0.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  1.0 ), level );\n  return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n\n  float level = floor( -log2( 1.0 - uv.x ) );\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25...\n\n  vec2 uv0 = vec2( 1.0 - p );\n  vec2 uv1 = vec2( 1.0 - 0.5 * p );\n  uv = ( uv - uv0 ) / ( uv1 - uv0 );\n\n  if ( !isValidUV( uv ) ) {\n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec4 tex = tap9( iChannel0, uv, level + 1.0 );\n  if ( level < 5.0 ) {\n    tex += tap9( iChannel1, uv, level + 1.0 );\n  }\n\n  vec3 col = tex.rgb;\n\n  fragColor = vec4( col, 1.0 );\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Settings\n\n#define LETTERBOX 1.0\n// #define GEOMETRY_SPHERE\n#define FLOOR\n// #define PERSPECTIVE\n\nconst int ITER = 200;\nconst float GEOMETRY_SEED = 0.18;\nconst float GEOMETRY_MARGIN = 0.03;\nconst float GEOMETRY_FRAME = 0.002;\nconst float GEOMETRY_DENSITY = 0.8;\n","name":"Common","description":"","type":"common"}]}