{"ver":"0.1","info":{"id":"fdGfRV","date":"1659484595","viewed":519,"name":"2D rain sheets","username":"Port51","description":"Simple rain sheets using randomly generated sheets/layers\n\nReferences:\nHashes from https://www.shadertoy.com/view/XlGcRh","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\n\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nfloat HashToNoise(uint hash)\n{\n    return float(hash % 65536u) / 65536.0;\n}\n\nvec2 HashToNoise(uvec2 hash)\n{\n    return vec2(\n        float(hash.x % 65536u) / 65536.0,\n        float(hash.y % 65536u) / 65536.0\n    );\n}\n\nvec3 HashToNoise(uvec3 hash)\n{\n    return vec3(\n        float(hash.x % 65536u) / 65536.0,\n        float(hash.y % 65536u) / 65536.0,\n        float(hash.z % 65536u) / 65536.0\n    );\n}\n\nmat2 RotationMatrix(float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n\nvec4 GetRainLayer(vec2 uv, float layerScale, float layerIntensity, float layerBlueShift, uint viewType)\n{\n    uvec2 rc = uvec2(uv * vec2(50.0, 10.0) * layerScale);\n    float colNoise0 = HashToNoise(pcg(rc.x));\n    \n    // Random speed and drop length\n    float rainFallDist = (colNoise0 * 2.0 + iTime * 5.0 * (layerScale * 0.9 + 0.1));\n    float heightScale = (colNoise0 * 3.0 + 5.0) * layerScale;\n    \n    rc.y = uint(uv.y * heightScale + rainFallDist);\n    float rowNoise0 = HashToNoise(pcg(rc.y));\n    vec2 cellNoise0 = HashToNoise(pcg2d(rc));\n    \n    // Local coords within cell\n    vec2 f = fract(uv * vec2(50.0, heightScale) + vec2(0.0, rainFallDist));\n    f.y = 1.0 - f.y;\n    \n    // Shift drop left or right\n    float xOffset = (rowNoise0 * 2.0 - 1.0) * 0.4;\n    \n    vec2 sdf = vec2(abs((f.x + xOffset) * 2.0 - 1.0), f.y);\n    \n    float dropVisibility = cellNoise0.x;\n    float v = max(0.0, 1.0 - sdf.x * 3.0) * f.y * dropVisibility * layerIntensity;\n    \n    if (viewType == 2u)\n        return vec4(cellNoise0.x);\n    else\n        return vec4(mix(vec3(1.0), vec3(0.2, 0.5, 1.0), layerBlueShift) * v, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Divide screen into different views\n    uint viewType;\n    if (uv.x < 0.25) viewType = 0u;\n    else if (uv.x < 0.75) viewType = 1u;\n    else viewType = 2u;\n    \n    vec4 c = vec4(0.0);\n    float layerThetaOffset = -0.08; // Global rotation for all layers\n    \n    uint layerCt = (viewType == 1u) ? 25u : 1u;\n    for (uint i = 0u; i < layerCt; ++i)\n    {\n        // Setup layer properties\n        float layerNoise0 = HashToNoise(pcg(i));\n        float layerTheta = (layerNoise0 * 2.0 - 1.0) * 0.011 + layerThetaOffset; // Random theta per layer\n        vec2 layerUv = uv * RotationMatrix(layerTheta);\n        \n        // Farther raindrops should be smaller, less intense, and bluer\n        float layerScale = sqrt(float(i) * 0.25 + 1.0);\n        float layerIntensity = exp(-float(i + 1u) * 0.235);\n        float layerBlueShift = 1.0 - exp(-float(i + 1u) * 0.25);\n        \n        c += (1.0 - c.a) * GetRainLayer(layerUv + float(i) * vec2(223.32849, 432.3829), layerScale, layerIntensity, layerBlueShift, viewType);\n    }\n\n    // Output to screen\n    fragColor = vec4(c.rgb, 1.0);\n    \n    // Dividing lines\n    if (uv.x > 0.75 && uv.x < 0.76) fragColor = vec4(1.0);\n    if (uv.x > 0.24 && uv.x < 0.25) fragColor = vec4(1.0);\n}","name":"Image","description":"","type":"image"}]}