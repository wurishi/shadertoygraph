{"ver":"0.1","info":{"id":"sldyW4","date":"1659857957","viewed":116,"name":"Inside Origami","username":"grom12345","description":"Built this for #WCCChallenge, not sure how to optimise it yet.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","tunnel","paper","koch","origami"],"hasliked":0,"parentid":"fldyWN","parentname":"Fork Fork Fork  grom12345 408"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//based heavily on these two shaders:\n//https://www.shadertoy.com/view/tdcGDj\n//https://www.shadertoy.com/view/WtGXDD\n\n#define MAX_STEPS 200\n#define MAX_DIST 6.\n#define SURF_DIST .0001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nvec2 N(float angle) {\n// angle to vector\n    return vec2(sin(angle), cos(angle));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn abs(length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.))-0.01;\n}\n\nfloat sdPlane(vec3 p, float z){\n    return p.z-z;\n}\n\nvec2 koch(vec2 uv, int k) {\n    uv.x = abs(uv.x);\n   \n    float d;\n    \n    vec2 n = N((5./6.)*3.1415);\n    \n    uv.y += tan((5./6.)*3.1415)*.5;\n   \td = dot(uv-vec2(.5, 0), n);\n    uv -= max(0.,d)*n*2.;\n    \n    float scale = 1.;\n    \n    n = N((2./3.)*3.1415);\n    uv.x += .5;\n    for(int i=0; i<k; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        d = dot(uv, n);\n        uv -= min(0.,d)*n*2.;\n    }\n    uv /= scale;\n    return uv;\n}\n\nvec2 koch3D(vec3 p, int n){\n     vec2 uv = p.xy;\n     return koch(uv, n);\n}\n\nvec4 GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    float plane1 = sdPlane(p, 20.);\n    float plane2 = -sdPlane(p, 0.);\n    \n    vec2 q = vec2(length(p.xz)-1.,-p.y);\n    float time = pow(sin(iTime*0.08-.9)*0.5+0.5, 3.);\n    float floorPlane = (p.y+.435-0.02*(1.-time));\n    \n    float t = sin(atan(p.x, p.z)*5.)*0.5+0.5;//mod(iTime*0.5, 1.);\n    time = t*(time);\n    //float time = mod(p.z*(5.-abs(p.z*0.5))*0.01+iTime*0.5, 1.);\n    q.xy *= Rot(time*PI*0.125);\n    //p.xy += vec2(sin(iTime*0.32895+p.z), cos(iTime*0.123765+p.z))*0.5;\n    int n1;\n    int n2;\n    float k;\n    float scale1;\n    float scale2;\n    \n    float parts = 7.;\n    int part = int(time*parts);\n    n1 = part;\n    n2 = part+1;\n    scale1 = pow(4./3., float(part));\n    scale2 = scale1*4./3.;\n    k = (time-float(part)/parts)*parts;\n    \n    \n    \n    vec2 koch1 = koch(q*scale1, n1)/scale1;\n    vec2 koch2 = koch(q*scale2, n2)/scale2;\n    \n    vec2 dd = mix(koch1, koch2, k);\n    vec2 uv = vec2(t, (atan(p.xy))*2.);\n    //float d = dd.y+texture(iChannel0, uv*1.).x*0.0001;\n    \n    \n    \n    float d = dd.y;\n    d = abs(d)-0.005;\n    \n    //d = max(d, plane1);\n    //d = max(d, plane2);\n    \n    d *= .5;\n    \n    if (floorPlane<d){\n        return vec4(0, uv, floorPlane);\n    }else{\n        return vec4(1, uv, d);\n    }\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec4 dS;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS.w;\n        if(dO>MAX_DIST || abs(dS.w)<SURF_DIST) break;\n    }\n    \n    return vec4(dS.rgb, dO);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).w - \n        vec3(GetDist(p-e.xyy).w, GetDist(p-e.yxy).w,GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    float time = iTime*0.2+1.6;\n    \n    vec2 n = N(time);\n    vec2 nN = n*0.5+0.5;\n\n    vec3 ro = vec3(n*(1.+pow(nN.x, 20.)*3.), pow(nN.x, 10.)).xzy;\n    //ro.yz *= Rot(m.y*PI);\n    //ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = vec3(uv, nN.x+0.5);\n    //rd.yz *= Rot(time*0.125+PI*0.5);\n    rd.yz *= Rot(pow(nN.x, 5.)*0.3);\n    rd.xz *= Rot(-time-(PI+nN.x*PI)*0.5);//*cos(time)*0.5+0.5;\n    \n    rd = normalize(rd);\n    //rd = mix(rd, vec3(uv, -1).xzy, sin(time)*0.5+0.5);\n   \n    vec4 dCol = RayMarch(ro, rd);\n    vec3 col = vec3(1);\n    vec2 uvt = dCol.yz*5.;\n    vec2 id = floor(uvt*5.);\n    float checkers = mod(id.y+id.x, 2.);\n    float d = dCol.w;\n\n    if(d<MAX_DIST) {\n       col = dCol.rgb;\n       \n       float noise = texture(iChannel0, uvt*10.).x;\n       float light = texture(iChannel0, uvt*.0002+n*0.002).x;\n       \n       \n       if (dCol.x==1.){\n           col = vec3(1.,.2*checkers, .35*checkers);\n           col += light*0.7-0.2;\n       }else{\n           col = vec3(1.,.2, .35);\n       }\n       \n       col += vec3(noise)*0.5;\n    \n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(r));\n        //if (dCol.x==1.) dif *= abs(p.z);\n        \n        //col = mix(col, vec3(1.), p.z-1.);\n        col *= pow(dif, .2);\n        if (dCol.x==1.){\n            float step = .005;\n            float steps = 10.;\n            float occ = 1.;\n            for(float i=1.; i<=steps; i++) {\n               vec3 p1 = p+n*step*i;\n               float d1 = GetDist(p1).w;\n               occ *= 1.-max(0., d1-step);\n            }\n            col *= vec3(pow(1.85-occ, 5.));\n        }else{\n            float step = .01;\n            float steps = 7.;\n            float occ = 1.;\n            for(float i=1.; i<=steps; i++) {\n               vec3 p1 = p+n*step*i;\n               float d1 = GetDist(p1).w;\n               occ *= 1.-max(0., d1-step);\n            }\n            col *= vec3(pow(1.8-occ, 5.));\n        }\n    }\n    \n\n    col = pow(col, vec3(.5));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}