{"ver":"0.1","info":{"id":"WtGyDm","date":"1611105367","viewed":472,"name":"Scrambled Sobol (0,2) Sequence","username":"AndrewHelmer","description":"Example of Practical Hash-Based Owen Scrambling (Burley, 2020), largely adapted from the supplemental material. Useful for ray tracers, far better than random points, especially for a path-tracer in Shadertoy.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["sampling","tracing","scrambling","hashing","sobol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n * Parameters to control the display of the points. Animation\n * must be reset to the 0th frame if you change these.\n */\nconst int num_points = 1024;\nconst int points_per_frame = 4;\nconst float pt_radius = 2.0;\n\n// 1.0 / 2^24\nconst float s = 1.0 / 16777216.0;\n\nuint reverse_bits(uint x) {\n    x = (((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1));\n    x = (((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2));\n    x = (((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4));\n    x = (((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8));\n    return ((x >> 16) | (x << 16));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * This first buffer simply computes and store elements of the Sobol (0,2) \n * sequence. This is a useful optimization for a ray tracer, because it\n * avoids having to recompute these values for every sample, although it\n * does cost a texture read.\n *\n * Code is mostly taken and adapted from the supplementary material\n * for Practical Hash-Based Owen Scrambling (Burley, 2020):\n *     http://www.jcgt.org/published/0009/04/01/\n */\n\nuint directions[32] = uint[32](\n      0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n      0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n      0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n      0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n      0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n      0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n      0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n      0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n);\n\nuint sobol(uint index) {\n      uint X = 0u;\n      for (int bit = 0; bit < 32; bit++) {\n        uint mask = (index >> bit) & 1u;\n        X ^= mask * directions[bit];\n      }\n      return X;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 0) {\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    uint index = uint(fragCoord.y)*uint(iResolution.x) + uint(fragCoord.x);\n    if (int(index) > num_points) return;\n    \n    uint x = reverse_bits(index) >> 8;\n    uint y = sobol(index) >> 8;\n    \n    float r = float(x) * s;\n    float g = float(y) * s;\n    fragColor = vec4(r,g,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n * This buffer loops over the indices to be rendered this frame, and computes \n * them by shuffling and scrambling the Sobol points from buffer A. Then it\n * draws the points for this frame over the previous result of the buffer. It\n * clears once it reaches the end of the array, and updates the random seeds.\n *\n * Much of this code is from the supplemental material for \n * Practical Hash-Based Owen Scrambling (Burley, 2020):\n *     http://www.jcgt.org/published/0009/04/01/\n */\nvec2 get_sobol_pt(uint index) {\n  uint y = index / uint(iChannelResolution[0].x);\n  uint x = index - (y * uint(iChannelResolution[0].x));\n  vec2 uv = vec2(x, y) / iChannelResolution[0].xy;\n  return texture(iChannel0, uv).rg;\n}\n\nuint laine_karras_permutation(uint x, uint seed) {\n    x += seed;\n    x ^= x * 0x6c50b47cu;\n    x ^= x * 0xb82f1e52u;\n    x ^= x * 0xc7afe638u;\n    x ^= x * 0x8d22f6e6u;\n    return x;\n}\n\nuint nested_uniform_scramble_base2(uint x, uint seed) {\n    x = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    return x;\n}\n\nuint hash_combine(uint seed, uint v) {\n    return seed ^ (v + (seed << 6) + (seed >> 2));\n}\n\nvec2 get_shuffled_scrambled_sobol_pt(uint index) {\n    uint loop_index = uint(iFrame*points_per_frame/num_points);\n    \n    uint x_seed = hash_combine(0x98fc82u, loop_index);\n    uint y_seed = hash_combine(0xab773au, loop_index);\n    uint shuffle_seed = hash_combine(0xacc75au, loop_index);\n\n    uint shuffled_index = \n      nested_uniform_scramble_base2(index, shuffle_seed) % uint(num_points);\n    vec2 sobol_pt = get_sobol_pt(shuffled_index);\n\n    uint x = uint(sobol_pt.x * 16777216.0) << 8;\n    uint y = uint(sobol_pt.y * 16777216.0) << 8;\n    x = nested_uniform_scramble_base2(x, x_seed);\n    y = nested_uniform_scramble_base2(y, y_seed);\n    return vec2(float(x >> 8) * s, float(y >> 8) * s);\n}\n\nbool within_radius(vec2 a, vec2 b, float r) {\n    vec2 diff = a-b;\n    return dot(diff, diff) < r*r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Skip the fragment if it's already been written, unless\n    // we've reached the end of the array.\n    if (iFrame > 0 &&\n        (iFrame*points_per_frame % num_points) \n             > ((iFrame-1)*points_per_frame % num_points)) {\n        vec2 uv = fragCoord / iResolution.xy;\n        vec4 prev_color = texture(iChannel1, uv);\n        if (prev_color.x < 1.0) {\n            fragColor = prev_color;\n            return;\n        }\n    }\n    \n    fragColor = vec4(1.0);\n    for (int i = 0; i < points_per_frame; i++) {\n        int idx = (iFrame*points_per_frame % num_points) + i;\n        if (idx > num_points) return;\n        \n        vec2 pt = get_shuffled_scrambled_sobol_pt(uint(idx));\n        if (within_radius(floor(pt*iResolution.xy), fragCoord, pt_radius)) {\n            fragColor = vec4(0.3, 0.3, 1.0, 1.0);\n            return;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}