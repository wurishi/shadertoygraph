{"ver":"0.1","info":{"id":"Ds3yDM","date":"1695270471","viewed":116,"name":"cartoon tree","username":"MonterMan","description":"cartoon tree","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["cartoon","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLE_COUNT 1\n#define T_MAX 1000.0\n#define cdot(a, b) clamp(dot((a), (b)), 0.0, 1.0)\n\n#define TWEAK1 (iMouse.y/iResolution.y)\n\nvec2 opMod(vec2 p, vec2 period, out vec2 outId)\n{\n    outId = floor((p+0.5*period)/period);\n    return mod(p+0.5*period, period)-0.5*period;\n}\n\nvec3 opMod(vec3 p, vec3 period, out vec3 outId)\n{\n    outId = floor((p+0.5*period)/period);\n    return mod(p+0.5*period, period)-0.5*period;\n}\n\nvec2 opModPolar(vec2 p, float period)\n{\n    float r = length(p);\n    float theta = atan(p.y, p.x);\n    theta = mod(theta+0.5*period, period)-0.5*period;\n    return r*vec2(cos(theta), sin(theta));\n}\n\n// <x, y, z> -> <theta, r, phi>\nvec3 toSpherical(vec3 p)\n{\n    float r = length(p);\n    p /= r;\n    \n    float theta = atan(p.z, p.x);\n    float phi = acos(p.y);\n    \n    return vec3(theta, r, phi);\n}\n\nfloat sdBall2d(vec3 p, vec2 id, vec2 idOffset, vec2 repPeriod)\n{\n    vec3 q = p;\n    q.xz -= repPeriod * idOffset;\n    vec2 r = hash22(id + idOffset);\n    q.xz += 0.55*(r-0.5);\n    return sdSphere(q, 0.45+0.1*r.x);\n}\n\nfloat sdBase2d(vec3 p)\n{\n    float dist = T_MAX;\n\n    const vec2 repPeriod = vec2(0.85);\n\n    vec2 domainId;\n    p.xz = opMod(p.xz, repPeriod, domainId);\n    \n    vec3 signs = vec3(sign(p.xz), 0.0);\n    \n    dist = smin(dist, sdBall2d(p, domainId, signs.zz, repPeriod), 0.01);\n    dist = smin(dist, sdBall2d(p, domainId, signs.xz, repPeriod), 0.01);\n    dist = smin(dist, sdBall2d(p, domainId, signs.zy, repPeriod), 0.01);\n    dist = smin(dist, sdBall2d(p, domainId, signs.xy, repPeriod), 0.01);\n    \n    return dist;\n}\n\nfloat sdBall(vec3 p, vec3 id, vec3 idOffset, vec3 repPeriod)\n{\n    vec3 q = p;\n    q -= repPeriod * idOffset;\n    vec3 r = hash43(id + idOffset).xyz;\n    r.y = 0.;\n    q += 0.55*(r-0.5);\n    return sdSphere(q, 0.45+0.1*r.x);\n}\n\nfloat sdBase(vec3 p)\n{\n    float dist = T_MAX;\n    \n    const vec3 repPeriod = vec3(0.85);\n\n    vec3 domainId;\n    p = opMod(p, repPeriod, domainId);\n    vec4 signs = vec4(sign(p), 0.0);\n\n    dist = smin(dist, sdBall(p, domainId, signs.www, repPeriod), 0.1);\n    dist = smin(dist, sdBall(p, domainId, signs.xww, repPeriod), 0.1);\n    dist = smin(dist, sdBall(p, domainId, signs.wyw, repPeriod), 0.1);\n    dist = smin(dist, sdBall(p, domainId, signs.xyw, repPeriod), 0.1);\n    dist = smin(dist, sdBall(p, domainId, signs.wwz, repPeriod), 0.1);\n    dist = smin(dist, sdBall(p, domainId, signs.xwz, repPeriod), 0.1);\n    dist = smin(dist, sdBall(p, domainId, signs.wyz, repPeriod), 0.1);\n    dist = smin(dist, sdBall(p, domainId, signs.xyz, repPeriod), 0.1);\n\n    return dist;\n}\n\nfloat sdBush(vec3 p, float scroll)\n{\n    float sdGuard = sdSphere(p, 3.0);\n    if (sdGuard > 2.0)\n    {\n        return sdGuard;\n    }\n\n    p = toSpherical(p);\n       \n    p.y -= 2.0;\n    \n    p.xz += scroll;\n    \n    float dist = sdBase2d(p);\n    \n    // iq's fbm detail technique: https://iquilezles.org/articles/fbmsdf/\n    float s = 1.0;\n    for (int i = 0; i < 2; ++i)\n    {\n        float env = dist - 0.1/s;\n        dist = smin(dist, smax(sdBase(s*p)/s, env, 0.3/s), 0.2/s);\n        s *= 2.0;\n    }\n    \n    return dist;\n}\n\nQuery map(vec3 p)\n{\n    Query query;\n    query.t = T_MAX;\n    query.matId = 0;\n    \n    update(query, p.y, 4);\n    \n    p.x += 0.02*sin(3.0*iTime+0.1*p.y)*p.y;\n    {\n        vec3 q = p;\n        q.y += 0.01*cos(8.2*iTime + 2.0*q.x);\n              \n        float scroll = 24.0; // tweak this value to get more variations\n        float bushScale = 1.15;\n        update(query, sdBush((q-vec3(0,5,0))*bushScale, scroll)/bushScale, 2);\n    }\n    \n    // tree trunk\n    p.xz += 0.1*sin(p.y);\n    float sdTrunk = sdCylinder(p-vec3(0,2.0,0), 5.0, 1.0);\n    {\n        vec3 q = p;\n        q.xz = opModPolar(q.xz, 1.3);\n        q.x -= 0.5;\n        sdTrunk = smin(sdTrunk, sdStick(q, vec3(-0.5,0.4,0), vec3(0.3,-0.1,0), 0.4, 0.1), 0.05);\n    }\n    update(query, sdTrunk, 3);\n    \n    return query;\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 256 && t < T_MAX; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float dist = map(p).t;\n        if (dist < 0.0001)\n        {\n            return 0.0;\n        }\n        t += dist;\n        res = min(res, k*dist/t);\n    }\n    return res;\n}\n\nfloat calcAO(vec3 p, vec3 n, float stepSize)\n{\n    float res = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; ++i)\n    {\n        float t = stepSize*float(i+1);\n        vec3 sampleP = p + t * n;\n        float dist = map(sampleP).t;\n        res += amp * (dist / t);\n        amp /= 2.0;\n        stepSize *= 2.0;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.001;      // replace by an appropriate value\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).t;\n    }\n    return normalize(n);\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 at = vec3(0, 4, 0);\n    vec3 ro = vec3(0, 5, -6);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0),cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.3 * cam_z);\n\n    int matId = -1;\n    float t = 0.0;\n    for (int i = 0; i < 512 && t < T_MAX; ++i)\n    {\n        vec3 p = ro + t * rd;\n        Query query = map(p);\n        if (abs(query.t) < 0.001)\n        {\n            matId = query.matId;\n            break;\n        }\n        t += query.t;\n    }\n\n    vec3 skyAvgCol = vec3(0.5,0.6,0.7);\n    \n    vec3 col = vec3(0);\n    \n    // calc sky gradient\n    vec3 skyCol;\n    {\n        float h = max(0.0, rd.y);\n        skyCol = mix(skyAvgCol, vec3(0.75, 0.78, 0.8), exp(-5.0*h));\n    }\n    \n    col = skyCol;\n    if (matId != -1)\n    {\n        vec3 p = ro + t * rd;\n        vec3 n = calcNormal(p);\n        vec3 ao = vec3(calcAO(p, n, 0.1));\n        ao = pow(ao, vec3(0.9,0.8,1.0));\n        \n        vec3 lightCol = vec3(0.95, 0.8, 0.6);\n        vec3 l = normalize(vec3(0.5, 0.4, -0.3));\n        \n        vec3 albedo = vec3(0.9);\n        float veg = 0.0;\n        if (matId == 1)\n        {\n            albedo = vec3(0.9);\n        }\n        else if (matId == 2)\n        {\n            albedo = vec3(0.2, 0.5, 0.2);\n            veg = 1.0;\n        }\n        else if (matId == 3)\n        {\n            albedo = vec3(0.3,0.15,0.1);\n        }\n        else if (matId == 4)\n        {\n            albedo = vec3(0.2, 0.45, 0.2);\n            veg = 0.1;\n        }\n        \n        vec3 shadow = vec3(calcShadow(p+0.001*n, l, 10.0));\n        shadow = pow(shadow, vec3(0.4,0.8,1.0));\n        \n        // smooth normal for the fresnel term so it looks softer\n        vec3 smooth_n = mix(n, normalize(p), 0.6);\n        vec3 fresnel = vec3(0.3,0.5,0.2) * pow(1.0+dot(rd, smooth_n), 3.0);// shadow;\n        \n        // direct light\n        col = 0.6 * albedo * lightCol * dot(n, l) * shadow;\n        // hacked subsurface (wrap shading) modulated by AO\n        col += veg * 0.5 * albedo * lightCol * (0.5 + 0.5 * dot(n, l)) * ao;\n        // sky ambient light\n        col += 0.05 * albedo * skyAvgCol * (0.5 + 0.5 * n.y) * ao;\n        // bounced light\n        col += 0.08 * albedo * lightCol * (0.5 - 0.5 * n.y) * ao;\n        col += veg * fresnel;\n        \n        col = mix(col, skyCol, 1.0-exp(-0.008*t));\n        //col = vec3(ao);\n        //col = shadow;\n    }\n    // vignette\n    col *= pow(rd.z, 0.4);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    vec2 pixelSize = vec2(2.0*aspectRatio,2.0) / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    for (int sampleI = 0; sampleI < SAMPLE_COUNT; ++sampleI)\n    {\n        vec2 jitter = hammersley(sampleI, SAMPLE_COUNT) - 0.5;\n        col += render(uv + jitter * pixelSize);\n    }\n    col /= float(SAMPLE_COUNT);\n\n    // fudge the color\n    col = pow(col, vec3(0.92, 0.95, 1.0));\n    col = mix(col, smoothstep(vec3(0), vec3(1), col), 0.8);\n    col *= 0.85;\n    // gamma\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat radicalInverse(int x, float base)\n{\n    int baseI = int(base);\n    float result = 0.0;\n    float b = 1.0 / base;\n    while (x > 0)\n    {\n        result += float(x % baseI) * b;\n        x /= baseI;\n        b /= base;\n    }\n    return result;\n}\n\nvec2 halton23(int index)\n{\n    return vec2(radicalInverse(index, 2.0), radicalInverse(index, 3.0));\n}\n\nvec2 hammersley(int index, int N)\n{\n    return vec2(float(index)/float(N), radicalInverse(index, 2.0));\n}\n\nmat2 rot2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        c, -s,\n        s, c);\n}\n\nfloat bilat(float x)\n{\n    return 2.0 * x - 1.0;\n}\n\n\nfloat noise2(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    \n    float a = hash12(ip+vec2(0,0));\n    float b = hash12(ip+vec2(1,0));\n    float c = hash12(ip+vec2(0,1));\n    float d = hash12(ip+vec2(1,1));\n    \n    vec2 t = smoothstep(vec2(0), vec2(1), fp);\n    return mix(mix(a, b, t.x),\n               mix(c, d, t.x),\n               t.y);\n}\n\nfloat fbm2(vec2 p)\n{\n    // origin is always black, offset it a little to look more natural\n    p += vec2(31.2, 72.1);\n    \n    float res = 0.0;\n    \n    float amp = 0.5;\n    float freq = 1.0;\n    for (int i = 0; i < 6; ++i)\n    {\n        res += amp * noise2(p*freq);\n        p *= rot2d(0.3*float(i));\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    \n    return res;\n}\n\nfloat voronoiEdge(vec2 p, float randomness)\n{\n    vec2 ip = floor(p);\n    vec2 a, b;\n    float aDist = 10e30;\n    float bDist = 10e31;\n    for (int dy = -1; dy <= 1; ++dy)\n    {\n        for (int dx = -1; dx <= 1; ++dx)\n        {\n            vec2 gridId = ip + vec2(dx, dy);\n            vec2 gridP = gridId + mix(vec2(0.5), hash22(gridId), vec2(randomness));\n            float currDist = length(gridP - p);\n            if (currDist < aDist)\n            {\n                bDist = aDist;\n                b = a;\n                aDist = currDist;\n                a = gridP;\n            }\n            else if (currDist < bDist)\n            {\n                bDist = currDist;\n                b = gridP;\n            }\n        }\n    }\n    \n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    return smoothstep(0.0, 0.03, abs(t-0.5));\n}\n\n//\n//\n// modeling essentials\n\n\nstruct Query\n{\n    float t;\n    int matId;\n};\n\n\nvoid update(inout Query query, float t, int matId)\n{\n    if (t < query.t)\n    {\n        query.t = t;\n        query.matId = matId;\n    }\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdSegment(vec3 p, float h, float r)\n{\n    p.y = max(0.0, abs(p.y) - 0.5*h);\n    return length(p) - r;\n}\n\nfloat sdSegment2(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    return length((a + t*ab) - p) - r;\n}\n\nfloat udBox2(vec2 p, vec2 dim)\n{\n    p = abs(p);\n    return length(max(vec2(0.0), p-0.5*dim));\n}\n\nfloat udBox(vec3 p, vec3 dim)\n{\n    vec3 q = abs(p) - 0.5*dim;\n    return length(max(q, 0.0));\n}\n\nfloat sdBox2(vec2 p, vec2 dim)\n{\n    vec2 q = abs(p) - 0.5*dim;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdBox(vec3 p, vec3 dim)\n{\n    vec3 q = abs(p) - 0.5*dim;\n    return length(max(q, 0.0)) + min(max(max(q.x, q.y), q.z), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    return sdBox2(vec2(length(p.xz), p.y), vec2(r, h));\n}\n\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r_a, float r_b)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;    \n    float t = clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0);    \n    return length(ap - t * ab) - mix(r_a, r_b, smoothstep(0.0,1.0,t));\n}\n\nfloat opRepeatLinear(float x, float period, out float outId)\n{\n    outId = floor((x+0.5*period) / period);\n    return mod(x+0.5*period, period)-0.5*period;\n}\n\nvec2 opRepeatLinear2(vec2 x, vec2 period, out vec2 outId)\n{\n    outId = floor((x+0.5*period) / period);\n    return mod(x+0.5*period, period)-0.5*period;\n}\n\n// basically mod(), but limited to hcount on each direction\nfloat modLim(float x, float period, float hcount)\n{\n    float id = floor(x/period);\n    if (id > 0.0) id = min(id, hcount);\n    if (id < 0.0) id = max(id, -hcount);\n    return x - id*period;\n}\n\nfloat opRepeatLimLinear(float x, float period, int count)\n{\n    float hcount = float(count/2);\n    return modLim(x+0.5*period, period, hcount)-0.5*period;\n}\n\nvec2 opRepeatPolar(vec2 p, float periodRadians, out float outId)\n{\n    float radius = length(p);\n    float theta = atan(p.y, p.x);\n    \n    theta = opRepeatLinear(theta, periodRadians, outId);\n    return radius * vec2(cos(theta), sin(theta));\n}\n\nfloat smin(float a, float b, float k)\n{\n    float term = max(0.0, k - abs(a - b));\n    return min(a, b) - 0.25/k*term*term;\n}\n\nfloat smax(float a, float b, float k)\n{\n    float term = max(0.0, k - abs(a - b));\n    return max(a, b) + 0.25/k*term*term;\n}","name":"Common","description":"","type":"common"}]}