{"ver":"0.1","info":{"id":"4XySRd","date":"1720336141","viewed":99,"name":"20240622_pathtracing - okdalto","username":"lioninoil","description":"make renderer","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nvoid rotX(inout vec3 z, float s, float c) {\n   z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\n\nvoid rotY(inout vec3 z, float s, float c) {\n   z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\n\nvoid rotZ(inout vec3 z, float s, float c) {\n   z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\n\nvoid rotX(inout vec3 z, float a) {\n   rotX(z, sin(a), cos(a));\n}\n\nvoid rotY(inout vec3 z, float a) {\n   rotY(z, sin(a), cos(a));\n}\n\nvoid rotZ(inout vec3 z, float a) {\n   rotZ(z, sin(a), cos(a));\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EP 0.001\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\n\nfloat fractal(vec3 p){\n    //rotY(p, 2.1);\n    for(int i = 0; i < 8; i++){\n        rotX(p, iTime * 0.2);\n        rotY(p, iTime * 0.1);\n        //rotY(p, 1.2);\n        //rotX(p, 0.3);\n        //rotY(p, 1.2);\n        rotZ(p, 0.2);\n        if(p.x+p.y<0.0) p.xy = -p.yx; // fold 1\n        if(p.y+p.z<0.0) p.yz = -p.zy; // fold 2\n        if(p.z+p.x<0.0) p.zx = -p.xz; // fold 3   \n        p -= 0.07;\n    }\n    return length(p) - 0.1;\n}\n\n\nfloat sdf(vec3 p){\n    float d = fractal(p);\n    d = min(d, sdSphere(p - vec3(cos(iTime) * 1.5, tan(iTime) * 1.2, sin(iTime) * 1.5), 0.4));\n    return d;\n}\n\nvec3 getNorm(vec3 p){\n    vec2 ep = vec2(EP, 0.0);\n    return normalize(vec3(\n        sdf(p + ep.xyy) - sdf(p - ep.xyy),\n        sdf(p + ep.yxy) - sdf(p - ep.yxy),\n        sdf(p + ep.yyx) - sdf(p - ep.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    // Normalized pixel coordinates (from 0 to 1)\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    vec3 tp = vec3(1.0);\n    \n    vec3 camPos = vec3(0.0, 0.0, -5.0);\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(vec3(uv, 0.0) - rayPos);\n    vec3 lightPos = vec3(cos(iTime), 0.5, sin(iTime));\n    bool isEnd = false;\n    for(int i = 0; i < 5; i++){\n        for(int j = 0; j < 100; j++){\n            float dist = sdf(rayPos);\n            if(dist < EP){\n                vec3 norm = getNorm(rayPos);\n                vec3 lightDir = normalize(lightPos - rayPos);\n                float diff = dot(norm, lightDir);\n                \n                if(length(rayPos - vec3(cos(iTime) * 1.5, tan(iTime) * 1.2, sin(iTime) * 1.5)) < 0.41){\n                    col += 50.0 * tp;\n                }else{\n                    col += 0.0 * tp;\n                }\n\n                tp = tp * vec3(1.0, 0.5, 0.2);\n                \n                rayPos += norm * EP * 2.0;\n                rayDir = normalize(RandomUnitVector(rngState) + norm);\n                break;\n            }\n            if(dist > 10.0){\n                col += texture(iChannel0, rayDir).xyz * tp;\n                isEnd = true;\n                break;\n            }\n            rayPos += rayDir * dist;\n        }\n        if(isEnd){\n            break;\n        }\n    }\n\n    // Output to screen\n    col = pow(col, vec3(1.0/2.2));\n    vec3 prev = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n    col = mix(prev, col, 0.05);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}