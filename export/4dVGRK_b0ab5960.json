{"ver":"0.1","info":{"id":"4dVGRK","date":"1457555478","viewed":404,"name":"Fish simulator 2016","username":"jcolman","description":"A fish... maybe thre will be more! Work in progress","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","fish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------------------------------\n// Jason Colman Feb 2016\n// Fish simulator 2016\n//------------------------------------------------------------------------\n\n#define PI 3.141592653589793\n\n// Initial value of t in ray equation p0 + t (p1 - p0)\n#define START_T 0.001\n\n// Once ray reaches this length, it won't hit anything in \n//  the scene.\n#define TOO_FAR 10.0\n\n// If distance from point to a surface is <= this, we are \n//  close enough to say we have hit it.\n#define CLOSE_ENOUGH 0.01\n\n// Max number of iterations in ray marching loop, will be\n//  interesting to find realistic value for this. Depends on\n//  number of objects in scene, no?\n// From a quick experiment, more than 100 makes no difference\n//  visually, for this example.\n#define MAX_ITERS 200\n\n#define LIGHT_DIR normalize(vec3(1.0, 0.8, 0.1))\n\n#define SPEED 1.0\n\n#define SMOOTH 0.1\n#define TAILW 0.07 * .3\n#define SCALE_SIZE 40.\n\n#define MAT_FISH  0\n#define MAT_EYE   1\n#define MAT_PUPIL 2\n\n//------------------------------------------------------------------------\n// From https://iquilezles.org/articles/smin\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//------------------------------------------------------------------------\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//------------------------------------------------------------------------\nfloat fishDist(vec3 pos)\n{\n    // Wriggle\n    float s = sin(iTime * 8. + pos.x);    \n    pos.z += s * .3;\n    \n    float bfin = max(\n        sdEllipsoid(pos + vec3(0.2, .4, 0), vec3(.3, 0.25, TAILW)),\n        sdEllipsoid(pos + vec3(0.1, .7, 0), vec3(.3, 0.3, 0.5)) );\n\n    float tfin = max(\n        sdEllipsoid(pos + vec3(-.3, -.75, 0), vec3(.5, 0.3, TAILW)),\n        sdEllipsoid(pos + vec3(0.1, -.65, 0), vec3(.4, 0.4, 0.5)) );\n    \n    float tail = max(\n        sdEllipsoid(pos + vec3(1.2, -0.55, 0), vec3(.6, 0.4, TAILW)),\n        sdEllipsoid(pos + vec3(1.5, -0.35, 0), vec3(.6, 0.45, 0.5)) );\n        \n    // Bottom tail\n//    tail = min(tail, max(\n//        sdEllipsoid(pos + vec3(1.2, 0.55, 0), vec3(.6, 0.4, TAILW)),\n//        sdEllipsoid(pos + vec3(1.5, 0.35, 0), vec3(.6, 0.45, 0.5))));\n        \n    float body = sdEllipsoid(pos + vec3(.1, 0, 0), vec3(.9, 0.4, 0.2));\n    \n    // Head\n    body = min(body,\n        sdEllipsoid(pos + vec3(-.5, 0, 0), vec3(.45, 0.3, 0.22)));\n               \n    // Mouth\n    body = max(body, \n        -sdEllipsoid(pos + vec3(-1., .1, 0), vec3(2., 0.1, 0.13)));\n\n    // No fins\n    return smin(tail, body, SMOOTH);\n    \n    return smin(tail, smin(min(bfin, tfin), body, SMOOTH), SMOOTH);    \n}\n\n//------------------------------------------------------------------------\nvec3 rotateY(vec3 pos, float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    return vec3(pos.x * c - pos.z * s, pos.y, pos.z * c + pos.x * s);\n}\n\n//------------------------------------------------------------------------\nvec3 fishpos(vec3 pos)\n{\n    float d = 4.;\n    \n    pos.y += sin(iTime * .6);\n    \n    pos.x += d * -sin(iTime);\n    pos.z += d * cos(iTime);\n\n    vec3 fpos = rotateY(pos, -iTime);   \n    return fpos;\n}\n\n//------------------------------------------------------------------------\nvec2 calcDist(vec3 pos)\n{\n    // Move fish around\n    \n    vec3 fpos = fishpos(pos);\n    float d = fishDist(fpos);\n    \n    //float d2 = fishDist(fpos + vec3(1., 1., 1.));\n    return vec2(d, 0);\n}\n\n//------------------------------------------------------------------------\nvec3 calcNormalAtPoint(vec3 pos) \n{\n    float d = 0.001;\n    vec2 u = vec2(1.0, 0.0);\n    return normalize(\n        vec3(\n            calcDist(pos + u.xyy * d).x - calcDist(pos - u.xyy * d).x,\n            calcDist(pos + u.yxy * d).x - calcDist(pos - u.yxy * d).x,\n            calcDist(pos + u.yyx * d).x - calcDist(pos - u.yyx * d).x\n        )\n    );\n}\n\n//------------------------------------------------------------------------\nvec3 render(vec3 eyePos, vec3 rayDir)\n{\n    vec3 bg = vec3(0.1, 0.2, 0.2);\n    \n    // t is distance along ray so far \n    float t = START_T;\n    \n    vec2 distMat = vec2(0.0, 0.0);\n    \n    // Repeatedly find the closest distance to an object in the\n    //  scene, and add this to t. \n    for( int i = 0; i < MAX_ITERS; i++ ) \n    {\n        // Distance to closest object and its material ID\n        distMat = calcDist(eyePos + rayDir * t);\n        float dist = distMat.x; // x-component is the distance\n\n        if (dist > TOO_FAR)\n            return bg; // ray has hit nothing, and never will \n        \n        if (dist <= CLOSE_ENOUGH)\n            break; // ray has hit something\n\n        t += dist * 0.9; // advance by this distance and keep marching\n    }\n\n    // Final pos, which is on surface of an object in the scene\n    vec3 pos = eyePos + rayDir * t;    \n    vec3 fpos = fishpos(pos);\n    \n    vec3 normal = calcNormalAtPoint(pos);\n    \n    // Calc diffuse lighting, and add a constant for ambient\n    float nDotL = min(max(0., dot(normal, LIGHT_DIR)) + 0.5, 1.0);\n\n    // Create red/white colour bands\n    float s = sin((fpos.x - .5) * 2.);\n    float c = cos(fpos.y * 1.);\n    float r =  c * c + s * s;\n    s = s * .5 + .5;\n    c = c * .5 + .5;\n    vec3 col = vec3(c, c * s, c * r * s * s); \n    // Shows basic colours\n    //return col;\n    \n    s = sin(fpos.x * SCALE_SIZE);\n    c = cos(fpos.y * SCALE_SIZE);\n    r = (s + c) * .7;\n    r *= r; \n    // Basic scales pattern\n    //return vec3(r);  \n    \n    s = clamp(0., 1., sin(fpos.z * 13.));\n    c = clamp(0., 1., cos(iTime * fpos.y * 11. + fpos.z * 2.));\n\n    //return vec3(s + c); // show mask\n    r *= (s + c);\n\n    // Basic scales pattern modulated by larger scrolling pattern,\n    //  giving shimmering effect\n    //return vec3(r);\n\n    // Just apply to the top half of the fish\n    r *= smoothstep(-.1, 1., fpos.y);\n    \n    // Make sure r is in range 0..1\n    r = clamp(r, 0., 1.);\n    //return vec3(r);\n\n    // Final colour is combination of colour bands and shimmering\n    //  scales effect\n    return vec3(nDotL * col ) + r * nDotL + vec3(0, 0, fpos.y * 0.1);\n}\n\n//------------------------------------------------------------------------\n// camera matrix\nmat3 getCameraMatrix( vec3 camFow ) \n{\n    vec3 forward = normalize( camFow );\n    vec3 up = normalize( vec3( 0.0, 0., 1.0 ) );\n    vec3 right = normalize( cross( up, forward ) );\n    \n    mat3 mat = mat3( right, up, forward );\n        \n    return mat;\n}\n\n//------------------------------------------------------------------------\nfloat lilypad(vec2 uv)\n{\n    float t = iTime * 0.004;\n    vec2 lilypos = 0.6 * vec2(cos(t), sin(t)); \n    vec2 d = vec2(uv - lilypos);\n    float dist = dot(d, d);\n    if (atan(d.x, d.y) + dist * 1.9 > 2.6)\n        return 999.;\n    if (dist > 0.03)\n        dist += sin(atan(d.x, d.y) * 80.) * 0.001;\n    return dist;\n}\n\n//------------------------------------------------------------------------\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get this pixel coord in range (-1..1)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\n    // Rotate camera in time with track curve, so we look at train\n    float deltaRot = -10.;//iMouse.x * 0.1; //iTime; //PI - sin(iTime * 1.05) * PI;\n\n    float D = 2.0;\n    float y = 12.0; //iMouse.y + 1.0; //cos(iTime * 0.2) + 2.0;\n    float z = -1.0; //iTime * SPEED;\n//    vec3 camPos = vec3( -D * cos(deltaRot), y, z + -D * sin(deltaRot) );\n    vec3 camPos = vec3(0, y, 0);\n//    vec3 camFow = vec3( 1.0 * cos(deltaRot), -40.0, 1.0 * sin(deltaRot) );\n    vec3 camFow = vec3(0, -1.0, 0);\n    mat3 camMat = getCameraMatrix( camFow );\n    \n    float viewRatio = iResolution.y / iResolution.x;\n    uv.y *= viewRatio;\n\n    vec3 rayDir = camMat * normalize( vec3( uv, viewRatio * 1.5 ) );\n    \n    // Get colour for pixel\n    vec3 colour = render(camPos, rayDir);\n    \n    float d = lilypad(uv);\n    if (d < .04)\n    {\n        colour = 0.7 * vec3(d * 20., .7, .25);\n    }\n    \n    fragColor = vec4(colour, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}