{"ver":"0.1","info":{"id":"7lGBzz","date":"1663943294","viewed":355,"name":"Fake Terrain Self Soft Shadow","username":"magician0809","description":"Fake Terrain Self Soft Shadow","likes":25,"published":1,"flags":0,"usePreview":1,"tags":["terrain","shadow","fake","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI (3.14159265359)\n#define DEG2RAD (PI / 180.0)\n\n#define STEPS (128)\n#define HEIGHT_SCALE (1.5)\n#define SHADOW_ANGLE (20.0 * DEG2RAD)\n#define FAST_SHADOW_INTEGRAL\n#define AGRRESSIVE_RAYMARCH\n\nfloat Min3(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat SampleTerrainHeightTS(vec2 uv)\n{\n    vec3 col = textureLod(iChannel0, uv, 0.0).rgb;\n    float height = col.r * 0.2 + col.g * 0.7 + col.b * 0.1;\n    return height;\n}\n\nvec3 SampleTerrainNormalTS(vec2 uv)\n{\n    vec2 texelSize = 1.0 / iChannelResolution[0].xy;\n    float hL = SampleTerrainHeightTS(vec2(uv.x - texelSize.x, uv.y));\n    float hR = SampleTerrainHeightTS(vec2(uv.x + texelSize.x, uv.y));\n    float hD = SampleTerrainHeightTS(vec2(uv.x, uv.y - texelSize.y));\n    float hU = SampleTerrainHeightTS(vec2(uv.x, uv.y + texelSize.y));\n    vec2 grad = vec2(hR - hL, hU - hD) / (texelSize * 2.0);\n    return vec3(-grad, 1.0);\n}\n\nfloat SampleTerrainHeight(vec2 pos, vec3 terrainSize)\n{\n    return SampleTerrainHeightTS(pos / terrainSize.xy) * terrainSize.z;\n}\n\nvec3 SampleTerrainNormal(vec2 pos, vec3 terrainSize)\n{\n    return SampleTerrainNormalTS(pos / terrainSize.xy) / terrainSize;\n}\n\nfloat ShadowIntegral(float x)\n{\n#ifdef FAST_SHADOW_INTEGRAL\n    return smoothstep(-1.0, 1.0, x);\n#else\n    x = clamp(x, -1.0, 1.0);\n    //integral(sqrt(1.0 - x * x))\n    return (sqrt(1.0 - x * x) * x + asin(x)) / PI + 0.5;\n#endif\n}\n\nfloat TerrainSoftShadow(vec3 ro, vec3 rd, vec3 terrainSize)\n{\n    float dt = Min3(terrainSize / abs(rd)) / float(STEPS);\n    float cosTheta = length(rd.xy);\n    float sinTheta = rd.z;\n    float res = 1.0;\n    float t = dt;\n    float shadowRange = tan(SHADOW_ANGLE);\n\tfor (int i = 0; i < STEPS; ++i)\n\t{\n\t    vec3 pos = ro + t * rd;\n        float deltaHeight = SampleTerrainHeight(pos.xy, terrainSize) - pos.z;\n        float projTerrain = (deltaHeight * cosTheta) / max(t + deltaHeight * sinTheta, 1e-5);\n        float shadow = ShadowIntegral(projTerrain / shadowRange);\n\t\tres = min(res, 1.0 - shadow);\n#ifdef AGRRESSIVE_RAYMARCH\n        t += max(dt, (0.5 / terrainSize.z) * -deltaHeight);\n        if (res <= 0.0 || pos.z > terrainSize.z) break;\n#else\n        t += dt;\n        if (res <= 0.0) break;\n#endif\n\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec3 terrainSize = vec3(1.0, 1.0, HEIGHT_SCALE);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x = (uv.x - 0.5) * aspect + 0.5;\n    vec2 posHorizontal = uv;\n\n    vec3 rayOriginWS = vec3(posHorizontal, SampleTerrainHeight(posHorizontal, terrainSize));\n    \n    vec3 rayDirectionWS;\n    if (iMouse.z > 0.0)\n    {\n        vec2 luv = iMouse.xy / iResolution.xy;\n        luv.x = (luv.x - 0.5) * aspect + 0.5;\n        vec3 lightPos = vec3(luv, 1.0);\n        rayDirectionWS = normalize(lightPos - rayOriginWS);\n    }\n    else\n    {\n        vec2 muv = vec2(cos(iTime), sin(iTime));\n        rayDirectionWS = normalize(vec3(muv, 1.0));\n    }\n    \n    float atten = TerrainSoftShadow(rayOriginWS, rayDirectionWS, terrainSize);\n\n    vec3 normalWS = SampleTerrainNormal(posHorizontal, terrainSize);\n    normalWS /= length(normalWS);\n    \n    float NoL = clamp(dot(normalWS, rayDirectionWS), 0.0, 1.0);\n\n    vec3 col = vec3(atten * NoL);\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}