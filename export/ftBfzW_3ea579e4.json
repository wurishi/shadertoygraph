{"ver":"0.1","info":{"id":"ftBfzW","date":"1651840620","viewed":74,"name":"raymarch attempt doug","username":"bentles","description":"i try to code raymarching without source material\n\nk raymarcher coded without looking at anything and then stole much from iq :'D","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nvec3 opRotateX( in vec3 p, in float angle ) {\n    vec3 column0 = vec3(1.0, 0.0, 0.0);\n    vec3 column1 = vec3(0.0, cos(angle), sin(angle));\n    vec3 column2 = vec3(0.0, -sin(angle), cos(angle));\n    mat3 n = mat3(column0, column1, column2); // sets columns of matrix n\n    \n    return n * p;\n}\n\nvec3 opRotateY( in vec3 p, in float angle ) {\n    vec3 column0 = vec3(cos(angle), 0.0, -sin(angle));\n    vec3 column1 = vec3(0.0, 1.0, 0);\n    vec3 column2 = vec3(sin(angle), 0.0, cos(angle));\n    mat3 n = mat3(column0, column1, column2); // sets columns of matrix n\n    \n    return n * p;\n}\n\nvec3 opRotateZ( in vec3 p, in float angle ) {\n    vec3 column0 = vec3(cos(angle), sin(angle), 0.0);\n    vec3 column1 = vec3(-sin(angle), cos(angle), 0.0);\n    vec3 column2 = vec3(0.0, 0.0, 1.0);\n    mat3 n = mat3(column0, column1, column2); // sets columns of matrix n\n    \n    return n * p;\n}\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nfloat sdWorld(vec3 world_coord) {\n\n    float pi = 3.1415;\n    float time = iTime / 2.0;\n    \n    // transform (rotate and repeat)\n     world_coord = opRotateY(world_coord, mod( time, 2.0 * pi));\n     //world_coord = opRotateX(world_coord, sin(time) * pi / 30.0);    \n    \n    world_coord = opRep(world_coord, vec3(8.0, 8.0, 8.0));\n    \n    world_coord = opRotateZ(world_coord, pi/2.0);\n    \n    //add shapes\n    float dBox = sdRoundBox(world_coord, vec3(0.3, 1.8, 0.3), 0.2);\n    \n    float dBox2 = sdRoundBox(world_coord, vec3(0.3, 0.3, 1.8), 0.2);\n    float dSphere = sdSphere(world_coord, 1.3);\n    \n    vec3 world_coord2 = opRotateZ(world_coord, pi / 2.0); \n    \n    float dTorus = sdTorus(world_coord2, vec2(1.5, 0.7));\n    \n    return max(max(max(-dTorus, dSphere), -dBox), -dBox2);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy* sdWorld( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx* sdWorld( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy* sdWorld( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx* sdWorld( pos + e.xxx*ep ) );\n}\n\n\nvec4 rayMarch(vec2 uv) {\n    // z coordinate comes out of the screen\n    \n    // gonna draw stuff at z = 0 so let's put camera closer to me\n    float z_cam = 10.0;\n    // rays passing thru camera all converge at this z coordinate:\n    float z_focal_point = z_cam + 15.0;// + (sin(iTime * 2.0)/1.0 + 0.5) * 2.0;\n    \n    //build a ray thru each pixel\n    vec3 cam_pixel_coord = vec3(uv, z_cam);\n    vec3 cam_fp_coord = vec3(0.0, 0.0, z_focal_point);    \n    vec3 ray = normalize(cam_pixel_coord - cam_fp_coord);\n    \n    //march cutoff criteria\n    float max_dist = 100000.0;\n    float hit_dist = 0.0001;\n    \n    float dist_to_check = 0.0;\n    vec3 ray_vec;\n    int max_steps = 1000;\n    \n    float color = 0.0; //black\n    \n    for (int i = 0; i < max_steps; i++)\n    {\n        ray_vec = cam_pixel_coord + ray * dist_to_check;\n        float dist = sdWorld(ray_vec);\n        \n        \n        if (abs(dist) < hit_dist) {\n            // how on earth do we decide the colour?\n            vec3 normal = calcNormal(ray_vec);\n            \n            // checking normal dot prod with 2 random points which act as lights\n            float shadow = \n                max(\n            dot(normal, normalize(vec3(0.7, 0.9, 0.2))),\n            dot(normal, normalize(vec3(-0.7, -0.4, 0.2))));\n            \n            color = shadow ;\n            break;\n        }        \n        dist_to_check += dist;\n        if (dist_to_check > max_dist) {\n            break;\n        }    \n    }\n    \n    return vec4(color, ray_vec);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\n    \n    // Time varying pixel color\n    vec4 shade_and_ray = rayMarch(uv);\n    vec3 colour = shade_and_ray.x * vec3(255.0/255.0, 232.0/255.0, 28.0/255.0);\n\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}