{"ver":"0.1","info":{"id":"ttSBWh","date":"1601021124","viewed":85,"name":"Basic Raymarching Controller","username":"Kiltun","description":"Raymarching Test based on : https://youtu.be/yxNnRSefK94","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","spheres","moving","keyboard","flying"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n        \n    vec4 out_color = texture(iChannel0, uv);\n\tfragColor = out_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_W = 87;\nconst int KEY_Z = 90;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_Q = 81;\nconst int KEY_D = 68;\nconst int KEY_SHIFT = 16;\nconst int KEY_SPACE = 32;\nconst int KEY_C = 67;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    vec3 o = cameraPosition(iChannel1);\n    float deltaTime = iTimeDelta;\n    \n    float zMov = texelFetch( iChannel0, ivec2(KEY_Z,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_S,0), 0 ).x;\n    float yMov = texelFetch( iChannel0, ivec2(KEY_SPACE,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_C,0), 0 ).x;\n    float xMov = texelFetch( iChannel0, ivec2(KEY_D,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_Q,0), 0 ).x;\n    float boost = texelFetch( iChannel0, ivec2(KEY_SHIFT,0), 0 ).x * 4.;\n    \n    deltaTime *= 1. + (boost);\n    o += (vec3(xMov * deltaTime,yMov * deltaTime, zMov * deltaTime));\n    \n    vec3 newPos = o;       \n    fragColor.xyz = newPos;\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\n\nconst int slotCameraPosition = 0;\nconst int slotCameraRotation = 1;\n\nvec3 cameraPosition(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraPosition).xyz;\n}\n\nvec3 cameraRotation(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraRotation).xyz;\n}\n\n\n//// ROTATION\n\nconst float pi = acos(-1.); //3.141592;\n\n// e^(i*rads) Euler's formula complex spinor\nvec2 cossin(float r)\n{\n    return sin(r + vec2(.5*pi, 0));\n}\n\n\nmat2 mrot(vec2 s)\n{\n    return mat2(s.x, -s.y, s.y, s.x);\n} // then can q.xz = mrot(cossin(a)) * q.xz;\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define ITERATIONS 32\n\nfloat map(vec3 p)\n{\n    p = fract(p) * 2. -1.;\n    return length(p) - 0.25;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.;\n    for(int i = 0; i < ITERATIONS; i++)\n    {\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 1.0));\n    /*r.zx *= mrot(cossin(iTime));\n    r.zy *= mrot(cossin(iTime));*/\n    \n    float time_var = iTime * 0.033;\n       \n    vec3 o = cameraPosition(iChannel1);\n    o += vec3(0.5, 0.0,time_var);\n        \n    float t = trace(o,r);\n    vec3 ball1 = 1. / vec3(t,t,t);\n    vec3 ball1Color = vec3(0.4,cos(time_var) * 0.5,sin(time_var*0.5) * 0.1);\n    ball1 *= ball1Color;\n    \n    float ti = trace(o + vec3(0.5,0.5,0.0),r);\n    vec3 ball2 = 1. / vec3(ti,ti,ti);\n    vec3 ball2Color = vec3(sin(time_var*1.2) * 0.3,cos(time_var*0.3) * 0.2,0.1);\n    ball2 *= ball2Color;\n    \n    //float fog = 1. / (1. + t * t* 0.1);\n    \n    //vec3 fc = vec3(fog);\n    \n    vec3 fini = vec3(max(ball1, ball2));\n\n    fragColor = vec4(fini,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}