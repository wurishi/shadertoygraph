{"ver":"0.1","info":{"id":"7tdyW4","date":"1659879295","viewed":111,"name":"twisty spaghetti","username":"jy483752","description":"spaghetti","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"7llXDs","parentname":"3d sjdhfnhfeahfnvahoief"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define getAo(p,n,d) clamp(GetDist(p+n*d)/d,0.,1.)\n#define PI acos(-1.)\n\nfloat GetDist(vec3 p){\n    p.xz *= rot(iTime/36.-p.y*PI/36.);\n    //for(int i=0; i<5; i++){\n    //    p = abs(p)-0.9;\n    //    p.xy*=rot(0.2+iTime);\n    //    p.xz*=rot(sin(iTime)*0.1);\n    //}\n    \n\n    vec4 s = vec4(0., 2., 6., 2.);\n    vec3 boxS = vec3(1., 6., 1.);\n    \n    //p.y += 1.;\n    //p.xy *=rot(sin(p.z*8.)*0.1);\n    //p.y -= 1.;\n    \n    vec3 twist = p;\n    twist.x = pmod(twist.x, 6.);\n    twist.z = pmod(twist.z, 6.);\n    twist.y = pmod(twist.y, 6.);\n    \n    twist.xz *= rot(iTime+twist.y*PI/6.);\n    \n    //float sphereDist = length(p-s.xyz)-s.w;\n    float boxDist = sdfBox(twist-vec3(0., 0., 0.), boxS);\n    //float planeDist = p.y;\n    \n    //float d = min(boxDist, planeDist);\n    return boxDist;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p)*0.1;\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.05, 0.);\n    \n    vec3 n = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p, \nvec3 lightPos, vec3 lightCol,\nvec3 albedo, vec3 n,\nvec3 rd){\n    vec3 l = normalize(lightPos-p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*6., l);\n    if(d<length(lightPos-p)) dif*=0.1;\n    \n    float fresnel = pow(1.-max(dot(n,-rd),0.),5.)*.1;\n    \n    return albedo*dif*lightCol+fresnel*lightCol;\n}\n\n//float DistLine(vec3 ro, vec3 rd, vec3 p){\n//    return length(cross((p-ro), rd))-length(rd);\n//}\n//\n//float DrawPoint(vec3 ro, vec3 rd, vec3 p){\n//    float d = DistLine(ro, rd, p);\n//    d = smoothstep(.06, .05, d);\n//    return d;\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 ro = vec3(.5, 4., .5);\n    \n    vec3 lookat = vec3(.5, 1., 0.);\n    \n    float zoom = .8;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    vec3 rd = normalize(i-ro);\n\n    float d = RayMarch(ro, rd);\n    float sky = d>MAX_DIST?0.:1.;\n    \n    vec3 p = ro + rd*d;\n    \n    vec3 ambient = vec3(.001);\n    \n    vec3 albedo = vec3(0.6);\n    \n    vec3 normal = GetNormal(p);\n    \n    vec3 light1 = vec3(0., 5., 6.);\n    //light1.xz += vec2(sin(iTime*2.), cos(iTime*2.)*2.);\n    vec3 dif = \n        GetLight(p, light1, vec3(.9, .4, .4), albedo, normal, rd)+\n        GetLight(p, vec3(9., -2., -3.), vec3(.4, .9, .4), albedo, normal, rd);\n    \n    vec3 col = dif*sky;\n    col *= getAo(p, normal, 0.5)*\n    getAo(p, normal, .9);\n    col += ambient;\n    \n    // Output to screen\n    fragColor = vec4(pow(col, vec3(.454545)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}","name":"Common","description":"","type":"common"}]}