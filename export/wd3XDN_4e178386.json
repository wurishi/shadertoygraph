{"ver":"0.1","info":{"id":"wd3XDN","date":"1572035549","viewed":484,"name":"blackle noise","username":"blackle","description":"a very small noise function that works on all scales. use the mouse to explore the space of floats, or just sit back and watch the show. the black boundaries represent every 2^8 steps","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n/// blackle noise ////////////////////////\n\n#define NO_COS 0\n#define SHOW_INTEGERS 0 //round to closest int\n#define SHOW_BOUNDARY 1 //show 2^8 boundaries\n#define SHOW_EXPONENT 1 //show exponent text\n\n//returns random number in range (-1, 1)\n#if NO_COS == 1\n#define FKS(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\n#else\n#define FKS(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\n#endif\nfloat noise_signed(vec2 p) {\n    int x = FKS(p.x); int y = FKS(p.y);\n    return float((x-y*y)*(x*x+y)-x)/2.14e9;\n}\n\n//returns random number in range (0, 1)\n#if NO_COS == 1\n#define FKU(k) floatBitsToUint(k*k/7.)^floatBitsToUint(k)\n#else\n#define FKU(k) floatBitsToUint(cos(k))^floatBitsToUint(k)\n#endif\nfloat noise_unsigned(vec2 p) {\n    uint x = FKU(p.x); uint y = FKU(p.y);\n    return float((x-y*y)*(x*x+y)-x)/4.28e9;\n}\n\n//////////////////////////////////////////\n//adapted from https://www.shadertoy.com/view/llySRh\nfloat char(vec2 p, int c) {\n    if (p.x < .0 || p.x > 1. || p.y < 0. || p.y > 1.) return 1.;\n\treturn texture( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ) ).w;\n}\n\nfloat pInt3(vec2 p, float n) {\n    float dist = 1.;\n    for (int k = 0; k < 3; k++ ) {\n        dist = min(dist, char(p, 48+int(abs(n)/pow(10.,float(k)))%10 ));\n    \tp.x += 0.5;\n    }\n    if (n < 0.) {\n        dist = min(dist, char(p, 45 ));\n        p.x+=0.5;\n        n = abs(n);\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    float control = -asin(sin(iTime*0.05))*2./3.1415;\n    if (iMouse.z > 0.) {\n        control = iMouse.x/iResolution.x*2.0-1.;\n    }\n    float exponent = control*128.;\n    float scaling = pow(2.,exponent);\n    vec2 uv_scaled = uv * scaling;\n\n#if SHOW_INTEGERS\n    uv_scaled = floor(uv_scaled);\n#endif\n    \n    vec4 color = vec4(noise_unsigned(uv_scaled));\n\n#if SHOW_BOUNDARY == 1\n    vec2 boundary = fract(log2(abs(uv_scaled))/4.);\n    float border = min(boundary.x,boundary.y);\n    if (border < 0.1) {\n        color *= sqrt(border/0.1);\n    }\n#endif\n#if SHOW_EXPONENT == 1\n    float chars = min(char((uv+vec2(0.51,-0.18))*6.,50), pInt3((uv+vec2(0.3,-0.3))*10., exponent));\n    color = mix(color, vec4(1.), smoothstep(0.54, 0.52, chars));\n    color = mix(color, vec4(0.), smoothstep(0.5, 0.48, chars));\n#endif\n    \n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}