{"ver":"0.1","info":{"id":"stSfz3","date":"1652490921","viewed":131,"name":"SIGGRAPH logo + displacement","username":"YutingYang","description":"SIGGRAPH logo's original appearance combined with iq's displacement mapping.\nShader program modified from iq's Siggraph logo:\nhttps://www.shadertoy.com/view/4sl3zn\nShader parameters obtained from Adelta framework:\nhttps://github.com/yyuting/Adelta","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["siggraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original logo:\n// https://www.siggraph.org/wp-content/uploads/2012/12/org.blend_.logo_.400.jpg\n\n// Shader program modified from \n// https://www.shadertoy.com/view/4sl3zn\n\n// Shader parameters obtained using the Adelta framework\n// https://github.com/yyuting/Adelta\n\n#define width 960.\n#define height 960.\n\nfloat scale_factor = 0.75;\n\n#define X float[](0.00022939883414545628, 0.0013158739453209168, 1.7412918400334945, 3.1403172141405835, -0.0006776883589170329, -0.05811079923855922, -0.521023225486668, 0.3629700069657715, 0.778027805999117, 0.09237181293763315, 0.1896124060972987, 0.40082541310417724, 0.21419339759324016, 0.13357801941251107, 1.0154413628865833, 4.025294144089588, 0.24758415680434528, 4.522246978434377, 0.6023132550832381, -0.21305110772047975, 0.25847523294276414, 0.7149938093807081, 1.6202299236332116, 0.358129926327441, 0.6738735278035585, 0.6622164020419822, 0.06125827187375278, 0.18980000886962817, 0.11704332846913305, 0.4146742728126009, 0.6713630506348166, 0.22341611902167888, 0.6536873227977258, 0.4153864248395166, 0.5314575862888066, 0.31472424399062093, 0.18982871259224407, 0.176536913859384, 0.5275433740926194, 0.32886559529747195, 0.7531990573433882, 0.46108306473061345, 0.27372275226946413)\n\n\n#define ro_x_idx 0\nfloat ro_x = X[ro_x_idx];\n\n#define ro_y_idx 1\nfloat ro_y = X[ro_y_idx];\n\n#define ro_z_idx 2\nfloat ro_z = X[ro_z_idx];\n\n#define ang_x_idx 3\nfloat ang_x = X[ang_x_idx];\n\n#define ang_y_idx 4\nfloat ang_y = X[ang_y_idx];\n\n#define ang_z_idx 5\nfloat ang_z = X[ang_z_idx];\n\n#define ax_ang_x_idx 6\nfloat ax_ang_x = X[ax_ang_x_idx];\n\n#define ax_ang_y_idx 7\nfloat ax_ang_y = X[ax_ang_y_idx];\n\n#define cone_ang_x_idx 8\nfloat cone_ang_x = X[cone_ang_x_idx];\n\n#define cone_ang_y_idx 9\nfloat cone_ang_y = X[cone_ang_y_idx];\n\n#define cone_ang_z_idx 10\nfloat cone_ang_z = X[cone_ang_z_idx];\n\n#define ellipse_ratio_idx 11\nfloat ellipse_ratio = X[ellipse_ratio_idx];\n\n#define cone_ang_w_idx 12\nfloat cone_ang_w = X[cone_ang_w_idx];\n\n#define d_thre_x_idx 13\nfloat d_thre_x = X[d_thre_x_idx];\n\n#define d_thre_y_idx 14\nfloat d_thre_y = X[d_thre_y_idx];\n\n#define angs_lig0_x_x_idx 15\nfloat angs_lig0_x_x = X[angs_lig0_x_x_idx];\n\n#define angs_lig0_x_y_idx 16\nfloat angs_lig0_x_y = X[angs_lig0_x_y_idx];\n\n#define angs_lig0_y_x_idx 17\nfloat angs_lig0_y_x = X[angs_lig0_y_x_idx];\n\n#define angs_lig0_y_y_idx 18\nfloat angs_lig0_y_y = X[angs_lig0_y_y_idx];\n\n#define pos_lig1_x_x_idx 19\nfloat pos_lig1_x_x = X[pos_lig1_x_x_idx];\n\n#define pos_lig1_x_y_idx 20\nfloat pos_lig1_x_y = X[pos_lig1_x_y_idx];\n\n#define pos_lig1_x_z_idx 21\nfloat pos_lig1_x_z = X[pos_lig1_x_z_idx];\n\n#define pos_lig1_y_x_idx 22\nfloat pos_lig1_y_x = X[pos_lig1_y_x_idx];\n\n#define pos_lig1_y_y_idx 23\nfloat pos_lig1_y_y = X[pos_lig1_y_y_idx];\n\n#define pos_lig1_y_z_idx 24\nfloat pos_lig1_y_z = X[pos_lig1_y_z_idx];\n\n#define amb_x_x_idx 25\nfloat amb_x_x = X[amb_x_x_idx];\n\n#define amb_x_y_idx 26\nfloat amb_x_y = X[amb_x_y_idx];\n\n#define amb_x_z_idx 27\nfloat amb_x_z = X[amb_x_z_idx];\n\n#define amb_y_x_idx 28\nfloat amb_y_x = X[amb_y_x_idx];\n\n#define amb_y_y_idx 29\nfloat amb_y_y = X[amb_y_y_idx];\n\n#define amb_y_z_idx 30\nfloat amb_y_z = X[amb_y_z_idx];\n\n#define kd0_x_x_idx 31\nfloat kd0_x_x = X[kd0_x_x_idx];\n\n#define kd0_x_y_idx 32\nfloat kd0_x_y = X[kd0_x_y_idx];\n\n#define kd0_x_z_idx 33\nfloat kd0_x_z = X[kd0_x_z_idx];\n\n#define kd0_y_x_idx 34\nfloat kd0_y_x = X[kd0_y_x_idx];\n\n#define kd0_y_y_idx 35\nfloat kd0_y_y = X[kd0_y_y_idx];\n\n#define kd0_y_z_idx 36\nfloat kd0_y_z = X[kd0_y_z_idx];\n\n#define kd1_x_x_idx 37\nfloat kd1_x_x = X[kd1_x_x_idx];\n\n#define kd1_x_y_idx 38\nfloat kd1_x_y = X[kd1_x_y_idx];\n\n#define kd1_x_z_idx 39\nfloat kd1_x_z = X[kd1_x_z_idx];\n\n#define kd1_y_x_idx 40\nfloat kd1_y_x = X[kd1_y_x_idx];\n\n#define kd1_y_y_idx 41\nfloat kd1_y_y = X[kd1_y_y_idx];\n\n#define kd1_y_z_idx 42\nfloat kd1_y_z = X[kd1_y_z_idx];\n\nvec3 ro = vec3(X[0], X[1], X[2]);\n\nvec2 disp( in vec3 p )\n{\n    float time = iTime - 3.14;\n    \n    // time for paper\n    //time = 0.;\n    \n\n\treturn vec2( pow( 0.5 + 0.5*cos( 1.0*time ), 2.0 ),\n                 pow( 0.5 + 0.5*cos( 25.0*p.x  + 1.5*time)*\n\t\t\t\t\t            sin( 25.0*p.y  + 2.0*time )*\n\t\t\t\t\t            sin( 25.0*p.z  + 1.0*time ), 3.0) );\n}\n\nfloat obj( in vec3 p, in vec3 scale)\n{\n    \n    vec3 ax = vec3(sin(ax_ang_x) * cos(ax_ang_y), cos(ax_ang_x) * cos(ax_ang_y), sin(ax_ang_y));\n\n\tfloat d1 = dot(p * scale,ax) - d_thre_x;\n    float d2 = length(p) - d_thre_y;\n    float d3;\n    \n    float cone_theta = cone_ang_x;\n    float cone_phi = cone_ang_y;\n    float cone_alpha = cone_ang_z;\n    \n    vec3 q = (p - ro) * scale;\n    \n    float q0 = dot(vec3(sin(cone_theta) * sin(cone_phi),\n                        cos(cone_theta) * sin(cone_phi),\n                        cos(cone_phi)),\n                   q);\n                   \n    float q1 = dot(vec3(sin(cone_theta) * cos(cone_phi),\n                        cos(cone_theta) * cos(cone_phi),\n                        -sin(cone_phi)),\n                   q);\n    float q2 = dot(vec3(-cos(cone_theta), sin(cone_theta), 0.), q);\n    \n    float ellipse_ratio = ellipse_ratio;\n    \n    float r1 = q1 * cos(cone_alpha) + q2 * sin(cone_alpha);\n    float r2 = q1 * sin(cone_alpha) + q2 * cos(cone_alpha);\n\n    \n    float scaled_dist = length(vec2(r1 * ellipse_ratio, r2));\n    \n    \n    float ang = cone_ang_w;\n    \n    d3 = dot(vec2(cos(ang), sin(ang)), vec2(scaled_dist, q0));\n        \n    float t = max(d1, d2);\n    \n    return max(-d3, t);\n}\n\nvec2 map( in vec3 p )\n{\n\tfloat d1 = obj( p, vec3(1.) );\n\tfloat d2 = obj( p, vec3(-1.0,-1.0,1.0) );\n\n    vec2        res = vec2( d1, 0.0 );\n\tif( d2<d1 ) res = vec2( d2, 1.0 );\n\n\tvec2 di = disp( p );\n\tres.x -= 0.04*di.x*di.y;\n\n\treturn res;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat t = 0.0;\n\tvec2 h = vec2( -1.0 );\n    for( int i=0; i<64; i++ )\n    {\n        h = map(ro+rd*t);\n\t\tt += h.x;\n\t}\n\t\n\tif( h.x < 0.004 * t ) return vec2(t,h.y);\n\n\treturn vec2(-1.0);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    float current_u;\n    float current_v;\n    \n    float max_scale = max(width / iResolution.x, height / iResolution.y) * scale_factor;\n\n    vec2 padding = (vec2(width, height) - max_scale * iResolution.xy) / 2.;\n\n    current_u = fragCoord.x * max_scale + padding.x;\n    current_v = fragCoord.y * max_scale + padding.y;\n    \n    fragCoord.x = current_u;\n    fragCoord.y = current_v;\n\n    vec3 ray_dir;\n        \n    ray_dir.x = fragCoord.x - width * 0.5;\n    ray_dir.y = fragCoord.y - height * 0.5;\n    ray_dir.z = 1. * width * 0.5;\n    ray_dir = normalize(ray_dir);\n    ray_dir.y *= -1.0;\n    //ray_dir.x *= -1.0;\n\n    float ang1 = ang_x;\n    float ang2 = ang_y;\n    float ang3 = ang_z;\n\n    float sin1 = sin(ang1);\n    float cos1 = cos(ang1);\n    float sin2 = sin(ang2);\n    float cos2 = cos(ang2);\n    float sin3 = sin(ang3);\n    float cos3 = cos(ang3);\n\n    vec3 ray_dir_p;\n    ray_dir_p.x = cos2 * cos3 * ray_dir.x + (-cos1 * sin3 + sin1 * sin2 * cos3) * ray_dir.y + (sin1 * sin3 + cos1 * sin2 * cos3) * ray_dir.z;\n    ray_dir_p.y = cos2 * sin3 * ray_dir.x + (cos1 * cos3 + sin1 * sin2 * sin3) * ray_dir.y + (-sin1 * cos3 + cos1 * sin2 * sin3) * ray_dir.z;\n    ray_dir_p.z = -sin2 * ray_dir.x + sin1 * cos2 * ray_dir.y + cos1 * cos2 * ray_dir.z;\n\n\n    vec3 rd = ray_dir_p;\n\n    vec3 col = vec3(1.0);\n\n\t// raymarch\n    vec2 tmat = intersect(ro,rd);\n    if( tmat.y>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd,nor);\n\t\tvec2 dis = disp( pos );\n        \n        vec3 amb_x = vec3(amb_x_x, amb_x_y, amb_x_z);\n        vec3 amb_y = vec3(amb_y_x, amb_y_y, amb_y_z);\n        \n        \n        vec3 dir_lig0_x = vec3(sin(angs_lig0_x_x) * cos(angs_lig0_x_y), cos(angs_lig0_x_x) * cos(angs_lig0_x_y), sin(angs_lig0_x_y));\n        vec3 dir_lig0_y = vec3(sin(angs_lig0_y_x) * cos(angs_lig0_y_y), cos(angs_lig0_y_x) * cos(angs_lig0_y_y), cos(angs_lig0_y_y));\n        \n        //vec3 dir_lig0_x = normalize(vec3(0.6,-0.5,0.2));\n        //vec3 dir_lig0_y = normalize(vec3(-0.6,-0.5,0.2));\n        \n        vec3 kd0_x = vec3(kd0_x_x, kd0_x_y, kd0_x_z);\n        vec3 kd0_y = vec3(kd0_y_x, kd0_y_y, kd0_y_z);\n\n        vec3 dif0_x = max(dot(nor, dir_lig0_x), 0.0) * kd0_x;\n        vec3 dif0_y = max(dot(nor, dir_lig0_y), 0.0) * kd0_y;\n        \n        // point light 1\n        vec3 pos_lig1_x = vec3(pos_lig1_x_x, pos_lig1_x_y, pos_lig1_x_z);\n        vec3 pos_lig1_y = vec3(pos_lig1_y_x, pos_lig1_y_y, pos_lig1_y_z);\n        \n        vec3 kd1_x = vec3(kd1_x_x, kd1_x_y, kd1_x_z);\n        vec3 kd1_y = vec3(kd1_y_x, kd1_y_y, kd1_y_z);\n        \n        vec3 dir_lig1_x = -normalize(pos - pos_lig1_x);\n        vec3 dir_lig1_y = -normalize(pos - pos_lig1_y);\n        \n        vec3 dif1_x = max(dot(nor, dir_lig1_x), 0.0) * kd1_x;\n        vec3 dif1_y = max(dot(nor, dir_lig1_y), 0.0) * kd1_y;\n        \n        vec3 col_x = amb_x + dif0_x + dif1_x;\n        vec3 col_y = amb_y + dif0_y + dif1_y;\n        \n        if (tmat.y == 0.) col = col_x;\n        else col = col_y;\n        \n        float rim = pow(1.0+dot(nor,rd),50.0);\n        col += 1.00*rim*vec3(1.0);\n        \n     \n     /*\n        // lights\n        float con = 1.0;\n        float amb = 0.5 + 0.5*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lig.x,lig.y,-lig.z)),0.0);\n        float rim = pow(1.0+dot(nor,rd),8.0);\n        float spe = pow(clamp(dot(lig,ref),0.0,1.0),8.0);\n        float occ = mix( 1.0, 0.9 + 3.0*dis.y, dis.x );\n\n\t\t// shadow\n\t\tfloat sh = softshadow( pos, lig, 0.01, 8.0 );\n\t\tdif *= sh;\n\t\tspe *= sh;\n\t\trim *= sh;\n\t\t\n        col  = 0.10*con*vec3(1.0)*occ;\n        col += 1.00*dif*vec3(1.0,0.8,0.6);\n        col += 0.40*bac*vec3(1.0)*occ;\n        col += 0.25*amb*vec3(0.6,0.8,1.0)*occ;\n\n        // material\n\t\tcol *= mix( vec3(0.7,0.1,0.1), vec3(0.0,0.2,1.0), tmat.y );\n\t\t\n\t\t// speculars\n        col += 0.50*spe*vec3(1.0);\n\t\tcol += 1.00*rim*vec3(1.0);\n\t\t\t\n        // gamma\n        col = sqrt(col); */\n    }\n\n\n    fragColor = vec4( col,1.0 );\n}","name":"Image","description":"","type":"image"}]}