{"ver":"0.1","info":{"id":"tsXGzN","date":"1545158672","viewed":386,"name":"Canyon surveyor","username":"mensab","description":"Playing around with basic FBM deformation, might artifact on some machines.\n\nThe artifacting itself is neat but I can't seem to reproduce it on higher end machines, unless there's some way in GLSL to screw with floats on bit level that I don't know about.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","terrain","parallax"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define OFFSET vec2(cos(iTime * .25) + 2. * sin(.1 * iTime), sin(iTime * .25) + 2. * cos(.167 * iTime))\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(vec2(p.x, p.y), vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n//  smoothed noise\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    float c00 = rand(ip);\n    float c01 = rand(ip + vec2(1., 0.));\n    float c10 = rand(ip + vec2(0., 1.));\n    float c11 = rand(ip + vec2(1.));\n    \n    vec2 fp = fract(p);\n    vec2 uf = smoothstep(vec2(0.), vec2(1.), fp);\n    float r0 = mix(c00, c01, uf.x);\n    float r1 = mix(c10, c11, uf.x);\n    return mix(r0, r1, uf.y);\n}\n\nfloat fbm (vec2 p) {\n    int iters = 10;\n    \n    float value = 0.;\n    float freq = 1.;\n    float amp = .5;\n    \n    float gain = .5;\n    float rescale = 2.;\n    \n    for (int i = 0; i < iters; i++) {\n        value += amp * noise(p * freq);\n        freq *= rescale;\n        amp *= gain;\n    }\n    \n    return value;\n}\n\nfloat terrain(vec2 p) {\n    //  stack+deform FBMs\n    vec2 q = vec2(fbm(p), fbm(p + vec2(.1, -.1)));\n    vec2 r = vec2(fbm(p + 4. * q * vec2(2., 1.)), fbm(p + 4. * q + vec2(-5., -3.)));\n    return fbm(p + 4. * r);\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.2831853 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //  circle around\n    uv += OFFSET;\n\n    //  flatness\n    float z = .2;\n    //  estimate normals\n    vec2 e = 1. / vec2(max(iResolution.x, iResolution.y));\n    float r = terrain(uv + vec2(e.x, 0.));\n    float l = terrain(uv - vec2(e.x, 0.));\n    float b = terrain(uv + vec2(0., e.y));\n    float t = terrain(uv - vec2(0., e.y));\n    vec3 n = normalize(vec3(r - l, t - b, z));\n    \n    //  lighting\n    vec3 ld = normalize(vec3(1.));\n    float i = dot(n, ld);\n    \n    //  terrain color\n    float h = terrain(uv);\n    vec3 c = palette(h, vec3(.9, .6, 1.), vec3(1., .9, .75), vec3(.5), vec3(.57, .53, .4));\n    c = mix(vec3(h), c, h * 1.33);\n    \n    //  clouds (+parallax)\n    float clouds = fbm((uv + vec2(1.)) * 6. + .5 * OFFSET);\n    clouds = clamp(pow(clouds + .2, 10.), 0., 1.);\n    \n    fragColor = vec4(mix(i * c + clouds * .75, vec3(1.), clouds), 1.);\n}","name":"Image","description":"","type":"image"}]}