{"ver":"0.1","info":{"id":"tdlyW2","date":"1605018335","viewed":82,"name":"Dots with mask","username":"nicolaecodreanu","description":"Dots","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fbm","dots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat variation(vec2 v1, vec2 v2, float strength, float speed) {\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.0;\n}\n\nvec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n    \n    vec2 diff = center-uv;\n    float len = length(diff);\n\n    len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n    len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n    \n    float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n    return vec3(circle);\n}\n\nfloat random(vec2 p) { \n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float bottomOfGrid = mix(random(i + vec2(0.0, 0.0)), random(i + vec2(1.0, 0.0)), f.x);\n    float topOfGrid = mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), f.x);\n    float t = mix(bottomOfGrid, topOfGrid, f.y);\n    return t;\n}\n\nfloat fbm(vec2 uv) {\n    float sum = 0.00;\n    float amp = 1.0;\n    for(int i = 0; i < 1; ++i) {\n        sum += valueNoise(uv) * amp;\n        uv += uv * 1.2;\n        amp *= 0.1;\n    }\n    return sum;\n}\n\nfloat hash( in vec2 p )  // replace this by something better\n{\n    p = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n// return value noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n   \n    \n    float va = hash( i + vec2(0.0,0.0) );\n    float vb = hash( i + vec2(1.0,0.0) );\n    float vc = hash( i + vec2(0.0,1.0) );\n    float vd = hash( i + vec2(1.0,1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return vec3( va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y, // value\n                 du*(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va) );     // derivative                \n}\n\nfloat sdCircle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat variation1(vec2 v1, vec2 v2, float strength, float speed) \n{\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float px = 2.0 / iResolution.y;\n    uv *= 20.0;\n    vec2 id = floor(uv);\n    vec2 p = step(0.05, mod(uv.xy, 0.055));\n    p = step(0.8, mod(uv.xy, 0.9));\n    float f = fbm(uv + iTime * 1.0);\n    vec3 n = noised(uv + iTime * 0.3);\n    vec3 col = vec3(0.0);\n    //col = mix(col, vec3(0.0, 0.7, 1.0), p.x * p.y * f);\n    col = mix(col, vec3(0.0, 0.7, 1.0), p.x * p.y * dot(n.x, n.x));\n    \n    vec2 UV = (fragCoord - 0.5 * iResolution.xy) / iResolution.xy;\n    float d = sdCircle(UV, 0.55);\n    d -= variation1(UV, vec2(1.0, 0.0), 5.0, 3.0);\n    float mask = smoothstep(-0.2, 0.0, d);\n    //col = mix(col, vec3(1.0), mask);\n    col *= mask;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}