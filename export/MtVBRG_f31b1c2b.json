{"ver":"0.1","info":{"id":"MtVBRG","date":"1543019082","viewed":230,"name":"Orbit Trapped","username":"belfry","description":"Playing with orbit traps for colouring.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["orbittraps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define reflections 2.\n#define optimized 0\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 a = abs(p) - b;\n    return max(a.x, max(a.y, a.z));\n}\n\nvec4 sdf(vec3 p) {\n    vec3 o = vec3(1000000.);\n    for (float i = 0.; i < 8.; i++) {\n        p -= vec3(1.83, 2.21, 1.916);\n        float a = 0.8 + sin(cos(p.x + p.y) + p.z) * .23;\n        p.xy *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        p = abs(p);\n        a = 0.214;\n        p.yz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        p -= vec3(-.52, .6, -.23);\n        a = -0.21;\n        p.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        \n        vec3 d = p - vec3(cos(iTime * .07), sin(iTime * .15), 1.) * 2.;\n        vec2 d1 = p.xz;\n        o = min(o, vec3(dot(d, d), dot(d1, d1), p.z));\n    }\n    p -= vec3(1., 2., 3.);\n    return vec4(max(sphere(p, 2.3085), -box(p, vec3(.5, 1.15, 3.9))), o*vec3(.1, .1, .5));\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(.05, 0.);\n    float dx = sdf(p + eps.xyy).x - sdf(p - eps.xyy).x;\n    float dy = sdf(p + eps.yxy).x - sdf(p - eps.yxy).x;\n    float dz = sdf(p + eps.yyx).x - sdf(p - eps.yyx).x;\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n, float dist, float steps) {\n    float ao = 0.;\n    for (float i = 1.; i <= steps; i++) {\n        ao += sdf(p + n * (i / steps * dist)).x;\n    }\n    return clamp(ao / steps, 0., 1.);\n}\n\nfloat translucency(vec3 p, vec3 n, float dist, float steps) {\n    float ao = 0.;\n    for (float i = 1.; i <= steps; i++) {\n        ao += sdf(p - n * (i / steps * dist)).x;\n    }\n    return clamp(ao / steps, 0., 1.);\n}\n\nvec3 draw(vec3 pos, vec3 n, float i, float t, vec3 dir, vec3 o) {\n    vec3 lightDir = normalize(vec3(1.));\n    float diffuse = max(0., dot(lightDir, n)) * .4;\n    float specular = pow(max(0., dot(normalize(lightDir + dir), n)), 16.) * .25;\n    float rim = pow(1. - abs(dot(n, dir)), 5.) * .3;\n    vec3 lightColor = vec3(.9, .85, .7);\n    float ao = ambientOcclusion(pos, n, 0.25, 5.);\n    float trans = translucency(pos, n, .4, 3.)*0.25;\n    vec3 lighting = (ao + diffuse) * lightColor \n        + (rim + specular) * vec3(0.3, 0.4,.7)\n        + trans * vec3(0.9, .4, .4);\n    return o * lighting + vec3(i / 500., t / 50., i / 500.);\n}\n\n#if optimized\nbool trace(vec3 camPos, vec3 dir, out vec3 pos, out float i, out float t, out vec3 o) {\n    pos = vec3(0.);\n    float eps = .005;\n    i = 0.;\n    t = 0.;\n    bool hit = false;\n    vec4 d;\n    for (; i < 300.; i++) {\n        pos = camPos + t * dir;\n\t\td = sdf(pos);\n        if (abs(d.x) < eps * t) {\n            hit = true;\n            break;\n        }\n        t += d.x * .09;\n        if (t > 300.)\n            break;\n    }\n    o = d.yzw;\n    return true;\n}\n#else\nbool trace(vec3 camPos, vec3 dir, out vec3 pos, out float i, out float t, out vec3 o) {\n    pos = vec3(0.);\n    float eps = .005;\n    i = 0.;\n    t = 0.;\n    bool hit = false;\n    vec4 d;\n    for (; i < 1000.; i++) {\n        pos = camPos + t * dir;\n\t\td = sdf(pos);\n        if (abs(d.x) < eps * t) {\n            hit = true;\n            break;\n        }\n        t += d.x * .09;\n        if (t > 300.)\n            break;\n    }\n    o = d.yzw;\n    return hit;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelPos = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float fov = radians(60.);\n    vec3 dir = normalize(vec3(pixelPos, 1. / tan(.5 * fov)));\n    \n    float a = iTime * .1;\n    dir.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    vec3 camPos = vec3(3., -4., -11.);\n    \n    \n    float i, t;\n    vec3 pos, o;\n    bool hit = trace(camPos, dir, pos, i, t, o);\n    vec3 n = normal(pos);\n    \n    vec3 col = vec3(0.);\n    if (hit) {\n        col = draw(pos, n, i, t, -dir, o);\n        \n        for (float j = 1.; j <= reflections; j++) {\n            dir = reflect(dir, n);\n            hit = trace(camPos, dir, pos, i, t, o);\n            n = normal(pos);\n            vec3 reflCol = draw(pos, n, i, t, -dir, o);\n\n            col = mix(col, reflCol, .1 / j);\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}