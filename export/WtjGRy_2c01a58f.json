{"ver":"0.1","info":{"id":"WtjGRy","date":"1560031149","viewed":102,"name":"Global Simple Volumetrics","username":"elementbound","description":"Volumetrics","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEG2RAD 0.01745329251994329576923690768489\n#define PI 3.1415926535897932384626433832795\n\n#define RANDOMIZED_SAMPLE_DST 1\n\n#define SHAPE_GRID 1\n#define SHAPE_SQUARE 0\n\nconst int SAMPLE_COUNT = 128;\nconst float SAMPLE_BIAS = 1.0;\nconst float SAMPLE_DISTANCE = 64.0;\n\n    \nstruct camera_t {\n\tvec3 from; \n\tvec3 to;\n\tvec3 up;\n};\n    \nstruct light_t {\n    vec3 pos;\n    vec3 color;\n    float energy;\n};\n    \ncamera_t camera;\nlight_t light;\n\n// Based on: \n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml\nmat4 lookAt(vec3 from, vec3 to, vec3 up) {\n    up = normalize(up);\n    \n    vec3 forward = to - from;\n    forward = normalize(forward);\n    \n    vec3 side = normalize(cross(forward, up));\n    up = cross(side, forward); \n    up = normalize(up);\n    \n    return mat4(vec4(side, 0.0), vec4(up, 0.0), vec4(forward, 0.0), vec4(0.,0.,0.,1.));\n}\n\nvec3 yawroll(float yaw, float roll) {\n    float d = cos(roll);\n    return vec3(cos(yaw)*d, sin(roll), sin(yaw)*d);\n}\n\n\nmat4 getView(in camera_t camera) {\n    return lookAt(camera.from, camera.to, camera.up);\n}\n\nbool isFloorHit(vec3 from, vec3 ray, out vec3 planeHit) {\n    if(ray.y * from.y < 0.0) {\n        vec3 planeRay = ray / ray.y;\n        planeHit = from - planeRay * from.y;\n\n        #if SHAPE_GRID\n        \treturn mod(planeHit.z / 0.2, 1.0) > 0.5 || mod(planeHit.x, 1.0) < 0.1;\n        #elif SHAPE_SQUARE\n            vec2 planeUv = planeHit.xz;\n\n            return (planeUv == clamp(planeUv, vec2(-1), vec2(1))) && max(abs(planeUv.x), abs(planeUv.y)) > 0.8;\n        #endif\n    }\n}\n\nbool isPointVisibleFrom(vec3 from, vec3 point) {\n    vec3 ray = normalize(point - from);\n    vec3 planeHit;\n    \n    if(isFloorHit(from, ray, planeHit)) {\n        if(distance(planeHit, from) > distance(planeHit, point)) {\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        return true;\n    }\n}\n\nvoid setupCamera(float time) {\n    float yaw = time / 15.0;\n    float roll = (1.0 + sin(mod(time / 30.0, 1.0) * 2.0 * PI)) / 2.0;\n    roll = mix(-30.0f, 60.0f, roll) * DEG2RAD;\n    \n    camera.from = yawroll(yaw, roll) * 2.0;\n    camera.to = vec3(0.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n}\n\nvoid setupLight(float time) {\n    float yaw = (time * 90.0f) * DEG2RAD;\n    float roll = -45.0f * DEG2RAD;\n    \n    light.pos = yawroll(yaw, roll) * 4.0;\n    light.color = vec3(1.0, 0.7, 0.0);\n    light.energy = ((2.0 + sin(time)) / 3.0) * 8.0;\n}\n\nfloat evaluateLightDistanceFactor(vec3 pos, light_t light) {\n    return light.energy / (1.0 + distance(pos, light.pos));\n}\n\n\nvec3 evaluateLight(vec3 pos, vec3 normal, light_t light) {\n    vec3 outgoing = normalize(light.pos - pos);\n    float dirFactor = dot(outgoing, normal);\n    dirFactor = abs(dirFactor);\n    \n    float distanceFactor = evaluateLightDistanceFactor(pos, light);\n    \n    return light.color * dirFactor * distanceFactor;\n}\n\n\nvec4 evaluateMist(vec3 pos) {\n    float mistAlpha = 0.8;\n    vec3 mistColor = vec3(0.8);\n    \n    if(isPointVisibleFrom(pos, light.pos)) {\n        mistColor *= evaluateLightDistanceFactor(pos, light) * light.color;\n    } else {\n        mistColor = vec3(0.0);\n        mistAlpha = 0.0;\n    }\n    \n    return vec4(mistColor, mistAlpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    const float fov = 120.0f * DEG2RAD;\n    const float znear = 1.0 / tan(fov / 2.0f);\n    \n    setupCamera(iTime);\n    setupLight(iTime);\n    mat4 view = getView(camera);\n    \n    // Ray\n    vec3 ray = normalize(vec3(uv, znear));\n    ray = normalize((view * vec4(ray, 1.0)).xyz);\n    \n    fragColor = texture(iChannel0, ray);\n    \n    // Check collision with ground plane\n    vec3 planeHit;\n    if(isFloorHit(camera.from, ray, planeHit)) {\n        float dirFactor = normalize(light.pos - planeHit).z;\n        dirFactor = (1.0 + dirFactor) / 0.5;\n        float illumFactor = light.energy / (1.0 + distance(light.pos, planeHit));\n\n        fragColor = texture(iChannel1, planeHit.xz) * vec4(evaluateLight(planeHit, vec3(0,1,0), light), 1.0);\n    }\n    \n    // Sample mist\n    vec4 mistColor = vec4(0);\n    for(int i = 0; i < SAMPLE_COUNT; i++) {\n        float distanceFactor = float(i) / float(SAMPLE_COUNT);\n        distanceFactor = pow(distanceFactor, SAMPLE_BIAS);\n        \n        #if RANDOMIZED_SAMPLE_DST\n        \tfloat nextDistanceFactor = float(i + 1) / float(SAMPLE_COUNT);\n        \tnextDistanceFactor = pow(nextDistanceFactor, SAMPLE_BIAS);\n        \n        \tfloat randomFactor = random(vec3(uv, iTime));\n        \tfloat sampleDistance = mix(0.0, SAMPLE_DISTANCE, mix(distanceFactor, nextDistanceFactor, randomFactor));\n        #else\n        \tfloat sampleDistance = mix(0.0, SAMPLE_DISTANCE, distanceFactor);\n        #endif\n        \n        vec3 sampleAt = camera.from + ray * sampleDistance;\n        \n        if(isPointVisibleFrom(camera.from, sampleAt)) {\n        \tvec4 mistSample = evaluateMist(sampleAt); \n        \tmistColor += mistSample;\n        }\n    }\n    mistColor /= float(SAMPLE_COUNT);\n    \n    fragColor = mix(fragColor, mistColor, mistColor.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Source:\n// https://stackoverflow.com/a/17479300\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }","name":"Common","description":"","type":"common"}]}