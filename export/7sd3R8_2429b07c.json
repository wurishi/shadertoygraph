{"ver":"0.1","info":{"id":"7sd3R8","date":"1629174439","viewed":53,"name":"Triangle Intersection + BaryC","username":"Yusef28","description":"From: [url]https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle[/url]\nAnd also peeked at envy24 https://www.shadertoy.com/view/7tsXzX\nI think I might be missing something though.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["triangle","intersection","barycentric"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 17-08-2021                                  //\n// Status: Incomplete, missing something in           //\n// Topic: Triangle Intersection and Barycentric Coords     //\n// Sources: https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle\n// Listening to:Best post-rock songs of 2020               //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n\n#define Samples 20.\n#define bounces 1.\n\n#define pi 3.14159\n\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 n, vec3 pop){\n\n    //first of all, if the dot of the rd and n is ... nvm\n    //if(dot(rd,n) > 0.9999) return -1.;\n    //dot(vector in plane with normal) = zero (orthogonal)\n    //(p-pointinplane)*n = 0\n    \n    //ray origin + rd at time t is point\n    //p = ro + rd*t;\n    \n    //what time t is p from eq 1 = p in eq 2\n    //(ro + rd*t - pointinplane)*n = 0\n    \n    //rearange to get some time alone\n    //float t = (dot(pop,n) - dot(ro,n)) / dot(rd,n);\n    \n    //we can do better than that, factor out n from top \n    return dot(pop-ro,n) / dot(rd,n);\n}\n\n\nvec3 iTriangle(vec3 ro,vec3 rd,vec3 A,vec3 B,vec3 C){\n\n    float t;\n    vec2 uv;\n    \n    //if there isn't a hit we give backa  t of -1., \n    //and a u and v of 0.,0.\n    \n    vec3 no_hit = vec3(-1.,0.,0.);\n    \n    //imagine a triagle with 3 points.\n    //the vector from point a to b\n    vec3 AzuB = normalize(B-A);\n    \n    //from point b to c\n    vec3 BzuC = normalize(C-B);\n    \n    //usw\n    vec3 CzuA = normalize(A-C);\n    \n    \n    //we use the cross of two of the above vectors\n    //to get a vector perpendicular to both\n    //any two of these holds all three points (a,b,and c)\n    //so the normal of them is the normal of the plane all three\n    //points lie in\n    vec3 planeN = cross(AzuB,BzuC);\n    \n    //so we find the intersection of that plane\n    t = iPlane(ro,rd,planeN,A);\n    \n    //and get the hit point\n    vec3 point_on_plane = ro + rd*t;\n    \n    //and return no hit if the t negative meaning it's behind us\n    if(t < 0.)\n        return no_hit;\n    \n    //then we are using each of the above 3 vectors AND a vector\n    //from that vectors starting point to our hit poing\n    //so if we go with A to B, we also use A to hit point\n    //and what we do is get the cross of those two\n    //because a cross product is also an area of a paralellagram\n    //with the triangle from those two  vectors and the mirror of\n    //that triangle. It's also a vector [erpendicular to the first two\n    \n    //for the first area we use it as an early exit//\n    //if the dot of that vector and the normal of the triangle is \n    //negative, we know the vector flipped directions meaning\n    //the hit point was outside outside the triagle.\n    //a bit more explenation\n    \n    //if the vectors a to b and a to hitPoint,form an angle larger than\n    //180, the paralellogram formed by the triangle and it's mirror\n    //must be negative (or flipped), so we get a cross product with a \n    //flipped direction\n    //the dot of that flipped direction and the normal with also then \n    //be negative.\n    \n    //and as for being inside the triangle, if you look at the way\n    //we've layed out the vectors, it goes in a circle from a to b to c to c\n    //that cycles in one direction so there is an inside and an outside/\n    //anything hit point in that circle (which will be a triangle lol)\n    //will form an angle less than 180 with the corresponding vector\n    //\n    if(dot(planeN,cross(AzuB,normalize(point_on_plane-A))) < 0.)\n        return no_hit;\n    \n    //now we use the second and third area checks, or the dot of those\n    //area vectos and the normal, as our uv coordinates because\n    //dotting a cross product gives us a value from 0 to 1 (when it's in)\n    //and two of these dotted area vectors is enough to describe\n    //and point in the triangle.\n    float u = dot(planeN, cross(BzuC, point_on_plane-B ) );\n    float v = dot(planeN, cross(CzuA, point_on_plane-C ) );\n   \n    //I'm definitly missing something though\n    return u >= 0. && v >= 0. ? vec3(t,u,v) : no_hit;\n}\n\nfloat checker(vec2 st){\n    return mod(floor(st.x)+floor(st.y),2.);\n}\n\nmat2 rot(float a){\n    float si = sin(a);\n    float cs = cos(a);\n    \n    return mat2(cs,-si,si,cs);\n}\n\nvec3 grid_design(vec2 uv){\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIG          //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    \n    //graph background\n    vec3 col = vec3(0.1);\n    \n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    \n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = vec3(1.);\n    float a = iTime/4.;\n    vec3 ro = vec3(6.*cos(a), 0., 6.*sin(a));\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 fwd = normalize(ta - ro);\n    vec3 uu = vec3(0., -1., 0.);\n    \n    vec3 right = normalize(cross(uu,fwd));\n    vec3 up = normalize(cross(right,fwd));\n    \n    float focal = 1.52;\n    \n    vec3 rd = right*uv.x + up*uv.y + fwd*focal;\n    \n    vec3 planeN = vec3(0., 1., 0.);\n    vec3 point_on_plane = vec3(0., -1., 0.);\n    \n    float t = iPlane(ro, rd, planeN, point_on_plane);\n    \n    if(t >= 0.){\n        vec3 pos = ro + rd*t;\n        col = grid_design(pos.xz/10.5);\n    }\n    \n    vec3 cPos = vec3(0., 0., 0.);\n    float r = 1.;\n    \n    vec3 A = vec3(-1.,1.,0.);\n    A.xy*=rot(iTime);\n    vec3 B = vec3(1.,0.,0.);\n    B.zx*=rot(iTime);\n    vec3 C = vec3(0.,2.,0.);\n    C.xy*=rot(iTime);\n    vec3 t_and_uv = iTriangle(ro,rd,A,B,C);\n    \n    if(t_and_uv.x >= 0.){\n            \n        vec3 tex = texture(iChannel0, t_and_uv.yz).xyz;\n        col = tex;\n        \n    }\n    \n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}