{"ver":"0.1","info":{"id":"wtsfDn","date":"1598729950","viewed":43,"name":"TFG 1 - Hola Mundo","username":"lukasharing","description":"Primer algoritmo escrito en GLSL para el TFG, “Funciones de distancia con signo”.\nSe ha definido una función “escena” el cual se peresentará en adelante, técnicas para su creación.\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tfg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PASOS 128\n#define EPSILON 0.001\n#define MAXIMO 20.0\n\n// No Vamos a entrar aún en como se define una escena, aunqeu el siguiente código, \n// representa el de una esfera en el (0, 0, 0) de radio 0.2 unidades\nfloat escena_sdf(vec3 rayo){\n    return length(rayo) - 0.2;\n}\n\nfloat SphereMarching(vec3 ojo, vec3 direccion){\n    float distancia = 0.0;\n    // Realizamos PASOS iteraciones de marching.\n    for(int i = 0; i < PASOS; ++i){\n        // Calculamos la cabeza del rayo\n        vec3 rayo = ojo + direccion * distancia;\n        // Calculamos el radio de la esfera más próxima a la isosuperficie\n        float radio = escena_sdf(rayo);\n        // Si el radio (distancia mínima a la isosuperficie es muy pequeña, estamos devolvemos la distancia del vector final. Esta distancia la utilizaremos más adelante para calcular el vector que apunta a la isosuperficie.\n        if(radio < EPSILON){\n            return distancia;\n        }\n        // Incrementamos la distancia recorrida si no estamos cerca de la isosuperficie.\n        distancia += radio;\n        // Comprobamos que no se haya superado la distancia de dibujado máximo. Para aquellos texels cuyo valor sea -1.0. Podemos considerarlos, el fondo de la escena.\n        if(distancia > MAXIMO){\n            return MAXIMO;\n        }\n    }\n    return MAXIMO;\n}\n\n// Cálculo de la normal de la isosuperficie intersectada por un rayo que ha sido estimado.\nvec3 Normal(vec3 p){\n    // f(x1,...,xn)\n    float fxyz = escena_sdf(p);\n    // f(x1,..,xi+h,xn)\n    float fxhyz = escena_sdf(p + vec3(EPSILON, 0.0, 0.0));\n    float fxyhz = escena_sdf(p + vec3(0.0, EPSILON, 0.0));\n    float fxyzh = escena_sdf(p + vec3(0.0, 0.0, EPSILON));\n\n    // Utilizamos la definicion de derivadas parciales para devolver el gradiente, que se trata de la normal de la isosuperficie.\n    return vec3(\n        (fxhyz - fxyz) / EPSILON,\n        (fxyhz - fxyz) / EPSILON,\n        (fxyzh - fxyz) / EPSILON\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalizamos las coordendas y las reescalamos para mantener el ratio de aspecto. Transladamos al centro de la pantalla.\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.y, iResolution.x);\n    // Definimos el ojo y la pantalla, que se encuentra en nuestra escena. Este debe estar detrás de la pantalla ya que de este se “lanzarán” los rayos que pasarán por la pantalla.\n    vec3 ojo = vec3(0.0, 0.0, -1.0);\n    vec3 pantalla = vec3(uv, 0.0);\n    // Es fácil observar que la dirección del rayo es el vector normalizado que apunta desde el ojo hasta la pantalla\n    vec3 direccion = normalize(pantalla - ojo);\n    // Con esto, ya podemos utilizar nuestro Sphere marcher.\n    float distancia = SphereMarching(ojo, direccion);\n    if(distancia < MAXIMO){\n        // Estamos aproximadamente sobre la isosuperficie. El vector, será el formado por el ojo, con su dirección modulada con la distancia recorrida, equivalente a la distancia a la isosuperficie desde el ojo.\n        // Veremos además cómo podemos añadir un material a cada objeto.\n        vec3 rayo = ojo + direccion * distancia;\n        // Utilizamos el color blanco para dibujar la isosuperficie.\n        fragColor = vec4(1.0);\n    }else{\n        // Estamos en el fondo de la escena.\n\n        // Utilizamos el color negro para dibujar el fondo.\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}