{"ver":"0.1","info":{"id":"MfSyzV","date":"1722606647","viewed":87,"name":"Draw Jump Flood Distance Field","username":"chronos","description":"Basic jump flood based distance field drawing.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["basic","flood","jump","flooding","jfa"],"hasliked":0,"parentid":"cdSyDW","parentname":"Basic Jump Flooding"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Draw Jump Flood Distance Field by chronos\n    ---------------------------------------------\n    \n    Super basic :)\n    Just drawing in Buffer A, and then flooding with different offsets in Buffer B\n    Jump flooding impl is forked from one of my previous JF shaders.\n    \n    Can easily be improved by better drawing logic and improved JF implementation.\n    \n    self link: https://www.shadertoy.com/view/MfSyzV\n*/\n\n\n// Buffer A is the source buffer, or input, from which the distance / offset should be calculated\n// Buffer B samples buffer A as a seed and itself to iteratively apply jump flooding\n\n// This buffer visualizes the result :)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 src = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 samp = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float dist = length(samp.rg);\n    vec3 color = \n    dist > 0. ? vec3(.5*(1.+normalize(samp.rg)), dist / 500.) + src.aaa * 0.5 : src.aaa * 0.5\n    ;\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy) / iResolution.y;\n    \n    bool mouse_down = iMouse.z > 0.;\n    \n    vec4 color = vec4(0);\n    \n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    color = bufA;\n    \n    if(length(uv-mouse) < 0.125 && mouse_down) \n    {\n        color.rg = vec2(0);//-(fragCoord - iMouse.xy) ;\n        color.a = 1.;\n    }\n\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ij = ivec2(fragCoord);\n    \n    const int N = 10;\n    \n    if(iFrame % N != 0)\n    {\n       fragColor = texelFetch(iChannel1, ij, 0);\n    }\n\n    // pow2, e.g.: 256, 128, 64, 32, 16, 8, 4, 2, 1\n    // jump_size for iFrame%N == N-1 should be 1,\n    // therefore  min(iFrame%N + 1, N) should be N\n    int jump_size = (1 << N) >> min(iFrame%N + 1, N); \n    \n    // Initialize variables\n    float current_dist = 9e9;\n    vec2 current_offset = vec2(0);\n    float current_fill = 0.;\n    \n    if(iFrame % N == 0 && iMouse.z> 0.)\n    {\n        vec4 bufA = texelFetch(iChannel0, ij, 0);\n        fragColor = bufA;\n        \n        current_fill   = bufA.a;\n        current_offset = bufA.rg;\n        current_dist   = mix(9e9, length(bufA.rg), bufA.a);\n    }\n    \n    for(int x = -1; x <= 1; ++x)\n    for(int y = -1; y <= 1; ++y)\n    {\n        ivec2 jump = jump_size*ivec2(x,y);\n        ivec2 coord = ij + jump;\n        if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y))\n        {\n            continue;\n        }\n\n        vec4 samp = texelFetch(iChannel1, coord, 0);\n\n        bool samp_fill = samp.a >= 1.;\n        vec2 samp_offset = samp.rg;\n\n        vec2 candidate_offset = vec2(jump) + samp_offset;\n        float candidate_dist = length(candidate_offset);\n\n        if (candidate_dist <= current_dist && samp_fill)\n        {\n            current_dist = candidate_dist;\n            current_offset = candidate_offset;\n            current_fill = 1.;\n        }\n\n    }\n\n    // save offset and fill\n    fragColor = vec4(current_offset, 0., current_fill);\n}","name":"Buffer B","description":"","type":"buffer"}]}