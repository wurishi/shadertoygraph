{"ver":"0.1","info":{"id":"ssSfWm","date":"1646400762","viewed":174,"name":"Voronoi with growth","username":"batersy","description":"Now the cell also grow as time from 1/max_k to 1/min_k, which give the cell curved boundary.\n(In case  cell edge use grid edge as part of it. you need to turn up 'surround' parameter)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n * Adapted from https://thebookofshaders.com/12\n */\n \n// cell number on height\nfloat cellNum = 6.;\n// whether cell center can move\nbool cellMove = true;\n// whether cell can growth\nbool cellGrowth = true;\n// max grow size 1/min_k\nfloat min_k = .6;\n// min grow size 1/max_k\nfloat max_k = 2.;\n// time cost for growing\nfloat cellCycle = 10.;\n// compute how many surrounding cells\nint surround = 2;\n\nfloat TWO_PI = 6.2831;\nfloat random( vec2 p ) {\n    return fract(sin((dot(p,vec2(233.1,123.7)) + dot(p,vec2(12.5,753.3)))*45345.5434));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.1233);\n}\n\nvec3 random3( vec2 p ) {\n    return fract(sin(vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(231.1,343.2))))*23234.2431);\n}\n\nfloat getK(vec2 gradlePos, float time) {\n    float init_phase = random(gradlePos);\n    float a = (max_k - min_k) / 2.;\n    float c = (min_k + max_k) / 2.;\n    float k = a*sin(time*TWO_PI/cellCycle + TWO_PI * init_phase) + c;\n    return k;\n}\n\nvec2 getCellCenter(vec2 gradlePos, float time) {\n    vec2 point = random2(gradlePos);\n    if(cellMove) {\n        float T = clamp(6.*length(point), 4., 8.);\n        point = 0.5 + 0.5*sin(time*TWO_PI/T + TWO_PI*point);\n    }\n    return point;\n}\n\nvec3 getColor(vec2 gradlePos, float time) {\n    vec3 color = random3(gradlePos);\n    color = 0.5 + 0.5*sin(color);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.);\n\n    // Scale\n    st *= cellNum;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;\n    vec2 m_neighbor = vec2(0.);\n    for (int y= -surround; y <= surround; y++) {\n        for (int x= -surround; x <= surround; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            vec2 point = getCellCenter(i_st + neighbor, iTime);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n            \n            float dist = 0.;\n            if(cellGrowth) {\n                float k = getK(i_st + neighbor, iTime);\n                dist = length(diff) * k / max_k;\n            } else\n                dist = length(diff);\n\n            // Keep the closer distance\n            if(dist < m_dist) {\n                m_neighbor = neighbor;\n                m_dist = min(m_dist, dist);\n            }\n        }\n    }\n    color = getColor(i_st + m_neighbor, iTime);\n\n    // Draw the min distance (distance field)\n    //color *= m_dist;\n\n    // Draw cell center\n    color += 1.-step(.02, m_dist);\n\n    // Draw grid\n    //color.rgb += step(.99, f_st.x) + step(.99, f_st.y);\n\n    // Show isolines\n    //color -= step(.7,abs(sin(27.0*m_dist)))*.5;\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}