{"ver":"0.1","info":{"id":"MdKSW1","date":"1464192900","viewed":154,"name":"My Raytracing test","username":"lowww","description":"following a tutorial and added a few other things.. not sure how to implement a light position. is it just on the normal calculation?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// more info https://iquilezles.org/articles/distfunctions\n\n// sphere - signed\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// box - unsigned\nfloat udBox(vec3 pos, vec3 size) {\n    return length(max(abs(pos) - size, 0.0));\n}\n\n// round box - unsigned\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// torus\nfloat sdTorus( vec3 p, vec2 t ) {\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat displacement(vec3 pos, float time) {\n    float t1 = 10.0 + (0.6 + 0.4 * sin(time) * 20.0);\n    float t2 = 10.0 + (0.4 + 0.6 * sin(time) * 20.0);\n    float t3 = 10.0 + (0.5 + 0.1 * sin(time) * 20.0);\n    return 0.01 * sin(t1 * pos.x) * sin(t2 * pos.y) * sin(t3 * pos.z);\n}\nfloat distfunc(vec3 pos) {    \n    float d2 = displacement(pos, iTime);\n    float sphere = sdSphere(pos, 1.2);\n    float box = udBox(pos, vec3(1., 1., 1.));\n    return sphere + d2;\n    return max(box, -sphere);\n}\n\nvec4 textureSphere( in vec3 pos, in vec3 nor ) {\n\tvec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture( iChannel0, uv ).xyz);\n    float ao = clamp( 0.75 + 0.25*nor.y, 0.0, 1.0 );\n    return vec4( col, ao );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 cameraOrigin = vec3(0.0, 0.0, 3.5);\n    vec3 cameraTarget = vec3(0.0);\n    vec3 upDirection = vec3(0.0, -1.0, 0.0);\n    \n    // move camera with mouse\n    cameraOrigin.xy = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n    cameraOrigin.xy *= vec2(4.0, -4.0);\n    \n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\n    screenPos.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    \n    const int MAX_ITER = 100;\n\tconst float MAX_DIST = 20.0;\n\tconst float EPSILON = 0.001;\n\n\tfloat totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n\n\tfor (int i = 0; i < MAX_ITER; i++) {\n    \tif (dist < EPSILON || totalDist > MAX_DIST)\n        \tbreak;\n\n    \tdist = distfunc(pos);\n    \ttotalDist += dist;\n    \tpos += dist * rayDir;\n\t}\n    \n    vec3 color = vec3(0.0);\n\n    if (dist < EPSILON) {\n        // normal\n        vec2 eps = vec2(0.0, EPSILON);\n\t\tvec3 normal = normalize(vec3(\n    \t\tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n    \t\tdistfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n   \t\t\tdistfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n        // lights\n        float diffuse = max(0.0, dot(-rayDir, normal));\n        float specular = pow(diffuse, 32.0);\n        \n        // material\n        vec3 material = textureSphere( pos, normal ).xyz;\n        color = vec3(diffuse + specular) * material;\n\t}\n\n\tfragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}