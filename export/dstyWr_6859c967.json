{"ver":"0.1","info":{"id":"dstyWr","date":"1695133423","viewed":33,"name":"Marble Test","username":"AochiToxx","description":"Trying for a black marbled surface with gold inlay.\n\nThis is probably horribly done. It's my first real attempt at a shader. ðŸ˜…\n\nAny suggestions are welcome!!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["marble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define diff .001\n#define timeScale 0.1\n#define lightPathRadius .35\n#define lightPathCenter vec3(.5, .5, .125)\n#define lightColor vec4(1.0, 1.0, 1.0, 1.0)\n#define lightStrength 0.1\n#define surfaceZDepth 0.0\n#define ambientColor vec4(0.0, 0.0, 0.0, 1.0)\n#define specularFactor 4.0\n#define specularRatio 2.0\n#define specularMapRatio 1.0\n\n#define AMPLITUDE 0.1\n#define FREQUENCY 5.0\n#define SPEED 0.5\n\n#define DARK_THRESHOLD 0.75\n#define GOLD_THRESHOLD 2.7\n#define GOLD_COLOR vec3(1.0, 0.84, 0.0)  // Basic gold color, adjust to your preference\n\n#define NUM_SAMPLES_X 4\n#define NUM_SAMPLES_Y 4\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat snoise(vec2 x) {\n    vec2 timeOffset = vec2(sin(iTime * SPEED), cos(iTime * SPEED));\n    x += timeOffset;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(hash(n), hash(n + 1.0), f.x),\n               mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\nvec3 getMarbleTexture(vec2 uv) {\n    float pattern = sin(uv.y * 20.0 + 20.0 * snoise(uv * 1.0)) * 0.5 + 0.5;\n    return mix(vec3(0.90, 0.85, 0.8), vec3(0.7, 0.65, 0.6), pattern);\n}\n\nfloat getHeightValue(vec2 coord)\n{\n    float baseNoise = snoise(coord * 1000.0);\n    float fineNoise = snoise(coord * 7500.0) * 1.5;\n    return baseNoise + fineNoise;\n}\n\nvec2 getLocalDiff(vec2 coord)\n{\n    float diffX = getHeightValue(vec2(coord.x+diff, coord.y)) - getHeightValue(vec2(coord.x-diff, coord.y));\n    float diffY = getHeightValue(vec2(coord.x, coord.y+diff)) - getHeightValue(vec2(coord.x, coord.y-diff));\n    return vec2(diffX, diffY);\n}\n\nfloat getIntensity(vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 getSurfaceNormal(vec2 coord)\n{\n    vec3 marbleColor = getMarbleTexture(coord);\n    float intensity = getIntensity(marbleColor);\n    \n    vec2 localDiff = getLocalDiff(coord);\n\n    float blendFactor = smoothstep(3.0, DARK_THRESHOLD, intensity);\n\n    localDiff *= mix(1.0, 0.2, blendFactor);\n    localDiff = (localDiff/8.0) + 0.5;\n    \n    float localDiffMag = length(localDiff);\n    float z = sqrt(1.0 - pow(localDiffMag, 1.0));\n    return vec3(localDiff, z);\n}\n\nfloat getSpecularity(vec2 coords)\n{\n    vec3 marbleColor = getMarbleTexture(coords);\n    float intensity = getIntensity(marbleColor);\n    \n    float baseSpec = 0.3;\n    float addedSpec = mix(0.5, 0.5, step(DARK_THRESHOLD, intensity));\n\n    return baseSpec + addedSpec;\n}\n\nvec3 genLightCoords()\n{\n    return vec3(lightPathCenter.x + (sin(iTime * timeScale) * lightPathRadius), \n                lightPathCenter.y + (cos(iTime * timeScale) * lightPathRadius),\n                lightPathCenter.z);\n}\n\nvec3 getIncidence(vec3 lightPos, vec2 coord)\n{\n    return lightPos - vec3(coord, surfaceZDepth);\n}\n\nfloat getAngle(vec3 lightIncidence, vec3 normal)\n{\n    normal.xy -= 0.5;\n    normal.xy *= 4.0;\n    return dot(normalize(lightIncidence), normalize(normal));\n}\n\nfloat getDist(vec3 light, vec2 coord)\n{\n    return distance(light, vec3(coord, 1.0));\n}\n\nvec4 getLighting(vec2 uv) {\n    // Oscillate the x-position of the light source within canvas bounds over a 20-second period\n    float lightXPosition = 2.0 + 1.0 * sin(iTime * 3.14 / 5.0);  // This will vary lightXPosition between [0, 1]\n    \n    // Set the light's position; position it high on the y-axis for top-down lighting\n    vec3 lightPos = vec3(lightXPosition, 0.5, 2);  \n\n    // Calculate direction vector from light's position to the current fragment\n    vec3 lightDirection = normalize(lightPos - vec3(uv, 0.0)); \n\n    vec3 normal = getSurfaceNormal(uv);\n    float cosine = max(dot(lightDirection, normal), 0.0);\n    \n    vec4 diffuse = lightColor * lightStrength * cosine;\n\n    float spec = dot(normalize(lightDirection + vec3(0.55, 0.55, 1.0)), normal);\n    vec4 specular = lightColor * lightStrength * pow(spec, specularFactor) * specularRatio * specularMapRatio;\n\n    return ambientColor + diffuse + specular;\n}\n\nvec3 getMarbleIntensity(vec2 uv) {\n    vec3 marbleColor = getMarbleTexture(uv);\n    float intensity = getIntensity(marbleColor*1.0478);\n    return vec3(intensity);\n}\n\nfloat grainyNoise(vec2 coord) {\n    float scale = 100.0;\n    return snoise(coord * scale);\n}\n\nvec3 addGlints(vec2 uv) {\n    float grain = grainyNoise(uv * 100.0 + vec2(iTime));\n\n    float timeVaryingGrain = grainyNoise(uv * 15.0 + vec2(iTime * SPEED * 5.5));\n\n    float sparkleMask = grain * timeVaryingGrain;\n\n    float sparkleThreshold = 0.99;\n    float sparkleIntensity = step(sparkleThreshold, sparkleMask);\n\n    return vec3(sparkleIntensity);\n}\n\nvec3 getGoldShading(vec2 uv, vec2 fragCoord) {\n    vec4 lighting = getLighting(uv);\n    vec3 goldShaded = GOLD_COLOR * lighting.rgb * 3.0;\n\n    vec3 glints = addGlints(uv);\n    \n    vec3 goldWithGrainAndGlints = goldShaded * (1.5 + 0.5 * grainyNoise(fragCoord.xy)) + glints;\n\n    return goldWithGrainAndGlints;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 resolution = iResolution.xy;\n    vec2 uv = fragCoord.xy / resolution;\n    vec4 totalColor = vec4(0.25);\n    \n    float sampleStepX = 1.0 / float(NUM_SAMPLES_X);\n    float sampleStepY = 1.0 / float(NUM_SAMPLES_Y);\n    float totalSamples = float(NUM_SAMPLES_X * NUM_SAMPLES_Y);\n\n    for (float x = 0.0; x < 1.0; x += sampleStepX) {\n        for (float y = 0.0; y < 1.0; y += sampleStepY) {\n            vec2 sampleOffset = vec2(x - 0.5 + sampleStepX * 0.5, y - 0.5 + sampleStepY * 0.5) / resolution;\n            vec2 samplePosition = uv + sampleOffset;\n\n            samplePosition.y = 1.0 - samplePosition.y;\n            \n            vec4 lighting = getLighting(samplePosition);\n            vec3 marbleColor = getMarbleTexture(samplePosition);\n            vec3 marbleIntensity = getMarbleIntensity(samplePosition);\n            \n            vec4 baseTexel = vec4(marbleColor, 1.0);\n            #ifdef useBaseImage\n            baseTexel *= texture(iChannel2, samplePosition);\n            #endif\n\n            vec3 litColor = clamp(lighting.rgb * baseTexel.rgb, vec3(0.0, 0.0, 0.0), vec3(1.5));\n            \n            float goldMask = step(GOLD_THRESHOLD, marbleIntensity.r + marbleIntensity.g + marbleIntensity.b);\n            vec3 shadedGold = getGoldShading(samplePosition, fragCoord);\n            vec3 goldWithGrain = shadedGold * (1.1 + 0.5 * grainyNoise(fragCoord.xy));\n            \n            vec3 finalSampleColor = mix(litColor, goldWithGrain, goldMask);\n\n            totalColor += vec4(finalSampleColor, 1.0);\n        }\n    }\n\n    fragColor = totalColor / totalSamples;  // Average the samples\n}\n\n\n","name":"Image","description":"","type":"image"}]}