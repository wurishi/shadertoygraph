{"ver":"0.1","info":{"id":"7scSDN","date":"1633137358","viewed":243,"name":"Geometric city","username":"Flopine","description":"I should really start writing this thesis instead of producing shaders... ","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","repetition","palette","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash21(x) fract(sin(dot(x,vec2(13.5,24.8)))*164.5)\n\nstruct obj {\n    float d;\n    vec3 sha;\n    vec3 li;\n};\n\nobj objmin(obj a, obj b)\n{\n    if(a.d<b.d) return a;\n    else return b;\n}\n\nvec2 edge (vec2 p)\n{\n    vec2 p2 = abs(p);\n    return (p2.x>p2.y)?vec2((p.x<0.)?-1.:1.,0.):vec2(0.,(p.y<0.)?-1.:1.);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p=max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nobj prim1 (vec3 p, vec3 size, vec2 id)\n{\n    obj p1 = obj(max(-sc(p,size.x*0.9),box(p,size)), vec3(0.1,0.,0.15), vec3(0.95,0.25,0.5));\n    obj p2 = obj(length(p-vec3(0.,1.5,0.))-max(hash21(id)*0.45,0.1), vec3(0.1,0.,0.6), vec3(0.1,0.8,0.4));\n    return objmin(p1,p2);\n}\n\nobj SDF (vec3 p)\n{\n    p.yz*=rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    p.z -= iTime;\n    \n    float size = 0.45;\n    vec2 center = round(p.xz),\n    neigh = center+edge(p.xz-center);\n    \n    obj me = prim1(p-vec3(center.x,0.,center.y),vec3(size,max(hash21(center)*2.,0.1),size),center),\n    next = obj(box(p-vec3(neigh.x,0.,neigh.y),vec3(size,2.,size)),vec3(0.),vec3(0.));\n    \n    return objmin(me,next);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n).d/eps,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(uv*5.,-30.), rd=vec3(0.,0.,1.),p=ro,\n    col=vec3(0.), l=normalize(vec3(1.,2.,-2.));\n    \n    bool hit = false; obj O;\n    for (float i=0.; i<100.;i++)\n    {\n        O = SDF(p);\n        if (O.d<0.001)\n        {hit=true;break;}\n        p += O.d*rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.0);\n        float ao = AO(0.1,p,n)+AO(0.15,p,n)+AO(0.4,p,n);\n        col = mix(O.sha, O.li, light)*ao/3.;\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}