{"ver":"0.1","info":{"id":"DtjyR3","date":"1692102349","viewed":69,"name":"Path Arc 2 SDF","username":"TheTurk","description":"Distance function for an arc that can be used as a building block to create complex shapes like [url]https://www.shadertoy.com/view/DdjyDW[/url]\nOther path distance functions:\n[url]https://www.shadertoy.com/playlist/scBBRD[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","distance","path","arc","shape","primitive","odd","even"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nconstructs an arc using two normalized vectors that define the \narc's starting and ending points and its radius. the sign of the \ndistance field is computed using the even-odd rule and determines \nwhether a point lies inside (negative sign) or outside (positive \nsign) a given shape.\n*/\n\nfloat arc(vec2 position, float radius, vec2 a, vec2 b) {\n    vec2 start = a * radius;\n    vec2 end = b * radius;\n    bool m = a.x * b.y < a.y * b.x;\n    // even-odd rule\n    float s = 1.0;\n    float c = radius * radius - position.y * position.y;\n    if (c > 0.0) {\n        c = sqrt(c);\n        bool s1 = -c * a.y < position.y * a.x;\n        bool s2 = -c * b.y < position.y * b.x;\n        bool s3 = c * a.y < position.y * a.x;\n        bool s4 = c * b.y < position.y * b.x;\n        if (position.x < -c && (s1 != m && s2 == m) == m) {\n            s = -s;\n        }\n        if (position.x < c && (s3 != m && s4 == m) == m) {\n            s = -s;\n        }\n    }\n    bool s1 = position.x * a.y < position.y * a.x;\n    bool s2 = position.x * b.y < position.y * b.x;\n    if ((s1 != m && s2 == m) == m) {  \n        return abs(length(position) - radius) * s;\n    }\n    vec2 d1 = position - start;\n    vec2 d2 = position - end;\n    return sqrt(min(dot(d1, d1), dot(d2, d2))) * s;\n}\n\n// example\nfloat hexagon(vec2 position, float radius) {\n    vec2 start = vec2(0.0, radius);\n    float d = float(0xffffffffU);\n    float s = 1.0;\n    for (int i = 0; i < 6; i++) {\n        vec2 end = vec2(start.x * 0.5 - start.y * -sqrt(3.0) * 0.5, start.x * -sqrt(3.0) * 0.5 + start.y * 0.5);\n        vec2 center = (start + end) * 0.5 * 0.5;\n        float r = length(start - center);\n        float ds = arc(position - center, r, (start - center) / r, (end - center) / r);\n        d = min(d, abs(ds));\n        s *= sign(ds);\n        start = end;\n    }\n    return d * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n   \n    vec2 center = vec2(0.0, 0.0);\n    float radius = 0.5;\n    float angle = (cos(iTime * 0.5) + 1.0) * 0.5 * 0.5 * 3.14159 + 0.25 * 3.14159;\n    vec2 normal1 =  vec2(sin(-angle), cos(-angle));\n    vec2 normal2 = vec2(sin(angle), cos(angle));\n    normal1 = vec2(normal1.x * cos(iTime) - normal1.y * sin(iTime), normal1.x * sin(iTime) + normal1.y * cos(iTime));\n    normal2 = vec2(normal2.x * cos(iTime) - normal2.y * sin(iTime), normal2.x * sin(iTime) + normal2.y * cos(iTime));\n    float d = arc(position - center, radius, normal1, normal2);\n    \n    // d = hexagon(position, 0.5); // example \n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7); \n    color *= 1.0 - exp(-4.0 * abs(d)); \n\tcolor *= 0.8 + 0.2 * cos(120.0 * d); \n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.003) * iResolution.y));\n    if (iMouse.z > 0.0) {\n        vec2 mousePosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        vec2 currentPoint = vec2(0.0, -0.5);\n        float d = arc(mousePosition - center, radius, normal1, normal2);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 3.0, abs(length(position - mousePosition) - abs(d)) * iResolution.y - 1.0));\n    }\n    fragColor = vec4(color, 1.0);\n} ","name":"Image","description":"","type":"image"}]}