{"ver":"0.1","info":{"id":"tdSBDt","date":"1591192312","viewed":149,"name":"Plumbing Maze","username":"spalmer","description":"fly through a 3D maze made of pipes!  :)  use mouse+arrows+pgup/dn+wasd+space/c, Try not to get lost in them, they're hollow!  There are entrances carved out periodically.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["collision","raymarch","camera","flashlight","ambientocclusion","maze","headlamp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 Render(vec3 ro, vec3 rd, float vig)\n{\n    int nsteps = nMarchSteps + IZERO; // perf/quality scalability trade-off\n    if (R.y >=  512.) nsteps = nsteps * 3 / 4;\n    if (R.y >=  768.) nsteps = nsteps * 3 / 4;\n    if (R.y >= 1024.) nsteps = nsteps * 3 / 4;\n    Hit h = tScene(ro, rd, 1. - 1e-2, nsteps);\n    float t = h.d; // trace depth to first hit\n    t = min(t, 8.5e4);\n    int m = h.m;\n    vec3 hp = ro + rd * t\n    , light = Light(m, hp, -rd, t, vig)\n    , c = light;\n    return c;\n}\n\nvec3 Render(vec2 p)\n{\n    State state;\n    vec2 R = iResolution.xy;\n    ivec2 i = ivec2(p);\n    LoadState(state, BufA, ivec2(R));\n    vec2 q = (p + p - R) / R.y;\n    mat3 view = Camera(state.eyeaim);\n    vec3 rv = vec3(q, 2.); // ray dir in view space\n    vec3 rd = normalize(view * rv);\n    vec3 ro = state.eyepos;\n    return Render(ro, rd, min(1., .5*dot(q, q)));\n}\n\nfloat Dither(vec2 p)\n{\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n\tvec3 c = Render(p);\n    c = pow(c, vec3(.4545)); // to sRGB gamut\n    c += .6 / 256. * Dither(p);\n    o = vec4(c, 1);\n}\n\n\n    //vec3 q = (p - .5 * R.xy).xxy;\n    //float d = dMaze(q);\n\t//float g = .5-.5*d;\n    //vec3 c = vec3(g);\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// uses the 2D maze from Maze Shape Gradient https://shadertoy.com/view/WdfyWH\n// but combines it with another plane distance to poof the walls out into 3D pipes\n// but the maze itself is still flat, for the most part.  TODO fully 3D pipework!\n// TODO more decorations in the pipes; flanges, valves etc.\n// flanges should only be on the outside!\n// 'plastic' windows?  gratings?\n// TODO manhole entrances.  Currently just carved holes out to allow pipe access.\n// maybe connect them to some fake vertical pipery\n\n// btw running with Common tab focused tends to slow frame rate!\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define IZERO min(iFrame, 0)\n\nconst float \n  tau = 2. * acos(-1.) //6.28318531 //\n, phi = .5*(sqrt(5.)+1.)\n, fogdensity = .01\n, aod = 1.1\n, mazespacing = 6.\n;\n\nconst vec3\n  sunDir = normalize(vec3(.1,.7,.9))\n, csky = vec3(.81,.91,.99) * .6\n;\n\nconst int\n  mSky  = 0\n, mPipe = 2\n;\n\nconst int\n  nMarchSteps = 256 //96 //128 //192 //\n;\n\n// cos,sin of full turns angle\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution;\n    vec3 eyepos;\n    vec3 eyevel; // or old pos? either way involves iTimeDelta\n    vec2 eyeaim;\n//    bool boost; // move faster\n};\n\nconst int\n  slotResolution = 0 // still not using zw channels - could put mouse state here, or..\n, slotEyePosAz   = 1 // stuffed azimuth and elevation of aim into w components\n, slotEyeVelEl   = 2 // of position and velocity, respectively\n, slotCount      = 3\n;\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResolution].xy);\n    state.eyepos = data[slotEyePosAz].xyz;\n    state.eyevel = data[slotEyeVelEl].xyz;\n    state.eyeaim = vec2(data[slotEyePosAz].w\n                       ,data[slotEyeVelEl].w);\n}\n\n// only needed in Buffer A\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) {\n      case slotResolution:\n        c.xy = vec2(R);\n        break;\n      case slotEyePosAz:\n        c = vec4(state.eyepos, state.eyeaim.x);\n        break;\n      case slotEyeVelEl:\n        c = vec4(state.eyevel, state.eyeaim.y);\n        break;\n      default:\n        break;\n    }\n}\n\n// custom struct for returning scene trace hit results\nstruct Hit\n{\n    float d;\n    int m; // material id\n};\n    \n// maze from https://shadertoy.com/view/WdfyWH\n\n#define R iResolution\n#define L length\n\n// unsure if /dot(r,r) would be worse than all this mess to keep r unit length\n#define tile(_) (mod((_) + 50., 100.) - 50.)\n#define tilediv(_) (((_) + ((_) < -1. ? 0. : .125*mazespacing)) / 100.) // HACK shifted to prevent color bleeding between sections\n#define D(_) L(tile(_))\n\nfloat dMaze(vec3 q)\n{\n    float U = mazespacing, d = U/2.; // lowest distance, maze scale \n    q -= vec3(U,0,U)*.125;\n    vec2 e = vec2(.5, 0)\n    , i = floor(q.xz / U + .5) * U;\n    for (float x = -2.; x < 3.; ++x) {\n        float u = x;\n        vec2 p = i + (x*x > 1. ? vec2(0,.5*u) : vec2(u,0)) * U\n        , v = q.xz - p;\n        v *= step(D(p), vec2(D(p + e), D(p + e.yx))) * 2. - 1.;\n    \tif (.5 < fract(sin((p.x+47.*p.y)*99.)*3e4)) v = v.yx;\n        if (v.y > 0.) v.y = max(0., v.y - U);\n        d = min(d, L(v));\n    }\n    return d;\n}\n\n// N.B.:  http://cs.utep.edu/vladik/2013/tr13-44.pdf\n// from a note on wikipedia page for Smooth maximum; seems to work!  needs tuned or something; still not \"smooth\"\n// I'm still not sure it 100% fixes the gradient seam.\n// Is it just not smooth *enough* to fix the derivative discontinuity? If so, higher order may solve it.\nfloat smin(float a, float b, float k)\n{\n    return .5*(a + b - sqrt(dot(a-b, a-b) + .000002/k));\n}\n\nfloat smax(float a, float b, float k)\n{\n    return -smin(-a, -b, k);\n    return .5*(a + b + sqrt(dot(a-b, a-b) + .000002/k));\n}\n\n\n// returns (distance, material)\nHit dScene(vec3 p)\n{\n    if (p.y > 2.5) return Hit(p.y - 2., mSky); // bound plane\n    float\n      dp = p.y // simple plane //length(p) - 1. // or ball //\n    , dm = \tdMaze(p) // medial axis maze skeleton\n        \t//abs(dMaze(p) - 1.05) // convert to make thin halfpipes if carved from plane\n    , dr = length(vec2(dm, dp)) - .99 // thick round pills\n    , dt = abs(dr + .09) - .08 // thin walled pipes\n    , dh = min( // holes to cut out - FIXME countering an offset that's added somewhere else!\n          length(vec3(mod(p.xz+2.*mazespacing, 4.*mazespacing)-2.*mazespacing-.75, p.y-1.).xzy) - .5 // small manholes on top for emergency access\n        , max(abs(tile(p.x)), abs(tile(p.z)))-10.) // big squares!\n        //max(abs(mod(p.x+50., 100.)-50.), abs(mod(p.z+50., 100.)-50.))-6. //length(mod(p+50., 100.)-50.) - 6. \n    , ds = \n    \t//dp \n    \t//dm\n    \t//dr\n    \t//dt\n        //max(-dh, dt) // just the pipes\n    \tmin(dp + 2.5, smax(-dh, dt, 1e-3)) // pipes and \"ground\" plane\n    \t//max(-dp, length(vec2(dm - .0, dp)) - .05) // free-floating 3d thin-walled pipes, cutaway view\n    \t//max(dp, -dm) // carve it out of plane - deeply!\n    \t//max(dp, 1.-length(vec2(dm, dp))) // carve round pills out of plane - hard edged seams //min(dp, 0.)))) //\n    \t//smax(dp, 1.-length(vec2(dm, dp)), .04) // carved with smooth edges //min(dp, 0.) // FIXME fails when camera is sort of high above ground!! nan's?\n    \t;\n    // this is what I mean; I need to work on the system which merges\n    // materials and distances together cleanly instead of \n    // all this ad-hoc stuff FIXME\n    return Hit(ds,\n               mPipe); \n}\n\n\nvec3 nScene(vec3 p, float h, out float d)\n{\n    vec3 n = vec3(\n          dScene(p + vec3(h,0,0)).d\n        , dScene(p + vec3(0,h,0)).d\n        , dScene(p + vec3(0,0,h)).d\n      ) - (d = dScene(p).d);\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n\nHit tScene(vec3 ro, vec3 rd, float rate, int iters)\n{\n    Hit c = Hit(3.4e38, mSky);\n    int i = iters;\n    float t = 0.;\n    const float thresh = 3e-3;\n    while (i-- > 0) {\n        Hit h = dScene(ro + rd * t);\n        float d = h.d;\n        t += d * rate;\n        if (abs(d) < abs(c.d)) {\n            c = h; \n        \tif (abs(d) < thresh)\n        \t    break;\n        }\n        if (rd.y >= 0. && ro.y + rd.y * t > 1.5) {\n         \tt = 8.5e4; break; // ray missed all solid objects!  Don't bother tracing into sky.\n        }\n    }\n    int m = c.m;\n    if (abs(c.d) > thresh * 2.) m = mSky;\n    const float dmax = 8.5e4; //1e4; //9e3; //\n    if (true && m == mSky) { // HACK different rescue\n        if (rd.y >= 0. && ro.y > -1.)\n            t = dmax;\n        else \n            m = mPipe;\n    }\n    c.m = m;\n    c.d = clamp(t, 0., dmax);\n    return c;\n}\n\n// compute material (albedo for now) from id\nvec3 Material(int i)\n{\n    vec3 a;\n    switch (i) {\n      default:\n      case mSky:  a = vec3(0); break;\n      case mPipe:  a = vec3(.5); break;\n    }\n    return a;\n}\n\n// TODO needs a headlight!!\n// TODO needs specular\n// TODO fake sun shadows\nvec3 Light(int m, vec3 p, vec3 v, float t, float vig)\n{    \n    float hd; // receives distance at hit point\n    vec3 n = nScene(p, .004, hd)\n    , albedo = Material(m)\n    , c = vec3(1); // lite color\n    if (m == mSky) // m <= 0)\n        t = 8.5e4;\n    albedo *= mix(vec3(.5), \n        cos(vec3(0,2,4)+tau*phi*(floor(tilediv(p.x))+29.*floor(tilediv(p.z))))\n            , p.y < -1. ? .0 : .4); // desaturate for pastel pipe colors\n    c *= albedo;\n    float nv = max(0., dot(n, v))\n    , nl = dot(n, sunDir)\n    , lite = mix(nl, 1., .5)\n    , spot = (1. - vig) * exp2(-.1*t);\n    lite += spot *  .7 * nv; // dim headlight HACK\n    lite += spot * 2.0 * pow(nv, 16.); // fake spec FIXME need schlick fresnel\n    c *= lite;\n    // fake ambient occlusion\n    float d2 = dScene(p + n * aod).d\n    , ao = mix(clamp(d2 / aod, 0., 1.), 1., .2);\n    c *= sqrt(ao); // TODO needs enough sensitivity to detect curvature of the interior of pipes!\n    //c *= clamp(.5-.5*dMaze(hp), 0., 1.); // FIXME antialiasing! but just debugging it actually\n    c = mix(csky, c, exp2(-fogdensity * t)); // simple fog Beer's law\n    //c *= vec3(mix(exp2(-.2 * t), 1., .2)); // DEBUG black depth fog\n    //c *= rd * .5 + .5; // DEBUG ray dir\n    //c *= n * .5 + .5; // DEBUG hit normal\n    return c;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// from Fly Camera https://shadertoy.com/view/tdsfR4\n// with iterative collision detection\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define Kbd  iChannel3\n\nconst float \n  eyeradius = .2\n, eyespeed = 10. //\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n, eyeh = 3. //0. //.75 - eyeradius //\n;\n\nconst int\n  eyesteps = 3\n;\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    bool button;\n    float dt; // delta time seconds\n    // debug features TODO\n};\n    \nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_G     = 71\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n, KEY_PGUP  = 33\n, KEY_PGDN  = 34\n// key bindings to local directions\n#if 0 // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0 // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE // up - maybe PgUp/Dn?\n, KEY_DW    = KEY_C     // down - anything but control!\n//, KEY_F     = 70\n//, KEY_R     = 82\n//, KEY_V     = 86\n//, KEY_X     = 88\n//, KEY_TAB   = 9\n;\n\nfloat key(int vk)\n{\n    return step(.5, texelFetch(Kbd, ivec2(vk, 0), 0).x);\n}\n\nbool option(int vk)\n{\n    return .5 <= texelFetch(Kbd, ivec2(vk,2), 0).x;\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    inp.move = vec3(key(KEY_RT) - key(KEY_LF)\n                  , key(KEY_UW) - key(KEY_DW)\n                  , key(KEY_FW) - key(KEY_BW));\n    inp.move += vec3(key(KEY_RIGHT) - key(KEY_LEFT)\n                  , key(KEY_PGUP) - key(KEY_PGDN)\n                  , key(KEY_UP) - key(KEY_DOWN));  // arrows for alternate input\n    if (iMouse.z >= 0. && dot(iMouse.xy, iMouse.xy) < 2.) { // preview icon?\n        inp.mouse.y = R.y*.5; // don't look at ground\n        inp.mouse.x = iTime * -.01 * R.x;\n        inp.move.z = .1;\n    }\n    inp.dt = iTimeDelta; //1./30.; //1./60.; // can lock frame delta for debugging\n}\n\nvec3 CollideSphere(vec3 pos, float radius)\n{\n    float d;\n    vec3 n = nScene(pos, radius, d);\n    pos -= n * min(0., d - radius * .7); // collision\n    n = nScene(pos, radius, d);\n    pos -= n * min(0., d - radius * .9); // again!\n//    n = SceneNormal(pos, radius, d);\n//    pos -= n * min(0., d - radius); // again! helps with getting stuck in crevices\n//    pos.y = max(pos.y, radius); // HACK prevent going beneath ground plane just in case\n    return pos;\n}\n\nvoid MoveCamera(inout State state, Inputs inp) \n{\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed;\n    if (key(KEY_SHIFT) > .5) spd *= 4.;\n    vec3 op = state.eyepos\n    , move = inp.move * inp.dt * spd \n    , p = op;\n    move /= float(eyesteps);\n    for (int i = eyesteps; i-- > 0; ) {\n    \tp += view * move;\n    \tp = CollideSphere(p, eyeradius);\n    }\n    state.eyepos = p;\n    state.eyevel = (p - op) / max(1e-7, iTimeDelta);\n    float evl2 = dot(state.eyevel, state.eyevel);\n    state.eyevel *= isnan(evl2) ? 0. : evl2 > 1e4 ? .5 : 1.;\n}\n\nvoid TurnCamera(inout State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution)\n    , oa = state.eyeaim\n    , a = inp.mouse / R;\n    a.x = fract(a.x * eyespin);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    a = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate\n    state.eyeaim = a;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(0,eyeh,-5);\n        state.eyeaim = vec2(0.,.5);\n    } else { // update state\n\t    MoveCamera(state, inp);\n\t    TurnCamera(state, inp);\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    bool init = iFrame == 0;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    vec4 c = init\n        ? vec4(0,0,0,1)\n     \t: fetch(BufA, i);\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n    SaveState(c, state, i);\n    o = c;\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}