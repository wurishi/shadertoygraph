{"ver":"0.1","info":{"id":"3ljBRR","date":"1598652132","viewed":102,"name":"Limited","username":"JacobC","description":"Faking IL/GI with ray marching and some reflections\nYou can move the camera by clicking the canvas and drag with the mouse","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","gi","reflections","ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Limited\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n#define T iTime\n\nstruct mat\n{\n    float depth;\n    vec3 col;\n    vec3 i_col;\n    float ao;\n    float ref;\n};\n    \nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat uop(in mat a, in mat b)\n{\n    float s = max(a.depth, b.depth);\n    float ao = map(s, 1., 2.8, 4.2);\n    s = map(s, 1., 1.4, 3.6);\n    return mat\n        (\n            min(a.depth, b.depth),\n            a.depth < b.depth ? a.col : b.col,\n            a.i_col * mix(a.depth > b.depth ? a.col : b.col, vec3(1.), s),\n            a.ao * ao,\n            a.depth < b.depth ? a.ref : b.ref\n        );\n}\n\n#define op0 vec3(cos(T)*6., 1., -sin(T)*6.)\n#define op1 vec3(0., 1., cos(T)*6.)\n#define op2 vec3(-cos(T)*6., 1., -sin(T)*6.)\n#define op3 vec3(0., -101., 0.)\n#define op4 vec3(0., -.5, 0.)\n\n#define oc0 vec3(.5, 1., 0.)\n#define oc1 vec3(1., 1., 1.)\n#define oc2 vec3(.5, 0., 1.)\n#define oc3 vec3(.5)\n\nvec3 h23(in vec2 p)\n{\n    return vec3\n        (\n            fract(sin(dot(p, vec2(90.12, 89.1))) * 41.),\n            fract(sin(dot(p, vec2(87.28, 76.3))) * 92.),\n            fract(sin(dot(p, vec2(40.61, 44.5))) * 65.)\n        );\n}\n\nmat scene(in vec3 p)\n{\n    vec3 icol = vec3(1.);\n    \n    mat o0 = mat(cube(p - op0, vec3(2.), max(abs(sin(T) * 2.), .4)), oc0, icol, 1., .25);\n    mat o1 = mat(cube(p - op1, vec3(2.), 2.), oc1, icol, 1., 0.);\n    mat o2 = mat(cube(p - op2, vec3(2.), max(abs(sin(T) * 2.), .4)), oc2, icol, 1., .001);\n    mat o3 = mat(cube(p - op3, vec3(100.), 1.), oc3, icol, 1., 0.);\n    \n    vec3 q = p;\n    bvec2 b = equal(greaterThan(q.xz, vec2(-60.)), lessThan(q.xz, vec2(60.)));\n    float s = 10.;\n    vec2 iq = floor(q.xz / s);\n    vec3 cq = h23(iq);\n    q.xz = b.x && b.y ? mod(q.xz, s) - s * .5 : q.xz;\n    \n    mat o4 = mat(cube(q - op4, vec3(.5), .5), cq  * 1.5, icol, 1., 0.);\n    \n    mat o = uop(o0, o2);\n    o = uop(o, o3);\n    o = uop(o, o1);\n    o = uop(o, o4);\n    \n    return o;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).depth;\n    vec3 n = d - vec3(scene(p - e.xyy).depth, scene(p - e.yxy).depth, scene(p - e.yyx).depth);\n    return normalize(n);\n}\n\n#define STEPS 99\n#define MIN_DIST .01\n#define MAX_DIST 99.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.depth;\n        if (s.depth < MIN_DIST)\n            return mat(t, s.col, s.i_col, s.ao, s.ref);\n        if (t > MAX_DIST)\n            return mat(t, vec3(-1.), vec3(-1.), -1., -1.);\n    }\n    return mat(t, vec3(-1.), vec3(-1.), -1., -1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\n#define AA 2.\n#define gd vec3(1., 1., 1.)\n#define sk vec3(.5, .7, 1.)\n#define R 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 f_col;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st - n - iResolution.xy * .5) / iResolution.y;\n            vec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n            \n            float sn = sin(ms.x);\n            vec3 o;\n            if (iMouse.z > 0.)\n            \to = vec3(ms.x * 3., max(ms.y * 3., 0.), 2.) * 8.;\n            else\n                o = vec3(12., 8., 20.);\n            vec3 d = camera(uv, o, vec3(0., 0., 0.));\n            \n            vec3 back = mix(gd, sk, d.y * .5 + .5);\n            vec3 col = vec3(0.);\n            \n            mat m = marcher(o, d);\n            if (m.ao >= 0.)\n            {\n                vec3 p = o + d * m.depth;\n                vec3 n = normal(p);\n                back = mix(gd, sk, n.y * .5 + .5);\n                \n                col += m.col * m.i_col * m.ao * back;\n                if (m.ref > .0)\n                {\n                    vec3 i = normalize(p - o);\n                    d = reflect(i, n);\n                    o = p + d * .05;\n                    m = marcher(o, d);\n                    for (int r = 0; r < R; r++)\n                    {\n                        if (m.ao >= 0.)\n                        {\n                            \n                            if (m.ref > 0.)\n                            {   \n                                p = o + d * m.depth;\n                \t\t\t\tn = normal(p);\n                                \n                            \tcol *= m.col * m.i_col * m.ao * back;\n                                \n                                i = normalize(p - o);\n                                d = reflect(i, n);\n                                o = p + d * .05;\n                                m = marcher(o, d);\n                            }\n                            else\n                               col *= m.col * m.i_col * m.ao * back;\n                        }\n                        else\n                            col *= back;\n                    }\n                }\n            }\n            else\n                col = back;\n            \n            f_col += col;\n        }\n    }\n\n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col), 1.);\n}","name":"Image","description":"","type":"image"}]}