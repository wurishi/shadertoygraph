{"ver":"0.1","info":{"id":"ctlSRs","date":"1675460215","viewed":39,"name":"Continuous space deformation","username":"JeanArthurDeda","description":"Reflection study in a continuous and monotonic deformation of space (and only space).\nThe angle between the trajectory and the surface, measured in the deformed space, doesn't change, resulting the in the same outcome regardless of the space deformation.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n//#define VIEW_DISTANCES\n//#define DEGENERATED\n\nfloat phys_aproax_def(float r, float m)\n{\n    // using the newtonioan aproximation of Einstein spacetime deformation which is\n    // dST(r) = dV(r) where V is the gravitational potential V(r)=-g*m/r hence\n    // dST(r) = g*m/r^2\n    // and I'm using the aproximated dST(r) model to deform only the space i.e. dS\n    float v = 9.8*m/(r*r);\n    // I should used the Gaussian error function erf(x)=(2/sqrt(π))*∫(0,x)e^(-t^2)dt\n    // to map from (0,oo) => (1,0) but even with taylor expansion the results are not\n    // that good so I'm using a dirty atan hack for the mapping\n    float d = atan(v)/(PI*0.5);\n    return mix(r, r*2.0, d); // Don't look here\n}\nvec2 phys_aproax_def(vec2 uv, vec2 c, float m)\n{\n    vec2 a = uv - c;\n    float l = length(a);\n    return c+a/l*phys_aproax_def(l, m);\n}\n\nvec2 inf_line(vec2 c, vec2 n, vec2 uv){ return vec2(abs (dot(uv-c, n)), abs (dot(uv-c, vec2(n.y, -n.x)))); }\n\nvec2 line (vec2 p1, vec2 p2, vec2 uv)\n{\n    vec2 t = p2-p1;\n    float l = length(t);\n    vec2 f = t/l;\n    vec2 p = vec2(f.y, -f.x);\n    float x = dot(uv-p1,f);\n    if (x < 0.0) return vec2(length(uv-p1), abs(x));\n    if (x > l) return vec2 (length(uv-p2), abs(x));\n    return vec2(abs(dot(uv-p1,p)), abs(x));\n}\n\nvec2 circle(vec2 c, float r, vec2 uv){return vec2 (abs(length(uv-c)-r), 1.0);}\n\nvec2 circle_full(vec2 c, float r, vec2 uv){return vec2 (length(uv-c)-r, 1.0);}\n\nvec2 opU(vec2 a, vec2 b){return a.x < b.x ? a : b;}\n\nvec2 scene (vec2 uv, float t)\n{\n    float c = cos(t * 0.1);\n    float s = sin(t * 0.1);\n    uv = vec2\n    (\n        uv.x*c + uv.y*s,\n        uv.x*s - uv.y*c\n    );\n    vec2 d = vec2 (999999999999.0, 0.0);\n\n    float l = 2.0;\n    for (float x = -l; x <= l; x+=0.14)\n    {\n        d = opU(d, inf_line(vec2(x, 0), vec2(1,0), uv));  \n        d = opU(d, inf_line(vec2(0, x), vec2(0,1), uv));\n    }\n\n#ifndef VIEW_DISTANCES\n    vec2 z = vec2(-0.2, -0.34);\n    // reflected item path\n    d = opU(d, circle_full(z+vec2(0, 0.7), 0.03, uv));\n    d = opU(d, line(z+vec2(0, 0.7), z+vec2(0.35, 0.35), uv));\n    d = opU(d, line(z+vec2(0.0, 0.0), z+vec2(0.35, 0.35), uv));\n    \n    // reflected item\n    float a=mod(t,2.0);\n    d = opU(d,circle_full(\n            a < 1.0 ? \n            z + mix(vec2(0, 0.7),vec2(0.35, 0.35),a) : \n            z + mix(vec2(0.35, 0.35),vec2(0.0, 0.0),a-1.0),\n            0.01, uv));\n    if (a<1.0)\n        d = opU(d, circle_full(z+vec2(0.0, 0.0), 0.02*(1.0-a), uv));\n    else\n        d = opU(d, circle(z+vec2(0.35, 0.35), 0.02*(2.0-a), uv));\n    \n    // surface\n    d = opU(d, line(z+vec2(0.35, 0.1), z+vec2(0.35, 0.6), uv));\n\n    // surface dart\n    d = opU(d, line(z+vec2(0.25, 0.35), z+vec2(0.35, 0.35), uv));\n    d = opU(d, line(z+vec2(0.25, 0.35), z+vec2(0.27, 0.33), uv));\n    d = opU(d, line(z+vec2(0.25, 0.35), z+vec2(0.27, 0.37), uv));\n    \n    // sensor array dart\n    d = opU(d, line(z+vec2(0.0, -0.02), z+vec2(0.1, -0.02), uv));\n    d = opU(d, line(z+vec2(0.08, 0.00), z+vec2(0.1, -0.02), uv));\n    d = opU(d, line(z+vec2(0.08, -0.04), z+vec2(0.1, -0.02), uv));\n    \n    // sensor array\n    d = opU(d, line(z+vec2(0.0, 0.05), z+vec2(0.0, -0.09), uv));\n    d = opU(d, line(z+vec2(0.0, 0.05), z+vec2(-0.15, -0.02), uv));\n    d = opU(d, line(z+vec2(0.0, -0.09),z+vec2(-0.15, -0.02), uv));\n    d = opU(d, circle_full(z+vec2(-0.06, -0.02), 0.035, uv));\n#endif\n    return d;\n}\n\nvec2 space(vec2 uv, float time, vec4 mouse)\n{\n    vec2 r = uv;\n    float num = 3.0;\n    for (float i = 0.0; i < num; i += 1.0)\n    {\n        vec2 c = vec2(cos(time*0.1+i), sin(time*0.5*(1.0+i))) * 0.5;\n        r = phys_aproax_def(r, c, 0.01/num);\n    }\n#ifdef DEGENERATED\n    r.x += tan(r.y-1.7) * 0.003;\n#endif\n    if (mouse.z > 0.0)\n        return mix (r, uv, smoothstep(-0.2, 0.2, uv.x-(mouse.x-0.5)*2.0));\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ruv = fragCoord/iResolution.xy;\n    vec2 uv = (ruv-0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 nmouse = vec4(iMouse.x / iResolution.x, iMouse.y / iResolution.y, iMouse.z, iMouse.w);\n    bool isinquad = (ruv.x<0.2&&ruv.y<0.2);\n    vec2 sp =isinquad ? vec2(uv.x*5.0+3.5,uv.y*5.0+2.0) : space(uv,iTime,nmouse);\n    vec2 s = scene (sp, iTime);\n    s *= isinquad ? 0.4 : 1.0;\n#ifdef VIEW_DISTANCES\n    float c = s.x<0.004?mod(s.y,1.0):0.0;\n#else\n    float c = clamp(s.x/0.004, 0.0, 1.0);\n#endif\n    fragColor = vec4(c, c, c ,1.0);\n}","name":"Image","description":"","type":"image"}]}