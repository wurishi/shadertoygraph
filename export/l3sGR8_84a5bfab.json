{"ver":"0.1","info":{"id":"l3sGR8","date":"1707209172","viewed":106,"name":"voronoi lava 2","username":"Moghammed","description":"Voronoi lava","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","lava"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n/*\n    static.frag\n    by Spatial\n    05 July 2013\n*/\n\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat distt( vec2 from, vec2 to, float idk ) { return pow(clamp(distance(from, to) + (0.7), 0.0, 1.0), 1.0 - idk); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.y, iResolution.x);\n    //vec2 zero = iResolution.xy / 2.0;\n    vec2 zero = normalize(iResolution.xy);\n    float slowTime = 0.03 * iTime + 1.35;\n    \n    float dist = 99999.0;\n    vec2 point = vec2(0., 0.);\n    vec2 neighbours[5] = vec2[5](vec2(99999.0, 99999.0), vec2(99999.0, 99999.0), vec2(99999.0, 99999.0), vec2(99999.0, 99999.0), vec2(99999.0, 99999.0));\n    float fromC = 0.0;\n    for(int i=0; i<80; i++) {\n        float d = float(i);\n        float timeOffset = tan(random(d));\n        float distanceFromCenter = sin(mod(timeOffset*slowTime + 1.0, 1.6));\n        vec2 newPoint = vec2(zero.x + distanceFromCenter * cos(d), zero.y + distanceFromCenter * sin(d));\n        for(int j = 5; j >= 0; j--) {\n            if(distance(uv, neighbours[j]) >= distance(uv, newPoint)) {\n                if(j == 0) {\n                    neighbours[j] = newPoint;\n                } else {\n                    neighbours[j] = neighbours[j-1];\n                }\n            }\n            else if(j < 5) {\n                neighbours[j+1] = newPoint;\n                break;\n            }\n        }\n    }\n    float distanceFromCenter = distance(neighbours[0], zero);\n\n    vec3 rockCol = vec3(.0,.0,.0);\n    vec3 lavaCol = vec3(1.0,pow(distance(uv, neighbours[0]) * 3.0, 1.01), 0.);\n    vec3 col = mix(lavaCol, rockCol, smoothstep(.0, 0.8, distanceFromCenter * 5.5));\n    \n    dist = pow(distance(uv, neighbours[0]) * 3.0, 1.01);\n    \n    \n    float mult = smoothstep(.0, 1.0, distanceFromCenter * 4.0);\n    float toBeat = pow(distance(uv, neighbours[0]) * 5.0, 1.15) * (50.85 - 50.0 * mult * pow(distanceFromCenter, 0.006))  ;\n    \n    if(distanceFromCenter < 0.2) {\n        col = lavaCol;\n    } else {\n        float maxd = 0.;\n        for(int i = 1; i <= 5; i++) {\n            float d = pow(distance(uv, neighbours[i]) * 5.0, 1.01);\n            if(pow(distance(uv, neighbours[i]) * 5.0, 1.01) < toBeat) {\n                maxd = max(maxd, toBeat - d);\n            }\n        }\n        col = mix(rockCol,lavaCol, smoothstep(0.00, .02, maxd));\n    }\n\n        \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}