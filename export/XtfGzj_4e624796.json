{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// \"Space Racing Lite\"  \n\n// Distance function and initial design for space car is by eiffie:\n// https://www.shadertoy.com/view/ldjGRh\n// the rest is by me but he also helped to optimize the code.\n\n// I removed some features by default because the original was crashing the Shadertoy browser\n// for win7 users - try commenting this lines to see if the full version compiles for you: \n\n//#define LOW_QUALITY // No reflections, no shadows, no planet, reduced ray steps & detail\n//#define NO_HUD \n\n#define LOOP_BREAKS // Could speed up, speed down, or just make your browser crash!\n\n\n\n#ifdef LOW_QUALITY\n\t#define RAY_STEPS 65\n\t#define SHADOW_STEPS 0\n\t#define ITERATIONS 5\n\t#define MAX_DIST 30.\n#else\n\t#define RAY_STEPS 75\n\t#define SHADOW_STEPS 40\n\t#define ITERATIONS 6\n\t#define MAX_DIST 35.\n#endif\n#define LIGHT_COLOR vec3(1.,.85,.6)\n#define AMBIENT_COLOR vec3(.7,.85,1.)\n#define SUN_COLOR vec3(1.,.8,.5)\n#define TUBE_COLOR vec3(1.,.6,.25)*1.2\n#define CAR_COLOR vec3(.4,.7,1.)\n#define TURBINES_COLOR vec3(.6,.75,1.)\n#define HUD_COLOR vec3(0.6,1.,0.3)\n#define PLANET_COLOR vec3(101., 153., 189.)/256.\n\t\n#define CAR_SCALE 4.\n#define SPECULAR 0.4\n#define DIFFUSE  2.0\n#define AMBIENT  0.4\n\n#define BRIGHTNESS .9\n#define GAMMA 1.1\n#define SATURATION .85\n\n\n#define DETAIL .004\n#define SPEED 8.\n#define t (mod(iTime,500.)+10.)*SPEED\n\n#define LIGHTDIR normalize(vec3(0.6,-0.2,-1.))\n\n// ------------------------------------------------------------------\n//    Global Variables\n// ------------------------------------------------------------------\n\nfloat FOLD=2.; // controls fractal fold and track width\nconst vec3 planetpos=vec3(-3.5,1.,-5.); // planet position\nconst vec2 tubepos=vec2(0.35,0.); // light tubes pos relative to FOLD\nmat2 trmx;//the turbine spinner\nfloat det=0.; // detail level (varies with distance)\nfloat backcam; // back cam flag\nvec3 carpos; // car position\nvec3 carvec; // car pointing vector\nmat3 carrot; // car rotation\nfloat hitcar; // ray-car hit flag\nmat2 fractrot; // rot mat for fractal (set in main)\nmat2 cartilt; // secondary car rotation\nfloat minT, minL; // min distance traps for glows of tube and turbines\nfloat ref; // reflection flag\nfloat tubeinterval; // tube tiling (for glow and lighting)\n\n\n// ------------------------------------------------------------------\n//    General functions \n// ------------------------------------------------------------------\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nfloat smin(float a,float b,float k){return -log(exp(-k*a)+exp(-k*b))/k;}//from iq\n\nfloat Sphere(vec3 p, vec3 rd, float r){\n\tfloat b = dot( -p, rd );\n\tfloat inner = b * b - dot( p, p ) + r * r;\n\tif( inner < 0.0 ) return -1.0;\n\treturn b - sqrt( abs(inner) );\n}\n\n\n// ------------------------------------------------------------------\n//    Track \n// ------------------------------------------------------------------\n\n// the track function, just some curves\nvec3 path(float ti) { \n\tfloat freq=.5, amp=1.; // for trying different settings\n\tti*=freq;\n\tfloat x=cos(cos(ti*.35682)+ti*.2823)*cos(ti*.1322)*1.5;\n\tfloat y=sin(ti*.166453)*4.+cos(cos(ti*.125465)+ti*.17354)*cos(ti*.05123)*2.;\n\tvec3  p=vec3(x,y,ti/freq);\n\treturn p;\n}\n\n// see if we are in the tunnel, and used also by distance function\nfloat tunnel(float z) {\nreturn abs(100.-mod(z+15.,200.))-30.;\n}\n\n\n// ------------------------------------------------------------------\n//    DE functions\n// ------------------------------------------------------------------\n\n\n// carcarspacecar by eiffie // (with some mods by Kali)\n// a reconfig of the carcar's tires (someday I will have to do an animation from the original to this)\n//the DE looks a bit long but there are actually fewer instructions than the car\n\nfloat carcarDE(in vec3 p0){\n\tp0.xy*=cartilt;\n\tp0*=CAR_SCALE;\n\tvec3 p=p0;\n\tp.y+=1.24;\n\tfloat r=length(p.yz);\n\tfloat d=length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.05);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz);\n\tp.xyz-=vec3(0.72,0.0,1.06);\n\tfloat w1=0.23,w2=0.24;\n\tif(p0.z<0.0){//this is discontinuous yet works unless you stand in front of the rear turbines\n\t\tw1=0.23,w2=0.05; //where you would get sucked into the blades anyways\n\t\tp=p.xzy; //so i'm comfortable with it :)\n\t} \n\tr=length(p.xy);\n\td=smin(d,length(vec2(max(abs(p.z)-w2,0.0),r-w1))-0.02,8.0);//done with the car shape, the rest is just turbines and could be replaced with lights or something\n\td=min(d,(length(p*vec3(1.,1.,.6))-.08-p0.z*.03));\n\tp.xy=trmx*p.xy;//spin\n\tfloat d2=min(abs(p.x),abs(p.y))*.15;//4 blades\n\t//p.xy=mat2(0.707,-0.707,0.707,0.707)*p.xy;//45 degree turn\n\t//d2=min(d2,min(abs(p.x),abs(p.y))*.2);//8 blades\n\td2=max(r-w1-.05,max(d2-0.005,abs(p.z)-w2+0.04));\n\td2=min(d2,(length(p)-.05-p0.z*.035)*.07);\n\td2=min(d2,max(d+.02,max(abs(p0.y-.07),abs(p0.x)-.4+min(0.,p0.z)))*.18);\n\tminL=min(minL,d2);//catch the minimum distance to the glowing parts\n\t// I used d2 only for glows (Kali)\n\treturn d/CAR_SCALE;// *carScale\n}\n\n\nvec3 carcarCE(in vec3 p0){//coloring\n\tp0*=CAR_SCALE;\n\tvec4 trpc=vec4(0.);//color trap (taking samples when finding the norm)// not for now (Kali)\n\n\t//right here you should inv-transform p0 as it gets used later\n\t//p0=(p0-carPos)*carRot/carScale;//or something like that??\n\tp0.xy*=cartilt;\n\tvec3 p=p0;\n\tp.y+=1.24;\n\tfloat r=length(p.yz);\n\tfloat d=length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz);\n\tp.xyz-=vec3(0.72,0.0,1.06);\n\tfloat w1=0.2,w2=0.24;\n\tif(p0.z<0.0){//this is discontinuous yet works unless you stand in front of the rear turbines\n\t\tw1=0.23,w2=0.05; //where you would get sucked into the blades anyways\n\t\tp=p.xzy; //so i'm comfortable with it :)\n\t}\n\tr=length(p.xy);\n\td=smin(d,length(vec2(max(abs(p.z)-w2,0.0),r-w1))-0.02,8.0);//done with the car shape, the rest is just turbines and could be replaced with lights or something\n\tp.xy=trmx*p.xy;\n\tfloat d2=min(abs(p.x),abs(p.y));//4 blades\n\tp.xy=mat2(0.707,-0.707,0.707,0.707)*p.xy;//45 degrees\n\td2=min(d2,min(abs(p.x),abs(p.y)));//8 blades\n\td2=max(r-w1+0.02,max(d2-0.005,abs(p.z)-w2+0.04));\n\t//up to here it is the same as DE, now accumulate colors\n\tif(d2<d){d=d2;trpc+=vec4(1.,0.6,0.3,256.0);}//turbines\n\telse {//the car's body\n\t\tp0.x=abs(p0.x);\n\t\tif((abs(p0.y-0.58)>0.05-p0.z*0.09 || p0.z>0.25) && \n\t\t   length(max(abs(p0.xz+vec2(-p0.z*.03,-0.5))-vec2(0.15+p0.z*.03,0.4),0.0))>0.1)\n\t\t\ttrpc+=vec4(CAR_COLOR,16.0);\n\t\telse trpc+=vec4(CAR_COLOR*.4,2.0);//the windsheild\n\t}\n\treturn trpc.xyz; // *carScale\n}\n\n//-------------------------------------------\n\n// DE for tubes\nfloat tubes(vec3 pos) {\n\tpos.x=abs(pos.x)-tubepos.x-FOLD;\n\tpos.y+=tubepos.y;\n\treturn (length(pos.xy)-.05);\n}\n\n// ------------------------------------------------------------------\n//    SCENE DE\n// ------------------------------------------------------------------\n\nfloat de(vec3 pos) {\n\tvec3 carp=pos-carpos; // scale car coordinates\n\tcarp=carrot*carp; // rotate car\n\tpos.xy-=path(pos.z).xy; // transform coordinates to follow track\n\tFOLD=1.7+pow(abs(100.-mod(pos.z,200.))/100.,2.)*2.; //varies fractal fold & track width\n\tpos.x-=FOLD;\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.z=abs(2.-mod(tpos.z,4.));\n\tvec4 p=vec4(tpos,1.);\n\tfor (int i=0; i<ITERATIONS; i++) { // calculate fractal\n\t\tp.xz=clamp(p.xz,-vec2(FOLD,2.),vec2(FOLD,2.))*2.0-p.xz;\n\t\tp=p*2.5/clamp(dot(p.xyz,p.xyz),.5,1.)-vec4(1.2,0.5,0.,-0.5);\n\t\tp.xy*=fractrot;\n\t}\n\tpos.x+=FOLD;\n\tfloat fr=min(max(pos.y+.4,abs(pos.x)-.15*FOLD),(max(p.x,p.y)-1.)/p.w); // fractal+pit\n\tfloat tub=tubes(pos);  \n\tminT=min(minT,tub*.5); // trap min distance to tubes\t\n\tfloat car=carcarDE(carp); \n\tfloat d=tub;\n\td=min(fr,d);\n\td=min(d,max(abs(pos.y-1.35+cos(3.1416+pos.x*.8)*.5)-.1,tunnel(pos.z))); // tunnel DE\n\tif (ref<1.) d=min(d,car);\n\td=max(d,abs(pos.x)-FOLD*2.);\n\tif (car<det) hitcar=1.; // ray hits the car!\n\treturn d;\n}\n\n\n// ------------------------------------------------------------------\n//    General Shading Functions\n// ------------------------------------------------------------------\n\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n#ifndef LOW_QUALITY \n\nfloat shadow(vec3 pos, vec3 sdir) {\n\tfloat sh=1.0;\n\tfloat totdist = DETAIL*10.;\n\tfloat dist=1000.;\n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<MAX_DIST && dist>DETAIL) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p);\n\t\t\t\tsh = min(sh, 10.*max(0.0,dist)/totdist);\n\t\t\t\tsh*= sign(max(0.,dist-DETAIL));\n\t\t\t\ttotdist += max(0.02,dist);\n\t\t\t}\n#ifdef LOOP_BREAKS\t\t\n\t\telse break;\n#endif\n\t\t}\n\t\n\treturn clamp(sh,0.,1.0);\n}\n\n#endif\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat hr,dd,aoi=0.,sca=1.,totao=0.;\n\thr = .075*aoi*aoi;dd = de(nor * hr + pos);totao += (hr-dd)*sca;sca*=.6;aoi++;\n\thr = .075*aoi*aoi;dd = de(nor * hr + pos);totao += (hr-dd)*sca;sca*=.55;aoi++;\n\thr = .075*aoi*aoi;dd = de(nor * hr + pos);totao += (hr-dd)*sca;sca*=.55;aoi++;\n\thr = .075*aoi*aoi;dd = de(nor * hr + pos);totao += (hr-dd)*sca;sca*=.55;aoi++;\n\treturn clamp( 1.0 - 4.*totao, 0., 1.0 );\n}\n\n\n// ------------------------------------------------------------------\n//    Light and Coloring\n// ------------------------------------------------------------------\n\n\n\nvec3 shade(in vec3 p, in vec3 dir, in vec3 n) {\n\n\tfloat savehitcar=hitcar;\n\n\tvec3 trackoffset=-vec3(path(p.z).xy,0.);\n\tvec3 pos=p;\n\tvec3 col=vec3(.5); // main color\n\tvec3 carp=pos-carpos; //scaled coordinates for the car\n\tcarp=carrot*carp; // rotate car\n\tpos+=trackoffset; // apply track transformation to the coordinates\n\t// track lines\n\tif (pos.y<.5) col+=pow(max(0.,.2-abs(pos.x))/.2*abs(sin(pos.z*2.)),8.)*TUBE_COLOR*2.;\n\tpos.x=abs(pos.x);\n\t// fake AO for the tunnel's upper corners\n\tif(tunnel(pos.z)<0.)\n\t\tcol*=1.-pow(max(0.5,1.-length(pos.xy+vec2(-FOLD*1.5,-.85))),5.)*max(0.,1.+pos.y);\n\tif (tubes(pos)<det) col=TUBE_COLOR; // hit tubes\n\tif (carcarDE(carp)<det) col=carcarCE(carp); // hit car, get coloring\n\n\tfloat ao=calcAO(p,n); // calc AO\n\tfloat camlight=max(0.,dot(dir,-n)); // camlight used for ambient\n\n\t// --- Tube lights ---\n\n\tvec3 tpos1=vec3((tubepos+vec2(FOLD,0.)),0.)+trackoffset; // get tube positions\n\tvec3 tpos2=tpos1-vec3((tubepos.x+FOLD)*2.,0.,0.);\n\t// light direction\n\tvec3 tube1lightdir=normalize(vec3(p.xy,0.)+vec3(tpos1.xy,0.)); \n\tvec3 tube2lightdir=normalize(vec3(p.xy,0.)+vec3(tpos2.xy,0.));\n\t// light falloffs\n\tfloat falloff1,falloff2;\t\n\tif (savehitcar>0.) {\n\t\tfalloff1=pow(max(0.,1.-.15*distance(vec3(p.xy,0.),vec3(-tpos1.xy,0.))),4.);\n\t\tfalloff2=pow(max(0.,1.-.15*distance(vec3(p.xy,0.),vec3(-tpos2.xy,0.))),4.);\n\t} else {\n\t\tfalloff1=pow(max(0.,1.-.2*distance(vec3(p.xy,0.),vec3(-tpos1.xy,0.))),4.);\n\t\tfalloff2=pow(max(0.,1.-.2*distance(vec3(p.xy,0.),vec3(-tpos2.xy,0.))),4.);\n\t}\n\t\n\tfloat diff, spec;\n\t\n\tvec3 r=reflect(LIGHTDIR,n);\n\t\n\t// tube1 calcs\n\tdiff=max(0.,dot(tube1lightdir,-n)); \n\tdiff+=max(0.,dot(normalize(tube1lightdir+vec3(0.,0.,.2)),-n))*.5; // add 2 more \n\tdiff+=max(0.,dot(normalize(tube1lightdir-vec3(0.,0.,.2)),-n))*.5; // with Z shifted\n\tspec=pow(max(0.,dot(tube1lightdir+vec3(0.,0.,.4),r)),15.)*.7;\n\tspec+=pow(max(0.,dot(tube1lightdir-vec3(0.,0.,.4),r)),15.)*.7;\n\tfloat tl1=(falloff1*ao+diff+spec)*falloff1;\n\n\t// tube2 calcs\n\tdiff=max(0.,dot(tube2lightdir,-n));\n\tdiff+=max(0.,dot(normalize(tube2lightdir+vec3(0.,0.,.2)),-n))*.5;\n\tdiff+=max(0.,dot(normalize(tube2lightdir-vec3(0.,0.,.2)),-n))*.5;\n\tspec=pow(max(0.,dot(tube2lightdir+vec3(0.,0.,.4),r)),15.)*.7;\n\tspec+=pow(max(0.,dot(tube2lightdir-vec3(0.,0.,.4),r)),15.)*.7;\n\tfloat tl2=(falloff2*ao+diff+spec)*falloff2;\n\n\t// sum tube lights - add ambient - apply tube intervall\n\tvec3 tl=((tl1+tl2)*(.5+tubeinterval*.5))*TUBE_COLOR;//*(1.+tun*.5);\n\n\n\t// --- Car lights ---\n\n\t// get the car turbines direction (aproximate)\n\tvec3 carlightdir1=normalize(p-carpos+vec3(.2,0.06,.15));\n\tvec3 carlightdir2=normalize(p-carpos+vec3(-.2,0.06,.15));\n\tvec3 carlightdir3=normalize(p-carpos+vec3(.2,0.06,-.35));\n\tvec3 carlightdir4=normalize(p-carpos+vec3(-.2,0.06,-.35));\n\n\tfloat cfalloff=pow(max(0.,1.-.1*distance(p,carpos)),13.); // car light falloff\n\n\t// accumulate diffuse\n\tdiff=max(0.,dot(carlightdir1,-n))*.5;\n\tdiff+=max(0.,dot(carlightdir2,-n))*.5;\n\tdiff+=max(0.,dot(carlightdir3,-n))*.5;\n\tdiff+=max(0.,dot(carlightdir4,-n))*.5;\n\n\tif (savehitcar<1.) diff*=clamp(1.-carlightdir1.y,0.,1.);\n\t\n\t// add ambient and save car lighting\n\tvec3 cl=TURBINES_COLOR*((diff+spec*.0)*cfalloff+cfalloff*.3)*1.2;\n \t\n\t// --- Main light ---\n\t\n#ifdef LOW_QUALITY\n\tfloat sh=ao;\n#else\n\tfloat sh=shadow(p, LIGHTDIR); // get shadow\n#endif\n\n\tdiff=max(0.,dot(LIGHTDIR,-n))*sh*1.3; // diffuse\n\tfloat amb=(.4+.6*camlight)*.6; // ambient+camlight\n\tspec=pow(max(0.,dot(dir,-r))*sh,20.)*SPECULAR; //specular\n\tif (savehitcar>0.) {diff*=.8;amb*=.3;}\n\tvec3 l=(amb*ao*AMBIENT_COLOR+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;\t\n\n\tif (col==TUBE_COLOR) l=.3+vec3(camlight)*.7; // special lighting for tubes\n\n\treturn col*(l+cl+tl); // apply all lights to the color\n}\n\n// the planet shading...\n// very simple and fast made, but for low res windowed mode it does the job :)\nvec3 shadeplanet(vec3 pos, vec3 k) { \n\n\tvec3 n=normalize(planetpos+pos+.2); // tweaked sphere normal\n\tfloat c=max(0.,dot(LIGHTDIR,normalize(k-n))); // surface value\n\tvec3 col=PLANET_COLOR+vec3(c,c*c,c*c*c)*.7; // surface coloring\n\t// add some noise\n\tfloat noi=max(0.,texture(iChannel1,n.yz*.5).x-.6);\n\tnoi+=max(0.,texture(iChannel1,n.yz).x-.6);\n\tnoi+=max(0.,texture(iChannel1,n.yz*2.).x-.6);\n\tcol+=noi*(1.5-c)*.7;\n\treturn col*max(0.,dot(LIGHTDIR,-n)); // diff light\n}\n\n// ------------------------------------------------------------------\n//    Raymarching + FX rendering\n// ------------------------------------------------------------------\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\thitcar=0.;\n\tref=0.;\n\tfloat totdist=0.;\n\tfloat glow=0.;\n\tfloat d=1000.;\n\tvec3 p=from, col=vec3(0.5);\n\n\tfloat deta=DETAIL*(1.+backcam); // lower detail for HUD cam\n\tvec3 carp=vec3(0.); // coordinates for car hit\n\tvec3 carn=vec3(0.); // normal for car\n\tfloat cardist=0.; // ray length for car\n\tvec3 odir=dir; // save original ray direction\n\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d>det && totdist<MAX_DIST) {\n\t\t\td=de(p);\n\t\t\tp+=d*dir;\n\t\t\tdet=max(deta,deta*totdist*.5*(1.+ref)); // scale detail with distance or reflect\n\t\t\ttotdist+=d; \n\t\t\tfloat gldist=det*8.; // background glow distance \n\t\t\tif(d<gldist&&totdist<20.) glow+=max(0.,gldist-d)/gldist*exp(-.1*totdist); //accum glow\n#ifndef LOW_QUALITY\n\t\t\tif (hitcar>0. && ref<1.) { // hit car, bounce ray (only once)\n\t\t\t\tp=p-abs(d-det)*dir; // backstep\n\t\t\t\tcarn=normal(p); // save car normal\n\t\t\t\tcarp=p; // save car hit pos\n\t\t\t\tdir=reflect(dir,carn); // reflect ray\n\t\t\t\tp+=det*dir*10.; // advance ray\n\t\t\t\td=10.; cardist=totdist;\n\t\t\t\tref=1.;\n\t\t\t}\n#endif\n\t\t} \n#ifdef LOOP_BREAKS\t\t\n\t\telse break;\n#endif\n\t}\n\n\ttubeinterval=abs(1.+cos(p.z*3.14159*.5))*.5; // set light tubes interval\n\tfloat cglow=1./(1.0+minL*minL*5000.0); // car glow\n\tfloat tglow=1./(1.0+minT*minT*5000.0); // tubes glow\n\tfloat l=max(0.,dot(normalize(-dir),normalize(LIGHTDIR))); // lightdir gradient\n\tvec3 backg=AMBIENT_COLOR*.4*max(0.1,pow(l,5.)); // background\n\tfloat lglow=pow(l,50.)*.5+pow(l,200.)*.5; // sun glow\n\n\tif (d<.5) { // hit surface\n\t\tvec3 norm=normal(p); // get normal\n\t\tp=p-abs(d-det)*dir; // backstep\n\t\tcol=shade(p, dir, norm); // get shading \n\t\tcol+=tglow*TUBE_COLOR*pow(tubeinterval,1.5)*2.; // add tube glow\n\t\tcol = mix(backg, col, exp(-.015*pow(abs(totdist),1.5))); // distance fading\n\n\t} else { // hit background\n\t\tcol=backg; // set color to background\n\t\tcol+=lglow*SUN_COLOR; // add sun glow\n\t\tcol+=glow*pow(l,5.)*.035*LIGHT_COLOR; // borders glow\n\t\t\n#ifdef LOW_QUALITY\n\t\tvec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\n\t\tfor (int i = 0; i < 14; i++) st = abs(st) / dot(st,st) - .9;\n\n\t\tcol+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 ); // add stars\n#else\n\t\tfloat planet=Sphere(planetpos,dir, 2.); // raytrace planet\n\n\t\t// kaliset formula - used for stars and planet surface \n\t\tfloat c;\n\t\tif (planet>0.) c=1.; else c=.9; // different params for planet and stars\n\t\tvec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\n\t\tfor (int i = 0; i < 14; i++) st = abs(st) / dot(st,st) - c;\n\n\t\tcol+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 ); // add stars\n\t\t\n\t\t// planet atmosphere\n\t\tcol+=PLANET_COLOR*pow(max(0.,dot(dir,normalize(-planetpos))),100.)*150.*(1.-dir.x);\n\t\t// planet shading\n\t\tif (planet>0.) col=shadeplanet(planet*dir,st);\n#endif\n\t\t\n\t}\n\t// car shading\n\n\t\t// add turbine glows\n\t\n#ifdef LOW_QUALITY\n\tcglow*=1.15;\n#else\n\tif (ref>0.) {\n\t\tref=0.;\n\t\tcol=shade(carp,odir,carn)+col*.3; // car shade + reflection\n\t\t// I wanted a lighter background for backward reflection\n\t\tl=max(0.,dot(normalize(-odir),normalize(LIGHTDIR)));\n\t\tbackg=AMBIENT_COLOR*.4*max(0.1,pow(l,5.)); \n\t\tcol = mix(backg, col,exp(-.015*pow(abs(cardist),1.5))); // distance fading\n\t}\n#endif \n\n\t\n\tcol+=TURBINES_COLOR*pow(abs(cglow),2.)*.4;\n\tcol+=TURBINES_COLOR*cglow*.15;\n\n\n\treturn col; \n}\n\n// simple HUD track graph with transparency\nvec4 showtrack(vec2 p) {\n\tp.x+=.25;\n\tvec2 uv=p;\n\tfloat uvpos=uv.x+1.5;\n\tvec3 pth=path((uvpos-1.5)*30.+t)*.05;\n\tfloat curpos=path(t).x*.05;\n\tfloat curs=pow(max(0.,1.-length(uv+vec2(0.,curpos))*2.),10.)*max(0.5,sin(iTime*10.))*2.;\n\tuv.xy=uv.xy-(vec2(uvpos,0.))*rot(pth.x/uvpos);\n\tfloat dotline=pow(max(0.,1.-abs(uv.y)*5.),30.);\n\tfloat graph=(curs+dotline);\n\treturn vec4((graph+.4)*HUD_COLOR,1.-.5*pow(abs(.025-mod(p.y*2.,.05))/.025,2.));\n}\n\n\n// ------------------------------------------------------------------\n//    Main code - Camera - HUD \n// ------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tminL=minT=1000.; // initialize min distance glows\n\tfractrot=rot(.5); // mat2D for the fractal formula\n\tvec3 carpos0=vec3(0.,-0.2,.0); // set relative car pos (unused now, only sets height)\n\tcarpos=vec3(carpos0+vec3(0.,0.,t)); // real car pos\n\tvec3 carmove=path(carpos.z); carmove.x*=1.+FOLD*.1; // get pos, exagerate x pos based on track width.\n\tcarvec=normalize((path(carpos.z+2.)-carmove)*vec3(FOLD*.25,1.,1.)); // car fwd vector\n\tcarrot=lookat(-carvec,vec3(0.,1.,0.)); // car rotation\n\tcartilt=rot(-carvec.x*2.); // xy rotation based on distance from center\n\tcarpos.xy+=carmove.xy-vec2(carvec.x,0.)*FOLD*.5; // move away from center when turning\n\tfloat tim=iTime*12.0;\n\ttrmx=mat2(cos(tim),-sin(tim),sin(tim),cos(tim));//the turbine spinner\n\n\t// --- camera & mouse ---\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*vec2(7.,1.5);\n\tif (iMouse.z<1.) { // if no mouse, alternate rear and back cam\n\t\tmouse=vec2(sin(iTime)*.7,2.+sin(iTime*.2)*.22)\n\t\t\t*min(0.,sign(10.-mod(iTime,20.)));\n\t}\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\n\tvec3 campos=vec3(0.,0.2,-.6); // original relative camera position\n\t//rotate camera with mouse\n\tcampos.yz=(campos.yz-carpos0.yz)*rot(mouse.y)+carpos0.yz;\n\tcampos.xz=(campos.xz-carpos0.xz)*rot(mouse.x)+carpos0.xz;\n\tcampos.x-=carvec.x*FOLD; // follow car x pos a bit when turning\n\n\tvec3 from;\n\t\n\tfloat fixcam=5.;\n\tfloat mt=mod(t/SPEED,fixcam*2.);\n\t//fixed cam every 15 seconds, random position, point at car position\n\tif ((mod(iTime,20.)>15. && iMouse.z<1.)) {\n\t\tfixcam*=SPEED;\n\t\tfrom=path(floor(t/fixcam)*fixcam+fixcam*.5);\n\t\t//from.x+=.05;// from.y+=.5;\n\t\tvec2 fixpos=(texture(iChannel1,vec2(from.z*.21325)).xy-.5)*vec2(FOLD*2.-.3,1.);\n\t\tfixpos.x+=sign(fixpos.x)*.3; fixpos.y+=.2;\n\t\tfrom.xy+=fixpos;\n\t\tdir=lookat(normalize(carpos-from),vec3(0.,1.,0.))*normalize(dir+vec3(0.,0.,0.5));\n\n\t} else { //normal cam\n\t\tfrom=path(t+campos.z)+campos;\n\t\tdir.y-=.3*campos.z;\n\t\tdir=lookat(normalize(carpos-from),vec3(0.,1.,0.))*normalize(dir);\n\t}\n\n\tvec4 hud=vec4(0.);\n\t\n#ifndef NO_HUD\t\n\t//HUD (hud camera was going to be transparent but won't compile)\n\tbackcam=0.;\n\t\tvec2 huv=uv+vec2(.75,.44);\n\t\tif (length(huv*huv*huv*vec2(5.,50.))<.05) hud=showtrack(huv*2.); // track HUD\n\t\tuv+=vec2(-.75,.44);\n\t\tif (length(uv*uv*uv*vec2(5.,50.))<.05) { //set ray data for HUD cam\n\t\t\t\tbackcam=1.;\n\t\t\t\tuv*=6.;\n\t\t\t\tdir=normalize(vec3(uv.xy*.6,-1.));\n\t\t\t\tfrom=vec3(carvec.x*.5,0.1,0.)+path(t-campos.z*1.7);\n\t\t\t\tdir=lookat(-normalize(carpos-from),normalize(vec3(0.,1.,0.)))*dir;\n\t\t\t\t//color+=HUD_COLOR*(vec3(HUDraymarch(from,dir))+.1);\n\t\t}\n\n#endif\t\n\n\tvec3 color=raymarch(from,dir); \t// Raymarch scene\n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tif (backcam>0.) { //if HUD cam, apply post effect\n\t\tcolor=(.2+pow(length(color),1.7)*.5)*HUD_COLOR\n\t\t\t*(1.-.5*pow(abs(.025-mod(uv.y*.9,.05))/.025,2.))*.9;\n\t}\n\t\n\tcolor=hud.rgb*hud.a+color*(1.-hud.a);//HUD transparency\n\n\t//color adjustments\n\tcolor=pow(abs(color),vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n\tfragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XtfGzj","date":"1384884765","viewed":4878,"name":"Space Race","username":"Kali","description":"A collab with effie who made the distance function for the car - Mouse enabled","likes":116,"published":1,"flags":0,"usePreview":1,"tags":["space","race"],"hasliked":0,"parentid":"","parentname":""}}