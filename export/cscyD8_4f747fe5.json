{"ver":"0.1","info":{"id":"cscyD8","date":"1709761648","viewed":126,"name":"MacBook Pro M2","username":"lz","description":"Thought that this model deserved it's own entry. \n-- Mouse enabled.\nBuffer B contains the screen content and can be replaced with your stuff.\nScreen reflection by default off due to compilation on Windows (REFLECTION in Common Tab)","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["3d","laptop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    MacBook Pro M2. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define PI2 6.28318530718\n#define T_EPS 0.0001\n#define T_FAR 1000.\n\n#define r2(_p, _alpha) (cos(_alpha)*_p + sin(_alpha) * vec2(_p.y, -_p.x))\n\n#define Ryz(_alpha) mat4(1., 0., 0., 0., \\\n                         0., cos(_alpha), sin(_alpha), 0., \\\n                         0., -sin(_alpha), cos(_alpha), 0., \\\n                         0., 0., 0., 1.)\n#define Rxz(_alpha) mat4(cos(_alpha), 0., sin(_alpha), 0., 0., 1., 0., 0., -sin(_alpha), 0., cos(_alpha), 0., 0., 0., 0., 1.)\n\nvec3 targetOrigin = vec3(0., -1., 0.);\nvec2 debugRot = vec2(0.);\nmat4 trf = mat4(1.);\nmat4 scrTrf = mat4(1.);\nvec3 scrOff = vec3(0.);\nfloat scrRndSide = 0.;\n\nvec2 toUV(in vec4 _plane, in vec2 _p, in vec2 _reverse, in vec4 _txcrd)\n{\n    vec2 tx = ((_p - _plane.xy) / _plane.zw); // 0 - 1 range\n    tx = mix(tx, vec2(1.) - tx, _reverse); // reverse axes if needed\n    return _txcrd.xy + tx * _txcrd.zw; // convert to texture coordinates\n}\n\n/*float screen(in vec3 _p)\n{\n}\n*/\n\nvec2 laptop(in vec3 _p, bool _mtl, bool _norm)\n{\n    // --- origin location of the geometry\n    vec3 op = _p;\n    \n    //if (_mtl == true || iMouse.z > 0.5)\n    //{\n        trf = mat4(1.);// * Ryz(debugRot.y*2.);\n        trf *= Rxz(debugRot.x*1.57 + 0.*3.14);\n        trf[3].xyz -= targetOrigin;\n        //trf = transpose(trf);\n        op = (trf * vec4(op, 1.)).xyz;\n        //op -= targetOrigin;\n    //}\n    \n    //float dgeom = length(_p - targetOrigin) - 5.;\n    \n    float g;\n    \n    // bottom (keboard) plane\n    float r = 0.5;\n    g = sdBox(op, vec3(14. * 0.5 - r, 0.5 * 0.5, 9.75 * 0.5 - r));\n    g -= r;\n    g = max(g, op.y - 0.5 * r) - 0.01;\n    \n    // front cut\n    vec3 opc = op - vec3(0., 0.5 * 0.5, 9.75 * 0.5 + r);\n    opc.yz = opc.yz * 0.707 + vec2(opc.z, -opc.y) * 0.707;    \n    float gc = sdBox(opc, vec3(1., 0.25, 0.25)) - 0.25;\n    \n    g = max(g, -gc);\n    \n    // back cut\n    opc = op - vec3(0., 0.5 * 0.5, -(9.75 * 0.5));\n    gc = sdBox(opc, vec3(11.*0.5, 0.5 * 1.5, 0.25));\n    g = max(g, -gc);\n    \n    // pins\n    opc = vec3(abs(op.x), op.yz) - vec3(14. * 0.5 - 1.5, 0.0, -9.75 * 0.5 + 0.25);\n    g = min(g, sdCylX(opc, vec2(0.125, 0.8)));\n    \n    // left side jacks\n    // power\n    float gpc = sdCapsuleZExtrusion(op - vec3(14. * 0.5, 0., -9.5 * 0.5 + 1.075), 0.75, 0.12, .05);\n\n    // usb-c\n    opc = op - vec3(14.*0.5, 0., -9.5 * 0.5 + 2.7);\n    float gl = sdCapsuleZExtrusion(vec3(opc.xy, abs(opc.z)) - (vec3(0., 0., 0.175)), 0.33, 0.1, 0.262);\n    // headsets/mic\n    opc = op - vec3(14.*0.5, 0., -9.5 * 0.5 + 3.7);\n    gl = min(gl, max(length(opc.zy) - 0.137, abs(opc.x) - 0.3));\n    //\n    \n    // right side jacks\n    opc = op - vec3(-14.*0.5, 0., -9.5 * 0.5 + 2.675);\n    gl = min(gl, sdCapsuleZExtrusion(opc, 1., 0.1, 0.262));\n    \n    opc = op - vec3(-14.*0.5, 0., -9.5 * 0.5 + 1.9);\n    gl = min(gl, sdCapsuleZExtrusion(opc, 0.33, 0.1, 0.262));\n    \n    opc = op - vec3(-14.*0.5, 0.05,  -9.5 * 0.5 + 1.25);\n    float gct = max(sdBox(opc.zy, vec2(0.3, 0.05)), abs(opc.x) - 0.3) - 0.075;\n    opc = op - vec3(-14.*0.5, -0.1, -9.5 * 0.5 + 1.25);\n    gct = min(gct, \n        max(sdTrapezoid(opc.zy, vec2(0.075, 0.075), vec4(1., 1., -1., 1.), vec2(0.21)), abs(opc.x) - 0.3));\n    gl = min(gct, gl);\n    \n    // screen\n\n    // screen rotation\n    mat4 tmtx = mat4(1.);\n    scrOff = vec3(0., 0.175, 9.75 *0.5 - 0.125);\n    tmtx[3].xyz = scrOff - vec3(0., 0.15, 0.);\n    scrTrf = Ryz(clamp(1.45 + 1.5*debugRot.y, 0., 2.2));\n\n    scrTrf *= tmtx;\n\n    tmtx[3].xyz -= 2.*scrOff;\n\n    scrTrf = tmtx * scrTrf;\n\n    opc = (scrTrf * vec4(op, 1.)).xyz;\n\n    // screen\n    r = 0.5; // side rounds\n    float gs = sdBox(opc.xz, vec2(14. * 0.5 - r, 9.75 * 0.5 - r));\n    gs -= r;\n    \n    // on normal calculation this radius must be constant for all the samples.\n    //scrRndSide = mix(step(0., opc.y), scrRndSide, float(_norm));\n    r = 0.075; // top rounds\n    vec2 q = max(vec2(gs + r, abs(opc.y) - 0.5 * 0.25 + r), vec2(0.));\n    gs = length(q) - r;\n    \n    \n    // connecting panel -- attached to screen\n    vec3 opp = opc - vec3(0., -0.25, -9.75*0.5 + 0.125);\n    \n    tmtx = mat4(1.);\n    mat4 opTrf = mat4(1.);\n    //tmtx[3].xyz = scrOff*0.5;\n    opTrf = Ryz(-0.1);\n    opTrf *= tmtx;\n    //tmtx[3].xyz -= scrOff;\n    opTrf = tmtx * opTrf;\n    \n    opp = (opTrf * vec4(opp, 1.)).xyz;\n    \n    float gp = sdBox(opp, vec3(14. * 0.5 - 1.5, 0.25, 0.05));\n    float gps = sdSmUnion(gs, gp, 0.1);\n    float gf = max(max(min(gps, g), -gl), -gpc);\n    \n    float mtl = 0.;\n    \n    if (_mtl)\n    {\n        // Works here, but won't work for organics (where smooth min and max are used)\n        // In the latter case maybe steps with epsilons will work.\n        mtl += float(g == gf);\n        mtl += 2. * float(gs == gf);\n        mtl += 3. * float(gp == gf);\n        mtl += 4. * float(-gl == gf);\n        mtl += 5. * float(-gpc == gf);\n    }\n    \n    return vec2(gf, mtl);\n}\n\nvec2 room(in vec3 _p, bool _mtl)\n{\n    float f = -sdBox(_p, vec3(400., 100., 400.));\n    \n    return vec2(f, 10.);\n}\n\nvec2 map(in vec3 _p, bool _mtl, bool _norm)\n{\n    vec2 lf = laptop(_p, _mtl, _norm);\n    //vec2 rf = room(_p, _mtl);\n    \n    return lf;\n}\n\nvec3 normal(in vec3 _p, in float _f)\n{\n    float f = _f;//map(_p).x;\n    vec2 e = vec2(0.001, 0.);\n    vec3 n;\n    n.x = map(_p + e.xyy, false, true).x - f;\n    n.y = map(_p + e.yxy, false, true).x - f;\n    n.z = map(_p + e.yyx, false, true).x - f;\n    \n    return normalize(n);\n}\n\nvec3 norm_forward(in vec3 _p, in float _f) {\n    vec2 e = vec2(0.001, 0.);\n    vec3 n;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    for (int i = ZERO; i < 3 && iFrame > 0; i++) {\n        n[i] = map(_p + vec3(i == 0, i == 1, i == 2)*e.x, true, false).x - _f;\n    }\n    \n    return normalize(n);\n}\n\nfloat key_press_sequence(const float _time, const int _input_key) {\n    // key press sequence\n    float t120 = mod(_time, 120.);\n    float t180 = mod(_time, 180.);\n    const float hit_start = 0.;\n    float press_rate = 1.5+0.1*noise(t180);\n    // 47 keys added.\n    // 10% top row, 50% letters, 5% ></ and 35% no key is pressed\n    float key_hash = hash(floor(t180 * press_rate));\n    int key = 1 + int(13. * key_hash * step(key_hash, 0.1) + // top row\n    (13. + 30. * key_hash) * (step(0.1, key_hash) - step(0.6, key_hash)) +\n    (43. + 4. * key_hash) * (step(0.6, key_hash) - step(0.65, key_hash)) +\n    50. * step(0.65, key_hash));\n    \n    return float(key == _input_key);\n}\n\nfloat CalcAO(in vec3 _p, in vec3 _n) {\n    float v0 = 0.276;\n    float v1 = 0.133;\n    float v2 = 0.179;\n    float v3 = 0.080;\n    float v4 = 0.272;\n    \n    float ao = 0.0;\n\tfloat s = 1.0;\n\tfor (float i = 0.; i < 6.; ++i)\n\t{\n\t\tfloat off = v0 + v1 * i / 6.;\n\t\tfloat t = map(_n * off + _p, false, true).x;\n\t\tao += (off - t) * s;\n\t\ts *= v2;\n\t}\n    \n    ao = mix(1., smoothstep(0., 1., 1. - v3 * 20. * ao), v4);\n    return ao;\n}\n\nvec3 render(in vec3 _p, in vec3 _n, in vec3 _d, in float _mtl,\n    in float _tdist, in vec3 _col, in float _scrRatio, in bool _rfl)\n{\n    const float lpWidth = 0.5;\n    const float lpRatio = 0.6965386; // This is laptop ratio\n    float lpHeight = lpRatio * lpWidth * _scrRatio;\n    \n    vec3 frame = vec3(0.9);\n    vec3 ldir = (vec3(_d));\n    \n    float diffTerm = max(dot(-ldir, _n), 0.);\n    float ao = CalcAO(_p, _n);\n    diffTerm *= ao;\n    vec3 col = (0.8 * diffTerm + 0.2) * frame;\n    \n    int mtl = int(_mtl);\n    \n    vec4 on = (trf * vec4(_n, 0.));\n    vec3 op = (trf * vec4(_p, 1.)).xyz;\n    \n    // YES THIS NEEDS TO BE PRECOMPUTED\n    vec3 l0 = normalize(-vec3(sin(0.), -0.5, cos(0.)));\n    vec3 l1 = normalize(-vec3(sin(PI2 * 0.33333), -0.5, cos(PI2 * 0.33333)));\n    vec3 l2 = normalize(-vec3(sin(PI2 * 0.66666), -0.5, cos(PI2 * 0.66666)));\n    vec3 h0 = normalize(-_d + l0);\n    vec3 h1 = normalize(-_d + l1);\n    vec3 h2 = normalize(-_d + l2);\n    \n    float emit = 0.;\n\n    float fshlick = pow(1. - max(dot(_d, -_n), 0.), 5.);\n    \n    float N;\n    N += pow(max(dot(_n, h0), 0.), 128.) * pow(1. - max(dot(-l0, _n), 0.), 5.);\n    N += pow(max(dot(_n, h1), 0.), 128.) * pow(1. - max(dot(-l1, _n), 0.), 5.);\n    N += pow(max(dot(_n, h2), 0.), 128.) * pow(1. - max(dot(-l2, _n), 0.), 5.);\n    \n    if (mtl == 1 && on.y > 0.99) // keyboard and trackpad\n    {\n      col = vec3(1., 0., 0.) * dot(-ldir, _n);\n      vec2 tx = toUV(vec4(-14. * 0.5, -9.75 * 0.5, 14., 9.75), op.xz, vec2(1., 1.), vec4(0., 0., lpWidth - 0.001, lpHeight));\n      \n      vec2 tuv = toUV(vec4(-14. * 0.5, -9.75 * 0.5, 14., 9.75), op.xz, vec2(1., 1.), vec4(0., 0., 1., 1.));\n       \n      // side speakers\n      float speakers = float(inBox(abs(vec2(0.5, 0.) - tuv), vec4(0.38, 0.462, 0.115, 0.436)));\n      tuv.x *= 14./9.75;\n      vec2 grid = tuv * (iResolution.y) * 0.1;\n      float f_speakers = smoothstep(0.05, 0.25, length(fract(grid) - vec2(0.5)));\n      float w = length(fwidth(tuv));\n      f_speakers = mix(f_speakers, 0.85, smoothstep(0.001, 0.0075, w));  \n\n      vec4 clr = texture(iChannel0, tx);\n      col = clr.rrr;\n      vec3 tn = (transpose(trf) * vec4(normalize(vec3(clr.y, 0.0001, clr.z)), 0.)).xyz;\n      col += 0.5*max(dot(tn, _d), 0.)*step(0.5, clr.w);\n      \n      // button normal\n      //vec3 button_n = normalize(vec3(clr.y, clr.z, 1.));\n      //button_n = (trf * vec4(button_n, 0.)).xyz;\n      // sin phi angle\n      float sin_phi = (abs(_d.y)/length(_d));\n      float f_phi_dir = smoothstep(0., 1., 1. - abs(sin_phi - 0.5));\n      // button light\n      float light_f = length(clr.yz)*f_phi_dir;\n      \n      col = mix(col, col * f_speakers, speakers);\n      //col += light_f * noise(clr.w * _d.x*_d.z * 6. + 103.);\n      col += 1.25*length(clr.yz)*noise(clr.w*f_phi_dir + 30.)*step(1., clr.w);\n      //col = 0.5 + 0.5*button_n;\n      col *= (1. - step(0.01,length(clr.yz))*0.8*key_press_sequence(iTime, int(clr.w)));\n      \n      col *= diffTerm;\n      \n      // fake shadows\n      float diff_sh = clamp((op.z - -9.75 * 0.5)/9.75, 0., 1.);\n      float fake_shadow = clamp(abs((debugRot.y + 1.))*exp(diff_sh), 0., 1.);\n      col *= fake_shadow;\n\n    }\n    else if (mtl == 2 && (scrTrf * on).y < -0.75) // screen\n    {\n        col = vec3(1., 1., 1.);\n        vec2 tx = toUV(vec4(-14. * 0.5, -9.75 * 0.5, 14., 9.75), (scrTrf * vec4(op, 1.)).xz, vec2(1., 0.), vec4(lpWidth, 0., lpWidth, lpHeight));\n\n        vec4 scrCol = texture(iChannel0, tx);\n        scrCol.rgb -= scrCol.rgb * (1. - diffTerm) * (1. - scrCol.a);\n        col = scrCol.rgb * scrCol.a;\n        if (_rfl == false) {\n            float fct = 1. - smoothstep(0.5, 1., length(_col));\n            col += _col * (0.05*fct + 0.9 * fshlick) * scrCol.a;\n        }\n        emit = 1.;\n    }\n    else if (mtl == 4) // panel\n    {\n        col = vec3(0.4) * diffTerm;\n    }\n    else if (mtl == 5) // jacks\n    {\n        vec3 c = op - vec3(14. * 0.5, 0., -9.5 * 0.5 + 1.075 + 0.14);\n        float fc = sdCapsule(c.yz, 0.5, 0.025);\n        float fp = 1. - (length(fract((c + vec3(0., 0.4, 0.25)) * 9.).yz - vec2(0.5)) - 0.2);\n        col = mix(col, 0.5*col, (1. - smoothstep(0., 0.08, fc)));\n        col += (1. - smoothstep(0., 0.02, fc)) * pow(fp, 64.) * vec3(1., 1., 0.2);\n        \n        col *= diffTerm;\n    }\n    if (mtl == 3 && (scrTrf * on).z > 0.8) // the low normal direction is to account for blending\n    {\n        col = vec3(0.3) * diffTerm;\n    }\n    \n    //col = vec3(on*0.5 + 0.5);\n    col = mix(col, 0.9*col + (0.2*N), (1. - emit));\n    return vec3(col); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 muv = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    // raw uv\n    vec2 ruv = fragCoord.xy / iResolution.y;\n    float scrRatio = iResolution.x / iResolution.y;\n    \n    float full_pixel = 2./iResolution.y;\n    float half_pixel = 0.5 * full_pixel;\n    float quad_pixel = 0.5 * half_pixel;\n    \n\n    debugRot += step(0.5, iMouse.z) * muv * 1.7;\n\n    vec3 col = vec3(0.);\n    vec3 rcol = vec3(0.);\n    int i_sample = 0;\n    vec4 ray_t = vec4(0.); // --- hit t for each subsample\n    bvec4 hit_t = bvec4(false); // --- hit (true/false) for each subsample\n    vec3 norm[4]; // --- normal for each subsample;\n    vec4 mtls; // --- material for each subsample;\n    vec3 rp;\n    vec3 rd0;\n    vec3 ro = vec3(0., 15., 12.);\n    ro.y -= 5.*smoothstep(0.5, 1., abs(muv.y));\n    // trace\n    for (float iy = quad_pixel; iy < full_pixel; iy += half_pixel) {\n      for(float ix = quad_pixel; ix < full_pixel; ix += half_pixel) {\n        vec3 rd = normalize(vec3((uv + vec2(ix, iy))*0.6, -1.)); \n\n        // Autoblur - this is a cool thing to try on movement!\n        // Not implemented because I'm not using differentiation between\n        // a static scene and movement.\n        // Definitely use it in later shader.\n        // debugRot += step(0.5, iMouse.z) * muv * 0.02;\n        \n        rd = camera(ro, rd, targetOrigin + vec3(0., 0., -4.));\n        \n        if (i_sample == 0) {\n            rd0 = rd;\n        }\n        \n        // trace --> move to separate function\n        vec3 p = ro;\n        float f = 10.0, t = 0., rf = 10., rt = 0.;\n        int i_iter = 0;\n        float mtl;\n        vec3 n;\n        vec2 res;\n\n        // the high count needed in case of rays parallel to screen\n        for (; i_iter < 1024; i_iter++)\n        {\n            res = map(p, true, false);\n            f = res.x;\n            mtl = res.y;\n            t = length(p - ro);\n\n            if (abs(f) < T_EPS*t || t >= T_FAR)\n                break;\n\n            p += f * rd;\n        }\n\n        \n        if (abs(f) < T_EPS * t) {\n            norm[i_sample] = norm_forward(p, f);\n            // In this case I favor compilation time over \n            // performance and clarity as it is much more severe\n            mtls[i_sample] = mtl;//map(p, true, true).y;\n            ray_t[i_sample] = t;\n            hit_t[i_sample] = true;\n        }\n        \n        i_sample++;\n      }\n    }\n\n#ifdef REFLECTION\n    // reflect\n    // Save computations on reflections so do it only once.\n    if (hit_t[0])\n    {\n        float t = ray_t[0];\n        vec3 n = norm[0];\n        float mtl = mtls[0];\n        \n        vec3 rfl_dir = (reflect(rd0, n));\n        vec3 p = ro + rd0 * ray_t[0];\n\n        if (int(mtls[0]) == 1) {\n            rfl_dir = vec3(0., 1., 0.); \n        }\n        rp = p + rfl_dir * 0.01;\n\n        float rf = 10., rt = 0.;\n        vec2 res;\n        float rmtl;\n        for (int i_iter = 0; i_iter < 256; i_iter++) {\n            res = map(rp, false, false);\n            rf = res.x;\n            rmtl = res.y;\n            rt = length(rp - p);\n            if (abs(rf) < T_EPS * rt || rt >= 35.)\n                break;\n            rp += rfl_dir * rf;\n        }\n\n        if (abs(rf) < T_EPS * rt) {\n            vec3 rn = norm_forward(rp, rf);\n            float rmtl = map(rp, true, false).y;\n            rcol = render(rp, rn, rfl_dir, rmtl, rt, vec3(0.), scrRatio, true);\n        }\n    }\n\n#endif\n    \n    // render\n    i_sample = 0;\n    for (float iy = quad_pixel; iy < full_pixel; iy += half_pixel) {\n      for(float ix = quad_pixel; ix < full_pixel; ix += half_pixel) {\n        vec3 rd = normalize(vec3((uv + vec2(ix, iy))*0.6, -1.)); \n\n        rd = camera(ro, rd, targetOrigin + vec3(0., 0., -4.));\n        float t = ray_t[i_sample];\n        vec3 n = norm[i_sample];\n        float mtl = mtls[i_sample];\n        \n        if (hit_t[i_sample])\n        {\n            vec3 p = ro + rd * t;\n            if (int(mtl) == 1 && i_sample == 0) {\n                rcol = vec3(0.5 + 0.5*smoothstep(0., 10., length(rp - p)));\n            }\n            col += render(p, n, rd, mtl, t, rcol, scrRatio, false);\n            //col = mix(col, rcol, 0.5);\n            //col = vec3(0.5) + n * 0.5;\n        }\n        else\n        {\n            float v =  0.2*hash(((ruv + 1.78)));\n            col += mix(vec3(0.1, 0.6, 0.77), vec3(0.02, 0.12, 0.3), v+uv.y);\n        }\n        \n        i_sample++;\n      }\n    }\n    \n    col *= 0.25;\n    // DEBUG\n    // col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    \n    //col *= 4.;\n    // tone mapping\n    col *= 2.;\n    col /= (col*0.75 + vec3(0.75));\n    col = pow(col, vec3(2.2));\n    \n    col = smoothstep(0., 0.5, iTime) * col;\n    \n    col = mix(vec3(0.), col, smoothstep(0., 1., iTime));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    MacBook Pro M2. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define FPS_DATA ivec2(0,0)\n\n#define TF0(crd) texelFetch(iChannel0, crd, 0)\n#define TF1(crd) texelFetch(iChannel1, crd, 0)\n#define TF2(crd) texelFetch(iChannel2, crd, 0)\n#define TF3(crd) texelFetch(iChannel3, crd, 0)\n#define TF(ch, crd) texelFetch(ch, crd, 0)\n\n//#define REFLECTION\n\nfloat hash( float _x )\n{\n    return fract(max(mod(mod(_x * 0.7231, 0.813), 0.17315), mod(_x * 49.34, 0.322))*172.92183);\n}\n\nfloat hash(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat noise(in float s)\n{\n  float i = floor(s);\n  float f = fract(s);\n  \n  return mix(hash(i), hash(i + 1.0), f * f* (3.0 - 2.0 * f));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// x - radius, y - x length\nfloat sdCylX(in vec3 _p, in vec2 _lr)\n{\n    return max(length(_p.yz) - _lr.x, abs(_p.x) - _lr.y);\n}\n\nfloat sdCapsule( vec2 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsuleZExtrusion(vec3 _p, float _h, float _r, float _d)\n{\n    float gzy = sdCapsule(_p.yz, _h, _r);\n    return max(gzy, abs(_p.x) - _d);\n}\n\n// bounded - not exact\nfloat sdTrapezoid(in vec2 _p, in vec2 _tb, in vec4 _vrl, in vec2 _rl)\n{\n    float fc0 = _p.y - _tb.x;\n    float fc1 = -_p.y - _tb.y;\n    float fc2 = -(dot(_p, normalize(_vrl.xy)) + _rl.x);\n    float fc3 = -(dot(_p, normalize(_vrl.zw)) + _rl.y);\n    \n    return max(max(max(fc0, fc1), fc2), fc3);\n}\n\nbool inBox(in vec2 _uv, in vec4 _box)\n{\n   vec2 v = step(_box.xy, _uv) - step(_box.xy + _box.zw, _uv);\n   return bool(v.x * v.y);\n}\n\n// iq\nvec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar) {\n  vec3 dir = normalize(o - tar);\n  vec3 right;\n  vec3 up = vec3(0., 1., 0.);\n\n      right = normalize(cross(dir,up));\n      up = normalize(cross(right,dir));\n\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\n// polynomial\nfloat sdSmUnion( float _f0, float _f1, float _k )\n{\n    float h = max( _k-abs(_f0-_f1), 0.0 )/_k;\n    return min( _f0, _f1 ) - h*h*_k*(1.0/4.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    MacBook Pro M2. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define _0 vec2(0., 12.)\n#define _1 vec2(1., 12.)\n#define _2 vec2(2., 12.)\n#define _3 vec2(3., 12.)\n#define _4 vec2(4., 12.)\n#define _5 vec2(5., 12.)\n#define _6 vec2(6., 12.)\n#define _7 vec2(7., 12.)\n#define _8 vec2(8., 12.)\n#define _9 vec2(9., 12.)\n\n#define _P vec2(0., 10.)\n#define _Q vec2(1., 10.)\n#define _R vec2(2., 10.)\n#define _S vec2(3., 10.)\n#define _T vec2(4., 10.)\n#define _U vec2(5., 10.)\n#define _V vec2(6., 10.)\n#define _W vec2(7., 10.)\n#define _X vec2(8., 10.)\n#define _Y vec2(9., 10.)\n#define _Z vec2(10., 10.)\n#define _A vec2(1., 11.)\n#define _B vec2(2., 11.)\n#define _C vec2(3., 11.)\n#define _D vec2(4., 11.)\n#define _E vec2(5., 11.)\n#define _F vec2(6., 11.)\n#define _G vec2(7., 11.)\n#define _H vec2(8., 11.)\n#define _I vec2(9., 11.)\n#define _J vec2(10., 11.)\n#define _K vec2(11., 11.)\n#define _L vec2(12., 11.)\n#define _M vec2(13., 11.)\n#define _N vec2(14., 11.)\n#define _O vec2(15., 11.)\n\n#define _AT vec2(0., 11.)\n\n#define _EXM    vec2(1., 13.)\n#define _DQT    vec2(2., 13.)\n#define _SHARP  vec2(3., 13.)\n#define _DLR    vec2(4., 13.)\n#define _PRC    vec2(5., 13.)\n#define _AND    vec2(6., 13.)\n#define _QT     vec2(7., 13.)\n#define _OPN_RND_BRCK vec2(8., 13.)\n#define _CLS_RND_BRCK vec2(9., 13.)\n#define _STAR   vec2(10., 13.)\n#define _PLUS   vec2(11., 13.)\n#define _COMMA  vec2(12., 13.)\n#define _DASH   vec2(13., 13.)\n#define _DOT    vec2(14., 13.)\n#define _SLASH  vec2(15., 13.)\n\n#define _CLN  vec2(10., 12.)\n#define _SCLN vec2(11., 12.)\n#define _LST  vec2(12., 12.)\n#define _EQ   vec2(13., 12.)\n#define _GRT  vec2(14., 12.)\n#define _QM   vec2(15., 12.)\n\n#define _OPN_SQR_BRCK vec2(11., 10.)\n#define _BSLASH       vec2(12., 10.)\n#define _CLS_SQR_BRCK vec2(13., 10.)\n#define _CIRCUMFLEX   vec2(14., 10.)\n#define _LOW_DASH     vec2(15., 10.)\n\n#define _OPN_PRN_BRCK vec2(11., 8.)\n#define _PIPE         vec2(12., 8.)\n#define _CLS_PRN_BRCK vec2(13., 8.)\n#define _TILDA        vec2(14., 8.)\n\n#define _BCKTICK      vec2(0., 9.)\n\n#define _a vec2(4.,3.)\n\n#define tx(_x, _y, _ch) float(iigrid.x == _x && iigrid.y == _y) * texture(iChannel1, 0.0625 * (_ch + cgrid)).r\n#define txs(_x, _y, _ch) float(iigrid.x == _x && iigrid.y == _y) * texture(iChannel1, 0.0625 * (_ch + sgrid)).r\n#define txn(_x, _y, _ch) float(iigrid.x == _x && iigrid.y == _y) * texture(iChannel1, 0.0625 * (_ch + ngrid)).r\n\n#define tx_custom(_x, _y, _ch, _v) float(iigrid.x == _x && iigrid.y == _y) * texture(iChannel1, 0.0625 * (_ch + _v)).r\n\n#define normUV(_uv, _pln) clamp((_uv - _pln.xy)/(_pln.zw), vec2(0.01), vec2(0.99))\n\n#define ATF(_crd, _pos, _val) if (_crd.x == _pos.x && _crd.y == _pos.y) { col = _val; }\n\n#define _DOT    vec2(14., 13.)\n#define _DASH   vec2(13., 13.)\n\n#define ADVANCE_ST(_v) (st.x += _v*0.5*_dsize.x)\n#define TRANSLATE_ST(_v) (st.x + _v * 0.5*_dsize.x)\n#define MAX_PRE_DOT_DIGITS 4.\n#define MAX_POST_DOT_DIGITS 2.\n\nfloat printSymbol(in vec2 _uv, in vec4 _dbox, in vec2 _symb)\n{\n    vec2 inside = step(_dbox.xy, _uv) - step(_dbox.xy + _dbox.zw, _uv);\n    if (inside.x * inside.y < 0.5)\n        return 0.;\n        \n    vec2 uv = (_uv - _dbox.xy) / _dbox.zw;\n    return texture(iChannel1, 0.0625 * (_symb + uv)).r;\n}\n\nfloat printNumber(in vec2 _uv, in vec2 _dstart, in vec2 _dsize, in float _num)\n{\n    vec2 symb;\n    vec2 st = _dstart;\n    float f = 0.;\n    if (_num < 0.) {\n        f = printSymbol(_uv, vec4(st, _dsize), _DASH);\n        _num *= -1.;\n        ADVANCE_ST(1.);\n    }\n    float num = _num;\n    float div = 1.;\n    float nd = 0.;\n    for (;nd < MAX_PRE_DOT_DIGITS && num >= div; nd++, div *= 10.);\n    //f += printSymbol(_uv, vec4(st, _dsize), vec2(nd, 12.));\n    \n    ADVANCE_ST(nd);\n    \n    // before the dot\n    float inum = 0.;\n    for (float id = 0.; id < nd; id++) {\n        float digit = floor(mod(num, 10.));\n        inum += digit * (id + 1.);\n        num /= 10.;\n        f += printSymbol(_uv, vec4(TRANSLATE_ST(-(id + 1.)), st.y, _dsize), vec2(digit, 12.));\n    }\n    if (nd == 0.0)\n    {\n        ADVANCE_ST(1.);\n        f += printSymbol(_uv, vec4(TRANSLATE_ST(-1.), st.y, _dsize), _0);\n    }\n    \n    f += printSymbol(_uv, vec4(st, _dsize), _DOT);\n    \n    num = _num - inum;\n    // print 2 digits after the dot\n    ADVANCE_ST(1.); //\n    for (float id = 0.; id < MAX_POST_DOT_DIGITS; id++) {\n        num *= 10.;\n        float digit = floor(mod(num, 10.));\n        f += printSymbol(_uv, vec4(st, _dsize), vec2(digit, 12.));\n        ADVANCE_ST(1.);\n    }\n    \n\n    return f;\n}\n\nfloat roundBox(in vec2 _uv, in vec4 _dims, in float _r)\n{\n    return sdBox(_uv - 0.5 * (2.*_dims.xy + _dims.zw), _dims.zw * (0.5 - 2.*_r)) - _r;\n}\n\nvec4 keyboardLayout(in vec2 _uv, in float _ratio)\n{\n    vec2 grid = _uv * vec2(15., 6.) - vec2(0.4, 0.);\n    vec2 igrid = floor(grid);\n    \n    grid.x -= 0.0 * step(igrid.y, 4.5) + 0.3 * step(igrid.y, 3.5) + 0.3 * step(igrid.y, 2.5)\n                + 0.5 * step(igrid.y, 1.5) + 0.3 * step(igrid.y, 0.5);\n\n    igrid = floor(grid);\n    vec2 fgrid = fract(grid);\n    vec2 cgrid = normUV(fgrid, vec4(0.25, 0.25, 0.5, 0.5)); // center (Letters)\n    vec2 sgrid = normUV(fgrid, vec4(0.3, 0.175, 0.4, 0.4)); // south\n    vec2 ngrid = normUV(fgrid, vec4(0.3, 0.5, 0.4, 0.4)); // north\n    \n    vec2 nlgrid = normUV(fgrid, vec4(0.35, 0.5, 0.3, 0.3)); \n    \n    ivec2 iigrid = ivec2(igrid);\n    \n    vec4 col = vec4(0.1, 0., 0., 0.);\n    float fb = roundBox(fgrid, vec4(vec2(0.1), vec2(0.9)), 0.05);\n    float fk = roundBox(_uv, vec4(vec2(0.01), vec2(0.99)), 0.01);\n    \n    float fkey = 0.;\n    \n    // digits\n    for (int id = 1; id <= 10; id++)\n        fkey += txs(id, 4, vec2(float(id % 10), 12.));\n    // symbols above digits\n    fkey += txn(1,4,_EXM) + txn(2,4,_AT) + txn(3,4,_SHARP) + txn(4,4,_DLR) + txn(5,4,_PRC) +\n            txn(6,4,_CIRCUMFLEX) + txn(7,4,_AND) + txn(8,4,_STAR) + \n            txn(9,4,_OPN_RND_BRCK) + txn(10,4,_CLS_RND_BRCK);\n    fkey += txn(12,4,_PLUS) + txs(12,4,_EQ);\n            \n    fkey += txs(0,4,_BCKTICK) + txn(0,4,_TILDA) + txs(11,4,_DASH) + txn(11,4,_DASH);\n    fkey += txs(11,3,_OPN_SQR_BRCK) + txn(11,3,_OPN_PRN_BRCK) + \n            txs(12,3,_CLS_SQR_BRCK) + txn(12,3,_CLS_PRN_BRCK);\n    fkey += txs(13,3,_BSLASH) + txn(13,3,_PIPE);\n    fkey += txs(10,2,_SCLN) + txn(10,2,_CLN) + txs(11,2,_QT) + tx_custom(11,2,_DQT, nlgrid);\n    \n    fkey += txs(8,1,_COMMA) + txn(8,1,_LST) + txs(9,1,_DOT) + txn(9,1,_GRT);\n    fkey += txs(10,1,_SLASH) + txn(10,1,_QM);\n    \n    // QWERTY\n    fkey += tx(1,3,_Q) + tx(2,3, _W) + tx(3,3,_E) + tx(4,3,_R) + tx(5,3,_T) + tx(6,3,_Y);\n    fkey += tx(7,3,_U) + tx(8,3, _I) + tx(9,3,_O) + tx(10,3,_P);\n    fkey += tx(1,2,_A) + tx(2,2, _B) + tx(3,2,_D) + tx(4,2,_F) + tx(5,2,_G) + tx(6,2,_H);\n    fkey += tx(7,2,_J) + tx(8,2, _K) + tx(9,2,_L);\n    fkey += tx(1,1,_Z) + tx(2,1, _X) + tx(3,1, _C) + tx(4,1,_V) + tx(5,1,_B) + tx(6,1,_N) + tx(7,1,_M);\n    \n    float ikey = float(iigrid.y == 4 && (iigrid.x >= 0 && iigrid.x <= 12));\n    ikey += float(iigrid.y == 3 && (iigrid.x >= 1 && iigrid.x <= 13));\n    ikey += float(iigrid.y == 2 && (iigrid.x >= 1 && iigrid.x <= 11));\n    ikey += float(iigrid.y == 1 && (iigrid.x >= 1 && iigrid.x <= 10));\n    \n    float in_key = float(iigrid.y == 4) + \n                14. * float(iigrid.y == 3) + \n                27. * float(iigrid.y == 2) +\n                38. * float(iigrid.y == 1) + igrid.x;\n                 \n    \n    col.r += fkey;\n    fb = 1. - smoothstep(0.0, 0.05, fb);\n    fk = 1. - smoothstep(0.0, 0.02, -fk);\n    col.gb = -(vec2(dFdx(fb), dFdy(fb))) * ikey - vec2(dFdx(fk), dFdy(fk));\n    col.w = ikey * in_key;\n    \n    \n    return vec4(col);\n}\n\nvec4 keyboardTexture(in vec2 _uv, in float _ratio)\n{\n    vec4 frame = vec4(vec3(0.9), 0.);\n    vec4 col = frame;\n    \n    const vec4 keyboard = vec4(0.115, 0.432, 0.77, 0.486);\n    const vec4 trackpad = vec4(0.2767, 0.026, 0.446, 0.3636);\n    \n    float ftrack = roundBox(_uv, trackpad, 0.02);\n    float fkeys = roundBox(_uv, keyboard, 0.02);\n    \n    if (inBox(abs(vec2(0.5, 0.) - _uv), vec4(0.38, 0.462, 0.115, 0.436)))\n    {\n        vec2 grid = _uv * (max(iResolution.x, iResolution.y) * 0.1);\n        grid.y *= _ratio;\n        float f = smoothstep(0.05, 0.15, length(fract(grid) - vec2(0.5)));\n        //col = mix(vec4(vec3(0.1), 0.), frame, f);\n    }\n\n    float ftr = 1. - smoothstep(0., 0.001, -roundBox(_uv, vec4(trackpad.xy + vec2(0.01), trackpad.zw - vec2(0.02)), 0.01));\n    col.gb = -vec2(dFdx(ftr), dFdy(ftr));\n    col.w = 0.5*step(ftrack, 0.);\n    \n    if (step(fkeys, 0.) > 0.5)\n    {\n        col = keyboardLayout(normUV(_uv, keyboard), iResolution.x/iResolution.y);\n    }\n    \n    // trackpad\n    col.r = mix(col.r, ((0.77) + 0.15*smoothstep(0., 0.0001, -ftrack)), step(ftrack, 0.));\n     \n    return col;\n}\n\nvec4 screenTexture(in vec2 _uv, in float _ar)\n{\n    bool inFrame = inBox(_uv, vec4(0.02, 0.025, 0.96, 0.95));\n    float f = sdBox(_uv - vec2(0.5), vec2(0.46, 0.45)) - 0.02;\n    vec4 col = vec4(1., 0., 0., 1.);\n    vec4 fpsData = TF2(FPS_DATA);\n    \n    vec4 frameCol = clamp(mix(vec4(0.05, 0.05, 0.05, 0.), vec4(0.15, 0.15, 0.15, 0.), sqrt(f/0.02)), 0., 1.);\n    col = mix(frameCol, texture(iChannel0, vec2(_uv.x, _uv.y)), step(f, 0.));\n    vec2 d_size = vec2(0.035 / _ar, 0.035);\n    col.rgb += 2.*col.bbb * printNumber(_uv, vec2(0.05, 0.9), d_size, fpsData.y);\n    col = mix(col, vec4(vec3(0.05), 0.), step(sdBox(_uv - vec2(0.5, 0.05), vec2(1., 0.05)), 0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // raw uv\n    vec2 ruv = fragCoord.xy / iResolution.y;\n    float scrRatio = iResolution.x / iResolution.y;\n    float lpWidth = scrRatio * 0.5;\n    const float lpRatio = 0.6965386; // this is a constant of a laptop --> width to height ratio.\n    float lpHeight = lpWidth * lpRatio;\n    \n    vec4 col = vec4(vec3(0.75), 0.);\n    \n    if (inBox(ruv, vec4(0., 0., lpWidth, lpHeight)))\n    {\n        col = keyboardTexture(ruv/vec2(lpWidth, lpHeight), lpRatio);\n        //col = vec4(floor(5.*ruv/vec2(lpWidth, lpHeight)) / 5., 0., 1.);\n    }\n    else if (inBox(ruv, vec4(lpWidth, 0., lpWidth, lpHeight)))\n    {\n        col = screenTexture((ruv - vec2(lpWidth, 0.))/vec2(lpWidth, lpHeight), lpRatio);\n        //col = vec4(0., floor(5.*(ruv - vec2(lpWidth, 0.))/vec2(lpWidth, lpHeight))/5., 1.);\n    }\n    \n    vec4 fps_data = TF2(FPS_DATA);\n    ivec2 crd = ivec2(fragCoord);\n    \n    ATF(crd, FPS_DATA, fps_data);\n    if (iFrame % 20 == 1) {\n      float fps = 20. / (iTime - fps_data.x);\n      ATF(crd, FPS_DATA, vec4(iTime, fps, iResolution.y, 0.));\n    }\n    // texture coordinate debugging\n    // col = vec4(floor(vec2(ruv.x/scrRatio, ruv.y)*10.)/10., 0., 1.);\n    \n    // col = texture(iChannel1, fragCoord.xy/iResolution.xy).rrrr;\n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    MacBook Pro M2. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define A_START 4\n#define A_N 11\n#define N_ANG 6.\n\n#define ANIM_T(_t, _e, _p) (smoothstep(_p - _e, _p, _t) - smoothstep(_p, _p + _e, _t))\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n\n#define SCENE_ANIM_TIME 40.\n\nconst float dists[10] = float[10](0.5, 0.65, 0.16, 1.0, -1.2, 0.4, 2.1, 0.3, -2.3, 0.9);\nconst vec3 cols[7] = vec3[7](vec3(0., 0.3, 0.7), vec3(0.0, 0.3, 0.96), vec3(0.5, .4, 0.2), vec3(0.4, 0.3, 0.04), vec3(0.2, .05, 0.), vec3(0.9, 0.6, 0.1), vec3(0.5, 0.21, 0.4));\nconst vec3 plasma[11] = vec3[11](vec3(0.050383,0.029803,0.527975),vec3(0.254627,0.013882,0.615419),vec3(0.417642,0.000564,0.65839),vec3(0.562738,0.051545,0.641509),vec3(0.69284,0.165141,0.564522),vec3(0.798216,0.280197,0.469538),vec3(0.881443,0.392529,0.383229),vec3(0.949217,0.517763,0.295662),vec3(0.98826,0.652325,0.211364),vec3(0.988648,0.809579,0.145357),vec3(0.940015,0.975158,0.131326));\nconst vec3 Blues[11] = vec3[11](vec3(0.9686274509803922,0.984313725490196,1.0),vec3(0.8901960784313725,0.9341176470588235,0.9749019607843137),vec3(0.8141176470588235,0.883921568627451,0.9498039215686275),vec3(0.7137254901960783,0.8321568627450979,0.9152941176470588),vec3(0.5796078431372549,0.7701960784313725,0.8737254901960784),vec3(0.4196078431372549,0.6823529411764706,0.8392156862745098),vec3(0.29098039215686267,0.5945098039215685,0.7890196078431372),vec3(0.18117647058823522,0.4949019607843136,0.7364705882352941),vec3(0.09019607843137256,0.39294117647058824,0.6705882352941177),vec3(0.03137254901960784,0.2917647058823529,0.5733333333333334),vec3(0.03137254901960784,0.18823529411764706,0.4196078431372549));\nconst vec3 bckColor = vec3(0.067, 0.67, 0.89);\n\nfloat hash2(in vec2 st) {\nreturn fract(sin(dot(st.xy,\nvec2(12.9898,78.233)))\n* 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\nvec2 i = floor(st);\nvec2 f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash2(i);\nfloat b = hash2(i + vec2(1.0, 0.0));\nfloat c = hash2(i + vec2(0.0, 1.0));\nfloat d = hash2(i + vec2(1.0, 1.0));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nvec2 u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 4 coorners porcentages\nreturn mix(a, b, u.x) +\n(c - a)* u.y * (1.0 - u.x) +\n(d - b) * u.x * u.y;\n}\n\nvec2 hash22(in vec2 uv)\n{\n  return fract(vec2(sin(uv.x*1834538.331),\n               sin(uv.y*617678.44)));\n}\n\nfloat hash21(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat hash(in vec3 p)\n{\n  return fract(sin(dot(p,\n    vec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat noise3(in vec3 p)\n{\n  vec3 pi = floor(p);\n  vec3 pf = fract(p);\n\n  pf = pf*pf*(3.-2.*pf);\n\n  float a = hash(pi + vec3(0., 0., 0.));\n  float b = hash(pi + vec3(1., 0., 0.));\n  float c = hash(pi + vec3(0., 1., 0.));\n  float d = hash(pi + vec3(1., 1., 0.));\n\n  float e = hash(pi + vec3(0., 0., 1.));\n  float f = hash(pi + vec3(1., 0., 1.));\n  float g = hash(pi + vec3(0., 1., 1.));\n  float h = hash(pi + vec3(1., 1., 1.));\n\n  return mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\n  mix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\nfloat fbm(vec2 uv) {\n  float f = .5*noise(uv);\n  vec2 off = vec2(0.01, 0.01);\n  f += .25*noise(uv*2.02 + off);\n  f += .125*noise(uv*4.01 + off);\n  f += .065*noise(uv*8.03 + off);\n  f += .0325*noise(uv*16.012 + off);\n\n  return f;\n}\n\n\n////\n\n\n#define BR_ZOOM_F 30.\n\nfloat branch(in vec2 uv, in float size, out vec3 col)\n{\n  float f = 0.;\n\n  uv.x *= BR_ZOOM_F;\n  uv.y *= BR_ZOOM_F*1.5;\n  uv.y += sin(uv.x*3.);\n  f = smoothstep(-size*BR_ZOOM_F*4., 0., uv.y) -\n      smoothstep(0., size*BR_ZOOM_F*4., uv.y);\n  f *= step(0.001, -uv.x)*(1.-step(.6,-uv.x));\n  col = vec3(0.5, 0.25, 0.0)*f;\n  return f;\n}\n\n#define LEAF_ZOOM_F 33.\n\nfloat leaf(in vec2 uv, in float size, out vec3 col)\n{\n  float f = 0.;\n  float fn = pow(abs(uv.x*LEAF_ZOOM_F*0.8),0.4);\n  float fn2 = pow(abs(uv.x*LEAF_ZOOM_F*0.8),0.8);\n  float y = uv.y*LEAF_ZOOM_F;\n  f = smoothstep(y - size, y, fn) -\n      smoothstep(y,y + size, fn2);\n  f *= step(0.001,uv.x);\n  col = vec3(0.0,0.7,0.0)*f;\n\n#ifdef HIGH\n  fn = pow(abs(uv.x*LEAF_ZOOM_F*0.8),0.6);\n  float f2 = smoothstep(y - size*LEAF_ZOOM_F*0.8, y, fn) -\n      smoothstep(y,y + size*LEAF_ZOOM_F*0.8, fn);\n  f2 *= step(0.001,uv.x)*(1.-step(0.05,uv.x));\n  col  = mix(col, vec3(0.0,0.4,0.0)*f2, f2);\n#endif\n\n  return f;\n}\n\nfloat leaf2(in vec2 uv, in float size, out vec3 col)\n{\n  float f = 0., f2 = 0.;\n  vec2 ouv = uv;\n  uv.y *= 4.3;\n  float fn = pow(abs(uv.x*LEAF_ZOOM_F),0.3);\n  float fn2 = pow(abs(uv.x*LEAF_ZOOM_F),2.8);\n  float y = uv.y*LEAF_ZOOM_F;\n  f = smoothstep(y - size, y, fn-sin(uv.x*LEAF_ZOOM_F*.3)) -\n      smoothstep(y,y + size, fn2);\n\n#ifdef HIGH\n  vec2 cuv = 2.8*SIN45*vec2(ouv.x - ouv.y, ouv.x + ouv.y);\n  fn = pow(abs(cuv.x*LEAF_ZOOM_F),0.3);\n  fn2 = pow(abs(cuv.x*LEAF_ZOOM_F),2.8);\n  y = cuv.y*LEAF_ZOOM_F;\n  f2 = smoothstep(y - size, y, fn - sin(cuv.x*LEAF_ZOOM_F*1.7) ) -\n      smoothstep(y,y + size, fn2);\n  f2 = f2*(1.-step(0.001,cuv.x));\n#endif\n  col = vec3(0.0,0.7,0.0)*(max(f, f2)-0.3*f*f2);\n\n  return f;\n}\n\nfloat apple(in vec2 uv, in float size, out vec3 col)\n{\n  float f = 0.;\n  vec2 ouv = uv;\n  uv.y = uv.y-abs(uv.x)*(2.*size+uv.y)*10.;\n  f = dot(uv, uv)*8. - size*size;\n  f = 1.- smoothstep(size*0.85,size,f);\n  vec3 acol = vec3(0.85,0.0,0.0);\n  vec3 spec = vec3(1.,1.,1.);\n  vec2 spc = vec2(-size*1.8,size*0.8);\n  acol = mix(spec, acol, length((uv-spc)/(size*1.3)));\n\n  col += acol*f;\n  vec3 lcol = vec3(0.), bcol = vec3(0.);\n  f += leaf(ouv-vec2(0.,4.*size), size*.2, lcol);\n  f += branch(ouv-vec2(0.,5.*size), size*.1, bcol);\n  col += lcol + bcol;\n  col = max(col, vec3(0.));\n  return f;\n}\n\nfloat pear(in vec2 uv, in float size, out vec3 col)\n{\n  vec2 lc = uv-vec2(0.,-0.1*size);\n  lc.y += abs(lc.x*0.2);\n  vec2 uc = uv-vec2(-0.2*size,-0.1*size);\n  float f = length(lc);\n  f = 1.-step(size,f);\n  vec3 pcol = vec3(0.3,.5,0.0);\n  vec3 spec = vec3(0.87,0.87,0.2);\n#ifdef HIGH\n  float fx = size*1.5 - 700000.*(uc.x+.03*size)*(uc.x+.05*size)*\n  (uc.x-0.3*size)*(uc.x-0.7*size);\n  float f2 = step(0.0,uc.y)*step(uc.y,fx);\n#else\n  float fx = size*1.5 - 100.*uv.x*uv.x;\n  float f2 = step(0.0,uv.y)*step(uv.y,fx);\n#endif\n  //f2 = max(f2, step(0.0,uv.y)*step(uv.y,size*1.5-70.*(uv.x)*uv.x));\n  vec2 spc = vec2(size*0.3,size*0.3);\n  pcol = mix(spec, pcol, pow(length((uv-spc)/size), .5));\n\n  col = pcol*max(f,f2);\n\n  vec3 bcol, lcol;\n  f += branch(uv-vec2(size*0.2,size*1.3), size*.06, bcol);\n  col = max(max(lcol, bcol), col);\n  \n  col = max(col * 0.3, vec3(0.));\n  return f;\n}\n\nfloat strawberry(in vec2 uv, in float size, out vec3 col)\n{\n  float f = 0., f2 = 0.;\n  vec2 ouv = uv;\n  vec2 ouv2 = uv - vec2(0., 4.*size);\n  uv.y -= abs(0.6*uv.x);\n  //uv.x *= 0.9;\n  f = dot(uv, uv)*8. - size*size;\n  f2 = dot(ouv2, ouv2)*1. - size*size;\n  f = 1. - smoothstep(size*0.5,size*4.,f);\n  f2 = 1. - smoothstep(size*0.001, size*0.2,f2);\n  f = max(f, f2);\n\n  //col = vec3(0.85*f, 0.0, 0.0);\n\n  float grid_size = size*1.7;\n  vec2 cuv = mod(vec2(uv.x*1.3,uv.y), vec2(grid_size, grid_size));\n  float cf = length(cuv - vec2(grid_size*0.5, grid_size*0.5)) - grid_size*0.06;\n  //float cf = dot(cuv - grid_size*0.5, cuv - grid_size*0.5)*2000. - size*size;\n  float cf1 = 1. - step(0.1*grid_size,cf);\n  float cf2 = 1. - step(0.4*grid_size,cf);\n  col = (vec3(0.,cf1,0.)*step(0.7,f) + vec3(0.85-0.2*cf2, 0.0,0.0))*f;\n\n  vec3 spec = vec3(1.,1.,1.);\n  vec2 spc = vec2(-size*2.,size*2.);\n  col = f*mix(spec, col, pow(0.3*length((ouv-spc)/size), 0.3));\n\n  vec3 lcol;\n  float lf = leaf2(ouv + vec2(0.,-10.0*size),\n                  size*.5, lcol);\n  col += lcol;\n\n  col = max(col, vec3(0.));\n  return f;\n}\n\nfloat orange(in vec2 uv, in float size, out vec3 col)\n{\n  float f = length(uv);\n  f = 1.-step(size, f);\n  vec3 ocol = vec3(0.91,0.61,0.1);\n  vec3 spec = vec3(1.,1.,0.6);\n  vec2 spc = vec2(-size*0.3,size*0.3);\n  ocol = mix(spec, ocol, length((uv-spc)/size));\n  col = ocol*f;\n\n   vec3 bcol, lcol;\n   f += branch(uv-vec2(size*0.2,size*0.6), size*.1, bcol);\n   f += leaf(uv-vec2(-0.15*size,1.3*size), size*.08, lcol);\n   col = max(max(lcol, bcol), col);\n  \n  col = max(col * 0.2, vec3(0.));\n  \n  return f;\n}\n\n////\n\n#define red vec3(1.,0.,0.)\n#define yellow vec3(1.,1.,0.)\n#define blue vec3(0.,0.,1.)\n#define white vec3(1.,1.,1.)\n#define ocean vec3(0.,0.6,0.93)\n  \nfloat radial_grid(in vec2 _uv, in float _N, in float _phase, in float _size)\n{\n    vec2 center = _size*vec2(cos(-PI/_N), sin(-PI/_N));\n    float alpha = _phase + atan(_uv.x, _uv.y);\n    float r = length(_uv);\n    vec2 nuv = normalize(_uv);\n    alpha = mix(alpha, -PI-(PI-alpha), step(0., alpha));\n    alpha = -mod(abs(alpha), PI2/_N);\n    vec2 op = r*vec2(cos(alpha), sin(alpha));\n    return length(op - center);\n}\n\nvec3 flower(in vec2 uv) {\n    vec3 col;\n    vec2 grid = uv * 2.2;\n    for (float it = 0.; it < 5.; it+=1.)\n    {\n        float tfact = 0.2 * it;\n        float time = iTime - tfact;\n        // Time varying pixel color\n        vec3 tcol;\n        \n        // animation timers\n        float t5 = mod(time, 5.);\n        float t17 = mod(time, 17.);\n        float t25 = mod(time, 25.);\n        float t47 = mod(time, 47.);\n        \n        const float ampl = 1./float(A_N);\n        float dr = ampl * PULSE_T(t25, 2., 4., 21.) + ampl * PULSE_T(t17, .5, 7., 13.);\n        float clScheme = PULSE_T(t47, 0.75, 27., 43.);\n\n        for (int ii = A_START; ii <= A_START + A_N; ii++)\n        {\n          float ivis = noise(vec2(0.25 * time, float(ii)));\n          \n          int i0 = ii - A_START;\n          float r = mix(1.75 - dr * float(i0), 0.25 + dr * float(i0), PULSE_T(t17, 1., 4.5, 11.5));\n          float f = radial_grid(grid, float(ii), mod((0.2*cos(time * 0.1) + 0.1 * noise(vec2(float(ii), time))),PI2), r);\n          f = pow(f, (0.5 + r*0.1)/float(A_N) + 0.75/float(A_N)*ANIM_T(t5, 1., 2.5));\n          \n          int ci = (i0) % 11;\n          tcol += smoothstep(0., 0.25, ivis) * mix(plasma[ci], Blues[ci], clScheme) * vec3(1. - f);\n        }\n        \n        col += tcol * pow(0.5, it);\n    }\n    \n    // add background\n    col = clamp(col, vec3(0.), vec3(1.));\n    float rGrid = length(grid*0.15);\n    vec3 background = mix(bckColor * 0.1, bckColor * 0.8, 1. - exp(-rGrid));\n    \n    col = mix(background * 2., col, 1. - rGrid);\n    \n    return col;\n}\n\nvec3 sky(in vec2 uv) {\n  vec2 sc = uv-vec2(0.7,0.7);\n  float sr = dot(sc,sc);\n  float af = atan(sc.y, sc.x);\n  \n  vec3 sun = vec3(1.,1.,1.)*(1.-smoothstep(sr, 0.00,0.01));\n// sun = clamp(sun, 0.,1.);\n\n  vec2 duv = uv;\n\n  float f = fbm(duv);\n  float tt = 0.1*iTime;\n  float anf = noise(vec2(af*10. + tt*5., tt*4.));\n  float f2 = fbm(duv+2.*vec2(cos(f) + cos(tt), sin(f)+sin(tt)) );\n  vec3 sky = vec3(0.,0.,max(blue.b*(1.-sr), 0.));\n  vec3 col1 = mix(yellow, red, f);\n  vec3 col2 = mix(sky, white,\n    f2);\n  vec3 col = mix(col2, col1, f*f2);\n\n  //col = mix(vec3(0.,0.,0.), col, 2.*(  col.r*col.g));\n  col += sun*(4.*(1.-col.g)*exp(-col.g*4.));\n  \n  return col;\n}\n\n#define SCALE 1.0/3.14\n\n//float hash(in float _x) { return fract(5313.235 * mod(_x, 0.75182) * mod(_x, 0.1242)); }\n//float noise(in float _x) { float i = floor(_x); float f = fract(_x); return mix(hash(i), hash(i + 1.), 3.*f*f - 2.*f*f*f); }\n\n#define CL(_id, _noise)  0.5 + 0.5*cos(6.28 * (_noise * vec3(0.2, 0.8, 0.4) + vec3(3.3, 1., 1.1) * vec3(hash(_id))))\n#define ROT2(_a) mat2(cos(_a), sin(_a), -sin(_a), cos(_a))\n\nvec3 cvis(in vec2 uv) {\n    \n    //vec2 muv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n    //uv *= 1./(1. + 0.25*length(uv));\n    float r = length(uv);\n    vec2 pos = mix(vec2((r), atan(uv.y, uv.x)), vec2(log(r), atan(uv.y, uv.x)), smoothstep(-1., 1., 0.));\n    pos.x += -iTime * .5 + 0.1 * sin(pos.y*1. + iTime);\n    vec2 grid = pos * SCALE;\n    grid *= 4.;\n    vec2 c_grid = fract(grid) - vec2(0.5);\n    vec2 rc_grid = ROT2(atan(uv.y, uv.x)) * c_grid;\n    float lgr = length(c_grid);\n    float f = mod(lgr * r, 0.1);\n    vec3 fcid = CL(floor(f * 80.), 0.15);\n    f *= (1.-smoothstep(0., 0.5 / (r + 1.), lgr));\n    vec2 gf = floor(grid);\n    float cid = gf.x * 30. + gf.y;\n    \n    vec3 acol, pcol, strcol, orcol, uv_acol, fruit_col;\n    apple(uv, 0.01, uv_acol);\n    \n    int fruit_id = int(mod(cid, 4.));\n    \n    if (fruit_id == 0) {\n        apple(rc_grid, 0.01, fruit_col);\n    }\n    else if (fruit_id == 1)\n        pear(rc_grid, 0.04, fruit_col);\n    else if (fruit_id == 2) {\n        strawberry(rc_grid, 0.01, fruit_col);\n    }\n    else if (fruit_id == 3)\n        orange(rc_grid, 0.05, fruit_col);\n    else\n        fruit_col = vec3(1., 0., 0.);\n        \n    //f = length(fract(grid) - vec2(0.5));\n    // Time varying pixel color\n    vec3 col = 5. * f * (CL(cid, iTime * 1.));\n    col = mix(fruit_col + 0.5*col, 0.25*vec3(0.1, 0.6, 0.9), 0.05 * r * r);\n    col *= 2.;\n    col /= (col * 0.2 + vec3(0.2));\n    \n    col += max(uv_acol, vec3(0.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) --> scaled\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 uv2 = fragCoord/iResolution.y;\n    vec2 ruv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    \n    \n    vec3 col;\n    \n    vec3 fcol = flower(uv);\n    vec3 scol = sky(mix(uv, uv2, noise(100. + iTime*0.25)));\n    vec3 cvcol = cvis(uv);\n    float t_anim = mod(iTime, SCENE_ANIM_TIME) / SCENE_ANIM_TIME;\n\n    //col = mix(fcol, scol, mod(iterm, 2.));\n    col = mix(col, cvcol, PULSE_T(t_anim, 0.05, 0.05, 0.2));\n    col = mix(col, scol, PULSE_T(t_anim, 0.05, 0.3, 0.75));\n    col = mix(col, fcol, PULSE_T(t_anim, 0.05, 0.85, 0.95));\n    \n    //col *= PULSE_T(t_anim, 2., 2., SCENE_ANIM_TIME - 2.);\n    \n    col /= (col*0.25 + vec3(1.));\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}