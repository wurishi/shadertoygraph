{"ver":"0.1","info":{"id":"3lSfDt","date":"1604253459","viewed":150,"name":"2d_four_noises23","username":"edwardbraed","description":"Four 2D noises (value, perlin, simplex, cellular) for visual comparison\n3d version - https://www.shadertoy.com/view/ttBfWt","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["perlin","simplex","value","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define OCTAVES 1\n#define SCALE 16.0\n#define POINTS_IN_CELL 1.0\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\nvec2 quantic(vec2 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand2(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------\n//- Value noise --------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nfloat valueNoise2(vec2 p)\n{\n\tvec2 ip = floor(p);\n    vec2 lp = p - ip;\n    vec2 q  = quantic(lp);\n    \n    float v1 = rand2(ip); //+ vec2(0.0, 0.0);\n    float v2 = rand2(ip     + vec2(1.0, 0.0));\n    float v3 = rand2(ip     + vec2(0.0, 1.0));\n    float v4 = rand2(ip     + vec2(1.0, 1.0));\n    \n\treturn mix(mix(v1, v2, q.x), \n               mix(v3, v4, q.x), q.y);\n}\n\nfloat valueFBM2(vec2 pos)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < OCTAVES; x++)\n    {\n        ma += amplitude;\n        res += valueNoise2(pos) * amplitude;\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n//----------------------------------------------------------------------------------\n//- Perlin noise -------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvec2 noiseVector2(vec2 p)\n{\n    float rv = rand2(p);\n    \n    if     (rv < 0.25) return vec2( 1.0,  0.0);\n    else if(rv < 0.50) return vec2(-1.0,  0.0);\n    else if(rv < 0.75) return vec2( 0.0,  1.0);\n                       return vec2( 0.0, -1.0);\n}\n\nfloat perlinNoise2(vec2 p)\n{\n\tvec2 ip = floor(p);\n    vec2 lp = p - ip;\n    vec2 q  = quantic(lp); \n    \n    vec2 nv1 = noiseVector2(ip); // + vec2(0.0,0.0);\n    vec2 nv2 = noiseVector2(ip      + vec2(1.0,0.0));\n    vec2 nv3 = noiseVector2(ip      + vec2(0.0,1.0));\n    vec2 nv4 = noiseVector2(ip      + vec2(1.0,1.0));\n    \n    vec2 dv1 = vec2(lp); // - vec2(0.0,0.0);\n    vec2 dv2 = vec2(lp      - vec2(1.0,0.0));\n    vec2 dv3 = vec2(lp      - vec2(0.0,1.0));\n    vec2 dv4 = vec2(lp      - vec2(1.0,1.0));\n    \n    float v1 = dot(nv1, dv1);\n    float v2 = dot(nv2, dv2);\n    float v3 = dot(nv3, dv3);\n    float v4 = dot(nv4, dv4);\n    \n\treturn mix(mix(v1,v2,q.x), mix(v3,v4,q.x), q.y);\n}\n\nfloat perlinFBM2(vec2 pos)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    \n    for(int x = 0; x < OCTAVES; x++)\n    {\n        ma += amplitude;\n        res += (0.5 + perlinNoise2(pos)) * amplitude;\n        //res += abs(perlinNoise2(pos) * amplitude);\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n//----------------------------------------------------------------------------------\n//- Simplex noise ------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvec2 simplexVector2(vec2 p)\n{   \n    const vec2 vecs[8] =  vec2[8]( vec2( 1.0,  1.0),\n                                   vec2(-1.0,  1.0),\n                                   vec2( 1.0, -1.0),\n                                   vec2(-1.0, -1.0),\n                                   vec2( 1.0,  0.0),\n                                   vec2(-1.0,  0.0),\n                                   vec2( 0.0,  1.0),\n                                   vec2( 0.0, -1.0));\n    \n    return vecs[int(rand2(p) * 8.0)];\n}\n\n// this realization from: \n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\nfloat simplexNoise2(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    float s = (p.x + p.y) * K1;\n    vec2 i = floor(p + s);\n    \n    float t = (i.x + i.y) * K2;\n    vec2 ti = i - t;\n    vec2 a = p - ti;\n    \n    vec2 o = (a.x > a.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0));\n    \n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    \n    vec2 g1 = simplexVector2(i);\n    vec2 g2 = simplexVector2(i + o);\n    vec2 g3 = simplexVector2(i + 1.0);\n    \n    float t1 = 0.5 - (a.x * a.x) - (a.y * a.y);\n    float t2 = 0.5 - (b.x * b.x) - (b.y * b.y);\n    float t3 = 0.5 - (c.x * c.x) - (c.y * c.y);\n    \n    float n1 = float(t1 > 0.0) * (t1 * t1 * t1 * t1 * dot(g1, a));\n    float n2 = float(t2 > 0.0) * (t2 * t2 * t2 * t2 * dot(g2, b));\n    float n3 = float(t3 > 0.0) * (t3 * t3 * t3 * t3 * dot(g3, c));\n        \n    return (1.0 + 70.0 * (n1 + n2 + n3)) * 0.5;\n}\n\nfloat simplexFBM2(vec2 pos)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    \n    for(int x = 0; x < OCTAVES; x++)\n    {\n        ma += amplitude;\n        res += simplexNoise2(pos) * amplitude;\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n//----------------------------------------------------------------------------------\n//- Cellular noise -----------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nfloat calcCell(vec2 pos, vec2 ipos)\n{\n    float md = 1.0; // min distance\n    for(float x = 0.1; x < POINTS_IN_CELL; x++)\n    {   \n        float ptX = rand2(ipos.xy + x * 0.23);\n        float ptY = rand2(ipos.yx + x * 0.16);\n        \n        md = min(md, distance(pos, ipos + vec2(ptX, ptY)));\n    }\n    return md;\n}\n\nfloat cellularNoise(vec2 pos)\n{\n    float res = 1.0;\n    \n    vec2 ipos = floor(pos);\n    \n    res = min(res, calcCell(pos, ipos + vec2(-1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec2( 0.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec2( 1.0, -1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec2(-1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec2( 0.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec2( 1.0,  0.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec2(-1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec2( 0.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec2( 1.0,  1.0)));\n    \n    return res;\n}\n\nfloat cellularFBM2(vec2 pos)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < OCTAVES; x++)\n    {\n        ma += amplitude;\n        res += cellularNoise(pos) * amplitude;\n        //res += abs(cellularNoise(pos) * amplitude);\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspect = calcAspect(iResolution.xy);\n\n    vec2 nPos = vec2(SCALE) * uv * aspect;\n    \n    vec3 rgb;\n    \n    if(uv.x < 0.5 && uv.y < 0.5)\n        rgb = vec3(valueFBM2(nPos * 1.5));\n    else if(uv.x > 0.5 && uv.y < 0.5)\n        rgb = vec3(perlinFBM2(nPos * 1.5));\n    else if(uv.x > 0.5 && uv.y >= 0.5)\n        rgb = vec3(simplexFBM2(nPos * 1.5));\n    else\n        rgb = vec3(cellularFBM2(nPos * 1.5));\n    \n    // Output to screen\n    fragColor = vec4(rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}