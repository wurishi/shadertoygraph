{"ver":"0.1","info":{"id":"NdK3DV","date":"1632401034","viewed":54,"name":"loka：【故障10-1】波动抖动故障","username":"LokaHer","description":"  1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _DIR 1\n#define _Speed (0.2)\n#define strength (2. * cos(iTime))\n#define _Amount (2. * sin(iTime))\n\n#define NOISE_SIMPLEX_1_DIV_289 0.00346020761245674740484429065744\n\nvec2 mod289(vec2 x)\n{\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec3 mod289(vec3 x)\n{\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec3 permute(vec3 x)\n{\n\treturn mod289(x * x * 34.0 + x);\n}\n\nvec3 taylorInvSqrt(vec3 r)\n{\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\n\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nfloat value_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;//相当于fract\n\t\n\t//取代smoothstep手动生成平缓曲线\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x),\n               mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\n\nfloat perlin_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n                   dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n                   dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\n\nfloat snoise(vec2 v)\n{\n\tconst vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n\t0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n\t- 0.577350269189626, // -1.0 + 2.0 * C.x\n\t0.024390243902439); // 1.0 / 41.0\n\t// First corner\n\tvec2 i = floor(v + dot(v, C.yy));\n\tvec2 x0 = v - i + dot(i, C.xx);\n\t\n\t// Other corners\n\tvec2 i1;\n\ti1.x = step(x0.y, x0.x);\n\ti1.y = 1.0 - i1.x;\n\t\n\t// x1 = x0 - i1  + 1.0 * C.xx;\n\t// x2 = x0 - 1.0 + 2.0 * C.xx;\n\tvec2 x1 = x0 + C.xx - i1;\n\tvec2 x2 = x0 + C.zz;\n\t\n\t// Permutations\n\ti = mod289(i); // Avoid truncation effects in permutation\n\tvec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) \n    + i.x + vec3(0.0, i1.x, 1.0));\n\t\n\tvec3 m = max(0.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n\tm = m * m;\n\tm = m * m;\n\t\n\t// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\t// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\tvec3 h = abs(x) - 0.5;\n\tvec3 ox = floor(x + 0.5);\n\tvec3 a0 = x - ox;\n\t\n\t// Normalise gradients implicitly by scaling m\n\tm *= taylorInvSqrt(a0 * a0 + h * h);\n\t\n\t// Compute final noise value at P\n\tvec3 g;\n\tg.x = a0.x * x0.x + h.x * x0.y;\n\tg.y = a0.y * x1.x + h.y * x1.y;\n\tg.z = a0.z * x2.x + h.z * x2.y;\n\treturn 130.0 * dot(m, g);\n}\n\n\n\n\nvec3 WaveJitterGlitch(vec2 uv)\n{\n    float uv_y = uv.y * iResolution.y;\n    float noise_wave_1 = snoise(vec2(uv_y * 0.01, iTime * _Speed * 20.)) * (strength * _Amount * 32.);\n\n    float noise_wave_x = noise_wave_1 / iResolution.x;\n    float uv_x = uv.x + noise_wave_x;\n    vec3 col = texture(iChannel0, vec2(uv_x, uv.y)).xyz;\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = WaveJitterGlitch(uv);  \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}