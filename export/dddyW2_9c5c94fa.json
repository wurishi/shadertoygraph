{"ver":"0.1","info":{"id":"dddyW2","date":"1695871028","viewed":50,"name":"Sketch #16: 3D Grid","username":"MOONtyzoo","description":"Learned raymarching from Art of Code and expanded on the algorithms to include color.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MIN_DIST 0.25\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nstruct sdfData\n{\n    float dist;\n    vec4 col;\n};\n\nsdfData SdfU(sdfData a, sdfData b)\n{\n    if (a.dist < b.dist) {return a;}\n    else {return b;}\n}\n\nsdfData SdfGrid(vec3 p)\n{\n    p = vec3(0.5) - fract(p - vec3(0.5));\n    \n    float xDist = sqrt(p.y*p.y + p.z*p.z);\n    float yDist = sqrt(p.x*p.x + p.z*p.z);\n    float zDist = sqrt(p.y*p.y + p.x*p.x);\n    vec4 xCol = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 yCol = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 zCol = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    sdfData sdfX = sdfData(xDist, xCol);\n    sdfData sdfY = sdfData(yDist, yCol);\n    sdfData sdfZ = sdfData(zDist, zCol);\n    return SdfU(sdfX, SdfU(sdfY, sdfZ));\n}\n\n/*\n    Returns vec4 with (r, g, b, dist)\n    \n    Defines all of the objects that are visible in the scene\n*/\nsdfData SdfScene(vec3 p)\n{ \n    sdfData grid = SdfGrid(p);\n    grid.dist -= 0.01;\n    \n    return grid;\n}\n\n// ---------------------------------------------------\n\n/*\n    Returns distance from ro along rd to the hitpoint\n    Also outputs the color of the sdf surface that is hit\n*/\nfloat RayMarch(vec3 ro, vec3 rd, out vec4 col)\n{\n    float dist = MIN_DIST;\n    col = vec4(0.859,0.859,0.859, 1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dist * rd;\n        \n        sdfData sdf = SdfScene(p);\n        float stepDist = sdf.dist;\n        dist += stepDist;\n        \n        if (dist > MAX_DIST) break;\n        if (stepDist < SURF_DIST)\n        {col = sdf.col; break;}\n    }\n    \n    return dist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 d = vec2(0.0, 0.01);\n    \n    vec3 n = (SdfScene(p).dist -\n              vec3(SdfScene(p - d.yxx).dist,\n                   SdfScene(p - d.xyx).dist,\n                   SdfScene(p - d.xxy).dist));\n    \n    return normalize(n);\n}\n\nvec3 ShadePoint(vec3 p, vec4 col)\n{\n    vec3 l = normalize(vec3(-1, -1, -1));\n    vec3 n = GetNormal(p);\n    float val = 0.6 + (dot(l, n) + 1.0)/5.0;\n    \n    return val*col.rgb;\n}\n\n// ---------------------------------------------------\n\nmat4 cameraLookAt(vec3 from, vec3 to)\n{\n    vec3 forward = normalize(from-to);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    mat4 mat =  mat4(right.x, right.y, right.z, 0.0,\n                up.x, up.y, up.z, 0.0,\n                forward.x, forward.y, forward.z, 0.0,\n                from.x, from.y, from.z, 1.0);\n                \n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(3.5*sin(0.3*iTime), 3.0, 3.5*cos(0.3*iTime));\n    vec3 rd = normalize( cameraLookAt(ro, vec3(0.0)) * vec4(uv.x, uv.y, -1.0, 0.0) ).xyz;\n    \n    vec4 sdfCol;\n    float dist = RayMarch(ro, rd, sdfCol);\n    \n    vec3 p = ro + dist * rd;\n    vec3 col = ShadePoint(p, sdfCol);\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}