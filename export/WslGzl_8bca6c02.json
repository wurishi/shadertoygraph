{"ver":"0.1","info":{"id":"WslGzl","date":"1547222847","viewed":546,"name":"Precise function drawer","username":"jaszunio15","description":"Function graph drawer\nTo add function:\n1. Increase FUNCTIONS_COUNT\n2. Add your function: float funcX(float x) ...\n3. Add functionData[previous index + 1] = INITIALIZE_FUNCTION(funcX, your color); in mainImage\n\nComment #define ANIMATE to disable animation","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["math","function","plot","visualisation","tool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan MrÃ³z (jaszunio15)\n\n//Number of functions to draw on screen\n#define FUNCTIONS_COUNT 4\n\n//View setting\n#define SCALE_X 8.0\n#define SCALE_Y 4.5\n#define CENTER_POINT vec2(0.0, 0.0)\n#define THICKNESS 0.004\n\n//Grid setting\n#define GRID_THICKNESS 0.004\n#define GRID1_DENSITY 1.0\n#define GRID2_DENSITY 0.5\n#define GRID_INTENSITY 0.2\n\n//comment ANIMATE to disable animation\n#define ANIMATE\n#define ANIMATION_TIMESCALE 0.3\n\n//Define your function here:\nfloat func1(float x) { return sin(x + iTime) * sin(iTime * 0.4); }\nfloat func2(float x) { return x * x * 0.2 - 4.0; }\nfloat func3(float x) { return (sin(x) * exp(-x * x * 0.5)) * 5.0; }\nfloat func4(float x) { return (10.0/(sqrt(2.0*PI))*exp(-x*x/2.0)*x*x*x*log(abs(x))-1.0)*cos(x*2.0+iTime*0.3); } //My improvisation :v\n\n#define INITIALIZE_FUNCTION(f, color) funcData( f (uv.x), color , (f(uv.x+EPSILON)-f(uv.x-EPSILON)) / (2.0 * EPSILON), true)\n#define INITIALIZE_FUNCTION_WITH_DOMAIN(f, color, domain) funcData( f (uv.x), color , (f(uv.x+EPSILON)-f(uv.x-EPSILON)) / (2.0 * EPSILON), domain)\n\nstruct funcData\n{\n \tfloat value;\n    vec3 color;\n    float derivative;\n    bool inDomain;\n};\n   \n//For grid calc\nvec2 triangleFunc(vec2 x) { return (abs(fract(x) - 0.5)) * 2.0; }\n    \n//for animation\nfloat hash(vec3 x)\n{\n \treturn fract(sin(dot(x, vec3(14.1452, 8.5293, 23.2201))) * 2416.1057);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //uv = coordinate system\n    vec2 uv = (fragCoord) * 2.0 / iResolution.xy;\n    uv -= 1.0;\n    uv *= vec2(SCALE_X, SCALE_Y);\n    uv += CENTER_POINT;\n    \n    //function and grid thickness\n    float aspect = (iResolution.y / iResolution.x) / (SCALE_Y / SCALE_X);\n    float hdScale = 1080.0 / iResolution.y;\n    float thickness = THICKNESS * hdScale * min(SCALE_X, SCALE_Y);\n    float gridThickness = GRID_THICKNESS * hdScale * min(SCALE_X, SCALE_Y);\n    \n    //Add your function here \n\t//INITIALIZE_FUNCTION(your_function_name, color) where color is vec3 variable\n\t//INITIALIZE_FUNCTION_WITH_DOMAIN(your_function_name, color, domain), where domain is boolean\n    //uv.x is an argument, and uv.y is function value\n    funcData[FUNCTIONS_COUNT] functionData;\n    functionData[0] = INITIALIZE_FUNCTION(func1, vec3(1.0, 1.0, 0.0));\n    functionData[1] = INITIALIZE_FUNCTION(func2, vec3(0.0, 1.0, 1.0));\n    functionData[2] = INITIALIZE_FUNCTION_WITH_DOMAIN(func3, vec3(1.0, 0.0, 1.0), uv.y > func2(uv.x) || uv.x > 0.0);\n    functionData[3] = INITIALIZE_FUNCTION(func4, vec3(0.0, 1.0, 0.0));\n    \n    vec3 mainColor = vec3(0.0);\n    for (int i = 0; i < FUNCTIONS_COUNT; i++)\n    {\n        //vertical distance to function and dericative\n        float distanceToFunction = abs(uv.y - functionData[i].value);\n        float tgAlpha = clamp(abs(functionData[i].derivative * aspect), 0.0, 16.0); //clamp to avoid vertical lines (e.g. saw or square function)\n\n        #ifdef ANIMATE\n\n        //Saw along x axis randomly shifted for each function based on color\n        float saw = fract((fragCoord.x / iResolution.x) - (iTime * ANIMATION_TIMESCALE * hash(functionData[i].color)) + hash(functionData[i].color));\n        float verticalThickness = sqrt(tgAlpha * tgAlpha + 2.0);\n        float intensity = 1.0 - smoothstep(0.0, thickness * (0.5 + saw), distanceToFunction / verticalThickness);\n        vec3 col = mix(functionData[i].color, vec3(1.0), vec3(POW8(saw)));\n        if (functionData[i].inDomain) mainColor += col * POW4(intensity) * saw;\n\n        #else\n\n        //vertical thickness from normal thickness and derivative\n        float verticalThickness = sqrt(tgAlpha * tgAlpha + 2.0);\n        float intensity = 1.0 - smoothstep(0.0, thickness, distanceToFunction / verticalThickness);\n        if (functionData[i].inDomain) mainColor += functionData[i].color * POW4(intensity);\n\n        #endif\n    }\n    \n    //Adding grid\n    vec2 grid;\n    \n    //OY and OX axis\n    grid = smoothstep(vec2(1.0) - vec2(gridThickness * aspect, gridThickness), vec2(1.0), 1.0 - abs(uv));\n    mainColor += vec3(max(grid.x, grid.y)) * GRID_INTENSITY * 0.5;\n    \n    //GRID1\n    grid = smoothstep(vec2(1.0) - vec2(gridThickness * aspect, gridThickness) / GRID1_DENSITY, vec2(1.0), triangleFunc(uv / GRID1_DENSITY));\n    mainColor += vec3(max(grid.x, grid.y)) * GRID_INTENSITY;\n    \n    //GRID2\n    grid = smoothstep(vec2(1.0) - vec2(gridThickness * aspect, gridThickness) / GRID2_DENSITY, vec2(1.0), triangleFunc(uv / GRID2_DENSITY));\n    mainColor += vec3(max(grid.x, grid.y)) * GRID_INTENSITY * 0.5;\n    \n    fragColor = vec4(mainColor, 0.0);\n    \n    //fragColor=vec4(pow(mainColor,vec3(.4545)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415927\n#define POW4(x) (x*x*x*x)\n#define POW8(x) (x*x*x*x*x*x*x*x)\n#define EPSILON 0.001","name":"Common","description":"","type":"common"}]}