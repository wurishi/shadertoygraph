{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\nProcural image made for Revision 2021 4k Excutable Graphics competition\n\nReleased executable can be found here: https://demozoo.org/graphics/292427/\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t       \n    vec2 res = iResolution.xy;\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/res.xy;\n\t\n\tvec4 value=texture(iChannel0,uv);\n    \n    \n    vec3 col=value.xyz/value.w;\n    \n    // basic \"tonemapping\"\n    col = smoothstep(0.,1.,col);\n    col = pow(col, vec3(0.4545));\n    \n\tfragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\nProcural image made for Revision 2021 4k Excutable Graphics competition\n\nReleased executable can be found here: https://demozoo.org/graphics/292427/\n*/\n\nfloat time;\n\n//DAVE HOSKINS' HASH FUNCTIONS\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// noise functions\n\nfloat srnd21(vec2 p)\n{\n    vec2 ip=floor(p);\n    p=fract(p);\n    p=smoothstep(0.,1.,p);\n    \n    float p1 = mix(rnd21(ip),rnd21(ip+vec2(1,0)),p.x);\n    float p2 = mix(rnd21(ip+vec2(0,1)),rnd21(ip+vec2(1,1)),p.x);\n    \n    return mix(p1,p2,p.y);\n}\n\nfloat noise21(vec2 p, float pro, float st) {\n    float v=0.0;\n    float s=0.5;\n    for(float i=0.; i<st; ++i) {\n        v+=srnd21(p+i*72.3)*s;\n        p*=pro;\n        s*=0.5;\n    }\n    return v;\n}\n\nfloat srnd31(vec3 p7)\n{\n    vec3 ip=floor(p7);\n\t\n    p7=fract(p7);\n    //p7=smoothstep(0.,1.,p7);\n    \n    float p1 = mix(rnd31(ip),rnd31(ip+vec3(1,0,0)),p7.x);\n    float p2 = mix(rnd31(ip+vec3(0,1,0)),rnd31(ip+vec3(1,1,0)),p7.x);\n    float p3 = mix(rnd31(ip+vec3(0,0,1)),rnd31(ip+vec3(1,0,1)),p7.x);\n    float p4 = mix(rnd31(ip+vec3(0,1,1)),rnd31(ip+vec3(1,1,1)),p7.x);\n    \n    return mix(mix(p1,p2,p7.y),mix(p3,p4,p7.y),p7.z);\n}\n\nfloat noise31(vec3 p8, float pro, float st) {\n    float v=0.0;\n    float s3=0.5;\n    for(float g=min(0.,float(iFrame)); g<st; ++g) {\n        v+=srnd31(p8+g*72.3)*s3;\n        p8*=pro;\n        s3*=0.5;\n    }\n    return v;\n}\n\n// useful functions\n\nfloat c01(float a) {return clamp(a,0.,1.);}\n\nfloat smin(float a, float b, float h) {\n\tfloat k=c01((a-b)/h*.5+.5);\n\treturn mix(a,b,k)-k*(1.-k)*h;\n}\n\nfloat pi=acos(-1.);\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// sdf functions\n\nfloat box(vec3 p, vec3 s) {\n    p=abs(p)-s;\n    return max(p.x, max(p.y,p.z));\n\t//return length(max(p,vec3(0))) + min(0.,max(p.x,max(p.y,p.z)));\n}\n\n// hexagonal shape with specified size\nfloat hex(vec3 p, vec3 s) {\n  vec3 ap=abs(p);\n  float prof=max(ap.x-s.x,(ap.x+ap.z)*.7-s.z);\n  return max(ap.y+max(-1.,prof)-s.y,prof);\n}\n\n// sdf to randomly moved boxes in a grid of size re\nfloat gribble(vec3 p, vec3 re) {\n  vec3 r1=(fract(p/re+.5)-.5)*re;\n  return box(r1+rnd33(floor(p/4.+.5))*2.-1.,re*.4)*.7;\n}\n\n// vessel distance function\nfloat vessel(vec3 p) {\n  \n  p.x=abs(p.x);\n  // main frame\n  float d = box(p, vec3(8,5,30));\n  \n  // top 3 layers\n  float u = min(hex(p-vec3(0,0,15),vec3(6,7,20)),min(hex(p-vec3(0,0,24),vec3(4,9,12)),hex(p-vec3(0,0,28),vec3(2,11,8))));\n  u=max(u, (u+p.y+p.z*.3)*.7-5.);\n  d=min(d, u);\n  \n  // box random details\n  float g1=gribble(p, vec3(4,4,10));\n  float g2=gribble(p+3., vec3(7,3,8));\n  \n  d=min(d,max(d-0.4,g1));\n  d=min(d,max(d-0.3,g2));\n  \n  // reactors\n  vec3 p2=p-vec3(0,2,0);\n  p2.x=abs(p2.x)-5.;\n  d=min(d, max(abs(p.z-38.)-8.,abs(length(p2.xy)-3.-sin(p.z*.3+.9))-.3)-g1*.2);\n  \n  // wings\n  vec3 p3=p;\n  p3.xy*=rot(.3);\n  vec3 ap=abs(p3-vec3(0,0,22));\n  float l=max(p3.z-26.,max(abs(p3.y-1.)-.3,(ap.x*.7+ap.z*.3)-14.))-g2*.2;\n  d=min(d, l);\n  \n  return d*.8;\n}\n\n// all global values I will need later\nfloat vesd=0.; // distance to vessel\nvec3 vesp=vec3(0); // local position of pixel in vessel space\nfloat smoke2=1.; // smoke opacity\nfloat lsmo=0.; // last smoke distance (to darken vessel around smoke)\nvec3 smp=vec3(0); // smoke pixel position\nfloat humd=0.; // distance to the character\nfloat map(vec3 p){\n    float d=10000.0;\n\n\t// ground distance\n\tvec2 uv1 = p.xz;\n\tfloat lh=noise21(uv1*0.02,2.,5.);\n    // main ground shape\n\tfloat h=pow(lh,3.) * (25.-60.*c01((length(p)-400.)/100.));\n    // turn ground into stratified layers\n\th=(floor(h)+smoothstep(0.,1.,fract(h)))*2.;\n    // rock detail shapes\n\th+=pow(noise31(p*vec3(1,8,1),lh*5.+1.,3.),2.) * 3.;\n    // sand part\n\th=smin(h, lh+7.+h*.05,5.);\n\t\n    // vessel location\n\tvesp=p.zyx+vec3(100,0,100);\n\t\n\t// foot path\n\tvec2 uv3 = vesp.xz-vec2(10,0);\n\tuv3*=rot(sin(vesp.x*.251)*.1);\n\tfloat mark=smoothstep(0.,1.,sin(uv3.x*4.+sign(uv3.y)*2.));\n\tfloat path=c01(.3-abs(abs(uv3.y)-.4)*2.+mark*.3)*(mark*.3+.5)*smoothstep(12.1,12.,abs(uv3.x-28.));\n\th+=min(.1,path);\n\n    // final ground sdf\n\tfloat g=-p.y + h;\n\td=min(d, g*.9);\n\t\n\t// vessel sdf\n\tvesp.yz*=rot(.6);\n\tvesp.xz*=rot(.2);\n\tvesd=vessel(vesp);\n\td=min(d, vesd);\n\n\t// character sdf\n\tvec3 p4a=(p+vec3(100.1,-6.5,50.3))-vec3(0,2.5-2.5-.1,0);\n\tvec3 p4=p4a;\n\tvec3 p5=p4;\n\tvec3 p6=p4;\n\tp5.z=abs(p5.z)+.1;\n\tp5.x+=sin(p4a.y*3.)*.2+.1;\n\tp5.zy*=rot(-.25);\n    // head\n\tfloat m=length(p4)-.2;\n    // body\n\tp4.x+=sin(p4a.y*6.+3.)*.05+.1;\n\tp4.y=abs(p4.y-.75)-.2;\n\tp4.y=abs(p4.y)-.1;\n\tm=smin(m, length(p4)-.25,.18);\n\tm=smin(m, max(1.-p5.y,length(p5.xz)-.1),.1);\n\tm=min(m, .7*max(1.-p5.y,length(p5.xz)-.1+sin(p4a.y*12.)*.05));\n\tp5.z-=.3;\n\tp5.x-=.1;\n\tm=smin(m, max(abs(-p5.y+.9)-.5,length(p5.xz)-.1),.2);\n\tm=smin(m, max(abs(-p4.y+.1)-.1,length(p5.xz)-.13),.1);\n\tp6.x+=.3;\n\tp6.z=abs(p6.z)-.1;\n\tm=min(m, max(abs(-p6.y+.65)-.4,length(p6.xz)-.4+.7*max(.3,abs(-p6.y+.65)))*.7);\n\thumd=m;\n\td=min(d,m);\n\t\n\t// smoke sdf\n\tvec3 p3 = p+vec3(110,0,94);\n\tp3.x+=p3.y*.3;\n\tp3.xz=abs(p3.xz*rot(p3.y*.07+sin(p3.y*.5)*.3))-5.;\n\tfloat smoke=length(p3.xz)+1.-p3.y*.05;\n\tlsmo=smoke;\n\tsmp=mix(p,smp,c01(smoke-5.));\n\tsmoke2*=c01(.4+(smoke)*.1);\n\t\n\td=min(d, smoke);\n    \n    return d;\n}\n\n\nfloat dither=1.;\n\nfloat shadow(vec3 p, vec3 l) {\n    float shad=1.0;    \n    float dd=0.;\n    for(int i=0;i<50; ++i) {\n        float d=map(p);\n        shad=min(shad,(abs(d)-.01)*100.);\n        if(d<0.01) {\n            shad=0.0;\n            break;\n        }\n        if(dd>20.) break;\n        p+=l*d;\n        dd+=d;\n    }\n    return shad;\n}\n\n// main lighting direction\nvec3 l = normalize(vec3(7,-2,0));\n\nvec3 sky(vec3 r, float dd, int it) {\n\tvec2 uvs=vec2(atan(r.z,r.x),r.y);\n    // \"clouds\"\n\tfloat n=noise21(uvs*vec2(7,50),3.7,3.);\n\tfloat n2=noise21(uvs*vec2(7,50)+vec2(.3,-.1),3.7,3.);\n\tfloat push=dd>900.?smoothstep(0.0,0.3,n2-n):0.;\n    // sky color\n\tvec3 sk=mix(vec3(.7,.5,.3)*(.9+.5*push),vec3(.4,0.3,0.2),dd>900.?c01((n-.3)*5.*(-r.y*10.)+5.*c01((-.1-abs(r.y))*2.)):.5);\n    // dark to see the sky\n\tsk=mix(sk*pow(vec3(cos(max(-5.5,r.y*9.))*.5+.5),vec3(2.,3.,2.3))*2.,vec3(0),c01(r.y));\n\n\t// sun halo\n\tvec3 l2 = normalize(vec3(7,-0.9,0)); // fake sun for composition\n\tsk+=pow(max(0.,dot(r,l2)),60.)*vec3(1,0.5,0.3)*1.2;\n\tsk+=smoothstep(0.9996,0.9998,dot(r,l2))*vec3(1,0.5,0.3);\n\n\t// far sky details\n\tif(dd>900.) {\n\t\tvec2 suv=uvs*3.;\n\t\tfloat nn = smoothstep(0.2,0.7,noise21(suv*vec2(5,20), 2., 3.));\n        // star belt\n\t\tnn += .07/(.01+abs(suv.y+suv.x*.2+1.));\n  \n        // stars\n\t\tfor(float i=0.;i<3.;++i) {\n\t\t\tsuv*=rot(.7);\n\t\t\tfloat grid=70.+i*10.;\n\t\t\tvec3 starid=rnd23(floor(suv*grid));\n\t\t\tvec2 staruv=fract(suv*grid)-.5;\n\t\t\tfloat stard=length(staruv+(starid.xy-.5)*.5);\n\t\t\tfloat starsmo=i*.07+.01;\n\t\t\tsk += .8*nn*pow(rnd11(starid.z),10.)*(.7+.3*max(sin(vec3(.8,1.7,.9)*3.*starid.z+i*10.),0.)) * smoothstep(.4,0.,stard)*starsmo/(starsmo+stard);\n\t\t}\n\t\tsk += nn*.01; // dust\n  \n        // meteroids\n\t\tvec2 muv=suv+vec2(.2+.2,-.3-.7);\n\t\tmuv*=rot(2.3)*1.3;\n\t\tfor(float i=0.;i<30.;++i) {\n\t\t\tfloat pp=-.1-sin(i*.7)*.3;\n\t\t\tmuv*=rot(sin(pp)*.3);\n\t\t\tfloat pro=cos(pp*7.);\n            // trail\n\t\t\tsk += vec3(1,.5,.3)*0.002*c01(1.-abs(.5+muv.y+pro*.15)*3.)/(0.001+abs(muv.x));\n            // meteroids\n\t\t\tif(length((.007*sin(suv*41.)+muv+vec2(0,0.2*pro+.7))*vec2(2,1))<.015) sk=vec3(0.2+smoothstep(0.,0.3,-muv.x*20.)*.7+sin(muv.y*170.)*sin(muv.x*170.)*.1);\n\t\t}\n\t}\n\t\n\treturn sk;\n}\n\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 getnormal(vec3 pos) {\n\n    vec3 eps = vec3(.001, 0, 0);\n\t\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += map(pos + eps * invert) * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t         \n\n\ttime = float(iFrame);\n    \n    vec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-iResolution.xy*0.5)/iResolution.y;\n    \n    vec4 finalcolor = vec4(0);\n    if(iFrame>0) {\n        finalcolor += texture(iChannel0, fragCoord/iResolution.xy);\n    }\n    \n    // verify if middle mouse clicked or if resolution changed\n    if(iMouse.z > .5 || texelFetch(iChannel0, ivec2(0),0).y != iResolution.y) {\n        finalcolor=vec4(0);\n    }\n\t\n    // separate rendering by tiles so browser doesn't freeze computer\n    int tilecount = 20;\n    int curtile = int(frag.y*float(tilecount)/iResolution.y);\n    \n    if(iFrame%tilecount == curtile) {\n        \n        // random jitter on uv to get antialiasing\n        vec2 uv = (frag-iResolution.xy*0.5+1.5*rnd23(frag+time).xy)/iResolution.y;\n\n        vec3 finalp=vec3(0);\n        vec3 finals=vec3(0);\n        vec3 finaln=vec3(0,1,0);\n\n        // raymarching dither to avoid any banding\n        dither = .9+.1*rnd21(frag+time*.7);\n\n        // camera position\n        vec3 s=5.*vec3(-28.635,-1.601,-4.168);\n        vec2 camr=vec2(8.455,.152);\n\n        vec3 cz=normalize(vec3(sin(camr.x)*cos(camr.y), sin(camr.y), cos(camr.x)*cos(camr.y)));\n        vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n        vec3 cy=cross(cz,cx);\n\n        float fov = 1.0;\n\n        float motime = time;\n\n        vec2 h = rnd23(frag-13.6+motime*37.7).xy * vec2(1.,6.283);\n        vec3 voff = sqrt(h.x)*(cx*sin(h.y)+cy*cos(h.y))*.3/iResolution.y;\n        // persp\n        vec3 r=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov);\n        finals=s;\n\n        vec3 col=vec3(0);\n        \n        vec3 bs = s;\n        vec3 alpha=vec3(1.0);\n        int bounce=4;\n        int ZERO = min(0,iFrame);\n        for(int j=ZERO; j<bounce; ++j) {\n        \n            smp=vec3(0);\n\n            for(int i=0; i<100; ++i) {\n                float d=map(s);\n                if(d<0.001) break;\n                if(d>1000.0) break;\n                s+=r*d*dither;\n            }\n\n            float vesd2=vesd;\n            vec3 vesp2=vesp;\n            float humd2=humd;\n\n            // smoke darkening and color\n            float smn=noise31(smp,4.,3.);\n            col += alpha * smoothstep(0.3,0.,smoke2)*(vec3(.3,.2,.1)*smoothstep(.4,.6,smn)+vec3(1,0.2,0.1)*smoothstep(0.3,1.,smn))*4.;\n            alpha*=pow(smoke2,2.);\n            alpha*=smoothstep(0.,1.,lsmo-7.)*.5+.5;\n\n            // surface normal\n            vec3 n=getnormal(s);\n            \n            // are we far enough\n            float dd=length(s-finals);\n            if(dd>1000.) {\n                col += sky(r,dd,j)*alpha;\n                // early out\n                break;\n            } else {\n\n                // fresnel\n                float fre=pow(max(0.,1.-abs(dot(r,n))),1.0);\n\n                vec3 val=vec3(0);\n\n                // shadow\n                float shad = shadow(s+n*0.1+l*0.1,l);\n                // mix ground diffuse colors\n                vec3 sand=mix(vec3(.9,.65,.4),vec3(0.3,.2,.1),c01(s.y-8.));\n                vec3 rock=mix(vec3(.3,0.1,0.1)*0.,vec3(.8,.7,.6),c01((abs(n.x)-.1)*10.));\n                vec3 diff=mix(rock,sand,c01(s.y-7.));\n                if(vesd2<.1) {\n                    // vessel color\n                    diff=vec3(1);\n                    if(vesp2.z<35. && abs(vesp2.x)<8.6 ) {\n                        if(rnd11(floor(vesp2.y+17.01))<.5) {\n                            // blue bands\n                            diff=vec3(0.4,.6,1);\n                        }\n                    }\n                    // darken also the reflection\n                    alpha*= diff;\n                }\n                if(humd2<.01) {\n                    // character color\n                    diff=vec3(1);\n                    alpha*=pow(fre,.5);\n                }\n\n                // apply direct lighting\n                val += shad * max(0.,dot(n,l)) * diff;\n\n                val=max(val,0.);\n                \n                // blend fog color\n                float blend=pow(c01((dd-100.)/900.),.6);\n                val = mix(val, sky(r,dd,j), blend);\n\n                col += val*alpha;\n\n                float rough = .5;\n                if(vesd2<.1) {\n                    // vessel roughness\n                    rough=vesp2.z>32.?0.:rnd31(floor(vesp2*vec3(3,.1,.1)-.72)*.3+.7);\n                }\n\n                // bounce in a random direction around reflection vector, depending on roughness\n                r=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(0,j*375)+time*1.3)-.5)*rough);\n\n                alpha *= 0.7*(1.-blend);\n                s+=n*0.005;\n            }\n            \n            // tricks by iq to disable unrolling and have faster compilation times\n            if( col.x<-100.0 ) break;\n        }\n\n        finalcolor += vec4(col, 1);\n    }\n    \n    // store last rendered resolution\n    if(ivec2(fragCoord)==ivec2(0)) {\n        finalcolor=iResolution.xyxy;\n    }\n    \n    fragColor = finalcolor;\n}\n","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"ssBGRG","date":"1617556526","viewed":13771,"name":"Red Crash - Procedural GFX","username":"NuSan","description":"Procural image made for Revision 2021 4k Excutable Graphics competition","likes":203,"published":1,"flags":32,"usePreview":1,"tags":["4k","pathtrace","proceduralgraphics"],"hasliked":0,"parentid":"","parentname":""}}