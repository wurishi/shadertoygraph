{"ver":"0.1","info":{"id":"MXXSzf","date":"1714769821","viewed":91,"name":"Kerr Black Hole by Endertrekkie","username":"endertrekkie","description":"3d rotating black hole sim\nuses Ray Marching: Part 1 as a base.","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"llt3R4","parentname":"Ray Marching: Part 1"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//input\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n//raymarching\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n//gravity\nfloat mass = 0.001;\nfloat speedOfLight = 10000.0;\nvec3 rotationDir = vec3(0,0.0001,0.001);\n//camera\nfloat fov = 120.0;\nfloat panAmount = 0.03;\n\nvec3 camPos = vec3(0,0,-10);\n\nfloat pointSDF(vec3 samplePoint) {\n    return length(samplePoint);\n}\n\n//gravity function\nfloat sampleGrav(vec3 samplePoint){\n    return -mass/pow(pointSDF(samplePoint),2.0);\n}\n//acceleration\nvec3 gravAccel(vec3 pos){\n    float grav = sampleGrav(pos);\n    vec3 grav_accel = grav * normalize(pos);\n    vec3 rot_accel = cross(rotationDir*mass,normalize(pos))/pow(length(pos),3.0);\n    return grav_accel+rot_accel;\n}\n//light curving function\nvec3 gravCurve(vec3 pos, vec3 dir, float dx){\n    vec3 accel = gravAccel(pos);\n    return normalize(dir + accel * dx);\n}\n\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return pointSDF(samplePoint)/10.;\n}\n\nvec4 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    vec3 pos = eye;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        pos += depth * marchingDirection;\n        float dist = sceneSDF(pos);\n        if (length(gravAccel(pos)) > speedOfLight) {\n\t\t\treturn vec4(marchingDirection,depth);\n        }\n        depth = dist;\n        marchingDirection = gravCurve(pos, marchingDirection, dist);\n        \n        if(length(pos) >= end) {\n            return vec4(marchingDirection,end);\n        }\n    }\n    return vec4(marchingDirection,end);\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camPos += vec3(\n    texture( iChannel1, vec2(KEY_LEFT,0.9)).r - \n    texture( iChannel1, vec2(KEY_RIGHT,0.9)).r,\n    texture( iChannel1, vec2(KEY_UP,0.9)).r - \n    texture( iChannel1, vec2(KEY_DOWN,0.9)).r,0);\n    \n\tvec3 dir = rayDirection(fov, iResolution.xy, fragCoord);\n    vec3 eye = vec3(panAmount*(iMouse.xy/iResolution.xy-vec2(0.5,0.5)), 1.0/fov);\n    vec4 hit = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    float dist = hit.w;\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = texture(iChannel0,hit.xyz);\n\t\treturn;\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}