{"ver":"0.1","info":{"id":"XtlSDM","date":"1437120289","viewed":477,"name":"Marched Ocean Floor","username":"StanRee","description":"Another test with my mountain marcher\n\nThanks IQ for the great tutorial   \nhttps://iquilezles.org/articles/terrainmarching/terrainmarching.htm\n\nalso dave_hoskins, I learned alot from\nhttps://www.shadertoy.com/user/Dave_Hoskins","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["example","simple","raytracer","ray","tutorial","raymarcher","iq","mountains","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixPos )\n{\n    vec4 temp;// because we always need a back up vec4           \n    vec2 uvLoc = vec2(pixPos) / iResolution.xy - 0.5;    \n    vec4 position = vec4(uvLoc.xy, 1.0, 1.0);     \n    vec4 direction = position * 0.5;\n        \n    //scene settings\n    const float camHeight = 5.0;\n    const float mtnScale = 0.019;    \n    const float uvHeightMapScale = .006; \n    const float uvColorSampleScale = .004; \n    const float movementSpeed = 10.0; \n        \n    //Camera, if we normalize the dir we will be linear w/ distance (ewwww)         \n    direction.y -= .2; //Lookdown \n    direction = normalize(direction);\n    direction = rotationMatrix(vec3(0.0, 1.0, 0.0), iTime * .1) * direction; \n    //direction *= .4;   // ++ = larger    \n    position.x += iTime * movementSpeed; //Posupdate\n    position.y += sin(iTime *.3)*10.0;\n    \n    \n    //tracer settings\n    const float max = 1.0;\n    const float min = 0.0; \n    const float delta = .002; \n    const float distanceMulti = 2.; \n    \n    float finalT = 0.0; \n    for (float tVal = max; tVal >= min; tVal -= delta)\n    {        \n        //zeroed out temp val \n        temp = vec4(0.0, 0.0, 0.0, 0.0);        \n        //Scaling uvs to scale up floor texture\n        vec2 mapUv = position.xz * uvHeightMapScale;        \n        //Offset centering texture sample to avoid seems, seems are hit at a rate of .5f\n        mapUv.x += .25;\n        \n        //check height mP\n        temp += texture(iChannel0, mapUv, 0.0);\n                      \n        //Height of mtn\n        float sampledHeight = temp.y;\n        //scaling the height of the mtn to fit within our view        \n        float currentHeight = position.y * mtnScale;\n        //raise the camera\n        currentHeight += camHeight; \n        \n        //if under mtn then break\n        if (sampledHeight > currentHeight)\n            break;                                \n        \n        //We are getting the brightness of the pixel in the height map (xyz included) \n        float brightness = (temp.r + temp.g + temp.b) / 3.0;\n\n        vec2 textureUv = position.xz * uvColorSampleScale;\n\n        //We are scaling our texture to get darker lower, lakes should go here :D\n        temp = texture(iChannel1, textureUv, 0.0) * brightness;\n        \n        //fade color with interpolation        \n        color = temp * 5. * tVal;// * tVal;       \n        \n        finalT = tVal ;\n        \n        //now MARCH!\n        position += direction * max * distanceMulti;\n    }\n    \n    color = abs(color); \n    color *= vec4(0.3, 0.5, 1.0, 1.0) ;\n    color += vec4(.0,.2,.3,0.);\n}\n","name":"","description":"","type":"image"}]}