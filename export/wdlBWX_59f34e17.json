{"ver":"0.1","info":{"id":"wdlBWX","date":"1589552867","viewed":142,"name":"Ford Circles 101","username":"spalmer","description":"I keep seeing Appollonian sphere packing and it always blows my mind, but I never understood quite how it works.  I've seen Ford Circle diagrams but never wrote code to produce them.  So I gave it a try, hopefully do Appollonian spheres next!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sphere","learning","packing","appollonian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://wikipedia.org/wiki/Ford_circle\n\n// I also tried to turn it 3D at https://shadertoy.com/view/tdsBWf\n\n// btw:  not related code-wise, but I did find another example by tpfto\n// of ford circles in a toy here: https://shadertoy.com/view/WlXGDX\n// check it out too!\n\n// mla's from comments is great: https://shadertoy.com/view/WdBBzD\n\n// btw there's a brilliant Ford circles implementation in\n// this toy by Gijs https://shadertoy.com/view/3sSyDG\n// called Basic Apollonan Gasket if you disregard all\n// of the inversion stuff.  Hard to find by searching Ford though.\n// I'm glad I didn't see that first, otherwise\n// I'd have probably been so confused I may \n// never have figured this much out.\n// Gijs probably right though, there's probably more\n// clever ways to evaluate this than a loop.\n\n// another one here by https://shadertoy.com/user/Gijs\n// at https://www.shadertoy.com/view/tlSyz3\n// seems intended to illustrate the basic algorithm\n// and I have an easier time understanding :)\n// great Farey algorithm implementation.\n\n// the baseline constraint and the constraint\n// on the prior circle(s) conspire to\n// constrain the location of the y coordinate\n// which by constraint with the baseline is\n// also equal to the radius\n\n// Ford circle for given rational number p/q\n// outputs center and radius\nvoid C(int p, int q, out vec2 c, out float r)\n{\n    if (q <  1) {\n        c = vec2(0); r = 0.; return;\n    }\n    c.x = float(p) / float(q);\n    r = .5 / float(q*q); \n    c.y = r;\n}\n    // radius is in fact a simple sequence to compute:\n    // AHA finally! maybe it's not *that* simple but still easy.\n\n    // must actually skip cases that reduce to simpler fractions!!!\n    // first the special cases to start sequence off:\n    // cannot do it recursively in GLSL anyway!\n\n// TODO user mla suggested https://wikipedia.org/wiki/Euclidean_algorithm\n// ok, how's this?  ;)  now if I can just recall where I got this\n// when I wrote the C# 3+ years ago... probably from Wikipedia!\n//\tassert(a > 0 && b > 0)\nint GCD(int a, int b)\n{ // iterative, not recursive\n\tint c = a;\n\twhile (a != b) { // use modulo division\n\t\tif (a > b) c = (a %= b); // to speed things\n\t\tif (b > a) c = (b %= a); // up for large numbers\t\n\t}\n\treturn c;\n}\n\nconst float tau = 2. * acos(-1.)\n    , phi = .5*(sqrt(5.) + 1.);\n\nvec3 hue(float h)\n{\n    return max(cos(vec3(0,2,4) + h * tau), 0.);\n}\n\nvoid Draw1(vec2 q, ivec2 n, inout float d, inout vec3 h)\n{\n    vec2 c; float r;\n    C(n.x,n.y, c,r);\n    float e = abs(length(q - c) - r);\n    if (e < d) {\n    \td = min(d, e);\n    \th = hue(phi / r);\t// hue based on which size\n    }\n}\n\nvec3 Draw(vec2 q)\n{\n    q = (q - .5) * 1.01 + .5; // inset\n    vec2 r = iResolution.xy;\n    q /= 1.+(sin(iTime*.2)*.5+.5);\n    float d = 3.4e38; vec3 h = vec3(1);\n    // FIXME do I need a table of primes? lol\n    // No, dummy, just GCD like mla said.\n    // we must iterate only the irreducible fractions!\n    // DAMMIT!  not the kind of problem I had hoped to\n    // enjoy working on, this morning, and now\n    // I'm all out of coffee!  :(\n    // not enough left to build sieve of eratothenes or whatever lol\n    // Yeah you really were out of coffee weren't you!  ;)\n    // HACK I have it kludged atm to make a nice little sequence anyhow\n    for (int j = 0; j <= 128; ++j)\n        for (int i = 1; i == 1; ++i)\n           Draw1(q, ivec2(i,j), d, h);\n\tfloat pixel = .5/r.y;\n    d -= .5 * pixel;\n\tfloat cov = clamp(.5 - .5*d*r.y, 0., 1.);\n    float g = cov;\n    vec3 c = 2. * vec3(g) * h; // super bright!  more will saturate weird\n    return c;\n}\n// anyway iterating brute force is lame, and\n// hopefully I can get something more clever in soon.\n\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    vec3 c = Draw(p/r.y - vec2(.25*r.x/r.y,0));\n    c = pow(c, vec3(1./2.2));\n    o = vec4(c, 1);\n}\n\n// code graveyard:\n\n    //if (any(lessThan(q, vec2(0)))\n    // || any(greaterThanEqual(q, vec2(1))))\n    //    return vec3(.0);\n\n        //for (int i = 0; i < j; ++i) //\n    //if (n.x == n.y) return;\n    //if (n.x == 0 && n.y > 1) return;\n    //if (j >= 3 && j % i == 0) continue; // HACK skips some of the more obvious duplicates but not all of them\n// || (q > 1 && p < 1)) {\n\n","name":"Image","description":"","type":"image"}]}