{"ver":"0.1","info":{"id":"cllfR4","date":"1692680293","viewed":46,"name":"Desert And Cloud","username":"luhongdi","description":"For the time being, it will be slowly improved，The clouds are too ugly...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","cloud","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Tmin 0.0\n#define Tmax 500.0\n#define Raymarch_Time 300\n#define PRESSICON 0.001\n#define AA 1\n#define PI 3.141592653579\n#define NUM_OCTAVES 5\n\nvec2 fixuv(in vec2 st,float multi){\n    return multi*(2.0*st-iResolution.xy)/min(iResolution.x,iResolution.y);\n}\n\n//噪声\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\nfloat noise(vec2 st) {//return -0.6~0.6\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {//return -1.0~1.0\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 1.0;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n        /* 1. find current tetrahedron T and it's four vertices */\n        /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n        /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n        \n        /* calculate s and x */\n        vec3 s = floor(p + dot(p, vec3(F3, F3, F3)));\n        vec3 x = p - s + dot(s, vec3(G3, G3, G3));\n        \n        /* calculate i1 and i2 */\n        vec3 e = step(vec3(0,0,0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        \n        /* x1, x2, x3 */\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        \n        /* 2. find four surflets and store them in d */\n        vec4 w, d;\n        \n        /* calculate surflet weights */\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        \n        /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n        w = max(0.6 - w, 0.0);\n        \n        /* calculate surflet components */\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        \n        /* multiply d by w^4 */\n        w *= w;\n        w *= w;\n        d *= w;\n        \n        /* 3. return the sum of the four surflets */\n        return dot(d, vec4(52.0, 52.0, 52.0, 52.0));\n}\n\n\nfloat noise_sum_abs(vec2 p,float f)//fbm绝对值的版本5次循环0-1.0\n{\n    p = p * 2.0;\n    f += 1.0000 * abs(snoise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(snoise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(snoise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(snoise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(snoise(p)); p = 2.0 * p;\n\n    return f;\n}\n\n//噪声终止\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat hillheight(vec3 location){\n    float noisehill=simplex3d(location);\n    float distancede=0.0;\n    float zz=location.z;\n    float xx=location.x;\n    float yy=location.y;\n    vec2 st=location.xz;\n    float a=1.0;\n\n    mat3 rot = mat3(1.0,0.0,0.0,\n                0.0,cos(0.5), sin(0.5),\n                0.0,-sin(0.5), cos(0.50));\n    mat2 rot2d = mat2(\n                cos(0.1), sin(0.1),\n                -sin(0.1), cos(0.10));\n    float desertground=0.0;\n    float desertwave=0.0;\n    for(int i=0;i<1;i++){\n        st=rot2d*st*0.7+vec2(1.75,1.36);\n        desertwave+=0.5*a*(3.0+5.0*noise(st))*abs(mod(0.01*st.x,1.0)-0.5);\n        a*=0.5;\n\n    }\n    float desertall=desertwave+step(0.55,noise(st));\n    float desertheight=yy-desertall;\n    return 0.9*desertheight;\n    \n}\n\nfloat plotcloud1(vec3 location){\n    vec2 st= vec2(location.x,location.z);\n    float fluence=2.0*noise(0.03*(st-0.0*iTime));\n    float dis;\n    float a=1.0;\n    mat2 rot2d = mat2(\n                cos(0.1), sin(0.1),\n                -sin(0.1), cos(0.10));\n    if(location.y>89.9+0.1*noise(st)){\n        dis= Tmax;\n    }\n    \n    else{\n        for(int i=0;i<4;i++){\n            st=rot2d*(st)*0.7+vec2(10.75,201.36)+2.0*noise(st);\n            float fluence=(1.0+1.0*noise(vec2(0.1*iTime,st.x)))*noise(0.1*(st-0.4*iTime));\n            dis+=a*(90.0-fluence-location.y);\n            a*=0.5;\n        }\n\n    }\n\n    return 1.0*dis;\n}\nfloat plotcloud2(vec3 location){\n        vec2 st= vec2(location.x,location.z);\n    float fluence=2.0*noise(0.03*(st-0.1*iTime));\n    float dis;\n    float a=1.0;\n    mat2 rot2d = mat2(\n                cos(0.1), sin(0.1),\n                -sin(0.1), cos(0.10));\n    if(location.y>120.9+0.1*noise(st)){\n        dis= Tmax;\n    }\n    \n    else{\n        for(int i=0;i<1;i++){\n            st=rot2d*(st)*0.7+vec2(10.75,201.36)+2.0*noise(st);\n            float fluence=(1.0+1.0*noise(vec2(0.1*iTime,st.x)))*noise(0.1*(st-0.1*iTime));\n            dis+=a*(121.0-fluence-location.y);\n            a*=0.5;\n        }\n\n    }\n\n    return 1.0*dis;\n}\nfloat plotcloud3(vec3 location){\n    vec2 st= vec2(location.x,location.z);\n    float fluence=2.0*noise(0.03*(st-0.1*iTime));\n    float dis;\n    float a=1.0;\n    mat2 rot2d = mat2(\n                cos(0.1), sin(0.1),\n                -sin(0.1), cos(0.10));\n    if(location.y>50.9+0.1*noise(st)){\n        dis= Tmax;\n    }\n    \n    else{\n        for(int i=0;i<1;i++){\n            st=rot2d*(st)*0.7+vec2(10.75,201.36)+2.0*noise(st);\n            float fluence=(1.0+1.0*noise(vec2(0.1*iTime,st.x)))*noise(0.1*(st-0.6*iTime));\n            dis+=a*(51.0-fluence-location.y);\n            a*=0.5;\n        }\n\n    }\n\n    return 1.0*dis;\n}\nfloat plotcloud(vec3 location){\n    float a=smin(plotcloud1(location),plotcloud2(location),0.1);\n    a=min(a,plotcloud3(location));\n    return a;\n}\nfloat map(in vec3 p){\n    vec3 locatio=vec3(p.x,p.y-4.0,p.z);\n    float texture=hillheight(p);\n    return texture;\n}\n\nfloat raymarch(in vec3 ro,in vec3 rd){\n    float t=Tmin;\n    for(int i=0;i<Raymarch_Time&&t<Tmax;i++){\n        vec3 p=ro+t*rd;\n        float d=map(p);\n        if(d<PRESSICON*t){\n            break;\n        }\n        t+=d;\n    }\n    return t;\n}\n\nfloat raymarchcloud(in vec3 ro,in vec3 rd){\n    float t=Tmin;\n    for(int i=0;i<Raymarch_Time&&t<Tmax;i++){\n        vec3 p=ro+t*rd;\n        float d=plotcloud(p);\n        if(d<PRESSICON){\n            break;\n        }\n        t+=d;\n    }\n    return t;\n}\n\n\nvec3 calcNormal( in vec3  p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h) + \n                      k.yyx*map( p + k.yyx*h) + \n                      k.yxy*map( p + k.yxy*h) + \n                      k.xxx*map( p + k.xxx*h) );\n}\n\nmat3 camera(vec3 tar,vec3 cam,float tr){\n    vec3 z=normalize(tar-cam);\n    vec3 cp=vec3(sin(tr),cos(tr),0.0);\n    vec3 x=normalize(cross(cp,z));\n    vec3 y=cross(z,x);\n    mat3 came=mat3(x,y,z);\n    return came;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{float res = 1.0;\n    float ph = 1e20;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 render(vec2 uv){\n    vec3 color=vec3(0.0);\n    float an=iTime*0.0009;\n    float r=400.0;\n    float h =-hillheight(vec3(r*sin(an),0.0,r*cos(an)));\n    vec3 pos=vec3(r*sin(an),h,r*cos(an));\n    vec3 ro =vec3(r*sin(an),h+0.5,r*cos(an));\n    mat3 came=camera(vec3(r*sin(an+0.01),h+0.5,r*cos(an+0.01)),ro,0.0);\n    vec3 rd=normalize(came*(vec3(uv,2.5)));\n    float t=raymarch(ro,rd);\n    \n    if(t<Tmax){\n        vec3 po=ro+t*rd;\n        vec3 n=calcNormal(po);\n        vec3 light=vec3(2.0,4.0,0.0);\n        float phemisp=clamp(1.0*dot(normalize(light-po),n),0.0,1.0);\n        float shadow=softshadow(po,normalize(light-po),Tmin,Tmax,0.06);\n        //phemisp *= shadow;\n\n        float amd=0.3+0.5*dot(n,vec3(0.0,1.0,0.0));\n        //vec3(1.0,0.5,0.1)\n\n        color=amd*vec3(0.4)+phemisp*vec3(1.0,0.471,0.12);\n    }\n    else{\n        float tcloud=raymarchcloud(ro,rd);\n        vec3 skytop=vec3(0.236,0.467,0.975);\n        vec3 skybottom=vec3(0.5,0.5,0.6);\n        color=1.0*mix(skybottom,skytop,0.7+rd.y*rd.y);\n        if(tcloud<Tmax){\n            vec3 pocloud=ro+tcloud*rd;\n            vec3 ncloud=calcNormal(pocloud);\n            vec3 lightcloud=vec3(r*sin(an),h+0.5,r*cos(an));\n            float phemispcloud=clamp(1.0*dot(normalize(pocloud-lightcloud),ncloud),0.0,1.0);\n            vec2 q = vec2(0.);\n            vec2 st=vec2(uv);\n            float u_time=iTime;\n            q.x = fbm( st + 0.00*u_time);\n            q.y = fbm( st + vec2(1.0));\n\n            vec2 r = vec2(0.);\n            r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.0*u_time );\n            r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.0*u_time);\n\n            float f = fbm(st+r);\n\n            color = mix(vec3(0.794,0.775,0.865),\n                vec3(0.670,0.685,0.750),\n                        clamp((f*f)*4.0,0.0,1.0));\n\n            color = 42.0*rd.y*rd.y*mix(color,\n                        vec3(0.827,0.815,0.840),\n                        clamp(length(q),0.0,1.0));\n            //color=vec3(1.0);\n\n        }\n\n\n    }\n    return color;\n\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n     vec3 color=vec3(0.0);\n    for(int m=0;m<AA;m++){\n        for(int n=0;n<AA;n++){\n            vec2 offset=2.0*(vec2(float(m),float(n))/float(AA)-0.5);\n            vec2 uv_ori_cube=fixuv(fragCoord+offset,5.0);\n            color+=render(uv_ori_cube);\n        }\n    }\n    // vec2 uv_ori_cube=fixuv(fragCoord,5.0);\n    // color+=render(uv_ori_cube);\n     fragColor = vec4(color/float(AA*AA),1.0);\n    //fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}