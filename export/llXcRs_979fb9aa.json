{"ver":"0.1","info":{"id":"llXcRs","date":"1505969228","viewed":162,"name":"Mandelbrot (w/ zoom) + Julia","username":"jgkling","description":"Extremely quick Mandelbrot vis with options for Julia sets too. Zoom is set up for the mandelbrot set only. If you enable zoom, make sure to reset time to 0.\n\nClick and drag the mouse around with the Julia sets!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define JULIA // uncomment to see Julia sets instead of Mandelbrot\n//#define USE_PALLETTE\n#define HARD_EDGE\n\n#ifndef JULIA\n    #define MANDELBROT\n    //#define ZOOM // Optional zoom, only for Mandelbrot\n#endif\n\nvec4 cosinePallette(float i)\n{\n    float r = 0.5 + 0.5 * cos(6.28318 * (1.0 * i + 0.2));\n    float g = 0.5 + 0.5 * cos(6.28318 * (1.0 * i + 0.05));\n    float b = 0.5 + 0.5 * cos(6.28318 * (1.0 * i + 0.2));\n    return vec4(r, g, b, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenP = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    #ifdef ZOOM\n        screenP /= iTime * iTime * iTime * 5.0;\n        screenP += vec2(-0.7498, 0.02495);\n    #else\n        #ifdef MANDELBROT\n            screenP += vec2(-0.5, 0.0); // Center the mandelbrot set for viewing\n        #endif\n    #endif\n    \n    vec2 z = screenP;\n    vec2 dz = vec2(0.0, 0.0);\n    #ifdef JULIA\n    \tdz.x += 1.0;\n    #endif\n        \n    vec2 julia;\n    #ifdef JULIA\n        julia = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    #endif\n    \n    int MAX_ITERS_I = 1000;\n    #ifndef ZOOM\n        #ifndef JULIA\n            MAX_ITERS_I = 256;\n        #endif\n    #endif\n    \n    float MAX_ITERS = float(MAX_ITERS_I);\n    \n    float j = 0.0;\n    bool diverged = false;\n    int i;\n    for (i = 0; i < MAX_ITERS_I; ++i)\n    {        \n        // Compute the derivative for distance estimation\n        // https://iquilezles.org/articles/distancefractals\n        dz = 2.0 * vec2(z.x * dz.x - z.y * dz.y, z.x * dz.y + z.y * dz.x);\n        \n        // Square the complex number\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n        \n        // + c\n        #ifdef MANDELBROT\n            z += screenP;\n        #endif\n        \n        #ifdef JULIA\n            z += julia;\n        #endif\n        \n        float magn = dot(z, z);\n        diverged = magn > 100000.0;\n        \n        if (diverged)\n        {\n            float magnDeriv = dot(dz, dz);\n            float distToSet = sqrt(magn / magnDeriv) * log(magn);\n            \n            float edge = 4.0;\n            \n            #ifdef HARD_EDGE\n                edge = 15.0;\n            #endif\n            \n            #ifdef JULIA\n                j = sqrt(distToSet) * edge; // This sqrt makes it look good. Also see this (by IQ!): https://www.shadertoy.com/view/Mss3R8\n            #else\n                j = 1.0 - float(i) / MAX_ITERS;\n            #endif\n            \n            // smooth iteration count for mandelbrot set shading? https://linas.org/art-gallery/escape/smooth.html\n            //j = float(i) + 1.f - log(log(sqrt(magn))) / log(2.f);\n            \n            break;\n        }\n    }\n    \n    #ifdef MANDELBROT\n        if (i == MAX_ITERS_I && !diverged) // this looks weird, pick a new pallette and don't do this\n        {\n            fragColor = vec4(0.0);\n            return;\n        }\n    #endif\n    \n    #ifdef USE_PALLETTE\n        j = clamp(j, 0.0, 1.0);\n        fragColor = cosinePallette(j);\n    #else\n        fragColor = vec4(vec3(j), 1.0);\n    #endif\n}","name":"Image","description":"","type":"image"}]}