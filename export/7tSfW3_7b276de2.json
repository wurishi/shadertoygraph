{"ver":"0.1","info":{"id":"7tSfW3","date":"1652813885","viewed":82,"name":"SimpleAbstractClock","username":"JohnnyRainbow81","description":"Just a simple clock","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["clock","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float TAU = 6.283185307179586;\nconst float TAU60 = 0.10471975511966;\nconst float SECONDHAND_VALUE = 9.5492965855137; //explained below\n/* \nBecause the amount of circular movement of the secondhand is TAU/60 (radians)\nwe need to transform the value of our seconds' movement driver (namely floor(iTime) ) to TAU/60:\n\nWe have\nTAU = 6.28; // This is just 2*PI\n\nTAU/60 = 0.10466; //This is the correct value to rotate the secondhand for 1/60 circle\n\n1.0 // full second we get from floor(iTime), not very handy as a fraction of a rotation \nwhere 6.28 in radians makes a full circle. (Btw it doesn't matter the value of floor(iTime) grows \nbecause it gets naturally clamped by using sin/cos)\n\nSo calculate:\n\n1.0/x = 0.10466 <=> \n\nx = 9.554 //We need to divide this value with 1.0 (our full second) \nto get the correct TAU/60 value for secondhand rotation:\n\n1.0/9.554 //gives us correct rotation amount (1/60 of circle or TAU/60 or 0.10466)\n*/\n\nmat2 rotate(float rad) {\n    return mat2(sin(rad), cos(rad), -cos(rad), sin(rad));\n}\n\nfloat circle(vec2 uv, vec2 pos, float radius, float softness) {\n    return 1.-smoothstep(radius, radius+softness, length(uv-pos));\n    \n}\n\nfloat rect(vec2 uv, vec2 pos, float width, float height, float softness) {\n    float left = smoothstep(-width/2., -width/2.+softness, uv.x - pos.x);\n    float right = 1.-smoothstep(width/2., width/2.+softness, uv.x - pos.x);\n    float bottom = smoothstep(-height/2., -height/2.+softness, uv.y - pos.y);\n    float top = 1.-smoothstep(height/2., height/2.+softness, uv.y - pos.y);\n    return left * right * top * bottom;\n\n}\n\nfloat circleOutline(vec2 uv, vec2 pos, float radiusInner, float radiusOuter, float softness) {\n    float inner = circle(uv, pos, radiusInner, softness);\n    float outer = circle(uv, pos, radiusOuter, softness);\n    return outer - inner;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 rotUV = uv * rotate(floor(iTime)/SECONDHAND_VALUE); //see calculation & comments above \n    vec2 rotUVbefore = uv * rotate(floor(iTime-.05)/SECONDHAND_VALUE-0.01);\n    vec2 rotUVafter = uv * rotate(floor(iTime+.11)/SECONDHAND_VALUE+0.02);\n    \n    //3 secondhands, 2 of them just add a bit fancyness\n   float secondHand = rect(rotUV,vec2(.2,.0), .4,.01, .006);\n   float secondHandBefore = rect(rotUVbefore, vec2(.2,.0), .4,.01,.006);\n   float secondHandAfter = rect(rotUVafter, vec2(.2,.0), .4,.01,.006);\n   \n   //draw 60 secondhand markers\n   float secondHandMarkers = 0.;\n   for(float i = 0.; i < TAU - TAU/60.; i+=TAU/60.) {\n       vec2 angleStepUV = uv * rotate(i);\n       float secondHandMarker = rect(angleStepUV, vec2(0.222,0.), .36,.010, .006);\n       secondHandMarkers += secondHandMarker;\n   }\n   \n    //colors\n    vec3 secondHandBeforeCol = vec3(1,0.3,0.2);\n    vec3 secondHandAfterCol = vec3(0,0.6,1);\n    vec3 background = vec3(0.26,0.05,length(uv*.3));\n    \n    //mask\n    float mask = length(uv);\n    \n    //result\n    vec3 col = vec3(/*clock*/ + secondHand + secondHandBefore*secondHandBeforeCol + secondHandAfter*secondHandAfterCol + secondHandMarkers)*mask;\n    fragColor = vec4(background+col,1.0);\n} \n\n","name":"Image","description":"","type":"image"}]}