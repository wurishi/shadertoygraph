{"ver":"0.1","info":{"id":"NttXW8","date":"1639034834","viewed":96,"name":"MathLab-ComplexFunction","username":"yunhai","description":"my complex function visualization template","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["lab"],"hasliked":0,"parentid":"NljGRV","parentname":"MathLab"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* --------4D mapping visulization tool help--------\n<MSI> means the length of black grid\n<CANVAS_WIDTH> means the gridNums*gridSize for X-axis\nyou can drag this canvas (and set mode or speed by <dragVec>)\nthey can be adjust in \"Common\" Tab\n\nthe <function map> below is to trans a Complex to another Complex\nby now the output can only be drawn by <function domainColouring>\nit's a good method for finding zeros\n\nand later may support other scheme such as draw vectors\n---------------------------------------------------*/\n\n#define movp ctov(cexp(Complex(0.,iT)))\n//-------------------experiment-----------------\nComplex map(Complex c)\n{\n    Complex o;\n    //t1\n    //c=vtoc(cpol(c));\n    \n    //t2\n    //c=clog(c);\n    \n    //t3\n    Complex z=cpow(c,5);//cneg(cpow(c,4));\n    Complex ez= cmul(cmul(c,c),c);\n    //ez=cmul(ez,ez);\n    o=csub(z,vtoc(movp));\n    \n    //t4\n    //o=ccos(c);\n    //o=csin(c);\n    \n    //default:\n    //o=c\n    return o;\n}\n//---------------------drawElements-------------------\nfloat spot(vec2 p,vec2 o){return SL(length(p-o));}\nfloat lineSeg(vec2 p,vec2 s,vec2 e){vec2 sp=p-s,se=e-s;\n      return SL(length(p-clamp(dot(sp,se)/dot(se,se),0.,1.)*se+s));}\nfloat lineRay(vec2 p,vec2 o,vec2 d){return SL(length(p-max(dot(p-o,d),0.)*d+o));}\nfloat line(vec2 p,vec2 o,vec2 d){return SL(length(p-(dot(p-o,d)*d+o)));}\n\n/*------------visulizing scheme------------*/\nvec3 domainColouring(Complex c)\n{\n    //re--->hue\n    //im--->saturate, bigger ---> whiter\n    vec2 pol=cpol(c).yx;pol.x=pol.x/PI*.5+.5;\n    float spd=1e-2;\n    return hsv(vec3(pol.x,exp(-pol.y*spd),1.));\n}\n//----------------------------------------------\nvec4 cartesian(vec2 uv)\n{\n    vec3 col=vec3(1.);\n    float a=0.;\n    float msp=MSI,lhlw=HLW/2.;\n    a=SS(lhlw+2.*PIXW,lhlw-PIXW,abs(uv.x-round(uv.x/msp)*msp))+\n      SS(lhlw+2.*PIXW,lhlw-PIXW,abs(uv.y-round(uv.y/msp)*msp));\n    col-=vec3(a);\n    vec3 cxy=vec3(1.4,2.,.2)*.4;\n    col=mix(col,cxy,line(uv,vec2(0.),vec2(1.,0.)));\n    col=mix(col,cxy,line(uv,vec2(0.),vec2(0.,1.)));\n    return vec4(col,a);\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    \n    vec2 uv=((C-.5*iR)-dragVec*(iM.xy-.5*iR))*PIXW;\n    float x=uv.x,y=uv.y,t=iTime*.5;\n    \n/*----complex function define----*/\n    Complex c=Complex(uv.x,uv.y);\n    c=map(c);\n    \n/*----complex function map format----*/\n    O.rgb=domainColouring(c);\n    O.rgb+=spot(uv,movp);\n/*-----------------------------------*/\n\n    vec4 cart=cartesian(uv);\n    O.rgb=mix(O.rgb,cart.xyz,cart.w);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iR iResolution.xy\n#define iM iMouse\n#define iT iTime\n#define PIXW (CANVAS_WIDTH/iR.x)\n#define SS(a,b,t) smoothstep(a,b,t)\n#define LW (5.*PIXW)\n#define HLW (LW*.5)\n#define SL(d) smoothstep(HLW+PIXW,HLW-PIXW,d)\nconst float PI=3.14159265;\n/*-----------DrawingSettings-----------*/\nconst float CANVAS_WIDTH=10.;\nconst float MSI=1.;//mesh space interval\n/*-----------input-----------*/\n//magnitude for speed and sign for dir, zero means lock\nconst float dragVec=0.;\n\n/*-----------utilities-----------*/\n//smoother hsv to rgb is from iq:\n//https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n//Complex utilities\nstruct Complex\n{\n    float re,im;\n};\nvec2 ctov(in Complex c)\n{\n    return vec2(c.re,c.im);\n}\nComplex vtoc(in vec2 v)\n{\n    return Complex(v.x,v.y);\n}\nComplex cmul(in Complex c,in Complex z)\n{\n    return Complex(c.re*z.re-c.im*z.im,c.re*z.im+c.im*z.re);\n}\nComplex cmul(in Complex c,float a)\n{\n    return Complex(c.re*a,c.im*a);\n}\nComplex cmul(float a,in Complex c){return cmul(c,a);}\nfloat cmag(in Complex c)\n{\n    return length(ctov(c));\n}\nComplex cdiv(in Complex c,float a)\n{\n    return cmul(c,1./a);\n}\nComplex ccon(in Complex c)\n{\n    return Complex(c.re,-c.im);\n}\nComplex cdiv(in Complex c,in Complex z)\n{\n    return cdiv(cmul(c,ccon(z)),cmag(z));\n}\nComplex cdiv(float a,in Complex z)\n{\n    return cdiv(Complex(a,0.),z);\n}\nvec2 cpol(in Complex c)//length than angle\n{\n    return vec2(cmag(c),atan(-c.im,-c.re));\n}\nComplex cadd(in Complex c,in Complex z)\n{\n    return Complex(c.re+z.re,c.im+z.im);\n}\nComplex cadd(in Complex c,float x)\n{\n    return Complex(c.re+x,c.im);\n}\nComplex cneg(in Complex c)\n{\n    return Complex(-c.re,-c.im);\n}\nComplex csub(in Complex c,in Complex z)\n{\n    return cadd(c,cneg(z));\n}\nComplex csub(in Complex c,float x)\n{\n    return cadd(c,-x);\n}\n\nComplex cexp(in Complex idx)\n{\n    return cmul(exp(idx.re),Complex(cos(idx.im),sin(idx.im)));\n}\nComplex clog(in Complex c)//take principalvalue\n{\n    vec2 pol=cpol(c);\n    return Complex(log(pol.x),pol.y);\n}\nComplex cpow(in Complex c,int idx)\n{\n    float i=float(idx);\n    Complex res=cexp(cmul(clog(c),i));//this is the result I deduced\n    return cmul(res,pow(-1.,i));//Tests tell me I should do this, but why?\n}\nComplex ccos(in Complex c)\n{\n    Complex e=cexp(Complex(c.im,-c.re));\n    return cmul(cadd(e,cdiv(1.,e)),.5);\n}\nComplex csin(in Complex c)\n{\n    Complex e=cexp(Complex(c.im,-c.re));\n    return cdiv(csub(e,cdiv(1.,e)),Complex(0.,2.));\n}\n","name":"Common","description":"","type":"common"}]}