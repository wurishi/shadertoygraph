{"ver":"0.1","info":{"id":"MXXSD4","date":"1709511006","viewed":119,"name":"Wavetable Tunnel","username":"BurgerTown","description":"Designed after the album art for Wavetable\nhttps://patriciataxxon.bandcamp.com/album/wavetable","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float EPSILON = .0001;\n//Based off of WaveTable by Patrica Taxxon\n//Comment out the Min of -clipping for a neat effect\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nvec2 scene(vec3 p){\n    float res = 1.;\n    \n    p.xy += vec2(cos(p.z),sin(p.z));\n    \n    //Rings\n    for(int i = 0; i<12;i++){\n        vec3 q = p;\n        q.xy *= rotate2d(3.14159265359*float(i)/6.);\n        q.z = mod(q.z,.3);\n        res = min(res, sdCylinder(q-vec3(0.4,0.,.0),vec3(0.,0.,.01)));\n    }\n    //Stripes\n    for(int i = 0; i<12;i++){\n        vec3 q = p;\n        q.xy *= rotate2d(3.14159265359*float(i)/6.);\n        q.yz *= rotate2d(3.14159265359*.5);\n        \n        res = min(res,sdCylinder(q,vec3(0.4,0.11,0.01)));\n    }\n    //ClipplingTunnel\n    float clipping = sdCylinder(p.yzx,vec3(0.,0.,.415));\n    \n    float mat = 0.;\n    \n    res = min(res,-clipping);\n    \n    if(res == -clipping ){mat = 1.;}\n    return vec2(res,mat);\n}\nvec2 march(vec3 ro,vec3 p){\n    float id = 0.;\n    float dist = .0;\n    for(int i = 0; i<64;i++){\n    vec2 depth = scene(ro + dist * p);\n    id = depth.y;\n        if(depth.x < EPSILON){\n            return vec2(dist,id);\n        }\n        //Has to be divided\n        dist += depth.x/2.;\n    }\n    return vec2(dist,id);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Camera setting\n    float angleLead = .5;\n    vec3 ro = vec3(0.,.0,1.0);\n    vec3 ta = vec3( -cos(iTime+angleLead), sin(iTime+angleLead), .0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    //Camera Movement\n    ro.z -= iTime;\n    ro.xy = vec2(-cos(ro.z),-sin(ro.z));\n    \n    vec2 dist = march(ro,rd);\n    vec3 col = vec3(0.);\n    if(dist.y == 0.){\n        col = mix(vec3(1, 0.239, 0.051),vec3(1, 0.714, 0.286),smoothstep(.7,3.,dist.x));\n    }\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}