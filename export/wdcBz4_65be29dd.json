{"ver":"0.1","info":{"id":"wdcBz4","date":"1604447616","viewed":122,"name":"simple spheres (vlllll)","username":"valalalalala","description":"Ray tracing a few spheres with some simple reflection and lighting. Occlusion mostly working. Reflection on the plane is sad, but maybe accurate.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["reflection","basic","shading","spheres","occlusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831952\n#define R \t\t\tiResolution\n#define M \t\t\tiMouse\n#define T \t\t\tiTime\n\n///////////////////////////////////////////////////////////////////////////////////////////\n\n#define SPHERE_COUNT  9\n#define SPHERE_RADIUS 0.5\n#define LIGHT_POWER   1.0\n#define LIGHT         vec3( 0.0, 0.5, -0.33 )\n#define SHINE         0.22\n\n///////////////////////////////////////////////////////////////////////////////////////////\n\n\n// https://iquilezles.org/articles/intersectors\nvec2 sphereHit( in vec3 rayOrigin, in vec3 rayDirection, in vec3 center, float radius )\n{\n    vec3 originToCenter = rayOrigin - center;\n    float b = dot( originToCenter, rayDirection );\n    float c = dot( originToCenter, originToCenter ) - radius*radius;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n// from https://www.shadertoy.com/view/4d2XWV ... magic\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 colorOfT( vec3 a, vec3 b, vec3 c, vec3 d, float t ) {\n    return a + b * cos( PI2 * ( c * t + d ) );\n}\n\nvec3 colorIt( float t ) {\n    return colorOfT( \n\t\tvec3( 0.5, 0.5, 0.5 ),\n\t\tvec3( 0.5, 0.5, 0.5 ),\n\t\tvec3( 1.0, 1.0, 1.0\t), \n\t\tvec3( 0.00, 0.33, 0.67 ),\n\t\tt\n\t);\n}\n\nfloat planeTest( in vec3 origin, in vec3 direction, out vec3 hit, out vec3 normal, out vec3 color ) {\n    float t = iPlane( origin, direction );\n    if ( t < 0.0 ) {\n        return t;\n    }\n    \n    hit = origin + t * direction * 0.99; // weak attempt to avoid self collisions;\n    normal = vec3( 0.0, 1.0, 0.0 );\n    color = vec3( 1.0 );\n    return t;\n}\n\nfloat sphereTest( in vec3 origin, in vec3 direction, out vec3 hit, out vec3 normal, out vec3 color ) {\n    // model information\n    int count = SPHERE_COUNT;\n    float radius = SPHERE_RADIUS;\n \n    // collision information\n    float closest = -1.0;\n    \n    for ( int i = 0 ; i < SPHERE_COUNT ; i++ ) {\n        float ic = float( i ) / float ( count );\n        float ingle = PI2 * ic;\n    \tfloat angle = T * 1.33 + ingle;\n        float offset = abs( sin( angle * 1.0 ) ) * radius * 5.0;\n        \n        float x = offset * cos( angle );\n        float y = offset * cos( angle + T );\n        y = pow(0.1,abs(sin(angle*1.10+1.0)));\n        float z = offset * sin( angle ) -1.0;\n        \n     \tvec3 sphere = vec3( x, y, z );\n        \n        vec2 d = sphereHit( origin, direction, sphere, radius );\n        if ( d.x < 0.0 ) continue;\n        \n        float h = min( d.x, d.y );\n        if ( h < closest || closest < 0.0 ) {\n            closest = h;\n           \thit = origin + closest * direction * 0.99; // weak attempt to avoid self collisions\n            normal = normalize( hit - sphere ); \n            color = colorIt( ic );\n        }\n    }\n    \n    return closest;\n}\n\n\nfloat hitTest( in vec3 origin, in vec3 direction, out vec3 hit, out vec3 normal, out vec3 color ) {\n    float d = sphereTest( origin, direction, hit, normal, color );\n    if ( d > 0.0 ) return d; // not sure this is ok..  \n    \n    d = planeTest( origin, direction, hit, normal, color );\n    color = vec3(1.0);\n    return d;\n}\n\nvec3 vec3_11_to_01( vec3 v ) {\n    return 0.5 * ( v + 1.0 );\n}\n\nvec4 heckers( in vec3 origin, vec3 direction ) {\n    vec3 hit;\n    vec3 normal;\n    vec3 color;\n    float closest = hitTest( origin, direction, hit, normal, color );\n    \n    if ( closest < 0.0 ) {\n        return vec4(vec3(0.11),1.0);\n    }\n\n    // normal on sphere where the ray hit\n    vec3 hitDirection = normal;\n    \n    vec3 toLight = normalize( LIGHT - hit );\n    float lightAngle = dot( normal, toLight );  \n    float lightDistance = abs( length( LIGHT - hit ) );\n    float lightStrength = LIGHT_POWER / pow( lightDistance, 2.0 ) * pow( lightAngle, 2.0 );\n  \n    // occlusion \n    vec3 occlusionHit; \n    vec3 occlusionNormal; \n    vec3 occlusionColor; // lol\n    float occlusionClosest = hitTest(hit, toLight, occlusionHit, occlusionNormal, occlusionColor );\n    if ( occlusionClosest >= 0.0 ) {\n        // FIXME: some strange banding here. maybe due to self collisions...\n        lightStrength = pow( lightStrength, 2.0 );\n    }\n    \n    // reflection\n    // FIXME: reflection or sphere in plane is flat and (worse) fake looking\n    int reflected = 0;\n    vec3 rHit = hit;\n    vec3 rHitDirection = hitDirection;\n    vec3 accumulateReflectColor = vec3( 0.0 );\n    for ( int i = 0 ; i < 5 ; i++ ) {\n        vec3 reflectHit; \n        vec3 reflectNormal; \n        vec3 reflectColor; \n        float reflectClosest = hitTest(rHit, rHitDirection, reflectHit, reflectNormal, reflectColor );\n        if ( reflectClosest < 0.0 ) break;\n\t\treflected = 1 + i;\n        if ( 0 == i ) {\n    \t\taccumulateReflectColor = reflectColor;\n        } else {\n            accumulateReflectColor = accumulateReflectColor * 0.90 + 0.10 * reflectColor;\n        }\n    }\n\tif( 0 != reflected ) {\n    \tcolor = accumulateReflectColor * SHINE + ( 1.0 - SHINE ) * color;\n    }\n    //color=vec3(float(reflected)/5.0); // fun negaverse version\n\n    \n    float ambient = 0.22;\n    float environmental = 1.0 - ambient;\n    \n    color = ( color * ambient ) + ( environmental * color * lightStrength );\n    \n    return vec4( color, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y; \n    vec3 origin = vec3(0.0, 0.0, 4.0 );\n    vec3 direction = normalize( vec3(xy,-2.0) );\n    \n    fragColor = heckers( origin, direction );\n}","name":"Image","description":"","type":"image"}]}