{"ver":"0.1","info":{"id":"fd2SRK","date":"1620577867","viewed":198,"name":"Columns Loop","username":"Bleuje","description":"3 seconds long perfect loop\n\nRaymarching code structure from lsdlive (https://www.shadertoy.com/view/4s3yDM)","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n// Using this shader from lsdlive as raymarching template : https://www.shadertoy.com/view/4s3yDM\n// Thanks lsdlive\n// Thanks to Cookie collective\n// Thanks to tdhooper and iq\n\n#define PI 3.14159\n#define TAU (2.*PI)\n\n#define radius1 18.\n#define radius2 19.\n#define duration 3.0\n\n// hglib / iq\n// http://mercury.sexy/hg_sdf/\n// https://iquilezles.org/articles/distfunctions\nfloat rep(float p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nvec3 rep(vec3 p, float d) {\n\treturn mod(p + d*.5, d) - d*.5;\n}\n\nvoid amod(inout vec2 p, float m) {\n\tfloat a = rep(atan(p.x, p.y), m);\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat smoo(float a, float b, float r) {\n\treturn clamp(.5 + .5*(b - a) / r, 0., 1.);\n}\n\nfloat smin(float a, float b, float r) {\n\tfloat h = smoo(a, b, r);\n\treturn mix(b, a, h) - r*h*(1. - h);\n}\n\nvec4 opu(vec4 a, vec4 b) {\n\treturn a.w < b.w ? a : b;\n}\n\nfloat time;\nfloat glow;\nfloat d2_saved;\nfloat d3_saved;\n//return vec4: vec3 color + float distance\nvec4 map(vec3 p) {\n\n    vec4 surface;\n    vec3 q = p;\n    float d = 10000.;\n    \n    d = min(d,length(q*vec3(1.,1.,1.))-radius1);\n    d = min(d,-(length(q*vec3(1.,1.,1.))-radius2));\n    float d2 = d;\n    \n    // walls, less visible for large angle\n    float angle = 0.07;\n    p.xy *= r2d(angle);\n    float d3 = p.x;\n    p.xy *= r2d(-2.*angle);\n    d3 = min(d3,-p.x);\n    float k = 0.07;\n    d = smin(d3,d2,k);\n    surface = vec4(vec3(0.),d);\n    \n    p = q;\n    //p.y-=13.0;\n    float m2 = TAU/150.;\n    p.yz *= r2d(- 2.0*time*m2-0.*PI/2.0);\n    float indDepth = floor((atan(p.z,p.y)+0.5*m2)/m2);\n    p.yz *= r2d(m2/2.0);\n    amod(p.yz,m2);\n    float m1 = TAU/230.;\n    float rot = PI/2.0;\n    float addRot = (mod(indDepth,2.0)==1.?m1/2.0:0.);\n    float indHorizontal = floor((atan(p.y,p.x)+0.5*m1+addRot)/m1);\n    if(indHorizontal!=floor(TAU/m1/4.)+1.||mod(indDepth,2.0)!=1.)\n    {\n        p.xy *= r2d(rot+addRot);\n        amod(p.xy,m1);\n        p.xy *= r2d(-rot);\n        \n        float cnt = 6.0;\n        float si = sign(indHorizontal-(floor(TAU/m1/4.)+0.5));\n        p.xz *= r2d(14.0*p.y*si-si*10.*time*TAU/cnt);\n        \n        float m3 = TAU/cnt;\n        float indTwist = floor((atan(p.z,p.x))/m3);\n        amod(p.xz,m3);\n        float r = 0.055;\n        p.x -= r;\n        d = length(p.xz)-TAU*r/cnt/2.0;\n        d = smin(d2,d,0.18);\n        \n        float col1 = mod(indTwist,2.0);\n        float lp = smoothstep(0.,0.3,d2);\n        col1 = mix(0.,col1,lp);\n        \n        surface = opu(surface,vec4(vec3(col1),d));\n    }\n    \n    //glow from lsdlive\n    glow += .015 / (.01 + d*d);\n    d2_saved = d2;\n    d3_saved = d3;\n    \n\treturn surface;\n\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec2 e = vec2(1., -1.)*.5773*.0005;\n\treturn normalize(e.xyy*map(pos + e.xyy).w +\n\t\te.yyx*map(pos + e.yyx).w +\n\t\te.yxy*map(pos + e.yxy).w +\n\t\te.xxx*map(pos + e.xxx).w);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n    \n    time = mod(iTime/duration,1.0);\n\n\tfloat posy = mix(radius1,radius2,0.17);\n\tvec3 ro = vec3(0., posy-0.25, -4.);\n\tvec3 ta = vec3(0, posy+0.2, 0.);\n\tvec3 rd;\n\n\trd = camera(ro, uv, ta);\n    \n    float rng = hash12(100.*q + 123.*time);\n\n\tvec3 p;\n\tvec4 res;\n\tfloat ri, t = 0.;\n\tfor (float i = 0.; i < 1.; i += 1.0/80.0) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tres = map(p);\n\t\tif (res.w<.001 || t>30.) break;\n\t\tt += res.w*(0.58+0.03*rng);\n\t}\n\n    vec3 bg = vec3(0.);\n    \n    vec3 col = res.xyz;\n    \n    float dper = 1.0;\n    float dist = t + 1.5*p.y + 1.5*pow(abs(p.x),1.3);\n    float a = mod(dist-dper*time,dper)/dper;\n    float lp = smoothstep(0.,0.5,d2_saved);\n    float v = 0.5*glow*(lp+0.1);\n    col += vec3(v,0.6*v,0.4*v)*pow(min(a,10.0*(1.-a)),6.0);\n    col += vec3(0.2*glow*(1.0-lp),0.,0.)*pow(min(a,20.0*(1.-a)),20.0);\n    col += vec3(0.05);\n    \n    col = mix(col, vec3(0.4,0.8,1.0), 0.9*ri);\n\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}