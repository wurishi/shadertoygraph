{"ver":"0.1","info":{"id":"tlSGR3","date":"1560425079","viewed":83,"name":"rect color","username":"Stephen_epa","description":"learn shape function","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLUE vec3(0., 0., 1.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define YELLOW vec3(1., 1., 0.)\n#define CYAN vec3(0., 1., 1.)\n#define PINK vec3(1., 0., 1.)\n\n#define SPLIT 6\n#define SCALE 40\n#define SEED vec2(.8, .34)\nfloat BorderRect(vec2 uv, vec4 border, vec4 bias)\n{\n    if (length(bias) == 0.)\n        bias = .1*border;\n    vec2 bl = vec2(smoothstep(border.xy-bias.xy, border.xy+bias.xy, uv));\n    vec2 rt = vec2(smoothstep(border.zw-bias.zw, border.zw+bias.zw, 1.-uv));\n    return (bl.x*bl.y*rt.x*rt.y);\n}\nfloat BorderRect(vec2 uv, vec4 ruv)\n{\n    uv *= float(SCALE);\n    vec4 border = vec4(ruv.xy+.5, ruv.xy+ruv.zw-.5);\n    vec2 bias = vec2(.01);\n    vec2 bl = vec2(smoothstep(border.xy-bias, border.xy+bias, uv.xy));\n    vec2 rt = vec2(smoothstep(border.zw+bias, border.zw-bias, uv.xy));\n    return (bl.x*bl.y*rt.x*rt.y);\n    \n}\nfloat hash(float x)\n{\n    return fract(sin(x)*42631.2);\n}\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(244.2, 852.19)))*12317.12);\n}\nvec3 hashColor(vec2 uv)\n{\n    float K = 1./7.;\n    float x = hash(uv);\n    if (x < K)\n        return RED;\n    else if ( x < 2.*K)\n        return BLUE;\n    else if ( x < 3.*K)\n        return YELLOW;\n    else if ( x < 4.*K)\n        return GREEN;\n    else if ( x < 5.*K)\n        return CYAN;\n    else if ( x < 6.*K)\n        return PINK;\n    else\n        return vec3(1.);\n}\n\nvec4 GetRandomUv(vec2 uv)\n{\n    vec2 rand[SPLIT];\n    vec2 seed = SEED;\n    vec2 scale = vec2(SCALE);\n    int i;\n    vec2 n = vec2(0.);\n    for (i = 0; i < SPLIT; ++i)\n    {\n        vec2 xy;\n        xy.x = hash(seed.x+float(i));\n        xy.y = hash(seed.y+float(i));\n        rand[i] = floor(scale*xy);\n        // hack\n        //rand[i] = vec2(float(SCALE)/float(SPLIT));\n        //scale -= rand[i];\n        n += rand[i];\n    }\n    for (i = 0; i < SPLIT; ++i)\n    {\n        rand[i] = rand[i]/n*scale;\n    }\n    uv *= float(SCALE);\n    vec2 pi = floor(uv);\n    vec2 uvs = vec2(0.0);\n    int j;\n    for (i = 0; i < SPLIT; ++i)\n    {\n        \n            // ok\n        uvs.y = 0.;\n\t\tfor (j = 0; j < SPLIT; ++j)\n        {\n            if (pi.x >= uvs.x && pi.x < uvs.x + rand[i].x &&\n               pi.y >= uvs.y && pi.y < uvs.y + rand[j].y)\n                return vec4(uvs, rand[i].x, rand[j].y);\n            uvs.y += rand[j].y;\n        }\n        uvs.x += rand[i].x;\n    }\n    return vec4(.5);\n    // for a [0, scale]^2 map\n    // get one vec4 : [uv.xy, scalex, scaley]\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t//uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n\t//uv *= 10.;\n    vec2 uvf = fract(uv);\n    vec2 uvi = floor(uv);\n    vec4 ruv = GetRandomUv(uv);\n\tcol += vec3(BorderRect(uv, ruv))*hashColor(ruv.xy);\n    //col = ruv.xyx;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}