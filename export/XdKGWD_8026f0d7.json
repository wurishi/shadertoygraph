{"ver":"0.1","info":{"id":"XdKGWD","date":"1454594094","viewed":322,"name":"Copy Basic Distance Fields Tut","username":"psk","description":"Following the Ray Marching segment here by Iq, http://on-demand.gputechconf.com/gtc/2014/video/S4550-shadertoy-fragment-shader.mp4 (about 12 minutes in).  Ive tried to copy each stage covered.  Public here as a learning tool.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["procedural","basic","tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/********\nFollowing the Ray Marching segment here by Iq, (but watch the whole vid!!)\nhttp://on-demand.gputechconf.com/gtc/2014/video/S4550-shadertoy-fragment-shader.mp4 (about 12 minutes in).  Ive tried to copy each stage covered.  \nThis is primarily for me to better understand each line that is covered\nI am making it public in case anyone else finds it useful\n\nThe code is designed to be **READ FORM BOTTOM TO TOP**\n\nEach stage has a Stagex entry point and a Mapstagex and calculateNormalsStagex functions\n(except stage 2-4 which share the first functions)\n\nIm still learning shadertoy/webgl so if you can shed any lights\non the functions i dont understand, or improve the comment quality please do\n\nI PREFER PINK!!\n\n(I think after this i have a basic understanding of ray marching and will next try to\nmake my own effect :)\n\n\n***/\n\n\nfloat mapstage9 (in vec3 p)\n{\n   \n   vec3 q= mod (p+2.0,4.0) - 2.0;\n   float d1 = length(q) - 1.0;   \n   d1 += 0.1* sin(10.0 * p.x)*sin(5.0 * p.y+2.0*iTime)*sin(10.0 * p.z) ; \n   float d2 = p.y + 1.0;\n   float k = abs(sin (iTime))+1.5;\n   float h= clamp (0.5 + 0.5 * (d1-d2)/k,0.0, 1.0);\n   return mix (d1,d2, h) - k* h *(1.0-h);\n}\n\nvec3 calcNormalstage9(in vec3 p)\n{\n   vec2 e= vec2(0.001,0.0);\n   return normalize (vec3 \n        (\n        \tmapstage9 (p+e.xyy) - mapstage9(p-e.xyy),\n            mapstage9 (p+e.yxy) - mapstage9(p-e.yxy),\n            mapstage9 (p+e.yyx) - mapstage9(p-e.yyx)                            \n        )\n\t);\n}\n\nvoid stage9( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       //ensure we are calling the changed map function for this stage\n       h = mapstage9 (ro + t*rd);\t\t\n       t+=h;\n    }\n\n    vec3 lig = vec3(0.5733);\n    \n    if (t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        //the calcnormals fucntion has changed for this stage as we have altered map\n        vec3 nor = calcNormalstage9(pos);\n     \tcol = vec3(1.0); \n        col = vec3(1.0,0,0.5) * clamp ( dot (nor,lig),0.0, 1.0);\n        col += vec3(0.2,0.3,0.3) * clamp ( nor.y,0.0, 1.0);\n        //Add a light in proportianl to how much the object faces the camera\n        //I couldnt determine the name of the effect to further research?\n        col += vec3(0.7,0.1,0.2) * clamp (1.0-dot(rd,nor),0.0, 1.0);\n        col *= 1.8;\n        col *= exp (-0.005*t);\n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\n\nfloat mapstage8 (in vec3 p)\n{\n   \n   vec3 q= mod (p+2.0,4.0) - 2.0;\n   float d1 = length(q) - 1.0;   \n   d1 += 0.1* sin(10.0 * p.x)*sin(5.0 * p.y+2.0*iTime)*sin(10.0 * p.z) ; \n   float d2 = p.y + 1.0;\n   \n   //size of transition between blending area\n   //orginal uses a constant but thought its more illustrative with a animation\n   float k = abs(sin (iTime));\n   \n   //determine blending area is distance between two objects\n   float h= clamp (0.5 + 0.5 * (d1-d2)/k,0.0, 1.0);\n    \n   //mix the two values together based on the blending variable\n   //the second half of the code seems to increase speead??\n   return mix (d1,d2, h) - k* h *(1.0-h);\n}\n\nvec3 calcNormalstage8(in vec3 p)\n{\n   vec2 e= vec2(0.001,0.0);\n   return normalize (vec3 \n        (\n        \tmapstage8 (p+e.xyy) - mapstage8(p-e.xyy),\n            mapstage8 (p+e.yxy) - mapstage8(p-e.yxy),\n            mapstage8 (p+e.yyx) - mapstage8(p-e.yyx)                            \n        )\n\t);\n}\n\nvoid stage8( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       //ensure we are calling the changed map function for this stage\n       h = mapstage8 (ro + t*rd);\t\t\n       t+=h;\n    }\n\n    vec3 lig = vec3(0.5733);\n    \n    if (t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        //the calcnormals fucntion has changed for this stage as we have altered map\n        vec3 nor = calcNormalstage8(pos);\n     \tcol = vec3(1.0); \n        col = vec3(1.0,0,0.5) * clamp ( dot (nor,lig),0.0, 1.0);\n        col += vec3(0.2,0.3,0.3) * clamp ( nor.y,0.0, 1.0);\n        col *= exp (-0.005*t);\n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\n\n\nfloat mapstage7 (in vec3 p)\n{\n   //modulo the position to effectively repeat the shape (infinitely)\n   vec3 q= mod (p+2.0,4.0) - 2.0;\n   //d1 now tests against q rather than p\n   float d1 = length(q) - 1.0;   \n   d1 += 0.1* sin(10.0 * p.x)*sin(5.0 * p.y+2.0*iTime)*sin(10.0 * p.z) ; \n   float d2 = p.y + 1.0;\n   return min (d1,d2);\n}\n\nvec3 calcNormalstage7(in vec3 p)\n{\n   vec2 e= vec2(0.001,0.0);\n   return normalize (vec3 \n        (\n        \tmapstage7 (p+e.xyy) - mapstage7(p-e.xyy),\n            mapstage7 (p+e.yxy) - mapstage7(p-e.yxy),\n            mapstage7 (p+e.yyx) - mapstage7(p-e.yyx)                            \n        )\n\t);\n}\n\nvoid stage7( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       //ensure we are calling the changed map function for this stage\n       h = mapstage7 (ro + t*rd);\t\t\n       t+=h;\n    }\n\n    vec3 lig = vec3(0.5733);\n    \n    if (t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        //the calcnormals fucntion has changed for this stage as we have altered map\n        vec3 nor = calcNormalstage7(pos);\n     \tcol = vec3(1.0); \n        col = vec3(1.0,0,0.5) * clamp ( dot (nor,lig),0.0, 1.0);\n        col += vec3(0.2,0.3,0.3) * clamp ( nor.y,0.0, 1.0);\n        //reduce the fog a little\n        col *= exp (-0.005*t);\n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\n\nfloat mapstage6 (in vec3 p)\n{\n   float d1 = length(p) - 1.0;\n   //modulate on the x,y,and z - animate on the y\n   d1 += 0.1* sin(10.0 * p.x)*sin(5.0 * p.y+2.0*iTime)*sin(10.0 * p.z) ; \n   float d2 = p.y + 1.0;\n   return min (d1,d2);\n}\n\nvec3 calcNormalstage6(in vec3 p)\n{\n   vec2 e= vec2(0.001,0.0);\n   return normalize (vec3 \n        (\n        \tmapstage6 (p+e.xyy) - mapstage6(p-e.xyy),\n            mapstage6 (p+e.yxy) - mapstage6(p-e.yxy),\n            mapstage6 (p+e.yyx) - mapstage6(p-e.yyx)                            \n        )\n\t);\n}\n\nvoid stage6( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       //ensure we are calling the changed map function for this stage\n       h = mapstage6 (ro + t*rd);\t\t\n       t+=h;\n    }\n\n    vec3 lig = vec3(0.5733);\n    \n    if (t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        //the calcnormals fucntion has changed for this stage as we have altered map\n        vec3 nor = calcNormalstage6(pos);\n     \tcol = vec3(1.0); \n        col = vec3(1.0,0,0.5) * clamp ( dot (nor,lig),0.0, 1.0);\n        col += vec3(0.2,0.3,0.3) * clamp ( nor.y,0.0, 1.0);\n        col *= exp (-0.1*t);\n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\nfloat mapstage5 (in vec3 p)\n{\n   float d1 = length(p) - 1.0;\n   //modulate on the x\n   d1 += 0.1* sin(10.0 * p.x); \n   float d2 = p.y + 1.0;\n   return min (d1,d2);\n}\n\nvec3 calcNormalstage5(in vec3 p)\n{\n   vec2 e= vec2(0.001,0.0);\n   return normalize (vec3 \n        (\n        \tmapstage5 (p+e.xyy) - mapstage5(p-e.xyy),\n            mapstage5 (p+e.yxy) - mapstage5(p-e.yxy),\n            mapstage5 (p+e.yyx) - mapstage5(p-e.yyx)                           \n        \n        )\n\t);\n}\n\nvoid stage5( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       //ensure we are calling the changed map function for this stage\n       h = mapstage5 (ro + t*rd);\t\t\n       t+=h;\n    }\n\n    vec3 lig = vec3(0.5733);\n    \n    if (t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        //the calcnormals fucntion has changed for this stage as we have altered map\n        vec3 nor = calcNormalstage5(pos);\n     \tcol = vec3(1.0); \n        col = vec3(1.0,0,0.5) * clamp ( dot (nor,lig),0.0, 1.0);\n        col += vec3(0.2,0.3,0.3) * clamp ( nor.y,0.0, 1.0);\n        col *= exp (-0.1*t);\n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\n\n\nfloat mapstage4 (in vec3 p)\n{\n   float d1 = length(p) - 1.0;\n   //d2 defines a distance from a plane\n   float d2 = p.y + 1.0;\n   //return the closest \n   return min (d1,d2);\n}\n\nvec3 calcNormalstage4(in vec3 p)\n{\n   vec2 e= vec2(0.001,0.0);\n   return normalize (vec3 \n        (\n        \tmapstage4 (p+e.xyy) - mapstage4(p-e.xyy),\n            mapstage4 (p+e.yxy) - mapstage4(p-e.yxy),\n            mapstage4 (p+e.yyx) - mapstage4(p-e.yyx)                           \n        \n        )\n\t);\n}\n\nvoid stage4( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       //ensure we are calling the changed map function for this stage\n       h = mapstage4 (ro + t*rd);\t\t\n       t+=h;\n    }\n\n    vec3 lig = vec3(0.5733);\n    \n    if (t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        //the calcnormals fucntion has changed for this stage as we have altered map\n        vec3 nor = calcNormalstage4(pos);\n     \tcol = vec3(1.0); \n        col = vec3(1.0,0,0.5) * clamp ( dot (nor,lig),0.0, 1.0);\n        col += vec3(0.2,0.3,0.3) * clamp ( nor.y,0.0, 1.0);\n        col *= exp (-0.1*t);\n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\n\n//From this point up we will change map and calc normal per stage\n\n//Simple single sphere is defined by distance from centre - radius\nfloat map (in vec3 p)\n{\n   float d1 = length(p) - 1.2;\n   return d1;\n}\n\n//The calculate normal function.  Im a little vauge as to what is going on here.\nvec3 calcNormal(in vec3 p)\n{\n   //define magic number... (not sure where this comes from)\n   vec2 e= vec2(0.001,0.0);\n   //translate the 2d vector to 3d?\n   return normalize (vec3 \n        (\n        \tmap (p+e.xyy) - map(p-e.xyy),\n            map (p+e.yxy) - map(p-e.yxy),\n            map (p+e.yyx) - map(p-e.yyx)                           \n        \n        )\n\t);\n}\n\nvoid stage44( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       h = map (ro + t*rd);\t\t\n       t+=h;\n    }\n    \n    if (t < tmax)\n    {\n        \n        vec3 pos = ro + t * rd;       \n        vec3 nor = calcNormal(pos);\n     \tcol = vec3(1.0);  \n        col = nor;\n        //col *= nor.x;\n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\n\nvoid stage3( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       h = map (ro + t*rd);\t\t\n       t+=h;\n    }\n    \n    //Define a light source\n    vec3 lig = vec3(0.5733);\n    \n    if (t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n     \tcol = vec3(1.0); \n        \n        //Add the light\n        col = vec3(1.0,0,0.5) * clamp ( dot (nor,lig),0.0, 1.0);\n        //Add some light form above (like sun light)\n        col += vec3(0.2,0.3,0.3) * clamp ( nor.y,0.0, 1.0);\n        //Add a little fog\n        col *= exp (-0.1*t);\n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\nvoid stage2( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,2.0);    \n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       h = map (ro + t*rd);\t\t\n       t+=h;\n    }\n    \n    if (t < tmax)\n    {\n        //calculate the position as the ray orgin + t + direction\n        vec3 pos = ro + t * rd;\n        //calculate a normal at this posiiton\n        vec3 nor = calcNormal(pos);\n     \tcol = vec3(1.0); \n        //Set the color to the normal for testing\n        col = nor;        \n    }\n    \n\tfragColor =vec4 (col,1.0);\n}\n\n//this sis the first stage rendering a sphere.  NB the map unction is defined above stage 4\n\n\nvoid stage1( out vec4 fragColor, in vec2 fragCoord )\n{\n    //modify the cordinates\n    //normalise and center and make square aspect\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 *uv;    \n    p.x *= iResolution.x / iResolution.y;\n    \n    //Define a ray, ro = ray orgin\n    vec3 ro = vec3(0.0,0.0,2.0);    \n    //rd = ray direction (i.e stright down the z\n    vec3 rd = normalize (vec3 (p,-1.0));\n    \n    //Initalise out colour output\n    vec3 col = vec3(0.0);\n    \n    //Define the control variables for the ray marcher    \n    float tmax = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    //march a ray for this fragment\n    for (int i=0;i<100;i++)\n    {\n       if ( h < 0.0001 || t>tmax) break;\n       //run the map function on the current ray position\n       h = map (ro + t*rd);\t\t\n       t+=h;\n    }\n    \n    //Test if the ray has intersecte the field\n    if (t < tmax)\n    {\n        //set a pure white fragment   \n     \tcol = vec3(1.0);         \n    }\n    \n    //and thats the output!\n\tfragColor =vec4 (col,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Quick hack to show the differnrt stages that are gone thouhg in the talk\n    //Dont EVER write code like this in real life :)    \n    int stage = int(mod(iTime/2.0, 9.0));\n    \n    \n    //Unlit sphere\n    if (stage == 0) stage1(fragColor, fragCoord);\n    //Apply normals to sphere\n    if (stage == 1) stage2(fragColor, fragCoord);\n    //Apply lights to the sphere\n    if (stage == 2) stage3(fragColor, fragCoord);\n    //Add a plane\n    if (stage == 3) stage4(fragColor, fragCoord);\n    //Deform the sphere\n    if (stage == 4) stage5(fragColor, fragCoord);\n \t//Animate the the deformation\n    if (stage == 5) stage6(fragColor, fragCoord);\n    //Duplicate the object\n    if (stage == 6) stage7(fragColor, fragCoord);\n    //Merge two objects by distance\n    if (stage == 7)stage8(fragColor, fragCoord);\n    //final light\n   \tif (stage == 8) stage9(fragColor, fragCoord);\n}\n","name":"Image","description":"","type":"image"}]}