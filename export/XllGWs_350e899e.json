{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec4 shape (vec2 uv, vec3 objDiff, vec3 objCol, vec3 bCol){\n  \n    if (objDiff.z > 0.0)\n        if(   (  uv.x >= ( objDiff.x - (iResolution.x/2.0) * (1.0/(objDiff.z*objDiff.z)) )  )\n           \t\t&&\n          \t  (  uv.x <= ( objDiff.x + (iResolution.x/2.0) * (1.0/(objDiff.z*objDiff.z)) )  )\n           &&\n           (  uv.y >= ( objDiff.y - (iResolution.y/2.0) * (1.0/(objDiff.z*objDiff.z)) )  )\n           \t\t&&\n          \t  (  uv.y <= ( objDiff.y + (iResolution.y/2.0) * (1.0/(objDiff.z*objDiff.z)) )  )\n           \n           \n          ){ return vec4 (objCol, 1.0); }\n    return vec4 (bCol, 1.0);\n}\n\n\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 objPos = vec3  (0.5, 0.5, iTime*60.0+24.0);\n    vec3 objDiff = vec3 (0.0, 0.0, 0.0);\n    vec2 cameraAngle = vec2 ( iMouse.xy / iResolution.xy ) - vec2(0.5, 0.5);\n    vec3 camPos = vec3\t( cameraAngle, -1);\n    \n    \n    objDiff.x = objPos.x - camPos.x;\n    objDiff.y = objPos.y - camPos.y;\n    objDiff.z = objPos.z - camPos.z;\n    \n  \n    vec3 objCol = vec3 (1.0, 0.1, 0.1);\n    vec3 bCol = vec3(1.0,1.0,1.0);\n    \n    \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = shape(uv, objDiff, objCol, bCol);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XllGWs","date":"1426192359","viewed":475,"name":"billboard engine","username":"timeiskey","description":"prototype of engine that places squares along vector objects.\nobj point arrays cant be defined in shader toy so ill do it in another language.\n////////////somehow allow for trig transforms","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","rotationless","engine"],"hasliked":0,"parentid":"","parentname":""}}