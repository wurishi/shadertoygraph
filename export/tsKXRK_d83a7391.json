{"ver":"0.1","info":{"id":"tsKXRK","date":"1574466254","viewed":143,"name":"Heart Pump Animated","username":"edubart","description":"Animated heart","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","animated","heart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.0\n#define MAX_STEPS 128\n#define SURF_DIST 0.0001\n#define M_PI 3.1415926535897932384626433832795\n#define AA 2\n\n#define MATERIAL_BODY 1\n\nstruct Hit {\n    float d;\n    int material;\n};\n\n// Distance to sphere at origin of radius `r`\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n#define check_hit(m) if(dist < mindist) { material = m; mindist = dist; }\n\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\n// Return the closest surface distance to point p\nHit get_sdf(vec3 p) {\n    float mindist = MAX_DIST;\n    int material = 0;\n    float dist;\n\n    // heart\n    vec3 q = p;\n    q.x = abs(q.x);\n    q.x = almostIdentity(q.x, 2.0, 1.0);\n    q.z = q.z*(2.0 - q.y/15.0);\n    q.y = 4.0 + 1.2*q.y - q.x*sqrt(max((20.0-q.x)/15.0, 0.0));\n    dist = sd_sphere(q, 15.0 + pow(0.5 + 0.5*sin(iTime*10.0 + q.y/25.0 + q.x/12.0 + q.z/20.0), 4.0)*3.0);\n    dist /= 3.0;\n    check_hit(MATERIAL_BODY);\n\n    return Hit(mindist, material);\n}\n\n// Get normal at point `p` using the tetrahedron technique for computing the gradient\nvec3 get_normal(vec3 p) {\n    const float eps = 0.01;\n    vec2 e = vec2(1.0,-1.0);\n    return normalize(e.xyy*get_sdf(p + e.xyy*eps).d + \n                     e.yyx*get_sdf(p + e.yyx*eps).d + \n                     e.yxy*get_sdf(p + e.yxy*eps).d + \n                     e.xxx*get_sdf(p + e.xxx*eps).d);\n}\n\n// March a ray from `rayfrom` along the `raydir` direction and return the closet surface distance\nHit ray_march(vec3 rayfrom, vec3 raydir) {\n    // begin at ray origin\n    float t = 0.0;\n    Hit hit;\n    // ray march loop\n    for(int i=0; i<MAX_STEPS; ++i) {\n        // compute next march point\n        vec3 p = rayfrom+t*raydir;\n        // get the distance to the closest surface\n        hit = get_sdf(p);\n        // hit a surface\n        if(abs(hit.d) < (SURF_DIST*t))\n            break;\n        // increase the distance to the closest surface\n        t += hit.d;\n    }\n    if(t > MAX_DIST)\n        hit.material = 0;\n    // return the distance to `rayfrom`\n    hit.d = t;\n    return hit;\n}\n\n// Hard shadows\nfloat hard_shadow(vec3 rayfrom, vec3 raydir, float tmin, float tmax) {\n    float t = tmin;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayfrom + raydir*t;\n        float h = get_sdf(p).d;\n        if(h < SURF_DIST)\n            return 0.0;\n        t += h;\n        if(t > tmax)\n            break;\n    }\n    return 1.0;\n}\n\n// Get occlusion along `normal` from point of view `rayfrom`\nfloat get_occlusion(vec3 rayfrom, vec3 normal) {\n    const int AO_ITERATIONS = 5;\n    const float AO_START = 0.01;\n    const float AO_DELTA = 0.11;\n    const float AO_DECAY = 0.95;\n    const float AO_INTENSITY = 1.0;\n\n    float occ = 0.0;\n    float decay = 1.0;\n    for(int i=0; i<AO_ITERATIONS; ++i) {\n        float h = AO_START + float(i) * AO_DELTA;\n        float d = get_sdf(rayfrom + h*normal).d;\n        occ += (h-d) * decay;\n        decay *= AO_DECAY;\n    }\n    return clamp(1.0 - occ * AO_INTENSITY, 0.0, 1.0);\n}\n\n// Return diffuse albedo color for material\nvec3 get_material_diffuse(vec3 p, int material) {\n    switch(material) {\n        case MATERIAL_BODY:\n            return vec3(0.3, 0.0, 0.0);\n        default:\n            return vec3(1.0, 1.0, 1.0);\n    }\n}\n\n// Return specular color for material\nvec3 get_material_specular(vec3 p, int material) {\n    switch(material) {\n        case MATERIAL_BODY:\n            return vec3(0.3, 0.05, 0.05)*3.0;\n        default:\n            return vec3(0.0);\n    }\n}\n\n// Compute the scene light at a point\nvec3 get_light(vec3 raydir, vec3 p, int material) {\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    vec3 normal = get_normal(p);\n    float occlusion = get_occlusion(p, normal);\n\n    // sun light\n    const float SUN_INTENSITY = 1.0;\n    const float SUN_SHINESS = 8.0;\n    const vec3 SUN_DIRECTION = normalize(vec3(0.6, 0.35, 0.5));\n    const vec3 SUN_COLOR = vec3(1.0,0.77,0.6);\n\n    float sun_diffuse = clamp(dot(normal, SUN_DIRECTION), 0.0, 1.0);\n    float sun_shadow = hard_shadow(p, SUN_DIRECTION, 0.01, 20.0);\n    float sun_specular = pow(clamp(dot(reflect(SUN_DIRECTION, normal), raydir), 0.0, 1.0), SUN_SHINESS);\n\n    diffuse += SUN_COLOR * (sun_diffuse * sun_shadow * SUN_INTENSITY);\n    specular += SUN_COLOR * sun_specular;\n\n    // sky light\n    const float SKY_INTENSITY = 1.0;\n    const float SKY_SHINESS = 8.0;\n    const float SKY_BIAS = 0.5;\n    const vec3 SKY_COLOR = vec3(0.50,0.70,1.00);\n    const vec3 SKY_DIRECTION = vec3(0.0, 1.0, 0.0);\n\n    float sky_diffuse = SKY_BIAS + (1.0 - SKY_BIAS)*clamp(dot(normal, SKY_DIRECTION), 0.0, 1.0);\n    float sky_specular = pow(clamp(dot(reflect(SKY_DIRECTION, normal), raydir), 0.0, 1.0), SKY_SHINESS);\n    diffuse += SKY_COLOR * (SKY_INTENSITY * sky_diffuse * occlusion);\n    specular += SKY_COLOR * (sky_specular * occlusion);\n\n    // fake indirect light\n    const float INDIRECT_INTENSITY = 0.2;\n    const float INDIRECT_SHINESS = 8.0;\n    const vec3 INDIRECT_COLOR = SUN_COLOR;\n\n    vec3 ind_dir = normalize(SUN_DIRECTION * vec3(-1.0,0.0,1.0));\n    float ind_diffuse = clamp(dot(normal, ind_dir), 0.0, 1.0);\n    float ind_specular = pow(clamp(dot(reflect(ind_dir, normal), raydir), 0.0, 1.0), INDIRECT_SHINESS);\n    diffuse += INDIRECT_COLOR * (ind_diffuse * INDIRECT_INTENSITY);\n    specular += INDIRECT_COLOR * (ind_specular * INDIRECT_INTENSITY);\n\n    // fresnel light\n    const float FRESNEL_INTENSITY = 2.0;\n    const vec3 FRESNEL_COLOR = SUN_COLOR;\n    float fresnel_diffuse = clamp(1.0+dot(raydir, normal), 0.0, 1.0);\n    diffuse += FRESNEL_COLOR * (FRESNEL_INTENSITY * fresnel_diffuse * (0.5 + 0.5*sun_diffuse));\n    \n    // apply material\n    vec3 col = diffuse * get_material_diffuse(p, material) +\n               specular * get_material_specular(p, material);\n\n    // gamma correction\n    col = pow(col, vec3(0.4545));\n\n    return col;\n}\n\nvec3 get_sky_background(vec3 raydir) {\n    const vec3 SKY_COLOR1 = vec3(0.4,0.75,1.0);\n    const vec3 SKY_COLOR2 = vec3(0.7,0.8,0.9);\n    vec3 col = mix(SKY_COLOR2, SKY_COLOR1, exp(10.0*raydir.y));\n    return col;\n}\n\n// Return camera transform matrix looking from `lookfrom` towards `lookat`, with tilt rotation `tilt`,\n// vertical field of view `vfov` (in degrees), at coords `uv` (in the range [-1,1])\nvec3 get_ray(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n    // camera up vector\n    vec3 vup = vec3(sin(tilt), cos(tilt), 0.0);\n    // camera look direction\n    vec3 lookdir = normalize(lookat - lookfrom);\n    // unit vector in camera x axis\n    vec3 u = cross(lookdir, vup);\n    // unit vector in camera y axis\n    vec3 v = cross(u, lookdir);\n    // vector in camera z axis normalized by the fov\n    vec3 w = lookdir * (1.0 / tan(vfov*M_PI/360.0));\n    // camera transformation matrix\n    mat3 t = mat3(u, v, w);\n    // camera direction\n    return normalize(t * vec3(uv, 1.0));\n}\n\nvec3 render(vec2 uv) {\n    float theta = 10.0*iMouse.x/iResolution.x + iTime;\n    vec3 lookat = vec3(0.0, 1.0, 0.0);\n    vec3 lookfrom = vec3(80.0*sin(theta), 5.0, 80.0*cos(theta));\n    vec3 raydir = get_ray(lookfrom, lookat, 0.0, 30.0, uv);\n    Hit hit = ray_march(lookfrom, raydir);\n    vec3 p = lookfrom + raydir * hit.d;\n    if(hit.material > 0)\n        return get_light(raydir, p, hit.material);\n    else\n        return get_sky_background(raydir);\n}\n\nvec3 render_aa(vec2 uv) {\n#if AA > 1\n    float w = 1.0/iResolution.y;\n    vec3 col = vec3(0.0);\n    for(int n=0; n<AA*AA; ++n) {\n        vec2 o = 2.0*(vec2(float(int(n / AA)),float(int(n % AA))) / float(AA) - 0.5);\n        col += render(uv + o*w);\n    }\n    col /= float(AA*AA);\n    return col;\n#else\n    return render(uv);\n#endif\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) {\n    // uv coords in range from [-1,1] for y and [-aspect_ratio,aspect_ratio] for x\n    vec2 uv = 2.0 * ((fragcoord-0.5*iResolution.xy) / iResolution.y);\n    // render the entire scene\n    vec3 col = render_aa(uv);\n    // set the finished color\n    fragcolor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}