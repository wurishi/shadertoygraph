{"ver":"0.1","info":{"id":"MfdXz8","date":"1714548798","viewed":45,"name":"Stereo imaging","username":"peremoya2000","description":"Hit restart in order to ensure sync. Simple simulation of an audio source orbiting around the listener. Uses panning for lateral angle and applies some attenuation from behind to simulate head shadowing and pinna occlusion.","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["sound","spatial","imaging"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fovzoom = .75;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //Calculate render parameters\n    float ballX = -sin(getEmitterAngle(iTime));\n    float ballZ = cos(getEmitterAngle(iTime));\n    vec3 ball = vec3(ballX,0,ballZ)*5.;\n      \n    vec3 f = vec3(0,0,1),\n    u = vec3(0,1,0),\n    r = normalize(cross(f,u)),\n    sCenter = f*fovzoom,\n    screenPoint = sCenter + uv.x * r + uv.y * u,\n    rayDir = normalize(screenPoint);\n    \n    //Raymarch for sphere\n    vec3 ray;\n    float rayL, rayStep;\n    for (int i=0; i<50; ++i){\n        ray = rayDir * rayL;      \n        rayStep = (length(ball-ray) - 1.);     \n        if(rayStep<.001 || rayStep>100.) break;\n        rayL += rayStep;\n    }\n    \n    vec3 col = vec3(0.);\n    if(rayStep<.001){       \n        //Diffuse lighting\n        vec3 lightDir = vec3(0,0,1);\n        vec3 ballColor = vec3(.1,.8,.4);\n        vec3 normal = normalize(ray-ball);\n        float diffuse = max(dot(normal,-normalize(lightDir)),0.);\n        vec3 reflectionRay = reflect(normalize(lightDir),normal);\n        float specular = pow(max(0.f,dot(-f,reflectionRay)),10.);\n        col=ballColor*.1+(.7*diffuse*ballColor)+specular*.2;        \n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float time )\n{\n    float angle = getEmitterAngle(time);\n    float rightChannel = sin(angle) *.5 + .5;\n    \n    //Slight boost for (rare) cases when the emitter in front can reach both ears without head shadowing\n    float frontAmpBoost = .05*smoothstep(PI-.3,PI,abs(angle-PI));   \n    //Back atenuation\n    float backAtenuation = min(1.,cos(angle)*.6+1.25);\n    \n    float wave = sin(TAU*440.0*time)*(.25+frontAmpBoost)*backAtenuation;\n    \n    return vec2(wave*(1.-rightChannel), wave*rightChannel);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n#define PI 3.14159265359\n\nfloat getEmitterAngle(float time)\n{\n    return mod(time*PI*.5, TAU);\n}","name":"Common","description":"","type":"common"}]}