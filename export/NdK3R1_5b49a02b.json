{"ver":"0.1","info":{"id":"NdK3R1","date":"1631999870","viewed":66,"name":"C-grid","username":"rafastv","description":"Colored grid","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["griddebug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Copyright (c) 2021 Rafael S. T. Vieira\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights  \n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/* RGB2HSV and HSV2RGB were taken from: \n * http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl \n */\n \n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_tiles = 7.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    float x = fragCoord.x/iResolution.y * n_tiles;\n    float y = fragCoord.y/iResolution.y * n_tiles;\n    \n    bool u = (mod(floor(x),2.0) == 1.0);\n    bool v = (mod(floor(y),2.0) == 1.0);\n    // 3-colors\n    vec3 color = vec3(1.0,1.0,0.0);\n    if (u == v)\n    {\n        switch (int(mod(floor(x),4.0)))\n        {\n            case 0: color = vec3(1.0,0.0,0.0); break;\n            case 1: color = vec3(1.0,0.0,0.0); break;\n            case 2: color = vec3(0.0,0.0,1.0); break;\n            case 3: color = vec3(0.0,0.0,1.0); break;\n        }\n        if (((floor(x) == 5.0) && (floor(y) == 3.0)) ||\n            ((floor(x) == 7.0) && (floor(y) == 3.0)) ||\n            ((floor(x) == 6.0) && (floor(y) == 4.0)) ||\n            ((floor(x) == 6.0) && (floor(y) == 2.0)))\n            {\n                color = vec3(0.75,0.5,0.25);\n                float radius = pow(fract(x)*2.0-1.0,2.0) + pow(fract(y)*2.0-1.0,2.0);\n                if (radius < 0.1)\n                    color = vec3(vec2(1.-pow(radius,0.1)),0.0);   \n            }\n    }\n    // border\n    float thickness = 0.125;\n    float cx = step(thickness, fract(x)) * (1.0 - step(1.0-thickness,fract(x)));\n    float cy = step(thickness, fract(y)) * (1.0 - step(1.0-thickness,fract(y)));\n    float bx = smoothstep(0.0,thickness, fract(x)) * (1.0 - smoothstep(1.0-thickness,1.0,fract(x)));\n    float by = smoothstep(0.0,thickness, fract(y)) * (1.0 - smoothstep(1.0-thickness,1.0,fract(y)));\n    float alpha = bx * by;\n    float beta  = cx * cy;\n    color =  color * alpha + vec3(0.5,0.5,0.5) * (1.0-alpha);\n    vec3 color2 = color * beta + vec3(0.25,0.5,0.75) * (1.0-beta);\n    // bw\n    //color = vec3(u == v);\n    // Output to screen\n    vec3 light = normalize(vec3(1.,1.,-1.));\n    vec3 normal = normalize(vec3(dFdx(alpha),dFdy(alpha),0.0) + vec3(0.0,0.0,-1.0));\n    \n    color = color * dot(normal,light);\n    vec3 c_txt = texture(iChannel0, vec2(x,y)).xyz;\n    vec3 c_hsv = rgb2hsv(0.1*c_txt + 0.9*color);\n    //vec3 c_hsv = rgb2hsv(color);\n    c_hsv.y = pow(c_hsv.y, 0.2);  \n    c_hsv.z = pow(c_hsv.z, 0.4);  \n    fragColor = vec4(hsv2rgb(c_hsv),1.0);\n    //fragColor = vec4((1.0+normal)/2.0,1.0);\n    //fhttps://www.shadertoy.com/img/themes/dark/play.pngragColor =  vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}