{"ver":"0.1","info":{"id":"M3K3DR","date":"1717535613","viewed":95,"name":"LiveArchive #02","username":"Flopine","description":"I'm digging up old shaders made during VJ sessions to archive them here! \n\nMicrochic Tuscany 2020","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","transparency","audio","vj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n//Microchic Tuscany 2020\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define ITER 32.\n\n#define time(speed) fract(iTime*speed)\n#define bouncy(ti) sqrt(abs(sin(ti*PI)))\n#define swit(ti) floor(sin(ti*TAU)+1.)\n\n\nstruct obj {\n  float d;\n  vec3 col;\n};\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(32.4, 26.4)))*1467.4);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = mod(atan(p.y,p.x), per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nobj minobj (obj a, obj b)\n{\n  if (a.d<b.d) return a;\n  else return b;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat plane (vec3 p, vec3 n)\n{return dot(p,normalize(n));}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-1.;}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    float dist = min(p.x,min(p.y,p.z));\n    \n    return stmin(sphe(p,1.5),dist,1.5,5.)-d;\n}\n\n\nvec3 palette (float t, vec3 c, vec3 d)\n{return vec3(0.5)+vec3(0.5)*cos(TAU*(c*t+d));}\n\nobj fracplane (vec3 p)\n{\n    p.z -= 5.;\n    p.yz *= rot(time(0.1)*TAU);\n    mo(p.xz, vec2(.5));\n    p.x -= 0.5;\n\n    p.yz *= rot(time(0.1)*TAU);\n    mo(p.yz, vec2(0.1));\n\n    p.xy *= rot(time(0.05)*TAU);  \n    mo(p.xy, vec2(0.2));\n\n    return obj(stmin(plane(p, vec3(0.5,1.,.8)),od(p, 0.1),0.1,5.),palette(length(p.xz),vec3(0.3),vec3(0.5,0.3,0)));\n}\n\nobj grid (vec3 p)\n{\n    p.x += sin(p.y*5.+time(texture(iChannel0, vec2(0.01, .25)).r)*TAU)*0.2;\n    float perz = 15.;  \n    vec3 per = vec3(13.+texture(iChannel0, vec2(0.008, .25)).r*5.,perz,perz);\n\n    p.z += time(0.1)*perz;\n\n    p = mod(p, per)-per*0.5;\n    mo(p.xz,vec2(.2));\n    mo(p.xy,vec2(2.5));\n    float d = sc(p,0.3);\n\n    return obj(d, vec3(0.,0.4,0.5));\n}\n\nobj snakes (vec3 p)\n{\n    p.xy *= rot(p.z*0.1);\n    moda(p.xy, 5.);\n    p.x -= 4.;\n    p.y += sin(p.z+time(0.2)*TAU + texture(iChannel0, vec2(0.001, 0.25)).r);\n    p.x += cos(p.z*0.5);\n    moda(p.xy, 5.);\n    p.x -= 0.5;\n\n    float d = cyl(p,0.05,1e10);\n\n    float per = 2.;\n    p.xy *= rot(time(1.)*TAU);\n    p.z += time(1.)*per;\n    p.z = mod(p.z,per)-per*0.5;\n\n    d = min(d, box(p,vec3(0.2)));\n\n    return obj(d,vec3(1.));\n}\n\nobj SDF (vec3 p)\n{\n    mo(p.xz, vec2(0.5));\n    p.x -= 2.8;\n    p.xy *= rot(p.z*0.05);\n\n    obj d = minobj(grid(p),snakes(p));\n    d = minobj(d,fracplane(p));\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float dither = hash21(uv);\n\n    if (swit(time(.25))>.5) mo(uv,vec2(.1+bouncy(time(0.3))*0.5));\n\n    vec3 ro = vec3(0.001,0.001,-0.4), rd = normalize(vec3(uv,1.+length(uv*.5)));\n    vec3 p = ro, l =  normalize(vec3(1.,2.,-2.)), col = vec3(0.);\n\n    bool hit = false;  \n    float shad, t = 0.;\n    obj O;\n\n    for (float i=0.; i<ITER;i++)\n    {\n        p = ro+t*rd;\n        O = SDF(p);\n        shad = i/ITER;\n\n        O.d = max(abs(O.d*(0.95+dither*0.05)), .005);\n        t += O.d;\n    }\n\n    if (t<=40.)\n    { \n      col = vec3(shad)*O.col;   \n    }\n\n    col = mix(col, vec3(0.012,0.0,0.01),1.-exp(-0.008*t*t));\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(0.4545)),1.0);\n}","name":"Image","description":"","type":"image"}]}