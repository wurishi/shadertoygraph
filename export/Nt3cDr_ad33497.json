{"ver":"0.1","info":{"id":"Nt3cDr","date":"1659542421","viewed":112,"name":"Rotating + scaling grid","username":"ewine","description":"A rotating anti-aliased grid","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid","matrix","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float gridSize = 10.0; //# of rows without transform\nfloat gridP = 0.05;\nvec3 bgColor = vec3(0.0,0.1,0.2);\nvec3 lineColor = vec3(0.3,0.7,0.8);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //-1 to 1 \n    vec2 uv = ( fragCoord - 0.5 * iResolution.xy ) / iResolution.y;\n    \n    //Rotate + scale transform\n    float s = 0.1 + abs(sin(iTime/5.0)) * 2.0;\n    float a = iTime/2.0;\n    uv = mat2(cos(a),-sin(a),sin(a),cos(a)) * s * uv;\n    \n    float modX = fract(uv.x*gridSize);\n    float modY = fract(uv.y*gridSize);\n    \n    //Use more smoothing the more the camera is zoomed out\n    //Prevents lines from being too thin\n    float p = gridP * max(0.1,s);\n    \n    float smoothX = smoothstep(0.0,p,abs(0.5-modX));\n    float smoothY = smoothstep(0.0,p,abs(0.5-modY));\n    \n    vec3 col = mix(lineColor,bgColor, smoothX * smoothY);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}