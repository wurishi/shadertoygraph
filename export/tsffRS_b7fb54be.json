{"ver":"0.1","info":{"id":"tsffRS","date":"1588477762","viewed":109,"name":"Polygonal rainbow","username":"CheersLuv","description":"A shader I made based off https://twitter.com/imlooh/status/1256705676484636672?s=20\nIt's not designed with performance in mind, sorry, just a pretty demonstration","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Displays the image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n\nconst float SWIRL_SPEED = 0.006;\n\nconst float ASPECT = 16.0/9.0;\n\nconst float POLY_Y_RES = 9.0 * 2.0;\nconst float POLY_X_RES = POLY_Y_RES * ASPECT;\n\nconst int BLUR_FACTOR = 2;\nconst int QUAD_FACTOR = 3;\n\nfloat NOISE_ADD = 10.0;\nfloat NOISE_MULT = 0.01;\n\nvec3 colors[] = vec3[](\n\tvec3(245, 152, 157)/255.0,\n    vec3(246, 150, 121)/255.0,\n    vec3(249, 173, 129)/255.0,\n    vec3(253, 198, 137)/255.0,\n    vec3(255, 247, 153)/255.0,\n    vec3(163, 211, 156)/255.0,\n    vec3(122, 204, 200)/255.0,\n    vec3(125, 167, 217)/255.0,\n    vec3(161, 134, 190)/255.0,\n    vec3(244, 154, 193)/255.0\n);\n\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat getAngle(vec2 a, vec2 b){\n    float angle = 0.0;\n    b = a-b;\n    \n    if(b.x < 0.0){\n    \tb *= -1.0;\n        angle += 3.1415;\n    }\n    \n    a = vec2(0.0, 1.0);\n    \n \tfloat dot = dot(a, b);\n    float maga = length(a);\n    float magb = length(b);\n    \n    return (angle +  acos(dot / (maga * magb)))/3.14159265/2.0;\n    \n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Creates the rainbow image\n\nvec4 getTexColor(vec2 uv){\n    \n    int size = colors.length();\n    \n    uv.y += random(uv)/30.0;\n    \n\tint index = (size-1)-(int((uv.y) * float(size))%size);\n    return vec4(colors[index], 1);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = getTexColor(uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Creates the spiral\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float angle = getAngle(vec2(0.5, 0.5), uv);\n    float length = length(vec2(0.5, 0.5) - uv);\n    \n    float x = angle - iTime * SWIRL_SPEED;\n    float y = length*2.0;\n    \n    fragColor = texture(iChannel0, vec2(mod(x, 1.0), mod(x+y, 1.0)));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Blurrs the image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n        \n    float its = float(BLUR_FACTOR);\n    \n    float samples = (its*2.0)+1.0;\n    samples *= samples;\n    for(float i = -its; i <= its; i++){\n        for(float j = -its; j <= its; j++){\n            \n            vec2 uv = fragCoord + vec2(float(i), float(j));\n            color += texture(iChannel0, uv/iResolution.xy)/samples;\n            \n        }\n    }\n    \n    fragColor = color;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// polygonises the image\n\nvec2 getPoint(vec2 quad);\nvec2 getQuadrant(vec2 uv);\n\n\nconst vec2 quadSize = vec2(POLY_X_RES, POLY_Y_RES);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    bool black = false;\n    \n    vec2 quad = getQuadrant(uv);\n    vec2 point = getPoint(quad);\n    float dist = length(uv - point);\n    \n    float its = float(QUAD_FACTOR);\n    \n    for(float i = -its; i <= its; i++){\n        for(float j = -its; j <= its; j++){\n            vec2 newQuad = getQuadrant(quad + (vec2(i, j)/quadSize));\n            vec2 newPoint = getPoint(newQuad);\n            float newDist = length(uv - newPoint);\n\n            if(newDist < 0.002){\n            \t// Draws a black dot at the centre of every polygon\n                //black = true;\n            }\n            \n            if(newDist < dist){\n                point = newPoint;\n                dist = newDist;\n            }   \n            \n            \n            \n        }\n    }\n    \n    \n    vec4 color = texture(iChannel0, point);\n    \n    fragColor = black ? vec4(0.0, 0.0, 0.0, 0.0) : color;\n    //fragColor = black ? color : mix(color, vec4(1.0, 1.0, 1.0, 1.0), 0.3);\n}\n\n\n\n\nvec2 getQuadrant(vec2 uv) {\n    return floor(uv*quadSize) / quadSize;\n}\n\nvec2 getPoint(vec2 uv){\n    \n    float mult = NOISE_ADD;\n    float add = iTime * NOISE_MULT;\n    \n    vec2 quad = getQuadrant(uv);\n    vec2 offset = vec2(snoise(quad.yx*mult+add), snoise(quad.xy*mult+add));\n    offset /= quadSize;\n    \n    return quad + offset;\n   \n}","name":"Buf D","description":"","type":"buffer"}]}