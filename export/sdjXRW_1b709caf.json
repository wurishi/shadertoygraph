{"ver":"0.1","info":{"id":"sdjXRW","date":"1619804832","viewed":180,"name":"Shaded noise","username":"reaxt","description":"Another daily except these arent daily at all anymore.\nHeavily inspired by the upcoming game \"critters for sale\", lots of values you can change here if you want :D\nalso, theres a line commented out,     //image += texture(iChannel1, uv);, it adds a claud\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","beginner","filter","shading","daily"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat greyScale(in vec3 col) {\n    return dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle),cos(angle));\n}\n\nfloat dotScreen(in vec2 uv, in float angle, in float scale) {\n    float s = sin( angle ), c = cos( angle );\n\tvec2 p = (uv - vec2(0.5)) * iResolution.xy;\n    vec2 q = rotate2d(angle) * p * scale; \n\treturn ( sin( q.x ) * sin( q.y ) ) * 4.0;\n}\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat qinticInOut(float t) {\n  return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float shadingPoint1 = 0.4;\n    float shadingValue1 = 0.1;\n    \n    float shadingPoint2 = 0.59;\n    float shadingValue2 = 0.4;\n    \n    float shadingPoint3 = 0.72;\n    float shadingValue3 = 0.6;\n    \n    float shadingPoint4 = 0.79;\n    float shadingValue4 = 0.91;\n    \n    float finalShadeValue = 0.1;\n    \n    vec2 uv2 = fragCoord/iResolution.xy;\n    \n    vec2 uv = uv2;\n    float modAmount = 1.;\n    float diviAmount = 1.;\n    float h = mod(iTime-mod(uv.x+uv.y,uv.x)/diviAmount, modAmount);\n    float h2 = mod(iTime/diviAmount, modAmount);\n    h = abs((h*2.)-modAmount);\n    h2 = abs((h2*2.)-modAmount);\n    float angle = qinticInOut(h);\n    float angle2 = cubicInOut(h2);\n    uv.x += bounceInOut(h)/401.;\n    uv.y -= (h2)/701.;\n    //float angle = 0.5;\n    //angle = rand(vec2(iTime, iFrame));\n    float scale = 2.* ((iResolution.x+iResolution.y)/1115.99999);\n    \n    //the magic noise\n    float noise = (dotScreen(uv+angle/40.,angle2/4., scale));\n    // Normalized pixel coordinates (from 0 to 1)\n\n    // Time varying pixel color\n    vec4 image = texture(iChannel0, uv);\n    //image += texture(iChannel1, uv);\n    vec4 imageSolid = texture(iChannel0, uv2);\n    \n    float averagedcol = (image.x+image.y+image.z)/3.;\n    float solidAveragedCol = (imageSolid.x+imageSolid.y+imageSolid.z);\n    float newcol =0.;\n    vec4 newvec = vec4(0.);\n    if(averagedcol < shadingPoint1) {\n     newvec = vec4(shadingValue1);\n    } else if(averagedcol < shadingPoint2) {\n         newvec = vec4(shadingValue2) /1.;\n\n    } else if(averagedcol < shadingPoint3) {\n     newvec = vec4(shadingValue3+noise ) /1.;\n     \n    } else if(averagedcol < shadingPoint4){\n     newvec = vec4(abs((solidAveragedCol+shadingValue4)-noise));\n    } else {\n     newvec = vec4(finalShadeValue,0.,0.,0.);\n    }\n    \n    float hm = newvec.x;\n\n    \n    // Output to screen\n\n    fragColor = vec4(newvec.z);\n}","name":"Image","description":"","type":"image"}]}