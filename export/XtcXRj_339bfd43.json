{"ver":"0.1","info":{"id":"XtcXRj","date":"1480530195","viewed":195,"name":"smoothed fract","username":"stduhpf","description":"Just an antialiasing trick that works almost only in that case.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","antialiasing","smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed = .1245498;\nvec2 grad(vec2 p){\n        p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n    return fract(seed+sin(p+seed)*43758.5453)-.5;\n        }\nfloat cubic(float x,float a,float da,float b, float db)\n{\n    vec4 abcd = vec4(2.*a-2.*b+da+db,-3.*a+3.*b-2.*da-db,da,a);\n    return x*x*x*abcd.x+x*x*abcd.y+x*abcd.z+abcd.w;\n}\nfloat perlin(vec2 uv) //polynomial interpolated perlin gradient noise (overkill and should be replaced with a classical value noise)\n{\n    vec2 relco = fract(uv);\n    vec2 inco = floor(uv);\n    vec2 grad1 = grad(inco+vec2(-1));\n    vec2 grad2 = grad(inco+vec2(0,-1));\n    vec2 grad3 = grad(inco+vec2(1,-1));\n    vec2 grad4 = grad(inco+vec2(2,-1));\n    vec2 grad5 = grad(inco+vec2(-1,0)); \n    vec2 grad6 = grad(inco+vec2(0));\n    vec2 grad7 = grad(inco+vec2(1,0));\n    vec2 grad8 = grad(inco+vec2(2,0));\n    vec2 grad9 = grad(inco+vec2(-1,1));\n    vec2 gradA = grad(inco+vec2(0,1));\n    vec2 gradB = grad(inco+vec2(1));\n    vec2 gradC = grad(inco+vec2(2,1));\n    vec2 gradD = grad(inco+vec2(-1,2));\n    vec2 gradE = grad(inco+vec2(0,2));\n    vec2 gradF = grad(inco+vec2(1,2));\n    vec2 gradG = grad(inco+vec2(2));\n    float s = dot(grad6,relco);\n    float t = dot(grad7, relco-vec2(1,0));\n    float ds= (t-dot(grad5,relco-vec2(-1,0)))/2.;\n    float dt= (dot(grad8,relco-vec2(2,0))-s)/2.;\n    float u = dot(gradA, relco-vec2(0,1));\n    float v = dot(gradB, relco-1.);\n    float du= (v-dot(grad9,relco-vec2(-1,1)))/2.;\n    float dv= (dot(gradC,relco-vec2(2,1))-u)/2.;\n    float n1 = cubic(relco.x,s,ds,t,dt);\n    float n2 =cubic(relco.x,u,du,v,dv);\n    float ms = dot(grad2,relco-vec2(0,-1));\n    float mt = dot(grad3, relco-vec2(1,-1));\n    float dms= (mt-dot(grad1,relco-vec2(-1)))/2.;\n    float dmt= (dot(grad4,relco-vec2(2,-1))-ms)/2.;\n    float mu = dot(gradE, relco-vec2(0,2));\n    float mv = dot(gradF, relco-vec2(1.,2));\n    float dmu= (mv-dot(gradD,relco-vec2(-1,2)))/2.;\n    float dmv= (dot(gradG,relco-vec2(2,2))-mu)/2.;\n    float dn1 = (n2-cubic(relco.x,ms,dms,mt,dmt))/2.;\n    float dn2 =(cubic(relco.x,mu,dmu,mv,dmv)-n1)/2.;\n    return cubic(relco.y,n1,dn1,n2,dn2);\n}\nfloat fbm(vec2 uv)\n{\n    float n =1.;\n    float r =1.;\n    for (int i =0;i<16;i++)\n    {\n        uv*=2.;\n        uv+=100.;\n        n=mix(n,perlin(uv),r);\n        r*=.25;\n    }\n    return n;\n}\nfloat smoothfract(float a)\n{\n    return fract(a)*pow((cos(fract(a)*acos(-1.)/2.)),.4);\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv =(2.*fragCoord.xy - iResolution.xy)/iResolution.x;\n    uv*=5.;\n    float k=1.5; //brigntness factor\n    float n=15.*perlin(uv); //replace with fbm for multiple octaves\n\tfragColor = vec4(fragCoord.x>iMouse.x?k*smoothfract(n):fract(n));\n}","name":"Image","description":"","type":"image"}]}