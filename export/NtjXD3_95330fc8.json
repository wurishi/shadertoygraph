{"ver":"0.1","info":{"id":"NtjXD3","date":"1628777920","viewed":51,"name":"To YuanXiao","username":"mengxin","description":"Just A Gift","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gift"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define float3 vec3\n#define half float\n#define PI 3.1415926\n\n// G( v; u,L,a ) = a * exp( L * (dot(u,v) - 1) )\n\nfloat rsqrt(float x)\n{\n    return 1.0/sqrt(x);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x,0.0,1.0);\n}\n\nfloat rcp(float x)\n{\n    return 1.0/x;\n}\n\nfloat Pow2(float x)\n{\n    return x*x;\n}\n\nstruct FSphericalGaussian\n{\n\tfloat3\tAxis;\t\t// u\n\tfloat\tSharpness;\t// L\n\tfloat\tAmplitude;\t// a\n};\n\nfloat Evaluate( FSphericalGaussian G, float3 Direction )\n{\n\t// G( v; u,L,a ) = a * exp( L * (dot(u,v) - 1) )\n\n\treturn G.Amplitude * exp( G.Sharpness * (dot( G.Axis, Direction ) - 1.0) );\n}\n\n// Integral over the sphere\nfloat Integral( FSphericalGaussian G )\n{\n\t// integral G  = 2*PI * a/L * ( 1 - exp(-2*L) )\n\t// integral G ~= 2*PI * a/L, L > 2\n\n\treturn (2.0*PI) * G.Amplitude / G.Sharpness * ( 1.0 - exp( -2.0 * G.Sharpness ) );\n}\n\n// G / integral G\nFSphericalGaussian Normalize( FSphericalGaussian G )\n{\n\t// G / integral G  = G( v; u, L, L / ( 2*PI * ( 1 - exp(-2*L) ) ) )\n\t// G / integral G ~= G( v; u, L, L / (2*PI) ), L > 2\n\n\tG.Amplitude = G.Sharpness / ( (2.0*PI) - (2.0*PI) * exp( -2.0 * G.Sharpness ) );\n\treturn G;\n}\n\n// G0 * G1\nFSphericalGaussian Mul( FSphericalGaussian G0, FSphericalGaussian G1 )\n{\n\t// um = L0 * u0 + L1 * u1\n\t// G0 * G1 = G( v; um / |um|, |um|, a0*a1 * exp( |um| - L0 - L1 ) )\n\n\tfloat  Lm = G0.Sharpness + G1.Sharpness;\n\tfloat3 um = G0.Sharpness * G0.Axis + G1.Sharpness * G1.Axis;\n\tfloat  umLength = length(um);\n\n\tFSphericalGaussian G ;\n\t//{\n\t//\tum / umLength,\n\t//\tumLength,\n\t//\tG0.Amplitude * G1.Amplitude * exp( umLength - Lm )\n\t//};\n\n\treturn G;\n}\n\n// integral G0 * G1\nfloat Dot( FSphericalGaussian G0, FSphericalGaussian G1 )\n{\n\t// integral G0 * G1  = 4*PI * a0 * a1 * exp( -L0 - L1 ) * sinh( |um| ) / |um|\n\t// integral G0 * G1  = 2*PI * a0 * a1 * ( exp( |um| - L0 - L1 ) - exp( -|um| - L0 - L1 ) ) / |um|\n\t// integral G0 * G1 ~= 2*PI * a0 * a1 * exp( |um| - L0 - L1 ) / |um|\n\t\n\tfloat  Lm = G0.Sharpness + G1.Sharpness;\n\tfloat3 um = G0.Sharpness * G0.Axis + G1.Sharpness * G1.Axis;\n\tfloat  umLength = length(um);\n\n\t//return 2*PI * G0.a * G1.a * ( exp( umLength - G0.L - G1.L ) ) / umLength;\n\t//return 2*PI * G0.Amplitude * G1.Amplitude * ( exp( umLength - Lm ) - exp( -umLength - Lm ) ) / umLength;\n\treturn (2.0*PI) * G0.Amplitude * G1.Amplitude * exp( umLength - Lm ) * ( 1.0 - exp( -2.0 * umLength ) ) / umLength;\n}\n\n// [ Iwasaki 2012, \"Interactive Bi-scale Editing of Highly Glossy Materials\" ]\nFSphericalGaussian Convolve( FSphericalGaussian G0, FSphericalGaussian G1 )\n{\n\tFSphericalGaussian G;// =\n\t//{\n\t//\tG0.Axis,\n\t\t//( G0.Sharpness * G1.Sharpness ) / ( G0.Sharpness + G1.Sharpness ),\n\t\t//(2*PI) * ( G0.Amplitude * G1.Amplitude ) / ( G0.Sharpness + G1.Sharpness )\n\t//};\n\n\treturn G;\n}\n\n// approximation using von Mises-Fisher\nFSphericalGaussian ToSphericalGaussian( float3 r, float Value )\n{\n\t// L = |r| * ( 3 - |r|^2 ) / ( 1 - |r|^2 )\n\n\tFSphericalGaussian G;\n\n\tfloat LengthR2 = dot( r, r );\n\tfloat InvLengthR = rsqrt( LengthR2 );\n\tfloat LengthR = LengthR2 * InvLengthR;\n\n\tG.Axis = r * InvLengthR;\n\tG.Sharpness = LengthR * ( 3.0 - LengthR2 ) / ( 1.0 - min( LengthR2, 0.9999 ) );\n\tG.Amplitude = Value * G.Sharpness / ( (2.0*PI) - (2.0*PI) * exp( -2.0 * G.Sharpness ) );\n\t//G.u = Value * G.L * (0.5/PI);\n\n\treturn G;\n}\n\nFSphericalGaussian Add( FSphericalGaussian G0, FSphericalGaussian G1 )\n{\n\t// r  = ( 1 / tanh(L) - 1/L ) * u\n\t// r  = ( ( 1 + exp( -2*L ) ) / ( 1 - exp( -2*L ) ) - 1/L ) * u\n\t// r ~= ( 1 - 1/L + 2 * exp( -2*L ) ) * u, L > 2\n\n\tfloat exp2L0 = exp( -2.0 * G0.Sharpness );\n\tfloat exp2L1 = exp( -2.0 * G1.Sharpness );\n\n\tfloat3 r0 = ( (1.0 + exp2L0) / (1.0 - exp2L0) - rcp( G0.Sharpness ) ) * G0.Axis;\n\tfloat3 r1 = ( (1.0 + exp2L1) / (1.0 - exp2L1) - rcp( G1.Sharpness ) ) * G1.Axis;\n\tfloat w0 = Integral( G0 );\n\tfloat w1 = Integral( G1 );\n\n\tfloat3 r = ( r0*w0 + r1*w1 ) / (w0 + w1);\n\tfloat w = w0 + w1;\n\n\treturn ToSphericalGaussian( r, w );\n}\n\n// Angle from axis of cone. Half subtended angle.\nfloat GetConeAngle( FSphericalGaussian G )\n{\n\t// cone angle ~= PI - PI*|r|\n\t// r = ( 1 / tanh(k) - 1/k ) * u ~= ( 1 - 1/k + 2 * exp( -2*k ) ) * u, k > 2\n\t// ConeAngle ~= sqrt( 2/L )\n\n\treturn sqrt( 2.0 / G.Sharpness );\n}\n\n// Inner product with cosine lobe\n// Assumes G is normalized\nfloat DotCosineLobe( FSphericalGaussian G, float3 N )\n{\n\t float muDotN = dot( G.Axis, N );\n\n\tconst float c0 = 0.36;\n\tconst float c1 = 0.25 / c0;\n\n\tfloat eml  = exp( -G.Sharpness );\n\tfloat em2l = eml * eml;\n\tfloat rl   = rcp( G.Sharpness );\n \n\tfloat scale = 1.0f + 2.0f * em2l - rl;\n\tfloat bias  = (eml - em2l) * rl - em2l;\n\n\tfloat x = sqrt( 1.0 - scale );\n\tfloat x0 = c0 * muDotN;\n\tfloat x1 = c1 * x;\n\n\tfloat n = x0 + x1;\n\tfloat y = ( abs( x0 ) <= x1 ) ? n*n / x : saturate( muDotN );\n\n\treturn scale * y + bias;\n}\n\nFSphericalGaussian MakeNormalizedSG(float3 LightDir, half Sharpness)\n{\n\tFSphericalGaussian SG;\n\tSG.Axis = LightDir;\n\tSG.Sharpness = Sharpness;\n\tSG.Amplitude = SG.Sharpness / ((2.0 * PI) * (1.0 - exp(-2.0 * SG.Sharpness)));\n\treturn SG;\n}\n\nvec3 SGDiffuseLighting(float3 N, float3 L, vec3 ScatterAmt)\n{\n\tFSphericalGaussian RedKernel = MakeNormalizedSG(L,1.0/(max(ScatterAmt.x, 0.0001f)));\n\tFSphericalGaussian GreenKernel = MakeNormalizedSG(L,1.0/(max(ScatterAmt.y, 0.0001f)));\n\tFSphericalGaussian BlueKernel = MakeNormalizedSG(L,1.0/(max(ScatterAmt.z, 0.0001f)));\n\n\tvec3 Diffuse = vec3(DotCosineLobe(RedKernel, N),DotCosineLobe(GreenKernel,N),DotCosineLobe(BlueKernel, N));\n\treturn Diffuse;\n\n}\n\n// [ Wang et al. 2009, \"All-Frequency Rendering of Dynamic, Spatially-Varying Reflectance\" ]\nFSphericalGaussian ClampedCosine_ToSphericalGaussian( float3 Normal )\n{\n\tFSphericalGaussian G;\n\t\n\tG.Axis = Normal;\n\tG.Sharpness = 2.133;\n\tG.Amplitude = 1.17;\n\n\t// Integrate to PI\n\t//G.Sharpness = 2.3;\n\t//G.Amplitude = 0.5 * 2.3 / ( 1 - exp( -2 * 2.3 ) );\n\n\treturn G;\n}\n\nFSphericalGaussian Hemisphere_ToSphericalGaussian( float3 Normal )\n{\n\tFSphericalGaussian G;\n\t\n\tG.Axis = Normal;\n\tG.Sharpness = 0.81;\n\tG.Amplitude = 0.81 / ( 1.0 - exp( -2.0 * 0.81 ) );\n\n\treturn G;\n}\n\n// Bent normal is normalized. AO is [0,1]. Both are cosine weighted.\nFSphericalGaussian BentNormalAO_ToSphericalGaussian( float3 BentNormal, float AO )\n{\n\t// ConeAngle ~= sqrt( 2/L )\n\t// L ~= 2/ConeAngle^2\n\n\tFSphericalGaussian G;\n\t\n\tG.Axis = BentNormal;\n\n#if 1\n\t// Cosine weighted integration of spherical cap\n\t// PI * SinAlpha^2\n\t// L ~= 2 / Pow2( acos( sqrt(1- AO) ) );\n\n\t// Approximation (no acos)\n\tG.Sharpness = ( 0.75 + 1.25 * sqrt( 1.0 - AO ) ) / AO;\n#else\n\t// Solid angle of cone = 2 * PI * (1 - CosTheta)\n\t// Solid angle of cone = 2*PI * AO\n\t// AO = 1 - cos( ConeAngle )\n\t// L ~= 2 / Pow2( acos( 1- AO ) );\n\t\n\t// Approximation (no acos)\n\tG.Sharpness = ( 1 - 0.19 * AO ) / AO;\n#endif\n\t\n\t// AO=1 integrates to 2pi\n\tconst float HemisphereSharpness = 0.81;\n\tG.Amplitude = HemisphereSharpness / ( 1.0 - exp( -2.0 * HemisphereSharpness ) );\n\n\treturn G;\n}\n\n/*\nstatic const float C[5] =\n{\n\t0.5 / sqrt(PI),\n\t0.5 * sqrt(3/PI),\n};\n\nstruct FSphericalHarmonics\n{\n\tfloat\tSH[4];\n};\n\nFSphericalHarmonics Add( float3 Direction, float Value )\n{\n}*/\n\nstruct FAnisoSphericalGaussian\n{\n\tfloat3\tAxisX;\n\tfloat3\tAxisY;\n\tfloat3\tAxisZ;\n\tfloat\tSharpnessX;\n\tfloat\tSharpnessY;\n\tfloat\tAmplitude;\n};\n\nfloat Evaluate( FAnisoSphericalGaussian ASG, float3 Direction )\n{\n\tfloat L = ASG.SharpnessX * Pow2( dot( Direction, ASG.AxisX ) );\n\tfloat u = ASG.SharpnessY * Pow2( dot( Direction, ASG.AxisY ) );\n\treturn ASG.Amplitude * saturate( dot( Direction, ASG.AxisZ ) ) * exp( -L - u );\n}\n\nfloat Dot( FAnisoSphericalGaussian ASG, FSphericalGaussian SG )\n{\n\t// ASG( v; u,nu,a ) = a * exp( 2 * nu * (dot(u,v) - 1) )\n\n\tfloat nu = SG.Sharpness * 0.5;\n\n\tASG.Amplitude *= SG.Amplitude;\n\tASG.Amplitude *= PI * rsqrt( (nu + ASG.SharpnessX) * (nu + ASG.SharpnessY) );\n\tASG.SharpnessX = (nu * ASG.SharpnessX) / (nu + ASG.SharpnessX);\n\tASG.SharpnessY = (nu * ASG.SharpnessY) / (nu + ASG.SharpnessY);\n\n\treturn Evaluate( ASG, SG.Axis );\n}\n\n\n\n\nfloat3 ACESToneMapping(float3 color, float adapted_lum)\n{\n\tconst float A = 2.51f;\n\tconst float B = 0.03f;\n\tconst float C = 2.43f;\n\tconst float D = 0.59f;\n\tconst float E = 0.14f;\n\n\tcolor *= adapted_lum;\n\treturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n// ray marching\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01;\nconst float grad_step = 0.01;\nconst float clip_far = 10.0;\n\n// math\n//const float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// distance function\n\nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat sdPetal(vec3 p, float s) {\n    p = p * vec3(0.8, 1.5, 0.8) + vec3(0.1, 0.0, 0.0);\n    vec2 q = vec2(length(p.xz), p.y);\n    \n    float lower = length(q) - 1.0;\n    lower = opS(length(q) - 0.97, lower);\n    lower = opI(lower, q.y);\n    \n    float upper = length((q - vec2(s, 0)) * vec2(1.1, 1.0)) +1.0 - s;\n    upper = opS(upper, length((q - vec2(s, 0)) * vec2(1, 1)) + 0.97 - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0);\n    \n    float region = length(p - vec3(1.0, 0.0, 0.0)) - 1.0;\n\n    return opI(opU(upper, lower), region);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0, s = 2.0;\n    mat3 r = rotationXY(vec2(0.1, PI2 * 0.618034));\n    r = r * mat3(1.08,0.0,0.0 ,0.0,0.995,0.0, 0.0,0.0,1.08);\n    for (int i = 0; i < 21; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, -0.02, 0.0);\n        s *= 1.05;\n    }\n    return d;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ) - map( pos - dx ),\n\t\t\tmap( pos + dy ) - map( pos - dy ),\n\t\t\tmap( pos + dz ) - map( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = map( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.3;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nconst vec3 light_pos = vec3( 20.0, 50.0, 20.0 );\nconst vec3 l = normalize(vec3(0,1.0,-0.5));\nconst float intensity = 10.0;\nconst vec3 ambient = vec3(0,0,0.1);\nconst vec3 HighCol = vec3(253.0/255.0,0.0/255.0,6.0/255.0);\nconst vec3 LowCol = vec3(0.0/255.0,0.0/255.0,0.0/255.0);\nconst vec3 RimCol = vec3(254.0/255.0,255.0/255.0,255.0/255.0);\n\nvec3 shading(vec3 v, vec3 n, vec3 eye) {\n\tvec3 ev = normalize(v - eye);\n    vec3 mat_color = vec3(0.65,0.1,0.1);\n \n    vec3 vl = normalize(light_pos - v);\n    \n    float dif = intensity*max(0.0,dot(n,vl)) ;\n    \n    vec3 diffuse = vec3(0,0,0);\n    \n    if(dif > 0.5)\n    {\n        diffuse += HighCol;\n    }\n    else\n    {\n        diffuse += LowCol;\n    }\n    \n    //vec3 diffuse = intensity*max(0,dot(n.l)) ;\n    vec3 h = normalize(vl - ev);\n    float rim = pow(1.0 - max(dot(n, -ev), 0.0), 2.0) * 0.15;\n    \n    if(rim > 0.09)\n    {\n        diffuse += RimCol;\n    }\n    \n    float ao = clamp(v.y * 0.5 + 0.5, 0.0, 1.0);\n    \n    if(ao<0.2)\n    {\n        diffuse *= 0.0;\n    }\n    \n    return diffuse;// mat_color * diffuse + (ambient + rim * vec3(1.0,1.0,1.0)) * ao;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir(45.0, iResolution.xy, fragCoord.xy);\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 5.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY(vec2(-1.0, 1.0));\n    if (iMouse.x > 0.0)\n\t\trot = rotationXY(iMouse.yx / iResolution.yx * vec2(PI, -2.0 * PI) + vec2(PI * -0.5, PI));\n    \n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching(eye, dir, 0.0, clip_far);\n    vec3 pos = eye + dir * depth;\n    vec3 c;\n    if (depth >= clip_far) {\n\t\tc = vec3(0.2, 0.0, 0.1);\n    }\n    else {\n        // shading\n        vec3 n = gradient( pos );\n        c = shading(pos, n, eye);\n    }\n    \n    c = ACESToneMapping(c,0.8);\n    \n    float r = 1.2 - length((fragCoord.xy / iResolution.xy) - 0.5) * 1.0;\n    fragColor = vec4(c * r, 1.0);\n}","name":"Image","description":"","type":"image"}]}