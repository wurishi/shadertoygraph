{"ver":"0.1","info":{"id":"Xsjyzy","date":"1492607354","viewed":109,"name":"Impending Doom","username":"gilesruscoe","description":"Urghaghghhgh","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarchblobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    \n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEP 200 //Maximum raymarch loop iterations  \n#define MAX_DIST 50.0 //Max distance before it is assumed the ray hit nothing\n#define EPSILON  0.015 //Minimum distance\n\nvec3 map(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n\treturn q;\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n//Sphere distance function\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n//Smooth polynominal min function, smoothly joins objects\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat spiral(vec2 uv)\n{\n    vec4 c = vec4(uv.x, uv.y, 0.0, 1.0);\n    \n    float the = iTime * 2.0;\n    //rotation matrix for xy\n    float r = length(uv) * 5.0;\n    float ct = cos(the - r);\n    float st = sin(the - r);\n    \n    c.xy *= mat2(ct, -st, st, ct);\n    \n    float n = noise(mod(vec3(c.xyz * 15.0), 15.0)) * 1.5;\n    return n;\n}\n\n//Distance function\nfloat distfunc(vec3 pos)\n{\n    float n = noise(pos * 2.f - 1.0) * 0.25;\n    pos += n;\n    pos.z += iTime;\n    \n    float the = iTime * 0.5;\n    //rotation matrix for xy\n    float ct = cos(the + pos.z * 0.5);\n    float st = sin(the + pos.z * 0.5);\n    \n    pos.xy *= mat2(ct, -st, st, ct);\n    \n    float t = iTime * 0.5;\n    \n    float ft = fract(t) * 0.8;\n    float ft2 = fract(t + 0.5) * 0.8;\n    float ftm = abs(fract(t) * 2.0 - 1.0);\n    float s0 = mix(ft, ft2, ftm);\n    pos.xy *= spiral(pos.xy * s0);\n    \n    pos = map(pos);\n    float s = sphere(pos * 0.27, abs(sin(iTime * 0.5 + n * 10.0)) * 0.22 + 0.05);\n    return s;\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy) * 0.35;\n    /////SCENE SETUP/////\n    //Uv coordinates in -1 to 1 space\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    //Aspect ratio correction\n    uv.x *= iResolution.x / iResolution.y;\n    //Camera Position with some tilting animation\n    vec3 cameraOrigin = vec3(0.01, 0.01, 4.0);\n    //Camera Target\n    vec3 cameraTarget = vec3(0.0);\n    //World Up Direction\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    //Camera Direction\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    //Camera Right Direction\n    vec3 cameraRight = normalize(cross(upDirection, cameraDir));\n    //Camera Up Direction\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    //Ray Direction\n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y+ cameraDir);\n    \n    /////RAY MARCHING////\n    //How far the ray has travelled so far\n    float totalDist = 0.0;\n    float dist = EPSILON;\n    //Point to start at\n    vec3 pos = cameraOrigin;\n    \n    for(int i = 0; i < MAX_STEP; i++)\n    {\n        //If the object has been hit or the ray has gone out of bounds, break.\n        if(dist < EPSILON || totalDist > MAX_DIST)\n            break;\n        //Evaluate the distance at current point using a distance function\n        dist = distfunc(pos);\n        //Progress the total distance covered\n        totalDist += dist;\n        //Progress the point along the ray vector by the distance travelled\n        pos += dist * rayDir;\n    }\n    \n    \n    /////Lighting/////\n    //Check if object was hit\n    if(dist < EPSILON)\n    {\n        //Calculate the surface normal by sampling fragments of EPSILON distance from this fragment \n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n        \tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n        //NDotL lighting, assuming the light source is the camera\n        float brightness = 1.5;\n        vec3 lightSource = normalize(vec3(0.0, 0.0, 15.0)) * brightness;\n        float diffuse = max(0.0, dot(lightSource, normal));\n        vec3 baseColor = vec3(0.46, 0.21, 0.45);\n        vec3 baseColor2 = vec3(0.8, 0.22, 0.15);\n        \n        float fresnel = pow(clamp(dot(normal, cameraDir), 0.0, 1.0), 0.75);\n        vec3 result = mix(baseColor, baseColor2, diffuse) + vec3(fresnel);\n        \n        //fog\n        result = mix(vec3(0.5, 0.15, 0.15), result, clamp((pos.z * 0.5) + 0.25, 0.0, 1.0));\n        \n        //Final frag result\n\t\tfragColor += vec4(result, 1.0) * 0.75;\n        \n    }\n    //If not hit, use background colour\n    else\n    {\n        fragColor = vec4(0.5, 0.15, 0.15, 0.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}