{"ver":"0.1","info":{"id":"4fS3Rh","date":"1703897517","viewed":101,"name":"WFC Key Dungeon 2D","username":"spalmer","description":"prototype for idea suggested by ollj:\na procedural map (wavefunctioncollapse 'dungeon' in this case) that has 3 (color coded) keys that fit 3 locked doors.\nSo far it's just 2D prototype.  Flat 1-level map.  ESDF+arrows.\nWIP, still has few bugs.","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["procedural","2d","game","key","dungeon","door","lock","wfc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by spalmer 2023\n\n// see 3D version http://shadertoy.com/view/4cB3DR\n\n// try ESDF or arrows to move\n// spacebar or mouse for map\n// backspace or escape if you get really stuck\n\n// riffing on an idea ollj suggested in a comment somewhere\n// that has stuck with me:  random dungeon with keys to\n// locked doors!  Now, this *should* be fairly interesting,\n// compared to simple 'maze' or whatever.  More fun!\n// So idk absolute best way to proceed, might try few things.\n// But the initial idea for this toy is to take ollj's idea,\n// generate 3 key locations (R,G,B) maybe keycode can be\n// some rgb bitmask here, to support more keys in future.\n// but plan on only using 3 of them for now.\n// Probably generate using WFC wavefunctioncollapse algorithm.\n// That seems to do well with these sort of problems.\n// My plan is to place the keys (& locks?) in a way that the dungeon\n// generates outwardly from the keys (& locks).\n// There will be constraints that navigable floorspace\n// may only be connected by similarly color-coded paths.\n// and such paths can only connect to other colors at the\n// corresponding lock which joins those colors.\n// I have more ideas about the toy.  I would like there\n// to be at least two, possibly four, layers to the dungeon,\n// connected by stairs.  Extra confusing.  Muwahahah.\n// not simply color coding the layers, though.\n// perhaps keys might be distributed through the layers somehow.\n// just having the floors isolated just seems weak.\n\n// Should also be first-person traversable eventually.\n// so far it's just 2D prototype.\n\n// I've seen some really cool WFC examples so should be able to \n// make some interesting sort of dungeon to explore.\n\n// can start with something like Crumby Maze or maybe\n// Plumbing Maze but probably need 3D toy.  Walk Camera maybe.\n// Hedges Maze.  I did lots of early maze toys, some never\n// saw light of day.  Walk Camera is probably furthest along.\n// Still needs work on the collision though.\n\n// So would need a buffer for the player camera controls,\n// a buffer for the dungeon, an 'image' tab to show it all.\n// could render offscreen and use postprocessing, probably good idea,\n// to use something to make fullscreen performant.  Like upscaling from\n// Lights, Camera, Action!\n// the player must keep track of which keys have been obtained!\n\n// the WFC toy I extracted from Fenix' circuit board is here:\n// http://shadertoy.com/view/csjSDR\n// but idk if I want to use any of that code; \n// I think I can simplify it down if I just start from scratch.\n// recently had some minor success over at http://shadertoy.com/view/lfX3RS (still private) also.\n\n// this one will have a much more complicated tileset,\n// with 3D connectivity, walls and floors that have color coding,\n// doors (some locked!) and flights of stairs.\n// doors must switch from 'locked' to 'unlocked'/'open' state.\n\n// Ideally would utilize some sort of stacking of 'bricks' like\n// http://shadertoy.com/view/7tVBWw (private) for the rendering of walls/floors.\n// and it seems a good idea to do some sort of ray-voxel DDA\n// traversal to trace the scene, maybe start with http://shadertoy.com/view/wdsfWn\n\n// idk how I'll manage to get the player to wait for the dungeon\n// to be fully constructed before allowing exploration;\n// it might actually take a while to settle down, judging\n// from what I've seen of WFC toys so far.\n// might let one play while it builds, just prevent somehow\n// from going near any 'invalid' areas.  (give them large blocking bounds)\n// (scan for them fairly long range, several tiles worth at least)\n// rn if you go there you'll probably go into limbo or get launched!\n\n// now obviously that's a lot for just one toy, and several parts are fairly complicated.\n// probably should divide this up into phases for implementation.\n\n// phase one:  the basic WFC, test out multiple colors generation\n// phase two:  make it 3D\n// phase three:  render it in 3D\n// phase four:  first person traversal\n// phase five:  gameplay, UI, polish\n\n// ok I screwed up and implemented phase one, then five, in 2D, before any of the others.\n\nfloat march(vec2 ro, vec2 rd, float maxt, int nstep)\n{\n    float t, h = maxt;\n    for (; t < maxt && --nstep > 0 && h > 1e-3; ) {\n        vec2 p = t * rd + ro;\n        Tile tilehere = LoadTile(iChannel0, iChannelResolution[0].xy, ivec2(p)); //, 0);\n        vec2 q = fract(p);\n        q = q - .5;\n        h = Distance(tilehere, q);\n        // TODO must limit to current cell (just past boundary) \n        // since that's the only info Distance checked, and it may overestimate otherwise\n        // just living w the artifacts for now since it gives \n        // the shadows a jaggedy kind of appeal\n        t += max(h, 1e-3);\n    }\n    return t;\n}\n\n\nvec3 Render(vec2 fc, vec2 rz)\n{\n    float aa = min(rz.x, rz.y);\n    aa /= 8.; // scale\n    if (iMouse.z > 0.) aa /= 3.;\n    bool overview = texelFetch(iChannel3, ivec2(32,2), 0).x > .5; // spacebar toggle\n    if (overview) aa = 3.; // spacebar = overview (tiny cells)\n    vec4 gamestate = texelFetch(iChannel0, ivec2(0), 0);\n    vec3 playerpos = gamestate.xyz;\n    int haskeys = int(gamestate.w);\n    vec2 q = fc;\n    q -= rz/2.;\n    vec4    ui = vec4(0);\n    ui = mix(ui, vec4(vec3(1,0,0) * float((haskeys >> 0) & 1), 1), clamp(.5 - (length(q - vec2(-.53, .3) * rz) - rz.y*.14), 0., 1.));\n    ui = mix(ui, vec4(vec3(0,1,0) * float((haskeys >> 1) & 1), 1), clamp(.5 - (length(q - vec2(-.53, .0) * rz) - rz.y*.14), 0., 1.));\n    ui = mix(ui, vec4(vec3(0,0,1) * float((haskeys >> 2) & 1), 1), clamp(.5 - (length(q - vec2(-.53,-.3) * rz) - rz.y*.14), 0., 1.));\n    q /= aa;\n    q += playerpos.xz;\n    if (iMouse.z > 0.) q += (4. * (iMouse.xy - 0.*rz/2.) - rz) / aa;\n    vec2 i = floor(q), f = q - i;\n    Tile tile = LoadTile(iChannel0, iChannelResolution[0].xy, ivec2(i)); //, 0);\n    vec3 c = DrawTile(tile, f, aa);\n    if (iMouse.z <= 0. && !overview) {\n        if (!isSeed(tile.def)) { // keys and doors glow in the dark (no GI yet tho)\n            // march some shadow rays to like a player-held lamp light\n            vec2 top = q - playerpos.xz; float tol = length(top);\n            top /= tol; // top = normalize(top);\n            float shadow = clamp(march(playerpos.xz, top, tol, min(0, iFrame) + 32) / (tol + .01), 0., 1.); \n            shadow = mix(pow(shadow, 2.), 1., .01); // ambient (otherwise scrolling w mouse useless)\n            shadow *= exp2(-.7*tol);\n            // TODO would be great to generate some light sources once we get any kind of lighting\n            c *= shadow;\n            // 'light' gradient of iChannel2 bricks\n            vec2 uv = q * .6873;\n            float x = texture(iChannel2, uv).r - texture(iChannel2, uv + .02 * top).r;\n            x += texture(iChannel2, uv * 1.7).r - texture(iChannel2, uv * 1.7 + .02 * top).r;\n            c *= clamp(mix(x * -4., 1., .7), .5, 1.);\n        }\n    }\n    c = mix(c, vec3(.4), clamp(.5 - aa * (length(q - playerpos.xz) - playerradius), 0., 1.));\n    c = mix(c, ui.rgb, ui.a);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 c = Render(fragCoord, iResolution.xy);\n    fragColor = vec4(sqrt(c), 1); // OETF\n    fragColor.rgb += (texelFetch(iChannel1, ivec2(fragCoord) & ivec2(iChannelResolution[1].xy-1.), 0).x - .5) / 128.; // bluenoise dither\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool Match(ivec3 a, ivec3 b)\n{\n    //return a.y == b.y; // ignore the corners, only check edges\n    //return a == b.zyx;\n    return (a & 1) == (b.zyx & 1); // ignore door flag\n}\n\nbool Fits(Tile c, in Tile[4] n)\n{\n    if (c.def == tBlank || c.def == tInvalid)\n        return false;\n    //if (c.def == tDeadEnd || c.def == tBars) \n    //    return false; // HACK exclude whichever tile,\n        // but dead ends break the connectivity of the game way too frequently.\n        // some might prefer the maze without bars, as it was originally.\n        // they're fairly chaotically placed.\n    bool r = true, anyconnectionvalid = false;\n    // prevent spontaneously generates cells with 'new' colors\n    // just, whereever it's allowed to on far side of walls.\n    // the colors must flood fill from existing colors, not just be 'made up'\n    // so now we check anyconnectionvalid\n    for (int j = 0; j < 4; ++j) {\n        Tile nj = n[j];\n        if (nj.def == tInvalid || nj.def == tBlank) \n            continue; // ignore these\n        ivec3 ec = Edge(c.def, j + c.rot), en = Edge(nj.def, j + nj.rot + 2);\n        if (!Match(ec, en)) {\n            r = false;\n            break;\n        }\n        if (c.def == tDoorLock || c.def == tDoorOpen) {\n            // doors have different color connectivity constraints,\n            // allow 1 color higher on one side\n            if (ec.y == 2) { // side with door connects to next area\n                if (nj.col != (c.col == 4 ? 7 : (c.col << 1))) {\n                    r = false;\n                    break;\n                } else anyconnectionvalid = true;\n            }\n            else if (ec.y == 0) {\n            // locked side neighbor must be the same color\n                if (c.col != nj.col) {\n                    r = false;\n                    break;\n                } else anyconnectionvalid = true;\n            }\n        } else { \n            // don't care about where walls are, but where floors connect,\n            if (ec.y == 0) {\n                // the neighbor must be the same color\n                // unless it's a door!\n                if (en.y == 2) {\n                    if (c.col <= nj.col) {\n                        r = false;\n                        break;\n                    }\n                    else anyconnectionvalid = true;\n                } else\n                if (c.col != nj.col) {\n                    r = false;\n                    break;\n                } else anyconnectionvalid = true;\n            }\n        }\n        // if we can't determine a color because there's no connectivity,\n        // should not really be placing this tile anyway, so just say doesn't fit.\n    }\n    if (!anyconnectionvalid)\n        return false;\n    return r;\n}\n\nTile LoadTile(ivec2 p)\n{\n    Tile t = FromFloat(texelFetch(iChannel0, p, 0).x);\n    if (!all(lessThan(uvec2(p), uvec2(MazeSize(iChannelResolution[0].xy))))) t.def = tSolid;\n    if (all(lessThan(uvec2(p), uvec2(1)))) t.def = tSolid; // pretend state pixel is solid so it gets walled in\n    return t;\n}\n\nvoid WaveFunctionCollapse(inout Tile t, ivec2 i) //, int l)\n{\n    if (isSeed(t.def))\n        return; // can't change it!\n    uint h = hash(uint((i.x + 71*i.y)/*^l*/^iFrame*777^int(iDate.w)));\n    // load neighbor tiles\n    Tile n[4]; // TODO [6] also vertical!\n    n[0] = LoadTile(iChannel0, iChannelResolution[0].xy, i + ivec2(-1,0)); //, l);\n    n[1] = LoadTile(iChannel0, iChannelResolution[0].xy, i + ivec2(0, 1)); //, l);\n    n[2] = LoadTile(iChannel0, iChannelResolution[0].xy, i + ivec2( 1,0)); //, l);\n    n[3] = LoadTile(iChannel0, iChannelResolution[0].xy, i + ivec2(0,-1)); //, l);\n    \n    if (n[0].def == tInvalid \n     || n[1].def == tInvalid \n     || n[2].def == tInvalid \n     || n[3].def == tInvalid)\n             if (~h*17u >  232333771u)\n            t.def = tBlank; // if any neighbor is tInvalid, there's a chance we can change back to tBlank\n        //else if (h*7u < 0x00000fffu)\n        //    t.def = tInvalid; // smaller chance of even becoming invalid ourselves thus spreading the reset\n    // first must determine whether can leave existing tile as is\n    bool invalid = t.def == tInvalid || t.def == tBlank;\n    if (!invalid) {\n        if (!Fits(t, n))\n           invalid = true;\n    }\n    if (!invalid)\n        return; // all good!\n    if (invalid && (h&(15u << 5)) == 0u) {\n        t.def = tInvalid; return;\n    }\n    // doors can only connect same or lesser color codes somehow\n    // the red key is found in the red area, etc.\n    // doors then simply let you into the 'next color' area.\n    if (!invalid)\n        if (t.def != tInvalid)\n            return; // we already generated a tile, and it's valid, so done here!  hopefully!\n    if (n[0].def <= tInvalid \n     && n[1].def <= tInvalid \n     && n[2].def <= tInvalid \n     && n[3].def <= tInvalid)\n        return; // can only update if at least some of the neighbors are valid/non-blank\n    // starting with a random kind and rotation, find first tile that fits here if there is one\n    int zero = min(0, iFrame);\n    for (int k = zero + 4 * 8 * tTotal; k-- > 0; ) {\n        int j = int((uint(k) + h) % uint(4 * 8 * tTotal));\n        Tile tj = FromFloat(float(j));\n        if (//tj.col != 0 && \n            tj.col != 1 && tj.col != 2 && tj.col != 4 && tj.col != 7)\n            continue; // allow only certain colors for now\n        if (tj.def != tInvalid && tj.def != tBlank)\n            if (!isSeed(tj.def)) {\n                if (Fits(tj, n))\n                    t = tj;\n                    //t.col = 0; // temp no colors for now\n            }\n    }\n    // if couldn't find any match, probably should switch to invalid\n    // else probably just stay invalid or blank\n    //if (invalid)\n    if (t.def == tBlank)\n        t.def = tInvalid; // switch to invalid to flag neighbors that they may want to change\n}\n// FIXME be aware that tInvalid can result in destruction and rewriting\n// of the passages in a way that makes getting to the exit impossible.\n// It's also possible for the generation to proceed in such a way that\n// one color gets blocked in by another and cannot reach its corresponding key\n// or something; in anything real, this would need to be detected and corrected somehow,\n// some rejection/failure/timeout handling, make it start over until gets it right.\n// or just cheat and carve a valid path through afterwards somehow.\n\nvec4 LoadState()\n{\n    return texelFetch(iChannel0, ivec2(0), 0);\n}\n\nfloat kb(int kc) \n{\n    return step(.5, texelFetch(iChannel3, ivec2(kc,0), 0).x);\n}\n// consult keyboard in iChannel3 // http://keyjs.dev \n\nvoid TileLogic(inout Tile t, ivec2 i) //, int l) // TODO maybe just track tile id as 3D ivec3\n{\n    vec4 gamestate = LoadState();\n    vec3 playerpos = gamestate.xyz;    // player location from Buffer B\n    int haskeys = int(gamestate.w);\n    bool nearplayer = length(playerpos - vec3(i.x, 0/*l*/, i.y) - vec3(.5, 0, .5)) < .7; // TODO optimize\n    bool hasthiskey = (t.col & haskeys) == t.col;\n    if (nearplayer) {\n        // game logic:\n        // if you go to where a key is, you acquire it, it changes to an empty floor.\n        // if you go to where a door is, if you have the proper key, it changes to a open door state \n        // (hall didn't work because caused invalid color connection)\n        switch (t.def) {\n            case tKey:\n                if (hasthiskey) // wait for key to be taken first\n                    t.def = tFloor;\n                break;\n            case tDoorLock:\n                if (hasthiskey) // only if have required key\n                    t.def = tDoorOpen; \n                break;\n        }\n        if (kb(8) > .5)\n            t.def = tInvalid; // must be stuck, redo this part\n    }\n}\n// keys don't get used up, there could be multiple doors of a color, \n// but only one guards another key or leads to another color floor.\n\nTile Init(ivec2 i) //, int l)\n{\n    Tile t;\n    t.def = tBlank;\n    t.col = 0;\n    int scramble = i.x * 127 + i.y * 49; // + l * 65535;\n    // FIXME uh, I have a hash() function!\n    t.rot = int(256. * sin(float(scramble))) & 3; //random();\n    // init 3 key locations and 3 locked door locations,\n    // one for each color code.  those are the dungeon seeds.\n    // need a 'win' exit location too.\n    // And a start.\n    // so at the start you need no keys, color for that area is now red (1)\n    ivec2 seeds[8];\n    // HACK to get started, I'll just pick some locations by hand:\n    seeds = ivec2[8] ( \n        ivec2(20, 15), // the start\n        ivec2(25, 10), // red key\n        ivec2(30, 20), // red door\n        ivec2(40, 25), // green key\n        ivec2(55, 40), // green door\n        ivec2(75, 15), // blue key\n        ivec2(85, 44), // blue door\n        ivec2(98, 48)  // the end\n    );\n    // TODO ensure all 5 are unique and not right next to each other or duplicated\n    //for (int i = seeds.length(); i-- > 0; ) seeds[i] = random2() % ivec2(iChannelResolution[0]);\n    #if 0\n    // randomize the seed locations (slightly) but not the start location, or I'd have to match in Buffer B\n    // idk why but it kills my doors!! FIXME\n    for (int j = seeds.length() - 1; j-- > 1; )\n        seeds[j] = seeds[j] + ivec2(3. * sin(vec2(acos(0.), 0) + float(hash(uint(scramble + j)) & 0xfffffu)));\n    #endif\n    ivec2 mz = MazeSize(iChannelResolution[0].xy);\n    for (int j = seeds.length(); j-- > 0; )\n        seeds[j] = seeds[j] * mz / ivec2(100,50);\n    // FIXME\n         if (i == seeds[0]) t = Tile(tFloor,1<<0, t.rot);\n    else if (i == seeds[1]) t = Tile(tKey,  1<<0, t.rot);\n    else if (i == seeds[2]) t = Tile(tDoorLock, 1<<0, 3);\n    else if (i == seeds[3]) t = Tile(tKey,  1<<1, t.rot);\n    else if (i == seeds[4]) t = Tile(tDoorLock, 1<<1, 3);\n    else if (i == seeds[5]) t = Tile(tKey,  1<<2, t.rot);\n    else if (i == seeds[6]) t = Tile(tDoorLock, 1<<2, 0);\n    else if (i == seeds[7]) t = Tile(tExit, 7, t.rot);\n    //if (all(lessThan(uvec2(i), uvec2(2)))) t = Tile(tSolid, 1, 0); //t.def = tSolid; // wall off state pixel\n    return t;\n}\n\nvoid Update(inout Tile t, ivec2 i) //, int l)\n{\n    int f = iFrame;\n    bool won = false;\n    //const int slow = 0; //5; //\n    //if ((~f % (1 << slow)) != 0) return;\n    //f >>= slow;\n    if (((i.x ^ i.y /*^ l*/ ^ f) & 1) != 0) { // neighbors take turns updating on alternate ticks\n        WaveFunctionCollapse(t, i); //, l);\n        TileLogic(t, i); //, l);\n        won = texelFetch(iChannel0, ivec2(0), 0).w < 0.; // TODO check iResolution changes\n    }\n    if (iFrame < 2 || won) \n        t = Init(i); //, l);\n}\n\n// controls\nvoid PlayerMove(inout vec4 state, vec4 mouse, float dt)\n{\n    // ESDF or arrow keys\n    vec2 mv = vec2(max(kb(70), kb(39)) - max(kb(83), kb(37)), \n                   max(kb(69), kb(38)) - max(kb(68), kb(40)));\n    if (mv == vec2(0) && iMouse == vec4(0)) // && iTime > 10. && iTimeDelta == 1./60.)\n        mv = .2 * sin(vec2(acos(0.),0) + .18*iTime); // attract mode    \n    vec3 pos = state.xyz; \n    float keys = state.w;\n    // TODO should be able to navigate with either keyboard or mouse\n    const float speed = 4.;\n    pos.xz += speed * mv * dt;\n    // need collision\n    Tile tilehere = LoadTile(iChannel0, iChannelResolution[0].xy, ivec2(pos.xz)); //, int(pos.y));\n    vec2 q = fract(pos.xz);\n    q = q - .5;\n    for (int i = min(0, iFrame) + 2; i-- > 0; ) {\n        // FIXME if I refactored this gradient to Common, could use it for fake shading in Image too\n        float d =  Distance(tilehere, q);\n        float du = Distance(tilehere, q + vec2(2e-2, 0));\n        float dv = Distance(tilehere, q + vec2(0, 2e-2));\n        vec2 g = vec2(du, dv) - d;\n        if (dot(g, g) > 1e-8)\n            q -= min(0., d - 1.*playerradius) * normalize(g);\n    }\n    q = q + .5;\n    pos.xz = floor(pos.xz) + q;\n    state = vec4(pos, keys);\n}\n\n// key inventory\nvoid GameLogic(inout vec4 state)\n{\n    // acquire any key we get near\n    vec3 playerpos = state.xyz;\n    int haskeys = int(state.w);\n    // must only enter the cell with the key to acquire it\n    Tile tilehere = LoadTile(iChannel0, iChannelResolution[0].xy, ivec2(playerpos.xz)); //, int(playerpos.y));\n    //Tile tilehere = FromFloat(texelFetch(iChannel0, ivec2(playerpos.xz), 0)[int(playerpos.y)]);\n    bool hasthiskey = (tilehere.col & haskeys) == tilehere.col;\n    switch (tilehere.def) {\n        case tKey:\n            haskeys |= tilehere.col;\n            break;\n        case tExit:\n            //if (tilehere.col == 7) // you got the magic thingy! a white ring\n            // TODO a nice animation as a reward would be nice\n            { haskeys = -1; } // you win!  yay!\n            break;\n    }\n    // esc should probably reset the game, generate a new dungeon\n    if (kb(27) > .5)\n        haskeys = -1; //7; // reset with esc key\n    state.w = float(haskeys);\n}\n// if you go to where a key is, you acquire it, it changes to an empty floor.\n// Must ensure we record that we've taken it, before it disappears!\n// will wait for us to take the key before removing it.\n// if you go to where a door is, if you have the proper key, it changes to an open door.\n\nbool mainState(out vec4 fragColor, vec2 fragCoord)\n{\n    if (fragCoord.x > 1. || fragCoord.y > 1.)\n        return false;\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    bool init = iFrame < 2 || state.w < 0.;\n    if (init) {\n        state.xyz = //vec3(25.5, 0,  19.5); // start position (HACK manually scaled, doesn't match Buffer A init)\n            vec3(vec2(ivec2(20, 15) * MazeSize(iChannelResolution[0].xy) / ivec2(100,50)) + .5, 0).xzy;\n        state.w = 0.; // have keys? or bits 0, 1, 2.  should start with none.\n    }\n    PlayerMove(state, iMouse, iTimeDelta);\n    GameLogic(state);\n    fragColor = state;\n    return true;\n}\n// state tucked in a corner you never see.\n\n// 'dungeon' WFC and world tile updates\nbool mainWFC(out vec4 fragColor, vec2 fragCoord)\n{\n    if (!all(lessThan(uvec2(fragCoord), uvec2(MazeSize(iChannelResolution[0].xy)))))\n        return false;\n    ivec2 i = ivec2(fragCoord);\n    //Tile tiles[nlayers] = LoadTiles(iChannel0, iChannelResolution[0].xy, i);\n    Tile t = LoadTile(iChannel0, iChannelResolution[0].xy, i);\n    //for (int l = 0; l < nlayers; ++l)\n    //    Update(tiles[l], i, l);\n    Update(t, i); //, 0);\n    //fragColor = StoreTiles(tiles, i);\n    fragColor.x = ToFloat(t); //tiles[0]);\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    if (!mainState(fragColor, fragCoord))\n        if (!mainWFC(fragColor, fragCoord))\n            discard;\n}\n// TODO could generate dijkstra field for various features like keys,\n// to enable some automatic traversal, solving of the dungeon, key puzzle thing.\n// Or for giving player hints.","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float playerradius = .2;\n\n// the buffers can get really large; you will definitely get lost if increase this!\nivec2 MazeSize(vec2 chres)\n{\n    return min(ivec2(chres), ivec2(2,1) << 6);\n}\n\nstruct TileDef\n{\n    int id;\n};\n\n// tiledef ids\nconst int\n    tBlank = 0, // everything starts as tBlank, it means nothing is here yet\n    tInvalid = 1, // if a tBlank gets stuck unable to find a valid tile, might switch to tInvalid to get neighbors to reset\n    tFloor = 2,\n    tDoorLock = 3,\n    tDoorOpen = 4,\n    tKey = 5,\n    tExit = 6, // some win object/exit\n    // most of those are somewhat special, can only be part of larger rooms if placed manually\n    tWall = 7, // side of room\n    tHall = 8,\n    tTurn = 9, // inside corner of room\n    tTurn2 = 10, // of narrow passageway \n    tTurn3 = 11, // outside corner of building\n    tRound = 12, // outside round corner\n    tPosts = 13,\n    tDiag = 14,\n    tJunct = 15,\n    tSolid = 16, // dungeon often has hard time generating without something to fill odd gaps\n    //tBars = 17,\n    //tDeadEnd = 18,\n    //tEmpty = 19, // unwalkable empty space like a pit or chasm or top of a tall room or stairs down\n    //tStair = 20,\n    tTotal = 17;\n    \n// seems need some sort of \"is seed\" flag;\n// I suppose classifying certain tiledefs will do.\n// to prevent wiping out important features during generation\n// when it has trouble finding a valid configuration.\n// seed tiles should never be 'erased' even when the neighbors don't match.\nbool isSeed(int def)\n{\n    return //def == tInvalid\n        //|| def == tEmpty \n        //|| def == tFull\n        //|| \n           def == tKey \n        || def == tFloor \n        //|| def == tStairs \n        || def == tDoorLock\n        || def == tDoorOpen\n        || def == tExit;\n}\n// seeds are special in that they never get deleted or created automatically.\n// tFloor is where player start etc. happen, just a safe place player can be.\n// they connect to regular walls and form larger rooms, but generally don't\n// get generated automatically.  mostly because of this!\n    \n// 'material' ids for inter-cell connection parts\nconst int\n    mEmpty = 0, // nothing has been generated here yet\n    mSolid = 1,\n    mDoorway = 2,\n    mTotal = 3;\n// my intention for these seems to have wandered and\n// now it's kind of a 'is solid' flag with special case haxx\n// that could be checked for elsewhere easier.  oh well.\n\n// following iq method\nfloat dBox(vec2 q, vec2 e)\n{\n    q = abs(q) - e;\n    float g = max(q.x, q.y);\n    return g <= 0. ? g : length(max(q, 0.));\n} \n\n// signed distance to unrotated tiledef centered at origin\n// extending 0.5 in each direction.\n// ideally I'd let some features extend into neighboring cells somehow\n// but for now probably CSG with some cube for the cell\n// so that these don't need to consider it.\nfloat Distance(TileDef def, vec2 q)\n{\n    vec2 a = abs(q); // many shapes need symmetry\n    float d = 3.4e38;\n    float w = .3; // passage width (inverse of wall thickness)\n    switch (def.id)\n    {\n        default: \n        case tBlank: break; //  d = .5 + 1e-4 - min(a.x, a.y); break;\n        case tFloor: break; //  d = .5 + 1e-4 - min(a.x, a.y); break;\n        case tDoorLock:  d = min(w*.95 - a.x, max(a.x, a.y) - 1e-6 - w); break; // FIXME make this not take up the whole cell\n        case tDoorOpen:  d = w*.95 - a.x; break;\n        case tKey:   d = min(min(length(max(vec2(0), abs(q - vec2(.06125,.25)) - vec2(.06125, 0))), length(max(vec2(0), abs(q - vec2(0, .125)) - vec2(0, .125)))), abs(length(q + vec2(0, .125)) - .125)) - .05; break;\n        case tExit:  d = abs(length(q) - .15) - .075; break;\n        case tWall:  d = w - q.y; break;\n        case tHall:  d = w - a.x; break;\n        case tTurn:  d = min(w + q.x, w + q.y); break; //d = dBox(q - vec3(.25,.25), vec3(.5,.5)); break; //\n        case tTurn2: d = min(min(w + q.x, w + q.y), dBox(q - vec2(.5), vec2(.5 - w))); break;\n        case tTurn3:  d = dBox(q - vec2(.5), vec2(.5 - w)); break; //max(w - q.x, w - q.y); break;\n        case tRound:  d = length(q - .5) - .5 + w; break;\n        case tPosts: d = dBox(vec2(a.x - .5, .5 + q.y), vec2(.5-w)); break; //max(w - a.x, q.y + w); break;\n        case tDiag: d = -abs(q.x + q.y) + 1. - w * sqrt(.5); break; //  d = min(w + max(- q.x, - q.y), max(q.x, q.y) + w); break;\n        case tJunct: d = min(max(w - a.x, q.y + w), w - q.y); break; //d = q.y + w; break; //\n        //case tBars:  d = length(vec2(a.x, q.y) - vec2(.5,1)) - .25; break;\n        //case tDeadEnd: d = min(w - a.x, .75 - q.y); break;\n        case tSolid: d = max(a.x, a.y) - 1e-6 - .5; break;\n        //case tEmpty: d = .5 + 1e-6; break; // 'empty' = distance to next cell\n        //case tStair: d = ?; break; // TODO some box domain repetition\n    }\n    return d;\n}\n\n// materials for an edge of a tiledef if rotated, starting with 0 = west, then 1 = north, 2 = east, 3 = south \n// why I picked this way?  idk, I think it was the keyboard support in Buffer A.\n// anyway it's contrary to my other toy, must do something different for 3D anyway\nivec3 Edge(int def, int rot)\n{\n    rot &= 3;\n    ivec3 m;\n    // TODO can you say 'look up table'?  repeat after me.   L.U.T.\n    switch (def)\n    {\n        default:\n        //case tInvalid: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tBlank: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tFloor: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tDoorLock:  m = ivec3[4](ivec3(1,1,1),ivec3(1,2,1),ivec3(1,1,1),ivec3(1,0,1))[rot]; break; // FIXME must match 'next' area somehow\n        case tDoorOpen:  m = ivec3[4](ivec3(1,1,1),ivec3(1,2,1),ivec3(1,1,1),ivec3(1,0,1))[rot]; break; // FIXME must match 'next' area somehow\n        // like there might need to be a 'back of the door' to connect to the other color with\n        case tKey:   m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tExit: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tWall:  m = ivec3[4](ivec3(0,0,1),ivec3(1,1,1),ivec3(1,0,0),ivec3(0,0,0))[rot]; break;\n        case tHall:  m = ivec3[4](ivec3(1,1,1),ivec3(1,0,1),ivec3(1,1,1),ivec3(1,0,1))[rot]; break;\n        case tTurn:  m = ivec3[4](ivec3(1,1,1),ivec3(1,0,0),ivec3(0,0,1),ivec3(1,1,1))[rot]; break;\n        case tTurn2:  m = ivec3[4](ivec3(1,1,1),ivec3(1,0,1),ivec3(1,0,1),ivec3(1,1,1))[rot]; break;\n        case tTurn3:  m = ivec3[4](ivec3(0,0,0),ivec3(0,0,1),ivec3(1,0,0),ivec3(0,0,0))[rot]; break;\n        case tRound:  m = ivec3[4](ivec3(0,0,0),ivec3(0,0,1),ivec3(1,0,0),ivec3(0,0,0))[rot]; break;\n        case tPosts:  m = ivec3[4](ivec3(1,0,0),ivec3(0,0,0),ivec3(0,0,1),ivec3(1,0,1))[rot]; break;\n        case tDiag:  m = ivec3[4](ivec3(1,0,0),ivec3(0,0,1),ivec3(1,0,0),ivec3(0,0,1))[rot]; break;\n        case tJunct: m = ivec3[4](ivec3(1,0,1),ivec3(1,1,1),ivec3(1,0,1),ivec3(1,0,1))[rot]; break;\n        //case tBars:  m = ivec3[4](ivec3(0,0,1),ivec3(1,1,1),ivec3(1,0,0),ivec3(0,0,0))[rot]; break;\n        //case tDeadEnd:  m = ivec3[4](ivec3(1,1,1),ivec3(1,1,1),ivec3(1,1,1),ivec3(1,0,1))[rot]; break;\n        case tSolid: m = ivec3[4](ivec3(1),ivec3(1),ivec3(1),ivec3(1))[rot]; break;\n        //case tEmpty: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        //case tStair:  m = ivec3[4](ivec3(),ivec3(),ivec3(),ivec3())[rot]; break; // TODO need 3D connectivity\n    }\n    return m;\n}\n\n// TODO probably some clever way not to have to use LUT\nmat2 Rot(int rot)\n{\n    const mat2 rots[4] = mat2[] ( \n        mat2(1,0,0,1),\n        mat2(0,1,-1,0),\n        mat2(-1,0,0,-1),\n        mat2(0,-1,1,0)\n        );\n    return rots[rot & 3];\n}\n\n\n// Wellons lowbias32 from http://nullprogram.com/blog/2018/07/31\nuint hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352du;\n    x ^= x >> 15;\n    x *= 0x846ca68bu;\n    return x ^ (x >> 16);\n}\n\n\nstruct Tile \n{\n    int def; // tile def id\n    int col; // color code bits; could also be considered a 'zone id' of sorts\n    int rot; // rotation\n};\n\n// selfillum emission in alpha; TODO more\nvec4 Material(Tile tile, vec2 q)\n{\n    vec3 tint = vec3((ivec3(tile.col) >> ivec3(0,1,2)) & 1);\n    //tint.b *= 3.; // HACK why blue so dim?\n    float factor = float(isSeed(tile.def));\n    tint = mix(vec3(.4), tint, mix(factor, 1., .2));\n    if (tile.def == tInvalid) tint = vec3(0);\n    return vec4(tint, factor);\n}\n\n// requires q to provide signed coordinates from -.5 to .5\n// to describe an entire cell.\nfloat Distance(Tile tile, vec2 q)\n{\n    q *= Rot(tile.rot);\n    return Distance(TileDef(tile.def), q);\n}\n\nvec3 DrawTile(Tile tile, vec2 f, float aa)\n{\n    if (tile.def == tInvalid) return vec3(.5,0,.5);\n    if (tile.def == tBlank) return vec3(.02,.02,.05);\n    //tile.rot = 0;\n    vec2 q = f - .5;\n    float d = Distance(tile, q);\n    float cov = clamp(.5 - d * aa, 0., 1.);\n    float g = mix(.4, 1., cov);\n    //g *= pow(max(0., 16. * (1.-f.x)*(1.-f.y)*f.x*f.y), .125); // HACK show grid\n    return g * Material(tile, q).rgb;\n}\n\n//vec4 FetchTiles(sampler2D ch, ivec2 p)\n//{\n//    return texelFetch(ch, p, 0);\n//}\n// simple packing/unpacking\nTile FromFloat(float x)\n{\n    int c = int(x),\n        def = c >> 5,  // n leftover bits at offset 5\n        col = (c >> 2) & 7,  // 3 bits at offset 2 for color code\n        rot = c & 3;   // 2 bits at offset 0 for rotation\n    return Tile(def, col, rot);\n}\n\nfloat ToFloat(Tile t)\n{\n    int i = (t.def << 5)\n        | ((t.col & 7) << 2)\n        | (t.rot & 3);\n    return float(i);\n}\n\nTile LoadTile(sampler2D ch, vec2 chr, ivec2 p) //, int l)\n{\n    vec4 layers = texelFetch(ch, p, 0); //FetchTiles(ch, p);\n    Tile t = FromFloat(layers[0/*l*/]);\n    if (!all(lessThan(uvec2(p), uvec2(MazeSize(chr))))) t.def = tSolid;\n    if (all(lessThan(uvec2(p), uvec2(1)))) t.def = tSolid; // pretend state pixel is a wall so it gets walled in\n    return t;\n}\n/*\n// idk why I make things so complicated.  I could just start with one layer.\nconst int nlayers = 1; //4; //\n\nTile[nlayers] LoadTiles(sampler2D ch, vec2 chr, ivec2 p)\n{\n    vec4 v = FetchTiles(ch, p);\n    Tile tiles[nlayers];\n    for (int l = 0; l < nlayers; ++l) {\n        tiles[l] = FromFloat(v[l]); //LoadTile(iChannel0, p, l);\n        if (!all(lessThan(uvec2(p), uvec2(MazeSize(chr))))) tiles[l].def = tSolid;\n        if (all(lessThan(uvec2(p), uvec2(1)))) tiles[l].def = tSolid; // pretend state pixel is a wall so it gets walled in\n    }\n    return tiles;\n}\n\nvec4 StoreTiles(in Tile t[nlayers], ivec2 p)\n{\n    vec4 o;\n    for (int i = 0; i < nlayers; ++i) \n        o[i] = ToFloat(t[i]);\n    return o;\n}\n*/","name":"Common","description":"","type":"common"}]}