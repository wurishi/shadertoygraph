{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"cubemap","id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\nRadiance Cascades with screen space probes\n    Lags 1 frame behind in order to make it work in shadertoy\n    Uses 6 cascades\n    Single bounce integration\n\nProbes\n    Same ray direction layout as Radiance Cascades 3D\n    Randomly placed within its tile and oriented with the pixel normal -> better coverage\n\nMerging\n    An entire cascade projects all ray hitpoints on the next cascade\n        In practice: good candidates for every probes and bin are chosen to\n        represent all points that project into that probe & bin\n            So its gather with a 5x5 search area\n            Scatter write would be better (but slower?)\n    Visibility is determined using the traced ray in the current bin\n        Limited to only be checked inside an interval <- function of probe size and depth (and resolution, aspect, FOV)\n    Four probes from the last cascade are used and then spatially interpolated\n        Weighted by whether any hitpoint was projected\n\nTemporal accumulation in cubemap\n    16 sample accumulation\n    No spatial denoising <- would help with disocclusion artifacts\n    Some flickering is visible\n\nImprovement ideas:\n    Samples are not BRDF weighted at all (big oof, I know)\n    Visibility is pretty naive, only checks depth inside bin\n    Maybe it can be done without stochastic probes?\n        Approximate point cloud integration when merging cascades without probe interpolation, but how? >:(\n\nFeedback is welcome :)\n\n\n\n\nControls:\n    Mouse to move the camera around (after the animation is done)\n*/\n\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024), 2.)*2. + 1.;\n    vec3 D = vec3(vec2(UV.x, mod(UV.y, 1024.))*I512 - 1., Sign);\n    if (UV.y > 4096.) D = D.xzy;\n    else if (UV.y > 2048.) D = D.zxy;\n    return texture(iChannel3, D);\n}\n\nvec3 acesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x + 0.03))/(x*(2.43*x + 0.59) + 0.14), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 hUV = floor(fragCoord*0.5) + 0.5;\n    float YOffset = floor(hUV.x*I1024)*1024. + floor(hUV.y*I1024)*3072.;\n    vec3 Color = textureCube(mod(hUV, 1024.) + vec2(0., YOffset)).xyz;\n    vec3 sunDir = GetSunDirection(iTime);\n    vec4 lMouse = texture(iChannel0, vec2(HRES.x + 1.5, HRES.y + 0.5)*IRES);\n    vec3 lPos = GetCameraPos(lMouse, IRES);\n    vec3 lEye = GetCameraEye(lMouse, IRES);\n    mat3 lEyeMat = TBN(lEye);\n    vec3 lDir = normalize(vec3((hUV*IHRES*2. - 1.)*ASPECT, 1.)*lEyeMat);\n    vec4 lAttr = texture(iChannel0, vec2(hUV.x + HRES.x, hUV.y)*IRES);\n    vec3 lNor = normalize(FloatToVec3(lAttr.z)*2. - 1.);\n    vec3 lCol = FloatToVec3(lAttr.y)*5.;\n    if (lAttr.w > -0.5) {\n        if (lCol.x > 1.) {\n            Color = lCol;\n        } else {\n            vec3 lPPos = lPos + lDir*lAttr.w;\n            vec3 sunLight = GetSunLight(iTime, lPPos);\n            if (TraceRay(lPPos + lNor*0.0001, sunDir, 10000., iTime).n.x < -15.) {\n                Color += max(0., dot(lNor, sunDir))*sunLight;\n            }\n            Color *= lCol;\n        }\n    }\n    \n    //DEBUG (depth)\n    //Color = texture(iChannel0, fragCoord*0.5*IRES).www*0.2;\n    \n    fragColor = vec4(pow(acesFilm(max(vec3(0.), Color)), vec3(0.45)), 1.);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//G-Buffer\n\nvoid UpdateMouseAttributes(inout vec4 info, vec4 mouse) {\n    if (mouse.z > 0.) {\n        if (info.w < 0.5) {\n            info.w = 1.;\n            info.z = iTime;\n            info.xy = mouse.zw;\n        }\n    } else {\n        info.w = 0.;\n    }\n}\n\nvoid UpdateMouse(inout vec4 info, vec4 mouseA, vec4 mouse) {\n    if (mouseA.w < 0.5)  {\n        info.zw = info.xy;\n    } else {\n        info.x = info.z + mouse.x - mouseA.x;\n        info.y = info.w + mouse.y - mouseA.y;\n        info.y = clamp(info.y, 0., RES.y);\n    }\n}\n\nvec2 AnimatedMouse(float t) {\n    float smooth_t = t*t*(3. - 2.*t);\n    return vec2(((1. - smooth_t) + 0.125)*HRES.x, (0.9 - sin(smooth_t*3.141592653)*0.85)*HRES.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 info = vec4(0.);\n    if (fragCoord.y < HRES.y) {\n        if (fragCoord.x < HRES.x) {\n            //Current frame\n            vec4 cMouse = vec4(0.);\n            if (iTime < ATIME) {\n                cMouse.xy = AnimatedMouse(iTime*IATIME);\n            } else {\n                vec4 mousea = texture(iChannel0, vec2(HRES.x + 3.5, HRES.y + 0.5)*IRES);\n                cMouse = texture(iChannel0, vec2(HRES.x + 0.5, HRES.y + 0.5)*IRES);\n                UpdateMouseAttributes(mousea, iMouse);\n                UpdateMouse(cMouse, mousea, iMouse);\n            }\n            vec3 pPos = GetCameraPos(cMouse, IRES);\n            vec3 pEye = GetCameraEye(cMouse, IRES);\n            vec3 pDir = normalize(vec3((fragCoord*IHRES*2. - 1.)*ASPECT, 1.)*TBN(pEye));\n            HIT rayHit = TraceRay(pPos, pDir, 1000000., iTime);\n            if (rayHit.n.x > -15.) {\n                info = vec4(0., Vec3ToFloat(rayHit.c*0.2), Vec3ToFloat(rayHit.n*0.5 + 0.5), rayHit.t);\n            } else {\n                info = vec4(-20.);\n            }\n        } else {\n            //Last frame\n            info = texture(iChannel0, vec2(fragCoord.x - HRES.x, fragCoord.y)*IRES);\n        }\n    } else if (fragCoord.x < HRES.x) {\n        //2nd last frame\n        info = texture(iChannel0, vec2(fragCoord.x + HRES.x, fragCoord.y - HRES.y)*IRES);\n    } else if (fragCoord.y < HRES.y + 1. && fragCoord.x < HRES.x + 4.) {\n        //Mouse position\n        if (iTime < ATIME) {\n            if (fragCoord.x > HRES.x + 3. || fragCoord.x < HRES.x + 1.) {\n                info = vec4(AnimatedMouse(iTime*IATIME), 0., 0.);\n            } else if (fragCoord.x < HRES.x + 2.) {\n                info = texture(iChannel0, vec2(fragCoord.x - 1., fragCoord.y)*IRES);\n            } else if (fragCoord.x < HRES.x + 3.) {\n                info = texture(iChannel0, vec2(fragCoord.x - 1., fragCoord.y)*IRES);\n            }\n        } else {\n            info = texture(iChannel0, fragCoord*IRES);\n            if (fragCoord.x > HRES.x + 3.) {\n                UpdateMouseAttributes(info, iMouse);\n            } else if (fragCoord.x < HRES.x + 1.) {\n                vec4 mousea = texture(iChannel0, vec2(fragCoord.x + 3., fragCoord.y)*IRES);\n                UpdateMouseAttributes(mousea, iMouse);\n                UpdateMouse(info, mousea, iMouse);\n            } else if (fragCoord.x < HRES.x + 2.) {\n                info = texture(iChannel0, vec2(fragCoord.x - 1., fragCoord.y)*IRES);\n            } else {\n                info = texture(iChannel0, vec2(fragCoord.x - 1., fragCoord.y)*IRES);\n            }\n        }\n    }\n    fragColor = info;\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//Cascade 2 and 5\n\nvec4 ProjectLC(vec2 luvp, float lProbeSize, vec3 probePos, vec3 probeDir, vec3 probeTan,\n               vec3 probeBit, vec3 probeNor, vec2 probeBin, vec3 pPos, mat3 pEyeMat,\n               vec2 cascadeOffset, vec4 rayInfo, float probeWSize, bool lFrame, float frame, float lCascade) {\n    //Last cascade projection\n    vec2 lProbeGridOffset = ProbeStochOffset(frame + 1., lCascade, lProbeSize);\n    if (lFrame) lProbeGridOffset = ProbeStochOffset(frame, lCascade, lProbeSize);\n    vec4 lProbeAttr = texture(iChannel0, (luvp + lProbeGridOffset + vec2(((lFrame) ? HRES.x : 0.), 0.))*IRES);\n    vec3 lProbeNor = normalize(FloatToVec3(lProbeAttr.z)*2. - 1.);\n    if (lProbeAttr.w < -5. || dot(probeDir, lProbeNor) <= 0.) return vec4(0.);\n    vec3 lProbePos = pPos + normalize(vec3(((luvp + lProbeGridOffset)*IHRES*2. - 1.)*ASPECT, 1.)*pEyeMat)*lProbeAttr.w;\n    vec3 lProbeBit; vec3 lProbeTan = TBN(lProbeNor, lProbeBit);\n    mat3 lProbeMat = TBN(lProbeNor);\n    vec2 luvd = ProjectDir(vec3(dot(probeDir, lProbeBit), dot(probeDir, lProbeTan), dot(probeDir, lProbeNor)), lProbeSize);\n    vec2 luvdc = clamp(luvd, vec2(2.5), vec2(lProbeSize - 2.5));\n    vec4 sampleBin = vec4(0.);\n    for (float x = -2.; x < 2.5; x++) {\n        for (float y = -2.; y < 2.5; y++) {\n            vec2 sLUV = cascadeOffset + luvp + luvdc + vec2(x, y);\n            vec4 sLD = texture(iChannel1, sLUV*IRES);\n            vec3 sRelPos = lProbePos + (ComputeDir(luvdc + vec2(x, y), lProbeSize)*lProbeMat)*sLD.w - probePos;\n            vec3 sRPosTBN = vec3(dot(sRelPos, probeBit), dot(sRelPos, probeTan), dot(sRelPos, probeNor));\n            vec2 sProjectedBin = ProjectDir(sRPosTBN, lProbeSize*0.5);\n            if (sProjectedBin.x < -0.5 || DFBox(sProjectedBin - probeBin, vec2(1.)) > 0.) continue;\n            if (rayInfo.w < probeWSize && rayInfo.w < dot(probeDir, sRelPos) - 0.005) continue;\n            sampleBin += vec4(max(vec3(0.), sLD.xyz), 1.);\n        }\n    }\n    float w = max(0.001, (dot(lProbeNor, probeNor) - 0.8)/0.2*float(abs(dot(lProbePos - probePos, probeNor)) < 0.02));\n    if (sampleBin.w > 0.5) return vec4(sampleBin.xyz/sampleBin.w*w, w);\n    else return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 info = vec4(-20.);\n    vec3 sunDir = GetSunDirection(iTime);\n    float probeCascade = 2. + floor(fragCoord.y*IHRES.y)*3.;\n    float probeSize = pow(2., probeCascade + 1.);\n    vec2 probePositions = floor(HRES/probeSize);\n    vec2 probeSSRes = probePositions*probeSize;\n    vec2 modUV = mod(fragCoord, HRES);\n    vec2 probeUV = mod(modUV, probeSize);\n    \n    if (fragCoord.x < HRES.x && DFBox(mod(fragCoord, HRES), probeSSRes) < 0.) {\n        //Probes\n        vec4 cMouse = texture(iChannel0, vec2(HRES.x + 0.5, HRES.y + 0.5)*IRES);\n        if (fragCoord.y < HRES.y) cMouse = texture(iChannel0, vec2(HRES.x + 1.5, HRES.y + 0.5)*IRES);\n        vec2 probeGridOffset = ProbeStochOffset(float(iFrame) + 1., probeCascade, probeSize);\n        if (fragCoord.y < HRES.y) probeGridOffset = ProbeStochOffset(float(iFrame), probeCascade, probeSize);\n        vec2 probeDirUV = floor(modUV/probeSize)*probeSize + probeGridOffset;\n        vec3 pPos = GetCameraPos(cMouse, IRES);\n        vec3 pEye = GetCameraEye(cMouse, IRES);\n        mat3 pEyeTBN = TBN(pEye);\n        vec3 pDir = normalize(vec3((probeDirUV*IHRES*2. - 1.)*ASPECT, 1.)*pEyeTBN);\n        vec4 pAttr = texture(iChannel0, (probeDirUV + vec2(((fragCoord.y < HRES.y) ? HRES.x : 0.), 0.))*IRES);\n        if (pAttr.w > -15.) {\n            //Probe is valid\n            vec3 probeNor = normalize(FloatToVec3(pAttr.z)*2. - 1.);\n            vec3 probePos = pPos + pDir*pAttr.w + probeNor*0.0001;\n            vec3 probeBit; vec3 probeTan = TBN(probeNor, probeBit);\n            vec3 probeDir = ComputeDir(probeUV, probeSize)*TBN(probeNor);\n            \n            //Trace ray\n            HIT rayHit = TraceRay(probePos, probeDir, 1000000., iTime);\n            if (rayHit.n.x > -15.) {\n                if (rayHit.c.x > 1.) {\n                    info = vec4(rayHit.c, rayHit.t);\n                } else {\n                    info = vec4(0., 0., 0., rayHit.t);\n                    vec3 hitP = probePos + probeDir*rayHit.t + rayHit.n*0.001;\n                    vec3 sunLight = GetSunLight(iTime, hitP);\n                    if (TraceRay(hitP, sunDir, 10000., iTime).n.x < -15.) {\n                        info.xyz += max(0., dot(rayHit.n, sunDir))*sunLight*rayHit.c;\n                    }\n                }\n            } else {\n                info = vec4(GetSkyLight(probeDir), 1000000.);\n            }\n            \n            //Merge\n            if (fragCoord.y < HRES.y) {\n                float probeWSize = ProbeWSize(probeDirUV, probeSize, pAttr.w, IRES, ASPECT);\n                float lProbeSize = probeSize*2.;\n                vec2 lPUVPos = clamp(floor(modUV/lProbeSize - 0.5), vec2(0.), floor(HRES/lProbeSize) - 2.)*lProbeSize;\n                vec2 fPUVPos = fract(modUV/lProbeSize - 0.5);\n                if (floor(modUV.x/lProbeSize - 0.5) > floor(HRES.x/lProbeSize) - 1.5) fPUVPos.x = 1.;\n                else if (floor(modUV.x/lProbeSize - 0.5) < -0.5) fPUVPos.x = 0.;\n                if (floor(modUV.y/lProbeSize - 0.5) > floor(HRES.y/lProbeSize) - 1.5) fPUVPos.y = 1.;\n                else if (floor(modUV.y/lProbeSize - 0.5) < -0.5) fPUVPos.y = 0.;\n                vec2 cascadeOffset = vec2(0., HRES.y);\n                vec4 S0 = ProjectLC(lPUVPos, lProbeSize, probePos,\n                                    probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                    pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                    fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n                vec4 S1 = ProjectLC(lPUVPos + vec2(lProbeSize, 0.), lProbeSize, probePos,\n                                    probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                    pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                    fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n                vec4 S2 = ProjectLC(lPUVPos + vec2(0., lProbeSize), lProbeSize, probePos,\n                                    probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                    pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                    fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n                vec4 S3 = ProjectLC(lPUVPos + lProbeSize, lProbeSize, probePos,\n                                    probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                    pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                    fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n                if (S0.w + S1.w + S2.w + S3.w > 0.0005) {\n                    info.xyz = mix(mix(S0.xyz, S1.xyz, fPUVPos.x), mix(S2.xyz, S3.xyz, fPUVPos.x), fPUVPos.y)/\n                               max(0.0001, mix(mix(S0.w, S1.w, fPUVPos.x), mix(S2.w, S3.w, fPUVPos.x), fPUVPos.y));\n                }\n            }\n        }\n    }\n    fragColor = info;\n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//Cascade 1 and 4\n\nvec4 ProjectLC(vec2 luvp, float lProbeSize, vec3 probePos, vec3 probeDir, vec3 probeTan,\n               vec3 probeBit, vec3 probeNor, vec2 probeBin, vec3 pPos, mat3 pEyeMat,\n               vec2 cascadeOffset, vec4 rayInfo, float probeWSize, bool lFrame, float frame, float lCascade) {\n    //Last cascade projection\n    vec2 lProbeGridOffset = ProbeStochOffset(frame + 1., lCascade, lProbeSize);\n    if (lFrame) lProbeGridOffset = ProbeStochOffset(frame, lCascade, lProbeSize);\n    vec4 lProbeAttr = texture(iChannel0, (luvp + lProbeGridOffset + vec2(((lFrame) ? HRES.x : 0.), 0.))*IRES);\n    vec3 lProbeNor = normalize(FloatToVec3(lProbeAttr.z)*2. - 1.);\n    if (lProbeAttr.w < -5. || dot(probeDir, lProbeNor) <= 0.) return vec4(0.);\n    vec3 lProbePos = pPos + normalize(vec3(((luvp + lProbeGridOffset)*IHRES*2. - 1.)*ASPECT, 1.)*pEyeMat)*lProbeAttr.w;\n    vec3 lProbeBit; vec3 lProbeTan = TBN(lProbeNor, lProbeBit);\n    mat3 lProbeMat = TBN(lProbeNor);\n    vec2 luvd = ProjectDir(vec3(dot(probeDir, lProbeBit), dot(probeDir, lProbeTan), dot(probeDir, lProbeNor)), lProbeSize);\n    vec2 luvdc = clamp(luvd, vec2(2.5), vec2(lProbeSize - 2.5));\n    vec4 sampleBin = vec4(0.);\n    for (float x = -2.; x < 2.5; x++) {\n        for (float y = -2.; y < 2.5; y++) {\n            vec2 sLUV = cascadeOffset + luvp + luvdc + vec2(x, y);\n            vec4 sLD = texture(iChannel1, sLUV*IRES);\n            vec3 sRelPos = lProbePos + (ComputeDir(luvdc + vec2(x, y), lProbeSize)*lProbeMat)*sLD.w - probePos;\n            vec3 sRPosTBN = vec3(dot(sRelPos, probeBit), dot(sRelPos, probeTan), dot(sRelPos, probeNor));\n            vec2 sProjectedBin = ProjectDir(sRPosTBN, lProbeSize*0.5);\n            if (sProjectedBin.x < -0.5 || DFBox(sProjectedBin - probeBin, vec2(1.)) > 0.) continue;\n            if (rayInfo.w < probeWSize && rayInfo.w < dot(probeDir, sRelPos) - 0.005) continue;\n            sampleBin += vec4(max(vec3(0.), sLD.xyz), 1.);\n        }\n    }\n    float w = max(0.001, (dot(lProbeNor, probeNor) - 0.8)/0.2*float(abs(dot(lProbePos - probePos, probeNor)) < 0.02));\n    if (sampleBin.w > 0.5) return vec4(sampleBin.xyz/sampleBin.w*w, w);\n    else return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 info = vec4(-20.);\n    vec3 sunDir = GetSunDirection(iTime);\n    float probeCascade = 1. + floor(fragCoord.y*IHRES.y)*3.;\n    float probeSize = pow(2., probeCascade + 1.);\n    vec2 probePositions = floor(HRES/probeSize);\n    vec2 probeSSRes = probePositions*probeSize;\n    vec2 modUV = mod(fragCoord, HRES);\n    vec2 probeUV = mod(modUV, probeSize);\n    \n    if (fragCoord.x < HRES.x && DFBox(mod(fragCoord, HRES), probeSSRes) < 0.) {\n        //Probes\n        vec4 cMouse = texture(iChannel0, vec2(HRES.x + 0.5, HRES.y + 0.5)*IRES);\n        if (fragCoord.y < HRES.y) cMouse = texture(iChannel0, vec2(HRES.x + 1.5, HRES.y + 0.5)*IRES);\n        vec2 probeGridOffset = ProbeStochOffset(float(iFrame) + 1., probeCascade, probeSize);\n        if (fragCoord.y < HRES.y) probeGridOffset = ProbeStochOffset(float(iFrame), probeCascade, probeSize);\n        vec2 probeDirUV = floor(modUV/probeSize)*probeSize + probeGridOffset;\n        vec3 pPos = GetCameraPos(cMouse, IRES);\n        vec3 pEye = GetCameraEye(cMouse, IRES);\n        mat3 pEyeTBN = TBN(pEye);\n        vec3 pDir = normalize(vec3((probeDirUV*IHRES*2. - 1.)*ASPECT, 1.)*pEyeTBN);\n        vec4 pAttr = texture(iChannel0, (probeDirUV + vec2(((fragCoord.y < HRES.y) ? HRES.x : 0.), 0.))*IRES);\n        if (pAttr.w > -15.) {\n            //Probe is valid\n            vec3 probeNor = normalize(FloatToVec3(pAttr.z)*2. - 1.);\n            vec3 probePos = pPos + pDir*pAttr.w + probeNor*0.0001;\n            vec3 probeBit; vec3 probeTan = TBN(probeNor, probeBit);\n            vec3 probeDir = ComputeDir(probeUV, probeSize)*TBN(probeNor);\n            \n            //Trace ray\n            HIT rayHit = TraceRay(probePos, probeDir, 1000000., iTime);\n            if (rayHit.n.x > -15.) {\n                if (rayHit.c.x > 1.) {\n                    info = vec4(rayHit.c, rayHit.t);\n                } else {\n                    info = vec4(0., 0., 0., rayHit.t);\n                    vec3 hitP = probePos + probeDir*rayHit.t + rayHit.n*0.001;\n                    vec3 sunLight = GetSunLight(iTime, hitP);\n                    if (TraceRay(hitP, sunDir, 10000., iTime).n.x < -15.) {\n                        info.xyz += max(0., dot(rayHit.n, sunDir))*sunLight*rayHit.c;\n                    }\n                }\n            } else {\n                info = vec4(GetSkyLight(probeDir), 1000000.);\n            }\n            \n            //Merge\n            float probeWSize = ProbeWSize(probeDirUV, probeSize, pAttr.w, IRES, ASPECT);\n            float lProbeSize = probeSize*2.;\n            vec2 lPUVPos = clamp(floor(modUV/lProbeSize - 0.5), vec2(0.), floor(HRES/lProbeSize) - 2.)*lProbeSize;\n            vec2 fPUVPos = fract(modUV/lProbeSize - 0.5);\n            if (floor(modUV.x/lProbeSize - 0.5) > floor(HRES.x/lProbeSize) - 1.5) fPUVPos.x = 1.;\n            else if (floor(modUV.x/lProbeSize - 0.5) < -0.5) fPUVPos.x = 0.;\n            if (floor(modUV.y/lProbeSize - 0.5) > floor(HRES.y/lProbeSize) - 1.5) fPUVPos.y = 1.;\n            else if (floor(modUV.y/lProbeSize - 0.5) < -0.5) fPUVPos.y = 0.;\n            vec2 cascadeOffset = vec2(0., floor(fragCoord.y*IHRES.y)*HRES.y);\n            vec4 S0 = ProjectLC(lPUVPos, lProbeSize, probePos,\n                                probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n            vec4 S1 = ProjectLC(lPUVPos + vec2(lProbeSize, 0.), lProbeSize, probePos,\n                                probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n            vec4 S2 = ProjectLC(lPUVPos + vec2(0., lProbeSize), lProbeSize, probePos,\n                                probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n            vec4 S3 = ProjectLC(lPUVPos + lProbeSize, lProbeSize, probePos,\n                                probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n            if (S0.w + S1.w + S2.w + S3.w > 0.0005) {\n                info.xyz = mix(mix(S0.xyz, S1.xyz, fPUVPos.x), mix(S2.xyz, S3.xyz, fPUVPos.x), fPUVPos.y)/\n                           max(0.0001, mix(mix(S0.w, S1.w, fPUVPos.x), mix(S2.w, S3.w, fPUVPos.x), fPUVPos.y));\n            }\n        }\n    }\n    fragColor = info;\n}","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//Cascade 0 and 3\n\nvec4 ProjectLC(vec2 luvp, float lProbeSize, vec3 probePos, vec3 probeDir, vec3 probeTan,\n               vec3 probeBit, vec3 probeNor, vec2 probeBin, vec3 pPos, mat3 pEyeMat,\n               vec2 cascadeOffset, vec4 rayInfo, float probeWSize, bool lFrame, float frame, float lCascade) {\n    //Last cascade projection\n    vec2 lProbeGridOffset = ProbeStochOffset(frame + 1., lCascade, lProbeSize);\n    if (lFrame) lProbeGridOffset = ProbeStochOffset(frame, lCascade, lProbeSize);\n    vec4 lProbeAttr = texture(iChannel0, (luvp + lProbeGridOffset + vec2(((lFrame) ? HRES.x : 0.), 0.))*IRES);\n    vec3 lProbeNor = normalize(FloatToVec3(lProbeAttr.z)*2. - 1.);\n    if (lProbeAttr.w < -5. || dot(probeDir, lProbeNor) <= 0.) return vec4(0.);\n    vec3 lProbePos = pPos + normalize(vec3(((luvp + lProbeGridOffset)*IHRES*2. - 1.)*ASPECT, 1.)*pEyeMat)*lProbeAttr.w;\n    vec3 lProbeBit; vec3 lProbeTan = TBN(lProbeNor, lProbeBit);\n    mat3 lProbeMat = TBN(lProbeNor);\n    vec2 luvd = ProjectDir(vec3(dot(probeDir, lProbeBit), dot(probeDir, lProbeTan), dot(probeDir, lProbeNor)), lProbeSize);\n    vec2 luvdc = clamp(luvd, vec2(2.5), vec2(lProbeSize - 2.5));\n    vec4 sampleBin = vec4(0.);\n    for (float x = -2.; x < 2.5; x++) {\n        for (float y = -2.; y < 2.5; y++) {\n            vec2 sLUV = cascadeOffset + luvp + luvdc + vec2(x, y);\n            vec4 sLD = texture(iChannel1, sLUV*IRES);\n            vec3 sRelPos = lProbePos + (ComputeDir(luvdc + vec2(x, y), lProbeSize)*lProbeMat)*sLD.w - probePos;\n            vec3 sRPosTBN = vec3(dot(sRelPos, probeBit), dot(sRelPos, probeTan), dot(sRelPos, probeNor));\n            vec2 sProjectedBin = ProjectDir(sRPosTBN, lProbeSize*0.5);\n            if (sProjectedBin.x < -0.5 || DFBox(sProjectedBin - probeBin, vec2(1.)) > 0.) continue;\n            if (rayInfo.w < probeWSize && rayInfo.w < dot(probeDir, sRelPos) - 0.005) continue;\n            sampleBin += vec4(max(vec3(0.), sLD.xyz), 1.);\n        }\n    }\n    float w = max(0.001, (dot(lProbeNor, probeNor) - 0.8)/0.2*float(abs(dot(lProbePos - probePos, probeNor)) < 0.02));\n    if (sampleBin.w > 0.5) return vec4(sampleBin.xyz/sampleBin.w*w, w);\n    else return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 info = (((fragCoord.y < HRES.y)) ? vec4(0.) : vec4(-20.));\n    vec3 sunDir = GetSunDirection(iTime);\n    float probeCascade = floor(fragCoord.y*IHRES.y)*3.;\n    float probeSize = pow(2., probeCascade + 1.);\n    vec2 probePositions = floor(HRES/probeSize);\n    vec2 probeSSRes = probePositions*probeSize;\n    vec2 modUV = mod(fragCoord, HRES);\n    vec2 probeUV = mod(modUV, probeSize);\n    \n    if (fragCoord.x < HRES.x && DFBox(mod(fragCoord, HRES), probeSSRes) < 0.) {\n        //Probes\n        vec4 cMouse = texture(iChannel0, vec2(HRES.x + 0.5, HRES.y + 0.5)*IRES);\n        if (fragCoord.y < HRES.y) cMouse = texture(iChannel0, vec2(HRES.x + 1.5, HRES.y + 0.5)*IRES);\n        vec2 probeGridOffset = ProbeStochOffset(float(iFrame) + 1., probeCascade, probeSize);\n        if (fragCoord.y < HRES.y) probeGridOffset = ProbeStochOffset(float(iFrame), probeCascade, probeSize);\n        vec2 probeDirUV = floor(modUV/probeSize)*probeSize + probeGridOffset;\n        vec3 pPos = GetCameraPos(cMouse, IRES);\n        vec3 pEye = GetCameraEye(cMouse, IRES);\n        mat3 pEyeTBN = TBN(pEye);\n        vec3 pDir = normalize(vec3((probeDirUV*IHRES*2. - 1.)*ASPECT, 1.)*pEyeTBN);\n        vec4 pAttr = texture(iChannel0, (probeDirUV + vec2(((fragCoord.y < HRES.y) ? HRES.x : 0.), 0.))*IRES);\n        if (pAttr.w > -15.) {\n            //Probe is valid\n            vec3 probeNor = normalize(FloatToVec3(pAttr.z)*2. - 1.);\n            vec3 probePos = pPos + pDir*pAttr.w + probeNor*0.0001;\n            vec3 probeBit; vec3 probeTan = TBN(probeNor, probeBit);\n            vec3 probeDir = ComputeDir(probeUV, probeSize)*TBN(probeNor);\n            \n            //Trace ray\n            HIT rayHit = TraceRay(probePos, probeDir, 1000000., iTime);\n            if (rayHit.n.x > -15.) {\n                if (rayHit.c.x > 1.) {\n                    info = vec4(rayHit.c, rayHit.t);\n                } else {\n                    info = vec4(0., 0., 0., rayHit.t);\n                    vec3 hitP = probePos + probeDir*rayHit.t + rayHit.n*0.001;\n                    vec3 sunLight = GetSunLight(iTime, hitP);\n                    if (TraceRay(hitP, sunDir, 10000., iTime).n.x < -15.) {\n                        info.xyz += max(0., dot(rayHit.n, sunDir))*sunLight*rayHit.c;\n                    }\n                }\n            } else {\n                info = vec4(GetSkyLight(probeDir), 1000000.);\n            }\n            \n            //Merge\n            float probeWSize = ProbeWSize(probeDirUV, probeSize, pAttr.w, IRES, ASPECT);\n            float lProbeSize = probeSize*2.;\n            vec2 lPUVPos = clamp(floor(modUV/lProbeSize - 0.5), vec2(0.), floor(HRES/lProbeSize) - 2.)*lProbeSize;\n            vec2 fPUVPos = fract(modUV/lProbeSize - 0.5);\n            if (floor(modUV.x/lProbeSize - 0.5) > floor(HRES.x/lProbeSize) - 1.5) fPUVPos.x = 1.;\n            else if (floor(modUV.x/lProbeSize - 0.5) < -0.5) fPUVPos.x = 0.;\n            if (floor(modUV.y/lProbeSize - 0.5) > floor(HRES.y/lProbeSize) - 1.5) fPUVPos.y = 1.;\n            else if (floor(modUV.y/lProbeSize - 0.5) < -0.5) fPUVPos.y = 0.;\n            vec2 cascadeOffset = vec2(0., floor(fragCoord.y*IHRES.y)*HRES.y);\n            vec4 S0 = ProjectLC(lPUVPos, lProbeSize, probePos,\n                                probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n            vec4 S1 = ProjectLC(lPUVPos + vec2(lProbeSize, 0.), lProbeSize, probePos,\n                                probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n            vec4 S2 = ProjectLC(lPUVPos + vec2(0., lProbeSize), lProbeSize, probePos,\n                                probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n            vec4 S3 = ProjectLC(lPUVPos + lProbeSize, lProbeSize, probePos,\n                                probeDir, probeTan, probeBit, probeNor, probeUV - 0.5,\n                                pPos, pEyeTBN, cascadeOffset, info, probeWSize,\n                                fragCoord.y < HRES.y, float(iFrame), probeCascade + 1.);\n            if (S0.w + S1.w + S2.w + S3.w > 0.0005) {\n                info.xyz = mix(mix(S0.xyz, S1.xyz, fPUVPos.x), mix(S2.xyz, S3.xyz, fPUVPos.x), fPUVPos.y)/\n                           max(0.0001, mix(mix(S0.w, S1.w, fPUVPos.x), mix(S2.w, S3.w, fPUVPos.x), fPUVPos.y));\n            }\n        }\n    }\n    fragColor = info;\n}","name":"Buffer D","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"//CONST\nconst float ATIME = 24.;\nconst float IATIME = 1./ATIME;\nconst float I256 = 1./256.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\n\n//DEFINE\n#define RES iChannelResolution[0].xy\n#define HRES floor(iChannelResolution[0].xy*0.5)\n#define IRES 1./iChannelResolution[0].xy\n#define IHRES (1./floor(iChannelResolution[0].xy*0.5))\n#define ASPECT vec2(iChannelResolution[0].x/iChannelResolution[0].y, 1.)\n\n//STRUCT\nstruct HIT { float t; vec3 n; vec3 c; };\n\n//GENERIC MATH\nvec3 FloatToVec3(float v) {\n    int VPInt = floatBitsToInt(v);\n    int VPInt1024 = VPInt % 1024;\n    int VPInt10241024 = ((VPInt - VPInt1024)/1024) % 1024;\n    return vec3(VPInt1024, VPInt10241024, ((VPInt - VPInt1024 - VPInt10241024)/1048576))*I1024;\n}\n\nfloat Vec3ToFloat(vec3 v) {\n    ivec3 intv = min(ivec3(floor(v*1024.)), ivec3(1023));\n    return intBitsToFloat(intv.x + intv.y*1024 + intv.z*1048576);\n}\n\nfloat SampleRand(vec2 uv, int frame) {\n    float framef = fract(float(frame)*1.618033);\n    return fract(sin(dot(uv, vec2(314.2434, 257.3424)))*8234.23354*framef);\n}\n\n//SDF\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p - b*0.5) - b*0.5;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p - b*0.5) - b*0.5;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec2 Rotate2(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\n//SCENE\nvec3 GetCameraPos(vec4 inMouse, vec2 ires) {\n    vec2 mouse = vec2(fract(inMouse.x*ires.x + 0.5), inMouse.y*ires.y);\n    vec2 a = vec2(mouse.x*3.141592653*4., 0.01 + (1. - mouse.y)*3.141592653*0.55);\n    vec3 rp = vec3(cos(a.x)*sin(a.y), cos(a.y), sin(a.x)*sin(a.y));\n    return vec3(3., 1., 3.) - rp/smin(-abs(rp.x), smin(-abs(rp.y), -abs(rp.z), 0.3), 0.3)*2.75;\n}\n\nvec3 GetCameraEye(vec4 inMouse, vec2 ires) {\n    return -normalize(GetCameraPos(inMouse, ires) - vec3(3., 1., 3.));\n}\n\nvec3 GetSkyLight(vec3 d) {\n    return mix(vec3(0.2, 0.4, 1.), vec3(0.35, 0.4, 0.5), max(0., d.y))*max(0.01, d.y*0.5 + 0.5)*0.2;\n}\n\nvec3 GetSunLight(float t, vec3 p) {\n    float nt = t*IATIME;\n    if (fract((p.x + p.z*0.9 - p.y*0.9)*0.33) > 0.6) return vec3(0.);\n    return vec3(1., 0.65, 0.3)*6.;\n}\n\nvec3 GetSunDirection(float t) {\n    float nt = t*IATIME;\n    \n    return normalize(vec3(0.5, 0.6, 0.7));\n}\n\n//RT\nvec3 AQuad(vec3 p, vec3 d, vec3 vTan, vec3 vBit, vec3 vNor, vec2 pSize) {\n    float norDot = dot(vNor, d);\n    float pDot = dot(vNor, p);\n    if (sign(norDot*pDot) < -0.5) {\n        float t = -pDot/norDot;\n        vec2 hit2 = vec2(dot(p + d*t, vTan), dot(p + d*t, vBit));\n        if (DFBox(hit2, pSize) <= 0.) return vec3(hit2, t);\n    }\n    return vec3(-1.);\n}\n\nvec2 ABox(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin - origin)*dir;\n    vec3 tMax = (bmax - origin)*dir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    return vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));\n}\n\nfloat ABoxFar(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin - origin)*dir;\n    vec2 tMax = (bmax - origin)*dir;\n    vec2 t1 = min(tMin, tMax);\n    vec2 t2 = max(tMin, tMax);\n    return min(t2.x, t2.y);\n}\n\nvec2 ABoxNormal(vec3 origin, vec3 idir, vec3 bmin, vec3 bmax, out vec3 N) {\n    vec3 tMin = (bmin - origin)*idir;\n    vec3 tMax = (bmax - origin)*idir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    vec3 signdir = -(max(vec3(0.), sign(idir))*2. - 1.);\n    if (t1.x > max(t1.y, t1.z)) N = vec3(signdir.x, 0., 0.);\n    else if (t1.y > t1.z) N = vec3(0., signdir.y, 0.);\n    else N = vec3(0., 0., signdir.z);\n    return vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));\n}\n\nfloat ASphere(vec3 p, vec3 d, float r) {\n    float a = dot(p, p) - r*r;\n    float b = 2.*dot(p, d);\n    float re = b*b*0.25 - a;\n    if (dot(p, d) < 0. && re > 0.) {\n        float st = -b*0.5 - sqrt(re);\n        return st;\n    }\n    return -1.;\n}\n\nvec4 AStud(vec3 p, vec3 d) {\n    vec4 info = vec4(-2., -2., -2., 100000.);\n    vec2 studNor = vec2(0.92387953242, 0.38268343256);\n    for (int i = 0; i < 8; i++) {\n        float t = -(dot(p.xz, studNor) + 0.3)/dot(d.xz, studNor);\n        if (t > 0. && t < info.w) {\n            vec3 hitp = p + d*t;\n            if (hitp.y >= 0. && hitp.y <= 0.2 && length(hitp.xz) < 0.3248) {\n                info = vec4(studNor.x, 0., studNor.y, t);\n            }\n        }\n        studNor = vec2(studNor.x - studNor.y, studNor.x + studNor.y)*0.70710678118;\n    }\n    float pt = -(p.y - 0.2)/d.y;\n    if (d.y != 0. && pt > 0. && pt < info.w) {\n        vec3 sp = p + d*pt;\n        float studAngle = (floor((atan(sp.z, sp.x)/3.141592653 + 1.)*4. + 0.) + 0.5)*0.25*3.141592653;\n        if (dot(sp.xz, vec2(-cos(studAngle), -sin(studAngle))) <= 0.3) info = vec4(0., 1., 0., pt);\n    }\n    return info;\n}\n\nvec4 ARound111(vec3 p, vec3 d) {\n    vec4 info = vec4(-2., -2., -2., 100000.);\n    vec2 studNor = vec2(0.92387953242, 0.38268343256);\n    for (int i = 0; i < 8; i++) {\n        float t = -(dot(p.xz, studNor) + 0.45)/dot(d.xz, studNor);\n        if (t > 0. && t < info.w) {\n            vec3 hitp = p + d*t;\n            if (hitp.y >= 0.2 && hitp.y <= 1.2 && length(hitp.xz) < 0.4871) {\n                info = vec4(studNor.x, 0., studNor.y, t);\n            }\n        }\n        studNor = vec2(studNor.x - studNor.y, studNor.x + studNor.y)*0.70710678118;\n    }\n    studNor = vec2(0.92387953242, 0.38268343256);\n    for (int i = 0; i < 8; i++) {\n        float t = -(dot(p.xz, studNor) + 0.35)/dot(d.xz, studNor);\n        if (t > 0. && t < info.w) {\n            vec3 hitp = p + d*t;\n            if (hitp.y >= 0. && hitp.y <= 0.25 && length(hitp.xz) < 0.379) {\n                info = vec4(studNor.x, 0., studNor.y, t);\n            }\n        }\n        studNor = vec2(studNor.x - studNor.y, studNor.x + studNor.y)*0.70710678118;\n    }\n    return info;\n}\n\nvoid AStudRect(vec3 p, vec3 d, vec3 id, vec2 size, inout HIT info) {\n    vec2 bb = ABox(p, id, vec3(0., 0., 0.), vec3(size.x, 0.205, size.y));\n    float dfb = DFBox(p, vec3(size.x, 0.2, size.y));\n    if (dfb < 0. || (bb.x > 0. && bb.y > bb.x && bb.x < info.t)) {\n        float st = ((dfb < 0.) ? 0. : bb.x + 0.001 );\n        float stud_maxt = min(bb.y, info.t);\n        for (int i = 0; i < 16; i++) {\n            if (st > stud_maxt) break;\n            vec3 sp = p + d*st;\n            vec2 fp = floor(sp.xz);\n            vec4 nt4 = AStud(vec3(sp.x - fp.x - 0.5, sp.y, sp.z - fp.y - 0.5), d);\n            if (nt4.x > -1.5 && st + nt4.w < info.t) {\n                info = HIT(st + nt4.w, nt4.xyz, vec3(0.95));\n                break;\n            }\n            st += ABoxFar(sp.xz, id.xz, fp, fp + 1.) + 0.001;\n        }\n    }\n}\n\nHIT TraceRay(vec3 p, vec3 d, float maxt, float time) {\n    HIT info = HIT(maxt, vec3(-20.), vec3(-1.));\n    vec3 id = 1./d;\n    vec4 nt4;\n    vec3 uvt, sp, bn;\n    vec2 bb;\n    float st, dfb;\n    \n    //Floor\n    bb = ABox(p, id, vec3(0., -0.2, 0.), vec3(6., 0.01, 6.));\n    dfb = DFBox(p - vec3(0., -0.2, 0.), vec3(6., 0.16, 6.));\n    if (dfb <= 0. || (bb.x > 0. && bb.y > bb.x && bb.x < info.t)) {\n        st = ((dfb <= 0.) ? 0. : bb.x + 0.001 );\n        vec2 fp = floor((p.xz + d.xz*st - vec2(0., 0.1))*vec2(1./6., 0.5))*vec2(6., 2.) + vec2(0., 0.1);\n        vec3 rp = vec3(p.x - fp.x, p.y, p.z - fp.y);\n        st = -rp.y/d.y;\n        vec4 plane = vec4(-2., -2., -2., 0.);\n        if (d.y < 0. && st > plane.w && rp.z + d.z*st <= 1.8) {\n            plane = vec4(0., 1., 0., st);\n        }\n        vec3 tmpn = vec3(0., 0.70710678118, 0.70710678118);\n        st = -dot(rp - vec3(0., -0.1, 1.9), tmpn)/dot(d, tmpn);\n        if (dot(d, tmpn) < 0. && st > plane.w && DFBox(rp.xz + d.xz*st - vec2(0., 1.8), vec2(6., 0.1)) <= 0.) {\n            plane = vec4(tmpn, st);\n        }\n        tmpn = vec3(0., 0.70710678118, -0.70710678118);\n        st = -dot(rp - vec3(0., -0.1, 1.9), tmpn)/dot(d, tmpn);\n        if (dot(d, tmpn) < 0. && st > plane.w && DFBox(rp.xz + d.xz*st - vec2(0., 1.9), vec2(6., 0.1)) <= 0.) {\n            plane = vec4(tmpn, st);\n        }\n        if (plane.x > -1.5 && plane.w >= bb.x && plane.w < min(bb.y, info.t)) {\n            info = HIT(plane.w, plane.xyz, vec3(0.95));\n        }\n    }\n    \n    AStudRect(p, d, id, vec2(6., 6.), info);\n    \n    //Stud wall\n    bb = ABox(p, id, vec3(-0.15, 0., 0.), vec3(0.01, 6., 6.));\n    dfb = DFBox(p - vec3(-0.15, 0., 0.), vec3(0.16, 6., 6.));\n    if (dfb <= 0. || (bb.x > 0. && bb.y > bb.x && bb.x < info.t)) {\n        st = ((dfb <= 0.) ? 0. : bb.x + 0.001 );\n        vec2 fp = floor((p.zy + d.zy*st - vec2(0., 0.1))*vec2(1./6., 0.5))*vec2(6., 2.) + vec2(0., 0.1);\n        vec3 rp = vec3(p.x, p.y - fp.y, p.z - fp.x);\n        vec4 plane = vec4(-2., -2., -2., 0.);\n        st = -rp.x/d.x;\n        if (d.x < 0. && st > plane.w && rp.y + d.y*st <= 1.8) plane = vec4(1., 0., 0., st);\n        vec3 tmpn = vec3(0.70710678118, 0.70710678118, 0.);\n        st = -dot(rp.xy - vec2(-0.1, 1.9), tmpn.xy)/dot(d, tmpn);\n        if (dot(d, tmpn) < 0. && st > plane.w && DFBox(rp.zy + d.zy*st - vec2(0., 1.8), vec2(6., 0.1)) <= 0.) plane = vec4(tmpn, st);\n        tmpn = vec3(0.70710678118, -0.70710678118, 0.);\n        st = -dot(rp.xy - vec2(-0.1, 1.9), tmpn.xy)/dot(d, tmpn);\n        if (dot(d, tmpn) < 0. && st > plane.w && DFBox(rp.zy + d.zy*st - vec2(0., 1.9), vec2(6., 0.1)) <= 0.) plane = vec4(tmpn, st);\n        st = -(rp.x + 0.1)/d.x;\n        if (d.x < 0. && st > 0. && plane.x < -1.5) plane = vec4(1., 0., 0., st);\n        if (plane.x > -1.5 && plane.w >= bb.x && plane.w < min(bb.y, info.t)) {\n            info = HIT(plane.w, plane.xyz, vec3(0.95, 0.3, 0.1));\n        }\n    }\n    st = info.t;\n    AStudRect(p.yxz, d.yxz, id.yxz, vec2(6., 6.), info);\n    if (info.t < st) {\n        info.c = vec3(0.95, 0.3, 0.1);\n        info.n = info.n.yxz;\n    }\n    \n    //Stud wall\n    bb = ABox(p, id, vec3(0., 0., -0.15), vec3(6., 6., 0.01));\n    dfb = DFBox(p - vec3(0., 0., -0.15), vec3(6., 6., 0.16));\n    if (dfb <= 0. || (bb.x > 0. && bb.y > bb.x && bb.x < info.t)) {\n        st = ((dfb <= 0.) ? 0. : bb.x + 0.001 );\n        vec2 fp = floor((p.yx + d.yx*st - vec2(0., 0.1))*vec2(1./6., 0.5))*vec2(6., 2.) + vec2(0., 0.1);\n        vec3 rp = vec3(p.x - fp.y, p.y - fp.x, p.z);\n        vec4 plane = vec4(-2., -2., -2., 0.);\n        st = -rp.z/d.z;\n        if (d.z < 0. && st > plane.w && rp.x + d.x*st <= 1.8) plane = vec4(0., 0., 1., st);\n        vec3 tmpn = vec3(0.70710678118, 0., 0.70710678118);\n        st = -dot(rp.xz - vec2(1.9, -0.1), tmpn.xz)/dot(d, tmpn);\n        if (dot(d, tmpn) < 0. && st > plane.w && DFBox(rp.yx + d.yx*st - vec2(0., 1.8), vec2(6., 0.1)) <= 0.) plane = vec4(tmpn, st);\n        tmpn = vec3(-0.70710678118, 0., 0.70710678118);\n        st = -dot(rp.xz - vec2(1.9, -0.1), tmpn.xz)/dot(d, tmpn);\n        if (dot(d, tmpn) < 0. && st > plane.w && DFBox(rp.yx + d.yx*st - vec2(0., 1.9), vec2(6., 0.1)) <= 0.) plane = vec4(tmpn, st);\n        st = -(rp.z + 0.1)/d.z;\n        if (d.z < 0. && st > 0. && plane.x < -1.5) plane = vec4(0., 0., 1., st);\n        if (plane.x > -1.5 && plane.w >= bb.x && plane.w < min(bb.y, info.t)) {\n            info = HIT(plane.w, plane.xyz, vec3(0.2, 0.95, 0.2));\n        }\n    }\n    st = info.t;\n    AStudRect(p.yzx, d.yzx, id.yzx, vec2(6., 6.), info);\n    if (info.t < st) {\n        info.c = vec3(0.2, 0.95, 0.2);\n        info.n = info.n.zxy;\n    }\n    \n    //Desk\n    bb = ABox(p, id, vec3(1., 0., 1.), vec3(5., 1.8, 3.));\n    dfb = DFBox(p - vec3(1., 0., 1.), vec3(4., 1.8, 2.));\n    if (dfb < 0. || (bb.x > 0. && bb.y > bb.x && bb.x < info.t)) {\n        nt4 = ARound111(p - vec3(1.5, 0., 1.5), d);\n        if (nt4.x > -1.5 && nt4.w < info.t) info = HIT(nt4.w, nt4.xyz, vec3(0.95));\n        nt4 = ARound111(p - vec3(1.5, 0., 2.5), d);\n        if (nt4.x > -1.5 && nt4.w < info.t) info = HIT(nt4.w, nt4.xyz, vec3(0.95));\n        nt4 = ARound111(p - vec3(4.5, 0., 1.5), d);\n        if (nt4.x > -1.5 && nt4.w < info.t) info = HIT(nt4.w, nt4.xyz, vec3(0.95));\n        bb = ABoxNormal(p, id, vec3(1., 1.2, 1.), vec3(5., 1.6, 3.), bn);\n        if (bb.x > 0. && bb.y > bb.x && bb.x < info.t) info = HIT(bb.x, bn, vec3(0.95));\n        AStudRect(p - vec3(1., 1.6, 1.), d, id, vec2(4., 2.), info);\n    }\n    \n    //Emissive\n    nt4 = ARound111(p - vec3(3., 0., 5.), d);\n    if (nt4.x > -1.5 && nt4.w < info.t) info = HIT(nt4.w, nt4.xyz, vec3(0.95, 0.3, 0.3));\n    bb = ABoxNormal(p, id, vec3(2.5, 1.2, 4.5), vec3(3.5, 1.6, 5.5), bn);\n    if (bb.x > 0. && bb.y > bb.x && bb.x < info.t) info = HIT(bb.x, bn, vec3(0.95));\n    nt4 = AStud(p - vec3(3., 1.6, 5.), d);\n    if (nt4.x > -1.5 && nt4.w < info.t) info = HIT(nt4.w, nt4.xyz, vec3(0.95));\n    \n    //Tilting block\n    vec3 rp = p - vec3(0.75, 0.2, 3.75); rp.zy = Rotate2(rp.zy, 1.08);\n    vec3 rd = vec3(d.x, Rotate2(d.zy, 1.08).yx);\n    bb = ABoxNormal(rp, 1./rd, vec3(0., 0., -2.), vec3(1., 0.4, 0.), bn);\n    if (bb.x > 0. && bb.y > bb.x && bb.x < info.t) info = HIT(bb.x, vec3(bn.x, Rotate2(bn.zy, -0.9).yx), vec3(0.2, 0.4, 0.95));\n    st = info.t;\n    AStudRect(rp - vec3(0., 0.4, -2.), rd, 1./rd, vec2(1., 2.), info);\n    if (info.t < st) {\n        info.c = vec3(0.2, 0.4, 0.95);\n        info.n = vec3(info.n.x, Rotate2(info.n.zy, -1.08).yx);\n    }\n    \n    //Return\n    if (info.n.x > -1.5) info.n *= -dot(info.n, d);\n    return info;\n}\n\n//MATH\nmat3 TBN(vec3 N) {\n    vec3 Nb, Nt;\n    if (abs(N.y) > 0.99999) {\n        Nb = vec3(1., 0., 0.);\n        Nt = vec3(0., 0., 1.);\n    } else {\n    \tNb = normalize(cross(N, vec3(0., 1., 0.)));\n    \tNt = normalize(cross(Nb, N));\n    }\n    return mat3(Nb.x, Nt.x, N.x, Nb.y, Nt.y, N.y, Nb.z, Nt.z, N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 B) {\n    if (abs(N.y) > 0.99999) {\n        B = vec3(1., 0., 0.);\n        return vec3(0., 0., 1.);\n    } else {\n    \tB = normalize(cross(N, vec3(0., 1., 0.)));\n    \treturn normalize(cross(B, N));\n    }\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.141592653*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x, z, sqrt(max(0., 1. - v.x)));\n}\n\nvec3 BRDF_GGX(vec3 w_o, vec3 w_i, vec3 n, float alpha, vec3 F0) {\n    vec3 h = normalize(w_i + w_o);\n    float a2 = alpha*alpha;\n    float D = a2/(3.141592653*pow(pow(dot(h, n), 2.)*(a2 - 1.) + 1., 2.));\n    vec3 F = F0 + (1. - F0)*pow(1. - dot(n, w_o), 5.);\n    float k = a2*0.5;\n    float G = 1./((dot(n, w_i)*(1. - k)+k)*(dot(n, w_o)*(1. - k) + k));\n    vec3 OUT = F*(D*G*0.25);\n    return ((isnan(OUT) != bvec3(false)) ? vec3(0.) : OUT);\n}\n\n\n//MERGING\nvec2 ProbeStochOffset(float frame, float cascade, float probeSize) {\n    float rv = mod(frame + 0.5, 16.) + cascade*0.15;\n    return min(floor(fract(sin(vec2(rv*341.192, rv*517.293))*vec2(695.293, 498.283))*probeSize) + 0.5,\n               vec2(probeSize - 0.5));\n}\n\nfloat ProbeWSize(vec2 uv, float probeSize, float probeDist, vec2 ires, vec2 aspect) {\n    vec3 cPos = normalize(vec3((uv*ires*2. - 1.)*aspect, 1.))*probeDist;\n    vec3 xPos = normalize(vec3((vec2(uv.x + probeSize*0.5, uv.y)*ires*2. - 1.)*aspect, 1.))*probeDist;\n    vec3 yPos = normalize(vec3((vec2(uv.x, uv.y + probeSize*0.5)*ires*2. - 1.)*aspect, 1.))*probeDist;\n    return max(length(cPos - xPos), length(cPos - yPos))*8.;\n}\n\nvec3 ComputeDir(vec2 uv, float probeSize) {\n    vec2 probeRel = uv - probeSize*0.5;\n    float probeThetai = max(abs(probeRel.x), abs(probeRel.y));\n    float probeTheta = probeThetai/probeSize*3.14192653;\n    float probePhi = 0.;\n    if (probeRel.x + 0.5 > probeThetai && probeRel.y - 0.5 > -probeThetai) {\n        probePhi = probeRel.x - probeRel.y;\n    } else if (probeRel.y - 0.5 < -probeThetai && probeRel.x - 0.5 > -probeThetai) {\n        probePhi = probeThetai*2. - probeRel.y - probeRel.x;\n    } else if (probeRel.x - 0.5 < -probeThetai && probeRel.y + 0.5 < probeThetai) {\n        probePhi = probeThetai*4. - probeRel.x + probeRel.y;\n    } else if (probeRel.y + 0.5 > probeThetai && probeRel.x + 0.5 < probeThetai) {\n        probePhi = probeThetai*8. - (probeRel.y - probeRel.x);\n    }\n    probePhi = (probePhi + 0.)*3.141592653*2./(4. + 8.*floor(probeThetai));\n    return vec3(vec2(sin(probePhi), cos(probePhi))*sin(probeTheta), cos(probeTheta));\n}\n\nvec2 ProjectDir(vec3 dir, float probeSize) {\n    if (dir.z <= 0.) return vec2(-1.);\n    float thetai = min(floor((1. - acos(length(dir.xy)/length(dir))/(3.141592653*0.5))*(probeSize*0.5)), probeSize*0.5 - 1.);\n    float phiF = atan(-dir.x, -dir.y);\n    float phiI = floor((phiF/3.141592653*0.5 + 0.5)*(4. + 8.*thetai) + 0.5) + 0.5;\n    vec2 phiUV;\n    float phiLen = 2.*thetai + 1.;\n    float sideLen = phiLen + 1.;\n    if (phiI < phiLen) phiUV = vec2(sideLen - 0.5, sideLen - phiI);\n    else if (phiI < phiLen*2.) phiUV = vec2(sideLen - (phiI - phiLen), 0.5);\n    else if (phiI < phiLen*3.) phiUV = vec2(0.5, phiI - phiLen*2.);\n    else phiUV = vec2(phiI - phiLen*3., sideLen - 0.5);\n    return vec2((probeSize - sideLen)*0.5) + phiUV;\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dX3Rr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"cubemap","id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//Temporal accumulation\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024), 2.)*2. + 1.;\n    vec3 D = vec3(vec2(UV.x, mod(UV.y, 1024.))*I512 - 1., Sign);\n    if (UV.y > 4096.) D = D.xzy;\n    else if (UV.y > 2048.) D = D.zxy;\n    return texture(iChannel3, D);\n}\n\nvec4 IntegrateProbe(vec2 probeUV, vec3 p, vec3 n, vec3 lPos, mat3 lEyeMat) {\n    vec2 lProbeGridOffset = ProbeStochOffset(float(iFrame), 0., 2.);\n    vec4 lProbeAttr = texture(iChannel0, (probeUV + lProbeGridOffset + vec2(HRES.x, 0.))*IRES);\n    vec3 lProbeNor = normalize(FloatToVec3(lProbeAttr.z)*2. - 1.);\n    if (lProbeAttr.w < -5.) return vec4(0., 0., 0., 0.001);\n    vec3 lProbePos = lPos + normalize(vec3(((probeUV + lProbeGridOffset)*IHRES*2. - 1.)*ASPECT, 1.)*lEyeMat)*lProbeAttr.w;\n    float weight = max(0.001, (dot(lProbeNor, n) - 0.8)/0.2*float(abs(dot(n, p - lProbePos)) < 0.05));\n    \n    return vec4((texture(iChannel1, (probeUV + 0.5)*IRES).xyz +\n                 texture(iChannel1, vec2(probeUV.x + 1.5, probeUV.y + 0.5)*IRES).xyz +\n                 texture(iChannel1, vec2(probeUV.x + 0.5, probeUV.y + 1.5)*IRES).xyz +\n                 texture(iChannel1, (probeUV + 1.5)*IRES).xyz)*0.25*weight, weight);\n}\n\nvec3 IntegrateProbes(vec2 uv, vec3 p, vec3 n, vec3 lPos, mat3 lEyeMat) {\n    vec2 probeUV0 = floor(uv*0.5 - 0.5)*2.;\n    vec2 probeFUV = fract(uv*0.5 - 0.5);\n    vec4 S0 = IntegrateProbe(probeUV0, p, n, lPos, lEyeMat);\n    vec4 S1 = IntegrateProbe(probeUV0 + vec2(2., 0.), p, n, lPos, lEyeMat);\n    vec4 S2 = IntegrateProbe(probeUV0 + vec2(0., 2.), p, n, lPos, lEyeMat);\n    vec4 S3 = IntegrateProbe(probeUV0 + 2., p, n, lPos, lEyeMat);\n    return mix(mix(S0.xyz, S1.xyz, probeFUV.x), mix(S2.xyz, S3.xyz, probeFUV.x), probeFUV.y)/\n           mix(mix(S0.w, S1.w, probeFUV.x), mix(S2.w, S3.w, probeFUV.x), probeFUV.y);\n}\n\nvec4 pLF(vec2 uv, vec3 n, vec3 p, vec3 l2Pos, mat3 l2EyeMat, out float w) {\n    vec4 lPAttr = texture(iChannel0, vec2(uv.x, uv.y + HRES.y)*IRES);\n    if (lPAttr.w < -5.) {\n        w = 0.;\n        return vec4(0., 0., 0., 0.);\n    }\n    vec3 l2PNor = normalize(FloatToVec3(lPAttr.z)*2. - 1.);\n    vec3 l2PPos = l2Pos + normalize(vec3((uv*IHRES*2. - 1.)*ASPECT, 1.)*l2EyeMat)*lPAttr.w;\n    \n    w = max(0., (dot(l2PNor, n) - 0.5)/0.5*float(abs(dot(n, p - l2PPos)) < 0.05));\n    \n    float YOffset = floor(uv.x*I1024)*1024. + floor(uv.y*I1024)*3072.;\n    uv = mod(uv, 1024.) + vec2(0., YOffset);\n    return textureCube(uv)*w;\n}\n\nvec4 projectLastFrame(vec2 uv, vec3 n, vec3 p, vec3 l2Pos, mat3 l2EyeMat) {\n    vec2 probeUV0 = floor(uv - 0.5) + 0.5;\n    vec2 probeFUV = fract(uv - 0.5);\n    float W0, W1, W2, W3;\n    vec4 S0 = pLF(probeUV0, n, p, l2Pos, l2EyeMat, W0);\n    vec4 S1 = pLF(probeUV0 + vec2(1., 0.), n, p, l2Pos, l2EyeMat, W1);\n    vec4 S2 = pLF(probeUV0 + vec2(0., 1.), n, p, l2Pos, l2EyeMat, W2);\n    vec4 S3 = pLF(probeUV0 + 1., n, p, l2Pos, l2EyeMat, W3);\n    if (W0 + W1 + W2 + W3 == 0.) return vec4(0.);\n    return mix(mix(S0, S1, probeFUV.x), mix(S2, S3, probeFUV.x), probeFUV.y)/\n           max(0.0001, mix(mix(W0, W1, probeFUV.x), mix(W2, W3, probeFUV.x), probeFUV.y));\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3, rayDir);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z > max(aDir.x, aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.z < 0.) UV.y += 1024.;\n    } else if (aDir.x > aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.x > 0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.y > 0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    \n    //Temporal accumulation\n    vec2 RESOffset = vec2((mod(floor(UV.y*I1024)+0.5,3.)-0.5)*1024.,floor(UV.y*I1024/3.)*1024.);\n    vec2 CUV = mod(UV,1024.)+RESOffset;\n    if (iFrame > 2 && DFBox(CUV, HRES) < 0.) {\n        //Within screen\n        vec4 lMouse = texture(iChannel0, vec2(HRES.x + 1.5, HRES.y + 0.5)*IRES);\n        vec3 lPos = GetCameraPos(lMouse, IRES);\n        vec3 lEye = GetCameraEye(lMouse, IRES);\n        mat3 lEyeMat = TBN(lEye);\n        vec3 lDir = normalize(vec3((CUV*IHRES*2. - 1.)*ASPECT, 1.)*lEyeMat);\n        vec4 lAttr = texture(iChannel0, vec2(CUV.x + HRES.x, CUV.y)*IRES);\n        vec3 lNor = normalize(FloatToVec3(lAttr.z)*2. - 1.);\n        float lDist = lAttr.w;\n        if (lDist < -0.5) lDist = 100000.;\n        vec3 lPPos = lPos + lDir*lDist;\n        vec3 lProbeLight;\n        if (lAttr.w < -0.5) lProbeLight = GetSkyLight(lDir);\n        else lProbeLight = IntegrateProbes(CUV, lPPos, lNor, lPos, lEyeMat);\n        \n        vec4 l2Mouse = texture(iChannel0, vec2(HRES.x + 2.5, HRES.y + 0.5)*IRES);\n        vec3 l2Pos = GetCameraPos(l2Mouse, IRES);\n        vec3 l2Eye = GetCameraEye(l2Mouse, IRES);\n        mat3 l2EyeMat = TBN(l2Eye);\n        vec3 l2Dir = normalize(vec3((CUV*IHRES*2. - 1.)*ASPECT, 1.)*l2EyeMat);\n        vec3 l2Tan; vec3 l2Bit = TBN(l2Eye, l2Tan);\n        vec4 l2Attr = texture(iChannel0, vec2(CUV.x, CUV.y + HRES.y)*IRES);\n        vec3 l2Nor = normalize(FloatToVec3(l2Attr.z)*2. - 1.);\n        float l2Dist = l2Attr.w;\n        if (l2Dist < -0.5) l2Dist = 100000.;\n        vec3 l2PPos = l2Pos + l2Dir*l2Dist;\n        vec3 l2Proj3 = vec3(dot(lPPos - l2Pos, l2Tan), dot(lPPos - l2Pos, l2Bit), dot(lPPos - l2Pos, l2Eye));\n        vec2 l2Proj2 = ((l2Proj3.xy/l2Proj3.z)*0.5/(ASPECT) + 0.5)*HRES;\n        if (DFBox(l2Proj2, HRES) < 0.) {\n            //Valid reprojection\n            l2Proj2 = clamp(l2Proj2, vec2(0.5), vec2(HRES - 0.5));\n            \n            //Manual bilinear interpolation between probes\n            vec4 lOutput = projectLastFrame(l2Proj2, lNor, lPPos, l2Pos, l2EyeMat);\n            Output = vec4((lOutput.xyz*lOutput.w + lProbeLight)/(lOutput.w + 1.), min(15., lOutput.w + 1.));\n        } else {\n            //No history\n            Output = vec4(lProbeLight, 1.);\n        }\n    }\n    \n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lXByRh","date":"1734384982","viewed":1394,"name":"RC - Screen Space Probes","username":"Mathis","description":"Radiance cascades in 3D with screen space probes\nMerging is done by reprojecting individual ray hitpoints with visibility\n\nOnly temporal accumulation is used, no spatial denoising","likes":38,"published":1,"flags":32,"usePreview":1,"tags":["gi","cloud","global","illumination","point","cascades"],"hasliked":0,"parentid":"","parentname":""}}