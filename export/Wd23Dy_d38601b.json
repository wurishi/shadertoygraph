{"ver":"0.1","info":{"id":"Wd23Dy","date":"1549909210","viewed":134,"name":"Trig-Dreamz","username":"teraspora","description":"Mouse clicks:   left to right varies the scale, up and down varies the level of black. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sin","cos","disc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define PHI 1.6180339887 \n#define SQ2 1.4142135623\n\n// Gold Noise Â©2015 dcerisano@standard3d.com\nfloat gold_noise(in vec2 coord, in float seed) {\n    return fract(tan(distance(coord * (seed + PHI), vec2(PHI, PI))) * SQ2);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat iden(float x) {\n    return x;\n}\n\nvec2 nmouse() {\n    return iMouse.xy / iResolution.xy;\n}\n\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// Usefuk functions:\n\n\n// Colour fns.:\nfloat hue(vec3 col) {\n    return rgb2hsl(col).s;\n}\n\nvec3 changeHue(vec3 col, float newHue) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.s = newHue;\n    return hsl2rgb(colHSL);\n}\n\t\nvec3 saturate(vec3 col) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.t = 1.0;\n    return hsl2rgb(colHSL);    \n}\n\nfloat om(float x) {\t\t// one minus x\n    return 1. - x;\n}\n\nvec3 om(vec3 v) {\t\t// one minus v\n    return 1. - v;\n}\n\nfloat op(float x) {\t\t// one plus x \n    return 1. + x;\n}\n\n// Normalised trig fns.:\nfloat nsin(float x) {\n    return op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n    return op(cos(x)) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // MUTABLE PARAMETERS:\n    float blackThreshold = 0.8 + (nmouse().y + 0.25); // 1.1; // Best between 1.0 and 1.3\n    \n    // ==================================================================\n    \n    float t = (48. + iTime) * 32. * (nsin(iTime / 64.) + 0.5);\n    float scale =  0.3 + 6. * nmouse().x + 0.5 * nsin(t / 32.);\n    float asp = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy /iResolution.yy - vec2(asp, 1.) * .5;\n    float uvl = length(uv);\t\t// save to use later framing viewport\n    vec2 st = uv;\n    float rotationSense1 = 1.  + 0.1 *sin(length(uv));\n    float rotationSense2 = -1. - 0.1 *sin(length(uv));uv = abs(uv) / scale;\n    uv += vec2(0.002 * sin(abs(uv.y) * t / 8.), 0.003 * sin(abs(uv.x) * t / 12.));\n    uv = rotate(uv, t / 256. * rotationSense1 * rotationSense2);\n    uv.y += 0.32 * sin(uv.x * 8. * cos(t / 1600.)) + 0.31 * sin(uv.x * 23. * cos(t / 1100.));    \n    uv.x += 0.32 * sin(uv.y * 17. * cos(t / 2900.)) + 0.33 * sin(uv.y * 31. * cos(t / 1900.));    \n    \n    uv.y += 0.31 * sin(uv.x * 53. * cos(t / 1700.)) + 0.325 * sin(uv.x * 41. * cos(t / 4700.));    \n    uv.x += 0.31 * sin(uv.y * 71. * sin(t / 2600.)) + 0.33 * sin(uv.y * 43. * cos(t / 6100.));    \n    vec3 col = hue2rgb(atan(uv.y, uv.x) / 2. / PI + .5);\n\t\n    col *= step(0., blackThreshold - length(col));\n    col = saturate(col);\n    float cdelta = mod(t / 64., 32.) / 32.;\n    col = changeHue(col, fract(hue(col) + cdelta)); \n    // Make the frame a disc:\n    col = step(uvl, 0.5) * col;\n    \n    // Add some old-style interference! \n    for (int i = 0; i < 2; i++) {\n      \t vec2 pos = vec2(asp * (gold_noise(uv, 97. / (float(i) + 1.)) - 0.5),\n                         gold_noise(uv.yx, 43. / (float(i) + 3.)) - 0.5);\n         col += vec3(1., 1., 1.) * step(distance(st, pos), 0.005);\n\t}\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}