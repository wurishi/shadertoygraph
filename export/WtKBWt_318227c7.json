{"ver":"0.1","info":{"id":"WtKBWt","date":"1615285578","viewed":97,"name":"raymarch edge detect 1","username":"milez770","description":"forked from my own project\nsimple pixel differencing","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"3lKczD","parentname":"ray is marching"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat threshold(in float thr1, in float thr2 , in float val) {\n // threshhold 보다 낮으면 0, 높으면 1\n if (val < thr1 ) {return 0.0;}\n if (val > thr2 ) {return 1.0;}\n return val;\n}\n\nfloat avg_intensity(in vec4 pix) {\n return (pix.r + pix.g + pix.b)/3.;\n}\n\n vec4 get_pixel (in vec2 coords, in float dx, in float dy) {\n return texture(iChannel0, coords + vec2(dx, dy) ).xyzw;   \n\n}\n\nfloat IsEdge(in vec2 coords)\n{\n  float dxtex = 1.0 / iChannelResolution[0].x; //512.0 /*image width*/;\n  float dytex = 1.0 / iChannelResolution[0].y; //512.0 /*image height*/;\n  float pix[9];\n  int k = -1;\n  float delta;\n    \n     pix[0] = avg_intensity(get_pixel(coords,float(-1)*dxtex, float(-1)*dytex));\n     pix[1] = avg_intensity(get_pixel(coords,float(-1)*dxtex, float(0)*dytex));\n     pix[2] = avg_intensity(get_pixel(coords,float(-1)*dxtex, float(1)*dytex));\n     pix[3] = avg_intensity(get_pixel(coords,float(0)*dxtex, float(-1)*dytex));\n     pix[4] = avg_intensity(get_pixel(coords,float(0)*dxtex, float(0)*dytex));\n     pix[5] = avg_intensity(get_pixel(coords,float(0)*dxtex, float(1)*dytex));\n     pix[6] = avg_intensity(get_pixel(coords,float(1)*dxtex, float(-1)*dytex));\n     pix[7] = avg_intensity(get_pixel(coords,float(1)*dxtex, float(0)*dytex));\n     pix[8] = avg_intensity(get_pixel(coords,float(1)*dxtex, float(1)*dytex));\n\n  // average color differences around neighboring pixels\n  delta = (abs(pix[1]-pix[7])+\n          abs(pix[5]-pix[3]) +\n          abs(pix[0]-pix[8])+\n          abs(pix[2]-pix[6])\n           )/4.;\n\n  return threshold(0.1,0.5,clamp(2.5*delta,0.0,1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord.xy/iResolution.xy;\n   vec4 col = vec4(IsEdge(uv));\n   col = 1.-col;\n   \n   \n   fragColor = col;\n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 1000.\n#define SURF_DIST 0.0001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    //p.xz *= Rot(iTime);\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p){\n    // sphere position\n    vec4 s = vec4(0, 1, 6, 1);\n    // point to sphere dist\n    // point to plane dist\n    float planeDist = dot(p, normalize(vec3(0, 1, 0)));\n    \n    vec3 sp = p;\n    sp.xz *= Rot(iTime);\n    sp -= vec3(1., 1, 0);\n    sp.xz *= Rot(iTime*2.);\n    float sphereDist = length(p-s.xyz)-s.w;\n    \n    vec3 bp = p;\n    bp.xz *= Rot(iTime);\n    bp -= vec3(3., 1, 0);\n    bp.xz *= Rot(iTime*2.);\n    float box = dBox(bp, vec3(1.));\n    \n    vec3 cp = p;\n    cp.xz *= Rot(iTime*1.5);\n    cp -= vec3(2., 1, 0);\n    //cp.xz *= Rot(iTime*10.);\n    \n    float cd = sdCapsule(cp, vec3(0, 0, 0), vec3(0, 1, .5), .8);\n    \n    vec3 tp = p;\n    tp -= vec3(0, 2, 0);\n    tp.yz *= Rot(iTime);\n    tp.xy *= Rot(iTime);\n    float td = sdTorus(tp - vec3(0, .0, 0), vec2(1.5, .2));\n    \n    vec3 bdp = p-vec3(0, 1, 0);\n    float scale = mix(1., 2., smoothstep(0., 1., bdp.y));\n    bdp.xz *= scale;\n    bdp.xz *= Rot(smoothstep(0., 1., bdp.y) - iTime);\n    \n    float bd = dBox( bdp , vec3(1) )/scale;\n    //bd -= sin(p.x*8.+iTime*2.7)*.1;\n    //bd = abs(bd)-.1;\n    \n    float blend = smin(td, box, .8);\n    float blend2 = smin(blend, box, .8);\n    \n    // plane or sphere\n    float d = 10000.;\n    //cd = abs(cd);\n    d = min(d, bd);\n    d = min(d, planeDist);\n    d = min(d, blend);\n    //d = min(d, bd);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    // dist from origin\n    float dO = 0.;\n    \n    // march till Max step\n    for(int i=0; i<MAX_STEPS; i++){\n        // marched point\n        vec3 p = ro + rd*dO;\n        // distance from marched point\n        float dS = GetDist(p);\n        // move marched point\n        dO += dS;\n        // if march end break \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    // distance from p to sphere\n    float d = GetDist(p);\n    // very small number for diff\n    vec2 e = vec2(.001, 0);\n    \n    // getting vector with very small vector\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(3, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);    \n   // float d = RayMarch(p+n*SURF_DIST*2., l);\n\n    if(d<length(lightPos - p)) dif *= .3;\n    \n    return dif;\n    \n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    \n    float d = RayMarch(ro, rd);\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n    \tcol = vec3(dif);\n    }\n    \n    vec3 p = ro+rd*d;\n\n    float dif = GetLight(p);\n    col = vec3(dif);;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}