{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Vivek Reddy \t\thttps://github.com/vivreddy\n// Rohith Chandran\thttps://github.com/rohith10\n// GPU Programming and Architecture Hackathon, University of Pennsylvania\t(17 Nov 2013)\n// http://www.seas.upenn.edu/~cis565\n\nfloat raySphereIntersect (vec3 origin, vec3 direction, vec3 center, float radius);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat amplitude = 0.8 * texture (iChannel0, vec2 (uv.x, 0.2)).x;\n//\tamplitude *= 0.8;\n\t\n\t//Camera Movement\n\tvec3 sphereCenter = vec3(0.0,0.0,0.0);\n\tfloat radius = 36.0;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\tfloat xAnim = 6.0*mouse.x;\n\tfloat yAnim = 6.0*mouse.y;\n\t\n\t// Hotfix to correctly orient the viewport at page load.\n\tif (xAnim == 0.0)\n\t\txAnim = 10.0;\n\tif (yAnim == 0.0)\n\t\tyAnim = 50.0;\n\t\n    vec3 eye = radius*normalize(vec3(sin(yAnim)*cos(xAnim), cos(yAnim)-0.1, sin(yAnim)*sin(xAnim)));\n    vec3 camZ = normalize(sphereCenter - eye);\n    vec3 camX = normalize(cross( vec3(0.0,1.0,0.0), camZ ));\n    vec3 camY = normalize(cross(camZ,camX));\n    vec3 direction = normalize( p.x*camX + p.y*camY + camZ );\n\t\n\t// Ray cast:\n\tvec3 view = camZ;\n    float lenEyeToProjCentre = 5.0;\n\n\tvec3 centreProj = eye + view*lenEyeToProjCentre;\n\tvec3 up = camY;\n\tvec2 fov = vec2 (60.0, 45.0);\n\t\t\n\tfloat degToRad = 3.1415926 / 180.0;\n\tvec3 origin = eye;\n\n\t\n\tvec3 A = cross (centreProj, up);\n    vec3 B = cross (A, centreProj);\n        \n    vec3 halfVecH = normalize (A) * lenEyeToProjCentre * tan (fov.x*degToRad);\n    vec3 halfVecV = normalize (B) * lenEyeToProjCentre * tan (fov.y*degToRad);\n\t\n\tvec3 P = centreProj + (2.0*uv.x - 1.0)*halfVecH + (2.0*uv.y - 1.0)*halfVecV;\n\tdirection = normalize (P - origin);\n\t\n\t// Render background:\n\tvec3 color = texture (iChannel1, direction).xyz;\n\t\n//\tvec3 center = vec3 (cos(3.0+iTime), 0.0, 0.0);\n\tvec3 center [6];\n\tcenter[0] = vec3(0.0,0.0,0.0) + vec3 (cos(3.0+iTime), 0.0, 0.0);\n\tcenter[1] = 36.0*amplitude*vec3(cos (iTime),0.0,sin (iTime)) + vec3 (cos(3.0+iTime), 15.0*amplitude*sin (3.0+iTime), 0.0);\n    center[2] = 36.0*amplitude*vec3(cos (20.0+iTime),0.0,sin (20.0+iTime)) + vec3 (cos(3.0+iTime), 15.0*amplitude*sin (3.0+iTime), 0.0);\n    center[3]  = 36.0*amplitude*vec3(cos (40.0+iTime),0.0,sin (40.0+iTime)) + vec3 (cos(3.0+iTime), 15.0*amplitude*sin (3.0+iTime), 0.0);\n    center[4]  = 36.0*amplitude*vec3(cos (60.0+iTime),0.0,sin (60.0+iTime)) + vec3 (cos(3.0+iTime), 15.0*amplitude*sin (3.0+iTime), 0.0);\n    center[5]  = 36.0*amplitude*vec3(cos (80.0+iTime),0.0,sin (80.0+iTime)) + vec3 (cos(3.0+iTime), 15.0*amplitude*sin (3.0+iTime), 0.0);\n\t\n\tfloat t = 10000.0;\n\tvec3 minJ = vec3 (0);\n\tbool intr = false;\n\tfor (int j = 0; j < 6; ++ j)\n\t{\n\t\tfloat t2 = raySphereIntersect (origin, direction, center [j], 7.0);\n\t\tif (t2 > 0.0)\n\t\t{\n\t\t\tvec3 iPt = origin + t2 * direction;\n\t\t\t\n\t\t\tfloat stepSize = 5.0 / 20.0;\n\t\t\t// Ray march:\n\t\t\tfor (int loopVar = 0; loopVar < 20; loopVar ++)\t\t// Hack to get for loop working.\n\t\t\t{\t\t\t\t\t\t\n\t\t\t\tfloat curSample = length (iPt - center[j]);\n\t\t\t\t\n\t\t\t\tif (curSample < (4.0 + amplitude))\t// We have marched past the heightfield. Stop.\n\t\t\t\t{\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\t\t// Otherwise, step through to the next step.\n\t\t\t\t{\t\n\t\t\t\t\tiPt += stepSize * direction;\n\t\t\t\t\tt2 += stepSize;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (t2 < t)\n\t\t\t{\n\t\t\t\tt = t2;\n\t\t\t\tminJ = center[j];\n\t\t\t\tintr = true;\n\t\t\t}\t\t\t\n\t\t}\n\t}\t\n\t\n\tif (intr)\n\t{\n\t\tvec3 iPt = origin + t * direction;\n\t\tvec3 normal = normalize(iPt-minJ);\n\t\tdirection = reflect (direction, normal); \n\t\tcolor = texture (iChannel1, direction).xyz;\n\t}\n\tfragColor = vec4(color,1.0);\n}\n\nfloat raySphereIntersect (vec3 origin, vec3 direction, vec3 center, float radius)\n{\n\tfloat radiusSqr = radius * radius;\n\tvec3 l = center - origin;\n\tfloat s = dot (l, direction);\n\tfloat lSquared  = dot (l, l);\n\t\n\tif ((s < 0.0) && (lSquared > radiusSqr))\n\t\treturn -1.0;\n\t\n\tfloat mSquared = lSquared - (s*s);\n\tif (mSquared > radiusSqr)\n\t\treturn -1.0;\n\t\n\tfloat q = sqrt (radiusSqr - mSquared);\n\tif (lSquared > radiusSqr)\n\t\treturn s - q;\n\t\n\treturn s + q;\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xsj3zD","date":"1384652643","viewed":275,"name":"Sphroove","username":"rohith10","description":"Spheres that groove to the music.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","sphere"],"hasliked":0,"parentid":"","parentname":""}}