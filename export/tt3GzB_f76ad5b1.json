{"ver":"0.1","info":{"id":"tt3GzB","date":"1576705271","viewed":244,"name":"FBM3 Demo","username":"gigatron","description":"Maybe for Revision 2050 ;!\n","likes":7,"published":1,"flags":64,"usePreview":0,"tags":["filterfbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llS3Rz","filepath":"https://soundcloud.com/fuujin/talamasca-overload","previewfilepath":"https://soundcloud.com/fuujin/talamasca-overload","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" // Gigatron France \n\n#define DOWN_SCALE 2.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n/*\n--------\n-###----\n##-##---\n##-##---\n-###----\n#####-#-\n##-####-\n##--##--\n##-###--\n-###-##-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\n \nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\n \n//vec2 res = iResolution.xy / DOWN_SCALE;\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n \n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\nfloat text(vec2 uv)\n{\n    float col = 0.0;\n    float t=mod(iTime,20.);// scroll duration \n    vec2 center = vec2(40.,30.);\n    \n    float time = iTime;\n    \n    float angle = time;\n    \n    if (time>20.0) {\n        uv = uv*2.-1.0;\n\t\n        t=2.4;\n    }\n    \n    print_pos = (vec2(160.-t*32.0,3.0+abs(16.*sin(t*4.))) - vec2(STRWIDTH(1.0),STRHEIGHT(1.0))/2.0);\n    \n    col += char(ch_S,uv);\n    col += char(ch_H,uv);\n    col += char(ch_A,uv);\n    col += char(ch_D,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    col += char(ch_T,uv);\n    col += char(ch_O,uv);\n    col += char(ch_Y,uv);\n    \n    col += char(ch_spc,uv);\n  \n\tcol += char(ch_R,uv);\n    col += char(ch_E,uv);\n    col += char(ch_V,uv);\n    col += char(ch_I,uv);\n    col += char(ch_S,uv);\n    col += char(ch_I,uv);\n    col += char(ch_O,uv);\n    col += char(ch_N,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_D,uv);\n    col += char(ch_E,uv);\n    col += char(ch_M,uv);\n    col += char(ch_O,uv);\n       \n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_B,uv);\n    col += char(ch_Y,uv);\n    \n    \n    col += char(ch_spc,uv);\n\n    col += char(ch_G,uv);\n    col += char(ch_I,uv);\n    col += char(ch_G,uv);\n    col += char(ch_A,uv);\n    col += char(ch_T,uv);\n    col += char(ch_R,uv);\n    col += char(ch_O,uv);\n    col += char(ch_N,uv);\n    \n    \n    col += char(ch_spc,uv);\n  \n    return col;\n}\n\nfloat tyou(vec2 uv)\n{\n    float col = 0.0;\n    float t=mod(iTime,20.);// scroll duration \n    vec2 center = vec2(40.,30.);\n    \n    float time = iTime;\n    \n    float angle = time;\n    \n    if (time>20.0) {\n        uv = uv*2.-1.0;\n\t\n        t=2.4;\n    }\n    \n    print_pos = (vec2(160.-t*32.0,120.0+abs(16.*sin(t*4.))) - vec2(STRWIDTH(1.0),STRHEIGHT(1.0))/2.0);\n    \n    col += char(ch_T,uv);\n    col += char(ch_H,uv);\n    col += char(ch_A,uv);\n    col += char(ch_N,uv);\n    col += char(ch_K,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_O,uv);\n    col += char(ch_U,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_exc,uv);\n    \n    col += char(ch_exc,uv);\n    \n    col += char(ch_exc,uv);\n  \n\t\n    return col;\n}\n\n#define OCTAVES 5\n#define generaltimer iTime\n \nvec3 hsv2rgb(  vec3 c )\n{\n vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nfloat random(vec2 st) {\n\treturn fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\t\n\tfloat a = random(i + vec2(0.0, 0.0));\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\t\n\tfloat result = mix(a, b, u.x) + (c-a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n\t\n\treturn result;\n\t\n}\n\nfloat fbm(vec2 st) {\n\tfloat value = 0.0;\n\tfloat amplitude = .5;\n\tfloat frequency = 0.0;\n\t\n\tfor (int i = 0; i < OCTAVES; i++) {\n\t\tvalue += amplitude * noise(st);\n\t\tst *= 8.0;\n\t\tamplitude *= 0.5;\n\t}\n\treturn value;\n}\n\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n\t\n    float time = iTime;\n     \n    vec2 uv = 2048.*fragCoord.xy / iResolution.xy;\n\tfloat pixel = text(uv*0.065);\n    \n    \n    \n    vec3 tx = texture(iChannel0,p).xyz;\n    \n    \n    \n\t\n\tvec3   color = hsv2rgb(vec3(time*0.15,1.0,1.0)) ;\n    \n    //vec3 color = hsv2rgb(vec3(tx )) ;\n\t\n\t      color += fbm(p + fbm(p * 5.0) + vec2(time*0.1,time*0.2))+tx.r;\n\t      color *= fbm(p + fbm(p * 3.0) - vec2(time*0.2,time*0.1))*tx.g;\n   \t\t  color *= fbm(p + fbm(p * 1.0) + vec2(time*0.2,time*0.1))*tx.b;\n \n    vec2 q = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(q,-1.5) );\n\t\n    // box animation\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,2.*sin(iTime)*2.0,-4.0)), 2.*sin(iTime)*2.0 );\n\tmat4 tra = translate( -0.5*  sin(iTime*2.) , -.5+abs(sin(iTime*4.)*2. ), 0.5*sin(iTime) );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\tvec3 box = vec3(1.,1.,1.) ;\n\n   \n    vec3 col = vec3(0.0);\n \n\n    vec4 res = boxIntersect( ro, rd, txx, txi, box );\n      \n   \n        float t2 = res.x;\n  \n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.yzw ;\n\t\tcol = hsv2rgb(vec3(time*0.25,1.0,1.0));\n \n\t\tvec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n\t\tcol *= abs(onor.x)*texture( iChannel2, 0.5+0.5*opos.yz ).xyz + \n               abs(onor.y)*texture( iChannel2, 0.5+0.5*opos.zx ).xyz + \n               abs(onor.z)*texture( iChannel2, 0.5+0.5*opos.xy ).xyz;\n      //  col *= 0.7;\n        col *= 0.9 + 0.4*nor.x;\n    \n    \tif(time>15.0 ) col += 0.5 + 0.6*nor.x;\n    \tif(time>30.0 ) col += 0.05 + 0.05*nor.x;\n        if(time>45.0 ) col *= 0.5 + 0.3*nor.x;\n        if(time>60.0 ) col  -= 0.2 * 0.6+nor.x;\n        if(time>75.0 ) col  += 0.01 + 0.02+nor.x;\n        if(time>85.0 ) col  /= 0.1 + 0.2+nor.x;\n        if(time>105.0) col  += -0.1 - 0.2+nor.x;\n        if(time>120.0) col  -= 0.4 + 0.3*nor.x;\n        if(time>135.0) col  *= -0.5;\n        if(time>145.0) col  *= 2.*nor;\n        if(time>160.0) col  -= -0.8+0.2*nor;\n        if(time>185.0) {col  *= -0.9;}\n        if(time>200.0) {col  += -1.59*nor.x;} \n        if(time>220.0) {col  -=0.2+  .79*nor.x;} \n    \t \n    \n    vec2 l = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 c = vec3(0.005, 0.0021, 0.009);  \n\tvec3 lightCol = vec3(0.1 + 0.09, 0.23, 0.6 + 0.024 * tan (time * 2.2));\n    float xm = texture( iChannel1,l).y;\n\tfor(int i = 0; i <10; ++i) {\n        \tfloat t = 0.8 * 3.14 * float(i) / 5.5 * time * .5;\n        \tfloat x = cos(t)*4.0;\n        \tfloat y = sin(t);\n        \tvec2 o = .5 * vec2(x   -  y, y)*sin(time);\n                \n        \tc += (0.3*abs(sin(time))) / (length(q - o)) * lightCol * 0.5;\n         \n    }\n\t \n    \n    \n        \n    fragColor = vec4( color+(col*1.50)*c.y+pixel , 1.0 ); \n    \n    if(time>235.0)    {   \n                       float fade =sin(time*0.15);\n                       box = vec3(0.,0.,0.);\n                       tx  = vec3(0.0,0.0,0.0);\n                       \n                       fragColor = vec4( (color+(col*1.50)*c.y+pixel)\n                                        , 1.0 )+fade;  \n                       }// restart fx timeline ;\n\n    \n    \n                 if(time>245.0) {       \n                       \n                 pixel = tyou(uv*0.065);\n                 fragColor = vec4(  pixel,pixel,pixel, 1.0 );\n                 }// restart fx timeline ;\n\n\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}