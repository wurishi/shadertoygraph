{"ver":"0.1","info":{"id":"XljXzy","date":"1444662840","viewed":287,"name":"Understanding spikey ball","username":"cabbibo","description":"Trying to understand the spikey ball shader\n\nhttps://www.shadertoy.com/view/MljXDw","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","sdf","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\n\n\tTrying to understand the spikey cloud ball shader:\n\thttps://www.shadertoy.com/view/MljXDw\n\n\n*/\n\n// port from http://glslsandbox.com/e#1802.0 with some modifications\n//--------------\n// Posted by las\n// http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(3., 2., 1.)/3.)*6.-3.)-1.), 0., 1.), s)*v\n\n\n/* original noise\nfloat pn(vec3 p) {\n   vec3 i = floor(p);\n   vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n   vec3 f = cos((p-i)*pi)*(-.5) + .5;\n   a = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n   a.xy = mix(a.xz, a.yw, f.y);\n   return mix(a.x, a.y, f.z);\n}\n*/\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n// Getting a few different noises\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\n\n\nfloat spikeball(vec3 p) {\n   vec3 q=p;\n   p = normalize(p);\n\n    \n   //b = length( p ) - .5;\n   return length(q)-2.5;//*pow(1.5,b.x*(1.-mix(.3, 1., sin(iTime*2.)*.5+.5)*b.x));\n}\n\nfloat map(vec3 p) {\n   p.z += 6.;\n   //R(p.xy, iTime);\n   //R(p.xz, iTime);\n   return spikeball(p) +  fpn(p*50.) * 0.45;\n}\n\nvec3 g(vec3 p) {\n   vec2 e = vec2(.0001, .0);\n   return normalize(vec3(map(p+e.xyy) - map(p-e.xyy),map(p+e.yxy) - map(p-e.yxy),map(p+e.yyx) - map(p-e.yyx)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   // p: position on the ray\n   // d: direction of the ray\n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((gl_FragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   d = normalize(d); \n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0., td=0.;\n   float w=0.;\n   \n   // total color\n   vec3 tc = vec3(0.);\n   \n   // i: 0 <= i <= 1.\n   // r: length of the ray\n   // l: distance function\n   float r=0., l=0., b=0.;\n\n   // rm loop\n   for (float i=0.; (i<1.); i+=1./16.) {\n\t   if(!((i<1.) && (l>=0.001*r) && (r < 10.)&& (td < .95)))\n\t\t   break;\n      \n      // evaluate distance function\n      l = map(p) * 0.5;\n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      const float h = .4;\n      ld = (h - l) * step(l, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w* hsv( w , 1. , 1. ); // * hsv(w*3.-0.5, 1.-w*20., 1.); \n      td += w;\n       \n      td += 1./200.;\n      \n      // enforce minimum stepsize\n      l = max(l, 0.03);\n      \n      // step forward\n      p += l*d;\n      r += l;\n   }     \n      \n   fragColor = vec4(tc, 1.0); //vec4(tc.x+td*2., ld*3., 0, tc.x);\n}","name":"","description":"","type":"image"}]}