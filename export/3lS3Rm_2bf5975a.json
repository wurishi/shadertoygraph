{"ver":"0.1","info":{"id":"3lS3Rm","date":"1558801275","viewed":1574,"name":"Stochastic Triplanar Sampling","username":"miloyip","description":"Left: Triplanar mapping with 3 texture sample per fragment\nRight: Stochastic triplanar mapping with 1 texture sample per fragment\n\nOriginal idea from https://www.gdcvault.com/play/1025480/Terrain-Rendering-in-Far-Cry","likes":15,"published":1,"flags":0,"usePreview":1,"tags":["triplanar","stochastic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TIGHT_BLEND 1\n\nfloat PI = 3.14159265359;\nmat3 rot;\n    \nmat3 rotationXY(vec2 angle) {\n\tvec2 c = cos(angle);\n\tvec2 s = sin(angle);\n\treturn mat3(\n\t\tc.y, 0.0, -s.y,\n\t\ts.y * s.x, c.x, c.y * s.x,\n\t\ts.y * c.x, -s.x, c.y * c.x\n\t);\n}\n\n// Wyman, Chris, and Morgan McGuire. \"Hashed alpha testing.\" \n// Proceedings of the 21st ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games. ACM, 2017.\nfloat hash(vec2 p) {\n   return fract(1.0e4 * sin(17.0 * p.x + 0.1 * p.y) * (0.1 + abs(sin(13.0 * p.y + p.x))));\n}\n\nfloat hash3D(vec3 p) {\n   return hash(vec2(hash(p.xy), p.z));\n}\n\nvec4 sampling(vec2 p) {\n    if (length(p) <= 1.0) {\n        // normal = 3D position on unit sphere\n        vec3 n = rot * vec3(p, sqrt(1.0 - dot(p, p)));\n        \n#if TIGHT_BLEND\n        vec3 a = max(vec3(0.0), abs(n) - sqrt(3.0)/3.0);\n        vec3 w = a / (a.x + a.y + a.z);\n#else\n        vec3 w = n * n;\n#endif\n        \n        if (p.x > 0.0) {\n            vec2 g; // maximum projection\n            if (w.x > w.y && w.x > w.z)\n                g = n.yz;\n            else if (w.y > w.z)\n                g = n.xz;\n            else\n                g = n.xy;\n\n            float pixDeriv = length(vec2(length(dFdx(n)), length(dFdy(n))));\n            float pixScale = 1.0 / pixDeriv;\n\n            float h = hash3D(floor(n * pixScale));\n            \n            vec2 t;\n            if (w.z > h)\n                t = n.xy;\n            else if (w.z + w.y > h)\n                t = n.xz;\n            else\n                t = n.yz;\n\n            //return vec4(t * 0.5 + 0.5, 0, 1);\n            return textureGrad(iChannel0, t, dFdx(g), dFdy(g));\n        }\n        else {\n            //return vec4(w, 1);\n            return \n                texture(iChannel0, n.xy) * w.z + \n                texture(iChannel0, n.xz) * w.y + \n                texture(iChannel0, n.yz) * w.x;\n        }\n    }\n    else\n        return vec4(1, 1, 1, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (fragCoord.xy / iResolution.xy - 0.5) * vec2(2.0 * iResolution.x / iResolution.y, 2.0);\n    rot = rotationXY(vec2(iMouse.yx / iResolution.yx) * vec2(PI, -2.0 * PI) + vec2(PI * -0.5, PI * 0.5));\n    fragColor = sampling(p);\n}\n","name":"Image","description":"","type":"image"}]}