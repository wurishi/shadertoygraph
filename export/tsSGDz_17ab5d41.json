{"ver":"0.1","info":{"id":"tsSGDz","date":"1548603896","viewed":125,"name":"mandelbrot study","username":"Myro","description":"I've heard that a mandelbrot set is the \"hello world\" of glsl programming. so here I am.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","mandelbrot","study","exploration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// mandelbrot set algorithm study\n// explore the mandelbrot set by clicking and dragging left and right\n\n\n// mandelbrot set largely inspired by http://glslsandbox.com/e#51677.2\n// colors by https://iquilezles.org/articles/palettes\nprecision mediump float;\n\n#define ITERATION 360\n\n// cosine based palette, 4 vec3 params\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette (float t) {\n    return cosineColor( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(0.01,0.01,0.01),vec3(0.0,0.10,0.20) );\n}\n\n// rendering the mandelbrot set using Escape time algorithm\n// https://en.wikipedia.org/wiki/Mandelbrot_set#Escape_time_algorithm\n// given a point p, returns a color corresponding to the escape time of this point\n\n// ie: we iterate a number of times on this point and return a color corresponding \n// to the number of iteration needed to determine that the pixel is not in the set (escape condition)\n// if p is in the set, we reach tha max number of iterations allowed and the color returned is black\n//   note: p is in the set only if (-2.5 < p.x < 1 && -1 < p.y < 1)\nvec3 mandelbrot(vec2 p) {\n    // r: tmp point used to iterate\n    vec2 r = p;\n    // l: distance between r and the origin. escape time reached if (l > 2)  \n    float l;\n    // d: fancy number only used to compute the color\n    float d = 0.0;\n\n    for (int i = 0; i < ITERATION; i++) {\n        // mandelbrot iteration magic\n        r = vec2(r.x * r.x - r.y * r.y + p.x, 2.0 * r.x * r.y + p.y);\n        l = length(r);\n        //d += l + 0.2;\n        d = float(i) - log2(log2(l));\n        if (l > 2.0) return palette(d);\n  \t}\n  \treturn vec3(1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // a used to de-strech the image\n  \tvec2 a = iResolution.xy / min(iResolution.x, iResolution.y);\n\n\tvec2 p = ((fragCoord.xy / iResolution.xy) * 4.0  - 2.0) * a;\n  \n    //freq & f used to pilot the zoom animation\n  \tfloat freq = 0.05;\n    float f = sin( 6.28318*((iTime-1.0) * freq)) * 0.5 + 0.5;\n    \n  \tp -= ( iMouse.xy / iResolution.xy-vec2(0.5) )* 5.0;\n  \tp *= pow(1.5, f * (-31.0));\n  \t\n    // (x,y): the point on the mandelbrot set we are zooming in    \n    float theta = 6.28318 * iMouse.x / iResolution.x, r, x, y;\n    \n\n    // UNCOMMENT ONE OF THE FOLLOWING LINES TO ZOOM ON DIFFERENT COOL PARTS OF THE SET\n    \n\t//some cool points\n    //x = 0.001643721971153; y = 0.822467633298876);\n    //x = -1.002029; y = 0.303864;\n\n    // the boundary of the main cardioid\n     r = (1.0005 - cos(theta))/2.0; x = r*cos(theta)+0.25; y = r*sin(theta);\n    \n    // the boundary of the period 2 disk\n    //r = 0.256, x = r*cos(theta)-1.0; y = r*sin(theta);\n    \n\t// the spike along the negative real axis\n\t// x = -1.405 - 0.3 * (sin(theta)+1.0); y = 0.0;\n        \n    p += vec2(x,y);    \n    fragColor = vec4(1.0 - mandelbrot(p), 1.0);\n}","name":"Image","description":"","type":"image"}]}