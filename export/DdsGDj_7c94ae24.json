{"ver":"0.1","info":{"id":"DdsGDj","date":"1666818375","viewed":102,"name":"Map and inverse map test","username":"Envy24","description":"Map for split screen shaders.\n\nSome examples:\nhttps://www.shadertoy.com/view/DdsGWj\nhttps://www.shadertoy.com/view/mdf3DM\nhttps://www.shadertoy.com/view/mdXGWB","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test","map","inverse","unmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n\n/* Maps screen coordinates to offsetted normalized device coordinate,\n   with aspect ratio correction. */\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    /**/\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    SC -= M;                         // apply mouse offset\n    /**/\n    SC = 2. * SC - R.xy;             // map xy from [0; R.x][0; R.y] to [-R.x; R.x][-R.y; R.y]\n    SC /= R.y;                       // map xy from [-R.x; R.x][-R.y; R.y] to [-AR; AR][-1; 1]\n    SC *= scale;                     // map xy from [-AR;AR][-1;1] to [-AR*scale; AR*scale][-scale; scale]    \n    return SC - origin;              // shift to new origin.\n}\n\n/* Undo previous mapping. */\nvec2 unmap_from_centered_ndc(in vec2 NDC, in float scale, in vec2 origin)\n{\n    NDC += origin;                   // shift to old origin.\n    NDC /= scale;                    // map xy from [-AR*scale; AR*scale][-scale; scale] to [-AR;AR][-1;1]\n    NDC *= R.y;                      // map xy from [-AR; AR][-1; 1] to [-R.x; R.x][-R.y; R.y]\n    NDC = 0.5 * (NDC + R.xy);        // map xy from [-R.x; R.x][-R.y; R.y] to [0; R.x][0; R.y]\n    /**/\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    NDC += M;                        // apply mouse offset\n    /**/\n    return NDC;        \n}\n\n/* Short versions */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc2(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\nvec2 unmap_from_centered_ndc2(in vec2 NDC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((((NDC + origin) / scale) * R.y) + R.xy) * 0.5 + M;       \n}\n\n/*Matrix form in homogeneous coordinates*/\nvec2 map_to_centered_ndc3(in vec2 SC, in float scale, in vec2 origin)\n{\n    vec2 M = MOUSE_OFFSET;\n    float s = scale / R.y;\n\n    vec3 P = mat3(              2.*s,                             0., 0.,\n                                  0.,                           2.*s, 0.,\n        -s*(2.*M.x + R.x) - origin.x,   -s*(2.*M.y + R.y) - origin.y, 1.) * vec3(SC, 1);\n\n    return P.xy;\n}\nvec2 unmap_from_centered_ndc3(in vec2 NDC, in float scale, in vec2 origin)\n{\n    vec2 M = MOUSE_OFFSET;\n    float c = R.y/(2.*scale);\n\n    vec3 P = mat3(                c,                           0., 0.,\n                                 0.,                            c, 0.,\n         c*origin.x + R.x*0.5 + M.x,   c*origin.y + R.y*0.5 + M.y, 1.) * vec3(NDC, 1);\n\n    return P.xy;      \n}\n\n/**\n#define MAP(SC, scale, origin) ( map_to_centered_ndc(SC, scale, origin) )\n#define INVMAP(SC, scale, origin) ( unmap_from_centered_ndc(SC, scale, origin) )\n/**/\n#define MAP(SC, scale, origin) ( map_to_centered_ndc2(SC, scale, origin, true) )\n#define INVMAP(SC, scale, origin) ( unmap_from_centered_ndc2(SC, scale, origin, true) )\n/**\n#define MAP(SC, scale, origin) ( map_to_centered_ndc3(SC, scale, origin) )\n#define INVMAP(SC, scale, origin) ( unmap_from_centered_ndc3(SC, scale, origin) )\n/**/\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float scale = 1.2;\n    vec2 origin =  vec2(0.25);\n    \n    vec2 NDC = MAP(SC, scale, origin);\n         SC = INVMAP(NDC, scale, origin);\n         \n    /* MAP test. Apply shift, scale, and mouse offset. */\n         // (White) Draw disk, rotated around current origin, with length 1 orbit.\n         vec3 color = mix( vec3(0), vec3(1),     smoothstep(4./R.y, 0., diskSDF_L2(NDC, vec2(cos(iTime), sin(iTime)), 10./R.y)) );\n         // (Green) Draw disk in current origin of coordinate system.\n              color = mix( color,   vec3(0,1,0), smoothstep(4./R.y, 0., diskSDF_L2(NDC, vec2(0),                      10./R.y)) );\n         // (Red) Draw disk in old origin of coordinate system.\n              color = mix( color,   vec3(1,0,0), smoothstep(4./R.y, 0., diskSDF_L2(NDC, -origin,                      10./R.y)) );\n         // You can drag scene with mouse.\n         \n    /* INV_MAP test. Undo shift, scale, and mouse offset. *     \n         // (White) Draw disk, rotated around current origin, with length R.y*0.5 orbit.\n         vec3 color = mix( vec3(0), vec3(1),     smoothstep(2., 0., diskSDF_L2(SC, R.xy*0.5+vec2(cos(iTime), sin(iTime))*R.y*0.5, 5.)) );\n         // (Green) Draw disk in current origin of coordinate system.\n              color = mix( color,   vec3(0,1,0), smoothstep(2., 0., diskSDF_L2(SC, R.xy*0.5+vec2(0)                     *R.y*0.5, 5.)) );\n         // (Red) Draw disk in old origin of coordinate system.\n              color = mix( color,   vec3(1,0,0), smoothstep(2., 0., diskSDF_L2(SC, R.xy*0.5+origin                      *R.y*0.5, 5.)) );\n         // You can't drag scene with mouse, because mouse offset is canceled.\n    /**/\n    \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}