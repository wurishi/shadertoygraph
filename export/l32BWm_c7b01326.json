{"ver":"0.1","info":{"id":"l32BWm","date":"1732053496","viewed":71,"name":"Ship's Battle","username":"Juliena","description":"Another lab work for study. \narrows - move the gun. \nspacebar - shoot.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst vec3 shipBodyColor = vec3(.1);\nconst float EPSILON = 0.0005;\n\nconst float expDuration = .1;\nconst float expDisplacement = 5.;\n\nmat2 rotate2d(float theta)\n{\n  return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  float sd;\n  Material mat;\n};\n\nMaterial chrome()\n{\n  vec3 aCol = vec3(0.25, 0.25, 0.25);\n  vec3 dCol = vec3(0.4);\n  vec3 sCol = vec3(0.774597);\n  float a = 76.80;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial waterMaterial(vec3 p)\n{\n  vec3 aCol = 0.4 * vec3(0., .8, .8);\n  vec2 texCoords = p.xz*.05;\n  texCoords += sin(iTime * 1.5) * .01;\n  vec3 dCol = vec3(1) * mix(0., 1., texture(iChannel1, texCoords).x);\n  vec3 sCol = vec3(0);\n  float a = 5.;\n  float opacity = .7;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial bulletMaterial()\n{\n  vec3 aCol = vec3(0.105882, 0.058824, 0.113725);\n  vec3 dCol = vec3(0.427451, 0.470588, 0.541176);\n  vec3 sCol = vec3(0.333333, 0.333333, 0.521569);\n  float a = 9.84615;\n  \n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial explosionMaterial(float colorAlpha)\n{\n  vec3 aCol = mix(vec3(1), vec3(1, .6, 0), colorAlpha);\n  vec3 dCol = vec3(0);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n  \n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial PartMaterial()\n{\n  vec3 aCol = vec3(.5);\n  vec3 dCol = vec3(0);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n  \n  return Material(aCol, dCol, sCol, a);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r, vec3 offset, mat3 rotate)\n{\n  p -= offset;\n  p *= rotate;\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r, vec3 offset, mat3 rotate, vec3 rotOffset )\n{\n  p -= offset;\n  p *= rotate;\n  p -= rotOffset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdFloor(vec3 p) {\n  float d = p.y + 1.;\n  return d;\n}\n\nfloat sdSphere( vec3 p, float s, vec3 offset )\n{\n  p -= offset;\n  return length(p)-s;\n}\n\n\n\nfloat opUnion(float a, float b)\n{\n  return min(a, b);\n}\n\nfloat opInter(float a, float b)\n{\n  return max(a, b);\n}\n\nfloat opSubtract(float a, float b)\n{\n  return max(-a, b);\n}\n\nSurface opUnion(Surface a, Surface b)\n{\n    if (a.sd < b.sd)\n    {\n        return a;\n    }\n    return b;\n}\n\nSurface sdBody(vec3 p)\n{\n  float leftCylinder = sdCappedCylinder(p, .3, 2.5, vec3(-2., -1., .0), identity(), vec3(0));\n  float rightCylinder = sdCappedCylinder(p, .3, 2.5, vec3(2., -1., .0), identity(), vec3(0));\n\n  float body = opInter(leftCylinder, rightCylinder);\n  \n  return Surface(body, chrome());\n}\n\nSurface sdGun(vec3 p, vec2 rotation)\n{\n  rotation = rotation*PI/180.;\n  \n  float outerCylinder = sdCappedCylinder(p, .4, .04, vec3(bulletOffset), rotateX(PI/2.)*rotateZ(rotation.x)*rotateX(rotation.y), vec3(0., .3, 0.));\n  float innerCylinder = sdCappedCylinder(p, .4, .05, vec3(bulletOffset), rotateX(PI/2.)*rotateZ(rotation.x)*rotateX(rotation.y), vec3(0., .3, 0.));\n  float box = sdRoundBox(p, vec3(.2, .15, .2), .01, vec3(bulletOffset), rotateY(rotation.x)*rotateX(rotation.y));\n\n  float gun = opSubtract(outerCylinder, innerCylinder);\n  gun = opUnion(gun, box);\n  return Surface(gun, chrome());\n}\n\nSurface sdTower(vec3 p)\n{\n  float bottomCylinder = sdCappedCylinder(p, .3, .35, vec3(.0, -.6, .4), identity(), vec3(0));\n  float topCylinder = sdCappedCylinder(p, .2, .2, vec3(.0, -.3, .4), identity(), vec3(0));\n  \n  float tower = opUnion(bottomCylinder, topCylinder);\n  return Surface(tower, chrome());\n}\n\n\nSurface sdTrajectoryPart(vec3 p, vec3 offset)\n{\n    float part = sdSphere(p, .05, offset);\n    return Surface(part, PartMaterial());\n}\n\nSurface sdTrajectory(vec3 p, vec2 rotation)\n{\n  rotation = rotation * PI / 180.;\n  vec3 velocity = countStartVelocity(rotation);\n  vec3 partOffset = bulletOffset;\n  float t = 2.*velocity.y*sin(-rotation.y)/9.8;\n  float steps = mix(15., 30., t/4.);\n  float partT = t/steps;\n  //to make trajectory \n  float timeOffset = (sin(iTime)*.5+.5);\n  velocity += timeOffset*partT*gravity;\n  partOffset += timeOffset*partT*velocity;\n  \n  Surface d = sdTrajectoryPart(p, partOffset);\n\n  for (int i = 0; i < int(steps); i++)\n  {\n      velocity += partT * gravity;\n      partOffset += partT * velocity;\n      Surface part = sdTrajectoryPart(p, partOffset);\n      d = opUnion(d, part);\n  }\n  return d;\n}\n\nSurface sdShip(vec3 p, vec3 offset, vec2 rotation)\n{\n  p -= offset;\n  Surface body = sdBody(p);\n  Surface gun = sdGun(p, rotation);\n  \n  Surface tower = sdTower(p);\n  \n  Surface d = opUnion(body, gun);\n  d = opUnion(d, tower);\n  \n  \n  \n  \n  return d;\n}\n\nSurface sdBullet(vec3 p, vec3 offset)\n{\n  float sphere = sdSphere(p, .04, offset);\n  \n  return Surface(sphere, bulletMaterial());\n}\n\nSurface sdExplosion(vec3 p, float alpha, vec3 offset)\n{\n  float radius = mix(0., 1., alpha);\n  float explosion = sdSphere(p, radius, offset);\n  float d2 = sin(expDisplacement*p.x + iTime)*sin(expDisplacement*p.y + iTime)*sin(expDisplacement*p.z + iTime);\n\n  return Surface(explosion + d2, explosionMaterial(alpha));\n}\n\n\nSurface sdScene(vec3 p) {\n  Surface water = Surface(sdFloor(p), waterMaterial(p));\n  \n  vec2 rotation = texelFetch(iChannel0, rotInfo, 0).xy;\n  Surface ourShip = sdShip(p, vec3(0, 0, 0), rotation);\n  \n  Surface trajectory = sdTrajectory(p, rotation);\n  \n  Surface co = opUnion(ourShip, trajectory);\n  \n  int bulletsCount = min(int(texelFetch(iChannel0, rotInfo, 0).z), 3);\n  \n  for (int i = 0; i < bulletsCount; i++)\n  {\n      vec3 offset = texelFetch(iChannel0, ivec2(2, i), 0).xyz;\n      Surface bullet = sdBullet(p, offset);\n      co = opUnion(bullet, co);\n  }\n  \n  co = opUnion(co, water);\n  \n  vec4 collInfo = texelFetch(iChannel0, collisionInfo, 0);\n  \n  if (collInfo.x <= 0.)\n  {\n      Surface enemyShip = sdShip(vec3(p.x, p.y, -p.z), enemyPos, vec2(0));\n      co = opUnion(co, enemyShip);\n  }\n  else\n  {\n      float timeAfterExplosion = iTime - collInfo.x;\n      if (timeAfterExplosion <= expDuration)\n      {\n          Surface enemyShip = sdShip(vec3(p.x, p.y, -p.z), enemyPos, vec2(0));\n          co = opUnion(co, enemyShip);\n          float lerpAlpha = timeAfterExplosion / expDuration;\n          Surface explosion = sdExplosion(p, lerpAlpha, collInfo.yzw);\n          co = opUnion(co, explosion);\n      }\n      else if (timeAfterExplosion <= 1.0)\n      {\n          float lerpAlpha = (timeAfterExplosion - expDuration) / (1. - expDuration);\n          Surface explosion = sdExplosion(p, 1. - lerpAlpha, collInfo.yzw);\n          co = opUnion(co, explosion);\n      }\n  }\n\n  \n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON; // epsilon\n  return normalize(\n    e.xyy * sdScene(p + e.xyy).sd +\n    e.yyx * sdScene(p + e.yyx).sd +\n    e.yxy * sdScene(p + e.yxy).sd +\n    e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat)\n{\n  //ambient\n  vec3 ambient = mat.ambientColor;\n\n  //diffusion\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse =  dotLN * mat.diffuseColor;\n  \n  //specular\n  vec3 R = reflect(lightDir, normal);\n  vec3 V = -rd;\n  float dotVR = clamp(dot(V, R), 0., 1.);\n  vec3 specular = pow(dotVR, mat.alpha) * mat.specularColor;\n  \n  return ambient + diffuse + specular;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  \n  Surface obj;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    obj = sdScene(p);\n    depth += obj.sd;\n    if (obj.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  obj.sd = depth;\n\n  return obj;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; // Condense 3 lines down to a single line!\n  \n  vec3 col = vec3(0);\n  vec3 backgroundColor = mix(vec3(1, .341, .2), vec3(0, 1, 1), uv.y) * 1.6;\n  \n  //camera (Taras for you dear)\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  if (mouse == vec2(.0)) mouse = vec2(.5, .4);\n  vec3 lp = vec3(0, 0, 0); // lookat point (aka camera target)\n  vec3 ro = vec3(-2, 1, 3);\n  float cameraRadius = 1.5; \n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouse.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouse.x)) + lp.xz;\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  \n  Surface co = rayMarch(ro, rd);\n  \n  if (co.sd > MAX_DIST) {\n    col = backgroundColor;\n} else {\n  vec3 p = ro + rd * co.sd;\n  vec3 normal = calcNormal(p);\n  \n   // light #1\n  vec3 lightPosition1 = vec3(3, 1, 1);\n  vec3 lightDirection1 = normalize(lightPosition1 - p);\n  float lightIntensity1 = 0.9;\n  \n  col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat);\n}\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 rotInfo = ivec2(0, 0);\nconst ivec2 collisionInfo = ivec2(0, 1);\n\nconst vec3 bulletOffset = vec3(0., -.6, -.6);\n\nconst float PI = 3.14159265359;\n\nconst vec3 enemyPos = vec3(0, 0, 5);\nconst vec3 enemyCollisionPos = vec3(.0, -.8, -5);\nconst vec3 enemyRadius = vec3(.5, .6, 1.3);\n\nconst float startVelocity = 15.;\n\nconst vec3 gravity = vec3(0, -9.8, 0);\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r, vec3 offset )\n{\n  p -= offset;\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nbool checkEnemyCollision(vec3 offset)\n{\n  return sdEllipsoid(offset, enemyRadius, enemyCollisionPos) <= 0.;\n}\n\nvec3 countStartVelocity(vec2 rotation)\n{\n    return startVelocity * vec3(0, 0, -1) * rotateX(-rotation.y) * rotateY(-rotation.x);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int BACKSPACE = 32;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n\nbool checkData (vec2 pos, ivec2 address)\n{\n    return ivec2(pos) == address;\n}\n\n\nvec2 handleArrows()\n{\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, -1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, 1);\n    \n    return left + up + right + down;\n}\n\nbool handleBackspace()\n{\n    float backspace = texelFetch(iChannel1, ivec2(BACKSPACE, 0), 0).x;\n    return backspace > 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 info = texelFetch(iChannel0, rotInfo, 0);\n    vec2 rotation = info.xy;\n    int bulletsCount = int(info.z);\n    float whenBackSpacePressed = info.w;\n    \n    bool backSpacePressed = false;\n    \n    float backSpaceCoolDown = iTime - whenBackSpacePressed;\n    \n    if (iFrame == 0)\n    {\n        if (int(fragCoord.x) == 1)\n        {\n            fragColor = vec4(bulletOffset, 0);\n        }\n        else if (int(fragCoord.x) == 2)\n        {\n            fragColor = vec4(vec3(0, 1, 0), 0);\n        }   \n        \n        if (checkData(fragCoord, collisionInfo))\n        {\n            fragColor = vec4(-1);\n        }\n    }\n    \n    if (backSpaceCoolDown > .5)\n    {\n        if (handleBackspace())\n        {\n            backSpacePressed = true;\n            whenBackSpacePressed = iTime;\n        }\n    }\n  \n    if (checkData(fragCoord, rotInfo))\n    {\n        rotation += handleArrows() * iTimeDelta * 100.;\n        rotation.x -= float(int(rotation.x) / 360) * 360.;\n        rotation.y = clamp(rotation.y, -90., 0.);\n    \n        if (backSpacePressed)\n        {\n          bulletsCount++;\n        }\n        \n        fragColor = vec4(rotation, bulletsCount, whenBackSpacePressed);\n        return;\n    }\n    \n    if (checkData(fragCoord, collisionInfo))\n    {\n        fragColor = texelFetch(iChannel0, collisionInfo, 0);\n        if (fragColor.x <= 0.)\n        {\n            for (int i = 0; i < min(bulletsCount, 3); i++)\n            {\n                vec3 bulletPos = texelFetch(iChannel0, ivec2(2, i), 0).xyz;\n                if (checkEnemyCollision(bulletPos))\n                {\n                    fragColor.x = iTime;\n                    fragColor.yzw = bulletPos;\n                }\n           \n            }\n        }\n    }\n    \n    int slot = (bulletsCount - 1) % 3;\n    int lastSlot = min(bulletsCount, 3);\n    \n    \n    if (int(fragCoord.x) == 1 && int(fragCoord.y) < lastSlot)\n    {\n        vec3 velocity = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n        if (int(fragCoord.y) == slot && backSpaceCoolDown > .02 && backSpaceCoolDown < .1)\n        {\n            rotation = rotation * PI / 180.;\n            velocity = countStartVelocity(rotation);\n        }\n        else\n        {\n            velocity += gravity * iTimeDelta;\n        }\n        fragColor = vec4(velocity, 0);\n    }\n    \n    if (int(fragCoord.x) == 2 && int(fragCoord.y) < lastSlot)\n    {\n        vec3 offset = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n        vec3 velocity = texelFetch(iChannel0, ivec2(1, int(fragCoord.y)), 0).xyz;\n\n        if (int(fragCoord.y) == slot && backSpaceCoolDown > .02 && backSpaceCoolDown < .1)\n        { \n            offset = bulletOffset;\n        }\n        else\n        {\n            offset += velocity * iTimeDelta;\n        }\n        fragColor = vec4(offset, 0);\n    }   \n}","name":"Buffer A","description":"","type":"buffer"}]}