{"ver":"0.1","info":{"id":"lddfRN","date":"1524353910","viewed":191,"name":"generalized Julia/Mandelbrot set","username":"akhgary","description":"mixture of ideas that i got from here and there and packed them together. I mention a few i could remember.\n\ngeneralized Julia/Mandelbrot set colored using distance estimation.\n\n\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["julia","mandelbrot","distance","complex","generalized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mandelbrot/Julia set \n//\n// click anywhere on mandelbrot set to see \n// how your selected number converges or diverges and see relations in julia set!\n//\n// =====================================\n// line drawing \n// https://www.shadertoy.com/view/Xs3XWH\n//\n// distance estimation formula \n// https://en.wikipedia.org/wiki/Mandelbrot_set#Exterior_distance_estimation\n//\n// HSV to RGB converter\n// could not remember :(\n//\n// cool transitions and generalized function, thanks to math.stackexchange community for their help.\n// https://math.stackexchange.com/questions/2746958/smooth-floor-function\n// https://math.stackexchange.com/questions/2746335/how-to-compute-zn\n//\n// thanks to user iq. that helped me a lot to understand what im doing wrong!\n// https://www.shadertoy.com/user/iq\n//\n//=====================================\n\nconst int iterations = 100;\nconst int lineIterations = 50;\nconst float bailout = 4.0; // z outside this radius are considered to diverge to infinity.\nconst float minPower = 2.0; // minimum power of Z.\nconst float maxPower = 7.0; // maximum power of Z.\nconst float duration = 20.0; // transition cycle duration in seconds.\nconst float hueDuration = 5.0; // hue cycle duration in seconds.\n\nconst bool drawLines = true;\nconst bool drawPoints = true;\nconst float thickness = 1.0/200.0; // affects lines and points\nconst float pointsAlpha =5.0;\nconst float sharpness = 6.0;\n\nconst float pi = 3.1415927;\nconst float pi2 = 6.283185;\nconst float epsilon = 1e-5;\n\n// convert HSV values to RGB values.\nvec3 HSV2RGB(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// maps pixels to xy plane\nvec2 uvmap(vec2 pixels) {\n    vec2 uv = (pixels.xy/iResolution.xy)*2.0 - 1.0;\n    uv.y /= iResolution.x/iResolution.y;\n    return uv;\n}\n\n// map a value from a defined range to a new range.\nfloat map(float x, float oldMin, float oldMax, float newMin, float newMax) {\n    return newMin + (x - oldMin)/(oldMax - oldMin)*(newMax - newMin);\n}\n\n// map a vector from defined ranges to new ranges.\nvec2 map(vec2 p, vec2 oldMin, vec2 oldMax, vec2 newMin, vec2 newMax) {\n    p.x = map(p.x, oldMin.x, oldMax.x, newMin.x, newMax.x);\n    p.y = map(p.y, oldMin.y, oldMax.y, newMin.y, newMax.y);\n    return p;\n}\n\n// draw line or points on a given plane.\nfloat line(vec2 uv, vec2 start, vec2 end) {\n    vec2 pa = uv - start;\n    vec2 ba = end - start;\n    float h = clamp (dot (pa, ba) / dot (ba, ba), 0.0, 1.0);\n    float d = length (pa - ba * h);\n    \n    return 1.0-clamp(d/thickness, 0.0, 1.0);\n}\n\n// iterative function for calculating mandelbrot and julia set.\nvec2 function(vec2 z, float n) {\n    float r = pow(dot(z, z), n/2.0);\n    float th = n*atan(z.y,z.x+epsilon);\n    return r*vec2(cos(th), sin(th));\n}\n\n// compute color for escaping points with exterior distance formula.\nvec3 getColor(float r, float dr) {\n    float t = iTime*pi/hueDuration;\n    float d = r*log(r)/dr;\n    d = clamp(pow(d, 1.0/sharpness), 0.0,1.0);\n    vec3 rgb = HSV2RGB(vec3(d,1.0,1.0))/2.0;\n    return vec3(d*(sin(t)+rgb.b+1.0)/2.0, \n\t\td*(sin(t+pi2/3.0)+rgb.g+1.0)/2.0,\n\t\td*(sin(t-pi2/3.0)+rgb.b+1.0)/2.0)-vec3(0.1);\n}\n\n// plots julia and mandelbrot set.\nvec4 plot(const vec2 z0, const vec2 c, const vec2 mouse, const bool julia) {\n    vec3 set = vec3(0);\n    vec3 path = vec3(0);\n    vec3 points = vec3(0);\n\t\n    vec2 z = z0;\n    vec2 dz = vec2(1, 0);\n    vec2 zL = vec2(0); // for drawing line with initial z = 0 and c = mouse.xy\n    bool inSetZ= true;\n    bool inSetZl = true;\n    \n    float tx = (1.0 - cos(iTime*pi/duration))*(maxPower-minPower)/2.0 + minPower;\n    float n = tx - sin(pi2*tx)/pi2;\n    \n    for(int i = 0; i < iterations ; i++)\n    {\n\tif(inSetZ)\n\t{\n\t    float dotZ = dot(z, z);\n\t\t\n    \t    if(dotZ > bailout*bailout)\n\t    {\n\t        set = getColor(sqrt(dotZ), length(dz));\n\t        inSetZ = false;\n\t    }\n\t    \n        // f(f(z))' = f'(f(z))*f'(z)\n\t    vec2 df = n*function(z, n - 1.0);\n\t    dz = vec2(df.x*dz.x-df.y*dz.y, df.x*dz.y + df.y*dz.x) + vec2(julia?0:1,0);\n\t    z = function(z, n) + c;\n\t\t\n            if(drawPoints) points += line(z0, z, z)/float(iterations);\n\t}\n\tif(drawLines && inSetZl)\n\t{\n\t    if(dot(zL, zL) > bailout*bailout || i > lineIterations) inSetZl = false;\n\t    vec2 newZ = function(zL, n) + mouse;\n\t    path += line(z0, zL, newZ)/float(i/8+1);\n\t    zL = newZ;\n\t}\n\tif(!inSetZ && (!inSetZl || !drawLines)) break;\n    }\n    points = vec3(clamp(points.x*pointsAlpha,0.0, 1.0)-0.2);\n    return vec4(set+path+points, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = uvmap(fragCoord.xy);\n    vec2 ms = uvmap(iMouse.xy);\n    float aspect = iResolution.y/iResolution.x; \n\t\n    ms = map(ms, vec2(-1, -aspect), vec2(0, aspect), vec2(-2, -2), vec2(2, 2));\n\t\n    if(uv.x < 0.0)\n    {\n        uv = map(uv, vec2(-1, -aspect), vec2(0, aspect), vec2(-2, -2), vec2(2, 2));\n        fragColor = plot(uv, uv, ms, false);\n    }\n    else\n    {\n        uv = map(uv, vec2(0, -aspect), vec2(1, aspect), vec2(-2, -2), vec2(2, 2));\n        fragColor = plot(uv, ms, ms, true);\n    }\n}","name":"Image","description":"","type":"image"}]}