{"ver":"0.1","info":{"id":"7ldfzj","date":"1663370562","viewed":425,"name":"Xor's Basic Raymarcher","username":"Xor","description":"This is a little guide on raymarching to go along with my mini tutorial series.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Xor's Basic Raymarcher\" by @XorDev\n\n    This is a little guide on raymarching to go along with my mini tutorial series:\n    https://mini.gmshaders.com\n*/\n\n//Raymarcher \"Epsilon\" meaning how close to the surface we need to get to stop the loop\n#define EPS 0.001\n//Max distance to travel before we stop the loop\n#define MAX 50.0\n//Light direction vector\n#define LIGHT normalize(vec3(1,3,-1))\n//Gamma for gamma correction\n#define GAMMA 2.2\n\n//Distance field function\nfloat dist(vec3 p)\n{\n    //Distance to ground floor\n    float ground = p.y+1.0;\n    //Basic repeating torus SDF\n    float torus = length(vec2(length(p.xy)-0.8, mod(p.z,8.0)-4.0))-0.2;\n    \n    //Repeat XY axes for boxes\n    p.xz = mod(p.xz, 4.0)-2.0;\n    //Shift downward\n    p.y += 0.3;\n    //Compute distance using rounded box formula\n    float box = length(max(abs(p)-0.4,-0.1))-0.2;\n    \n    return min(ground, min(torus, box)); //Return the closest of them all\n}\n//Compute normal from the distance field\nvec3 normal(vec3 p)\n{\n    //Signed epsilon for computing distance field derivative\n    const vec2 e = vec2(2, -2) * EPS;\n    \n    //Basically we're offsetting by slight amounts and computing rate of change.\n    //This tells us which direction is most positive and then we normalize the vector.\n    return normalize(dist(p+e.xxy)*e.xxy + dist(p+e.xyx)*e.xyx + dist(p+e.yxx)*e.yxx + dist(p+e.y)*e.y);\n}\n//Basic raymarching function\nvec4 raymarch(vec3 pos, vec3 dir)\n{\n\tfloat d = 0.0; //Starting distance\n\n\tfor(int i = 0; i<200; i++) //Step 200 times\n\t{\n\t\tfloat step_dist = dist(pos + dir * d); //Check distance field\n\t\td += step_dist; //March forward\n\t\tif (step_dist<EPS || d>MAX) break; //Stop at intersection or max distance\n\n\t}\n\treturn vec4(pos + dir * d, d); //Return intersection point and distance\n\n}\n//Basic soft shadow function\nfloat shadow(vec3 pos, vec3 dir, float mx)\n{\n    float d = 0.01; //Starting distance\n    float s = 1.0; //Shadow value\n\n\tfor(int i = 0; i<40; i++) // Step 40 times\n\t{\n\t\tfloat step_dist = dist(pos + dir * d); //Check distance field\n\t\td += step_dist; //March forward\n        \n        \n\t\tif (step_dist<EPS) return 0.0; //Stop at intersection\n        if (d>mx) break; //Stop at max distance\n        s = min(s, step_dist / d * 5.0); //Brightness from proximity\n\n\t}\n\treturn s; //Return shadow brightness\n}\n//Sample color at any given point\nvec3 color(vec3 pos, vec3 dir, float dep)\n{\n    //Get normal\n    vec3 n = normal(pos);\n    \n    //Coloring and checkerboard pattern\n    vec3 cell = ceil(pos*3.);\n    float checker = mod(cell.x+cell.y+cell.z, 2.0);\n    vec3 col = pow(1.0 - vec3(0,.6,.8)*checker, vec3(GAMMA));\n    \n    //Dot product lighting\n    float light = dot(n, LIGHT);\n    //Fade to black\n    light = max(light, 0.1+light*0.1);\n    \n    //Shadow raymarching\n    float shade = shadow(pos, LIGHT, MAX)*0.9+0.1;\n    //Blend the shading together with ambient light\n    vec3 amb = pow(vec3(0.01,0.2,0.3), vec3(GAMMA));\n    col *= mix(amb, vec3(1), min(light, shade));\n    \n    //Compute sky color using simple gradient\n    vec3 sky = pow(vec3(0.2, 0.5, 0.8) * (1.0+dot(dir, LIGHT)), vec3(GAMMA));\n    //Fade to background sky color\n    col = mix(col, sky, smoothstep(0.0, MAX, dep));\n    \n    //Set color from dot lighting\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Camera position (scrolling forward)\n    vec3 p = vec3(0,0,iTime);\n    //Ray direction\n    vec3 d = normalize(vec3(fragCoord-.5*iResolution.xy,iResolution.y));\n    \n    //Find raymarch intersection\n    vec4 m = raymarch(p, d);\n    //Find color at intersection\n    vec3 c = color(m.xyz, d, m.w);\n    \n    c = pow(c, vec3(1.0/GAMMA));\n        \n    //Output color\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}