{"ver":"0.1","info":{"id":"4sdSW7","date":"1459735603","viewed":373,"name":"Voxel Clock","username":"akohdr","description":"Borrowed coolest looking 7-seg LED clock (https://www.shadertoy.com/view/MdfGzf) projected into a voxel space.\nClick on viewport to see voxel world slices, cursor keys work as per original clock. \n","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["clock","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Since this is a map lookup feel free to amp speed to something crazy\n//#define SPD_R 3.*iTime\n//#define SPD_R .5*iTime\n\n// of course doesn't need to spin continuously\n#define SPD_R 1.*sin(cos(iTime))\n//#define SPD_R sin(2.*iTime)\n\n//#define SHOW_AXIS\n\n// Cut/Paste begin ------------------------------------------------------------\n#define BOB_H 10.\n#define EYE_D iResolution.x/2.\n#define WORLD_OFFSET vec3(iResolution.x/4.,iResolution.y/4.,0)\n#define B0 vec4(.0,.0,.0,1.)\n#define B1 vec4(.6,.6,.6,1.)\n#define B2 vec4(.3,.3,.3,1.)\n\n// goal is fast voxel based abstraction returning existence and colour(c) in spacetime(P)\nbool cVoxel(out vec4 c, in vec4 P );\n\nbool VxViewer(out vec4 fc,             // fragColor\n         const in vec2 P,              // fragCoord\n         const in vec3 R,              // iResolution\n        const in float T ) {           // timebase\n    \n    vec2 t = vec2(sin(T), cos(T)),\n         l = P.xx / R.xx - .5;         // vec ops faster than single scalar\n    vec3 r = vec3(l.y*t.y - .8*t.x, \n                  (P.y/R.y - .5)*R.y/R.x, \n                  .8*t.y + l.x*t.x),\n         o = t.xxy * vec3(EYE_D, BOB_H, -EYE_D),\n         h = length(r)/r,\n         q = sign(r),\n         f = floor(o),\n//         d = abs(h)+vec3(3,0,0),  //produces space stretching effects which are cool\n         d = abs(h),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n    \n    for(int i=0;i<700;i++) {\n        \n        if(cVoxel(fc,vec4(f+WORLD_OFFSET,T))){ // move to top of loop for edgeless non-spin voxels\n            fc += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n            return true; // early exit\n        }\n        \n        bvec3 a = lessThan(s,s.yzx),\n              b = lessThanEqual(s,s.zxy);\n              m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n        \n        f += m*q;\n        s += m*d;\n    }\n    return false;\n}\n// Cut/Paste end ------------------------------------------------------------\n\n// Pallette defs / constants\n#define RED vec4(.9,.0,.0,1.)\n#define GRN vec4(.0,.9,.0,1.)\n#define BLU vec4(.0,.0,.9,1.)\n#define PRP vec4(.3,0.,.5,1.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if(iMouse.z>0.)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else        \n    if(!VxViewer(fragColor, \n             fragCoord,\n             iResolution,\n             SPD_R))          // timebase\n    // we didn't hit voxel\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n}\n\nvec3 vDim = vec3(iResolution.xy,16.);\n    \nvec2 prj3Dto2D(const in vec4 P) {\n    // slightly convoluted to space things out to show two clocks\n    vec4 p = P;\n    p.z -= 1.;\n    \n    vec2 ir2 = iResolution.xy/2.;\n\tif(p.z<0. || (p.z>4.&&p.z<6.) || p.z>132.||\n       p.x<0.|| p.x>ir2.x||\n       p.y<0.|| p.y>ir2.y\n      ) return vec2(0.);\n    \n    float fpl = 2.;\n    vec2 fOrigin;\n    \tfOrigin.x = mod(p.z/2. , fpl);\n    \tfOrigin.y = (p.z/2.)-(fOrigin.x*fpl);\n    \n    return p.xy + floor(fOrigin) * ir2;\n}\n\n// AXIS support ----------------------------------------------\n#define SPHERE(p,c,r) length(p.xyz-c.xyz)<r\n#define ARX(p,c,r) length(p.xy-c.xy)<r-length(1.23*p.xz-c.xz)\n#define ARY(p,c,r) length(p.xy-c.xy)<r-length(1.23*p.yz-c.yz)\n#define ARZ(p,c,r) length(p.yz-c.yz)<r-length(1.23*p.xz-c.xz)\n\n#define Q(q) if(q) return true;\n#define QC(C,q) {c=C;Q(q)}\n#define QS(C,p,c,r) QC(C,SPHERE(p,c,r))\n#define QX(C,p,c,r,X) QC(C,X(p,c,r))\n#define vO vec3(0.)\n#define vX(r) vec3(r,0.,0.)\n#define vY(r) vec3(0.,r,0.)\n#define vZ(r) vec3(0.,0.,r)\n\n// painful to use but macros can save couple fps, multi line macros would be nice\n#ifdef SHOW_AXIS\n\t#define AXIS(s,r) {QX(RED,P,vX(s),r,ARX) QX(GRN,P,vY(s),r,ARY) QX(BLU,P,vZ(s),r,ARZ) QS(PRP,P,vO,r/2.)}\n#else\n\t#define AXIS(s,r)\n#endif\n// -----------------------------------------------------------\n\nbool cVoxel(out vec4 c,\n             in vec4 P ) {\n    AXIS(33.,7.5)\n\n    // pull voxel state from 2D map of world slices generated in BufA\n    c = texture(iChannel0, prj3Dto2D(P)/iResolution.xy);\n \treturn c.x+c.y > 0.;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//From: https://www.shadertoy.com/view/MdfGzf\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nbool showMatrix = true;\nbool showOff = false;\n\nfloat segment(vec2 uv, bool On)\n{\n\tif (!On && !showOff)\n\t\treturn 0.0;\n\t\n\tfloat seg = (1.0-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t    (1.0-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)));\n\t\n    //Fiddle with lights and matrix\n\t//uv.x += sin(iTime*60.0*6.26)/14.0;\n\t//uv.y += cos(iTime*60.0*6.26)/14.0;\n\t\n\t//led like brightness\n\tif (On)\n\t\tseg *= (1.0-length(uv*vec2(8.8,1.9)));//-sin(iTime*25.0*6.26)*0.04;\n\telse\n\t\tseg *= -(0.05+length(uv*vec2(0.2,0.1)));\n\t\n\treturn seg;\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    seg += segment(uv.yx+vec2(-1.0, 0.0),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-0.5,-0.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( 0.5,-0.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0.0, 0.0),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-0.5, 0.5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( 0.5, 0.5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1.0, 0.0),num!=-1 && num!=1 && num!=4 && num!=7          );\n\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim)\n{\n\t//Speed optimization, leave if pixel is not in segment\n\tif (abs(uv.x)>1.5 || abs(uv.y)>1.2)\n\t\treturn 0.0;\n\t\n\tfloat seg= 0.0;\n\tif (uv.x>0.0)\n\t{\n\t\tnr /= 10;\n\t\tif (nr==0 && zeroTrim)\n\t\t\tnr = -1;\n\t\tseg += sevenSegment(uv+vec2(-0.75,0.0),nr);\n\t}\n\telse\n\t\tseg += sevenSegment(uv+vec2( 0.75,0.0),int(mod(float(nr),10.0)));\n\t\n\treturn seg;\n}\n\nfloat dots(vec2 uv)\n{\n\tfloat seg = 0.0;\n\tuv.y -= 0.5;\n\tseg += (1.0-smoothstep(0.11,0.13,length(uv))) * (1.0-length(uv)*2.0);\n\tuv.y += 1.0;\n\tseg += (1.0-smoothstep(0.11,0.13,length(uv))) * (1.0-length(uv)*2.0);\n\treturn seg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n\tbool isGreen = texture(iChannel2,vec2(KEY_DOWN,0.75)).r <0.5;\n\tshowOff = texture(iChannel2,vec2(KEY_RIGHT,0.75)).r >0.5;\n\n// Tweaks to clock rendering\n    vec2 fragCoord = mod(fc.xy,iResolution.xy/2.)*2.;\n    if(fc.x> iResolution.x/2.) { isGreen = !isGreen; showOff = !showOff; }\n// end tweaks\n    \n    \n\tbool ampm = texture(iChannel2,vec2(KEY_UP,0.75)).r <0.5;\n\tshowMatrix = texture(iChannel2,vec2(KEY_LEFT,0.75)).r >0.5;\n\t\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) /\n \t\t       min(iResolution.x,iResolution.y);\n\t\n\tfloat timeOffset = 0.0;\n\tif (iResolution.x>iResolution.y)\n\t{\n\t\tuv *= 6.0;\n\t}\n\telse\n\t{\n\t\t//uv *= 12.0;\n\t\t// Many clocks with different time + zoom in on the right one\n\t\tuv *= 70.0+sin(iTime*0.0628)*58.0;\n\t\t\n\t\tuv += vec2(5.5,2.5);\n\t\tvec2 offset = vec2(floor(uv.x/11.0),\n\t\t\t\t\t\t   floor(uv.y/5.0 ));\n\t\tif (length(offset)>0.0)\n\t\t\ttimeOffset = (offset.y*163.13+offset.x*13.23)+mod(iTime,1.0);\n\t\telse\n\t\t\ttimeOffset = 0.0;\n\t\t\t\t\t\t\t\t\n\t\tuv.x = mod(uv.x,11.0)-5.5;\n\t\tuv.y = mod(uv.y, 5.0)-2.5;\n\t}\n\t\n\tuv.x *= -1.0;\n\tuv.x += uv.y/12.0;\n\t//wobble\n\t//uv.x += sin(uv.y*3.0+iTime*14.0)/25.0;\n\t//uv.y += cos(uv.x*3.0+iTime*14.0)/25.0;\n    uv.x += 3.5;\n\tfloat seg = 0.0;\n\n\tfloat timeSecs = iDate.w+timeOffset;\n\t\n\tseg += showNum(uv,int(mod(timeSecs,60.0)),false);\n\t\n\ttimeSecs = floor(timeSecs/60.0);\n\t\n    uv.x -= 1.75;\n\n\tseg += dots(uv);\n\t\n    uv.x -= 1.75;\n\t\n\tseg += showNum(uv,int(mod(timeSecs,60.0)),false);\n\t\n\ttimeSecs = floor(timeSecs/60.0);\n\tif (ampm)\n\t{\n\t\tif (timeSecs>12.0)\n\t\t  timeSecs = mod(timeSecs,12.0);\n\t}\n\t\n    uv.x -= 1.75;\n\t\n\tseg += dots(uv);\n\t\n    uv.x -= 1.75;\n\tseg += showNum(uv,int(mod(timeSecs,60.0)),true);\n\t\n\t// matrix over segment\n\tif (showMatrix)\n\t{\n\t\tseg *= 0.8+0.2*smoothstep(0.02,0.04,mod(uv.y+uv.x,0.06025));\n\t\t//seg *= 0.8+0.2*smoothstep(0.02,0.04,mod(uv.y-uv.x,0.06025));\n\t}\n\t\n\tif (seg<0.0)\n\t{\n\t\tseg = -seg;;\n\t\tfragColor = vec4(seg,seg,seg,1.0);\n\t}\n\telse\n\t\tif (showMatrix)\n\t\t\tif (isGreen)\n\t\t\t\tfragColor = vec4(0.0,seg,seg*0.5,1.0);\n\t\t\telse\n\t\t\t\tfragColor = vec4(0.0,seg*0.8,seg,1.0);\n\t\telse\n\t\t\tif (isGreen)\n\t\t\t\tfragColor = vec4(0.0,seg,0.0,1.0);\n\t\t\telse\n\t\t\t\tfragColor = vec4(seg,0.0,0.0,1.0);\n\t\n}","name":"Buf A","description":"","type":"buffer"}]}