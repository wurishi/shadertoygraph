{"ver":"0.1","info":{"id":"4lB3D1","date":"1428451730","viewed":5362,"name":"Glass with caustic","username":"andregc","description":"Experiment with caustics. Fork of https://www.shadertoy.com/view/XljGWR. But here less number of reflection/refraction rays are used as shader craches with bug number of rays. If you card is enough power you can set \"calcRecursion\" define to bigger values","likes":75,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","raymarching","reflection","refraction","glass","caustic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Forked from https://www.shadertoy.com/view/XljGWR\n// Distance function, camera setup and base for raymarching from iq's // https://www.shadertoy.com/view/Xds3zN\n\n\n#define OBJECT_MAP_FUNCTION map1\n\n#define calcRecursion rec3 // use n rays levels (rays1 to rays6): total  RAY_COUNT = 2^n-1\n#define DIST_EPSILON 0.005\n\n#define ID_SKY 2.001\n#define ID_FLOOR 1.\n#define ID_LIGHT 1.001\n#define ID_GLASS_WALL 2.000\n#define ETA 0.85\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n#define DENSITY_MIN 0.1\n#define DENSITY_MAX 0.1\n#define MATERIAL_COLOR vec3(0.5,0.8,1)*0.1\n#define AIR_COLOR vec3(0.5,0.8,1)*0.1\n\n\n#define SURFACE_COLOR vec3(0.8,1.,0.9)\n//#define SURFACE_COLOR vec3(0.8,1.,0.8)*(1.-0.2* mod( floor(5.0*p.z) + floor(5.1*p.x) + floor(5.1*p.y), 2.0))\n//#define SURFACE_COLOR vec3(0.8,1.,0.8)*(0.6+0.4*noise(p.xz*30. + p.yz*23.))\n vec3 LIGHT_DIR = normalize(vec3(-0.6,0.7,-0.3));\n//-------------------------------------------------------------------------------\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nstruct CP {\n    float dist;\n    vec3 normal;\n    float mat;\n    vec3 p;\n};\n    \n    \nstruct Ray {\n    vec3 rd;\n    CP cp;\n    vec3 col;\n    float share;\n    float eta;\n};\n    \n    \n//-------------------------------------------------------------------------------\n//  https://www.shadertoy.com/view/Xds3zN\nfloat sdBox( vec3 p, vec3 b )\n{\n   vec3 d = abs(p) - b;\n   return (min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n   return (length(p)-r);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return abs(length(max(abs(p)-b,0.0))-r);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n   \n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opS(  vec3 d1, vec3 d2 )\n{\n    return -d1.x>d2.x ? d2: d1;\n}\n\n//-------------------------------------------------------------------------------\n\n\n\nvec3 map1(in vec3 pos) {\n    vec3 res =  vec3((sdCappedCylinder(pos-vec3(0,0.49,-0.4), vec2(0.3,0.5))), ID_GLASS_WALL, ETA);\n    res = opU(res, vec3(sdSphere(pos-vec3(0.,0.31,0.4),0.3),ID_GLASS_WALL, ETA));\n  //  res = opU(res, vec3(sdTorus(pos.yxz-vec3(0.3,0.,-0.7),vec2(0.2,0.1)),ID_GLASS_WALL, ETA));\n    res.x =abs(res.x);\n   \n \treturn res;\n}\n\nvec3 map(in vec3 pos) {\n    vec3 res = vec3(sdPlane(pos), ID_FLOOR, -1. );\n\treturn opU(res, OBJECT_MAP_FUNCTION(pos));    \n}\n\n//-------------------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    float d = map(pos).x;\n    return normalize( vec3(\n\t    map(pos+eps.xyy).x - d,\n\t    map(pos+eps.yxy).x - d,\n\t    map(pos+eps.yyx).x - d)\n\t);\n}\n\n              \nCP findIntersection(vec3 p, vec3 rd) {\n     \n    float tmin = 0.000;\n    float tmax = 50.0;\n    \n\tfloat precis = DIST_EPSILON;\n    float t = tmin;\n    float eta = -1.;\n    vec3 res;\n    for( int i=0; i<50; i++ )\n    {\n\t  \tres = map(p+rd*t);\n        eta = res.z;\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n    }\n    \n    p+=rd*t;\n    // calculate normal in the father point to avoid artifacts\n    vec3 n = calcNormal(p-rd*(precis-res.x));\n    CP cp = CP(t, n, res.y, p);\n\n    return cp;\n}\n\n//-------------------------------------------------------------------------------\n\n\nvec3 refractCaustic(vec3 p, vec3 rd, vec3 ld, float eta) {\n     vec3 cl = vec3(1);\n    for(int j = 0; j < 2; ++j) {\n\n        CP cp = findIntersection(p, rd);\n        if (length(cp.p) > 2.) {\n            break;\n        }\n        cl *= SURFACE_COLOR;//*(abs(dot(rd, cp.normal)));\n        vec3 normal = sign(dot(rd, cp.normal))*cp.normal;\n        rd = refract(rd, -normal, eta);\n\n        p = cp.p;\n        eta = 1./eta;\n        p += normal*DIST_EPSILON*2.;\n    }\n     float d = clamp( dot( rd, ld ), 0.0, 1.0 );\n     return smoothstep(0.99, 1., d)*cl;\n}\n\nvec3 caustic(vec3 p,vec3 ld, Ray ray) {\n    vec3 VX = normalize(cross(ld, vec3(0,1,0)));\n\tvec3 VY = normalize(cross(ld, VX));     \n    vec3 c = vec3(0);\n    \n    const int N =3;\n    p += ray.cp.normal*DIST_EPSILON;\n   \n    for(int i = 0; i < N;++i) {\n        \n        float n1 = rand(p.xz*10. + vec2(iTime*2. +float(i)*123.));\n        float n2 = rand(p.xz*15. +vec2(iTime*3. +float(i)*111.));\n\n        vec3 rd = ld+(VX*(n1-0.5)+VY*(n2-0.5))*0.1;\n       // rd = ld;\n        rd = normalize(rd);\n\n \t\tvec3 cl = refractCaustic(p, rd, ld, ray.eta);\n        \n      \tc += cl* dot(rd,ray.cp.normal);\n    }\n    return c*3./float(N);\n}\n\n// lightning is based on https://www.shadertoy.com/view/Xds3zN\nvec3 getFloorColor(in Ray ray) {\n    \n    vec3 col = vec3(0);\n    vec3 pos = ray.cp.p;\n    vec3 ref = reflect( ray.rd, ray.cp.normal );\n    \n    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n    col = 0.4 + 0.1*f*vec3(1.0);\n\n    float dif = clamp( dot( ray.cp.normal, LIGHT_DIR ), 0.0, 1.0 );\n    vec3 brdf = vec3(0.0);\n    brdf += caustic(pos, LIGHT_DIR, ray);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    col = col*brdf;\n    // exclude branching\n    col *= (ID_GLASS_WALL-ray.cp.mat);\n\n    return col;\n}\n    \n\nvec3 getColor(in Ray ray) {\n\n    vec3 p = ray.cp.p ;// can be used by SURFACE_COLOR define\n    vec3 c1 = ray.col * SURFACE_COLOR;\n    vec3 c2 = getFloorColor(ray);\n    // exclude branching\n    return mix(c2, c1, ray.cp.mat - ID_FLOOR);\n\n}    \n\n//-------------------------------------------------------------------------------\n\n\nvec3 getRayColor(Ray ray) {\n\n\n    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 col = getColor(ray);\n\n    float q = exp(-d*ray.cp.dist);\n    col = col*q+matColor*(1.-q);\n    return col*ray.share;\n}\n\nvoid getRays(inout Ray ray, out Ray r1, out Ray r2) {\n     vec3 p = ray.cp.p;\n    float cs = dot(ray.cp.normal, ray.rd);\n    // simple approximation\n    float fresnel = 1.0-abs(cs);\n//\tfresnel = mix(0.1, 1., 1.0-abs(cs));\n    float r = ray.cp.mat - ID_FLOOR;\n     vec3 normal = sign(cs)*ray.cp.normal;\n    vec3 refr = refract(ray.rd, -normal, ray.eta);\n    vec3 refl = reflect(ray.rd, ray.cp.normal);\n    vec3 z = normal*DIST_EPSILON*2.;\n    p += z;\n    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),(1.-fresnel)*r, 1./ray.eta);\n    p -= 2.*z;\n    r2 = Ray( refl, findIntersection(p, refl), vec3(0),r*fresnel, ray.eta);\n}\n    \n// set of \"recursion\" functions\n\nvoid rec1(inout Ray ray) {\n    ray.col += getRayColor(ray);\n}\n\n\nvoid rec2(inout Ray ray) {\n\t\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n\n    ray.col += getRayColor(r1);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec3(inout Ray ray) {\n    \n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec2(r1);\n    ray.col += getRayColor(r1);\n    // use first level of relfection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec4(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec3(r1);\n    ray.col += getRayColor(r1);\n    // use first level of relfection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec5(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec4(r1);\n    ray.col += getRayColor(r1);\n    // use first level of relfection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec6(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec5(r1);\n    ray.col += getRayColor(r1);\n    \n    // use only first level of relfection to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\n\n\nvec3 castRay(vec3 p, vec3 rd) {\n    CP cp = findIntersection(p, rd);\n   \n    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);\n    calcRecursion(ray);\n    ray.col = getRayColor(ray);\n\treturn ray.col;\n    \n}\n\nvec3 render(vec3 p, vec3 rd) {\n    vec3 col= castRay(p, rd);\n    return col;\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    // this strange construction is used to define initial view angle\n    // simple \"IF\" condition can work incorrectly on weak GPU \n    // (at least on one of tested computers_\n    mo = mix(vec2(0.6,0.3),mo, sign(mo.x+mo.y));\n\n\n    mo.y+=0.02;\n\tmo.y *=1.57;\n    float time =0.;//sin(iTime);//iTime*0.1;;\n\tmo.x*=10.;\n    float R = 4.3;\n    \n    float Y = sin(mo.y);\n    float X = cos(mo.y);\n\tvec3 ro = vec3(cos(time + mo.x)*X, Y, X*sin(time + mo.x) )*R;\n\tvec3 ta = vec3( 0,0.4,0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta,0. );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.5) );\n    \n    vec3 c = render(ro, rd);\n\n\tfragColor = vec4(c, 1);\n}","name":"","description":"","type":"image"}]}