{"ver":"0.1","info":{"id":"l33Xzs","date":"1719410233","viewed":44,"name":"ball+Torus+Sphere Tracing+Camera","username":"sophytoeat","description":"None","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["torus","camera","spheretracing","ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_THRESHOLD 0.01\n\n// 球の符号付き距離関数\nfloat sdCapsule(vec3 point, vec3 start, vec3 end, float radius) {\n    vec3 ab = end - start;\n    vec3 ap = point - start;\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 closestPoint = start + t * ab;\n    float distance = length(point - closestPoint) - radius;\n    return distance;\n}\n\n// トーラスの符号付き距離関数\nfloat sdTorus(vec3 point, vec2 radii) {\n    float x = length(point.xz) - radii.x;\n    return length(vec2(x, point.y)) - radii.y;\n}\n\n// シーン内の任意の表面から点までの最短距離を取得する関数\nfloat getDistance(vec3 point) {\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float sphereDist = length(point - sphere.xyz) - sphere.w;\n    float planeDist = point.y;\n    float torusDist = sdTorus(point - vec3(0, 0.5, 6.0), vec2(1.5, 0.3));\n    float distance = min(torusDist, planeDist);\n    distance = min(distance, sphereDist);\n    return distance;\n}\n\n// Sphere Marchingを実行し、レイが移動した距離を返す関数\nfloat sphereMarch(vec3 rayOrigin, vec3 rayDirection) {\n    float totalDistance = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 currentPoint = rayOrigin + rayDirection * totalDistance;\n        float distance = getDistance(currentPoint);\n        totalDistance += distance;\n        if (totalDistance > MAX_DISTANCE || distance < SURFACE_THRESHOLD) break;\n    }\n    return totalDistance;\n}\n\n// 表面上の点における法線を計算する関数\nvec3 getNormal(vec3 point) {\n    float distance = getDistance(point);\n    vec2 epsilon = vec2(0.01, 0.0);\n    vec3 normal = distance - vec3(\n        getDistance(point - epsilon.xyy),\n        getDistance(point - epsilon.yxy),\n        getDistance(point - epsilon.yyx)\n    );\n    return normalize(normal);\n}\n\n// 点におけるライティングを計算する関数\nfloat getLight(vec3 point) {\n    vec3 lightPosition = vec3(0, 5, 6);\n    vec3 lightDirection = normalize(lightPosition - point);\n    vec3 normal = getNormal(point);\n    float diffuse = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    float shadow = sphereMarch(point + normal * SURFACE_THRESHOLD * 2.0, lightDirection);\n    if (shadow < length(lightPosition - point)) diffuse *= 0.1;\n    return diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n\n    float Time = 0.45 * (15.0 + iTime);\n    vec3 ro = vec3(8.0 * cos(Time), 6.0, 8.0 * sin(Time));\n    vec3 ta = vec3(0.0, 2.5, 0.0);\n\n    vec2 m = iMouse.xy / iResolution.xy;\n    if (iMouse.z > 0.0) {\n        float hd = -m.x * 14.0 + 3.14159;\n        float elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n        ro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n        ro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n    }\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rayDirection = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n\n    vec3 color = vec3(0.0);\n    float distance = sphereMarch(ro, rayDirection);\n    vec3 point = ro + rayDirection * distance;\n    float lighting = getLight(point);\n    distance /= 9.0;\n    color = vec3(lighting);\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}