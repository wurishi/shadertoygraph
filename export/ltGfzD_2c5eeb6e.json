{"ver":"0.1","info":{"id":"ltGfzD","date":"1541983723","viewed":82,"name":"Raymarch exp1","username":"gest","description":"По мотивам https://www.shadertoy.com/view/XlcfzB","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchcubemap3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Адаптер\n#define u_time iTime\n#define u_canvas iResolution\n#define u_mouse iMouse\n#define u_textureCube0 iChannel0\n#define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n#define textireCube texture\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Object {\n\tfloat\tsteps;\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tfloat \tid;\t\t\t//id элемента сцены\n    vec3    color;\t\t//Цвет элемента\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tfloat  steps;\t\t//Максимальное число итераций\n\tvec3  normal;\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tObject object;\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формируем луч\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvec3 scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n\treturn v;\n}\n//Перемещение вектора\nvec3 translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n\treturn v;\n}\n//Вращение вектора\nvec3 rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n\treturn v;\n}\n//-------------------------------------------\n//Расстояние до бокса\nfloat dBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n//Расстояние до сферы\nfloat dSphere(vec3 p, float radius) { \n\treturn length(p) - radius; \n}\n//-------------------------------------------\n//Карта расстояний до элементов сцены\nfloat map (in vec3 p, out Object object) {\n\tobject.distance = Infinity;\n\tobject.id = 0.;\n    object.color = vec3(1);\n    \n\tfloat d;\n\n\t//Куб\n\tvec3 p1 = p;\n\ttranslate(p1, vec3(-0.3, 0, 0));\n\trotate(p1, vec3(0,1,0)*u_time/4.);\n\td = min( object.distance, dBox( p1 , vec3(0.2) ));\n\tif (object.distance > d) {\n\t\tobject.distance = d;\n\t\tobject.id = 1.;\n        object.color = vec3(1,0,0);\n\t}\n\t\n\t//Сфера\n\tvec3 p2 = p;\n\ttranslate(p2, vec3(0.3, 0, 0));\n\td = min( object.distance, dSphere( p2, 0.2 ));\n\tif (object.distance > d) {\n\t\tobject.distance = d;\n\t\tobject.id = 2.;\n        object.color = vec3(0,1,0);\n\t}\n\n\t//Плоскость\n\tvec3 p3 = p;\n\ttranslate(p3, vec3(0, -2, 0));\n\td = min( object.distance, dBox( p3 , vec3(10,0.01,2) ));\n\tif (object.distance > d) {\n\t\tobject.distance = d;\n\t\tobject.id = 3.;\n        object.color = vec3(0,0,1);\n\t}\n\n\treturn object.distance;\n}\n//Карта расстояний до элементов сцены (без дополнительных параметров)\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\n//Нормали в точке поверхности\nvec3 mapNormal( in vec3 p, float epsilon ) {\n\tmat3 eps = mat3(epsilon);\n\treturn normalize( vec3(\n\t\tmap( p + eps[0]) - map(p - eps[0]),\n\t\tmap( p + eps[1]) - map(p - eps[1]),\n\t\tmap( p + eps[2]) - map(p - eps[2])\n\t));\n}\n//Пересечение луча с элементами сцены\nfloat rayMarch( inout Ray ray ) {\n\t//Минимальное расстояник\n    ray.distance = ray.near;\n\t//Флаг пересечения\t\t\t\t\n    ray.hit = false;\n    for (float i = 0.; i < 128.; ++i) {\n\t\tray.object.steps = i+1.;\n\t\t//Текущая точка луча\n\t\tray.position = ray.origin + ray.distance * ray.direction;\t\n\t\t//Минимальное расстояние до элемента сцены\n        ray.object.distance = map(ray.position, ray.object);\t\t\n        ray.hit = abs(ray.object.distance) < ray.epsilon;\n        //Проверка достижения требуемой точности\n\t\tif (ray.hit) break;    \n\t\t//Перемещаем точку луча\n        ray.distance += ray.object.distance;\t\t\t\t\n\t\t//Проверка достижения предельной дистанции\n        if (ray.distance > ray.far) break;\n\t\t//Проверка ограничения итераций\n\t\tif (ray.object.steps>ray.steps) break;\t\n\t\t\t\n    }\n\tray.distance = min(ray.distance, ray.far);\n\treturn ray.object.steps;\n}\n\nvec3 lightPosition = vec3(2,1,0);\n\nvoid main() {\n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = gl_FragCoord.xy / u_canvas.xy;\n    uv = -1. + 2.*uv;\n\n    vec3 mouse = u_mouse.xyz / vec3(u_canvas.xy, 1.0);\n    mouse.xy = mouse.xy - 0.5;\n    mouse.xy = (u_mouse.xy==vec2(0)) ? (vec2(0)) : (mouse.xy);\n\n    //Формируем камеру\n    Camera cam;\n    {\n        cam.fov \t= 45.;\n        cam.aspect\t= aspect;\n\n        cam.origin \t= vec3(0, 1, 1);\n        translate (cam.origin, vec3(0, 1.+ mouse.y*3.5, 0));\n        rotate (cam.origin, vec3(0,1,0)*(mouse.x*3.5 + PI));\n\n        cam.target \t= vec3(0,0,0); \n        cam.up \t\t= vec3(0,1,0);\n    }\n    //Формируем луч\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.;\n        ray.far  \t= 10.;\n        ray.epsilon = 0.001;\n        ray.steps \t= 128.;\n    }\n    rayMarch(ray);\n\n    //Cubemap\n    vec3 color = textureCube(u_textureCube0, ray.direction).rgb;\n\n    //Пересечение с фигурой\n    if (ray.distance<ray.far) {\n        ray.normal = mapNormal( ray.position, ray.epsilon );\n\n        //Отражение\n        Ray ray1;\n        {\n            ray1.origin \t= ray.position;\n            ray1.direction \t= reflect(ray.direction, ray.normal);\n            ray1.near \t\t= 0.01; //Отступаем от поверхности\n            ray1.far  \t\t= 10.;\n            ray1.epsilon \t= 0.001;\n            ray1.steps \t\t= 64.;\n        }\n        rayMarch(ray1);\n\n        if (ray1.distance<ray1.far) {\n            ray1.normal = mapNormal( ray1.position, ray1.epsilon );\n            color = ray1.object.color * textureCube(u_textureCube0, reflect(ray1.direction, ray1.normal)).rgb*1.5;\n        } else {\n            color = ray.object.color * textureCube(u_textureCube0, reflect(ray.direction, ray.normal)).rgb;\n        }\n\n        //Тень\n        Ray ray2;\n        {\n            ray2.origin \t= ray.position;\n            ray2.direction \t= normalize(lightPosition - ray.position);\n            ray2.near \t\t= 0.01; //Отступаем от поверхности\n            ray2.far  \t\t= distance(lightPosition, ray.position);\n            ray2.epsilon \t= 0.001;\n            ray2.steps \t\t= 64.;\n        }\n        rayMarch(ray2);\n\n        float shadow = 0.;\n        if (ray2.hit && ray2.object.id!=ray.object.id) shadow = 0.5;\n\n        color *= (1.-shadow);\n    }\n    gl_FragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}