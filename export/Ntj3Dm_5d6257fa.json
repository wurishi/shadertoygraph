{"ver":"0.1","info":{"id":"Ntj3Dm","date":"1624040065","viewed":299,"name":"Spherical Clouds","username":"andrew741","description":"Spherical volumetric clouds. Its actually quite hard to make clouds work on a sphere especially with the lighting which still isn't perfect. I plan to combine this with my atmospheric scattering shader to make a really nice planet (similar to earth).","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","noise","clouds","spherical","volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// stores data on a sphere with a hollow center\nstruct SphereData\n{\n    float dstToSphere1;\n    float dstThroughSphere1;\n    float dstToSphere2;\n    float dstThroughSphere2;\n    bool collidedSphere1;\n    bool collidedSphere2;\n    vec3 collideIn1;\n    vec3 collideOut1;\n    vec3 collideIn2;\n    vec3 collideOut2;\n};\n\n\n// finds where (if at all) a ray hits a sphere (i found this function on yt, not my own)\nvec2 RaySphere(vec3 rd, vec3 ro, vec3 sc, float r)\n{\n    vec3 offset = ro - sc;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n\n    float discriminant = b * b - 4. * c;\n\n    if (discriminant > 0.)\n    {\n        float s = sqrt(discriminant);\n        float dstToSphereNear = max(0., (-b - s) / 2.);\n        float dstToSphereFar = (-b + s) / 2.;\n\n        if (dstToSphereFar > 0.)\n        {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n    }\n    return vec2(999999999999999999., 0);\n}\n\n\nSphereData GetSphereData(vec3 rd, vec3 ro)\n{\n    vec2 sphere1 = RaySphere(rd, ro, vec3(0.), 7.);\n    vec2 sphere2 = RaySphere(rd, ro, vec3(0.), 5.);\n\n    bool collided1 = sphere1.x > 99999. ? false : true;\n    bool collided2 = sphere2.x > 99999. ? false : true;\n    vec3 collideIn1 = ro + rd * sphere1.x;\n    vec3 collideOut1;\n    if (!collided2)\n    {\n        collideOut1 = collideIn1 + rd * sphere1.y;  // shouldnt be 0.5\n    }\n    else\n    {\n        collideOut1 = collideIn1 + rd * (sphere1.y - sphere2.y) * 0.5;\n    }\n    vec3 collideIn2 = collideOut1 + rd * sphere2.y;\n    vec3 collideOut2 = collideIn2 + rd * (sphere1.y - sphere2.y) * 0.5;\n    SphereData dat = SphereData(sphere1.x, sphere1.y, sphere2.x, sphere2.y, collided1, collided2, collideIn1, collideOut1, collideIn2, collideOut2);\n    return dat;\n}\n\n\n// this noise method is from https://www.shadertoy.com/view/XslGRr\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel1,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\n\n// samples 3D nosie and stores it in one channel (x aka a float)\nfloat SampleNoise(vec3 p)\n{\n    float h = noise(p);\n    return h;\n}\n\n\nfloat HeightScale(vec3 p)\n{\n    float l = 1. - abs((length(p) - 5.) * 2. - 1.);\n    return pow(l, 2.);\n}\n\n\nfloat lightMarch(vec3 sun_dir, vec3 start)\n{\n    float dstThroughCloud  = RaySphere(sun_dir, start, vec3(0.), 7.).y;\n    float dstThroughCloud2 = RaySphere(sun_dir, start, vec3(0.), 5.).y;\n    \n    if (dstThroughCloud2 > 0.)\n    {\n        dstThroughCloud = (dstThroughCloud - dstThroughCloud2) * 0.5;\n    }\n    float density;\n    vec3 p = start;\n    float total_density = 0.;\n    float step_size = dstThroughCloud / 21.;\n    vec3 step_size_v3 = sun_dir * step_size;\n    for (int s = 0; s < 20; s++)\n    {\n        p += step_size_v3;\n        density = max(SampleNoise(p * 0.5), 0.) * step_size * 4. * HeightScale(p);\n        total_density += density;\n    }\n    if (dstThroughCloud2 > 0.)\n    {\n        p += sun_dir * dstThroughCloud2;\n        for (int s = 0; s < 20; s++)\n        {\n            p += step_size_v3;\n            density = max(SampleNoise(p * 0.5), 0.) * step_size * 4. * HeightScale(p);\n            total_density += density;\n        }\n    }\n    return total_density;\n}\n\n\nstruct CloudData\n{\n    float transmittance, lightEnergy;\n};\n\n\nCloudData Clouds(inout vec3 col, vec3 start, vec3 end, vec3 sun_dir, vec3 sun_col, vec3 rd, float lightEnergy, float transmittance)\n{\n    // renders clouds based on the start and end point\n    vec3 p = start;\n    float step_size_through_cloud = length(end - start) / 61.;\n    step_size_through_cloud = step_size_through_cloud;\n    vec3 step_size = rd * step_size_through_cloud;\n    \n    //float forwardScatter = dot(-sun_dir, rd) * 0.5 + 0.52;\n    \n    float density;\n    float lightDensity;\n    for (int s = 0; s < 60; s++)\n    {\n        p += step_size;\n        density = max(SampleNoise(p * 0.5) * 1.1 - 0.1, 0.) * HeightScale(p) * step_size_through_cloud * 4.;\n        lightDensity = exp(-lightMarch(sun_dir, p) * 0.5);\n        lightEnergy += density * transmittance * lightDensity * 1.;\n        \n        transmittance *= exp(-density);\n        \n        if (transmittance < 0.01) break;\n    }\n    return CloudData(transmittance, lightEnergy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the uv and normalized mouse coordiante\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    // the mouse direction (changes the veiw direction)\n    if (iMouse.z < 0. || iMouse.xy == vec2(0))\n    {\n        m = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.25 + 0.75);\n    }\n\n    // the direction and color of the sun\n    vec3 sun_col = vec3(1., 0.95, 0.9);\n    //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n    vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n    \n    // getting ray direction and position\n    vec3 ro = vec3(0, 1, -1) * 10.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 col = vec3(0., 0., 0.);\n    \n    // getting data on the sphere (pre-calculated for preformace sense the clouds are already slow enough)\n    vec2 textureUV = fragCoord.xy / iResolution.xy;\n    SphereData sphere = GetSphereData(rd, ro);\n    \n    col = vec3(0.3, 0.3, rd.y * 0.5 + 0.5);\n    col = mix(col, sun_col, pow(max(dot(sun_dir, rd), 0.), 200.));\n    if (sphere.collidedSphere1)\n    {\n        if (sphere.collidedSphere2)\n        {\n            // render two sets of clouds\n            CloudData data = Clouds(col, sphere.collideIn1, sphere.collideOut1, sun_dir, sun_col, rd, 0., 1.);\n            data = Clouds(col, sphere.collideIn2, sphere.collideOut2, sun_dir, sun_col, rd, data.lightEnergy, data.transmittance);\n            col = col * data.transmittance + data.lightEnergy;\n        }\n        else\n        {\n            // render one set of clouds\n            CloudData data = Clouds(col, sphere.collideIn1, sphere.collideOut1, sun_dir, sun_col, rd, 0., 1.);\n            col = col * data.transmittance + data.lightEnergy;\n        }\n    }\n\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// generates the distance to the clouds and through the clouds\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 60)\n    {\n        // the uv and normalized mouse coordiante\n        vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n        vec2 m = iMouse.xy / iResolution.xy;\n\n        // the mouse direction (changes the veiw direction)\n        if (iMouse.z < 0. || iMouse.xy == vec2(0))\n        {\n            m = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.25 + 0.75);\n        }\n\n        // the direction and color of the sun\n        vec3 sun_col = vec3(1., 0.95, 0.6);\n        //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n        vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n\n        // getting ray direction and position\n        vec3 ro = vec3(0, 1, -1) * 10.;\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n        vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n        \n        // finding the distance to the start of the cloud sphere\n        vec3 p = ro;\n        float dstToSphere = 0.;\n        bool collided = false;\n        for (int s = 0; s < 460; s++)\n        {\n            float dst = length(p) - 7.;\n            p += rd * dst;\n            dstToSphere += dst;\n            \n            if (dst < 0.001)\n            {\n                collided = true;\n                break;\n            }\n            else if (dstToSphere > 150.) break;\n        }\n        float dstThroughSphere;\n        float dstToSphere2;\n        float dstThroughSphere2;\n        if (!collided)\n        {\n            dstToSphere = -1.;\n            float dstThroughSphere = -1.;\n            float dstToSphere2 = -1.;\n            float dstThroughSphere2 = -1.;\n        }\n        else\n        {\n            // finding the distance through the cloud sphere\n            p += rd * 0.075;\n            dstThroughSphere = 0.;\n            for (int s = 0; s < 460; s++)\n            {\n                float dst = min(-(length(p) - 7.), length(p) - 5.);\n                p += rd * dst;\n                dstThroughSphere += dst;\n\n                if (dst < 0.001 || dstThroughSphere > 150.) break;\n            }\n            // checking if the ray intercects with two layers of clouds (two sides of the sphere)\n            dstToSphere2 = -1.;  // -1 means that that layer dose not esist\n            dstThroughSphere2 = -1.;\n            if (length(p + rd * 0.075) - 7. < 0.)\n            {\n                // the ray will collide with another layer of cloud\n                p += rd * 0.075;\n                for (int s = 0; s < 460; s++)\n                {\n                    float dst = -(length(p) - 5.);\n                    p += rd * dst;\n                    dstToSphere2 += dst;\n\n                    if (dst < 0.001 || dstToSphere2 > 150.) break;\n                }\n                p += rd * 0.05;\n                for (int s = 0; s < 460; s++)\n                {\n                    float dst = -(length(p) - 7.);\n                    p += rd * dst;\n                    dstThroughSphere2 += dst;\n\n                    if (dst < 0.001 || dstThroughSphere2 > 150.) break;\n                }\n            }\n        }\n        \n        fragColor = vec4(dstToSphere, dstThroughSphere, dstToSphere2, dstThroughSphere2);\n    }\n    else\n    {\n        fragColor = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.);\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n","name":"Common","description":"","type":"common"}]}