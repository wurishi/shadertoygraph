{"ver":"0.1","info":{"id":"tlt3WN","date":"1576441030","viewed":265,"name":"Procedural Hexagon Texture","username":"MikeXenix","description":"Modified shader from my precious MechZoneEX project. It is an animated texture inspired by Zone Of The Enders VR training scene. This is my first shader here so it is not excellent...","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["procedural","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Michael Yllo - MikeXenix/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Animated texture inspired by Zone Of The Enders VR training scene\n\n// Original version can be seen in the video https://youtu.be/L0oue-ccvNM\n\n// A bit of a hacked together procedural texture computing the closest distance to a hexagon grid using planes and voronoi regions\nfloat hexTex(vec2 Tex)\n{\n    float degAlpha = 57.0;\n    \n    float alpha = (degAlpha) / 360.0 * 2.0 * 3.14159, cal = cos(alpha), sal = sin(alpha);\n\tfloat beta = ((90.0 - degAlpha) / 360.0 * 2.0 * 3.14159), cbe = cos(beta), sbe = sin(beta);\n\tfloat r = 0.5 / cbe;\n\tvec2 P1 = vec2(r*sbe, r*cbe);\n\tvec2 P2 = vec2(2.0 * r*cal, 0.0);\n\tvec2 N = normalize(P2 - P1);\n\tfloat D = dot(vec2(-N.y, N.x), P1);\n    \n\tfloat v = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.y), 1.0));\n\tfloat v2 = 1.0 - 2.0 * abs(0.5 - mod(abs(Tex.x), 1.0));\n\tfloat d = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D);\n\tfloat d2 = (dot(vec2(-N.y, -N.x), vec2(v2, v)));\n\n\tif (v2 <= r * cal)\n\t{\n\t\tif (d2 > 0.0)\n\t\t\td = abs(d) / D;\n\t\telse if (v < 0.5)\n\t\t\td = abs(0.5 - v) * 2.0;\n\t\telse if (d > 0.0)\n\t\t\td = abs(d2) / D;\n\t\telse\n\t\t\td = abs(0.5 - v) * 2.0;\n\t}\n\telse if (d <= 0.0)\n\t{\n\t\td = abs(d) / D;\n\t}\n\telse\n\t{\n\t\tif (v2 >= 2.0 * r*cal)\n\t\t{\n\t\t\tif (v < 0.5)\n\t\t\t{\n\t\t\t\tvec2 P3 = vec2(0.25, 0.5);\n\t\t\t\tvec2 N2 = normalize(P3 - P2);\n\t\t\t\tfloat D2 = dot(vec2(-N2.y, N2.x), P2);\n\t\t\t\tfloat d3 = (dot(vec2(-N2.y, -N2.x), vec2(v2, v)) - D2);\n\t\t\t\tif (d3 < 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d) / D;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfloat d4 = (dot(vec2(-N.y, N.x), vec2(v2, v)) - D * 2.0);\n\t\t\t\tif (d4 > 0.0)\n\t\t\t\t\td = 1.0 - abs(0.5 - v) * 2.0;\n\t\t\t\telse\n\t\t\t\t\td = abs(d2) / D;\n\t\t\t}\n\t\t}\n\t\telse if (v > 0.5)\n\t\t\td = abs(dot(vec2(-N.y, -N.x), vec2(v2, v))) / D;\n\t\telse\n\t\t\td = abs(d) / D;\n\t}\n\n    return min(0.999, d);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float c = pow(1.0-hexTex(uv.xy*vec2(6.0,3.0)),3.1+2.0*sin(iTime)); // eval texture and bend with pow\n    float ang = atan(uv.x-0.5,uv.y-0.5);\n    float len = length(uv.xy-vec2(0.5,0.5))*5.0;\n    float clrRing = 2.0 * max(0.0,-len * 0.2 + pow(1.0 - abs(sin(-iTime + len + 0.2*cos(ang * 6.0))), 3.0) * (0.5 + pow(c, 2.0)));\n    c = c*abs(sin(iTime*2.0))*(1.0-len*0.3)+clrRing; // combine and animate more\n\n    // Output to screen\n    fragColor = vec4(0,c,c,1.0);\n}","name":"Image","description":"","type":"image"}]}