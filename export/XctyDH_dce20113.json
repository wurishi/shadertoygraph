{"ver":"0.1","info":{"id":"XctyDH","date":"1730584729","viewed":150,"name":"Sound Eclipse Ripple","username":"Spectraledge","description":"I added a ripple effect to the edit by SwagLord which is a twist on DuckMonster's Sound Eclipse.\n\n\n","likes":1,"published":3,"flags":4,"usePreview":0,"tags":["visualization","mic","virtualdj"],"hasliked":0,"parentid":"McSBRy","parentname":"Fork SoundEclip SwagLordLa 430"},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BEATMOVE 1\n\nconst float FREQ_RANGE = 16.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.75;\nconst float BRIGHTNESS = 0.05;\nconst float SPEED = 0.35; // Reduced speed for a more leisurely pace\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n    return texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n    float index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n    return mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius, float replica, float timeOffset) {\n    float dist = length(fragment);\n    \n    // Create a ripple effect using sine waves and iTime\n    float ripple = sin(dist * 8.0 - iTime * 4.0 * replica) * 0.5 + 0.5; // Adjust values for desired ripple speed and intensity\n    radius *= ripple; // Modulate the radius with the ripple\n\n    float ring = 1.0 / abs(dist - radius);\n    \n    float b = dist < radius ? BRIGHTNESS/replica*0.5 * 0.3 : BRIGHTNESS/replica*0.5;\n    \n    vec3 col = vec3(0.0);\n    \n    float angle = atan(fragment.x, fragment.y);\n    col += hsv2rgb(vec3((angle + iTime * 0.25 * replica + timeOffset) / (PI * replica), 1.0, 1.0)) * ring * b;\n    \n    float frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n    col *= frequency;\n    \n    // Black halo\n    col *= smoothstep(radius * 0.5, radius, dist);\n    \n    return col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x, float frequency) {\n    vec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n    \n    float freq = abs(fragment.x * 0.5);\n    \n    col *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(frequency);\n\n    // Add some jaggedness for a lightning effect\n    float lightning = fract(sin(dot(fragment * 80.0, vec2(12.9898,78.233))) * 43758.5453);\n    col *= lightning * smoothstep(radius, radius * 2.8, abs(fragment.x));\n    \n    return col;\n}\n\nvec2 rotate(vec2 uv, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n    fragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0134, 0.052, 0.1);\n\n    float baseRadius = sin(iTime) + 2.0;\n\n    color += doHalo(fragPos, baseRadius * RADIUS * getfrequency(5000.0), 1.0, 0.0);\n    color += doHalo(fragPos, baseRadius * RADIUS * getfrequency(500.0), 2.0, 3.1415);\n    color += doHalo(fragPos, RADIUS * getfrequency(80.0), 3.0, 0.0);\n\n    for (int i = 0; i < 8; i++) { // Increased number of lines\n        float angle = float(i) / 8.0 * PI * 2.0; // Calculate angle for each line\n        vec2 rotatedUv = rotate(fragPos, iTime * SPEED + angle); \n        color += doLine(rotatedUv, baseRadius * RADIUS * getfrequency(1.0 + float(i) * 0.1), rotatedUv.x, 1.0 + float(i) * 0.1);\n    }\n\n    color += max(luma(color) - 1.1, 0.0);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}