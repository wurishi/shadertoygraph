{"ver":"0.1","info":{"id":"3l2yW1","date":"1595855981","viewed":115,"name":"Newton's attractor","username":"lekkel124","description":"Convergence for Newton's Method of the equation z^alpha - 1 = 0, where alpha changes over time.\nThe screen is the complex plane. The colour indicates to which root the method converges starting from that point. The darker, the more steps needed.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","attractor","newton","method"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXITER 100\n#define EPS 0.001\n#define PI 3.14159265359\n#define HORIZONTALUNITAMOUNT 6.0\n#define SPREADFACTOR 2.0\n\n//polar/cartesian conversions\n//see atan2 on wikipedia https://en.wikipedia.org/wiki/Atan2\nvec2 cart2polar(vec2 a)\n{\n    float theta = 0.0;\n    if(a.x > 0.0) {theta = atan(a.y/a.x);}\n    if(a.x <= 0.0 && a.y >= 0.0) {theta = atan(a.y/a.x) + PI;}\n    if(a.x <= 0.0 && a.y < 0.0) {theta = atan(a.y/a.x) - PI;}\n    return vec2(length(a), mod(theta, 2.0*PI));\n}\n\nvec2 polar2cart(vec2 a)\n{\n    return vec2(a.x*cos(a.y), a.x*sin(a.y));\n}\n\n//Complex division (polar form)\nvec2 cDiv(vec2 a, vec2 b)\n{\n    return vec2(a.x/b.x, a.y-b.y);\n}\n\n//Functions (taking and outputing complex numbers in polar form)\nvec2 foo(vec2 a, float exponent)\n{\n    vec2 b = vec2(pow(a.x, exponent), exponent*a.y);\n    vec2 c = polar2cart(b)-vec2(1.0, 0.0);\n    vec2 d = cart2polar(c);\n    return vec2(d.x, mod(d.y, 2.0*PI));\n}\n\nvec2 dfoo(vec2 a, float exponent)\n{\n    return vec2(exponent*pow(a.x, exponent-1.0), mod((exponent-1.0)*a.y, 2.0*PI));\n}\n\n\n//Messing up with other functions. Please ignore.\n\nvec2 cPower(vec2 a, float e)\n{\n    return vec2(pow(a.x, e), mod(e*a.y, 2.0*PI));\n}\n\nvec2 dcPower(vec2 a, float e)\n{\n    return vec2(e*pow(a.x, e-1.0), mod((e-1.0)*a.y, 2.0*PI));\n}\n\nvec2 r2cPower(float e, vec2 a)\n{\n    return vec2(pow(e, a.x*cos(a.y)), mod(log(e)*sin(a.y), 2.0*PI));\n}\n\nvec2 dr2cPower(float e, vec2 a)\n{\n    vec2 b = r2cPower(e, a);\n    return vec2(log(e)*b.x, b.y);\n}\n\nvec2 foo2(vec2 a, float exponent)\n{\n    vec2 part1 = cPower(a, exponent);\n    vec2 part2 = r2cPower(exponent, a);\n    return cart2polar(polar2cart(part1) - polar2cart(part2));\n}\n\nvec2 dfoo2(vec2 a, float exponent)\n{\n    vec2 part1 = dcPower(a, exponent);\n    vec2 part2 = dr2cPower(exponent, a);\n    return cart2polar(polar2cart(part1) - polar2cart(part2));\n}\n\nvec2 foo3(vec2 a, float e)\n{\n    return cart2polar(polar2cart(cPower(a, 3.0*e)) + polar2cart(cPower(a, 2.0*e)) - vec2(1.0, 0.0));\n}\n\nvec2 dfoo3(vec2 a, float e)\n{\n    return cart2polar(polar2cart(dcPower(a, 3.0*e)) + polar2cart(dcPower(a, 2.0*e)));\n}\n\n//http://www.milefoot.com/math/complex/functionsofi.htm\n//Be careful must not be polar. Better naming convention ?\nvec2 csin(vec2 a) { return vec2(sin(a.x)*cosh(a.y), cos(a.x)*sinh(a.y)); }\n\nvec2 ccos(vec2 a) { return vec2(cos(a.x)*cosh(a.y), -sin(a.x)*sinh(a.y)); }\n\nvec2 csinh(vec2 a) { return vec2(sinh(a.x)*cos(a.y), cosh(a.x)*sin(a.y)); }\n\nvec2 ccosh(vec2 a) { return vec2(cosh(a.x)*cos(a.y), sinh(a.x)*sin(a.y)); }\n\n\nvec2 foo4(vec2 a, float e)\n{\n    return cart2polar(csin(polar2cart(a)));\n}\n\nvec2 dfoo4(vec2 a, float e)\n{\n    return cart2polar(ccos(polar2cart(a)));\n}\n\n//Newton's Algorithm\n//Return vec3 where the two first components are the point the method converges towards\n//And the last one is the number of iterations it took.\nvec3 newton(vec2 a0, float exponent)\n{\n  vec2 ai = a0;\n  for (int i = 0; i < MAXITER; i++)\n  {  \n    vec2 zp = cart2polar(ai);\n    ai -= polar2cart(cDiv(foo(zp, exponent), dfoo(zp, exponent)));\n    if(foo(zp, exponent).x <= EPS) {\n    \treturn vec3(zp, float(i));\n    }\n  }\n  return vec3(0.0);\n}\n\n//Colours ------------------------------------------\n\n//See https://www.shadertoy.com/view/3ljyW1 for the colorwheel.\nfloat colorSpike(float theta, float spike)\n{\n    return max(0.0, smoothstep(0.0, 1.0, 1.0 - abs(SPREADFACTOR*(theta - spike))));\n}\n\n\nvec4 colorWheel(float theta)\n{\n    float thetamod = mod(theta, 2.0*PI)/(2.0*PI);\n    return vec4(colorSpike(thetamod, 0.0) + colorSpike(thetamod, 1.0),\n                colorSpike(thetamod, 1.0/3.0) + colorSpike(thetamod, 4.0/3.0),\n                colorSpike(thetamod, 2.0/3.0) + colorSpike(thetamod, -1.0/3.0),\n                1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x - vec2(0.5, 0.5*iResolution.y/iResolution.x);\n    uv *= HORIZONTALUNITAMOUNT;\n    float exponent = 2.0 + 0.1*iTime;\n    vec2 polaruv = cart2polar(uv);\n    vec3 tmp = newton(uv, exponent);\n    vec2 root = tmp.xy;\n    float alpha = sqrt(tmp.z*2.0/(float(MAXITER)));\n    vec4 color = vec4(0.0);\n    if(root != vec2(0,0))\n    {\n        //color = colorWheel(root.y);\n        color = colorWheel(root.y)*(1.0-alpha);\n        //color = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n    /*/if(abs(1.0 - polaruv.x) <= 0.05)\n    {\n        color = colorWheel(polaruv.y);\n    }/*/\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}