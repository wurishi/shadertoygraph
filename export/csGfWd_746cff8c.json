{"ver":"0.1","info":{"id":"csGfWd","date":"1698761529","viewed":73,"name":"Hair_shade_alg_test","username":"Donald","description":"Trying out a new hair shading algorithm. Assumes hair is a particularly unusual type of smoke. Ie it's full continuous infinitesimally fine fur. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//vec3 lvec_=;\nvec3 lvec_=normalize(vec3(-2,10.,-0.4));\nvec3 lcol=vec3(0.5,.3,0.0);\nfloat mask(vec3 p){return pow(clamp(1.5-length(p),0.,1.),2.);}//smoothstep(1.5,1.,dot(p,p));}//1./(1.+exp(dot(p,p)));}\nfloat bright(vec3 p,vec3 lvec){return smoothstep(.7,1.5,dot(p,p))*.7*clamp(dot(normalize(p),lvec),0.,1.)+.4;}\n//vec3 ph(vec3 pos){return mask(pos)*texture(iChannel0, pos.xyz*.5).xyz;}\nvec3 ph(vec3 pos){vec3 p=pos*5.;return mask(pos)*(pow(sin(p.x*1.61-p.z*.73),2.)+pow(cos(p.z*2.34),2.)+pow(cos(p.x-p.z),2.))*vec3(sin(p.x)*cos(p.x+p.y),cos(p.z-p.x)+sin(p.y),-sin(p.z-p.y)*cos(p.x));} \nvec3 curl(vec3 pos){float h=0.00001;\nvec3 v=ph(pos);\nvec3 dx=(ph(pos+vec3(h,0.,0.))-v)/h;\nvec3 dy=(ph(pos+vec3(0.,h,0.))-v)/h;\nvec3 dz=(ph(pos+vec3(0.,0.,h))-v)/h;\n\nreturn vec3(dy.z-dz.y,dz.x-dx.z,dx.y-dy.x);// vec3(ph(pos+vec3(0.,h,0.)).z-v.z,ph(pos+vec3(0.,0.,h)).x-v.x,ph(pos+vec3(h,0.,0.)).y-v.y)/h;\n}\n\nvec2 light(vec3 pos,vec3 dir,float amt){return vec2(0.,1.);}\nvec3 render(vec3 pos,vec3 dir,vec2 uv,vec3 lvec){\n\nvec3 l=vec3(0.);\nfloat lleft=1.;\nfloat mn=0.;\nfloat mx=dot(pos,dir);\n//return vec3(mx);\nfloat eps=0.00000001;\n//if (mask(pos+dir*mx)<eps){return vec3(0.);}\nfor (int j=0;j<10;j++){\n\nfloat md=0.5*(mn+mx);\nif (mask(pos-md*dir)>eps){mx=md;}else{mn=md;\n\n}\n}\n//return vec3(mx);\npos-=mn*dir;\npos-=0.1*dir;\n//return curl(pos);//,lvec)))*.2;\nfloat stp=0.05;\nfor (int i=0;i<int(3./stp);i++){\n\n\nfloat m=mask(pos);\n//0.01/clamp(1./m,0.,10.);\nvec3 hair=curl(pos);\nif (length(hair)>0.0001){\nfloat trans=exp(-length(hair)*stp);\nl+=(1.-trans)*(vec3(0.,0.,.1)+lcol*length(cross(normalize(hair),lvec)))*bright(pos,lvec)*lleft;\nlleft*=trans;\n}\nif (lleft<0.003){break;}\npos+=dir*stp;\n}\n//return vec3(lleft);\n\nreturn l*3.5+texture(iChannel1, uv).xyz*lleft;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_=fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.x;\n    uv-=0.5;\n    uv.y+=0.25;\n    uv*=5.;\n    // Time varying pixel color\n    //vec3 col = curl(vec3(uv,0.0))*0.01;//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n//ph(vec3(uv,-0.01));//\n    // Output to screen\n    float a=0.8+0.4*iTime;\n    mat3 rot1=mat3(vec3(cos(a),sin(a),0.),vec3(-sin(a),cos(a),0.),vec3(0.,0.,1.));\n    mat3 rot2=mat3(vec3(cos(a),0.,sin(a)),vec3(0.,1.,0.),vec3(-sin(a),0.,cos(a)));\n    mat3 rot=rot1*rot2;\n    vec3 col=render(vec3(rot*vec3(uv,-2.)),rot*vec3(0.,0.,1.),uv_,rot*lvec_);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}