{"ver":"0.1","info":{"id":"3ssSWj","date":"1552255119","viewed":89,"name":"#1 Ray_marching_shader","username":"stupak_da","description":"Homework","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Math constants\n#define M_PI 3.1415926535897932384626433832795\n#define e 0.01f\n\n// Raymarching constants\n#define MAX_MARCHING_STEPS 300\n#define MAX_DIST 100.0\n#define FOV (M_PI / 2.0) // In radians\n\n\n// Collision constants\n#define SPHERE 0\n#define PLANE 1\n#define CAPSULE 2\n#define BOX 3\n#define ROUNDBOX 4\n#define TORUS 5\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b*vec3(0.5,1.0,0.5)*2.;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) ;\n}\n\n// Signed-distance function of a sphere\nfloat sphereSDF(in vec3 pos, in float radius, in vec3 center) {\n    return length(pos + center) - radius;\n}\n\n// Signed-distance function of a plane\nfloat planeSDF(in vec3 pos, in vec4 normal) {\n    return dot(pos, normal.xyz) + normal.w;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) /dot(ab,ab);\n    t=clamp(t, 0., 1.);\n    \n    vec3 c = a+t*ab;\n    return length(p-c) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sceneSDF(in vec3 pos, out int collision_id) {\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\n    float d_sphere = sphereSDF(pos, 1.0, vec3(-1.0, 1.0  *sin(iTime), 5));\n    float d_sphere1 = sphereSDF(pos, 1.0, vec3(0.0, 0.0, 3.0));\n    float d_plane = planeSDF(pos, vec4(0.0, 1.0, 0.0, 2.0));\n\tfloat d_box = sdBox(pos - vec3(-2.0,0,-3), vec3(0.2,0.3,0.5));\n    float d_capsule = sdCapsule(pos - vec3(6,0, -2), vec3(-2.0,0,-2),vec3(-2,1,-2), 0.5);\n    float d_Roundbox = sdRoundBox(pos - vec3(2,-1.2,-1), vec3(0.2,0.5,0.5), 0.3);\n    float d_torus = sdTorus(pos - vec3(-2.0/*sin(iTime)*/, (-1.0)*sin(iTime),-1.0), vec2(0.5,0.3));\n    \n    if (d_sphere <= d_plane || d_box <=d_plane || d_capsule <=d_plane || d_Roundbox <=d_plane || d_torus <=d_plane) {\n        float d = min(d_sphere, d_box);\n        d = min(d_capsule, d);\n        d= min(d, d_capsule);\n        d=min(d,d_Roundbox);\n        d=min(d,d_torus);\n        if (d == d_sphere || d == d_sphere1) {\n            collision_id = SPHERE;\n        } else if (d == d_capsule) {\n            collision_id = CAPSULE;\n        }\n        else if (d == d_box) {\n            collision_id = BOX;\n        }\n        else if (d == d_Roundbox) {\n            collision_id = ROUNDBOX;\n        } else if (d==d_torus) {\n            collision_id = TORUS;\n        }\n        return d;\n    } else {\n        collision_id = PLANE;\n        return d_plane;\n    }\n}\n\n// SDF of scene which doesn't tell you what you collide with\nfloat sceneSDF(in vec3 pos) {\n    int collision_id;\n    return sceneSDF(pos, collision_id);\n}\n\n// Estimate the normal off of the scene sdf\nvec3 Normal(in vec3 p) {\n    return normalize(vec3(\n            sceneSDF(vec3(p.x + e, p.y, p.z)) - sceneSDF(vec3(p.x - e, p.y, p.z)),\n            sceneSDF(vec3(p.x, p.y + e, p.z)) - sceneSDF(vec3(p.x, p.y - e, p.z)),\n            sceneSDF(vec3(p.x, p.y, p.z  + e)) - sceneSDF(vec3(p.x, p.y, p.z - e))\n        ));\n}\n\nvec3 board_color(vec3 p) {\n\treturn vec3(1.0, 1.0, 1.0);\n}\n\n//  BRDF\nvec3 blinnPhongContribForLight(in vec3 diffuse_color, in vec3 specular_color, in float alpha, in vec3 p, in vec3 eye,\n                          in vec3 lightPos, in vec3 lightIntensity, in float attenuation) {\n    vec3 N = Normal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    // Light not visible from this point\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // Light reflection in opposite direction as viewer, apply only diffuse lighting\n    if (dotRV < 0.0) {\n        vec3 d= lightIntensity*attenuation;\n        vec3 k = diffuse_color * dotLN;\n        return d*k;\n    }\n\n    // Blinn - phong calculation\n    vec3 half_direction = normalize(normalize(L) + V);\n    float specular = pow(max(dot(half_direction, N), 0.0), 16.0);\n    vec3 light = lightIntensity * diffuse_color * dotLN * attenuation;\n    vec3 color = specular_color * pow(dotRV, alpha) * specular * attenuation;\n    return light+color;\n\n}\n\n\n\nvec3 blinnPhongIllumination(vec3 diffuse_color,\n                            vec3 specular_color, float alpha, float attenuation,\n                            vec3 light_pos, float light_intense,\n                            vec3 point_pos, vec3 eye) {\n    vec3 light_I = light_intense * vec3(1.0, 1.0, 1.0);\n\n    vec3 color = blinnPhongContribForLight(diffuse_color, specular_color, alpha, point_pos, eye,\n                                  light_pos,\n                                  light_I, attenuation);\n    \n\n    return color;\n}\n\n//Camera rotation\nmat3 Rotation(vec2 angle)\n{\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n  mat3 temp = mat3(\n      c.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x);\n    return temp;\n}\n\n//RayMarching algorithm\nfloat RayMarch(in vec3 eye, in vec3 ray_dir, out int collision_id) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n        float d = sceneSDF(eye + depth * ray_dir, collision_id);\n        if (d < e) {\n            return depth;\n        }\n        depth += d;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 rayDirection(in float fieldOfView, in vec2 size, in vec2 frag_coord) {\n    vec2 xy = frag_coord - size / 2.0;\n    float z = size.y / tan(fieldOfView / 2.0);\n    vec3 d = normalize(vec3(xy, -z));\n    return d;\n}\n\n\nfloat shadow_calculate(in vec3 ray_origin, in vec3 ray_direction, in float min_t, \n             in float max_t, in float k) {\n    float res = 1.0;\n    for (float t = min_t; t < max_t; ) {\n        float dist = sceneSDF(ray_origin + ray_direction * t);\n        if (dist < e) {\n            return 0.0;\n        }\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return res;\n}\n\nvec3 calculate_color(vec3 eye, vec3 p, int collision_id, vec3 ray_dir) {\n\n    // Determine / define blinn-phong calculation components\n    vec3 ambient_color = vec3(0.2, 0.2, 0.2);\n    vec3 diffuse_color;\n    if (collision_id == SPHERE) {\n        diffuse_color = vec3(0.0, 0.5, 1.0);\n    } else if (collision_id == PLANE) {\n        diffuse_color = board_color(p);\n    } else if (collision_id == CAPSULE) {\n        diffuse_color = vec3(0.7,0.5,0);\n    } else if (collision_id == BOX) {\n        diffuse_color = vec3(0.5, 0.3, 0.3);\n    } else if (collision_id == ROUNDBOX) {\n        diffuse_color = vec3(0.2, 0.8,0.2);\n    } else if (collision_id == TORUS) {\n        diffuse_color = vec3(1.0,0.0,0.0);\n        ambient_color = vec3(0.5,0,0.5);\n    }\n    \n    vec3 specular_color = vec3(0, 1.0, 1.0);\n    float shininess = 50.0;\n\n    // Light attributes\n    vec3 lightPos1 = vec3(4.0 /** sin(iTime)*/,\n                              1.0,\n                              0.0 /* cos(iTime)*/);\n    float lightIntensity = 1.0f;\n    vec3 lightPos2 = vec3(-4.0, 1.0, 6.0);\n    \n\n    // Compute the ambient component of light\n    vec3 ambient_light = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambient_light * ambient_color;\n\n    // Compute if the point of calculation is obstructed by any objects from the light\n    vec3 shadow_ray1 = normalize(lightPos1 - p);\n    vec3 shadow_ray2 = normalize(lightPos2 - p);\n    float shadow_factor1 = shadow_calculate(p + shadow_ray1, shadow_ray1, 0.0, MAX_DIST, 8.0);\n\tfloat shadow_factor2 = shadow_calculate(p + shadow_ray2, shadow_ray2, 0.0, MAX_DIST, 8.0);\n    // Add the diffuse and specular components\n    vec3 blinn_phong_contribution = blinnPhongIllumination(diffuse_color, specular_color, shininess, 0.5,\n                                    lightPos1, lightIntensity, p, eye) * shadow_factor1;\n    color += blinn_phong_contribution;\n\tblinn_phong_contribution = blinnPhongIllumination(diffuse_color, specular_color, shininess, 0.5,\n                                    lightPos2, lightIntensity, p, eye) * shadow_factor2;\n    color += blinn_phong_contribution;\n    // Reflect light off of the sphere\n\t\n    return color;\n\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*158.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec3 eye = vec3(0, 0, 8);\n    mat3 rot = Rotation((iMouse.xy - iResolution.xy * 0.5).yx * vec2(0.01, -0.01));\n    \n    vec3 ray_dir = rayDirection(FOV, iResolution.xy, fragCoord);\n    vec3 eye1 = vec3(0,0,6);\n\t\n    eye = rot * eye;\n    ray_dir = rot * ray_dir;\n    int collision_id, collision_id1;\n    \n    float dist = RayMarch(eye, ray_dir, collision_id);\n    vec3 p = eye + dist * ray_dir;\n    //vec3 p1=e\n\t\n    vec3 color;\n    if (dist > MAX_DIST - e) {\n        // Create nice gradient effect for the background\n        color = vec3(0.0, .8-sqrt(ray_dir.y * 2.0), .8-sqrt(ray_dir.y * 3.0));\n        vec3 col = pow( color, vec3(0.4545) );\n\n    \t// vignetting    \n    \tcol *= 0.25 + 0.75*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    \t// dithering\n    \tcol += (1.0/255.0)*hash3(q.x+13.0*q.y);\n        fragColor = vec4(col, 1.0);\n        \n    } else {\n        // Something was hit\n        color = calculate_color(eye, p, collision_id, ray_dir);\n        \n    \tvec3 col = pow( color, vec3(0.4545) );\n   \n    \tcol *= 0.25 + 0.75*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    \tcol += (1.0/255.0)*hash3(q.x+13.0*q.y);\n        fragColor = vec4(col, 1.0);\n    \n    }\n}","name":"Image","description":"","type":"image"}]}