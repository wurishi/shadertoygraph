{"ver":"0.1","info":{"id":"3l3fRn","date":"1612105827","viewed":364,"name":"Linked Rings Fractal Tiling","username":"fizzer","description":"A recreation (with some extra shading) of figure 18.10 on p.293 of the book Tessellations by Robert Fathauer (ISBN 978-0-367-18597-8).\nClick and drag for a closer look. Hit T to toggle tiling outlines.","likes":40,"published":1,"flags":16,"usePreview":0,"tags":["fractal","tessellation","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265358979232;\nconst float order = 6.;\nconst float th = pi * 2. / order;\nconst float r2 = .08;\nconst float opp = tan(th / 2.);\nconst float hyp = sqrt(opp * opp + 1.);\n\nconst vec2 q = hyp * vec2(cos(th / 2.), sin(th / 2.));\nconst vec2 thv = vec2(cos(th), sin(th));\nconst mat3 iter_xfrm = mat3(mat2(1. / opp)) * mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(-q.x, -q.y, 1.));\n\nmat2 rot(float th)\n{\n    return mat2(cos(th),sin(th),-sin(th),cos(th));\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0., -sin(a), cos(a), 0., 0., 0., 1.);\n}\n\nvec4 ring(vec2 uv, vec2 rp, float r1, float r2, float sc, vec3 rd, vec3 col, float lod)\n{\n    mat3 envm = rotZ(cos(iTime) * .5) * rotY(sin(iTime) * .3);\n    vec4 res;\n    float u = (length(uv - rp) * sc - r1 + r2 * 2.) / r2;\n    res.a = abs(length(uv - rp) - (r1 - r2 * 2.) / sc) - r2 / sc;\n    u = clamp(u, -1., +1.);\n    vec3 n = vec3(normalize(uv - rp) * u, sqrt(1. - u * u));\n    vec3 r = reflect(rd, n);\n    res.rgb = textureLod(iChannel0, envm * r, lod).rrr * col;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 3.;\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * zoom;\n\n    if(iMouse.z > 0.)\n    {\n        // Zoom in a bit while dragging with the mouse.\n        zoom = 1.2;\n        vec2 offset = (iMouse.xy- iResolution.xy * .5) / iResolution.xy;\n        uv = (fragCoord - iResolution.xy * .5) / iResolution.y * zoom + offset * 4.;\n    }\n\n    vec3 rd = normalize(vec3(uv.xy / 4., 1));\n    vec3 col = vec3(0);\n    vec2 p = uv;\n    \n    // Filter width in 'worldspace'.\n    float w = zoom / iResolution.x;\n    \n    // Local scale.\n    float sc = 1.;\n    \n    float a;\n    int j = 0;\n    \n    mat3 m = mat3(1);\n    \n    // Space-folding loop.\n    for(int i = 0; i < 15; ++i)\n    {\n        float a2 = atan(p.y, p.x);\n        a = mod(a2, th);        \n        mat2 rm = rot(a - a2);\n            \n        m = mat3(rm) * m;\n        p = rm * p;\n        \n        if(p.x < 1. && dot(p - thv, thv) < 0.)\n            break;\n\n        p = (p - q) / opp;\n        m = iter_xfrm * m;\n        \n        if(order == 6.)\n        {\n            p = rot(th / 2.) * p;\n            m = mat3(rot(th / 2.)) * m;\n        }\n\n        sc /= opp;\n        ++j;\n    }\n    \n    float d = min(min(min(p.y, -p.x + 1.), -dot(p - thv, thv)), dot(p, vec2(thv.y, -thv.x)));\n    \n    // Transform ring centers in local space back to worldspace, so that the shading on the rings\n    // can be consistent.\n    vec3 r0p = inverse(m) * vec3(0, 0, 1);\n    vec3 r1p = inverse(m) * vec3(q, 1);\n\n    col = vec3(.05);\n\n    vec3 ringCol0 = vec3(1), ringCol1 = vec3(1, .9, .5);\n    \n    // Swap ring colours on alternate iterations.\n    if((j & 1) == 1)\n    {\n        vec3 temp = ringCol0;\n        ringCol0 = ringCol1;\n        ringCol1 = temp;\n    }\n\n    vec4 ring0, ring1;\n    float lod = .5 + log2(3. * sc * zoom);\n    \n    ring0 = ring(uv, r0p.xy, 1., r2, sc, rd, ringCol0, lod);\n    ring1 = ring(uv, r1p.xy, opp, r2 * opp, sc, rd, ringCol1, lod);\n    \n    // Swap compositing order mid-way across the tile, so that the rings appear linked-together.\n    if(a < th / 2.)\n    {\n        vec4 temp = ring0;\n        ring0 = ring1;\n        ring1 = temp;\n    }\n    \n    // Composite.\n    col = mix(col, ring0.rgb * smoothstep(.0, .07 / sc, ring1.a + .005 / sc), 1. - smoothstep(-w, +w, ring0.a));\n    col = mix(col, ring1.rgb, 1. - smoothstep(-w, +w, ring1.a));\n    \n    if(ring0.a > 0. && ring1.a > 0.)\n        col *= mix(.0, 1., smoothstep(-.1, .11, min(ring0.a, ring1.a)));\n\n    if(texelFetch(iChannel1, ivec2(84, 2), 0).r != 0. && d > 0.)\n        col += vec3(1. - smoothstep(.002, .003,d / (sc * zoom) * 2.)) * .3;\n\n    fragColor = vec4(sqrt(col * 1.3), 1.0);\n}","name":"Image","description":"","type":"image"}]}