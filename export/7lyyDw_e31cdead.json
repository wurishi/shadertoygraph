{"ver":"0.1","info":{"id":"7lyyDw","date":"1661856287","viewed":139,"name":"Lorenz butterfly","username":"akoylasar","description":"A visualisation of the Lorenz equation solved using fourth order Runge-Kutta method.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["attractor","numerical","lorenz","euler","differentialequations","rungekutta"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2022-2022 Fouad Valadbeigi (akoylasar@gmail.com).\n\n#define VERTICES 8\n#define EDGES 12\n\nconst vec4 vertices[8] = vec4[](\n\tvec4(-.5, -.5, -.5, 1.),\n\tvec4(.5, -.5, -.5, 1.),\n\tvec4(.5, .5, -.5, 1.),\n\tvec4(-.5, .5, -.5, 1.),\n\n\tvec4(-.5, -.5, .5, 1.),\n\tvec4(.5, -.5, .5, 1.),\n\tvec4(.5, .5, .5, 1.),\n\tvec4(-.5, .5, .5, 1.)\n\t);\n\nconst ivec2 edges[EDGES] = ivec2[](\n    ivec2(0, 1),\n    ivec2(1, 2),\n    ivec2(2, 3),\n    ivec2(3, 0),\n\n    ivec2(4, 5),\n    ivec2(5, 6),\n    ivec2(6, 7),\n    ivec2(7, 4),\n\n    ivec2(0, 4),\n    ivec2(1, 5),\n    ivec2(2, 6),\n    ivec2(3, 7)\n);\n\n\n// from https://www.shadertoy.com/view/4lfBWf\nfloat segment(vec2 u, vec2 a, vec2 b)  {         \n    b -= a, u -= a;\n    return length(u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nvoid lineTo(vec2 uv, inout vec3 col, vec2 a, vec2 b, float w) {\n    float s = segment(uv, a, b);\n    s = 1. - smoothstep(0., 1., s * w);\n    col = max(col, vec3(s));\n}\n\nmat4 getViewMatrix(vec3 origin, vec3 target) {\n    mat4 m = mat4(0.);\n    vec3 w = normalize(target - origin);\n    vec3 u = normalize(cross(w, WORLD_UP));\n    vec3 v = cross(u, w);\n    m[0] = vec4(u, 0.);\n    m[1] = vec4(v, 0.);\n    m[2] = vec4(w, 0.);\n    m[3] = vec4(origin, 1.);\n    return inverse(m);\n}\n\nmat4 makePerspective(float fovy, float near, float far) {\n    mat4 m = mat4(0.);\n    vec2 s = 1. / tan(vec2(fovy * .5));\n    float d = 1. / (near - far);\n    m[0] = vec4(s.x, 0., 0., 0.);\n    m[1] = vec4(0., s.y, 0., 0.);\n    m[2] = vec4(0., 0., far * d, -1.);\n    m[3] = vec4(0., 0., far * near * d, 0.);\n    return m;\n}\n\nmat4 makeScale(vec3 s) {\n    mat4 m = mat4(0.);\n    m[0] = vec4(s.x, 0., 0., 0.);\n    m[1] = vec4(0., s.y, 0., 0.);\n    m[2] = vec4(0., 0., s.z, 0.);\n    m[3] = vec4(0., 0., 0., 1.);\n    return m;\n}\n\nvec3 drawWireframeBounds(vec2 fragCoord, mat4 viewProj, float scale) {\n    vec3 col = vec3(0.);\n    mat4 mvp = viewProj * makeScale(vec3(scale));\n    \n    vec2 p = 2. * (fragCoord / iResolution.xy) - 1.;\n    float aspect = iResolution.x / iResolution.y;\n    p.x *= aspect;\n        \n    vec4 vertsNdc[VERTICES];\n    for (int i = 0; i < VERTICES; i++) {\n        vertsNdc[i] = mvp * vertices[i];\n        vertsNdc[i].xy /= vertsNdc[i].w;\n    }\n    for (int i = 0; i < EDGES; i++) {\n        ivec2 edge = edges[i];\n        vec4 a = vertsNdc[edge.x];\n        vec4 b = vertsNdc[edge.y];\n        float width = abs(a.z + b.z) * 1.;\n        lineTo(p, col, a.xy, b.xy, width);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 rot = texture(iChannel0, vec2(1.5) / iResolution.xy).zw;\n    float r = cameraDistFromOrigin;\n    float s = r * cos(rot.y);\n    vec3 cameraPos = vec3(s * sin(rot.x), r * sin(rot.y), s * cos(rot.x));\n\n    mat4 view = getViewMatrix(cameraPos, ORIGIN);\n    mat4 projection = makePerspective(cameraFov, 1., 100.);\n    mat4 vp = projection * view;\n    \n    vec4 col = texture(iChannel1, fragCoord / iResolution.xy);\n    col.rgb += drawWireframeBounds(fragCoord, vp, 80.);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SIGMA 10.\n#define BETA 8. / 3.\n#define RHO 28.\n#define DELTA .1\n\nvec3 lorenz(vec3 v) {\n    float xd = SIGMA * (v.y - v.x);\n    float yd = v.x * (RHO - v.z) - v.y;\n    float zd = v.x * v.y - BETA * v.z;\n    return vec3(xd, yd, zd);\n}\n\nvec3 RK4_lorenz(float dt, vec3 v) {\n    vec3 k1 = lorenz(v);\n    vec3 k2 = lorenz(v + dt * k1 * .5);\n    vec3 k3 = lorenz(v + dt * k2 * .5);\n    vec3 k4 = lorenz(v + dt * k3);\n    vec3 vNext = v + dt * (k1 + 2. * k2 + 2. * k3 + k4) / 6.;\n    return vNext;\n}\n\nvec4 getData(vec2 id) {\n    return texture(iChannel0, id / iResolution.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (fragCoord.x >= 2.5 || fragCoord.y >= 2.5) discard;\n    vec4 p = vec4(0.);\n    if (fragCoord == vec2(.5)) {\n        p.xyz = vec3(-8., 8., 27.);\n        if (iFrame > 0 && iMouse.z <= 0.) {\n            p = getData(fragCoord);\n            p.xyz = RK4_lorenz(iTimeDelta, p.xyz);\n        }\n    }\n    if (fragCoord == vec2(1.5)) {\n        p = getData(vec2(1.5)); // xy is prev mouse pos, zw is accumulated mouse delta representing rotation around X and Y axes respectively. \n        p.zw += (1. - step(0., iMouse.w)) * (iMouse.xy - p.xy) / iResolution.xy; \n        p.z = clamp(p.z, -maxXRot, maxXRot);\n        p.w = clamp(p.w, -maxYRot, maxYRot);\n        p.xy = iMouse.xy;\n    }\n\n    fragColor = p;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"struct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nvec4 getData(vec2 id) {\n    return texture(iChannel0, id / iResolution.xy);\n}\n\nRay getRay(in vec2 fragCoord,\n           in vec3 origin,\n           in vec3 target) {\n    vec3 w = normalize(target - origin);\n    vec3 u = normalize(cross(w, WORLD_UP));\n    vec3 v = cross(u, w);\n    \n    vec2 p = 2. * (fragCoord / iResolution.xy) - 1.;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float s = tan(cameraFov * .5);\n    \n    p.x *= s * aspect; \n    p.y *= s;\n    \n    Ray ray;\n    ray.rd = normalize(w + p.x * u + p.y * v);\n    ray.ro = origin;\n    return ray;\n}\n\nfloat intersectSphere(vec4 sphere, Ray ray) {\n    vec3 oc = ray.ro - sphere.xyz;\n    float a = dot(ray.rd, ray.rd);\n    float b = 2.0 * dot(oc, ray.rd);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return -1.0;\n    return (-b - sqrt(d)) / 2.0 * a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 v = getData(vec2(.5));\n    \n    vec4 sphere = vec4(v.xyz, .3);\n    \n    // TODO: Store in buffer and remove duplicates from Image buffer\n    vec2 rot = getData(vec2(1.5)).zw;\n    float r = cameraDistFromOrigin;\n    float s = r * cos(rot.y);\n    vec3 cameraPos = vec3(s * sin(rot.x), r * sin(rot.y), s * cos(rot.x));\n    \n    Ray ray = getRay(fragCoord, cameraPos, ORIGIN);\n    \n    vec3 color = vec3(0.);\n    float t = intersectSphere(sphere, ray);\n    if (t > 0.) {\n        color = mix(vec3(.93, .1, 0.), vec3(0., .85, .98), abs(sin(iTime)));\n    }\n    \n    float alpha = .999 * (1. - step(0., iMouse.z));\n    vec4 prev = texture(iChannel1, fragCoord / iResolution.xy);\n    fragColor = vec4(color + prev.rgb * alpha, 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define PI2 PI * 0.5\n#define RADIANS PI / 180.\n#define WORLD_UP vec3(0., 1., 0.)\n#define ORIGIN vec3(0.)\n\nconst float maxXRot = PI;\nconst float maxYRot = 80. * RADIANS;\n\nconst float cameraFov = 46. * RADIANS;\nconst float cameraDistFromOrigin = 200.;","name":"Common","description":"","type":"common"}]}