{"ver":"0.1","info":{"id":"tdSSWz","date":"1553473760","viewed":2058,"name":"Water heightmap","username":"rls","description":"First time using buffers. Buffer A generates the heightmap, and it's position is offset by itself to achieve the peaks of the waves.\n\nMouse to drag the separator.","likes":23,"published":1,"flags":32,"usePreview":1,"tags":["waves","ripples","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BUMP_HEIGHT 0.004\n\nfloat bumpFunc(vec2 st){\n    float center = length((st-(iMouse.xy/iResolution.xy*1.-vec2(1.))));\n    \n    vec4 samp1 = texture(iChannel0, st);\n    \n    vec2 disp = st;\n    disp.x += samp1.x*0.11;\n    //disp.x = fract(disp.x);\n    \n    vec4 samp2 = texture(iChannel0, disp);\n    \n    return samp2.x;\n}\n\nvec3 bumpMap(vec3 st){\n    vec3 sp = st;\n    vec2 eps = vec2(2./iResolution.y, 0.);\n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    return vec3(fx,fy,0.)*BUMP_HEIGHT;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float mouse = (iMouse.x/iResolution.x);\n    if( iMouse.z<0.001 ) mouse=0.5;\n    \n    vec4 samp1 = texture(iChannel0, uv);\n    \n    vec2 disp = uv;\n    disp.x += samp1.x*0.08;\n    //disp.x = fract(disp.x);\n    \n    vec4 samp2 = texture(iChannel0, disp);\n    \n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    vec3 sp = vec3(uv, 0); // Surface position.\n    vec3 rd = normalize(vec3(uv, 1.)); // Direction vector from the origin to the screen plane.\n    vec3 lp = vec3(iMouse.xy/iResolution.xy, -0.5)*2.; // Light position\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n    \n    sn = normalize( sn + bumpMap(sp));\n    \n    vec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.01);\n\tld /= lDist;  \n    float atten = 1./(1.0 + lDist*lDist*0.01);\n    \n    \n    \n    float diff = max(dot(sn, ld), 0.);  \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 100.);\n    \n    //reflections\n    vec3 ref = reflect( vec3(sp.xy,bumpFunc(sp.xy)), sn );\n    \n  \tvec2 tcx = ref.xy;\n    vec3 env_color = texture(iChannel1,tcx).rgb;\n    vec3 color = env_color;\n    \n    vec3 final = mix(color,samp2.rgb,step(uv.x,mouse));\n    \n    fragColor = vec4(final.r,final.g,final.b,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 1.4;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 coords1 = rotate2d( .9*PI ) * uv;\n    vec2 coords2 = rotate2d( .06*PI ) * uv;\n    \n    coords1.x += iTime*0.1;\n    coords1.y -= iTime*0.3;\n    \n    coords2.x -= iTime*0.1;\n    coords2.y -= iTime*0.2;\n    \n    float wave1 = fbm(vec2(coords1.x*30.0,coords1.y*3.0));\n\tfloat wave2 = fbm(vec2(coords2.x*30.0,coords2.y*3.0));\n    \n    float combinedWaves = mix(wave1,wave2,0.5);\n    \n    combinedWaves = pow(combinedWaves,2.0);\n    \n    fragColor = vec4(combinedWaves);\n}","name":"Buffer A","description":"","type":"buffer"}]}