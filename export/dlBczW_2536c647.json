{"ver":"0.1","info":{"id":"dlBczW","date":"1697556304","viewed":51,"name":"Customizable Portal Shader","username":"WhiteTophat","description":"Mouse X = Portal Hue\nMouse Y = Portal Saturation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["portal","customizable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec4 color = hsv2rgb(vec3(mouseUV.x, mouseUV.y, 1.0)) * vec4(2.0);\n    float density = 3.0;\n    float time = iTime;\n    float radius = 0.7;\n    float angle = 3.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center = vec2(0.5);\n    vec2 resolution = iResolution.xy;\n    float portalAlpha = 1.0;\n    \n    vec2 realCenter = center*iResolution.xy;\n    float realRadius = radius * length(iResolution) / 2.3;\n    \n    fragColor = vec4(1.0);\n    if (distance(fragCoord, realCenter) > realRadius) {\n        fragColor = vec4(0.0);\n    }\n    float dist = distance(fragCoord, realCenter);\n    dist = (1.0 - (dist / length(iResolution.xy) / (radius / 1.5)) - 0.5) * 3.0;\n    fragColor = portalEffect(color, density, time, radius, angle, uv, center, resolution) * dist * fragColor;\n    \n    // Atmosphere/Ground\n    vec4 atmosphere = vec4(1.0 - uv.y) / 2.0;\n    if (uv.y > 0.2) {\n        atmosphere = vec4(1.0 - uv.y) / 5.0;\n    }\n    float value = 1.0 - ((fragColor.r + fragColor.g + fragColor.b + fragColor.a) / 5.0);\n    value = pow(value, 5.0);\n    fragColor = lerp(atmosphere, fragColor, clamp(abs(value * portalAlpha), 0.0, 1.0));\n    \n    float colorDisplay = 0.9;\n    if (uv.y > colorDisplay) {\n        float redEnd = 1.0 / 3.0;\n        float greenEnd = 2.0 / 3.0;\n        if (uv.x < redEnd) fragColor = vec4(color.r, 0.0, 0.0, 1.0);\n        else if (uv.x < greenEnd) fragColor = vec4(0.0, color.g, 0.0, 1.0);\n        else fragColor = vec4(0.0, 0.0, color.b, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (a * vec4(t)) + (b * vec4(1.0-t));\n}\nvec4 lerp(vec4 a, vec4 b, vec4 t) {\n    return (a * t) + (b * (vec4(1.0) * t));\n}\n\nvec4 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6.0 - 3.0) - 1.0; //red\n    float g = 2.0 - abs(hue * 6.0 - 2.0); //green\n    float b = 2.0 - abs(hue * 6.0 - 4.0); //blue\n    vec4 rgb = vec4(r,g,b, 1.0); //combine components\n    rgb = clamp(rgb, 0.0, 1.0); //clamp between 0 and 1\n    return rgb;\n}\nvec4 hsv2rgb(vec3 hsv) {\n    vec4 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = lerp(vec4(1.0), rgb, 1.0 - hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\nfloat getValueFromNumber(vec4 vector, int num) {\n    if (num == 0) return vector.r;\n    if (num == 1) return vector.g;\n    if (num == 2) return vector.b;\n    if (num == 3) return vector.a;\n}\nint getLargest(vec4 vector) {\n    int largest = 0;\n    if (vector.g > getValueFromNumber(vector, largest)) largest = 1;\n    if (vector.b > getValueFromNumber(vector, largest)) largest = 2;\n    if (vector.a > getValueFromNumber(vector, largest)) largest = 3;\n    return largest;\n}\nvec4 normalizeColor(vec4 color) {\n    vec4 normalized = vec4(color.r, color.g, color.b, color.a);\n    int largest = getLargest(color);\n    if (largest == 0) normalized /= vec4(color.r);\n    if (largest == 1) normalized /= vec4(color.g);\n    if (largest == 2) normalized /= vec4(color.b);\n    if (largest == 3) normalized /= vec4(color.a);\n    return normalized;\n}\n\nvec2 hash( vec2 p ){\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n// return distance, and cell id\nvec2 voronoi( in vec2 x, float iTime ){\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\nvec2 swirlUV( float effectRadius, float fxAngle, vec2 _uv, vec2 center, vec2 iResolution ){\n    float effectAngle = fxAngle * PI;\n    center = center == vec2(0., 0.) ? vec2(.5, .5) : center;\n    \n    vec2 uv = _uv - center;\n    \n    float len = length(uv * vec2(iResolution.x / iResolution.y, 1.));\n    float angle = atan(uv.y, uv.x) + effectAngle * smoothstep(effectRadius, 0., len);\n    float radius = length(uv);\n\n    return vec2(radius * cos(angle), radius * sin(angle)) + center;\n}\n\nvec4 portalEffect(vec4 color, float voronoiDensity, float time, float radius, float angle, vec2 _uv, vec2 center, vec2 resolution) {\n    vec2 uv = swirlUV(radius, angle, _uv, center, resolution);\n    return vec4(voronoi(voronoiDensity * uv, time).x) * color;\n}","name":"Common","description":"","type":"common"}]}