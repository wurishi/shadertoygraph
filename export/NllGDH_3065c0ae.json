{"ver":"0.1","info":{"id":"NllGDH","date":"1622134705","viewed":173,"name":"RSM","username":"Shcherbakov","description":"Reflective shadow map. Sample from a stream https://youtu.be/8oyl1gEwHQw","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["gi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool isShadowed(float z, vec2 uv) {\n    float lightDepth = texture(iChannel1, uv).w;\n    return lightDepth + 1e-1 < z;\n}\n\nfloat getShadow(float z, vec2 uv) {\n    return isShadowed(z, uv) ? 0.0 : 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float RADIUS = 15.0;\n    vec3 CAMERA_POS = vec3(RADIUS * sin(iTime), 3, RADIUS * cos(iTime));\n    vec3 viewTarget = vec3(0, 3, 0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 forward = normalize(viewTarget - CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    fragColor = vec4(0);\n    for (int i = -1; i < 1; ++i) {\n        for (int j = -1; j < 1; ++j) {\n            vec3 viewVec = normalize(forward\n                + up * (uv.y * 2.0 + float(i) / iResolution.x * 0.5)\n                + right * (uv.x * 2.0 + float(j) / iResolution.x * 0.5));\n\n            float t = INF;\n            vec3 normal;\n            vec3 color;\n\n            bool intersected = floorTrace(CAMERA_POS, viewVec, t, normal, color);\n            intersected = pyramidTrace(CAMERA_POS, viewVec, t, normal, color) || intersected;\n            intersected = templeTrace(CAMERA_POS, viewVec, t, normal, color) || intersected;\n            intersected = BoxTrace(CAMERA_POS, viewVec, t, normal, color) || intersected;\n\n            // Output to screen\n            if (intersected) {\n                vec3 worldPos = CAMERA_POS + t * viewVec;\n                vec3 toLight = LIGHT_POS - worldPos;\n                vec3 lightVec = -normalize(toLight);\n                vec3 lightForward = normalize(-LIGHT_POS);\n                vec3 lightUp = vec3(0, 0, 1);\n                vec3 lightRight = normalize(cross(lightForward, lightUp));\n                lightUp = cross(lightRight, lightForward);\n                float forwardScale = dot(lightVec, lightForward);\n                vec3 scaledLightVec = lightVec / forwardScale;\n                vec2 lightUV = vec2(dot(scaledLightVec, lightRight), dot(scaledLightVec, lightUp));\n                lightUV /= LIGHT_UV_SCALE;\n                lightUV = (lightUV * iResolution.x + iResolution.xy * 0.5) / iResolution.xy;\n\n                float shadow = 0.0;\n                vec3 secColor = vec3(0, 0, 0);\n                if (lightUV.x > 0.0 && lightUV.x < 1.0 && lightUV.y > 0.0 && lightUV.y < 1.0) {\n                    shadow = getShadow(length(toLight), lightUV);\n                }\n                vec3 secondaryLighting = vec3(0);\n                int SAMPLES_COUNT = 15;\n                float samples_count = float(SAMPLES_COUNT);\n                float R = 0.3;\n                int count = 0;\n                for (int i = 0; i < SAMPLES_COUNT; ++i) {\n                    for (int j = 0; j < SAMPLES_COUNT; ++j) {\n                        vec2 uv = (vec2(i, j) + 0.5) / samples_count;\n                        float phi = float(i) / samples_count * 2.0 * M_PI;\n                        uv = vec2(sin(phi), cos(phi)) * (float(j) + 0.5) / samples_count * R + lightUV;\n                        if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0) {\n                            continue;\n                        }\n                        vec2 encNormal = texture(iChannel1, uv).yz;\n                        vec3 sampleNormal = vec3(\n                            cos(encNormal.x) * sin(encNormal.y),\n                            sin(encNormal.x) * sin(encNormal.y),\n                            cos(encNormal.y)\n                        );\n                        uint encColor = uint(texture(iChannel1, uv).x);\n                        vec3 sampleColor = vec3(encColor >> 16u, (encColor >> 8u) & 0xFFu, encColor & 0xFFu) / 255.0;\n                        float sampleDepth = texture(iChannel1, uv).w;\n                        uv = (uv * iResolution.xy- iResolution.xy * 0.5) / iResolution.x;\n                        vec3 viewVec = normalize(lightForward\n                            + lightUp * (uv.y * LIGHT_UV_SCALE)\n                            + lightRight * (uv.x * LIGHT_UV_SCALE));\n                        vec3 samplePos = LIGHT_POS + viewVec * sampleDepth;\n                        secondaryLighting += sampleColor // lengthSq(samplePos - worldPos)// * 100.0\n                            * max(0.0, dot(normal, normalize(samplePos - worldPos)))\n                            * max(0.0, dot(sampleNormal, -normalize(samplePos - worldPos)));\n                        count += 1;\n                    }\n                }\n                secondaryLighting /= float(count);\n                \n                fragColor.rgb += color * (\n                    max(0.0, dot(normal, normalize(toLight))) * shadow\n                    + secondaryLighting\n                    + textureLod(iChannel0, normal, 7.0).rgb * 0.1);\n                //fragColor.rgb += secondaryLighting;\n            } else {\n                fragColor += texture(iChannel0, viewVec);\n            }\n        }\n    }\n    fragColor /= 4.0;\n    /*vec2 encNormal = texture(iChannel1, fragCoord / iResolution.xy).yz;\n    vec3 normal = vec3(\n        cos(encNormal.x) * sin(encNormal.y),\n        sin(encNormal.x) * sin(encNormal.y),\n        cos(encNormal.y)\n    );\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy).wwww / 50.0;\n    uint encColor = uint(texture(iChannel1, fragCoord / iResolution.xy).x);\n    vec3 color = vec3(encColor >> 16u, (encColor >> 8u) & 0xFFu, encColor & 0xFFu) / 255.0;\n    fragColor.xyz = color;*/\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec3 LIGHT_POS = vec3(0, 42, 0);\nconst float INF = 1e10;\nconst float LIGHT_UV_SCALE = 0.7;\n\n#define RSM 1\n\nfloat lengthSq(vec3 a) {\n    return dot(a, a);\n}\n\n#define M_PI 3.14159265358979323846\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nfloat rand (vec2 co, float l) {return rand(vec2(rand(co), l));}\nfloat rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}\n\nfloat perlin(vec2 p, float dim, float time) {\n\tvec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\tfloat c = rand(pos, dim, time);\n\tfloat cx = rand(posx, dim, time);\n\tfloat cy = rand(posy, dim, time);\n\tfloat cxy = rand(posxy, dim, time);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;\n}\n\n// p must be normalized!\nfloat perlin(vec2 p, float dim) {\n\treturn perlin(p, dim, 0.0);\n}\n\nfloat floorSDF(vec3 pos) {\n    return pos.y - 0.3 + clamp(perlin(pos.xz, 5.0) * 0.5 + 0.5, 0.0, 1.0) * 0.2;\n}\n\nfloat floorTrace(vec3 pos, vec3 dir) {\n    // (pos + t * dir).y == 0\n    float t = (0.5 - pos.y) / dir.y;\n    if (t < 0.0) {\n        return INF;\n    }\n\n    vec3 worldPos = pos + t * dir;\n    const float MARCH_SIZE = 0.01;\n    float sdf = floorSDF(worldPos);\n    for (int i = 0; i < 100; ++i) {\n        t += max(MARCH_SIZE, sdf);\n        worldPos = pos + t * dir;\n        sdf = floorSDF(worldPos);\n        if (sdf < 0.0) {\n            return t;\n        }\n    }\n    return t;\n}\n\nvec3 calcFloorNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(floorSDF(p+h.xyy) - floorSDF(p-h.xyy),\n                           floorSDF(p+h.yxy) - floorSDF(p-h.yxy),\n                           floorSDF(p+h.yyx) - floorSDF(p-h.yyx) ) );\n}\n\nbool floorTrace(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) {\n    float floor_t = floorTrace(pos, dir);\n    if (floor_t == INF || floor_t > t) {\n        return false;\n    }\n    t = floor_t;\n    vec3 worldPos = pos + t * dir;\n    normal = calcFloorNormal(worldPos);\n    color = vec3(0xf1, 0xca, 0x89) / 255.0;\n    return true;\n}\n\nfloat planeTrace(vec3 pos, vec3 dir, vec4 plane) {\n    // dot(pos + t * dir, plane) = -plane.w\n    float t = -dot(vec4(pos, 1), plane) / dot(dir, plane.xyz);\n    if (t < 0.0) {\n        return INF;\n    }\n    return t;\n}\n\nbool pyramidTrace(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) {\n    pos.y *= 0.5;\n    dir.y *= 0.5;\n    pos.y -= 2.5;\n    const int PLANES_COUNT = 5;\n    vec4 planes[PLANES_COUNT];\n    planes[0] = vec4(1, 1, 0, -sqrt(2.0));\n    planes[1] = vec4(-1, 1, 0, -sqrt(2.0));\n    planes[2] = vec4(0, 1, 1, -sqrt(2.0));\n    planes[3] = vec4(0, 1, -1, -sqrt(2.0));\n    planes[4] = vec4(0, -1, 0, 0);\n    bool inter = false;\n    for (int i = 0; i < PLANES_COUNT; ++i) {\n        float plane_t = planeTrace(pos, dir, planes[i]);\n        if (plane_t == INF || plane_t > t) {\n            continue;\n        }\n        vec3 worldPos = pos + plane_t * dir;\n        bool inner = true;\n        for (int j = 1; j < PLANES_COUNT; ++j) {\n            inner = inner && dot(vec4(worldPos, 1), planes[(i + j) % PLANES_COUNT]) < 0.0;\n        }\n        if (!inner) {\n            continue;\n        }\n        t = plane_t;\n        normal = normalize(planes[i].xyz);\n        color = vec3(0xaa, 0x1c, 0x20) / 255.0;\n        inter = true;\n    }\n    return inter;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat tampleSDF(vec3 pos) {\n    return -sdPyramid(pos, 1.0) - 0.001 * perlin(-pos.xz * 5.0, 25.0);\n}\n\nvec3 calcPyramidNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(tampleSDF(p+h.xyy) - tampleSDF(p-h.xyy),\n                           tampleSDF(p+h.yxy) - tampleSDF(p-h.yxy),\n                           tampleSDF(p+h.yyx) - tampleSDF(p-h.yyx) ) );\n}\n\n\nbool templeTrace(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) {\n    float dist = 0.0;\n    const float H = 1.0;\n    const float SCALE = 1.0 / 40.0;\n    const float MARCH_SIZE = 0.0025 / SCALE;\n    vec3 worldPos = (pos + dist * dir) * SCALE;\n    float sdfRound = 0.06;\n    float sdf = tampleSDF(worldPos);\n    float sg = sign(sdf);\n    sdf *= sg;\n    for (int i = 0; i < 200; ++i) {\n        dist += max(MARCH_SIZE, sdf / SCALE);\n        if (dist > t) {\n            return false;\n        }\n        worldPos = (pos + dist * dir) * SCALE;\n        sdf = tampleSDF(worldPos) * sg;\n        if (sdf < 0.0) {\n            if (worldPos.y > 0.97) {\n                return false;\n            }\n            t = dist;\n            normal = calcPyramidNormal(worldPos);\n            color = vec3(0xcc, 0x9b, 0x6d) / 255.0;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nfloat sdBox(vec3 p)\n{\n  vec3 b = vec3(1.0 + p.y * 0.2, 1.5, 1.0 + p.y * 0.2);\n  p.y -= 2.6;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.1 + 0.03 * perlin(p.xz + p.y, 5.0);\n}\n\n\nvec3 calcBoxNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(sdBox(p+h.xyy) - sdBox(p-h.xyy),\n                           sdBox(p+h.yxy) - sdBox(p-h.yxy),\n                           sdBox(p+h.yyx) - sdBox(p-h.yyx) ) );\n}\n\nbool BoxTrace(vec3 pos, vec3 dir, inout float t, inout vec3 normal, inout vec3 color) {\n    float dist = 0.0;\n    const float MARCH_SIZE = 0.01;\n    vec3 worldPos = pos;\n    float sdf = sdBox(worldPos);\n    for (int i = 0; i < 60; ++i) {\n        dist += max(MARCH_SIZE, sdf);\n        if (dist > t) {\n            return false;\n        }\n        worldPos = (pos + dist * dir);\n        sdf = sdBox(worldPos);\n        if (sdf < 0.0) {\n            t = dist;\n            normal = calcBoxNormal(worldPos);\n            color = vec3(1, 1, 1);\n            return true;\n        }\n    }\n    return false;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float RADIUS = 15.0;\n    vec3 viewTarget = vec3(0, 0, 0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 forward = normalize(viewTarget - LIGHT_POS);\n    vec3 up = vec3(0, 0, 1);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    fragColor = vec4(0);\n    vec3 viewVec = normalize(forward\n        + up * (uv.y * LIGHT_UV_SCALE)\n        + right * (uv.x * LIGHT_UV_SCALE));\n\n    float t = INF;\n    vec3 normal;\n    vec3 color;\n\n    bool intersected = floorTrace(LIGHT_POS, viewVec, t, normal, color);\n    intersected = pyramidTrace(LIGHT_POS, viewVec, t, normal, color) || intersected;\n    intersected = templeTrace(LIGHT_POS, viewVec, t, normal, color) || intersected;\n    intersected = BoxTrace(LIGHT_POS, viewVec, t, normal, color) || intersected;\n\n    // Output to screen\n    if (intersected) {\n        color *= max(0.0, dot(normal, -viewVec));\n        uvec3 encColor = uvec3(color * 255.0) << uvec3(16, 8, 0);\n        fragColor.x = float(encColor.x | encColor.y | encColor.z);\n        fragColor.z = acos(normal.z);\n        fragColor.y = atan(normal.y, normal.x);\n        fragColor.w = t;\n    } else {\n        fragColor.w = INF;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}