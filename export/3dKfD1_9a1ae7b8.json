{"ver":"0.1","info":{"id":"3dKfD1","date":"1607029511","viewed":135,"name":"Real-time tunnel","username":"lechuga2000","description":"Real-time tunnel","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","realtime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Eye\nvec3 eye;\n\n// Light\nvec3 lightColor = vec3(0.5, 1.0, 0.2);\nvec3 lightPosition;\n\n// tunnel\nconst vec2 tunnelCenter = vec2(0.0);\nfloat tunnelRadius = 1.0;\n\nvec3 tunnelMaterialDiffuse = vec3(1.0);\nvec3 tunnelMaterialAmbient = vec3(0.1);\nvec3 tunnelMaterialSpecular = vec3(0.7);\nfloat tunnelMaterialShininess = 50.0;\n\nvec3 color(in vec3 lightPosition, in vec3 normal, in vec3 materialAmbient, in vec3 materialDiffuse\n               , in vec3 materialSpecular, in float materialShininess, in vec3 rayIntersection)\n{\n  vec3 L = normalize(lightPosition - rayIntersection);\n  vec3 E = normalize(eye - rayIntersection);\n  vec3 R = normalize(-reflect(L, normal));\n\n  vec3 Idiffuse = materialDiffuse * max(dot(normal, L), 0.0);\n  vec3 Ispecular = materialSpecular * pow(max(dot(R, E), 0.0), 0.3 * materialShininess);\n\n  return clamp(materialAmbient + Idiffuse + Ispecular, 0.0, 1.0);\n}\n\nvec3 tunnelColor(in vec3 lightPosition, in vec3 rayIntersection)\n{\n  vec3 normal = -normalize(vec3(rayIntersection.xy, 0.0));\n\n  float dmax = min(10.0, iTime);\n  float d = max(0.0, (dmax - length(rayIntersection - lightPosition)) / dmax);\n\n  return d * mix(color(lightPosition, normal, tunnelMaterialAmbient, tunnelMaterialDiffuse, tunnelMaterialSpecular\n                     , tunnelMaterialShininess, rayIntersection), lightColor, d);\n}\n\nbool tunnelIntersection(in vec3 rayOrigin, in vec3 rayDirection, out float t)\n{\n  float aa = pow(rayOrigin.x, 2.0);\n  float ab = rayOrigin.x * rayDirection.x;\n  float bb = pow(rayDirection.x, 2.0);\n  float cc = pow(rayOrigin.y, 2.0);\n  float cd = rayOrigin.y * rayDirection.y;\n  float dd = pow(rayDirection.y, 2.0);\n  float rr = pow(tunnelRadius, 2.0);\n\n  float bbdd = bb + dd;\n  if (bbdd > 1.0e-5)\n  {\n    t = (sqrt(-aa * dd + 2.0 * ab * cd - bb * cc + bb * rr + dd * rr) - ab - cd) / bbdd;\n    return true;\n  }\n  else\n  {\n    return false;\n  }\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy - 0.5;\n  uv.x *= iResolution.x / iResolution.y;\n\n  // Eye\n  eye = vec3(0.0, 0.0, -2.0 * iTime);\n\n  // Light\n  lightPosition = eye + 0.6 * vec3(cos(2.0 * iTime), sin(1.5 * iTime), -6.0 * (1.3 + sin(iTime)));\n\n  vec3 rayDirection1 = normalize(eye);\n  vec3 rayDirection2 = cross(rayDirection1, vec3(0.0, -1.0, 0.0));\n  vec3 rayDirection3 = cross(rayDirection1, rayDirection2);\n  \n  mat3 m = rotationMatrix(rayDirection1, cos(iTime));\n  rayDirection2 *= m;\n  rayDirection3 *= m;\n\n  vec3 rayDirection = normalize(rayDirection1 + uv.x * rayDirection2 + uv.y * rayDirection3);\n\n  fragColor = vec4(0.0);\n\n  float spotA = acos(dot(rayDirection, normalize(lightPosition - eye)));\n  float spotAMax = 5.0e-3 * (10.0 + (lightPosition.z - eye.z));\n  if (spotA < spotAMax)\n  {\n    fragColor += vec4(lightColor, 1.0) * (1.0 - spotA / spotAMax);\n  }\n\n  float t;\n  if (tunnelIntersection(eye, rayDirection, t))\n  {\n    vec3 rayIntersection = eye + t * rayDirection;\n    fragColor += vec4(tunnelColor(lightPosition, rayIntersection), 1.0)\n         * texture(iChannel0, vec2(atan(rayIntersection.y, rayIntersection.x), -rayIntersection.z));\n  }\n}","name":"Image","description":"","type":"image"}]}