{"ver":"0.1","info":{"id":"XlXBWH","date":"1511694265","viewed":228,"name":"[WST1] Night in the city","username":"johnny66","description":"Good evening in Wroclaw\nEvening city\nDobry wieczór we wrocławiu\n","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["city","wroclaw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MsSSR1","filepath":"https://soundcloud.com/user5384344/the-prodigy-climbatize","previewfilepath":"https://soundcloud.com/user5384344/the-prodigy-climbatize","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Title: Good evening in Wroclaw, Author: Jonatan\n// This shader is prepared for the first Wroclaw Shader Competition \"\n// organized by Faculty of Physics and Astronomy, Khronos Chapter and SIggraph Chapter from Wroclaw\"\n\n#define LIMIT 1187000\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = sin( x.x * 17.11 );\n    float yhash = cos( x.y * 5.2 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\n\n\n\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 4.0, 5.0 , 1.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.4, 4.4), c.y);\n}\n\nfloat cam(float f) {\n    float tt = mod(f, 25.0) * 3.0;\n\tfloat go = smoothstep(3.0, 45.0, tt) - smoothstep(6.0, 95.0, tt);\n    return go *540.0*iTime;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    float t = iTime;\n    //stars\n    vec3 vColor = vec3( (sin(t)*0.1)*.32, (sin(t)*0.1)*.32, 0.4 ) * fragCoord.y / iResolution.y;\n    float StarFieldThreshhold = 0.98;\n\n    // Stars with a slow crawl.\n    float xRate = 0.2;\n    float yRate = 0.0;\n    vec2 vSamplePos = fragCoord.xy + vec2( xRate * float( iFrame ), yRate * float( iFrame ) );\n\tfloat StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n    vColor += vec3( StarVal );\n\t//fragColor = vec4(vColor, 1.0);\n        \n    //stars\n    \n    \n    float x = floor(fragCoord.x) + floor(cam(t));\n    float y = floor(fragCoord.y)+ floor (sin(cam(t)));\n    float wtf = 1.;\n    float c = 0.0;    \n    float bgOff = 1.0;\n\n    for (int k = 0; k < LIMIT; k++) {\n        c++;\n        \n        if (x <= 1.) {\n            c = 0.2;\n            bgOff = 0.1;\n        \tbreak;   \n        }\n        if (c >= y / (0.0014 * iResolution.y)) {\n        \tbreak;   \n        }\n        if (mod(x,  2.0) == 0.0) {\n            x = x / 2.0;\n        } else {\n            x = x * 3.0 + wtf;\n            if (x <= wtf * 4.0) {\n            \tx = 9990.0;   \n            }\n        }\n       \n    }\n   \n   // fragColor = vec4(vColor, 1.0);\n    fragColor = \n   vec4(hsv2rgb(vec3(x/2., 0.33, 0.5 * bgOff)), 1.0)   \n   + vec4(vColor, 1.0)\n   + vec4(.1,.1,.1,1.0)\n   + vec4((sin(t)*0.41)*.32,(sin(t)*0.41)*.32, sin(t)*.4, 1.0) ;\n    \n    \n    \n    \n}\n\n\n\n","name":"Image","description":"","type":"image"}]}