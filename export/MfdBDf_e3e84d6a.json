{"ver":"0.1","info":{"id":"MfdBDf","date":"1733595948","viewed":104,"name":"2d fish silhouette","username":"ircss","description":"simple fish shilloute animation","likes":14,"published":3,"flags":0,"usePreview":0,"tags":["procedural","animation","fish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat rand(float seed) \n{\n  return fract(sin(seed *52.02) * 762.2);\n}\n\nfloat movement(float seed, float timeOfset)\n{\n  float speed = 1.;\n  float d = sin(rand(seed           ) * 512.2 + (iTime + timeOfset)  *0.4 * speed) *0.5;\n        d+= sin(rand(seed*12.+613.52) * 61.2  + (iTime + timeOfset)  *0.3 * speed) *0.25;\n        d+= sin(rand(seed*83.+22.52 ) * 721.2 + (iTime + timeOfset)  *1.2 * speed) *0.25;\n\n  return d;\n}\n\n\n// -------------------------------\n// THE ACTUAL LINE COORD FUNCTION\n// Alternativly you could also construct a 3x3 matrix with p2-p1 in x column, ortho to that in the y column and z column coordinates of p1, then multiply the pixel coordinates with that to transform the coordinate to the line coordinate. For line segments you would still have to clamp. This will probably be more instructions due to 3x3 having unnesscerly multiplications on zero entries\nvec3 LineSegCoord(vec2 p1, vec2 p2, vec2 uv){\n    \n\n    vec2 vector = p2 - p1;                      // Find the vector between the two lines\n     vec2 ortho    = vec2(vector.y, -vector.x);     // For 3D you would have to use cross product or something\n\n          uv   -= p1;                           // Move the entire coord system so that the point 1 sits on the origin, it is either that or always adding point 1 when you want to find your actual point\n    float len   = length(vector);               // Find the ditance between the two points\n       vector  /= len;                          // normalize the vector \n    float vUv   = dot(vector, uv);              // Find out how far the projection of the current pixel on the line goes along the line using dot product\n    vec2  p     = vector * clamp(vUv, 0.,len) ; // since vector is normalized, the if you multiplied it with the projection amount, you will get to the coordinate of where the current uv has the shortest distance on the line. The clamp there ensures that this point always remains between p1 and p2, take this out if you want an infinite line\n  \n            uv += ortho * sin((iTime *0.4  + vUv)*25.)*0.1 * smoothstep(0.3, 0.0, vUv); \n  \n    vec2 ToLine = p - uv;                       \n    float d     = length(ToLine);               // the actual distance between the current pixel and its projection on the line\n    \n   \n    float signedD = dot(ortho, ToLine);            // this gives you a signed distance between the current pixel and the line. in contrast to the value d, first this value is signed, so different on the different sides of the line, and second, for a line segment with finite ends, beyond the finit end, the magnitude of this value and d start to differ. This value will continue to get smaller, as you go around the corner on the finit edge and goes into negative\n    \n    return vec3(vUv, d, signedD); \n}\n\nvec2 movement2D(float seed, float timeOfset)\n{\n    return vec2(movement(seed, timeOfset), movement(seed + 21.7132, timeOfset));\n}\n\nvoid drawFish(inout vec3 sceneColor, in vec2 uv, in vec3 fishColor, in float seed)\n{\n    vec2 fishHead = (movement2D(seed , 0.0) + vec2(1.)) * 0.5;\n    vec2 fishHeadNext =(movement2D(seed , 0.1) + vec2(1.)) * 0.5 ;\n    vec2 direction = fishHeadNext - fishHead;\n    vec2 fishTail = fishHead  + normalize(direction) * -1.* 0.2;\n    \n    vec3 linCord = LineSegCoord(fishTail, fishHead, uv);\n    \n    float fishBoarder = (sin(linCord.x * 25. + 3.6) *0.5 + 0.5) * 0.020 * smoothstep(0.5,0.0,abs(linCord.x - 0.2));\n    sceneColor = mix( fishColor, sceneColor, smoothstep(fishBoarder, fishBoarder + 0.01, linCord.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n\n    // Time varying pixel color\n    vec3 col = mix(vec3(0.00784313725490196, 0.403921568627451, 0.6627450980392157), \n    vec3(0., 0.792156862745098, 0.9882352941176471), smoothstep(0., 1., uv.y));\n    \n    vec3 fishColor = vec3(0.00392156862745098, 0.11764705882352941, 0.1803921568627451);\n    \n    uv.x -= (iResolution.x/iResolution.y) *0.25;\n    \n    drawFish(col, uv, fishColor, 0.);\n    drawFish(col, uv, fishColor, 2.125125);\n    drawFish(col, uv, fishColor, 9.12351);\n    drawFish(col, uv, fishColor, -5.83125);\n    drawFish(col, uv, fishColor, 1.8231);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}