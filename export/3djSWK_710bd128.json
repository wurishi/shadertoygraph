{"ver":"0.1","info":{"id":"3djSWK","date":"1555028948","viewed":287,"name":"4x4D Perlin Noise","username":"scratch13764","description":"A 4 channel 4 dimensional Perlin noise algorithm with the analytical normal of the fourth channel.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","gradient","volumetric","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct vec16 // 4x vec4\n{\n    vec4 x, y, z, w;\n};\n\nstruct vec8 // 2x vec4\n{\n    vec4 x, y; \n    // Used to hold the values of noise and the derivative of the alpha channel\n};\n\nvec16 hash (vec4 p) // uh\n{\n    p = round(p); // Just a hardware issue on my computer, you probably don't need this\n    vec4 a = -1. + 2.*fract(\n        vec4(4825.39872, 5978.23875, 2938.69837, 7981.19439)*\n        sin(p.x*29.847 + p.y*74.947 + \n            p.z*34.684 + p.w*91.234));\n    vec4 b = -1. + 2.*fract(\n        vec4(8274.84872, 8763.17864, 5763.89345, 7185.87917)*\n        sin(p.x*22.398 + p.y*93.478 + \n            p.z*93.239 + p.w*25.252));\n    vec4 c = -1. + 2.*fract(\n        vec4(9287.29472, 6782.62067, 9872.75203, 4987.28734)*\n        sin(p.x*74.973 + p.y*63.289 + \n            p.z*34.428 + p.w*50.982));\n    vec4 d = -1. + 2.*fract(\n        vec4(3287.97291, 9247.82436, 2874.38254, 6298.92293)*\n        sin(p.x*43.834 + p.y*78.934 + \n            p.z*48.934 + p.w*48.729));\n    return vec16(a, b, c, d);\n}\n\nvec4 dott (vec16 f, vec4 v) //\"No matching overload function found\"\n{\n    return vec4(\n    dot(f.x, v),\n    dot(f.y, v),\n    dot(f.z, v),\n    dot(f.w, v));\n}\n\nvec8 perlin4x4 (vec4 p)\n{\n    // Address and interpolation values\n    vec4 f = fract(p),\n    m = f*f*f*(f*f*6. - f*15. + 10.);\n    p -= f;\n\n    // Interpolating the gradients for noise\n    vec4 noise = mix(mix(mix(\n        mix(dott(hash(p + vec4(0,0,0,0)), f - vec4(0,0,0,0)), \n            dott(hash(p + vec4(1,0,0,0)), f - vec4(1,0,0,0)), m.x), \n        mix(dott(hash(p + vec4(0,1,0,0)), f - vec4(0,1,0,0)), \n            dott(hash(p + vec4(1,1,0,0)), f - vec4(1,1,0,0)), m.x), m.y), mix(\n        mix(dott(hash(p + vec4(0,0,1,0)), f - vec4(0,0,1,0)), \n            dott(hash(p + vec4(1,0,1,0)), f - vec4(1,0,1,0)), m.x), \n        mix(dott(hash(p + vec4(0,1,1,0)), f - vec4(0,1,1,0)), \n            dott(hash(p + vec4(1,1,1,0)), f - vec4(1,1,1,0)), m.x), m.y), m.z), mix(mix(\n        mix(dott(hash(p + vec4(0,0,0,1)), f - vec4(0,0,0,1)), \n            dott(hash(p + vec4(1,0,0,1)), f - vec4(1,0,0,1)), m.x), \n        mix(dott(hash(p + vec4(0,1,0,1)), f - vec4(0,1,0,1)), \n            dott(hash(p + vec4(1,1,0,1)), f - vec4(1,1,0,1)), m.x), m.y), mix(\n        mix(dott(hash(p + vec4(0,0,1,1)), f - vec4(0,0,1,1)), \n            dott(hash(p + vec4(1,0,1,1)), f - vec4(1,0,1,1)), m.x), \n        mix(dott(hash(p + vec4(0,1,1,1)), f - vec4(0,1,1,1)), \n            dott(hash(p + vec4(1,1,1,1)), f - vec4(1,1,1,1)), m.x), m.y), m.z), m.w);\n    // Interpolating the values of the gradients for the first derivative normal\n    // (of the alpha channel)\n    // It's faster to recalculate the hashes by the way\n    vec4 derivative = mix(mix(mix(\n        mix(hash(p + vec4(0,0,0,0)).w, \n            hash(p + vec4(1,0,0,0)).w, m.x), \n        mix(hash(p + vec4(0,1,0,0)).w, \n            hash(p + vec4(1,1,0,0)).w, m.x), m.y), mix(\n        mix(hash(p + vec4(0,0,1,0)).w, \n            hash(p + vec4(1,0,1,0)).w, m.x), \n        mix(hash(p + vec4(0,1,1,0)).w, \n            hash(p + vec4(1,1,1,0)).w, m.x), m.y), m.z), mix(mix(\n        mix(hash(p + vec4(0,0,0,1)).w, \n            hash(p + vec4(1,0,0,1)).w, m.x), \n        mix(hash(p + vec4(0,1,0,1)).w, \n            hash(p + vec4(1,1,0,1)).w, m.x), m.y), mix(\n        mix(hash(p + vec4(0,0,1,1)).w, \n            hash(p + vec4(1,0,1,1)).w, m.x), \n        mix(hash(p + vec4(0,1,1,1)).w, \n            hash(p + vec4(1,1,1,1)).w, m.x), m.y), m.z), m.w);\n    return vec8(noise, derivative);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float a = iTime/2.;\n    \n    vec3 ro = -vec3(sin(a), 0, cos(a))*7.5;\n    vec3 rs = normalize(vec3(uv, 1));\n    rs.xz *= mat2(cos(-a),-sin(-a),sin(-a),cos(-a));\n    \n    vec3 p;\n    \n    fragColor = vec4(0.);\n    if (uv.x < cos(iTime/2.))\n    {\n        for (float d = 9.; d >= 5.; d -= .25)\n        {\n            vec3 p = ro + rs*d;\n            vec8 n = perlin4x4(vec4(p*1.25, iTime/2.));\n            n.x = n.x*.5 + .5;\n            fragColor = mix(fragColor, n.x*.75+.25,\n                        pow(n.x.a, 6.)*smoothstep(3., 2.7, length(p)));\n        }\n        fragColor *= 2.;\n    }else{\n\t    float d = 5.;\n        vec8 noise;\n        float m;\n        vec3 norm;\n        for (d; d <= 8.;)\n        {\n            noise = perlin4x4(vec4((ro+rs*d)*1.25, iTime/2.));\n            m = max(length(ro+rs*d)-2.8, -noise.x.w*.5+.05);\n            if (m <= .01)\n            {\n                p = ro+rs*d; \n                fragColor = noise.x*.5+.5;\n                norm = normalize((length(p) < 2.8)? noise.y.xyz : p);\n                fragColor += .7*max(pow(dot(reflect(rs, norm), vec3(.577)), 9.), 0.);\n                fragColor *= dot(norm, vec3(.577))*.25+.75;\n                break;\n            }\n            d += m;\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}