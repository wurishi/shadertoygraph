{"ver":"0.1","info":{"id":"dddXDl","date":"1680860022","viewed":74,"name":"Perlin noise terrain test","username":"TrashProgrammer","description":"Heightmap test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WATER_HEIGHT 8.0\n\nconst int MAX_STEPS = 250;\nconst float MIN_HIT_DIST = 0.05;\nconst float MAX_TRACE_DIST = 300.0;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 d = vec2(1.0, 0.0);\n    \n    f = (f* (6.*f - 15.) + 10.)*f*f*f;\n    \n    float q11 = rand(i);\n    float q21 = rand(i + d.xy);\n    float q12 = rand(i + d.yx);\n    float q22 = rand(i + d.xx);\n    \n    float x1 = mix(q11, q21, f.x);\n    float x2 = mix(q12, q22, f.x);\n    \n    return mix(x1, x2, f.y);\n}\n\nfloat fbm(vec2 p) {\n    return 0.5 * noise(p + vec2(12.3435, 7.6483)) \n         + 0.25 * noise(2.0 * p + vec2(4.3334, 15.8788))\n         + 0.125 * noise(4.0 * p + vec2(1.2934, 8.4558));\n}\n\nfloat h(vec3 p) {\n    float grass = 0.0;\n    float height = -15.0 * noise(p.xz * 0.0667) - 5.0 * noise(p.xz * 0.1) - 2.5 * noise(p.xz * 0.2);\n    if(-height + fbm(p.xz) > 10.0) {\n        grass = 0.12 * noise(p.xz * 15.0);\n    };\n    return p.y + height - grass ;\n}\n\nfloat mapWorld(vec3 p) {\n    vec2 k = vec2(1.0, -1.0);\n    float d = 0.001;\n    float de = 500.0;\n    vec3 dd = (k.xyy*h( p + k.xyy*d ) + \n         k.yyx*h( p + k.yyx*d ) + \n         k.yxy*h( p + k.yxy*d ) + \n         k.xxx*h( p + k.xxx*d )) * de;\n    float dist = h(p) / length(dd); \n    return dist;\n}\n\n//https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(in vec3 p) {\n    vec2 k = vec2(1.0, -1.0);\n    float d = 0.001;\n    vec3 n = normalize(\n        k.xyy*h( p + k.xyy*d ) + \n        k.yyx*h( p + k.yyx*d ) + \n        k.yxy*h( p + k.yxy*d ) + \n        k.xxx*h( p + k.xxx*d )\n    );\n    \n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDirection, float tStart) {\n    float t = tStart;\n    bool hit = false;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 position = rayOrigin + t * rayDirection;\n       \n        float closestDistance = mapWorld(position);\n        if(closestDistance < MIN_HIT_DIST) {\n            t += closestDistance;\n            hit = true;\n            break;\n        }\n   \n        t += closestDistance;\n       \n        if(t > MAX_TRACE_DIST) {\n            break;\n        }\n    }\n    return vec2(t, hit);\n}\n\n//https://iquilezles.org/articles/fog/\nvec3 applyFog( in vec3  rgb, in float dist) {\n    float b = 0.02;\n    float fogAmount = 1.0 - exp( -dist *b );\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    vec3 cameraPos = vec3(5.0 * iTime, 25.0, -10.0 + -5.0 * sin(iTime));\n    vec3 rayDirection = normalize(vec3(ndc, 1.0));\n    \n    vec2 result = rayMarch(cameraPos, rayDirection, 0.0);\n    vec3 col = vec3(0.5294, 0.8078, 0.9216);\n    \n    if(result.y == 1.0) {\n        vec3 finalPos = cameraPos + result.x * rayDirection;\n        vec3 viewDir = normalize(cameraPos - finalPos);\n        vec3 lightDir = normalize(-finalPos);\n        vec3 halfDir = normalize(viewDir + lightDir);\n        vec3 normal = getNormal(finalPos);\n        float water = WATER_HEIGHT + 0.5*sin(iTime * 0.01);\n        if(finalPos.y + fbm(finalPos.xz) > 10.0) {\n            col = vec3(0.3373, 0.4902, 0.2745);\n            normal += vec3(fbm(finalPos.xz * 2.0), 1.0, fbm(finalPos.zx * 2.0));\n            normal.y /= 5.0 * abs(noise(10. * finalPos.xz));\n        } else {\n            col = (1.0 - exp(-0.95 * (finalPos.y - water))) * vec3(0.588, 0.294, 0.0); \n            normal += vec3(fbm(finalPos.xz * 5.0), 0.0, fbm(finalPos.zx * 5.0));\n        }\n        normal = normalize(normal);\n        float spec = pow(max(dot(normal, halfDir), 0.0), 32.0);\n        col -= abs(0.3 * fbm(finalPos.xz * 0.5));\n        col = col * (spec + dot(normal, viewDir));\n        col = applyFog(col, result.x);\n        if(finalPos.y < water) {\n            const float k = 1.1;\n            col = mix(vec3(0.0, 0.0, 1.0), col, exp(k * (finalPos.y - water)));\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}