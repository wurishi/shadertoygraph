{"ver":"0.1","info":{"id":"fttBRS","date":"1663258420","viewed":88,"name":"homework1&2","username":"Stolyarova","description":"homework","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","car"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nconst vec3 eye = vec3(0., 0., 5.);\nconst vec3 lightpos = vec3(0., 15.,  -10.);\nconst vec3 ligthcolor = vec3(1.);\n\nconst int m_plane = 1;\nconst int m_base = 2;\nconst int m_wheel = 3;\nconst int m_car = 4;\n\n\nconst mat2 m2 = mat2(0.1, -1.2,\n                     1.2,  0.1);\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx<0.0 && cay<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(cax*cax + cay*cay*baba,\n                     cbx*cbx + cby*cby*baba) );\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.5;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.7;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \nfloat GetDistCar(vec3 p)\n{\n   \n    float CillinderDist =  sdCappedCylinder(p - vec3(-1, .5, 1.5), vec3(0.3,0.,0), vec3(-0.4,0.,0.), 0.5);\n    float Cillinder1Dist =  sdCappedCylinder(p - vec3(1, .5, -1.5), vec3(0.3,0.,0), vec3(-0.4,0.,0.), 0.5);\n    float Cillinder2Dist =  sdCappedCylinder(p - vec3(-1, .5, -1.5), vec3(0.3,0.,0), vec3(-0.4,0.,0.), 0.5);\n    float Cillinder3Dist =  sdCappedCylinder(p - vec3(1, .5, 1.5), vec3(0.3,0.,0), vec3(-0.4,0.,0.), 0.5);\n    \n    float BoxDist = rounding(sdBox(p - vec3(0.0, 0.7, 0.1), vec3(0.85, 0.2, 2.4)), 0.3);\n    float form1 = opSubtraction(CillinderDist,BoxDist);\n    float form2 = opSubtraction(Cillinder1Dist, form1);\n    float form3 = opSubtraction(Cillinder2Dist, form2);\n    float form4 = opSubtraction(Cillinder3Dist, form3);\n    \n    form1 = sdPlane(p, normalize(vec3(0., 1., 0.3)), 0.1);\n    form4 = opSmoothSubtraction(form1, form4, 0.1);\n    form1 = sdPlane(p, normalize(vec3(0, 1, 0.25)), -1.6);\n    form4 = opSmoothIntersection(form1, form4, 0.1);\n    form1 = sdPlane(p, normalize(vec3(0, 1, -0.2)),0.);\n    form4 = opSmoothSubtraction(form1, form4, 0.1);\n    form1 = sdPlane(p, normalize(vec3(1, 0, 0.25)),-1.6);\n    form4 = opSmoothIntersection(form1, form4, 0.2);\n    form1 = sdPlane(p, normalize(vec3(1, 0, -0.25)),1.6);\n    form4 = opSmoothSubtraction(form1, form4, 0.2);\n    \n    \n    BoxDist = sdBox(p - vec3(0., 2.2, 0.), vec3(0.75, 0.6, 1.5));\n    float PiramidDist = rounding(sdPyramid(p-vec3(0., 1.2, 0.), 0.8), 0.17);\n    float Cone = sdRoundCone(p-vec3(0., 0.5, 0.), vec3(0, 0.5, 0.2), vec3(0., 0.55, -1.8), 0.9, 0.1);\n    float Tri1 = rounding(udTriangle(p - vec3(0.1, 0.6, -0.5), vec3(0.7, 0.6, -.21), vec3(0.43, 1., -0.), vec3(0.4, 0.5, -1.5)) - 0.01, 0.1);\n    float Tri2 = rounding(udTriangle(p - vec3(-0.1, 0.6, -0.5), vec3(-0.7, 0.6, -.21), vec3(-0.43, 1., -0.), vec3(-0.4, 0.5, -1.5)) - 0.01, 0.1);\n    \n    form1 = opSmoothUnion(PiramidDist, Cone, 0.2);\n    form2 = opSmoothUnion(form1, Tri1, 0.01);\n    form3 = opSmoothUnion(form2, Tri2, 0.01);\n    form2 = opSmoothSubtraction(BoxDist, form3, 0.2);\n    form3 = opSmoothUnion(form2, form4,0.3);\n    \n    const float k = .1;\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,s,-s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    form1 = rounding(udQuad(q - vec3(0, 0.6, -0.5), vec3(0.75, 0.7, -1.8), vec3(0.75, 0.72, -1.9),vec3(-0.75, 0.7, -1.8), vec3(-0.75, 0.72, -1.9))-0.01, 0.1);\n    form3 = opUnion(form1, form3);\n    return form3;\n}\n\nfloat GetDistWheels(vec3 p)\n{\n    float CillinderDist = rounding(sdCappedCylinder(p - vec3(-0.8, .49, 1.5), vec3(0.2,0.,0), vec3(-0.2,0.,0.), 0.35), 0.1);\n    float Cillinder1Dist = rounding(sdCappedCylinder(p - vec3(0.8, .49, -1.5), vec3(0.2,0.,0), vec3(-0.2,0.,0.), 0.35), 0.1);\n    float Cillinder2Dist = rounding(sdCappedCylinder(p - vec3(-0.8, .49, -1.5), vec3(0.2,0.,0), vec3(-0.2, 0.,0.), 0.35), 0.1);\n    float Cillinder3Dist = rounding(sdCappedCylinder(p - vec3(0.8, .49, 1.5), vec3(0.2,0.,0), vec3(-0.2,0.,0.), 0.35), 0.1);\n\n    float form1 = opUnion(CillinderDist, Cillinder1Dist);\n    float form2 = opUnion(form1, Cillinder2Dist);\n    float form3 = opUnion(form2, Cillinder3Dist);\n    return form3;\n}\n\nfloat GetDist(vec3 p) {\n\n    float base = sdCappedCone(p, vec3(0., 0., 0.), vec3(0., .1, 0.), 4.1, 4.);\n    \n    float planeDist = p.y;\n     \n    p.xz *= Rot(iTime);\n    float Car = GetDistCar(p);\n    float Wheels = GetDistWheels(p);\n    \n    float d =  min(base, planeDist);\n    d = min(Car, d);\n    d = min(d, Wheels);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, inout bool hit) {\n\tfloat dO=0.;\n    hit = false;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST)\n            break;\n        if(dS<SURF_DIST) \n        {\n            hit = true;\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion ( in vec3 pos, in vec3 normal )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n\n    for ( int i = 0; i < 5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = GetDist( pos + h*normal );\n\n        occ += (h-d)*sca;\n        sca *= 0.95;\n\n        if ( occ > 0.35 ) \n            break;\n    }\n\n    return clamp ( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*normal.y);\n}\n\n\nvec3 getTriplanarWeights(in vec3 n) {\n    vec3 weights = pow(abs(n), vec3(2.));\n    return weights / (weights.x + weights.y + weights.z);\n}\n\nvec3 fresnel(in vec3 f0, in float product) {\n    product = clamp(product, 0., 1.);\n    return mix(f0, vec3(1.), pow(1. - product, 5.));\n}\n\nfloat D_GGX(in vec3 n, in vec3 lightVec, in vec3 v, in float roughness) {\n    float r2 = roughness * roughness;\n    float r4 = r2 * r2;\n    vec3 h = normalize(lightVec + v);\n    float nh = dot(n, h);\n    float nh2 = nh * nh;\n    float d = (r4 - 1.) * nh2 + 1.;\n    return r4 / (3.14 * d * d);\n}\n\nfloat G_neumann(in vec3 n, in vec3 lightVec, in vec3 v) {\n    float nl = dot(n, lightVec);\n    float nv = dot(n, v);\n    return nl * nv/ max(nl, nv);\n}\n\nvec3 cookTorrance(in vec3 n, in vec3 lightVec, in vec3 v, in vec3 f0, in float roughness) {\n    float D = D_GGX(n, lightVec, v, roughness);\n    float G = G_neumann(n, lightVec, v);\n    return f0 * D * G;\n}\n\nint material(vec3 p){\n    \n    float b_dist = sdCappedCone(p, vec3(0., 0., 0.), vec3(0., .1, 0.), 4.1, 4.);\n    float p_dist = p.y;\n    float t_dist = GetDist(p); \n    p.xz *= Rot(iTime);\n    float c_dist = GetDistCar(p);\n    float w_dist = GetDistWheels(p);\n    if(t_dist == p_dist)\n        return m_plane;\n    else if(t_dist == c_dist)\n        return m_car;\n    else if(t_dist == w_dist)\n        return m_wheel;\n    else if(t_dist == b_dist)\n        return m_base;\n    \n}\n\nvoid ColorRoughnessMetalness(int material, in vec3 point,\n                             inout vec3 baseColor, inout float roughness,\n                             inout float metalness) {\n\n    if (material == m_car) {\n       \n        baseColor = vec3(0., .5, 0.4);\n\n        float average = (baseColor.r + baseColor.g + baseColor.b) / 3.;\n        roughness = baseColor.r - average;\n        metalness = pow((1. - roughness), 2.);\n        roughness *= 2.;\n        baseColor = clamp(baseColor * 1.5, 0., 1.);\n    }\n    else if (material == m_wheel) {\n        \n        baseColor = vec3(0.2, 0.2, 0.2);\n\n        float average = (baseColor.r + baseColor.g + baseColor.b) / 3.;\n        roughness = baseColor.r - average;\n        roughness = (roughness + 0.047058824) / 0.215686275;\n        metalness = pow((1. - roughness), 2.);\n        roughness *= 3.;\n        baseColor = clamp(baseColor * 1.5, 0., 1.);\n    }\n    else if (material == m_base) {\n        vec3 n1 = GetNormal(point);\n        vec3 pos = point;\n        vec3 tx = getTriplanarWeights (n1);\n        vec2 textureScale = 5.0 * iResolution.xy/max(iResolution.x, iResolution.y);\n\n        pos.xz *= Rot(iTime); \n        vec4 cx = texture(iChannel2, pos.yz / textureScale + 0.5);\n        vec4 cy = texture(iChannel2, pos.zx / textureScale + 0.5);\n        vec4 cz = texture(iChannel2, pos.xy / textureScale + 0.5);\n        baseColor = vec4(cx * tx.x + cy * tx.y + cz * tx.z).xyz;\n\n        float average = (baseColor.r + baseColor.g + baseColor.b) / 3.;\n        roughness = baseColor.r - average;\n        roughness = (roughness + 0.047058824) / 0.215686275;\n        metalness = pow((1. - roughness), 2.);\n        roughness *= 3.;\n        baseColor = clamp(baseColor * 1.5, 0., 1.);\n    }\n    else if (material == m_plane) {\n        baseColor = texture(iChannel0, point.xz * 0.25).rgb * vec3(1.);\n        metalness = 0.;\n        roughness = 1.;\n    }\n}\n\nbool isInShadow(in vec3 p, in vec3 l, in vec3 n) {\n    bool hit;\n    float d = RayMarch(p+n*SURF_DIST*2., l, hit);\n    if (d < length(lightpos - p))\n        return true;\n    return false;\n}\n\nvec3 calculateLighting(in vec3 baseColor, in float metalness, in float roughness,\n                       in vec3 n, in vec3 v, in float nv, in vec3 lightVec, in float nl,\n                       in vec3 point, in float dist, in int material) {\n              \n    baseColor = pow(baseColor, vec3(2.));\n    \n    vec3 F0;\n    if (material == m_car)\n        F0 = vec3(0.77, 0.78, 0.78);\n    else if (material == m_wheel)\n        F0 = vec3(0.21, 0.21, 0.21);\n    else if (material == m_base)\n        F0 = vec3(0.04);\n    else if (material == m_plane)\n        F0 = vec3(0.04);\n        \n    F0 = mix(F0, baseColor, metalness);\n    vec3 specFresnel = fresnel(F0, nv);\n    vec3 spec = cookTorrance(n, lightVec, v, specFresnel, roughness)\n        * nl / max(0.001, 4.* nl * nv);\n    vec3 diff = (vec3(1.) - specFresnel) * nl / 3.14;\n    vec3 color = (diff * mix(baseColor, vec3(0.), metalness) + spec) * ligthcolor;\n    color += 0.25 * baseColor * ambientOcclusion(point, n);\n\n    if (isInShadow(point, lightVec, n) && (material == m_base || material == m_plane))\n        color *= vec3(0.25, 0.3, 0.5);\n\n    color = pow(color, vec3(1. / 2.));\n    color = mix(color, vec3(0.3, 0.2, 0.5) , pow(dist/MAX_DIST, 1.));\n    \n    return color;\n}\n\nvec3 getColor(in vec3 point, in float dist, in vec3 ro) {\n    int mat = material(point);\n        \n    vec3 lightVec = normalize(lightpos - point);\n    vec3 n = GetNormal(point);\n    vec3 v = normalize(ro - point);\n    float nv = dot(n, v);\n    float nl = max(0., dot(n, lightVec));\n\n    vec3 baseColor;\n    float metalness, roughness;\n\n    ColorRoughnessMetalness(mat, point, baseColor, roughness, metalness);  \n    \n    vec3 color = calculateLighting(baseColor, metalness, roughness, \n                                   n, v, nv, lightVec, nl,  point, dist, mat);\n    return color;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 skyColor(in vec3 rayOrigin, in vec3 rayDirection) {\n    vec3 color = vec3(0.3, 0.2, 0.5) - 0.5 * rayDirection.y;    \n    return color;\n}\n\nfloat fractionalBrownianMotion(vec2 point) {\n    float f = 0.0;\n    \n    f += 0.5000 * texture(iChannel1, (point + 0.4 * iTime)/256.0).x;\n    point = m2 * point * 2.02;\n    \n    f += 0.2500 * texture(iChannel1, (point + 0.1 * iTime)/256.0).x;\n    point = m2 * point * 2.03;\n    \n    f += 0.1250 * texture(iChannel1, point / 256.0).x;\n    point = m2 * point * 2.01;\n    \n    f += 0.0625 * texture(iChannel1, point/256.0).x;\n    return f / 0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    bool hit;\n    \n    vec3 ro = vec3(0, 4, -5);\n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(1.*.2-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n    float d = RayMarch(ro, rd, hit);\n    \n    vec3 p = ro + rd * d;\n    vec3 color = skyColor(ro, rd);\n    \n    vec2 sc = ro.xz + rd.xz * (250.*5000. - ro.y) / rd.y;\n    vec3 clouds = mix(color, vec3(0.5, 0.45, 0.5),\n        0.6 * smoothstep(0.4, 0.8, fractionalBrownianMotion(0.0001*sc/250.)));\n    if (rd.y > 0.)\n        color = mix(color, clouds, clamp(rd.y, 0., 0.01) * 100.);\n      \n    if (hit)\n        color = getColor(p, d, ro);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}