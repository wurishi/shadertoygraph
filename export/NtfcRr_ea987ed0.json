{"ver":"0.1","info":{"id":"NtfcRr","date":"1647417413","viewed":252,"name":"PathTracer - Reflective+Glossy","username":"Pikachuxxxx","description":"simple quad and sphere based path tracer, using cornel box for demo + Now with added reflective and Glossy materials with a hacky de-noiser","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"Nlfczn","parentname":"PathTracer - Diffuse"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFAST APPROXIMATION OF https://www.shadertoy.com/view/3dd3Wr\n\n[\nThis project did NOT use any code from the /\\ above, I was creating this\nwhilst comparing its visuals to the above project\n]\n\nBoi if anybody uses this script you better not change the name of the function\n\nBy: Sir Bird / Zerofile\n\n*/\n\n#define SAMPLES 80  // HIGHER = NICER = SLOWER\n#define DISTRIBUTION_BIAS 0.6 // between 0. and 1.\n#define PIXEL_MULTIPLIER  1.5 // between 1. and 3. (keep low)\n#define INVERSE_HUE_TOLERANCE 20.0 // (2. - 30.)\n\n#define GOLDEN_ANGLE 2.3999632 //3PI-sqrt(5)PI\n\n#define pow(a,b) pow(max(a,0.),b) // @morimea\n\nmat2 sample2D = mat2(cos(GOLDEN_ANGLE),sin(GOLDEN_ANGLE),-sin(GOLDEN_ANGLE),cos(GOLDEN_ANGLE));\n\nvec3 sirBirdDenoise(sampler2D imageTexture, in vec2 uv, in vec2 imageResolution) {\n    \n    vec3 denoisedColor           = vec3(0.);\n    \n    const float sampleRadius     = sqrt(float(SAMPLES));\n    const float sampleTrueRadius = 0.5/(sampleRadius*sampleRadius);\n    vec2        samplePixel      = vec2(1.0/imageResolution.x,1.0/imageResolution.y); \n    vec3        sampleCenter     = texture(imageTexture, uv).rgb;\n    vec3        sampleCenterNorm = normalize(sampleCenter);\n    float       sampleCenterSat  = length(sampleCenter);\n    \n    float  influenceSum = 0.0;\n    float brightnessSum = 0.0;\n    \n    vec2 pixelRotated = vec2(0.,1.);\n    \n    for (float x = 0.0; x <= float(SAMPLES); x++) {\n        \n        pixelRotated *= sample2D;\n        \n        vec2  pixelOffset    = PIXEL_MULTIPLIER*pixelRotated*sqrt(x)*0.5;\n        float pixelInfluence = 1.0-sampleTrueRadius*pow(dot(pixelOffset,pixelOffset),DISTRIBUTION_BIAS);\n        pixelOffset *= samplePixel;\n            \n        vec3 thisDenoisedColor = \n            texture(imageTexture, uv + pixelOffset).rgb;\n\n        pixelInfluence      *= pixelInfluence*pixelInfluence;\n        /*\n            HUE + SATURATION FILTER\n        */\n        pixelInfluence      *=   \n            pow(0.5+0.5*dot(sampleCenterNorm,normalize(thisDenoisedColor)),INVERSE_HUE_TOLERANCE)\n            * pow(1.0 - abs(length(thisDenoisedColor)-length(sampleCenterSat)),8.);\n            \n        influenceSum += pixelInfluence;\n        denoisedColor += thisDenoisedColor*pixelInfluence;\n    }\n    \n    return denoisedColor/influenceSum;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const vec2 iChannel0Resolution = vec2(512, 512);\n    \n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    color = sirBirdDenoise(iChannel0, uv, iChannel0Resolution).rgb;\n    \n    // apply exposure (how long the shutter is open)\n    color *= c_exposure;\n    \n    // convert unbounded HDR color range to SDR color range\n    color = ACESFilm(color);\n \n    // convert from linear to sRGB for display\n    color = LinearToSRGB(color);\n \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Path Tracer Settings\n// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 100.0f;\n\n// number of ray bounces allowed\nconst int c_numBounces = 4;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// a pixel value multiplier of light before tone mapping and sRGB\nconst float c_exposure = 0.5f; \n\n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int c_numRendersPerFrame = 8;\n\nconst float KEY_SPACE = 32.5/256.0;\n\n/////////////////////////////////\n// math constants\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n/////////////////////////////////\n// math util\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/////////////////////////////////\n// Hit Info\nstruct SMaterialInfo\n{\n    vec3 albedo;           // the color used for diffuse lighting\n    vec3 emissive;         // how much the surface glows\n    float percentSpecular; // percentage chance of doing specular instead of diffuse lighting\n    float roughness;       // how rough the specular reflections are\n    vec3 specularColor;    // the color tint of specular reflections\n};\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\n// Hit test functions\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n\n\n}\n \nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n    //get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n \n // SRGB-Linear Conversion Functions\n vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n// Tonemapping\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n \n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n    // back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.8f, 0.5f, 0.2f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.2f;\n            hitInfo.material.roughness = 0.8f;\n            hitInfo.material.specularColor = vec3(1.0f, 0.6f, 0.0f);\n        }\n\t}\n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.3f, 0.6f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.5f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 0.6f, 0.8f);            \n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.1f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.6f;\n            hitInfo.material.roughness = 0.4f;\n            hitInfo.material.specularColor = vec3(0.7f, 0.0f, 0.0f);\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.1f, 0.7f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.4f;\n            hitInfo.material.roughness = 0.2f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.7f, 0.0f);            \n        }        \n    }\n    \n    //// left box_1 - left face \n    //{\n    //    vec3 A = vec3( -4.5f, -2.0f, 10.0f) + sceneTranslation;\n    //    vec3 B = vec3( -4.5f, -2.0f, 5.0f) + sceneTranslation;\n    //    vec3 C = vec3( -4.5f,  2.0f, 5.0f) + sceneTranslation;\n    //    vec3 D = vec3( -4.5f,  2.0f, 10.0f) + sceneTranslation;\n    //    if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n    //    {\n    //        hitInfo.material.albedo = vec3(0.8f, 0.8f, 0.8f);\n    //        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    //        hitInfo.material.percentSpecular = 0.0f;\n    //        hitInfo.material.roughness = 0.0f;\n    //        hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n    //    }        \n    //}\n    //\n    //// left box_1 - right face \n    //{\n    //    vec3 A = vec3( -1.5f, -2.0f, 10.0f) + sceneTranslation;\n    //    vec3 B = vec3( -1.5f, -2.0f, 5.0f) + sceneTranslation;\n    //    vec3 C = vec3( -1.5f,  2.0f, 5.0f) + sceneTranslation;\n    //    vec3 D = vec3( -1.5f,  2.0f, 10.0f) + sceneTranslation;\n    //    if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n    //    {\n    //        hitInfo.material.albedo = vec3(0.9f, 0.5f, 0.9f);\n    //        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    //        hitInfo.material.percentSpecular = 0.0f;\n    //        hitInfo.material.roughness = 0.01;\n    //        hitInfo.material.specularColor = vec3(0.9f, 0.5f, 0.9f);            \n    //    }        \n    //}\n    //\n    //// left box_1 - cieling\n    //{\n    //    vec3 A = vec3(-4.5f, 2.0f, 10.0f) + sceneTranslation;\n    //    vec3 B = vec3(-1.5f, 2.0f, 10.0f) + sceneTranslation;\n    //    vec3 C = vec3(-1.5f, 2.0f, 5.0f) + sceneTranslation;\n    //    vec3 D = vec3(-4.5f, 2.0f, 5.0f) + sceneTranslation;\n    //    if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n    //    {\n    //        hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n    //        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    //        hitInfo.material.percentSpecular = 0.0f;\n    //        hitInfo.material.roughness = 0.0f;\n    //        hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n    //    }        \n    //}\n    //\n    //// left box_1 - flooar\n    //{\n    //    vec3 A = (vec3(-4.5f, -2.0f, 10.0f) + sceneTranslation) * rotateY(sin(90.0f));\n    //    vec3 B = (vec3(-1.5f, -2.0f, 10.0f) + sceneTranslation) * rotateY(sin(90.0f));\n    //    vec3 C = (vec3(-1.5f, -2.0f, 5.0f) + sceneTranslation) *  rotateY(sin(90.0f));\n    //    vec3 D = (vec3(-4.5f, -2.0f, 5.0f) + sceneTranslation) *  rotateY(sin(90.0f));\n    //    if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n    //    {\n    //        hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n    //        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    //        hitInfo.material.percentSpecular = 0.0f;\n    //        hitInfo.material.roughness = 0.0f;\n    //        hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n    //    }        \n    //}\n    //\n    //// left box_1 - back wall\n    //{\n    //    vec3 A = (vec3(-4.5f, -2.0f, 5.0f) + sceneTranslation) * rotateZ(0.0f);\n    //    vec3 B = (vec3(-1.5f, -2.0f, 5.0f) + sceneTranslation) * rotateZ(0.0f);\n    //    vec3 C = (vec3(-1.5f,  2.0f, 5.0f) + sceneTranslation) * rotateZ(0.0f);\n    //    vec3 D = (vec3(-4.5f,  2.0f, 5.0f) + sceneTranslation) * rotateZ(0.0f);\n    //    if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n    //    {\n    //        hitInfo.material.albedo = vec3(0.8f, 0.2f, 0.2f);\n    //        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    //        hitInfo.material.percentSpecular = 0.2f;\n    //        hitInfo.material.roughness = 0.8f;\n    //        hitInfo.material.specularColor = vec3(1.0f, 0.2f, 0.0f);\n    //    }\n\t//}\n    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }\n    \n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-6.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.6f, 0.1f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n        hitInfo.material.percentSpecular = 0.6f;\n        hitInfo.material.roughness = 0.6f;\n        hitInfo.material.specularColor = vec3(0.9f, 0.6f, 0.1f);        \n    } \n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(6.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.5f, 0.9f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);   \n        hitInfo.material.percentSpecular = 0.6f;\n        hitInfo.material.roughness = 0.2;\n        hitInfo.material.specularColor = vec3(0.2f, 0.2f, 0.2f);        \n    }  \n    \n    // blue balls\n    for (int i = 0; i < 5; i++){\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f + float(i) * 5.0f, 10.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 2.0f * float(i + 1) / 10.0f;\n            hitInfo.material.specularColor = vec3(0.4f, 0.6f, 0.9f);       \n        }  \n    }\n    \n    // Pink balls\n    for (int i = 0; i < 5; i++){\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f + float(i) * 5.0f, 4.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 2.0f * float(i + 1) / 10.0f;\n            hitInfo.material.specularColor = vec3(0.9f, 0.5f, 0.9f);       \n        }  \n    }\n    \n    // gold balls\n    for (int i = 0; i < 5; i++){\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f + float(i) * 5.0f, -2.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 2.0f * float(i + 1) / 10.0f;\n            hitInfo.material.specularColor = vec3(0.9f, 0.6f, 0.1f);       \n        }  \n    }\n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    // initialize\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n     \n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        // shoot a ray out into the world\n        SRayHitInfo hitInfo;\n        hitInfo.dist = c_superFar;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n         \n        // if the ray missed, we are done\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += SRGBToLinear(texture(iChannel1, rayDir).rgb) * throughput;\n            break;\n        }\n         \n        // update the ray position\n        rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n         \n        // calculate whether we are going to do a diffuse or specular reflection ray \n        float doSpecular = (RandomFloat01(rngState) < hitInfo.material.percentSpecular) ? 1.0f : 0.0f;\n\n        // Calculate a new ray direction.\n        // Diffuse uses a normal oriented cosine weighted hemisphere sample.\n        // Perfectly smooth specular uses the reflection ray.\n        // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n        // Squaring the roughness is just a convention to make roughness feel more linear perceptually.\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.roughness * hitInfo.material.roughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n\n        // add in emissive lighting\n        ret += hitInfo.material.emissive * throughput;\n\n        // update the colorMultiplier\n        throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);   \n        \n        // Russian Roulette\n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        {\n        \tfloat p = max(throughput.r, max(throughput.g, throughput.b));\n        \tif (RandomFloat01(rngState) > p)\n            \tbreak;\n\n        \t// Add the energy we 'lose' by randomly terminating paths\n        \tthroughput *= 1.0f / p;            \n        }\n    }\n  \n    // return pixel color\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n\n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);//sin(iTime));\n     \n    // calculate the camera distance\n    float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);        \n     \n    // Anti - Aliasing\n    // calculate subpixel camera jitter for anti aliasing\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n     \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3(((fragCoord+jitter)/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n    // correct for aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n     \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n \n    // raytrace for this pixel\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    for (int index = 0; index < c_numRendersPerFrame; ++index)\n    \tcolor += GetColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    \n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    // show the result\n    fragColor = vec4(color, blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}