{"ver":"0.1","info":{"id":"ttscRX","date":"1592682371","viewed":266,"name":"Volume interpolation","username":"munrocket","description":"Different interpolations with Marschner-Lobb test function","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["volume","voxel","trilinear","tricubic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License. Â© 2020 munrocket\n\n#define MAX_DIST 4.\n#define MAX_STEPS 100\n#define DIFF_EPS 1e-2\n#define SHAD_EPS 3e-2\n\nconst float e = 1. / 16.;\nconst float e2 = e * 2.;\n\nfloat marschnerLobb(vec3 p) {\n\treturn p.y - (1. + cos(14. * (p.x*p.x + p.z*p.z))) / 10.;\n}\n\n/// begin interpolation ///\n\nfloat i0(vec3 p) {\n    p = floor(p / e + .5) * e;\n    return marschnerLobb(p);\n}\n\nfloat i1(vec3 p) {\n    vec3 d = fract(p / e + .5);\n    float f00 = mix(i0(p),                 i0(p + vec3(e, 0, 0)), d.x);\n    float f01 = mix(i0(p + vec3(0, 0, e)), i0(p + vec3(e, 0, e)), d.x);\n    float f10 = mix(i0(p + vec3(0, e, 0)), i0(p + vec3(e, e, 0)), d.x);\n    float f11 = mix(i0(p + vec3(0, e, e)), i0(p + vec3(e, e, e)), d.x);\n    float f0 = mix(f00, f10, d.y);\n    float f1 = mix(f01, f11, d.y);\n    return mix(f0, f1, d.z);\n}\n\nfloat CR(float f0, float f1, float f2, float f3, float x) {\n    float c2 = -.5*f0 + 0.5*f2;\n\tfloat c3 = f0 - 2.5*f1 + 2.0*f2 - .5*f3;\n\tfloat c4 = -.5 * f0\t+ 1.5*f1 - 1.5*f2 + 0.5*f3;\n\treturn ((c4 * x + c3) * x + c2) * x + f1;\n}\n\nfloat i2(vec3 p) {\n    vec3 d = fract(p / e + .5);\n    float f00 = CR(i0(p + vec3(-e,-e,-e)), i0(p + vec3(0,-e,-e)), i0(p + vec3(e,-e,-e)), i0(p + vec3(e2,-e,-e)), d.x);    \n    float f01 = CR(i0(p + vec3(-e,-e, 0)), i0(p + vec3(0,-e, 0)), i0(p + vec3(e,-e, 0)), i0(p + vec3(e2,-e, 0)), d.x);\n    float f02 = CR(i0(p + vec3(-e,-e, e)), i0(p + vec3(0,-e, e)), i0(p + vec3(e,-e, e)), i0(p + vec3(e2,-e, e)), d.x);\n    float f03 = CR(i0(p + vec3(-e,-e,e2)), i0(p + vec3(0,-e,e2)), i0(p + vec3(e,-e,e2)), i0(p + vec3(e2,-e,e2)), d.x);\n    \n    float f10 = CR(i0(p + vec3(-e, 0,-e)), i0(p + vec3(0, 0,-e)), i0(p + vec3(e, 0,-e)), i0(p + vec3(e2, 0,-e)), d.x);    \n    float f11 = CR(i0(p + vec3(-e, 0, 0)), i0(p                ), i0(p + vec3(e, 0, 0)), i0(p + vec3(e2, 0, 0)), d.x);\n    float f12 = CR(i0(p + vec3(-e, 0, e)), i0(p + vec3(0, 0, e)), i0(p + vec3(e, 0, e)), i0(p + vec3(e2, 0, e)), d.x);\n    float f13 = CR(i0(p + vec3(-e, 0,e2)), i0(p + vec3(0, 0,e2)), i0(p + vec3(e, 0,e2)), i0(p + vec3(e2, 0,e2)), d.x);\n    \n    float f20 = CR(i0(p + vec3(-e, e,-e)), i0(p + vec3(0, e,-e)), i0(p + vec3(e, e,-e)), i0(p + vec3(e2, e,-e)), d.x);\n    float f21 = CR(i0(p + vec3(-e, e, 0)), i0(p + vec3(0, e, 0)), i0(p + vec3(e, e, 0)), i0(p + vec3(e2, e, 0)), d.x);\n    float f22 = CR(i0(p + vec3(-e, e, e)), i0(p + vec3(0, e, e)), i0(p + vec3(e, e, e)), i0(p + vec3(e2, e, e)), d.x);\n    float f23 = CR(i0(p + vec3(-e, e,e2)), i0(p + vec3(0, e,e2)), i0(p + vec3(e, e,e2)), i0(p + vec3(e2, e,e2)), d.x);\n    \n    float f30 = CR(i0(p + vec3(-e,e2,-e)), i0(p + vec3(0,e2,-e)), i0(p + vec3(e,e2,-e)), i0(p + vec3(e2,e2,-e)), d.x);\n    float f31 = CR(i0(p + vec3(-e,e2, 0)), i0(p + vec3(0,e2, 0)), i0(p + vec3(e,e2, 0)), i0(p + vec3(e2,e2, 0)), d.x);\n    float f32 = CR(i0(p + vec3(-e,e2, e)), i0(p + vec3(0,e2, e)), i0(p + vec3(e,e2, e)), i0(p + vec3(e2,e2, e)), d.x);\n    float f33 = CR(i0(p + vec3(-e,e2,e2)), i0(p + vec3(0,e2,e2)), i0(p + vec3(e,e2,e2)), i0(p + vec3(e2,e2,e2)), d.x);\n    \n    float f0 = CR(f00, f01, f02, f03, d.z);\n    float f1 = CR(f10, f11, f12, f13, d.z);\n    float f2 = CR(f20, f21, f22, f23, d.z);\n    float f3 = CR(f30, f31, f32, f33, d.z);\n    \n    return CR(f0, f1, f2, f3, d.y);\n}\n\n/// end interpolation ///\n\nfloat map(vec3 p) {\n    vec3 q = abs(p) - 1.;\n  \tfloat cube = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    float t = fract(iTime / 6.);\n    if ( t < .3333) {\n    \treturn max(i0(p)*.1, cube);\n    } else if ( t < .6666 ) {\n        return max(i1(p)*.1, cube);\n    } else {\n        return max(i2(p)*.1, cube);\n    }\n}\n\nvec3 normal(vec3 pos, vec3 fix) {\n    const vec2 e = vec2(DIFF_EPS, 0.);\n    vec3 N = vec3(\tmap(pos + e.xyy) - map(pos - e.xyy),\n        \t\t\tmap(pos + e.yxy) - map(pos - e.yxy),\n        \t\t\tmap(pos + e.yyx) - map(pos - e.yyx));\n   \treturn normalize(N + fix);\n}\n\nfloat castRay(vec3 camera, vec3 dir) {\n    float t = 0.;\n    vec3 pos;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tpos = camera + t * dir;\n        float dt = map(pos) * (1. + 2.*step(80., float(i)));\n        t += dt;\n        if(abs(dt) < DIFF_EPS*.3 || t > MAX_DIST) break;\n    }\n    return mix(t, -1., step(MAX_DIST, t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-iResolution.xy*0.5)/min(iResolution.x,iResolution.y);\n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., 0., 2.5);\n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.05);\n    dir = rotate(dir, mouse);\n    camera = rotate(camera, mouse);\n    \n    float t = castRay(camera, dir);\n    vec3 pos = camera + t * dir;\n        \n    vec3 N = normal(pos, normalize(camera)*1e-5);\n    \n    vec3 sun_dir = normalize(vec3(-1.5, 1.5, .5));\n    float sun_dif = clamp( dot(N, sun_dir), 0., 1. );\n    float sun_sha = step(castRay(pos + N * SHAD_EPS, sun_dir), 0.);\n    float sky_dif = clamp(.5 + .5 * dot(N, vec3(0.,1.,0.)), 0., 1.);\n\n    vec3 col = sun_dif * sun_sha * vec3(1., .6, .4);\n    col += sky_dif * vec3(0., .2, .4);\n    col = mix(vec3(.6, .7, .8), col, step(0., t)) + vec3(-1. + 2.*step(0., t), 0., 0.);\n        \n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5, 0.2);\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}","name":"Common","description":"","type":"common"}]}