{"ver":"0.1","info":{"id":"slG3RD","date":"1637329139","viewed":103,"name":"Bezier_curves_sidps","username":"kingcrimson1112","description":"A bezier curve shader for quadratic and cubic curves.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simulation","bezier","curves","interpolation","beziercurves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------------------------------------\n// CONSTANTS\n//----------------------------------------------------\nfloat scale = 1.0f;\nvec3 bgCol = vec3(0.05f, 0.05f, 0.1f);\nvec3 pointCol = vec3(1.0f);\nfloat pointR=0.025f;\nvec3 lineCol = vec3(0.9f,0.0f,0.0f);\nfloat lineMargin=0.0001f;\nvec3 cursorCol = vec3(0.1f,0.9f,0.1f);\nfloat cursorR=0.05f;\nvec3 curveCol = vec3(0.1f,0.8f,0.9f);\nfloat curveUnit=0.001f;\nfloat curveMargin=0.01f;\n//----------------------------------------------------\n\n//----------------------------------------------------\n// BEZIER SETTINGS\n//----------------------------------------------------\n#define USE_CUBIC 1\n\n#if USE_CUBIC\n\n#define POINTS 4\nvec2[POINTS] points= vec2[POINTS](\nvec2(-1.2f,0.3f),\nvec2(1.5f,-0.8f),\nvec2(0.5f,0.9f),\nvec2(-1.2f,-0.3f)\n);\n\n#else\n\n#define POINTS 3\nvec2[POINTS] points= vec2[POINTS](\nvec2(-1.0f,0.0f),\nvec2(1.2f,0.85f),\nvec2(0.5f,0.0f)\n);\n\n#endif\n\nvec2 get_point(float t)\n{\n    int maxSize=POINTS;\n    vec2[POINTS] p1=points;\n    vec2[POINTS] p2=points;\n    while(maxSize>=1)\n    {\n        for(int i=0;i<maxSize-1;i++)\n        {\n            p2[i]=mix(p1[i],p1[i+1],t);\n        }\n        maxSize--;\n        p1=p2;\n    }\n    return p1[0];\n}\n//----------------------------------------------------\n// checks if C lies in between A and B\nbool in_range(vec2 a, vec2 b, vec2 c, float margin)\n{\n    float d1=distance(a,b);\n    float d2= distance(c,a)+distance(c,b);\n    return (abs(d1-d2)<=margin);\n}\n\n// checks if pixel lies inside anchor points\nbool check_point(vec2 p)\n{\n    for(int i=0;i<POINTS;i++)\n    {\n        if(distance(points[i],p)<pointR)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n// checks if pixel lies inside anchor lines\nbool check_line(vec2 p)\n{\n    for(int i=0;i<POINTS;i++)\n    {\n        for(int j=0;j<POINTS;j++)\n        {\n            if(i!=j && abs(j-i)==1)\n            {\n               if(in_range(points[i],points[j],p,lineMargin))\n               {\n                   return true;\n               }\n            }\n        }\n    }\n    return false;\n}\n\n// gets current phase (t)\nfloat get_phase()\n{\n    return  sin(iTime)*sin(iTime);\n}\n\n// checks if pixel lies on current cursor\nbool check_cursor(vec2 p, vec2 p1)\n{\n    return (distance(p,p1)<cursorR);\n}\n\n// checks if pixel lies on curve\nbool check_curve(vec2 p, float phase, float unit)\n{\n    float t=0.0f;\n    while(t<phase)\n    {\n        float t2=min(t+unit,phase);\n        \n        vec2 p1=get_point(t);\n        vec2 p2=get_point(t2);\n        \n        if(in_range(p1,p2,p,curveMargin))\n        {\n            return true;\n        }\n        \n        t=t2;\n    }\n    return false;\n}\n\n// Returns centered UV points\nvec2 get_uv(vec2 fc)\n{\n    vec2 uv=fc/iResolution.xy;\n    uv=uv*2.0f-1.0f;\n    uv.x*=(iResolution.x/iResolution.y);\n    uv*=scale;\n    return uv;\n}\n\n// Gets final color\nvec3 get_color(vec2 p)\n{\n    vec3 col = bgCol;\n    float phase =get_phase();\n    vec2 p1 = get_point(phase);\n    if(check_cursor(p,p1))\n    {\n       col = cursorCol;\n    }\n    else if(check_curve(p, phase,curveUnit))\n    {\n        col = curveCol;\n    }\n    else if(check_point(p))\n    {\n        col = pointCol;\n    }\n    else if(check_line(p))\n    {\n        col = lineCol;\n    }   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = get_uv(fragCoord);\n    vec3 col=get_color(uv);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}