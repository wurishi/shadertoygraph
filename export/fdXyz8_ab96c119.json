{"ver":"0.1","info":{"id":"fdXyz8","date":"1641651274","viewed":86,"name":"Noise Sampler 2","username":"Nickid2018","description":"Minecraft Terrain Builder noise, from \"net.minecraft.world.level.levelgen.synth.NormalNoise\"","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Random Data generated by MC 1.18.1 NormalNoise and Xoroshiro128++ RNG with seed 514\nint p1[256] = int[256](-60, 76, -37, 124, 34, -72, 66, 18, -40, -57, -26, -84, -54, 20, -124, -18, 89, -31, 116, 92, -29, -89, -50, 11, -76, 62, -70, 83, 93, -100, -10, -38, 68, -106, -9, -23, 46, 64, 95, 118, 58, 73, -69, 14, 3, -97, -62, -123, 104, 77, -102, 84, -4, -39, -48, 107, 85, 111, -27, 72, 119, 31, -115, 54, -55, -108, 90, -17, 40, 100, 86, 81, 108, -118, -73, 94, -110, -113, 48, -58, -125, 110, -107, -67, -35, 50, 1, 102, -16, -119, 79, 44, 27, -87, 0, -77, 13, 117, 122, 71, 74, 127, -36, -34, 26, -121, -53, 2, -65, -117, -83, -93, -109, -90, 120, -41, 56, -47, 125, -13, -78, 115, 126, 23, -104, -46, 57, -122, -14, 55, 25, -56, 33, 37, -61, -52, -1, 88, 39, 70, -114, -22, 109, 78, -30, -11, 15, -64, -101, -8, 53, 96, -79, -71, -81, 17, -43, -15, 60, -99, 16, 80, -66, 47, -116, 5, 49, 98, -111, -51, -32, -128, -85, 10, 42, 7, 114, 103, 121, 123, 28, -92, -68, 8, -127, 38, 75, -88, 22, -105, 106, 61, -20, 19, -98, -74, -96, 69, -95, -12, 12, -45, -24, -112, -94, -75, 45, -19, -82, -44, 101, -126, -42, 30, 41, 82, -120, -80, -63, 112, 32, -86, -103, 97, 6, 105, -21, 4, 9, 65, 21, 99, -6, 43, 51, -59, 29, -91, -25, 52, 87, 59, -28, 24, -2, -5, 36, -7, 113, -33, 67, 91, -3, 35, -49, 63);\nint p2[256] = int[256](-113, 67, -11, -127, 10, 41, 77, 83, -125, -46, 52, -88, 122, -99, 36, -67, 56, 96, 46, -10, -90, -102, -56, 74, 80, -82, 105, -121, 65, -84, -18, 57, -4, -112, -89, -58, 29, 98, -41, -30, 108, 32, -63, 0, -92, -119, 30, 8, -50, -118, -5, -13, -116, -16, -49, 90, -79, -105, -98, 19, -66, -77, 1, 81, -26, 51, 113, 119, -1, -78, -36, 43, 87, -86, -68, -44, 91, -60, -23, 55, 21, 116, 34, -33, 23, -24, 115, 72, 35, 54, 101, 71, 107, 97, -93, 15, 79, 62, -87, 48, -8, -37, 58, -81, 85, -40, 93, 7, -73, -12, -54, -128, 92, -95, 20, 123, 125, 78, -114, 37, -32, 117, 88, -39, 17, -38, -19, -100, 68, -34, -6, 61, -29, -53, -62, 103, 47, 110, 44, 18, 12, 76, -94, 40, -75, 89, 53, -71, -104, 69, -42, 13, 2, 124, -28, 31, -3, -101, -31, 63, -96, 59, -122, -14, -52, 111, 28, -22, 99, 73, 104, -111, -83, 127, 9, 64, 14, -126, -35, -55, -124, -72, 60, 94, 26, 16, 24, -91, -69, 4, -123, 5, -115, 120, 70, -57, 25, 38, 100, -21, -76, -106, -45, -107, 42, -80, 39, 112, -2, 121, -65, -7, -108, 33, 50, 84, -103, -47, -97, 102, 11, 95, -117, 49, 109, 3, 75, -64, 6, -15, 45, 82, -51, 114, -109, -110, -17, 66, -120, -48, 106, -70, -85, 27, 22, -9, -43, -20, 126, 86, -61, -25, 118, -27, -74, -59);\nint p3[256] = int[256](25, 27, 48, 97, 28, 42, -59, 23, -122, 51, -82, -108, -33, -125, -22, 98, 120, -99, 126, 56, 105, 114, 89, -55, -112, -64, 54, 36, -93, -18, -12, 50, -48, 100, 21, 18, -43, 122, -58, -13, -25, 81, 14, 85, 118, 35, -61, 29, 26, -44, 55, -87, -104, 57, -109, -40, 94, 72, 12, 106, 82, 39, -42, -110, 53, -88, 83, -94, 124, 37, -121, 84, 93, 108, 127, 76, 109, -19, 58, 88, 64, 31, 102, -113, -77, -103, 99, -7, -9, -91, -60, -115, -34, -1, 75, -76, -128, 20, -116, 110, -127, -35, 95, -41, 16, -49, 69, 123, 46, -69, 90, -50, -86, 45, -73, 66, -75, 9, -118, 4, -85, -62, -123, -45, -57, -101, 111, 70, 125, -105, 30, 73, -70, -4, 86, -68, -124, -8, 65, 79, 112, -10, -83, 68, 61, -24, 15, 38, -54, -79, -119, -71, 33, -29, 10, -52, 77, 52, 24, 7, 67, 74, 2, 60, -65, -84, 11, -117, -56, 19, -21, 3, -20, 0, -6, -80, 40, -74, -27, -11, -53, 121, 5, -72, -126, -111, -81, -51, 62, -3, -14, 71, -15, -100, 104, -63, -67, -37, -107, -38, -66, -95, 107, 115, 119, -28, 34, 78, 17, 41, 116, -36, 32, 8, -2, -114, -89, 13, -23, 1, -30, -17, 91, -5, -96, -90, -120, 59, -102, -39, -106, -32, 43, 47, -78, 6, 22, 96, -16, -26, -92, 113, 92, 101, 117, 103, -31, -47, 63, 44, -46, -98, 87, 49, 80, -97);\nint p4[256] = int[256](-86, -1, 109, -114, 32, -75, 24, 91, -29, -115, 113, 10, -64, -109, -20, -53, 29, 89, -45, 4, -94, 126, -44, -47, 111, 88, 122, -8, -74, -30, 92, -10, 62, -9, 72, 99, 61, -48, 95, 48, -90, -36, -85, 53, -33, -15, 11, 13, -78, -84, 101, 97, 94, 76, 63, 28, -104, -19, 66, 80, -80, 6, -106, -46, -124, -100, 50, -63, -126, -26, 49, 47, -62, 78, 14, 30, 69, 86, -122, -55, 108, -2, 1, 115, 45, 77, -52, -91, -50, 105, -38, -37, -120, -73, 68, -28, -99, -13, 31, -117, 25, -34, -14, 51, -23, -32, 104, 19, -116, 0, 44, 119, 46, 5, -121, 16, -17, -58, -6, 70, -67, -27, -69, 38, -12, 87, 82, 120, -16, 117, -22, 110, -82, 102, 17, 73, -127, 118, 23, -112, 42, -97, -101, -11, 33, -118, 27, -89, 56, -110, -76, 123, 15, -66, 114, -108, 37, -56, 58, -95, 18, 65, -61, -70, 36, 96, 52, -68, -3, 55, -54, -41, -60, 12, 41, 81, 22, 125, 39, -87, -7, -43, 60, 127, 9, 7, 3, 34, 20, -42, 2, 43, 79, 54, 83, -65, -128, 98, -88, -77, -21, -81, 100, -103, -71, 93, 64, 121, 116, -102, 21, -92, -59, 71, -119, -40, -24, 124, -72, 57, 40, 67, -111, -123, -113, -4, 84, -107, -105, 59, -83, -18, -49, -35, 26, 85, -57, 35, 112, -98, -51, 107, 75, 106, -125, -39, -5, -31, 90, -79, -96, 8, 74, -25, -93, 103);\nfloat xos[4] = float[4](37.24751861619632, 30.610946490823096, 71.57024283599105, 224.18342319268598);\nfloat yos[4] = float[4](254.72829787684196, 97.02986365083956, 61.59014930694542, 27.450296256769406);\nfloat zos[4] = float[4](216.18338551088627, 214.9602705600881, 18.793427323829462, 96.44898842887349);\n// Random Constant End --\n\n// Utility Functions\nint GRADIENT_1[16] = int[16](1, -1, 1, -1, 1, -1, 1, -1, 0, 0, 0, 0, 1, 0, -1, 0);\nint GRADIENT_2[16] = int[16](1, 1, -1, -1, 0, 0, 0, 0, 1, -1, 1, -1, 1, -1, 1, -1);\nint GRADIENT_3[16] = int[16](0, 0, 0, 0, 1, 1, -1, -1, 1, 1, -1, -1, 0, 1, 0, -1);\n\nint getGradient(int hash, int index) {\n    if (index == 0)\n        return p1[hash & 0xFF] & 0xFF;\n    if (index == 1)\n        return p2[hash & 0xFF] & 0xFF;\n    if (index == 2)\n        return p3[hash & 0xFF] & 0xFF;\n    else\n        return p4[hash & 0xFF] & 0xFF;\n}\n\nfloat lerp(float delta, float start, float end) {\n    return start + delta * (end - start);\n}\n\nfloat lerp2(float deltaX, float deltaY, float x0y0, float x1y0, float x0y1, float x1y1) {\n    return lerp(deltaY, lerp(deltaX, x0y0, x1y0), lerp(deltaX, x0y1, x1y1));\n}\n\nfloat lerp3(float deltaX, float deltaY, float deltaZ, float x0y0z0, float x1y0z0, float x0y1z0, float x1y1z0, float x0y0z1, float x1y0z1, float x0y1z1, float x1y1z1) {\n    return lerp(deltaZ, lerp2(deltaX, deltaY, x0y0z0, x1y0z0, x0y1z0, x1y1z0), lerp2(deltaX, deltaY, x0y0z1, x1y0z1, x0y1z1, x1y1z1));\n}\n\nfloat perlinFade(float value) {\n    return value * value * value * (value * (value * 6.0 - 15.0) + 10.0);\n}\n\nfloat dotImpl(int hash, float x, float y, float z) {\n    return float(GRADIENT_1[hash & 0xF]) * x + float(GRADIENT_2[hash & 0xF]) * y + float(GRADIENT_3[hash & 0xF]) * z;\n}\n\nfloat grad(int hash, float x, float y, float z) {\n    return dotImpl(hash, x, y, z);\n}\n// Utility Functions End\n\nfloat sampleAndLerp(int sectionX, int sectionY, int sectionZ,\n            float localX, float localY, float localZ, float fadeLocalX, int index) {\n    int i = getGradient(sectionX, index);\n    int j = getGradient(sectionX + 1, index);\n    int k = getGradient(i + sectionY, index);\n    int l = getGradient(i + sectionY + 1, index);\n    int m = getGradient(j + sectionY, index);\n    int n = getGradient(j + sectionY + 1, index);\n    float d = grad(getGradient(k + sectionZ, index), localX, localY, localZ);\n    float e = grad(getGradient(m + sectionZ, index), localX - 1.0, localY, localZ);\n    float f = grad(getGradient(l + sectionZ, index), localX, localY - 1.0, localZ);\n    float g = grad(getGradient(n + sectionZ, index), localX - 1.0, localY - 1.0, localZ);\n    float h = grad(getGradient(k + sectionZ + 1, index), localX, localY, localZ - 1.0);\n    float o = grad(getGradient(m + sectionZ + 1, index), localX - 1.0, localY, localZ - 1.0);\n    float p = grad(getGradient(l + sectionZ + 1, index), localX, localY - 1.0, localZ - 1.0);\n    float q = grad(getGradient(n + sectionZ + 1, index), localX - 1.0, localY - 1.0, localZ - 1.0);\n    float r = perlinFade(localX);\n    float s = perlinFade(fadeLocalX);\n    float t = perlinFade(localZ);\n    return lerp3(r, s, t, d, e, f, g, h, o, p, q);\n}\n    \nfloat noiseImpl(float x, float y, float z, float yScale, float yMax, int o) {\n    float n;\n    float d = x + xos[o];\n    float e = y + yos[o];\n    float f = z + zos[o];\n    int i = int(floor(d));\n    int j = int(floor(e));\n    int k = int(floor(f));\n    float g = d - float(i);\n    float h = e - float(j);\n    float l = f - float(k);\n//    if (yScale != 0.0) { ----------------------Unused\n//        float m = yMax >= 0.0 && yMax < h ? yMax : h;\n//        n = floor(m / yScale + 1.0E-7) * yScale;\n//    } else {\n        n = 0.0;\n//    }\n    return sampleAndLerp(i, j, k, g, h - n, l, h, o);\n}\n\nfloat noise(float x, float y, float z, int o) {\n    return noiseImpl(x, y, z, 0.0, 0.0, o);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mapping to (256, 256)\n    vec2 uv = (fragCoord/iResolution.xy) * 256.0;\n    uv.y = 256.0 - uv.y;\n    vec2 first1 = uv / 1024.0;\n    vec2 first2 = uv / 256.0;\n    vec2 second1 = first1 * 1.0181268882175227;\n    vec2 second2 = first2 * 1.0181268882175227;\n\n    float data = ((((16.0 / 21.0) * noise(first1.x, 0.0, first1.y, 0)+\n                  (8.0 / 63.0) * noise(first2.x, 0.0, first2.y, 1)+\n                  (16.0 / 21.0) * noise(second1.x, 0.0, second1.y, 2)+\n                  (8.0 / 63.0) * noise(second2.x, 0.0, second2.y, 3)\n                 )) / 4.0 * 5.0) // Truth Noise\n                 * 2.0 - 0.8;\n    \n    // Output to screen\n    fragColor = vec4(data, data, data, 1.0);\n}","name":"Image","description":"","type":"image"}]}