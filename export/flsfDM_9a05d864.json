{"ver":"0.1","info":{"id":"flsfDM","date":"1650980306","viewed":62,"name":"Generations 5-nT CA","username":"Envy24","description":"5-neighbor generations totalistic cellular automat (Von Neumann neighbourhood).\n\nMouse.x changes palette.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","wolfram","4neighbor"],"hasliked":0,"parentid":"NtsfWM","parentname":"Generations 9-nT CA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void generate_palette(\n    inout vec3[num_of_states] palette)\n{\n    int offset = int(MX);\n    for (int c = 0; c < num_of_states; ++c)\n    {\n        palette[c].x = float(sample1DHashUI32(uint(offset + c)));\n        palette[c].y = float(sample1DHashUI32(uint(offset + c + num_of_states)));\n        palette[c].z = float(sample1DHashUI32(uint(offset + c + 2 * num_of_states)));\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 SC ) \n{ \n    vec3 palette[num_of_states];\n\n    generate_palette(palette);\n\n    O = vec4(palette[int(TEXF0(SC).r)], 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ALIVE true\n#define DEAD  false\n#define READ_CELL(P) int(TEX0(TEX_COORDS(P)).r)\n\nint read_neighbors_states(vec2 SC, int next_state) \n{\n    /* Kernel:\n                tl t tr\n                 l m r\n                bl b br\n    */\n\n    int t  = READ_CELL(SC + vec2( 0,  1));\n    int r  = READ_CELL(SC + vec2( 1,  0));\n    int b  = READ_CELL(SC + vec2( 0, -1));\n    int l  = READ_CELL(SC + vec2(-1,  0));\n    int m  = READ_CELL(SC);\n\n    return // max sum == 5\n         int(l == 0) +\n         int(b == 0) +\n         int(r == 0) +\n         int(t == 0) +\n         int(m == 0);\n}\n\nfloat check_rule(\n    in int rule,\n    in vec2 SC)\n{\n    int current_state = READ_CELL(SC);\n    int next_state = (current_state + 1) & (num_of_states - 1);\n    int num_of_alive_neighbors = read_neighbors_states(SC, next_state);       \n             \n    int new_state = 0;\n\n    switch (current_state)\n    {\n    case 0: /* Cell is dead. New state is defined by rule. */\n        new_state = (rule >> num_of_alive_neighbors) & 1;\n        break;\n    case 1: /* Cell is alive (or newly born). Need to model aging process. */\n        // Cell should be ... ?\n        switch ((rule >> (num_of_alive_neighbors + 6)) & 1)\n        {\n        case 0: /* grow old. */\n            new_state = next_state;\n            break;\n        case 1: /* born. */\n        default:\n            new_state = 1;\n            break;\n        }\n        break;\n    default: /* Cell is alive, but should grow old. */\n        new_state = next_state;\n        break;\n    }\n    \n    return float(new_state);\n}\n\nfloat randomize_part_of_frame(\n    in vec2 SC,\n    in float amount)  // in range [0.0; 1.0]\n{\n    vec2 C = R.xy * 0.5;\n    vec2 Offset = C * amount;\n    \n    float s = mod(abs(fract(sin(dot(SC + vec2(iTime), vec2(127.1,311.7))) * 43758.5453123)), 1.0);\n    float hash = floor(s * float(num_of_states));  \n\n    return \n       (SC.x > (C.x - Offset.x) &&\n        SC.x < (C.x + Offset.x) &&\n        SC.y > (C.y - Offset.y) &&\n        SC.y < (C.y + Offset.y)) == true ?\n            float(hash) :\n            0.0;\n}\n\nfloat init_one_pixel_in_center(vec2 SC)\n{\n    SC = floor(SC);\n    vec2 M = vec2(floor(R.x * 0.5), floor(R.y * 0.5));\n    return \n        SC.y == M.y && SC.x == M.x ?\n            0.0 :\n            1.0;\n}\n\nfloat mainScene(in vec2 SC)\n{\n    float transition_number = 0.0;\n    \n    /* rules range = [0; 4095] or [0; 2^12 - 1]. */\n    //int rule = 2414;\n    //int rule = 2410;\n    int rule = 413;\n\n    return\n        iFrame == 0 ?\n            init_one_pixel_in_center(SC) :\n            //randomize_part_of_frame(SC, 0.4) :\n            check_rule(rule, SC);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = vec4(mainScene(SC));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R                        iResolution\n#define TEX0(TC)               ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)              ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define MX                     ( iMouse.x )                       // in range [0.0; iMouse.x]\n\nconst int num_of_states = 16; // Number of possible cell states.\n\n/* Every num_of_frame returns true \nand number of detected transitions. */\nbool transition(\n    in int frame,\n    in int numOfFrames,\n    inout float quotent)\n{\n    // Convert to float.\n    float f = float(frame);\n    float inv = 1.0 / float(numOfFrames);\n    \n    // Calculate previous and current quotents.\n    float qc = floor(f * inv);\n    quotent = floor((f - 1.0) * inv);\n    \n    return quotent < qc;\n}\n\n/*  \n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample1DHashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n    \n    return float(value * value * value) * 2.32830644e-10;\n}","name":"Common","description":"","type":"common"}]}