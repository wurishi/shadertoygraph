{"ver":"0.1","info":{"id":"NtlfRl","date":"1651320205","viewed":167,"name":"Direct ellipse distance","username":"gleboneloner","description":"Direct numerical approximation of the distance to an ellipse without square roots and transcendental functions.\nIt uses only addition, subtraction and multiplication.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","numerical","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ellipse ( vec2 ab, vec2 uv ) {\n\n    float a = ab.x*ab.x, b = ab.y*ab.y;\n    float u = uv.x*uv.x, v = uv.y*uv.y;\n\n    float U1 = b*b-2.0*a*b+a*a;\n    float U2 = -2.0*b*b*v+6.0*a*b*v-4.0*a*a*v-4.0*b*b*u+6.0*a*b*u-2.0*a*a*u-2.0*b*b*b+2.0*a*b*b+2.0*a*a*b-2.0*a*a*a;\n    float U3 = b*b*v*v-6.0*a*b*v*v+6.0*a*a*v*v+6.0*b*b*u*v-10.0*a*b*u*v+6.0*a*a*u*v-2.0*b*b*b*v+4.0*a*b*b*v-8.0*a*a*b*v+6.0*a*a*a*v+6.0*b*b*u*u-6.0*a*b*u*u+a*a*u*u+6.0*b*b*b*u-8.0*a*b*b*u+4.0*a*a*b*u-2.0*a*a*a*u+b*b*b*b+2.0*a*b*b*b-6.0*a*a*b*b+2.0*a*a*a*b+a*a*a*a;\n    float U4 = 2.0*a*b*v*v*v-4.0*a*a*v*v*v-2.0*b*b*u*v*v+2.0*a*b*u*v*v-6.0*a*a*u*v*v-6.0*a*b*b*v*v+10.0*a*a*b*v*v-6.0*a*a*a*v*v-6.0*b*b*u*u*v+2.0*a*b*u*u*v-2.0*a*a*u*u*v+4.0*b*b*b*u*v-6.0*a*b*b*u*v-6.0*a*a*b*u*v+4.0*a*a*a*u*v+6.0*a*b*b*b*v-8.0*a*a*b*b*v+4.0*a*a*a*b*v-2.0*a*a*a*a*v-4.0*b*b*u*u*u+2.0*a*b*u*u*u-6.0*b*b*b*u*u+10.0*a*b*b*u*u-6.0*a*a*b*u*u-2.0*b*b*b*b*u+4.0*a*b*b*b*u-8.0*a*a*b*b*u+6.0*a*a*a*b*u-2.0*a*b*b*b*b+2.0*a*a*b*b*b+2.0*a*a*a*b*b-2.0*a*a*a*a*b;\n    float U5 = a*a*v*v*v*v+2.0*a*b*u*v*v*v+2.0*a*a*u*v*v*v-4.0*a*a*b*v*v*v+2.0*a*a*a*v*v*v+b*b*u*u*v*v+4.0*a*b*u*u*v*v+a*a*u*u*v*v-6.0*a*b*b*u*v*v+2.0*a*a*b*u*v*v-2.0*a*a*a*u*v*v+6.0*a*a*b*b*v*v-6.0*a*a*a*b*v*v+a*a*a*a*v*v+2.0*b*b*u*u*u*v+2.0*a*b*u*u*u*v-2.0*b*b*b*u*u*v+2.0*a*b*b*u*u*v-6.0*a*a*b*u*u*v+6.0*a*b*b*b*u*v-10.0*a*a*b*b*u*v+6.0*a*a*a*b*u*v-4.0*a*a*b*b*b*v+6.0*a*a*a*b*b*v-2.0*a*a*a*a*b*v+b*b*u*u*u*u+2.0*b*b*b*u*u*u-4.0*a*b*b*u*u*u+b*b*b*b*u*u-6.0*a*b*b*b*u*u+6.0*a*a*b*b*u*u-2.0*a*b*b*b*b*u+6.0*a*a*b*b*b*u-4.0*a*a*a*b*b*u+a*a*b*b*b*b-2.0*a*a*a*b*b*b+a*a*a*a*b*b;\n\n    float s1 = 0.0, s2 = 100.0;\n\n    float H1 = s1*s1*(s1*s1*(s1*s1*(U1*s1*s1+U2)+U3)+U4)+U5;\n    float H2 = s2*s2*(s2*s2*(s2*s2*(U1*s2*s2+U2)+U3)+U4)+U5;\n\n    for ( int i = 0; i < 10; i += 1 ) {\n\n        float s3 = (s1+s2)/2.0, H3 = s3*s3*(s3*s3*(s3*s3*(U1*s3*s3+U2)+U3)+U4)+U5;\n\n        sign(H1)*sign(H3) <= 0.0 ? ( s2 = s3, H2 = H3 ) : ( s1 = s3, H1 = H3 );\n\n    }\n    \n    return (s1+s2)/2.0;\n\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 ab = iMouse.xy-iResolution.xy/2.0;\n\n    if ( iMouse.z == 0.0 ) ab = vec2( 140, 80 );\n\n    vec2 uv = fragCoord-iResolution.xy/2.0;\n\n \tfloat d = ellipse( ab, uv );\n    \n    vec3 col = vec3(0.9,0.6,0.3);\n    \n\tcol *= (1.0-1.0/exp(d/40.0));\n    \n    col *= (0.8+0.2*cos(d));\n    \n\tcol = mix( col, vec3(1.0), smoothstep( 2.0, 0.0, d ) );\n\n\tfragColor = vec4( col, 1.0 );\n\n}","name":"Image","description":"","type":"image"}]}