{"ver":"0.1","info":{"id":"dtsyRs","date":"1691071171","viewed":85,"name":"First proper raymarcher","username":"dokso","description":"I'm finally starting to get a grasp on things, yay.\nFps might be bad, not 100% sure why.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","phong","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n#define MAX_DIST 10.0\n#define MIN_DIST 0.1\n#define MAX_RAYS 512\n#define PI 3.1415926535897932384626433832795028841971693993751\n\n// constructing a quaternion to rotate along an axis\nvec4 newQ(const vec3 axis, float angle) {\n\tangle = angle * 0.5; // account for first and second rotation combined\n\treturn vec4(axis * sin(angle), cos(angle));\n}\n// rotate vector along quaternion\nvec3 rotateVQ(const vec3 v, const vec4 q) {\n\t// optimized in a way that it only works correctly with unit vectors\n\treturn vec3(\n\t\tv.x + 2.0 * (q.x * (q.y*v.y + q.z*v.z) + q.y * (q.w*v.z - q.y*v.x) - q.z * (q.w*v.y + q.z*v.x)),\n\t\tv.y + 2.0 * (q.y * (q.x*v.x + q.z*v.z) + q.z * (q.w*v.x - q.z*v.y) - q.x * (q.w*v.z + q.x*v.y)),\n\t\tv.z + 2.0 * (q.x * (q.w*v.y - q.x*v.z) - q.y * (q.w*v.x + q.y*v.z) + q.z * (q.x*v.x + q.y*v.y))\n\t);\n}\n// if you are unsure how this works, i highly suggest-\n// 3blue1brown's videos on quaternions, and his essence of linear algebra series\n// they proved very useful as they taught me what i needed to derive this function\n\nmat2 rotate(const float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(\n\t\tc, -s,\n\t\ts,  c\n\t);\n}\n\n// noise thingamajig\nfloat N21(const vec2 v) {\n\tfloat noise = dot(v, vec2(123.4, 234.5));\n\tnoise = fract(sin(noise) * 45432.212);\n\treturn noise;\n}\n\nfloat noise(vec2 v, const float scale, const float rot) {\n\tv = v * scale * rotate(rot);\n\tvec2 frac = smoothstep(0.0, 1.0, fract(v));\n\tvec2 id = floor(v);\n\n\tfloat bl = N21(id);\n\tfloat br = N21(id + vec2(1.0, 0.0));\n\tfloat tl = N21(id + vec2(0.0, 1.0));\n\tfloat tr = N21(id + vec2(1.0, 1.0));\n\n\tfloat b = mix(bl, br, frac.x);\n\tfloat t = mix(tl, tr, frac.x);\n\tfloat bt = mix(b, t, frac.y);\n\n\treturn bt;\n}\n\nfloat fbnoise(const vec2 v) {\n\tfloat n = noise(v, 4.0, 0.0);\n\tn += noise(v, 8.0, 0.2) * 0.5;\n\tn += noise(v, 16.0, 0.4) * 0.25;\n\tn += noise(v, 32.0, 0.6) * 0.125;\n\tn += noise(v, 64.0, 0.8) * 0.0625;\n\tn += noise(v, 128.0, 0.8) * 0.03125;\n\tn /= 1.96875;\n\n\treturn n;\n}\n\n// material things\nstruct Surface {\n\tfloat dist;\n\tfloat specular;\n\tfloat roughness;\n\tvec3 color;\n};\n\nSurface minSurface(const Surface a, const Surface b) {\n\tif (b.dist < a.dist) return b; // i wish i could do this without branching\n\treturn a;\n}\n\n// here comes sdf magic\nfloat box(const vec3 samplePos, const vec3 size) {\n\tvec3 relative = abs(samplePos) - size * 0.5;\n\n\tfloat inside = min(max(max(relative.x, relative.y), relative.z), 0.0);\n\tfloat outside = length(max(relative, 0.0));\n\n\treturn inside + outside;\n}\n\nSurface map(const vec3 samplePos) {\n\tSurface[] objects = Surface[] (\n\t\tSurface(\n\t\t\tsamplePos.y + 0.2 + fbnoise(samplePos.xz) * 0.05, // dist\n\t\t\t1.0 - (sign(sin(samplePos.x * 4.0) * sin(samplePos.z * 4.0)) * 0.5 + 0.5), // specular\n\t\t\t0.0, // roughness\n\t\t\tvec3(sign(sin(samplePos.x * 4.0) * sin(samplePos.z * 4.0)) * 0.5 + 0.5) // color\n\t\t),\n\t\tSurface(\n\t\t\tlength(samplePos) - 0.2, // dist\n\t\t\t0.5, // specular\n\t\t\t0.5, // roughness\n\t\t\tvec3(1.0) // color\n\t\t),\n\t\tSurface(\n\t\t\tbox(rotateVQ(samplePos - vec3(0.0, 0.5, 0.0), newQ(normalize(vec3(1.0, cos(iTime), sin(iTime))), iTime)), vec3(0.2)) - sin(iTime) * 0.025 - 0.025, // dist\n\t\t\t1.0, // specular    // i apologize to anyone trying to read this ^\n\t\t\t0.0, // roughness\n\t\t\tvec3(1.0, 0.0, 0.0) // color\n\t\t)\n\t);\n\n\tSurface closest;\n\tclosest.dist = MAX_DIST;\n\tfor (int i = 0; i < objects.length(); i++) {\n\t\tclosest = minSurface(closest, objects[i]);\n\t}\n\n\treturn closest;\n}\n\nvec3 estNormal(const vec3 samplePos) {\n\tvec2 e = vec2(EPSILON, 0.0);\n\tfloat d = map(samplePos).dist;\n\n\treturn normalize(vec3(\n\t\td - map(samplePos - e.xyy).dist,\n\t\td - map(samplePos - e.yxy).dist,\n\t\td - map(samplePos - e.yyx).dist\n\t));\n}\n\nSurface march(const vec3 ro, const vec3 rd) {\n\tfloat t = MIN_DIST;\n\n\tfor (int i = 0; i<MAX_RAYS && t<MAX_DIST; i++) {\n\t\tSurface closest = map(ro+rd*t);\n\t\tfloat dist = closest.dist;\n\t\tt += dist;\n\n\t\tif (dist < EPSILON * t) {\n\t\t\treturn Surface(t, closest.specular, closest.roughness, closest.color);\n\t\t}\n\t}\n\n\treturn Surface(MAX_DIST, 0.0, 0.0, vec3(0.0));\n}\n\nvec3 material = vec3(0.18);\nvec3 sunColor = vec3(6.0, 5.0, 4.0);\nvec3 sunDir = normalize(vec3(0.0, 1.0, 2.0));\nvec3 skyColor = vec3(0.5, 0.8, 1.2);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec2 mouseP = (2.0 * iMouse.xy - iResolution.xy) / iResolution.xy;\n\n\tfloat pitch = mouseP.x * PI + PI;\n\tfloat height = mouseP.y * 0.5 + 0.5;\n\n\tvec3 camPos = vec3(sin(pitch), height, cos(pitch));\n\tvec3 lookAt = vec3(0, height, 0);\n\t\n\t// cross products are awesome\n\tvec3 forward = normalize(lookAt - camPos);\n\tvec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n\tvec3 up = cross(forward, right);\n\n\tvec3 rayDir = normalize(forward + right * uv.x + up * uv.y);\n\n\tSurface surface = march(camPos, rayDir);\n\tfloat dist = surface.dist;\n\n\tvec3 col = mix(vec3(0.0, 0.5, 1.0) * pow(2.0, 1.0 - rayDir.y), vec3(1.0), exp(max(rayDir.y, 0.0) * -10.0));\n\tif (dist < MAX_DIST) {\n\t\tvec3 hit = camPos + rayDir * dist;\n\t\tvec3 normal = estNormal(hit);\n\n\t\tfloat sunShadow = step(MAX_DIST, march(hit + normal * EPSILON, sunDir).dist);\n\t\tfloat ambient = max(dot(normal, vec3(0.0, 1.0, 0.0)), 0.0);\n\t\tfloat diffuse = max(dot(normal, sunDir), 0.0) * sunShadow;\n\t\tfloat specular = pow(max(dot(rayDir, reflect(sunDir, normal)), 0.0), 1.0 + (1.0 - surface.roughness) * 63.0) * surface.specular * sunShadow;\n\t\t\n\t\tvec3 hitColor = vec3(0.0);\n\t\thitColor += material * surface.color * skyColor * ambient;\n\t\thitColor += material * surface.color * sunColor * diffuse;\n\t\thitColor += material * sunColor * specular;\n\n\t\t// fog\n\t\tcol = mix(hitColor, col, smoothstep(MAX_DIST * 0.4, MAX_DIST, dist));\n\t}\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}