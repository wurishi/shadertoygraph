{"ver":"0.1","info":{"id":"7dKcD1","date":"1654809560","viewed":90,"name":"Corn Grid","username":"alint","description":"Corn using an hexagonal grid noise.\nGithub link: https://github.com/tuxalin/procedural-tileable-shaders","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","grid","gradient","hex","corn","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint ihash1D(uint q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = q * 747796405u + 2891336453u;\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\nuvec4 ihash1D(uvec4 q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = q * 747796405u + 2891336453u;\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\nfloat hash1D(vec2 x)\n{\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 8192.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\nvec3 hash3D(vec2 x) \n{\n    // based on: pcg3 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec3 v = uvec3(x.xyx * 8192.0) * 1664525u + 1013904223u;\n    v += v.yzx * v.zxy;\n    v ^= v >> 16u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return vec3(v) * (1.0 / float(0xffffffffu));\n}\n\nvoid betterHash2D(vec4 coords0, vec4 coords1, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 hash0 = ihash1D(ihash1D(uvec4(coords0.xz, coords1.xz)) + uvec4(coords0.yw, coords1.yw));\n    uvec4 hash1 = hash0 * 1933247u + ~hash0 ^ 230123u;\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n} \nvoid betterHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 i = uvec4(cell);\n    uvec4 hash0 = ihash1D(ihash1D(i.xzxz) + i.yyww);\n    uvec4 hash1 = ihash1D(hash0 ^ 1933247u);\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n}\nvoid smultiHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    betterHash2D(cell, hashX, hashY);\n    hashX = hashX * 2.0 - 1.0; \n    hashY = hashY * 2.0 - 1.0;\n}\n\nvec2 noiseInterpolateDu(const in float x) \n{ \n    float x2 = x * x;\n    float u = x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n    float du = 30.0 * x2 * (x * (x - 2.0) + 1.0);\n    return vec2(u, du);\n}\nvec4 noiseInterpolateDu(const in vec2 x) \n{ \n    vec2 x2 = x * x;\n    vec2 u = x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n    vec2 du = 30.0 * x2 * (x * (x - 2.0) + 1.0);\n    return vec4(u, du);\n}\nvec4 noiseHexagonsd(vec2 pos, vec2 scale, vec2 scaleRatio, float size, vec2 disorder, bool isVertical, bool useCenter)\n{\n    const float kSqrtThree = 1.73205080757;\n    const float kHalfSqrtThree = 0.866025403785;\n    const float kInvSqrtThree = 0.57735026919;\n    \n    vec2 invScale = 1.0 / scale;\n    vec2 center;\n    {\n        vec4 hexScale = vec4(1.0, kSqrtThree, 1.0, kInvSqrtThree);\n        hexScale = isVertical ? hexScale : hexScale.yxwz;\n        vec4 r = vec4(1.0, kHalfSqrtThree, 0.5, kInvSqrtThree);\n        r = isVertical ? r : r.yxwz;\n    \n        vec2 p = pos * scale * hexScale.xy;\n        vec4 c = floor(p.xyxy * hexScale.zwzw + vec4(0.0, 0.0, -r.zw)) + 0.5;\n        vec4 uv = p.xyxy - c * hexScale.xyxy + vec4(0.0, 0.0, -0.5 * hexScale.xy);\n        // dot product\n        vec4 temp = uv * uv;\n        temp.xy = temp.xz + temp.yw;\n        center = temp.x < temp.y ? c.xy : c.zw + 0.5;\n        // normalize UV range and transform center position to UV space\n        center = center * invScale;\n    }\n    \n    // the horizontal/vertical and diagonal radii\n    vec4 radii = isVertical ? invScale.yyxy * vec4(0.0, 0.33333333, 0.5, 0.1666666666) : invScale.xxxy * vec4(0.33333333, 0.0, 0.1666666666, 0.5);\n    float radius = isVertical ? min(radii.y, radii.z) : min(radii.x, radii.w);\n\n    disorder *= 0.5 * radius;\n    vec4 p0 =  center.xyxy - radii, p1 =  center.xyxy + radii;\n    vec4 hash0, hash1;\n    betterHash2D(fract(p0) * 8192.0, fract(p1) * 8192.0, hash0, hash1);\n    vec4 temp = hash0;\n    hash0 = vec4(temp.xy, hash1.xy).xzyw * 2.0 - 1.0;\n    hash1 = vec4(temp.zw, hash1.zw).xzyw * 2.0 - 1.0;\n    \n    vec4 invScaleRatio = 1.0 / scaleRatio.xyxy;\n    invScaleRatio.zw *= invScaleRatio.zw;\n    vec4 dc;\n    vec4 pc;\n    vec4 oc;\n    p0 = pos.xyxy - p0 + hash0 * disorder.xyxy;\n    temp = (p0 * p0) * invScaleRatio.zwzw;\n    dc.xy = temp.xz + temp.yw;\n    \n    p1 = pos.xyxy - p1 + hash1 * disorder.xyxy;\n    temp = (p1 * p1)* invScaleRatio.zwzw;\n    dc.zw = temp.xz + temp.yw;\n    pc = mix(p0, p1, step(dc.zw, dc.xy).xxyy);\n    oc = mix(p0 - hash0 * disorder.xyxy, p1 - hash1 * disorder.xyxy, step(dc.zw, dc.xy).xxyy);\n    dc.xy = min(dc.xy, dc.zw);\n    \n    p0 = center.xyxy + radii.zwzw * vec4(-1.0, 1.0, 1.0, -1.0);\n    betterHash2D(fract(p0) * 8192.0, fract(center.xyxy) * 8192.0, hash0, hash1);\n    temp = hash0;\n    hash0 = vec4(temp.xy, hash1.xy).xzyw * 2.0 - 1.0;\n    hash1.xy = vec2(temp.z, hash1.z) * 2.0 - 1.0;\n    \n    p0 = pos.xyxy - p0 + hash0 * disorder.xyxy;\n    temp = (p0 * p0) * invScaleRatio.zwzw;\n    dc.zw = temp.xz + temp.yw;\n    pc = mix(pc, p0, step(dc.zw, dc.xy).xxyy);\n    oc = mix(oc, p0 - hash0 * disorder.xyxy, step(dc.zw, dc.xy).xxyy);\n    dc.xy = min(dc.xy, dc.zw);\n    \n    float d = min(dc.x, dc.y);\n    pc.xy = dc.x < dc.y ? pc.xy : pc.zw;\n    oc.xy = dc.x < dc.y ? oc.xy : oc.zw;\n    if (useCenter)\n    {\n        p0.xy = pos - center + hash1.xy * disorder.xy * 0.5;\n        dc.x = dot(p0.xy * invScaleRatio.xy, p0.xy * invScaleRatio.xy);\n        pc.xy = d < dc.x ? pc.xy : p0.xy;\n        oc.xy = d < dc.x ? oc.xy : pos - center;\n        d = min(d, dc.x);\n    }\n    radius *= size;\n    \n    d = sqrt(d);\n    vec2 dxdy = pc.xy / d;\n    vec2 uDu = noiseInterpolateDu((radius - d) / radius);\n    return vec4(vec3(uDu.x,  dxdy * (uDu.y * radius)) * step(0.0, uDu.x), hash1D(clamp(-oc.xy + pos, 0., 1.)));\n}\n\nvec3 gradientNoised(vec2 pos, vec2 scale, float seed) \n{\n    // gradient noise with derivatives based on Inigo Quilez\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n    \n    vec4 hashX, hashY;\n    smultiHash2D(i, hashX, hashY);\n    vec2 a = vec2(hashX.x, hashY.x);\n    vec2 b = vec2(hashX.y, hashY.y);\n    vec2 c = vec2(hashX.z, hashY.z);\n    vec2 d = vec2(hashX.w, hashY.w);\n    \n    vec4 gradients = hashX * f.xzxz + hashY * f.yyww;\n\n    vec4 udu = noiseInterpolateDu(f.xy);\n    vec2 u = udu.xy;\n    vec2 g = mix(gradients.xz, gradients.yw, u.x);\n    \n    vec2 dxdy = a + u.x * (b - a) + u.y * (c - a) + u.x * u.y * (a - b - c + d);\n    dxdy += udu.zw * (u.yx * (gradients.x - gradients.y - gradients.z + gradients.w) + gradients.yz - gradients.x);\n    return vec3(mix(g.x, g.y, u.y) * 1.4142135623730950, dxdy);\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uvN = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 baseColor = pow(vec3(187, 150, 46) / 255.0+0.2, vec3(2.2));\n    float shininess = 23.0;\n    float strength = 0.55;\n    vec2 jitter = abs(sin(iTime)) * vec2(0.35, 0.15);\n    float scale = 7.0;\n    vec3 shadow = vec3(1.35);\n    \n    vec3 g = gradientNoised(uv, vec2(scale, scale + 2.) + 5., 0.0);\n    uv += (g.yz) * 0.004;\n    vec4 c = noiseHexagonsd(uv, vec2(scale, scale + 2.), vec2(1.0, 0.68), 1.5, jitter, true, true);\n    {\n        vec3 hsv = rgb2hsv(baseColor);\n        hsv += (hash3D(c.ww) * 2.0 - 1.0) * vec3(0.02, 0.11, 0.1);\n        hsv.x = fract(hsv.x);\n        baseColor = hsv2rgb(clamp(hsv, 0.0, 1.0));\n    }\n    vec4 cInner = noiseHexagonsd(uv, vec2(scale, scale + 2.), vec2(2.0, 1.0), 0.5, jitter, true, true);\n    c.xyz -= cInner.xyz * vec2(0.35, 1.75).xyy;\n    vec3 normal = normalize(vec3(c.yz, c.x * 0.2));\n    normal = normalize(mix(vec3(0.0, 0.0, 1.0), normal, strength));\n    \n    vec3 lightDir = normalize(vec3(sin(iTime * 3.), 0.0, 1.0));\n    lightDir = normalize(vec3(0.5, 0.1, 2.5));\n    lightDir = mix(normalize(vec3(cos(iTime), sin(iTime), 1.0)), lightDir, pow(abs(sin(iTime * 0.25)), 2.0));\n    \n    vec3 viewDir = normalize(vec3(uvN * 2.0 - 1.0, 0.75));\n    vec3 halfDir = normalize(viewDir + lightDir);\n    vec3 R = reflect(viewDir, normalize(normal));\n    \n    // diffuse\n    vec3 col = max(dot(lightDir, normal), 0.0) * baseColor;\n    // specular blinn phong\n    col += pow(max(0.0, dot(normal, halfDir)), shininess) * textureLod(iChannel0, R, 5.5).rgb * 1.25;\n    col *= min(vec3(pow(vec3(max(c.x - 0.1, 0.0)), shadow)) * 1.0 - 0.1, 1.0) + baseColor * 0.175;\n\n    \n    fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}