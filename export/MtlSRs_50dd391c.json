{"ver":"0.1","info":{"id":"MtlSRs","date":"1439109194","viewed":380,"name":"Light Falloff Equations","username":"mba105","description":"Experimenting with some lighting falloff equations from Real-Time Rendering (ch. 7.4).","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["lightingfalloff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nvec3 render_square(vec2 coord, float size)\n{\n    \n    ivec2 p = ivec2(coord / size);\n    vec2 uv = mod(coord, size) / size;\n    \n    float li = 1.0; // light source intensity\n    float r = distance(uv, vec2(0.5)) * 10.0; // scaled distance from light\n    \n    if (ivec2(0, 0) == p)\n    {\n        // inverse square:\n        \n        // > li when distance is < 1.0\n        // never reaches 0.0\n        \n        float f = 1.0 / (r * r);\n        \n        return vec3(li * clamp(f, 0.0, 1.0));\n    }\n    \n    if (ivec2(1, 0) == p)\n    {\n        // fixed function:\n        // constant, linear, quadratic components\n        \n        float sc = 0.0;\n        float sl = 0.0;\n        float sq = 1.0;\n        \n        float f = 1.0 / (sc + sl * r + sq * r * r);\n        \n        return vec3(li * clamp(f, 0.0, 1.0));\n    }\n    \n    if (ivec2(2, 0) == p)\n    {\n        // radius controls:\n        \n        float rs = 1.0;\n        float re = 2.0;\n        \n        float f = (re - r) / (re - rs);\n        \n        return vec3(li * clamp(f, 0.0, 1.0));\n    }\n    \n    if (ivec2(3, 0) == p)\n    {\n        // pixar:\n        \n        // reaches fc at rc\n        // approaches fmax at r == 0.0\n        // never reaches 0.0\n        \n        float fc = 0.5;\n        float rc = 1.2;\n        float fmax = 1.0;\n        float se = 3.0;\n        \n        float k0 = log(fc / fmax);\n        float k1 = se / k0;\n        \n        float f0 = fmax * exp(k0 * pow(r / rc, -k1));\n        float f1 = fc * pow(rc / r, se);\n        \n        float f = mix(f0, f1, step(rc, r));\n        \n        return vec3(li * clamp(f, 0.0, 1.0));\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 result, in vec2 coord)\n{\n    vec2 screen = iResolution.xy;\n\t\n    // number of squares to fit on screen\n    vec2 n = vec2(4.0, 1.0);\n    \n    vec2 s = screen / n;\n    // size of a square\n    float size = min(s.x, s.y);\n    \n    // letterbox size\n    vec2 lb = screen - size * n;\n    \n    // color and return from letterbox\n    if (any(lessThan(coord, lb * 0.5)) || \n        any(lessThan(screen - coord, lb * 0.5)))\n    {\n        result = vec4(vec3(0.0, 0.1, 0.1), 1.0);\n        return;\n    }\n    \n    vec3 c = render_square(coord - lb * 0.5, size);\n    \n\tresult = vec4(c, 1.0);\n}\n","name":"","description":"","type":"image"}]}