{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\n//data structure for plane representing equation ax + by + cz = d\nstruct Plane {\n  vec3 abc;\n  float d;\n};\n\n//data structure for cube of equation x^n + y^n +z^n = r^n\nstruct Cube {\n\n  vec3 center;\n  float radius;\n  float n;\n};\n\n//determines if it was hit and color returned\nstruct hit {\n  bool h;\n  vec3 col;\n};\n\n//roatation functions\nvec3 rotate3Dy(vec3 v, float angle) {\n\n  return v * mat3(cos(angle), 0., sin(angle), 0., 1., 0., -sin(angle), 0.,\n                  cos(angle));\n}\n\nvec3 rotate3Dx(vec3 v, float angle) {\n\n  return v * mat3(1., 0., 0., 0., cos(angle), -sin(angle), 0., sin(angle),\n                  cos(angle));\n}\n\n//calculates the equation of the cube as a function of t\nfloat f(float t, vec3 ro, vec3 rd, Cube c) {\n  return pow(ro.x + t * rd.x - c.center.x, c.n) +\n         pow(ro.y + t * rd.y - c.center.y, c.n) +\n         pow(ro.z + t * rd.z - c.center.z, c.n) - pow(c.radius, c.n);\n}\n\n//derivative of above function\nfloat fprime(float t, vec3 ro, vec3 rd, Cube c) {\n  return (c.n * pow(ro.x + rd.x * t - c.center.x, c.n-1.) * rd.x) +\n         (c.n * pow(ro.y + rd.y * t - c.center.y, c.n-1.) * rd.y) +\n         (c.n * pow(ro.z + rd.z * t - c.center.z, c.n-1.) * rd.z);\n}\n\n//gradient vector of cube c at pos\nvec3 fgrad(vec3 pos, Cube c) {\n  return vec3(c.n * pow(pos.x - c.center.x, c.n-1.),\n              c.n * pow(pos.y - c.center.y, c.n-1.),\n              c.n * pow(pos.z - c.center.z, c.n-1.));\n}\n\n//newton approximation to calculate the value t that the ray hits the cube\nfloat newton(float xn, int d, vec3 ro, vec3 rd, Cube c) {\n\n  for (int i = 0; i < d; i++) {\n    xn = xn - f(xn, ro, rd, c) / fprime(xn, ro, rd, c);\n  }\n  return xn;\n}\n\n//intersect plane function returns t such that ro + t*rd hits the plane\nfloat iPlane(vec3 ro, vec3 rd, Plane p) {\n  return (p.d - dot(p.abc, ro)) / (dot(p.abc, rd));\n}\n\n//returns t such that ro + rd*t hits the cube\nfloat iCube(vec3 ro, vec3 rd, Cube c) {\n  float t = newton(0.0, 20, ro, rd, c);\n\n  if (f(t, ro, rd, c) < 0.01) {\n    return t;\n  }\n  return -1.0;\n}\n\n\n//checks intersection of plane and cube\nhit intersect(vec3 ro, vec3 rd, vec3 light) {\n\n//initalize the plane and cube\n  Plane p = Plane(vec3(0.0, 1.0, 0.0), -3.0);\n  Cube c = Cube(vec3(5. * sin(iTime), 0.0, 5. * cos(iTime)), 1.0, 6.0);\n\n  float tp = iPlane(ro, rd, p);\n  float tc = iCube(ro, rd, c);\n\n  if (tp > 0.) {\n    if (tc > 0.) {\n    \n    //hit the cube return phong lighting\n      vec3 pos = ro + tc * rd;\n      \n      //find dot product between normal of the cube and light directio \n      float d = dot(normalize(fgrad(pos, c)), normalize(light - ro - tc*rd));\n      \n      \n      //calculate specular lighting\n      vec3 viewdir = normalize(ro - pos);\n      vec3 reflectdir = reflect(-normalize(light-pos), normalize(fgrad(pos,c)));\n      float spec = pow(max(dot(viewdir, reflectdir), 0.0), 256.);\n      if (d < 0.0){\n          d = 0.0;\n      }\n      \n      //return the correct rgb for lighting\n      return hit(true, vec3(1.0,0.0,0.0) * (d + 0.3) + vec3(1.0,1.0,1.0) * spec/2.);\n\n    }\n    \n    \n    //hit plane\n        vec3 pos = ro + tp * rd;\n        \n        //add in shadows by intersecting light direction with the cube\n        float tt = iCube(pos, normalize(light - pos), c); \n        vec3 v = normalize(light - pos);\n        vec3 pq = normalize(c.center - pos);\n\n        float dd = length(cross(pq, v))/length(v);\n\n\n        if (tt > 0.){\n          return hit(true, vec3(dd));\n        }\n        \n        \n    float d = dot(normalize(p.abc), normalize(light - ro - tp * rd));\n    return hit(true, vec3(1.0) * (d + 0.1));\n  }\n\n  return hit(false, vec3(0.0));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates(from 0 to 1)\n  vec2 uv = fragCoord / max(iResolution.x, iResolution.y);\n\n  vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n  vec3 ro = vec3(0.0, 1.5, -7.);\n\n//initliaze vectors\n  vec3 rd = normalize(vec3(p, 2.0));\n  vec3 light = vec3(0.0, 3.0, 0.0);\n\n  vec3 col = vec3(0.);\n\n\n//calculate color vector and output\n  hit h = intersect(ro, rd, light);\n\n  if (h.h) {\n    col = h.col;\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfyBDW","date":"1734198836","viewed":20,"name":"cubeish","username":"arshakir","description":"created a ray traced cube ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cuberaytracing"],"hasliked":0,"parentid":"","parentname":""}}