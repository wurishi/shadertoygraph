{"ver":"0.1","info":{"id":"mlySWV","date":"1686353144","viewed":113,"name":"Stateful Balls","username":"memdbp","description":"Motion simulated with verlet integration (kinda). Optimized using voronoi. Data about each ball and pixel is stored in buffers. Click to randomize. Mouse x-position sets number of balls. Try maxing out the number of balls :love:","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","voronoi","simulation","balls","verlet","stateful"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// returns the location of ball data\nivec2 lookup(int id){\n    int maxAcesPixelX = (int(iResolution.x)/blocksize)*blocksize;\n    return ivec2( (blocksize*id)%maxAcesPixelX,   ((blocksize*id)/maxAcesPixelX)*blocksize );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 image = empty;\n    // background gradient and dithering\n    image = mix(gradient[0],gradient[1],fragCoord.y/iResolution.y);\n    image += (1.0/512.0)*sin(fragCoord.x*2.0+13.0*fragCoord.y);\n    // IDs of 4 closest particles to px\n    ivec4 adjacent = ivec4(texelFetch(iChannel2, ivec2(fragCoord), 0 ));\n    // draw balls that are close to the current pixel\n    for(int i=0;i < 4;i++){\n        ivec2 c = lookup(adjacent[i]);\n        // for the index of every ball fetch its info\n        vec2 location = texelFetch(iChannel1, c,0).xy;\n        vec4 color_radius = texelFetch(iChannel1, c + ivec2(0,1),0);\n        vec4 colish = texelFetch(iChannel1, c + ivec2(1,0),0);\n        float radius = color_radius.w;\n        float dist = distance(fragCoord,location);\n        float w = 0.5*fwidth(dist);\n        // tinge the base color on colide\n        vec4 color = mix( vec4(color_radius.xyz,1.), colish, max(colish.w-0.4,0.) );\n        // draw glow\n        if (adjacent[i]<int(iResolution.x))\n            image.xyz += colish.w*colish.xyz * 0.3*pow(radius*1.9/dist, glowintensity);\n        // draw balls\n        image = mix( color, image, smoothstep(-w,w,dist-radius) );        \n    }    \n    fragColor = image;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// nrand with a +iDate.w modifier\nfloat nrand( in vec2 n ) {\n    return fract(sin(floor(iDate.w) + dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// https://www.shadertoy.com/view/llGSzw\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nconst float PHI = 1.61803398;\nconst float PI = 3.141592653;\nconst float g = -9.81;\n\nconst vec4 empty = vec4(0.);\n// blocks are squares of pixels of blocksize length. blocks store data about each ball\nconst int blocksize = 2;\nconst int initialnumballs = 20;\n// gravity(given in m/s) is multiplied by 100 to represent chosen scale: 1px=1cm\nconst float scale = 100.;\nconst float maxvelocityvariance = 1000.0;\n// value that determines what min x-coord fills the screen with balls\nconst float maxballstart = 50.;\n// number of random vornoi checks that happen every frame on each pixel\nconst int randcheck = 3;\nconst float glowintensity = 4.;\nconst float fadespeed = 0.95;\nconst float maxslowdown = 40.;\nconst float slowdownstart = 20.;\n\nvec4 gradient[2] = vec4[](\n    vec4(0.),\n    vec4(0,0.11,0.21,1.)\n);\n\nconst vec3 palette[6] = vec3[](\n    vec3(1, 0.89, 0.25),\n    vec3(0.61, 0.36, 0.9),\n    vec3(0, 0.73, 0.98),\n    vec3(0, 0.96, 0.83),\n    vec3(0.95, 0.36, 0.71),\n    vec3(0.98,0.47,0.13)\n);\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// stores data from the previous frame. used for physics\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel1,ivec2(fragCoord),0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// particle buffer - verlet\n// data about each ball is stored in blocks of \"blocksize\"x\"blocksize\" pixels\n// ballnum starts with 1 but ID starts with 0\nstruct Phys {\n   vec2 pos;\n   vec2 vel;\n   bool walls;\n   bool[4] balls;\n};\n\n// returns the location of ball data\nivec2 lookup(int id){\n    int maxAcesPixelX = (int(iResolution.x)/blocksize)*blocksize;\n    return ivec2( (blocksize*id)%maxAcesPixelX,   ((blocksize*id)/maxAcesPixelX)*blocksize );\n}\n\nbool ballcollide(in vec2 p1next,in vec2 p2next,in float r1, in float r2) {    \n    if( distance(p1next,p2next) < r1+r2)\n        return true;\n    else\n        return false;\n}\n\n// x&y for wall or floor. data returned true is \"will collide in the next frame\"\nbool walls(inout vec2 position,inout vec2 velocity, float radius, float time) {\n    bool c = false;\n    vec2 acc = vec2(0.,g*scale);\n    vec2 pnext = position + velocity*time + acc*(time*time*0.5);\n    // walls\n    if( pnext.x <= radius)\n        velocity.x = abs(velocity.x),  c = true;\n    if ( pnext.x >= iResolution.x-radius)\n        velocity.x = -1.*abs(velocity.x),  c = true;\n    // floors\n    if( pnext.y <= radius)\n        velocity.y = abs(velocity.y),  c = true;\n    if( pnext.y >= iResolution.y-radius)\n        velocity.y = -1.*abs(velocity.y),  c = true;\n    return c;\n}\n\nPhys physics(in vec2 position,in vec2 velocity,in float radius,in float time,in int ID){\n    // verlet integration\n    vec2 acc = vec2(0.,g*scale);\n    vec2 new_pos = position + velocity*time + acc*(time*time*0.5);\n\tvec2 new_acc = vec2(0.,g*scale);\n\tvec2 new_vel = velocity + (acc+new_acc)*(time*0.5);\n    // ball collisions\n    bool[4] bc = bool[](false,false,false,false);\n    // pass current particle data and ajacent particle IDs to check for collisions\n    ivec4 adjacent = ivec4(texelFetch(iChannel0, lookup(ID)+ivec2(1,1), 0 ));\n    vec2 p1next = new_pos + new_vel*time + new_acc*(time*time*0.5);\n    for(int i = 1; i < 4; i++){\n        if(ID!=adjacent[i] && adjacent[i]>-1){\n            vec4 temp = texelFetch(iChannel0,lookup(adjacent[i]),0);\n            float r2 = texelFetch(iChannel0,lookup(adjacent[i])+ivec2(0,1),0).w;\n            vec2 p2 = temp.xy;\n            vec2 v2 = temp.zw;\n            vec2 p2next = p2 + v2*time + acc*(time*time*0.5);\n            // for every collision calculate the change in velocity\n            if( ballcollide(p1next,p2next,radius,r2) ){\n                // worst two lines IMO\n                vec2 normal = normalize(new_pos - p2next);\n                new_vel = faceforward(reflect(new_vel,normal),new_vel,normal);                \n                bc[i] = true;\n            }\n        }\n    }\n    // wall collisions: if ball is outside the screen on the next frame\n    bool w = walls(new_pos, new_vel, radius, time);\n    return Phys(new_pos,new_vel,w,bc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    ivec2 px = ivec2( fragCoord );\n    ivec2 intRes = ivec2(iResolution);\n    vec4 f = empty;\n    // copy previous frame to the buffer\n    f = texelFetch(iChannel0, px, 0 );\n    // set number of balls using buffer. if the buffer for numballs is empty (zero frame) set it to initialnumballs\n    vec4 balls_speed = texelFetch(iChannel0, intRes-1, 0 );\n    int numballs = int(balls_speed.x);\n    // 1 is full speed - lower value decreases speed\n    float speedlimit = min(1.,balls_speed.y);\n    // set numballs in buffer\n    if((iFrame==0 || numballs==0) && px==intRes-1) f = vec4(float(initialnumballs),1.,0.,0.);\n    // this is a variable for edgecases\n    int maxAcesPixelX = (intRes.x/blocksize)*blocksize;\n    // ballnum represents the block index of the current pixel. beginning with 1\n    int ballnum = 1 + \n        px.x/blocksize + // x\n        px.y/blocksize * (intRes.x/blocksize - (px.x/maxAcesPixelX)); // y\n    // mark as unused pixel if block is incomplete due to being at the edge\n    if((px.x/maxAcesPixelX)==1) ballnum = numballs+1;\n    // blockcord stores coordinates within the current block. beginning with 0\n    ivec2 blockcord = px % blocksize;\n    // initialize on frame 1 or on mouse click\n    if( iMouse.z > 0.0 || iFrame==1 ) {\n        f = empty;\n        if(px==intRes-1 && iFrame!= 1) {\n            // numballs\n            if(iMouse.x>iResolution.x-maxballstart)\n                f.x = float(intRes.x*intRes.y/blocksize/blocksize-2);\n            else\n                f.x = pow(iMouse.x/iResolution.x,5.)*iResolution.x+2.;\n            // speed\n            f.y = 1. / min(maxslowdown,trunc(1.+float(numballs))/slowdownstart);\n\n        }\n        // if the current pixel is inside the boundry of a block which needs to contain a ball, initialize it\n        if( ballnum <= numballs){\n            // coords(0,0): vec4(vec2 location, vec2 velocity)\n            if(blockcord == ivec2(0,0)) {\n                f = vec4(\n                    (iResolution.x / float(numballs + 1))*float(ballnum), // x\n                    iResolution.y*0.75, // y\n                    // get a random velocity\n                    nrand( fragCoord )*maxvelocityvariance-0.5*maxvelocityvariance, // x:\n                    nrand( fragCoord + vec2(3.))*maxvelocityvariance-0.5*maxvelocityvariance // y\n                );\n                if(numballs>intRes.x){\n                    f.xy = vec2(\n                        fragCoord.x, // x\n                        fragCoord.y // y\n                    );\n                }\n            // coords(0,1): vec4(vec3(r,g,b),float radius)\n            } else if(blockcord == ivec2(0,1)) {\n                f = vec4(\n                    // color: get a random color from the palette array\n                    palette[int(nrand(fragCoord)*3.*float(palette.length()))%palette.length()],\n                    // radius: golden ratio of ball diameter to largest screen dimension\n                    max(iResolution.x,iResolution.y) / (2.*float(numballs)*(PHI+1.)) \n                );\n                // give some random variation to the radius but make sure it's above 1px and below 1/4 the screen res\n                float maxradvar = f.w+1.;\n                f.w = clamp(f.w + nrand( fragCoord)*maxradvar,1.0,min(iResolution.x,iResolution.y)/4.);\n            }\n        } \n    // physics etc.\n    } else {\n        if( ballnum <= numballs){\n            int ID = ballnum - 1;\n            float time = iTimeDelta * 1. * speedlimit;\n            // position & velocity pixel\n            if(blockcord == ivec2(0,0)) {\n                float radius = texelFetch(iChannel0, px + ivec2(0.,1.), 0 ).w;\n                vec2 position = f.xy;\n                vec2 velocity = f.zw;\n                Phys phys = physics(position, velocity, radius, time, ID);\n                f = vec4(phys.pos,phys.vel);\n            }\n            // collision pixel - this will change the color of the ball if it's colliding\n            if(blockcord == ivec2(1,0)) {\n                // if it's colliding set it to a color. if it's not colliding fade to 0. if it's stationary fade to 0, but keep alpha 1    \n                vec4 temp = texelFetch(iChannel0, px + ivec2(-1.,0.), 0 );\n                float radius = texelFetch(iChannel0, px + ivec2(-1.,1.), 0 ).w;\n                vec2 position = temp.xy;\n                vec2 velocity = temp.zw*-1.;\n                Phys phys = physics(position, velocity, radius, time, ID);\n                // set or fade collision color\n                if( phys.walls ){\n                        f = vec4(vec3(.94),1.);\n                } else if( phys.balls != bool[](false,false,false,false) ){\n                    ivec4 adjacent = ivec4(texelFetch(iChannel0, px+ivec2(0,1), 0 ));\n                    for(int i = 1; i < 4; i++){\n                        if( phys.balls[i] == true ){\n                            // color of the ball it's colliding into\n                            f = vec4(texelFetch(iChannel0, lookup(adjacent[i])+ivec2(0,1), 0 ).xyz,1.);\n                        }\n                    }\n                } else {\n                    f.w *= fadespeed;\n                }\n            }\n            // adjacent IDs pixel - lookup the IDs of the 4 closest particles from buffer c\n            if(blockcord == ivec2(1,1)) {\n                // get the location of the ball\n                ivec2 position = ivec2(texelFetch(iChannel1, px + ivec2(-1.,-1.), 0 ).xy);\n                // display the 4 closest particle IDs\n                f = texelFetch(iChannel2, position, 0 );\n            }\n        }\n    }\n    fragColor = f;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// particle-pixel adjacency buffer - voronoi: https://www.shadertoy.com/view/WltSz7\n// every pixel stores IDs of 4 closest particles\n\n// returns the location of ball data\nivec2 lookup(int id){\n    int maxAcesPixelX = (int(iResolution.x)/blocksize)*blocksize;\n    return ivec2( (blocksize*id)%maxAcesPixelX,   ((blocksize*id)/maxAcesPixelX)*blocksize );\n}\n\n// returns data for final distance and ID buffers. if a new particle is closer to px coords then it's data is stored in the buffers and overwrites old data\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n    else if(d[3] < d_)           \n        i = ivec4(i.xyzw),    d = vec4(d.xyzw);\n}\n\n// gives distance. input the ID first particle and the location of the second\nfloat distance2Particle(int id, vec2 fragCoord, int numballs){\n\t// edge cases and uninitialized cases\n    if(id<0 || id>numballs-1) return 1e38;\n\t// measure the distance between the particles\n    // get the particle location corresponding to the input id\n    vec2 delta = texelFetch(iChannel1, lookup(id), 0).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 px = ivec2(fragCoord);\n\tivec2 intRes = ivec2(iResolution);\n    int numballs = int(texelFetch(iChannel1, intRes-1, 0 ).x);\n    int maxAcesPixelX = (intRes.x/blocksize)*blocksize;\n    ivec4 new = ivec4(-1);\n    vec4 dis = vec4(1e38);\t\n    // get all known closest particle IDs from old self and neighbours\n\t// get an ivec4 containing the IDs for the 4 closest particles of a pixel\n    ivec4 self = ivec4(texelFetch(iChannel2, px + ivec2( 0, 0), 0));\n    ivec4 right = ivec4(texelFetch(iChannel2, px + ivec2( 1, 0), 0));\n\tivec4 up = ivec4(texelFetch(iChannel2, px + ivec2( 0, 1), 0));\n    ivec4 left = ivec4(texelFetch(iChannel2, px + ivec2( -1, 0), 0));\n    ivec4 down = ivec4(texelFetch(iChannel2, px + ivec2( 0, -1), 0));\n\n    // if doing max\n    if( iMouse.z>0.0 && iMouse.x>iResolution.x-maxballstart)\n        self.x = 1 + \n            px.x/blocksize + // x\n            px.y/blocksize * (intRes.x/blocksize - (px.x/maxAcesPixelX)); // y\n    \n    //collect them in a array so we can loop over it = 20 IDs\n    ivec4[5] candidates = ivec4[5](self, right, up, left, down); \n\t// check 5 pixels * 4 particles = 20 checks for distance\n\t// after this is run the buffers \"new\" and \"dis\" will contain data for the closest particles\n    for(int i=0; i<5; i++){\n        for(int j=0; j<4; j++){\n            int id = candidates[i][j];\n            float dis2 = distance2Particle(id, fragCoord, numballs);\n            insertion_sort( new, dis, id, dis2 );\n        }\n    }\n\t// this loop just gets the ID of a random existinig particle and checks its distance    \n    for(int j = 0; j < randcheck; j++){\n        float h = hash(\n            px.x + // x \n            px.y*intRes.x + // y\n            iFrame*intRes.x*intRes.y + // frame step\n            j // incresed to check more particles - helpful if lots of particles or speed is high\n        );\n        int p = int(h*float(numballs));\n        insertion_sort(new, dis, p, distance2Particle(p, fragCoord, numballs) );\n    }\n\t// store the IDs in the buffer\n    fragColor = vec4(new); \n}","name":"Buffer C","description":"","type":"buffer"}]}