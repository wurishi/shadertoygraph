{"ver":"0.1","info":{"id":"3tsfz7","date":"1596364327","viewed":228,"name":"Swimming Pool on a Cloudy Day","username":"DrNoob","description":"Swimming pool on a cloudy summer day\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.","likes":8,"published":1,"flags":96,"usePreview":0,"tags":["fbm","blur","water","caustics","gamma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtB3DG","filepath":"https://soundcloud.com/daniel-ottini-sound/swimming-pool-ambience","previewfilepath":"https://soundcloud.com/daniel-ottini-sound/swimming-pool-ambience","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Swimming pool on a cloudy summer day\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Takes the pool floor from buffer A and applies some Gaussian blur to it.\n// Then adds fake caustics, passing clouds and does some gamma adaptation.\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Coordinate normalization\n    vec2 st = fragCoord / iResolution.xy;\n    st.x -= 0.5;\n    st.x *= iResolution.x / iResolution.y;\n    \n    // Truncated, normalized Gaussian kernel coefficients for sigma = 3.0 via\n    // http://dev.theomader.com/gaussian-kernel-calculator/\n    const int kSize = 3;\n    float[] kCoeffs = float[](0.174938, 0.165569, 0.140367, 0.106595);\n    \n    // Apply Gaussian blur to pool floor from buffer A (channel 0)\n    vec3 color = vec3(0);\n    for (int dy = -kSize; dy <= kSize; ++dy) {\n        int ky = abs(dy);\n    \tfor (int dx = -kSize; dx <= kSize; ++dx) {\n            int kx = abs(dx);\n        \tcolor += kCoeffs[kx] * kCoeffs[ky] * texture(iChannel0, (fragCoord + vec2(dx, dy)) / iResolution.xy).rgb;\n    \t}\n    }\n    \n        \n    // Add fake caustics\n    // https://www.shadertoy.com/view/MdlXz8\n    const float inten = 1.0 / 0.005;\n    const float tau = 10.0;\n    vec2 p = mod(st*tau, tau) - 250.0;\n\tvec2 i = st * 20.0;\n\tfloat c = 1.0;\n\n    const int numIter = 5;\n\tfor (int n = 0; n < numIter; ++n) \n\t{\n\t\tfloat t = iTime * (1.0 - (3.5 / float(n + 1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0 / length(vec2(p.x / (sin(i.x + t) * inten), p.y / (cos(i.y + t) * inten)));\n\t}\n\tc /= float(numIter);\n\tc = 1.17 - pow(c, 1.4);\n\tc = pow(abs(c), 20.0);\n    color = mix(color, white, clamp(c, 0.0, 1.0));\n    \n    // Add passing clouds\n    float s = vfbm(st + 0.25 * iTime);\n    color = mix(color, black, 0.4 * s);\n    \n    // Gamma adaptation\n    const float invGamma = 1.0 / 0.7;\n    color = pow(color, vec3(invGamma));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Swimming pool on a cloudy summer day\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// This buffer generates the pool floor.\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Line SDF\nfloat line(in vec2 p,   // input coordinates\n           in vec2 v0,  // start point\n           in vec2 v1,  // end point\n           in float lw, // line width\n           in float sw) // step width\n{\n    vec2 sp = vec2(sw, sw); // 2D step width\n    \n    vec2 line = smoothstep(v0 - vec2(lw) - sp, v0 - vec2(lw) + sp, p) *\n         (1.0 - smoothstep(v1 + vec2(lw) - sp, v1 + vec2(lw) + sp, p));\n    \n    return line.x * line.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Coordinate normalization\n    vec2 st = fragCoord / iResolution.xy;\n    st.x -= 0.5;\n    st.x *= iResolution.x / iResolution.y;\n  \n    // Grid\n    const int gridSize = 40;\n    vec2 grid = vec2(gridSize);\n    vec2 gv = st * grid;\n    \n    // Animate grid\n    gv += vec2(0.2 * vnoise(5.0 * iTime + gv.x) * sin(5.0 * iTime + gv.y),\n               0.1 * vnoise(3.0 * iTime + gv.y) * cos(4.0 * iTime + gv.x));\n    \n    // Cell coordinates\n    vec2 cv = fract(gv);\n    vec2 id = floor(gv);\n\n    // Cell color\n    vec3 cellColor = mix(darkBlue, white, hash21(id));\n    \n    // Inner cells\n    float s = step(-grid.x * 0.2, id.x) - step(grid.x * 0.2, id.x);\n    vec3 color = mix(midBlue, cellColor, s);\n    \n    // Outer cells\n    s = step(-grid.x * 0.3, id.x) - step(-grid.x * 0.2, id.x);\n    color = mix(color, white, s);\n    s = step(grid.x * 0.2, id.x) - step(grid.x * 0.3, id.x);\n    color = mix(color, white, s);\n    \n    // Add lines\n    const vec3 lineColor = lightBlue;\n    float lw = 0.05; // line width\n    float sw = 0.15; // step with\n    vec2 sp = vec2(0.5) - abs(cv - 0.5); // step position\n    for (int x = -gridSize; x <= gridSize; ++x) {\n        float l = line(gv, vec2(x, 0), vec2(x, gridSize), lw, sw);\n        color = mix(color, lineColor, l);\n    }\n    for (int y = 0; y <= gridSize; ++y) {\n    \tfloat l = line(gv, vec2(-gridSize, y), vec2(gridSize, y), lw, sw);\n\t  \tcolor = mix(color, lineColor, l);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Colors\nconst vec3 black = vec3(0);\nconst vec3 white = vec3(0.975,0.975,0.975);\nconst vec3 darkBlue = vec3(0.406,0.528,0.920);\nconst vec3 midBlue = vec3(0.550,0.776,0.920);\nconst vec3 lightBlue = vec3(0.642,0.861,0.975);\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 1D value noise\nfloat vnoise(in float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f*f * (3.0 - 2.0*f); // smoothstep without clamping\n    return mix(hash11(i), hash11(i + 1.0), u);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(vec2 p) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int numOctaves = 5;\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * vnoise(p);\n\t\tp = rot * p * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n","name":"Common","description":"","type":"common"}]}