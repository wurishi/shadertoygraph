{"ver":"0.1","info":{"id":"Wl2cWR","date":"1594125739","viewed":157,"name":"jjj concetric squares rotating","username":"jjj","description":"concetric squares rotating, pga","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["squares","pga2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define u_time iTime\n#define u_resolution iResolution\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_SQRT_2 1.4142135623731\n\n\n#define mvec2 float[8]\n\n\n\n// basis vectors\n// \"1\",\"e0\",\"e1\",\"e2\",\"e01\",\"e20\",\"e12\",\"e012\"\n\nmvec2 conjugate (mvec2 mv) {\n    return mvec2 (mv[0], -mv[1], -mv[2], -mv[3], -mv[4], -mv[5], -mv[6], mv[7]);\n}\n\nmvec2 reverse (mvec2 mv) {\n    return mvec2 (mv[0], mv[1], mv[2], mv[3], -mv[4], -mv[5], -mv[6], -mv[7]);\n}\n\nmvec2 dual(mvec2 mv) {\n    return mvec2(mv[7], mv[6], mv[5], mv[4], mv[3], mv[2], mv[1], mv[0]);\n}\n\nmvec2 Involute (mvec2 mv) {\n    return mvec2( mv[0], -mv[1], -mv[2], -mv[3], mv[4], mv[5], mv[6], -mv[7] );\n}\n\n// The geometric product.\nmvec2 mul (mvec2 a, mvec2 b)\n{\n    return mvec2 (\n        b[0]*a[0]+b[2]*a[2]+b[3]*a[3]-b[6]*a[6],\n        b[1]*a[0]+b[0]*a[1]-b[4]*a[2]+b[5]*a[3]+b[2]*a[4]-b[3]*a[5]-b[7]*a[6]-b[6]*a[7],\n        b[2]*a[0]+b[0]*a[2]-b[6]*a[3]+b[3]*a[6],\n        b[3]*a[0]+b[6]*a[2]+b[0]*a[3]-b[2]*a[6],\n        b[4]*a[0]+b[2]*a[1]-b[1]*a[2]+b[7]*a[3]+b[0]*a[4]+b[6]*a[5]-b[5]*a[6]+b[3]*a[7],\n        b[5]*a[0]-b[3]*a[1]+b[7]*a[2]+b[1]*a[3]-b[6]*a[4]+b[0]*a[5]+b[4]*a[6]+b[2]*a[7],\n        b[6]*a[0]+b[3]*a[2]-b[2]*a[3]+b[0]*a[6],\n        b[7]*a[0]+b[6]*a[1]+b[5]*a[2]+b[4]*a[3]+b[3]*a[4]+b[2]*a[5]+b[1]*a[6]+b[0]*a[7]\n    );\n}\n\nmvec2 mul (mvec2 a, float b) {\n    return mvec2(a[0]*b, a[1]*b, a[2]*b, a[3]*b, a[4]*b, a[5]*b, a[6]*b, a[7]*b);\n}\n\nmvec2 mul (float a, mvec2 b) {\n    return mul(b,a);\n}\n\nmvec2 meet(mvec2 a, mvec2 b)\n{\n    return mvec2(\n\t    b[0]*a[0],\n    \tb[1]*a[0]+b[0]*a[1],\n    \tb[2]*a[0]+b[0]*a[2],\n\t    b[3]*a[0]+b[0]*a[3],\n    \tb[4]*a[0]+b[2]*a[1]-b[1]*a[2]+b[0]*a[4],\n\t    b[5]*a[0]-b[3]*a[1]+b[1]*a[3]+b[0]*a[5],\n    \tb[6]*a[0]+b[3]*a[2]-b[2]*a[3]+b[0]*a[6],\n\t    b[7]*a[0]+b[6]*a[1]+b[5]*a[2]+b[4]*a[3]+b[3]*a[4]+b[2]*a[5]+b[1]*a[6]+b[0]*a[7]\n    );\n}\n\nmvec2 join(mvec2 a, mvec2 b) {\n\treturn mvec2(\n\t\tb[0]*a[7]+b[1]*a[6]+b[2]*a[5]+b[3]*a[4]+b[4]*a[3]+b[5]*a[2]+b[6]*a[1]+b[7]*a[0],\n\t\tb[1]*a[7]+b[4]*a[5]-b[5]*a[4]+b[7]*a[1],\n\t\tb[2]*a[7]-b[4]*a[6]+b[6]*a[4]+b[7]*a[2],\n\t\tb[3]*a[7]+b[5]*a[6]-b[6]*a[5]+b[7]*a[3],\n\t\tb[4]*a[7]+b[7]*a[4],\n\t\tb[5]*a[7]+b[7]*a[5],\n\t\tb[6]*a[7]+b[7]*a[6],\n\t\tb[7]*a[7]\n\t);\n}\n\nmvec2 inner(mvec2 a, mvec2 b) {\n    return mvec2(\n        b[0]*a[0]+b[2]*a[2]+b[3]*a[3]-b[6]*a[6],\n        b[1]*a[0]+b[0]*a[1]-b[4]*a[2]+b[5]*a[3]+b[2]*a[4]-b[3]*a[5]-b[7]*a[6]-b[6]*a[7],\n        b[2]*a[0]+b[0]*a[2]-b[6]*a[3]+b[3]*a[6],\n        b[3]*a[0]+b[6]*a[2]+b[0]*a[3]-b[2]*a[6],\n        b[4]*a[0]+b[7]*a[3]+b[0]*a[4]+b[3]*a[7],\n        b[5]*a[0]+b[7]*a[2]+b[0]*a[5]+b[2]*a[7],\n        b[6]*a[0]+b[0]*a[6],\n        b[7]*a[0]+b[0]*a[7]\n    );\n}\n\nfloat norm( mvec2 mv) { \n    return sqrt(abs(mul(mv, conjugate(mv))[0]));\n}\n\nfloat inorm(mvec2 mv) { \n    return mv[1] != 0.0 ? mv[1] : mv[7] != 0.0 ? mv[7] : norm(dual(mv));\n}\n\nmvec2 normalize2(mvec2 mv) {\n    return mul(mv, 1./norm(mv));\n}\n\nmvec2 add (mvec2 a, float b) {\n    return mvec2(a[0]+b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]);\n}\n\nmvec2 add (float a, mvec2 b) {\n    return add(b,a);\n}\n\n\n\n\nmvec2 apply( mvec2 transformation, mvec2 target) {\n    return mul(mul(transformation, target), reverse(transformation));\n}\n\n\n\n\nmvec2 point( vec2 p ) {\n    return mvec2 (0., 0., 0., 0., p.x, p.y, 1., 0.);\n}\n\nvec2 point( mvec2 p ) {\n    return vec2( p[4], p[5]);\n}\n\nmvec2 line( vec2 p ) {\n    return mvec2 (0., 0., p.x, -p.y, 0., 0., 0., 0.);\n}\n\nmvec2 line( vec2 p1, vec2 p2 ) {\n    return join(point(p1), point(p2));\n}\n\nmvec2 dir( vec2 p ) {\n    return mvec2 (0., 0., 0., 0., p.x, p.y, 0., 0.);\n}\n\n\n\n\n\nmvec2 rot( float rad, vec2 p) {\n    return add(cos(rad*.5), mul(point(p), sin(rad*.5)));\n}\n\nmvec2 rot( float rad) {\n    return rot(rad, vec2(0.));\n}\n\nmvec2 orth_trans( vec2 d) {\n    return add(1., dir(d));\n}\n\nmvec2 trans(vec2 d) {\n    mvec2 r = rot(radians(90.));\n    \n    return add(1., apply(r, dir(d)));\n    \n}\n\nfloat oscilate(float min, float max, float freq) {\n    return (sin(u_time)*freq+.5)*(max-min) + min;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float COUNT = 20.;\n    float THICKNESS = oscilate(0.1, 0.9,  0.5) * .5; // oscilate(0.1, 0.9,  0.5);  // .5\n    float DRAG = oscilate(0.2, 2.0,  0.2); // oscilate(0.2, 3.0,  0.5); // .5 or 1.2\n    float CYCLE_LENGTH = 1.5; // oscilate(1.0, 1.5,  0.2); // oscilate(1.0, 2.0,  0.05); // 1.5\n    float SHARPNESS = 100./u_resolution.y; // 10.\n    float SPEED = 1.0; // doesn't oscilate nicely\n\n\n    // Normalized pixel coordinates (from -1 to 1)\n    float resScale = 1.0/min(u_resolution.x, u_resolution.y);\n    vec2 p = (fragCoord.xy*2.0 - u_resolution.xy)*resScale;\n    float dist = abs(length(p)*COUNT);\n\n    float c = 0.;\n    for (float i = max(1., trunc(dist/M_SQRT_2)); i < min(dist+1., COUNT); i += 1.) {\n        float angleMixFactor = smoothstep(0., 1., \n            mod(u_time*SPEED -i*DRAG/COUNT, CYCLE_LENGTH) );\n\n        float rad = -M_PI * .5 * angleMixFactor; // from 0 to 90 degrees\n        mvec2 R = rot(rad);\n\n        vec2 rp = abs(point(apply(R, point(p))));\n        float d = max(rp.x,rp.y) * COUNT;\n        float e =\n            smoothstep(i, i-SHARPNESS, d-THICKNESS) *\n            smoothstep(i-SHARPNESS, i, d+THICKNESS)\n        ;\n        c = max(c, e);\n    }\n    \n    vec3 col = vec3(c);\n\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}