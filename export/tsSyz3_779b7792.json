{"ver":"0.1","info":{"id":"tsSyz3","date":"1587047525","viewed":439,"name":"Bubulle with ggx and sss","username":"MonsieurSoleil","description":"Test using nusan/flopine/leon denise/iq and other shaders code found on the net.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","noise","subsurfacescattering","wave","shadow","volumetric","glow","kifs","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nconst float GA = 2.399; \n\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemapACES( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec4 dof(vec2 uv, float rad, float focusDistance, float maxVal)\n{\n\n\tvec4 texFetch = texture(iChannel0, uv);\n\n\tfloat diff = maxVal *  abs(focusDistance - fract(texFetch.x * 10000.0));\n\ttexFetch.x -= fract(texFetch.x * 10000.0);\n\t\n\tvec3 acc = texFetch.xyz;\n    vec2 pixel = vec2(diff * 1080.0f/1920.0f, diff);\n\t\n\tvec2 angle=vec2(0.0,rad);\n\t\n    float r = 1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        r += 1.0/r;\n\t\t\n\t    angle *= rot;\n        vec4 col = texture(iChannel0,uv + pixel * (r-1.) * angle);\n\t\tacc+=col.xyz;\n\t}\n\t\n\tfloat gamma = 2.2;\n\treturn vec4(tonemapACES(acc/80.), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1.0 / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    \n    vec4 mainColor = dof(fragCoord.xy *pp, 2.5, 0.3, 0.0005);\n    \n    fragColor = vec4(mainColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// sub surface scattering https://www.shadertoy.com/view/XscyRs + https://www.shadertoy.com/view/lllBDM\n\nfloat gg = 0.0;\n\n#define time iTime\n\nconst float pi = 3.14159;\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p, vec2(127.1, 311.7)),\n              dot(p, vec2(269.5, 183.1)) );\n    \n  return -1.0 + 2.0 * fract(sin(p) * 46375.264154);\n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n}\n\nvec3 tonemapAces( vec3 x)\n{\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  \n  return (x * (a * x + b)) / (x * (c*x+d) + e);\n}\n\nfloat noise(in vec2 p)\n{\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  \n  vec2 u = f*f*(3.0 - 2.0 * f);\n  \n  return mix(\n  \n  mix(dot( hash( i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0) ),\n      dot( hash( i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0) ), u.x ),\n  \n  mix(dot( hash( i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0) ),\n    dot( hash( i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0) ), u.x), u.y);\n  \n}\n\nfloat rnd(vec2 uv)\n{\n   return fract(\n                dot(\n                    sin(uv*754.2697 + uv.yx * 942.742), \n                    vec2(3847.6511)\n                  )\n              );\n}\n\nfloat rnd(float t)\n{\n   return fract(sin(t * 425.65211) * 562.145);\n}\n\nfloat curve(float t)\n{\n  return mix(\n  rnd(floor(t)), \n  rnd(floor(t)+1.0),\n  smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat terrain(vec2 p)\n{\n  vec2 p2 = p;\n  vec2 p3 = p;\n  \n  p2.y += curve(time * 0.01) * 32.0; \n  p3.x += curve(time * 0.02) * 32.0; \n  p3.y += curve(time * 0.01) * 64.0;\n  \n  float valS = noise(p * 0.01) + 0.5;\n  valS = 1.0 - abs(valS - 0.5) * 2.0;\n  valS = pow(valS, 2.0);\n  \n  float valM = noise(p3 * 0.26) + 0.5;\n  valM = 1.0 - abs(valM - 0.5) * 2.0;\n  valM = pow(valM, 2.0);\n  \n  float valB = smoothstep(0.0, 1.0, noise(p2 * 0.1) + 0.1);\n  \n  float val = valS * 1.01 + valM * 0.99 + valB * 2.8;\n  \n  return val * 1.3 - 0.3;\n}\n\nfloat sphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nfloat map(vec3 p)\n{\n  float mat = 0.0;\n  \n \n  \n  vec3 p2 = p;\n  vec3 p3 = p;\n  //p3.xz *= rot( cos(time+(p.x * 0.05)) );\n  mat = sphere(p, 8.0);\n  \n    // act as a bounding volume to optimize calculations.\n  if(mat < 1.0)\n  {\n    mat =max(mat, p.y + (cos(time * 0.5) * 1.5 + 2.0) - terrain(p.xz));\n    \n    mat = max(mat, sphere(p, 8.0));\n    \n    gg += 0.1/(0.9+mat*mat);\n  }\n  \n  return mat;\n}\n\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n\nvec3 subsurface( vec3 p, vec3 dir )\n{\nvec3 density = pow(vec3(0.7, 0.5, 0.4), vec3(0.4));\n  float confidence = .01;\n  vec3 visibility = vec3(1.0);\n  \n  float lastVal = map(p);\n  float soft = 0.0;\n  for(int i = 1; i < 15; ++i)\n  {\n    if( visibility.x < confidence )\n    {\n      continue;\n    }\n    \n    float val = map(p);\n    \n    vec3 softened = pow(density, vec3(smoothstep(soft, -soft, val)));\n    \n    if( (val-soft) * lastVal < 0.0 )\n    {\n      float transition = -min(val-soft, lastVal)/abs(val-soft-lastVal);\n      visibility *= pow(softened, vec3(transition));\n    }\n    \n    else if( val-soft < 0.0 )\n    {\n      visibility *= softened;\n    }\n    \n    soft += 0.1;\n    lastVal = val+soft;\n    p += dir * 0.4;\n  }\n  \n  return visibility;\n}\n\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0)\n{\n  float alpha = rough*rough;\n  float asqrt = alpha*alpha;\n  vec3 h = normalize(v + l);\n  \n  float dnl = clamp(dot(n, l), 0.0, 1.0);\n  float dnv = clamp(dot(n, v), 0.0, 1.0);\n  float dnh = clamp(dot(n, h), 0.0, 1.0);\n  float dlh = clamp(dot(l, h), 0.0, 1.0);\n  \n  float f, d, vis;\n  float den = dnh*dnh*(asqrt - 1.0) + 1.0;\n  d = asqrt/(pi * den * den);\n  dlh = pow(1.0 - dlh, 5.0);\n  f = f0 + (1.0 - f0)*dlh;\n  float k = alpha/1.0;\n  vis = G1V(dnl, k)*G1V(dnv, k);\n  \n  \n  float spec = dnl * d * f *vis;\n  return spec;\n}\n\nfloat err(float dist){\n    dist = dist/100.0;\n    return min(0.01, dist*dist);\n}\n\nvec3 dr(vec3 origin, vec3 direction, vec3 position){\n    int iterations = 3;\n    for(int i = 0; i < iterations; i++){\n        position = position + direction * (map(position) - err(distance(origin, position)));\n    }\n    return position;\n}\n\nvec3 calcNormals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.00);\n  return normalize(map(p) - vec3(map(p-uv.xyy), map(p-uv.yxy), map(p-uv.yyx)));\n}\n\nfloat getao(vec3 p, vec3 n, float h)\n{\n  return clamp(map(p+n*h) / h, 0.0, 1.0);\n}\n\nfloat shadow(vec3 p, vec3 l, int stepC, float limit)\n{\n  for(int i = 0; i < stepC; ++i)\n  {\n    float d = map(p);\n    \n    if(d < limit)\n    {\n      return 0.0;\n      break;\n    }\n    if(d > 20.0)\n    {\n     \treturn 1.0;   \n    }\n    \n    p += d * l;\n  }\n  \n   return 1.0;\n}\n\nfloat shadowS(vec3 p, vec3 l, int stepC, float limit)\n{\n\tfloat acc = 0.0;\n  for(int i = 0; i < stepC; ++i)\n  {\n    float d = map(p);\n    \n    if(d < limit)\n    {\n      return abs(0.5 - (float(i) * 0.01));\n      break;\n    }\n    if(d > 20.0)\n    {\n     \treturn 1.0;   \n    }\n    \n    p += d * l;\n  }\n  \n   return 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 light = vec3(0., 10.5, 1.0);\n    \n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 ori = vec3(cos(time * 0.1) * 22.5, 7.5, sin(time * 0.1) * 22.5), target = vec3(0.0);\n  vec3 forward = normalize(target - ori);\n  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n  vec3 up = normalize(cross(forward, right));\n  vec3 dir = normalize(forward + right * uv.x + up * uv.y);\n  vec3 p = ori + 0.5 * dir;\n  \n  vec3 color = vec3(0.0);\n  \n  float shad = 0.0;\n  float mat = 0.0;\n  float d = 0.0;\n  float RealDistance = 0.0f;\n  for(int i = 0; i < 120; ++i)\n  {\n    mat = map(p);\n    \n    if(mat < 0.001) \n    {\n        shad = pow(1.0-(d*float(i)/500.0), 2.0);\n      \n        break;\n    }\n    \n    color += vec3(1.0, 1.0, 1.0) * gg * 0.0020;\n    d+=mat * 0.8;\n    p += mat * dir* 0.8;\n    RealDistance = d;\n  }\n  \n  float rand = rnd(uv);\n  \n  // Volumetric\n  const int volumetricSteps = 50;\n  float voldist = 35.0;\n  float stepsize = voldist/float(volumetricSteps);\n  vec3 lr = dir * stepsize;\n  vec3 lp = ori + lr * rand;\n  float stepdist = stepsize* rand;\n  vec3 atcol = vec3(0.0);\n  \n  for(int i = 0; i < volumetricSteps; ++i)\n  {\n    if(stepdist > d)\n    {\n      break;\n    }\n    vec3 lv = light - lp;\n    float ldist = length(lv);\n    lv = normalize(lv);\n    \n    \n    float shadowV = shadow(lp + lr * 0.1, lv, 20, 0.1);\n    atcol += 0.7/(0.05+ ldist*ldist) * shadowV;\n    \n    lp+=lr;\n    stepdist += stepsize;\n  }\n  \n  float fog = 0.0;\n  if(RealDistance >= 100.0f)\n  {\n      RealDistance = 99.0f;\n  } else {\n      fog = 1.0 - clamp((RealDistance / 100.0), 0.0, 1.0);\n  }\n  \n  \n   vec3 skycolor = mix(vec3(0.0, 0.4, 1.0), vec3(1.0, 0.2, 0.0), pow(1.0-(clamp(uv.y+0.6, 0.0, 1.0)), 0.7));\n   \n   if(shad >= 0.0 && fog > 0.2)\n  {\n    vec3 n = calcNormals(p);\n    vec3 ld = normalize(-light);\n    float fresnel = pow( max(0.0, 1.0 + dot(n, dir)), 3.0 );\n    \n    \n    vec3 albedo = vec3(1.0);\n    \n    vec3 lamb = vec3(max(0.0, dot(n, ld)));\n    float spec = ggx(n, dir, ld, 3.0, fresnel);\n\t\n    vec3 ss = subsurface(p, dir);\n\n    lamb = mix(lamb, ss, 0.8);\n    //lamb = ss;\n    color += (vec3(1.0) * spec + (lamb * albedo)) * 1.0;\n\t//color += ((lamb * albedo));\n    color += (skycolor * fresnel) * 1.0;\n    \n  }\n  \n  \n  //vec3 skycolor = mix(vec3(0.0, 0.4, 1.0), vec3(1.0, 0.3, 0.0), pow(1.0-(clamp(uv.y+0.6, 0.0, 1.0)), 0.7));\n  \n \n\tcolor += pow(1.0 - fog, 8.0) * 1.4 * skycolor * 1.0;\n \n\tcolor += atcol;\n\t\n\t\n\t\n\tcolor.x = round(color.x*10000.0) * 0.0001;\n/* \n    this portion of code is useless,where i have to put his, \n    i couldn't get alpha from any buffer, \n    so i had to hide the distance value into red color.\n*/\n\t\n\tcolor.x += ( clamp((length(p-ori)/100.0) * 0.0001, 0.000001, 0.0000999f));\n\t\n    fragColor = vec4(color.xyz, 1.0);\n  \n  \n  fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}