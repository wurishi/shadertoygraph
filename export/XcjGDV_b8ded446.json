{"ver":"0.1","info":{"id":"XcjGDV","date":"1704663249","viewed":30,"name":"GridDotPng ","username":"Eighteur","description":"Turn Pixels into circles","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","png"],"hasliked":0,"parentid":"lcB3DV","parentname":"RandomDotPng"},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat MapInput(float x, float in_min, float in_max, float out_min, float out_max)\n{\n    float result = (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n    return result;\n}\nvec2 MapInput(vec2 x, float in_min, float in_max, float out_min, float out_max)\n{\n    vec2 result = vec2((x.x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min,\n    (x.y - in_min) * (out_max - out_min) / (in_max - in_min) + out_min);\n    return result;\n}\n\nvec4 getGridColor(vec2 gridSize, vec2 offset, float sizeRatio, vec2 uv)\n{\n    vec2 pixelOffset = vec2(1./(gridSize.x), 1./(gridSize.y));\n    float circleSize = 1.0 / (gridSize.x*5.) * sizeRatio;\n    \n    vec4 resultColor = vec4(0.);\n    \n    //Define the color of the pixel\n    vec2 testPos = ((uv) / (pixelOffset));\n    testPos = vec2(floor(testPos.x), floor(testPos.y)) - offset;\n    testPos = vec2(pixelOffset.x * (testPos.x ) + (pixelOffset.x ) /2., pixelOffset.y * (testPos.y) + pixelOffset.y /2.);\n    vec4 testColor = texture(iChannel0, testPos);\n    \n    //Define if the pixel is in one of the circle\n    float dist = sdCircle(testPos-uv, circleSize);\n    dist = step(dist, circleSize);\n    \n    return testColor * dist;\n}\n\nvec4 getGridColorWithSize(vec2 gridSize, vec2 offset, float sizeRatio, vec2 uv, vec3 rgb)\n{\n    vec2 pixelOffset = vec2(1./(gridSize.x), 1./(gridSize.y));\n    float circleSize = 1.0 / (gridSize.x*5.) * sizeRatio;\n    \n    vec4 resultColor = vec4(0.);\n    \n    //Define the color of the pixel\n    vec2 testPos = ((uv) / (pixelOffset));\n    testPos = vec2(floor(testPos.x), floor(testPos.y)) - offset;\n    testPos = vec2(pixelOffset.x * (testPos.x ) + (pixelOffset.x ) /2., pixelOffset.y * (testPos.y) + pixelOffset.y /2.);\n    vec4 testColor = texture(iChannel0, testPos);\n    testColor.w = testColor.r * rgb.r + testColor.g * rgb.g + testColor.b * rgb.b;\n    testColor = vec4(testColor.r * rgb.r,testColor.g * rgb.g,testColor.b * rgb.b, testColor.a);\n    \n    //Define if the pixel is in one of the circle\n    float dist = sdCircle(testPos-uv, circleSize * testColor.w);\n    dist = step(dist, circleSize);\n    \n    testColor.w = dist;\n    return testColor * dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    //Define the grid size\n    vec2 gridSize = vec2(100. * ((sin(iTime/2.) + 1.)/2.),100.* ((sin(iTime/5.)+1.)/2.));\n    \n    //Define the subgrid parameters\n    vec4 mainColor = getGridColorWithSize(gridSize, vec2(0.), 0.7, uv, vec3(1.,0.,0.));\n    vec4 secondaryColor = getGridColorWithSize(gridSize, vec2(0.2), 0.7, uv, vec3(0.,1.,0.));\n    vec4 tertiaryColor = getGridColorWithSize(gridSize, vec2(-0.1,-0.3), 0.7, uv, vec3(0.,0.,1.));\n    \n    // Output to screen\n    fragColor = mainColor + secondaryColor + tertiaryColor;\n}","name":"Image","description":"","type":"image"}]}