{"ver":"0.1","info":{"id":"lsSyDW","date":"1492135611","viewed":138,"name":"IIS Loxodromic Example","username":"soma_arc","description":"Render the orbit of circles with Iterated Inversion System.\nLoxodromic Generator.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","inversion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\n\nvec3 makeCircleFromPoints(vec2 a, vec2 b, vec2 c){\n    float lA = distance(b, c);\n    float lB = distance(a, c);\n    float lC = distance(a, b);\n    float coefA = lA * lA * (lB * lB + lC * lC - lA * lA);\n    float coefB = lB * lB * (lA * lA + lC * lC - lB * lB);\n    float coefC = lC * lC * (lA * lA + lB * lB - lC * lC);\n    float denom = coefA + coefB + coefC;\n    vec2 center = (coefA * a + coefB * b + coefC * c)/denom;\n    return vec3(center, distance(center, a));\n}\n\nvec2 circleInvert(vec2 pos, vec3 circle){\n\treturn ((pos - circle.xy) * circle.z * circle.z)/(length(pos - circle.xy) * length(pos - circle.xy) ) + circle.xy;\n}\nconst float PI = 3.1415926535;\n\nconst float schottky1R = 75.;\nconst float schottky2R = 90.;\nconst float schottky3R = 90.;\nconst float schottky4R = 75.;\nvec3 schottky1 = vec3(214, -7, schottky1R);\nvec3 schottky2 = vec3(160, 150, schottky2R);\nvec3 schottky3 = vec3(-5, 220, schottky3R);\nvec3 schottky4 = vec3(-155, 150, schottky4R);\n\n// A Loxodromic Generator\nconst vec3 C1 = vec3(-10, -20, 150);\nconst vec3 C2 = vec3(0, 0, 200);\nconst vec3 C1d = vec3(18.18181818, 36.36363636, 272.72727272); // C1' = I_C2(C1)\nvec3 C3 = vec3(311.05263, -605.526315, 650.70412);\nvec2 P = vec2(300, -600);\n// a line is represented by a direction vector and \n// TC1 and TC1'\n// The line l is derived from a point and a direction vector\nconst vec4 line = vec4(C1.xy, normalize(C1.xy - C2.xy)); // (x, y, dirX, dirY)\n\n// The angle between TL and TC3\nconst float theta = 0.56661607666;\n\n\nconst int MAX_ITERATIONS = 55;\nint iterations = 0;\nfloat colNum = 0.;\nfloat IIS(vec2 pos){\n    colNum = 0.;\n    float loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < MAX_ITERATIONS ; i++){\n\t\tif(i > iterations) break;\n        cont = false;\n        \n\t\tif(distance(pos, schottky1.xy) < schottky1.z){\n\t\t\tpos = circleInvert(pos, schottky1);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, schottky2.xy) < schottky2.z){\n\t\t\tpos = circleInvert(pos, schottky2);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, schottky3.xy) < schottky3.z){\n\t\t\tpos = circleInvert(pos, schottky3);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, schottky4.xy) < schottky4.z){\n\t\t\tpos = circleInvert(pos, schottky4);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, C1.xy) < C1.z){\n            vec2 pVec = pos - line.xy;\n            float len = dot(pVec, line.zw);\n            vec2 lP = len * line.zw + line.xy;\n            vec2 reflecVec = 2. * (lP - pos);\n            pos = pos + reflecVec;\n\n    \t\tpos = circleInvert(pos, C3);\n    \t\tpos = circleInvert(pos, C1);\n    \t\tpos = circleInvert(pos, C2);\n\n    \t\tcont = true;\n    \t\t//\t\t loopNum++;\n \t\t}else if(distance(pos, C1d.xy) >= C1d.z){\n    \t\tpos = circleInvert(pos, C2);\n    \t\tpos = circleInvert(pos, C1);\n\n    \t\tpos = circleInvert(pos, C3);\n\n            \n            vec2 pVec = pos - line.xy;\n            float len = dot(pVec, line.zw);\n            vec2 lP = len * line.zw + line.xy;\n            vec2 reflecVec = 2. * (lP - pos);\n            pos = pos + reflecVec;\n\n\n    \t\tcont = true;\n    \t\t//\t\t loopNum++;\n \t\t}\n\n        \n\t\tif(cont == false) break;\n\t}\n\n\treturn loopNum;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 renderGen(const vec2 pos){\n    vec3 col = vec3(0);\n    \n    vec2 v1 = pos - line.xy;\n    vec2 projection = line.zw * dot(v1, line.zw);\n    vec2 n = v1 - projection;\n    float d = length(n);\n    if(d < 10.)\n        col = vec3(1);\n    else if(distance(pos, C1.xy) < C1.z){\n    \tcol = vec3(.5, 0, 0);\n    }else if(distance(pos, C2.xy) < C2.z){\n    \tcol = vec3(0, .5, 0);\n    }else if(distance(pos, C1d.xy) < C1d.z){\n    \tcol = vec3(0, 0, .5);\n    }\n    if(distance(pos, C3.xy) < C3.z){\n    \tcol = mix(col, vec3(1, 1, 0), 0.5);\n    }\n    if(distance(pos, P) < 30.){\n    \tcol = vec3(0, 1, 1);\n    }\n    return col;\n}\n\nvec3 gammaCorrect(vec3 c){\n    const float gammaCoeff = 1. / 2.2;\n\treturn vec3(pow(c.x, gammaCoeff),\n               \tpow(c.y, gammaCoeff),\n               \tpow(c.z, gammaCoeff));\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nconst float SAMPLE_NUM = 30.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, 4. + PI * 8.);\n    vec3 sum = vec3(0);\n        \n    float startTime = 0.;\n    schottky1.z = mix(0., schottky1R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n    \n    iterations += (t > startTime + 0.2) ? 1 : 0;\n    iterations += (t > startTime + 0.4) ? 1 : 0;\n    iterations += (t > startTime + 0.6) ? 1 : 0;\n    iterations += (t > startTime + 0.8) ? 1 : 0;\n    iterations += (t > startTime + 1.) ? 1 : 0;\n    iterations += (t > startTime + 1.2) ? 1 : 0;\n    iterations += (t > startTime + 1.4) ? 1 : 0;\n    iterations += (t > startTime + 1.6) ? 1 : 0;\n    iterations += (t > startTime + 1.8) ? 1 : 0;\n    iterations += (t > startTime + 2.) ? 1 : 0;\n    \n    startTime += 2.;\n    \n    if(t > startTime)\n        P.x = 350. + 600. * sin(t - startTime + PI/2.);\n    else\n\t\tP.x = 350. + 600. * sin(0. + PI/2.);\n\n    iterations += int(mix(0., 30.,\n                         scene(t, startTime, 0.5)));\n    startTime += 3.5;\n    \n    schottky2.z = mix(0., schottky2R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\t\n    startTime += 3.5;\n  \n    schottky3.z = mix(0., schottky3R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 3.5;\n    \n    schottky4.z = mix(0., schottky4R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 5.;\n    \n    schottky1.z += mix(0., -schottky1R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n    \n    schottky2.z += mix(0., -schottky2R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\t\n    startTime += 2.;\n  \n    schottky3.z += mix(0., -schottky3R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n    \n    schottky4.z += mix(0., -schottky4R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    \n    vec2 pd = circleInvert(P, C1);\n    vec2 pdd = circleInvert(P, C2);\n    C3 = makeCircleFromPoints(P, pd, pdd);\n    \n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        position = position * 1700.;\n        position += vec2(0, -300);\n\n        float loopNum = IIS(position);\n\n        if(loopNum >  0.){\n            sum += hsv2rgb(vec3(0.01 + 0.03 * (loopNum - 1.),1.0,1.0));\n        }else{\n            sum += renderGen(position);\n            //sum += vec3(0.,0.,0.);\n        }\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}","name":"Image","description":"","type":"image"}]}