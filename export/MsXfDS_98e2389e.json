{"ver":"0.1","info":{"id":"MsXfDS","date":"1497824879","viewed":408,"name":"Voronoi - Medial Axis Distances","username":"steverock","description":"Voronoi noise with an extra pass to compute distance-to-cell-medial-axis. Green lines are the normal cell borders, purple lines are the medial axes, and grey lines are the isolines of the medial-axis-distance-field.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All based on: https://iquilezles.org/articles/voronoilines\n\nfloat CELL_FREQ = 8.0;\nfloat DOTS = 0.;\n\n// J=1.,R=2 is artifact free\n// J=1,R=1 is mostly artifact free\n// J=1.5,R=1 has some discounts, but visually acceptable\nfloat JITTER_SCALE = 1.0;\nint SECOND_PASS_INDEX_RADIUS = 1;\n\nvec4 red = vec4(1., 0., 0.0, 1.0);\nvec4 green = vec4(0., 1., 0.0, 1.0);\nvec4 blue = vec4(0.5, 0.2, 1.0, 1.0);\n\nvec2 perp(vec2 r) {\n    return vec2(r.y, -r.x);\n}\n\nvec2 random2f( vec2 p )\n{\n    p.x += iTime*0.1;\n\treturn JITTER_SCALE * texture( iChannel0, (p+0.5)/12.0, -100.0 ).xy;\n}\n\nfloat line_offset(vec2 p, vec2 dir) {\n    return p.y - p.x * dir.y/dir.x;\n}\n\nfloat line_slope(vec2 p, vec2 dir) {\n    return dir.y/dir.x;\n}\n\nfloat lensq(vec2 v) {\n    return dot(v, v);\n}\n\nvec2 intersect(vec2 p1, vec2 d1, vec2 p2, vec2 d2)\n{\n    // Notation: rearrange the two lines and solve:\n    // ax + c = bx + d\n    float a = line_slope(p1, d1);\n    float c = line_offset(p1, d1);\n    float b = line_slope(p2, d2);\n    float d = line_offset(p2, d2);\n    \n    return vec2(\n        (d-c)/(a-b),\n        (a*d-b*c)/(a-b));\n}\n\nvec2 rotate(vec2 v, float rads)\n{\n    float c = cos(rads);\n    float s = sin(rads);\n    return vec2( c * v.x - s * v.y,\n                 s * v.x + c * v.y );\n}\n    \nvoid voronoi( in vec2 xGlobal, out vec2 cellId, out float distToAnchor,\n             out float distToBorder, out float distToMedial )\n{\n    vec2 p = vec2(floor( xGlobal ));\n    vec2 f = fract( xGlobal );\n\n    vec2 cellAnchor;\n\n    // Find the cell we're in\n    distToAnchor = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( float(i), float(j) );\n        vec2 qLocal = b + random2f(p+b);\n        vec2 r = qLocal - f;\n        float d = dot(r,r);\n\n        if( d < distToAnchor )\n        {\n            distToAnchor = d;\n            cellAnchor = r;\n            cellId = b;\n        }\n    }\n\n    // Second pass to explicitly find closest bisector\n    // given the cell point.\n    distToBorder = 8.0;\n    vec2 borderAnchor;\n    int R2 = SECOND_PASS_INDEX_RADIUS;\n    for( int j=-R2; j<=R2; j++ )\n    for( int i=-R2; i<=R2; i++ )\n    {\n        vec2 b = cellId + vec2( float(i), float(j) );\n        vec2 qLocal = b + random2f(p+b);\n        vec2 r = qLocal - f;\n        float d = dot( 0.5*(cellAnchor+r), normalize(r-cellAnchor) );\n\n        if( d < distToBorder ) {\n            distToBorder = d;\n            borderAnchor = r;\n        }\n    }\n    \n    // THE NEW STUFF\n    // Third pass to find closest medial axis segment or border.\n    // We're including the border, so set that as initial best.\n    distToMedial = distToBorder;\n    vec2 p1 = (cellAnchor + borderAnchor) * 0.5;\n    vec2 d1 = normalize(cellAnchor - borderAnchor);\n    \n    for( int j=-R2; j<=R2; j++ )\n    for( int i=-R2; i<=R2; i++ )\n    {\n        vec2 b = cellId + vec2( float(i), float(j) );\n        vec2 qLocal = b + random2f(p+b);\n        vec2 r = qLocal - f;\n        \n        vec2 p2 = (cellAnchor + r) * 0.5;\n        vec2 d2 = normalize(cellAnchor - r);\n\n        vec2 p3 = intersect(\n            p1, perp(d1),\n            p2, perp(d2));\n        \n        // ALTERNATE, BAD METHOD:\n        // Compute a point equidistant from both borders,\n        // along the ray (p1, d1).\n        // This doesn't work for the d1=d2 case for some reason.\n        // The denom is near-0, but it doesn't result in good behavior.\n        // Not sure why.\n        /*\n        float t = (p1.y*d2.y - p2.y*d2.y + p1.x*d2.x - p2.x*d2.x)\n                  /\n                  (1.0 - d1.y*d2.y - d1.x*d2.x);\n        vec2 p3 = p1 + t*d1;\n\t\t*/\n\n        // The iso-line direction is half way between the two perpendicular directions.\n        // Use rotations instead of just averaging, to be robust near the d1=-d2 case.\n        float theta = atan(d2.y, d2.x) - atan(d1.y, d1.x);\n        vec2 d3 = rotate(d1, theta/2.0);\n\n        // Compute perp distance\n        float d2iso = abs(dot(p3, perp(d3)));\n        distToMedial = min(distToMedial, d2iso);\n    }\n}\n\nfloat isoline(float dist) {\n    return pow(sin(6.2*10.0*dist) * 0.5 + 0.5, 5.);\n}\n\nfloat gauss(float x) {\n    return exp(-1. * x * x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float freq = CELL_FREQ;\n    float toMedial;\n    float toAnchor;\n    float toBorder;\n    vec2 cellId;\n    voronoi(uv*freq, cellId, toAnchor, toBorder, toMedial);\n    \n    fragColor = vec4(0.);\n   \tfragColor += gauss(toBorder*30.) * green;\n    fragColor += DOTS * gauss(toAnchor*1000.) * green;\n    fragColor += gauss(toMedial*100.)*blue;\n    fragColor += isoline(toMedial*2.)*vec4(0.3);\n}","name":"Image","description":"","type":"image"}]}