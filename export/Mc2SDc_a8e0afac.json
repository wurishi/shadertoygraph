{"ver":"0.1","info":{"id":"Mc2SDc","date":"1706925898","viewed":179,"name":"[phreax] aurora borrealis slow","username":"phreax","description":"Slow painter version of https://www.shadertoy.com/view/lfjSWc\nAwesome to watch at fullscreen!\n\nYou may play with brightness, contrast and feedback values depending on resolution.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","warp","highlights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fork of \"Basic Warped 2D Noise\" by Shane. https://shadertoy.com/view/Xl2XWz\n\n/*\n\tStandard Warped Noise\n\t---------------------\n\n\tLoosely based on the original by Shadertoy user \"jackdavenport.\"\n\thttps://www.shadertoy.com/view/Mt2SzR\n\n\tIn keeping with the concept of the original, this was also coded straight off the top of my head.\n\n*/\n\n#define PHI 1.61803\n#define PI  3.14159\n\n// change for different effects, depending on resolution\n#define FEEDBACK 0.995\n#define BRIGHTNESS 10.\n#define CONTRAST 1.5\n#define SPEED 1.\n\n// Virtually the same as your original function, just in more compact (and possibly less reliable) form.\nfloat smoothNoise(vec2 p) {\n\t\n\tvec2 i = floor(p); p-=i; p *= p*(3.-p-p); \n    \n    return dot(mat2(fract(sin(vec4(0, 1, 27, 28) + i.x+i.y*27.) * 1e5))*vec2(1.-p.y,p.y), vec2(1.-p.x, p.x));\n\n}\n\n// Also the same as the original, but with one less layer.\nfloat fractalNoise(vec2 p) {\n    \n    return smoothNoise(p)*.5333 + smoothNoise(p*2.)*.2667 + smoothNoise(p*4.)*.1333 + smoothNoise(p*8.)*.0667;\n    \n    //Similar version with fewer layers. The highlighting sample distance would need to be tweaked.\n    //return smoothNoise(p)*.57 + smoothNoise(p*2.45)*.28 + smoothNoise(p*6.)*.15;\n    \n    // Even fewer layers, but the sample distance would need to be tweaked.\n    //return smoothNoise(p)*.65 + smoothNoise(p*4.)*.35;\n    \n}\n\n// Standard noise warping. Call the noise function, then feed a variation of the result\n// into itself. Rinse and repeat, etc. Completely made up on the spot, but keeping your \n// original concept in mind, which involved combining noise layers travelling in opposing\n// directions.\nfloat warpedNoise(vec2 p) {\n    \n    vec2 m = vec2(iTime, -iTime)*.15;//vec2(sin(iTime*0.5), cos(iTime*0.5));\n    \n    \n    float x = fractalNoise(p + m);\n    float y = fractalNoise(p + m.yx + x);\n    float z = fractalNoise(p - m - x + y);\n    return fractalNoise(p + vec2(x, y) + vec2(y, z) + vec2(z, x) + length(vec3(x, y, z))*0.25);\n    \n    \n}\n\n// Zucconis Spectra color (https://www.shadertoy.com/view/cdlSzB)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\nvec3 colNoise(vec2 uv, float colShift) {\n    float nl = warpedNoise(uv*2.);\n    // Take two noise function samples near one another.\n    float n = warpedNoise(uv * 6.);\n    float n2 = warpedNoise(uv * 6. + .03*sin(nl));\n    \n    // Highlighting - Effective, but not a substitute for bump mapping.\n    //\n    // Use a sample distance variation to produce some cheap and nasty highlighting. The process \n    // is vaguely related to directional derivative lighting, which in turn is mildly connected to \n    // Calculus from First Principles.\n    float bump = max(n2 - n, 0.)/.02*.7071;\n    float bump2 = max(n - n2, 0.)/.02*.7071;\n    \n    // Ramping the bump values up.\n    bump = bump*bump*.25 + pow(bump, 8.)*.25;\n    bump2 = bump2*bump2*.25 + pow(bump2, 8.)*.15;\n    \n    vec3 col = spectral_zucconi6(nl+n*1.5+colShift)*(vec3(1.000,0.800,0.973)*vec3(1.2*bump, (bump + bump2)*.4, bump2)*.3);\n\n    return col;\n}\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n\n// cheapo noise function\nfloat n21(vec2 p) {\n    p = fract(p*vec2(234.42,725.46));\n    p += dot(p, p+54.98);\n    return fract(p.x*p.y);\n}\n\nvec2 n22(vec2 p) {\n    float n = n21(p);\n    return vec2(n, n21(p+n));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates. Using division by a scalar, namely \"iResolution.y,\" for aspect correctness.\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    // uv = uv.yx;\n    uv.x = abs(uv.x);\n   \n  \n   vec3 col = vec3(0);\n   // vec3 col = colNoise(uv*2.) + colNoise(uv)*1.2 + .25*colNoise(uv*.4)+.1*colNoise(uv*.1);\n    \n   for(float i=.0; i<=.8; i+=.2) {   \n       float z = fract(i-.05*iTime*SPEED);\n       float fade = smoothstep(.8, .1, z); // \n       //uv += 0.2*n22(vec2(i*412., 52423.*i));\n       uv *= rot(2.*PI/PHI+ PI/12.*sin(.1*iTime*SPEED));       // Rotate layer\n       vec2 UV = uv*1.5*z+ + n22(vec2(i*51., 4213.*i));        // Scale and offset layer by random value\n      \n       col += colNoise(UV, SPEED*iTime*.11+z)*fade;\n    }\n\n    \n    // Gamma correction.\n    col = pow(clamp(col, 0., 1.)*BRIGHTNESS, vec3(CONTRAST));\n    col = pow(col, vec3(1./2.2));\n    \n    vec4 tex = texture(iChannel0, fragCoord/iResolution.xy);\n    if (tex.a != iResolution.x) tex = vec4(0); // detect resolution change\n    \n    col = mix(col, tex.rgb, FEEDBACK);\n    fragColor = vec4(col, iResolution.x);\n        \n}\n","name":"Buffer A","description":"","type":"buffer"}]}