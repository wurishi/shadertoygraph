{"ver":"0.1","info":{"id":"cljBz1","date":"1693771080","viewed":63,"name":"Rainbow Aurora","username":"gigaherz","description":"A silly fork of https://www.shadertoy.com/view/ctjfR1 with the effect coloring changed to a rainbow.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rainbow","aurora"],"hasliked":0,"parentid":"ctjfR1","parentname":"Basic Aurora"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\n//\nfloat hash(float n) { return fract(sin(n) * 1e4) - 0.5; }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))) - 0.5; }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\t// Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise(vec3 x) {\n\tconst vec3 step = vec3(110, 241, 171);\n\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n \n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \n\t// incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat noiseOctaves(vec3 x) {\n    return\n        noise(x) + \n        noise(x*2.0+x)*0.5 + \n        noise(x*4.0+x*2.0)*0.25 + \n        noise(x*8.0+x*4.0)*0.125;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0f - 1.0f;\n    \n    // perspective (I probably should be using matrix calculations here instead of trig)\n    vec3 origin = vec3(0,0,0);\n    float yaw = 0.0f;\n    float pitch = 50.0f * 0.01745f /* deg to rad */; // upward\n    vec2 look = vec2(yaw,pitch);\n    float fov_x = 3.0f; // only want half here\n    vec2 tfov = vec2(fov_x, fov_x * iResolution.y / iResolution.x);\n    vec2 tan_uv = uv * tfov;\n    vec2 ray_a = atan(tan_uv) + look;\n    vec3 ray = vec3(\n        cos(ray_a.x) * cos(ray_a.y),\n                       sin(ray_a.y),\n        sin(ray_a.x) * cos(ray_a.y)\n    );\n    \n    if (ray.y < 0.0)\n    {\n        fragColor = vec4(0,0,0,1.0f);\n        return;\n    }    \n    \n    // aurora\n    float start = 1000.0f;\n    float end = 8000.0f;\n    float brightness = 25.0f;\n    \n    // view range\n    float fade_start = 10000.0f;\n    float fade_end = 20000.0f;\n    \n    vec3 outc = vec3(0.0f,0.0f,0.0f);\n    float steps = 125.0f;\n    for(float i=0.0f;i<steps;i++)    \n    {    \n        float fi = i/steps;\n        float elevation = mix(start, end, fi);\n        \n        // intersect ray with elevation\n        vec2 intersection = vec2(\n            elevation * ray.x / ray.y,\n            elevation * ray.z / ray.y);\n            \n        float h_distance = length(intersection);\n        float coef = 1.0f;\n            \n        if (h_distance > fade_end)\n        {\n            continue;\n        }\n        if (h_distance > fade_start)\n        {\n            coef = 1.0f - (h_distance-fade_start)/(fade_end-fade_start);\n        }\n                    \n        vec3 timeOffset = iTime * vec3(0.01f, 0.01f, 0.02f);\n        vec3 posOffset = vec3(intersection * 0.00025f, fi*0.01f);\n            \n        // noise values\n        float value = noiseOctaves(timeOffset + posOffset);\n        float hue = 8.0f*fract(fi + 0.01f*noiseOctaves(timeOffset + posOffset*10.0f + vec3(0.27f, 0.43f, 0)));\n    \n        float col = coef * (brightness / steps) * clamp(2.0-4.0*(fi-0.5f),0.0f,1.0f) * clamp(2.5f-abs(value)*50.0f,0.0f,1.0f);\n        \n        vec3 color = vec3(0,1,0);\n        if (hue < 1.0f)\n            color = mix(vec3(0,0,0),vec3(0.25f,0,0.25f),hue);\n        else if (hue < 2.0f)\n            color = mix(vec3(0.25f,0,0.25f),vec3(0,0,1),hue-1.0f);\n        else if (hue < 3.0f)\n            color = mix(vec3(0,0,1),vec3(0,1,1),hue-2.0f);\n        else if (hue < 4.0f)\n            color = mix(vec3(0,1,1),vec3(0,1,0),hue-3.0f);\n        else if (hue < 5.0f)\n            color = mix(vec3(0,1,0),vec3(1,1,0),hue-4.0f);\n        else if (hue < 6.0f)\n            color = mix(vec3(1,1,0),vec3(1,0,0),hue-5.0f);\n        else if (hue < 7.0f)\n            color = mix(vec3(1,0,0),vec3(0.5f,0,0.2f),hue-6.0f);\n        else \n            color = mix(vec3(0.5f,0,0.2f),vec3(0,0,0),hue-7.0f);\n     \n        outc += col * color;\n    }\n\n    // Output to screen\n    fragColor = vec4(outc,1.0);\n}","name":"Image","description":"","type":"image"}]}