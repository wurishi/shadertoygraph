{"ver":"0.1","info":{"id":"XslyzX","date":"1489141737","viewed":1073,"name":"ColorBlindness","username":"lhog","description":"ColorBlindness correction","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","colorblindness"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// copypasta from: http://blog.noblemaster.com/wp-content/uploads/2013/10/2013-10-26-ColorCorrection.txt\n\n\n// OpenGL code for color correction\n// Correction for color blindness (more here: http://tylerdavidhoward.com/thesis/)\n\nconst mat3 RGBtoOpponentMat = mat3(0.2814, -0.0971, -0.0930, 0.6938, 0.1458,-0.2529, 0.0638, -0.0250, 0.4665);\nconst mat3 OpponentToRGBMat = mat3(1.1677, 0.9014, 0.7214, -6.4315, 2.5970, 0.1257, -0.5044, 0.0159, 2.0517);\n\nconst int NONE = 0;\nconst int PROTANOPIA = 1;\nconst int DEUTERANOPIA = 2;\nconst int TRITANOPIA = 3;\n\nconst int blindnessType = PROTANOPIA; //example\n\nvoid blindnessFilter( out vec4 myoutput, in vec4 myinput )\n{\n\tif (blindnessType == PROTANOPIA) {\n\t\t\tvec3 opponentColor = RGBtoOpponentMat * vec3(myinput.r, myinput.g, myinput.b);\n\t\t\topponentColor.x -= opponentColor.y * 1.5; // reds (y <= 0) become lighter, greens (y >= 0) become darker\n\t\t\tvec3 rgbColor = OpponentToRGBMat * opponentColor;\n\t\t\tmyoutput = vec4(rgbColor.r, rgbColor.g, rgbColor.b, myinput.a);\n\t} else if (blindnessType == DEUTERANOPIA) {\n\t\t\tvec3 opponentColor = RGBtoOpponentMat * vec3(myinput.r, myinput.g, myinput.b);\n\t\t\topponentColor.x -= opponentColor.y * 1.5; // reds (y <= 0) become lighter, greens (y >= 0) become darker\n\t\t\tvec3 rgbColor = OpponentToRGBMat * opponentColor;\n\t\t\tmyoutput = vec4(rgbColor.r, rgbColor.g, rgbColor.b, myinput.a);\n\t} else if (blindnessType == TRITANOPIA) {\n\t\t\tvec3 opponentColor = RGBtoOpponentMat * vec3(myinput.r, myinput.g, myinput.b);\n\t\t\topponentColor.x -= ((3.0 * opponentColor.z) - opponentColor.y) * 0.25;\n\t\t\tvec3 rgbColor = OpponentToRGBMat * opponentColor;\n\t\t\tmyoutput = vec4(rgbColor.r, rgbColor.g, rgbColor.b, myinput.a);\n    } else {\n\t\t\tmyoutput = myinput;\n\t}\t\n}\n\nvoid blindnessVision( out vec4 myoutput, in vec4 myinput )\n{\n\tvec4 blindVisionR;\n\tvec4 blindVisionG;\n\tvec4 blindVisionB;\n\tif (blindnessType == PROTANOPIA) {\n\t\t\tblindVisionR = vec4( 0.20,  0.99, -0.19, 0.0);\n\t\t\tblindVisionG = vec4( 0.16,  0.79,  0.04, 0.0);\n\t\t\tblindVisionB = vec4( 0.01, -0.01,  1.00, 0.0);\n\t} else if (blindnessType == DEUTERANOPIA) {\n\t\t\tblindVisionR = vec4( 0.43,  0.72, -0.15, 0.0 );\n\t\t\tblindVisionG = vec4( 0.34,  0.57,  0.09, 0.0 );\n\t\t\tblindVisionB = vec4(-0.02,  0.03,  1.00, 0.0 );\t\t\n\t} else if (blindnessType == TRITANOPIA) {\n\t\t\tblindVisionR = vec4( 0.97,  0.11, -0.08, 0.0 );\n\t\t\tblindVisionG = vec4( 0.02,  0.82,  0.16, 0.0 );\n\t\t\tblindVisionB = vec4(-0.06,  0.88,  0.18, 0.0 );\n\t} else {\n        \tblindVisionR = vec4(1.0,  0.0,  0.0, 0.0 );\n        \tblindVisionG = vec4(0.0,  1.0,  0.0, 0.0 );\n        \tblindVisionB = vec4(0.0,  0.0,  1.0, 0.0 );\t\t\t\n\t}\n\tmyoutput = vec4(dot(myinput, blindVisionR), dot(myinput, blindVisionG), dot(myinput, blindVisionB), myinput.a);\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy; // Condensing this into one line\n    vec4 texColor = texture(iChannel0,xy); // Get the pixel at xy from iChannel0\n    vec4 tmp;\n    blindnessFilter(tmp, texColor);    \n    blindnessVision(fragColor, tmp);\n}","name":"Image","description":"","type":"image"}]}