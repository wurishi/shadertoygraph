{"ver":"0.1","info":{"id":"MlVSRc","date":"1485832447","viewed":138,"name":"Assignment 2 -- Reveal","username":"IllusoryOrchestra","description":"This is my second assignment for my Graphics/Game Programming I course. This includes both the original assignment instructions and the bonuses. The circle appears when the texture is clicked, and the circle can be clicked and dragged across the texture.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","blur","edgedetection","textures","emboss","sharpen","reveal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAuthor: Megan Hoins\nClass: CSI-200-01\nAssignment: Assignment 2 - Reveal\nDate Assigned: January 24, 2017\nDue Date: January 31, 2017 at 11:59 PM\n\nDescription:\nThis program will blur a texture. Hovering the mouse over the texture \nwill \"reveal\" another texture underneath, which is sharpened. The reveal \nwill be limited to a circle around the mouse position. The radius of the \ncircle will initially be 10% but it will be variable, or able to be changed \nby a variable defined at the top of the shader.\n\nCertification of Authenticity: I certify that this is entirely my own work,\nexcept where I have given fully-documented references to the work of others.\nI understand the definition and consequences of plagiarism and acknowledge\nthat the assessor of this assignment may, for the purpose of assessing this\nassignment:\n- Reproduce this assignment and provide a copy to another member of academic\nstaff; and/or\n- Communicate a copy of this assignment to a plagiarism checking service\n(which may then retain a copy of this assignment on its database for the\npurpose of future plagiarism checking)\n\n*/\n\nfloat blurMultiplier = 1.0; // Create a variable to hold a multiplier that will ensure the blur is\n\t\t\t\t\t\t\t// parametrically modifiable\n\nfloat blurTotal = 0.111 * blurMultiplier; // Calculate the total blur amount by multiplying the \n\t\t\t\t\t\t\t\t\t\t  // default by the multiplier\n\n// Create a matrix to hold the blur kernel -- the amount of blur will be parametrically modifiable\n// based on the above variables and the results of the calculation\nmat3 blur = mat3(\n \tblurTotal, blurTotal, blurTotal, // First column\n \tblurTotal, blurTotal, blurTotal, // Second column\n \tblurTotal, blurTotal, blurTotal // Third column\n);\n\n// Create a matrix to hold the sharpen kernel\nmat3 sharpen = mat3(\n \t0.0, -1.0, 0.0, // First column\n \t-1.0, 5.0, -1, // Second column\n \t0.0, -1.0, 0.0 // Third column\n);\n\n// Create a matrix to hold the first edge detection kernel\nmat3 edgeDetection1 = mat3(\n    -1.0, -1.0, -1.0, // First column\n    -1.0, 8.0, -1.0, // Second column\n    -1.0, -1.0, -1.0 // Third column\n);\n\n// Create a matrix to hold the second edge detection kernel\nmat3 edgeDetection2 = mat3(\n  \t0.0, 1.0, 0.0, // First column\n    1.0, -4.0, 1.0, // Second column\n    0.0, 1.0, 0.0 // Third column\n);  \n\n// Create a matrix to hold the emboss kernel\nmat3 emboss = mat3(\n    -2.0, -1.0, 0.0, // First column\n    -1.0, 1.0, 1.0, // Second column\n    0.0, 1.0, 2.0 // Third column\n);\n\n// Originally by Nikos Papadopoulos, 4rknova / 2015\n// Heavily modified by Dr. Sajid Farooq, 2016\n// Credited here for use in the assignment\n// Implement the kernel using the filter and sample functions defined below\nvec3 sample(const int x, const int y, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;\t\n    uv = (uv + vec2(x, y)) / iChannelResolution[0].xy ;\n\treturn texture(iChannel0, uv).xyz;\n}\n\nvec3 filter(in vec2 fragCoord, mat3 kernel)\n{\n\tvec3 sum = sample(-1, -1, fragCoord) * kernel[0][0]\n\t+ sample(-1, 0, fragCoord) * kernel[0][1]\n\t+ sample(-1, 1, fragCoord) * kernel[0][2]\n\t+ sample( 0, -1, fragCoord) * kernel[1][0]\n\t+ sample( 0, 0, fragCoord) * kernel[1][1]\n\t+ sample( 0, 1, fragCoord) * kernel[1][2]\n\t+ sample( 1, -1, fragCoord) * kernel[2][0]\n\t+ sample( 1, 0, fragCoord) * kernel[2][1]\n\t+ sample( 1, 1, fragCoord) * kernel[2][2];\n \n\treturn sum;\n}\n\nfloat CircleRadius = 0.1; // Create a modifiable variable to hold the radius of the circle\n\nfloat filterDecision = 0.0; // Use this variable to change the filter being used for the circle\n\t\t\t\t\t\t  \t// 1 will be the first edge detection, 2 will be the second edge \n\t\t\t\t\t\t\t// detection, and 3 will be the emboss. Any other number will return \n\t\t\t\t\t\t\t// the default, which in this case will be sharpen\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 Layer1;\n \tvec4 Layer2; // Create two variables to hold the blur and sharpen layers\n    \n    vec2 mouseInput = iMouse.xy / iResolution.xy; // Create a variable to hold the mouse input, which\n    \t\t\t\t\t\t\t\t\t\t\t  // is calculated by dividing the location of the\n    \t\t\t\t\t\t\t\t\t\t\t  // mouse by the resolution\n    \n    vec3 blurBG = filter(fragCoord.xy, blur); // Store the blur filter in a variable\n    vec3 filterCircle; // Create a variable to store the chosen filter\n    \n    // Based on the chosen number of the filter, store the matching filter in the filterCircle\n    // variable created above\n    if(filterDecision == 1.0)\n    {\n\t\tfilterCircle = filter(fragCoord.xy, edgeDetection1);\n    }\n    else if(filterDecision == 2.0)\n    {\n\t\tfilterCircle = filter(fragCoord.xy, edgeDetection2);\n    }\n    else if(filterDecision == 3.0)\n    {\n        filterCircle = filter(fragCoord.xy, emboss);\n    }\n    else\n    {\n        filterCircle = filter(fragCoord.xy, sharpen);\n    }\n    \n    Layer1 = vec4(filterCircle, 1.0); // Convert the chosen filter to a vec4 and store it in the \n    \t\t\t\t\t\t\t\t  // first layer\n    Layer2 = vec4(blurBG, 1.0); // Convert the blur filter to a vec4 and store it in the second layer\n    \n    // Correct the current position for the aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Correct the current position of the mouse for the aspect ratio\n    mouseInput.x *= iResolution.x / iResolution.y;\n    \n    // If the current location is within the circle, then convert the alpla of layer2 to 0\n    // This will allow the second layer to overlay the first layer\n    if(length(uv - mouseInput) <= CircleRadius)\n    {\n\t\tLayer2.a = 0.0;\n    }\n \n \t// Blend the two layers together and output it to the screen\n \tvec4 Composite = mix(Layer1, Layer2, Layer2.a);\n \tfragColor = Composite;   \n}","name":"Image","description":"","type":"image"}]}