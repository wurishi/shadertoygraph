{"ver":"0.1","info":{"id":"DdsBWB","date":"1689133440","viewed":139,"name":"Silly Particle System","username":"rafaelbeckel","description":"I was trying to build a simple particle system without a vertex shader. With a vertex shader, I could trivially render millions of particles, but how to do it with a fragment shader only? This method limits us to a few hundred particles, but it works.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * I was trying to build a simple particle system without a vertex shader.\n *\n * With a vertex or compute shader, I could trivially render millions of particles, \n * but how to do it if we're limited to a fragment shader?\n * \n * This method is inneficient, and limits us to a couple hundreds of particles only.\n * It works by storing the particle's position and velocity in a texture (BufferA)\n * then looping through some of the pixels in the texture to find a position that\n * matches our current uv coordinates. It it's a match, we render the particle.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    // Loop over some particles in the texture.\n    for (int p = 0; p < 400; ++p) {\n        vec2 texCoord = vec2(p, p) / iResolution.xy;\n        vec4 data = texture(iChannel0, texCoord);\n        vec2 position = data.xy;\n        vec2 velocity = data.zw;\n        float distance = length(position - uv);\n\n        // If the particle is within range, render it.\n        if (distance < 0.01 - length(velocity)/1.5) {\n            float speed = length(velocity) * 100.;\n            speed = clamp(speed, 0.0, 1.0);\n            \n            vec3 slowColor = vec3(0., 1., 1.); // Cyan\n            vec3 fastColor = vec3(1., 0., 1.); // Purple\n\n            vec3 particleColor = mix(slowColor, fastColor, speed);\n            float brightness = length(velocity) / distance;\n\n            color = particleColor * brightness;\n        }\n    }\n\n    if (length(color) > 0.0) {\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(vec3(0.),1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(.5);\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (iFrame == 0) { // Initialization\n        \n        // Generate a random initial position.\n        vec2 position = vec2(rand(uv), rand(uv - vec2(0.01)));\n\n        // Calculate initial velocity.\n        vec2 direction = center - position;\n        vec2 velocity = normalize(direction) * 0.01;\n\n        // Store the position and velocity in the output color.\n        fragColor = vec4(position, velocity);\n        \n    } else { // Update\n        \n        // Read the current particle data from the texture.\n        vec4 data = texture(iChannel0, uv);\n\n        // The xy components represent the particle's position.\n        // The zw components represent the particle's velocity.\n        vec2 position = data.xy;\n        vec2 velocity = data.zw;\n\n        // Apply a force that attracts the particle to the center of the screen.\n        vec2 direction = center - position;\n        vec2 force = normalize(direction);\n\n        // Update the particle velocity based on the force.\n        velocity += force * 0.0005;\n\n        // Update the particle position based on the velocity.\n        position += velocity;\n\n        // Write the updated particle data back to the texture.\n        fragColor = vec4(position, velocity);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}