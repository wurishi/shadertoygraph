{"ver":"0.1","info":{"id":"DtGfRt","date":"1702354675","viewed":38,"name":"Mirror Ball by Vulpes","username":"Vulpes","description":"just a spherical mirror.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DIFF_MIN .0312\n#define DIFF_MAX .125\n#define ITERATIONS 12\n#define SUBPIXEL_QUALITY .75\n\nfloat quality[7] = float[](1.5, 2., 2., 2., 2., 4., 8.);\n\nfloat getLuma(vec3 rgb){\n    return sqrt(dot(rgb, vec3(0.299, 0.587, 0.114)));\n}\n\nvec4 getTexel(vec2 fragCoord, float x, float y)\n{\n    return texture(iChannel0, vec2((fragCoord.x + x) / iResolution.x, (fragCoord.y + y) / iResolution.y));\n}\n\nvec4 AA(vec2 inverseScreenSize, vec2 inuv)\n{\n    float lumaCenter = getLuma(texture(iChannel0, inuv).rgb);\n    \n    float lumaDown =  getLuma(textureOffset(iChannel0, inuv, ivec2( 0, -1)).rgb);\n    float lumaUp =    getLuma(textureOffset(iChannel0, inuv, ivec2( 0,  1)).rgb);\n    float lumaLeft =  getLuma(textureOffset(iChannel0, inuv, ivec2(-1,  0)).rgb);\n    float lumaRight = getLuma(textureOffset(iChannel0, inuv, ivec2( 1,  0)).rgb);\n    \n    float lumaMin = min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));\n    float lumaMax = max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));\n    \n    float lumaRange = lumaMax - lumaMin;\n    \n    if (lumaRange < max(DIFF_MIN, lumaMax * DIFF_MAX)) return texture(iChannel0, inuv);\n    \n    float lumaDownLeft =  getLuma(textureOffset(iChannel0, inuv, ivec2(-1, -1)).rgb);\n    float lumaUpRight =   getLuma(textureOffset(iChannel0, inuv, ivec2( 1,  1)).rgb);\n    float lumaUpLeft =    getLuma(textureOffset(iChannel0, inuv, ivec2(-1,  1)).rgb);\n    float lumaDownRight = getLuma(textureOffset(iChannel0, inuv, ivec2( 1, -1)).rgb);\n    \n    float lumaDownUp = lumaDown + lumaUp;\n    float lumaLeftRight = lumaLeft + lumaRight;\n    \n    float lumaLeftCorners = lumaDownLeft + lumaUpLeft;\n    float lumaDownCorners = lumaDownLeft + lumaDownRight;\n    float lumaRightCorners = lumaDownRight + lumaUpRight;\n    float lumaUpCorners = lumaUpRight + lumaUpLeft;\n    \n    float edgeHorizontal =  abs(-2.0 * lumaLeft + lumaLeftCorners)  + abs(-2.0 * lumaCenter + lumaDownUp ) * 2.0    + abs(-2.0 * lumaRight + lumaRightCorners);\n    float edgeVertical =    abs(-2.0 * lumaUp + lumaUpCorners)      + abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0  + abs(-2.0 * lumaDown + lumaDownCorners);\n\n    bool isHorizontal = (edgeHorizontal >= edgeVertical);\n    \n    float luma1 = isHorizontal ? lumaDown : lumaLeft;\n    float luma2 = isHorizontal ? lumaUp : lumaRight;\n    \n    float gradient1 = luma1 - lumaCenter;\n    float gradient2 = luma2 - lumaCenter;\n\n    bool is1Steepest = abs(gradient1) >= abs(gradient2);\n\n    float gradientScaled = 0.25*max(abs(gradient1),abs(gradient2));\n    \n    float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;\n\n    float lumaLocalAverage = 0.0;\n\n    if (is1Steepest)\n    {\n        stepLength = - stepLength;\n        lumaLocalAverage = 0.5*(luma1 + lumaCenter);\n    } \n    else \n    {\n        lumaLocalAverage = 0.5*(luma2 + lumaCenter);\n    }\n\n    vec2 currentUv = inuv;\n    if (isHorizontal)\n    {\n        currentUv.y += stepLength * 0.5;\n    }\n    else \n    {\n        currentUv.x += stepLength * 0.5;\n    }\n    \n    vec2 offset = isHorizontal ? vec2(inverseScreenSize.x,0.0) : vec2(0.0,inverseScreenSize.y);\n    \n    vec2 uv1 = currentUv - offset;\n    vec2 uv2 = currentUv + offset;\n\n    float lumaEnd1 = getLuma(texture(iChannel0, uv1).rgb);\n    float lumaEnd2 = getLuma(texture(iChannel0, uv2).rgb);\n    lumaEnd1 -= lumaLocalAverage;\n    lumaEnd2 -= lumaLocalAverage;\n\n    bool reached1 = abs(lumaEnd1) >= gradientScaled;\n    bool reached2 = abs(lumaEnd2) >= gradientScaled;\n    bool reachedBoth = reached1 && reached2;\n\n    if (!reached1)\n    {\n        uv1 -= offset;\n    }\n    if (!reached2)\n    {\n        uv2 += offset;\n    }\n    \n    if (!reachedBoth)\n    {\n\n        for (int i = 2; i < ITERATIONS; i++) {\n            if (!reached1) \n            {\n                lumaEnd1 = getLuma(texture(iChannel0, uv1).rgb);\n                lumaEnd1 = lumaEnd1 - lumaLocalAverage;\n            }\n            \n            if (!reached2) \n            {\n                lumaEnd2 = getLuma(texture(iChannel0, uv2).rgb);\n                lumaEnd2 = lumaEnd2 - lumaLocalAverage;\n            }\n            \n            reached1 = abs(lumaEnd1) >= gradientScaled;\n            reached2 = abs(lumaEnd2) >= gradientScaled;\n            reachedBoth = reached1 && reached2;\n\n            if (!reached1)\n            {\n                uv1 -= offset * quality[i];\n            }\n            if (!reached2)\n            {\n                uv2 += offset * quality[i];\n            }\n\n            if(reachedBoth) break;\n        }\n    }\n    \n    float distance1 = isHorizontal ? (inuv.x - uv1.x) : (inuv.y - uv1.y);\n    float distance2 = isHorizontal ? (uv2.x - inuv.x) : (uv2.y - inuv.y);\n\n    bool isDirection1 = distance1 < distance2;\n    float distanceFinal = min(distance1, distance2);\n\n    float edgeThickness = (distance1 + distance2);\n\n    float pixelOffset = - distanceFinal / edgeThickness + 0.5;\n    \n    bool isLumaCenterSmaller = lumaCenter < lumaLocalAverage;\n\n    bool correctVariation = ((isDirection1 ? lumaEnd1 : lumaEnd2) < 0.0) != isLumaCenterSmaller;\n\n    float finalOffset = correctVariation ? pixelOffset : 0.0;\n    \n    float lumaAverage = (1.0/12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);\n    \n    float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter)/lumaRange, 0.0, 1.0);\n    float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;\n    \n    float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;\n\n    finalOffset = max(finalOffset, subPixelOffsetFinal);\n    \n    vec2 finalUv = inuv;\n    if (isHorizontal)\n    {\n        finalUv.y += finalOffset * stepLength;\n    } \n    else \n    {\n        finalUv.x += finalOffset * stepLength;\n    }\n    \n    return texture(iChannel0, finalUv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 col = AA(1. / iResolution.xy, uv);\n    \n    fragColor = vec4(col.rgb,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 400\n#define MAX_DIST 250.\n#define SURFACE_DIST .001\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat getDist(vec3 p)\n{\n    vec4 sphere = vec4(0, 1, 0, 1);\n    \n    float distSphere = length(p-sphere.xyz)-sphere.w;\n    float distFloor = p.y;\n    \n    return min(distFloor, distSphere);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float dist = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dist - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx)\n    );\n    \n    return normalize(normal);\n}\n\n\nvec2 rayMarch(vec3 begin, vec3 direction)\n{\n    float dist0 = 0.005;\n    int j = 0;\n    \n    for (int i = 0; i < MAX_STEPS; i++, j++)\n    {\n        vec3 p = begin + dist0 * direction;\n        float distS = getDist(p);\n        dist0 += distS;\n        if (distS < SURFACE_DIST) return vec2(dist0, 0.);\n        if (dist0 > MAX_DIST) return vec2(dist0, -1.);\n    }\n    \n    return vec2(-1., -1.);\n}\n\nfloat getFog(float dist)\n{\n    float fog_factor = (30. - dist) / (30. - 10.);\n    return clamp(fog_factor, 0., 1.);\n}\n\nfloat getLight(vec3 p, float dist)\n{\n    vec3 lightPos = vec3(0, 5, 6);\n    vec3 light = normalize(lightPos-p);\n    vec3 normal = getNormal(p);\n    \n    float dif = clamp(dot(normal, light), 0., 1.);\n    float distL = rayMarch(p + normal*SURFACE_DIST*2., light).x;\n    \n    if (p.y < .01 && (fract(p.x) > .5 ^^ fract(p.z) > .5)) dif *= .5;\n    \n    if(distL < length(lightPos - p))\n    {\n        dif *= 0.05;\n    }\n    \n    dif = mix(.3, dif, getFog(dist));\n    \n    return dif;\n}\n\nfloat getShading(vec3 p, vec3 v)\n{\n    vec3 normal = getNormal(p);\n    vec3 direct = reflect(v, normal);\n    vec2 r = rayMarch(p + normal*SURFACE_DIST*1.005, direct);\n    if (r.y < 0.) return -1.;\n    float dist = r.x;\n    vec3 p2 = p + direct * dist;\n    float dif = getLight(p2, 4. * dist) * .25;\n    \n    return dif;\n}\n\nfloat getPixel(float px, float py)\n{\n    vec3 begin = vec3(sin(iTime)*4., 2.*sin(iTime) + 2.5, cos(iTime)*4.);\n    \n    vec3 direction = normalize(vec3(px, py, 1));\n    direction = direction * rotateX((begin.y - 1.) / distance(begin, vec3(0., 1., 0.))) * rotateY(atan(-begin.z, begin.x) + 3.5 * 3.1415);\n    \n    vec3 col;\n    \n    vec2 r = rayMarch(begin, direction);\n    float dist = r.x;\n    if (r.y < 0.) return -1.;\n    vec3 p = begin + direction * dist;\n    float dif = getLight(p, dist);\n    \n    if (p.y > .01)\n    {\n        dif = getShading(p, direction);\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = getPixel(uv.x, uv.y);\n    vec3 col;\n    \n    if (t < 0.)\n    {\n        col = vec3(0);\n    }\n    else\n    {\n        col = vec3(t);\n        col = pow(col, vec3(.4545));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}