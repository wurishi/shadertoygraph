{"ver":"0.1","info":{"id":"wtlGDX","date":"1696721450","viewed":118,"name":"sparkling night","username":"BynaryCobweb","description":"This is a shader I made some time ago, the sea could be improved and some clouds added, maybe I'll continue it someday","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sea","moon","night"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define STEP 100\n#define EPS (2.0/iResolution.x)\n#define FAR 6.0\n#define SQRT2 1.41421\n#define INV_SQRT2 0.70710\n\n// LIB\n\nfloat rand(vec2 uv) {\n    return texture(iChannel0, uv/256.0, -100.0).r;\n}\n\nfloat noise(in vec2 uv) {\n    vec2 f = fract(uv);\n    vec2 i = floor(uv);\n    \n    float a = rand(i);\n    float b = rand(i + vec2(0.0, 1.0));\n    float c = rand(i + vec2(1.0, 0.0));\n    float d = rand(i + vec2(1.0, 1.0));\n    \n    vec2 u = -2. * f * f * f + 3. * f * f;\n    return mix(mix(a, b, u.y), mix(c, d, u.y), u.x);\n}\n\n// gradient of noise\nvec2 gnoise(in vec2 uv) {\n    vec2 f = fract(uv);\n    vec2 i = floor(uv);\n    \n    float a = rand(i);\n    float b = rand(i + vec2(0.0, 1.0));\n    float c = rand(i + vec2(1.0, 0.0));\n    float d = rand(i + vec2(1.0, 1.0));\n    \n    vec2 u = -2. * f * f * f + 3. * f * f;\n    vec2 du = -6. * f * f + 6. * f;\n   \n    float m = a - b - c + d;\n    \n    return vec2(\n        m * du.x * u.y + (c - a) * du.x,\n        m * u.x * du.y + (b - a) * du.y\n    );\n}\n\nfloat fbm(in vec2 uv) {\n    float sum = 0.0;\n    float amp = 0.0;\n    float persistence = 0.7;\n    vec2 st = uv;\n    \n    for (int i = 0; i < 8; ++i) {\n        amp = amp / persistence + noise(st);\n        sum = sum / persistence + 1.;\n        st *= 2.;\n    }\n    return amp / sum;\n}\n\nfloat afbm(in vec2 uv) {\n    float sum = 0.0;\n    float amp = 0.0;\n    float persistence = 0.7;\n    vec2 st = uv;\n    \n    for (int i = 0; i < 8; ++i) {\n        amp = amp / persistence + abs(-1. + 2. * noise(st));\n        sum = sum / persistence + 1.;\n        st *= 2.;\n    }\n    return amp / sum;\n}\n\n// gradient afbm\nvec2 gafbm(in vec2 uv) {\n    float sum = 0.0;\n    vec2 amp = vec2(0.0);\n    float persistence = 0.7;\n    vec2 st = uv;\n    \n    for (int i = 0; i < 8; ++i) {\n        float s = sign(-1. + 2. * noise(st));\n        amp = amp / persistence + s * 2. * gnoise(st);\n        sum = sum / persistence + 1.;\n        st *= 2.;\n    }\n    return amp / sum;\n}\n\n// UTILS\n\nfloat middle() {\n    return iResolution.x / iResolution.y / 2.;\n}\n\n\n// RENDER\n\nvec3 sky(in vec2 uv, in vec3 color) {\n    float blue = (1. - uv.y) * 0.25 + 0.15;\n    float red = (1. - uv.y);\n    red = red * red * 0.4;\n    \n    return vec3(red, 0.1, blue);\n}\n\nvec3 stars(in vec2 uv, in vec3 color) {\n    float a = rand(uv * 256.);\n    a *= uv.y * 0.2 + 0.8;\n    // glowing\n    a += 0.02 * sin(iTime * rand(uv * -12.) + rand(uv * 300.));\n    float v = smoothstep(0.8, 0.95, a);\n    // v *= uv.y * 0.3 + 0.1;\n    vec3 col = mix(color, vec3(1.), v);\n    return col;\n}\n\nvec3 moonBaseColor = vec3(0.9, 0.92, 0.97);\nvec2 moonCenter = vec2(0.28, 0.75);\nfloat moonRadius = 0.15;\n            \nvec3 moon(in vec2 uv, in vec3 color) {\n    vec3 moonColor = moonBaseColor;\n    moonColor.xyz *= 0.5 + fbm(uv*3.0) * 0.7;\n    \n    float dist = distance(moonCenter, uv);\n    float v = smoothstep(moonRadius + 0.006, moonRadius - 0.006, dist);\n    float halo = smoothstep(moonRadius + 0.8, moonRadius - 0.05, dist) * 0.3;\n    vec3 col = mix(color, moonColor, max(v, halo));\n    return col;\n}\n\nvec3 clouds(in vec2 uv, in vec3 color) {\n    return color;\n}\n\nfloat seaSDF(in vec3 p) {\n    vec2 warp = p.xy + 0.4 * noise(p.xy * 10. + 89.);\n    // slow\n    vec2 pos = warp + vec2(iTime * 0.05);\n    // fast\n    vec2 pos2 = warp + vec2(iTime * 0.13);\n    return p.z - (2. - afbm(pos) - afbm(pos2)) * 0.25;\n    // return distance(vec3(0, 0, 1), p) - 1.;\n}\n\nvec2 seaGrad(in vec3 p) {\n    vec2 warp = p.xy + 0.4 * noise(p.xy * 10. + 89.);\n    vec2 gwarp = vec2(1.) + 0.4 * gnoise(p.xy * 10. + 89.);\n    vec2 pos = warp + vec2(iTime * 0.005);\n    vec2 pos2 = warp + vec2(iTime * 0.13);\n    return gwarp * (gafbm(pos) + gafbm(pos2) * 0.25);\n}\n\nvec3 seaNorm(in vec3 p) {\n    vec2 grad = seaGrad(p);\n    float sl = grad.x * grad.x + grad.y * grad.y;\n    return vec3(grad, sqrt(1. - sl));\n    // return normalize(p - vec3(0, 0, 1));\n}\n\nfloat raymarchSea(in vec3 ro, in vec3 rd) {\n    float t = 0.;\n    float d;\n    \n    for (int i = 0; i < STEP; i++) {\n        d = seaSDF(ro + t * rd);\n        if (d < EPS*t || t > FAR) {\n            break;\n        }\n        t += d;\n    }\n    return d < EPS*t ? t : -1.;\n}\n\nvec3 seaDiffuse = vec3(0.07, 0.6, 0.85);\nvec3 seaSpecular = vec3(0.8, 0.95, 1.0);\nvec3 lightSource = vec3(-1., -1., 1.);\n\nvec4 shadeSea(in vec3 ro, in vec3 rd, float t) {\n    vec3 p = ro + rd * t;\n    float dist = length(ro - p);\n    vec3 n = seaNorm(p);\n    \n    // lighting\n    float diffuse = max(0., dot(n, normalize(lightSource)));\n    float specular = pow(diffuse, 20.);\n    vec4 col = vec4(seaDiffuse * diffuse + seaSpecular * specular, 0.5 + specular);\n    \n    // distance to camera\n    float darken = 1. / pow(max(dist - 2., 1.), 2.);\n    col.xyz *= darken;\n    col.w *= mix(darken, 1., 0.4);\n    \n    // star reflection\n    col += vec4(stars(-p.xy/5., vec3(0.)), 0.);\n    \n    // sky reflection\n    col.xyz += darken / 1.5 * sky(-p.xy/20., vec3(0.));\n    \n    return col;\n}\n\nvec3 camPos = vec3(0., -5., 1.);\nvec3 camDir = vec3(0, 1, -0.00);\n// no units, just tweak the value as needed\nfloat fov = 1.;\n\nvec3 sea(in vec2 uv, in vec3 color) {\n    vec3 rd = normalize(camDir + vec3(uv.x - middle(), 0.0, uv.y - 0.5) * fov);\n    float d = raymarchSea(camPos, rd);\n    vec4 seaColor = shadeSea(camPos, rd, d);\n    return d < 0. ? color : mix(color, seaColor.xyz, seaColor.w);\n    // return mix(seaBaseColor, color, min(1., 1. / (d*d)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n\n    vec3 color = vec3(1.);\n    \n    color = sky(uv, color);\n    color = stars(uv, color);\n    color = moon(uv, color);\n    color = clouds(uv, color);\n    color = sea(uv, color);\n    \n    // color = vec4(vec3(fbm2(uv)), 1.0);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}