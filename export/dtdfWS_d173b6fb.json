{"ver":"0.1","info":{"id":"dtdfWS","date":"1701606717","viewed":154,"name":"Pixel-Art Procedural Planets","username":"AkiAoki","description":"Use your mouse click to generate a random planet based on your pointer position!\n\nWanted to make a cute procedural pixel-art planet generation. That's the result. :) ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["procedural","pixel","planet","planets","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int PRES_Y = 100;\n//const int SEED = 60;\n//#define SEED round(iTime * 0.25)\n#define SEED round(iMouse.x * 100.0 * iMouse.y)\nconst float CAM_ROTATION_SPEED = 0.3;\nconst float CAM_DISTANCE = 15.0;\nconst float PLANET_RADIUS = 4.6;\n\n#define DRAW_CLOUDS 1\n\n// (source: https://www.shadertoy.com/view/4djSRW)\nvec3 hash_(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// (source: https://www.shadertoy.com/view/4djSRW)\nvec3 hash_q( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p += vec3(float(SEED) * 0.01);\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// returns 3D value noise (source: https://iquilezles.org/articles/gradientnoise/)\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm3(in vec3 pos, in float lac, in float pers)\n{\n    float sum = 0.0;\n    float ampl = 1.0;\n    float freq = 1.0;\n    float maxAmpl = 0.0;\n    for (int i = 0; i < 3; i++)\n    {\n        sum += noise(pos * freq) * ampl;\n        maxAmpl += ampl;\n        ampl *= pers;\n        freq *= lac;\n    }\n    \n    return sum / maxAmpl;\n}\n\nfloat fbm5(in vec3 pos, in float lac, in float pers)\n{\n    float sum = 0.0;\n    float ampl = 1.0;\n    float freq = 1.0;\n    float maxAmpl = 0.0;\n    for (int i = 0; i < 5; i++)\n    {\n        sum += noise(pos * freq) * ampl;\n        maxAmpl += ampl;\n        ampl *= pers;\n        freq *= lac;\n        pos += vec3(31.1051, 71.0214, 49.4195);\n    }\n    \n    return sum / maxAmpl;\n}\n\nfloat celShade(float value, float steps)\n{\n    return round(value * steps) / steps;\n}\n\nvec2 raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) \n{\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n\tfloat disc = b * b - 4.0 * a* c;\n    if (disc < 0.0) {\n        return vec2(-1.0, -1.0);\n    }else{\n\t\treturn vec2(-b - sqrt(disc), -b + sqrt(disc)) / (2.0 * a);\n\t}\n}\n\nfloat getHeight(in vec3 pos)\n{\n    float p1 = 0.03 + hash(vec3(124)) * 1.0;\n    float p2 = hash(vec3(125)) * 0.5 - 0.25;\n    float p3 = hash(vec3(126)) * 0.3 - 0.15;\n    float p4 = hash(vec3(131)) * 4.0;\n    float height = 0.0;\n    float domain = fbm3(pos * 0.2, 1.8 + p2, 0.8 + p3); // apply domain warp\n    height += fbm5(pos * p1 + domain * vec3(1.0 + p4), 1.8, 0.8);\n    return height;\n}\n\nvec3 getHeightColor(float height, vec3 viewDir, vec3 R)\n{\n    vec3 sunColor = vec3(0.9, 0.8, 0.5);\n    float oceanLevel = 0.2 + hash(vec3(123)) * 0.6;\n    float snowLevel = 0.92;\n    vec3 result;\n    if (height < oceanLevel)\n    {\n        vec3 c = vec3(hash(vec3(207.0)), hash(vec3(208.0)), hash(vec3(209.0)));\n        //result = vec3(0.4, 0.6, 0.96);\n        result = c;\n        float specular = pow(1.0 - clamp(dot(R, viewDir) + 1.0, 0.0, 1.0), 2.0);\n        specular = celShade(specular, 3.0);\n        //result += sunColor * vec3(0.8 * specular);\n    }\n    else if (height > snowLevel)\n    {\n        result = vec3(1.0, 1.0, 1.0);\n    }\n    else\n    {\n        vec3 a = vec3(hash(vec3(201.0)), hash(vec3(202.0)), hash(vec3(203.0)));\n        vec3 b = vec3(hash(vec3(204.0)), hash(vec3(205.0)), hash(vec3(206.0)));\n        //result = mix(vec3(0.4, 0.8, 0.5), vec3(0.08, 0.33, 0.13) * 0.3, celShade(1.0-height, 8.0));\n        result = mix(a, b, celShade(1.0-height, 8.0));\n    }\n    return result;\n}\n\nvec3 drawClouds(in vec3 color, in vec3 pos)\n{\n    float p1 = hash(vec3(127)) * 3.0 - 1.5;\n    float p2 = hash(vec3(128)) * 0.15 - 0.075;\n    float p3 = hash(vec3(129)) * 0.2 - 0.1;\n    float p4 = hash(vec3(130)) * 0.5;\n    float clmp = 0.3 + p4;\n    vec3 mPos = pos;\n    mPos.y *= 3.0 + p1;\n    float cH = fbm5(mPos * (0.14 + p3) + 5187.231 + iTime * (0.1 + p2), 1.6, 0.9);\n    cH = mod(cH * 4.0, 1.0); // To make more circle-shaped clouds\n    \n    if (cH > clmp)\n    {\n        float nch = (cH - clmp) / (1.0 - clmp);\n        if (nch > 0.1)\n        {\n            color = vec3(0.95);\n        }\n        else\n        {\n            color = vec3(0.8, 0.8, 0.9);\n        }\n    }\n    else if (clmp - cH < 0.03)\n    {\n        color *= 0.8; // kind of shadow. ToDo better\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sAspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int PRES_X = int(float(PRES_Y) * sAspect);\n    \n    ivec2 iuv = ivec2(uv * vec2(PRES_X, PRES_Y));\n    uv.x = floor(uv.x * float(PRES_X)) / float(PRES_X);\n    uv.y = floor(uv.y * float(PRES_Y)) / float(PRES_Y);\n    \n    vec3 camPos = vec3(0, 0, -15);\n    camPos = vec3(sin(iTime * CAM_ROTATION_SPEED) * CAM_DISTANCE, 0.0, cos(iTime * CAM_ROTATION_SPEED) * CAM_DISTANCE);\n    camPos.y = sin(iTime * CAM_ROTATION_SPEED) * 5.0;\n    \n    vec3 sphPos = vec3(0, 0, 0);\n    vec3 lightDir = normalize(vec3(1, -1, 2));\n    float pR = PLANET_RADIUS;\n    \n    mat4x4 viewMat;\n    viewMat[2] = vec4(normalize(sphPos - camPos), 0.0);\n    viewMat[0] = vec4(cross(viewMat[2].xyz, vec3(0, 1, 0)), 0.0);\n    viewMat[1] = vec4(cross(viewMat[0].xyz, viewMat[2].xyz), 0.0);\n    viewMat[3] = vec4(0, 0, 0, 1);\n    \n    viewMat[3] = vec4((viewMat * vec4(camPos, 0.0)).xyz, 1.0);\n    \n    mat4x4 viewMatInv = inverse(viewMat);\n    lightDir = (viewMat * vec4(lightDir, 0.0)).xyz;\n    \n    vec3 rayDir = normalize(vec3((uv.x - 0.5) * sAspect, (uv.y - 0.5), 1.4));\n    rayDir = (viewMat * vec4(rayDir, 0.0)).xyz;\n    \n    \n    vec2 sphIDs = raySphereIntersect(camPos, rayDir, sphPos, pR);\n    float sphID = min(sphIDs.x, sphIDs.y);\n    \n    vec3 sphI = camPos + rayDir * sphID;\n    \n    vec3 sphN = normalize(sphI - sphPos);\n    \n    \n    float nDotL = dot(lightDir, sphN);\n    float lum = celShade(1.0 - (nDotL + 1.0) * 0.5, 4.0);\n    //lum = lum * 2.0 - 1.0;\n    lum = lum * 0.5 + 0.5;\n    lum = clamp(lum, 0.0, 1.0);\n    \n    //fragColor = vec4(fbm5(vec3(uv.x, uv.y, 0.0) * 15.0, 2.3, 0.8));\n    //return;\n    \n    if (sphID < 0.0)\n    {\n        // Draw background\n        //fragColor = vec4(hash(vec3(uv.x, uv.y, 0.0)), 0);\n        float sHash = hash(vec3(iuv.x, iuv.y, 0.0));\n        if (sHash < 0.04)\n        {\n            fragColor = vec4(1.0 * sin(sHash * 3295.201 + iTime * 0.4));\n        }\n        else\n        {\n            fragColor = vec4(0);\n        }\n        \n    }\n    else\n    {\n        // Draw planet\n        float height = getHeight(sphI);\n        vec3 heightColor = getHeightColor(height, lightDir, reflect(rayDir, sphN)) * lum;\n        #if DRAW_CLOUDS\n        heightColor = drawClouds(heightColor, sphI);\n        #endif\n        fragColor = vec4(heightColor, 1.0);\n        //fragColor = vec4(sphI.x / 5.0, sphI.y / 5.0, -sphI.z / 5.0, 1.0);\n        //fragColor = -vec4(sphI.z / 5.0);\n    }\n    \n    //fragColor = 2.0 * fragColor / (fragColor + 1.0);\n}","name":"Image","description":"","type":"image"}]}