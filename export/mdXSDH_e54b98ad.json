{"ver":"0.1","info":{"id":"mdXSDH","date":"1669046445","viewed":103,"name":"Eikonal FIM 1D","username":"spalmer","description":"Please read the comments on the Image tab for explanation.\nThis lets you view iteravely refined SDF w/ diff. isolevel thresholds.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["sdf","visualizer","1d","graph","eikonal"],"hasliked":0,"parentid":"cdlXWr","parentname":"1D Fuzzy SDF Visualization 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hatchling is trying to teach me something\n// and I'm trying to show how\n// my iterative method http://shadertoy.com/view/7dGSz3\n// relates to theirs http://shadertoy.com/view/cdlXWr\n\n// - The shader is intended to be used mostly while unpaused.\n// - Each reset of toy, the test function will evolve.\n//   (1-D perlin noise).\n// - This isn't optimized, the search function is iterative,\n//   and tuned to be slow.\n\n// 1. Click and drag your mouse to view the SDF produced at different boundary\n//    thresholds. Top = 1, Bottom = 0.\n// 2. Reset toy and watch it build the SDF.\n\n// Legend:\n//    Orange curve : Arbitrary function to turn into an SDF.\n//      Blue curve : The resulting SDF.\n//  Red background : The SDF has a positive gradient at this X coordinate.\n// Cyan background : The SDF has a negative gradient at this X coordinate.\n//   Light/dark bg : The SDF is poitive/negative at this X coordinate.\n// Horizontal Line : The isolevel threshold delininating inside from outside.\n\n// Controls:\n//       Pause : Prevent the blue function from evolving.\n//       Reset : Generate new orange functions.\n// Mouse Click : Change the SDF's boundary level\n\n// How to Interpret the Visualization:\n// * Orange line:\n//     - The noisy input function.\n//     - Where the orange line crosses the white line,\n//       we have an isocontour.\n// * Blue line:\n//     - The signed distance from X coordinate\n//       to the closest point on the orange line\n//       that crosses the probability threshold.\n//     - Where the blue line crosses the white line,\n//       the signed distance is 0.\n// * Horizontal white line:\n//     - Shows the isolevel, where orange is considered zero.\n//     - Can be controlled with the mouse.\n//     - All blue points along the line are 0.\n// * Red/Cyan tinted regions:\n//     - Shows the gradient of the SDF.\n//     - Notice that the gradient changes in the center\n//       between two points where the orange line\n//       and the horizontal white line intersect.\n\nfloat graph(float graphHeight, float graphGradient, float fragHeight)\n{\n    float range = (1. + abs(graphGradient)) * 2.,\n      upper = graphHeight + range,\n      lower = graphHeight - range,\n      value = (fragHeight - lower) / (upper - lower);\n    value = 1. - (abs(value - .5) * 2.);\n    return clamp(value, 0., 1.); \n}  \n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    float mouseY = iMouse.y < 0.5 ? r.y * 0.5 : iMouse.y; \n    \n    float horzLine = graph(mouseY, 0., p.y);\n\n    float orangeLine;\n    {\n        float orangeLineH = textureLod(iChannel1, vec2(p.x / r.x, 0), 0.).w * r.y; \n        orangeLine = graph(orangeLineH, dFdx(orangeLineH), p.y);\n    }\n    \n    float blueGrad, blueLine;\n    {        \n        float blueLineH = textureLod(iChannel0, vec2(p.x / r.x, 0), 0.).w;\n        blueLineH -= 0.5;\n        blueLineH *= r.y;\n        blueLineH += mouseY;\n        blueGrad = dFdx(blueLineH);\n        blueLine = graph(blueLineH, blueGrad, p.y);\n    }\n\n    vec3 c = vec3(0);\n    c = mix(c, blueGrad > 0. ? vec3(1, 0, 0) : vec3(0, 1, 1), .2);    \n    c = mix(c, vec3(1), horzLine);\n    c = mix(c, vec3(1, .7, .3), orangeLine);\n    c = mix(c, vec3(.3, .7, 1), blueLine);\n    o = vec4(c,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Noise function to display.\n// FIXME something is breaking the previews, probably bluenoise texture not fully loaded...\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    // Only process the first row of pixels.\n    if (p.y > .5)\n        discard;\n    \n    vec2 r = iResolution.xy;\n    if (iFrame >= 1 && iChannelResolution[1].x > 0.) {\n        o = textureLod(iChannel0, p / r, 0.);\n        return;\n    }\n    \n    vec2 q = p / r;\n    q.x += fract(15.*iDate.w); // different pattern with each reset of toy\n\n    vec2 n = vec2(0);\n    \n    // 1-D perlin noise.\n    const int maxLayer = 5;\n    for (int i = 2; i < maxLayer; ++i) {\n        vec2 uv = q;\n        // Randomize offset per layer.\n        float uvOffset = float(i) * 1.618;\n        uvOffset -= floor(uvOffset);\n\n        // Get weighted sample with varying scale.\n        float weightScale = float(1 << i);\n        float uvScale = 1.0 / weightScale;\n//        uv.y += iTime * 0.05;  // frozen so that can leave toy unpaused so can see my iterative method working\n        uv *= uvScale;\n        uv += vec2(uvOffset);\n        vec4 t = texture(iChannel1, uv * uvScale);\n        t.w = 1.;\n        t *= weightScale;\n\n        n += t.xw;\n    }\n    n.x += sin(q.x * 7.); // in case no texture loaded\n    // idk why we must bias so\n    o = 2. * n.x/n.y - vec4(.5);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Computes the sdf of BufferA.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 intFragCoord = ivec2(fragCoord);\n    \n    if (fragCoord.y > .5)\n        discard;\n    \n    float mouseY = iMouse.y < 0.5 ? iResolution.y * 0.5 : iMouse.y; \n    \n #if 1\n    // my method from Eikonal FIM at http://shadertoy.com/view/7dGSz3\n    // really had to work on it though!  still needs cleaned up.\n  #define U(q) (textureLod(iChannel0, vec2(q,0)/r, 0.).w * 2. - 1.)\n  #define T(q) (textureLod(iChannel1, vec2(q,0)/r, 0.).w * 2. - 1.)\n    vec2 p = fragCoord,\n       r = iResolution.xy;\n    float m = mouseY / r.y;\n    m *= 2.;\n    m -= 1.;\n    float d;\n    if (iFrame < 1) {\n        d = U(p.x);\n        d -= m;\n        // can start with garbage\n        //float s = .06 * (iTime - 20. * p.x / r.x); //(sin(12. * s) * .14 + .5) * r.y - p.y; // squiggles\n    } else {\n        //const float clip = .0008;\n        d = T(p.x); // old value\n        //if (abs(d) > clip) { // don't mess w data near surface\n            // Eikonal field straightening\n            // compute local gradient\n            float d2 = T(p.x + 1.),\n                  d0 = T(p.x - 1.);\n            float g = (d2 - d0) * .5;\n            float gsq = g * g;\n            float gsqthresh = 1e-9/r.y;\n            // near ridges, where gradient length != 1 / non-eikonal field zones, busted derivative areas, gsq will be < 1\n            //if (gsq < gsqthresh) {\n                //d *= 1.01; //.99; // busted gradients\n            //} else {\n                float dsgn = sign(d);\n                //gsq += 1e-7; // avoid divide zero\n                // sample point precisely 1 unit away in the direction indicated by gunit; we should be about 1 unit from that.\n                float q = p.x - sign(g) * dsgn; // * inversesqrt(gsq) * g;\n                float stretch = 1.125 * .5 / r.y;\n                float nd = T(q) \n                    + dsgn * stretch;\n                if (nd * dsgn > 0.) // on same side still?\n                    d = nd;\n                else\n                    d = 0.;\n            //}\n            float avg = (d0 + d2)*.5;\n            d = clamp(d, avg-.003, avg+.003);\n        //}\n    }\n    float dist = d * .5 + .5;\n  #undef T\n  #undef U\n #else\n    // kept Hatchling's method so can switch back & forth to compare\n    // The X center of \"my\" pixel (the current one being drawn).\n    float myCenter = fragCoord.x; //float(intFragCoord.x) + 0.5;\n    float myHeight = texelFetch(iChannel0, ivec2(fragCoord.x, 0), 0).r;\n    \n    float dither = mouseY / iResolution.y;\n    vec4 thresh = (vec4(dither));\n    float maxDist = iResolution.x;\n    vec4 dist = vec4(maxDist);\n    bvec4 mySign = greaterThan(vec4(myHeight), thresh);\n\n    ivec2 intResolution = ivec2(iResolution.xy);\n    for (int iNeighbor = 0; iNeighbor < intResolution.x; iNeighbor++) {\n        // This doesn't work for some reasosn.\n        /*int neighborX = (iNeighbor / 2) + 1;\n        if((iNeighbor % 2) == 0)\n            neighborX = -neighborX;\n            \n        neighborX += intFragCoord.x;\n        \n        if(neighborX > intResolution.x-1) neighborX = intResolution.x-1;\n        if(neighborX < 0) neighborX = 0;*/\n        \n        // Can't break early, I guess. Brute force it is. -shrug-\n        int neighborX = iNeighbor;\n            \n        // The X center of the neighbor pixel.\n        float neighborCenter = float(neighborX) + 0.5;\n        float neighborNearestEdge = neighborCenter + sign(myCenter - neighborCenter) * 0.5;\n\n        float distMeToNeighbor = abs(myCenter - neighborNearestEdge);\n\n        float neighborHeight = texelFetch(iChannel0, ivec2(neighborX, 0), 0).r;\n\n\n        bvec4 neighborSign = greaterThan(vec4(neighborHeight), thresh);\n\n        bvec4 signEquals = equal(mySign, neighborSign);\n        bvec4 neighborFurther = greaterThanEqual(vec4(distMeToNeighbor), dist);\n        \n        dist.x = signEquals.x || neighborFurther.x ? dist.x : distMeToNeighbor;\n        dist.y = signEquals.y || neighborFurther.y ? dist.y : distMeToNeighbor;\n        dist.z = signEquals.z || neighborFurther.z ? dist.z : distMeToNeighbor;\n        dist.w = signEquals.w || neighborFurther.w ? dist.w : distMeToNeighbor;\n    }\n    dist *= vec4(mySign) * 2.0 - vec4(1.0);\n    dist /= vec4(maxDist);\n    dist = dist * 0.5 + 0.5;\n #endif\n    // TODO let's try Jump Flood!\n    fragColor = vec4(dist);\n}","name":"Buffer B","description":"","type":"buffer"}]}