{"ver":"0.1","info":{"id":"lc23zV","date":"1704721690","viewed":102,"name":" a SDF sphere","username":"Leabemo","description":"3D","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 相机FOV\n#define FOV  90.\n\n// 球体的球心位置\n#define SPHERE_POS vec3(0, 0, -2)\n\n// 球体的半径\n#define SPHERE_R 1.0\n\n// 球体的漫反射系数\n#define SPHERE_KD vec3(1)\n\n// 相机视点位\n#define CAMERA_POS vec3(0, 0, 2)\n\n// 光线推进的起始距离\n#define RAYMARCH_NEAR 0.1\n\n// 光线推进的最远距离\n#define RAYMARCH_FAR 128.\n\n// 光线推进次数\n#define RAYMARCH_TIME 20\n\n// 当推进后的点位距离物体表面小于RAYMARCH_PRECISION时，默认此点为物体表面的点\n#define RAYMARCH_PRECISION 0.001\n\n// 光源位置\n#define LightPos vec3(1, 2, 2)\n\n// 抗锯齿数量\n#define AA 4\n\n// 计算光线方向向量\nvec3 rayDirection(vec2 fragCoord) {\n    vec2 size = iResolution.xy;\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(FOV) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// 球体的SDF模型\nfloat SDFSphere(vec3 coord) {\n  return length(coord - SPHERE_POS) - SPHERE_R;\n}\n\n// 计算球体的法线  数学推导：https://iquilezles.org/articles/normalsSDF/\nvec3 SDFNormal(in vec3 p) {\n  const float h = 0.0001;\n  const vec2 k = vec2(1, -1);\n  return normalize(k.xyy * SDFSphere(p + k.xyy * h) +\n    k.yyx * SDFSphere(p + k.yyx * h) +\n    k.yxy * SDFSphere(p + k.yxy * h) +\n    k.xxx * SDFSphere(p + k.xxx * h));\n}\n\n// 增加光源\nvec3 AddLight(in vec3 p){\n    // 旋转灯光位置\n    vec3 Lpos = LightPos + vec3(sin(iTime),0.,cos(iTime))*5.;\n    // 计算光照\n    vec3 l = normalize(Lpos - p);\n    vec3 n = SDFNormal(p);\n    float diffuse = dot(n,l);\n    vec3 amb = vec3(0,0,0);\n    return vec3(diffuse) + amb;\n}\n\n// 光线步进\nvec3 RayMarch(vec2 coord,vec3 bg) {\n  float d = RAYMARCH_NEAR;\n  // 从相机视点到当前片元的射线\n  vec3 rd = rayDirection(coord);\n  // 片元颜色\n  vec3 color = vec3(0);\n  for(int i = 0; i < RAYMARCH_TIME && d < RAYMARCH_FAR; i++) {\n    // 光线推进后的点位\n    vec3 p = CAMERA_POS + d * rd;\n    // 光线推进后的点位到球体的有向距离\n    float curD = SDFSphere(p);\n    // 若有向距离小于一定的精度，默认此点在球体表面\n    if(curD < RAYMARCH_PRECISION) {\n      color = AddLight(p);\n      break;\n    }\n    else{\n      color = bg;\n    }\n    // 距离累加\n    d += curD;\n  }\n  return color;\n}\n// 平均抗锯齿\nvec3 RayMarch_anti(vec2 fragCoord,vec3 bg) {\n  // 初始颜色\n  vec3 color = vec3(0.);\n  // 行列的一半\n  float aa2 = float(AA / 2);\n  // 逐行列变了\n  for(int y = 0; y < AA; y++) {\n    for(int x = 0; x < AA; x++) {\n      // 基于像素的偏移距离\n      vec2 offset = vec2(float(x), float(y)) / float(AA) - aa2;\n      // 投影坐标位\n      vec2 coord = fragCoord + offset;\n      // 累加周围片元的颜色\n      color += RayMarch(coord,bg);\n    }\n  }\n  // 返回周围颜色的均值\n  return color / float(AA * AA);\n} \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n  // 计算背景颜色\n  vec2 uv = fragCoord/iResolution.xy;\n  vec3 cam_pos = SPHERE_POS+vec3(sin(iTime*0.3),-.1,cos(iTime*0.3))*5.;\n  vec3 cam_dir = normalize(vec3(cam_pos - SPHERE_POS));\n  vec3 cam_r=-cross(cam_dir,vec3(0,1,0));\n  vec3 cam_u=-cross(cam_r,cam_dir);\n  vec3 r=normalize(uv.x*cam_r+uv.y*cam_u+1.*cam_dir);\n  vec3 bg = texture(iChannel0,r).rgb;\n  \n  // 光线步进\n  \n  vec3 color = RayMarch(fragCoord,bg);\n  color = RayMarch_anti(fragCoord,bg);\n  // 最终颜色\n  fragColor = vec4(color, 1);\n  \n}","name":"Image","description":"","type":"image"}]}