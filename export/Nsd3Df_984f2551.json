{"ver":"0.1","info":{"id":"Nsd3Df","date":"1630784411","viewed":235,"name":"Interleaved  \"Best\" Integer Hash","username":"jt","description":"Based on \"Best\" Integer Hash by FabriceNeyret2 / Chris Wellons [url]https://www.shadertoy.com/view/WttXWX[/url],\nwith bitwise interleaving of xy coordinates to create seed\nusing [url]https://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","hash","interleaved","integer","bitwise","unsigned","2dhash","hash2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/Nsd3Df Interleaved \"Best\" Integer Hash by jt\n// Based on \"Best\" Integer Hash by FabriceNeyret2 / Chris Wellons\n// see: https://www.shadertoy.com/view/WttXWX\n\n// Added bitwise interleaving of x, y coordinates to create seed.\n// using https://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN\n\n// 2021 JT\n\n// --- choose one:\n//#define hashi(x)   lowbias32(x)\n#define hashi(x)   triple32(x) \n\n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\nuint lowbias32(uint x) // https://nullprogram.com/blog/2018/07/31/\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// inverse lowbias32\nuint lowbias32_r(uint x) // https://nullprogram.com/blog/2018/07/31/\n{\n    x ^= x >> 16;\n    x *= 0x43021123U;\n    x ^= x >> 15 ^ x >> 30;\n    x *= 0x1d69e2a5U;\n    x ^= x >> 16;\n    return x;\n}\n\nuint triple32(uint x) // https://nullprogram.com/blog/2018/07/31/\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n#define GENERATE_MAGIC_CONSTANT(n) (~0U/((1U<<(1U<<(n)))+1U)) /* generation of constants as suggested by mla */\n\n// source: https://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN\nuint interleave(uvec2 v)\n{\n    v &= uvec2(0x0000FFFFu, 0x0000FFFFu); // clear high bits\n\n    // bitmask-constants in binary:\n    // 01010101010101010101010101010101 = 0x55555555\n    // 00110011001100110011001100110011 = 0x33333333\n    // 00001111000011110000111100001111 = 0x0F0F0F0F\n    // 00000000111111110000000011111111 = 0x00FF00FF\n    // where\n    //        11 * 01010101010101010101010101010101 = 11111111111111111111111111111111\n    //       101 * 00110011001100110011001100110011 = 11111111111111111111111111111111\n    //     10001 * 00001111000011110000111100001111 = 11111111111111111111111111111111\n    // 100000001 * 00000000111111110000000011111111 = 11111111111111111111111111111111\n    // i.e.\n    // 0x003 * 0x55555555 = 0xFFFFFFFF = ~0\n    // 0x005 * 0x33333333 = 0xFFFFFFFF = ~0\n    // 0x011 * 0x0F0F0F0F = 0xFFFFFFFF = ~0\n    // 0x101 * 0x00FF00FF = 0xFFFFFFFF = ~0\n    //const uvec4 B = uvec4(GENERATE_MAGIC_CONSTANT(0), GENERATE_MAGIC_CONSTANT(1), GENERATE_MAGIC_CONSTANT(2), GENERATE_MAGIC_CONSTANT(3));\n    const uvec4 B = uvec4(0x55555555U, 0x33333333U, 0x0F0F0F0FU, 0x00FF00FFU);\n    const uvec4 S = uvec4(1U, 2U, 4U, 8U);\n\n    // Interleave lower 16 bits of x and y, so the bits of x\n    // are in the even positions and bits from y in the odd;\n    // z gets the resulting 32-bit Morton Number.\n    // x and y must initially be less than 65536.\n    v.x = (v.x | (v.x << S.w)) & B.w;\n    v.x = (v.x | (v.x << S.z)) & B.z;\n    v.x = (v.x | (v.x << S.y)) & B.y;\n    v.x = (v.x | (v.x << S.x)) & B.x;\n\n    v.y = (v.y | (v.y << S.w)) & B.w;\n    v.y = (v.y | (v.y << S.z)) & B.z;\n    v.y = (v.y | (v.y << S.y)) & B.y;\n    v.y = (v.y | (v.y << S.x)) & B.x;\n\n    return v.x | (v.y << 1);\n}\n\nuint unshuffle(uint x) // https://web.archive.org/web/20190109051129/http://www.hackersdelight.org/hdcodetxt/shuffle.c.txt thanks to mla for pointing this out!\n{\n   uint t = (x ^ (x >> 1u)) & 0x22222222u;  x = x ^ t ^ (t << 1u);\n   t = (x ^ (x >> 2u)) & 0x0C0C0C0Cu;  x = x ^ t ^ (t << 2u);\n   t = (x ^ (x >> 4u)) & 0x00F000F0u;  x = x ^ t ^ (t << 4u);\n   t = (x ^ (x >> 8)) & 0x0000FF00u;  x = x ^ t ^ (t << 8u);\n   return x;\n}\n\n#define hash2to1(x, y) hash(interleave(x, y))\n\n// TODO: unhash(v) = unshuffle(lowbias32_r(v)) ?\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4(hash(interleave(uvec2(U+iMouse.xy))));\n}\n","name":"Image","description":"","type":"image"}]}