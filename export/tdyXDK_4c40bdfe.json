{"ver":"0.1","info":{"id":"tdyXDK","date":"1588661916","viewed":117,"name":"spinnin' char","username":"skaplun","description":"simple sdf extrusion","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","typeface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 256\n#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPSILON 0.0001\n\n#define INSIDE(c, r) (c.x >= r.x && c.x <= r.x + r.z && c.y >= r.y && c.y <= r.y+r.w)\n#define REMAP(from, to) vec2((from.x - to.x)/to.z, (from.y - to.y)/to.w)\nfloat getChar(sampler2D Font, vec2 P, int L){\n   return texture(Font, (P + vec2(L%16, 15-L/16))/16.).a;\n}\n\nstruct Char{\n\tvec4 region;\n\tint letter;\n};\n\nfloat getChars(vec2 uv){\n    vec2 r = uv * .15 + .5;\n    r -= .5;\n    float a = iTime;\n    r *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    r += .5;\n    float T = getChar(iChannel1, r, 27);\n    return T;\n}\n\nfloat opExtrussion(in vec3 p, in float sdf, in float h){\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat world(vec3 pos){\n    float char = getChars(pos.xz);\n    float e = min(pos.y, max(pos.y - .1 - .1 * pow(smoothstep(.51, .5, char), .5), char - .51));\n    float spacing = .04;\n    float v = mod(pos.z, spacing) - spacing * .5;\n  \treturn max(e, opSubtraction(v + .0001, v - .0010));\n}\n\nfloat march(vec3 eye, vec3 marchingDirection){\n    const float precis = .001;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n\t    vec3 p = eye + marchingDirection * t;\n        float hit = world(p);\n        if(hit < precis) return t;\n        t += hit * .5;\n    }\n    return -1.;\n}\n\n//const vec3 colors[3] = vec3[](\n//\tvec3(119., 205., 210.)/255., vec3(235., 200., 170.)/255., vec3(235., 118., 132.)/255.\n//);\n\n#define FARCLIP 6.\nvec4 color(vec3 camPos, vec3 localViewDir){\n    vec3 col;\n    vec3 pos = camPos;\n    vec3 rayDir = localViewDir;\n    \n    float dis = march(pos, rayDir);\n    if(dis >= 0.){\n        pos += rayDir * dis;\n\t\tcol = vec3(pow(pos.y, .133));\n    }else{\n        col = vec3(FARCLIP + 1.);\n    }\n    \n    return vec4(col, 1.);\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr){\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nconst float PI = acos(-1.);\nvec4 render(in vec2 fragCoord){\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float a = PI * .75;//(iMouse.x/iResolution.x) * PI * 2.;\n    vec3 eye = vec3(3. * sin(a), 2.5, 3. * cos(a)) * 1.4;\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.15, -.25, 0.), vec3(0., 1., 0.)) * viewDir;\n\treturn color(eye, worldDir);\n}\n\n#define AA 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += render(fragCoord + vec2(x, y) / float(AA));\n        }\n    \n    fragColor /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{vec3 origin, direction;};\nstruct Light{vec3 normal; vec3 attenuation; float radius;};\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n","name":"Common","description":"","type":"common"}]}