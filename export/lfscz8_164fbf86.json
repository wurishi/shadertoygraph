{"ver":"0.1","info":{"id":"lfscz8","date":"1720798179","viewed":77,"name":"other truchet","username":"jorge2017a2","description":"other truchet","likes":10,"published":1,"flags":8,"usePreview":0,"tags":["sound","truchet","othertruchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//referencia art of code\n//Shader Coding: Truchet Tiling Explained!\n//https://www.youtube.com/watch?v=2R7h76GoIJM\n\nfloat Hash21(vec2 p)\n{\n    p=fract(p*vec2(234.34,432.356));\n    p+=dot(p, p+32.25);\n    return fract(p.x*p.y);\n}\n\n\nvec4 truchet(vec2 uv, float pwidth, vec3 pcol )\n{\n    vec3 col;\n    uv*=5.0;\n    //uv+=iTime;\n    vec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n\n    float n=Hash21(id);\n\n    float width=pwidth;  //0.1;\n\n    if(n<0.5) gv.x*=-1.0;  //giro de linea\n\n    float mask=smoothstep(0.01,-0.01, abs(gv.x-gv.y)-width);\n    col+=mask;\n    return vec4(col*pcol,mask);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv =(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col=vec3(0.0);\n    vec4 col1=truchet(uv,0.1, vec3(1.0));\n    vec4 col2=truchet(uv+iTime*0.25+vec2(0.,0.5),0.025, vec3(1.0,0.0,0.0));\n    vec4 col3=truchet(uv-(iTime*0.25)*vec2(0.5,0.5),0.05, vec3(1.0,0.0,1.0));\n    \n    col=mix(col1.rgb, col2.rgb, col2.a);\n    col=mix(col.rgb, col3.rgb, col3.a);\n    \n    fragColor=vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//referencia \n//https://www.shadertoy.com/view/lt2GRy\n// 2015-04-26 jnorberg\n//modificado por Jorge F.P\n\n\nfloat pi = 3.14159265359;\nfloat tau = 2.0 * 3.14156592;\n\nfloat note( float n ) { return 440.0 * pow( 2.0, ( n-49.0) / 12.0 ); }\n\nfloat bass( float time, float f, float c )\n{\n    float wf = mix(0.1,111.0, c );\n    float w0 = 0.25 + floor( wf ); // bandwidth (has to be integer)\n    float w1 = w0 + 1.0;\n    float wfrac = fract( wf );\n    \n    float p = mod( time*f, tau );\n    float saw = 1.0 - p / pi; // saw full aliasing \n    \n    // sinc-like features ahoy\n    float s = 0.9; // \"strength\" basically fake \"q\", try lowering for extra crunch\n    float i = tau - p; // i \"inverted p\"\n    float d0 = 1.0 / (1.0 + s * p );\n    float d1 = 1.0 / (1.0 + s * i );\n\n    float sinc_0 = -cos(p*w0) * d0 + cos(i*w0) * d1;\n    float sinc_1 = -cos(p*w1) * d0 + cos(i*w1) * d1;\n\n    return saw + mix( sinc_0, sinc_1, wfrac );\n}\n\nfloat kick( float t )\n{\n    t = t/(0.19+t);\n    float v = sin( 150.0 * t );\n    v *= 0.9 / (0.4 + 50.0*t); // env1\n    v = v / ( 0.2 + abs(v)); // saturate\n    v *= 0.5 / (0.5+2.0*t*t*t); // env2\n    return v;\n}\n\n// hi-hat-noise from and's \"starDust\"\nfloat noise(float t, float falloff )\n{\n    float phi = t * iSampleRate;\n    float v = fract(sin(phi * 0.011753) * 122.3762) - 0.5;\n    return 0.005 * v / (falloff + t );\n}\n\nvec2 ssaw( float t, float f )\n{\n    // super saw, super stereo :)\n    float m = fract( t * f );\n    vec2 s = vec2(\n        m + fract( t * f * 1.015 ) + 0.5 * fract( t * f * 0.98 ),\n        m + fract( t * f * 0.985 ) + 0.5 * fract( t * f * 1.02 )\n    );\n    s *= 0.08 * t;\n    return s;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float s16 = fract(time*8.0);\n    float s8 = fract(time*4.0);\n    float s4 = fract(time*2.0);\n    float s4_2 = fract(time*2.0+0.75);\n    float s4_3 = fract(time*2.0+0.5);\n    float s4_4 = fract(time*2.0+0.25);\n    float s2 = fract(time*1.0);\n    float s1 = fract(time*0.5);\n    float backforth = fract(time*0.125);\n\n    float backforth1 = fract(time*1.125);\n    float backforth0 = fract(time*0.125);\n\n\n    float si4 = fract(abs(1.0- 2.0*sin(time*0.25)));\n    float si5 = fract(abs(1.0- 2.0*sin(time*0.5)));\n    \n    \n    \n    float mono = 0.0;\n\n    // bass\n    float c = 0.5 * backforth1+si5 + 0.005 / ( 0.05 + s16 );\n    float n = 44.0;\n    if ( s1 >= 0.75+0.125 )\n        n -= 12.0;\n\telse if ( s1 >= 0.25 && s1 < 0.375 )\n        n -= 96.0*( s1-0.35);   \n    float f = note( n );\n    float b = bass( s16 * 0.125, f, c );\n    b *= (0.5 + s4) * 0.2 * ( 1.0 - s16 ); // fake \"ducking\" the bass\n    mono += b;\n    \n    \n    // kick\n    float k = kick( s4 );\n    mono += k;\n    \n    \n\t// parallel distortion (for bass+kick drum)\n    mono = 0.5 * ( mono + mono / ( 0.4 + abs(mono) ) );\n   \n   \n    // hats\n\tmono += noise( s4_2, 0.07 );\n    mono += noise( s4_3, 0.01 );\n    mono += noise( s4_4, 0.08 );\n   \n      \n    // make stereo\n   \n    vec2 stereo = vec2( mono );\n     vec2 stereo0=stereo;\n    \n    stereo += ssaw( s4, note( 24.0 ) );\n    vec2 ss1= ssaw( s4, note(20.0 + mix( 7.0, 8.0, floor( backforth1 + 0.5) ) ) );\n    vec2 ss2= ssaw( s4, note(20.0 + mix( 7.0, 8.0, floor( backforth0 + 0.5) ) ) );\n    stereo+=2.0*mix(ss1,ss2,floor( backforth + 0.5));\n    \n    \n    vec2 ss3= ssaw( si4, note( 34.0 ) );\n    stereo=mix(stereo, ss3+stereo0*0.5, sin(time*0.5));\n    \n    \n    stereo *= 1.25; // louder\n    stereo = clamp( stereo, vec2(-0.99), vec2(0.99) ); // clip\n    \n    \n    return stereo;\n}","name":"Sound","description":"","type":"sound"}]}