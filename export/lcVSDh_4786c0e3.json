{"ver":"0.1","info":{"id":"lcVSDh","date":"1715128494","viewed":644,"name":"HHD, HLSH, and SH Hemi Multiply","username":"Torust","description":"This ShaderToy compares the results of SH reconstruction with and without hemisphere multiplies and shows how to encode to both RGB and luminance HHD and HLSH.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics","hemispheres","hhd","hlsh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hemispherical Lighting Insights, Activision Tech Report.\n// Thomas Roughton, Peter-Pike Sloan, Ari Silvennoinen, and Peter Shirley.\n// https://research.activision.com/publications/2024/05/hemispherical-lighting-insights\n//\n// This ShaderToy demonstrates the effect of hemisphere multiplies on quadratic \n// SH data, shows the quadratic to linear SH multiply combined with the HHD L1 solve, \n// and demonstrates the accuracy of the HLSH approximation presented in the paper \n// as an inexpensive alternative to a full hemisphere multiply.\n//\n// Images are: [Quad. SH]              [L1 Hemi Mul + RGB HHD]            [L1 Hemi Mul + Lum HHD]                  \n//             [Quad. SH w/ Hemi Mul]  [RGB HLSH (incl. Hemi Mul)]        [Lum HLSH (incl. Hemi Mul)],\n// where the centre of the sphere is the hemisphere normal. \n// [Quad SH w/ Hemi Mul] in the bottom-left is the reference. \n//\n// Mouse X (phi) and Y (theta) control the hemisphere normal orientation in world space;\n// the mouse effectively controls the orientation of the surface plane, and then the image\n// shows the illumination for all normals for a normal map on that surface plane.\n//\n// The choice of environment map is given by the 'environment' variable on line 77. \n\nconst bool drawBackground = false; // Whether to draw the SH radiance behind the probes.\nconst float PI = 3.141592653589793;\n\n// St Peter's Basilica: https://www.pauldebevec.com/Probes/, \n// with SH coefficients from https://www.shadertoy.com/view/Mt23zW.\nconst vec3 stpeter[9] = vec3[](\n    8.0 * vec3( 0.3623915,  0.2624130,  0.2326261 ),\n    8.0 * vec3( 0.1759131,  0.1436266,  0.1260569 ),\n    8.0 * vec3(-0.0247311, -0.0101254, -0.0010745 ),\n    8.0 * vec3( 0.0346500,  0.0223184,  0.0101350 ),\n    8.0 * vec3( 0.0198140,  0.0144073,  0.0043987 ),\n    8.0 * vec3(-0.0469596, -0.0254485, -0.0117786 ),\n    8.0 * vec3(-0.0898667, -0.0760911, -0.0740964 ),\n    8.0 * vec3( 0.0050194,  0.0038841,  0.0001374 ),\n    8.0 * vec3(-0.0818750, -0.0321501,  0.0033399 ) \n);\n\n// Pisa Courtyard: https://vgl.ict.usc.edu/Data/HighResProbes/\nconst vec3 pisa[9] = vec3[](\n    vec3( 0.732668,  0.610310,  0.585349),\n    vec3(-0.506687, -0.417720, -0.429780),\n    vec3(-0.031983, -0.252292, -0.411999),\n    vec3( 0.103438,  0.139038,  0.167152),\n    vec3(-0.102849, -0.141602, -0.169318),\n    vec3(-0.038356,  0.214884,  0.408204),\n    vec3( 0.119999,  0.129040,  0.123580),\n    vec3( 0.009767, -0.113339, -0.185314),\n    vec3(-0.017577,  0.000823, -0.014609)\n);\n\n// Ennis-Brown House Dining Room: https://vgl.ict.usc.edu/Data/HighResProbes/\nconst vec3 ennis[9] = vec3[](\n    0.2 * vec3( 4.531689,  4.308981,  4.520285),\n    0.2 * vec3(-1.057496, -1.336207, -1.825209),\n    0.2 * vec3(-6.188428, -6.201931, -6.694056),\n    0.2 * vec3(-0.407847, -0.405074, -0.416838),\n    0.2 * vec3( 0.179401,  0.180498,  0.212682),\n    0.2 * vec3( 2.653277,  2.971460,  3.824151),\n    0.2 * vec3( 7.051956,  6.934999,  7.286222),\n    0.2 * vec3( 0.795407,  0.720389,  0.719510),\n    0.2 * vec3( 0.079124, -0.100926, -0.384239)\n);\n\n// Uffizi: https://vgl.ict.usc.edu/Data/HighResProbes/\nconst vec3 uffizi[9] = vec3[](\n    (1.0 / 3.0) * vec3( 3.171716,  3.076861,  3.500972),\n    (1.0 / 3.0) * vec3(-3.701456, -3.673000, -4.282978),\n    (1.0 / 3.0) * vec3(-0.077917, -0.080867, -0.109681),\n    (1.0 / 3.0) * vec3( 0.027043,  0.024597,  0.031224),\n    (1.0 / 3.0) * vec3(-0.095452, -0.088531, -0.102552),\n    (1.0 / 3.0) * vec3( 0.181852,  0.183784,  0.241100),\n    (1.0 / 3.0) * vec3(-0.697054, -0.708923, -0.866909),\n    (1.0 / 3.0) * vec3(-0.005508, -0.003777, -0.002297),\n    (1.0 / 3.0) * vec3(-3.610548, -3.575409, -4.168227)\n);\n\n// The environment to use.\nconst vec3 environment[9] = stpeter;\nconst float coneCosAlpha = 0.0; // 0 = hemisphere.\n\n// Luminance of a colour using sRGB coefficients.\nfloat Color_Luminance(vec3 color) {\n    return dot(color, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\n// Evaluate quadratic spherical harmonics in the specified direction.\nvoid SH_InDirection(vec3 direction, out float sh[9]) {\n    sh[0] = 0.5 * sqrt(1.0 / PI);\n\n    sh[1] = -sqrt(0.75 / PI) * direction.y;\n    sh[2] = sqrt(0.75 / PI) * direction.z;\n    sh[3] = -sqrt(0.75 / PI) * direction.x;\n\n    sh[4] = 0.5 * sqrt(15.0 / PI) * direction.x * direction.y;\n    sh[5] = -0.5 * sqrt(15.0 / PI) * direction.y * direction.z;\n    sh[6] = 0.25 * sqrt(5.0 / PI) * (-1.0 + 3.0 * direction.z * direction.z);\n    sh[7] = -0.5 * sqrt(15.0 / PI) * direction.z * direction.x;\n    sh[8] = 0.25 * sqrt(15.0 / PI) * (direction.x * direction.x - direction.y * direction.y);\n}\n\n// Convolve quadratic SH with a normalized cosine lobe to produce irradiance.\nvoid SH_ConvCos(inout float sh[9]) {\n   sh[0] *= 1.0;\n    \n   sh[1] *= 2.0 / 3.0;\n   sh[2] *= 2.0 / 3.0;\n   sh[3] *= 2.0 / 3.0;\n    \n   sh[4] *= 0.25;\n   sh[5] *= 0.25;\n   sh[6] *= 0.25;\n   sh[7] *= 0.25;\n   sh[8] *= 0.25;\n}\n\n// Dot product of two SH coefficient vectors.\nfloat SH_Dot(float c[9], float sh[9]) {\n   float result = 0.0;\n    \n   for (int i = 0; i < 9; i += 1) {\n       result += c[i] * sh[i];\n   }\n    \n   return result;\n}\n\n// Dot product of two SH coefficient vectors.\nvec3 SH_Dot(vec3 c[9], float sh[9]) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < 9; i += 1) {\n        result += c[i] * sh[i];\n    }\n    \n    return result;\n}\n\nvoid SH_ToLuminance(vec3 inSH[9], out float lumSH[9]) {\n    for (int i = 0; i < 9; i += 1) {\n        lumSH[i] = Color_Luminance(inSH[i]);\n    }\n}\n\n// Multiply sh by a cone in (0, 0, 1).\n// alpha is the half-angle of the cone; cosAlpha = 0 gives a hemisphere.\n// Note that for cosAlpha > 0 irradZ will be reduced.\nvoid SH_MulCone(vec3 sh[9], float cosAlpha, out vec3 result[9]) {\n    float cosAlpha2 = cosAlpha * cosAlpha;\n    float cosAlpha3 = cosAlpha2 * cosAlpha;\n    float cosAlpha4 = cosAlpha2 * cosAlpha2;\n    \n    result[0] = 0.5 * (1.0 - cosAlpha) * sh[0] + sqrt(3.0) / 4.0 * (1.0 - cosAlpha2) * sh[2];\n    result[1] = 0.25 * (2.0 - 3.0 * cosAlpha + cosAlpha3) * sh[1] + sqrt(5.0) * 3.0 / 16.0 * pow(cosAlpha2 - 1.0, 2.0) * sh[5];\n    result[2] = sqrt(3.0) / 4.0 * (1.0 - cosAlpha2) * sh[0] + 0.5 * (1.0 - cosAlpha3) * sh[2] + sqrt(15.0) / 16.0 * (1.0 + 2.0 * cosAlpha2 - 3.0 * cosAlpha4) * sh[6];\n    result[3] = 0.25 * (2.0 - 3.0 * cosAlpha + cosAlpha3) * sh[3] + sqrt(5.0) * 3.0 / 16.0 * pow(cosAlpha2 - 1.0, 2.0) * sh[7];\n\n    result[4] = -1.0 / 16.0 * pow(cosAlpha - 1.0, 3.0) * (8.0 + 3.0 * cosAlpha * (3.0 + cosAlpha)) * sh[4];\n    result[5] = sqrt(5.0) * 3.0 / 16.0 * pow(cosAlpha2 - 1.0, 2.0) * sh[1] + 0.25 * (2.0 - 5.0 * cosAlpha3 + 3.0 * cosAlpha3 * cosAlpha2) * sh[5];\n    result[6] = -0.25 * sqrt(5.0) * cosAlpha * (cosAlpha2 - 1.0) * sh[0] + sqrt(15.0) / 16.0 * (1.0 + 2.0 * cosAlpha2 - 3.0 * cosAlpha4) * sh[2] + 0.25 * (2.0 - 5.0 * cosAlpha3 + 3.0 * cosAlpha3 * cosAlpha2) * sh[6];\n    result[7] = sqrt(5.0) * 3.0 / 16.0 * pow(cosAlpha2 - 1.0, 2.0) * sh[3] + 0.25 * (2.0 - 5.0 * cosAlpha3 + 3.0 * cosAlpha3 * cosAlpha2) * sh[7];\n    result[8] = -1.0 / 16.0 * pow(cosAlpha - 1.0, 3.0) * (8.0 + 3.0 * cosAlpha * (3.0 + cosAlpha)) * sh[8];\n}\n\n// Simple and Fast Spherical Harmonic Rotation\n// Hable 2014\n// http://filmicworlds.com/blog/simple-and-fast-spherical-harmonic-rotation/\nvoid SH_Rotate(vec3 sh[9], mat3 mat, out vec3 result[9]) {\n    float m00 = mat[0][0];\n    float m01 = mat[1][0];\n    float m02 = mat[2][0];\n    float m10 = mat[0][1];\n    float m11 = mat[1][1];\n    float m12 = mat[2][1];\n    float m20 = mat[0][2];\n    float m21 = mat[1][2];\n    float m22 = mat[2][2];\n    \n    result[0] = sh[0];\n\n    result[1] = ( m11)*sh[1] + (-m12)*sh[2] + ( m10)*sh[3];\n    result[2] = (-m21)*sh[1] + ( m22)*sh[2] + (-m20)*sh[3];\n    result[3] = ( m01)*sh[1] + (-m02)*sh[2] + ( m00)*sh[3];\n\n    const float s_c3 = 0.94617469575; // (3*sqrt(5))/(4*sqrt(pi))\n    const float s_c4 = -0.31539156525;// (-sqrt(5))/(4*sqrt(pi))\n    const float s_c5 = 0.54627421529; // (sqrt(15))/(4*sqrt(pi))\n\n    const float s_c_scale = 1.0/0.91529123286551084;\n    const float s_c_scale_inv = 0.91529123286551084;\n\n    const float s_rc2 = 1.5853309190550713*s_c_scale;\n    const float s_c4_div_c3 = s_c4/s_c3;\n    const float s_c4_div_c3_x2 = (s_c4/s_c3)*2.0;\n\n    const float s_scale_dst2 = s_c3 * s_c_scale_inv;\n    const float s_scale_dst4 = s_c5 * s_c_scale_inv;\n\n    // Sparse matrix multiply\n    vec3 sh0 =  sh[7] + sh[8] + sh[8] - sh[5];\n    vec3 sh1 =  sh[4] + s_rc2*sh[6] + sh[7] + sh[8];\n    vec3 sh2 =  sh[4];\n    vec3 sh3 = -sh[7];\n    vec3 sh4 = -sh[5];\n\n    // Rotations.  R0 and R1 just use the raw matrix columns\n    float r2x = m00 + m01;\n    float r2y = m10 + m11;\n    float r2z = m20 + m21;\n\n    float r3x = m00 + m02;\n    float r3y = m10 + m12;\n    float r3z = m20 + m22;\n\n    float r4x = m01 + m02;\n    float r4y = m11 + m12;\n    float r4z = m21 + m22;\n\n    // dense matrix multiplication one column at a time\n\n    // column 0\n    vec3 sh0_x = sh0 * m00;\n    vec3 sh0_y = sh0 * m10;\n    vec3 d0 = sh0_x * m10;\n    vec3 d1 = sh0_y * m20;\n    vec3 d2 = sh0 * (m20 * m20 + s_c4_div_c3);\n    vec3 d3 = sh0_x * m20;\n    vec3 d4 = sh0_x * m00 - sh0_y * m10;\n\n    // column 1\n    vec3 sh1_x = sh1 * m02;\n    vec3 sh1_y = sh1 * m12;\n    d0 += sh1_x * m12;\n    d1 += sh1_y * m22;\n    d2 += sh1 * (m22 * m22 + s_c4_div_c3);\n    d3 += sh1_x * m22;\n    d4 += sh1_x * m02 - sh1_y * m12;\n\n    // column 2\n    vec3 sh2_x = sh2 * r2x;\n    vec3 sh2_y = sh2 * r2y;\n    d0 += sh2_x * r2y;\n    d1 += sh2_y * r2z;\n    d2 += sh2 * (r2z * r2z + s_c4_div_c3_x2);\n    d3 += sh2_x * r2z;\n    d4 += sh2_x * r2x - sh2_y * r2y;\n\n    // column 3\n    vec3 sh3_x = sh3 * r3x;\n    vec3 sh3_y = sh3 * r3y;\n    d0 += sh3_x * r3y;\n    d1 += sh3_y * r3z;\n    d2 += sh3 * (r3z * r3z + s_c4_div_c3_x2);\n    d3 += sh3_x * r3z;\n    d4 += sh3_x * r3x - sh3_y * r3y;\n\n    // column 4\n    vec3 sh4_x = sh4 * r4x;\n    vec3 sh4_y = sh4 * r4y;\n    d0 += sh4_x * r4y;\n    d1 += sh4_y * r4z;\n    d2 += sh4 * (r4z * r4z + s_c4_div_c3_x2);\n    d3 += sh4_x * r4z;\n    d4 += sh4_x * r4x - sh4_y * r4y;\n\n    // extra multipliers\n    result[4] = d0;\n    result[5] = -d1;\n    result[6] = d2 * s_scale_dst2;\n    result[7] = -d3;\n    result[8] = d4 * s_scale_dst4;\n}\n\nvoid SH_MulRotatedHemisphereQuadraticToLinear(float sh[9], vec3 N, float irradZ, out float result[4]) {\n\tvec3 l1Vector = vec3(-sh[3], -sh[1], sh[2]);\n\tfloat l1Dot = dot(l1Vector, N);\n\t\n\tresult[0] = 0.5 * sh[0] + sqrt(3.0) / 4.0 * l1Dot;\n\t\n\tvec3 l1ResultVector = l1Vector;\n\t// Set dot(L1, N) to sqrt(3 pi) / 2 * irradZ, to match the expected value. \n\t// irradZ is scaled by 2.0 since we multiply by 0.5 on the next line\n\tl1ResultVector += (sqrt(3.0 * PI) * irradZ - l1Dot) * N;\n\tl1ResultVector *= 0.5f;\n\t\t\n\tconst float s_rc2 = sqrt(3.0);\n\n\tfloat x0 = sh[4];\n\tfloat x1 = sh[5];\n\tfloat x2Scaled = sh[6] * s_rc2;\n\tfloat x3 = sh[7];\n\tfloat x4 = sh[8];\n\t\n\tfloat Nx2 = N.x * N.x;\n\tfloat Ny2 = N.y * N.y;\n\tfloat Nz2 = N.z * N.z;\n\t\n\tfloat Nxyz = 2.0 * N.x * N.y * N.z;\n\tfloat Ny2MinusNx2 = Ny2 - Nx2;\n\n\tvec3 l2Components;\n\tl2Components.x =  Nxyz * x1 - N.x * Nz2 * x2Scaled\t\t\t+ (2.0 * Nx2 - 1.0) * (N.z * x3 - N.y * x0) + (Ny2MinusNx2 + 1.0) * N.x * x4;\n\tl2Components.y =  Nxyz * x3 - N.y * Nz2 * x2Scaled\t\t\t+ (2.0 * Ny2 - 1.0) * (N.z * x1 - N.x * x0) + (Ny2MinusNx2 - 1.0) * N.y * x4;\n\tl2Components.z = -Nxyz * x0 + N.z * (1.0 - Nz2) * x2Scaled\t+ (2.0 * Nz2 - 1.0) * (N.x * x3 + N.y * x1) + (Ny2MinusNx2)\t\t  * N.z * x4;\n\n\tl1ResultVector += 3.0 * sqrt(5.0) / 16.0 * l2Components;\n\n\tresult[1] = -l1ResultVector.y;\n\tresult[2] =  l1ResultVector.z;\n\tresult[3] = -l1ResultVector.x;\n}\n\nvoid SH_MulRotatedHemisphereQuadraticToLinear(vec3 sh[9], vec3 N, vec3 irradZ, out vec3 result[4]) {\n\tmat3 l1Vector = mat3(-sh[3], -sh[1], sh[2]); // For HLSL, the matrix constructor is transposed; watch out.\n\tvec3 l1Dot = l1Vector * N; // RGB\n\t\n\tresult[0] = 0.5 * sh[0] + sqrt(3.0) / 4.0 * l1Dot;\n\t\n\tmat3 l1ResultVector = transpose(l1Vector); // Each column consists of an XYZ vector, with the columns being R, G, and B.\n\t// Set dot(L1, N) to sqrt(3 pi) / 2 * irradZ, to match the expected value. \n\t// irradZ is scaled by 2.0 since we multiply by 0.5 on the next line\n\tl1ResultVector[0] += (sqrt(3.0 * PI) * irradZ.r - l1Dot.r) * N;\n\tl1ResultVector[1] += (sqrt(3.0 * PI) * irradZ.g - l1Dot.g) * N;\n\tl1ResultVector[2] += (sqrt(3.0 * PI) * irradZ.b - l1Dot.b) * N;\n\tl1ResultVector *= 0.5f;\n\t\t\n\tconst float s_rc2 = sqrt(3.0);\n\n\tvec3 x0 = sh[4];\n\tvec3 x1 = sh[5];\n\tvec3 x2Scaled = sh[6] * s_rc2;\n\tvec3 x3 = sh[7];\n\tvec3 x4 = sh[8];\n\t\n\tfloat Nx2 = N.x * N.x;\n\tfloat Ny2 = N.y * N.y;\n\tfloat Nz2 = N.z * N.z;\n\t\n\tfloat Nxyz = 2.0 * N.x * N.y * N.z;\n\tfloat Ny2MinusNx2 = Ny2 - Nx2;\n\n\tmat3 l2Components; // Each column consists of an RGB vector, with the columns being X, Y, and Z.\n\tl2Components[0] =  Nxyz * x1 - N.x * Nz2 * x2Scaled\t\t\t+ (2.0 * Nx2 - 1.0) * (N.z * x3 - N.y * x0) + (Ny2MinusNx2 + 1.0) * N.x * x4;\n\tl2Components[1] =  Nxyz * x3 - N.y * Nz2 * x2Scaled\t\t\t+ (2.0 * Ny2 - 1.0) * (N.z * x1 - N.x * x0) + (Ny2MinusNx2 - 1.0) * N.y * x4;\n\tl2Components[2] = -Nxyz * x0 + N.z * (1.0 - Nz2) * x2Scaled\t+ (2.0 * Nz2 - 1.0) * (N.x * x3 + N.y * x1) + (Ny2MinusNx2)\t\t  * N.z * x4;\n\n    l1ResultVector = transpose(l1ResultVector);\n\tl1ResultVector += 3.0 * sqrt(5.0) / 16.0 * l2Components;\n\n\tresult[1] = -l1ResultVector[1];\n\tresult[2] =  l1ResultVector[2];\n\tresult[3] = -l1ResultVector[0];\n}\n\nstruct HHD\n{\n    vec3 scaledHighlightDir;\n    float hemiIntensity;\n};\n\nHHD SH_SolveToHHDL1(vec4 sh, vec3 hemiNormal, float irradZLum) {\n    float l0 = sh[0];\n    vec3 l1 = vec3(sh[1], sh[2], sh[3]);\n\n    float a = 9.0 * PI / 4.0;\n    float b = sqrt(PI) * (sqrt(3.0) * (sqrt(3.0 * PI) / 2.0) * irradZLum - 6.0 * l0);\n    float c = 3.0 * l0 * l0 - dot(l1, l1);\n\n    float hemiIntensity = (-b - sqrt(max(b * b - 4.0 * a * c, 0.0))) / (2.0 * a);\n    hemiIntensity = min(hemiIntensity, irradZLum);\n    \n    vec3 highlightDirection = 2.0 / sqrt(3.0 * PI) * vec3(-l1[2], -l1[0], l1[1]) - hemiIntensity * hemiNormal;\n\n    HHD result;\n    result.scaledHighlightDir = highlightDirection;\n    result.hemiIntensity = hemiIntensity;\n    return result;\n}\n\nfloat HHD_Eval(HHD hhd, vec3 hemiNormal, vec3 normal) {\n\tfloat dv = dot(hemiNormal, normal);\n\tfloat df = dv * 0.5f + 0.5f;\n\n\treturn hhd.hemiIntensity * df + max( dot( normal, hhd.scaledHighlightDir ), 0.0 );\n}\n\nstruct HLSH {\n   float Ca;\n   vec3 Cdd;\n};\n\nstruct HLSHRGB {\n   vec3 Ca;\n   vec3 cx;\n   vec3 cy;\n   vec3 cz;\n};\n\n\n// Evaluate HLSH in a direction.\nfloat HLSH_Eval(HLSH hlsh, vec3 N) {\n    return hlsh.Ca + dot(N, hlsh.Cdd);\n}\n\n// Evaluate RGB HLSH in a direction.\nvec3 HLSH_Eval(HLSHRGB hlsh, vec3 N) {\n    return hlsh.Ca + hlsh.cx * N.x + hlsh.cy * N.y + hlsh.cz * N.z;\n}\n\n// Solve SH to HLSH with the Irrad-Z constraint, \n// performing a hemisphere or cone multiply in the process.\n// alpha is the half-angle of the cone; cosAlpha = 0 gives a hemisphere.\nHLSH SH_ProjectToHLSHConeMultiply(float sh[9], vec3 N, float cosAlpha) {\n    float cosAlpha2 = cosAlpha * cosAlpha;\n    float cosAlpha3 = cosAlpha2 * cosAlpha;\n    float cosAlpha4 = cosAlpha2 * cosAlpha2;\n    \n    vec3 Nsh = vec3(-N.y, N.z, -N.x);\n\tvec3 l1Vector = vec3(sh[1], sh[2], sh[3]);\n\tfloat l1Dot = dot(Nsh, l1Vector);\n    \n    vec3 l1TangentComponents = l1Vector - l1Dot * Nsh;\n    \n    float inDirection[9];\n    SH_InDirection(N, inDirection);\n    \n    float pZ2 = 0.0;\n    for (int i = 4; i < 9; i += 1) {\n       pZ2 += inDirection[i] * sh[i];\n    }\n    pZ2 *= sqrt(4.0 * PI / 5.0);\n    \n    float Ca = 1.0 / (4096.0 * sqrt(PI)) * (1024.0 + cosAlpha * (-1767.0 + cosAlpha * (512.0 + 21.0 * cosAlpha * (10.0 + cosAlpha2)))) * sh[0];\n    Ca += 1.0 / (8192.0 * sqrt(3.0 * PI)) * (2203.0 + cosAlpha2 * (-5301.0 + cosAlpha * (2048.0 + 105.0 * cosAlpha * (9.0 + cosAlpha2)))) * l1Dot;\n    Ca += sqrt(5.0) / (8192.0 * sqrt(PI)) * (-448.0 + cosAlpha * (1767.0 + cosAlpha * (-512.0 + 3.0 * cosAlpha * (-659.0 + cosAlpha * (256.0 + 119.0 * cosAlpha + 15.0 * cosAlpha3))))) * pZ2;\n    \n\tconst float s_rc2 = sqrt(3.0);\n\n\tfloat x0 = sh[4];\n\tfloat x1 = sh[5];\n\tfloat x2Scaled = sh[6] * s_rc2;\n\tfloat x3 = sh[7];\n\tfloat x4 = sh[8];\n\t\n\tfloat Nx2 = N.x * N.x;\n\tfloat Ny2 = N.y * N.y;\n\tfloat Nz2 = N.z * N.z;\n\t\n\tfloat Nxyz = float(2.0) * N.x * N.y * N.z;\n\tfloat Ny2MinusNx2 = Ny2 - Nx2;\n\n\tvec3 l2Components;\n    l2Components[0] = -Nxyz * x3 + N.y * Nz2 * x2Scaled - (float(2.0) * Ny2 - float(1.0)) * (N.z * x1 - N.x * x0) - (Ny2MinusNx2 - 1.0) * N.y * x4;\n\tl2Components[1] = -Nxyz * x0 + N.z * (float(1.0) - Nz2) * x2Scaled\t+ (float(2.0) * Nz2 - float(1.0)) * (N.x * x3 + N.y * x1) + (Ny2MinusNx2) * N.z * x4;\n\tl2Components[2] = -Nxyz * x1 + N.x * Nz2 * x2Scaled - (float(2.0) * Nx2 - float(1.0)) * (N.z * x3 - N.y * x0) - (Ny2MinusNx2 + 1.0) * N.x * x4;\n\t\n    vec3 tangentComponents = 1.0 / (4096.0 * sqrt(3.0 * PI)) * (cosAlpha - 1.0) * (cosAlpha - 1.0) * (2573.0 + cosAlpha * (2074.0 + 105.0 * cosAlpha * (6.0 + cosAlpha * (2.0 + cosAlpha)))) * l1TangentComponents;\n    tangentComponents += sqrt(15.0) / (2048.0 * sqrt(PI)) * (176.0 + cosAlpha2 * (-256.0 + cosAlpha * (-105.0 + cosAlpha * (128.0 + 42.0 * cosAlpha + 15.0 * cosAlpha3)))) * l2Components;\n\n    vec3 tangentComponentsSwizzled = vec3(-tangentComponents[2], -tangentComponents[0], tangentComponents[1]);\n\n    float iZ = sh[0] * (1.0 - cosAlpha2) * inDirection[0] + \n                2.0 / 3.0 * (1.0 - cosAlpha3) * sqrt(0.75 / PI) * l1Dot + \n                0.25 * (1.0 + 2.0 * cosAlpha2 - 3.0 * cosAlpha4) * 0.5 * sqrt(5.0 / PI) * pZ2;\n    \n    HLSH result;\n    result.Ca = Ca;\n    result.Cdd = tangentComponentsSwizzled + N * (iZ - Ca);\n    return result;\n}\n\n// Solve SH to HLSH, performing a hemisphere or cone multiply in the process.\n// alpha is the half-angle of the cone; cosAlpha = 0 gives a hemisphere.\nHLSHRGB SH_ProjectToHLSHConeMultiplyRGB(vec3 sh[9], vec3 N, float cosAlpha) {\n    float cosAlpha2 = cosAlpha * cosAlpha;\n    float cosAlpha3 = cosAlpha2 * cosAlpha;\n    float cosAlpha4 = cosAlpha2 * cosAlpha2;\n\n    vec3 Nsh = vec3(-N.y, N.z, -N.x);\n\tvec3 l1VectorR = vec3(sh[1].r, sh[2].r, sh[3].r);\n\tvec3 l1VectorG = vec3(sh[1].g, sh[2].g, sh[3].g);\n\tvec3 l1VectorB = vec3(sh[1].b, sh[2].b, sh[3].b);\n\tvec3 l1Dot = vec3(dot(Nsh, l1VectorR), dot(Nsh, l1VectorG), dot(Nsh, l1VectorB));\n    \n    vec3 l1TangentComponentsR = l1VectorR - l1Dot.r * Nsh;\n    vec3 l1TangentComponentsG = l1VectorG - l1Dot.g * Nsh;\n    vec3 l1TangentComponentsB = l1VectorB - l1Dot.b * Nsh;\n    \n    float inDirection[9];\n    SH_InDirection(N, inDirection);\n    \n    vec3 pZ2 = vec3(0.0);\n    for (int i = 4; i < 9; i += 1) {\n       pZ2 += inDirection[i] * sh[i];\n    }\n    \n    pZ2 *= sqrt(4.0 * PI / 5.0);\n    \n    vec3 iZ = sh[0] * (1.0 - cosAlpha2) * inDirection[0] + \n                2.0 / 3.0 * (1.0 - cosAlpha3) * sqrt(0.75 / PI) * l1Dot + \n                0.25 * (1.0 + 2.0 * cosAlpha2 - 3.0 * cosAlpha4) * 0.5 * sqrt(5.0 / PI) * pZ2;\n    \n    vec3 Ca = 1.0 / (4096.0 * sqrt(PI)) * (1024.0 + cosAlpha * (-1767.0 + cosAlpha * (512.0 + 21.0 * cosAlpha * (10.0 + cosAlpha2)))) * sh[0];\n    Ca += 1.0 / (8192.0 * sqrt(3.0 * PI)) * (2203.0 + cosAlpha2 * (-5301.0 + cosAlpha * (2048.0 + 105.0 * cosAlpha * (9.0 + cosAlpha2)))) * l1Dot;\n    Ca += sqrt(5.0) / (8192.0 * sqrt(PI)) * (-448.0 + cosAlpha * (1767.0 + cosAlpha * (-512.0 + 3.0 * cosAlpha * (-659.0 + cosAlpha * (256.0 + 119.0 * cosAlpha + 15.0 * cosAlpha3))))) * pZ2;\n    \n\tconst float s_rc2 = sqrt(3.0);\n\n\tvec3 x0 = sh[4];\n\tvec3 x1 = sh[5];\n\tvec3 x2Scaled = sh[6] * s_rc2;\n\tvec3 x3 = sh[7];\n\tvec3 x4 = sh[8];\n\t\n\tfloat Nx2 = N.x * N.x;\n\tfloat Ny2 = N.y * N.y;\n\tfloat Nz2 = N.z * N.z;\n\t\n\tfloat Nxyz = float(2.0) * N.x * N.y * N.z;\n\tfloat Ny2MinusNx2 = Ny2 - Nx2;\n\n\tvec3 l2Components[3];\n    l2Components[0] = -Nxyz * x3 + N.y * Nz2 * x2Scaled - (float(2.0) * Ny2 - float(1.0)) * (N.z * x1 - N.x * x0) - (Ny2MinusNx2 - 1.0) * N.y * x4;\n\tl2Components[1] = -Nxyz * x0 + N.z * (float(1.0) - Nz2) * x2Scaled\t+ (float(2.0) * Nz2 - float(1.0)) * (N.x * x3 + N.y * x1) + (Ny2MinusNx2) * N.z * x4;\n\tl2Components[2] = -Nxyz * x1 + N.x * Nz2 * x2Scaled - (float(2.0) * Nx2 - float(1.0)) * (N.z * x3 - N.y * x0) - (Ny2MinusNx2 + 1.0) * N.x * x4;\n\t\n    float l1TangentComponentsScale = 1.0 / (4096.0 * sqrt(3.0 * PI)) * (cosAlpha - 1.0) * (cosAlpha - 1.0) * (2573.0 + cosAlpha * (2074.0 + 105.0 * cosAlpha * (6.0 + cosAlpha * (2.0 + cosAlpha))));\n    vec3 tangentComponents[3];\n    tangentComponents[0] = l1TangentComponentsScale * vec3(l1TangentComponentsR[0], l1TangentComponentsG[0], l1TangentComponentsB[0]);\n    tangentComponents[1] = l1TangentComponentsScale * vec3(l1TangentComponentsR[1], l1TangentComponentsG[1], l1TangentComponentsB[1]);\n    tangentComponents[2] = l1TangentComponentsScale * vec3(l1TangentComponentsR[2], l1TangentComponentsG[2], l1TangentComponentsB[2]);\n    \n    float l2TangentComponentsScale = sqrt(15.0) / (2048.0 * sqrt(PI)) * (176.0 + cosAlpha2 * (-256.0 + cosAlpha * (-105.0 + cosAlpha * (128.0 + 42.0 * cosAlpha + 15.0 * cosAlpha3))));\n    tangentComponents[0] += l2TangentComponentsScale * l2Components[0];\n    tangentComponents[1] += l2TangentComponentsScale * l2Components[1];\n    tangentComponents[2] += l2TangentComponentsScale * l2Components[2];\n\n    vec3 iZMinusCa = iZ - Ca;\n    tangentComponents[0] += iZMinusCa * Nsh.x;\n    tangentComponents[1] += iZMinusCa * Nsh.y;\n    tangentComponents[2] += iZMinusCa * Nsh.z;\n    \n    HLSHRGB result;\n    result.Ca = Ca;\n    result.cx = -tangentComponents[2];\n    result.cy = -tangentComponents[0];\n    result.cz = tangentComponents[1];\n    return result;\n}\n\n// Evaluate radiance from spherical harmonic env in direction normal.\nvec3 SH_EvalRadiance(vec3 env[9], vec3 normal) {\n    float shDir[9];\n    SH_InDirection(normal, shDir);\n    \n    return SH_Dot(env, shDir);\n}\n\n// Evaluate irradiance from spherical harmonic env in direction normal.\nvec3 SH_EvalIrradiance(vec3 env[9], vec3 normal) {\n    float shDir[9];\n    SH_InDirection(normal, shDir);\n    \n    SH_ConvCos(shDir);\n    \n    return SH_Dot(env, shDir);\n}\n\n// Using HHD, approximate irradiance from spherical harmonic env in direction normal, \n// assuming env contains only hemispherical data.\nvec3 HHD_EvalIrradiance(vec3 env[9], vec3 normal, vec3 hemiNormal) {\n    vec3 irradZ = SH_EvalIrradiance(env, hemiNormal);\n    \n    vec3 shLin[4];\n    SH_MulRotatedHemisphereQuadraticToLinear(environment, hemiNormal, irradZ, shLin); \n\n    HHD rgb[3];\n    rgb[0] = SH_SolveToHHDL1(vec4(shLin[0].r, shLin[1].r, shLin[2].r, shLin[3].r), hemiNormal, irradZ.r);\n    rgb[1] = SH_SolveToHHDL1(vec4(shLin[0].g, shLin[1].g, shLin[2].g, shLin[3].g), hemiNormal, irradZ.g);\n    rgb[2] = SH_SolveToHHDL1(vec4(shLin[0].b, shLin[1].b, shLin[2].b, shLin[3].b), hemiNormal, irradZ.b);\n\n    vec3 irradiance = vec3(0.0);\n    irradiance.r = HHD_Eval(rgb[0], hemiNormal, normal);\n    irradiance.g = HHD_Eval(rgb[1], hemiNormal, normal);\n    irradiance.b = HHD_Eval(rgb[2], hemiNormal, normal);\n    return irradiance;\n}\n\n// Using HHD, approximate irradiance from spherical harmonic env in direction normal, \n// assuming env contains only hemispherical data.\n// This version computes luminance HHD coefficients, reducing the cost \n// (and interpolants for a vertex shader).\nvec3 HHD_EvalIrradianceLuminance(vec3 env[9], vec3 normal, vec3 hemiNormal) {\n    vec3 irradZ = max(SH_EvalIrradiance(env, hemiNormal), vec3(0.0));\n    float irradZLum = max(Color_Luminance(irradZ), 1e-8);\n    \n    float luminanceSH[9];\n    SH_ToLuminance(env, luminanceSH);\n    \n    float shLin[4];\n    SH_MulRotatedHemisphereQuadraticToLinear(luminanceSH, hemiNormal, irradZLum, shLin); \n\n    HHD hhd = SH_SolveToHHDL1(vec4(shLin[0], shLin[1], shLin[2], shLin[3]), hemiNormal, irradZLum);\n    hhd.hemiIntensity /= irradZLum; \n    hhd.scaledHighlightDir /= irradZLum;\n    \n    // Note that hemiIntensity is also given by 1.0 - dot(hhd.scaledHighlightDir, hemiNormal),\n    // (or the equivalent scaled by irradZLum), so can be reconstructed in a pixel shader \n    // after interpolation.\n\n    return irradZ * HHD_Eval(hhd, hemiNormal, normal);\n}\n\n// Using HLSH, approximate irradiance from spherical harmonic env in direction normal \n// after multiplying with a cone in hemiNormal.\nvec3 HLSH_EvalIrradiance(vec3 env[9], vec3 normal, vec3 coneNormal, float coneCosAlpha) {\n    HLSHRGB hlsh = SH_ProjectToHLSHConeMultiplyRGB(env, coneNormal, coneCosAlpha);\n    return HLSH_Eval(hlsh, normal);\n}\n\n// Using HLSH, approximate irradiance from spherical harmonic env in direction normal \n// after multiplying with a cone in hemiNormal.\n// This version computes luminance HLSH coefficients, reducing the cost \n// (and interpolants for a vertex shader).\nvec3 HLSH_EvalIrradianceLuminance(vec3 env[9], vec3 normal, vec3 coneNormal, float coneCosAlpha) {\n    vec3 irradZ = max(SH_EvalIrradiance(env, coneNormal), vec3(0.0));\n    float irradZLum = max(Color_Luminance(irradZ), 1e-8);\n    \n    float luminanceSH[9];\n    SH_ToLuminance(env, luminanceSH);\n\n    HLSH hlsh = SH_ProjectToHLSHConeMultiply(luminanceSH, coneNormal, coneCosAlpha);\n    hlsh.Ca /= irradZLum;\n    hlsh.Cdd /= irradZLum;\n    \n    // Note that Ca is also given by 1.0 - dot(hlsh.Cdd, coneNormal),\n    // (or the equivalent scaled by irradZLum), so can be reconstructed in a pixel shader \n    // after interpolation.\n    \n    return irradZ * HLSH_Eval(hlsh, normal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord.y = iResolution.y - fragCoord.y;\n\n    float phi = 2.0 * PI * iMouse.x / iResolution.x - PI;\n    float theta = clamp(PI * iMouse.y / iResolution.y, 0.001, PI - 0.001);\n    float sinTheta = sin(theta);\n    vec3 forward = vec3(sinTheta * cos(phi), cos(theta), sinTheta * sin(phi));\n    \n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = cross(right, forward);\n    mat3 cam = mat3(right, up, forward);\n\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(p.x, -p.y, 1.0));   \n    vec3 color = drawBackground ? SH_EvalRadiance(environment, rd) : vec3(0.0);\n    \n    float boxSize = min(iResolution.x / 3.0, iResolution.y / 2.0);\n    const float sphereRadius = 0.46;\n    const float sphereRadiusSq = sphereRadius * sphereRadius;\n    \n    vec2 margin = 0.5 * vec2(iResolution.x - 3.0 * boxSize, iResolution.y - 2.0 * boxSize);\n    vec2 coord = fragCoord - margin;\n    \n    float boxX = floor(coord.x / boxSize);\n    float boxY = floor(coord.y / boxSize);\n    coord.x -= boxX * boxSize;\n    coord.y -= boxY * boxSize;\n    \n    float boxNumber = 2.0 * boxX + boxY;\n    if (clamp(boxX, 0.0, 2.0) != boxX || clamp(boxY, 0.0, 1.0) != boxY) {\n        boxNumber = -1.0;\n    }\n   \n    vec2 uv = coord / boxSize; \n    vec2 spherePoint = (uv - 0.5) / sphereRadius;\n\n    float rSq = dot(spherePoint, spherePoint);\n\n    if (rSq <= 1.0) {\n        vec3 hemiNormal = cam * vec3(0, 0, -1);\n        vec3 localNormal = vec3(spherePoint.x, -spherePoint.y, -sqrt(1.0 - rSq));\n        vec3 worldNormal = cam * localNormal;\n    \n        if (boxNumber == 0.0) {\n            // Top-left: SH without a hemisphere multiply.\n            color = SH_EvalIrradiance(environment, worldNormal);\n        } else if (boxNumber == 1.0) {\n            // Bottom-left: SH with a hemisphere multiply.\n            \n            mat3 flipZ = mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, -1));\n            mat3 rotationMatrix = flipZ * transpose(cam);\n            \n            vec3 rotatedSH[9];\n            SH_Rotate(environment, rotationMatrix, rotatedSH);\n            \n            vec3 hemiMultipliedSH[9];\n            SH_MulCone(rotatedSH, coneCosAlpha, hemiMultipliedSH);\n            \n            color = SH_EvalIrradiance(hemiMultipliedSH, vec3(localNormal.xy, -localNormal.z));\n        } else if (boxNumber == 2.0) {\n             // Top-centre: RGB HHD (SH3 -> hemi multiply -> SH2 -> HHD).\n             color = HHD_EvalIrradiance(environment, worldNormal, hemiNormal);\n        } else if (boxNumber == 3.0) {\n            // Bottom-centre: RGB HLSH (SH3 -> hemi-multiplied HLSH).\n            color = HLSH_EvalIrradiance(environment, worldNormal, hemiNormal, coneCosAlpha);\n        } else if (boxNumber == 4.0) {\n             // Top-right: Luminance HHD (SH3 -> luminance -> hemi multiply -> SH2 -> HHD).\n             color = HHD_EvalIrradianceLuminance(environment, worldNormal, hemiNormal);\n        } else if (boxNumber == 5.0) {\n             // Bottom-right: Luminance HLSH (SH3 -> luminance -> hemi-multiplied HLSH).\n             color = HLSH_EvalIrradianceLuminance(environment, worldNormal, hemiNormal, coneCosAlpha);\n        } \n    }\n\n\tfragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}