{"ver":"0.1","info":{"id":"lftBD4","date":"1733261757","viewed":47,"name":"Cellular noise in a hex grid","username":"stegu","description":"Not actually a hex grid, but a staggered grid with hex-style adjacency. The pattern looks less regular than for a square grid with small jitters. Note the anti-aliasing of Voronoi edges that dodges F2 being wrong in many places inside cells.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley","cellular"],"hasliked":0,"parentid":"4ctBz8","parentname":"Cellular \"noise\" demo (2D)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float aastep(float a, float x) {\n    float fw = 0.7*fwidth(x-a);\n    return smoothstep(-fw, fw, x-a);\n}\n\n// Make a kind-of random RGB color from a modulo-289 integer ID\nvec3 rgbh(float h) {\n    return vec3(1.0-mod(h,7.0)/8.0, 0.9-mod(h,49.0)/64.0, 1.0-h/288.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/min(iResolution.x, iResolution.y);\n\n    vec2 F;\n    vec2 P1, P2;\n    float ID1, ID2;\n    vec3 col;\n    \n    F = cellularhex(uv*8.0, 0.5*sin(iTime), P1, P2, ID1, ID2); // try animating the jitter here!\n\n    if(uv.x < 0.0) {\n        // AA of cell edges: mix in 2nd neighbor's color near the edge\n        // (the \"aastep\"), and because the 2nd neigbor is often wrong,\n        // mask the mix to operate only near edges (the \"step\").\n        float aamask = (1.0-aastep(0.0, F.y-F.x)) * step(-0.1,F.x-F.y);\n        col = mix(rgbh(ID1), rgbh(ID2), aamask);\n        col = mix(vec3(1.0), col, aastep(0.05,F.x)); // White dots\n    }\n    else {\n        // The classic \"crystals\" pattern, with color to make use of ID1\n        col = sqrt(F.y-F.x)*rgbh(ID1);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Cellular noise (\"Worley noise\") in 2D.\n// Version 2024-11-29, by Stefan Gustavson.\n// Published under the CC-BY-SA 4.0 license:\n// https://creativecommons.org/licenses/by-sa/4.0/\n\n// Cellular noise, returning F1 and F2 in a vec2,\n// the offset from P to the nearest point P1\n// in an \"out\" parameter vec2 P1, and the hashed\n// Voronoi cell ID in an \"out\" parameter float ID1.\n// Hex-like grid, but with integer coordinates.\n// 11-cell search window for good F1 and F2 values.\n//\n// Straightforward code written to be easy to read\n// rather than optimally fast. Still not dead slow.\n\nfloat permute289(float x) {\n  return mod((34.0 * x + 10.0) * x, 289.0);\n}\n\nvec2 cellularhex(vec2 P, float jitter,\n        out vec2 P1, out vec2 P2, out float ID1, out float ID2)\n{\n    jitter = clamp(jitter,-1.0,1.0);\n    float halfj = 0.5*jitter;\n    vec2 P0 = floor(P);\n    vec2 Pi = P0;\n    float oddy = mod(Pi.y, 2.0); // 1.0 for odd y, 0.0 for even y\n    // Expand Pi by 2 along x to allow integer indexing with stagger\n    Pi.x = Pi.x * 2.0 + oddy; // Scale x index by 2 and stagger\n\tPi = mod(Pi, 289.0);\n    P0.x = P0.x + 0.5 * oddy; // Stagger x coord\n\tvec2 Pf = P0-P; // Vector from P to unjittered P0 in same grid cell\n\tfloat px, pxy;\n\tfloat d, d1, d2;\n\tfloat ox, oy, dx, dy;\n\td1 = d2 = 8.0; // Init to distances larger than any actual outcome\n    // Middle row of three cells: same stagger and same y as P0\n\tfor(float ix = -2.0; ix <= 1.0; ix++) {\n\t\tpx = permute289(Pi.x + 2.0*ix); // indexing is scaled in x\n\t\tpxy = permute289(px + Pi.y);\n        float psi = pxy*0.07482; // Scale the hash (and jumble it some more)\n        // Generate a displacement vector (ox,oy) of maximum length\n        ox = cos(psi); // sin and cos are usually fast these days\n        oy = sin(psi);\n        float sqc = 0.5 / max(abs(ox), abs(oy));\n        ox = ox * sqc; // \"Square the circle\"\n        oy = oy * sqc; // (push points to the edge of a square)\n\t\tdx = Pf.x + ix + jitter*ox + 0.5;\n\t\tdy = Pf.y + jitter*oy + 0.5; // same y\n\t\td = dx*dx + dy*dy; // Distance from P to Pn, squared\n        // d could replace either d1 or d2, handle both cases\n        P2 = (d <= d1 ? P1 : (d<= d2 ? vec2(dx, dy) : P2));\n        ID2 = (d <= d1 ? ID1 : (d<= d2 ? pxy : ID2));\n        d2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n\t\tP1 = (d <= d1 ? vec2(dx,dy) : P1);\n\t\tID1 = (d <= d1 ? pxy : ID1);\n\t\td1 = (d <= d1 ? d : d1);\n\t}\n    // Top and botton row of two cells each: offset 0.5 in x\n\tfor(float ix = -1.0; ix <= 2.0; ix++) { // 0.0 to 1.0 for small jitters\n\t\tpx = permute289(Pi.x + 2.0*ix - 1.0);\n        for(float iy = -1.0; iy <= 1.0; iy += 2.0) { // only -1 and 1\n            pxy = permute289(px + Pi.y + iy);\n            float psi = pxy*0.07482; // Scale the hash (and jumble it some more)\n            // Generate a displacement vector (ox,oy) of maximum length\n            ox = cos(psi); // sin and cos are usually fast these days\n            oy = sin(psi);\n            float sqc = 0.5 / max(abs(ox), abs(oy));\n            ox = ox * sqc; // \"Square the circle\"\n            oy = oy * sqc; // (push points to the cell edge)\n            dx = Pf.x + ix + jitter*ox;\n            dy = Pf.y + iy + jitter*oy + 0.5;\n            d = dx*dx + dy*dy; // Distance from P to Pn, squared\n            // d could replace either d1 or d2, handle both cases\n            P2 = (d <= d1 ? P1 : (d<= d2 ? vec2(dx, dy) : P2));\n            ID2 = (d <= d1 ? ID1 : (d<= d2 ? pxy : ID2));\n            d2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n            P1 = (d <= d1 ? vec2(dx,dy) : P1);\n            ID1 = (d <= d1 ? pxy : ID1);\n            d1 = (d <= d1 ? d : d1);\n        }\n\t}\n\treturn(sqrt(vec2(d1, d2)));\n}\n","name":"Common","description":"","type":"common"}]}