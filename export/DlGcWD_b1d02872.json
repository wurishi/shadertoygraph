{"ver":"0.1","info":{"id":"DlGcWD","date":"1701334728","viewed":34,"name":"Voxel Raymarching 101","username":"huangziji","description":"3d","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x,0.,1.)\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(in vec3 pos)\n{\n    vec4 sph = vec4(0.0,0.0,0.0,7.5);\n    ivec3 ipos = ivec3(floor(pos));\n    int size = 32;\n    for (; size>0;size>>=1) {\n        vec3 ce = vec3(ipos - ipos%size) + float(size>>1);\n        float d1 = sdBox(ce-sph.xyz, vec3(size>>1)) - sph.w;\n        if (d1 > 0.) break;\n    }\n    return float(size);\n}\n\nfloat sum(vec3 v) { return dot(v, vec3(1.0)); }\n\nbool getVoxel(vec3 pos) { return map(pos) < 1.; }\n\nfloat vertexAo(vec2 side, float corner) {\n\t//if (side.x == 1.0 && side.y == 1.0) return 1.0;\n\treturn (side.x + side.y + max(corner, side.x * side.y)) / 3.0;\n}\n\nvec4 voxelAo(vec3 pos, vec3 d1, vec3 d2) {\n\tvec4 side = vec4(getVoxel(pos + d1), getVoxel(pos + d2), getVoxel(pos - d1), getVoxel(pos - d2));\n\tvec4 corner = vec4(getVoxel(pos + d1 + d2), getVoxel(pos - d1 + d2), getVoxel(pos - d1 - d2), getVoxel(pos + d1 - d2));\n\tvec4 ao;\n\tao.x = vertexAo(side.xy, corner.x);\n\tao.y = vertexAo(side.yz, corner.y);\n\tao.z = vertexAo(side.zw, corner.z);\n\tao.w = vertexAo(side.wx, corner.w);\n\treturn 1.0 - ao;\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd)\n{\n    vec3 pos = ro;\n    float t=0.;\n    vec3 mask=vec3(0.0);\n    while (t < 30.) {\n        float size = map(pos);\n        if (size < 1.) break;\n\n        vec3 sideDist = (max(sign(rd),0.0)*size - mod(pos,size)) / rd;\n        mask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        float dt = min(min(sideDist.x, sideDist.y), sideDist.z);\n        t += dt;\n        pos += rd*dt + sign(rd)*mask*0.0001;\n    }\n\n    //   vec3 sideDist = (floor(pos)-ro + max(sign(-rd),0.0))/rd;\n    return vec4(t, mask);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 uv )\n{\n    uv = (2.0*uv-iResolution.xy)/iResolution.y;\n    float m = iTime;//iMouse.x/iResolution.x*6.5;\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ro = vec3(12.0*sin(m), 2.0*sin(iTime*2.6), 12.0*cos(m))*1.5;\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(uv, 1.2));\n\n    vec4 t = castRay(ro, rd);\n    vec3 col = vec3(0.0);\n    if (t.x < 30.) {\n\n        vec3 mask = t.yzw;\n        vec3 pos = ro + rd*t.x + mask*sign(rd)*.001;\n        vec4 ao = voxelAo(floor(pos)-sign(rd)*mask, mask.zxy, mask.yzx);\n        vec2 uv = fract(vec2(sum(mask*pos.yzx), sum(mask*pos.zxy)));\n        float occ = mix(mix(ao.z, ao.w, uv.x), mix(ao.y, ao.x, uv.x), uv.y);\n        occ = pow(occ, 1.0 / 3.0);\n\n        vec3 sun_dir = normalize(vec3(1.0,2.0,-3.0));\n        float sun_dif = saturate(dot(mask, sun_dir))*.9+0.1;\n        col += vec3(0.8,0.6,0.3)*sun_dif*occ;\n        col += vec3(0.3,0.5,1.0)*.05;\n    } else {\n        col = vec3(0.3,0.5,1.0) - rd.y*0.4;\n    }\n    \n    col = sqrt(col);\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}