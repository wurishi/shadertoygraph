{"ver":"0.1","info":{"id":"mlBXDw","date":"1727175262","viewed":29,"name":"eyes x 20  [p1]","username":"valalalalala","description":"This is the second part of the 20 eyes project","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["eyes"],"hasliked":0,"parentid":"dlSSDW","parentname":"eyes x 20 [p0]"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        //////////////////////////////////////////////////////////////////////\n       //                                                                 ////\n      // \"twenty eyes [p1]\"                                              // //\n     //                                                                 //  //\n    // working up to the full concept a bit at a time...               //   //\n   // Leveraging the beauty of MltcDB to create abominations!         //    //\n  //                                                                 //     //\n //                                                                 //     //\n/////////////////////////////////////////////////////////////////////     //\n//                                                                 //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike           //   //\n// 3.0 Unported License                                            //  //\n//                                                                 // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                               ////\n//                                                                 ///\n/////////////////////////////////////////////////////////////////////\n\n\nfloat tTime, bTime, dTime, oTime; // .2, 2x and 4x clocks\n\n/////////////////////////////////////////////////////////////////////\n\nconst int EYE = 1;\nconst int FACE = 2;\nconst int LIPS = 3;\nconst int LIDS = 4;\nconst int HAIR = 5;\n\n//#define length langth // use approximation\n\n/////////////////////////////////////////////////////////////////////\n\n\nfloat fLineSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p) -r;\n}\n\n//based off fLineSegment + madness\nfloat linor(vec3 p, vec3 a, vec3 b, float r1, float r2, float power ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    float r = mix( r1, r2, pow( t, power ) );\n    return length((ab*t + a) - p) -r;\n}\nfloat linor(vec3 p, vec3 a, vec3 b, float r1, float r2 ) {\n    return linor( p, a, b, r1, r2, EINS );\n}\n\n// polynomial smooth min (k = 0.1); iq\nfloat smin( float a, float b, float k ){\nif(keyToggle(13,iChannel1)) return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smin( float a, float b ) {\n    return smin( a, b, .1 );\n}\n\n// https://www.shadertoy.com/view/MltcDB\nfloat ellipsoid(vec3 p, vec3 r){\n    float lg = length(p /(r * r));\n\treturn (length(p / r) - 1.) * (length(p / r)) / lg;\n\t//return (length(p / r) - 1.) * (r.x + r.y + r.z) / 3.;//max(max(r.x, r.y), r.z);\n}\n\nfloat sphere( vec3 p, vec3 center, float radius ) {\n    return length( p - center ) - radius;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nfloat eyeDistance( vec3 p, float pad ) {\n    vec3 center = V000;\n    float ed = 3e3;\n\n    float e = .02;\n    float apart = 5.1;\n    \n    p.y += .044;\n    \n    // hacky rotation\n    p.y -= e * 14.;\n    p.z -= .310 + p.y * .2 - .24 * abs( abs( p.x ) - .07 ); \n\n    vec3 pl = p - x3( apart * e );        \n    vec3 pr = p + x3( apart * e );\n\n    // this will gives 18 of the 20 eyes\n    pl.xy = REPLIM( pl.xy, e * 2.2, vec2(1.),vec2(+1.));\n    pr.xy = REPLIM( pr.xy, e * 2.2, vec2(1.),vec2(+1.));   \n\n    ed = min( ed, sphere( pl, center, e * pad ) );\n    ed = min( ed, sphere( pr, center, e * pad ) );\n    \n    // finally we have 20 eyes to put into our head!\n    p.x = abs( abs( p.x ) - 9.2 * e );\n    p.z += .012;\n    ed = min( ed, sphere( p, center, e * pad ) );\n\n    return ed;\n}\n\nfloat eyeDistance( vec3 p ) {\n    return eyeDistance( p, 1. );\n}\n\nfloat lipDistance( vec3 p, float thickness ) {\n    p.y -= .019;\n    \n    vec3 px = p; \n    px.x = abs( px.x );\n\n    vec3 up = px;\n    up.y += up.x * .22;\n    vec3 dn = px;\n    dn.y -= dn.x * .14;\n\n    float upl = ellipsoid( up - vec3( .014, .064, .248 ), vec3( .032, .019, .04 ) * thickness ); // upper lip\n    float dnl = ellipsoid( dn - vec3( .000, .042, .246 ), vec3( .053, .021, .04 ) * thickness ); // lower lip\n    \n    return smin( upl, dnl, .0047 );\n}\n\nfloat lipDistance( vec3 p ) {\n    return lipDistance( p, 1. );\n}\n\n// huge depth to MltcDB\nfloat faceDistance( vec3 p ) {\n    vec3 px = p; \n    px.x = abs( px.x );\n\n    float d = 3e3;\n    \n    #if 0\n        d = sphere( p, y3( .39 ), .33 );  // front of head\n        d = smin( d, sphere( p,  vec3( ZED, .40,-.11 ), .36 ), .02 ); // back of head\n        d = smin( d, sphere( p,  vec3( ZED,-.04, .18 ), .04 ), .33 ); // chin\n        d = smin( d, sphere( px, vec3( .15, .12, .16 ), .05 ), .20 ); // cheek\n        d = smin( d, sphere( px, vec3( .06, .03, .02 ), .03 ), .20 ); // jaw\n    #else\n        d = sphere( p, vec3( ZED, .34, .01 ), .31 );  // front of head  \n        d = smin( d, sphere( p, vec3( ZED, .342, -.07 ), .33 ), .02 ); // back of head\n        d = smin( d, sphere( p,  vec3( ZED,-.02, .18 ), .03 ), .31 ); // chin\n        d = smin( d, sphere( px, vec3( .155, .14, .18 ), .030 ), .20 ); // cheek\n        d = smin( d, sphere( px, vec3( .12, .1 * .507, .1 * .583 ), .007 ), .16 ); // jaw\n    #endif\n    \n    vec3 e = px; e.x -= .3 * e.y; e.z += .09 * e.y; // lazy rotation\n    d = smin( d, ellipsoid( e - vec3( .24, .21,-.06 ), vec3( .027, .07, .06 ) ), .013 ); // ears\n    \n    d = smin( d, ellipsoid( p - vec3( ZED, .09, .21 ), vec3( .090, .091, .07) ), .01 ); // mouth barrel    \n    d = smin( d, lipDistance( p, .95 ), .005 ); // bring in lips\n  \n    //d = smin( d, linor( p, vec3( ZED, .41, .27 ), vec3( ZED, .15, .31 ), .021, .033 ), .042 ); // nose\n    float base   = ellipsoid( p - vec3( ZED, .14, .31 ), vec3( .03, .01, .02 ) );\n    float bridge = linor( p, vec3( ZED, .44, .27 ), vec3( ZED, .15, .31 ), .005, .013, 4. );\n    float nose = smin( base, bridge, .042 );\n    d = smin(d, nose, .03 );// nose\n    \n    d = smin( d, linor( px, vec3( .06, .40, .24 ), vec3( .1931, .41, .14 ), .015, .012 ), .1 ); // brows   \n    \n    // eyesockets and blinking\n    float eye = eyeDistance( p, mix( .98, 1., .5 + bTime ) );\n    d = smin( d, eye, .013 );\n    \n    return d;\n}\n\nfloat eyebrowDistance( vec3 p ) {\n    vec3 px = p;\n    px.x = abs( px.x );\n\n    vec3 p1 = vec3( .030, .320, .318 );\n    vec3 p2 = vec3( .056, .333, .321 );\n    vec3 p3 = vec3( .095, .340, .313 );\n    vec3 p4 = vec3( .172, .328, .272 );\n\n    float d1 = linor( px, p1, p2, .008, .006, 1. );\n    float d2 = linor( px, p2, p3, .006, .005, 1. );\n    float d3 = linor( px, p3, p4, .005, .004, 1. );\n\n    return min( d1, min( d2, d3 ) );\n}\n\n// yeah... pony tail for the uber lazy\nfloat hairDistance( vec3 p ) {\n    float eb = eyebrowDistance( p );\n\n    float t = triangle( 888. * ( p.x + p.y * .3 - abs(p.z) * .2 ) ) ; \n    \n    float h = 1. + t * .001;\n    \n    float h1 = sphere( p, vec3( ZED, .37, -.09 ), .337 * h );\n    float h2 = sphere( p, vec3( ZED, .37, -.02 ), .331 * h );\n    float hr = smin( h1, h2, .02 );\n    \n    float dt = oTime ;//sign( dTime ) * pow( dTime, 2. ) -.;\n    \n    float y = p.y - .55;\n    y = y * y * (3.0 - 2.0 * y) * .3;\n    \n    vec3 bop = vec3( y * dt * .5, p.x * dt * .2, y * dt * .1 );\n    \n    h = .98 + .02 * abs( triangle( 444. * ( p.x - bop.x ) ) ); \n    \n    float p1 = sphere( p, vec3( ZED, .48, -.48 ) + bop, .12 * h );\n    float p2 = sphere( p, vec3( ZED, .32, -.54 ) + bop, .08 * h );\n    float p3 = sphere( p, vec3( ZED, .18, -.56 ) + bop, .08 * h );\n    float p4 = sphere( p, vec3( ZED, .04, -.54 ) + bop, .07 * h );\n    float p5 = sphere( p, vec3( ZED,-.08, -.52 ) + bop, .06 * h );\n\n    float pn = min( p1, min( p2, min( p3, min( p4, p5 ) ) ) );\n    \n    float pm = .02;\n    pn = smin( p1, smin( p2, smin( p3, smin( p4, p5, pm ), pm ), pm ), pm );\n    \n    hr = min( pn, hr );\n    \n    return min( hr, eb );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nMapped mapEyes( vec3 p ) {\n    vec3 center = .0*vec3( tTime, V000.yz );\n    float ed = eyeDistance( p );\n    return Mapped( ed, EYE, center );\n}\n\nMapped mapFace( vec3 p ) {\n    return Mapped( faceDistance( p ), FACE, V000 );\n}\n\nMapped mapLips( vec3 p ) {\n    return Mapped( lipDistance( p ), LIPS, V000 );\n}\n\nMapped mapLids( vec3 p ) {\n    return Mapped( eyeDistance( p, 1.01 * mix( .98, 1., .5 + bTime ) ), LIDS, V000 );\n}\n\nMapped mapHair( vec3 p ) {\n    return Mapped( hairDistance( p ), HAIR, V000 );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nMapped map( vec3 p ) {\n    vec3 og = p;\n    \n    vec3 nj = p;\n    nj.y -= .0 * .4;\n\n    // head is up a bit from the neck\n    p = nj;\n\n    p.y += .2;\n    //head sway in time \n    float dt = sign( dTime ) * pow( dTime, 2. );\n    vec3 bop = vec3( .2 * p.y* dt, -.2 * nj.x * dt, dt );\n    //p.x += .2 * p.y  * dt;\n    //p.y -= .2 * nj.x * dt;\n    p.xy += bop.xy;\n\n    Mapped m = mapEyes( p );\n    Mapped f = mapFace( p );\n    mino( m, f );\n    mino( m, mapLips( p ) );\n    mino( m, mapLids( p ) );\n    mino( m, mapHair( p ) );\n    \n    // special case for the neck...\n    float neck = linor( nj, vec3( ZED, .12, -.11 ), vec3( ZED, -.31, -.14 ), .12, .13 );\n    neck = smin( neck, f.depth, .02 );\n    mino( m, Mapped( neck, FACE, p ) );\n\n    m.center = bop;\n    \n    return m;\n}\n\nMAP_TIME\n\nvec3 subo( vec3 p ) {\n    // https://www.shadertoy.com/view/MdXSzX\n    #define TRANSMISSION_RANGE_ .15\n    #define TRANSMISSION_RANGE .88\n    vec3 lightDir1 = normalize(vec3(3,1,-2));//normalize( V101.xzx );\n    vec3 lightDir2 = normalize(vec3(-3,1,-2));//normalize( V101.zzx );\n    vec3 lightCol1 = vec3(1.1,1,.9)*1.4;\n    vec3 lightCol2 = vec3(.8,.4,.2)*2.0;\n\n    // And sub surface scattering too! Because, why not?\n    float transmissionRange = TRANSMISSION_RANGE;//iMouse.x/iResolution.x;//distance/10.0; // this really should be constant... right?\n    float transmission1 = map( p + lightDir1*transmissionRange ).depth/transmissionRange;\n    float transmission2 = map( p + lightDir2*transmissionRange ).depth/transmissionRange;\n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n    return subsurface;\n}\n\nvec3 eyeColor( float radius, float angle ) {\n    float iR = radius;\n    float iA = angle;\n    \n    float nz = noise(  7.7 * vec2( iR, iA ) );\n    float iT = triangle( 8.8 * ( iA + nz + tTime ) );\n    \n    float iB = mix( pow( 4. * nz , 2. ), iT, iT + nz ); // ridges\n    \n    vec3 color = V101.yzy;\n    \n    const vec3 iris_middle = vec3( .33, .33, .66 );\n    const vec3 iris_inner = vec3( .66, .33, .88 );\n    const vec3 iris_outer = vec3( .11, ZED, .11 );\n\n    float inner = smoothstep(0.1, 0.7, iR);\n    float outer = smoothstep(0.72, 1.05, iR);\n\n    color = iris_middle;\n    color = mix( color, iris_outer, outer );\n    color = mix( iris_inner, color, inner );\n    color *= 2.* mix( .33, 1., iB );\n    return color;\n}\n\n// help from https://www.shadertoy.com/view/3t2Szh\nvec3 eyeColor( in Ray ray, in Marched marched, in vec3 n, in vec3 look ) {\n    vec3 p = marched.p;\n    vec3 center = marched.mapped.center;\n\n    // these 3 magic numbers are strongly tied :-/\n    float iris = .95;\n    float pupil = iris * mix( 1.05, 1.04, clamp( tTime, ZED, EINS ) );   \n    \n    vec3 on = normalize( look - center );\n    float angle = dot( n, on );\n    \n    if ( angle < ZED || angle < iris ) return vec3( 2.2 * dot( n, -ray.dir ) );\n    if ( angle > pupil ) return V000;\n    \n    float iR = ( pupil - angle ) / ( pupil - iris );\n    float iA = atan( n.x - on.x, n.y - on.y );\n      \n    return eyeColor( iR, iA );\n}\n\nvec3 eyes20( in vec2 st ) {\n    INIT_SHADER_ENVIRONMENT(st)\n    \n    tTime = triangle( iTime * .2 );\n    bTime = triangle( iTime * 2. );\n    dTime = triangle( iTime * 4. );\n    oTime = triangle( iTime * 4. + .25 * TAU );\n    \n    vec3 color;\n    Ray ray = rayToggle( env, makeRay( env ), iChannel1 );\n    Marched marched = march( ray );\n\n    if ( marched.hit ) {\n        vec3 p = marched.p;\n        vec3 q = p + vec3( marched.mapped.center.xy, ZED );\n        \n        vec3 n = mapNormal( p, marched.depth );\n        float l = dot( n, -ray.dir );\n        \n        switch ( int( marched.mapped.type ) ) {\n            case EYE:\n                color = eyeColor( ray, marched, n, vec3( env.ms, 1. ) );\n\n                //eyes are so small there's not much point in this LOD\n                #if 0\n\n                //n += 3.3 * noise_iq( 3.3 * order( abs( p + tTime ) ).xy );\n\n                vec3 rDir = reflect( ray.dir, n );\n                float fresnel = saturate( pow( EINS + l, 5. ) );\n\n                float subsurface = .11;\n                float reflection = .33;\n\n                color = mix( color, subo( p ), subsurface );\n                color = mix( color, texture( iChannel0, rDir ).rgb, reflection * fresnel );\n                #endif\n                break;\n            case FACE:\n                float spk = noise( 88.*( q.xy + q.z * .5 ) );\n                spk = spk*spk*(3.-2.*spk);\n                color = vec3( .9, .8, .6 );\n                color = mix( color, .77 * color, spk );\n                color *= l * l;\n \n                color = mix( color, subo( p ), .11 );\n                break;\n            case LIPS:                \n                color = l * l * vec3( .5, .04, .05 );\n                break;\n            case LIDS:\n                color = l * l * l * vec3( .7, .6, .8 );\n                break;\n            case HAIR:\n                color =  l * l * .33 * vec3( .7, .6, .8 );\n                break;\n        }\n   \n        \n    } else {\n        float r = length( env.uv );\n        float i = ( r - .22 ) / .77;\n        \n        color = mix( V000, \n            mix( \n                eyeColor( i, atan( env.uv.y, env.uv.x ) ), \n                V101.zzz * 3.3 * invert( r - .44 ),\n                step( .8, r )\n            ),\n            step( .22, r ) \n        );\n    }\n    \n    return color;\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 result, in vec2 st ){ \n    result = vec4( eyes20( st ), 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873., ZED = .0, HALB = .5, EINS = 1., PI  = HALB * TAU;\n\nconst vec3 V101 = vec3( -EINS, ZED, +EINS ), V000 = vec3( ZED );\n\nconst float EPSILON = .001, ZFAR = 199., VIEW_DISTANCE = 2.;\nconst vec3 MAGIC = vec3( TAU * 3.3, 99.733, 15873. );\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / min( resolution.x, resolution.y );\n}\n\nfloat absMod( float f, float m ) {\n    return abs( mod( f, m ) - m *.5 );\n}\n\nfloat scalo( float f, float s ) {\n    return f * s - .5 * s;\n}\n\nfloat invert( float f ) {\n    return 1. - f;\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n\nvec3 x3( float x ) { return vec3( x, V000.yz ); }\nvec3 y3( float y ) { return vec3( ZED, y, ZED ); }\nvec3 z3( float z ) { return vec3( V000.xy, z ); }\n\n/////////////////////////////////////////////////////////////////////\n\n#define saturate(x) clamp(x, ZED, EINS)\n#define MODO(v,f) ( mod( v + .5 * f, f ) - .5 * f )\n\n// more iq magic...\n#define REPLIM(p,s,limmin,limmax) ((p)- (s)*clamp(round((p)/(s)),-limmin,limmax))\n\n/////////////////////////////////////////////////////////////////////\n\nfloat magicFloat( vec2 uv ) {\n    return dot( uv, MAGIC.xy );\n}\n\n// really a lot like just regular fract based hash :-P\nfloat triangleHash( float f ) {\n    return fract( triangle( f * MAGIC.x ) * f * MAGIC.z * .133 );\n}\n\nfloat triangleHash( vec2 uv ) { \n    return triangleHash( magicFloat( uv ) );\n}\n\n////////////////////////////////////////////////////////////////\n// IQ's https://www.shadertoy.com/view/XdXGW8, gradient - 2D \n\nvec2 hash( in vec2 p ) {\n    return vec2( triangleHash( p.xy ), triangleHash( p.yx ) );\n}\n\nfloat noise_iq( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( in vec2 p ) {\n    return noise_iq( p );\n}\n\nvec4 fbm( vec2 uv ) {\n    vec4 f = vec4( noise( uv * 1. ), noise( uv * 2. ), noise( uv * 4. ), .0 );\n    f.w = dot( f.xyz, vec3( 1., .5, .25 ) );\n    return f;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n#define qcos( x ) triangle( x )\n#define qsin( x ) triangle( x + TAU * .25 )\n\nvec2 trig( float angle ) {\n    return vec2( cos( angle ), sin( angle ) );\n}\n\nmat2 rotate2d( in float angle ) {\n    vec2 t = trig( angle );\n    return mat2( t.x, -t.y, t.y, t.x );\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 order( vec3 p )  {\n    vec3 q = vec3( min( p.x, min( p.y, p.z ) ), .0, max( p.x, max( p.y, p.z ) ) );\n    q.y = ( p.x + p.y + p.z ) - ( q.x + q.z );\n    return q;  \n}\n\nvec2 order( vec2 p ) {\n    return vec2( min( p.x, p.y ), max( p.x, p.y ) );\n}\n\nfloat langth( vec3 p ) {\n    return dot( order( abs( p ) ), vec3( 0.25, 0.51, 0.79 ) ) * 1.06 + -0.0011;\n    //return dot( order( abs( p ) ), vec3( 0.25, 0.49, 0.74 ) ) * 1.11 + -0.0020;\n    //return dot( order( abs( p ) ), vec3( .2, .4, .9 ) );\n}\n\nfloat langth( vec2 p ) {\n    return dot( order( abs( p ) ), vec2( 0.41, 0.88 ) ) * 1.06 + -0.0004;\n    //return langth( vec3( ZED, p ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nbool keyToggle( int key, sampler2D keyboardChannel ) {\n    return .0 < texelFetch( keyboardChannel, ivec2(key,2), 0 ).x;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nconst int MOUSE_UP = -1, MOUSE_DOWN = 1, MOUSE_CLICKED = 2;\n\nstruct ShadEnv {\n    vec3      iResolution;           // viewport resolution (in pixels) \n    float     iTime;                 // shader playback time (in seconds)\n    float     iTimeDelta;            // render time (in seconds)\n    float     iFrameRate;            // shader frame rate\n    int       iFrame;                // shader playback frame\n    float     iChannelTime[4];       // channel playback time (in seconds)\n    vec3      iChannelResolution[4]; // channel resolution (in pixels) \n    vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n    vec4      iDate;                 // (year, month, day, time in seconds)\n    float     iSampleRate;           // sound sample rate (i.e., 44100)\n    vec2      st;                    // aka fragCoord\n    vec2      uv;\n    vec2      ms;\n    vec2      trigTime;\n    int       mouseStatus;\n    float     pixel1;\n};\n\n#define INIT_SHADER_ENVIRONMENT(st) ShadEnv env = ShadEnv( iResolution, iTime, iTimeDelta, iFrameRate, iFrame, iChannelTime, iChannelResolution, iMouse, iDate, iSampleRate, st, V101.xy, V101.xy, V101.xy, MOUSE_UP, EINS );     init( env ); \n\nvoid init( inout ShadEnv env ) {\n    env.uv = pixelToUv( env.st, env.iResolution.xy );\n    env.trigTime = trig( env.iTime );\n    env.mouseStatus = MOUSE_UP + int( 2. * step( 3e-3, env.iMouse.z ) + step( 3e-3, env.iMouse.w ) );\n    env.ms = pixelToUv( env.iMouse.xy, env.iResolution.xy ) * step( 3e-3, env.iMouse.z + env.iMouse.w );\n    env.pixel1 = max( EINS / env.iResolution.x, EINS / env.iResolution.y ); \n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Ray { \n    vec3 eye; \n    vec3 dir; \n};\n\n// 1 is front, 2 is left, 3 is top\nRay rayToggle( in ShadEnv env, in Ray ray, in sampler2D keyboardChannel ) {\n    if ( keyToggle( 49, keyboardChannel ) ) {\n        // 1: side\n        ray.eye = VIEW_DISTANCE * V101.yyz;\n        ray.dir = normalize( vec3( env.uv, -EINS ) - ray.eye );\n    } else \n    if ( keyToggle( 50, keyboardChannel ) ) {\n        // 2: side\n        ray.eye = VIEW_DISTANCE * V101.xyy;\n        ray.dir = normalize( vec3( EINS, env.uv.yx ) - ray.eye );       \n    } else \n    if ( keyToggle( 51, keyboardChannel ) ) {\n        // 3: top\n        ray.eye = VIEW_DISTANCE * V101.yzy;\n        ray.dir = normalize( vec3( env.uv.x, -EINS, -env.uv.y ) - ray.eye );\n    } else\n    if ( keyToggle( 52, keyboardChannel ) ) {\n        // 4: 3 quarter ok... this is not right, but close enuff for now\n        ray.eye = VIEW_DISTANCE * V101.zyz;\n        ray.dir = normalize( vec3( ZED, env.uv.yx ) * .6 - ray.eye );   \n    } else\n    if ( keyToggle( 53, keyboardChannel ) ) {\n        // 5: back\n        ray.eye = VIEW_DISTANCE * V101.yyx;\n        ray.dir = normalize( vec3( env.uv, EINS ) - ray.eye );\n    }\n    \n    return ray;\n}\n\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nRay makeRay( in ShadEnv env, float depth ) {\n    vec2 t = trig( env.ms.x * PI );\n    vec3 eye = depth * vec3( t.y, sin( env.ms.y * 1.88 ), t.x );    \n    vec3 dir = normalize( makeCamera( eye, V000, ZED ) * vec3( env.uv, EINS ) - eye);\n    \n    return Ray( eye, dir );\n}\n\nRay makeRay( inout ShadEnv env ) {\n    return makeRay( env, VIEW_DISTANCE );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Mapped {\n    float depth;\n    int type;\n    vec3 center; // for eyes\n};\n\nstruct Marched {\n    vec3 p;\n    float depth;\n    bool hit;\n    Mapped mapped;\n};\n\nconst int MARCH_CONTINUE = 0, MARCH_SUCCESS = 1, MARCH_FAILED = 2;\n\n///////////////////////////////////////\n\nMapped newMapped( float depth ) { return Mapped( depth, -1, V000); }\nMapped newMapped() { return newMapped( 3e11 ); }\n\nMarched newMarch( Ray ray ) {\n    return Marched( ray.eye, ZED, false, newMapped( ZED ) );\n}\n\n///////////////////////////////////////\n\nvoid mino( inout Mapped m, in Mapped q ) {\n    if ( q.depth < m.depth ) {\n        m = q;\n    }\n}\n\n///////////////////////////////////////\n\nint _marchStep( in Ray ray, in float side, inout Marched marched, Mapped mapped ) {\n    marched.mapped = mapped;\n    marched.mapped.depth *= side;\n    marched.depth += marched.mapped.depth;\n        \n    if ( abs( marched.mapped.depth ) < EPSILON ) {\n        marched.hit = true;\n        return MARCH_SUCCESS;\n    }\n        \n    if ( marched.depth > ZFAR ) return MARCH_FAILED;\n    \n    marched.p = ray.eye + marched.depth * ray.dir;\n    return MARCH_CONTINUE;\n}\n\nMarched _marchMissed( in Marched marched ) {\n    marched.depth = -abs( marched.depth );\n    return marched;\n}\n\n///////////////////////////////////////\n\nMapped map( vec3 p ); // implement this, then use this macro: MAP_TIME\n\n#define MAP_TIME \\\nfloat mapDepth( vec3 p ) { return map( p ).depth; } \\\nvec3 mapNormal(vec3 p,float d) {\\\n    mat3 k = mat3(p,p,p) - mat3( d * EPSILON ); \\\n    return normalize( mapDepth(p) - vec3( mapDepth(k[0]), mapDepth(k[1]), mapDepth(k[2])) ); \\\n} \\\nvec3 mapNormal(vec3 p) { return mapNormal(p,EPSILON); }\\\nMarched march( in Ray ray, in float side ) { \\\n    Marched marched = newMarch( ray ); \\\n    for( int i = 0 ; i < int( ZFAR ) ; i++ ) { \\\n        switch( _marchStep( ray, side, marched, map( marched.p ) ) ) { \\\n            case MARCH_SUCCESS: return marched; \\\n            case MARCH_FAILED: i = int(ZFAR); \\\n        } \\\n    } \\\n    return _marchMissed( marched ); \\\n} \\\nMarched march( Ray ray ) { return march( ray, EINS ); }\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}