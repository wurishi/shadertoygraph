{"ver":"0.1","info":{"id":"lsByWh","date":"1491866076","viewed":599,"name":"Begin Again effect","username":"KylBlz","description":"Attempting to replicate a cool effect seen on the music video for \"Begin Again\" by Knife Party\nhttps://www.youtube.com/watch?v=MQPK4q488c0\nThanks to Reinder and mplanck for scenes!","likes":10,"published":1,"flags":96,"usePreview":1,"tags":["light","effect","again","begin","smudge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this is it. All the other buffers render scenes\n\n#define steps 128\n#define d vec2(.6/iResolution.x, -.6/iResolution.x)\n#define tex(a, b) .25*(textureLod(a, b+d, 0.)+textureLod(a, b-d, 0.)+textureLod(a, b+d.yx, 0.)+textureLod(a, b-d.yx, 0.))\n\nvec3 smudge(in sampler2D iChannel, in vec2 uv, in vec2 dirlen) {\n    vec3 col = textureLod(iChannel,uv,0.).rgb, smpcol = col, o = col;\n    vec2 smp = uv, dir = normalize(dirlen)/iResolution.xx;\n    float len = length(dirlen), brightest = 0.;\n    if (len < .001) return col;\n    for (int i = 0; i < steps; i++) {\n        smp += dir;\n        smpcol = tex(iChannel, smp).rgb;\n        float brightness = length(smpcol);\n        if (float(i)/iResolution.x > len) break;\n        if (brightness > brightest && brightness > sqrt(float(i)/float(steps)*4.)) {\n            brightest = brightness;\n            col = smpcol;\n        }\n    }\n    return (length(o) < length(col))? col: o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float len = max(.0001,fract(iTime*.1)*.6-.2)*.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    int igt = int(mod(iTime*.1, 4.));\n    if (igt == 3) fragColor = vec4(smudge(iChannel0, uv, (vec2(.5)-uv)*len), 1.);\n    else if (igt == 1) fragColor = vec4(smudge(iChannel1, uv, (uv-vec2(.5,.55))*len), 1.);\n    else if (igt == 2) fragColor = vec4(smudge(iChannel2, uv, (vec2(.0,.5)-uv)*len), 1.);\n    else if (igt == 0) fragColor = vec4(smudge(iChannel3, uv, vec2(0., len)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XssSWl","filepath":"https://soundcloud.com/singlefriend/knife-party-begin-again-single-friend-chill-electro-remix","previewfilepath":"https://soundcloud.com/singlefriend/knife-party-begin-again-single-friend-chill-electro-remix","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define tex(a, b) textureLod(a, b, 0.)\n#define v3min(a) min(a.x, min(a.y, a.z))\n#define ome .999\n\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n    vec2 c=cos(angle), s=sin(angle); vec3 o = p;\n    o.yz *= mat2(c.x,s.x,-s.x,c.x);  o.xz *= mat2(c.y,s.y,-s.y,c.y);\n    return o;\n}\n\n//change to only accept white with step(.999, v3min(sXX))\nvec3 bloomblur(sampler2D channel, vec2 uv) {\n    vec3 s = tex(channel, uv).rgb, o = s, dst = vec3(.003,-.003,0.),\n    //sample level\n    s00 = tex(channel, uv + dst.xz).rgb, s01 = tex(channel, uv + dst.yz).rgb,\n\ts10 = tex(channel, uv + dst.zx).rgb, s11 = tex(channel, uv + dst.zy).rgb;\n    //only include samples further away\n    float ss00 = step(ome, v3min(s00)), ss01 = step(ome, v3min(s01)),\n          ss10 = step(ome, v3min(s10)), ss11 = step(ome, v3min(s11)),\n          smpNum = 1. + .5*(ss00 + ss01 + ss10 + ss11);\n    o += .5*(s00*ss00 + s01*ss01 + s10*ss10 + s11*ss11);\n    //sample level\n    dst *= 2.;\n    s00 = tex(channel, uv + dst.xx).rgb; s01 = tex(channel, uv + dst.xy).rgb;\n\ts10 = tex(channel, uv + dst.yx).rgb; s11 = tex(channel, uv + dst.yy).rgb;\n    //only include samples further away\n    ss00 = step(ome, v3min(s00)); ss01 = step(ome, v3min(s01));\n    ss10 = step(ome, v3min(s10)); ss11 = step(ome, v3min(s11));\n    //weight half\n    smpNum += .25*(ss00 + ss01 + ss10 + ss11);\n    o += .25*(s00*ss00 + s01*ss01 + s10*ss10 + s11*ss11);\n    return o / smpNum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tif (int(mod(iTime*.1, 4.)) != 3) return;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 rd = normalize(vec3(uv * 2. - 1., -1.));\n    rd = rotateXY(rd, vec2(-.5, iTime*.1));\n    fragColor = pow(tex(iChannel1, rd), vec4(2.));\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Venice. Created by Reinder Nijhoff 2013\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdXGW2\n//\n// My attempt to create a procedural city with a lot of lights. The city is inspired by Venice. \n// The shader is a combination of my shaders: https://www.shadertoy.com/view/Mdf3zM and \n// https://www.shadertoy.com/view/lslGDB.\n// (I have never been in Venice btw)\n//\n\n// #define SHOW_ORNAMENTS\n#define SHOW_GALLERY\n#define SHOW_LIGHTS\n#define SHOW_BRIDGES\n#define SHOW_MOON_AND_CLOUDS\n\n//----------------------------------------------------------------------\n\n#define BUMPFACTOR 0.2\n#define EPSILON 0.1\n#define BUMPDISTANCE 200.\n\n#define CAMERASPEED 10.\n\n#define BUILDINGSPACING 20.\n#define MAXBUILDINGINSET 12.\n\n#define GALLERYHEIGHT 10.5\n#define GALLERYINSET 2.5\n\nfloat time;\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*32.5454412211233);\n}\nvec2 hash2( float n ) {\n\treturn fract(sin(vec2(n,n+1.0))*vec2(11.1451239123,34.349430423));\n}\nvec3 hash3( float n ) {\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\n\treturn -1.0 + 2.0*textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tfloat  z = x.z*64.0;\n\tvec2 offz = vec2(0.317,0.123);\n\tvec2 uv1 = x.xy + offz*floor(z); \n\tvec2 uv2 = uv1  + offz;\n\treturn mix(texture( iChannel0, uv1 ,-100.0).x,texture( iChannel0, uv2 ,-100.0).x,fract(z))-0.5;\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n//----------------------------------------------------------------------\n// distance functions\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\nfloat udBox( vec3 p, vec3 b) {\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdCylinderXY( vec3 p, vec2 h ) {\n  return length(p.xy)-h.x; //max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\nfloat opU( float d1, float d2 ) {\n    return min(d2,d1);\n}\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\n//----------------------------------------------------------------------\n// building functions\n\nfloat getXoffset( float z ) {\n\treturn 20.*sin( z*0.02);\n}\n\nvec2 getBuildingInfo( in vec3 pos ) {\n\tvec2 res;\n\t// base index\t\n\tres.x = floor( pos.z/BUILDINGSPACING + 0.5 );\n\t// base z coord\n\tres.y = res.x * BUILDINGSPACING;\n\t\n\t// negative index for buildings at the right side\n\tres.x *= sign( pos.x + getXoffset(pos.z) );\n\t\n\treturn res;\n}\n\nvec4 getBuildingParams( in float buildingindex ) {\n\tvec3 h = hash3( buildingindex );\n\treturn vec4(\n\t\t20. + 4.5*floor( h.x*7. ),\t // height\n\t\th.y*MAXBUILDINGINSET,\n\t\tstep(h.z, 0.5),\t\t\t\t // sidewalk\n\t\tstep(abs(h.z-0.4),0.25)\t\t // balcony\n\t);\n}\n\nfloat baseBuilding( in vec3 pos, in float h ) {\n\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\n\t\n\tfloat res = \n\topS(\t\t\n\t\t// main building\n\t\tudBox( tpos, vec3( 8.75, h, 8.75 ) ),\n\t\t\t// windows\n\t\topS(\n\t\t\topU(\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) ),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\n\t\t\t),\n\t\t\tudBox( tpos+vec3(0.,-h,0.), vec3( 9.0, 1.0, 9.0 ) )\n\t\t)\t\t\n\t);\n\t\n\tres =\n\topU( \n\t\tres,\n\t\topI( // main building windows\n\t\t\tudBox( tpos, vec3( 8.75, h, 8.75 ) ), \n\t\t\topU(\n\t\t\t\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, h, 0.05 ) ),\n\t\t\t\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\n\t\t\t)\n\t\t)\n\t);\n\treturn res;\t\n}\n\nfloat baseGallery( in vec3 pos ) {\n\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\n\t\n\tfloat res = \n\topU(\t\n\t\topS(\n\t\t\tudBox( tpos+vec3(0.,0.,-GALLERYINSET), vec3( 8.75, GALLERYHEIGHT, 0.125 ) ),\n\t\t\topU(\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-5., tpos.z-5.), vec3( 1.6,3.,10.) ),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-8., tpos.z-5.), vec2( 1.6,10.) )\n\t\t\t)\n\t\t),\n\t\tsdTriPrism( vec3( tpos.z+3.4,-44.4+3.9*tpos.y, tpos.x), vec2( 7.5, 8.7 ) )\n\t);\n\t\n\treturn res;\t\n}\n\nfloat baseBalcony( in vec3 pos, in float h ) {\n\tfloat res = opI(\t\t\n\t\t// main building\n\t\tudBox( pos, vec3( 9.0, h, 9.0 ) ),\n\t\t\t// balcony\n\t\tsdBox( vec3( pos.x, mod(pos.y+4.5, 9.)-7.5, pos.z-5.), vec3( 40.,0.5,40.) )\n\t);\n\treturn res;\t\t\n}\n\nfloat baseBridge( in vec3 pos ) {\n\tpos.x *= 0.38;\n\tfloat res = \n\topS(\t\n\t\topU( \n\t\t\tsdBox( pos, vec3( 4., 2., 2.5 ) ),\n\t\t\tsdTriPrism( vec3( pos.x,-8.+3.*pos.y, pos.z), vec2( 4.5, 2.5 ) )\n\t\t),\n\t\tsdCylinderXY( pos+vec3( 0., 1.5, 0. ), vec2( 3.8, 3. ) )\n\t);\n\treturn res;\n}\n\n// dinstancefield definitions\n\nfloat mapSimpleTerrain( in vec3 p ) {\t\n\tp.x += getXoffset( p.z );\t\n\tp.x = -abs( p.x );\n\tvec2 res = vec2( udBox( vec3(p.x+30., p.y-1., p.z) , vec3( 20., 100.25, 99999. ) ), 1.);\n\n#ifdef SHOW_BRIDGES\n\tfloat zcenter = mod(p.z+60.,120.)-70.;\n\tres = opU( res, vec2( baseBridge( vec3( p.x, p.y, zcenter) ), 8. ) ); // bridge\n#endif\n\t\n\treturn min( res.x, p.y+10. );\n}\n\nvec2 mapTerrain( in vec3 p ) {\t\n\tvec2 buildingInfo = getBuildingInfo( p );\n\tvec4 buildingParams = getBuildingParams( buildingInfo.x );\n\t\n\tvec3 pos = p;\n\tpos.x += getXoffset( pos.z );\n\tpos.x = -abs( pos.x );\n\t\n\tvec2 res = vec2( udBox( vec3(pos.x+30., pos.y, pos.z) , vec3( 20., 0.25, 99999. ) ), 1.); // ground\n\t\n\tfloat z = buildingInfo.y;\n\tfloat zcenter = mod(pos.z+10.,20.)-10.;\n\n#ifdef SHOW_BRIDGES\n\tres = opU( res, vec2( baseBridge( vec3( pos.x, pos.y,  mod(pos.z+60.,120.)-70.) ), 8. ) ); // bridge\n#endif\n\t\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-6.0, zcenter) , 0.5 ), 3. ) ); // light\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter+0.6) , 0.35 ), 3. ) ); // light\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter-0.6) , 0.35 ), 3. ) ); // light\n\t\n\tres =  opU( res, vec2( sdCylinderXZ( vec3( pos.x+11.5, pos.y, zcenter), vec2( 0.1, 6.0) ), 4.)); // \n\t\t\t\t\t\t  \n\tpos += vec3( 28.75+buildingParams.y, 2.5, 0.);\t\t\n\tres =  opU( res, vec2( baseBuilding( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 2. ) );\n\n#ifdef SHOW_ORNAMENTS\n\tres = mix( res, opU( res, vec2( baseBalcony( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 9. ) ), buildingParams.w );\n#endif\n\t\n#ifdef SHOW_GALLERY\n\tpos.x += -8.75-GALLERYINSET;\t\t\n\tres = mix( res, opU( res, vec2( baseGallery( vec3( pos.x, pos.y, zcenter) ), 5. ) ), buildingParams.z );\n#endif\t\n\t\t\t\t\t\t\t\t\t  \n\treturn vec2( min( res.x,  11.-zcenter ), res.y );\n}\n\nfloat waterHeightMap( vec2 pos ) {\n\tvec2 posm = 0.02*pos * m2;\n\tposm.x += 0.001*time;\n\tfloat f = fbm( vec3( posm*1.9, time*0.01 ));\n\tfloat height = 0.5+0.1*f;\n\theight += 0.025*sin( posm.x*6.0 + 10.0*f );\n\t\n\treturn  height;\n}\n\n// intersection functions\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out vec3 normal ) {\n    vec3  ds = ro - sph.xyz;\n    float bs = dot( rd, ds );\n    float cs = dot(  ds, ds ) - sph.w*sph.w;\n    float ts = bs*bs - cs;\n\t\n    if( ts > 0.0 ) {\n        ts = -bs - sqrt( ts );\n\t\tif( ts>0. ) {\n\t\t\tnormal = normalize( ((ro+ts*rd)-sph.xyz)/sph.w );\n\t\t\treturn true;\n\t\t}\n    }\n\n    return false;\n}\n\nvec3 intersect( const vec3 ro, const vec3 rd ) {\n\tfloat maxd = 1500.0;\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float t = 0.0;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<140; i++ ) {\n\t\tif( abs(h)<precis || t>maxd ) break; {\n\t\t\tt += h;\n\t\t\tvec2 mt = mapTerrain( ro+rd*t );\n\t\t\th = 0.96*mt.x;\n\t\t\tm = mt.y;\n\t\t}\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nfloat intersectSimple( const vec3 ro, const vec3 rd ) {\n\tfloat maxd = 10000.0;\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ ) {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\th = mapSimpleTerrain( ro+rd*t );\n\t\t}\n    }\n\n    return t;\n}\n\nvec3 calcNormal( const vec3 pos ) {\n    vec3 eps = vec3(0.1,0.0,0.0);\n\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy).x - mapTerrain(pos-eps.xyy).x,\n           mapTerrain(pos+eps.yxy).x - mapTerrain(pos-eps.yxy).x,\n           mapTerrain(pos+eps.yyx).x - mapTerrain(pos-eps.yyx).x ) );\n}\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = mapTerrain( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvoid getSkyColor( in vec3 rd, out vec3 bgcol, out vec3 col ) {\n\tvec3 lig = normalize( vec3( -2.5, 1.7, 2.5 ) );\n\t\n\tbgcol = 1.1*vec3(0.15,0.15,0.4) - rd.y*0.4;\t\n\tbgcol *= 0.3;\n    float moon = clamp( dot(rd,lig), 0.0, 1.0 );\n\tbgcol += vec3(2.0,1.5,0.8)*0.015*pow( moon, 32.0 );\n\t\n\tcol = bgcol;\n\t\n#ifdef SHOW_MOON_AND_CLOUDS\t\n\t// moon!\n\tvec3 normal;\n\tif( intersectSphere( vec3(0., 0., 0.), rd, vec4( lig, 0.03), normal ) ) {\n\t\tfloat l = dot( normalize( vec3( 2.2, -1.9, 0.5)), normal )*(0.4+texture( iChannel2, normal.xy*0.5 ).y);\n\t\tcol += 0.2*clamp( 2.5*vec3(2.0,1.5,0.8)*clamp(l, 0.0, 1.), vec3(0.), vec3(1.) );\n\t}\t\t\t\n\t\n// cloud function by inigo: https://www.shadertoy.com/view/Mds3z2 \n\tvec2 cuv = rd.xz*(100.0)/rd.y;\n\tfloat cc = texture( iChannel2, 0.0001*cuv +0.1+ 0.0013*time ).x;\n\tcc = 0.65*cc + 0.35*texture( iChannel2, 0.0001*2.0*cuv + 0.0013*.5*time ).x;\n\tcc = smoothstep( 0.3, 1.0, 1.1*cc );\n\tcol = mix( col, 0.1*vec3(0.05,0.05,0.4), 0.99*cc );\n#endif\n}\n\n//-----------------------------------------------------\n\nvec3 path( float _time ) {\n\tfloat z = _time*CAMERASPEED;\t\n\treturn vec3( -getXoffset(z)+5.*cos(_time*0.1), 1.25, z );\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (int(mod(iTime*.1, 4.)) != 1) return;\n    time = iTime + 43.;\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\t\n    // camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x/iResolution.x;\n\ttime += off;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\t\n\tta.y *= 1.1 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.07*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\t\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\t\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\t\n\t// raymarch\n    float distSimple = intersectSimple(ro,rd);\n\tbool reflection = false;\n\t\n\tfloat dist, totaldist = 0., depth = 0.;\n\tvec3 normal, tmat, lp, lig;\n\t\n\tif( intersectPlane( ro, rd, 0., dist ) && dist < distSimple ) {\t\t\t\n\t\tro = ro+rd*dist;\n\t\ttotaldist = dist;\n\t\t\n\t\tdepth = mapTerrain(ro).x;\n\t\t\n\t\tvec2 coord = ro.xz;\n\t\tvec2 dx = vec2( EPSILON, 0. );\n\t\tvec2 dz = vec2( 0., EPSILON );\n\t\t\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\t\t\t\t\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tnormal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) / (2. * EPSILON);\n\t\tnormal.z = -bumpfactor * (waterHeightMap(coord + dz) - waterHeightMap(coord-dz) ) / (2. * EPSILON);\n\t\tnormal = normalize( normal );\n\t\t\n\t\trd = reflect( rd, normal );\n\t\treflection = true;\n\t} \n\t\n\t// intersect scene\t\n\ttmat = intersect(ro,rd);\n\ttotaldist += tmat.x;\n\t\n\t// sky\t \n\tvec3 col, bgcol;\n\tgetSkyColor( rd, bgcol, col );\n\t\t\t\n    vec3 pos = ro + tmat.x*rd;\n\t\n    if( tmat.z>-0.5 && totaldist < 500.) {\n\t\t// info building hit\n\t\tvec2 buildingInfo = getBuildingInfo( pos );\t\t\t\n\t\tvec4 buildingParams = getBuildingParams( buildingInfo.x );\n\t\t\t\n\t\tfloat z = buildingInfo.y;\n\t\tlp = vec3( 11.5*sign(buildingInfo.x)-getXoffset(z), 6.0, z );\n\t\tlig = normalize(lp-pos);\n\t\t\n\t\t// geometry\n        vec3 nor = calcNormal(pos);\n\t\t\t\t\n        // material\n\t\tvec3 mate, origmate;\n\t\tvec3 matpos = pos*0.3;\n\t\t\n#ifdef SHOW_GALLERY\n\t\tif( tmat.z == 5. )\n\t\tmate.xyz = texcube(iChannel3, matpos, nor ).xyz*0.2;\n\t\t\telse\n#endif\n\t\torigmate = mate.xyz = texcube(iChannel1, matpos, nor ).xyz*0.4;\n\t\t\n\t\tbool aboveGallery = false;\n\t\t\n\t\tif( tmat.z == 3. ) mate.xyz = 160.*vec3(1.30,1.10,0.40);\n\t\telse if( tmat.z == 2. ) mate.xyz *= \n\t\t\tclamp( 4.*texture( iChannel2, buildingInfo.x*vec2(1.4231153121) ).xyz\n\t\t\t,vec3(0.), vec3(1.) );\n\t\t\t\n\t\t// lighting\n\t\tfloat occ = calcAO( pos, nor );\n        float amb = clamp(0.5 + 0.5*nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n\t\tif( tmat.z == 5. && pos.y > GALLERYHEIGHT-2.6 ) {\n\t\t\tdif = abs(dot(nor,lig));\n\t\t\tmate.xyz = vec3(0.3,0.,0.);\n\t\t}\n\t\tdif /= dot( lp-pos,lp-pos );\n\t\t\n        float bac = max(0.2 + 0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n\t\t\n\t\tif( buildingParams.z == 1. && pos.y > GALLERYHEIGHT ) {\n\t\t\taboveGallery=true;\n\t\t}\t\t\n\t\tvec3 lcol = aboveGallery?vec3(2.9, 1.65, 0.65 ):vec3(1.30,0.60,0.40);\n\t\t\n\t\t// lights\n\t\tvec3 brdf = vec3(0.0);\n        brdf += (60.0*dif)*lcol;\n\t\tbrdf += (0.1*amb)*vec3(0.10,0.15,0.30);\n\t\tbrdf += (0.1*bac)*vec3(0.09,0.03,0.01);\n\t\t\n\t\t// surface-light interacion\n\t\tcol = (mate.xyz*brdf)*occ;\n\t\t\n\t\t// in room ?\n\t\tfloat isLeft = sign(buildingInfo.x);\n\t\t\n\t\tif( ((pos.x+getXoffset( pos.z ))*isLeft > buildingParams.y+20.25 &&\n\t\t    abs( pos.z-buildingInfo.y ) < 8.5 &&\n\t\t  \tpos.y < buildingParams.x-0.5) || false ) {\n\t\t\t\n\t\t\tvec2 roomcoord = pos.zy;\n\t\t\troomcoord.x = floor( (roomcoord.x-buildingInfo.y+5.) / 3.5 ) * 3.5 +\n\t\t\t\t\t\t  floor( (buildingInfo.y+5. ) / 10.) * 10.;\n\t\t\troomcoord.y = floor( roomcoord.y / 9. ) * 9.;\n\t\t\t\n\t\t\tif( noise( vec3(roomcoord*1.15321*isLeft, time*0.0005 ) ) > -0.1 ) {\n\t\t\t\tvec3 rlc = vec3( \n\t\t\t\t\t(buildingParams.y+3.+20.25)*isLeft-getXoffset( roomcoord.x-5. ), \n\t\t\t\t\troomcoord.y+5.5, \n\t\t\t\t\troomcoord.x-5. );\n\t\t\t\t\tvec3 ld = rlc-pos;\n\t\t\t\t\tdif = max(dot(nor,normalize(ld) ),0.0)/dot(ld,ld);\n\t\t\t\t\tcol += origmate*(dif*120.)*texture( iChannel2, roomcoord*0.1231 ).xyz;\n\t\t\t}\n\t\t}\n\n#ifdef SHOW_LIGHTS\n\t\t// and extra lights!\n\t\tfloat basez = floor( (pos.z)/2. )*2.-2.0;\n\t\tfor(int i=0; i<3; i++) {\n\t\t\tbuildingInfo = getBuildingInfo( vec3( pos.x, pos.y, basez ) );\n\t\t\t// check if building lights here\n\t\t\tif( abs( basez - buildingInfo.y ) > 8.75 ||\n\t\t\t  \tnoise( buildingInfo ) > 0.15 ) {\n\t\t\t\tbasez += 2.;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuildingParams = getBuildingParams( buildingInfo.x );\n\t\t\tvec3 rlc = vec3( (buildingParams.y-1.+20.25)*isLeft-getXoffset( basez ),\n\t\t\t\t\t\t7.7-1.5*abs(sin(basez*0.3)), basez );\n\t\t\tvec3 ld = rlc-pos;\n\t\t\tdif = max(dot(nor,normalize(ld) ),0.0)/dot(ld,ld);\n\t\t\tcol += mate.xyz*(dif*6.0)*texture( iChannel2, vec2(basez*time*0.0001)*0.1231 ).xyz;\t\n\t\t\tbasez += 2.;\n\t\t}\n#endif\n\t\n\t\tif( reflection ) {\n\t\t\tcol = mix( bgcol, col, exp(-0.00000001*pow(totaldist-dist,3.0)) );\t\t\n\t\t\tcol *= 0.9*vec3( 0.8, 0.9, 1. )*(0.5+clamp( depth*2., 0.0, 0.5));\t\t\n\t\t\tif( dist != totaldist ) totaldist = dist;\n\t\t} \n\t\tcol = mix( bgcol, col, exp(-0.00000001*pow(totaldist,3.0)) );\n\t} \n\n\t\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = clamp( col, 0.0, 1.0 );\n\t\n\tcol *= vec3(1.03,1.02,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by Reinder Nijhoff 2014\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/Xtf3zn\n//\n// car model is made by Eiffie\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\n\n#define BUMPMAP\n#define MARCHSTEPS 128\n#define MARCHSTEPSREFLECTION 48\n#define LIGHTINTENSITY 5.\n\n//----------------------------------------------------------------------\n\nconst vec3 backgroundColor = vec3(0.2,0.4,0.6) * 0.09;\n#define time (iTime + 90.)\n\n//----------------------------------------------------------------------\n// noises\n\nfloat hash( float n ) {\n    return fract(sin(n)*687.3123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n//    f += 0.0625*noise( p );\n    \n    return f/0.9375;\n}\n\n//----------------------------------------------------------------------\n// distance primitives\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( in vec3 p, in float s ) {\n    return length(p)-s;\n}\n\nfloat sdCylinder( in vec3 p, in vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------\n// distance operators\n\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\n\n//----------------------------------------------------------------------\n// Map functions\n\n// car model is made by Eiffie\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\n\nfloat mapCar(in vec3 p0){ \n\tvec3 p=p0+vec3(0.0,1.24,0.0);\n\tfloat r=length(p.yz);\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\n\tr=length(p.yz);\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\n\td=max(d,-max(p.x-0.165,r-0.24));\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\n\td=min(d,d2);\n\n\treturn d;\n}\n\nfloat dL; // minimal distance to light\n\nfloat map( const in vec3 p ) {\n\tvec3 pd = p;\n    float d;\n    \n    pd.x = abs( pd.x );\n    pd.z *= -sign( p.x );\n    \n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\n    float lh = hash( floor( pd.z/13. ) );\n    \n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\n    \n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\n   \n    if( lh > 0.5 ) {\n\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\n    }\n    \n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\n\td = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \n    \n    d = opS( d, -(p.x+8.) );\n    d = opU( d, pd.y );\n\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\n    \n    // car\n    if( ch > 0.75 ) {\n        pdc.x += (ch-0.75)*4.;\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\n\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\n \t}\n    \n    d = opU( d, 13.-pd.x );\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\n    d = opU( d, dL );\n    \n\treturn d;\n}\n\n//----------------------------------------------------------------------\n\nvec3 calcNormalSimple( in vec3 pos ) {   \n    const vec2 e = vec2(1.0,-1.0)*0.005;\n\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t    e.yyx*map( pos + e.yyx )   + \n\t\t\t\t\t    e.yxy*map( pos + e.yxy )   + \n\t\t\t\t\t    e.xxx*map( pos + e.xxx )   );  \n    return n;\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    vec3 n = calcNormalSimple( pos );\n    if( pos.y > 0.12 ) return n;\n\n#ifdef BUMPMAP\n    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );\n\n    if( abs(pos.x)<8. ) {\n\t\toc = pos.xz;\n    }\n    \n     vec3 p = pos * 250.;\n   \t vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);\n     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);\n    \n    n = normalize( xn + n );\n#endif\n    \n    return n;\n}\n\nvec3 int1, int2, nor1;\nvec4 lint1, lint2;\n\nfloat intersect( in vec3 ro, in vec3 rd ) {\n\tconst float precis = 0.001;\n    float h = precis*2.0;\n    float t = 0.;\n    int1 = int2 = vec3( -500. );\n    lint1 = lint2 = vec4( -500. );\n    float mld = 100.;\n    \n\tfor( int i=0; i < MARCHSTEPS; i++ ) {\n        h = map( ro+rd*t );\n\t\tif(dL < mld){\n\t\t\tmld=dL;\n            lint1.xyz = ro+rd*t;\n\t\t\tlint1.w = abs(dL);\n\t\t}\n        if( h < precis ) {\n            int1.xyz = ro+rd*t;\n            break;\n        } \n        t += max(h, precis*2.);\n    }\n    \n    if( int1.z < -400. || t > 300.) {\n        // check intersection with plane y = -0.1;\n        float d = -(ro.y + 0.1)/rd.y;\n\t\tif( d > 0. ) {\n\t\t\tint1.xyz = ro+rd*d;\n\t    } else {\n        \treturn -1.;\n    \t}\n    }\n    \n    ro = ro + rd*t;\n    nor1 = calcNormal(ro);\n    ro += 0.01*nor1;\n    rd = reflect( rd, nor1 );\n    t = 0.0;\n    h = precis*2.0;\n    mld = 100.;\n    \n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\n        h = map( ro+rd*t );\n\t\tif(dL < mld){\n\t\t\tmld=dL;            \n            lint2.xyz = ro+rd*t;\n\t\t\tlint2.w = abs(dL);\n\t\t}\n        if( h < precis ) {\n   \t\t\tint2.xyz = ro+rd*t;\n            return 1.;\n        }   \n        t += max(h, precis*2.);\n    }\n\n    return 0.;\n}\n\n//----------------------------------------------------------------------\n// shade\n\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\n    vec3  col = vec3(0.5);\n    \n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\n    if( pos.y < 0.01 ) {\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\n    }    \n    \n    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);\n  \tcol *= (sh * backgroundColor);  \n \n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\n        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );\n        if( ha > 0.95) {\n            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );\n        }\n    }\n    \n\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\n  \n    return col;\n}\n\nvec3 getLightColor( in vec3 pos ) {\n    vec3 lcol = vec3( 1., .7, .5 );\n    \n\tvec3 pd = pos;\n    pd.x = abs( pd.x );\n    pd.z *= -sign( pos.x );\n    \n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\n\n    if( ch > 0.75 ) { // car\n        pdc.x += (ch-0.75)*4.;\n        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {\n            lcol = vec3( 1., 0.05, 0.01 );\n        }\n    }\n    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {\n        float fl = floor( pd.z/13. );\n        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );\n    }\n    if(  abs(pd.x) > 10. && pd.y > 5. ) {\n        float fl = floor( pd.z/2. );\n        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );\n    }\n   \n    return lcol;\n}\n\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\n\n//----------------------------------------------------------------------\n// main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (int(mod(iTime*.1, 4.)) != 2) return;\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n        \n    if (q.y < .12 || q.y >= .88) {\n\t\tfragColor=vec4(0.,0.,0.,1.);\n\t\treturn;\n\t}\n    \n    // camera\n    float z = time;\n    float x = -10.9+1.*sin(time*0.2);\n\tvec3 ro = vec3(x,  1.3+.3*cos(time*0.26), z-1.);\n    vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n    \n    vec3 col = backgroundColor;\n\n    // raymarch\n    float ints = intersect(ro+randomStart(p)*rd ,rd );\n    if(  ints > -0.5 ) {\n        \n        // calculate reflectance\n\t\tfloat r = 0.09;     \t        \n        if( int1.y > 0.129 ) r = 0.025 * hash(  133.1234*floor( int1.y / 3. ) + floor( int1.z / 3. ) );\n        if( abs(int1.x) < 8. ) {\n            if( int1.y < 0.01 ) { // road\n\t            r = 0.007*fbm(int1.xz);\n            } else { // car\n                r = 0.02;\n            }\n        }\n        if( abs( int1.x ) < 0.1 ) r *= 4.;\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) r *= 4.;\n        \n        r *= 2.;\n        \n        col = shade( ro, int1.xyz, nor1 );\n        \n        if( ints > 0.5 ) {\n            col += r * shade( int1.xyz, int2.xyz, calcNormalSimple(int2.xyz) );\n        }  \n        if( lint2.w > 0. ) {            \n            col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\n        } \n    } \n      \n    // Rain (by Dave Hoskins)\n\tvec2 st = 256. * ( p* vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13) );\n    float f = noise( st ) * noise( st*0.773) * 1.55;\n\tf = 0.25+ clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\n    \n    if( lint1.w > 0. ) {\n        col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\n    }  \n    \n\tcol += 0.25*f*(0.2+backgroundColor);\n\n    // post processing\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\tcol *= 1.2*vec3(1.,0.99,0.95);   \n\tcol = clamp(1.06*col-0.03, 0., 1.);  \n    q.y = (q.y-.12)*(1./0.76);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); \n\n    fragColor = vec4( col*1.1-.1, 1.0 );\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Bay Bridge by mplanck\n\n// tested on Macbook Pro 15\"\n// tested on Windows OS 8.1 - 980 TITAN\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n#define BRIDGE_SURFACE_ID 1.\n#define ISLAND_SURFACE_ID 2.\n#define SKY_SURFACE_ID 3.\n#define WATER_SURFACE_ID 4.\n#define SUSPENSION_STRUTS_SURFACE_ID 5.\n#define BRIDGE_LIGHT_SURFACE_ID 6.\n#define MOON_SURFACE_ID 7.\n\n#define MOON_COLOR vec3(.91, .93, 1.)\n\n#define DIST_MARCH_STEPS 50\n#define DIST_MARCH_MAXDIST 44.\n\n// **************************************************************************\n// INLINE MACROS\n\n#define MATCHES_SURFACE_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))\n\n// **************************************************************************\n// DEFINES\n\n// Increase to 8 to anti-alias (and to warm up your GPU)\n#define NUM_AA_SAMPLES 1.\n\n// **************************************************************************\n// GLOBALS\n\nvec4  g_debugcolor  = vec4(0.);\nfloat g_time        = 0.;\nfloat g_exposure    = 1.;\nfloat g_focus       = .9;\nvec3  g_moonpos     = vec3(0.);\n\nvec3  g_camorigin   = vec3(0.);\nvec3  g_campointsat = vec3(0.);\n\n// **************************************************************************\n// MATH UTILITIES\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod ( iChannel0, (uv+ 0.5)/256.0, 0.).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// Approximating a dialectric fresnel effect by using the schlick approximation\n// http://en.wikipedia.org/wiki/Schlick's_approximation. Returns a vec3 in case\n// I want to approximate a different index of reflection for each channel to\n// get a chromatic effect.\nvec3 fresnel(vec3 R, vec3 N, float eta)\n{\n    // assume that the surrounding environment is air on both sides of the \n    // dialectric\n    float ro = (1. - eta) / (1. + eta);\n    ro *= ro;\n    \n    float fterm = pow(max(0., 1. - dot(R, N)), 5.);  \n    return vec3(ro + ( 1. - ro ) * fterm); \n}\n\n// Rotate the input point around the x-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_xaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x,\n                point.y * cosa - point.z * sina,\n                point.y * sina + point.z * cosa);\n}\n\n// Rotate the input point around the y-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where I want to reuse the\n// same angle on different points, so why do the heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_yaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x * cosa  + point.z * sina,\n                point.y,\n                point.x * -sina + point.z * cosa);\n}\n\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal. *Overkill* \n// for intersecting with the x-z plane.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ro,\n                     vec3 rd,\n                     vec3 pn,\n                     vec3 po)\n{\n    float rddn = dot(rd, pn);\n    float intersected = 0.;\n\n    float t = REALLY_BIG_NUMBER;\n    // If the denominator is not a really small number (positive or negative)\n    // then an intersection took place.  If it is really small, then the ray\n    // is close to parallel to the given plane.\n    if (abs(rddn) > REALLY_SMALL_NUMBER) {\n        t = -dot(pn, (ro - po)) / rddn;    \n        if (t > REALLY_SMALL_NUMBER) {\n            intersected = 1.;\n        } else {\n            t = REALLY_BIG_NUMBER;\n        }\n\n    }\n    return vec2(intersected, t);\n}\n\n// intersection for a sphere with a ray. If the ray origin is inside the\n// sphere - no intersection takes place.  So there is gauranteed to be a tmin\n// and tmax return value.\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\nvec3 intersect_sphere(vec3 ro,                 \n                      vec3 rd, \n                      float sphr,\n                      vec3 sphc)\n{\n\n    vec3 oro = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - sphr*sphr;\n    float discr = b*b - a*c; \n    \n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/a;\n    tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmin);\n\n    float outside = step(sphr*sphr, dot(oro, oro));\n    return outside * vec3(hit, tmin, tmax);\n}\n\n// intersection for a sphere with a ray. Assumes intersecting from within the sphere\n// and tmax return value.\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\nvec3 intersect_isphere(vec3 ro,                 \n                      vec3 rd, \n                      float sphr,\n                      vec3 sphc)\n{\n\n    vec3 oro = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - sphr*sphr;\n    float discr = b*b - a*c; \n    \n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/a;\n    tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmax);\n\n    return vec3(hit, tmin, tmax);\n}\n\nfloat flow_noise( in vec3 p )\n{\n    vec3 q = p - vec3(0., .5 * g_time, 0.);\n    float f;\n    f  = 0.50000*noise( q ); q = q*3.02 -vec3(0., .5 * g_time, 0.);\n    f += 0.35000*noise( q ); q = q*3.03;\n    f += 0.15000*noise( q ); q = q*3.01;\n    return f;\n}\n\nfloat map4( in vec3 p )\n{\n    vec3 q = p;\n    float f;\n    \n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n    return f;\n}\n\n// overlay ca on top of ci and return ci\nvoid composite(inout vec4 ci, vec4 ca)\n{\n    // assume pre-multiplied alpha    \n    ci += ca * (1. - ci.a);\n}\n\nvec3 nearest_point_on_line( vec3 a, vec3 b, vec3 p)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / dot(ba, ba);\n    return a + t * ba;\n}\n\n\n// Given the float values, mix between them such that \n//  result=v1 at mod(x,4)=0,3\n//  result=v2 at mod(x,4)=1\n//  result=v3 at mod(x,4)=2\n\nfloat periodicmix(float v1, \n                 float v2, \n                 float v3, \n                 float x)\n{\n    float modx = mod(x, 3.);\n    return mix(v1, \n                mix(v2, \n                    mix(v3, \n                        v1,\n                        smoothstep(.5, .6, modx - 2.)), \n                    smoothstep(.5, .6, modx - 1.)), \n                smoothstep(.5, .6, modx));\n}\n\n// **************************************************************************\n// DISTANCE FUNC MATH\n\nfloat sphere_df( vec3 p, float r ) { return length( p ) - r; }\nfloat roundbox_df ( vec3 p, vec3 b, float r ) {return length(max(abs(p-vec3(0., .5*b.y, 0.))-.5*b,0.0))-r; }\n\n// **************************************************************************\n// INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct CameraInfo\n{\n    vec3 camera_origin;\n    vec3 ray_look_direction;\n    mat3 camera_transform;\n    vec2 image_plane_uv;\n};\n\n#define INIT_CAMERA_INFO() CameraInfo(vec3(0.) /* camera_origin */, vec3(0.) /* ray_look_direction */, mat3(1.) /* camera_transform */, vec2(0.) /* image_plane_uv */)\n\nstruct SurfaceInfo\n{\n    float surface_id;\n    vec3 view_origin;\n    vec3 view_dir;\n    vec3 surface_point;\n    vec3 surface_normal;\n    vec2 surface_uv;\n    float surface_depth;\n    float shade_in_reflection;\n};\n#define INIT_SURFACE_INFO(view_origin, view_dir) SurfaceInfo(-1. /* surface_id */, view_origin, view_dir, vec3(0.) /* surface_point */, vec3(0.) /* surface_normal */, vec2(0.) /* surface_uv */, 0. /* surface_depth */, 0. /* shade_in_reflection */)\n\nstruct MaterialInfo\n{\n    vec3 bump_normal;\n    vec3 diffuse_color;\n    vec3 specular_color; \n    float specular_exponent; \n    float reflection_intensity;\n    vec3 emissive_color;\n};\n#define INIT_MATERIAL_INFO(surface_normal) MaterialInfo(surface_normal /* bump_normal */, vec3(0.) /* diffuse_color */, vec3(0.) /* specular_color */, 1. /* specular_exponent */, 1. /* reflection_intensity */, vec3(0.) /* emissive_color */)\n\n// **************************************************************************\n// SETUP WORLD\n    \nvoid setup_globals()\n{\n    // Way to globally control playback rate.\n    g_time = 1. * iTime;\n    //g_time = .2 * iMouse.x;\n    \n    g_exposure = 1.;    \n\n    // remap the mouse click ([-1, 1], [-1/AspectRatio, 1/AspectRatio])\n    vec2 click = iMouse.xy / iResolution.xx;  \n    click = 2.0 * click - 1.0;  \n    \n    g_camorigin = vec3(0.0, .1, 7.0);\n    \n    //float rotxang    = .4 * PI * click.y;\n    float rotxang    = .4 * PI * -0.0;\n    rotxang += -.02 * cos(.02 * g_time) - .03;\n    float cosrotxang = cos(rotxang);\n    float sinrotxang = sin(rotxang);\n    g_camorigin = rotate_xaxis(g_camorigin, cosrotxang, sinrotxang);\n    \n    //float rotyang    = PI * click.x;\n    float rotyang    = PI * .28;\n    rotyang += .05 * sin(.2 * g_time);\n    //float rotyang    = .1 * sin(.1 * g_time + PI_OVER_TWO) + TWO_PI * .71;\n    float cosrotyang = cos(rotyang);\n    float sinrotyang = sin(rotyang);    \n    g_camorigin = rotate_yaxis(g_camorigin, cosrotyang, sinrotyang);\n\n    g_campointsat = vec3(0., .55, 1.5);\n\n    // XXX: DUPLICATED from setup_camera\n    // would be nice to consolidate work, but laziness won.\n\n    // calculate the ray origin and ray direction that represents mapping the\n    // image plane towards the scene.  Assume the camera is facing y-up (0., 1.,\n    // 0.).\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_campointsat - g_camorigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // project the camera ray through the current pixel being shaded using the\n    // pin-hole camera model.\n\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 click_uv = iMouse.xy / iResolution.xy - .5;\n    click_uv.y *= inv_aspect_ratio;\n\n    vec3 ray_click_dir = normalize( click_uv.x * ix + click_uv.y * iy + g_focus * iz );\n\n    vec3 result = intersect_isphere(g_camorigin, ray_click_dir, 40., g_camorigin);\n\n    if (iMouse.x + iMouse.y > 1.)\n    {\n   \t\tg_moonpos = g_camorigin + result.z * ray_click_dir;\n    }\n    else\n    {\n        g_moonpos = vec3(-28., 8., 3.);\n    }\n\n}\n\n\nCameraInfo setup_camera(vec2 aaoffset)\n{\n\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 image_plane_uv = (gl_FragCoord.xy + aaoffset) / iResolution.xy - .5;\n    image_plane_uv.y *= inv_aspect_ratio;\n\n    // calculate the ray origin and ray direction that represents mapping the\n    // image plane towards the scene.  Assume the camera is facing y-up (0., 1.,\n    // 0.).\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_campointsat - g_camorigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // project the camera ray through the current pixel being shaded using the\n    // pin-hole camera model.\n    vec3 ray_look_direction = normalize( image_plane_uv.x * ix + image_plane_uv.y * iy + g_focus * iz );\n\n    return CameraInfo(g_camorigin, ray_look_direction, mat3(ix, iy, iz), image_plane_uv);\n\n}\n\n// **************************************************************************\n// MARCH WORLD\n\nvec2 mergeobjs(vec2 a, vec2 b) { return mix(b, a, step(a.x, b.x)); }\n\nfloat uniondf(float a, float b) { return min(a, b); }\nfloat intersdf(float a, float b) { return max(a, b); }\nfloat diffdf(float a, float b) { return max(a, -b); }\n\nvec2 scene_df( vec3 p )\n{\n    \n    // ground    \n    vec3 gp = p * vec3(.2, 1., .2) + vec3(0., 10., 0.) * (.5*map4(.2 * p)-.5) + vec3(7.2, 3.3, -2.);\n    vec2 ground_obj = vec2(sphere_df(gp, 2.9), ISLAND_SURFACE_ID);    \n\n    // moon\n    vec3 mp = p - g_moonpos;\n    float mdf = sphere_df(mp, 1.2);\n    \n    // bridge towers\n    vec3 bb = p;    \n    bb.x = mod(bb.x + 4., 8.); // repeat bridge struts\n    bb.x -= 4.;\n    \n    bb.z = abs(bb.z); // symmetric along the xy plane\n    bb.z -= .15; // separation of sides\n    \n    float bdf = roundbox_df( bb, vec3(.1, 2.5, .03), .01); // sides    \n    bdf = uniondf(bdf, roundbox_df( bb, vec3(.35, .12, .15), .01)); // bottom\n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., 2.45, -0.1), vec3(.11, .1, .3), .01)); // top    \n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., .92, -0.1), vec3(8., .02, .2), .01)); // bottom bridge\n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., 1.05, -0.1), vec3(8., .02, .2), .01)); // top bridge\n                 \n    // struts\n    vec3 cb = bb;\n    cb.y = mod(cb.y + .19, .38);\n    cb.y = abs(cb.y - .19);\n    \n    // mask out certain struts by moving them so far away, they\n    // would never be the closest object\n    float m = step(2.5, bb.y) + step(.95, bb.y) * step(bb.y, 1.3); \n    cb.y -= .15 + REALLY_BIG_NUMBER * m;\n    cb.yz *= mat2(-.707, -.707, .707, -.707); \n    bdf = uniondf(bdf, roundbox_df( cb, vec3(.03, 1., .03), .01)); // struts\n\n    // suspension cables\n    vec3 sp = p;    \n    sp.x = mod(sp.x, 8.); \n    sp.x -= 4.;\n    sp.z = abs(sp.z);\n    sp.z -= .15;\n    sp.y -= .09 * sp.x*sp.x;\n    bdf = uniondf(bdf, roundbox_df( sp - vec3(0., 1.1, 0.), vec3(8., .01, .01), .01)); // bridge\n        \n    // suspension hanging struts\n    vec3 tp = p;\n    tp.x = mod(tp.x + .05, .1);\n    tp.x -= .05;\n    tp.z -= .13;\n    float sdf = roundbox_df(tp - vec3(0., 1.06, 0.), vec3(.0, .089 * sp.x*sp.x + .02, .0), .005);\n    \n    // bridge warning light\n    float wldf = sphere_df(bb - vec3(0.0, 2.64, -.15), .03);\n        \n    vec2 bridge_obj = vec2(bdf, BRIDGE_SURFACE_ID); \n    vec2 suspension_obj = vec2(sdf, SUSPENSION_STRUTS_SURFACE_ID);        \n    vec2 light_obj = vec2(wldf, BRIDGE_LIGHT_SURFACE_ID); \n    vec2 moon_obj = vec2(mdf, MOON_SURFACE_ID);\n    \n    vec2 obj = ground_obj;\n    obj = mergeobjs(obj, bridge_obj);\n    obj = mergeobjs(obj, suspension_obj);\n    obj = mergeobjs(obj, light_obj);\n    obj = mergeobjs(obj, moon_obj);\n    return obj;\n}\n\nvec3 calc_normal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.01, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene_df(p + epsilon.xyy).x - scene_df(p - epsilon.xyy).x,\n        scene_df(p + epsilon.yxy).x - scene_df(p - epsilon.yxy).x,\n        scene_df(p + epsilon.yyx).x - scene_df(p - epsilon.yyx).x );\n    return normalize( n );\n}\n\nvec2 intersect_water(vec3 ro, vec3 rd)\n{\n    return intersect_plane(ro, rd, vec3(0., 1., 0.), vec3(0., 0., 0.));\n}\n\nSurfaceInfo march_scene(vec3 ray_origin,\n                        vec3 ray_direction,\n                        float consider_water )\n{\n\n    SurfaceInfo surface = INIT_SURFACE_INFO(ray_origin, ray_direction);\n\n    vec2 water = consider_water * intersect_water(ray_origin, ray_direction);\n    \n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float total_t = 0.;\n    float curr_t = 0.;\n    \n    vec3 ro = ray_origin;\n    vec3 rd = ray_direction;\n    \n    for (int i=0; i < DIST_MARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || curr_t + total_t > DIST_MARCH_MAXDIST ) \n        {\n            break;\n        }        \n\n        vec3 p = ro + curr_t * rd;        \n        vec2 dfresult = scene_df( p );\n        \n        // calculate sky on it's own since it shifts with ray_origin\n        // and we don't want to consider it with calc_normal\n        vec2 sky_obj = vec2(-sphere_df(p, 35.), SKY_SURFACE_ID);\n        dfresult = mergeobjs(sky_obj, dfresult);\n\n        dist = dfresult.x;        \n        curr_t += dist;\n        surface.surface_id = dfresult.y;\n   \n        if ( water.x > .5 && curr_t > water.y )\n        {\n            surface.surface_id = WATER_SURFACE_ID;\n            curr_t = water.y;\n            break;\n        }   \n\n                                          \n    }\n    \n    surface.surface_point = ro + curr_t * rd;\n    total_t += curr_t;\n    \n    if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        vec3 n = vec3(0., 1., 0.);\n        vec3 u = normalize(-vec3(1., 0., 1.) * ray_origin);\n        vec3 v = cross(n, u);\n        surface.surface_uv = vec2(100., 10.) * vec2( dot(surface.surface_point, u), \n                                                    dot(surface.surface_point, v) );\n\n        n += u * (.2 * flow_noise(surface.surface_uv.xxy) - .1);\n        surface.surface_normal = normalize(n);\n       \n    }    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, SKY_SURFACE_ID))\n    {\n        surface.surface_normal = -rd;\n        surface.surface_uv = surface.surface_point.xz;\n    }\n    else \n    {        \n        surface.surface_normal = calc_normal( surface.surface_point );\n        surface.surface_uv = surface.surface_point.xz;\n    }\n    \n            \n    surface.surface_depth = total_t;\n\n    return surface;\n}\n\n// **************************************************************************\n// SHADE WORLD\n\nvec3 light_from_point_light(SurfaceInfo  surface,\n                            MaterialInfo material,\n                            vec3 light_position,\n                            vec3 light_color,\n                           float falloff_with_distance,\n                           float specular_sharpen)\n{\n    vec3 light_direction = normalize(light_position - surface.surface_point);\n    vec3 light_reflection_direction = reflect(light_direction, material.bump_normal);\n    \n    // Phong reflection model\n    vec3 reflective_shading = material.specular_color * pow(max(0., dot(light_reflection_direction, surface.view_dir)), \n        material.specular_exponent * specular_sharpen);\n    \n    float ldist = length(surface.surface_point - light_position);\n    float dist_atten = 1./ldist;\n    vec3 diffuse_shading = material.diffuse_color * max(0., dot(light_direction, material.bump_normal)) * mix(1., dist_atten, falloff_with_distance);    \n    vec3 scene_color = light_color * (diffuse_shading + reflective_shading);\n \n    return scene_color;\n\n}\n\n\nvec4 shade_clouds(vec3 ro, vec3 rd, float depth)\n{\n    vec4 cloud_rgba = vec4(0.);\n    vec3 cn = normalize(ro);\n    float num_clouds = 0.;\n    \n    for (float i = 0.; i < 3.; i += 1.)\n    {\n        vec3 ch = intersect_isphere(ro, rd, 3.1 * i + 4.5, ro);\n        if (ch.x > .5 && ch.z < depth )\n        {\n            vec3 hp = ro + rd * ch.z;\n            vec3 hpo = nearest_point_on_line(ro, g_moonpos, hp);\n            vec3 uvhp = hp - vec3(-28., 9., 9.);\n            \n            uvhp *= 2.;\n            float height_s = smoothstep(1., 5., hp.y);\n            \n            float cloud_alpha = (.06 + .02 * i) * (.2 + .8 * smoothstep(.1, .9 - .25 * height_s, map4(vec3(1., .8, 0.) * uvhp.yxz + vec3(3. * i, 5. * i , .05 * g_time))));\n            cloud_alpha *= smoothstep(0.5, 1.5, hp.y) * smoothstep(2. + 1.8 * i, .0, hp.y);\n            vec3 cloud_color = 2. * vec3(.6,.8,1.+.1*i);\n            \n            vec3 halod = hp - hpo;\n            vec3 halo_color = .8 * MOON_COLOR * max(0., 4. - length(2. * halod));\n            cloud_color += .6 * pow(halo_color, vec3(2.));\n            composite(cloud_rgba, vec4(cloud_color * cloud_alpha, cloud_alpha));            \n            num_clouds += 1.;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    //g_debugcolor.rgb = vec3(num_clouds * .25);\n    //g_debugcolor.a = 1.;\n    return cloud_rgba;\n    //return vec4(0.);\n}\n\nvec3 shade_reflected_world(SurfaceInfo surface)\n{\n    vec4 scene_color = vec4(0.);\n    \n    MaterialInfo material = INIT_MATERIAL_INFO(surface.surface_normal);\n    if (MATCHES_SURFACE_ID(surface.surface_id, BRIDGE_SURFACE_ID))\n    {\n\n        material.diffuse_color = .02 * vec3(.65, .62, .68);\n        material.specular_color = .5 * vec3(0.5, 0.6, 0.7);\n        material.specular_exponent = 30.;\n\n        material.emissive_color = vec3(.04, .03, .035);\n    } \n    else if (MATCHES_SURFACE_ID(surface.surface_id, BRIDGE_LIGHT_SURFACE_ID))\n    {\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        float i = abs(sin(g_time));\n        material.emissive_color = i*i * vec3(2., .05, .05);\n        material.reflection_intensity = 10.;\n        \n    }\n    else if (MATCHES_SURFACE_ID(surface.surface_id, SUSPENSION_STRUTS_SURFACE_ID))\n    {\n\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        material.specular_exponent = 1.;\n\n        vec3 dp = surface.surface_point.xyz;\n        dp.x = mod(dp.x + 4., 8.);\n        dp.x -= 4.;\n        \n        // pattern 1\n        float s = (.5 * cos(6. * dp.y * pow(abs(dp.x), .5) - 4. * g_time ) + .5);\n        float c1 = smoothstep(.3, 1., s);\n\n        // pattern 2\n        s = (.5 * cos(4. * dp.y * dp.x + mix(-1., 1., step(0., dp.x))* 5. * g_time ) + .5);\n        float c2 = smoothstep(.2, .8, s);\n           \n        // pattern 3\n        dp = surface.surface_point.xyz;\n        s = .5 * cos(2. * dp.x - 2.* g_time + 5. * 1. * sin(3. * dp.y + 1. * g_time)) + .5;\n        float c3 = smoothstep(.2, .9, s);\n        \n        float c = periodicmix(c1, c2, c3, .2 * g_time + .3 * dp.y);\n\n        // discrete lights\n        float l = mod(20. * dp.y, 1.);\n        c *= smoothstep(0.2, .5, l) * smoothstep(.8, .5, l);\n        \n        material.emissive_color = 2. * c * vec3(.9, .9, 1.);\n        material.reflection_intensity = 8.;\n\n    } \n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, ISLAND_SURFACE_ID))\n    {\n        vec3 surface_color = .05 * vec3(1., .5, .7);        \n\n        material.diffuse_color = surface_color;\n\n        material.emissive_color = .1 * surface_color;\n        material.specular_color = .1 * surface_color;\n        material.specular_exponent = 1.;\n\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, SKY_SURFACE_ID))\n    {\n        vec3 sky_color = .6 * vec3(0.15, 0.12, .12) * smoothstep(3., 0., surface.surface_point.y);        \n        float l = smoothstep(2., 0., surface.surface_point.y);\n        sky_color += .5 * vec3(0.2, 0.14, .12) * l * l;\n\t\tvec3 cn = surface.surface_point;\n        cn.z = floor(20. * cn.z) * .05;\n        float city_noise = noise(8. * cn.xzz);\n        sky_color += 2. * vec3(1., .8, .7) * smoothstep(.25 * city_noise - .05, -.06, surface.surface_point.y);\n        material.emissive_color = sky_color;\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, MOON_SURFACE_ID))\n    {\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        \n        mat3 om = mat3( 0.00,  0.80,  0.60,\n                       -0.80,  0.36, -0.48,\n                       -0.60, -0.48,  0.64 );\n\n        vec3 mp = 1.3 * om * (surface.surface_point - g_moonpos);\n\n        float moon = .1;\n        moon += .6 * smoothstep( 0.2,  .8, noise( .6 * (mp - vec3(1., 0., 0.)) ));\n        mp = 1.2 * om * mp; \n        moon += .5 * smoothstep( 0.2,  1., noise( .8 * (mp - vec3(1., 0., 0.))));\n        mp = 2.8 * om * mp; \n        moon += 0.300 * smoothstep( 0.1,  1.3, pow(noise( mp ), 3.0));    \n\n        moon *= .8 + .2 * smoothstep( 0.5,  0.7, noise( 1.7 * mp ));\n        moon *= .6 + .4 * noise( 30.5 * mp); \n        moon += 0.35 * pow(noise( 15.5 * mp), 6.);\n\n        material.emissive_color = moon * .6 * MOON_COLOR;\n        material.reflection_intensity = 4.;\n    }\n      \n    vec4 scene_rgba = vec4(0.05, .05, .08, 0.1);\n    vec3 em = material.emissive_color * mix(1., material.reflection_intensity, step(0.5, surface.shade_in_reflection));  \n    scene_rgba.rgb += em;\n    vec4 clouds_rgba = shade_clouds(surface.view_origin, surface.view_dir, surface.surface_depth);\n\n    vec3 lit_color = light_from_point_light(surface, \n                                            material, \n                                            g_moonpos, \n                                            MOON_COLOR, \n                                            0., \n                                            1.);\n\n\n    lit_color *= g_exposure;\n    clouds_rgba.rgb *= g_exposure;\n \n    composite(scene_rgba, clouds_rgba);\n    composite(scene_rgba, vec4(lit_color, 1.));\n        \n    return scene_rgba.rgb;\n}\n\n\nvec3 shade_world(SurfaceInfo surface)\n{\n\n    vec4 scene_color = vec4(0.);\n    \n    if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        MaterialInfo material = INIT_MATERIAL_INFO(surface.surface_normal);\n        \n        vec3 surface_color = vec3(.07,.08,.1) + mix(vec3(.18, .22, .35),\n                                 vec3(.21, .25, .38), \n                                 flow_noise(surface.surface_uv.xxy));\n\n        material.diffuse_color = .6 * surface_color;\n        material.emissive_color = .15 * surface_color;\n        material.specular_color = .5 * MOON_COLOR;\n        material.specular_exponent = 200.;\n        \n        SurfaceInfo refl_surface = march_scene( surface.surface_point, \n                                                reflect(surface.view_dir, \n                                                        surface.surface_normal), \n                                                0. );\n        \n        refl_surface.shade_in_reflection = 1.;\n        vec3 refl_color = shade_reflected_world( refl_surface );\n        \n        // fresnel like falloff to reflection\n        refl_color *= (.5 + .5 * smoothstep(0.3, 2.5, surface.surface_depth));\n\n        // loss of reflection with wave occlusion in the distance\n        refl_color *= (.5 + .5 * smoothstep(3., 1., surface.surface_depth));\n            \n\n        vec4 scene_rgba = vec4(0.);\n        \n        vec3 lit_color = light_from_point_light(surface, \n                                                material, \n                                                g_moonpos, \n                                                MOON_COLOR, \n                                                0., 1.);\n        \n        lit_color += .2 * refl_color;        \n        lit_color *= g_exposure;              \n        \n        scene_color = scene_rgba; \n        composite(scene_color, vec4(lit_color, 1.));\n\n    }\n    else\n    {\n        \n        scene_color.rgb = shade_reflected_world(surface);\n    }\n\n    return scene_color.rgb;\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (int(mod(iTime*.1, 4.)) != 0) return;\n    // ----------------------------------\n    // SETUP GLOBALS\n\n    setup_globals();\n\n    // ----------------------------------\n    // SETUP CAMERA\n\n    float denom = TWO_PI/max(1., NUM_AA_SAMPLES-1.);\n    vec3 scene_color = vec3(0.);\n\n    for (float aa = 0.; aa < NUM_AA_SAMPLES; aa += 1.) \n    {\n\n        vec2 aaoffset = step(.5, aa) * .5 * vec2( cos((aa-1.) * denom ),\n                                                  sin((aa-1.) * denom ) );\n\n        CameraInfo camera = setup_camera( aaoffset );\n        \n        // ----------------------------------\n        // SCENE MARCHING\n\n        SurfaceInfo surface = march_scene( camera.camera_origin,\n         camera.ray_look_direction, 1. );\n        \n        // ----------------------------------\n        // SHADING\n        \n        scene_color += shade_world( surface );\n        \n\n    }\n\n    scene_color /= NUM_AA_SAMPLES;\n\n    // ----------------------------------\n    // POST PROCESSING\n    \n    // Brighten\n    scene_color *= 1.2;\n  \n    // Gamma correct\n    scene_color = pow(max(vec3(0.), scene_color), vec3(.8));\n\n    // Contrast adjust - cute trick learned from iq\n    scene_color = mix( scene_color, vec3(dot(scene_color,vec3(0.333))), -.3 );\n\n    // Color tint\n    scene_color *= .5 + .5 * vec3(.9, 1., 1.);\n      \n    // Horizontal vignette - inspired by iq\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    scene_color *= 0.2 + 0.8*pow( 8.0*uv.x*(1.0-uv.x), 0.1 );\n    \n    // Debug color - great debugging tool.  \n    if (g_debugcolor.a > 0.) \n    {\n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scene_color;\n    }\n\n    fragColor.a = 1.;\n}\n","name":"Buf D","description":"","type":"buffer"}]}