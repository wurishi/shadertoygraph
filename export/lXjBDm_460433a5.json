{"ver":"0.1","info":{"id":"lXjBDm","date":"1729563694","viewed":63,"name":"Fissure Crack","username":"Shoozes","description":"Crack Texture","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["glass","web","crack","fissure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adjusts the randomness applied to each cell in the Voronoi calculation\nconst float THIC = 1.44; // <-- Higher to make it more of a FISSURE or lower for GLASS, 0.0 for WEBS\nconst float SECTIONS = 8.0;\nconst float PI = 3.14159265359;\nconst float PI_PI = 6.28318530718;\n\n// Hash function to generate a pseudo-random offset for each cell position\nvec2 hash(vec2 _pos) {\n    _pos = mod(_pos, SECTIONS);\n    return fract(sin(vec2(dot(_pos, vec2(144.44)), dot(_pos, vec2(144.44)))) * 14444.4444);\n}\n\n// Computes the Voronoi cell closest to the given point and its border distance\nvec3 voronoi(vec2 _point, out vec2 cellId) {\n    vec2 _cell = floor(_point);   // Cell grid position\n    vec2 _off = fract(_point); // Fractional part within the cell\n    vec2 nearestCell, offToCell;\n    float minDist = 8.0; // Initialize with a large value\n\n    // Find the nearest neighboring cell\n    for (int j = -1; j <= 1; j++)\n    for (int i = -1; i <= 1; i++) {\n        vec2 cell = vec2(float(i), float(j));\n        vec2 rndOff = THIC * hash(_cell + cell);\n        vec2 distance = cell + rndOff - _off;\n        float distSquared = dot(distance, distance);\n        if (distSquared < minDist) { \n            minDist = distSquared; \n            offToCell = distance; \n            nearestCell = cell; \n        }\n    }\n\n    // Refine the border distance to handle edges between cells\n    minDist = 8.0;\n    for (int j = -2; j <= 2; j++)\n    for (int i = -2; i <= 2; i++) {\n        vec2 cell = nearestCell + vec2(float(i), float(j));\n        vec2 rndOff = THIC * hash(_cell + cell);\n        vec2 distance = cell + rndOff - _off;\n        if (dot(offToCell - distance, offToCell - distance) > 0.000001) {\n            float dist = dot(0.5 * (offToCell + distance), normalize(distance - offToCell));\n            minDist = min(minDist, dist);\n        }\n    }\n\n    cellId = _cell + nearestCell; // Store the ID of the closest cell\n    return vec3(minDist, offToCell);\n}\n\n// Generates a basic noise value based on sine waves\nfloat noise(float _value) {\n    float _floor = floor(_value);\n    float _frac = fract(_value);\n    return mix(\n        fract(sin(_floor) * 14444.),\n        fract(sin(_floor + 1.0) * 14444.),\n        _frac\n    );\n}\n\n// Generates low-frequency noise for smooth transitions\nfloat lowFreqNoise(float _value) {\n    _value = mod(_value, 1.0);\n    float res = 10.0;\n    float _frac = fract(_value * res);\n    float index = floor(_value * res);\n    float a = noise(mod(index, res));\n    float b = noise(mod(index + 1.0, res));\n    return mix(a, b, _frac) * 2.0 - 1.0;\n}\n\n\n// Generates the color of a pixel based on its position and Voronoi calculations\nvec3 getColor(vec2 fragCoord) {\n    vec2 uvCenter = iResolution.xy / iResolution.x * 0.5;\n    vec2 uv = fragCoord.xy / iResolution.x - uvCenter;\n    float radius = length(uv);\n    float rot = atan(uv.y, uv.x) / PI_PI + 0.5;\n    vec2 polarCoords = vec2(max(0.5, pow(radius, 0.1)), rot);\n    polarCoords.x += 0.015 * abs(lowFreqNoise(polarCoords.y));\n    vec2 frequency = vec2(12.0, SECTIONS);\n\n    vec2 cellId;\n    float borderDist = voronoi(polarCoords * frequency, cellId).x;\n    cellId = mod(cellId, SECTIONS);\n    float edgeFactor = mix(0.1, 0.0, pow(radius, 0.1));\n    float edge = smoothstep(edgeFactor, edgeFactor + 0.0001, borderDist);\n\n    // Calculate normal variation based on noise for shading\n    vec3 nmOff = vec3(\n        noise(cellId.x * 7.0),\n        noise(cellId.y * 13.0),\n        noise(27.0 * (cellId.x - cellId.y))\n    ) * 2.0 - 1.0;\n    vec3 N = normalize(vec3(0.0, 0.0, 1.0) + 0.1 * nmOff);\n\n    // Mix colors based on edge proximity\n    vec3 finalColor = mix(vec3(1.0), vec3(0.2, 0.36, 0.4), 1.0 - edge);\n    return finalColor;\n}\n\n// Main shader function, applies anti-aliasing by averaging colors\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 colorSum = vec3(0.0);\n    for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n        colorSum += getColor(fragCoord + vec2(float(i), float(j)) / 3.0);\n    fragColor = vec4(colorSum / 9.0, 1.0); // Average colors for smooth edges\n}\n","name":"Image","description":"","type":"image"}]}