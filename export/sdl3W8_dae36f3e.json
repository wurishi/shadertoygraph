{"ver":"0.1","info":{"id":"sdl3W8","date":"1615890616","viewed":51,"name":"rotating sin(x)","username":"wwwwww195140","description":"axis","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 matrixMul(vec4 p[4], vec4 data){\n    \n    vec4 a = p[0] * data;\n    vec4 b = p[1] * data;\n    vec4 c = p[2] * data;\n    vec4 d = p[3] * data;\n    return vec4(a.x+a.y+a.z+a.w, b.x+b.y+b.z+b.w, c.x+c.y+c.z+c.w, d.x+d.y+d.z+d.w);\n}\n\n// rotate object centered by itself in camera space\nvec4 pointMVP(vec4 cameraSpace, vec4 cameraToNDC[4], vec4 rotByX[4], vec4 rotByY[4], vec4 rotByZ[4], vec4 NDCToCamera[4]){\n    vec4 coord = cameraSpace;\n    coord = matrixMul(cameraToNDC, coord);\n    coord = matrixMul(rotByX, coord);\n    coord = matrixMul(rotByY, coord);\n    coord = matrixMul(rotByZ, coord);\n    coord = matrixMul(NDCToCamera, coord);\n    return coord;\n}\n\nfloat distToCol(float dist) {\n    return clamp(1.-dist, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.xy *= 2.;\n    float scale = 60.;\n    \n    //matrix trasformation\n    float zplaneDepth = -3.;  // zplaneDepth = zNear\n    float n = -3.;\n    float f = -15.;\n    float speed = mod(iTime*1e2*.5,360.);\n    float thetaX = 0./180.*3.14;\n    float thetaY = 0./180.*3.14;\n    float thetaZ = speed/180.*3.14;\n    vec4 screenData = vec4(uv.x, uv.y, 1., 1.);  //suppose screenSpace always has depth of 1 in NDC space\n    \n    \n    float A = 1./(2.*n)-1./(2.*f);\n    float B = 1./(2.*n)+1./(2.*f);\n    vec4 projInverse[4];\n    projInverse[0] = vec4(scale/zplaneDepth, 0.,  0.,      0.);\n    projInverse[1] = vec4(0., scale/zplaneDepth,  0.,      0.); \n    projInverse[2] = vec4(0., 0.,  0.,      1.);\n    projInverse[3] = vec4(0., 0., A,  B);\n    \n    vec4 rotByX[4];\n    rotByX[0] = vec4(1., 0.,             0.,          0.);\n    rotByX[1] = vec4(0., cos(thetaX),    -sin(thetaX), 0.);\n    rotByX[2] = vec4(0., sin(thetaX),   cos(thetaX), 0.);\n    rotByX[3] = vec4(0., 0.,             0.,          1.);\n    \n    vec4 rotByY[4];\n    rotByY[0] = vec4(cos(thetaY),    0.,  -sin(thetaY),       0.); \n    rotByY[1] = vec4(0.,             1.,  0.,                 0.);\n    rotByY[2] = vec4(sin(thetaY),    0.,  cos(thetaY),        0.);\n    rotByY[3] = vec4(0.,             0.,  0.,                 1.);\n    \n    vec4 rotByZ[4];\n    rotByZ[0] = vec4(cos(thetaZ),    sin(thetaZ),   0.,       0.); \n    rotByZ[1] = vec4(-sin(thetaZ),   cos(thetaZ),   0.,       0.);\n    rotByZ[2] = vec4(0.,             0.,            1.,       0.);\n    rotByZ[3] = vec4(0.,             0.,            0.,       1.);\n    \n    vec4 cameraToNDC[4];\n    cameraToNDC[0] = vec4(1,   0,   0.,       0.); \n    cameraToNDC[1] = vec4(0,   1,   0.,       0.);\n    cameraToNDC[2] = vec4(0.,  0.,  1.,       -zplaneDepth+1.);\n    cameraToNDC[3] = vec4(0.,  0.,  0.,       1.);\n    \n    vec4 NDCToCamera[4];\n    NDCToCamera[0] = vec4(1,   0,   0.,       0.); \n    NDCToCamera[1] = vec4(0,   1,   0.,       0.);\n    NDCToCamera[2] = vec4(0.,  0.,  1.,       zplaneDepth-1.);\n    NDCToCamera[3] = vec4(0.,  0.,  0.,       1.);\n    \n    vec4 one[4];\n    one[0] = vec4(1,   0,   0.,       0.); \n    one[1] = vec4(0,   1,   0.,       0.);\n    one[2] = vec4(0.,  0.,  1.,       0.);\n    one[3] = vec4(0.,  0.,  0.,       1.);\n    \n    vec4 shiftToOrg[4];\n    shiftToOrg[0] = vec4(1,   0,   0.,       0.); \n    shiftToOrg[1] = vec4(0,   1,   0.,       0.);\n    shiftToOrg[2] = vec4(0.,  0.,  1.,       -1.);\n    shiftToOrg[3] = vec4(0.,  0.,  0.,       1.);\n    \n    \n\n//----------------------\n\n    vec4 cameraSpaceNPlane = zplaneDepth*matrixMul(projInverse, screenData);\n    vec4 cameraSpaceNfCenterPlane =  matrixMul(shiftToOrg, cameraSpaceNPlane);\n    \n    vec4 coord = cameraSpaceNfCenterPlane;\n    coord = matrixMul(cameraToNDC, coord);\n    coord = matrixMul(rotByX, coord);\n    coord = matrixMul(rotByY, coord);\n    coord = matrixMul(rotByZ, coord);\n    coord = matrixMul(NDCToCamera, coord);\n    \n    /*\n    vec4 right = vec4(1., 0., 0., 1.);\n    right = matrixMul(rotByX, right);\n    right = matrixMul(rotByY, right);\n    right = matrixMul(rotByZ, right);\n    right = matrixMul(NDCToCamera, right);\n    \n    vec4 back = vec4(0., 0., 1., 1.);\n    back = matrixMul(rotByX, back);\n    back = matrixMul(rotByY, back);\n    back = matrixMul(rotByZ, back);\n    back = matrixMul(NDCToCamera, back);\n    \n    */\n\n    vec4 up = vec4(0., 1., 0., 1.);\n    up = matrixMul(rotByX, up);\n    up = matrixMul(rotByY, up);\n    up = matrixMul(rotByZ, up);\n    up = matrixMul(NDCToCamera, up);\n\n    \n    vec4 org = vec4(0., 0., 0., 1.); //org in NDC space\n    org = matrixMul(rotByX, org);\n    org = matrixMul(rotByY, org);\n    org = matrixMul(rotByZ, org);\n    org = matrixMul(NDCToCamera, org);\n    \n    //draw curve\n    float curveDist = distToCol(pow(abs((coord-org).y-8.*sin((coord-org).x)),10.))*clamp(sign(scale-abs((coord-org).x)),0., 1.);\n    vec4 colCurve = vec4(curveDist, 0., 0., 1.);\n\n    \n    vec4 colAxisX;vec4 colAxisY;vec4 colAxisZ;\n    \n    //draw x axis\n    float distToX = pow((coord-org).z,2.) +pow((coord-org).y,2.);\n    float xaxis = distToCol(distToX); // dist to x = 0\n    colAxisX = vec4(0., xaxis, 0., 0.);\n    \n    //draw y axis\n    float distToY = pow((coord-org).z,2.) +pow((coord-org).x,2.);\n    float yaxis = distToCol(distToY);\n    colAxisY = vec4(0., yaxis, yaxis, 0.);\n    \n\n    // draw zaxis\n    float zaxis = dot(normalize((coord-org).xyz), normalize((up-org).xyz));\n    colAxisZ = vec4(0., 0., pow(abs(zaxis),50.), 0.);\n\n    \n    fragColor = colCurve + colAxisX + colAxisY + colAxisZ;\n}\n\n","name":"Image","description":"","type":"image"}]}