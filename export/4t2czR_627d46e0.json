{"ver":"0.1","info":{"id":"4t2czR","date":"1507295405","viewed":245,"name":"Test gradient","username":"vicga","description":"Test for gradient","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n#define GAMMA (2.2)\n\nvec2 hash(in vec2 p) {\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(299.5,783.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.545);\n}\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\n\nvec2 Noise( in vec3 x )\n{\n//x.z = .0;    \n    vec3 p = floor(x);\n    vec3 f = x-p;\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\n#if (1)\n    uv += f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\trg.yw = texture( iChannel0, (uv-vec2(37.0,17.0)+0.5)/256.0, -100.0 ).xz;\n#else\n\t// on some hardware interpolation lacks precision\n\tvec4 rg = mix( mix(\n\t\t\t\ttexture( iChannel0, (uv+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (uv+vec2(1,0)+0.5)/256.0, -100.0 ),\n\t\t\t\tf.x ),\n\t\t\t\t  mix(\n\t\t\t\ttexture( iChannel0, (uv+vec2(0,1)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (uv+1.5)/256.0, -100.0 ),\n\t\t\t\tf.x ),\n\t\t\t\tf.y );\n#endif\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z ); // this doesn't seem to match up well any more, but it's close...\n}\n\n\nfloat noise(in vec2 p) \n{\n    vec2 p00 = floor(p);\n    vec2 p10 = p00 + vec2(1.0, 0.0);\n    vec2 p01 = p00 + vec2(0.0, 1.0);\n    vec2 p11 = p00 + vec2(1.0, 1.0);\n    \n    vec2 s = p - p00;\n    \n    float a = dot(hash(p00), s);\n\tfloat b = dot(hash(p10), p - p10);\n\tfloat c = dot(hash(p01), p - p01);\n\tfloat d = dot(hash(p11), p - p11);\n\n    vec2 q = s*s*s*(s*(s*6.0 - 15.0) + 10.0);\n\n    float c1 = b - a;\n    float c2 = c - a;\n    float c3 = d - c - b + a;\n\n   \treturn a + q.x*c1 + q.y*c2 + q.x*q.y*c3;\n}\n\n\nvec2 Position() {\n\treturn vec2(noise(vec2(iTime*0.14)), noise(vec2(iTime*0.12))) +\n           vec2(0.0, iTime * 0.25);\n}\n\nvec3 colorA = vec3(0.6,0.8,0.74);\nvec3 colorB = vec3(.64,0.66,0.69);\nvec3 colorC = vec3(0.21,0.08,0.36);\nvec3 colorD = vec3(0,0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.x;\n    \n    /*vec2 pos = vec2(uv*5.0);\n   \n    vec2 p = Position() + (fragCoord / max(iResolution.x, iResolution.y));\n \tfloat h = noise(p);\n    h += noise(p * 2.0);\n    h += noise(p * 1.0);*/\n\n    vec2 blob = Noise( vec3(uv.x,uv.y*sqrt(3.0)*.5,uv.y*.5)*3.0 + iTime*vec3(0.001,-.05,.3) );\n \tfloat h = noise(blob);\n    vec3 col1 = pow(colorA,vec3(4.0*sqrt(max(0.0,(blob.x-.6)*2.0))));\n\tvec3 col2 = pow(colorB,vec3(4.0*sqrt(max(0.0,(blob.y-.6)*2.0))));\n    vec3 color = mix(colorA,colorB, .0);\n    color = mix(color, colorC, h);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}