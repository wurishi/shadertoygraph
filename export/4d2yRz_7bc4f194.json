{"ver":"0.1","info":{"id":"4d2yRz","date":"1490646363","viewed":107,"name":"test321434","username":"ChuckNorris","description":"asdf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["asdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print digits larger than 99999, increase MAX_DIGITS\n\n#define MAX_DIGITS    5\n#define BASE         10\n#define DIGIT_WIDTH  20.0\n#define DIGIT_HEIGHT 20.0\n\n#define PLUS_SIGN  vec2(11.0, 13.0)\n#define MINUS_SIGN vec2(13.0, 13.0)\n#define DOT        vec2(14.0, 13.0)\n\nint idiv(int a, int b){\n    // If you encounter precision loss, this is probably the reason.\n    return int(float(a)/float(b));\n}\n\nint imod(int a, int b){\n    return a - idiv(a, b)*b;\n}\n\n// draw a character where p is bottom left\nfloat draw_char(vec2 p, vec2 char_position){\n    vec2 uv = (gl_FragCoord.xy - p)/vec2(DIGIT_WIDTH, DIGIT_HEIGHT);\n    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0){\n        return texture(iChannel3, (uv + char_position)/16.0).r;\n    }\n    return 0.0;\n}\n\n// draw a digit between 0-9\nfloat draw_digit(vec2 p, int digit){\n    return draw_char(p, vec2(float(digit), 12.0));\n}\n\n// draw an unsigned integer\nfloat draw_uint(vec2 p, int number){\n    number = abs(number);\n    \n    // we draw numbers from right to left because we get digits in that order\n    p.x += float(MAX_DIGITS - 1)*DIGIT_WIDTH;\n    \n    float color = 0.0;\n    \n    // decompose number into digits\n    for (int i = 0; i < MAX_DIGITS; i++){\n        int digit = imod(number, BASE);\n        number = idiv(number, BASE);\n        \n        color += draw_digit(p, digit);\n        \n        p.x -= DIGIT_WIDTH;\n    }\n    \n    return color;\n}\n\n// draw an unsigned integer with a sign in front\nfloat draw_uint_with_sign(vec2 p, int number, bool negative){\n    // draw sign\n    float color = draw_char(p, negative ? MINUS_SIGN : PLUS_SIGN);\n    p.x += DIGIT_WIDTH;\n    \n    // draw uint\n    color += draw_uint(p, number);\n    \n    return color;\n}\n\nfloat draw_int(vec2 p, int number){\n    return draw_uint_with_sign(p, number, number < 0);\n}\n\nfloat draw_float(vec2 p, float f){\n    float color = draw_uint_with_sign(p, int(f), f < 0.0);\n    p.x += float(MAX_DIGITS + 1)*DIGIT_WIDTH;\n    \n    // draw dot\n    color += draw_char(p, DOT);\n    p.x += DIGIT_WIDTH;\n    \n    // remove integer part\n    f -= float(int(f));\n    // shift fractional part into integer part\n    f *= pow(float(BASE), float(MAX_DIGITS));\n    \n    // draw fractional part\n    color += draw_uint(p, int(f));\n    \n    return color;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst float pi = 3.14159;\nconst float inf = 65536.0;\n\n#define sphere_center vec3(0.0, 0.0, 0.0)//cos(iTime))\n\nvec4 draw_sphere(vec3 center, float radius, vec3 origin, vec3 direction){\n    vec3 co = center - origin;\n    \n    float dco = dot(direction, co);\n    \n    float d2 = dco*dco - dot(co, co) + radius*radius;\n    \n    if (d2 >= 0.0){\n        float dist0 = dco - sqrt(d2);\n        \n        vec3 position = origin + direction*dist0;\n        \n        vec3 normal = normalize(position - center);\n        \n        vec3 color = normal*0.5 + 0.5;\n        \n        return vec4(color, dist0);\n    }\n    \n    return vec4(vec3(0.0), inf);\n}\n\nstruct Intersection {\n    vec3 position;\n    float dist;\n    vec3 normal;\n};\n\n// TODO replace eye with origin\nvec4 draw_plane(vec3 position, vec3 normal, vec3 eye, vec3 direction){\n    // we want that point p must be on plane\n    // dot(p - position, normal) = 0\n    //\n    // and we also want point p on ray at distance t\n    // eye + t*direction = p\n    // \n    // substitute p\n    // dot(eye + t*direction - position, normal) = 0\n    //\n    // reorder terms\n    // dot(eye - position + t*direction, normal) = 0\n    //\n    // split dot product and extract t\n    // dot(eye - position, normal) + t*dot(direction, normal) = 0\n    // \n    // solve for t\n    // t = dot(position - eye, normal)/dot(direction, normal)\n    \n    float f = dot(direction, normal);\n    \n    // if ray does not point towards plane we got nothing\n    if (f >= 0.0) return vec4(vec3(0.0), inf);\n    \n    float t = dot(position - eye, normal)/f;\n    \n    vec3 p = eye + t*direction;\n    \n    vec3 color = texture(iChannel0, p.xy*0.1).rgb;\n    \n    color *= vec3(fract(length(p - position)));\n    \n    return vec4(color, t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float angle = iTime*0.2;\n    angle = pi;\n    \n    vec3 eye = vec3(cos(angle), sin(angle), 5.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n  \n    vec3 forwards = normalize(target - eye);\n\tvec3 right    = normalize(cross(forwards, up));\n    vec3 upwards  = normalize(cross(right, forwards));\n    \n    vec3 direction = normalize(uv.x*right + uv.y*upwards + forwards);\n    \n    // ray cylinder intersection\n    \n    /*\n\to + t*d = p\n\tdot(p - c, p - c) = r^2\n\tdot(o + t*d - c, o + t*d - c) = r^2\n\tdot(oc + t*d, oc + t*d) = r^2\n\tdot(oc, oc + t*d) + dot(t*d, oc + t*d) = r^2\n\tdot(oc, oc) + dot(oc, t*d) + dot(t*d, oc) + dot(t*d, t*d) = r^2\n\tdot(oc, oc) + 2*t*dot(oc, d) + t^2*dot(d, d) = r^2\n\t*/\n    \n    vec2 center = vec2(2.0, 3.0);\n    vec2 origin = eye.xy;\n    vec2 oc = origin - center;\n    vec2 d = direction.xy;\n    float r = 0.5;\n\t\n    float a = dot(d, d);\n    float b = dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n    \n    float p = b/a;\n    float q = c/a;\n    \n    float d2 = p*p - q;\n    \n    vec4 color0 = draw_sphere(sphere_center, 1.0, eye, direction);\n    vec4 color1 = draw_plane(vec3(0.0), up, eye, direction);\n    \n    vec3 color = color0.w < color1.w ? color0.rgb : color1.rgb;\n    \n    // must intersect cylinder and direction must go towards cylinder\n    if (d2 >= 0.0 && b <= 0.0){\n        float d = sqrt(d2);\n        float d0 = -p - d;\n        float d1 = -p + d;\n        \n        vec3 p = eye + d0*direction;\n        vec3 q = eye + d1*direction;\n        \n        float cylinder_height = 1.5 + cos(iTime);\n        \n        if (d0 < min(color0.w, color1.w) && p.z < cylinder_height){\n        \tvec3 normal = normalize(p - vec3(center, p.z));\n        \tcolor = normal*0.5 + 0.5;\n        }else if (d1 < min(color0.w, color1.w) && q.z < cylinder_height){\n        \tvec3 normal = -normalize(p - vec3(center, p.z));\n        \tcolor = normal*0.5 + 0.5;\n        }\n    }\n    \n    /*\n    vec2 position = vec2(0.0);\n    color *= 1.0 - draw_float(position, q.w);\n    position.y += DIGIT_HEIGHT;\n    color *= 1.0 - draw_float(position, q.z);\n    position.y += DIGIT_HEIGHT;\n    color *= 1.0 - draw_float(position, q.y);\n    position.y += DIGIT_HEIGHT;\n    color *= 1.0 - draw_float(position, q.x);\n    */\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}