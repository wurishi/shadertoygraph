{"ver":"0.1","info":{"id":"ttd3RN","date":"1575969981","viewed":259,"name":"wired_torus","username":"skaplun","description":"Just single sdf cylinder equation and bunch of coordinates manipulation\nLooks much better with AA enabled, but performance is poor in this case","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sdf","animation","nosense"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 64\n#define EPSILON 0.0001\nBreakdownAnimationState bas;\n\nfloat sdCappedCylinder(vec3 p, float h, float r){\n    vec2 d = abs(vec2(length(p.zy), p.x)) - vec2(h,r);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 noodles(vec3 worldPos, float h){\n\tvec2 rp = vec2(atan(worldPos.z, worldPos.y) + worldPos.x*TAU*2.11, length(worldPos.yz));\n    float id = floor(rp.x/(PI/32.));\n    rp.x = mod(rp.x, PI/32.)-PI/64.;\n    worldPos.yz = (rp.y+fbm1x(id*37.13, iTime*.5) * .25) * vec2(sin(rp.x), cos(rp.x));\n    float size = pow(getInvNormalizedBAS(bas, BAS_COLLAPSE), .5)*.6 - .3;\n    worldPos.z -= size * 10.;\n   \n    h -= fbm1x(id * 1.13, 1.) * 0.125 * smoothstep(.25, .2, distance(h, .25));\n    worldPos.x -= h;\n    return vec3(sdCappedCylinder(worldPos, .075, h), id, worldPos.x + h);\n}\n\nfloat outer(vec3 worldPos){\n\tfloat a = radians(90.);\n    worldPos.xz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    return sdCappedCylinder(worldPos, 8.2, 3.5);\n}\n\nvec3 world(vec3 worldPos){\n    float size = 5.;\n    worldPos = vec3((atan(worldPos.x, worldPos.y)/TAU+.5), length(worldPos.xy) - size, worldPos.z);\n    float phase = getNormalizedBAS(bas, BAS_EXPAND)*.5;\n    return noodles(worldPos, phase);\n}\n\nvec3 march(vec3 eye, vec3 marchingDirection){\n\tconst float precis = .01;\n    \n    float t = 0.;\n    bool hitOuter = false;\n    for(int i=0; i<32; i++){\n        float hit = outer(eye + marchingDirection * t);\n        if(hit < .05){\n            hitOuter = true;\n        }\n        t += hit;\n        if(hitOuter)\n            break;\n    }\n    if(hitOuter)\n        for(int i=0; i<MAX_MARCHING_STEPS; i++){\n            vec3 hit = world(eye + marchingDirection * t);\n            if(hit.x < precis) return vec3(t, hit.gb);\n            t += hit.x * .5;\n        }\n\n    return vec3(-1.);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)).x - world(vec3(p.x - EPSILON, p.y, p.z)).x,\n        world(vec3(p.x, p.y + EPSILON, p.z)).x - world(vec3(p.x, p.y - EPSILON, p.z)).x,\n        world(vec3(p.x, p.y, p.z  + EPSILON)).x - world(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvec3 color1 = vec3(248., 241., 212.)/255.;\nvec3 color2 = vec3(241., 150., 69.)/255.;\n\nvec4 render(in vec2 fragCoord){\n\tvec3 color = vec3(.15);\n    //float a = iMouse.x/iResolution.x * PI * 2.;\n    float a = PI*.15 + PI * pow(getNormalizedBAS(bas, BAS_ROTATE), 4.);\n    vec3 eye = vec3(30. * sin(a), 0., 30. * cos(a));\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    vec3 hit = march(eye, worldDir);\n    if (hit.x > 0.) {\n        vec3 p = (eye + hit.x * worldDir);\n        vec3 norm = estimateNormal(p);\n        color = color1;\n        if(floor(mod(hit.y, 15.)) == 0. || floor(mod(hit.y, 15.)) == 2.)\n            color = color2;\n        color *= 1. - .125 * smoothstep(4., 5., mod(hit.y, 10.));\n        color *= abs(pow(dot(worldDir, norm), 2.));\n    }\n    return vec4(color, 1.);\n}\n\n#define AA 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    bas = getBreakdownAnimationState(iTime);\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\nconst float PI = acos(-1.); \nconst float TAU = PI*2.; \nstruct Ray{vec3 origin, direction;};\n    \nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nstruct BreakdownAnimationState{\n\tfloat id;\n    float phase; \n};\n\n#define BAS_EXPAND 0.\n#define BAS_ROTATE 1.\n#define BAS_COLLAPSE 2.\n#define BAS_END 3.\n    \nconst int PHASES_COUNT = 3;\nconst float PHASES_DURATIONS[PHASES_COUNT] = float[PHASES_COUNT](1.5, 3.0, 4.5);\n\nBreakdownAnimationState getBreakdownAnimationState(float time){\n\ttime = mod(time, PHASES_DURATIONS[PHASES_COUNT - 1]);\n    \n    int id = 0;\n    for(int i=1; i<=PHASES_COUNT; i++){\n        if(time < PHASES_DURATIONS[i-1]){\n        \tid = i-1;\n            break;\n        }\n    }\n    float phase = (time - (id == 0 ? 0. : PHASES_DURATIONS[id-1]))\n        \t\t/ (PHASES_DURATIONS[id] - (id == 0 ? 0. : PHASES_DURATIONS[id-1]));\n    \n    return BreakdownAnimationState(float(id), phase);\n}\n\nfloat getNormalizedBAS(BreakdownAnimationState bas, float id){\n\tif(id == bas.id)\n        return bas.phase;\n    else\n        return step(id, bas.id);\n    //return max(bas.phase, step(bas.id, id-1.));\n}\n\nfloat getInvNormalizedBAS(BreakdownAnimationState bas, float id){\n\tif(id == bas.id)\n        return 1.-bas.phase;\n    else\n        return step(bas.id, id);\n    //return max(1.-bas.phase, step(bas.id, id-1.));\n}","name":"Common","description":"","type":"common"}]}