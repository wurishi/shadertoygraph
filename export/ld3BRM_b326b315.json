{"ver":"0.1","info":{"id":"ld3BRM","date":"1563202426","viewed":105,"name":"Binary Heap GLSL","username":"nnorm","description":"A na√Øve binary heap implementation in GLSL. Probably not very useful but...here you go anyway.\n\nEDIT: This is probably useless af, I'm not sure it's correct either. Use it as you wish. :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tree","datastructure","whywouldyoudothat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Binary Heap GLSL Implementation */\n/* \n** Since a Binary Heap (either min-heap or max-heap) can be stored in an array I figured I could\n** implement it in a shader. If you change the data type to a struct for exemple you can use that\n** and rank the nodes depending on the criteria you need (depth? thickness? density?)\n** and then use that datastructure to cull stuff maybe? Or maybe you need to have a simple\n** binary tree structure for each pixel. I've set the size of the container to 128 but it can be\n** smaller or bigger.\n**/\n\nstruct BinaryHeap\n{\n    int count_;\n    int data_[128];\n};\n\nBinaryHeap makeBHeap()\n{\n    //-1 here is just an \"impossible id\"\n    //note that in GLSL arrays must be initialized w/ a constant expression\n    //that is why...you know there's the following line\n    BinaryHeap b = BinaryHeap(0,  int[128](-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1));    \n    //this can be solved w/ some preprocessor macro, too lazy for now to write it tho\n    return b;\n}\n\nint getParent(in BinaryHeap b, int i)\n{\n    int index = int(floor((float(i)-1.0)/2.0));\n    return b.data_[index];\n}\n\nint getLeftChild(in BinaryHeap b, int i)\n{\n    return b.data_[i*2+1];\n}\n\nint getRightChild(in BinaryHeap b, int i)\n{\n    return b.data_[i*2+2];\n}\n\nbool insertNodeMin(in BinaryHeap b, int x)\n{\n    if(b.count_ < 128)\n    {\n        int i = b.count_ - 1;\n        b.data_[i] = x;\n        while(b.data_[i] > getParent(b, i))\n        {\n            int pindex = int(floor((float(i)-1.0)/2.0));\n            int tmp = getParent(b, i);\n            b.data_[i-1] = tmp;\n            b.data_[pindex] = x;\n            i = pindex;\n        }\n        b.count_ += 1;\n        return true;\n    }\n\telse\n    \treturn false;\n}\n\nbool insertNodeMax(in BinaryHeap b, int x)\n{\n    if(b.count_ < 128)\n    {\n        int i = b.count_ - 1;\n        b.data_[i] = x;\n        while(b.data_[i] < getParent(b, i))\n        {\n            int pindex = int(floor((float(i)-1.0)/2.0));\n            int tmp = getParent(b, i);\n            b.data_[i-1] = tmp;\n            b.data_[pindex] = x;\n            i = pindex;\n        }\n        b.count_ += 1;\n        return true;\n    }\n\telse\n    \treturn false;\n}\n\nint getRoot(in BinaryHeap b)\n{\n    return b.data_[0]; //either the min or the max of the heap\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}