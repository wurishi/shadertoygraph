{"ver":"0.1","info":{"id":"DlSyz1","date":"1691442988","viewed":36,"name":"Gradient multistop","username":"bkeenan","description":"Linear gradient with multiple color stops.\nGradient function has midpoint control similar to Photoshop.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Horizontal linear gradient with multiple color stops.\n * Gradient function has midpoint control similar to Photoshop.\n */\n\n// Use medium precision on mobile devices\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TAU (2.*PI)\n\n#define COLOR_BLACK       vec3(0.0, 0.0, 0.0)\n#define COLOR_WHITE       vec3(1.0, 1.0, 1.0)\n#define COLOR_TEAL        vec3(0.0078, 0.482, 0.482)\n#define COLOR_WEB_ORANGE  vec3(1.0, 0.647, 0.0)\n#define COLOR_ORANGE      vec3(1.0, 0.509, 0.482)\n#define COLOR_DEEP_RUBY   vec3(0.5451, 0.294, 0.325)\n\n\n// Size of one pixel in normalized texture coordinates (0-1)\nfloat pixel_size;\n\n// Duration of the animation in seconds\nfloat animation_duration = 8.0;\n\n/**\n * Bias Ease-In and Ease-Out\n * \n * @param  {float} x      The value to Ease (the input value to interpolate)\n * @param  {float} bias   Control parameter to vary the function from ease-out (0.0) to ease-in (1.0).\n *                        The midpoint is linear, no easing (0.5).\n * @param  {bool}  invert Invert the curve, e.g. to switch direction of interpolation.\n */\nfloat bias(float x, float bias, bool invert) {\n  if(invert)\n    bias = 1.0 - bias;\n\n  return x / ((1.0 / bias - 2.0) * (1.0 - x) + 1.0);\n}\n\n/**\n * Mix a gradient between two colors based on the input value within the specified stops.\n *\n * @param val       The input value for which the gradient is calculated.\n * @param stop1     Where the gradient starts.\n * @param stop2     Where the gradient ends.\n * @param midpoint  Midpoint controls where the transition occurs. 0-1 range, 0.5 is linear.\n * @param color_a   The starting color of the gradient.\n * @param color_b   The ending color of the gradient.\n * @return          The interpolated color between color_a and color_b based on the input value.\n */\nvec3 color_gradient(float val, float stop1, float stop2, float midpoint, vec3 color_a, vec3 color_b) {\n  // Clamp input value within the specified stops range\n  val = clamp(val, stop1, stop2);\n\n  // Calculate the relative position of val between the stops (0-1)\n  val = (val - stop1) / (stop2 - stop1);\n\n  // Calculate the gradient with a midpoint bias\n  float bias_ease = bias(val, midpoint, true);\n  float weight = mix(0.0, 1.0, bias_ease);\n\n  // mix the colors\n  return mix(color_a, color_b, weight);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Current fragment position in normalized coordinates (0-1)\n  vec2 uv = fragCoord/iResolution.xy;;\n  // maintain aspect ratio\n  // uv.x *= iResolution.x / iResolution.y;\n\n  // Size of one pixel in normalized texture coordinates (0-1)\n  pixel_size = 1.0 / iResolution.y;\n\n  // Calculate the normalized time in the range [0, 1]\n  float normalized_time = mod(iTime, animation_duration) / animation_duration;\n  float oscillating_time = (0.5 + 0.5 * sin(2.0 * PI * normalized_time));\n\n  vec3 color = COLOR_BLACK;\n\n  // Define the gradient with color stops from 0.0 to 1.0\n  // Midpoints control where the transition occurs (animated)\n  float stop1 = 0.03;\n  float midpoint1 = oscillating_time;\n  float stop2 = 0.5;\n  float midpoint2 = oscillating_time;\n  float stop3 = 1.0 - 0.03;\n\n  // Mix the gradients between each stop\n  color = color_gradient(uv.x, stop1, stop2, midpoint1, COLOR_TEAL, COLOR_WEB_ORANGE);\n  color = color_gradient(uv.x, stop2, stop3, midpoint2, color, COLOR_DEEP_RUBY);\n\n  // Output to screen\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}