{"ver":"0.1","info":{"id":"WssXDl","date":"1552553732","viewed":99,"name":"Main Building of MSU in fog","username":"Nikita_Pimenov","description":"Home work","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mashgraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MAX_DIST 1000.0\n#define SMALL_DIST 0.01\n\nfloat DistSquare(vec3 p, vec4 square) {\n    float Dx, Dy, Dz;\n    if (p.x - square.x <= square.w) {\n        if (p.x - square.x >= -square.w) {\n            Dx = 0.0;\n        } else {\n            Dx = square.x - square.w - p.x;\n        }\n    } else {\n        Dx = p.x - square.x - square.w;\n    }\n    if (p.y - square.y <= square.w) {\n        if (p.y - square.y >= -square.w) {\n            Dy = 0.0;\n        } else {\n            Dy = square.y - square.w - p.y;\n        }\n    } else {\n        Dy = p.y - square.y - square.w;\n    }\n    if (p.z - square.z <= square.w) {\n        if (p.z - square.z >= -square.w) {\n            Dz = 0.0;\n        } else {\n            Dz = square.z - square.w - p.z;\n        }\n    } else {\n        Dz = p.z - square.z - square.w;\n    }\n    return sqrt(Dx * Dx+ Dy * Dy + Dz * Dz);\n}\nfloat DistRectangle(vec3 p, vec3 rectangle, vec3 size) {\n    float Dx, Dy, Dz;\n    if (p.x - rectangle.x <= size.x) {\n        if (p.x - rectangle.x >= -size.x) {\n            Dx = 0.0;\n        } else {\n            Dx = rectangle.x - size.x - p.x;\n        }\n    } else {\n        Dx = p.x - rectangle.x - size.x;\n    }\n    if (p.y - rectangle.y <= size.y) {\n        if (p.y - rectangle.y >= -size.y) {\n            Dy = 0.0;\n        } else {\n            Dy = rectangle.y - size.y - p.y;\n        }\n    } else {\n        Dy = p.y - rectangle.y - size.y;\n    }\n    if (p.z - rectangle.z <= size.z) {\n        if (p.z - rectangle.z >= -size.z) {\n            Dz = 0.0;\n        } else {\n            Dz = rectangle.z - size.z - p.z;\n        }\n    } else {\n        Dz = p.z - rectangle.z - size.z;\n    }\n    return sqrt(Dx * Dx + Dy * Dy + Dz * Dz);\n}\nfloat DistSphere(vec3 p, vec4 sphere) {\n    return length(p - sphere.xyz) - sphere.w;\n}\nfloat DistTorus(vec3 p, vec3 torus, vec2 size) {\n    vec3 v = torus - p;\n    vec2 q = vec2(length(v.xz) - size.x, v.y);\n\treturn length(q) - size.y;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 torus1 = vec3(3.0, 0.4, 8.0);\n    vec2 SizeTorus1 = vec2(1.0, 0.1);\n    vec3 torus2 = vec3(-3.0, 0.4, 8.0);\n    vec2 SizeTorus2 = vec2(1.0, 0.1);\n    \n    vec4 sphere0 = vec4(0.0, 0.7, 7.0, 0.5); //sphere, which is forward\n    sphere0.xz += vec2(sin(4.0 * iTime), 4.0 * cos(iTime)); \n    \n    vec4 sphere1 = vec4(0.0, 11.0, 15.0, 0.3);//Main building of Moscow State University\n    vec3 rectangle1 = vec3(0.0, 2.4, 15);\n    vec3 SizeRectangle1 = vec3(1.2, 2.4, 1.2);\n    vec4 square2 = vec4(0.0, 5.6, 15.0, 0.9);\n    vec4 square3 = vec4(0.0, 7.2, 15.0, 0.7);\n    vec3 rectangle2 = vec3(0.0, 9.3, 15.0);\n    vec3 SizeRectangle2 = vec3(0.2, 1.4, 0.2);\n    \n    vec3 rectangle3 = vec3(2.6, 1.2, 15.0);\n    vec3 SizeRectangle3 = vec3(1.3, 1.2, 1.0);\n    vec3 rectangle4 = vec3(4.5, 1.2, 15.0);\n    vec3 SizeRectangle4 = vec3(0.6, 1.2, 3.6);\n    vec4 square4 = vec4(4.5, 2.9, 12.0, 0.5);\n    vec4 sphere2 = vec4(4.5, 3.7, 12.0, 0.3);\n    vec4 square5 = vec4(4.5, 2.9, 18.0, 0.5);\n    vec4 sphere3 = vec4(4.5, 3.7, 18.0, 0.3);\n    \n    vec3 rectangle5 = vec3(-2.6, 1.2, 15.0);\n    vec3 SizeRectangle5 = vec3(1.3, 1.2, 1.0);\n    vec3 rectangle6 = vec3(-4.5, 1.2, 15.0);\n    vec3 SizeRectangle6 = vec3(0.6, 1.2, 3.6);\n    vec4 square6 = vec4(-4.5, 2.9, 12.0, 0.5);\n    vec4 sphere4 = vec4(-4.5, 3.7, 12.0, 0.3);\n    vec4 square7 = vec4(-4.5, 2.9, 18.0, 0.5);\n    vec4 sphere5 = vec4(-4.5, 3.7, 18.0, 0.3);\n    float DistPlane = p.y;\n    float Torus = min(DistTorus(p, torus1, SizeTorus1),\n                    DistTorus(p, torus2, SizeTorus2));\n    float Sphere = min(DistSphere(p, sphere1),\n                   min(DistSphere(p, sphere2),\n                   min(DistSphere(p, sphere3),\n                   min(DistSphere(p, sphere4),\n                   min(DistSphere(p, sphere5),\n                   DistSphere(p, sphere0))))));\n    float Square = min(DistSquare(p, square2),\n                   min(DistSquare(p, square3),\n                   min(DistSquare(p, square4),\n                   min(DistSquare(p, square5),\n                   min(DistSquare(p, square6),\n                   DistSquare(p, square7))))));\n    float Rectangle = min(DistRectangle(p, rectangle1, SizeRectangle1),\n                      min(DistRectangle(p, rectangle2, SizeRectangle2),\n                      min(DistRectangle(p, rectangle3, SizeRectangle3),\n                      min(DistRectangle(p, rectangle4, SizeRectangle4),\n                      min(DistRectangle(p, rectangle5, SizeRectangle5),\n                      DistRectangle(p, rectangle6, SizeRectangle6))))));\n    float minimum = min(Torus, min(Sphere,\n                    min(Square, min(Square, \n                    min(Rectangle, DistPlane)))));\n    if (minimum == Torus) {\n        return vec4(0.0, 0.0, 1.0, Torus);\n    }\n    if (minimum == Sphere) {\n        return vec4(1.0, 1.0, 0.0, Sphere);\n    }\n    if (minimum == Square) {\n        return vec4(1.0, 1.0, 1.0, Square);\n    }\n    if (minimum == Rectangle) {\n        return vec4(1.0, 0.0, 0.0, Rectangle);\n    }\n    if (minimum == DistPlane) {\n        return vec4(0.2, 0.817, 0.2, DistPlane);\n    }\n    return vec4(MAX_DIST, 0.0, 0.0, 0.0);\n}\nfloat RayMarch (vec3 RayOri, vec3 RayDi) {\n    float DistOrig = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = RayOri + DistOrig * RayDi;\n        float dist = GetDist(p).w;\n        DistOrig += dist;\n        if (dist < SMALL_DIST || DistOrig > MAX_DIST) break;\n    }\n    return DistOrig;\n}\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    float d = GetDist(p).w;\n    vec3 norm = d - vec3(\n        GetDist(p - e.xyy).w,\n        GetDist(p - e.yxy).w,\n        GetDist(p - e.yyx).w);\n    \n    return normalize(norm); \n}\nvec3 GetColour(vec3 p) {\n    vec3 LightPos[2];\n    LightPos[0] = vec3(0, 15, 12);\n    LightPos[1] = vec3(0, 15, 12);\n    LightPos[0].xz += vec2(sin(iTime), cos(iTime)) * 8.0;\n    LightPos[1].xz += vec2(sin(iTime + 3.14 * 0.2), cos(iTime + 3.14 * 0.2)) * 8.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 2; ++i) {\n        vec3 LightDi = normalize(LightPos[i] - p);\n        vec3 norm = GetNormal(p);\n        vec3 e = normalize(-p);\n        vec3 refl = normalize(-reflect(LightDi, norm));\n        \n        vec3 amb = GetDist(p).xyz * 0.3;\n        vec3 dif = amb * 0.8 * max(dot(norm, LightDi), 0.0);\n        dif = clamp(dif, 0.0, 1.0);\n        vec3 spec = vec3(1.0) * pow(max(dot(refl, e), 0.0), 60.0);\n        spec = clamp(spec, 0.0, 1.0);\n        col += 0.5 * (amb + dif + spec);\n    }\n    float light = 1.0;\n    float d = RayMarch(p + GetNormal(p) * SMALL_DIST * 2.0, normalize(LightPos[0] - p));\n    if (d < length(LightPos[0] - p)) {\n        col *= 0.7;\n    }\n    d = RayMarch(p + GetNormal(p) * SMALL_DIST * 2.0, normalize(LightPos[1] - p));\n    if (d < length(LightPos[1] - p)) {\n        col *= 0.7;\n    }\n    float fog = clamp(length(p) / 15.5, 0.0, 1.0); \n\tcol = col * (1.0 - fog) + fog * vec3(0.7, 0.7, 0.7);\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(1.0, 1.0, 0.0);\n    \n    vec3 RayOri = vec3(0, 1, 0);\n    uv.y = uv.y + 0.2;\n    vec3 RayDi = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(RayOri, RayDi);\n    vec3 p = RayOri + RayDi * d;\n    col = GetColour(p);\n    \n    float red;\n    float green;\n\t/*if (d > MAX_DIST) {\n        red = -1.0 * uv.y + 1.0;\n        green = -0.35 * uv.y + 1.0;\n        col = vec3(red, green, 1.0);\n    }*/\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}