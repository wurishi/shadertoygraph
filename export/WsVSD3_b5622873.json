{"ver":"0.1","info":{"id":"WsVSD3","date":"1575195803","viewed":119,"name":"SDF jacqes","username":"jacquespillet","description":"Tests with sdfs","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_TRACE_DISTANCE = 100.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\n//Simplex noise\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n\n\n\n    \n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    vec2 res;\n    res.x = opSmoothUnion(\n        sdSphere( pos - vec3(-1,1,1) , 2.0),\n        sdRoundBox( pos, vec3( 2 , 1 , 2 ), 0.1),\n        0.0\n    );\n    \n    //res.x += simplex3d_fractal(pos) * 0.1 * cos(iTime);\n    res.y = 1.0;\n    \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in Ray ray ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ray.origin+ray.direction*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , Ray ray ){\n  vec3 color =texture(iChannel0, ray.direction).rgb;\n    \n  vec3 lightPos = vec3( 0 , 2. , 6. );\n    \n    \n  if( res.y > 0.0){\n      \n    vec3 pos = ray.origin + ray.direction * res.x;\n    vec3 norm = calcNormal( pos );\n      \n    vec3 lightDir = normalize( lightPos - pos );\n    vec3 fragToCam = normalize( pos - ray.origin );\n    \n    float diffuse = max( 0. , dot( lightDir , norm ));\n      \n      \n\n    vec3 halfwayVec = normalize(lightDir + fragToCam);\n    \n    vec4 tex = texture(iChannel0, norm);\n    vec3 specular =  vec3(tex) * pow(max(dot(norm.xyz, halfwayVec),0.0), 1.0);\n\t\n   \t\n      \n    color = 0.2 * vec3( 1. , 0., 0.) * diffuse + specular +  vec3( .1 , .1, .2 );        \n  }\n   \n  return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\t\n    vec3 ro = vec3(4., 2, 8);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    Ray ray = Ray(ro, rd);\n    vec2 res = calcIntersection(ray);\n\n\t\n    vec3 color = render( res ,ray );\n    \n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}