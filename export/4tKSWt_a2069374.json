{"ver":"0.1","info":{"id":"4tKSWt","date":"1486481423","viewed":422,"name":"Pulsing planets","username":"nomadiclizard","description":"Cast rays detect whether they can ever cross a sphere boundary and step accordingly. Finding a good way to pick march distance when in proximity to surface, to balance efficiency with fidelity is tricky. Next up fog and lighting!","likes":10,"published":1,"flags":1,"usePreview":0,"tags":["3d","raymarcher","vr","planets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a raymarcher\n// started out rendering spheres which have been growing steadily into planets\n\n#define pi 3.141592653589793\n#define twoPi (2.0*pi)\n#define halfPi (0.5*pi)\n#define infinity 100.0\n\n#define SHOWESCAPE\n#define WARP\n\n// raymarching algorithm will march maxsteps and stop when at epsilon from a surface\nconst int maxsteps = 60;\nconst float epsilon = 0.0001;\nconst float minstepfraction = 0.50;\n\n// view stuff\nconst float fov = radians(45.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\nstruct Sphere {\n    // location\n    vec3 p;\n    // spheres have a surface defined between r1 and r2\n\t// rays passing within r1 are guaranteed to hit\n\t// rays passing without r2 are guaranteed to miss\n    float r1;\n    float r2;\n    // rotation matrix\n    mat4 rmatrix;\n    // texture unit pulls from this channel (-1 if none)\n    int texChannel;\n    // height between r1 and r2 pulls from this (-1 if none)\n    int heightChannel;\n};\n\nstruct SphereHit {\n    bool hit;\n    float t1;\n    float t2;\n};        \n\nSphere s_s1 = Sphere(vec3(1.5, 0.0, 0.0), 1.0, 1.25, mat4(1.0), 0, 0);\nSphere s_s2 = Sphere(vec3(-1.5, 0.0, 0.0), 1.0, 1.25, mat4(1.0), 1, 1);\n\nstruct RayHit {\n    // point in space the ray hit and the normal\n    vec3 p;\n    vec3 n;\n    // iteration count and error upon hit\n    int i;\n    float e;\n    // texture colour\n    vec4 tex;\n};\n    \n// useful\nvec3 lookat(vec3 p1, vec3 p2)\n{\n    return normalize(p2 - p1);\n}\n\n// really useful\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// sorta useful\nmat4 translationMatrix(vec3 p)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\n// texture using supplied unit index\n// future hook for simplex noise\nvec4 textureThis(int unit, vec2 uv)\n{\n    if (unit == 0) {\n        return texture(iChannel0, uv);\n    } else if (unit == 1) {\n        return texture(iChannel1, uv);\n    } else if (unit == 2) {\n        return texture(iChannel2, uv);\n    } else if (unit == 3) {\n        return texture(iChannel3, uv);\n    } else {\n        return vec4(0.5, 0.5, 0.5, 1.0);\n    }\n}\n\n// calculates intersection parameters for a ray passing within r2 of the sphere\n// such that p = ro + t.rd for entry and exit of sphere\nSphereHit spherehit(Sphere s, vec3 ro, vec3 rd)\n{\n    vec3 rosp = ro - s.p;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, rosp);\n    float c = dot(rosp, rosp) - (s.r2 * s.r2);\n    float b2m4ac = b * b - 4.0 * a * c;\n    if (b2m4ac >= 0.0) {\n        float r = sqrt(b2m4ac);\n        return SphereHit(true, (-b - r) / (2.0 * a), (-b + r) / (2.0 * a));\n    } else {\n        return SphereHit(false, 0.0, 0.0);\n    }\n}\n\n// radius of sphere at point p computes uv\nfloat sphereradius(Sphere s, vec3 sp, out vec2 uv)\n{\n    vec3 nn = normalize(vec3(s.rmatrix * vec4(sp, 1.0)));\n    uv.x = 0.5 + atan(nn.z, nn.x) / twoPi;\n    uv.y = 0.5 - asin(nn.y) / pi;\n    #ifdef WARP\n    const float amp = 0.07;\n    const float freq = 0.15;\n    const float gran = 3.0;\n    float a = amp * cos(2.0 * pi * (uv.x * gran + freq * iTime)) * sin(2.0 * pi * (uv.y * gran + freq * iTime));\n    return s.r1 + a + (s.r2 - s.r1 - amp) * vec3(textureThis(s.heightChannel, uv)).g;\n    #else\n    return s.r1 + (s.r2 - s.r1) * vec3(texture(s.heightChannel, uv)).g;\n    #endif\n}\n\n// distance from point to surface of a sphere directly below it computes uv \nfloat spheredist(Sphere s, vec3 p, out vec2 uv)\n{\n    vec3 sp = p - s.p;\n    return length(sp) - sphereradius(s, sp, uv);\n}\n\n// check a sphere for ray intersection passing within epsilon of surface\n// computes rayhit and updates mindist\nbool checksphere(Sphere s, SphereHit sh, float t, vec3 rd, vec3 p, int i, inout float mindist, out RayHit hit)\n{\n    if (sh.hit) {\n    \t// if current ray position is within r2 of the sphere\n        if(t >= sh.t1 && t <= sh.t2) {\n        \t// possibly hitting this sphere - figure out for sure\n    \t\tvec2 uv;\n            float et = epsilon * t;\n    \t\tfloat d = spheredist(s, p, uv);\n    \t\tif (d <= et) {\n                // normal will be dh/dx, dh/dy, dh/dz\n                #ifndef SHOWESCAPE\n                vec2 dummy;\n                float xd = spheredist(s, p + right * et, dummy);\n                float yd = spheredist(s, p + up * et, dummy);\n                float zd = spheredist(s, p + forward * et, dummy);\n                vec3 n = normalize(vec3(xd - d, yd - d, zd - d));\n                vec4 c = texture(s.texChannel, uv);\n                #else\n                vec3 n = vec3(0.0);\n                vec4 c = vec4(float(s.texChannel) + 1.0);\n                #endif\n\t            hit = RayHit(p, n, i, d, c);\n\t        \treturn true;\n\t    \t} else {\n\t            // min dist should be some fraction of our height above the sphere\n        \t\tmindist = min(mindist, d * minstepfraction);\n\t        }\n\t    } else if (t < sh.t1) {\n    \t    // not within sphere - can step fully up to it\n            mindist = min(mindist, sh.t1 - t);\n        }\n    }\n\treturn false;\n}\n\n// march til we hit an object in the scene or the skybox\nbool raymarch(vec3 ro, vec3 rd, out RayHit hit)\n{\n    // precalc useful stuff for sphere intersection\n    float t = 0.0;\n    int breakstep = maxsteps;\n    SphereHit sh1 = spherehit(s_s1, ro, rd);\n    SphereHit sh2 = spherehit(s_s2, ro, rd);\n    \n    // march up to maxsteps\n    for (int i = 0; i < maxsteps; i++) {\n        float mindist = infinity;\n        vec3 p = ro + t * rd;\n        // check the spheres\n        if (checksphere(s_s1, sh1, t, rd, p, i, mindist, hit)) return true;\n        if (checksphere(s_s2, sh2, t, rd, p, i, mindist, hit)) return true;\n        // diverging from everything?\n        if (t > infinity) { breakstep = i; break; }\n        // march on\n        t += max(mindist, epsilon);\n    }\n    // assume intersection with skybox (??or last object to get close to??)\n    hit = RayHit(ro + infinity * rd, -rd, breakstep, 0.0, vec4(0.0));\n    return false;\n}\n\n// black -> white via red and yellow for 0,1\nvec4 falsecolourr(float x, float stretch)\n{\n    float px = pow(x, stretch) * pi;\n    return vec4(sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\n// black -> white via green and cyan for 0,1\nvec4 falsecolourg(float x, float stretch)\n{\n    float px = pow(x, stretch) * pi;\n    return vec4(sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    // make the spheres orbit and spin\n    mat4 omatrix = rotationMatrix(up, 0.05 * twoPi * iTime);\n    mat4 rmatrix = rotationMatrix(vec3(1.0, 1.0, 0.0), radians(30.0));\n    mat4 tmatrix = translationMatrix(vec3(0.0, 0.0, -3.5));\n    {\n    \ts_s1.p = vec3(tmatrix * rmatrix * omatrix * vec4(s_s1.p, 1.0));\n        vec3 axis = vec3(rmatrix * vec4(up, 1.0));\n        float angle = 0.15 * twoPi * iTime;\n    \ts_s1.rmatrix = rotationMatrix(axis, angle);\n    }\n    {\n    \ts_s2.p = vec3(tmatrix * rmatrix * omatrix * vec4(s_s2.p, 1.0));\n    \tvec3 axis = vec3(rmatrix * vec4(up, 1.0));\n        float angle = 0.10 * twoPi * iTime;\n        s_s2.rmatrix = rotationMatrix(axis, angle);\n    }\n    \n    // raymarch in that direction\n    RayHit hit;\n    raymarch(fragRayOri, fragRayDir, hit);\n    \n    #ifdef SHOWESCAPE\n    // use the iteration escape count to provide render efficiency feedback\n    float escape = float(hit.i) / float(maxsteps);\n    float error = abs(20.0 * hit.e * cos(iTime));\n    if (hit.tex.x == 0.0) {\n\t    fragColor = falsecolourg(escape, 1.0);\n\t} else {\n\t    fragColor = falsecolourr(escape, 1.0);\n    }\n    fragColor.b += error;\n    #else\n    // oooo dot product lighting\n    float lightintensity = dot(forward, hit.n);\n    fragColor = hit.tex * lightintensity;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // figure out where to look (the VR version does it for us)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, vec3(uv.x * tan(fov), uv.y * tan(fov), -1.0));\n    \n    // render\n    mainVR( fragColor, fragCoord, ro, rd);\n}","name":"Image","description":"","type":"image"}]}