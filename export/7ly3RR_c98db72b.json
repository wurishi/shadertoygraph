{"ver":"0.1","info":{"id":"7ly3RR","date":"1637045040","viewed":63,"name":"rgb spheres","username":"venturecapital","description":"limited range diffuse light shading with multiple \"materials\"","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shadow","beginner","checkerboard","messy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAXIMUM_RAY_STEPS = 1024;\nfloat MIN_DIST = .001;\nfloat MAX_DIST = 69.;\n\n// EPSILON Ïµ - usually used to denote a small quantity\nfloat EPSILON = 0.0001;\n\n// Materials\nint m_n = 99;\nint m_s1 = 0;\nint m_s2 = 1;\nint m_s3 = 2;\nint m_plane = 3;\n\n// n is a Plane Equation. .xyz is the normal vector of the plane and .w is the distance from origin.\n// n must be normalized\nfloat sdfPlane(vec3 p, vec4 n) {\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdfSphere(vec3 p, float r, vec3 c) {\n    return distance(p, c)-r;\n}\n\n// returns [dist, material]\nvec2 sdf(vec3 p) {\n    // floaty point modifier gives the sphere centers a slight wobble\n    float fp1 = sin(iTime) * 0.02;\n    float fp2 = sin(iTime) * 0.021;\n    float fp3 = sin(iTime) * 0.022;\n\n    float speed = 0.4;\n\n    float r = .25;\n\n    float outer_y = sin(iTime*speed) * .4;\n\n    float plane = sdfPlane(p, vec4(0., 1., 0., 1.));\n\n    float s1 = sdfSphere(p, r, vec3(-r*1.5, -outer_y+fp1, cos(iTime*speed)*r*1.5));\n    float s2 = sdfSphere(p, r, vec3(.0, .0+fp2, .0));\n    float s3 = sdfSphere(p, r, vec3(r*1.5, outer_y+fp3, -cos(iTime*speed)*r*1.5));\n\n    float dist = min(plane, min(min(s1,s2),s3));\n\n    if (dist == plane) return vec2(dist, m_plane);\n    if (dist == s1) return vec2(dist, m_s1);\n    if (dist == s2) return vec2(dist, m_s2);\n    if (dist == s3) return vec2(dist, m_s3);\n}\n\n// via iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdf(ro + rd*t).x;\n        if( h<0.001 ) return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// via https://iquilezles.org/\nvec3 getNormal( vec3 p) {\n    vec2 h = vec2(EPSILON, 0);\n    return normalize(vec3(\n        sdf(p + h.xyy).x - sdf(p - h.xyy).x,\n        sdf(p + h.yxy).x - sdf(p - h.yxy).x,\n        sdf(p + h.yyx).x - sdf(p - h.yyx).x\n    ));\n}\n\nfloat checkerboard(vec3 p) {\n    float cx = floor(1. * p.x);\n    float cy = floor(1. * p.z); \n    float result = mod(cx + cy, 2.0);\n    return sign(result);\n}\n\n// diffuse lighting\nfloat diffuse(vec3 origin, vec3 p) {\n    float d = distance(origin, p);\n    vec3 l = normalize((origin - p) * d);\n    vec3 n = getNormal(p);\n\n    // dot gives value between -1 and 1\n    // clamp between 0 and 1\n    float diffuse = clamp(dot(n, l), 0., 1.);\n    return clamp(diffuse * (5./distance(origin.xz, p.xz)), 0., 1.);\n}\n\n// src - https://www.shadertoy.com/view/4tByzD\nvec2 rayMarch(vec3 origin, vec3 direction) {\n    // used to store current and last distance\n    vec2 dist = vec2(MIN_DIST);\n\n    for (int i = 0; i < MAXIMUM_RAY_STEPS; i++) {\n        // get the point we hit\n        vec3 p = origin + direction * dist.y;\n\n        // get minimal distance from objects in the scene\n        vec2 d = sdf(p);\n        dist.x = d.x;\n\n        // collision detection\n        if (dist.x <= EPSILON) {\n            // return the last depth\n            return vec2(dist.y, d.y);\n        }\n\n        // increase last distance\n        dist.y += dist.x;\n\n        if (dist.y >= MAX_DIST) {\n            return vec2(MAX_DIST, m_n);\n        }\n    }\n\n    return vec2(MAX_DIST, m_n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // this makes it so that the zero uvs are in the center of the view\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\n    // rayMarch scene\n    vec3 cam = vec3(0., .25, 3);\n    vec3 light = vec3(-sin(iTime*.3)*7., 4., (sin(iTime*.6)*5. + 10.)/2. - 1.);\n    \n    vec3 direction = normalize(vec3(uv, -1));\n    vec2 result = rayMarch(cam, direction);\n    float dist = result.x;\n    int mat = int(result.y);\n\n    vec3 color = vec3(0., 0., 0.);\n    if (dist < MAX_DIST) {\n        vec3 p = cam + direction * dist;\n        vec3 normal = getNormal(p);\n\n        if (mat == m_s1) color=vec3(.8,0,0);\n        if (mat == m_s2) color=vec3(0,.8,0);\n        if (mat == m_s3) color=vec3(0,0,.8);\n        if (mat == m_plane) color = vec3(checkerboard(p)+0.3);\n\n        float diffuse = diffuse(light, p);\n        color *= vec3(diffuse);\n\n        // brighten things up a bit\n        color *= 1.05;\n\n        float softShadow = softshadow(p, normalize(light), .1, 10., 40.);\n        color *= (softShadow+0.1);\n    }\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}