{"ver":"0.1","info":{"id":"tdVfDR","date":"1607037676","viewed":60,"name":"function walk (vlllll)","username":"valalalalala","description":"Another sort of ray-tracer. It walks along each ray and tests detects a hit when the value of the function (z=f(x,y)) is close to the z value along the ray. \n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","function"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// walk along a ray until it gets close to a function\n// https://tutorial.math.lamar.edu/Classes/CalcIII/QuadricSurfaces.aspx\n\n#define PI2    6.2831952\n#define POZ(v) clamp(v,0.,abs(v))\n#define TIME   iTime * 1.\n\n#define F1(at) ( 0.50 * ( cos( at.x * PI2 ) + sin( at.y * PI2 ) ) )\n#define F2(at) dot(at,at)\n#define F3(at) at.x*at.y+at.x*at.y\n#define F4(at) ( 7.7 * pow( at.x, 2. ) + 1. * pow( at.y, 2. ) )\n#define F5(at) sqrt( POZ( at.x*at.y * 0.33 + 0.13 ) )\n#define F6(at) pow( at.x, 2. ) - pow( at.y, 2. )\n\n\n#define LIGHT_POWER  3.0\n#define LIGHT        vec3( 0.0, 0., 1.33 )\n#define AMBIENT      0.2\n\n#define COUNT     1344\n#define xCOUNT  512\n#define THRESHOLD 0.00033\n\n#define AA\n\nstruct Hit {\n    float t;\n    vec3 hit;\n    vec3 normal;\n};\n\n\nfloat eq( in int i, in float value ) {  \n    return clamp(1.-step(0.3,abs(float(i)-floor(value))),0.,1.);\n}\n\nfloat to3( in int i, in float t, in vec3 at, in float z ) {\n    return eq( i, t ) * z;\n}\n\nfloat evaluateFunction( in vec3 at ) {\n\tfloat t = 1. + mod( TIME * 0.11, float( 5 ));\n\treturn 0.\n        + to3( 1, t, at, F1( at ) )\n        + to3( 2, t, at, F2( at ) )\n        + to3( 3, t, at, F3( at ) )\n        + to3( 4, t, at, F4( at ) )\n        + to3( 5, t, at, F5( at ) )\n        + to3( 6, t, at, F6( at ) )\n    ;\n}\n\nHit makeHit( in float t, in vec3 a, in vec3 increment ) {\n\tvec3 oncrement = vec3( -increment.y, increment.x, 0. );\n    vec3 b = a + increment;\n    vec3 c = a + oncrement;\n    b.z = evaluateFunction( b );\n    c.z = evaluateFunction( c );\n    vec3 ab = normalize( b - a );\n    vec3 ac = normalize( c - a );           \n    return Hit( t, a, cross( ab, ac ) );\n}\n\nHit walk( in vec3 at, in vec3 direction ) {\n\tvec3 increment = direction / float( COUNT );\n    \n\tfor ( int i = 0 ; i < COUNT ; i++ ) {\n        float z = evaluateFunction( at );\n        float d = pow( at.z - z, 2.0 );\n        if ( d > THRESHOLD ) {\n            at += increment;\n        } else {\n            float t = float( i ) / float( COUNT );\n            at.z = z;\n            return makeHit( t, at, increment );\n        }\n    }\n    return Hit( -1., vec3(0.), vec3(0.) );\n}\n\nvec3 colorHit( in Hit hit_ ) {\n    float t = hit_.t;\n    vec3 hit = hit_.hit;\n    vec3 normal = hit_.normal;\n    \n\tvec3 toLight = LIGHT - hit;\n\tfloat angleLight = dot( normalize( toLight ), normal );\n\tfloat distanceLight = dot( toLight, toLight );\n    float valueLight = LIGHT_POWER / distanceLight;\n  \n    angleLight = clamp( angleLight, 0., 1. );\n        \n    // check if light is blocked...\n    \n    float selfAvoidance = THRESHOLD;\n    Hit occlusion = walk( hit + toLight * selfAvoidance, toLight );\n    \n    // any hit blocks light: t=-1 -> 1 ; t=0.33 -> 0 \n    float occluded = 1.-step( 0., occlusion.t );\n    \n    // closer hits block more light\n    //occluded = abs( occlusion.t ); \n    \n    // distant hits block more light\n    occluded = clamp( 0., 1., occlusion.t );\n    \n    //occluded = pow( abs(occlusion.t), 0.15 );\n    //occluded = 1.;\n    \n    // calulate effect of light\n    \n    float light = AMBIENT;\n    light += (1.-light) * valueLight * angleLight * occluded;\n    \n    // the actual color part... kinda lame...\n    \n    vec3 color = abs( vec3( hit.x, hit.y, hit.z ) );\n    color = 1.2 * t * 0.7  + 0.23 * color;\n    \n    //color *= (0.6+0.3*abs( normal.z ));\n    \n\t// final color\n    \n    return light * color;\n}\n\nvec3 colorAt( in vec2 xy  ) {   \n    float t = TIME * 1.6;\n    vec2 rot = vec2(cos(t), sin(t));\n\n    // bumping the z beyond 200 is fun\n    vec3 origin = vec3(xy *2., 2.0 + abs( sin( t ) ) * 3. ); \n    vec3 destination = vec3( xy + rot + 0.50, -1. );    \n    vec3 direction = destination - origin;\n    \n    // primary and secondary rays\n    \n    Hit primary = walk( origin, direction );   \n    Hit secondary = walk( primary.hit, -primary.normal );\n    \n    vec3 primaryColor    = colorHit( primary );\n    vec3 secondaryColor  = colorHit( secondary );\n    float primaryLegit   = step( 0., primary.t );\n    float secondaryLegit = step( 0., secondary.t );\n    float neitherLegit   = 1. - primaryLegit;\n    \n    primaryColor   *= primaryLegit;\n    secondaryColor *= secondaryLegit;\n    vec3 foreground = mix( primaryColor, secondaryColor, 0.2 );\n    \n    vec2 bxy = fract( abs(xy) ) - 0.5 + 0.5 * rot;\n    float bl = dot( bxy, bxy );\n    //bl = ( bxy.x * bxy.y );\n    vec3 background = vec3( bxy, bl ) * neitherLegit * 0.33;\n\n    return foreground + background;\n}\n\nvec3 raerae( in vec2 st, in float scale ) {\n    vec2 xy = (2.0*st-iResolution.xy) / iResolution.y * scale;\n    return colorAt( xy );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float f = 0.5 / iResolution.y;\n    float scale = 1.1 + abs( cos( TIME ) );\n    \n\tfloat weight = 1.;\n    \n    vec3 color = vec3( 0. );\n    color += raerae( fragCoord.xy + vec2( 0., 0. ), scale );\n#ifdef AA\n    weight = 0.25;\n    color += raerae( fragCoord.xy + vec2( f,  0. ), scale );\n    color += raerae( fragCoord.xy + vec2( f,  f  ), scale );\n    color += raerae( fragCoord.xy + vec2( 0., f  ), scale );\n#endif\n    fragColor = vec4( weight * color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}