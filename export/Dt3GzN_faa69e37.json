{"ver":"0.1","info":{"id":"Dt3GzN","date":"1681994008","viewed":170,"name":"Hyperboloid - Intersection","username":"Poisson","description":"A simple way to calculate ray - hyperbola intersection.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raytracer","ray","raycasting","sphere","intersection","specular","ellipsoid","quadratic","equation","raycaster","hyperbola","hyperboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3 // antialiasing\n\n// hyperbola intersection + normal\n// this is just a modified ellipsoid\n// th is the thickness of the center\n// 0 th creates 2 symetric cones\nvec4 hypIntersect(vec3 ro, vec3 rd, vec3 ce, vec3 ra, float th) {\n    vec3 oc = ro - ce;\n    vec3 r2 = abs(ra)*ra; // squared size\n    \n    // solve quadratic equation\n    float a = dot(rd, rd/r2);\n    float b = dot(oc, rd/r2);\n    float c = dot(oc, oc/r2) - abs(th)*th;\n    float h = b*b - a*c; // discriminant\n    \n    if(h<0.) return vec4(-1); // no intersection\n    float t = (-b - sqrt(h))/a; // distance\n    // normal\n    // please tell me if the normal calculation is not right\n    vec3 n = normalize((oc + rd*t)/r2);\n    \n    return vec4(t, n);\n}\n\n// hyperbola shadow\nfloat hypShadow(vec3 ro, vec3 rd, vec3 ce, vec3 ra, float th) {\n    vec3 oc = ro - ce;\n    vec3 r2 = sign(ra)*ra*ra;\n    \n    float a = dot(rd, rd/r2);\n    float b = dot(oc, rd/r2);\n    float c = dot(oc, oc/r2) - sign(th)*th*th;\n    float h = b*b - a*c;\n    \n    if (b>0. || h<0.) return 1.;\n    return 0.;\n}\n\n// simple pattern by iq\nvec3 pattern(vec2 uv) {\n    vec3 col = vec3(.6);\n    col += .4*smoothstep(-.01, .01, cos(uv.x*.5)*cos(uv.y*.5)); \n    col *= smoothstep(-1., -.98, cos(uv.x)) * \n           smoothstep(-1., -.98, cos(uv.y));\n    return col;\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd, int id) {\n    vec3 bgCol = vec3(.5+.5*rd.y)*.03; // background\n    vec3 col = bgCol;\n    \n    // hyperbola animation\n    vec3 ce = vec3(0); // center\n    // size\n    vec3 ra;\n    float th; // thickness\n    if (cos(.8*iTime)<0.) {\n        ra = vec3(.75,-1.5,-1.5);\n        th = id==0 ? 1.: -1.;\n    } else {\n        ra = vec3(1,-1,1)*vec3(1.+.4*sin(iTime),1.4+.7*cos(iTime),1.+.5*cos(iTime+1.));\n        th = .5+.5*sin(iTime*.6+3.);\n        if (id!=0) th *= -1.;\n    }\n    \n    float t = 1e10; // distance\n    vec3 n;\n    \n    // plane\n    float t1 = (-4.-ro.y)/rd.y;\n    if (t1>0.) {\n        t = t1;\n        n = vec3(0,1,0);\n        col = vec3(.6);\n    }\n    \n    // hyperbola\n    vec4 tn = hypIntersect(ro, rd, ce, ra, th);\n    if (tn.x>0. && tn.x<t) {\n        t = tn.x;\n        n = tn.yzw;\n        \n        vec3 p = ro + rd*t - ce;\n        if (cos(.8*iTime)<0.) p = p.yxz;\n        vec2 uv = vec2(atan(p.x,p.z), p.y); // 2d coordinates\n        col = pattern(16.*uv);\n    }\n    \n    if (t<1e10) { // we hit the surface\n        vec3 p = ro + rd*t; // hit point\n        \n        vec3 lig = vec3(.57735); // light direction\n        vec3 hal = normalize(lig - rd); // half vector for specular\n        \n        float dif = clamp(dot( n, lig),0.,1.); // diffuse light\n        float bac = clamp(dot(-n, lig),0.,1.); // back/bounce light\n        float sha = hypShadow(p, lig, ce, ra, th); // shadow\n        float spe = clamp(dot(n, hal),0.,1.); // blinn phong specular\n        float occ = .6+.4*n.y; // ambient occlusion\n        \n        vec3 lin = vec3(0);\n        lin += vec3(.2,.3,.4)*occ; // sky light\n        lin += 1.8*vec3(1,.9,.7)*dif*sha; // key light\n        lin += occ*.3*vec3(1,.9,.7)*bac*bac; // bounce light\n        \n        col *= lin;\n        col += dif*sha*.7*pow(spe,48.); // specular\n        \n        col = mix(col, bgCol, 1.-exp(-t*.02)); // fog\n    }\n    \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // side vector\n    vec3 v = cross(u, w); // up vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized mouse coordinates\n    vec2 mo = (iMouse.xy - .5*iResolution.xy)/iResolution.y;\n    \n    // camera xz rotation\n    float an = .4*iTime + mo.x*3.14192;\n    vec3 ro = 16.*vec3(sin(an),.2,cos(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 tot = vec3(0); // accumulated color\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n        int id = int(step(p.x,0.));\n        p.x = fract(p.x)-.5;\n        \n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n        vec3 col = render(ro, rd, id); // render\n        \n        col = col*1.3/(1.+.7*col); // tonemapping\n        col = pow(col, vec3(.4545)); // gamma correction\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .5+.5*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    \n    // output\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}