{"ver":"0.1","info":{"id":"csl3Ds","date":"1667034632","viewed":88,"name":"cone variations","username":"kastorp","description":"exact sdf for some cone variations:  symmetric, orthogonal, cave, lamp","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Cone Variations by Kastorp\n//----------------------------\n//just trivial exercises but may be useful\n\n//R=max radius, h= height; origin= base center, axis=z\n// calculated as distance from two segments in the intersection plane, with sign \nfloat cone(vec3 pp,float R, float h) {\n  vec2  p=vec2(length(pp.xy), pp.z), a=vec2(R,0),c=vec2(0,h); //plane coordinates and vertexes\n  return min(\n   length(p- mix(a, vec2(0), clamp((R - p.x) / R, 0., 1.))), //base segment\n   length(p- mix(a, c, clamp(dot(p - a, normalize(c - a)) / length(c - a), 0., 1.))) //rope segment\n  )* ( p.y<0.|| p.x/R+p.y/h>1.?1.:-1.);  //negative if inside cone\n}\n\n//R=max radius, h= height; origin= center, axis=z\nfloat symcone(vec3 pp,float R, float h) {\n  vec2  p=vec2(length(pp.xy), pp.z), a=vec2(R,0),c=vec2(0,h); //plane coordinates and vertexes\n  return min(\n   length(p- mix(a, c, clamp(dot(p - a, normalize(c - a)) / length(c - a), 0., 1.))), //upper segment\n   length(p- mix(a,- c, clamp(dot(p - a, normalize(-c - a)) / length(-c - a), 0., 1.))) //lower segment\n  )* ( p.x/R-p.y/h>1.|| p.x/R+p.y/h>1.?1.:-1.);  //negative if inside cone\n}\n\n//easy formula  R=radius, h= height; origin= center, axis=z\nfloat cylinder(vec3 pp,float R,float h) {\n  vec2  v=abs(vec2(length(pp.xy), pp.z)) -vec2(R,h);\n  return length(max(v,0.))+min(max(v.x,v.y),0.); \n}\n\n//h=height, n= aperture direction; origin= base center, axis=z\nfloat orthcone(vec3 pp,float h,vec2 n) {\n  vec2 p=vec2(length(pp.xy), pp.z-h), v=abs(p*mat2(n.x,n.y,-n.y,n.x)) -h*n.yx;\n  return length(max(v,0.0))+min(max(v.x,v.y),0.0); \n}\n\n//R=max radius, tk= thickness, n= aperture direction; origin= base center, axis=z\nfloat cavecone(vec3 pp,float R,float  tk, vec2 n) {\n  vec2 p=vec2(length(pp.xy), pp.z), \n       v=abs(p*mat2(n.x,n.y,-n.y,n.x)) -vec2(R,tk);\n  return length(max(v,0.0))+min(max(v.x,v.y),0.0); \n}\n\n//R= mean radius, h=height, tk= thickness, n= aperture direction; origin= center, axis=z\nfloat lamp(vec3 pp,float R,float h,float  tk, vec2 n) {\n  vec2 p=vec2(length(pp.xy)-R, pp.z), \n       v=abs(p*mat2(n.x,-n.y,n.y,n.x)) -vec2(h,tk);\n  return length(max(v,0.0))+min(max(v.x,v.y),0.0); \n}\n\nfloat map(vec3 p) {      \n    float d= p.y; \n    p.xz=mod(p.xz+2.5,5.)-2.5;\n    float ap=.4+sin(iTime*3.)*.1; //aperture =R/h\n    vec2 n=normalize(vec2(ap,1));\n    \n     d= min(d,symcone(p.xzy -vec3(1,-.5,.5) ,ap*.5,.5));\n     d= min(d,cone(p.xzy -vec3(0,2,0) ,ap,1.));    \n     d= min(d,orthcone(p.xzy -vec3(1.5,1,0) ,.5,n));\n     d= min(d,cavecone(p.xzy -vec3(.5,.5,0) ,.7,.01,n));\n     d= min(d,lamp(p.xzy -vec3(-.5,0,.2), .2,.2,.01,n));\n    return d;\n}\n\n//-------------------------\n\n//Iq\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .001 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\treturn normalize(n);\n}\n\n//Iq\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat s = 1., t = .005;\n\tfor (float i = 0.; i < 40.; i++)\n\t{\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\treturn clamp(s, 0., 1.);\n}\n\n//Iq\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0,1., 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 lights(vec3 p, vec3 rd, float d) {\n    vec3 lightDir = normalize( vec3(15.,19.,6.) );\n\tvec3 ld = normalize(lightDir*6.5 - p), n = calcN(p, d) ;\n\n\tfloat ao = 1.,\n\tl1 = max(0., .2 + .8 * dot(ld, n)),\n\tl2 = 0.,\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n\tl1 *= .1 + .9 * calcShadow(p+.001*n, ld);\n\tvec3 lig = ((l1 + l2) * ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\n// Shane\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){ \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\tvec3 p;\n\tfloat d = .01;\n\tfor (float i = 0.; i < 100.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .001  )break;\n        if(d >10.) return vec3(0,.3,.3);\n\t\td += h;\n\t}   \n\treturn (p.y>=0.01?  tex3D(iChannel0 ,p, calcN(p, d) ).rgb:tex3D(iChannel1 ,p, calcN(p, d) ).rgb)*lights(p, rd, d) * exp(-d * .085);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n    float t=-iTime*.5;\n\tvec3 ro = vec3(1.*cos(t),1.1 +4.*iMouse.y/iResolution.y, 1.*sin(t));\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, vec3(.5), uv)), vec3(.45)), fc), 0);\n}\n","name":"Image","description":"","type":"image"}]}