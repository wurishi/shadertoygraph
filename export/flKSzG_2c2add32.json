{"ver":"0.1","info":{"id":"flKSzG","date":"1640909055","viewed":269,"name":"Mandelbrot Explorer (dbl prec)","username":"dahart","description":"MOVE: click to center a point     OR     arrow keys. \nZOOM in/out: z/x    OR     shift + up/down\ndec/Inc iterations: i/I       dec/Inc samples-per-pixel: s/S       \nRESET view: r       CYCLE preset views: v          toggle display of coordinate: d\n","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot","doubleprecision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThis shader is for studying precision and interactively navigating the Mandelbrot set.\n\nMOUSE & KEYBOARD controls:\n\nMOVE: click to center a point  -OR-  arrow keys\nZOOM: z/x                      -OR-  shift + up/down\n\ndec/Inc iterations:             i/I   \ndec/Inc samples-per-pixel:      s/S   \ntoggle display of coordinates:  d\nRESET view:                     r    (also resets samples & iterations)\ncycle predefined views:         v    (some are blocky; at the limit of precision - zoom out a bit)\n\nThere is a small safe/dead click zone in the bottom left corner \nSo you can click (focus the window) without moving the view.\n\nApologies in advance for any/all problems:\nThis shader is strictly WebGL 2, it will give compile errors in WebGL 1 browsers.\nThis shader might be pretty slow on mobile or older GPUs.\nThis shader can be extremely slow for higher iterations and pixel sample counts.\nIf the rendering takes too long, the shader will crash.\nThere are still some artifacts due to a bug or two in my double-precision math code.\nI don't know if the buffer state code works in all GPUs & browsers.\n\nPartly inspired by https://www.shadertoy.com/view/XdsXWN, which can get better than double precision.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor   = vec4(0.);\n    vec4 mandel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 hud    = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor   = comp(mandel, premult(hud));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid UI( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, ifc, 0);\n    \n    if (ifc.y > 0 || ifc.x > 4) return;\n\n    int nr = min(0, iFrame);\n\n    // (0,0) = centerx (hi 16 bits of each channel to reconstruct 2 floats)\n    // (1,0) = centery (hi 16 bits of each channel to reconstruct 2 floats)\n    // (2,0) = size    (hi 16 bits of each channel to reconstruct 2 floats)\n    // (3,0) = (iters (sign=hud), samples, date(secs), view) (int, stored as float)\n    // (4,0) = (iResolution.x, iResolution.y, blockStart, blockEnd)\n\n    vec4 center_x_v4 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 center_y_v4 = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 vsize_v4    = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 opts        = texelFetch(iChannel0, ivec2(3, 0), 0); \n    vec4 res         = texelFetch(iChannel0, ivec2(4, 0), 0);\n    \n    int iters   = int(abs(opts.x));\n    int samples = int(opts.y);\n    int hud     = (opts.x > 0.0) ? 1 : -1;  // int(sign(opts.x)); // int(sign(x)) is broken?\n    int view    = int(opts.w);\n\n    vec2 blockId = res.zw;\n    \n    bool restartRender = false;\n\n    // restart render if the resolution changes (fullscreen, etc.)\n    if (ivec2(res.xy) != ivec2(iResolution.xy)) restartRender = true;\n    \n    uvec2 center_x = v4_to_u2(center_x_v4);\n    uvec2 center_y = v4_to_u2(center_y_v4);\n    uvec2 vsize    = v4_to_u2(vsize_v4);\n    \n    bool isLtKeyDown    = texelFetch(iChannel1, ivec2(LT_KEY, 1), 0).x > 0.;\n    bool isUpKeyDown    = texelFetch(iChannel1, ivec2(UP_KEY, 1), 0).x > 0.;\n    bool isRtKeyDown    = texelFetch(iChannel1, ivec2(RT_KEY, 1), 0).x > 0.;\n    bool isDnKeyDown    = texelFetch(iChannel1, ivec2(DN_KEY, 1), 0).x > 0.;\n    \n    bool isIKeyPressed  = texelFetch(iChannel1, ivec2(I_KEY, 1), 0).x > 0.;\n    bool isDKeyToggled  = texelFetch(iChannel1, ivec2(D_KEY, 2), 0).x > 0.;\n    bool isRKeyDown     = texelFetch(iChannel1, ivec2(R_KEY, 1), 0).x > 0.;\n    bool isSKeyPressed  = texelFetch(iChannel1, ivec2(S_KEY, 1), 0).x > 0.;\n    bool isVKeyPressed  = texelFetch(iChannel1, ivec2(V_KEY, 1), 0).x > 0.;\n    bool isXKeyDown     = texelFetch(iChannel1, ivec2(X_KEY, 1), 0).x > 0.;\n    bool isZKeyDown     = texelFetch(iChannel1, ivec2(Z_KEY, 1), 0).x > 0.;\n    bool isShiftKeyDown = texelFetch(iChannel1, ivec2(SHIFT_KEY, 0), 0).x > 0.;\n    \n    bool isMoveKeyDown  = isLtKeyDown || isUpKeyDown || isRtKeyDown || isDnKeyDown || isXKeyDown || isZKeyDown;\n    bool isZoomKeyDown  = isShiftKeyDown || isXKeyDown || isZKeyDown;\n\n    uvec2[2] newCenter = uvec2[2]( center_x, center_y );\n    uvec2 newVSize     = vsize;\n    \n    if (iFrame == 0 || isRKeyDown) {\n        newCenter[0] = float_to_u2(-0.5);\n        newCenter[1] = float_to_u2(0.);\n        newVSize = float_to_u2(1.);\n        iters = 256;\n        samples = 1;\n        view = -1;\n        restartRender = true;\n    }\n            \n    if (isMoveKeyDown) {\n        if (isZoomKeyDown) {\n            float zoom = 2.;\n            bool zoomin = isUpKeyDown || isZKeyDown;\n            bool zoomout = isDnKeyDown || isXKeyDown;\n            if (zoomin || zoomout) {\n                if (zoomin) zoom = 1. / zoom;\n                newVSize = u2_mul(vsize, float_to_u2(zoom));\n            }\n            if (u2_to_float(newVSize) > 1.5) newVSize = float_to_u2(1.5);\n            restartRender = true;\n        } else {\n            float move = 0.2;\n            bool horiz = isLtKeyDown || isRtKeyDown;\n            uvec2 a = (horiz) ? newCenter[0] : newCenter[1];\n            if (isLtKeyDown || isDnKeyDown) move = -move;\n            uvec2 b = u2_add( a, u2_mul(newVSize, float_to_u2( move)));\n            if (horiz) { newCenter[0] = b; } else { newCenter[1] = b; }\n            #if 0\n            if (isLtKeyDown) newCenter[0] = u2_add( newCenter[0], u2_mul(newVSize, float_to_u2( move)));\n            if (isRtKeyDown) newCenter[0] = u2_add( newCenter[0], u2_mul(newVSize, float_to_u2( move)));\n            if (isUpKeyDown) newCenter[1] = u2_add( newCenter[1], u2_mul(newVSize, float_to_u2( move)));\n            if (isDnKeyDown) newCenter[1] = u2_add( newCenter[1], u2_mul(newVSize, float_to_u2( move)));\n            #endif\n            restartRender = true;\n        }\n    }\n\n    if (isIKeyPressed) {\n        if (isShiftKeyDown) iters = max(int(float(iters) * 1.1), iters+1);\n        else                iters = max(1, min(int(float(iters) / 1.1), iters-1));\n        restartRender = true;\n    }\n\n    if (isSKeyPressed) {\n        if (isShiftKeyDown) samples++;\n        else                samples = max(1, samples-1);\n        restartRender = true;\n    }\n    \n    int newHud = isDKeyToggled ? 1 : -1;\n    //if (hud != newHud) restartRender = true;\n    \n    if (isVKeyPressed) {\n\n    restartRender = true;\n    view = view + 1;\n    if (view > 8) view = 0;\n\n    uint[] views = uint[] (\n        // case 0:\n        0x3f5ff080u, 0x3f7b7d00u, 0x3f2cde00u, 0x3f492480u,\n        0x3f1ff200u, 0x3f49f780u, 0x3f350e00u, 0x3f541280u,\n        0x3f1e7c00u, 0x3f000000u, 0x3f000000u, 0x3f000000u,\n        300u, 1u, // iters, samples\n\n        // case 1:\n        0x3f5ff080u, 0x3f7b7d00u, 0x3f2cde00u, 0x3f492480u,\n        0x3f1ff200u, 0x3f49f780u, 0x3f350e00u, 0x3f541280u,\n        0x3f1e7c00u, 0x3f000000u, 0x3f000000u, 0x3f000000u,\n        300u, 1u, // iters, samples\n\n        // case 2:\n        0x3f5ff080u, 0x3f7b7d00u, 0x3f2cde00u, 0x3f492480u,\n        0x3f1ff200u, 0x3f49f780u, 0x3f350e00u, 0x3f541280u,\n        0x3f1e7c00u, 0x3f000000u, 0x3f000000u, 0x3f000000u,\n        700u, 1u, // iters, samples\n    \n        // case 3: deep spirals\n        0x3f5ff380u, 0x3f7fc000u, 0x3f48e800u, 0x3f25d600u,\n        0x3f1fd280u, 0x3f2a8500u, 0x3f31ff80u, 0x3f74da80u,\n        0x3f1ea780u, 0x3f0cd280u, 0x3f000000u, 0x3f000000u,\n        2000u, 1u, // iters, samples\n    \n        // case 4:\n        0x3f5ff080u, 0x3f69ca00u, 0x3f2eb180u, 0x3f589580u,\n        0x3f1ff200u, 0x3f2a5500u, 0x3f162500u, 0x3f5df400u,\n        0x3f1f3800u, 0x3f000000u, 0x3f000000u, 0x3f000000u,\n        3500u, 1u, // iters, samples\n    \n        // case 5: 3-way lightning\n        0x3f5ffe00u, 0x3f21c500u, 0x3f1bad00u, 0x3f2aa200u,\n        0x3f1fd280u, 0x3f30e980u, 0x3f4f9480u, 0x3f0dcd00u,\n        0x3f1eb000u, 0x3f000000u, 0x3f000000u, 0x3f000000u,\n        1385u, 1u, // iters, samples\n\n        // case 6: sea horses\n        0x3f5fbd80u, 0x3f748180u, 0x3f40dd80u, 0x3f6f4000u,\n        0x3f1ff480u, 0x3f6de800u, 0x3f493980u, 0x3f333200u,\n        0x3f1eac00u, 0x3f000000u, 0x3f000000u, 0x3f000000u,\n        16000u, 1u, // iters, samples\n        \n        // case 7:\n        0x3f5ffe00u, 0x3f37e400u, 0x3f6f5100u, 0x3f2ffb80u,\n        0x3f5fa680u, 0x3f723c80u, 0x3f2cfa80u, 0x3f014000u,\n        0x3f1f5c00u, 0x3f000000u, 0x3f000000u, 0x3f000000u,\n        2250u, 1u, // iters, samples\n        \n        // case 8:\n        0x3f5ffb80u, 0x3f7fcc80u, 0x3f464800u, 0x3f02be80u,\n        0x3f1f5a80u, 0x3f343780u, 0x3f2e4f80u, 0x3f577c80u,\n        0x3f1e9800u, 0x3f000000u, 0x3f000000u, 0x3f000000u,\n        1158u, 1u // iters, samples\n    );\n\n    switch(view) {\n    case 0:\n        // This predefined view is as close as I can get with double-precision \n        // to the view in TekF's shader here https://www.shadertoy.com/view/XdsXWN\n        // TekF's shader gets significantly better than double-precision for this specific view!\n\n        // double-precision bits\n        // newCenter[0].x = 0x3fd451f0u; newCenter[0].y = 0x11c41c40u;\n        // u4_to_u2 takes encoded coordinates, as displayed in the HUD\n        newCenter[0] = u4_to_u2(uvec4(0x3f1fea00u, 0x3f28f800u, 0x3f08e200u, 0x3f0e2000u));\n        \n        //newCenter[1].x = 0xbfdf5c28u; newCenter[1].y = 0x864005fcu;\n        newCenter[1] = u4_to_u2(uvec4(0x3f5fef80u, 0x3f2e1400u, 0x3f432000u, 0x3f02fe00u));\n\n        //newVSize.x = 0x3cc201d0u; newVSize.y = 0xc7e7df45u;\n        newVSize = u4_to_u2(uvec4(0x3f1e7580u, 0x3f000000u, 0x3f000000u, 0x3f000000u));\n        iters = 300;\n        break;\n    \n    case 1:\n        // center of a 5-pronged star\n        newCenter[0] = uvec2( 0xbfe1fd90u, 0x5a255758u );\n        newCenter[1] = uvec2( 0x3fe491f5u, 0x45126abcu );\n        newVSize     = uvec2( 0x3d244b79u, 0u);\n        iters = 300;\n        samples = 1;\n        break;\n    \n    default:\n        int i = view * 14;\n        newCenter[0] = u4_to_u2(uvec4(views[i+0], views[i+1], views[i+2], views[i+3]));\n        newCenter[1] = u4_to_u2(uvec4(views[i+4], views[i+5], views[i+6], views[i+7]));\n        newVSize     = u4_to_u2(uvec4(views[i+8], views[i+9], views[i+10], views[i+11]));\n        iters = int(views[i+12]);\n        samples = int(views[i+13]);\n\n    }\n    }\n        \n    // Click to center the clicked point. \n    if (iMouse.w > 0.) {\n    // Safe zone in the bottom left corner so\n    // I can focus the window without moving the view\n    if (iMouse.z > 50. || iMouse.w > 50.) {\n        float aspect = iResolution.y / iResolution.x;\n        vec2 uv = iMouse.xy / iResolution.xy;\n\n        // map the mouse click to our complex number coordinate\n        // and store it as our new center\n\n        uvec2[2] center = uvec2[2]( center_x, center_y );\n        uvec2[2] size   = uvec2[2]( vsize, vsize);\n        size[0] = u2_mul( size[0], float_to_u2(1./aspect) );\n\n        vec2 wuv = 2. * uv - 1.;\n        for (int i = nr; i < 2; i++) {\n            uvec2 suv = u2_mul( size[i], float_to_u2(wuv[i]) );\n            newCenter[i] = u2_add( center[i], suv );\n        }\n\n        restartRender = true;\n    }\n    }\n    \n\n    if (restartRender) {\n        blockId = vec2(0, MINBLOCKS);\n    } else \n    {\n        float dt = iDate.w - opts.z; // seconds since last frame \n        \n        float prevNumBlocks = blockId.y - blockId.x;\n        float newNumBlocks;\n        \n        // adjust upward slowly, and adjust downward QUICKLY\n        if      (dt < 0.05) newNumBlocks = prevNumBlocks + float(BLOCKINC);\n        else if (dt > 0.20) newNumBlocks = float(MINBLOCKS);\n        else if (dt > 0.10) newNumBlocks = prevNumBlocks / 2.;\n        else                newNumBlocks = prevNumBlocks;\n        \n        newNumBlocks = clamp(newNumBlocks, float(MINBLOCKS), float(MAXBLOCKS));\n        \n        blockId = vec2(blockId.y, blockId.y + newNumBlocks);\n    }\n\n    switch(ifc.x) {\n        case 0: fragColor = u2_to_v4(newCenter[0]); break;\n        case 1: fragColor = u2_to_v4(newCenter[1]); break;\n        case 2: fragColor = u2_to_v4(newVSize); break;\n        case 3: fragColor = vec4(newHud * iters, samples, iDate.w, view); break;\n        case 4: fragColor = vec4(iResolution.xy, vec2(blockId)); break;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < 1. && fragCoord.x < 5.) {\n        UI(fragColor, fragCoord);\n    } \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define INCREMENTAL     // render one block at a time\n#define SHOW_NEXT_BLOCK // display active block\nconst int BLOCKSIZE = 64;\nconst int MINBLOCKS = 1; // min # of blocks to render at once. ideally minBlocks * BLOCKSIZE^2 == # GPU thread cores\nconst int MAXBLOCKS = MINBLOCKS * 8;\nconst int BLOCKINC  = 2; // # blocks to increase at a time based on framerate\n//#define SHOW_COBWEBS    // visualize a little bit of internal set structure (with a bug I accidentally discovered Pickover Stalks)\n\nvec4 premult(vec4 color) {\n    return vec4(color.rgb * color.a, color.a);\n}\n\nvec4 comp(vec4 bg, vec4 fg) {\n    return fg + bg * (1. - fg.a);\n}\n   \n\n#define MASK(nbits) ((1u << (nbits)) - 1u)\nconst uint mask13 = MASK(13);\n\nconst int U2_SIGN_BITS    = 1;\nconst int U2_EXP_BITS     = 11;\nconst int U2_SIGNEXP_BITS = U2_SIGN_BITS + U2_EXP_BITS;\nconst int U2_BIAS         = int(MASK( U2_EXP_BITS - 1 ));  // 1023\nconst int U2_MANT_BITS    = 64 - U2_SIGNEXP_BITS;\nconst int U2_EXP_POS      = 32 - U2_SIGNEXP_BITS; // position of exponent in the hi 32 bit word\n\nconst uint U2_SIGN_MASK = 1u << 31; // 0x80000000\nconst uint U2_EXP_MASK  = MASK(U2_EXP_BITS) << U2_EXP_POS; // 0x7ff00000\n\nuvec2 u2_mul(uvec2 a, uvec2 b) {\n  uvec2 c = uvec2(0,0); // c = a * b\n\n  int aexp = int((a.x & U2_EXP_MASK) >> 20);\n  int bexp = int((b.x & U2_EXP_MASK) >> 20);\n  if (aexp == 0 || bexp == 0) return c; // TODO: handle denormals?\n  aexp -= 1023;\n  bexp -= 1023;\n  int cexp = aexp + bexp; \n  // if (cexp + U2_BIAS <= 0 || cexp + U2_BIAS >= 256) return c; // overflow check isn't helpful for Mandelbrot\n\n  uint asign = a.x & U2_SIGN_MASK;\n  uint bsign = b.x & U2_SIGN_MASK;\n  uint csign = asign ^ bsign;\n\n  // extract mantissa 13 bits at a time\n  // LSB to MSB order, so amant[0] is lo bits\n  uint amant[4];\n  amant[0] = ((a.y      ) & mask13);\n  amant[1] = ((a.y >> 13) & mask13);\n  amant[2] = ((a.y >> 26) & mask13) | ((a.x << 6) & mask13);\n  amant[3] = ((a.x >>  7) & mask13) | 0x00002000u;\n  \n  uint bmant[4];\n  bmant[0] = ((b.y      ) & mask13);\n  bmant[1] = ((b.y >> 13) & mask13);\n  bmant[2] = ((b.y >> 26) & mask13) | ((b.x << 6) & mask13);\n  bmant[3] = ((b.x >>  7) & mask13) | 0x00002000u;\n  \n  // multiply\n  uint cmant[9];\n  for (int i = 0; i < 9; i++) cmant[i] = 0u;\n\n  // starting from here, avg rel err =~ 8e-17\n  #if 0\n  cmant[0+0] += amant[0] * bmant[0];\n\n  // starting from here, avg rel err =~ 8e-17\n  cmant[0+1] += amant[0] * bmant[1];\n  cmant[1+0] += amant[1] * bmant[0];\n\n  // starting from here, avg rel err =~ 8e-17\n  cmant[0+2] += amant[0] * bmant[2];\n  cmant[1+1] += amant[1] * bmant[1];\n  cmant[2+0] += amant[2] * bmant[0];\n  #endif\n\n  // starting from here, avg rel err =~ 1.7e-16\n  cmant[1+2] += amant[1] * bmant[2];\n  cmant[2+1] += amant[2] * bmant[1];\n  // starting from here, avg rel err =~ 4.9e-13\n  cmant[0+3] += amant[0] * bmant[3];\n  cmant[3+0] += amant[3] * bmant[0];\n\n  // starting from here, avg rel err =~ 1.8e-12\n  cmant[1+3] += amant[1] * bmant[3];\n  cmant[2+2] += amant[2] * bmant[2];\n  cmant[3+1] += amant[3] * bmant[1];\n\n  // starting from here, avg rel err =~ 1.3e-08\n  cmant[2+3] += amant[2] * bmant[3];\n  cmant[3+2] += amant[3] * bmant[2];\n\n  // starting from here, avg rel err =~ 9.0e-05\n  cmant[3+3] += amant[3] * bmant[3];\n\n\n  // carry\n  for (int i = 3; i < 9; i++) {\n    cmant[i] += (cmant[i-1] & 0xffffe000u) >> 13;\n    cmant[i-1] &= 0x00001fffu;\n  }\n\n  // find high bit set\n  int hibit = ((cmant[8] & 2u) != 0u) ? 1 : 0;\n\n  cexp += hibit;\n\n  if (hibit == 1) c.x |= (cmant[8] & 1u) << 19;\n  c.x |= cmant[7] << (7-hibit);\n  c.x |= cmant[6] >> (6+hibit);\n\n  c.y |= cmant[6] << (26-hibit);\n  c.y |= cmant[5] << (13-hibit);\n  c.y |= cmant[4] >> (0+hibit);\n\n  c.x |= csign;\n  c.x |= (uint(cexp + 1023) << 20u) & U2_EXP_MASK;\n\n  return c;\n}\n\nuvec2 u2_add(uvec2 a, uvec2 b) \n{\n  int aexp = int((a.x & U2_EXP_MASK) >> 20);\n  int bexp = int((b.x & U2_EXP_MASK) >> 20);\n  if (aexp == 0 && bexp == 0) return uvec2(0); // TODO: handle denormals\n  if (aexp == 0) return b;\n  if (bexp == 0) return a;\n\n  // sort so that a is the larger exponent\n  if (bexp > aexp) {\n    uvec2 utmp = a;\n    a = b;\n    b = utmp;\n\n    int itmp = aexp;\n    aexp = bexp;\n    bexp = itmp;\n  }\n\n  // remove bias, for a signed exponent value\n  aexp -= 1023;\n  bexp -= 1023;\n\n  int aexpDelta = aexp - bexp;\n  if (aexpDelta > 52) return a;\n\n  uint asign = a.x & U2_SIGN_MASK;\n  uint bsign = b.x & U2_SIGN_MASK;\n\n  // extract mantissa 26 bits at a time\n  // LSB to MSB order, so amant[0] is lo bits\n  uint amant_lo, amant_hi, bmant_lo, bmant_hi;\n  amant_hi = 0x04000000u | ((a.x << 6) & 0x03ffffc0u) | ((a.y >> 26) & 0x0000003fu); // include explicit leading '1', for 27 bits total\n  amant_lo = a.y << 6; // 26 bits (TODO: guard/round/sticky?)\n\n  bmant_hi = 0x04000000u | ((b.x << 6) & 0x03ffffc0u) | ((b.y >> 26) & 0x0000003fu); // include explicit leading '1', for 27 bits total\n  bmant_lo = b.y << 6; // 26 bits (TODO: guard/round/sticky?)\n\n  // shift b into a's range\n  if (aexpDelta > 0) {\n    if (aexpDelta < 32) {\n        bmant_lo = (bmant_hi << (32 - aexpDelta)) | (bmant_lo >> aexpDelta);\n        bmant_hi >>= aexpDelta;\n    } else {\n        bmant_lo = bmant_hi >> (aexpDelta - 32);\n        bmant_hi = 0u;\n    }\n  }\n\n  if (asign != 0u) {\n    amant_hi = ~amant_hi; \n    amant_lo = (~amant_lo + (1u<<6)) & 0xffffffc0u;\n    // carry\n    if (amant_lo == 0u) amant_hi++;\n  }\n  if (bsign != 0u) { \n    bmant_hi = ~bmant_hi; \n    bmant_lo = (~bmant_lo + (1u<<6)) & 0xffffffc0u;\n    // carry\n    if (bmant_lo == 0u) bmant_hi++;\n  }\n\n  // add\n  uint cmant_lo=0u, cmant_hi=0u;\n\n  cmant_hi = amant_hi + bmant_hi;\n  cmant_lo = amant_lo + bmant_lo;\n  // carry\n  if (cmant_lo < amant_lo) cmant_hi++;\n\n  uint csign = cmant_hi & U2_SIGN_MASK;\n\n  if (csign != 0u) {\n    cmant_hi = ~cmant_hi;\n    cmant_lo = (~cmant_lo + (1u<<6)) & 0xffffffc0u;\n    // carry\n    if (cmant_lo == 0u) cmant_hi++;\n  }\n\n  // find high bit set\n  int hibitPos = int(log2( (cmant_hi != 0u) ? float(cmant_hi) : float(cmant_lo) ));\n  if (hibitPos < 0) return a;\n\n  int cexpDelta = (cmant_hi != 0u) ? 26 - hibitPos : 26 + (32 - hibitPos);\n  int cexp = aexp - cexpDelta;\n\n  if (cexpDelta < 0) {\n    // shift right by one\n    cmant_lo = ((cmant_hi & 1u) << 31) | (cmant_lo >> 1);\n    cmant_hi >>= 1;\n  } else if (cexpDelta > 0) {\n    // shift left by cexpDelta\n    if (cexpDelta < 26) {\n        cmant_hi = (cmant_hi << cexpDelta) | (cmant_lo >> (32 - cexpDelta));\n        cmant_lo <<= cexpDelta;\n    }\n    else {\n        cmant_hi = (cmant_lo >> 6) << (cexpDelta - 26);\n        cmant_lo = 0u;\n    }\n  }\n\n  uvec2 c = uvec2(0,0); // result\n  \n  c.x |= csign;\n  c.x |= uint((cexp + 1023) << 20) & U2_EXP_MASK;\n\n  c.x |= (cmant_hi >> 6) & 0x000fffffu;\n  c.y |= ((cmant_hi << (32-6)) & 0xfc000000u) | ((cmant_lo >> 6) & 0x03ffffffu);\n\n  return c;\n}\n\nuvec2 float_to_u2(float f) {\n    uint fbits = floatBitsToUint(f);\n    \n    uint sign =      fbits & U2_SIGN_MASK;\n    int   exp = int((fbits & 0x7f800000u) >> 23);\n    if (exp == 0) return uvec2(0,0); // denormal\n    exp -= 127;\n    uint mant =      fbits & 0x007fffffu;\n\n    uvec2 u2;\n    u2.x = sign | (uint(exp + 1023) << 20) | (mant >> 3);\n    u2.y = fbits << (32 - 3);\n    return u2;\n}\n\nfloat u2_to_float(uvec2 u2) {\n    \n    uint sign =      u2.x & U2_SIGN_MASK;\n    int   exp = int((u2.x & U2_EXP_MASK) >> 20) - 1023;\n    uint mant = ((u2.x & 0x000fffffu) << 3) | ((u2.y & 0xe0000000u) >> 29);\n\n    uint fbits = sign | (uint(exp + 127) << 23) | mant;\n    return uintBitsToFloat(fbits);\n}\n\nuvec2 u2_neg(uvec2 u2) {\n    return uvec2(u2.x ^ U2_SIGN_MASK, u2.y);\n}\n\nuvec2 u2(float f) { return float_to_u2(f); }\n\n/*\n*/\n\n/*\n\nEncode a U2 into our texture buffer\n\nUse the top 16 bits of the mantissa in each channel to capture our data\n\n4 channels * 16 bits = a 64 bit number per pixel\n\nMy idea here is an attempt to accurately capture all bits, \neven on devices with low precision textures. \n\nIt does seem to work on my desktop machine to store uints directly as full floats,\nbut that seems risky as I could occasionally end up with NaNs or denormals and they\nmight not decode accurately.\n\nNot sure if this encoding is misguided, because I don't know how webGL \nprecision really works. How many bits do the ShaderToy Buffers guarantee, \nand which bits are they?\n\n*/\n\nvec4 u2_to_v4(uvec2 u2) {\n    uint real_hi = (u2.x >> 16) & 0x0000ffffu;\n    uint real_lo = (u2.x >>  0) & 0x0000ffffu;\n    uint imag_hi = (u2.y >> 16) & 0x0000ffffu;\n    uint imag_lo = (u2.y >>  0) & 0x0000ffffu;\n\n    vec4 v4 = vec4(0);\n    v4.x = uintBitsToFloat((real_hi << (23-16)) | 0x3f000000u);\n    v4.y = uintBitsToFloat((real_lo << (23-16)) | 0x3f000000u);\n    v4.z = uintBitsToFloat((imag_hi << (23-16)) | 0x3f000000u);\n    v4.w = uintBitsToFloat((imag_lo << (23-16)) | 0x3f000000u);\n    return v4;\n}\n\n// Decode a v4 (pixel from the buffer) into a U2\nuvec2 v4_to_u2(vec4 v4) {\n    uint real_hi = (floatBitsToUint(v4.x) >> (23-16)) & 0x0000ffffu;\n    uint real_lo = (floatBitsToUint(v4.y) >> (23-16)) & 0x0000ffffu;\n    uint imag_hi = (floatBitsToUint(v4.z) >> (23-16)) & 0x0000ffffu;\n    uint imag_lo = (floatBitsToUint(v4.w) >> (23-16)) & 0x0000ffffu;\n    \n    uvec2 u2;\n    u2.x = (real_hi << 16) | real_lo;\n    u2.y = (imag_hi << 16) | imag_lo;\n    return u2;\n}\n\n// This is purely to allow input of the float-encoded bits\n// Same as v4_to_u2 but without the float bits conversion\n// See the handling of '1' and '2' keys in the UI() function\nuvec2 u4_to_u2(uvec4 u4) {\n    uint real_hi = ((u4.x) >> (23-16)) & 0x0000ffffu;\n    uint real_lo = ((u4.y) >> (23-16)) & 0x0000ffffu;\n    uint imag_hi = ((u4.z) >> (23-16)) & 0x0000ffffu;\n    uint imag_lo = ((u4.w) >> (23-16)) & 0x0000ffffu;\n    \n    uvec2 u2;\n    u2.x = (real_hi << 16) | real_lo;\n    u2.y = (imag_hi << 16) | imag_lo;\n    return u2;\n}\n\n\nfloat v4_to_float(vec4 v4) { return v4.x; }\nvec4  float_to_v4(float f) { return vec4(f,0,0,0); }\n\n\n// mouse/keyboard how-to:\n// https://shadertoyunofficial.wordpress.com/2019/01/26/classical-corner-cases/\n// https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n//\n// keymap: https://www.shadertoy.com/view/ldSBzd\n// text drawing: https://www.shadertoy.com/view/llySRh\n// kbd debug: https://www.shadertoy.com/view/4dGyDm\n\n/*\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_4 = 52;\nconst int KEY_5 = 53;\n*/\n\nconst int LT_KEY = 37;\nconst int UP_KEY = 38;\nconst int RT_KEY = 39;\nconst int DN_KEY = 40;\nconst int D_KEY = 68;\nconst int I_KEY = 73;\nconst int R_KEY = 82;\nconst int S_KEY = 83;\nconst int V_KEY = 86;\nconst int X_KEY = 88;\nconst int Z_KEY = 90;\nconst int SHIFT_KEY = 16;\n\n// Get ring start number, from current ring width\n// int K(int w) { return w > 1 ? 4+(w-2)*4 : 1; }\n\n// Get width of ring index\nint W(int i) { return i*2+1; }\n\n// Ulam indexing is from https://www.shadertoy.com/view/tlcyRj\nint ulamId(ivec2 block2d) {\n    int x = int(block2d.x);\n    int y = int(block2d.y);\n    int i = max(abs(x), abs(y)); // Ring index\n    int w0 = W(i-1); // Ring below width\n    int w1 = W(i); // Ring current width\n    int h = w1/2;\n    int A = w0*w0;\n    int v = sign(y) == -1 && y == -h && x > -h ? 3 : (sign(x) == 1 && x == h ? 0 : (sign(y) == 1 && y == h ? 1 : 2));  \n    int j;\n    switch (v) {\n        case 0: j =  y + (h+2); break;\n        case 1: j = -x + (h+1); break;\n        case 2: j = -y + (h  ); break;\n        case 3: j =  x + (h-1); break;\n    }\n    // Original is off by 2!\n    int n = A + v*w1 + j * int(i != 0) - 2;\n    return n;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n\nuvec2[2] CMUL(uvec2[2] a, uvec2[2] b) {\n    // (ax + ayi)(bx + byi) = (ax bx − ay by) + (ax by + ay bx)i\n    //uvec2 real = u2_add(u2_mul(a.xy, b.xy), u2_neg(u2_mul(a.zw, b.zw)));\n    //uvec2 imag = u2_add(u2_mul(a.xy, b.zw), u2_mul(a.zw, b.xy));\n\n    uvec2[4] mulout;\n\n    int nr = min(0,iFrame);\n\n    for (int i = nr; i < 2; i++) {\n    for (int j = nr; j < 2; j++) {\n        mulout[i*2+j] = u2_mul(a[i], b[j]);\n    }\n    }\n\n    mulout[3] = u2_neg(mulout[3]);\n\n    uvec2[2] ri;\n    for (int i = nr; i < 2; i++) ri[i] = u2_add(mulout[i], mulout[3-i]);\n\n    return ri;\n}\n\n\n\nvec4 render( vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n    int nr = min(0, iFrame);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uvec4 CfragCoord = uvec4(float_to_u2(fragCoord.x), float_to_u2(fragCoord.y));\n    uvec4 CrcpiResolution = uvec4(float_to_u2(1./iResolution.x), float_to_u2(1./iResolution.y));    \n    uvec4 Cuv;\n    Cuv.xy = u2_mul( CfragCoord.xy, CrcpiResolution.xy);\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    vec4 ui[5];\n    for (int pixel = 0; pixel < 5; pixel++) {\n        ui[pixel] = texelFetch(iChannel0, ivec2(pixel, 0), 0);\n    }\n    \n    vec4 centerx_v4 = ui[0];\n    vec4 centery_v4 = ui[1];\n    vec4 vsize_v4   = ui[2];\n    vec4 opts       = ui[3];\n    vec4 res        = ui[4];\n\n    int iters   = abs(int(opts.x));\n    int samples = max(1, int(opts.y));\n    int hud     = (opts.x > 0.0) ? 1 : -1; // int(sign(opts.x)); // int(sign(x)) is broken??\n    \n    vec2 blockId   = res.zw;\n\n    // let's render in blocks starting from the center and spiraling out\n    // This is useful for high samples per pixel, high iterations, and full-screen\n    #ifdef INCREMENTAL\n    //float blocksize = 16.; // TODO: adaptive block size based on worst-case render time?\n    ivec2 bid2 = ivec2(floor(((fragCoord - (iResolution.xy/2.) + (float(BLOCKSIZE)/2.)) / float(BLOCKSIZE))));\n    int uid = ulamId(bid2);\n    if (uid < int(blockId.x) || uid >= int(blockId.y)) {\n        color = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        \n        // show the next block in the queue (indicate activity & progress, helpful when changing samples and in some regions)\n        #ifdef SHOW_NEXT_BLOCK\n        if (uid == int(blockId.y)) { color = mix(color, vec4(vec3(.5),1), 0.5); return color; }\n        #endif // SHOW_NEXT_BLOCK\n        return color;\n    }\n    #endif // INCREMENTAL\n\n    uvec2 center_x = v4_to_u2(centerx_v4);\n    uvec2 center_y = v4_to_u2(centery_v4);\n    uvec2 vsize    = v4_to_u2(vsize_v4);\n\n    bool isRKeyPressed = texelFetch(iChannel2, ivec2(R_KEY, 1), 0).x > 0.;\n    if (iFrame == 0 || isRKeyPressed) \n    {\n        center_x = float_to_u2(-0.5);\n        center_y = float_to_u2(0.);\n        vsize = float_to_u2(1.);\n    }\n\n    uvec2[2] center = uvec2[2]( center_x, center_y );\n\n    uvec2[2] size = uvec2[2](vsize, vsize);\n    size[0] = u2_mul( size[0], float_to_u2(1./aspect) );\n    \n    uvec2[2] c;\n    vec2 wuv = 2. * uv - 1.;\n    for (int i=nr;i<2;i++) {\n        uvec2 suv = u2_mul( size[i], float_to_u2(wuv[i]) );\n        c[i] = u2_add( center[i], suv );\n    }\n    \n    vec4 textColor = vec4(0);\n    \n    vec2 pxSz = 1.f / iResolution.xy;\n    vec2 sampSz = vec2(1.f / float(samples));\n    uvec2 sz[2] = uvec2[2]( size[0], size[1] );\n    \n    //vec4 color = vec4(0);\n    for (int AAX = nr; AAX < samples; AAX++) {\n    for (int AAY = nr; AAY < samples; AAY++) {\n    \n    vec2 puv = (fragCoord.xy + vec2(AAX, AAY)*sampSz) * pxSz;\n    vec2 wuv = 2. * puv - 1.;\n    for(int i=nr;i<2;i++) {\n        uvec2 suv = u2_mul( sz[i], float_to_u2(wuv[i]) );\n        c[i] = u2_add( center[i], suv );\n    }\n\n    uvec2[2] z = c;\n\n    int i;\n    float l;\n    \n    #ifdef SHOW_COBWEBS   \n    vec2 maxRatio = vec2(0.);\n    #endif\n    \n    for (i = nr; i < iters; i++) {\n        uvec2[2] ztmp = CMUL(z, z);\n        for(int j=nr;j<2;j++) z[j] = u2_add(ztmp[j], c[j]);\n        for(int j=nr;j<2;j++) ztmp[j] = u2_mul(z[j], z[j]);\n        uvec2 z_l_sqr = u2_add(ztmp[0], ztmp[1]);\n        if (u2_to_float(z_l_sqr) > 4.) break;\n        \n        #ifdef SHOW_COBWEBS\n        float ratio = abs(u2_to_float(z[1]) / u2_to_float(z[0]));\n        maxRatio = max(maxRatio, vec2( 1./ratio, ratio ));\n        #endif\n    }       \n\n    // Nice colormap from: https://www.shadertoy.com/view/XdsXWN\n    const vec3 colourPhase = vec3(5,7,11)/80.0;\n    vec3 colourPhaseStart = vec3(1);\n    \n    float mu = float(i);\n    \n    #ifdef SHOW_COBWEBS   \n    if (i == iters) {\n        i = 0; \n        mu = 2. * log2(max(1e-39, max(maxRatio.x, maxRatio.y)));\n    }\n    #endif\n    \n    if (i < iters) color.rgb += pow(sin(colourPhase.xyz * mu + colourPhaseStart)*.5+.5,vec3(1.5));\n    \n    }\n    }\n    \n    color /= float(samples * samples);\n    \n    color = vec4( pow(color.rgb, vec3(1./2.2)), 1. );\n    if (textColor.g > 0.) color.rgb = textColor.rgb;\n    //color.rgb = mix(color.rgb, textColor.rgb, pow(textColor.a, 1.));\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = render(fragCoord);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec4 renderHUD( vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n    int nr = min(0, iFrame);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uvec4 CfragCoord = uvec4(float_to_u2(fragCoord.x), float_to_u2(fragCoord.y));\n    uvec4 CrcpiResolution = uvec4(float_to_u2(1./iResolution.x), float_to_u2(1./iResolution.y));    \n    uvec4 Cuv;\n    Cuv.xy = u2_mul( CfragCoord.xy, CrcpiResolution.xy);\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    vec4 ui[5];\n    for (int pixel = 0; pixel < 5; pixel++) {\n        ui[pixel] = texelFetch(iChannel0, ivec2(pixel, 0), 0);\n    }\n    \n    vec4 centerx_v4 = ui[0];\n    vec4 centery_v4 = ui[1];\n    vec4 vsize_v4   = ui[2];\n    vec4 opts       = ui[3];\n    vec4 res        = ui[4];\n\n    int iters   = abs(int(opts.x));\n    int samples = max(1, int(opts.y));\n    int hud     = (opts.x > 0.0) ? 1 : -1; // int(sign(opts.x)); // int(sign(x)) is broken??\n    \n    vec2 blockId   = res.zw;\n\n    uvec2 center_x = v4_to_u2(centerx_v4);\n    uvec2 center_y = v4_to_u2(centery_v4);\n    uvec2 vsize    = v4_to_u2(vsize_v4);\n\n    bool isRKeyPressed = texelFetch(iChannel1, ivec2(R_KEY, 1), 0).x > 0.;\n    if (iFrame == 0 || isRKeyPressed) \n    {\n        center_x = float_to_u2(-0.5);\n        center_y = float_to_u2(0.);\n        vsize = float_to_u2(1.);\n    }\n\n    uvec2[2] center = uvec2[2]( center_x, center_y );\n\n    uvec2[2] size = uvec2[2](vsize, vsize);\n    size[0] = u2_mul( size[0], float_to_u2(1./aspect) );\n    \n    uvec2[2] c;\n    vec2 wuv = 2. * uv - 1.;\n    for (int i=nr;i<2;i++) {\n        uvec2 suv = u2_mul( size[i], float_to_u2(wuv[i]) );\n        c[i] = u2_add( center[i], suv );\n    }\n    \n    vec4 textColor = vec4(0);\n    if (hud > 0) {\n#if 1\n    // debug display of numbers\n    vec2 textSz = vec2(12,20);\n    vec2 textUV = fragCoord.xy / textSz;\n    vec2 charUV = fract(textUV) * vec2(0.5, 1) + vec2(0.25, 0);\n    vec2 charID = floor(textUV); // (col, row)\n    \n    int row = int(charID.y);\n    int col = int(charID.x);\n    // Show the stored state in our \"ui\" buffer: center x/y, size, and options\n    // 5 rows, 4 numbers, 8 characters each (hex). The 9s are to put a space betwee each number\n    if (row < 5 && col < 9*4) {\n        int whichNum = col / 9;\n        uint num = floatBitsToUint(ui[4-row][whichNum]);\n        int whichDigit = 8 - (col % 9);\n        int c = int((num >> (4*whichDigit)) & 0xfu);\n        c += (c > 9) ? (65 - 10) : 48;\n        vec2 texUV = charUV / 16.;\n        if (whichDigit < 8) textColor += texture(iChannel2, texUV + fract( vec2(c, 15-c/16) / 16. ) ).xxxx;\n    }\n#endif\n    } // hud\n        \n    //color = vec4( pow(color, vec4(1./2.2)) );\n    if (textColor.g > 0.) color = textColor;\n    \n    if (hud == 1 && fragCoord.x < 450. && fragCoord.y < 110.) color.a = max(0.75, color.a);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = renderHUD(fragCoord);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}