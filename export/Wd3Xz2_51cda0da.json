{"ver":"0.1","info":{"id":"Wd3Xz2","date":"1573955193","viewed":162,"name":"3d Newton Solver (test)","username":"copperTones","description":"An attempt to draw any 3d graph using a modified version of Newton's Method. Didn't work out well, and probably isn't fixable.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","test","graph","solver"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define pi 3.1416\n#define euler 2.7183\n#define phi (1+sqrt(5.))/2.\n\nvec3 CAM_pos = vec3(0, 0, -6);\nmat3 CAM_mat = mat3(1);\n#define CAM_zoom 1.\n\n#define GRAPH_eps 1e-5\n#define GRAPH_itr 5\n#define GRAPH_maxt 50.\n#define GRAPH_tct 5\n#define GRAPH_tjmp 1.\n\n#define LIGHT_dir normalize(vec3(1))\n\nstruct Ray {\n\tvec3 pos;\n\tvec3 vel;\n};\nRay Perspective(vec2 uv) {//mostly ripped from my own unity code\n\tRay result;\n\tresult.pos = CAM_pos;\n\tresult.vel = normalize(vec3(uv, CAM_zoom));\n\tresult.vel = CAM_mat * result.vel;\n\treturn result;\n}\n\nfloat slope(Ray ray, float t) {\n\treturn (fRay(ray, t+GRAPH_eps) - fRay(ray, t))/GRAPH_eps;\n}\n#define swzl vec2(0, GRAPH_eps)\nvec3 normal(vec3 pos) {//modified iq normal\n\treturn normalize(vec3(\n        f(pos+swzl.yxx) - f(pos-swzl.yxx),\n        f(pos+swzl.xyx) - f(pos-swzl.xyx),\n        f(pos+swzl.xxy) - f(pos-swzl.xxy)\n    ));\n}\nfloat newtonStep(Ray ray, float t) {//newton's method implementation\n\treturn t - fRay(ray, t)/slope(ray, t);\n}\nfloat newton(Ray ray) {\n    float minT = GRAPH_maxt;\n    for (int tm = 0; tm < GRAPH_tct; tm++) {//start point\n        float t = GRAPH_tjmp*float(tm);//incriment by jmp\n        for (int i = 0; i < GRAPH_itr; i++) {\n            t = newtonStep(ray, t);\n        }\n        if (t >= 0. && t < minT)\n            minT = t;//smalest non-neg\n    }\n    return minT;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragCoord -= iResolution.xy/2.;\n    vec2 uv = fragCoord/R.x;//clamp/scale by x\n    uv *= 2.;\n    vec2 mouse = iMouse.xy - R/vec2(.5, 1.);\n    mouse *= 2.*pi/R.x;\n    if (iMouse.xy == vec2(0))//default camera\n        mouse = vec2(1.2, -.8);\n    \n    CAM_pos = vec3(iTime, 0, -6);\n    CAM_mat = rotZ(mouse.x)*rotX(mouse.y);\n    \n    Ray ray = Perspective(uv);\n    float t = newton(ray);\n    float s = min(2.5*abs(fRay(ray, t)), 1.);\n    vec3 pos = rayPt(ray, t);\n    vec3 norm = normal(pos);\n    float n = max(-dot(norm, LIGHT_dir), 0.);\n    \n    vec3 col = mix(vec3(.3, .5, 0), vec3(.4, 1, 0), n);\n    col = mix(col, vec3(.8, .9, 1), t/GRAPH_maxt);\n    col = mix(col, vec3(0, .1, .5), s);\n    \n    fragColor = vec4(col, 1);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-------------------------//\nfloat z(vec2 axes) {\n\t//return 5.*cos(length(axes))*pow(.5, length(axes));\n    return 1.*(cos(axes.x)+cos(axes.y));\n    //return 0.;\n}\nfloat f(vec3 pos) {\n    return z(pos.xy) - pos.z;\n}\n//-------------------------//\n#define rayPt(ray, t) (ray.pos + ray.vel*(t))\n#define fRay(ray, t) f(rayPt(ray, t))\n\nmat3 rotX(float a) {\n\treturn mat3(1, 0, 0,\n               0, cos(a), sin(a),\n               0, -sin(a), cos(a));\n}\nmat3 rotY(float a) {\n    mat3 x = rotX(a);\n\treturn mat3(x[2].zxy, x[0].zxy, x[1].zxy);\n}\nmat3 rotZ(float a) {\n    mat3 x = rotX(a);\n\treturn mat3(x[1].yzx, x[2].yzx, x[0].yzx);\n}","name":"Common","description":"","type":"common"}]}