{"ver":"0.1","info":{"id":"sd3yzB","date":"1653721144","viewed":252,"name":"Maxwell 2D ","username":"Amirk","description":"Maxwell's equations implemented in 2D. Buffer A updates H field using curls of E field, after which Buffer B updates E field using curls of H field.\nVisualisation with Electric field. ","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["refraction","maxwell","electrodynamics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col=vec3(0);\n\n    float EZ = texture(iChannel0,uv).r*40.;\n    //float HX= texture(iChannel0,uv).g*40.;\n    //float HY= texture(iChannel0,uv).b*40.;\n    \n    //float energy=0.5*(er*EZ*EZ+(HX*HX+HY*HY)/ur); //energy in the field\n    \n    if(length(fragCoord.xy-iResolution.xy*0.5)<iResolution.y/4.) {\n        er=2.;\n        ur=2.;\n    }\n\n     col= color(1.51*EZ)/(er*0.5);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this Buffer updates magnetic field H with curls of E with buffer B\n\nivec2 per(int px, int py){\n  ivec2 r = ivec2(textureSize(iChannel0, 0));\n  ivec2 p=ivec2(px,py);\n  \n  return p = (p+r) % r; \n}\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){\n    if(per(i,j).y==0) return 0.;\n\n\n    return texelFetch(iChannel0, per(i,j),0).r;\n}\nfloat Hx(int i, int j){\n    if(per(i,j).y==0) return 0.;\n\n\n    return texelFetch(iChannel0, per(i,j),0).g;\n}\nfloat Hy(int i, int j){\n    if(per(i,j).y==0) return 0.;\n\n\n    return texelFetch(iChannel0, per(i,j),0).b;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    float EZ,HX,HY;\n    \n    //define obstacle:\n    if(length(fragCoord.xy-iResolution.xy*0.5)<iResolution.y/4.) {\n        er=2.;\n        ur=2.;\n    }\n\n    \n    EZ=Ez(i,j);\n  \n    //Maxwell's equation:\n    //update H:\n    HX=Hx(i,j) -mH*( Ez(i,j+1)-Ez(i,j) );\n    HY=Hy(i,j)-mH*( -(Ez(i+1,j)-Ez(i,j)) );\n    \n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,HX,HY);\n    \n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":" //speed of light c:\n #define c  1. \n //grid cell size:\n #define dz 0.1\n //relative permittivity:\n float er = 1.0;\n //relative permeability:\n float ur = 1.0;\n //timestep is chosen so that one grid cell is traversed in excatly two time steps. \n //First time step is to update H, the second to update E.\n #define dt dz/(2.0*c)\n //some precalculations:\n #define mE c*dt/(er*dz)\n #define mH c*dt/(ur*dz)\n //maxFreq controls the highest frequency contained in the source pulse.\n //it should be of the of the same order as the speed of light c.\n #define maxFreq  1. \n \n float t;\n\n\n//a gaussian pulse at x, y:\nfloat source(float time, ivec2 xy, int i, int j){ \n    if(i==xy.x&&j==xy.y)\n        return exp(-(time-dt*70.0)*(time-dt*70.0)*4.*maxFreq*maxFreq);\n    \n    else return 0.0;\n}\n\nvec3 color(float t)\n{\n vec3 col;\n col.r = 0.5-0.5*cos(2.*3.1416*(1.5*t+1.9));\n col.g = 0.5-0.5*cos(2.*3.1416*(.9*t+.15));\n col.b = 0.5-0.5*cos(2.*3.1416*(1.7*t+.2));\n return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this Buffer updates electric field E with curls of H using buffer A\n\n\n//periodic boundary:\n ivec2 per(int px, int py){\n  ivec2 r = ivec2(textureSize(iChannel0, 0));\n  ivec2 p=ivec2(px,py);\n  \n  return p = (p+r) % r; \n}\n\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){\n    \n    if(per(i,j).y==0) return 0.;\n    else\n        return texelFetch(iChannel0, per(i,j),0).r;\n}\nfloat Hx(int i, int j){\n    if(per(i,j).y==0) return 0.;\n\n\n    return texelFetch(iChannel0, per(i,j),0).g;\n}\nfloat Hy(int i, int j){\n    if(per(i,j).y==0) return 0.;\n\n\n    return texelFetch(iChannel0, per(i,j),0).b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    t=dt*float(iFrame);\n    \n    float EZ,HX,HY;\n    \n    //define obstacle:\n    if(length(fragCoord.xy-iResolution.xy*0.5)<iResolution.y/4.) {\n        er=2.;\n        ur=2.;\n    }\n    \n    //Maxwell's equation:\n    //update E:\n    EZ=Ez(i, j)+ mE* ((Hy(i,j)-Hy(i-1,j))-(Hx(i,j)-Hx(i,j-1)));\n    \n    //add sources:\n    EZ+=source(t, ivec2(iResolution.xy/4.), i,j);\n    \n    if(iMouse.z>0.){\n        EZ+=source(dt*50., ivec2(iMouse.xy), i, j);\n    }\n    \n    HX=Hx(i,j);\n    HY=Hy(i,j);\n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,HX,HY);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}