{"ver":"0.1","info":{"id":"dlyyzG","date":"1700339091","viewed":36,"name":"Yoko_psico","username":"faportero","description":"my first shader using sdf ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hearmoonsdfpsicocolors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//pagina para crear diferentes gradientes basados en el coseno\n//http://dev.thi.ng/gradients/\n//https://iquilezles.org/articles/distfunctions2d/\n\nvec3 palette2( float t ) {\n    vec3 a = vec3(0.270, 0.264, 0.764);\n    vec3 b = vec3(0.724 ,0.903, 0.546);\n    vec3 c = vec3(1.288 ,1.501, 0.197);\n    vec3 d = vec3(4.263 ,3.439, 5.631);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n/*f\nvec3 palette1( float t ) {\n    vec3 a = vec3(0.611, 0.621, 0.773);\n    vec3 b = vec3(0.868, 0.708, 0.683);\n    vec3 c = vec3(1.364, 1.038, 0.990);\n    vec3 d = vec3(1.599 ,5.004, 2.175);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n*/\nvec3 palette1( float t ) {\n    vec3 a = vec3(0.897, 0.474, 0.219);\n    vec3 b = vec3(0.933, 0.831, 0.838);\n    vec3 c = vec3(1.423, 1.041, 1.480);\n    vec3 d = vec3(2.159, 1.324, 3.029);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// signed distance to an equilateral triangle\nfloat sdEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdCircleWave( in vec2 p, in float tb, in float ra )\n{\n    tb = 3.1415927*5.0/6.0*max(tb,0.0001);\n    vec2 co = ra*vec2(sin(tb),cos(tb));\n    p.x = abs(mod(p.x,co.x*4.0)-co.x*2.0);\n    vec2  p1 = p;\n    vec2  p2 = vec2(abs(p.x-2.0*co.x),-p.y+2.0*co.y);\n    float d1 = ((co.y*p1.x>co.x*p1.y) ? length(p1-co) : abs(length(p1)-ra));\n    float d2 = ((co.y*p2.x>co.x*p2.y) ? length(p2-co) : abs(length(p2)-ra));\n    return min(d1, d2); \n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // symmetry (optional)\n    p.x = abs(p.x);\n    \n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec2 uv0 = uv;\n    vec3 finalColor  = vec3(0.0);\n    \n   for (float i = 0.0; i<1.8; i++){//con el for agregamos iteraciones al escalamiento y a la variacion de color\n\n       //A continuacion volvemos a remapear las coordenadas uv para que la repeticion\n        //que ocurre gracias al fract (toma solo los vaolres decimales de los enteros es decir se repuite de 0 a 1)\n        // no se genere con el rango de 0 a 1 y con centro en la esquina    \n        \n        \n        uv = fract(0.98*uv) -vec2(0.5, 0.0);\n        uv *= 2.;\n        uv += vec2(0.0,-0.5);\n        //uv = abs(uv);\n        \n        uv0 = fract(1.8*uv0);\n        uv0 *= 2.5;\n        uv0 += vec2(-1.2,-0.9);\n\n         float s = sdMoon( uv0, .65, .8, 0.85);\n         s = smoothstep(-1.,1.,s);\n                  \n\n         float d = sdHeart( uv);\n    \n        // tambien se divide por el mismo factor porque al multiplicar el color la intensidad aumenta asi que al dividirlo por el mismo factor no se altera la intensidad\n        d = sin(d*8.0 + 3.*iTime)/8.0;// multiplicamos por iTime (tiempo en segundos) para que se despplace en funcion del tiempo\n        d = abs(d);\n        d = pow(0.005/d,1.2);// la funcion pow aumenta el contraste\n        \n        //d = step(0.1,d);//step para endurar los bordes, definiendo un umbral para el valor d\n        d = smoothstep(0.0,0.2,d);// creamos una transicion suave en los vordes definiendo un umbral maximo y un minimo\n        \n        s = sin(s*5. - iTime)/5.;// multiplicamos por iTime (tiempo en segundos) para que se despplace en funcion del tiempo\n        s = abs(s);\n        s = pow(0.1/s,1.2);// la funcion pow aumenta el contraste\n        \n        vec3 col1 = 2.5*palette1(s + i * .5 + iTime * .8);\n        vec3 col2 = 0.3*palette2(d + i * 1.5 + iTime * .4);\n        \n        \n        finalColor += col1*col2;\n    }    \n    fragColor = vec4(finalColor,1.0);\n    \n\n}\n","name":"Image","description":"","type":"image"}]}