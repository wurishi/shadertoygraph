{"ver":"0.1","info":{"id":"ttSSWK","date":"1567107317","viewed":1755,"name":"flame_experiment","username":"skaplun","description":"Inspired by @XT95's wonderful 'Flame' shader.\nSDF primitives and noise are by @iq.\nInteractive\nUncomment #define SHOW_LAYERS to show composition process","likes":24,"published":1,"flags":0,"usePreview":1,"tags":["noise","raymarch","flame","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define EPSILON MIN_FLOAT\n#define MAX_MARCHING_STEPS 64\n#define YELLOW vec3(1.,.6,.1)\n#define BLUE vec3(0.1,.3,1.)\n\nfloat scene(vec3 p){\n    float yFactor = p.y;\n    float time = iTime * 2.;\n    vec2 cntr = vec2(fbm1x(yFactor, time), fbm1x(yFactor + 78.233, time))\n          \t  * smoothstep(-1., 2., yFactor);\n    if(layer() > 3)\n    \tp.xz -= cntr;\n    \n    float rad = 1.;\n    if(layer() > 2)\n    \trad = smoothstep(2.5, -2., p.y);\n    float ang = atan(p.x, p.z) + fbm1x(p.y, iTime);\n    float n = noised(vec2(ang * 8./6.2831, p.y - iTime * 3.)) * .75;\n    \n    if(layer() > 4)\n        rad -= n * rad;\n    \n    float cyl = sdCylinder(p, vec2(rad, 2.));\n    if(layer() < 2)\n        return cyl;\n    \n    float sphereRad = 1.;\n    if(layer() > 4)\n        sphereRad -= 1. + n * smoothstep(-1., 0., p.y + 2.);\n    float sphere = length(p + vec3(0., 2., 0.)) - sphereRad;\n    return min(cyl, sphere);\n}\n\nfloat march(vec3 eye, vec3 marchingDirection, float start, float end, out float outClr) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection);\n        if (dist < MIN_FLOAT) {\n            return depth;\n        }\n        depth += dist * .75;\n        outClr = 1. - float(i)/float(MAX_MARCHING_STEPS);\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.x - iMouse.x) * .01;\n    vec3 origin = vec3(7.5 * sin(ang), 3. + sin(ang) * 2., 7.5 * cos(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0., -.25, 0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray r = Ray(origin, dir);\n    \n    vec3 finalColor = vec3(.1);\n    \n    float baseDist;\n    if(plane_hit(origin, dir, vec3(0., -3., 0.), vec3(0., -1., 0.), baseDist)){\n    \tvec3 p = origin + dir * baseDist;\n        float f = mod(floor(p.z) + floor(p.x), 2.);\n        finalColor = f * vec3(.05);\n        \n        if(layer() > 7)\n            finalColor += BLUE * (fbm1x(atan(p.x, p.z), iTime) * .25 + .5)\n                               * smoothstep(5., 0., length(p.xz))\n                               * (fbm1x(atan(p.x, p.z) * .1, iTime * 5.) * .25 + .5);\n    }else{\n    \tbaseDist = MAX_FLOAT;\n    }\n    \n    if(layer() == 0)\n        return finalColor;\n    \n    float aa = 0.;\n    float dist = march(r.origin, r.dir, MIN_DIST, MAX_DIST, aa);\n    if (dist < MAX_DIST - MIN_FLOAT && dist < baseDist) {\n        if(layer() <= 5){\n        \tfinalColor = vec3(aa);\n        }else{\n        \tvec3 p = r.origin + dist * r.dir;\n            vec3 c = vec3(1.);\n            if(layer() > 6)\n                c = mix(YELLOW, BLUE, smoothstep(2., -2.5, p.y));\n\n            Ray trRay = Ray(r.origin + dist * r.dir, r.dir);\n            const float stepSize = .01;\n            float t = MIN_FLOAT;\n            for(float i=0.; i<200.; i++){\n                vec3 p = trRay.origin + trRay.dir * t;\n                float s = scene(p);\n                if(abs(s) > .1)\n                    break;\n                if(abs(s) < stepSize * 5.){\n                    finalColor += c * .02;\n                }\n                t += stepSize;\n            }\n        }\n    }\n    return finalColor;\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    uv = fragCoord/iResolution.xy;\n    time = iTime + 25.;\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n    if(layer() < 8)\n    \tfragColor.rgb = mix(vec3(1.), fragColor.rgb, stripe());\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\n//#define SHOW_LAYERS\n\nstruct Ray{ vec3 origin, dir;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\n// vertical\nfloat sdCylinder(vec3 p, vec2 h){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\n//by Íñigo Quílez\nvec2 hash(in vec2 x){\n    // Needs to coincide with the wrap multiple (24, in this case) in the \"world\" function.\n    x = mod(x, 8.); \n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noised(in vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return (va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd));\n}\n\nvec2 uv;\nfloat time;\n#define LAYERS_CNT 14.\nint layer(){\n#ifdef SHOW_LAYERS\n    return int(floor(mod(abs(uv.x*.25 - time - uv.y*.5), LAYERS_CNT)));\n#else\n\treturn int(LAYERS_CNT);\n#endif\n}\n\nfloat stripe(){\n    return smoothstep(.4975, .495, distance(fract(uv.x*.25 - time - uv.y*.5), .5));\n}","name":"Common","description":"","type":"common"}]}