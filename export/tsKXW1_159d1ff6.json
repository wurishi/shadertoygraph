{"ver":"0.1","info":{"id":"tsKXW1","date":"1573996395","viewed":78,"name":"Line defined by two points","username":"Hotrhodium","description":"Unnecessarily Complicated! Uses Distance(P1,P2,(x0,y0)) = |(y2 - y1)x0 - (x2 - x1)y0 + x2*y1 - y2*x1|/SQRT((y2-y1)^2 + (x2-x1)^2) to find distance to line. Point A is set to rotate and Point B is set to mouse input.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["line","points","two"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float RotDia = 100.0;\n    vec2 PointA = vec2(0.4*iResolution.x,0.6*iResolution.y);//Set point A\n    float CirDia = distance(PointA,fragCoord);\n    vec2 PointB = iMouse.xy;//Get mouse input for point B\n    vec2 TimeCir = vec2(cos(iTime),sin(iTime))*vec2(RotDia);//Make rotating circle\n    PointA += TimeCir;//Offset Point A by rotating circle\n    \n    vec3 BkCol = vec3(0.2,0.7,1.0);\t\t//Define Background\n    vec3 col = BkCol;\t\t\t\t\t//Set Background\n    vec3 CirCol = vec3(1.0,1.0,0.0);\n    vec3 RedCol = vec3(1.0,0.1,0.1);\t//Define Line Color\n    vec3 DotCol = vec3(0.0,1.0,0.0);\t//Define Dot Color\n    \n    float LineThick = 1.0;\t\t\t\t//This is the distance from line that will be filled in\n    float Blend;\n    \n    float DistA = distance(PointA,fragCoord);\t//These make the dots at the end\n    float DistB = distance(PointB,fragCoord);\n    float LineLen = distance(PointA,PointB);\t//Not needed for each pixel\n    float Cross = (PointB.x*PointA.y) - (PointB.y*PointA.x);//Not needed for each pixel\n    float DistL = abs(((PointA.x-PointB.x)*fragCoord.y) - ((PointA.y-PointB.y)*fragCoord.x)+ Cross);\n    //PointA.x-PointB.x and PointA.y-PointB.y could be done once per frame.\n    DistL = DistL/LineLen;\t\t\t//This completes this method for finding closest distance from line to pixel\n    \n    if (DistL < LineThick)\n    {\n        col = RedCol;\n    }\n    LineThick += 1.0;\n    if(DistL < LineThick)\t\t\t//Incorrect aprox. Im still working on this one\n    {\t\t\t\t\t\t\t\t//If outside of line but less than 1 pixel away\n        Blend = LineThick - DistL;\t//Get aprox amount of pixel still in line\n        col = RedCol * vec3(Blend);\t//Add that percentage of line color to pixel \n        Blend = 1.0 - Blend;\t\t//Find inverse. This is amount of pixel outside line\n        col += BkCol * vec3(Blend);\t//Add that percentage of background color to pixel\n    }\n   // float DistToA = distance(\n    if (CirDia - 0.5 < RotDia)\n    {\n        \n        if (CirDia + 0.5 > RotDia)\n        {\n        col = CirCol;\n        }\n        \n    }\n    //if (DistA + 2.0 > RotDia)\n   // {\n   //     col = CirCol;\n   // }\n    \n    if (DistA < 3.0)\t\t\t\t//Add Dot on top.\n    {\n        col = DotCol;   \n    }\n    if (DistB < 3.0)\n    {\n        col = DotCol;   \n    }    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}