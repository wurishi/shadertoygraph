{"ver":"0.1","info":{"id":"DlSyDK","date":"1692350161","viewed":78,"name":"Oren Nayar Comparison","username":"kenhu","description":"Oren Nayar Comparison","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"mlfcD7","parentname":"Diffuse BRDF Comparison"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct AppState\n{\n    float\tmenuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n    float   diff;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    s.diff      = data.w;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot  \t= data.xy;\n    s.objRot    \t= data.zw;\n}\n\nfloat Smooth(float x)\n{\n\treturn smoothstep(0., 1., saturate(x));   \n}\n\nfloat Circle(vec2 p, float r)\n{\n    return (length(p / r) - 1.) * r;\n}\n\nvoid Rotate(inout vec2 p, float a) \n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat Capsule(vec2 p, float r, float c) \n{\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nfloat RoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat Sphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat UnionRound(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Displace(float scale, float ampl, vec3 p)\n{\n    p *= ampl;\n\treturn scale * sin(p.x) * sin(p.y) * sin(p.z);\n}\n\nfloat Scene(vec3 p, mat3 localToWorld)\n{  \n    p = p * localToWorld;\n    \n    float ret = Sphere(p, 1.2);\n    //ret = RoundBox(p, vec3(1.0, 1.0, 0.3), 0.1);\n    //ret += Displace(0.1, 7.0, p);\n    \n\treturn ret;\n}\n\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for (int i = 0; i < 50; ++i)\n    {\n        if (h < 0.001 || t > maxd) \n        {\n            break;\n        }\n        \n\t    h = Scene(ro + rd * t, localToWorld);\n        t += h;\n    }\n\n    if (t > maxd)\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    Scene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\n\t    Scene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\n\t    Scene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\n\treturn normalize(nor);\n}\n\nvoid SliderText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(67, 76);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? String(t.x, uint[16](_R,_o,_u,_g,_h,_n,_e,_s,_s,_,_,_,_,_,_,_)) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    } \n}\n\nvoid DrawRadial(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(-164, 73);\n    \n\t// radial\n    float c2 = Capsule(p - vec2(0., 1.), 3., 8.5);\n    float c1 = Circle(p + vec2(0., 7. - 8. * (2. - s.menuId)), 2.5);\n    \n    color = mix(color, vec3(0.9), Smooth(-c2 * 2.));\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));    \n}\n\nvoid DrawCheck(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(-164, -90);\n    \n\t// check\n    float c2 = Circle(p + vec2(0., 0.), 3.0);\n    float c1 = Circle(p + vec2(0., 0.), s.diff * 2.5);\n    \n    color = mix(color, vec3(0.9), Smooth(-c2 * 2.));\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));    \n}\n\nvoid CheckText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(-160, -94);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);\n    \n    // Format\n    // String(t.x, uint[16](_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_))\n       \n    uint v = 0u;\n\tv = t.y == 0. ? String(t.x, uint[16](_D,_i,_f,_f,_e,_r,_e,_n,_c,_e,_,_,_,_,_,_)) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n    \n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid DrawSlider(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(110, 94.5);\n    \n    p.y += 15.;\n    float c1 = Capsule(p.yx - vec2(0., 20.), 1., 20.);\n    c1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\n\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\n}\n\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(-160, 62);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);\n    \n    // Format\n    // String(t.x, uint[16](_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_))\n       \n    uint v = 0u;\n\tv = t.y == 2. ? String(t.x, uint[16](_Q,_u,_a,_l,_i,_t,_a,_t,_i,_v,_e,_,_,_,_,_)) : v;\n    v = t.y == 1. ? String(t.x, uint[16](_G,_o,_t,_a,_n,_d,_a,_,_,_,_,_,_,_,_,_)) : v;\n\tv = t.y == 0. ? String(t.x, uint[16](_F,_u,_j,_i,_i,_,_,_,_,_,_,_,_,_,_,_)) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n    if (t.y == 2. - s.menuId)\n    {\n        textColor = vec3(0.74, 0.5, 0.12);\n\t}\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(0., 10.);\n    p *= .011;\n    \n    float yaw = 2.7 - s.objRot.x;\n    mat3 rotZ = mat3(\n        vec3(cos(yaw), 0.0, -sin(yaw)),\n\t\tvec3(0.0, 1.0, 0.0),        \n        vec3(sin(yaw), 0.0, cos(yaw))\n       );\n    \n    float phi = -0.1 + s.objRot.y;\n    mat3 rotY = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(phi), sin(phi)),\n        vec3(0.0, -sin(phi), cos(phi))\n       );\n    \n    mat3 localToWorld = rotY * rotZ;  \n    \n    // Light\n    vec3 lightDir      = normalize(vec3(0., 0., 1.));\n    lightDir = localToWorld * lightDir;\n    \n\tvec3 rayOrigin \t= vec3(0.0, .3, -3.5);\n    vec3 rayDir \t= normalize(vec3(p.x, p.y, 2.0));    \n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\n    if (t > 0.0)\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal(pos, localToWorld);        \n        vec3 viewDir = -rayDir;\n        vec3 refl = reflect(rayDir, normal);\n\n        vec3 halfVec = normalize(viewDir + lightDir);\n        float vdoth = saturate(dot(viewDir, halfVec));\n        float ndoth\t= saturate(dot(normal, halfVec));\n        float ndotv = saturate(dot(normal, viewDir));\n        float ndotl = saturate(dot(normal, lightDir));\n        \n        vec3 diffuseColor  = vec3(1.);\n        vec3 specularColor = vec3(0.);\n        float roughness    = s.roughness;\n        \n        if (s.menuId == 0.)\n        {\n            color = Diffuse_OrenNayar_Qualitative(diffuseColor, roughness, ndotv, ndotl, vdoth) * ndotl;\n        }\n        else if (s.menuId == 1.)\n        {\n            color = Diffuse_OrenNayar_Gotanda(diffuseColor, roughness, ndotv, ndotl, vdoth) * ndotl;\n        }\n        else if (s.menuId == 2.)\n        {\n            color = Diffuse_OrenNayar_Fujii(diffuseColor, roughness, ndotv, ndotl, vdoth) * ndotl;\n        }\n        \n        if (s.diff > 0.0)\n        {\n            vec3 difference = \n                color - \n                Diffuse_OrenNayar_Qualitative(diffuseColor, roughness, ndotv, ndotl, vdoth) * ndotl;\n            float differenceR = max3(-difference.x, -difference.y, -difference.z);\n            float differenceG = max3(difference.x, difference.y, difference.z);\n            if (differenceR < differenceG)\n                differenceR = 0.;\n            else\n                differenceG = 0.;\n\n            float differenceIntensity = 10.;\n            color = abs(vec3(differenceR, differenceG, 0.)) * differenceIntensity;\n        }\n        \n        color = pow(color, vec3(1. / 2.2));\n    }\n    else\n    {\n        // shadow\n        float planeT = -(rayOrigin.y + 1.2) / rayDir.y;\n        if (planeT > 0.0)\n        {\n            vec3 p = rayOrigin + planeT * rayDir;\n            \n            float radius = .7;\n            color *= 0.5 + 0.5 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\n        }\t\t\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;    \n    p *= 100.;\n    \n    AppState s;\n    LoadState(s);  \n\n    vec3 color = pow(vec3(1. / PI), vec3(1. / 2.2)); // Background\n    \n    DrawScene(color, p, s);\n    MenuText(color, p, s);\n    SliderText(color, p, s);\n    DrawRadial(color, p, s);\n    DrawCheck(color, p, s);\n    CheckText(color, p, s);\n    DrawSlider(color, p, s);\n\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// control loop\n\nconst float FOCUS_SLIDER = 1.;\nconst float FOCUS_OBJ    = 2.;\n\nstruct AppState\n{\n    float   menuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n    float   diff;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    s.diff      = data.w;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot   = data.xy;\n    s.objRot        = data.zw;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord)\n{\n    if (iFrame <= 0)\n    {\n        s.menuId      = 0.0;\n        s.roughness   = 0.5;\n        s.focus       = 0.0;\n        s.focusObjRot = vec2(0.0);\n        s.objRot      = vec2(0.0);\n        s.diff        = 0.0;\n    }\n    \n    vec4 ret = vec4(0.);\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.roughness, s.focus, s.diff), ret, fragCoord);\n    StoreValue(vec2(1., 0.), vec4(s.focusObjRot, s.objRot), ret, fragCoord);\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.) \n    {\n        discard;    \n    }\n\n    AppState s;\n    LoadState(s);\n    \n    vec4 q = iMouse / iResolution.xyxy;\n    q.w=abs(q.w)*sign(q.z);\n    vec4 m = -1. + 2. * q;\n    m.xz *= iResolution.x / iResolution.y;    \n    m *= 100.;    \n\n    vec4 sliderM = m - vec2(110, 94.5).xyxy;\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\n    {\n        s.focus = FOCUS_SLIDER;\n    } \n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\n    {\n        if (s.focus != FOCUS_OBJ)\n        {\n            s.focusObjRot = s.objRot; \n        }\n        s.focus = FOCUS_OBJ;\n    }\n    else\n    {\n        s.focus = 0.;\n        vec2 mp = (m.xy - vec2(-160, -1));\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y / 8.) : -1.;\n        if (menuId >= 0. && menuId <= 2.)\n        {\n            s.menuId = menuId;\n        }\n        \n        if (sign(iMouse.w) > 0.0 && mp.x < 40.0 && mp.y < -85.0 && mp.y > -95.0)\n        {\n            s.diff = 1.0 - s.diff;\n        }\n    }\n\n    if (s.focus == FOCUS_SLIDER)\n    {\n        s.roughness = saturate(sliderM.x / 40.);    \n    } \n    if (s.focus == FOCUS_OBJ)\n    {\n        s.objRot = s.focusObjRot + .04 * (m.xy - m.zw);\n    }\n    \n    fragColor = SaveState(s, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Common\n\nconst float PI = float(3.14159);\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0.), vec3(1.)); }\nfloat rcp(float x) { return 1. / x; }\nfloat min3(float x, float y, float z) { return min(min(x,y),z); }\nfloat max3(float x, float y, float z) { return max(max(x,y),z); }\n\nfloat Pow5(float x) { float xx = x*x; return xx * xx * x; }\n\n// BRDF\n\n    // https://www1.cs.columbia.edu/CAVE/publications/pdfs/Oren_SIGGRAPH94.pdf\n    vec3 Diffuse_OrenNayar_Qualitative( vec3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )\n    {\n        float VoL     = 2. * VoH * VoH - 1.;\t\t// double angle identity\n    \n        float sigma   = Roughness;\n        float sigma2  = sigma * sigma;\n    \n        float A       = 1.0 - 0.5 * sigma2 / (sigma2 + 0.33);\n        float B       = 0.45 * sigma2 / (sigma2 + 0.09);\n        \n        float theta_r = acos(NoV);\n        float theta_i = acos(NoL);\n        \n        float alpha   = max(theta_r, theta_i);\n        float beta    = min(theta_r, theta_i);\n        \n        float cos_phi = (VoL - NoV * NoL) / (sin(theta_i) * sin(theta_r));\n    \n        return DiffuseColor / PI * (A + B * max(0.0, cos_phi) * sin(alpha) * tan(beta));\n    }\n    \n    // https://blog.selfshadow.com/publications/s2012-shading-course/gotanda/s2012_pbs_beyond_blinn_notes_v3.pdf\n    vec3 Diffuse_OrenNayar_Gotanda( vec3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )\n    {\n        float VoL     = 2. * VoH * VoH - 1.;\t\t// double angle identity\n    \n        float sigma   = Roughness;\n        float sigma2  = sigma * sigma;\n    \n        float A       = 1.0 - 0.5 * sigma2 / (sigma2 + 0.33);\n        float B       = 0.45 * sigma2 / (sigma2 + 0.09);\n        \n        // Note the last division of NoL is necessary as Gotanda expand NoL during derivation\n        // As we will multiply NoL later, cancel it here\n            \n        return DiffuseColor / PI * (A + B * max(0.0, VoL - NoV * NoL) * min(1.0, NoL / NoV) / NoL);\n    }\n    \n    // From BRDF.ush ~ it says Gotanda but actually more like this Fujii one\n    // https://mimosa-pudica.net/improved-oren-nayar.html\n    vec3 Diffuse_OrenNayar_Fujii( vec3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )\n    {\n        float a       = Roughness;\n        float s       = a;\n        float s2      = s * s;\n        float VoL     = 2. * VoH * VoH - 1.;\t\t// double angle identity\n        float Cosri   = VoL - NoV * NoL;\n        float C1      = 1. - 0.5 * s2 / (s2 + 0.33);\n        float C2      = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0. ? rcp( max( NoL, NoV ) ) : 1. );\n        \n        float boost   = 1.0;\n        // boost      = ( 1. + Roughness * 0.5 );   // remove this for comparison, likely used to preserve energy\n        \n        // Proposed formula also has a term with albedo, likely interreflection componenet from the original paper\n        vec3 Interreflection = vec3(0.0);\n        Interreflection = 0.17 * DiffuseColor * s2 / (s2 + 0.13);\n        \n        return DiffuseColor / PI * ( C1 + C2 + Interreflection ) * boost;\n    }\n    \n// Text\n\nuint _ = 0u;\n\nuint _A = 65u;\nuint _B = 66u;\nuint _C = 67u;\nuint _D = 68u;\nuint _E = 69u;\nuint _F = 70u;\nuint _G = 71u;\nuint _H = 72u;\nuint _I = 73u;\nuint _J = 74u;\nuint _K = 75u;\nuint _L = 76u;\nuint _M = 77u;\nuint _N = 78u;\nuint _O = 79u;\nuint _P = 80u;\nuint _Q = 81u;\nuint _R = 82u;\nuint _S = 83u;\nuint _T = 84u;\nuint _U = 85u;\nuint _V = 86u;\nuint _W = 87u;\nuint _X = 88u;\nuint _Y = 89u;\nuint _Z = 90u;\n\nuint _a = 97u;\nuint _b = 98u;\nuint _c = 99u;\nuint _d = 100u;\nuint _e = 101u;\nuint _f = 102u;\nuint _g = 103u;\nuint _h = 104u;\nuint _i = 105u;\nuint _j = 106u;\nuint _k = 107u;\nuint _l = 108u;\nuint _m = 109u;\nuint _n = 110u;\nuint _o = 111u;\nuint _p = 112u;\nuint _q = 113u;\nuint _r = 114u;\nuint _s = 115u;\nuint _t = 116u;\nuint _u = 117u;\nuint _v = 118u;\nuint _w = 119u;\nuint _x = 120u;\nuint _y = 121u;\nuint _z = 122u;\n\nuint _plus = 43u;\nuint _minus = 45u;\n\nuint String(float index, uint chars[16])\n{\n    if (index < 4.)\n        return (chars[0] << 0) + (chars[1] << 8) + (chars[2] << 16) + (chars[3] << 24);\n    if (index < 8.)\n        return (chars[4] << 0) + (chars[5] << 8) + (chars[6] << 16) + (chars[7] << 24);\n    if (index < 12.)\n        return (chars[8] << 0) + (chars[9] << 8) + (chars[10] << 16) + (chars[11] << 24);\n    if (index < 16.)\n        return (chars[12] << 0) + (chars[13] << 8) + (chars[14] << 16) + (chars[15] << 24);\n\n    return 0u;\n}","name":"Common","description":"","type":"common"}]}