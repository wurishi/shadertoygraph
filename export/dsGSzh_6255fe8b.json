{"ver":"0.1","info":{"id":"dsGSzh","date":"1680702911","viewed":274,"name":"2.5D Column Shadows Thingy","username":"SnoopethDuckDuck","description":"Instructions:\n    CLICK the screen to draw columns\n    WASD to move\n    Q to change mode\n    hold SPACE to stop collisions\n    R to reset\n   \ninspired by this shader: https://www.shadertoy.com/view/cdKXzR","likes":26,"published":3,"flags":48,"usePreview":0,"tags":["raymarching","game","interactive","sdf","shadows","buffer"],"hasliked":0,"parentid":"cdVGWm","parentname":"Circle Packing SDF"},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 36.\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    \n    ivec2 ipx = ivec2(px);\n    vec4 txP = cell(ch0, ivec2(0, 0)); // Point\n    vec4 txD = cell(ch0, ivec2(1, 0)); // Other data\n    vec4 txB = cell(ch2, ipx);         // SDF\n\n    // Point position\n    vec2 p = txP.xy;\n\n    // Ray direction\n    vec2 rd = normalize(px - p);\n \n    // Total distance travelled\n    float d = 0.;\n    \n    float mode1 = mix(1., -1., step(1., txD.r));\n    float mode2 = step(2., txD.r);\n    \n    // Step count (in raymarching loop)\n    float c = MAX_STEPS;\n    \n    for (float i = 0.; i < MAX_STEPS; i++) {\n        // Distance to scene from p\n        float d0 = cell(ch2, ivec2(p)).r;\n             \n        // I can't explain this part,\n        // d0 = min(distance to scene, distance to pixel), and   \n        // a + abs(d0 - a) == d0 when d0 > a\n        float a = 0.22 * mode1 * length(px-p);\n        d0 = min(a + abs(d0 - a), length(p - px));\n\n        // Add noise to hide banding effect\n        d0 += (2. * hash12(floor(0.5 * p)) - 1.);\n        \n        // Adding to d0 when mode1 == -1. (when columns are visible)\n        // removes the wall/floor part\n        d0 += 5. * mode2;\n        \n        // Make columns taller and thicker (really cool)\n        // d0 -= 20.;\n        \n        // Move along ray direction by some amount\n        // (smaller increments give a nicer result)\n        p += 0.3 * d0 * rd;   \n        \n        // Increase total distance travelled\n        d += d0;\n\n        // Break if close to sdf boundary\n        if (d0 < 2.) { // || length(px - txP.xy) > 140.) \n            c = i + 1.;\n            break; \n        }\n    }\n    \n    vec3 col = vec3(exp(0.2 - 0.0015 * vec3(1,2,6) * c * c));\n    \n    // Border\n    float m =  min(px.x, res.x - px.x);\n    m = min(m, min(px.y, res.y - px.y));\n    col = mix(col, vec3(0.8, 0.8, 1), exp(-0.5 * m));\n    \n    // Nyan cat shadows\n    // float mx = clamp(length(col), 0., 1.);\n    // col *= mix(texture(ch1, vec2(1,4)*px/res).rgb, vec3(1), mx);\n    \n    // alternatively:\n    // col *= mix(texture(ch1, vec2(2,8)*px/res).rgb, vec3(1), 1.-pow(mx,10.));\n\n    // Foggier version\n    // col = vec3(exp(-0.002*d));\n    \n    // Overlay circles\n    // col += 0.5 * txB.b ;\n    \n    // Overlay normals\n    // vec2 n = norm(ch2, ipx);\n    // col.gb *= .5 + .5 * n;\n     \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEYBOARD iChannel1\n\n// This buffer stores point information\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    \n    vec4 txP = cell(ch0, ivec2(0, 0)); // Point\n    vec4 txQ = cell(ch0, ivec2(1, 0)); // Other data\n    vec4 txA = cell(ch0, ipx);         // This buffer\n    \n    // Initialize point on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) {\n        if (ipx == ivec2(0,0) || ipx == ivec2(0,1))        \n            txA = vec4(floor(0.5 * res), 0, 0);    \n        else if (ipx == ivec2(1,0))\n            txA = vec4(0, 0, 0, 0);\n    }\n    \n    float spd = 0.5;\n    if (ipx == ivec2(0, 0)) {\n        // Update velocity\n        txA.z += spd * (key_val(KEY_D) - key_val(KEY_A));\n        txA.w += spd * (key_val(KEY_W) - key_val(KEY_S));\n        txA.zw *= 0.95;\n        \n        // Old/New distance to buffer\n        float d0 = cell(ch2, ivec2(txA.xy)).r;          \n        float d1 = cell(ch2, ivec2(txA.xy + txA.zw)).r; \n        \n        // Normal\n        vec2 n = norm(ch2, ivec2(txA.xy));\n        \n        // If crossed boundary then push back\n        // (could use (-n.y,n.x) to slide along distances instead)\n        if (d0 > br && d1 < br && !key_down(KEY_SPACE)) \n            txA.zw = -n * length(txA.zw);\n        \n        // Update position\n        txA.xy += txA.zw;               \n    } \n    \n    // Save old position (unused?)\n    else if (ipx == ivec2(0, 1)) \n        txA = txP;\n        \n    // Other data (toggle mode)\n    else if (ipx == ivec2(1, 0)) {\n        // Could be improved but works fine\n        if (key_down(KEY_Q) && txA.g == 0.) {\n            txA.r = mod(txA.r + 1., 3.);\n            txA.g = 1.;\n        }\n        else if (!key_down(KEY_Q))\n            txA.g = 0.;            \n    }\n   \n   fragColor = txA;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define res iResolution.xy\n\n#define ss(a) smoothstep(-1., 1., a)\n\n// Ball radius\n#define br 2.\n\n// using: https://www.shadertoy.com/view/DscGRH\n#define key_val(key) texelFetch(KEYBOARD, ivec2(key, 0), 0).x\n#define key_down(key) (int(key_val(key)) == 1)\n#define KEY_RESET 82\n#define KEY_SPACE 32\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_Q 81\n#define KEY_E 69\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\n// from: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nvec4 cell(in sampler2D ch, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(ch, 0));\n    p = (p+r) % r;\n    return texelFetch(ch, p, 0);\n}\n\n// from: https://www.shadertoy.com/view/3tfcDM\nvec2 norm(in sampler2D ch, in ivec2 p) {\n    ivec3 e = ivec3(0, -1, 1);\n    return normalize(vec2(cell(ch, p-e.zx).r - cell(ch, p-e.yx).r,\n                          cell(ch, p-e.xz).r - cell(ch, p-e.xy).r));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define KEYBOARD iChannel1\n\n// This buffer stores sdf\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    vec4 txB = cell(ch2, ipx); // This buffer\n    \n    // Initialize distances on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) \n        txB = vec4(res.y ,0,0,0);   \n    \n    // Max radius of circles\n    float maxR = 20.;\n    \n    // Mouse position\n    vec2 ms = iMouse.xy;\n        \n    // Values at mouse\n    vec4 txR = cell(ch2, ivec2(ms));\n        \n    // If not inside sdf boundary, draw\n    if (txR.r > 0.) {        \n        // Red: distance field\n        float r = min(maxR, txR.r);\n        float d = length(px - ms) - r;\n        txB.r = smin(txB.r, d, 15.);\n        \n        // -- Green, blue, alpha are probably unused -- \n        \n        // Green: fade from centre of circles\n        float l = length(px - ms);\n        txB.g = max(txB.g, 1.-l / r);\n        \n        // Blue: random [0,1] value for each circle\n        float b = hash22(ms + iTime).x;\n        txB.b = mix(txB.b, b, ss(r-l));\n        \n        // Alpha: radius of circles\n        txB.a = mix(txB.a, l, ss(r-l));          \n    }\n    \n    fragColor = txB;\n}","name":"Buffer B","description":"","type":"buffer"}]}