{"ver":"0.1","info":{"id":"slBfRc","date":"1652607100","viewed":172,"name":"Periwinkle Diffusing","username":"greenbird10","description":"Simulate pigment diffusing in water","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["2d","fbm","fliud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by greenbird10\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec4 c = vec4(texture(iChannel0, p).rgb, 1.0);\n  \n    fragColor = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Referrence:\n// Sinuous by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n// Velocity handling\n\nconst float initalSpeed = 10.;\n#define time iTime*initalSpeed\n\n//From Dave (https://www.shadertoy.com/view/4djSRW)\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x))*2.0 - 1.0;\n}\n\n//From iq (https://www.shadertoy.com/view/XdXGW8)\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\nfloat fbm( in vec2 p, float tm )\n{\n    p *= 2.0;\n    p -= tm;\n\tfloat z=2.;\n\tfloat rz = 0.;\n    p += time*0.001 + 0.1;\n\tfor (float i= 1.;i < 7.;i++ )\n\t{\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\n\t\tz = z*1.93;\n        p *= m2;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nvec3 update(in vec3 vel, vec4 p, in float id)\n{\n    float n1a = fbm(p.xy * 10., id);\n    float n1b = fbm(p.yx * 10., id);\n    float nn = fbm(vec2(n1a,n1b),0.)*5.8 + .5;\n    \n    vec2 dir = vec2(cos(nn), sin(nn));\n    float speed = 1.5;\n    vel.xy = mix(vel.xy, dir*speed, 0.3);\n    return vel;\n}\n\n#define bufferPixel 5.\n#define samplePos 7.\n#define sampleVelo 3.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 w = 1./iResolution.xy;\n    if (fragCoord.y > bufferPixel*2.) discard;\n    \n    vec4 col = vec4(0);\n    vec4 pos = texture(iChannel0, vec2(q.x, samplePos*w.y));\n    vec3 velo = texture(iChannel0, vec2(q.x, sampleVelo*w.y)).xyz;\n    velo = update(velo, pos, pos.w);    \n    pos.xy += velo.xy * 0.02 * (pos.w*0.9+0.1);\n    \n    \n    if (fragCoord.y < bufferPixel)  //velo\n    {\n        col.rgb = velo;\n    }\n    else  // pos\n    {\n        col.xyz = pos.xyz;\n    }\n    col.w = pos.w;\n    \n    \n    //Init\n    float offset = q.x*733.;\n    float mdf = mod(float(iFrame) + offset, 1201.);\n    if (mdf < 5. || float(iFrame) < offset) \n    {\n        if (fragCoord.y < bufferPixel)\n            col = vec4(0.1,0,0,0);\n        else\n            col = vec4(\n            -0.99, \n            texture(iChannel1, q*.5).r*2. - 1.,\n            0,\n            q.x);\n    }\n    \n\tfragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Referrence:\n// Sinuous by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n// Rendering\n\n/*\n\tThis buffer renders each particles\n\tmultiple times per frame to allow particles\n\tto move more than one pixel per frame while still\n\tleaving a solid trail.\n*/\n\n#define time iTime\n\n//Anywhere under 800 \"should\" work fine (might slow down though)\nconst int numParticles = 300;\n\nfloat mag(vec2 p){return dot(p,p);}\n\nvec2 rot2d(vec2 p, float r) {\n    return vec2(p.x*cos(r) - p.y*sin(r),\n                p.x*sin(r) + p.y*cos(r));\n}\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define samplePos 7.\nvec4 drawParticles(in vec2 p)\n{\n    vec4 rez = vec4(0);\n    vec2 w = 1./iResolution.xy;\n    \n    for (int i = 0; i < numParticles; i++)\n    {\n        vec2 pos = texture(iChannel0, vec2(i,samplePos)*w).rg;\n        pos = rot2d(pos, 2.5);\n        pos.y += -0.1;\n        pos.x += -0.1;\n        pos.y *= 1.2;\n        pos.x *= 1.2;\n        \n        float d = mag(p - pos);\n        d *= 200.;\n        d = 0.01/(pow(d,1.0)+.001);\n\n  \n        // rand color in HSV\n        vec3 randCol = abs(sin(vec3(2.,3.4,1.2)*(iTime*.07 + float(i)*.001 + 2.5) + vec3(0.2,0.,1.2)));\n        // only blue purple\n        randCol.r = mix(0., .3, randCol.r);  \n        randCol = hsv2rgb(randCol);\n        rez.rgb += d*randCol*0.03;\n    }\n    \n    return rez;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 1.1;\n    \n    \n    vec4 cola = -drawParticles(p) * 0.05; \n    vec4 colb = texture(iChannel1, q);\n    vec4 col = cola + colb;\n    \n    \n    vec4 base = vec4(1,0.98,0.9,0.9); //*(1.-mag(p+vec2(-0.20,-.3))*0.1);\n    \n\n    if (iFrame < 15) fragColor = base;\n    else fragColor = col;//-cola * 200.;\n}","name":"Buffer B","description":"","type":"buffer"}]}