{"ver":"0.1","info":{"id":"ddffWl","date":"1689273846","viewed":173,"name":"Perspective Distortion (Flushed)","username":"fizzer","description":"Someone suggested I should do this, so I did. See [url=https://www.shadertoy.com/view/DdfBDl]here[/url] for the original.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["distortion","camera","perspective","fov","emoji","flushed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See https://www.shadertoy.com/view/DdfBDl\n\nconst float pi = 3.14159265358979323;\n\n// from IQ: https://www.shadertoy.com/view/wl23RK\n// sc is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nvec3 hexColour(int code)\n{\n    return pow(vec3((code & 0xff0000) >> 16, (code & 0xff00) >> 8, code & 0xff) / 255., vec3(2));\n}\n\nvec4 flushedFace(vec2 uv)\n{\n    float w = length(fwidth(uv)) / 2.;\n    vec4 res = vec4(1, 1, 1, 0);\n    uv.x = abs(uv.x);\n    \n    res = mix(res, vec4(hexColour(0xffcc4d), 1), 1. - smoothstep(1. - w, 1. + w, length(uv)));\n    res = mix(res, vec4(hexColour(0xff7892), 1), 1. - smoothstep(0.27979 - w, 0.27979 + w, length(uv - vec2(0.62, -0.2936))));\n    res = mix(res, vec4(hexColour(0xffffff), 1), 1. - smoothstep(0.2936 - w, 0.2936 + w, length(uv - vec2(0.1775 * 2., 0.03542))));\n    res = mix(res, vec4(hexColour(0x664500), 1), 1. - smoothstep(0.14468 - w, 0.14468 + w, length(uv - vec2(0.1765 * 2., 0.04042))));\n    \n    res = mix(res, vec4(hexColour(0x664500), 1), 1. -\n            smoothstep(0.0617 - w, 0.0617 + w, length(vec2(max(0., uv.x - 0.2302), uv.y + 0.62553))));\n    \n    float a = 1.08, b = .53;\n    vec2 sc = vec2(cos(a), sin(a));\n    mat2 m = mat2(cos(b), sin(b), -sin(b), cos(b));\n    float eyebrow = sdArc(m * (uv - vec2(0.27191, 0.13404)), sc, 0.4948, .06 );\n    \n    res = mix(res, vec4(hexColour(0x664500), 1), 1. - smoothstep(-w, +w, eyebrow));\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Parameters\n    vec2 range = vec2(1.01, 4.);\n\n    float cameraSphereDistance = mix(range.x, range.y, .5 + .5 * cos(iTime));\n    \n    if(iMouse.z > .5)\n        cameraSphereDistance = mix(range.x, range.y, iMouse.x / iResolution.x);\n    \n    // Problem geometry\n    float innerConeHalfAngle = acos(1. / cameraSphereDistance);\n    float outerConeHalfAngle = pi / 2. - innerConeHalfAngle;\n    float b = sqrt(cameraSphereDistance * cameraSphereDistance - 1.);\n    float c = cos(outerConeHalfAngle) * b;\n    float e = sin(innerConeHalfAngle);\n\n    // Camera / ray setup\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n    vec3 ro = vec3(0, 0, cameraSphereDistance), rd = normalize(vec3(uv * e * 1.2, -c));\n\n    vec3 col = vec3(0);\n\n    // Ray-sphere intersection\n    vec2 is = vec2(1, 0);\n    \n    {\n       float b = 2. * dot(rd, ro);\n       float c = cameraSphereDistance * cameraSphereDistance - 1.;\n       float desc = b * b - 4. * c;\n       if (desc >= 0.)\n           is = (sqrt(desc) * vec2(-1, 1) - b) / 2.;\n    }\n\n    // Environment texture\n    col = pow(texture(iChannel0, rd.zyx).rgb, vec3(2));\n\n    if(is.x > 0. && is.x <= is.y)\n    {\n        // Surface texture\n        vec3 rp = ro + rd * is.x;\n        col = flushedFace(rp.xy).rgb;\n    }\n\n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}