{"ver":"0.1","info":{"id":"lcGcRR","date":"1731394154","viewed":32,"name":"streak shader ","username":"congodin","description":"shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["streak"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Sphere setup\n    vec3 spherePos = vec3(0.0);\n    float sphereRadius = 0.3;\n    \n    // Camera setup\n    float camRadius = 2.0;\n    vec3 camPos = vec3(cos(iTime * 0.5) * camRadius, 0.3, sin(iTime * 0.5) * camRadius);\n    vec3 camTarget = spherePos;\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    \n    // Camera matrices\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = cross(camDir, camRight);\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    // Ray-sphere intersection check\n    vec3 oc = camPos - spherePos;\n    float b = dot(rayDir, oc);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float h = b * b - c;\n    \n    float result = 1.0;\n    vec2 streakUV = uv;\n    float streakInfluence = 1.0;\n    vec3 normal = vec3(0.0);\n    bool hitSphere = false;\n    \n    if(h >= 0.0) {\n        float t = -b - sqrt(h);\n        vec3 pos = camPos + rayDir * t;\n        normal = normalize(pos - spherePos);\n        hitSphere = true;\n        \n        // Adjust streak UV based on surface normal\n        streakUV = vec2(\n            atan(normal.z, normal.x),\n            acos(normal.y)\n        ) * 0.5;\n        \n        // Modify streak influence based on surface curvature\n        streakInfluence = abs(dot(normal, rayDir));\n    }\n    \n    // Base streak angle\n    float baseAngle = -0.785;\n    \n    // Create multiple layers of streaks\n    for(float i = 0.0; i < 3.0; i++) {\n        float angle = baseAngle;\n        \n        // If we hit the sphere, adjust streak angle based on normal\n        if(hitSphere) {\n            angle += dot(normal.xy, vec2(1.0, 0.0)) * 1.5;\n        }\n        \n        // Rotate UV for streak direction\n        mat2 rot = mat2(\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n        );\n        \n        vec2 rotUV = rot * streakUV;\n        \n        // Add movement\n        rotUV += iTime * 0.1 * (i + 1.0);\n        \n        // Create base streak pattern\n        float density = 15.0 + i * 5.0;\n        float pattern = fract(rotUV.x * density - rotUV.y * density);\n        \n        // Add variation to streak intensity\n        float noise = fract(sin(dot(rotUV * 15.0, vec2(12.9898, 78.233))) * 43758.5453);\n        \n        // Create breaks in streaks\n        float breaks = step(0.7, fract(sin(floor(rotUV.y * 5.0) + i * 1234.5) * 43758.5453));\n        \n        // Combine streak elements\n        float streak = smoothstep(0.3, 0.7, pattern) * breaks * (0.8 + 0.2 * noise);\n        \n        // If we hit the sphere, modify streak based on surface properties\n        if(hitSphere) {\n            streak *= streakInfluence;\n            // Add more breaks near edges\n            streak *= smoothstep(0.0, 0.2, dot(normal, vec3(0.0, 0.0, 1.0)) + 0.5);\n        }\n        \n        // Layer opacity\n        float opacity = 0.6 / (i + 1.0);\n        \n        // Combine with result\n        result = min(result, mix(1.0, 1.0 - streak, opacity));\n    }\n    \n    // Paper texture\n    float paper = fract(sin(dot(uv * 200.0, vec2(12.9898, 78.233))) * 43758.5453);\n    result = mix(result, result * paper, 0.05);\n    \n    fragColor = vec4(vec3(result), 1.0);\n}","name":"Image","description":"","type":"image"}]}