{"ver":"0.1","info":{"id":"fscBD8","date":"1656387065","viewed":171,"name":"d20 clouds","username":"pb","description":"light being blocked instead of being transmitted as in previous \"d20 particle storm\"","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","glow","icosahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//this is the same code as \"d20 particle storm\" except\n//light is blocked by the icosahedral fractal and different\n//scale factor is used for the IFS\n//also did not really need the gaussian blur post process\n\n#define PI 3.14159265;\n\n//hard coded icosahedron vertices for fractal generation\nconst float sqr5 = sqrt(5.);\nconst float p1 = 1./sqr5;\nconst float p2 = 2./sqr5;\nconst float p3 = sqrt( (5.+sqr5)/10. );\nconst float p4 = sqrt( (5.-sqr5)/10. );\nconst float p5 = (5.-sqr5)/10.;\nconst float p6 = (-5.-sqr5)/10.;\nconst float p7 = (5.+sqr5)/10.;\nconst float p8 = (-5.+sqr5)/10.;\n\nvec3[] d20 = vec3[] (\nvec3(1.,0.,0.),\nvec3(p1, p2, 0.),\nvec3(p1, p5, p3),\nvec3(p1, p6, p4),\nvec3(p1, p6, -p4),\nvec3(p1, p5, -p3),\nvec3(-1.,0.,0.),\nvec3(-p1, -p2, 0.),\nvec3(-p1, p8, -p3),\nvec3(-p1, p7, -p4),\nvec3(-p1, p7, p4),\nvec3(-p1, p8, p3)\n);\n\nvec3  ifs_color, center_of_hollow_sphere, center_of_earth;\nfloat ifs_scale; \nint   max_iter;\nfloat angle_time, thetaL, phiL, max_dist, sun_rnd, global_lum;\nvec3  global_light, lightpos;\n\nvec2 de_d20(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    z += .5;\n    z = mod( z - 1.1, 2.2 ) - 1.1;\n\n    ifs_color = vec3(0.);\n\n    for (int i=0; i<100; i++) {\n       \n        if ( i > max_iter ) break;\n\n        min_vtx = d20[0];\n        min_dist=length(z-d20[0]);\n        for (int j=1; j<12; j++) {\n        \n            dist_to_vtx=length(z-d20[j]); \n            if (dist_to_vtx<min_dist) {min_vtx=d20[j]; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        n++;\n\n        //potentially interesting colors\n        if ( z.x * z.y > 0. ) ifs_color.x ++;\n        if ( z.y * z.z > 0. ) ifs_color.y ++;\n        if ( z.z * z.x > 0. ) ifs_color.z ++;\n\n    }\n\n    ifs_color /= float(n);\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    return vec2( scene_dist, objid );\n}\n\nmat3 rot_xz( float an ) {\n    float can = cos(an);\n    float san = sin(an);\n\n    return mat3( can, 0., -san,\n                 0. , 1.,   0.,\n                 san, 0.,  can );\n\n}   \n\nvec3 sky_color( vec3 dir, vec3 lightpos, vec3 p ) {\n  \n    vec3 skypos  = dir*max_dist - center_of_earth;\n    vec3 sky;\n\n    float ldiff = length( -lightpos - skypos ); \n\n    ldiff *= ldiff;\n\n    float sun_lum  = exp( -ldiff/7e10 );\n    float sun_lum2 = exp( -ldiff/2e8);\n    float sun_lum3 = exp( -ldiff/8e9);\n\n    global_lum = max( min((1.+.85*sin(angle_time)),1.3), 0.);\n    \n    global_light = vec3( sun_lum/2., sun_lum/2., 1.6*sun_lum );\n\n    float global_sun_lum = sun_lum2;\n\n    sky = vec3(sun_lum2,sun_lum2,sun_lum2/2.);\n    sky += (1.-sun_lum)*sky + .5*global_light;\n    sky += (1.-sun_lum)*sky + .9*vec3( sun_lum3, sun_lum3/1.5, 0.);\n\n    return  sky;\n\n}\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\n    float totdist=0.;\n    float dist;\n    vec3  p, col=vec3(0.);\n    float glow = 0.;\n    float glow_threshold = .01*(1.+1.);\n\n    for (int i=0; i<40; i++) {\n\n        {\n            p = from + totdist*dir;\n            dist = de_d20(p).x;\n            totdist+=dist; \n            //not exactly glow anymore but density\n            if (dist<glow_threshold) \n                glow += max(0.,glow_threshold-dist)* exp(-totdist*totdist);\n         }\n \n    }\n\n    //the \"sky\" is always max_dist away\n    vec3 backg = sky_color( dir, lightpos, p );\n\n    col = backg*max(.1,(1.-1.3*glow));  //this was changed\n    col += (1.-.8)*glow * backg ;       //this was changed\n    \n\n\n    return col; \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ifs_scale = 1.666 + .96;    //this was changed\n    max_iter = 7;\n    max_dist = 100000.;\n    center_of_earth = vec3(0.,-1000.,0.);    \n    \n    mat3 rot;\n    vec3 movement;\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0. );\n        \n    float  focal_point = -1.2;\n\n    rot = rot_xz(.5);\n    vec3   rd =  rot * normalize(vec3(uv,focal_point));\n\n    ro -= rot[2] * iTime/2.;\n\n    angle_time = 0.;\n\n    thetaL    = -angle_time;\n\n    phiL      = 0.;\n    lightpos  = max_dist * \n        vec3( sin(thetaL)*sin(phiL), sin(thetaL)*cos(phiL), cos(thetaL) )  \n        + center_of_earth;        \n\n    center_of_hollow_sphere = ro;\n \n\n    vec3 color = raymarch(ro,rd);\n \n    color = clamp(color,0.,1.);\n    color = pow( color, vec3(2.) );\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}