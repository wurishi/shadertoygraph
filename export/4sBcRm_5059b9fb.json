{"ver":"0.1","info":{"id":"4sBcRm","date":"1491312719","viewed":218,"name":"CellTex Domain Distortion","username":"TinyTexel","description":"potentially useful for generating mountains\nright: distorted cell tex\nbottom left: undistorted cell tex\ntop left: distortion vector\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","distortion","worley","cellular","cell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\npotentially useful for generating mountains\nright: distorted cell tex\nbottom left: undistorted cell tex\ntop left: distortion vector\n*/\n\n#define Time iTime\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define clamp(x) clamp(x, 0.0, 1.0)\n\n\nconst float Pi = 3.14159265359;\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n\nfloat CellTex(vec2 p, float seed, vec2 cells)\n{\n\tfloat d1;\n\tvec2 p1;\n\tvec2 cv1;\n\t\n\tvec2 p_i = floor(p);\n\t\n\td1 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < d1)\n\t\t{\n\t\t\td1 = d;\n\t\t\tp1 = fp;\n\t\t\tcv1 = cv;\n\t\t}\n\t}\n    \n    \n\tfloat dd = 64.0;\n    \n    const float n = 1.0;\n\tfor(float i = -n; i <= n; ++i)\n\tfor(float j = -n; j <= n; ++j)\n\tif(i != cv1.x || j != cv1.y)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t    float d = dot(p - (p1 + fp) * 0.5, normalize(p1 - fp));\n\t\td *= 1.48;// empirically normalized\n\n\t\tdd = min(dd, d);\n\t}\n\t\n\treturn dd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 tex = uv / iResolution.xy;\n    \n    //uv.x = mod(uv.x, iResolution.x / 3.0);\n    \n    vec2 cells = vec2(0.0);\n    \n    vec2 pos = uv * 0.02 + Time * 0.2;\n    \n    vec2 off = vec2(CellTex(pos, 0.1, cells), \n                    CellTex(pos, 0.2, cells)) - vec2(0.25);\n    \n    float os = tex.x > 0.25 ? 0.3 : 0.0;\n    \n    float r = CellTex(pos + off * os, 0.0, cells);\n    \n    vec3 col = tex.y > 0.5 && tex.x < 0.25 ? vec3(off.xy * 1.0, 0.0*length(off)) : vec3(r);\n    \n    fragColor = vec4(clamp(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}