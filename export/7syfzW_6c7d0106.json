{"ver":"0.1","info":{"id":"7syfzW","date":"1657731087","viewed":241,"name":"The Chair","username":"ChutneyPot","description":"Some modeling and putting-everything-together practice.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","chair","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The Chair, July 2022\n// by Tito Morab - ChutneyPot\n// https://www.shadertoy.com/view/7syfzW\n//--------------------------------------------------------------------------\n#define CAM_VFOV 40.0\n#define CAM_POS vec3(0.8, 0.4, 1.0)\n#define CAM_TGT vec3(0.0, 0.0, 0.0)\n\n#define MOUSE_SENS 0.02\n\n#define EPSI 1e-4\n#define MAX_DIST 25.0\n#define MAX_STEPS 100\n#define AA 1\n\n#define D_LIGHT_DIR vec3(-0.4, 0.5, 1.0)\n#define P_LIGHT_POS vec3(2.5, 0.3, 0.2)\n#define D_LIGHT_COL vec3(1.0, 1.0, 1.0)\n#define P_LIGHT_COL vec3(1.0, 1.0, 1.0)\n\n#define A_LIGHT_COL vec3(0.03)\n#define AO_INCR 0.2\n#define AO_STEPS 5\n\n#define BG_COL vec3(0.4, 1.5, 1.5)\n#define SEAT_COL vec3(0.97, 0.55, 1.0)\n#define FRAME_COL vec3(1.2, 1.3, 0.55)\n\nconst float PI = 3.141592;\n\nstruct ob\n{\n    int id;\n    \n    float md;\n    float td;\n    \n    vec3 a;\n    float m;\n    float r;\n};\n\nvec3 linearToGamma(in vec3 col)\n{\n    return pow(col, vec3(0.4545));\n}\n\nvec3 gammaToLinear(in vec3 col)\n{\n    return pow(col, vec3(2.2));\n}\n\nfloat saturate(in float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\n//https://iquilezles.org/articles/distfunctions/\nvec3 bend(in vec3 p, in float k)\n{\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    mat2 m = mat2(c,-s, s, c);\n    vec3 q = vec3(m * p.xy, p.z);\n    return q;\n}\n\nvec2 rot(in vec2 uv, in float ang)\n{\n    ang = radians(ang);\n    vec2 res = mat2(cos(ang), sin(ang), -sin(ang), cos(ang)) * uv;\n    return res;\n}\n\nfloat sMin(float a, float b, float k)\n{\n    float h = saturate(0.5 + 0.5 * (b - a) / k);\n    return mix(b, a, h) - (k * h * (1.0 - h));\n}\n\nfloat plane(in vec3 p, in vec3 n)\n{\n    return dot(p,n);\n}\n\nfloat sphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat box(in vec3 p, in vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nob sMinDist(ob o1, ob o2)\n{\n    if(o1.md < o2.md)\n        return o1;\n    else\n        return o2;\n}\n\nob minDist(ob o1, ob o2)\n{\n    if(o1.md < o2.md)\n        return o1;\n    else\n        return o2;\n}\n\nob getNearestObj(in vec3 p)\n{    \n     float mdF = plane(p - vec3(0.0, -0.2, 0.0), vec3(0.0, 1.0, 0.0));   \n     float mdW = plane(p - vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0));\n     \n     float md = sMin(mdF, mdW, 1.2);\n     ob bg = ob(0, md, 0.0, gammaToLinear(BG_COL), 0.01, 0.95);\n          \n     float sd = box(bend(p, 0.5) - vec3(0.0, 0.08, 0.03), vec3(0.15, 0.001, 0.12)) - 0.005;\n     \n     vec3 q = p;\n     q.z += sin((q.x + 1.0) * 20.0) * 0.01;\n     q.z += sin((q.y + 0.0) * 20.0) * 0.005;\n     float bd = box(bend(q, -0.2) - vec3(0.0, 0.22, -0.09), vec3(0.14, 0.075, 0.001)) - 0.005;    \n     ob b = ob(1, min(sd, bd), 0.0, gammaToLinear(SEAT_COL), 0.3, 0.3);\n      \n     q = p;\n     q.xz = abs(q.xz) - vec2(0.13, 0.26);\n     q.xy = rot(vec2(q.xy), -10.0);\n     float ld1 = box(q - vec3(0.0, -0.06, -0.15), vec3(0.005, 0.14, 0.01)) - 0.005;\n     \n     q = p;\n     q.x = abs(q.x) - 0.13;\n     q.xy = rot(vec2(q.xy), -10.0);\n     float ld2 = box(q - vec3(0.0, 0.17, -0.11), vec3(0.005, 0.09, 0.01)) - 0.005;\n     \n     q = p;\n     q.x = abs(q.x) - 0.13;\n     q.xy = rot(vec2(q.xy), -10.0);\n     q.y += sin((q.z - 1.02) * 20.0) * 0.01;\n     float ld3 = box(q - vec3(0.0, 0.06, 0.0), vec3(0.005, 0.015, 0.12)) - 0.005;\n     \n     q = p;\n     q.z = abs(q.z) - 0.12;\n     q.y += sin((q.x - 1.02) * 20.0) * 0.01;\n     float ld4 = box(q - vec3(0.0, 0.01, -0.01), vec3(0.12, 0.01, 0.01)) - 0.005;\n     \n     float ld = sMin(sMin(sMin(ld1, ld2, 0.0), ld3, 0.001), ld4, 0.001);\n     ob l = ob(2, ld, 0.0, gammaToLinear(FRAME_COL), 0.0, 0.94);            \n     \n     ob c = minDist(b, l);  \n     return minDist(bg, c);\n}\n\nvec3 getNormal(in vec3 p)\n{\n    vec2 e = vec2(EPSI, 0.0);\n    \n    vec3 n = normalize(vec3(\n                getNearestObj(p + e.xyy).md - getNearestObj(p - e.xyy).md,\n                getNearestObj(p + e.yxy).md - getNearestObj(p - e.yxy).md,\n                getNearestObj(p + e.yyx).md - getNearestObj(p - e.yyx).md));\n    return n;\n}\n\nfloat getShadow(in vec3 p, in vec3 l)\n{\n    float md = 0.0;\n    float td = 0.01;\n    \n    float sh = 1.0;\n    \n    for(int mc = 0; mc < 100; mc++)\n    {\n       vec3 sp = p + td * l;\n       md = getNearestObj(sp).md;\n       td += md;\n       sh = min(sh, md * 16.0 / td);\n       \n       if(md < EPSI)\n           return 0.0;\n           \n        if(td > MAX_DIST)\n            break;\n    }\n    \n    return sh;\n}\n\nfloat getAO(in vec3 p, in vec3 n)\n{\n    float ao = 0.0;\n    float wt = 0.5;\n    \n    for(int s = 1; s <= AO_STEPS; s++)\n    {\n        float t = AO_INCR * float(s); \n        vec3 ap = p + t * n;\n        float d = getNearestObj(ap).md;\n        float n = t - d;\n        ao += (1.0 - n) * wt;\n        wt *= 0.5;\n    }\n    \n    return ao;\n}\n\nfloat distributionGGX(in float nDotH, in float r)\n{\n    float a = r * r;\n    float a2 = a * a;\n    float nDotH2 = nDotH * nDotH;\n    \n    float num = a2;\n    float den = nDotH2 * (a2 - 1.0) + 1.0;\n    den = PI * den * den;\n    \n    return num / den;\n}\n\nfloat geometrySchlickGGX(in float nDotX, in float r)\n{\n    float k = (r + 1.0) * (r + 1.0) / 8.0;\n    \n    float num = nDotX;\n    float den = nDotX * (1.0 - k) + k;\n    \n    return num / den;\n}\n\nfloat geometrySmith(in float nDotV, in float nDotL, in float r)\n{    \n    float ggxV = geometrySchlickGGX(nDotV, r);\n    float ggxL = geometrySchlickGGX(nDotL, r);\n    \n    return ggxV * ggxL;\n}\n\nvec3 fresnelSchlick(in float vDotH, in vec3 f0)\n{\n    return f0 + (1.0 - f0) * pow(saturate(1.0 - vDotH), 5.0);\n}\n\nvec3 getRadianceOut(in vec3 n, in vec3 v, in vec3 l, in ob o, in vec3 f0, in vec3 li)\n{\n    vec3 h = normalize(v + l);\n\n    float nDotL = max(dot(n, l), 0.0);\n    float nDotV = max(dot(n, v), 0.0);\n    float nDotH = max(dot(n, h), 0.0);\n    float vDotH = max(dot(v, h), 0.0);\n\n    float ndf = distributionGGX(nDotH, o.r);\n    float g = geometrySmith(nDotV, nDotL, o.r);\n    vec3 f = fresnelSchlick(vDotH, f0);\n\n    vec3 num = ndf * g * f;\n    float den = 4.0 * nDotV * nDotL;\n    vec3 spec = num / max(den, EPSI);\n\n    vec3 kS = f;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - o.m;\n    vec3 diff = kD * o.a / PI;\n\n    vec3 l0 = (diff + spec) * li * nDotL;\n    return l0;\n}\n\n//https://learnopengl.com/PBR/Lighting\nvec3 getPBRLighting(in vec3 p, in vec3 cp, in ob o)  \n{\n    vec3 n = getNormal(p);\n    vec3 v = normalize(cp - p);\n    \n    vec3 f0 = vec3(0.04);\n    f0 = mix(f0, o.a, o.m);\n    \n    vec3 l0 = vec3(0.0); \n    vec3 ld = P_LIGHT_POS - p;\n    vec3 l = normalize(ld);\n\n    float dis = length(ld);\n    float att = 1.0 / (dis * dis);\n    vec3 li = P_LIGHT_COL * att;\n\n    l0 += getRadianceOut(n, v, l, o, f0, li) * getShadow(p, l);       \n    l0 += getRadianceOut(n, v, D_LIGHT_DIR, o, f0, D_LIGHT_COL) * getShadow(p, D_LIGHT_DIR);\n    \n    vec3 il = A_LIGHT_COL * o.a * getAO(p, n);\n    \n    vec3 col = l0 + il;\n    return col;\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMappingACES(in vec3 col)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((col * (a * col + b)) / (col * (c * col + d) + e));\n}\n\nfloat vignette(in vec2 uv)\n{  \n    float v = uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y);\n    return saturate(pow(v * 30.0, 0.2));\n}\n\nob march(in vec3 ro, in vec3 rd)\n{\n    ob o;\n    float md = 0.0;\n    float td = 0.0;\n    \n    for(int mc = 0; mc < MAX_STEPS; mc++)\n    {\n       vec3 p = ro + td * rd;\n       o = getNearestObj(p);\n       md = o.md;\n       td += md;\n       \n       if(md < EPSI || td > MAX_DIST)\n           break;\n    }\n    \n    o.td = td;\n    return o;\n}\n\nvoid initCamera(in vec2 uv, inout vec3 ro, inout vec3 rd)\n{\n    float fl = 1.0 / tan(radians(CAM_VFOV / 2.0));\n    vec3 ip = vec3(uv, fl);\n    \n    //vec3 cp = CAM_POS;\n    vec3 cp = mix(CAM_POS, vec3(0.7, 0.5, 0.85), sin(iTime * 0.2) * 0.5 + 0.5);   \n    vec3 fd = normalize(CAM_TGT - cp);\n    vec3 rt = cross(fd, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(rt, fd);\n    \n    ip = cp + mat3(rt, up, fd) * ip;\n    \n    ro = cp;\n    rd = normalize(ip - cp);\n}\n\nvec3 render(in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro, rd;\n    initCamera(uv, ro, rd);\n    \n    ob o = march(ro, rd);\n    if(o.td < MAX_DIST)\n    {\n        vec3 p = ro + o.td * rd;\n        col = getPBRLighting(p, ro, o);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n\nvec3 col = vec3(0.0);\n#if AA == 1\n    col += render(fragCoord + vec2(-0.25, 0.25));\n    col += render(fragCoord + vec2(0.25, 0.25));\n    col += render(fragCoord + vec2(0.25, -0.25));\n    col += render(fragCoord + vec2(-0.25, -0.25));\n    col /= 4.0;\n#else\n    col = render(fragCoord);\n#endif\n\n    col = toneMappingACES(col);\n    \n    float v = vignette(fragCoord / iResolution.xy);    \n    col = mix(vec3(0.0), col, v);   \n    \n    col = linearToGamma(col);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}