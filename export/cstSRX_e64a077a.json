{"ver":"0.1","info":{"id":"cstSRX","date":"1680173834","viewed":136,"name":"Stereolux Workshop - 2D","username":"Flopine","description":"Shadercoding workshop for Stereolux","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagons","teaching","workshop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.)\n#define TAU 2.*PI\n\n#define hexratio vec2(1., sqrt(3.))\n\n#define square(uv,s) ( max(abs(uv.x), abs(uv.y)) - s)\n\n// angular modulo\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    // calculate angle in polar coord\n    float a = atan(p.y,p.x);\n    // repet the angle\n    a = mod(a, per)-per*0.5;\n    // polar to euler coord\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\n// rotation matrice\nmat2 rotation (float angle)\n{\n    return mat2( cos(angle), sin(angle), -sin(angle), cos(angle) );\n}\n\nfloat hexagone (vec2 uv)\n{ \n    uv = abs(uv);\n    return  max(uv.x, dot(uv, normalize(hexratio)) );\n}\n\nvec4 hexgrid (vec2 uv)\n{\n    vec2 grid_a = mod(uv, hexratio) - hexratio*0.5;\n    vec2 grid_b = mod(uv-hexratio*0.5, hexratio) - hexratio*0.5;  \n    \n    vec2 hex_uv;\n    // if we are closer to grid a than grid b\n    if ( length(grid_a) < length(grid_b) )\n    {\n        hex_uv = grid_a;\n    }\n    else\n    {\n        hex_uv = grid_b;\n    }\n    \n    // one line if\n    //vec2 hex_uv = ( length(grid_a) < length(grid_b) ) ? grid_a : grid_b;\n\n    vec2 hex_id = uv - hex_uv;\n    \n    return vec4(hex_uv, hex_id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n    // translation\n    //uv = uv + iTime\n    //uv.x += iTime;\n    \n    //scale\n    //uv *= sin(iTime)*0.5+0.5;\n    uv *= 3.;\n    \n    //rotation\n    //uv *= rotation(iTime);\n    \n    // symmetry\n    //uv = abs(uv)-0.5;\n    //uv = abs(uv) - ( sin(iTime)*0.5 + 0.5 )*2.0;    \n        \n    // angular modulo\n    moda(uv, 3.);\n    uv.x -= 2.;\n    \n    //id of each cells\n    //vec2 id = floor(uv);\n    \n    //cells\n    //uv = fract(uv)-0.5;\n    \n    //circles\n    float circle = step(0.5, length(uv) );  \n    float outline_circle = step( 0.01 ,abs( length(uv)-0.25 ) ); \n    \n    //squares\n    float sq = step(0.5, square(uv, 0.));\n    float outline_sq = step(0.01, abs( square(uv, 0.5) ));\n    \n    vec4 hg = hexgrid(uv);   \n    float mix_cursor =  sin( length(hg.zw * 0.8) - iTime ) * 0.5 + 0.5;\n    // lerp - linear interpolation\n    float threshold = mix( 0.1, 0.45, clamp( mix_cursor, 0.0, 1.0) );\n    \n    vec3 col = vec3( step(threshold, hexagone(hg.xy) ) );\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}