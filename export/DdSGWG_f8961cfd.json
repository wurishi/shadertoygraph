{"ver":"0.1","info":{"id":"DdSGWG","date":"1668052888","viewed":92,"name":"OA Question 2 Keyu Lu","username":"keyulu","description":"Starting point for Question 2 - Basic Shading\n\nDrag mouse for orbit camera.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shading"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=======================================================================================\nvec3 ShadePixel (in vec3 albedo, in vec3 normal)\n{\n\treturn albedo;\n}\n//=======================================================================================\n//enviroment mapping helper\nvec3 enviromentMapping(vec3 rayDir) {\n    vec3 entex = texture(iChannel0, rayDir).xyz;//mapping\n    entex = entex * entex;//color correction\n    vec3 correctedTexture = pow(entex, vec3(1.0 / 1.3));\n    return correctedTexture;//return corrected texture\n}\n//camera rotation helper, I am aiming to rotation matrix around the Y axis.\nmat3 rotateY(float angle) {\n    float cosValue = cos(angle);\n    float sinValue = sin(angle);\n    return mat3(\n        vec3(cosValue, 0, sinValue),\n        vec3(0, 1, 0),\n        vec3(-sinValue, 0, cosValue)\n    );\n}\n//postprocessing worley noise helper - randomized value generator\nvec2 random( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n//postprocessing worley noise helper - worley noise generator\nfloat WorleyNoise(vec2 uv) {\n    uv *= 7.;\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0;\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = random(uvInt + neighbor);//calling random helper written above for the generation of worley noise\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n//postprocessing grain helper - grain generator\nfloat grain (vec2 uv) {\n    float grainEffect = fract(iTime + sin(dot(uv.xy, vec2(14.0,130.)))* 3000.);\n    return grainEffect;\n}\n\nbool RayIntersectAABox  (in vec3 boxMin, in vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    vec3 boxCenter = (boxMin+boxMax)*0.5;\n\tvec3 roo = rayPos - boxCenter;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (time.x > maxTime)\n        return false;\n    \n    // if time invalid or we hit from inside, bail out\n    if (time.y < time.x || time.x < 0.0)\n        return false;\n\t\n    // calculate surface normal\n    hitPos = rayPos + rayDir * time.x;   \n    vec3 hitPosRelative = hitPos - boxCenter;\n    vec3 hitPosRelativeAbs = abs(hitPosRelative);\n    vec3 distToEdge = abs(hitPosRelativeAbs - rad);\n\n    float closestDist = 1000.0;\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        if (distToEdge[axis] < closestDist)\n        {\n            closestDist = distToEdge[axis];\n            normal = vec3(0.0);\n            if (hitPosRelative[axis] < 0.0)\n                normal[axis] = -1.0;\n            else\n                normal[axis] = 1.0;\n        }\n    }        \n\n    // store the collision time as the new max time\n    maxTime = time.x;\n    return true;\n}\n\n//=======================================================================================\nbool RayIntersectSphere (in vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    if (sphere.w <= 0.0)\n        return false;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n        return false;\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (collisionTime > maxTime)\n        return false;\n    \n    // store the collision time as the new max time\n    maxTime = collisionTime;\n    \n\t//compute the point of intersection\n\thitPos = rayPos + rayDir * collisionTime;    \n    \n   \t// calculate the normal\n\tnormal = hitPos - sphere.xyz;\n\tnormal = normalize(normal); \n\n\treturn true;\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor)\n{   \n    float maxRayHitTime = 1000.0;\n    bool hit = false;\n    vec3 hitPos;    \n    vec3 normal;            \n    vec3 albedo;\n        \n\t// green box\n    if (RayIntersectAABox(vec3(0.4,-0.3,-0.5), vec3(1.4,0.3,0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {    \n        //enviroment mapping for the green box\n        //vec3 normal2 = normalize(hitPos - vec3(0.0));\n        hit = true;\n        albedo = vec3(0.1, 0.9, 0.1); \n        albedo = albedo*(enviromentMapping(reflect(rayDir, normal)));\n    }\n\t\n    // red sphere\n    if (RayIntersectSphere(vec4(-0.4, 0.4, 0.5, 0.5), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        //enviroment mapping for the red sphere\n        //vec3 normal2 = normalize(hitPos - vec3(0.0));\n        hit = true;\n        albedo = vec3(0.9, 0.1, 0.1); \n        albedo = albedo*(enviromentMapping(reflect(rayDir, normal)));\n    }\n    \n    // blue sphere\n    if (RayIntersectSphere(vec4(-0.8, 0.4, -0.75, 0.25), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        //enviroment mapping for the blue sphere\n        //vec3 normal2 = normalize(hitPos - vec3(0.0));\n        hit = true;\n        albedo = vec3(0.1, 0.1, 0.9);\n        albedo = albedo*(enviromentMapping(reflect(rayDir, normal)));\n    }\n    \n    if (!hit)\n\t\treturn;\n    \n    pixelColor = ShadePixel(albedo, normal);\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //----- camera setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 0.0;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) : 0.0;\n\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!    \n    \n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t   \n\t// if the mouse button is down do orbit camera\n\tif( iMouse.z > 0.0 ) {\n\t\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\t\trayPos = cameraPos;\n\t}\n\t// else handle the case of the mouse button not being down\n\telse {\n\t\trayPos = vec3(0.0,3.0,-3.0);\n\t\tvec3 f = normalize(cameraAt - rayPos);\n\t\tvec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n\t\tvec3 u = normalize(cross(l,f));\n\t\t\n\t\trayTarget = (f * cameraDistance)\n\t\t\t\t  + (l * percent.x * cameraViewWidth)\n\t\t          + (u * percent.y * cameraViewHeight);\t\t\n\t}\n    \n\t//----- ray trace\n\tvec3 rayDir = normalize(rayTarget);\n    //camera rotation \n    const float PI = 3.1415;\n    rayDir *= rotateY(sin(iTime * 0.4) * PI);\n    // initialze ray color to the cube map\n    vec3 pixelColor = texture(iChannel0, rayDir).rgb;\n    \n    // ray trace\n\tTraceRay(rayPos, rayDir, pixelColor);\n   \n    //point light and directional light (diffuse + specular. Doesn't need to be PBR. Lambert / phong is ok!)\n    vec2 uv = fragCoord/iResolution.xy;//initialize uv\n    \n    //Setting up animated lighting\n    float var = abs(sin(iTime)+cos(iTime)*0.237);\n    //Setting up variables needed for lighting\n    float diffuse ;    \n    float specular;\n    float ambient;\n    float emissive;\n    float viewLength;\n    vec3 normal = normalize(vec3(0.0,0.0,1.0));        \n\tvec3 lightPos = vec3(var*2., sin(iTime * 1.4) * 2., sin(iTime * 1.8) * 3.);//lighting animation\n    vec3 lightDir = normalize(lightPos - vec3(uv,0.0));   \n    vec3 viewPos = vec3(0.0,0.0,1.0);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n\tvec3 viewDir = normalize(viewPos - vec3(uv,0.0));\n    vec3 viewDirection = rayPos + rayDir;\n    float angle = dot(rayDir, normalize(lightPos - viewDirection));\n    viewLength = length(lightPos - viewDirection) * sqrt(1. - angle * angle);\n    \n    //diffuse lighting \n\tdiffuse = max(dot(normal, lightDir), 0.0); \n    //specular lighting\n\tspecular  = pow(max(dot(viewDir, reflectDir), 0.0), 40.) * 2.0;  \n    //ambient lighting\n    ambient = 0.5;\n    //emissive lighting\n    emissive = pow(viewLength + .95, -2.);\n\n    // output sRGB corrected pixel\n    pixelColor = pow(pixelColor, vec3(1.0/2.2));   \n    //apply ambient,diffuse, specular and emissive to pixelColor\n    pixelColor = (ambient + diffuse +specular + emissive )* (pixelColor.rgb);\n    \n    //post processing shaders\n    //Vignette processing shader\n    vec2 vignette = abs(uv - vec2(0.5)) * 1.6;\n    vignette = pow(vignette, vec2(2.0));\n    pixelColor.rgb *= pow(1.0 - dot(vignette,vignette), 3.5);\n    \n    //worley warp processing shader\n    uv -= 1. * iTime;\n    vec3 originalColor = vec3(texture(iChannel0, vec3(uv,1)));\n    float xAxis = WorleyNoise(uv+vec2((1.0/iResolution.x),0.0))-WorleyNoise(uv-vec2((1.0/iResolution.y),0.0));\n    float yAxis = WorleyNoise(uv+vec2(0.0,(1.0/iResolution.y)))-WorleyNoise(uv-vec2(0.0,(1.0/iResolution.y)));\n    float distance = WorleyNoise(uv);\n    vec2 newUV = uv + vec2(xAxis, yAxis);\n    vec3 result0 = vec3(texture(iChannel0, vec3(uv,0.1)));\n    vec3 result1 = clamp(result0*(1.0-distance),0.,1.);\n    pixelColor = mix(pixelColor, result1, 0.15);\n    \n    //grain processing shader\n    vec3 grainShader = vec3(grain(uv));\n    pixelColor = mix(pixelColor, grainShader, 0.05);\n    \n    //output\n\tfragColor = vec4(pixelColor, 1.0);\n}\n/*I added:\n* point light and directional light (diffuse + specular. Doesn't need to be PBR. Lambert / phong is ok!)\n* ambient lighting\n* emissive lighting\n* environment mapped reflections\n* animated camera and light\n* post processing effects\n*/\n\n/*\nAdd:\n* point light and directional light (diffuse + specular. Doesn't need to be PBR. Lambert / phong is ok!)\n* ambient lighting\n* emissive lighting\n* environment mapped reflections\n\n* One other feature to make it unique / show off your stuff. Some ideas:\n * shadows\n * Normal or bump mapping\n * ray based reflections\n * anti aliasing\n * lens effects\n * post processing effects\n * warping geometry, more complex geometry\n * animating the camera, lights or geometry.\n * refraction or transparency\n * anything else you can think of\n*/","name":"Image","description":"","type":"image"}]}