{"ver":"0.1","info":{"id":"cdcBDs","date":"1697750143","viewed":68,"name":"Perceptual color similarity","username":"MV10","description":"Converts RGB (linear sRGB) to OKLab space to determine the similarity between two RGB colors. A simple RGB gradient is across the top. The grayscale band indicates how similar (0 to 1 range) each spot on the gradient is to the colored block at the bottom.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["color","perception","similarity","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nI have an application which needs to allow perceptual color-matching with\nvarying levels of tolerance. The typical YCC chroma-key methods and all RGB/HSV\nmethods were far too error-prone and not at all perceptually-oriented. However,\nOKLab is an excellent perceptual model which retains computationally-friendly\naspects. It's a bit heavyweight, but I'm hoping it'll work for my needs.\n\nThis demonstrates the similarity calculation (a simple distance function) by\ncycling through RGB (linear-sRGB) target colors every few seconds, and visually\nshowing the similarity versus all the points across an RGB color spectrum.\n\nSince 0.0 indicates the colors are identical, the visual representation is the inverse\n(in other words, black is as dissimilar as possible, and bright white indicate the\ncolors are identical). The smaller block shows a 5% tolerance relative to the identical\nmatch.\n\nFor performance purposes, the OKLab conversion uses a Halley estimation in place of\ntrue cube root calculations (of which six would be required to compare two colors).\nMy CPU tests show this is about 14% faster with minimal errors versus real cube roots.\n\nThe other popular estimation method, Newton, seems to require twice as many iterations\nto achieve the same low error-rate, and at least for my CPU-based testing, as a result\nit doesn't have any performance benefits.\n\nCredits\n  OKLab calcs   https://bottosson.github.io/posts/oklab/\n  Halley calc   https://www.shadertoy.com/view/wts3RX\n  RGB gradient  https://www.shadertoy.com/view/4dsSzr\n\n*/\n\nvec3 rgb_gradient(float x)\n{\n    float t = x / iResolution.x;\n    vec3 p = abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\n    return clamp(p - 1.0, 0.0, 1.0);\n}\n\nfloat halley_cube_root(float x)\n{\n    float y = sign(x) * uintBitsToFloat(floatBitsToUint(abs(x)) / 3u + 0x2a514067u);\n    for( int i = 0; i < 4; ++i )\n    {\n        float y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    return y;\n}\n\nvec3 rgb2oklab(vec3 c)\n{\n    float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n\tfloat a = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n\tfloat b = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n\n    float lr = halley_cube_root(l);  // pow(l, 1.0 / 3.0)\n    float ar = halley_cube_root(a);  // pow(a, 1.0 / 3.0)\n    float br = halley_cube_root(b);  // pow(b, 1.0 / 3.0)\n\n    return vec3 (\n        0.2104542553 * lr + 0.7936177850 * ar - 0.0040720468 * br,\n        1.9779984951 * lr - 2.4285922050 * ar + 0.4505937099 * br,\n        0.0259040371 * lr + 0.7827717662 * ar - 0.8086757660 * br);\n}\n\nfloat color_difference(vec3 rgb1, vec3 rgb2)\n{\n    vec3 oklab1 = rgb2oklab(rgb1);\n    vec3 oklab2 = rgb2oklab(rgb2);\n    return distance(oklab1, oklab2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bands = 5.0;\n    float band = bands * fragCoord.y / iResolution.y;\n    float block_width = iResolution.x / 10.0;\n\n    float tolerance = 0.05;\n\n    fragColor = vec4(0.0);\n\n    // pick a comparison color\n    vec3 target = rgb_gradient(0.5 + 0.5 * cos(iTime) * iResolution.x);\n\n    if(band > 4.0) // gradient band\n    {\n        fragColor = vec4(rgb_gradient(fragCoord.x), 1.0);\n    }\n    else if(band > 2.0) // similarity and tolerance-range bands\n    {\n        vec3 gradient = rgb_gradient(fragCoord.x);\n        float similarity = 1.0 - color_difference(target, gradient);\n        if(band > 3.0) // similarity\n        {\n            fragColor = vec4(vec3(similarity), 1.0);\n        }\n        else // within tolerance range\n        {\n            if(similarity + tolerance >= 1.0) \n                fragColor = vec4(1.0);\n        }\n    }\n    else if (band > 0.25 && band < 1.50) // comparison color\n    {\n        float center = iResolution.x / 2.0;\n        if(fragCoord.x > center - block_width && fragCoord.x < center + block_width)\n            fragColor = vec4(target, 1.0);\n    }\n\n}\n","name":"Image","description":"","type":"image"}]}