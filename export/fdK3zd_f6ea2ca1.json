{"ver":"0.1","info":{"id":"fdK3zd","date":"1631979123","viewed":94,"name":"les babales","username":"yamashi","description":"Defi NaN, click somewhere to attract balls, note that this a real blackhole, it will win over collisions ^^","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvec3 drawSphere(in vec2 fragCoord)\n{\n    if(iMouse.z > 0.0)\n    {\n        vec2 dist = fragCoord - iMouse.xy;\n        float len = dot(dist, dist);\n        if(len < (25.0*25.0))\n        {\n            return vec3(1,1,1);\n        }\n    }\n\n    for(int i = 0; i < sphereCount; ++i)\n    {\n        vec4 sphereDef = loadValue(txSpheres + ivec2(0, i));\n        \n        vec2 dist = fragCoord - sphereDef.xy;\n        float len = dot(dist, dist);\n        \n        if(len < (sphereDef.z*sphereDef.z))\n        {\n            return loadValue(txSphereColors + ivec2(0, i)).xyz;\n        }\n    }\n    return vec3(0,0,0);\n}\n\nvec3 drawEffects(in vec2 fragCoord, in vec3 color)\n{\n    if(color != vec3(0,0,0))\n        return color;\n\n    for(int i = 0; i < sphereCount; ++i)\n    {\n        vec4 sphereDef = loadValue(txSpheres + ivec2(0, i));\n        vec4 sphereVelocityDef = loadValue(txSphereVelocities + ivec2(0, i));\n        if(sphereVelocityDef.w <= 0.0)\n            continue;\n                \n        vec2 dist = fragCoord - sphereDef.xy;\n        float len = dot(dist, dist);\n        float effect_size = sphereDef.z * 1.2;\n        \n        if(len > (sphereDef.z*sphereDef.z) && len <= (effect_size*effect_size))\n        {\n            return vec3(sphereVelocityDef.w*2.0);\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Output to screen\n    fragColor = vec4(drawEffects(fragCoord, drawSphere(fragCoord)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n\n    if( ifragCoord.x > 2 || ifragCoord.y > sphereCount) discard;\n   \n    float frame_delta = min(iTimeDelta, 0.05);\n\n    int sphereIdx = ifragCoord.y;\n    \n    int xDiv = int(iResolution.x / (40.0 + float(sphereCount * 3)));\n    int yDiv = int(iResolution.y / (40.0 + float(sphereCount * 3)));\n    \n    float offsetx = float(sphereIdx % xDiv) * (float(iResolution.x) / float(xDiv));\n    float offsety = float(sphereIdx / xDiv) * (float(iResolution.y) / float(yDiv));\n\n    vec4 sphereDef = vec4(30.0 + offsetx, 30.0 + offsety , 15.0 + float(sphereIdx), 20.0 + float(sphereIdx));\n    vec4 velocity = vec4(100.0, 200.0, 0.0, 0.0);\n\n    if(iFrame > 0)\n    {\n        sphereDef = loadValue(txSpheres + ivec2(0, sphereIdx));\n        velocity = loadValue(txSpheres + ivec2(1, sphereIdx));\n    }\n\n    vec4 futureDef = sphereDef + vec4(velocity.xy * frame_delta, 0, 0);\n\n    float had_colided = velocity.z;\n    float colided = 0.0;\n    \n    vec4 bounds = vec4(iResolution.x, iResolution.y, 0.0, 0.0);\n    vec4 component_bounds = vec4(futureDef.x + futureDef.z, futureDef.y + futureDef.z, futureDef.x - futureDef.z, futureDef.y - futureDef.z);\n\n    bvec2 upper_bound_limits = greaterThan(component_bounds.xy, bounds.xy);\n    bvec2 lower_bound_limits = lessThan(component_bounds.zw, bounds.zw);\n    \n    // Test bounds\n    velocity.x = mix(velocity.x, (velocity.x > 0.0 ? -velocity.x : velocity.x), upper_bound_limits.x);\n    velocity.x = mix(velocity.x, (velocity.x < 0.0 ? -velocity.x : velocity.x), lower_bound_limits.x);\n    velocity.y = mix(velocity.y, (velocity.y > 0.0 ? -velocity.y : velocity.y), upper_bound_limits.y);\n    velocity.y = mix(velocity.y, (velocity.y < 0.0 ? -velocity.y : velocity.y), lower_bound_limits.y);\n    \n    for(int i = 0; i < sphereCount; ++i)\n    {\n        if(i == sphereIdx)\n            continue;\n\n        vec4 otherSphereDef = loadValue(txSpheres + ivec2(0, i));\n        vec4 otherVelocity = loadValue(txSpheres + ivec2(1, i));\n\n        vec2 col = sphereDef.xy - otherSphereDef.xy;\n        \n        float len_squarred = dot(col, col);\n        float radius_squarred = (sphereDef.z+otherSphereDef.z)*(sphereDef.z+otherSphereDef.z);\n\n        if(len_squarred <= radius_squarred)\n        {\n            colided = had_colided + 1.0;\n                \n            float push = dot(velocity.xy - otherVelocity.xy, col)/len_squarred;\n            float elastic_factor = 2.0 * push * otherSphereDef.w / (otherSphereDef.w + sphereDef.w);\n            velocity.xy -= mix(elastic_factor * col, vec2(0.0,0.0), min(had_colided,1.0)); \n        }\n    }\n    \n    if(ifragCoord.x == 0)\n        fragColor = colided == 0.0 ? futureDef : (sphereDef + vec4(velocity.xy * frame_delta, 0, 0));\n        \n    if(ifragCoord.x == 1)\n    {\n        // Apply gravity pull\n        vec2 delta = iMouse.xy - sphereDef.xy;\n        velocity.xy += clamp(iMouse.z, 0.0, 1.0) * delta * iTimeDelta * 100000.0 / (length(delta) * length(delta));\n        \n        float time_left = velocity.w - frame_delta;\n        float col_effect = colided > 0.0 ? 0.5 : time_left;\n\n        fragColor = vec4(velocity.xy, colided, col_effect);\n    }\n        \n    if(ifragCoord.x == 2)\n        fragColor = vec4(offsetx / float(iResolution.x), offsety / float(iResolution.x), 1, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int sphereCount                = 30;\nconst ivec2 txSpheres                = ivec2(0, 0);\nconst ivec2 txSphereVelocities       = ivec2(1, 0);\nconst ivec2 txSphereColors           = ivec2(2, 0);","name":"Common","description":"","type":"common"}]}