{"ver":"0.1","info":{"id":"llSyz3","date":"1509473405","viewed":121,"name":"SDF Renderer","username":"Baldur","description":"A simple signed distance field renderer including:\n- soft shadows\n- smooth minimum distance combination\n- reflections\n- phong-lighting\n\nControls:\n- Move: arrow keys + mouse\n- Set light position: Q","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MAX_T 1000.0\n#define DELTA 0.003\n\nconst vec2 LOC_CAM_POS = vec2( 1.0, 0.0 );\nconst vec2 LOC_CAM_UP = vec2( 2.0, 0.0 );\nconst vec2 LOC_CAM_DIR = vec2( 3.0, 0.0 );\nconst vec2 LOC_LIGHT_POS = vec2( 4.0, 0.0 );\n\nconst vec3 SKY_COLOR = vec3( 103.0 / 255.0, 206.0 / 255.0, 240.0 / 255.0 );\n\nconst float pi = 3.14159265359;\n\nstruct RayIntersection\n{\n\tfloat dist;\n    vec3 point;\n    float t;\n};\n\nfloat inverseMix( float a, float b, float x )\n{\n\treturn ( x - a ) / ( b - a );\n}\n       \nvec3 readVec3( vec2 location )\n{\n    return texture( iChannel1, ( location + 0.5 ) / iChannelResolution[ 1 ].xy ).rgb;\n}\n\nfloat degToRad( float deg )\n{\n    return deg / 180.0 * 3.1415926;\n}\n\nfloat distSphere( vec3 point, vec3 center, float radius )\n{\n    return distance( center, point ) - radius;\n}\n\nfloat distTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2( length( p.xz ) - t.x,p.y );\n    return length( q ) - t.y;\n}\n\nfloat distHalfSpace( vec3 point, vec3 support, vec3 normal )\n{\n    return dot( point - support, normal );\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 uvMap( vec3 point )\n{\n    return point.xz;\n}\n\nfloat dist( vec3 point )\n{\n    point.x = mod( point.x + 8.0, 16.0 ) - 8.0;\n    point.z = mod( point.z + 8.0, 16.0 ) - 8.0;\n    \n    return\n        smin(\n            smin(\n\t        \tdistSphere( point, vec3( -mod( iTime, 4.0 ) * 4.0 + 16.0, sin( iTime / 2.0 * pi ) * 3.0, sin( iTime / 8.0 * 6.0 * pi ) * 3.0 ), 1.0 ),\n            smin(\n\t        \tdistSphere( point, vec3( -mod( iTime, 4.0 ) * 4.0, sin( iTime / 2.0 * pi ) * 3.0, sin( iTime / 8.0 * 6.0 * pi ) * 3.0 ), 1.0 ),            \n            smin(\n\t        \tdistSphere( point, vec3( -sin( iTime / 8.0 * 6.0 * pi ) * 3.0, sin( iTime / 2.0 * pi ) * 3.0, -mod( iTime, 4.0 ) * 4.0 + 16.0 ), 1.0 ),\n            smin(\n\t        \tdistSphere( point, vec3( -sin( iTime / 8.0 * 6.0 * pi ) * 3.0, sin( iTime / 2.0 * pi ) * 3.0, -mod( iTime, 4.0 ) * 4.0 ), 1.0 ),            \n            smin(\n\t        \tdistSphere( point, vec3( sin( iTime / 8.0 * 6.0 * pi ) * 3.0, sin( iTime / 2.0 * pi ) * 3.0, mod( iTime, 4.0 ) * 4.0 - 16.0 ), 1.0 ),\n            smin(\n\t        \tdistSphere( point, vec3( sin( iTime / 8.0 * 6.0 * pi ) * 3.0, sin( iTime / 2.0 * pi ) * 3.0, mod( iTime, 4.0 ) * 4.0 ), 1.0 ),\n            smin(\n\t        \tdistSphere( point, vec3( mod( iTime, 4.0 ) * 4.0 - 16.0, sin( iTime / 2.0 * pi ) * 3.0, -sin( iTime / 8.0 * 6.0 * pi ) * 3.0 ), 1.0 ),\n        \t smin(\n\t\t\t\tdistSphere( point, vec3( mod( iTime, 4.0 ) * 4.0, sin( iTime / 2.0 * pi ) * 3.0, -sin( iTime / 8.0 * 6.0 * pi ) * 3.0 ), 1.0 ),\n\t\t\t\t\tdistSphere( point, vec3( 0.0, 1.0, 0.0 ), 1.0 ),\n                2.0 ), 2.0 ), 2.0 ), 2.0 ), 2.0 ), 2.0 ), 2.0 ), 2.0 ),\n        distHalfSpace( point, vec3( 0.0, -1.0, 0.0 ), vec3( 0.0, 1.0, 0.0 ) ),\n        3.0\n    );\n}\n\nmat4 rotationMatrix( float angle )\n{\n    return mat4(\n        cos( angle ), 0.0, sin( angle ), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin( angle ), 0.0, cos( angle ), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 translationMatrix( vec3 translation )\n{\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        translation.x, translation.y, translation.z, 1.0 );\n}\n\nRayIntersection traceRay( vec3 start, vec3 dir )\n{\n    RayIntersection result;\n\tfloat t = 0.0;\n    \n    \n    for( int i = 0; i < 1024; ++i )\n    {\n        result.point = start + dir * t;\n        result.dist = dist( result.point );\n        \n        if( result.dist < EPSILON * 0.9 || t > MAX_T )\n        {\n            break;\n        }\n        \n        t += result.dist;\n    }\n    \n    result.t = t;\n    \n    return result;\n}\n\nfloat traceShadowRay( vec3 start, vec3 lightPos )\n{\n\tconst float k = 20.0;\n    \n\tfloat res = 1.0;\n    \n    vec3 dir = normalize( lightPos - start );\n    \n\tfloat maxDist = length( lightPos - start );\n\t\n\tfloat t = EPSILON * 20.0;\n    \n\tfor( int i = 0; i < 512; ++i )\n    {\n\t\tfloat d = dist( start + dir * t );\n        \n        if( d < EPSILON )\n        {\n            return 0.0;\n        }\n        \n        if( t > maxDist )\n        {\n            break;\n        }\n        \n\t\tres = min( res, k * d / t );\n        \n\t\tt += d;\n\t}\n    \n    return res;\n}\n\nvec3 computeNormal( vec3 point )\n{\n    vec2 h = vec2( DELTA, 0.0 );\n    return normalize( vec3(\n\t    ( dist( point + h.xyy ) - dist( point - h.xyy ) ) / DELTA,\n\t    ( dist( point + h.yxy ) - dist( point - h.yxy ) ) / DELTA,\n\t    ( dist( point + h.yyx ) - dist( point - h.yyx ) ) / DELTA\n    ) );\n}\n\nvec3 getPosition()\n{\n    return texture( iChannel1, vec2( 0.5, 0.5 ) / iChannelResolution[ 1 ].xy ).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 start = vec3( 0.0, 0.0, 0.0 );\n    vec3 end = normalize( vec3( ( fragCoord.xy - iResolution.xy / 2.0 ) / max( iResolution.x, iResolution.y ) * 2.0, 1.0 ) );\n    \n    vec3 lightPos = readVec3( LOC_LIGHT_POS );\n    vec3 camPos = readVec3( LOC_CAM_POS );\n    vec3 camUp = readVec3( LOC_CAM_UP );\n    vec3 camDir = readVec3( LOC_CAM_DIR );\n            \n    vec3 camLeft = cross( camUp, camDir );\n    \n    mat4 transform = mat4(\n        camLeft.x, camLeft.y, camLeft.z, 0.0,\n        camUp.x, camUp.y, camUp.z, 0.0,\n        camDir.x, camDir.y, camDir.z, 0.0,\n        camPos.x, camPos.y, camPos.z, 1.0 );\n    \n    start = ( transform * vec4( start, 1.0 ) ).xyz;\n    end = ( transform * vec4( end, 1.0 ) ).xyz;\n    vec3 dir = end - start;\n    \n    float colorFactor = 1.0;\n    float reflection = 0.3;\n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n    \n    for( int r = 0; r < 3; ++r )\n    {\n        RayIntersection inter = traceRay( start, dir );\n        \n        if( inter.dist < EPSILON)\n    \t{\n            vec3 normal = computeNormal( inter.point );\n        \n        \tvec3 lightVec = normalize( lightPos - inter.point );\n            vec3 eyeVec = normalize( start - inter.point );\n            \n        \tfloat shadowFactor = traceShadowRay( inter.point, lightPos );\n            //float shadowFactor = 1.0;\n        \tfloat diffuse = max( 0.0, dot( lightVec, normal ) );\n        \tfloat specular = pow( max( 0.0, dot( lightVec, reflect( -eyeVec, normal ) ) ), 30.0 );\n        \tfloat ambient = 0.1;\t        \n\t        //vec3 materialColor = texture( iChannel0, uvMap( inter.point ) ).rgb;\n            vec3 materialColor = normal;\n            \n            vec3 localColor = ( ambient + diffuse * shadowFactor ) * materialColor\n                 \t\t    + specular * shadowFactor * vec3( 1.0, 1.0, 1.0 );\n            \n            localColor = mix( localColor, SKY_COLOR, inter.t / MAX_T );\n            \n            dir = reflect( -eyeVec, normal );\n            start = inter.point + dir * EPSILON * 1.0;\n            color += colorFactor * ( 1.0 - reflection ) * localColor;\n            colorFactor *= reflection;\n        }\n        else\n        {\n            color += colorFactor * SKY_COLOR;\n            colorFactor = 0.0;\n        }\n                \n        if( colorFactor < 0.01 )\n        {\n            break;\n        }\n    }\n    \n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float KEY_LEFT = 37.5 / 256.0;\nconst float KEY_DOWN = 40.5 / 256.0;\nconst float KEY_RIGHT = 39.5 / 256.0;\nconst float KEY_UP = 38.5 / 256.0;\nconst float KEY_Q = 81.5 / 256.0;\n\nconst vec2 LOC_INITIALIZED = vec2( 0.0, 0.0 );\nconst vec2 LOC_CAM_POS = vec2( 1.0, 0.0 );\nconst vec2 LOC_CAM_UP = vec2( 2.0, 0.0 );\nconst vec2 LOC_CAM_DIR = vec2( 3.0, 0.0 );\nconst vec2 LOC_LIGHT_POS = vec2( 4.0, 0.0 );\n\nconst float pi = 3.14159265359;\n\n#define SPEED 0.5\n\nvoid writeValue( vec2 location, vec4 value, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = ( floor( fragCoord.x ) == location.x && floor( fragCoord.y ) == location.y )\n        ? value\n        : fragColor;\n}\n\nvoid writeValue( vec2 location, bool value, inout vec4 fragColor, vec2 fragCoord )\n{\n    writeValue( location, vec4( value ? 1.0 : 0.0, 0.0, 0.0, 0.0 ), fragColor, fragCoord );\n}\n\nvoid writeValue( vec2 location, float value, inout vec4 fragColor, vec2 fragCoord )\n{\n    writeValue( location, vec4( value, 0.0, 0.0, 0.0 ), fragColor, fragCoord );\n}\n\nvoid writeValue( vec2 location, vec2 value, inout vec4 fragColor, vec2 fragCoord )\n{\n    writeValue( location, vec4( value, 0.0, 0.0 ), fragColor, fragCoord );\n}\n\nvoid writeValue( vec2 location, vec3 value, inout vec4 fragColor, vec2 fragCoord )\n{\n    writeValue( location, vec4( value, 0.0 ), fragColor, fragCoord );\n}\n\nbool readBool( vec2 location )\n{\n    return texture( iChannel0, ( location + 0.5 ) / iChannelResolution[ 0 ].xy ).r > 0.5;\n}\n\nfloat readFloat( vec2 location )\n{\n    return texture( iChannel0, ( location + 0.5 ) / iChannelResolution[ 0 ].xy ).r;\n}\n\nvec2 readVec2( vec2 location )\n{\n    return texture( iChannel0, ( location + 0.5 ) / iChannelResolution[ 0 ].xy ).rg;\n}\n\nvec3 readVec3( vec2 location )\n{\n    return texture( iChannel0, ( location + 0.5 ) / iChannelResolution[ 0 ].xy ).rgb;\n}\n\nvec4 readVec4( vec2 location )\n{\n    return texture( iChannel0, ( location + 0.5 ) / iChannelResolution[ 0 ].xy ).rgba;\n}\n\nbool isKeyDown( float key )\n{\n    return texture( iChannel1, vec2( key, 0.25 ) ).r > 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0.0, 0.0, 0.0, 0.0 );\n        \n    float rotY = 6.0 * pi * iMouse.x / max( iResolution.x, iResolution.y );\n    float rotX = clamp( -pi + 4.0 * pi * iMouse.y / max( iResolution.x, iResolution.y ), -pi / 2.0, pi / 2.0 );\n    \n    vec3 lightPos = readVec3( LOC_LIGHT_POS );\n    vec3 camPos = readVec3( LOC_CAM_POS );\n    vec3 camDir = vec3( sin( rotY ) * cos( rotX ), sin( rotX ), cos( rotY ) * cos( rotX ) );\n    vec3 camUp = vec3( -sin( rotY ) * sin( rotX ), cos( rotX ), -cos( rotY ) * sin( rotX ) );\n    bool initialized = readBool( LOC_INITIALIZED );\n\n    if( !initialized )\n    {\n        initialized = true;\n        lightPos = vec3( 0.0, 20.0, 8.0 );\n        camPos = vec3( 5.0, 5.0, 5.0 );\n    }\n    \n    if( isKeyDown( KEY_UP ) )\n        camPos += camDir * SPEED;\n    \n    if( isKeyDown( KEY_DOWN ) )\n        camPos -= camDir * SPEED;\n    \n    if( isKeyDown( KEY_Q ) )\n        lightPos = camPos;\n    \n    writeValue( LOC_INITIALIZED, initialized, fragColor, fragCoord );\n    writeValue( LOC_CAM_POS, camPos, fragColor, fragCoord );\n    writeValue( LOC_CAM_UP, camUp, fragColor, fragCoord );\n    writeValue( LOC_CAM_DIR, camDir, fragColor, fragCoord );\n    writeValue( LOC_LIGHT_POS, lightPos, fragColor, fragCoord );\n}","name":"Buf A","description":"","type":"buffer"}]}