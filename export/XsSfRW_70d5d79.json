{"ver":"0.1","info":{"id":"XsSfRW","date":"1499712391","viewed":487,"name":"Spinning Halos","username":"EcceGratum","description":"simple music visualizer","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["music","audio","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MUSICCHANNEL iChannel0\n#define MUSICTEXWIDTH 512\n#define CONTACT 0.04\n\nconst int iDiskCount = 128; // switch to 64 for performance\nconst float fInnerDisk = 0.003;\nconst float fMinSamplingRate = 1.0 / 1024.0;\n\nconst int iMaxSamples = 64;\n\nconst float fSplitY = 1.0 / float(iDiskCount);\nconst float TexelsPerDisk = 1.0 / float(iDiskCount + 1);\n\n// utils\nvec3 lerp(vec3 x, vec3 y, float s) { return s * (y - x) + x; }\nvec4 lerp(vec4 x, vec4 y, float s) { return s * (y - x) + x; }\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\n// iq\nfloat sdTorus(vec3 p, vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n\treturn hsv2rgb(vec3(h,s,v));\n}\n\nvec3 LUT(float x) {\n    return hsv2rgb(vec3((330.0 / 360.0) - x, 1.0, 1.0));\n}\n\nvec4 And(vec4 A, float MinB, vec3 BColor) {\n    float NewMin = step(MinB, A.x);\n\n    return A * (1.0 - NewMin) + NewMin * vec4(MinB, BColor);\n}\n\nvec4 map(vec3 pos) {\n    // x = minDist\n    // yzw = color\n    vec4 Result = vec4(1e9, 0.0, 0.0, 0.0);\n\n    for(int i = 0; i < iDiskCount; ++i) {\n        float DiskWidth = textureGrad(MUSICCHANNEL, vec2(1.0 - float(i) * TexelsPerDisk, 0.0), vec2(0.0), vec2(0.0)).r;\n\t\tfloat AvoidDisk = (step(DiskWidth, 1e-5)) * 1e9;\n        \n        float DiskY = float(i) * (1.0 / float(iDiskCount)) - 0.5;\n        Result = And(Result, AvoidDisk + sdTorus(pos - vec3(0.0, DiskY, 0.0), vec2(DiskWidth, fInnerDisk)), LUT(DiskWidth));\n    }\n   \n    return Result;\n}\n\nbool HitCylinder(vec3 RayOri, vec3 RayDir) {\n    const float cHalfHeight = 0.575;\n    const float cRadius = 1.05;\n\n    float a = 1.0 - (RayDir.y * RayDir.y);\n    float b = dot(RayOri, RayDir) - (RayOri.y * RayDir.y);\n    float c = dot(RayOri, RayOri) - (RayOri.y * RayOri.y) - (cRadius * cRadius);\n    float h = b * b - a * c;\n    \n    if(h < 0.0) \n        return true;\n    \n    h = sqrt(h);\n    float t1 = (-b - h) / a;\n \n    float y = RayOri.y + t1 * RayDir.y;\n\n    if(abs(y) < cHalfHeight) \n        return false;\n\n    float sy = sign(y);\n    float tp = (sy * cHalfHeight - RayOri.y) / RayDir.y;\n    if(abs(a * tp + b) < h)\n        return false;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    // ray   \n    vec3 vRayDir = vec3(0, 0, 1);\n    vec3 vRayPos = vec3(uv.xy * 2.0, -1.5); \n        \n    vec3 vInter = vRayPos;\n\n    // rotation\n    vec2 um = vec2(3.5 + iChannelTime[0] * 0.05, 1.0);\n    mat2 mx = mm2(um.x * -12.0);\n    mat2 my = mm2(um.y * 12.0); \n    vInter.xz *= mx;\n    vRayDir.xz *= mx;\n    vInter.yz *= my;\n    vRayDir.yz *= my;\n    \n    // early check hit worst cylinder\n    if(HitCylinder(vInter, vRayDir)) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    //\n    vec4 vDstColor = vec4(0.0);\n    \n    float r = 0.0;     \n    for(int iSample = 0; iSample < iMaxSamples; ++iSample)\n    {        \n    \tif(!(vDstColor.a < 0.985 && r < 3.0))\n           break;\n        \n        vec4 R = map(vInter);\n        float l = R.x;\n        \n        const float h = .04;\n        float Contact = step(l, h);\n        float ld = (h - l) * Contact;\n        \n        vDstColor.rgb += ld * R.yzw;\n        vDstColor.a += ld;\n        \n        l = max(l, fMinSamplingRate);\n\n        r += l;            \n\n        vInter.xyz += l * vRayDir;\n    }\n    \n    fragColor = vec4(vDstColor.rgb, 0.0);\n}","name":"Image","description":"","type":"image"}]}