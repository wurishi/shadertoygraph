{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Created by sebastien durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ----------------------------------------------------\n// Very good introduction to relativity (in french)\n// http://podcast.grenet.fr/podcast/introduction-a-la-relativite-restreinte/\n// ----------------------------------------------------\n// Some part of code are adaptation of shaders \n// [Neptunian]    https://www.shadertoy.com/view/Mss3zS\n// [Star Nest]    https://www.shadertoy.com/view/4dfGDM\n// [Phoenix]      https://www.shadertoy.com/view/4d2XR1\n// [Burning Star] https://www.shadertoy.com/view/XdsGDX\n// ----------------------------------------------------\n// Fly over the sun at real speed !\n// Relativistic Doppler effect give a Blue color of sun over 20% of light speed\n// This illustrate how speed reduce the travel distance \n// (for a photon the entier universe is flat in the direction of speed and the age of universe is just 0Âµs)\n// ----------------------------------------------------\n \n\n\n\n// beta = velocity of spaceship / speed of light (possible to control it with mouse also)\n#define BETA 0.8\n\n// Effects comment some if too slow in full screen\n#define SPACE_BACKGROUND_ON\n#define SUN_LAVA_ON\n#define SUN_ERUPTION_ON\n//Much better but not working in all configuration\n#define SUN_3D_SURFACE_ON   \n#define LAYER_2D_ON\n#define globalTime (iTime+28.48)\n\n// Possible speed up of spaceship, but 1 for realistic rendering (1 sec of anim = 1 second for rfeal)\n#define AnimationMoveRatio  1. \n\n// UY Scuti radius = 1708 Solar Radius ! (biggest star known)\n// ... if you have time (fly take 1708 time sur fly of our small sun)\n//#define UY_Scuti\n\n#ifndef UY_Scuti\n\t// in solar radius per second\n\t#define LightSpeed .430735\n\t#define SUN_DENSITY 55.\n// http://en.wikipedia.org/wiki/Solar_rotation // real : 2.692E-6\n\t#define SUN_RAD_PER_S 2.692E-2 \n#else\n\t#define LightSpeed (.430735/1708.)\n\t#define SUN_DENSITY 500.\n\t#define SUN_RAD_PER_S 2.692E-9 // real : ???\n#endif\n\n\n// Optical effect of speed\nconst float gDoppler = 1.;      // Proportion Red/Blueshift rays (reel = 1)\nconst float gIntensity = .5;    // Proportion Solid angle light flux (reel = 1)\nconst float minIntensity = .05; // Intensitee minimum visible apres application de gIntensity (reel = 0)\n\n\n\n// -- Common Tools ----------------------------------------------------\n\nfloat hash(in float n) { return fract(sin(n)*43758.5453123); }\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.-2.*f);\n\tvec2 rg = textureLod(iChannel0, (((p.xy+vec2(37.,17.)*p.z) + f.xy)+.5)/256., -100.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in float r, out float dist, out float edge) {\n\tfloat b = dot(rd,-ro),\n\t\t  d = b*b - dot(ro,ro) + r*r;\n\tif (d < 0.) return false;\n    edge = sqrt(d);\n\tdist = b - edge;\n\treturn dist > 0.;\n}\n\n\n// +------------------------------------------------------+\n// |                  Deep Space Effect                   |\n// +------------------------------------------------------+\n// Star Nest by Kali\n// https://www.shadertoy.com/view/4dfGDM\n\n#ifdef SPACE_BACKGROUND_ON\n\n#define iterations 17\n#define formuparam 0.53\n#define volsteps 6\n#define stepsize 0.1\n#define tile   0.850\n#define brightness 0.0015\n#define darkmatter 1.500\n#define distfading .530\n#define saturation 0.650\n\nvec4 space(in vec3 dir) {\n\tvec3 from=vec3(1.,.5,0.5);\n\t//volumetric rendering\n\tfloat a,pa,s=0.1,fade=1.;\n\tvec3 p,v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tp = from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\ta = pa = 0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\tv+=fade+vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\treturn vec4(v*.02,1.);\t\n}\n\n#else\n\nvec4 space(in vec3 dir) {\n    return vec4(0);\n}\n\n#endif // DEEP_SPACE_ON\n\n\n// +------------------------------------------------------+\n// |                 Sun Eruption Effect                  |\n// +------------------------------------------------------+\n\n#ifdef SUN_ERUPTION_ON\n\n// original by nimitz https://www.shadertoy.com/view/lsSGzy#, slightly modified\n#define ray_brightness 15.\n#define GAMMA 6.\n#define ray_density 3.5\n#define curvature 28.\n#define RED   4.\n#define GREEN 1.\n#define BLUE  .3 \n#define SIZE .04\n\n// FLARING GENERATOR, A.K.A PURE AWESOME\nmat2 m2 = mat2( .8,  .6, -.6,  .8);\nfloat fbm( in vec2 p ) {\t\n\tfloat z=2.,        // EDIT THIS TO MODIFY THE INTENSITY OF RAYS\n\t\t  rz = -.0005; // EDIT THIS TO MODIFY THE LENGTH OF RAYS\n\tp *= .525;         // EDIT THIS TO MODIFY THE FREQUENCY OF RAYS\n\tfor (int i= 1; i<7; i++) {\n\t\trz+= abs((textureLod(iChannel0, p*.01,0.).x-.5)*2.)/z;\n\t\tz = z*2.;\n\t\tp = p*2.*m2;\n\t}\n\treturn rz;\n}\n\nvec4 fireTexture(in vec2 uv, in float t, in float z) {\n\tuv*= curvature*SIZE;\n\tuv.y -= 1.5; //-uv.y;\n    \n\tfloat gam = mix(GAMMA*2., 0., .5+.5*z);\n    float density = ray_density;\n\tfloat \tr = sqrt(dot(uv,uv)), // DISTANCE FROM CENTER, A.K.A CIRCLE\n\t \t\tx = dot(normalize(uv), vec2(.35,0.))+t,\n\t\t\ty = dot(normalize(uv), vec2(.0,.65))+t;\n \n    float val = fbm(vec2(r + y *density, x + density)); // GENERATES THE FLARING\n\tval = smoothstep(gam*.02-.1,ray_brightness+(gam*0.02-.1)+.001, val);\n\tval *= 15.; // sqrt(val); // WE DON'T REALLY NEED SQRT HERE, CHANGE TO 15. * val FOR PERFORMANCE\n\t\n\tvec3 col = val / vec3(RED,GREEN,BLUE);\n\tcol = 1.-col; // WE DO NOT NEED TO CLAMP THIS LIKE THE NIMITZ SHADER DOES!\n    float rad=30. * textureLod(iChannel1, uv, 0.).x; // MODIFY THIS TO CHANGE THE RADIUS OF THE SUNS CENTER\n\tcol = mix(col,vec3(1.), rad - 266.667 * r); // REMOVE THIS TO SEE THE FLARING\n    uv.y=uv.y+1.2;\n    r = length(uv);\n\tcol = col * (1. - clamp(.3*abs(r*r),0.,1.));\n    col = clamp(col,0.,100.);\n\treturn vec4(col, smoothstep(length(col),.0,.2));\n}\n\nstruct Base {\n\tmat3 base;\n\tvec3 o;\n};\n\nBase basis(in vec3 o, in vec3 n) { \n\tBase b;\n    float a=1./(1.+n.z), c=-n.x*n.y*a;\n\tb.base = mat3(n.x, n.y, n.z, 1.-n.x*n.x*a, c, -n.x,  c, 1.-n.y*n.y*a, -n.y);\n\tb.o = o;\n\treturn b;\n}\n\nvec4 colorEruption(in vec3 ro, in vec3 rd, in float time,in float kMax, vec3 refVec, in float h, in vec2 scale) {\n    refVec = normalize(refVec);\n    vec3 pAnim = -(1.+h)*refVec;\n    Base b = basis(pAnim, refVec);\n    \n    vec4 textColor,col = vec4(0);\n    // Chang basis\n\tro = (ro-b.o)*b.base;\n\trd = rd*b.base;\n\n\tfloat k = (abs(rd.z)<.0001) ? -1. : -ro.z/rd.z;   // intersection avec plan y=0; dans base du fire\n    float dk = abs(.003/rd.z);\n    vec3 p = ro + k*rd;\n    if (k>0. && abs(p.x)<.1*scale.x && abs(p.y)<.1*scale.y) {\n        k = max(0., k-13.*dk); \n        float tSun = 10.*scale.x -(time)*.04;\n        for (int i=0;i<26;i++) {\n            if (k>kMax) break;\n            p = ro + k*rd;\n            textColor = fireTexture(scale*p.yx, tSun, .75*float(i)*p.z/rd.z);\n            col += .08*textColor;// + col*(1.-textColor.a) + textColor*textColor.a\n            k+=dk;\n        }\n    }\n\treturn col;\n}\n\n#endif\n\n\n// +------------------------------------------------------+\n// |                  Sun Lava effect                     |\n// +------------------------------------------------------+\n\nfloat SunTwinklingFactor;\n\n\n#ifdef SUN_LAVA_ON\n\nconst mat3 msun = mat3(0., .8, .6, -.8, .36, -.48, -.6, -.48, .64);\n\nfloat smoothNoise(in vec3 q){\n\tfloat f  = .5000*noise(q); q=msun*q*2.01;\n          f += .2500*noise(q); q=msun*q*2.02;\n          f += .1250*noise(q); //q=msun*q*2.03;\n       //   f += .0625*noise(q);\n\treturn f;\n}\n\n#define NB_LUT 4\n\n// TODO posibilitee de precalculer les (1./LUT_DIST[i+1]-LUT_DIST[i]) pour gagner un peu (taritement appele souvent)\nvec3 mapping(float dist, float vmin, float vmax, mat4 LUT, vec4 LUT_DIST) {\n\tfloat distLut = (dist-vmin)/vmax;\n    vec3 c = vec3(0);\n\tfor(int i=0;i<NB_LUT;++i) \n        if(distLut<LUT_DIST[i+1]){\n            c = mix(LUT[i],LUT[i+1], (distLut-LUT_DIST[i])/(LUT_DIST[i+1]-LUT_DIST[i])).xyz;\n            break;\n        }\n\treturn c;\n}\n\nconst mat4 LAVA_COLOR  = mat4(0.,0.,0.,0.,  .7,.3,.1,1.,  .9,.6,.3,1.,  2.,3.9,2.5,1.);\nconst vec4 LAVA_COLOR_DIST = vec4(0.,.35,.55,1.);\n//const mat4 LAVA_COLOR2  = mat4(0.,0.,0.,0.,  0.,0.,0.,0.,  1.4,1.4,1.1,1.,  0.6,0.5,0.3,1.);\n//const vec4 LAVA_COLOR_DIST2 = vec4(0.,.45,.55,1.);\n\nvec3 getSunColor(in vec3 p, in float time) {\n    float lava = smoothNoise((p+vec3(time*.01))*SUN_DENSITY );\n\tvec3 color = mapping(1. - sqrt(lava), 0.,1., LAVA_COLOR, LAVA_COLOR_DIST);\n\tcolor += color*color;\n// With white area, but 2 time slower \n//    float lava2 = smoothNoise((p+vec3(time*.0025))*SUN_DENSITY*.12 );\n//    vec3 color2 = mapping(lava2*lava2, 0.,1., LAVA_COLOR2, LAVA_COLOR_DIST2);\n//\tcolor += .5*color2;\n    return SunTwinklingFactor*color; // todo: le faire sur une constante\n}\n\n#else\n\nvec3 getSunColor(in vec3 p, in float time) {\n    return vec3(1,.8,.4);\n}\n\n#endif // SUN_LAVA_ON\n\n\n// +----------------------------------------+\n// |           VOLUMIC SUN SURFACE          |\n// +----------------------------------------+\n\nconst float VOLUMIC_SURFACE_TICKNESS  = .018; //.023;\n\n\n#ifdef SUN_3D_SURFACE_ON\n\nconst int   VOLUMIC_SURFACE_NB_STEP   = 40;//70;\nconst float VOLUMIC_SURFACE_RAY_STEP  = .0033; //.0023;\nconst float VOLUMIC_SURFACE_INTENSITY = .04; //.022;\n\nvec4 getLightRays(vec3 ro, vec3 rd, in float time) {\n\tvec3 p = vec3(0.0);\n \tfloat edge, dist, r = 1. + VOLUMIC_SURFACE_TICKNESS;\n\tbool hit = intersectSphere(ro - p, rd, r, dist, edge);\n\tvec2 uv;\t\n\tvec4 sampleCol, c = vec4(0);\n\tif (hit) {\n\t\tvec3 pos = ro + rd*dist;\n        float light, d, rout;\n        \n\t\t// ray-march into volume\n\t\tfor(int i=0; i<VOLUMIC_SURFACE_NB_STEP; i++) {\n            d = length(pos);\n            if (d<1. || d>r+.001 || c.a>0.95 ) break;\n  \t\t\t\n            sampleCol.rgb = /*getSunColor(pos); */ vec3(.5,.01,.08)+getSunColor(normalize(pos), time);\n            light = length(sampleCol.rgb);\n            //---------------\n            rout = 1.+ VOLUMIC_SURFACE_TICKNESS*clamp(light*light,0.,1.);\n           // if (d<rout /*&& d>1.*/) {\n\t\t\tsampleCol.a = light*(rout-d)/(rout-1.);\n\t\t\tsampleCol.a *= sampleCol.a; \n\t\t\tsampleCol.rgb *= sampleCol.a;\t\t\t\t\n\t\t\tc += VOLUMIC_SURFACE_INTENSITY*sampleCol*(1. - c.a);\n        //    }\n\t\t\tpos += rd*VOLUMIC_SURFACE_RAY_STEP;\n\t\t}\n\t}\t\n\treturn c;\n}\n\n#endif // SUN_3D_SURFACE_ON\n\n\n\n// +----------------------------------------+\n// |         CLASSICAL RAY TRACING          |\n// +----------------------------------------+\n\n\nvec4 render(in vec3 ro, in vec3 rd, in float time) {\n\t// Rotate view to integrate sun rotation \n#ifdef SUN_RAD_PER_S\n    float cosSunRot = cos(1.6+time*SUN_RAD_PER_S), \n\t\t  sinSunRot = sin(1.6+time*SUN_RAD_PER_S);\n    mat2 rotSun = mat2(cosSunRot, sinSunRot, -sinSunRot, cosSunRot);\n    vec3 rdSpace = rd.yzx;\n    ro.zx *= rotSun;\n    rd.zx *= rotSun;\n#endif\n\n    float dist, edge;\n    vec4 color;\n\n    if (intersectSphere(ro, rd, 1., dist, edge)) {\n        vec3  pos = ro+rd*dist,\n        \t  nor = normalize(pos);\n        float lDif = clamp(dot(nor, -rd), .01, 1.),\n\t\t\t  a = smoothstep(0., .5, sqrt(edge)); \n        vec3 oCol = getSunColor(pos, time);\n        oCol = mix(oCol, vec3(1.8, .4, .4), 1.-a*.95); // atmosphere\n        oCol = oCol*(.5+ .5*lDif);\n    \tcolor = vec4(oCol, a);\n    } else {\n        color = space(rdSpace);\n        dist = 1000.;\n    }\n    \n    if (color.a<1.0) {\n\t\tcolor = vec4(mix(space(rdSpace).rgb, color.rgb, color.a), 1.0);\n\t}   \n    \n// Sun special effects -------------------------------------------\n    \n#ifdef SUN_ERUPTION_ON\n    vec4 textColor = colorEruption(ro,rd,time, dist, vec3(-.4,.1,.35), .12, vec2(3.,6.));\n    vec4 textColor2 = colorEruption(ro,rd,time, dist, vec3(.7,-1,0), .2, vec2(6.,4.1));\n    color = color*(1.-.3*textColor.a) + .5*textColor*textColor.a;\n    color = color*(1.-.3*textColor2.a) + .5*textColor2*textColor2.a;\n#endif\n    \n#ifdef SUN_3D_SURFACE_ON\n    vec4 textColor3 = getLightRays(ro, rd, time);\n    color = color*(1.-.3*textColor3.a) + .5*textColor3*textColor3.a;\n#endif\n    \n\treturn color;\n}\n\n\n\n// +------------------------------------------------------+\n// |                 Relativistic Kit                     |\n// +------------------------------------------------------+\n\n// Wavelengths\n#define lUltraViolet    340.0\n#define lBlue           460.0\n#define lGreen          520.0\n#define lRed            700.0\n#define lInfraRed       1000.0\n\nfloat initRayForSpeed(in vec3 ro, in vec3 rd, in vec3 velocity, out vec3 ray, out float intensity, out float relativeTime) {\n    float beta = length(velocity), // = (velocity of observer) / (speed of light)\n    \t  gamma = 1./sqrt(1. - beta*beta);\n \tif (beta == 0.) { // No speed => classical case\n        ray = rd;\n        intensity = 1.;\n\t\trelativeTime = globalTime;\n        return 1.;\n    }\n\n  // - Relative time for non moving scene  ------------------- \n\trelativeTime = gamma*globalTime;\n\n  // - Angular Compression -----------------------------------\n  // http://en.wikipedia.org/wiki/Relativistic_aberration  \n\tvec3 vn = normalize(velocity); \t// Velocity normal\n\tfloat cosa = dot(rd,vn), \t\t// Length of parallel component to velocity\n\t\t  cosb = (cosa - beta) / (1. - cosa*beta);\n\tvec3 p = rd - cosa*vn;   \t\t// Perpendicular component to velocity\n    ray = cosb*vn + sqrt(1.-cosb*cosb)*normalize(p); \n\n  // - The Intensity Effect ---------------------------------\n    intensity = gamma*(1. - beta*cosb)*(1. - beta*cosb);\n    intensity = 1. + (intensity - 1.)*gIntensity; // Partial intensities for clarity\n\n  // - The Doppler Effect -----------------------------------\n  // http://en.wikipedia.org/wiki/Relativistic_Doppler_effect\n    return (gDoppler == 0.) ? 1. : gamma*(1. - beta*cosb);\n}\n\nfloat shiftColor(in float sb, in vec3 c, in float cuv, in float cir) {\n    if(sb < lUltraViolet) return cuv * sb / lUltraViolet;\n    if(sb < lBlue)        return (c.b - cuv) * (sb - lUltraViolet) / (lBlue - lUltraViolet) + cuv;\n    if(sb < lGreen)       return (c.g - c.b) * (sb - lBlue)        / (lGreen - lBlue)       + c.b;\n    if(sb < lRed)         return (c.r - c.g) * (sb - lGreen)       / (lRed - lGreen)        + c.g;\n    if(sb < lInfraRed)    return (cir - c.r) * (sb - lRed)         / (lInfraRed - lRed)     + c.r;\n    return (lInfraRed / sb) * cir;\n}\n\nvec3 relativisticRayTracing(in vec3 ro, in vec3 rd, in vec3 velocity) {\n    float relativeTime; // Relative time for non moving objects\n    vec3 r;\t      \t\t\t// New ray\n    float doppler;   \t\t// Spectrum shift\n    float illumination, intensity;\n\n// - Shift ray ------------------------------------------------------------\n    doppler = initRayForSpeed(ro, rd, velocity, r, intensity, relativeTime);  \n    \n///////////////////////////////////////////////////////////////////////////////////////\n    // Do classical RayTracing or RayMarching here   :)\n    vec3 c = render(ro,r,relativeTime).xyz;\n    \n///////////////////////////////////////////////////////////////////////////////////////\n    \n// - Dimming + Spectrum shift ---------------------------------------------\n    if (gIntensity != 0. && length(c) > minIntensity) {\n        c = clamp(c/intensity, minIntensity, 100.);\n    }\n    if (gDoppler != 0.) {\n\t    doppler = 1. + (doppler - 1.) * gDoppler;\n        float cuv = (0.5*c.b + 0.25*c.g + 0.125*c.r), // ultraviolet\n        \t  cir = (0.5*c.r + 0.25*c.g + 0.125*c.b); // infrared\n        return vec3 (shiftColor(lRed/doppler,   c, cuv, cir), // Shifted wavelengths\n        \t\t\t shiftColor(lGreen/doppler, c, cuv, cir),\n        \t\t     shiftColor(lBlue/doppler,  c, cuv, cir));\n    } else {\n        return c;\n    }\n}\n\n\n// +------------------------------------------------------+\n// |                     2D elt                           |\n// +------------------------------------------------------+\n\n#ifdef LAYER_2D_ON      \n\nfloat sdCircle( vec2 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdEllipse( vec2 p, in vec2 ab ) {\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n    float c = (m2 + n2 - 1.)/3.; \n\tfloat c3 = c*c*c;\n    float d = c3 + m2*n2, q = d + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.) {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    } else {\n        float h = 2.0*m*n*sqrt(d);\n        float s = sign(q+h)*pow(abs(q+h), 1./3.);\n        float u = sign(q-h)*pow(abs(q-h), 1./3.);\n        float rx = -s - u - c*4. + 2.*m2;\n        float ry = (s - u)*sqrt(3.);\n        float rm = sqrt(rx*rx + ry*ry);\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.*g/rm - m)/2.;\n    }\n    float si = sqrt(1. - co*co);\n    vec2 closestPoint = vec2(ab.x*co, ab.y*si);\t\n    return length(closestPoint - p) * sign(p.y-closestPoint.y);\n}\n\n\nfloat udRoundBox(vec2 p, vec2 b, float r) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sunIcon(vec2 p, float s, float k) {\n    vec2 ab = vec2(s*k,s);\n    float d = sdEllipse(p,ab);\n    return d;\n}\n\nfloat spaceshipIcon(in vec2 p) {\n    p.x+=1.5;\n    return min(sdEllipse(p,vec2(3, 1.35)), \n           min(sdEllipse(p-vec2(-2.7,1.125), vec2(1.65, .75)),\n               sdEllipse(p-vec2(-2.7,-1.125), vec2(1.65, .75))));\n}\n\nfloat clock(in vec2 p, in float r, in float time) {\n    time *= -1./12.;\n    float s = sin(6.28*time), c = cos(6.28*time);\n    vec2 p1 = p*mat2(c,s,-s,c);\n    float d = udRoundBox(p1-vec2(r*.35,0),vec2(r*.35,0),.8);\n    s = sin(12.*6.28*time), c = cos(12.*6.28*time);\n    p1 = p*mat2(c,s,-s,c);\n    d= min(d, udRoundBox(p1-vec2(r*.5,0),vec2(r*.5,0),.8));\n    return d;\n}\n\nvec3 draw2D(vec2 uv, vec3 cScreen, float gamma, float xstart, float xend, float sx) {\n    if (gamma > 100.) { \n        return cScreen;\n    } else {\n        \n        float xdist = 9.5*abs(xend-xstart)/gamma;\n        xstart = 9.5*abs(xstart/gamma);\n        \n        vec2 p = uv*150.;\n        float s = 300.;\n        vec3 cFill, cBack = cScreen; \n        float d,d2, a0,a1;\n        d = sdCircle(p-vec2(-70.,-65) ,6.);\n        cFill = .1+cScreen*.5;\n        d = min(d,sdCircle(p-vec2(-45.,-65) ,6.));\n        a1 = clamp(max(d-.35, 0.0)*iResolution.x/s, 0.0, 1.0);\n        a0 = clamp(max(abs(d-.35)-.25, 0.0)*iResolution.x/s, 0.0, 1.0);\n        cBack = clamp(mix(cBack, a0*cFill, (1.0-a1)),0.,1.);\n        d = clock(p-vec2(-70,-65), 6., globalTime);\n        d2 = clock(p-vec2(-45,-65), 6., globalTime*gamma);\n        \n        p += vec2(-50,70);\n        d = min(d, udRoundBox(p+vec2(xstart-xdist*.5,-11.5), vec2(xdist*.5,0.), .2));\n        d = min(d, spaceshipIcon(p+vec2(mix(xstart, xstart+xdist, sx),-14.5)));   \n        d2 = min(d2, sunIcon(p, 9.5,1./gamma));\n        cFill = (d2<d ? vec3(1.,.8,.1) : vec3(0,1.,0));\n        d = min(d, d2);\n        a1 = clamp(max(d-.35, 0.0)*iResolution.x/s, 0.0, 1.0);\n        a0 = clamp(max(abs(d-.35)-.25, 0.0)*iResolution.x/s, 0.0, 1.0); \n        return mix(cBack, a0*cFill, (1.0-a1));\n    }\n}\n\n#endif // LAYER_2D_ON      \n\n// +------------------------------------------------------+\n// |                       Main                           |\n// +------------------------------------------------------+\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool isMouseCtrl = (iMouse.y>0.);\n\n    \n// - Physics -----------------------------    \n    float beta = clamp( (isMouseCtrl ? iMouse.y/iResolution.y : BETA), 0.,1.),\n\t\t  gamma = 1./sqrt(1. -beta*beta),\n\t\t  v = beta*LightSpeed*AnimationMoveRatio;  // Velocity\n    vec3 color;\n    \n    //float cinemascope : 2.35 /1;\n\n    if (fragCoord.x/iResolution.x > .97) {\n    \tcolor = (fragCoord.y/iResolution.y < beta) ? mix(vec3(.3,1,.3), vec3(1,0,0), beta) : vec3(.3); \n    \n    } else {\n        float relativeTime = gamma*globalTime; // Relative time for the planet\n        SunTwinklingFactor = (1.+.03*cos(5.*relativeTime+2.*hash(relativeTime)));\n\n    // - Camera ------------------------------   \n        vec2 q = (fragCoord.xy / iResolution.xy) - .5;\n        q.x *= (iResolution.x/iResolution.y);\n\n        float height = 1.001*(1.+VOLUMIC_SURFACE_TICKNESS);\n        float shipX, xstart, xend;\n       \n        if (iMouse.w>0.) {\n            shipX = 7.-8.*(iMouse.x/iResolution.x);\n            xstart = 7.; xend = -1.;\n        } else {\n    #ifndef UY_Scuti \n            shipX = mod(6.-gamma*v*globalTime, 6.)-1.;  // gamma*v because of length contraction\n            xstart = 5.;\n            xend = -1.;\n    #else\n            shipX = mod(1.5-gamma*v*globalTime, 1.5)-.5; // gamma*v because of length contraction\n            xstart = 1.;\n            xend = -.5;\n    #endif        \n        }\n        \n        vec3 ro = vec3(shipX, height, 0);\n        float a = -.5, ca = cos(a), sa=sin(a); // Small rotation to watch the planet\n        ro.yz *= mat2(ca,sa,-sa,ca);\n        \n        vec3 ww = normalize(vec3(-1.,0,0));\n        a = .15; ca = cos(a); sa=sin(a); // Small rotation to watch the planet\n        ww.zx *= mat2(ca, sa,-sa,ca);\n\n        vec3 uu = normalize(cross(ww, vec3(0,1,0))),\n             vv = normalize(cross(uu, ww));\n\n    // - Render scene -----------------------    \n        vec3 rd = normalize( q.x*uu + q.y*vv + 1.5*ww );\n        \n        color = relativisticRayTracing(ro, rd, vec3(-1,0,0)*beta);\n#ifdef LAYER_2D_ON    \n        if (fragCoord.y/iResolution.y < .15) {\n        \tcolor = draw2D(q, color.rgb, gamma, xstart, xend, (xstart-shipX)/(xend-xstart));\n        }\n#endif\n    }\n    \n   \n    fragColor = vec4(clamp(color,0.,1.),1);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtXGR8","date":"1418596162","viewed":1324,"name":"[NV15] Relative Time/Length","username":"iapafoto","description":"[MOUSE] : Y change speed / X change position\nIllustrate dilatation of time and length at hight speed  (Rq: 1 second of anim = 1 real second for traveler)\nIllustrate also optical effect of speed - Try it in full screen !","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["sun","fire","space","relativistic","relativity"],"hasliked":0,"parentid":"","parentname":""}}