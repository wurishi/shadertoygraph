{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//-------------------------------------------------------------\n// Thanks to Beautypi (Iq and Pol Jeremias) for this wonderful sharing environment\n//-------------------------------------------------------------\n// Raymarching techniques by Iq\n//\t\thttps://iquilezles.org/www/articles\n//\t\tThanks a lot for all your papers and the clear explanations :)\n//-------------------------------------------------------------\n// Distance functions\n//\t\thttps://iquilezles.org/articles/distfunctions\n//\t\thttps://www.shadertoy.com/view/Xds3zN\n//-------------------------------------------------------------\n// CookTorrance shader:\n// \t\t- Background physics and math of shading (SIGGRAPH2013 papers)\n//      - Physically Based Shading at Pixar (SIGGRAPH2013 papers)\n//\t\t- Fresnel value set to 1.0 for all materials, I've played with\n//\t\t  roughness and reflectivity to achieve the needed result\n//-------------------------------------------------------------\n// Music only for atmosphere:\n//\t\tMost geometric person by Noby\n//-------------------------------------------------------------\n// Photo inspiration: \n//\t\thttp://instagram.com/p/tQ9EaizRIC by Roland Levesque\n//-------------------------------------------------------------\n\n//STRUCTS -----------------------------------------------------\n//Materials----------------------------------------------------\nstruct material \n{\n\tvec3\t\talbedo;\t\t\t\t// Albedo color\n\tfloat\t\troughness;\t\t\t// Roughness\n\tfloat\t\treflectivity;\t\t// Fraction of diffuse reflection\n};\n\n//RayIntersect-------------------------------------------------\nstruct rayIntersect \n{\n\tvec3\t\tmPos;\t\t\t\t//Pos\n\tvec3\t\tnor; \t\t\t\t//Normal\n\tfloat\t\tdist;\t\t\t\t//Distance\n\tmaterial\tmat; \t\t\t\t//Object material\n};\n//-------------------------------------------------------------\n\n//Lights ------------------------------------------------------\nstruct lightTube\n{\n\tvec3 tubeStart;\n    vec3 tubeEnd;\n\tvec3 color;\n};\n//-------------------------------------------------------------\n//END STRUCTS -------------------------------------------------\n\n//DEFINE VALUES -----------------------------------------------\n#define PI 3.14159\n\n#define EPSILON\t\t0.000001\t//min dist distance\n#define FARCLIP \t35.0\t\t//Far clip distance\n\n#define AMBIENT_COLOR vec3(1.0, 0.94510, 0.89412)\n\n#define BOXROOM_SIZE vec3(4.1, 2.6, 14.5)\n#define BOXROOM_POS vec3(0.0, 2.9, -9.5)\n\n#define ELEVATOR_SIZE vec3(0.3, 2.15, 1.0)\n#define ELEVATOR_POS vec3(1.4, -2.85, 2.0)\n\n#define TOP_ELEVATORBOX_SIZE vec3(0.02, 0.05, 1.0)\n#define TOP_ELEVATORBOX_POS vec3(1.4, -0.65, 2.0)\n    \n#define EXITDOOR_SIZE vec3(1.1, 2.95, 0.2)\n#define EXITDOOR_POS vec3(3.2, 2.95, -24.0)\n\n#define EXITDOOR_HSTROKE_SIZE vec3(1.1, 0.05, 0.05)\n#define EXITDOOR_HSTROKE_POS vec3(3.4, 4.3, -24.0)\n#define EXITDOOR_VSTROKE_SIZE vec3(0.07, 2.95, 0.05)\n#define EXITDOOR_VSTROKE_POS vec3(2.2, 2.95, -24.0)\n\n#define EXITDOOR_WINDOW_SIZE vec3(0.1, 0.5, 0.1)\n#define EXITDOOR_WINDOW_POS vec3(2.75, 3.25, -24.2)\n    \n#define PLINTHE_SIZE vec3(4.15, 0.095, 14.5)\n#define PLINTHE_POS vec3(0.0, 0.41, -9.5)\n\n#define Square_SIZE vec3(0.55, 0.55, 0.2)\n#define SquareL1_Front1 vec3(0.675, 4.6, -23.3)\n#define SquareL1_Front2 vec3(-0.475, 4.6, -23.3)\n#define SquareL1_Front3 vec3(-1.625, 4.6, -23.3)\n#define SquareL1_Front4 vec3(-2.775, 4.6, -23.3)\n\n#define SquareL2_Front1 vec3(0.675, 3.45,  -23.3)\n#define SquareL2_Front2 vec3(-0.475, 3.45, -23.3)\n#define SquareL2_Front3 vec3(-1.625, 3.45, -23.3)\n#define SquareL2_Front4 vec3(-2.775, 3.45, -23.3)\n\n#define SquareL3_Front1 vec3(0.675, 2.3,  -23.3)\n#define SquareL3_Front2 vec3(-0.475, 2.3, -23.3)\n#define SquareL3_Front3 vec3(-1.625, 2.3, -23.3)\n#define SquareL3_Front4 vec3(-2.775, 2.3, -23.3)\n\n#define SquareL4_Front1 vec3(0.675, 1.15,  -23.3)\n#define SquareL4_Front2 vec3(-0.475, 1.15, -23.3)\n#define SquareL4_Front3 vec3(-1.625, 1.15, -23.3)\n#define SquareL4_Front4 vec3(-2.775, 1.15, -23.3)\n\n//TOP squares\n#define SquareTOP_SIZE vec3(0.6, 0.1, 0.6)    \n#define SquareTOPL1_POS vec3(2.5, 0.01, 0.125)\n\n//Materials\n#define MarbleMatID 1.0\n#define MarbleMatAlbedo vec3(0.78431, 0.78431, 0.82353)\n#define MarbleMatRoughness 0.4\n#define MarbleMatReflectivity 0.35\n    \n#define BlackMarbleMatID 2.0\n#define BlackMarbleMatAlbedo vec3(0.35294, 0.34118, 0.40177)\n#define BlackMarbleMatRoughness 0.35\n#define BlackMarbleMatReflectivity 0.7\n    \n#define TopWhiteMatID 3.0\n#define TopWhiteMatAlbedo vec3(0.9)\n#define TopWhiteMatRoughness 0.175\n#define TopWhiteMatReflectivity 0.5\n\n#define BlackRoughMatID 4.0\n#define BlackRoughMatAlbedo vec3(0.055, 0.06, 0.065)\n#define BlackRoughMatRoughness 0.7\n#define BlackRoughMatReflectivity 0.95\n\n#define SquareOrangeMatID 5.0\n#define SquareOrangeMatAlbedo vec3(1.0, 0.32549, 0.10196)\n\n#define ElevBlackMatID 6.0\n#define ElevBlackMatAlbedo vec3(0.025)\n#define ElevBlackMatRoughness 0.9\n#define ElevBlackMatReflectivity 0.45\n    \n#define MetalMatID 7.0\n#define MetalMatAlbedo vec3(0.05)\n#define MetalMatRoughness 0.9\n#define MetalMatReflectivity 0.3\n\n#define SquareWhiteMatID 8.0\n#define SquareWhiteMatAlbedo vec3(1.0)\n\n#define CeilMatAlbedo vec3(0.1)\n#define CeilMatReflectivity 0.75\n\n//Map scene-----------------------------------------------------\n//Distance functions by Iq -------------------------------------\n// https://iquilezles.org/articles/distfunctions\n// https://www.shadertoy.com/view/Xds3zN\n//--------------------------------------------------------------\n//Union\nvec2 OperationUnion(vec2 dist1, vec2 dist2)\n{\n    return (dist1.x < dist2.x) ? dist1 : dist2;\n}\n\nfloat OpU(float dist1, float dist2)\n{\n\treturn min(dist1, dist2);\n}\n\nvec2 OperationSoustraction(vec2 dist1, vec2 dist2)\n{\n    if (-dist2.x > dist1.x)\n        return vec2(-dist2.x, dist2.y);\n\n    return dist1;\n}\n\nfloat OpS(float dist1, float dist2)\n{\n\treturn max(-dist2, dist1);\n}\n\nfloat OpI(float dist1, float dist2)\n{\n\treturn max(dist1, dist2);\n}\n\nvec3 OperationRepetition(vec3 mPos, vec3 rep)\n{\n    return mod(mPos, rep) - 0.5 * rep;\n}\n\nfloat UnsignedDistBox(vec3 mPos, vec3 boxSize)\n{\n  return length(max(abs(mPos) - boxSize, 0.0));\n}\n\nfloat SignedDistBox(vec3 mPos, vec3 boxSize)\n{\n  vec3 d = abs(mPos) - boxSize;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat SignedDistSphere(vec3 mPos, float rad)\n{\n    return length(mPos)- rad;\n}\n\n//--------------------------------------------------------------\n\nvec2 SceneDistance(vec3 mPos)\n{\n    vec2 room = vec2(-SignedDistBox(mPos - BOXROOM_POS, BOXROOM_SIZE), MarbleMatID);\n    \n\t// Plinthe\n    vec2 plinthe = vec2(SignedDistBox(mPos - PLINTHE_POS, PLINTHE_SIZE), BlackRoughMatID);\n    vec2 res = OperationSoustraction(room, plinthe);\n\n    // ************************************************ //\n    // Kind of \"plane tree\" in order to avoid calculate //\n    //          the useless parts of the scene          //\n    // ************************************************ //\n    // Right wall\n    if(mPos.x < -3.9)\n    {\n        float exclusionBox = SignedDistBox(mPos - vec3(0.0, 2.9, -15.0), vec3(4.5, 2.6, 6.0));\n        // Elevator box above\n        float elevatorStuff = OpI(exclusionBox, SignedDistBox(OperationRepetition(mPos - TOP_ELEVATORBOX_POS,\n                                                                                  vec3(11.0, 10.0, 3.5)),\n                                                              TOP_ELEVATORBOX_SIZE));\n        // Elevator call button\n        elevatorStuff = OpU(elevatorStuff, OpI(exclusionBox, \n                                               SignedDistBox(OperationRepetition(mPos - vec3(1.4, -3.0, 4.0),\n                                                                                 vec3(11.0, 11.0, 3.5)),\n                                                             vec3(0.05, 0.5, 0.125))));\n\n        res = OperationUnion(res, vec2(elevatorStuff, MetalMatID));\n\n        // Elevator floors\n        float elevatorFloor = OpI(exclusionBox, SignedDistBox(OperationRepetition(mPos - vec3(1.4, -0.75, 2.0),\n                                                                                  vec3(11.0, 11.0, 3.5)),\n                                                              vec3(0.01, 0.15, 0.3)));\n        res = OperationUnion(res, vec2(elevatorFloor, ElevBlackMatID));\n\n        float elev = OpI(exclusionBox, SignedDistBox(OperationRepetition(mPos - ELEVATOR_POS,\n                                                                         vec3(11.5, 10.0, 3.5)),\n                                                     ELEVATOR_SIZE));\n        res = OperationSoustraction(res, vec2(elev, ElevBlackMatID));\n    }\n    // Ground\n   \telse if(mPos.y < 0.4)\n    {\n        // Squares on ground\n        float exclusionBoxGround = SignedDistBox(mPos - vec3(0.0, 0.2, -9.5), vec3(3.65, 0.4, 14.5));\n        float squareGround = OpI(exclusionBoxGround, \n                              UnsignedDistBox(OperationRepetition(mPos - vec3(0.0, 5.21, 0.25), \n                                                                  vec3(5.0, 10.0, 1.5)),\n                                              vec3(3.9, 0.1, 0.5)));\n        res = OperationUnion(res, vec2(squareGround, BlackMarbleMatID));\n    }\n    // Top\n    else if(mPos.y > 5.1)\n    {\n        // Squares top\n        float exclusionBoxCeil = SignedDistBox(mPos - vec3(0.0, 5.5, -9.5), vec3(3.65, 0.4, 14.5));\n        float squareTop = OpI(exclusionBoxCeil, \n                              UnsignedDistBox(OperationRepetition(mPos - SquareTOPL1_POS, \n                                                                  vec3(1.25, 11.15, 1.3)),\n                                              SquareTOP_SIZE));\n\n        //Adding small bump distortion with Sin and Cos\n        res = OperationUnion(res, vec2(squareTop + ((sin(mPos.x * 12.5) + cos(mPos.z * 7.5))* 0.0005), TopWhiteMatID));\n\n\n        // Black spheres\n        float blackCylinder = OpI(exclusionBoxCeil, \n                                  SignedDistSphere(OperationRepetition(mPos - vec3(7.1, 1.575, 1.3),\n                                                                         vec3(8.0, 8.0, 3.8)),\n                                                     0.15));\n\n        res = OperationUnion(res, vec2(blackCylinder, BlackRoughMatID));\n    }\n    // Front\n    else if(mPos.z < -19.0)\n    {\n        // Exit door\n        float exitDoor = SignedDistBox(mPos - EXITDOOR_POS, EXITDOOR_SIZE);\n        res = OperationSoustraction(res, vec2(exitDoor, BlackRoughMatID));\n\n        float exitDoorStroke = SignedDistBox(mPos - EXITDOOR_HSTROKE_POS, EXITDOOR_HSTROKE_SIZE);\n        exitDoorStroke = OpU(exitDoorStroke, SignedDistBox(mPos - EXITDOOR_VSTROKE_POS, \n                                                           EXITDOOR_VSTROKE_SIZE));\n\n        res = OperationUnion(res, vec2(exitDoorStroke, BlackRoughMatID));\n\n        // Window\n        res = OperationSoustraction(res, vec2(SignedDistBox(mPos - EXITDOOR_WINDOW_POS, \n                                                              EXITDOOR_WINDOW_SIZE), SquareWhiteMatID));\n\n        // Door handle SignedDistSphere\n        res = OperationUnion(res, vec2(SignedDistSphere(mPos - vec3(2.45, 2.2, -24.2), 0.125)\n                                         , MetalMatID));\n\n        // Squares front\n        float frontWhiteSquares = UnsignedDistBox(mPos - SquareL1_Front1, Square_SIZE);\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL1_Front2, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL1_Front4, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL2_Front2, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL2_Front3, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL2_Front4, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL3_Front1, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL3_Front2, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL3_Front4, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL4_Front2, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL4_Front3, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL4_Front4, Square_SIZE));\n\n        res = OperationUnion(res, vec2(frontWhiteSquares, SquareWhiteMatID));\n\n        float fOrSqr = UnsignedDistBox(mPos - SquareL1_Front3, Square_SIZE);\n        fOrSqr = OpU(fOrSqr, UnsignedDistBox(mPos - SquareL2_Front1, Square_SIZE));\n        fOrSqr = OpU(fOrSqr, UnsignedDistBox(mPos - SquareL4_Front1, Square_SIZE));\n\n        res = OperationUnion(res, vec2(fOrSqr, SquareOrangeMatID));\n\n        res = OperationUnion(res, vec2(UnsignedDistBox(mPos - SquareL3_Front3, \n                                                                     Square_SIZE), BlackRoughMatID));\n    }\n    \n    return res;\n}\n//--------------------------------------------------------------\n\n//Calculate normals--------------------------------------------\nvec3 CalcNormal(vec3 mPos)\n{\n\tvec3 eps = vec3(0.025, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    SceneDistance(mPos + eps.xyy).x - SceneDistance(mPos - eps.xyy).x,\n\t    SceneDistance(mPos + eps.yxy).x - SceneDistance(mPos - eps.yxy).x,\n\t    SceneDistance(mPos + eps.yyx).x - SceneDistance(mPos - eps.yyx).x);\n\t\t\n\treturn normalize(nor);\n}\n//-------------------------------------------------------------\n\n//Calculate AO-------------------------------------------------\nfloat CalcAO(vec3 mPos, vec3 nor)\n{\n\tfloat totAO = 0.0;\n    float sca = 1.0;\n    for(int aoi = 0; aoi < 3; aoi++)\n    {\n        float hr = 0.01 + 0.025 * float(aoi + 2);\n        vec3 aoPos =  nor * hr + mPos;\n        float dd = SceneDistance(aoPos).x;\n        totAO += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - 4.0 * totAO, 0.0, 1.0);\n}\n//-------------------------------------------------------------\n\n//-------------------------------------------------------------\n// Shading ----------------------------------------------------\n//-------------------------------------------------------------\nvec3 Shading(vec3 rayOrigin, vec3 rayDirection,\n               rayIntersect mIntersection, lightTube lig)\n{\n\tvec3 L0 = lig.tubeStart - mIntersection.mPos;\n\tvec3 L1 = lig.tubeEnd - mIntersection.mPos;\n\tvec3 r = reflect(-rayDirection, mIntersection.nor);\n    \n\tvec3 Ld\t= L1 - L0;\n\tfloat RoL0 = dot(vec3(r), L0);\n\tfloat RoLd = dot(vec3(r), Ld);\n\tfloat L0oLd = dot(L0, Ld);\n\tfloat distLd = length(Ld);\n\tfloat t = (RoL0 * RoLd - L0oLd) / (distLd * distLd - RoLd * RoLd);\n\tvec3 closestPoint = L0 + Ld * clamp(t, 0.0, 1.0);\n    \n\tvec3 LightDir = normalize(closestPoint);\n\t\n    float NdotV = clamp(dot(mIntersection.nor, -rayDirection), 0.0, 1.0);\n\tfloat NdotL = clamp(dot(mIntersection.nor, LightDir), 0.0, 1.0);\n    \n\t//ambient, AO, BRDF\n    float ao = CalcAO(mIntersection.mPos, mIntersection.nor);\n\tvec3 amb = 0.3 * clamp(0.5 + 0.5 * mIntersection.nor.y, 0.0, 1.0) * AMBIENT_COLOR * ao;\n\n\t//Diffuse\n\tvec3 diff = amb + mIntersection.mat.albedo - mIntersection.mat.reflectivity / (2.0 * PI);\n\tvec3 colorResult = diff * NdotL;\n\t\n\tif (NdotV * NdotL > 0.0)\n\t{\n\t\t//Half angle Vector\n\t\tvec3 HalfAngleV = normalize(-rayDirection + LightDir);\n\t\tfloat NdotH = clamp(dot(mIntersection.nor, HalfAngleV), 0.0, 1.0);\n\t\tfloat VdotH = clamp(dot(-rayDirection, HalfAngleV), 0.0, 1.0);\n        \n\t\t// R0 good air-dielectric interface for 1.4 < Nt < 2.2\n        // Variances in micro-surfaces will result in a brighter or dimmer fresnel\n        // Fresnel Schlick's approximation\n\t\tfloat F = pow(1.0 - VdotH, 5.0);\n        \n\t\t// Cook-Torrance Geometry function\n\t\tfloat NH2 = 2.0 * NdotH / VdotH;\n\t\tfloat G = min(1.0, min(NdotV, NdotL) * NH2);\n \n\t\t// Roughness Beckmann Distribution\n\t\tfloat sq_NdotH   = NdotH * NdotH;\n\t\tfloat sq_NdotH_M = sq_NdotH * (mIntersection.mat.roughness * mIntersection.mat.roughness);\n\t\tfloat D = exp((sq_NdotH - 1.0) / sq_NdotH_M) / (PI * sq_NdotH * sq_NdotH_M);\n\n\t\t//float brdf_spec = (F * D * G) / (NdotV * NdotL * 4.0);\n        float brdf_spec = (F * D * G) / 4.0;\n\t\tcolorResult += (1.0 - mIntersection.mat.reflectivity) * brdf_spec;\n    }\n\treturn colorResult * lig.color * ao;\n}\n//-------------------------------------------------------------\n\n//RaymarchScene-------------------------------------------------\nvec3 RayMarchScene(vec3 rayOrigin, vec3 rayDirection,\n                   inout rayIntersect mIntersection)\n{\n    float dist = EPSILON * 2.0;\n    float t = 0.5;\n    float m = -1.0;\n    \n    for(int i = 0; i < 45; i++)\n    {\n        if(abs(dist) < EPSILON || t > FARCLIP) \n            break;\n\n        t += dist;\n        vec2 res = SceneDistance(rayOrigin + rayDirection * t);\n        dist = res.x;\n\t    m = res.y;\n    }\n    \n    if(t > FARCLIP)\n        m = -1.0;\n    \n    vec3 pos = rayOrigin + t * rayDirection;\n    mIntersection.mPos = pos;\n    mIntersection.nor = CalcNormal(pos);\n    mIntersection.dist = t;\n    \n\tvec3 colorResult = vec3(0.0);\n\tif (t > EPSILON)\n\t{\n\t\tmaterial mat;\n\t\tmat.albedo = SquareWhiteMatAlbedo;\n\t\tmat.roughness = 0.5;\n\t\tmat.reflectivity = 0.7;\n\t\t\n        if(m - 0.5 <= MarbleMatID)\n        {\n            if(mIntersection.nor.z > 0.0)\n            {\n                mat.albedo = texture(iChannel0, (pos.xy)/5.0, -100.0).xxx * BlackMarbleMatAlbedo - 0.25;\n                mat.roughness = BlackMarbleMatRoughness;\n                mat.reflectivity = BlackMarbleMatReflectivity;\n            }\n            else if(mIntersection.nor.y < 0.0)\n            {\n                mat.albedo = CeilMatAlbedo;\n                mat.reflectivity = CeilMatReflectivity;\n            }\n            else\n            {\n                float r = texture(iChannel0, (pos.zy - pos.yx)/7.0, -100.0).x;\n                mat.albedo = r * MarbleMatAlbedo;\n                mat.roughness = MarbleMatRoughness;\n                mat.reflectivity = MarbleMatReflectivity + min(r * r, 0.3);\n            }\n        }\n        else if(m - 0.5 <= BlackMarbleMatID)\n        {\n            mat.albedo = texture(iChannel0, (pos.xz)/4.0, -100.0).xxx * BlackMarbleMatAlbedo - 0.15;\n\t\t\tmat.roughness = BlackMarbleMatRoughness;\n\t\t\tmat.reflectivity = BlackMarbleMatReflectivity;\n        }\n        else if(m - 0.5 <= TopWhiteMatID)\n        {\n            mat.albedo = TopWhiteMatAlbedo;\n\t\t\tmat.roughness = TopWhiteMatRoughness;\n\t\t\tmat.reflectivity = TopWhiteMatReflectivity;\n        }\n        else if(m - 0.5 <= BlackRoughMatID)\n        {\n            mat.albedo = BlackRoughMatAlbedo;\n\t\t\tmat.roughness = BlackRoughMatRoughness;\n\t\t\tmat.reflectivity = BlackRoughMatReflectivity;\n        }\n\t\telse if(m - 0.5 <= SquareOrangeMatID)\n\t\t{\n\t\t\tmat.albedo = SquareOrangeMatAlbedo;\n\t\t}\n        else if(m - 0.5 <= ElevBlackMatID)\n\t\t{\n\t\t\tmat.albedo = ElevBlackMatAlbedo;\n\t\t\tmat.roughness = ElevBlackMatRoughness;\n\t\t\tmat.reflectivity = ElevBlackMatReflectivity;\n\t\t}\n        else if(m - 0.5 <= MetalMatID)\n        {\n            mat.albedo = MetalMatAlbedo;\n\t\t\tmat.roughness = MetalMatRoughness;\n\t\t\tmat.reflectivity = MetalMatReflectivity;\n        }\n\n\n\t\t\n\t\tmIntersection.mat = mat;\n\t\t\n\t\t//Shading / lighting\n        lightTube lig;\n\t\tlig.tubeStart = vec3(0.675, 4.7, -22.8);\n        lig.tubeEnd = vec3(0.675, 1.25, -22.8);\n        lig.color = vec3(1.0, 0.9451, 0.92157);\n        \n        for (int i = 0; i < 4; i++)\n        {\n\t\t\tcolorResult += 0.5 * Shading(rayOrigin, rayDirection, mIntersection, lig);\n            lig.tubeStart.x -= 1.15;\n            lig.tubeEnd.x -= 1.15;\n        }\n\t}\n    return colorResult;\n}\n//--------------------------------------------------------------\n\n//Render the scene----------------------------------------------\nvec3 RenderScene(vec3 rayOrigin, vec3 rayDirection)\n{ \n\trayIntersect mIntersection;\n\tmIntersection.mPos = vec3(0.0);\n\tmIntersection.nor = vec3(0.0);\n\tmIntersection.dist = 0.0;\n\t\n\t// Opaque\n    vec3 accum = RayMarchScene(rayOrigin, rayDirection, mIntersection);\n    \n    //reflection\n\trayIntersect mIntersecReflect = mIntersection;\n\tvec3 rayDirReflect = reflect(rayDirection, mIntersecReflect.nor);\n\tvec3 rayOriginReflect = mIntersecReflect.mPos + EPSILON * rayDirReflect;\n\tfloat refl = 1.0;\n\n\tfor (float k = 1.0; k < 3.0; ++k)\n\t{\n\t\tmIntersecReflect.dist = -1.0;\n\t\trefl *= max(0.75 - mIntersection.mat.reflectivity, 0.0);\n\t\taccum += RayMarchScene(rayOriginReflect, rayDirReflect, mIntersecReflect) * refl;\n\n\t\tif ((mIntersecReflect.dist < EPSILON)) \n\t\t\tbreak;\n\t\t\n\t\trayOriginReflect = mIntersecReflect.mPos;\n\t\trayDirReflect = reflect(rayDirReflect, mIntersecReflect.nor);\n\t\trayOriginReflect += EPSILON * rayDirReflect;\n\t}\n    \n\treturn clamp(accum, 0.0, 1.0);\n}\n//--------------------------------------------------------------\n//END THE SCENE-------------------------------------------------\n\n//Post Process ------------------------------------------------\nvec3 GammaCorrection(vec3 colorResult)\n{\n\treturn pow(colorResult, vec3(0.45455));\n}\n\nvec3 Contrast(vec3 colorResult)\n{\n    return colorResult * 0.6 + 0.4 * colorResult * colorResult * (3.0 - 2.0 * colorResult);\n}\n\nvec3 Tint(vec3 colorResult)\n{\n    return colorResult * vec3(1.025, 1.02, 1.0);\n}\n\nvec3 Vigneting(vec3 colorResult, vec2 fragCoord)\n{\n\tvec2 inXYPos = (fragCoord.xy / iResolution.xy);\n\treturn colorResult * (0.55 + 0.45 * pow(70.0 * inXYPos.x * inXYPos.y * (1.0 - inXYPos.x) * (1.0 - inXYPos.y), 0.15));\n}\n\nvoid ApplyPostProcess(inout vec3 colorResult, vec2 fragCoord)\n{\n    colorResult = GammaCorrection(colorResult);\n    colorResult = Contrast(colorResult);\n    colorResult = Tint(colorResult);\n    colorResult = Vigneting(colorResult,fragCoord);\n}\n//-------------------------------------------------------------\n\n//Post CameraDirection -----------------------------------------\nvec3 GetCameraRayDir(vec2 mUV, in vec3 camPosition, vec3 camTarget)\n{\n\tvec3 forwardVector = normalize(camTarget - camPosition);\n\tvec3 rightVector = normalize(cross(vec3(0.0, 1.0, 0.0), forwardVector));\n\tvec3 upVector = normalize(cross(forwardVector, rightVector));\n    \n\tvec3 camDirection = normalize(\tmUV.x * rightVector \n                                  +\tmUV.y * upVector\n                                  +\t5.0 * forwardVector);\n    \n\treturn camDirection;\n}\n//--------------------------------------------------------------\n\n//Screen coordinates ------------------------------------------\nvec2 GetScreenSpaceCoord(vec2 fragCoord)\n{\n\tvec2 mUV = (fragCoord.xy/iResolution.xy) * 2.0 - 1.0;\n\tmUV.x *= iResolution.x / iResolution.y;\n\n\treturn mUV;\t\n}\n//-------------------------------------------------------------\n\n//Main loop-----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mUV = GetScreenSpaceCoord(fragCoord);\n\n    //Camera --------------------------------------------------------\n    float mTime = sin(iTime / 10.0) * 0.1;\n    vec3 rayOrigin = vec3(-mTime, 3.0, 5.0);\n    vec3 camTarget = vec3(mTime, 2.95, 0.0);\n    \n    vec3 rayDirection = GetCameraRayDir(mUV, rayOrigin, camTarget);\n    //END CAMERA ----------------------------------------------------\n\n    vec3 mColor = RenderScene(rayOrigin, rayDirection);\n    \n    ApplyPostProcess(mColor,fragCoord);\n\n    fragColor = vec4(mColor, 1.0);\n}\n//--------------------------------------------------------------\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsjXWh","date":"1411654203","viewed":1065,"name":"Photo_Reproduction","username":"Polytopes","description":"I tried to reproduce a photo from a friend, I did a first pass on performances and optimisations, the framerate is still low for a medium end graphic c.\nOriginal picture from Roland Levesque: http://instagram.com/p/tQ9EaizRIC\nSee comments for more infos","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["architecture"],"hasliked":0,"parentid":"","parentname":""}}