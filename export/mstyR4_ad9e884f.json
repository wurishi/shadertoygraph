{"ver":"0.1","info":{"id":"mstyR4","date":"1695332909","viewed":18,"name":"First RayMarching","username":"martonban","description":"https://inspirnathan.com/posts/52-shadertoy-tutorial-part-6/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define SURFACE_DISTANCE .01\n\n/*\nThe camera has a UV, Pos, and a LookAt compnents\nThis camera is shooting rays from the position called ViewRays.\nThese rays is goinf to give us what is the distance from the rays to the intersection\nAfter we have the distance we can get the material, light values\nAfter all of it we can get the pixel's colors.\n*/\n\n// GetDistance\nfloat getDist(vec3 currentMarchingLocation) {\n    // SphereModel |  POS  | r\n    vec4 sphere1 = vec4(0, 1, 6, 1);\n    \n    float sphereDistance = length(currentMarchingLocation - sphere1.xyz) - sphere1.w;\n    float planeDistance = currentMarchingLocation.y;\n    \n    float totalDistance = min(sphereDistance, planeDistance);\n    return totalDistance;\n}\n\n\n// Ray March\nfloat rayMarch (vec3 cameraPostion, vec3 rayDirection) {\n    float distanceFromOrigin = 0.0f;\n    \n    for(int i = 0; i<MAX_STEPS; i++){\n        vec3 currentMarchingLocation = cameraPostion + rayDirection * distanceFromOrigin;\n        float distanceToScene = getDist(currentMarchingLocation);\n        distanceFromOrigin += distanceToScene;\n        // WE HAVE A HIT\n        if (distanceFromOrigin > MAX_DISTANCE || distanceToScene < SURFACE_DISTANCE) break;\n    }\n    \n    return distanceFromOrigin;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// point = Surface Position\nfloat getLight(vec3 point) {\n   vec3 lightPos = vec3(0, 5, 6);\n   lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n   vec3 lightVector = normalize(lightPos - point);\n   vec3 normalVector = getNormal(point);\n   \n   float dif = clamp(dot(normalVector, lightVector), 0., 1.);\n   float d = rayMarch(point + normalVector * SURFACE_DISTANCE * 2., lightVector);\n   if(d < length(lightPos - point)) dif *= .1;\n   return dif;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    // Normal Stuff\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // Camera \n    vec3 cameraPostion = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    float distance = rayMarch(cameraPostion, rayDirection);\n    vec3 point = cameraPostion + rayDirection * distance;\n    float diffuseLight = getLight(point);\n    \n    col = vec3(diffuseLight);\n    fragColor = vec4(col, 1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}