{"ver":"0.1","info":{"id":"dd3fWB","date":"1697579593","viewed":82,"name":"Cubatrix","username":"potatomatorange","description":"Just a neon cube","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["lesson1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvec2 project(in vec3 p, in float depth)\n{\n    return vec2(p.x / (p.z + depth), p.y / (p.z + depth));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    float d = 2.5;\n        \n    vec3 vertices[8];\n    vertices[0] = vec3(1.0, -1.0, -1.0);\n    vertices[1] = vec3(1.0, 1.0, -1.0);\n    vertices[2] = vec3(-1.0, 1.0, -1.0);\n    vertices[3] = vec3(-1.0, -1.0, -1.0);\n    vertices[4] = vec3(1.0, -1.0, 1.0);\n    vertices[5] = vec3(1.0, 1.0, 1.0);\n    vertices[6] = vec3(-1.0, 1.0, 1.0);\n    vertices[7] = vec3(-1.0, -1.0, 1.0);\n    \n    vec2 edges[12];\n    \n    edges[0] = vec2(0, 1);\n    edges[1] = vec2(1, 2);\n    edges[2] = vec2(2, 3);\n    edges[3] = vec2(3, 0);\n    edges[4] = vec2(4, 5);\n    edges[5] = vec2(5, 6);\n    edges[6] = vec2(6, 7);\n    edges[7] = vec2(7, 4);\n    edges[8] = vec2(0, 4);\n    edges[9] = vec2(1, 5);\n    edges[10] = vec2(2, 6);\n    edges[11] = vec2(3, 7);    \n    \n    float angle = 0.7 * iTime;\n    \n    vec3 res = vec3(0.0, 0.0, 0.0);\n    \n    int cubes_number = 6;\n    \n    for (int cube = 0; cube < cubes_number; cube++){\n        mat3 rot;\n\n        float angle_mod = (angle + 1.0 * sin(0.21231*angle * float(cube + 1))) * 0.5432 * float(cube % 3 + 1) ;\n        rot[cube % 3] = vec3(sin(angle_mod), cos(angle_mod), 0);\n        rot[(cube + 1) % 3] = vec3(0.0, 0.0, 1.0);\n        rot[(cube + 2) % 3] = vec3(-cos(angle_mod), sin(angle_mod), 0);\n\n        rot = transpose(rot);\n\n        vec3 vertices_rotated[8];\n        for (int i=0; i < vertices.length(); i++){\n            vertices_rotated[i] = rot * vertices[i];\n        }\n\n        for (int i=0; i<edges.length(); i++)\n        {\n            vec2 a = project(vertices_rotated[int(edges[i].x)], d);\n            vec2 b = project(vertices_rotated[int(edges[i].y)], d);\n\n            vec3 base_color = vec3(1.0 - 0.5 * sin(angle_mod*2.0) , 1.0 - 0.5 * cos(angle_mod) , 1.0 - 0.5 * cos(3.0 * angle_mod)); //vec3(0.3, 0.3, 1.0);\n            vec3 col =  base_color * (smoothstep(0.0, 0.5, 0.002 / udSegment(p, a, b)));\n\n            res += col;\n        }\n    }\n    \n    \n    vec2 texture_uv = vec2(fract(1.7 * p).x, fract(2.0 * p).y + 0.5 * iTime);\n    float texture_value = texture(iChannel0, texture_uv).rgb.x;\n    float shade = 3.0 / float(cubes_number);\n    //fragColor = texture_value * vec4(1.0, 1.0, 1.0, 1.0);\n    fragColor = shade * vec4(res, 1.0) * (1.0-texture_value);\n}","name":"Image","description":"","type":"image"}]}