{"ver":"0.1","info":{"id":"4d3SzH","date":"1457549837","viewed":927,"name":"Magnetic Field Effect With Drags","username":"vamoss","description":"Magnetic Field Effect With Drags","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["line","angle","magnectic","pointing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nOriginal Work\nhttp://netgrind.tumblr.com/post/82030732540/spinbow\n\nDrag Code from:\nhttps://www.shadertoy.com/view/4dtSRn\n*/\n\n#define COMBINE_ANGLES\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nconst float amplitude = 3.0;//how far goes the magnectic effect takes influences\nconst int maxCount = 12;//maximum of drags\nconst float radius = 10.0;//drag size\nconst float border = 1.5;//drag border\n\nconst float statePos = float(maxCount);\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);//delete area\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\n//  Function from IÃ±igo Quiles \n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat line(vec2 uv, vec2 origin, vec2 destiny, float radius){\n    destiny -= origin;\n\tfloat color = length( clamp( dot(uv-origin,destiny)/dot(destiny,destiny), 0.,1.) *destiny - uv+origin );\n    return smoothstep(color-0.05,color+0.05, radius);    \n}\n\nfloat lerpDegrees(float start, float end, float amount)\n{\n    float CS = (1.0-amount)*cos(start) + amount*cos(end);\n    float SN = (1.0-amount)*sin(start) + amount*sin(end);\n    return atan(SN, CS)-PI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //read buffer\n    vec4 state = BufA(statePos);\n    vec3 color = vec3(0.0);\n    \n    float curr = 0.0;\n    float dist = radius + 1.0;\n    for (int i = 0; i < maxCount; ++i) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        float d = distance(fragCoord, center);\n        if (d < dist) {\n            dist = d;\n            curr = f;\n        }\n    }\n    \n    //drags\n    if (dist < radius) {\n        if (dist > radius - border) {\n            //border\n            color = vec3(1.0, 1.0, 1.0);\n        } else {\n            if (curr == state.x)\n                if (state.z > 0.0)\n                    //mouse pressed\n                    color = vec3(0.0, 0.5, 0.0);\n                else\n                    //last pressed\n                    color = vec3(0.5, 1.0, 1.0);\n            else\n                //standby\n                color = vec3(0.5, 0.5, 0.5);\n        }\n    }\n    \n    if (inRect(fragCoord, deleteRect))\n        color = mix(color, vec3(1.0, 0.0, 0.0), 0.8);\n    \n    //find closest drag\n    vec2 closestPos = BufA(0.0).xy/iResolution.xy;\n    float closestDistance = 99999.0;\n    for (int i = 0; i < maxCount; i++) {\n        //skip unused indices\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        \n        float tmpDist = distance(BufA(f).xy/iResolution.xy, uv);\n        if(tmpDist<closestDistance){\n            closestDistance = tmpDist;\n            closestPos = BufA(f).xy/iResolution.xy;\n        }\n    }\n    \n    //tile\n    vec2 frequency = vec2(32.0, 18.0);\n    vec2 index = floor(frequency * uv)/frequency;\n    vec2 uvTiled = fract(frequency * uv);\n\t\n    //line\n    float lineWidth = 0.15;\n    float lineLenght = 0.3;\n    vec2 origin = index;\n    vec2 dest;\n    \n    //angle\n    float angle = 0.0;\n#ifdef COMBINE_ANGLES\n    for (int i = 0; i < maxCount; i++) {\n        //skip unused indices\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        \n        dest=BufA(f).xy/iResolution.xy-0.5/frequency;\n        float angle2 = atan((dest.y-origin.y),(dest.x-origin.x));\n        float dist2 = (1.-distance(origin, dest));\n        angle = lerpDegrees(angle, angle2, pow(dist2, amplitude));\n    }\n#else\n    dest=closestPos-0.5/frequency;\n    angle = atan((dest.y-origin.y),(dest.x-origin.x));\n#endif\n                    \n    //line width in relation with distance\n    float destDist = pow(1.-distance(origin, closestPos), amplitude);\n    \n    //pulsate\n    //destDist += (sin(3.0*iTime+destDist*20.0)+1.0)/4.0;\n    \n    lineWidth *= destDist;\n    \n    //make line go to both direction around center\n    origin = vec2(cos(angle)*lineLenght,sin(angle)*lineLenght)+0.5;\n    dest = vec2(cos(angle)*-lineLenght,sin(angle)*-lineLenght)+0.5;\n    \n    //animate colors\n    //angle+=iTime*4.0;\n    \n\tcolor += line(uvTiled, origin, dest, lineWidth) * hsb2rgb(vec3(angle/TWO_PI,0.3,1.0));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Drag and drop framework\n// https://www.shadertoy.com/view/4dtSRn\n// by mhnewman\n//\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\nconst int maxCount = 12;\nconst float radius = 10.0;\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n//*\n    //thumbnail mouseover\n    if(iMouse.x==0.0){\n        //manipulate index\n        float index = 0.0;\n        if(p.x==index){\n            float ratio = 100.;\n            fragColor = vec4(\n                cos(iTime*3.0)*ratio+iResolution.x/2.0,\n                sin(iTime*3.0)*ratio+iResolution.y/2.0,\n                0.0,\n                0.0\n            );\n            return;\n        }\n    }\n/**/\n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        //\n        // Initial conditions\n        //\n        addObject(0.3 * iResolution.x, 0.1 * iResolution.y);\n        addObject(0.7 * iResolution.x, 0.1 * iResolution.y);\n        addObject(0.8 * iResolution.x, 0.9 * iResolution.y);\n        addObject(0.2 * iResolution.x, 0.6 * iResolution.y);\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / iResolution.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / iResolution.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / iResolution.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n            \tstate.x = 2.0 * statePos;\n            } else {\n    \t        state.x = state.y;\n        \t    state.y += 1.0;\n        \t}\n        }\n    } else if (state.z > 0.0 && iMouse.z <= 0.0 && inRect(iMouse.xy, deleteRect)) {\n        if (p.x == statePos) {\n            state.x = 2.0 * statePos;\n            state.y -= 1.0;\n            state.z = iMouse.z;\n\t        fragColor = state;\n    \t    return;\n        }\n        if (p.x < state.x) {\n            fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n            return;\n        }\n        fragColor = texture(iChannel0, (fragCoord + vec2(1.0, 0.0)) / iResolution.xy);\n        return;\n    }\n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buf A","description":"","type":"buffer"}]}