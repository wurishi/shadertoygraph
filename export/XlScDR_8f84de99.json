{"ver":"0.1","info":{"id":"XlScDR","date":"1508172591","viewed":78,"name":"Decentralization Affects Polar","username":"JaapSuter","description":"N/A","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2dmathdemonstration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Line Circle Intersection - written 2015 by JT\n\nfloat DistanceAlong(vec2 a, vec2 u, vec2 c)\n{\n    return dot(u, c - a) / dot(u, u);\n}\n\nvec2 ProjectAlong(vec2 a, vec2 u, vec2 c)\n{\n    return a + u * DistanceAlong(a, u, c);\n}\n\nfloat PointLineDistance(vec2 a, vec2 u, vec2 c)\n{\n    return length(c - ProjectAlong(a, u, c));\n}\n\nvec4 LineCircleIntersections(vec2 a, vec2 u, vec2 m, float r)\n{\n    float distradial = length(ProjectAlong(a, u, m) - m);\n    float disttangent = sqrt(r * r - distradial * distradial);\n    return\n        vec4(\n        \tProjectAlong(a, u, m) + normalize(u) * disttangent,\n            ProjectAlong(a, u, m) - normalize(u) * disttangent);\n}\n\n#define draw(q) oCol *= smoothstep(0.0, 0.01, abs(q))\n\n\n    const float lineCount = 256.0;\n    const float lineLength = 800.0;\n    const float innerRadiusMm = 86.0;\n    const float outerRadiusMm = 153.0;\n\n        \n\nvoid mainImage(out vec4 oCol, vec2 iPos)\n{\n    float rawHeight = lineCount;\n    float polarHeight = iResolution.y - rawHeight;\n\n\tvec2 polarOrigin = vec2(iResolution.x / 2.0, polarHeight / 2.0);\n    \n    \n    iPos -= vec2(0.5);\n    \n    vec2 cPos = iMouse.xy - polarOrigin;\n    cPos /= 8.0;\n    cPos = floor(cPos);\n    float cRadius = (innerRadiusMm + outerRadiusMm) / 2.0 - 9.0;\n    \n        \n    if (iPos.y > polarHeight) {        \n        if (iPos.x > lineLength) {\n            oCol = vec4(0, 0, 0, 1);            \n        }\n        else {\n            \n            iPos.y = iResolution.y - 1.0 - iPos.y;\n            \n            const float pi = 3.14159265359;\n            \n\t    \tfloat normAngle = iPos.y / rawHeight;\n            float lineDist = iPos.x / lineLength;\n            \n            vec2 a = vec2(0.0);\n            vec2 u = vec2(cos(normAngle * pi * 2.0), sin(normAngle * pi * 2.0));\n            vec2 m = cPos;\n            float r = cRadius;\n            \n            vec4 iss = LineCircleIntersections(a, u, m, r);\n            float d0 = length(iss.xy) - innerRadiusMm;\n            float d1 = length(iss.xy) - innerRadiusMm;\n            \n            if (d0 < 1.0)\n                d0 = d1;\n            d0 /= (outerRadiusMm - innerRadiusMm);\n            d0 *= lineLength;\n                        \n            if (abs(d0 - iPos.x) < 1.3)\n                oCol = vec4(1, 0, 0, 1);\n            else\n            \toCol = vec4(0.1, 0.1, 0.1, 1.0);\n            \n            int iY = int(iPos.y);\n            if (0 == (iY % 64))\n                oCol.b += 0.2f;\n            \n        }\n    }\n    else {\n        \n        oCol = vec4(0.0);\n        iPos -= polarOrigin;\n        if (abs(iPos.x) < 1.0 || abs(iPos.y) < 1.0) {\n            oCol += vec4(0.2, 0.2, 0.2, 1);\n        }\n\t\t\t \n        vec2 dv = iPos - cPos;\n        float dd = length(dv);\n        vec2 av = abs(dv);\n        float ad = abs(dd - cRadius);\n\n        if (((av.x < 1.0 || av.y < 1.0) && dd < cRadius) || ad < 1.0) {\n            oCol += vec4(0.2, 0.2, 0.9, 0.2);\n        }\n        \n        float dpd = length(iPos);\n        if (abs(dpd - innerRadiusMm) < 1.0)\n        \toCol += vec4(0.9, 0.8, 0.5, 0.1);\n\t\telse if (abs(dpd - outerRadiusMm) < 1.0)\n        \toCol += vec4(0.9, 0.8, 0.5, 0.1);\n    }\n}\n","name":"Image","description":"","type":"image"}]}