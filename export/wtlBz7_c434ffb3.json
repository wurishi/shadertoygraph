{"ver":"0.1","info":{"id":"wtlBz7","date":"1596395584","viewed":57,"name":"v4-51154.9","username":"jorge2017a1","description":"v4-51154.9 ---Autor desconocido\nUsar el Mouse","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["v4511549"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//referencia\n//51154.9 ---Autor desconocido\n\n#define PI \t\t3.1415926535897932384626\n#define ZERO \t\tvec3(0.0)\n#define X\t\tvec3(1.0,0.0,0.0)\n#define Y\t\tvec3(0.0,1.0,0.0)\n#define Z\t\tvec3(0.0,0.0,1.0)\n#define R\t\t2.0\n#define T\t\t4\n\n#define EPSILON\t\t0.001\n#define MAX_DIST\t80.0\n#define MAX_ITER\t100\n\n#define MAX_LIGHT\t2\n#define BALL_ROW\t1.0\n#define BALL_COL\t2.0\n#define RADIUS\t\t2.0\n\n#define ALBEDO  \tvec3(0.75)\n#define METALLIC \t0.99\n#define ROUGHNESS \t1.0\n#define F0\t\tmix(vec3(0.04),albedo,metallic)\n#define AO\t\t1.0\n\n\n\n\n\n//-----------------------------\n\nfloat rand(vec3 seed){\n\treturn fract(sin(dot(seed, vec3(12.9898,78.233,233.33))) * 43758.5453);\n}\n\nfloat rand(vec2 seed)\n{\n\treturn rand(vec3(seed,0.0));\n}\n\nfloat rand(float seed)\n{\n\treturn rand(vec3(seed,0.0,0.0));\n}\n\nfloat noise3(vec3 pos)\n{\n\tfloat t = -iTime*0.0;\n\tvec3 base = floor(pos*R+t);\n\tvec3 pot = fract(pos*R+t);\n\tvec3 f = smoothstep(0.0,1.0,pot);\n\tfloat w1 = mix(rand(base),    rand(base+X),    f.x);\n\tfloat w2 = mix(rand(base+Z),  rand(base+X+Z),  f.x);\n\tfloat w3 = mix(rand(base+Y),  rand(base+X+Y),  f.x);\n\tfloat w4 = mix(rand(base+Y+Z),rand(base+X+Y+Z),f.x);\n\treturn mix(\n\t\tmix(w1,w3,f.y),\n\t\tmix(w2,w4,f.y),\n\t\tf.z\n\t);\n}\n\n\nfloat fbm3(vec3 pos)\n{\n\tfloat total = 0.0, amp = 1.0;\n\tfor (int i = 0; i < T; i++){\n\t\ttotal += noise3(pos) * amp; \n\t\tpos *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn 1.0-exp(-total*total);\n}\n//\nvec3 fresnelSchlick(vec3 albedo,float cosTheta,float metallic)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n//\nfloat plane(vec3 pos,vec3 normal,float h)\n{\n\treturn dot(pos,normalize(normal))-h;\n}\n\nfloat box(vec3 pos,vec3 center,vec3 size)\n{\n  \tvec3 d = abs(pos-center) - size;\n \treturn length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec3 t){\n  vec2 q = vec2(length(p.xz)-t.x, p.y+t.z);\n  return length(q)-t.y;\n}\n\nfloat cylinder( vec3 p, vec2 h)\n{\n   \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat solidSphere(vec3 pos, vec3 center, float radius)\n{\n\tfloat d = distance(pos,center)-radius;\n\treturn d;\n}\n\nfloat sphere(vec3 pos, vec3 center, float radius)\n{\n\tfloat d = solidSphere(pos,center,radius);\n\treturn d;\n}\n\nvec2 dmin(vec2 a,vec2 b)\n{\n\tif(a.x == min(a.x,b.x))\n\t\treturn a;\n\telse \n\t\treturn b;\n}\n\n\n//---------------------------------------------------------\n\n// return (distance, id)\n\nvec2 dist(vec3 pos)\n{\n\tfloat id = 0.0;\n\tfloat d = MAX_DIST;\n    \n\tfloat obj = id;\n\t\n    for(float i = -BALL_ROW+1.0; i <= BALL_ROW-1.0; i+=2.0){\n\t\tfor(float j = -BALL_COL+1.0; j <= BALL_COL-1.0; j+=2.0){\t\n\t\t\tfloat _d = sphere(pos,1.25*(j*X-i*Z-Z)*RADIUS,RADIUS);\n\t\t\td = min(d,_d);\n\t\t\tif(d == _d){\n\t\t\t\tobj = id;\n\t\t\t}\n\t\t\tid++;\n\t\t}\n\t}\n\n\tfloat s_id = BALL_ROW*BALL_COL;\n\tvec2 dp = vec2(plane(pos,Y,-RADIUS),-1.);\n\tvec2 db = vec2(box(pos-7.0*Z-5.0*X,ZERO,vec3(RADIUS)),s_id);\n\tvec2 dc = vec2(cylinder(pos+5.*X-5.*Z,vec2(1.0,5.0)),s_id+1.0);\n\tvec2 dt = vec2(torus(pos+5.*X-5.*Z,vec3(2.0,0.5,1.5)),s_id+2.0);\n\tvec2 p = vec2(d,obj);\n\tp = dmin(p,dp);\n\tp = dmin(p,db);\n\tp = dmin(p,dc);\n\tp = dmin(p,dt);\n\n\treturn p;\n}\n\nvec3 setCamera(vec2 uv,vec3 pos,vec3 lookat,vec3 up)\n{\n\tvec3 camDir = normalize(lookat-pos);\n\tvec3 camUp = normalize(up);\n\tvec3 camRight = cross(camDir,camUp);\n\treturn normalize(uv.x*camRight+uv.y*camUp+5.0*camDir);\n}\n\nvec3 rayMarching(vec3 ro,vec3 rd,float mint)\n{\n\tvec2 d = vec2(mint);\n\tfloat h = d.x;\n\tfor(int i = 0; i<MAX_ITER; i++){\n\t\td = dist(ro+rd*h);\n\t\tif(d.x < EPSILON){ \n\t\t\tbreak;\n\t\t}\n\t\tif(h > MAX_DIST){\n\t\t\treturn vec3(MAX_DIST);\n\t\t}\n\t\th += d.x;\n\t}\n\treturn vec3(h,d);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\t return normalize(vec3(\n        \tdist(pos+X*EPSILON).x - dist(pos - X*EPSILON).x,\n        \tdist(pos+Y*EPSILON).x - dist(pos - Y*EPSILON).x,\n        \tdist(pos+Z*EPSILON).x - dist(pos - Z*EPSILON).x\n    \t));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float k)\n{\n    float res = 1.0;\n    float h = mint;\n    for(int t = 0; t < MAX_ITER; t++){\n        float d = dist(ro+rd*h).x;\n        if( d < EPSILON)\n            return 0.0;\n\tif(h > MAX_DIST)\n\t\tbreak;\n        res = min(res, k*d/h);\n        h += d;\n    }\n    return res;\n}\n\nfloat calcShadow(vec3 pos,vec3 dir)\n{\n\tfloat esp = 100.0*EPSILON;\n\tfloat d = rayMarching(pos,dir,esp).y;\n\treturn step(esp,d);\n}\n\n\n\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\t\n   \n    float t=mod(iTime, 300.0);\n    vec3 ro=vec3(0.0+10.0*cos(t),10.0,-30.0+10.0*sin(t));\n    \n    ro= getMouse(ro);\n    \n   \n\tvec3 rd = setCamera(uv,ro,ZERO,Y);\n\tvec3 h = rayMarching(ro,rd,EPSILON);\n\tvec3 color = ZERO;\n\t\n    \n    if(h.x < MAX_DIST)\n    {\n\t\tfor(int i = 0; i< MAX_LIGHT;i++){\n\t\tvec3 Lo = ZERO;\n\t\tfloat t = 0.2 * iTime;\n\t\tvec3 light = 18.0*vec3(sin(t*float(i)),0.3,cos(float(i)*t));\n\t\tvec3 pos = ro+rd*h.x;\n\t\t\n\t\tfloat row = floor(h.y / BALL_COL);\n\t\tfloat col = h.y - row * BALL_COL;\n\t\tfloat k = smoothstep(0.4,0.7,fbm3(pos));\n\t\tfloat id = step(0.0,h.z);\n\t\tvec3 albedo = mix(vec3(1.0),mix(ALBEDO,vec3(0.69,0.05,0.0),1.0-k),id);\n\t\tfloat roughness = ROUGHNESS*(1.0-k)*id+0.2;\n\t\tfloat metallic = METALLIC*(k)*id+0.2;\n\t\t\n\t\tvec3 N = calcNormal(pos);\n\t\tvec3 L = normalize(light-pos);\n\t\tvec3 V = normalize(ro-pos);\n\t\tvec3 H = normalize(V+L);\n\t\t\n\t\tvec3 F  = fresnelSchlick(albedo,max(dot(H, V), 0.0),metallic);\n\t\tfloat NDF = DistributionGGX(N, H, roughness);       \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);\n\t\t\n\t\tfloat dis = 1.0;//length(light-pos);\n        \tfloat attenuation = 1.0 / (dis * dis);\n        \tvec3 radiance     = vec3(1.0,1.0,1.0) * attenuation;\n\n\t\tvec3 nominator  = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n\t\tvec3 specular     = nominator / denominator;\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic; \n\t\tfloat NdotL = max(dot(N, L), 0.0);        \n   \t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t\tvec3 ambient = vec3(0.03) * albedo * AO ;\n\t\tcolor += ambient + Lo * softShadow(pos,L,0.1,16.0);  \n\t\t}\n\t\tcolor = color / (color + vec3(1.0));\n\t\tcolor = pow(color, vec3(1.0/2.19)); \n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}