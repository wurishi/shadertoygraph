{"ver":"0.1","info":{"id":"l3jGzy","date":"1708609991","viewed":37,"name":"moleculee","username":"LeticiaBenaoudia","description":"ty","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2023.02.06\n// Eric Galin\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m,vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n \n  // Origin\n  ro=vec3(10.,0.,15.);\n  ro*=Rz(a);\n \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  rd=normalize(p.x*u+p.y*v+le*w);\n}\n\n// Primitives\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\n\nfloat Sphere(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n// plan\n// p : point\n// c : centre du plan\n// n : vecteur normal au plan\n \n\n float plane (vec3 p,vec3 c,vec3 n)\n{\n  return dot(p-c,n);\n}\n\n// cercle\n\n float cercle( vec3 p,vec3 c, vec3 n , float R)\n {\n float h = dot (p-c,n);\n float l = sqrt (dot ((p-c),(p-c))- h*h);\n float m = l-R;\n float d =sqrt((h*h)+(m*m));\n  return d;\n }\n \n\n// tore\n\n// p : point\n// c : centre du tore\n// n : vecteur normal au plan du cercle (cercle principal du tore)\n// R : rayon du cercle principal du tore\n// r : rayon du tore\n\nfloat tore( vec3 p, vec3 c, vec3 n,float R,float r)\n{ return cercle(p,c,n,R)-r;\n}\n\n//segment\n\nfloat seg (vec3 p,vec3 a, vec3 b)\n{\nvec3 u=(b-a) / length (b-a);\nfloat l = dot(p-a,u);\n \nif( dot (p-a,u) <0.)\n{\nreturn length(p-a);\n}\nif( dot (p-b,u) >0.)\n{\nreturn length(p-b);\n}\nreturn sqrt( length((p-a)*length(p-a))- l*l);\n}\n //capsule\n \n// p : point\n// a : extrémité du segment\n// b : autre extrémité du segment\n// r : rayon de la capsule\n float capsule (vec3 p,vec3 a,vec3 b, float r)\n {\n return seg(p,a,b)-r;\n }\n \n \n // disque\n \n float Disque (vec3 p ,vec3 c ,vec3 n ,float R)\n{ float h= dot(p-c,n);\n  float m= sqrt(length(p-c)*length(p-c)-h*h);\n  if (m<R){\n   return h;\n  }\n return cercle(p,c,n,R);\n }\n \n // Operators\n\n// Union\n\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n  return min(a,b);\n \n}\n// intersection\n\n float intersecte( float a, float b)\n {\n \n return max(a,b);\n }\n // différence\n \n float difference(float a,float b)\n {\n return max(a,-b);\n } \n// cube\n// p : Point dans l'espace\n// pa : Point de début de la boîte\n// pb : Point de fin de la boîte\n\n float Box(vec3 p,vec3 pa,vec3 pb)\n {\n float a = plane(p,pb,(vec3(1.0,0.0,0.1)));\n float b =plane(p,pa, (vec3(-1.0,0.0,0.0)));\n float c =plane(p,pb, (vec3(0.0,1.0,0.0)));\n float d =plane(p,pa, (vec3(0.0,-1.0,0.0)));\n float e =plane(p,pb, (vec3(0.0,0.0,1.0)));\n float f =plane(p,pa, (vec3(0.0,0.0,-1.0)));\n float boite = (intersecte(a,intersecte(b ,intersecte(c,intersecte( d,intersecte(e,f))))));\n return boite;\n \n}\n//cylindre\n// p : Point dans l'espace\n// r : Rayon du cylindre\n// a : Extrémité  du cylindre\n// b : Extrémité  du cylindre \n\nfloat cylindre(vec3 p,float r ,vec3 a,vec3 b )\n{\nfloat p1=plane(p,a,a-b);\nfloat p2=plane(p,b,b-a);\n\nfloat cap=capsule(p,a,b,r);\n\nreturn intersecte(p1,intersecte(p2,cap));\n }\n \n// molecule\n// p : Point dans l'espace\n// cs1, cs2, cs3, cs4 : Centres des sphères\n// rs1, rs2, rs3, rs4 : Rayons des sphères\n// rb1, rb2, rb3 : Rayons des cylindres\n// a1, b1, a2, b2, a3, b3 : Points de début et de fin des cylindres\n// ct1, ct2, ct3, ct4 : Centres des tores\n// nt1, nt2, nt3, nt4 : Normales des tores\n// Rt1, Rt2, Rt3, Rt4 : Rayons des tores\n// rbt1, rbt2, rbt3, rbt4 : Rayons des sections des tores\nfloat molecule(vec3 p,\n               vec3 cs1, float rs1, float rb1, vec3 a1, vec3 b1,\n               vec3 cs2, float rs2, float rb2, vec3 a2, vec3 b2,\n               vec3 cs3, float rs3, float rb3, vec3 a3, vec3 b3,\n               vec3 cs4, float rs4,\n               vec3 ct1, vec3 nt1, float Rt1, float rbt1,\n               vec3 ct2, vec3 nt2, float Rt2, float rbt2,\n               vec3 ct3, vec3 nt3, float Rt3, float rbt3,\n               vec3 ct4, vec3 nt4, float Rt4, float rbt4) {\n\n    float atomes1 = Sphere(p, cs1, rs1);\n    float atomes2 = Sphere(p, cs2, rs2);\n    float atomes3 = Sphere(p, cs3, rs3);\n    float atomes4 = Sphere(p, cs4, rs4);\n    float branche1 = cylindre(p, rb1, a1, b1);\n    float branche2 = cylindre(p, rb2, a2, b2);\n    float branche3 = cylindre(p, rb3, a3, b3);\n    float tore1 = tore(p, ct1,nt1, Rt1, rbt1);\n    float tore2 = tore(p, ct2,nt2, Rt2, rbt2);\n    float tore3 = tore(p, ct3,nt3, Rt3, rbt3);\n    float tore4 = tore(p, ct4,nt4, Rt4, rbt4);\n\n     float molecule = Union(Union(Union(Union(Union(atomes1, atomes2), atomes3), atomes4),\n                             Union(Union(branche1, branche2), branche3)),\n                       Union(Union(Union(tore1, tore2), tore3), tore4));\n\n    return molecule;\n}\n \n\n\n// Potential field of the object\n// p : point\n//float object(vec3 p)\n//{\n  //float v=(\n    //Union(Sphere(p,vec3(0.,2.,2.),2.25),\n    //Sphere(p,vec3(3.,0.,-1.),3.)),\n    //Sphere(p,vec3(3.,0.,5.),3.75)\n  //);\n \n  //v=Union(v,\n    //plane(p,vec3(2.0,1.0,2.0),normalize (vec3(3.0,2.0,4.0))));\n \n  //return v;\n//}\n\n \n   //float B= Box(p,vec3(-5,-5,-2),vec3(2,2,2));\n   //return B;\n   //float t= tore (p,vec3(2,2,1),normalize (vec3(1,3,1)),4.,3.);\n   //return t;\n   //float c=capsule(p,vec3(3,8,2),vec3(2,5,4),2.);\n   //return c;\n   //float cy=cylindre(p,3.,vec3(3,15,2),vec3(2,5,4));\n   //return cy;\n   //float d= cercle(p,vec3(0.,0.,2.), vec3(0.1,0.,1.),1.);\n   //float d= Disque(p,vec3(0.,0.,2.), vec3(0.1,0.,1.),1.);\n  //return d;\n\n\n//);\n   \n\n float object (vec3 p)\n{\n\nfloat result = molecule(p,    \n    vec3(0.0, 0.0, 0.0), 1.0,  \n    0.1, vec3(1.0, 0.0, 0.0), vec3(2.0, 0.0, 0.0),   \n    vec3(2.0, 0.0, 0.0), 0.7,  \n    0.1, vec3(-0.8, 0.5, 0.0), vec3(-2.0, 1.5, 0.0),  \n    vec3(-2.0, 1.5, 0.0), 0.6, \n    0.1,vec3(-1.5, -1.0, 1.5),vec3(1.0, 0.0, 0.0),\n    vec3(-1.92, -1.1,1.8),0.6,\n    vec3(0.0, 0.0, 0.0),normalize (vec3(1,3,1)),1.5,0.1,\n    vec3(2.0, 0.0, 0.0),normalize (vec3(1,3,1)),1.,0.1,\n    vec3(-2.0, 1.5, 0.0),normalize (vec3(1,3,1)),1.,0.1,\n    vec3(-1.92, -1.1,1.8),normalize (vec3(1,3,1)),1.,0.1\n    );\n    return result;\n}\n\n \n\n// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  float v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z))-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z))-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps))-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float e,out bool h,out int s)\n{\n  h=false;\n \n  // Start at the origin\n  float t=0.;\n \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=object(p);\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),d.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  bool h;\n  int s;\n  float t=SphereTrace(p+Epsilon*n,l,100.,h,s);\n  if(!h)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p,vec3 n,vec3 e)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n \n  // Ambient color\n  vec3 ambient=.25+.25*background(n);\n \n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n \n  // Specular\n  vec3 r=reflect(e,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n \n  // Trace ray\n \n  // Hit and number of steps\n  bool hit;\n  int s;\n \n  float t=SphereTrace(ro,rd,100.,hit,s);\n \n  // Shade background\n  vec3 rgb=background(rd);\n \n  if(hit)\n  {\n    // Position\n    vec3 p=ro+t*rd;\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    // Shade object with light\n    rgb=Shade(p,n,rd);\n  }\n \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n \n  color=vec4(rgb,1.);\n}","name":"Image","description":"","type":"image"}]}