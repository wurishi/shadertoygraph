{"ver":"0.1","info":{"id":"dlyBRK","date":"1702262874","viewed":46,"name":"artichoke 2","username":"Efim","description":"simple technique of drawing petals on the surface of a sphere","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","repetition","artichoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright (c) 2023 Efim Manevich\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n\n#define PI  3.14159265359\n#define TAU 6.28318530718\n\nconst float dist_infin = 10.0;\n#define nn 128\nconst float eps = 0.001;\n\n\nmat3 rotateX(float f) {\n    return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(f), -sin(f)), vec3(.0, sin(f), cos(f)));\n}\n\nmat3 rotateZ(float f) {\n    return mat3(vec3(cos(f), -sin(f), 0.0), vec3(sin(f), cos(f), 0.0), vec3(0.0, 0.0, 1.0));\n\n}\n\nmat3 rotateY(float f) {\n    return mat3(vec3(cos(f), 0.0, sin(f)), vec3(0.0, 1.0, 0.0), vec3(-sin(f), 0.0, cos(f)));\n}\n\n\nfloat fcolor(float x)\n{\n    return 0.35 + 0.1*sin(x*10.0); \n}\n\nvec3 sdfColor;\nvec3 resColor;\nvec3 col1 = vec3(0.5019607843137255, 0.6705882352941176, 0.34509803921568627);\nvec3 col2 = vec3(0.4588235294117647, 0.16862745098039217, 0.21176470588235294);\n\nfloat petalArti(vec3 pos, float w, float h)\n{\n    //petal SDF\n    float rs = 8.0 + 3.0*cos(iTime);\n    vec3 p = rotateX(PI/rs)*pos;\n    float y = clamp(p.y/h, 0., 1.);\n    float lh = .5;\n    float yh = clamp((y - 1. + lh)/lh, 0., 1.); \n    float d = cos(yh*(PI/2.2))/2.0;\n    float x = clamp(p.x/w, 0.5-d, 0.5+d);\n    float z = sin((d - abs(x - 0.5))/d*PI/2.1)*(w+h)*0.05 * cos(abs(y-0.6)/0.6*PI/2.);//(1.+cos((x-0.5)*PI)*cos((y-0.5)*PI))*.1*(w+h)*y*y;\n    z*=(1. + y);\n    float cl = fcolor(x) + fcolor(x + PI); \n    sdfColor = mix(col2, col1, vec3(smoothstep(-0.3, 0.3, y - cl)));\n    vec3 val = vec3(x*w, y*h, z);\n    return length(p - val)*0.4 - 0.001*(h+w);\n}\n\n\nfloat sdArtichoke(vec3 p, float r)\n{\n    float l = length(p.xy);\n    float d = length(p)-r;\n    \n    float n = 8.;\n    float m = 12.;\n    float st = 0.5;\n    \n    float y = 1. - (atan(l, p.z) + PI/2.)/PI;\n    float x = mod(atan(p.y, p.x), TAU)/TAU;\n    float row = floor(y*n);\n    y = y*n - row;\n    \n    float shift = mod(st*row, 1.0);\n    x = mod(x - shift/m, 1.0);\n    x = fract(x*m);\n    float rh = 1.5*PI*r/n;\n    float rw = l/length(p)*r*TAU/m;\n    //float dl = toorow3D(x, y, d, step, rw, rh);\n    //calc patal in two row\n    float x1 = x;\n    float y1 = y*0.5 + 0.5;\n    float x2 = mod(x - st, 1.0);\n    float y2 = y*0.5;\n    float dl1 = petalArti(vec3(x1*rw, y1*rh, d), rw, rh);\n    resColor = sdfColor; \n    float dl2 = petalArti(vec3(x2*rw, y2*rh, d), rw, rh);\n    if (dl2 < dl1)\n        resColor = sdfColor;\n    float dl = min(dl1, dl2);\n    //calc patal\n    d*=0.8;\n    if (d < dl)\n        resColor = col2;\n    d = min(d, dl);\n    return d;\n    \n}\n\n\n\nfloat map(in vec3 pos) {\n   return sdArtichoke(pos, .8);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos) {\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map(pos + k.xyy * h) +\n        k.yyx * map(pos + k.yyx * h) +\n        k.yxy * map(pos + k.yxy * h) +\n        k.xxx * map(pos + k.xxx * h));\n}\n\nstruct HIT {\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\nconst HIT hit_inf = HIT(dist_infin, vec3(0.0), vec3(0.0));\n\nHIT giper3D(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for(int i = 0; i < nn; i++) {\n        vec3 pos = ro + rd * t;\n        float h = map(pos);\n        if(h < eps || t >= dist_infin)\n            break;\n        t += h;\n    }\n\n    if(t >= dist_infin)\n        return hit_inf;\n\n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    return HIT(t, nor, pos);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p), r = normalize(cross(vec3(0, 1, 0), f)), u = cross(f, r), c = f * z, i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\n\nvec3 calccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n        col *= clamp(difu, 0.3, 1.0);\n    return col;   \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 light = normalize(vec3(0.0, 1.0, 2.5)); //light\n    vec3 light2 = normalize(vec3(0.0, -1.0, -2.5)); //light\n    float t = iTime / 3.;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n        m = (-iResolution.xy + 2.0 * (iMouse.xy)) / iResolution.y;\n        t = 0.;\n    }\n    vec3 ro = vec3(0.0, 0.0, 2.); // camera\n    ro = rotateY(-m.x * TAU) * rotateX(-m.y * PI) * ro; //camera rotation\n\n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n    mat3 rota  = rotateX(-PI/2.0)*rotateY(-t);\n    mat3 rota_1  = rotateY(t)*rotateX(PI/2.0);\n    \n\n    vec3 tot = vec3(0.0);\n\n    //antiblick\n    for(int m = 0; m < AA; m++) for(int n = 0; n < AA; n++) {\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n            vec3 rd = GetRayDir(p, ro, vec3(0, 0., 0), fl); //ray direction\n            vec3 col = vec3(1.); // background  \n\n            HIT giper = giper3D(rota * ro, rota * rd);\n            if(giper.dist < dist) {\n                vec3 nor = rota_1 * giper.nor;\n\n                col = resColor;\n                \n                \n                //float dif = clamp(dot(nor, light), 0.4, 1.0);\n                //float amb = 0.2 + 0.5 * dot(nor, light2);\n                //col = vec3(0.2, 0.3, 0.4) * amb + vec3(0.85, 0.75, 0.65) * dif;\n                col = calccolor(col, col, -rd, light, light2, nor);\n                col = pow( col, vec3(0.7));\n            }\n        // gamma        \n            //col = sqrt(col);\n            tot += col;\n        }\n    //antiblick\n    tot /= float(AA * AA);\n    fragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}