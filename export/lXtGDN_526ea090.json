{"ver":"0.1","info":{"id":"lXtGDN","date":"1717030036","viewed":53,"name":"my firsty raymarching shader","username":"Gnufoo","description":"my first raymarching shader!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rotates an object around an axis\nmat2 rotate2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Returns the smooth minimum of two values\nfloat smoothmin( float a, float b, float k )\n{\n    k *= 2.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\n// Returns the distance from a sphere at point p with radius r\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Returns the distance from a box at point p with dimensions b\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Returns the distance to the closest object in the scene\n\nfloat map(vec3 p) {\n    vec3 spherePosition = p;\n    \n    spherePosition.x += sin(iTime * 0.4);\n    spherePosition.y += pow(5.0, cos(iTime * 0.4));\n    \n    spherePosition = fract(spherePosition) - 0.5;\n    \n    float sphere = sdSphere(spherePosition, 0.01);\n    \n    vec3 boxPosition = p; // Input copy\n    \n    boxPosition = fract(boxPosition) - 0.5;\n    \n    boxPosition.xz = boxPosition.xz * rotate2D(iTime);\n    boxPosition.xy = boxPosition.xy * rotate2D(iTime);\n    \n    float box = sdBox(boxPosition, vec3(0.14)); // A cube with side length 0.1\n        \n    return smoothmin(sphere, box, 0.05);\n}\n\nvec3 getNormal(vec3 position) {\n    const float epsilon = .0001;\n    \n    vec3 normal = vec3(\n        map(position + vec3(epsilon, 0.0, 0.0)) - map(position - vec3(epsilon, 0.0, 0.0)),\n        map(position + vec3(0.0, epsilon, 0.0)) - map(position - vec3(0.0, epsilon, 0.0)),\n        map(position + vec3(0.0, 0.0, epsilon)) - map(position - vec3(0.0, 0.0, epsilon))\n    );\n    \n    return normalize(normal);\n}\n\n\nconst int MAX_ITERATIONS = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert the fragCoord to clip space\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Initialization\n    \n    // Ray origin placed behind the origin\n    vec3 rayOrigin = vec3(0.0, 0.0, -3);\n    \n    // Normalized ray direction of the current pixel\n    vec3 rayDirection = normalize(vec3(uv.xy, 1.0));\n    \n    // Color of the pixel\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    float rayDistance = 0.0;\n    \n    // Raymarching\n    \n    vec3 currentRayPosition;\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        // Current position along the ray\n        currentRayPosition = rayOrigin + rayDirection * rayDistance;\n\n        // Distance to the closest object in the scene\n        float d = map(currentRayPosition);\n        \n        // Stop iterating if we are inside an object\n        if (d < 0.001) {\n            break;\n        }\n        \n        // Stop iterating if we are too far away\n        if (rayDistance > 100.0) {\n            break;\n        }\n\n        // Add the distance to our ray\n        rayDistance += d;\n    }\n    \n        \n    // Get the pixel color, invert it, and then paint it\n    color = vec3(rayDistance / 5.0);\n    \n    color = 1.0/color;\n    \n    vec3 paintColor = vec3(0.000,0.502 + 1.0,0.251);\n    \n    vec3 lightDirection = normalize(vec3(2, -1, 0));\n\n    vec3 normal = getNormal(currentRayPosition);\n    \n    float light = dot(-lightDirection, normal);\n    \n    fragColor = vec4(paintColor, 1) * light;\n}","name":"Image","description":"","type":"image"}]}