{"ver":"0.1","info":{"id":"mlyBzR","date":"1701766487","viewed":78,"name":"clelie","username":"Efim","description":"https://mathcurve.com/courbes3d.gb/clelie/clelie.shtml","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","clelie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this solve of FabriceNeyret2, very short template\n//M - sdf function for clelie\n\n#define PI  3.14159265359\n#define TAU 6.28318530718\n\n#define N        normalize\n#define r(f)     mat2( cos(f + vec4(0,33,11,0)) )   // rotation \n\nfloat t;\n\nfloat M(vec3 p)                                     // map: sdCeli\n{\n    p.yz *= r( t);\n    p.xy *= r(-t);\n    float  n = 2.,\n           l = length(p.xy),\n           L = mod( atan(p.y,p.x)/3.14, 2. ) *n;\n    return length(vec2( length(p)/2.-.5,\n                        l* sin( ( (fract(L)-.5)*3.14 + atan(p.z,l)/sign(mod(L,2.)-1.) ) *.5/n )\n                 )    ) -.03;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 m, R = iResolution.xy, e = vec2(1,-1)/1e4;\n    t = iMouse.z > 0. ? m = ( 2.*iMouse.xy - R ) / R.y, 0. // mouse or auto-demo\n                      : iTime;\n  \n    vec3 p; p.z = 2.;                               // camera\n    p.yz *= r(m.y*3.14);                            // camera rotation\n    p.xz *= r(m.x*6.28);\n   \n    int k;     // antialiasing AxA\n    \n    #if HW_PERFORMANCE==0\n    #define A 1\n    #else\n    #define A 2\n    #endif\n    \n    for( O *= 0.; k < A*A; k++ )\n    {   vec3 p = p, \n             n = N(-p),\n             r = N(vec3(n.z,0,-n)),                 // ray direction\n             d = N(   mat3( r, cross(n,r), n )\n                    * vec3( ( 2.*( U +vec2(k%A,k/A)/float(A)-.5 ) - R ) / R.y, 1.5 ) \n                  );\n   \n        float t, E = .001, h = E;                   // --- ray-march\n        for (int i; i++ < 128 && h >= E && t < 5. ; )\n            t += h = M( p += d*h );    \n        \n        t < 5. ?                                    // if hit:\n            n = N( e.xyy* M(p + e.xyy ) +           // normal\n                   e.yyx* M(p + e.yyx ) + \n                   e.yxy* M(p + e.yxy ) + \n                   e.xxx* M(p + e.x   ) ),  \n            O +=  vec4(.2  ,.3,.4 ,0) * (.5 + .5*dot( n, vec3(0, .7,-.7)) )     // ambiant\n                + vec4(.85,.75,.65,0) * max(     dot( n, vec3(0, .7, .7)), .2 ) // diffuse\n          : O ;\n    }\n\n    O = sqrt( O ) / float(A);                       // sRGB\n}","name":"Image","description":"","type":"image"}]}