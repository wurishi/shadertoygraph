{"ver":"0.1","info":{"id":"ttXGDr","date":"1556039108","viewed":68,"name":"color dumpling","username":"sako","description":"I want to solve edge noise...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float epsilon = 0.00001;\nconst float PI = 3.14159265;\nconst int rayLoopCount = 128;\nvec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n\nstruct camera{\n    vec3 position;\n    float fov;\n} cam;\n\n\n// util func\n//-------------------------------------------------------------------------------------\nfloat deg2rad(float angle){\n    return angle * PI / 180.0;\n}\n\n// dist func\n//-------------------------------------------------------------------------------------\n\n// box distance fuction\nfloat distBox(vec3 p, vec3 size){\n    vec3 q = abs(p);\n    return length(max(q - size, 0.0));\n}\n\n// shere distance fuction\nfloat distSphere(vec3 pos, float size, vec3 sPos)\n{\n    return length(pos - sPos) - size; \n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec3 onRep(vec3 p, float interval){\n    return mod(p, interval) - interval * 0.5;\n}\n\nvec3 foldX(vec3 p) {\n    p.x = abs(p.x);\n    return p;\n}\n\nvec3 foldY(vec3 p) {\n    p.y = abs(p.y);\n    return p;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n// scene\n//-------------------------------------------------------------------------------------\n\nfloat sceneDist(vec3 pos){\n    vec3 fPos = pos;\n    fPos = rotate(fPos, iTime*3.0, vec3(0, 1, 1));\n    fPos = foldX(fPos);\n    fPos = foldY(fPos);\n    float random = sin(iTime+floor(pos.y*2.0));\n    float sphere = distSphere(fPos, 0.3, vec3(0.5, 0.5, random));\n    vec3 pollFPos = fPos -vec3(0.5, 0.5, 2.0);\n    pollFPos = rotate(pollFPos, PI/2.0, vec3(1.0, 0.0, 0.0));\n    float poll = sdVerticalCapsule(pollFPos, 4.0, 0.05);\n\n\n    float dist = min(poll, sphere);\n    return dist;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    return normalize(vec3(\n        sceneDist(pos + vec3(epsilon, 0., 0.)) - sceneDist(pos - vec3(epsilon, 0., 0.)),\n        sceneDist(pos + vec3(0., epsilon, 0.)) - sceneDist(pos - vec3(0., epsilon, 0.)),\n        sceneDist(pos + vec3(0., 0., epsilon)) - sceneDist(pos - vec3(0., 0., epsilon))\n    ));\n}\n\nfloat genShadow(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for(float t=0.0; t<100.0; t++){\n        h = sceneDist(ro+rd*c);\n        if(h<epsilon){\n            return shadowCoef;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvec3 trace(vec2 uv){\n    vec3 col = vec3(0.0);   \n    vec3 bgCol = vec3(1.2, 1.1, 1.2);\n    bgCol += length(uv-vec2(0.5/min(iResolution.x, iResolution.y)))/8.0; \n    vec2 cp = vec2(3.0 * cos(iTime), 3.0 * sin(iTime));\n    cam.position = vec3(cp.x, cp.y, -3.0*(cos(iTime)+1.0)-5.0);\n    cam.fov = 30.0;\n    \n    //trace\n    float fov = deg2rad(cam.fov / 2.0);\n    \n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(lookAt-cam.position);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n    \n\n    vec3 ray = normalize(forward + fov*uv.x*right + fov*uv.y*up);\n    vec3 cur = cam.position;\n    \n    //dist\n    float dist;\n    for (int i=0; i < rayLoopCount; i++)\n    {\n        dist = sceneDist(cur);\n        if (dist < epsilon)\n        {\n        break;\n        }\n        cur += ray * dist;\n    }\n    \n    vec3 outcol = vec3(1.0);\n    if(dist <= epsilon){\n        vec3 normal = getNormal(cur);\n    \n        float diff = dot(normal, lightDir);\n        // float shadow = genShadow(cur + normal * epsilon, lightDir);\n        // return bgCol;\n        vec3 ambient = vec3(0.2);\n        vec3 diffcol = vec3(1.0);\n        diffcol = vec3(floor(normal.x*10.0), fract(uv.x*3.0), floor(normal.y*10.0));\n        diffcol += vec3(0.5);\n        // diffcol = vec3();\n        col = vec3(diff)*diffcol + ambient;\n        // col = col * max(0.5, shadow);\n        \n        \n        outcol = col;\n    }else{\n        outcol = bgCol;\n    }\n    outcol *= 1.-length(uv-vec2(0.5/min(iResolution.x, iResolution.y)))/4.0; \n    \n    return outcol;\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    fragColor = vec4(trace(uv), 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}