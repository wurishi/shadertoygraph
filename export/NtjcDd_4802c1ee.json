{"ver":"0.1","info":{"id":"NtjcDd","date":"1650524391","viewed":73,"name":"Bouncy Ball","username":"nathan84","description":"Branchless implementation of a physically accurate bouncing ball with coefficient of restitution.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bouncy Ball\n// written by Nathan Damgaard\n\n// radius of the ball\n#define RADIUS 0.05\n\n// height that the ball starts at\n#define H 0.25\n\n// coefficient of restitution\n// note: don't set this to 0.\n#define k 0.9\n\n// acceleration of gravity in m/s^2\n#define g 9.81\n\n// this is required to keep n from going to\n// infinity and crashing the shader.\n#define nlimit 200.\n\n#define HIT_DIST 0.001\n#define MAX_STEPS 200\n\n#define LOOP_TIME 3.5\n#define STEP_INTERVAL 0.02\n\nfloat bounce() {\n    float V = sqrt(2.*g*H);\n    float t0 = V/g;\n    float t = mod(iTime,LOOP_TIME)+t0;\n    float n = floor( log(.5*(k-1.)*t*g/V + 1.) / log(k) );\n          n = min(n, nlimit);\n    float v = V*pow(k,n);\n    float X = 2.*V/g * (pow(k,n)-1.)/(k-1.);\n    \n          t = mod(iTime,LOOP_TIME)+t0 - X;\n    float h = v*t - .5*g*pow(t,2.);\n    h = (n == nlimit) ? 0. : h;\n    \n    return h;\n}\n\nfloat sphereSDF( vec3 location, float radius, vec3 p ) {\n    return length(location-p)-radius;\n}\n\nfloat floorSDF( vec3 p ) {\n    return p.y;\n}\n\nvec4 unionSDF( vec4 d1, vec4 d2 ) {\n    return d1.x > d2.x? d2 : d1;\n}\n\nvec4 calculateDist( vec3 p ) {\n    vec3 sphereP = vec3(0.5*mod(iTime,LOOP_TIME)-0.51, RADIUS+bounce(), -0.5);\n    \n    vec4 d = vec4(sphereSDF( sphereP, RADIUS, p ),1.,0.,0.);\n         \n    /*float x  = mod(p.x*10.,1.);\n    float q1 = smoothstep(0.5-STEP_INTERVAL,0.5,x)+smoothstep(1.0,1.-STEP_INTERVAL,x)-1.;\n          x  = mod(p.z*10.,1.);\n    float q2 = smoothstep(0.5-STEP_INTERVAL,0.5,x)+smoothstep(1.0,1.-STEP_INTERVAL,x)-1.;*/\n    /*float q  = round(mod(p.z*10.,2.)/2.);\n          q  = floor(mod(p.x*10.+q,2.));*/\n    float q = abs(sign(mod(p.x*5.,1.)-0.5)+sign(mod(p.z*5.,1.)-0.5))/2.;\n    vec3 col = vec3(q);\n         d = unionSDF( d, vec4(floorSDF( p ),col)) ;\n    \n    return d;\n}\n\nvec3 getNormal( vec3 p ) {\n    vec2 e = vec2(HIT_DIST,0);\n    float d = calculateDist( p ).x;\n    vec3 n = vec3(\n            d-calculateDist(p-e.xyy).x,\n            d-calculateDist(p-e.yxy).x,\n            d-calculateDist(p-e.yyx).x\n            );\n    return normalize(n);\n}\n\nvec4 castRay( vec3 ro, vec3 rd ) {\n    vec4 d = vec4(0.);\n    vec3 rp = ro;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        rp += rd*d.x;\n        d = calculateDist(rp);\n        if( d.x <= HIT_DIST ) {\n            return vec4(length(rp-ro),d.yzw);\n        }\n    }\n    \n    return vec4(length(rp-ro),vec3(0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.2, -1.0);\n    vec3 rd = normalize(vec3(uv, 0.0)-ro);\n    \n    vec3 light = vec3(0., 1.0, -1.5);\n    \n    vec4 d = castRay( ro, rd );\n    vec3 rp = ro + rd*d.x;\n    vec3 normal = getNormal(rp);\n    vec3 toLight = normalize(light-rp);\n    float brightness = max(0.,dot(normal,toLight));\n    \n    // contributed by elenzil\n    if (brightness > 0.0) {\n        float shad = castRay( rp + normal * 0.01, toLight ).x;\n        if (shad < 100000.) {\n            brightness *= 0.6;\n        }\n    }\n    // -----\n    \n    vec3 col = brightness*d.yzw;\n\n    // do single bounce reflection\n    d = castRay( rp + normal * 0.01, normal );\n    if ( d.x < 100000. ) {\n        float old_brightness = brightness;\n        vec3 ray_pos = (rp + normal * 0.01) + normal*d.x;\n        toLight = normalize(light-ray_pos);\n        normal = getNormal( ray_pos );\n        brightness = max(0.,dot(normal,toLight));\n        \n        col += old_brightness*brightness*d.yzw;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}