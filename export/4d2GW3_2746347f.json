{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI 3.1415\n\n#define ENVIRONMENT 0\n#if(ENVIRONMENT == 0)\n\t#define RESOLUTION iResolution.xy\n\t#define TIME iTime\n\t#define OFFSET iMouse.xy/iResolution.xy\n\t#define POSITION fragCoord.xy\n\n\t#define DEPTH 4\n#elif(ENVIRONMENT == 1)\n\t#define RESOLUTION resolution.xy\n\t#define TIME time\n\t#define OFFSET offset\n\t#define POSITION fragCoord.yx\n\tuniform vec3 resolution;\n\tuniform float time;\n\tuniform vec2 offset;\n\n\t#define DEPTH 3\n#endif\n\n#define CHILDREN 3\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x+sin(a)*v.y, -sin(a)*v.x+cos(a)*v.y);\n}\n\nvec2 repeat_arc(vec2 pos, int n) {\n\tfloat a = atan(pos.y, pos.x);\n\tfloat s = 2.*PI/float(n);\n\treturn rotate(vec2(length(pos),0), mod(a,s)-s/2.);\n}\n\nfloat cog_teeth (float a) {\n\treturn 4.*clamp(2.*abs(mod(a/2./PI, 1.)-.5), .25, .75)-2.;\n}\n\nbool cog (vec2 pos, float r, float depth, int teeth) {\n\treturn length(pos) < r - depth*cog_teeth(float(teeth)*atan(pos.y, pos.x));\n}\n\nbool cogs(vec2 pos, float theta, float r1, float r2, float r3, float cog_depth, int cog_teeth) {\n\tfloat rm = (r2+r3)/2.;\n\tfloat ri = (r2-r3)/2.;\n\t\n\tbool result = false;\n\tfor(int i=0; i<DEPTH; i++) {\n\t\tfloat s_theta = (r2/rm)*(1.-r3/r2)*theta; // (r2/rm) is magic factor\n\t\tresult = result || cog(pos, r1, cog_depth, cog_teeth);\n\t\tresult = result &&!cog(pos, r2, cog_depth*ri/r1, int(float(cog_teeth)*r2/ri));\n\t\tresult = result || cog(rotate(pos, theta), r3, cog_depth*ri/r1, int(float(cog_teeth)*r3/ri));\n\t\tpos = rotate(repeat_arc(rotate(pos, s_theta*(r3/r2)), CHILDREN)-vec2(rm,0.), s_theta*(r3/ri))*r1/ri;\n\t}\n\treturn result;\n}\n\nbool cogs(vec2 pos, float theta) {\n\treturn cogs(pos, theta, 1., .8, .4, .1, 9);\n}\n\nbool cog_array(vec2 pos, float theta, float r, float depth, int teeth) {\n\tpos = mod(pos,4.*r);\n\tif(pos.x < 2.*r != pos.y < 2.*r) {\n\t\ttheta += PI/float(teeth);\n\t}\n\tpos = abs(pos-vec2(2.*r));\n\tpos = rotate(pos-vec2(r), theta);\n\treturn cog(pos, r, depth, teeth);\n}\n\nvec2 get_pos(vec2 fragCoord) {\n\treturn (POSITION-RESOLUTION/2.)/RESOLUTION.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfragColor = cogs(rotate(get_pos(fragCoord)+vec2(.4,0),-TIME/5.), TIME/3.) ? vec4(1) :\n\t\t\t\t\t\tcogs(rotate(get_pos(fragCoord)+vec2(-.5,+.4)-OFFSET/3., -TIME)*3., TIME) ? vec4(.5) : \n\t\t\t\t\t\tcog_array(get_pos(fragCoord)-OFFSET, TIME/3., .1, .01, 9) ? vec4(.1) : vec4(0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2GW3","date":"1394318473","viewed":933,"name":"Infinite Gears","username":"reuben364","description":"I made it to use as a live wallpaper on my phone and it has gone through a few iterations for it to be feasible. ","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","gears","grayscale","infinite"],"hasliked":0,"parentid":"","parentname":""}}