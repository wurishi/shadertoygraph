{"ver":"0.1","info":{"id":"ttVBWy","date":"1615005843","viewed":310,"name":"Phindoll Visualizer","username":"Mrpalland","description":"Fun visuals to Oliver Buckland's song https://soundcloud.com/oliver-buckland/radical-phindoll\n\nReference to char 'Phindoll' : JoelG's ENA Series: https://www.youtube.com/watch?v=juBv2XWnwt8\n\n(If music does not start, press pause then play on iChannel0)\n","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","music","audio","visualizer","dolphin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XllSWH","filepath":"https://soundcloud.com/oliver-buckland/radical-phindoll","previewfilepath":"https://soundcloud.com/oliver-buckland/radical-phindoll","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Song: https://soundcloud.com/oliver-buckland/radical-phindoll\n//Pixelated noise: https://www.shadertoy.com/view/lsf3WH\n//Frequency Separation: https://www.shadertoy.com/view/Msl3Rr\n//Sound Input: https://www.shadertoy.com/view/Xds3Rr\n//Raymarching Reference: https://iquilezles.org/articles/distfunctions\n//Referencing Animation: https://www.youtube.com/watch?v=juBv2XWnwt8\n\nvec2 rand2(vec2 co)\n{\n    vec3 a = fract(co.xyx*vec3(123.4, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y *a.z));\n}\n\nvec2 noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(1.4-2.0*f);\n\n    return mix( mix( rand2( i + vec2(0.0,0.0) ), \n                     rand2( i + vec2(1.0,0.0) ), u.x),\n                mix( rand2( i + vec2(0.0,1.0) ), \n                     rand2( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat freqs[4];\n\nfloat ring(vec3 p, vec3 rotation)\n{\n    vec3 s = sin(rotation);\n    vec3 c = cos(rotation);\n    p *= mat3(c.y*c.z, -s.z*c.x+c.z*s.y*s.x, s.z*s.x+c.z*s.y*c.x,\n                s.z*c.y, c.x*c.z+s.z*s.y*s.x, -c.z*s.x+s.z*s.y*c.x,\n                -s.y, s.x*c.y, c.x*c.y);\n    \n    vec2 d1 = abs(vec2(length(p.xz),p.y)) - vec2(1.2 + freqs[3]*0.2,0.2);\n    float c1 = min(max(d1.x,d1.y),0.0) + length(max(d1,0.0));\n    \n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - vec2(1.3 + freqs[3]*0.2,0.1 + freqs[0]*0.05);\n    float c2 = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    \n    return max(-c1, c2);\n    \n}\n\nfloat sphere(vec3 p, float r){\n    return length(p) - r;\n}\n\n#define PI 3.1459\n\nvec2 map(vec3 p){\n    float d = ring(p, vec3(iTime, 0., PI/4.0))+0.01;\n    d = min(d, ring(p, vec3(iTime*0.3, 0., -PI/4.0)))+0.01;\n    d = min(d, ring(p, vec3(PI/2.0, iTime, 0.)));\n    d = min(d, ring(p, vec3(iTime*1.4, iTime, 0.1)));\n    float s = sphere(p - vec3(0.,0.,0.6), 1.4 + freqs[3]*0.1);\n    d = max(-s, d);\n    \n    \n    return vec2(d, s);\n}\n\nvec3 getNormal(vec3 p)\n    {\n        vec2 e = vec2(0.02, 0.0);\n        vec3 n = map(p).x - vec3(\n            map(p - e.xyy).x,\n            map(p - e.yxy).x,\n            map(p - e.yyx).x);\n        return normalize(n);\n    }\n\nvec2 march(vec3 ro, vec3 rd){\n    vec2 dO = vec2(0.);\n    vec2 dS;\n\n    for(int i = 0; i < 50; i++)\n    {\n        vec3 p = ro + dO.x * rd;\n        dS = map(p);\n        dO += dS;\n        if(dS.x < 0.001 || dO.x > 100.) break;\t//ray isn't moving or has gone too far\n    }\n    \n    return vec2(dO);\n}\n\n#define TIMESCALE 0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 muv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //float freqs[4];\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    \n    //Basecolor (Arbitrary)\n    vec3 col = vec3(0.1);\n    \n    float minDist = 1000.;\n    float t = iTime*20.*TIMESCALE;\n    vec2 cell = vec2(0.); \n    \n    //Repeat grid for smaller sample\n    uv *= 5.0;\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    //Voronoi Calculation\n    for(float y = -1.0; y <= 1.0; y++){\n        for(float x = -1.0; x <= 1.0; x++){\n            vec2 offs = vec2(x,y);\n            \n            //Seed for random generation; interesting to add/mult dd or dv\n            vec2 seed = id+offs;\n            \n            vec2 n = rand2(seed);\n            vec2 p = offs + sin(n*t)*0.5;\n            float d = length(gv - p);\n            \n            if(d < minDist){\n                minDist = d;\n                cell = id+offs;\n            }\n        }        \n    }\n    \n    //Color (cell id + UV offset)\n    vec3 c1 = vec3(0.1, 0.9, 1.0);\n    vec3 c2 = vec3(0.1, 0.7, 1.0);\n    vec3 pink = vec3(0.84, 0.3, 0.7);\n    col.rgb = mix(c1, c2, 1. - (pow(minDist, 3.0)*2.5)+length(cell/(10.) + vec2(0.0, 1.0)) - freqs[3]*0.5);\n    \n    col.rgb += noise(uv*20.).x*0.03;\n    \n    //Dolphin Tail\n    vec2 iuv = (gv*10.0)*1.0*vec2(2.0+freqs[0]*0.5, 2.0);\n    float tail = iuv.y*0.3+abs(iuv.x)*0.08 - 0.6 + pow(abs(iuv.x)*0.2-0.7, 3.);\n    tail = clamp(tail, 0., 1.);\n    tail += clamp(-iuv.y*0.5 + 0.3 + -pow(abs(iuv.x)*0.2-0.7, 3.), 0., 1.);\n    tail += 2.0*clamp(-iuv.y*0.5 + 0.2 + -pow(abs(iuv.x)*0.2-0.7, 3.), 0., 1.);\n    tail -= iuv.y*clamp(iuv.y/iuv.y*0.09 - pow(abs(iuv.x), iuv.y), 0., 1.);\n    tail = 1.0 - clamp(tail, 0., 1.);\n    \n    col = mix(col, pink*1.6, vec3(smoothstep(0.0, 0.2, tail)));\n    \n    //Rows\n    float rows = fract(sin(iTime)*0.05 - freqs[0]*0.05 + uv.y*0.3 + .2);\n    float rowmask = floor(0.5 + rows); \n    float gnoise = noise(uv*10.0).x;\n    float pnoise = noise(uv*20.0).x;\n    \n    vec3 gold = vec3(1.0, 0.9, 0.0) * (1. - length(cell/(30.)));\n    \n    gold = gold * (rows +0.2)*1.5 + floor(0.52 + rows)*0.2 + gnoise*0.04;\n    gold = clamp(gold, 0., 1.);\n    \n    col = mix(col, gold, 1.0 - rowmask);\n    \n    //Raymarching Settings\n    vec3 ro = vec3(0., -.0, -3.4);\n    vec3 rd = normalize(vec3(muv.x, muv.y, 1.));\n    float circle = 1.0 - smoothstep(0.95, 1.0, length(uv + vec2(0., -0.0)) - 2.7 - freqs[3]*0.4 );\n    \n    col += smoothstep(0.0, 100.9 + freqs[3], 0.1*vec3(march(ro, rd).x/ 1.)) * (1.0 - circle) * length(gv.y);\n    \n    //bottom visualizer\n    float vis = texture( iChannel0, vec2(uv.x*.02 + .5,0.2) ).x;\n    vis = vis*5.0;\n\n    vis = ((1. - uv.y) + vis - 5.35);\n    float outline = vis + 0.3;\n    col = mix(col, vec3(0.9, 0.9, 0.9) + freqs[2]*0.3, clamp(clamp(outline, 0., 0.1)*30., 0., 1.));\n    \n    vis = smoothstep(0., 0.05, vis);\n    \n    col = mix(col, pink + freqs[2]*0.3 + pnoise*0.05, clamp(vis, 0., 1.));\n    \n    //Radiant Glow\n    col = mix(col, col*1.8, 1.0 - smoothstep(-2.0, 1.0, length(uv + vec2(0.0, 0.0)) - 5.3 - freqs[3]*2.0));\n    \n    //Phindoll\n    vec3 light = normalize(vec3(1., 1.4, -0.5));\n    \n    float phindoll = 1. - clamp(march(ro, rd).x / 50., 0., 1.);\n    vec3 phinnorm = normalize(getNormal(ro + rd * march(ro, rd).x));\n    vec4 cubemap = texture(iChannel1, phinnorm);\n    vec3 stars = (clamp(vec3(rand2(uv*0.2).x-rand2(uv*0.2).y)*8.0, .0, 8.0) - 7.);\n    \n    col = mix(col, stars, circle*(1.0 - phindoll));\n    \n    col = mix(col, cubemap.gbr*0.6 + clamp(cubemap.rgb*5.8 * vec3(1.0, 0.9, 0.0), 0., 2.) * clamp(dot(phinnorm, light), 0., 1.), smoothstep(0., 1., phindoll));\n    \n    //Gamma Correction\n    col = pow(col, vec3(0.74545));\n    \n    //col = vec3(smoothstep(0.0, 0.1, tail));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}