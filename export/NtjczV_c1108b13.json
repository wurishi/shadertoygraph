{"ver":"0.1","info":{"id":"NtjczV","date":"1650045796","viewed":140,"name":"northern light 2","username":"maetuni","description":"northern light","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["northernlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nfloat rand(float x)\n{\nreturn 1.0 - 2.0 * fract(sin(x)*43758.5453123);\n}\n\nfloat randSinWave(float x, float t, float c, float w, float seed)\n{\n    return sin(2.0 * PI * (1.0 / w * (-c * t + x) + rand(seed)));\n}\n\nfloat band(vec2 uv, float aspect, float yPos, float falloff, float bend, int sinNum, float offset)\n{\n    float w = 2.0;\n    float c = 0.5;\n    float a = 0.05;\n    float f = 0.0;\n    float t = iTime + offset;\n    \n    for(int i = 1; i <= sinNum; i++)\n    {\n        float r = float(i) * 0.6;\n        f += a * exp(-r) * randSinWave(uv.x, t , c * exp(-r) * rand(r), w * exp(-r), rand(r + 0.1));\n    }\n    \n    f += yPos + (uv.x - 0.5 * aspect) * (uv.x - 0.5 * aspect) * bend;\n    \n    float d = dot((uv - vec2(uv.x, f)),vec2(0.0, 1.0));\n    return smoothstep(0.3, 0.0, d) * smoothstep(0.0, 0.05, d) * smoothstep(0.0, 1.0, (1.0 - falloff * (uv.x - 0.5 * aspect) * (uv.x - 0.5 * aspect)));\n}\n\nvec4 background(vec2 uv, float aspect)\n{\n    vec3 backgroundCol = normalize(vec3(0.0, 0.8, 1.0)) * 0.6;   \n    float f = -0.1 * (uv.x - 0.5 * aspect) * (uv.x - 0.5 * aspect) + 1.5;\n    return vec4(backgroundCol * smoothstep(f , 0.0, uv.y), 1.0);\n}\n\nvec4 treeline(vec2 uv)\n{\n    float scale = 0.05;\n    float phase = uv.x * 0.5 * PI;    \n    float f = scale * sin(phase);\n    f += scale * 1.0 * sin(phase * 1.1 + 1.1 * PI);\n    f += scale * 0.9 * sin(phase * 3.0 + 2.0 * PI);\n    f += scale * 0.8 * sin(phase * 4.2 + 1.5 * PI);\n    f += scale * 0.7 * sin(phase * 5.3 + 2.5 * PI);\n    f += scale * 0.5 * sin(phase * 8.2 + 2.5 * PI);\n    f += 0.25;\n    float a = sin(phase * 1.1 + 1.2 * PI);\n    a += sin(phase * 10.0 + 1.4 * PI);\n    a += sin(phase * 15.0 + 1.6 * PI);\n    a += sin(phase * 30.0 + 1.8 * PI);\n    a = 0.5 * a + 0.5;\n    float t = scale * 0.1 * sin(phase * 100.0 + 1.1 * PI) * a;\n    t += scale * 0.1 * sin(phase * 200.0 + 1.1 * PI) * a;\n    t += scale * 0.1 * sin(phase * 300.0 + 2.0 * PI) * a;\n    t += scale * 0.1 * sin(phase * 400.0 + 1.5 * PI) * a;\n    t += scale * 0.1 * sin(phase * 500.0 + 2.5 * PI) * a;\n    t += scale * 0.05 * sin(phase * 1000.0 + 1.6 * PI) * a;\n    t += scale * 0.05 * sin(phase * 2000.0 + 1.8 * PI) * a;\n    t = abs(t);\n    f += t;\n    f = smoothstep(f, f + 0.01, uv.y);\n    return vec4(f, f, f, 1.0);\n}\n\nvec3 stars(vec2 uv)\n{\n    float f = rand(length(uv) * 0.1);\n    if(f > 0.999) return vec3(1.0, 1.0, 1.0);\n    else return vec3(0.0, 0.0, 0.0);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec3 col = stars(uv);\n\n    col += normalize(vec3(0.0, 1.0, 0.2)) * (band(uv, aspect, 0.7, 1.5, 0.2, 20, 0.0) + band(uv - vec2(0.1, 0.0), aspect, 0.5, 1.6, -0.2, 20, 1.0) + band(uv, aspect, 0.8, 1.5, 0.8, 20, -0.8));\n    \n    fragColor = mix(vec4(col, 1.0), background(uv, aspect), 0.5) * treeline(uv);\n}\n","name":"Image","description":"","type":"image"}]}