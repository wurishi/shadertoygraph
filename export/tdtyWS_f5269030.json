{"ver":"0.1","info":{"id":"tdtyWS","date":"1609141711","viewed":66,"name":"Happy & Tears","username":"usoppGod","description":"Emoticon Animation. Use Mouse Click and Drag.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["happy","sad","emoticon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a,b,t) smoothstep(a,b,t)\n// Smooth step delta\n#define SD(a,b,t) smoothstep(a,a+b,t)\n#define sat(a) clamp(a, 0.,1.)\nfloat Remap01 (float a, float b, float val )\n{\n    return (val-a)/(b-a);\n}\nfloat Remap01Clamped (float a, float b, float val )\n{\n    return clamp((val-a)/(b-a),0.,1.);\n}\nfloat Remap (float a, float b, float newA, float newB, float val )\n{\n    float ratio = sat((val-a)/(b-a));\n    return newA + (newB-newA)*ratio;\n}\nfloat Circle (vec2 uv, vec2 position, float radius, float blur)\n{\n \tuv -= position;\n    return S(radius, radius -blur,length(uv));\n}\nfloat Length (vec2 uv, vec2 position)\n{\n \tuv -= position;\n    return length(uv);\n}\n\nvec2 WithIn (vec2 uv, vec4 rect ) \n{\n \treturn (uv - rect.xy)/(rect.zw - rect.xy);   \n}\n\n// UV is 0,0 at left bottom to 1,1 at top right , with in the rect defined. all the other pixels beyond the rect will\n// have a uv < 0 or > 1 which can be ignored. \nvec4 Eye(vec2 uv, float rightSide, vec2 mousePos, float smile)\n{\n    uv -= 0.5; \n    float d = length( uv );\n    vec4 col = vec4( 1.);\n    col.a = SD(0.5, -0.02, d);\n    \n    vec4 irisColor = vec4(  .3, .5, 1., 1. );\n        \n    // the blue tint gradient \n    col.rgb = mix ( col.rgb, irisColor.rgb , S(0.1, 0.7, d)*0.7 );\n    \n    // black shadow below the eye \n    col.rgb = mix ( col.rgb, vec3(0.), S(0.45, 0.5, d) * 0.7 * sat( -uv.y-uv.x) );\n    \n    uv = uv - vec2(mousePos.x*rightSide, mousePos.y) * 0.4;\n    d = length( uv );\n    \n    // the black eye ball outline\n    col.rgb = mix ( col.rgb, vec3(0.), SD(0.3, -0.02, d));\n    \n    //The blue IRIS\n    irisColor.rgb *= (1. + S(0.3, 0.05, d));\n    col.rgb = mix ( col.rgb, irisColor.rgb, S(0.28, 0.27, d));\n    \n    vec2 uv2 = uv - vec2(mousePos.x*rightSide, mousePos.y) * 0.05;\n    vec2 uv3 = uv + vec2(mousePos.x*rightSide, mousePos.y) * 0.05;\n    float d2 = length( uv2 );\n\n    // Black at the center of eye \n    col.rgb = mix ( col.rgb, vec3(0.), SD( mix(0.32, 0.16, smile), -0.02, d2) );\n    \n    // Hightlight - because of light reflection\n    float tearyPos = ( sin(iTime*5.) *uv.y*uv.y*rightSide)* (1.-smile);\n    float highlight = Circle( uv3 , vec2( -0.15 * rightSide, 0.15) + vec2(tearyPos,0) , 0.1, 0.02);\n    highlight += Circle( uv3, vec2( 0.08 * rightSide, -0.08) + vec2(tearyPos,0), 0.07, 0.02);\n    col.rgb = mix ( col.rgb, vec3(1.), highlight);\n    \n    return col;\n}\n\nvec4 Head(vec2 uv, float smile)\t// -0.5<>0.5\n{\n    vec4 col = vec4( 196./255.,127./255.,0., 0.);\n    float d = length( uv );\n    \n    // the outer circle - we are restricting everything to with-in this \n    // this approach of setting alpha first will make sure that we do not cross the bounds by any mistake \n    col.a = Circle( uv, vec2(0.,0.), 0.5, 0.01); \n    \n    //Shadow \n    // 1 - 0<>0.3 => inside 1.0 - outside 0.7 \n    col.rgb *=  pow( 1. - S( 0.45, 0.48, d)*0.2, 2.);\n    \n    //outerRing\n    col.rgb = mix( col.rgb, vec3( 168./255.,76./255.,0.), SD(0.48,0.005, d));\n\n       \n    // Highlight on the top \n    float highlight = SD( 0.4, -0.005, d ); // 0<>1\n    highlight *= Remap( 0.4, -0.1, 1., 0., uv.y )*0.75;\n    \n    // Eye sockets \n    highlight -= Circle(uv, vec2(0.21,0.08), 0.19, 0.01);\n    \n    highlight = sat(highlight);\n    col.rgb = mix( col.rgb, vec3(1.), highlight);\n    \n    // Red Pigment \n    float cheek = Circle( uv, vec2(0.2, -0.15), 0.2, 0.15) * 0.4 * smile;\n    col.rgb = mix( col.rgb, vec3(1., 0.1, 0.1), cheek);\n    \n    return col;\n}\n\nvec4 Mouth (vec2 uv, float smile)\n{\n    uv -= 0.5; \n\n    float d = length( uv );\n\n    uv.y *= 1.5;\n    uv.y -= uv.x * uv.x * 2.;\n\n    float d2 = length(uv);\n    \n    //background color of mouth\n    vec4 col = vec4( .5, .18, .05, 1.);\n\n    // Creating a circle \n    float smileFactor = mix(d, d2, (smile+0.5)*0.66 );\n    //float smileFactor = mix(d, d2, (smile) );\n    col.a = S(0.5, 0.48, smileFactor );\n    \n    // Teeth\n    float teeth = Circle( uv, vec2(0.0, 0.6), 0.4, 0.03);\n    vec3 toothCol = vec3(1.) * S(0.6,0.35, d);// tooth shadow falloff\n    col.rgb = mix ( col.rgb, toothCol, teeth);\n\n    // Tounge\n    float tounge = Circle( uv, vec2(0.0, -0.5), 0.5, 0.3);\n    vec3 toungeCol = vec3(1., 0.5,0.5);\n    col.rgb = mix ( col.rgb, toungeCol, tounge);\n\n    return col;\n}\n\n// uv: -0.5<>0.5 mousePos: -0.5<>0.5 smile 0<>1\nvec4 Smiley(vec2 uv, vec2 mousePos, float smile)\n{\n    // Mirror rightside to leftside\n    float right = sign(uv.x);\n    uv.x = abs( uv.x );\n    \n    vec4 col = vec4( 0., 0., 0., 0.);\n    vec4 head = Head(uv, smile);\n    vec4 eye = Eye(WithIn(uv, vec4(0.03, -.1, 0.37, 0.25 )), right, mousePos, smile);\n    vec4 mouth = Mouth(WithIn(uv, vec4(-0.3, -.4, 0.3, -0.1 )), smile);\n    \n\n    col = mix ( col, head, head.a );\n    col = mix ( col, eye, eye.a );\n    col = mix ( col, mouth, mouth.a );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvOrig = fragCoord/iResolution.xy;\n    vec2 uv = (uvOrig - 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouseDirection = iMouse.xy/iResolution.xy;\n    mouseDirection -= 0.5;\n    \n    // to set the initial mouse direction to center of the screen. or else it will be (0,0) as it left bottom. \n    // on User tap, we are activating the mouseDirection.\n    mouseDirection =  sign( iMouse.zw*iMouse.zw ) * mouseDirection;\n    \n    float smile = (sin(iTime) + 1.) * 0.5; // 0<>1\n    \n    fragColor = Smiley(uv, mouseDirection, smile);\n}","name":"Image","description":"","type":"image"}]}