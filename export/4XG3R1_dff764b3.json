{"ver":"0.1","info":{"id":"4XG3R1","date":"1717254650","viewed":262,"name":"2024-06-01","username":"FoRenard","description":"ayo","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["livecoding","vj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    fragColor=texture(iChannel0,gl_FragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI=acos(-1.);\nconst float TAU=PI*2.;\n#define norm(x) normalize(x)\n#define rep(i, n) for(int i = 0; i < int(n); i++)\n#define sat(x) clamp(x,0.0,1.0)\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v ^= v >> 16u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\nvec2 orbit(float a)\n{\n    return vec2(cos(a),sin(a));\n}\nvec2 pmod(vec2 suv,float div)\n{\n    float shift=.0;\n    float a = mod(atan(suv.y,suv.x) + shift,TAU / div) - PI / div;\n    return orbit(a) * length(suv);\n}\nvec3 pcg33(vec3 v)\n{\n    uvec3 u = pcg3d(floatBitsToUint(v));\n    return vec3(u) / float(0xffffffffu);\n}\n// ortho basis\n// https://en.wikipedia.org/wiki/Osculating_plane\nmat3 getBNT(vec3 T)\n{\n    // camera rotation (may not be needed)\n    // float cr = 0.0;\n    // vec3 N = vec3(sin(cr), cos(cr), 0.0);\n    T = normalize(T);\n    vec3 N = vec3(0,1,0);\n    vec3 B = normalize(cross(N,T));\n    N = normalize(cross(T,B));\n    return mat3(B,N,T);\n}\n// Cyclic Noise by nimitz (explained by jeyko)\n// https://www.shadertoy.com/view/3tcyD7\n// And edited by 0b5vr\n// https://scrapbox.io/0b5vr/Cyclic_Noise\nvec3 cyclic(vec3 p, float freq)\n{\n    vec3 seed = vec3(1, 2, 3);\n    const int octaves = 8;\n    vec4 n = vec4(0);\n    mat3 bnt = getBNT(seed);\n\n    for(int i = 0; i < octaves; i++)\n    {\n        p += sin(p.yzx);\n        n += vec4(cross(cos(p), sin(p.zxy)), 1);\n        p *= bnt * freq;\n    }\n\n    return n.xyz / n.w;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define time iTime\n#define backbuffer iChannel0\n#define FC gl_FragCoord.xy\n#define RES iResolution.xy\nfloat alt,lt,atr,tr;\nint bt;\nvec2 asp,asp2;\nfloat bpm = 135.0;\n#define sc(x) pcg33(vec3(bt,x,4.291))\n#define sc4(x) pcg33(vec3(x,-1.123,bt/4))\n#define nsc(x) pcg33(vec3(bt+1,x,4.291))\nvec3 s0(vec2 suv)\n{\n    vec3 h = sc(0),h2 = sc(1);\n    vec3 col = sin(dot(h.xy * 10. - 5.,suv) + alt * (h.z * 10. - 5.) + h2 * TAU);\n    return col;\n}\nfloat s1sdf(vec3 p)\n{\n    vec3 op = p;\n    float rt = 0.5;\n    p.x = abs(p.x);\n    p.zy *= rot(p.x * rt);\n    p.xz *= rot(p.y * rt);\n    p.x -= 2.;\n    p.xy = pmod(p.xy * rot(alt * 0.1),4.0);\n    p.x -= 2.;\n    float w = 0.2;\n    return min(length(p.xy) - w,min(length(p.zy) - w,length(p.xz) - w)) + smoothstep(4.,8.,length(op));\n}\nvec3 s1normal(vec3 p)\n{\n    vec2 e = vec2(1e-4,0);\n    return normalize(vec3(s1sdf(p + e.xyy) - s1sdf(p - e.xyy),2. * e.x,s1sdf(p + e.yxy) - s1sdf(p - e.yxy)));\n}\nvec3 s1(vec2 suv)\n{\n    if(sc(13).x < 0.5)\n        suv.x = abs(suv.x);\n    vec3 col = vec3(0);\n    vec3 rp,ro,rd,dir;\n    float rt = mix(sc(4).x,nsc(4).x,atr);\n    float r = mix(4.,8.,rt);\n    ro = mix(norm(tan(sc(7) * 2. - 1.)),norm(tan(nsc(7) * 2. - 1.)),tr) * r;\n    dir = mix(sc(9),nsc(9),tr) * 2. - 1. - ro;\n    float z = (.7 + length(suv) * mix(-0.5,0.5,mix(sc(11),nsc(11),tr).x)) * mix(0.5,4.0,mix(sc(10),nsc(10),tr).x);\n    rd = getBNT(dir) * normalize(vec3(suv,z));\n    float l = 0.,d;\n    bool hit = false;\n    rep(i,99)\n    {\n        rp = ro + rd * l;\n        l += d = s1sdf(rp) * 0.3;\n        if(d < 1e-4)\n        {\n            hit = true;\n            break;\n        }\n    }\n    vec3 n = hit ? s1normal(rp) : vec3(0,0,1);\n    col = cyclic(3. * cyclic(rd * 2.,1.) + alt * 0.5 + n * 5.,1.0).xxx;\n    col *= float(hit);\n    col = pow(sat(col),vec3(0.4545)) * 1.5;\n    return col;\n}\nvoid settime(float t)\n{\n    alt = lt = t;\n    atr = fract(lt);\n    tr = tanh(atr * 5.);\n    bt = int(lt);\n    lt = tr + float(bt);\n}\nvec4 main_ayo()\n{\n    vec2 fc = FC,res = RES;\n    asp = res / min(res.x,res.y);\n    asp2 = res / max(res.x,res.y);\n    vec2 uv = fc / res,suv = (uv * 2. - 1.) * asp;\n    settime(time*bpm/60.);\n    if((bt/4)%2<1)\n        settime(alt-cyclic(vec3(suv,alt * 0.3),1.0).x);\n    vec3 col=s1(suv);\n    float ema=float(bt%4<1);\n    vec2 sd=vec2(0);\n    vec3 back=texelFetch(backbuffer,ivec2(fc+sd),0).rgb;\n    back = (iFrame%4<1?abs(col - back):back);\n    col = mix(col,back,ema);\n    return vec4(sat(col),1);\n}\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){fragColor=main_ayo();}","name":"Buffer A","description":"","type":"buffer"}]}