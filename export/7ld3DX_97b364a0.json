{"ver":"0.1","info":{"id":"7ld3DX","date":"1636888836","viewed":406,"name":"Desert Bloom","username":"panna_pudi","description":"Purge this desert!","likes":41,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","flower","grass","hex","desert","cracks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Desert Bloom by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I felt like I wanted to do something cute and I didn't have\n// much experience with 2D effects. So I came across some shaders\n// from Fabrice that impressed me. For desert there're 2nd order\n// Voronoi and applied noise on the edges between individual cell. \n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wwrighter, Shane,\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n//\n// Vorocracks marble/cracks by Fabrice\n// https://www.shadertoy.com/view/Xd3fRN\n//\n// Hexagonal Voronoi Line Distance by Shane\n// https://www.shadertoy.com/view/4dSfzD\n// \n// Sakura Bliss by Philippe Desgranges\n// https://www.shadertoy.com/view/ts33DX\n\nconst float PI = 3.14159265359;\nconst float TAU = 2. * PI;\n\n// 2d rotation matrix\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct HexGrid {\n    vec2 uv;\n    vec2 id;\n    float dist;\n};\n\nconst float SQRT3 = sqrt(3.);\nfloat hex_dist(vec2 p) {\n    p = abs(p);\n    // Multiplying by 0.5 is the same as using normalize()\n    float d = dot(p, 0.5 * vec2(1., SQRT3));\n    return max(d, p.x);\n}\n\nHexGrid hex_coords(vec2 p) {\n    const vec2 r = vec2(1., SQRT3);\n    const vec2 h = r / 2.;\n    vec2 a = mod(p, r) - h;\n    vec2 b = mod(p - h, r) - h;\n\n    vec2 gv = dot(a, a) < dot(b, b) ? a : b;\n\n    vec2 id = p - gv;\n    float dist = 0.5 - hex_dist(gv);\n    return HexGrid(gv, id, dist);\n}\n\nvec2 pix_to_hex(vec2 p) {\n    return floor(vec2(p.x + p.y / SQRT3, 2. * p.y / SQRT3));\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\n\nvec2 hash22(vec2 p) {\n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(262144, 32768) * n);\n    return sin(p * TAU) * 0.5 + 0.5;\n}\n\n// Random point on the hexagonal grid\nvec2 hex_pt(vec2 p) {\n    return vec2(p.x - p.y * 0.5, SQRT3 / 2. * p.y) +\n           (hash22(p) - 0.5) * SQRT3 / 2. / 2.;\n}\n\n// IQ's polynomial-based smooth minimum function.\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// 2-pass voronoi traversal\nfloat voronoi(vec2 p) {\n    vec2 hex_p = pix_to_hex(p);\n\n    // LUT for possible cells for traversal\n    const vec2 offsets[7] = vec2[7](vec2(-1), vec2(0, -1), vec2(-1, 0), vec2(0),\n                               vec2(1), vec2(1, 0), vec2(0, 1));\n\n    vec2 min_cell_id = vec2(0.);\n\n    vec2 mo;\n\n    float min_dist = 8., smooth_edge_dist = 8., ln_dist, d;\n    for (int i = 0; i < 7; ++i) {\n        vec2 h = hex_pt(hex_p + offsets[i]) - p;\n        d = dot(h,h);\n        if (d < min_dist) {\n            min_dist = d;\n            mo = h;\n            min_cell_id = offsets[i];\n        }\n    }\n\n    for (int i = 0; i < 7; ++i) {\n        vec2 h = hex_pt(hex_p + offsets[i] + min_cell_id) - p - mo;\n\n        if (dot(h,h) > 0.00001) {\n            ln_dist = dot(mo + h * 0.5, normalize(h));\n            smooth_edge_dist = smin(smooth_edge_dist, ln_dist, 0.1);\n        }\n    }\n\n    return max(smooth_edge_dist, 0.);\n}\n\n// type of Perlin noise\nint MOD = 0;\n\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = smoothstep(0., 1., f);\n\n    float v =\n        mix(mix(hash21(i + vec2(0, 0)), hash21(i + vec2(1, 0)), f.x),\n            mix(hash21(i + vec2(0, 1)), hash21(i + vec2(1, 1)), f.x), f.y);\n    return MOD == 0 ? v\n           // Other two has more sharp edges.\n           : MOD == 1 ? 2. * v - 1.\n           : MOD == 2 ? abs(2. * v - 1.)\n                      : 1. - abs(2. * v - 1.);\n}\n\n#define noise22(p) vec2(noise2(p), noise2(p + 17.7))\nvec2 fbm22(vec2 p) {\n    vec2 v = vec2(0);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 6; i++, p *= 2., a /= 2.)\n        p *= R,\n        v += a * noise22(p);\n\n    return v;\n}\n\nvec3 cracks(vec2 p) {\n    const float RATIO = 0.9;\n    const float STONE_SLOPE = .2;\n    const float FRACTAL_DEPTH = 2.;\n    const float FRACTAL_SCALE = 1.9;\n    const float NOISE_SCALE = 1.73;\n    const float NOISE_AMP = 0.6;\n    const float BEVEL = 50.;\n    const float GAP = .01;\n\n    vec3 col = vec3(0.);\n    for (float i = 0.; i < FRACTAL_DEPTH; ++i) {\n        // Scale down\n        vec2 crack_cell = p / RATIO;\n        // Compute the magnitude of distortions on the path\n        vec2 deviation = NOISE_AMP * fbm22(p / NOISE_SCALE) * NOISE_SCALE;\n        // Find the distance to the neares crack\n        float dist = voronoi(crack_cell + deviation);\n        dist = clamp(BEVEL * (dist - GAP), 0., 1.);\n\n        dist *= 1. - STONE_SLOPE * dist;\n\n        // Exposure\n        col += vec3(1. - dist) / exp2(i);\n\n        // Shrink and rotate next layer\n        p *= FRACTAL_SCALE * rot(0.37);\n    }\n\n    return 1. - col;\n}\n\nfloat back_out(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (pow(f, 2.0) - f * 0.8 *sin(f * PI));\n}\n\n// Returns vec4(color, distance)\nvec4 draw_lotus(vec2 uv, vec2 id, float blur, float len) {\n    vec2 rnd = noise22(id);\n    // Computes the angle of the flower with a random rotation speed\n    float angle =\n        atan(uv.y, uv.x) * sign(rnd.x + 1e-10) + iTime * mix(-0.8, 0.8, rnd.y);\n\n    // Distance to the center of the flower\n    float transit = clamp(len, 0., 1.);\n    transit = back_out(transit);\n\n    float dist = length(uv) - (transit - 1.);\n\n    // Flower shaped distance function form the center\n    float petal = 1.0 - abs(sin(angle * 2.5));\n    float sqpetal = petal * petal;\n    petal = mix(petal, sqpetal, 0.7);\n    float sepal = 1.0 - abs(sin(angle * 2.5 + 1.5));\n    petal += sepal * 0.2;\n\n    float lotus_dist = dist + petal * 0.2;\n\n    // Compute a blurry shadow mask.\n    float shadow_blur = 0.3;\n    float shadow = smoothstep(0.5 + shadow_blur, 0.5 - shadow_blur, lotus_dist) * 0.4;\n\n    //Computes the sharper mask of the flower\n    float lotus_mask = smoothstep(0.5 + blur, 0.5 - blur, lotus_dist);\n\n    // The flower has a pink hue and is lighter in the center\n    vec3 lotus_col = vec3(1.1, 0.8, 0.7);\n    lotus_col += (0.5 - dist) * 0.2;\n\n    // Computes the border mask of the flower\n    vec3 outline_col = vec3(1.0, 0.3, 0.3);\n    float outline_mask = smoothstep(0.5 - blur, 0.5, lotus_dist + 0.045);\n\n    // Defines a tiling polar_space for the pistil pattern\n    float polar_space = angle * 1.9098 + 0.5;\n    float polar_pistil = fract(polar_space) - 0.5; // 12 / (2 * pi)\n\n    // Round dot in the center\n    outline_mask += smoothstep(0.035 + blur, 0.035 - blur, dist);\n\n    float petal_blur = blur * 2.0;\n    float pistil_mask = smoothstep(0.12 + blur, 0.12, dist) *\n                        smoothstep(0.05, 0.05 + blur, dist);\n\n    // Compute the pistil 'bars' in polar space\n    float barw = 0.2 - dist * 0.7;\n    float pistil_bar = smoothstep(-barw, -barw + petal_blur, polar_pistil) *\n                      smoothstep(barw + petal_blur, barw, polar_pistil);\n\n    // Compute the little dots in polar space\n    float pistil_dot_len = length(vec2(polar_pistil * 0.10, dist) - vec2(0, 0.16)) * 9.0;\n    float pistil_dot = smoothstep(0.1 + petal_blur, 0.1 - petal_blur, pistil_dot_len);\n\n    //combines the middle an border color\n    outline_mask += pistil_mask * pistil_bar + pistil_dot;\n    lotus_col = mix(lotus_col, outline_col, clamp(outline_mask, 0., 1.) * 0.5);\n\n    //sets the background to the shadow color\n    lotus_col = mix(vec3(0.2, 0.2, 0.8) * shadow, lotus_col, lotus_mask);\n\n    //incorporates the shadow mask into alpha channel\n    lotus_mask = clamp(lotus_mask + shadow, 0., 1.);\n\n    // returns the flower in pre-multiplied rgba\n    return vec4(lotus_col, lotus_mask);\n}\n\n// vec4(color, distance)\nvec4 draw_leaf(vec2 q, float factor, vec2 dir) {\n    float scale = 12.;\n\n    // Rotate uv in particular direction.\n    {\n        // Originally each leaf facing up.\n        vec2 a = vec2(0., 1.);\n        // Find orthogonal direction by computing vector product in 3D\n        // cross(vec3(dir, 0), vec3(0, 0, 1))\n        dir = vec2(-dir.y, dir.x);\n\n        float angle =\n            atan(dir.y * a.x - dir.x * a.y, dir.x * a.x - dir.y * a.y);\n        q *= rot(angle);\n    }\n\n    // Distance from the center.\n    float r = length(q * scale) / factor;\n    // Mirrored polar angle.\n    float t = abs(atan(q.x, q.y) / PI);\n\n    // Scary polynomial to define the edge of leaf.\n    float leaf_edge = (11.0 * t - 6.0 * t * t * t + 6.0 * t * t * t * t * t) /\n                      (4.0 - 3.0 * t);\n    float leaf_blur = 0.9;\n\n    // Make darkened borders, but without of soft blur outside because\n    // of the limitations? of texture bombing.\n    float leaf =\n        1. - smoothstep(leaf_edge - leaf_blur, leaf_edge + leaf_blur, r);\n\n    // False shading for folded in half leaf.\n    leaf *= smoothstep(-0.3, 0.5, abs(q.x)) * 0.5;\n\n    vec3 leaf_color = 2.8 * vec3(0.11 * leaf, 0.69 * leaf, 0.14 * leaf);\n    return vec4(leaf_color, leaf);\n}\n\n\n// Defines the border between the different parts.\nfloat transit(vec2 uv) {\n    return uv.x - 0.5 + 0.35 * sin(uv.y * 3.);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord ) {\n    // Screen coordinates in [-1, 1] range with aspect.\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.);\n    uv *= 3.;\n    \n    // Distance between pixels for antialiasing.\n    float pix = fwidth(uv.x);\n    \n    // Separate coordinates and shifted from 0 by y to remove artifacts.\n    vec2 p = uv;\n    p -= vec2(iTime * 0.5, -4.5);\n    \n    // Initialize base color.\n    vec3 col = vec3(0.);\n    \n    // Hexagonal grid.\n    HexGrid gv = hex_coords(p);\n    vec2 id = gv.id;\n    \n    // Antialiazed mask to the border of hexagonal grid.\n    float hex_grid_border = smoothstep(0.02 - pix, 0.02 + pix, gv.dist);\n    vec2 gr = id + iTime * 0.5;\n    float edge = transit(gr);\n    \n    // Broken clay\n    {\n        // Compute broken clay pattern on local hex coordinates\n        // with offset based on index.\n        vec3 crack = cracks(gv.uv * 2.5 + id * 4.);\n        const vec3 desert = vec3(0.9726, 0.851, 0.300);\n        col = vec3(hex_grid_border * crack * desert);\n\n        // Add basic shading.\n        float shade = 1. - dot(gv.uv, normalize(vec2(1., -1.)));\n        col *= shade * crack * 1.5;\n    }\n\n    \n    // Flooding water\n    {\n        // Combine two masks.\n        edge = smoothstep(-0.1, 0.7, edge);\n\n        vec3 water = vec3(0.61, 0.705, 0.752);\n        col = mix(col, water, edge);\n        // To keep hex edge from disappearing\n        // float border = edge * hex_grid_border;\n        // col = mix(col, water, border);\n    }\n    \n    \n    vec2 q = p * 3.; // scaled screen coordinates.\n    vec2 cell = floor(q); // divide space on cells.\n    vec2 offset = fract(q); // local cell coordinates.\n\n    // Keep track of layering separate leaf based on priority.\n    float priority = 999.;\n\n    // The amount of neighbours to visit\n    int nbors = 1;\n    // Texture Bombing 101\n    // https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch20.html\n    // The basic idea behind texture bombing is to divide UV space into a regular\n    // grid of cells. We then place an image within each cell at a random location,\n    // using a noise or pseudo-random number function. The final result is the composite\n    // of these images over the background.\n    for (int u = -nbors; u <= nbors; ++u) {\n        for (int v = -nbors; v <= nbors; ++v) {\n            // Compute a new cell coordinates by shifting origin on integral offset.\n            vec2 cell_n = cell - vec2(u, v);\n            vec2 cell_offset = offset + vec2(u, v);\n\n            // Add more leaves in each cell for crowded overlapping.\n            for (float  n = 0.5; n < 3.; ++n) {\n                // Choose random place inside of cell\n                vec2 random_uv = hash22(cell_n + n);\n                vec2 off = cell_offset - random_uv;\n\n                float leaf_size; vec2 dir;\n                {\n                    // Recalculate hex coordinates for each cell\n                    // in very cumbersome way and will visit this\n                    // place later to:\n                    // 1. Choose leaf direction orthogonal to hex coords.\n                    // 2. Vary length depending on the distance to the edge.\n                    vec2 lu = cell_n + vec2(iTime * 1.5, 0.);\n                    lu /= 7.;\n                    HexGrid hb = hex_coords(lu - vec2(iTime * 0.5, 0.));\n\n                    float curvy_wall = lu.x + 0.5 + 0.2 * sin(lu.y * 3. + iTime * 0.3);\n                    float edge_mask = smoothstep(0.1 - 0.3, 0.1 , hb.id.y);\n\n                    leaf_size = clamp(curvy_wall * edge_mask, 0., 1.);\n\n                    vec2 k = hex_coords(cell_n).id - cell_n;\n                    dir = k + (hash22(random_uv + n) * 2. - 1.) * 0.25;\n                }\n\n                // We need to check adjacent cells for overlapping leaves.\n                // This process is computationally heavy and might be logical to\n                // split this function on two. The first for checking the hit `leaf.w`\n                // and coloring.\n                vec4 leaf = draw_leaf(off, leaf_size, dir);\n                if (leaf.w > 0. && random_uv.x < priority) {\n                    col = leaf.rgb;\n                    priority = random_uv.x;\n                }\n            }\n        }\n    }\n\n    \n    // Lotus flowers\n    {\n        float len = transit(gr + vec2(0.6, 0.));\n\n        float blur = 0.1;\n        vec4 lotus = draw_lotus(gv.uv * 1.3, gv.id, blur, len);\n        col = mix(col, lotus.rgb, lotus.w);\n    }\n\n    // Vignette\n    vec2 d = abs(fragCoord / iResolution.xy - vec2(0.5)) * 1.15;\n    d = pow(d, vec2(2.0));\n    col *= pow(clamp(1.0 - dot(d, d), 0., 1.0), 3.5);\n    \n    // Gamma Correction\n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColour = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}