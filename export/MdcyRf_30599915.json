{"ver":"0.1","info":{"id":"MdcyRf","date":"1676599201","viewed":402,"name":"Fastâ„¢ interactive raymarcher","username":"nilrem","description":"Try fullscreen (yes - on your machine!) and press:\n- WASD for left/right/forward/back\n- Shift/Space for down/up","likes":33,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","fps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on:\n//   Desert Canyon by shane\n//   https://www.shadertoy.com/view/Xs33Df\n// And bits and pieces from other places\n// Please let me know so I can give credit where credit is due :)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord / iResolution.xy;\n    \n    //vec3 col = texture( iChannel0, u ).rgb;\n    vec3 col = texelFetch( iChannel0, ivec2( fragCoord ), 0 ).rgb;\n    \n    // Edit: This shader needs gamma correction, so I've hacked this and a line above in\n    // to counter the dark shading... I'll do it properly later.\n    col = pow( max( col, 0. ), vec3( 0.75 ) );\n\n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    //u = fragCoord/iResolution.xy;\n    col *= pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .0625);\n\n    // Done.\n\tfragColor = vec4( clamp( col, 0., 1. ), 1.0 );\n    \n    #ifdef DEBUG_SHOW_DEPTH\n        #ifdef DEBUG_SHOW_MINDEPTH\n    \t\t#ifdef DEBUG_SHOW_MINDEPTH_BUFFER\n    \t\t\tfloat grayscale = texelFetch( iChannel1, ivec2( fragCoord / float(DEPTH_WIDTH) ), 0 ).w;\n            #else\n    \t\t\tfloat grayscale = sample_mindepth( fragCoord, iChannel1 );\n    \t\t#endif\n            //grayscale = pow( grayscale / 8., 8.0 );\n    \t\tgrayscale = grayscale / 16.;\n            fragColor = vec4( vec3( grayscale ), 1.0 );\n        #else\n            float grayscale = texelFetch( iChannel0, ivec2( fragCoord ), 0 ).w;\n            grayscale = pow( grayscale / 4., 8.0 );\n            fragColor = vec4( vec3( grayscale ), 1.0 );\n        #endif\n    #endif\n\n    // DEBUG\n    /*\n    //float val = texture( iChannel0, u ).w / 40.;\n    //float val = texture( iChannel1, u ).w / 40.;\n    float val = texture( iChannel1, u/float(DEPTH_WIDTH) ).w / 40.;\n    fragColor = vec4( vec3( clamp( val, 0., 1. ) ), 1.0 );\n\t*/\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define DEBUG_SHOW_LOGBISECT_ITERATIONS // Visualize number of iterations (lunar aesthetics ;))\n//#define DEBUG_SHOW_BISECT_ITERATIONS    // requires the above\n#define DEBUG_SHOW_BISECT_ITERATIONS_SCALE 2.0\n\n// What the hell did I do this for\n//#define DEBUG_EXPENSIVE_MAP\n\n//#define DEBUG_SHOW_DEPTH\n//#define DEBUG_SHOW_MINDEPTH\n//#define DEBUG_SHOW_MINDEPTH_BUFFER\n\n#define FREEWALK\n\n#define FLYTHROUGH_START 3.15\n#define FLYTHROUGH_SPEED 1.01\n\n#define FLYTHROUGH_MOUSE\n\n#define VIEWPLANE_Z        1.0\n\n// Ultimately requires WebGL compute shaders for net benefit\n//#define TEMPORAL_DEPTH_OPTIMIZATION\n\n//#define DISABLE_SHADOWS\n//#define DISABLE_NORMALS_CURVATURE\n#define DISABLE_AO\n\n#define DEPTH_WIDTH 8\n\n//#define NOISE_DETAIL\n#define AO_STEPS 1\n\n// Fresnel coefficient\n#define F0 0.18\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine\n#define FAR 60.\n\n#define SHADOW_START 0.2\n#define SHADOW_END   65.\n#define SHADOW_STEPS 26\n#define SHADOW_K     7.\n\n// Optimization\n#define NORMAL_CURVATURE_OPTIMIZATION\n\n#define LOGBISECT_STEPS      130\n#define BISECT_STEPS         12\n#define LOGBISECT_PRECISION  0.001\n#define BISECT_PRECISION     0.001\n\n// Conservative (somewhat):\n//#define LOGBISECT_STEPS      256\n//#define BISECT_STEPS         12\n//#define LOGBISECT_PRECISION  0.0005\n//#define BISECT_PRECISION     0.0005\n\n#define BUMPMAPPING_EPSILON  0.0015\n\n// Config\n#define CAM_SPEED\t\t\t6.0\n#define CAM_DEFAULT_POS\t\tvec3( 2.0, 1.2, 1.0 )\n#define CAM_DEFAULT_PITCH\t( -0.1 * M_PI_2 )\n#define CAM_DEFAULT_YAW\t\t(  0.17 * M_2PI  )\n\n#define CAM_MIN_PITCH\t\t( -0.48 * M_PI )\n#define CAM_MAX_PITCH\t\t(  0.48 * M_PI )\n\n#define MOUSE_SPEED_X\t\t3.1\n#define MOUSE_SPEED_Y\t\tMOUSE_SPEED_X\n\n#define SAMPLER_KEYBOARD\tiChannel1\n\n// State\n#define STATE_CAM_POS\t0\n#define STATE_CAM_DIR\t1\n#define STATE_CAM_EULER 2\n#define STATE_MOUSE     3\n#define STATE_LASTENTRY\t4\t// This must be the highest unused state number\n\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera\nconst float freqA = 0.15/3.75;\nconst float freqB = 0.25/2.75;\nconst float ampA  = 20.0;\nconst float ampB  = 4.0;\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice\nmat2 rot2( float th )\n{\n    vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x);\n}\n\n// 1x1 and 3x1 hash functions\nfloat hash1( float n ){ return fract(cos(n)*45758.5453); }\nfloat hash1( vec3 p ){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n// RGB to grayscale\nfloat getGrey( vec3 p )\n{\n    return dot( p, vec3(0.299, 0.587, 0.114) );\n}\n\n/*\n// IQ's smooth minium function. \nfloat sminP(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*( b - a )/s, 0., 1. );\n    return mix( b, a, h ) - h*( 1.0 - h )*s;\n}\n*/\n\n// Smooth maximum, based on the function above\nfloat smaxP( float a, float b, float s )\n{\n    float h = clamp( 0.5 + 0.5*( a - b )/s, 0., 1. );\n    return mix( b, a, h ) + h*( 1.0 - h )*s;\n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes\nvec2 path( in float z )\n{\n    return vec2( ampA*sin( z*freqA ), ampB*cos( z*freqB ) + 3.*( sin( z*0.025 ) - 1.) );\n}\n\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\n// more interesting scene, but had to keep things simple in order to accommodate slower machines\nfloat map( in vec3 p, sampler2D sampl )\n{\n    // Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\n    // texture but I'd much rather produce my own. From what I hear, Shadertoy will be providing\n    // fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\n    // happens, I'll really be able to do some damage. :)\n    float tx = textureLod( sampl, p.xz/16. + p.xy/80., 0.0 ).x;\n    \n    // A couple of sinusoidal layers to produce the rocky hills\n    vec3  q = p*0.25;\n    float h = dot( sin(q)*cos(q.yzx), vec3(.222) ) + dot( sin(q*1.5)*cos(q.yzx*1.5), vec3(.111) );\n    \n    \n    // The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added\n    float d = p.y + h*6.;\n    \n    // Reusing \"h\" to provide an undulating base layer on the tunnel walls\n    q  = sin( p*0.5 + h );\n    h  = q.x*q.y*q.z;\n    \n    #ifdef DEBUG_EXPENSIVE_MAP\n    for( float x = 0.1; x < 1.1; x += 0.1 )\n    {\n        q  += asin( asin( asin( abs(p*0.00001) + 0.0001*asin(abs(0.00001*h)+0.001) + 0.001 ) ) );\n\t    h  += 0.0000001 * q.x*q.y*q.z;\n    }\n    #endif\n    \n\t// Producing a single winding tunnel. If you're not familiar with the process, this is it\n    // We're also adding some detailing to the walls via \"h\" and the rocky \"tx\" value\n    p.xy  -= path(p.z);\n    float tnl = 1.5 - length( p.xy*vec2(.33, .66) ) + h + (1. - tx)*.25;\n    \n\t// Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\n    // detailing. I've also added a portion of the tunnel term onto the end, just because\n    // I liked the way it looked more. \n    return smaxP( d, tnl, 2. ) - tx*.5 + tnl*.8; \n}\n\n// Optimization\n// Ultimately requires WebGL compute shaders for net benefit\nfloat sample_mindepth( vec2 fragCoord, sampler2D mindepth_sampler )\n{\n    /*\n    vec2  invres   = 1. / iResolution.xy;\n    vec2  uvdepth  = ( floor( fragCoord ) / float(DEPTH_WIDTH) + .5 ) * invres;\n    */\n    //vec2  coord    = floor( fragCoord ) / float(DEPTH_WIDTH) + .5;\n    ivec2 coordi   = ivec2( fragCoord / float(DEPTH_WIDTH) );\n    float mindepth = 1000.;\n\n    for( int i = -1; i <= 1; i++ )\n    {\n        int cx = coordi.x + i;\n        \n        //if( cx < 0 ) continue;\n        \n        for( int j = -1; j <= 1; j++ )\n        {\n            int cy = coordi.y + j;\n            \n            //if( cy < 0 ) continue;\n            \n            float depth = texelFetch( mindepth_sampler, ivec2( cx, cy ), 0 ).w;\n            //float depth = texture( iChannel2, uvdepth + vec2( i, j ) * invres ).w;\n            \n            mindepth    = min( mindepth, depth );\n        }\n    }\n\n    //mindepth = max( 0., mindepth * 0.99 );\n    \n    return mindepth;\n}\n\n// Log-Bisection Tracing\n// https://www.shadertoy.com/view/4sSXzD\n//\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact: nmz@Stormoid.com\n//\n// Notes: This is a trimmed down version of Nitmitz's original. If you're interested in the function \n// itself, refer to the original function in the link above. There, you'll find a good explanation as to \n// how it works too\n//\n// For what it's worth, I've tried most of the standard raymarching methods around, and for difficult \n// surfaces to hone in on, like the one in this particular example, \"Log Bisection\" is my favorite\n\nfloat logBisectTrace( in vec3 ro, in vec3 rd, in float tstart, sampler2D sampl\n#ifdef DEBUG_SHOW_LOGBISECT_ITERATIONS\n\t, out vec2 iterations\n#endif\n\t\t\t\t\t\t\t)\n{\n    float t    = tstart;\n    float told = tstart;\n    float mid;\n    float dn;\n    \n    float d    = map( rd*t + ro, sampl );\n    float sgn  = sign( d );\n\t\n    int i;\n    for( i = 0; i < LOGBISECT_STEPS; i++ )\n    {\n        \n        told = t;\n        \n        // Branchless version of the following:   \n        // if(d>1.) t += d; else t += log(abs(d) + 1.1);\n        // NOTE: predicated optimizations done by most modern compilers, no need for this anymore\n        \n        //t += d;\n        //t += min( d, d*d );\n        \n        //t += step( d, 1. ) * ( log( abs(d) + 1.0 ) - d ) + d;\n        \n        //t += log(abs(d) + 1.1);\n        //t += d;//step(-1., -d)*(d - d*.5) + d*.5;\n        \n        if( d > 1. )  t += d * 1.0;\n        else          t += log( abs(d) + 1.0 );\n        \n        d = map( rd*t + ro, sampl );\n\n        // If the threshold is crossed with no detection, use the bisection method\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if( sign(d) != sgn || d < LOGBISECT_PRECISION || t > FAR )  break;\n    }\n\n    int ii;\n    \n    // If a threshold was crossed without a solution, use the bisection method\n    if( sign(d) != sgn )\n    {\n        // Based on suggestions from CeeJayDK, with some minor changes\n\n        dn = sign( map( rd*told + ro, sampl ) );\n        \n        vec2 interval = vec2( told, t ); // Near, Far\n\n        for( ii = 0; ii < BISECT_STEPS; ii++ )\n        {\n            //Evaluate midpoint\n            mid     = dot( interval, vec2( .5 ) );\n            float d = map( rd*mid + ro, sampl );\n            \n            if( abs(d) < BISECT_PRECISION )  break;\n            \n            // Suggestion from movAX13h\n            // Set mid to near or far, depending on which side we're on\n            interval = mix( vec2(interval.x, mid), vec2(mid, interval.y), step(0.0, d*dn) );\n        }\n\n        t = mid; \n    }\n    \n    #ifdef DEBUG_SHOW_LOGBISECT_ITERATIONS\n    \titerations = vec2( i, ii );\n    #endif\n    \n    //if (abs(d) < 0.001) t += d;\n\n    return min( t, FAR );\n}\n\n// Tetrahedral normal, courtesy of IQ\nvec3 normal( in vec3 p, sampler2D sampl )\n{  \n    vec2 e  = vec2( -1., 1. )*0.001;   \n\treturn normalize( e.yxx*map(p + e.yxx, sampl) + e.xxy*map(p + e.xxy, sampl) + \n\t\t\t\t\t  e.xyx*map(p + e.xyx, sampl) + e.yyy*map(p + e.yyy, sampl)   );\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n  = max( n*n, 0.001 );\n    n /= ( n.x + n.y + n.z );  \n    \n\treturn (  n.x * texture( tex, p.yz )\n            + n.y * texture( tex, p.zx )\n            + n.z * texture( tex, p.xy ) ).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total\nvec3 doBumpMap( in sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor )\n{\n    const float eps = BUMPMAPPING_EPSILON;\n    vec3 grad = vec3(  getGrey( tex3D( tex, vec3(p.x-eps, p.y, p.z), nor ) )\n                     , getGrey( tex3D( tex, vec3(p.x, p.y-eps, p.z), nor ) )\n                     , getGrey( tex3D( tex, vec3(p.x, p.y, p.z-eps), nor ) ) );\n    \n    grad = ( grad - getGrey(tex3D(tex,  p , nor)) ) / eps; \n    \n    grad -= nor * dot( nor, grad );\n\t\n    return normalize( nor + grad*bumpfactor );\n}\n\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \n// through some cracks... kind of\nfloat softShadow( in vec3 ro, in vec3 rd, in float start, in float end, in float k, in sampler2D sampl )\n{\n    #ifndef DISABLE_SHADOWS\n        float shade = 1.0;\n\n        // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n        // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this\n        // If adding shadows seems to make everything look dark, that tends to be the problem\n        float dist = start;\n        float stepDist = end/float(SHADOW_STEPS);\n\n        // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n        // number to give a decent shadow is the best one to choose. \n        for (int i=0; i<SHADOW_STEPS; i++){\n            // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n            // you may hit a surface not between the surface and the light\n            float h = map(ro + rd*dist, sampl);\n            //shade = min(shade, k*h/dist);\n            shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n            // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n            // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results\n            // Anyway, here's some posibilities. Which one you use, depends on the situation:\n            // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n\n            // In this particular instance the light source is a long way away. However, we're only taking a few small steps\n            // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\n            // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\n            // shadows give that illusion... kind of\n\n            dist += clamp(h, 0.2, stepDist*2.);\n\n            // There's some accuracy loss involved, but early exits from accumulative distance function can help\n            if (abs(h)<0.001 || dist > end) break; \n        }\n\n        // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n        // look too brutal to me\n\n        return min(max(shade, 0.0) + 0.1, 1.0);\n    #else\n\t    return 1.0;\n    #endif\n}\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function and have been looking for an excuse to use it. For a better version, and usage, \n// refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist, sampler2D sampl )\n{\n    /*\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n    //const float nbIte = 2.0;\n    \n\t//const float falloff = 0.9;\n    \n    for( float i = 1.; i < nbIte + .5; i++ )\n    //for( float i = 2.; i < nbIte + .5; i++ )\n    {\n        l   = ( i + hash1(i) ) * .5 / nbIte * maxDist;\n        \n        ao += ( l - map( p + n*l, sampl ) ) / ( 1. + l ); // / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1. - ao / nbIte, 0., 1.);\n    */\n\n  \t#ifndef DISABLE_AO\n        float ao = 0.0, l;\n\n        //const float falloff = 0.9;\n\n        for( int i = 0; i < AO_STEPS; i++ )\n        {\n            float j   = float(i) + 1.1;\n                  l   = ( j + hash1( j ) ) * .5 / float(AO_STEPS) * maxDist;\n\n                  ao += ( l - map( p + n*l, sampl ) ) / ( 1. + l ); // / pow(1.+l, falloff);\n        }\n\n        return clamp( 1. - ao / float(AO_STEPS), 0., 1.);\n    #else\n    \treturn 1.0;\n    #endif\n}\n\n// More concise, self contained version of IQ's original 3D noise function\nfloat noise3D(in vec3 p)\n{\n    // Just some random figures, analogous to stride. You can change this, if you want\n\tconst vec3 s = vec3( 7, 157, 113 );\n\t\n\tvec3 ip = floor( p ); // Unique unit cell ID\n    \n    // Setting up the stride vector for randomization and interpolation, kind of\n    // All kinds of shortcuts are taken here. Refer to IQ's original formula\n    vec4 h = vec4( 0., s.yz, s.y + s.z ) + dot( ip, s );\n    \n    // Cell's fractional component\n\tp -= ip;\n\t\n    // A bit of cubic smoothing to give the noise that rounded look\n    // cubic hermite polynomial in horner's form\n    p  = p*p*( 3. - 2.*p );\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner\n    \n    vec4 val1 = fract( sin( h      ) * 43758.5453 );\n    vec4 val2 = fract( sin( h + s.x) * 43758.5453 );\n    \n    //vec4 val1 = hash4( h       );\n    //vec4 val2 = hash4( h + s.x );\n    \n    // Interpolation along X\n    h = mix( val1, val2, p.x );\n\t\n    // Interpolating along Y\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value\n    return mix(h.x, h.y, p.z); // Range: [0, 1]\n}\n\n// Simple fBm to produce some clouds\nfloat fbm(in vec3 p)\n{\n    // Four layers of 3D noise\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n\n}\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir)\n{\n\tfloat sun = max(dot(rd, sunDir), 0.0); // Sun strength\n\tfloat horiz = pow(1.0-max(rd.y, 0.0), 3.)*.35; // Horizon strength\n\t\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\n    // Mixing in the sun color near the horizon\n\tcol = mix(col, vec3(1, .9, .7), horiz);\n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better\n\tcol += 0.25*vec3(1, .7, .4)*pow(sun, 5.0);\n\tcol += 0.25*vec3(1, .8, .6)*pow(sun, 64.0);\n\tcol += 0.2*vec3(1, .9, .7)*max(pow(sun, 512.0), .3);\n    \n    // Add a touch of speckle, to match up with the slightly speckly ground\n    #ifdef SKY_NOISE_DETAIL\n    col = clamp(col + hash1(rd*107.1)*0.05 - 0.025, 0., 1.);\n    #endif\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that\n\tvec3  sc     = ro + rd*FAR*100.; sc.y *= 3.;\n    float clouds = 0.5*smoothstep(0.5, 1.0, fbm(.001*sc));\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit)\n\treturn mix( col, vec3(1.0,0.95,1.0), clouds * clamp(rd.y*4., 0., 1.) );\n}\n\n// Cool curve function, by Shadertoy user, Nimitz\n//\n// It gives you a scalar curvature value for an object's signed distance function, which \n// is pretty handy for all kinds of things. Here's it's used to darken the crevices\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n// calculations, I'm assuming. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, sampler2D sampl)\n{\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\n\n    vec2 e = vec2(-1., 1.)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx, sampl), t2 = map(p + e.xxy, sampl);\n    float t3 = map(p + e.xyx, sampl), t4 = map(p + e.yyy, sampl);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p, sampl))*amp + ampInit, 0., 1.);\n}\n\n// Original 5 taps + normal version by nimitz from: https://www.shadertoy.com/view/Xts3WM\n//5 taps total, returns both normal and curvature\nvec3 normal_curvature(in vec3 p, out float curv, in sampler2D sampl)\n{\n\t#ifndef DISABLE_NORMALS_CURVATURE\n        vec2 e = vec2(-1., 1.)*0.04;   \n        float t1 = map(p + e.yxx, sampl), t2 = map(p + e.xxy, sampl);\n        float t3 = map(p + e.xyx, sampl), t4 = map(p + e.yyy, sampl);\n\n        curv = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*map(p, sampl));\n\n        return normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    #else\n        curv = 0.0;\n        return normalize( vec3( 0.0, 0.0, 0.5 ) );\n    #endif\n}\n\n\n\n/*\n\tDesert Canyon\n\t-------------\n\n\tJust a simple canyon fly through. Since the laws of physics aren't adhered to (damn stray floating \n\trocks), you can safely assume the setting is a dry, rocky desert on a different planet... in an \n\talternate reality. :)\n\n\tI thought I'd do a daytime scene for a change. I like the way they look, but I find they require\n\tmore effort to light up correctly. In this particular example, I had to find the balance between\n\tindoor and outdoor lighting, but keep it simple enough to allow reasonable frame rates for swift \n\tcamera movement. For that reason, I was really thankful to have some of Dave Hoskins's and IQ's \n\texamples to refer to.\n\n\tThe inspiration for this particular scene came from Dr2's flyby examples. This is obviously less\n\tcomplicated, since his involve flybys with actual planes. Really cool, if you've never seen them.\n\n\tAnyway, I'll put up a more interesting one at a later date.\n\t\n\n\tOutdoor terrain shaders:\n\n\tElevated - iq\n\thttps://www.shadertoy.com/view/MdX3Rr\n\tBased on his (RGBA's) famous demo, Elevated\n\thttp://www.pouet.net/prod.php?which=52938\n\n\t// How a canyon's really done. :)\n\tCanyon - iq\n\thttps://www.shadertoy.com/view/MdBGzG\n\n\t// Too many good ones to choose from, but here's one\n\t// Mountains - Dave_Hoskins\n\thttps://www.shadertoy.com/view/4slGD4\n\n\t// Awesome\n    River Flight - Dr2\n    https://www.shadertoy.com/view/4sSXDG\n\n*/\n\n// Utility functions\n\n// Camera out vector from euler angles\nvec3 get_camera_direction_from_euler( in float pitch, in float yaw )\n{\n    vec3 cam_dir;\n    cam_dir.x       = cos( pitch ) * cos( yaw );\n    cam_dir.y       = sin( pitch );\n    cam_dir.z       = cos( pitch ) * sin( yaw );\n    cam_dir         = normalize( cam_dir );\n    return cam_dir;\n}\n\n// Camera matrix from camera out vector (orthonormal basis from normalized direction),\n//   using a left-handed coordinate system\n//\n// One way to think about this:\n//   Imagine the camera out (direction) vector as a normal vector, perpendicular to the view plane.\n//   The camera right and up vectors are then the tangent and bitangent vectors to that normal.\n//   Since there are an infinite number of possible combinations of tangent and bitangent vectors\n//   to any given normal vector (all perpendicular to each other), we use the world up vector\n//   as a reference, effectively constraining the camera roll angle to zero.\n//\n// The following is a fast variant of the Gram-Schmidt process which only works in 3D\n//   (using the 3-dimensional vector cross product)\n//   It is numerically stable as long as the angle between the camera out and world up vectors\n//   is sufficiently large (say, a degree or so, for single precision floats)\n//\n//   => We're fine as long as we aren't staring exactly at the zenith or floor centered beneath us\n//\nmat3 get_camera_matrix_from_direction( in vec3 cam_out )\n{\n\tvec3 world_up    = vec3( 0.0, 1.0, 0.0 );\n    \n    vec3 cam_right   = normalize( cross( cam_out, world_up ) );\n    \n    // Normalization is unnecessary here, since cam_right and cam_out\n    // are both unit vectors and perpendicular to each other\n    vec3 cam_up      = cross( cam_right, cam_out  );\n\n    // Camera out vector stays unmodified, any decent glsl compiler will optimize this \"pass-through\"\n    return mat3( cam_right, cam_up, cam_out );\n}\n\nvec3 get_virtual_pixel_from_fragcoord( in vec2 fragcoord, in vec2 resolution, in float viewplane_z )\n{\n    vec3   virtual_pixel = vec3( ( 2.0 * fragcoord.xy - resolution.xy ) / resolution.x, viewplane_z );\n    return virtual_pixel;\n}\n\nvec3 get_ray_direction_from_virtual_pixel( vec3 virtual_pixel, mat3 camera_matrix )\n{\n    vec3   ray_dir = camera_matrix * normalize( virtual_pixel );\n    return ray_dir;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SAMPLER_STATE\t\tiChannel0\n\nvec4 get_state( int texel_x )\n{\n    return texelFetch( SAMPLER_STATE, ivec2( texel_x, 0 ), 0 );\n}\n\n// Math constants\n#define M_PI       3.141592653589793\n#define M_2PI      6.283185307179586\n#define M_4PI      12.56637061435917\n#define M_PI_2     1.570796326794897\n#define M_PI_4     0.785398163397448\n#define M_INV_2PI  0.15915494             // inline constant on GCN\n\n// Keyboard input\n// Javascript character codes\n#define KEY_BACKSPACE\t8\n#define KEY_TAB\t\t\t9\n#define KEY_ENTER\t\t13\n#define KEY_SHIFT\t\t16\n#define KEY_CTRL\t\t17\n#define KEY_ALT\t\t\t18\n#define KEY_PAUSE\t\t19\n#define KEY_CAPSLOCK\t20\n#define KEY_ESCAPE\t\t27\n#define KEY_SPACE\t\t32\n#define KEY_PAGEUP\t\t33\n#define KEY_PAGEDOWN\t34\n#define KEY_END\t\t\t35\n#define KEY_HOME\t\t36\n#define KEY_LEFT\t\t37\n#define KEY_UP\t\t\t38\n#define KEY_RIGHT\t\t39\n#define KEY_DOWN\t\t40\n#define KEY_INSERT\t\t45\n#define KEY_DELETE\t\t46\n#define KEY_0\t\t\t48\n#define KEY_1\t\t\t49\n#define KEY_2\t\t\t50\n#define KEY_3\t\t\t51\n#define KEY_4\t\t\t52\n#define KEY_5\t\t\t53\n#define KEY_6\t\t\t54\n#define KEY_7\t\t\t55\n#define KEY_8\t\t\t56\n#define KEY_9\t\t\t57\n#define KEY_A\t\t\t65\n#define KEY_B\t\t\t66\n#define KEY_C\t\t\t67\n#define KEY_D\t\t\t68\n#define KEY_E\t\t\t69\n#define KEY_F\t\t\t70\n#define KEY_G\t\t\t71\n#define KEY_H\t\t\t72\n#define KEY_I\t\t\t73\n#define KEY_J\t\t\t74\n#define KEY_K\t\t\t75\n#define KEY_L\t\t\t76\n#define KEY_M\t\t\t77\n#define KEY_N\t\t\t78\n#define KEY_O\t\t\t79\n#define KEY_P\t\t\t80\n#define KEY_Q\t\t\t81\n#define KEY_R\t\t\t82\n#define KEY_S\t\t\t83\n#define KEY_T\t\t\t84\n#define KEY_U\t\t\t85\n#define KEY_V\t\t\t86\n#define KEY_W\t\t\t87\n#define KEY_X\t\t\t88\n#define KEY_Y\t\t\t89\n#define KEY_Z\t\t\t90\n#define KEY_NUMPAD0\t\t96\n#define KEY_NUMPAD1\t\t97\n#define KEY_NUMPAD2\t\t98\n#define KEY_NUMPAD3\t\t99\n#define KEY_NUMPAD4\t\t100\n#define KEY_NUMPAD5\t\t101\n#define KEY_NUMPAD6\t\t102\n#define KEY_NUMPAD7\t\t103\n#define KEY_NUMPAD8\t\t104\n#define KEY_NUMPAD9\t\t105\n#define KEY_MULTIPLY\t106\n#define KEY_ADD\t\t\t107\n#define KEY_SUBTRACT\t109\n#define KEY_DECIMAL\t\t110\n#define KEY_DIVIDE\t\t111\n#define KEY_F1\t\t\t112\n#define KEY_F2\t\t\t113\n#define KEY_F3\t\t\t114\n#define KEY_F4\t\t\t115\n#define KEY_F5\t\t\t116\n#define KEY_F6\t\t\t117\n#define KEY_F7\t\t\t118\n#define KEY_F8\t\t\t119\n#define KEY_F9\t\t\t120\n#define KEY_F10\t\t\t121\n#define KEY_F11\t\t\t122\n#define KEY_F12\t\t\t123\n#define KEY_NUMLOCK\t\t144\n#define KEY_SCROLLLOCK\t145\n#define KEY_SEMICOLON\t186\n#define KEY_EQUAL\t\t187\n#define KEY_COMMA\t\t188\n#define KEY_DASH\t\t189\n#define KEY_PERIOD\t\t190\n#define KEY_SLASH\t\t191\n#define KEY_BACKSLASH\t220\nbool is_key_down( int char_code )\n{\n    return texelFetch( SAMPLER_KEYBOARD, ivec2( char_code, 0 ), 0 ).x > 0.5;\n}\n\n// Mouse input\nstruct mouse_state\n{\n    vec2  pos_rel;\t\t\t// mouse movement since last frame\n    vec2  pos_abs;\t\t\t// absolute mouse position in current frame\n    vec2  pos_abs_last;\t\t// absolute mouse position in last frame\n    float button_pressed;\n};\n    \nvec4 pack_mouse_state( mouse_state mouse )\n{\n    return vec4( mouse.pos_abs_last, mouse.button_pressed, 0.0 );\n}\n\nmouse_state unpack_mouse_state( vec4 packed )\n{\n    return mouse_state( vec2( 0 ), vec2( 0 ), packed.xy, packed.z );\n}\n\n// Get to it\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Integer fragment coordinates\n    ivec2 frag = ivec2( floor(fragCoord) );\n\t\n    // MOAR performance (depends on hardware/driver though)\n    if( frag.y > 0 || frag.x >= STATE_LASTENTRY )\n    {\n        discard;\n    }\n    \n    // Load state\n    vec3  cam_pos       = get_state( STATE_CAM_POS ).xyz;\n    \n    float cam_pitch, cam_yaw;\n    {\n        vec2 cam_euler  = get_state( STATE_CAM_EULER ).xy;\n    \t\t cam_pitch  = cam_euler.x;\n    \t\t cam_yaw    = cam_euler.y;\n    }\n    \n    mouse_state mouse   = unpack_mouse_state( get_state( STATE_MOUSE ) );\n    \n    // Set default state in the first frame\n    if( iFrame == 0 )\n    {\n        cam_pos   = CAM_DEFAULT_POS;\n        cam_pitch = CAM_DEFAULT_PITCH;\n        cam_yaw   = CAM_DEFAULT_YAW;\n        \n        mouse.pos_rel        = vec2( 0 );\n        mouse.pos_abs        = vec2( 0 );\n        mouse.pos_abs_last   = vec2( 0 );\n        mouse.button_pressed = 0.0;\n    }\n    \n    // Update mouse input\n    if( iMouse.z > 0.0 )\n    {\t// Mouse button down\n        \n        if( mouse.button_pressed < 0.5 )\n        {\t// Mouse button just pressed down\n            mouse.button_pressed = 1.0;\n            mouse.pos_abs_last   = abs( iMouse.zw ) / iResolution.yy;\n        }\n   \t\t\n        mouse.pos_abs       = iMouse.xy / iResolution.yy;\n        mouse.pos_rel       = mouse.pos_abs - mouse.pos_abs_last;\n\t    mouse.pos_abs_last  = mouse.pos_abs;\n    }\n    else\n    {\n    \tmouse.button_pressed = 0.0;\n    }\n    \n    // Update euler angles\n    cam_pitch += mouse.pos_rel.y * MOUSE_SPEED_X;\n    cam_yaw   += mouse.pos_rel.x * MOUSE_SPEED_Y;\n    cam_pitch = min( cam_pitch, CAM_MAX_PITCH );\n    cam_pitch = max( cam_pitch, CAM_MIN_PITCH );\n    cam_yaw   = mod( cam_yaw  , M_2PI         );\n    \n    // Camera direction vector from euler angles\n    vec3 cam_out    = get_camera_direction_from_euler( cam_pitch, cam_yaw );\n    \n    // Camera matrix (orthonormal basis) from direction vector\n    mat3 cam_matrix = get_camera_matrix_from_direction( cam_out );\n    vec3 cam_right  = cam_matrix[0];\n    vec3 cam_up     = cam_matrix[1];\n    //vec3 cam_out  = cam_matrix[2];\t// Same as direction vector\n    \n    // Process keyboard input\n    if( is_key_down( KEY_W ) )\n    {\n        cam_pos += cam_out * CAM_SPEED * iTimeDelta;\n    }\n\telse if( is_key_down( KEY_S ) )\n    {\n        cam_pos -= cam_out * CAM_SPEED * iTimeDelta;\n    }\n    \n    if( is_key_down( KEY_A ) )\n    {\n        cam_pos -= cam_right * CAM_SPEED * iTimeDelta;\n    }\n    else if( is_key_down( KEY_D ) )\n    {\n        cam_pos += cam_right * CAM_SPEED * iTimeDelta;\n    }\n    \n    if( is_key_down( KEY_SPACE ) )\n    {\n        cam_pos.y += CAM_SPEED * iTimeDelta;\t// Move up and down along world up vector\n    }\n    else if( is_key_down( KEY_SHIFT ) )\n    {\n        cam_pos.y -= CAM_SPEED * iTimeDelta;\t// Move up and down along world up vector\n    }\n    \n    // Store state\n    if( frag.x == STATE_CAM_POS )\n    {\n        fragColor = vec4( cam_pos, 1.0 );\n    }\n    else if( frag.x == STATE_CAM_DIR )\n    {\n        fragColor = vec4( cam_out, 1.0 );\n    }\n    else if( frag.x == STATE_CAM_EULER )\n    {\n        fragColor = vec4( cam_pitch, cam_yaw, 0.0, 0.0 );\n    }\n    else if( frag.x == STATE_MOUSE )\n    {\n        fragColor = pack_mouse_state( mouse );\n    }\n    \n    return;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef TEMPORAL_DEPTH_OPTIMIZATION\n    \n    // WIP: project last frame into current frame\n    // (different from temporal reprojection, where the current frame is available)\n    \n    /*\n    vec2 invres = 1. / iResolution.xy;\n    vec2 uv     = ( float(DEPTH_WIDTH) * floor( fragCoord ) + .5 ) * invres;\n    \n    if( uv.x > 1.0 || uv.y > 1.0 )  discard;\n    \n    float mindepth = 1000.;\n    \n    for( int i = 0; i < DEPTH_WIDTH; i++ )\n    //for( int i = -DEPTH_WIDTH/2; i < DEPTH_WIDTH/2 + 1; i++ )\n    {\n        for( int j = 0; j < DEPTH_WIDTH; j++ )\n        //for( int j = -DEPTH_WIDTH/2; j < DEPTH_WIDTH/2 + 1; j++ )\n        {\n            float depth = texture( iChannel0, uv + vec2( i, j ) * invres ).w;\n            //float depth = textureLod( iChannel0, uv + vec2( i, j ) * invres, 0.0 ).w;\n            mindepth    = min( mindepth, depth );\n        }\n    }\n    */\n    \n    vec2 coord = float(DEPTH_WIDTH) * floor( fragCoord ) + .5;\n    \n    if( coord.x > iResolution.x || coord.y > iResolution.y )  discard;\n    \n    ivec2 coordi = ivec2( coord );\n    ivec2 resi   = ivec2( iResolution.xy );\n    \n    float mindepth = 10000.;\n    \n    //for( int i = 0; i < DEPTH_WIDTH; i++ )\n    for( int i = -DEPTH_WIDTH/2; i <= DEPTH_WIDTH/2; i++ )\n    {\n        int cx = coordi.x + i;\n        if( cx < 0 || cx > resi.x ) continue;\n        \n        //for( int j = 0; j < DEPTH_WIDTH; j++ )\n        for( int j = -DEPTH_WIDTH/2; j <= DEPTH_WIDTH/2; j++ )\n        {\n            int cy = coordi.y + j;\n            if( cy < 0 ) continue;\n\n            float depth = texelFetch( iChannel0, ivec2( cx, cy ), 0 ).w;\n            //float depth = texelFetch( iChannel0, ivec2( coord ) + ivec2( i, j ), 0 ).w;\n            mindepth    = min( mindepth, depth );\n        }\n    }\n    \n    fragColor = vec4( 0.0, 0.0, 0.0, mindepth );\n    \n    #endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// State\n#define SAMPLER_STATE      iChannel3\n\nvec4 get_state( int texel_x )\n{\n    return texelFetch( SAMPLER_STATE, ivec2( texel_x, 0 ), 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    \n    #ifdef FREEWALK\n        // Load state\n        vec3  cam_pos  = get_state( STATE_CAM_POS ).xyz;\n        vec3  cam_out  = get_state( STATE_CAM_DIR ).xyz;\n\n        // Camera matrix (orthonormal basis from camera direction)\n        mat3  cam_matrix    = get_camera_matrix_from_direction( cam_out );\n\n\t\tvec3  virtual_pixel = get_virtual_pixel_from_fragcoord( fragCoord, resolution, VIEWPLANE_Z );\n    \n        vec3  ray_dir       = get_ray_direction_from_virtual_pixel( virtual_pixel, cam_matrix );\n        vec3  ray_pos       = cam_pos;\n    \n    \tvec3 ro = ray_pos;\n    \tvec3 rd = ray_dir;\n    \n    #else\n        // Screen coordinates\n        vec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\n        // Camera Setup.\n        float flythrough_time  = iTime * FLYTHROUGH_SPEED + FLYTHROUGH_START;\n        #ifdef FLYTHROUGH_MOUSE\n              flythrough_time += iMouse.x*80./iResolution.x;\n        #endif\n        vec3 lookAt = vec3(0.0, 0.0, flythrough_time );  // \"Look At\" position.\n        vec3 ro = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n        // Using the Z-value to perturb the XY-plane.\n        // Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n        // synchronized with the distance function.\n        lookAt.xy += path(lookAt.z);\n        ro.xy += path(ro.z);\n\n        // Using the above to produce the unit ray-direction vector.\n        float FOV = 3.14159/3.; // FOV - Field of view.\n        vec3 forward = normalize(lookAt-ro);\n        vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n        vec3 up = cross(forward, right);\n\n        // Ray direction.\n        vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n\n        // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n        // Naturally, it's synchronized with the path in some kind of way.\n        rd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\n    \n    #endif  // FREEWALK\n    \n\t// Raymarching, using Nimitz's \"Log Bisection\" method. Very handy on stubborn surfaces. :)\n    \n    #ifdef TEMPORAL_DEPTH_OPTIMIZATION\n    \tfloat mindepth = sample_mindepth( fragCoord, iChannel2 );\n    #else\n    \tfloat mindepth = 0.0;\n    #endif\n    \n    float t = mindepth;\n    #ifdef DEBUG_SHOW_LOGBISECT_ITERATIONS\n    vec2 iterations;\n    #endif\n    \n    /*if( mindepth < FAR )*/  t = logBisectTrace( ro, rd, mindepth * 0.99, iChannel0\n    #ifdef DEBUG_SHOW_LOGBISECT_ITERATIONS\n    , iterations\n    #endif                                           \n    );\n    \n\t//float t = logBisectTrace( ro, rd, mindepth, iChannel0 );\n    \n    // Usually you'd just make this a unit directional light and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*0.5, FAR, FAR) + vec3(0, 0, ro.z);\n \n    // Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\n    // terrain, then mix together with a fog falloff. Pretty straight forward.\n    vec3 sky = getSky( ro, rd, normalize(lp - ro) );\n    \n    // The terrain color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = sky;\n    \n    // If we've hit the ground, color it up.\n    if( t < FAR )\n    {\n        vec3 sp = ro+t*rd; // Surface point\n        \n        #ifdef NORMAL_CURVATURE_OPTIMIZATION\n        \tfloat curv;\n            vec3  sn   = normal_curvature( sp, curv, iChannel0 );\n                  curv = curv * .75 + .5;\n        #else\n            vec3  sn   = normal( sp, iChannel0 ); // Surface normal\n            float curv = curve(  sp, iChannel0 ) * .9 + .1; // Surface curvature.\n        #endif\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld  = lp-sp;\n             ld /= max(length(ld), 0.001); // Normalize the light direct vector.\n\n        \n        // Texture scale factor.\n        const float tSize1 = 1./6.;\n        \n        // Bump mapping with the sandstone texture to provide a bit of gritty detailing.\n        // This might seem counter intuitive, but I've turned off mip mapping and set the\n        // texture to linear, in order to give some grainyness. I'm dividing the bump\n        // factor by the distance to smooth it out a little. Mip mapped textures without\n        // anisotropy look too smooth at certain viewing angles.\n        sn = doBumpMap( iChannel1, sp*tSize1, sn, .007/(1. + t/FAR) );//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\n        \n        float shd = softShadow(  sp, ld, SHADOW_START, SHADOW_END, SHADOW_K, iChannel0 ); // Shadows.\n        \n        float ao  = calculateAO( sp, sn, 4., iChannel0 ); // Ambient occlusion.\n        \n        float dif = max( dot( ld, sn ), 0.0); // Diffuse term.\n        float spe = pow( max( dot( reflect( -ld, sn ), -rd ), 0.0 ), 5. ); // Specular term.\n        float fre = clamp( 1.0 + dot( rd, sn ), 0.0, 1.0 ); // Fresnel reflection term.\n\n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max( dot( rd, normalize( rd + ld ) ), 0. ), 5.0 );\n\t\tfloat fre2    = mix( F0, 1., Schlick );  //F0 = .2 - Hard clay... or close enough.\n        \n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = fre*fre2 + .06*ao;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = clamp( mix( vec3( .8, 0.5,.3 ), vec3( .5, 0.25, 0.125 ), ( sp.y + 1. )*.15 ), vec3( .5, 0.25, 0.125 ), vec3( 1. ) );\n        \n        // Give the soil a bit of a sandstone texture. This line's made up.\n        col = smoothstep( -.5, 1., tex3D( iChannel1, sp*tSize1, sn ) ) * ( col + .25 );\n        // One thing I really miss when using Shadertoy is anisotropic filtering, which makes mapped \n        // textures appear far more crisp. It requires just a few lines in the backend code, and doesn't \n        // appear to effect frame rate, but I'm assuming the developers have their reasons. Anyway, this\n        // line attempts to put a little definition back in, but it's definitely not the same thing. :)     \n        #ifdef NOISE_DETAIL\n        col = clamp( col + noise3D( sp*48. )*.3 - .15, 0., 1. );\n        #endif\n        \n        // Edit: This shader needs gamma correction, so I've hacked this and a postprocessing line\n        // in to counter the dark shading... I'll do it properly later.\n        col = pow( col, vec3(1.5) );\n        \n        // Tweaking the curvature value a bit, then using it to color in the crevices with a \n        // brownish color... in a lame attempt to make the surface look dirt-like.\n        curv = smoothstep( 0., .7, curv );\n        col *= vec3( curv, curv*0.95, curv*0.85 );\n \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        col += getSky( sp, reflect( rd, sn ), ld ) * fre*fre2*.5;\n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = ( col*( dif + .1 ) + fre2*spe ) * shd*ao + amb*col;\n    }\n    \n    // Combine the terrain with the sky using some distance fog. This one is designed to fade off very\n    // quickly a few units out from the horizon. Account for the clouds, change \"FAR - 15.\" to zero, and \n    // the fog will be way more prominent. You could also use \"1./(1 + t*scale),\" etc.\n    col = mix( col, sky, sqrt( smoothstep( FAR - 15., FAR, t ) ) );\n    \n\t/*\n    // Edit: This shader needs gamma correction, so I've hacked this and a line above in\n    // to counter the dark shading... I'll do it properly later.\n    col = pow(max(col, 0.), vec3(.75));\n\n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col *= pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .0625);\n\n    // Done.\n\tfragColor = vec4(clamp(col, 0., 1.), 1.0 );\n    */\n    \n    fragColor = vec4( col, t );\n    \n    #ifdef DEBUG_SHOW_LOGBISECT_ITERATIONS\n        #ifdef DEBUG_SHOW_BISECT_ITERATIONS\n            float grayscale = iterations.y / float(BISECT_STEPS);\n        #else\n        \tfloat grayscale = iterations.x / float(LOGBISECT_STEPS) * DEBUG_SHOW_BISECT_ITERATIONS_SCALE;\n        #endif\n    \tfragColor.rgb = vec3( grayscale );\n    #endif\n}","name":"Buffer D","description":"","type":"buffer"}]}