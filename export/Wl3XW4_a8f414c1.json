{"ver":"0.1","info":{"id":"Wl3XW4","date":"1580904779","viewed":63,"name":"Japanese War Flag","username":"Wallby","description":"First upload, very (over-)complicated, but for the sake of learning Shadertoy. Feedback is welcome.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["learning","firstupload"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define lerp(a, b, t) a + (b-a) * t\n\nvec3 smoothConeX(\n    vec2 uv,\t\t \t// input\n    float a0, float b0, // max line\n    float a1, float b1, // min line\n    float b,\n    vec3 backgroundColor,\n    vec3 color\n\t)\n{\n    float y0 = a0 + b0 * uv.x;\n    float y1 = a1 + b1 * uv.x;\n    \n    vec2 ls0 = vec2(0., a0 + b0 * 0.); // line 0 start\n    vec2 ls1 = vec2(0., a1 + b1 * 0.); // line 1 start\n    \n    vec2 nv0 = normalize(vec2(1., a0 + b0 * 1.) - ls0); // normalized vector for line 0\n    vec2 nv1 = normalize(vec2(1., a1 + b1 * 1.) - ls1); // normalized vector for line 1\n    \n    vec2 uvrls0 = vec2(uv - ls0); // uv relative to the line start of line 0\n    vec2 uvrls1 = vec2(uv - ls1); // uv relative to the line start of line 1\n    \n    float p0 = dot(uvrls0, nv0);\n    float p1 = dot(uvrls1, nv1);\n    \n    float luvrls0 = length(uvrls0);\n    float luvrls1 = length(uvrls1);\n    \n    float d0sq = luvrls0*luvrls0 - p0*p0;\n    float d1sq = luvrls1*luvrls1 - p1*p1;\n    \n    if(y0 < uv.y && uv.y < y1 || y0 > uv.y && uv.y > y1)\n    {\n        float s = smoothstep(0., b*b, min(d0sq,d1sq));\n\t\t\n        return lerp(\n            backgroundColor, color,\n            s\n        );\n    }\n    else\n    {\n        return backgroundColor;\n    }\n}\n\nvec3 smoothConeY(\n    vec2 uv,\t\t \t// input\n    float a0, float b0, // max line\n    float a1, float b1, // min line\n    float b,\n    vec3 backgroundColor,\n    vec3 color\n\t)\n{\n    // y = a + bx\n    // x = (y - a)/b\n    float x0 = (uv.y - a0) / b0;\n    float x1 = (uv.y - a1) / b1;\n    \n    vec2 ls0 = vec2((0. - a0) / b0, 0.); // line 0 start\n    vec2 ls1 = vec2((0. - a1) / b1, 0.); // line 1 start\n    \n    vec2 nv0 = normalize(vec2((1. - a0) / b0, 1.) - ls0); // normalized vector for line 0\n    vec2 nv1 = normalize(vec2((1. - a1) / b1, 1.) - ls1); // normalized vector for line 1\n    \n    vec2 uvrls0 = vec2(uv - ls0); // uv relative to the line start of line 0\n    vec2 uvrls1 = vec2(uv - ls1); // uv relative to the line start of line 1\n    \n    float p0 = dot(uvrls0, nv0);\n    float p1 = dot(uvrls1, nv1);\n    \n    float luvrls0 = length(uvrls0);\n    float luvrls1 = length(uvrls1);\n    \n    float d0sq = luvrls0*luvrls0 - p0*p0;\n    float d1sq = luvrls1*luvrls1 - p1*p1;\n    \n    if(x0 < uv.x && uv.x < x1 || x0 > uv.x && uv.x > x1)\n    {\n        float s = smoothstep(0., b*b, min(d0sq,d1sq));\n\t\t\n        return lerp(\n            backgroundColor, color,\n            s\n        );\n    }\n    else\n    {\n        return backgroundColor;\n    }\n}\n\nvec3 smoothCircle(\n    vec2 fragCoord, vec3 backgroundColor, // pixel data\n    vec2 xy, float rmin, float rmax, vec3 c) // circle data\n{\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.xy; // 0 to 1\n    uv -= xy;\n    uv.x *= aspect;\n    \n    float d = length(uv);\n    \n    return lerp(backgroundColor, c, smoothstep(rmax, rmin, d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 foregroundColor = vec3(0.9, 0., 0.2);\n    const vec3 backgroundColor = vec3(1., 1., 1.);\n\n    vec3 c = backgroundColor;\n\n    const float b = 0.005;\n\n    float r = 0.25;\n    c = smoothCircle(\n        fragCoord, c,\n        vec2(0.5, 0.5), r - b, r, foregroundColor);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    c = smoothConeX(\n        uv,\n        0.1, .85,\n        -0.1, 1.15,\n        b,\n        c,\n        foregroundColor\n    ); // bottom-left\n\n    c = smoothConeX(\n        uv,\n        -0.5, 2.,\n        -1., 2.95,\n        b,\n        c,\n        foregroundColor\n    ); // bottom-second-left\n\n    c = smoothConeX(\n        uv,\n        -0.05, 1.15,\n        0.05, .85,\n        b,\n        c,\n        foregroundColor\n    ); // top-right\n\n    c = smoothConeX(\n        uv,\n        -.96, 2.95,\n        -0.51, 2.,\n        b,\n        c,\n        foregroundColor\n    ); // top-second-right\n\n    c = smoothConeX(\n        uv,\n        1.1, -1.15,\n        0.9, -.85,\n        b,\n        c,\n        foregroundColor\n    ); // top-left\n\n    c = smoothConeX(\n        uv,\n        1.5, -2.,\n        2., -2.95,\n        b,\n        c,\n        foregroundColor\n    ); // top-second-left\n\n    c = smoothConeX(\n        uv,\n        .95, -.85,\n        1.05, -1.15,\n        b,\n        c,\n        foregroundColor\n    ); // bottom-right\n\n    c = smoothConeX(\n        uv,\n        1.96, -2.95,\n        1.51, -2.,\n        b,\n        c,\n        foregroundColor\n    ); // bottom-second-right\n\n    c = smoothConeX(\n        uv,\n        0.59, -.15,\n        0.41,  0.15,\n        b,\n        c,\n        foregroundColor\n    ); // middle-left\n\n    c = smoothConeX(\n        uv,\n        0.44, 0.15,\n        0.56, -0.15,\n        b,\n        c,\n        foregroundColor\n    ); // middle-right\n\n    c = smoothConeY(\n        uv,\n        -7.9, 16.5,\n        8.1, -15.5,\n        b,\n        c,\n        foregroundColor\n    ); // top-middle\n\n    c = smoothConeY(\n        uv,\n        -8.1, 17.5,\n        7.9, -14.5,\n        b,\n        c,\n        foregroundColor\n    ); // botom-middle\n\n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}