{"ver":"0.1","info":{"id":"lt2XWy","date":"1446316974","viewed":970,"name":"wave dispersion 2d","username":"jt","description":"A ray-traced 2d-visualization of wave dispersion (using a simple bisection root-finder).\nOriginal 1d-version by FabriceNeyret2 [url]https://www.shadertoy.com/view/MtBSDG[/url]\n","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","wave","implicitsurface","dispersion","bicestionrootfinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wave-despersion 2d with implicit-surface ray-tracer by Jakob Thomsen\n// Waves-dispersion function by FabriceNeyret2\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n#define pi 3.1415926\n\nfloat localtime;\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat wave(float x, float k, float c, float t)\n{\n    float X = x - c * t;\n    return sin(k * X) * exp(-X * X);\n}\n\nfloat dispersion2d(vec2 v, float t) // testing FabriceNeyret2's waves dispersion function (source: https://www.shadertoy.com/view/MtBSDG)\n{\n    float r = length(v);\n    const float n = 10.0;\n    float sum = 0.0;\n    for (float k = 1.0; k < n; k++)\n    {\n        //sum += wave(abs(r), k, sqrt(k), t) / k; // dispersion for capillary waves (original)\n        sum += wave(r, k, sqrt(k), t) / k + wave(-r, k, sqrt(k), t) / k; // dispersion for capillary waves (no-\"kink\"-tweak)\n        //sum += wave(abs(r), k, 1.0 / sqrt(k), t) / k;// dispersion for gravity waves (original)\n        //sum += wave(r, k, 1.0 / sqrt(k), t) / k + wave(-r, k, 1.0 / sqrt(k), t) / k;// dispersion for gravity waves (no-\"kink\"-tweak)\n    }\n    \n    //return v.x < 0.0 ? n * sum / d : sum; // comparing variant *1 with variant *n/d looks rather similar in this scale\n    return sum; // NOTE: using the simple 1d variant instead of the correct 2d variant here (looks similar in this scale)\n}\n\nfloat fn(vec3 v)\n{\n    v *= 10.0;\n    return v.z + clamp(dispersion2d(v.xy, localtime), -1.0, 1.0);\n}\n\nvec3 nrm(vec3 v)\n{\n    v *= 10.0;\n    float d = 0.01;\n    vec2 grad;\n    grad.x = dispersion2d(v.xy + vec2(d, 0.0), localtime) - dispersion2d(v.xy + vec2(-d, 0.0), localtime);\n    grad.y = dispersion2d(v.xy + vec2(0.0, d), localtime) - dispersion2d(v.xy + vec2(0.0, -d), localtime);\n    return normalize(vec3(-grad, d));\n}\n\nfloat comb(float v)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), 10.0);\n}\n\nvec3 texGrid(vec3 v)\n{\n    v.x = fract(v.x * 8.0);\n    v.y = fract(v.y * 8.0);\n    float q = 0.0;\n    q = max(q, comb(v.x));\n    q = max(q, comb(v.y));\n    return vec3(q);\n}\n\nvec3 texHeight(vec3 v)\n{\n    v = 0.5 + 0.5 * clamp(v, -1.0, 1.0);\n    return vec3(0.0, v.z, 1.0 - v.z);\n}\n\nvec3 texLight(vec3 v)\n{\n    return vec3(abs(nrm(v).z));\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float phi = iTime * 0.0;\n    //float phi = 2.0 * iMouse.x / iResolution.x - 1.0;\n    vec3 v = vec3(uv, depth);\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    v.x = iso.x * cos(phi) + iso.y * sin(phi);\n    v.y = iso.x * -sin(phi) + iso.y * cos(phi);\n    v.z = iso.z;\n\n    return v;\n}\n\nvec3 bisection(vec3 a, vec3 b) // slow root-finder, but simple & stable\n{\n    float fa = fn(a);\n    float fb = fn(b);\n    const int n = 16;\n    for(int i = 0; i < n; i++)\n    {\n        vec3 c = (a + b) / 2.0;\n        float fc = fn(c);\n        if(sign(fc) == sign(fa))\n        {\n            a = c;\n            fa = fc;\n        }\n        else\n        {\n            b = c;\n            fb = fc;\n        }\n    }\n    \n    return (a + b) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localtime = fract(iTime / 16.0) * 16.0;\n\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv /= 2.0;\n\n    vec3 a = camera(uv.xy, 1.0);\n    vec3 b = camera(uv.xy,-1.0);\n    vec3 v = bisection(a, b);\n    vec3 color = (abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0) ? vec3(0.0, 0.0, 0.0) : texLight(v) * texHeight(v) + 0.1 * texGrid(v);\n\n    //fragColor = vec4(color * vec3(m), 1.0);\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}