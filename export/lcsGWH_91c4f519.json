{"ver":"0.1","info":{"id":"lcsGWH","date":"1703034817","viewed":36,"name":"guang000","username":"lihuiru","description":"guang","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["guang"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI = 3.141592654;\nconst float side = 0.3;\nconst float angle = PI*1.0/3.0;\nconst float sinA = 0.86602540378;\nconst float cosA = 0.5;\nconst vec3 zero = vec3(0.0);\nconst vec3 one = vec3(1.0);\n\n// generates the colors for the rays in the background\nvec4 rayColor(vec2 fragToCenterPos, vec2 fragCoord) {\n\tfloat d = length(fragToCenterPos);\n\tfragToCenterPos = normalize(fragToCenterPos);\n\t\t\n\tfloat multiplier = 0.0;\n\tconst float loop = 60.0;\n\tconst float dotTreshold = 0.90;\n\tconst float timeScale = 0.75;\n\tconst float fstep = 10.0;\n\t\n\t// generates \"loop\" directions, summing the \"contribution\" of the fragment to it. (fragmentPos dot direction)\n\tfloat c = 0.5/(d*d);\n\tfloat freq = 0.25;\t\t\n\tfor (float i = 1.0; i < loop; i++) {\n\t\tfloat attn = c;\n\t\tattn *= 1.85*(sin(i*0.3*iTime)*0.5+0.5);\n\t\tfloat t = iTime*timeScale - fstep*i;\n\t\tvec2 dir = vec2(cos(freq*t), sin(freq*t));\n\t\tfloat m = dot(dir, fragToCenterPos);\n\t\tm = pow(abs(m), 4.0);\n\t\tm *= float((m) > dotTreshold);\n\t\tmultiplier += 0.5*attn*m/(i);\n\t}\n\n\t// radius for the rings around the triforce\n\tconst float r0 = 0.345;\n\tconst float r1 = r0 + 0.02;\n\tconst float r2 = r1 + 0.005;\n\t\n\t// \"f\" controls the intensity of the ray color\n\tfloat f = 1.0;\n\tif (d < r0) f = smoothstep(0.0, 1.0, d/r0);\n\telse if (d < r1) f = 0.75;//(d - r0) / (r1 - r0);\n\telse if (d < r2) f = 1.2;\n\t\t\n\n\tconst vec4 rayColor = vec4(0.9, 0.7, 0.3, 1.0);\n\t\t\n\t// Applies the pattern\n\tfloat pat = abs(sin(10.0*mod(fragCoord.y*fragCoord.x, 1.5)));\n\tf += pat;\n\tvec4 color = f*multiplier*rayColor;\n\treturn color;\n}\n\n// from \"Real Time Collision Detection\": compute barycentric coordinates for p with respect to triangle (a,b,c)\nvoid barycentric(vec3 a, vec3 b, vec3 c, vec3 p, out float u, out float v, out float w) {\n\tvec3 v0 = b - a;\n\tvec3 v1 = c - a;\n\tvec3 v2 = p - a;\n\t\n\tfloat d00 = dot(v0, v0);\n\tfloat d01 = dot(v0, v1);\n\tfloat d11 = dot(v1, v1);\t\n\tfloat d20 = dot(v2, v0);\n\tfloat d21 = dot(v2, v1);\n\t\n\tfloat denom = d00 * d11 - d01 * d01;\n\t\n\tv = (d11 * d20 - d01*d21) / denom;\n\tw = (d00 * d21 - d01*d20) / denom;\n\tu = 1.0 - v - w;\n}\n\nbool all_set(vec3 vec) {\n\tfloat prod = vec.x * vec.y * vec.z;\n\treturn (vec.x == 1.0 && vec.y == 1.0 && vec.z == 1.0);\n}\n\nfloat insideTriforce(vec3 pos, float aspect, out float u, out float v, out float w) {\n\t// 1st triangles - vertices\n\tvec3 v0 = vec3(0.5*aspect, 0.8, 1.0);\n\tvec3 v1 = v0 + vec3(-side*cosA, -side*sinA, 0.0);\n\tvec3 v2 = v1 + vec3(2.0 * (v0.x - v1.x), 0.0, 0.0);\n\t\n\t// test if inside 1st triangle\n\tbarycentric(v0, v1, v2, pos, u, v, w);\n\tvec3 uvw = vec3(u,v,w);\n\tvec3 inside = step(zero, uvw) * (1.0 - step(one, uvw));\n\n\tif (all_set(inside))\n\t\treturn 1.0;\n\n\t// 2nd triangles - vertices\n\tfloat dx = v1.x - v0.x;\t// half-side in x\n\tfloat dy = v1.y - v0.y;\t// half-side in y\n\tv0 -= vec3(-dx, -dy, 0.0);\n\tv1 = v0 + vec3(-side*cosA, -side*sinA, 0.0);\n\tv2 = v1 + vec3(2.0 * (v0.x - v1.x), 0.0, 0.0);\t\n\t\n\t// test if inside 2nd triangle\n\tbarycentric(v0, v1, v2, pos, u, v, w);\n\tuvw = vec3(u,v,w);\n\tinside = step(zero, uvw) * (1.0 - step(one, uvw));\n\tif (all_set(inside))\n\t\treturn 1.0;\n\t\n\t// 3rd triangles - vertices\t\n\tv0 += vec3(-dx*2.0, 0.0, 0.0);\n\tv1 = v0 + vec3(-side*cosA, -side*sinA, 0.0);\n\tv2 = v1 + vec3(2.0 * (v0.x - v1.x), 0.0, 0.0);\t\n\n\t// test if inside 3rd triangle\n\tbarycentric(v0, v1, v2, pos, u, v, w);\n\tuvw = vec3(u,v,w);\n\tinside = step(zero, uvw) * (1.0 - step(one, uvw));\n\tif (all_set(inside))\n\t\treturn 1.0;\n\t\n\treturn 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aspect = iResolution.x / iResolution.y;\t\n\tvec3 pos = vec3(fragCoord.xy / iResolution.xy, 1.0);\n\tpos.x *= aspect;\n\t\n\tvec2 fragToCenterPos = vec2(pos.x - 0.5*aspect, pos.y - 0.5);\n\tvec4 rayCol = rayColor(fragToCenterPos,fragCoord);\n\t\n\t// barycentric coordinates of pos with respect to the triangle of the triforce it lies inside\n\tfloat u, v, w;\n\tfloat c = insideTriforce(pos, aspect, u, v, w);\t\n\n\tfloat lim = 0.075;\n\t\n\tvec3 normal = vec3(0.0, 0.0, 1.0);\n\tvec3 uNormalContrib = vec3(0.0);\n\tvec3 vNormalContrib = vec3(0.0);\n\tvec3 wNormalContrib = vec3(0.0);\n\t\t\n\t// on the edge of each triangle, \"bend\" the normal in the direction of the edge\n\tif (u < lim) {\n\t\tfloat uNorm = u/lim;\n\t\tfloat offset = cos(0.5*PI*uNorm);\n\t\toffset *= offset;\n\t\tuNormalContrib = vec3(0.0, -offset, 0.0);\n\t}\n\tif (v < lim) {\n\t\tfloat vNorm = v/lim;\n\t\tfloat offset = -cos(0.5*PI*vNorm);\n\t\toffset *= offset;\n\t\tvNormalContrib = vec3(offset*cosA, offset*sinA, 0.0);\n\t}\n\tif (w < lim) {\n\t\tfloat wNorm = w/lim;\n\t\tfloat offset = cos(0.5*PI*wNorm);\n\t\toffset *= offset;\n\t\twNormalContrib = vec3(-offset*cosA, offset*sinA, 0.0);\n\t}\n\t\n\t// sums all the contributions to form the normal\n\tnormal += uNormalContrib + vNormalContrib + wNormalContrib;\n\tnormal = normalize(normal);\n\t\n\t// generate a position for the view: on a circle around the center of the screen\n\tfloat freq = 1.5*iTime;\n\tvec3 view = vec3(0.5, 0.5, 0.0) + vec3(sin(freq), cos(freq), 2.0);\n\tview = normalize(view);\n\t\n\t// Apply lambertian light\n\tfloat light = dot( view, normal );\n\t\n\t// when the barycentric coordinate falls into the [minW, maxW] interval, shade with a lighter tone\n\tfloat minW = mod(1.15*iTime, 4.0);\n\tfloat maxW = minW + 0.3;\n\tfloat s = 1.0;\n\tif (w > minW && w < maxW)\n\t\ts += 0.1;\n\n\tvec4 triforceColor = light*c*vec4(s, s, 0.0, 0.0);\n\tfragColor = mix(rayCol, triforceColor, c);\n}\n","name":"Image","description":"","type":"image"}]}