{"ver":"0.1","info":{"id":"WtsBWl","date":"1598921553","viewed":51,"name":"TFG 4-8.3 Sección FDS","username":"lukasharing","description":"Sección de una esfera por un plano","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tfg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PASOS 128\n#define EPSILON 0.001\n#define MAXIMO 20.0\n#define PI 3.1415\n\nmat2 rot(float a){\n    return mat2(\n        +cos(a), -sin(a), \n        +sin(a), +cos(a)\n    );\n}\n\n// FDS Esfera\nfloat SDFEsfera(vec3 p, float r){\n\treturn length(p) - r;\n}\n\n// FDS Plano con signo\nfloat SDFPlano(vec3 p, vec3 n){\n    return dot(p, n);\n}\n\n// Isometría rotación plano XZ\nvec3 rotXZ(vec3 p, float a){\n    vec2 pr = p.xz * rot(a);\n    return vec3(pr.x, p.y, pr.y);\n}\n\nfloat escena_sdf(vec3 p){\n    // Rotamos el plano XZ, pi / 4 rad\n    p = rotXZ(p, PI / 2. * 1.2);\n\t// Sección de una esfera\n    return max(\n        SDFEsfera(p, 0.3),\n        SDFPlano(p - vec3(0., 0., 0.15), vec3(0., 0., 1.))\n    );\n}\n    \n// Homomorfismo\nfloat h3(float h){\n    return pow(h, pow(2., 3.));\n}\n\n// Producto Escalar normalizado positivo.\nfloat dot01(vec3 a, vec3 b){ \n    return max(dot(a,b)/(length(a)*length(b)), 0.0);\n}\n\nfloat f_difusa(float distancia){\n\treturn 1.0;\n}\n\nfloat SphereMarching(in vec3 ojo, in vec3 direccion, float distancia_plano){\n    float distancia = 0.0;\n    // Realizamos PASOS iteraciones de marching.\n    for(int i = 0; i < PASOS; ++i){\n        // Calculamos la cabeza del rayo\n        vec3 rayo = ojo + direccion * distancia;\n        // Calculamos el radio de la esfera más próxima a la isosuperficie\n        float radio = escena_sdf(rayo);\n        // Si el radio (distancia mínima a la isosuperficie es muy pequeña, estamos devolvemos la distancia del vector final. Esta distancia la utilizaremos más adelante para calcular el vector que apunta a la isosuperficie.\n        if(radio < EPSILON){\n            return distancia;\n        }\n        // Incrementamos la distancia recorrida si no estamos cerca de la isosuperficie.\n        distancia += radio;\n        // Comprobamos que no se haya superado la distancia de dibujado máximo. Para aquellos texels cuyo valor sea -1.0. Podemos considerarlos, el fondo de la escena.\n        if(distancia > distancia_plano) break;\n    }\n    return distancia_plano;\n}\n\n// Cálculo de la normal de la isosuperficie intersectada por un rayo que ha sido estimado.\nvec3 Normal(vec3 p){\n     // f(x1,...,xn)\n     float fxyz = escena_sdf(p);\n     // f(x1,..,xi+h,xn)\n     float fxhyz = escena_sdf(p + vec3(EPSILON, 0.0, 0.0));\n     float fxyhz = escena_sdf(p + vec3(0.0, EPSILON, 0.0));\n     float fxyzh = escena_sdf(p + vec3(0.0, 0.0, EPSILON));\n     \n     // Utilizamos la definicion de derivadas parciales para devolver el gradiente, que se trata de la normal de la isosuperficie.\n     return vec3(\n         (fxhyz - fxyz) / EPSILON,\n         (fxyhz - fxyz) / EPSILON,\n         (fxyzh - fxyz) / EPSILON\n     );\n}\n\n// Modelo de iluminación Phong con sombras duras\nfloat ModeloIluminacion(vec3 direccion, vec3 p){\n    // Calculamos la normal en el punto p.\n    vec3 normal = Normal(p);\n    float intensidad = 0.0;\n    // Intensidad Ambiente Global\n    intensidad += 0.2;\n    // Punto p de la isosuperficie, separado del suelo para ayuda a acelerar el cálculo de \n    p = p + normal * 0.1;\n    // Intensidad de cada Luz\n    // Luz 1.\n    vec3 posicion_luz_1 = vec3(3.0, 3.0, 1.);\n    vec3 d_luz_1 = posicion_luz_1 - p;\n    vec3 dir_luz_1 = normalize(d_luz_1);\n    float dst_luz_1 = length(d_luz_1);\n    // En el caso de que se trate de una luz direccional, utilizaremos el plano MAXIMO, utilizado antes.\n    if(SphereMarching(p, dir_luz_1, dst_luz_1) >= dst_luz_1){\n        // Intensidad Difusa\n        intensidad += dot01(d_luz_1, normal);\n        // Intensidad Especular (Si no es direccional)\n        vec3 r_luz_1 = reflect(d_luz_1, normal);\n        intensidad += f_difusa(dst_luz_1) * h3(dot01(r_luz_1, direccion));\n    }\n    \n    // Luz 2. Direccional\n    vec3 dir_luz_2 = -normalize(vec3(1., 0., 0.));\n    // En el caso de que se trate de una luz direccional, utilizaremos el plano MAXIMO, utilizado antes.\n    if(SphereMarching(p, dir_luz_2, MAXIMO) >= MAXIMO){\n        // Intensidad Difusa\n        intensidad += dot01(dir_luz_2, normal);\n    }\n    \n    return clamp(intensidad, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalizamos las coordendas y las reescalamos para mantener el ratio de aspecto. Transladamos al centro de la pantalla.\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.y, iResolution.x);\n    // Definimos el ojo y la pantalla, que se encuentra en nuestra escena. Este debe estar detrás de la pantalla ya que de este se “lanzarán” los rayos que pasarán por la pantalla.\n    vec3 ojo = vec3(0.0, 0.0, -1.0);\n    vec3 pantalla = vec3(uv, 0.0);\n    // Es fácil observar que la dirección del rayo es el vector normalizado que apunta desde el ojo hasta la pantalla\n    vec3 direccion = normalize(pantalla - ojo);\n    // Con esto, ya podemos utilizar nuestro Sphere marcher.\n    float distancia = SphereMarching(ojo, direccion, MAXIMO);\n    if(distancia < MAXIMO){\n        // Estamos \"sobre\" la isosuperficie. \n        // El punto será el formado por el ojo y en dirección modulada con la distancia acumulada.\n        vec3 p = ojo + direccion * distancia;\n        // Con la información actual, podemos aplicar un modelo de iluminación.\n        float intensidad = ModeloIluminacion(direccion, p);\n        // Utilizamos el color blanco para dibujar la isosuperficie.\n        fragColor = vec4(1.0) * intensidad;\n    }else{\n        // Estamos en el fondo de la escena.\n\n        // Utilizamos el color negro para dibujar el fondo.\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}