{"ver":"0.1","info":{"id":"4lVXDc","date":"1486328658","viewed":181,"name":"Raymarching balls","username":"nomadiclizard","description":"Messing around with the concept of raymarching. Colouring shows march iteration escape (brighter -> higher iteration count). VR enabled, works with my DK2/Firefox nightly. :D","likes":0,"published":1,"flags":1,"usePreview":0,"tags":["3d","raymarcher","balls","vr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// learning how to raymarch woopwoop!\n\n#define pi 3.141592653589793\n#define twoPi (2.0*pi)\n#define halfPi (0.5*pi)\n#define infinity 100.0\n\n#define obj_sky 0\n#define obj_s1 1\n#define obj_s2 2\n\n// raymarching algorithm will march maxsteps and stop when at epsilon from a surface\nconst int maxsteps = 50;\nconst float epsilon = 0.0005;\n\n// view stuff\nconst float fov = radians(45.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\nstruct Sphere {\n    int objid;\n    vec3 p;\n    float r;\n    vec3 axis;\n    float angle;\n};\n    \nstruct RayHit {\n    int objid;\n    vec3 p;\n    vec2 uv;\n    vec3 n;\n    int i;\n};\n    \n// useful\nvec3 lookat(vec3 p1, vec3 p2)\n{\n    return normalize(p2 - p1);\n}\n\n// really useful\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// sorta useful\nmat4 translationMatrix(vec3 p)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\n// distance from point to surface of a sphere\nfloat spheredist(Sphere s, vec3 p)\n{\n    return length(p - s.p) - s.r;\n}\n\n// calc uv [0,1] texture and normal for point p on surface of a rotating sphere\nvec2 spheretex(Sphere s, vec3 p, out vec3 n)\n{\n    vec3 sp = s.p - p;\n    n = normalize(sp);\n    vec3 nn = vec3(normalize(rotationMatrix(s.axis, s.angle) * vec4(sp, 1.0)));\n    vec2 uv;\n    uv.x = 0.5 + atan(nn.z, nn.x) / twoPi;\n    uv.y = 0.5 - asin(nn.y) / pi;\n    return uv;\n}\n\n// check a sphere for ray intersection passing within epsilon of surface\n// computes rayhit and updates last distance to sphere and mindist\nbool checksphere(Sphere s, vec3 p, int i, inout float lastdist, inout float mindist, out RayHit hit) {\n    // if we know we're moving away from the sphere we can skip the calc\n    if(lastdist > 0.0) {\n        float d = spheredist(s, p);\n        if(d <= epsilon) {\n            // hit!\n            vec3 n;\n            vec2 uv = spheretex(s, p, n);\n            hit = RayHit(s.objid, p, uv, n, i);\n            return true;\n        } else {\n            // store distance so next time if it's further we can skip this sphere\n            mindist = d < mindist ? d : mindist;\n            lastdist = d > lastdist ? 0.0 : d;\n        }\n    }\n    return false;\n}\n\n\nSphere s_sky = Sphere(obj_sky, vec3(0.0), infinity, up, 0.0);\nSphere s_s1 = Sphere(obj_s1, vec3(1.5, 0.0, 0.0), 1.0, up, 0.0);\nSphere s_s2 = Sphere(obj_s2, vec3(-1.5, 0.0, 0.0), 1.0, up, 0.0);\n\n// march til we hit an object in the scene or the skybox\nbool raymarch(vec3 ro, vec3 rd, out RayHit hit) {\n    float d_s1 = infinity;\n    float d_s2 = infinity;\n    float t = 0.0;\n    int breakstep = maxsteps;\n    for(int i = 0; i < maxsteps; i++) {\n        float mindist = infinity;\n        vec3 p = ro + t * rd;\n        // check the spheres\n        if(checksphere(s_s1, p, i, d_s1, mindist, hit)) return true;\n        if(checksphere(s_s2, p, i, d_s2, mindist, hit)) return true;\n        // diverging from everything?\n        if(mindist == infinity) { breakstep = i; break; }\n        // march on\n        t += mindist;\n    }\n    // assume intersection with skybox (??or last object to get close to??)\n    {\n        vec3 n;\n        vec2 uv = spheretex(s_sky, ro + infinity * rd, n);\n        hit = RayHit(s_sky.objid, ro, uv, n, breakstep);\n        return false;\n    }\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    // make the spheres orbit and spin\n    mat4 omatrix = rotationMatrix(up, 0.05 * twoPi * iTime);\n    mat4 rmatrix = rotationMatrix(vec3(1.0, 1.0, 0.0), radians(30.0));\n    mat4 tmatrix = translationMatrix(vec3(0.0, 0.0, -3.5));\n\n    s_s1.p = vec3(tmatrix * rmatrix * omatrix * vec4(s_s1.p, 1.0));\n    s_s1.axis = vec3(rmatrix * vec4(s_s1.axis, 1.0));\n    s_s1.angle += 0.15 * twoPi * iTime;\n    s_s2.p = vec3(tmatrix * rmatrix * omatrix * vec4(s_s2.p, 1.0));\n    s_s2.axis = vec3(rmatrix * vec4(s_s2.axis, 1.0));\n    s_s2.angle += 0.10 * twoPi * iTime;\n    \n    // raymarch in that direction\n    RayHit hit;\n    raymarch(fragRayOri, fragRayDir, hit);\n    float escapem = log(exp(2.5) * float(hit.i) / float(maxsteps)) / 2.5;\n    if(hit.objid == obj_sky) {\n\t\tfragColor = vec4(escapem, 0.0, 0.0, 0.0);\n    } else {\n        // oooo dot product lighting\n        float lightintensity = dot(fragRayDir, hit.n);\n\t\tif (hit.objid == obj_s1) {\n        \tfragColor = texture(iChannel0, hit.uv) * lightintensity;\n            fragColor.rb *= escapem;\n    \t} else if (hit.objid == obj_s2) {\n\t        fragColor = texture(iChannel1, hit.uv) * lightintensity;\n            fragColor.rg *= escapem;\n    \t}\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // figure out where to look (the VR version does it for us)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, vec3(uv.x * tan(fov), uv.y * tan(fov), -1.0));\n    \n    // render\n    mainVR( fragColor, fragCoord, ro, rd);\n}","name":"Image","description":"","type":"image"}]}