{"ver":"0.1","info":{"id":"XcsfWX","date":"1724455472","viewed":21,"name":"2 body gravity visualizer","username":"endertrekkie","description":"each pixel is a starting location, starting velocity is set in Common. each frame, each pixel is moved, and the closest gravitational body is the color.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["space","visualizer","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool checkMouse(vec2 samp){\n    vec2 pos = iMouse.xy / iResolution.xy;\n    vec2 vel = startVel;\n    vec2 lastPos = pos;\n    for(int i = 0; i < iFrame; i++){\n        updateGravs(float(i) * orbitSpeed);\n        lastPos = pos;\n        if(length(netG(pos)) > 10000.0){\n            updateGravs(float(iFrame) * orbitSpeed);\n            vel = vec2(100.0);\n            pos = vec2(100.0);\n            return false;\n        }\n        vec4 info = simStep(pos,vel, timeStep);\n        pos = info.xy;\n        vel = info.zw;\n        if(sdSegment(samp,lastPos,pos) < 0.001){\n            return true;\n        }\n    }\n    return false;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    if(checkMouse(uv)){\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n        return;\n    }\n    \n    //point info (position = xy, velocity = zw)\n    vec4 pInfo = texture(iChannel0, uv);\n    // Output to screen\n    fragColor = vec4(getCol(pInfo.xy),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 g1 = vec2(0.6,0.5);//grav 1 position\nvec2 g2 = vec2(0.4,0.5);//grav 2 position\n\nvec3 g1col = vec3(0.1,0.0,0.0);//color of first grav\nvec3 g2col = vec3(0.0,0.1,0.0);//color of second grav\n\nfloat timeStep = 0.001;//how far to step each frame\nfloat subDtMin = 10.0;//minimum gravity to subdivide dt\nint maxIters = 32;//maximum iterations to do in a frame\n\n\n//change starting velocity of each pixel\nvec2 startVel = vec2(1.0,0.0);\n\n//speed that the orbital bodies \nfloat orbitSpeed = 0.01;\n\n\nvoid updateGravs(float t){\n    g1 = vec2(sin(t),cos(t))/10.0 + vec2(0.5);\n    g2 = vec2(-sin(t),-cos(t))/10.0 + vec2(0.5);\n}\n\n//distance to segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n//distance to point\nfloat sdPoint( in vec2 p, in vec2 o){\n    return length(o - p);\n}\n//distance to grav\nfloat sdG(in vec2 p){\n    return min(sdPoint(p,g1),sdPoint(p,g2));\n}\n//force of gravity\nvec2 g(in vec2 d){\n    return -1.0/(length(d)*length(d))*normalize(d);\n}\n//net gravity\nvec2 netG(vec2 pos){\n    return g(pos - g1) + g(pos - g2);\n}\n//color of nearest object\nvec3 getCol(vec2 pos){\n    if(sdPoint(pos, g1) < sdPoint(pos, g2)){\n        return g1col / sdPoint(pos, g1);\n    }\n    return g2col / sdPoint(pos, g2);\n}\n//simulate 1 step\nvec4 simStep(in vec2 pos, in vec2 vel, float dt){\n    int iters = 1;\n    while(sdG(pos) < subDtMin && iters < maxIters){\n        iters *= 2;\n        dt /= 2.0;\n    }\n    for(int i = 0; i < iters; i++){\n        vel += netG(pos) * dt;\n        pos += vel * dt;\n    }\n    return vec4(pos,vel);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //if on first frame, set initial conditions\n    if(iFrame == 0){\n        fragColor = vec4(uv,startVel);\n        return;\n    }\n    \n    updateGravs(float(iFrame) * orbitSpeed);\n\n    //point info (position and velocity)\n    vec4 pInfo = texture(iChannel0, uv);\n    //update point info\n    if(length(netG(pInfo.xy)) > 10000.0){\n        pInfo = vec4(100.0);\n    }\n    pInfo = simStep(pInfo.xy,pInfo.zw,timeStep);\n    //store new point info\n    fragColor = pInfo;\n}","name":"Buffer A","description":"","type":"buffer"}]}