{"ver":"0.1","info":{"id":"WdXSRj","date":"1551624254","viewed":2927,"name":"Clouds raymarching","username":"dp","description":"A cloud rendering thing i made a couple of years ago.\nControls:\n  WASD - Move Left/Right/Fowards/Backwards\n  Spacebar/C  - Move up/down\n  Shift - Speed modifier\n  Arrow keys - Pitch/Yaw\n  Mouse - Move the sun around","likes":39,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","clouds","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Written (mostly) by Domenico Pellegrino \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 vPixSize = vec2(1.0) / iResolution.xy;\n    vec2 vUV = fragCoord * vPixSize;\n\n    fragColor = vec4(texture(iChannel0, vUV).rgb, 1.0); \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define M_PI 3.14159265\n\n//================\n// Camera\n#define FOV 60.0\n#define NEAR 0.001\n#define FAR 500.0\n\n// Marching constants\n#define MARCH_STEPS 200\n#define MARCH_EXP 2.0\n#define MARCH_ROUGH_MULT 1.0\n\n#define SHADOW_STEPS 24\n#define SHADOW_EXP 2.0\n#define SHADOW_FAR 70.0\n\n// Lighting constants\n#define LIGHT_FALLOFF 0.0\n\n// Volume characteristics \n#define CLOUD_HEIGHT 12.0\n#define CLOUD_START -16.0\n#define CLOUD_COVERAGE 0.7\n#define CLOUD_DENSITY_MULT  0.6\n#define CLOUD_SMOOTHNESS 0.05\n#define POWDER_COEFF 2.0\n\n#define CLOUDS_SPEED -0.03\n#define CLOUDS_TOP (CLOUD_START - CLOUD_HEIGHT)\n#define CLOUDS_BASE (CLOUD_START)\n#define AMBIENT_EXTICTION 0.05\n\n//#define ATMO_DENS vec2(0.00, 0.001)\n#define ATMO_DENS vec2(0.0, 0.00)\n\n#define SIGMA_E 0.0\n#define SIGMA_S 1.0\n\n\n// Colors\n// DAY\n\n#define LIGHT_STRENGTH 25.0\n\n#define COLOR_LIGHT \t\t\tvec3(1.0)//vec3(1.0, 0.9, 0.8) //vec3(1.0, 0.2, 0.05)\n#define COLOR_GROUND \t\t\tvec3(0.83,0.66,0.362)\n#define COLOR_SKY \t\t\t\tmix(vec3(.0, .1, .4),vec3(.3, .6, .8),1.0-vUV.y/2.0)\n#define COLOR_AMBIENT_TOP\t\t0.6*vec3(.15, .35, .6)\n#define COLOR_AMBIENT_BOTTOM\tCOLOR_GROUND * 0.05\n\n\n// Night\n/*\n#define LIGHT_STRENGTH 2.5\n\n#define COLOR_LIGHT \t\t\tvec3(0.85, 0.90, 1.0)\n#define COLOR_GROUND \t\t\tpow(vec3(235,212,160)/vec3(255), vec3(2.2))\n#define COLOR_SKY \t\t\t\tvec3(0.0)\n#define COLOR_AMBIENT_TOP\t\t(0.1*COLOR_LIGHT)\n#define COLOR_AMBIENT_BOTTOM\tCOLOR_GROUND * 0.02\n*/\n\nconst float gcRcpSteps = 1.0 / float(MARCH_STEPS);\nconst float gcRcpShadowSteps = 1.0 / float(SHADOW_STEPS);\n\n//===========================================================================\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_ENTER = 13.5/256.0;\nconst float KEY_SHIFT = 16.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\nbool IsKeyDown(float aKeyId)\n{\n   return texture(iChannel2, vec2(aKeyId, 0.0)).x >= 0.5;\n}\n\n//===========================================================================\n// Variables\n\nbool IsVariable(vec2 aFragCoord, int aVarId)\n{\n    return \n        aFragCoord.y < 1.0 && \n        aFragCoord.y >= 0.0 && \n        int(round(aFragCoord.x-0.5)) == aVarId;\n}\n\nvec4 ReadVec4(int aVarId)\n{\n\treturn texelFetch(iChannel0, ivec2(aVarId, 0), 0);\n}\n\nvec4 ReadVec4(vec2 aFragCoord)\n{\n    return texture(iChannel0, aFragCoord / iChannelResolution[0].xy);\n}\n\n\nmat4 CreateViewToWorldMatrix(const vec3 aCamPos, const vec2 aCamRot)\n{\n    float vCosY = cos(aCamRot.y);\n    vec3 vCameraFront = vec3(\n        vCosY * cos(aCamRot.x),\n        sin(aCamRot.y),\n        vCosY * sin(aCamRot.x));\n    \n    vCameraFront = normalize(vCameraFront);\n        \n    vec3 vUp = cross(cross(vCameraFront, vec3(0.0,1.0,0.0)), vCameraFront);\n        vUp = normalize(vUp);\n\n    vec3 vRight = cross(vCameraFront, vUp);\n    vRight = normalize(vRight);\n\n    return mat4(vec4(vRight.x, vUp.x, vCameraFront.x, -aCamPos.x),\n                vec4(vRight.y, vUp.y, vCameraFront.y, -aCamPos.y),\n                vec4(vRight.z, vUp.z, vCameraFront.z, -aCamPos.z),\n                vec4(0.0, 0.0, 0.0, 1.0)\n               );\n}\n \nmat4 CreateProjectionMatrix()\n{\n    float vA = iResolution.x / iResolution.y;\n \tfloat vD = 1.0 / tan(radians(FOV * 0.5));\n    return mat4(vec4(vD/vA, 0.0, 0.0, 0.0),\n                vec4(0.0, vD, 0.0, 0.0),\n                vec4(0.0, 0.0, (NEAR+FAR)/(NEAR-FAR), (2.0*NEAR*FAR)/(NEAR-FAR)),\n                vec4(0.0, 0.0, -1.0, 0.0));\n    \n}\nmat3 CreateCameraRotationMatrix(const vec2 aCamRot)\n{\n    float vCosY = cos(aCamRot.y);\n    vec3 vCameraFront = vec3(\n        vCosY * cos(aCamRot.x),\n        sin(aCamRot.y),\n        vCosY * sin(aCamRot.x));\n    \n    vCameraFront = normalize(vCameraFront);\n        \n    vec3 vUp = cross(cross(vCameraFront, vec3(0.0,1.0,0.0)), vCameraFront);\n        vUp = normalize(vUp);\n\n    vec3 vRight = cross(vCameraFront, vUp);\n    vRight = normalize(vRight);\n\n    return mat3(vRight, vUp, vCameraFront);\n}\n\n\nvec2 UVToFragCoord(const in vec2 aUV)\n{\n\tvec2 vFragCoord = aUV * 2.0 - 1.0;\n\tvFragCoord.x *= iResolution.x / iResolution.y;\n\treturn vFragCoord;\t\n}\n\nvec3 CreateRayDir(const vec2 vFragCoord, const vec2 aCamRot)\n{  \n    float vAspectRatio = iResolution.x / iResolution.y;\n    float vTan = tan(0.5 * radians(FOV));\n    vec3 vRD = vec3(\n        (2.0 * ((vFragCoord.x+0.5) / iResolution.x) - 1.0) * vTan * vAspectRatio,\n        (1.0 - 2.0 * ((vFragCoord.y+0.5) / iResolution.y)) * vTan,\n        -1.0);\n    vRD = normalize(vRD);\n   \tmat3 vMatView = CreateCameraRotationMatrix(aCamRot);\n    return vMatView * vRD;\n}\n\nvec2 FragCoordToUV(const in vec2 aFragCoord)\n{\n    vec2 vScaledFragCoord = aFragCoord;\n    vScaledFragCoord.x *= iResolution.y / iResolution.x;\n    return (vScaledFragCoord * 0.5 + 0.5);\n}\n\nvec2 WorldToUV(const in vec3 aWorldPos,\n               const in vec3 aCamPos, \n               const in vec2 aCamRot)\n{\n    vec3 vOffset = aWorldPos - aCamPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * CreateCameraRotationMatrix(aCamRot);\n\tvCameraLocal = normalize(vCameraLocal);\n    \n    vec2 vOfs = vec2(0.5) / iResolution.xy;\n    float vAspectRatio = iResolution.x / iResolution.y;\n    float vTan = tan(0.5 * radians(FOV));\n    vec2 vUV = vec2((vCameraLocal.x / (vAspectRatio * vTan) + 1.0) / 2.0,\n                    (1.0 - (vCameraLocal.y / vTan)) / 2.0) - vOfs;\n    \n    \n    return vUV;\n}\n\n#define VAR_CAMERA_POS_xyz 0\n#define VAR_CAMERA_ROT_xy 1\n\n#define CAMERA_VEL 5.0\n#define CAMERA_ROT_VEL 1.0\n\nvec3 CalcCameraPos()\n{\n    if (iFrame <= 0) return vec3(10.0, -2.0, 4.0);\n    vec4 vOldValue = ReadVec4(VAR_CAMERA_POS_xyz);\n      \n    float vCamVel = CAMERA_VEL;\n    if (IsKeyDown(KEY_SHIFT)) vCamVel *= 6.0;\n        \n    float vVelX = 0.0;\n    if (IsKeyDown(KEY_A)) vVelX -= vCamVel;\n    if (IsKeyDown(KEY_D)) vVelX += vCamVel;\n\t\t\n    float vVelY = 0.0;\n    if (IsKeyDown(KEY_SP)) vVelY -= vCamVel;\n    if (IsKeyDown(KEY_C)) vVelY += vCamVel;\n        \n    float vVelZ = 0.0;\n    if (IsKeyDown(KEY_W)) vVelZ -= vCamVel;\n    if (IsKeyDown(KEY_S)) vVelZ += vCamVel;\n        \n    vec2 vRot = ReadVec4(VAR_CAMERA_ROT_xy).xy;\n    mat3 vView = CreateCameraRotationMatrix(vRot);\n        \n    vec3 vPos = vOldValue.xyz + iTimeDelta*vView*vec3(vVelX, vVelY, vVelZ);\n    vPos.y = min(0.99, vPos.y);\n    return vPos;\n}\n\nvec2 CalcCameraRot()\n{    \n    if (iFrame <= 0) return vec2(0.0, 0.0);\n    vec4 vOldValue = ReadVec4(VAR_CAMERA_ROT_xy);\n    float vVelX = 0.0;\n    if (IsKeyDown(KEY_LEFT)) vVelX += CAMERA_ROT_VEL;\n    if (IsKeyDown(KEY_RIGHT)) vVelX -= CAMERA_ROT_VEL;\n    \n    float vVelY = 0.0;\n    if (IsKeyDown(KEY_DOWN)) vVelY += CAMERA_ROT_VEL;\n    if (IsKeyDown(KEY_UP)) vVelY -= CAMERA_ROT_VEL;\n        \n    return vOldValue.xy + iTimeDelta*vec2(vVelX, vVelY);\n}\n\nbool HandleState(vec2 aFragCoord, out vec4 oNewValue)\n{\n    if (IsVariable(aFragCoord, VAR_CAMERA_POS_xyz))\n    {\n        oNewValue = vec4(CalcCameraPos(), 0.0);\n     \treturn true;   \n    }\n    else if (IsVariable(aFragCoord, VAR_CAMERA_ROT_xy))\n    {\n        vec2 vRot = CalcCameraRot();\n\t\toNewValue = vec4(vRot.x, vRot.y, 0.0, 0.0);\n     \treturn true;   \n    }\n    return false;\n}\n\n//===========================================================================\n// Tonemapping\n\nfloat Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nvec3 Tonemap_Uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(vec3(0.0), vec3(m), x);\n    vec3 w2 = step(vec3(m + l0), x);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(x / m, vec3(c)) + b;\n    vec3 S = P - (P - S1) * exp(CP * (x - S0));\n    vec3 L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\n\n//===========================================================================\n// Noise\n\nfloat Hash11(float aN)\n{\n \treturn fract(sin(aN+1.951) * 43758.5454);   \n}\n\nfloat Hash21(vec2 co)\n{\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Noise(vec3 aP)\n{\n \tvec3 p = floor(aP);\n\tvec3 f = fract(aP);\n\n\tf = f*f*(vec3(3.0) - vec3(2.0) * f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(\n\t\tmix(\n\t\t\tmix(Hash11(n + 0.0), Hash11(n + 1.0), f.x),\n\t\t\tmix(Hash11(n + 57.0), Hash11(n + 58.0), f.x),\n\t\t\tf.y),\n\t\tmix(\n\t\t\tmix(Hash11(n + 113.0), Hash11(n + 114.0), f.x),\n\t\t\tmix(Hash11(n + 170.0), Hash11(n + 171.0), f.x),\n\t\t\tf.y),\n\t\tf.z);   \n}\n\nfloat NoiseFBM( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    return textureLod(iChannel1, (p+f+0.5)/32.0, 0.0).x;\n}\n\nfloat fbm( vec3 p )\n{\n    mat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );    \n    float f;\n    f  = 0.5000*NoiseFBM( p ); p = m*p*2.02;\n    f += 0.2500*NoiseFBM( p ); p = m*p*2.03;\n    f += 0.1250*NoiseFBM( p );\n    return f;\n}\n\n//------------------------------\n\nvec2 VolumeDensity(vec3 aP)\n{\n    vec2 vDens = vec2(0);\n    float vD = length(aP - vec3(2.0, 0.0, 0.0));\n\n    float vHeight = pow(fbm(aP.yxz*0.1 + iTime*CLOUDS_SPEED*0.1), 2.0)*10.0;\n    float vTop = CLOUDS_TOP - vHeight;\n\n    if (aP.y >= vTop && aP.y <= CLOUDS_BASE)\n    {\n        aP.x += vHeight * 10.0;\n        float vCov = pow(fbm(aP.yxz*0.05 + iTime*CLOUDS_SPEED*0.5), 1.5)*4.0;\n        aP.x -= vHeight * 10.0;\n\n        float vV = (fbm(aP.yxz*1.0 + iTime*CLOUDS_SPEED*4.0)+\n                    fbm(aP.xzy*3.0 + iTime*CLOUDS_SPEED*8.0)*0.8) * 0.4;\n        vV = pow(vV, 0.5);\n        float vT = (fbm(aP*0.2+ iTime*CLOUDS_SPEED))/max(0.00001, CLOUD_COVERAGE*vCov);\n\t\tvT /= clamp((CLOUDS_BASE - aP.y)/(abs(CLOUDS_BASE-vTop)*0.3), 0.0, 1.0);\n        vT /= clamp((aP.y - vTop)/(abs(CLOUDS_BASE-vTop)*0.5), 0.0, 1.0);\n\n        float vOut;\n        if (vV >= vT+CLOUD_SMOOTHNESS)\n        {\n            vOut = vV;\n        }\n        else if (vV >= vT)\n        {\n            vOut = vV * (vV-vT)/(CLOUD_SMOOTHNESS);\n        }\n        else\n        {\n            vOut = 0.0;\n        }\n        \n        vDens += vec2(vOut*CLOUD_DENSITY_MULT);\n    }\n    \n    if (vD < 1.0)\n    {\n        vDens += vec2(1.0);\n    }\n     \n    vDens += ATMO_DENS;\n    \n    return vDens * vec2(SIGMA_E, SIGMA_S);\n}\n\n//===========================================================================\n// Phase function\n\nfloat HG(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * M_PI * pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n}\n\nfloat Schlick(float k, float costh)\n{\n    return (1.0 - k * k) / (4.0 * M_PI * pow(1.0 - k * costh, 2.0));\n}\n\n\nconst float mieParams[10] = float[10](\n    9.805233e-06,\n    6.500000e+01,\n    -5.500000e+01,\n    8.194068e-01,\n    1.388198e-01,\n    -8.370334e+01,\n    7.810083e+00,\n    2.054747e-03,\n    2.600563e-02,\n    -4.552125e-12\n    );\n\nfloat numericalMieFit(float costh)\n{\n    // This function was optimized to minimize (delta*delta)/reference in order to capture\n    // the low intensity behavior.\n    \n    float p1 = costh + mieParams[3];\n    vec4 expValues = exp(vec4(mieParams[1] *costh+mieParams[2], mieParams[5] *p1*p1, mieParams[6] *costh, mieParams[9] *costh));\n    vec4 expValWeight= vec4(mieParams[0], mieParams[4], mieParams[7], mieParams[8]);\n    return dot(expValues, expValWeight);\n}\n\n//------------------------------\nfloat PhaseFunction(float cosTh)\n{\n    float vPh = 0.0;\n    //vPh = numericalMieFit(cosTh);\n    float vLerp = 0.7;\n    vPh = HG(0.7, cosTh)*vLerp + HG(-0.4, cosTh)*(1.0-vLerp);\n    vPh = max(HG(0.98, cosTh), vPh);\n    return pow(vPh, 1.0/2.2) * 0.2;\n}\n\n\n//===========================================================================\n// Lighting\n\nfloat MarchShadowRay(vec3 aSamplePos, vec3 aLightPos, float aRand)\n{\n    vec3 vRD = aLightPos - aSamplePos;\n    float vMaxMarchDist = min(SHADOW_FAR, length(vRD));\n    vRD = normalize(vRD);\n    \n    float vTrI = 1.0;\n    \n    float vNormRandStep = aRand * gcRcpShadowSteps;\n    float vP = gcRcpShadowSteps;\n    float vD = 0.0;\n    float vNextD;\n    \n    for (int vN = 0; vN < SHADOW_STEPS; ++vN)\n    {\n        vNextD = pow(vP + vNormRandStep, SHADOW_EXP) * vMaxMarchDist;\n        \n        float vSS = vNextD - vD;\n    \tvec3 vPos = aSamplePos + vRD * vD;   \n\n        vec2 vDens = VolumeDensity(vPos);\n        float vSampleE = vDens.x + vDens.y;\n        float vOpticalDepth = vSampleE * vSS;\n        float vTr = exp(-vOpticalDepth);\n        if (vPos.y >= 1.5)\n        {\n            vTr = 0.0;\n        }\n        \n        vTrI *= vTr;\n        if (vTrI < 0.00)\n        {\n            vTrI = 0.0;\n            break;\n        }\n        vD = vNextD; \n        vP += gcRcpShadowSteps;\n    }\n\n    return vTrI;\n}\n\nfloat Ei(float z) \n{ \n    return 0.5772156649015328606065 + log(1e-4 + abs(z)) + z * (1.0 + z * (0.25 + z * ( (1.0/18.0) + z * ( (1.0/96.0) + z * (1.0/600.0) ) ) ) ); // For x!=0 \n}\n\nvec3 EvalAmbient(\n    float aSamplePos, \n    vec3 aTopColor, vec3 aBottomColor, \n    float aTopOfVolume, float aBottomOfVolume,\n\tfloat aExtinctionCoeff)\n{\n    float Hp = max(0.0,aTopOfVolume - aSamplePos); \n    // Height to the top of the volume \n    float a = -aExtinctionCoeff * Hp; \n    vec3 IsotropicScatteringTop = aTopColor * max(vec3(0.0), exp(a) - a * Ei(a));\n    float Hb = max(0.0, aSamplePos - aBottomOfVolume); \n    // Height to the bottom of the volume \n    a = -aExtinctionCoeff * Hb; \n    vec3 IsotropicScatteringBottom = aBottomColor * max(vec3(0.0), exp(a) - a * Ei(a));\n    return IsotropicScatteringTop + IsotropicScatteringBottom;\n}\n\n//===========================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec4 vStateVal = vec4(0);\n    if (HandleState(fragCoord.xy, vStateVal))\n    {\n        fragColor = vStateVal;\n        return;\n    }\n    \n    vec2 vUV = fragCoord.xy / iResolution.xy;\n    float vRand = Hash21(vUV + vec2(iTime*0.01));\n    \n    vec4 vMouse = iMouse / iResolution.xxxx;\n    if (vMouse.xy == vec2(0)) vMouse.xy = vec2(0.3, 0.5);\n  \n    vec3 vBackCol = COLOR_SKY;\n    vec3 vLightCol = COLOR_LIGHT;\n    vec3 vGroundCol = COLOR_GROUND;\n    vec3 vAmbientTop = COLOR_AMBIENT_TOP;\n    vLightCol *= LIGHT_STRENGTH;\n    \n    vec3 vCameraPos = CalcCameraPos();\n    vec2 vRot = CalcCameraRot();\n    vec3 vRO = vec3(vCameraPos);\n\tvec3 vRD = CreateRayDir(fragCoord, vRot);\n\n    vec3 vLightPos = vec3(-800,-(vMouse.y-0.5)*3000.0-1500.0,(vMouse.x-0.5)*2000.0);\n    \n    float vLAmount = dot(vec3(0.0, -1.0, 0.0), normalize(vLightPos));\n    \n    vBackCol *= vLAmount;\n    vGroundCol *= vLAmount;\n    vAmbientTop *= vLAmount;\n    vLightCol *= vLAmount;\n\n\n    float vNormRandStep = vRand * gcRcpSteps;\n    float vNormD = gcRcpSteps;\n    float vNextD;\n    float vMarchD = 0.0;\n    \n    float vTrI = 1.0;\n    vec3 vScI = vec3(0);\n    float vAlpha = 0.0;\n    \n    float vDepth = -1.0;\n    \n    for (int vN = 0; vN < MARCH_STEPS; ++vN)\n    {\n        vNextD = pow(vNormD + vNormRandStep, MARCH_EXP) * FAR;\n        float vSS = vNextD - vMarchD;\n   \t\tvec3 vPos = vRO + vRD * vMarchD;\n        \n        if (vPos.y >= 1.0)\n        {\n            float vAtt = pow(length(vLightPos-vPos), LIGHT_FALLOFF);\n\n            vec3 vLightDir = normalize(vLightPos-vPos);\n\t\t\tfloat diff = max(dot(vec3(0.0, -1.0, 0.0), vLightDir), 0.0);\n            \n            float vLightTr = MarchShadowRay(vPos, vLightPos, Hash21(vPos.xy + iTime));\n\n            vec3 vLight = vLightCol * vLightTr / vAtt;\n            \n\t\t\tvec3 diffuse = diff * vLight;   \n            \n            vec3 vViewDir = normalize(vRO - vPos);\n\t\t\tvec3 reflectDir = reflect(-vLightDir, vec3(0.0, -1.0, 0.0));  \n            float spec = pow(max(dot(vViewDir, reflectDir),0.0), 8.0);\n\t\t\tvec3 specular = spec * vLight;  \n            \n            vec3 vOut = vTrI * (vGroundCol * (min(vec3(1),0.13*((diffuse + specular))) + 0.15*vAmbientTop));\n         \tvScI += vOut;\n\t\t\tif (vDepth < 0.0)\n            {\n                vDepth = vMarchD;\n            }\n            vAlpha = 1.0;\n            break;\n        }\n        \n        vec2 vDens = VolumeDensity(vPos);\n        if (vDens != vec2(0))\n        {\n            float vAngle = dot(normalize(vLightPos-vPos), vRD);\n            \n        \tfloat vSampleA = max(0.0000001, vDens.x);\n            float vSampleS = vDens.y;\n            float vSampleE = vSampleA + vSampleS;\n            \n            float vOpticalDepth = vSampleE * vSS;\n            float vPowder = exp(-vOpticalDepth * POWDER_COEFF);\n            float vTr = exp(-vOpticalDepth) * vPowder;\n            \n            float vLightTr = MarchShadowRay(vPos, vLightPos, Hash21(vPos.xy + iTime));\n\n            float vDistToLight = length(vPos - vLightPos);\n            vec3 vLightOrders = vec3(0);\n                \n            float vLightAtt = 1.0 / pow(vDistToLight, LIGHT_FALLOFF);\n            float b = 1.0;\n            float c = 1.0;\n            \n            float vPh = PhaseFunction(vAngle);\n            for (int vOrderS = 0; vOrderS < 2 ;++vOrderS)\n            {\n            \tfloat vPh = PhaseFunction(vAngle * c);\n               \n\t\t\t\tvLightOrders += b * vLightCol * pow(vLightTr, c) * vPh * vLightAtt;\n            \tb = b * 0.5;\n                c = c * 0.5;\n            }\n            \n            vec3 vPosAmbient = EvalAmbient(vPos.y, COLOR_AMBIENT_BOTTOM, vAmbientTop, \n                                           CLOUDS_BASE, CLOUDS_TOP, AMBIENT_EXTICTION);\n            vec3 vTotalLight = vLightOrders + vPosAmbient;\n            vec3 vS = (vTotalLight) * vSampleS * vTrI;\n            vec3 vSInt = vTrI * (vS - vS*vTr)/vSampleE;\n            vScI += vSInt;\n\n            if (vDepth < 0.0 && vDens.y > ATMO_DENS.y)\n            {\n                vDepth = vMarchD;\n            }\n            vTrI *= vTr;\n            \n            vAlpha+=(1.0-vTr)*(1.0-vAlpha);\n \t\t\tif (vTrI < 0.02)\n            {\n                break;\n            }\n        }\n        vMarchD = vNextD; \n        vNormD += gcRcpSteps;\n    }\n\n    \n    vScI = Tonemap_Uchimura(vScI, 1.0, 1.7, 0.1, 0.0, 1.33, 0.0);\n    vAlpha = Tonemap_Uchimura(vAlpha, 1.0, 1.7, 0.1, 0.0, 1.33, 0.0);    \n\n    \n    vec3 vCol = mix(vBackCol, vScI/(0.000001+vAlpha), vAlpha);\n\n    vec4 vOut = vec4(vCol, 1.0);\n    vDepth = min(vDepth, 1000000.0);\n    if (vDepth < 0.0) vDepth = FAR;\n   \tfragColor = vec4(vOut.rgb, vDepth);    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define M_PI 3.14159265\n\n//================\n// Camera\n#define FOV 60.0\n#define FAR 500.0\n\n\n//===========================================================================\n// Variables\n\n\nbool IsVariable(vec2 aFragCoord, int aVarId)\n{\n    return \n        aFragCoord.y < 1.0 && \n        aFragCoord.y >= 0.0 && \n        int(round(aFragCoord.x-0.5)) == aVarId;\n}\n\nvec4 ReadVec4(sampler2D aCh, int aVarId)\n{\n\treturn texelFetch(aCh, ivec2(aVarId, 0), 0);\n}\n\nvec4 ReadVec4(sampler2D aCh, vec2 aFragCoord)\n{\n    return texture(aCh, aFragCoord / iChannelResolution[0].xy);\n}\n\n\nmat4 CreateWorldToViewMatrix(const vec3 aCamPos, const vec2 aCamRot)\n{\n    float vCosY = cos(aCamRot.y);\n    vec3 vCameraFront = vec3(\n        vCosY * cos(aCamRot.x),\n        sin(aCamRot.y),\n        vCosY * sin(aCamRot.x));\n    \n    vCameraFront = normalize(vCameraFront);\n        \n    vec3 vUp = cross(cross(vCameraFront, vec3(0.0,1.0,0.0)), vCameraFront);\n        vUp = normalize(vUp);\n\n    vec3 vRight = cross(vCameraFront, vUp);\n    vRight = normalize(vRight);\n\n    return mat4(vec4(vRight.x, vUp.x, vCameraFront.x, -aCamPos.x),\n                vec4(vRight.y, vUp.y, vCameraFront.y, -aCamPos.y),\n                vec4(vRight.z, vUp.z, vCameraFront.z, -aCamPos.z),\n                vec4(0.0, 0.0, 0.0, 1.0)\n               );\n}\n \nmat3 CreateCameraRotationMatrix(const vec2 aCamRot)\n{\n    float vCosY = cos(aCamRot.y);\n    vec3 vCameraFront = vec3(\n        vCosY * cos(aCamRot.x),\n        sin(aCamRot.y),\n        vCosY * sin(aCamRot.x));\n    \n    vCameraFront = normalize(vCameraFront);\n        \n    vec3 vUp = cross(cross(vCameraFront, vec3(0.0,1.0,0.0)), vCameraFront);\n        vUp = normalize(vUp);\n\n    vec3 vRight = cross(vCameraFront, vUp);\n    vRight = normalize(vRight);\n\n    return mat3(vRight, vUp, vCameraFront);\n}\n\n\nvec2 UVToFragCoord(const in vec2 aUV)\n{\n\tvec2 vFragCoord = aUV * 2.0 - 1.0;\n\tvFragCoord.x *= iResolution.x / iResolution.y;\n\treturn vFragCoord;\t\n}\n\nvec3 CreateRayDir(const vec2 vFragCoord, const vec2 aCamRot)\n{  \n    float vAspectRatio = iResolution.x / iResolution.y;\n    float vTan = tan(0.5 * radians(FOV));\n    vec3 vRD = vec3(\n        (2.0 * ((vFragCoord.x+0.5) / iResolution.x) - 1.0) * vTan * vAspectRatio,\n        (1.0 - 2.0 * ((vFragCoord.y+0.5) / iResolution.y)) * vTan,\n        -1.0);\n    vRD = normalize(vRD);\n   \tmat3 vMatView = CreateCameraRotationMatrix(aCamRot);\n    return vMatView * vRD;\n}\n\nvec2 FragCoordToUV(const in vec2 aFragCoord)\n{\n    vec2 vScaledFragCoord = aFragCoord;\n    vScaledFragCoord.x *= iResolution.y / iResolution.x;\n    return (vScaledFragCoord * 0.5 + 0.5);\n}\n\nvec2 WorldToUV(const in vec3 aWorldPos,\n               const in vec3 aCamPos, \n               const in vec2 aCamRot)\n{\n    vec3 vRD = aWorldPos - aCamPos;\n    vRD = vRD * CreateCameraRotationMatrix(aCamRot);\n\tvRD = normalize(vRD);\n    \n    vec2 vOfs = vec2(0.5) / iResolution.xy;\n    float vAspectRatio = iResolution.x / iResolution.y;\n    float vTan = tan(0.5 * radians(FOV));\n    \n    vRD = vRD / vRD.z;\n    vec2 vUV = vec2((vRD.x / (vAspectRatio * vTan) + 1.0) / 2.0,\n                    (1.0 - (vRD.y / vTan)) / 2.0) + vOfs;\n    \n    vUV = 1.0 - vUV;\n    return vUV;\n}\n\n\n#define VAR_CAMERA_POS_xyz 0\n#define VAR_CAMERA_ROT_xy 1\n\nbool HandleState(vec2 aFragCoord, out vec4 oNewValue)\n{\n    if (IsVariable(aFragCoord, VAR_CAMERA_POS_xyz))\n    {\n        vec4 vOldValue = ReadVec4(iChannel0, VAR_CAMERA_POS_xyz);\n        oNewValue = vOldValue;\n     \treturn true;   \n    }\n    else if (IsVariable(aFragCoord, VAR_CAMERA_ROT_xy))\n    {\n        vec4 vOldValue = ReadVec4(iChannel0, VAR_CAMERA_ROT_xy);\n        oNewValue = vOldValue;\n     \treturn true;   \n    }\n    return false;\n}\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\n\nvec3 clipToAABB(in vec3 cOld, in vec3 cNew, in vec3 centre, in vec3 halfSize)\n{\n    if (all(lessThanEqual(abs(cOld - centre), halfSize))) {\n        return cOld;\n    }\n    \n    vec3 dir = (cNew - cOld);\n    vec3 near = centre - sign(dir) * halfSize;\n    vec3 tAll = (near - cOld) / dir;\n    float t = 1e20;\n    for (int i = 0; i < 3; i++) {\n        if (tAll[i] >= 0.0 && tAll[i] < t) {\n            t = tAll[i];\n        }\n    }\n    \n    if (t >= 1e20) {\n\t\treturn cOld;\n    }\n    return cOld + dir * t;\n}\n\n\nivec2 offsets[8] = ivec2[8]( \n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nfloat gCoeffs[8] = float[8](\n    0.024879, 0.024879, \n    0.024879, 0.024879,\n    0.107973, 0.107973,\n    0.107973, 0.107973);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    if (HandleState(fragCoord.xy, fragColor))\n    {\n        return;\n    }\n    \n    vec2 vUV = fragCoord / iResolution.xy;\n    \n    \n    \n    // Current (new)\n    vec4 vCurr = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    float vCurrDepth = vCurr.w;\n\tvec3 vCurrRO = ReadVec4(iChannel0, VAR_CAMERA_POS_xyz).xyz;\n    vec2 vCurrRot = ReadVec4(iChannel0, VAR_CAMERA_ROT_xy).xy;\n    vec3 vCurrRD = CreateRayDir(fragCoord, vCurrRot);\n    \n    // Previous (history)\n\tvec3 vPrevRO = ReadVec4(iChannel1, VAR_CAMERA_POS_xyz).xyz;\n    vec2 vPrevRot = ReadVec4(iChannel1, VAR_CAMERA_ROT_xy).xy;\n\n    // Reproject\n    vec3 vCurrPos = vCurrRO + vCurrRD * vCurrDepth;\n    vec2 vPrevUV = WorldToUV(vCurrPos, vPrevRO, vPrevRot);\n    //vec3 vPrevRD = CreateRayDir(vPrevUV * iResolution.xy, vPrevRot);\n    vec4 vPrev = texture(iChannel1, vPrevUV);\n\tfloat vPrevDepth = vPrev.w;\n\n    // Variance clipping\n    vec3 vNew = RGBToYCoCg(vCurr.rgb);\n    vec3 vHist = RGBToYCoCg(vPrev.rgb);\n\n    vec3 colorAvg = vNew * 0.468592;\n    vec3 colorVar = vNew*vNew * 0.468592;\n    //float depthAvg = vCurrDepth;\n    //float depthVar = vCurrDepth * vCurrDepth * 0.468592;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec4 vSample = texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0);\n        vec3 fetch = RGBToYCoCg(vSample.xyz);\n        colorAvg += fetch * gCoeffs[i];\n        colorVar += fetch*fetch * gCoeffs[i];\n        //depthAvg += vSample.z * gCoeffs[i];\n        //depthVar += vSample.z*vSample.z * gCoeffs[i];\n    }\n    //colorAvg /= 9.0;\n    //colorVar /= 9.0;\n    \n    float gColorBoxSigma = 1.5;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n\n    //float gDepthBoxSigma = 3.0;\n\t//float depthsigma = sqrt(max(0.0, depthVar - depthAvg*depthAvg));\n\t//float depthMin = depthAvg - gDepthBoxSigma * depthsigma;\n\t//float depthMax = depthAvg + gDepthBoxSigma * depthsigma;\n    \n    vPrev.rgb = clamp(vHist, colorMin, colorMax);\n    //vCurrDepth = clamp(vCurrDepth, depthMin, depthMax);\n    //vec3 vPrevPos = vPrevRO + vPrevRD * vPrevDepth;\n    \n    float vLerp = 0.0;\n    //bool vPosTestPass = distance(vCurrPos, vPrevPos) < depthMin * 0.1;\n        \n    \n    if (vPrevUV.x > 0.0 && vPrevUV.x < 1.0 &&\n        vPrevUV.y > 0.0 && vPrevUV.y < 1.0 || vPrevDepth < 0.0)// && \n//        vPosTestPass)\n    {\n        vLerp = 0.99;\n    }\n   \n        \n\tvec4 vFinal = vec4(YCoCgToRGB(mix(vNew, vPrev.rgb, vLerp)), vCurrDepth);\n    //vec4 vFinal = vec4(mix(vCurr.rgb, vPrev.rgb, vLerp), vCurrDepth);\n    //if (vUV.x > 0.5)\n    {\n    \tfragColor = vFinal;    \n    }\n    //else\n    //{\n    //\tfragColor = vec4(vCurr.xyz, 1.0);    \n    //}\n}","name":"Buffer B","description":"","type":"buffer"}]}