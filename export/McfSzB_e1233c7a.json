{"ver":"0.1","info":{"id":"McfSzB","date":"1705403225","viewed":119,"name":"truchet ring and tapes","username":"lijiyong","description":"made this shader using purge color and flats aspect designed view.\nthanks for watching and hope you will like this truchet styles.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["ring","truchet","electrons","twist","tapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Truchet ring and tapes\n    by LJY studio presets.\n    Copyright ( c ) 2024 LJY ST.\n    \n    made this shader using purge color and flats aspect designed view.\n    thanks for watching and hope you will like this truchet styles.\n*/\n\n#define I iResolution\n#define A min(I.x, I.y)\n#define T iTime // hash available in 9000 sec\n#define PI 3.1415\n#define TAU PI * 2.\n#define rot(a)                                                                 \\\n  mat2(cos(a + vec4(0, 11, 33, 0))) // ignored precision when 3D map\n// hash\n#define h(u) fract(dot(u.yxx * .1234, sign(u.yxx) + 1.12) * 123.456)\n// division\n#define k( p ) min( min( abs(p-.02), abs(p+.02) ), abs(p) ); \n\nfloat M, R, RC; // RC = curved index\n\n// rep uv around by myself\nfloat rep(inout vec2 u, float rep){\n\n    float r = 6.28 / rep; // each radian\n    \n    float a = round( atan(u.y, u.x) / r ) * r; // aligned uv\n    \n    u = vec2(\n        dot( u, vec2( cos(a), sin(a) ) ),\n        dot( u, vec2( -sin(a), cos(a) ) )\n    );\n    \n    return floor( mod( ( round( a / r ) + rep * .5 ), rep ) ); // index\n\n}\n\nfloat getSplit(vec3 p, float t, float i) {\n  // arc split each curved\n  /*\n      construction curve by time detal, that means willing antialias curves\n  */\n  float z = fract(atan(p.x, p.y) / PI * .5);\n  z = step(z,\n           .6 + sin( (t * .2 - ( i + 3. ) * 3.) * i) * .5 // current detal\n  );\n  return z;\n}\n\n// sd mainRing\nfloat f(vec3 p) {\n  vec2 q = vec2(length(p.xz) - .6, p.y);\n\n  // twist\n  vec3 g = p;\n  g.xz *= rot(cos(T));\n  q.xy *= rot(g.x * 3. - T);\n\n  return M = max(abs(q.x) - .05, abs(q.y) - .05);\n}\n\n// sd ribbon curved\nvec2 s(vec3 p, float l /* l = timeline */) {\n\n  p.xz *= rot(l * .2);\n  RC = rep(p.xz, 5.);\n  \n  if( RC != 0. )\n      p.y *= sign( RC ); // direction steps\n  \n  p.x -= .8;\n  \n  // position noise\n  p.z += sin( p.z * .5 ) / 5.;\n  // curve twist\n  p.xz *= rot(p.y * 1.2);\n  p.xz *= rot((p.y) * (p.x + p.z));\n  p.xy *= rot(RC * 2. - l);\n  \n\n  float z = .1, j, c = 6.; // c = ribbon tape side / edge antialias, additional more tape adjusted this value\n\n  for (; j < c; j++)\n    z = min(z, getSplit(p, l - j * (j / c), RC)); // z was ARC segment overlayed\n\n  vec2 q = vec2(length(p.xy) - .5, p.z);\n\n  return vec2(R = max(max(abs(q.x) - 1e-5, abs(q.y) - .05), z), RC);\n}\n\nfloat df(vec3 p) { return min(f(p), s(p, T).x); }\n\n// get normal\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\n// get truchet texture\nfloat tex(vec2 u, int t) {\n  float r = h(abs(round(u / -.2) - 20.)), g, p;\n  u = mod(u + .1, .2) - .1, u *= rot(round(r) * 1.57),\n  u -= sign(u.x + u.y) * .1;\n  \n  p = length(u) - .1;\n  g = (t == 0) ? abs(p) : k(p);\n  \n  return smoothstep(5. / A, 0., g );\n}\n\nvec3 trace(vec2 u) {\n\n  vec3 c, p,\n      // adjustd camera aspect\n      o = vec3(0., 0., -3.), r = vec3(u * .25, 1.);\n\n  float t, d, i;\n  \n  for (; i < 256.; i++) { // raymarching\n    p = o + r * t,\n    // trasform position\n        p.zy *= rot(PI * .3 + cos(T) * .2), p.xz *= rot(cos( T ) * -.2), d = df(p),\n    t += d * (d == M ? .445 : .14); // rotX antialias\n    if (d < 1e-3 || t > 5.)\n      break; // safe march optimized performance\n  }\n\n  if (d < 1e-3) { // shaded color\n\n    c += .11; // saturation\n    vec3 n = l(p);\n\n    float m = max(max(max(max(-n.z, n.y), -n.x), n.x), 0.), // map ring\n          m2 = dot( n, vec3( max( n.x, n.y ), dot( n, n ), n.z ) ); // map curve\n\n    if (df(p) == M) {\n      \n      c += clamp( dot( r, n ), 0., 1. ) * .1;\n      c += vec3(1, 3, 4) * .1;          // ring color\n      c += m * tex(p.xz * 3. + T * .1, 0); // map truchets to main ring\n\n    } else {\n\n      // random color\n      c += vec3(h(vec2( 5., RC + 3.)), h(vec2(RC, 5.)),\n                h(vec2( RC + 2., RC + 3.))) *\n           .3;\n\n      c += m2 * tex(p.xz * 5., 0) * .3; // map truchets to curved\n\n      c = sqrt(c); // gama\n    }\n  }\n\n  return c;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec2 u = (U * 2. - I.xy) / A; // normalized uv\n\n  vec3 c = cos(vec3(u.x - sin(4e2 * u.y), u.y, sin(u.x))) * .3, r = trace( u ); // background crt noise\n\n  c += tex(u, 1) * .05; // background truchets\n  \n  // raymarch results\n  c = mix(\n      c,\n      r.rgb,\n      clamp( r.r * 5., 0., 1. )\n  );\n\n  O = c.rgbg;\n}\n","name":"Image","description":"","type":"image"}]}