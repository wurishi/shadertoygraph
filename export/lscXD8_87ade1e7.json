{"ver":"0.1","info":{"id":"lscXD8","date":"1459009624","viewed":1262,"name":"afunctional iteration","username":"Linusmartensson","description":"Working to get something interesting going based on the flame fractal algorithm. Exceedingly slow, but quite pleasant stills.","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float s0;\n\nfloat rand(float f){\n  return mod(f*32151.0+13425.20,4096.0)/4096.0;   \n}\nfloat rand0(){\n  s0 = rand(s0);\n  return mod(s0*54921.0+53425.20,4096.0)/4096.0;   \n    \n}\n\nvec2 rand20(){\n    return vec2(rand0(),rand0());\n}\n\n\nfloat df(in vec2 uv, in vec2 pt, in float m){\n  return m/(0.01+0.5*(dot(uv-pt, uv-pt)));   \n}\n\nvoid f(in vec2 uv, inout vec2 pt, inout vec3 color, inout float density, in vec2 spt){\n    float m, dens;\n    vec2 jpt;\n\n    vec2 qpt = vec2(0.0);\n\n    float q;\n    vec2 c, s;\n\n    vec2 ipt = pt;\n    \n    q = (rand0()*2.0-1.0)*0.1*iTime;\n    c = vec2(1.0)*cos(q);\n    s = vec2(1.0,-1.0)*sin(q);\n    pt = vec2(pt.x*c.x+pt.y*s.y,pt.x*s.x+pt.y*c.y);\n    dens = df(uv,pt,1.0);\n    density += dens;\n    color += dens * vec3(-0.03,0.02,0.07);\n\n    \n\tm = rand0()*0.25;\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    q = iTime*0.01*(rand0()*2.0-1.0);\n    c = vec2(1.0)*cos(q);\n    s = vec2(1.0,-1.0)*sin(q);\n    qpt = m*vec2(jpt.x*c.x+jpt.y*s.y,jpt.x*s.x+jpt.y*c.y);\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(4.67,0.67,0.0) / distance(jpt,qpt);\n  \n\tm = rand0();\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    qpt = m*(sin(jpt.xy+iTime*rand0()*2.0-1.0));\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(1.0,0.5,0.0);\n\n    m = rand0();\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    qpt = m*(((uv-jpt))*(rand0()*2.0-1.0));\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(4.0,2.1,1.0);\n\n    m = rand0()*0.5;\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    qpt = m*((jpt));\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(2.0,2.1,9.0);\n\n    \n    \n    m = rand0()*0.5;\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    qpt = m*(jpt*sin(jpt*0.1+sin(iTime*0.12+jpt.xy*0.5*(rand20()-0.5))));\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(3.0,1.30,0.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    s0 = 320.0;\n    float r = 80.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy * r - 0.5*r;\n    fragColor = vec4(1.0);\n    \n    for(int i=0;i<3;++i){\n        \t\n        float density = 0.0;\n        vec3 color = vec3(0.0);\n        vec2 pt = rand20() * r - 0.5*r;\n \t\tvec2 spt = pt;      \n        for(int j=0;j<24;++j){\n            float dens=0.0;\n            vec3 col = vec3(0.0);\n            \n            f(uv, pt, col, dens, spt);\n            \n            if(j>5){\n                density += dens;\n                color += col;\n            }\n        }\n        \n        fragColor += vec4(vec3(color)/(0.1+density), 1.0);//*(iTime/(10.+float(i)+iTime));\n\n    }\n    fragColor.xyz = smoothstep(0.5,3.0,fragColor.xyz);\n}","name":"Image","description":"","type":"image"}]}