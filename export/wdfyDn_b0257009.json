{"ver":"0.1","info":{"id":"wdfyDn","date":"1584612360","viewed":100,"name":"My Ray Marching for Dummies","username":"hummerrr","description":"https://www.youtube.com/watch?v=PGtv-dBi2wE","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define SURFACE_DISTANCE .001\n#define GAMMA 2.2\n#define PI 3.14159265\n#define TWO_PI 6.283185307\n\nstruct Ray\n{\n    vec3 o, d;\n};\n    \nstruct capsule\n{\n\tvec3 p,a,b;\n    float radius;\n};\n\nfloat GetDistance(vec3 p);\nfloat RayMarch(Ray ray);\nfloat Capsule(capsule cs);\n\nmat2 rot(float angle)\n{\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nfloat Sphere(vec3 p)\n{\n    vec3 spherePos = vec3(0,1,6);\n    float radius = 1.;\t\n    float sphereDistance = length(p-spherePos)-radius;\n \treturn sphereDistance;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDistance(p);\n    vec2 e = vec2(.001,0);\n    vec3 n = d - vec3(\n        GetDistance(p-e.xyy),\n        GetDistance(p-e.yxy),\n        GetDistance(p-e.yyx)\n    );\n    return normalize(n);\n}\n \nfloat GetLight(vec3 p, Ray ray)\n{\n    vec3 lightPos = ray.o-vec3(-5.,-1.5,0.);\n    vec3 lightVector = normalize(lightPos-p);\n    vec3 normal = GetNormal(p);\n    \n    float diffuse = clamp(dot(normal, lightVector),0.,1.);\n    Ray shadow;\n    shadow.o = p+normal*SURFACE_DISTANCE*2.;\n    shadow.d = lightVector;\n    float shadowColor = RayMarch(shadow);\n    if(shadowColor<=length(lightPos-p)) diffuse *= 0.25;\n    \n  \treturn diffuse;\n}\n\nvec3 CamSys(vec2 uv, vec3 eye, vec3 target, float zoom)\n{        \n    vec3 f = normalize(target-eye);\n    vec3 r = normalize(cross(vec3(0.,1.,0.), f));\n    vec3 u = normalize(cross(f, r));\n    vec3 center = eye + f*zoom;\n    vec3 intersection = center + uv.x*r + uv.y*u;\n    return intersection - eye;\n}\n\nfloat RayMarch(Ray ray)\n{\n    float distanceToOrigin = 0.;        \n    for(int i=0;i<MAX_STEPS;i++)\n    {\n\t\tvec3 p = ray.o + ray.d * distanceToOrigin;        \n        float distanceToScene = GetDistance(p);\n        distanceToOrigin += distanceToScene;\n        \n        if(distanceToOrigin > MAX_DISTANCE ||\n           distanceToScene < SURFACE_DISTANCE)\n        break;\n    }   \n    return distanceToOrigin;\n}\n\nfloat Capsule(capsule cs)\n{\n \tvec3 ab = cs.b-cs.a;\n    vec3 ap = cs.p-cs.a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t,0.,1.);    \n    vec3 c = cs.a + t*ab;\n    return length(cs.p-c)-cs.radius;\n}\n\ncapsule VCapsule(capsule oldCaps, vec3 off)\n{\n    capsule newCaps = capsule(oldCaps.p, oldCaps.b, oldCaps.b+off, oldCaps.radius-0.02);\n    return newCaps;\n}\n\nfloat GetDistance(vec3 p)\n{    \n    float planeDistance = p.y;\n    float objectDistance = 0.;\n    capsule cs;    \n    cs.a = vec3(0,0.1,0.), cs.b = vec3(0,1,0.), cs.radius = 0.1;\n    cs.p = p;  \n\n    //trunk\n    objectDistance = Capsule(cs);\n    //1.\n    capsule left = VCapsule(cs,vec3(-.5,.5,.0));\n    objectDistance = min(objectDistance, Capsule(left));\n    capsule right = VCapsule(cs,vec3(.5,.5,.0));\n    objectDistance = min(objectDistance, Capsule(right));\n\n    //2.    \n    cs = left;\n    capsule left1 = VCapsule(cs,vec3(.25,.5,.0));\n    objectDistance = min(objectDistance, Capsule(left1));\n    capsule left2 = VCapsule(cs,vec3(-.25,.5,.0));\n    objectDistance = min(objectDistance, Capsule(left2));\n    //2.\n    cs = right;\n    capsule right1 = VCapsule(cs,vec3(.25,.5,.0));\n    objectDistance = min(objectDistance, Capsule(right1));\n    capsule right2 = VCapsule(cs,vec3(-.25,.5,.0));\n    objectDistance = min(objectDistance, Capsule(right2));    \n\n    return min(objectDistance, planeDistance);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0);\n    Ray ray;\n    ray.o = vec3(0.,1,-5);    \n    ray.o.zx *= rot(.0);\n    ray.d = CamSys(uv,ray.o,vec3(0.,1.,0.),1.0);\n    \n    float d = RayMarch(ray);\n    if(d < MAX_DISTANCE) {\n        vec3 p = ray.o+ray.d*d;\n        float diff = GetLight(p, ray);    \n        color = vec3(diff);\n    }\n    fragColor = vec4(pow(color, vec3(1./GAMMA)), 1.0);\n}","name":"Image","description":"","type":"image"}]}