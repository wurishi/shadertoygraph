{"ver":"0.1","info":{"id":"ls3cRM","date":"1519273544","viewed":203,"name":"Hyperboloid Raymarch","username":"dmemes","description":"raymarch of a hyperboloid","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","hyperboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHTDIR normalize(vec3(.9, .15, -.5))\n#define LIGHTCOL vec3(1.0, 1.0, .85)\n#define TEXSCALE .3\n\n#define A 5.0\n#define B 5.0\n#define C 15.0\n\n#define GRID\n#define GRIDTHICKNESS 2.0\n\nfloat map(vec3 p) {\n    // hyperoboloid: x^2/A + z^2/B - y^2/C = 1.0\n    // xz cross sections are ellipses:\n    // x^2/A + z^2/B = 1.0 + y^2/C\n    // (x^2/A + z^2/B) / (1.0 + y^2/C) = 1.0\n    // radius = sqrt(1.0 + y^2/C)\n    return sqrt(p.x * p.x / A + p.z * p.z / B) - sqrt(1.0 + p.y*p.y / C);\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\nvec3 shade(vec3 p){\n    vec3 norm = calcNormal(p);\n    \n    vec3 col = vec3(1.0);\n    \n\t// triplanar texture\n    vec3 blend = abs(norm);\n    blend /= (blend.x + blend.y + blend.z);\n    col = texture(iChannel0, TEXSCALE * p.yz).rgb * blend.x +\n          texture(iChannel0, TEXSCALE * p.xz).rgb * blend.y +\n          texture(iChannel0, TEXSCALE * p.xy).rgb * blend.z;\n    \n    float ndotl = clamp(dot(norm, LIGHTDIR), 0.0, 1.0);\n    vec3 light = LIGHTCOL * ndotl * ndotl;\n    light += .15; // ambient light\n    col *= light;\n    \n    #ifdef GRID\n    vec3 grid = vec3(\n        min(1.0, GRIDTHICKNESS * pow(abs(fract(p.x) - .5) + .5, 50.0)),\n        min(1.0, GRIDTHICKNESS * pow(abs(fract(p.y) - .5) + .5, 50.0)),\n        min(1.0, GRIDTHICKNESS * pow(abs(fract(p.z) - .5) + .5, 50.0)));\n    col = mix(col, grid, clamp(length(grid) - .2, 0.0, 1.0));\n    #endif\n    \n    return col;\n}\n\n// https://www.shadertoy.com/view/4slGD4\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t) {\n    float halfwayT;\n    for (int i = 0; i < 5; i++) {\n\n        halfwayT = dot(t, vec2(.5));\n        float d = map(rO + halfwayT*rD); \n        t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\n\n    }\n\treturn dot(t, vec2(.5));\n}\n\nvec3 background(vec3 ro, vec3 rd){\n    float light = clamp(dot(rd, LIGHTDIR), 0.0, 1.0);\n    return (50.0 * pow(light, 5000.0) + .3 * pow(light, 50.0)) * LIGHTCOL;\n}\n\nvec3 march(vec3 ro, vec3 rd){\n    vec2 t = vec2(0.0, 0.0);\n    bool c = false;\n    for (int i = 0; i < 128; i++){\n        vec3 p = ro + rd * t.x;\n        float d = map(p);\n        if (d < 0.0) {\n            t.x = BinarySubdivision(ro, rd, t);\n            c = true;\n            break;\n        }\n        t.y = t.x;\n    \tt.x += max(.5 * d, .01);\n    }\n    if (!c) t.x = 1000.0;\n    \n    \n    vec3 col = background(ro, rd);\n    if (c) col = shade(ro + rd * t.x);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 rd = vec3((uv.x - .5), (uv.y - .5) * iResolution.y / iResolution.x, 1.0);\n    rd = normalize(rd);\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x = (mouse.x - .5) * 3.1415926 * 2.0;\n    \n    mouse.y = max(mouse.y, .25);\n    vec3 ro = -(mouse.y * 50.0 + 2.5) * vec3(sin(mouse.x), 0.0, cos(mouse.x)) + vec3(0.0, -50.0 * (mouse.y - .5), 0.0);\n\n    vec3 fwd = normalize(-ro);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), fwd);\n    vec3 up = cross(fwd, right);\n    \n    rd = rd.x * right +\n         rd.y * up +\n         rd.z * fwd;\n    rd = normalize(rd);\n    \n    vec3 col = march(ro, rd);\n   \tfragColor = vec4(col, 20.0);\n}","name":"Image","description":"","type":"image"}]}