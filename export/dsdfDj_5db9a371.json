{"ver":"0.1","info":{"id":"dsdfDj","date":"1697673021","viewed":77,"name":"00GraphicsClassLesson12","username":"foodini","description":"I'm using this as an intro point in a class on computer graphics. The intent is to show people how to create cool shapes, then work backward from there to help them understand raymarching. It's always best to get people fiddling as early as possible.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","interview"],"hasliked":0,"parentid":"mddBDr","parentname":"00GraphicsClassLesson11"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Your frame rate will be inversely proportional to the max dist you\n// choose in your distance functions. \n\nfloat map_composite_object( in vec3 p) {\n    return sdf_sphere(p, 1.5);\n}\n\nbool dist_to_composite_object( in vec3 p, in vec3 d, out float total_dist, out int iterations ) {\n    total_dist = 0.0;\n    for(int iterations=0; iterations<150; iterations++) {\n        float dist = map_composite_object(p);\n        total_dist += dist;\n        if(dist < 0.001) {\n            return true;\n        }\n        if(total_dist > 100.0) {\n            return false;\n        }\n        p += dist * d;\n    }\n    return false;\n}\n\nconst float sqrt2_inv = 1.0/sqrt(2.0);\nfloat map_terrain( in vec3 p ) {\n    // ASSUMING WE ARE ABOVE IT.... we have to see how far we are from the perlin surface.\n    // This is done a bit heuristically. The perlin surface spans from -2.0 to 0.0, but our\n    // distance from it cannot be determined absolutely. All we can do is guess a minimum distance.\n    // If we are y units above the perlin surface and the surface can be no steeper than 45 degrees,\n    // then we can be no nearer than y/sqrt(2) units from the surface.\n    float terrain_height = (perlin(vec3(p.xz, iTime)) * 0.5) - 1.5;\n    return (p.y-terrain_height)*sqrt2_inv;\n}\n\n// For simplicity, the ground can only be seen from above.\nbool dist_to_terrain( in vec3 p, in vec3 d, out float total_dist) {\n    total_dist = 0.0;\n\n    if(p.y > 0.0) {\n        // If p is above the ground's max altitude (0.0), d had better point downward.\n        if(d.y >= 0.0) {\n            return false;\n        } else {\n            // This computes \"how many\" ds we need to travel from p to get to the y==0.0 plane:\n            float scale = -p.y/d.y;\n\n            // Assuming d is normalized (which it should be), this just returns scale:\n            total_dist = length(d*scale);\n            \n            p += d * total_dist;\n        }\n    }\n\n    // Do a standard ray march....\n    for(int iterations=0; iterations<150; iterations++) {\n        float dist = map_terrain(p);\n        total_dist += dist;\n        if(dist < 0.001) {\n            return true;\n        }\n        if(total_dist > 20.0) {\n            return false;\n        }\n        p += dist * d;\n    }\n    return false;\n\n}\n\nvec3 calc_normal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    vec3 normal = normalize( \n        vec3(map_composite_object(p+h.xyy) - map_composite_object(p-h.xyy),\n             map_composite_object(p+h.yxy) - map_composite_object(p-h.yxy),\n             map_composite_object(p+h.yyx) - map_composite_object(p-h.yyx) ) );\n    return normal;\n}\n\n// Nothing says the light_col is limited to values <= 1.0!!!\nvec3 light_col = vec3(0.8, 0.6, 1.0);\nvec3 light_pos = vec3(2.0, 5.0, 2.0);\nfloat light_size = 1.0;\n\nbool is_shadowed(in vec3 p, in vec3 normal, in vec3 light_pos) {\n    float distance_travelled = 0.0;\n    \n    // p is already very close to a surface. If we just check to see how far from\n    // that surface we are and assume we've hit it when d<0.001, we'll always think\n    // we've hit it in the first iteration. What happens if this value is too small?\n    p += normal * 0.002;\n    vec3 light_dir = light_pos - p;\n    float dist_to_light = length(light_dir);\n    //normalize light_dir:\n    light_dir /= dist_to_light;\n    \n    for(int iterations = 0; iterations < 40; iterations++) {\n        float d = map_composite_object(p);\n        distance_travelled += d;\n        if(distance_travelled > dist_to_light) {\n            return false;\n        }\n        if(d < 0.001) {\n            return true;\n        }\n        p += d * light_dir;\n    }\n    \n    // you could make an argument to go either way... true is probably better.\n    return true;\n}\n    \n// MAKE VERY SURE THAT to_viewpoint and normal ARE NORMALIZED (length == 1.0)\nvec3 lighting(in vec3 p, in vec3 to_viewpoint, in vec3 normal, in vec3 light_col, in vec3 light_pos, in vec3 surface_col) {\n    float shadow_test_count = 1.0;\n    vec3 lit_color = vec3(0.0);\n    \n    for(float shadow_test=1.0; shadow_test<=shadow_test_count; shadow_test++) {\n        vec3 area_light_pos = light_pos + rand_vec3(global_rand_state) * light_size;\n    \n        vec3 area_light_dir = normalize(area_light_pos - p);\n        float diffuse_brightness = dot(normal, area_light_dir);\n        if(diffuse_brightness > 0.0) {\n            if(!is_shadowed(p, normal, area_light_pos)) {\n                lit_color += diffuse_brightness * light_col * surface_col;\n                \n                vec3 reflection = 2.0 * normal * dot(normal, area_light_dir) - area_light_dir;\n                float cos_refl_viewpt = dot(reflection, to_viewpoint);\n                if(cos_refl_viewpt > 0.0) {\n                    lit_color += light_col * pow(cos_refl_viewpt, 100.0);\n                }\n            }\n        }\n    }\n    \n    return lit_color/shadow_test_count;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Making random numbers is hard AFF:\n    make_rand_state(fragCoord, iResolution, iFrame);\n    //fragColor.rgb = rand_vector(fragCoord);\n    //return;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // We want 0,0 to be the center of the screen, so rescale and recenter:\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // The pixels in the image now go from <-1.0, -1.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Rescale\n    // in the y direction to compensate:\n    uv.y /= (iResolution.x/iResolution.y);\n    \n    // Set up the camera:\n    float camera_distance_from_origin = 6.5;\n    float camera_time = 5.5;\n    vec3 camera_position = vec3(\n        sin(camera_time/2.0) * camera_distance_from_origin,\n        0.3,\n        cos(camera_time/2.0) * camera_distance_from_origin);\n        \n    vec3 camera_lookat_point = vec3(0.0, 0.0, 0.0);\n    \n    // Setting up the camera takes a bit of magic. The cross product of two vectors gives\n    // you a third vector at right angles to both of the input vectors. Our camera is at \n    // some arbitrary point in space, pointing at some other arbitrary point in space. To\n    // figure out which way is up and which way is right, we have to do some assuming. We\n    // want the camera to be level, so the right vector must be perpendicular to <0, 1, 0>\n    // AND the look direction, so let's start with that:\n    // !!!!NOTE!!!!\n    // This all goes to hell if your camera is directly above or below the lookat point,\n    // because the cross product of the look vector and <0, 1, 0> is undefined. Don't.\n    vec3 look_direction = normalize(camera_lookat_point - camera_position);\n    vec3 right = normalize(cross(look_direction, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, look_direction));\n    \n    // To get the direction a \"reverse photon\" travels from the eyepoint, we put the uv \n    // \"screen\" in front of the eyepoint and find the vector from the eyepoint through\n    // the pixel we're currently processing:\n    float eyepoint_to_screen_distance = 2.0;\n    vec3 pixel_location = camera_position + eyepoint_to_screen_distance * look_direction +\n        right * uv.x + up * uv.y;\n    vec3 ray_direction = normalize(pixel_location - camera_position);\n    \n    // 1) Start at the camera position.\n    // 2) Check to see how far current_position is from object(s).\n    // 3) Move along the camera->pixel direction by that distance.\n    // 4) goto 2, until you've either gone too far from objects to expect to ever hit them,\n    //    or, you're so close to one that we'll assume you've hit the object.\n    // 5) If you hit the compound object, find its normal and just use that as its color,\n    //    otherwise, you hit the ground plane and choose a color that paints the grid.\n    // 6) If you've iterated too many times, give up and return blinking green to draw\n    //    attention to the issue.\n    vec3 current_position = camera_position;\n\n    int obj_iterations;\n    float obj_dist;\n    float plane_dist;\n    bool obj_isect;\n    bool plane_isect;\n    vec3 obj_isect_point;\n    vec3 plane_isect_point;\n    \n    for(float reflection_count=0.0; reflection_count<10.0; reflection_count++) {\n        obj_isect = dist_to_composite_object(current_position, ray_direction, obj_dist, obj_iterations);\n        if(obj_isect) {\n            obj_isect_point = current_position + ray_direction * obj_dist;\n\n            vec3 normal = calc_normal(obj_isect_point);\n            \n            vec3 perlin_vect;\n            current_position = obj_isect_point + normal * 0.01;\n            float t = iTime * 3.0;\n            vec4 chaos_x = vec4(current_position*10.0, t);\n            perlin_vect.x = perlin(chaos_x);\n            vec4 chaos_y = vec4(current_position * 10.0 + vec3(298.837, 38729.83, 38729.8), t);\n            perlin_vect.y = perlin(chaos_y);\n            vec4 chaos_z = vec4(current_position.zxy * 10.0, t);\n            perlin_vect.z = perlin(chaos_z);\n      \n            normal += perlin_vect * 0.2;\n            normal = normalize(normal);\n            \n\n            ray_direction = reflect(ray_direction, normal);\n        } else {\n            plane_isect = dist_to_terrain(current_position, ray_direction, plane_dist);\n\n            if (plane_isect) {\n                plane_isect_point = current_position + ray_direction * plane_dist;\n\n                vec3 c = vec3(perlin(vec3(plane_isect_point.xz, iTime)))/2.0 + 0.5;\n                fragColor.rgb = lighting(plane_isect_point, -ray_direction, vec3(0.0, 1.0, 0.0), light_col, light_pos, c);\n                return;\n            }\n        }\n    }\n    fragColor = texture(iChannel0, ray_direction);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hard_union( float d0, float d1 ) {\n    return(min(d0, d1));\n}\n\nfloat hard_subtraction( float d0, float d1 ) {\n    return(max(d0, -d1));\n}\n\nfloat hard_intersection( float d0, float d1 ) {\n    return(max(d0, d1));\n}\n\nfloat smooth_union( float d0, float d1, float k ) {\n    float h = clamp( 0.5 + 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) - k*h*(1.0-h); }\n\nfloat smooth_subtraction( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0+d1)/k, 0.0, 1.0 );\n    return mix( d0, -d1, h ) + k*h*(1.0-h); }\n\nfloat smooth_intersection( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) + k*h*(1.0-h); }\n\n// TODO: \n// * more shapes!\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_x(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,   0.0,\n                0.0, s,   c,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_y(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,   0.0, -s,  0.0,\n                0.0, 1.0, 0.0, 0.0,\n                s,   0.0, c,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_z(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,   -s,  0.0, 0.0,\n                s,   c,   0.0,  0.0,\n                0.0, 0.0, 1.0,  0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point along the rotation axis,\n// this is a clockwise rotation (in our left-handed coordinate system.)\nmat4 rotation_arbitrary(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translate(vec4 delta) {\n    return mat4(1.0, 0.0, 0.0, delta.x,\n                0.0, 1.0, 0.0, delta.y,\n                0.0, 0.0, 1.0, delta.z,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// LOOK AT https://iquilezles.org/articles/distfunctions/ for the best SDF reference\n// anywhere.\n\n// The \"signed distance function\" for a box with rounded corners. \nfloat sdf_rounded_box( in vec3 p, in vec3 r, in float radius) {\n    return length(max(abs(p) - r, 0.0)) - radius;\n}\n\nfloat sdf_sphere( in vec3 p, in float radius) {\n    return length(p) - radius;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//TODO:\n// * Octaves of noise.\n\nfloat map(float m, float minin, float maxin, float minout, float maxout) {\n    float t = (m-minin)/maxin;\n    return minout + t*(maxout-minout);\n}\n\nvec2 map(float m, float minin, float maxin, vec2 minout, vec2 maxout) {\n    float t = (m-minin)/maxin;\n    return minout + t*(maxout-minout);\n}\n\nvec3 map(float m, float minin, float maxin, vec3 minout, vec3 maxout) {\n    float t = (m-minin)/maxin;\n    return minout + t*(maxout-minout);\n}\n\nvec4 map(float m, float minin, float maxin, vec4 minout, vec4 maxout) {\n    float t = (m-minin)/maxin;\n    return minout + t*(maxout-minout);\n}\n\nconst float PI = 3.14159265359;\nconst float _2PI = 3.14159265359 * 2.0;\n\n// Usually, you don't care about the order of random number delivery. In fact,\n// most of the time, you want it to be unpredictable. For any such consumption\n// of entropy, use the global seed. \n// HOWEVER! Sometimes you need absolute predictability. For example, when you\n// are generating vectors for a perlin noise generator, every (x,y,z,w) vertex\n// needs to generate the same vector. If you were to use the global seed for\n// this, you'd get different anchor vectors for each caller and the result would\n// be white noise and not perlin noise.\nuint global_rand_state;\n\n//Adapted from: https://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3\nuint hash(inout uint rand_state) {\n    rand_state ^= 2747636419u;\n    rand_state *= 2654435769u;\n    rand_state ^= rand_state >> 16;\n    rand_state *= 2654435769u;\n    rand_state ^= rand_state >> 16;\n    rand_state *= 2654435769u;\n    return rand_state;\n}\n\nuint make_rand_state(vec2 fragCoord, vec3 iResolution, int iFrame){\n    return\n        uint(fragCoord.y*iResolution.x + fragCoord.x) + \n        uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nuint make_rand_state(float entropy) {\n    return uint(entropy + entropy * 65536.0);\n}\n\nuint make_rand_state(ivec2 entropy) {\n    uint x = uint(entropy.x)^uint(12394723);\n    uint y = uint(entropy.y)^uint(29837472);\n    return hash(x) ^ hash(y);\n}\n\nuint make_rand_state(ivec3 entropy) {\n    uint x = uint(entropy.x)^uint(12394723);\n    uint y = uint(entropy.y)^uint(29837472);\n    uint z = uint(entropy.z)^uint(92974672);\n    return hash(x) ^ hash(y) ^ hash(z);\n}\n\nuint make_rand_state(ivec4 entropy) {\n    uint x = uint(entropy.x)^uint(12394723);\n    uint y = uint(entropy.y)^uint(29837472);\n    uint z = uint(entropy.z)^uint(92974672);\n    uint w = uint(entropy.w)^uint(73496335);\n    return hash(x) ^ hash(y) ^ hash(z) ^ hash(w);\n}\n\n\n// returns a float in the range [0.0..1.0]\nfloat rand_float(inout uint rand_state) {\n    return float(hash(rand_state)) / 4294967295.0; // 2^32-1\n}\n\n// returns a vector in the range <[-1.0..1.0], [-1.0..1.0]>\nvec2 rand_vec2(inout uint rand_state) {\n    return vec2(rand_float(rand_state)*2.0-1.0, rand_float(rand_state)*2.0-1.0);\n}\n\n// returns a uniformally-distributed random normalized vector (a random point on\n// the unit circle.)\nvec2 rand_norm_vec2(inout uint rand_state) {\n    float theta = rand_float(rand_state) * _2PI;\n    return vec2(cos(theta), sin(theta));\n}\n\n// returns a vector in the range <[-1.0..1.0], [-1.0..1.0], [-1.0..1.0]>\nvec3 rand_vec3(inout uint rand_state) {\n    return vec3(\n        rand_float(rand_state)*2.0-1.0, rand_float(rand_state)*2.0-1.0,\n        rand_float(rand_state)*2.0-1.0);\n}\n\n// returns a uniformally-distributed random normalized vector (a random point on\n// the unit sphere.)\nvec3 rand_norm_vec3(inout uint rand_state) {\n    float theta = _2PI * rand_float(rand_state);\n    float phi = acos(1.0 - 2.0*rand_float(rand_state));\n    return vec3(\n        sin(phi) * cos(theta),\n        sin(phi) * sin(theta),\n        cos(phi));\n}\n\n// returns a vector in the range <[-1.0..1.0], [-1.0..1.0], [-1.0..1.0], [-1.0..1.0]>\nvec4 rand_vec4(inout uint rand_state) {\n    return vec4(\n        rand_float(rand_state)*2.0-1.0, rand_float(rand_state)*2.0-1.0, \n        rand_float(rand_state)*2.0-1.0, rand_float(rand_state)*2.0-1.0);\n}\n\nfloat noise(float seed) {\n    uint rand_state = uint(seed + seed*65536.0);\n    return rand_float(rand_state);\n}\n\nvec2 noise(ivec2 seed) {\n    uint rand_state = make_rand_state(seed);\n    return rand_vec2(rand_state);\n}\n\nvec3 noise(ivec3 seed) {\n    uint rand_state = make_rand_state(seed);\n    return rand_vec3(rand_state);\n}\n\nvec4 noise(ivec4 seed) {\n    uint rand_state = make_rand_state(seed);\n    return rand_vec4(rand_state);\n}\n\n// a perlin function with a 2D domain and 1D range.\n// THE RANGE IS [-1.0..1.0], not [0.0..1.0] as you might expect. THIS IS TO BE\n// CONSISTENT WITH OTHER PERLIN FUNCTIONS THAT RETURN VECTORS IN THE -1..1 RANGE.\nfloat perlin(vec2 p) {\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n    vec2 u;\n    if(false) { // faster, but poorer definition\n        u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    } else {\n        vec2 f3 = f*f*f;\n        vec2 f4 = f3*f;\n        vec2 f5 = f4*f;\n        u = 6.0*f5 - 15.0*f4 + 10.0*f3;\n    }\n\n    return mix( mix( dot( noise( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( noise( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( noise( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( noise( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// a perlin function with a 3D domain and 1D range.\n// THE RANGE IS [-1.0..1.0], not [0.0..1.0] as you might expect. THIS IS TO BE\n// CONSISTENT WITH OTHER PERLIN FUNCTIONS THAT RETURN VECTORS IN THE -1..1 RANGE.\nfloat perlin(vec3 p) {\n    ivec3 i = ivec3(floor( p ));\n     vec3 f =       fract( p );\n\t\n    vec3 u;\n    if(false) { // faster, but poorer definition\n        u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    } else {\n        vec3 f3 = f*f*f;\n        vec3 f4 = f3*f;\n        vec3 f5 = f4*f;\n        u = 6.0*f5 - 15.0*f4 + 10.0*f3;\n    }\n\n    return \n        mix( mix( mix( dot( noise( i+ivec3(0,0,0) ), f-vec3(0.0,0.0,0.0) ), \n                       dot( noise( i+ivec3(1,0,0) ), f-vec3(1.0,0.0,0.0) ), u.x),\n                  mix( dot( noise( i+ivec3(0,1,0) ), f-vec3(0.0,1.0,0.0) ), \n                       dot( noise( i+ivec3(1,1,0) ), f-vec3(1.0,1.0,0.0) ), u.x), u.y),\n             mix( mix( dot( noise( i+ivec3(0,0,1) ), f-vec3(0.0,0.0,1.0) ), \n                       dot( noise( i+ivec3(1,0,1) ), f-vec3(1.0,0.0,1.0) ), u.x),\n                  mix( dot( noise( i+ivec3(0,1,1) ), f-vec3(0.0,1.0,1.0) ), \n                       dot( noise( i+ivec3(1,1,1) ), f-vec3(1.0,1.0,1.0) ), u.x), u.y), u.z);\n}\n\n// a perlin function with a 4D domain and 1D range.\n// THE RANGE IS [-1.0..1.0], not [0.0..1.0] as you might expect. THIS IS TO BE\n// CONSISTENT WITH OTHER PERLIN FUNCTIONS THAT RETURN VECTORS IN THE -1..1 RANGE.\nfloat perlin(vec4 p) {\n    ivec4 i = ivec4(floor( p ));\n     vec4 f =       fract( p );\n\t\n    vec4 u;\n    if(false) { // faster, but poorer definition\n        u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    } else {\n        vec4 f3 = f*f*f;\n        vec4 f4 = f3*f;\n        vec4 f5 = f4*f;\n        u = 6.0*f5 - 15.0*f4 + 10.0*f3;\n    }\n\n    return \n        mix(\n            mix( mix( mix( dot( noise( i+ivec4(0,0,0,0) ), f-vec4(0.0,0.0,0.0,0.0) ), \n                           dot( noise( i+ivec4(1,0,0,0) ), f-vec4(1.0,0.0,0.0,0.0) ), u.x),\n                      mix( dot( noise( i+ivec4(0,1,0,0) ), f-vec4(0.0,1.0,0.0,0.0) ), \n                           dot( noise( i+ivec4(1,1,0,0) ), f-vec4(1.0,1.0,0.0,0.0) ), u.x), u.y),\n                 mix( mix( dot( noise( i+ivec4(0,0,1,0) ), f-vec4(0.0,0.0,1.0,0.0) ), \n                           dot( noise( i+ivec4(1,0,1,0) ), f-vec4(1.0,0.0,1.0,0.0) ), u.x),\n                      mix( dot( noise( i+ivec4(0,1,1,0) ), f-vec4(0.0,1.0,1.0,0.0) ), \n                           dot( noise( i+ivec4(1,1,1,0) ), f-vec4(1.0,1.0,1.0,0.0) ), u.x), u.y), u.z),\n            mix( mix( mix( dot( noise( i+ivec4(0,0,0,1) ), f-vec4(0.0,0.0,0.0,1.0) ), \n                           dot( noise( i+ivec4(1,0,0,1) ), f-vec4(1.0,0.0,0.0,1.0) ), u.x),\n                      mix( dot( noise( i+ivec4(0,1,0,1) ), f-vec4(0.0,1.0,0.0,1.0) ), \n                           dot( noise( i+ivec4(1,1,0,1) ), f-vec4(1.0,1.0,0.0,1.0) ), u.x), u.y),\n                 mix( mix( dot( noise( i+ivec4(0,0,1,1) ), f-vec4(0.0,0.0,1.0,1.0) ), \n                           dot( noise( i+ivec4(1,0,1,1) ), f-vec4(1.0,0.0,1.0,1.0) ), u.x),\n                      mix( dot( noise( i+ivec4(0,1,1,1) ), f-vec4(0.0,1.0,1.0,1.0) ), \n                           dot( noise( i+ivec4(1,1,1,1) ), f-vec4(1.0,1.0,1.0,1.0) ), u.x), u.y), u.z), u.w);\n}\n\nfloat perlin_harmonics(vec2 p, int octaves) {\n    float scale = 1.0;\n    float retval = 0.0;\n    \n    while(octaves > 0) {\n        retval += perlin((scale+p)*scale)/scale;\n        scale *= 1.83;\n        octaves--;\n    }\n    return retval;\n}\n\nfloat perlin_harmonics(vec3 p, int octaves) {\n    float scale = 1.0;\n    float retval = 0.0;\n    \n    while(octaves > 0) {\n        retval += perlin((scale+p)*scale)/scale;\n        scale *= 1.83;\n        octaves--;\n    }\n    return retval;\n}","name":"Common","description":"","type":"common"}]}