{"ver":"0.1","info":{"id":"WdcGzn","date":"1567656106","viewed":198,"name":"Mondrian Grid","username":"gressettd","description":"Clarifying \"Art by the Numbers\" and how it works. Also worked the pattern to provide cell id and coords so we might start using it to tile / bomb whatever.\nFeel free to comment if you have insights to add into the code.\n\nRef https://www.shadertoy.com","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// adaptation of https://www.shadertoy.com/view/4ljGzc\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\nfloat Random3D(vec3 p)\n{\n\tvec3 comparator = vec3(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y),\n\t\t12.987 * Random1D(p.z));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude + 0.001);\n\treturn random;\n}\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\nvec2 RandomVector2(float p) \n{\n    vec3 p3 = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n    return fract(vec2(p3.x * p3.y, p3.z * p3.x));\n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n\nvec3 ComputeMondrian(vec2 pos, int iterations, float seed, float aspect, out vec2 extents)    \n{\n    \n      \n    // start with a cell covering the entire rendering area\n    vec2 cellMin = vec2(0.0,0.0);\n    vec2 cellMax = vec2(1.0,aspect);\n    \n    // initial cell ID\n    float cellID = seed;\n    \n    // create a random vector from the seed / cell id.\n    // used to bias splits toward \n    // a similar split shapes\n    vec2 imageDetailBias = vec2(\n        0.1 + // no zeros\n        0.5 * // scaled down, we want smaller values for the later pow()\n        \tRandom1D(cellID + 0.9)); // random vector [0..1,0..1]\n    \n    // sub divide the area and find which cell we're inside\n    // in the end\n    for (int i = 0; i < 5; ++i) \n    {\n        vec2 cellSize = cellMax - cellMin; // this is the drawing area to split.\n        \n        // split the parent area into two parts,\n        // then focus on the child part next iteration\n        \n        \n        vec2 splitSize = \n            floor( // favors splitting parent on one axis \n            2.0 *  \n            pow(cellSize, imageDetailBias) * // current cell shape, lifted by bias\n            RandomVector2(cellID) // direction vector [0..1] \n        \t);\n        \n        vec2 splitDir = \n            // gen direction, create a positive quadrant vector\n            vec2(0.2,0.2) + // non-zero, minimum 0.2\n            (0.6 * RandomVector2(cellID + 0.1)); // random vector\n        \n        vec2 splitter = splitSize * splitDir;\n        \n        // where does the split occur\n        vec2 splitCross = \n            cellMin + // start at parent upper left\n            \t(splitter * cellSize); // divide current cell size\n        \n        // subdivide the cell into quadrants along the division line,\n        // find out which quadrant the current px position is in:\n        /*\n\t\t\t\t|\n\t\t\t0,1\t|  1,1\n\t\t\t\t|\n\t\t-------------------\n\t\t\t0,0\t|  1,0\n\t\t\t\t|\n\t\t\t\t|\n\t\t*/\n        vec2 child = step(splitCross, pos);\n        \n        // compute child cell that position is in, and extents from parent extents;\n        // based on the quadrant the position is in\n        \n        // choose between dividing line (x,y) or parent cell min (x,y) based on position quadrant\n        cellMin = mix(cellMin, splitCross, child); \n        // choose between dividing line (x,y) or parent cell max (x,y) based on position quadrant\n        cellMax = mix(splitCross, cellMax, child);\n        \n        // create a cellID for the child for next iteration\n        cellID = Random3D(vec3(cellID, child.x, child.y));\n        \n    }\n    \n    // now we've computed the cell id and extents of\n    // the most nested child cell that the position is in.\n    // provide out the info\n    \n    vec2 ccRange = cellMax - cellMin;\n    vec2 ccPos = (pos - cellMin) / ccRange;\n    extents = ccRange;\n    return vec3(cellID, ccPos.x, ccPos.y);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 pos = fragCoord.xy / iResolution.x;\n   \tfloat aspect = iResolution.y / iResolution.x;\n    \n    const float duration = 4.2;\n    float seed = floor(iTime / duration);\n\tvec2 ext;\n    vec3 cc = ComputeMondrian(pos, 5, seed, aspect, ext);\n    \n    vec4 bias = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 scale = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 freq = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 phase = vec4(0.0, 0.3333, 0.6666, 1.0);\n    vec3 idCol = ComputeWaveGradientRGB(cc.x,bias,scale,freq,phase).xyz;\n    float intensity = (cc.y+cc.z) * 0.5;\n    \n    vec3 color = intensity * idCol;\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}