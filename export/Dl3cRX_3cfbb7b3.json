{"ver":"0.1","info":{"id":"Dl3cRX","date":"1699469258","viewed":99,"name":"Grass using domain repetition","username":"FrederickAmpsUp","description":"mmm grass\ncould use some optimization","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"ml3czj","parentname":"messing with ray marching"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\n// Data structures\n\nstruct MarchParams {\n    int steps;\n    float surf,miss;\n};\n\nstruct Ray {\n    vec3 o,d;\n};\nvec3 at(Ray r, float t) { return r.o+r.d*t; }\n\nstruct Interval {\n    float start,end;\n};\n\nstruct Material {\n    vec3 col;\n};\n\n// Signed distance functions / ray-marching utils\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(p-c)-r;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 translate(in vec3 p, in vec3 t) {\n    return p-t;\n}\nvec3 repeatX(in vec3 p, in float size) {\n    return vec3(p.x - size*round(p.x/size), p.yz);\n}\nvec3 repeatY(in vec3 p, in float size) {\n    return vec3(p.x, p.y - size*round(p.y/size), p.z);\n}\nvec3 repeatZ(in vec3 p, in float size) {\n    return vec3(p.xy, p.z- size*round(p.z/size));\n}\n\nvec3 rotateY(in vec3 p, in float angleRads) {\n    float angle = atan(p.z, p.x) + angleRads;\n    float dist = sqrt(p.x*p.x+p.z*p.z);\n    return vec3(cos(angle)*dist, p.y, sin(angle)*dist);\n}\n\nfloat smin(float a, float b, float k) {\n    return 0.5 * ((a + b) - sqrt((a-b)*(a-b)+k));\n}\n\nfloat time;\n\n// RNG stuff\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat lerp(float a, float b, float k) { return mix(a,b,k); }\n\nfloat noise( vec3 x ) {\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),\n        lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),\n        lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// Scene SDF\nfloat map(in vec3 p, out Material mat) {\n    mat.col = vec3(0.0, 1.0, 0.0);\n    float ground_plane = p.y + 1.0;\n    \n    float dist = ground_plane;\n    float sphere = sdSphere(p, vec3(0, 0.9, 0), 1.0);\n    if (p.y > 0.2) {\n        dist = p.y;\n        if (sphere < dist) {\n            mat.col = vec3(1.0);\n            dist = sphere;\n        }\n        return dist;\n    }\n    float grass0 = sdBox(repeatX(repeatZ(p, 0.1), 0.1), vec3(0.0025, 0.05*noise(p)+0.01, 0.0025));\n    float grass1 = sdBox(repeatX(repeatZ(rotateY(p, 0.3), 0.05), 0.05), vec3(0.0025, 0.1*noise(p)+0.01, 0.0025));\n    float grass2 = sdBox(repeatX(repeatZ(rotateY(p, 0.6), 0.05), 0.1), vec3(0.0025, 0.1*noise(p)+0.01, 0.0025));\n    float grass3 = sdBox(repeatX(repeatZ(rotateY(p, 0.9), 0.1), 0.05), vec3(0.0025, 0.05*noise(p)+0.01, 0.0025));\n    float grass4 = sdBox(repeatX(repeatZ(rotateY(p, 1.2), 0.05), 0.05), vec3(0.0025, 0.1*noise(p)+0.01, 0.0025));\n    float grass5 = sdBox(repeatX(repeatZ(rotateY(p, 1.5), 0.1), 0.1), vec3(0.0025, 0.05*noise(p)+0.01, 0.0025));\n    float grass6 = sdBox(repeatX(repeatZ(rotateY(p, 1.8), 0.05), 0.0), vec3(0.0025, 0.05*noise(p)+0.01, 0.0025));\n    float grass7 = sdBox(repeatX(repeatZ(rotateY(p, 2.1), 0.1), 0.05), vec3(0.0025, 0.1*noise(p)+0.01, 0.0025));\n    float grass8 = sdBox(repeatX(repeatZ(rotateY(p, 2.4), 0.05), 0.1), vec3(0.0025, 0.05*noise(p)+0.01, 0.0025));\n    float grass9 = sdBox(repeatX(repeatZ(rotateY(p, 2.7), 0.05), 0.05), vec3(0.0025, 0.1*noise(p)+0.01, 0.0025));\n    \n    // grass :)\n    float grass = min(min(min(min(min(min(min(min(min(grass0, grass1), grass2), grass3), grass4), grass5), grass6), grass7), grass8), grass9) - .003;\n    float ground = min(ground_plane, grass);\n    //float ground = ground_plane;\n    dist = ground;\n    if (sphere < dist) {\n        mat.col = vec3(1.0);\n        dist = sphere;\n    }\n    \n    return dist;\n}\n\n// Marching function\nfloat march(in MarchParams p, in Ray r, in Interval i, out Material mat) {\n    vec3 pos;\n    float t = i.start;\n    for (int stp = 0; stp < p.steps; ++stp) {\n        pos = at(r,t);\n        float scene = map(pos, mat);\n        \n        if (scene < p.surf || scene > p.miss || t > i.end) return t;\n        t += scene;\n    }\n    \n    return t;\n}\n\n// Soft shadows\nfloat shadow(in MarchParams p, in Ray r, in Interval i, in float lightSize) {\n    float res = 1.0;\n    float t = i.start;\n    float maxt = i.end; // field selectors don't work in for loops ig\n    for( int i=0; i<p.steps && t<maxt; i++ ) {\n        Material _col;\n        float h = map(at(r,t), _col);\n        res = min( res, h/(lightSize*t) );\n        t += clamp(h, 0.005, 0.50);\n        if(res<-1.0) break;\n    }\n    res = max(res,-1.0);\n    if (res != res) return 1.0;\n    float final = 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    return final;\n}\n\n// Ambient occlusion\nfloat ambientOcc(vec3 point, vec3 normal, float step_dist, float step_nbr)\n{\n    float occlusion = 1.0f;\n    while(step_nbr > 0.0) {\n        Material _mat;\n        occlusion -= pow(step_nbr * step_dist - (map( point + normal * step_nbr * step_dist, _mat)),2.0) / step_nbr;\n        step_nbr--;\n    }\n\n    return occlusion;\n}\n\n// Get a normal\nvec3 normal(in vec3 pos) {\n    float epsilon = 0.0001;\n    Material _col;\n    return normalize(\n        vec3(\n            map(pos + vec3(epsilon, 0, 0), _col) - map(pos - vec3(epsilon, 0, 0), _col),\n            map(pos + vec3(0, epsilon, 0), _col) - map(pos - vec3(0, epsilon, 0), _col),\n            map(pos + vec3(0, 0, epsilon), _col) - map(pos - vec3(0, 0, epsilon), _col)\n        )\n    );\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LIGHT_POS vec3(100000, 100000, -100000)\n#define LIGHT_COL vec3(1.0)\n\n#define SKY (vec3(135, 206, 235) / 255.)\n#define AMBIENT (.2*SKY)\n\n\n// Different maps. Uncommenting these will show different components of the final render.\n//#define AO_MAP\n//#define SHADOW_MAP\n//#define LIGHT_MAP\n//#define COLOR_MAP\n//#define NORMAL_MAP\n//#define POS_MAP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime; // get time in common without errors\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    vec2 jitter = vec2(1,1)/iResolution.xy;\n    \n    vec3 rayDir = normalize(rotateY(vec3(uv, 1.0), iTime/5.0));\n    MarchParams p = MarchParams(min(iFrame,0)+256, 0.0001, 1000.0);\n    Ray r = Ray(vec3(0.0, 1.0, -5.0), rayDir);\n    Material mat;\n    \n    float dist = march(p, r,\n        Interval(0.0, 1000.0), mat);\n        \n    bool hit = dist < p.miss;\n    if (!hit) {\n        fragColor = vec4(SKY, 1.0);\n        return;\n    }\n    \n    vec3 hitPos = at(r, dist);\n    vec3 hitNorm = normal(hitPos);\n    \n    vec3 col = AMBIENT * mat.col;\n    \n    vec3 dirToLight = normalize(LIGHT_POS - hitPos);\n    \n    float lighting = max(dot(hitNorm, dirToLight), 0.0);\n    float shadows  = shadow(p, Ray(hitPos, dirToLight), Interval(p.surf, 1000.0), 0.3);\n    col += LIGHT_COL * mat.col * max(lighting * shadows, 0.2);\n    float ao = max(pow(ambientOcc(hitPos, hitNorm, .006, 20.0), 40.0), 0.1);\n    col *= max(ao, 0.5);\n\n    fragColor = vec4(col, 1.0);\n    \n    // gamma correction\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n    \n#ifdef AO_MAP\n    fragColor = vec4(ao);\n#endif\n\n#ifdef SHADOW_MAP\n    fragColor = vec4(shadows);\n#endif\n\n#ifdef LIGHT_MAP\n    fragColor = vec4(lighting);\n#endif\n\n#ifdef COLOR_MAP\n    fragColor = vec4(mat.col, 1.0);\n#endif\n\n#ifdef NORMAL_MAP\n    fragColor = vec4(hitNorm, 1.0);\n#endif\n\n#ifdef POS_MAP\n    fragColor = vec4(hitPos, 1.0);\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}