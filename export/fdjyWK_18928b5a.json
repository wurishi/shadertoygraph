{"ver":"0.1","info":{"id":"fdjyWK","date":"1644105335","viewed":408,"name":"hypersapience","username":"stb","description":"Just playing with with circle inversions.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","circle","psychedelic","complex","conformal","inversion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n#define rotate(p, a) vec2(p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a))\n\nvec2 c_inv(vec2 p, vec2 o, float r) {\n    return (p-o) * r * r / dot(p-o, p-o) + o;\n}\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat grid(in vec2 p){ p = abs(fract(p+.5)-.5); return 2. * min(p.x, p.y); }\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n\tvec2 p = (fc-res/2.) / res.y;\n\tvec2 m = (iMouse.xy-res/2.) / res.y;\n\tfloat f;\n    \n\t// zoom\n    p *= 1.3;\n    \n    float T = .35*iTime;\n    \n    // building face shape from summed-up circle inversions\n    vec2 p_grp1, p_grp2 = vec2(0.);\n    float I = 19.;\n    for(float i=0.; i<I; i++)\n        p_grp1 += c_inv(p, vec2(.35*(i-I/2.+.5)/I, -.4+.02*cos(4.*i/(I+1.)-PI/2.)), 4.*(.125+pow(i/I-.5, 2.)));\n    I = 14.;\n    for(float i=0.; i<I; i++)\n        p_grp2 += c_inv(p, vec2(.15*(i-I/2.+.5)/I, -.45-.01*cos(4.*i/(I)-PI/2.)), .75);\n    \n    // everything is added together in a single statement\n    p =\n        (\n            // eyes\n            + c_inv(p, vec2(-.3, .2), 4.)\n            + c_inv(p, vec2(.3, .2), 4.)\n            \n            //nose\n            - c_inv(p, vec2(-.065, -.17), 1.7)\n            - c_inv(p, vec2(.065, -.17), 1.7)\n            \n            // upper lip\n            + p_grp1/2.\n            \n            // lower lip\n            + p_grp2\n        ) / 17.;\n    \n    // saving coords for later\n    vec2 p2 = p;\n    \n    // translate grid\n    p += (.5*T) * vec2(.13, 1.);\n    \n    // fractalize\n    vec2 p3 = p;\n    if(true) {\n        for(float i=0.; i<14.; i++) {\n            p3 += i * vec2(.215, .12);\n            p3 = rotate(p3, 1.+1.4*I+.1*sin(.05*T-.1));\n            p3 = abs(mod(p3, 40.)-20.);\n        }\n    }\n    \n    // apply grid\n\tf = grid(p3);\n    \n    //trying make lines an even thickness (produces pixelization artifacts)\n    float wd = length(vec2(dFdx(p.x), dFdx(p.y)));\n    f /= wd * .015 * res.x;\n    \n    f = min(1., f+.73);\n    \n    // apply random cells\n    f += .07 * (.5 - hash12(floor(p3)));\n    \n    vec3 RGB = vec3(f);\n    \n    // faux lighting\n    f += 1.5*(.014 * length(p2+15.) - .85);\n    //f += 1.5*(.014 * length(p2+30.*m) - .85);\n    \n    RGB += mix(vec3(.03, .3, .4), 2.9*vec3(1., .6, .2), f)-.7;    \n    \n\tfo = vec4(RGB, 1.);\n}\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}