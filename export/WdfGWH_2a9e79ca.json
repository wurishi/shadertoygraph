{"ver":"0.1","info":{"id":"WdfGWH","date":"1546173928","viewed":304,"name":"Puffin Pipes","username":"nr4","description":"Tunnel scene with some stars in the background.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","acid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Puffin Pipes\n * From \"Puffin Cure\" by Team210 - 64k Demo at Under Construction 2018\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Speed optimizations\n\n// Global constants\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Global variables\nvec3 col = c.yyy;\n\n// Hash function\nfloat rand(vec2 x)\n{\n    return fract(sin(dot(x-1. ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n/* Simplex noise -\nCopyright (C) 2011 by Ashima Arts (Simplex noise)\nCopyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\nvec3 taylorInvSqrt(vec3 r) \n{     \n    return 1.79284291400159-0.85373472095314*r; \n}\n\nvec3 permute(vec3 x)\n{\n    return mod((x*34.+1.)*x, 289.);\n}\n\nfloat snoise(vec2 P) \n{     \n    const vec2 C = vec2 (0.211324865405187134, 0.366025403784438597);  \n    vec2 i = floor(P+dot(P, C.yy)) ; \n    vec2 x0 = P-i+dot(i, C.xx) ; \n    // Other  corners \n    vec2 i1 ; \n    i1.x = step ( x0.y , x0.x ) ;  //  1.0  i f  x0 . x > x0 . y ,  e l s e  0.0 \n    i1.y = 1.0 - i1.x ; \n    // x1 = x0 − i1 + 1.0 ∗ C. xx ;  x2 = x0 − 1.0 + 2.0 ∗ C. xx ; \n    vec4 x12 = x0.xyxy + vec4 ( C.xx , C.xx * 2.0 - 1.0) ; \n    x12.xy -= i1 ; \n    //  Permutations \n    i = mod( i ,  289.0) ;  // Avoid  truncation  in  polynomial  evaluation \n    vec3 p = permute ( permute ( i.y + vec3 (0.0 , i1.y ,  1.0  ) ) + i.x + vec3 (0.0 , i1.x ,  1.0  ) ) ; \n    //  Circularly  symmetric  blending  kernel\n    vec3 m = max(0.5 - vec3 ( dot ( x0 , x0 ) ,  dot ( x12.xy , x12.xy ) , dot ( x12.zw , x12.zw ) ) ,  0.0) ; \n    m = m * m ; \n    m = m * m ; \n    //  Gradients  from 41  points  on a  line ,  mapped onto a diamond \n    vec3 x = fract ( p * (1.0  /  41.0) ) * 2.0 - 1.0  ; \n    vec3 gy = abs ( x ) - 0.5  ; \n    vec3 ox = floor ( x + 0.5) ;  // round (x)  i s  a GLSL 1.30  feature \n    vec3 gx = x - ox ; //  Normalise  gradients  i m p l i c i t l y  by  s c a l i n g m \n    m *= taylorInvSqrt ( gx * gx + gy * gy ) ; // Compute  f i n a l  noise  value  at P \n    vec3 g ; \n    g.x = gx.x * x0.x + gy.x * x0.y ; \n    g.yz = gx.yz * x12.xz + gy.yz * x12.yw ; \n    //  Scale  output  to  span  range  [ − 1 ,1] \n    //  ( s c a l i n g  f a c t o r  determined by  experiments ) \n    return  -1.+2.*(130.0 * dot ( m , g ) ) ; \n}\n/* End of Simplex Noise */\n\n// Multi-frequency simplex noise\nfloat mfsnoise(vec2 x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.2;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*snoise(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\n// 3D rotational matrix\nmat3 rot(vec3 p)\n{\n    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\n// add object to scene\nvec2 add(vec2 sda, vec2 sdb)\n{\n    return mix(sda, sdb, step(sdb.x, sda.x));\n}\n\n// Distance to line segment\nfloat lineseg(vec2 x, vec2 p1, vec2 p2)\n{\n    vec2 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\nfloat lineseg(vec3 x, vec3 p1, vec3 p2)\n{\n    vec3 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\n// Distance to circle\nfloat circle(vec2 x, float r)\n{\n    return length(x)-r;\n}\n\n// Distance to circle segment\nfloat circlesegment(vec2 x, float r, float p0, float p1)\n{\n    float p = atan(x.y, x.x);\n    p = clamp(p, p0, p1);\n    return length(x-r*vec2(cos(p), sin(p)));\n}\n\n// Distance to 210 logo\nfloat logo(vec2 x, float r)\n{\n    return min(\n        min(circle(x+r*c.zy, r), lineseg(x,r*c.yz, r*c.yx)),\n        circlesegment(x+r*c.xy, r, -.5*pi, .5*pi)\n    );\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\nvec2 scene(vec3 x)\n{\n    vec2 sdf = c.xy;\n    \n    x -= c.yyx*iTime;\n    \n    vec3 dv = 2.e-2*vec3(snoise(c.xx*(x.z-iTime)),\n                      snoise(c.xx*(x.z-iTime)+13.),\n                      snoise(c.xx*(x.z-iTime)-22.)\n                      );\n    x += dv;\n    x *= rot(c.yyx*iTime);\n    \n    float dz = .5;\n    vec3 z = vec3(x.xy, mod(x.z, dz)-.5*dz);\n    \n    float r = length(x.xy),\n        ddr = .1,\n        dr = mod(r, ddr)-.5*ddr,\n        p = atan(x.y,x.x),\n        ddp = pi/(8.+round(24.*rand(floor(2.*iTime)*c.xx))),\n        dp = mod(p, 2.*ddp)-ddp,\n        r0 = .3;\n    \n    vec3 y = vec3(r0*cos(p-dp), r0*sin(p-dp), 0.);\n    sdf = vec2(length(z-y)-.05, 1.+3.*round(rand(vec2(p-dp,x.z-z.z))));\n    \n    sdf = add(sdf, vec2(stroke(lineseg(z, vec3(r0*cos(p-dp-ddp), r0*sin(p-dp-ddp), 0.), vec3(r0*cos(p-dp+ddp), r0*sin(p-dp+ddp), 0.)), .03),1.));\n\tsdf = add(sdf, vec2(stroke(lineseg(vec3(z.xy,abs(z.z)), y, y+dz*c.yyx), .03), 1.+3.*round(rand(vec2(p-dp+17.)))));\n    \n    sdf.x -= length(dv)-.03;\n\n    return sdf;\n}\n\n//performs raymarching\n//scene: name of the scene function\n//xc: \t name of the coordinate variable\n//ro:\t name of the ray origin variable\n//d:\t name of the distance variable\n//dir:\t name of the direction variable\n//s:\t name of the scenestruct variable\n//N:\t number of iterations used\n//eps:\t exit criterion\n//flag:  name of the flag to set if raymarching succeeded\n#define raymarch(scene, xc, ro, d, dir, s, N, eps, flag) \\\n\tflag = false;\\\n\tfor(int i=0; i<N; ++i)\\\n    {\\\n        xc = ro + d*dir;\\\n        s = scene(xc);\\\n        if(s.x < eps)\\\n        {\\\n            flag = true;\\\n            break;\\\n        }\\\n        d += s.x;\\\n    }\n\n//computes normal with finite differences\n//scene: name of the scene function\n//n:\t name of the normal variable\n//eps:\t precision of the computation\n//xc:\t location of normal evaluation\n#define calcnormal(scene, n, eps, xc) \\\n\t{\\\n        float ss = scene(xc).x;\\\n        n = normalize(vec3(scene(xc+eps*c.xyy).xc-ss,\\\n                           scene(xc+eps*c.yxy).xc-ss,\\\n                           scene(xc+eps*c.yyx).xc-ss));\\\n    }\n\n//camera setup\n//camera: camera function with camera(out vec3 ro, out vec3 r, out vec3 u, out vec3 t)\n//ro:\t  name of the ray origin variable\n//r:\t  name of the right variable\n//u:\t  name of the up variable\n//t:\t  name of the target variable\n//uv:\t  fragment coordinate\n//dir:\t  name of the dir variable\n#define camerasetup(camera, ro, r, u, t, uv, dir) \\\n\t{\\\n        camera(ro, r, u, t);\\\n        t += uv.x*r+uv.y*u;\\\n        dir = normalize(t-ro);\\\n    }\n\n//post processing: 210 logo and trendy display lines\n//col: output color\n//uv:  fragment coordinate\n#define post(color, uv) \\\n\t{\\\n    \tcol = mix(clamp(col,c.yyy,c.xxx), c.xxx, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, stroke(logo(uv-vec2(-.45,.45),.02),.005)));\\\n    \tcol += vec3(0., 0.05, 0.1)*sin(uv.y*1050.+ 5.*iTime);\\\n\t}\n\t\n//camera for scene 1\nvoid camera1(out vec3 ro, out vec3 r, out vec3 u, out vec3 t)\n{\n    ro = c.yyx;\n    r = c.xyy;\n    u = c.yxy;\n    t = c.yyy;\n}\n\n// Standard shadertoy color\nvec3 stdcolor(vec2 x)\n{\n\treturn 0.5 + 0.5*cos(iTime+x.xyx+vec3(0,2,4));\n}\n\n// Select material color\nvec3 color(float rev, float ln, float index, vec2 uv, vec3 x)\n{\n    vec3 col = c.yyy;\n    if(index == 1.)\n    {\n        x *= 1.e-2;\n   \t\tvec3 c1 = stdcolor(1.5e2*x.z+x.xy+.5*rand(17.*c.xx)), \n        \tc2 = stdcolor(1.5e2*x.z+x.xy+x.yz+x.zx+.5*rand(12.*c.xx)+11.+uv), \n            c3 = stdcolor(1.5e2*x.z+x.xy+x.yz+x.zx+.5*rand(15.*c.xx)+23.+uv);\n\t\tcol = .1*c1*vec3(1.,1.,1.) + .2*c1*vec3(1.,1.,1.)*ln + 1.5*vec3(1.,1.,1.)*pow(rev,2.*(2.)) + 2.*c1*pow(rev, 8.)+3.*c1*pow(rev, 16.);\n        col = clamp(.23*col, 0., 1.);\n\t}\n    else if(index == 4.)\n    {\n        x *= 1.e-2;\n   \t\tvec3 c1 = 1.*stdcolor(1.5e2*x.z+x.xy+.5*rand(47.*c.xx)/*+iNBeats*/+14.), \n        \tc2 = 1.*stdcolor(1.5e2*x.z+x.xy+x.yz+x.zx+.5*rand(12.*c.xx)/*+iNBeats*/+21.+uv), \n            c3 = 1.*stdcolor(1.5e2*x.z+x.xy+x.yz+x.zx+.5*rand(15.*c.xx)/*+iNBeats*/+33.+uv);\n\t\tcol = .1*c1*vec3(1.,1.,1.) + .2*c1*vec3(1.,1.,1.)*ln + 1.5*vec3(1.,1.,1.)*pow(rev,4.) + 2.*c1*pow(rev, 8.)+3.*c1*pow(rev, 16.);\n        col = clamp(.23*col, 0., 1.);\n\t}\n    return col;\n}\n\nfloat star(vec2 x, float r0)\n{\n    return 1.-smoothstep(.5*r0, r0, length(x));\n}\n\n// Background 1 (Moon)\nvec3 background1(vec2 x)\n{\n    //Stars\n    float dr = .03, scale;\n    vec2 y = mod(x, dr)-.5*dr;\n    float rs = rand(x-y)*.005,\n        dx = -.5*(dr-rs)+(dr-2.*rs)*rand(x-y+1.),\n        dy = -.5*(dr-rs)+(dr-2.*rs)*rand(x-y+2.);\n    scale = star(y-vec2(dx,dy), rs);\n    vec3 color = scale*clamp(8.*rand(x.xy+4.)*stdcolor(rand(x-y+3.)*x.xy), 0., 1.); \n    \n    // Star nebula\n    float f = mfsnoise(x.xy-6.93, 2.e-1, 1.e2, .55);\n    color += mix(c.yyy, stdcolor(x), .5+.95*f);\n    color += mix(c.yyy, 2.*stdcolor(x+4.), .5+.33*f);\n    color += mix(c.yyy, stdcolor(x+8.), .5+.79*f);\n    \n    return clamp(color, 0., 1.);\n}\n\n// Background for the unc logo\nvec3 background2(vec2 x)\n{\n    vec3 bg = c.yyy;\n    float p = atan(x.y,x.x)/iTime,\n        n = 5.,\n        dmax = .3+.1*snoise(iTime*c.xx);\n    for(float i = 0.; i<n; i+=1.)\n    {\n        float d = i/n*dmax;\n        bg += background1((length(x)-.05+d-2.*iTime)*vec2(cos(p), sin(p))-.05*vec2(snoise(x.xy-iTime), snoise(x.xy+iTime)));\n    }\n    bg /= n;\n    return bg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    \n\t// Perform raymarching\n    vec3 ro, r, u, t, x, dir;\n    vec2 s;\n    camerasetup(camera1, ro, r, u, t, uv, dir);\n    \t\n    float d = .2/length(dir.xy);\n    {\n    \tbool hit;\n            \n        raymarch(scene, x, ro, d, dir, s, 150, 1.e-4, hit);\n        if(hit == false)\n        {\n        \t// Draw Background here.\n            col = background1(uv);\n                \n            post(col, uv);\n            fragColor = vec4(col, 1.);\n            return;\n        }\n            \n        vec3 n;\n        calcnormal(scene, n, 5.e-3, x);\n\n        vec3 l = x+2.*c.yyx, re = normalize(reflect(-l,n)), v = normalize(x-ro);\n        float rev = abs(dot(re,v)), ln = abs(dot(l,n));\n\n        col = color(rev, ln, s.y, uv, x);\n    }\n    \n    // Post-process\n    post(col, uv);\n    \n    // Set the fragment color\n    fragColor = vec4(col, 1.);    \n}\n\n","name":"Image","description":"","type":"image"}]}