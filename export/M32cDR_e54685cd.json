{"ver":"0.1","info":{"id":"M32cDR","date":"1727159619","viewed":2,"name":"ikun test","username":"ikun","description":"a moon above the sea","likes":0,"published":1,"flags":56,"usePreview":0,"tags":["sea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// console:\n// gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/scl/fi/os0bna1knyoeyh455xz2z/image.png?rlkey=4lpx45139vopgvlg48189lj3c&st=hd7qrysq&raw=1', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\nconst int KEY_1 = 49;\n// 迭代次数，raymarching\nconst int NUM_STEPS = 32;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n// 法向量\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// 海\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\n// 波浪高度\nconst float HEIGHT = 0.6;\n// 波浪粗糙度\nconst float CHOPPY = 4.0;\n// 渲染速度\nconst float SPEED = 0.8;\nconst float FREQ = 0.16;\n\n// 海的基底颜色\nconst vec3 SEA_BASE_COLOR = vec3(0.05,0.1,0.3)*0.01;\n// 波浪的颜色\nconst vec3 SEA_WATER_COLOR = vec3(0.05,0.1,0.3)*0.04;\n#define MY_TIME (1.0 + iTime * SPEED)\n\n// 八度矩阵\nconst mat2 octave_m = mat2(1.5,1.0,-1.0,1.5);\n\n// noise 算法\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// 光照\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 80.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// 夜晚天空\nvec3 getSkyColor(vec3 e) {\n    // 天空渐变颜色\n    e.y = (max(e.y, 0.0) * 0.5 + 0.1) * 1.5;\n\n    vec3 nightSky = vec3(\n        pow(1.0 - e.y, 3.0) * 0.05,\n        pow(1.0 - e.y, 3.0) * 0.1,\n        pow(1.0 - e.y, 3.0) * 0.3\n    ) * 0.15;\n\n    return nightSky;\n}\n\n\n// 分形布朗运动算法\nfloat octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map_moon(vec2 uv) {\n    float freq = FREQ*10.0;\n    float amp = HEIGHT;\n    float choppy = CHOPPY;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = octave((uv)*freq,choppy);\n    \td += octave((uv-MY_TIME*0.1)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return h;\n}\n\nfloat map(vec3 p) {\n    float freq = FREQ;\n    float amp = HEIGHT;\n    float choppy = CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = octave((uv+MY_TIME)*freq,choppy);\n    \td += octave((uv-MY_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    // 用来在tracing时算法线的\n    float freq = FREQ;\n    float amp = HEIGHT;\n    float choppy = CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = octave((uv+MY_TIME)*freq,choppy);\n    \td += octave((uv-MY_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// 海的颜色\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);\n    fresnel = min(fresnel * fresnel * fresnel, 0.5);\n    \n    vec3 reflected = getSkyColor(reflect(eye, n));    \n    vec3 refracted = SEA_BASE_COLOR + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted*0.5, reflected, fresnel);\n    \n    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - HEIGHT) * 0.18 * atten;\n    \n    color += specular(n, l, eye, 60.0);\n    \n    return color;\n}\n\n// 计算法线\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\n// Ray marching算法\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) {\n        p = ori + dir * tx;\n        return tx;   \n    }\n    float hm = map(ori);    \n    for(int i = 0; i < NUM_STEPS; i++) {\n        float tmid = mix(tm, tx, hm / (hm - hx));\n        p = ori + dir * tmid;\n        float hmid = map(p);        \n        if(hmid < 0.0) {\n            tx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }        \n        if(abs(hmid) < EPSILON) break;\n    }\n    p = ori + dir * mix(tm, tx, hm / (hm - hx));\n    return mix(tm, tx, hm / (hm - hx));\n}\n\n// 月亮光晕颜色\nvec3 moonCol = pow(vec3(168., 195., 224.)/255.*0.6, vec3(2.2));\nvec3 moon(vec3 sundir, vec3 dir) {\n    vec3 col = max(0.0, -dir.z)*moonCol*pow(max(dot(sundir, dir), 0.0), 20.0);\n    vec2 moonPos = dir.xy/dir.z - sundir.xy/sundir.z;\n    vec3 yellow_Color = vec3(0.91, 0.88, 0.23);\n    col = mix(col, vec3(1.65), max(0.0, -dir.z)*map_moon(moonPos)*smoothstep(0.17, 0.15, length(moonPos))*yellow_Color);\n    \n    return col / (col + 1.0);\n}\n\n#define R iResolution.xy\n#define M iMouse\n#define circle(cl,cn,r)  col=mix(col,cl, smoothstep(.001,0.00,length((uv-cn))-r));\n#define cc(cl,FUNC)  col=mix(col,cl, smoothstep(.001,0.00,FUNC));\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat shape(vec2 uv, float k, vec2 c1,float r1, vec2 c2, float r2,vec2 c3, float r3){\n    return smin(length(uv-c1)-r1, smin(length(uv-c2)-r2,length(uv-c3)-r3,k),k);    \n}\n\nvoid rabbit( out vec4 O, in vec2 U )\n{\n    float bufferA = texture(iChannel2, vec2(.5)).x;\n\n    float lastTime = -log(1.0-bufferA) * 10.;\n    float timeDiff = iTime - lastTime;\n\n    vec2 uv = (U-R*.6)/R.y*3., m = (M.xy-R*.5)/R.y,m2 = (M.xy-R*.5)/R.y;\n    uv.y -=.3;\n    float a =  timeDiff*3.,  k=cos(a-.3)*.9+1.7,  k2=cos(a-1.3)*1.+2.4,  z=1.8;\n    vec2 v=  vec2(cos(a)*.6,-sin(a)*.7)*.1,\n         w = -v,   r=vec2(cos(k),sin(k)),  ra=vec2(cos(k2),sin(k2));\n    \n    uv*=z;\n    //background\n    //vec3 col =uv.y <-.3 ? vec3(.3,.6,0):vec3(0,.5,.8);\n    vec3 col = vec3(0.0);\n    vec3 white = vec3(1.);\n    //movement\n    uv+=z*vec2(1.2,.3) + z*vec2(-2.4,0)*(a*.053)*3.-vec2(0,abs(k)*.1) + vec2(5., 0.) ;\n    \n    //tail\n    circle(white,vec2(-.15,-.02)+w*.8-v*.1,.05);\n    \n    //body\n    cc(white, shape(uv,.1,  vec2(.0)-w*.8,.16,  vec2(.12,.05)-w*.5-v*.5,.13,  vec2(.22,.05)-w*.1-v*.8,.12));\n  \n    //face\n    cc(white,shape(uv,.02,   vec2(.4,.11)-v,.05,  vec2(.33,.12)-v,.1,  vec2(.43,.11)-v,.0));\n    circle(vec3(.0),vec2(.35,.16)+v,.01);   \n     \n    //ears\n    cc(white,shape(uv,.05,  vec2(.27,.35)-v,.05,   vec2(.28,.28)-v,.03,  vec2(.29,.23)-v,.025));    \n    cc(white,shape(uv,.05,  vec2(.23,.33)-v,.05,   vec2(.25,.26)-v,.03,   vec2(.27,.21)-v,.025));  \n        \n    //legs\n    cc(white,shape(uv,.05,   vec2(-.02,-.07)-w,.12,   vec2(-.02,-.07)-w-r*.14,.05,  vec2(-.02,-.07)-w-r*.19,.03));\n    \n    //arm\n    cc(white,shape(uv,.04,   vec2(.22,-.01)-v,.07,   vec2(.22,-.01)-v-ra*.07,.04,   vec2(.22,-.01)-v-ra*.12,.03));    \n\n    O = vec4(col,1.0); \n    //vignette\n    O *= vec4(0.91, 0.88, 0.23,0.0)*0.6;   \n}\n\nvec3 getPixel(in vec2 coord, float time) {    \n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray\n    time = 2.0;\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);  \n    vec3 ori = vec3(0.0,3.5,5.0);\n    vec3 dir = normalize(vec3(uv.xy,-0.5));\n\n    dir = normalize(dir);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n\n    //这里调月亮高度\n    vec3 l = normalize(vec3(1.0, 0.5, -1.0));\n    vec3 col = moon(l, dir);\n\n    float bufferA = texture(iChannel2, uv).x;\n\n    float lastTime = -log(1.0-bufferA) * 10.;\n    float timeDiff = iTime - lastTime;\n\n    vec4 char_color = vec4(0., 0., 0., 0.);\n    uv.x = uv.x * 2.0 - 1.0;\n    \n    if(uv.y > (1.0 - timeDiff*0.3))\n    {\n        char_color = (texture(iChannel0, uv));\n        if (char_color.x > 0.5)\n        {\n            char_color.xyz = vec3(0.0,0.0,0.0);\n        }\n        else\n        {\n            char_color.xyz = vec3(0.91, 0.88, 0.5)*0.6;\n        }\n    }\n    \n    vec4 background;\n    rabbit(background, coord);\n    background.xyz += getSkyColor(dir)+ col;\n    \n\n    // color\n    return mix(\n        background.xyz + char_color.xyz,\n        getSeaColor(p,n,l,dir,dist),\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\n}\n\n\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3 + iMouse.x*0.01;\n    \n\n    //rabbit(fragColor, fragCoord);\n\n    vec3 color = getPixel(fragCoord, time);\n    \n    \n    \n    // post\n\tfragColor += vec4(pow(color,vec3(0.65)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// noise 算法\nfloat hash( float p ) {\n\tfloat h = dot(vec2(p,p),vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvec2 Hash(vec2 p)\n{\n\tp  = fract(p * vec2(1.3983, 1.4427));\n    p += dot(p.yx, p.xy +  vec2(3.5351, 4.3137));\n\treturn fract(vec2(p.x * p.y * 5.4337, p.x * p.y * 7.597));\n}\n\nfloat Noise(float n)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = f*f*(3.0-2.0*f);\n    return mix(hash(n), hash(n+1.0), f)-.5;\n   \n}\n\nvec2 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\nvec2 FBM( vec2 p )\n{\n    p = mod(p, 200.0);\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 3.;\n\tf += 0.2500  * Noise(p); p = p * 3.;\n\tf += 0.1250  * Noise(p); p = p * 3.;\n    f += 0.062125 * Noise(p); p = p * 3.;\n    return f;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    \n    float gTime= time;\n    vec2 pos = vec2(gTime * (120.0), gTime * (1000.0));\n    vec2 noise = FBM(pos)* .35 + FBM(pos*7.0)* (.1*Noise(gTime*.1)+.1);\n    \n    vec2 audio =  noise*(sin(time+Noise(time))+1.5);\n    return audio* smoothstep(.0, 2.0, time) * smoothstep(180.0, 170.0, time);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_1 = 49;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    bool key_press = bool(texelFetch(iChannel1, ivec2(KEY_1, 2), 0).x);\n    float t = 1.0 - exp(-iTime*0.1);\n    // fragColor = vec4(1.0);\n    // return;\n    if (key_press)\n    {\n        fragColor = vec4(t);\n    }\n    else\n    {\n        \n        fragColor =texture(iChannel0, uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}