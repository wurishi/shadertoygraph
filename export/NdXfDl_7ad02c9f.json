{"ver":"0.1","info":{"id":"NdXfDl","date":"1645527689","viewed":3753,"name":"Phased Array Simulator","username":"bitluni","description":"Click and drag mouse to change phase shift and source count","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"ssXfR4","parentname":"complete flow"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float timeScale = 0.000005;\n\nconst float frequency = 40000.0;\nconst float speedOfSound = 343.46; //at 20Â°C\nconst float waveLength = 343.46 / frequency;\n\nconst int startSourceCount = 2;\nconst int extraSourceCountSide = 63;\nconst float sourceRadius = 0.001;\nconst float defaultSourceDistance3 = 0.005;\nconst float defaultSourceDistance2 = waveLength/2.0; //0.005;\nconst float defaultSourceDistance = 0.02;\nconst bool directivity = false;\nconst bool attenuation = false;\nconst bool powerDisplay = true;\nconst bool placeBottom = true;\nconst float defaultPixelPerMeter = 10000.0;\nconst bool showPhases = true;\nconst bool showSource = true;\nconst bool mousePowerDisplay = false;\nconst bool mousePhaseShift = true;\nconst bool mouseSoureShift = false;\nconst bool mouseZoom = true;\nconst bool mouseSourceCount = true;\n\n//const float phaseShiftPerSource = 0.0;\n\nconst float PI2 = 3.1415926 * 2.0;\n\nconst float dirTab[11] = float[](\n    0.0, -0.5, -2.0, \n    -4.0, -6.0, -11.5,\n    -15.5, -20.0, -25.0,\n    -27.0, -35.0);\n\nfloat cat(float P0, float P1, float P2, float P3, float t)\n{\n    float t2 = t * t;\n    float t3 = t * t2;\n    return 0.5 * ((2.0 * P1) + (-P0 + P2) * t + (2.0 * P0 - 5.0 * P1 + 4.0 * P2 - P3) * t2 + (-P0 + 3.0 * P1- 3.0 * P2 + P3) * t3);\n}\n\nfloat directivityFactor(vec2 dir)\n{\n    \n    float a = abs(atan(dir.x, dir.y) / PI2 * 360.0);\n    if(a >= 90.0)\n        return 0.0;\n    int index = int(floor(a * 0.1));\n    return pow(10.0, cat(dirTab[max(index - 1, 0)], dirTab[index], dirTab[index + 1], dirTab[index + 2], fract(a * 0.1)) * 0.1);\n}\n\nfloat blend(float t1, float t2, float d, float ct)\n{\n    return smoothstep(0., 1., (ct - t1) / d) *\n     (1. - smoothstep(0., 1., (ct - t2 + d) / d));\n}\n\nfloat sat(float f)\n{\n    return clamp(f, 0., 1.);\n}\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sourceBlend = 0.0;\n    float shiftBlend = 0.0;\n    float syncBlend = 0.0;\n    float phaseBlend = 0.0;\n    float halfWaveBlend = 0.0;\n    float directionalBlend = 0.0;\n    float zoomBlend = 0.0;\n    float zoomBlend2 = 1.0;\n    float powerBlend = 0.0;\n    float extraPhase = 0.0;\n    float maxt = 20.;\n    float countBlend = 0.0;\n\n    int sourceCount = startSourceCount;\n    vec2 sourceShift = vec2(defaultSourceDistance, 0.0);\n    vec4 overlay = vec4(1.0, 1.0, 1.0, 0.0);\n    float phaseShiftPerSource = 0.0;\n    if(mousePhaseShift)\n        phaseShiftPerSource = ((iMouse.x / iResolution.x) + 0.5);\n    float powerDisplayValue = 0.0;\n    if(powerDisplay)\n        powerDisplayValue = 1.0;\n    if(mousePowerDisplay)\n        powerDisplayValue = iMouse.y / iResolution.y;\n    if(mouseSoureShift)\n        sourceShift[0] = 0.04 * iMouse.y / iResolution.y + \n        waveLength / 2.0;\n    float pixelsPerMeter = defaultPixelPerMeter;\n    if(mouseSourceCount)\n        countBlend = iMouse.y / iResolution.y;\n \n \n//////////////////////////////////////////     \n     float dt = mod(iTime , maxt);\n//13 1\n    sourceBlend = 1.0;\n//21\n    shiftBlend = 1.0;\n//32-50 2\n    syncBlend = blend(10.0, maxt, 2., dt);\n//41-48 71.5- 2\n    extraPhase = blend(35.0, 52.0, 0.1, dt);\n    phaseBlend = blend(40.5, 51.5, 1.0, dt) +\n                blend(71.5, 78.0, 2., dt) + \n                blend(96.0, maxt, 2., dt);\n//51 5\n    halfWaveBlend = 1.;\n//68.5 1\n    directionalBlend = blend(68.0, maxt, 2., dt);\n//82 2\n    powerBlend = 1.;\n  \n//////////////////////////////////////////\n    float outerSources = fract(countBlend * float(extraSourceCountSide));\n    float sourceCountFloat = float(sourceCount) + countBlend * float(extraSourceCountSide) * 2.;\n    sourceCount = sourceCount + int(floor(countBlend * float(extraSourceCountSide))) * 2 + 2;\n    float sourceCountFract = fract(sourceCountFloat);\n    \n    sourceShift = vec2(\n        mix(defaultSourceDistance * shiftBlend, \n            defaultSourceDistance2, halfWaveBlend), \n            0);\n    powerDisplayValue = powerBlend;\n    //pixelsPerMeter = mix(pixelsPerMeter, (0.4 * defaultPixelPerMeter), zoomBlend);\n    pixelsPerMeter = mix(pixelsPerMeter, (0.02 * defaultPixelPerMeter), zoomBlend2);\n    float inner = sourceRadius * 0.8 * (1. - zoomBlend2);\n//////////////////////////////////////////\n      float t = dt * timeScale;\n   \n    float powerScale = ((1.0 + countBlend * 1. ) / float(sourceCountFloat));\n \n    float arraySize = sourceShift.x * (float(sourceCount) - 1.0);\n    float arraySizeFloat = sourceShift.x * (float(sourceCountFloat) - 1.0);\n    pixelsPerMeter = defaultPixelPerMeter / arraySizeFloat * 0.01;\n    vec2 source[startSourceCount + extraSourceCountSide + extraSourceCountSide + 2];\n    source[0] = vec2(\n        (iResolution.x - arraySize * pixelsPerMeter) * 0.5, \n        mix(iResolution.y * 0.5, iResolution.y * 0.1, zoomBlend)); //iMouse.xy;    \n    if(placeBottom)\n        source[0].y = sourceRadius * 4.0 * pixelsPerMeter;\n    for(int i = 1; i < sourceCount; i++)\n        source[i] = source[i - 1] + sourceShift * pixelsPerMeter;\n    \n    float sumSin = 0.0;\n    float sumCos = 0.0;\n    for(int i = 0; i < sourceCount; i++)\n    {\n        vec2 dir = fragCoord - source[i];\n        float outerBlend = 1.;\n        if(i == 0 || i == sourceCount - 1)\n            outerBlend = outerSources;\n        \n        float d = length(dir); \n        if(d > inner * pixelsPerMeter && d < sourceRadius * pixelsPerMeter)\n        {\n            //d = 0.0f;\n            if(showSource)\n                overlay = vec4(1., 1., 1., .3) * sourceBlend * outerBlend;\n        }\n\n        float amp = 1.f;\n        if(directivity)\n            amp = mix(1., directivityFactor(dir), directionalBlend);\n        if(attenuation)\n            amp = log(amp / d * 1000.0 + 1.0);\n        float phase = (d / pixelsPerMeter / waveLength - fract(t * frequency) + phaseShiftPerSource * float(i)) * PI2;\n        amp *= outerBlend;\n        sumSin += sin(phase) * amp;\n        sumCos += cos(phase) * amp;\n    }\n    \n    if(showPhases)\n        for(int i = 0; i < 2; i++)\n        {\n            float outerBlend = 1.;\n            if(i == 0 || i == sourceCount - 1)\n                outerBlend = outerSources;\n            float d = (fragCoord.x / iResolution.y) * 10.0;\n            float phase = (d + fract(t * frequency) + phaseShiftPerSource * float(i)) * PI2;\n            float sp = sin(phase);\n            float dy = (abs(1.0 - (((fragCoord.y / iResolution.y) * 50.0 - 1.5 - float(i) * 3.0) - sin(phase))) - 0.02) * 30.0;\n            overlay += vec4(0., 0., 0., clamp(1.0 - dy, 0., 1.) ) * syncBlend;\n        }\n    \n    float power = sqrt(sumSin * sumSin + sumCos * sumCos) * powerScale;\n    //power *= power;\n    vec4 field = mix(\n        vec4(sat(sumSin * powerScale), 0, sat(-sumSin * powerScale), 1.0), \n        vec4(power, power, power, 1.0),\n            powerDisplayValue);\n    fragColor = vec4(\n        sqrt(mix(field.r * field.r, overlay.r * overlay.r, overlay.a)),\n        sqrt(mix(field.g * field.g, overlay.g * overlay.g, overlay.a)),\n        sqrt(mix(field.b * field.b, overlay.b * overlay.b, overlay.a)),\n            1.0);\n}","name":"Image","description":"","type":"image"}]}