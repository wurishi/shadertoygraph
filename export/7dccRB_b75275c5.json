{"ver":"0.1","info":{"id":"7dccRB","date":"1653619598","viewed":93,"name":"octahedron vs spherical mapping","username":"ear7h","description":"Use the mouse to move the sections.\nGrayscale is error (darker is better) and color is the encoding, downsampling, then decoding. Note the higher error around the center of the ball for spherical mapping.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["normalmap","octahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 100.;\n\n// tweek this to change the mapping resolution\nconst float QUANTILES = 8.;\n\n// sphere <-> octohedral mappings from:\n// https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\nvec2 octwrap(vec2 v) {\n    return (1. - abs(v.yx)) * sign(v.xy);\n}\n\nvec2 octen(vec3 n) {\n    n /= abs(n.x) + abs(n.y) + abs(n.z);\n    n.xy = n.z >= 0. ? n.xy : octwrap(n.xy);\n    n.xy = n.xy * 0.5 + 0.5;\n    return n.xy;\n}\n\nvec3 octde(vec2 v) {\n    v = v * 2. - 1.;\n    \n    vec3 n = vec3(v.x, v.y, 1. - abs(v.x) - abs(v.y));\n    float t = max(-n.z, 0.);\n    n.xy += -sign(n.xy) * t;\n\n    return normalize(vec3(n));\n}\n\n// standard spherical coords\n// https://en.wikipedia.org/wiki/Spherical_coordinate_system\nvec2 sphen(vec3 n) {\n    return vec2(acos(n.z), atan(n.y, n.x)) / vec2(PI, PI * PI);\n}\n\nvec3 sphde(vec2 v) {\n    v *= vec2(PI, PI * PI);\n    return vec3(\n        cos(v.y) * sin(v.x),\n        sin(v.y) * sin(v.x),\n        cos(v.x)\n    );\n}\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n\nfloat ball(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nfloat scene(vec3 p) {\n    return ball(p, 1.);\n    \n}\n\nfloat raymarch(vec3 camera, vec3 ray) {\n    float depth = MIN_DIST;\n    \n    for (int i = 0; i < 255; i++) {\n        float dist = scene(camera + ray * depth);\n        if (dist < 0.0001) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n\n    return MAX_DIST;\n}\n\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\n\nvec3 quadrantcol(vec3 norm) {\n    // smooth\n    return 0.5 * norm + 0.5;\n    \n    // discrete quadrants\n    //return 0.5 * sign(norm) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy * .5)/iResolution.y;\n    vec3 cam = normalize(vec3(1, uv));\n    vec3 init = vec3(-3., 0., 0.);\n    \n    float zrot = iTime/1.5;\n    float yrot = 0.5;\n    \n    cam = erot(cam, vec3(0, 1, 0), yrot);\n    init = erot(init, vec3(0, 1, 0), yrot);\n    cam = erot(cam, vec3(0, 0, 1), zrot);\n    init = erot(init, vec3(0, 0, 1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    \n    fragColor = vec4(vec3(0.), 1.);\n \n \n        for (int i = 0; i < 150 && !hit; i++) {\n            float dist = scene(p);\n            if (dist * dist < 1e-8) {\n                // oct usage\n                vec3 n = norm(p);\n                \n                vec3 n1;\n                \n                if (\n                    (iMouse.y != 0. && uv.y < iMouse.y/iResolution.y - 0.5) ||\n                    (iMouse.y == 0. && uv.y < 0.0)\n                ) {\n                    n1 = octde(round(octen(n) * QUANTILES) / QUANTILES);\n                } else {\n                    n1 = sphde(round(sphen(n) * QUANTILES) / QUANTILES);\n                }\n                \n                if (\n                    (iMouse.x != 0. && uv.x > 2. * iMouse.x/iResolution.x - 1.) ||\n                    (iMouse.x == 0. && uv.x > 0.0)\n                ) {\n                    vec3 col = quadrantcol(n1);\n                    fragColor.rgb = col;\n                } else {\n                    // show error\n                    fragColor.rgb = vec3(distance(n, n1));\n                }\n                \n                break;\n            }\n            p += cam*dist;\n            if (distance(p, init) > 20.) {\n                break;\n            }\n        }\n    \n    fragColor = sqrt(fragColor);\n}","name":"Image","description":"","type":"image"}]}