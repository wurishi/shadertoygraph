{"ver":"0.1","info":{"id":"3dSyzy","date":"1587080231","viewed":115,"name":"Cornell Box - AO + DoF","username":"ez21","description":"Cornell Box, with ambient occlusion and thinLens DoF approximation","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLUR true\n\nfloat array[121] = float[](0.006849, 0.007239, 0.007559, 0.007795, 0.007941, 0.00799,\n                           0.007941, 0.007795, 0.007559, 0.007239, 0.006849, 0.007239,\n                           0.007653, 0.00799, 0.00824, 0.008394, 0.008446, 0.008394,\n                           0.00824, 0.00799, 0.007653, 0.007239, 0.007559, 0.00799,\n                           0.008342, 0.008604, 0.008764, 0.008819, 0.008764, 0.008604,\n                           0.008342, 0.00799, 0.007559, 0.007795, 0.00824, 0.008604,\n                           0.008873, 0.009039, 0.009095, 0.009039, 0.008873, 0.008604,\n                           0.00824, 0.007795, 0.007941, 0.008394, 0.008764, 0.009039,\n                           0.009208, 0.009265, 0.009208, 0.009039, 0.008764, 0.008394,\n                           0.007941, 0.00799, 0.008446, 0.008819, 0.009095, 0.009265,\n                           0.009322, 0.009265, 0.009095, 0.008819, 0.008446, 0.00799,\n                           0.007941, 0.008394, 0.008764, 0.009039, 0.009208, 0.009265,\n                           0.009208, 0.009039, 0.008764, 0.008394, 0.007941, 0.007795,\n                           0.00824, 0.008604, 0.008873, 0.009039, 0.009095, 0.009039,\n                           0.008873, 0.008604, 0.00824, 0.007795, 0.007559, 0.00799,\n                           0.008342, 0.008604, 0.008764, 0.008819, 0.008764, 0.008604,\n                           0.008342, 0.00799, 0.007559, 0.007239, 0.007653, 0.00799,\n                           0.00824, 0.008394, 0.008446, 0.008394, 0.00824, 0.00799,\n                           0.007653, 0.007239, 0.006849, 0.007239, 0.007559, 0.007795,\n                           0.007941, 0.00799, 0.007941, 0.007795, 0.007559, 0.007239,\n                           0.006849);\n// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    if (BLUR) {\n        // from https://www.shadertoy.com/view/XdfGDH\n        const int mSize = 11;\n        const int kSize = (mSize-1)/2;\n        float kernel[mSize];\n        vec3 final_color = vec3(0.0);\n\n        //create the 1-D kernel\n        float sigma = 20.0;\n        float Z = 0.0;\n        for (int j = 0; j <= kSize; ++j) {\n            kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n        }\n\n        //get the normalization factor (as the gaussian has been clamped)\n        for (int j = 0; j < mSize; ++j) {\n            Z += kernel[j];\n        }\n\n        //read out the texels\n        for (int i=-kSize; i <= kSize; ++i) {\n            for (int j=-kSize; j <= kSize; ++j) {\n                final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n            }\n        }\n\n        vec2 uv = fragCoord/iResolution.xy;\n        vec4 unblurredColor = texture(iChannel0, uv);\n\n        fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n    }\n    \n    else {\n        // no blur   \n        vec2 uv = fragCoord/iResolution.xy;\n        vec4 unblurredColor = texture(iChannel0, uv);\n        fragColor = unblurredColor;\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FLOOR_SDF plane(pos, vec3(0., 1.0, 0.), vec3(0., -2.5, 0.))\n#define LEFTWALL_SDF plane(pos, vec3(-1., 0.0, 0.), vec3(5., 2.5, 0.))\n#define RIGHTWALL_SDF plane(pos, vec3(1., 0.0, 0.), vec3(-5., 2.5, 0.))\n#define BACKWALL_SDF plane(pos, vec3(0., 0.0, -1.), vec3(0., 2.5, 5.))\n#define CEILING_SDF plane(pos, vec3(0., -1.0, 0.), vec3(0., 7.5, 0.))\n#define LONGCUBE_SDF box(pos, vec3(3., 6., 3.), vec3(0.0, 27.5, 0.0), vec3(2., 0., 3.))\n#define SHORTCUBE_SDF box(pos, vec3(3., 3., 3.), vec3(0.0, -17.5, 0.0), vec3(-2., -1., 0.75))\n\n    \n#define FLOOR_ID 3\n#define LEFTWALL_ID 4\n#define RIGHTWALL_ID 5\n#define BACKWALL_ID 6\n#define CEILING_ID 7\n#define LONGCUBE_ID 8\n#define SHORTCUBE_ID 9\n\n\nconst float FOVY = (3.141569 * 2.) * 19.5 / 360.;\nconst int RAY_STEPS = 256;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n    vec3 n;\n};\n    \n\n\n\n// SDF of a sphere\nfloat sphere(vec3 p , float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n// SDF of plane\nfloat plane(vec3 p, vec3 n, vec3 c)\n{\n  \t// n must be normalized\n  \tvec3 a = p - c;\n  \tvec3 b = n;\n    \n    if (dot(a, b) < -0.001) {\n        return 10000.;\n    }\n  \n  \treturn dot(a ,b) / length(b);\n}\t\n\n// transformation\nmat4 inverseTransform(vec3 s, vec3 rDeg, vec3 t) {\n    \n    // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 rMat = r_x * r_y * r_z;\n    \n    // creating worldTransform matrix\n    mat4 translateMat;\n    translateMat[0] = vec4(1., 0., 0., 0.);\n    translateMat[1] = vec4(0., 1., 0., 0.);\n    translateMat[2] = vec4(0., 0., 1., 0.);\n    translateMat[3] = vec4(t.x, t.y, t.z, 1.);\n    \n    mat4 scaleMat;\n    scaleMat[0] = vec4(s.x, 0., 0., 0.);\n    scaleMat[1] = vec4(0., s.y, 0., 0.);\n    scaleMat[2] = vec4(0., 0., s.z, 0.);\n    scaleMat[3] = vec4(0., 0., 0., 1.);\n\n    mat4 worldTrans = translateMat * rMat * scaleMat;\n    \n    return inverse(worldTrans);\n}\n\n// SDF of box\nfloat box(vec3 p, vec3 s, vec3 r, vec3 t) {\n    mat4 inverseTrans = inverseTransform(s, r, t);\n    vec4 tempP = inverseTrans * vec4(p, 1.f);\n    p = vec3(tempP.x, tempP.y, tempP.z);\n    \n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n    \n    float t2;\n    if ((t2 = LEFTWALL_SDF) < t) {\n        t = t2;\n        obj = LEFTWALL_ID;\n    }\n    if ((t2 = RIGHTWALL_SDF) < t) {\n        t = t2;\n        obj = RIGHTWALL_ID;\n    }\n    if ((t2 = BACKWALL_SDF) < t) {\n        t = t2;\n        obj = BACKWALL_ID;\n    }\n    if ((t2 = CEILING_SDF) < t) {\n        t = t2;\n        obj = CEILING_ID;\n    }\n    if ((t2 = LONGCUBE_SDF) < t) {\n        t = t2;\n        obj = LONGCUBE_ID;\n    }\n    if ((t2 = SHORTCUBE_SDF) < t) {\n        t = t2;\n        obj = SHORTCUBE_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = LEFTWALL_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = RIGHTWALL_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = BACKWALL_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = CEILING_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = LONGCUBE_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SHORTCUBE_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nfloat distField(vec3 pos) {\n    return 0.;\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos), \n                    \t  sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n    \n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeMaterial(int hitObj, vec3 pos, vec3 n, vec3 lightVec, vec3 view) {\n    float lambert = dot(lightVec, n);\n    switch(hitObj) {\n        case FLOOR_ID:\n        \treturn vec3(1., 1., 1.) * lambert; // * colorPalette(WorleyNoise3D(p));\n        \tbreak;\n        case LEFTWALL_ID:\n        \treturn vec3(1., 0., 0.) * lambert;\n            break;\n        case RIGHTWALL_ID:\n        \treturn vec3(0., 1., 0.) * lambert;\n            break;\n        case BACKWALL_ID:\n        \treturn vec3(1., 1., 1.) * lambert;\n            break;\n        case CEILING_ID:\n        \treturn vec3(1., 1., 1.) * lambert;\n            break;\n        case LONGCUBE_ID:\n        \treturn vec3(1., 1., 1.) * lambert;\n            break;\n        case SHORTCUBE_ID:\n        \treturn vec3(1., 1., 1.) * lambert;\n            break;\n        case -1:\n            return vec3(0., 0., 0.);\n        \tbreak;\n    }\n    return vec3(0., 0., 0.);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect, lightPos);\n    \n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    // vec3 normalAsColor = 0.5 * (nor + vec3(1.0, 1.0, 1.0));\n    \n    return Intersection(t, surfaceColor, isect, hitObj, nor);\n}\n\n// returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0, 1, 0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 5.5, -35);\n    vec3 ref = vec3(0, 2.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    vec3 lightPos = vec3(0, 7.4, -2.0);\n\n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n    \n    // used for DoF gaussian blur\n    float FOCAL_LENGTH = mix(50.0, 35., cos(iTime));\n\tfloat FOCAL_RANGE = 16.0;\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (isect.p - eye)));\n    float dofBlurAmount = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofBlurAmount = pow(dofBlurAmount, 0.5);\n    \n    // ambient occlusion\n    float k = 2.5;\n    float occDist = 0.12;\n    float sum = 0.;\n    for (float i = 1.; i <= 5.; i = i + 1.) {\n        float distSDF = sceneMap3D(isect.p + isect.n * i * occDist, lightPos);\n        sum += (1. / pow(2., i)) * (i * occDist - distSDF);\n    }\n    float ao = 1.0 - k * sum;\n\n    // Output to screen\n    fragColor = vec4(isect.color, dofBlurAmount) * ao;\n}","name":"Buffer A","description":"","type":"buffer"}]}