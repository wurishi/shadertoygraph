{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define MAX_STEP 100\n#define MAX_DIST 100.\n#define MIN_D 0.01\n\nmat2 rot(float a){\n    return mat2(\n        cos(a), sin(a),\n        -sin(a), cos(a)\n    );\n}\nfloat sdCube(vec3 p , vec3 s, float r){\n    return length( max(abs(p)-s, 0.))-r;\n}\nfloat GetDist(vec3 p ){\n    //float s = length(p-vec3(0., 0., 9.))-2.;\n    \n    \n    vec3 pos = vec3(0., 1., 9.);\n    pos.xz *= rot(iTime);\n    float c = sdCube(p-pos, vec3(1., 2., 3.), 2.);\n    \n    float pl = p.y + 2.;\n    \n    vec4 pp = vec4(p-vec3(0,1,4), 1);\n    pp.wz *= rot(iTime);\n    pp.wy *= rot(iTime*2.); \n    pp.xz *= rot(iTime);\n    float ci = length( max(abs(pp)-vec4(1.,1.,1.,1.), 0.));\n    \n    return min(ci, pl);\n}\nfloat RayMarch(vec3 ro, vec3 rd, float side){\n    float D = 0.;\n    for(int i = 0; i < MAX_STEP; i ++){\n        vec3 p = ro + rd * D;\n        float ds = GetDist(p) * side;\n        D += ds;\n        if(D < MIN_D || D > MAX_DIST)break;\n    }\n    return D;\n}\n\nvec3 GetNormal(vec3 p){\n    float dp = GetDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    vec3 n = dp - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n\n    vec3 LightPos = vec3(0., 80., -20.);\n    \n    vec3 l2p = normalize(LightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(l2p, n), 0., 1.);\n    float d = RayMarch(p+n*MIN_D*2., l2p, 1.);\n \n    if(d < length(LightPos - p)) dif *= 0.1;\n    \n    return dif;\n}\n\nfloat GetRayDif(vec3 p, vec3 ro, vec3 rd){\n    vec3 n = GetNormal(p);\n    float distP = GetDist(p);\n    vec3 ray = ro + rd * distP;\n    \n    float it1 = RayMarch(p, n, 1.);\n\n    return it1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = 2. *fragCoord/iResolution.xy - 1.;\n    \n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    vec3 col = vec3(0.2, 0.5, 0.7);\n    \n    float d = RayMarch(ro, rd, 1.);\n    \n\n    \n    float l = 0.;\n    if(l < MAX_DIST){\n    \n        vec3 p = ro + rd * d;\n        l = GetLight(p);\n    }\n    \n    col *= vec3(l);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcKBzh","date":"1734265596","viewed":10,"name":"4D cube","username":"haprog","description":"4d cube","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["4d"],"hasliked":0,"parentid":"","parentname":""}}