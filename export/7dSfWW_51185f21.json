{"ver":"0.1","info":{"id":"7dSfWW","date":"1646298798","viewed":66,"name":"Ferris - PBR Marcher","username":"Ferrisfox","description":"PBR rendering powered by ray marching ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SURF_DIST .001\n\n// Sky limit\n#define MAX_DIST 5000.\n#define SKY_DIST -1.\n\n// Iteration limit\n#define MAX_ITER 5000.\n#define ITER_DIST -1.\n\n// Material properties\n#define SMOOTHNESS .5\n#define METALLIC .3\n\n\nstruct ray { // Ray\n    vec3 o;  // Ray orign\n    vec3 d;  // Ray direction (plz normalize this)\n};\n\nstruct rmr { // Ray March Result\n    float d; // Obj Distance\n    float i; // Steps taken\n    float a; // ~Ang Ray-SDF\n};\n\nstruct ptlight { // Point light\n    vec3 p;      // Position\n    float i;     // Intensity\n    float s;     // Shadow softness\n};\n\nfloat sdf( vec3 p ) {\n    return min(p.y, distance(p,vec3(0,1,0))-1.);\n}\n\nrmr march( ray r, float md ) {\n    rmr m = rmr(0., 0., 6.);\n    \n    for(; m.i<MAX_ITER; m.i++) {\n        \n        vec3 p = r.o + r.d * m.d;\n        float d = sdf(p);\n        \n        m.a = min( m.a, atan(d,m.d));\n        \n        m.d += d;\n        \n        if( d < SURF_DIST ) {\n            return m;\n        }\n        \n        // Sky limit\n        if( m.d > md ) {\n            #ifdef SKY_DIST\n            m.d = SKY_DIST;\n            #endif\n            return m;\n        }\n    }\n    \n    // Too many iterations\n    #ifdef ITER_DIST\n    m.d = ITER_DIST;\n    #endif\n    \n    return m;\n}\n\nvec3 norm( vec3 p ) {\n    const vec2 d = vec2(0, SURF_DIST);\n    \n    vec3 n = vec3(\n        sdf(p + d.yxx) - sdf(p - d.yxx),\n        sdf(p + d.xyx) - sdf(p - d.xyx),\n        sdf(p + d.xxy) - sdf(p - d.xxy)\n    );\n    \n    return normalize(n);\n}\n\nvec3 rendptlight( ptlight l, vec3 p, ray v ) {\n    const float esd = SURF_DIST * (1. + SURF_DIST);\n\n    vec3 ld = normalize(l.p - p);\n    float d = distance(l.p, p);\n    \n    vec3 n = norm(p);\n    \n    float light = 0.0795774 * l.i / (d*d);\n    \n    ray lr = ray( p + n*esd, ld);\n    rmr lm = march(lr, d);\n    \n    light *= lm.d == SKY_DIST ? 1. : 0.;\n    light *= smoothstep(.0, l.s*.1, lm.a); \n    \n    //////////////\n    //  albedo  //\n    //////////////\n    \n    float albedo = clamp(dot( n, ld ), 0., 1.);\n    albedo *= light * (1.-METALLIC);\n    \n    ///////////////////\n    //  blinn-phong  //\n    ///////////////////\n    \n    vec3 hv = normalize(ld - v.d);\n    float spec = clamp(dot(hv, n), 0., 1.);\n    spec = pow(spec, SMOOTHNESS * 100.);\n    spec *= light * METALLIC;\n    \n    return vec3(albedo + spec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 lp = vec3(cos(iTime),0,sin(iTime))*2.;\n    lp.y = 1.5;\n    \n    ptlight l = ptlight(lp, 20., 1.);\n    \n    vec3 ro = vec3(0, 1, -5);\n    vec3 rd = normalize(vec3(uv,1));\n    ray r = ray(ro,rd);\n    rmr m = march(r, MAX_DIST);\n    \n    vec3 p = ro + rd * m.d;\n    \n    \n    col += rendptlight(l, p, r);\n    col *= m.d>0. ? 1. : 0.;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}