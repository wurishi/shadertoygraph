{"ver":"0.1","info":{"id":"3slfzN","date":"1587843922","viewed":399,"name":"Raymarch Infinite spheres","username":"NRGsama","description":"Raymarch Infinite spheres\nSDF and infinite duplication code from Inigi Quilez\nSort of fake DOF effect using 1/(1+d*d*0.1) ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdSphere( vec3 p, vec3 b )\n{\n  return sin(length(p)) - b.x  ;\n}\nfloat opRep( in vec3 p, in vec3 c , float s )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdSphere(q,vec3(s,s,s));\n}\nfloat getDist(vec3 p) {\n    return opRep(p,vec3(1,1,1),0.04);\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p){\n\tvec3 lightPos = vec3(0,1,iTime) ;\n    //lightPos.xz += vec2(2.*sin(iTime),2.*cos(iTime));\n    vec3 lv = normalize(lightPos - p ); \n    vec3 n = getNormal(p) ;\n    float dif = clamp(dot(n,lv),0.,1.)*5. ;\n    float d = rayMarch(p+n*SURF_DIST*2.,lv) ;\n    //if(d<length(lightPos-p)) dif *=.1 ;\n    return dif ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float speed = 0.05 ; \n    mat2 mat = mat2(vec2(cos(iTime*speed), sin(iTime*speed)), \t\t// first column (not row!)    \n             \t\tvec2(-sin(iTime*speed), cos(iTime*speed)));\n    uv = mat*uv ;\n\tvec3 ro = vec3(0,0.5,iTime);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    float d = rayMarch(ro,rd);\n    //vec3 p = ro + rd * d ;\n    float dif = 1.0/(1.0+d*d*0.1);\n    vec3 col = vec3(dif*2.,dif/d*2.0,0);\n    //float fog = 1.0 / 1.0 + d*d*0.1;\n    //vec3 col  = vec3(fog) ;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}