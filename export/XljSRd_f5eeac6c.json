{"ver":"0.1","info":{"id":"XljSRd","date":"1445912086","viewed":108,"name":"endlessFileboxes","username":"polyomino","description":"Learning a bit more about raymarching...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float PI=3.14159265;\n\n\nvec2 oRoundedBox(vec3 p, vec3 boxRadius, float rounding, float material)\n{\n    boxRadius -= vec3(rounding, rounding, rounding);\n    float d = length(max(abs(p)-boxRadius,0.0)) - rounding;\n    return vec2(d,1);\n}\n\nvec2 oUnion(in vec2 obj0, in vec2 obj1)\n{\n  if (obj0.x < obj1.x)\n  \treturn obj0;\n  else\n  \treturn obj1;\n}\n\nvec2 oMindProbe(vec3 p)\n{\n    float rpt = 12.0;\n    p += rpt / 2.0;\n    \n    vec3 k = floor(p / rpt);\n    p = mod(p, rpt) - rpt / 2.0;\n    float sM = 2.0;\n    float sT = 0.3;\n    float sR = 0.4;\n    float cM = 1.8;\n    float cR = 0.3;\n    vec2 p1 = oRoundedBox(p, vec3(sT, sM, sin(k.z) * sM), sR, 1.0);\n    vec2 p2 = oRoundedBox(p, vec3(sin(k.x) * sM, sT, sM), sR, 1.0);\n    vec2 p3 = oRoundedBox(p, vec3(sM, sin(k.y) * sM, sT), sR, 1.0);\n    vec2 p4 = oRoundedBox(p, vec3(cM, cM, cM), cR, 2.0);\n    \n    p1 = oUnion(p1,p2);\n    p1 = oUnion(p1,p3);\n    p1 = oUnion(p1,p4);\n    \n    return p1;\n}\n\n//Floor Color (checkerboard)\nvec3 floor_color(in vec3 p)\n{\n  if (fract(p.x*0.2)>0.2)\n  {\n    if (fract(p.z*0.2)>0.2)\n      return vec3(0,0.1,0.2);\n    else\n      return vec3(1,1,1);\n  }\n  else\n  {\n    if (fract(p.z*.2)>.2)\n      return vec3(1,1,1);\n    else\n      return vec3(0.3,0,0);\n   }\n}\n\n// from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//float rand(float n){return fract(sin(n) * 43758.5453123);}\n//float noise(float p)\n//{\n//  float fl = floor(p);\n//  float fc = fract(p);\n//  return mix(rand(fl), rand(fl + 1.0), fc);\n//}\n\nvec3 rand3(vec3 n)\n{\n  return fract(sin(n) * 43758.5453123);\n}\nvec3 noise3(vec3 p)\n{\n    vec3 pF = floor(p);\n    vec3 pR = fract(p);\n    return mix(rand3(pF), rand3(pF + vec3(1,1,1)), pR);\n}\n\n// Primitive color\nvec3 prim_c(in vec3 p)\n{\n  return noise3(p * 8.3);\n// instead of grey\n//  return vec3(0.6,0.6,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n\n  // Camera up vector.\n  vec3 vuv=vec3(0,1,0); \n  \n  // Camera lookat.\n  vec3 vrp=vec3(0,0,0);\n\n  float mx=iMouse.x/iResolution.x*PI*2.0;\n  float my=iMouse.y/iResolution.y*PI/2.01;\n    float cameraDistance = 15.0;\n  vec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*cameraDistance; \n  //vec3 prp = vec3(0.0);\n    \n    prp += iTime;\n\n  // Camera setup.\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n\n  // Raymarching.\n  const vec3 e=vec3(0.02,0,0);\n  const float maxd=100.0; //Max depth\n  vec2 d=vec2(0.1,0.0);\n  vec3 c,p,N;\n\n  float f=1.0;\n  for(int i=0;i<64;i++)\n  {\n    if ((abs(d.x) < .001) || (f > maxd)) \n      break;\n    \n    f+=d.x;\n    p=prp+scp*f;\n      d = oMindProbe(p);\n  }\n  \n  if (f < maxd)\n  {\n    // y is used to manage materials.\n    if (d.y==0.0) \n      c=floor_color(p);\n    else\n      c=prim_c(p);\n    \n    vec3 n = vec3(d.x-oMindProbe(p-e.xyy).x,\n                  d.x-oMindProbe(p-e.yxy).x,\n                  d.x-oMindProbe(p-e.yyx).x);\n    N = normalize(n);\n      float lightAngle = iTime;\n      //lightAngle = 2.0;\n\tvec3 L = vec3(sin(lightAngle)*20.0,10,cos(lightAngle)*20.0);\n    float b=dot(N,normalize(prp-p+L));\n    //simple phong lighting, LightPosition = CameraPosition\n    fragColor=vec4((b*c+pow(b,6.0))*(1.0-f*.01),1.0);\n  }\n  else \n    fragColor=vec4(0,0,0,1); //background color\n}\n","name":"Image","description":"","type":"image"}]}