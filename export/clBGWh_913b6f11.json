{"ver":"0.1","info":{"id":"clBGWh","date":"1673190986","viewed":90,"name":"random segment tiles 2","username":"kastorp","description":"another experiment","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["lines","blocks","segments","asymmetric"],"hasliked":0,"parentid":"dtj3WR","parentname":"random segment tiles"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// random segment tiles 2 by kastorp\n// inspired by  https://www.shadertoy.com/view/Ws3GRs \n\n//David Hoskins Hash without sin\nvec2 hash22(vec2 p)\n{\n    p*=1.1;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// modulation function, based on block position\n// x= position shift, y= on(if<0) / off(if>=0)\nvec2 val(vec2 x) { \n    //return .2 *sin(x.x*1.57+.87)+ .2 *sin(x.y*1.57+.87) ; //Gyroid\n    vec2 v =mix(hash22(x+floor(iTime)), hash22(x+floor(iTime+1.)),fract(iTime))*.8-.4; //random\n    \n    //return vec2(v.x,  min(mod(x.x,4.),mod(x.y,3.))>0.? 1.:0.);\n    if(abs(x.x)>7.) return vec2(0.,  mod(x.x,3.)!=mod(x.y,3.)?-.1:1.); //deterministic\n    return vec2(v.x,v.y-.5 +smoothstep(0.,4.,abs(length(x)-5.))); //random position and probabilistic\n}\n\n#define line(t) smoothstep(max(28./iResolution.y,.02),0., abs(t))\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    vec2 uv = 14.*(I-.5*iResolution.xy)/iResolution.y;\n    vec2 c= floor(uv+.5),lc=fract(uv+.5)-.5,k=vec2(1,0);\n    bool odd = mod(c.x,2.)!=mod(c.y,2.);     \n    if(odd){lc=lc.yx;k=k.yx;} \n\n    // Explanation: \n    // even tiles are crosse by a vertical line (A,B), subdivided in segments c1,c2,c3\n    // the segment c4 connects point E (which is coincident to B of the left tile) to AB\n    // the segment c5 connects point D (which is coincident to A of the right tile) to AB\n    //  \n    //\n    //         B     \n    //         |           \n    //         c3            \n    //         |---c4--D           \n    //         |               \n    //         c2          \n    // E--c5---|           \n    //         |\n    //         c1     \n    //         |         \n    //         A\n    //\n    // general rules:\n    //   for odd tiles the axis are swapped\n    //   if E is above D, flip y axis\n    //   c1 depends on the current tile \n    //   c4 and c5 are dependent from the neighbours\n    //   c3 is active only if c1 is active\n    //   c2 must connect c4 and c5 (if both active), but may be removed if also c1 and c3 are active\n       \n    vec2 hx=val(c),hr=val(c+k),hl=val(c-k);\n    vec2 a=vec2(hx.x,-.5), b=vec2(a.x,+.5),d=vec2(.5,hr.x),e=vec2(-.5,hl.x);\n    float flip=1.,mx=d.y,mn=e.y;\n    if(e.y>d.y) {flip=-1.; vec2 t=a;a=b;b=t; mx=e.y;mn=d.y;} // if crossing, flip y axis\n\n    //tile id (unused here):\n    //vec2 id=vec2(max(step(lc.x - a.x,0.)*step(lc.y - e.y,0.),step(lc.x - a.x,0.)*step(0.,lc.y - e.y)),\n    //    max(step(0.,lc.x - a.x)*step(lc.y - d.y,0.),step(lc.x - a.x,0.)*step(lc.y - e.y,0.)));        \n    //id =  + c  - (odd?id.yx:id.xy);   \n\n    //colors\n    vec3  oddC=vec3(.4,0,0),evenC=vec3(0,.4,0),lineC1=vec3(1), orphC=vec3(0,0,.4);\n    if(iMouse.z<=0.) { oddC=evenC=vec3(.3);orphC=vec3(.1);};               \n\n    //evaluate active segments  \n    float c4=step(hr.y,0.) ,c5=step(hl.y,0.),c1=step(hx.y,0.), c3=c1,c2=max(min(c4,c5),c1);\n    if(min(min(c4,c5),c1)>0. && abs(d.y-e.y)>.2 ) c2=step(hr.y,-0.25);\n    \n    vec3 col =  (odd? oddC :evenC)*max(c1,min(c4,c5)*.5) ; //debug brick color\n                //*(.5+.25*sin(id.x*1.57) +.25*cos(id.y*3.14)); //block color\n    col += lineC1*(\n              line(lc.x - a.x)*( c1* step(lc.y-mn,0. ) \n                       + c2* step(lc.y-mx,0. )* step(0.,lc.y-mn) \n                       + c3* step(0.,lc.y-mx))\n           +  line(lc.y - d.y) * c4 * step(0.,lc.x-a.x)\n           +  line(lc.y - e.y) * c5 * step(lc.x-a.x,0.)\n       );\n    if(c4!=c5 && c1==0.) col+=orphC;\n    \n    O = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}