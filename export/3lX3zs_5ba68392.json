{"ver":"0.1","info":{"id":"3lX3zs","date":"1557505791","viewed":185,"name":"Art : Rings","username":"Gijs","description":"Tried to make https://nl.reddit.com/r/blender/comments/axjh2c/spinning_rings/","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["dasdasdad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float onion( in float sdf, in float thickness ){\n    return abs(sdf)-thickness;\n}\n\nfloat dBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat dSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat dRing( in vec3 p, float r){\n    float s = dSphere(p,r);\n    float o = onion(s,RING_WIDTH);  \n    return max(o,max(p.y-RING_BREADTH,-RING_BREADTH-p.y));\n}\n\nfloat dBase(vec3 p){\n    float onion  = onion( onion( onion( onion( dSphere(p,1.) , 0.5), 0.25), 0.125), 0.125-RING_WIDTH);\n    float cut1 = max(onion,p.y);\n    \n    float box  = dBox(p-vec3(0,-2,0),vec3(2));\n    float cut2 = max(box,-dSphere(p,1.9));\n    return min(cut1,cut2);\n}\n\nfloat dRings(vec3 p){\n    float distance = 1e20;\n    \n    for(float i=1.;i<=7.;i++){\n        vec3 q = rotate(p, iTime+i*0.2, vec3(0,1,0));\n             q = rotate(q, iTime*1.1+i*0.2, vec3(1,0,0));\n        distance = min(distance,dRing(q,.25*i));\n    }\n    return distance;\n}\n\nfloat dFloor(vec3 p){\n    float floor = max(p.y+0.1, -dSphere(p,1.9));\n    float box1  = dBox(p+vec3(5,0,0),vec3(3,1,7));\n    float box2  = dBox(p+vec3(-1.,0,-3),vec3(1));\n    return min(min(floor,box1),box2);\n}\n\nfloat getDistance(vec3 p){\n    float distance = MAX_MARCH;\n\n    \n    distance = min(distance,dBase(p));\n    distance = min(distance,dRings(p));\n    distance = min(distance,dFloor(p));\n    \n    return distance;\n}\n\nvec3 getColor(vec3 p){\n    float distance = MAX_MARCH;\n    vec3  color    = vec3(.8);\n    \n    float base = dBase(p);\n    if(base<distance){\n        distance = base;\n        color = vec3(0.03);\n    }\n    \n    float rings = dRings(p);\n    if(rings<distance){\n        distance = rings;\n        color = vec3(1,.4,.2);\n    }\n    \n    float floor = dFloor(p);\n    if(floor<distance){\n        distance = floor;\n        color = vec3(1.);\n    }\n\n\n    return color;\n}\n\nvec3 getNormal(vec3 p, float eps){\n    eps = max(eps,1e-7);\n    vec2 k = vec2(1,-1);\n    vec2 d = k*eps;\n    return normalize( k.xyy*getDistance( p + d.xyy ) + \n                      k.yyx*getDistance( p + d.yyx ) + \n                      k.yxy*getDistance( p + d.yxy ) + \n                      k.xxx*getDistance( p + d.xxx ) );\n}\n\nfloat softshadow(vec3 p, vec3 d, float k, float eps, float m){\n    float res = 1.0;\n    float ph  = 1e20;\n    float t   = 2.*eps;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        float h = getDistance(p + d*t);\n        \n        if( h < eps ) return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        \n        if(t>m) break;\n    }\n    \n    return res;\n}\n\nfloat occlusion(vec3 p, vec3 n){\n    float o = 1.0;\n    float s = OCCLUSION_SPREAD;               \n    float k = OCCLUSION_INTENSITY/s;  \n    float d = 2.0*s;           \n    \n    for (int i = 0; i < OCCLUSION_SAMPLES; ++i) {\n        o -= (d - getDistance(p + n * d)) * k;\n        d += s;\n        k *= 0.5;\n    }\n    \n    return clamp(o, 0.0, 1.0);\n}\n\nvoid raymarch(in vec3 p, in vec3 d, float eps, inout int steps, inout float dis, inout float meps, inout float t){\n\tfor (;steps<MAX_STEPS;steps++){\n\t\tdis = getDistance(p + d*t);     \n        t += dis;\n        meps = abs(t)*eps;\n\n\t\tif(dis<meps){\n            t -= (meps-dis);\n            break;\n        }\n        \n        if(t>MAX_MARCH) break;\n\t}\n}\n\nvec3 raymarcher(vec3 p, vec3 d, float eps){ \n    int   steps = 0;\n    float dis = 0.;\n    float meps = 0.;\n    float t = 0.;\n    raymarch(p,d,eps,steps,dis,meps,t);\n    vec3 hitPos    = p + d*t;\n\n    if(dis<meps){\n\n        vec3 hitColor  = getColor(hitPos);\n        vec3 hitNormal = getNormal(hitPos,meps);\n        vec3 reflectDir = reflect(d,hitNormal);\n        \n        vec3 c = vec3(0);\n        \n        \n        vec3  del1 = LIGHT_1_POS-hitPos;\n        float dis1 = length(del1);\n        vec3  dir1 = del1/dis1;\n        float int1 = dis1*dis1/LIGHT_1_SIZE;\n        c += hitColor*softshadow(hitPos + hitNormal*2.*meps, dir1, int1*0.001, meps, dis1)*LIGHT_1_COLOR;\n        \n        vec3  dif1 = reflectDir-dir1;\n        c += LIGHT_1_COLOR/int1/dot(dif1,dif1);\n        \n        vec3  del2 = LIGHT_2_POS-hitPos;\n        float dis2 = length(del2);\n        vec3  dir2 = del2/dis2;\n        float int2 = dis2*dis2/LIGHT_2_SIZE;\n        c += hitColor*softshadow(hitPos + hitNormal*2.*meps, dir2, int2*0.001, meps, dis2)*LIGHT_2_COLOR;  \n        \n        vec3  dif2 = reflectDir-dir2;\n        c += LIGHT_2_COLOR/int2/dot(dif2,dif2);\n        \n        float occlusion = occlusion(hitPos,hitNormal);\n        c += hitColor*AMBIENT_COLOR*occlusion;\n\n        return c;\n        \n    }else{\n\n        return AMBIENT_COLOR; \n\n    }   \n}\n\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragCoord ){\n    float minResolution = min(iResolution.x,iResolution.y);\n    float eps = DETAIL*ZOOM/minResolution;\n\n    //Seed\n    uvec2 up  = uvec2(fragCoord);\n    uvec2 res = uvec2(iResolution);\n    uint seed =  up.x + res.x*up.y + res.x*res.y*uint(iFrame);\n    \n    //Scaling\n    vec2 sp  = (fragCoord*2.-iResolution.xy)/minResolution*ZOOM;\n   \n    //Final\n    vec3 col = vec3(\n        raymarcher(\n            cameraPosition+sp.x*ZOOM*cameraRight+sp.y*ZOOM*cameraUpward,\n            cameraForward,\n            eps\n        )\n    );\n    \n    // reinhard tone mapping/\n    //col /= col + 1.;\n    \n    // exposure tone mapping\n    col = 1. - exp(-col * EXPOSURE);\n    \n    // gamma correction \n    col = pow(col, vec3(1./GAMMA));\n    \n    fragcolor = vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//constants\n#define PI  3.14159\n#define TAU 6.28318\n\t\n//Render\nconst float DETAIL    = .1;\nconst int   MAX_STEPS = 128;\nconst float MAX_MARCH = 30.;\n\n//Lighting\nconst vec3  AMBIENT_COLOR = vec3(.5,.6,1.);\nconst vec3  LIGHT_1_POS   = vec3(-100,60,101);\nconst vec3  LIGHT_1_COLOR = vec3(1,.8,.8);\nconst float LIGHT_1_SIZE  = 0.2;\nconst vec3  LIGHT_2_POS   = vec3(-100,60,-101);\nconst vec3  LIGHT_2_COLOR = vec3(.8,1,1);\nconst float LIGHT_2_SIZE  = 0.2;\n\n//Camera\nconst float ZOOM          = 1.5;\nconst vec3 cameraPosition = vec3(1,.6,-1)*8.;\nconst vec3 cameraForward  = normalize(vec3(0)-cameraPosition);\nconst vec3 cameraRight    = normalize(cross(vec3(0,1,0),cameraForward));\nconst vec3 cameraUpward   = cross(cameraForward,cameraRight);\n\n//Occlusion\nconst float OCCLUSION_SPREAD    = 0.05;\nconst float OCCLUSION_INTENSITY = .1;\nconst int   OCCLUSION_SAMPLES   = 3;\n\n//Post\nconst float GAMMA    = 1.8;\nconst float EXPOSURE = .8;\n\n//Rings\nconst float RING_WIDTH   = 0.01;\nconst float RING_BREADTH = 0.03;\n\n\n//rotates vector around another\nvec3 rotate(vec3 p, float angle, vec3 v){\n\tfloat c = cos(angle);\n\tvec3 s = sin(angle) * v;\n\tvec3 d =  (1.0 - c) * v;\n    return dot(p,d)*v + p*mat3(c,-s.z,s.y, s.z,c,-s.x, -s.y,s.x,c);\n}","name":"Common","description":"","type":"common"}]}