{"ver":"0.1","info":{"id":"McSBWR","date":"1724789410","viewed":58,"name":"sfw3r23err","username":"minddome","description":"wobble","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["wobble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1 // Set AA to 1 to reduce performance impact\n#endif\n\nfloat hash(vec2 p)  \n{\n    p  = fract( p*0.6180339887 );\n    p *= 25.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = hash(p+vec2(0,0));\n    float b = hash(p+vec2(1,0));\n    float c = hash(p+vec2(0,1));\n    float d = hash(p+vec2(1,1));\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2( fbm4(p+vec2(1.0)), fbm4(p+vec2(6.2)) );\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2( fbm6(p+vec2(9.2)), fbm6(p+vec2(5.7)) );\n}\n\n\nfloat func( vec2 q, out vec2 o, out vec2 n )\n{\n    q += 0.05*sin(vec2(0.11,0.13)*iTime + length( q )*5.0);\n    \n    q *= 0.7 + 0.2*cos(0.05*iTime);\n\n    o = 0.5 + 0.5*fbm4_2( q );\n    \n    o += 0.02*sin(vec2(0.13,0.11)*iTime*length( o ));\n\n    n = fbm6_2( 4.0*o );\n\n    vec2 p = q + 3.0*n + 1.0;\n\n    float f = 0.5 + 0.5*fbm4( 2.0*p );\n\n    f = mix( f, f*f*f*1.0, f*abs(n.x) ); // Reduced intensity of wobble\n\n    f *= 1.0-0.5*pow( 0.5+0.5*sin(8.0*p.x)*sin(8.0*p.y), 8.0 );\n\n    return f;\n}\n\nfloat funcs( in vec2 q )\n{\n    vec2 t1, t2;\n    return func(q,t1,t2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    // Berechnungen ohne AA\n    vec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 o, n;\n    float f = func(q, o, n);\n    \n    // Change color to grayscale\n    vec3 col = vec3(0.4); // Darker base gray color\n    col = mix( col, vec3(0.6), f ); // Dark gray to lighter gray\n    col = mix( col, vec3(0.8), dot(n,n) ); // Add some light gray based on normal\n    col = mix( col, vec3(0.5), 0.5*o.y*o.y ); // Add more gray based on 'o'\n    col = mix( col, vec3(0.4), 0.6*smoothstep(1.2,1.3,abs(n.y)+abs(n.x)) ); // Darker gray\n    col *= f*4.0; // Reduced multiplier to lessen brightness\n\n    vec2 ex = vec2( 1.0 / iResolution.x, 0.0 );\n    vec2 ey = vec2( 0.0, 1.0 / iResolution.y );\n\n    vec3 nor = normalize( vec3( funcs(q+ex) - f, ex.x, funcs(q+ey) - f ) );\n    \n    vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n    vec3 lin  = vec3(0.4)*(nor.y*0.5+0.5); // Further reduced lighting contribution\n    lin += vec3(0.1)*dif; // Slightly darker diffuse component\n\n    col *= lin;\n    col = vec3(1.0)-col;\n    col = col*col;\n    col *= vec3(0.18, 0.18, 0.2); // No color adjustment\n\n    tot = col;\n    \n    vec2 p = fragCoord / iResolution.xy;\n    tot *= 0.5 + 0.5 * sqrt(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}