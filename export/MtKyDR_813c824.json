{"ver":"0.1","info":{"id":"MtKyDR","date":"1535853518","viewed":351,"name":"Noise + Noise raymarching","username":"DeadMan","description":"This is a raymarcher that visualizes a noise function using the sound from a song as an input.\nInspiration: https://www.shadertoy.com/view/4ddXW4","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","music"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DISTANCE 50.0\n#define STEP 0.0\n#define STEPINC 0.00005\n#define SEED 10283.2\n#define PERSISTENCE 1.0\n#define SPEED 3.0\n#define BRIGHTNESS 1.0\n#define SPEC_POW 100.0\n#define SPEC_INTENSITY 10.0\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n\nfloat noise(vec3 x) {\n\tconst vec3 Step = vec3(110, 241, 171);\n\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n \n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \n\t// incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, Step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix( hash(n + dot(Step, vec3(0, 0, 0))), hash(n + dot(Step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(Step, vec3(0, 1, 0))), hash(n + dot(Step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(Step, vec3(0, 0, 1))), hash(n + dot(Step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(Step, vec3(0, 1, 1))), hash(n + dot(Step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat getNoise(vec3 loc){\n    return noise(vec3(loc * PERSISTENCE) + vec3(SEED + texture(iChannel0, (loc.xy * 0.01) - vec2(0.5)) * 10.0)) * (length(loc.xy));\n}\n\nvec3 getNormal(vec3 pos){\n\tvec2 eps = vec2(1.0, 0.0);\n\n\tvec3 nor = vec3(getNoise(pos + eps.xyy) - getNoise(pos - eps.xyy),\n\t\t\tgetNoise(pos + eps.yxy) - getNoise(pos - eps.yxy),\n\t\t\tgetNoise(pos + eps.yyx) - getNoise(pos - eps.yyx));\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord / iResolution.xy;\n    vec2 screenPos = UV * 2.0 - vec2(1.0);\n\tvec3 camLoc = vec3(0, 0, iTime * SPEED);\n    vec3 calcDir = vec3(screenPos.x, screenPos.y * (iResolution.y / iResolution.x), 1.0);\n    \n    Ray mainRay;\n    mainRay.origin = camLoc;\n    mainRay.direction = calcDir;\n    \n    float dist = 0.0;\n    \n    float brightness = 0.0;\n    \n    float stepDist = STEP;\n    vec3 location;\n    \n    for(float t = 0.0; t < DISTANCE; t += stepDist){\n        location = mainRay.origin + (mainRay.direction * t);\n        if(getNoise(location) > 0.99){\n            /*while(getNoise(location) > 0.5){\n                t -= 0.01;\n                location = mainRay.origin + (mainRay.direction * t);\n            }*/\n            dist = t / DISTANCE;\n            vec3 norm = getNormal(location);\n            \n            vec3 dirToCam = normalize(location - camLoc);\n            \n            brightness = clamp(dot(dirToCam, norm), 0.0, 1.0);\n            \n            vec3 refVec = reflect(norm, dirToCam);\n            \n            float spec = pow(clamp(-dot(refVec, dirToCam), 0.0, 1.0), SPEC_POW) * SPEC_INTENSITY;\n            \n            brightness += spec;\n            \n            brightness *= 1.0 / (t);\n            \n            brightness *= BRIGHTNESS;\n            \n            break;\n        }\n        stepDist += STEPINC;\n    }\n    \n    vec3 color = 0.5 + 0.5*cos((iTime*2.0)+location+vec3(0,2,4));\n    \n    // Output to screen\n    //fragColor = vec4(snoise(vec4(UV * PERSISTENCE, 1023.0, 210.4)));\n    fragColor = vec4(brightness * color, 1.0);\n}","name":"Image","description":"","type":"image"}]}