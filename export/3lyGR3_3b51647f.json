{"ver":"0.1","info":{"id":"3lyGR3","date":"1579429130","viewed":85,"name":"explorationDeSD","username":"antoinefortin","description":"fff","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 pos, float angle)\n{\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c) * pos;\n}\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  \n  vec3 q = abs(p) - b;\n  // For Chris Nieven my mentor. \n  q.xy = (rotate(q.xy /5.5, iTime)) / 2.;\n     q.xz *= abs((rotate(q.xz /2.5, iTime)) / 1.);\n\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n\nfloat map(vec3 pos)\n{\n    vec3 q = pos;\n\t\n    // Definir nos geometries\n    vec3 boite = vec3(0.5, 0.5, 0.5);\n    float distanceDeLaBoite = sdRoundBox(q, boite, 0.);\n    float d = distanceDeLaBoite;\n    // Animer nos geometrie \n    \n    // Modifier notre espace\n    \n    // Utiliser un systeme de materiel\n    \n    q.xy=rotate(q.xy + iTime, 2.5);\n    vec3 boxSize = vec3(abs(sin(iTime)) / 5.5);\n\t q.y -= .5;\n      \n\n       \n    //float d = sdRoundBox(q, boxSize, 0.);\n       \n\n    float d2 = pos.y - (-0.25);\n    \n    return min(d, d2);\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 20.0) break;\n        \n    }\n    \n    if(t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\n\tvec3 ro = vec3(0.0,3.5,iTime *-2.);\n    vec3 rd = normalize(vec3(p, -1.5));\n\tvec3 col = vec3(0.0);\n    \n\tfloat t = castRay(ro, rd);\n    \n    \n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        \n       \tvec3 sundir = normalize(vec3(sin(iTime), 0.5, 0.2));\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n    \t\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(5. *abs(sin(iTime)), 1.0, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}