{"ver":"0.1","info":{"id":"XdccRH","date":"1518120202","viewed":85,"name":"Spindle of Death","username":"kMiller","description":"Hw for procedural graphics class","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","gif"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// Union (with material data)\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sphere(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\nfloat torus(vec3 pos, vec2 t)\n{\n    vec2 qos = vec2(length(pos.yz) - t.x, pos.x);\n    return length(qos) - t.y;\n}\n\nmat3 rotMat(float theta) {\n    float s1 = sin(theta);\n    float c1 = cos(theta);\n\treturn mat3(vec3(c1, -s1, 0),\n                    vec3(s1, c1, 0),\n                    vec3(0, 0, 1)); \n}\n\nvec3 rotRing(vec3 p) {\n   float c = cos(radians(22.5));\n   float s = sin(radians(22.5));\n   return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec2 sceneSDF(vec3 pos) {\n    float r = .8;\n    float t = .005;\n     float time = iTime;\n    //float time = gain(fract(iTime), .7);\n\t\n    mat3 rotZ = rotMat(time * 2.0);\n    vec3 p = pos;\n    float t1 = torus(p, vec2(r, t));\n    vec3 bp = rotZ * p;\n    bp.y -= r;\n    float b1 = sphere(bp, .06);\n    \n    \n    p = rotRing(p);\n    float t2 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .1);\n   \tbp = rotZ * p;\n    bp.y -= r;\n    float b2 = sphere(bp, .06);\n    float ball = min(b1, b2);\n    float sdf = min(t1, t2);\n    \n    p = rotRing(p);\n    float t3 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .2);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b3 = sphere(bp, .06);\n    ball = min(ball, b3);\n    sdf = min(sdf, t3);\n    \n    p = rotRing(p);\n    float t4 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .3);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b4 = sphere(bp, .06);\n    ball = min(ball, b4);\n    sdf = min(sdf, t4);\n    \n    p = rotRing(p);\n    float t5 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .4);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b5 = sphere(bp, .06);\n    ball = min(ball, b5);\n    sdf = min(sdf, t5);\n    \n    p = rotRing(p);\n    float t6 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .5);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b6 = sphere(bp, .06);\n    ball = min(ball, b6);\n    sdf = min(sdf, t6);\n    \n    p = rotRing(p);\n    float t7 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .6);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b7 = sphere(bp, .06);\n    ball = min(ball, b7);\n    sdf = min(sdf, t7);\n    \n    p = rotRing(p);\n    float t8 = torus(p, vec2(r, t));\n    rotZ = rotMat(time * 2.0 + .7);\n    bp = rotZ * p;\n    bp.y -= r;\n    float b8 = sphere(bp, .06);\n    ball = min(ball, b8);\n    sdf = min(sdf, t8);\n    \n    //return vec2(sdf, 0);\n    \n\tvec2 rings = vec2(sdf, 0);\n\n    return opU(rings, vec2(ball, 1.0));\n}\n\n\nvec2 raymarch(in vec3 origin, in vec3 dir)\n{\n    vec2 dist = vec2(10000000.0, 0.0);\n    float dt = 0.01;\n    float t = 0.01;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        dist = sceneSDF(origin + t * dir);\n\n        if(dist.x < 0.001)\n        {\n            return vec2(t, dist.y);\n        }\n        else if (t >100.0)\n        {\n            break;\n        }\n        \n        t += dist.x;\n    }\n    return vec2(-1, 0);\n}\n\nvec3 rayCast(vec2 pixel, vec3 origin)\n{ \n    vec3 ref = vec3(0.0, 0.0, 0.0);\n    vec3 camLook = normalize(ref - origin);\n    vec3 camRight = normalize( cross(camLook, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = ref + pixel.x * camRight + pixel.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    //ndc coordinates\n    vec2 scrPt = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float pi = 3.1415;\n    float timeInt = mod(iTime * .5, 8.0);\n    float c = cos(timeInt * .5);\n    float s = sin(timeInt * .5);\n\n    mat3 rotX = mat3(vec3(c, 0, -s),\n                    vec3(s, 0, c),\n                    vec3(0, 0, 1)); \n    vec3 cameraPos;\n    if(timeInt <= 1.0) {\n        cameraPos = vec3(0, 0, 4);\n    } else if(timeInt <= 2.0) {\n        cameraPos = mix(vec3(0, 0, 4), vec3(0, 4, 0), mod(timeInt,1.0));\n    } else if(timeInt <= 3.0) {\n        cameraPos = vec3(0, 4, 0.01);\n    } else if(timeInt <= 4.0) {\n        cameraPos = mix(vec3(0, 4, 0.01), vec3(0, 0, -4), mod(timeInt,1.0));\n    } else if(timeInt <= 5.0) {\n        cameraPos = vec3(0, 0, -4);\n    } else if(timeInt <= 6.0) {\n        cameraPos = mix(vec3(0, 0, -4), vec3(0, -4, 0.01), mod(timeInt,1.0));\n    } else if(timeInt <= 7.0) {\n        cameraPos = vec3(0, -4, 0.01);\n    } else {\n        cameraPos = mix(vec3(0, -4, 0.01), vec3(0, 0, 4), mod(timeInt,1.0));\n    }\n    //vec3 cameraPos = vec3(0, 0, 4);\n    vec3 rayDir = rayCast(scrPt, cameraPos);\n\tvec2 object = raymarch(cameraPos, rayDir);\n    \n    if (object.x > 0.0) // hit\n    {\n        if(object.y == 0.0) {\n\t\t\tfragColor = vec4(0, 0, 0, 1);\n        } else {\n            fragColor = vec4(1);\n        }\n    }\n    else // miss\n    {\n        fragColor = vec4(.5, .5, .5, 1.0);\n    }\n\n}","name":"Image","description":"","type":"image"}]}