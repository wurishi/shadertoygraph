{"ver":"0.1","info":{"id":"sdXGDN","date":"1615947195","viewed":93,"name":"Fractal spheres","username":"sfavaron","description":"Fractal spheres","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spheres","fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//map function, core of all the ray marching shaders. They return a scalar value, given a 3D point.\nfloat map(vec3 p) {\n    // you transform the space so it's a repeating coordinate system\n    p = fract(p) * 2. - 1.;\n  \t\n    //sphere map function is the length of the point minus the radius\n    //it's negative on the inside of the sphere and positive on the outside and 0 on the surface.\n    float r = 0.25; //(sin(iTime*2.)+1.)/8. + 0.01;\n    return length(p) - r;\n}\n\n//we use a numerical marching algorithim called trace\n//o = origin\n//r = ray to march along\n//t = intersection along the ray\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for(int i=0; i < 32; i++) {\n        //origin + ray*t = where we are along the ray;\n        // we step along the ray in variable length segments, \n        //until we gradual converge on the intersection and evaluate the map function at that point\n        float d = map(o+r*t);\n        if(d>15.) break; // Near and far break;\n        //we add that to t\n        // the smaller the 0.5 value, the less accurate the map function is\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //transform the cordinates to -1 to 1, instead of 0 to 1\n    uv = uv * 2.0 - 1.0;\n    //correct the aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //r = ray\n    // it needs to be normalized so it doesn't poke through the geometry when it's really close to the camera\n    //the z cordinate is 1.0, that's how you project the 2D coordinate into 3D space, \n    //you just decide the z value, which determines the field of view of the camera\n    // smaller z = higher fov. 1.0 = 90 degrees\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    //rotation around the y axis\n    //you have to look up on wikipedia what this is\n    float the= iTime*0.5;\n    //r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    //r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    //r.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n    // the sphere is at (0.0,0.0,0.0)\n    vec3 o = vec3(0., 0., iTime);\n    \n    //trace from the origin along the ray to find the intersection from our map function\n    float t = trace(o, r);\n    \n    // simple fogging funcition to darken things the further away they are\n    float fog = 1.0 / (1. + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n    fragColor = vec4(fc, 1.0);\n}","name":"Image","description":"","type":"image"}]}