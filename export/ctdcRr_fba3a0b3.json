{"ver":"0.1","info":{"id":"ctdcRr","date":"1698838237","viewed":10,"name":"Image_synthese","username":"mendo","description":"Image","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["image"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\n\nstruct Box{\n    vec3 p;\n    vec3 size;\n    Plane f1, f2, f3, f4, f5, f6;\n};\n\nstruct Elipsoid{\n    vec3 center;\n    vec3 size;\n    int i;\n};\n\n\nstruct Cylinder{\n    vec3 a, b;\n    Plane f1, f2;\n    float r;\n    int i;\n};\n\n\nstruct Capsule{\n    Cylinder c;\n    Sphere s1, s2;\n    int i;\n};\n\nstruct Tore{\n    vec3 p;\n    float r, R;\n    int i;\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 a; //Ambiant\n    vec3 d;// Diffuse\n    vec3 s; //Specular\n    float t; // opacity between [0, 1]\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\nint checker3D(vec3 p, float sideSize){\n    return ((int(p.x) + int(p.y) + int(p.z)) * int(sideSize)) % 2;\n}\n\nfloat axial(vec3 p){\n    float r = sqrt(pow(p.x, 2.) + pow(p.y, 2.));\n    return 0.5 + 0.5 * cos(3.141592 * r);\n}\n\nfloat dist(vec3 p1, vec3 p2){\n    return sqrt(pow(p1.x-p2.x, 2.) + pow(p1.y-p2.y, 2.) + pow(p1.z-p2.z, 2.));\n}\n\nfloat wave(vec3 p) {  \n    float t = cos(p.x + iTime*1.5);\n    float t2 = cos(p.y);\n    \n    float t3 = sin(p.x * 2.);\n    float t4 = sin(p.y);\n\n    return cos(t + t2 + t3);\n}\n\nfloat turbulence(vec3 p){\n\n   return cos(p.x*2. + p.y*5. + p.z*2.)\n   + sin(p.x + p.y + p.z*2.) * 8.;\n}\n\nvec3 wood(vec3 p){\n    \n    vec3 brown = vec3(0.58, 0.27, 0.12);\n    vec3 brown2 = vec3(0.30, 0.12, 0.05);\n\n    float d = dist(p, vec3(0., 0., 0.)) * 8.;\n    float t = turbulence(p);\n    float r = cos(d + t);\n     \n    return abs(r) * brown + (1. - abs(r)) * brown2;\n}\n\n\n// Compute point on ray\nvec3 Point(Ray ray, float t)\n{\n    return ray.o + t * ray.d;\n}\n\nbool Intersect(Ray ray, out Hit x);\nvec3 Rotate(vec3 n, float angle, int axe);\n\n// Compute color\n// i : Texture index\nMaterial Texture(vec3 intersection, vec3 d, vec3 n, int i) {\n\n    if(i == 0){ // color1\n        float f = Checkers(.5 * intersection.xy);\n        vec3 col = vec3(.4,.5,.7) + f * vec3(.1);\n        return Material(col, vec3(1.,1.,1.), vec3(1.,1.,1.), 1.);\n    }\n    else if(i == 1) { // color 2\n        return Material(vec3(0.,0.,1.), vec3(1.,1.,1.), vec3(.3,.3,.3), 1.);\n    }\n    // 2 = miror\n    else if(i == 3){ // damier\n        int checker = checker3D(intersection, 1.);\n        return Material(vec3(checker, checker, checker), vec3(1.,1.,1.), vec3(1.,1.,1.), 1.);\n    }\n    else if(i == 4){ // radiale\n        float axial = axial(intersection);\n        return Material(\n        mix(vec3(1., 1., 0.), vec3(1., 0., 1.), axial), \n        vec3(1.,1.,1.), vec3(1.,1.,1.), 1.);\n    }\n    else if(i == 5){ // bois\n        return Material(wood(intersection), vec3(1.,1.,1.), vec3(.5,.5,.5), 1.);\n    }\n    else if(i == 6){ // water\n        return Material(\n        vec3(0, 0.23, 0.38) + vec3(0.01, 0.41, 0.59) * wave(intersection), vec3(1.,1.,1.), vec3(0.,0.,0.), 1.);\n    }\n    else if(i == 7) { //transparent\n        return Material(vec3(0.,1.,1.), vec3(1.,1.,1.), vec3(.3,.3,.3), 0.5);\n        \n    }else if(i == 8) { //transparent with refraction\n        return Material(vec3(1.,0.,0.), vec3(1.,1.,1.), vec3(.3,.3,.3), 0.5);\n    }\n}\n\n\nvec3 Background()\n{\n    return vec3(0.53, 0.71, 0.9);\n}\n\n// for mirors, transparency and transparency with refraction\nMaterial TextureWithReflection(out Ray ray, out Hit current){\n\n  int nbReflection = 3;\n  Material result;\n  Material firstHit;\n\n  for(int i = 0; i < nbReflection; i++){\n  \n        current = Hit(1000., vec3(0), -1);\n          \n        if(Intersect(ray, current)){\n            \n            if(current.i == 2){ // miror\n                vec3 reflectedRay = normalize(ray.d - (2. * dot(current.n, ray.d) * current.n));\n                ray = Ray(Point(ray, current.t) + 0.01 * current.n, reflectedRay);\n            }\n            else{\n                vec3 tempAmbiant = result.a;\n                float tempTransparency = result.t;\n                vec3 tempA = result.a;\n                result = Texture(Point(ray, current.t), ray.d, current.n, current.i);\n                \n                if(result.t < 1.){\n                    result.a = mix(result.a, tempA, 0.5); \n                }\n\n                \n                if(result.t < 1.){ // transparent object\n                \n                    ray = Ray(Point(ray, current.t) - 0.01 * current.n, ray.d);\n                    nbReflection++;\n                    \n                    if(current.i == 8){\n                        //refraction\n                        float indice = 1.2;\n                        ray.d = normalize(current.n*(indice - 1.) + ray.d);\n                    }\n\n                }else{ // non transparent object\n                    result.a = mix(result.a, tempAmbiant, tempTransparency);\n                    return result;\n                }\n            }\n        }\n    }\n}\n\nbool isPointInBoxBounds(vec3 p, Box b){\n\n    if(((p.x >= b.p.x -b.size.x -0.01)  && (p.x <= b.p.x + b.size.x + 0.01))\n    && ((p.y >= b.p.y -b.size.y -0.01) && (p.y <= b.p.y + b.size.y + 0.01))\n    && ((p.z >= b.p.z -b.size.z -0.01) && (p.z <= b.p.z + b.size.z + 0.01))){\n    \n        return true;\n    }\n    return false;\n}\n\n\nBox buildBox(vec3 p, vec3 size, int texture) {\n    Box b;\n    b.p = p;\n    b.size = size;\n    b.f1 = Plane(vec3(0.,1.,0.), vec3(p.x,p.y+size.y,p.z), texture);\n    b.f2 = Plane(vec3(0.,-1.,0.), vec3(p.x,p.y-size.y,p.z), texture);\n    b.f3 = Plane(vec3(1.,0.,0.), vec3(p.x+size.x,p.y,p.z), texture);\n    b.f4 = Plane(vec3(-1.,0.,0.), vec3(p.x-size.x,p.y,p.z), texture);\n    b.f5 = Plane(vec3(0.,0.,1.), vec3(p.x,p.y,p.z+size.z), texture);\n    b.f6 = Plane(vec3(0.,0.,-1.), vec3(p.x,p.y,p.z-size.z), texture);\n    return b;\n}\n\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray, Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p = Point(ray,t);\n            x = Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x)\n{\n    float t = -dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t > 0.)\n    {\n        x = Hit(t, pl.n ,pl.i);\n        return true;\n    }\n    return false;\n}\n\n\nbool intersectBox(Ray ray, Box b, out Hit x){\n\n    Plane faces[6] = Plane[6](b.f1, b.f2, b.f3, b.f4, b.f5, b.f6);\n    bool result = false;\n    Hit current;\n    float closestPoint = 1000.;\n    int closestPointMaterial;\n    bool ret = false;\n    \n    for(int i = 0; i < 6; i++){\n        if(IntersectPlane(ray, faces[i], current)){\n        \n            vec3 p = Point(ray, current.t);\n            if (isPointInBoxBounds(p, b)){\n                if (current.t < closestPoint){\n\n                    closestPoint = current.t;\n                    closestPointMaterial = current.i;\n                    x = current;\n                    ret = true;\n                }\n            }\n        }\n    }\n    x.t = closestPoint;\n    x.i = closestPointMaterial;\n    return ret;\n}\n\n\nbool intersectElipsoid(Ray ray, Elipsoid e, out Hit x)\n{\n    float a = (pow(ray.d.x, 2.) / pow(e.size.x, 2.))\n                + (pow(ray.d.y, 2.) / pow(e.size.y, 2.))\n                + (pow(ray.d.z, 2.) / pow(e.size.z, 2.));\n\n    float b = (2. * (ray.o.x + e.center.x) * ray.d.x) / (pow(e.size.x, 2.))\n                + (2. * (ray.o.y + e.center.y) * ray.d.y) / (pow(e.size.y, 2.))\n                + (2. * (ray.o.z + e.center.z) * ray.d.z) / (pow(e.size.z, 2.));\n                \n    float c = (pow(ray.o.x + e.center.x, 2.)) / (pow(e.size.x, 2.))\n                + (pow(ray.o.y + e.center.y, 2.)) / (pow(e.size.y, 2.))\n                + (pow(ray.o.z + e.center.z, 2.)) / (pow(e.size.z, 2.))\n                -1.;\n                \n    float delta = pow(b, 2.) - 4. * a * c;\n    \n    if (delta > 0.){\n    \n        float t = (-b -sqrt(delta)) / (2. * a) ;\n        if(t>0.)\n        {\n            ray.o += e.center;\n            vec3 p = Point(ray,t);\n            vec3 normal = normalize(2. * vec3(p.x / pow(e.size.x, 2.), p.y / pow(e.size.y, 2.), p.z / pow(e.size.z, 2.)));\n            x = Hit(t, normal, e.i);\n            \n            return true;\n        }\n    }\n    \n    \n    return false;\n}\n\nbool intersectOpenCylinder(Ray ray, Cylinder c, out Hit x){\n\n    vec3 h = normalize(c.a - c.b);\n    vec3 w = ray.o - c.a;\n    \n    float a = dot(ray.d, ray.d) - pow(dot(ray.d, h), 2.) ;\n    float b = 2. * (dot(ray.d, w) - dot(ray.d, h) * dot(w, h));\n    float c1 = dot(w, w) - pow(dot(w, h), 2.) - pow(c.r, 2.);\n    \n    float delta = pow(b, 2.) - (4. * a * c1);\n    \n    if (delta > 0.){\n        float t = (-b - sqrt(delta)) / (2. * a);\n        \n        if (t > 0.){\n            vec3 p = Point(ray, t);\n            float ap = length(c.a - p);\n            float bp = length(c.b - p);\n            float h1 = sqrt(pow(ap, 2.) - pow(c.r, 2.));\n            float h2 = sqrt(pow(bp, 2.) - pow(c.r, 2.));\n            \n            if (h1 <= length(c.a - c.b) && h2 <= length(c.b - c.a)){\n            \n                vec3 temp = c.a + (c.b-c.a)*(h1 / length(c.b-c.a));\n                x = Hit(t, normalize(p - temp), c.i);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool intersectClosedCylinder(Ray ray, Cylinder c, out Hit closestHit){\n    \n    Hit hits[3] = Hit[3](Hit(1000., vec3(0), -1),\n                         Hit(1000., vec3(0), -1),\n                         Hit(1000., vec3(0), -1));\n    \n    intersectOpenCylinder(ray, c, hits[0]);\n    IntersectPlane(ray, c.f1, hits[1]);\n    IntersectPlane(ray, c.f2, hits[2]);\n    \n    bool res = false;\n    \n    if(hits[0].t > 0. && hits[0].t < closestHit.t){\n        closestHit = hits[0];\n        res = true;\n    }\n    if(hits[1].t > 0. && hits[1].t < closestHit.t){\n        if(dist(Point(ray, hits[1].t), c.f1.p) <= c.r){\n           closestHit = hits[1];\n           res = true;\n        }\n    }\n    if(hits[2].t > 0. && hits[2].t < closestHit.t){\n        if(dist(Point(ray, hits[2].t), c.f2.p) <= c.r){\n           closestHit = hits[2];\n           res = true;\n        }\n    }\n    return res;\n}\n\n\nbool intersectCapsule(Ray ray, Capsule c, out Hit x){\n\n    Hit hits[3] = Hit[3](Hit(1000., vec3(0), -1),\n                         Hit(1000., vec3(0), -1),\n                         Hit(1000., vec3(0), -1));\n    \n    intersectOpenCylinder(ray, c.c, hits[0]);\n    IntersectSphere(ray, c.s1, hits[1]);\n    IntersectSphere(ray, c.s2, hits[2]);\n    \n    Hit closestHit = Hit(1000., vec3(0), -1);\n    bool res = false;\n    \n    \n    for(int i = 0; i < 3; i++){\n        if(hits[i].t > 0. && hits[i].t < closestHit.t){\n        \n            closestHit = hits[i];\n            res = true;\n        }\n    }\n    \n    x = closestHit;\n    return res;\n}\n\nfloat solve3emeDegre(float a, float b, float c, float d){\n\n    //première étape\n    b/=a; c/=a; d/=a;\n    \n    //(y+x)^3 + b*(y+x)^2 + c*(y+x) + d\n    float x = -b/3.;\n    float nbY = 3.*pow(x, 2.) + (b*2.*x) + c;\n    float reste = pow(x, 3.) + b*pow(x, 2.) + (c*x) + d;\n    \n    float p = -nbY;\n    float q = -reste;\n    \n    float solution = pow(q/2. + sqrt(pow(q/2., 2.) - pow(p/3., 3.)), 1./3.)\n    + pow(q/2. - sqrt(pow(q/2., 2.) - pow(p/3., 3.)), 1./3.);\n     \n    solution += x;\n    return solution;\n}\n\n\n\nbool solve4emeDegre(float a, float b, float c, float d, float e, out vec4 racines){\n    b/= a; c/= a; d/=a; e/=a;\n    \n    // debut resolution 4 eme degre, simplification\n    float x = -b/4.;\n    \n    float nbY2 = 6. * pow(x, 2.) + b*3.*x + c;\n    float nbY = 4. * pow(x, 3.) + b*3.*pow(x, 2.) + 2.*x*c + d;\n    float reste = pow(x, 4.) + b*pow(x, 3.) + c*pow(x, 2.) + d*x + e;\n    //y^4 + nbY2*y^2 + q*y + r\n    \n    float p = nbY2;\n    float q = nbY;\n    float r = reste;\n    \n    // resolution 3eme degre apres simplification\n    //8t^3 - 4pt^2 - 8rt + (4pr - q^2) = 0\n    float solution = solve3emeDegre(8., -4.*p, -8.*r, (4.*p*r) - pow(q, 2.));\n     \n    //y^4 = (y^2 + solution)^2 - 2*solution*y^2 - solution^2\n    float nbY2_2 = -2.*solution;\n    float reste2 = -pow(solution, 2.);\n    \n    //y^4 + nbY2*y^2 + q*y + r\n    float nbY2_final = -nbY2_2 -p;\n    float nbY_final = -q;\n    float reste_final = -reste2 -r;\n    \n    //(y^2 + solution)^2 = nbY2_final + nbY_final + reste_final\n    //identité rematquable\n    float racineCarre = sqrt(nbY2_final); // a\n    float racineCarre2 = sqrt(reste_final); //* (nbY_final/abs(nbY_final)); // b\n    \n    //maintenant: (y^2 + solution)^2 = (racineCarre + racineCarre2)^2\n    //donc: y^2 + solution = racineCarre + racineCarre2\n    //on a donc deux equations de degre 2:\n    // y^2 -racineCarre*y + solution - racineCarre2\n    // et y^2 + racineCarre*y + solution + racineCarre2\n    \n    float racineEquation1 = -racineCarre;\n    float racineEquation2 = racineCarre;\n    \n    float delta1 = pow(racineEquation1, 2.) - 4.*(solution - racineCarre2);\n    float delta2 = pow(racineEquation2, 2.) - 4.*(solution + racineCarre2);\n\n    racines = vec4(-1., -1., -1., -1.);\n    \n    if(delta1 == 0.){\n        racines.x = (-racineEquation1) / 2.;\n        racines.x += x;\n        \n        if(delta2 == 0.){\n            racines.y = (-racineEquation2) / 2.;\n            racines.y += x;\n            \n        }else if(delta2 > 0.){\n            racines.y = (-racineEquation2 + sqrt(delta2)) / 2.;\n            racines.z = (-racineEquation2 - sqrt(delta2)) / 2.;\n            racines.y += x;\n            racines.z += x;\n        }\n    }else if(delta1 > 0.){\n        racines.x = (-racineEquation1 + sqrt(delta1)) / 2.;\n        racines.y = (-racineEquation1 - sqrt(delta1)) / 2.;\n        racines.x += x;\n        racines.y += x;\n    \n        if(delta2 == 0.){\n            racines.z = (-racineEquation2) / 2.;\n            racines.z += x;\n\n        }else if(delta2 > 0.){\n            racines.z = (-racineEquation2 + sqrt(delta2)) / 2.;\n            racines.w = (-racineEquation2 - sqrt(delta2)) / 2.;\n            racines.z += x;\n            racines.w += x;\n        }  \n    }else if(delta1 < 0.){\n        if(delta2 == 0.){\n            racines.x = (-racineEquation2) / 2.;\n            racines.x += x;\n\n        }else if(delta2 > 0.){\n            racines.x = (-racineEquation2 + sqrt(delta2)) / 2.;\n            racines.y = (-racineEquation2 - sqrt(delta2)) / 2.;\n            racines.x += x;\n            racines.y += x;\n        }  \n    }\n\n    if(delta1 >= 0. || delta2 >= 0.){\n        return true;\n    }\n    return false;\n}\n\n\nbool intersectTore(Ray r, Tore t, out Hit current){\n\n    float rox = pow(r.o.x + t.p.x, 2.);\n    float roy = pow(r.o.y + t.p.y, 2.);\n    float roz = pow(r.o.z + t.p.z, 2.);\n    \n    float rdx = pow(r.d.x, 2.);\n    float rdy = pow(r.d.y, 2.);\n    float rdz = pow(r.d.z, 2.);\n\n    float a = pow(rdx + rdy + rdz, 2.);\n    float b = 4. * (rdx + rdy + rdz) * (r.d.x*(r.o.x + t.p.x) + r.d.y*(r.o.y + t.p.y) + r.d.z*(r.o.z + t.p.z));\n    float c = 2.*(rdx + rdy + rdz) * (rox + roy + roz + pow(t.R, 2.) - pow(t.r, 2.))\n    + 4.*pow(r.d.x*(r.o.x + t.p.x) + r.d.y*(r.o.y + t.p.y) + r.d.z*(r.o.z + t.p.z), 2.) -(4.*pow(t.R, 2.) * (rdx + rdz));\n    \n    float d = 4. * (r.d.x*(r.o.x + t.p.x) + r.d.y*(r.o.y + t.p.y) + r.d.z*(r.o.z + t.p.z))\n    * (rox+roy+roz + pow(t.R, 2.) - pow(t.r, 2.))\n    - (8.* pow(t.R, 2.) * (r.d.x*(r.o.x + t.p.x) + r.d.z*(r.o.z + t.p.z)));\n    \n    float e = pow(rox + roy + roz + pow(t.R, 2.) - pow(t.r, 2.), 2.)\n    - (4.* pow(t.R, 2.) * (rox + roz));\n    \n    vec4 racines;\n    bool isThereRoots = solve4emeDegre(a, b, c, d, e, racines);\n    \n    float minimum = 1000.;\n    \n    if(racines.x > 0. && racines.x < minimum){\n        minimum = racines.x;\n        \n    }if(racines.y > 0. && racines.y < minimum){\n        minimum = racines.y;\n        \n    }if(racines.z > 0. && racines.z < minimum){\n        minimum = racines.z;\n    }\n    if(racines.w > 0. && racines.w < minimum){\n        minimum = racines.w;\n    }\n    \n    // normale\n    r.o += t.p;\n    vec3 p = Point(r, minimum);\n    float temp = pow(p.x, 2.) + pow(p.y, 2.) + pow(p.z, 2.)\n    + pow(t.R, 2.) - pow(t.r, 2.);\n    float dfdx = 4.*p.x*temp - 8.*pow(t.R, 2.)*p.x;\n    float dfdy = 4.*p.y * temp;\n    float dfdz = 4.*p.z*temp -8.*pow(t.R, 2.) * p.z;\n    \n    \n    current.t = minimum;\n    current.n = normalize(vec3(dfdx, dfdy, dfdz));\n    current.i = t.i;\n    \n    if(isThereRoots){\n        return true;\n    }\n    return false;\n}\n\n\nvec3 Rotate(vec3 n, float angle, int axe){\n    \n    float cosTeta = cos(angle);\n    float sinTeta = sin(angle);\n    \n    vec3 res = n;\n    if (axe == 0){ // around x axes\n        res.y = cosTeta * n.y -sinTeta * n.z;\n        res.z = sinTeta * n.y + cosTeta * n.z;\n    }\n    else if (axe == 1){ // around y axes\n        res.x = cosTeta * n.x -sinTeta * n.z;\n        res.z = sinTeta * n.x + cosTeta * n.z;\n    }\n    else if (axe == 2){ // around z axes\n        res.x = cosTeta * n.x -sinTeta * n.y;\n        res.y = sinTeta * n.x + cosTeta * n.y;\n    }\n    return normalize(res);\n}\n\nvec3 Homothetie(vec3 n, vec3 scale){\n    return n *= scale; \n}\n\nvoid Translation(out vec3 n, vec3 t){\n    n += t;\n}\n\nvoid HomothetieBox(out Box b, vec3 scale){\n    b.size = Homothetie(b.size, scale);\n\n    b.f1.p = b.p + (abs(b.f1.p - b.p) * scale.y);\n    b.f2.p = b.p - (abs(b.f2.p - b.p) * scale.y);\n    b.f3.p = b.p + (abs(b.f3.p - b.p) * scale.x);\n    b.f4.p = b.p - (abs(b.f4.p - b.p) * scale.x);\n    b.f5.p = b.p + (abs(b.f5.p - b.p) * scale.z);\n    b.f6.p = b.p - (abs(b.f6.p - b.p) * scale.z);\n}\n\n\n// Scene intersection\n// ray : The ray\n// x : Returned intersection information\nbool Intersect(Ray ray, out Hit x){\n\n    // Spheres\n    Sphere sph1 = Sphere(vec3(0., 5., 1.), 1., 2);\n    Sphere sph2 = Sphere(vec3(1., 1., 1.1), 1., 8);\n    Sphere sph3 = Sphere(vec3(2.5, 4., 1.), 1., 2);\n    Sphere sph4 = Sphere(vec3(1., -3., 3.), 1., 7);\n\n    \n    \n    Elipsoid e = Elipsoid(vec3(3., -3., -2.), vec3(2, 3, 2), 3);\n    Box b = buildBox(vec3(1, -4, 1), vec3(1, 2, 1), 1);\n    HomothetieBox(b, vec3(1, abs(cos(iTime)), abs(sin(iTime))));\n    \n    // rotating plane if we want\n    vec3 n = Rotate(vec3(0., 0., 1.), 0., 0);\n    Plane pl = Plane(n, vec3(0.,0.,0.), 4);\n               \n    Cylinder c = Cylinder(vec3(-2., -2., 1.), vec3(-2., -2., 3.),\n                    Plane(vec3(0., 0., -1.), vec3(-2., -2., 1.), 5),\n                    Plane(vec3(0., 0., 1.), vec3(-2., -2., 3.), 5), \n                    1., 5);\n                       \n    Capsule cap = Capsule(\n                  Cylinder(vec3(5., 0., 1.5), vec3(5., 0., 2.5), \n                  Plane(vec3(0., 0., -1.), vec3(5., 0., 2.), 5),\n                  Plane(vec3(0., 0., 1.), vec3(5., 0., 3.), 5), \n                  1., 5),\n                  Sphere(vec3(5., 0., 1.5), 1., 5),\n                  Sphere(vec3(5., 0., 2.5), 1., 5),\n                  5);\n    \n    Tore t = Tore(vec3(-5, -5, -2), 0.5, 1., 1);\n    \n    \n    x = Hit(1000., vec3(0), -1);\n    Hit current;\n    bool ret = false;\n    \n    if(IntersectSphere(ray,sph1,current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(IntersectSphere(ray,sph2,current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(IntersectSphere(ray,sph3,current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(IntersectSphere(ray,sph4,current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(IntersectPlane(ray,pl,current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(intersectElipsoid(ray, e, current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(intersectBox(ray, b, current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(intersectClosedCylinder(ray, c, current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(intersectCapsule(ray, cap, current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    if(intersectTore(ray, t, current) && current.t < x.t){\n        x = current;\n        ret = true;\n    }\n    return ret;\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n\n// Hemisphere direction\nvec3 Hemisphere(int seed, vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n   \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n\n    return d;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// N : Number of samples\nfloat AmbientOcclusion(vec3 p, vec3 n, int N, float radius)\n{\n    float result = 0.;\n    Hit hit = Hit(1000., vec3(0), -1);\n    \n    for(int i = 0; i < N; i++)\n    {\n        vec3 d = Hemisphere (i,n); // d dans la demi-sphere\n        Ray ray = Ray(p, d);\n        \n        if(Intersect(ray, hit)){\n            \n            if(hit.t > 0. && hit.t < radius){\n                result += 1.;\n            }\n        }\n    }\n    \n    return result / float(N);\n}\n        \n//TODO dire si la lumiere est globale pour utiliser les lumieres ponctuelles\nvec3 Phong(Material m, vec3 light, bool isGlobalLight, vec3 n, vec3 v, vec3 p){\n\n   float ka = 1.;\n   float kd = 1.;\n   float ks = 1.;\n   float shininess = 10.;\n   \n   if(isGlobalLight){\n       light = -light;\n   }else{\n       light = -normalize(light - p);\n   }\n\n   vec3 baseColor = vec3(0., 0., 0.);\n   vec3 a = m.a;\n   vec3 d = m.d * max(dot(n, light), 0.);\n   vec3 r = (2. * dot(n, light) * n) - light; // rayon réfléchi\n   vec3 s = m.s * pow(max(dot(r, v), 0.), shininess);\n   \n   float angleLightNormal = dot(normalize(n), -light);\n   \n   if(angleLightNormal >= 0. && angleLightNormal <= 1.){\n       baseColor += (a*ka + d*kd + s*ks) * angleLightNormal;\n   }\n   return baseColor;\n}\n\n// p : intersection\nfloat GlobalLightShadow(vec3 p, vec3 globalLight){\n    \n    Hit current = Hit(1000., vec3(0), -1);\n    if(Intersect(Ray(p, globalLight), current)){\n        return 0.;\n    }\n    return 1.;\n}\n\n\n// p : intersection\n// n : normal\n// v : rayon depuis la camera\nvec3 PonctualLightsWithShadow(vec3 p, vec3 n, vec3 v, Material m){\n\n    const float nbLights = 2.;\n    vec3[2] lights = vec3[2](\n        vec3(0., 0., 10.),\n        vec3(1., 8., 10.)\n    );\n    \n    // intersections with lights for shadows\n    float cptIntersection = 0.;\n    vec3 finalColor = vec3(0);\n    \n    for(int i = 0; i < int(nbLights); i++){\n    \n        vec3 pToLight = lights[i] - p;\n        Ray ray = Ray(p, normalize(pToLight));\n        Hit tempHit = Hit(1000., vec3(0), -1);\n        finalColor += Phong(m, lights[i], false, n, v, p);\n    \n        if((Intersect(ray, tempHit)\n           && tempHit.t > 0.\n           && tempHit.t < length(pToLight))){\n        \n            cptIntersection++;\n        } \n    }\n    float coefShadow = (1. - (cptIntersection / nbLights)) \n    / (length(lights[0]-p) * 0.1);\n    \n    \n    return finalColor * coefShadow;\n}\n\n// Apply color model\n// m : Material\n// n : normal\n// p : intersection\n// v : ray from camera\nvec3 Color(Material m, vec3 n, vec3 p, vec3 v)\n{\n    p += 0.01 * n;\n    vec3 globalLight = normalize(vec3(1., 1., 1.));\n    \n    // pontual lights color and shadow\n    vec3 colorPonctualLights = PonctualLightsWithShadow(p, n, v, m);\n    //globalLightColor\n    //vec3 colGlobal = Phong(m, globalLight, true, n, v, p);\n    //shadow global light\n    //float coefGlobalShadow = GlobalLightShadow(p, globalLight);\n    \n    vec3 finalCol = colorPonctualLights; // ponctual lights\n    //finalCol += colGlobal * coefGlobalShadow;\n    finalCol = finalCol - (finalCol * AmbientOcclusion(p, n, 50, 1.));\n    return finalCol;\n}\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    Hit current = Hit(1000., vec3(0), -1);\n    Material mat = TextureWithReflection(ray, current);\n    return Color(mat, current.n, Point(ray, current.t), ray.d);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv = (-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    //  Mouse control\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro = 12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta = vec3(0.,0.,1.5);\n    mat3 ca = setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd = ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col = Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}