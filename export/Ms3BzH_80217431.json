{"ver":"0.1","info":{"id":"Ms3BzH","date":"1524084311","viewed":144,"name":"Tentacle Tunnel","username":"ChloeSnyder","description":"OwO what's this","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["m"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\n// RAY MARCHING CODE SOURCE JAMIE WONG\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\nconst float EPSILON_NORM = .001;\n\nconst vec3 A = vec3(-3.142, -3.142, .618);\nconst vec3 B = vec3(-3.142, -3.142,-.362);\nconst vec3 C = vec3(-3.142, -3.142, 2.0);\nconst vec3 D = vec3(-3.142, -3.142, -3.142);\n\nvec3 K_d = vec3(-1, -1, -1); // diffuse color\nfloat shininess;\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\n\nfloat noise2(vec3 x)\n{\n        return fract(sin(dot(x.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\n\n\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nvec4 FAST32_hash_3D_Cell( vec3 gridcell )\t//\tgenerates 4 different random numbers for the single given cell point\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec4 SOMELARGEFLOATS = vec4( 635.298681, 682.357502, 668.926525, 588.255119 );\n    const vec4 ZINC = vec4( 48.500388, 65.294118, 63.934599, 63.279683 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell - floor(gridcell * ( 1.0 / DOMAIN )) * DOMAIN;\n    gridcell.xy += OFFSET.xy;\n    gridcell.xy *= gridcell.xy;\n    return fract( ( gridcell.x * gridcell.y ) * ( 1.0 / ( SOMELARGEFLOATS + gridcell.zzzz * ZINC ) ) );\n}\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nfloat Falloff_Xsq_C2( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nfloat PolkaDot3D( \tvec3 P,\n                    float radius_low,\t\t\n                    float radius_high\t)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    vec4 hash = FAST32_hash_3D_Cell( Pi );\n\n    //\tuser variables\n    float RADIUS = max( 0.0, radius_low + hash.w * ( radius_high - radius_low ) );\n    float VALUE = RADIUS / max( radius_high, radius_low );\t//\tnew keep value in proportion to radius.  Behaves better when used for bumpmapping, distortion and displacement\n\n    //\tcalc the noise and return\n    RADIUS = 2.0/RADIUS;\n    Pf *= RADIUS;\n    Pf -= ( RADIUS - 1.0 );\n    Pf += hash.xyz * ( RADIUS - 2.0 );\n    //Pf *= Pf;\t\t//\tthis gives us a cool box looking effect\n    return Falloff_Xsq_C2( min( dot( Pf, Pf ), 1.0 ) ) * VALUE;\n}\n\n\n/**\n * Rotation matrix around the X axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale) * min(scale.x, min(scale.y, scale.z));\n}\n\n//JW\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n//JW\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n//JW\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//iq\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//iq\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// iq\nfloat cylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//http://glslsandbox.com/e#40928.0\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\n\n// Based off: //http://glslsandbox.com/e#40928.0\n// Creates the main body of tentacle\nfloat noodle (vec3 p)\n{\n   \n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.01 );  \n    \n    // sdCapsule, second argument defines lower end point, third is upper end point\n    // p is the point being evaluated, last argument is thickness\n    float cap = sdCapsule(p, vec3( 0.0, -6.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ), 0.3 * scale );\n\t\n    // want more tapering at the end\n    float cone = sdCone(rotateX(-PI/2.0) * p + vec3(0.0, 0.0, -1.0), normalize(vec2(1.5, .30)));\n    //return cone;\n    return smin(cone, cap, -.5);\n}\n\nfloat suctionCup(vec3 p, float scale)\n{\n    \n    vec3 cp = rotateX(-PI/2.0) * p;\n    float outer = cylinderSDF(cp, vec2(1.0, .30) / scale);\n    float inner = cylinderSDF(cp, vec2(.25, .5) / scale);\n    \n    float mid = differenceSDF(outer, inner);\n    \n    return mid;\n}\n\n\n\n\n//http://glslsandbox.com/e#40928.0\n// Creates the tentacle by calling noodle and placing suction cups along body of tentacle\nfloat Tentacle( vec3 p )\n{\n    p.x -= sin( p.y * 2.0 + iTime * 7.0 ) * 0.21;\n    \n    float noodle = noodle(p); // The \"main body\" of the tentacle\n    if(noodle < EPSILON)\n    {\n        K_d = vec3(0.0, 0.0, .8);// palette(sin(iTime), A, B, C, D);\n    } \n    \n    float scale = 150.0;\n    p += vec3(0.0, -.70, 0.0);\n    vec3 sc_p1 = p - vec3(0.01, 0.0, 0.03);\n    vec3 sc_p2 = p - vec3(-0.01, 0.0, 0.03);\n    \n    \n    sc_p1 = rotateY(PI/4.0) * sc_p1;\n    sc_p2 = rotateY(-PI/4.0) * sc_p2;\n    float sc1 = suctionCup(sc_p1, scale);\n    float sc2 = suctionCup(sc_p2, scale);\n    float sc = unionSDF(sc1, sc2);\n    if(sc < EPSILON)\n    {\n        K_d = palette(noise(sc_p1.xy), vec3(.5, .5, .5), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, .333, .667));\n    }\n    \n    \n    // first six suction cups: start small and scale bigger\n    // as they are placed from the tip towards the base\n    // also, rotate so that they lie \"on\" the surface of the tentacle\n    for(int i = 0; i < 6; i++)\n    {\n        scale /= 1.45;\n        sc_p1 += vec3(-0.00005, .05 * float(i),float(i) * -0.0085);\n        sc_p2 += vec3(0.00005, .05 * float(i),float(i) * -0.0085);\n        sc1 = suctionCup(sc_p1, scale);\n        sc2 = suctionCup(sc_p2, scale);    \n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n        \n        if(sc < EPSILON)\n        {\n            K_d = palette(noise(sc_p1.xy), vec3(.5, .5, .5), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, .333, .667));\n        }\n    }\n    \n    sc_p1 = rotateY(-PI/8.0) * sc_p1;\n    sc_p2 = rotateY(PI/8.0) * sc_p2;\n    \n    // Once close enough to the base, can be the same size and rotation\n    for(int j = 6; j < 15; j++)\n    {\n    \n        sc_p1 += vec3(0, .25 , -0.0177);\n        sc_p2 += vec3(0, .25 , -0.0177);\n        sc1 = suctionCup(sc_p1, scale);\n        sc2 = suctionCup(sc_p2, scale);\n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n        if(sc < EPSILON)\n        {\n            K_d = palette(noise(sc_p1.xy), vec3(.5, .5, .5), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, .333, .667));\n        }\n    }\n    \n   \n    return smin(noodle, sc, .01);\n  \n}\n\n// modified from iq\nfloat opRep(vec3 p)\n{\n    vec3 q = vec3(p.x + cos(iTime), p.y + sin(iTime), mod(p.z,9.0));\n\n    float scale = 1.0 - 2.5 * saturate( abs( q.y ) * 0.01 );  \n   \tfloat boundingCapsule = sdCapsule(q, vec3( 0.0, -6.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ),  .50 * scale );\n    float tentacle; \n\n    if(boundingCapsule < .001)\n   \t{\n    \ttentacle = Tentacle(q);\n       // K_d += palette(noise(p.yz), vec3(.5, .5, .5), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(0.0, .333, .667));\n        \n    } else {\n        tentacle = boundingCapsule;\n   \t}\n\n    return tentacle;\n}\n\n\n// Creates the tunnel and maps the tentacles onto it\nfloat map( vec3 p){\n   \n    float tentacleRing = -1.0;\n    float amplitude = 1.9;\n    int numTentacles = 10;\n    float offSet = (noise(.75 * PI * p.xy)/2.0 * sin(3.0 * iTime));\n    float m = cos(p.x) + cos(p.y) + sin(p.z) + offSet;\n\n    if(m < EPSILON)\n    {\n\t\t// coloring the tunnel\n       /* vec3 colorPoint = vec3(cos(p.x) + offSet + p.x + sin(iTime), cos(p.y) + offSet + p.y + iTime, sin(p.z) + offSet + p.z + iTime);\n        float redpt = PolkaDot3D(mod(p, 3.0), .0, .70);\n        vec3 redDots = vec3(2.0 * redpt, 0.0, 0.0);\n        float yellowpt = PolkaDot3D(p, .60, .60);\n        vec3 yellowDots = vec3(2.0 * yellowpt, 2.0 * yellowpt, 0.0);\n\t\t\n        float ptOffY = PolkaDot3D(colorPoint, .5, .5);\n        float ptOffR = PolkaDot3D(mod(colorPoint, 25.0), .5, .5);\n        vec3 redDotsOff = vec3(2.0 * ptOffR, 0.0, 0.0);\n        vec3 yellowDotsOff = vec3(2.0 * ptOffY, 2.0 * ptOffY, 0.0);\n        \n        if(redDots.x > 0.0)\n        {\n            redDots.x = 1.0;\n        }\n        if(redDotsOff.x > 0.0)\n        {\n            redDotsOff.x = 1.0;\n        }\n        if(yellowDots.x > 0.0)\n        {\n            yellowDots.y = 1.0;\n            yellowDots.x = 1.0;\n        }\n        if(yellowDotsOff.x > 0.0)\n        {\n            yellowDotsOff.y = 1.0;\n            yellowDotsOff.x = 1.0;\n        }*/\n        \n        vec3 colorPoint = vec3(cos(p.x) + offSet + p.x + sin(iTime), cos(p.y) + offSet + p.y + iTime, sin(p.z) + offSet + p.z + iTime);\n        float redpt = PolkaDot3D(mod(p, 3.0), .0, .50);\n        vec3 redDots = vec3(redpt, 0.0, 0.0);\n        float yellowpt = PolkaDot3D(p, .30, .5);\n        vec3 yellowDots = vec3(yellowpt, yellowpt, 0.0);\n\t\t\n        float ptOffY = PolkaDot3D(colorPoint + p, .0, .2);\n        float ptOffR = PolkaDot3D(mod(colorPoint, 25.0), .0, .2);\n        vec3 redDotsOff = vec3(ptOffR, 0.0, 0.0);\n        vec3 yellowDotsOff = vec3(ptOffY, ptOffY, 0.0);\n        \n        vec3 blue =  palette(p.z, A, B, C, D);\n        \n        if(redDots.x > 0.0)\n        {\n            redDots.x = 1.0;\n           // K_d = vec3(1.0, 0.0, 0.0);\n             K_d = palette(redpt, vec3(0.478, 1.068, -0.212), vec3(2.238, 1.118, 1.388), vec3(0.108, 0.528, 0.478), vec3(0.907, 1.547, 1.657));\n        }\n        else if(redDotsOff.x > 0.0)\n        {\n            redDotsOff.x = 1.0;\n           // K_d = vec3(1.0, 0.0, 0.0);\n             K_d = palette(ptOffR, vec3(0.478, 1.068, -0.212), vec3(2.238, 1.118, 1.388), vec3(0.108, 0.528, 0.478), vec3(0.000, 0.478, 0.478));\n        }\n         else if(yellowDots.x > 0.0)\n        {\n            yellowDots.y = 1.0;\n            yellowDots.x = 1.0;\n            K_d =  palette(-yellowpt, vec3(.5, .5, .0), vec3(.5, .5, .0), vec3(.10, .50, .0), vec3(0.0, .0, .0));\n        }\n        else if(yellowDotsOff.x > 0.0)\n        {\n            yellowDotsOff.y = 1.0;\n            yellowDotsOff.x = 1.0;\n            K_d = vec3(1.0, 1.0, 0.0);\n        } else {\n\t\t\tK_d = yellowDots + redDots + redDotsOff + yellowDotsOff + vec3(0, 0, blue.z);      \n        }\n        \n    }\n    float gap = 360.0 / float(numTentacles) * deg2rad;\n    \n    for(int i = 0; i < numTentacles; i++)\n    {\n\n       \tfloat angle = float(i) * gap;     \n             \n        float offsetX = (amplitude) * sin(angle);\n    \tfloat offsetY = (amplitude) * cos(angle);\n        \n        vec3 localP = p;\n        localP += vec3(offsetX, offsetY, 0.0);\n        localP = rotateZ(-angle) * localP;\n        \n        \n        float tentacle = opRep(localP);\n        \n        if(tentacleRing == -1.0)\n        {\n            tentacleRing = tentacle;\n        }\n      \n        tentacle = unionSDF(tentacle, m); //smin(tentacle, m, .1);\n        tentacleRing = unionSDF(tentacle, tentacleRing);\n\n    }\n    \n    \n             \n    return tentacleRing;//smin2(tentacleRing, m, 4.0);\n    \n}\n\n  \nfloat sceneSDF(vec3 samplePoint) {\n    \n    float sdf = map(samplePoint);\n     return sdf;\n\n  \n}\n\n\n/** JW\n * \n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/** JW\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/** JW\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON_NORM, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON_NORM, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON_NORM, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON_NORM, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON_NORM)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON_NORM))\n    ));\n}\n\n\nfloat lambert(vec3 N, vec3 L)\n{\n  vec3 nrmN = normalize(N);\n  vec3 nrmL = normalize(L);\n  float result = dot(nrmN, nrmL);\n  return max(result, 0.0);\n}\n\n\n/** JW\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n//iq\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float b = .1;\n    float c = .1;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(01.5,0.6,1.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 2.5 * iTime);\n      \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    \n    worldDir.xy = rot(worldDir.xy, (iTime));\n\n   \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    \n    vec3 color = K_d * lambert(estimateNormal(p), eye);\n    \n    vec3 color_fog = applyFog(color, dist, eye, worldDir);\n    \n    fragColor = vec4(color_fog, 1.0);\n\n    \n}","name":"Image","description":"","type":"image"}]}