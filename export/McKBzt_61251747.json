{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 offset;\nvec3 tank_col = vec3(0, 0.3, 0);\n\nSurface sdTank (vec3 p, vec3 col, bool playable) {\n    vec2 rotation = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    vec3 tank_pos = texelFetch( iChannel0, ivec2(5,0), 0 ).xyz;\n    vec3 p1 = p;\n    float move_angle = texelFetch(iChannel0, ivec2(7, 0), 0).x;\n    \n    \n    \n    if (playable) {\n        p += tank_pos;\n        p.xz *= r2d(move_angle);\n    }\n    Surface hull = sdRoundBox(p, vec3(1, 0.5, 1), vec3(0, -0.5, -2.5), 0.2, col, identity());\n    Surface tow = tank_tow((p - vec3(0, 0, -2.5)) * rotateY(-3.14), rotation, playable, col);\n    Surface t = minWithColor(tow, hull);\n    return t;\n}\n\nSurface sdScene(vec3 p) {\n    float draw_house = texelFetch(iChannel0, ivec2(8, 0), 0).x;\n    vec3 floorColor = vec3(0, 0.5, 0);\n    vec3 proj_pos = texelFetch( iChannel0, ivec2(1,0), 0 ).xyz;\n    vec3 proj_angle = texelFetch( iChannel0, ivec2(2,0), 0 ).xyz;\n    Surface co = field(p, floorColor);\n    vec2 rotation = vec2(0.);\n    Surface Player_Tank = sdTank(p, tank_col, true);\n    Surface Projectile = sdSphere(p - proj_pos, 0.2, vec3(0.1, 0.1, 0.1));\n    if  (draw_house == 1.0) { \n        Surface House = sdTank(p - vec3(0, 0, -20), tank_col, false); \n        co = minWithColor(co, House);\n    }\n    co = minWithColor(co, Player_Tank);\n    co = minWithColor(co, Projectile); \n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface co; // closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > end) break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).sd +\n        e.yyx * sdScene(p + e.yyx).sd +\n        e.yxy * sdScene(p + e.yxy).sd +\n        e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 backgroundColor = vec3(0.835, 1, 1);\n    vec2 rotation = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    \n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(5, 3, 8);  \n    vec3 lp = vec3(5, 3, 8) - texelFetch(iChannel0, ivec2(5, 0), 0).xyz;    \n    ro.xz+=vec2(lp.x, lp.z);\n    lp.x += texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    ro.xz += vec2(lp.x, lp.z);\n    vec4 a = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n    \n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); \n\n    if (co.sd > MAX_DIST) {\n        col = backgroundColor; \n    } else {\n        vec3 p = ro + rd * co.sd; \n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(2, 2, 7);\n        vec3 lightDirection = normalize(lightPosition - p);\n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.); \n        col = dif * co.col + backgroundColor * .2;\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_SPACE = 32;\n\nconst int W = 87;\nconst int A = 65;\nconst int S = 83;\nconst int D = 68;\n\nfloat move_speed = 0.1;\nconst float PI = 3.14;\nconst float rotation_speed = 0.01;\nfloat proj_speed = 10.;\nvec4 proj_pos;\nvec4 proj_angle;\nvec4 projectile_fired;\nvec4 dtime;\nfloat shot_cooldown = 1.;\nfloat last_shot;\n\nvec4 gravity = vec4(0., -9.8, 0., 0.);\n\nmat2 r2d(float t) {\n    float sn = sin(t);\n    float cs = cos(t);\n    return mat2(cs, -sn, sn, cs);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Surface {\n    float sd; \n    vec3 col; \n};\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface field(vec3 p, vec3 col) { \n   float p2 = p.y+1.;\n   return Surface(p2, col);\n}\n\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform) {\n    p = p  - offset;\n    vec3 d = abs(p) - b;\n    float q = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    return Surface(q, col);\n}\n\n\nSurface sdRoundBox(vec3 p, vec3 b, vec3 BoxOffset, float r, vec3 col, mat3 transform) {\n    p -= BoxOffset;\n    vec3 q = abs(p) - b + r;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    return Surface(d, col);\n}\n\nSurface sdSphere( vec3 p, float s , vec3 col) {\n    float q= length(p)-s;\n    return Surface(q, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface tank_tow (in vec3 p, in vec2 t, bool playable, vec3 col) {\n    vec3 tow_pos = p;\n    if(playable) {\n        tow_pos.xz *= r2d(-t.x);\n    }\n    Surface tower = sdRoundBox(tow_pos, vec3(0.6, 0.6, 0.5), vec3(0.), 0.1, col, identity());\n    if(playable) {\n        p.xz *= r2d(-t.x);\n        p -= vec3(0., 0.4, 0.6);\n        p.yz *= r2d(t.y);\n    }\n    Surface muzzle = sdBox(p, vec3(0.2, 0.2, 0.9), vec3(0.0), col, identity());\n    return minWithColor(muzzle, tower);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void save_data(ivec2 px, vec4 data, inout vec4 fragColor, ivec2 current_pos) {\n    fragColor = (px.x==current_pos.x && px.y==current_pos.y ) ? data : fragColor;\n}\n\nbool handleBackspace() {\n    float space = texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x;\n    if (space == 0.0) return false;\n    return true; \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 angle_offset = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 proj_pos = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 proj_angle = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 dtime = texelFetch(iChannel0, ivec2(3, 0), 0);\n    vec4 projectile_fired = texelFetch(iChannel0, ivec2(4, 0), 0);\n    vec4 tank_pos = texelFetch(iChannel0, ivec2(5, 0), 0);\n    vec4 tank_move_dir = texelFetch(iChannel0, ivec2(6, 0), 0);\n    vec4 move_angle = texelFetch(iChannel0, ivec2(7, 0), 0);\n    vec4 draw_house = texelFetch(iChannel0, ivec2(8, 0), 0);\n   \n    if (iFrame == 0) { \n        proj_angle = vec4(0., 0., -1., 0.);\n        tank_move_dir = vec4(0., 0., -1., 0.);\n        proj_pos = vec4(0., -1.5, -2.5, 0.);\n        tank_pos = vec4(0., 0., 0., 0.);\n        draw_house = vec4(1., 0., 0., 0.);\n    }\n    \n    if(texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x != 0.f) {\n         angle_offset.x += rotation_speed;\n    } else if(texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x != 0.f) {\n         angle_offset.x -= rotation_speed;\n    }\n  \n    if(texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x != 0.f && angle_offset.y < 0.3) {\n        angle_offset.y += rotation_speed;\n    } else if(texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x != 0.f && angle_offset.y > 0.) {\n        angle_offset.y -= rotation_speed;\n    }\n    \n    if(texelFetch(iChannel1, ivec2(W, 0), 0).x != 0.f) {\n        tank_pos -= tank_move_dir*move_speed;\n    } else if(texelFetch(iChannel1, ivec2(S, 0), 0).x != 0.f) {\n        tank_pos += tank_move_dir*move_speed;  \n    }\n    \n    \n    if(texelFetch(iChannel1, ivec2(A, 0), 0).x != 0.f) {\n        move_angle.x += rotation_speed;\n        angle_offset.x += rotation_speed;\n    } else if (texelFetch(iChannel1, ivec2(D, 0), 0).x != 0.f) {\n        move_angle.x -= rotation_speed;\n        angle_offset.x -= rotation_speed;\n    }\n    tank_move_dir.xz = vec4(0., 0., -1., 0.).xz * r2d(-move_angle.x);\n   \n    if (handleBackspace()) {\n        proj_pos = vec4(0. - tank_pos.x, 0.4, -2.5 - tank_pos.z, 0.);\n        proj_pos.xz* r2d(-move_angle.x);\n        proj_angle.yz = vec4(0., 0., -1., 0.).yz* r2d(angle_offset.y);\n        proj_angle.xz = vec4(0., 0., -1., 0.).xz * r2d(angle_offset.x);\n        projectile_fired.x = 1.;\n    }\n   \n    if (projectile_fired.x == 1.) {\n        dtime.x += iTimeDelta;\n        proj_pos  += proj_angle + 0.5 * gravity * dtime.x * dtime.x;       \n        if ((proj_pos.z <= -20.) &&(proj_pos.x <= 1.5) &&(proj_pos.x >= -1.5) ) {\n            draw_house.x = 0.;\n        }\n        if (proj_pos.y <= -2.0 ) {\n            dtime.x = 0.;\n            projectile_fired.x = 0.;\n            proj_pos = vec4(0. - tank_pos.x, -1.5, -2.5 - tank_pos.z, 0.);   \n        }\n    }\n   \n    ivec2 int_fc = ivec2(fragCoord);\n    save_data(ivec2(0, 0), angle_offset, fragColor, int_fc);\n    save_data(ivec2(1, 0), proj_pos, fragColor, int_fc);\n    save_data(ivec2(2, 0), proj_angle, fragColor, int_fc);\n    save_data(ivec2(3, 0), dtime, fragColor, int_fc);\n    save_data(ivec2(4, 0), projectile_fired, fragColor, int_fc);\n    save_data(ivec2(5, 0), tank_pos, fragColor, int_fc);\n    save_data(ivec2(6, 0), tank_move_dir, fragColor, int_fc);\n    save_data(ivec2(7, 0), move_angle, fragColor, int_fc);\n    save_data(ivec2(8, 0), draw_house, fragColor, int_fc);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"McKBzt","date":"1734364940","viewed":37,"name":"WoT DLC","username":"topkedi","description":"bruh","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["tanks"],"hasliked":0,"parentid":"","parentname":""}}