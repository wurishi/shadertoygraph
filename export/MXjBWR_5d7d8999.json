{"ver":"0.1","info":{"id":"MXjBWR","date":"1729350540","viewed":137,"name":"Helixify! 2D section => 3D Helix","username":"eliemichel","description":"Compose 2D SDFs into a 3D helix shape! Any \"reasonable\" combination of two 2D shapes works: one for the large radius, one for the extrusion.","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["2d","3d","sdf","spheretracing","helix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Helixify!\n// Compose 2D SDFs into a 3D helix shape! Any \"reasonable\" combination of two 2D shapes\n// works: one for the large radius, one for the extrusion.\n// This is an approximation, since we evaluate smallShape2D in the frame given by\n// the closest point on the helix.\n//\n// Wanna helixify the helix? Go to https://www.shadertoy.com/view/MXBfWh\n//\n// Copyright (c) Élie Michel -- MIT licensed (for what is not borrowed from other shaders)\n//\n// CREDITS:\n// Shading is borrowed from iq https://www.shadertoy.com/view/Xds3zN\n// Isolines are from Zavie https://www.shadertoy.com/view/XcVGRR\n\n// NB: We are Y-up\n#define EPSILON 1e-3\n#define MAX_ITER 100\n#define TWO_PI 6.28318530718\n\n//------------------------------------------------------------\n// Scene definition utils\n// from https://iquilezles.org/articles/distfunctions2d\n// and https://iquilezles.org/articles/distfunctions\n\nfloat sdUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat sdIntersection(float a, float b) {\n    return max(a, b);\n}\n\nfloat sdDifference(float a, float b) {\n    return max(-a, b);\n}\n\nfloat sdPlane(vec3 pos, vec3 norm, float offset) {\n    return dot(pos, norm) - offset;\n}\n\nfloat sdCircle(vec2 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdRoundedBox2D( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n//------------------------------------------------------------\n// Simple utility functions\nfloat gridCell(vec2 pos) {\n    float x = 2.0 * fract(floor(pos.x) * 0.5);\n    float y = 2.0 * fract(floor(pos.y) * 0.5);\n    return x + y - 2.0 * x * y;\n}\n\nmat2 rot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nfloat pausedTime(float time, float pausePeriod, float pauseDuration) {\n    float scaledTime = time / pausePeriod;\n    float unpauseDuration = 1.0 - pauseDuration / pausePeriod;\n    return (\n        min(fract(scaledTime), unpauseDuration) + floor(scaledTime) * unpauseDuration\n    ) * pausePeriod;\n}\n\n//------------------------------------------------------------\n// Core scene definition\n\n// Cross-section of the helix\nfloat largeShape2D(vec2 pos) {\n    //return length(pos) - 0.4;\n    \n    float roundness = sin(iTime) * 0.5 + 0.5;\n    \n    return sdRoundedBox2D(\n        pos,\n        vec2(0.4, mix(0.3, 0.4, roundness)),\n        vec4(0.4 * roundness)\n    );\n}\n\n// Shape of 1 turn of the helix\nfloat smallShape2D(vec2 pos) {\n    float sharpness = sin(0.5 * iTime) * 0.5 + 0.5;\n    return mix(\n        sdCircle(pos, 0.1),\n        sdStar5(pos, 0.1, mix(1.0, 0.5, sharpness)),\n        sharpness\n    );\n    //return length(pos) - 0.1;\n}\n\n// Core of the helix shape.\n// Param 'stepSize' is the Y distance between two points of the helix with the\n// same XZ coords.\n// If GLSL would allow it, this would be a higher-order function\n// taking 'smallShape2D' and 'largeShape2D' as arguments.\n// Copyright (c) Élie Michel -- MIT licensed\nfloat helixify(vec3 pos, float stepSize) {\n    // Signed distance to the trajectory of the helix in the XZ (horizontal) plane.\n    float dist_xz = largeShape2D(pos.xz);\n    \n    // The rest is about computing dist_y, i.e. the distance along the Y axis.\n\n    // Curvilinear abscissa of the closest point, modulo 1, where 1 corresponds\n    // to a full step of the helix.\n    float frac_cu = atan(pos.z, pos.x) / TWO_PI;\n    \n    // We now need to figure out the actual closest point, i.e., the n such that\n    // the full curvilinear abscissa of the closest point is n + frac_cu.\n    \n    // Potential candidates are base_n - 1, base_n and base_n + 1 (as long as the\n    // largeShape2D does not depend on Y)\n    int base_n = int(floor(pos.y / stepSize - frac_cu));\n    \n    float dist_y = 2.0 * stepSize; // Upper-bound, will necessarily be overwritten in the loop\n    for (int n = base_n - 1 ; n <= base_n + 1 ; ++n) {\n        // Y coord of the helix point at curvilinear abscissa n + frac_cu\n        float helix_y = (float(n) + frac_cu) * stepSize;\n        float candidate_dist_y = pos.y - helix_y;\n        if (abs(candidate_dist_y) < abs(dist_y)) {\n            dist_y = candidate_dist_y;\n        }\n    }\n    \n    // Coordinates in the local frame of the closest helix point\n    vec2 local_pos = vec2(dist_xz, dist_y);\n    return smallShape2D(local_pos);\n}\n\nfloat sceneDist(vec3 pos) {\n    float restStepSize = 0.3;\n    float restLen = 1.5;\n    \n    // Animation\n    float bounce = 12.0 * fract(iTime) * pow(1.0 - fract(iTime), 4.0);\n    float stepSize = restStepSize - 0.1 + 0.4 * bounce;\n    float len = restLen * stepSize / restStepSize;\n    \n    float x = cos(TWO_PI * pausedTime(iTime, 1.0, 0.5)) * 0.5;\n    float y = abs(sin(TWO_PI * pausedTime(iTime, 1.0, 0.5))) * 0.75;\n    vec3 offset = vec3(x, y, 0.0);\n    \n    pos -= offset;\n    \n    // Scene construction\n    return sdIntersection(\n        sdIntersection(\n            helixify(pos, stepSize),\n            sdPlane(pos, vec3(0.0, 1.0, 0.0), len)\n        ),\n        sdPlane(pos, vec3(0.0, -1.0, 0.0), 0.0)\n    );\n}\n\n// Use direction to better evaluate step size to ground plan intersection\nfloat sceneRaycast(vec3 pos, vec3 dir) {\n    //return sceneDist(pos);\n    float groundPlaneRayDist = dir.y > 0.0 ? 10000.0 : pos.y / abs(dir.y);\n    return sdUnion(\n        groundPlaneRayDist,\n        sceneDist(pos)\n    );\n}\n\n//------------------------------------------------------------\n// Shading, borrowed from iq\nvec3 calcNormal( in vec3 pos )\n{\n    if (pos.y < EPSILON) return vec3(0.0, 1.0, 0.0);\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(pos+0.0005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = sceneDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = sceneDist( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 computeShading(vec3 pos, vec3 nor, vec3 rd, float t) {\n    vec3 ref = reflect( rd, nor );\n    vec3 col = (\n        pos.y <= EPSILON\n        ? vec3(mix(0.1, 0.3, gridCell(pos.xz)))\n        : vec3(1.0, 0.5, 0.0) * 0.5\n    );\n    float ks = 0.4;\n    float occ = calcAO( pos, nor );\n\n    vec3 lin = vec3(0.0);\n    // sun\n    {\n        vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n              dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n              spe *= dif;\n              spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n        lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n        lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n    }\n    // sky\n    {\n        float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n              dif *= occ;\n        float spe = smoothstep( -0.2, 0.2, ref.y );\n              spe *= dif;\n              spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n              spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n        lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n        lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n    }\n    \n    //return mix( lin, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    return lin;\n}\n\n//------------------------------------------------------------\n// Viewport function\n\nvoid mainViewport( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n    vec3 direction = normalize(vec3(uv.xy, 1.0));\n    direction.yz = rot(.05 * TWO_PI) * direction.yz;\n    vec3 pos = vec3(0.0, 4.0, -8.0);\n    \n    float fac = -1.0;\n    float t = 0.0;\n    for (int i = 0 ; i < MAX_ITER ; ++i) {\n        float sd = sceneRaycast(pos, direction);\n        if (sd < EPSILON) {\n            fac = float(i) / float(MAX_ITER);\n            break;\n        }\n        pos += .95 * direction * sd;\n        t += .95 * sd;\n    }\n    \n    if (fac >= 0.0) {\n        vec3 normal = calcNormal(pos);\n        vec3 col = vec3(fac);\n        col = normal * 0.5 + 0.5;\n        col = computeShading(pos, normal, direction, t);\n        col = pow(col, vec3(0.4545));\n        fragColor = vec4(col,1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0,1.0);\n    }\n}\n\n//------------------------------------------------------------\n// Isoline view function\n\n// Isolines from Zavie https://www.shadertoy.com/view/XcVGRR\n#define POSITIVE_DISTANCE_SPACE vec3(0.13, 0.62, 0.74)\n#define NEGATIVE_DISTANCE_SPACE vec3(0.01, 0.19, 0.28)\n#define ZERO_DISTANCE_ISO_LINE vec3(1.0, 0.72, 0.01)\n#define ISO_LINES vec3(0.56, 0.79, 0.9)\n\nvec3 debugDistance(vec3 iResolution, float d)\n{\n    float refWidth = 1. * iResolution.y / 1080.;\n\n    float dd1 = fwidth(d);\n    float width1 = 2.5 * dd1 * refWidth;\n    \n    float iso1 = smoothstep(-dd1, dd1, abs(fract(d) * 2. - 1.) - (1. - width1));\n\n    float dd5 = fwidth(5. * d);\n    float width5 = 1.0 * dd5 * refWidth;\n    float iso5 = smoothstep(-dd5, dd5, abs(fract(5.*d) * 2. - 1.) - (1. - width5));\n\n    float dd0 = fwidth(d);\n    float width0 = 3. * dd0 * refWidth;\n    float iso0 = smoothstep(-dd0, dd0, width0 - abs(d));\n\n    float isoLines = max(iso0, max(iso1, iso5));\n\n    vec3 background = (d > 0. ? POSITIVE_DISTANCE_SPACE : mix(NEGATIVE_DISTANCE_SPACE, ISO_LINES, 0.1));\n    vec3 lineColor = mix(ISO_LINES * (d > 0. ? 1. : 0.8), ZERO_DISTANCE_ISO_LINE, iso0);\n\n    return mix(background, lineColor, isoLines);\n}\n\nvoid mainIsolineLarge( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * vec2(1., iResolution.y / iResolution.x);\n    vec2 c = vec2(0.5) * vec2(1., iResolution.y / iResolution.x);\n\n    float scale = 4.5;\n    float d = largeShape2D((uv - c) * scale);\n\n    vec3 colouredDistance = debugDistance(iResolution, d);\n\n    fragColor = vec4(colouredDistance, 1.0);\n}\n\nvoid mainIsolineSmall( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * vec2(1., iResolution.y / iResolution.x);\n    vec2 c = vec2(0.5) * vec2(1., iResolution.y / iResolution.x);\n\n    float scale = 4.5;\n    float d = smallShape2D((uv - c) * scale);\n\n    vec3 colouredDistance = debugDistance(iResolution, d);\n\n    fragColor = vec4(colouredDistance, 1.0);\n}\n\n//------------------------------------------------------------\n// Main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float mask1 = sdRoundedBox2D(fragCoord - iResolution.xy * vec2(0.25, 0.75), iResolution.xy * 0.25 - vec2(10.0), vec4(25.0));\n    float mask2 = sdRoundedBox2D(fragCoord - iResolution.xy * vec2(0.25, 0.25), iResolution.xy * 0.25 - vec2(10.0), vec4(25.0));\n    \n    if (mask1 < 0.0) {\n        mainIsolineLarge(fragColor, fragCoord + iResolution.xy * vec2(0.25, -0.25));\n    } else if (mask2 < 0.0) {\n        mainIsolineSmall(fragColor, fragCoord + iResolution.xy * vec2(0.25, 0.25));\n    } else {\n        mainViewport(fragColor, fragCoord + iResolution.xy * vec2(-0.25, 0.0));\n    }\n}\n","name":"Image","description":"","type":"image"}]}