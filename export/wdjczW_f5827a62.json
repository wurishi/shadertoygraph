{"ver":"0.1","info":{"id":"wdjczW","date":"1594909304","viewed":217,"name":"Circle glow animation","username":"nicolaecodreanu","description":"2D animation with circles. \nInspired from other shadertoy examples.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","circle","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define ANIMATION_TIMESCALE 0.5\n#define ANIM_FUNC Quart\n#define polar(a) vec2(cos(a),sin(a))\n#define rotate(a) mat2(cos(a),sin(a),-sin(a),cos(a));\n\nfloat sdCircle(in vec2 p, in float r) \n{\n \treturn length(p) - r;   \n}    \n\nfloat Quart(float s, float e, float t)\n{\n    t = clamp((t - s) / (e - s), 0.0, 1.0);\n    return 1.0 - pow(1.0 - t, 4.0);\n}\n\nfloat exponentialOut(float s,float e,float t) {\n  \tt = clamp((t - s) / (e - s),0.0,1.0);\n  \treturn t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat variation(vec2 v1, vec2 v2, float strength, float speed) {\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float px = 1.5 / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    //----------circle\n    {\n        //circle uv\n        vec2 cv = uv;\n        \n        //setup timer loop\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, 3.0);\n        \n        //setup animation\n        float fillIn = ANIM_FUNC(0.0, 1.0, t);\n        float fadeOut = ANIM_FUNC(2.0, 3.0, t);\n        \n        //setup mask\n        float v = fillIn * (TWOPI + 0.3); //value\n        float i = v - 0.3; //interval \n        float a = mod(atan(uv.y, uv.x) - 0.5 * PI, TWOPI); //positive values in interval [0, TWOPI]\n        float fillMask = 1.0 - smoothstep(i, v, a);\n        float mask = fillMask - fadeOut;\n        \n        //draw circle\n        float r = 0.3;\n        float d = sdCircle(cv, r);\n        col = mix(col, vec3(1.0), (1.0 - smoothstep(0.0, px, abs(d))) * mask);\n    }\n   \n    //----------satellites\n    {\n        //circle uv\n        vec2 cv = uv;\n        \n        //setup timer loop\n        const float loop = 3.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n        \n        //rotation\n        float rotation = exponentialOut(0.0, 1.0, t);\n        cv *= rotate(t * 0.1 * rotation);\n        \n        //positions\n        const float cnt = 4.0;\n        vec2 dirs[int(cnt)];\n        for(float i = 0.0; i < cnt; i++) \n        {\n            dirs[int(i)] = polar(i * TWOPI / cnt + PI * 0.5);\n        }\n        \n        for(float i = 0.0; i < cnt; i++) \n        {\n            //setup animation\n            float show = (0.5 / cnt) * i;\n            float fadeIn = ANIM_FUNC(show, show + 0.1, t);\n            float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n            \n            //setup mask\n           \tfloat mask = fadeIn - fadeOut;\n            \n            //draw sattelites\n            float d = sdCircle(cv - dirs[int(i)] * 0.3, 2.0 * px);\n            col = mix(col, vec3(1.0), (1.0 - smoothstep(-px, px, d)) * mask);\n        }\n    }\n    \n    //----------dotted circle\n    {\n        //circle uv\n        vec2 cv = uv;\n        \n    \t//setup timer loop\n        const float loop = 3.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n        \n        //setup animation\n        float fadeIn = ANIM_FUNC(0.0, 1.0, t);\n        float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n        float scaleUp = exponentialOut(0.0, 1.0, t);\n        \n        //setup mask\n        float mask = fadeIn - fadeOut;\n        \n        //draw circle\n        float r = 0.18 + scaleUp * 0.1;\n        float d = sdCircle(cv, r);\n        col = mix(col, vec3(1.0), (1.0 - smoothstep(-3.0 * px, 1.0 * px, abs(d))) * mask);\n    }    \n    \n    //----------dotted sattelites\n    {\n        //circle uv\n        vec2 cv = uv;\n        \n        //setup timer loop\n        const float loop = 3.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n        \n        //rotation\n        float rotation = exponentialOut(0.0, 1.0, t);\n        cv *= rotate(t * 0.2 * -rotation);\n        \n        //positions\n        const float cnt = 100.0;\n        vec2 dirs[int(cnt)];\n        for(float i = 0.0; i < cnt; i++)\n        {\n        \tdirs[int(i)] = polar(i * TWOPI / cnt);\n        }    \n        \n        for(float i = 0.0; i < cnt; i++)\n        {\n         \t//setup animation\n            float fadeIn = ANIM_FUNC(0.0, 1.0, t);\n            float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n            float scaleUp = exponentialOut(0.0, 1.0, t);\n            \n            //setup mask\n            float mask = fadeIn - fadeOut;\n            \n            //draw sattelites\n            float d = sdCircle(cv - dirs[int(i)] * (0.18 + scaleUp * 0.1), px * 0.5);\n            col = mix(col, vec3(1.0), (1.0 - smoothstep(-2.0 * px, px, d)) * mask);\n        }           \n    }    \n   \n    //----------glowing circle\n    {\n    \t//circle uv\n        vec2 cv = uv + vec2(-0.03, 0.03);\n        \n        //setup timer loop\n        const float loop = 30.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n        \n        //rotation\n        float rotation = exponentialOut(0.0, 1.0, t);\n        cv *= rotate(t * 0.5 * -rotation);\n        \n        //deformation\n        cv += variation(cv, vec2(0.0, 2.0), 0.5, 1.0);\n        \n        //setup animation\n        float fadeIn = ANIM_FUNC(0.5, 2.0, t);\n        float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n        \n        //setup mask\n        float mask = fadeIn - fadeOut;\n        \n        //draw circle\n        float a = atan(cv.y, cv.x);\n        float r = 0.3;\n        float d = sdCircle(cv, r);\n        col = mix(col, vec3(1.0), (1.0 - smoothstep(-10.0 * px, 2.0 * px, abs(d))) * mask);\n        col = mix(col, vec3(1.0), (1.0 - smoothstep(-30.0 * px, 10.0 * sin(a) * px, abs(d))) * smoothstep(px, -px, d) * mask);\n    }    \n     \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}