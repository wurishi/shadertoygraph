{"ver":"0.1","info":{"id":"3tdSDn","date":"1580752569","viewed":203,"name":"Mini Cookie Party Theme","username":"Flopine","description":"This shader was made for being printed on goodies given during the mini cookie party of february 2020 : https://www.facebook.com/events/568826153850368/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","triangle","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// MINI COOKIE PARTY PATTERN\n// This shader was made for being printed on goodies given during\n// the mini cookie party of february 2020\n// https://www.facebook.com/events/568826153850368/\n\n#define hr vec2(1.,sqrt(3.))\n#define time iTime\n#define PI 3.141592\n#define TAU (2.*PI)\n\n\nstruct Pattern\n{\n    float hdist;\n    float hmoda;\n\tfloat tridist;\n};\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat hexadist(vec2 uv)\n{\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(hr)));\n}\n\n// distance to a triangle found here:     \n//https://www.shadertoy.com/view/Wsl3RB\nfloat tdist (vec2 uv)\n{\n \tfloat a = atan(uv.y,uv.x)+PI/2.;\n    float r = TAU/3.;\n\n    return cos(floor(.5+a/r)*r-a)*length(uv*1.5);\n}\n\nPattern final_grid (vec2 uv, float detail)\n{\n    uv *= detail;\n\n    vec2 ga = mod(uv, hr) - hr*0.5;\n    vec2 gb = mod(uv - hr*0.5, hr) - hr*0.5; \n    \n    vec2 guv = (dot(ga,ga) < dot (gb,gb)) ? ga : gb; \n   \n    float h_dist = hexadist(guv);\n    float h_moda = mod(atan(guv.y, guv.x),PI/3.)*PI/6.;\n    \n    float tri_dist = tdist (guv);  \n   \n    return Pattern(h_dist, h_moda, tri_dist);\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(TAU*(c*t+d));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= rot(PI/4.);\n    \n    Pattern FG = final_grid(uv,3.);\n    float mask = (FG.hmoda > 0.25) ? 1. : 0.;   \n    float final_pattern = clamp((step(FG.tridist,0.5) + step(0.67,FG.tridist)*0.5)\n                     \t\t*step(0.2,FG.hdist)\n                          \t*mask,\n                           0.,1.);\n\n    vec3 col = palette(final_pattern, vec3(0.5),vec3(0.4),vec3(.5), vec3(0.5,0.3,0.3));\n    col.r *= step(0.2,.5-FG.hmoda);\n        \n    col = mix(col,(1.-col),step(0.3,fract(abs(uv.x)-time*0.5)-0.1));\n    \n    // Output to screen\n    fragColor = vec4(sqrt(clamp(col,0.,1.)),1.);\n}","name":"Image","description":"","type":"image"}]}