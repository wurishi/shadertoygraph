{"ver":"0.1","info":{"id":"flcfzX","date":"1665580665","viewed":141,"name":"solar storm","username":"pb","description":"solar storm?","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["icosahedron","backbuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 U) {\n\n  U /= iResolution.xy;\n  O=texture(iChannel0,U);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265;\n#define sc  1.28\n\n//hard coded icosahedron vertices for fractal generation\nconst float sqr5 = sqrt(5.);\nconst float p1 = 1./sqr5;\nconst float p2 = 2./sqr5;\nconst float p3 = sqrt( (5.+sqr5)/10. );\nconst float p4 = sqrt( (5.-sqr5)/10. );\nconst float p5 = (5.-sqr5)/10.;\nconst float p6 = (-5.-sqr5)/10.;\nconst float p7 = (5.+sqr5)/10.;\nconst float p8 = (-5.+sqr5)/10.;\n\nvec3[] d20 = vec3[] (\nvec3(1.,0.,0.),\nvec3(p1, p2, 0.),\nvec3(p1, p5, p3),\nvec3(p1, p6, p4),\nvec3(p1, p6, -p4),\nvec3(p1, p5, -p3),\nvec3(-1.,0.,0.),\nvec3(-p1, -p2, 0.),\nvec3(-p1, p8, -p3),\nvec3(-p1, p7, -p4),\nvec3(-p1, p7, p4),\nvec3(-p1, p8, p3)\n);\n\nfloat ifs_scale; \nint   max_iter;\nfloat  max_dist, global_lum;\nvec3  global_light, lightpos;\n\nmat3 rot_xz( float an ) {\n    float can = cos(an);\n    float san = sin(an);\n\n    return mat3( can, 0., -san,\n                 0. , 1.,   0.,\n                 san, 0.,  can );\n\n}   \n\nvec2 de_d20(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    z += .5;    \n    z = mod( z - 1., 1.8 ) - 1.;\n    z = rot_xz(iTime)*z;\n\n    for (int i=0; i<100; i++) {\n        if ( i > max_iter ) break;\n        min_vtx = sc*d20[0];\n        min_dist=length(z-sc*d20[0]);\n        for (int j=1; j<12; j++) {\n            dist_to_vtx=length(z-sc*d20[j]); \n            if (dist_to_vtx<min_dist) {min_vtx=sc*d20[j]; min_dist=dist_to_vtx;}    \n        }\n        z = min_vtx + ifs_scale*(z-min_vtx);  //exact same formula as for Sierpinski Triangle\n        n++;\n    }\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    return vec2( scene_dist, objid );\n}\n\n\n\nvec3 sky_color( vec3 dir, vec3 lightpos, vec3 p ) {\n  \n    vec3 skypos  = dir*max_dist;\n    vec3 sky;\n\n    float ldiff = length( -lightpos - skypos ); \n\n    ldiff *= ldiff;\n\n    float sun_lum  = exp( -ldiff/1e11);\n    float sun_lum2 = exp( -ldiff/.6e9);\n    float sun_lum3 = exp( -ldiff/1e10);\n    \n    global_light = vec3( sun_lum/3., sun_lum/3., 1.2*sun_lum );\n\n    float global_sun_lum = sun_lum2;\n\n    sky = vec3(sun_lum2,sun_lum2,0.);\n    sky += (1.-sun_lum)*sky + .7*global_light;\n    sky += (1.-sun_lum)*sky + vec3( sun_lum3/2., sun_lum3/3., 0.);\n\n    return  .7*sky;\n\n}\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\n    float totdist=0.;\n    float dist;\n    vec3  p, col=vec3(0.);\n    float glow = 0.;\n    float glow_threshold = .04 + .02*abs(sin(iTime));\n\n    for (int i=0; i<20; i++) {\n\n        {\n            p = from + totdist*dir;\n            dist = de_d20(p).x;\n            totdist+=dist; \n\n            if (dist<glow_threshold) \n                glow += max(0.,glow_threshold-dist)* exp(-totdist*totdist) ; ///(2.*max(1.,(1.+2.*sin(iTime/7.))))) ;\n         }\n \n    }\n\n    vec3 backg = sky_color( dir, lightpos, p );\n\n    col = backg;\n    col +=  glow * backg ;\n    col.r += glow * .2;\n    col.g += glow * .5;\n\n\n    return col; \n\n}\n\nfloat random(vec2 p) {\n    return fract( sin( dot( p, vec2(12., 90.)))  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ifs_scale = 1.8 + abs( sin(iTime/3.) ); \n    max_iter = 2; \n    max_dist = 1e5;  \n \n    mat3 rot;\n    vec2 oU = fragCoord/iResolution.xy;\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0. );\n    float  focal_point = -1.6;\n\n    rot = rot_xz(.2*sin(iTime));\n    vec3   rd =  rot * normalize(vec3(uv,focal_point));\n\n    ro  += vec3(-sin(iTime/50.),.5,-1.)* iTime/2.;\n  \n    lightpos  = max_dist * vec3(0.,0.,1.) ;        \n\n    vec3 color = raymarch(ro,rd);\n \n    color = .5 + 1.9*(color - .5);\n    color = clamp(color,0.,1.);\n    \n    float tf = 1.+.5*sin(iTime+random(ro.xy));\n    vec4 prev = texture(iChannel0,vec2(.1*sin(iTime),0.)+oU);\n    fragColor = vec4(color, 1.); \n    fragColor.g += .15*tf*prev.g;\n    fragColor.r += .35*tf*prev.r;\n    fragColor.b -= .7*tf*prev.b;\n    fragColor = clamp(fragColor,0.,1.);\n    fragColor = pow(fragColor,vec4(2.));\n}","name":"Buffer A","description":"","type":"buffer"}]}