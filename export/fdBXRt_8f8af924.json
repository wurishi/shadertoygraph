{"ver":"0.1","info":{"id":"fdBXRt","date":"1620923959","viewed":112,"name":"Numbering pixel","username":"fancyzero","description":"Number the Non-Zero pixels(cells) in order","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pixel","voxel","counting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat rectMask(vec2 uv, vec4 rect)\n{\n    uv = (uv-rect.xy)/(rect.zw-rect.xy);\n    vec2 z = step(-1.,-uv)*step(0.,uv);\n    \n    return dot(z,z.yx);\n}\n\n\nfloat getFloatDigit(float v, float d)\n{\n       float i = 0.;\n       float m = 1.;\n       float m2 = 10.;\n       if ( d < 0. )\n       {    \n           d = d*-1.;\n           m2 = 0.1;\n       }\n       while( i < d)\n       {\n           m *= m2;\n           i+=1.;\n       }\n    return floor(mod(v*m,10.));\n}\n\nvec4 Debug(float n, float digits, float intDigits,vec4 rect,vec2 uv)\n{\n    bool isNagetive = false;\n    if (n < 0.)\n    {\n        n *= -1.;\n        isNagetive = true;\n    }\n    \n    float dWidth = (rect.z-rect.x)/digits;\n    float dPos = floor((uv.x-rect.x)/(rect.z-rect.x)*digits);\n    float d = 0.;\n    if (dPos-intDigits < 0. )\n        d = getFloatDigit(n, (dPos+1.)-intDigits);\n    else\n        d = getFloatDigit(n, dPos-intDigits);\n    \n    \n    \n    float mask = rectMask(uv,rect);\n    float rows= 16.;\n    float cols = 16.;\n    \n    float char = 12.*16.+d;\n    if (dPos-intDigits == 0.)\n        char = 14.*16.-2.;\n    if (dPos == 0. && isNagetive)\n        char = 14.*16.-3.;\n    float x = mod(char,rows);\n    float y = floor(char/cols);\n    \n    vec4 subRect = vec4(rect.x +dPos*dWidth, rect.y,rect.x+(dPos+1.)*dWidth, rect.w );\n    vec4 charRect = vec4(x/cols, y/rows,(x+1.)/cols, (y+1.)/rows);\n    vec2 scale = 1./16./(subRect.zw-subRect.xy) ;\n    vec4 c = texture(iChannel2,(uv-subRect.xy)*scale+charRect.xy);\n    return vec4(smoothstep(0.54,0.49,c.w))*mask;\n    return c.xxxx*mask;\n}\n\nivec2 toMipPos( int level,ivec2 p, int maxLevels)\n{\n\n    int size = 1<< level;\n    \n    int mask = (1<<(level+1))-1;\n    \n    ivec2 base = ivec2((1<<(maxLevels+1))-mask-1,0);\n    p = ivec2(p.x>>(maxLevels-level), p.y >>(maxLevels-level))+base;\n    \n    return p;\n}\n\nivec2 quadrantOrigin( ivec2 p )\n{\n    return ivec2(p.x&0xfffffffe, p.y&0xfffffffe);\n}\n\nfloat fetchData(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).x;\n}\n\nint GetIndex( ivec2 p, int maxLevel)\n{\n    float v = 0.;\n    for ( int i = 1 ; i < maxLevel; i++)\n    {\n        ivec2 base = levelOrigin(i,maxLevel);\n        ivec2 q = toMipPos(i,p,maxLevel);\n        ivec2 o = quadrantOrigin( q );\n        \n        if (o.x != q.x || o.y != q.y )\n            v += fetchData(o);\n        else\n            continue;\n        \n        if (o.x+1 != q.x || o.y != q.y )\n            v += fetchData( o+ivec2(1,0));\n        else\n            continue;\n\n        if (o.x != q.x || o.y+1 != q.y )\n            v += fetchData( o+ivec2(0,1));\n        else\n            continue;\n    }\n\n    //last mip\n    ivec2 q = p;\n    ivec2 o = quadrantOrigin( p );    \n    v += fetchData(o);    \n    if (o.x == q.x && o.y == q.y )\n        return int(v);\n    v += fetchData(o+ivec2(1,0));    \n    if (o.x+1 == q.x && o.y == q.y )\n        return int(v);\n    v += fetchData(o+ivec2(0,1));    \n    if (o.x == q.x && o.y+1 == q.y )\n        return int(v);\n    v += fetchData(o+ivec2(1,1));    \n   \n    \n    return int(v);\n    \n}\n\nivec4 GetLevelBound( int maxLevel, int level)\n{\n    int maxSize = 1<<maxLevel;\n    ivec2 leftBottom = toMipPos(level, ivec2(0,0),maxLevel);\n    ivec2 rightTop = toMipPos(level, ivec2(maxSize-1,maxSize-1),maxLevel);\n    return ivec4(leftBottom.xy, rightTop.xy);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float scale = iResolution.y/float(MAX_SIZE);\n    float scale2 = 4.;\n    \n    float d = length(fragCoord  - iMouse.xy)/(iResolution.y/100.);\n    d = (step(d,15.));\n    if (length(iMouse.xy) <1.)\n        d = 0.;\n    fragCoord /= scale;\n    vec2 mousePos = iMouse.xy/scale;\n    ivec2 iuv = ivec2(mix(fragCoord,fragCoord/scale2+mousePos*((scale2-1.)/scale2),d)) ;\n    \n    \n    ivec2 iuv2 = swizzling(iuv,MAX_SIZE);\n    int maxLevels = int(log2(float(MAX_SIZE)));      \n    \n    fragColor = texelFetch(iChannel0,iuv2,0)*vec4(0.545,0.435,0.510,1.);\n    \n    \n       \n    vec2 grid = fract(mix(fragCoord,fragCoord/scale2+mousePos*(scale2-1.)/scale2,d));\n    vec4 cellColor = texelFetch(iChannel0,iuv2,0)*mix(vec4(0.545,0.435,0.510,1.),vec4(0.376,0.302,0.353,1.),step(grid.x,grid.y));\n    grid = abs(grid - 0.5);\n    fragColor =mix(fragColor, cellColor ,smoothstep(0.40,0.41,max(grid.x,grid.y)));\n    \n    fragColor =mix(fragColor, vec4(0.475,0.624,0.376,1.), smoothstep(0.45,0.46,max(grid.x,grid.y)));\n    \n    float num =  float(GetIndex(iuv2,maxLevels))-1.; \n    grid = fract(mix(fragCoord,fragCoord/scale2+mousePos*(scale2-1.)/scale2,d));       \n    fragColor+= Debug(num, 3., 3., vec4(0.02,0.2,0.98,0.7), grid)*texelFetch(iChannel0,iuv2,0);\n    if (iuv.x >= MAX_SIZE || iuv.y >= MAX_SIZE)\n        fragColor = vec4(0.);\n}\n\n\n/*    for ( int i=1; i <= 0; i++ )\n    {\n    ivec2 mipPos = toMipPos(i, ivec2(1,6), maxLevels);\n    if (iuv.x == mipPos.x && iuv.y == mipPos.y )\n        fragColor = vec4(0.192,0.647,0.192,1.);\n    \n        mipPos =  quadrantOrigin(toMipPos(i, ivec2(1,6),maxLevels));\n    if (iuv.x == mipPos.x && iuv.y == mipPos.y )\n        fragColor = vec4(0.588,0.588,0.114,1.);     \n    }\n    */\n    \n    /*    ivec2 imousePos = ivec2(int(iMouse.x/scale),int(iMouse.y/scale));\n    ivec2 swp = swizziling(imousePos,1<<maxLevels);\n    if (iuv.x == swp.x && iuv.y == swp.y )\n        fragColor = vec4(0.192,0.647,0.192,1.);\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 countingDownsample(int size, int iter,vec2 fragCoord)\n{\n    ivec2 coord = ivec2(int(fragCoord.x), int (fragCoord.y));\n    int mask = (size<<1) -1;\n    int xMin = (~(((size<<1)>>iter)-1)) & mask;\n    int xMax = xMin + (size >> iter);\n    \n    if ( (size >> iter) > 0&& coord.x >= xMin && coord.y < (size >> iter) && coord.x < xMax)\n    {\n        if (iter == 0 )\n        {\n            vec4 col= texelFetch(iChannel0, coord,0).xxxx;\n            col = step(col,vec4(THRESHOLD));\n            return vec4(col);\n        }\n        else\n        {\n            ivec2 base = (coord - ivec2(xMin,0))*2;\n            base.x += xMin - (size>>iter-1);\n            float p1 = (texelFetch(iChannel1, base+ivec2(0,0),0)).x;\n            float p2 = (texelFetch(iChannel1, base+ivec2(0,1),0)).x;\n            float p3 = (texelFetch(iChannel1, base+ivec2(1,0),0)).x;\n            float p4 = (texelFetch(iChannel1, base+ivec2(1,1),0)).x;\n            float total = p1+p2+p3+p4;\n            return vec4(total);\n        }\n    }\n\n    return texelFetch(iChannel1, coord,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    ivec2 coord = ivec2(int(fragCoord.x), int (fragCoord.y));\n    \n    \n    int maxIters = int(log2(float(MAX_SIZE)));\n    int size = int(pow(2., float(maxIters)));\n\n    int iter = iFrame%(maxIters+1);\n    if ( iter <= maxIters )\n        fragColor = countingDownsample(size, iter,fragCoord);\n    else\n       fragColor = texelFetch(iChannel1,coord,0);\n    return;\n \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//how many cells\n#define MAX_SIZE 16  \n//how many \"white\" cells \n#define THRESHOLD ( floor(mod(iTime,100.)) / 100. *0.3+ 0.3 )\n\nivec2 levelOrigin(int level, int maxLevel)\n{\n    int rightMost = (1<<(maxLevel+1))-2;\n    return ivec2(rightMost - ((1<<level+1)-2),0);\n}\n\n\nivec2 swizzling( ivec2 pos , int size)\n{\n    int linearAddr = pos.y*size + pos.x;\n    int osize = size;\n    ivec2 p = ivec2(0,0);\n    size/=2;\n    int x = 0;\n    int y = 0;\n    while(size > 0)\n    {\n        int q = size*size;\n        int b = linearAddr/q;\n        int base = b*q;\n        linearAddr -= base;\n        if (b == 1)\n            x+=size;\n        if (b == 2)\n            y+=size;         \n        if (b == 3)\n        {\n            x+=size;\n            y+=size;         \n        }\n        \n        size /=2;\n    }\n    return ivec2(x,y);\n}\n\nivec2 unSwizzling( ivec2 pos , int size)\n{\n    //this is amazing\n    pos = swizzling(pos,size);\n    pos = swizzling(pos,size);\n    return pos;\n}\n\n","name":"Common","description":"","type":"common"}]}