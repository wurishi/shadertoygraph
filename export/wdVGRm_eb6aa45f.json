{"ver":"0.1","info":{"id":"wdVGRm","date":"1569943981","viewed":146,"name":"Thorny Partitions","username":"104","description":"Creating chaos by dividing space recursively-ish","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","partition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define POINTS 3\n#define PARTITIONS 12\n\nconst float PI2 = 6.28;\n\nvec2 min2(vec2 lhs, vec2 rhs) {\n    if (lhs.x < rhs.x)\n        return lhs;\n    return rhs;\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 N = C/R-.5;\n    vec2 uv = N;\n    uv.x *= R.x/R.y;\n    float t = iTime  *.5;\n    vec3 pts[POINTS];// x,y,seed\n\n    // x = dist, y = pts index\n    vec2 tileFinder = vec2(0);\n    float seed = 1.;\n    for (int ip = 0; ip < PARTITIONS; ++ ip) {\n\n        for (int i = 0; i < POINTS; ++ i) {\n            vec4 h = hash41(seed+float(i));\n            pts[i] = vec3(\n                sin(h.x*PI2+t*h.y),\n                sin(h.y*PI2-t*h.z),\n                h.x\n            )*.3;\n        }\n\n       \t// find the closest pt\n        tileFinder = vec2(length(uv - pts[0].xy), 0);\n        for (int i = 1; i < POINTS; ++ i) {\n            float d = length(uv - pts[i].xy);\n            tileFinder = min2(tileFinder, vec2(d, i));\n        }\n        \n        // center around that point and re-partition\n        uv -= pts[int(tileFinder.y)].xy;\n        uv *= 1.4;\n        seed = pts[int(tileFinder.y)].z;\n    }\n    \n    o = hash41(pts[int(tileFinder.y)].z *1e3)+.02;\n    o *= tileFinder.x;\n    o = clamp(o,0.,1.);\n    o = pow(o,o-o+.4);\n    o *= 1.-dot(N,N);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}