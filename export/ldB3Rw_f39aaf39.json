{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// ray marching const\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float step_scale = 0.5;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math const\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// math\nmat2 rot2( float angle ) {\n\tfloat c = cos( angle );\n\tfloat s = sin( angle );\n\t\n\treturn mat2(\n\t\t c, s,\n\t\t-s, c\n\t);\n}\n\n// pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// distance function\nfloat dist_sphere( vec3 v, float r ) {\n\treturn length( v ) - r;\n}\n\nfloat dist_box( vec3 v, vec3 size, float r ) {\n\treturn length( max( abs( v ) - size, 0.0 ) ) - r;\n}\n\n// get distance in the world\nfloat dist_field( vec3 v ) {\n\t// ...add objects here...\n\t\n\t// box\n\tfloat d2 = dist_box( v + vec3( 0.0, 2.2, 0.0 ), vec3( 8.0, 0.05, 8.0 ), 0.05 );\n\n\t// twist\n\tv.xz = rot2( v.y ) * v.xz;\n\t\n\t// sphere\n\tfloat d0 = dist_sphere( v, 2.7 );\n\t\n\t// box\n\tfloat d1 = dist_box( v, vec3( 2.0, 2.0, 2.0 ), 0.05 );\n\t\t\n\n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn min( d2, max( d1, -d0 ) );\n}\n\n// get gradient in the world\nvec3 gradient( vec3 v ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( v + dx ) - dist_field( v - dx ),\n\t\t\tdist_field( v + dy ) - dist_field( v - dy ),\n\t\t\tdist_field( v + dz ) - dist_field( v - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * step_scale;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// shadow\nfloat shadow( vec3 light, vec3 lv, float len ) {\n\tfloat depth = ray_marching( light, lv, 0.0, len );\n\t\n\treturn step( len - depth, 0.01 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\tconst float shininess = 64.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos = vec3( 7.0, 7.0, 7.0 );\n\t\tvec3 light_color = vec3( 0.9, 0.7, 0.4 );\n\t\t\n\t\tvec3 vl = light_pos - v;\n\t\tfloat len = length( vl );\n\t\tvl /= len;\n\t\n\t\tfloat att = min( 100.0 / ( len * len ), 1.0 );\n\t\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * (\n\t\t\tatt * shadow( light_pos, -vl, len ) * ( diffuse * 0.6 + specular * 0.5 )\n\t\t\t);\n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( 0.0, 1.0, 0.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = light_pos - v;\n\t\tfloat len = length( vl );\n\t\tvl /= len;\n\t\n\t\tfloat att = min( 7.0 / ( len * len ), 1.0 );\n\t\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * (\n\t\t\tatt * shadow( light_pos, -vl, len ) * ( diffuse * 0.9 + specular * 0.9 )\n\t\t\t);\n\t}\n\t\n\t// light 2\n\t{\n\t\tvec3 light_pos   = vec3( -7.0, 7.0, -7.0 );\n\t\tvec3 light_color = vec3( 0.6, 0.3, 0.6 );\n\t\n\t\tvec3 vl = light_pos - v;\n\t\tfloat len = length( vl );\n\t\tvl /= len;\n\t\n\t\tfloat att = min( 122.0 / ( len * len ), 1.0 );\n\t\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * (\n\t\t\tatt * shadow( light_pos, -vl, len ) * ( diffuse * 0.6 + specular * 0.5 )\n\t\t\t);\n\t}\n\n\treturn final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 12.0 );\n\n\t// rotate camera\n\tmat3 rot = rot3xy( vec2( -DEG_TO_RAD*30.0, iTime * 0.5 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tdiscard;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldB3Rw","date":"1385045879","viewed":1924,"name":"Hard Edge Shadow","username":"gltracy","description":"Attenuate Lights with Hard Edge Shadow","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["shadow","attenuate"],"hasliked":0,"parentid":"","parentname":""}}