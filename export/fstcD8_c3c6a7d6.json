{"ver":"0.1","info":{"id":"fstcD8","date":"1653402772","viewed":60,"name":"Dalux Entry","username":"Mystiking","description":"Dalux smashing down unto a sheet of some sort.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["house"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define SURFACE_DIST 0.001\n#define MAX_DIST 1000.0\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nfloat Union(float d0, float d1) {\n    return min(d0, d1);\n}\n\nfloat Intersection(float d0, float d1) {\n    return max(d0, d1);\n}\n\nfloat Difference(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n\nvec3 Rotate(vec3 p, int axis, float angle, vec3 center) {\n    float c = cos(angle * 3.14 / 180.);\n    float s = sin(angle * 3.14 / 180.);\n    mat3 R;\n    if (axis == 0) {\n        R = mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));\n    } else if (axis == 1) {\n        R = mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));\n    } else {\n        R = mat3(vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1));\n    }\n    \n    return R * (p - center) + center;\n}\n\nfloat Box(vec3 p, vec3 center, vec3 size) {\n    vec3 pt = p - center;\n    float p0 = abs(pt.x) - size.x / 2.;\n    float p1 = abs(pt.y) - size.y / 2.;\n    float p2 = abs(pt.z) - size.z / 2.;\n    \n    if (p0 > 0. && p1 > 0. && p2 > 0.) {\n        return sqrt(dot(vec3(p0, p1, p2), vec3(p0, p1, p2)));\n    } else {\n        return vmax(vec3(p0, p1, p2));\n    }\n}\n\nfloat DaluxMainBox(vec3 p, vec3 center, vec3 size, float scale) {\n    size *= scale;\n    float dMainBox = Box(p, center, size);\n    return dMainBox;\n}\n\nfloat DaluxRoof(vec3 p, vec3 center, vec3 size, float scale) {\n    size *= scale;\n    float roofThickness = 0.25 * size.y;\n    \n    vec3 roofCenter = center + vec3(0, size.y, 0);\n    vec3 roofCenterLeft = roofCenter - vec3(size.x * 0.35, 0, 0);\n    vec3 roofCenterRight = roofCenter + vec3(size.x * 0.35, 0, 0);\n    float angle = 40.;\n    \n    float deltaRotation = cos(iTime*10.) - 0.5;\n    vec3 pointOfRotation = center + vec3(0, size.y, 0);\n    float dRoofLeft = Box(Rotate(Rotate(p, 2, angle, roofCenterLeft), 2, 45. * deltaRotation, roofCenter), roofCenterLeft, vec3(size.x, roofThickness, size.z));\n    float dRoofRight = Box(Rotate(Rotate(p, 2, -angle, roofCenterRight), 2, -45. * deltaRotation, roofCenter), roofCenterRight, vec3(size.x, roofThickness, size.z));\n   \n    float dRoof = Union(dRoofLeft, dRoofRight);\n    \n    \n    float dMainBox = DaluxMainBox(p, center, size + vec3(size.x, 0, size.z), scale);\n    \n    return Difference(dRoof, dMainBox);\n}\n\n\nfloat Scene(vec3 p) {\n    float dPlane = p.y;\n    \n    return dPlane;\n}\n\nfloat DaluxLogo(vec3 p, vec3 center, vec3 size) {\n    \n    float dMainBox = DaluxMainBox(p, center, size, 1.);\n    float dRoof = DaluxRoof(p, center, size, 1.);\n\n    return Union(dMainBox, dRoof);\n}\n\nfloat GetDist(vec3 p, int object, vec2 uv) {\n    int numDaluxLogos = 20;\n    vec3 size = vec3(2, 1, 1);\n    float d = MAX_DIST;\n    \n    int resetCounter = int(iTime) / 20;\n    float tz = iTime - float(resetCounter) * 20.0;\n    \n    \n    vec3 t = vec3((cos(iTime)-0.5)*2., (sin(iTime)-0.5)*2., 20. - tz);\n    if (object == 0)\n        d = Scene(p);\n    else if (object == 1)\n        for (int i = 0; i < numDaluxLogos; i++) {\n            vec3 ti = vec3(\n                float(i % 12) * 2.5,\n                float((i * 2) % 5) * 2.5 * cos(float(i) * 30.),\n                i * 2);\n            d = Union(d,\n            DaluxMainBox(\n                p,\n                vec3(0, 0, 6) + t + ti, size, 1.));\n        }\n    else if (object == 2)\n        for (int i = 0; i < numDaluxLogos; i++) {\n            vec3 ti = vec3(\n                float(i % 12) * 2.5,\n                float((i * 2) % 5) * 2.5 * cos(float(i) * 30.),\n                i * 2);\n            d = Union(d, DaluxRoof(p, vec3(0, 0, 6) + t + ti, size, 1.));\n        }\n    return d;\n}\n\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection, int object, vec2 uv) {\n    float dOrigin = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = rayOrigin + dOrigin * rayDirection;\n        float dScene = GetDist(p, object, uv);\n        dOrigin += dScene;\n        if (dScene < SURFACE_DIST || dOrigin > MAX_DIST) break;\n    }\n    return dOrigin;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 camera = vec3(0, 0.5, 0);\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord-0.5 * iResolution.xy) / iResolution.y;\n    vec3 viewDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    float dScene = RayMarch(camera, viewDirection, 0, uv);\n    float dBody = RayMarch(camera, viewDirection, 1, uv);\n    float dRoof = RayMarch(camera, viewDirection, 2, uv);\n    \n    vec3 daluxGreen = vec3(55., 78., 24.) / 255.;\n    vec3 daluxGrey  = vec3(25., 35., 42.) / 255.;\n    vec3 lightBlue = vec3(173,216,230) / 255.;\n    vec3 sand = vec3(220, 192, 139) / 255.;\n    float addedLight = 0.05;\n    vec3 col;\n    if (dRoof < MAX_DIST && dRoof < dBody) {\n        col = daluxGrey + addedLight;\n    } else if (dBody < MAX_DIST && dBody < dRoof){\n        col = daluxGreen + addedLight;\n    } else if (dScene < MAX_DIST) {\n        col = sand + vec3(0, 0, 1. / dScene * 0.25);\n    } else {\n        col = lightBlue;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}