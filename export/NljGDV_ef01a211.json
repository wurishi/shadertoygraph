{"ver":"0.1","info":{"id":"NljGDV","date":"1624762240","viewed":269,"name":"cloud in a bubble 2","username":"bloodnok","description":"A cloud in a bubble, with a light source in the middle.\nThe sphere intersections are raytraced, rays through the sphere and to the light source are raymarched in regular steps. \nThere will be much much faster ways to do this.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","cloud","atmosphere"],"hasliked":0,"parentid":"flS3zy","parentname":"cloud in a bubble"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927\n/*\n\t@geofftnz\n\n\tforking someone's raytraced sphere in order to do some material testing.\n    atmospheric scattering attempt.\n    \n    Basic idea:\n    Ray traced sphere, ray march through interior.\n    Accumulate Mie+Rayleigh scattering\n    Accumulate air and cloud density.\n    At each point on the primary ray march, do a secondary ray march towards the light source to calculate amount of light reaching point.\n    \n    Full of bugs & fudge factors.\n\n*/\n// atmospheric scattering specifics\n\n// Rayleigh absorbtion constant. Controls how different frequencies are scattered. Makes the sky blue.\nvec3 Kr = vec3(0.1287, 0.2698, 0.7216);\n\n// Mie scattering\nfloat miePhase = 0.95;\nfloat mieAmount = 0.1;\n\n// Rayleigh scattering\nfloat ralPhase = -0.01;\nfloat rayleighAmount = 1.9;  // how blue is your sky?\n\nfloat absorbCoeff = 0.6;  // how much the air absorbs light.\nfloat cloudScatter = 20.0;  // amount of omni-directional scatter off clouds.\nfloat cloudAbsorbFactor = 50.0;  // attenuation by clouds.\nfloat cloudMie = 50.0; // amount of Mie scattering by clouds\n\nfloat airDensityBase = 0.25;\n\nvec3 lightcol = vec3(2.0,10.0,0.9); // overridden below\nfloat lightFallOff = 2.0;\n\nvec4 sph1 = vec4 (0.0,0.0,0.0,1.0);\n\nfloat airIOR = 1.0;\nfloat sph1IOR = 1.05;\n\nfloat backgroundLevel = 0.05;  // brightness of background cubemap\n\n// ray step sizes. Increase for more performance. Decrease for better quality. Set to zero to crash.\nfloat primaryRayStepSize = 0.05;\nfloat secondaryRayStepSize = 0.1;\nfloat dither = 0.8; // dither ray start position by this proportion of step size.\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n// credit: iq/rgba\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n\n\treturn n;\n}\n\n//------------------------------------------------------------------------------\n// Colour space transform\n//------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Academy_Color_Encoding_System#Converting_ACES2065-1_RGB_values_to_CIE_XYZ_values\nvec3 RGBtoXYZ(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(0.9525523959,0.3439664498,0.0),\n        \tvec3(0,0.7281660966,0.0),\n        \tvec3(0.0000936786,-0.0721325464,1.0088251844)\n        );\n    return x * col;\n}\n\nvec3 XYZtoRGB(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(1.0498110175,-0.4959030231,0.0),\n        \tvec3(0.0,1.3733130458,0.0),\n        \tvec3(-0.0000974845,0.0982400361,0.9912520182)\n        );\n    return x * col;\n}\n\n\n//============================================================\n// credit: demofox https://www.shadertoy.com/view/4tyXDR\n#define OBJECT_REFLECTIVITY 0.1 // How reflective the object is. regardless of fresnel.\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n    return ret;\n}\n\n\n\nfloat pointRayDistance(vec3 ro, vec3 rd, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\tif (cosvu<0.0) return length(p-ro);\n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\n\nstruct iRayIntersection\n{\n    float t;      // intersection point along ray\n    vec3 normal;  // normal of surface at intersection\n    uint obj;     // id of intersected object, 0 on no intersection\n    float inside; // < 0.0 if inside object, >= 0.0 if outside\n};\n\niRayIntersection irSphere(vec3 ro, vec3 rd, vec4 sph, uint obj)\n{\n    iRayIntersection res;\n    res.t = -1.0;\n    res.normal = vec3(1.0,0.0,0.0);\n    res.obj = 0u;\n    res.inside = 0.0;\n    \n    // sphere intersection\n\tvec3 oc = ro - sph.xyz;       // ray origin relative to centre of sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-sph.w*sph.w;   // if c < 0.0, ray origin is inside sphere\n\tfloat det = b*b - 4.0*c;   // determinant = b^2-4ac  (a==1)\n    \n    if (det >= 0.0)  // we have at least one solution\n    {\n        float detsqrt = sqrt(det);\n        res.obj = obj;\n        \n        res.inside = c;\n        \n        res.t = (res.inside < 0.0)\n        ? (-b + detsqrt)*0.5  // inside sphere\n        : (-b - detsqrt)*0.5;  // outside sphere\n        \n        // sphere normal\n        res.normal = normalize((ro + rd * res.t) - sph.xyz);\n        \n        if (c<0.0) res.normal = -res.normal; // flip normal if we started inside sphere.\n    }\n    \n    return res;\n}\n\n// scene description\niRayIntersection irScene(vec3 ro, vec3 rd)\n{\n    iRayIntersection res;\n    res.t = 1000000.0;\n    res.normal = vec3(1.0,0.0,0.0);\n    res.obj = 0u;\n    res.inside = 0.0;\n    \n    iRayIntersection res2 = irSphere(ro,rd,sph1,1u);\n    \n    if (res2.obj > 0u && res2.t < res.t)\n    {\n        res = res2;\n    }\n    \n    return res;    \n}\n\n\nfloat iSphere (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b - sqrt(h))/2.0;\n\treturn t;\n}\n\nfloat iSphereInside (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b + sqrt(h))/2.0;\n\treturn t;\n}\n\nvec3 nSphere (in vec3 pos, in vec4 sph){\n\treturn (pos - sph.xyz) / sph.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd){\n\t//eq. of a plane, y=0 = ro.y + t*rd.y\n\treturn -ro.y/rd.y;\n}\n\nvec3 nPlane( in vec3 pos){\n\treturn vec3(0.0,1.0,0.0);\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT){\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere (ro, rd, sph1); //intersect with sphere\n\tfloat tpla = iPlane (ro,rd); //intersect with plane\n\tif (tsph > 0.0){\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\tif (tpla > 0.0 && tpla < resT){\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t}\n\treturn id;\n}\n\n\n// mie/rayleigh phase - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\n// sensible g: mie:0.97, ral:-0.01\nfloat phase(float alpha, float g){\n    float gg = g*g;\n    float a = 3.0*(1.0-gg);\n    float b = 2.0*(2.0+gg);\n    float c = 1.0+alpha*alpha;\n    float d = pow(1.0+gg-2.0*g*alpha, 1.5);\n    return (a/b)*(c/d);\n}\n\n// exponential absorbtion - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\nvec3 absorb(float dist, vec3 col, float f)\n{\n    vec3 c = col;    \n    c *= (vec3(1.0) - pow(Kr, vec3(f / max(dist,0.0000000001))));\n    //c *= (vec3(1.0) - pow(vec3(0.05,0.7,0.9), vec3(f / max(dist*0.5,0.0000000001))));\n    //c *= (vec3(1.0) - pow(vec3(0.01,0.85,0.9), vec3(f / max(dist*0.1,0.0000000001))));\n    return c;\n}\n\nfloat cloudAbsorb(float cloud)\n{\n    return exp(-cloud * cloudAbsorbFactor);\n}\n\nfloat airDens(vec3 pos){\n    \n    //return 5.0 * exp(-7.0 * alt) * (1.0-alt);  // last factor is lies, but makes sure we end at 0.0 at edge of atmosphere\n    return airDensityBase;\n}\n\n// calculate cloud density\n// hpos is centre of sphere to hollow out\nfloat cloud(vec3 pos, vec3 hpos){\n\n    vec3 pos2 = pos - sph1.xyz;\n    float density = 1.0-smoothstep(0.3,0.95,dot(pos2,pos2));\n    \n    vec3 hpos2 = pos-hpos;\n    density *= smoothstep(0.0,0.05,dot(hpos2,hpos2));\n\n    pos += vec3(17.3,6.9,0.19) * iTime * 0.02;\n    \n    //return smoothstep(0.8,1.2,fbm(pos*2.0))*max(0.0,fbm(pos*2.0)-1.0);\n    return max(0.0,(fbm(pos*2.3)* density)-0.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    Kr = RGBtoXYZ(Kr);\n\n\tvec3 light = normalize( vec3(0.5,1.0,0.5));\n\t//uv are the pixel coordinates, from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tp = -1.0 + 2.0*p;\n\tp.x *= iResolution.x/iResolution.y;\n\n\n    vec3 mse = iMouse.xyz;\n    if (mse.z <= 0.0){  // default view\n        mse.x = iResolution.x * 0.5;\n        mse.y = iResolution.y * 0.5;\n    }\n\n    // turn mouse into spherical coords\n\tvec2 nMouse = (mse.xy / iResolution.xy)* PI;\n\tfloat th = nMouse.y; \n\tfloat ph = -nMouse.x * 2.0;\n    \n    if (mse.z <= 0.0){  // default view\n        ph += iTime * 0.8;\n    }\n    \n\t//vec3 ro = vec3(0.0,1.1,2.0); //camera position\n    vec3 ro;\n    float camdist = 2.0;\n\tro.x = sin(th) * cos(ph) * camdist;\n\tro.z = sin(th) * sin(ph) * camdist;\n\tro.y = cos(th) * camdist;\n\n\n\tvec3 lookAt = sph1.xyz;\n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(vec3(0,1,0), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd0 = normalize(front*1.5 + left*p.x + up*p.y); // rect vector\n\n    /*\n\tlight.x = sin(th) * cos(ph);\n\tlight.z = sin(th) * sin(ph);\n\tlight.y = -cos(th);\n\tlight = normalize(light);\n    */\n    light = normalize(vec3(1.0,1.0,1.0));\n    vec3 lightpos = sph1.xyz;\n    \n    lightpos += vec3(sin(iTime * 0.3),sin(iTime * 0.37),sin(iTime * 0.47)) * 0.6;\n    \n    lightcol = (normalize(vec3(sin(iTime*0.15),sin(iTime*0.17),sin(iTime*0.19))) * 0.5 + 0.5) * 20.0;\n\t\n    iRayIntersection hit = irScene(ro,rd0);  // intersect primary ray with scene\n\n\tvec3 col = vec3(0.0);\n    float airDensity = 0.0;\n    float cloudDensity = 0.0;\n    float cloudAttenuation = 1.0;\n\n\t\n\tif (hit.obj == 1u)  // we've hit our transparent sphere\n    {\n    \n\t\tro = ro + hit.t*rd0;\t//move to our hit position\n        \n        // calculate new ray direction based on refraction\n        vec3 rd = refract(rd0,hit.normal,airIOR / sph1IOR);\n        \n        // do another trace along our refracted ray to find the exit position in the sphere\n        float tfar = iSphereInside(ro,rd,sph1);\n        \n       \n        // now we raymarch through the sphere along the refracted ray and accumulate scattered light\n\n        // setup scattering - parallel light source\n        //float mie = phase(dot(rd,light),miePhase) * mieAmount; // relative amount of Mie scattering.\n        //float rayleigh = phase(dot(rd,light),ralPhase) * rayleighAmount; // relative amount of Rayleigh scattering.\n                \n        // step through scattering medium, cast rays to lightsource to determine shadow.\n        float litDensity = 0.0;\n        float dt = tfar * primaryRayStepSize;\n        float hh = hash(iTime + dot(rd+ro,vec3(12.65898,37.3516781,17.651651)));  // add a little noise to the start of the ray traversal so smooth out banding.\n            \n        vec3 mieAccum = vec3(0.0);\n        vec3 rayleighAccum = vec3(0.0);\n        vec3 cloudAccum = vec3(0.0); // scatter from clouds\n        vec3 totalInflux = vec3(0.0);\n            \n        // raymarch through sphere:\n        // - calculate cumulative absorption\n        // - calculate influx at each point\n        //   - raymarch towards sun & repeat above process.\n\n        for(float t = hh * primaryRayStepSize * dither; t < tfar; t+=dt){\n\n            vec3 apos = ro + rd * t;  // position along atmosphere ray\n\n            float stepCloudDensity = cloud(apos,lightpos) * dt;\n            cloudDensity += stepCloudDensity; // total cloud density along path\n\n            float stepDensity = airDens(apos) * dt;  // calculates amount of air for this step\n\n            airDensity += stepDensity;  // total air density from viewer to point\n\n            //vec3 influx = lightcol;  // incoming light (todo: calculate this)\n            vec3 influx = vec3(0.0);\n\n            // do another raycast towards the sun\n            //float tsun = iSphereInside(apos, light, sph1); // cast ray to sun, intersect with inner edge of sphere\n            \n            float tsun = length(lightpos - apos);\n            vec3 rdLight = normalize(lightpos - apos);\n            \n            float mie = phase(dot(rd,rdLight),miePhase) * mieAmount; // relative amount of Mie scattering.\n            float rayleigh = phase(dot(rd,rdLight),ralPhase) * rayleighAmount; // relative amount of Rayleigh scattering.\n            \n            float dtl = tsun * secondaryRayStepSize; // keep it rather chunky, don't want to bog down\n            float airToLight = 0.0;\n            float cloudToLight = 0.0;\n            float hh2 = hash(iTime + dot(apos,vec3(12.65898,37.3516781,17.651651)));\n\n            for (float tl = hh2 * secondaryRayStepSize * dither; tl < tsun; tl += dtl){\n\n                vec3 spos = apos + rdLight * tl;\n                cloudToLight += cloud(spos,lightpos) * dtl;  // acumulate cloud density\n                airToLight += airDens(spos) * dtl;\n            }\n\n            influx = absorb(airToLight,lightcol,absorbCoeff) * cloudAbsorb(cloudToLight) * (1.0 / (1.0 + tsun*tsun*lightFallOff)); \n\n            cloudAttenuation = cloudAbsorb(cloudDensity); \n\n            rayleighAccum += absorb(airDensity,influx * Kr * rayleigh * stepDensity,absorbCoeff) * cloudAttenuation;\n\n            // mie from air + cloud\n            mieAccum += absorb(airDensity,influx * (mie * (stepDensity + stepCloudDensity*cloudMie) + (cloudScatter*stepCloudDensity)),absorbCoeff) * cloudAttenuation;\n        }\n        \n        // refract through to background\n        vec3 background = texture(iChannel1,rd).rgb * backgroundLevel; \n        col += absorb(airDensity,background,absorbCoeff) * cloudAttenuation;\n\n\n        col += mieAccum;\n        col += rayleighAccum;\n\n        // sun disc\n        //float mie_eye = phase(dot(rd,light),0.9995) * 0.001; // relative amount of Mie scattering.\n        //col += absorb(airDensity,lightcol,absorbCoeff) * mie_eye * cloudAttenuation;\n\n        // add some fresnel reflection\n        vec3 refl = reflect(rd0,hit.normal);\n        float reflAmount = FresnelReflectAmount(airIOR,sph1IOR,hit.normal,rd0);\n        col = col * (1.0-reflAmount) + texture(iChannel1,refl).rgb * reflAmount * backgroundLevel;\n\n\n        \n\n\t}else{\n        // default colour = background hit to skybox\n        col = texture(iChannel0,rd0).rgb * backgroundLevel;\n        \n        //col += lightcol * phase(dot(rd0,light),0.9995) * 0.001; // relative amount of Mie scattering.\n\t}\n\n\n    // ACES to RGB\n    col = XYZtoRGB(col);\n\n    // reinhardt HDR tonemapping\n\tfloat whitelevel = 5.0;\n\tcol = (col  * (vec3(1.0) + (col / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + col);\t\n\n    // gamma\t\n\tcol = pow(col,vec3(1.0/2.0));\n\n\t\n\tfragColor = vec4(col,1.0);\n\t\n}\n","name":"Image","description":"","type":"image"}]}