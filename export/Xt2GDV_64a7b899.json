{"ver":"0.1","info":{"id":"Xt2GDV","date":"1432714426","viewed":284,"name":"NASA flag remake","username":"104","description":"A remake of \"International NASA Earth Flag\" by lamogui ( https://www.shadertoy.com/view/4l23DK ). The compulsive part of me wanted to get those little details. It's still not 100% perfect, because of dimensions, but the overlapping should be all correct.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","logo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// a remake of \n// \"International NASA Earth Flag\" by lamogui \n// https://www.shadertoy.com/view/4l23DK\n\n// looks easy, but there are subtle challenges to get it PERFECT:\n// - ring intersections have many exceptions. they are interconnected.\n// - there are exceptions to the ring \"borders\" to avoid weird geometry around intersections\n\n// So, I wanted to take lamogui's version and make a version that has\n// the following properties:\n// - anti-aliased. for this i converted everything to using distance fields\n// - uses a sensible way to express \"exceptions\" in the ring intersections.\n//   for this i have a function that can swap rings' z-order.\n// - render the illustration as perfectly as possible\n\n// picture of the original flag image:\n// https://metrouk2.files.wordpress.com/2015/05/nasa-flag.jpg?quality=80&strip=all&strip=all&w=768&h=513&crop=1\n\n\n\n\n\n// comment this to see the image with no exception detailing\n#define DO_EXCEPTIONS\n\n\n\n\n\nconst vec3 blue=vec3(1./255., 59./255., 166./255.);\nconst vec3 white=vec3(1.);\nconst float innerRadius=0.25;\nconst float outerRadius=0.272;\nconst float borderWidth = 0.024;\nconst float positionRadius = 0.259;\n\nconst float ringCount = 6.;\nconst float startingRing = 0.;\n//const float highlightRing = 31.;\n\nfloat smoothFalloff = .0045;\n\n\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nvec2 rot2D(vec2 p, float a)\n{\n    return vec2(p.x*cos(a)-p.y*sin(a),p.x*sin(a) + p.y*cos(a));\n}\n\nfloat dtoa(float d, float amount)\n{\n    return 1.0 - smoothstep(0.0, amount, d - amount * 0.5);\n}\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\n\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    float d = length(uv - origin) - radius;\n    return d;\n}\nfloat sdDonut(vec2 uv, vec2 center, float innerRadius, float outerRadius)\n{\n    return opS(sdCircle(uv, center, outerRadius), sdCircle(uv, center, innerRadius));\n}\n\nbool isAngleBetween(float x, float a, float b)\n{\n    x = mod(x - a, pi2);\n    return x >= 0. && x <= mod(b - a, pi2);\n}\n\nfloat flip(float i, float a, float b)\n{\n    if(i == a) return b;\n    if(i == b) return a;\n    return i;\n}\n\n\n// one kind of exception is z-ordering. at certain locations in the\n// graphic, rings are \"flipped\". the bottom ring gets flipped to the top.\n// here i check for these exceptions.\nfloat mapI(float i, float a, float distToCenter)\n{\n#ifndef DO_EXCEPTIONS\n    return i;\n#endif\n    if(distToCenter > innerRadius)\n    {\n        if(isAngleBetween(a, 2.5, 3.5))// 6 o-clock\n            return flip(i, 4., 5.);\n        if(isAngleBetween(a, 3.5, 4.5))// 8 o-clock\n            return flip(i, 3., 4.);\n        return flip(i, 2., 3.);\n    }\n    if(distToCenter < innerRadius - 0.1)\n\t    return flip(i, 0.,3.);// inner area... just \n    return i;\n}\n\n// another kind of detail exception is around intersections, sometimes the blue\n// border forms weird geometry. here i test for these scenarios and conditionally\n// don't draw the border.\nbool shouldDrawBorder(float i, float a, float distToCenter)\n{\n#ifndef DO_EXCEPTIONS\n    return true;\n#endif\n    // around the intersections with the center ring\n    if(distToCenter > innerRadius - 0.1 && distToCenter < outerRadius + 0.1)\n    {\n\t    if(i == 3. && isAngleBetween(a, 5., 6.))\n            return false;\n\t    if(i == 2. && isAngleBetween(a, 0., 1.))\n            return false;\n\t    if(i == 5. && isAngleBetween(a, 1., 2.))\n            return false;\n\t    if(i == 4. && isAngleBetween(a, 4., 5.))\n            return false;\n\t    if(i == 3. && isAngleBetween(a, 3., 4.))\n            return false;\n    }\n    return true;\n}\n\nvec3 earth_flag(vec2 uv)\n{\n    float distToHighlight = 100.;// for debugging\n    float dist = 100.0;// far\n    \n    float a = atan(uv.x,uv.y);\n    float distToCenter = length(uv);\n    \n    // draw rings\n    for (float i = 0.; i < ringCount; i++)\n    {\n        float realI = mapI(i, a, distToCenter);\n        vec2 center = rot2D(vec2(positionRadius, .0), (realI+startingRing) * pi2 / ringCount);\n        \n#ifdef DO_EXCEPTIONS\n        if(i == 3.)\n        {\n        \t// the center ring is obscured by rings >3 and 4. so draw the center ring now\n            dist = opU(dist, sdDonut(uv, vec2(0.), innerRadius, outerRadius));\n        }\n#endif\n        // blue border\n        if(shouldDrawBorder(realI, a, distToCenter))\n\t        dist = opS(dist, sdDonut(uv, center, innerRadius - borderWidth, outerRadius + borderWidth));\n\n        // white donut\n        dist = opU(dist, sdDonut(uv, center, innerRadius, outerRadius));\n\n        // debug code\n/*        if(i == highlightRing)\n        {\n\t        center = rot2D(vec2(positionRadius, .0), (i+startingRing) * pi2 / ringCount);\n            distToHighlight = sdDonut(uv, center, innerRadius, outerRadius);\n        }//*/\n    }\n\n    // draw center circle\n#ifdef DO_EXCEPTIONS\n    if(!isAngleBetween(a, 2., 4.))// don't cover up the work we did above for rings 3 & 4\n#endif\n    {\n\t    dist = opS(dist, sdDonut(uv, vec2(0.), innerRadius - borderWidth, outerRadius + borderWidth));\n  \t\tdist = opU(dist, sdDonut(uv, vec2(0.), innerRadius, outerRadius));\n    }\n    \n    // convert distance to color.\n    float alpha = dtoa(dist, smoothFalloff);\n    vec3 onColor = mix(white, vec3(1.0,0.,0.), dtoa(distToHighlight, smoothFalloff));\n    vec3 ret = mix(blue, onColor, alpha);\n\n    // for debugging\n    //if(isAngleBetween(a, 2.0, 3.0))\n    //    return mix(ret, vec3(1.0,0.,0.), 0.3);\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = fragCoord.xy / iResolution.xy;\n    vec2 uv=v*2.-vec2(1.);\n    uv.x*=iResolution.x/iResolution.y;\n    if(iResolution.x < 400.) uv *= 0.6;// make it bigger for thumbnail version\n\tfragColor = vec4(earth_flag(uv),1.);\n}\n","name":"","description":"","type":"image"}]}