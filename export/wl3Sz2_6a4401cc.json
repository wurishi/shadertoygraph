{"ver":"0.1","info":{"id":"wl3Sz2","date":"1581342993","viewed":468,"name":"Plane Grid AA","username":"spalmer","description":"draws an analytically antialiased grid plane.\ncan compare methods split-window using mouse click.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["grid","antialias","plane","splitscreen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// derived from https://shadertoy.com/view/3tVGRz\n// see also https://shadertoy.com/view/wt3Sz2\n\n// a simple testbed for rendering an antialiased grid plane.\n// can contrast various filtering methods.\n// no texture samplers used!\n\n// thicker than .5 makes squares, not grids\nfloat gridThickness = .1; //.2; //.25; //.02; //.4; //\n\nconst vec3 Cfill = vec3(1.,1.,.9); //1.,1.,1.); //1.,1.,0.); //\nconst vec3 Cgrid = vec3(0.,0.,0.); //1.,0.,1.);\nconst vec3 Csky = vec3(.8,.9,1.);\n\n\n// refactored out the common derivative filtering portion:\n// trivial to change to any dimension.  \n// can ignore the axis not being striped\nfloat filterWidth1(float u)\n{\n    float dx = dFdx(u), dy = dFdy(u);\n    return dx * dx + dy * dy + .0001;\n}\n\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n   // btw fwidth totally works too\n//    vec2 fw = fwidth(uv); return dot(fw, fw) + .0001; //max(fw.x, fw.y) + .0001; //\n//    return max(dot(dx, dx), dot(dy, dy)) + .0001; // tried; looks same to me\n\nfloat filterWidth3(vec3 uvw)\n{\n    vec3 dx = dFdx(uvw), dy = dFdy(uvw);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\n// well, after all the resituating it's not very optimal\n// perhaps I should make a nice centered inset one instead,\n// as reference, so the filtered ones won't have to futz \n// with the zero crossing edge so much\nfloat gridSimple(vec2 p)\n{\n\tvec2 g = step(gridThickness, fract(gridThickness*.5-p));\n\treturn 1.-g.x*g.y;\n}\n\nfloat gridUnfiltered(vec2 p)\n{\n    p -= .5*gridThickness; // center\n    return step(1.-gridThickness, max(fract(p.x),fract(p.y)));\n}\n\nfloat gridAASimple(vec2 p)\n{\n    vec2 f = fract(p);\n    float g = min(min(f.x, 1.-f.x), min(f.y, 1.-f.y)) * 2. - gridThickness\n    , x = step(g, 0.) //gridUnfiltered(p)\n    , w = fwidth(p.x) + fwidth(p.y)\n    , r = 2.*iResolution.y\n    , l = r*abs(g) / (1. + 1.*r*w) // can try different functions, divisor controls fade rate with distance\n    // up close, should blend toward 0.5, but\n    // far away should blend toward gridThickness, maybe sqrt'd?\n    , s = sqrt(gridThickness) //gridThickness*gridThickness //gridThickness //\n    , t = mix(.5, s, min(w, 1.));\n    return mix(t, x, clamp(l, 0., 1.));\n}\n// still not happy with how it fades out too soon,\n// but at least it's basically working.  Better than the others.\nfloat gridSmooth(vec2 p)\n{\n    vec2 q = p;\n    q += .5;\n    q -= floor(q);\n    q = (gridThickness + 1.) * .5 - abs(q - .5);\n    float w = 12.*filterWidth2(p);\n    float s = sqrt(gridThickness);\n    return smoothstep(.5-w*s,.5+w, max(q.x, q.y));\n}\n\n// the half sqrt(gridThickness) bias is fairly tricky; \n// honestly I shouldn't need to involve smoothstep at all here, hold on\n// meh, still not working worth a dern, maybe someday\nfloat gridSmoothLinear(vec2 p)\n{\n    vec2 q = p;\n    q += .5;\n    q -= floor(q);\n    q = (gridThickness + 1.) * .5 - abs(q - .5);\n    float w = 12.*filterWidth2(p);\n    float s = gridThickness;\n    return clamp((max(q.x, q.y) - .5-w*s) / (w*(s+1.)), 0., 1.);\n}\n\n// working better now\nfloat gridExp(vec2 p)\n{\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    float g = min(f.x, f.y);\n    g = max(0., g - .5*gridThickness);\n    g = exp2(-fadePower*g);\n    float s = sqrt(gridThickness);\n    return mix(g, s, exp2(-.02 / filterWidth2(p)));    \n}\n\n// for ilyaev\nfloat gridPow(vec2 p)\n{\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    f = max(vec2(0), 1. - f + .5*gridThickness);\n    f = pow(f, vec2(fadePower));\n    float g = f.x+f.y; //max(f.x, f.y); //\n    float s = sqrt(gridThickness);\n    return mix(g, s, exp2(-.01 / filterWidth2(p)));    \n}\n\n// originally from https://shadertoy.com/view/WlVGDh\n// this is just not the way to do grids, blurs\n// the corners too much, but it sort of works:\nfloat gridSine(vec2 p)\n{\n    p *= 3.1415927;\n    float g = sin(p.x) * sin(p.y); // grid texture\n    g *= g; g = max(0., 1. - g);\n    g = pow(g, 8./gridThickness);\n    float s = .75*sqrt(gridThickness); // HACK idk\n    g = mix(g, s, min(1., 1.*filterWidth2(p))); //length(fwidth(p)))); // aa\n\treturn g;\n}\n\n// similar but with parabola - still just wrong at corners\nfloat gridPara(vec2 p)\n{\n    vec2 q = fract(p);\n    q = max(vec2(0), .5 - gridThickness*.5 - abs(.5 - q));\n    q *= 1.-q; q = 4.*q;\n    float g = 1.-q.x*q.y;\n    g = pow(g, 1./gridThickness);\n    float s = sqrt(gridThickness);\n    g = mix(g, s, min(1., 4.*filterWidth2(p))); //length(fwidth(p)))); // aa\n\treturn g;\n}\n\n// shown on right side of split screen\nfloat ImageR(vec2 uv)\n{\n    return gridAASimple(uv);\n    return gridSmooth(uv);\n    return gridPow(uv);\n    return gridSine(uv);\n    return gridExp(uv);\n    return gridPara(uv);\n    return gridSmoothLinear(uv);\n//    return gridSimple(uv);\n//    return gridUnfiltered(uv);\n}\n\n// shown on left half of split screen\nfloat ImageL(vec2 uv)\n{\n//    return gridSimple(uv);\n    return gridUnfiltered(uv);\n}\n\n\nconst float maxd = 85000.;\n\n// halfspace\nfloat tracePlaneY(vec3 rp, vec3 rd)\n{\n    return rp.y <= 0. ? 0. :\n    \trd.y >= 0. ? -1. :\n    \trp.y / -rd.y;\n}\n\n\nvec2 rot(inout vec2 v, vec2 cs)\n{\n    float c = cs.x, s = cs.y; // cs is a cosine,sine pair representing angle of rotation\n    return v = vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvec2 rot(inout vec2 v, float radians)\n{\n    return rot(v, vec2(cos(radians), sin(radians)));\n}\n\n\nvec3 CameraRay(vec2 p)\n{\n    vec2 q = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(q / 2., 1.));\n    float pitch = .4, yaw = iTime * .04;\n    rot(rd.yz, pitch);\n    rot(rd.xz, yaw);\n    return rd;\n}\n\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    // a simple camera\n    vec3 rp = vec3(0,1,0);\n    rp.y += sin(iTime * 0.07) * .99; // bob slowly up and down\n    vec3 rd = CameraRay(p);\n    \n    // Y plane distance\n    float d = maxd;\n    float dplane = tracePlaneY(rp, rd);\n    vec2 cc = vec2(1, 0);\n    if (dplane >= 0.) {\n        d = min(d, dplane);\n\t    cc = rp.xz + rd.xz * d; // grid uv at hit point\n    \tcc *= 4.; // tiling\n    }\n    \n    // split screen at mouse click\n    float splits = p.x - iMouse.x;\n    bool left = splits < 0.;\n    // depending on last mouse click, split screen between two different functions\n    float gridline = left \n        ? ImageL(cc)\n        : ImageR(cc);\n\n    c.rgb = mix(Cfill, Cgrid, gridline); // colorize\n    \n    // no actual lighting in this simple test,\n    // but a few dot products would do it.\n    \n    float fog = 1.0 - exp2(-.03*d); //0.; //\n    c.rgb = mix(c.rgb, Csky, fog);\n    // green vertical line at split\n    c.rgb = mix(c.rgb, vec3(.0,.5,.0), exp2(-2. * abs(splits)));\n    \n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n    c.a = 1.;\n}\n\n\n\n\n//  if (!(d >= 0.)) d = maxd; // handle possible nan\n//  float dflat = d / rd.z;\n//  float aa = 1.0 - exp2(-.03*d); // HACK\n//    float g = exp2(-.03*d);\n//    c = vec3(g); // debug depths\n","name":"Image","description":"","type":"image"}]}