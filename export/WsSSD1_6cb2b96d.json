{"ver":"0.1","info":{"id":"WsSSD1","date":"1553600569","viewed":122,"name":"Gulp gulp","username":"KavabONga","description":"Yay, got to make some smoothing functions. I actually thought it would be much more difficult.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float deSphere(vec3 spherePos, float radius, vec3 pos) {\n\treturn length(spherePos - pos) - radius;\n}\n\nfloat deBox( vec3 center, vec3 b, vec3 p) {\n    vec3 d = abs(p - center) - b;\n    return length(max(d,0.0))\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat deUnion(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nfloat deIntersection(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\nfloat deSmoothUnion(float d1, float d2, float k) {\n\tfloat h = clamp(.5 + .5 * (d1 - d2) / k, 0., 1.);\n    return mix(d1, d2, h) - k * h * (1. - h);\n}\n\nfloat deSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp(.5 + .5 * (d2 - d1) / k, 0.0, 1.0 );\n    return mix(d2, d1, h) + k * h * (1.0 - h); \n}\n\nfloat de(vec3 pos) {\n    return deSmoothUnion(\n        deSmoothUnion(deSphere(vec3(sin(iTime) * 3., 0., 6.), 1., pos), deSphere(vec3(-sin(iTime) * 3., 0., 6.), 1., pos), .5),\n        deBox(vec3(0., sin(iTime) * 2., 6.), vec3(1.), pos), 1.\n    );\n}\n\nvec3 getNormal(vec3 pos) {\n    vec2 offset = vec2(0.0001, 0.);\n\treturn normalize(\n        vec3(\n            de(pos + offset.xyy) - de(pos - offset.xyy),\n            de(pos + offset.yxy) - de(pos - offset.yxy),\n            de(pos + offset.yyx) - de(pos - offset.yyx)\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos2 = (fragCoord  - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 sun = vec3(-1., -1., 2.);\n    \n    vec3 pos = vec3(pos2, 1.), dir = normalize(pos);\n    \n    const int Steps = 60;\n    const float minDistance = 0.0001; \n    float mind = 10000., di;\n    int i;\n    \n    for (i = 0, di = 0.; i < Steps; i++) {\n    \tfloat d = de(pos);\n        mind = min(mind, d);\n        di = di + step(mind, minDistance);\n        pos += dir * d;\n    }\n    vec3 n = getNormal(pos);\n    vec3 reflection = normalize(reflect(pos, n));\n    \n    float light =  clamp(dot(n, -normalize(sun)), 0., 1.);\n    float alpha = 1. - step(minDistance, mind);\n    \n    vec4 background = vec4(0.2, 0.2, 1., 1.) * (pos2.y + 0.7);\n    vec4 scene = vec4(1.) * light;\n    fragColor = mix(scene, background, 1. - alpha);\n}","name":"Image","description":"","type":"image"}]}