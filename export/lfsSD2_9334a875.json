{"ver":"0.1","info":{"id":"lfsSD2","date":"1707732405","viewed":27,"name":"[inspirnathan] 00 - introduction","username":"hrst4","description":"[inspirnathan] 00 - introduction","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci √† lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/47-shadertoy-tutorial-part-1\n\n/*\nSalutations, chers amis ! J'ai r√©cemment √©t√© fascin√© par les shaders et \nleur incroyable qualit√©. Aujourd'hui, je vais vous expliquer comment cr√©er \ndes shaders de pixels √† l'aide d'un outil en ligne extraordinaire appel√© Shadertoy, \ncr√©√© par Inigo Quilez et Pol Jeremias, deux personnes extr√™mement talentueuses.\n\nQu'est-ce qu'un shader ?\n\nLes shaders sont des programmes puissants qui, √† l'origine, √©taient destin√©s √† \nl'ombrage d'objets dans une sc√®ne 3D. De nos jours, les shaders ont de multiples fonctions.\nLes programmes de shaders s'ex√©cutent g√©n√©ralement sur le processeur graphique (GPU) \nde votre ordinateur, o√π ils peuvent fonctionner en parall√®le.\n\n\nIl est extr√™mement important de comprendre que les shaders s'ex√©cutent en parall√®le \nsur votre GPU. \nVotre programme s'ex√©cutera ind√©pendamment pour chaque pixel dans Shadertoy en m√™me temps.\n\n\nLes langages de shaders tels que le High-Level Shading Language (HLSL)\net l'OpenGL Shading Language (GLSL) sont les langages les plus couramment utilis√©s\npour programmer le pipeline de rendu du GPU. \n\nCes langages ont une syntaxe similaire au langage de programmation C.\n\nLorsque vous jouez √† un jeu tel que Minecraft, les shaders sont utilis√©s pour donner\nl'impression que le monde est en 3D lorsque vous le regardez √† partir d'un √©cran en 2D \n(c'est-√†-dire le moniteur de votre ordinateur ou l'√©cran de votre t√©l√©phone).\nLes shaders peuvent √©galement modifier radicalement l'aspect d'un jeu en ajustant\nla fa√ßon dont la lumi√®re interagit avec les objets ou la fa√ßon dont les objets sont\nrendus √† l'√©cran. \n\nCette vid√©o YouTube pr√©sente 10 shaders qui peuvent donner √† Minecraft un aspect\ntotalement diff√©rent et d√©montrer la beaut√© des shaders.\nhttps://www.youtube.com/watch?v=1BnNAu_L4FA\n\n\nLes shaders se pr√©sentent g√©n√©ralement sous deux formes : \nles vertex shaders et les fragment shaders.\nLe vertex shader est utilis√© pour cr√©er les sommets des maillages 3D \nde toutes sortes d'objets tels que des sph√®res, des cubes, des √©l√©phants,\nles protagonistes d'un jeu en 3D, etc. \n\nLes informations fournies par le nuanceur de sommets sont transmises au nuanceur g√©om√©trique,\nqui peut alors manipuler ces sommets ou effectuer des op√©rations suppl√©mentaires \navant le nuanceur de fragments. \n\nVous n'entendrez g√©n√©ralement pas beaucoup parler des nuanceurs de g√©om√©trie. \nLa derni√®re partie du pipeline est le fragment shader.\n\nLe fragment shader calcule la couleur finale du pixel et d√©termine si un pixel doit\n√™tre montr√© √† l'utilisateur ou non.\n\nSupposons par exemple que nous ayons un nuanceur de vertex qui dessine\ntrois points/vertices √† l'√©cran sous la forme d'un triangle. \nUne fois que ces sommets sont transmis au nuanceur de fragment, \nla couleur du pixel entre chaque sommet peut √™tre remplie automatiquement.\n\nLe GPU sait tr√®s bien comment interpoler les valeurs.\nEn supposant qu'une couleur soit attribu√©e √† chaque sommet dans le nuanceur de sommet, \nle GPU peut interpoler les couleurs entre chaque sommet pour remplir le triangle.\n\nDans les moteurs de jeu comme Unity ou Unreal, les vertex shaders et les fragment shaders \nsont largement utilis√©s pour les jeux en 3D.\nUnity fournit une abstraction au-dessus des shaders appel√©e ShaderLab,\nqui est un langage qui se superpose √† HLSL pour faciliter l'√©criture des shaders \npour vos jeux. En outre, Unity fournit un outil visuel appel√© Shader Graph \nqui vous permet de construire des shaders sans √©crire de code. \n\nSi vous cherchez \"Unity shaders\" sur Google, vous trouverez des centaines de shaders\nqui ex√©cutent de nombreuses fonctions diff√©rentes. Vous pouvez cr√©er des shaders qui \nfont briller les objets, rendent les personnages translucides, et m√™me cr√©er des \"effets\nd'image\" qui appliquent un shader √† l'ensemble de la vue de votre jeu. \nIl existe un nombre infini de fa√ßons d'utiliser les shaders.\n\nVous entendrez souvent parler des nuanceurs de fragments comme des nuanceurs de pixels.\nLe terme \"nuanceur de fragment\" est plus exact, car les nuanceurs peuvent emp√™cher \nles pixels d'√™tre dessin√©s √† l'√©cran. Dans certaines applications telles que Shadertoy, \nvous devez dessiner chaque pixel √† l'√©cran, il est donc plus logique de les appeler\nnuanceurs de pixels dans ce contexte.\n\nLes shaders sont √©galement responsables du rendu de l'ombrage et de l'√©clairage\ndans votre jeu, mais ils peuvent √™tre utilis√©s √† d'autres fins. \nUn programme de shaders peut √™tre ex√©cut√© sur le GPU, alors pourquoi ne pas profiter \nde la parall√©lisation qu'il offre ? Vous pouvez cr√©er un shader de calcul \nqui ex√©cute des calculs lourds sur le GPU plut√¥t que sur le CPU. \nEn fait, Tensorflow.js tire parti du GPU pour former des mod√®les \nd'apprentissage automatique plus rapidement dans le navigateur.\n\nLes shaders sont des programmes puissants !\n\n\n# Qu'est-ce que Shadertoy ?\n\nDans la prochaine s√©rie de billets, je parlerai de Shadertoy. \nShadertoy est un site web qui aide les utilisateurs √† cr√©er des shaders de pixels et √†\nles partager avec d'autres, un peu comme Codepen avec HTML, CSS et JavaScript.\n\nShadertoy s'appuie sur l'API WebGL pour effectuer un rendu graphique dans le navigateur\n√† l'aide du GPU. WebGL vous permet d'√©crire des shaders en GLSL et prend en charge \nl'acc√©l√©ration mat√©rielle. \nEn d'autres termes, vous pouvez exploiter le GPU pour manipuler les pixels de \nl'√©cran en parall√®le afin d'acc√©l√©rer le rendu. \nVous souvenez-vous que vous deviez utiliser ctx.getContext('2d') lorsque vous \ntravailliez avec l'API HTML Canvas ? \nShadertoy utilise un canevas avec le contexte webgl au lieu de 2d, \nde sorte que vous pouvez dessiner des pixels √† l'√©cran avec de meilleures \nperformances en utilisant WebGL.\n\nBien que Shadertoy utilise le GPU pour am√©liorer les performances de rendu,\nvotre ordinateur peut ralentir un peu lorsqu'il ouvre un shader Shadertoy \nde quelqu'un qui effectue des calculs lourds. Assurez-vous que le GPU de votre ordinateur\npeut le supporter et comprenez que cela peut √©puiser la batterie de \nvotre appareil assez rapidement.\n\nLes moteurs de jeux 3D modernes tels que Unity et Unreal Engine et les logiciels de mod√©lisation 3D tels que Blender fonctionnent tr√®s rapidement parce qu'ils utilisent √† la fois un vertex shader et un fragment shader, et qu'ils effectuent de nombreuses optimisations pour vous. Dans Shadertoy, vous n'avez pas acc√®s √† un vertex shader. Vous devez vous appuyer sur des algorithmes tels que le ray marching et les champs/fonctions de distance sign√©s (SDF) pour rendre les sc√®nes 3D, ce qui peut s'av√©rer co√ªteux en termes de calcul.\n\nVeuillez noter que l'√©criture de shaders dans Shadertoy ne garantit pas \nqu'ils fonctionneront dans d'autres environnements tels que Unity.\nIl se peut que vous deviez traduire le code GLSL en une syntaxe \nsupport√©e par votre environnement cible, telle que HLSL. \nShadertoy fournit √©galement des variables globales qui peuvent ne pas √™tre prises\nen charge dans d'autres environnements. \nQue cela ne vous arr√™te pas pour autant ! Il est tout √† fait possible de modifier\nvotre code Shadertoy et de l'utiliser dans vos jeux ou vos logiciels de mod√©lisation. \nCela demande juste un peu de travail suppl√©mentaire. \nEn fait, Shadertoy est un excellent moyen d'exp√©rimenter les shaders avant de\nles utiliser dans votre moteur de jeu ou votre logiciel de mod√©lisation pr√©f√©r√©.\n\nShadertoy est un excellent moyen de s'entra√Æner √† la cr√©ation de shaders \navec GLSL et vous aide √† penser de mani√®re plus math√©matique. \nDessiner des sc√®nes en 3D n√©cessite beaucoup d'arithm√©tique vectorielle. \nC'est un exercice intellectuellement stimulant et un excellent moyen de montrer \nses comp√©tences √† ses amis. \nSi vous naviguez sur Shadertoy, vous verrez des tonnes de cr√©ations magnifiques\nqui ont √©t√© dessin√©es uniquement √† l'aide de math√©matiques et de code ! Une fois\nque tu auras pris en main Shadertoy, tu verras que c'est vraiment amusant !\n\n# Introduction √† Shadertoy\n(...)\n\n# Comprendre le code d'un shader\n\nWhen you first start a new shader in Shadertoy, you will find the following code:\n*/\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n*/\n\n/*\nVous pouvez ex√©cuter le code en appuyant sur la petite fl√®che comme indiqu√© dans\nla section 8 de l'image ci-dessus ou en appuyant sur Alt+Enter ou Option+Enter\ncomme raccourci clavier.\n\nSi vous n'avez jamais travaill√© avec des shaders auparavant, ce n'est pas grave ! \nJe vais faire de mon mieux pour vous expliquer la syntaxe GLSL que vous utilisez \npour √©crire des shaders dans Shadertoy. \nD'embl√©e, vous remarquerez qu'il s'agit d'un langage √† typage statique comme C, C++, Java\net C#. GLSL utilise √©galement le concept de types. \nCertains de ces types sont : bool (bool√©en), int (entier), float (d√©cimal) et vec (vecteur).\nGLSL exige √©galement que des points-virgules soient plac√©s √† la fin de chaque ligne.\nDans le cas contraire, le compilateur √©mettra une erreur.\n\n\nDans l'extrait de code ci-dessus, nous d√©finissons une fonction mainImage \nqui doit √™tre pr√©sente dans notre shader Shadertoy.\nElle ne renvoie rien, le type de retour est donc void. \nElle accepte deux param√®tres : fragColor et fragCoord.\n\nIl se peut que vous vous grattiez la t√™te √† propos des entr√©es et sorties.\nPour Shadertoy, vous n'avez g√©n√©ralement √† vous soucier de ces mots-cl√©s \nqu'√† l'int√©rieur de la fonction mainImage. Vous vous souvenez que j'ai dit\nque les shaders nous permettent d'√©crire des programmes pour le pipeline \nde rendu du GPU ? Pensez √† l'entr√©e et √† la sortie comme √† l'entr√©e et √† la sortie.\nShadertoy nous donne une entr√©e, et nous √©crivons une couleur en sortie.\n\nAvant de continuer, changeons le code en quelque chose d'un peu plus simple :\n*/\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  vec3 col = vec3(0., 0., 1.); // RGB values\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n*/\n\n/*\nLorsque nous ex√©cutons le programme de nuanceur, \nnous devrions obtenir une toile enti√®rement bleue.\nLe programme de nuanceur s'ex√©cute pour chaque pixel de la toile EN PARALL√àLE. \nIl est extr√™mement important de garder cela √† l'esprit. Vous devez r√©fl√©chir √† \nla mani√®re d'√©crire un code qui changera la couleur du pixel en fonction de la \ncoordonn√©e du pixel. \n\nIl s'av√®re que nous pouvons cr√©er des ≈ìuvres d'art √©tonnantes en utilisant\nuniquement les coordonn√©es des pixels !\n\nDans les shaders, nous sp√©cifions les valeurs RVB (rouge, vert, bleu) \nen utilisant une plage comprise entre z√©ro et un. \nSi vos valeurs de couleur sont comprises entre 0 et 255, vous pouvez les normaliser\nen les divisant par 255.\n\nNous avons donc vu comment modifier la couleur de la toile, \nmais que se passe-t-il √† l'int√©rieur de notre programme d'ombrage ? \n\nLa premi√®re ligne de la fonction mainImage d√©clare une variable appel√©e uv de type vec2.\nSi vous vous souvenez de votre arithm√©tique vectorielle √† l'√©cole, cela signifie \nque nous avons un vecteur avec une composante \"x\" et une composante \"y\". \nUne variable de type vec3 aurait une composante \"z\" suppl√©mentaire.\n\nVous avez peut-√™tre appris √† l'√©cole l'existence du syst√®me de coordonn√©es 3D. \nIl nous permet de repr√©senter graphiquement des coordonn√©es 3D sur des feuilles \nde papier ou toute autre surface plane. Il est √©videmment difficile de visualiser les\n3D sur une surface 2D. \n\nC'est pourquoi les math√©maticiens les plus brillants ont cr√©√© un syst√®me de coordonn√©es\n3D pour nous aider √† visualiser les points dans l'espace 3D.\n\nCependant, dans le code des shaders, les vecteurs doivent √™tre consid√©r√©s comme \ndes \"tableaux\" pouvant contenir entre une et quatre valeurs.\nLes vecteurs peuvent contenir des informations sur les coordonn√©es XYZ dans\nl'espace 3D ou des informations sur les valeurs RVB. \nPar cons√©quent, les √©l√©ments suivants sont √©quivalents dans les programmes de shaders :\n\ncolor.r = color.x\ncolor.g = color.y\ncolor.b = color.z\ncolor.a = color.w\n\nOui, il peut y avoir des variables de type vec4, et la lettre w ou a est utilis√©e\npour repr√©senter une quatri√®me valeur. \nLe a signifie \"alpha\", puisque les couleurs peuvent avoir un canal alpha en plus \ndes valeurs RVB normales. \nJe suppose qu'ils ont choisi w parce qu'il se trouve avant x dans l'alphabet,\net qu'ils ont d√©j√† atteint la derni√®re lettre ü§∑.\n\nLa variable uv ne repr√©sente pas vraiment un acronyme.\nElle fait r√©f√©rence au sujet de la cartographie UV qui est couramment utilis√©e \npour cartographier des morceaux d'une texture (comme une image)bsur des objets 3D.\nLe concept de cartographie UV est plus applicable aux environnements qui vous donnent \nacc√®s √† un vertex shader contrairement √† Shadertoy, mais vous pouvez toujours exploiter\nles donn√©es de texture dans Shadertoy.\n\nLa variable fragCoord repr√©sente les coordonn√©es XY du canevas.\nLe coin inf√©rieur gauche commence √† (0, 0) et le coin sup√©rieur droit est \n(iResolution.x, iResolution.y). \n\nEn divisant fragCoord par iResolution.xy, nous pouvons normaliser les coordonn√©es\ndes pixels entre z√©ro et un.\n\nRemarquez que nous pouvons effectuer des op√©rations arithm√©tiques assez facilement\nentre deux variables de m√™me type, m√™me s'il s'agit de vecteurs.\nC'est la m√™me chose que d'effectuer des op√©rations sur les composants individuels :\n\nuv = fragCoord/iResolution.xy\n\n// The above is the same as:\nuv.x = fragCoord.x/iResolution.x\nuv.y = fragCoord.y/iResolution.y\n\nLorsque nous disons quelque chose comme iResolution.xy,la partie .xy se r√©f√®re uniquement\n√† la composante XY du vecteur. Cela nous permet de ne retirer que les composantes\ndu vecteur qui nous int√©ressent, m√™me si iResolution est de type vec3.\n\nSelon cet article de Stack Overflow \n(https://stackoverflow.com/questions/27888323/what-does-iresolution-mean-in-a-shader), \nla composante z repr√©sente le rapport d'aspect des pixels, qui est g√©n√©ralement de 1,0. \nUne valeur de 1 signifie que les pixels de votre √©cran sont carr√©s.\nVous ne verrez g√©n√©ralement pas les gens utiliser la composante z de iResolution tr√®s\nsouvent, voire pas du tout.\n\nNous pouvons √©galement effectuer des raccourcis lors de la d√©finition des vecteurs.\nL'extrait de code suivant d√©finit la couleur de l'ensemble de la toile en noir.\n\n*/\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  vec3 col = vec3(0); // Same as vec3(0, 0, 0)\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n*/\n\n/*\nLorsque nous d√©finissons un vecteur, le code du shader est suffisamment intelligent\npour appliquer la m√™me valeur √† toutes les valeurs du vecteur si vous ne sp√©cifiez \nqu'une seule valeur. Par cons√©quent, vec3(0) est √©tendu √† vec3(0,0,0).\n\nSi vous essayez d'utiliser des valeurs inf√©rieures √† z√©ro comme couleur de fragment\nde sortie, elles seront limit√©es √† z√©ro. \nDe m√™me, toute valeur sup√©rieure √† un sera limit√©e √† un. \nCela ne s'applique qu'aux valeurs de couleur dans la couleur finale du fragment.\n\nIl est important de garder √† l'esprit que le d√©bogage dans Shadertoy et \ndans la plupart des environnements de shaders, en g√©n√©ral, est principalement visuel. \nVous n'avez rien comme console.log pour venir √† votre secours. \nVous devez utiliser la couleur pour vous aider √† d√©boguer.\n\nEssayons de visualiser les coordonn√©es des pixels sur l'√©cran avec le code suivant :\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  vec3 col = vec3(uv, 0); // This is the same as vec3(uv.x, uv.y, 0)\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n\n\n/*\nNous devrions obtenir une toile compos√©e d'un m√©lange de noir, de rouge, de vert \net de jaune.\n\nC'est joli, mais en quoi cela nous aide-t-il ? \nLa variable uv repr√©sente les coordonn√©es normalis√©es de la toile entre z√©ro et un \nsur l'axe des x et l'axe des y. Le coin inf√©rieur gauche de la toile a pour coordonn√©es\n(0, 0). Le coin sup√©rieur droit de la toile a pour coordonn√©es (1, 1).\n\n\nDans la variable col, nous la fixons √† (uv.x, uv.y, 0), \nce qui signifie que nous ne devrions pas nous attendre √† une couleur bleue dans le canevas.\nLorsque uv.x et uv.y sont √©gaux √† z√©ro, nous obtenons du noir. \nLorsqu'ils sont tous deux √©gaux √† un, nous obtenons du jaune, car en infographie,\nle jaune est une combinaison de valeurs rouges et vertes. Le coin sup√©rieur gauche \nde la toile est (0, 1), ce qui signifie que la variable col serait √©gale √† (0, 1, 0), \nce qui correspond √† la couleur verte. Le coin inf√©rieur droit a pour coordonn√©es (1, 0),\nce qui signifie que la variable col est √©gale √† (1, 0, 0), ce qui correspond \n√† la couleur rouge.\n\nLaissez les couleurs vous guider dans votre processus de d√©bogage !\n\n# Conclusion\n\nOuf ! J'ai couvert pas mal de choses sur les shaders et Shadertoy dans cet article.\nJ'esp√®re que vous √™tes toujours avec moi ! \nLorsque j'ai appris les shaders pour la premi√®re fois, j'ai eu l'impression \nd'entrer dans un tout nouveau domaine de la programmation.\nC'est compl√®tement diff√©rent de ce √† quoi je suis habitu√©,\nmais c'est excitant et stimulant ! Dans la prochaine s√©rie d'articles,\nje parlerai de la fa√ßon dont nous pouvons cr√©er des formes sur le canevas \net faire des animations !\n*/\n\n\n\n","name":"Image","description":"","type":"image"}]}