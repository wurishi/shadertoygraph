{"ver":"0.1","info":{"id":"llKGWR","date":"1474230360","viewed":102,"name":"[OLD] Shading","username":"Sabouh","description":"Shading\nYou can move the camera using your mouse.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shading","rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Inspired by inigo quilez's articles \n https://iquilezles.org/articles/distfunctions\n + Romain Vergne's lectures \n Shader : Shading\n Author : Sabouh\n*/\n \n//to get a higher float precision\nprecision highp float;\nconst float PI = 3.1415926535897932384626433832795;\nconst int PLANE_NB = 3;\nconst int SPHERE_NB = 5;\nconst int OBJ_NB = PLANE_NB + SPHERE_NB;\nconst int LIGHT = OBJ_NB +1;\nconst int LIGHT2 = LIGHT +1;\nconst int MAX_NB = 10;\nconst float MAX_VALUE = 100.;\nconst int MAX_INT_VALUE = 50;\nconst vec4 background = vec4(1.,1.,1.,1.);\n\n//*******************************Tools**************************\n//Structures definition\n\n//Properties\nstruct Properties{\n   vec3 specColor;\n   float roughness;\n   int distrib;//distribution {1,2,3}\n   int geom;//geom func {1,2}\n};\n    \n//Light\nstruct Light{\n\tvec3 p;//position\t\n};\n\n//MarchingPack\nstruct MarchingPack{\n\tfloat dist;\n\tfloat index;\n\tbool hit;\n\t\n};\n\n//Ray\nstruct Ray{\n\tvec3 o; //origin\n\tvec3 d; //direction\n};\n\n//Camera\nstruct Camera{\n\tvec3 e;//eye\n    vec3 r;//right\n    vec3 u;//up\n    vec3 v;//view\n\t\n};\n\nstruct Color{\n\tvec4 c;\n};\n\n//Plane\nstruct Plane{\n\tvec3 n; //normal\n\tfloat d; //offset\n};\n\n//Sphere\nstruct Sphere{\n\tvec3 c; //center\n\tfloat r; //rayon\n};\n\n\n//Distance operations\n\n//union\nvec2 opU(vec2 d1,vec2 d2){\n\treturn d1.x<d2.x ? d1 : d2; //if d1.x < d2.x return d1 else d2\n}\n\n//substraction\nfloat opS(float d1, float d2){\n\treturn max(-d1,d2);\n}\n\n//intersection\nfloat opI(float d1,float d2){\n\treturn max(d1,d2);\n}\n\n\n\n//Init\nvec4 getColor(float index){\n\tif(index == 1.){\n\t\treturn vec4(0.,1.,1.,1.); //cyan 3\n\t}else if(index == 2.){\n\t\treturn vec4(0.,1.0,0.,1.); //green 2\n\t}else if(index == 3.){\n\t\treturn vec4(0.,0.,1.,1.); //blue 1\n\t}else if(index == 4.){\n\t\treturn vec4(1.,0.,0.,1.); //red 4\n\t}else if(index == 5.){ \n\t\treturn vec4(1.,0.,1.,1.); //magenta 5\n\t}else if(index == 6.){ \n\t\treturn vec4(1.,1.,0.,1.); //yellow 6\n\t}else if(index == 7.){ \n\t\treturn vec4(0.1,0.,0.,1.); //blood red 7\n\t}else if(index == 8.){ \n\t\treturn vec4(0.1,0.1,0.1,1.); // 7\n\t}else if(index == float(LIGHT)){ \n\t\treturn vec4(1.,0.,0.,0.); //yellow\n\t}else if(index == float(LIGHT2)){ \n\t\treturn vec4(1.,0.,0.,0.); //yellow\n\t}else{\n\t\treturn background;//ERROR WHITE\n\t\t\n\t}\n}\n\nvec4 createSphere(vec3 c, float r, float phi, float teta){\n\tfloat x,y,z;\n\tx = c.x + r*sin(phi)*cos(teta);\n\ty = c.y + r*sin(phi)*sin(teta);\n\tz = c.z + r*cos(phi);\n    return vec4(x,y,z,r);\n    \n}\n\n\nvec4 getObject(float index){\n    vec4 res ;\n\tif(index == 1.){\n\t\tres =  vec4(0.,0.,1.,0.); //Plan (x,y)\n\t}else if(index == 2.){\n\t\tres = vec4(1.,0.,0.,0.); //Plan (y,z)\n\t}else if(index == 3.){\n\t\tres = vec4(0.,1.,0.,0.); //Plan (x,z)\n\t}else if(index == 4.){\n\t\tres = createSphere(vec3(-10.,2.,2.),1., PI/2., PI/2.*iTime); \n\t}else if(index == 5.){ \n\t\tres = createSphere(vec3(-2.,10.,2.),1., PI/2., PI); \n\t}else if(index == 6.){ \n\t\tres = createSphere(vec3(-10.,5.,2.), 1., PI/2.*iTime, PI); \n\t}else if(index == 7.){ \n\t\tres = createSphere(vec3(-10.,10.,2.),1., PI, PI);\n\t}else if(index == 8.){ \n\t\tres = createSphere(vec3(-2.,2.,2.), 1., PI, PI);\n\t}else if(index == float(LIGHT)){ \n\t\tres = createSphere(vec3(-1.,2.,5.),1., PI, PI); \n\t}else{\n\t\tvec4 res = vec4(MAX_VALUE,MAX_VALUE,MAX_VALUE,MAX_VALUE);//ERROR \n\t\t\n\t}\t\n    return res;\n}\n\n//return specular color and roughness of the object\nProperties getProperties(float index){\n    \n\tif(index == 1.){\n\t\treturn Properties(vec3(1.,1.,1.),0.,1,1); //cyan 3\n\t}else if(index == 2.){\n\t\treturn Properties(vec3(1.,1.0,1.),1.,2,1); //green 2\n\t}else if(index == 3.){\n\t\treturn Properties(vec3(1.,1.,1.),1.,3,1); //blue 1\n\t}else if(index == 4.){\n\t\treturn Properties(vec3(1.,1.,1.),0.001,2,1); //red 4\n\t}else if(index == 5.){ \n\t\treturn Properties(vec3(1.,1.,1.),0.5,3,2); //magenta 5\n\t}else if(index == 6.){ \n\t\treturn Properties(vec3(1.,1.,1.),1.,2,2); //yellow 6\n\t}else if(index == 7.){ \n\t\treturn Properties(vec3(1.,1.,1.),0.1,1,2); //blood red 7\n\t}else if(index == 8.){ \n\t\treturn Properties(vec3(1.,1.,1.),1.,3,2); // grey 8\n\t}else if(index == float(LIGHT)){ \n\t\treturn Properties(vec3(1.,0.,0.),0.,-1,-1); //yellow\n\t}else if(index == float(LIGHT2)){ \n\t\treturn Properties(vec3(1.,0.,0.),0.,-1,-1); //yellow\n\t}else{\n\t\treturn Properties(vec3(1.,1.,1.),-1.,-1,-1);//ERROR WHITE\n\t\t\n\t}\n}\n\n\nfloat fPlane(Ray r,float t,vec4 n){\n    vec3 norma = normalize(n.xyz);\n    vec3 norm = n.xyz;\n    vec3 pos = r.o +r.d*t;\n    vec3 Q = norma*n.w ; //Q is in Plane\n    \n    if(dot(r.d,norm ) == 0.){\n       if(dot(r.o-Q,norm)==0.){\n        \treturn 0.;\n       }else{\n        \treturn MAX_VALUE;\n       }\n    }else{\n        if(dot(Q-r.o,norm)  /dot(r.d,norm) < 0.){\n            return MAX_VALUE;\n        }else if(dot(Q-pos,norm) == 0.){\n            return 0.;\n        }else{\n    \t\treturn  ( dot(Q-r.o,norm)  /dot(r.d,norm) ) -t;\n        }\n    }\n        \n}\n\nfloat fSphere(Ray r, float t,vec4 o){\n    vec3 pos = r.o+r.d*t;\n    if(dot(o.xyz-pos,r.d) >=0.){\n        return distance(o.xyz,pos) - o.w ;\n        \n    }else{\n        if(length(o.xyz-pos) <= o.w ){\n            return distance(o.xyz,pos) - o.w ;\n        }else{\n            return MAX_VALUE;\n        }\n    }\n}\n\nfloat functionDist(Ray r, float t, float index){\n    if(index <= float(PLANE_NB)){\n        return fPlane(r,t,getObject(index));\n    }else{\n        return fSphere(r,t,getObject(index));\n    }\n}\n\nvec2 map(Ray r,float t){\n\tvec2 res =  vec2(  fPlane(r,t,getObject(1.)  ),1.) ;\n\tfor(int i = 2;i<= OBJ_NB;i++){\n\t\tif(i<=PLANE_NB){\n\t\t\tres = opU(res, vec2(  fPlane(r,t,getObject(float(i))) ,float(i)) );\n\t\t}else{\n\t\t\tres = opU(res, vec2( fSphere(r,t,getObject(float(i)) ),float(i)) );\n        }\n\t}\n\treturn res;\n}\n\nvec2 mapL(Ray r,float t,float index){\n    vec2 res = vec2(MAX_VALUE,-1.);\n    if(index != 1.){\n\t\tres =  vec2(  fPlane(r,t,getObject(1.)  ),1.) ;\n    }\n\tfor(int i = 2;i<= OBJ_NB;i++){\n        \n     if(index != float(i)){\n\t\tif(i<=PLANE_NB ){\n\t\t\tres = opU(res, vec2(  fPlane(r,t,getObject(float(i))) ,float(i)) );\n\t\t\n        }else{\n\t\t\tres = opU(res, vec2( fSphere(r,t,getObject(float(i)) ),float(i)) );\n\t\t\t\n\t\t}\n     }\n\n\t}\n\treturn res;\n}\n\n\n\nvec3 getNormal(vec3 pos, float index){\n    vec3 n;\n    if(index <= float(PLANE_NB)){\n       \tn = normalize( getObject(index).xyz );\n    }else{\n       \tn = normalize( pos - getObject(index).xyz );\n    }\n    return n;\n}\n\nfloat getIntensity(vec3 pos,vec3 l,vec3 n,float index){\n    float intensity;\n    if(index <= float(PLANE_NB)){\n\t\t\n        intensity =   max( dot(normalize(l -pos),n),dot(normalize(l -pos),-n))   ;\n    }else{\n        intensity =   dot(normalize(l -pos),n)  ;\n    }\n    return intensity;\n}\n\n\n\n//-------------------------------------------------------------------------------------\n//Fresnel coef (here Schlick)\nvec3 F(vec3 color, vec3 l,vec3 h){\n    return color +(1.-color)*pow(1.-dot(l,h),5.);\n}\n\n\n// Cook-Torrance\nfloat Gct(vec3 l, vec3 v,vec3 h, vec3 n){\n    //h = 2.*h;\n    return min(1.,\n               min( (2.*dot(n,h)*dot(n,v))/dot(v,h) ,\n                   (2.*dot(n,h)*dot(n,l))/dot(v,h) ));\n}\n\n\n// implicit function G\nfloat Gimpl(vec3 l, vec3 v,vec3 m,vec3 n){\n   //m = m/2.;\n    return dot(n,l)*dot(n,v);\n}\n\n//shadowing func\nfloat G(vec3 l, vec3 v,vec3 m,vec3 n,float index){\n    \n    int geom = getProperties(index).geom;\n    if(geom == 1){\n    \tm = m/2.;\n    \treturn Gimpl(l,v,m,n);\n    }\n    if(geom == 2){\n    \treturn Gct(l,v,m,n);\n    }\n    \n    return Gct(l,v,m,n);\n}\n\n\n//GGX\nfloat Dtr(vec3 m,vec3 n,float index, float alpha){\n    float scal = dot(n,m);\n    return pow(alpha,2.) /(PI*pow(pow(dot(n,m),2.)*(pow(alpha,2.)-1.)+1.,2.) );\n}\n\n//Beckmann\nfloat Db(vec3 m,vec3 n,float index, float alpha){\n    float scal = dot(n,m);\n    return 1./( PI*pow(alpha,2.)*pow(scal,4.)) * exp(-( (1.-pow(scal,2.))/( pow(alpha,2.)*pow(scal,2.))) );\n}\n\n\n//Phong\nfloat Dp(vec3 m,vec3 n,float index, float alpha){\n    return (alpha+2.)/(2.*PI)*pow(dot(n,m),alpha);\n}\n\n//distribution\nfloat D(vec3 m,vec3 n,float index){\n    m = m/2.;\n    Properties prop = getProperties(index);\n    int distrib = prop.distrib;\n\tfloat alpha = prop.roughness;\n    if(distrib==1){\n        return Dp(m,n,index,alpha);\n    }\n    if(distrib==2){\n\t\treturn Db(m,n,index,alpha);\n    }\n    if(distrib==3){\n\t\treturn Dtr(m,n,index,alpha);\n    }\n\treturn Dp(m,n,index,alpha);\n}\n\n\n//microfacettes theories\nvec3 spec(vec3 l, vec3 v,vec3 n,float index){\n\tvec3 h = normalize(l+v);\n    vec3 f0 = getProperties(index).specColor;\n    return ( F(f0,l,h)*G(l,v,h,n,index)*D(h,n,index) )/( 4.*dot(n,l)*dot(n,v) );\n\n}\n\n//lambert\nvec3 diff(vec3 l, vec3 v,vec3 n,float index,vec3 color){\n\tvec3 h = normalize(l+v);\n    \n    return color/PI;\n\n}\n\nvec3 brdf(vec3 l,vec3 v,vec3 n, vec3 color, float index){\n\treturn spec(l,v,n,index)+diff(l,v,n,index,color);\n}\n\n\n//------------------------------------------------------------------\n\n//Direct Illumination 1 light, diffus\nvec4 directIllum(Camera c,Light l,vec3 pos,float dist, float index,float D){\n\t//compute the normal\n\tvec3 n = getNormal(pos,index);\n\t//compute intensity\n    float intensity = getIntensity(pos,l.p,n,index);\n    if(intensity <=0.){\n        intensity = 0.*PI;\n    }else{\n        intensity = PI*intensity;\n    }\n    \n\tfloat t ;\n\tvec4 obj;\n\tvec3 color;\n    if(mod(iTime,9.) <3.){\n    \t//color map\n\t\t color = getColor(index).xyz;\n    }else if(mod(iTime,9.) <6. ){\n    \t//height map\n        float h = dist/(D);\n     \tcolor = vec3(h,h,h);\n    }else{\n    \t//normal map\n        color = n;\n    }\n    vec3 newColor = intensity * brdf(normalize(l.p-pos),normalize(c.e-pos), n, color,index);\n    return vec4(newColor,1.);\n}\n\nvec4 displayColor(vec3 pos,float dist, float index,float D){\n\t\n\t\n    if(mod(iTime,9.) <3.){\n    \t//color map\n\t\treturn getColor(index);\n    }else if(mod(iTime,9.) <6. ){\n    \t//height map\n        float h = dist/(D);\n     \treturn vec4(h,h,h,1.);\n    }else{\n    \t//normal map\n    \tif(index <= float(PLANE_NB)){\n        \treturn vec4((getObject(index)).xyz,1.0) ;\n    \t}else{\n        \tvec3 n = pos - getObject(index).xyz;\n\t\t\treturn vec4(n,1.0);\n    \t}\n    }\n\t\n}\n\n//ray Marching Algorithm\nMarchingPack rayM(Ray r,float epsilon,float index){\n\t\n\tfloat t = 0.00;\n\tvec2 d;\n\tvec3 pos;\n\tfor(int i = 0; i< MAX_INT_VALUE;i++){\n        pos = r.o+ r.d*t;\n\t\td = map(r,t);\n        if(  d.x <= epsilon ){\n  \t\t \tMarchingPack mp = MarchingPack(t-d.x,d.y,true);\n       \t    return mp;\n       \t }\n\t\tt = t +  d.x;\n\t}\n    \n\tMarchingPack mp = MarchingPack(t,d.y,false);\n\treturn mp;\t\n}\n\n\n//ray Marching Light Algorithm\nMarchingPack rayML(Light l,Ray r,float epsilon,float index){\n\t\n\tfloat t = 0.00;\n\tvec2 d;\n\tvec3 pos;\n\tfor(int i = 0; i< MAX_INT_VALUE;i++){\n        pos = r.o+ r.d*t;\n\t\td = mapL(r,t,index);\n        if( t <= length(r.o-l.p) && d.x <= epsilon  ){\n            \tMarchingPack mp = MarchingPack(t-d.x,d.y,true);\n                return mp;\n            \n        }\n       \n\t\tt = t +  d.x;\t\n\t}\n    \n\tMarchingPack mp = MarchingPack(t,d.y,false);\n\treturn mp;\t\n}\n\n//Shading\nvec4 shading(vec2 fragCoord){\n\t//cast a ray w/ camera\n\t\n\t//(x,y) in range [-1;1] \n\tfloat x = (2.*fragCoord.x - iResolution.x )/iResolution.x;\n\tfloat y = (2.*fragCoord.y - iResolution.y )/iResolution.y;\n   \n\tfloat xMouse = (2.*iMouse.x - iResolution.x )/iResolution.x;\n\tfloat yMouse = (2.*iMouse.y - iResolution.y )/iResolution.y;\n\t\n\t//camera\n\tCamera c;\n    vec3 u1;\n\tc.e = vec3(xMouse*15.,yMouse*15.,15.);//camera pos\n\tc.v = normalize(-c.e);\n\tu1 = vec3(0.,1.,0.);\n\tc.r = normalize(cross(c.v,u1));\n\tc.u = normalize(cross(c.r,c.v));\n\t\n\t//Ray\n\tRay r;\n\tfloat D = 1./tan(PI/4.);\n\tr.o = c.e;\n\tvec3 rd = x*c.r + y *c.u+ D*c.v;\n\tr.d = normalize(rd);\n\t\n\tLight l = Light( getObject(float(LIGHT)).xyz );\n    //l.p = c.e;\n\tLight l2= Light( getObject(float(LIGHT2)).xyz );\n\t\n\tMarchingPack rmp = rayM(r,0.002,-1.);\n\tif(rmp.hit){\n    \tvec3 pos = r.o+r.d*rmp.dist;\n        \n        Ray shadowRay = Ray(pos,normalize(l.p-pos));\n        MarchingPack rmpl = rayML(l,shadowRay,0.002,rmp.index);\n        \n        if(rmpl.hit){\n\t\t\treturn 0.1*directIllum(c,l,pos,rmp.dist,rmp.index,c.e.z*2.);\n            \n        }else{\n\t\t\treturn directIllum(c,l,pos,rmp.dist,rmp.index,c.e.z*2.);\n        }\n\t}else{\n\t\treturn background;\n\t}\n    \n    \n}\n\n\n//************************Application********************************************\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t  \n\tfragColor = shading(fragCoord);\n    \n}","name":"Image","description":"","type":"image"}]}