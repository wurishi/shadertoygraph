{"ver":"0.1","info":{"id":"WlVSWD","date":"1582740930","viewed":160,"name":"arewijk_lights","username":"Bl00dhound","description":"testing some lights\nvery slow running implementation, completely tanks on higher resolution, not sure on how to not recalculate every light for every single pixel yet, i'm used to having lookup tables and have a lot to learn about parallelization ;)\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","beginner","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nlights: my first pixel shader worth a damn\n*/\n// shader settings\n#define color_gradient_size 1.25  // how quickly the gradient transitions\n#define color_cycle_speed 18.0    // the animation speed of the color cycling\n#define num_lights 2000           // the amount of lights \n#define size_lights 200.0         // the size of the lights\n#define wraps 32.0                // the number of circular wraparounds (aka rings)\n\n// math constants\n#define pi  3.14159265\n#define tau 6.28318530\nvec4 background=vec4(1.0);\n\n  // HSV to RGB lifted from somewhere\n  vec3 HUEtoRGB(vec3 c) {\n  vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);\n  vec3 p=abs(fract(c.xxx + K.xyz)*6.0-K.www);\n  return c.z * mix(K.xxx,clamp(p - K.xxx, 0.0, 1.0),c.y);\n  }\n\n  // draw light (pos_px,radius,uvmap), lifted this one too\n  // may replace it with a cheaper single distance or inverse square function later.\n  vec4 drawlight(vec2 pos,float radius, vec2 uv) { \n  float dist=length(pos-uv);\n  float maxDistance=pow(radius,0.10);\n  float quadDistance=pow(dist,0.21);\n  float quadIntensity=1.0-min(quadDistance,maxDistance)/maxDistance;      \n      \n  vec4 lght=vec4(quadIntensity);\n  return lght;\n  }\n\n  void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 res=iResolution.xy;\n  vec2 pix=fragCoord.xy;\n  vec2 uv=(pix/res)*1.0;\n  vec4 col=vec4(0.,0.,0.,0.);\n  vec4 tex=texture(iChannel0,uv);\n      \n  // make sum lights\n  float bounds=res.y*1.05;\n  float tm=iTime;\n  float anitm=tm*0.15;\n  float twistamount=8.0; \n  \n    for (int a=0; a<num_lights; a++) {\n    float fac=float(a)/float(num_lights);\n    float form_x=fac*pi*2.0;\n    float form_y=fac*pi*2.0;\n    float xbnd=float(bounds)*(fac);\n    float ybnd=float(bounds)*(fac);\n    float ix=sin(form_x*wraps)*xbnd;\n    float ij=cos(form_y*wraps)*ybnd;\n    float sinmod=-sin(anitm+(fac*twistamount))*8.0;\n    float cosmod=-cos(anitm+(fac*twistamount))*8.0;\n    ix+=sinmod;\n    ij+=cosmod;        \n    float lsize=bounds*fac*(size_lights/1000.0); // light size; \n    vec2 lpos=res/2.0;\n    lpos+=vec2(ix,ij);\n    float coord_threshold=lsize/4.0; // why /4 instead of 2 for half the size? i don't have a clue.. but it's free performance ;)\n        \n        // hacky position comparison breakouts to speed up the loop (significantly)\n        if (abs(fragCoord.x-lpos.x)>coord_threshold) { continue; }\n        if (abs(fragCoord.y-lpos.y)>coord_threshold) { continue; }\n        \n    vec4 light=drawlight(lpos,lsize,fragCoord);\n    float colspeed=(tm*(color_cycle_speed/100.0));\n    float colfac=-(fac*color_gradient_size)+(colspeed);\n    float col_h=colfac;\n    float col_s=sin((colfac)*tau);\n    col_s=max(.05,fac);\n    float col_v=sin(colfac*tau);\n    col_v=col_s;\n\n    vec3 hoe=HUEtoRGB(vec3(col_h,col_s,col_v));\n    light.rgb*=hoe*15.0;\n\tvec4 col_comb=vec4(light.rgb,1.0);\n    col+=col_comb;\n    }\n\n  fragColor=col;    \n  }","name":"Image","description":"","type":"image"}]}