{"ver":"0.1","info":{"id":"4tfXR2","date":"1437846382","viewed":743,"name":"CCCamp 2015","username":"WilstonOreo","description":"A little contribution to the CCCamp 2015 Logo Design.\nhttps://events.ccc.de/camp/2015/wiki\nhttps://events.ccc.de/camp/2015/wiki/images/4/47/Cccamp15-poster-preview.jpg","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagon","ccc","cccamp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nvec3 eggplant_base = vec3(0.557, 0.349, 0.565); // #8e5990\nvec3 eggplant_structure = vec3(0.518, 0.31, 0.533); //  #844f88\n\nvec3 blue_base = vec3(0.459, 0.522, 0.659); // #7585a8\nvec3 blue_structure = vec3(0.404, 0.467, 0.604); // #67779a\n\nvec3 green_base = vec3(0.51, 0.604, 0.251); // #829a40\nvec3 green_structure = vec3(0.447, 0.541, 0.188); // #728a30\n\nvec3 orange_base = vec3(0.894, 0.671, 0.314); // #e4ab50\nvec3 orange_structure = vec3(0.824, 0.592, 0.188); // #d29730\n\nvec3 brown_base = vec3(0.647, 0.455, 0.314); // #a57450\nvec3 brown_structure =  vec3(0.6, 0.4, 0.251); // #996640\n\nvec3 base = vec3(0.251, 0.251, 0.251); //  #404040\n\nvec3 black_structure = vec3(0.102, 0.102, 0.102); // #1a1a1a\n\nvec3 light_gray_structure = vec3(0.502, 0.502, 0.502); // #808080\n\nconst float soft = 0.01;\n\nfloat hash( float n )\n{\n  return fract(sin(n)*43758.5453);\n}\nfloat hash1( vec2  p )\n{\n  return hash(dot(p,vec2(127.1,311.7) ));\n}\n\nfloat hash2( vec2  p )\n{\n  return fract(sin(dot(p,vec2(704.1,14.7) ))*4033358.5453);\n}\n\n\n//////// ICONS ////////////\n\nfloat circle(vec2 pos, float r)\n{\n  float _distance = length(pos);\n  float _v = (_distance ) / r;\n  return 1.0 - smoothstep(1.0 - soft / r,1.0,_v); \n}\n\nfloat rectangle(vec2 pos, float w, float h)\n{\n  return 1.0 -  \n    max(smoothstep(0.5*w - soft,0.5*w + soft,abs(pos.x)), \n    smoothstep(0.5*h - soft,0.5*h + soft,abs(pos.y))); \n}\n\nfloat diamond(vec2 pos, float size)\n{\n  return 1.0 - smoothstep(size - soft,size +soft,(abs(pos.x) + abs(pos.y)));\n}\n\nfloat line(vec2 coord, vec2 p1, vec2 p2, float thickness)\n{\n  float d = dot(coord - p1, p2 - p1) / length(p2 - p1);\n  d /= length(p2 - p1);\n  d = clamp(step(0.0, d) * d, 0.0, 1.0);\n  d = distance(p1 + d * (p2 - p1), coord);\n\n  float dst = 1.0 - smoothstep(thickness - soft, thickness + soft, d);\n\n  return dst;\n}\n\nfloat chip(vec2 pos)\n{\n  float border = rectangle(pos,0.5,0.5) - rectangle(pos,0.35,0.35);\n  return clamp(border +\n    line(pos,vec2(0.25,0.15),vec2(0.3,0.15),0.04) + \n    line(pos,vec2(0.25,0.00),vec2(0.3,0.00),0.04) +\n    line(pos,vec2(0.25,-0.15),vec2(0.3,-0.15),0.04) +\n    line(pos,vec2(-0.25,0.15),vec2(-0.3,0.15),0.04) + \n    line(pos,vec2(-0.25,0.00),vec2(-0.3,0.00),0.04) +\n    line(pos,vec2(-0.25,-0.15),vec2(-0.3,-0.15),0.04) +\n    line(pos,vec2(-0.15,0.25),vec2(-0.15,0.30),0.04) +\n    line(pos,vec2(0.0,0.25),vec2(0.0,0.30),0.04) + \n    line(pos,vec2(0.15,0.25),vec2(0.15,0.30),0.04) +\n    line(pos,vec2(-0.15,-0.25),vec2(-0.15,-0.30),0.04) +\n    line(pos,vec2(0.0,-0.25),vec2(0.0,-0.30),0.04) + \n    line(pos,vec2(0.15,-0.25),vec2(0.15,-0.30),0.04),\n    0.0,1.0);\n}\n\nfloat screen(vec2 pos)\n{\n  float display = rectangle(pos,0.6,0.4) - rectangle(pos,0.5,0.3);\n  return clamp(display + \n    rectangle(pos + vec2(0.0,0.25),0.1,0.15) +\n    rectangle(pos + vec2(0.0,0.3),0.5,0.07),0.0,1.0);\n}\n\nfloat laptop(vec2 pos)\n{\n  float display = rectangle(pos,0.5,0.35) - rectangle(pos,0.4,0.25);\n  return clamp(display + \n  rectangle(pos + vec2(0.0,0.3),0.7,0.07) +\n  line(pos,vec2(0.22,-0.15),vec2(0.32,-0.27),0.03) +\n  line(pos,vec2(-0.22,-0.15),vec2(-0.32,-0.27),0.03)\n  ,0.0,1.0); \n}\n\nfloat cloud(vec2 pos) \n{\n  return clamp(clamp(\n    circle(pos + vec2(-0.2,0.0),0.3) + \n    circle(pos + vec2(0.0,0.15),0.3) + \n    circle(pos + vec2(0.07,-0.17),0.35) +\n    circle(pos + vec2(0.3,0.0),0.35),0.0,1.0) -\n    clamp(circle(pos + vec2(-0.2,0.0),0.2) + \n    circle(pos + vec2(0.0,0.15),0.2) +\n    circle(pos + vec2(0.07,-0.17),0.25) +\n    circle(pos + vec2(0.3,0.0),0.25),0.0,1.0)\n  ,0.0,1.0);\n}\n\n\n\nfloat plug(vec2 pos)\n{\n  return \n    clamp(circle(pos,0.5) - circle(pos,0.4) +     \n      rectangle(pos - vec2(0.0,0.37),0.15,0.15) + \n      rectangle(pos + vec2(0.0,0.37),0.15,0.15) +\n      circle(pos - vec2(0.17,0.0),0.08) +\n      circle(pos + vec2(0.17,0.0),0.08),\n    0.0,1.0);\n}\n\nfloat wifi(vec2 pos)\n{\n  return clamp(circle(pos,0.1) + \n    (diamond(pos - vec2(0.0,0.5),0.5)) *( circle(pos,0.3) - circle(pos,0.2) + circle(pos,0.5) - circle(pos,0.4)),0.0,1.0);\n}\n\nfloat antenna(vec2 pos)\n{\n  return clamp( rectangle(pos + vec2(0.0,0.25),0.1,0.5) + circle(pos,0.1) + \n    (diamond(pos + vec2(0.5,0.0),0.5) + diamond(pos - vec2(0.5,0.0),0.5)) *( circle(pos,0.3) - circle(pos,0.2) + circle(pos,0.5) - circle(pos,0.4)),0.0,1.0);\n}\n\nfloat note(vec2 pos)\n{\n  return clamp(\n    rectangle(pos - vec2(-0.2,-0.05),0.1,0.5) +\n    rectangle(pos - vec2( 0.2,0.05),0.1,0.5) + \n    circle(pos - vec2(0.15,-0.2),0.1) + \n    circle(pos - vec2(-0.25,-0.3),0.1) + \n    line(pos,vec2(-0.2,0.2),vec2(0.2,0.3),0.05),0.0,1.0);\n}\n\nfloat fire(vec2 pos)\n{\n  return clamp(clamp(diamond(pos - vec2(0.0,0.25),0.103) + \n    circle(pos - vec2(0.0,0.134 * sqrt(2.0)),0.12),0.0,1.0) -\n    clamp(diamond(pos - vec2(0.0,0.25),0.05) + \n    circle(pos - vec2(0.0,0.133 * sqrt(2.0)),0.08),0.0,1.0) +\n    line(pos,vec2(0.0,0.0),vec2(0.0,-0.2),0.04) + \n    line(pos,vec2(-0.2,0.0),vec2(0.2,0.0),0.04) + \n    line(pos,vec2(0.0,0.0),vec2(0.15,-0.15),0.04) + \n    line(pos,vec2(0.0,0.0),vec2(-0.15,-0.15),0.04),0.0,1.0); \n}\n\n//////// END ICONS ////////////\n\n// { 2d cell id, distance to border, distnace to center )\nvec4 hexagon( vec2 p )\n{\n  vec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\n  vec2 pi = floor(q);\n  vec2 pf = fract(q);\n\n  float v = mod(pi.x + pi.y, 3.0);\n\n  float ca = step(1.0,v);\n  float cb = step(2.0,v);\n  vec2  ma = step(pf.xy,pf.yx);\n\n  // distance to borders\n  float e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n  // distance to center\n  p = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n  float f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\n\n  return vec4( pi + ca - cb*ma, e, f );\n}\n\nvec2 position( vec2 p)\n{\n  vec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n  p = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\n  return vec2(fract(p) - 0.5)*vec2(1.0,0.85);\n}\n\nvoid get_hexagon_color(float value, out vec3 color_base, out vec3 color_structure, out vec3 color_icon)\n{\n  int f = int(value * 6.0);\n\n  color_icon = vec3(1.0);\n  if (f == 0)\n  {\n    color_base = eggplant_base;\n    color_structure = eggplant_structure;\n  }\n  else if (f == 1)\n  {\n    color_base = blue_base;\n    color_structure = blue_structure;\n  }\n  else if (f == 2)\n  {\n    color_base = green_base;\n    color_structure = green_structure;\n  }\n  else if (f == 3)\n  {\n    color_base = orange_base;\n    color_structure = orange_structure;\n  }\n  else if (f == 4)\n  {\n    color_base = brown_base;\n    color_structure = brown_structure;\n  }\n  else if (f == 5)\n  {\n    color_base = vec3(1.0);\n    color_structure = light_gray_structure;\n    color_icon = light_gray_structure;\n  }\n}\n\nfloat get_icon(float value, vec2 pos) \n{\n  float icon_value = 0.0;\n\n  float bobble = (1.0 + 0.05*(hash(value)*0.1 +1.0)*sin(iTime * 4.0 + hash(value)));\n\n  int f = int(value * 9.5);\n  pos *= bobble;\n\n  if (f == 0) \n  {\n    icon_value = chip(pos*2.0);\n  } else\n  if (f == 1) \n  {\n    icon_value = screen(pos*2.0);\n  } else\n  if (f == 2) \n  {\n    icon_value = laptop(pos*2.0);\n  } else\n  if (f == 3) \n  {\n    icon_value = cloud(pos*2.5);\n  } else\n  if (f == 4) \n  {\n    icon_value = plug(pos*3.0);\n  } else\n  if (f == 5) \n  {\n    icon_value = wifi(pos*2.0);\n  } else\n  if (f == 6) \n  {\n    icon_value = antenna(pos*2.5);\n  } else\n  if (f == 7) \n  {\n    icon_value = note(pos*2.0);\n  } else\n  if (f == 8) \n  {\n    icon_value = fire(pos*1.5);\n  } \n\n  return icon_value;\n}\n\nvec4 pick3(vec4 a, vec4 b, vec4 c, float u)\n{\n  float v = fract(u * 0.3333333333333);\n  return mix(mix(a, b, step(0.3, v)), c, step(0.6, v));\n}\n\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n  vec2 e0 = p1 - p0;\n  vec2 e1 = p2 - p1;\n  vec2 e2 = p0 - p2;\n\n  vec2 v0 = p - p0;\n  vec2 v1 = p - p1;\n  vec2 v2 = p - p2;\n\n  vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n  vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n  vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n  vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                     vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 pos = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n\n  pos = 8.0 * pos.yx * vec2(1.0,0.95) + vec2(sin(iTime),iTime);\n\n  vec4 h = hexagon(pos);\n  vec3 color_base, color_structure, color_icon;\n  get_hexagon_color(hash1(h.xy),color_base,color_structure,color_icon);\n\n  bool has_icon = false;\n  bool hollow = false;\n  vec2 hpos = position(pos);\n\n  vec2 points[6];\n    \n  points[0] = vec2(0.5773503 * 0.95, 0.5*0.5773503)*0.83;\n  points[1] = vec2(0.5773503 * 0.95,-0.5*0.5773503)*0.83;\n  points[2] = vec2(0.0, -0.5773503)*0.83;\n  points[3] = vec2(-0.5773503 * 0.95,-0.5*0.5773503)*0.83;\n  points[4] = vec2(-0.5773503 * 0.95,0.5*0.5773503)*0.83;\n  points[5] = vec2(0.0, 0.5773503)*0.83;\n\n  vec3 color = color_base;\n\n  float dist = (1.0 - length((h.xy + vec2(-0.4,-iTime))*0.08 - vec2(0.3,-0.3)));\n\n  float hexagon_scale = ( sin(iTime*3.0 + dist*16.0)*0.05 + 1.0)*0.85;\n\n  if (color_base != vec3(1.0))\n  {\n    float dline = 0.0;\n    float tri = 1.0;\n\n    int numTriangles = int(min(dist * 13.0,6.0));\n\n    if (numTriangles == 0) color_structure = vec3(1.0);\n\n    if (numTriangles > 0)\n    {\n      int nT = int(min(float(numTriangles),5.0));\n      for (int i = 0; i <= 6; ++i)\n      {\n      \tif (i > nT) break;\n        vec2 p = points[i]*0.85;\n        float d = line(hpos,vec2(0.0),p,0.01);\n        dline = max(d,dline);\n      }\n\n      if (numTriangles <= 5)\n      {\n        vec2 p_prev = points[0] * hexagon_scale;\n        for (int i = 0; i <= 5; ++i)\n        {\n          if (i > numTriangles) break;\n          vec2 p = points[i]*hexagon_scale;\n          float tri_d = sdTriangle(vec2(0.0),p_prev,p,hpos);\n          tri = min(tri,tri_d);\n          p_prev = p;\n        }\n      }\n      else if (numTriangles == 6)\n      {\n        tri = float(h.z < 1.0 - hexagon_scale);\n        has_icon = true;\n      }\n    }\n\n    color_base = mix(color_base,vec3(1.0),smoothstep(0.0,soft,tri));\n\n    color =  mix(color_base,color_structure, dline);\n  }\n  else if (dist > 0.05)\n  {\n    float d = h.z < 0.32 ? h.z : 0.0;\n    color = mix(color_base,color_structure,smoothstep(0.25 - soft,0.25 + soft,d));\n    has_icon = true;\n    hollow = true;\n  }\n\n  if (has_icon) \n  {\n    float v_icon = hash2(h.yx);\n\n    color = hollow ? color - color_icon * get_icon(v_icon,hpos.yx) :\nmax( color_icon * get_icon(v_icon,hpos.yx),color) ;   \n    ;\n  }\n\n  color -= 4.0 * pow(length(uv - 0.5),3.0) * vec3(0.08*smoothstep(0.8,1.0,1.0 - h.z));\n\n  fragColor = vec4(color, 1.0 );\n}\n\n","name":"","description":"","type":"image"}]}