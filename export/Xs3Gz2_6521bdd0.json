{"ver":"0.1","info":{"id":"Xs3Gz2","date":"1450748517","viewed":354,"name":"Blurry ray/cone marching","username":"public_int_i","description":"Some sort of ray/cone marching to blur a scene using only closest distance and color of closest object.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//Blurry ray/cone marching by Ethan Shulman 2015\n\n//I came up with this months ago when creating my own distance field \n//global illumination system. \n//After seeing XT95's hemisphere ambient occlusion it reminded me about\n//this because it works similarly.\n\n//It works pretty well but I'm sure it can be improved.\n\n\n#define EPSILON .01\n\nvec3 lightDir = normalize(vec3(2.,8.,6.));\n\n\nfloat ground(vec3 p) {\n    return abs(p.y+10.);\n}\n\nfloat walls(vec3 p) {\n    return length(max(abs(p+vec3(10.,0.,0.))-vec3(10.,10.,1.), 0.));\n}\n\nfloat spheres(vec3 p){\n    return length(abs(p)-8.)-2.;\n}\n\nfloat df(vec3 p) {\n    return min(ground(p),\n           min(spheres(p),\n               walls(p)));\n}\n\nvec3 colorAtPoint(vec3 p) {\n    int closestId = 0;\n    float closest = ground(p), closestTemp;\n    \n    if ((closestTemp = spheres(p)) < closest) {\n        closestId = 1;\n        closest = closestTemp;\n    }\n    \n    if ((closestTemp = walls(p)) < closest) {\n        closestId = 2;\n        closest = closestTemp;\n    }\n    \n    \n    vec3 oc;\n    if (closestId == 0) {\n        oc = vec3(.8);\n    }\n    if (closestId == 1) {\n        oc = vec3(max(0.,sign(p.z)),max(0.,-sign(p.z)),.3);\n    }\n    if (closestId == 2) {\n        oc = vec3(1.,.1,.1);\n    }\n    \n    return oc*(.3 + max(0., (df(p+lightDir*EPSILON)-df(p))/EPSILON));\n}\n\nfloat rand(vec3 s) {\n    \n    //Thanks to Shane for the improved random function\n    return fract(cos(dot(s, vec3(7, 157, 113)))*43758.5453);\n\n    /* old\n    return fract( (fract(s.x*32.924)*8. + fract(s.x*296.234) +\n                 fract(s.y*32.924)*8. + fract(s.y*296.234) +\n                 fract(s.z*32.924)*8. + fract(s.z*296.234))*98.397 );*/\n}\nvec3 randDir(vec3 s) {\n    return vec3(sin(rand(s.yzx+.89234)*34.24),\n                cos(rand(s.zxy-1.445)*34.24),\n                -cos(rand(s)*34.35));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy,\n        uv = (fragCoord.xy * 2. - R) / R.y;\n    \n    vec3 rp = vec3(0.,2.,20.);\n    vec3 rd = normalize(vec3(uv*2.,-1.));\n    \n    float blur = cos(iTime*.25)*.5+.5;\n    float coneSize = 10.*(blur*.8+.2),\n        \t\tconeRand = 0.25*blur,\n        \t\taddMult = .25+(1.-blur)*.5;\n    \n    vec4 c = vec4(0.);//color sum, w is alpha/opacity\n    vec3 lp = rd;\n    float s = 0.,ld = 0.;\n    for (int i = 0; i < 64; i++) {\n        vec3 p = rp+normalize(rd+randDir(lp)*coneRand*min(1., ld/(s*.05)))*s;\n        float d = df(p);\n        \n        if (d < coneSize) {\n            float alpha = (1.-d/coneSize)*addMult;\n            c += vec4(colorAtPoint(p)*alpha,alpha);\n        }\n        if (c.w > 1.) break;\n        s += d*(.5+rand(p)*.5);\n    \tlp = p;\n        ld = d;\n    }\n\t\n    fragColor = vec4(mix(vec3(0.),c.xyz,c.w),1.);\n}","name":"","description":"","type":"image"}]}