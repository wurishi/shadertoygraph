{"ver":"0.1","info":{"id":"3ldXD7","date":"1581136135","viewed":141,"name":"Heart SDF Base Code","username":"gracegi","description":"Base code for FemmeHacks tutorial, based on the work of Inigo Quilez: https://www.youtube.com/watch?v=aNR4n0i2ZlM\n\nMore SDF Functions:\nhttps://iquilezles.org/articles/distfunctions/distfunctions.htm\n\nFinal Code:\nhttps://www.shadertoy.com/view/wttXD7","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["femmehacks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265359;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat heartShape(vec3 p, float rad) {\n    // TODO 1: Change this to a heart SDF function\n    float result = length(p) - rad;\n    return result;\n    \n    // Heart SDF function:\n    //float z = p.z * (2.0 - p.y / 15.0);\n    //float y = 1.3 * p.y - abs(p.x) * sqrt(1.0 - abs(p.x));\n    //vec3 p2 = vec3(p.x, y, p.z);\n    //return length(p2) - rad;\n}\n\n// TODO 2.1: Write function to call heartShape with animated radius\n\n//float sceneSDF(vec3 samplePoint) {\n//    float result = heartShape(samplePoint, 0.2 * abs(sin(PI * iTime * 0.5 + samplePoint.y * 0.1)) + 0.6);\n//\treturn result;\n//}\n\n\n// get shortest distance to surface using ray marching\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // TODO 2.1: Call animated radius version of SDF instead of heartShape\n        //float dist = sceneSDF(eye + depth * marchingDirection);\n        float dist = heartShape(eye + depth * marchingDirection, 0.5); \n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n\n        // SPHERE CASTING! :D\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}           \n\n/////// ******** SHADER STUFF ******** ///////\n/////// don't worry about all of this! ///////\n/////// this is all to make the heart  ///////\n/////// shiny. if you want to know     ///////\n/////// more about this, ask or pop me ///////\n/////// an email!\t\t\t\t\t   ///////\n\n// estimate normal using SDF gradient\nvec3 estimateNormal(vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy * heartShape(pos + e.xyy, 0.7 ) +\n\t\t\t\t\t  e.yyx * heartShape( pos + e.yyx, 0.7 ) + \n\t\t\t\t\t  e.yxy * heartShape( pos + e.yxy, 0.7 ) + \n\t\t\t\t\t  e.xxx * heartShape( pos + e.xxx, 0.7 ));\n}\n\nvec2 map( vec3 q )\n{\n    q *= 100.0;\n\n    vec2 res = vec2( q.y, 2.0 );\n\n    float r = 15.0;\n    q.y -= r;\n    float ani = pow( 0.5+0.5*sin(6.28318*iTime + q.y/25.0), 4.0 );\n    q *= 1.0 - 0.2*vec3(1.0,0.5,1.0)*ani;\n    q.y -= 1.5*ani;\n    float x = abs(q.x);\n    float y = q.y;\n    float z = q.z;\n    y = 4.0 + y*1.2 - x*sqrt(max((20.0-x)/15.0,0.0));\n    z *= 2.0 - y/15.0;\n    float d = sqrt(x*x+y*y+z*z) - r;\n    d = d/3.0;\n    if( d<res.x ) res = vec2( d, 1.0 );\n    \n    res.x /= 100.0;\n    return res;\n}\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 kk;\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.01 + ap*0.2 ).x*20.0, 0.0, 1.0 );\n    }\n\tao /= 64.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\n/////////////////////////////////////////////////\n//////////////// end of shader ! ////////////////\n/////////////////////////////////////////////////\n\n\n/////////////// main function ///////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 eye = vec3(0, 0, 5.0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n\n    float an = 0.2*(iTime+2.0);\n    float u = gl_FragCoord.x * 2.0 / iResolution.x - 1.0;\n    float v = gl_FragCoord.y * 2.0 / iResolution.y - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 rayOrigin = (right * u * aspect + up * v - eye);\n    vec3 rayDirection = normalize(cross(right, up));\n\n    float dist = shortestDistanceToSurface(rayOrigin, rayDirection, MIN_DIST, MAX_DIST);\n    \n    // if our ray didn't hit anything, \n    if (dist >= MAX_DIST - 2.0 * EPSILON) {\n        // TODO 3: Change background from white to color gradiant\n        fragColor = vec4(1.0);\n        return;\n        \n        //vec4 color1 = vec4(0.25, 0.3, 0.8, 1.0);\n        //vec4 color2 = vec4(1.2, 0.77, 0.5, 1.0);\n        \n        //fragColor = mix(color2, color1, v * 0.5);\n        \n\t\t//return;\n    }\n    \n    vec3 position = rayOrigin + dist * rayDirection;\n    vec3 normal = estimateNormal(position);\n    vec3 ref = reflect(rayDirection, normal);\n    float fre = clamp(1.0 + dot(normal, rayDirection), 0.0, 1.0);\n    float occ = calcAO(position, normal); \n    occ = occ*occ;\n    // OPTIONAL TODO: change object color \n    vec3 col = vec3(0.9,0.05,0.01);\n    col = col*0.72 + 0.2*fre*vec3(1.0,0.8,0.2);\n            \n    vec3 lin  = 4.0*vec3(0.7,0.80,1.00)*(0.5+0.5*normal.y)*occ;\n    lin += 0.5*fre*vec3(1.0,1.0,1.00)*(0.6+0.4*occ);\n    col += smoothstep(0.0,0.4,ref.y)*(0.06+0.94*pow(fre,5.0))*occ;\n\n    col = pow(col,vec3(0.4545));\n    col = clamp(col,0.0,1.0);\n    \n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}