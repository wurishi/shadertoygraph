{"ver":"0.1","info":{"id":"tdfXDl","date":"1554220065","viewed":564,"name":"Relativity engine","username":"Kushulain","description":"Shows what we would live with slow speed of light. I took into account postulates of special relativity as much as I could.\nYou can enjoy the train paradox, doppler effect, FOV distortion, late drop shadows...\nControls :\nESDF to move + mouse drag.","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","time","slow","relativity","lorentz","lightspeed","dilation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 Get(float var)\n{\n    return texture(iChannel0,vec2(varWdth*0.5 + var * varWdth,0.2)/iResolution.xy).rgba;\n}\n\nvec3 GetMaterialsColor(RayInfo r, int matID)\n{\n    float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7);\n    //fakeOA = 1.;\n    \n    \n    switch(matID){\n    case 0:\n        return vec3(0.4,0.4,0.4)*fakeOA;\n    case 1:\n        return vec3(0.8,0.4,0.4)*fakeOA;\n    case 2:\n        return vec3(0.4,0.8,0.4)*fakeOA;\n    case 3:\n        return vec3(0.4,0.4,0.8)*fakeOA;\n    case 4:\n        return vec3(0.8,0.8,0.4)*fakeOA;\n    case 5:\n        return vec3(0.4,0.8,0.8)*fakeOA;\n    case 6:\n        return vec3(0.8,0.4,0.8)*fakeOA;\n    case 7:\n        return vec3(0.9,0.9,0.9)*fakeOA;\n    case 8:\n        return vec3(0.0,0.0,0.0)*fakeOA;\n\t}\n}\n\nvoid MarchLight(inout RayInfo r, float startTime, float maxDist)\n{\n    float totalDist = 0.0;\n    vec3 origin = r.pos;\n    \n    for (r.iter=0;r.iter<maxStepRayMarching;r.iter++){\n        r.time = startTime; \n    \tSetTime(r.time);\n        r.dist = map(r.pos,-1);\n        totalDist += r.dist;\n        \n        \n        r.pos+= r.dir*(r.dist);\n        if (abs(r.dist)<rayEps || totalDist > maxDist)\n        {\n            break;\n        }\n    }\n}\n\nvoid MarchPOV(inout RayInfo r, float startTime)\n{\n    //dpos = vec3(-2.2,0,0);\n    //lorentzF = LorentzFactor(length(dpos));\n    \n    float speedC = length(dpos)/SpeedOfLight;\n    vec3 nDpos = vec3(1,0,0);\n    \n    if (length(dpos) > 0.)\n    \tnDpos = normalize(dpos);\n    \n    //shrink space along vel axis (length contraction of field of view)\n    float cirContraction = dot(nDpos,r.dir)*(LorentzFactor(length(LgthContraction*dpos)));\n    vec3 newDir = (r.dir - nDpos*dot(nDpos,r.dir)) + cirContraction*nDpos;\n    r.dir = normalize(newDir);\n    \n    float dDirDpos = dot(dpos,r.dir);\n    \n    // Aberration of light, at high speed (v) photons angle of incidence (a) vary with lorenz factor (Y) :\n    // tan(a') = sin(a)/(Y*(v/c + cos(a)))\n    // velComponentOfRayDir' = Y*(velComponentOfRayDir+v/c)\n    float lightDistortion = lorentzF*(dot(-nDpos,r.dir)+speedC);\n    r.dir = mix(\n        r.dir,\n        normalize((r.dir - nDpos*dot(nDpos,r.dir)) - lightDistortion*nDpos),\n        FOVAberrationOfLight);\n    \n    //Classical Newtown Mechanic instead would be :\n    //r.dir = normalize(r.dir-dpos/SpeedOfLight);\n    \n    \n    for (r.iter=0;r.iter<maxStepRayMarching;r.iter++){\n        \n        float camDist = length(r.pos - objects[o_cam].pos);\n        \n        float photonDelay = -photonLatency*camDist/SpeedOfLight;\n        \n        //takes dilated distance x/Y and find the time in map frame with :\n        // v = -dDirDpos (dot product of direction & velocity, because we want to transform from cam frame to map frame)\n        // Y = lorentzFactor\n        //\n        // t' = Y(t-v*(x/Y)/c²)\n        // t' = Y(0-v*(x/Y)/c²)\n        // t' = Y(v*x/Y)/c²\n        // t' = vx/c²\n        float relativeInstantEvents = SimultaneousEvents*dDirDpos*camDist/(SpeedOfLight*SpeedOfLight);\n        \n    \tr.time = startTime;\n        r.time += mix(relativeInstantEvents,photonDelay,photonLatency);\n        \n        \n        \n    \tSetTime(r.time);\n        r.dist = map(r.pos,-1);\n        \n        \n        //blackhole Gravitational lens effect\n        vec3 blackHoleDirection = (objects[o_blackHole].pos-r.pos);\n        r.dir += (1./RayPrecision)*r.dist*normalize(blackHoleDirection)*BlackHoleMassFactor/(length(blackHoleDirection)*SpeedOfLight*SpeedOfLight);\n        r.dir = normalize(r.dir);\n        \n        if(abs(r.dist)<rayEps)\n            break;\n        r.pos+= (1./RayPrecision)*(r.dist)*(r.dir); //\n    }\n    \n    //r.pos = origin + r.dir*min(length(r.pos-origin),maxDist);\n    \n    r.surfaceNorm = GetNormal(r.pos).xyz;\n}\n\nvec3 GetDiffuse(RayInfo r)\n{\n    RayInfo tmpRay = r;\n    vec3 surfPos = r.pos;\n    \n    \n    vec3 diffuseCol = vec3(0);\n    //accretion disk\n    float accretion = blackHoleAccretionDisk;\n    \n    int mat = rayMat;\n    vec3 objVel = objects[rayObj].vel;\n    \n    vec3 lHalo = vec3(0);\n    \n    float[numLights] halos;\n    \n    for (int L=0; L<numLights; L++)\n    {\n        halos[L] = o_lights[L].haloResult;\n    }\n    \n    \n    for (int L=0; L<numLights; L++)\n    {\n        float lightLate;\n        for (int i=0; i<10; i++)\n        {\n            lightLate = photonLatency*length(o_lights[L].pos-surfPos) / SpeedOfLight;\n            ProcessLightValue(r.time-lightLate);\n        }\n        \n        vec3 lightRelPos = o_lights[L].pos-surfPos;\n        vec3 camLightDir = normalize(o_lights[L].pos-pos);\n        vec3 lightColor = o_lights[L].colorIntensity.rgb;\n        \n\t\tProcessLightValue(r.time-lightLate+0.01);\n        vec3 lightVel = ((o_lights[L].pos-surfPos)-lightRelPos)/0.01;\n        vec3 lightRelVel = lightVel - objVel;\n        \n        \n        vec3 lightDir = normalize(lightRelPos);        \n        vec3 camDir = normalize(pos-surfPos);\n        \n        vec3 camRelVel = dpos - objVel;\n        \n        float lightLorentzF = LorentzFactor(length(lightVel));\n        \n        //halo\n        float halo = halos[L];\n        float camDirLightSpeed = dot(camLightDir,lightVel);\n        float camDirCamSpeed = dot(camLightDir,dpos);\n        float haloRelativisticRelSpeed = (camDirCamSpeed-camDirLightSpeed)/(1.-(camDirCamSpeed*camDirLightSpeed/(SpeedOfLight*SpeedOfLight)));\n        \n        \n        SetTime(r.time);\n        vec3 matCol = GetMaterialsColor(tmpRay,mat);\n\n        RayInfo shadow;\n        \n        shadow.pos = surfPos + lightDir*0.1;\n        shadow.dir = lightDir;\n        float dropShadowAtten = 1.;\n        MarchLight(shadow, r.time, length(lightRelPos));\n        if (length(shadow.pos-surfPos) < (length(lightRelPos)-0.5))\n            dropShadowAtten = 0.4;\n\n        //SetTime(r.time);\n        //float distTime = map(surfPos,mat);\n        //SetTime(r.time+0.01);\n        //distTime = map(surfPos,mat) - distTime;\n        //float speed = -distTime*100.0;\n        float speed = 0.;\n        //speed += LorentzFactor(lightRelativisticRelSpeed);\n        speed += dot(lightDir,-lightRelVel);\n        speed += dot(camDir,-camRelVel);\n\n        float atten = max(0.,dot(lightDir,r.surfaceNorm));\n        //atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0);\n        atten *= 1./(0.5*length(lightRelPos)+1.);\n        //atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.);\n        atten *= dropShadowAtten;\n        \n        \n        diffuseCol += DopplerShiftFactor(lightColor * matCol * atten,\n                                   (SpeedOfLight/(SpeedOfLight-speed*dopplerFactor))*\n                                  \tlorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler));\n        lHalo += halo*DopplerShiftFactor(lightColor,\n                                   (SpeedOfLight/(SpeedOfLight-(haloRelativisticRelSpeed)*dopplerFactor))*\n                                  \t(lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler)));\n    }\n    \n    return  diffuseCol+(lHalo+accretion)*(1.-diffuseCol); //\n}\n\n\nvec3 GetSampleColor(vec2 uv)\n{\n    RayInfo r;\n    \n    //sets up ray direction\n    r.dir = vec3(0.,0.,1.);\n    \n    //applies fov\n    if (fishEye)\n    {\n    \tvec3 crossv = cross(r.dir,vec3(uv,0.));\n    \tr.dir = Rotate(BuildQuat(normalize(crossv),length(uv)*FOV),r.dir);\n    }\n    else\n    {\n    \tr.dir = vec3(uv.xy*FOV,1.);\n    }\n    \n    //applies look dir\n    r.pos = objects[o_cam].pos;\n    r.dir = Rotate(objects[o_cam].rot,r.dir);\n    \n    \n    MarchPOV(r,playerTime);\n        \n    \n    return GetDiffuse(r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.yy;\n    \n    pos = Get(POS).xyz;\n    dpos = Get(D_POS).xyz;\n    playerTime = Get(TIME).x;\n    \n    //vec3 LZZ = dpos;\n    //vec3 LZY = vec3(0,1,0);\n    //vec3 LZX = cross(LZY,normalize(LZZ));\n    //LZY = cross(LZZ,LZX);\n    //LZLgthContract = mat3x3(LZX,LZY,LZZ);\n    \n        \n   \tlorentzF = LorentzFactor(length(dpos));\n    SetTime(playerTime);\n    ProcessCamPos(Get(POS).xyz,Get(QUAT));\n    \n    vec3 color = GetSampleColor(uv);\n    \n    //float ao = 1.-float(r.iter)/float(maxStepRayMarching);\n\t\n    // Output to screen\n    fragColor = vec4(color*1.5,1.0);\n    \n    //vec2 uvs = fragCoord/iResolution.xy - 0.5;\n    \n    \n    //\n    //fragColor = vec4(uvs.x,uvs.y,0,1);\n    \n    //fragColor *= length(Get(D_POS).xyz)/SpeedOfLight;\n    \n    //displays Buffer\n    //fragColor += (texture(iChannel0,fragCoord/iResolution.xy).rgba );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nThis a relativistic engine, where speed of light can be slow to a few m/s.\n\n====== It takes into account :\n-Delayed view of far objects\n-Doppler Red/blue shifts of color\n-Field of view distortion\n-Relativistic Length Contractions\n-Relativistic Time Dilation + (Doppler & proper velocity consequences)\n-Relativistic simultaneity view (SimultaneousEvents = 1. & photonLatency = 0.)\n\n====== So far it doesn't into accout :\n-Doppler additionnal shift when space is contracted, not sure...\n-The rotating object in the middle of the scene is not really affected by doppler color shifting\n-Mass of object\n\n====== Things to enjoy :\n-Distorted drop shadow of the vertical pole.\n\n-You can see that field of view is correctly distorted by moving along with the train and notice\nit's not distorted anymore but the rest is. By setting the speed of light to a large number, the train will be\nexactly the same.\n\n-To better see the train paradox : put photonLatency & FOVAberrationOfLight to zero.\nExplanations : While at rest in front of the tunnel, watch the shrinked train entering and fitting in the tunnel.\nBut if you move along with the train, this one won't be shrinked, but the tunnel will be, the train will no longer\nfits in the tunnel. But... what happens if one close the tunnel doors at this time ?\n\n-While moving, see objects blue-shifted in front of you, and red-shifted behind you. Because of doppler effect.\n\n-See the result of a blinking light, slowly drawing waves on the walls.\n\n- Twin Paradox : Waiting for the train at a corner to make a whole return trip will take more time than if\nyou moving along with it.\n\n*/\n\n//light settings\n#define SpeedOfLight 2.5 //speed of light in meter/second\n#define photonLatency 1. //zero = instant vision, makes easier to see how relativity affect time & space\n#define FOVAberrationOfLight 1. //take relative velocity of photons to camera & distort field of view\n\n//optical settings\n#define dopplerFactor .5 //take player/object/light vel to shift color\n#define repeatDoppler false\n\n//relativity\n#define LgthContraction  1. //shrink map along velocity vector at high speed\n#define TimeDilation 1. //speed map frame time at high speed\n#define SimultaneousEvents 1. //see past behind you, futur foward at high speed (not supposed to be observed)\n#define relativisticDoppler .2 //take light source speed into account and their own time dilation\n\n//black hole\n#define BlackHoleMassFactor 2.\n#define AccretionDisk 2.\n\n\n//player and cam\n#define fishEye false\n#define FOV 1.3 //1.57 = 90\n#define maxSpeed 2.2 //do not go over speed of light it breaks time & space\n#define thrustForce 5. //player acceleration\n\n\n\n#define RayPrecision 1.\n#define maxStepRayMarching 80\n#define MaxRayDist 9.0\n\n#define ADD(func) rDist = min(rDist,func);\n#define SUB(func) rDist = max(rDist,-func);\n\n#define VOL(func)  if (func < rDist)\n//rDist = min(max(func,0.1),rDist);\n\n#define rayEps 0.001\n#define numMats 7\n#define numLights 3\n#define GI 1.3\n#define GIDist 2.5\n\n\n#define gravity vec3(0.,-3.,0.)\n\nfloat PI = 3.14159265359;\n\n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID == processedMaterial || processedMaterial == -1) { nextMat = matID; lastrDist = rDist;\n#define endMaterial() } if (rDist != lastrDist) rayMat = nextMat;  \n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\nint nextMat;\nint rayMat;\nint rayObj;\nfloat matSize;\nfloat lastrDist;\nfloat lastrDistObj;\nvec4 volumetricCol;\n\n\nfloat varWdth = 5.;\n\nfloat POS = 0.;\nfloat D_POS = 1.;\nfloat DD_POS = 2.;\nfloat QUAT = 3.;\nfloat D_QUAT = 4.;\nfloat TIME = 5.;\nfloat COLLISION = 6.;\nfloat CAM_PITCHYAW = 7.;\nfloat PROPER_D_POS = 8.;\nfloat TRAIN_TIME = 9.;\n\n\n// Keys\nconst float KEY_E = 69.5/255.;\nconst float KEY_D = 68.5/255.;\nconst float KEY_F = 70.5/255.;\nconst float KEY_S = 83.5/255.;\n\n\n//Quaternions\n\n\n//Life saving Quaternion function by ciberxtrem !\nvec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\nfloat maxGISize;\n\n//Basic Ray marching primitives\nfloat sphere(vec4 ray,vec3 pos, float radius)\n{\n    maxGISize = max(maxGISize,radius*ray.w);\n    return ray.w*(length(ray.xyz-pos) - radius);\n}\n\nfloat cylinderY(vec4 ray,vec3 pos, float radius, float height)\n{\n    maxGISize = max(maxGISize,height*radius*ray.w);\n    \n    return ray.w*(max(length(ray.xz-pos.xz) - radius, abs(ray.y-pos.y)-height));\n}\n\nfloat cylinderZ(vec4 ray,vec3 pos, float radius, float height)\n{\n    maxGISize = max(maxGISize,height*radius*ray.w);\n    \n    return ray.w*(max(length(ray.xy-pos.xy) - radius, abs(ray.z-pos.z)-height));\n}\n\nfloat cube(vec4 ray, vec3 pos, float size)\n{\n    maxGISize = max(maxGISize,size*ray.w);\n    \n    ray.xyz = abs(ray.xyz-pos) - size;\n    return ray.w*max(max(ray.x,ray.y),ray.z);\n}\n\nfloat line(vec4 ray, vec3 pos, float size)\n{\n    maxGISize = max(maxGISize,size*ray.w);\n    \n    ray.xyz = abs(ray.xyz-pos) - size;\n    return ray.w*max(ray.z,ray.y);\n}\n\nfloat box(vec4 ray, vec3 pos, vec3 size)\n{\n    maxGISize = max(maxGISize,length(size)*ray.w);\n    \n    ray.xyz = abs(ray.xyz-pos) - size;\n    return ray.w*max(max(ray.x,ray.y),ray.z);\n}\n\nfloat LogShift(float val, float target)\n{\n    float result = 0.;\n    \n    if (repeatDoppler)\n    {\n    \tfloat loga = log2(val);\n    \tresult = max(0.,     1.-abs(mod(loga-target,1.))*3.);\n    \tresult =       max(result, 1.-abs(mod(loga-target,1.)-1.)*3.);\n    }\n    else\n    {\n    \tfloat loga = log2(val);\n    \tresult = max(0.,     1.-abs(loga-target)*3.);\n    }\n    \n    \n    \n    return result;\n}\n\nfloat GetMatch(vec3 col, vec3 shiftedFreq, float targetFreq)\n{\n    float result = col.r*LogShift(shiftedFreq.r,targetFreq)+\n        \t\tcol.g*LogShift(shiftedFreq.g,targetFreq)+\n        \t\tcol.b*LogShift(shiftedFreq.b,targetFreq);\n    \n    return result;\n}\n\n//Doppler\nvec3 DopplerShiftFactor(vec3 oCol, float factor)\n{\n    vec3 freq = vec3(1.,1.257,1.58) * factor;\n        \n    vec3 result = vec3(0);\n    \n    result.r = \tGetMatch(oCol,freq,0.) + GetMatch(oCol,freq,1.)*0.3 + GetMatch(oCol,freq,-.33)*.2 ;\n    \n    result.g = \tGetMatch(oCol,freq,0.33);\n    \n    result.b = \tGetMatch(oCol,freq,0.66) + GetMatch(oCol,freq,1.)*.5 + GetMatch(oCol,freq,1.33)*.25 ;\n    \n    \n    \n    return result;\n}\n\n\nvec3 DopplerShift(vec3 oCol, float speed)\n{\n    return DopplerShiftFactor(oCol,SpeedOfLight/(SpeedOfLight-speed*dopplerFactor));\n}\n\n\n//scene\n\n//scene\nstruct Object\n{\n    vec4 rot;\n    vec3 pos;\n    vec3 vel;\n    vec3 scale;\n    float radius; //optimization\n};\n    \nstruct Light\n{\n    vec3 pos;\n    float size;\n    vec4 colorIntensity;\n    float haloResult;\n};\n\nObject[10] objects;\n\nint o_cam = 0;\nint o_myCube = 1;\nint o_myCubeChildren = 2;\nint o_train = 3;\nint o_tunnel = 4;\nint o_tunnel_door = 5;\nint o_blackHole = 6;\n\nfloat blackHoleAccretionDisk = 0.;\n\nLight[numLights] o_lights;\n\nstruct RayInfo\n{\n    vec3 dir;\n    vec3 pos;\n    vec3 surfaceNorm;\n    int iter;\n    float time;\n    float dist;\n    int object;\n    vec3 closestObject;\n};\n\nint curObj = 0;\nint minObjDepth = -1;\n    \n#define beginObj(objID,var) Transform(objects[objID],var); curObj = objID;  lastrDistObj = rDist;\n#define endObj() if (rDist != lastrDistObj) rayObj = curObj; lastrDistObj = rDist;\n\nvec4 Transform(Object infos, vec4 pos)\n{\n    pos.xyz = infos.pos-pos.xyz;\n    pos.xyz = Rotate(infos.rot,pos.xyz);\n    pos.xyz /= infos.scale;\n    \n    pos.w *= dot(vec3(1),abs(infos.scale))/3.; //distance field dilation approx\n    \n    return pos;\n}\n\n\nvoid ProcessCamPos(vec3 pos, vec4 rot)\n{\n    objects[o_cam].pos = pos;\n    //objects[o_cam].pos = vec3(0,0,-5);\n    objects[o_cam].rot = rot;\n}\n\nfloat lorentzF;\n//mat3x3 LZLgthContract;\nvec3 pos;\nvec3 dpos;\nfloat playerTime;\n\nfloat LorentzFactor(float vel)\n{\n    float vSqr = (vel*vel)/(SpeedOfLight*SpeedOfLight);\n\n    return 1./(sqrt(1.-min(vSqr,0.9999)));\n}\n\nvoid ProcessObjectPos(float time)\n{\n    \n    objects[o_myCube].pos = vec3(0,0,0);\n    objects[o_myCube].rot = BuildQuat(vec3(0,1,0),time*2.);\n    objects[o_myCube].scale = vec3(0.8);\n    \n    objects[o_blackHole].pos = vec3(5.,sin(time*0.2),-5.);\n    objects[o_blackHole].rot = BuildQuat(vec3(0,1,0),time*2.);\n    objects[o_blackHole].scale = vec3(1.);\n    \n    objects[o_myCubeChildren].pos = vec3(1,1,1);\n    objects[o_myCubeChildren].rot = BuildQuat(normalize(objects[o_myCubeChildren].pos),time*1.);\n    //o_myCubeChildren.rot = vec4(0,0,0,1);\n    objects[o_myCubeChildren].scale = vec3(.4,.4,.4);\n    \n    float trainV = 2.2;\n    objects[o_train].vel = vec3((floor(mod(trainV*time/16.,2.))*2.-1.)*trainV,0,0); \n    \n    \n    float trainDir = 1.;\n    if (objects[o_train].vel.x < 0.)\n        trainDir = -1.;\n    \n    objects[o_train].pos = vec3(abs(1.-mod(trainV*time/16.,2.))*16.-8.,-.8,9.);\n    objects[o_train].rot = BuildQuat(vec3(0,1,0),PI*.5);\n    objects[o_train].scale = vec3(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,photonLatency)); ///\n    \n    //objects[o_train].pos.x = 0.;\n    objects[o_tunnel].pos = vec3(0.,-.8,9.);\n    objects[o_tunnel].rot = BuildQuat(vec3(0,1,0),PI*.5);\n    objects[o_tunnel].scale = vec3(1.,1.,1);\n    \n    objects[o_tunnel_door].pos = objects[o_tunnel].pos;\n    objects[o_tunnel_door].rot = objects[o_tunnel].rot;\n    float open = clamp((1.-abs(3.*objects[o_train].pos.x))*2.,0.,1.);\n    objects[o_tunnel_door].scale = vec3(open,open,1);\n}\n\nvoid ProcessLightValue(float time)\n{\n    time *= 1.;\n    \n    o_lights[0].pos = vec3(6.,1.,sin(time));\n    o_lights[0].colorIntensity = 3.*vec4(0.2,1.,.2,1);\n    o_lights[1].pos = vec3(-3,-2.2,sin(time*.3)*8.);\n    o_lights[1].colorIntensity = 2.*vec4(1,1,0.5,1);\n    o_lights[2].pos = vec3(9.5,1.8,9.5);\n    o_lights[2].colorIntensity = 3.*max(0.,abs(sin(PI*time)))*vec4(1,0.2,1,1);\n}\n\nvoid SetTime(float time)\n{\n    ProcessLightValue(time);\n    ProcessObjectPos(time);\n}\n\n\nfloat map(vec3 pos, int processedMaterial)\n{\n    float rDist = 0.; //0. if first operation is a SUB(), 1e10 otherwise\n    maxGISize = 0.;\n    rayObj = 0;\n    \n    vec4 worldSpace = vec4(pos,1);\n    \n    \n    beginMaterial(0)\n    SUB(box(worldSpace,vec3(0,0,0),vec3(10,2.5,10)));\n    \n    ADD(cylinderY(worldSpace,vec3(-6,0,-2.),0.1,3.));\n    ADD(cylinderY(worldSpace,vec3(5,0,-2.),0.1,3.));\n    endMaterial()\n    \n    vec4 cubeSpace = beginObj(o_myCube,worldSpace);\n    //ADD(box(cubeSpace,vec3(0,0,0),vec3(1)));\n    \n    //cubeSpace.xz = abs(cubeSpace.xz);\n    vec4 cubeChildrenSpace = cubeSpace;\n    \n    for (int i=0; i<4; i++)\n    {\n    \tbeginMaterial(i)\n        ADD(sphere(cubeChildrenSpace,vec3(0,0,0),1.));\n    \tendMaterial()\n        cubeChildrenSpace = abs(cubeChildrenSpace);\n        cubeChildrenSpace = beginObj(o_myCubeChildren,cubeChildrenSpace);\n    }\n    \n\tvec4 blackHoleSpace = beginObj(o_blackHole,worldSpace);\n    beginMaterial(8)\n    ADD(sphere(blackHoleSpace,vec3(0,0,0),.5));\n    endMaterial()\n    \n        \n    vec4 tunnelSpace = beginObj(o_tunnel,worldSpace);\n    beginMaterial(3)\n    ADD(box(tunnelSpace,vec3(0,.5,0),vec3(.2,.1,1.5)));\n    ADD(box(tunnelSpace,vec3(0,-.5,0),vec3(.2,.1,1.5)));\n    endMaterial()\n    \n    vec4 tunnelDoorSpace = beginObj(o_tunnel_door,worldSpace);\n    beginMaterial(4)\n    ADD(box(tunnelDoorSpace,vec3(0,0,1.4),vec3(.2,.4,0.1)));\n    ADD(box(tunnelDoorSpace,vec3(0,0,-1.4),vec3(.2,.4,0.1)));\n    endMaterial()\n        \n    vec4 trainSpace = beginObj(o_train,worldSpace);\n    beginMaterial(7)\n    ADD(box(trainSpace,vec3(0,0,-.8),vec3(.1,.1,.18)));\n    ADD(box(trainSpace,vec3(0,0,-.4),vec3(.1,.1,.18)));\n    ADD(box(trainSpace,vec3(0,0,0),vec3(.1,.1,.18)));\n    ADD(box(trainSpace,vec3(0,0,.4),vec3(.1,.1,.18)));\n    ADD(box(trainSpace,vec3(0,0,.68),vec3(.1,.1,.06)));\n    ADD(cylinderZ(trainSpace,vec3(0,.04,.8),.07,.18));\n    endObj()\n    endMaterial()\n        \n    float temp = max(0.,(1.-20.*abs(blackHoleSpace.y)));\n    float tmpGauss = length(blackHoleSpace.xz)-1.5;\n    rDist = min(rDist,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))));\n    temp *= rDist*pow(2.7,-(tmpGauss*tmpGauss)/(0.1));\n    \n    blackHoleAccretionDisk += (1.-blackHoleAccretionDisk)*temp * AccretionDisk;\n        \n    for(int L=0; L<3; L++)\n    {\n    \tADD(sphere(worldSpace,o_lights[L].pos,0.001));\n        vec3 relPos = o_lights[L].pos-pos;\n        o_lights[L].haloResult += rDist*(0.02/(dot(relPos,relPos)+0.01));\n    }\n        \n    \n        \n    return rDist;\n}\n\nvec4 GetNormal(vec3 pos)\n{\n    vec2 e = vec2(0.003,0.);\n    float o = map(pos,-1);\n    return vec4(normalize(vec3(\tmap(pos+e.xyy,-1) - o,\n                          \t\tmap(pos+e.yxy,-1) - o,\n                          \t\tmap(pos+e.yyx,-1) - o)),o);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 Get(float var)\n{\n    return texture(iChannel0,vec2(varWdth*0.5 + var * varWdth,.5)/iResolution.xy).rgba;\n}\n\nbool Processing(float var, float pos)\n{\n    return (pos > var * varWdth) && (pos < (var+1.) * varWdth);\n}\n\nvec3[5] collidersPos;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float uvx = fragCoord.x;\n    \n    if (fragCoord.y > 10. || fragCoord.x > varWdth*10.)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    \n    pos = Get(POS).xyz;\n    dpos = Get(D_POS).xyz;\n    vec4 quat = Get(QUAT);\n    vec4 dquat = Get(D_QUAT);\n    vec2 pitchYaw = Get(CAM_PITCHYAW).xy;\n    float time = Get(TIME).x;\n    float deltaT = min(0.1,iTimeDelta);\n    \n    float playerLorentzFactor = LorentzFactor(length(dpos));\n    \n    time += deltaT* mix(1.,playerLorentzFactor,TimeDilation);\n    \n    SetTime(time);\n    ProcessCamPos(pos,quat);\n    \n    \n    vec3 acc = vec3(0.);\n    \n    vec2 e = vec2(0.002,0.);\n    \n    vec3 forward = Rotate(quat,vec3(0.,0.,1.));\n    vec3 up = Rotate(quat,vec3(0.,1.,0.));\n    vec3 right = Rotate(quat,vec3(1.,0.,0.));\n    \n    \n    vec3 velDir = normalize(dpos);\n    vec4 normDist = GetNormal(pos+vec3(0.,-2.,0.));\n    vec3 norm = normDist.xyz;\n    float proxAlert = normDist.a;\n    //grav += normalize(norm-grav) * iTimeDelta;\n    \n    //collisions\n    float collisionViolence = dot(velDir,-norm);\n    \n    \n    vec2 mousePos = iMouse.xy - iResolution.xy * 0.5;\n    \n        \n\t//inputs\n    vec2 joystick = (mousePos.xy)/iResolution.yy;\n    \n    \n    \n    if (mousePos.x == 0. && mousePos.y == 0.)\n        joystick *= 0.;\n    \n    joystick *= max(1.,joystick.x);\n    joystick *= 8.0;\n    \n    if (iMouse.z <= 0.)\n        joystick = vec2(0);\n    \n    pitchYaw += joystick*deltaT;\n    \n    pitchYaw.y = clamp(pitchYaw.y,-PI*0.45,PI*0.45);\n    \n    quat = BuildQuat(vec3(0,1,0), pitchYaw.x);\n    right = Rotate(quat,vec3(1.,0.,0.));\n    quat = MulQuat(BuildQuat(right, -pitchYaw.y),quat);\n    //quat = MulQuat(BuildQuat(forward, -deltaT*joystick.x),quat);\n    \n    vec3 groundForwardDir = cross(right,vec3(0,1,0));\n        \n    float thurst = texture(iChannel1, vec2(KEY_E, 0.2)).x - texture(iChannel1, vec2(KEY_D, 0.2)).x;\n    acc += thurst*groundForwardDir*thrustForce;\n    float strafe = texture(iChannel1, vec2(KEY_F, 0.2)).x - texture(iChannel1, vec2(KEY_S, 0.2)).x;\n    acc += strafe*right*thrustForce;\n    \n    if (length(acc) > thrustForce)\n        acc = normalize(acc)*thrustForce;\n    \n    //gravity\n    acc += gravity;// * abs(dot(norm,forward));\n    \n    //drag\n    acc -= (dpos/maxSpeed)*thrustForce;\n    \n    //add acceleration\n    //dpos +=  deltaT*acc;\n    dpos +=  (deltaT*acc);///(playerLorentzFactor*playerLorentzFactor);\n    //properDpos += (deltaT*acc)/(playerLorentzFactor*playerLorentzFactor);\n    \n        \n    if (length(dpos) > maxSpeed)\n        dpos = normalize(dpos)*0.999*maxSpeed;\n        \n    \n    \n    \n\tif (proxAlert <= 0.0)\n    {\n        //if (collisionViolence > 0.)\n        //\tdpos = reflect(dpos,norm)/(collisionViolence*10.+1.);\n        dpos.y = 0.;\n        //pos.y = 0.;\n        //pos = vec3(0.,0.,-4.);\n    }\n    \n    \n    vec4 wallCollision = GetNormal(pos);\n    \n    \n    //velDir = normalize(dpos);\n    \n    //nose fall / stall\n    //quat = MulQuat(BuildQuat(cross(forward,velDir),length(velDir-forward)*deltaT),quat);\n    \n    //add derivatives\n    pos += deltaT*dpos*mix(1.,playerLorentzFactor,TimeDilation);\n    \n    if (wallCollision.w < 0.5)\n    {\n        dpos.xz -= max(0.,dot(dpos.xz,-wallCollision.xz)) * dpos.xz;\n        pos.xz += (wallCollision.xz) * (.5-wallCollision.w);\n    }\n    \n    if (iFrame == 0)\n    {\n        dpos = vec3(0.,0.,0.0);\n        pos = vec3(0.,0.,-4.);\n        quat = vec4(0,0,0,1);//BuildQuat(vec3(1.,0.,0.),1.57);\n    }\n    \n    \n    if (Processing(POS,uvx) )\n    \tfragColor = vec4(pos,1.);\n    if (Processing(D_POS,uvx) )\n    \tfragColor = vec4(dpos,1.);\n    if (Processing(QUAT,uvx) )\n    \tfragColor = vec4(quat);\n    if (Processing(D_QUAT,uvx) )\n    \tfragColor = vec4(dquat);\n    if (Processing(DD_POS,uvx) )\n    \tfragColor = vec4(acc,1.);\n    if (Processing(TIME,uvx) )\n    \tfragColor = vec4(time);\n    if (Processing(COLLISION,uvx) )\n    \tfragColor = vec4((proxAlert));\n    if (Processing(CAM_PITCHYAW,uvx) )\n    \tfragColor = vec4(pitchYaw,0,0);\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}