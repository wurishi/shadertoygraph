{"ver":"0.1","info":{"id":"MstyRn","date":"1517808046","viewed":108,"name":"Good circle","username":"jgkling","description":"using smoothstep to mask inside, outside and edge of a circle with \"anti-aliasing\"","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RADIUS 0.3\n#define edgeThickness 0.03\n\nfloat sphereSDF( vec2 p, float radius ) {\n    return length(p) - radius;\n}\n\n// Reason why we need two smoothsteps: to allow the edge to have a color that is not just\n// a blend of the inside and outside colors.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 ndc = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    float sdf = sphereSDF(ndc, RADIUS);\n    \n    // smoothstep from inside the circle to outside to create the edge\n    float ss = smoothstep(0.0, edgeThickness, sdf);\n    \n    // Multiply the outgoing smoothstep with the incoming smoothstep\n    float ss2 = ss * (1.0 - ss);\n    \n    // Artificially scale up since the values are low after the above multiply\n    ss2 *= 5.0; // some magic number\n    \n    // Smoothstep returns values like:\n    // 0 0 0 lowerEdge interpolatedValues upperEdge 1 1 1\n    \n    // Use the original smoothstep to determine inside/outside the circle\n    // Use the second smoothstep for the edge\n    vec3 insideCol = vec3(0, 0, 0);\n    vec3 outsideCol = vec3(1, 1, 1);\n    vec3 edgeCol = vec3(1, 0, 1);\n    \n    // Blend everything together\n    vec3 mixedCol1 = mix(insideCol, outsideCol, ss);\n    vec3 finalCol = mix(mixedCol1, edgeCol, ss2);\n    \n    // Output\n    fragColor = vec4(finalCol, 1);\n}\n","name":"Image","description":"","type":"image"}]}