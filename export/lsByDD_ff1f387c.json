{"ver":"0.1","info":{"id":"lsByDD","date":"1492122780","viewed":242,"name":"Line Segment Intersection","username":"eriwine","description":"Renders 2 line segments and highlights the point where they intersect","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["linesegmentintersectionwidth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Back color\nvec4 BackColor = vec4(1.0,1.0,1.0,1.0);\n\n//Line 1\nvec2 L1A = vec2(0.8,0.1);\nvec2 L1B = vec2(0.2, 0.5);\nfloat L1Thickness = 0.001;\nvec4 L1Color = vec4(0.2,0.7,0.2,1.0);\n\n//Line 2\nvec2 L2A = vec2(0.3,0.1);\nvec2 L2B = vec2(0.9, 0.5);\nfloat L2Thickness = 0.001;\nvec4 L2Color = vec4(0.2,0.2,0.8,1.0);\n\n//Intersection\nvec4 IntersectColor = vec4(1.0,0.0,0.0,1.0);\nfloat IntersectRadius = 0.005;\n\n//length squared\nfloat lengthSquared(vec2 v, vec2 w)\n{\n    return (v.x - w.x) * (v.x - w.x) + (v.y - w.y) * (v.y - w.y);\n}\n\n//Returns squared distance between point p and line segment L defined by endpoints LA, LB\nfloat distanceToSegmentSquared(vec2 p, vec2 LA, vec2 LB)\n{\n    //distance of line segment\n    float l2 = lengthSquared(LA,LB);\n    //If line segment is 0 length, just get difference with first endpoint\n    if (l2 == 0.0) \n        return lengthSquared(p, LA);\n    \n    //Vector representation of L\n    vec2 v = LB - LA;\n    vec2 w = p - LA;\n    \n    //t is percentage along line L point p falls\n    float t = dot(w,v) / l2;  \n    t = clamp(t,0.0,1.0);\n    \n    //projection of p onto v,w is nearest point\n    vec2 nearestPoint = vec2(LA.x + t * v.x, LA.y + t * v.y);\n    \n    //Distance between p and projectedpoint\n    return lengthSquared(p, nearestPoint);\n}\n\nfloat distanceToSegment(vec2 p, vec2 v, vec2 w)\n{\n    return sqrt(distanceToSegmentSquared(p,v,w));\n}\n\n//Cross product of 2d vectors returns scalar\n//1 = perpendicular, 0 = colinear\nfloat cross2D(vec2 v1, vec2 v2)\n{\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\n//Line intersection algorithm\n//Based off Andre LeMothe's algorithm in \"Tricks of the Windows Game Programming Gurus\".\nbool lineIntersection(vec2 L1A, vec2 L1B, vec2 L2A, vec2 L2B, out vec2 p)\n{\n    //Line 1 Vector\n    vec2 v1 = L1B - L1A;\n    \n    //Line 2 Vector\n    vec2 v2 = L2B - L2A;\n    \n    //Cross of vectors\n    float d = cross2D(v1,v2);\n    \n    //Difference between start points\n    vec2 LA_delta = L1A - L2A;\n    \n    //Percentage v1 x LA_delta is along v1 x v2\n    float s = cross2D(v1,LA_delta) / d;\n    \n    //Percentage v2 x LA_delta is along v1 x v2\n    float t = cross2D(v2,LA_delta) / d;\n    \n    //Do segments intersect?\n    //Bounds test\n    if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0)\n    {\n        //Projection\n        p = vec2(L1A.x + (t * v1.x), L1A.y + (t * v1.y)); \n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y*=(iResolution.y/iResolution.x);\n    \n\tvec4 color = BackColor;\n    \n    //L1A.x+=sin(iTime)*0.2;\n    \n    //Draw line 1\n    if (distanceToSegment(uv, L1A, L1B) < L1Thickness)\n    {\n        color = L1Color;\n    }\n    \n    //Draw line 2\n    if (distanceToSegment(uv, L2A, L2B) < L2Thickness)\n    {\n        color = L2Color;\n    }\n    \n    //Draw intersection\n    vec2 p;\n    if (lineIntersection(L1A, L1B, L2A, L2B, p))\n    {\n        if (length(p - uv) < IntersectRadius)\n        {\n            color = IntersectColor;\n        }\n    }\n        \n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}