{"ver":"0.1","info":{"id":"WdsSWs","date":"1552559236","viewed":107,"name":"evankh_Landscape","username":"evankh","description":"Playing around with generating & coloring a heightmap","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","landscape","ramp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int VERY_DEEP_WATER = 0;\nconst int DEEP_WATER = 1;\nconst int MEDIUM_WATER = 2;\nconst int SHALLOW_WATER = 3;\nconst int BEACH = 4;\nconst int GRASS = 5;\nconst int FOREST = 6;\nconst int MOUNTAIN = 7;\nconst int SNOW = 8;\nconst int NUM_TERRAIN_TYPES = 9;\n\nvec2 size = vec2(25.0, 12.0);\nvec3 terraincolors[] = vec3[](vec3(0.2,  0.6,  1.0),\n                              vec3(0.3,  0.65, 1.0),\n                              vec3(0.4,  0.7,  1.0),\n                              vec3(0.5,  0.75, 1.0),\n                              vec3(1.0,  0.9,  0.8),\n                              vec3(0.25, 0.75, 0.25),\n                              vec3(0.15, 0.45, 0.15),\n                              vec3(0.5),\n                              vec3(1.0));\nfloat terrainheights[] = float[](-7.0, -5.0, -1.5, 0.0, 0.5, 3.0, 5.0, 10.0);\nfloat octaveSize[5] = float[](5.0, 3.0, 1.0, 0.25, 1.0/7.0);\nfloat octaveAmpl[5] = float[](10.0, 8.0, 2.0, 0.25, 0.4);\n\nvec3 shadowcolor = vec3(0.05, 0.05, 0.05);\nconst float shadow_threshold = 25.0;\nconst float shadow_slope = 0.015;\nconst float shadow_fade = 3.0;\n\nvec3 linecolor = vec3(0.0, 0.2, 0.5);\nconst float line_freq = 100.0;\nconst float line_width = 0.3;\nconst float line_length = 1.5;\n\nconst float tree_freq = 150.0;\nconst float tree_height = 0.75;\nconst float tree_radius = 0.3;\nconst float tree_max_radius = 1.0;\nconst float tree_slope = 1.0/(tree_max_radius - tree_radius);\nconst float tree_max = 1.0 + tree_radius * tree_slope;\n\nint ramp(float x) {\n    for (int i = 0; i < NUM_TERRAIN_TYPES - 1; i++)\n        if (x < terrainheights[i]) return i;\n    return NUM_TERRAIN_TYPES - 1;\n}\n\nfloat Sample(vec2 x) {\n    vec2 grid = floor(size * x);\n    vec2 offs = smoothstep(0.0, 1.0, fract(size * x));\n    float noise1 = texture(iChannel0, grid / size).r;\n    float noise2 = texture(iChannel0, (grid + vec2(1.0, 0.0)) / size).r;\n    float noise3 = texture(iChannel0, (grid + vec2(0.0, 1.0)) / size).r;\n    float noise4 = texture(iChannel0, (grid + vec2(1.0)) / size).r;\n    return mix(mix(noise1, noise2, offs.x), mix(noise3, noise4, offs.x), offs.y);\n}\n\nfloat correct(float x) {\n    if (x < 0.5) return x;\n    if (x < 5.0) return 0.5;\n    return 0.8*(x-5.0)+3.0;\n}\n\nfloat noise(vec2 x) {\n    float height_suggestion = distance(x, vec2(0.5,0.0))-1.5;\n    //height_suggestion *= height_suggestion * height_suggestion;\n    //height_suggestion *= height_suggestion * height_suggestion;\n    //height_suggestion = correct(height_suggestion);\n    float sum = 0.0;\n    for (int i = 0; i < 5; i++)\n        sum += octaveAmpl[i] * Sample(x / octaveSize[i]);\n    return correct(sum + 22.0 * height_suggestion);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    size.x = 13.0 + 45.0 / 100.0;\n    size = vec2(100.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= vec2(0.5);\n    uv *= 2.0;\n    uv += vec2(0.5);\n    \n    float noisebase = noise(uv);\n    float eps = 0.005;\n    vec2 duv = vec2(noise(uv + vec2(eps, 0.0)), noise(uv + vec2(0.0, eps))) - noisebase;\n    duv /= eps;\n    \n    int terrain = ramp(noisebase);\n    \n    float sum = 0.0;\n    for (int i = 0; i < 5; i++) sum += octaveAmpl[i];\n    int terr = ramp(noisebase);\n    \n    // Make one side of the mountain darker\n    float shadefac = dot(duv, normalize(vec2(1.0, 0.25)));\n    shadefac = 1.0 + shadow_slope * (shadow_threshold - shadefac);\n    shadefac = max(shadefac, 1.0 - (noisebase - terrainheights[MOUNTAIN - 1]) / shadow_fade);\n    shadefac = clamp(shadefac, 0.0, 1.0);\n    terraincolors[MOUNTAIN] = mix(shadowcolor, terraincolors[MOUNTAIN], shadefac);\n    terraincolors[SNOW] = mix(shadowcolor, terraincolors[SNOW], shadefac);\n    \n    // Draw lines in the water near the island\n    float lines = clamp(-line_length - noisebase, 0.0, 1.0);\n    lines = max(step(line_width, fract(uv.y * line_freq)), lines);\n    terraincolors[SHALLOW_WATER] = mix(linecolor, terraincolors[SHALLOW_WATER], lines);\n    terraincolors[MEDIUM_WATER] = mix(linecolor, terraincolors[MEDIUM_WATER], lines);\n    terraincolors[DEEP_WATER] = mix(linecolor, terraincolors[DEEP_WATER], lines);\n    terraincolors[VERY_DEEP_WATER] = mix(linecolor, terraincolors[VERY_DEEP_WATER], lines);\n    \n    // Darken the area near the coastline\n    float land_dist = clamp(-noisebase*1.5, 0.0, 1.0);\n    terraincolors[SHALLOW_WATER] = mix(shadowcolor, terraincolors[SHALLOW_WATER], land_dist);\n    \n    // Draw a tree pattern in the forest\n    vec2 treeuv = vec2(uv.x - tree_height * uv.y, uv.x + tree_height * uv.y);\n    vec2 tree = (floor(treeuv * tree_freq) + 0.5) / tree_freq;\n    float forest = distance(treeuv, tree) * tree_freq;\n    forest = clamp(tree_max - tree_slope * forest, 0.0, 1.0);\n    terraincolors[FOREST] *= forest;\n\n    vec3 col = terraincolors[terr];\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}