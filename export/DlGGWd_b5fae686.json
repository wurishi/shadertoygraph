{"ver":"0.1","info":{"id":"DlGGWd","date":"1689764838","viewed":17,"name":"Flowing space","username":"pik","description":"reflect,ao,shadow,spec,diff,path,raycsatmarch,postprocess,glow,texture,mouse,GAMMA,SATURATION","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sample"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.shadertoy.com/view/Xtf3Rn\n\n#define SCREEN_EDGE\n#define POSTPROCESS\n#define SHADOW\nconst  float GAMMA=1.3;\nconst float BRIGHTNESS=0.99;\nconst float SATURATION=0.85;\nconst vec3 FOG_COLOR=vec3(0.1,0.1,0.);\nconst vec3 LIGHT_COLOR=vec3(0.2,0.1,0.3);\nconst vec3 AMBIENT_COLOR=vec3(0.1);\nconst vec3 FLOOR_COLOR=vec3(0.1,0.8,0.1);\n\nconst vec3 lightdir=normalize(vec3(1.,0.,-2.));\nconst float detail=0.0001;\nconst float spr=0.15;\nfloat det;\nvec3 sppos;\n\nmat2 rot(float t)\n{\n    return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nvec3 path(float ti)\n{\n    return vec3(sin(ti),.3-sin(ti*.632)*.3,cos(ti*.5))*.5;\n}\nfloat tex(vec3 p)\n{\n    vec3 d=mod(floor(p*2.),2.)*2.-1.;\n    float n=d.x*d.y*d.z;\n    return step(0.,n);\n}\n\nvec3 setcam(vec3 cam,vec3 tar,vec2 uv,inout vec2 an)\n{\n    vec3 fo=normalize(tar-cam);\n    vec3 up=vec3(0.,1.,0.);\n    vec3 si=normalize(cross(fo,up));\n    up=cross(si,fo);\n    an=vec2(atan(fo.x,fo.z),fo.y);\n    return normalize(uv.x*si+uv.y*up+fo);\n}\n\nfloat sphere(vec3 ro,vec3 dir,float r)\n{\n    vec3 oc=ro;\n    float b=dot(oc,dir);\n    float c=dot(oc,oc)-r*r;\n    float h=b*b-c;\n    if(h<0.0) return -1.0;\n    h=sqrt(h);\n    return -b-h;\n}\n\nvec2 map(vec3 p)\n{\n    float mat=0.;\n    float d1=p.y+0.5;\n    vec3 q=p;\n    q=mod(q,0.5)-0.25;\n    float d2=length(q)-0.1;\n    float d=min(d1,d2);\n    if(abs(d-d2)<0.001)mat=1.;\n    \n    \n    return vec2(d,mat);\n}\nvec3 normal(vec3 p)\n{\n    vec2 e=vec2(0.0001,0.);\n    return normalize(\n        vec3(map(p+e.xyy).x-map(p-e.xyy).x,\n             map(p+e.yxy).x-map(p-e.yxy).x,\n             map(p+e.yyx).x-map(p-e.yyx).x));\n}\n\nfloat shadow(vec3 p,vec3 dir)\n{\n    float sh=1.;\n    float dist=det*2.;\n    float d=10.;\n    float t1=sphere(p-0.005*lightdir-sppos,-dir,spr);\n    if(t1>0. && t1<0.5)\n    {\n        vec3 n=normalize(p-dir*t1-sppos);\n        sh=1.-pow(max(0.,dot(n,dir))*1.2,3.);\n    }\n    for(int i=0;i<50;i++)\n    {\n        if(dist<0.6 && d>detail)\n        {\n            vec3 q=p-dist*dir;\n            dist=map(q).x;\n            sh=min(sh,max(0.,50.*d/dist));\n            dist+=max(0.01,d);\n        }\n    }\n    return clamp(sh,0.1,1.);\n}\n\nfloat calcAO(vec3 p,vec3 dir)\n{\n    float aodet=detail*40.;\n    float ao=0.;\n    float sc=14.;\n    for(int aoi=0;aoi<5;aoi++)\n    {\n        float hr=aodet*float(aoi*aoi);\n        vec3 aopos=p+dir*hr;\n        float d=map(aopos).x;\n        ao+=(hr-d)*sc;\n        sc*=0.7;\n    }\n        return clamp(1.-5.*ao,0.,1.);\n}       \n\nvec3 light(vec3 p,vec3 dir,vec3 n,float mat)\n{\n    vec3 col;\n    float sh;\n    sh=calcAO(p,-2.5*lightdir);//softshadow\n    #ifdef SHADOW\n        sh=shadow(p,lightdir);\n    #endif\n    float ao=calcAO(p,n);\n    float diff=max(0.,dot(-lightdir,n))*sh;\n    vec3 amb=max(0.5,dot(-dir,n))*0.5+AMBIENT_COLOR;\n    vec3 r=reflect(-lightdir,n);\n    float spec=pow(max(0.,dot(dir,r)),10.);\n    //COLOR\n    if(mat>1.5)\n    {\n        col=vec3(1.);\n        spec=spec*spec;\n    }\n    else\n    {\n        float k=tex(p);\n        col=mix(vec3(k,k*k,k*k*k),vec3(k,k,k),0.3);\n        if(abs(mat-0.)<0.01){col*=FLOOR_COLOR;}\n    }\n    col=col*amb+col*diff*LIGHT_COLOR+spec*LIGHT_COLOR;\n    col*=min(1.,ao);\n    return col;\n}\n\nvec3 raymarch(vec3 ro,vec3 dir)\n{\n    vec3 col;\n    vec3 p=ro;vec3 rd=dir;vec3 n0=vec3(0.);vec3 n1=vec3(0.);vec3 n=vec3(0.);\n    float glow=0.;\n    float sp=0.;\n    vec2 ref=vec2(1.,0.);//(distance,material)//raymarching//\n    det=0.;\n    //shpere\n    sppos=path(iTime*0.25+2.3)+vec3(0.,0.,-3.0);\n    vec3 wob=cos(iTime*10.+dir*200.*length(ro-sppos))*0.003;\n    float t=sphere(ro-sppos+wob,dir,spr);\n    float tg=sphere(ro-sppos+wob,dir,spr*1.5);\n    if(t>0.)\n    {\n        sp=1.;\n        ref=vec2(t,0.);\n        p+=dir*t;\n        n0=normalize(p-sppos);\n        dir=reflect(dir,n);\n    }\n    else if(tg>0.)\n    {\n        ref=vec2(tg,-0.);\n        p+=dir*tg;\n        n1=normalize(p-sppos);\n        glow+=pow(max(0.,dot(n1,-dir)),5.);\n    }\n    //RAYMARCH\n    float dist=0.;\n    for(int i=0;i<70;i++)\n    {\n        if(ref.x>det && dist<3.)\n        {\n            p=ro+dir*dist;\n            ref=map(p);\n            det=detail*(1.+dist*60.)*(1.+max(0.,sign(t))*5.);\n            dist+=ref.x;\n            if(ref.x<0.015) glow+=max(0.,0.015-ref.x)*exp(-dist);\n        }\n    }\n  \n    float l=1.;\n    l*=pow(max(0.,dot(normalize(-dir.xz),normalize(lightdir.xz))),2.);\n    l*=max(0.2,dot(-dir,lightdir));\n    vec3 bg=FOG_COLOR*(1.2-l)+LIGHT_COLOR*l*0.7;//FOG vs.LIGHT\n    bg*=AMBIENT_COLOR;\n    \n    //COLOR\n    if(ref.x<=det)\n    {\n        n=normal(p);\n        col=light(p,dir,n,ref.y)*exp(-0.2*dist*dist);//vec3(0.,0.2,0.8);\n        float f=1.-exp(-pow(dist,1.5));\n        col=mix(col,bg,f);\n    }\n    else\n    {\n        col=bg;\n    }\n    \n    vec3 lightglow=LIGHT_COLOR+pow(l,30.)*0.5;\n    col+=glow+(bg+lightglow)*1.3;\n    col+=lightglow*min(1.,dist*dist*0.3);\n    if(t>0.)//sphere\n    {\n        vec3 sphlight=light(p,rd,n0,2.);\n        col=mix(col,sphlight,0.3);\n        float f=1.-exp(-pow(t,1.5));\n        col=mix(col,bg,0.1);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    vec3 col;\n    vec2 uv2=uv;\n    //POSTPROCESS\n    #ifdef SCREEN_EDGE\n        uv*=1.+pow(length(uv2*uv2*uv2*uv2),4.)*0.07;\n    #endif\n    //////////////\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 cam=path(iTime*0.25)+vec3(0.,0.,-3.);\n    vec3 tar=path(iTime*0.25+0.7)+vec3(0.,0.,-3.);\n    vec3 ro=cam;\n    vec2 an;\n    vec3 dir=setcam(cam,tar,uv,an);\n    dir.xz*=rot(an.x);\n    dir.yz*=rot(an.y);\n    //MOUSE\n    vec2 mouse=vec2(0.);\n    if(iMouse.z>=1.)mouse=(iMouse.xy/iResolution.xy-0.5)*3.;\n    dir.xy*=rot(mouse.x);\n    dir.xz*=rot(mouse.y);\n    //////////////\n    \n    col=raymarch(ro,dir);\n    col=pow(col,vec3(GAMMA))*BRIGHTNESS;\n    col=mix(vec3(length(col)),col,SATURATION);\n    #ifdef POSTPROCESS\n        col*=1.-pow(length(uv2*uv2*uv2*uv2)*1.1,6.);\n        col.r*=(0.5+0.5*abs(0.5-mod(uv2.y,0.021)/0.021))*1.5;\n        col.g*=(0.5+0.5*abs(0.5-mod(uv2.y+0.007,0.021)/0.021))*1.5;\n        col.b*=(0.5+0.5*abs(0.5-mod(uv2.y+0.014,0.021)/0.021))*1.5; \n    #endif\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}