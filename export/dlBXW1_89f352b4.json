{"ver":"0.1","info":{"id":"dlBXW1","date":"1676190692","viewed":138,"name":"Recursive Raytracer, v2.3","username":"foodini","description":"I'm just iterating on a \"recursive\", \"object-oriented\" raytracer in a language that supports neither. There are several previous versions, but this is the first numbered version. The code is getting pretty spaghetti.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["perlin","raytrace","recursive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFINALLY RUNNING BELOW 60FPS on my desktop machine!  =]\n\n\nOkay, there's still a lot to do, but this gets the proof-of-concept out of the way.\n\nFirst, the checklist of what works;\n* \"Recursive\" ray tracing.\n* Reflection and refraction of nested objects. This only works if the interior\n  objects' indices of refraction are specified relative to their parent. A sphere\n  of ior 1.8 inside a 1.5 is specified with an ior of 1.8/1.5.\n* \"Barf-o-morphism\" I want to just keep a list of objects, each of which knows its\n  type. You just write the intersection function for an object type (and, \n  eventually, provide texturing info) and you don't have to think about anything else.\n* Fresnel reflection. Glass objects don't _just_ refract. Some of the light that\n  hits the glass surface is reflected. It's a complicated interaction that involves\n  the polarization of light and it's not worth getting into here. Frankly, I can't\n  even say I barely understand it. I'm operating on faith here.\n* Perlin noise. Only currently used for warping the mandelbrot texture. I may use it\n  to create some \"proper\" textures like wood, etc. Maybe\n* Visible light sources. It's fake, but it's not too bad. It depends upon the angle\n  between the cast ray and the direction to the center of the light source, which\n  means its size is constant in screenspace and gives it a very wonky behavior as\n  it passes in front of the camera. I don't know if I'll try to fix this.\n* Soft shadows. This is expensive as hell. It's easier to see with only one light\n  source or without the messed up mandelwarp. I may eliminate this to go to just one\n  light and try to do actual real-time caustics. That's probabaly the next project,\n  and I'll have to finish it before Kerbal Space Program 2 comes out.\n* Depth-of-field. Only those things at the camera's focal length are in sharp focus.\n\n\nGLSL has no recursion. \"Recursive\" ray-tracers generally work by replacing a ray,\nwhen it hits a refractive surface, with one ray that goes through the object surface\nand one that reflects off of it. These two rays are computed by a self call to a \ntrace() function... which you can't do in glsl.\n\nInstead, I just have a worklist of unprocessed rays. Each ray knows how much of the\nfinal color it contributes. For example, if a ray passes through a filter, the ray that\ncomes out the other side knows that whatever it hits in the end, only a fraction of\nthe surface's color will be used for the pixel color. Each time a ray hits a filter\nof any kind, new rays are generated with more and more attenuation.\n\nI have no idea how to explain this properly. It's too late at night for that. Hit me\nup in the comments and I'll try to make sense of it. In the meantime, enjoy the todo\nlist:\n\n\nTODO: \n* I want to get transmissive attenuation working. Glass isn't transparent. It\n  slightly impedes photons as they pass through. I want blue glass and red glass\n  and grey glass.\n* Caustics? This is not, by any measure, even remotely easy. As I write this comment,\n  the scene is entirely static, so I could accumulate a lightmap texture over hundreds\n  of frames and produce a good caustic. I'm wondering if I can do something in real\n  time with some dynamic geometry.\n  \n  It can't be entirely insane. The scene here is (at the time of writing) throwing\n  nine rays per pixel for antialiasing. I don't need more than 4 unless depth-of-field\n  is on. If the texture to which I render the caustic is about the same size as the\n  screen and I throw about 4-9 rays per lightmap pixel, my rendering time will roughly\n  double. (I may turn off Fresnel reflection for caustics.)\n* Frequency-based refraction? This would cost a fortune. A ray would have to encode\n  more than r,g,b, it would have to encode a gamut of frequencies in the visible spectrum.\n  Each refraction would generate one new rays FOR EACH FREQUENCY instead of just 1-2.\n* I want to be apply any texture to any object. This may not be possible in the long\n  run, but a sphere, a plane, and an isomorph should all be refractable, perlin-able,\n  etc.\n* Add perlin textures, bump mapping, normal mapping. \n* Video textures?\n* More interesting objects. Geometric, parametric, and...? Possibly terrain, though \n  that's a stretch. Isomorphs (blobs) definitely. Doing blobs means supporting just\n  about any raymarched geometry which provides a lot of options, but is insanely\n  expensive.\n* CONSTRUCTIVE SOLID GEOMETRY!\n* Subsurface scattering? Just shoot me.\n*/\n\nstruct Object {\n    int   type;\n    vec3  vec3_prop_0;\n    \n    float float_prop_0;\n    \n    int   texture_index;\n};\n\nstruct Texture {\n    int   texture_type;  // REFLECT, REFRACT, MAND, etc.\n    vec3  reflective_attenuation;    // reflective attenuation\n    float ior;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float size;\n};\n\nconst int max_objects = 10;\nint constructed_obj_count = 0;\nObject objects[max_objects];\n\nint constructed_shadow_count = 0;\nint shadowing_object_ids[max_objects];\n\nconst int max_textures = 10;\nint constructed_texture_count = 0;\nTexture textures[max_textures];\n\nconst int max_lights = 3;\nint constructed_light_count = 0;\nLight lights[max_lights];\n\n// For Spheres:\nconst int SPHERE_TYPE = 0;\n#define sphere_pos             vec3_prop_0\n#define sphere_radius          float_prop_0\n\n// For Planes:\nconst int PLANE_TYPE = 1;\n#define plane_normal           vec3_prop_0\n#define plane_displacement     float_prop_0\n\nconst int REFLECT  = 0;\nconst int REFRACT  = 1;\nconst int MAND     = 2;\nconst int GRID     = 3;\nconst int PERLIN   = 4;\nconst int MANDWARP = 5;\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nconst float PI = 3.1415926538;\nconst float EULER = 2.71828183;\nint rand_seed = 2987492621;\n// THIS SUCKS and is making antialiasing terrible.\nfloat rand(in vec2 co){\n    int chaos = int(co.x * 867530.9 * sin(PI + iTime) + co.y * 555236.8 * cos(EULER + iTime));\n    rand_seed += chaos;\n    rand_seed *= 1664525;\n    rand_seed += 1013904223;\n    return abs(float(rand_seed) / float(2147483647));\n}\n\nvec3 rand_normalized_vector() {\n    /*\n    You can generate normally-distributed numbers on the surface of the unit sphere with something like\n    the following. The math should be right, but I've not tried it. Note the cost. \n    */\n    float phi = 2.0 * PI * rand(vec2(EULER, PI));\n    float theta = acos(2.0 * rand(vec2(EULER, PI)) - 1.0);\n    float u = cos(phi);\n    float root = sqrt(1.0 - u*u);\n    float x = root * cos(theta);\n    float y = root * sin(theta);\n    float z = u;\n    \n    \n    return vec3(x, y, z);\n}\n\nfloat sphere_dist(in Object sphere, in Ray ray) {\n    vec3 OC = sphere.sphere_pos - ray.origin;\n    float len_OC_squared = dot(OC, OC);\n    float r_squared = sphere.sphere_radius*sphere.sphere_radius;\n    float Tca;\n    float Tca_squared;\n    float Thc_squared;\n    \n    Tca = dot(OC, ray.dir);\n\n    // Is the ray origin outside the sphere?\n    if(len_OC_squared >= r_squared) {\n        // Does the ray point away from the sphere?\n        if(Tca < 0.0) {\n            return -1.0;\n        } else {\n            Tca_squared = Tca * Tca;\n            Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        }\n        // Does the ray miss the sphere?\n        if(Thc_squared < 0.0)\n            return -1.0;\n        return Tca - sqrt(Thc_squared);\n    } else {\n        Tca_squared = Tca * Tca;\n        Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        return Tca + sqrt(Thc_squared);\n    }\n}\n\nfloat plane_dist(in Object plane, in Ray ray) {\n    float Vprd = dot(plane.plane_normal, ray.dir);\n    float Vpro = -(dot(plane.plane_normal, ray.origin) + plane.plane_displacement);\n    float t = Vpro / Vprd;\n    if(t>0.0)\n        return t;\n    return -1.0;\n}\n\nfloat dist_to_obj(Object obj, in Ray ray) {\n    if(obj.type == SPHERE_TYPE) {\n        return sphere_dist(obj, ray);\n    } \n    if(obj.type == PLANE_TYPE) {\n        return plane_dist(obj, ray);     \n    }\n}\n\nvec3 lighting(in vec3 diffuse_color, in vec3 intersect_point, in vec3 normal) {\n    vec3 lit = vec3(0.0);\n    float max_samples = 4.0;\n    for(int light_index = 0; light_index < constructed_light_count; light_index++) {\n        for(float sample_id = 0.0; sample_id < max_samples; sample_id += 1.0) {\n            bool obstructed = false;\n            vec3 point_on_light_sphere = lights[light_index].pos + rand_normalized_vector() * lights[light_index].size;\n            vec3 to_light = point_on_light_sphere - intersect_point;\n            float dist_to_light = length(to_light);\n            to_light /= dist_to_light;\n            Ray test_ray;\n            test_ray.origin = intersect_point + 0.001*normal;\n            test_ray.dir = to_light;\n            for(int shadow_index = 0; shadow_index < constructed_shadow_count; shadow_index++) {\n                float dist_to_object = dist_to_obj(objects[shadow_index], test_ray);\n                if(dist_to_object > 0.0 && dist_to_object < dist_to_light) {\n                    obstructed = true;\n                    break;\n                }\n            }\n            if(!obstructed) {\n                lit += diffuse_color * lights[light_index].color/max_samples * dot(normal, to_light);\n            }\n        }\n    }\n    return lit;\n}\n\n// TODO: add the actual intersect point (since p is essentially a uv) and the normal\nvec3 mand(in vec2 uv, in vec3 intersect_point, in vec3 normal) {\n    //return vec3(0.5);\n    //return grid(p);\n\n    //mandel (&intersect, raycolor, .003, 0.14707684544406, 0.651762543252595, \"blues.map\");\n    //void mandel (Point3 *p, col color, double scale, double ztrans, double xtrans, char *filename)\n    vec2 c = vec2(uv.x, uv.y) * 0.003;// * (0.0005 + pow(sin(iTime/15.0), 2.0));\n    c += vec2(0.1382309, 0.643002);\n    vec2 z = c;\n    vec2 zn;\n    \n    for(float i=0.; i<500.; i++) {\n        if(dot(zn,zn) >= 4.0) {\n            float d = i + 1. - log(log(length(zn)))/log(2.);\n            vec3 diffuse_color = vec3(\n                (1.0+sin((iTime*5. + d)/17.))/2.0,\n                (1.0+cos((iTime*7. + d)/13.))/2.0,\n                (1.0+sin((iTime*11. + d)/11.))/2.0\n                );\n            return lighting(diffuse_color, intersect_point, normal);\n        } else {\n            zn = mat2(zn,-zn.y,zn.x) * zn + c;\n    \t\tz = zn;\n        }\n    }\n    return vec3(0.0);\n}\n\nvec3 grid(in vec2 p) {\n    float sx = sin(p.x/PI);\n    float sy = sin(p.y/PI);\n    \n    sx *= sx * sx;\n    sx = pow(sx, 20.0);\n    sy *= sy * sy;\n    sy = pow(sy, 20.0);\n    \n    return vec3(max(sx, sy));\n}\n\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n/*\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n*/\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec3 perlin(in vec3 p) {\n    return vec3(cnoise(p+iTime), cnoise(p+200.0+iTime), cnoise(p+500.0+iTime));\n}\n\n\n//TODO: Get the 2d version of the perlin function....\nvec3 mandwarp(in vec3 p, in vec3 intersect_point, in vec3 normal) {\n    vec3 p1 = p + perlin(p) * 0.4;\n    return mand(p1.xz, intersect_point, normal);\n}\n\nstruct RayContext {\n    Ray ray;\n    vec3 contribution;\n};\nconst int max_contexts = 10;\nint num_contexts = 0;\nRayContext contexts[max_contexts];\n\nbool push(in Ray ray, in vec3 contribution) {\n    if(num_contexts == max_contexts)\n        return false;\n    \n    contexts[num_contexts].ray = ray;\n    contexts[num_contexts].contribution = contribution;\n    num_contexts++;\n    \n    return true;\n}\n\nbool pop(out Ray ray, out vec3 transmissive_attenuation, out vec3 contribution) {\n    if(num_contexts == 0)\n        return false;\n    \n    num_contexts--;\n    ray = contexts[num_contexts].ray;\n    contribution = contexts[num_contexts].contribution;\n    \n    return true;\n}\n\n// Returns a normal that points toward the ray source. Reflection, refraction, and lighting all\n// depend upon this assumption. Refraction requires that we know if we're entering or exiting\n// the object, so we return that information as well.\n// TODO: save the dot product by taking a bool that tells the function whether or not it's needed.\nvec3 get_normal(in Object object, in vec3 ray_dir, in vec3 intersect_point, out bool incident_upon_exterior) {\n    vec3 normal;\n    \n    if(object.type == SPHERE_TYPE) {\n        normal = normalize(intersect_point - object.sphere_pos);\n    } else {\n        normal = object.plane_normal;\n    }\n    incident_upon_exterior = (dot(ray_dir, normal) < 0.0);\n    if(!incident_upon_exterior)\n        normal = -normal;\n    \n    return normal;\n}\n\nfloat max_vec3(in vec3 i) {\n    return max(max(i.x, i.y), i.z);\n}\n\n// Fresnel is very costly to compute. I should just replace this with a cheap approximation.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel.html\nfloat fresnel_reflection_fraction(in vec3 ray_dir, in vec3 normal, in float ior) {\n    //return false;\n    \n    float cosi = dot(ray_dir, normal);\n    float etai;\n    float etat;\n    if (cosi < 0.0) {\n        etai = 1.0;\n        etat = ior;\n    } else {\n        etai = ior;\n        etai = 1.0;\n    }\n    \n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if(sint >= 1.0)\n        return 1.0;\n    \n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    \n    return (Rs * Rs + Rp * Rp) / 2.0;\n}\n\nvoid push_reflection_ray(Ray ray, vec3 normal, vec3 intersect_point, vec3 contribution) {\n    if(max_vec3(contribution) > 0.005) {\n        Ray new_ray;\n        new_ray.dir = reflect(ray.dir, normal); // _SHOULDN'T_ need normalizing.....\n        new_ray.origin = intersect_point + normal * 0.001;\n        push(new_ray, contribution);\n    }\n}\n\nvoid push_refraction_ray(\n        Ray ray, vec3 normal, vec3 intersect_point, vec3 contribution, float ior) {\n    float eta = 1.0/ior;\n    if(max_vec3(contribution) > 0.005) {\n        Ray new_ray;\n        new_ray.dir = refract(ray.dir, normal, eta); // _SHOULDN'T_ need normalizing.....\n        if(dot(new_ray.dir, new_ray.dir) == 0.0) {\n            // This is the \"total internal reflection\" case. glsl reflect() returns a zero vector for\n            // this situation, so we have to make it ourselves:\n            push_reflection_ray(ray, normal, intersect_point, contribution);\n        } else {\n            new_ray.origin = intersect_point - normal * 0.001;\n            push(new_ray, contribution);\n        }\n    }\n}\n\nvec3 process_texture(in Object nearest, in Ray ray, in float nearest_dist, vec3 current_contribution) {\n    vec3 intersect_point;\n    \n    Texture object_texture = textures[nearest.texture_index];\n    \n    if(nearest.type != -1) {\n        intersect_point = ray.origin + ray.dir * nearest_dist;\n    } else {\n        //nothing hit\n        float sky_blue = ray.dir.y;\n        float sky_rg = pow(sky_blue, 3.0);\n        return vec3(sky_rg, sky_rg, sky_blue);\n    }\n\n    bool incident_upon_exterior = true;\n    vec3 normal = get_normal(nearest, ray.dir, intersect_point, incident_upon_exterior);\n\n    if(object_texture.texture_type == MAND) {\n        return mand(intersect_point.xz, intersect_point, normal);\n    } else if(object_texture.texture_type == GRID) {\n        return grid(intersect_point.xz);\n    } else if(object_texture.texture_type == PERLIN) {\n        return perlin(intersect_point);\n    } else if(object_texture.texture_type == REFLECT) {\n        push_reflection_ray(\n            ray, normal, intersect_point, current_contribution * object_texture.reflective_attenuation);\n    } else if(object_texture.texture_type == MANDWARP) {\n        return mandwarp(intersect_point, intersect_point, normal);\n    } else if (object_texture.texture_type == REFRACT) {\n        float ior = object_texture.ior;\n        if(!incident_upon_exterior)\n            ior = 1.0/ior;\n        float reflection_fraction = fresnel_reflection_fraction(ray.dir, normal, ior);\n        //if(intersect_point.z > 0.0)\n        //    return vec3(reflection_fraction);\n        if(reflection_fraction > 0.002) {\n            vec3 reflection_contribution = \n                reflection_fraction * current_contribution * object_texture.reflective_attenuation;\n            push_reflection_ray(ray, normal, intersect_point, reflection_contribution);\n        } \n        // NOTE!!! We're currently not doing any transmissive attenuation, so you could infinitely\n        //         recurse here.\n        reflection_fraction = 0.0;\n        if(reflection_fraction < 0.998) {\n            vec3 refraction_contribution = (1.0 - reflection_fraction) * current_contribution;\n            push_refraction_ray(ray, normal, intersect_point, refraction_contribution, ior);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 trace() {\n    //TODO: track the index so you do less unnecessary copying?\n    Object nearest;\n    float nearest_dist = 1e10;\n    int nearest_index;\n    \n    bool traversed;\n    \n    Ray ray;\n    vec3 transmission;    \n    vec3 current_contribution = vec3(1.0);\n\n    vec3 accumulated_texture = vec3(0.0);\n    \n    int ray_count = 0;\n\n    while(pop(ray, transmission, current_contribution)) {\n        nearest.type = -1;\n        nearest_index = -1;\n        \n        for(int obj_index=0; obj_index<=constructed_obj_count; obj_index++) {\n            float dist = dist_to_obj(objects[obj_index], ray);\n            if(dist > 0.0) {\n                if(nearest.type == -1 || dist < nearest_dist) {\n                    nearest = objects[obj_index];\n                    nearest_dist = dist;\n                    nearest_index = obj_index;\n                }\n            }\n        }\n\n        accumulated_texture += current_contribution * process_texture(\n            nearest, ray, nearest_dist, current_contribution);\n        \n        // Do a distance check to the light and see if it's closer than the nearest hit object?\n        // I need some way to determine if the current ray is in free space before I accumulate\n        // the light color for visible lighting.\n        \n        for(int light=0; light<constructed_light_count; light++) {\n            vec3 to_light = lights[light].pos - ray.origin;\n            if(nearest_dist > 0.0 && dot(to_light, to_light) < nearest_dist * nearest_dist) {\n                float dot_prod = dot(to_light, ray.dir);\n                // I used to normalize to_light first, then do the dot_prod check for > 0.0, but that \n                // does a possibly unnecessary sqrt in computing the length for normalization. This avoids that:\n                if(dot_prod > 0.0) {\n                    float len = length(to_light);\n                    to_light /= len;\n                    accumulated_texture += lights[light].color * pow(dot_prod/len, 280.0) * current_contribution;\n                }\n            }\n        }\n        \n        \n        // REMEMBER that the max ray count is no the max recursion depth, but the max number of\n        // rays tested for a single pixel. Two nested spheres can requrie 50 or more at current\n        // limits.\n        if(++ray_count == 25)\n            return accumulated_texture;\n    }\n\n    return accumulated_texture;\n}\n\nvoid add_shadow(int object_id) {\n    if(constructed_shadow_count == max_objects)\n        return;\n        \n    shadowing_object_ids[constructed_shadow_count++] = object_id;\n}    \n\n// WARNING! The argument names here are being affected by the preprocessor, so you may\n//          get compile errors that reference \"float_prop_0\", etc.\nvoid add_sphere(in vec3 sphere_pos, in float sphere_radius, in int texture_index, bool casts_shadow) {\n    if(constructed_obj_count == max_objects)\n        return;\n        \n    if(casts_shadow)\n        add_shadow(constructed_obj_count);\n        \n    objects[constructed_obj_count].type = SPHERE_TYPE;\n    objects[constructed_obj_count].sphere_pos = sphere_pos;\n    objects[constructed_obj_count].sphere_radius = sphere_radius;\n    objects[constructed_obj_count].texture_index = texture_index;\n    constructed_obj_count++;\n}\n\n// WARNING! The argument names here are being affected by the preprocessor, so you may\n//          get compile errors that reference \"float_prop_0\", etc.\nvoid add_plane(in vec3 plane_normal, in float plane_displacement, in int texture_index, bool casts_shadow) {\n    if(constructed_obj_count == max_objects)\n        return;\n        \n    if(casts_shadow)\n        add_shadow(constructed_obj_count);\n\n    objects[constructed_obj_count].type = PLANE_TYPE;\n    objects[constructed_obj_count].plane_normal = plane_normal;\n    objects[constructed_obj_count].plane_displacement = plane_displacement;\n    objects[constructed_obj_count].texture_index = texture_index;\n    constructed_obj_count++;\n}\n\n// Make a set of texture functinos that don't take all args\nint add_texture(in int texture_type, in vec3 reflective_attenuation, in float ior) {\n    if(constructed_texture_count == max_textures)\n        return 0;\n\ntextures[constructed_texture_count].texture_type = texture_type;\n    textures[constructed_texture_count].reflective_attenuation = reflective_attenuation;\n    textures[constructed_texture_count].ior = ior;\n    return constructed_texture_count++;\n}\n\nvoid add_light(in vec3 pos, in vec3 color, in float size) {\n    if(constructed_light_count == max_lights)\n        return;\n    \n    lights[constructed_light_count].pos = pos;\n    lights[constructed_light_count].color = color;\n    lights[constructed_light_count].size = size;\n    \n    constructed_light_count++;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int large_sphere_tex_index = add_texture(REFRACT, vec3(0.7), 1.5);\n    int small_sparse_sphere_tex_index = add_texture(REFRACT, vec3(0.98), 0.8/1.5);\n    int small_dense_sphere_tex_index = add_texture(REFRACT, vec3(0.98), 1.5/1.8);\n    int mandelbrot_tex_index = add_texture(MAND, vec3(0.0), 0.0);\n    int mandelwarp_tex_index = add_texture(MANDWARP, vec3(0.0), 0.0);\n    int grid_tex_index = add_texture(GRID, vec3(0.0), 0.0);\n    int perlin_tex_index = add_texture(PERLIN, vec3(0.0), 0.0);\n\n    add_sphere(vec3( 0.0,  0.0,  0.0),  1.0,  large_sphere_tex_index, true);\n    \n    add_sphere(vec3(-0.51, 0.0,  0.0),  0.25, small_dense_sphere_tex_index, false);\n    add_sphere(vec3( 0.51, 0.0,  0.0),  0.25, small_dense_sphere_tex_index, false);\n    add_sphere(vec3( 0.0,  0.0,  0.51), 0.25, small_sparse_sphere_tex_index, false);\n    add_sphere(vec3( 0.0,  0.0, -0.51), 0.25, small_sparse_sphere_tex_index, false);\n    add_sphere(vec3( 0.0,  0.51, 0.0),  0.25, small_sparse_sphere_tex_index, false);\n    add_sphere(vec3( 0.0, -0.51, 0.0),  0.25, small_sparse_sphere_tex_index, false);\n    \n    add_sphere(vec3( 0.0,  0.0,  0.0),  0.25, small_sparse_sphere_tex_index, false);\n    \n    add_plane( vec3( 0.0,  1.0, 0.0), 1.2, mandelwarp_tex_index, false);\n    \n    add_light( vec3( 4.0,  2.0,  0.0), vec3(0.3, 0.1, 1.0), 1.0);\n    add_light( vec3( 0.0,  2.5,  4.0), vec3(1.0, 0.1, 0.3), 1.0);\n    //add_light( vec3(-3.0,  2.5, -2.0), vec3(0.3, 0.6, 0.1), 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screen_space = uv * 2.0 - 1.0;\n    screen_space.x *= (iResolution.x/iResolution.y);\n\n    float cos2 = cos(iTime/4.0);\n    \n    float dist_to_pix_plane = 6.0;\n    vec3 cam_position = vec3(dist_to_pix_plane * sin(iTime/2.0), 1.0, dist_to_pix_plane * cos(iTime/2.0));\n    //cam_position = vec3(-3.0, 3.0, -3.0);\n    \n    float pix_plane_height = 3.5;\n    vec3 cam_look_at = vec3( -1.2 * cos(iTime/2.0), 0.2, 1.2 * sin(iTime/2.0));\n    vec3 cam_look_dir = dist_to_pix_plane * normalize(cam_look_at - cam_position);\n    \n    vec3 right = cross(vec3(0.0, 1.0, 0.0), cam_look_dir);\n    right = (pix_plane_height / 2.0) * normalize(right);\n    vec3 up = cross(cam_look_dir, right);\n    up = (pix_plane_height / 2.0) * normalize(up);\n    \n    vec3 pixel_width = right/iResolution.x;\n    vec3 pixel_height = up/iResolution.y;\n    \n    // You can get away with an aa level of 4ish if you turn off depth-of-field. Once\n    // I have lighting working, the DOF effect won't be so impactful and can be turned\n    // down.\n    float antialias_level = 9.0;\n    float depth_of_field_intensity = 15.0;\n    \n    \n    vec3 out_color = vec3(0.0);\n    Ray ray;\n    for(float aa=0.0; aa<antialias_level; aa+=1.0) {\n        vec3 ray_screen_isect_point = cam_position + cam_look_dir + \n            (screen_space.x * right) + (screen_space.y * up);\n        \n        ray_screen_isect_point += pixel_width * (rand(uv*(aa+1.0) * 2.0 - 1.0));\n        ray_screen_isect_point += pixel_height * (rand(uv*(aa+1.5) * 2.0 - 1.0));\n\n        ray.origin = cam_position;\n        if(depth_of_field_intensity > 0.0) {\n            ray.origin += depth_of_field_intensity * pixel_width * (rand(uv*(aa+1.0) * 2.0 - 1.0));\n            ray.origin += depth_of_field_intensity * pixel_height * (rand(uv*(aa+1.0) * 2.0 - 1.0));                 \n        }\n\n        ray.dir = normalize(ray_screen_isect_point - ray.origin);\n\n        push(ray, vec3(1.0));\n        out_color += trace();\n    }\n    out_color /= float(antialias_level);\n\n\n    // do a bit of fake gamma correcting as we output:\n    fragColor = vec4(\n        pow(out_color.x, 0.7),\n        pow(out_color.y, 0.7),\n        pow(out_color.z, 0.7),\n        1.0);\n    \n}","name":"Image","description":"","type":"image"}]}