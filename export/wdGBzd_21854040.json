{"ver":"0.1","info":{"id":"wdGBzd","date":"1607718983","viewed":81,"name":"hoeled_rainbow","username":"hoeled","description":"The Book of Shaders exercise \"Try to make a rainbow\"","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Cloud(vec2 uv, float size, float aa, float time, float flip, float random) {\n    uv *= 1.2;\n    uv.y -= .34;\n    uv.x += 1.18;\n    if (flip > 0.) {\n        uv.x -= fract(iTime*.05*time)*2.9;\n    } else {\n        uv.x += fract(iTime*.05*time)*2.9;\n    }\n    \n    uv.y += cos(iTime*time)*.06+.1;\n    float cloud;\n    for(float i = .1; i<.9; i+=.1) {\n        float randomX = fract(548.546*i*random)*.48+sin(iTime)*.027;\n        float randomY = fract(124.786*i*.355)*.25+sin(iTime*.5)*.077;\n        float d = length(vec2(uv.x+randomX, uv.y+randomY));\n        cloud += smoothstep(size/4.+aa+randomX*.2, size/4.+randomX*.2, d)*2.;\n    }\n    return cloud;\n}\n\nvec3 Rainbow(vec2 uv, vec3 bg, float aa) {\n    float d = length(vec2(uv.x, uv.y+.5));\n\n    float red = smoothstep(.9+aa, .9, d);\n    red -= smoothstep(.85+aa, .85, d);\n    \n    float orange = smoothstep(.85+aa, .85, d);\n    orange -= smoothstep(.8+aa, .8, d);\n    \n    float yellow = smoothstep(.8+aa, .8, d);\n    yellow -= smoothstep(.75+aa, .75, d);\n    \n    float green = smoothstep(.75+aa, .75, d);\n    green -= smoothstep(.7+aa, .7, d);\n    \n    float turquoise = smoothstep(.7+aa, .7, d);\n    turquoise -= smoothstep(.65+aa, .65, d);\n    \n    float blue = smoothstep(.65+aa, .65, d);\n    blue -= smoothstep(.6+aa, .6, d);\n    \n    float purple = smoothstep(.6+aa, .6, d);\n    purple -= smoothstep(.55+aa, .55, d);\n    \n    vec3 rainbow;\n    rainbow = red * vec3(1., 0., 0.) - bg * red;\n    rainbow += orange * vec3(7., .6, 0.) - bg * orange;\n    rainbow += yellow * vec3(1., 1., 0.) - bg * yellow;\n    rainbow += green * vec3(0., 1., 0.) - bg * green;\n    rainbow += turquoise * vec3(0., .8, 1.) - bg * turquoise;\n    rainbow += blue * vec3(0., .27, 1.) - bg * blue;\n    //rainbow += purple * vec3(.6, .0, 1.) - bg * purple;\n    \n    return rainbow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float aa = 1.5 / iResolution.y;\n    \n    uv *= 1. - uv * sin(iTime*.3) *.05;\n    \n    float bmod = sin(iTime)*.3+.3;\n    vec3 bg = mix(vec3(0.5, 0.5, 1.), vec3(0.0, 0.0, .9-bmod), uv.y+.15);\n    vec3 col = bg;\n\n    col += Cloud(uv, .3, aa, .7, 1., .687);\n    \n    /*uv.y *= 1.5;\n    uv.x = -uv.x;\n    uv.x -= 2.4;\n    float cloudBack = Cloud(vec2(uv.x, uv.y-.1), .31, aa, 0.23, -1., .431);\n    uv.x = -uv.x;\n    uv.x -= 2.4;\n    uv.y /= 1.5;*/\n    \n    uv.x -= .6;\n    uv.y -= .07;\n    uv.y += sin(iTime*.5)*.02;\n    float ground1 = smoothstep(2.+aa, 2., length(vec2(uv.x+.3, uv.y+2.35)));\n    \n    uv.x += .6;\n    uv.y += .07;\n    \n    uv.y -= sin(iTime*.5)*.02;\n    uv.y -= cos(iTime*.3)*.02;\n    vec3 rainbow = Rainbow(uv, bg, aa);\n    col += rainbow;\n    \n    //float rainb = clamp(rainbow.r, .0, 1.) + clamp(rainbow.g, .0, 1.) + clamp(rainbow.b, .0, 1.);\n    //rainb *= 1000.;\n    //cloudBack = cloudBack - rainb;\n    //col += clamp(cloudBack, .0, .5);\n    \n    uv.y +=.0;\n    uv.y += cos(iTime*.3)*.02;\n    uv.y += cos(iTime*.3)*.02;\n    float ground2 = smoothstep(4.+aa, 4., length(vec2(uv.x, uv.y+4.35)));\n    \n    ground1 *= ground1 - ground2;\n    col = clamp(col, 0., 1.);\n    ground1 += rainbow.r + rainbow.g + rainbow.b * 20.;\n    ground1 *= 1.-step(-.2, uv.y);\n    \n    float g1 = clamp(ground1, 0., 1.);\n    col -= g1 * vec3(.35, .02, .85);\n    col *= clamp(vec3(1., 1., 1.) * (1.-ground2), 0., 1.);\n    col += clamp(vec3(1., 1., 1.) * ground2, 0., 1.)*vec3(.1, .55, .1);\n    \n    col.r += sin(iTime*.76)*.2;\n    col.b += sin(iTime*.14)*.1;\n    col.rg += .1;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}