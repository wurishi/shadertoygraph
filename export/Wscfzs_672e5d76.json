{"ver":"0.1","info":{"id":"Wscfzs","date":"1605744446","viewed":53,"name":"ps_MandelbrotSet","username":"p_schneider","description":"This shader targets to achieve a mathematical render of Mandelbrot's Set, one the best known and most\nused fractals in mathematics. It is defined by a mathematical function on the complex plane.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractals","mandelbrotset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis documentation refers to the GitHub Repo: https://github.com/pedrotrschneider/shader-fractals\n\n(PT - Br) Documentação em português começa na linha 8.\n(En) English documentation starts on line 30.\n\n(PT - Br)\nDocumentação em português:\nEste é um shader voltado para a renderização matemática do Conjunto de Mandelbrot, um dos fractais mais\nconhecidos e utilizados na matemática. Ele é definido por uma função matemática no conjunto dos números\ncomplexos.\n\nPara a construção desse shader foram utilizadas diversas fontes:\n- The Art of Code: https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n- The Coding Train: https://www.youtube.com/channel/UCvjgXvBlbQiydffZU7m1_aw\n- Sebastian Lague: https://www.youtube.com/user/Cercopithecan\n\nEste shader está sob a licença MIT.\nCheque \"License.txt\" para detalhes sobre a licensa.\n\nInstruções para compilar:\n- Entre no site https://www.shadertoy.com\n- No canto superior direito, clique em \"new\". Você será redirecionado para uma página com uma caixa\nde texto onde voce pode escrever e uma tela.\n- Apague todo o conteúdo da caixa de texto.\n- Copie este código e cole-o diretamente na ciaxa de texto.\n- Se nada mudar, aperte \"alt\" + \"enter\" e o shader deve compilar.\n\n(En)\nEnglish documentation:\nThis shader targets to achieve a mathematical render of Mandelbrot's Set, one the best known and most\nused fractals in mathematics. It is defined by a mathematical function on the complex plane.\n\nFor the creation of this shader, several resources were used:\n- The Art of Code: https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n- The Coding Train: https://www.youtube.com/channel/UCvjgXvBlbQiydffZU7m1_aw\n- Sebastian Lague: https://www.youtube.com/user/Cercopithecan\n\nThis shader in under the MIT license.\nRefer to \"LICENSE.txt\" for the details of the license.\n\nInstructions to compile:\n- Follow this url: https://www.shadertoy.com.\n- On the upper right portion of the screen, click on the \"new\" button. You will be redirected to a page\nwith a text box you can write on and a screen.\n- Delete all the text on the text box.\n- Copy this code and paste it on the text box.\n- If nothing happnes, press \"alt\" + \"enter\" and the shader should compile.\n\nInstructions to compile:\n- Follow this url: https://www.shadertoy.com.\n- On the upper right portion of the screen, click on the \"new\" button. You will be redirected to a page\nwith a text box you can write on and a screen.\n- Delete all the text on the text box.\n- Copy this code and paste it on the text box.\n- If nothing happnes, press \"alt\" + \"enter\" and the shader should compile.\n*/\n\n// Method for the mathematical constructoin of the mandelbrot set\nfloat mandelbrot (vec2 c, float RECURSION_LIMIT) {\n  float recursionCount = 0.0;\n\n  vec2 z = vec2 (0.0, 0.0);\n\n  for (float i = 0.0; i < RECURSION_LIMIT; i++) {\n    z = vec2 (z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n\n    if (length (z) > 2.0) {\n      break;\n    }\n\n    recursionCount++;\n  }\n\n  return recursionCount;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  const vec2[4] locations = vec2[] (\n    vec2 (0.281717921930775, 0.5771052841488505),\n    vec2 (-0.81153120295763, 0.20142958206181),\n    vec2 (0.452721018749286, 0.39649427698014),\n    vec2 (-0.745428, 0.113009) // <-- this is the one used in the demonstration. You can change the\n                               // index of the array on line XX to change the final location\n  );\n\n  vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / iResolution.y; // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv2 = uv; // Creates a copy of the uvs for coloring\n  vec2 mouse = iMouse.xy / iResolution.xy; // Gets the coordinates of the mouse to aply zoom\n\n  float time = 0.032 * float (iFrame);\n  // float time = iTime;\n  float zoom = pow (time, time / 10.0);\n  vec3 col = vec3 (1.0); // Color to be drawn on the screen\n\n  float RECURSION_LIMIT = 10000.0; // Maximum number of iterations to test\n\n  uv /= (zoom); // Scales the uv based of the zoom\n  vec2 c = uv; // Initializes c as the current pixel position\n  c += locations[3]; // Offsets the current pixel position to put the desired location in the middle\n\n  float recursionCount = mandelbrot (c, RECURSION_LIMIT); // Calculates the amount of iterations until the point went out of bounds\n\n  float f = recursionCount / RECURSION_LIMIT; // Puts the amount of iterations in range [0, 1]\n\n  // Coloring the fractal\n  if (f == 1.0) { // If it is in the mandelbrot set itself, colors black\n    col.r = 0.0;\n    col.b = 0.0;\n    col.g = 0.0;\n  }\n  else { // If its close to the mandelbrot set, colors based on how close it is to beeing on the mandelbrot\n    float offset = 0.5;\n    float ff = pow (f, 1.0 - (f * max (0.0, (50.0 - time))));\n    float smoothness = 1.0;\n    col.r = smoothstep (0.0, smoothness, ff) * (uv2.x * 0.5 + 0.5);\n    col.b = smoothstep (0.0, smoothness, ff) * (uv2.y * 0.5 + 0.5);\n    col.g = smoothstep (0.0, smoothness, ff) * (-uv2.x * 0.5 + 0.5);\n  }\n\n  fragColor = vec4 (col.rgb, 1.0); // Outputs the result color to the screen\n}","name":"Image","description":"","type":"image"}]}