{"ver":"0.1","info":{"id":"wlKyWt","date":"1612003962","viewed":124,"name":"Wave generator sphere","username":"ma38su","description":"a vibrating sphere on the surface of the water. I don't guarantee physical correctness.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["pathtracingraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\nconst float EPS = 0.001;\nconst float INF = 5.;\n\nconst vec3 top_color = vec3(.2, .6, 1.);\nconst vec3 horizon_color = vec3(.9);\n\nconst vec3 water_bottom_color = vec3(0., .2, .5);\nconst vec3 water_horizon_color = vec3(0., 0., 1.);\n\nvec3 sky_color(vec3 rd) {\n  float t = 0.5 * (rd.y + 1.0);\n  return t * top_color + (1.0 - t) * horizon_color;\n}\n\nvec3 water_color(vec3 rd) {\n  float t = 0.5 * (-rd.y + 1.0);\n  return t * water_bottom_color + (1.0 - t) * water_horizon_color;\n}\n\nvec4 plane = vec4(0.0, 1.0, 0.0, 2.0);\n\nfloat distPlane(vec3 p, vec4 n) {\n  return dot(p, n.xyz) * n.w;\n}\n\nfloat distSphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\nfloat distFunc(vec3 p) {\n  float r = .2;\n  float theta = iTime * PI * 6.0 / 3.;\n  vec3 c = vec3(0., r + (cos(theta + 0.1) - 0.5) * .01, 0.);\n\n  float d1 = distSphere(p, c, r);\n  float d2 = distPlane(p, plane);\n  float dist = length(p.xz);\n  d2 += sin(dist * PI * 10.0 - theta) * 0.003 / max(dist * dist * 3., 1.);// * max(1. / dist, 1.);\n  return min(d1, d2);\n  return d2;\n}\n\nconst vec3 dx = vec3(EPS, 0, 0);\nconst vec3 dy = vec3(0, EPS, 0);\nconst vec3 dz = vec3(0, 0, EPS);\n\nvec3 normal(in vec3 p) {\n  return normalize(vec3(\n  \tdistFunc(p + dx) - distFunc(p - dx),\n  \tdistFunc(p + dy) - distFunc(p - dy),\n  \tdistFunc(p + dz) - distFunc(p - dz)\n  ));\n}\n\nfloat schlick(const float cosine, const float ref_idx) {\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 r = iResolution.xy;\n  vec2 p = (fragCoord.xy * 2. - r) / min(r.x,r.y);\n  vec3 ta = vec3(p, 0.);\n  vec3 ro0 = vec3(0., 0.1, -1.);\n  vec3 rd = normalize(ta - ro0);\n  \n  float t = 0.;\n  vec3 albedo = vec3(1.);\n  vec3 sphere_color = vec3(0.99, 0.99, 0.);\n  float ray_rate = 1.;\n  vec3 col = vec3(0.);\n  for (int ns = 0; ns < 96; ++ns) {\n    vec3 ro = ro0 + rd * t;\n    float d = distFunc(ro);\n    if (length(ro) > INF) break;\n    if (d < EPS) {\n      vec3 nv = normal(ro);\n\n      vec3 reflected = reflect(rd, nv);\n      if (ro.y > 0.01) {\n        if (sphere_color.x > 1.0 || sphere_color.y > 1. || sphere_color.z > 1.0) {\n          col += ray_rate * albedo * sphere_color;\n          fragColor = vec4(sqrt(col), 1.);\n          return;\n        }\n        t = max(d, EPS * 1.5);\n        rd = reflected;\n        ro0 = ro;\n        albedo *= sphere_color;\n        continue;\n      }\n\n      float ref_idx = 1.3330; // water\n      float etai_over_etat = 1.0 / ref_idx; // front face\n      float cos_theta = min(dot(-rd, nv), 1.0);\n      float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n      if (etai_over_etat * sin_theta > 1.0) {\n        rd = reflected;\n      } else {\n        float rate = schlick(cos_theta, etai_over_etat);\n        col += ray_rate * (1. - rate) * water_color(refract(rd, nv, etai_over_etat));\n        ray_rate *= rate;\n        rd = reflected;\n      }\n      t = max(d, EPS * 1.5);\n      ro0 = ro;\n    }\n    t += d * .5;\n  }\n  \n  col += ray_rate * albedo * sky_color(rd);\n\n  fragColor = vec4(sqrt(col), 1.);\n}\n","name":"Image","description":"","type":"image"}]}