{"ver":"0.1","info":{"id":"NssGWl","date":"1616765923","viewed":161,"name":"Totalistic cellular automata OLD","username":"Envy24","description":"Totalistic cellular automata 8 or 9 neighbors (Moore's neighborhood)\n\nMore cellular automats: https://www.shadertoy.com/playlist/fXVSRy","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["maze","conway","gameoflife","cellularautomata","totalistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ALIVE (vec4(1.0f, 1.0f, 1.0f, 1.0f))\n#define DEAD  (vec4(0.0f, 0.0f, 0.0f, 1.0f))\n\n/* \n    PICK RULE [0; 1048575] and RESTART! \n    \n     Conway's rule decode example:\n     bit idx:  9  8  7  6  5  4  3  2  1  0\n       state:  0  0  0  0  0  0  1  0  0  0  // born if cell is dead and count == 3\n       \n     bit idx: 19 18 17 16 15 14 13 12 11 10\n       state:  0  0  0  0  0  0  1  1  0  0  // live if cell alive and count == 2 of count == 2\n    \n    For register with 20 bits max value equal pow(2, 20) - 1 or 1048575.\n */\n//int rule = 12296;    // Conway's Game Of Life\n//int rule = 31752;    // Maze\nint rule = 12744;    // Infinite Game Of Life\n//int rule = 12360;\n//int rule = 1027464;\n//int rule = 565656;\n//int rule = 253637;\n//int rule = 122435;\n//int rule = 122536;\n//         1048575\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\n/*\n    Returns number of alive neighbors.\n*/\nint count_neighbours(vec2 fragCoord)\n{\n    // if r == 0.0f then cell is dead, otherwise cell is alive.\n\n    float LEFT     = (fragCoord.x - 1.0f) / iResolution.x;\n    float CENTER_X = fragCoord.x          / iResolution.x; \n    float RIGHT    = (fragCoord.x + 1.0f) / iResolution.x;\n    float TOP      = (fragCoord.y - 1.0f) / iResolution.y;\n    float CENTER_Y = fragCoord.y          / iResolution.y; \n    float BOTTOM   = (fragCoord.y + 1.0f) / iResolution.y; \n\n    return \n        int(texture(iChannel0, vec2(LEFT,     TOP)).r > 0.0f) + \n        int(texture(iChannel0, vec2(CENTER_X, TOP)).r > 0.0f) +\n        int(texture(iChannel0, vec2(RIGHT,    TOP)).r > 0.0f) +\n        int(texture(iChannel0, vec2(LEFT,     CENTER_Y)).r > 0.0f) +\n        //int(texture(iChannel0, vec2(CENTER_X, CENTER_Y)).r > 0.0f) + // comment this line if you want to exclude center cell.\n        int(texture(iChannel0, vec2(RIGHT,    CENTER_Y)).r > 0.0f) +\n        int(texture(iChannel0, vec2(LEFT,     BOTTOM)).r > 0.0f) +\n        int(texture(iChannel0, vec2(CENTER_X, BOTTOM)).r > 0.0f) +\n        int(texture(iChannel0, vec2(RIGHT,    BOTTOM)).r > 0.0f);\n}\n\n/*\n    Returns 1 if cell should live, otherwise returns 0.\n*/\nint check_rule_totalistic(int rule, int count, int isAlive)\n{\n\tif (isAlive != 1)\n\t{\n\t\tint should_born = (rule >> count) & 1;\n\n\t\treturn should_born;\n\t}\n\telse\n\t{\n\t\tint should_live = (rule >> (count + 10)) & 1;\n\n\t\treturn should_live;\n\t}\n}\n\nvec4 randomizePartOfFrame(\n    in vec2 P,\n    float amount)  // in range [0.0; 1.0]\n{\n    float midX = iResolution.x * 0.5;\n    float midY = iResolution.y * 0.5;\n    float rx = midX * amount;\n    float ry = midY * amount;\n    \n    return \n       (P.x > (midX - rx) &&\n        P.x < (midX + rx) &&\n        P.y > (midY - ry) &&\n        P.y < (midY + ry)) == true ?\n            vec4(step(hash(P), 0.5)) :\n            DEAD;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if (iFrame == 0) \n    {\n        fragColor = randomizePartOfFrame(fragCoord, 0.8);\n    } \n    else\n    {\n        /* Rule code 2 */\n        int isAlive = int(texture(iChannel0, fragCoord / iResolution.xy).r > 0.0f);\n        int count = count_neighbours(fragCoord);\n\n        if (check_rule_totalistic(rule, count, isAlive) == 1) { fragColor = ALIVE; }\n        else { fragColor = DEAD; }\n        \n        return;\n        /* !Rule code 2 */\n        \n\n        /* Conway's Game Of Life. (For debug without rule code) *\n        bool isAlive = (texture(iChannel0, fragCoord / iResolution.xy).r > 0.0f);\n        \n        int count = count_neighbours(fragCoord);\n        \n        switch (count)\n        {\n            case 2:\n                if (isAlive == true) { fragColor = ALIVE; }\n                else { fragColor = DEAD; }\n                break;\n            case 3:\n                fragColor = ALIVE;\n                break;\n            default:\n                fragColor = DEAD; \n                break;\n        }\n        return;\n        /**/\n        \n        /* Maze. (For debug without rule code) *\n        bool isAlive = (texture(iChannel0, fragCoord / iResolution.xy).r > 0.0f);\n        \n        int count = count_neighbours(fragCoord);\n        \n        switch (count)\n        {\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                if (isAlive == true) { fragColor = ALIVE; }\n                else { fragColor = DEAD; }\n                break;\n            case 3:\n                fragColor = ALIVE;\n                break;\n            default:\n                fragColor = DEAD; \n                break;\n        }\n        return;\n        /* !Mazetrick */\n     }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample2DHashUI32(uint x, uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * entropy2 + x;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}","name":"Common","description":"","type":"common"}]}