{"ver":"0.1","info":{"id":"ctlGWl","date":"1672800660","viewed":150,"name":"REP2","username":"BrushC","description":"Raymarching Engine Practice 2\n\nCool moon render. Was initially supposed to be a volume rendering but I got lazy","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rand(vec2 x) {\n    vec2 n = fract(x * vec2(581.246, 369.169));\n    n += dot(n, n + 57.35);\n    n *= mod(n.yx, 5.236);\n    return fract(n);\n}\n\nvec3 planetPosition() {\n    vec3 spherePosition = vec3(0, 0, 200);\n    spherePosition = (vec4(spherePosition, 1.0) * mRotY(-iTime * 0.1)).xyz;\n    spherePosition.y = 30.0 + 30.0*sin(-iTime * 0.1);\n    \n    return spherePosition;\n}\n\nvec2 DE(vec3 p) {\n    // Moon\n    vec2 planeUV = p.xz;\n    \n    float t = iTime * 0.3;\n    planeUV.x = p.x * cos(t) - p.z * sin(t);\n    planeUV.y = p.z * cos(t) + p.x * sin(t);\n    \n    float bump = 0.0;\n    bump += smoothstep(0.5, 1.0, textureLod(iChannel0, 0.1 + planeUV * 0.01, 0.0).x) * 2.2;\n    bump += smoothstep(0.4, 1.0, textureLod(iChannel0, planeUV * 0.03, 0.0).x) * 0.7;\n    bump += smoothstep(0.1, 1.0, textureLod(iChannel0, planeUV * 0.1, 0.0).x) * 0.3;\n    \n    float curve = pow(length(planeUV), 2.0) / 32.0;\n    \n    float plane = dot(p, vec3(0.0, 1.0, 0.0)) + 3.0 + bump + curve;\n    \n    // Planet\n    vec3 spherePosition = planetPosition();\n    vec3 surfaceDirection = normalize(p - spherePosition);\n    vec2 sphereUV = directionToEquirectangular(surfaceDirection) + 1.0;\n    \n    float heightFalloff = (1.0 - abs(p.y - spherePosition.y) / 30.0);\n    float height = 30.0;\n    height += 6.0 * texture(iChannel0, sphereUV * 1.0).x * min(heightFalloff + 0.5, 1.0);\n    height += 1.0 * texture(iChannel0, sphereUV * 3.5).x;\n    height -= 0.2 * texture(iChannel1, sphereUV * 12.0).x;\n    \n    float sphere = length(p - spherePosition) - height;\n    \n    if (plane <= sphere) return vec2(plane, 0.0);\n    return vec2(sphere, 1.0);\n}\n\nRay raymarch(vec3 rO, vec3 rD) {\n    vec4 ray = vec4(rO, 0.0);\n    float nearest = MAX_DIST;\n    float steps = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 estimation = DE(ray.xyz);\n        float stepDistance = estimation.x;\n        stepDistance *= 0.8;\n        ray.xyz += rD * stepDistance;\n        ray.w += stepDistance;\n        \n        nearest = min(nearest, stepDistance);\n        \n        if (ray.w >= MAX_DIST || stepDistance <= MIN_DIST) {\n            break;\n        }\n        \n        steps = float(i) / float(MAX_STEPS);\n    }\n    \n    return Ray(ray.xyz, ray.w, nearest, steps, int(DE(ray.xyz).y));\n}\n\nvec3 normal(vec3 point) {\n    vec2 d = vec2(0.01, 0.0);\n    \n    vec3 normal = DE(point).x - vec3(\n        DE(point - d.xyy).x,\n        DE(point - d.yxy).x,\n        DE(point - d.yyx).x\n    );\n    return normalize(normal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Raymarching Setup\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 normalizedUV = uv * 2.0 - 1.0;\n    normalizedUV.x *= iResolution.x / iResolution.y;\n    \n    vec3 rO = vec3(0.0, 0.0, 0.0);\n    vec3 rD = vec3(normalizedUV, 1.0) - rO;\n    \n    vec2 mouseNormalized = (vec2(iMouse) / vec2(iResolution)) * 2.0 - 1.0;\n    mat4 cameraTransformation = mRotX(PI / 2.0 * mouseNormalized.y) * mRotY(-TAU * mouseNormalized.x);\n    \n    rD = (vec4(rD, 1.0) * cameraTransformation).xyz;\n    rD = normalize(rD);\n    \n    // Background\n    vec2 backgroundUV = directionToEquirectangular(rD);\n    vec3 backgroundColor = vec3(0.04);\n    \n    Ray sP = raymarch(rO, rD);\n    \n    vec3 fogColor = vec3(0.6, 0.3, 0.2);\n    \n    // No hit\n    if (sP.depth >= MAX_DIST) {\n        float nearest = sP.nearestDistance * 1.0;\n        float atmosphere = exp(-0.2 * nearest);\n        atmosphere = smoothstep(0.5, 1.0, atmosphere);\n        \n        backgroundUV.x *= 6.0;\n        backgroundUV.y *= 5.0;\n        \n        atmosphere -= 0.1 * texture(iChannel0, backgroundUV).x;\n        atmosphere = max(atmosphere, 0.0);\n        \n        // Stars\n        float map = texture(iChannel2, backgroundUV * 3.0).x;\n        map = smoothstep(0.25, 0.23, map);\n        \n        fragColor = vec4(mix(fogColor, backgroundColor, 1.0 - atmosphere * 0.5), 1.0);\n        // fragColor = vec4(vec3(map), 1.0);\n        \n        return;\n    }\n    \n    // Hit\n    vec3 normals = normal(sP.position);\n    \n    vec3 color = vec3(0);\n    \n    // Coloring objects\n    vec3 sunDirection = normalize(vec3(-1, 1, 0.5));\n    switch (sP.id) {\n        // Moon\n        case (0): {\n            color = vec3(0.87, 0.87, 0.98) * dot(normals, sunDirection);\n            \n            float fog = exp(-0.08 * sP.depth) * 1.3;\n            fog += sP.steps / 5.0;\n            fog = min(fog, 1.0);\n            \n            color = mix(color, fogColor, 1.0 - fog);\n        } break;\n        \n        // Planet\n        case (1): {\n            vec3 pos = planetPosition();\n            vec3 surfaceDirection = normalize(pos - sP.position);\n            vec2 planetUV = directionToEquirectangular(surfaceDirection);\n            planetUV *= 5.0;\n            \n            float height = (length(sP.position - pos) - 30.0);\n            float colormap = min(height / 4.0, 1.0);\n            float glow = smoothstep(0.5, 0.0, height / 6.0);\n            glow = pow(glow, 2.0) * 2.0;\n            \n            float fresnel = min(1.0, pow(1.0 + dot(rD, normals), 2.0));\n            \n            vec3 mappedColor = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), colormap);\n            color = mappedColor * dot(normals, sunDirection) + vec3(1.6, 0.8, 0.3) * glow;\n            color = mix(color, fogColor, fresnel);\n            // color = vec3(fresnel);\n        } break;\n    }\n    \n    \n\n    fragColor = vec4(color, 1.0);\n    // fragColor = vec4(vec3(sP.id), 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415\n#define TAU 6.2831\n\n#define MAX_STEPS 128\n#define MIN_DIST 1e-1\n#define MAX_DIST 3e2\n\nstruct Ray {\n    vec3 position;\n    float depth;\n    float nearestDistance;\n    float steps;\n    int id;\n};\n\n// Matrix functions\n\nmat4 mIdentity() {\n    return mat4(1, 0, 0, 0,  // Column 1, not row 1\n                0, 1, 0, 0,  // Column 2\n                0, 0, 1, 0,  // Column 3\n                0, 0, 0, 1); // Column 4\n}\n\nmat4 mTranslation(vec3 t) {\n    mat4 m = mIdentity();\n    m[0].w = t.x;\n    m[1].w = t.y;\n    m[2].w = t.z;\n    return m;\n}\n\nmat4 mRotX(float a) {\n    mat4 m = mIdentity();\n    m[1].y = cos(a);\n    m[1].z = sin(a);\n    m[2].y = -sin(a);\n    m[2].z = cos(a);\n    return m;\n}\n\nmat4 mRotY(float a) {\n    mat4 m = mIdentity();\n    m[0].x = cos(a);\n    m[0].z = -sin(a);\n    m[2].x = sin(a);\n    m[2].z = cos(a);\n    return m;\n}\n\nmat4 mRotZ(float a) {\n    mat4 m = mIdentity();\n    m[0].x = cos(a);\n    m[0].y = sin(a);\n    m[1].x = -sin(a);\n    m[1].y = cos(a);\n    return m;\n}\n\n\nvec2 directionToEquirectangular(vec3 direction) {\n    vec2 uv;\n\tuv.x = atan(direction.z, direction.x);\n\tuv.y = acos(direction.y);\n\tuv /= vec2(TAU, -PI);\n    return uv;\n}","name":"Common","description":"","type":"common"}]}