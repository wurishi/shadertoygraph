{"ver":"0.1","info":{"id":"MdSfDw","date":"1500645393","viewed":661,"name":"Hilbert curve branchless mix()","username":"ollj","description":"Hilbert curve,branchless via mix(step())\n\nturns out substituting by mix, making mix() explicit and rearranging it, reveals lots of symmetry of differentials.\nmostly around line; l-=fU.y*(l.yx+l);","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["fractal","branchless","hilbert","filling","zorder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ngeneral method, find and utilize symmetry via substitution.\nthe \"trickiest\" substitution is substituting branches in other's code,\n... where other people were sloppy, or ignorant of utilizing symmetry,\n... with somethng more symetrical like \nx=abs(x*a)*b-c;\nor\nx-=x*a-c;\nwhich is quite often reasonable, as below:\n*/\n\n/*\nHilbert curve,branchless via mix(step())\nbranchless performs better as subroutine (accumulating only the memory needed for itself).\nbranchless performs worse  as high-level routine with many subroutines (accumulating too much memory).\n\nbranchless performs better on newer GPU (larger  buffers, faster memory, more pipeline support)\nbranchless performs worse  on older GPU (smaller buffers, slower memory, less pipeline optimizations)\n\nbranchless has more constant troughput, less fluctuating fps. \n... (always stays at the lower fps, no shortcut branches)\n\nexplicit mix(f,t,r)\nvec2 mix2(vec2 f,vec2 t,float a){return f*(1.−r)+t*r;}\nvec2 mix2(vec2 f,vec2 t,float a){return f−f*r   +t*r;}\ni go as far as treating mix() more as fuzzy logic branchless|predicted branch,\nthat is identical to linear intrpolation,\nwhere f=false,t=true,r=relay|condition  (showing that putting TRUE left of FALSE is a bad habbit)\nwhich gets its waveform collapsed via r=step(r,0.);\n\nincluding \nhttps://www.shadertoy.com/view/XssfRf\nto make branchless hillbert curve render\nwe might find some mirror symmetry when expanding some of these mix(step()) functions:\nthe whole thing seems to have a lot of mirror symmetry, \nbegging to be resolved by \"abs()\" or \"-=\"\n\nthese branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\nbased on \n  https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\nthey substitute \n\n//(r> 0)?t:f\n#define greater(t,f,r)   mix(t,f,step(r,0.))\n//(r< 0)?t:f\n#define less(t,f,r)      mix(t,f,step(0.,r))\n//(r==0)?t:f\n*/\n#define equals(t,f,r)    mix(f,t,step(r,0.)+step(0.,r)-1.)\n/*\n//----------- mirror symmetry mirror == swap outputs--------------------\n//(r!=0)?t:f\n#define unequal(t,f,r)   mix(t,f,step(r,0.)+step(0.,r)-1.)\n//(r>=0)?t:f   \"unless   \"=not less   ==greater OR equal\n#define unless(t,f,r)    mix(f,t,step(0.,r))\n//(r<=0)?t:f   \"ungreater\"=not greater==less    OR equal\n#define ungreater(t,f,r) mix(f,t,step(r,0.))\n*/\n\n//#define rm(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n\n\n//...above gets Merged with hillbert curve's conditional folds of\n//https://www.shadertoy.com/view/XtjXW3\n//,hilbert curve 5, rounded\n\n//#define plot(U,l) greater(abs( dot(U , vec2(-l.y,l.x)) ), 0.,dot(U,l))\n#define plot(U,l) mix(abs(dot(U,vec2(-l.y,l.x))),0.,step(dot(U,l),0.))\n//above is branchless of below\n//#define plot(U,l) ( dot(U,l) > 0.  ? abs( dot(U , vec2(-l.y,l.x)) ) : 0. )\n#define plotC(U,l)  abs( length(U-(l)/2.) - .5 )\n\nvoid mainImage( out vec4 o,  vec2 U ){\n o=vec4(0);\n float s = 1.;  // mat2 R = mat2(0,-1,-1,0);\n U /= iResolution.y; U.x -= .3; U+=1e-5; // or bug at depth 2. why ?\n vec2 P = vec2(.5), I=vec2(1,0),J=vec2(0,1), fU, l=-I,r=l, k;\n for (float i=0.; i<7.; i++) {\n  if (i > mod(iTime,7.) ) break;\n  fU = step(.5,U);         // select child \n  U = 2.*U-fU;           // go to new local frame\n  l=mix(mix(J,l,fU.y),-mix(I,J,fU.y),fU.x);\n  //above is branchless of below:\n  //if(c.x){l=-mix(I,J,fU.y);}else{l=mix(J,l,fU.y);}\n  //l = c.x ? c.y ? -J : -I            // node left segment\n   //        : c.y ?  l :  J;\n        \n  r=equals(I,mix(J,-J,fU.y),fU.x-fU.y);\n  //above is branchless of below:\n  // if(c.x==c.y) r=I; else {r=mix(J,-J,fU.y); }\n  //r = (c.x==c.y)?  I : c.y ?-J:J;    // node right segment\n        \n  // the heart of Hilbert curve : \n  //U.x=mix(U.x,(1.-U.x),fU.x);\n  U.x+=2.*(fU.x*-U.x)+fU.x;//explicit mix(), rearranged  \n  //l.x=l.x*-fU.x+l.x-l.x*fU.x;//l.x=mix(l.x,  -l.x,fU.x);//explicit mix()\n  l.x+=2.*(l.x*-fU.x);//explicit mix(), rearranged\n  //r.x=r.x*-fU.x+r.x-r.x*fU.x;//r.x=mix(r.x,  -r.x,fU.x);//explicit mix()\n  r.x+=2.*(r.x*-fU.x);//explicit mix(), rearranged\n  //tipple swap of 2*vec2: l,r:\n  k=mix(k,l,fU.x);//k is just a buffer for this tripple swap\n  l=mix(l,r,fU.x);\n  r=mix(r,k,fU.x);//silly way to make a tripple swap of 2*vec2 branchless.\n  //above mix() is branchless of below:\n  //if (c.x) { U.x = 1.-U.x; l.x=-l.x;r.x=-r.x;  // sym\n  //            k=l;l=r;r=k;                    }// sym.trippleSwap\n     \n  //above is .x symmetry, mostly mirroing on y=0.\n  //below is .y symmetry, mostly quater rotations of the upper quadrants.\n    \n  //U=U-U*fU.y+(1.-U.yx)*fU.y;//U=mix(U,(1.-U.yx),fU.y);//explicit mix()\n  U-=fU.y*(U+U.yx-1.);//explicit mix(), rearranged\n  //l=l-l.yx*fU.y-l*fU.y;//l=mix(l,-l.yx,fU.y);//explicit mix()\n  l-=fU.y*(l.yx+l);//explicit mix(), rearranged\n  //r=r-r.yx*fU.y-r*fU.y;//r=mix(r,-r.yx,fU.y);//explicit mix()\n  r-=fU.y*(r.yx+r);//explicit mix(), rearranged     \n  //above mix()(explicit and rearranged) are branchless of below:\n  //if (c.y) { U   = 1.-U.yx; l  =-l.yx; r  =-r.yx; }  // .5+(U-.5)*R   // rot+sym\n  s++;\n }\n P=U-P;\n o+=mix(plotC (P,l+r),plot(P,l)+plot(P,r),step(length(l+r),0.));\n //above mix() is branchless of below:\n //o += length(l+r) > 0. ?   plotC (U-P, l+r) :  plot (U-P, l) + plot (U-P, r);\n    \n o=smoothstep(.33+.01*s,.33-.01*s,o);\n fU=min(U,1.-U);//clamp or color\n \n o*=mix(vec4(0),vec4(.3,1,.1,1),step(0.,min(fU.x,fU.y)));//framing\n //above mix() is branchless of below:\n //o*=min(fU.x,fU.y)<0. ? o-o : vec4(.3,1,.1,1);\n}\n\n/*\n//previous (branching) Hilbert_curve version as backup\n//https://www.shadertoy.com/view/XljSW3\n//,hilbert curve 4 (compact)\n\n#define plot(U,l) ( dot(U,l) > 0. ?  .7*s/H / abs( dot( U, vec2(-l.y,l.x) )) : 0. )\n\nvoid mainImage( out vec4 o,  vec2 U ){\n    o = vec4(0.0);\n    float H = iResolution.y, s=1.; // mat2 R = mat2(0,-1,-1,0);\n    U /= H; U.x -= .3;\n    vec2 P = vec2(.5), I=vec2(1,0),J=vec2(0,1), fU, l=-I,r=l, k;\n    for (float i=0.; i<10.; i++) {\n        if (i > mod(iTime,7.) ) break;\n       //fU = min(U,1.-U); if (min(fU.x,fU.y) < 4./H) { o.r++; break; } // cell border\n\n        fU = step(.5,U);         // select child\n        bvec2 c = bvec2(fU);     \n        U = 2.*U - fU;           // go to new local frame\n        l = c.x ? c.y ? -J : -I            // node left segment\n                : c.y ?  l :  J;\n        r = (c.x==c.y)?  I : c.y ?-J:J;    // node right segment\n        // the heart of Hilbert curve : \n        if (c.x) { U.x = 1.-U.x;  l.x=-l.x;  r.x=-r.x;  k=l;l=r;r=k; }      // sym\n        if (c.y) { U   = 1.-U.yx; l  =-l.yx; r  =-r.yx; }  // .5+(U-.5)*R   // rot+sym\n        s *= 2.;\n    }\n\n\to +=  plot (U-P, l) + plot (U-P, r); //* vec4(fU,1.-fU);\n\n    \n    fU = min(U,1.-U);            // clamp or color\n    o *= min(fU.x,fU.y)<0. ? o-o : vec4(.3,1,.1,1);\n}\n\n*/","name":"Image","description":"","type":"image"}]}