{"ver":"0.1","info":{"id":"wdVfzy","date":"1607449405","viewed":182,"name":"Simple Scene Editor v2.0","username":"me_123","description":"to toggle edit/view mode you can press the first button(on the lower left corner). the panel with the RGB sliders are to change the color of the object selected. the last panel is for changing the samples. the shader used raytracing and raymarching. enjoy","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","pathtracing","statefull"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ray marching for selection\nfloat md = 100.;\nfloat eps = 0.01;\nint max_steps = 100;\nfloat boundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat SDF(in vec3 p, sphere[objectCount] s) {\n\tint act = int(load(ACTIVE).x);\n    p -= s[act].center;\n\treturn boundingBox(p, vec3(0.5), 0.01);\n}\nfloat rayMarch(in ray r, sphere[objectCount] s) {\n\tfloat d0 = 0.;\n    vec3 p = vec3(0);\n    for (int i = 0; i < max_steps; i += 1) {\n    \tp = r.origin + r.dir * d0;\n        float d = SDF(p, s);\n        d0 += d;\n        if (d < eps || d > md) {\n        \tbreak;\n        }\n    }\n    return d0;\n}\nvoid getScene(out sphere[objectCount] s) {\n    for (int i = 0; i < sc; i += 1) {\n    \t//position, center\n        vec4 data = load(vec2(SCENE)+vec2(i, 0));\n        //matereal, color\n        vec4 data1 = load(vec2(SCENE)+vec2(i, 1));\n        s[i] = sphere(data.w, data.xyz, mater(data1.xyz, int(data1.w), 0.1));\n    }\n}\nvec3 drawImage(in vec2 fragCoord )\n{\n\n    mouse = (iMouse.xy/iResolution.xy)-0.5;\n    sphere[objectCount] s;\n    float r = iResolution.x/iResolution.y;\n    mouse *= (r)*2.;\n    mouse.y = max(mouse.y, -0.1);\n    if (fragCoord.y < 100.) {\n\t    if (fragCoord.x < 100.) {\n    \tvec3 color = vec3(0.2, 1., 0.6);\n        vec2 p = (fragCoord.xy/100.);\n       \tbool hitArrow = (box(p-0.5, vec2(0.06, 0.4)) < 0.0) || (box(p-0.5, vec2(0.4, 0.06)) < 0.0) ||\n        \t\t\t\t(eq((p*5.)-vec2(2.5, 4.)) < 0.0) || \n        \t\t\t\t(eq(((p*5.)-vec2(2.5, 1.))*rot(3.1415)) < 0.0) || \n        \t\t\t\t(eq(((p*5.)-vec2(1.0, 2.5))*rot(4.712)) < 0.0) ||\n        \t\t\t\t(eq(((p*5.)-vec2(4.0, 2.5))*rot(1.57)) < 0.0);\n        if (hitArrow) {\n        \tif (int(load(TOGGLE).x) == 1) {\n\t        \tcolor = vec3(0.2);\n            } else {\n            \tcolor = vec3(1.0, 0.6, 0.2);\n            }\n        }\n    \treturn color;\n    }\n\t    if (fragCoord.x > 100. && fragCoord.x < 200.) {\n   \t\tvec3 col = load(COLOR).xyz;\n        vec2 p = ((fragCoord.xy-vec2(100, 0))/100.);\n    \tbool b = (box(p-vec2(0.1, 0.5), vec2(0.06, 0.4)) < 0.0) || \n            \t (box(p-vec2(0.5, 0.5), vec2(0.06, 0.4)) < 0.0) ||\n            \t (box(p-vec2(0.9, 0.5), vec2(0.06, 0.4)) < 0.0)\n       \t;\n        bool lr = length(p-vec2(0.1, col.x*0.9))-0.065 < 0.0;\n        bool lg = length(p-vec2(0.5, col.y*0.9))-0.065 < 0.0;\n        bool lb = length(p-vec2(0.9, col.z*0.9))-0.065 < 0.0;\n        vec3 c = vec3(col.xyz)-vec3(0.3, 0.2, 0.0);\n        if (b) {\n        \tc = vec3(0);\n        }\n        if (lr) {c = vec3(1, 0, 0);}\n        if (lg) {c = vec3(0, 1, 0);}\n        if (lb) {c = vec3(0, 0, 1);}\n    \treturn c;\n    }\n\t    if (fragCoord.x > 200. && fragCoord.x < 300.) {\n   \t\tvec3 col = vec3(1);\n        vec2 p = ((fragCoord.xy-vec2(200, 0))/100.);\n    \tbool b = (box(p-vec2(0.5, 0.5), vec2(0.06, 0.4)) < 0.0);\n        int s = max(min(int(load(SAMPLES).x*10.), 100), 10);\n        bool sa = length(p-vec2(0.5, float(s)/100.))-0.065 < 0.0;\n        vec3 c = vec3(1.0, 0.4, 0.4);\n        if (b) {\n        \tc = vec3(0);\n        }\n        if (sa) {c = vec3(1);}\n    \treturn c;\n    }\n    }\n    vec3 c = vec3(0);\n    vec2 uv;\n    int samples = max(int(load(SAMPLES).x), 1);\n    for (int i = 0; i < samples; i += 1) {\n        uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n        uv += (vec2(hash(uv+float(i)), hash(uv+float(i)+float(samples+1)))-0.5)/(iResolution.xy/2.);\n        vec3 ro = load(RO).xyz;//vec3(sin(mouse.x*5.)*camSize, mouse.y*camSize, cos(mouse.x*5.)*camSize);\n        vec3 rd = getRD(ro, uv);\n        getScene(s);\n        float rm = rayMarch(ray(ro, rd), s);\n        float depth;\n        c += color(ro, rd, uv+(float(i)/1000.), int(load(ACTIVE).x), s, depth);\n        if (depth == 0.) {\n        \tdepth += md;\n        }\n        if ((rm < depth)) {\n        \tc += 1.0;\n        }\n        //c = vec3(depth/10.);\n    }\n   \treturn vec3(c/float(samples));\n}\nvec2 chunkPos = vec2(0);\nfloat chunkSize = 200.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(drawImage(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nvoid getScene(out sphere[objectCount] s) {\n    for (int i = 0; i < sc; i += 1) {\n        //position, center\n        vec4 data = load(vec2(SCENE)+vec2(i, 0));\n        //matereal, color\n        vec4 data1 = load(vec2(SCENE)+vec2(i, 1));\n        s[i] = sphere(data.w, data.xyz, mater(data1.xyz, int(data1.w), 0.1));\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = load(fragCoord);\n    if (iFrame == 0) {\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        sphere[objectCount] s;\n        makeScene(s);\n        store(TOGGLE, vec4(0));\n        for (int i = 0; i < sc; i += 1) {\n            //position and radius\n            store(SCENE+ivec2(i, 0), vec4(s[i].center, s[i].radius));\n            //color  and matereal\n            store(SCENE+ivec2(i, 1), vec4(s[i].mat.color, s[i].mat.mat));\n        }\n        store(RO, vec4(vec3(0), 1.));\n        store(SAMPLES, vec4(1));\n        store(ACTIVE, vec4(10));\n        return;\n    }\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    vec4 colr        = load(COLOR);\n    vec3 ro          = load(RO).xyz;\n    int activ        = int(load(ACTIVE).x);\n    int toggle       = int(load(TOGGLE).x);\n    vec2 m = (iMouse.xy/iResolution.xy)-0.5;\n    m.x *= iResolution.x/iResolution.y;\n    vec3 rd = getRD(ro, m);\n    ray r = ray(ro, rd);\n    rec h;\n    sphere[objectCount] s;\n    getScene(s);\n    if (iMouse.x < 300. && iMouse.y < 100.) {\n        if (iMouse.x < 100. && iMouse.y < 100.) {\n            if (!(iMouse.z < 1. || iMouse.w < 1.)) {\n                int t = 0;\n                if (toggle == 0) {\n                    t = 1;//store(TOGGLE, vec4(1));\n                } else {\n                    t = 0;//store(TOGGLE, vec4(0));\n                }\n                store(TOGGLE, vec4(t));\n            }\n        }\n        if (iMouse.x < 200. && iMouse.x > 100.) {\n            vec3 nc = colr.xyz;\n            if (iMouse.x < 133. && iMouse.x > 100.) {nc.x = iMouse.y/100.;}\n            if (iMouse.x < 166. && iMouse.x > 133.) {nc.y = iMouse.y/100.;}\n            if (iMouse.x < 199. && iMouse.x > 166.) {nc.z = iMouse.y/100.;}\n            store(SCENE+ivec2(activ, 1), vec4(nc, load(SCENE+ivec2(activ, 1)).w));\n            store(COLOR, vec4(nc, colr.w));\n        }\n        if (iMouse.x < 300. && iMouse.x > 200.) {\n            store(SAMPLES, vec4(iMouse.y/10.));\n        }\n    } else {\n        bool hit = hitScene(r, 0.0001, 100., h, 0, s);\n        if (hit && (toggle == 0) ) {\n        } else {\n            rec h1;\n            bool plane = hitSphere((rd*1000.)+(h.p-(h.normal/2.)), 1000., r, 0.0001, 1000., h1, h1.mat, 0, 0);\n            if (iMouse.z > 0.0 && h.id != 7) {\n                store(SCENE+ivec2(h.id, 0), vec4(h1.p.xyz, 0.5));\n            }\n        }\n        if (toggle == 0) {\n            if (iMouse.z > 0.0) {\n                store(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n            }\n            else if (vm.z != 0.0) {\n                store(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n            }\n            ro = vec3(-sin(load(VMOUSE).x/50.)*5., load(VMOUSE).y/10., -cos(load(VMOUSE).x/50.)*5.);\n        } else {\n            store(COLOR, vec4(h.mat.color.xyz, 0));\n            store(ACTIVE, vec4(vec3(h.id), 0));\n        }\n    }\n    store(RO, vec4(ro, 1.));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\nconst ivec2 SCALE = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(2, 0);\nconst ivec2 PMOUSE = ivec2(3, 0);\nconst ivec2 ACTIVE = ivec2(4, 0);\nconst ivec2 RO = ivec2(5, 0);\nconst ivec2 RD = ivec2(6, 0);\nconst ivec2 EB = ivec2(7, 0);\nconst ivec2 TOGGLE = ivec2(8, 0);\nconst ivec2 MOUSEMOVE = ivec2(9, 0);\nconst ivec2 COLOR = ivec2(10, 0);\nconst ivec2 SAMPLES = ivec2(11, 0);\nconst ivec2 SCENE = ivec2(1, 1);\nconst int objectCount = 8;\nvec2 mouse = vec2(0);\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\nstruct ray {\n\tvec3 origin;\n    vec3 dir;\n};\nmat2 rot(float d) {\n\treturn mat2(cos(d), -sin(d), sin(d), cos(d));\n}\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat eq( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nstruct mater {\n\tvec3 color;\n    int mat;\n    float ev;\n};\nstruct rec {\n    float t;\n    vec3  p;\n    vec3  normal;\n    mater mat;\n    int id;\n};\n\nstruct sphere {\n\tfloat radius;\n    vec3 center;\n    mater mat;\n};\nfloat hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+10.), 0.33333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return vec3(x, y, z);\n}\nint sc = 8;\nvoid makeScene(out sphere[objectCount] m) {\n    m[0] = sphere(0.5, vec3(0, 0., 0), mater(vec3(0.8, 0.3, 0.3), 0, 0.));\n\tm[1] = sphere(0.5, vec3(1, 0., 0), mater(vec3(0.8, 0.8, 0), 0, 0.));\n\tm[2] = sphere(0.5, vec3(-1., 0., 0), mater(vec3(0.8, 0.6, 0.2), 0, 0.));\n\tm[3] = sphere(0.5, vec3(-1., 1., 0), mater(vec3(0.4), 0, 0.));\n\tm[4] = sphere(0.5, vec3(1., 1., 0), mater(vec3(0.9), 0, 0.));\n\tm[5] = sphere(0.5, vec3(0., 1., 0), mater(vec3(0.7), 0, 0.));\n\tm[objectCount-1] = sphere(1000.0, vec3(0, -1000.5, -1), mater(vec3(0.8, 0.8, 0.8), 0, 0.2));\n}\nvoid diffused(out ray r, vec2 seed, rec hit, inout vec3 c) {\n    vec3 target = hit.p + hit.normal + rus(seed);\n    r.origin = hit.p;\n    r.dir = target - hit.p;\n    c *= hit.mat.color;\n}\nvoid gloss(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    r.origin = hit.p;\n    r.dir = (reflect(r.dir, hit.normal)+(rus(seed)*hit.mat.ev))/hit.mat.ev;\n    c *= hit.mat.color;\n}\nvoid emit(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    c = hit.mat.color*10.;\n}\nbool hitSphere(vec3 center, float radius, ray r, float t_min, float t_max, out rec re, mater mat, int i, int act) {\n    vec3 oc = r.origin-center;\n    float a = dot(r.dir, r.dir);\n    float b = dot(oc, r.dir);\n    float c = dot(oc, oc) - radius*radius;\n    float disc = b*b - a*c;\n    if (disc > 0.) {\n        float temp = (-b - sqrt(b*b-a*c)) / a;\n        if (temp < t_max && temp > t_min) {\n            vec3 p = r.origin+r.dir*temp;\n            re.t = temp;\n            re.p = p;\n            re.normal = (p - center) / radius;\n            if (act == i) {\n                mat.color;\n            }\n            re.mat = mat;\n            re.id=i;\n        \treturn true;\n        }\n        temp = (-b + sqrt(b*b-a*c)) / a;\n        if (temp < t_max && temp > t_min) {\n            vec3 p = r.origin+r.dir*temp;\n            re.t = temp;\n            re.p = p;\n            re.normal = (p - center) / radius;\n            re.mat = mat;\n            re.id=i;\n        \treturn true;\n        }\n    }\n    return false;\n}\nbool hitScene(ray r, float tmin, float tmax, out rec hit, int act, sphere[objectCount] sce) {\n\tbool hitIt = false;\n    float closest = tmax;\n    for (int i = 0; i < sc; i += 1) {\n        if (hitSphere(sce[i].center, sce[i].radius, r, tmin, closest, hit, sce[i].mat, i, act)) {\n        \thitIt = true;\n            closest = hit.t;\n        };\n    }\n    return hitIt;\n}\n\nvec3 color(vec3 ro, vec3 rd, vec2 seed, int act, sphere[objectCount] sce, out float d) {\n    vec3 c = vec3(1.0);\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float depth = 0.;\n    for (int i = 0; i < 10; i += 1) {\n        rec hit;\n        ray r = ray(roo, rdd);\n        if (hitScene(r, 0.001, 200.0, hit, act, sce)) {\n            ray rrr = r;\n            if (hit.mat.mat == 0) {diffused(rrr, seed, hit, c);}\n            if (hit.mat.mat == 1) {gloss(rrr, seed, hit, c);}\n            if (hit.mat.mat == 2) {emit(rrr, seed, hit, c);}\n            roo = rrr.origin;\n            rdd = rrr.dir;\n        } else {\n            vec3 dir = normalize(rdd);\n            float t = 0.5*(dir.y+1.);\n            c *= ((1.-t)*vec3(1)+t*vec3(0.5, 0.7, 1.0))/1.;\n            break;\n        }\n        if (i == 0) {\n        \tdepth = hit.t;\n        }\n        \n\t}\n    d = depth;\n    return c;\n}\nvec3 getRD(vec3 ro, vec2 uv) {\n    vec3 at = vec3(0, 0., 0.0);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n    return rd;\n}\n","name":"Common","description":"","type":"common"}]}