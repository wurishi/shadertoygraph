{"ver":"0.1","info":{"id":"mtlfD8","date":"1692889358","viewed":156,"name":"Psychedelic Fluid Filter","username":"ascomycody","description":"Pretty cool I guess. Works on webcam","likes":0,"published":3,"flags":48,"usePreview":0,"tags":["fluid","psychedelic","diffusion","feedback"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----- A Dynamic Fluid-Like Filter\n// inspired and made possible by this shader: Viscous Fingering by cornusammonis (https://www.shadertoy.com/view/Xst3Dj)\n// I used the Viscous Fingering effect with a DoG edge detector to provide input to the recursive loop\n\n// control the strength of the effect with EFFECT_AMP\n#define EFFECT_AMP 4.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 buffa = texture(ic0, uv).rgb;\n    vec3 buffc = texture(ic1, uv).rgb;\n    vec3 wc = texture(ic2, uv).rgb;\n    vec3 wc2 = texture(ic2, uv).rgb*.9;\n    \n    vec3 offset = buffc * EFFECT_AMP  + (vec3(1.) - buffa);\n    vec3 col = (offset * wc) + (wc2 * (vec3(1.) - offset));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897\n#define E 2.71828\n#define RHO 1.5\n\n#define ic0 iChannel0\n#define ic1 iChannel1\n#define ic2 iChannel2\n#define ic3 iChannel3\n\n#define sampleDist 1.\n#define dx sampleDist / iResolution.x\n#define dy sampleDist / iResolution.y\n\n\n#define TAU .1\n#define COLOR_STEPS 2.\n\n#define COLOR_STEPS_R 1. / COLOR_STEPS\n\n\nstruct mat8 {mat4 a; mat4 b; mat4 c; mat4 d;};\n\nstruct mat8rgb {mat8 r; mat8 g; mat8 b;};\n\nmat8 initMat8GK(in float sd, in int size){\n  \n    mat8 m = mat8(mat4(0.,0.,0.,0.,\n                       0.,0.,0.,0.,\n                       0.,0.,0.,0.,\n                       0.,0.,0.,0.),\n                  mat4(0.,0.,0.,0.,\n                       0.,0.,0.,0.,\n                       0.,0.,0.,0.,\n                       0.,0.,0.,0.),\n                  mat4(0.,0.,0.,0.,\n                       0.,0.,0.,0.,\n                       0.,0.,0.,0.,\n                       0.,0.,0.,0.),\n                  mat4(0.,0.,0.,0.,\n                       0.,0.,0.,0.,\n                       0.,0.,0.,0.,\n                       0.,0.,0.,0.));\n    float sum = 0.;\n    \n    int halfSize = int(floor(float(size) * .5));\n    float sd2 = 2. * (sd * sd);\n    float coeff = 1. / (PI * sd2);\n    \n    for(int i = 0; i < size; i++){\n    for(int j = 0; j < size; j++){\n    \n        int x = i - halfSize;\n        int y = j - halfSize;\n        \n        float numr = float((x * x) + (y * y));\n        float expo = numr / sd2;\n        float val = coeff * pow(E, -expo);\n        \n        m.a[i][j] = (i<4&&j<4) ? val : m.a[i][j];\n        m.b[x][j] = (i>3&&j<4) ? val : m.b[x][j];\n        m.c[i][y] = (i<4&&j>3) ? val : m.c[i][y];\n        m.d[x][y] = (i>3&&j>3) ? val : m.d[x][y];\n        \n        sum += val;\n        \n    }\n    }\n    float rsum = 1. / sum;\n    \n    m.a *= rsum;\n    m.b *= rsum;\n    m.c *= rsum;\n    m.d *= rsum;\n    \n    return m;\n}\n\nfloat readMat8Val(in mat8 m, in int x, in int y, in int size){\n    \n    int halfSize = int(floor(float(size) * .5));\n    return (x<4) ? (y<4) ? m.a[x][y] : m.c[x][y-halfSize] : (y<4) ? m.b[x-halfSize][y] : m.d[x-halfSize][y-halfSize];\n}\n\nvec3 applyMat8Kernel(in mat8rgb z, in mat8 m, in int size){\n    \n    vec3 x;\n    \n    for( int j = 0; j < size; j++){\n    for( int i = 0; i < size; i++){\n    \n        x.r += readMat8Val(z.r, i, j, size) * readMat8Val(m, i, j, size);\n        x.g += readMat8Val(z.g, i, j, size) * readMat8Val(m, i, j, size);\n        x.b += readMat8Val(z.b, i, j, size) * readMat8Val(m, i, j, size);\n    }   \n    }\n    \n    return vec3(x.r, x.g, x.b);\n    \n}\n\nvec3 applyMat8Filter(in sampler2D tx, in vec2 p, in vec2 d, in mat8 f, in int size)\n{    \n\n    mat8rgb m = mat8rgb(mat8(mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.)),\n                        mat8(mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.)),\n                        mat8(mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.),\n                             mat4(0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.,\n                                  0.,0.,0.,0.)));\n    \n    int halfSize = int(floor(float(size) * .5));\n    \n    for( int j = -halfSize; j <= halfSize; j++ ){\n    for( int i = -halfSize; i <= halfSize; i++ ){\n    \n            ivec2 offset = ivec2(i, j);\n        \n            vec2 pos = p + (vec2(offset) * d);\n            \n            ivec2 offset2 = offset + ivec2(halfSize, halfSize);\n            \n            if(offset2.x<4){\n                if(offset2.y<4){\n                    m.r.a[offset2.x][offset2.y] = texture(tx, pos).r;\n                    m.g.a[offset2.x][offset2.y] = texture(tx, pos).g;\n                    m.b.a[offset2.x][offset2.y] = texture(tx, pos).b;\n                } else {\n                    m.r.c[offset2.x][offset2.y-4] = texture(tx, pos).r;\n                    m.g.c[offset2.x][offset2.y-4] = texture(tx, pos).g;\n                    m.b.c[offset2.x][offset2.y-4] = texture(tx, pos).b;\n                }\n            } else {\n               if(offset2.y<4){\n                    m.r.b[offset2.x-4][offset2.y] = texture(tx, pos).r;\n                    m.g.b[offset2.x-4][offset2.y] = texture(tx, pos).g;\n                    m.b.b[offset2.x-4][offset2.y] = texture(tx, pos).b;\n               } else {\n                    m.r.d[offset2.x-4][offset2.y-4] = texture(tx, pos).r;\n                    m.g.d[offset2.x-4][offset2.y-4] = texture(tx, pos).g;\n                    m.b.d[offset2.x-4][offset2.y-4] = texture(tx, pos).b;\n               }\n            }\n    }\n    }\n    \n    return applyMat8Kernel(m, f, size);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 d = vec2(dx, dy);\n    \n    //-----Kernel size (odd numbers only) 3 <= x <= 7\n        int ksize1 = 3;\n        int ksize2 = 3;\n    \n        mat8 gk1 = initMat8GK(1., ksize1);\n        mat8 gk2 = initMat8GK(.01, ksize2);\n    \n        vec3 gkcol1 = applyMat8Filter(ic0, uv, d, gk1, ksize1);\n        vec3 gkcol2 = applyMat8Filter(ic0, uv, d, gk2, ksize2);\n        \n        vec3 col = vec3(0.);\n        vec3 gkcol = (((1. + TAU) * gkcol2) - (TAU * gkcol1));\n        col = gkcol*.001;\n        \n        col += smoothstep(.1, 1., vec3(pow(gkcol.r, 1.),pow(gkcol.g, 1.),pow(gkcol.b, 1.)));\n        col = vec3(round(col.r * COLOR_STEPS) * COLOR_STEPS_R, round(col.g * COLOR_STEPS) * COLOR_STEPS_R, round(col.b * COLOR_STEPS) * COLOR_STEPS_R);\n        \n    fragColor = vec4(col.rrr,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0; // edge-neighbors\n    const float _K2 = 1.0/6.0; // vertex-neighbors\n    const float cs = 0.25; // curl scale\n    const float ls = 0.24; // laplacian scale\n    const float ps = -0.06; // laplacian of divergence scale\n    const float ds = -0.08; // divergence scale\n    const float pwr = 0.2; // power when deriving rotation angle from curl\n    const float amp = 1.0; // self-amplification\n    const float sq2 = 0.7; // diagonal weight\n\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec3 uv =    texture(iChannel0, vUv).xyz;\n    vec3 uv_n =  texture(iChannel0, vUv+n).xyz;\n    vec3 uv_e =  texture(iChannel0, vUv+e).xyz;\n    vec3 uv_s =  texture(iChannel0, vUv+s).xyz;\n    vec3 uv_w =  texture(iChannel0, vUv+w).xyz;\n    vec3 uv_nw = texture(iChannel0, vUv+nw).xyz;\n    vec3 uv_sw = texture(iChannel0, vUv+sw).xyz;\n    vec3 uv_ne = texture(iChannel0, vUv+ne).xyz;\n    vec3 uv_se = texture(iChannel0, vUv+se).xyz;\n    \n    // uv.x and uv.y are our x and y components, uv.z is divergence \n\n    // laplacian of all components\n    vec3 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    float sp = ps * lapl.z;\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    float sd = ds * div;\n\n    vec2 norm = normalize(uv.xy);\n    \n    // temp values for the update rule\n    float ta = amp * uv.x + ls * lapl.x + norm.x * sp + uv.x * sd;\n    float tb = amp * uv.y + ls * lapl.y + norm.y * sp + uv.y * sd;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    // initialize with noise\n    if(iFrame<10 || reset()) {\n        fragColor = -0.5 + texture(ic1, fragCoord.xy / iResolution.xy);\n    } else {\n        fragColor = clamp(vec4(a,b,div,1), -1., 1.) * (texture(ic1, fragCoord.xy / iResolution.xy) * RHO)+ (-0.5 + texture(ic1, fragCoord.xy / iResolution.xy));\n    }\n    \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 components = texture(iChannel0, uv).xyz;\n    vec3 norm = normalize(components);\n    fragColor = vec4(0.5 + norm.z);\n}","name":"Buffer C","description":"","type":"buffer"}]}