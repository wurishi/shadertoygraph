{"ver":"0.1","info":{"id":"styBD3","date":"1665349826","viewed":143,"name":"Artober - Mosaic","username":"Flopine","description":"Day 9 of artober, I'm learning new stuffs along the way and it feels great :D I'm not doing my best renders though","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","repetition","pattern","tiling","everyday","octagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n// found in Shane's shader : https://www.shadertoy.com/view/wdBSRm\n#define oct(u,s) (max((abs(u.y) + abs(u.x))/sqrt(2.), max(abs(u.x), abs(u.y)))-s)\n#define circle(u,s) (length(u)-s)\n#define square(u,s) ( max(abs(u.x),abs(u.y)) - s)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.02,fwidth(val-thre)))\n\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = mod(atan(p.x,p.y)+per*.5, per)-per*.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nvec3 octa_tiles (vec2 uv)\n{\n    vec2 id = floor(uv - .5),\n    cp = fract(uv - .5) - .5,\n    uu = cp;\n    \n    float outline = AAstep(0.015, abs(oct(cp, 0.505)));\n\n    cp = abs(cp)-.25;\n    float d = AAstep(0.005, square(cp, 0.1));\n    outline *= AAstep(0.007, abs(square(cp, 0.1)));\n\n    cp = uu;\n    cp *= rot(PI/4.);\n    cp = abs(cp)-0.25;\n    d *= AAstep(0.005, square(cp, 0.1));\n    outline *= AAstep(0.007, abs(square(cp, 0.1)));\n\n    vec3 col = mix(vec3(0., 0.1, 0.5), vec3(0.99,0.4,0.1), d);\n\n    cp = uu;\n    moda(cp, 8.);\n    cp.x -= 0.5;\n    outline *= max(1.-d,AAstep(0.008, abs(cp.y)));\n    col *= outline;\n    \n    return col;\n}\n\nvec3 square_tiles (vec2 uv)\n{\n    vec2 id = floor(uv)*2.+1.,\n    cp = fract(uv)-.5;\n    \n    return mix(vec3(.7,0.2,0.4), vec3(0., 0.1, 0.5), mod((id.x+id.y)*.5,2.));\n}\n\n\n// Octagonal tiling is from Fizzer's shader: \n// https://www.shadertoy.com/view/MlyBRG\n// The comments added on my code are what I've understood from this shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    uv *= 2.;\n    vec2 p = uv.xy + vec2(iTime*.4);\n    \n    vec2 fpa = abs(fract(p) - .5),\n    fp, id;\n    \n    vec3 col;\n    \n    // if cell corners are outside the radius of octagon's inner circle (I think... XD)\n    if (fpa.x+fpa.y < 1.-sqrt(2.)*.5)\n    {\n        // we're in a square area\n        col = square_tiles(p);\n    }\n    else\n    {\n        // we're in an octagonal area\n        col = octa_tiles(p);\n    }\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}