{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n// Constants\nconst float M_PI    = 3.14159265358979323846;\nconst float M_SQRT2 = 1.41421356237309504880;\n\n\n\n// -------------------------------------------------\n// Forward cartesian projection\nvec2 transform_forward(vec2 P)\n{\n    return P;\n}\n\n// Inverse cartesian projection\nvec2 transform_inverse(vec2 P)\n{\n    return P;\n}\n// -------------------------------------------------\n\n\n\n\n// [-0.5,-0.5]x[0.5,0.5] -> [xmin,xmax]x[ymin,ymax]\n// ------------------------------------------------\nvec2 scale_forward(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P += vec2(.5,.5);\n    P *= vec2(limits[1] - limits[0], limits[3]-limits[2]);\n    P += vec2(limits[0], limits[2]);\n    return P;\n}\n\n// [xmin,xmax]x[ymin,ymax] -> [-0.5,-0.5]x[0.5,0.5]\n// ------------------------------------------------\nvec2 scale_inverse(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P -= vec2(limits[0], limits[2]);\n    P /= vec2(limits[1]-limits[0], limits[3]-limits[2]);\n    return P - vec2(.5,.5);\n}\n\n// Antialias stroke alpha coeff\nfloat stroke_alpha(float distance, float linewidth, float antialias)\n{\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n    if( border_distance > (linewidth/2.0 + antialias) )\n        return 0.0;\n    else if( border_distance < 0.0 )\n        return 1.0;\n    else\n        return alpha;\n}\n\n// Compute the nearest tick from a (normalized) t value\nfloat get_tick(float t, float vmin, float vmax, float step)\n{\n    float first_tick = floor((vmin + step/2.0)/step) * step;\n    float last_tick = floor((vmax + step/2.0)/step) * step;\n    float tick = vmin + t*(vmax-vmin);\n    if (tick < (vmin + (first_tick-vmin)/2.0))\n        return vmin;\n    if (tick > (last_tick + (vmax-last_tick)/2.0))\n        return vmax;\n    tick += step/2.0;\n    tick = floor(tick/step)*step;\n    return min(max(vmin,tick),vmax);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t// Cartesian limits\n\tvec4 u_limits1 = vec4(-10.1, +10.1, -10.1, +10.1)  * .5*(1.+sin(iTime/2.))/2.;\n\n\t// Projected limits\n\tvec4 u_limits2 = vec4(-10.,10.,-10.,10.); ;\n\n    const float u_antialias = 1.0;\n\tvec2 u_major_grid_step = vec2(1.0, 1.0);\n\tvec2 u_minor_grid_step = vec2(.1, .1);\n\tfloat u_major_grid_width = 2.00;\n\tfloat u_minor_grid_width = 1.00;\n\tvec4  u_major_grid_color = vec4(0,0,0,1);\n\tvec4  u_minor_grid_color = vec4(.5,.5,.5,1);\n\n    \n    vec2 v_texcoord;\n    if (iResolution.x > iResolution.y) {\n        v_texcoord.x = fragCoord.x/iResolution.y - 0.5\n                     - 0.5*(iResolution.x-iResolution.y)/iResolution.y;\n        v_texcoord.y = fragCoord.y/iResolution.y - 0.5;\n\t} else {\t\n        v_texcoord.x = fragCoord.x/iResolution.x - 0.5;\n        v_texcoord.y = fragCoord.y/iResolution.x - 0.5\n                     - 0.5*(iResolution.y-iResolution.x)/iResolution.x;\n    }\n    vec2 v_size = iResolution.xy;    \n\n    \n    \n    vec2 NP1 = v_texcoord;\n    vec2 P1 = scale_forward(NP1, u_limits1);\n    vec2 P2 = transform_inverse(P1);\n\n    // Test if we are within limits but we do not discard yet because we want\n    // to draw border. Discarding would mean half of the exterior not drawn.\n    bvec2 outside = bvec2(false);\n    if( P2.x < u_limits2[0] ) outside.x = true;\n    if( P2.x > u_limits2[1] ) outside.x = true;\n    if( P2.y < u_limits2[2] ) outside.y = true;\n    if( P2.y > u_limits2[3] ) outside.y = true;\n\n    vec2 NP2 = scale_inverse(P2,u_limits2);\n    vec2 P;\n    float tick;\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_major_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float Mx = length(v_size * (NP1 - P));\n    // float Mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_minor_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float mx = length(v_size * (NP1 - P));\n    // float mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_major_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float My = length(v_size * (NP1 - P));\n    // float My = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_minor_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float my = length(v_size * (NP1 - P));\n    // float my = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    float M = min(Mx,My);\n    float m = min(mx,my);\n\n    // Here we take care of \"finishing\" the border lines\n    if( outside.x && outside.y ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = max(Mx,My);\n        }\n    } else if( outside.x ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = Mx;\n        }\n    } else if( outside.y ) {\n        if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = My;\n        }\n    }\n\n    // Mix major/minor colors to get dominant color\n    vec4 color = u_major_grid_color;\n    float alpha1 = stroke_alpha( M, u_major_grid_width, u_antialias);\n    float alpha2 = stroke_alpha( m, u_minor_grid_width, u_antialias);\n    float alpha  = alpha1;\n    if( alpha2 > alpha1*1.5 )\n    {\n        alpha = alpha2;\n        color = u_minor_grid_color;\n    }\n\n    fragColor = mix(vec4(1,1,1,1), color, alpha);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdSXRm","date":"1410253374","viewed":1974,"name":"Cartesian grid","username":"rougier","description":"Pixel perfect regular grid. Better in full screen. Works for any invertible projection (see other shaders)","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["grid","antialias","projection","distance","polar","hammer","mercator","cartesian"],"hasliked":0,"parentid":"","parentname":""}}