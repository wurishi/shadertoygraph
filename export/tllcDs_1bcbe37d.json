{"ver":"0.1","info":{"id":"tllcDs","date":"1685033962","viewed":66,"name":"voice_assistant_loop","username":"MartinRGB","description":"voice assistant","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["voiceassistant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 100.\n\n#define ENABLE_RADIAL_BLUR true\n\nvec4 blurEffect( sampler2D sourceImage, vec2 inUV, vec2 innerPoint ){\n    \n    float u_slot1 = (sin(iTime*2.) + 1.)/2.;\n    \n    vec2 targetVector = innerPoint - inUV;\n    float shineFactor = 1. - length(targetVector) / sqrt(0.005 + 0.5 * u_slot1);\n    //shineFactor = 0.5 + u_slot1*0.5;\n    \n    //shineFactor*= (sin(iTime) +1.)/2.;\n    \n    vec4 result = texture(sourceImage, inUV);\n    \n    // Turn on to overlay blur over texture\n    bool textureOverlay = true;\n    \n    if(!textureOverlay)\n    \tresult = vec4(0.0);\n    \n    if(ENABLE_RADIAL_BLUR)\n        for(float dist = 0.0; dist < 1.0; dist += 2. / STEPS){\n\n            result += texture(sourceImage, inUV + targetVector * dist*1.) * shineFactor / STEPS;\n\n        }\n    else\n        result = texture(sourceImage,inUV);\n    \n    result.w = 1.;\n    return result;\n    \n}\n\n// Move mouse around to set inner point of radial blur!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized inner point of radial blur\n    vec2 innerPoint = iMouse.xy / iResolution.xy; //vec2((sin(iTime)+1.)/2.,0.5);\n\n    //innerPoint = vec2(0.5 + 0.25*sin(iTime),0.5);\n    fragColor = blurEffect(iChannel0, uv, innerPoint);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( ab.x > ab.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        //co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n        co = min(0.999,(ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0);\n    }\n    \n    float si = sqrt( 1.0 - co*co );\n    vec2 r = ab * vec2(co,si);\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n//#define USE_APPROXIMATION\n#define PI 3.1415926\n// See: https://iquilezles.org/articles/ellipsoids\nfloat sdEllipsoidApproximated( in vec2 p, in vec2 r ) \n{\n    // # funny method \n    //r = r*0.01 + 0.15;\n    //r = vec2(pow(r.x,0.5),pow(r.y,0.5));\n    //r =  r + 0.1;\n    \n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec4 ringImage( in float radius,in float borderWidth,in vec2 pos,in float radians,float blur,vec3 blurColor)\n{\n\tvec2 uv = -.5 + 1.0 * gl_FragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    uv -= pos;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n    \n    //float radius = 0.2;\n    //float borderWidth = 0.2;\n\t\n    #ifdef USE_APPROXIMATION\n\tfloat d = sdEllipsoidApproximated( uv, vec2(radius + 0.003  - (((sin(iTime*2.))+1.)/2.*radius),radius));\n    d = sdEllipsoidApproximated(uv,vec2(radius - map(sin(radians),-1.,1.,0.003,0.001+radius)+0.0012 ,radius ));\n    #else\n    float d = sdEllipse(uv,vec2(radius - map(sin(radians),-1.,1.,0.003,0.001+radius)+0.0012 ,radius )); // map(sin(iTime*2. + radians),-1.,1.,0.003,0.001+radius)\n    //d = sdEllipse(uv,vec2(radius - 0.003,radius));\n    #endif\n    \n    //d = mix(d1,d2,0.5);\n    \n    #ifdef USE_APPROXIMATION\n \tfloat r = 1.0-smoothstep(borderWidth-borderWidth/2. ,borderWidth+borderWidth/2. ,abs(d));\n    float rBlur = 1.0-smoothstep(borderWidth-borderWidth/2.*blur ,borderWidth+borderWidth/2.*blur ,abs(d));\n    #else\n    float r = 1.0-smoothstep(borderWidth-borderWidth/2. ,borderWidth+borderWidth/2. ,abs(d));\n    float rBlur = 1.0-smoothstep(borderWidth-borderWidth/2.*blur ,borderWidth+borderWidth/2.*blur ,abs(d));\n    #endif\n    \n    vec4 col,colBlur;\n    \n\tcol = vec4(r);\n\tcolBlur = vec4(blurColor,pow(rBlur,1.5));\n    \n//     vec4 color = vec4(r);\n//     if(color.a <= 0.9999999){\n//         color.a = 0.;\n//     }\n//     else{\n        \n//     }\n    \n    if(col.a <= 0.001){\n        col = vec4(1.,1.,1.,0.);\n    }\n    else{\n        //col = mix(vec4(vec3(1.,0.,0.),1.),col,col.a);\n        \n    }\n    \n    //col += colBlur;\n    col = mix(colBlur,col,col.a);\n    \n\treturn col; //1.0 -abs(d)\n}\n\nvec4 drawObjectColor(in vec2 uv){\n    vec4 color,colorAdd;\n    vec4 colorC0,colorL1,colorL2,colorL3,colorR1,colorR2,colorR3;\n    \n    float u_slot1 = (sin(iTime*2.) + 1.)/2.;\n    float u_slot2 = (cos(iTime) + 1.)/2.;\n    u_slot2 = 0.;\n    \n    //u_slot1 = 0.;\n    \n    vec3 blurColor = vec3(0.03,0.090,0.930);\n    float blurRadius = 5. + 4.*u_slot1;\n    \n    colorC0 = ringImage(0.09,0.015,vec2(0.,0.) + vec2(u_slot1*0.,0.),PI*1.5 - PI*u_slot1,blurRadius,blurColor);\n    colorL1 = ringImage(0.070 - u_slot1*0.02 + 0.02*u_slot2,0.015,vec2(0.,0.) + vec2(-u_slot1*0.1,0.),PI*1.5 - PI*u_slot1,blurRadius,blurColor);\n    colorL3 = ringImage(0.050 - u_slot1*0.048+ 0.04*u_slot2,0.015,vec2(0.,0.) + vec2(-u_slot1*0.3,0.),PI*1.5 - PI*u_slot1,blurRadius,blurColor);\n    colorL2 = ringImage(0.050 - u_slot1*0.03+ 0.04*u_slot2,0.015,vec2(0.,0.) + vec2(-u_slot1*0.2,0.),PI*1.5 - PI*u_slot1,blurRadius,blurColor);\n    colorR1 = ringImage(0.070 - u_slot1*0.02+ 0.02*u_slot2,0.015,vec2(0.,0.)+ vec2(u_slot1*0.1,0.),PI*1.5 - PI*u_slot1,blurRadius,blurColor);\n    colorR2 = ringImage(0.050  - u_slot1*0.03+ 0.04*u_slot2,0.015,vec2(0.,0.)+ vec2(u_slot1*0.2,0.),PI*1.5 - PI*u_slot1,blurRadius,blurColor);\n    colorR3 = ringImage(0.050 - u_slot1*0.048+ 0.04*u_slot2,0.015,vec2(0.,0.) + vec2(u_slot1*0.3,0.),PI*1.5 - PI*u_slot1,blurRadius,blurColor);\n    \n\n    color = mix(color,colorR3,colorR3.a);\n    color = mix(color,colorL3,colorL3.a);\n    color = mix(color,colorR2,colorR2.a);\n    color = mix(color,colorL2,colorL2.a);\n    color = mix(color,colorR1,colorR1.a);\n    color = mix(color,colorL1,colorL1.a);\n    color = mix(color,colorC0,colorC0.a);\n    \n    colorAdd = colorC0+colorL1+colorL2+colorL3+colorR1+colorR2+colorR3;\n\n   \n    \n    //color = mix(colorAdd,color,1. - u_slot1);\n    //color = colorAdd;\n    \n    return color;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 color = drawObjectColor(uv);\n    \n    fragColor =  color;\n}","name":"Buffer A","description":"","type":"buffer"}]}