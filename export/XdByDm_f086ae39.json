{"ver":"0.1","info":{"id":"XdByDm","date":"1492285728","viewed":147,"name":"PhotoAlter","username":"MasqueradeOfSilence","description":"PhotoAlter: Shader that continually changes an image from the following four settings:\n1. Color\n2. Grayscale\n3. Sepia\n4. Negative","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["awesome"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\nCreated by Alex Neville\nLanguage: GLSL\n\n\tPhotoAlter: Shader that continually changes an image from the following \n\t\tfour settings:\n        1. Color\n        2. Grayscale\n        3. Sepia\n        4. Negative\n**/\n\n#define PI 3.1415926535897932384626433832795\n#define PI_T PI / 2.0\n#define T_PI PI * 2.0\n#define ALPHA 255.0\n#define SCALE 1.0\n\n/**\n\tgetNormalizedTime: Returns an index in the unit circle, \n\t\tbetween 0 and 2pi. \n\n\tMaximum number of iterations must be specified, because\n\t\tGLSL does not allow while loops or for loops without \n\t\ta set number of iterations. The algorithm can run\n\t\tfor upwards of 5 minutes with only 20 iterations. \n**/\nfloat getNormalizedTime(float time)\n{\n    const int maxIter = 20;\n    for (int i = 0; i < maxIter; i++)\n    {\n        if (time >= T_PI)\n        {\n            time -= T_PI;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return time;\n}\n\n/**\n\tMainImage method: Controls the color value of each pixel.\n\t\tThis is based on a function of the current time,\n\t\tsine wave, and unit circle. \n**/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    xy.y = SCALE - xy.y;\n    vec4 textureColor = texture(iChannel0, xy);\n    \n    // obtain elapsed time in seconds\n    float time = getNormalizedTime(iTime);\n    \n    // Color: Keep as is. Sin(0) = 0. \n    if (time >= 0.0 && time < PI_T)\n    {\n\t\t;\n    }\n    // Black and White:\n    else if (time >= PI_T && time < PI)\n    {\n     \ttextureColor.rgb = vec3(0.21 * textureColor.r + 0.72 *\n            textureColor.g + 0.07 * textureColor.b);\n    }\n    // Sepia:\n    else if (time >= PI && time < (3.0 * PI) / 2.0)\n    {\n        float tr = 0.393 * textureColor.r + 0.769 * textureColor.g\n            + 0.189 * textureColor.b;\n        float tg = 0.349 * textureColor.r + 0.686 * textureColor.g\n            + 0.168 * textureColor.b;\n        float tb = 0.272 * textureColor.r + 0.534 * textureColor.g\n            + 0.131 * textureColor.b;\n        if (tr > ALPHA)\n        {\n            textureColor.r = ALPHA;\n        }\n        else\n        {\n            textureColor.r = tr;\n        }\n        if (tg > ALPHA)\n        {\n            textureColor.g = ALPHA;\n        }\n        else\n        {\n            textureColor.g = tg;\n        }\n        if (tb > ALPHA)\n        {\n            textureColor.b = ALPHA;\n        }\n        else\n        {\n            textureColor.b = tb;\n        }\n    }\n    // Negative: Use 1.0, not 255.0, for this scaling!\n    else\n    {\n        float tr = SCALE - textureColor.r;\n        float tg = SCALE - textureColor.g;\n        float tb = SCALE - textureColor.b;\n        textureColor.r = tr;\n        textureColor.g = tg;\n        textureColor.b = tb;\n    }\n    fragColor = textureColor;\n}","name":"Image","description":"","type":"image"}]}