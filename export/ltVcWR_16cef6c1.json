{"ver":"0.1","info":{"id":"ltVcWR","date":"1536255106","viewed":412,"name":"Art by Numbers VI","username":"mhnewman","description":"Inspired by the works of Yayoi Kusama","likes":32,"published":1,"flags":32,"usePreview":0,"tags":["procedural","art","yayoi","kusama"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pow(texture(iChannel0, fragCoord / iResolution.xy), vec4(0.25, 0.4, 0.4, 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float sphericalAberration = 0.1;\nconst float vignetting = 0.3;\nconst vec3 backgroundColor = vec3(1.0);\n\nconst int marchIter = 200;\nconst float marchDist = 100.0;\nconst float epsilon = 0.0001;\n\nconst float tau = 6.283185;\n\nfloat boundingCapsule(vec3 pos, vec3 top, float radius) {\n    top.z = min(top.z, pos.z);\n    return distance(pos, top) - radius;\n}\n\nfloat scene(vec3 pos) {\n    float row = 0.2;\n \tvec3 p = floor(pos / vec3(1.0, 1.0, row));\n    float height = 1.5 + 8.0 * hash1(p.xy);\n    float maxHeight = 9.0 * row;\n    float k = -20.0;\n    float res = 0.0;\n    for (int i = 0; i < 5; ++i) {\n        float id = p.z + float(i) - 2.0;\n        vec3 h = vec3(p.xy, id);\n        float radius = id / height + hash1(h) - 0.5;\n        radius = mix(0.25, 0.1, clamp(radius, 0.0, 1.0));\n        vec3 center = vec3(p.xy, row * (id + 0.5));\n        center += mix(vec3(0.35, 0.35, 0.0), vec3(0.65, 0.65, 0.0), hash3(h));\n\t    res += exp2(k * (distance(pos, center) - radius)) * step(id, height);\n    }\n    float sdf = log2(res) / k;\n    sdf = min(sdf, pos.z);\n    sdf = min(sdf, boundingCapsule(pos, vec3(p.xy + vec2(0.5, -0.5), maxHeight), 0.4));\n    sdf = min(sdf, boundingCapsule(pos, vec3(p.xy + vec2(-0.5, 0.5), maxHeight), 0.4));\n    sdf = min(sdf, boundingCapsule(pos, vec3(p.xy + vec2(0.5, 1.5), maxHeight), 0.4));\n    sdf = min(sdf, boundingCapsule(pos, vec3(p.xy + vec2(1.5, 0.5), maxHeight), 0.4));\n    return sdf;\n}\n\nfloat setCamera(out vec3 eye, out vec3 center, out float focalDist, out float blurAmount) {\n    focalDist = 6.0;\n    blurAmount = 0.007;    \n    \n    vec2 m = vec2(0.15, 0.75);\n    m *= tau * vec2(1.0, 0.25);    \n    float dist = 6.0;\n    center = vec3(0.5, 0.5, 0.7);\n    eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    return 6.0;\n}\n\n//\tFrom http://nghiaho.com/?page_id=846\nconst mat3 m = mat3( 0.25581, -0.77351,  0.57986,\n                    -0.85333, -0.46255, -0.24057,\n                     0.45429, -0.43327, -0.77839);\n\nvec3 setColor(vec3 pos, vec3 norm) {\n    pos = 6.0 * m * pos;\n    vec3 p = floor(pos);\n    float d = distance(pos, p + vec3(0.35) + 0.3 * hash3(p));\n    return mix(vec3(0.8, 0.0, 0.0), vec3(1.0), step(0.35, d));\n}\n\nfloat castRay(vec3 eye, vec3 ray, out float dist) {\n    dist = 0.0;\n    for (int i = 0; i < marchIter; ++i) {\n        float sdf = scene(eye + dist * ray);\n        dist += sdf;\n        if (sdf < epsilon)\n            return 1.0;\n        if (dist >= marchDist)\n            break;\n    }\n    return 0.0;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + epsilon, p.y, p.z)) - scene(vec3(p.x - epsilon, p.y, p.z)),\n        scene(vec3(p.x, p.y + epsilon, p.z)) - scene(vec3(p.x, p.y - epsilon, p.z)),\n        scene(vec3(p.x, p.y, p.z + epsilon)) - scene(vec3(p.x, p.y, p.z - epsilon))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Restart accumulation on window resize\n    vec3 frame = texture(iChannel0, vec2(0.5) / iResolution.xy).xyz;\n    float resize = step(abs(frame.x - iResolution.x) + abs(frame.y - iResolution.y), 0.5);\n    frame.xy = iResolution.xy;\n    frame.z = mix(1.0, frame.z + 1.0, resize);\n    \n    // Render pass\n    vec3 eye, center;\n    float focalDist, blurAmount;\n    float zoom = setCamera(eye, center, focalDist, blurAmount);\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n\n    // Anti aliasing\n    vec2 hash = hash2(vec3(iTime, fragCoord));\n    vec2 xy = (2.0 * (fragCoord + hash - 0.5) - iResolution.xy) / iResolution.y;\n    \n    // Spherical aberration\n    xy /= cos(sphericalAberration * (1.0 + 0.3 * hash1(vec3(iTime + 0.1, fragCoord))) * length(xy));\n    \n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward);\n    \n    // Depth of field    \n    hash = hash2(vec3(iTime + 0.2, fragCoord));\n    float a = sqrt(hash.x);\n    float b = a * cos(6.283185 * hash.y);\n    float c = a * sin(6.283185 * hash.y);\n\n    vec3 target = eye + ray * focalDist / dot(ray, forward);\n    eye += focalDist * blurAmount * (b * right + c * up);\n    ray = normalize(target - eye);\n    \n    // Cast Ray\n    float dist;\n    float hit = castRay(eye, ray, dist);\n    vec3 pos = eye + dist * ray;\n\n    vec3 norm = normal(pos);\n    vec3 color = setColor(pos, norm);\n    \n    // Ambient occlusion\n    pos += 0.001 * norm;\n\n    vec3 z = norm;\n    vec3 x = normalize(cross(z, vec3(-0.36, -0.48, 0.8)));\n    vec3 y = normalize(cross(z, x));\n\n    hash = hash2(vec3(iTime + 0.3, fragCoord));\n    a = sqrt(hash.x);\n    b = a * cos(6.283185 * hash.y);\n    c = a * sin(6.283185 * hash.y);\n    a = sqrt(1.0 - hash.x);\n    vec3 shadeDir = b * x + c * y + a * z;\n    color *= 1.0 - castRay(pos, shadeDir, dist);\n    \n    color = mix(backgroundColor, color, hit);\n\n    // Vignetting\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    color *= vignetting * pow((1.0 - uv.x * uv.x) * (1.0 - uv.y * uv.y), 0.2) + 1.0 - vignetting;\n    \n    // Accumulate color\n    vec3 oldColor = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 accum = mix(oldColor, color, 1.0 / frame.z);\n    fragColor = vec4(mix(accum, frame, step(fragCoord.x + fragCoord.y, 1.5)), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash1(float p) {\n\tvec2 p2 = fract(p * vec2(5.39831, 5.44272));\n    p2 += dot(p2.yx, p2.xy + vec2(21.53514, 14.31375));\n\treturn fract(p2.x * p2.y * 95.43376);\n}\n\nfloat hash1(vec2 p2) {\n\tp2 = fract(p2 * vec2(5.39831, 5.44272));\n    p2 += dot(p2.yx, p2.xy + vec2(21.53514, 14.31375));\n\treturn fract(p2.x * p2.y * 95.43376);\n}\n\nfloat hash1(vec3 p3) {\n    p3 = fract(p3 * vec3(5.39831, 5.44272, 6.93713));\n    p3 += dot(p3, p3.yxz + 19.19348);\n    return fract(p3.x * p3.y * p3.z);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(5.39831, 5.44272, 6.93713));\n    p3 += dot(p3, p3.yzx + 19.19348);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(float p) {\n    vec3 p3 = fract(p * vec3(5.39831, 5.44272, 6.93713));\n    p3 += dot(p3, p3.yxz + 19.19348);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 hash3(vec3 p3) {\n    p3 = fract(p3 * vec3(5.39831, 5.44272, 6.93713));\n    p3 += dot(p3, p3.yxz + 19.19348);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}","name":"Common","description":"","type":"common"}]}