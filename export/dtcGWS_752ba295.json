{"ver":"0.1","info":{"id":"dtcGWS","date":"1683950817","viewed":150,"name":"TriangleNet","username":"ayaha401","description":"I want to make glow but I could not....","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define T iTime\n#define saturate(x) clamp(x, 0., 1.)\n\nconst float PI=3.1415926536;\nconst float TAU=PI*2.;\nconst float eps=1e-6;\nconst float DEG2RAD = PI/180.;\nconst float LT = 20.;\n\nvec2 pmod(vec2 p, float n)\n{\n    float a = mod(atan(p.y, p.x),TAU / n) - .5 * TAU / n;\n    return length(p) * vec2(sin(a), cos(a));\n}\n\nfloat opu(float d1, float d2) { return min(d1, d2); }\n\nfloat ops(float d1, float d2) { return max(-d1, d2); }\n\nvec2 path(float t)\n{\n    return vec2(sin(t), cos(t))*.1;\n}\n\nfloat exp2Fog(float d, float density)\n{\n    float dd = d * density;\n    return exp(-dd * dd);\n}\n\nfloat triangle(vec2 p) {\n\tp.x /= sqrt(3.);\n\tfloat d1 = abs(fract(p.x + p.y + .5) - .5);\n\tfloat d2 = abs(fract(p.x - p.y + .5) - .5);\n\tfloat d3 = abs(fract(p.x * 2. + .5) - .5);\n\treturn min(min(d1, d2), d3) * sqrt(3.) * .5;\n}\n\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    pp.xy *= rot(DEG2RAD*30.);\n    pp.xy += vec2(.3, .5);    //offset\n    pp.z = mod(pp.z, .5) - .25;\n    \n    float d;\n    \n    float triBase=abs(triangle(pp.xy))-.05;\n    float d0=abs(pp.z)-.13;\n    \n    float triIn=triangle(pp.xy)-.08;\n    float d1=abs(pp.z)-.03;\n    d = opu(max(triIn, d1), max(triBase,d0));\n    \n    return d;\n}\n\nvec3 makeN(vec3 p)\n{\n    vec2 eps = vec2(.0001, 0.);\n    return normalize(vec3(map(p+eps.xyy)-map(p-eps.xyy),\n                          map(p+eps.yxy)-map(p-eps.yxy),\n                          map(p+eps.yyx)-map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float zfac = ((1.0-dot(uv, uv))*.1 + 1.);\n    float dist, hit, i = 0.;\n    vec3 cPos = vec3(0., 0., T*1.3);\n    vec3 lookAt = cPos + vec3(0., 0., .5);\n    cPos.xy += path(cPos.z) * 3.7;\n    lookAt.xy += path(lookAt.z) * 2.5;\n    float fov = PI/3.5;\n    vec3 forward = normalize(lookAt - cPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = cross(forward, right);\n    vec3 ray = forward*zfac + fov*uv.x*right + fov*uv.y*up;\n    ray = normalize(ray);\n    vec3 L = normalize(vec3(1.)*vec3(sin(T), cos(T), 1.));\n    vec3 col=vec3(0);\n    float t=mod(T, LT);\n    \n    for(;i<128.;i++)\n    {\n        vec3 rp = cPos + ray * hit;\n        rp.xy += -path(rp.z)*4.5;\n        dist = map(rp);\n        hit += dist;\n        \n        if(dist < eps)\n        {\n            vec3 N=makeN(rp);\n            float diff = dot(N,L) * .5 + .5;\n            diff += .5;\n            float spec = pow(saturate(dot(reflect(L, N), ray)), 100.0);\n\n            col = vec3(.3);\n            if(mod(rp.z-(.25-.13)-(.13-.031), 1.5) < .03*2.) col = vec3(1., .656, .238);\n            col = col * diff + spec;\n        }\n    }\n    \n    float ft = 10.; // fadeTime\n    if(t<1.3) col *= abs(2. * fract((T*LT)* .5 - .25) - 1.); // flicker\n    if((mod(t-8., LT) < 8.)) col *= 1.-1./(1.+exp(6.-mod(T-8.,LT)*ft)); // fadeout\n    if((mod(t-16., LT) < 1.)) col *= 1./(1.+exp(6.-mod(T-16.,LT)*ft)); // fadein\n    \n    // fog\n    vec3 fogCol = vec3(1., 1., 1.);\n    float fp = .36; // fogPower\n    float fog = exp2Fog(hit, fp);\n    col = mix(fogCol, col, fog);\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}