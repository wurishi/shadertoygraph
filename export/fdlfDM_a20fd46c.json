{"ver":"0.1","info":{"id":"fdlfDM","date":"1644941768","viewed":321,"name":"My Simple BingDwenDwen","username":"nelsonkuang","description":"A simple BingDwenDwen...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bingdwendwen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* References:\n* 1. iq's sdf functions\n* 2. https://inspirnathan.com/topics/shaders/\n*/\nconst int MAX_MARCHING_STEPS = 180;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.1415926535897932384626433832795;\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance value from SDF\n  Material mat; // material of object\n};\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial red() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.1, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.2, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial darkRed() {\n  vec3 aCol = 0.5 * vec3(0.2, 0.1, 0.1);\n  vec3 dCol = 0.6 * vec3(0.1, 0.05, 0.05);\n  vec3 sCol = 0.6 * vec3(0.3, 0.3, 0.3);\n  float a = .5;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial snowWhite() {\n  vec3 aCol = .8 * vec3(.8);\n  vec3 dCol = 0.1 * vec3(0.8);\n  vec3 sCol = .2 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial black() {\n  vec3 aCol = 0.0 * vec3(0.8);\n  vec3 dCol = 0.0 * vec3(0.8);\n  vec3 sCol = 0.0 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7 * mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial rainbow(vec3 p, float t) {\n  vec3 aCol = .4 * palette(t, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.00, 0.33, 0.67));\n  vec3 dCol = .5 * vec3(.8);\n  vec3 sCol = .6 * vec3(1);\n  float a = 2.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nmat3 rotateX(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));\n}\n\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));\n}\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1));\n}\n\nmat3 identity() {\n  return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n/*\nSurface IDs:\n1. Floor\n2. Box\n3. Sphere\n4. Ellipsoid\n5. Torus\n*/\nSurface sdFloor(vec3 p, float offset, Material mat) {\n  float d = p.y - offset;\n  return Surface(1, d, mat);\n}\n\n// x ^ 2 + y ^ 2 + z ^ 2 = r ^ 2\nSurface sdSphere(vec3 p, float r, vec3 offset, Material mat, mat3 transform, vec3 transformOrigin) {\n  p = (p - offset) * transform - transformOrigin;\n  return Surface(3, length(p) - r, mat);\n}\n\nSurface sdEllipsoid(vec3 p, vec3 r, vec3 offset, Material mat, mat3 transform, vec3 transformOrigin) {\n  p = (p - offset) * transform - transformOrigin;\n  return Surface(4, (length(p / r) - 1.0) * min(min(r.x, r.y), r.z), mat);\n}\n\nSurface sdTorus(vec3 p, vec2 t, vec3 offset, Material mat, mat3 transform, vec3 transformOrigin) {\n  p = (p - offset) * transform - transformOrigin;\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return Surface(5, length(q) - t.y, mat);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if(obj2.sd < obj1.sd)\n    return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  Surface floorObj = sdFloor(p, -1., checkerboard(p));\n  Surface bodyObj = sdEllipsoid(p, vec3(1.6, 2., 1.6), vec3(0, 1.5, -4), snowWhite(), identity(), vec3(0)); // identity\n\n  Surface leftLegObj = sdEllipsoid(p, vec3(.5, 1., .5), vec3(-1.5, 0, -4), black(), rotateZ(PI / 4.), vec3(0));\n  Surface rightLegObj = sdEllipsoid(p, vec3(.5, 1., .5), vec3(1.5, 0, -4), black(), rotateZ(-PI / 4.), vec3(0));\n\n  Surface leftArmObj = sdEllipsoid(p, vec3(.5, 1., .5), vec3(-1.5, 1.8, -4), black(), rotateZ(PI / 4.), vec3(0));\n  Surface rightArmObj = sdEllipsoid(p, vec3(.5, 1., .5), vec3(1.5, 1.8, -4), black(), rotateZ(-3. * PI / 4.), vec3(0));\n  Surface leftHandObj = sdEllipsoid(p, vec3(.2, .2, .1), vec3(-1.9, 1.5, -4.35), darkRed(), identity(), vec3(0));\n  Surface rightHandObj = sdEllipsoid(p, vec3(.2, .2, .1), vec3(1.9, 2.3, -4.27), darkRed(), identity(), vec3(0));\n\n  Surface leftEarObj = sdSphere(p, .4, vec3(-1.1, 3.3, -4), black(), rotateZ(PI / 4.), vec3(0));\n  Surface rightEarObj = sdSphere(p, .4, vec3(1.1, 3.3, -4), black(), rotateZ(-PI / 4.), vec3(0));\n\n  Surface yellowRingObj = sdTorus(p, vec2(1.1, .05), vec3(0, 2.3, -5.1), rainbow(p, 0.85), rotateX(0.719 * PI / 2.), vec3(0));\n  Surface blueRingObj = sdTorus(p, vec2(1.05, .06), vec3(0, 2.3, -5.15), rainbow(p, 0.45), rotateX(0.725 * PI / 2.), vec3(0));\n  Surface redRingObj = sdTorus(p, vec2(1.0, .05), vec3(0, 2.3, -5.2), rainbow(p, 0.15), rotateX(0.73 * PI / 2.), vec3(0));\n\n  Surface rightEyeObj = sdEllipsoid(p, vec3(.25, .5, .25), vec3(-.45, 2.5, -5.2), black(), rotateZ(PI / 4.), vec3(0));\n  Surface leftEyeObj = sdEllipsoid(p, vec3(.25, .5, .25), vec3(.45, 2.5, -5.2), black(), rotateZ(-PI / 4.), vec3(0));\n\n  Surface rightWhiteEyeBallObj = sdSphere(p, .13, vec3(-.35, 2.65, -5.35), snowWhite(), identity(), vec3(0));\n  Surface leftEWhiteyeBallObj = sdSphere(p, .13, vec3(.35, 2.65, -5.35), snowWhite(), identity(), vec3(0));\n\n  Surface rightBlackEyeBallObj = sdSphere(p, .108, vec3(-.35, 2.67, -5.39), black(), identity(), vec3(0));\n  Surface leftBlackEyeBallObj = sdSphere(p, .108, vec3(.35, 2.67, -5.39), black(), identity(), vec3(0));\n\n  Surface noseBallObj = sdSphere(p, .15, vec3(0, 2.35, -5.4), black(), identity(), vec3(0));\n\n  Surface mouthObj = sdEllipsoid(p, vec3(.3, .2, .1), vec3(0, 1.9, -5.5), red(), identity(), vec3(0));\n\n  Surface co = opUnion(floorObj, bodyObj);\n  co = opUnion(co, leftLegObj);\n  co = opUnion(co, rightLegObj);\n\n  co = opUnion(co, leftArmObj);\n  co = opUnion(co, rightArmObj);\n  co = opUnion(co, leftHandObj);\n  co = opUnion(co, rightHandObj);\n\n  co = opUnion(co, leftEarObj);\n  co = opUnion(co, rightEarObj);\n\n  co = opUnion(co, yellowRingObj);\n  co = opUnion(co, blueRingObj);\n  co = opUnion(co, redRingObj);\n\n  co = opUnion(co, rightEyeObj);\n  co = opUnion(co, leftEyeObj);\n  co = opUnion(co, rightWhiteEyeBallObj);\n  co = opUnion(co, leftEWhiteyeBallObj);\n  co = opUnion(co, rightBlackEyeBallObj);\n  co = opUnion(co, leftBlackEyeBallObj);\n\n  co = opUnion(co, noseBallObj);\n\n  co = opUnion(co, mouthObj);\n\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co;\n\n  for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if(co.sd < PRECISION || depth > end)\n      break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1., -1.) * .0005;\n  return normalize(e.xyy * sdScene(p + e.xyy).sd +\n    e.yyx * sdScene(p + e.yyx).sd +\n    e.yxy * sdScene(p + e.yxy).sd +\n    e.xxx * sdScene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n  vec3 up = vec3(0, 1, 0);\n  vec3 cd = normalize(lookAtPoint - cameraPos);\n  vec3 cr = normalize(cross(up, cd));\n  vec3 cu = normalize(cross(cd, cr));\n\n  return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n  vec2 mouseUV = iMouse.xy / iResolution.xy;\n\n  vec3 backgroundColor = vec3(.835, 1, 1);\n\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0, .5, -4);\n\n  vec3 ro = vec3(0, 2, -1);\n\n  float cameraRadius = 3.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(PI / 2., 0., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n\n  if(co.sd > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    vec3 p = ro + rd * co.sd;\n    vec3 normal = calcNormal(p);\n\n      // light #1\n    vec3 lightPosition1 = vec3(-8, -6, -5);\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    float lightIntensity1 = 0.9;\n\n      // light #2\n    vec3 lightPosition2 = vec3(1, 1, 1);\n    vec3 lightDirection2 = normalize(lightPosition2 - p);\n    float lightIntensity2 = 0.5;\n\n      // final color of object\n    col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat);\n    col += lightIntensity2 * phong(lightDirection2, normal, rd, co.mat);\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}