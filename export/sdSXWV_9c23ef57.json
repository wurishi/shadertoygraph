{"ver":"0.1","info":{"id":"sdSXWV","date":"1621114385","viewed":98,"name":"Color Touch by Darko","username":"omegasbk","description":"Made this simple SDF scene for fun.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Darko Supe (omegasbk)\n// 15.5.2021.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n\n#define PI 3.14159265359\n\n#define BOX1 0\n#define BALL 1\n#define WALL 2\n#define BOX2 3\n\nfloat getDist(vec3 p, out int body) \n{\n    float time = iTime * 3.;\n\n    vec4 s = vec4(2, abs(sin(time)) * 2. + 1.9, 7, 1);\n    \n    float sphereDist = length(p - s.xyz) - s.w;\n    \n    vec3 b = vec3(1., 1, 1);\n    vec3 c = vec3(sin(time + 3. * PI / 2.) + 3., -3.2 + mod(time + PI, 2. * PI), 4.5 + mod(time + PI, 2. * PI));\n    vec3 q = abs(p - c) - b;\n    float cubeDist = length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n    \n    vec3 b1 = vec3(1., 1, 1);\n    vec3 c1 = vec3(sin(time + PI / 2.) + 3., -3.2 + mod(time, 2. * PI), 4.5 + mod(time, 2. * PI));\n    vec3 q1 = abs(p - c1) - b1;\n    float cubeDist1 = length(max(q1, 0.0)) + min(max(q1.x, max(q1.y,q1.z)), 0.0);\n\n    vec3 b2 = vec3(1, 1000, 1000);\n    vec3 c2 = vec3(4, 2, 7);\n    vec3 q2 = abs(p - c2) - b2;\n    float wallDist = length(max(q2, 0.0)) + min(max(q2.x, max(q2.y,q2.z)), 0.0);\n    \n    float minDist = sphereDist;\n    body = BALL;\n    \n    if (cubeDist < minDist)\n    {\n        minDist = cubeDist;\n        body = BOX1;\n    }\n    if (cubeDist1 < minDist)\n    {\n        minDist = cubeDist1;\n        body = BOX2;\n    }\n    if (wallDist < minDist)\n    {\n        minDist = wallDist;\n        body = WALL;\n    }\n        \n    return minDist;\n}\n\nvec3 getNormal(vec3 p) \n{\n    int body;\n    float d = getDist(p, body);\n    \n    vec2 e = vec2(.01, 0); \n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy, body), \n        getDist(p - e.yxy, body), \n        getDist(p - e.yyx, body));\n        \n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int body)\n{\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p, body);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) \n            break;\n    }\n    \n    return dO;\n}\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPosition = vec3(0, 5, 6);\n    int body;\n    \n    lightPosition.xz = vec2(-2, 0);\n    \n    vec3 l = normalize(lightPosition-p);\n    vec3 n = getNormal(p);\n    \n    float diff = clamp(dot(n, l), 0., 1.);\n    \n    float d = rayMarch(p + n * SURF_DIST * 2., l, body);\n    if (d < length(lightPosition - p))\n       diff *= .1;\n    \n    return diff;\n}\n\nvec3 getBodyColor(int body)\n{\n    if (body == BALL)\n        return ((sin((iTime) * 6.) + 1.) / 8.) * vec3(.0, .6, .8);\n    else if (body == BOX1)\n        return (1. - ((sin((iTime) * 3.) + 1.) / 2.)) * step(0.5, (sin((iTime) * 3.) + 1.) / 2.) * vec3(.9, .6, .2);\n    else if (body == BOX2)\n        return (1. - ((sin((iTime + PI) * 3.) + 1.) / 2.)) * step(0.5, (sin((iTime + PI) * 3.) + 1.) / 2.) * vec3(.9, .6, .2);\n        \n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 3.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1.2, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.8));\n    \n    int body;\n    float d = rayMarch(ro, rd, body);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = getLight(p);\n    col = vec3(dif); \n    \n    if (body == WALL)\n    {\n        ro = p;\n        rd = reflect(rd, getNormal(p));\n        d = rayMarch(ro + rd * SURF_DIST * 2., rd, body);\n        \n        p = ro + rd * d;\n                        \n        col = vec3(mix(getLight(p), col.x, 0.96));\n        col *= vec3(0.8, 0.2, 0.6);\n        col = mix(getBodyColor(body), col, 0.8);\n    }\n    else\n    {\n        col += getBodyColor(body);    \n    }\n        \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}