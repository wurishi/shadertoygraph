{"ver":"0.1","info":{"id":"Mc2cR1","date":"1721979536","viewed":133,"name":"Wire World","username":"Aurcereal","description":"wire worldd","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","colorful","tube"],"hasliked":0,"parentid":"lc2cR1","parentname":"Base Raymarch V2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define D2R .0174533\n#define R2D 57.29578\n\n#define MAXSTEPS 200\n#define MAXDIST 100.0\n#define SDEPS 0.0005\n#define NORMEPS 0.005\n\n#define DEBUG 1\n\nvec3 camPos;\n\n// From https://iquilezles.org/articles/palettes/\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 pal1(float t)\n{\n    return pal( t*.5+iTime*.3, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n}\n\nvec3 currGlowColor;\nvec3 marchedGlow;\n\nfloat sdSphereCuts(vec3 lp, float sphereScaleMult, float cylinderRadius, float zRep, float polarPartSize, float polarOff) {\n    float sphereSize = sphereScaleMult*smoothstep(cylinderRadius*.5, cylinderRadius, length(lp.xy));\n    vec3 sp = lp;\n    sp.z = mod(sp.z+zRep*.5, zRep) - zRep*.5;\n    vec2 spolar = toPolar(sp.xy);\n    spolar.y = mod(spolar.y + polarPartSize*.5+polarOff, polarPartSize) - polarPartSize*.5;\n    sp.xy = toCartesian(spolar);\n    sp.x -= cylinderRadius;\n    float sphere = sdCylinder(sp, vec2(sphereSize, cylinderRadius*.5), vec3(1.,0.,0.));//length(sp) - sphereSize;\n    return sphere;\n}\n\nfloat sdCylinderAdd(vec3 lp, float sphereScaleMult, float cylinderRadius, float zRep, float polarPartSize, float polarOff) {\n    float sphereSize = sphereScaleMult*smoothstep(cylinderRadius*.5, cylinderRadius, length(lp.xy));\n    vec3 sp = lp;\n    sp.z = mod(sp.z+zRep*.5, zRep) - zRep*.5;\n    vec2 spolar = toPolar(sp.xy);\n    spolar.y = mod(spolar.y + polarPartSize*.5+polarOff, polarPartSize) - polarPartSize*.5;\n    sp.xy = toCartesian(spolar);\n    sp.x -= cylinderRadius;\n    float cylinder = sdCylinder(sp, vec2(sphereSize, cylinderRadius*.5), vec3(1.,0.,0.));//length(sp) - sphereSize;\n    cylinder = max(cylinder, -sdCylinder(sp-vec3(cylinderRadius*.25,0.,0.), vec2(sphereSize*.7, cylinderRadius*.15), vec3(1.,0.,0.)));\n    // have small cuts around the cylinder top outline and a little small cut inside\n    \n    vec3 zp = sp;\n    float rep = 0.03;\n    zp = mod(zp+rep*.5, rep)-rep*.5;\n    float cut = length(zp) - rep*.3*smoothstep(cylinderRadius*.5, cylinderRadius*.4, length(sp.yz));;\n    cylinder = max(cylinder, -cut);\n    \n    return cylinder;\n}\n\nfloat vignette(vec2 p) {\n    p = abs(p);\n    p = vec2(iResolution.x/iResolution.y, 1.) - p;\n    float dist = min(p.x, p.y);\n    float vig = .2*smoothstep(0.3, 0., dist);\n    return 1.-vig;\n}\n\nfloat sdTubes(vec3 p)\n{\n\n    //\n    float repSize = 1.;\n    float sphereScaleMult = .04;\n    float zRep = .15;\n    float cylinderRadius = .2;\n\n    p = rot(p, vec3(0.,0.,1.), PI*.25+p.z*.2);\n    //p.xy += vec2(sin(p.z*0.4+100.), cos(p.z*0.5+232.1)); // layer more longer period or shifted period\n    //p.xy += vec2(sin(p.z*0.2-41.32), cos(p.z*0.23+421.4));\n    p.xy *= mix(1., 0.5, smoothstep(2., 8., p.z-camPos.z));\n    vec3 lp = p;\n    lp.xy = mod(lp.xy+0.*repSize*.5,repSize) - repSize*.5;\n    vec2 id = p.xy-lp.xy;\n    //cylinderRadius *= 1.-.4*smoothstep(1., 2., length(id));\n    \n    //\n    //lp.xy *= 1.-fsin(lp.z)*.4;\n    lp.xy *= 1.-fsin(iTime)*.4*smoothstep(2., 8., p.z-camPos.z); //.1\n    float cylinder = sdCylinder(lp, vec2(cylinderRadius, 30000.), vec3(0.,0.,1.));\n    \n    float sphere = sdSphereCuts(lp, sphereScaleMult, cylinderRadius, zRep, PI/6.,0.);\n    sphere = min(sphere, sdSphereCuts(lp+vec3(0.,0.,zRep*.5), sphereScaleMult*.5, cylinderRadius, zRep, PI/12.,0.));\n    \n    //zRep *= 0.7;\n    float addSolid = MAXDIST;//sdCylinderAdd(lp, sphereScaleMult*2.7*.5, cylinderRadius, zRep*3., PI/4.,PI*.25);\n    addSolid = min(addSolid, sdCylinderAdd(lp, sphereScaleMult*2.7, cylinderRadius, zRep*3., PI/2.,PI*.25+PI*.25*(mod(lp.z+zRep*1.5*1., zRep*6.)-mod(lp.z+zRep*1.5*1., zRep*3.))/(zRep*3.)));\n    \n    vec3 rp = lp;\n    rp.xy = toPolar(rp.xy);\n    rp.y = mod(rp.y+PI*.125, PI*.25) - PI*.125;\n    rp.xy = toCartesian(rp.xy);\n    rp.x -= cylinderRadius*.92;\n    float rail = sdCylinder(rp, vec2(cylinderRadius*.2, 300.), vec3(0.,0.,1.));\n    //addSolid = min(addSolid, rail);\n    \n    //\n    float final = min(max(cylinder, -sphere), addSolid);\n    \n    //\n    currGlowColor = pal1(p.z*0.2) * min(1., .001/pow(cylinder, 2.));\n    \n    return final;\n}\n\n// blue blob glow\nfloat sdBlueRing(vec3 p)\n{\n    return 1.;\n}\n\nfloat sdf(vec3 p) {\n    float sd = sdTubes(p);\n    \n    //\n    marchedGlow += currGlowColor*sd;\n    return sd;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(NORMEPS, 0.0);\n\n    return normalize(\n        vec3(sdf(p + e.xyy) - sdf(p - e.xyy),\n             sdf(p + e.yxy) - sdf(p - e.yxy),\n             sdf(p + e.yyx) - sdf(p - e.yyx)\n             ));\n             \n}\n\nfloat trace(vec3 ro, vec3 rd, out int steps)\n{\n    float d = 0.0, sd;\n    steps = 0;\n    \n    for(int i=0; i<MAXSTEPS; i++)\n    {\n        sd = sdf(ro+rd*d);\n        d += sd;\n        steps++;\n    \n        if(abs(sd) < SDEPS || d >= MAXDIST) {return d;}\n    }\n    return MAXDIST;\n}\n\nvec3 sampleSkybox(vec3 rd)\n{\n    return vec3(0.);// acos(-rd.y) * vec3(.2, .1, .4);\n}\n\nvec3 shade(vec3 camPos, vec3 rd, vec3 hitP, vec3 norm, float dist, float alongCamDist, float steps) \n{\n    vec3 skybox = sampleSkybox(rd);\n    if(dist >= MAXDIST) return skybox+marchedGlow;\n    \n    //\n    vec3 lightDir = normalize(vec3(0., -1., -1.));\n    \n    //\n    float diffuse = max(0., dot(norm, -lightDir));\n    //diffuse = floor(diffuse*8.)/8.;\n    vec3 diffuseCont = diffuse*pal1(hitP.z*.2);//vec3(0.843,0.843,0.843)*2.;\n    \n    //\n    float specular = max(0., dot(reflect(rd, norm), -lightDir));\n    specular = pow(specular, 32.);\n    //specular = floor(specular*8.)/8.;\n    vec3 specularCont = specular*vec3(0.8);\n    \n    //\n    vec3 ambientCont = vec3(0.04);\n    \n    //\n    float AO = 1.-min(1.,steps/128.);\n    \n    //\n    float fog = min(1., exp(-0.1*(alongCamDist - 20.)));\n    \n    //\n    vec3 solidCol = diffuseCont * 0.4 + specularCont*.5 + ambientCont;\n        \n    //\n    //return norm*0.5+0.5;\n    return mix(skybox, solidCol, AO*fog)+marchedGlow;\n}\n\nvec3 render(vec2 fragCoord)\n{\n    \n    // Cam Specs\n    float theta = PI*.5;\n    float phi = 0.;\n    \n    vec3 fo = vec3(cos(phi) * cos(theta), sin(phi), cos(phi) * sin(theta)), up = vec3(0.0, 1.0, 0.0);\n    vec3 ri = normalize(cross(up, fo));\n    up = cross(fo, ri);\n    \n    float fovMultX = 1.0, fovMultY = .57735;                                           //HARDCODE fov TRIG\n    camPos = vec3(0.0, 0.1, -5.+iTime);                                                //HARDCODE cam pos\n    \n    \n    // Create World Space Ray\n    vec3 ray = normalize(vec3(((fragCoord/iResolution.xy)*2.0-1.0) * vec2(fovMultX, fovMultY), 1.0));\n    ray = ray.z * fo + ray.y * up + ray.x * ri;\n    \n    // Screen Space Pos\n    vec2 sp = ((fragCoord/iResolution.xy)*2.-1.)*vec2(iResolution.x/iResolution.y, 1.);\n    \n    // Trace\n    int steps;\n    float dist = trace(camPos, ray, steps);\n    \n    // Shade\n    return cpow(shade(camPos, ray, camPos+ray*dist, normal(camPos+ray*dist), dist, dot(ray*dist, fo), float(steps)), 0.8)\n        * vignette(sp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(render(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define TAU 6.283\n\n// Math\nvec2 toPolar(vec2 cartesian) {\n    return vec2(length(cartesian), mod(atan(cartesian.y, cartesian.x), TAU));\n}\n\nvec2 toCartesian(vec2 polar) {\n    return polar.x * vec2(cos(polar.y), sin(polar.y));\n}\n\nfloat fsin(float x) {\n    return sin(x)*.5+.5;\n}\n\nvec3 cpow(vec3 c, float a) {\n    return vec3(pow(c.x, a), pow(c.y, a), pow(c.z, a));\n}\n\n// Distortion\nvec3 rot(vec3 v, vec3 a, float o) {\n    vec3 along = a * dot(v, a);\n    vec3 against = v - along;\n    \n    vec3 up = normalize(cross(against, along)) * sign(dot(v,a));\n    vec3 ri = normalize(against);\n    \n    return  length(against) * (cos(o) * ri + sin(o) * up) + along;\n}\n\n// SDFs\n\nfloat sdBox(vec3 p, vec3 dim) {\n    vec3 dist = abs(p) - dim*.5;\n    float s = sqrt(max(dist.x,0.)*dist.x + max(dist.y,0.)*dist.y + max(dist.z,0.)*dist.z);\n    return step(s, 0.)*max(max(dist.x, dist.y),dist.z) + s;\n}\n\nfloat sdCylinder(vec3 p, vec2 dim, vec3 fo) {\n    float along = dot(p, fo);\n    float against = length(p - along*fo);\n    \n    vec2 sp = vec2(against, along);\n    sp = abs(sp) - vec2(dim.x, dim.y*.5);\n    float s = sqrt(sp.x*max(sp.x,0.) + sp.y*max(sp.y,0.));\n    return step(s, 0.) * max(sp.x, sp.y) + s;\n}\n\nfloat sdCylinder(vec3 p, vec2 dim) {\n    return sdCylinder(p, dim, vec3(0.,1.,0.));\n}\n\n\n// Hashes (https://www.shadertoy.com/view/4djSRW)\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash21(vec2 p)\n{\n    p += 0.001;\n    p -= mod(p, 0.01);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31flr(vec3 p3)\n{\n    p3 = p3 - mod(p3, .1);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}","name":"Common","description":"","type":"common"}]}