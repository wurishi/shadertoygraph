{"ver":"0.1","info":{"id":"ddccWH","date":"1695051931","viewed":51,"name":"Sinkhorn Entropic OT","username":"chronos","description":"Sinkhorn’s Algorithm for Entropic Optimal Transport:\nhttps://arxiv.org/pdf/1306.0895.pdf","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["visualization","distance","1d","algorithm","transport","probability","optimal","distributions","wasserstein","sinkhorn","entropic"],"hasliked":0,"parentid":"ddcyD8","parentname":"Approximate Optimal Transport"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Sinkhorn’s Algorithm for Entropic Optimal Transport:\n    \n    Based on the paper \n    \n    Sinkhorn Distances: Lightspeed Computation of Optimal Transport\n      By Marco Cuturi\n\n    https://arxiv.org/pdf/1306.0895.pdf\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    color = texelFetch(iChannel0, ivec2(fragCoord.xy)/4, 0).rgb;\n\n    // if inside transport map square\n    if(fragCoord.x < 400. && fragCoord.y < 400.)\n    {\n        // Only show the resulting transport map values\n        color = color.rrr * 200.;\n    }\n\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n Computing the Wasserstein Distance (or Wasserstein Metric)\n \n Consider two (1D in this case) distributions: C, R\n \n The transport plan (or coupling) T, is a (2D) distribution\n which minimizes the total transport cost, M\n \n Here, the transport cost is simply the Euclidean distance squared\n\n The distributions C and R integrate to 1\n The transport plan T will have marginals C and R\n \n*/\n\n/*\nSinkhorn Algorithm for Entropic Optimal Transport\n\nInput:\ncost matrix: M\nregularization parameter: lambda\nmarginals: r and c\n\nNote: in the paper r is the row sum of P and c is the column sum of P\ni.e\nmatmul(P, ones) = r\nmatmul(transpose(P), ones) = c\n\nAlgo Init:\nK = exp(-lambda M)\nu = 1 / len(r)\n\nwhile true\n    Ku = K^T[j] u       // col j of the matrix dotted with u\n    Kv = K[i] v         // row i of the matrix dotted with v\n\tv[j] = c[j] / Ku\n\tu[i] = r[i] / Kv\nendwhile\n\nresult = diag(u) K diag(v)\n\nresult[i][j] = u[i] K[i][j] v[j]\n\n*/\n\nconst float size = 100.;\n\nfloat i_from_y(float y) { return (size - 1.) - y; }\n\nfloat y_from_i(float i) { return (size - 1.) - i; }\n\n// get Transport Plan\nfloat getT(float i, float j)\n{\n    float x = j;\n    float y = y_from_i(i);\n    return texelFetch(iChannel0, ivec2(x, y), 0).r;\n}\n\nfloat getu(float k)\n{\n    float x = k;\n    float y = y_from_i(k);\n    return texelFetch(iChannel0, ivec2(x, y), 0).g;\n}\n\nfloat getv(float k)\n{\n    float x = k;\n    float y = y_from_i(k);\n    return texelFetch(iChannel0, ivec2(x, y), 0).b;\n}\n\n// C as column vector\nfloat getC(float i)\n{\n    const int col = 512+256;\n    float weight = 0.;\n    for(float k = 0.; k < size; k++) { weight += texelFetch(iChannel1, ivec2(k, col),0).r; }\n    return texelFetch(iChannel1, ivec2(i, col),0).r / weight;\n}\n\n// R as column vector\nfloat getR(float i)\n{\n    const int col = 256;\n    float weight = 0.;\n    for(float k = 0.; k < size; k++) { weight += texelFetch(iChannel1, ivec2(k, col),0).b; }\n    return texelFetch(iChannel1, ivec2(i, col),0).b / weight;\n}\n\nfloat cost(float i, float j)\n{\n    return pow(abs(i - j)/size, 2.); // Seems that using the distance squared is important\n}\n\nfloat getK(float i, float j)\n{\n    float lambda = 400.;\n    float M = cost(i, j);\n    float K = exp(-lambda * M);\n    return K;\n}\n\nconst float PI = 3.14159;\nfloat gaussian(float mean, float std, float x)\n{\n    return (1./ (std * sqrt(2. * PI))) * exp(-0.5 * pow((x-mean) / std, 2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = floor(fragCoord.x);\n    float y = floor(fragCoord.y);\n    \n    float j = x;\n    float i = i_from_y(y);\n    \n    float Transport = 0.;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    // inside square\n    if(x < size && y < size)\n    {\n        // init\n        float K = getK(i, j);\n        float u, v;\n        u = 1. / size;\n        v = 1. / size;\n        \n        Transport = (K * u) * v;\n        \n        if(iFrame > 0) // Begin iterating when iFrame % 3 == 1\n        {\n            Transport = getT(i,j);\n            \n            /*\n                Ku = K^T[j] u       // col j of the matrix dotted with u\n                Kv = K[i] v         // row i of the matrix dotted with v\n                v[j] = c[j] / Ku\n                u[i] = r[i] / Kv\n                ---------------------------------------\n                u = r / (K v)\n                v = c / (K^T u)\n            */\n            \n            // Alternate each frame solving for u and v\n            if(iFrame % 3 == 0)\n            {\n                // for v_j\n                float Ku = 0.;\n                for(float k = 0.; k < size; k++)\n                {\n                    Ku += getK(k, i) * getu(k);\n                }\n                v = getC(i) / Ku;\n                u = getu(i);\n            }\n            else if (iFrame % 3 == 1)\n            {\n                // for u_i\n                float Kv = 0.;\n                for(float k = 0.; k < size; k++)\n                {\n                    Kv += getK(i, k) * getv(k);\n                }\n                u = getR(i) / Kv;\n                v = getv(i);\n            }\n            else // if (iFrame % 3 == 2)\n            {\n                u = getu(i);\n                v = getv(j);\n                \n                // P = u_i exp(-lambda M_ij) v_j\n                Transport = (K * u) * v ;\n            }\n        }\n        \n        fragColor = vec4(vec3(Transport, u , v), 1.0);\n    }\n    \n    float C = 25. * getC(j);\n    float R = 25. * getR(i);\n        \n    // top\n    if(x < size && y >= size)\n    {\n        fragColor.rgb += smoothstep(0.011, 0.010, abs((y - size)/size - C));\n        fragColor.rgb += 0.25*smoothstep(0.011, 0.010, (y - size)/size - C);\n        \n        // Compute transported mass via column j\n        float mass = 0.;\n        for(float k = 0.; k < size; k++)\n        {\n            mass += getT(k, j);\n        }\n        mass *= 25.;\n        \n        fragColor.rgb += vec3(0,1,0) * .5 * smoothstep(0.011, 0.010, abs((y - size)/size - mass));\n        fragColor.rgb += vec3(0,1,0) * 0.125*smoothstep(0.011, 0.010, (y - size)/size - mass);\n    }\n    \n    // right side \n    if(x >= size && y < size)\n    {\n        fragColor.rgb += smoothstep(0.011, 0.010, abs((x - size)/size - R));\n        fragColor.rgb += 0.25*smoothstep(0.011, 0.010, (x - size)/size - R);\n        \n        // Compute transported mass via row i\n        float mass = 0.;\n        for(float k = 0.; k < size; k++)\n        {\n            mass += getT(i, k);\n        }\n        mass *= 25.;\n\n        fragColor.rgb += vec3(1,0,0) * .5 * smoothstep(0.011, 0.010, abs((x - size)/size - mass));\n        fragColor.rgb += vec3(1,0,0) * 0.125*smoothstep(0.011, 0.010, (x - size)/size - mass);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}