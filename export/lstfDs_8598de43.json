{"ver":"0.1","info":{"id":"lstfDs","date":"1527566292","viewed":286,"name":"Roots Fractal","username":"rory618","description":"roots of polynomials with coefficients 1 or -1\nCurrent approach is to find closest root to pixel with newtons method. Drag mouse and press W to zoom.\n\nRef: https://crd.lbl.gov/assets/Images/Organization/AMCS/ANAG/Ligocki/Density-11.gif","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["complex","greyscale","polynomials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Euclid's orchard\" by rory618. https://shadertoy.com/view/4tVGR1\n// 2018-05-26 06:21:53\n\nconst vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    \n    fragColor = .5+sin(log(abs(texture(iChannel1, uv))))*.5;//textureLod(iChannel1,vec2(.5),100.)/1.;\n    \n   // fragColor = exp(fragColor)/(1.+exp(fragColor));\n    \n    vec2 nup = mouse.xy - mouse.zw;\n    vec2 nright = vec2(nup.y, -nup.x) * iResolution.x / iResolution.y;\n    \n\t\n    \n    vec2 o = (fragCoord - mouse.zw);\n    \n    float z = max(0.0, min(1.0, 1.0-\n    min(\n    \tmin(\n        \tabs( dot(o, nup)/length( nup) - length( nup)) , \n            abs( dot(o,-nup)/length(-nup) - length(-nup)) \n        ), min(\n            abs( dot(o, nright)/length( nright) - length( nright)) ,\n         \tabs( dot(o,-nright)/length(-nright) - length(-nright)) \n        )\n    )));\n    \n    if(iMouse.z>.1 && mouse.z != 0.0)\n        fragColor += z;//*fragColor + (z);\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nfloat smoothing = 100.0;\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n\nbool keyIsDown( float key ) {\n    return texture( iChannel2, vec2(key,0.25) ).x > .5;\n}\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n\nvec3 color(float z){\n    return vec3(\n    \t.5+.5*sin(sqrt(z)*4.14),\n    \t.5+.5*sin(sqrt(z)*4.25),\n    \t.5+.5*sin(sqrt(z)*4.36)\n    );\n}\n\nvec2 evalPoly(vec2 x, int c){\n    c = c * 887923;\n    vec2 t = x;\n    vec2 s = vec2(0,0);\n    for(int i = 0; i < 16; i++){\n        s += t * (float(c-(c/2)*2)*2.-1.);\n        c = c / 2;\n        t=t*mat2(x, -x.y, x.x);\n    }\n    return s;\n}\n\nvec2 evalDeriv(vec2 x, int c){\n    c = c * 887923;\n    vec2 t = x;\n    \n    vec2 s = vec2(0,0);\n    for(int i = 0; i < 16; i++){\n        s += cdivide(t,x) * (float(c-(c/2)*2)*2.-1.) * float(i + 1);\n        c = c / 2;\n        t=t*mat2(x, -x.y, x.x);\n    }\n    return s;\n}\n\nvec4 image(vec2 p, float s) {\n    vec2 x = p;\n    float f = 0.;\n    for(int h = 0; h < 16;h++){\n        vec2 z = evalPoly(p,h+iFrame*16);\n        vec2 e = p - cdivide(z,evalDeriv(p,h+iFrame*16));\n        for(int i = 0; i < 20; i++){\n        \te = e - cdivide(evalPoly(e,h+iFrame*16),evalDeriv(e,h+iFrame*16));\n            //if(length(evalPoly(p,h+iFrame*16))<.1 && length(e-p)<.01)\n            \tf += max(0.,(s - length(e-p))/s*.01);\n            //basically draw a smudge at every point along the newtons method solver trajectory.\n\t\t\t//Of course it draws more than just the roots but seems like the best bet for drawing as much of\n            //the structure of the roots as possible.\n            \n        }\n        \n        //if(length(evalPoly(e,h+iFrame*16)) < 1e-3)\n        \t//f += 1e-2/(pow(length(e-p),length(e-p))+.1)/(length(evalPoly(e,h+iFrame*16))+.1);// max(f,1.);\n    }\n    return vec4(f*16.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = (fragCoord.xy - vec2(.5) + hash23(vec3(fragCoord, iTime))) / iResolution.xy;\n    \n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    if ( keyIsDown(KEY_R) || keyIsDown(KEY_W) || iFrame <= 1) {\n        fragColor = image(p,length(up)/50.)+1.;\n    } else {\n    \tfragColor = (texture(iChannel1, fragCoord / iResolution.xy)+image(p,length(up)/50.));\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n        \n    if (iMouse.z < 0.1) {\n        mouse.zw = -iMouse.xy;\n    } else if(mouse.z < 0.0) {\n        mouse.zw = iMouse.xy;\n    }\n    \n    mouse.xy = iMouse.xy;\n    if (iMouse.z > 0.1 && mouse.z != 0.0) {\n    \tif ( keyIsDown(KEY_W) && mouse.xy != mouse.zw ) {\n        \tvec2 ncenter = uvtoc(center, up, right, (mouse.zw / iResolution.xy - vec2(.5))*2.0);\n            vec2 nup = uvtoc(center, up, right, (mouse.xy / iResolution.xy - vec2(.5))*2.0) - ncenter;\n            center = ncenter;\n            up = nup;\n            mouse.z = 0.0;\n    \t}\n    }\n    \n    viewport = vec4(center, up);\n    \n    if ( keyIsDown(KEY_R) || iFrame <= 1) {\n        viewport = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    fragColor = vec4(0);\n    \n    fragColor += save(viewport,viewportLoc,fragCoord);\n    fragColor += save(mouse,mouseLoc,fragCoord);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nvec2 conj(vec2 z) {\n    return vec2(z.x,-z.y);\n}\nvec2 cprod(vec2 a, vec2 b){\n    return mat2(a,-a.y,a.x) * b;\n}\nvec2 csqr(vec2 a){\n    return cprod(a,a);\n}\nfloat cabs(vec2 z) {\n    return length(z);\n}\nfloat cabs2(vec2 z) {\n    return dot(z,z);\n}\nvec2 cinv(vec2 z){\n    return conj(z)/cabs2(z);\n}\nvec2 cdivide(vec2 a, vec2 b){\n    return cprod(a,cinv(b));\n}","name":"Common","description":"","type":"common"}]}