{"ver":"0.1","info":{"id":"XXSXDd","date":"1711204540","viewed":152,"name":"AnimatedHumanShader","username":"BrunoLevy","description":"Added animation to iq's human shader for FPGA folks so that we see something moving","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original version here: https://www.shadertoy.com/view/XflXDs\n// Binary version of the Human Shader at\n// https://www.shadertoy.com/view/Dtf3Dl\n// \n//\n// The original Human Shader was designed\n// with decimal fixed point, for humans to\n// compute. This version uses binary fixed\n// point instead for computers.\n//\n// Bruno: added bouncing animation\n// (confession: I do not understand what I'm doing...)\n\n\nvec3 compute( int x, int y )\n{\n    int R, B;\n\n    //-------------------------    \n    // Section A (2 MUL, 3 ADD)\n    //-------------------------    \n    \n    int v0 = int((1.0+sin(iTime*4.0))*4.0);\n\n    \n    int u = x-36;\n    int v = 18-y;\n    int u2 = u*u;\n    int v2 = (v-v0)*(v-v0);\n    int h = u2 + v2;\n    //-------------------------  \n    \n    if( h < 200 ) \n    {\n        //-------------------------------------\n        // Section B, Sphere (4/7 MUL, 5/9 ADD)\n        //-------------------------------------\n        R = 420;\n        B = 520;\n\n\n        int t = 5200 + h*8;\n        int p = (t*u)>>7;\n        int q = (t*(v - v0))>>7;\n        \n        // bounce light\n        int w = 18 + (((p*5-q*13))>>9);\n        if( w>0 ) R += w*w;\n        \n        // sky light / ambient occlusion\n        int o = q + 900;\n        R = (R*o)>>12;\n        B = (B*o)>>12;\n\n        // sun/key light\n        if( p > -q )\n        {\n            int w = (p+q)>>3;\n            R += w;\n            B += w;\n        }\n        //-------------------------  \n\t}\n    else if( v<0 )\n    {\n        //-------------------------------------\n        // Section C, Ground (5/9 MUL, 6/9 ADD)\n        //-------------------------------------\n        R = 150 + 2*v;\n        B = 50;\n        \n        int p = h + 8*v2;\n        int c = 240*(-v)+200*v0 - p;\n\n        // sky light / ambient occlusion\n        if( c>1200 )\n        {\n            int o = (25*c)>>3;\n            o = (c*(7840-o)>>9) - 8560;\n            R = (R*o)>>10;\n            B = (B*o)>>10;\n        }\n\n        // sun/key light with soft shadow\n        int r = c + u*v;\n        int d = 3200 - h - 2*r;\n        if( d>0 ) R += d;\n        //-------------------------  \n    }\n    else\n    {\n        //------------------------------\n        // Section D, Sky (1 MUL, 2 ADD)\n        //------------------------------\n        int c = x + 4*y;\n        R = 132 + c;\n        B = 192 + c;\n        //-------------------------  \n    }\n    \n    //-------------------------\n    // Section E (3 MUL, 1 ADD)\n    //-------------------------\n    R = min(R,255);\n    B = min(B,255);\n    \n    int G = (R*11 + 5*B)>>4;\n    //-------------------------  \n\n    return vec3(R,G,B);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 resolution = vec2(71,40);\n\n    ivec2 ij = ivec2(floor(resolution*fragCoord/iResolution.xy));\n    \n    vec3 col = compute( ij.x, 39-ij.y );\n    \n    // draw grid lines\n    {\n    ivec2 ijp = ivec2(floor(resolution*(fragCoord-vec2(1,1))/iResolution.xy));\n    ivec2 ijn = ivec2(floor(resolution*(fragCoord+vec2(1,1))/iResolution.xy));\n    if( ijn.x!=ij.x || ijn.y!=ij.y || ijp.x!=ij.x || ijp.y!=ij.y) col*=0.75;\n    }\n    \n    fragColor = vec4( col/255.0, 1.0 );\n}","name":"Image","description":"","type":"image"}]}