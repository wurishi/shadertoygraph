{"ver":"0.1","info":{"id":"3sdSzr","date":"1571350516","viewed":547,"name":"Chocolate and orange","username":"skaplun","description":"Found this one on Pinterest, couldn't find the author\nEnable AA for better quality.\nUse value noise instead of simplex for better performance \nMany of code snippets taker here on Shadertoy. Most of them are originally made by @iq","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["noise","simplex","animation","layer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-5\n\nconst vec3 ORANGE = vec3(158., 64., 1.)/255.;\nconst vec3 GRAY = vec3(15.)/255.;\n\nfloat noise(in vec3 x){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec4 map(vec3 p){\n    float noiseVal = simplex_noise(vec3(p.xz, iTime * .1)) * .5 + .5;\n    if (p.y > .25){\n        return vec4(opSubtraction(.3 - p.y, noiseVal - (.2 - smoothstep(.285, .3, p.y) * .01)), GRAY);\n    }\n    if (p.y > .2){\n        return vec4(opSubtraction(.25 - p.y, noiseVal - (.3 - smoothstep(.235, .25, p.y) * .01)), GRAY);\n    }\n    if (p.y > .15){\n        return vec4(opSubtraction(.2 - p.y, noiseVal - (.4 - smoothstep(.185, .2, p.y) * .01)), GRAY);\n    }\n    if (p.y > .1)\n        return vec4(opSubtraction(.15 - p.y, noiseVal - (.5 - smoothstep(.135, .15, p.y) * .01)), GRAY);\n    if (p.y > .05)\n        return vec4(opSubtraction(.1 - p.y, noiseVal - (.6 - smoothstep(.085, .1, p.y) * .01)), ORANGE);\n    \n    return vec4(0., GRAY);\n}\n\nconst float epsilon = 0.01;\nvec3 calculateNormals(vec3 pos){\n    /*\n    vec2 eps = vec2(0.0, epsilon);\n    vec3 n = normalize(vec3(\n    map(pos + eps.yxx).x - map(pos - eps.yxx).x,\n    map(pos + eps.xyx).x - map(pos - eps.xyx).x,\n    map(pos + eps.xxy).x - map(pos - eps.xxy).x));\n    return n;\n\t*/\n\t\n    // by @iq\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n\t\n}\n\n//by @iq\nconst float maxHei = 1.;\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<12; i++){\n        float h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//by @iq\nfloat calcAO( in vec3 pos, in vec3 nor ){\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nconst int stepsCnt = 50;\nvec3 clrInside(in float minD, in float maxD, in Ray r){\n    float stepSize = (maxD - minD)/float(stepsCnt);\n    vec3 color = vec3(0.);\n    float t = minD + MIN_FLOAT;\n    for(int i = 0; i <= stepsCnt; i++){\n        vec3 p = r.origin + r.dir * t;\n        vec4 dst = map(p);\n        \n        if(dst.x < stepSize*.5){\n            vec3 nor = calculateNormals(p);\n            vec3 ref = reflect( r.dir, nor );\n            // lighting\n            float occ = calcAO( p, nor );\n            vec3  lig = normalize( vec3(-3.5, 1.4, -1.6) );\n            vec3  hal = normalize( lig-r.dir );\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n            float dom = smoothstep( -.1, 0.4, ref.y );\n            float fre = pow( clamp(1.0+dot(nor,r.dir),0.0,1.0), 2.0 );\n\n            dif *= calcSoftshadow( p, lig, 0.02, 2.5 );\n            dom *= calcSoftshadow( p, ref, 0.02, 2.5 );\n\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 16.0)*\n                        dif * (.1 + .96*pow( clamp(1.0+dot(hal,r.dir),0.0,1.0), 5.0 ));\n\n            vec3 lin = vec3(0.0);\n            lin += 3.80*dif*vec3(1.30,1.00,0.70);\n            lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n            lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n            lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n            lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n            vec3 col = dst.yzw * lin;\n            col += 7.00*spe*vec3(1.10,0.90,0.70);\n\n            col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n            return clamp(col, 0., 1.);\n        }\n        \n        t += stepSize;\n        if(t >= maxD)\n            break;\n    }\n    return color;\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.y - iMouse.y) * .01 / 3.1415;\n    vec3 origin = vec3(0., 3. * cos(ang), 3. * sin(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray camRay = Ray(origin, dir);\n    \n    float minDst, maxDst;\n    plane_hit(camRay, Plane(vec3(0., .5, 0.), vec3(0., -1., 0.)), minDst);\n    plane_hit(camRay, Plane(vec3(0.), vec3(0., -1., 0.)), maxDst);\n    return clrInside(minDst, maxDst, camRay);\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Box{ vec3 origin; vec3 bounds;};\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{vec2 dist;vec3 ptnt[2];};\nstruct Plane{ vec3 origin; vec3 normal;};\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nbool plane_hit(in Ray inray, in Plane plane, out float dst) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        dst = dot(p0l0, plane.normal) / denom;\n        return true;\n    }\n    return false;\n}\n\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}","name":"Common","description":"","type":"common"}]}