{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//#define SHADOWS\n#define PI 3.14159\n\n\nfloat sdPlane( vec3 p )\n{\n   return p.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n   return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p, float a )\n{\n    float  c = cos(a*p.y+a);\n    float  s = sin(a*p.y+a);\n    mat2   m = mat2(c,-s,s,c);\n\treturn vec3(m*p.xz,p.y);\n}\n\nmat3 makeRotateX(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(1.0, c, -s,\n              0.0,  s, c,\n              0.0, 0.0, 1.0);\n}\nmat3 makeRotateY(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(c,    0.0, s,\n              0.0,  1.0, 0.0,\n              -s,   0.0, c);\n}\nmat3 makeRotateZ(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(c, -s, 0.0,\n              s,  c, 0.0,\n              0.0, 0.0, 1.0);\n}\n\n//----------------------------------------------------------------------\n\nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\n\tfloat angle = atan( vPos.x, vPos.z );\n\t\n\tfloat fScale = fSteps / (PI * 2.0);\n\tfloat steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\t\n\tfloat s = sin(-steppedAngle);\n\tfloat c = cos(-steppedAngle);\n\t\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, \n\t\t\t     vPos.y,\n\t\t\t     -s * vPos.x + c * vPos.z);\n\t\n\treturn vResult;\n}\n\n\n\nfloat gear(vec3 pos, float inner_diamenter, float outer_diameter, float width, int numTeeth, float toothDepth, float spinAngle)\n{\n  width *= 0.5;\n  pos = makeRotateZ(0.5*PI)*pos;\n  pos = makeRotateY(spinAngle)*pos;\n\n  float cylToothMax = sdCylinder( pos-vec3( 0.0, 0.0, 0.0), vec2(outer_diameter+0.5*toothDepth,width) ); //w h\n  float cylToothMin = sdCylinder( pos-vec3( 0.0, 0.0, 0.0), vec2(outer_diameter-0.5*toothDepth,width) ); //w h\n  float cylInner = sdCylinder( pos-vec3( 0.0, 0.0, 0.0), vec2(inner_diamenter,width+0.1*width) ); //w h\n\n  vec3 vToothDomain = DomainRotateSymmetry(pos, float(numTeeth));\n  vToothDomain.xz = abs(vToothDomain.xz);\n  // spacing, height, width ???\n  float co = outer_diameter / float(numTeeth);\n  float fGearDist = dot(vToothDomain.xz,\n  normalize(vec2(outer_diameter+co/toothDepth, 30.0*co*toothDepth))) -  2.5*outer_diameter / float(numTeeth);\n\n  //return max(cylToothMax,fGearDist);\n  return max(opS(cylToothMax,cylInner),min(cylToothMin ,fGearDist));\n}\n\nvec2 map( in vec3 pos )\n{\n  vec2 res=vec2(1000.0, 0.0);\n//  res = vec2(sdPlane(pos), 0);\n  float gy = 0.0;\n  vec3 gear1_pos = 0.1 * vec3(-3.0, -2.0+gy, 0.0);\n  vec3 gear2_pos = 0.1 * vec3(3.1, -2.0+gy, 0.0);\n  vec3 gear3_pos = 0.1 * vec3(-3.1, 4.2+gy, 0.0);\n  float gearAnim = 0.7 * iTime;\n  float twistDir = sin(-3.0*gearAnim);\n  float twistAmount = 0.5 * cos(-3.0*gearAnim);\n  float g1 = gear(opTwist(pos - gear1_pos.zyx, -twistAmount*twistDir ), 0.10, 0.4, 0.10, 20, 0.07, gearAnim);\n  float g2 = gear(opTwist(pos - gear2_pos.zyx, twistAmount*twistDir ), 0.05, 0.2, 0.20, 10, 0.07, -2.0*gearAnim-0.0*PI);\n  float g3 = gear(opTwist(pos - gear3_pos.zyx, 2.0*twistAmount*twistDir ), 0.13, 0.2, 0.05, 10, 0.07, -2.0*gearAnim+0.5*PI);\n  res = opU(res, vec2(g1, 28.0) ); //red\n  res = opU(res, vec2(g2, 5.5) ); // green\n  res = opU(res, vec2(g3, 31.5) ); //blue\n  return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n   float precis = 0.0001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<128; i++ )\n    {\n       if( abs(h)<precis||t>maxd ) break;\n       t += h;        \n       vec2 res = map( ro+rd*t );\n       h = res.x;\n       m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n\tfloat precis = 0.001;\n\tfloat t = mint;\n\tfor( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n\t\t\n        if( h<precis )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n\nvec3 calcNormal(vec3 p) {\n   vec2 e = vec2(0.0001, 0.0);\n        vec3 n = vec3( map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x ) - map(p).x;\n   return n/e.x;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n   float totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n  vec3 col = vec3(0.0);\n  vec2 res = castRay(ro,rd,10.0);\n  float t = res.x;\n  float m = res.y;\n  if( m>-0.5 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n\n    col = vec3(0.6) + 0.4*sin( vec3(1.,1.8,1.10)*(m-1.0) );\n\n    float ao = calcAO( pos, nor );\n    //float ao = 0.0;\n\n    vec3 lig = normalize( vec3(-5., 5., -10.));\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n    float sh = 1.0;\n\t#ifdef SHADOWS\n    if( dif>0.02 ) { sh = shadow( pos, lig, 0.02, 10.0); dif *= sh; }\n    #endif\n    vec3 brdf = vec3(0.0);\n    brdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n    brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n    brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n    float pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n    float spe = sh*pow(pp,16.0);\n    float fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    col = col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\n  }\n\n  col *= exp( -0.01*t*t );\n\n\n  return vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0+2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy;\n\n  // camera\n  float camFactorX = mix(0.0, mo.x, clamp(iMouse.z, 0.0, 1.0));\n  float camFactorY = mix(0.0, mo.y, clamp(iMouse.z, 0.0, 1.0));\n  float zoom = 3.2 * 0.6 - 3.2 * camFactorY + 2.5*clamp(iMouse.z, 0.0, 1.0);\n  float ang = PI*1.2 + 2.0*PI*camFactorX;\n  vec3 ro = vec3( zoom*cos(ang), 0.5, zoom*sin(ang) );\n  vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n  // camera tx\n  vec3 cw = normalize( ta-ro );\n  vec3 cp = vec3( 0.0, 1.0, 0.0 );\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n  vec3 col = render( ro, rd );\n  col = sqrt( col );\n  fragColor=vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sj3zK","date":"1390985493","viewed":834,"name":"glxgears","username":"teh_bear","description":"twisty glxgears. Gear function taken from https://www.shadertoy.com/view/Msl3Rn, raymarching from iq.\nClick & move mouse to rotate & zoom.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["gears","glxgears","gear"],"hasliked":0,"parentid":"","parentname":""}}