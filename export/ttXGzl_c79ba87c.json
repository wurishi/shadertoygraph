{"ver":"0.1","info":{"id":"ttXGzl","date":"1557334156","viewed":118,"name":"ScaredFish","username":"bignobody","description":"Implicit Surface wiki page had a surface of genus 2 equation, so I thought I would try to raymarch it. Wasn't entirely successful but I got some fun results by animating large EPSILON values... Reminds me of a fish face from SpongBob Squarepants!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","genus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// branch of my Rainbow Crocs shader: https://www.shadertoy.com/view/3d2SRD\n#define MAX_STEPS 64\n\n#define MAX_DIST 256.0\n\nfloat gyroidSDF(vec3 p , float s)\n{\n//\tfloat g = cos(p.x) * sin(p.y) + cos(p.y) * sin(p.z) + cos(p.z) * sin(p.x);\n    float g = dot(cos(p),sin(p.yzx));\t// shorthand suggested by Shane\n    return length(normalize(p) * g * s);\n}\n\nfloat genusSDF(vec3 p, vec3 q, float s)\n{\n //2y(y2-3x2)(1-z2)+(x2+y2)2 - (9z2-1)(1-z2) = 0   \n\t//float g = 2.0 * p.y * (pow(p.y,2.0)- pow(3.0 * p.x,2.0)) * (1.0-pow(p.z,2.0)) + pow(pow(p.x,2.0)+pow(p.y,2.0),2.0) - (pow(9.0*p.z,2.0)-1.0)*(1.0-pow(p.z,2.0));\n//\tfloat g = q.y * 2.0 * p.y * (pow(p.y,2.0)-  pow(q.x * 3.0 * p.x,2.0)) * (q.z * 1.0 -pow(p.z,2.0)) + pow(pow(p.x,2.0)+pow(p.y,2.0),2.0) - ( pow(q.z * 9.0 * p.z,2.0)-1.0)*(q.z-pow(p.z,2.0));\n\tfloat g = q.y * p.y * (pow(p.y,2.0)-  pow(q.x * p.x,2.0)) * (q.z-pow(p.z,2.0)) + pow(pow(p.x,2.0)+pow(p.y,2.0),2.0) - ( pow(q.z * p.z,2.0)-1.0)*(q.z-pow(p.z,2.0));\n//\tfloat g = p.y * (pow(p.y,2.0)- pow(p.x,2.0)) * (pow(p.z,2.0)) + pow(pow(p.x,2.0)+pow(p.y,2.0),2.0) - (pow(p.z,2.0)-1.0)*(1.0-pow(p.z,2.0));\n\n    return length(normalize(p) * g * s);\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n \treturn length(p)-r;   \n}\n\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphereSDF(q, 0.11);\n}\n\nfloat getInRange(float a, float b, float d)\n{\n\treturn (d-a)/(b-a);   \n}\n\nfloat remapValue(float originStart, float originEnd, float remapStart, float remapEnd, float v)\n{\n \treturn getInRange(originStart,originEnd,v) * (remapEnd-remapStart) + remapStart;   \n}\n\nfloat sceneSDF(vec3 p)\n{\n\t//float t = mod(iTime,10.0);\n    float t = iTime * 1.1;\n    float ev = remapValue(-1.0,1.0, 1.6,2.0, cos(t))+1.25;\n    \n\tmat3 rz = mat3(cos(ev), sin(ev), 0.0,\n                   -sin(ev), cos(ev), 0.0,\n                   0.0,0.0,1.0);\n    \n    vec3 q = inverse(rz) * p;\n    return genusSDF(normalize(q), vec3(3.0,2.0,9.0), 0.1);\n}\n\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist, float EPSILON )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n        // We're inside the scene surface!\n        return depth;\n    \t}\n    \t// Move along the view ray\n    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \t// Gone too far; give up\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 estimateNormal(vec3 p, float EPSILON) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 1.0;\n    float ext = iTime * 0.6;\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n  //  vec3 camOrigin = vec3(-180.0 * sin(ext),0.0,-180.0* cos(ext));\n    vec3 camOrigin = vec3(0.0,0.0,-80.0 + sin(ext));\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n\n\tfloat EPSILON = 5.9 + cos(ext);\n\n    float d = distToSurface(camOrigin,rayDirection, 0.0,MAX_DIST,EPSILON);\n\tvec3 g = estimateNormal(camOrigin + rayDirection * d,EPSILON);\n  //  d = d/length(g);\n  \tvec3 p = camOrigin + rayDirection * d;\n  \n   \t\n    if (d > MAX_DIST-EPSILON)\n    {\n     \t// no hit\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        //discard;\n        return;\n    }\n\tvec3 bc = vec3(-0.1+g.x,-0.9+g.y,1.0-g.x);\n\t//vec3 bc = vec3(-0.4+g.y,-0.3+g.x,1.0-g.x);\n    vec3 col = vec3(clamp(d,0.0,0.99))*(bc+g);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}