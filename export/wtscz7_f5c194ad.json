{"ver":"0.1","info":{"id":"wtscz7","date":"1591742979","viewed":124,"name":"SDF Raymarch","username":"keshav2010","description":"simulating diffuse lightening effect (directional light) and ambience. Light-direction is changing.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","beginner","light","diffuselight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 140\n#define MIN_DIST 0.0005\n\n\n//all items in scene defined below\n\n//Signed distance field function for sphere\nfloat signDistanceSphere(vec3 pos, vec3 sphereCenter, float s_r)\n{\n\treturn length(sphereCenter - pos) - s_r; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec4[] spheresArray =  vec4[](vec4(0., 0.5, 20, .5),\n                                  vec4(0.+ 0.5*sin(iTime)*sin(iTime), 0. , 5., 0.325+0.1*sin(iTime)),\n\t\t\t\t\t\t\t\t  vec4(1.5 , 0.5, 10.+ 5.*sin(iTime), .5),\n                                  vec4(-0.25, -32.5, 222, 35.)\n    \t\t\t\t\t\t);\n    \n    \n    vec3 ambientLightIntensity = vec3(0.025);\n    vec3 rayOrigin = vec3(1., .5, -10);\n    vec3 currentPoint = vec3(uv.x, uv.y, 0);\n    \n    vec3 lightDirection = vec3(2.5*cos(iTime),1.5*sin(iTime*0.5),-5.0f);\n    //ray direction\n    vec3 rd = normalize(currentPoint - rayOrigin);\n    \n    vec3 col = vec3(0);\n    //sphere trace each step\n    vec3 currentTracePoint = currentPoint;\n    \n    vec3 currentSphereCenter;\n    for(int i=0; i<MAX_STEP; i++) \n    {\n        float currentMinDist = 1000.;\n        int id;\n        \n    \tfor(int i=0; i<5; i++)\n        {\n            vec3 sc = vec3(spheresArray[i].x, spheresArray[i].y, spheresArray[i].z); //sphere-center\n            float sr = spheresArray[i].w;\n        \tfloat dist = signDistanceSphere(currentTracePoint, sc, sr);\n            if(dist < 0.){ //don't render\n               continue;\n            }\n            if(dist < currentMinDist) \n            {\n                currentSphereCenter = sc; //to compute surface normal(approx.) later for more well defined color\n                currentMinDist = dist;\n            }\n            \n        }\n        if(currentMinDist <= MIN_DIST)\n        {\n            vec3 surfaceNormal = normalize(currentTracePoint - currentSphereCenter);\n            \n            col=vec3(dot(normalize(surfaceNormal), normalize(lightDirection)), dot(normalize(surfaceNormal), normalize(lightDirection)), 0. );\n            col+=5.*ambientLightIntensity;\n            \n       \t\tbreak; \n        }\n   \t\t//update point \n        currentTracePoint  += rd*currentMinDist;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}