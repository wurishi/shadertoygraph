{"ver":"0.1","info":{"id":"lcffzj","date":"1724020728","viewed":33,"name":"Base Color Raymarching","username":"Luxdum","description":".","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingcolorlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Shape {\n    float dist;\n    vec3 color;\n};\n\nShape shapeMin(Shape a, Shape b) {\n    if (a.dist < b.dist)\n        return a;\n    \n    return b;\n}\n\nShape sdBox( vec3 p, vec3 b, vec3 color ) {\n  vec3 q = abs(p) - b;\n  float dist = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Shape(dist, color);\n}\n\nShape sdSphere(vec3 p, float r, vec3 color) {\n    float dist = length(p) - r;\n    return Shape(dist, color);\n}\n\nShape sdPlane(vec3 p, float h, vec3 color) {\n    float dist = p.y + h;\n    return Shape(dist, color);\n}\n\nShape map(vec3 p) {\n    Shape sphere = sdBox(p, vec3(1.), vec3(1., 0., 0.));\n    Shape plane = sdPlane(p, 2., vec3(1., 1., 1.));\n    \n    return shapeMin(sphere, plane);\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0,1,6. + sin(iTime)*3.,1); //Sphere xyz is position w is radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist  = p.y;\n    float d = min(sphereDist,planeDist);\n \n    return d;\n}\nvec3 GetNormal(vec3 pos) { \n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).dist + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).dist + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).dist + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).dist );\n}\n\nfloat GetShadow(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos - p);\n    float t = 0.01; // Démarre juste au-dessus de la surface pour éviter l'auto-occlusion\n    float shadow = 1.0;\n\n    for (int i = 0; i < 50; i++) {\n        vec3 q = p + l * t;\n        float d = map(q).dist; // Obtenez la distance au point le plus proche\n\n        if (d < 0.001) {\n            shadow = 0.0;\n            break;\n        }\n        t += d;\n        if (t > 10.0) break; // Limite la portée des ombres pour éviter les calculs inutiles\n    }\n\n    return shadow;\n}\n\nvec3 lDirectionalDiffuse(vec3 p, vec3 lPos, float intensity, vec3 color) {\n    // Light (directional diffuse)\n    vec3 l = normalize(lPos - p); // Light Vector\n    vec3 n = GetNormal(p); // Normal Vector\n    \n    float dif = dot(n, l); // Diffuse light\n    dif = clamp(dif, 0. ,1.); // Clamp so it doesnt go below 0\n    \n    return clamp(color * dif * intensity, 0., 1.);\n}\n\nvec3 lAmbientLight(float intensity, vec3 color) {\n    return color * intensity;\n}\n\nvec3 GetLights(vec3 p) {\n    vec3 ambientLight = lAmbientLight(.2, vec3(1., 1., 0.));\n\n    vec3 lightPos = vec3(sin(iTime) * 10., 5., cos(iTime) * 10.);\n    vec3 dif = lDirectionalDiffuse(p, lightPos, 1., vec3(1., 0., 0.));\n    float shadow = GetShadow(p, lightPos);\n\n    return (dif * shadow) + ambientLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialization\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 backgroundColor = vec3(.1, .2, .3);\n    vec3 shapeColor = vec3(backgroundColor);\n    \n    float t = 0.;\n    \n    // Raymarchin\n    int i = 0;\n    for (i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t;\n        // p.xy += sin(t) * .45;\n        \n        Shape shape = map(p);\n        float d = shape.dist;\n        shapeColor = shape.color * GetLights(p);\n        \n        t += d;\n        if (d < .01) break;\n        if (d > 100.) {\n            shapeColor = backgroundColor;\n            break;\n        }\n    }\n        \n    // Calcul Output color\n    vec3 col = shapeColor;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}