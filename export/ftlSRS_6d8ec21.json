{"ver":"0.1","info":{"id":"ftlSRS","date":"1626014789","viewed":193,"name":"Mode7 Noise Map","username":"JackOverflow","description":"Using noise to generate something that looks like a map.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","map","mode7"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// define colours\nconst vec3 sky = vec3(0.282, 0.619, 0.878);\nconst vec3 deepSea = vec3(0.196, 0.384, 0.945);\nconst vec3 shallows = vec3(0.282, 0.619, 0.878);\nconst vec3 sandyBeach = vec3(0.921, 0.854, 0.556);\nconst vec3 grassland = vec3(0.149, 0.756, 0.062);\nconst vec3 forest = vec3(0.156, 0.482, 0.168);\nconst vec3 mountain = vec3(0.615, 0.411, 0.043);\nconst vec3 snowyPeak = vec3(0.984, 0.960, 0.913);\n\n// pixelates current image, use renderedPixelSize to control how \"pixelated\" the resulting image is\nvec2 pixelate(vec2 resolution, float renderedPixelSize, vec2 uv) {\n    // pixelate code from: https://luka712.github.io/2018/07/01/Pixelate-it-Shadertoy-Unity/    \n    float onePixelSizeX = 1.0 / resolution.x;\n    float onePixelSizeY = 1.0 / resolution.y;\n    \n    float cellSizeX =  renderedPixelSize * onePixelSizeX;\n    float cellSizeY = renderedPixelSize * onePixelSizeY;\n    \n    float x = cellSizeX * floor(uv.x / cellSizeX);\n    float y = cellSizeY * floor(uv.y / cellSizeY);\n    return vec2(x, y);\n}\n\n// generates 2D noise by mixing iChannel 0 and 1\nfloat noise(vec2 uv1, vec2 uv2, float blend) {\n    vec4 channel0 = texture(iChannel0, vec2(uv1.x, uv1.y));\n    vec4 channel1 = texture(iChannel1, vec2(uv2.x, uv2.y));\n    float noise = mix(channel0, channel1, blend)[0];\n    noise = pow(noise * 1.05, 3.86);\n    return noise;\n}\n\n// zooms given co-ordinate by zoomFactor, centered around scaleCenter\nvec2 zoom(float zoomFactor, vec2 scaleCenter, vec2 uv) {\n    // zooming taken from here: https://www.shadertoy.com/view/XtjyWW\n    return (uv - scaleCenter) * zoomFactor + scaleCenter;\n}\n\n// scrolls given co-ordinate by speed pixels per second\nvec2 scroll(float speed, float time, vec2 uv) {\n    float scroll = speed * time;\n    float offset = mod(scroll, 1.0);\n    return vec2(uv.x + offset, uv.y + offset);\n}\n\n// generates a 2D map, from noise in iChannel 0 and 1\nfloat noise_map(vec2 uv) {\n    uv = zoom(0.5, vec2(0.5, 0.5), uv);\n    return noise(uv, uv, 0.8);\n}\n\nvec2 mode7(float fov, float center_screen, float scale, float horizon, vec2 cameraPosition, float cameraRotation, vec2 uv) {\n    // from here: https://www.shadertoy.com/view/MddSzB\n    // projection\n    uv -= vec2(center_screen);\n    vec3 projection = vec3(uv.x, uv.y - horizon - fov, uv.y-horizon);\n    vec2 scene = projection.xy / projection.z;\n    // camera transformation\n    scene *= scale;\n    mat2 rotationMatrix = mat2(cos(cameraRotation), - sin(cameraRotation), sin(cameraRotation), cos(cameraRotation));\n    scene *= rotationMatrix;\n    scene += cameraPosition;\n    return scene;\n}\n\nvec3 biome(float elavation) {\n    vec3 pixelColour;\n    \n    // Use elevation value to pick current pixel colour\n    if (elavation < 0.1) {\n        pixelColour = deepSea;\n    } else if (elavation < 0.2) {\n        pixelColour = shallows;\n    } else if (elavation < 0.3) {\n        pixelColour = sandyBeach;\n    } else if (elavation < 0.5) {\n        pixelColour = grassland;\n    } else if (elavation < 0.7) {\n        pixelColour = forest;\n    } else if (elavation < 0.9) {\n        pixelColour = mountain;\n    } else {\n        pixelColour = snowyPeak;\n    }\n    return pixelColour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // calculate distance based on un-transformed uv.y for doing fog effect later\n    float distance = pow(uv.y, 3.16);\n\n    uv = pixelate(iResolution.xy, 4.0, uv.xy);\n    float scroll_speed = 0.15;\n    vec2 position = vec2(sin(iTime * scroll_speed), iTime * scroll_speed);\n    float rotation = sin(iTime * 0.12);\n    uv = mode7(1.0, 0.45, 0.3, 0.75, position, rotation, uv);\n    float elavation = noise_map(uv);\n    \n    // get ground colour from biome\n    vec3 groundColour = biome(elavation);\n    // apply distance based shading\n    vec3 pixelColour = mix(groundColour, sky, distance);\n    \n    // Output to screen\n    fragColor = vec4(pixelColour, 1.0);\n}","name":"Image","description":"","type":"image"}]}