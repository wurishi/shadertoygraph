{"ver":"0.1","info":{"id":"NdXSDB","date":"1629793755","viewed":220,"name":"Health Potion","username":"Jeaper","description":"An sdf health potion. With wonky \"physics\". Click left or right of the bottle to rotate.\nFirst SDF I have made, I tried to figure out all these SDF functions myself to understand it better, so sorry if these functions are not \"optimal\" or \"traditional\"!\n","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["2d","sdf","sprite","potion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 rotateUV(vec2 uv, vec2 pos, float angle) {\n    //uv /= resolution; \n    angle *= M_PI*2.0;\n    uv-= pos;\n    //uv.y /= resolution.x / resolution.y;\n    float s = sin(angle), c = cos(angle);\n    uv *= mat2(c, s, -s, c);\n    //uv.y *= resolution.x / resolution.y;\n    uv+= pos;\n    \n    return uv;\n}\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\n// 2D Random\nfloat random (in vec2 st, in float noiseSeed) {\n   return fract(sin(dot(st.xy,\n\t\t\t\t\tvec2(12.9898, 78.233)))\n\t\t\t\t\t* 43758.5453123 * noiseSeed);\n}\nfloat perlinNoise (in vec2 st, in float noiseSeed, float resolution) {\n    st *= resolution;\n    \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i,noiseSeed);\n    float b = random(i + vec2(1.0, 0.0),noiseSeed);\n    float c = random(i + vec2(0.0, 1.0),noiseSeed);\n    float d = random(i + vec2(1.0, 1.0),noiseSeed);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n    (c - a)* u.y * (1.0 - u.x) +\n    (d - b) * u.x * u.y;\n}\nvec3 draw(vec3 orgColor,  vec4 color, float d) {\n  float inShape = smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n  return mix(orgColor, color.rgb, inShape * color.a);\n}\n// substracts shape d1 from shape d2\n\nfloat sdSubtract( float d1, float d2 ){\n    return max(d2-d1,0.0);\n}\n\n//I tried to figure out all this SDF stuff myself to understand it better, so sorry if these functions are not \"optimal\" or \"traditional\"\n\nfloat sdRoundedRectangle (vec2 uv, vec4 transform, float rounding) {\n    float rect= step(length(max(abs(uv-transform.xy)-transform.zw+rounding,0.0))-rounding,0.0);\n    return rect;\n}\nfloat sdRectangle (vec2 uv, vec4 transform) {\n    float rect = step(length(max(abs(uv-transform.xy)-transform.zw,0.0)),0.0);\n    return rect;\n}\n\nfloat sdCircle (vec2 uv, vec2 pos, vec2 rad) {\n    uv.x -= pos.x;\n    uv.x *= rad.y/rad.x;\n    uv.x += pos.x;\n    float d = step(length(uv-pos), rad.y);\n\treturn d;\n}\n\nfloat bottleTop(vec2 uv,vec2 pos, float border){\n    float d = 0.0;\n    float throatTop = sdRoundedRectangle(uv, vec4(pos.x,pos.y+0.27,0.095+border, 0.062+border),0.08);\n    d = max(d, throatTop);\n    return d;\n}\n\n\n\nfloat bottleStand(vec2 uv,vec2 pos, float border){\n   float standBorder = (border* (0.7+(smoothstep(pos.y-0.2,pos.y-0.4,uv.y)*0.7)));\n   float stand = sdRoundedRectangle(uv, vec4(pos.x,pos.y-0.45, 0.154+standBorder,0.05+standBorder),0.05);\n   return stand;\n}\nfloat bottleThroat(vec2 uv,vec2 pos, float border){\n   pos.y+=0.16;\n   return sdRoundedRectangle(uv, vec4(pos.x,pos.y, 0.071+((border*0.5) +(border* (0.2+(smoothstep(pos.y+0.05,pos.y-0.05,uv.y)*0.5)))),0.11),0.05);\n}\nfloat bottleBody(vec2 uv,vec2 pos, float border){\n  float bodyBorder = border* (0.7+(smoothstep(0.25,0.0,uv.y-(pos.y-0.125))*0.7));\n  float body =  sdCircle(uv, vec2(pos.x,pos.y -0.2),vec2(0.3224+bodyBorder,0.2824+bodyBorder));\n  return body;\n}\nfloat bottleGlass(vec2 uv,vec2 pos, float border){\n    float glass = 0.0;\n    glass = bottleThroat(uv,pos,border);\n   \n    float body = bottleBody(uv,pos,border);\n    float stand =  bottleStand(uv,pos,border);\n    \n    body = max(body,  stand);\n    glass = max(glass, body);\n    \n    glass = sdSubtract(bottleTop(uv,pos,border),glass);\n   \n    return glass;\n}\n\nvec3 bottleLighting(vec2 uv, vec2 pos, vec3 color){\n\n    float body =  bottleBody(uv,pos,0.0);\n    \n    float stand = bottleStand(uv,pos,0.0);\n    \n    float d = max(body,stand);\n    \n    // Light the center\n    vec2 bodyCenter = vec2(pos.x+0.02,pos.y -0.22);\n    float remove = 0.0;\n    \n    remove = max(remove, sdCircle(rotateUV(uv,bodyCenter,0.12), bodyCenter, vec2(0.30,0.24)));\n    remove = max(remove, sdCircle(uv,vec2(pos.x,pos.y+0.098), vec2(0.08,0.06)));\n    d = sdSubtract(remove, d);\n    \n    vec2 lightPos = vec2(pos.x,pos.y-0.2);\n    float light = smoothstep(0.35,0.0,length(uv-lightPos));\n    \n    d *= smoothstep(1.0,0.0,light);\n    \n    color.rgb = draw(color.rgb, vec4(1.0,1.0,1.0,light), d);\n    \n    // Light the throat\n    vec4 throatTransform = vec4(pos.x,pos.y+0.16, 0.071,0.11);\n    d = sdRoundedRectangle(uv, throatTransform,0.05);\n    d *= smoothstep(0.0,0.12 + 0.04 * smoothstep(0.13,0.0,abs(uv.y-(pos.y+0.165))),abs(uv.x-(pos.x+0.004)));\n    d = sdSubtract(bottleTop(uv,pos,0.011),d);\n    //d *= smoothstep(0.1,0.0,abs(uv.x-pos.x));\n    color.rgb = draw(color.rgb, vec4(1.0,1.0,1.0,d), d);\n    \n    return color;\n}\n\nfloat getBottleBorder(vec2 uv,vec2 pos, float border){\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    float glass = bottleGlass(uv,pos,0.0);\n    glass = sdSubtract(glass, bottleGlass(uv,pos,border));\n    \n    float throatTop = bottleTop(uv,pos,border);\n    throatTop = sdSubtract(bottleTop(uv,pos,0.0),throatTop);\n    glass = max(glass, throatTop);\n    \n    float bottleTopOffset = 0.016;\n    throatTop = bottleTop(uv,vec2(pos.x,pos.y+0.01),-bottleTopOffset);\n    throatTop = sdSubtract(bottleTop(uv,pos,-(bottleTopOffset+border)),throatTop);\n    glass = max(glass, throatTop);\n    \n    return glass;\n}\nvec3 bottleBorder(vec2 uv,vec2 pos, vec3 color){\n  \n   float glass = getBottleBorder(uv,pos, 0.011);\n    \n    vec4 glassColor = vec4(0.86,0.96,0.93,0.8);\n    color.rgb = draw(color.rgb, glassColor,glass);\n    return color;\n}\n\nvec3 cork(vec2 uv, vec2 pos, vec3 color){\n    // Todo: Cork\n    float noise = perlinNoise(uv,1.2,50.0);\n    vec4 corkColor = vec4(0.53,0.27,0.03,1.0);\n    vec4 corkLightColor = vec4(0.88,0.54,0.23,1.0);\n    \n    corkColor.rgb = draw(corkColor.rgb, vec4(corkLightColor.rgb,smoothstep(0.7,1.0,noise)*0.7), smoothstep(0.5,1.0,noise)*0.7);\n    corkLightColor.rgb = mix(corkLightColor.rgb, corkColor.rgb, smoothstep(0.6,1.0,noise)*0.6);\n    \n    float corkPos = pos.y + 0.332;\n    float corkBody =  sdCircle(uv, vec2(pos.x,corkPos),vec2(0.06+ 0.028*smoothstep(corkPos-0.175,corkPos+0.025,uv.y),0.09 ));\n    color.rgb = draw(color.rgb, corkColor,corkBody);\n    \n    float corkTop =  sdCircle(uv, vec2(pos.x,corkPos +0.05),vec2(0.06+0.03* smoothstep(corkPos+0.08,corkPos-0.1,uv.y),0.038 ));\n    color.rgb = draw(color.rgb, corkLightColor,corkTop);\n    return color;\n}\n\nfloat clampedSmoothStep(float a, float b, float c){\n  return smoothstep(a,b,c) * (1.0-(step(abs(b-a),abs(c-a))));\n}\n\n\nfloat getFillLevel(vec2 uv, vec2 center, vec2 bottleRotationalData, vec3 liquidRotationalData){\n    \n    float fillLevel = center.y + 1.18;\n    // Animate the fullness\n    float liquidLevelAnimation = (0.11*sin(iTime*0.4));\n    fillLevel += liquidLevelAnimation*0.8;\n    \n    // Estimate the fullness based on the rotation of the bottle \n    float rotation =  bottleRotationalData.x;;\n    float fillLevelModifier = clampedSmoothStep(1.0001,0.50001,rotation);\n    fillLevelModifier += clampedSmoothStep(-0.0001,0.49999,rotation);\n    fillLevel -= 0.4 * fillLevelModifier;\n    \n    \n    float directionRotation = liquidRotationalData.z;\n    float direction = clampedSmoothStep(-0.00001,0.49999,directionRotation);\n    direction += clampedSmoothStep(-0.00001,0.25000,directionRotation);\n    direction -= clampedSmoothStep(1.00001,0.74999,directionRotation);\n    direction -= clampedSmoothStep(0.75000,0.50001,directionRotation);\n    // Wave motion\n    float liquidVelocity = (liquidRotationalData.y*2.0) - 1.0;\n    float liquidAmplitude = abs(0.5-liquidRotationalData.y);\n    float frequency = 20.0;// + 0.1*liquidAmplitude;\n    float amplitude = 0.003 + 0.015* liquidAmplitude;\n    float liquidMovementAnimation = sin((uv.x + (iTime * 0.08) +(M_PI* direction)) * frequency) * amplitude;\n    fillLevel += liquidMovementAnimation;\n   \n    \n    fillLevel += 0.02 * smoothstep(0.2,0.7,abs(liquidVelocity)) * smoothstep(0.5,0.0,abs(uv.x-center.x));\n    \n    float rotationalDifference = (liquidRotationalData.z*2.0) - 1.0;\n    rotationalDifference = (abs(rotationalDifference) + 0.4);\n  \n    fillLevel += 0.05 * smoothstep( center.x+rotationalDifference, center.x-rotationalDifference, uv.x)*step(0.1,abs(rotationalDifference));;\n    \n    return fillLevel;\n}\nvec3 liquid(vec2 uv, vec2 pos, vec3 color, float mask,vec2 bottleRotationalData){\n    // Rotate the liquid opposite of the bottle\n    vec3 liquidRotationalData = loadValue(txLiquidRotationalData).xyz;\n    //rotationalData = loadValue(txBottleRotationalData).xyz;\n    \n    liquidRotationalData.x = fMod(liquidRotationalData.x,1.0);\n    liquidRotationalData.z *= step(0.01,liquidRotationalData.z);\n    //liquidRotationalData.x = 0.1;\n    \n    float liquidVelocity = liquidRotationalData.y*2.0 - 1.0;\n    float bottleRotation = liquidRotationalData.x;\n   \n    uv = rotateUV(uv,pos,fMod(bottleRotation+0.5,1.0));\n    //TODO: Can I make the noise bound to the center of the liquid somehow?\n   \n    vec4 liquidColor = vec4(0.96,0.01,0.01,1.0);\n    \n    float fillLevel = getFillLevel(uv,pos,bottleRotationalData, liquidRotationalData);\n    vec2 noiseUv = uv;\n    noiseUv.y += fillLevel;\n    \n    // For the highlight close to the surface. \n    float rotationalDifference = (liquidRotationalData.z*2.0) - 1.0;\n    rotationalDifference = (abs(rotationalDifference) + 0.4);\n    float closeToSurface = smoothstep(0.05+ (0.07 * smoothstep( pos.x+rotationalDifference, pos.x-rotationalDifference, uv.x)*step(0.1,abs(rotationalDifference))), 0.0, abs((1.0-uv.y) - (fillLevel+0.015)));\n    \n    \n    \n    float brightness = 0.1+ 0.3* closeToSurface;\n    vec3 liquidHighlightColor = vec3(0.96,brightness,brightness);\n    \n    // I really like blendadd\n    // 2 scrolling textures blended together to make an endless one.\n    float noise = perlinNoise(noiseUv+vec2((0.24*sin(iTime*0.15)), 1.0-iTime / 17.0),1.0,20.0);\n    noise += perlinNoise(noiseUv+vec2(1.0-iTime / 25.0, 1.0-iTime / 23.0),0.8,23.0);\n    noise = smoothstep(0.6,0.9,noise);\n    liquidColor.rgb = mix(liquidHighlightColor,liquidColor.rgb,noise);\n    \n    \n    // Calculate how full of liquid the bottle is (Just how far up the screen we should mask it)\n    \n    float belowSurface = step(fillLevel, 1.0-uv.y);;\n    float newMask = mask * belowSurface;\n    \n    \n    //Base liquid Color\n    color.rgb = draw(color.rgb, liquidColor, newMask);\n    \n    // Add some highlight by the surface. \n    mask += closeToSurface*newMask*0.5;\n    color.rgb = mix(color.rgb, liquidHighlightColor,newMask * closeToSurface );\n    \n    \n    \n    noise = perlinNoise(noiseUv+vec2((0.24*sin(iTime*0.15)), 1.0-iTime / 25.0),1.0,22.0);\n    noise += perlinNoise(noiseUv+vec2(1.0-iTime / 38.0, 1.0-iTime / 35.0),0.8,35.0);\n    float aboveSurfaceLevel = smoothstep(fillLevel-0.13,fillLevel,1.0-uv.y);\n    noise = smoothstep(0.45,0.4,noise)*aboveSurfaceLevel;\n    vec3 aboveSurfaceColor = mix(vec3(0.15,0.15,0.15),liquidHighlightColor.rgb*1.5,aboveSurfaceLevel);\n    color.rgb = mix(color.rgb,aboveSurfaceColor,(noise*mask));\n    \n    \n    return color;\n}\n\nvec3 bottle(vec2 uv, vec2 pos, vec3 color, vec2 bottleRotationalData){\n    float alpha = 0.2;\n    float alphaModifier = 0.2*smoothstep(0.0,0.4,length(uv-vec2(pos.x,pos.y-0.2)));\n    alpha +=  alphaModifier;\n    vec4 glassColor = vec4(0.57,0.67,0.93,alpha);\n    float glass = bottleGlass(uv,pos,0.0);\n    color = liquid(uv,pos,color, glass,bottleRotationalData);\n     \n    \n    \n    color.rgb = draw(color.rgb, glassColor, glass);\n    \n    color.rgb = draw(color.rgb, glassColor, bottleTop(uv,pos,0.0));\n    \n    color.rgb = bottleLighting(uv,pos,color);\n    \n    color = bottleBorder(uv,pos,color);\n    \n    \n    \n    color = cork(uv,pos,color);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bottleData = loadValue(txBottleRotationalData);\n    \n    //Rotate the coordinate around the center\n    vec2 rotatedCoord = rotateUV(fragCoord,vec2(0.5,0.5)*iResolution.xy,1.0-bottleData.x);\n    \n    vec4 color = vec4(0.1,0.1,0.1,1.0);\n    \n    // Make it so that we can use the same coordinate system for x and y\n    vec2 uv = 2.0 * (rotatedCoord.xy / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 center =  vec2(0.0,0.0);\n    \n    // Color the background\n    vec2 lightPos = vec2(center.x,center.y-0.2);\n    float light = smoothstep(1.4,0.0,length(uv-lightPos)) *0.3;\n    color.rgb = mix(color.rgb, vec3(0.76,0.01,0.01),light);\n    \n    \n    color.rgb = bottle(uv,center,color.rgb,bottleData.xy);\n    \n    \n    // Make anything without color transparent\n    color.a = step(0.000001,color.r+color.g+color.b);\n    \n    float testValue = 0.0;\n    testValue =loadValue(txLiquidRotationalData).z;\n    testValue-=0.5;\n    testValue *= 1.0;\n    testValue += 0.5;\n    float testValue2 = fract(iTime / 40.0);\n    //testValue = modDistance(0.1,testValue2,1.0);\n    \n    \n    //if((fragCoord.xy/iResolution.xy).x > 0.9){\n    //  if((fragCoord.xy/iResolution.xy).x > 0.95){\n    //     color.rgb = mix(vec3(0.0,0.0,0.0),color.rgb,step(0.0,(fragCoord.xy/iResolution.xy).y- testValue));\n    //  }\n    //  else{\n    //    color.rgb = mix(vec3(0.0,0.0,0.0),color.rgb,step(0.0,(fragCoord.xy/iResolution.xy).y- testValue2));\n    //  }\n    //}\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define velocityFalloff 0.1\n#define velocityClickMultiplier 0.12\n#define velocityRealignment 0.011\n#define liquidThickness 2.9\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    vec2 r = 0.5*vec2(re.zw);\n    vec2 d = abs( vec2(fragCoord-re.xy)-r) - r - 0.5;\n    fragColor = ( -max(d.x,d.y) > 0.0 ) ? va : fragColor;\n}\n\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    // don't compute gameplay outside of the data area\n    if( ifragCoord.x > 31 || ifragCoord.y>31 ) discard;\n    \n    \n    vec4 m = iMouse / iResolution.x;\n\n    float animation = iTimeDelta * 2.0;\n            \n    vec2 uv = fragCoord/iResolution.xy;\n    //vec4 color = texture(iChannel0, uv);\n    \n    \n    vec2 bottleRotationalData = loadValue(txBottleRotationalData).xy;\n    // Holding the mouse button increases velocity\n    float newVelocity = velocityClickMultiplier*(m.x-0.5);\n    newVelocity *= step( 0.00001,m.z);\n    \n    // Store the shapes rotation and velocity in x and y\n    float velocity =((bottleRotationalData.y*2.0)-1.0);\n    velocity += newVelocity;\n    velocity *= 1.0-(velocityFalloff * animation);\n    //This step is to decrease float weirdness when getting too low.\n    velocity *= step( 0.00001,abs(velocity));\n    // -1 == 0 | 0 == 0.5 | 1 == 1\n    bottleRotationalData.y =  0.5 + (velocity/2.0);\n    float bottleRotation = mod(bottleRotationalData.x + (velocity * animation * 0.1),1.0);\n    bottleRotationalData.x = bottleRotation;\n    \n    \n    // Liquid\n    vec3 liquidRotationalData = loadValue(txLiquidRotationalData).xyz;\n    float liquidRotation = liquidRotationalData.x;\n    // store the liquids rotation and velocity in z and w\n    float velocity2 =((liquidRotationalData.y*2.0)-1.0);\n    //divide by the thickness of the liquid to get a slower acceleration and deceleration\n    velocity2 += newVelocity / liquidThickness;\n   \n    \n    \n    // Move towards the bottles rotation\n    float rotationalDist = modDistance(liquidRotation,bottleRotation,1.0);\n    rotationalDist *= smoothstep( 0.001, 0.5,abs(rotationalDist));\n    rotationalDist *= velocityRealignment * 0.5;\n    rotationalDist *= step( 0.001,abs(rotationalDist));\n    velocity2 -= rotationalDist;\n    // Save it\n    liquidRotationalData.z =   (0.5*rotationalDist)+0.5 ;\n    \n    \n    // Decrease velocity over time\n    velocity2 *= 1.0-((velocityFalloff * liquidThickness) * animation);\n     //This step is to decrease float weirdness when getting too low.\n    velocity2 *= step( 0.001,abs(velocity2));\n    // -1 == 0 | 0 == 0.5 | 1 == 1\n    liquidRotationalData.y =  0.5 + (velocity2 * 0.5);\n    liquidRotation =  fMod(liquidRotation + (velocity2 * animation * 0.1),1.0);\n   \n    liquidRotationalData.x = liquidRotation;\n    \n   \n    storeValue( txBottleRotationalData,vec4(bottleRotationalData,0.0,0.0),fragColor, ifragCoord);\n    storeValue( txLiquidRotationalData,vec4(liquidRotationalData,0.0),fragColor, ifragCoord);\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const ivec2 txBottleRotationalData = ivec2(31, 1);\nconst ivec2 txLiquidRotationalData = ivec2(31, 3);\n\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n\nfloat fMod(float x, float y){\n  \n  return x - y * trunc(x/y);\n}\n\nfloat modDistance(float a, float b, float modulus){\n  \n  a = fMod(a, modulus);\n  b = fMod(b, modulus);\n  \n  float t1 = fMod((modulus+a)-b, modulus);\n  float t2 = fMod(a-(b+modulus), modulus);\n  float r1 = t1 * step(abs(t2),abs(t1));\n  float r2 = t2 * step(abs(t1),abs(t2));\n  return r1 + r2;\n}\n\n","name":"Common","description":"","type":"common"}]}