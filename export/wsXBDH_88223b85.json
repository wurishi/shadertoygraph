{"ver":"0.1","info":{"id":"wsXBDH","date":"1588138044","viewed":659,"name":"line integral convolution plot","username":"matthen","description":"visualizing a vector field with a line integral convolution plot","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["convolution","field","plot","vectorfield","force"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_STEPS 256.\n#define FIELD_COL vec3(0.478431, 0.929412, 1.)\n\n\nvec3 gradient(in float t) {\n    return FIELD_COL * (0.4 + 0.6 * smoothstep(0., 1., t));\n}\n\nvec3 mass_1(in float t) {\n\treturn vec3(0.4 * sin(0.4 * t), 0.4 * cos(0.4 * t), 0.05);   \n}\n\nvec3 mass_2(in float t) {\n\treturn vec3(-0.05 * sin(0.4 * t) , -0.05 * cos(0.4 * t), 0.1); \n}\n\nvec3 mass_3(in float t) {\n\tvec3 m1 = mass_1(t);\n    \n    return vec3(m1.x + 0.1 * sin(2. * t), m1.y + 0.1 * cos(2. * t), 0.02);\n}\n\nvec2 force(in vec3 m, in vec2 uv) {\n    float dist = 0.6 * m.z + length(uv - m.xy);\n    vec2 f = m.z * (uv - m.xy);\n    return f / (dist * dist * dist);\n}\n\nvec2 field(in vec2 uv, in float t) {\n    vec2 f = vec2(0., 0.);\n    f += force(mass_1(t), uv);\n    f += force(mass_2(t), uv);\n    f += force(mass_3(t), uv);\n    \n\treturn f;   \n}\n\nvec3 getNoise(in vec2 uv) {\n    uv *= 0.4;\n    ivec2 pi = ivec2(\n        uv * iResolution.y + 0.5 * iResolution.xy\n    );\n    ivec2 ires = ivec2(iResolution.xy);\n    pi = (pi + ires) % ires;\n    return texelFetch(iChannel0, pi, 0).xyz;\n}\n\nvec3 mix_disk(in vec3 col, in vec3 m, in vec2 uv) {\n    float dist = length(uv - m.xy);\n    float rad = 0.6 * m.z;\n    vec3 mixed = mix(col, vec3(0., 0., 0.), smoothstep(rad + 0.003, rad - 0.003, dist));\n    mixed = mix(mixed, FIELD_COL, 1. - smoothstep(0., 0.005, abs(dist - rad)));\n    \n    return mixed;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord  - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv *= 1.1;\n    float t = mod(iTime, 15.707);\n    \n    vec3 value;\n    float norm = 0.;\n    vec2 uvt = uv;\n    float dt = 0.005 * smoothstep(0., 7.853, t);\n    dt -= 0.005 * smoothstep(7.853, 15.707, t);\n    \n    \n    for (float i = 0.; i < NUM_STEPS; i++) {\n        float mask = (0.5 + 0.4 * cos(2. * 3.1415 * (i - NUM_STEPS * t / 2.) / NUM_STEPS));\n        value += getNoise(uvt) * mask;\n        norm += mask;\n        uvt += dt * field(uvt, t);\n    }\n    \n\tvec3 col = 1.2 * value / norm;\n    col *= gradient(length(field(uv, t)));\n    \n    col = mix_disk(col, mass_1(t), uv);\n    col = mix_disk(col, mass_2(t), uv);\n    col = mix_disk(col, mass_3(t), uv);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// source of noise\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float noise = hash12(fragCoord);\n    noise = step(noise, 0.5);\n    \n    fragColor = vec4(vec3(noise),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}