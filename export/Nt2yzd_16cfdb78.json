{"ver":"0.1","info":{"id":"Nt2yzd","date":"1650283799","viewed":799,"name":"WINDING NUMBERS","username":"alro","description":"Exploring winding numbers and signed angles","likes":58,"published":1,"flags":0,"usePreview":0,"tags":["2d","line","star","palette","heart","curve","angle","infinity","signed","inside","outside","winding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n*  The winding number of a point describes how many full revolutions a curve makes around it.\n*  Open curves produce interesting visuals. We discretise parametric curves into linear\n*  segments and find the signed angle between the vectors connecting a point to the segment.\n*  The sum of these angles, divided by 2PI radians, gives the winding number.\n*\n*  Based on:\n*      https://en.wikipedia.org/wiki/Winding_number\n*  [1] https://igl.ethz.ch/projects/winding-number/\n*      https://twitter.com/keenanisalive/status/1448036393012322313\n*      https://www.shadertoy.com/view/Wddyz2\n*\n*/\n\n#define PI 3.1415926536\n#define TWO_PI 6.2831853072\n\nconst float sceneSwitchSpeed = 0.21;\n\n// Uncomment defines to control scene and colour\n\n/* \n    0: Circle\n    1: Heart\n    2: Star\n    3: Lemniscate\n*/\n\n//#define SCENE 1\n\n/*\n    0: Black and white\n    1: Pastel rainbow\n    2: Red and purple\n    3: Blue\n*/\n\n//#define PALETTE 2\n\n\n// https://math.stackexchange.com/questions/3020095/signed-angle-in-plane:\n// \"the ratio of the cross product and scalar product is the tangent of the angle\"\n// From [1]: \"The tangent of the signed angle between a and b is det([ab]) / dot(ab)\"\nfloat signedAngle(vec2 a, vec2 b){\n    // atan(y, x) returns the angle whose arctangent is y / x. Value in [-pi, pi]\n    return atan(a.x*b.y - a.y*b.x, dot(a, b));\n}\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 getColour(float t, int palette){\n\n\n    if(palette == 0){\n\n        // Black and white\n        return vec3(-0.5 * t + 0.45);\n    }\n\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n    \n    if(palette == 1){\n\n        // Pastel rainbow\n        // Animated\n\n        t *= 0.45;\n        t += 0.1 * iTime;\n\n        a = vec3(0.65);\n        b = 1.0 - a;\n        c = vec3(1.0,1.0,1.0);\n        d = vec3(0.15,0.5,0.75);\n\n    }else if(palette == 2){\n\n        // Red and purple\n\n        t *= -0.3;\n        t += 0.65;\n\n        a = vec3(0.55, 0.5, 0.7);\n        b = 1.0-a;\n        c = vec3(1.0,1.0,1.0);\n        d = vec3(0.15,0.95,0.8);\n\n    }else if(palette == 3){\n\n        // Blue\n        // Same as above with different t\n\n        t *= 0.35;\n        t += 0.3;\n\n        a = vec3(0.55, 0.5, 0.7);\n        b = 1.0-a;\n        c = vec3(1.0,1.0,1.0);\n        d = vec3(0.15,0.95,0.8);\n\n    }\n\n    return a + b * cos(TWO_PI * (c * t + d));\n}\n\nvec2 getCircle(float t){\n    return vec2(sin(t), cos(t));\n}\n\n// http://mathworld.wolfram.com/Lemniscate.html\nvec2 getLemniscate(float t){\n    float a = 1.5;\n    return vec2((a * cos(t)) / (1.0 + (sin(t) * sin(t))), \n                (a * sin(t) * cos(t))/ (1.0 + (sin(t) * sin(t))));\n}\n\n// http://mathworld.wolfram.com/HeartCurve.html\nvec2 getHeart(float t){\n    return 0.05 * vec2(1, -1) * vec2(16.0 * sin(t) * sin(t) * sin(t),\n                -(13.0 * cos(t) - 5.0 * cos(2.0 * t)\n                - 2.0 * cos(3.0 * t) - cos(4.0 * t))) + vec2(0, 0.1);\n}\n\nvec2 rotate2d(vec2 v, float a){\n    return v * mat2(cos(a),-sin(a), sin(a), cos(a));\n}\n\n// https://en.wikipedia.org/wiki/Hypotrochoid\n// https://mathworld.wolfram.com/Hypotrochoid.html\nvec2 getHypotrochoid(float t){\n    float a = 5.0;\n    float b = 3.0;\n    float h = 5.0;\n    float a_b  = a - b;\n    float t_ab = t * a_b / b;\n    return vec2(a_b * cos(t) + h * cos(t_ab), a_b * sin(t) - h * sin(t_ab));\n}\n\n\nvec2 getPosition(float t, int scene){\n\n    if(scene == 0){\n        return getCircle(t);\n    }else if(scene == 1){\n        return getHeart(t);\n    }else if(scene == 2){\n        return getHypotrochoid(t);\n    }else{\n        return getLemniscate(t);\n    }\n\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    uv.y /= iResolution.x / iResolution.y;\n    uv *= 4.0;\n    \n    // 0: Circle\n    // 1: Heart\n    // 2: Star\n    // 3: Lemniscate\n    int scene = int(floor(mod(sceneSwitchSpeed * iTime, 4.0)));\n    \n    // 0: Black and white\n    // 1: Pastel rainbow\n    // 2: Red and purple\n    // 3: Blue\n    \n    // Pick a random palette. Should use a better method with uniform distribution which\n    // avoids picking the same value consecutively.\n    float rand = mod(1.0 + 4.0 * hash11(floor(sceneSwitchSpeed * iTime)), 4.0);\n    \n    int palette = int(rand);\n    \n#ifdef SCENE\n    scene = SCENE;\n#endif\n\n#ifdef PALETTE\n    palette = PALETTE;\n#endif\n    \n    float angle = 0.0;\n    float segments = 16.0;\n\n    float delta = (0.25 * (TWO_PI)) / segments;\n    \n    float speed = 2.0;\n    float radius = 1.0;\n    \n    // Heart\n    if(scene == 1){\n        segments = 16.0;\n        speed = 2.0;\n        delta = (0.15 * (TWO_PI)) / segments;\n    }\n    \n    // Star\n    if(scene == 2){\n        radius = 0.142;\n        speed = 4.0;\n        delta = (0.08 * (6.0 * PI)) / segments;\n        // Rotate star\n        uv = rotate2d(uv, -0.31415);\n    }\n    \n    // Lemniscate\n    if(scene == 3){\n        segments = 32.0;\n        speed = 2.5;\n        delta = (0.25 * (TWO_PI)) / segments;\n    }\n    \n    vec2 c0;\n    vec2 c1;\n    float t = speed * iTime;\n\n    for(float i = 0.0; i < segments; i += 1.0){\n        \n        c0 = radius * getPosition(t + (i) * delta, scene);\n        c1 = radius * getPosition(t + (i + 1.0) * delta, scene);\n        angle += signedAngle(c0-uv, c1-uv);\n        \n        // Add additional lines for some shapes\n        \n        // Circle\n        if(scene == 0){\n            c0 = 0.333 * radius * getPosition(2.2 * t + (i) * delta, scene);\n            c1 = 0.333 * radius * getPosition(2.2 * t + (i + 1.0) * delta, scene);\n            angle -= signedAngle(c0-uv, c1-uv);\n            \n            c0 = 0.666 * radius * getPosition(-t + (i) * delta, scene);\n            c1 = 0.666 * radius * getPosition(-t + (i + 1.0) * delta, scene);\n            angle += signedAngle(c0-uv, c1-uv);\n        }\n        \n        // Heart\n        if(scene == 1){\n            c0 = radius * getPosition(t + (i) * delta + 3.0, scene);\n            c1 = radius * getPosition(t + (i + 1.0) * delta + 3.0, scene);\n            angle += signedAngle(c0-uv, c1-uv);\n        }\n        \n        // Star\n        if(scene == 2){\n            c0 = radius * getPosition(t + (i) * delta + 3.0, scene);\n            c1 = radius * getPosition(t + (i + 1.0) * delta + 3.0, scene);\n            angle += signedAngle(c0-uv, c1-uv);\n        }\n    }\n\n    vec3 col = getColour(angle / TWO_PI, palette);\n   \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2022 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/","name":"Common","description":"","type":"common"}]}