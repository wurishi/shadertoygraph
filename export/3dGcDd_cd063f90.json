{"ver":"0.1","info":{"id":"3dGcDd","date":"1603987361","viewed":117,"name":"metaBallsReflexions","username":"Kaeylos","description":"#8 particles/circles\nmade during the Ink-MAC-tober 2020","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","imac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----- Ray marching options ----- //\n#define AA_SAMPLES 1 // antialisaing\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 50\n#else\n    #define MAX_STEPS 200\n#endif\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.0001\n\n#define FBM_MAX_ITER 10\n\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float t, float a, float b) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat map(float t, float a, float b, float c, float d) { return c + (t - a) * (d - c) / (b - a); }\nfloat mult(vec2 v) { return v.x*v.y; }\nfloat mult(vec3 v) { return v.x*v.y*v.z; }\nfloat sum(vec2 v) { return v.x+v.y; }\nfloat sum(vec3 v) { return v.x+v.y+v.z; }\n#define saturate(v) clamp(v, 0., 1.)\n\n// ----- Noise stuff ----- //\n// Based on Morgan McGuire and David Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat perlinNoise(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = hermiteInter(f);\n    return mix(hash1(id), hash1(id + 1.0), u);\n}\n\nvec3 perlinNoise3(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = hermiteInter(f);\n    return mix(hash3(id), hash3(id + 1.0), u);\n}\n\nvec3 fbm (float x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tvec3 v = vec3(0.);\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise3(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t}\n\treturn v / aSum;\n}\n\nvec3 vectorWiggle(float x) {\n    return fbm(x, 1., 2);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polysmin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 p, float radius) { return length(p) - radius; }\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [0, 1], including hue.\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0, 1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sceneSDF(vec3 p) {\n\tfloat d = 1.e10;\n\t\n\tfloat speed = 0.5;\n\tfloat t = iTime*speed;\n\tfor(float i=0.0; i < 15.; ++i) {\n\t\tfloat h = hash1(i*4757.);\n\t\tfloat radius = map(pow(perlinNoise(i*15456. + t),3.), 0.05, 0.35);\n\t\tvec3 center = mix(1., 0.4, pow(perlinNoise(i*10.*h+ t), 3.))*(vectorWiggle(i*10.*h + t)*2.-1.);\n\t\tfloat sphere = sphereSDF(p - center, radius);\n\t\t\n\t\td = polysmin(d, sphere, mix(0.05, 0.1, h));\n\t}\n\treturn d;\n}\n\n// from iq technique\n// source: https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++) {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = sceneSDF(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// source: https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p) {\n    const float h = NORMAL_DELTA;\n\tconst vec2 k = vec2(1., -1.);\n    return normalize( k.xyy * sceneSDF( p + k.xyy*h ) + \n                      k.yyx * sceneSDF( p + k.yyx*h ) + \n                      k.yxy * sceneSDF( p + k.yxy*h ) + \n                      k.xxx * sceneSDF( p + k.xxx*h ) );\n}\n\n// return dist, marchingCount\nvec2 rayMarching(vec3 O, vec3 D) { // ray origin and dir\n    float t = 0.0;\n    float marchingCount = 0.0;\n \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 pos = O + D * t;\n        float d = sceneSDF(pos);\n        \n        t += d * 0.6; // precision handling\n        ++marchingCount;\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n\n    }\n    return vec2(t, marchingCount);\n}\n\nvec3 blendColor(float t, vec3 a, vec3 b) {\n\treturn sqrt((1. - t) * pow(a, vec3(2.)) + t * pow(b, vec3(2.)));\n}\n    \nvec3 render(vec3 O, vec3 D) { // ray origin and dir\n\t\n\tint reflexionsCount = 2;\n\tfloat shadowsAttenuation = 5.;\n\tfloat specularStrength = 20.;\n\tvec3 backgroundColor = vec3(2,43,58)/255.0;\n\tvec3 ballsColor = vec3(255,166,43)/255.0;\n\t\n\t// backgroundColor = vec3(29, 186, 34)/255.0;  // green\n\t// ballsColor = vec3(255, 68, 180)/255.0; // pink\n\t\n    vec3 sunDir = normalize(vec3(0., 1., -1.));\n    vec3 sunColor = normalize(vec3(0.7, 0.7, 0.5));\n    float sunIntensity = 0.; \n    \n    vec3 finalCol = vec3(0.0);\n    bool skyReached = false;\n    \n    vec3 p, normal, ref;\n    for(int i = 0; i < reflexionsCount; ++i) {// reflexion loop\n    \t\n    \tvec3 col = ballsColor;\n    \tfloat d = rayMarching(O, D).x;\n    \t\n    \tif( d < MAX_DIST) {\n\t    \t// intersected point position\n\t        p = O + D * d;\n\t        normal = getNormal(p);\n\t        ref = normalize(reflect(D, normal));\n\t        \n\t        float occ = calcOcclusion(p, normal); // ambient occlusion\n\t        float sunDiffuse = saturate(dot(normal, sunDir));\n\t\t\t\n\t\t\tfloat sunSpecular = pow(max(0., dot(normal, normalize(sunDir - D))), specularStrength); // Blinn-Phong\n\t        // sunSpecular = pow(max(0., dot(sunDir, ref)), specularStrength); // Phong\n\t\t\t\n\t        col += sunIntensity*sunColor*sunDiffuse + sunSpecular*sunColor;\n\t\t\tcol *= mix(occ, 1., 0.5);\n\t        col *= 0.3;\n\t    }else {\n\t    \tcol = backgroundColor;\n\t    \tskyReached = true;\n\t    }\n        \n        // define new Origin and Direction for reflexion\n        O = p + normal*SURF_DIST;\n        D = ref;\n        \n        // mix reflexions colors\n        // using step and mix to branchless set finalCol = col when i == 0\n        if( i == 0) {\n        \tfinalCol = col;\n        }else {\n        \tfloat f = 0.6;\n        \tif(skyReached) f /= 6.; // diminish impact of backgroundColor\n\t        \t\n        \tfinalCol = blendColor(f, finalCol, col);\n        \t// finalCol = (finalCol + col*f) / (1+f);\n        }\n        if(skyReached) break; // no reflexions calculation for sky\n    }\n    \n    \n\treturn vec3(saturate(finalCol));\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.1; // zoom\n\t\n\tvec3 O = vec3(1.5, 0., 0.); // origin\n\n\tvec3 finalColor = vec3(0.);\n#if AA_SAMPLES > 1\n    for (float i = 0.; i < float(AA_SAMPLES); i++) {\n    \tfor (float j = 0.; j < float(AA_SAMPLES); j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t\t\tvec3 D = computeCamDir(uv, O, vec3(0.,1.,0.), vec3(0.)); // dir\n\t    \tfinalColor += render(O, D);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n    \n    // gamma corection\n    finalColor = pow(finalColor, vec3(1./2.2));\n    \n    \n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.y *= 1.5; // saturate\n    hsv.z *= 1.3;\n    finalColor = hsv2rgb(saturate(hsv));\n    \n    // color grading\n    finalColor *= vec3(1.07 ,0.92, 0.95);\n    \n\tfragColor = vec4(finalColor,1.);\n}","name":"Image","description":"","type":"image"}]}