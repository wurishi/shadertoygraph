{"ver":"0.1","info":{"id":"ldcfDH","date":"1572276287","viewed":161,"name":"hash-based high-pass dither test","username":"mystran","description":"Dithers using a small 5-tap high-pass kernel sampling a hash-based RPDF.\n\nDrag mouse to adjust comparison.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["dither"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float levels = 6.; // number of quantisation levels, must be at least 2\nconst float animFPS = 120.; // max framerate for temporal dither, set 0 to disable\nbool separateRGB = false; // use different random values for different channels?\n\nuint hash(uint x)\n{\n    x ^= x >> 16; x *= 0x7feb352du; \n    x ^= x >> 15; x *= 0x846ca68bu; \n    x ^= x >> 16;\n    return x;\n}\n\n// fetch random values for RGB channels\nvec3 hash2v(uint x, uint y)\n{\n    // take a hash, split it into components\n    uint h = hash(uint(x)+(uint(y)<<16));\n    vec3 v;\n    v.x = float(h&0xffu); if(separateRGB) h >>= 8;\n    v.y = float(h&0xffu); if(separateRGB) h >>= 8;\n    v.z = float(h&0xffu);\n    \n    return v / float(0xffu);\n}\n\nvec3 triCDF(vec3 x)\n{\n    vec3 y = min(x, 1.-x);\n    y = .5 * sqrt(2.*y);\n    return mix(y, 1.-y, round(x));\n}\n\nvec3 dither(vec3 c, uvec2 xy)\n{\n    \n    // temporal dither\n    xy.x += uint(floor(animFPS*iTime)*12345.);\n    \n    // compute noise\n    vec3 h = hash2v(xy.x, xy.y);\n    h -= .25 * hash2v(xy.x-1u, xy.y);\n    h -= .25 * hash2v(xy.x+1u, xy.y);\n    h -= .25 * hash2v(xy.x, xy.y-1u);\n    h -= .25 * hash2v(xy.x, xy.y+1u);\n\n    // scale, about 2 is enough to deal \n    h *= 2.;\n    \n    float g = levels-1.;\n    \n    // expand near black to counter compression\n    vec3 f0 = max(.5-c*g, 0.); c -= .5*f0*f0;\n    // expand near white to counter compression\n    vec3 f1 = max(.5-(1.-c)*g, 0.); c += .5*f1*f1;    \n    \n    return round(c*g + h) / g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c = texture(iChannel0,uv.xy).xyz;\n    \n    if(abs(iMouse.x - fragCoord.x) < iResolution.x*.25) \n    {\n        c = dither(c, uvec2(fragCoord.xy));\n    }\n\telse if(iMouse.y < .5*iResolution.y) c = round(c*(levels-1.)) / (levels-1.);\n    \n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}