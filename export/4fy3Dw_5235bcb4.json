{"ver":"0.1","info":{"id":"4fy3Dw","date":"1713428019","viewed":162,"name":"Alien Orb (not my work)","username":"akr51","description":"Thanks The Art of Code for the YouTube tutorial","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPSILON 0.0001\n#define MAX_DST 100.0\n#define ITERATI 128\n#define PI 3.141592\n#define TAU 2.0 * PI\n\n\nmat2 rt(float t)\n{\n\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n\n}\n\n\n\nfloat smin(float a, float b, float k)\n{\n\n\n    float h = clamp(0.5 + 0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n\n}\n\n\nfloat bgyroid(vec3 sp)\n{\n\n    float cr = 10.0;\n    sp.zy *= rt(iTime * 0.2);\n    return abs(0.7 * dot(sin(sp * cr), cos(sp.yzx * cr)) / cr) - 0.02;\n\n}\n\n\nfloat map(vec3 sp)\n{\n\n    \n    float b = length(sp) - 1.0;\n    b = abs(b) - 0.03;\n    // GYROID\n    float g = bgyroid(sp);\n    \n    // bool intersection\n    b = smin(b, g, -0.05);\n    \n    float pl = sp.y  + 1.0;\n    sp.z += iTime * 0.2;\n    sp *= 2.0;\n    sp.y += sin(sp.z) * 0.01;\n    float y = abs(dot(sin(sp), cos(sp.yzx))) * 0.1;\n    pl += y;\n    float d = min(pl, b);\n    \n    return d;\n\n}\n\n\n\nvec3 nml(vec3 p)\n{\n\n\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(map(p) - vec3(map(p - d.xyy), map(p - d.yxy), map(p - d.yyx)));\n    \n\n}\n\n\n\nfloat mrch(vec3 ro, vec3 rd)\n{\n\n    float d0 = 0.0;\n    \n     for (int i = 0; i < ITERATI; i++)\n     {\n     \n         vec3 p = ro + rd * d0;\n         float ds = map(p);\n         \n         d0 += ds;\n         \n         if (d0 > MAX_DST || abs(ds) < EPSILON) break;\n         \n         \n     }\n     \n     return d0;\n}\n\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n    \n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    \n    float fov = 1.5;\n    \n    return mat3(u, v, w) * normalize(vec3(uv, fov));\n\n}\n\n\n\nfloat hash21(vec2 p)\n{\n\n    \n    p = fract(p * vec2(1233.34, 234.45));\n    p += dot(p, p + 23.4);\n    return fract(p.x * p.y);\n\n}\n\n\n\nfloat glit(vec2 p, float a)\n{\n\n    p *= 13.0;\n    vec2 id = floor(p);\n    p = fract(p) - 0.5;\n    \n    float n = hash21(id);\n    \n    float d = length(p);\n    float m = smoothstep(0.5 * n, 0.0, d);\n    m *= sin(a + fract(n * 23.1) * 3.141592 * 2.0) * 0.5 + 0.5;\n    m = pow(m, 9.0);\n    return m * 2.0;\n\n}\n\n\n// point of ray plane intersection\nvec3 raypln(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n\n\n    float t = max(0.0, dot(p - ro, n) / dot(rd, n));\n    return ro + rd * t;\n\n}\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    vec2 dm = iResolution.xy, uv = (u + u - dm) / dm.y;\n    // square dist from origin (implicit origin)\n    float cds = dot(uv, uv);\n    vec2 ms = iMouse.xy / dm;\n    \n    vec3 ro = vec3(0.0, 1.0, -3.0);\n    \n    ro.yz *= rt(-ms.y * PI + 1.0);\n    ro.y = max(-0.9, ro.y);\n    ro.xz *= rt(ms.x * TAU);\n    \n    vec3 fx = vec3(0.0, 0.0, 0.0);\n    vec3 rd = dir(uv, ro, fx);\n    \n    float d0 = mrch(ro, rd);\n    \n    vec3 cl =  vec3(0.0);\n    \n    if (d0 < MAX_DST)\n    {\n    \n        vec3 hp = ro + rd * d0;\n        vec3 n = nml(hp);\n        vec3 ld = normalize(vec3(0.0, 0.0, 0.0) - hp);\n        \n        float f = dot(n, ld) * 0.5 + 0.5;\n        \n        cl = vec3(f);\n        \n        float cd = length(hp); // distance from spatial origin (3-space)\n        \n        // plane point ht given length of hit point in relation to spatial\n        // 3D origin (0.0, 0.0, 0.0)\n        if (cd > 1.038) \n        {\n        \n            // Only one light source we do this differently.\n            \n            // think about light direction\n            // still a bit confusd why we evaluate the shape we cut\n            // out of the sphere for the shadows\n            float s = bgyroid(-ld);\n            \n            // We have cd (distance from spatial origin 3-space)\n            // we use smooth step for smooth shadows\n            float w = cd * 0.01;\n            float sh = smoothstep(-w, w, s);\n            cl *= sh * 0.9 + 0.1;\n            cl += glit(hp.xz, dot(ro, vec3(2.0))) * sh * vec3(0.0, 2.0, 0.0);\n            cl /= pow(cd, 2.0);\n            cl *= vec3(0.3, 0.5, 0.3);\n        \n        } else {\n            // hit ball instead of floor (above)\n            float sss = smoothstep(0.06, 0.0, cds);\n            sss = pow(sss, 2.0);\n            cl *= vec3(0.2, 0.6, 0.4);\n            cl += sss * vec3(0.3, 0.6, 0.3) * 2.0;\n        }\n    \n    }\n    \n    // center light\n    float lit = 0.003 / cds;\n    vec3 lcl = vec3(0.0, 4.8, 0.7);\n    \n    \n    cl += lit * smoothstep(0.0, 0.7, d0 - 3.0) * lcl;\n    \n    float ss = bgyroid(normalize(ro));\n    \n    // plane hit point of \n    vec3 pp = raypln(ro, rd, vec3(0.0), normalize(ro));\n    float sb = bgyroid(normalize(pp));\n    sb *= smoothstep(0.0, 0.4, cds); // mask center\n           \n    \n    cl += max(0.0, sb * 1.0) * 0.3;\n    \n    // glare\n    cl += lit * smoothstep(-0.0, 0.011, ss);\n   \n    \n    c_out = vec4(cl, 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}