{"ver":"0.1","info":{"id":"DtyGDy","date":"1684536888","viewed":69,"name":"Forked Fork : Glassrods ray","username":"mehow_one","description":"Using the same material to refract an image using raymarched cylinders.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"NdVfzt","parentname":"Forked : Shiny Rock"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//Image:post effect\n\n#define ITER   32.\n#define RADIUS 0.1\n\nvec4 tx(vec2 uv){return texture(iChannel0,uv);}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 m=vec2(1,iResolution.x/iResolution.y);\n    vec4 c=tx(uv);\n    float a=sin(iTime*.1)*6.283,v=0.,b=1./ITER;\n    for(int j=ZERO;j<6;j++){\n        float r=RADIUS/ITER;\n        vec2 d=vec2(cos(a),sin(a))*m;\n        for(int i=ZERO;i<int(ITER);i++){\n            v+=tx(uv+d*r*RADIUS).w*(1.-r);\n            r+=b;\n        }\n        a+=1.047;\n    }\n    v*=.01;\n    c+=v;\n    c.w=1.;\n\tfragColor=c;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//BufferA:scene\n#define R iResolution.x/iResolution.y\n//refraction index\n#define RI1 2.80\n#define RI2 2.88\n\n//settings:trace\n#define ITER   128\n#define EPS   1e-4\n#define NEAR   1.0\n#define FAR   10.0\n\n//settings:trace2\n#define ITER2  128\n#define EPS2  1e-4\n#define NEAR2 0.04\n\nconst int MAX_STEPS = 100;\nconst float MAX_DIST = 100.;\nconst float SURF_DIST = .01;\nconst float PHI = 2.39996322973;\n\n//CONSTANTS\nconst float pi=acos(-1.);\nconst float qp=pi*.25,op=qp*.5,hp=op*.5;\nconst mat2 rot4=mat2(sin(qp),cos(qp),-cos(qp),sin(qp));\nconst mat2 rot3=mat2(sin(qp+op),cos(qp+op),-cos(qp+op),sin(qp+op));\nconst mat2 rot2=mat2(sin(op),cos(op),-cos(op),sin(op));\nconst mat2 rot1=mat2(sin(hp),cos(hp),-cos(hp),sin(hp));\n\n//SDF\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//SCENE\nfloat map(vec3 p){\n    float d = MAX_DIST;\n    vec3 c = vec3(0.25,0.,0.);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float rd = sdCylinder(q,0.5,0.125);\n    d = min(d, rd);\n    \n    return d;\n}\n\n//NORMAL\nvec3 normal(vec3 p){\n    const vec2 e=vec2(-1,1);\n    return normalize(e.xxx*map(p+e.xxx*EPS)+e.xyy*map(p+e.xyy*EPS)+\n                     e.yxy*map(p+e.yxy*EPS)+e.yyx*map(p+e.yyx*EPS));\n}\n\n//RAYMARCHING\nfloat trace(vec3 ro,vec3 rd,out vec3 p,out vec3 n){\n    float t=NEAR,d;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        d=map(p);\n        if(abs(d)<EPS||t>FAR)break;\n        t+=step(d,1.)*d*.5+d*.5;\n    }\n    n=normal(p);\n    return min(t,FAR);\n}\n\n//RAYMARCHING UNDER SURFACE\nfloat trace2(vec3 ro,vec3 rd,out vec3 p,out vec3 n){\n    float t=NEAR2,d;\n    for(int i=ZERO;i<ITER2;i++){\n        p=ro+rd*t;\n        d=-map(p);\n        if(abs(d)<EPS2||d<EPS2)break;\n        t+=d;\n    }\n    n=-normal(p);\n    return t;\n}\n\n//CUBEMAP\nvec3 cubemap(vec3 d){    \n\treturn texture(iChannel1,(d.xy*2.+.5)).rgb;\n}\n\n//FRESNEL EQUATION\nfloat schlickFresnel(float ri,float co) {\n    float r=(1.-ri)/(1.+ri);\n    r=r*r;\n    return r+(1.-r)*pow(1.-co,5.);\n}\n\n//GET LIGHT PATH\nvec3 lightPath(vec3 p,vec3 rd,float ri){\n    vec3 n;\n    vec3 r0=-rd;\n    //2nd reflection\n    trace2(p,rd,p,n);\n    rd=reflect(rd,n);\n    vec3 r1=refract(rd,n,ri);\n    r1=length(r1)<EPS?r0:r1;\n    //3rd reflection\n    trace2(p,rd,p,n);\n    rd=reflect(rd,n);\n    vec3 r2=refract(rd,n,ri);\n    r2=length(r2)<EPS?r1:r2;\n    //final refraction\n    trace2(p,rd,p,n);\n    vec3 r3=refract(rd,n,ri);\n    return length(r3)<EPS?r2:r3;\n}\n\n//MATERIAL\nvec3 material(vec3 p,vec3 rd,vec3 n){\n\n    //1st reflection\n    vec3 l0=reflect(rd,n);\n\n    //cosine for fresnel\n    float co=max(0.,dot(-rd,n));\n    \n    //low frequency light path\n    float f1=schlickFresnel(RI1,co);\n    vec3 l1=lightPath(p,refract(rd,n,1./RI1),RI1);\n    \n    //high frequency light path\n    float f2=schlickFresnel(RI2,co);\n    vec3 l2=lightPath(p,refract(rd,n,1./RI2),RI2);\n\n    //dispersion\n    float a=0.;\n    vec3 dc=vec3(0);\n    vec3 r=cubemap(l0);\n    for(int i=ZERO;i<10;i++){\n        vec3 l=normalize(mix(l1,l2,a));\n        float f=mix(f1,f2,a);\n        dc+=cubemap(l)*hsv(a+.9,1.,1.)*(1.-f)+r*f;\n        a+=.1;\n    }\n    dc*=.15;\n    \n    return dc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //CAMERA SETUP\n    \n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p,n,c=vec3(0),\n         ro=vec3(0,0.,-2.),\n         rd=normalize(vec3(uv,1.5));\n    \n    //GET SURFACE\n    float t=trace(ro,rd,p,n);\n\n    //SHADING\n    float w=0.;\n    if(t>9.){\n        //background\n        c=cubemap(rd);\n    }else{\n        //diamond\n\t    c = material(p,rd,n);\n        w = smoothstep(1.60,1.61,length(c));\n    }\n    fragColor=vec4(c,0.);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//Common:snippets\n\n#define ZERO min(0,iFrame)\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define C(c) U.x-=.5; O+= char(U,64+c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/32.),dFdy(p/32.) );\n}\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    float FontSize = 72.;\n    vec2 position = vec2(-0.25+sin(iTime)*.5,-.1);\n    \n    vec2 U = ( uv - position)*64.0/FontSize;\n    C(1);//C(5);C(12);C(12);C(15);C(-32);C(23);C(15);C(18);C(12);C(4);C(-31);\n    O.x = smoothstep(0.4,0.5,O.x);\n    O = O.xxxx+texture(iChannel1,uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}