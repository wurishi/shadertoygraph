{"ver":"0.1","info":{"id":"mtXBWs","date":"1694123811","viewed":46,"name":"Perlin Noise S","username":"Domenic3000","description":"Perlin Noise Shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nint hash(vec3 p) {\n    vec3 hashVec = vec3(dot(p, vec3(127.1, 311.7, 419.2)),\n                        dot(p, vec3(269.5, 183.3, 372.9)),\n                        dot(p, vec3(416.8, 238.7, 144.2)));\n    float hashValue = fract(sin(hashVec.x + hashVec.y + hashVec.z) * 43758.5453123);\n    return int(mod(hashValue * 12.0, 12.0));\n}\n\nfloat grad(int hash, vec3 p) {\n    // 12 possible 3D gradient directions\n        const vec3[12] gradients = vec3[12](\n        vec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\n        vec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\n        vec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1));\n\n    // Reduce the hash to one of the 12 gradient directions\n    int h = hash & 11;\n\n    // Compute the dot product\n    return dot(gradients[h], p);\n}\n\nfloat noise(vec3 p) {\n    vec3 Pi = floor(p);\n    vec3 Pf = p - Pi;\n    int ix0 = int(Pi.x);\n    int ix1 = ix0 + 1;\n    int iy0 = int(Pi.y);\n    int iy1 = iy0 + 1;\n    int iz0 = int(Pi.z);\n    int iz1 = iz0 + 1;\n    float n000 = grad(hash(vec3(ix0, iy0, iz0)), Pf);\n    float n001 = grad(hash(vec3(ix0, iy0, iz1)), Pf - vec3(0, 0, 1));\n    float n010 = grad(hash(vec3(ix0, iy1, iz0)), Pf - vec3(0, 1, 0));\n    float n011 = grad(hash(vec3(ix0, iy1, iz1)), Pf - vec3(0, 1, 1));\n    float n100 = grad(hash(vec3(ix1, iy0, iz0)), Pf - vec3(1, 0, 0));\n    float n101 = grad(hash(vec3(ix1, iy0, iz1)), Pf - vec3(1, 0, 1));\n    float n110 = grad(hash(vec3(ix1, iy1, iz0)), Pf - vec3(1, 1, 0));\n    float n111 = grad(hash(vec3(ix1, iy1, iz1)), Pf - vec3(1, 1, 1));\n    float fadePfX = fade(Pf.x);\n    float fadePfY = fade(Pf.y);\n    float fadePfZ = fade(Pf.z);\n    float nx00 = mix(n000, n100, fadePfX);\n    float nx01 = mix(n001, n101, fadePfX);\n    float nx10 = mix(n010, n110, fadePfX);\n    float nx11 = mix(n011, n111, fadePfX);\n    float nxy0 = mix(nx00, nx10, fadePfY);\n    float nxy1 = mix(nx01, nx11, fadePfY);\n\n    return mix(nxy0, nxy1, fadePfZ);\n}\n\n\nfloat layeredNoise(vec3 p) {\n    float total = 0.7;\n    float frequency = 0.2;\n    float amplitude = 1.0;\n    float maxAmplitude = 0.8;\n    for(int i = 0; i < 3; i++) { // 3 octaves for example, adjust as needed\n        total += noise(p * frequency) * amplitude;\n        maxAmplitude += amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5; // each octave has half the amplitude of the previous\n    }\n    return total / maxAmplitude;\n}\n\nfloat adjustContrastAndBrightness(float n, float contrast, float brightness) {\n    return (n - 0.5) * contrast + 0.5 + brightness;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    const int GRADIENT_LENGTH = 5;\n    \n    const vec3 gradientColors[GRADIENT_LENGTH] = vec3[](\n    vec3(0.0, 0.2, 0.3),  // Color1\n    vec3(0.1, 0.1, 0.2),  // Color2\n    vec3(0.0, 0.0, 0.3),  // Color3\n    vec3(0.0, 0.3, 0.4),  // Color4\n    vec3(0.0, 0.8, 0.5)   // Color5\n    );\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x += iTime * 0.1;\n    float scale = 8.0; // or any value you find visually pleasing\n    float n = layeredNoise(vec3(uv * scale, iTime));\n    \n    // Adjust contrast and brightness\n    n = adjustContrastAndBrightness(n, 2.0, 0.4); // Example values, adjust as needed\n    // Ensure the noise value stays between 0 and 1\n    n = clamp(n, 0.0, 1.0);\n    \n    // Gradient sampling\n    float scaledNoise = n * float(GRADIENT_LENGTH - 1);\n    int index = int(scaledNoise);\n    vec3 color1 = gradientColors[index];\n    vec3 color2 = gradientColors[min(index + 1, GRADIENT_LENGTH - 1)];\n    vec3 finalColor = mix(color1, color2, fract(scaledNoise));\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}