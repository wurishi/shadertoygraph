{"ver":"0.1","info":{"id":"MsKyWw","date":"1522335006","viewed":167,"name":"Compact Disk - Diffraction ","username":"nawafuji","description":"tested diffraction prop","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\nconst float S = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n/*\nfloat distanceToNearestSurface(vec3 p){\n  return length(p) - 1.0;\n}\n*/\n\nconst float eta = 0.66;\nconst float etaR = 0.65;\nconst float etaG = 0.67;\nconst float etaB = 0.69;\n\nconst float fresnelPower = 5.0;\nconst float F = ((1.0-eta)*(1.0-eta))/((1.0+eta)*(1.0+eta));\n\n//const float gratingSpacing = 100.0 * pow(0.1, 9.0);\nconst float gratingSpacing = 100.0 * 1.0E-9;\nconst float surfaceRoughness = 1.0;\n\n// map a visible wavelength[nm] to OpenGL's RGB representation\nvec3 lambda2rgb(float lambda)\n{\n    const float ultraviolet = 400.0;\n    const float infrared = 700.0;\n    \n    float a = (lambda - ultraviolet) / (infrared - ultraviolet);\n    \n    const float C = 7.0;\n    vec3 b = vec3(a) -vec3(0.75, 0.5, 0.25);\n    return max((1.0-C*b*b),0.0);\n}\n\nfloat fog(vec3 p, vec3 e){\n    bool useFogCoordinate = true;\n    float fdepth;\n    if(useFogCoordinate)\n        fdepth = length(p-e);\n    else\n        fdepth = abs(p.z);\n        \n    float fog;\n    float density = 0.02;\n    fog = exp(-density * fdepth);\n    return clamp(fog, 0.0, 1.0);\n}\n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float rad){\n    return length(vec3(0.0) - p) - rad;\n}\n\nfloat plane(vec3 p){\n    float s = 0.0;\n    float d = abs(p.z - s);\n    return max(d,0.0);\n}\n\n\nfloat distanceToNearestSurface(vec3 p){\n\n    float dist = 10.0;\n   //\tvec3 q = vec3(mod(p.x, dist) - dist/2.0, p.yz);\n//    return min(min(cube(q), sphere(q)),plane(q));\n    //return min(cube(q), sphere(q));\n    //return plane(p);\n    //return cube(p)/sphere(p);\n\t//return max(-sphere(p),cube(p));\n    return max(sphere(p,2.0), max(plane(p), -sphere(p,0.5)));\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\nvec2 computeSphereTexCoord(vec3 p){\n    float longitude = acos(dot(vec2(0,-1), normalize(p.xz)));\n    if(p.x > 0.0)\n        longitude = 2.0*PI - longitude;\n    longitude /= 2.0*PI;\n    \n    float latitude = acos(dot(vec2(1,0), normalize(p.yz)));\n    latitude /= PI;\n    \n    return vec2(longitude, latitude);\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e){\n\n    \n    vec3 lightVector = normalize(l-p);\n    vec3 eyeVector = normalize(e-p);\n    vec3 halfVector = normalize(lightVector + eyeVector);\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,1.0,1.0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(ambient + diffuse + specular, vec3(1.0));\n}\n\nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  float dist = 0.0;\n  for(int i = 0; i < 20; i++){\n    float nearest = distanceToNearestSurface(p + dir*dist);\n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = p+dir*dist;\n                //vec3 light = vec3(100.0,\n                  //          30.0,\n                    //        50.0);\n        vec3 light = vec3(100.0*sin(iTime),\n                            30.0*cos(iTime),\n                            50.0*(1.5+cos(iTime)));\n        vec3 normal = computeSurfaceNormal(hit);\n        vec3 pixelColor = computeLambert(hit, normal, light, p);\n        vec2 texcoord = computeSphereTexCoord(hit);\n        \n        vec3 L = normalize(light - hit);\n        vec3 V = -dir;\n        vec3 H = L+V;\n        \n        vec3 T = cross(normalize(hit),normal);\n        float u = abs(dot(T,H));\n        \n        vec3 diffColor = vec3(0.0);\n        \n        const int numSpectralOrders = 3;\n        \n        for (int m=1; m<= numSpectralOrders; ++m)\n        {\n         \tfloat lambda = gratingSpacing * u / float(m);\n            diffColor += lambda2rgb(lambda);\n        }\n            \n        float w = dot(normal, H);\n        float e = surfaceRoughness * u / w;\n        vec3 hilight = exp(-e*e)*vec3(1.0,1.0,1.0);\n        \n        const float diffAtten = 0.8;\n        vec3 color = diffAtten*diffColor+hilight;\n        return color;\n        \n    } \n    dist += nearest;\n  }\n  //return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 cameraPosition = vec3( cameraDistance*sin(iTime), 0.0, cameraDistance*cos(iTime));\n\t//vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0,-1.0*cos(iTime));\n\n    vec2 mouseUV = vec2(0.5,0.5);\n    if(iMouse.z>0.0)  \n        mouseUV = 2.0*iMouse.xy/iResolution.xy-1.0;\n  \n    float d = 10.0;\n    float z = d*cos(mouseUV.y*PI/2.0);\n    vec3 cameraPosition = vec3(sin(mouseUV.x*PI/2.0) * z, d*sin(mouseUV.y*PI/2.0), cos(mouseUV.x*PI/2.0)*z);\n\tvec3 cameraDirection = -normalize(cameraPosition);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    float fovy = fovx * iResolution.y/iResolution.x;\n\tfloat ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// generate the ray for this pixel\n\tvec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n\tvec3 nright = normalize(cross(cameraUp, cameraDirection));\n    cameraUp = normalize(cross(nright, cameraDirection));\n\tvec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n\tvec3 rayDirection = normalize(pixel - cameraPosition);\n\n\tvec3 pixelColour = intersectsWithWorld(cameraPosition, rayDirection);\n            \n\n    fragColor = vec4(pixelColour, 1.0);\n}\n\n\n/** \n\n\tthe screenshot is here:\n    https://www.dropbox.com/s/ya2hhxvz1ixqipv/localShadertoysTextures.jpg?dl=0\n\n\trun fiddler (http://www.telerik.com/fiddler)\n    enable HTTPS ( & decrypt ) in fiddler options\n    go to tab shown on screenshot (autoresponder) and set options\n    add rule, then enter url to capture\n    in this example: https://www.shadertoy.com/presets/tex00.jpg\n    (first in textures set)\n\tand\n    enter url for redirect to ( could be file://... or /usr/user/...\n    \n    in this example \n    http://ogario.wpload.com/skins/amiga.png\n\n\n    image dimensions must be power of 2.\n    load image (thumbnail won't be changed) into channel\n    use iChannel as always\n\n    FB Post: \n    https://www.facebook.com/photo.php?fbid=10153170819997409&set=o.163777690435874&type=3&pnref=story\n**/\n\n","name":"Image","description":"","type":"image"}]}