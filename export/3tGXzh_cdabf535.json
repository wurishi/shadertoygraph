{"ver":"0.1","info":{"id":"3tGXzh","date":"1582387132","viewed":103,"name":"Robotwar 2020","username":"spalmer","description":"A robot battling programming game in GLES.\nMay the best robot win!   UI, game logic WIP.\nSee Image for details, BufferA for robot programs and update, Common to choose robots.\nContenders posted in comments get included.  Provide a SFW functiion name!","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["game","programming"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Similar to Core Wars, it's a game about programming robots to fight.\n// The original Robotwar by Silas Warner is long abandoned by defunct Muse, \n// but you can still play emulated in a browser here:\n// https://archive.org/details/wozaday_Robotwar\n// See also crobots, a similar game: https://en.wikipedia.org/wiki/Crobots\n\n// This simple clone has no workbench or anything.\n// Instead robots are simply programmed in GLSL,\n// in the Buffer A tab.  This just shows the game state.\n\n// This toy is a tribute to Silas Warner,\n// who got me obsessed with programming.\n// I hope I can do him justice.  Bear with me!\n\n// Presently there's much to be desired regarding the physics,\n// collision handling, bullet hit detection, graphics,\n// and just about every aspect of it.\n// Then again, the original had quite a primitive feel to it.\n\n// Currently they're just different-colored shapes.\n// This is the only way to tell them apart besides behavior.\nconst vec3[maxrobots] rhues = vec3[] (\n    vec3(1,0,0)*.9\n  , vec3(0,1,0)*.8\n  , vec3(0,0,.9)+.06\n  , vec3(1,1,0)*.7\n  , vec3(1,0,1)*.7\n  , vec3(0,1,1)*.7\n  , vec3(.3)\n//  , vec3(.7)\n);\n\n// choose shape.  handles scale relative to arena.\nfloat sdRobot(vec2 q)\n{\n    const float s = robotradius;\n    q /= s; // scale\n    // robot body shape:\n    float d = sdOcta //sdDisc //sdBox //\n        (q);     // octa seems best choice overall for now\n    // some details indicating facing direction\n    // a notch in the back:\n    float cut = -sdDisc //sdDiamo //sdBox //\n        ((q - vec2(0,-1.)) * 5.) / 5.;\n    d = max(d, cut); // sdf intersection\n    return d * s; // unscale\n}\n\n    \nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    // TODO auto-zoom-in on \"winner\" robot to let them celebrate a bit before resetting\n    if (any(greaterThan(iMouse.zw, vec2(.5)))) { // zoom lens on mouse down\n        // mostly so I can see details of the robot rendering - they're kind of small!\n        // I could probably learn something from the other guy's magnifying lens tool\n        vec2 m = mix(iMouse.xy, R*.5, -.0), pm = p - m, mp = iMouse.xy - p;\n        p = mix(p, pm / 3. + m,\n            smoothstep(R.y*.6, R.y*.5, length(mp)));\n    }\n//    if (int(p.y)/8 > nrobots) { c = vec4(.3,0,0,1); return; }\n//    c = texelFetch(iChannel0, ivec2(p)/8, 0) * .1 + .5; return; // debug Buffer A\n    vec2 uv = p / R;\n    vec2 q = (p+p-R) / R.y;\n    q *= 1.05; // slight inset scale\n    float dc = 3.4e38; int id = -1;\n  #if 1\n    bool flick = (iFrame&1)!=0;\n    for (int i = 1; i <= nrobots; ++i) {\n    \tStorage s = LoadState(iChannel0, i); // check pixel distance\n        // user data[] is not loaded in Image pass but it's still heavy fetching\n        Robot r = RobotOfState(s); // needed for aim, scan, radar, which don't have corresponding guts\n        Guts g = GutsOfState(s);\n    \tint flickid = flick ? i : -2; // flicker between robot color and orange;\n        float d;\n        if (!(g.alive >= 0.)) continue; // FIXME limits bullet & explosion after dying\n        //if (!(g.health > 0.)) continue;\n        if (g.explosiontimer > 0.) { // if shot or robot exploding, draw explosion\n            d = distance(g.explosionpos, q) - sin(66.*iTime)*exp2(.5 * g.explosiontimer) * .1;\n            if (d <= dc && dc > 0.) { dc = d; id = flickid; }                \n        }\n        if (!flick) flickid = -1; // flicker between robot color and white\n        if (g.bullet.timer > 0.) { // if shot active, draw shot\n            d = distance(g.bullet.pos, q) - .01 - .005*sin(99.*iTime);\n            if (d <= dc && dc > 0.) { dc = d; id = flickid; }\n        }\n        vec2 rq = q - g.pos;\n        if (dot(rq,rq) > robotradius*robotradius + .002) continue; // bound disc optimization\n        // draw cannon using aim\n        d = udSeg(rq, ddir(r.aim) * robotradius, vec2(0)) - .1*robotradius;\n        if (d <= dc && dc > 0.) { dc = d; id = -1; }\n        vec2 bq = rq * drot(g.bearing);\n        d = sdRobot(bq);\n        if (d <= dc && dc > 0.) { dc = d; id = i; }\n        // FIXME if program never assigns to radar, should not draw the beam\n        // draw scan beam using radar TODO don't bound clip maybe\n        //if (!flick) flickid = -1; // flicker based on scanner color and white\n        if (fract(iTime*2.) < .09 || r.scan < 0.) {\n\t        vec2 dradar = ddir(r.radar);\n    \t    d = udSeg(rq, dradar * robotradius, dradar * .2) - .3*robotradius;\n        \tif (d <= dc && dc > 0.) {\n                dc = d; \n                id = flickid; // could use *scannee* color maybe\n            } // only visible a short ways from the robot anyway due to bound disc\n        }\n    }\n  #endif\n    vec3 bgc = vec3(.6); // + .2 * cos(iTime + q.xyx + vec3(0,2,4));\n    dc *= iResolution.y; //fwidth(dc); //\n    float cov = clamp(.5 - .5*dc, 0., 1.);\n    vec3 col = vec3(.01);\n    //if (length(q) < 1.) col = vec3(1);\n    float da = sdArena(q);\n    float cova = clamp(.5 - .5*da*iResolution.y, 0., 1.); //any(greaterThanEqual(abs(q), vec2(.95))) ? 1. : 0.;\n    col = mix(col, bgc, cova);\n    //if (cova >= .5) col = bgc; //\n    vec3 rc = id >= 0 ? rhues[id-1] : id == -2 ? vec3(1.,.9,.8) : vec3(1);    \n\tcol = mix(col, vec3(rc), cov);\n    // output srgb-ish gamma\n    c = vec4(pow(col, vec3(.4545)), 1);\n}\n\n\n// TODO need score and names for the robots, health bars\n\n// TODO if click on a robot icon, the focus should go on the robot\n// camera should zoom in and focus on it\n\n// TODO there could be objects in the playfield robots can\n// \"grab\" and use as shields, clubs, etc.\n\n// TODO the modern game could have some additional sensors\n// to allow more flexibility with playfields and tactics\n// and less reliance on hardcoded positioning.\n// for instance have a Dijkstra field of enemy robots!\n// (how to exclude the scanning robot? subtract self distance?)\n// which would allow pathing toward the nearest enemy,\n// even around obstacles.  Also would allow knowing\n// distance to closest obstacle or enemy.  Would aid navigation\n// and keep battles from devolving into dumb robots unable to \n// find each other to finish each other off, ending the battle.\n// would require some state buffer for the playfield itself.\n// There's plenty of room for it presently!\n// could probably suffice with just a voronoi diagram of the enemy robots.\n// probably best to keep the arena completely concave, nowhere to hide.\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// the robots go here:\n\nvoid Veggy(inout Robot r)\n{\n//    r.turn = 0.;\n    r.radar += 30. * iTimeDelta; // ignores results\n//    r.data[0].x = pi * pow(robotradius, 2.); // he's thinking, ok?\n}\n\nvoid Dopey(inout Robot r)\n{\n    r.turn = mod(-30. * iTime, 360.); // spins in circles\n    r.vel = vec2(.1, 0); // sideways!\n    r.radar = r.aim = -r.turn;\n    if (r.scan < 0.) r.shot = -r.scan; // shoot it!\n}\n\nvoid Moron(inout Robot r)\n{\n    r.turn = mod(-20. * iTime, 360.); // spins slowly\n    r.aim = r.turn;\n    r.radar = r.turn;\n    r.vel = vec2(0., .3); // while haphazardly racing forwards!\n    if (r.scan < 0. || r.scan > .5)\n    \tr.shot = 2.; //-r.scan + .1; // fire\n}\n\nvoid Twitchy(inout Robot r)\n{\n    if (r.scan < -.2) {\n    \tr.shot = -r.scan + .02;\n    \tr.vel = vec2(0);\n    } else {\n    \tr.radar = r.aim = r.turn = rand(360.);\n    \tr.vel = vec2(0, (rand(2.) - .5) * .2);\n    }\n}\n\nvoid Watcher(inout Robot r)\n{ // demonstrates how the robot body turns slower than the cannon\n    r.aim = r.radar = r.turn = mod(-60.*iTime, 360.);\n    r.vel = vec2(0);\n    if (r.scan < 0.) // && r.shot == 0.)\n    \tr.shot = -r.scan + .01; // fire\n//    if (r.data[0].x != r.damage) { } // evasive TODO\n//    r.data[0].x = r.damage;\n}\n\nvoid Roamer(inout Robot r)\n{\n    if (r.scan < -.1) { // enemy, not too close we might blow ourselves up?\n        r.vel = vec2(0); // stop\n    \tr.shot = -r.scan + .1; //2.; // fire\n        return; // keep shooting here until it moves away\n    }\n    // trying to be semi-intelligent\n    r.turn = mod(10. * iTime + 30. * sin(.8*iTime), 360.); // spins very slowly\n    if (fract(iTime) > .75\n        && abs(r.scan) > .2) { // avoid advancing into hazards!\n    \tr.vel = vec2(0.,.2); // slowly inch forwards!\n\t    r.aim = r.turn; // aim forward so we can scan for walls too\n    } else {\n        r.vel = vec2(0); // stop\n        r.aim = sin(iTime*20.)*120. + r.turn; // scan around\n    }\n\tr.radar = r.aim;\n}\n\nvoid Bottom(inout Robot r)\n{ // trying to recreate one of the original robots' behaviors\n    //r.turn = 0.; // never turns, actually\n    if (r.scan < -.1) { // enemy, not too close we might blow ourselves up?\n        r.vel = vec2(0); // stop\n    \tr.shot = -r.scan + .1; //2.; // fire\n        return; // keep shooting here until it moves away\n    }\n    //float wantturn = ?;\n    if (r.pos.y > -.96+robotradius) {\n        r.vel = vec2(0., -.5); r.aim = 180. + 5.*r.vel.x;\n        // at this point not stopping for anybody.  Get out of my way!\n    } else {\n      if (r.scan > 0. && r.scan < robotradius * 2.) { // whoa! a wall!\n        //if (length(r.vel) < .02) {\n            r.data[0].x = r.pos.x >= 0. ? 0. : 1.;\n        //} else {\n        //\tr.vel = vec2(0);\n        //\treturn;\n        //}\n      }\n\t    r.vel = vec2(r.data[0].x*2.-1., 0);\n\t\tif (fract(12.5*iTime) > .75) {\n\t        r.aim = r.vel.x * 90.; // aim forward so we can scan for walls too\n\t    } else { // TODO maybe use r.vel.x instead of r.turn?\n\t        r.aim = r.vel.x * 3.; // scan taking into account our intended velocity\n\t    }\n    }\n\tr.radar = r.aim;\n}\n\nvoid Custom(inout Robot r)\n{\n    // YOUR ROBOT HERE\n}\n\n// for programming, use only the inout Robot r argument;\n// in particular, use of texelFetch or texture to \n// sniff other robots' data is forbidden!  Guts, \n// LoadState, and SaveState are specifically not to be used.\n// Use of other helpers in Common such as\n// ddir, drot, rand, robotradius, movespeed etc. are ok.\n// Use of shadertoy.com uniforms such as iTime is fine.\n// Use of shadertoy.com uniform iMouse is disallowed,\n// since the point is not player-controlled robots,\n// but player-programmed robots!\n// Making helper functions is fine, but none of these use any.\n// You can persist state from frame to frame in the\n// general purpose vec4 data[] array \"registers\"\n// Unfortunately there's a lot more work to do for\n// robot authors in this system; for instance,\n// where the original had labels and subroutines\n// useful for state management, here everything runs\n// every frame, and any state for behavior must\n// be managed in the data[] array as some sort\n// of software state machine.  e.g.  data[0].x = 0.\n// for patrol, = 1. when alerted to a robot presence,\n// = 2. for evasive maneuvers when taking fire.\n// bonus points for not hanging the gpu in fullscreen!\n\n// see https://www.shadertoy.com/view/wtG3WW where I devised this:\n// query if ray intersects disc of given radius at origin as efficiently as possible\nbool idisc(vec2 ro, vec2 rd, float radius)\n{\n    float vc = dot(ro, rd), vr = dot(ro, ro) - radius*radius;\n    return (vc < 0. && vr * dot(rd, rd) <= vc * vc) || vr <= 0.;\n}\n\n// FIXME every damn time I use robotguts I wind up off-by-one due to the \n// changeup between 1-based and 0-based indexing!  FIXME FIXME FIXME\nGuts robotguts[nrobots];\n\nfloat traceArena(vec2 ro, vec2 rd)\n{ // FIXME hardcoded to square arena shape ray trace; TODO need disc, octa\n    // FIXME idk why I need so many abs, seems wrong, but this finally works at least:\n    vec2 q = abs(sign(rd) - ro) / abs(rd); //(sign(rd) - ro) / rd; //\n    return min(q.x, q.y);\n}\n\nfloat RadarScan(vec2 ro, vec2 rd, int vi)\n{\n    float dmax = 3.4e38, dc = dmax;\n    for (int i = 1; i <= nrobots; ++i) {\n        if (i == vi) continue; // ignore self\n        if (!(robotguts[i-1].alive >= 0.) || robotguts[i-1].health <= 0.) continue;\n        vec2 p = ro - robotguts[i-1].pos; // FIXME off by one wut is this one-based bs anyway\n        if (idisc(p, rd, robotradius)) {\n            dc = min(dc, length(p));\n        }\n    }\n    return dc != dmax\n        ? min(-.001, 2. * robotradius - dc)\n        : max( .001, traceArena(ro, rd) - robotradius);\n}\n\nvoid CheckStatus(inout Guts g)\n{\n    if (g.health <= 0.) {\n        g.alive = -1.;\n        g.health = 0.;\n    }\n}\n\nvoid TakeDamage(float dmg, inout Guts g, int v)\n{\n    g.health -= dmg;\n    g.health = max(0., g.health);\n    float tdmg = .01 + dmg / 15.;\n    if (g.explosiontimer < tdmg\n      && (g.health < .1 || dmg > 1.\n          || (iFrame&7) == 0)) {\n        g.explosionpos = g.pos + .7*robotradius * rdir(rand() * tau);\n        g.explosiontimer = tdmg;\n    }\n    CheckStatus(g);\n}\n\n// push away from colliding object given distance (negative if overlapping)\n// and normal (away from colliding object), computing damage taken\n// and adjusting position and velocity accordingly.\nvoid Impact(inout vec2 p, inout vec2 v, inout float damage\n            , vec2 v_other, vec2 normal, float cdistance)\n{\n \t// HACK for now ignore v_other (other robot velocity)\n    if (cdistance < 0.) {\n        damage += .04 * distance(v, v_other);  // caller handles guts, explosions, etc.; just accumulate\n        v -= v; // HACK just stop for now // TODO along normal between centers\n        p -= cdistance * normal; // de-overlap\n    }\n}\n\n// returns \"damage\" caused/taken by impact\n// p = robot arena position, v = robot velocity\nfloat Collide(inout vec2 p, inout vec2 v, int vi)\n{\n    float dmax = 3.4e38, dc = dmax, damage = 0., d;\n    for (int i = 1; i <= nrobots; ++i) {\n        if (i == vi) continue; // ignore self\n        Guts gother = robotguts[i-1];\n        if (!(gother.alive >= 0.)) continue; // ignore if dead\n        vec2 p = p - gother.pos\n            , v_other = gother.vel;\n        d = length(p) - 2. * robotradius;\n        Impact(p, v, damage, v_other, normalize(-p), d);\n    }\n    d = sdArena(p) - robotradius;\n    Impact(p, v, damage, vec2(0), normalize(-p), d);\n    return damage;\n}\n\nfloat wrapangle(float deg) \n{\n    deg = mod(deg, 360.);\n    //if (abs(deg) > 180.) deg -= 360. * sign(deg);\n         if (deg < -180.) deg += 360.;\n    else if (deg >  180.) deg -= 360.;\n    return deg;\n}\n\nvoid CheckEnemyFire(inout Guts g, int v) \n{\n    for (int i = 1; i <= nrobots; ++i) {\n    \tif (i == v) continue; // our own explosions can't hurt us - can't shoot ourselves either\n        Guts e = robotguts[i-1]; // ARGH!\n        Bullet bullet = e.bullet;\n        if (bullet.timer > 0.) \n        \tif (distance(bullet.pos, g.pos) < .02 + robotradius)\n            \tTakeDamage(3., g, i); //v); //\n        if (e.explosiontimer > 0.)\n        \tif (distance(e.explosionpos, g.pos) < .12 + robotradius) {\n            \tTakeDamage(.2, g, i); //v); //\n\t        }               \n    }\n}\n\nvoid MoveRobot(inout Robot r, inout Guts g, int v)\n{\n    mat2 facing = drot(g.bearing); // convert local strafe dir to world dir\n    vec2 wantvel = r.vel;\n    if (dot(wantvel, wantvel) > 1.) wantvel = normalize(wantvel);\n    wantvel = facing * (wantvel * movespeed);\n    g.vel = mix(wantvel, g.vel, exp2(-moveaccel * iTimeDelta));\n//    g.pos = -.0 + .5*rdir(float(v)*2.1 + iTime); // HACK\n    g.pos += g.vel * iTimeDelta;\n    float dmg = Collide(g.pos, g.vel, v);\n    if (dmg > 0.) TakeDamage(dmg, g, v);\n    r.pos = g.pos;\n    r.vel = g.vel * facing / movespeed;\n    // could go in own function but guess it's part of movement\n    g.bearing = wrapangle(g.bearing);\n    r.turn = wrapangle(r.turn);\n    // FIXME way too complicated considering we already did something just like it inside wrapangle twice!\n    if (r.turn - g.bearing > 180.) r.turn -= 360.;\n    else if (r.turn - g.bearing < -180.) r.turn += 360.;\n    g.bearing = mix(r.turn, g.bearing, exp2(-turnrate * iTimeDelta));\n//    r.turn = g.bearing; // feedback, but is it necessary? complicates things, must continually reassign to accomplish a turn\n}\n\n// for instance setting r.shot to 1e-4 should blow up immediately, next frame.\n// setting r.shot to 2. should make it all the way across the arena and hit the wall.\n// distance involved corresponds to what radar returns, I guess, or should!\nvoid CannonFire(inout Robot r, inout Guts g, int v)\n{\n    if (g.explosiontimer > 0.) {\n        // pos += sin(blah)\n        g.explosiontimer = max(0., g.explosiontimer - iTimeDelta);\n    }\n    if (g.bullet.timer > 0.) {\n        // TODO detect impact with robots or arena wall\n        // presently they just use timed explosive shells\n\t    g.bullet.pos += bulletspeed * ddir(g.bullet.dir) * iTimeDelta;\n        bool bhit = false;\n        for (int i = 1; i <= nrobots; ++i)\n            if (i != v) // don't shoot ourself\n            \tbhit = bhit || distance(g.bullet.pos,robotguts[i-1].pos) < robotradius + .003; // FIXME need bulletsize constant\n        if (!bhit && sdArena(g.bullet.pos) < .002) bhit = true;\n        if (bhit)\n            g.bullet.timer = 0.;\n        g.bullet.timer = max(0., g.bullet.timer - iTimeDelta);\n        if (g.bullet.timer == 0.) {\n            // TODO explode!\n            g.explosionpos = g.bullet.pos;\n            g.explosiontimer = .5;\n        }\n        r.shot = -g.bullet.timer; // definitely don't want to shoot again until bullet expires.\n    }\n    float wantshot = r.shot;\n    g.reload = max(0., g.reload - iTimeDelta);\n    r.shot = -g.reload;\n    if (wantshot <= 0.) return;\n    if (g.reload > 0.) return; // still reloading!\n    // TODO use r.aim to fire bullet\n    g.bullet.pos = g.pos + 1.1 * robotradius * ddir(r.aim);\n    g.bullet.dir = wrapangle(r.aim);\n    // TODO calibrate timer with distance using shotspeed\n    g.bullet.timer = min(2.8, wantshot + robotradius*2./3.) / bulletspeed; // - robotradius?*.5? idk\n\tr.shot = -(g.reload = 2.8 / bulletspeed);\n}\n\nvoid UpdateRobot(inout Robot r, inout Guts g, int v)\n{\n    // update guts state\n    MoveRobot(r, g, v);\n    r.scan = RadarScan(g.pos, ddir(r.radar), v);\n    CannonFire(r, g, v);\n    CheckEnemyFire(g, v);\n    // update robot-code-visible state based on guts\n    CheckStatus(g);\n    r.damage = 100.-g.health; // health is authoritative\n}\n\nvoid LoadUserData(sampler2D ch, int v, inout vec4[SU] data)\n{\n    for (int u = 0; u < SU; ++u)\n        data[u] = texelFetch(ch, ivec2(u,v), 0);\n}\n\n// pack\nvoid StateOfRobot(out Storage s, Robot r, Guts g)\n{\n    for (int i = 0; i < r.data.length(); ++i) // SU\n        s[i] = r.data[i];\n    s[SR + 0].xy = r.pos;\n    s[SR + 0].zw = r.vel;\n    s[SR + 1].z = r.scan;\n    s[SR + 1].w = r.damage;\n    s[SR + 2].x = r.aim;\n    s[SR + 2].y = r.turn;\n    s[SR + 2].z = r.radar;\n    s[SR + 2].w = r.shot;\n    s[SG + 0].xy = g.pos;\n    s[SG + 0].zw = g.vel;\n    s[SG + 1].xy = g.bullet.pos;\n    s[SG + 1].z  = g.bullet.dir;\n    s[SG + 1].w  = g.bullet.timer;\n    s[SG + 2].xy = g.explosionpos;\n    s[SG + 2].w = g.explosiontimer;\n    s[SG + 3].x = g.bearing;\n    s[SG + 3].y = g.health;\n    s[SG + 3].z = g.reload;\n    s[SG + 3].w = g.alive;\n}\n    \nvoid SaveState(inout vec4 c, int u, Storage s)\n{\n    c = s[u];\n}\n\n\nvoid TickRobot(inout Storage s, ivec2 p) // p.x really not needed FIXME fix arg\n{\n    int v = p.y;\n\tRobot r = RobotOfState(s);\n    // only place we ever need load or copy user data state is here\n    LoadUserData(iChannel0, v, r.data);\n    // HACK attempting an optimization here\n   \tbool alive = r.damage < 100.; //true; // haven't unpacked guts yet!\n    switch (v) { // support as many robots as you like\n\t    case 1: if (alive) Robot1(r); break;\n\t    case 2: if (alive) Robot2(r); break;\n\t    case 3: if (alive) Robot3(r); break;\n        case 4: if (alive) Robot4(r); break;\n        case 5: if (alive) Robot5(r); break;\n        case 6: if (alive) Robot6(r); break;\n        case 7: if (alive) Robot7(r); break;\n        case 8: if (alive) Robot8(r); break;\n        default: return; // if you fail to uncomment enough, they'll just be zombies\n\t}\n    Guts g = GutsOfState(s);\n    if (g.alive >= 0.) {\n    \t// FIXME but truly we should allow bullets and \n    \t// explosions to happen even if the robot is dead.\n        if (p.x >= SU) //  actual robot state (not user data)?\n      \t\tUpdateRobot(r, g, v);\n\t   \tStateOfRobot(s, r, g);    \n    }    \n}\n\n// game logic unrelated to any particular robot\n// runs as if it were a robot at index 0 (and uses BufferA row 0)\nvoid GameState(inout Storage s)\n{\n    // detect a winner if only one\n    // left alive, or\n    // TODO declare ties, etc.\n    // TODO keep score.\n    // TODO timeout for Veggy vs. Veggy stalemates\n    int nalive = 0;\n    for (int i = 1; i <= nrobots; ++i) {\n        Guts g = robotguts[i-1];\n        if (g.alive >= 0.) ++nalive;\n    }\n    if (nalive < 2) {\n        if ((nalive < 1 && fract(iTime) < .06) // pause\n            || mod(iTime, 5.) < .06) // there must be only one!\n        s[0] = vec4(0,0,0,1); // raise reset flag\n    }// else if (s[0].w > 0.) // clear reset flag next frame\n    //    s[0] = vec4(0); // Init will clear it for us\n    // else carry on with battle\n}\n\nvoid TickGame(inout vec4 c, ivec2 p)\n{\n    Storage s; // = LoadState(iChannel0, v);\n    if (p.y > nrobots // unused BufferA rows\n    \t|| p.x > s.length()) return; // no data pixels after that\n    // since every robot needs every other robot's state,\n    // pretty much every frame, may as well load them all \n    // and unpack once here into a global array of Guts\n    // so other routines won't duplicate loading/unpacking\n    for (int i = 1; i <= nrobots; ++i) {\n        Storage sn = LoadState(iChannel0, i);\n        if (i == p.y) s = sn;\n        robotguts[i-1] = GutsOfState(sn);\n    }\n    c = texelFetch(iChannel0, p, 0); // individual texel will likely get overwritten, but you never know\n    if (p.y == 0)\n        GameState(s);\n    else\n        TickRobot(s, p);\n    SaveState(c, p.x, s);\n}\n\nvoid InitRobot(inout vec4 c, ivec2 p)\n{\n    c = vec4(0); // all robots registers start out zero\n    if (p.y < 1 || p.y > nrobots) return;\n    Robot r; Guts g;\n    g.pos = .5*rdir(float(p.y)*1.1 + 5.*iDate.w); // starting locations\n    r.pos = g.pos;\n    g.alive = 1.; // true\n    g.health = 100.;\n    g.bullet.timer = 0.;\n    Storage s;\n    StateOfRobot(s, r, g);\n    SaveState(c, int(p.x), s);\n}\n\nvoid mainImage(out vec4 c, vec2 q)\n{\n    rseed = mod(543.*iTime + iDate.w, 64.);\n    ivec2 p = ivec2(q);\n    // should we should start a new battle?  check game logic reset flag\n    if (iFrame == 0 || texelFetch(iChannel0, ivec2(0), 0).w > 0.)\n    \tInitRobot(c, p);\n    else \n        TickGame(c, p);\n}\n\n\n// FIXME there's a major bug where robots can sometimes \"just die\"\n// for no apparent reason; maybe colliding with ghosts, or\n// perhaps shooting themselves somehow?  very odd.\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// see also some salvaged documentation at:\n// https://corewar.co.uk/robotwar/robotwar.txt\n// yeah but we'll just be using GLSL ES\n// instead of robot assembly language of yore.\n\n// maxrobots up to 8 should be supported fairly easily but probably won't run well with more.\n// The original game only supported 5.\nconst int maxrobots = 7; // currently would need a strong gpu to handle much more in fullscreen\n// when changing nrobots, also change nhues in Image and the AI program switch in BufferA\nconst int nrobots = 5;   // nrobots must be <= maxrobots presently\n// there are only a few programs currently:\n// But you can make one and change nrobots!\n// or reassign these, or whatever! Pick all Veggy!\n#define Robot1 Bottom //Roamer //Custom //\n#define Robot2 Roamer //Veggy //Dopey //\n#define Robot3 Moron //Veggy //Watcher //\n#define Robot4 Watcher //Veggy //Twitchy //\n#define Robot5 Dopey //Twitchy //Roamer //\n#define Robot6 Veggy //Dopey //\n#define Robot7 Veggy //Custom //\n#define Robot8 Veggy //Custom //\n\nconst float robotradius = .06;\nconst float movespeed = .8; // see robotradius\nconst float moveaccel = 4.1;\nconst float bulletspeed = 2.; // speed is always the same; give them a chance to miss or dodge!\nconst float turnrate = 12.5;\n\n// produces rotations that correspond to the directions produced by rdir\n// versus straight up (top of screen) at angle 0, which gives cs=(0,1)\n// I know, I know, I'm confused AF too!  \n// especially since I'm not using the original arena dimensions of 0..256\n// maybe I should switch it all to a more conventional system/handedness?\n// kind of started off conventional and adapted it all to clockwise!\nmat2 mrot(vec2 cs)\n{\n//    return mat2(cs.x, cs.y, -cs.y, cs.x); // \"regular\" rotation\n    return mat2(cs.y, -cs.x, cs.x, cs.y); // \"robot\" rotation - cs is actually sin+cos, and it's reversed\n}\n\nconst float pi = 3.1415927, halfpi = 1.5707963, tau = 6.2831853;\n// handles things like aim\nvec2 rdir(float rad)\n{\n    return sin(vec2(0, halfpi) + rad);\n}\n\nvec2 ddir(float deg)\n{\n    return rdir(radians(deg));\n}\n\nmat2 mrot(float rad)\n{\n    return mrot(rdir(rad));\n}\n\nmat2 drot(float deg)\n{\n    return mrot(ddir(deg));\n}\n\nfloat rseed = 0.;\n\n// unlike original, just a simple random [0..1) fraction prng.\n// calling multiple times will return different values.\nfloat rand()\n{\n    return fract(sin((rseed += 77.) * 7777.));\n}\n// a random number between [0, rmax)\nfloat rand(float rmax)\n{\n    return rand() * rmax;\n}\n\n// SDF functions\n// for rendering and collision\n// doubt robots would use these\n\n// iq's, mostly\nfloat udSeg(vec2 q, vec2 a, vec2 b)\n{\n    q -= a; b -= a;\n    return length(q - b*clamp(dot(q,b)/dot(b,b), 0., 1.));\n}\n\n// bunch of shape stuff from https://www.shadertoy.com/view/WtVGWm\n\nfloat sdBox(float p)\n{\n    return abs(p) - 1.;\n}\n\nfloat sdDisc(vec2 q)\n{\n    return length(q) - 1.;\n}\n// normal of segment\nvec2 nseg(vec2 a, vec2 b) // a should not equal b\n{\n    vec2 d = normalize(b - a); // maybe nan!\n \treturn vec2(-d.y, d.x); // perp 90 degree rotation\n}\n\nfloat sdSlab(vec2 q, vec2 n)\n{\n    return sdBox(dot(q, n));\n}\n\nfloat sdBox(vec2 q)\n{\n    float d = sdSlab(q, vec2(1, 0));\n    d = max(d, sdSlab(q, vec2(0, 1)));\n    if (d > 0. && // early out, don't bother unless outside\n    \tall(lessThan(vec2(1.), abs(q)))) // in corner voronoi regions\n        d = distance(abs(q), vec2(1)); // must replace distance\n    return d;\n}\n\nfloat sdDiamo(vec2 q)\n{\n    const float rh = sqrt(.5); // rh corrects scale due to use of taxi metric\n    float d = sdSlab(q, vec2(1, 1))*rh;\n    d = max(d, sdSlab(q, vec2(1,-1))*rh);    \n    if (d > 0. && // early out, don't bother unless outside\n    \tabs(dot(abs(q), vec2(1,-1))) > 1.)\n        d = min(distance(abs(q), vec2(1,0))\n    \t\t  , distance(abs(q), vec2(0,1)));\n    return d;\n}\n\nfloat sdOcta(vec2 q)\n{\n    float d = -3.4e38;\n    d = max(d, sdSlab(q, vec2(1   )*.707107));\n    d = max(d, sdSlab(q, vec2(1,-1)*.707107));\n    d = max(d, sdSlab(q, vec2(        1, 0)));\n    d = max(d, sdSlab(q, vec2(        0, 1)));\n    return d;\n}\n\n\n// for collision detection and rendering\nfloat sdArena(vec2 q)\n{\n    return -\n        sdBox //sdDisc //sdOcta //\n        (q);\n}\n\n// I believe a fully concave arena is best\n// so that robots cannot hide from each other.\n// In any case the arena is inverted here\n// versus the shape sdf, which should probably be convex.\n\n\n// 32 was thrashing the texture cache a bit; trying smaller register footprint\nconst int nregisters = 10; //12; //8; //16; //32; //\n#define Storage vec4[nregisters]\n// these are arbitrary but must fit in Storage\n#define SU (nregisters - 3 - 4) // how many data registers\n#define SR SU //7 //26 //(nregisters - 4 - 3) //\n#define SG (SR + 3) //(nregisters - 4) //\n// I mean I could allocate the entire row, or any block,\n// but only so much will actually be useful.\n    \n// I guess it all is technically writable, \n// but some of it (pos) won't have any effect,\n// and much of it (inputs) will merely be \n// replaced by next frame's inputs anyway.\n\n// angles are in clockwise degrees, 0 is up, 90 is right.\nstruct Robot\n{\n    vec4[SU] data; // programs can store values here from frame to frame\n    vec2 pos; // position (-1..1) within arena according to gps; just a copy of guts\n    vec2 vel; // present velocity (-1..1) in robot space, rotated by turn angle; allows strafe.  subsumes speed (it's just vel.y)\n    float aim; // angle of cannon, relative to \n    float turn; // angle (bearing?) of robot body; facing; may want separate variable for feedback of actual state; this is *desired* facing! not to mention there's the actual current facing in guts\n    float radar; // angle of scanner\n    float scan; // prior frame's radar's result, distance to wall (+) or robot (-)\n    float damage; // percent; can track to detect accumulation\n    float shot; // store to fire with a distance-based timer (1 for full range) if 0 it's ready to fire.\n}; // needs 3 vec4 slots in addition to the user data\n    \n// maybe split vel and throttle control?\n\n// TODO one simple idea I just had\n// allocate a small block of SDF data for each robot\n// to allow them to edit their own appearance!\n// probably needn't be very high resolution.\n// Maybe a (symmetrical) polygonal outline, mirrored 4 quadrants?\n// nah, they'd cheat and make invisible robots.\n\n\nstruct Bullet\n{\n    vec2 pos;\n    float dir; // could precompute sin&cos, but don't want to store them\n    float timer; // seconds til detonation - TODO could maybe cram the explosion timer in here too if necessary\n}; // needs a slot\n\n// robot internal state that programs don't see and cannot write (unless you cheat!)\nstruct Guts\n{\n    vec2 pos; // the actual state\n    vec2 vel;\n    Bullet bullet; // just one at a time; will always impact before reload can happen anyway due to slow reload rate\n    vec2 explosionpos;\n    float explosiontimer;\n    float bearing; // current facing angle\n    float health; // = 100 - damage\n    float reload; // time til reload, 0 if ready to fire\n    float alive; // sign flag, < 0 if dead\n}; // needs 4 vec4 slots counting the bullet\n\n    \n// load/store\n\nStorage LoadState(sampler2D ch, int v)\n{\n    Storage s;\n    for (int u = SU; u < s.length(); ++u)\n        s[u] = texelFetch(ch, ivec2(u,v), 0);\n    return s;\n}\n\n// unpack \n\n// specifically does *not* copy user data; often not needed\nRobot RobotOfState(Storage s)\n{\n    Robot r;\n    r.pos    = s[SR + 0].xy;\n    r.vel    = s[SR + 0].zw;\n    r.scan   = s[SR + 1].z; // x and y are free\n    r.damage = s[SR + 1].w;\n    r.aim    = s[SR + 2].x;\n    r.turn   = s[SR + 2].y;\n    r.radar  = s[SR + 2].z;\n    r.shot   = s[SR + 2].w;\n    return r;\n}\n\nGuts GutsOfState(Storage s)\n{\n    Guts g;\n    g.pos     = s[SG + 0].xy;\n    g.vel     = s[SG + 0].zw;\n    g.bullet.pos   = s[SG + 1].xy;\n    g.bullet.dir   = s[SG + 1].z;\n    g.bullet.timer = s[SG + 1].w;\n    g.explosionpos = s[SG + 2].xy;\n    g.explosiontimer = s[SG + 2].w; // z is free\n    g.bearing = s[SG + 3].x;\n    g.health  = s[SG + 3].y;\n    g.reload  = s[SG + 3].z;\n    g.alive   = s[SG + 3].w;\n    return g;\n}\n\n","name":"Common","description":"","type":"common"}]}