{"ver":"0.1","info":{"id":"tdcfz7","date":"1604654957","viewed":150,"name":"Gold_monyaru","username":"tono","description":"Gold","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["monyaru"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float t = 0.;\nfloat pi = acos(-1.);\n\n#define MAX 100.\n\nvec2 min2(vec2 a,vec2 b)\n{\n    if(a.x < b.x){\n        return a;\n    }\n    return b;\n}\n\nfloat rand(vec2 a)\n{\n    return fract(sin(dot(a,vec2(123.45,67.89))*123.4 ));\n}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//カンニングします\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nvec3 simplex3dVector(vec3 p)\n{\n    float s = simplex3d(p);\n    float s2 = simplex3d(random3(vec3(p.y,p.x,p.z)) + p.yxz);\n    float s3 = simplex3d(random3(vec3(p.z,p.y,p.x)) + p.zyx);\n    return vec3(s,s2,s3);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(100,0.);\n    p.xy *= rot(sin(p.z/3.)/2.);\n    d.x = p.y + .7;\n    \n    if(d.x < 1.)\n    {\n        d.x -= simplex3d(vec3(p.x,0.,p.z ) * 40. + t* .8)/100.;\n        d.x -= simplex3d(vec3(p.x,0.,p.z ) * .6)/50.;\n        d.x -= simplex3d(vec3(p.x,0. + t / 1.,p.z ) * .2)/1.1;\n        d.y = 0.;\n    }\n    vec3 p2 = p;\n    p.xy *= rot(-floor(p.z/pi));\n    p = cos(p) * 1.;\n    p.y -= sin(floor(p2.z/pi) + t);\n    p.x -= cos(floor(p2.z/pi) + t/2.) * .1;\n    d = min2(vec2(length(p) - .7,1.),d);\n    d.x *= .9;\n    return d;\n}\n\n\nvec2 march(vec3 cp,vec3 rd)\n{\n    float depth = 0.;\n    float id = 0.;;\n    for(int i = 0 ; i < 256 ; i++)\n    {\n        vec3 rp = rd * depth + cp;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.0001)\n        {\n            depth *= -1.;\n            id = d.y;\n            break;\n        }\n        if(depth > MAX){break;}\n        depth += d.x;\n    }\n    depth *= -1.;\n    return vec2(depth,id);\n}\n\nfloat map2(vec3 p)\n{\n    vec3 p2 = p;\n    p.xy *= rot(floor(p.z/pi));\n    p = cos(p) * 1.;\n    p.y -= sin(floor(p2.z/pi) + t);\n    p.x -= cos(floor(p2.z/pi) + t/2.) * .1;\n    return length(p) - .7;\n}\n\nfloat water(vec3 cp , vec3 rd,float maxdepth)\n{\n    float ac = 0.;\n    float depth = 0.;\n    for(int i = 0; i < 66 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        \n       // rp = simplex3dVector(rp);\n        float d = simplex3d(rp + vec3(0.,-t/8.,0.)) - .1  * abs(sin(0.7 * 1.2 + pi/2. * (simplex3d(rp /10.) - .5 )) - .1);\n        d = min(d,map2(rp ));\n        d = max(0.01,abs(d));\n        ac += exp(-d * .3);\n        if(depth > maxdepth){break;}\n        depth += d;\n    }\n    return ac - depth * depth;\n}\n\nvoid getCamra(vec2 p,out vec3 cp,out vec3 rd)\n{\n    t = iTime;\n    vec3 forward = vec3(0.,0.,0.);\n    forward.z += t/2.;\n    vec3 target = vec3(0.,0.,0.) + forward;\n    cp = vec3(0.,0.,-15.) + forward;\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    p.y *= -1.;\n    float fov = 2. - dot(p,p)/5.;\n\t//fov  = 2. - dot(p,p) * 6.;\n    rd = normalize(p.x * cs + p.y * cu + cd * fov);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 cp,rd;\n    getCamra(p,cp,rd);\n    vec2 d = march(cp,rd);\n\tvec3 color = vec3(0.);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = d.x * rd + cp;\n        vec2 e = vec2(0.,0.001);\n        vec3 N = normalize(vec3( map(pos).x - vec3(map(pos - e.yyx).x,map(pos - e.yxy).x , map(pos - e.xyy).x) ));\n     \t//color = N;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        sun.xz *= rot(2.1);\n        float diff = mix(max(dot(sun,N),0.),1.,0.);\n        float aor = d.x/MAX;\n        float ao = exp2(pow(max(0.,1. - map(pos + N * aor).x/aor),1.));\n        float fr = pow(1. + dot(N,rd),4.);\n        float spo = mix(3.,10.,d.y);\n        float sss = smoothstep(0.,1.,map(pos+sun * .4).x / .4);\n        float sp = pow(max(dot(reflect(-sun,N),-rd),0.),spo);\n        vec3 albedo = mix(vec3(.7,0.7,.3),vec3(1.,1.,.2),d.y);\n       // color = vec3(.6) * diff;\n        color = mix(sp * albedo + albedo * ao * (diff + sss),color,min(fr,.5));\n        float m = 1. - exp(-.000003 * d.x * d.x * d.x);\n   \t\tcolor = mix(color,vec3(0.),m);\n    }else{\n        d.x = MAX;\n    }\n    float ac = water(cp,rd,d.x);\n    vec3 wcolor = normalize( vec3(1.,.3,0.) ) * max(0.,ac)/180.;\n    color = clamp(color/2. + wcolor,vec3(0.),vec3(1.));\n //   color *= vec3(1.5,.5,1.);\n    color = clamp(color,0.,1.);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}