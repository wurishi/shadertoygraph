{"ver":"0.1","info":{"id":"sd3fzB","date":"1656687902","viewed":102,"name":"Easing Functions - interpolation","username":"jorgemoag","description":"Easing functions\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["easing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/****************************/\n/***** EASING FUNCTIONS *****/\n/****************************/\n\n#define PI 3.1415926\n\n// sine\n\nfloat easeInSine(float x) {\n    return 1. - cos((x * PI) / 2.);\n}\n\nfloat easeOutSine(float x) {\n    return sin((x * PI) / 2.);\n}\n\nfloat easeInOutSine(float x) {\n    return -(cos(PI * x) - 1.) / 2.;\n}\n\n// quad\n\nfloat easeInQuad(float x) {\n    return x * x;\n}\n\nfloat easeOutQuad(float x) {\n    return 1. - pow(1. - x, 2.);\n}\n\nfloat easeInOutQuad(float x) {\n    return x < 0.5 ? \n            2. * x * x : \n            1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\n// cubic\n\nfloat easeInCubic(float x) {\n    return x * x * x;\n}\n\nfloat easeOutCubic(float x) {\n    return 1. - pow(1. - x, 3.);\n}\n\nfloat easeInOutCubic(float x) {\n    return x < 0.5 ? \n            4. * x * x * x : \n            1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\n\n/***********************/\n/***** MAIN INTERP *****/\n/***********************/\n\nfloat interp(float t) {\n    return easeInOutQuad(t);\n}\n\n/**************************************/\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a, ap = p - a;\n    float h = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n    return distance(p, a + h * ab);\n}\n\nfloat dotted(vec2 p, float n, float w, float r) {\n    return step(abs(length(p)-r), w) * step(w, sin(n*atan(p.y/p.x)));\n}\n\nvec3 grid(vec2 p, float y, float t) {\n    vec3 col = vec3(0.);\n    \n    col += vec3(1.,0.,0.) * step(p.y, 0.01);\n    col += vec3(0.,1.,0.) * step(p.x, 0.01);\n    \n    vec3 bc = mix(vec3(1., 0.7, 0.3), vec3(0.5, 0.3, 0.7), y);\n    \n    col += bc*step(abs(p.y - y) - .0125, 0.);\n    \n    vec2 q = fract(10.0*p);\n    col += vec3(0.025) * step(q.x, 0.1);\n    col += vec3(0.025) * step(q.y, 0.1);\n    \n    col = mix(col, vec3(0.), step(0., p.x - 1.05));\n    \n    vec2 c1 = vec2(1.4, 0.2), c2 = vec2(1.4, 0.8);    \n    col += vec3(1.) * dotted(p - c1, 10., 0.005, .125);\n    col += vec3(1.) * dotted(p - c2, 10., 0.005, .125);\n    \n    vec2 C = mix(c1, c2, t);\n    bc = mix(vec3(1., 0.7, 0.3), vec3(0.5, 0.3, 0.7), t);\n    col += bc * step(length(p - C) - .105, 0.);\n    \n    \n    col = max(bc*step(length(p - vec2(t, y)) - .03, 0.), col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float t = fract(iTime);\n    \n    col = grid(uv, interp(uv.x), interp(t));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}