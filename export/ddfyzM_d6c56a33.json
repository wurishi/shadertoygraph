{"ver":"0.1","info":{"id":"ddfyzM","date":"1686687413","viewed":36,"name":"NoCol - NiceBug","username":"Perseid","description":"Based on this 'bug' : https://www.youtube.com/watch?v=SqpIcsN0FTI&pp=ygUJbm9jb2wgYnVn","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["collision","simulation","particle","nocol"],"hasliked":0,"parentid":"DsfyR7","parentname":"Particle simulation"},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float movingDisk(in vec2 p, in vec2 o, in float r, in vec2 v, in float dt) {\n    vec2 p0 = p - o, p1 = v * dt;\n\n    float a = dot(p1, p1);\n    float b = dot(p0, p1);\n    float c = dot(p0, p0) - r * r;\n\n    float h = b * b - a * c;\n    \n    vec2 t = clamp((vec2(-1.0, 1.0) * sqrt(h) - b) / a, 0.0, 1.0);\n    return (t.y - t.x)*step(0.0, h);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n\n    float distanceField = mapEnvironment(uv);\n    fragColor =  vec4(.0, .0, .0, 1.0);\n    fragColor.rgb = mix( vec3(.5,0.,0.), fragColor.rbg, 1.-(getStableCount()/5.) );\n    \n    fragColor.rgb = mix( BallColor , fragColor.rgb, 1.-getTrail(ivec2(fragCoord))/30. );\n    \n    for(int i = 0; i < BALL_COUNT_X; ++i)\n    for(int j = 0; j < BALL_COUNT_Y; ++j)\n    {\n        float scale = 3.;\n        vec3 colColor = vec3(1.,.2,.2);\n        vec3 stableColor = BallColor;\n        ivec2 ij = ivec2(i,j);\n        \n        vec2 ballPos = getBallPos(ij)/scale;\n        \n        float disk = 0.;\n        if(distance(uv,ballPos)<getBallSize(ij)/scale) disk = 1.;\n        \n        float stable = getBallStability(ij);\n        vec3 color = stable*colColor + stableColor*(1.- stable);\n        \n        fragColor.rgb = mix(fragColor.rgb, color, disk);\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BALL_COUNT_X 5\n#define BALL_COUNT_Y 5\n\n#define BallColor vec3(0.2,1.,.2)\n\n#define getTrail(ij) texelFetch(iChannel3, ij,0).x\n\n#define BALL_RADIUS 0.01\n\n#define BALL_RADIUS_MAX 0.1\n\n#define getNoise(ij) texelFetch(iChannel1, ij+ivec2(((((iFrame/30)+35)*67)%200), (((iFrame)*13)%200)), 0)\n#define getNoise2(ij) getNoise(ij+ivec2(BALL_COUNT_X,.0))\n\n#define getBallPos(ij) texelFetch(iChannel0, ij,0).xy\n#define getBallVel(ij) texelFetch(iChannel0, ij,0).zw\n#define getRawSize(ij) texelFetch(iChannel0, ij+ivec2(BALL_COUNT_X,.0),0).x*4.\n#define sigmoid(x) x / (1.0 + abs(x))\n#define getBallSize(ij) ((sigmoid(getRawSize(ij))+1.)/2.) * BALL_RADIUS + (1.-((sigmoid(getRawSize(ij))+1.)/2.)) * BALL_RADIUS_MAX\n#define getBallStability(ij) texelFetch(iChannel0, ij+ivec2(BALL_COUNT_X,.0),0).y\n\n#define attraction_force_bug .001\n#define forceToCenter(p) -p*attraction_force_bug\n\n#define getStableCount() texelFetch(iChannel0, ivec2(0,BALL_COUNT_Y+2),0).x\n\nconst float KEY_SPACE  = 32.5/256.0;\n\n\nfloat mapEnvironment(in vec2 p) {\n    vec2 q1 = abs(p) - vec2(20.0, 20.0);\n    vec2 q2 = abs(p + vec2(0.35, 0.0)) - 0.25;\n    float wall = -length(max(q1, 0.0)) - min(max(q1.x, q1.y), 0.0);\n    float box = length(max(q2, 0.0)) + min(max(q2.x, q2.y), 0.0);\n     \n    float balls = 9e9;\n    balls = min(balls, length(p - vec2(-0.6,  0.2))  - 0.1);\n    balls = min(balls, length(p - vec2(-0.45,  0.1)) - 0.1);\n    balls = min(balls, length(p - vec2(-0.30,  0.0)) - 0.1);\n    balls = min(balls, length(p - vec2(-0.15, -0.1)) - 0.1);\n    balls = min(balls, length(p - vec2( 0.0, -0.2))  - 0.1);\n    \n    balls = min(balls, length(p - vec2(0.6,  0.2))  - 0.1);\n    balls = min(balls, length(p - vec2(0.45,  0.1)) - 0.1);\n    balls = min(balls, length(p - vec2(0.30,  0.0)) - 0.1);\n    \n    \n    balls = min(balls, length(p - vec2(-0.80,  -0.4)) - 0.1);\n    balls = min(balls, length(p - vec2( 0.80,  -0.4)) - 0.1);\n    balls = min(balls, length(p - vec2(-0.40,  -0.4)) - 0.1);\n    balls = min(balls, length(p - vec2(0.30,  -0.4)) - 0.1);\n    \n    \n    return 1.0;\n}\n\nvec2 getNormal(in vec2 p) {\n    return normalize(vec2(mapEnvironment(p + vec2(0.001, 0.0)) - mapEnvironment(p - vec2(0.001, 0.0)),\n                          mapEnvironment(p + vec2(0.0, 0.001)) - mapEnvironment(p - vec2(0.0, 0.001))));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nbool collisionPush(in vec3 ball, out vec3 ballRes){\n    bool collision = false;\n    ballRes = ball;\n    for(int i = 0; i < BALL_COUNT_X; ++i)\n    for(int j = 0; j < BALL_COUNT_Y; ++j){\n        ivec2 ij = ivec2(i,j);\n\n        vec3 collider = vec3( getBallPos(ij) , getBallSize(ij) );\n        float dist = distance(ball.xy, collider.xy);\n        float minDist = (ball.z + collider.z);\n        if(dist < minDist){\n            vec2 collideAxe = (ball.xy-collider.xy)/dist;\n            ballRes += vec3((minDist-dist) * collideAxe,0.);\n            collision = true;\n        }\n    }\n    return collision;\n}\n\n\nvoid updatePos(out vec4 ballPosVel, in ivec2 ij){\n\n    \n    // Init\n    vec4 noise = getNoise(ij);\n    ballPosVel = (noise -vec4(0.5,0.5,0.5,0.5))* vec4(iResolution.xy/iResolution.y,.01,.01);//- vec4( -0.6,  -0.2, 0, 0);\n\n    // Simulate\n    bool reset = texture( iChannel2, vec2(KEY_SPACE,0.5) ).x > 0.5;\n    \n    if (iFrame > 10 && !reset) {\n      \n            vec2 ballPos = getBallPos(ij);\n            vec2 ballVel = getBallVel(ij);\n\n            ballVel += forceToCenter(ballPos);\n\n            ballPos += ballVel;\n            \n            vec3 ball = vec3(ballPos, getBallSize(ij));\n            \n            collisionPush( ball, ball );\n            \n            ballPos = ball.xy;\n            \n\n            ballPosVel = vec4(ballPos, ballVel);\n      \n    }\n}\n\nvoid updateStable(out vec4 ballSizeStable, in ivec2 ij){\n    bool reset = texture( iChannel2, vec2(KEY_SPACE,0.5) ).x > 0.5;\n    if(reset) ballSizeStable = getNoise2(ij);\n    else{\n        vec3 o = vec3(0.,0.,0.);\n        if(collisionPush(\n            vec3(\n                getBallPos(ij),\n                getBallSize(ij)\n            ), o\n        )){\n            ballSizeStable = vec4(\n                getBallSize(ij),\n                1,0,0\n            );\n        }else{\n            ballSizeStable = vec4(\n                getBallSize(ij),\n                getBallStability(ij)-0.1\n                ,0,0\n            );\n        }\n    }\n}\n\nint calculateStables(){\n    int stable = 0;\n    for(int i = 0; i < BALL_COUNT_X; ++i)\n    for(int j = 0; j < BALL_COUNT_Y; ++j){\n        ivec2 ij = ivec2(i,j);\n        if(getBallStability(ij)>0.){\n            stable++;\n        }\n    }\n    return stable;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x == 0. && int(fragCoord.y) == BALL_COUNT_Y+2){\n        fragColor = vec4(calculateStables(), 0,0,0);\n        return;\n    }\n    ivec2 ij = ivec2(fragCoord);\n    fragColor = vec4(0,0,0,1);\n    if(ij.x > BALL_COUNT_X || ij.y > BALL_COUNT_Y){\n        if(ij.x > BALL_COUNT_X) return;\n        updateStable(fragColor, ij);\n    }\n    updatePos(fragColor, ij);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool isPos(vec2 pos){\n    for(int i = 0; i < BALL_COUNT_X; ++i)\n    for(int j = 0; j < BALL_COUNT_Y; ++j){\n        ivec2 ij = ivec2(i,j);\n        if( distance(getBallPos(ij),pos) < 1. )return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    if(iFrame > 0) return;\n    \n    ivec2 ij = ivec2(fragCoord);\n    \n    if(isPos(fragCoord)){\n        fragColor = vec4(0.,0.,0., 1.);\n    }else{\n        fragColor = vec4(0.,.0,.0, 1.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}