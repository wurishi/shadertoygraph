{"ver":"0.1","info":{"id":"wtfBWS","date":"1597583452","viewed":193,"name":"3D cubic Koch snowflake","username":"CyanMARgh","description":"To be honest, I'm not very sure that it is called that way. Does anyone know its real name?","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","koch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraPos = vec3(0., 10., -13.5);\nfloat softShadow = 10.;\nfloat depthmax = 80.; \nconst float eps = 0.0001;\nvec3 backcol = vec3(.6,.7,1.);\nfloat inf = 1e20;\n\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\nvec4 cdif(vec4 d1, vec4 d2){\n    d2.w*=-1.;\n    return d1.w>d2.w?d1:d2;\n}\nvec4 cmix(vec4 d1, vec4 d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat box(vec3 b, vec3 p){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nbool closer(vec3 p, vec3 a, vec3 b){\n    return length(p-a)<length(p-b);\n}\nvec4 koch(vec3 p){    \n    float d = box(vec3(3.),p);\n    float x,y,z,s=1.;\n\tconst vec3 Y=vec3(0.,4.,0.),X=vec3(4.,0.,0.),Z=vec3(0.,0.,4.),XY=vec3(2.,2.,0.),XZ=vec3(2.,0.,2.),YZ=vec3(0.,2.,2.),XYZ=vec3(2.,2.,2.);\n\n    float I=4.+2.1*sin(iTime),i_=0.;\n    vec3 p_;\n    for(float i=1.;i<=I;i++){\n        p = abs(p);x=p.x,y=p.y,z=p.z;\n        \n        if(closer(p,XYZ,X)&&closer(p,XYZ,Y)&&closer(p,XYZ,Z)&&closer(p,XYZ,XY)&&closer(p,XYZ,XZ)&&closer(p,XYZ,YZ)){\n            p_=XYZ;\n        }else if(y>max(x,z)+2.){\n            p_=Y;i_++;\n        }else if(x>max(y,z)+2.){\n            p_=X;i_++;\n        }else if(z>max(x,y)+2.){\n            p_=Z;i_++;\n        }else{\n            float m = min(x,min(y,z));\n            if(m==x){\n                p_=YZ;\n            }else if(m==y){\n                p_=XZ;\n            }else{\n                p_=XY;\n            }\n        }        \n        p = 3.*(p-p_);\n        s*=3.3;\n    \td = min(box(vec3(3.),p)/s,d);\n    }    \n    return vec4(mix(vec3(2.,2.,3.0),vec3(1.7),i_/I),d);\n}\n\n\n\n//color functions\nbool cb3(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return (d.x+d.y+d.z)%2==0;\n}\n//scene SDF\nvec4 map(vec3 p){\n    vec4 d0 = vec4(1.,1.,1.,-box(vec3(20.,20.,20.),p-vec3(0.,20.,0.)));\n    d0.xyz*=cb3(p)?1.:.8;\n    \n    vec4 d = koch(p-vec3(0.,6.,0.));\n    d0 = cun(d0,d);\n        \n    return d0;\n}\n//normals\nvec3 norm(vec3 p){\n    const vec2 e = vec2(eps,0.);\n    float d = map(p).w;\n    return normalize(vec3(\n        map(p + e.xyy).w-d,\n        map(p + e.yxy).w-d,\n        map(p + e.yyx).w-d\n    ));\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += h;//clamp(h,0.,3.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 2; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\nvec3 getFullLight(vec3 pos, vec3 n){   \n    pos+=eps*n;\n    vec3 col;\n\n    if (length(pos) < depthmax){\n        col = vec3(.25);\n\t\tcol += getLight(pos, vec3(11., 13., 8.), n, vec3(1.,.9,.9), 60.,false);\n        col += getLight(pos, vec3(-8.,13., 11.), n, vec3(1.,1.,1.), 60.,false);\n        col += getLight(pos, vec3(-11.,13.,-8.), n, vec3(1.,1.,1.), 60.,false);\n        col += getLight(pos, vec3(8., 13.,-11.), n, vec3(1.,.9,.9), 60.,false);\n    }else{\n        col = backcol;\n    }\n    return col;\n}\n//direction of ray by pixel coord\nvec3 getDir(vec2 fragCoord, float angle){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.zy*=ro(-.25);\n    dir.xz*=ro(angle);\n    return dir;\n}\n\n//color and length of ray\nvec3 rayCast(vec3 eye, vec3 dir){\n    vec3 col = vec3(0.);\n    float k=1.;\n    \n    vec3 pos; float depth=0., sdepth=0., dist, distM;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;\n\n        depth += dist;\n        sdepth += dist;\n        \n        if(dist < eps){ //intersection with object\n            break; \n        }else if(length(pos)>depthmax){ //ray \n            depth = depthmax+eps;\n            break;\n        }\n    } \n    vec3 n = norm(pos);\n    pos+=eps*n*5.;\n    col+=map(pos).xyz*k*getFullLight(pos,n);\n\tif(map(pos).w<0.)col+=vec3(1e20);\n    return col * exp(-0.003*sdepth);\n}\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //direction calculation\n    float angle = 6.9;    \n    vec3 eye = cameraPos;\n    eye.xz*=ro(angle);\n    vec3 dir = getDir(fragCoord,angle);\n\n    //raymarching\n    vec3 col = rayCast(eye, dir);\n    \n    fragColor = vec4(1.5*log(1.+ col), 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}