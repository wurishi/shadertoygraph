{"ver":"0.1","info":{"id":"csycRK","date":"1696284910","viewed":93,"name":"inktober 2023 #2 - Spiders","username":"Shalexder","description":"spider","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","spider"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    vec3 col = vec3(0.);\n    float n = 0.;\n    for(float x = -1.; x < 1.; x += 1.){\n        for(float y = -1.; y < 1.; y += 1.){\n            vec2 v = vec2(x, y);\n            vec2 uv = (fragCoord.xy+v) / iResolution.xy;\n            float p = 1./(length(v)+1.);\n            col += texture(iChannel0, uv).rgb*p;\n            n += p;\n        }\n    }\n    col /= n;\n    fragColor = vec4(col.rgb, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n\n\nfloat random (vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n  }\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 rotate(vec2 p, float a){\n    float c = cos(a);\n    float s = sin(a);\n    mat2 m = mat2(c, s, -s, c);\n    return m*p;\n}\nfloat smoothMin( float d1, float d2, float k ) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat spiderSDF(vec3 p){\n\n    /*p.xz = rotate(p.xz, u_time*.5-1.);\n    p.yz = rotate(p.yz, -.1+u_time*.5);\n    return sdBox(p, vec3(1., 1., 1.));*/\n    //p.xz = rotate(p.xz, -.02);\n    float body = length(vec3(p.x*1.2, p.y*1.2, p.z)-vec3(0., 0., .2))-1.;\n    float head = length(p-vec3(0., -.3, -.8))-.5;\n    float e = .5;\n    float legs0 = sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(.5, -.2, -.6), vec3(1., .5, -1.2), .1);\n    float legs0_1 = sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(1., .5, -1.2), vec3(1.2, -.7, -1.6), .08);\n    float legs1 = sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(.5, -.2, -.3), vec3(1.6, .5, -.3), .1);\n    float legs1_1 = sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(1.6, .5, -.3), vec3(1.7, -.7, -.5), .08);\n    float legs2= sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(.5, -.2, -.3+e), vec3(1.6, .5, -.4+e), .1);\n    float legs2_1 = sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(1.6, .5, -.4+e), vec3(1.7, -.2, -.4+e), .08);\n    float legs3 = sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(.5, -.2, -.3+2.*e), vec3(1.6, .5, -.4+2.*e), .1);\n    float legs3_1 = sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(1.6, .5, -.4+2.*e), vec3(1.7, -.5, -.3+2.*e), .08);\n    float mainPart = min(body, head);\n    float bodyAndLegs = smoothMin(smoothMin(smoothMin(smoothMin(smoothMin(smoothMin(smoothMin(smoothMin(\n      mainPart,\n      legs0, .1),\n      legs0_1, .1),\n      legs1, .1),\n      legs1_1, .1),\n      legs2, .1),\n      legs2_1, .1),\n      legs3, .1),\n      legs3_1, .1);\n\n    float fangs = sdCapsule(vec3(abs(p.x), p.y, p.z), vec3(.06, -.3, -1.4), vec3(.1, -.6, -1.5), .05);\n    float eyes1 = length(vec3(abs(p.x), p.y, p.z*.9)-vec3(.12, -.1, -1.5))-.08;\n    float eyes2 = length(vec3(abs(p.x), p.y, p.z*.9)-(vec3(.12, -.1, -1.5)+vec3(.1, -.1, 0.)))-.08;\n    float eyes3 = length(vec3(abs(p.x), p.y, p.z*.9)-(vec3(.12, -.1, -1.5)+vec3(-.05, -.1, 0.)))-.08;\n    return min(min(min(min(bodyAndLegs, fangs), eyes1), eyes2), eyes3);\n}\n\nfloat getDist(vec3 p){\n  float ground = p.y+1.;\n  float tunnel = max(-(length(p.xy)-2.), -p.z-1.);\n  float environment = min(ground, tunnel);\n  return min(environment, spiderSDF(p));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        float d = getDist(ro+dO*rd);\n        dO += d;\n        if(d < SURFACE_DIST || dO > MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(vec3 p){\n    float d = getDist(p);\n    vec2 e = vec2(.01, 0.);\n    return normalize(d-vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx)\n    ));\n}\n\nfloat getLight(vec3 p, vec3 lightPos){\n    vec3 ld = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    return clamp(dot(ld, n), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    //uv *= 1.4;\n    vec3 ro = vec3(0., 0., -4.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    //rd = vec3(rd.x, rotate(rd.yz, a-.5));\n    \n    \n    float d = rayMarch(ro, rd);\n    vec3 p = ro+d*rd;\n    \n    vec3 col = vec3(0.);\n    if(d < MAX_DIST){\n        col = vec3(1.);\n        float distanceLight = 1.-d*.28+.15;\n        vec3 lp = ro+vec3(2., 2., 2.);\n        float light = map(getLight(p, lp), 0., 1., .4, 1.)*distanceLight;\n        col *= light;\n        \n    }\n    if(random(gl_FragCoord.xy/10.+0.*mod(iTime*182.2897, 10.)) < col.x){\n      col = vec3(1.);\n    } else {\n      col = vec3(0.);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}