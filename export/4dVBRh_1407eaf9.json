{"ver":"0.1","info":{"id":"4dVBRh","date":"1527839471","viewed":107,"name":"dragon gears","username":"nexor","description":".","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","signeddistancefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 f,vec2 c)\n{\n    vec3 col = vec3(0.);\n    c/=resolution.xy;\n    col=texture(iChannel0,c).rgb;\n\tf=vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\n//uniform vec2 resolution;\n//uniform float time;\n//uniform sampler2D backbuffer;\n//uniform vec2 touch;\n#define resolution iResolution.xy\n#define time iTime\n#define touch iMouse.xy\n\n#define pi 3.141569\n#define pi_2 (pi*.5)\n#define pi_4 (pi*.25)\n#define pi2 (pi*2.)\n#define up vec3(.0,1.,.0)\n#define right vec3(1.,.0,.0)\n#define back vec3(.0,.0,1.)\n#define sin1(x) (sin((x))*.5+.5)\n#define cos1(x) (cos((x))*.5+.5)\n#define saw(x) (4.*abs(fract((x))-.5)-1.)\n#define saw1(x) (2.*abs(fract((x))-.5))\n#define mir(x,d) (abs((x))-(d))\n\nstruct Light\n{\n   vec3 position,color;\n   float intensity;\n   bool directional;\n}lights[3];\n\nconst int material_count = 4;\nstruct Material\n{\n    vec3 albedo;\n    float roughness,metallic;\n}materials[4];\n\n\nMaterial mixmat(int a, int b, float f)\n{\n    Material M;\n    M.albedo=mix(materials[a].albedo,materials[b].albedo,f);\n    M.roughness=mix(materials[a].roughness,materials[b].roughness,f);\n    M.metallic=mix(materials[a].metallic,materials[b].metallic,f);\n    return M;\n}\n\nMaterial material(float m)\n{\n\tint k=abs(int(m));\n\tfloat f=abs(fract(m));\n    k=k%material_count;\n    int kpo=(k+1)%material_count;\n    \n\treturn mixmat(k,kpo,f);\n}\n\nvec2 map(vec3 p);\nvec3 norm(vec3 p);\nfloat ao( in vec3 pos, in vec3 nor );\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k );\n\nmat2 rot(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\nmat3 rot(float a,float x,float y,float z)\n{\n\tfloat s=sin(a),c=cos(a);\n\treturn mat3(\n\t\tx+c*y+c*z,s*z,s*y,\n\t\t-s*z,y+c*x+c*z,s*x,\n\t\t-s*y,-s*x,z+c*x+c*y);\n}\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    \n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nconst mat3 M =mat3(\n\t.74,-.52,.42,\n\t.64,.73,-.23,\n\t-.19,.45,.88\n);\n\nfloat fbm(vec3 p)\n{\n    int seed = 35;\n    \n    float f = 0.0;\n    f += 0.5000*noise( p ); p*=M*2.02;\n    f += 0.2500*noise( p ); p*=M*2.03;\n    f += 0.1250*noise( p ); p*=M*2.01;\n    f += 0.0625*noise( p );\n    f /= 0.9375;\n    return f;\n}\n\nvec2 fan(vec2 p,int k)\n{\n    float n=float(k);\n\tfloat a=atan(p.y,p.x);\n\ta=mod(a,pi2/n)-pi/n;\n\treturn length(p)*vec2(cos(a),sin(a));\n}\n\n#define rep(x,a) (mod((x),(a))-.5*(a))\n\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 X = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, X.wz), vec4(c.gb, X.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 X = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + X.xyz) * 6.0 - X.www);\n\treturn c.z * mix(X.xxx, clamp(p - X.xxx, 0.0, 1.0), c.y);\n}\n\nfloat lengthN(vec2 p,float n)\n{\n\tp=pow(p,vec2(n));\n\treturn pow(p.x+p.y,1./n);\n}\n\nfloat plane(vec3 p,vec3 n,float d)\n{\n\treturn dot(p,n)+d;\n}\n\nfloat sphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat torus88(vec3 p,vec2 t)\n{\n\tvec2 q=vec2(lengthN(p.xz,8.)-t.x,p.y);\n\treturn lengthN(q,8.)-t.y;\n}\n\nfloat torus28(vec3 p,vec2 t)\n{\n\tvec2 q=vec2(lengthN(p.xz,2.)-t.x,p.y);\n\treturn lengthN(q,8.)-t.y;\n}\n\nfloat Ud(float a,float b)\n{\n\treturn min(a,b);\n}\nvec2 Um(vec2 a, vec2 b)\n{\n\treturn vec2(Ud(a.x,b.x),\n\t\tmix(a.y,b.y,1.-step(a.x,b.x)));\n}\nfloat Sd(float a,float b)\n{\n\treturn max(a,-b);\n}\nvec2 Sm(vec2 a,vec2 b)\n{\n\treturn vec2(Sd(a.x,b.x),\n\t\tmix(a.y,b.y,step(a.x,b.x)));\n}\nfloat Id(float a,float b)\n{\n\treturn max(a,b);\n}\nvec2 Im(vec2 a,vec2 b)\n{\n\treturn vec2(Id(a.x,b.x),\n\t\tmix(a.y,b.y,step(a.x,b.x)));\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 dec(float r,float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn vec2(c,s)*r;\n}\n\nvec2 pol(float x, float y)\n{\n\tfloat r=length(vec2(x,y)),a=atan(y,x);\n\treturn vec2(r,a);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr),cos(cr),.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\treturn mat3(cu,cv,cw);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = pi * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 burgess(vec3 col)\n{\n    vec3 maxCol = max(vec3(0.0), col - 0.004);\n    vec3 retCol = (maxCol * (6.2 * maxCol + 0.05)) / (maxCol * (6.2 * maxCol + 2.3) + 0.06);\n    return pow(retCol, vec3(1.0 / 2.2));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float MAXITER = 4000.;\nconst float MAX_DISTANCE = 100.;\nconst float ITER_MUL = .15;\nconst float ITER_SHADOW_MUL = .25;\nconst float FOG = .007;\nconst vec3 FOG_COLOR = vec3(.2,.5,.8);\nconst float SHADOW_HARDNESS = 16.;\n\nfloat gear(float t)\n{\n \treturn floor(t)+pow(fract(t),3.);\n}\n\nvec2 map(vec3 p)\n{\n\tvec3 q=p,r=p;\n\tvec2 res=vec2(-1.);\n\tres=vec2(plane(q,up,5.),2.);\n\n\tfloat d=1e10,e=1e10;\n    mat2 R = rot(pi_2);\n    float gt = gear(time);\n    \n    p.y-=4.5;\n    r=p;\n    r.xz*=rot(gt*pi/6.);\n    r.yz*=R;\n    \n    r.xy=fan(r.xy,3)-vec2(15.,.0);\n    q=r;\n    r.yz*=R;\n    r.xy*=rot(gt*pi/3.);\n    r.xy=fan(r.xy,3)-vec2(5.5,.0);\n    d=torus(r,vec2(3.,1.))+sin(gear(-time*3.)+atan(r.z,r.x)*7.+length(r.xz)*4.)*.2;\n    e=torus(q,vec2(6.,1.))+sin(length(q.xz)*4.+atan(q.z,q.x)*7.+gt*4.)*.3;\n\t\n\tres=Um(res,vec2(d,3.));\n    res=Um(res,vec2(e,1.5));\n    e=torus(p,vec2(15.,.5))+sin(length(p.xz)*4.+atan(p.z,p.x)*12.-gt*4.)*.3;\n    res=Um(res,vec2(e,2.5));\n\treturn res;\n}\n\n\nvoid init()\n{\n    int m = 0,l = 0;\n\tmaterials[m].albedo=vec3(1.);\n    materials[m].roughness=1.;\n    materials[m++].metallic=1.;\n    \n\tmaterials[m].albedo=vec3(1.,.0,.0);\n    materials[m].roughness=1.;\n    materials[m++].metallic=1.;\n    \n\tmaterials[m].albedo=vec3(.0,1.,.0);\n    materials[m].roughness=.5;\n    materials[m++].metallic=.5;\n    \n\tmaterials[m].albedo=vec3(.0,.0,1.);\n    materials[m].roughness=.5;\n    materials[m++].metallic=1.;\n    \n    float flame = (pow(cos(time/3.),3.)+sin(time*3.))*.15;\n    vec3 flame_pos = vec3(flame*cos(time*36.),0.,flame*sin(time*24.));\n    lights[l].position = flame_pos + vec3(.0,0.,.0);\n    lights[l].color = vec3(1.,.0,.0);\n    lights[l].directional = false;\n    lights[l++].intensity = 1000.;\n    \n    /*\n    lights[l].position = vec3(.0,0.,.0);\n    lights[l].color = vec3(1.,.0,.0);\n    lights[l].directional = false;\n    lights[l++].intensity = 800.;\n    //*/\n    \n    //*/\n    lights[l].position = vec3(6.,10.,2.);\n    lights[l].color = vec3(1.,1.,1.);\n    lights[l].directional = true;\n    lights[l++].intensity = 5.;\n    //*/\n    \n}\n\nvec3 render(vec3 ro, vec3 rd, out float d)\n{\n\tvec3 col=vec3(.0);\n\n\tfloat tmin=.0;\n\tfloat tmax=MAX_DISTANCE;\n\n\tfloat t=tmin;\n\tfloat m=-1.;\n\tfloat i=.0;\n\tfor(;i<MAXITER;i++)\n\t{\n\t\tfloat precis=.000125*t;\n\t\tvec2 res=map(ro+t*rd);\n        if(res.x<precis||t>tmax)break;\n\t\tt+=res.x*ITER_MUL;\n\t\tm=res.y;\n\t}\n\tif(t<tmax)\n\t{\n        Material mat = material(m);\n        vec3 albedo = mat.albedo;\n        float roughness = mat.roughness;\n        float metallic = mat.metallic;\n\t\tvec3 P = ro+t*rd;\n        \n        vec3 V = -rd;\n\t\tvec3 N = norm(P);\n        vec3 F0 = vec3(.04);\n        F0 = mix(F0,albedo,metallic);\n        \n        float occ = ao(P,N);\n        \n        vec3 Lo = vec3(.0);\n        for(int i = 0; i < lights.length(); i++)\n        {\n            \n        \tfloat attenuation = .0;\n        \t\n        \tvec3 L = vec3(.0);\n            \n            if(lights[i].directional)\n            {\n                attenuation = 1.;\n                L = normalize(lights[i].position);\n            }\n            else\n            {\n                attenuation = inversesqrt(distance(lights[i].position,P));\n                L = normalize(lights[i].position-P);\n            }\n            vec3 radiance = lights[i].color * attenuation;\n            \n        \tvec3 H = normalize(V+L);\n            \n            float sha = softshadow(P,L,0.,30.,SHADOW_HARDNESS);\n\n            float NDF = DistributionGGX(N, H, roughness);        \n            float G   = GeometrySmith(N, V, L, roughness);      \n            vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\n            vec3 kS = F;\n            vec3 kD = 1. - kS;\n            kD *= 1.0 - metallic;\t  \n            \n            float NdotL = max(dot(N, L), 0.0);\n\n            vec3 numerator    = NDF * G * F * lights[i].intensity;\n            float denominator = 4.0 * max(dot(N, V), 0.0) * NdotL;\n            vec3 specular     = numerator / max(denominator, 0.001);  \n\n            Lo += (kD * albedo / pi + specular) * radiance * NdotL * sha;\n        }\n        vec3 ambient = vec3(0.03) * albedo;\n        col = ambient + Lo;\n\n        col = col / (col + vec3(1.0));\n    }\n    d=t/tmax;\n    t*=FOG;\n\tcol=mix(FOG_COLOR,col,exp(-t*t));\n\n\treturn col;\n}\n\n\n\nvec3 render( vec2 c , out float d)\n{\n\tinit();\n\tvec2 uv = c/resolution.xy;\n\tvec3 col = vec3(.0);\n\tvec2 p=(-resolution+2.*c)/resolution.y;\n\tvec2 t=touch/resolution;\n\tt=-1.+2.*t;\n\n\tvec3 ro =vec3(.0,16.,15.);\n    ro.z-=t.y*35.;\n\tro.xz*=rot(pi2-t.x*pi2);\n    \n    ro.y+=t.y*2.;\n\tvec3 to = vec3(.0,1.,.0);\n\tmat3 ca = camera(ro,to,.0);\n\tvec3 rd = ca * normalize(vec3(p,2.75));\n\tcol=render(ro,rd,d);\n\tcol=burgess(col);\n\treturn col;\n}\n\nvoid mainImage(out vec4 f,vec2 c)\n{   \n    float d=.0;\n    vec3 col = render(c,d);\n\tf=vec4(col,d);\n}\n\n\nvec3 norm(vec3 p)\n{\n\tvec2 e=vec2(1.,-1.)*.5773*.000125;\n\treturn normalize(\n\t\te.xyy*map(p+e.xyy).x+\n\t\te.yxy*map(p+e.yxy).x+\n\t\te.yyx*map(p+e.yyx).x+\n\t\te.xxx*map(p+e.xxx).x);\n}\n\nfloat ao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<3; i++ )\n    {\n        float hr = 0.01 + 0.12 * float( i ) / 4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n\tfloat res = 1.;\n\tfor( float t=mint; t < maxt; )\n\t{\n\t\tfloat h = map(ro + rd*t).x;\n\t\tif( h<0.0005 ) return 0.0;\n\t\tres = min( res, k*h/t );\n\t\tt += h*ITER_SHADOW_MUL;\n\t}\n\treturn res;\n}","name":"Buf A","description":"","type":"buffer"}]}