{"ver":"0.1","info":{"id":"3ds3DH","date":"1546246203","viewed":96,"name":"chocolate donut","username":"compy_art","description":"messing around with Signed Distance Functions.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blarg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV = 120.0;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst int MAX_STEPS = 255;\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat sdf_torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n\nfloat sdf_scene(vec3 p) {\n    \n    \n    vec3 t = vec3(p.x, p.z, p.y);\n    return sdf_torus(t, vec2(1.0, 0.3));\n    \n}\n \n// Thanks LearnOpenGL!\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\n\nvoid mainImage(out vec4 f_col, in vec2 f_cord) {\n    \n    \n   \tvec3 eye = vec3(0.0, 0.0, 5.0);\n    vec3 r_dir = normalize(vec3(f_cord - iResolution.xy / 2.0,\n                      \t   -iResolution.x / tan(radians(FOV) / 2.0)\n                      \t   ));\n    \n    float r_dist = MIN_DIST;\n    float n_dist = 0.0;\n    \n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        n_dist = sdf_scene(eye + r_dir * r_dist);\n        \n        if (n_dist < EPSILON) {\n        \tbreak;   \n        }\n        \n        r_dist += n_dist;\n        \n        if (r_dist >= MAX_DIST - EPSILON) {\n         \tr_dist = MAX_DIST;\n            break;\n        }\n    }\n    \n    if (r_dist > MAX_DIST - 20.0) {\n        \n        // background color\n    \tf_col = vec4(0.0, 0.2, 0.2, 1.0);\n    } else {\n        \n        vec3 p_pos = eye + r_dir * r_dist;\n        vec3 p = p_pos;\n        vec3 p_norm = normalize(\n                                 vec3(\n                                      sdf_scene(vec3(p.x + EPSILON, p.y, p.z)) - sdf_scene(vec3(p.x - EPSILON, p.y, p.z)),\n                                      sdf_scene(vec3(p.x, p.y + EPSILON, p.z)) - sdf_scene(vec3(p.x, p.y - EPSILON, p.z)),\n                                      sdf_scene(vec3(p.x, p.y, p.z + EPSILON)) - sdf_scene(vec3(p.x, p.y, p.z - EPSILON))\n                                    )\n                         \t   );\n        // Make the point (approx.) \n\n\n       \n        vec3 l_pos = vec3(2.0, 2.0, 5.0);\n        vec3 l_rad = vec3(0.5, 0.3, 0.2);\n        \n        // ambient\n        float ambientStrength = 0.1;\n        vec3 ambient = ambientStrength * l_rad;\n\n        // diffuse \n        vec3 l_dir = normalize(l_pos - p_pos);\n        float diff = max(dot(p_norm, l_dir), 0.0);\n        vec3 diffuse = diff * l_rad;\n\n        // specular\n        float specularStrength = 0.5;\n        vec3 viewDir = normalize(eye - p_pos);\n        vec3 reflectDir = reflect(-l_dir, p_norm);  \n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n        vec3 specular = specularStrength * spec * l_rad;  \n\n        vec3 obj_col = vec3(0.5, 0.5, 0.5);\n        vec3 result = (ambient + diffuse + specular) * obj_col;\n        f_col = vec4(result, 1.0);\n    }\n    //f_col = normalize(vec4(floor(r_dist), 0.3, n_dist, 1.0));\n}","name":"Image","description":"","type":"image"}]}