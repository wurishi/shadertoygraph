{"ver":"0.1","info":{"id":"DscfW4","date":"1697151184","viewed":125,"name":"Avoid Thread Idle w/ Upscaling","username":"Real_NC","description":"Showing two different methods for rendering something in lower resolution and then upscaling.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fractal","performance","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nUpscaling Performance by Real_NC\n\nDo not use this work, in any form, without a written acknowledgement of Real_NC as the author and a link to this\nshadertoy.com page.\nFor other uses and restrictions not covered here, see the Shadertoy license.\n\n-----------------------------------------------------------------------------------------------------------------\nDemonstrating that because of how the GPU dispatches threads, scaling mode 0 increases performance while \nscaling mode 1 does not improve performance unless the scaling factor is very high. This is because scaling\nmode 1 forces GPU threads to idle while waiting for 1 pixel to render.\n*/\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O = texelFetch(iChannel0, shrink(intU), 0);\n    if (mask2) O *= 0.6; // darken image wherever the reduced res buffer is calculating the image\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Raymarch T-Square fractal\n#define EPSILON 0.001\n\n#define PI 3.14159265\n#define TAU 2.0 * PI\n\n//---------------------------------------------------------------------------------------------------------\n// hash by Dave Hoskins https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash11(uint q)\n{\n    q += 5u; // on my laptop, the first 5 values of q are not properly random.\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n//end of hash by Dave Hoskins\n//---------------------------------------------------------------------------------------------------------\nuint seed = uint(0);\nvec3 randomSphere()\n{\n    vec2 a = vec2(\n    hash11(seed++)*TAU,\n    acos(2.0*hash11(seed++) - 1.0));\n    \n    \n    \n    return vec3(vec2(cos(a.x), sin(a.x))*sin(a.y), cos(a.y));\n}\n\nmat2 rotMat(float t)\n{\n    vec2 i = vec2(cos(t), sin(t));\n    return mat2(\n    i.x, i.y,\n    -i.y, i.x\n    );\n}\n\n\nvec3 iterate(vec3 p)\n{\n    vec2 t = normalize(vec2(1,-cos(iTime*0.3) + 1.0 - 0.577));\n    p.x = abs(p.x);\n    vec2 b = normalize(vec2(0,1) + t); //bisector\n    \n    if(p.z < p.x * b.y / b.x) \n    p.xz *= mat2(\n    -t.y, t.x,\n    t.x, t.y\n    );\n    p.z -= 0.5;\n    p *= 2.0;\n    \n    \n    return p;\n}\n\nfloat map(vec3 p)\n{\n    float d = min(length(p) - 0.16, p.y + 0.5);\n    for(int i = 1; i <= 10; i++)\n    {\n        p = iterate(p);\n        d = min(d, (length(p) - 0.16)/float(1<<i));\n    }\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    float c = map(p);\n    vec2 q = vec2(EPSILON, 0);\n    \n    return normalize(vec3(\n    map(p + q.xyy),\n    map(p + q.yxy),\n    map(p + q.yyx)\n    ) - c);\n}\n\nfloat getRayD(vec3 ro, vec3 rd)\n{\n    float m;\n    float d;\n    ro += rd*0.01;\n    for(int i = 0; i <= 200; i++)\n    {\n        m = map(ro);\n        d += m;\n        ro += rd*m;\n        if (m <= EPSILON) break;\n        if (d >= 30.0) break;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    //--------------------------------------------------------------\n    if (!mask2) discard;\n    U = vec2(fill(intU));\n    //regular code goes here:---------------------------------------\n    seed = uint(U.x*U.y) + uint(iFrame);\n    U = (U - iResolution.xy*0.5)/iResolution.y;\n    \n    vec3 rd = normalize(vec3(U, 1.2));\n    vec3 ro = vec3(0, 1.1, -2);\n    \n    rd.zy *= rotMat(0.5);\n    rd.xz *= rotMat(iTime*0.1);\n    \n    ro.xz *= rotMat(iTime*0.1);\n    \n    O.rgb = vec3(0);\n    \n    for(int s = 0; s < 10; s++)\n    {\n        float d;\n        vec3 n;\n        vec3 col = vec3(1);\n        \n        vec3 rd2 = rd;\n        vec3 ro2 = ro;\n        \n        for(int i = 0; i <= 5; i++)\n        {\n            d = getRayD(ro2, rd2);\n            ro2 += rd2*d;\n            if (d >= 30.0) break;\n            if (ro2.y <= -0.4) col *= vec3(0.7, 0.21, 0.04);\n            else col *= vec3(0.2,0.9,0.9);\n            n = normalize(normal(ro2) + randomSphere()*0.03);\n            rd2 = reflect(rd2, n);\n        }\n        O.rgb += col*0.1*texture(iChannel0, rd2).rgb;\n    }\n    O *= 1.3;\n    O = pow(O, vec4(0.454545));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Scaling mode 0 uses 1/4 of the screen, scaling mode 1 uses 1/4 of every 2x2 pixel section\n#define SCALING_MODE 0\n\n// scaling factor, power of 2 to divide resolution\n#define SF 1\n\n// utilities for repeated expressions\n#define intR ivec2(iResolution.xy)\n#define intU ivec2(U)\n#define mask2 mask(intU, intR)\n\nivec2 fill (ivec2 U) // remap coords so the pixels left after the mask can properly calculate the image\n{\n#if (SCALING_MODE == 0)\n    return U << SF;\n#endif\n#if (SCALING_MODE == 1)\n    return U;\n#endif\n}\n\nivec2 shrink (ivec2 U) // remap full coords to reduced coords to sample half-res buffers\n{\n#if (SCALING_MODE == 0)\n    return U >> SF;\n#endif\n#if (SCALING_MODE == 1)\n    return (U >> SF) << SF;\n#endif\n}\n\nbool mask (ivec2 U, ivec2 R)\n{\n#if (SCALING_MODE == 0)\n    return (min(U, R >> SF) == U);\n#endif\n#if (SCALING_MODE == 1)\n    return ((U & ivec2(~0 << SF)) == U);\n#endif\n}\n\n\n","name":"Common","description":"","type":"common"}]}