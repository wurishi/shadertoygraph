{"ver":"0.1","info":{"id":"XcyyWG","date":"1732286493","viewed":97,"name":"Truchet tiles v4","username":"jorge2017a2","description":"Truchet tiles v4","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["truchet","tiles","v4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por jorge2017a2\n///Truchet tiles v4\n\n//--22-nov-2024\n//referencia\n//https:/-iquilezles.org/articles/distfunctions2d\n\n/// consejos y correcciones por @FabriceNeyret2, \n/// consejos @Elsio,\n\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n\n\n#define S3(d,b) smoothstep(6./iResolution.y, 0. , d - (b) )\n#define S(d,b) smoothstep(6./iResolution.y, 0. , d - (b) )\n\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nfloat Sdf_I(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Sdf_U(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Sdf_D(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DFB(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S3( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S3(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\n\nvec3 DFS(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut;\n  return colOut;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\n\n\n// Function to rotate a 2D point by an angle\nvec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\n\n/*\nvec3 Fig01(vec2 p,vec3 colout)\n{\n    \n\nvec2 A,B, med,pr;\nfloat dfin;\nfloat  r1,ang, he ;\n\nA=vec2(1.0,0.0);\nr1=0.1824324;\nfloat d11=sdCircle(p-A,r1);\nd11=abs(d11)-0.05;\ncolout= DFB(vec3(1.0), colout, d11);\n\nA=vec2(0.1858108,0.5);\nmed=vec2(0.00168919,0.535473);\nfloat d12=sdBox(p-A,med);\nd12=abs(d12)-0.05;\ncolout= DFB(vec3(1.0), colout, d12);\n\nA=vec2(0.5,0.8141892);\nmed=vec2(0.5101351,0.00168919);\nfloat d13=sdBox(p-A,med);\nd13=abs(d13)-0.05;\ncolout= DFB(vec3(1.0), colout, d13);\n\nA=vec2(0.0,1.0);\nr1=0.8243243;\nfloat d14=sdCircle(p-A,r1);\nd14=abs(d14)-0.05;\ncolout= DFB(vec3(1.0), colout, d14);\n\nA=vec2(0.0,1.0);\nr1=0.5067568;\nfloat d15=sdCircle(p-A,r1);\nd15=abs(d15)-0.05;\ncolout= DFB(vec3(1.0), colout, d15);\n\nA=vec2(1.013514,-0.00675676);\nr1=0.5067568;\nfloat d16=sdCircle(p-A,r1);\nd16=abs(d16)-0.05;\ncolout= DFB(vec3(1.0), colout, d16);\n\n    return colout;\n}\n\n*/\n\n//FabriceNeyret2, 2024-11-22\n//corrections for perfect fitting:\n\nvec3 Fig01(vec2 p, vec3 colout)\n{\n    vec2 A,B, med,pr;\n    float dfin, r1,ang, he ;\n\n    A=vec2(1,0);\n    r1=.2;\n    float d11=sdCircle(p-A,r1);\n    d11=abs(d11) - .05;\n    colout= DFB(vec3(1), colout, d11);\n\n    A=vec2(.2,.5);\n    med=vec2(0,.5);\n    float d12=sdBox(p-A,med);\n    d12=abs(d12) - .05;\n    colout= DFB(vec3(1), colout, d12);\n\n    A=vec2(.5,.8);\n    med=vec2(.5,0);\n    float d13=sdBox(p-A,med);\n    d13=abs(d13) - .05;\n    colout= DFB(vec3(1), colout, d13);\n\n    A=vec2(0,1);\n    r1=0.8;\n    float d14=sdCircle(p-A,r1);\n    d14=abs(d14) - .05;\n    colout= DFB(vec3(1), colout, d14);\n\n    A=vec2(0,1);\n    r1=0.5;\n    float d15=sdCircle(p-A,r1);\n    d15=abs(d15) - .05;\n    colout= DFB(vec3(1), colout, d15);\n\n    A=vec2(1,0);\n    r1=0.5;\n    float d16=sdCircle(p-A,r1);\n    d16=abs(d16) - .05;\n    colout= DFB(vec3(1), colout, d16);\n\n    return colout;\n}\n\n\n\n// Function to generate a random number based on tile position\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvec3 truchet(vec2 uv, vec3 col)\n{\n    vec2 pos = uv;\n    vec2 tile = floor(uv); // Determina la posición del tile\n    pos = fract(uv); // Normaliza las coordenadas dentro del tile (0 a 1)\n    \n    // Genera una elección aleatoria para la rotación (90° o 180°)\n    float choice = random(tile);\n    float ang = (choice < 0.5) ? radians(90.0) : radians(180.0);\n     \n    //Elsio, 2024-11-22\n     // show grid on mouse click\n    float f = min(pos.x, pos.y) - .02;\n    if(iMouse.z > 0.)\n        col = mix(\n                  col, \n                  vec3(1, 0, 0),\n                  smoothstep(.01, .0, f)\n              );\n\n    // Aplica la rotación\n    pos = rotate(pos - 0.5, ang) + 0.5; // Rotación con el centro del tile como origen\n\n    // Dibuja la figura dentro del tile rotado\n    col = Fig01(pos, col);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float scale =2.0;\n   vec2 uv =  scale * ( 2. * fragCoord - iResolution.xy ) / iResolution.y ;\n   uv+=iTime*0.25;  \n   vec3 col=vec3(0.0);\n   col= truchet(uv,col) ;\n   col=pow(col,  vec3(0.554545)); \n   fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}