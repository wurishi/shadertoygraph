{"ver":"0.1","info":{"id":"lX2yWz","date":"1727275222","viewed":21,"name":"Perlin noise Dequilla","username":"Dequilla","description":"Testing perlin noise. Trying to learn.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perlin","dynamic","generated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat fade(in float t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// Linear intorpolate\nfloat lerp(in float a, in float b, in float x)\n{\n    return a + x * (b - a);\n}\n\nvec2 random_gradient(int ix, int iy) \n{\n    // Code found: https://en.wikipedia.org/wiki/Perlin_noise\n    // No precomputed gradients mean this works for any number of grid coordinates\n    const int w = 8 * 4;\n    const int s = w / 2; // rotation width\n    int a = ix, b = iy;\n    a *= 3284157443; b ^= a << s | a >> w-s;\n    b *= 1911520717; a ^= b << s | b >> w-s;\n    a *= 2048419325;\n    float random = float(a) * ( 3.14159265 / float(~(~0u >> 1)) ); // in [0, 2*Pi]\n    vec2 v;\n    v.x = cos(random); \n    v.y = sin(random);\n    return v;\n}\n\nfloat dot_gradient(ivec2 gridCoord, vec2 actualCoord)\n{\n    vec2 rg = random_gradient(gridCoord.x, gridCoord.y);\n    \n    vec2 relative = vec2(\n        actualCoord.x - float(gridCoord.x),\n        actualCoord.y - float(gridCoord.y)\n    );\n    \n    return dot(relative, rg);\n}\n\nfloat perlin(in vec2 pos)\n{\n    // Grid coords\n    ivec2 v1 = ivec2(floor(pos.x), floor(pos.y));\n    ivec2 v2 = ivec2(v1.x + 1, v1.y + 1);\n\n    // Interpolation weights\n    vec2 iw = vec2(\n        fade(pos.x - float(v1.x)),\n        fade(pos.y - float(v1.y))\n    );\n    \n    // Calculate lengths of vectors from borders to position and interpolate\n    float n0 = dot_gradient(v1, pos);\n    float n1 = dot_gradient(ivec2(v2.x, v1.y), pos);\n    float ix0 = mix(n0, n1, iw.x);\n    \n    n0 = dot_gradient(ivec2(v1.x, v2.y), pos);\n    n1 = dot_gradient(v2, pos);\n    float ix1 = mix(n0, n1, iw.x);\n\n    return mix(ix0, ix1, iw.y) * 0.5 + 0.5; // range -1 to 1 so multiply and add to make 0 to 1\n}\n\nfloat perlin_process(in vec2 pos, in int octaves, in float persistence) \n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    float maxValue = 0.0;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;i++) {\n        total += perlin(vec2(pos.x * frequency, pos.y * frequency)) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    \n    return total/maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float infl = float(iFrame);\n    \n    vec2 np_1 = vec2(\n        (fragCoord.x + infl) / 30.0 + (iMouse.x / 255.0), \n        (fragCoord.y + infl) / 30.0 + (iMouse.y / 255.0)\n    );\n    \n    float r1 = perlin_process(np_1, 4, 0.7);\n    float g1 = perlin_process(np_1, 1, 0.7);\n\n    vec2 np_2 = vec2(\n        (fragCoord.x - (infl / 2.0)) / 30.0 + (iMouse.x / 255.0), \n        (fragCoord.y + (infl / 3.0)) / 30.0 + (iMouse.y / 255.0)\n    );\n    \n    float r2 = perlin_process(np_2, 7, 0.9);\n    float g2 = perlin_process(np_2, 1, 0.7);\n\n    // Output to screen\n    float rout = mix(r1, r2, 0.5);\n    float gout = mix( mix(r1, r2, 0.5), mix(g1, g2, 0.5), 0.1 ) * 0.4;\n    \n    fragColor = vec4(\n        rout, \n        gout, \n        0.0, \n        1.0\n    );\n}","name":"Image","description":"","type":"image"}]}