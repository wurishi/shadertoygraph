{"ver":"0.1","info":{"id":"MfXGW7","date":"1703122804","viewed":48,"name":"Magnetic Pendulum Sim 2","username":"zenzicubic","description":"A magnetic pendulum sim using RK4 and backbuffers","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["physics","pendulum","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float dis, minDis = 1000.;\n    int minI = 0;\n    for (int i = 0; i < nMagnets; i ++) {\n        dis = distance(tex.xy, mags[i]);\n        if (dis < minDis) {\n            minDis = dis;\n            minI = i;\n        }\n    }\n    vec3 c = vec3(0.702,0.247,0.384);\n    if (minI == 1) {\n        c = vec3(0.953,0.776,0.467);\n    } else if (minI == 2) {\n        c = vec3(0.047,0.039,0.243);\n    }\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 outst, vec2 pos) {\n    vec2 v = scl * (2. * pos - iResolution.xy) / iResolution.y;\n    if (iFrame == 0) {\n        outst = vec4(v, 0., 0.);\n        return;\n    }\n    vec4 st = texelFetch(iChannel0, ivec2(pos), 0);\n    outst = integrate(st);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define nMagnets 3\n\nvec2[nMagnets] mags = vec2[](\n    vec2(1., 0.),\n    vec2(-.5, .866),\n    vec2(-.5, -.866)\n);\n\n#define dt 5e-3\n#define scl 2.\n\nconst float h = .25;\nconst float g = .2;\nconst float u = .1;\n\nvec4 f(vec4 v) {\n    vec2 fc = vec2(0.);\n    vec2 r, p = v.xy;\n    \n    float fac;\n    for (int i = 0; i < nMagnets; i ++) {\n        r = mags[i] - p;\n        fac = pow(h * h + dot(r, r), -1.5);\n        fc += r * fac;\n    }\n    \n    fc -= g * p + u * v.zw;\n    return vec4(v.zw, fc);\n}\n\nvec4 integrate(vec4 v) {\n    vec4 k1 = dt * f(v);\n    vec4 k2 = dt * f(v + .5 * k1);\n    vec4 k3 = dt * f(v + .5 * k2);\n    vec4 k4 = dt * f(v + k3);\n    return v + .333 * (.5 * k1 + k2 + k3 + .5 * k4);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 outst, vec2 pos) {\n    vec2 v = scl * (2. * pos - iResolution.xy) / iResolution.y;\n    if (iFrame == 0) {\n        outst = vec4(v, 0., 0.);\n        return;\n    }\n    vec4 st = texelFetch(iChannel0, ivec2(pos), 0);\n    outst = integrate(st);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 outst, vec2 pos) {\n    vec2 v = scl * (2. * pos - iResolution.xy) / iResolution.y;\n    if (iFrame == 0) {\n        outst = vec4(v, 0., 0.);\n        return;\n    }\n    vec4 st = texelFetch(iChannel0, ivec2(pos), 0);\n    outst = integrate(st);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 outst, vec2 pos) {\n    vec2 v = scl * (2. * pos - iResolution.xy) / iResolution.y;\n    if (iFrame == 0) {\n        outst = vec4(v, 0., 0.);\n        return;\n    }\n    vec4 st = texelFetch(iChannel0, ivec2(pos), 0);\n    outst = integrate(st);\n}","name":"Buffer D","description":"","type":"buffer"}]}