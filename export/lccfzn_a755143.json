{"ver":"0.1","info":{"id":"lccfzn","date":"1732633700","viewed":108,"name":"Raymarcher Bubbles","username":"Reini","description":"Raymarching","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int SCOUNT = 20;\n\nstruct sphere {\n    float radius;\n    vec3 pos;\n};\n\nfloat elasticOut(float t) {\n  const float HALF_PI = 1.5707963267948966;\n  return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat smin( float[SCOUNT] d, float k )\n{\n    float r = 0.0;\n    for (int i=0; i<d.length(); i++){\n        r += exp2(-d[i] / k);\n    }\n    return -k*log2(r);\n}\nfloat hmin (float[2] d, float k){\n    float m = 1000000.0;\n    for (int i=0; i<d.length(); i++){\n        m = min(m, d[i]);\n    }\n    return m;\n}\n\nfloat sdf_sphere (vec3 point, float radius) {\n    return length(point) - radius;\n}\n\nfloat dist (vec3 point, sphere[SCOUNT] s) {\n    float[SCOUNT] distances;\n    for (int i=0; i<s.length(); i++){\n        distances[i] = sdf_sphere(point + s[i].pos, s[i].radius);\n    }\n    float safeDist = smin(distances, 0.2);\n    return safeDist;\n}\n\nvec3 raymarch (vec3 camPos, vec3 rayDir, sphere[SCOUNT] s) {\n    float marchedDist = 0.0;\n    \n    float safeDist = dist(camPos + rayDir*marchedDist, s);\n    \n    for (int i=0; i<100; i++){\n        if (safeDist < 0.001) {\n            // HIT SOMETHING\n            float eps = 0.00001;\n            float d_X = dist(camPos + rayDir*marchedDist + vec3(eps, 0, 0), s);\n            float d_Y = dist(camPos + rayDir*marchedDist + vec3(0, eps, 0), s);\n            float d_Z = dist(camPos + rayDir*marchedDist + vec3(0, 0, eps), s);\n            vec3 grad = vec3(d_X - safeDist, d_Y - safeDist, d_Z - safeDist);\n            vec3 normal = -normalize(grad);\n            vec3 sun = normalize(vec3(1.0, 1.0, -1.0));\n            float highlight = dot(normal, sun);\n            float fresnel = pow(cos(normal.y), 4.0);\n            float lightness = max(highlight * 0.3, fresnel);\n            return vec3(0, lightness, 0);\n        }\n        marchedDist += safeDist;\n        safeDist = dist(camPos + rayDir*marchedDist, s);\n    }\n    return vec3(0, 0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = (fragCoord - iResolution.xy*0.5) / iResolution.x;\n    \n    float fov = 10.0;\n    \n    vec3 camPos = vec3(0, -6.0, 0);\n    vec3 rayDir = normalize(vec3(px.x * fov, -camPos.y, px.y * fov));\n    \n    // define Objects\n    sphere spheres[SCOUNT];\n    \n    for (int i=0; i<SCOUNT; i++){\n        spheres[i] = sphere(0.1, vec3(0, 0, 0));\n    }\n    \n    for (int i=1; i<SCOUNT; i++){\n        float duration = 5.0;\n        float timeshift = (duration / float(SCOUNT-1))*float(i);\n        float time = mod(iTime + timeshift, duration) / duration;\n        \n        float z = sin(float(i)*37.292);\n        float j = sin(z);\n        float x = sin(j*40.0);\n        float y = cos(j*40.0);\n        vec3 dir = normalize(vec3(x, y, z));\n        \n        spheres[i].pos = (dir * (1.3 - elasticOut(time))*3.0) * pow(1.0 - time, 0.5);\n    }\n    \n    vec3 color = raymarch(camPos, rayDir, spheres);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}