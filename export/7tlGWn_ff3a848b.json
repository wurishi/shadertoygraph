{"ver":"0.1","info":{"id":"7tlGWn","date":"1622562133","viewed":200,"name":"interstellar_chase breakdown","username":"skaplun","description":"Original shader: https://www.shadertoy.com/view/tscSD2\nOriginal animation: https://dribbble.com/shots/3845535-Space-Chase\nText-guided animation: https://twitter.com/sskaplun/status/1399753380587843586\n","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","sdf","raymatch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cubeMap(p) texture(iChannel0, p)\n#define r(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define C_MOON 10\n#define C_UFO_MAIN 11\n#define C_UFO_SECOND 12\n#define C_UFO_ENGINE 13\n#define C_SHUTTLE_MAIN 14\n#define C_SHUTTLE_SECOND 15\n#define C_SHUTTLE_EX 16\n#define NONE vec3(0.)\n\n#define AP_GRADIENT_NOISE_1 0\n#define AP_GRADIENT_NOISE_2 1\n#define AP_VORONOI_NOISE    2\n#define AP_EXHAUST_PLANE    3\n#define AP_SHUTTLE_CPLANES  4\n\nfloat TIME;\n\nstruct WORLD{\n    Sphere moonBounds;\n    bool renderMoon;\n    \n    Sphere ufoBounds;\n    bool renderUFO;\n    mat3 ufoRotMat;\n    \n    Sphere shuttleBounds;\n    bool renderShuttle;\n    mat3 shuttleRotMat;\n    \n    Cylinder exhaustBounds;\n    bool renderExhaust;\n    mat3 exhaustRotMat;\n    \n    Ray cameraRay;\n};\n\nWORLD consrtuctWorld(vec2 fragCoord){\n    WORLD w;\n    w.moonBounds = Sphere(vec3(0.), 6.2);\n    \n    {\n        w.ufoBounds = Sphere(vec3(0., 7., 0.), 1.);\n        //w.ufoBounds.origin += apPhasesStates[AP_UFO_FLY_AWAY] * vec3(7., 2., 8.);\n        w.ufoBounds.origin -= w.moonBounds.origin;\n        float ufoAng = -1. * apPhasesStates[AP_WAIT_1] - clamp(TIME - PHASES_DURATIONS[AP_SHUTTLE_EXHAUST_7], 0., PHASES_DURATIONS[PHASES_COUNT - 1]);\n        mat3 m = rz(ufoAng);\n        w.ufoBounds.origin *= m;\n        w.ufoBounds.origin += w.moonBounds.origin;\n    \n        float y = clamp(TIME - PHASES_DURATIONS[AP_UFO_4], 0., PHASES_DURATIONS[PHASES_COUNT - 1]);\n        float z = -PI * .5 * pow(smoothstep(0., 1., apPhasesStates[AP_UFO_FLY_AWAY]), 6.);\n        vec2 sat = shiftAtPos(1., y) * .2 * step(MIN_FLOAT, y);\n        w.ufoRotMat = inverse(m) * ry(y) * rx(sat.x) * rz(sat.y);// * rz(z);// * ry(y);\n    }\n    \n    {\n        w.shuttleBounds = Sphere(vec3(0., 7., 0.), 1.);\n        w.shuttleBounds.origin -= w.moonBounds.origin;\n        float a = -clamp(TIME - PHASES_DURATIONS[AP_SHUTTLE_EXHAUST_7], 0., PHASES_DURATIONS[PHASES_COUNT - 1]);\n        mat3 m = rz(a);\n        w.shuttleBounds.origin *= m;\n        w.shuttleBounds.origin += w.moonBounds.origin;\n        \n        vec2 v = shiftAtPos(1., abs(a)) * .1 * step(a, 0.);\n        w.shuttleRotMat = inverse(m) * ry(v.x);\n    }\n    \n    {\n        w.exhaustBounds = Cylinder(vec3(0., 7., 0.), vec3(-1., 7., 0.), 1.);\n        \n        w.exhaustBounds.A -= w.moonBounds.origin;\n        w.exhaustBounds.B -= w.moonBounds.origin;\n        float a = -clamp(TIME - PHASES_DURATIONS[AP_SHUTTLE_EXHAUST_7], 0., PHASES_DURATIONS[PHASES_COUNT - 1]);\n        mat3 m = rz(a);\n        w.exhaustBounds.A *= m;\n        w.exhaustBounds.B *= m;\n        w.exhaustBounds.A += w.moonBounds.origin;\n        w.exhaustBounds.B += w.moonBounds.origin;\n        \n        w.exhaustRotMat = inverse(m);\n    }\n    \n    {\n        float x = -25. + 20. * apPhasesStates[AP_MOON_SHIFT_AWAY];\n        float y = 25. - 15. * apPhasesStates[AP_MOON_SHIFT_AWAY]\n                      -  5. * pow(apPhasesStates[AP_UFO_3], .25)\n                      +  5. * apPhasesStates[AP_UFO_4];\n        vec3 eye = mix(vec3(x, y, 0.),\n                       vec3((5. + 5. * apPhasesStates[AP_UFO_FLY_AWAY]) * cos(PI*.5), 10., (5. + 5. * apPhasesStates[AP_UFO_FLY_AWAY]) * sin(PI*.5)),\n                       pow(apPhasesStates[AP_WAIT_1], 8.));\n                       \n        float ph = apPhasesStates[AP_SHUTTLE_1];\n        eye = mix(eye,\n                  vec3((10. - 5. * ph) * cos(PI * .5 - PI * 1.25 * ph), y, (10. - 5. * ph) * sin(PI * .5 - PI * 1.25 * ph)),\n                  step(MIN_FLOAT, ph));\n                  \n        ph = apPhasesStates[AP_SHUTTLE_EXHAUST_1];\n        eye = mix(eye,\n                  vec3(-10., 12., -4.),\n                  ph);\n                  \n        ph = smoothstep(0., .25, apPhasesStates[AP_FLY_TOGETHER]);\n        eye = mix(eye,\n                  vec3(-7., 15., 0.),\n                  ph);\n                  \n        ph = smoothstep(0., .75, apPhasesStates[AP_END]);\n        eye = mix(eye,\n                  vec3(0., 0., 50.),\n                  ph);\n                  \n        ph = smoothstep(.75, 1., apPhasesStates[AP_END]);\n        eye = mix(eye,\n                  vec3(-25., 25., 0.),\n                  ph);\n        \n        vec3 to = vec3(-2.5 * apPhasesStates[AP_SHUTTLE_EXHAUST_1] * apPhasesInvStates[AP_FLY_TOGETHER], 7. * pow(apPhasesInvStates[AP_END], 8.), 0.);\n        \n        float end = smoothstep(.75, .5, apPhasesStates[AP_END]);\n        mat3 rm =  rz(-clamp(TIME - PHASES_DURATIONS[AP_SHUTTLE_EXHAUST_7], 0., PHASES_DURATIONS[PHASES_COUNT - 1])\n                      * end - 4.2 * (1. - end));\n        eye *= rm;\n        to *= rm;\n\n        vec2 offset = vec2(iResolution.x * .15, iResolution.y * .15 * apPhasesStates[AP_UFO_1]);\n        vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord + offset);\n        //vec3 worldDir = viewMatrix(eye, to, vec3(0., 1., 0.) * rz(ufoAng)) * viewDir;\n        vec3 worldDir = viewMatrix(eye, to, vec3(0., 1., 0.) * rm) * viewDir;\n        w.cameraRay = Ray(eye, worldDir);\n        //w.cameraRay = ray;\n    }\n    \n    float ph = smoothstep(1., .9, apPhasesStates[AP_END]);\n    w.moonBounds.rad *= ph;\n    w.ufoBounds.rad *= ph;\n    w.shuttleBounds.rad *= ph;\n    w.exhaustBounds.r *= ph;\n    \n    w.renderMoon = sphere_hit(w.moonBounds, w.cameraRay);\n    w.renderUFO = sphere_hit(w.ufoBounds, w.cameraRay) && int(bap.id) >= AP_UFO_1;\n    w.renderShuttle = sphere_hit(w.shuttleBounds, w.cameraRay) && int(bap.id) >= AP_SHUTTLE_1;\n    Hit h;\n    w.renderExhaust = cylinderHit(w.cameraRay, w.exhaustBounds, h) && \n                      ((w.cameraRay.origin + w.cameraRay.direction * h.dist) * w.exhaustRotMat).x < -.5 &&\n                      ((w.cameraRay.origin + w.cameraRay.direction * h.dist) * w.exhaustRotMat).x > -8.;\n                      \n    return w;\n}\n\nfloat ufo_engine(vec3 p){\n    float ph = clamp(apPhasesStates[AP_UFO_3], MIN_FLOAT, 1.0);\n        \n    float delta = PI/4.;\n    float l = length(p.xz);\n    float a = mod(atan(p.z, p.x), delta) - delta/2.;\n    vec3 mp = vec3(l * sin(a), p.y, l * cos(a));\n\n    float id = floor((atan(p.z, p.x) + PI)/delta);\n    float span = 1./8.;\n    float curPhase = smoothstep(id * span, (id+1.) * span, ph);\n\n    vec3 p1 = vec3(0., -.135 - .2 * smoothstep(.95, .75, ph), .25 * curPhase);\n    vec3 p2 = vec3(0., -.025 - .2 * smoothstep(.95, .75, ph), .8 * curPhase);\n    \n    return sdCapsule(mp, p1, p2, .025 + l * .1);\n}\n\nHit UFO(vec3 p){\n\tHit ufo = miss;\n    {\n        // hmmm... strange bug without clamping\n        float size = clamp(smoothstep(.5, 1., apPhasesStates[AP_UFO_1]), .001, 1.0);\n        ufo = opMin(ufo, Hit(sdEllipsoid(p, vec3(1., 0.175, 1.) * size), C_UFO_MAIN, NONE));\n    }\n    \n    if(int(bap.id) >= AP_UFO_2)\n    {\n        float ph = clamp(apPhasesStates[AP_UFO_2], MIN_FLOAT, 1.0);\n        float delta = PI/4.;\n        float l = length(p.xz);\n    \tfloat a = mod(atan(p.z, p.x), delta) - delta/2.;\n        vec3 mp = vec3(l * sin(a), p.y, l * cos(a));\n        \n        vec3 pos = vec3(0., .075 + .5 * smoothstep(1., .5, ph), .8 * smoothstep(.25, .5, ph));\n        float rad = .06 * smoothstep(0., .25, ph)\n                  + .1 * sin(PI * smoothstep(.25, .5, ph));\n        ufo = opMin(ufo, Hit(length(mp - pos) - rad, C_UFO_SECOND, NONE));\n    }\n    \n    if(int(bap.id) >= AP_UFO_3)\n    {\n        ufo = opMin(ufo, Hit(ufo_engine(p), C_UFO_ENGINE, NONE));\n    }\n    \n    if(int(bap.id) >= AP_UFO_4)\n    {\n        float ph = apPhasesStates[AP_UFO_4];\n        vec3 cabinH = vec3(0., .5 * smoothstep(.25, .15, ph), 0.);\n        vec3 cabinSize = vec3(.6, .5, .6) * smoothstep(0., .15, ph);\n        ufo = opMin(ufo, Hit(opSubtraction(p.y, sdEllipsoid(p - cabinH, cabinSize)), C_UFO_SECOND, NONE));\n    \n        \n        vec3 antennaBaseH = vec3(0., .23 + .5  * smoothstep(.4, .3, ph), 0.);\n        float antennaBaseS = .3 * smoothstep(.2, .4, ph);\n        ufo = opMin(ufo, Hit(opSubtraction(p.y, length(p - antennaBaseH) - antennaBaseS), C_UFO_SECOND, NONE));\n        \n        vec3 a = vec3(0., .5, 0.);\n        vec3 b = vec3(0., .7 * smoothstep(.4, .8, ph), 0.);\n        vec3 c = vec3(.15  * clamp(smoothstep(.6, .8, ph), MIN_FLOAT, 1.), .7  * clamp(smoothstep(.4, .8, ph), MIN_FLOAT, 1.), 0.);\n        \n        float th = 0.0;\n        vec2 h = sdBezier(a, b, c, p);\n        float kh = h.y;\n\t\tfloat antenna = h.x - (.025 - smoothstep(.5, .85, p.y) * .015);\n\t\t\n    \tufo = opMin(ufo, Hit(antenna, C_UFO_MAIN, NONE));\n        ufo = opMin(ufo, Hit(length(p - vec3(.15, .7, 0.)) - .04 * smoothstep(.7, 1., ph), C_UFO_MAIN, NONE));\n    }\n    \n    return ufo;\n}\n\nHit spaceShuttle(vec3 p){\n    float mainBody = MAX_FLOAT;\n    \n    {\n        float ph = apPhasesStates[AP_SHUTTLE_1];\n        mainBody = sdEllipsoid(p, vec3(1., .35, .4) * smoothstep(0., .25, ph));\n        mainBody = smin(mainBody,\n                        length(p + vec3(.8 * smoothstep(.5, .75, ph), -.6 * smoothstep(.66, .33, ph), 0.)) - .35 * smoothstep(.25, .5, ph), .15);\n        mainBody = opSubtraction(p.x + 1. - .2 * smoothstep(.75, 1., ph), mainBody);\n    }\n    \n    if(int(bap.id) >= AP_SHUTTLE_2){//wings\n        vec3 mp = p;\n        mp.yz = abs(mp.yz);\n        float ph = apPhasesStates[AP_SHUTTLE_2];\n        float wings = length(mp) - 1. * smoothstep(0., .25, ph);\n        wings = max(wings, mp.y - max(.025, smoothstep(.5, .25, ph)));\n        wings = max(wings, sdPlane(mp, normalize(vec3(1., 0., 1.)), -max(.5, smoothstep(.75, .5, ph))));\n        wings = max(wings, -sdPlane(mp, normalize(vec3(1., 0., -.25)), max(.7, smoothstep(1., .75, ph))));\n        \n        mainBody = smin(mainBody, wings, .15);\n    }\n    \n    if(int(bap.id) >= AP_SHUTTLE_3){//tail\n        vec3 mp = p;\n        mp.z = abs(mp.z);\n        float ph = apPhasesStates[AP_SHUTTLE_3];\n        float tail = length(mp) - 1. * smoothstep(0., .2, ph);\n        tail = max(tail, mp.z - max(.025, smoothstep(.4, .2, ph)));\n        tail = max(tail, -mp.y - smoothstep(.4, .2, ph));\n        tail = smax(tail, sdPlane(mp, normalize(vec3(1., 1.5, 0.)), -max(.3, smoothstep(.6, .4, ph))), 100.);\n        tail = smax(tail, sdPlane(mp, normalize(vec3(-1., .5, 0.)), -max(.7, smoothstep(.8, .6, ph))), 100.);\n        tail = smax(tail, -sdPlane(mp, normalize(vec3(0., -1., 0.)), max(.6, smoothstep(1., .8, ph))), 100.);\n        \n        mainBody = min(mainBody, tail);\n    }\n    \n    float ph = apPhasesStates[AP_SHUTTLE_4];\n    Hit cabin = Hit(length(p - vec3(.4, .2 + .3 * smoothstep(.66, .33, ph), 0.)) - .25 * smoothstep(0., .33, ph), C_SHUTTLE_SECOND, NONE);\n    Hit exhaust = Hit(sdTorus(p.yxz + vec3(0., .8, 0.), vec2(.3, .125 * smoothstep(.66, 1., ph))), C_SHUTTLE_SECOND, NONE);\n    return opMin(Hit(mainBody, C_SHUTTLE_MAIN, NONE), opMin(cabin, exhaust));\n}\n\nvec4[3] getExhaustBubble(vec3 p, vec3 mp, float id, float t, WORLD w){\n    float bsize = smoothstep(-8., -2., p.x) * \n                  pow(smoothstep(-.5, -2., p.x), .5) * .5;\n    float amp = pow(smoothstep(-1., -3., p.x), .5)\n              * abs(p.x) * .2 * .2\n              * apPhasesStates[AP_SHUTTLE_EXHAUST_5];\n    \n    vec3 pos = vec3(.5, sin(id * .95 + t), cos(id + t * .75)) * vec3(1., amp, sin(p.x + t) * amp * 3.);\n    vec3 pos1 = vec3(.25, cos(id * 1.25 + t * 2.), -sin(id * .5 + t * 2.)) * vec3(1., amp, cos(p.x + t) * amp * 3.);\n    vec3 pos2 = vec3(.75, -cos(id * .5 + t * .65), sin(id * 1.5 + t * 1.1)) * vec3(1., amp, -cos(p.x + t) * amp * 3.);\n    \n    return vec4[3](vec4(pos, bsize), vec4(pos1, bsize), vec4(pos2, bsize));\n}\n\nfloat shuttle_exhaust(vec3 p, WORLD world){\n    float t = clamp(TIME - PHASES_DURATIONS[AP_SHUTTLE_EXHAUST_6], 0., 50.);\n    vec3 mp = vec3(fract(p.x), p.y, p.z);\n    float id = floor(abs(mp.x));\n    mp.x = fract(mp.x + t * 6.);\n\n    float val = MAX_FLOAT;\n    for(int j=-1; j<2;j++){\n        vec4 bubbles[3] = getExhaustBubble(p, mp - vec3(float(j), 0., 0.), id, t * 2., world);\n        for(int i=0; i<3; i++)\n            val = smin(val, length(mp - vec3(float(j), 0., 0.) - bubbles[i].xyz) - bubbles[i].w * apPhasesStates[AP_SHUTTLE_EXHAUST_4],\n                        .2 * apPhasesStates[AP_SHUTTLE_EXHAUST_6]);\n    }\n\n    val = max(val, p.x + .75);\n    val = max(val, -p.x - apPhasesStates[AP_SHUTTLE_EXHAUST_1] * 8.);\n    \n    return val;\n}\n\nHit world(vec3 p, Ray ray, WORLD world){\n    Hit result = miss;\n    \n    {//moon\n        if(world.renderMoon){\n            vec3 mp = p - world.moonBounds.origin;\n            vec4 moon = cubeMap(normalize(mp));\n            float craterSize = mix(.01, .1, moon.a * .001);\n            float rad = world.moonBounds.rad * pow(apPhasesStates[AP_MOON_SPHERE_GROW], 2.)\n                      - (1. - moon.r) * .4 * smoothstep(.65, .85, apPhasesStates[AP_MOON_GRAD_NOISE_1])\n                      - (1. - moon.g) * .1 * smoothstep(.65, .85, apPhasesStates[AP_MOON_GRAD_NOISE_2])\n                      - mix(-pow(smoothstep(craterSize * 2., craterSize, moon.b), 16.) * .005,\n                             pow(smoothstep(craterSize, 0., moon.b), .75) * .12, smoothstep(craterSize + .005, craterSize - .005, moon.b))\n                        * smoothstep(.65, .85, apPhasesStates[AP_MOON_VORONOI_NOISE]);\n            result = opMin(result, Hit(length(mp) - rad, C_MOON, NONE));\n        }\n    }\n    \n    {\n        if(world.renderUFO){\n            vec3 mp = p - world.ufoBounds.origin;\n            mp *= world.ufoRotMat;\n            result = opMin(result, UFO(mp));\n        }\n    }\n    \n    if(int(bap.id) >= AP_SHUTTLE_1)\n    {\n        if(world.renderShuttle)\n        {\n            vec3 mp = p - world.shuttleBounds.origin;\n            mp *= world.shuttleRotMat;\n            result = opMin(result, spaceShuttle(mp));\n        }\n    }\n    \n    if(world.renderExhaust)\n    {\n        p -= world.exhaustBounds.A;\n        p *= world.exhaustRotMat;\n        result = opMin(result, Hit(shuttle_exhaust(p, world), C_SHUTTLE_EX, NONE));\n    }\n    \n    return result;\n}\n\nHit cutoffPlanes(Ray ray, float minD, float maxD, WORLD world){\n    if(int(bap.id) >= AP_MOON_GRAD_NOISE_1 && \n       int(bap.id) <= AP_MOON_VORONOI_NOISE)\n    {\n        float phase = bap.phase;\n        Sphere s = Sphere(world.moonBounds.origin + vec3(world.moonBounds.rad * 3.75, 0., 0.) * smoothstep(.75, .5, phase), world.moonBounds.rad + 1.);\n        \n        s.rad *= smoothstep(0., .25, phase) * smoothstep(1., .65, phase);\n        \n        Hit hit;\n        if(sphere_hit(Sphere(s.origin, s.rad), ray, 0., minD, hit))\n            return Hit(hit.dist, int(bap.id) - AP_MOON_GRAD_NOISE_1, hit.normal);\n    }\n    \n    if(int(bap.id) >= AP_SHUTTLE_EXHAUST_1)\n    {\n        float dst = (world.exhaustBounds.A.y-ray.origin.y)/ray.direction.y;\n        float ph = apPhasesStates[AP_SHUTTLE_EXHAUST_1];\n        float phase = bap.phase;\n        vec3 p = ray.origin + ray.direction * dst;\n        p.z = abs(p.z);\n        if(p.x < -.8 && p.x > -min(7., ph * 10.) && p.z < abs(p.x * .4) )\n            return Hit(dst, AP_EXHAUST_PLANE, vec3(0., 1., 0.));\n    }\n    \n    if(int(bap.id) >= AP_SHUTTLE_2)\n    {\n        vec3 res = vec3(MAX_FLOAT, 0., 0.);\n        {\n            float ph = apPhasesStates[AP_SHUTTLE_2];\n            float dst = ((max(.025, smoothstep(.6, .15, ph)) + world.shuttleBounds.origin.y)-ray.origin.y)/ray.direction.y;\n            vec3 p = ray.origin + ray.direction * dst;\n            if(dst < minD){\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.z)))\n                              * smoothstep(.075, .025, distance(ph, .375)), .5)\n                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.z)), 1.4))) * .35;\n            }\n            \n            dst = ((world.shuttleBounds.origin.y - max(.025, smoothstep(.6, .15, ph)))-ray.origin.y)/ray.direction.y;\n            p = ray.origin + ray.direction * dst;\n            if(dst < minD){\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.z)))\n                             * smoothstep(.075, .025, distance(ph, .375)), .5)\n                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.z)), 1.4))) * .35;\n            }\n            \n            vec3 n = vec3(1., 0., 1.);\n            if(plane_hit(ray, n * max(.33, smoothstep(.75, .5, ph) - .33), n, dst) && dst < minD) {\n                p = ray.origin + ray.direction * dst;\n                p.y -= world.shuttleBounds.origin.y;\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1., 0.95, max(abs(p.y), abs(p.z)))\n                              * smoothstep(.25, .05, distance(ph, .65)), .5)\n                          * max(.25, smoothstep(.025, .0125, distance(max(abs(p.y), abs(p.z)), .9))) * .35;\n            }\n            \n            n = vec3(-1., 0., 1.);\n            if(plane_hit(ray, n * min(-.33, -smoothstep(.75, .5, ph)+.2), n, dst) && dst < minD) {\n                p = ray.origin + ray.direction * dst;\n                p.y -= world.shuttleBounds.origin.y;\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1., .95, max(abs(p.y), abs(p.z)))\n                              * smoothstep(.25, .05, distance(ph, .75)), .5)\n                          * max(.25, smoothstep(.025, .0125, distance(max(abs(p.y), abs(p.z)), .9))) * .35;\n            }\n            \n            n = vec3(-1., 0., .25);\n            if(plane_hit(ray, n *  max(.7, .5 + smoothstep(1., .75, ph)), n, dst) && dst < minD) {\n                p = ray.origin + ray.direction * dst;\n                p.y -= world.shuttleBounds.origin.y;\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1., .95, max(abs(p.y), abs(p.z)))\n                              * smoothstep(.2, .05, distance(ph, .8)), .5)\n                          * max(.25, smoothstep(.025, .0125, distance(max(abs(p.y), abs(p.z)), .9))) * .35;\n            }\n            \n            n = vec3(-1., 0., -.25);\n            if(plane_hit(ray, n *  max(.7, .5 + smoothstep(1., .75, ph)), n, dst) && dst < minD) {\n                p = ray.origin + ray.direction * dst;\n                p.y -= world.shuttleBounds.origin.y;\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1., .95, max(abs(p.y), abs(p.z)))\n                              * smoothstep(.2, .05, distance(ph, .8)), .5)\n                          * max(.25, smoothstep(.025, .0125, distance(max(abs(p.y), abs(p.z)), .9))) * .35;\n            }\n            \n            ph = apPhasesStates[AP_SHUTTLE_3];\n            dst = (max(.025, smoothstep(.4, .2, ph))-ray.origin.z)/ray.direction.z;\n            p = ray.origin + ray.direction * dst;\n            p.y -= world.shuttleBounds.origin.y;\n            if(dst < minD){\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.y)))\n                              * smoothstep(.1, .025, distance(ph, .3)), .5)\n                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.y)), 1.4))) * .35;\n            }\n            \n            dst = (-max(.025, smoothstep(.4, .2, ph))-ray.origin.z)/ray.direction.z;\n            p = ray.origin + ray.direction * dst;\n            p.y -= world.shuttleBounds.origin.y;\n            if(dst < minD){\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.y)))\n                             * smoothstep(.1, .025, distance(ph, .3)), .5)\n                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.y)), 1.4))) * .35;\n            }\n            \n            dst = (world.shuttleBounds.origin.y-smoothstep(.4, .2, ph)-ray.origin.y)/ray.direction.y;\n            p = ray.origin + ray.direction * dst;\n            if(dst < minD){\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.z)))\n                             * smoothstep(.1, .025, distance(ph, .3)), .5)\n                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.z)), 1.4))) * .35;\n            }\n            \n            n = normalize(vec3(1., 1.5, 0.));\n            if(plane_hit(ray, n * -min(-world.shuttleBounds.origin.y+1., 1.2-world.shuttleBounds.origin.y-smoothstep(.6, .4, ph)), n, dst) && dst < minD) {\n                p = ray.origin + ray.direction * dst;\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.z)))\n                              * smoothstep(.2, .05, distance(ph, .5)), .5)\n                          * max(.25, smoothstep(.05, .025, distance(max(abs(p.x), abs(p.z)), 1.4))) * .35;\n            }\n            /*\n            n = normalize(vec3(1., -.5, 0.));\n            //max(.7, smoothstep(.8, .6, ph))\n            if(plane_hit(ray, n * (vec3(0.,-8.,0.) + smoothstep(.8, .6, ph)), n, dst) && dst < minD) {\n                p = ray.origin + ray.direction * dst;\n                //p.y -= world.shuttleBounds.origin.y;\n                res.x = min(res.x, dst);\n                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.z),max(abs(p.x), abs(p.y))))\n                              * smoothstep(.2, .05, distance(ph, .7)), .5)\n                          * max(.25, smoothstep(.05, .025, distance(max(abs(p.z), max(abs(p.x), abs(p.y))), 1.4))) * .35;\n            }\n            */\n        }\n        return Hit(res.x, AP_SHUTTLE_CPLANES, vec3(res.yz, 0.));\n    }\n    \n    return miss;\n}\n\nvec2 getNoiseColor(vec3 dir, int type){\n    vec2 res;\n    float a = 2. * PI * pow(smoothstep(0., .75, bap.phase), .5);\n    dir.xz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    vec4 noises = cubeMap(dir);\n    res.x = noises[type];\n    if(type == AP_VORONOI_NOISE){\n        float phase = smoothstep(.25, .5, bap.phase);\n        float craterSize = mix(.01, .1, noises.a * .001) + (1.-phase);\n        res.x = mix(res.x, smoothstep(.025 * craterSize * 4., .075 * craterSize * 4., distance(res.x, craterSize)), phase);\n    }\n    res.y = smoothstep(0., .25, bap.phase) * smoothstep(1., .5, bap.phase);\n    return res;\n}\n\nvec2 getExhaustPlaneColor(vec3 p, WORLD w){\n    vec2 planeColor = vec2(1., .25);\n    float span = .5;\n    {\n        float ph = apPhasesStates[AP_SHUTTLE_EXHAUST_2];\n        float id = floor(abs(p.x)) * .1;\n        float curWidth = smoothstep(id * span, (id+1.) * span, ph) * abs(p.x) * .35;\n        planeColor.x *= max(smoothstep(.48, .47, distance(fract(p.x), .5)),\n                            smoothstep(curWidth - .05, curWidth, abs(p.z)));\n    }\n    \n    {\n        float ph = apPhasesStates[AP_SHUTTLE_EXHAUST_3];\n        \n        float t = 0.;\n        vec3 mp = p;\n        float id = floor(abs(mp.x));\n        mp.x = fract(mp.x);\n        id *= .1;\n        \n        vec4 bubbles[] = getExhaustBubble(p, mp, id, t, w);\n        float span = .34;\n        for(int i=0; i<3; i++){\n            vec4 b1 = bubbles[i];\n            float curSpan = smoothstep(float(i) * span, float(i+1) * span, ph);\n            float curWidth = smoothstep(id * span, (id + 1.) * span, curSpan)\n                       * mix(.75, b1.w, pow(smoothstep(.5, 1., curSpan), .5))\n                       * .75;\n            \n            float scale = smoothstep(0., .1, curSpan);\n            planeColor.x *= smoothstep(.025 * scale, .05 * scale, distance(distance(b1.xz, mp.xz), curWidth));\n        }\n        \n        planeColor.y *= apPhasesInvStates[AP_SHUTTLE_EXHAUST_4];\n    }\n    return planeColor;\n}\n\nconst int MAX_GEOMETRY_MARCHING_STEPS = 96;\nHit march_geometry(const in Ray ray, float start, float end, const in WORLD w) {\n    float t = start;\n    for(int i=0; i<MAX_GEOMETRY_MARCHING_STEPS; i++){\n        Hit hit = world(ray.origin + t * ray.direction, ray, w);\n        if( hit.dist < EPS ) return Hit(t, hit.matID, hit.normal);\n        t += hit.dist * .75;\n    }\n    return miss;\n}\n\nvec3 geometryNormal(vec3 pos, const in Ray ray, const in WORLD w){\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPS;\n    return normalize( e.xyy*world( pos + e.xyy, ray, w ).dist + \n\t\t\t\t\t  e.yyx*world( pos + e.yyx, ray, w ).dist + \n\t\t\t\t\t  e.yxy*world( pos + e.yxy, ray, w ).dist + \n\t\t\t\t\t  e.xxx*world( pos + e.xxx, ray, w ).dist );\n}\n\nvec3 albedoByID(int matID){\n    switch(matID){\n    \tcase 10:\n        \treturn vec3(.6);\n        case 11:\n        case 14:\n        \treturn vec3(.8);\n        case 12:\n        case 15:\n        \treturn vec3(24., 28., 60.)/255. * .5;\n        case 13:\n        \treturn vec3(253., 237., 136.)/255. * .5;\n        default:\n            return vec3(0.); \n    }\n}\n\nfloat orenNayarDiffuse(vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float roughness, float albedo) {\n    float LdotV = dot(lightDirection, viewDirection);\n    float NdotL = dot(lightDirection, surfaceNormal);\n    float NdotV = dot(surfaceNormal, viewDirection);\n\n    float s = LdotV - NdotL * NdotV;\n    float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n    float sigma2 = roughness * roughness;\n    float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n    float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n    return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\nfloat gaussianSpecular(vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float shininess) {\n    vec3 H = normalize(lightDirection + viewDirection);\n    float theta = acos(dot(H, surfaceNormal));\n    float w = theta / shininess;\n    return exp(-w*w);\n}\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal){\n    vec3 lin = vec3(0.0);\n\n    vec3  view = normalize(-rd);\n    const vec3 lig1 = normalize(vec3(-1., 1., 1.));\n    const vec3 lig2 = normalize(vec3(0., 1., 2.));\n    \n    float spc2 = gaussianSpecular(lig2, view, nor, 0.95);\n    float dif2 = max(0., orenNayarDiffuse(lig2, view, nor, -20.1, 1.0));\n    vec3  col2 = vec3(.5);\n    lin += col2*spc2+dif2*col2;\n\n    vec3 col = mal*lin;\n\n    return col;\n}\n\nconst vec3 MOON_CLR_1 = vec3(255., 171., 71.)/255.;\nconst vec3 MOON_CLR_2 = vec3(71., 155., 255.)/255.;\nvec3 doMaterial(in vec3 pos, WORLD world){\n    vec3 p = pos - world.moonBounds.origin;\n    float c = clamp(length(p) - world.moonBounds.rad + .4, 0., 1.) * 4.;\n    return mix(MOON_CLR_1, MOON_CLR_2, c);\n}\n\nconst int star_iterations = 10;\nfloat doBackgroundStars(in vec3 dir){\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n              ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                           dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i )\n    {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y + iTime;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );\n    }\n    return f;\n}\n\nvec3 engineLighs(vec3 p, WORLD w){\n    vec3 res = vec3(0.);\n    if(int(bap.id) >= AP_UFO_3){\n        vec3 mp = p - w.ufoBounds.origin;\n        mp *= w.ufoRotMat;\n        res += vec3(253., 237., 136.)/255. * clamp((1.25 - ufo_engine(mp)), 0., 1.) * apPhasesStates[AP_UFO_4];\n    }\n    if(int(bap.id) >= AP_SHUTTLE_EXHAUST_6){\n        vec3 mp = p - w.exhaustBounds.A;\n        mp *= w.exhaustRotMat;\n        res += vec3(253., 237., 136.)/255. * clamp((1.25 - shuttle_exhaust(mp, w)), 0., 1.) * apPhasesStates[AP_SHUTTLE_EXHAUST_7];\n    }\n    return res;\n}\n\nvec2 voronoi(in vec3 x){\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    \tfor( int j=-1; j<=1; j++ )\n    \t\tfor( int i=-1; i<=1; i++ ){\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash33( p + b );\n                float d = dot( r, r );\n\n                if( d < res.x ){\n                    id = dot(p + b, vec3(20.31, 517., 113.));\n                    res = vec2(d, res.x);\n                }else if(d < res.y){\n                    res.y = d;\n                }\n    }\n    return vec2(res.x, abs(id));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tTIME = mod(iTime, PHASES_DURATIONS[PHASES_COUNT - 1]);\n    bap = getBreakdownAnimationPhase(TIME);\n    \n    for(int i = min(iFrame, 0); i<PHASES_COUNT; i++){\n        apPhasesStates[i] = getNormalizedBAP(bap, float(i));\n        apPhasesInvStates[i] = 1. - apPhasesStates[i];\n    }\n    \n    WORLD world = consrtuctWorld(fragCoord);\n    vec3 color = vec3(doBackgroundStars(world.cameraRay.direction));\n    Hit hit = march_geometry(world.cameraRay, 0., 500., world);\n    if (hit.matID != -1) {\n        vec3 p = (world.cameraRay.origin + hit.dist * world.cameraRay.direction);\n    \t\n        vec3 norm = geometryNormal(p, world.cameraRay, world);\n        color = norm;\n        \n        {\n            vec3 albedo = hit.matID != 10 ? albedoByID(hit.matID) : doMaterial(p, world);\n            \n            switch(hit.matID){\n                case C_MOON:\n                    color = mix(color, doLighting(world.cameraRay.origin, norm, world.cameraRay.direction, hit.dist, albedo), apPhasesStates[AP_MOON_SHIFT_AWAY]);\n                    color += 2. * engineLighs(world.cameraRay.origin + world.cameraRay.direction * hit.dist, world);\n                    break;\n                case C_UFO_MAIN:\n                case C_UFO_SECOND:\n                    color = mix(color, doLighting(world.cameraRay.origin, norm, world.cameraRay.direction, hit.dist, albedo), apPhasesStates[AP_UFO_4]);\n                    break;\n                case C_UFO_ENGINE:\n                    color = mix(color, 1.5 * mix(vec3(1., 0., 0.), vec3(253., 237., 136.)/255., pow(abs(dot(world.cameraRay.direction, norm)), .5)), apPhasesStates[AP_UFO_4]);\n                    break;\n                case C_SHUTTLE_MAIN:\n                case C_SHUTTLE_SECOND:\n                    color = mix(color, doLighting(world.cameraRay.origin, norm, world.cameraRay.direction, hit.dist, albedo), apPhasesStates[AP_SHUTTLE_EXHAUST_1]);\n                    break;\n                case C_SHUTTLE_EX:\n                    color = mix(color, 1.5 * mix(vec3(1., 0., 0.), vec3(253., 237., 136.)/255., pow(abs(dot(world.cameraRay.direction, norm)), .5)), apPhasesStates[AP_SHUTTLE_EXHAUST_7]);\n                    break;\n            }\n        }\n    }\n    \n    if(int(bap.id) < AP_MOON_SHIFT_AWAY ||\n       (int(bap.id) >= AP_SHUTTLE_1 && int(bap.id) <= AP_SHUTTLE_EXHAUST_4)) {\n        Hit h = cutoffPlanes(world.cameraRay, (hit.dist < 100.) ? hit.dist : 1000., 1000., world);\n        if(h.dist < hit.dist) {\n            if(h.matID <= AP_VORONOI_NOISE){\n                vec2 noise_clr = getNoiseColor(h.normal, h.matID);\n                color = mix(color, noise_clr.xxx, noise_clr.y);\n            }else if(h.matID == AP_SHUTTLE_CPLANES){\n                color = mix(color, vec3(1.), h.normal.x);\n            }\n            else if(h.matID == AP_EXHAUST_PLANE){\n                vec2 plane_clr = getExhaustPlaneColor(world.cameraRay.origin + world.cameraRay.direction * h.dist, world);\n                color = mix(color, plane_clr.xxx, plane_clr.y);\n            }\n        }\n    }\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPS 1e-3\nconst float PI = acos(-1.);\n\nstruct Ray{vec3 origin, direction;};\nstruct Sphere{vec3 origin; float rad;};\nstruct Cylinder{vec3 A, B;float r;};\nstruct Hit{float dist; int matID; vec3 normal;};\n\nconst Hit miss = Hit(MAX_FLOAT, -1, vec3(0.));\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.direction, inray.direction);\n    float b = dot(oc, inray.direction);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    return discriminant > 0.;\n}\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray, float t_min, float t_max, inout Hit rec) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.direction, inray.direction);\n    float b = dot(oc, inray.direction);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        float temp = (-b - sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            rec.dist = temp;\n            vec3 p = inray.origin + inray.direction * rec.dist;\n            rec.normal = (p - sphere.origin) / sphere.rad;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool plane_hit(Ray ray, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, ray.direction);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ray.origin;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool cylinderHit(const in Ray ray,  const in Cylinder cyl, inout Hit rec) {\n  float cxmin, cymin, czmin, cxmax, cymax, czmax;\n  if (cyl.A.z < cyl.B.z) {\n      czmin = cyl.A.z - cyl.r; czmax = cyl.B.z + cyl.r;\n  } else {\n      czmin = cyl.B.z - cyl.r; czmax = cyl.A.z + cyl.r;\n  }\n  if (cyl.A.y < cyl.B.y) {\n      cymin = cyl.A.y - cyl.r; cymax = cyl.B.y + cyl.r;\n  } else {\n      cymin = cyl.B.y - cyl.r; cymax = cyl.A.y + cyl.r;\n  }\n  if (cyl.A.x < cyl.B.x) {\n      cxmin = cyl.A.x - cyl.r; cxmax = cyl.B.x + cyl.r;\n  } else {\n      cxmin = cyl.B.x - cyl.r; cxmax = cyl.A.x + cyl.r;\n  }\n    /*\n  if (optimize) {\n   if (start.z >= czmax && (start.z + dir.z) > czmax) return;\n   if (start.z <= czmin && (start.z + dir.z) < czmin) return;\n   if (start.y >= cymax && (start.y + dir.y) > cymax) return;\n   if (start.y <= cymin && (start.y + dir.y) < cymin) return;\n   if (start.x >= cxmax && (start.x + dir.x) > cxmax) return;\n   if (start.x <= cxmin && (start.x + dir.x) < cxmin) return;\n  }\n*/\n\n    vec3 AB = cyl.B - cyl.A;\n    vec3 AO = ray.origin - cyl.A;\n    vec3 AOxAB = cross(AO, AB);\n    vec3 VxAB  = cross(ray.direction, AB);\n    float ab2 = dot(AB, AB);\n    float a = dot(VxAB, VxAB);\n    float b = 2. * dot(VxAB, AOxAB);\n    float c = dot(AOxAB, AOxAB) - (cyl.r * cyl.r * ab2);\n    float d = b * b - 4. * a * c;\n    if (d < 0.)\n        return false;\n    \n    rec.dist = (-b - 1. * sqrt(d)) / (2. * a);\n    /*\n    float[2] coef = float[2](1., -1.); \n    for(int i=0; i<2; i++){\n        float time = (-b - coef[i] * sqrt(d)) / (2. * a);\n        rec.dist[i] = time;\n        rec.ptnt[i] = ray.origin + ray.direction * time;\n        rec.nrm[i] = normalize(rec.ptnt[i] - vec3(0., rec.ptnt[i].y, 0.));\n    }*/\n    return true;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    // taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    angle = radians(angle);\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/*\nmat3 rotMat(vec3 rotation){\n    vec3 s = sin(rotation), c = cos(rotation);\n    mat3 rx = mat3(1.0, 0.0, 0.0,\n                   0.0, c.x,-s.x,\n                   0.0, s.x, c.x);\n    mat3 ry = mat3(c.y, 0.0,-s.y,\n                   0.0, 1.0, 0.0,\n                   s.y, 0.0, c.y);\n    mat3 rz = mat3(c.z,-s.z, 0.0,\n                   s.z, c.z, 0.0,\n                   0.0, 0.0, 1.0);\n    return rx * rz * ry;\n}\n*/\n\n#define rx(a) mat3(1.0, 0.0, 0.0, 0.0, cos(a),-sin(a), 0.0, sin(a), cos(a))\n#define ry(a) mat3(cos(a), 0.0,-sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a))\n#define rz(a) mat3(cos(a),-sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0)\n\nvec3 apply_rot(mat4 r, vec3 p){\n    return (r*vec4(p, 1.)).xyz;\n}\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p){\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p){\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p){\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4){\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p){\n    vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n                        f.y),\n                mix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n                        f.y),\n                f.z);\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\nfloat FBM( vec3 p ){\n    float f;\n\n        f = 0.5000 * Noise(p); p = m*p;\n        f += 0.2500 * Noise(p); p = m*p;\n        f += 0.1250 * Noise(p); p = m*p;\n        f += 0.0625   * Noise(p); p = m*p;\n        f += 0.03125  * Noise(p); p = m*p;\n        f += 0.015625 * Noise(p);\n    return f;\n}\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nvec2 shiftAtPos(float x, float time){\n\treturn vec2(fbm1x(x, time), fbm1x(x + 78.233, time));\n}\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\n//sdf functions\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest(vec2 b0, vec2 b1, vec2 b2){\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t){\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nHit opMin(Hit a, Hit b) {\n    if (a.dist < b.dist) return a; else return b;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h ) {\n    return dot(p,n) + h;\n}\n\nconst float CUTOFF_PLANES_THICKNESS = .015;\nfloat plane(vec3 pos, vec3 nrm, float dist){\n    return max(-sdPlane(pos, nrm, -dist + CUTOFF_PLANES_THICKNESS),\n               -sdPlane(pos, nrm * -1., dist + CUTOFF_PLANES_THICKNESS));\n}\n\n// Breakdown animatio data\n\nstruct BreakdownAnimationPhase{\n\tfloat id;\n    float phase; \n};\n\n#define AP_MOON_SPHERE_GROW 0\n#define AP_MOON_GRAD_NOISE_1 1\n#define AP_MOON_GRAD_NOISE_2 2\n#define AP_MOON_VORONOI_NOISE 3\n#define AP_MOON_SHIFT_AWAY 4\n\n#define AP_UFO_1 4 /*intentionally*/\n#define AP_UFO_2 5\n#define AP_UFO_3 6\n#define AP_UFO_4 7\n#define AP_UFO_FLY_AWAY 8\n\n#define AP_WAIT_1    9 \n#define AP_SHUTTLE_1 10\n#define AP_SHUTTLE_2 11\n#define AP_SHUTTLE_3 12\n#define AP_SHUTTLE_4 13\n#define AP_SHUTTLE_EXHAUST_1 14\n#define AP_SHUTTLE_EXHAUST_2 15\n#define AP_SHUTTLE_EXHAUST_3 16\n#define AP_SHUTTLE_EXHAUST_4 17\n#define AP_SHUTTLE_EXHAUST_5 18\n#define AP_SHUTTLE_EXHAUST_6 19\n#define AP_SHUTTLE_EXHAUST_7 20\n#define AP_FLY_TOGETHER 21\n#define AP_END 22\n\nconst int PHASES_COUNT = 23;\nconst float PHASES_DURATIONS[PHASES_COUNT] = float[PHASES_COUNT]\n    (1., 3., 5., 7., 8., 9., 10., 12., 13., 15., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 37.);\nfloat apPhasesStates[PHASES_COUNT];\nfloat apPhasesInvStates[PHASES_COUNT];\nBreakdownAnimationPhase bap;\nBreakdownAnimationPhase getBreakdownAnimationPhase(float time){\n\ttime = mod(time, PHASES_DURATIONS[PHASES_COUNT - 1]);\n    \n    int id = 0;\n    for(int i=1; i<=PHASES_COUNT; i++){\n        if(time < PHASES_DURATIONS[i-1]){\n        \tid = i-1;\n            break;\n        }\n    }\n    float phase = (time - (id == 0 ? 0. : PHASES_DURATIONS[id-1]))\n        \t\t/ (PHASES_DURATIONS[id] - (id == 0 ? 0. : PHASES_DURATIONS[id-1]));\n    \n    return BreakdownAnimationPhase(float(id), phase);\n}\n\nfloat getNormalizedBAP(BreakdownAnimationPhase bas, float id){\n\tif(id == bas.id)\n        return bas.phase;\n    else\n        return step(id, bas.id);\n}\n\nfloat getInvNormalizedBAP(BreakdownAnimationPhase bas, float id){\n\tif(id == bas.id)\n        return 1.-bas.phase;\n    else\n        return step(bas.id, id);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"vec2 voronoi(in vec3 x){\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    \tfor( int j=-1; j<=1; j++ )\n    \t\tfor( int i=-1; i<=1; i++ ){\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash33( p + b );\n                float d = dot( r, r );\n\n                if( d < res.x ){\n                    id = dot(p + b, vec3(20.31, 517., 113.));\n                    res = vec2(d, res.x);\n                }else if(d < res.y){\n                    res.y = d;\n                }\n    }\n    return vec2(res.x, abs(id));\n}\n/*\nfloat height(vec3 p){\n\tvec4 h;\n    h.xy = voronoi(p * 3.);\n    h.z = FBM(10. * p);\n    h.w = FBM(3. * p);\n    float craterSize = mix(.01, .1, h.y * .001);\n    return - h.w * .3 + h.z * .04\n           + mix(-pow(smoothstep(craterSize * 2., craterSize, h.x), 16.) * .005,\n                  pow(smoothstep(craterSize, 0., h.x), .75) * .1, smoothstep(craterSize + .005, craterSize - .005, h.x));\n}\n*/\nvec4 height(vec3 p){\n\tvec4 h;\n    h.r = FBM(3. * p);\n    h.g = FBM(10. * p);\n    h.ba = voronoi(p * 3.).xy;\n    return h;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {\n    if (iFrame > 1) discard;\n    fragColor -= fragColor;\n    fragColor = height(rayDir);\n    //fragColor.gba = normal(rayDir);\n}","name":"Cube A","description":"","type":"cubemap"}]}