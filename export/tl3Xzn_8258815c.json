{"ver":"0.1","info":{"id":"tl3Xzn","date":"1580269671","viewed":68,"name":"RayTraceRefractions","username":"JackSolace","description":"Ray trace of a half-spheer lens to showcase reflections and refractions","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray","lens","light","sphere","animated","reflect","refract","learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Jan 2020\n//Basic Raytrace of a Moving Sphere with Reflections and Refractions.\n//normally these checks would be done recursively but for educational purpses it is often\n//easier to see it done iteratively\n//The Reflections and Refractions are only calculated for one bounce\n//This is closer to a halfSphere \"Lens\" than a true glass sphere (need lots of bounces)\n#define PI 3.14159265359\n\nstruct Ray {\n\tvec3 origin; // Origin of ray (not to be confused with world origin)\n\tvec3 direction; // Direction Normalized vector\n};\n\nstruct Sphere {\n    int objID;\n\tvec3 center;  // Center of the Sphere\n\tfloat radius; // Radius of the Sphere\n};\n    \nstruct Plane {\n    int objID;\n\tvec3 normal; //Normal vector\n    vec3 point; //Some point such that for all points p in the plane dot((p-point),normal) == 0\n};\n\n//Simplest light source\nstruct PointLight {\n    vec3 position; //3d point in space\n    vec4 color; //RGBA color\n};\n\n    \n//Move the Sphere over time\nvoid AnimateSphere(inout Sphere sphere) {\n    //Size of the animation loop\n\tfloat loopRadius = 4.0;\n    //initial sphere position\n    float loopOffset = sphere.center.z;\n    //time it takes to complete a loop\n    float loopTime = 8.0;\n    \n    //Based on parametric equations of a circle\n    sphere.center.x = sin((mod(iTime, loopTime))/loopTime*2.0*PI)*loopRadius;\n    sphere.center.z = loopOffset + cos((mod(iTime,loopTime))/loopTime*2.0*PI)*loopRadius;\n    \n}\n    \n//Get the Specular color (shiny light)\nvec4 calculateSpecular(in vec3 rayd, in vec3 normal, in vec3 toLight, in PointLight light) {\n    //specular exponent\n    float shinnyness = 5.0;\n    //get the reflected light vector\n    vec3 reflected = 2.0*dot(toLight, normal)*normal - toLight;\n    //calculate specular color\n    return light.color * max(0.0,pow(dot(rayd,reflected),shinnyness));\n}\n    \n//Get the Diffuse color (Basic light effect)\nvec4 calculateDiffuse(in vec3 normal, in vec3 toLight, in PointLight light) {\n    return light.color * max(0.0,dot(normal,toLight));\n}\n    \n//Get the direction to the light source (no shadows simplifies check)\nvec3 checkLight(in vec3 intersect, in PointLight light) {\n    return normalize(light.position - intersect);\n}\n\n//Get the sphere surface normal from the intersection point\nvec3 getSphereIntersectionNormal(in vec3 intersect, in Sphere sphere) {\n\treturn normalize(intersect - sphere.center);\n} \n\n//Get the 3d point that is depth along the ray\nvec3 calculateIntersectionPoint(in Ray ray, in float depth) {\n\treturn ray.origin + ray.direction*depth;\n}\n    \n// From the Wikipedia page on Line-Plane intersection\nfloat intersectPlane(in Ray ray, in Plane plane) {\n\tfloat denominator = dot(plane.normal,ray.direction);\n    if(abs(denominator) >= 0.001) {//make sure Ray is not parallel to plane (or nearly parallel)\n        return dot((plane.point - ray.origin),plane.normal)/denominator;\n    }\n\treturn -1.0; // Any negative number to indicate no intersect (or intersection from behind)\n}\n\n// From the Wikipedia page on Line-sphere intersection\nfloat intersectSphere(in Ray ray, in Sphere sphere) {\n\t// Sphere center to ray origin\n\tvec3 co = ray.origin - sphere.center;\n\n\t// The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance from the ray origin to point of intersection\n    //bear in mind that there may be more than one solution\n\tfloat discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n\t\t\t- (dot(co, co) - sphere.radius * sphere.radius);\n\n\t// If answer is not negative, get ray intersection depth\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.direction, co) - sqrt(discriminant);\n\telse\n\t\treturn -1.; // Any negative number to indicate no intersect\n}\n\nfloat performPlaneCheck(in Ray ray, in Plane plane, in Sphere sphere, out vec4 color){\n//code for plane Check\n// Check if the ray from the camera through the pixel intersects the Plane\n\tfloat intersectionDepth = intersectPlane(ray,plane);\n    if (intersectionDepth >= 0.001 && intersectionDepth <= 1000.0) {//Front and Back Culling\n    \t//Point light is purple and a little to the left and aboveof the camera start\n    \tPointLight light = PointLight(vec3(-5.0,5.0,0.0), vec4(1.0,1.0,1.0,1.0));\n    \t//Get the ray intersection Point\n    \tvec3 intersect = calculateIntersectionPoint(ray,intersectionDepth);\n    \t//Initialize Plane color\n    \tvec4 ambientPlaneColor = vec4(0.0,0.0,0.0,1.0);\n    \t\n        //set Texture to appropriate material\n        if (plane.objID == 1) {\n        \tambientPlaneColor = texture(iChannel0,intersect.xz);\n        }else {\n        \tambientPlaneColor = texture(iChannel1,intersect.xy);\n        }\n        \n        \n    \t//Get the direction to the lightsource from the intersection point\n    \tvec3 toLight = checkLight(intersect, light);\n    \t//contruct Ray for shadow check\n    \tRay shadowRay = Ray(intersect, toLight);\n    \t//Do a shadow check\n    \tfloat shadowIntersectionDepth = intersectSphere(shadowRay,sphere);\n    \tif (shadowIntersectionDepth >= 0.05) { //Sphere is blocking the Light\n        \tcolor = ambientPlaneColor;\n    \t}else{ //Light is visable from this point\n        \tcolor = ambientPlaneColor + 0.25*calculateDiffuse(plane.normal, toLight, light);\n    \t}\n        return intersectionDepth;\n    }else{\n        // else draw background color (black)\n\t\tcolor = vec4(0.0,0.0,0.0,1.0);\n        return -1.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // output a 4d fragment color vector [R,G,B,A]\n    // input is a 2d fragment Co-ordinate vector [X,Y]\n    // can interpret input vector as a pixel (function is called 640x360 times by default per frame)\n    \n\t// Converting all coordinates (x,y) to be in the range [0,1]\n\tfloat u = fragCoord.x / iResolution.x; // iResolution.x is width in pixels\n\tfloat v = fragCoord.y / iResolution.y; // iResolution.y is height in pixels\n\n\t// Now convert from coordinate range [0,1] to [-1,1]\n\t// This moves pixel (0,0) to the middle of the image\n\tu = u * 2.0 - 1.0;\n\tv = v * 2.0 - 1.0;\n\n    //the following line is necessary since the image may not be a square\n    //removing this line results in the x dimension being stretched\n    u *= (iResolution.x/iResolution.y);\n    \n\t// The position of this pixel in 3D space \n    //(imagine a plane centered at the origin perpendicular to the camera, what would be the 3d coordinates of this pixel?)\n\tvec3 pixelPos = vec3(u, v, 0);\n\n    // The camera position in this example is on a fixed loop.\n    // Initialize at 0.0\n    vec3 cameraPos = vec3(0.0, 0.0, -4.0); \n    \n\t// The ray direction is ray from the camera through the pixel\n\tvec3 rayDir = normalize(pixelPos - cameraPos);\n    \n    // The Sphere is at the origin\n    Sphere sphere = Sphere(0,vec3(0.0, 0.0, 7.0), 1.0);\n    \n    //Animate the Sphere\n    AnimateSphere(sphere);\n    \n    // The wooden plane is the xz plane at y = -2.0\n    Plane woodPlane = Plane(1,vec3(0.0,1.0,0.0),vec3(0.0,-2.0,0.0));\n    \n    // The tile plane is the xy plane at z = 12.0\n    Plane tilePlane = Plane(2,vec3(0.0,0.0,-1.0), vec3(0.0,0.0,15.0));\n\n    //Create Ray struct from origin through current pixel\n    Ray ray = Ray(cameraPos, rayDir);\n    \n\t// Check if the ray from the camera through the pixel intersects the sphere\n\tfloat intersectionDepth = intersectSphere(ray, sphere);\n\n\t// If the depth at which the ray intersects the sphere is positive (in front of camera)\n\tif (intersectionDepth >= 0.05)//Sphere Check\n\t{//draw the sphere color (basic ambient + diffuse)\n        //ambient color of the sphere is greyish\n        vec4 ambientSphereColor = vec4(0.2,0.2,0.2,1.0);\n        \n        //Point light is white and a little to the left of the camera start\n        PointLight light = PointLight(vec3(-3.0,0.0,0.0), vec4(0.5,0.5,0.5,1.0));\n        \n        //Get the ray intersection Point\n        vec3 intersect = calculateIntersectionPoint(ray, intersectionDepth);\n        \n        //Get the surface normal at that point\n\t\tvec3 normal = getSphereIntersectionNormal(intersect,sphere);\n        \n        //Get the direction to the lightsource from the intersection point\n        vec3 toLight = checkLight(intersect, light);\n        \n        //we are going to skip the checks for shadows for the sphere\n        //but in other scenes we will not have this luxury\n        \n        //Refract Ray see https://en.wikipedia.org/wiki/Refraction for math details\n        vec3 refracted = refract(ray.direction,normal, 0.7);//1.0/1.2 is index of refraction for glass\n        Ray refractedRay = Ray(intersect,refracted);\n        \n        vec4 woodColor = vec4(0.0,0.0,0.0,0.0);//Initialize colors\n        vec4 tileColor = vec4(0.0,0.0,0.0,0.0);\n        \n        //This is a lazy way of handling 2 planes in a scene\n        float intersectedWood = performPlaneCheck(refractedRay,woodPlane,sphere, woodColor);\n        float intersectedTile = performPlaneCheck(refractedRay,tilePlane,sphere, tileColor);\n        vec4 refColor = vec4(0.0,0.0,0.0,0.0);\n        if (intersectedWood < 0.0)\n        {\n        \trefColor = tileColor;\n        }else if (intersectedTile <= intersectedWood){\n        \trefColor = tileColor;\n        }else{\n            refColor = woodColor;\n        }\n        \n        //calculate reflected Ray (normalize here is because im paranoid)\n        vec3 reflected = normalize(ray.direction - 2.0*dot(ray.direction, normal)*normal);\n        Ray rayreflect = Ray(intersect,reflected);\n          \n        //initialize reflected color\n        vec4 reflectColor = vec4(1.0,1.0,1.0,1.0);\n        //Plane Check\n        float intersected = performPlaneCheck(rayreflect,woodPlane,sphere,reflectColor);\n        //For this Scene we can skip the tilePlane check on reflections since\n        //we cannot reflect from the sphere to the back wall.\n        if (intersected > 0.0){\n        \t//Combine it all to get the correct color (with reflected and refracted Color (mostly refracted))\n        \tfragColor = 0.25*ambientSphereColor + 0.25*calculateDiffuse(normal,toLight,light) + 0.15*reflectColor + 0.35*refColor;\n        }else{\n        \t//Combine it all to get the correct color (with refracted)\n        \tfragColor = 0.33*ambientSphereColor + 0.17*calculateDiffuse(normal,toLight,light) + 0.5*refColor;\n        }\n        \n    } else {//Plane Checks (No Sphere Hit)\n        vec4 woodColor = vec4(0.0,0.0,0.0,0.0);//Initialize colors\n        vec4 tileColor = vec4(0.0,0.0,0.0,0.0);\n        \n        //This is a lazy way of handling 2 planes in a scene\n        float intersectedWood = performPlaneCheck(ray,woodPlane,sphere, woodColor);\n        float intersectedTile = performPlaneCheck(ray,tilePlane,sphere, tileColor);\n        \n        if (intersectedWood < 0.0)\n        {\n        \tfragColor = tileColor;\n        }else if (intersectedTile <= intersectedWood){\n        \tfragColor = tileColor;\n        }else{\n            fragColor = woodColor;\n        }\n        //Ideally a well coded ray tracer would handle these checks generically for all obj's in a scene\n        //This is a toy example\n    }\n}","name":"Image","description":"","type":"image"}]}