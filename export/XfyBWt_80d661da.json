{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// The core algorithm is adapted from Inigo Quilez: https://www.shadertoy.com/view/MlKcDD\n// What's different here is that there is no clamping of `t` values. This is because I intentionally want to render the stroke of a quadratic Bézier curve without round caps.\n//\n// For strongly-correct stroking it would be needed to split the quadratic into monotonic subsegments and stroke these additively, while adding additional joins when the curve has a cusp.\n//\n// For a definition for what 'strongly-correct' means, see here:\n// - https://w3.impa.br/~diego/projects/Neh20/\n// - https://www.youtube.com/watch?v=UrnnCKYw6aA (3:50)\n\nfloat cos_acos_3(in float x) {\n    x = sqrt(0.5 + 0.5 * x);\n    return x * (x * (x * (x * -0.008972 + 0.039071) - 0.107074) + 0.576975) + 0.5;\n}\n\nvec3 one_root(in float h, in float p, in float q, in float kx) {\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n\n    vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n    float t = uv.x + uv.y;\n\n    t -= (t * (t * t + 3.0 * p) + q) / (3.0 * t * t + 3.0 * p);\n    t = t - kx;\n\n    return vec3(t, -1.0, -1.0);\n}\n\nvec3 three_roots(in float p, in float q, in float kx) {\n    float z = sqrt(-p);\n    float m = cos_acos_3(q / (p * z * 2.0));\n    float n = sqrt(1.0 - m * m);\n\n    n *= sqrt(3.0);\n\n    return vec3(m + m, -n - m, n - m) * z - kx;\n}\n\nvec3 nearest_quadratic_points(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n\n    return (h >= 0.0) ? one_root(h, p, q, kx) : three_roots(p, q, kx);\n}\n\nvec2 eval_quadratic_at(in vec2 p0, in vec2 p1, in vec2 p2, in float t) {\n    float mt = 1.0 - t;\n    float mt2 = mt * mt;\n    float t2 = t * t;\n    \n    return mt2 * p0 + 2.0 * mt * t * p1 + t2 * p2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    vec2 scale = iResolution.xy;\n    float stroke_width = min(iResolution.x, iResolution.y) / 10.0;\n\n\tvec2 v0 = vec2(0.9, 0.9) * cos(iTime * 0.5 + vec2(0.0, 5.0));\n    vec2 v1 = vec2(0.9, 0.9) * cos(iTime * 0.6 + vec2(3.0, 4.0));\n    vec2 v2 = vec2(0.9, 0.9) * cos(iTime * 0.7 + vec2(2.0, 0.0));\n\n    vec2 p0 = (v0 + 1.0) * 0.5 * scale;\n    vec2 p1 = (v1 + 1.0) * 0.5 * scale;\n    vec2 p2 = (v2 + 1.0) * 0.5 * scale;\n\n    vec3 t = nearest_quadratic_points(uv, p0, p1, p2);\n    \n    float d0 = (t.x >= 0.0 && t.x <= 1.0) ? distance(uv, eval_quadratic_at(p0, p1, p2, t.x)) : 2.0 * stroke_width;\n    float d1 = (t.y >= 0.0 && t.y <= 1.0) ? distance(uv, eval_quadratic_at(p0, p1, p2, t.y)) : 2.0 * stroke_width;\n    float d2 = (t.z >= 0.0 && t.z <= 1.0) ? distance(uv, eval_quadratic_at(p0, p1, p2, t.z)) : 2.0 * stroke_width;\n    \n    float half_stroke = stroke_width / 2.0;\n    float inside = float(min(d0, min(d1, d2)) <= half_stroke);\n\n    vec4 src_color = vec4(1.0, 0.0, 0.0, 1.0) * inside;\n    vec4 dst_color = vec4(1.0, 1.0, 1.0, 1.0);\n\n    // Output to screen\n    fragColor = mix(dst_color, src_color, inside);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfyBWt","date":"1734801151","viewed":76,"name":"Quadratic Stroke (No Caps)","username":"vg_head","description":"This is an example where a quadratic Bézier curve is stroked but there are no caps at the endpoints.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["bezier","stroke","rasterization"],"hasliked":0,"parentid":"","parentname":""}}