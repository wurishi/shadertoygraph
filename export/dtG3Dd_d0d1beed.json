{"ver":"0.1","info":{"id":"dtG3Dd","date":"1685037590","viewed":49,"name":"Path Tracing Torus","username":"CEDipEngineering","description":"Simplified path tracer for torus.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","torus","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Tipos de Materias implementados\n#define lambertian 0\n#define metal 1\n\n// Definições de material dos objetos\nstruct Material {\n  vec3 albedo; // na prática a cor do objeto\n  int type; // tipo (lambertiam ou metal)\n};\n\n// Raio lançado diretamente ou refletido\nstruct Ray {\n  vec3 origin, direction;\n};\n\n// Estrutura para controle de colisões de raios\nstruct hit_record {\n  float t;\n  vec3 p, normal;\n  Material mat;\n};\n\n// Definições para esferas\nstruct Sphere {\n  vec3 center;\n  float radius;\n  Material mat;\n};\n\nstruct Torus {\n  vec3 center;\n  float R;\n  float r;\n  Material mat;\n};\n\n// Rotinas para números aleatórios\nvec3 frand;\nvec3 rand = vec3(0.5, 0.5, 0.5);\nvec2 rand2(){ \n  vec2 rand = vec2(\n    mod(rand.y*(195.1*frand.z+371.2*frand.x+508.3*frand.y), 1.0),\n    mod(rand.x*(573.9*frand.z+736.4*frand.y+914.5*frand.x), 1.0)\n  );\n  return fract(rand).xy-0.5;\n}\n\nvec3 random_in_unit_sphere(){ \n  rand = vec3(\n    mod(rand.z*((7.1*frand.z)+(5.1*frand.x)+(9.7*frand.y))*3.83,2.0),\n    mod(rand.x*((1.1*frand.z)+(6.7*frand.x)+(4.9*frand.y))*1.57,2.0),\n    mod(rand.y*((3.1*frand.z)+(4.3*frand.x)+(5.2*frand.y))*2.34,2.0)\n  );\n  return (rand-vec3(1.0));\n}\n\nvec3 random_unit_vector() {\n    return (normalize(random_in_unit_sphere()));\n}\n\nvec3 random_in_hemisphere(vec3 normal) {\n    vec3 in_unit_sphere = random_in_unit_sphere();\n    if (dot(in_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal\n        return in_unit_sphere;\n    else\n        return -in_unit_sphere;\n}\n\n\n// Verifica se um vetor ter todas suas coordenadas muito pequenas\nbool near_zero(vec3 e) {\n  float s = 1e-8;\n  return (abs(e[0]) < s) && (abs(e[1]) < s) && (abs(e[2]) < s);\n}\n\n\n// Retornando o ponto em um t de raio\nvec3 point_at_parameter(Ray r, float t) {\n  return(r.origin + t*r.direction);\n}\n\n// Verificando o lado da face correto\nvec3 set_face_normal(Ray r, vec3 outward_normal) {\n    bool front_face = dot(r.direction, outward_normal) < 0.0;\n    return front_face ? outward_normal :-outward_normal;\n}\n\n\n// Cria o raio para o pixel da tela\nRay get_ray(vec2 uv) {\n  float aspect = iResolution.x/iResolution.y;\n  vec3 lower_left_corner = vec3(-1.0*aspect,-1.0, -1.0);\n  vec3 horizontal = vec3(2.0*aspect, 0.0, 0.0);\n  vec3 vertical = vec3(0.0,2.0, 0.0);\n  \n  float an = 0.5*iTime;\n  vec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n  vec3 ta = vec3( 0.0, 0.1, 0.0 );\n  \n  vec2 p = (-iResolution.xy + 2.0*uv)/iResolution.y;\n  // camera matrix\n  vec3 ww = normalize( ta - ro );\n  vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n  vec3 vv = normalize( cross(uu,ww));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n  \n  Ray r = Ray(ro, rd); \n  return r;\n}\n\n// Verifica e atualiza dados no caso da intersecção de um raio\nbool hit_sphere(Sphere s, Ray r, float t_min, float t_max, out hit_record rec){\n  \n\n  vec3 oc = r.origin - s.center;\n  float a = dot(r.direction,r.direction);\n  float half_b = dot(oc, r.direction);\n  float c = dot(oc,oc) - s.radius*s.radius;\n  float discriminat = half_b*half_b - a*c;\n  if (discriminat < 0.0) return(false);\n  float sqrtd = sqrt(discriminat);\n  \n  float root = (-half_b - sqrtd) / a;\n  if (root < t_min || t_max < root) {\n    root = (-half_b + sqrtd) / a;\n    if (root < t_min || t_max < root)\n      return false;\n  }\n      \n  rec.t = root;\n  rec.p = point_at_parameter(r,rec.t);\n  \n  vec3 outward_normal = (rec.p - s.center) / s.radius;\n  rec.normal = normalize(set_face_normal(r, outward_normal));\n  rec.mat = s.mat;\n    \n  return(true);\n}\n\n// Cálculo para os raios refletidos de alguma forma\nbool scatter(Material mat, Ray r_in, hit_record rec, out vec3 attenuation, out Ray scattered) {\n  \n  vec3 scatter_direction = rec.normal + random_unit_vector();\n  \n  if (near_zero(scatter_direction))\n    scatter_direction = rec.normal;\n\n  if(mat.type == 0) {\n    scattered = Ray(rec.p, scatter_direction);\n    attenuation = mat.albedo;\n    return true;\n  }\n\n  if(mat.type == 1) {\n    vec3 reflected = reflect(normalize(r_in.direction), rec.normal);\n    scattered = Ray(rec.p, reflected);\n    attenuation = mat.albedo;\n    return(dot(scattered.direction, rec.normal) > 0.0);\n  }\n  \n  return false;\n  \n}\n\n\n\n// ---------------------------------------------------------------------- //\n// Definição da cena\nSphere world = Sphere(vec3( 0.0, -100.5, -1.0), 100.0, Material(vec3(0.8, 0.8, 0.0),0));\nTorus object = Torus(vec3(0.0, 0.0, 0.0), 1.0, 0.5, Material(vec3(0.3, 0.8, 0.1), 1));\n// ---------------------------------------------------------------------- //\n\n\n// Trata lista de todos os objetos da cena\nbool hitable_list(Ray r, float t_min, float t_max, inout hit_record rec) {\n   \n    float t = iTorus(r.origin, r.direction, vec2(object.R, object.r));\n    if (t < 0.0) return false;\n    rec.t = t;\n    rec.p = point_at_parameter(r,rec.t);\n    rec.normal = nTorus(rec.p, vec2(object.R, object.r));\n    rec.mat = object.mat;\n    \n  return true;\n}\n\n\n// Rotina que calcula a cor final do pixel\nconst int max_depth = 10;\nvec3 color(Ray r){\n  hit_record rec;\n  vec3 col = vec3(1.0);\n  Ray raio = r;\n  for(int i=0; i < max_depth; i++){\n    if(hitable_list(raio, 0.0001, 100.0, rec)) {\n    \n      Ray scattered;\n      vec3 attenuation = vec3(0.0);\n      \n      if (scatter(rec.mat, r, rec, attenuation, scattered))\n        raio = scattered;\n      else break;\n      \n      col *= attenuation;      \n\n    } else {\n      vec3 unit_direction = normalize(r.direction);\n      float t = 0.5 * (unit_direction.y + 1.0);\n      col *= mix(vec3(1.0), vec3(0.5,0.7,1.0), t);\n      return col;\n    }\n  }\n  return col;\n}\n\n\nconst float samples_per_pixel = 10.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord/iResolution.xy;\n  vec3 col = vec3(0.0);\n  for(float s=2.0; s<=samples_per_pixel; ++s) {\n      frand = vec3(fragCoord.xy,s);\n      vec2 delta;\n      delta = rand2() / iResolution.xy;\n      Ray r = get_ray(fragCoord+delta);\n      col += color(r);\n  }\n  col /= samples_per_pixel;\n  float gamma = 2.0;\n  col = pow(col, vec3(1.0/gamma));\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://iquilezles.org/articles/intersectors/\n\n// Return t along line where intersection occurs\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return -1.0;\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\n// Return normal\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}","name":"Common","description":"","type":"common"}]}