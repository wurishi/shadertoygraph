{"ver":"0.1","info":{"id":"cdSGRw","date":"1667389616","viewed":212,"name":"Fear Inoculum","username":"RagePly","description":"An attempt to remake Tool's Fear Inoculum album cover.\nReference: https://en.wikipedia.org/wiki/Fear_Inoculum\n\nAny and all feedback is appreciated!","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","sdf","helix","cover","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAn attempt to remake Tool's Fear Inoculum album cover.\n\nDefines FEAR_DIST in buffer b and FEAR_BLUR can be commented out to remove lens distortion and blur respectively.\n\nAny and all feedback is appreciated!\n\nReference: https://en.wikipedia.org/wiki/Fear_Inoculum\n\n*/\n\nfloat lerp( in float x, in float a, in float b )\n{\n    return (clamp(x, a, b) - a)/(b-a);\n}\n\n#define FEAR_BLUR\n#define GAUSS_SIZE 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / iResolution.x;\n    vec2 uv = (fragCoord / iResolution.xy - vec2(0.5, 0.5)) * vec2(1.0, ratio);\n    vec2 screen = fragCoord/iResolution.xy;\n    \n    #ifdef FEAR_BLUR\n    \n    vec3 tex = vec3(0.0);    \n    // apply more blur radially, with the center around the \"blue lightsource\"\n    float sigma_factor = smoothstep(0.0, 0.250, length(uv-vec2(0.0, -0.1)));\n    \n    // adapt sigma wrt screen resolution\n    float sigma = sigma_factor * iResolution.x/350.0 + 0.1*(1.0 - sigma_factor);\n    float G = 0.0;\n    \n    // Gaussian blur https://en.wikipedia.org/wiki/Gaussian_blur\n    for (int i = -GAUSS_SIZE; i <= GAUSS_SIZE; i++)\n    {\n        for (int j = -GAUSS_SIZE; j <= GAUSS_SIZE; j++)\n        {\n            float x = float(i);\n            float y = float(j);\n            vec2 v = vec2(x, y) / iResolution.xy;\n            \n            float g = exp(- (x*x + y*y)/(2.0*sigma*sigma));\n            \n            G += g;\n            \n            tex += g * texture(iChannel0, screen + v).rgb;\n            \n        }\n    }\n    \n    vec3 color = tex / G;\n    #else\n    vec3 color = texture(iChannel0, screen).rgb;\n    #endif\n    \n    // slight tint around adges\n    float radial_shadow = 1.0 - length(uv);\n    radial_shadow *= radial_shadow;\n    color *= lerp(radial_shadow, -0.5, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// feature\nbool eyelid;\nbool iris;\nbool pupil;\n#define pi 3.141592653589793\n\n// 2D heightmap with input theta: angle around the helix-arm and psi: angle around y-axle\nfloat radial_offset( in float theta, in float psi )\n{\n    float eye_ridge = 0.7 + 0.1*sin(iTime);\n    float eye_crater = 0.6 + 0.1*sin(iTime);\n    float eye_pupil = 0.7;\n    \n    float x = theta+psi+iTime/10.0;\n    float y = psi;\n    \n    float height = (pow(sin(10.0*x), 2.0) + pow(sin(23.0*y), 2.0))/2.0;\n    \n    if (height > eye_ridge)\n    {\n        eyelid = true;\n        height = 2.0*eye_ridge - height;\n        \n        if (height < eye_crater)\n        {\n            iris = true;\n            height = 2.0*eye_crater - height;\n            \n            if ( height > eye_pupil ) pupil = true;\n        }\n    }\n    else {\n        // simple roughness\n        height += 0.0025*(sin(100.0*x) + sin(300.0*y));\n        height += 0.0012*(sin(232.0*x+123.0) + sin(600.0*y+789.0));\n    }\n    \n    return (1.0 - clamp(height, 0.1, 1.0));\n}\n\n// adapted from https://www.shadertoy.com/view/ttB3DV\nfloat helix_sdf( in vec3 pos, in float rad, in float vert )\n{\n    // horizontal distance\n    float h = length(pos.xz) - rad;\n    \n    // vertical distance from spiral\n    float t = pos.y / vert * 2.0 * pi;\n    float v = vert * asin(sin(t + 0.5*atan(pos.x, pos.z))) / 2.0 / pi;\n    \n    // distance = distance from arm with thickness given by constant + offset map\n    return sqrt(h*h + v*v) - 9.0 + radial_offset( atan(v, h), atan(pos.x, pos.z));\n}\n\n// [a, b] -> [0, 1], with clamping.\nfloat lerp( in float x, in float a, in float b )\n{\n    return (clamp(x, a, b) - a)/(b-a);\n}\n\n// https://iquilezles.org/articles/fog/\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -distance*0.005 );\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float ratio = iResolution.y / iResolution.x;\n   vec2 uv = (fragCoord / iResolution.xy - vec2(0.5, 0.5)) * vec2(1.0, ratio);\n   \n   // setup ray\n   vec3 o = vec3(0.0,0.0,-0.5);\n   vec3 d = normalize(vec3(uv, 0.0) - o);\n   o = vec3(uv,0.0);\n   \n   // rotate camera\n   float xtilt = -0.4;\n   \n   mat4 xrot = rotationMatrix(vec3(1.0,0.0,0.0), xtilt);\n   o = (xrot * vec4(o,1.0)).xyz;\n   d = (xrot * vec4(d,1.0)).xyz;\n   \n   // translate camera\n   \n   o += vec3(-7.0,-0.0,-25.0);\n   \n   // helix settings\n   \n   float coil = 60.0;\n   float rad = 20.0;\n   \n   // raymarch https://iquilezles.org/articles/raymarchingdf/\n   float dist = 0.0;\n   bool hit = false;\n   float h;\n   int i = 0;\n   \n   for(; i < 100 && dist < 100.0; i++)\n   {\n       // reset features\n       eyelid = false;\n       iris = false;\n       pupil = false;\n       \n       h = helix_sdf(o,rad,coil);\n       if (h < 0.001)\n       {\n           hit = true;\n           break;\n       }\n       \n       dist += 0.9*h;\n       o += 0.9*h*d;\n   }\n   \n   \n   if (hit) \n   {\n       // approximate surface normal\n       float dDdx = (helix_sdf(o + vec3(0.001, 0.0, 0.0), rad, coil) - h)/0.001;\n       float dDdy = (helix_sdf(o + vec3(0.0, 0.001, 0.0), rad, coil) - h)/0.001;\n       vec3 n = normalize(vec3(dDdx, dDdy, 1));\n       \n       // primary smooth-shading \n       float normal = dot(n, normalize(vec3(-1.0, 0.6, 0.5)));\n       float shader = lerp(clamp(normal, 0.0, 1.0), -0.02, 2.0);\n       \n       // highlight\n       vec3 highlight = 1.0 * smoothstep(0.47, 0.5, shader) * vec3(0.396, 0.718, 0.996);\n       \n       // AmBient Occlusion\n       float abo = exp(-float(i)*0.05);\n       \n       // left arm-highlight\n       float left_highlight = 3.0*smoothstep(0.5, 1.0, dot(n, normalize(vec3(-0.4, 1.0, 0.0)))); // direction + amp\n       left_highlight *= smoothstep(0.3, 1.0, dot(normalize(o.xz), vec2(-1.0, -0.0))); // sector bias/filter\n       left_highlight = 1.2*lerp(left_highlight, 0.0, 1.0); // compress and amplify\n       vec3 lh = left_highlight * vec3(0.667, 0.875, 0.969);\n       \n       // underside glow\n       vec3 light_source = vec3(0.0, -40.0, 30.0);\n       float height = 1.0 - lerp(o.y, -40.0, -20.0); // height bias/filter\n       float lightcomp = dot(n, normalize(light_source - o)); // light direction\n       vec3 light = 5.0 * height * lerp(lightcomp, 0.0, 1.0) * vec3(0.8,0.75,1.0);\n       \n       // material color\n       vec3 base_color = 0.5 * vec3(0.8,0.8,1.0);\n       if (pupil)\n       {\n           base_color = vec3(-1.0,-1.0,-1.0); // make them really dark\n       }\n       else if (iris)\n       {\n           base_color = vec3(2.0, 2.0, 2.0); // have them pop out\n       }\n       else if (eyelid)\n       {\n           base_color = vec3(0.8, 0.1, 0.1);\n       }\n       \n       \n       base_color = lh + highlight + abo * 0.5*shader * base_color + light;\n       fragColor = vec4(applyFog(base_color, dist), 1.0);\n   } \n   else \n   {\n       fragColor = vec4(vec3(0.0), 1.0);\n   \n   }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define FEAR_DIST\n// https://nullprogram.com/blog/2018/07/31/\nuint hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n// lens distortion with wavelength bias\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord / iResolution.xy;\n#ifdef FEAR_DIST\n    \n    // direct distortion radially \n    float ratio = iResolution.y / iResolution.x;\n    vec2 of  = (uv - vec2(0.5, 0.5) - vec2(0.0, -0.2)) * vec2(1.0, ratio) / iResolution.xy;\n    float rad = length(of*iResolution.xy);\n    of *= -iResolution.x/190.0 * smoothstep(0.0, 0.3, rad);\n    \n    // apply more distortion towards the highlighted areas\n    of *= 1.0 - smoothstep(0.5, 1.5, uv.x); // slight left-bias\n    of *= 1.0 - smoothstep(0.5, 1.5, uv.y); // slight down-bias\n    \n    // apply some grain\n    uint u = uint(fragCoord.x * iResolution.y);\n    uint v = uint(fragCoord.y);\n    uint h = hash(u + v);\n    float hf = float(h);\n    float hx = mod(hf, 1000.0) / 1000.0;\n    float hy = mod(hf / 1000.0, 1000.0) / 1000.0;\n    vec2 gof = iResolution.x * 0.001 * vec2(hx, hy) / iResolution.xy;\n    \n    // sample texture with increasing offset\n    vec4 t1  = texture(iChannel0, uv + 5.0 * of + gof);\n    vec4 t4  = texture(iChannel0, uv + 10.0 * of + gof);\n    vec4 t16 = texture(iChannel0, uv + 15.0 * of + gof);\n    \n    float red = t1.r;\n    float green = t4.g;\n    float blue = t16.b;\n    \n    fragColor = vec4(red, green, 1.1*blue, 1.0);\n#else\n    fragColor = texture(iChannel0, uv);\n#endif\n}","name":"Buffer B","description":"","type":"buffer"}]}