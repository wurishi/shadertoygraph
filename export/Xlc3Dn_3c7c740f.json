{"ver":"0.1","info":{"id":"Xlc3Dn","date":"1468576136","viewed":937,"name":"multipass zoom/radial blur","username":"seniltai","description":"multipass radial/zoom blur based on ryg's comments on pouet in 2008","likes":11,"published":3,"flags":32,"usePreview":0,"tags":["blur","zoom","radial","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPSIZE_SEQ 3.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tfragColor += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor /= STEPS;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// camera attributes\n// cameraDirection and cameraUp MUST be normalized\n// (ie. their length must be equal to 1)\nconst vec3 cameraPosition = vec3(0.0, 0.0, 5.0);\nconst vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\n// epsilon-type values\nconst float S = 0.1;\nconst float EPSILON = 0.001;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    return length(p) - 1.0;\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\n\nfloat computeLambert(vec3 p, vec3 n, vec3 l){\n    float ndotl = clamp(dot(normalize(l-p), n), 0.0, 1.0);\n    return pow(ndotl, 1.0/2.2);\t// dirty srgb\n}\n\nvec2 computeLatLong(vec3 n)\n{\n \treturn vec2(atan(n.y,sqrt(dot(n.xz, n.xz))), atan(n.z,n.x));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 20; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0*cos(iTime), 50.0*cos(iTime));\n            vec3 normal = computeSurfaceNormal(hit);\n            vec2 latlon = computeLatLong(normal);\n            float lighting = computeLambert(hit, normal, light);\n            latlon.xy += iTime;\n            vec3 tex = texture(iChannel0, latlon).xyz;\n            vec3 texInv =  texture(iChannel1, latlon).xyz;\n            result =  pow(mix(tex, texInv, lighting), vec3(4.0))*4.0;\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n\n    // generate the ray for this pixel\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 pixelColour = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColour, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define STEPSIZE_SEQ 0.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 16.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tfragColor += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor /= STEPS;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define STEPSIZE_SEQ 1.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tfragColor += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor /= STEPS;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define STEPSIZE_SEQ 2.0\n\n// IDENTICAL CODE\n#define RADIAL 0\n#define STEPSIZE_CONFIG 0.12 * sin(iTime)\n#define STEPS 6.0\n#define STEPSIZE (((STEPSIZE_CONFIG) * pow(2.0, STEPSIZE_SEQ)) / STEPS)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 zoomUv = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvDelta = zoomUv- uv;\n    \n#if RADIAL == 1\n  \tuvDelta.xy = vec2(-uvDelta.y, uvDelta.x);\n#endif\n    \n    for(float i=0.0; i<STEPS; i += 1.0)\n    {\n    \tfragColor += texture(iChannel0, uv + (uvDelta * STEPSIZE * i) );\n    }\n    fragColor /= STEPS;\n}","name":"Buffer D","description":"","type":"buffer"}]}