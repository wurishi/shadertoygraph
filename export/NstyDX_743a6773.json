{"ver":"0.1","info":{"id":"NstyDX","date":"1654604796","viewed":306,"name":"Volumetric Solar Flare","username":"MatheoMoinet","description":"Solar Flare like object made using\nhttps://www.shadertoy.com/view/NscyDB\nPlease imagine the sun under it ;)","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sun","bezier","flare","mapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"QBezier 2 Cylinder volume noise\" by MatheoMoinet. https://shadertoy.com/view/stffD7\n// 2022-06-02 09:35:54\n\n//From FabriceNeyret2 https://www.shadertoy.com/view/llySRh\n// --- key toggles -----------------------------------------------------\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n// --- events ----------------------------------------------------------\n\n// --- mouse side events https://www.shadertoy.com/view/3dcBRS\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame)\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n// ------------------\n\n\n#define MAX_STEPS 1000\n#define MAX_BACKWARD_STEPS 10\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define LIGHT_MARCH_STEP_SIZE 0.1\n#define LIGHT_MARCH_SAMPLING_STEP_SIZE 0.2\n#define VOLUME_MARCH_STEP_SIZE 0.02\n#define TRANSPARENCY_STOP_THRESHOLD 0.01\n\n#define WHITE_BACKGROUND 0\n#define NO_LIGHT 0\n#define TEST_ON 0\n#define USE_ALBEDO 1\n\n#if USE_ALBEDO == 1  //  Either set the albedo value (which corresponds to the material color)\nconst vec3 albedo = vec3(0.980,0.306,0.047);  //Portion of light returning to the observer\nconst vec3 sigma_t = vec3(0.6,0.6,0.6);  //Portion of light that keeps going after traversing the volume //#FA4E0C\nconst vec3 sigma_s = albedo*(1.-sigma_t);\nconst vec3 sigma_a = (1.-albedo)*(1.-sigma_t);\n\n#else  // Or set the sigma_t and sigma_a values // sigma_s + sigma_a +  sigma_t MUST be equal to vec3(1.)\nconst vec3 sigma_s = vec3(.1,.2,.3);  //Portion of light scattered back when traversing the volume\nconst vec3 sigma_a = vec3(.1);  //Portion of light absorbed by the material\nconst vec3 sigma_t = 1.-sigma_a-sigma_s;  //Portion of light that keeps going after traversing the volume\n#endif\n\nfloat unit_density = 50.;\nvec3 lightColor = vec3(20.);\n\n#define DIAMETER_BEZIER 0.5\n#define USE_BEZIER_BBOX 1\n#define SIMPLIFIED_INTERSECTIONS 1\n#define BEZIER_SMOOTH_RADIUS_COEF 0.3\n#define BEZIER_LENGTH_DISTORTION_MODE 0    //0: length= t,    1: length= real length\n#define BEZIER_LENGTH_REZOLUTION 5 //At least 2\n#define BEZIER_VOLUME_LENGTH_DISTORTION_MODE 1\n#define BEZIER_VOLUME_RADIUS_DISTORTION_MODE 1\n\n#define NOISE_OCTAVE 5\n#define NOISE_THRESHOLD 0.1\n\n#define TIME_SPEED 0.3\n#define FLARE_TIME mod(iTime*TIME_SPEED,3.14)\n\n// ========= Bezier Struct and Globals =======================================================================================================================\n\nconst int bezier_nbr_curves = 1;\nconst int bezier_nbr_segments = 4; //Total nbr of segments of all curves\n#define BEZIER_MAX_NBR_ADDI_SEGMENTS 3 //Max nbr of segments for one curve\n\n\n\nstruct bbox3 {\n    vec3 mMin, mMax;\n};\n\nstruct BezierSegment {\n    vec3 A,B,C;  //Control points\n    float angle_offset; //Fixed as long as the curve doesn't change\n    bool bbox_can_intersect; //Fixed as long as the curve and the ray direction don't change\n    float acc_length_offset;\n    float seg_length;\n};\n\nstruct BezierCurve {\n    vec3[3] init_ctrl_points;\n    vec3[BEZIER_MAX_NBR_ADDI_SEGMENTS] addi_ctrl_points;\n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] Bs_dist_coef;\n    int curve_id;\n    int nbr_segments;\n    int segment_arr_offset;\n    int last_closest_segment;\n    float max_diameter;\n    bool bboxs_can_intersect;\n};\nBezierCurve[bezier_nbr_curves] bezier_curves;\nint new_curve_arr_offset=0;\nint new_curve_id = 0;\nBezierSegment[bezier_nbr_segments] bezier_all_segments;\n\n// ============= Utils =================================================================================================================================================\n\nfloat angle_btw_vec3(vec3 v1, vec3 v2, vec3 normal){ //BTW -180 and 180°\n    v1 = normalize(v1); v2 = normalize(v2);\n    vec3 cross_v1v2 = cross(v1, v2); float dot_v1v2 = dot(v1, v2);\n    float angle3 = atan(dot(cross_v1v2,normal), dot_v1v2); // https://stackoverflow.com/questions/5188561 //atan2((Va x Vb) . Vn, Va . Vb)\n    return degrees(angle3);    \n}\nfloat angle_btw_vec3(vec3 vector1, vec3 vector2){ //BTW 0 and 180°\n    return degrees(acos(dot(normalize(vector1), normalize(vector2))));\n}\nvec2 iBBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ){ // ray-box intersection in box space //Taken from IQ's shader : https://www.shadertoy.com/view/tsBfRD\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n#define hash33(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n\nvec3 rand_unit_vector(vec3 p)\n{\n    return normalize(2.*hash33(p)-1.);\n}\n\nfloat perlin_noise(vec3 p,float grid_size)\n{\n    p*=grid_size;\n\tvec3 pi = floor(p);\n    vec3 pf = p-pi;\n    vec3 w = pf*pf*(3.-2.*pf);\n    \n    float f000 = dot(rand_unit_vector(pi+vec3(.0,.0,0.)),pf-vec3(.0,.0,0.));\n    float f001 = dot(rand_unit_vector(pi+vec3(.0,.0,1.)),pf-vec3(.0,.0,1.));\n    float f010 = dot(rand_unit_vector(pi+vec3(.0,1.0,0.)),pf-vec3(.0,1.0,0.));\n    float f011 = dot(rand_unit_vector(pi+vec3(.0,1.0,1.)),pf-vec3(.0,1.0,1.));\n    float f100 = dot(rand_unit_vector(pi+vec3(1.0,.0,0.)),pf-vec3(1.0,.0,0.));\n    float f101 = dot(rand_unit_vector(pi+vec3(1.0,.0,1.)),pf-vec3(1.0,.0,1.));\n    float f110 = dot(rand_unit_vector(pi+vec3(1.0,1.0,0.)),pf-vec3(1.0,1.0,0.));\n    float f111 = dot(rand_unit_vector(pi+vec3(1.0,1.0,1.)),pf-vec3(1.0,1.0,1.));\n\n    float xm1 = mix(f000,f100,w.x);\n    float xm2 = mix(f001,f101,w.x);\n    float xm3 = mix(f010,f110,w.x);\n    float xm4 = mix(f011,f111,w.x);\n    float ym1 = mix(xm1,xm2,w.z); \n    float ym2 = mix(xm3,xm4,w.z); \n    float zm = mix(ym1,ym2,w.y);\n    \n    return zm*1./sqrt(1./2.);\n}\n\nfloat noise_sum(vec3 p,int octave){\n\tfloat a = 1., r = 0., s=0.;\n    vec3 o[NOISE_OCTAVE] ;\n    o[0] = p;\n    for (int i=1; i<NOISE_OCTAVE; i++){\n        o[i] = o[i-1]*2.;\n    }\n    for (float i=0.; i<float(octave); i+=1.){\n        r += a*perlin_noise(o[int(i)],1.);\n        s = s + a;        \n        a = a*0.5;\n    }\n    return r/s;\n}\nfloat noise_mul(vec3 p,int octave){\n\tfloat r = 1., s=1.;\n    vec3 o[NOISE_OCTAVE] ;\n    o[0] = p;\n    for (int i=1; i<NOISE_OCTAVE; i++){\n        o[i] = o[i-1]*2.;\n    }\n    for (float i=0.; i<float(octave); i+=1.){\n        r *= smoothstep(-0.5,0.5, perlin_noise(o[int(i)],1.))*2.;\n        s *= 2.;        \n    }\n    return r/s;\n}\n\n\n// ============= Bezier Basic Functions =========================================================================================================================================================\n\nvec3 bezierFunc( vec3 A, vec3 B, vec3 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return (1.0-t)*(1.0-t)*A + 2.0*(1.0-t)*t*B + t*t*C; // b(t) = (1-t)^2*A + 2(1-t)t*B + t^2*C\n}\n\nvec3 bezier_dx( vec3 A, vec3 B, vec3 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return 2.0*(t-1.0)*A + 2.0*(1.0-2.0*t)*B + 2.0*t*C; // b'(t) = 2(t-1)*A + 2(1-2t)*B + 2t*C\n}\n\nvec3 bezier_dx_dx( vec3 A, vec3 B, vec3 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return 2.0*A - 4.0*B + 2.0*C; // b\"(t) = 2*A - 4*B + 2*C\n}\n\nbbox3 bezierBbox( in vec3 p0, in vec3 p1, in vec3 p2 ){ //Taken from IQ's shader : https://www.shadertoy.com/view/tsBfRD\n    vec3 mi = min(p0,p2);\n    vec3 ma = max(p0,p2);\n    vec3 t = clamp((p0-p1)/(p0-2.0*p1+p2),0.0,1.0);\n    vec3 s = 1.0 - t;\n    vec3 q = s*s*p0 + 2.0*s*t*p1 + t*t*p2;\n    mi = min(mi,q);\n    ma = max(ma,q);\n    return bbox3( mi, ma );\n}\n\n\n\n// ============= Bezier Setup Functions =========================================================================================================================================================\n\nvoid bezierSaveLastClosestSegment(BezierCurve bezier_curve){\n    bezier_curves[bezier_curve.curve_id].last_closest_segment = bezier_curve.last_closest_segment;\n}\n\nvoid bezierSaveBboxsCanIntersect(BezierCurve bezier_curve){\n    bezier_curves[bezier_curve.curve_id].bboxs_can_intersect = bezier_curve.bboxs_can_intersect;\n}\n\nBezierSegment bezierGetSegment(BezierCurve bezier_curve, int segment_i){\n    return bezier_all_segments[bezier_curve.segment_arr_offset+segment_i];\n}\n\nvoid bezierSetSegment(BezierCurve bezier_curve, int segment_i, BezierSegment segment){\n    bezier_all_segments[bezier_curve.segment_arr_offset+segment_i] = segment;\n}\n\nfloat bezierLength(BezierSegment seg, float t){\n    int nbr_parts = BEZIER_LENGTH_REZOLUTION;\n    vec3 pos_on_curve = bezierFunc(seg.A, seg.B, seg.C, t);\n    vec3 last_point = seg.A;\n    vec3 next_point;// = bezierFunc(seg.A, seg.B, seg.C, 1./nbr_parts);\n    float total_len = 0.;//= length(last_point-next_point);\n    for (float i=1.; (1./float(nbr_parts))*i < t ; i++){\n        next_point = bezierFunc(seg.A, seg.B, seg.C, (1./float(nbr_parts))*i);\n        total_len += length(last_point-next_point);\n        last_point = next_point;\n    }\n    total_len += length(last_point-pos_on_curve);\n    return total_len;\n}\nfloat bezierLength(BezierCurve b_curve, float t){\n    BezierSegment seg = bezierGetSegment(b_curve, int(t));;\n    float local_len;\n    if (float(b_curve.nbr_segments) == t){ //Last segment, and t = 1. for this segment\n        local_len = bezierLength(seg, 1.);\n        seg = bezierGetSegment(b_curve, int(t-1.));\n    } else {\n        local_len = bezierLength(seg, fract(t));\n    }\n    float total_len = local_len + seg.acc_length_offset;\n    return total_len;\n}\n\nfloat bezierCurvilinearAbscissa(BezierCurve b_curve, float t){\n    #if BEZIER_LENGTH_DISTORTION_MODE == 0\n        return t;\n    #else\n        return bezierLength(b_curve, t);\n    #endif\n}\n\nfloat bezierGetRadius(BezierCurve bezier_curve, float t){\n    if (t<0. || t> float(bezier_curve.nbr_segments)){\n        return 0.;\n    }\n    switch (bezier_curve.curve_id){\n        case 0:\n            //t = bezierLength(bezier_curve, t)*0.1;\n            return 0.5+smoothstep(0.0, 2., t)*0.5;//0.4*2.*abs(cos(iTime));//*t;\n            break;\n    }\n}\n\nvoid bezierCreateSegments(BezierCurve bezier_curve){\n    int seg_idx = bezier_curve.segment_arr_offset;\n    bezier_all_segments[seg_idx].A = bezier_curve.init_ctrl_points[0];\n    bezier_all_segments[seg_idx].B = bezier_curve.init_ctrl_points[1];\n    bezier_all_segments[seg_idx].C = bezier_curve.init_ctrl_points[2];\n    for (int i=0; i<bezier_curve.nbr_segments-1; i++){\n        int seg_idx = bezier_curve.segment_arr_offset+i+1;\n        vec3 A = bezier_all_segments[seg_idx-1].C;\n        vec3 C = bezier_curve.addi_ctrl_points[i];\n        vec3 prevB = bezier_all_segments[seg_idx-1].B;\n        vec3 B = A + (A-prevB)*bezier_curve.Bs_dist_coef[i];\n        bezier_all_segments[seg_idx].A = A;\n        bezier_all_segments[seg_idx].B = B;\n        bezier_all_segments[seg_idx].C = C;\n    }\n}\n\nvoid bezierInitSegmentBboxsCanIntersect(BezierCurve b_curve, vec3 ro, vec3 rd){\n    bool bboxs_can_intersect = false;\n    for (int i=0; i<b_curve.nbr_segments; i++){\n        BezierSegment seg = bezierGetSegment(b_curve, i);\n        bbox3 bbox = bezierBbox(seg.A,seg.B,seg.C);\n        bbox.mMin -= b_curve.max_diameter;\n        bbox.mMax += b_curve.max_diameter;\n        vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n        vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n        vec2 intersect = iBBox(ro, rd, bcen, brad);\n        seg.bbox_can_intersect = ! (intersect==vec2(-1.0));\n        bboxs_can_intersect = bboxs_can_intersect || seg.bbox_can_intersect;\n        bezierSetSegment(b_curve, i, seg);\n    }\n    b_curve.bboxs_can_intersect = bboxs_can_intersect;\n    bezierSaveBboxsCanIntersect(b_curve);\n}\n\nvoid bezierInitSegmentBboxsCanIntersect(vec3 ro, vec3 rd){\n    for (int i=0; i<bezier_curves.length(); i++){\n        bezierInitSegmentBboxsCanIntersect(bezier_curves[i], ro, rd);\n    }\n}\n\nvoid bezierInitSegmentLength(BezierCurve b_curve){\n    float acc_length_offset = 0.;\n    for (int i=0; i<b_curve.nbr_segments; i++){\n        BezierSegment seg = bezierGetSegment(b_curve, i);\n        seg.acc_length_offset = acc_length_offset;\n        float seg_len = bezierLength(seg, 1.);\n        acc_length_offset += seg_len;\n        seg.seg_length = seg_len;\n        bezierSetSegment(b_curve, i, seg);\n    }\n}\n\nvoid bezierInitAngleOffset(BezierCurve bezier_curve){\n    vec3 reference_plan_n = vec3(1.,0.,0.);\n    float acc_angle_offset = 0.;\n    vec3 A,B,C;\n    vec3 bezier_plan_n; \n    for (int i=0; i<bezier_curve.nbr_segments; i++){     // Calculate accumulated_offset\n        BezierSegment currentSegment = bezierGetSegment(bezier_curve,i);\n        A = currentSegment.A, B = currentSegment.B, C = currentSegment.C;\n        bezier_plan_n = normalize(cross(B-A,C-A)); //Normal to the plan in wich the 3 control points (i.e. the curve) lay\n        vec3 bezier_plan_up = normalize((B-A));\n        float angle_btw_prev_plan_and_plan = angle_btw_vec3(reference_plan_n, bezier_plan_n, bezier_plan_up);\n        acc_angle_offset += angle_btw_prev_plan_and_plan; acc_angle_offset = mod(180.+acc_angle_offset, 360.)-180.;\n        reference_plan_n = bezier_plan_n;\n        currentSegment.angle_offset = acc_angle_offset;\n        bezierSetSegment(bezier_curve,i,currentSegment);\n    }\n}\n\nvoid initBezierSegments(BezierCurve bezier_curve, vec3 ro, vec3 rd){\n    bezierCreateSegments(bezier_curve);\n    bezierInitSegmentBboxsCanIntersect(bezier_curve, ro, rd);\n    bezierInitSegmentLength(bezier_curve);\n    bezierInitAngleOffset(bezier_curve);\n}\n\nvoid initBezierCurves(vec3 ro, vec3 rd){\n    for (int i=0; i<bezier_curves.length(); i++){\n        initBezierSegments(bezier_curves[i], ro, rd);\n    }\n}\n\nBezierCurve createBezierCurve(\n    vec3[3] init_ctrl_points, \n    vec3[BEZIER_MAX_NBR_ADDI_SEGMENTS] addi_ctrl_points, \n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] Bs_dist_coef, \n    int nbr_of_segments,\n    float max_diameter\n){\n    int curve_id = new_curve_id++;\n    int segment_arr_offset = new_curve_arr_offset;\n    new_curve_arr_offset += nbr_of_segments;\n    BezierCurve bezier_curve = BezierCurve(init_ctrl_points,addi_ctrl_points,Bs_dist_coef,curve_id,nbr_of_segments,segment_arr_offset,0, max_diameter, false);\n    bezier_curves[curve_id] = bezier_curve;\n    return bezier_curve;\n}\n\n\n// =========== Bezier Curves Definitions ===========================================================================================================================================================\n\nvoid createAllBezierCurves(){\n    // Curve 1\n    float flare_time = sin(FLARE_TIME+1./3.*sin(FLARE_TIME));\n    flare_time = sqrt(flare_time);\n\n    float ring_height_coef = clamp(flare_time, -0.3, 1.)*2.;\n    float ring_width_coef = clamp(flare_time, 0.01, 1.)*2.;\n    float ring_z_coef = 0.;//1.-ring_height_coef;\n    vec3[3] bezier_1_init_pts = vec3[](\n            vec3(1.0,-4.0,-2.0),\n            vec3(3.*ring_width_coef,-4.,-2.),\n            vec3(3.*ring_width_coef, -4.+3.*ring_height_coef,-2.+1.*ring_z_coef)\n    );\n    vec3[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_1_addi_pts;\n    bezier_1_addi_pts[0] = vec3(0.0,-4.+6.*ring_height_coef,-2.0+2.*ring_z_coef);\n    bezier_1_addi_pts[1] = vec3(-3.0*ring_width_coef-0.5*FLARE_TIME,-4.+3.*ring_height_coef,-2.0+1.*ring_z_coef);\n    bezier_1_addi_pts[2] = vec3(-1.0-1.*FLARE_TIME,-4.0,-2.0);\n\n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_1_Bs_dist_coef;\n    bezier_1_Bs_dist_coef[0] = 1.;    \n    bezier_1_Bs_dist_coef[1] = 1.;\n    bezier_1_Bs_dist_coef[2] = 1.;\n\n    BezierCurve bezier1 = createBezierCurve(bezier_1_init_pts, bezier_1_addi_pts, bezier_1_Bs_dist_coef, 4,4.);\n    \n}\n\n// ======================================================================================================================================================================\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b ){ //Taken from IQ's website\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox(vec3 p , bbox3 bbox){\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n    return sdBox(p-bcen,brad);\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){ //Taken from IQ's website\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); } //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec3 pos, vec3 A, vec3 B, vec3 C){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        // 1 root\n        res = vec2(dot2(d+(c+b*t)*t),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        \n        // 3 roots, but only need two\n        float dis = dot2(d+(c+b*t.x)*t.x);\n        res = vec2(dis,t.x);\n        dis = dot2(d+(c+b*t.y)*t.y);\n        if( dis<res.x ) res = vec2(dis,t.y );\n    }\n    res.x = sqrt(res.x);\n    return res;\n}\n\nvec2 sdBezier(vec3 pos, BezierCurve bezier_curve, BezierSegment segment, int i){\n    vec3 A = segment.A, B = segment.B, C = segment.C;\n    vec2 res = sdBezier(pos, A,B,C);\n    float curr_radius = bezierGetRadius(bezier_curve, res.y + float(i));\n    if (res.y<=0. || res.y>=1.){\n        float curr_extremity = clamp(0.,1.,res.y); //Either 0. or 1.\n        vec3 p0 = bezierFunc(A,B,C,curr_extremity);\n        vec3 tangeant = bezier_dx(A,B,C,curr_extremity);\n        if (curr_extremity == 1.){\n            tangeant = -tangeant;\n        }\n        vec3 p1 = p0 + tangeant;\n        res.x = sdCylinder(pos, p0, p1, curr_radius);\n    } else {\n        res.x -= curr_radius;\n    }\n    return res;\n}\n\nvec2 sdBezier(vec3 pos, BezierCurve bezier_curve){ // sd for multy segment bezier curve, with optimizations\n    #if USE_BEZIER_BBOX\n    if (! bezier_curve.bboxs_can_intersect){\n        return vec2(MAX_DIST,0.); //None of the segment can intersect, return early\n    }\n    #endif\n    bool shouldLookForNewClosestSegment = true;\n    int last_closest = bezier_curve.last_closest_segment;\n    BezierSegment currentSegment = bezierGetSegment(bezier_curve,last_closest);\n    vec2 best_res = sdBezier(pos, bezier_curve, currentSegment, last_closest);\n    #if SIMPLIFIED_INTERSECTIONS == 1\n        if (best_res.x <= 0. && best_res.y >= 0. && best_res.y <= 1.){\n            shouldLookForNewClosestSegment = false;\n        }\n    #endif\n    best_res.y += float(last_closest);\n    if (shouldLookForNewClosestSegment)\n    for (int i=0; i<bezier_curve.nbr_segments; i++){   \n        if (i == last_closest){\n                continue;\n        }\n        currentSegment = bezierGetSegment(bezier_curve,i);\n        #if USE_BEZIER_BBOX\n            if (!currentSegment.bbox_can_intersect){\n                continue;\n            }\n            /* // Actually slower to perform in most cases than calling sdBezier alone, so not usefull\n            bbox3 bez_bb = currentSegment.bbox;\n            float dist_to_bb= sdBox(pos,bez_bb);\n            if (dist_to_bb>best_res.x){\n                continue;\n            }/**/\n        #endif\n        vec2 res = sdBezier(pos, bezier_curve, currentSegment, i);\n        if (res.x < best_res.x ){ //&& res.y>=0. && res.y<=1.\n            best_res = res;\n            best_res.y += float(i); \n            bezier_curve.last_closest_segment = i;\n            bezierSaveLastClosestSegment(bezier_curve);\n        }\n    }\n    return best_res;\n}\n\n\nfloat bezierGetAngle(BezierCurve bezier_curve, float t, vec3 p){\n    BezierSegment currentSegment = bezierGetSegment(bezier_curve,int(floor(t)));\n    vec3 A = currentSegment.A, B = currentSegment.B, C = currentSegment.C;\n    float acc_angle_offset = currentSegment.angle_offset ;\n        \n    // Calculate angle relative to current bezier curve\n    t = fract(t);\n    vec3 bezier_p = bezierFunc(A,B,C,t);\n    vec3 bezier_dir = normalize(bezier_dx(A,B,C,t)); //Direction of the gradient of the bezier curve // normal to the disc // Equi to Tangent vector in Frenet formulas https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas\n    vec3 direction_to_p = normalize(bezier_p-p);\n    vec3 bezier_plan_n = normalize(cross(B-A,C-A)); //Normal to the plan in wich the 3 control points (i.e. the curve) lay //Equi to Binormal vector\n    //bezier_plan_n = normalize(bezier_dx_dx(A,B,C,t)); // Also Binormal vector in theory, but is more general (and probably faster ?)\n    vec3 normal_to_bezier_in_plan = cross(bezier_plan_n,bezier_dir); //Equi to Normal vector\n    if (any(isnan(normal_to_bezier_in_plan)) || any(isinf(normal_to_bezier_in_plan))){ //handle case when the 3 cpoints are alligned\n        //st_assert(false);\n        return 0.;\n    }\n    float angle = angle_btw_vec3(direction_to_p, normal_to_bezier_in_plan, bezier_dir);\n    angle -= acc_angle_offset; angle = mod(180.+angle, 360.)-180.; //Add offset\n    return angle;\n}\n\nvec3 getPointInBasicCylinder(float height, float dist_to_center, float angle){ // Return coordinates inside vertical cylinder centered at origin, radius 1, infinite height\n    angle = radians(angle);\n    vec3 cyl_origin = vec3(0.);\n    vec3 p_in_cylinder = cyl_origin + vec3(0.,height, 0.);\n    vec2 dir_center_to_point = vec2(cos(angle), sin(angle));\n    p_in_cylinder.xz = dir_center_to_point * dist_to_center;\n    return p_in_cylinder;\n}\n\nvec3 bezierMapToCylinder(float t, BezierCurve bezier_curve, float dist_to_bezier_surface, float angle){\n    float height = bezierCurvilinearAbscissa(bezier_curve, t); //Height inside cylinder\n    angle += mod((height*1.+ iTime*0.0)*360.,360.); //Twist along vertical axis\n    height*=0.5;\n    \n    //Map to a vertical cylinder of origin vec3(0.) , radius 1, and heigth 1   \n    float curve_radius = bezierGetRadius(bezier_curve, t);\n    float dist_to_bezier = dist_to_bezier_surface+curve_radius;\n    float dist_to_center = dist_to_bezier/curve_radius; //Normalized distance to center of cylinder;\n    return getPointInBasicCylinder(height, dist_to_center, angle);\n}\n\nfloat GetDist(vec3 p) {\n    float d=1e8;\n    for (int i=0; i<bezier_nbr_curves; i++){\n        BezierCurve bezier_curve = bezier_curves[i];\n        d = min(d,sdBezier(p, bezier_curve).x);\n    }\n    return d;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec2 RayMarchVolume(vec3 ro, vec3 rd) {\n    bool is_inside = false;\n    if (GetDist(ro) < 0.){ //Already inside\n        is_inside = true;\n    }\n\tfloat dO=0., in_dist = 0., out_dist = 0.;\n    float last_dS = 0., last_last_dS = 0.;\n    float last_ms = 0., last_last_ms = 0.;\n    const int max_backward_steps = MAX_BACKWARD_STEPS;\n    int nbr_backward_steps = 0;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        float march_step = dS*0.5;\n        \n        if (is_inside == false && dS>0. && last_last_dS != 0.){ //Try to handle case where we go through/over object without detecting them when diameter grows too fast\n            float slop = (dS - last_dS)/last_ms;\n            float prev_slop = (last_dS - last_last_dS)/last_last_ms;\n            float acceleration = slop-prev_slop;\n\n            float predicted_next_dS = dS + (slop + acceleration)*march_step;\n            if (predicted_next_dS<0.){ //Will go on the other side of object\n                float predicted_intersection_dS = -dS/(slop+acceleration); // dist where the predicted object interesects with the ray\n                predicted_intersection_dS *=0.5; //Step half to prevent going too far\n                march_step = min(march_step, predicted_intersection_dS); //New march step size should not be higher than the predicted intersection dist\n            }\n        }\n        if (last_last_dS == 0.){\n            march_step = 0.01;\n        }\n        \n        dO += abs(march_step);\n        if (dO>MAX_DIST){\n            break;\n        }\n        \n        if (abs(dS)<SURF_DIST){\n            if (is_inside == false){ //In edge\n                in_dist = dO;\n                is_inside = true;\n                \n            } else if (last_dS<dS){ // Out edge\n                out_dist = dO;                \n                return vec2(in_dist,out_dist);\n            }\n            dO+= SURF_DIST;//SURF_DIST*2.-dS;\n        } else {\n            if (is_inside == true && dS>0.){ //Got outside but didn't detect out edge\n                out_dist = dO;       //TODO Revert half of the distance traveled ?\n                return vec2(in_dist,out_dist);\n            } \n            \n            if (is_inside == false && dS<0.){ //Got inside but didn't detect in edge\n                if (dO<in_dist || in_dist == 0.){ // Keep the best 'in_dist' so far\n                    in_dist = dO;\n                }\n                \n                if (nbr_backward_steps < max_backward_steps){ // Go backward half of the distance to the object to try to find the edge\n                    dO -= abs(march_step); //Cancel current march step\n                    dO -= abs(dS)/2.; //Go back half of the distance\n                    nbr_backward_steps++;\n                    continue; // Do not update last_dS etc\n                } else { // Consider that we are inside, use best in_dist as real in_dist\n                    is_inside = true;\n                }\n            }\n        }\n        last_last_dS = last_dS;\n        last_dS = dS;\n        last_last_ms = last_ms;\n        last_ms = march_step;\n    }\n    //i> MAX_STEPS or dO> MAX_DIST\n    if (is_inside && dO<MAX_DIST) return vec2(in_dist, max(in_dist, dO));\n    else return vec2(dO,dO);\n}\n\n\nfloat bezierVolumeDistortion(float t, BezierCurve bezier_curve){\n    float distortion = 1.;\n    #if BEZIER_VOLUME_RADIUS_DISTORTION_MODE == 1\n    float radius = bezierGetRadius(bezier_curve, t);\n    float radius_distortion = 1./radius;\n    distortion *= radius_distortion;\n    #endif\n\n    #if BEZIER_VOLUME_LENGTH_DISTORTION_MODE == 1\n    BezierSegment seg = bezierGetSegment(bezier_curve, int(t));\n    float seg_length = seg.seg_length;\n    float curr_length = bezierLength(seg, t);\n    float normalized_length = curr_length/seg_length;\n    float length_distortion = t/normalized_length /seg_length;\n    distortion *= length_distortion;\n    #endif\n    return distortion;\n}\n\nfloat bezierOccupancy(vec3 p, BezierCurve bezier_curve){\n    vec2 bezier_info = sdBezier(p, bezier_curve);\n    float t = bezier_info.y ;\n    float smooth_bezier = smoothstep(0., 0.-0.02-BEZIER_SMOOTH_RADIUS_COEF, bezier_info.x);\n    //float smooth_bezier = smoothstep(DIAMETER_BEZIER, 0.2, bezier_info.x);\n    float bezier1 = smooth_bezier ;\n    \n    \n    bezier1 *= smoothstep(-3.5,-3.1, p.y);\n    \n    if (bezier1>0.){ //If in bezier segment\n        float angle = bezierGetAngle(bezier_curve, t, p);\n        # if TEST_ON == 1\n            float norm_angle = (angle)/180.;\n            float angle_to_show = 0.; float angle_to_show_range = 0.005;\n            bool show_angle = norm_angle>(angle_to_show-angle_to_show_range) && norm_angle<(angle_to_show + angle_to_show_range);\n            st_assert(show_angle == false);\n        #endif\n\n        vec3 p_mapped = bezierMapToCylinder(t,bezier_curve, bezier_info.x, angle);\n        p_mapped += p_mapped+vec3(0.,-FLARE_TIME*3.,0.);\n        float noise = noise_mul(p_mapped, NOISE_OCTAVE);\n\n        //noise = abs(noise);\n        //bezier1 *= smoothstep(0.8, 0.1,length(p_mapped.xz+noise));\n        noise = smoothstep(0.00, 0.5,noise);\n        noise *= smoothstep(1., -0.5, p_mapped.y);\n        bezier1 *= smoothstep(1., 0.1,length(p_mapped.xz));\n        bezier1*=noise;\n        \n        float distortion = bezierVolumeDistortion(t, bezier_curve);\n        bezier1*=distortion;\n        \n    }\n    return bezier1;\n}\n\nfloat occupancyFunction(vec3 p){\n    float bezier_occupancy = 0.;\n    for (int i=0; i<bezier_nbr_curves; i++){\n        BezierCurve bezier_curve = bezier_curves[i];\n        bezier_occupancy += bezierOccupancy(p,bezier_curve);\n    }\n    float objects = bezier_occupancy;//clamp(bezier_occupancy,0.,1.);\n    return objects;\n}\n\n\nfloat GetLocalDensity(vec3 p){\n    float occupancy = occupancyFunction(p);\n    return occupancy*unit_density;\n}\n\nvec3 calculateTransparency(float len, float density){\n    return exp(-len *density * (1.-sigma_t) );\n}\n\nvec3 GetVolumeColor(vec3 ro, vec3 rd, float dist_start, float dist_end,vec3 lightDir, inout vec3 T_acc){\n    if (dist_end-dist_start == 0.){\n        return vec3(0.); // maybe should remove and just not loop and return color = 0 and T = 1\n    }\n    \n    vec3 color = vec3(0.); //accumulated color as we move into the volume\n    //T_acc = vec3(1.); //accumulated transparency as we move into the volume\n    vec3 localTransparency;\n\n    float total_dist = dist_end-dist_start;\n    float step_size = VOLUME_MARCH_STEP_SIZE;\n\n    float localDensity;\n    vec3 p;\n    vec3 albedo = sigma_s / (sigma_s + sigma_a);\n    float mapped_step_size;\n    \n    for (float dist=0.; dist<total_dist; dist+=step_size){\n        p = ro + rd*(dist_start+dist); //p += rd*dist;\n        localDensity = GetLocalDensity(p);\n        \n        if (localDensity>0.){\n            localTransparency = calculateTransparency(step_size, localDensity);\n            vec3 localOpacity = 1.-localTransparency;\n            vec3 phase = vec3(1.);  //Fraction of light reflected depending on the angle to the light, per color. 1. for now\n            vec3 illum = lightColor * phase; //Should actually compute how much light reaches through the volume\n            \n            vec3 lightReachingPoint = illum * phase * T_acc;\n            //vec3 lightReachingPoint = illum * phase ;\n            vec3 materialLocalColor = albedo * localOpacity;\n            color+= T_acc * materialLocalColor * lightReachingPoint ;\n            \n            T_acc*=localTransparency; //The probability to have light through multiple slices is the multiplication of the probability of the slices\n            \n            if ((T_acc.x + T_acc.y + T_acc.z) < TRANSPARENCY_STOP_THRESHOLD){\n                T_acc = vec3(0.);\n                break;\n            }\n        }\n        step_size = VOLUME_MARCH_STEP_SIZE*max(0.05,sqrt(dist)); //max to avoid infinite loop when dist == 0\n    }\n    return color ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord.xy-(0.5*iResolution.xy))/iResolution.y;\n    vec2 m = iMouse.xy == vec2(0.) ? vec2(0.5) : iMouse.xy/iResolution.xy;\n    \n    #if NO_LIGHT\n        lightColor *= vec3(uv.y<0.);\n    #endif\n    \n    createAllBezierCurves();\n    \n    vec3 ro = vec3(0, 3., -3);\n    //vec3 ro = vec3(0, 4., -10);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);   \n    \n    initBezierCurves(ro, rd);\n    \n    \n    vec3 background = vec3(0.);\n    //background = vec3(0.067,0.141,0.22);\n    #if WHITE_BACKGROUND\n        background = vec3(uv.x>0.);\n    #endif\n    vec3 col =vec3(0.);\n    vec3 lightPos = vec3(sin(iTime),1.,cos(iTime));\n   \n    vec2 distances = RayMarchVolume(ro, rd);\n    vec3 T_acc = vec3(1.);\n    \n    float total_in_dist, total_out_dist;\n    \n    const int max_nbr_it = 100;\n    int nbr_it = 0;\n    while (distances.x<MAX_DIST && nbr_it<max_nbr_it){\n        vec3 lightDir = normalize(lightPos);\n        bezierInitSegmentBboxsCanIntersect(ro + rd*(distances.x), rd);\n        col += GetVolumeColor(ro,rd,distances.x,distances.y, lightDir, T_acc);\n        distances = vec2(distances.y)+0.1;\n        bezierInitSegmentBboxsCanIntersect(ro + rd*(distances.y), rd);\n        distances += RayMarchVolume(ro + rd*(distances.y), rd);\n        //st_assert(nbr_it<3);\n        nbr_it++;\n    }\n    col += T_acc * background;\n    \n    col = pow(col,vec3(1./2.2));\n    fragColor = vec4( col ,1.0);\n\n    #if TEST_ON == 1\n        st_assert( length((sigma_s + sigma_a + sigma_t) - 1.) < 1e-5);\n\n    #endif\n}","name":"Image","description":"","type":"image"}]}