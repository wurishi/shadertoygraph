{"ver":"0.1","info":{"id":"ll23Rd","date":"1431588925","viewed":4565,"name":"Companion Cube Remix","username":"ChristinaCoffin","description":"Remixed a couple existing shadertoys that had nothing to do with a companion cube to make a \"Companion Cube\" :) \nSee the tex() + heartMapping() func for my main experiment of mixing procedural heart shape in raymarching object","likes":72,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Companion Cube Remix - @christinacoffin\n//\t- heart shape mapping doesnt completely play nice with the parallax mapping, something to improve upon.\n// \t\n// modified version of Parallax mapping demo by nimitz (twitter: @stormoid)  : https://www.shadertoy.com/view/4lSGRh\n// modified procedural heartshape by Iq : https://www.shadertoy.com/view/XsfGRn\n\n//Show only the raymarched geometry (for comparison)\n//#define RAYMARCHED_ONLY\n\n//The amount of parallax\n#define PARALLAX_SCALE .2\n\n//Scale the texture offset as a function of incidence (much better results)\n#define USE_OFFSET_SCALING\n#define OFFSET_SCALE 4.\n\n//Bump mapping intensity\n#define BUMP_STRENGTH .21\n#define BUMP_WIDTH 0.004\n\n//Main texture scale\nconst float texscl = 2.5;\n\n#define ITR 70\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat hash(vec2 x){\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); }\n\nfloat sdfsw = 0.; //Global mouse control\n\nfloat length4(in vec3 p ){\n\tp = p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/4.0 );\n}\n\nfloat map(vec3 p)\n{\n    float d = mix(length(p)-1.1,length4(p)-1.,sdfsw-0.3);\n    d = min(d, -(length4(p)-4.));\n    return d*.95;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//From TekF (https://www.shadertoy.com/view/ltXGWS)\nfloat cells(in vec3 p)\n{\n    p = fract(p/2.0)*2.0;\n    p = min(p, 2.0-p);\n    return 1.-min(length(p),length(p-1.0));\n}\n\nvec4 heartMapping( in vec2 p )\n{\t\n\tp.y -= 0.25;\n\n    // background color\n    // make this black for now since we use the heart shape to displace things and dont want the other parts affected (keep it black colored)\n    vec3 bcol = vec3(0,0,0);//1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\n    // shape\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\t// color\n\tfloat s = d;//1.0-0.5*clamp(r/d,0.0,1.0);\n    \n\ts = 0.5;// + 0.5*p.x;\n\ts *= 1.0;//-0.25*r;\n\ts = 0.5 + 0.6*s;\n\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\n\tvec3 hcol = vec3(1.0,0.0,0.3)*s;\n\t\n    vec3 col = mix( bcol, hcol, smoothstep( -0.01, 0.01, d-r) );\n\n    col.x *= ss;//fluctate color based on the beating animation\n    col.y = ss;//\n\n    //todo: we could encode other shapes in other color channels and mix them in tex() differently\n    \n    return vec4(col,1.0);\n}\n\nfloat tex( vec3 p )\n{\n    p *= texscl;\n    float rz= 0.0;//-0.5;\n    float z= 1.;\n    \n    // do the Heart shape mapping before the parallax loop warps the position data\n    // triplanar map it so we get it on all 6 sides\n    float heartScaleFactor = 1.1;\n    vec4 heart0 = heartMapping( p.xy * heartScaleFactor );\n    vec4 heart1 = heartMapping( p.zy * heartScaleFactor );\n    vec4 heart2 = heartMapping( p.xz * heartScaleFactor );\n    \n    heart0 = max( heart0, heart1 );\n    heart0 = max( heart0, heart2 );\n    float heartMask = (heart0.x + heart1.x + heart2.x *0.333);\n    heartMask = clamp(heartMask, 0.0, 1.0);\n    \n    for ( int i=0; i<2; i++ )\n    { \n        #ifndef RAYMARCHED_ONLY\n        rz += cells(p)/z;\n        #endif\n        \n        p *= 2.5*0.15;\n        z *= -1.1*0.15;\n    }\n \n    return clamp(heartMask+(rz*rz)*4.95,0.,1.)*2.73 - 1.0-heartMask;\n}\n\n/*\n\tThe idea is to displace the shaded position along the surface normal towards\n\tthe viewer,\tthe tgt vector is the displacement vector, then\tI apply a scaling\n\tfactor to the displacement and also have an incidence based\toffset scaling set up.\n*/\nvec3 prlpos(in vec3 p, in vec3 n, in vec3 rd)\n{\n    //vec3 tgt = cross(cross(rd,n), n); //Naive method (easier to grasp?)\n    vec3 tgt = n*dot(rd, n) - rd; //Optimized\n\n#ifdef USE_OFFSET_SCALING\n    tgt /= (abs(dot(tgt,rd)))+OFFSET_SCALE;\n    \n#endif\n    \n    p += tgt*tex(p)*PARALLAX_SCALE;\n    return p;\n}\n\nfloat btex(in vec3 p)\n{\n    float rz=  tex(p);\n    rz += tex(p*20.)*0.01; //Extra (non-parallaxed) bump mapping can be added\n    \n //   rz += tex(p);\n    \n    return rz;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(BUMP_WIDTH*sqrt(ds)*0.5, 0);\n    float n0 = btex(p);\n    vec3 d = vec3(btex(p+e.xyy)-n0, btex(p+e.yxy)-n0, btex(p+e.yyx)-n0)/e.x;\n    vec3 tgd = d - n*dot(n ,d);\n    n = normalize(n-tgd*BUMP_STRENGTH*2./(ds));\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 bp = fragCoord.xy/iResolution.xy*2.-1.; \n    vec2 p = bp;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.4,-0.25):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t\n    \n    mo.y = 0.425;// lock the shape to be 'companion cube-ish in appearance\n    mo.y += (0.5 * abs(sin(iTime)))-0.15; \n    \n    p.x += mo.x*1.;\n    sdfsw = mo.y*4.;\n    \n\tvec3 ro = vec3(0.,0.,4.);\n    vec3 rd = normalize(vec3(p,-3.+sin(time*0.9+sin(time))));\n    mat2 mx = mm2(time*.1+sin(time*0.4)-0.2);\n    mat2 my = mm2(time*0.07+cos(time*0.33)-0.1);\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n\t\n\tfloat rz = march(ro,rd);\n\t\n    vec3 col = vec3(0);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos );\n        pos = prlpos(pos,nor,rd);\n        float d = distance(ro,pos);\n        nor = bump(pos, nor, d);\n\n        vec3 ligt = normalize( vec3(-.5, 0.5, -0.3) );\n        float dif = clamp( dot( nor, ligt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-ligt))), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),10.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        vec3 brdf = vec3(0.3);\n        brdf += bac*vec3(0.3);\n        brdf += dif*0.5;\n        \n        float tx=  tex(pos);\n        col = sin(vec3(1.5+mo.x*0.4,2.2+mo.x*0.25,2.7)+tx*1.2+4.2)*0.6+0.55;\n        col = col*brdf + spe*.5/sqrt(rz) +.25*fre;\n        \n        col = mix(col,vec3(.0),clamp(exp(rz*0.43-4.),0.,1.));\n    }\n \n    col.x *= col.z;//colorize\n    col.xyz = col.zxy;//color channel flip!   \n    \n    \n    col = clamp(col*1.05,0.,1.);\n    col *= pow(smoothstep(0.,.2,(bp.x + 1.)*(bp.y + 1.)*(bp.x - 1.)*(bp.y - 1.)),.3);\n    col *= smoothstep(3.9,.5,sin(p.y*.5*iResolution.y+time*10.))+0.1;\n    col -= hash(col.xy+p.xy)*.025;\n\t\n\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}