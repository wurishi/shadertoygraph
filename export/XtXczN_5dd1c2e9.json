{"ver":"0.1","info":{"id":"XtXczN","date":"1503597027","viewed":496,"name":"RGB Gradient study","username":"Kchplr","description":"RGB Gradient study","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["gradients"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec3 correctMixColor (const in vec3 color1, const in vec3 color2, const in float ratio) {\n    return sqrt(\n        pow(color1, vec3(2.)) * (1. - ratio) + pow(color2, vec3(2.)) * ratio\n    );\n}\n\nvec3 correctSmoothMixColor (const in vec3 color1, const in vec3 color2, const in float ratio) {\n    return sqrt(\n        pow(color1, vec3(2.)) * (1. - ratio) + pow(color2, vec3(2.)) * smoothstep(0., 1., ratio)\n    );\n}\n\nvec3 customMixColor (const in vec3 color1, const in vec3 color2, const in float ratio) {    \n    return pow(\n        pow(color1, vec3(1.8, 2.2, 1.6)) * (1. - ratio) + pow(color2, vec3(1.8, 2.2, 1.6)) * ratio,\n    \t1. / vec3(1.8, 2.2, 1.6)\n    );\n}\n\nvec3 customMixColor2 (const in vec3 color1, const in vec3 color2, const in float ratio) {    \n    return mix(normalize(clamp(color1, 1e-9, 1.)), normalize(clamp(color2, 1e-9, 1.)), smoothstep(0., 1., ratio)) * mix(length(color1), length(color2), ratio);\n}\n\nvec3 customMixColor3 (const in vec3 color1, const in vec3 color2, const in float ratio) {\n    vec3 baseColor = mix(color1, color2, ratio);\n    float baseLuma = dot(baseColor, vec3(0.299, 0.587, 0.114));\n    float dstLuma = dot(correctMixColor(color1, color2, ratio), vec3(0.299, 0.587, 0.114));\n    return baseColor * (mix(1., 1. + (dstLuma - baseLuma) * 2., 1. - pow(2. * abs(ratio - 0.5), 2.2)));\n}\n\nvec3 customMixColor4 (const in vec3 color1, const in vec3 color2, const in float ratio) {\n    float distLum = length(vec2(dot(color1, vec3(0.299, 0.587, 0.114)), dot(color2, vec3(0.299, 0.587, 0.114))));\n    vec3 baseColor = mix(color1, color2, ratio);\n    float baseLuma = dot(baseColor, vec3(0.299, 0.587, 0.114));\n    return baseColor * (mix(1., 1. + (1. - baseLuma) * distLum, 1. - pow(2. * abs(ratio - 0.5), 2.)));\n}\n\nvec3 customMixColor5 (const in vec3 color1, const in vec3 color2, const in float ratio) {\n    float distLuma = length(vec2(\n        color1.r * 0.299 + color1.g * 0.587 + color1.b * 0.114,\n        color2.r * 0.299 + color2.g * 0.587 + color2.b * 0.114\n    ));\n    \n    vec3 baseColor = mix(color1, color2, ratio);\n    float baseLuma = baseColor.r * 0.299 + baseColor.g * 0.587 + baseColor.b * 0.114;\n    \n    return baseColor * (mix(1., 1. + (1. - baseLuma) * distLuma, 1. - pow(2. * abs(ratio - 0.5), 1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color1;\n    vec3 color2;\n    \n    /*\n    if (iMouse.w < 0.) {\n    \tcolor1 = texture(iChannel0, uv).rgb;\n    \tcolor2 = texture(iChannel1, uv).rgb;\n    } else {*/\n    \tfloat iTime = iMouse.x / iResolution.x * 50.;\n    \tcolor1 = vec3((sin(iTime) + 1.) / 2., (sin(iTime/9.) + 1.) / 4., 0.0);\n    \tcolor2 = vec3(0.0, 0.0, (sin(iTime/3.3) + 1.) / 2.);\n    //}\n    \n    color1 = vec3(0.);\n    color2 = vec3(0.9, 1., 1.);\n    \n    vec3 color;\n    \n    if (uv.y > 0.902) {\n        // 1st (top) = simple mix()\n        color = mix(color1, color2, uv.x);\n    } else if (uv.y > 0.802 && uv.y < 0.9) { // middle\n        // 2nd = manual correct mix\n        color = correctMixColor(color1, color2, uv.x);\n    } else if (uv.y > 0.702 && uv.y < 0.8) {\n        // 3rd = manual correct + smoothstepped mix\n        color = correctSmoothMixColor(color1, color2, uv.x);\n    } else if (uv.y > 0.602 && uv.y < 0.7) {\n        // 4th = correct mix with weighted channels\n        color = customMixColor(color1, color2, uv.x);\n    } else if (uv.y > 0.502 && uv.y < 0.6) {\n        // 5th = mix the normalized colors and (a rough approx of) the luminosity independtly\n        // can glitch while animated but gives interesting result when blending from a bright color to a dark color\n        color = customMixColor2(color1, color2, uv.x);\n    } else if (uv.y > 0.402 && uv.y < 0.5) {\n        color = customMixColor3(color1, color2, uv.x);\n    } else if (uv.y > 0.302 && uv.y < 0.4) {\n        color = customMixColor4(color1, color2, uv.x);\n    }  else if (uv.y > 0.202 && uv.y < 0.3) {\n        color = customMixColor4(color1, color2, uv.x);\n    }else {\n        fragColor = vec4(0.);\n    }\n    \n    fragColor = vec4(color, 1.);\n        \t\n}","name":"Image","description":"","type":"image"}]}