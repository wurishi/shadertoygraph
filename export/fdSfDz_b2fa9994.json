{"ver":"0.1","info":{"id":"fdSfDz","date":"1645965138","viewed":234,"name":"Raymarching_cloud","username":"Passo2018","description":"Raymarching_cloud","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//reference:https://shaderbits.com/blog/creating-volumetric-ray-marcher\n//https://www.shadertoy.com/view/3sXSRX\n//https://www.shadertoy.com/view/3s3yD8\n\n#define PI 3.1415926\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nvec2 fixUV(in vec2 fragCoord){\n    return (2.*fragCoord - iResolution.xy)/min(iResolution.x,iResolution.y);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    p = p * (4. + cos(iTime/10.)/40.);\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n    f += 0.2500 * noise(p); p = 2.0 * p;\n    f += 0.1250 * noise(p); p = 2.0 * p;\n    f += 0.0625 * noise(p); p = 2.0 * p;\n\n    return f;\n}\n\nfloat sdcloud(vec3 p){\n    float sphere_size = 1.5;\n    float noise_size = 0.5;\n    float noise_freq = 0.8;\n    float sphere_space_scale = 0.3;\n   //torus heart\n    vec3 o = vec3(0.,0.,0.);\n    p -= o;\n    float r1 = 1.8;\n    float r2 = 0.8;\n\n    float sph = -length( vec2(length(vec2(p.x,p.z))-r1,p.y) ) + r2 + fbm(p*noise_freq-vec3(0.,.5,1.)*iTime*0.05)*noise_size;\n    return sph*sphere_space_scale;\n}\n\n  const int sample_steps = 64; //cloud sampling\n  const int light_steps = 24; //light sampling\n  const float opacity = 0.2;\n\n//camera setting by iq\nmat3 setCamera(vec3 ta, vec3 ro, float cr){\n\n    vec3 z = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr),cos(cr),0.);\n    vec3 x = normalize(cross(z, cp));\n    vec3 y = cross(x,z);\n    return mat3(x, y, z);\n}\n//in the raymarching cloud render \n//sampledensity simple version\n\nvec3 render (vec2 uv){\n    //camera\n  \n    vec3 ro = vec3(4.,5., 4.);\n    float thetab = 1.;\n    float theta = iMouse.x / iResolution.x * 2. * PI;\n    thetab  = iMouse.y / iResolution.y * 2. * PI;\n    ro = vec3(3.*cos(0.2*iTime), 5.*sin(thetab-PI/2.),3.*sin(0.2*iTime));\n    \n   \n    vec3 ta = vec3(0.);\n    mat3 cam = setCamera(ta, ro, 0.);\n    vec3 rd = normalize(cam * vec3(uv, 1.));\n\n\n      // sun attributes\n    vec3 sun_dir = normalize(vec3(0.4, 0.8, 0.4*sin(iTime)));\n    vec3 sun_col = vec3(0.9882, 0.9216, 0.8784);\n    vec3 SkyColor = vec3(1.0, 1.0, 1.0);\n\n    //iq sky reference:https://www.shadertoy.com/view/XslGRr\n    float sun = clamp( dot(sun_dir,rd), 0.0, 1.0 );\n    vec3 backgroudcolor = vec3(0.6196, 0.6039, 0.7412);\n    backgroudcolor -= 0.6*vec3(0.90,0.75,0.95)*abs(rd.y);\n    backgroudcolor += 0.2*vec3(1.00,0.60,0.10)*pow( sun, 8.0 );\n\n     // cloud attributes\n    float Transmittance = 1.0;\n    float light_Transmittance = 1.0;\n    vec3 sample_pos = ro; \n    float lcurdensity = 0.;\n    float sample_dist = 0.1;\n    float light_sample_dist = 0.04;\n    float shadow_density = 1.1;\n    float Density = 0.4;\n    float ShadowThreshold = 0.001;\n\n\n    float LightAbsorption = 100.;\n    vec3 col = vec3(0.);\n\n    //cloud raymarching\n    sun_dir *= light_sample_dist;\n    shadow_density *= light_sample_dist;\n    Density *= sample_dist;\n\n\n    for (int iter = 0; iter < sample_steps; iter++)\n    {\n    \tfloat depth = sdcloud(sample_pos); //sampling\n        float cursample = sdcloud(sample_pos);\n        \n        if (cursample > 0.001){\n        if (depth > 0.001 )//into cloud box\n        {\n            float shadowdist = 0.;\n            vec3 lpos = sample_pos;\n            Transmittance *= 1.-cursample / float(sample_steps) * LightAbsorption ;\n            if (Transmittance<=0.01) break;\n\n         //light marching sampling\n            for(int s = 0; s<light_steps; s++){\n                \n                lpos += sun_dir*shadowdist;\n                float lsample = sdcloud(lpos);\n                shadowdist += lsample;\n                if (sdcloud(lpos)<0.) break;\n                    lcurdensity = lsample*Density;\n                    // float shadowterm = exp(-shadowdist * shadow_density);\n                    // vec3 absorbedlight = vec3(shadowterm * lcurdensity);\n                    //lightEnergy += absorbedlight * light_Transmittance *Transmittance ;\n                    // lightEnergy +=  exp(shadowdist * AmbientDensity) * curdensity * SkyColor * 0.6 ;\n\n                    light_Transmittance *= 1. - lcurdensity * LightAbsorption / float(light_steps);\n                if (light_Transmittance<=0.01) break;\n            }\n        float tmp = cursample / float(sample_steps);\n        //ambient + light\n        col += SkyColor*20.* tmp * Transmittance  + sun_col * tmp * Transmittance *light_Transmittance *80.;\n       \n        //total_density += cursample * depth * Density;\n        //Transmittance = exp(-total_density*sample_lenth);\n         }\n         }\n        sample_pos += rd * sample_dist; \n    }\n     \n    // vec3 cloudCol = backgroudcolor * Transmittance * total_density;\n    // vec3 LightCol = sun_col * lightEnergy;\n    //col += cloudCol + LightCol*1.2 ;\n    col += backgroudcolor;\n    return col;\n   }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fixUV(fragCoord);\n    vec3 col = render(uv);\n\n    col = pow(col,vec3(2.0/3.2));\n    col = smoothstep(vec3(0.0, 0.0, 0.0),vec3(1.0, 1.0, 1.0),col);\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}