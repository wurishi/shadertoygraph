{"ver":"0.1","info":{"id":"7lBXWV","date":"1628633207","viewed":77,"name":"Strange Mandelbrot","username":"incription","description":"A prototype of the true fractional iteration of the mandelbrot f^s(x) = x^2 + c can be found in common, but it does not work yet. (Need more terms of abels function, so _iter is not stable). ","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["mandelbrot","shadertoy","buffer","pass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Smooth Mandelbrot Attempt\" by incription. https://shadertoy.com/view/slsSWX\n// 2021-08-10 19:21:11\n\nvec2 sm(vec2 a, vec2 b, float t) {\n    return vec2(smoothstep(a.x, b.x, t), smoothstep(a.y,b.y,t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 dat = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 c = getc(uv);\n    vec2 z = dat.xy;\n    float i = dat.z * _iter;\n    z = mix(z, iter(z, c, _iter), float(iFrame%dt)/float(dt));\n    \n    vec3 col = vec3(z, 0);\n    \n    fragColor.rgb = col;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 c = getc(uv);\n    \n    vec4 dat = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    \n    //dat.xy = cpow(dat.xy, vec2(2,0)) + vec2(2, 0);\n    if( iFrame % dt == 0) {\n            dat.xy = iter(dat.xy, c, _iter);\n            //dat.z += 1. / _iter;\n    }\n    \n    if( iFrame == 0 || iMouse.z > 0.) {\n        dat.xy = c;\n        dat.z = 0.;\n    }\n    \n    fragColor = dat;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//computes f^(1/_iter)(x) = x^2 + c\n#define _iter 2.\n//frames between updates (mixes between steps)\n#define dt 1\n\n#define _cbsize 50.\n#define _n 5.\n\n#define e vec2(2.17181, 0.)\n#define one vec2(1., 0.)\n#define two vec2(2., 0.)\n\nfloat gamma01(in float x) {\n    return 2.80508 * x + 8.14950446 - sqrt(47.9819532714 * x + 51.1136058464);\n}\n\nfloat gamma(in float x) {\n    float h = floor(x), f = x - h, y = gamma01(f);\n    if (x < 0.0) for (float n=0.0; n < -h; n++) y /= f - n;\n    else for (float n=1.0; n < h + 1.0; n++) y *= f + n;\n    return y;\n}\n\nfloat factorial(in float x) {\n    return gamma01(x + 1.);\n}\n\nfloat choose(in float n, in float k) {\n    return factorial(n)/(factorial(k) * factorial(n - k));\n}\n\nvec2 cdiv(in vec2 a, in vec2 b) {\n    float dis = b.x * b.x + b.y * b.y;\n    return vec2((a.x * b.x + a.y * b.y) / dis, (a.y * b.x - a.x * b.y) / dis); \n}\n\n\nvec2 cmul(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\n// complex exponent e^a\nvec2 cexp(in vec2 a) {\n    float ea = exp(a.x);\n    float vl = a.y;\n    return ea * vec2( cos(vl), sin(vl) );\n}\n\n// complex natural logarithm ln(a)\nvec2 cln(in vec2 a) {\n    float ql = length(a);\n    return vec2( log(ql), atan(a.y, a.x));\n}\n\n// complex power function a^b\nvec2 cpow(in vec2 a, in vec2 b) {\n    return cexp(cmul(cln(a), b));   \n}\n\nvec2 ccosh(in vec2 a) {\n    return cdiv(cexp(a) - cexp(-a) , vec2(2, 0));\n}\n\nvec2 cacosh(in vec2 a) {\n    return cln(a + cpow(cpow(a, vec2(2, 0) - vec2(1., 0)), vec2(.5, 0.)));\n}\n\n/*\nThe function computes f^1/_s(x)=x^2+c\nThe formula is shown in the paper https://people.math.osu.edu/edgar.2/preprints/trans_frac/fractional.pdf\nCurrently needs more terms (O( ... )) to be more accurate\n*/\nvec2 mandeln2(vec2 x, vec2 c, float _s) {\n    vec2 s  = vec2(_s, 0.);\n    \n    vec2 _x = x;\n    vec2 u0 = cdiv(one, cln(x));\n    vec2 u1 = cpow(_x, -one);\n    vec2 u2 = cexp(-_x);\n    vec2 u3 = cexp(cexp(cpow(-e, _x)));\n    vec2 u4 = cpow(_x, cpow(-two, s));\n    vec2 u5 = cexp(cpow(-two, cmul(s, _x)));\n    vec2 u6 = cexp(cpow(-two, cmul(s, cexp(_x))));\n    _x = cmul(x, x) + c;\n    \n    vec2 conj = one + cmul(cmul(cpow(two, -one + s), c), cmul(u1, u1)) - \n                cmul(cdiv(c, two), cmul(u4, u4)) + \n                cmul( cmul(cpow(two, -two + s), c - cmul(c, c)) + cmul(cpow(two, -vec2(3,0) + cmul(two, s)), cmul(c,c)),\n                    cmul(u1, cmul(cmul(u1, u1), u1)) ) +\n                cmul(cmul(cmul(cpow(two, -two + s), cmul(c, c)), cmul(u1, u1)), cmul(u4, u4));\n    return cmul(conj, cpow(x, cpow(two, s)));\n    \n}\n\nvec2 julia_f(vec2 z, float m) {\n    return 2. * ccosh(cpow(vec2(2., 0.), vec2(m, 0)) * cacosh(cdiv(z, vec2(2, 0))));\n}\n\nvec2 getc(vec2 uv) {\n        return vec2(3, 2) * uv - vec2(2, 1);\n}\nvec2 iter(vec2 z, vec2 c, float s) {\n    //if(z.x *z.x + z.y * z.y > 16.) return z;\n    return mandeln2(z, c, s);\n}","name":"Common","description":"","type":"common"}]}