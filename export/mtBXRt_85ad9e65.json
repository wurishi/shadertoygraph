{"ver":"0.1","info":{"id":"mtBXRt","date":"1676439129","viewed":194,"name":"polar day","username":"hayabuzo","description":"This shader is about an endless day without sleep. Inspired by @DubElementMusic. All snowflakes are generative.","likes":8,"published":1,"flags":64,"usePreview":1,"tags":["generative","snowflake","blizzard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtjSWc","filepath":"https://soundcloud.com/maximwolzynofficial/time-to?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/maximwolzynofficial/time-to?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 30\n#define MAX_DIST 30.0\n#define SURF_DIST 0.001\n\n#define PI 3.14159265359             \n#define TWO_PI 6.28318530718\n\n#define msin(x) sin(mod(x,TWO_PI))\n#define mcos(x) cos(mod(x,TWO_PI))\n\n#define sm(a,b,c) smoothstep(a,b,c)\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define FRC float(iFrame)/60.0\n#define RES iResolution\n#define M iMouse\n#define TX1 iChannel0\n#define texture2D texture\n\n\n// ----------------------------------------------------------------------------------------\n\nfloat GetDist(vec3 p) {\n\n\tfloat time = FRC*0.4;\n\n\t\t\t\tp.y += sin(time*20.0)*0.03;\n\n\tvec3  pSphere = p;\n\t\t\t\tpSphere.z += 20.0+sin(time*1.3)*3.0;\n\t\t\t\tpSphere.y -= 10.0+sin(time*2.0)*0.5;\n\t\t\t\tpSphere.x += 05.0+sin(time*0.6)*0.8;\n\tfloat a = time*5.0;\n\t\t\t\tpSphere.yz *= rot(a*0.87);\n\t\t\t\tpSphere.xy *= rot(a*0.87);\n\t\t\t\tpSphere.xz *= rot(a);\n\n\tfloat r = 8.0;\n\tfloat dSphere = length(pSphere) - r; \n\tvec2  uvSphere = vec2( atan(pSphere.x,pSphere.z)/TWO_PI, p.y/r/4.0 );\n\t\t\t\tdSphere += 3.0 * smoothstep(0.5,0.4,pSphere.x);\n\n\tvec3  pPlane = p;\n\t\t\t\tpPlane.z -= time*5.0;\n\tfloat height = 1.0;\n\t\t\t\theight *= texture2D(TX1, fract(pPlane.xz*0.1)).r;\n\t\t\t\theight *= 0.6;\n\t\t\t\theight -= (sin(pPlane.z*0.1)*sin(pPlane.x*0.28)*0.5+0.5)*2.0;\n\tfloat dPlane = (pPlane.y)-height;\n\n\tfloat dTotal = (MAX_DIST);\n\t\t\t\tdTotal = min(dTotal, dPlane);\t\n\t\t\t\tdTotal = min(dTotal, dSphere);\t\n\n\treturn dTotal;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat distOrigin = 0.0; \t            // расстояние от источника лучей, камеры\n\tfor (int i=0; i<MAX_STEPS; i++) {\n\t\t\tvec3  p = (ro + rd*distOrigin);   // текущая точка расчета\n\t\t\tfloat distSurface = GetDist(p);\t\t// расстояние до ближайшей поверхности\n      \t\t\tdistOrigin += distSurface;\n\t\t\tif ( distOrigin > MAX_DIST || abs(distSurface) < SURF_DIST ) break;\n\t}\n\treturn distOrigin;\n}\n\nvec3  GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n  vec2 e = vec2( 0.001, 0.0 ); \n\tvec3 n = d - vec3( \n\t\tGetDist(p-e.xyy),   \n\t\tGetDist(p-e.yxy),\n\t\tGetDist(p-e.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat GetDiffuseLight(vec3 p) {\n\n\tvec3  lightPosition = vec3( -20.0, 20.0, 20.0 );  \n\tvec3  l = normalize(lightPosition - p);       \n\tvec3  n = GetNormal(p);                       \n\tfloat dif = dot(n,l);                         \n        dif = dif*0.5+0.5;                      \n\t\t\t\tdif = clamp(dif, -1.0, 1.0);             \n\tfloat amount = sin(FRC*2.8)*0.5+0.5;\n\treturn dif*(amount*0.05+0.95);\n\n}\n\n\nfloat f2h1(float f) { \n  float a = 291.7567292;\n  float b = 94.32862056;   \n\treturn fract( sin(mod(f*a,6.283))*b ); }\n\nvec2  uv2h2(vec2 uv) {\n  float a = 291.7567292;\n  float b = 94.32862056;   \n\tfloat c = 143.6456534;\n\tfloat r = 0.314;\n\t\t\t\tuv *= mat2(cos(r), sin(r), -sin(r), cos(r));\n\tfloat x = sin(mod(uv.x*a,6.283))*b;\n\t\t\t\tr = (uv.y-uv.x)*c*uv.y;\n\t\t\t\tuv *= mat2(cos(r), sin(r), -sin(r), cos(r));\n\tfloat y = sin(mod(uv.x*a,6.283))*b;\n\t\t\t\tr = (uv.x-uv.y)*c*uv.x;\n\t\t\t\tuv *= mat2(cos(r), sin(r), -sin(r), cos(r));\n\tfloat z = sin(mod(uv.x*a,6.283))*b;\n\t\t\t\treturn vec2(fract(x+y),fract(y+z)); }\n\nfloat drawLine(vec2 uv, vec2 a, vec2 b, float r) {\n\tfloat l = length(b-a);\n\tvec2  s = b-a;\n\t\t\t\tuv -= a;\n\t\t\t\tuv *= mat2(s.x/l, s.y/l, -s.y/l, s.x/l);\n\tfloat d = length(uv - vec2(clamp(uv.x,0.0,l),0.0) );\n\treturn smoothstep(r,0.0,d);\n}\n\n/* from The Art Of Code KIFS */\nvec2 uv2mirror(vec2 uv, vec2 point, float angle) {\n\t\t\t\tuv -= point;\n\tif (uv.x<0.0) return uv + point;\n\tvec2  normal = vec2(sin(angle),cos(angle));\n\tfloat normalDist = dot(uv,normal); \t\t\t\t\t\t\n\t\t\t\tnormalDist = min(0.0,normalDist);\t\t\t\t\n\t\t\t\tuv -= normal * normalDist * 2.0; \t\t\t\t\n\treturn uv + point; }\n\nfloat drawFlake(vec2 uv, float size, vec2 turn, vec2 seed, float bold) {\n\n\tmat2  m = mat2(1.0/cos(turn.x*PI),0.0,0.0,1.0);\n\t\t\t\tuv *= rot(turn.y);\n\t\t\t\tuv *= m;\n\n        seed = fract(seed);\n\n\tfloat angle = PI/6.0;\n\n  float k1 = 0.4, k2 = 0.4, k3 = 0.6, k4 = 0.8;\n  // float k1 = 0.7, k2 = 0.7, k3 = 0.9, k4 = 0.9;\n\n\t\t\t\tuv.x = abs(uv.x);\n\t\t\t\tuv.y = -abs(uv.y);\n\t\t\t\tuv = uv2mirror(uv,vec2(0.0,0.0),angle);\n\t\t\t\tuv.x = abs(uv.x-size*0.5)+size*0.5;\n\n\t\t\t\tuv.y = -abs(uv.y);\n\t\t\t\tuv = uv2mirror(uv,vec2(k1*size*seed.y,0.0),angle);\n\t\t\t\tuv.y = -abs(uv.y);\n\t\t\t\tuv = uv2mirror(uv,vec2(k2*size,0.0),angle);\n\n\t\t\t\tuv.y = -abs(uv.y);\n\t\t\t\tuv = uv2mirror(uv,vec2(k3*size*seed.x,0.0),angle);\n\t\t\t\tuv.y = -abs(uv.y);\n\t\t\t\tuv = uv2mirror(uv,vec2(k4*size,0.0),angle);\n\n  float flake = drawLine(uv, vec2(0.0), vec2(size, 0.0), 0.1*size*bold);\n        flake += drawLine(uv, vec2(0.0,-size*seed.x*0.25), vec2(size, 0.0), 0.1*size*bold);\n\n\t\t\t\tflake *= 0.6+0.4 * abs(cos(turn.x*PI));\n\n\treturn flake;\n\t\n}\n\n\n\nfloat drawGrid(vec2 uv, float layer, vec2 scale, vec2 size, vec2 speed, float flow, float dir, float vis) {\n\n\tfloat col = 0.0;\n\n\tstruct structGrid {\n\t\tvec2  scale, uv, id, aspect; \n\t\tvec2  size, pos, lim, speed;\n\t\tfloat shift, border, center, object, flow, dir, vis;\n\t} grid;\n\n\t// базовый масштаб и координаты\n\tgrid.scale = scale;\n\tgrid.uv = fract(uv/grid.scale);\n\tgrid.id = floor(uv/grid.scale);\n\tgrid.aspect = vec2(max(grid.scale.xy/grid.scale.yx,vec2(1.0)));\n\tgrid.flow = flow;\n\tgrid.dir  = dir;\n\tgrid.vis  = vis;\n\n\t// сдвиг по одной из осей\n\tfloat hash_shift = f2h1(fract(0.5+grid.id.x*164.36));\n\tgrid.shift = (grid.flow)*(hash_shift-0.5-grid.dir);\n\tgrid.uv.y += grid.shift;\n\tgrid.uv = fract(grid.uv);\n\tgrid.id.y = floor((uv.y/grid.scale.y+grid.shift));\n\n\tfloat hash_vis = f2h1(fract(grid.id.y*534.36*(1.0+layer)));\n\tif( hash_vis > grid.vis ) return col;\n\n\t// расположение объекта в стандатризированных координатах -1...1\n\tgrid.speed = speed;\n\tgrid.speed /= grid.aspect;\n\tvec2 hash_pos = 0.01+uv2h2(fract(grid.id*572.4));\n\tgrid.pos = msin(grid.speed*grid.flow*hash_pos);\n\n\t// позиционирование объекта в ячейке\n\tgrid.size = size;\n\tgrid.size *= 0.5+0.5*(sin( mod(grid.flow*hash_pos.y,3.14) )*0.5+0.5);\t\t// size change\n\tgrid.size /= grid.aspect;\n\tgrid.pos *= (vec2(1.0)-grid.size)*0.5;\n\n\t// центровка координат ячейки\n\tgrid.uv -= 0.5;\n\n\tcol += (drawFlake((grid.uv-grid.pos)/(grid.size), 0.5, grid.pos*10.0, hash_pos, 0.3));\n\n\treturn col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2  uv = fragCoord/iResolution.xy;\n  vec2  uvShift = vec2(0.5); uv -= uvShift;\n  vec2  uvRes = vec2(max(RES.xy/RES.yx,vec2(1.0))); uv *= uvRes;\n\n  vec2  m = vec2(0.5);//M;\n        m -= (M.xy/RES.xy-0.5)*0.1;\n  vec3  ro = vec3(0, -1, -5);\n        ro.yz *= rot(-m.y*3.14+1.0);\n        ro.xz *= rot(-m.x*6.2831);\n  vec3  lp = vec3( 0.0, 2.5+sin(FRC*8.0)*0.03, 0.0 );\n  vec3  cf = normalize(lp - ro);\n  vec3  cr = normalize( cross( vec3( 0.0, 1.0, 0.0), cf ));\n  vec3  cu = cross(cf,cr);\n  float z = 1.0;\n  vec3  c = ro + cf * z;\n  vec3  i = c + uv.x*cr + uv.y*cu;\n  vec3  rd = normalize(i - ro);\n\n  vec3  fogCol =vec3(0.7,0.8,0.9)*0.5;\n  vec3  col = fogCol;\n  float d = RayMarch(ro, rd);\n\n  float pz = 0.0;\n    \n  if(d<MAX_DIST) {\n    vec3  p = ro + rd * d;\n    float dif = GetDiffuseLight(p);\n    \t    col = vec3(dif);\n          pz = p.z;\n          pz = smoothstep(-5.0,-10.0,pz);\n          pz *= step(1.0,p.y);\n\n    float distFog = smoothstep(-20.0,15.0,p.z);\n    col = mix(fogCol, col, distFog);\n  }\n    \n  col = pow(col, vec3(.4545));\n  //col *= 0.0;\n\n\t// ----------------------------\n\n\tfloat time = FRC*0.25;\n\tfloat shift = 0.2*(0.5+0.5*sin(time*2.0));\n\tvec3  wind = (-time+shift) * 0.2 * vec3 (7.0,6.0,-30.0);\n\n\tfloat grid;\n  float depth; \n  float flakes = 0.0;\n\tfor (float i=0.0; i<1.0; i+=1.0/5.0) {\n    depth = 0.0+fract(i-wind.z*0.1)*10.0;\n\t\tvec2  uvGrid = uv;\n\t\t\t\t\tuvGrid += (M.xy/RES.xy-0.5)*0.5*vec2(1.0,0.5)+vec2(0.0,sin(FRC*8.0)*0.005);\n\t\t\t\t\tuvGrid *= 0.0 + depth;\n\t\t\t\t\tuvGrid += i * 172.5;\n\t\t\t\t\tuvGrid -= wind.xy;\n\t\tgrid = drawGrid(\n\t\t\t/*  uv         */  uvGrid,\n\t\t\t/*  layer      */  i,\n\t\t\t/*  scale      */  vec2(0.2),\t\n\t\t\t/*  size       */  vec2(0.3),  \n      /*  speed      */  vec2(0.5),  \n      /*  flow       */  time*10.0+100.0,  \n      /*  direction  */  0.0,\n      /*  visibility */  0.2\n\t\t\t);\n    flakes += 0.1*grid*sm(1.0,0.95,depth*0.1);//*(1.0+9.0*grid*sm(0.1,0.0,depth*0.1));\n\t}\n\n\tpz = 0.4+0.6*clamp((1.0-pz),0.0,1.0);\n\tcol += vec3(flakes*pz);\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}