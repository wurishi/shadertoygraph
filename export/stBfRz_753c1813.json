{"ver":"0.1","info":{"id":"stBfRz","date":"1651884143","viewed":315,"name":"PILLAR_GRID","username":"Yetman","description":">>> RENDER â–  | REPEAT <X, Y> | ROTATION=FUNC(X, Y, TIME) | REPEAT <Z> | PARALLAX","likes":14,"published":3,"flags":32,"usePreview":0,"tags":["parallax","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPLIT_SIZE 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = vec4(\n        texelFetch(iChannel0, coord - ivec2(SPLIT_SIZE), 0).r,\n        texelFetch(iChannel0, coord                    , 0).g,\n        texelFetch(iChannel0, coord + ivec2(SPLIT_SIZE), 0).b,\n        1.0\n    );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TILE_SIZE 50.0\n#define ALPHA 0.05\n#define MAX_SCALE 1.75\n#define STEP_COUNT 75\n#define DRIFT_VELOCITY vec2(50.0)\n#define GROOVE_NORMAL vec2(1.0, 1.0)\n#define GROOVE_DEPTH 20.0\n#define GROOVE_WAVELENGTH 7.0\n#define ROT_WAVE_DIR vec2(1.0, 1.0)\n#define ROT_WAVELENGTH 180.0\n#define ROT_WAVE_SPEED 22.5\n#define ROT_PER_WAVE 90.0\n#define ROT_FRACTION 0.2\n\nfloat smooth_staircase(float x, float height, float smoothness){\n    return height * smoothstep(0.0, smoothness, fract(x / height));\n}\n\nfloat layer(in vec2 fragCoord, int level){\n    fragCoord -= iTime * DRIFT_VELOCITY;\n    vec2 tile = floor(fragCoord/TILE_SIZE);\n    vec2 tile_coord = fract(fragCoord/TILE_SIZE) * 2.0 - 1.0;\n    \n    if(level > (STEP_COUNT - int(GROOVE_DEPTH * sin(radians(360.0) / GROOVE_WAVELENGTH * dot(tile, GROOVE_NORMAL))))) \n        return 1.0;\n    \n    float deg = dot(tile, ROT_WAVE_DIR) * 360.0 / ROT_WAVELENGTH + ROT_WAVE_SPEED * iTime;\n    deg = smooth_staircase(deg, ROT_PER_WAVE, ROT_FRACTION);\n    float angle = radians(deg);\n    \n    mat2 rotation = mat2(\n        cos(angle), -sin(angle),\n        sin(angle),  cos(angle)\n    );\n    tile_coord = rotation * tile_coord;\n    \n    float max_norm = max(abs(tile_coord.x), abs(tile_coord.y));\n    float square = smoothstep(0.5 - 2.0 * fwidth(max_norm), 0.5, max_norm);\n    \n    return square;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= iResolution.xy  * 0.5;\n    \n    float final = 1.0;\n    \n    float step_size = (MAX_SCALE - 1.0)/float(STEP_COUNT);\n    float scale = MAX_SCALE;\n    \n    for(int level = 1; level < STEP_COUNT; level++){\n        scale -= step_size;\n        vec2 coord = fragCoord * scale;\n        \n        float color = layer(coord, level);\n        \n        final = color * (1.0 - ALPHA) * final + ALPHA * color;\n    }\n    \n    fragColor.rgb = vec3(final);\n    fragColor.a = 1.0;\n}","name":"Buffer A","description":"","type":"buffer"}]}