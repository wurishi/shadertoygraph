{"ver":"0.1","info":{"id":"Wt2GR1","date":"1558490732","viewed":526,"name":"Penrose Tribar (wip)","username":"cmarangu","description":"wip\nwip\n[url]https://twitter.com/i/events/1301776298839175169?s=20[/url]","likes":8,"published":1,"flags":0,"usePreview":1,"tags":["penrose","tribar","curvilinear3dmanifold","cylindricalspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///*\n// Current code for: Penrose Tribar (wip)\n// Date: 2020 6/10\n// Tags: penrose, tribar, curvilinear3dmanifold, cylindricalspace\n// Descriptsion: wip\n\n\n// 2020 9/15 seems like the polar coordinates voxel tracer thingy is almost complete!\n// still a number of bugs to kill, and compiling this thing takes about 3 whole seconds,\n// and crashes Chrome's WebGL implementation when I try to add the final arc. I will be\n// rewriting the code from scratch yet again, hopefully to kill the visual bugs and fix\n// the compilation time a bit. Should add it runs 60fps full screen right now.\n//\n// 2020 9/16 OK so I am starting this project from scratch again for the second(?) time\n// though reuse much of the same code. GL to me.\n//\n// 2021 1/2 fiddled with the code. changed shading and got a nice silver/aqua\n// color theme with the voxels as. mini cylinders instead of cubes. I still need to\n// rewrite this from scratch cleanly again\n\n\n// TODO\n// - stuff\n// - the distance to it is looped\n// -\n// - \n// -\n\n\n// ↓ i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582\n#define TAU 6.28318530718\n\n#define arg mod(float(iFrame)/30./1., 1.)\n\n//#define triL ( (roundL*2.+numrect/gridm) )\n//#define triL 6.\n#define triL ((1.+1./3.)*2.+3.*1.+0./3.)\n#define gridm 3.\n#define roundL (1.+1./3.)\n#define arcm 5.\n\n#define numcubes ((triL-roundL*2.)*gridm*3.+arcm*3.)\n//#define worldlen (numcubes*4.)\n#define worldlen 6.\n#define triofftot (arg*worldlen)\n#define triofff floor(arg*worldlen)\n#define trioffm fract(arg*worldlen)\n//#define trioff arg\n\n#define  cam_psp 0\n#define cam_maus 0\n#define camtrans 0\n#define camkinex 1\n\n\n//\n//#define sund normalize(vec3(1., .2, -.2))\n#define sund normalize(vec3(1., .0, -.0))\nvec3 sky_map (vec3 d) {\n    //return vec3(0.);\n    //return vec3(.0, .0, 100./255.);\n    //return vec3(0., 1., 0.);\n    return texture(iChannel2, d).rgb;\n}\n\n#define inter_sky vec4(vec3(0.), 1e9)\n\nint blocktyp (vec3 pT) {\n    //if (mod(pT.x+1., 4.) < 1.) {\n    //if (pT.y <= 0. && pT.z <= 0.) {\n    if (mod(pT.x+0., 6.) >= 1. && min(abs(pT.z-1.), abs(pT.y-1.) ) < 1.) {\n        return 0;\n    }\n    return 1;\n}\n\n/*#define SDF(p) min(\\\n    (length(max(abs(p-vec3(.5, .75, .5))-vec3(.44, .2, .44), 0.) )-.04),\\\n    (length(max(abs(p-vec3(.5, .25, .5))-vec3(.44, .2, .44), 0.) )-.04)\\\n)//*/\n//#define SDF(p) (length(max(abs(p-vec3(.5, .25, .5))-vec3(.44, .2, .44), 0.) )-.03)\n//\n//#define SDF(p) (length(p-vec3(.5) )-.49)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.4), 0.) )-.02)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.3), 0.) )-.18)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.465), 0.) )-.02)\n// try mini n=(1, 0, 0) cylinder\n#define SDF(p) ( length((p).yz-.5)-.49 )\n//#define SDF(p) ( length((p).xy-.5)-.49 )\n\nvec4 inter_SDF (vec3 p, vec3 d) {\n    //\n    vec3 camp = p;\n    float SDFp;\n    for (int i=0; i<6020; ++i) {\n        SDFp = SDF(p);\n        if (SDFp > 1.8) { // sqrt(3)\n        //if (SDFp > .18) {\n        //if (SDFp > 20.) {\n            break;\n        }\n        else if (abs(SDFp) < 1e-5) {\n            return vec4(\n                normalize(-SDFp+vec3(\n                    SDF(p+vec3(1e-3, 0., 0.)),\n                    SDF(p+vec3(0., 1e-3, 0.)),\n                    SDF(p+vec3(0., 0., 1e-3))\n                )),\n                length(p-camp)\n            );\n            #undef inf\n        }\n        p += d*abs(SDFp)*.99;\n    }\n    return inter_sky;\n}\n\nfloat DE_arcu (vec3 p, vec3 bl, float ggo) {\n    // x tran th\n    // y tran r\n    //vec3 q;\n    //q = vec3(\n    //    mod(atan(p.y, p.x)+TAU, TAU)*arcm/(PI*.5),\n    //    length(p.xy),\n    //    p.z\n    //);\n    //q = fract(q);\n    //return SDF(q);\n    //\n    //p = fract(\n    //    vec3(\n    //        mod(atan(p.y, p.x)+TAU, TAU)*arcm/(PI*.5),\n    //        length(p.xy),\n    //        p.z\n    //    )\n    //);\n    //return SDF(p);\n    p = vec3(\n        mod(atan(p.y, p.x)+TAU, TAU)*arcm/(PI*.5),\n        length(p.xy),\n        p.z\n    );\n    //p = fract(p);\n    //p -= floor(p);\n    p -= bl;\n    p.y = 1.-p.y;\n    #define th ggo\n    p.yz -= .5;\n    p.yz = vec2(cos(th)*p.y+cos(PI*.5+th)*p.z, sin(th)*p.y+sin(PI*.5+th)*p.z);\n    p.yz += .5;\n    #undef th\n    //\n    return SDF(p);\n}\n\nvec4 inter_arcu (vec3 p, vec3 d, vec3 bl, float ggo) {\n    //\n    vec3 camp = p, q;\n    float SDFp;\n    for (int i=0; i<6020; ++i) {\n    //for (int i=0; i<20; ++i) {\n        /*q = vec3(\n            mod(atan(p.y, p.x)+TAU, TAU)*arcm/(PI*.5),\n            length(p.xy),\n            p.z\n        );\n        q -= bl;\n        #define th ggo*PI*.5\n        q.yz -= .5;\n        q.yz = vec2(cos(th)*q.y+cos(PI*.5+th)*q.z, sin(th)*q.y+sin(PI*.5+th)*q.z);\n        q.yz += .5;\n        #undef th*/\n        SDFp = DE_arcu(p, bl, ggo);\n        //SDFp = SDF(q);\n        //inbound = true;\n        //inbound = q.x >= 0. && q.x < 1. &&\n        //          q.y >= 0. && q.y < 1. &&\n        //          q.z >= 0. && q.z < 1. && inbound;\n        //if (SDFp > 4. || !inbound) {\n        if (SDFp > 4.) {\n        //if (!inbound) {\n        //if (SDFp > 20.) {\n            break;\n        }\n        else if (abs(SDFp) < 9e-5) {\n            return vec4(\n                normalize(-SDFp+vec3(\n                    DE_arcu(p+vec3(1e-3, 0., 0.), bl, ggo),\n                    DE_arcu(p+vec3(0., 1e-3, 0.), bl, ggo),\n                    DE_arcu(p+vec3(0., 0., 1e-3), bl, ggo)\n                )),\n                length(p-camp)\n            );\n            #undef inf\n        }\n        p += d*abs(SDFp);\n    }\n    return inter_sky;\n}\n\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n#define inter_plane_short(p, d, c, n) (\\\n    dot(-n, d) > 1e-6 ? vec4(n, dot(c-p, -n)/dot(-n, d)) : inter_sky\\\n)\n#define inter_plane_dist(p, d, c, n) (\\\n    dot(-n, d) > 1e-6 ? dot(c-p, -n)/dot(-n, d) : inter_sky\\\n)\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1;\n    inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, c, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n\nfloat SDF_cylinder (vec3 p, vec3 c, vec3 n, float r) {\n    return length(cross(normalize(p-c), n) )*length(p-c)-r;\n}\nvec4 inter_cylinder (vec3 p, vec3 d, vec3 c, vec3 n, float r) {\n    if (abs(dot(d, n)) > .9999) { return inter_sky; }\n    float sign_camp = sign(SDF_cylinder(p, c, n, r));\n    p -= c;\n    vec3 camp = p; // original (unrotated/marched) ray origin\n    vec3 camd = d; // original (unrotated) ray direction\n    float ph = asin(n.y); //acos(length(n.xz));\n    float th = atan(n.z, n.x);\n    ph = -ph; th = -th;\n    mat2 zenith = mat2(\n        cos(ph), cos(PI*.5+ph),\n        sin(ph), sin(PI*.5+ph)\n    );\n    mat2 azimuth = mat2(\n        cos(th), cos(PI*.5+th),\n        sin(th), sin(PI*.5+th)\n    );\n    p.xz *= azimuth;\n    p.xy *= zenith;\n    d.xz *= azimuth;\n    d.xy *= zenith;\n    \n    // quadratic formula\n    float A = d.y*d.y+d.z*d.z;\n    float B = 2.*p.y*d.y+2.*p.z*d.z;\n    float C = p.y*p.y+p.z*p.z-r*r;\n    if (B*B-4.*A*C < 0.) { return inter_sky; }\n    float w;\n    float w1 = (-B+sqrt(B*B-4.*A*C))/(2.*A);\n    float w2 = (-B-sqrt(B*B-4.*A*C))/(2.*A);\n    if (w1 < 0.) {\n        if (w2 < 0.) {\n            return inter_sky;\n        }\n        w = w2;\n    }\n    else {\n        if (w2 < 0.) {\n            w = w1;\n        }\n        else {\n            //w = min(w1, w2);\n            w = w2;\n        }\n    }\n    p.xy *= inverse(zenith);\n    p.xz *= inverse(azimuth);\n    d.xy *= inverse(zenith);\n    d.xz *= inverse(azimuth);\n    p += d*w;\n    #define inf vec2(5e-4, 0.)\n    return vec4(\n        normalize(\n            -SDF_cylinder(p, c, n, r)+\n            vec3(\n                SDF_cylinder(p+inf.xyy, c, n, r),\n                SDF_cylinder(p+inf.yxy, c, n, r),\n                SDF_cylinder(p+inf.yyx, c, n, r)\n            )\n        )*sign_camp,\n        w\n    );\n    return inter_sky;\n    #undef inf\n    //\n    //#define inf vec2(5e-4, 0.)\n    //vec3 camp = p;\n    //float SDFp;\n    //for (int i=0; i<400; ++i) {\n    //    SDFp = SDF_cylinder(p, c, n, r);\n    //    if (i > 4 && SDFp > 10.) {\n    //        return inter_sky;\n    //    }\n    //    else if (abs(SDFp) < 5e-4) {\n    //        return vec4(\n    //            normalize(\n    //                -SDFp+\n    //                vec3(\n    //                    SDF_cylinder(p+inf.xyy, c, n, r),\n    //                    SDF_cylinder(p+inf.yxy, c, n, r),\n    //                    SDF_cylinder(p+inf.yyx, c, n, r)\n    //                )\n    //            ),\n    //            length(p-camp)\n    //        );\n    //    }\n    //    p += d*abs(SDFp)*1.;\n    //}\n    //#undef inf\n}\n\n#define DE_rectprism(p, whl) max( \\\n    max( \\\n        max(-p.x, p.x-whl.x), \\\n        max(-p.y, p.y-whl.y) \\\n    ), \\\n    max(-p.z, p.z-whl.z) \\\n)\nfloat yew;\nfloat DE_arcprism (vec3 p, vec3 bl, vec3 whl) {\n    p = vec3(\n        mod(atan(p.y, p.x)+TAU-bl.x, TAU),\n        length(p.xy),\n        p.z\n    );\n    p -= vec3(0., bl.y, bl.z);\n    return DE_rectprism(\n        p, whl\n    );\n}\n\nvec4 inter_rectprism (vec3 p, vec3 d, vec3 whl) {\n    #define bl vec3(0.)\n    //\n    vec4 inter_closest = inter_sky, inter_current; vec3 q; bool hits;\n    q = p;\n    inter_current = inter_plane(p, d, bl, vec3(1., 0., 0.));\n    q += d*inter_current.w;\n    hits  = true;\n    hits = q.y >= bl.y && q.y < bl.y+whl.y && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    if (inter_current.w < inter_closest.w && hits) { inter_closest = inter_current; }\n    //\n    q = p;\n    inter_current = inter_plane(p, d, bl, vec3(0., 1., 0.));\n    q += d*inter_current.w;\n    hits  = true;\n    hits = q.x >= bl.x && q.x < bl.x+whl.x && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    if (inter_current.w < inter_closest.w && hits) { inter_closest = inter_current; }\n    //\n    q = p;\n    inter_current = inter_plane(p, d, bl, vec3(0., 0., 1.));\n    q += d*inter_current.w;\n    hits  = true;\n    hits = q.x >= bl.x && q.x < bl.x+whl.x && hits;\n    hits = q.y >= bl.y && q.y < bl.y+whl.y && hits;\n    if (inter_current.w < inter_closest.w && hits) { inter_closest = inter_current; }\n    //\n    //\n    //\n    q = p;\n    inter_current = inter_plane(p, d, bl+whl, vec3(1., 0., 0.));\n    q += d*inter_current.w;\n    hits  = true;\n    hits = q.y >= bl.y && q.y < bl.y+whl.y && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    if (inter_current.w < inter_closest.w && hits) { inter_closest = inter_current; }\n    //\n    q = p;\n    inter_current = inter_plane(p, d, bl+whl, vec3(0., 1., 0.));\n    q += d*inter_current.w;\n    hits  = true;\n    hits = q.x >= bl.x && q.x < bl.x+whl.x && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    if (inter_current.w < inter_closest.w && hits) { inter_closest = inter_current; }\n    //\n    q = p;\n    inter_current = inter_plane(p, d, bl+whl, vec3(0., 0., 1.));\n    q += d*inter_current.w;\n    hits  = true;\n    hits = q.x >= bl.x && q.x < bl.x+whl.x && hits;\n    hits = q.y >= bl.y && q.y < bl.y+whl.y && hits;\n    if (inter_current.w < inter_closest.w && hits) { inter_closest = inter_current; }\n    //\n    //\n    //\n    //return inter_closest;\n    //inter_current = inter_SDF(p, d);\n    //if (inter_current.w < inter_closest.w) {inter_closest = inter_current; }\n    return inter_closest;\n    #undef bl\n}\n\nvec4 inter_arcprism (vec3 p, vec3 d, vec3 bl, vec3 whl) {\n    vec4 inter_closest = inter_sky, inter_current; vec3 q; bool hits;\n    vec3 camp = p;\n    //\n    // front and back circle-ish faces\n    //\n    p = camp;\n    inter_current = inter_plane(p, d, bl, normalize(vec3(0., 0., -1.)) );\n    p += d*inter_current.w;\n    q = vec3(\n        mod(atan(p.y, p.x)+TAU, TAU),\n        length(p.xy),\n        p.z\n    );\n    hits = true;\n    //hits = q.x >= bl.x && q.x < bl.x+whl.x && hits;\n    hits = mod(q.x-bl.x+TAU, TAU) < whl.x && hits;\n    //hits = mod(q.x-bl.x+PI+TAU, TAU) >= PI && mod(q.x-bl.x-whl.x+PI+TAU, TAU) < PI && hits;\n    hits = q.y >= bl.y && q.y < bl.y+whl.y && hits;\n    //\n    if (inter_current.w < inter_closest.w && hits) {\n        inter_closest = inter_current;\n    }\n    //\n    p = camp;\n    inter_current = inter_plane(p, d, bl+whl, normalize(vec3(0., 0., -1.)) );\n    p += d*inter_current.w;\n    q = vec3(\n        mod(atan(p.y, p.x)+TAU, TAU),\n        length(p.xy),\n        p.z\n    );\n    hits = true;\n    //hits = q.x >= bl.x && q.x < bl.x+whl.x && hits;\n    hits = mod(q.x-bl.x+TAU, TAU) < whl.x && hits;\n    //hits = mod(q.x-bl.x+PI+TAU, TAU) >= PI && mod(q.x-bl.x-whl.x+PI+TAU, TAU) < PI && hits;\n    hits = q.y >= bl.y && q.y < bl.y+whl.y && hits;\n    if (inter_current.w < inter_closest.w && hits) {\n        inter_closest = inter_current;\n    }\n    //\n    // cylinder tricky part\n    //\n    p = camp;\n    inter_current = inter_cylinder(p, d, vec3(0.), normalize(vec3(0., 0., 1.)), bl.y);\n    p += d*inter_current.w;\n    q = vec3( mod(atan(p.y, p.x)+TAU, TAU), length(p.xy), p.z);\n    hits = true;\n    hits = mod(q.x-bl.x+PI+TAU, TAU) >= PI && mod(q.x-bl.x-whl.x+PI+TAU, TAU) < PI && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    if (inter_current.w < inter_closest.w && hits) {\n        inter_closest = inter_current;\n    }\n    //\n    p += d*1e-3;\n    inter_current = inter_cylinder(p, d, vec3(0.), normalize(vec3(0., 0., 1.)), bl.y);\n    //float lenb4 = inter_current.w;\n    p += d*inter_current.w;\n    q = vec3( mod(atan(p.y, p.x)+TAU, TAU), length(p.xy), p.z);\n    hits = true;\n    //hits = mod(q.x-bl.x+PI+TAU, TAU) >= PI && mod(q.x-bl.x-whl.x+PI+TAU, TAU) < PI && hits;\n    hits = mod(q.x-bl.x+TAU, TAU) < whl.x && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    //inter_current.w += length(p-camp);\n    //inter_current.w += lenb4;\n    inter_current.w = length(p-camp);\n    if (inter_current.w < inter_closest.w && hits) {\n        inter_closest = inter_current;\n    }\n    //\n    //\n    // cylinder tricky part\n    //\n    p = camp;\n    inter_current = inter_cylinder(p, d, vec3(0.), normalize(vec3(0., 0., 1.)), bl.y+whl.y);\n    p += d*inter_current.w;\n    q = vec3( mod(atan(p.y, p.x)+TAU, TAU), length(p.xy), p.z);\n    hits = true;\n    //hits = mod(q.x-bl.x+PI+TAU, TAU) >= PI && mod(q.x-bl.x-whl.x+PI+TAU, TAU) < PI && hits;\n    hits = mod(q.x-bl.x+TAU, TAU) < whl.x && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    if (inter_current.w < inter_closest.w && hits) {\n        inter_closest = inter_current;\n    }\n    //\n    p += d*1e-3;\n    inter_current = inter_cylinder(p, d, vec3(0.), normalize(vec3(0., 0., 1.)), bl.y+whl.y);\n    //float lenb4 = inter_current.w;\n    p += d*inter_current.w;\n    q = vec3( mod(atan(p.y, p.x)+TAU, TAU), length(p.xy), p.z);\n    hits = true;\n    //hits = mod(q.x-bl.x+PI+TAU, TAU) >= PI && mod(q.x-bl.x-whl.x+PI+TAU, TAU) < PI && hits;\n    hits = mod(q.x-bl.x+TAU, TAU) < whl.x && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    //inter_current.w += length(p-camp);\n    //inter_current.w += lenb4;\n    inter_current.w = length(p-camp);\n    if (inter_current.w < inter_closest.w && hits) {\n        inter_closest = inter_current;\n    }\n    //\n    // caps\n    //\n    if (whl.x >= TAU*.99) {\n        // the ring goes a full 360deg so ignore the cap things\n        return inter_closest;\n    }\n    //\n    //\n    p = camp;\n    inter_current = inter_plane(\n        p, d, vec3(0.), normalize(vec3(cos(bl.x+PI*.5), sin(bl.x+PI*.5), 0.)) );\n    p += d*inter_current.w;\n    q = vec3( mod(atan(p.y, p.x)+TAU, TAU), length(p.xy), p.z);\n    hits = true;\n    // hits = mod(q.x-bl.x+PI+TAU, TAU) >= PI && mod(q.x-bl.x-whl.x+PI+TAU, TAU) < PI && hits;\n    hits = abs( mod(q.x-bl.x+TAU, TAU)-PI )-PI*.5 > 0. && hits;\n    //hits = abs( mod(q.x-bl.x+PI+TAU, TAU)-PI*.5 ) > PI*.5;\n    hits = q.y >= bl.y && q.y < bl.y+whl.y && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    if (inter_current.w < inter_closest.w && hits) {\n        inter_closest = inter_current;\n    }\n    //\n    p = camp;\n    inter_current = inter_plane(\n        p, d, vec3(0.), normalize(vec3(cos(bl.x+whl.x+PI*.5), sin(bl.x+whl.x+PI*.5), 0.)) );\n    p += d*inter_current.w;\n    q = vec3( mod(atan(p.y, p.x)+TAU, TAU), length(p.xy), p.z);\n    hits = true;\n    // hits = mod(q.x-bl.x+PI+TAU, TAU) >= PI && mod(q.x-bl.x-whl.x+PI+TAU, TAU) < PI && hits;\n    hits = abs( mod(q.x-bl.x-whl.x+TAU, TAU)-PI )-PI*.5 > 0. && hits;\n    //hits = abs( mod(q.x-bl.x+PI+TAU, TAU)-PI*.5 ) > PI*.5;\n    hits = q.y >= bl.y && q.y < bl.y+whl.y && hits;\n    hits = q.z >= bl.z && q.z < bl.z+whl.z && hits;\n    if (inter_current.w < inter_closest.w && hits) {\n        inter_closest = inter_current;\n    }\n    //\n    //\n    return inter_closest;\n}\n\nvec4 inter_voxrectprismX (vec3 p, vec3 d, vec3 whl, inout vec3 pT) {\n    //return inter_rectprism(p, d, whl);\n    //float ggo = mod( floor(pT.x/(numcubes/3.)), 3.);\n    float pTo = pT.x;\n    float dist; vec4 inter_current; bool blockhere; int blocid;\n    vec3 camp = p, qm, qf;\n    // space skipping\n    float boulen = .1;\n    vec3 p_m_bouc = p+vec3(boulen);\n    vec3 bouwhl = whl+vec3(boulen*2.);\n    #if 1\n    if (DE_rectprism(p_m_bouc, bouwhl) > 0.) {\n        inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n        if (inter_current.w >= inter_sky.w) {\n            // never hit bounding cube\n            return inter_sky;\n        }\n        else {\n            //\n            p += d*inter_current.w;\n            p += d*1e-3;\n        }\n    }\n    #else\n    inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n    return inter_current;\n    #endif\n    for (int voxjumps=0; voxjumps<400; ++voxjumps) {\n        //\n        p_m_bouc = p+vec3(boulen);\n        if (DE_rectprism(p_m_bouc, bouwhl) > .2) {\n            return inter_sky;\n        }\n        pT = p;\n        pT.x += triofftot;\n        pT.x += pTo;\n        //qf = floor(pT);\n        //qm = fract(pT);\n        vec3 opt = pT, od = d;\n        pT.yz -= gridm*.5;\n        //for (float lj=0.; lj<lamt; ++lj) {\n        //    pT.yz = vec2(-pT.z, pT.y);\n        //    //pf determine blockhere retlated to qm panes\n        //    //    pm determine inter_current\n        //    //    rotate pm inside its own cell along w d\n        //}\n        float th = floor(pT.x/(numcubes)) + floor(pTo/(numcubes/3.));\n        th *= PI*.5;\n        //#define th PI*.5\n        //pT.yz = vec2(-pT.z, pT.y);\n        //pT.yz = mat2(cos(th), cos(PI*.5+th), sin(th), sin(PI*.5+th))*pT.yz;\n        //\n        // below is correct one\n        //pT.yz = mat2(cos(th), sin(th), cos(PI*.5+th), sin(PI*.5+th))*pT.yz;\n        pT.yz = vec2(cos(th)*pT.y+cos(PI*.5+th)*pT.z, sin(th)*pT.y+sin(PI*.5+th)*pT.z);\n        //#undef th\n        //\n        pT.yz += gridm*.5;\n        pT.x = mod(pT.x, numcubes);\n        qf = floor(pT);\n        qm = fract(pT);\n        //qm.xy = mobi*qm.xy;\n        //\n        //\n        blockhere = true;\n        //\n        blocid = blocktyp(qf);\n        blockhere = blocid != 0 && blockhere;\n        //\n        blockhere = pT.y >= 0. && pT.y < gridm && pT.z >= 0. && pT.z < gridm && blockhere;\n        //\n        pT = opt; qf = floor(opt); qm = fract(opt); d = od;\n        //\n        //\n        if (blockhere) {\n            /*for (float lj=0.; lj<mod(ggo, 4.); ++lj) {\n                qm.yz -= .5;\n                qm.yz = vec2(-qm.z, qm.y);\n                qm.yz += .5;\n                d.yz = vec2(-d.z, d.y);\n                //pf determine blockhere retlated to qm panes\n                //    pm determine inter_current\n                //    rotate pm inside its own cell along w d\n            }*/\n            qm.yz -= .5;\n            //qm.yz = mat2(cos(th), sin(th), cos(PI*.5+th), sin(PI*.5+th))*qm.yz;\n            //d.yz = mat2(cos(th), sin(th), cos(PI*.5+th), sin(PI*.5+th))*d.yz;\n            qm.yz = vec2(cos(th)*qm.y+cos(PI*.5+th)*qm.z, sin(th)*qm.y+sin(PI*.5+th)*qm.z);\n            d.yz = vec2(cos(th)*d.y+cos(PI*.5+th)*d.z, sin(th)*d.y+sin(PI*.5+th)*d.z);\n            //#undef th\n            qm.yz += .5;\n            inter_current = inter_SDF(qm, d);\n            pT = opt; qf = floor(opt); qm = fract(opt); d = od;\n            //\n            inter_current.w += length(p-camp);\n            vec3 wasp = p;\n            p = camp+d*inter_current.w;\n            blockhere = DE_rectprism(p, whl) < 1e-3;\n            if (inter_current.w < inter_sky.w && blockhere) {\n                pT = p;\n                pT.x += triofftot;\n                pT.x += pTo;\n                /*for (float lj=0.; lj<mod(ggo, 4.); ++lj) {\n                    inter_current.yz = vec2(inter_current.z, -inter_current.y);\n                    //pf determine blockhere retlated to qm panes\n                    //    pm determine inter_current\n                    //    rotate pm inside its own cell along w d\n                }*/\n                inter_current.yz = mat2(cos(-th), sin(-th), cos(PI*.5-th), sin(PI*.5-th))*inter_current.yz;\n                return inter_current;\n            }\n            p = wasp;\n        }\n        //\n        //\n        dist = inter_sky.w;\n        // macro method\n        #if 0\n        //#define inter_plane_dist(p, d, c, n) (dot(n, d)>1e-6?dot(c-p, n)/dot(n, d):inter_sky.w)\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(-1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., -1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., 0., -1.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(1., 0., 0.), vec3(1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 1., 0.), vec3(0., 1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 0., 1.), vec3(0., 0., 1.)) );\n        #else\n        // optimized method\n        dist = min(dist, qm.x/-d.x+ max(d.x +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.y/-d.y+ max(d.y +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.z/-d.z+ max(d.z +1e-6, 0.)*1e20 );\n        //\n        dist = min(dist,dot(vec3(1., 0., 0.)-qm, vec3(1., 0., 0.))/d.x+max(-d.x +1e-6, 0.)*1e20);\n        dist = min(dist,dot(vec3(0., 1., 0.)-qm, vec3(0., 1., 0.))/d.y+max(-d.y +1e-6, 0.)*1e20);\n        dist = min(dist,dot(vec3(0., 0., 1.)-qm, vec3(0., 0., 1.))/d.z+max(-d.z +1e-6, 0.)*1e20);\n        //\n        #endif\n        //\n        p += d*dist; p += d*5e-3;\n    }\n    //\n    return inter_sky;\n}\n\nvec4 inter_voxarcprismXY (vec3 p, vec3 d, float bly, vec3 whl, inout vec3 pT) {\n    float pTo = pT.x;\n    //\n    //#define th (trioffm*PI*.5/arcm)\n    float th = trioffm*PI*.5/arcm;\n    //p.xy = mat2(cos(th), sin(th), cos(PI*.5+th), sin(PI*.5+th))*p.xy;\n    //d.xy = mat2(cos(th), sin(th), cos(PI*.5+th), sin(PI*.5+th))*d.xy;\n    p.xy = vec2(cos(th)*p.x+cos(PI*.5+th)*p.y, sin(th)*p.x+sin(PI*.5+th)*p.y);\n    d.xy = vec2(cos(th)*d.x+cos(PI*.5+th)*d.y, sin(th)*d.x+sin(PI*.5+th)*d.y);\n    //\n    vec3 bl = vec3(th, bly, 0.);\n    //\n    vec4 inter_current; vec3 camp = p, qf; bool blockhere; int blocid;\n    //\n    //#define boulen .2\n    #define boulen .9\n    //#define boulen .02\n    vec3 boubl = bl-vec3(boulen/PI, boulen, boulen);\n    vec3 bouwhl = whl+vec3(boulen/PI*2., boulen*2., boulen*2.);\n    //\n    #if 1\n    // space skipping\n    if (DE_arcprism(p, boubl, bouwhl) > .0) {\n        inter_current = inter_arcprism(p, d, boubl, bouwhl);\n        if (inter_current.w >= inter_sky.w) {\n            return inter_sky;\n        }\n        p += d*inter_current.w;\n        p += d*1e-3;\n    }\n    #else\n    //inter_current = inter_arcprism(p, d, bl, whl);\n    inter_current = inter_arcprism(p, d, boubl, bouwhl);\n    #define tempn inter_current\n    //temp.xy = mat2(cos(-th), sin(-th), cos(PI*.5-th), sin(PI*.5-th))*tempn.xy;\n    tempn.xy = vec2(\n        cos(-th)*tempn.x+cos(PI*.5-th)*tempn.y,\n        sin(-th)*tempn.x+sin(PI*.5-th)*tempn.y);\n    #undef tempn\n    return inter_current;\n    //\n    #endif\n    //\n    for (int voxjumps=0; voxjumps<400; ++voxjumps) {\n        //\n        //if (DE_arcprism(p, boubl, bouwhl) > .2) {\n        if (DE_arcprism(p, boubl, bouwhl) > 3.2) {\n            return inter_sky;\n        }\n        pT = vec3(\n            mod(atan(p.y, p.x)+TAU, TAU)/(PI*.5)*arcm,\n            length(p.xy),\n            p.z\n        );\n        //\n        qf = floor(pT);\n        qf.x += triofff;\n        qf.x += pTo;\n        qf.y -= gridm*(roundL-1.); qf.y = floor(gridm-qf.y-.1);\n        //\n        float th90 = floor(qf.x/(numcubes)) + floor(pTo/(numcubes/3.));\n        //qf.yz -= gridm*.5;\n        for (int rotqf=0; rotqf<int(  floor(mod(th90, 4.))  ); ++rotqf) {\n            qf.yz += .1;\n            qf.yz = vec2(gridm-qf.z, qf.y);\n            //\n            //qf.yz = vec2(qf.z, gridm-qf.y);\n            qf.yz = floor(qf.yz);\n        }\n        //qf.yz += gridm*.5;\n        //qf = floor(qf);\n        //\n        blockhere = true;\n        //\n        blocid = blocktyp(qf);\n        blockhere = blocid != 0 && blockhere;\n        //\n        blockhere = qf.y >= 0. && qf.y < gridm && qf.z >= 0. && qf.z < gridm && blockhere;\n        if (blockhere) {\n            inter_current = inter_arcu(p, d, floor(pT), th90*PI*.5);\n            #undef th\n            if (inter_current.w < inter_sky.w) {\n                vec3 tempp = p+d*inter_current.w;\n                if (\n                    DE_arcprism(tempp, bl, whl) <= .0 &&\n                    /*DE_arcprism(\n                        tempp,\n                        floor(pT)*vec3(PI*.5/arcm, 1., 1.),\n                        vec3(PI*.5/arcm, 1., 1.)\n                    ) <= 0.7/*/true/**/) {\n                    inter_current.w += length(p-camp);\n                    #define tempn inter_current\n                    //temp.xy = mat2(cos(-th), sin(-th), cos(PI*.5-th), sin(PI*.5-th))*tempn.xy;\n                    tempn.xy = vec2(\n                        cos(-th)*tempn.x+cos(PI*.5-th)*tempn.y,\n                        sin(-th)*tempn.x+sin(PI*.5-th)*tempn.y);\n                    #undef tempn\n                    p = tempp;\n                    pT = vec3(\n                        mod(atan(p.y, p.x)+TAU, TAU)/(PI*.5)*arcm,\n                        length(p.xy),\n                        p.z\n                    );\n                    pT.y -= gridm*(roundL-1.); pT.y = gridm-pT.y;\n                    pT.x += triofff;\n                    pT.x += pTo;\n                    return inter_current;\n                }\n                #if 1\n                p = tempp;\n                #endif\n            }\n        }\n        //\n        pT = vec3(\n            mod(atan(p.y, p.x)+TAU, TAU)/(PI*.5)*arcm,\n            length(p.xy),\n            p.z\n        );\n        inter_current = inter_arcprism(\n            p, d, floor(pT)*vec3(PI*.5/arcm, 1., 1.), vec3(PI*.5/arcm, 1., 1.));\n        //inter_current.w += length(p-camp);\n        //return inter_current;\n        p += d*inter_current.w;\n        p += d*1e-3;\n    }\n    return inter_sky;\n    #undef boulen\n}\n\nvec4 inter_tribar (vec3 p, vec3 d, out vec3 pT) {\n    //\n    #define cy1c   (\\\n        vec3(.5)/3. + \\\n        vec3(.5+(triL-1.), .5, .5)/3. + \\\n        vec3(.5+(triL-1.), .5+(triL-1.), .5)/3.\\\n    )*gridm\n    //#define cy1c vec3(0.)\n    //#define cy1n normalize(vec3(1., 1., 1.))\n    #define cy1n vec3(.577350269189626)\n    //#define cy1n normalize(vec3(1., 0., 0.))\n    #define cy1r (3.2*gridm)\n    //\n    float drep = length(vec3(triL-1.))*gridm;\n    //\n    #if 1\n    #define pane0c vec3(roundL*gridm, 0., 0.)\n    #define pane0n normalize(vec3(1., 0., 0.))\n    #else\n    #define pane0c vec3(0.)\n    #define pane0n normalize(vec3(0., 0., 1.))\n    //#define pane0n normalize(vec3(1.))\n    #endif\n    #define pane1c (pane0c+vec3(triL-1.)*gridm)\n    #define pane1n pane0n\n    //\n    //\n    vec4 inter_closest = inter_sky, inter_current;\n    //\n    vec3 camp = p; vec3 q;\n    //\n    //\n    #define render_cy1 0\n    // space skipping\n    //return inter_plane(p, d, pane0c, pane0n);\n    vec4 inter_cy1 = inter_cylinder(p, d, cy1c, cy1n, cy1r);\n    if (SDF_cylinder(p, cy1c, cy1n, cy1r) > 0.) {\n        if (inter_cy1.w >= inter_sky.w) {\n            return inter_sky;\n        }\n        else {\n            #if render_cy1\n            return inter_cy1;\n            #else\n            p += d*inter_cy1.w;\n            p += d*1e-3;\n            inter_cy1 = inter_cylinder(p, d, cy1c, cy1n, cy1r);\n            inter_cy1.w += length(p-camp);\n            #endif\n        }\n    }\n    #if render_cy1\n    else {\n        inter_closest = inter_cy1;\n    }\n    #endif\n    //\n    //\n    //\n    #define render_panes 0\n    vec4 inter_closest_pane;\n    //\n    //\n    for (int djumps=0; djumps<3; ++djumps) {\n        //\n        q = p;\n        if (SDF_plane(p, pane0c, pane0n) < 0.) {\n            inter_current = inter_plane(p, cy1n, pane0c, pane0n);\n            inter_current.w = (1.+floor(inter_current.w/drep))*drep;\n            q += cy1n*inter_current.w;\n            //\n        }\n        if (SDF_plane(p, pane1c, pane1n) >= 0.) {\n            inter_current = inter_plane(p, -cy1n, pane1c, pane1n);\n            inter_current.w = (1.+floor(inter_current.w/drep))*drep;\n            q -= cy1n*inter_current.w;\n            //\n        }\n        //\n        inter_closest_pane = inter_sky;\n        inter_current = inter_plane(q, d, pane0c, pane0n);\n        inter_current.w += length(p-camp);\n        if (inter_current.w < inter_closest_pane.w) {\n            inter_closest_pane = inter_current;\n        }\n        inter_current = inter_plane(q, d, pane1c, pane1n);\n        inter_current.w += length(p-camp);\n        if (inter_current.w < inter_closest_pane.w) {\n            inter_closest_pane = inter_current;\n        }\n        //\n        //\n        // rect prisms\n        #if 0\n        /*vec3 pT2;\n        inter_current = inter_voxrectprismX(\n            q, d, vec3(triL-1., 1., 1.)*gridm, pT2);\n        inter_current.w += length(p-camp);\n        if (inter_current.w < inter_closest.w) {\n            pT = pT2;\n            inter_closest = inter_current;\n        }*/\n        inter_current = inter_rectprism(\n            q, d, vec3(triL-1., 1., 1.)*gridm);\n        inter_current.w += length(p-camp);\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        inter_current = inter_rectprism(\n            q-vec3(triL-1., 0., 0.)*gridm, d, vec3(1., triL-1., 1.)*gridm);\n        inter_current.w += length(p-camp);\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        inter_current = inter_rectprism(\n            q-vec3(triL-1., triL-1., 0.)*gridm, d, vec3(1., 1., triL-1.)*gridm);\n        inter_current.w += length(p-camp);\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        #else\n        // arc prisms\n        //\n        // right x\n        //\n        /*inter_current = inter_arcprism(\n            q-vec3(gridm*3., gridm*2., 0.),\n            d,\n            vec3(0.),\n            vec3(PI*.5, gridm, gridm)\n        );*/\n        /*vec3 pT3;\n        inter_current = inter_voxarcprismXY(\n            q-vec3(gridm*3., gridm*2., 0.),\n            d,\n            0.,\n            vec3(PI*.5, gridm, gridm),\n            pT3\n        );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n            pT = pT3;\n        }//*/\n        //\n        //\n        vec3 qT = q, dT = d, pT2;\n        //\n        float jjo;\n        //\n        for (float ggo=0.; ggo<3.; ++ggo) {\n            pT2 = vec3(0.);\n            pT2.x += (numcubes/3.)*ggo;\n            inter_current = inter_voxrectprismX(\n                qT-vec3(0.+roundL, 0., 0.)*gridm,\n                dT,\n                vec3(triL-roundL*2., 1., 1.)*gridm,\n                pT2\n            );\n            inter_current.w += length(p-camp);\n            if (inter_current.w < inter_closest.w) {\n                for (jjo=0.; jjo<ggo; ++jjo) {\n                    inter_current.yz = vec2(-inter_current.z, inter_current.y);\n                    //\n                    inter_current.xy = vec2(-inter_current.y, inter_current.x);\n                }\n                inter_closest = inter_current;\n                pT = pT2;\n            }\n            //\n            //\n            //\n            pT2 = vec3(0.);\n            pT2.x += (numcubes/3.)*ggo; pT2.x += numcubes/3.-arcm;\n            vec3 c1 = vec3(triL-roundL, roundL, 0.)*gridm;\n            qT -= c1;\n            qT.xy = vec2(-qT.y, qT.x);\n            dT.xy = vec2(-dT.y, dT.x);\n            inter_current = inter_voxarcprismXY(\n                qT,\n                dT,\n                (roundL-1.)*gridm,\n                vec3( PI*.5, gridm, gridm),\n                pT2\n            );\n            qT.xy = vec2(qT.y, -qT.x);\n            dT.xy = vec2(dT.y, -dT.x);\n            inter_current.xy = vec2(inter_current.y, -inter_current.x);\n            qT += c1;\n            //\n            //inter_current = inter_arcprism(\n            //    qT-vec3(triL-roundL, roundL, 0.)*gridm,\n            //    dT,\n            //    vec3( TAU*.75, (roundL-1.)*gridm, 0.),\n            //    vec3( PI*.5,   gridm,             gridm)\n            //);pT2 = vec3(5., 0., 0.);\n            //\n            inter_current.w += length(p-camp);\n            if (inter_current.w < inter_closest.w) {\n                for (jjo=0.; jjo<ggo; ++jjo) {\n                    inter_current.yz = vec2(-inter_current.z, inter_current.y);\n                    //\n                    inter_current.xy = vec2(-inter_current.y, inter_current.x);\n                }\n                inter_closest = inter_current;\n                pT = pT2;\n            }\n            //\n            //\n            // up y\n            //\n            //\n            qT.x -= (triL-1.)*gridm;\n            qT.xy = vec2(qT.y, -qT.x);\n            dT.xy = vec2(dT.y, -dT.x);\n            //\n            qT.yz = vec2(qT.z, -qT.y);\n            dT.yz = vec2(dT.z, -dT.y);\n        }\n        //\n        #endif\n        //\n        //\n        if (inter_closest_pane.w < inter_closest.w) {\n            #if render_panes\n            return inter_closest_pane;\n            #else\n            //inter_closest = inter_sky;\n            p = camp+d*inter_closest_pane.w;\n            p += d*1e-3;\n            #endif\n        }\n        else {\n            return inter_closest;\n            // break;\n        }\n    }\n    return inter_closest;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    //\n    vec3 randy; vec2 screen, maus; float samplei2, samplei, ox, oy;\n    //\n    vec3 retina; vec4 inter_current, inter_closest; float shiny; vec3 TEXp;\n    vec3 camp, camd, p, d, q, pT; mat2 azimuth, zenith; float th, ph;\n    //\n    //\n    th = atan(cy1n.z, cy1n.x);//-atan(1., 0.);\n    ph = atan(cy1n.y, length(cy1n.xz));//-atan(0., 1.);\n    #if cam_maus\n    maus = (iMouse.xy-iResolution.xy/2.)/iResolution.y*2.;\n    th += maus.x*PI;\n    ph += maus.y*PI;\n    #endif\n    azimuth = mat2(\n        cos(th), cos(PI*.5+th),\n        sin(th), sin(PI*.5+th)\n    );\n    zenith = mat2(\n        cos(ph), cos(PI*.5+ph),\n        sin(ph), sin(PI*.5+ph)\n    );\n    //\n    #define spp 1.\n    #define spw 1.\n    fragColor.xyz = vec3(0.);\n    //\n    for (samplei2=0.; samplei2<spp*spw*spw; ++samplei2) {\n        ox = mod(samplei2, spw);\n        oy = mod(samplei2/spw, spw);\n        samplei = mod(samplei2/spw/spw, spp);\n        #if 0\n        randy = vec3(\n            fract(sin(\n                mod(\n                    samplei*21.463049023049+\n                    (float(iFrame)+fragCoord.x)*0.021415,\n                    TAU\n                )+fragCoord.y*52.2324352432\n            )),\n            fract(sin(\n                mod(\n                    samplei*421.83743204984+\n                    (float(iFrame)+fragCoord.x)*8.234203,\n                    TAU\n                )+fragCoord.y*123.242543465\n            )),\n            fract(sin(\n                mod(\n                    samplei*952.13454543556+\n                    float(iFrame)*8.234203,\n                    TAU\n                )+fragCoord.y*.003432443\n            ))\n        );\n        #undef samplei\n        #else\n        randy = vec3(0.);\n        #endif\n        //\n        screen = (fragCoord+randy.rg-iResolution.xy/2.)/iResolution.y*2.*.72/.72;\n        //\n        retina = vec3(0.);\n        shiny = 1.;\n        //\n        #if cam_psp\n        camp = vec3(0., 0., -2.)*.4;\n        camd = normalize(vec3(screen.xy, 1.));\n        #else\n        camp = vec3(screen.xy, -6.);\n        camd = normalize(vec3(0., 0., 1.));\n        #endif\n        //\n        camd.yz = zenith*camd.yz;\n        camp.yz = zenith*camp.yz;\n        camd.xz = azimuth*camd.xz;\n        camp.xz = azimuth*camp.xz;\n        //\n        camd = normalize(camd);\n        //camp *= gridm;\n        camp *= cy1r;\n        camp += cy1c;\n        //\n        //\n        #define gobac mod(atan(screen.y, screen.x), TAU)\n        //\n        // setup all camera points on the plane centered at 000 with normal cy1n\n        //camp -= camd*20.;\n        //vec4 inter_start = inter_plane(camp, camd, vec3(0.), -cy1n);\n        //camp += camd*inter_start.w;\n        //\n        // move the camera along the axis of repition continuouslly\n        #if camtrans\n        camp += camd*arg*length(vec3(( triL-1.)*gridm ));\n        #endif\n        //\n        // offset camera rayorigin along a spiral helicloid - \n        // to make the interior not visible and close the loop\n        //\n        //camp += camd*(  (gobac+PI*1.6) )*length(vec3((triL-1.)*gridm))/TAU;\n        #if camkinex\n        camp += camd*(gobac/TAU+.2)*length(vec3(( triL-1.)*gridm ));\n        #endif\n        //\n        //\n        //\n        p = camp; d = camd;\n        //\n        //for (int bounces=0; bounces<33; ++bounces) {\n        for (int bounces=0; bounces<2; ++bounces) {\n            // only have 2 bounces anyways\n            if (shiny < .1) { break; }\n            inter_closest = inter_tribar(p, d, pT);\n            //\n            if (inter_closest.w >= inter_sky.w) {\n                // hits sky - no shading\n                break;\n            }\n            p += d*inter_closest.w;\n            //\n            #define drep length(vec3(triL-1.))\n            q = p;\n            if (SDF_plane(p, pane0c, pane0n) < -1e-2) {\n                inter_current = inter_plane(p, cy1n, pane0c, pane0n);\n                inter_current.w = (1.+floor(inter_current.w/drep))*drep;\n                q += cy1n*inter_current.w;\n                //\n            }\n            if (SDF_plane(p, pane1c, pane1n) >= 1e-2) {\n                inter_current = inter_plane(p, -cy1n, pane1c, pane1n);\n                inter_current.w = (1.+floor(inter_current.w/drep))*drep;\n                q -= cy1n*inter_current.w;\n                //\n            }\n            //\n            if (abs(SDF_cylinder(p, cy1c, cy1n, cy1r)) < 1e-2) {\n                // hits cylinder portal\n                TEXp = .5+.5*inter_closest.xyz;\n                //TEXp *= mod(floor(p.x+.001)+floor(p.y+.001)+floor(p.z+.001), 2.);\n                #define shininess .3999993\n                //#define shininess .0\n                retina += TEXp*shiny*shininess;\n                shiny *= 1.-shininess;\n                #undef shininess\n                //d = reflect(d, inter_closest.xyz);\n                //break;\n                //\n            }\n            else if (min(abs(SDF_plane(q, pane0c, pane0n)),\n                         abs(SDF_plane(q, pane1c, pane1n))) < 1e-2) {\n                //hits one of the plane portals\n                TEXp = vec3(1.);\n                TEXp = abs(inter_closest.xyz);\n                //TEXp = .5+.5*inter_closest.xyz;\n                TEXp *= .7+.3*mod(floor(p.x+.001)+floor(p.y+.001)+floor(p.z+.001), 2.);\n                #define shininess .29999995\n                //#define shininess .0\n                retina += TEXp*shiny*shininess;\n                shiny *= 1.-shininess;\n                #undef shininess\n                //d = reflect(d, inter_closest.xyz);\n                //break;\n            }\n            else {\n                // hits object\n                //TEXp = abs(inter_closest.xyz);\n                //TEXp = .5+.5*inter_closest.xyz;\n                TEXp = vec3(1.);\n                //\n                TEXp = mix(\n                    vec3(.0, .2, .9),\n                    vec3(.0, .9, .8),\n                    clamp(\n                        .5+.5*sin( (pT.x-arg*worldlen)*TAU/numcubes),\n                    0., 1.)*(\n                        .3+.7*sky_map(inter_closest.xyz).r\n                    )\n                );\n                TEXp += vec3(1.)*pow( sky_map(reflect(d, inter_closest.xyz)).r, 1.);\n                TEXp = clamp(TEXp, 0., 1.);\n                //TEXp +=\n                //TEXp *= mod(floor(pT.x+.001)+floor(pT.y+.001)+\n                //            floor(pT.z+.001), 2.);\n                //TEXp *= fract(pT.x);\n                #if 0\n                TEXp *= mod(floor(p.x-.01)+floor(p.y-.01)+\n                        floor(p.z-.01), 2.);\n                #endif\n                #if 0\n                if (mod(\n                    floor(pT.x+.001)+floor(pT.y+.001)+\n                    floor(pT.z+.001), 2.) < 1.) {\n                    TEXp *= fract(pT.x)*.8;\n                }\n                #endif\n                #if 0\n                pT = mod(pT, numcubes);\n                if (pT.x >= -.001 && pT.x <= 1.001*gridm &&\n                    pT.y >= -.001 && pT.y <= 1.001*gridm &&\n                    pT.z >= -.001 && pT.z <= 1.001*gridm) {\n                    TEXp = vec3(1., 0., 1.);\n                }\n                #endif\n                //TEXp = vec3(1.);\n                //#define shininess .29999993\n                #define shininess .39999993\n                retina += TEXp*shiny*shininess;\n                shiny *= 1.-shininess;\n                #undef shininess\n                d = reflect(d, inter_closest.xyz);\n                #if 0\n                vec4 \n                inter_current = inter_tribar(p, sund,\n                break;\n                #endif\n            }\n            p += d*1e-3;\n        }\n        if (shiny >= 1.) {\n            if (SDF_cylinder(camp, cy1c, cy1n, cy1r) > 0.) {\n                //retina += vec3(0.)*shiny;\n                //shiny *= 0.;\n            }\n            retina = vec3(0., 0., 100./255.)*shiny;\n            //retina += vec3(.4, .8, .9)*shiny;\n            shiny *= 0.;\n        }\n        retina += shiny*sky_map(d);\n        fragColor.rgb += retina;\n    }\n    //\n    fragColor.rgb /= spp*spw*spw;\n    fragColor.a = 1.;\n}\n\n\n\n\n\n\n\n/*\n// Old code for: Essence of Helix 2.0\n// Date: 2019-05-22\n// Tags: raytracing, tunnel, spiral\n// Description: Just messin around. Shadertoy rocks!\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat squish = 1.0;\n    float squash = 1.0;\n    vec2 center = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    vec2 xy = vec2(\n        (fragCoord.x-center.x)/squash,\n    \t(fragCoord.y-center.y)/squish\n    );\n    \n    // ↓ for convenience\n    float x = xy.x;\n    float y = xy.y;\n    \n    float zr = iTime+500.0/sqrt(x*x+y*y*1.2);\n    zr = iTime + 200./sqrt(x*x+y*y*1.2);\n    float zt = 1.0*atan(y,x);\n    \n    // it makes it be all checkerboardy\n    zr = floor(zr*1.0)/1.0;\n    zt = floor(zt*60.0)/60.0;\n    \n    float parx = 0.5 + 0.5*cos(zr*6.0+zt);\n    float pary = 0.5 + 0.5*cos(zr*16.0+zt*16.0);\n    \n    // a differet textrue thingy\n    // parx = mod(abs(zx+1e4), 1.0);\n    // pary = mod(abs(zy+1e4), 1.0);\n    \n    \n    // ugly black fog at the horizon. yuck.\n    // float fog = 5.0;\n    \n    // if (abs(y)<fog) {\n    //     parx = parx*sqrt(y/fog);\n    //     pary = pary*sqrt(y/fog);\n    // }\n    \n    vec3 col = vec3(min(parx, pary), parx, max(parx, pary));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n/**/","name":"Image","description":"","type":"image"}]}