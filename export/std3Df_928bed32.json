{"ver":"0.1","info":{"id":"std3Df","date":"1636990760","viewed":115,"name":"night_flies","username":"skaplun","description":"Tried to recreate Last of Us 2 loading screen","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR .1\n#define FAR 10.\n#define STEPS 20.\n#define EMIRAD 0.2\n\n#define BUTTERFLIES_COUNT 30\nButterfly butterflies[BUTTERFLIES_COUNT] = Butterfly[BUTTERFLIES_COUNT](\n    Butterfly(Sphere(vec3(0.), .1), 1., 0.),\n    Butterfly(Sphere(vec3(0.), .1), 2.1, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 3.2, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 4.3, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 5.4, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 6.5, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 7.6, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 8.7, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 9.8, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 10.9, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 11., 0.),\n    Butterfly(Sphere(vec3(0.), .1), 12.1, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 13.2, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 14.3, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 15.4, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 16.5, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 17.6, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 18.7, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 19.8, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 20.9, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 51., 0.),\n    Butterfly(Sphere(vec3(0.), .1), 62.1, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 73.2, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 84.3, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 95.4, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 126.5, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 437.6, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 3458.7, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 69.8, 0.),\n    Butterfly(Sphere(vec3(0.), .1), 70.9, 0.)\n);\n\nfloat TIME;\nfloat butterfly(const in Butterfly butterfly, vec3 p){\n    {\n        vec3 pos = p - butterfly.boundingSphere.origin;\n        pos = vec3(pos.xy, abs(pos.z));\n        float rad = butterfly.boundingSphere.rad;\n        float res = sdEllipsoid(pos, vec3(rad * .5, rad * .125, rad * .125));\n        \n        {\n            vec3 wpos = pos;\n            float a = butterfly.flap;\n            wpos.yz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            \n            float wing = sdPlane(wpos, normalize(vec3(0., 1., 0.)), .005);\n            wing = max(-wing, sdPlane(wpos, normalize(vec3(0., 1., 0.)), -.005));\n            wing = max(wing, length(wpos) - rad);\n            \n            \n            wpos = pos;\n            a = PI * .35;\n            wpos.zx *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            float winga = sdEllipsoid(wpos, vec3(rad, rad * .5, rad * .35));\n            \n            wpos = pos;\n            a = PI * .475;\n            wpos.zx *= mat2(cos(a), -sin(a), sin(a), cos(a));\n            float wingb = sdEllipsoid(wpos - vec3(rad * -.15, 0., rad * .1), vec3(rad, rad * .5, rad * .25));\n            \n            res = min(max(wing, min(winga, wingb)), res);\n        }\n        \n        return res;\n    }\n}\n\nvec2 world(vec3 pos, const in Ray ray){\n    vec2 res = vec2(MAX_FLOAT);\n    for(int i=min(iFrame,0); i<BUTTERFLIES_COUNT; i++){\n        Butterfly curCic = butterflies[i];\n        if(sphere_hit(curCic.boundingSphere, ray))\n            res = min2(res, vec2(butterfly(curCic, pos), 2.5));\n    }\n    return res;\n}\n\nconst int MAX_MARCHING_STEPS = 64;\nvec2 march(const in Ray ray, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = world(ray.origin + depth * ray.direction, ray);\n        if (dist.x < EPS)\n            return vec2(depth, dist.y);\n        depth += dist.x;\n        if (depth >= end)\n            return vec2(end, -1.);\n    }\n    return vec2(-1.);\n}\n\nvec3 calculateNormals(vec3 pos, const in Ray ray){\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPS;\n    return normalize( e.xyy*world( pos + e.xyy, ray ).x + \n\t\t\t\t\t  e.yyx*world( pos + e.yyx, ray ).x + \n\t\t\t\t\t  e.yxy*world( pos + e.yxy, ray ).x + \n\t\t\t\t\t  e.xxx*world( pos + e.xxx, ray ).x );\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt){\n    for(int i=min(iFrame,0); i<BUTTERFLIES_COUNT; i++){\n        Butterfly curCic = butterflies[i];\n        curCic.boundingSphere.rad *= .5;\n        if(sphere_hit(curCic.boundingSphere, Ray(ro, rd), mint, maxt))\n            return 0.;\n    }\n    return 1.;\n}\n\nfloat volNoise;\nfloat GetVolumeLight( vec3 camPos, vec3 rayDir, vec3 lightPos, float lightRan, float hit, vec2 screenPos ){    \n    float maxDis = min(FAR, hit);\n    float stepDis = (FAR - NEAR) / STEPS;\n    vec3 stepVec = rayDir * stepDis;\n    \n    float dis = NEAR + volNoise * 0.5;\n    vec3 pos = camPos + rayDir * dis;\n        \n    float sum = 0.0;\n    for(float i = 0.0; i < STEPS; i++)\n    {        \n        vec3 lightVec = lightPos - pos;\n        float lenLightVec = length(lightVec);\n        if(lenLightVec < lightRan)\n        {\n        \tvec3 lightDir = normalize(lightVec);\n            float shadow = shadow(pos, lightDir, 0.0, lenLightVec - EMIRAD - 0.03);\n            float atten = max(1. - lenLightVec / lightRan, 0.0);\n        \tsum += shadow * atten / STEPS;\n        }\n        \n        dis += stepDis;        \n        if(dis > maxDis)\n        \tbreak;        \n        pos += stepVec;\n    }\n    \n    return sum;\n}\n\nvec3 render(vec3 camPos, vec3 rayDir, vec2 screenPos) {\n    Ray r = Ray(camPos, rayDir);\n    Light light = Light(vec3(0), vec3(0.439,0.757,1.000) * 1.5, 4.0, vec3(0.2));\n    \n    vec3 col;\n    vec3 pos = camPos;\n    vec2 hit = march(r, NEAR, FAR);\n    if(hit.y >= 0.) {\n        vec3 pos = r.origin + r.direction * hit.x;\n        vec3 nrm = calculateNormals(pos, r);\n        col = light.lightCol * max(.01, dot(nrm, normalize(light.lightPos - pos)));\n    } else {\n        col = vec3(0.03);\n    }\n    if(sphere_hit(Sphere(light.lightPos, light.lightRan), r, NEAR, FAR))\n        col += GetVolumeLight(camPos, rayDir, light.lightPos, light.lightRan, hit.x, screenPos) * light.lightCol;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    volNoise = texture(iChannel0, fragCoord / iChannelResolution[0].xy).r;\n    TIME = iTime;\n    for(int i=min(iFrame,0); i<BUTTERFLIES_COUNT; i++){\n        vec3 noise = noised(vec2(butterflies[i].id + 47., TIME * .5));\n        float dstToLight = 2. + noise.z * 1.5;\n        float a = noise.x * PI * 2.- PI * .75;\n        float a2 = noise.y * PI * .5 - PI * .5;\n        \n        butterflies[i].boundingSphere.origin.xy = vec2(dstToLight * sin(a), dstToLight *  cos(a));\n        butterflies[i].boundingSphere.origin.xz = vec2(dstToLight * sin(a2), dstToLight *  cos(a2));\n        butterflies[i].flap = sin(iTime * 50.) - a;\n    }\n    \n    vec3 lookAt = vec3(-5., -2.5, 0.);\n    vec3 eye = vec3(0., 0, 10.);\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, lookAt, vec3(0., 1., 0.)) * viewDir;\n    \n    vec3 col = render(eye, worldDir, fragCoord.xy);\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPS 1e-4\nconst float PI = acos(-1.);\n\nstruct Ray{vec3 origin, direction;};\nstruct Sphere{vec3 origin; float rad;};\nstruct Butterfly{Sphere boundingSphere; float id, flap;};\nstruct Light\n{\n    vec3 lightPos;\n    vec3 lightCol;\n    float lightRan;\n    vec3 amb;\n};\n\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.direction, inray.direction);\n    float b = dot(oc, inray.direction);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    return discriminant > 0.;\n}\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray, float t_min, float t_max) {\n    vec3 oc = inray.origin - sphere.origin;\n    float a = dot(inray.direction, inray.direction);\n    float b = dot(oc, inray.direction);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        float temp = (-b - sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec2 min2(vec2 a, vec2 b){\n    return (a.x <= b.x) ? a : b;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h ) {\n  return dot(p,n) + h;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n//by iq\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}","name":"Common","description":"","type":"common"}]}