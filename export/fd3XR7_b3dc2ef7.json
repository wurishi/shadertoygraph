{"ver":"0.1","info":{"id":"fd3XR7","date":"1632825953","viewed":167,"name":"GraphicsTrackSpecialisation","username":"TheTUFGuy","description":"Blinn-Phong Model","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["submission"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//General Instruction: Just focus on Set functions :) \n#define MAX_STEPS 100\n#define MAX_DIST 200.0\n#define SURF_DIST 0.001\n#define MAX_OBJECTS 100\n\nfloat createSphere(vec3 pos, float r, vec3 p)//takes in centre and radius\n{\n    return length(p-pos)-r;\n}\nfloat createCapsule(vec3 a, vec3 b, float r,vec3 p)//takes in two endpoints and radius\n{\n   vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r; \n}\nfloat createTorus(vec3 pos, float r, float t, vec3 p)//takes in centre, radius and thickness\n{\n    p-=pos;\n    float x = length(p.xz)-r;\n    return length(vec2(x,p.y))-t;\n}\nfloat createBox(vec3 origin, vec3 dim, vec3 p)//takes in centre and dimensions (no rotation implemented yet)\n{\n    p-=origin;\n    \n    vec3 q = abs(p) - dim;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvoid SetObjects(out int n,out float objects[MAX_OBJECTS],vec3 p)\n{\n    n=5; //number of objects(not more than 99 please!)\n    //update number of objects above and add the objects in the lines below using functions shown above\n    objects[0] = createSphere(vec3(0.,1.,6.),1.2,p);\n    objects[1]  = createSphere(vec3(2,4,6),.3,p);\n    objects[2] = createCapsule(vec3(-3.5,-4.,6.),vec3(2,4,6),.2,p);\n    objects[3] = createTorus(vec3(0,1,6),2.,.2,p);\n    objects[4] = createSphere(vec3(2,1,6),.5,p);\n}\nvoid SetMat(out vec4[MAX_OBJECTS] mat,int n)\n{\n    //set material for each object as specified above\n    mat[0]=vec4(1.,1.,0.,1.);\n    mat[1]=vec4(1.,0.,0.,1.);\n    mat[2]=vec4(1.,1.,1.,1.);\n    mat[3]=vec4(0.,0.,1.,1.);\n    mat[4]=vec4(0.,1.,1.,1.);\n    //Don not touch\n    mat[n]=vec4(0.);\n}\nvoid SetCamera(out vec3 ro, out vec3 rd, vec2 uv)\n{\n    //Camera Position\n    ro =vec3(10.*sin(3.*iTime),3,6.+10.*cos(3.*iTime));\n    //Point at which the camera looks\n    vec3 lookAt = vec3(0,1,6);\n    //Zoom of camera (in terms of dist b/w screen and camera\n    float zoom =1.;\n    \n    \n    //Do not touch (unless you know what you are doing ofc :p)\n    vec3 f = normalize(lookAt-ro);\n    vec3 r = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,r));\n    vec3 c = ro+f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    rd = i-ro;\n}\nvoid SetLight(out vec3 lightPos, out vec4 col, out float diff, out float ambF, out float specF)\n{\n    //Light Position\n    lightPos = vec3(4,10,9.0);\n    //Light Color\n    col =vec4(1.,1.,1.,1.);\n    //Diffusion Factor\n    diff = .5;\n    //Ambience Factor\n    ambF = 0.3;\n    //Specular Factor\n    specF = 0.7;\n    \n}\n\n\n\n\n\n//DO NOT TOUCH\nfloat GetDist(vec3 p)  //of objects from point p\n{\n    float objects[MAX_OBJECTS];\n    int n;\n    SetObjects(n,objects,p);\n    float d = MAX_DIST*1000.;\n    for(int i=0;i<n;i++)\n    {\n        d=min(d,objects[i]);\n    }\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.0;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p =ro+rd*dO;\n        float dS = GetDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST||dS<SURF_DIST) break;\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.001,0);\n    vec3 n = d-vec3(GetDist(p-e.xyy),GetDist(p-e.yxy),GetDist(p-e.yyx));\n    return normalize(n);\n}\nvec4 GetLight(vec3 p, vec3 rd)\n{\n    \n    vec3 lightPos; vec4 col; float diffF,ambF,specF;\n    SetLight(lightPos,col,diffF,ambF,specF);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float diff = clamp(dot(n,l),0.,1.)*diffF;\n    //Shadow Calc\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) diff *= .1;\n    \n    vec3 v = normalize(rd*-1.);\n    vec3 r = reflect(-1.*l,n);\n    specF *= pow(max(dot(v,r),0.0),64.);\n    \n    return (specF+ambF+diff)*col;\n}\nvec4 GetMat(vec3 p)\n{\n    float objects[MAX_OBJECTS];\n    int n;\n    SetObjects(n,objects,p);\n    float d = MAX_DIST*1000.;\n    for(int i=0;i<n;i++)\n    {\n        d=min(d,objects[i]);\n    }\n    int i;\n    for(i=0;i<n;i++)\n    {\n        if(d==objects[i])\n        break;\n    }\n    vec4 mat[MAX_OBJECTS];\n    SetMat(mat,n);\n    return mat[i];\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro,rd;\n    SetCamera(ro,rd,uv);\n    float d = RayMarch(ro,rd);\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro+rd*d;\n        vec4 light = GetLight(p,rd);\n        vec4 material  = GetMat(p);\n        vec4 result = material*light;\n        fragColor = result;\n    }\n    else\n    fragColor = vec4(0.);\n}","name":"Image","description":"","type":"image"}]}