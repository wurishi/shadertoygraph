{"ver":"0.1","info":{"id":"lc23zD","date":"1703927529","viewed":38,"name":"stars and mobius","username":"nayk","description":"stars,colorful,mobius,galaxy,universe","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["colorful","mobius","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/Ds2XRd https://www.shadertoy.com/view/4tyfWy*/\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nfloat nice_beautiful_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define BUMP_EPS 0.004\n\n\nfloat tt, g_mat;\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\nvec3 waveSpectrum(float w){\n\n    if(w > 700.0 || w < 400.0){\n        return vec3(0);\n    }\n    \n\tfloat x = fract((w - 400.0)/ 300.0);\n    \n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\tvec3 col = bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2);\n\n    // https://twitter.com/Atrix256/status/1019359890660192256\n    // Undo gamma\n    col = invGamma(col);\n\n    return col;\n}\n\nvec3 diffraction(vec3 rd, vec3 n, vec3 td, vec3 l, float d) {\n\n    vec3 col = vec3(0);\n\n    float cos_ThetaL = dot(l, td);\n    float cos_ThetaV = dot(rd, td);\n   \n    float u = abs(cos_ThetaL - cos_ThetaV);\n    \n    if(u == 0.) {\n        return vec3(0);\n    }\n    \n    for(float i=1.; i < 2.; i++) {\n        float wavelength = u * d / i;\n        col += waveSpectrum(wavelength);\n    }\n    col = clamp(col, vec3(0), vec3(1));\n    return col;\n}\n\nvec3 transform(vec3 p) {\n   p.yz *= rot(PI*.25 + tt);\n   p.yx *= rot(PI*.25 + .4*tt);\n    return p;\n}\n\nvec2 torusUV(vec3 p) {\n\n    p = transform(p);\n    float a = atan(p.z, p.x);\n    float r = length(p.zx);\n    \n    return vec2(r, a);  \n}\n\n\nfloat box(vec3 p, vec3 r) {\n  vec3 d = abs(p) - r;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n\n\nfloat map(vec3 p) {   \n  \n    vec3 bp = p;\n    float edge = 0.01;\n  \n    p = transform(p);\n\n    float r = 2.;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n\n    float rev = 1.;\n    float a = atan(p.z, p.x);\n\n    cp *= rot(rev*a);\n    cp = abs(cp) - .1;\n    \n    float dr = rect(cp.xy, vec2(.5), edge);\n\n    float d= dr;\n    return .5*d;\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat gridSurf( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*2., 1.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = BUMP_EPS;\n    float ref = gridSurf(p);                 \n    vec3 grad = vec3( gridSurf(vec3(p.x-eps, p.y, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y-eps, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        if(abs(d) < 0.0001 || t > 100.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    \n    return vec2(t, mat);\n}\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n    \tvec2 uv2 = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\tuv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n   tt = iTime;\n    vec3 ro = vec3(uv*6.,-4.),\n          rd = vec3(0,0,1.),\n          lp = vec3(3., 0., -5),\n          lp2 = vec3(-3., 0., -5);\n\n    vec3 col;\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.122,0.467,0.518);\n    vec3 c2 = vec3(0.192,0.122,0.278);\n    \n    // light color\n    vec3 lc1 = vec3(0.745,0.761,0.976);\n    vec3 lc2 = vec3(0.573,0.922,0.969);\n    \n    \n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 200.;\n        vec2 rm = raymarch(ro, rd, steps);\n        mat = rm.y;\n        \n        \n        vec3 p = ro + rm.x*rd;\n        \n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                                e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n\n        vec2 tuv = torusUV(p);\n\n        n = doBumpMap(vec3(tuv.x, 0., tuv.y*2.*PI), n, .001);\n    \n     \n        if(rm.x < 50.) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l2), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n\n            float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n\n            vec3 td = vec3(tuv.x, tuv.y, 0.).yxz;\n            vec3 tangent;\n            vec3 bitangent;\n\n            pixarONB(n, tangent, bitangent);\n            tangent = normalize(tangent);\n            bitangent = normalize(bitangent);\n\n            mat3 tbn = mat3(tangent, bitangent, n);\n            l = normalize(vec3(0., 1, 0));\n            vec3 difr = diffraction(-rd, n, normalize(tbn*td), l, 700.);\n            col += .3*(lc1*dif + lc2*dif2)+ difr;\n            \n          \n            col = mix(col, col*(smoothstep(0., 1., sin(tuv.y*150.+10.*tt))), .5);\n          \n            if(mat == 0.) {\n                rd = reflect(rd, n);\n                \n                rd.yz *= rot(PI*.8);\n         \n             \n                \n             \n               // refl *= mix(vec3(1), spectral_zucconi6(n.x*n.y*3.), .5); // reflect rainbows too\n           \n    \n              \n            } \n\n        } else {\n            col =  mix(c1+.2, c2-.2, (pow(dot(uv2, uv2), .8)))*.5+.1; // background\n            \n            //col = texture(iChannel0, ro).rgb;\n            col = invGamma(col);\n        } \n    \n    }\n\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv));\n    col *= mix(.2, 1., (1.5-pow(dot(uv2, uv2), .5))); // vignette\n    col = gamma(col); // gamma \n\n\tvec3 from=vec3(1.,.5,0.5)*col;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n     fragColor *= vec4(nice_beautiful_star(uv,anim) * vec3(0.55,0.5,0.55), 1.0);\n   \n}\n","name":"Image","description":"","type":"image"}]}