{"ver":"0.1","info":{"id":"4l3GWS","date":"1471061510","viewed":596,"name":"Wobbly Truchet Tiles","username":"AmazingThew","description":"Simple Truchet tiles with some noise-based animation applied to the lines\n\nUses Wombat's noise implementation: https://github.com/BrianSharpe/Wombat","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nconst int samples = 4;\nconst float angle = 1.;\nconst mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\nconst vec4 navy = vec4(0.08, 0.15, 0.22, 1.00);\nconst vec4 egg  = vec4(1.00, 0.96, 0.91, 1.00);\n\nconst float speed = 2.;\nconst float noiseScale = 67.;\nconst float shift = -8.;\n\nvec2 aux;\n\nfloat SimplexPerlin3D( vec3 P );\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec4 samplePixel(vec2 uv) {\n    vec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n    float tileWidth = 50.0 / iResolution.x;\n    \n    uv *= aspect;\n    uv *= rot;\n    \n    float noiseZ = iTime * speed;\n    float noise = SimplexPerlin3D(vec3(uv*iResolution.x/40., noiseZ)) * 0.5 + 0.5;\n    \n    float thickness = uv.x+0.4;\n    thickness = thickness*0.3 - noise * 0.07 * (1.0-uv.x+0.4);\n    \n    vec2 tileCoord = fract(uv / tileWidth);\n    vec2 tileId = floor(uv / tileWidth);\n    \n    vec2 dlCorner = vec2(0.0, 0.0);\n    vec2 drCorner = vec2(1.0, 0.0);\n    vec2 ulCorner = vec2(0.0, 1.0);\n    vec2 urCorner = vec2(1.0, 1.0);\n    float dlArc = mix(1.0, 0.0, step(thickness, abs(length(tileCoord-dlCorner)-0.5)));\n    float drArc = mix(1.0, 0.0, step(thickness, abs(length(tileCoord-drCorner)-0.5)));\n    float ulArc = mix(1.0, 0.0, step(thickness, abs(length(tileCoord-ulCorner)-0.5)));\n    float urArc = mix(1.0, 0.0, step(thickness, abs(length(tileCoord-urCorner)-0.5)));\n    \n    float typeA = max(dlArc, urArc);\n    float typeB = max(drArc, ulArc);\n    float typeC = mix(1.0, 0.0, min(step(thickness, abs(tileCoord.x-0.5)), step(thickness, abs(tileCoord.y-0.5))));\n    \n    float selector = rand(tileId+vec2(12.));\n    float val = mix(mix(typeA, typeB, step(1.0/3.0, selector)), typeC, step(2.0/3.0, selector));\n    //val = mix(typeA, typeB, step(0.5, selector)); //Uncomment for Smith-style tiles\n    \n    return mix(navy, egg, 1.0-val);\n}\n\nvec4 superSamplePixel(vec2 pos) {\n    vec2 off = 1.0 / float(samples) / iResolution.xy;\n    vec4 sum = vec4(0.0);\n    for (int x=0; x<samples; x++) {\n        for (int y=0; y<samples; y++) {\n            sum += samplePixel(pos + vec2(off.x*float(x), off.y*float(y)));\n        }\n    }\n    return sum / float(samples * samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    aux = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = superSamplePixel(uv);\n}\n\n\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I'm not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This is a modified version of Stefan Gustavson's and Ian McEwan's work at http://github.com/ashima/webgl-noise\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - space scaled can have an approx feature size of 1.0\n//  - filter kernel changed to fix discontinuities at tetrahedron boundaries\n//\n\n//\n//  Simplex Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat SimplexPerlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHADRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tevaluate gradients\n    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    kernel_weights = max(0.5 - kernel_weights, 0.0);\n    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\n\n    //\tsum with the kernel and return\n    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\n}","name":"Image","description":"","type":"image"}]}