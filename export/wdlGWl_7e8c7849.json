{"ver":"0.1","info":{"id":"wdlGWl","date":"1547829856","viewed":226,"name":"Simplified bilin patch intersect","username":"msqrt","description":"A variation of https://www.shadertoy.com/view/3dXGWs, mapping the intersection to a reference coordinate system (Woop triangle intersection style).","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["bilinear","patch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Analytic bilinear surface ray intersection. Also shows how such a surface is contained\n// within a tetrahedron defined by the same 4 points as the surface itself.\n//\n// This can be useful for when rasterising the bounding surface as a pre-step when mixing\n// raytracing with rasterisation.\n//\n// This example also shows the use of ray differentials, using surface differentials\n// obtained directly from the intersection point which are then used to transform the ray\n// differentials in to texture space.\n//\n\n#define SHOW_BOUNDING_POLYTOPE\t0\n#define SHOW_BOUNDING_WIREFRAME\t0\n\n\n// Deformed cube geometry\nvec3 vertices[8];\nint indices[6 * 4];\n\n// Ray intersection test with bilinear surface defined by 4 points\nbool traceBilinearPatch(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd,\n                        inout vec3 outs, inout vec3 outt, inout vec3 outuvi)\n{\n    pb -= pa; pc -= pa; pd -= pa; ro -= pa;\n    mat3 M = mat3(pb, pc, pd);\n    if(abs(determinant(M))<1e-6) { // planar; intersect as rectangle\n        M[2] = cross(pb, pc);\n        M = mat3(1.,.0,.0,.0,.0,1.,.0,1.,.0)*inverse(M);\n   \t\tro = M * ro;\n    \trd = M * rd;\n        if(abs(rd.y)<1.e-6) return false;\n        float t = -ro.y/rd.y;\n        outuvi = vec3(ro.xz + t*rd.xz, t);\n    }\n    else {\n        // map ray to reference coordinates (rotation, scale, shear)\n \t   \tM = mat3(1.,.0,.0,.0,.0,1.0,1.,-1.,1.)*inverse(M);\n        ro = M * ro;\n        rd = M * rd;\n\n        // f(p) = p.y+p.x*p.z = 0, plug in p = o + td\n        // f(o+td) = (o.y+t*d.y) + (o.x+t*d.x)*(o.z+t*d.z)\n        //\t\t   = o.y+o.x*o.z + t*(d.y+d.x*o.z+o.x*d.z) + t*t*(d.x*d.z) = 0 => quadratic solve\n        \n        float c = ro.y+ro.x*ro.z, b = rd.y+rd.x*ro.z+ro.x*rd.z, a = rd.x*rd.z, d = b*b-4.*a*c;\n        if(d<.0) return false;\n        float t0, t1;\n        if(abs(a)>1.e-5) {\n            a = .5/a;\n            d = abs(a*sqrt(d));\n            b = -b*a;\n            t0 = b-d, t1 = b+d;\n        }\n        else\n            t0 = t1 = -c/b; // almost linear, solve as such\n        // for reference patch, uv = xz\n        outuvi = vec3(ro.xz + t0*rd.xz, t0);\n        if(t0!=t1 && (outuvi.z<.0 || outuvi.x<.0 || outuvi.y<.0 || outuvi.x>1. || outuvi.y>1.))\n            outuvi = vec3(ro.xz + t1*rd.xz, t1);\n    }\n    if(outuvi.z<.0 || outuvi.x<.0 || outuvi.y<.0 || outuvi.x>1. || outuvi.y>1.)\n        return false;\n    // Surface differentials in worldspace\n    outs = pb * outuvi.x - mix(pc, pd, outuvi.x);\n    outt = pc * outuvi.y - mix(pb, pd, outuvi.y);\n\t\n    return true;\n}\n\n// Ray intersection test with tetrahedron\nvec2 traceTetrahedron(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd, inout vec3 outn)\n{\n    vec3 tn0 = cross(pb - pa, pc - pa);\n    vec3 tn1 = cross(pb - pc, pd - pc);\n    vec3 tn2 = cross(pd - pa, pb - pa);\n    vec3 tn3 = cross(pc - pa, pd - pa);\n\n    if(dot(pd - pc, tn0) > 0.0)\n    {\n        tn0 = -tn0;\n        tn1 = -tn1;\n        tn2 = -tn2;\n        tn3 = -tn3;\n    }\n\n    float td0 = dot(rd, tn0);\n    float td1 = dot(rd, tn1);\n    float td2 = dot(rd, tn2);\n    float td3 = dot(rd, tn3);\n\n    float tt0 = dot(pa - ro, tn0) / td0;\n    float tt1 = dot(pc - ro, tn1) / td1;\n    float tt2 = dot(pa - ro, tn2) / td2;\n    float tt3 = dot(pa - ro, tn3) / td3;\n\n    float tmin = -1e4, tmax = +1e4;\n\n    if(td0 > 0.0)\n    {\n        tmax = min(tmax, tt0);\n    }\n    else\n    {\n        if(tt0 > tmin)\n        {\n            tmin = tt0;\n            outn = tn0;\n        }\n    }\n\n    if(td1 > 0.0)\n    {\n        tmax = min(tmax, tt1);\n    }\n    else\n    {\n        if(tt1 > tmin)\n        {\n            tmin = tt1;\n            outn = tn1;\n        }\n    }\n\n    if(td2 > 0.0)\n    {\n        tmax = min(tmax, tt2);\n    }\n    else\n    {\n        if(tt2 > tmin)\n        {\n            tmin = tt2;\n            outn = tn2;\n        }\n    }\n\n    if(td3 > 0.0)\n    {\n        tmax = min(tmax, tt3);\n    }\n    else\n    {\n        if(tt3 > tmin)\n        {\n            tmin = tt3;\n            outn = tn3;\n        }\n    }\n\n    return vec2(tmin, tmax);\n}\n\n// Ray intersection test with deformed cube composed of six bilinear patches\nbool traceDeformedCube(vec3 ro, vec3 rd, inout vec3 outs, inout vec3 outt, inout vec3 outuvi)\n{\n    vec3 closest_uvi = vec3(1e4), closest_s = vec3(0), closest_t = vec3(0);\n\n    vec3 uvi, norm, s, t;\n\n    // Intersection test against sides of deformed cube\n\n    for(int i = 0; i < 6; ++i)\n    {\n        vec3 pa = vertices[indices[i * 4 + 0]];\n        vec3 pb = vertices[indices[i * 4 + 1]];\n        vec3 pc = vertices[indices[i * 4 + 2]];\n        vec3 pd = vertices[indices[i * 4 + 3]];\n\n        if(traceBilinearPatch(ro, rd, pa, pb, pc, pd, s, t, uvi))\n        {\n            if(uvi.z > 0.0 && uvi.z < closest_uvi.z)\n            {\n                closest_uvi = uvi;\n                closest_s = s;\n                closest_t = t;\n            }\n        }\n    }\n\n    float u = closest_uvi.x;\n    float v = closest_uvi.y;\n    float i = closest_uvi.z;\n\n    if(u < 0. || u > 1. || i < 0. || v < 0. || v > 1.)\n        return false;\n\n    outs = closest_s;\n    outt = closest_t;\n    outuvi = closest_uvi;\n\n    return true;\n}\n\nvec3 closestPointsOnLines(vec3 p0, vec3 v0, vec3 p1, vec3 v1)\n{\n    return inverse(mat3(v0, -v1, cross(v1, v0))) * (p1 - p0);\n}\n\nfloat lineMask(vec3 ro, vec3 rd, vec3 pa, vec3 pb, float r, float maxt)\n{\n    vec3 t = closestPointsOnLines(ro, rd, pa, pb - pa);\n\n    vec3 lp = mix(pa, pb, clamp(t.y, 0., 1.));\n\n    return step(distance(ro + rd * t.x, lp), r) * step(t.x, maxt);\n}\n\nfloat tetrahedronWireframeMask(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd, float r, float maxt)\n{\n    float mask = 0.;\n\n    mask = max(mask, lineMask(ro, rd, pa, pb, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pb, pd, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pd, pc, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pc, pa, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pa, pd, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pc, pb, r, maxt));\n\n    return mask;\n}\n\nfloat deformedCubeWireframeMask(vec3 ro, vec3 rd, float r, float maxt)\n{\n    float mask = 0.;\n\n    for(int i = 0; i < 6; ++i)\n    {\n        vec3 pa = vertices[indices[i * 4 + 0]];\n        vec3 pb = vertices[indices[i * 4 + 1]];\n        vec3 pc = vertices[indices[i * 4 + 2]];\n        vec3 pd = vertices[indices[i * 4 + 3]];\n\n        mask = max(mask, tetrahedronWireframeMask(ro, rd, pa, pb, pc, pd, r, maxt));\n    }\n\n    return mask;\n}\n\nfloat traceDeformedCubeBounds(vec3 ro, vec3 rd, inout vec3 outn)\n{\n    vec3 closest_uvi = vec3(1e4), closest_s = vec3(0), closest_t = vec3(0);\n\n    float min_i = 1e4;\n\n    // Intersection test against tetrahedral bounds of sides of deformed cube\n\n    for(int i = 0; i < 6; ++i)\n    {\n        vec3 pa = vertices[indices[i * 4 + 0]];\n        vec3 pb = vertices[indices[i * 4 + 1]];\n        vec3 pc = vertices[indices[i * 4 + 2]];\n        vec3 pd = vertices[indices[i * 4 + 3]];\n\n        vec3 n;\n\n        vec2 is = traceTetrahedron(ro, rd, pa, pb, pc, pd, n);\n\n        if(is.x < is.y && is.x < min_i)\n        {\n            min_i = is.x;\n            outn = n;\n        }\n    }\n\n    return min_i;\n}\n\n// Box-filtered grid, from https://iquilezles.org/articles/filterableprocedurals\nfloat grid( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    const float N = 10.0; // grid ratio\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0., -.1, 4.);\n\n    // Set up primary ray including differentials\n\n    vec3 rd = normalize(vec3(uv.xy, -1.6));\n    vec3 rdx = rd + dFdx(rd);\n    vec3 rdy = rd - dFdy(rd);\n\n    // Base vertices and indices of cube\n\n    vertices[0] = vec3(-1, -1, -1);\n    vertices[1] = vec3(-1, -1, +1);\n    vertices[2] = vec3(-1, +1, -1);\n    vertices[3] = vec3(-1, +1, +1);\n    vertices[4] = vec3(+1, -1, -1);\n    vertices[5] = vec3(+1, -1, +1);\n    vertices[6] = vec3(+1, +1, -1);\n    vertices[7] = vec3(+1, +1, +1);\n\n    indices[0 * 4 + 0] = 0;\n    indices[0 * 4 + 1] = 1;\n    indices[0 * 4 + 2] = 2;\n    indices[0 * 4 + 3] = 3;\n\n    indices[1 * 4 + 0] = 7;\n    indices[1 * 4 + 1] = 6;\n    indices[1 * 4 + 2] = 5;\n    indices[1 * 4 + 3] = 4;\n\n    indices[2 * 4 + 0] = 0;\n    indices[2 * 4 + 1] = 1;\n    indices[2 * 4 + 2] = 4;\n    indices[2 * 4 + 3] = 5;\n\n    indices[3 * 4 + 0] = 2;\n    indices[3 * 4 + 1] = 3;\n    indices[3 * 4 + 2] = 6;\n    indices[3 * 4 + 3] = 7;\n\n    indices[4 * 4 + 0] = 0;\n    indices[4 * 4 + 1] = 2;\n    indices[4 * 4 + 2] = 4;\n    indices[4 * 4 + 3] = 6;\n\n    indices[5 * 4 + 0] = 1;\n    indices[5 * 4 + 1] = 3;\n    indices[5 * 4 + 2] = 5;\n    indices[5 * 4 + 3] = 7;\n\n    // Vertex deformation, twisting etc.\n\n    for(int i = 0; i < 8; ++i)\n    {\n        vec3 p = vertices[i];\n        \n        float an = cos(time + p.y) / 2.;\n        p.xz = mat2(cos(an), sin(an), sin(an), -cos(an)) * p.xz;\n\n        an = cos(time*2.+p.x+2.);\n        p.yz = mat2(cos(an),sin(an),sin(an),-cos(an)) * p.yz;\n\n        an = time + 5.;\n        p.xz = mat2(cos(an), sin(an), sin(an), -cos(an)) * p.xz;\n\n        an = time / 3.;\n        p.yz = mat2(cos(an), sin(an), sin(an), -cos(an)) * p.yz;\n\n        vertices[i] = p;\n    }\n\n    // The convex bounds are traced here as a small speedup\n    vec3 boundsn;\n    float bounds_i = traceDeformedCubeBounds(ro, rd, boundsn);\n\n    bool hit = false;\n    vec3 closest_uvi = vec3(1e4), closest_s = vec3(0), closest_t = vec3(0);\n\n    //if(bounds_i > 0. && bounds_i < 1e3)\n    {   \n        hit = traceDeformedCube(ro, rd, closest_s, closest_t, closest_uvi);\n    }\n\n    int textureID = 0;\n    float shadow = 1.;\n\n    // Light direction\n    vec3 l = normalize(vec3(6, 7, 0));\n\n    // Intersection with floor\n    float floor_i = (-2. - ro.y) / rd.y;\n\n    if(floor_i > 0.0 && floor_i < closest_uvi.z)\n    {\n        // Ray hit the floor\n        vec3 rp = ro + rd * floor_i;\n\n        closest_s = vec3(1, 0, 0) * .2;\n        closest_t = vec3(0, 0, 1) * .2;\n\n        closest_uvi.x = dot(rp, closest_s);\n        closest_uvi.y = dot(rp, closest_t);\n        closest_uvi.z = floor_i;\n\n        // vec3 dummy_s, dummy_t, dummy_uvi;\n        //if(traceDeformedCube(rp, l, dummy_s, dummy_t, dummy_uvi))\n        //{\n        //   shadow = .5;\n        //}\n\n        textureID = 1;\n    }\n    else if(hit && (closest_uvi.z < floor_i || floor_i < 0.0))\n    {\n        textureID = 2;\n    }\n\n    if(textureID == 0)\n    {\n        // Background\n        fragColor.rgb = vec3(.1);\n    }\n    else\n    {\n        float u = closest_uvi.x;\n        float v = closest_uvi.y;\n        float i = closest_uvi.z;\n\n        vec3 closest_norm = normalize(cross(closest_s, closest_t));\n\n        // Ensure that the normal is forward-facing\n\n        if(dot(rd, closest_norm) > 0.)\n            closest_norm = -closest_norm;\n\n        // Use ray differentials to get intersection points for neighbouring pixels\n        // and transform them in to texture space for texture sampling.\n\n        vec3 rp = ro + rd * i;\n        vec3 rpx = ro + rdx * dot(rp - ro, closest_norm) / dot(rdx, closest_norm);\n        vec3 rpy = ro + rdy * dot(rp - ro, closest_norm) / dot(rdy, closest_norm);\n\n        vec2 duvx = vec2(dot(rpx - rp, closest_s), dot(rpx - rp, closest_t));\n        vec2 duvy = vec2(dot(rpy - rp, closest_s), dot(rpy - rp, closest_t));\n\n        // Texturing\n\n        vec3 c;\n\n        if(textureID == 1)\n        {\n            c = textureGrad(iChannel2, vec2(u, v), duvx / 2., duvy / 2.).rgb;\n            c *= mix(.5, 1., smoothstep(0., 2., length(rp.xz)));\n        }\n        else if(textureID == 2)\n        {\n            c = textureGrad(iChannel0, vec2(u, v), duvx / 2., duvy / 2.).rgb;\n            c *= mix(.5, 1., smoothstep(0., .1, 1. - 2. * max(abs(u - .5), abs(v - .5))));\n            float gridscale = 8.0;\n            vec3 gridc = vec3(grid(vec2(u, v) * gridscale + .05, duvx / 2. * gridscale, duvy / 2. * gridscale));\n            c = mix(gridc, c, smoothstep(.2, .26, fract(time / 5. - .7)) - smoothstep(.7, .76, fract(time / 5. - .7)));\n        }\n\n        // Shading\n\n        vec3 r = reflect(rd, closest_norm);\n        float fres = mix(.01, .8, pow(clamp(1. - dot(-rd, closest_norm), 0., 1.), 2.));\n\n        vec3 spec = texture(iChannel1, r).rgb * .5;\n\n        spec += pow(max(0., dot(closest_norm, normalize(l + normalize(-rd)))), 64.);\n\n        vec3 diff = c * max(0., .5 + .5 * dot(l, closest_norm));\n\n        fragColor.rgb = mix(diff, spec, fres) * shadow;\n    }\n\n\n    #if SHOW_BOUNDING_POLYTOPE\n    if(bounds_i > 0. && bounds_i < 1e3)\n    {\n        boundsn = normalize(boundsn);\n        vec3 bounds_col = vec3(.5 + .5 * dot(boundsn, l));\n        fragColor.rgb = mix(fragColor.rgb, bounds_col, .5);\n    }\n    #endif\n\n    #if SHOW_BOUNDING_WIREFRAME\n    float wireframe_mask = deformedCubeWireframeMask(ro, rd, 0.01, closest_uvi.z);\n    fragColor.rgb = mix(fragColor.rgb, vec3(1), wireframe_mask * .5);\n    #endif\n\n    // Gamma correction\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}