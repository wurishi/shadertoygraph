{"ver":"0.1","info":{"id":"td3cW7","date":"1601083137","viewed":512,"name":"Walking trip","username":"athibaul","description":"A hand-modelled human character with a walking animation. I really start to like rounded cones :)","likes":54,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sdf","animation","walking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------\n// WALKING TRIP\n// ------------\n\n// Alexis THIBAULT, 09/2020\n\n// Thank you iq for this \"rounded cone\" sdf, I love it!\n\n\n\n// ------------ EXPLANATION OF THE ANIMATION ------------\n//\n// The animation was done completely manually.\n//\n// Most measurements used come from these documents:\n// - Artistic proportion chart\n//     https://upload.wikimedia.org/wikipedia/commons/8/82/Drawing_of_proportions_of_the_male_and_female_figure%2C_1936.jpg\n// - Chronophotography of a walking person\n//     https://thegenealogyofstyle.files.wordpress.com/2014/12/marey_morin20walk_1886.jpg\n// But there was also a lot of tweaking, of course.\n//\n// Human walking motion can be decomposed into a few main\n// components:\n// - arm and leg movement, with a period of ~1 second\n//     (1.33 here for a chill walk),\n// - vertical bobbing at each step, so twice faster (every half second).\n//\n// Good envelope functions must be found for each joint\n// angle. A simple sin() is usually fine, except for \n// complex movements. We then need to determine:\n// \n// - the AMPLITUDE of the motion:\n//     minimal and maximal angle value are easy to measure \n//     on a chronophotography, or can be guessed and \n//     tweaked manually.\n// \n// - the PHASE:\n//     this is really the core of what makes the animation\n//     look natural. For instance, the lower arm is carried\n//     along by the lower arm, so its motion follows with a little\n//     time delay; so does the hand relative to the lower arm.\n//     Sometimes it is possible to measure, but here I did it all\n//     by trial-and-error.\n//     Changing the phase completely changes the feel of the walk,\n//     it can make it robotic, completely unnatural, or just\n//     different. Try for instance changing the phase of the\n//     head bobbing!\n//\n// - in some cases, more subtle envelope shapes must be used,\n//     e.g. for the lower leg and foot to follow the ground correctly.\n//     Once again, this was done by trial-and-error, but with close\n//     observation of the chronophotography, plus obvious knowledge \n//     of what happens when we walk (stuff like \"when on the ground,\n//     the foot is horizontal and doesn't move relative to the ground\").\n//\n// ------------------------------------------------------------\n\n\n\n\n#define PI 3.1415926\n#define TAU (2.*PI)\n// Adapted mix() for functions that range in [-1,1]\n#define smix(a,b,x) mix(a,b,0.5+0.5*(x))\n#define ROT(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\n// Uncomment to show the body without smoothing\n//#define BARE_BONES\n\n\n\n\n#ifdef BARE_BONES\n#define smin(a,b,k) min(a,b)\n#define smax(a,b,k) max(a,b)\n#else\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(1.-abs((b-a)/k), 0., 2.);\n    return min(a,b) - k*0.25*h*h*step(-1.,-h);\n}\nfloat smax(float a, float b, float k)\n{\n    float h = clamp(1.-abs((b-a)/k), 0., 2.);\n    return max(a,b) + k*0.25*h*h*step(-1.,-h);\n}\n#endif\n\n/*\nfloat smin(float a, float b, float k, float d)\n{\n    // Modified smooth-min function\n    float h = clamp(1.-abs((b-a)/k), 0.,2.);\n    return min(a,b) - k/d*0.5*pow(h,d) * step(-1.,-h);\n}\n*/\n\nfloat gain(float x, float d)\n{\n    // Modified gain function, for x between -1 and 1\n    // k<1. makes the output stay around zero more,\n    // k>1. makes the output stay around +-1 more.\n    return (1.-pow(1.-abs(x), d)) * sign(x);\n}\n\n\n\nfloat halfMan( vec3 p, float t )\n{\n    // Only the right half of the man (y < 0.)\n    // (yeah sorry I'm the kind of person who uses vertical z)\n    // Measurements are in meters.\n    \n    float d;\n    \n    // Torso\n    #if 0\n    // Old version\n    d = sdRoundCone(p, vec3(0.03, -0.07,-0.1), vec3(-0.01,-0.095,-0.27), 0.085, 0.10);\n    float srad = clamp(0.5*(0.13-p.x), 0., 0.1);\n    d = smin(d, sdRoundCone(p, vec3(0.02, -0.07,-0.1), vec3(-0.02, -0.08, 0.15), 0.085, 0.125), srad);\n\t#else\n    // Re-modeled, and with animation\n    vec3 hip = vec3(-0.01-0.02*sin(PI*t),-0.095,-0.27); // Rocking hip\n    d = sdRoundCone(p, vec3(0.02, -0.07,-0.1), hip, 0.08, 0.10);\n    float srad = 0.1*smoothstep(0.,0.1,0.095-0.5*p.x);\n    vec3 shoulder = vec3(-0.02+0.01*sin(PI*t+PI/4.), -0.08, 0.15); // Rocking shoulder\n    d = smin(d, sdRoundCone(p, vec3(0.02, -0.07,-0.02), shoulder, 0.085, 0.125), srad);\n\t#endif\n\n    // Femur\n    float th2M = TAU/12., th2m = -TAU*13./360.; // Min/max angles\n    float th2 = smix(th2M,th2m,sin(PI*t)); // Femur oscillation is sinusoidal\n    float femurL = 0.46;\n    //vec3 q = p - vec3(0., -0.11, -0.275);\n    vec3 q = p - hip;\n    q.xz *= ROT(th2);\n    q.yz *= ROT(0.07); // Femur points \"inwards\" a bit\n    q.z += femurL;\n    d = smin(d, sdRoundCone(q.xzy, 0.06, 0.095, 0.4), 0.03);\n    \n    // Tibia\n    float th1M = -0.01, th1m = -TAU/6.;\n    // Tibia oscillation is... complicated.\n    // It is delayed by PI/4 relative to the femur, and stays around\n    // extreme values more.\n    float th1 = mix(th1M,th1m,pow(0.5+0.5*sin(PI*t-TAU/4.),2.));\n    float tibiaL = 0.355;\n    q.y += 0.005;\n    q.xz *= mat2(cos(th1), sin(th1), -sin(th1), cos(th1));\n    q.yz *= ROT(-0.05);\n    q.z += tibiaL;\n    d = smin(d, sdRoundCone(q.xzy, 0.041, 0.055, 0.31), 0.02);\n    \n    // Foot\n    // Foot motion is real complicated.\n    // When set on the ground, it must be horizontal.\n    float th0set=-th1-th2; \n    // When lifted, it is first pointing \"down\" a lot,\n    // then pointing \"up\" a bit.\n    float th0relax=0.5*th1+0.1; \n    // Mix them based on whether the foot is on the ground.\n    float th0 = smix(th0set, th0relax, gain(sin(PI*t-TAU/3.), 3.0));\n    vec3 foot = vec3(0.25,0.11,0.035);\n    q.xz *= mat2(cos(th0),sin(th0),-sin(th0),cos(th0));\n    q.z += 0.065;\n    q.x -= 0.05;\n    d = smin(d, sdBox(q,0.5*foot-0.02)-0.02, 0.1);\n    \n    // Upper arm\n    q = p - vec3(-0.03+shoulder.x, -0.19, 0.215);\n    float uarmL = 0.305;\n    float th3 = 0.3*sin(PI*t); // Oscillates opposite of the femur\n    q.xz *= mat2(cos(th3), sin(th3), -sin(th3), cos(th3));\n    q.yz *= ROT(-0.25);\n    q.z += uarmL;\n    srad = clamp(0.8*(p.z-0.16)-0.3*(p.x+0.05), 0., 0.1);\n    d = smin(d, sdRoundCone(q.xzy, 0.045, 0.07, uarmL), srad);\n    \n    // Lower arm\n    float larmL = 0.254;\n    float th4 = 0.15+0.15*sin(PI*t-PI/6.); // Delayed w.r.t. upper arm\n    q.xz *= ROT(th4);\n    q.yz *= ROT(0.15);\n    q.z += larmL;\n    d = smin(d, sdRoundCone(q.xzy, 0.03, 0.045, 0.21), 0.02);\n    \n    // Hand\n    float phi5 = PI/6.;\n    q.xz *= ROT(0.1+0.1*sin(PI*t-PI/4.)); // Delayed still a bit more\n    q.xy *= ROT(phi5);\n    q.z += 0.08;\n    q.y += 0.008;\n    d = smin(d, sdBox(q, vec3(0.04, 0.02,0.08)-0.02)-0.025, 0.0);\n    d = smin(d, sdRoundCone(q, vec3(0.02,0.005,0.06), vec3(0.05,0.04,-0.03),0.025,0.01), srad);\n    \n    // Neck bottom\n    d = smin(d, sdRoundCone(p, vec3(-0.04,-0.165,0.275), vec3(-0.02,0.05,0.32), 0.01,0.02), 0.05);\n    \n    return d;\n}\n\nfloat fullMan( vec3 p, float t )\n{\n    // Vertical bobbing of the whole body\n    p.z -= 0.03*sin(TAU*t+PI/6.);\n    \n    // SDF cheat: don't evaluate the complicated sdf if we're too far\n    float d0 = sdBox(p, vec3(0.7,0.5,1.2));\n    if(d0 > 0.5) return d0-0.25;\n    \n    // Join the two halves, with a half-cycle of time offset between the two\n    float srad = smoothstep(0.,1.,10.0*(0.3+p.z)+3.*p.x)*0.1 + 0.01;\n    float d = smin(halfMan(p,t), halfMan(vec3(p.x,-p.y,p.z), t+1.), srad);\n    \n    // Neck\n    d = smin(d, sdRoundCone(p, vec3(-0.04,0.,0.275), vec3(0.0,0.,0.38),0.06,0.06), 0.05);\n    \n    // Head\n    vec3 q = p;\n    q.z -= 0.35;\n    q.xy *= ROT(gain(cos(0.4*t), 2.)); // Just lookin' around...\n    q.xz *= ROT(-0.3-0.1*sin(TAU*t+PI/4.)); // and bobbin' my head...\n    q.z += 0.35;\n    q = vec3(q.x,abs(q.y),q.z);\n    float d2 = smin(\n        sdRoundCone(q, vec3(0.,0.,0.50), vec3(0.08,   0.0,0.38),0.1,0.04),\n        length(q-vec3(0.02,0.035,0.45))-0.05,\n        0.04\n    );\n    // Eye orbit\n    //d2 = smax(d2, 0.01-length(q-vec3(0.1,0.05,0.46)), 0.055);\n    // Nose\n    //d2 = smin(d2, length(q-vec3(0.11,0.,0.435)) - 0.01, 0.04);\n    \n    d = smin(d,d2,0.05);\n    return d;     \n}\n\nfloat buildings( vec3 p, float t )\n{\n    p.y = abs(p.y)+3.;\n    p.y -= max(10.*round(p.y/10.), 10.);\n    \n    // It's actually the buildings that are moving!\n    // (That's all relative, of course.)\n    p.x = mod(p.x + 1.0*t, 10.0) - 5.;\n    return sdBox(p, vec3(3.,2.5,4.))-0.1;\n}\n\nfloat map( vec3 p )\n{\n    float d = p.z+1.13;\n    //d = smin(d, 2.6-length(p), 1.5); // Uncomment to trap the man in a bubble\n    float t = 1.5*iTime;\n    d = min(d, fullMan(p, t));\n    d = min(d, buildings(p+vec3(0.,0.,1.13), t));\n    return d;\n}\n\n\n\nvec3 normal( vec3 p )\n{\n    vec2 e = 0.001 * vec2(1, -1);\n    return normalize(\n          e.xxx * map(p+e.xxx)\n        + e.xyy * map(p+e.xyy)\n        + e.yxy * map(p+e.yxy)\n        + e.yyx * map(p+e.yyx)\n    );\n}\n\n// Ambient Occlusion computation adapted from iq\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor, float scale )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + scale*0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)/scale*sca;\n        sca *= 0.95;\n        if( occ>0.5 ) break;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    float th = iTime * 0.1;\n    vec3 ro = vec3(2.5*cos(th), 2.5*sin(th), 0.0);\n    //vec3 ro = vec3(0.,-2.5,0.);\n    vec3 camFwd = normalize(vec3(0.5,0,0) - ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    float fov = 0.5;\n    vec3 rd = (camFwd + fov * (uv.x * camRight + uv.y * camUp));\n    rd = normalize(rd);\n    \n    float d, t=0.;\n    for(int i=0; i<256; i++)\n    {\n        d = map(ro+t*rd);\n        if(d < 0.001 || t > 100.) break;\n        t += d;\n    }\n    vec3 p = ro+t*rd;\n    vec3 col;\n    if(t > 100.)\n    {\n        col = 0.5+0.5*rd;\n    }\n    else\n    {\n        vec3 n = normal(p);\n        col = 1.7*(0.5+0.5*n);\n        \n        //vec3 q = 10.*p; // Grid every 10cm\n        //vec3 grid = abs(q-round(q));\n        //col = mix(col, vec3(2.0), smoothstep(0.1,0.0,min(grid.y,grid.z)));\n        float sca = clamp(length(p), 1.0, 10.0);\n        col *= calcAO(p,n,sca);\n    }\n    \n    \n    col *= smoothstep(3.5,1.0,length(uv));\n    \n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Distance functions by iq\n// https://www.shadertoy.com/view/Xds3zN\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n","name":"Common","description":"","type":"common"}]}