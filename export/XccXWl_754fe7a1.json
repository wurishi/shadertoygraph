{"ver":"0.1","info":{"id":"XccXWl","date":"1714578871","viewed":62,"name":"Onde stazionarie","username":"L1zardSqu4d","description":"ciao","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ondestazionarie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897931;\n\n// Constants\nconst float NODI = 1.0;\n\nconst float LUNGHEZZA = 6.0;\nconst float AMPIEZZA = 1.2; // m\nconst float VELOCITA = 4.;\n\nconst float LAMBDA = 2. * LUNGHEZZA / NODI ; // m\nconst float FREQUENZA = VELOCITA / LAMBDA; // Hz\nconst float OMEGA = 2. * PI * FREQUENZA;\nconst float K = 2. * PI / LAMBDA;\n\nconst float ZOOM = 5.;\n\n// if H_CONST is too low it won't work\n#define H_CONST 1.0e-2\n#define DERIVATIVE(f, x) ((f(x + H_CONST) - f(x)) / H_CONST)\n\n// position = position of the pixel in space\n// m = f'(position.x)\n#define G_FUNCTION(m, xpos) (-xpos / m + position.y + position.x / m)\n#define G_FUNCTION_DERIVATIVE(m) (-1.0 / m)\n\n#define H_FUNCTION(f, x, m) (f(x) - G_FUNCTION(m, x))\n#define H_FUNCTION_DERIVATIVE(x, m) (m - G_FUNCTION_DERIVATIVE(m))\n\nconst float thickness = 10.0;\n#define AXIS_THICKNESS 2.0\n#define DASH_SIZE 0.1\n\n\nfloat f0(float x) {\n    //if(x < .0 || x > LAMBDA * 0.5) return BIG_NUMBER;\n\treturn AMPIEZZA * cos(K * x) * cos(OMEGA * iTime);\n    \n}\n\n// Approximated with Newton's method\n#define PLOT(f, functionColor) { \\\nint iterations = 0; \\\nfloat xguess = position.x; \\\nfloat m = DERIVATIVE(f, xguess); \\\nfloat fvalue = H_FUNCTION(f, xguess, m); \\\nwhile(abs(fvalue) > 1e-5 && iterations++ < 5) { \\\n    xguess = xguess - fvalue / H_FUNCTION_DERIVATIVE(xguess, m); \\\n    m = DERIVATIVE(f, xguess); \\\n    fvalue = H_FUNCTION(f, xguess, m); \\\n} \\\nvec2 positionOnFunction = vec2(xguess, f(xguess)); \\\nfloat distance = length(position - positionOnFunction); \\\ncolor = mix(color, functionColor, 1.0 - smoothstep(0.0, 1.0, distance / (thickness * pixelSize * 0.5))); \\\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n\tvec3 color = vec3(0.15);\n\n\tfloat pixelSize = ZOOM / iResolution.y;\n    vec2 camera = vec2(LAMBDA * (0.25 + NODI * 0.5 * 0.5) - pixelSize * iResolution.x * 0.5, -ZOOM * 0.5);\n\n\tvec2 position = camera + pixelSize * gl_FragCoord.xy;\n\n\t// grid\n\t#define DIST_AXIS(val) abs(mod(val, 1.0))\n\tif(DIST_AXIS(position.x) < pixelSize * AXIS_THICKNESS || DIST_AXIS(position.y) < pixelSize * AXIS_THICKNESS) {\n\t\tcolor += vec3(0.05);\n\t}\n    \n    // Asse y\n    if(abs(position.y) < pixelSize * AXIS_THICKNESS) {\n        // Draw dashed line\n        if(position.x >= LAMBDA * 0.25 && position.x <= LAMBDA * (0.25 + 0.5 * NODI)) {\n            //color += vec3(0.2, 0, 0.2);\n            if(mod(position.x, DASH_SIZE) < DASH_SIZE * 0.5) {\n                color += vec3(0.2, 0, 0);\n            }\n        } else { // Draw normal axis\n            color += vec3(0.2);\n        }\n    }\n    \n    // Asse x\n    if(abs(position.x) < pixelSize * AXIS_THICKNESS) {\n        color += vec3(0.2);\n    }\n    \n    // Walls\n    if((abs(position.x - LAMBDA * 0.25) < pixelSize * AXIS_THICKNESS || abs(position.x - LAMBDA * (0.25 + 0.5 * NODI)) < pixelSize * AXIS_THICKNESS) && abs(position.y) < AMPIEZZA * 1.5) {\n        color = vec3(0.6);\n    } else {\n        if(position.x >= LAMBDA * 0.25 && position.x <= LAMBDA * (0.25 + 0.5 * NODI)) {\n            PLOT(f0, vec3(0.85, 0.22, 0.18));\n        }\n    }\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}