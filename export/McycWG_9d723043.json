{"ver":"0.1","info":{"id":"McycWG","date":"1732306339","viewed":97,"name":"infinity^n","username":"pb","description":"thanks Gaston,  please watch as iteration count increases...","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"MX2BWV","parentname":"julia spirals^n"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime/3.\n#define too_small 1e-7\n\nvoid mainImage0( out vec4 O, vec2 u )\n{\n    vec2  R =  iResolution.xy, m=iMouse.xy, z,\n          U = ( u+u - R )/ R.y *2.;\n          \n    float i = -1.;\n    \n    float iters = min(12.,mod(floor(iTime*2.),40.));\n    \n    //zoom in after done increasing iterations\n    if (iters == 12.) U *= max(.0002, (1.5-mod(iTime*2.,40.)/20.) );\n    \n    z=U;  //Julia set: input is each pixel coordinate\n    for ( O *= 0. ; i++ < iters && dot(z,z) < 1e5 ; ) {\n        \n        float modz2 = z.x*z.x*z.x*z.x + z.y*z.y*z.y*z.y + 2.*z.x*z.x*z.y*z.y;\n        modz2 =  max(modz2,too_small);\n        \n        //we are looking for: 1/z^2 + c for which we need to \n        //multiply top and bottom by complex conjugate (!)\n        //so we get z!/(z^2*z!^2)+c\n        z = vec2(z.x*z.x-z.y*z.y,-2.*z.x*z.y)/modz2\n            + vec2(-1,0) ;\n        \n    }\n    \n    float zx = mod(iTime*2.,80.)<40. ? cos(log(abs(z.x))*.25) : cos(log(length(z))*.5);\n    O = vec4( zx*zx );\n   \n}\n\n//FabriceNeyret2 antialiasing trick\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.b++;                        // uncomment to see where the oversampling occurs\n    }\n}\n","name":"Image","description":"","type":"image"}]}