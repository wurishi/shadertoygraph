{"ver":"0.1","info":{"id":"WsySRG","date":"1574267776","viewed":145,"name":"Neighborhood","username":"skaplun","description":"Original arrtwork by Danny Jauregui - https://weandthecolor.com/goes-neighborhood-artworks-danny-jauregui/30418","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["worley","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CELLS_CNT 48.\n#define aa (10./iResolution.y)\nconst float refr_a = 0.7;\nconst float refl_i = 0.45;\nconst float refr_i = 0.8;\n\nvec4 render(in vec2 fragCoord){\n\tfloat a = .9;\n    vec3 eye = vec3(3.5 * sin(a), 0., 3.5 * cos(a));\n    vec3 viewDir = rayDirection(90., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    HitRecord rec;\n    if (box_hit(Box(vec3(0.), 1.), Ray(eye, worldDir), rec)){\n    \tvec2 st = (dot(rec.nrm, vec3(1., 0., 0.)) == 0. ? rec.ptnt.xy : rec.ptnt.zy) * .5 + .5,\n             ist = floor(st * CELLS_CNT),\n             fst = fract(st * CELLS_CNT);\n        \n        float v = smoothstep(.4 + aa, .4, abs(fst.x - .5)) * smoothstep(.4 + aa, .4, abs(fst.y - .5));\n        v *= step(floor(pow(rand(ist.y * .27), .25) * CELLS_CNT) * .9, ist.x);\n\t\t\n        vec3 reflRay = reflect(worldDir, rec.nrm);\n\t\tvec3 refrRay = refract(worldDir, rec.nrm, refr_a);\n        \n        float a = iTime;\n        reflRay.xz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n        refrRay.xz *= mat2(cos(-a), -sin(-a), sin(-a), cos(-a));\n        \n        vec3 cubeRefl = texture(iChannel0, reflRay).rgb * refl_i;\n        vec3 cubeRefr = texture(iChannel0, refrRay).rgb * refr_i;\n        \n        vec3 col = pow((cubeRefl + cubeRefr), vec3(4.));\n\n       \treturn vec4(col, v);\n    }\n    \n    return vec4(0.);\n}\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 bg = vec3(pow(bg(uv), .1));\n    vec4 cellColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            cellColor += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    cellColor /= float(AA * AA);\n    fragColor = vec4(mix(bg, cellColor.rgb, cellColor.a), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{vec3 origin, direction;};\nstruct HitRecord{float dist; vec3 ptnt;vec3 nrm;};\n    \nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nstruct Sphere{\n\tvec3 origin;\n    float rad;\n};\n\nstruct Box{ vec3 origin; float size; };\n\nvec3 box_normal_at(const in Box box, const in vec3 point) {\n    vec3 normal;\n    vec3 localPoint = point - box.origin;\n    float mindist = MAX_FLOAT;\n    float dist = abs(box.size - abs(localPoint.x));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(1., 0., 0.);\n        normal *= sign(localPoint.x);\n    }\n    \n    dist = abs(box.size - abs(localPoint.y));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(0, 1., 0);\n        normal *= sign(localPoint.y);\n    }\n    dist = abs(box.size - abs(localPoint.z));\n    if (dist < mindist) { \n        mindist = dist; \n        normal = vec3(0, 0, 1.);\n        normal *= sign(localPoint.z);\n    } \n    return normal;\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, const in Ray inray, inout HitRecord rec){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.origin + vec3(inbox.size);\n    vec3 minbounds = inbox.origin + vec3(-inbox.size);\n    tx = ((inray.direction.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.direction.x;\n\tty = ((inray.direction.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.direction.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.direction.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.direction.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n    \trec.dist = tx.MIN;\n        rec.ptnt = inray.origin + inray.direction * rec.dist;\n        rec.nrm = box_normal_at(inbox, rec.ptnt);\n        return true;\n    }\n        \n    return false;\n}\n\nfloat rand(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 rand(vec2 n)\n{\n \treturn vec2(rand(n.x*23.62-300.0+n.y*34.35),rand(n.x*45.13+256.0+n.y*38.89)); \n}\n\n// returns (dx, dy, distance)\nvec3 worley(vec2 n,float s)\n{\n    vec3 ret = vec3(s * 10.);\n    // look in 9 cells (n, plus 8 surrounding)\n    for(int x = -1;x<2;x++)\n    {\n        for(int y = -1;y<2;y++)\n        {\n            vec2 xy = vec2(x,y);// xy can be thought of as both # of cells distance to n, and \n            vec2 cellIndex = floor(n/s) + xy;\n            vec2 worleyPoint = rand(cellIndex);// random point in this cell (0-1)\n            worleyPoint += xy - fract(n/s);// turn it into distance to n. ;\n            float d = length(worleyPoint) * s;\n            if(d < ret.z)\n                ret = vec3(worleyPoint, d);\n        }\n    }\n    return ret;\n}\n\n#define r(a) mat2(cos(radians(a)), -sin(radians(a)), sin(radians(a)), cos(radians(a)))\nfloat bg(vec2 uv){\n\tvec2 q = 3. * uv; float wsize = 0.8;\n    float f  = 0.5000*worley( q, wsize ).z; q = r(30.)*q*2.01;wsize *= .75;\n    f += 0.2500*worley( q, wsize ).z; q = r(30.)*q*2.02;wsize *= 0.75;\n    f += 0.1250*worley( q, wsize ).z; q = r(30.)*q*2.03;wsize *= 0.75;\n    f += 0.0625*worley( q, wsize ).z; q = r(30.)*q*2.01;wsize *= 0.75;\n    return f;\n}","name":"Common","description":"","type":"common"}]}