{"ver":"0.1","info":{"id":"4fS3Dt","date":"1704764065","viewed":119,"name":"Blue Noise Sorting","username":"sampajama","description":"Very High Quality Blue Noise Generator using Sinc Filtering and ChaCha20. Because this process is recursive, it can only generate a new image every 64 frames, in order to recursively filter old images.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["noise","math","blue","hash","hash","bluenoise","rng","sinc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Blue noise vs Bayer dithering\" by Suslik. https://shadertoy.com/view/wl3XWs\n// 2024-01-10 18:22:04\n\nfloat RaySphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n\tfloat scale = -1.0;\n\n\tfloat a = dot(rayDir, rayDir);\n\tvec3 delta = rayStart - sphereCenter;\n\tfloat b = 2.0 * dot (delta, rayDir);\n\tfloat c = dot(sphereCenter, sphereCenter) + dot(rayStart, rayStart) - 2.0 * dot(rayStart, sphereCenter) - sphereRadius * sphereRadius;\n\tfloat disc = b * b - 4.0 * a * c;\n\tif (disc > 0.0)\n\t{\n\t\tfloat sqrtDisc = sqrt(disc);\n\n\t\tscale = (-b - sqrtDisc) / (2.0 * a);\n\t}\n\treturn scale;\n}\n\nfloat RaytraceScene(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenters[3], vec3 lightPos)\n{\n    for(int i = 0; i < 3; i++)\n    {\n        float hitScale = RaySphereIntersection(rayOrigin, rayDir, sphereCenters[i], iResolution.x * 0.09);\n        if(hitScale < 0.0)\n            continue;\n        vec3 hitPoint = rayOrigin + rayDir * hitScale;\n        vec3 normal = normalize(hitPoint - sphereCenters[i]);\n        \n        float diffuse = max(0.0, dot(normal, -normalize(hitPoint - lightPos)));\n        return diffuse * 0.8 + 0.2;\n    }\n    return 0.1;\n}\n\nfloat GetBayerDither(float grayscale, ivec2 pixelCoord)\n{    \n    //use this for 2x2 bayer test\n    /*int bayerMatrix4[4] = int[4](0, 2, 3, 1);\n    int pixelIndex4 = (pixelCoord.x % 2) + (pixelCoord.y % 2) * 2;\n    return grayscale > (float(bayerMatrix4[pixelIndex4]) + 0.5) / 4.0 ? 1.0 : 0.0;*/\n\n    //use this for 8x8 bayer test\n    /*vec2 uv = (vec2(pixelCoord) + vec2(0.5)) / 8.0; //8 is the texture size\n    return textureLod(iChannel0, fract(uv), 0.0).x < grayscale ? 1.0 : 0.0; //8x8 creates more artifacts on moving objects than 4x4*/\n    \n    //this is the default 4x4 bayer\n    int bayerMatrix16[16] = int[16](0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5);\n    int pixelIndex16 = (pixelCoord.x % 4) + (pixelCoord.y % 4) * 4;\n    return grayscale > (float(bayerMatrix16[pixelIndex16]) + 0.5) / 16.0 ? 1.0 : 0.0;\n}\n\nfloat GetBlueNoiseDither(float grayscale, ivec2 pixelCoord)\n{\n    vec2 uv = (vec2(pixelCoord) + vec2(0.5)) / iChannelResolution[1].xy; //1024 is the texture size\n    float blueNoiseValue = textureLod(iChannel1, fract(uv), 0.0).x;\n    //blueNoiseValue = sin(blueNoiseValue * 2.0 * 3.141592 + iTime) * 0.5 + 0.5;\n    return blueNoiseValue < grayscale ? 1.0 : 0.0;\n}\n\nfloat GetRandomNoiseDither(float grayscale, ivec2 pixelCoord)\n{\n    vec2 uv = (vec2(pixelCoord) + vec2(0.5)) / iChannelResolution[2].xy; //1024 is the texture size\n    float blueNoiseValue = textureLod(iChannel2, fract(uv), 0.0).x;\n    //blueNoiseValue = sin(blueNoiseValue * 2.0 * 3.141592 + iTime) * 0.5 + 0.5;\n    return blueNoiseValue < grayscale ? 1.0 : 0.0;\n}\n\nfloat GetPixelColor(vec2 pixelCoord)\n{\n    float xPos = mix(iResolution.x * 0.2, iResolution.x * 0.8, sin(iTime) * 0.5 + 0.5);\n    float yPos = sin(iTime * 3.0) * 0.05 * iResolution.y * 0.0;\n    vec3 sphereCenters[3];\n    sphereCenters[0] = vec3(xPos, iResolution.y * 0.1666 + yPos, 0.0);\n    sphereCenters[1] = vec3(xPos, iResolution.y * 0.5000 + yPos, 0.0);\n    sphereCenters[2] = vec3(xPos, iResolution.y * 0.8333 + yPos, 0.0);\n    \n    vec3 lightPos = vec3(iResolution.x * (1.5), iResolution.y * 0.5, -1.5 * iResolution.x);\n    \n    vec3 rayOrigin = vec3(iResolution.x * 0.5, iResolution.y * 0.5, -iResolution.x);\n    vec3 rayDst = vec3(pixelCoord.xy, 0.0);\n    vec3 rayDir = normalize(rayDst - rayOrigin);\n    vec3 normals[2];\n\t\n    float grayscale = RaytraceScene(rayOrigin, rayDir, sphereCenters, lightPos);\n    float ditherColor = 0.0;\n    ivec2 shift = ivec2(0*iFrame, 1*iFrame);\n    if(pixelCoord.y > iResolution.y * 0.6666)\n    {\n        ditherColor = GetBayerDither(grayscale, ivec2(pixelCoord) + shift);\n    }else if(pixelCoord.y > iResolution.y * 0.3333)\n    {\n        ditherColor = GetBlueNoiseDither(grayscale, ivec2(pixelCoord) + shift);\n    } else {\n        ditherColor = GetRandomNoiseDither(grayscale, ivec2(pixelCoord) + shift);\n    }\n    //ditherColor = grayscale; //use for test without dithering\n    return ditherColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    float linearColor = 0.0;\n    if(cos(iTime * 0.5) * 0.5 + -5.5 < fragCoord.x / iResolution.x)\n    {\n        linearColor = GetPixelColor(fragCoord.xy);\n    }else\n    {\n        ivec2 offset;\n        float sumColor = 0.0f;\n        float sumWeight = 0.0f;\n        for(int x = -2; x < 2; x++)\n        {\n            for(int y = -2; y < 2; y++)\n            {\n                sumColor += GetPixelColor(fragCoord.xy + vec2(x, y));\n                sumWeight += 1.0;\n            }\n        }\n        linearColor = sumColor / sumWeight;\n    }\n    fragColor = vec4(pow(vec3(linearColor), vec3(1.0 / 2.2)), 1.0); //linear->srgb manual conversion as shadertoy does not support actual srgb\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ROUNDS 20\n#define ROTL(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n#define QUARTER_ROUND(a, b, c, d) \\\n    a += b; d ^= a; d = ROTL(d,16); \\\n    c += d; b ^= c; b = ROTL(b,12); \\\n    a += b; d ^= a; d = ROTL(d, 8); \\\n    c += d; b ^= c; b = ROTL(b, 7);\n\nfloat uintBitsToUnorm(uint b)\n{\n    return float(b) / float(~ 0u);\n}\n\nvec4 chacha(vec2 fragCoord)\n{\n    uint m11 = 0x65787061u; // \"expa\"\n    uint m12 = 0x6E642033u; // \"nd 3\"\n    uint m13 = 0x322D6279u; // \"2-by\"\n    uint m14 = 0x7465206Bu; // \"te k\n\n    uint m21 = floatBitsToUint(iResolution.x);\n    uint m22 = floatBitsToUint(iResolution.y);\n    uint m23 = floatBitsToUint(iMouse.x);\n    uint m24 = floatBitsToUint(iMouse.y);\n    \n    vec4 pre = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    uint m31 = floatBitsToUint(pre.x);\n    uint m32 = floatBitsToUint(pre.y);\n    uint m33 = floatBitsToUint(pre.z);\n    uint m34 = floatBitsToUint(pre.w);\n    \n    uint m41 = floatBitsToUint(fragCoord.x);\n    uint m42 = floatBitsToUint(fragCoord.y);\n    uint m43 = floatBitsToUint(iTime);\n    uint m44 = uint(iFrame);\n\n    for (int r = 0; r < ROUNDS; r += 2) \n    {\n        // EVEN ROUND\n        QUARTER_ROUND(m11, m12, m13, m14);\n        QUARTER_ROUND(m21, m22, m23, m24);\n        QUARTER_ROUND(m31, m32, m33, m34);\n        QUARTER_ROUND(m41, m42, m43, m44);\n        \n        // ODD ROUND\n        QUARTER_ROUND(m11, m22, m33, m44);\n        QUARTER_ROUND(m21, m32, m43, m14);\n        QUARTER_ROUND(m31, m42, m13, m24);\n        QUARTER_ROUND(m41, m12, m23, m34);\n    }\n\n    return vec4(\n        uintBitsToUnorm(m11 ^ m21 ^ m31 ^ m41),\n        uintBitsToUnorm(m12 ^ m22 ^ m32 ^ m42),\n        uintBitsToUnorm(m13 ^ m23 ^ m33 ^ m43),\n        uintBitsToUnorm(m14 ^ m24 ^ m34 ^ m44)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 10 || (abs((5 * iFrame % int(2.0 * iResolution.x)) - int(fragCoord.x)) < 10)) {\n        fragColor = chacha(fragCoord);\n    } else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getCoord(vec2 coord)\n{\n    return pow(vec4(texture(iChannel0, fract(coord / iResolution.xy)).rgb, 1.0), GAMMA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samp_sum = getCoord(fragCoord);\n    samp_sum *= MID_WEIGHT * lp_window(0.0) * lp_kernel(0.0);\n    \n    for(float d = 1.0; d < RANGE - 0.5; d += 1.0)\n    {\n        float w = lp_window(d / RANGE);\n        float k = lp_kernel(d / KERNEL);\n        \n        vec4 s1p = getCoord(fragCoord + vec2(d, 0.0));\n        vec4 s1n = getCoord(fragCoord - vec2(d, 0.0));\n        \n        samp_sum += w * k * (s1p + s1n);\n    }\n    \n    fragColor = samp_sum / samp_sum.a;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float EPS = (5.79334e-21);\nconst float PI = (3.14159265358979323);\nconst float PHI = (1.61803398875);\nconst float SQRT1 = (1.00000000000);\nconst float SQRT2 = (1.41421356237);\nconst float SQRT3 = (1.73205080757);\n\n////* SPATIAL  *////\nconst float KERNEL = 2.0;\nconst float RANGE = floor(KERNEL * 32.0);\nconst float MID_WEIGHT = 1.0;\n\nconst vec4 GAMMA = vec4(1.0);\nconst float COMP_RANGE = 64.0;\n\nfloat lp_sinc(float x) {\n    return sin(PI * x + EPS) / (PI * x + EPS);\n}\n\nfloat lp_gauss(float x) {\n    return exp(-x * x * 0.5);\n}\n\nfloat lp_flat_gauss(float x) {\n    return 0.5 * exp(-x * x) * (3.0 - 2.0 * x * x);\n}\n\nfloat lp_kernel(float x) {\n    return lp_flat_gauss(x);\n}\n\nfloat lp_window(float x) {\n    // return 1.0;\n    x = (1.0 + x) * 0.5;\n\n    return 0.35875\n         - 0.48829 * cos(2.0 * PI * x)\n         + 0.14128 * cos(4.0 * PI * x)\n         - 0.01168 * cos(6.0 * PI * x);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 getCoord(vec2 coord)\n{\n    return vec4(texture(iChannel1, fract(coord / iResolution.xy)).rgb, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samp_sum = getCoord(fragCoord);\n    samp_sum *= MID_WEIGHT * lp_window(0.0) * lp_kernel(0.0);\n    \n    for(float d = 1.0; d < RANGE - 0.5; d += 1.0)\n    {\n        float w = lp_window(d / RANGE);\n        float k = lp_kernel(d / KERNEL);\n        \n        vec4 s1p = getCoord(fragCoord + vec2(0.0, d));\n        vec4 s1n = getCoord(fragCoord - vec2(0.0, d));\n        \n        samp_sum += w * k * (s1p + s1n);\n    }\n    \n    fragColor = texture(iChannel0, fract(fragCoord / iResolution.xy));\n    fragColor -= samp_sum / samp_sum.a;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 getCoord(vec2 coord)\n{\n    return vec4(texture(iChannel0, fract(coord / iResolution.xy)).rgb, 1.0);\n}\n\n// slowest function, no way around it :/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 total = vec4(0.0);\n    vec4 center = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 2.0);\n    \n    for(float dx = 0.5; dx < iResolution.x; ++dx)\n    {\n        total += 1.0000 * sign(center - getCoord(vec2(dx, +0.0 + fragCoord.y)));\n        \n        total += 0.5000 * sign(center - getCoord(vec2(dx, +1.0 + fragCoord.y)));\n        total += 0.5000 * sign(center - getCoord(vec2(dx, -1.0 + fragCoord.y)));\n        \n        total += 0.2500 * sign(center - getCoord(vec2(dx, +2.0 + fragCoord.y)));\n        total += 0.2500 * sign(center - getCoord(vec2(dx, -2.0 + fragCoord.y)));\n        \n        // total += 0.1250 * sign(center - getCoord(vec2(dx, +3.0 + fragCoord.y)));\n        // total += 0.1250 * sign(center - getCoord(vec2(dx, -3.0 + fragCoord.y)));\n        \n        // total += 0.0625 * sign(center - getCoord(vec2(dx, +4.0 + fragCoord.y)));\n        // total += 0.0625 * sign(center - getCoord(vec2(dx, -4.0 + fragCoord.y)));\n    }\n    \n    for(float dy = 0.5; dy < iResolution.y; ++dy)\n    {\n        total += 1.0000 * sign(center - getCoord(vec2(+0.0 + fragCoord.x, dy)));\n        \n        total += 0.5000 * sign(center - getCoord(vec2(+1.0 + fragCoord.x, dy)));\n        total += 0.5000 * sign(center - getCoord(vec2(-1.0 + fragCoord.x, dy)));\n        \n        total += 0.2500 * sign(center - getCoord(vec2(+2.0 + fragCoord.x, dy)));\n        total += 0.2500 * sign(center - getCoord(vec2(-2.0 + fragCoord.x, dy)));\n        \n        // total += 0.1250 * sign(center - getCoord(vec2(+3.0 + fragCoord.x, dy)));\n        // total += 0.1250 * sign(center - getCoord(vec2(-3.0 + fragCoord.x, dy)));\n        \n        // total += 0.0625 * sign(center - getCoord(vec2(+4.0 + fragCoord.x, dy)));\n        // total += 0.0625 * sign(center - getCoord(vec2(-4.0 + fragCoord.x, dy)));\n    }\n    \n    fragColor = 0.5 + 0.5 * total / total.a;\n}","name":"Buffer D","description":"","type":"buffer"}]}