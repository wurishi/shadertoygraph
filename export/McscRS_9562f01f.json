{"ver":"0.1","info":{"id":"McscRS","date":"1721268434","viewed":66,"name":"murmur3 cell farm","username":"benhardy","description":"A demo of using murmur-3 based hashing for pseudorandomness.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","cell","twist","hashing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED = vec3(1,0,0);\n\nint murmur_32_scramble(int k) {\n    k *= 0xcc9e2d51;\n    k = (k << 15) | (k >> 17);\n    k *= 0x1b873593;\n    return k;\n}\n\n\nint murmur3_32(int x, int y, int seed)\n{\n    int h = seed ^ murmur_32_scramble(x);\n    h = (h << 13) | (h >> 19);\n    h = h * 5 + 0xe6546b64;\n    h ^= murmur_32_scramble(y);\n    h = (h << 13) | (h >> 19);\n    h = h * 5 + 0xe6546b64;\n    /* Finalize. */\n\th ^= 2;\n\th ^= h >> 16;\n\th *= 0x85ebca6b;\n\th ^= h >> 13;\n\th *= 0xc2b2ae35;\n\th ^= h >> 16;\n\treturn h;\n}\n\nvec4 distort(vec2 start, float power) {\n    float dTime = iTime + 4.5*sin(iTime*0.2);\n    vec2 centre = vec2(\n       sin(dTime*0.93) *1.5,\n       cos(dTime*0.62)\n    ) * 2.8;\n    vec2 rel = start - centre;\n    float dist = 3.0*(sin(iTime*3.91)+1.5)*length(rel) - 3.0;\n    float effect = (1.0+0.5*sin(iTime*0.1))/(1.0+pow(dist,2.0));\n    float mult = 1.0 + 0.125*(0.5+cos(dist))/(pow(dist,2.0)+1.0);\n    rel = rel * mult;\n    float len = length(rel);\n    float ang = atan(rel.y, rel.x) + effect * sin(iTime*1.2);\n    rel = vec2(cos(ang), sin(ang))*len;\n    return vec4(rel + centre, effect, 0.5);\n}\n\nvec4 distort2(vec2 start, float power) {\n  float dx = sin(start.x+iTime*1.1) + cos(start.y+iTime*1.3);\n  float dy = cos(start.x+iTime*1.7) - sin(start.y+iTime*1.9);\n  vec2 bonk = vec2(dx, dy);\n  return vec4(bonk * power + start, length(bonk*power), atan(dx,dy));\n}\n\nvec3 lerp(vec3 a, vec3 b, float x) {\n  return a + (b-a) * x;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 6.0 * (fragCoord.xy/iResolution.xy -0.5)\n      *vec2(iResolution.x/iResolution.y, 1.0);\n    float spin = 0.4 + 0.1 * sin(iTime*0.12);\n    uv = vec2(cos(spin)*uv.x + sin(spin)*uv.y,\n        -sin(spin)*uv.x + cos(spin)*uv.y);\n\n    vec4 pos = distort(uv, 2.0*sin(iTime*0.13));\n    vec2 gpos = abs(fract(pos.xy*5.0)-0.5);\n  \n    vec2 gpos_in = pos.xy*5.0-0.5;\n      gpos_in.y -= iTime;\n      vec2 gposi = gpos_in-fract(gpos_in);\n    \n    float bent = 1.0-0.5*clamp(pos.z, 0.0, 1.0);\n    float bent2 = clamp(pos.q*0.5+0.5, 0.0, 1.0);\n    float d = min(gpos.x,gpos.y) *20.0-1.0;\n    vec3 color = clamp(vec3(d), 0.0, 1.0);\n    int box = murmur3_32(int(gposi.x), int(gposi.y),\n        int(iTime*1.0)) % 7;\n    float redness = clamp(float(2-box), 0.0, 2.0) * 0.4;\n      color = lerp(color,RED,redness);\n      \n    color *= bent;\n//    color *= (1.0-clamp(float(box),0.0,1.0)) * vec3(0.0,0.0,0.7);\n    //color.y *=bent2;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}