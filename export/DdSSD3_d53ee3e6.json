{"ver":"0.1","info":{"id":"DdSSD3","date":"1670964101","viewed":71,"name":"[steve] Game of Life","username":"import_shader_steve","description":"Conway's Game of Life implementation. Getting the hang of loading & storing information in buffers.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.);\n    //color = texture(iChannel0, uv).xyz;\n    color = texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// load the texel color of a specific coordinate\nvec3 loadValue(ivec2 p) {\n    return texelFetch(iChannel0, p, 0).rgb;\n}\n\n// count the alive neighbors surrounding a specific cell\nint GetNeighbors(ivec2 p) {\n    int count = 0;\n    \n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            if (i == 0 && j == 0) continue;\n            if (loadValue(ivec2(p) + ivec2(i, j)).r > 0.5) {\n                count ++;\n            }\n        }\n    }\n    \n    return count;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.);\n    \n    //bool isAlivePast = ( loadValue(ivec2(fragCoord)).r > 0.5 || \n        //ivec2(iMouse.xy) == ivec2(fragCoord) ) ? true : false;\n    bool isAlivePast = ( loadValue(ivec2(fragCoord)).r > 0.5 )  ? true : false;\n    int count = GetNeighbors(ivec2(fragCoord));\n    \n    // decide if the cell is alive or dead in this frame,\n    // based on its status on the previous frame\n    bool isAliveNow = false;\n    if (isAlivePast && (count == 2 || count == 3)) {\n        isAliveNow = true;\n    } else if (!isAlivePast && count == 3) {\n        isAliveNow = true;\n    } else {\n        isAliveNow = false;\n    }\n    \n    if (isAliveNow) {\n        color = vec3(1.);\n    } else {\n        color = vec3(0.);\n    }\n    \n    if (iMouse.z > 0.5 && distance(iMouse.xy, fragCoord) < mouseThreshold) {\n        color = vec3(1.);\n    }\n    \n    fragColor = vec4(color, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// Multiples of 4x5 work best\nconst vec2 fontSize = vec2(4,5) * vec2(5,5);\nvec2 grid(int x, int y) {\n    return fontSize.xx * vec2(1,ceil(fontSize.y/fontSize.x)) * vec2(x,y) + vec2(2);\n}\n\n#define mouseThreshold 5.","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// load the texel color of a specific coordinate\nvec3 loadChannel0(ivec2 p) {\n    return texelFetch(iChannel0, p, 0).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = loadChannel0(ivec2(fragCoord));\n    if (iMouse.z > 0.5 && distance(iMouse.xy, fragCoord) < mouseThreshold) {\n        color = vec3(1.);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}