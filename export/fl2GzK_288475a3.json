{"ver":"0.1","info":{"id":"fl2GzK","date":"1624281764","viewed":17,"name":"Union Chamfer","username":"khalladay","description":"Trying to make the commonly found \"opUnionChamfer\" more robust","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["union","chamfer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Demonstrating some weird bits of the commonly found \"opUnionChamfer\" function\n//The original chamfer exhibits artifacts around areas that aren't perpendicular to one another\n//(for example, rotate the camera around and observe the \"point\" of the chamfer between these\n//two cubes). The union function also returns a distance that's been multiplied by sqrt(0.5), artificially\n//increasing the number of steps to trace a chamfered shape. This appears to be because the chamfer op is\n//hugely sensitive to being overshot by a ray-march. The distance-multiply would belp prevent rays from overshooting\n//the surface, although this doesn't eliminate all the artifacts, as shown here. \n\n//To address both the artifacting and the reduced trace effectiveness introduced by the multiply, you can omit the mulitply\n//all-togeher, as long as you also compute the exact surface hitpoint of a traced ray by adjusting the final sample point\n//to ensure that you're always sampling at exactly 0 distance on your shape. \n\n//By default, this shader shows my proposed \"improvement\" (it's so small it can barely be called that), to the union chamfer.\n//if you set EXACT_CHAMFER to 0, you'll switch back to the default version of this function, with the distance field debug colored\n//red in areas where the union artificially increases step count by multiplying the distance returned from opUnionChamfer. You can also\n//spin the camera around to see the artifacting on the chamfered shape. \n\n#define DETAIL_LEVEL 128\n#define PI 3.14159\n\n#define CHAMFER_SIZE 3.0\n#define EXACT_CHAMFER 1\n\n#define DEBUG_DISTANCE_FIELD 1\n#define COLOR_DEBUG_DISTANCE_FIELD_TO_SHOW_MULTIPLY_REGION 1\n\n//from https://mercury.sexy/hg_sdf/\nfloat opUnionChamfer(float a, float b, float r) \n{\n    return min(min(a,b), (a-r+b) * sqrt(0.5));\n}\n\nfloat opUnionChamferExact(float a, float b, float r)\n{\n    return min(min(a,b), (a-r+b));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 at, float height)\n{\n    float b1 = sdBox(at + vec3(3,height,0), vec3(3,3,3));\n    float b2 = sdBox(at + vec3(-3.0,height, 0), vec3(3.0,3.0,3.0));\n    \n    #if EXACT_CHAMFER\n    return opUnionChamferExact(b1,b2,CHAMFER_SIZE);\n    #else\n    return opUnionChamfer(b1,b2,CHAMFER_SIZE);\n    #endif\n}\n\nvec3 mapCol(vec3 at, float height)\n{\n    #if EXACT_CHAMFER\n    return vec3(0,0,0);\n    #elif COLOR_DEBUG_DISTANCE_FIELD_TO_SHOW_MULTIPLY_REGION\n    float b1 = sdBox(at + vec3(3,height, 0), vec3(3,3,3));\n    float b2 = sdBox(at + vec3(-3,height, 0), vec3(3.0,3.0,3.0));\n    \n    float a = min(b1,b2);\n    float b = (b1 - CHAMFER_SIZE + b2)*sqrt(0.5);\n    if (a <= b) return vec3(0,0,0);\n    else return vec3(1,0,0);\n    #else\n    return vec3(0,0,0);\n    #endif\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float height)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.00001*e, height);\n    }\n    return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseX = (-iMouse.x / iResolution.x) * 10.0;\n    \n    //xz coords for camera are a circle\n    vec3 CAM_OFFSET = 8.0 * (vec3( cos(mouseX), 0.0 , sin(mouseX) ));    \n\tvec3 CAM_UP = vec3(0.0, 1.0, 0.0);\n\tvec3 CAM_POS = vec3(0,8,0) + CAM_OFFSET;\n\tvec3 CAM_LOOKPOINT = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 lookDirection = normalize(CAM_LOOKPOINT - CAM_POS);\n\tvec3 viewPlaneU = normalize(cross(CAM_UP, lookDirection));\n\tvec3 viewPlaneV = cross(lookDirection, viewPlaneU);\n\tvec3 viewCenter = lookDirection + CAM_POS;\n\t\n    //remap uvs to -1 - +1\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\n\tvec3 fragWorldPos = viewCenter + (uv.x * viewPlaneU * iResolution.x / iResolution.y) + (uv.y * viewPlaneV);\n\tvec3 camPosToFragWorld = normalize(fragWorldPos - CAM_POS);\n\n\tconst float farClip = 50.0;\n\t\n\tvec3 col = mix(vec3(0.25), vec3(0.5,0.4,0.3), fragCoord.y/iResolution.y);\n    float h = sin(iTime) * 3.0;\n\n    float groundDist = -CAM_POS.y / camPosToFragWorld.y;\n    float debug_sd = map(CAM_POS + camPosToFragWorld*groundDist,h);\n    \n    #if DEBUG_DISTANCE_FIELD\n    if (debug_sd > 0.0)\n    {\n       col = mapCol(CAM_POS + camPosToFragWorld*groundDist,h)+vec3(0.85,0.85, 0.25) * fract(debug_sd);\n    }        \n    #endif\n    \n    float s = map(CAM_POS,h);\n    float dist = s;\n\tvec3 p = CAM_POS + camPosToFragWorld*s;\n    \n\tfor (int i = 0; i < DETAIL_LEVEL; ++i)\n    {\n        float s=map(p,h);\n        if ( s < 0.0001 )\n\t\t{\n        \n        #if EXACT_CHAMFER\n            col = abs(calcNormal(p + s * camPosToFragWorld,h));\n        #else\n            col = abs(calcNormal(p,h));\n        #endif\n            break;\n\t\t}\n        \n        dist += s;\n        \n        #if DEBUG_DISTANCE_FIELD\n        if (dist > groundDist) break;\n        #endif\n        \n        p += camPosToFragWorld*s;\n\n    }\n    \n  \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}