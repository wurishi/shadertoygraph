{"ver":"0.1","info":{"id":"MlfyRM","date":"1503999517","viewed":170,"name":"AA barycentric triangle 2","username":"etale_cohomology","description":"Fork of https://www.shadertoy.com/view/lslXDf\n\nAnother way of drawing an antialiased barycentric triangle","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","math","tutorial","triangle","mobius","antialias","barycentric","cramer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/lslXDf\n\n// An antialiased barycentric triangle!\n\n#define ANTIALIAS 4.\n\n// Does this use Cramer's rule?\nfloat sdf_triangle(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c){\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement-vector\n    vec2 dvec_ac = vec_c - vec_a;  // Displacement-vector\n    vec2 dvec_ap = vec_p - vec_a;  // Displacement-vector\n\n    float det_dvec_ab_dvec_ac = dvec_ab.x * dvec_ac.y - dvec_ac.x * dvec_ab.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ab and dvec_ac\n\tfloat det_dvec_ap_dvec_ac = dvec_ap.x * dvec_ac.y - dvec_ac.x * dvec_ap.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ap and dvec_ac\n    float det_dvec_ab_dvec_ap = dvec_ab.x * dvec_ap.y - dvec_ap.x * dvec_ab.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ab and dvec_ap\n    float inv_det_dvec_ab_dvec_ac = 1. / det_dvec_ab_dvec_ac;  // Multiplicative-inverse of a determinant\n\n    float bary_x = det_dvec_ap_dvec_ac * inv_det_dvec_ab_dvec_ac;  // Why does this work?\n    float bary_y = det_dvec_ab_dvec_ap * inv_det_dvec_ab_dvec_ac;  // Why does this work?\n    float bary_z = 1. - bary_x - bary_y;  // The last barycentric coordinate is easy!\n\n    return min(min(bary_x, bary_y), bary_z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * uv;\n\n    //vec2 mouse_uv = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    //mouse_uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * mouse_uv;\n\n    vec2 triangle_a = vec2(.0, -.8);\n    vec2 triangle_b = vec2(.8,  .0);\n    vec2 triangle_c = vec2(.0,  .8);//mouse_uv;\n    float triangle = sdf_triangle(uv, triangle_a, triangle_b, triangle_c);\n    triangle = smoothstep(0., ANTIALIAS / iResolution.y, triangle);\n\n\tfragColor.rgb = vec3(triangle);\n}\n","name":"Image","description":"","type":"image"}]}