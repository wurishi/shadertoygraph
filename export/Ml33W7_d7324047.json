{"ver":"0.1","info":{"id":"Ml33W7","date":"1470271838","viewed":210,"name":"2D Dist Func (triangle, rect)","username":"vug","description":"Distance functions for line, triangle and rectangle.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n Inspired by https://www.shadertoy.com/view/ltBGzK \"2D Distance Field Visualization\"\n Here I tried have\n 1) a distance field that can tell inside from outside (e.g. to fill the inside of the shape)\n 2) where the isolines are scaled versions of each other (e.g. no curves at the corners)\n 3) a distance function for triangle\n */\n\n\nfloat rectDist(vec2 p, vec2 dim) {\n    //return length(max(abs(p) - dim, 0.0));\n    //\n    //return abs(p).x - dim.x*0.5;\n    //return abs(p).y - dim.y*0.5;\n    //return max(p.x, p.y);\n    //return max(p.x - dim.x*0.5, p.y - dim.y*0.5);\n    //\n    return max(abs(p).x - dim.x*0.5, abs(p).y - dim.y*0.5);\n}\n\nfloat lineDist(vec2 p, vec2 x, vec2 y) {\n    vec2 v_xy = y - x;\n    vec2 v_xp = p - x;\n    vec2 u_xy = normalize(v_xy);\n    float proj = dot(v_xp, u_xy);\n    vec2 v_xz = u_xy * proj;\n    vec2 v_zp = v_xp - v_xz;\n    //return length(v_zp); // * sign( cross(vec3(v_xz, 0.0), vec3(v_xp, 0.0)).z );\n    return length(v_zp) * sign( cross(vec3(v_xz, 0.0), vec3(v_xp, 0.0)).z ) * -sign(dot(v_xp, u_xy));\n}\n\nfloat triangleDist(vec2 p, vec2 a, vec2 b, vec2 c) {\n    float d_ab = lineDist(p, a, b);\n    float d_bc = lineDist(p, b, c);\n    float d_ca = lineDist(p, c, a);\n    return max(max(d_ab, d_bc), d_ca);\n}\n\nfloat unionOp(in float d1, in float d2 ) { return min(d1,d2); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy - 0.5*iResolution.xy) / iResolution.yy;\n    float t = iTime;\n    \n    float dist1 = rectDist(uv - vec2(0.5, 0.1), vec2(1.0+0.5*sin(t+0.1), 0.3+0.2*cos(t+0.5)));\n    float dist2 = lineDist(uv, vec2(-0.9+sin(t), 0.0), vec2(-0.7, 0.8));\n    float dist3 = triangleDist(uv, vec2(-0.1, -0.1), vec2(1.2+0.5*sin(t+0.7), 0.5+sin(t+1.1)), vec2(0.3, 0.9));\n    float dist = unionOp(unionOp(dist1, dist2), dist3);\n    \n    float thickness = 0.01;\n    float zero = 1.0 - smoothstep(thickness, thickness+0.003, abs(dist));  // shape borders, where distance field is zero.\n    \n    float h = dist;\n    h = tanh(6.0*dist); // emphasize color\n    vec3 color1 = (h > 0.0) ? vec3(h,0.0,0.0) : vec3(0.0,0.0,-h); // red if positive, blue if negative\n    \n    float mod_of_dist = mod(dist, 0.06); // thin lines\n    float zero_of_mod_dist = 1.0 - smoothstep(0.006, .007, abs(mod_of_dist));\n    vec3 color2 = vec3(zero_of_mod_dist);\n     \n\tfragColor = vec4((color1 + color2)*clamp(sin(t*0.7)*2.+0.1, 0.0, 1.0) + zero, 1.0);\n}","name":"Image","description":"","type":"image"}]}