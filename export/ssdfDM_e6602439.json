{"ver":"0.1","info":{"id":"ssdfDM","date":"1656755180","viewed":79,"name":"WEREM: SoftShadows","username":"weremsoft","description":"just trying some soft shadows based on the article https://iquilezles.org/articles/rmshadows/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["softsadowsraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST .01\n\n\nfloat getDist2Box(vec3 p, vec3 size)\n{\n    return length(max(abs(p)-size, 0.));\n}\n\nfloat getDist2Sphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat getDistance(vec3 p)\n{\n    // distance to sphere\n    vec3 sphere = vec3(1., 1., 5.);\n    float ds = getDist2Sphere(p - sphere, 1.);\n\n    float boxDistance = getDist2Box(p-vec3(-1.5,.75, 5.5), vec3(.75));\n\n    return min(min(ds, p.y), boxDistance);\n}\n\n// Stable softshadow function from https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getDistance(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.);\n    \n    float d = getDistance(p);\n    \n    vec3 n = d - vec3(\n        getDistance(p - e.xyy), \n        getDistance(p - e.yxy),\n        getDistance(p - e.yyx));    \n    \n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    \n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dl = getDistance(ro + rd * dO);\n        dO += dl;\n        if(dl < MIN_DIST || dO > MAX_DIST) break;\n    }\n\n    return dO;\n}\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPosition = vec3(-1., 5., 6.);\n    \n    float lightMoveRadius = 7.;\n    \n    lightPosition.x = sin(iTime) * lightMoveRadius;\n    lightPosition.z = cos(iTime) * lightMoveRadius;\n    \n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    vec3 n = getNormal(p);\n    \n    float angleNormLight = dot(lightDirection, n);\n    \n    float distanceToLight = rayMarch(p + n * .1, lightDirection);\n    \n    float shadow = softshadow(p, lightDirection, 0.01, 100., 8.);\n    \n    return angleNormLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0., 1., 0);\n\n    vec3 rd = normalize(vec3(uv, 1.));\n\n    vec3 p = ro + rd * rayMarch(ro, rd);\n    \n    \n    vec3 col = vec3(getLight(p));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}