{"ver":"0.1","info":{"id":"4d3fzN","date":"1524268500","viewed":17912,"name":"Candy Tunnel","username":"shau","description":"Colourful tunnel","likes":41,"published":1,"flags":32,"usePreview":1,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define T iTime\n#define FAR 50.0\n#define EPS 0.05\n#define HASHSCALE1 .1031\n\n#define CA vec3(0.5, 0.5, 0.5)\n#define CB vec3(0.5, 0.5, 0.5)\n#define CC vec3(1.0, 1.0, 1.0)\n#define CD vec3(0.0, 0.33, 0.67)\n\n#define CT T / 14.0\n\nstruct CubeIntersection {\n    float tN;\n    float tF;\n    vec3 nN;\n    vec3 nF;\n    vec3 col;\n};\n\nstruct Cubes {\n    CubeIntersection near;\n    CubeIntersection mid;\n    CubeIntersection far;\n}; \n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {return a + b * cos(6.28318 * (c * t + d));}\nvec3 glowColour() {return palette(T * 0.1, CA, CB, CC, CD);}\nfloat atten(float nft) {return 1.0 / (1.0 + nft * nft * 2.0);}\n\n//Dave Hoskins - hash without sine\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 path(float t) {\n    float a = sin(t * PI / 16.0 + 1.7);\n    float b = cos(t * PI / 16.0);\n    return vec3(a * 2.0, b * a, t);    \n}   \n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat fbm(vec3 x) {\n    float r = 0.0;\n    float w = 1.0;\n    float s = 1.0;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\n//Eiffie\nfloat sdHelix(vec3 rp, float r) {\n    \n    rp.xy += path(rp.z).xy * 1.1;\n    rp.xy *= rot(r);\n\n    float d = 2.0;\n    float halfd = d * 0.5;\n    \n    float a = atan(rp.y, rp.x) * halfd;\n    float b = mod(rp.z, PI * d) - PI * halfd;\n    a = abs(a - b);\n    if (a > PI * halfd) a = PI * d - a;\n    return length(vec2(length(rp.xy) - 4.4, a)) - 1.0;\n}\n\nfloat map(vec3 rp) {\n    return sdHelix(rp, 0.4 * T);     \n}\n\n//IQ - Box functions\n// https://iquilezles.org/articles/boxfunctions\nCubeIntersection cubeIntersection(vec3 ro, vec3 rd, vec3 boxSize, float r1, float r2) {\n    \n    ro.zy *= rot(r1);\n    rd.zy *= rot(r1);\n    ro.xz *= rot(r2);\n    rd.xz *= rot(r2);\n\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    //miss\n    if (tN > tF || tF < 0.0) return CubeIntersection(0.0, 0.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\n    vec3 nN = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    vec3 nF = -sign(rd) * step(t2.xyz, t2.yzx) * step(t2.xyz, t2.zxy); \n\n    nN.zy *= rot(-r1); \n    nF.zy *= rot(-r1); \n    nN.xz *= rot(-r2); \n    nF.xz *= rot(-r2); \n    \n    return CubeIntersection(tN, tF, nN, nF, vec3(0.0));\n}  \n\nfloat boxDensity(vec3 wro, vec3 wrd, vec3 r, float dbuffer, float r1, float r2) {\n    \n    wro.zy *= rot(r1);\n    wrd.zy *= rot(r1);\n    wro.xz *= rot(r2);\n    wrd.xz *= rot(r2);    \n    \n    vec3 d = (vec4(wrd,0.0)).xyz;\n\tvec3 o = (vec4(wro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/d;\n    vec3 n = m*o;\n    vec3 k = abs(m)*r;\n    vec3 ta = -n - k;\n    vec3 tb = -n + k;\n\tfloat tN = max( max( ta.x, ta.y ), ta.z );\n\tfloat tF = min( min( tb.x, tb.y ), tb.z );\n\tif( tN > tF || tF < 0.0) return 0.0;\n\n    // not visible (behind camera or behind dbuffer)\n    if( tF<0.0 || tN>dbuffer ) return 0.0;\n\n    // clip integration segment from camera to dbuffer\n    tN = max( tN, 0.0 );\n    tF = min( tF, dbuffer );\n    \n    // move ray to the intersection point\n    o += tN*d; tF=tF-tN; tN=0.0;\n\n    // density calculation. density is of the form\n    //\n    // d(x,y,z) = [1-(x/rx)^2] * [1-(y/ry)^2] * [1-(z/rz)^2];\n    //\n    // this can be analytically integrable (it's a degree 6 polynomial):\n    \n    vec3 a = 1.0 -     (o*o)/(r*r);\n    vec3 b =     - 2.0*(o*d)/(r*r);\n    vec3 c =     -     (d*d)/(r*r);\n    \n    float t1 = tF;\n    float t2 = t1*t1;\n    float t3 = t2*t1;\n    float t4 = t2*t2;\n    float t5 = t2*t3;\n    float t6 = t3*t3;\n    float t7 = t3*t4;\n\n    float f = (t1/1.0) *(a.x*a.y*a.z) + \n              (t2/2.0) *(a.x*a.y*b.z + a.x*b.y*a.z + b.x*a.y*a.z) + \n              (t3/3.0) *(a.x*a.y*c.z + a.x*b.y*b.z + a.x*c.y*a.z + b.x*a.y*b.z + b.x*b.y*a.z + c.x*a.y*a.z) +\n              (t4/4.0) *(a.x*b.y*c.z + a.x*c.y*b.z + b.x*a.y*c.z + b.x*b.y*b.z + b.x*c.y*a.z + c.x*a.y*b.z + c.x*b.y*a.z) + \n              (t5/5.0) *(a.x*c.y*c.z + b.x*b.y*c.z + b.x*c.y*b.z + c.x*a.y*c.z + c.x*b.y*b.z + c.x*c.y*a.z) + \n              (t6/6.0) *(b.x*c.y*c.z + c.x*b.y*c.z + c.x*c.y*b.z) + \n              (t7/7.0) *(c.x*c.y*c.z);\n      \n    return f;   \n}\n    \n//modified from IQs voxel marching\nCubes drawCubes(vec3 ro, vec3 rd) {\n\n    CubeIntersection near = CubeIntersection(0.0, 0.0, vec3(0.0), vec3(0.0), vec3(0.0));\n    CubeIntersection mid = CubeIntersection(0.0, 0.0, vec3(0.0), vec3(0.0), vec3(0.0));\n    CubeIntersection far = CubeIntersection(0.0, 0.0, vec3(0.0), vec3(0.0), vec3(0.0));\n    \n    vec4 sound = texture(iChannel0, vec2(0.5) / iResolution.xy);\n    \n    float nHits = 0.0;\n\n    vec3 pos = floor(ro);\n    vec3 ri = 1.0 / rd;\n    vec3 rs = sign(rd);\n    vec3 dis = (pos - ro + 0.5 + rs * 0.5) * ri;\n\n    vec3 mm = vec3(0.0);\n    for (int i = 0; i < 128; i++) {\n        \n        float r = hash13(pos);\n        float r1 = r + T + pos.z;\n        float r2 = r1 * 2.0 + pos.y;\n        vec3 col = palette(r * 1.6, CA * sound.x * 0.4, CB * sound.z * 0.5, CC * sound.y * 0.5, CD) * sound.w * 1.6;\n\n        if (map(pos) < EPS) {\n            \n            vec3 cube = vec3(clamp(r * 0.5, 0.1, 0.3));\n            CubeIntersection ci = cubeIntersection(ro - (pos + vec3(0.5)), rd, cube, r1, r2);\n            col *= boxDensity(ro - (pos + vec3(0.5)), rd, cube, FAR, r1, r2);\n\n            if (ci.tN > 0.0) {\n\n                if (nHits == 0.0) {\n                \n                    near.tN = ci.tN;\n                    near.tF = ci.tF;\n                    near.nN = ci.nN;\n                    near.nF = ci.nF;\n                    near.col = col;\n                    \n                } else if (nHits == 1.0) {\n                    \n                    mid.tN = ci.tN;\n                    mid.tF = ci.tF;\n                    mid.nN = ci.nN;\n                    mid.nF = ci.nF;\n                    mid.col = col;\n\n                } else if (nHits == 2.0) {\n                    \n                    far.tN = ci.tN;\n                    far.tF = ci.tF;\n                    far.nN = ci.nN;\n                    far.nF = ci.nF;\n                    far.col = col;\n                }\n               \n                nHits += 1.0;\n                if (nHits > 2.0) break;\n            }\n        }\n        \n        mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n        dis += mm * rs * ri;\n        pos += mm * rs;\n    }\n            \n    return Cubes(near, mid, far);\n}\n\n//Moody clouds from Patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) {\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(CT, 0.0), CT)) * 1.5;\n    return clamp(pow(vec3(nz), vec3(4.0)) * rd.y, 0.0, 1.0);\n}\n\nvec4 colourSurface(vec3 ro, vec3 rd, CubeIntersection cube) {\n\n    vec4 pc = vec4(0.0);\n    \n    vec3 lp = vec3(0.0, 0.0, T * 4.0);\n    lp.xy -= path(lp.z).xy;\n\n    //near face\n    vec3 rp = ro + rd * cube.tN;  \n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    float ltatten = 1.0 / (1.0 + lt * lt * 0.005);\n    \n    float spec = pow(max(dot(reflect(-ld, cube.nN), -rd), 0.0), 32.0) * ltatten;\n    float fres = pow(clamp(dot(cube.nN, rd) + 1.0, 0.0, 1.0), 64.0) * ltatten;\n    pc.xyz += clouds(reflect(rd, cube.nN)) * glowColour() * fres;\n    pc.xyz += vec3(1.0) * spec;\n    \n    float nft = cube.tF - cube.tN;\n    \n    //glow\n    pc.xyz += cube.col * 2.0 * ltatten;\n    \n    //far face\n    rp = ro + rd * cube.tF;  \n    ld = normalize(lp - rp);\n    lt = length(lp - rp);\n    ltatten = 1.0 / (1.0 + lt * lt * 0.005);\n\n    spec = pow(max(dot(reflect(-ld, cube.nF), -rd), 0.0), 32.0) * ltatten;\n    fres = pow(clamp(dot(cube.nF, rd) + 1.0, 0.0, 1.0), 64.0) * ltatten;\n    pc.xyz += clouds(reflect(rd, cube.nF)) * glowColour() * fres * atten(nft) * 0.6;\n    pc.xyz += vec3(1.0) * spec * atten(nft) * 0.6;\n\n    return pc;\n}\n\nvec3 colourScene(vec3 ro, vec3 rd, Cubes cubes) {\n    \n    vec3 bgc = clouds(rd) * glowColour(); \n    vec3 pc = bgc;\n    \n    if (cubes.near.tN > 0.0) {\n        \n        vec4 nc = colourSurface(ro, rd, cubes.near);    \n        pc = nc.xyz;\n    \n        if (cubes.mid.tN > 0.0) {\n            \n            vec4 mc = colourSurface(ro, rd, cubes.mid);\n            pc += mc.xyz * atten(nc.w) * 0.3;\n        \n            if (cubes.far.tN > 0.0) {\n                \n                vec4 fc = colourSurface(ro, rd, cubes.far);\n                pc += fc.xyz * atten(nc.w + mc.w) * 0.1;\n            \n            } else {\n                pc += bgc * atten(nc.w + mc.w) * 0.1;\n            }\n\n        } else {\n            pc += bgc * atten(nc.w) * 0.3;\n        }\n    }\n    \n    return pc;\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, T * 4.0);\n    ro = lookAt + vec3(0.0, 0.0, -1.0);\n    \n    lookAt.xy -= path(lookAt.z).xy * 1.1;\n    ro.xy -= path(ro.z).xy * 1.1;\n    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    Cubes cubes = drawCubes(ro, rd);\n    //fragColor = vec4(sqrt(clamp(colourScene(ro, rd, cubes), 0.0, 1.0)), 1.0);\n    fragColor = vec4(colourScene(ro, rd, cubes), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 currentSound = texture(iChannel0, uv / iResolution.xy);\n    \n    float level = currentSound.x;\n    float bass = currentSound.y;\n    float mid = currentSound.z;\n    float treble = currentSound.w;\n    \n    for (int x = 0; x < 512; x++) {\n        vec4 newSound = texelFetch(iChannel1, ivec2(x , 0), 0);\n        level += newSound.x;\n        if (x < 140) bass += newSound.x;\n        if (x > 139 && x < 300) mid += newSound.x;\n        if (x > 299) treble += newSound.x;\n    }\n    \n    level /= 60.0;\n    bass /= 60.0;\n    mid /= 20.0;\n    treble /= 36.0;\n    \n    fragColor = vec4(level, bass, mid, treble);    \n}","name":"Buf A","description":"","type":"buffer"}]}