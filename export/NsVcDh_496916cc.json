{"ver":"0.1","info":{"id":"NsVcDh","date":"1654783310","viewed":65,"name":"RayTracer03","username":"alanza","description":"a third attempt at raytracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"sdGcWh","parentname":"RayTracer02"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 center;\n    vec3 color;\n    float radius;\n    float eta;\n};\n\nstruct Tri {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 color;\n};\n\nTri triangles [5];\n\nvec3 normalToPlane(in vec3 a, in vec3 b, in vec3 c) {\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    return cross(ab, ac);\n}\n\nstruct Light {\n    vec3 position;\n    float intensity;\n};\n\nLight lights [3];\n\nvec3 toLight(vec3 position, Light light) {\n    return light.intensity*(light.position - position)/dot(light.position - position, light.position - position);\n}\n\nstruct Ray {\n    vec3 point;\n    vec3 direction;\n};\n\nfloat solveQuadratic(in float a, in float b, in float c) {\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0 || a == 0.0) {\n    // no real roots, return garbage\n        return 696969.0;\n    }\n    else {\n        float root = sqrt(discriminant);\n        return 0.5*(-b + root)/a;\n        }\n        // both roots negative, return garbage\n        // else return 696969.0;\n}\n\n// assumes ray.direction is a unit vector\nfloat intersectSphere(in Ray ray, in Sphere sphere) {\n    float b = 2.0*dot(ray.point - sphere.center, ray.direction);\n    float c = dot(ray.point - sphere.center, ray.point - sphere.center) - sphere.radius*sphere.radius;\n    return solveQuadratic(1.0, b, c);\n}\n\nfloat intersectFloor(in Ray ray) {\n    if (ray.direction.y == 0.0) {\n        return 696969.0;\n    } else {\n    return (-1.0 - ray.point.y)/ray.direction.y;\n    }\n}\n\nfloat intersectPlane(in Tri tri, in Ray ray) {\n    float scale = dot(ray.direction, normalToPlane(tri.a, tri.b, tri.c));\n    // parallel to the plane; return garbage\n    if (scale == 0.0) return 696969.0;\n    else return dot(tri.a - ray.point, normalToPlane(tri.a, tri.b, tri.c))/scale;\n}\n\nfloat angle(in vec3 center, in vec3 a, in vec3 b) {\n    return acos(dot(a - center, b - center)/(length(a - center)*length(b - center)));\n}\n\n\nfloat intersectTriangle(in float dist, in Tri tri, in Ray ray) {\n    if (dist == 696969.0) return 696969.0;\n    else {\n        vec3 hit = ray.point + dist*ray.direction;\n        if (angle(tri.a, hit, tri.b) < angle(tri.a, tri.c, tri.b) \n            && angle(tri.b, hit, tri.c) < angle(tri.b, tri.a, tri.c)\n            && angle(tri.c, hit, tri.a) < angle(tri.c, tri.b, tri.a)) {\n            return dist;\n        } else return 696969.0;\n    }\n}\n        \n\nstruct rayTraceData {\n    Ray ray;\n    vec3 color;\n};\n\nrayTraceData rayTrace(in Ray ray) {\n    int min = 0;\n    float dist = 696969.0;\n    for (int i = 0; i < triangles.length(); i++) {\n        float try = intersectTriangle(intersectPlane(triangles[i], ray),triangles[i], ray);\n        if (try < dist) {\n            dist = try;\n            min = i;\n        }\n    }\n    if (dist == 696969.0) {\n            return rayTraceData(ray, vec3(0,0,0));\n    }\n    // the first hit is at distance dist along ray.direction\n    vec3 hit = ray.point + dist*ray.direction;\n    \n    vec3 normal = normalToPlane(triangles[min].a, triangles[min].b, triangles[min].c);\n    // bounce off the triangle\n    Ray new = Ray(hit, normalize(reflect(ray.direction, normal)));\n    vec3 col = vec3(0,0,0);\n    for (int i = 0; i < lights.length(); i++) {\n        float shade = dot(toLight(new.point, lights[i]), new.direction);\n        if (shade > 0.0) {\n            col = col + shade*shade*triangles[min].color;\n        }\n    }\n    return rayTraceData(new, col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec3 camera = vec3(0,0,0);\n    Ray ray = Ray(camera,normalize(vec3(uv,0.5)));\n    \n    vec3 i = vec3(1,0,4);\n    vec3 j = vec3(-1,0,4);\n    vec3 k = vec3(0,-1,4);\n    vec3 l = vec3(1,1,6);\n    \n    float vary = 0.5 + 0.5*cos(iTime);\n    \n    triangles[0] = Tri(i,j,k, vary + normalize(i));\n    triangles[1] = Tri(i,j,l, vary + normalize(j));\n    triangles[2] = Tri(i,k,l, vary + normalize(k));\n    triangles[3] = Tri(j,k,l, vary + normalize(l));\n    triangles[4] = Tri(vec3(0,-2,20),vec3(-23,-2,3),vec3(23,-2,3),vary + normalize(vec3(2,-2,0)));\n    \n    \n    lights[0] = Light(vec3(0,4,-4),2.0);\n    lights[1] = Light(vec3(-3,4,2),8.0);\n    lights[2] = Light(vec3(2,2,1),3.0);\n    \n    vec3 col;\n    for (int i = 0; i < 1; i++) {\n        rayTraceData data = rayTrace(ray);\n            col = col + data.color;\n        ray = data.ray;\n    }\n    \n    /* if (abs(uv.x) <= 0.2 || abs(uv.y) <= 0.2) {\n        col = vec3(1,0,0);\n    } */\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}