{"ver":"0.1","info":{"id":"XtlSR2","date":"1438071971","viewed":281,"name":"ShaderPus","username":"chronokun","description":"2d octopus created with signed distance function bezier tentacles","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","beziers","badfps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float sBezier(vec2 p, vec2 cp0, vec2 cp1, vec2 cp2, vec2 cp3, float u, float r)\n{\n\tvec4 a;\n\tvec4 b;\n\n\ta[3] = (cp3.x + (3.0 * (cp1.x - cp2.x)) - cp0.x) / 8.0;\n\ta[2] = (3.0 * (cp3.x - cp2.x - cp1.x + cp0.x)) / 8.0;\n\ta[1] = ((cp3.x - cp0.x) / 2.0) - a[3];\n\ta[0] = ((cp3.x + cp0.x) / 2.0) - a[2];\n\n\tb[3] = (cp3.y + (3.0 * (cp1.y - cp2.y)) - cp0.y) / 8.0;\n\tb[2] = (3.0 * (cp3.y - cp2.y - cp1.y + cp0.y)) / 8.0;\n\tb[1] = ((cp3.y - cp0.y) / 2.0) - b[3];\n\tb[0] = ((cp3.y + cp0.y) / 2.0) - b[2];\n\n\tfloat x = a[3]*(u*u*u) + a[2]*(u*u) + a[1]*u + a[0];\n\tfloat y = b[3]*(u*u*u) + b[2]*(u*u) + b[1]*u + b[0];\n\n\tfloat s = sqrt(pow((x - p.x), 2.0) + pow((y - p.y), 2.0)) - (r*(1.0-u));\n\n\treturn(s);\n}\n\nfloat opS(float fD1, float fD2)\n{\n\treturn(max(-fD1, fD2));\n}\n\nfloat opI(float fD1, float fD2)\n{\n\treturn(max(fD1, fD2));\n}\n\nfloat opU(float fD1, float fD2)\n{\n\treturn(min(fD1, fD2));\n}\n\nfloat sTentacle(vec2 pc, vec2 cpts[4])\n{\n\tfloat fR = 0.02;\n\tfloat fD = 4.0;\n\tfloat fStep = 1.0;\n\tfloat fU = -1.0;\n\tfor(int i = 0; i < 16; ++i)\n\t{\n\t\tfloat fDTempA = sBezier(pc, cpts[0], cpts[1], cpts[2], cpts[3], fU+fStep, fR);\n\t\tfloat fDTempB = sBezier(pc, cpts[0], cpts[1], cpts[2], cpts[3], fU-fStep, fR);\n\t\tif(fDTempA < fD)\n\t\t{\n\t\t\tfU += fStep;\n\t\t}\n\t\telse if(fDTempB < fD)\n\t\t{\n\t\t\tfU -= fStep;\n\t\t}\n\n\n\t\tfD = sBezier(pc, cpts[0], cpts[1], cpts[2], cpts[3], fU, fR);\n\t\tfStep /= 2.0;\n\t}\n\n\treturn(fD);\n}\n\nvec3 shaderPus(vec2 pc)\n{\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tfloat wiggle[7];\n\tfor(int i = 0; i < 7; ++i)\n\t{\n\t\twiggle[i] = sin((float(i+1)*iTime) / 4.0);\n\t}\n    \n    vec2 cpts0[4];\n    vec2 cpts1[4];\n    vec2 cpts2[4];\n    vec2 cpts3[4];\n    vec2 cpts4[4];\n    vec2 cpts5[4];\n\tvec2 cpts6[4];\n\tvec2 cpts7[4];\n\n\n\tcpts0[0] = vec2(-0.75, 0.72);\n\tcpts0[1] = vec2(0.0+(wiggle[2]*-0.25), 0.75+(wiggle[2]*-0.25));\n\tcpts0[2] = vec2(0.0+(wiggle[3]*-0.3), -0.75);\n\tcpts0[3] = vec2(0.75, -0.75+(wiggle[0]*0.25));\n\t//\n\tcpts1[0] = vec2(-0.75, 0.75);\n\tcpts1[1] = vec2(0.0+(wiggle[2]*-0.25), 0.85+(wiggle[2]*-0.25));\n\tcpts1[2] = vec2(0.0+wiggle[3], -0.45);\n\tcpts1[3] = vec2(0.75, -0.65+(wiggle[0]*-0.25));\n\t//\n\tcpts2[0] = vec2(-0.75, 0.75);\n\tcpts2[1] = vec2(-0.25+(wiggle[6]*-0.25), 0.55+(wiggle[5]*-0.125));\n\tcpts2[2] = vec2(0.0+(wiggle[4]*0.3), -0.95);\n\tcpts2[3] = vec2(0.65, -0.55+(wiggle[1]*0.25));\n\t//\n\tcpts3[0] = vec2(-0.75, 0.82);\n\tcpts3[1] = vec2(-0.15+(wiggle[1]*0.5), 0.65+(wiggle[3]*-0.125));\n\tcpts3[2] = vec2(0.4+(wiggle[3]*0.2), -0.25);\n\tcpts3[3] = vec2(0.95, -0.35+(wiggle[1]*-0.25));\n\t//\n\tcpts4[0] = vec2(-0.75, 0.52);\n\tcpts4[1] = vec2(0.35+(wiggle[1]*-0.65), 0.33+(wiggle[2]*-0.25));\n\tcpts4[2] = vec2(0.4+(wiggle[2]*0.2), -0.25+(wiggle[4]*-0.25));\n\tcpts4[3] = vec2(0.75, -0.85+(wiggle[2]*0.25));\n\t//\n\tcpts5[0] = vec2(-0.75, 0.62);\n\tcpts5[1] = vec2(0.35+(wiggle[6]*-0.25), 0.35+(wiggle[2]*-0.65));\n\tcpts5[2] = vec2(0.4, -0.25+(wiggle[3]*-0.25));\n\tcpts5[3] = vec2(0.75, 0.25+(wiggle[2]*-0.25));\n\t//\n\tcpts6[0] = vec2(-0.75, 0.54);\n\tcpts6[1] = vec2(-0.52+(wiggle[2]*-0.25), 0.2+(wiggle[2]*-0.25));\n\tcpts6[2] = vec2(0.0+(wiggle[2]*0.25), 0.0+(wiggle[2]*-0.25));\n\tcpts6[3] = vec2(0.75+(wiggle[1]*-0.75), -0.85+(wiggle[3]*0.25));\n\t//\n\tcpts7[0] = vec2(-0.77, 0.55);\n\tcpts7[1] = vec2(0.0+(wiggle[5]*0.25), 0.0+(wiggle[1]*-0.55));\n\tcpts7[2] = vec2(-0.25+(wiggle[2]*0.25), -0.5+(wiggle[0]*-0.125));\n\tcpts7[3] = vec2(-0.55+(wiggle[1]*-0.35), -0.95+(wiggle[3]*-0.25));\n\n\tfloat fD = 100.0;\n\n\tfD = min(fD, sTentacle(pc, cpts0));\n    fD = min(fD, sTentacle(pc, cpts1));\n    fD = min(fD, sTentacle(pc, cpts2));\n    fD = min(fD, sTentacle(pc, cpts3));\n    fD = min(fD, sTentacle(pc, cpts4));\n    fD = min(fD, sTentacle(pc, cpts5));\n    fD = min(fD, sTentacle(pc, cpts6));\n    fD = min(fD, sTentacle(pc, cpts7));\n\n\tfD = min(length(pc - vec2(-0.65, 0.65))-0.25, fD);\n\n\tfloat fD2 = 4.0;\n\t\n\tfD2 = opS(length(pc - vec2(-0.57+(wiggle[2]*-0.25), 0.65+(wiggle[2]*-0.25)))-0.0625, fD2);\n\tfD2 = opS(length(pc - vec2(-0.77+(wiggle[1]*0.25), 0.65+(wiggle[3]*0.25)))-0.0625, fD2);\n\tfD2 = opU(length(pc - vec2(-0.79+(wiggle[2]*-0.0625), 0.65+(wiggle[4]*-0.0625)))-0.0225, fD2);\n\tfD2 = opU(length(pc - vec2(-0.59+(wiggle[3]*-0.0625), 0.65+(wiggle[5]*-0.0625)))-0.0225, fD2);\n\n\tfloat fDPX = fD * iResolution.x;\n\tfDPX = min(fDPX, sqrt(2.0));\n\tfDPX = max(fDPX, 0.0);\n\n\tfloat fDPX2 = fD2 * iResolution.x;\n\tfDPX2 = min(fDPX2, sqrt(2.0));\n\tfDPX2 = max(fDPX2, 0.0);\n    \n    float fDPX3 = (fD2+0.01) * iResolution.x;\n\tfDPX3 = min(fDPX3, sqrt(2.0));\n\tfDPX3 = max(fDPX3, 0.0);\n\t\n\tfloat fT = (fDPX/sqrt(2.0));\n\n\tfloat fC = mix(1.0, 0.0, fT);\n\n\tfC = max(0.0, fC);\n\tfC = min(1.0, fC);\n\n\tfloat fT2 = (fDPX2/sqrt(2.0));\n    float fT3 = (fDPX3/sqrt(2.0));\n\n\tfloat fC2 = mix(1.0, 0.0, fT2);\n\n\tfC2 = max(0.0, fC2);\n\tfC2 = min(1.0, fC2);\n    \n    float fC3 = mix(1.0, 0.0, fT3);\n    fC3 = max(0.0, fC3);\n\tfC3 = min(1.0, fC3);\n\n\tcolor = mix(vec3(0.0, 0.75*pc.y, 0.85), vec3((2.0/3.0)*(-pc.x+1.0), 0.0, 1.0), fC);\n\tcolor = mix(color, vec3(1.0, 1.0, 0.5), fC2);\n    color = mix(color, vec3(0.0, 0.0, 0.0), fC3);\n    return(color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 c = shaderPus((uv*2.0)-vec2(1.0, 1.0));\n    \n\tfragColor = vec4(c,1.0);\n}","name":"","description":"","type":"image"}]}