{"ver":"0.1","info":{"id":"MdfcRr","date":"1486685303","viewed":396,"name":"Kleinian Orbit","username":"utak3r","description":"Kleinian group using an algorithm of Jos Leys and coloured with orbit traps.\nFor more info check this thread on Fractal Forums:\nhttp://www.fractalforums.com/3d-fractal-generation/an-escape-tim-algorithm-for-kleinian-group-limit-sets/","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","fractal","kleinian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Kleinian group using an algorithm of Jos Leys and coloured with orbit traps.\n// For more info check this thread on Fractal Forums:\n// http://www.fractalforums.com/3d-fractal-generation/an-escape-tim-algorithm-for-kleinian-group-limit-sets/\n// and read this paper from Jos:\n// http://www.josleys.com/articles/Kleinian%20escape-time_3.pdf\n\n#define MAXITER 64\n#define PLAY_ZOOM\n\nfloat box_size_x = 0.92;\n\nfloat wrap(float x, float a, float s)\n\t{\n\tx -= s; \n\treturn (x-a*floor(x/a)) + s;\n\t}\n\nvoid TransA(inout vec2 z, float a, float b)\n\t{\n\tfloat iR = 1. / dot(z,z);\n\tz *= -iR;\n\tz.x = -b - z.x; \n\tz.y = a + z.y; \n\t}\n\nvec4  JosKleinian(vec2 z)\n\t{\n\tfloat time = iTime * 0.2;\n\tfloat PIH = 1.570797;\n#ifdef PLAY_ZOOM\n\tfloat zoommin = 1.0;\n\tfloat zoommax = 30.0;\n\tfloat zoom = (sin(time - PIH) + 1.0) / 2.0 * (zoommax - zoommin) + zoommin;\n\t//vec2 zoomcenter = vec2((sin(time - PIH) - 0.65) * 0.2, (sin(time - PIH) + 0.95) * 0.5);\n\tvec2 zoomcenter = vec2(-0.2, 0.5);\n#else\n\tfloat zoom = 2.8;\n\tvec2 zoomcenter = vec2(-1.0, 1.75);\n#endif\n\n\tz /= zoom;\n\tz += zoomcenter;\n\n\tvec2 lz=z+vec2(1.), llz=z+vec2(-1.);\n    float flag=0.;\n\tfloat KleinR = 1.8462756+(1.958591-1.8462756)*0.5+0.5*(1.958591-1.8462756)*sin(-iTime*0.2);  \n\tfloat KleinI = 0.09627581+(0.0112786-0.09627581)*0.5+0.5*(0.0112786-0.09627581)*sin(-iTime*0.2);\n\t//float KleinR = 1.902;\n\t//float KleinI = 0.042;\n      \n\tfloat a = KleinR;\n    float b = KleinI;\n\tfloat f = sign(b)*1.;\n\tvec4 dmin = vec4(1e20);\n\tfor (int i = 0; i < MAXITER; i++) \n\t\t{\n\t\tz.x = z.x + f*b/a*z.y;\n\t\tz.x = wrap(z.x, 2. * box_size_x, - box_size_x);\n\t\tz.x = z.x - f*b/a*z.y;\n\n\t\t//If above the separation line, rotate by 180° about (-b/2, a/2)\n        if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5))))\n\t\t\t{\n\t\t\tz = vec2(-b, a) - z;\n\t\t\t}\n\n\t\t//Apply transformation a\n\t\tTransA(z, a, b);\n\n\t\t// trap calculation\n\t\tdmin=min(dmin, vec4( \n\t\t\t\tabs(0.0+z.y + 0.5*sin(z.x)),\n\t\t\t\tabs(1.0+z.x + 0.5*sin(z.y)),\n\t\t\t\tdot(z,z),\n\t\t\t\tlength(fract(z)-0.5)\n\t\t));\n\n\t\t//If the iterated points enters a 2-cycle , bail out.\n        if (dot(z-llz,z-llz) < 1e-6)\n\t\t\t{\n\t\t\tbreak;\n\t\t\t}\n        //if the iterated point gets outside z.y=0 and z.y=a\n        if (z.y < 0. || z.y > a)\n\t\t\t{\n\t\t\tflag=1.; \n\t\t\tbreak;\n\t\t\t}\n        //Store prévious iterates\n\t\tllz=lz; lz=z;\n\t}\n\n\tvec3 color = vec3(dmin.w);\n\tcolor = mix(color, vec3(0.992, 0.929, 0.675), min(1.0,pow(dmin.x*0.25,0.20)));\n\tcolor = mix(color, vec3(0.835, 0.8, 0.667), min(1.0,pow(dmin.y*0.50,0.50)));\n\tcolor = mix(color, vec3(1.00,1.00,1.00), 1.0-min(1.0,pow(dmin.z*1.00,0.15)));\n\tcolor = 1.25*color*color;\n\treturn vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(0.42, 0.);\n\tuv.x *= iResolution.x/iResolution.y;\n\tfragColor = JosKleinian(uv);\n}\n","name":"Image","description":"","type":"image"}]}