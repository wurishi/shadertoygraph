{"ver":"0.1","info":{"id":"7d3BDX","date":"1657550155","viewed":284,"name":"La Espiral De La Vida","username":"dominionxvii","description":"Spinspinspin! With water, fake caustics, reflection, reggeaton synched animation\n\nIf your GPU can handle it, uncomment\"#define HD\" will make it even prettier!\nIn the Sound tab, uncomment \"#define DEBUG_AUDIO\" to have a shitty sinwave reggeaton beat","likes":11,"published":1,"flags":8,"usePreview":1,"tags":["raymarchingwatercausticsspiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define HD\n//#define ANTIALIAS\n\n#define MAX_STEPS 3000\n#define MAX_DIST 1600.\n#define SURF_DIST .005\n\n#define NO_TRANSFORM Transform(vec3(0.0), vec4(0.0), 0.0, vec3(0.0))\n\n#define ID_LAKE 0\n#define ID_SKY 1\n#define ID_CUBE 2\n#define ID_ORB 3\n\n#define ID_NONE -1\n\n#define REFL_LAKE 0.25\n#define REFL_SKY 0.0\n#define REFL_CUBE 0.0\n\n\n#define FOG GetColor(15, 15, 15)\nconst float cameraDistancePerLoop = 4.;\nconst float objectDist = 6.;\nconst float loopAfterXObject = 70.;\nconst float loopDist = objectDist * loopAfterXObject;\n\nconst float lakeSkySplit = 10.;\n\nstruct Transform\n{\n    vec3 pos;\n    vec4 rot;\n    float scale;\n    vec3 instanceId;\n};\n\nstruct RayMarchHit\n{\n    float dist;\n    int materialId;\n    float refl;\n    Transform tr;\n};\n\nstruct RayHit\n{\n    //inputs\n    vec3 ro;\n    vec3 rd;\n    \n    //outputs\n    bool hasHit;\n    float dist;\n    vec3 hitPos;\n    vec3 normal;\n    vec3 reflDir;\n        \n    RayMarchHit rm;\n};\n\nstruct WorldData\n{\n    vec3 lightDir;\n    float ambientLight;\n    float angle;\n};\n\nWorldData worldData;\nfloat iTimeS;\nfloat iTimeRatio;\nfloat cameraZ;\n\nvec3 TransformPoint(vec3 p)\n{\n    mat2 rot = Rot(p.z * worldData.angle);\n    p.xy *= rot;\n\n    float kickFreq = 120.;\n    float ratioZ = distance(cameraZ, p.z) / loopDist;\n    float kickPropagate = (1.0 - ratioZ) * 0.005;\n    float kick = 1.000 * GetKick(iTimeRatio + kickPropagate) +\n                 0.750 * GetKick(iTimeRatio - 0.005 + kickPropagate) +\n                 0.250 * GetKick(2. * iTimeRatio + kickPropagate) +\n                 0.125 * GetKick(2. * iTimeRatio - 0.005  + kickPropagate);\n    float kickAmp = 1. + 0.035 * kick * sin(iTimeRatio * TAU * kickFreq + ratioZ * TAU * 0.5);\n    p.y *= kickAmp;\n    \n    p.x += 2. * sin(iTimeRatio * TAU * 2.5 + ratioZ * TAU * 1.);\n\n    return p;\n}\n\nRayMarchHit rmMin(RayMarchHit hit1, RayMarchHit hit2)\n{\n    if(hit1.dist < hit2.dist)\n    {\n        return hit1;\n    }\n    else\n    {\n        return hit2;\n    }\n}\n\nuint InstanceIdToSeed(vec3 instanceID)\n{\n    return WangHash(uint(instanceID.x * 123.51 + instanceID.z * 52.126)); ;\n}\n\nvec3 GetObjectColor(vec3 instanceID)\n{\n    uint seed = uint(instanceID.z * 352.241 + instanceID.x * 126.27);\n    uint state = WangHash(seed);\n    float hue = NextFloat(0., 360., state);\n    \n    float hitHat = GetHitHat(iTimeRatio);\n    float flashHue = mix(hue, hue + 60., hitHat);\n    return HSVtoColor(flashHue, 0.35, 1.);\n}\n\nvec3 GetCubePositionID(vec3 p)\n{\n    p.z -= loopDist * iTimeRatio;\n\n    vec3 pos = floor((p / objectDist) + 0.5);\n    pos.z = mod(pos.z, loopAfterXObject) + 35.; //add this offset to remove the ugly yellow bar\n    return pos;\n}\n\nvec3 GetCubePositionCellPos(vec3 p)\n{\n    p.z -= loopDist * iTimeRatio;\n\n    return mod(p + 0.5 * objectDist, objectDist) - 0.5 * objectDist;\n}\n\nint GetShape(vec3 instanceID)\n{\n    uint state = InstanceIdToSeed(instanceID * 24.);\n\n    float randomShape = NextFloat(0.0, 1.0, state);\n    //return randomShape < 0.7 ? ID_CUBE : ID_ORB;\n    return ID_ORB;\n}\n\nvec3 GetFloatingCubePos(vec3 p, vec3 instanceID)\n{\n    float randomOffset = 1.3;\n\n    uint state = InstanceIdToSeed(instanceID); \n\n    p.xz = GetCubePositionCellPos(p).xz;\n    p.x += NextFloat(-randomOffset, randomOffset, state);\n    p.z += NextFloat(-randomOffset, randomOffset, state);\n\n    p.y += 10.2;\n    \n    \n    bool hideObject = NextFloat(0.0, 1.0, state) < 0.85;\n\n    if(hideObject)\n        p.z += 10000000.;\n    \n    return p;\n}\n\n//sdLake is expensive, try to skip it\nRayMarchHit sdLakeTest(vec3 p)\n{    \n    float d = p.y + lakeSkySplit;\n    return RayMarchHit(d, ID_LAKE, REFL_LAKE, NO_TRANSFORM);\n}\n\nRayMarchHit sdLake(vec3 p)\n{\n    float objectWaveSum = 0.;\n    \n#ifdef HD\n    float invFadeDist = 1. / (objectDist * 0.75);\n    //Stack Object waves from all 9 surrounding cell\n    for(float x = -1.; x <= 1.; x += 1.)\n    for(float z = -1.; z <= 1.; z += 1.)\n    {\n        vec3 offsetPos = vec3(x, 0.0, z) * objectDist;\n\n        vec3 instanceID = GetCubePositionID(p - offsetPos);\n        vec3 cubeFloatWavePos = GetFloatingCubePos(p - offsetPos , instanceID);\n\n        float dopplerEffectTrail = (cubeFloatWavePos.z + offsetPos.z) * 0.5; \n        float waveDist = length(cubeFloatWavePos.xz + offsetPos.xz) + dopplerEffectTrail; \n\n        //fbm sinwave\n        const float waveDistFreq = 2.;\n\n        //TODO match it to loopDist\n        float sinWave = \n            0.500 * sin(1.0 * PI * waveDistFreq * waveDist - 1.0 * iTimeS * PI) +\n            0.250 * sin(2.0 * PI * waveDistFreq * waveDist - 2.0 * iTimeS * PI) + \n            0.125 * sin(4.0 * PI * waveDistFreq * waveDist - 4.0 * iTimeS * PI);\n\n        float wavePower = easeInQuad(1.0 - saturate(waveDist * invFadeDist));\n\n        objectWaveSum += wavePower * sinWave;      \n    }\n#endif\n       \n    float x0 = 1.0 * snoiseRotate(vec2(p.x / 16.0, 0.0), 0.125, (p.z / loopDist) * 1. - iTimeRatio);\n    float x1 = 0.5 * snoiseRotate(vec2(p.x / 8.0, 0.0), 0.25, (p.z / loopDist) * 2. - iTimeRatio);\n    float x2 = 0.25 * snoiseRotate(vec2(p.x / 4.0, 0.0), 0.5, (p.z / loopDist) * 4. - iTimeRatio);\n    float x3 = 0.125 * snoiseRotate(vec2(p.x / 2.0, 0.0), 1.0, (p.z / loopDist) * 8. - iTimeRatio);\n    float noiseSum = x0 + x1 + x2 + x3;\n\n    float d = p.y + lakeSkySplit + \n        0.015 * objectWaveSum +\n        0.035 * noiseSum; \n    return RayMarchHit(d, ID_LAKE, REFL_LAKE, NO_TRANSFORM);\n}\n\nRayMarchHit sdSky(vec3 p)\n{\n\n    float d = -p.y + lakeSkySplit; \n    return RayMarchHit(d, ID_SKY, REFL_SKY, NO_TRANSFORM);\n}\n\nRayMarchHit sdCubes(vec3 p)\n{\n    vec3 objectPos = p;\n    vec3 instanceID = GetCubePositionID(p);\n    p = GetFloatingCubePos(p, instanceID);\n\n    //wave wobble\n    float waveMovement = sin(4.0 * iTimeRatio * TAU + instanceID.z * objectDist);\n    p.y += 0.15 * waveMovement;\n\n    uint state = InstanceIdToSeed(instanceID); \n    \n    float scale =  NextFloat(0.3, 0.5, state);\n    \n    float randomShape = NextFloat(0.0, 1.0, state);\n    int materialID = GetShape(instanceID);\n    \n    float d = 0.0;\n    if(materialID == ID_CUBE) \n    {\n        d = sdBox(p, vec3(scale));\n    }\n    else //Sphere\n    {\n        d = sdSphere(p, scale);\n    }\n  \n    Transform tr = Transform(objectPos, vec4(0.0, 0.0, 0.0, 1.0), scale, instanceID);\n    return RayMarchHit(d, materialID, REFL_CUBE, tr);\n}\n\nRayMarchHit GetDist(vec3 p) \n{     \n    //DEBUG\n    //return sdSky(p, worldRot);\n    p = TransformPoint(p);\n    p.y = -abs(p.y);\n    RayMarchHit hit;\n    \n    \n    RayMarchHit sky = sdSky(p);\n    RayMarchHit lakeTest = sdLakeTest(p);\n\n    hit = sky;\n    \n    if(lakeTest.dist < sky.dist)\n    {\n        RayMarchHit cube = sdCubes(p);\n        RayMarchHit lake = sdLake(p);\n        hit = rmMin(sky, cube);\n        hit = rmMin(hit, lake);\n    }\n    \n    return hit;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).dist;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).dist,\n        GetDist(p-e.yxy).dist,\n        GetDist(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nRayHit RayMarch(vec3 ro, vec3 rd) \n{\n    RayHit rayhit;\n    rayhit.ro = ro;\n    rayhit.rd = rd;\n    \n\tfloat d = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * d;\n        RayMarchHit rmHit = GetDist(p);\n        d += rmHit.dist;\n        \n        if(abs(rmHit.dist) < SURF_DIST)\n        {       \n            vec3 n = GetNormal(p);\n            vec3 r = reflect(rd, n);\n        \n            rayhit.hasHit = true;\n            rayhit.dist = d;\n            rayhit.hitPos = p;\n            rayhit.normal = n;\n            rayhit.reflDir = reflect(rd, n);\n            rayhit.rm = rmHit;\n            break;\n        }\n        \n        if(d > MAX_DIST)\n        {\n            rayhit.hasHit = false;\n            break;\n        }\n    }\n    \n    return rayhit;\n}\n\n\nvec3 GetLocalLight(in RayHit rayHit, bool useNormal)\n{\n#ifdef HD\n    float dist = 3.;\n#else\n    float dist = 2.;\n#endif\n\n    vec3 p = TransformPoint(rayHit.hitPos);\n    float invFadeDist = 1.0 / (objectDist * dist);\n    vec3 lightSum = vec3(0.0);\n    \n    for(float x = -dist; x <= dist; x += 1.)\n    {\n        for(float z = -dist; z <= dist; z += 1.)\n        {\n            vec3 offsetPos = vec3(x, 0.0, z) * objectDist;\n            \n            vec3 instanceID = GetCubePositionID(p - offsetPos);\n            \n            if(GetShape(instanceID) == ID_CUBE)\n                continue;\n\n            vec3 cubeFloatWavePos = GetFloatingCubePos(p - offsetPos , instanceID);\n            \n            float lightDist = length(cubeFloatWavePos.xz + offsetPos.xz); \n            float lightPower = (1.0 - easeOutCubic(saturate(lightDist * invFadeDist))) * invFadeDist;\n    \n            if(useNormal)\n            {\n                vec3 objPos = p - offsetPos;\n                vec3 dir = normalize((rayHit.hitPos - objPos));\n                float dotL = saturate(dot(rayHit.normal, dir));\n                lightPower *= dotL;\n            }\n    \n            lightSum += lightPower * GetObjectColor(instanceID);\n        }   \n    }\n    \n    float zRatio = 1. - (distance(cameraZ, p.z) / loopDist);\n    float snareTrail = 0.01;\n\nfloat snare = GetSnare(iTimeRatio - zRatio * snareTrail);\n\n    return lightSum * mix(0.6, 1.5, snare);\n}\n\nfloat GetLightIntensity(in RayHit rayHit)\n{\n    vec3 lightPos = vec3(0.0, 0.0, rayHit.hitPos.z);\n    vec3 lightDir = normalize(lightPos - rayHit.hitPos);\n    float dotL = saturate(dot(rayHit.normal, lightDir));\n    return saturate(dotL + worldData.ambientLight);\n}\n\nvec3 GetSkyColorAtPosition(vec3 pos)\n{\n    float z = TransformPoint(pos).z;\n    z = fract(z / loopDist) * 360.;\n    \n    float hueOffset = z + (pos.x +  pos.y);\n    float hue = mod(hueOffset, 360.);\n\n    vec3 skyColor = HSVtoColor(hue, 0.2, 0.75);\n    return skyColor;\n}\n\nvec3 RenderLake(in RayHit rayHit)\n{\n    vec3 p = TransformPoint(rayHit.hitPos);\n\n    //debug grid\n    //return GetObjectColor((GetCubePositionID(p)));\n\n    float light = GetLightIntensity(rayHit);\n    vec3 waterColor = GetColor(162, 234, 250);\n    vec3 foamColor = GetColor(255, 255, 255);\n       \n    float objectWaveSum = 0.;    \n\n#ifdef HD\n    float invFadeDist = 1.0 / (objectDist * 0.45);\n\n    //Stack Object waves from all 9 surrounding cell\n    for(float x = -1.; x <= 1.; x += 1.)\n    {\n        for(float z = -1.; z <= 1.; z += 1.)\n        {\n            vec3 offsetPos = vec3(x, 0.0, z) * objectDist;\n            \n            vec3 instanceID = GetCubePositionID(p - offsetPos);\n            vec3 cubeFloatWavePos = GetFloatingCubePos(p - offsetPos , instanceID);\n            float waveDist = length(cubeFloatWavePos.xz + offsetPos.xz);\n           \n            float wavePower = easeInQuad(1.0 - saturate(waveDist * invFadeDist));\n    \n            objectWaveSum += wavePower;\n        }   \n    }\n#endif\n    \n    \n    vec3 skyColor = GetSkyColorAtPosition(rayHit.hitPos);\n    \n    vec2 p2 = TransformPoint(rayHit.hitPos).xz;\n    float cell12scale = 0.1;\n\n\n    vec2 causticDir = vec2(iTimeRatio * loopDist * 0.125);\n    float cell1 = cellularXVII(p2 * cell12scale + causticDir * cell12scale, vec2(loopDist) * cell12scale);\n    float cell2 = cellularXVII(p2 * cell12scale - causticDir * cell12scale, vec2(loopDist) * cell12scale);\n    \n    cell1 = 1.0 - pow(cell1, 1.5);\n    cell2 = 1.0 - pow(cell2, 3.5);\n  \n    float cell34scale = 0.5;\n    float cell3 =  cellularXVII(p2 * cell34scale + causticDir * cell34scale, vec2(loopDist) * cell34scale);\n    float cell4 = cellularXVII(p2 * cell34scale - causticDir * cell34scale, vec2(loopDist) * cell34scale);\n    \n    cell3 = 1.0 - pow(cell3, 3.5);\n    cell4 = 1.0 - pow(cell4, 3.5);\n \n    float caustics1 = 1.2 - saturate(min(cell1, cell2));\n    float caustics2 = saturate(1.2 - saturate(min(cell3, cell4)));\n\n    waterColor = mix(waterColor, skyColor, .5);\n    \n    float sparkles = 0.;\n    float sparkDist = 80.;\n    if(rayHit.dist < sparkDist)\n    {\n        vec3 p = TransformPoint(rayHit.hitPos);\n        float sparkles1 = saturate(snoise(p * 3. + vecX(0.1 * iTimeS)));\n        float sparkles2 = saturate(snoise(p * 6. + vecX(0.1 * iTimeS)));\n        float sparkles3 = saturate(snoise(p * 9. + vecX(0.1 * iTimeS)));\n\n        sparkles1 = 5. * smoothstep(0.93, 1.0, sparkles1);\n        sparkles2 = 3. * smoothstep(0.83, 1.0, sparkles2);\n        sparkles3 = 1. * smoothstep(0.83, 1.0, sparkles3);\n        sparkles = (sparkles1 + sparkles2 + sparkles3);\n        \n        sparkles *= 1. - gain(saturate(rayHit.dist / sparkDist), 20.0);\n    }\n    \n    vec3 localLight = GetLocalLight(rayHit, false); \n    return (waterColor * light * 0.65) + (localLight * 4.) + sparkles + objectWaveSum * 0.35 + (caustics1 * 0.25 + caustics2 * 0.02);\n}\n\nvec3 RenderCube(in RayHit rayHit)\n{\n    float light = GetLightIntensity(rayHit);\n    light = Remap(light, 0., 1., 0.25, 0.5);\n\n    Transform tr = rayHit.rm.tr;\n\n    vec3 col = GetObjectColor(tr.instanceId);\n    \n    //add more grayscale \n    col = mix(col, vec3(Luminance(col)), 0.75);\n    \n    vec3 localLight = GetLocalLight(rayHit, true); \n    return saturate(col * light + localLight);\n}\n\nvec3 RenderOrb(in RayHit rayHit)\n{\n    float light = GetLightIntensity(rayHit);\n    light = Remap(light, 0., 1., 0.75, 1.0);\n    Transform tr = rayHit.rm.tr;\n\n    vec3 col = GetObjectColor(tr.instanceId);\n    \n    float fresnel = Fresnel(rayHit.rd, rayHit.normal, 1.);\n    \n    return saturate(col * light + fresnel);\n}\n\nvec3 AddFog(vec3 color, float depth)\n{\n    float fogPlane = 400.;\n    \n    if(depth < fogPlane)\n        return color;\n        \n    float ratio = saturate(unlerp(depth, fogPlane, MAX_DIST));\n    return mix(color, FOG, ratio); \n}\n\nvec3 GetColor(in RayHit rayHit)\n{\n    if(rayHit.hasHit)\n    {\n        switch(rayHit.rm.materialId)\n        {\n            case ID_LAKE: return RenderLake(rayHit);\n            //case ID_SKY: return RenderSky(rayHit);\n            case ID_CUBE: return RenderCube(rayHit);\n            case ID_ORB: return RenderOrb(rayHit);\n\n        }\n    }\n    return FOG;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 pos, vec3 lookPos, float zFov)\n{\n    vec3 forward = normalize(lookPos - pos);\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = cross(forward, right);\n    \n    //fov is computed by extruding more Z, then normalizing it\n    forward = forward * zFov;\n    vec3 dir = normalize(forward + uv.x * right + uv.y * up);\n    return dir;\n}\n\nvec3 RenderAtUv(vec3 ro, vec2 uv)\n{\n    vec3 rd = GetRayDir(uv, ro, vec3(0.), -2.);\n    \n    RayHit hit = RayMarch(ro, rd);\n    vec3 col = GetColor(hit);\n    \n    //Compute reflection\n    if(hit.rm.refl > 0.0)\n    {\n#ifdef HD\n        uint blurState = WangHash(4323432u);\n\n        int blurIteration = 6;\n        vec3 colRefl = vec3(0.0); \n        for(int i = 0; i < blurIteration; i++)\n        {\n            vec3 reflDir = normalize(hit.reflDir + NextVec3(-vec3(0.01), vec3(0.01), blurState));\n            RayHit hitRefl = RayMarch(hit.hitPos + hit.normal * 0.01, reflDir);\n            colRefl += GetColor(hitRefl);\n        }\n        colRefl /= float(blurIteration);\n        \n#else\n        RayHit hitRefl = RayMarch(hit.hitPos + hit.normal * 0.01, hit.reflDir);\n        vec3 colRefl = GetColor(hitRefl);\n#endif\n\n        col = mix(col, colRefl, hit.rm.refl);\n    \n    }\n    col = AddFog(col, hit.dist);\n    return col;\n}\n\n\nvec3 RenderAtUvAntiAliasing(vec3 ro, vec2 uv, vec2 fragCoord)\n{\n    vec3 colorSum = vec3(0.0);        \n    vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n  \n    colorSum += RenderAtUv(ro, uv);\n    colorSum += RenderAtUv(ro, mix(uv, vec2(uv.x, nextUv.y), 0.5));\n    colorSum += RenderAtUv(ro, mix(uv, vec2(nextUv.x, uv.y), 0.5));\n    colorSum += RenderAtUv(ro, mix(uv, nextUv, 0.5));\n    colorSum /= 4.0;\n    return colorSum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float timeScale = 1.;\n    iTimeS = mod(iTime * timeScale, loopDuration);\n\n    iTimeRatio = (iTimeS / loopDuration);\n\n    cameraZ = 0.001 + iTimeRatio * loopDist * cameraDistancePerLoop;\n    vec3 ro = vec3(0, 0, cameraZ);\n\n    worldData.lightDir = normalize(vec3(0.0, -1.5, -1.0));\n    worldData.ambientLight = 0.35;\n    worldData.angle = (2. * PI) / loopDist;\n\n#ifdef ANTIALIAS\n    vec3 col = RenderAtUvAntiAliasing(ro, uv, fragCoord);\n#else\n    vec3 col = RenderAtUv(ro, uv);\n#endif\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.283185\n#define PI 3.141592\n\n//Music & Synch\n#define BEAT\n\n//https://www.desmos.com/calculator/c1x3ln85sk?lang=es\n//bpm = 60 * mesuresPerLoop * mesureLength / loopDuration\n\nconst int mesuresPerLoop = 8;\nconst int beatPerMesure = 8;\nconst int hitHatMesure[beatPerMesure] = int[beatPerMesure](1, 0, 1, 0, 1, 0, 1, 0); \nconst int kickMesure[beatPerMesure]   = int[beatPerMesure](1, 0, 0, 0, 1, 0, 0, 0); \nconst int snareMesure[beatPerMesure]  = int[beatPerMesure](0, 0, 0, 1, 0, 0, 1, 0);\nconst float loopDuration = 16.;\n\n//Utils\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Luminance(vec3 col)\n{\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722; \n}\n\n\nvec3 GetColor(int r, int g, int b)\n{\n    return vec3(r, g, b) / 255.;\n}\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 v)\n{\n    return vec3(saturate(v.x), saturate(v.y), saturate(v.z));\n}\n\nvec3 Smoothstep(vec3 a, vec3 b, float t)\n{\n    return vec3(smoothstep(a.x, b.x, t), smoothstep(a.y, b.y, t), smoothstep(a.z, b.z, t));\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\n\nfloat Remap(float fromMin, float fromMax, float toMin, float toMax, float x)\n{\n    float t = saturate(unlerp(x, fromMin, fromMax));\n    return mix(toMin, toMax, t);\n}\n\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\n\nfloat easeOutCirc(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutCubic(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\nfloat easeInQuad(float x)\n{\n    return x * x;\n}\n\nfloat easeInCubic(float x)\n{\n    return x * x * x;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat Fresnel(vec3 rd, vec3 normal, float power)\n{\n    float fresnel = dot(rd, -normal);\n    fresnel = max(fresnel, 0.0);\n    fresnel = 1.0 - fresnel;\n    fresnel = pow(fresnel, power);\n    return fresnel;\n}\n\nfloat distancesq(vec2 x, vec2 y)\n{\n    vec2 diff = x - y;\n    return dot(diff, diff);\n}\n\n\nfloat distancesq(vec3 x, vec3 y)\n{\n    vec3 diff = x - y;\n    return dot(diff, diff);\n}\n\nfloat Tri(float x)\n{\n    return 1. - abs(1. - 2. * x);\n}\n\nfloat Repeat(float x, float repeat)\n{\n  return x - floor(x/repeat)*repeat;\n\n}\nvec2 Repeat(vec2 v, vec2 repeat)\n{\n    return vec2(Repeat(v.x, repeat.x), Repeat(v.y, repeat.y));\n}\n\nfloat Quantize(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec2 Quantize(vec2 x, vec2 resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec2 Quantize(vec2 x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec4 fade(vec4 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n        \nfloat snoise(vec2 v)\n{\n    vec4 C = vec4(0.211324865405187,  // (3.0-math.sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(math.sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = math.step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0f, 1.0f);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    float  gx = a0.x * x0.x + h.x * x0.y;\n    vec2 gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    vec3 g = vec3(gx,gyz);\n\n    return 130.0 * dot(m, g);\n}\n\nfloat snoiseRotate(vec2 center, float r, float t)\n{\n    t *= TAU;\n    float s = sin(t), c = cos(t);\n    vec2 p = center + r * vec2(s, c);\n    return snoise(p);\n}\n\nfloat snoise(vec3 v)\n{\n    vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy; \n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\n\nfloat pnoise(vec2 P, vec2 rep)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\n\nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\nvec2 cellular(vec3 P)\n{\n    const float K = 0.142857142857; // 1/7\n    const float Ko = 0.428571428571; // 1/2-K/2\n    const float K2 = 0.020408163265306; // 1/(7*7)\n    const float Kz = 0.166666666667; // 1/6\n    const float Kzo = 0.416666666667; // 1/2-1/6*2\n    const float jitter = 1.0f; // smaller jitter gives more regular pattern\n\n    vec3 Pi = mod289(floor(P));\n    vec3 Pf = fract(P) - 0.5;\n    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n    vec3 p1 = permute(p + Pi.y - 1.0);\n    vec3 p2 = permute(p + Pi.y);\n    vec3 p3 = permute(p + Pi.y + 1.0);\n    vec3 p11 = permute(p1 + Pi.z - 1.0);\n    vec3 p12 = permute(p1 + Pi.z);\n    vec3 p13 = permute(p1 + Pi.z + 1.0);\n    vec3 p21 = permute(p2 + Pi.z - 1.0);\n    vec3 p22 = permute(p2 + Pi.z);\n    vec3 p23 = permute(p2 + Pi.z + 1.0);\n    vec3 p31 = permute(p3 + Pi.z - 1.0);\n    vec3 p32 = permute(p3 + Pi.z);\n    vec3 p33 = permute(p3 + Pi.z + 1.0);\n    vec3 ox11 = fract(p11 * K) - Ko;\n    vec3 oy11 = mod7(floor(p11 * K)) * K - Ko;\n    vec3 oz11 = floor(p11 * K2) * Kz - Kzo; // p11 < 289 guaranteed\n    vec3 ox12 = fract(p12 * K) - Ko;\n    vec3 oy12 = mod7(floor(p12 * K)) * K - Ko;\n    vec3 oz12 = floor(p12 * K2) * Kz - Kzo;\n    vec3 ox13 = fract(p13 * K) - Ko;\n    vec3 oy13 = mod7(floor(p13 * K)) * K - Ko;\n    vec3 oz13 = floor(p13 * K2) * Kz - Kzo;\n    vec3 ox21 = fract(p21 * K) - Ko;\n    vec3 oy21 = mod7(floor(p21 * K)) * K - Ko;\n    vec3 oz21 = floor(p21 * K2) * Kz - Kzo;\n    vec3 ox22 = fract(p22 * K) - Ko;\n    vec3 oy22 = mod7(floor(p22 * K)) * K - Ko;\n    vec3 oz22 = floor(p22 * K2) * Kz - Kzo;\n    vec3 ox23 = fract(p23 * K) - Ko;\n    vec3 oy23 = mod7(floor(p23 * K)) * K - Ko;\n    vec3 oz23 = floor(p23 * K2) * Kz - Kzo;\n    vec3 ox31 = fract(p31 * K) - Ko;\n    vec3 oy31 = mod7(floor(p31 * K)) * K - Ko;\n    vec3 oz31 = floor(p31 * K2) * Kz - Kzo;\n    vec3 ox32 = fract(p32 * K) - Ko;\n    vec3 oy32 = mod7(floor(p32 * K)) * K - Ko;\n    vec3 oz32 = floor(p32 * K2) * Kz - Kzo;\n    vec3 ox33 = fract(p33 * K) - Ko;\n    vec3 oy33 = mod7(floor(p33 * K)) * K - Ko;\n    vec3 oz33 = floor(p33 * K2) * Kz - Kzo;\n    vec3 dx11 = Pfx + jitter * ox11;\n    vec3 dy11 = Pfy.x + jitter * oy11;\n    vec3 dz11 = Pfz.x + jitter * oz11;\n    vec3 dx12 = Pfx + jitter * ox12;\n    vec3 dy12 = Pfy.x + jitter * oy12;\n    vec3 dz12 = Pfz.y + jitter * oz12;\n    vec3 dx13 = Pfx + jitter * ox13;\n    vec3 dy13 = Pfy.x + jitter * oy13;\n    vec3 dz13 = Pfz.z + jitter * oz13;\n    vec3 dx21 = Pfx + jitter * ox21;\n    vec3 dy21 = Pfy.y + jitter * oy21;\n    vec3 dz21 = Pfz.x + jitter * oz21;\n    vec3 dx22 = Pfx + jitter * ox22;\n    vec3 dy22 = Pfy.y + jitter * oy22;\n    vec3 dz22 = Pfz.y + jitter * oz22;\n    vec3 dx23 = Pfx + jitter * ox23;\n    vec3 dy23 = Pfy.y + jitter * oy23;\n    vec3 dz23 = Pfz.z + jitter * oz23;\n    vec3 dx31 = Pfx + jitter * ox31;\n    vec3 dy31 = Pfy.z + jitter * oy31;\n    vec3 dz31 = Pfz.x + jitter * oz31;\n    vec3 dx32 = Pfx + jitter * ox32;\n    vec3 dy32 = Pfy.z + jitter * oy32;\n    vec3 dz32 = Pfz.y + jitter * oz32;\n    vec3 dx33 = Pfx + jitter * ox33;\n    vec3 dy33 = Pfy.z + jitter * oy33;\n    vec3 dz33 = Pfz.z + jitter * oz33;\n    vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n    vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n    vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n    vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n    vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n    vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n    vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n    vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n    vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n    // Sort out the two smallest distances (F1, F2)\n    // Do it right and sort out both F1 and F2\n    vec3 d1a = min(d11, d12);\n    d12 = max(d11, d12);\n    d11 = min(d1a, d13); // Smallest now not in d12 or d13\n    d13 = max(d1a, d13);\n    d12 = min(d12, d13); // 2nd smallest now not in d13\n    vec3 d2a = min(d21, d22);\n    d22 = max(d21, d22);\n    d21 = min(d2a, d23); // Smallest now not in d22 or d23\n    d23 = max(d2a, d23);\n    d22 = min(d22, d23); // 2nd smallest now not in d23\n    vec3 d3a = min(d31, d32);\n    d32 = max(d31, d32);\n    d31 = min(d3a, d33); // Smallest now not in d32 or d33\n    d33 = max(d3a, d33);\n    d32 = min(d32, d33); // 2nd smallest now not in d33\n    vec3 da = min(d11, d21);\n    d21 = max(d11, d21);\n    d11 = min(da, d31); // Smallest now in d11\n    d31 = max(da, d31); // 2nd smallest now not in d31\n    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n    d12 = min(d12, d21); // 2nd smallest now not in d21\n    d12 = min(d12, d22); // nor in d22\n    d12 = min(d12, d31); // nor in d31\n    d12 = min(d12, d32); // nor in d32\n    d11.yz = min(d11.yz, d12.xy); // nor in d12.yz\n    d11.y = min(d11.y, d12.z); // Only two more to go\n    d11.y = min(d11.y, d11.z); // Done! (Phew!)\n    return sqrt(d11.xy); // F1, F2\n}\n\n\n///\n\nvec3 HSVtoColor(float hue, float saturation, float value)\n{\n    float hi = mod(floor(hue / 60.), 6.);\n    float f = hue / 60. - floor(hue / 60.);\n\n    value = value;\n    float v = value;\n    float p = value * (1. - saturation);\n    float q = value * (1. - f * saturation);\n    float t = value * (1. - (1. - f) * saturation);\n\n    if (hi == 0.)\n        return vec3(v, t, p);\n    else if (hi == 1.)\n        return vec3(q, v, p);\n    else if (hi == 2.)\n        return vec3(p, v, t);\n    else if (hi == 3.)\n        return vec3(p, q, v);\n    else if (hi == 4.)\n        return vec3(t, p, v);\n    else\n        return vec3(v, p, q);\n}\n\nfloat cellfbm( in vec2 x, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*x;\n    }\n\treturn a;\n}\n\nfloat cellfbmr( in vec2 x, mat2 rot, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\n//raymarcher\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opRep(float p, float c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(float xmin, float xmax, inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return mix(xmin, xmax, t);\n}\n\nvec2 NextVec2(vec2 rmin, vec2 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    return vec2(x, y);\n}\n\nvec3 NextVec3(vec3 rmin, vec3 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    float z = NextFloat(rmin.z, rmax.z, state);\n    return vec3(x, y, z);\n}\n\nfloat cellularXVII(vec2 p)\n{\n    float minDistSq = 999999.;\n    vec2 centerCell = floor(p);    \n\n    for(float x = -1.; x <= 1.; x += 1.)\n    {\n        for(float y = -1.; y <= 1.; y += 1.)\n        {\n            vec2 cell = centerCell + vec2(x, y);    \n            uint state = WangHash(uint(cell.x * 263. + cell.y * 126.));\n            vec2 offset = NextVec2(vec2(0.0), vec2(1.0), state);\n            vec2 centerPos = cell + offset;\n            float distSq = distancesq(p, centerPos);\n            minDistSq = min(minDistSq, distSq);\n        }\n    }\n    return sqrt(minDistSq);\n}\n\nfloat cellularXVII(vec2 p, vec2 cellCycle)\n{\n    float minDistSq = 999999.;\n    vec2 centerCell = Quantize(p, 1.);    \n\n    for(float x = -1.; x <= 1.; x += 1.)\n    {\n        for(float y = -1.; y <= 1.; y += 1.)\n        {\n            vec2 cell = centerCell + vec2(x, y);\n            //cell = Quantize(cell, 1.);\n            vec2 cellRepeat = Repeat(cell, cellCycle);        \n            uint state = WangHash(uint(cellRepeat.x * 263. + cellRepeat.y * 126.));\n            \n            vec2 offset = NextVec2(vec2(0.0), vec2(1.0), state);   \n            vec2 centerPos = (cell  + offset);          \n\n            float distSq = distancesq(p, centerPos);\n            minDistSq = min(minDistSq, distSq);\n        }\n    }\n    return sqrt(minDistSq);\n}\n\n\n\n//quats\n\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}\nvec4 qInverse(vec4 q)\n{\n    vec4 x = q;\n    return vec4(1.0/(dot(x, x)) * x * vec4(-1.0, -1.0, -1.0, 1.0));\n}\n\n//Music utils\n\n//delay attack sustain release\nfloat DASRCurve(float t, float delay, float attack, float sustain, float release)\n{\n    if(t < delay)\n        return 0.0;\n    if(t < attack)\n        return Remap(delay, attack, 0.0, 1.0, t);\n    if(t < sustain)\n        return 1.0;\n    else if(t < release)\n        return Remap(sustain, release, 1.0, 0.0, t);\n    else\n        return 0.0;\n        \n}\n\nfloat GetEnv(float t)\n{\n    t = DASRCurve(t, 0.0, 0.05, 0.5, 1.0);//smooth\n    //t = DASRCurve(t, 0.0, 0.00, 1.0, 1.0);//step\n    return easeInOutCubic(t);\n}\n\nvoid TimeToBeatIndex(float ratio, out int i, out float t)\n{  \n    //[0, 1] -> [0, mesuresPerLoop]\n    t = ratio * float(beatPerMesure * mesuresPerLoop);\n    i = int(t) % beatPerMesure;\n    t = fract(t);\n    return;\n    \n    //[0m mesuresPerLoop] -> mesuresPerLoop x [0, 1]\n    t = fract(t);   \n\n    //mesuresPerLoop x [0, mesureLength]\n    t *= float(beatPerMesure);\n   \n    // finalize value\n    i = int(t);\n    i = i % beatPerMesure;\n\n    t = fract(t);\n    return;\n   \n    //[0, 1] -> [0, mesuresPerLoop]\n    t = ratio * float(mesuresPerLoop);\n    \n    //[0m mesuresPerLoop] -> mesuresPerLoop x [0, 1]\n    t = fract(t);   \n    \n    //mesuresPerLoop x [0, mesureLength]\n    t = t * float(beatPerMesure);\n   \n    // finalize value\n    i = int(t);\n    i = i % beatPerMesure;\n\n    t = fract(t);\n}\n\nfloat GetHitHat(float ratio)\n{\n    int i;\n    float t;\n    TimeToBeatIndex(ratio, i ,t);\n    return GetEnv(t) * float(hitHatMesure[i]);\n}\n\n\nfloat GetSnare(float ratio)\n{\n    int i;\n    float t;\n    TimeToBeatIndex(ratio, i ,t);\n    return GetEnv(t) * float(snareMesure[i]);\n}\n\nfloat GetKick(float ratio)\n{\n    int i;\n    float t;\n    TimeToBeatIndex(ratio, i ,t);\n    return GetEnv(t) * float(kickMesure[i]);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"//#define DEBUG_AUDIO\n\nfloat AudioSin(float freq, int sec, float secFrac)\n{\n    sec = sec % 10;\n    float t = float(sec) + secFrac;\n    return sin(freq * t); \n}\n\nvec2 mainSound(int samp, float time)\n{  \n#ifdef DEBUG_AUDIO  \n    float timeScale = 1.;\n    float iTimeS = mod(time * timeScale, loopDuration);\n    float iTimeRatio = (iTimeS / loopDuration);\n\n    float pi2 = 6.2831;\n    float la2 = 110.;\n    float la3 = 220.;\n    float hitHatVib = 560.;\n\n    int seconds = samp / int(iSampleRate);\n    float secondFrac = mod(float(samp), iSampleRate) / iSampleRate;\n    \n    float hitHat = GetHitHat(iTimeRatio) * AudioSin(pi2 * hitHatVib, seconds, secondFrac) * 0.2;\n    float kick = GetKick(iTimeRatio) * AudioSin(pi2 * la2, seconds, secondFrac);\n    float snare = GetSnare(iTimeRatio) * AudioSin(pi2 * la3, seconds, secondFrac);\n\n    return vec2(kick + snare + hitHat) * 0.25;\n#else\n    return vec2(0.);\n#endif\n\n}","name":"Sound","description":"","type":"sound"}]}