{"ver":"0.1","info":{"id":"MfcXRX","date":"1715366649","viewed":40,"name":"Raytracing sphere","username":"leprixon","description":"base ray tracing only sphere. So it doesn't include any additional checks and doesn't require reflect light system","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// returns part of culculation needed for calculation\n// t-variable (x(vec) = origin(point) + t * direction(vector)\n// doesn't do entire calculation of t since this part is needed\n// for checking if the line hits the sphere\nfloat doHit(vec3 origin, float s, float r)\n{\n    return r * r - dot(origin, origin) + s * s;\n}\n\n\n// rotate vector p around the axis `x`\nvec3 rotX(vec3 p, float angle)\n{\n    float cosa = cos(angle);\n    float sina = sin(angle);\n    \n    // rotation linear function (matrix mulptiplaying)\n    return vec3(\n        p.x,\n        dot(p, vec3(0, cosa, -sina)),\n        dot(p, vec3(0, sina, cosa))\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coords\n    vec2 uvs = vec2((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y);\n    vec3 uv = vec3(uvs, pow(1.0 - dot(uvs, uvs), 0.5));\n    vec2 mouse = vec2((iMouse.xy - 0.5 * iResolution.xy) / iResolution.y);\n    \n    // default color\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // Sets\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    vec3 light = vec3(-mouse.x, -mouse.y, -.0); // light origin\n    vec3 spOrigin = vec3(0.0, 0.0, 0.5);        // sphere origin\n    float r = 0.2;\n    \n    // direction\n    float angle = -0.0 * 3.1415 / 180.0;\n    vec3 p = normalize(uv - cam);               // not rotated direction vector\n    vec3 dir = rotX(p, angle);                   // rotated direction vector\n    \n    // hit\n    float s = dot(cam - spOrigin, dir) / dot(dir, dir); // const for culculation t\n    \n    // part of calculation. Returned to check if we have a hit\n    float dh = doHit(cam - spOrigin, s, r);             \n    \n    if (dh >= 0.0)\n    {\n        // Hit place\n        float t = pow(dh, .5) - s;\n        vec3 ps = cam + dir * t;\n        \n        // normal to the hit place and the vector of the falling light\n        vec3 normP = normalize(spOrigin - ps);\n        vec3 l = normalize(ps - light);\n        \n        // Facing light?\n        float cosa = dot(-l, normP);\n        \n        // Playing with colors\n        float m = ps.z / 2.3;\n        vec3 k = normalize(vec3(ps.xy + m, ps.z - m));\n        \n        col = cosa * vec3(\n            smoothstep(0.0, 1.0, k.x),\n            smoothstep(0.0, 1.0, k.y),\n            smoothstep(0.0, 1.0, k.z)\n        );\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}