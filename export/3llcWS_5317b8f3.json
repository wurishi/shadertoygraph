{"ver":"0.1","info":{"id":"3llcWS","date":"1592948937","viewed":421,"name":"star ribbon","username":"halcy","description":"small sketch going off old code while I try to not lose it reading a students thesis","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["ribbon","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DO_BLUR 1\n\n// blur with hexagonalish sampling pattern\n// weighs samples according to coc size (so that \"in focus\" samples count for less)\n// and according to tap nb (weighs outer samples higher)\nvec3 hexablur(sampler2D tex, vec2 uv) {\n    vec2 scale = vec2(1.0) / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float asum = 0.0;\n    float coc = texture(tex, uv).a;\n    for(float t = 0.0; t < 8.0 * 2.0 * 3.14; t += 3.14 / 32.0) {\n    \tfloat r = cos(3.14 / 6.0) / cos(mod(t, 2.0 * 3.14 / 6.0) - 3.14 / 6.0);\n        \n        // Tap filter once for coc\n        vec2 offset = vec2(sin(t), cos(t)) * r * t * scale * coc;\n        vec4 samp = texture(tex, uv + offset * 1.0);\n        \n        // Tap filter with coc from texture\n        offset = vec2(sin(t), cos(t)) * r * t * scale * samp.a;\n        samp = texture(tex, uv + offset * 1.0);\n        \n        // weigh and save\n        col += samp.rgb * samp.a * t;\n        asum += samp.a * t;\n        \n    }\n    col = col / asum;\n    return(col);\n}\n\n// Blur image from buffer\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    if(DO_BLUR == 1) {\n\t\tfragColor = vec4(hexablur(iChannel0, uv), 0.0);\n        \n        // Tonemap and gamma-correct\n        fragColor = fragColor / (fragColor + vec4(1.0));\n        fragColor.rgb = vec3(pow(fragColor.r, 1.0 / 2.2), pow(fragColor.g, 1.0 / 2.2), pow(fragColor.b, 1.0 / 2.2));\n    }\n    else {\n        fragColor = vec4(texture(iChannel0, uv));\n        \n        // Tonemap and gamma-correct\n        fragColor = fragColor / (fragColor + vec4(1.0));\n        fragColor.rgb = vec3(pow(fragColor.r, 1.0 / 2.2), pow(fragColor.g, 1.0 / 2.2), pow(fragColor.b, 1.0 / 2.2));\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Various knobs to twiddle\n#define MIN_DIST 0.001\n#define STEP_MULTIPLIER 1.0\n#define MAX_STEPS 128\n#define NORMAL_OFFSET 0.01\n\n// Trefoil knot positions\n// hard to do implicitly, lets cheat.\nvec3 trefoil(float t) {\n\treturn vec3(\n        sin(t) + 2.0 * sin(2.0 * t),\n        cos(t) - 2.0 * cos(2.0 * t),\n        -sin(3.0 * t)\n    );\n}\n\nvec3 loc[16] =  vec3[16](\n    \n    vec3( 0.577,  0.577,  0.577),\n    vec3(-0.577,  0.577,  0.577),\n    vec3( 0.577, -0.577,  0.577),\n    vec3(-0.577, -0.577,  0.577),\n    \n    vec3( 0.000,  0.357,  0.934),\n    vec3( 0.000,  0.357, -0.934),\n    \n    vec3( 0.934,  0.000,  0.357),\n    vec3(-0.934,  0.000,  0.357),\n    \n    vec3( 0.357,  0.934,  0.000),\n    vec3( 0.357, -0.934,  0.000),\n    \n    vec3( 0.000,  0.851,  0.526),\n    vec3( 0.000, -0.851,  0.526),\n    vec3( 0.526,  0.000,  0.851),\n    vec3(-0.526,  0.000,  0.851),\n    vec3( 0.851,  0.526,  0.000),\n    vec3(-0.851,  0.526,  0.000)\n);\n\nfloat dode(vec3 pos, float soft) {\n    float dist = 0.0;\n    for(int i = 10; i < 16; i++) {\n\t\tdist += pow(abs(dot(pos, loc[i])), soft);\n    }\n    return(pow(dist, 1.0 / soft));\n}\n\nfloat ico(vec3 pos, float soft) {\n    float dist = 0.0;\n    for(int i = 0; i < 10; i++) {\n\t\tdist += pow(abs(dot(pos, loc[i])), soft);\n    }\n    return pow(dist, 1.0 / soft);\n}\n\n// Distance / color combiner\nvec4 distcompose(vec4 dista, vec4 distb, float softness) {\n    float mixfact = clamp(0.5 + 0.5 * (distb.a - dista.a) / softness, 0.0, 1.0);\n    return mix(distb, dista, mixfact) - vec4(0.0, 0.0, 0.0, softness * mixfact * (1.0 - mixfact));\n}\n\n// World\nvec4 distfunc(vec3 pos) {\n  \tvec4 box = vec4(0.0);\n    box.xyz = vec3(0.01);\n    box.a = min(min(pos.y, -abs(pos.z) + 2.0), -abs(pos.x) + 2.0);\n    vec4 dist = box;\n    \n    float big = iTime * 2.0;\n    for(float i = 0.0; i < 15.0; i += 1.0) {\n        vec3 pos2 = pos - vec3(0.0, 1.0, 0.0) + trefoil(iTime + i / 15.0 * 3.14159) * 0.45;\n        vec4 box5 = vec4(1.0);\n\n        float icodist = ico(pos2 * 0.9, 30.0);\n        float dodedist = dode(pos2, 30.0);\n\n        float rad = 0.06 + sin(big - i) * 0.025;\n        box5.a = icodist - dodedist * 0.5 - rad;\n        dist = distcompose(dist, box5, 0.0);\n    }\n    \n    return(dist);\n}\n\n// Renderer\nvec4 pixel(vec2 fragCoord) {\n    // Screen -1 -> 1 coordinates\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Set up time dependent stuff\n    vec3 lightpos = vec3(0.0, 1.5, 0.0);\n    float wobble = sin(iTime * 0.2) * 4.8;\n    \n    // Camera as eye + imaginary screen at a distance\n    vec3 eye = vec3(sin(wobble) * -1.75, 1.4 + cos(iTime * 0.3), cos(wobble) * -1.75);\n    vec3 lookat = vec3(0.0, 1.0, 0.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    vec3 ray = normalize(pixelpos - eye);\n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    float iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n    vec3 colorval = distfunc(pos).rgb;\n    vec3 itershade = vec3(iters / float(MAX_STEPS));\n    \n    if(colorval.r == 1.0) {\n        // FD normals\n        vec2 d = vec2(NORMAL_OFFSET, 0.0);\n        vec3 normal = normalize(vec3(\n            distfunc(pos + d.xyy).a - distfunc(pos - d.xyy).a,\n            distfunc(pos + d.yxy).a - distfunc(pos - d.yxy).a,\n            distfunc(pos + d.yyx).a - distfunc(pos - d.yyx).a\n        ));\n        vec3 refl = reflect(normalize(pos - eye), normal);\n    \n    \tcolorval = texture(iChannel0, refl).rgb * 1.5;\n    }\n    else {\n        colorval = texture(iChannel0, pos - eye).rgb * 0.7;\n    }\n    \n    colorval = pow(colorval, vec3(4.0));\n    colorval += itershade * vec3(0.1);\n    \n    \n    // Calculate CoC (limited to a maximum size) and store\n    float depth = -dot(pos - eye, normalize(eye - lookat));\n    vec3 depth_target = - vec3(0.0, 1.0, 0.0) + trefoil(iTime + 0.0 / 15.0 * 3.14159) * 0.45;\n    vec4 fragColor = vec4(colorval.xyz, 0.0);\n    float coc = pow(0.5 * abs(2.0 - length(eye - lookat) / depth), 2.0);\n    return(vec4(fragColor.rgb, max(0.01, min(0.35, coc))));\n    \n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pixel(fragCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}