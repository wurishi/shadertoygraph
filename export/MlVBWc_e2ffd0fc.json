{"ver":"0.1","info":{"id":"MlVBWc","date":"1544378893","viewed":149,"name":"Random Shard","username":"oalpha","description":"A random shape generated by an array random planes. Planes are generated from an integer seed (SHARD_SEED). The amount of planes generated is SHARD_PLANE_NUM. The distribution of planes is not yet adequate.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ALTITUDE 0.6\n#define SHARD_SEED 6\n#define SHARD_PLANE_NUM 64\nvec3 SHARD_SHAPE = vec3(.5, .5, 1.2);\nconst vec3 SHARD_COLOR = vec3(1., 0., 0.);\n#define SAMPLES 2\n#define CAMERA_DISTANCE 2.25\n\nstruct RSet2 {\n    mat2 q;\n    vec2 l;\n    vec4 r;\n};\n    RSet2 rset2() {\n        return RSet2(\n            mat2(1.0),\n            vec2(0.0),\n            vec4(0.0)\n        );\n    }\n\nconst vec4 rs1 = vec4(\n    3.3540e-1,   7.2490e-1,   6.9690e-1,   5.2740e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300);\nconst vec4 rs2 = vec4(\n    2.7730e-2,   5.1710e-1,   3.3970e-1,   1.0300e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300);\nconst vec4 rs3 = vec4(\n    4.4190e-1,   7.6040e-1,   7.7920e-1,   3.7080e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300);\n\nfloat randSin(float x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\n\n#define RAND randSin\n\nvec3 rvec3(float x, vec4 r1, vec4 r2, vec4 r3) {\n    return vec3(RAND(x, r1), RAND(x, r2), RAND(x, r3));\n}\n\nfloat dot2(vec3 v) {\n    return dot(v, v);\n}\n\nstruct Ray3 {\n    // base\n    vec3 b;\n    // direction\n    vec3 d;\n};\n#define eray3 Ray3(O3,O3)\n#define nray3(b,d) Ray3(b,normalize(d))\n    \nRay3 cameraRay(\n    vec3 camera,\n    vec3 focus,\n    vec3 up,\n    vec2 fov,\n    float screen,\n    vec2 uv\n) {\n    vec3 z = normalize(camera - focus);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    \n    mat3 raycaster = screen * mat3(\n        fov.x,0.,0.,\n        0.,fov.y,0.,\n        0.,0.,1.\n    ) * mat3(x, y, -z);\n    \n    Ray3 ray = nray3(\n        camera,\n        raycaster * vec3(uv, 1.)\n    );\n    \n    return ray;\n}\n\n#define Sphere3 vec4\nfloat SphereHit(Ray3 r, Sphere3 s) {\n    vec3 D = s.xyz - r.b;\n    if(length(D) <= s.w)\n        return 1.;\n    if(dot(r.d, D) < 0.)\n        return 0.;\n    float D2 = dot2(D), dD = dot(r.d, D);\n    float h = D2 / dD * sqrt(1. - dD * dD / D2);\n    return h <= s.w ? 1. : 0.;\n}\n\nmat4 SphereTrace(Ray3 r, Sphere3 s, mat3 o) {\n    vec3 D = s.xyz - r.b;\n    if(length(D) <= s.w || dot(r.d, D) < 0.)\n        return mat4(0.);\n    float D2 = dot2(D), dD = dot(r.d, D);\n    float len = dD - sqrt(dD * dD - D2 + s.w * s.w);\n    vec4 p = vec4(len * r.d + r.b, 1.);\n    vec4 z = vec4(normalize(p.xyz - s.xyz), 0.);\n    vec4 x = vec4(normalize(cross(o[1], z.xyz)), 0.);\n    vec4 y = vec4(normalize(cross(z.xyz, x.xyz)), 0.);\n    return mat4(x, y, z, p);\n}\n\nfloat ShardHit(Ray3 r, vec4 p[SHARD_PLANE_NUM]) {\n    float x, xset = 0.;\n    float n, nset = 0.;\n    for(int i = 0; i < SHARD_PLANE_NUM; i++) {\n        vec3 pn = p[i].xyz;\n        if(dot(pn, r.d) < 0.) {\n            vec3 pc = pn * p[i].w;\n            vec3 D = r.b - pc;\n            float l = -dot(pn, D) / dot(pn, r.d);\n            if(l > x || xset < .5) {\n                x = l;\n                xset = 1.;\n            }\n        }\n        else {\n            vec3 pc = pn * p[i].w;\n            vec3 D = r.b - pc;\n            float l = -dot(pn, D) / dot(pn, r.d);\n            if(l < n || nset < .5) {\n                n = l;\n                nset = 1.;\n            }\n        }\n    }\n    return x < n ? 1. : 0.;\n}\n\nmat4 ShardTrace(Ray3 r, vec4 p[SHARD_PLANE_NUM], mat3 o) {\n    float d;\n    vec3 n;\n    for(int i = 0; i < SHARD_PLANE_NUM; i++) {\n        vec3 pn = p[i].xyz;\n        if(dot(pn, r.d) < 0.) {\n            vec3 pc = pn * p[i].w;\n            vec3 D = r.b - pc;\n            float l = -dot(pn, D) / dot(pn, r.d);\n            if(l > d || i == 0) {\n                d = l;\n                n = pn;\n            }\n        }\n    }\n    vec4 t = vec4(d * r.d + r.b, 1.);\n    vec4 z = vec4(n, 0.);\n    vec4 x = vec4(normalize(cross(o[1], z.xyz)), 0.);\n    vec4 y = vec4(normalize(cross(z.xyz, x.xyz)), 0.);\n    return mat4(x, y, z, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tm = iTime * 0.25;\n    \n    const float R = 1.;\n    vec3 center = vec3(0.);\n    \n    float seeds[SHARD_PLANE_NUM];\n    for(int i = 0; i < SHARD_PLANE_NUM; i++)\n        seeds[i] = float(i * SHARD_SEED) * 3.14159265358;\n    vec4 planes[SHARD_PLANE_NUM];\n    for(int i = 0; i < SHARD_PLANE_NUM; i++) {\n        vec3 v = normalize(2. * rvec3(seeds[i], rs1, rs2, rs3) - 1.);\n        vec3 p = R * v * SHARD_SHAPE;\n        v = normalize(v * SHARD_SHAPE.yzx * SHARD_SHAPE.zxy);\n        planes[i] = vec4(v, dot(p, v));\n    }\n    /*\n    planes[0] = vec4( 1.,  0.,  0., R);\n    planes[1] = vec4( 0.,  1.,  0., R);\n    planes[2] = vec4( 0.,  0.,  1., R);\n    planes[3] = vec4(-1.,  0.,  0., R);\n    planes[4] = vec4( 0., -1.,  0., R);\n    planes[5] = vec4( 0.,  0., -1., R);\n\t*/\n    \n    vec3\n        camera = vec3(\n            CAMERA_DISTANCE * vec2(cos(tm), sin(tm)),\n            CAMERA_DISTANCE * ALTITUDE\n            //D * 2. * vec2(cos(tm), sin(tm)),\n            //D * .5\n        ),\n        focus = vec3(0., 0., .25),\n        up = vec3(0., 0., 1.);\n    vec2 fov = vec2(1.);\n    float screen = 1.;\n    \n    const int SAMPLES2 = SAMPLES * SAMPLES;\n    vec4 pixel = vec4(0.);\n    float weight = 1. / float(SAMPLES2);\n    for(int si = 0; si < SAMPLES2; si++) {\n        int sx = si / SAMPLES;\n        int sy = si - sx * SAMPLES;\n        vec2 shift = vec2(ivec2(sx, sy) + 1) / (float(SAMPLES) * 2.);\n        shift /= iResolution.x;\n        Ray3 r = cameraRay(\n            camera,\n            focus,\n            up,\n            fov,\n            screen,\n            ((uv + shift) * 2. - 1.) * vec2(1., iResolution.y / iResolution.x)\n        );\n        //if(SphereHit(r, vec4(center, R)) > 0.) {\n        //    mat4 trace = SphereTrace(r, vec4(center, R), mat3(1.));\n        if(ShardHit(r, planes) > 0.) {\n            mat4 trace = ShardTrace(r, planes, mat3(1.));\n            float n1 = 1.0003;\n            float n2 = .135;\n            //n2 = .5;\n            //n2 = n1;\n            //n2 = 1.5;\n            //n2 = .9;\n            float ci = dot(trace[2].xyz, -r.d);\n            float si = sin(acos(ci)), st = si * n1 / n2;\n            float ru;\n            if(st >= 1.)\n                ru = 1.;\n            else {\n                float ct = cos(asin(st));\n                ct = sqrt(1. - st * st);\n                float rs = (n1 * ci - n2 * ct) /\n                    (n1 * ci + n2 * ct);\n                float rp = (n1 * ct - n2 * ci) /\n                    (n1 * ct + n2 * ci);\n                ru = .5 * (rs * rs + rp * rp);\n            }\n            float cf = 1. - ci;\n            float ce = exp(8. * cf * cf);\n            //ru = mix(ce / (ce + 4.), 1., 0.);\n            //ru = 1.;\n            //ru *= 5.;\n            r = Ray3(\n                trace[3].xyz,\n                r.d - 2. * dot(r.d, trace[2].xyz) * trace[2].xyz\n            );\n            pixel += weight * ru * texture(iChannel0, r.d.xzy) * vec4(SHARD_COLOR, 1.);\n        }\n        else\n            pixel += weight * texture(iChannel0, r.d.xzy);\n    }\n\n    // Output to screen\n    fragColor = pixel;\n}","name":"Image","description":"","type":"image"}]}