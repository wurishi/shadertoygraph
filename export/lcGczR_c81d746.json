{"ver":"0.1","info":{"id":"lcGczR","date":"1731406917","viewed":79,"name":"Yet another Noise","username":"lchaumartin","description":"Yet another Hash fonction in GLSL. Based on XOR and shift operators. The idea was to get consistent random values for any input range : float between 0 and 1 as well as integer values.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["noise","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float p)\n{\n    uint uFactor = floatBitsToUint(p);\n    uFactor ^= uFactor >> 17u;\n    uFactor ^= uFactor << 5u;\n    uFactor ^= uFactor >> 17u;\n    uFactor ^= uFactor << 5u;\n    uFactor ^= uFactor >> 17u;\n    uFactor ^= uFactor << 5u;\n    return fract(float(uFactor) / 4294967296.0);\n}\n\nfloat hash(vec2 p)\n{\n    return hash(fract(p.x *(0.5 + hash(p.y))));\n}\n\nvec2 hash2(vec2 p)\n{\n    return vec2(hash(p), hash(p+1.0));\n}\n\nvec3 hash3(vec2 p)\n{\n    return vec3(hash2(p), hash(p+2.0));\n}\n\nfloat fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 p) {\n    // Compute grid cell coordinates\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Fade curves for each axis\n    vec2 u = vec2(fade(f.x),fade(f.y));\n\n    // Compute gradient contributions from the four corners\n    float n00 = hash(i + vec2(0.0, 0.0));\n    float n10 = hash(i + vec2(1.0, 0.0));\n    float n01 = hash(i + vec2(0.0, 1.0));\n    float n11 = hash(i + vec2(1.0, 1.0));\n\n    // Bilinear interpolation\n    float nx0 = mix(n00, n10, u.x);\n    float nx1 = mix(n01, n11, u.x);\n    return mix(nx0, nx1, u.y); // Final noise value\n}\n\nfloat perlinNoise(vec2 p, int octaves, float persistence) {\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n\n    for (int i = 0; i < octaves; i++) {\n        total += perlinNoise(p * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    return total / maxValue; // Normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.05 + (1.0 + sin(iTime))*0.5*0.95;\n    vec2 uvI = floor((fragCoord - 0.5 * iResolution.xy) * zoom + 0.5 * iResolution.xy + iTime*120.0);\n    vec2 uvS = ((fragCoord - 0.5 * iResolution.xy) * zoom + 0.5 * iResolution.xy + iTime*120.0);\n    vec3 col;\n    if(fragCoord.x < iMouse.x)\n        col = vec3(hash(uvI));\n    else\n        col = vec3(perlinNoise(uvS, 4, 0.5));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}