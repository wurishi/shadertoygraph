{"ver":"0.1","info":{"id":"MtGyW3","date":"1537922459","viewed":273,"name":"Signed Distance to Polygon","username":"nr4","description":"Filled 2d Polygons. Suggestions for optimization welcome :)\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","polygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Signed Distance to Polygon\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Got rid of the if(.) by using step functions\n\n// (Un)Comment this for different look\n#define DRAW_GEOMETRY\n// More points = cooler\n#define N 32\n\n// Global constants\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Distance to line segment\nfloat lineseg(vec2 x, vec2 p1, vec2 p2)\n{\n    vec2 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\n// Standard shadertoy fill color\nvec3 col(vec2 uv, float o)\n{\n    return 0.5 + 0.5*cos(o+uv.xyx+vec3(0,2,4));\n}\n\n// Distance to specific polygon\nfloat polygon(vec2 x)\n{\n    vec2 pts[N];\n\tfloat ret = 1., n = 0.;\n    \n    for(float i=0.; i<float(N); i+=1.)\n    \tpts[int(i)] = -.5*c.xx+vec2(1.5*rand(i*c.xx)+.25*cos(rand(3.*i*c.xx)*iTime), rand(2.*i*c.xx)+.25*sin(rand(3.*i*c.xx)*iTime));\n    \n    for(int i=0; i<N; ++i)\n    {\n        int ip1 = int(mod(float(i+1), float(N)));\n        vec2 k = x-pts[i], d = pts[ip1]-pts[i];\n        \n        float beta = k.y/d.y,\n            alpha = d.x*k.y/d.y-k.x;\n        \n        n += step(0., beta)*step(beta, 1.)*step(0., alpha);\n        ret = min(ret, lineseg(x, pts[i], pts[ip1]));\n    }\n    \n    return mix(ret, -ret, mod(n, 2.));\n}\n\n// Add objects to scene with proper antialiasing\nvec4 add(vec4 sdf, vec4 sda)\n{\n    return vec4(\n        min(sdf.x, sda.x), \n        mix(sda.gba, sdf.gba, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, sda.x))\n    );\n}\n\n// Add the polygon to a scene\nvec4 scene(vec2 x)\n{\n    vec4 sdf = vec4(polygon(x), col(x, 3.+iTime));\n    sdf = add(sdf, vec4(stroke(sdf.x, .003), col(x, 5.+iTime)));\n    return sdf;\n}\n\n// Draw everything\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    vec4 s = scene(uv);\n\tvec3 col = \n#ifdef DRAW_GEOMETRY\n        mix(s.gba,\n#endif\n            mix(col(uv, iTime), col(uv, 1.+iTime), .5+.5*sign(s.x))\n            *smoothstep(1.5/iResolution.y, -1.5/iResolution.y, .001*sin(2.*pi*50.*s.x))\n#ifdef DRAW_GEOMETRY\n            , \n            smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, s.x)\n           )\n#endif\n    \t;\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}