{"ver":"0.1","info":{"id":"MX3GD8","date":"1716412027","viewed":139,"name":"Ball Physics 2D","username":"spalmer","description":"Simulation of ball shaped bodies solves normal and frictional impulses. Fork of TDM's toy, simplifying the physics.  Mouse interact.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["2d","collision","simulation","ball","bounce","dynamics","solver","physics","roll","rigidbody","angular","friction","leapfrog","elasticity"],"hasliked":0,"parentid":"NtlGz7","parentname":"2D Physics (balls)"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nfork of TDM 2D Physics (balls) http://shadertoy.com/view/NtlGz7 - CCA NC-SA 3.0\nrefactored, simplified by spalmer\nsee Common for license details (where the TDM code mostly resides)\n*/\n/*\nCommon    : shared\nBuffer A  : dynamics\nBuffer B  : collisions\nImage     : render\n*/\n\n/*\n  Render\n*/\n\nfloat circle(vec2 p, vec2 c, float w, float x) \n{\n    float dist = w - length(p - c),\n        aa = dot(fwidth(p), vec2(1));\n    return clamp(dist / aa + x, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 r = iResolution.xy,\n        q = (2. * fragCoord - r) / r.y;\n    vec3 c = vec3(mix(.7, 1., circle(q, vec2(0), frameSize, .5)));    \n    for (int i = 0; i < nBalls; ++i) {\n        Body body = getBody(iChannel0, i);\n        float ra = ballSize,\n            ba = circle(q, body.pos, ra, .5);\n        vec2 qa = q - body.pos;\n        qa = rot(qa, -body.ori);\n        float tau = radians(360.), //2. * pi,\n            a = tau / 5.;\n        // angular domain repetition\n        qa = rot(qa, -a * round(atan(qa.y, qa.x) / a));\n        vec2 o = vec2(ra * .5, 0);\n        ba *= 1. - circle(qa * vec2(ra/.3, 1), o, ra * .1, 0.);\n        vec3 bc = .2 * cos(vec3(0,2,4) - sqrt(1.25) * float(i)) + .04; //vec3(.5,0,.3);\n        c = mix(c,bc,ba);\n    }\n    fragColor = vec4(sqrt(c), 1.); // OETF\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n * code from \"2D Physics (balls)\" by TDM  http://shadertoy.com/view/NtlGz7\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n \n// all spalmer code here (not in original TDM toy) is also CCA BY-NC-SA 3.0\n// http://creativecommons.org/licenses/by-nc-sa/3.0/\n\n// can be fun with fewer balls\n// with more balls, exhibits problems with nonphysical behaviors and jittering when stacked  :octopus:\n// I think the lack of the extra collision pass is probably the culprit?\n// yeah it's way better with the extra pass, so I put it back in.\n// Something weird still seems to be going on though!\n// idk if it needs more substepping, my guess is either\n// lack of a proper global constraint solver, or\n// perhaps I broke something, because I don't think TDM's toy did this.\n// Nevermind, even TDM's gets a little funky past about 30 balls, even with flat floor.\n// I'll hunt for it.  In mean time probably shouldn't increase nBalls past maybe 12..\n// if you change any of this, you should reset the toy.\nconst int nBalls = 4;\nconst float\n    ballSize = .2,\n    ballMass = .3,\n    elasticity = .85,\n    friction = .7, // added by spalmer\n    frameSize = .95;\nconst vec2 gravity = vec2(0,-2);\n//const float maxVelocity = 4.; // disabled\n// simple antisymmetric product\nfloat cross2(vec2 a, vec2 b) \n{\n    return a.x * b.y - a.y * b.x; // aka cross(vec3(a,0), vec3(b,0)).z\n}\n// similar for (pseudo)scalars\n/*vec2 cross2(vec2 a, float b) \n{\n    return vec2(a.y * b, a.x * -b);\n}*/\nvec2 cross2(float a, vec2 b) \n{\n    return vec2(b.y * -a, b.x * a);\n}\n/*vec2 perp(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}*/ // == cross2(v, 1.)\n\nvec2 rot(vec2 v, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec2(\n        v.x * c - v.y * s,\n        v.x * s + v.y * c);\n}\n\nstruct Body \n{\n    vec2 pos; // linear position\n    vec2 vel; // linear velocity\n    float ori; // angular orientation\n    float spin; // angular velocity\n    float imass; // 1. / mass\n    float imom; // inverse moment of inertia tensor\n    // TODO per-ball radius, shape fn\n    // momentum is actually what is conserved, not velocity;\n};\n\n#define fetch(ch, x, y) texelFetch(ch, ivec2(x,y), 0)\n\nBody getBody(sampler2D ch, int i) \n{\n    vec4 d0 = fetch(ch, i, 0),\n         d1 = fetch(ch, i, 1);\n    Body b;\n    b.pos = d0.xy;\n    b.vel = d0.zw;\n    b.ori = d1.x;\n    b.spin = d1.y;\n    b.imass = d1.z;\n    b.imom = d1.w;\n    return b;\n}\n\n// obtain velocity of point on body at local location\nvec2 velAt(in Body b, vec2 at)\n{\n    return b.vel + cross2(b.spin, at);\n}\nvoid addVel(inout Body b, vec2 at, vec2 impulse)\n{\n    b.vel += b.imass * impulse;\n    b.spin += b.imom * cross2(at, impulse); // cross will likely duplicate work done elsewhere, but optimizer should recombine\n}\n\n// iapafoto has an excellent toy http://shadertoy.com/view/slXGRH\n// which mentions the following page:\n// TODO see http://en.wikipedia.org/wiki/Collision_response\n// x' = \"new timestep value\", v^ = vector v, [s] = subscript, x^-1 = inverse for matrix or reciprocal for scalar\n// just jotting down their collision response formula, transformed to raw ansi:\n// (1a)  v'[1] = v[1] - j[r] / m[1] * n^\n// (1b)  v'[2] = v[2] + j[r] / m[2] * n^\n// (2a)  w'[1] = w[1] - j[r] * I[1]^-1 * cross(r[1], n^)\n// (2b)  w'[2] = w[2] + j[r] * I[2]^-1 * cross(r[2], n^)\n// (3)  v[pi] = v[i] + cross(w[i], r[i])\n// (4)  dot(v'[r], n) = -e * dot(v[r], n)\n// (5)  j[r] = -(1 + e) * dot(v[r], n) / (m[1]^-1 + m[2]^-1 + dot(\n//                cross(I[1]^-1 * cross(r[1], n^), r[1]) + \n//                cross(I[2]^-1 * cross(r[2], n^), r[2])\n//                , n))\n\n// then simply apply impulse j[r] to both bodies which is also a bit tricky\n// but 5 there is an absolute doozy!  I'm unsure I got the order of operations right on the cross vs. matrix mul.\n// anyway the I[r]^-1 imom tensor must be transformed to a common world orientation for a 3d system.\n// plagiarizing a bit here, but it says apparently the previous list of steps is wildly out of order:\n/*\nto compute post-collision linear velocities v′[i] and angular velocities w′[i]:\n\n (1)  Compute reaction impulse magnitude j[r] in terms of v[r], m[1], m[2], I[1], I[2], r[1], r[2], n^ normal vector and e elasticity using equation (5)\n (2)  Compute reaction impulse vector j^[r] in terms of its magnitude j[r] and contact normal n^ using j^[r] = j[r] n^.\n (3)  Compute new linear velocities v'[i] in terms of old velocities v[i], masses m[i] and reaction impulse vector j^[r] using equations (1a) and (1b)\n (4)  Compute new angular velocities w′[i] in terms of old angular velocities w[i], inertia tensors I[i] and reaction impulse j[r] using equations (2a) and (2b)\n*/\n// anyway then the cross products devolve in 2D to produce something like what's in impulse / impulse2\n// I think I can clean it up some more, perhaps.  I'll try.\n\n// to start, in 2d, (5) would become (5b)\n// cross2 returns a scalar, dot would want a vector, maybe that just becomes a multiply?  Hrmm.\n// (5b)  j[r] = -(1 + e) * dot(v[r], n) / (m[1]^-1 + m[2]^-1 + dot(\n//                cross2(I[1]^-1 * cross2(r[1], n^), r[1]) + \n//                cross2(I[2]^-1 * cross2(r[2], n^), r[2])\n//                , n))\n\n// and for just one object vs. immovable world,\n// (5c)  j[r] = -(1 + e) * dot(v[r], n) / (m[1]^-1 + dot(\n//                cross2(I[1]^-1 * cross2(r[1], n^), r[1])\n//                , n))\n\n// let's go the other way, take (1 + e) * dot(n, rv) / (imass + cross2(at, n) * cross2(at, n) * imom)\n// in wpedia terms, that's (1 + e) * dot(n^, v^) / (m[1]^-1 + cross2(r[1], n^)^2 * I[1]^-1) where v^ is rel vel\n// ok but how does TDM go from cross to cross2 and recombine like that?\n// dot(cross2(I[1]^-1 * cross2(r[1], n^), r[1]), n^) --> cross2(r[1], n^)^2 * I[1]^-1\n\n// in these situations it typically pays to envision the 3d case but anchored about the z axis\n// and treat cross(a, b) as vec3(cross2(a.yz, b.yz), cross2(a.xz, b.xz), cross2(a.xy, b.xy))\n// so anchoring z means simply ignoring the .x and .y terms of the 3d cross() result\n// and only using the .z term of the output vector, multiplying all .z inputs by zero.\n// what happens is the term briefly becomes imaginary and then converts back.\n// one of the crosses winds up being a cross of a scalar with a vector, which maps\n// to one of the scalar arg cross2 cases, the scalar multiplies are actually\n// commutative so can just put them both on the same side once it all folds out I guess.\n// so the first Qa = cross2(r[1], n^) takes 2 vectors and produces a (pseudo)scalar\n// and the Qb = I[1]^-1 * Qa, inertia tensor in 2d is just a scalar, inverse inertia tensor is (pseudo?)scalar\n// and Qc = cross2(Qb, r[1]) has a (pseudo)scalar left argument and vector right argument\n\n// writing out all the original (5c) componentwise\n/*\nfloat Qa = cross2(r[1], n^) = at.x * n.y - at.y * n.x\nfloat Qb = I[1]^-1 * Qa = imom * Qa\nvec2 Qc = cross2(Qb, r[1]) = vec2(at.y * -Qb, at.x * Qb)\nfloat Qd = dot(Qc, n) = Qc.x * n.x + Qc.y * n.y\nif expand Qd all the way out, becomes\nQb = imom * (at.x * n.y - at.y * n.x)\nQd = at.y * -Qb * n.x + at.x * Qb * n.y\nj[r] = -(1 + e) * (v[r].x * n.x + v[r].y * n.y) / (imass + Qd)\n*/\n\n// anyway TDM calls j[r] lambda and winds up with Qd = Qa * Qa * imom\n// which I just think is magic\n\n// but Maxima agrees:\n/*\n(%i1)\tQa : at_x * n_y - at_y * n_x;\n(Qa)\tat_x*n_y-at_y*n_x\n(%i2)\tQb : imom * Qa;\n(Qb)\timom*(at_x*n_y-at_y*n_x)\n(%i3)\tQd : at_y * -Qb * n_x + at_x * Qb * n_y;\n(Qd)\tat_x*imom*n_y*(at_x*n_y-at_y*n_x)-at_y*imom*n_x*(at_x*n_y-at_y*n_x)\n(%i4)\tratsimp(Qd - Qa * Qa * imom);\n(%o4)\t0\n\n// :shrug: my vector algebra is weak, apparently I rely upon a primitive form of A.I. lol\n*/\n\n/* // unused here in 2d but stashing this stub for posterity\n// see, in 3d, the body-local inertia tensor must be transformed to world orientation\n// (transforming the other way is just more complicated)\n// and this transformation of one matrix in terms of another must be done in\n// a particular way or the mass transfer doesn't work off-axis correctly.\n// so just showing how it would be done in 3d, suggesting one way to do it anyhow.\n// but in 3d you'd have the orientation matrix handy, and use matrix result instead of float.\n// In 2d, things are much simpler, and none of this is required.\n// the scalar inverse inertia tensor would simply remain unchanged by such a 2d rotation/unrotation.\n// pretty much wherever you see b.imom, you'd use imomw(b) instead\nfloat imomw(Body b) // returns mat3 in 3d\n{\n    float R = 1.; // body orientation matrix in 3d\n    return R * b.imom * (1./R); //R * b.imom * transpose(R); //\n} */\n\n// refactored from collisionWith*\n\nfloat impulse(inout Body b0, float K, vec2 at, vec2 i, float lmin, float lmax)\n{\n    vec2 v0 = velAt(b0, at),\n        rv = v0;\n    float w1 = cross2(at, i),\n        a = K * dot(i, rv),\n        b = b0.imass + w1 * w1 * b0.imom,\n        lambda = clamp(-a / b, lmin, lmax);\n    addVel(b0, at, lambda * i);\n    return lambda;\n}\n\nfloat impulse2(inout Body b0, inout Body b1, float K, vec2 at, vec2 i, float lmin, float lmax)\n{\n    vec2 v0 = velAt(b0,  at),\n         v1 = velAt(b1, -at),\n        rv = v0 - v1;\n    float w1 = cross2(at, i),\n        w2 = -w1, //cross2(-at, normal),\n        a = K * dot(i, rv),\n        b = b0.imass +\n            b1.imass +\n            w1 * w1 * b0.imom +\n            w2 * w2 * b1.imom,\n        lambda = clamp(-a / b, lmin, lmax);\n    i *= lambda;\n    addVel(b0, at, i); //lambda * w1,  i); // at,\n    addVel(b1,-at, i); //lambda * w2, -i); //-at,\n    return lambda;\n}\n\n// can use same impulse2 for both cases, using a Body with infinite mass i.e. zero imass and imom;\n// can't be const, due to usage, but should never actually be moved, so is effectively const; idk if optimizer will realize this\n// I tried it and it works!  Uncomment the calls in collisionWithPlane below.\nBody infmass = Body(vec2(0), vec2(0), 0., 0., 0., 0.);\n       \n// now when I do rigid body physics, I typically try to combine the\n// normal and friction forces and apply one combined impulse;\n// TDM does them sequentially, I'm unsure if that's key or can be optimized.\n// Since they were sequential yet shared code, I refactored them,\n// but that actually makes it harder to recombine in some ways.\n// It does, however highlight the fact that the same general algo is being done twice here.\n// Much of the noninterpenetration/frictioncone clamping only works this way in 2d, anyway.\n// I'm still thinking of the best way to clean this up.\n// If anyone has any ideas, fork away!\n    \nvec2 collisionWithPlane(inout Body b0, vec3 plane) \n{\n    vec2 normal = normalize(plane.xy);\n    float dist = dot(b0.pos, normal) + plane.z,\n        penetration = ballSize - dist;\n    if (penetration < 0.) \n        return vec2(0);\n    vec2 r0 = -ballSize * normal;\n    // normal\n    float lambda = impulse(b0, 1. + elasticity, r0, normal, 0., 9e9);\n    //float lambda = impulse2(b0, infmass, 1. + elasticity, r0, normal, 0., 9e9);\n    // friction\n    vec2 tangent = cross2(-1., normal); //perp(normal); //cross2(normal, 1.); //vec2(normal.y, -normal.x); //\n    impulse(b0, friction, r0, tangent, -lambda, lambda);\n    //impulse2(b0, infmass, friction, r0, tangent, -lambda, lambda);\n    return normal * penetration;\n}\n\nvec2 collisionWithBody(inout Body b0, in Body b1) \n{\n    vec2 normal = b0.pos - b1.pos;\n    float dist = length(normal),\n        ra = ballSize,\n        penetration = 2. * ra - dist;\n    if (penetration < 0. || penetration > 1.99 * ra)\n        return vec2(0);\n    normal /= dist;\n    vec2 r0 = -ra * normal,\n        r1 = -r0; //ra * normal;\n    // normal\n    float lambda = impulse2(b0, b1, 1. + elasticity, r0, normal, 0., 9e9);\n    // friction\n    vec2 tangent = cross2(-1., normal);\n    impulse2(b0, b1, friction, r0, tangent, -lambda, lambda);\n    float m0 = 1./b0.imass, m1 = 1./b1.imass;\n    float response =\n        //.5 // HACK assume equal masses\n        m1 / (m0 + m1) // simpler\n        //1. / (b1.imass * (1. / b0.imass + 1. / b1.imass))\n        ;\n    return penetration * response * normal;\n}\n\n// not a proper constraint solver so enough stacking will get jittery and weird.\n// even with 2 passes of collision (Buffer B and C) it still only stacks so high.\n// TODO Erleben shock propagation?\nvoid solve(sampler2D data, inout Body b0, int id)\n{\n    vec2 displace = vec2(0);    \n    // inter-ball collision detection\n    for (int i = 0; i < nBalls; ++i) {\n        if (i == id)\n            continue;        \n        Body b1 = getBody(data, i);\n        displace += collisionWithBody(b0, b1);\n    }    \n    // new round enclosure\n    displace += collisionWithPlane(b0, vec3(-normalize(b0.pos), frameSize));\n    b0.pos += displace;\n}\n\nvoid storeBody(int id, in Body b, inout vec4 c, ivec2 fc) \n{\n    if (fc.x != id)\n        return;\n    if (fc.y == 0)\n        c = vec4(b.pos, b.vel);\n    else if (fc.y == 1)\n        c = vec4(b.ori, b.spin, b.imass, b.imom);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nDynamics\n*/\n\n// TODO for previews, should alter things so it keeps bouncing more.\n\nvoid initBody(int id, inout Body b) \n{\n    b.pos = vec2(-.5 + float(id) / float(nBalls),.1 * sin(float(5*id))); //rnd.xy * .4;\n    b.vel = vec2(0,3); //cross2(1., b.pos) * 2.;\n    b.spin = 9. - 18. * fract(3. * iDate.w * float(id));\n    float r = ballSize; // radius // sqrt(mass / pi / density)\n    float m = ballMass; // mass // pi * r * r\n    //m *= 1. / float(id + 1); // stress test: unequal masses\n    b.imass = 1. / m;\n    float it = .5 * m * r * r; // I = 1/2 m r² ; 2D inertia tensor for disc/cylinder\n    b.imom = 1. / it;\n}\n    //vec3 rnd = sin(float(id) * vec3(9,7,5)); //\n\nvec2 mouseForce(vec2 x, vec2 v) \n{\n    if (iMouse.z < .5)\n        return vec2(0);\n    vec2 r = iResolution.xy,\n        m = (2. * iMouse.xy - r) / r.y,\n        d = x - m;\n    float p = dot(d,d);\n    if (p < ballSize * ballSize) return vec2(0); \n    return -2. * d / p;\n}\n\nvoid mainImage(out vec4 o, vec2 fc)\n{\n    int id = int(fc.x);\n    if (id >= nBalls)\n        discard;\n    \n    Body body = getBody(iChannel0, id);\n    if (iFrame == 0\n        || ((iFrame & 1023) == 0 && iMouse == vec4(0)) \n        )\n        initBody(id, body);\n    \n    float dt = min(iTimeDelta, .07); // clamp to 14fps\n    // save for integration technique\n    vec2 priorvel = body.vel;\n    float priorspin = body.spin; // no extra spin gets added here though..\n    // integrate forces\n    vec2 force = mouseForce(body.pos, body.vel);\n    vec2 acc = force * body.imass + gravity; // acceleration\n    // seems the details of the integrator aren't particularly important;\n    // what's important for this toy is the addVel response be correct,\n    // and collisions correct.  With more stacking or weird forces, may matter.\n  #if 1\n    // I'm fairly sure now that this is actually Leapfrog integration technique.\n    // I believe there's a half-timestep offset missing in the documentation somewhere here.\n    // IF one assumes the velocities are actually stored at - 1/2 timestep vs positions, then it\n    // does seem to fit http://en.wikipedia.org/wiki/Leapfrog_integration#Algorithm\n    body.vel += dt * acc;\n    \n    /* // limit max velocity\n    float len2 = dot(body.vel,body.vel);\n    if (len2 > maxVelocity * maxVelocity)\n        body.vel *= inversesqrt(len2) * maxVelocity;*/\n\n    body.pos += .5 * dt * (priorvel  + body.vel );\n    body.ori += .5 * dt * (priorspin + body.spin); // priorspin and body.spin are always the same though, so is equivalent to += dt * body.spin\n    // anyway it works real well.\n  #else\n    // simplest possible Euler integrator\n    body.vel += dt * acc;\n    body.pos += dt * body.vel;\n    body.ori += dt * body.spin;\n    // not particularly stable but suffices for this toy, as \n    // timestep is small enough compared to ball size, speed, stacking\n  #endif\n  \n    // wth is that ... not leapfrog, is it?\n    // v[n+1] = v[n] + t * f(n)\n    // x[n+1] = x[n] + t * (v[n+1] + v[n])/2\n    // appears to be by velocity Verlet or possibly Trapezoidal rule based somehow\n    // midpoint maybe, it's 2nd order, stable, probably implicit, \n    // but the order of evaluation and particular coeffs are unfamiliar.\n    // perhaps one of you can help me identify it!\n    // Wikipedia these days is using a scheme to describe these which doesn't parse well for me.\n    // http://en.wikipedia.org/wiki/List_of_numerical_analysis_topics#Numerical_methods_for_ordinary_differential_equations\n    // at this point I'm thinking it's actually just Leapfrog with velocity timestep offsets not labeled properly?\n    // perhaps Leapfrog with velocities *actually* stored on the even timesteps\n    // and then \"interpolated\" for purposes of doing the leapfrogging.\n    // Quite puzzling actually.  I kind of like it!  must grok it better.\n       \n    o = vec4(0);\n    storeBody(id, body, o, ivec2(fc));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nCollision solver\n*/\n\n// NOTE:  stacking works better with extra collision pass in Buffer C.\n\nvoid mainImage(out vec4 o, vec2 fc) \n{\n    int id = int(fc.x);\n    if (id >= nBalls) discard;\n    \n    // solve collisions\n    Body body = getBody(iChannel0, id);\n    solve(iChannel0, body, id);\n    \n    // store\n    o = vec4(0);\n    storeBody(id, body, o, ivec2(fc));\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\nCollision solver - pass 2\n*/\n\n// NOTE:  stacking worked better with extra collision pass in Buffer C.\n// note the slight jitter when balls touch, presently!\n// I'm leaving it because the point of this toy is to simplify.\n\nvoid mainImage(out vec4 o, vec2 fc) \n{\n    int id = int(fc.x);\n    if (id >= nBalls) discard;\n    \n    // solve collisions\n    Body body = getBody(iChannel0, id);\n    solve(iChannel0, body, id);\n    \n    // store\n    o = vec4(0);\n    storeBody(id, body, o, ivec2(fc));\n}\n","name":"Buffer C","description":"","type":"buffer"}]}