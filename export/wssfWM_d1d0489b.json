{"ver":"0.1","info":{"id":"wssfWM","date":"1593551334","viewed":192,"name":"Color Your Planet","username":"lz","description":"Started as a drawing tool for my 5 years old daughter. Evolved to a planet texturing concept.\nCreate diffuse, specular and height maps. It's possible to save and load maps for future use.\nThe 3D is very basic. Intended for full screen. See Buffer C.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d","3d","paint","drawing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Color Your Planet, Final drawing image.\n    please see Documentation in Buffer C.\n*/\n\n#define ORIGIN_ORBIT_DISTANCE 1.75\n\n#define VELOCITY_FACTOR 50.\n#define SCALE_VELOCITY(v) 1 + int(v*VELOCITY_FACTOR)\n\n#define INV_CHAR_DEPTH 0.0625\n#define _CHAR(start, size, uv, ch) pos = clamp(uv, start,  start+size); col += texture(iChannel3, (ch+(pos-start)/size)*INV_CHAR_DEPTH);    \n\n#define _SPACE vec2(0.,13.)\n#define _      vec2(0.,13.)\n#define _dot   vec2(14.,13.)\n\n#define _0 vec2(0.,12.)\n#define _1 vec2(1.,12.)\n#define _2 vec2(2.,12.)\n#define _3 vec2(3.,12.)\n#define _4 vec2(4.,12.)\n#define _5 vec2(5.,12.)\n#define _6 vec2(6.,12.)\n#define _7 vec2(7.,12.)\n#define _8 vec2(8.,12.)\n#define _9 vec2(9.,12.)\n\n#define _A vec2(1., 11.)\n#define _B vec2(2., 11.)\n#define _C vec2(3., 11.)\n#define _D vec2(4., 11.)\n#define _E vec2(5., 11.)\n#define _F vec2(6., 11.)\n#define _G vec2(7., 11.)\n#define _H vec2(8., 11.)\n#define _I vec2(9., 11.)\n#define _J vec2(10., 11.)\n#define _K vec2(11., 11.)\n#define _L vec2(12., 11.)\n#define _M vec2(13., 11.)\n#define _N vec2(14., 11.)\n#define _O vec2(15., 11.)\n#define _P vec2(0., 10.)\n#define _Q vec2(1., 10.)\n#define _R vec2(2., 10.)\n#define _S vec2(3., 10.)\n#define _T vec2(4., 10.)\n#define _U vec2(5., 10.)\n#define _V vec2(6., 10.)\n#define _W vec2(7., 10.)\n#define _X vec2(8., 10.)\n#define _Y vec2(9., 10.)\n#define _Z vec2(10., 10.)\n\n#define _a vec2(1., 9.)\n#define _b vec2(2., 9.)\n#define _c vec2(3., 9.)\n#define _d vec2(4., 9.)\n#define _e vec2(5., 9.)\n#define _f vec2(6., 9.)\n#define _g vec2(7., 9.)\n#define _h vec2(8., 9.)\n#define _i vec2(9., 9.)\n#define _j vec2(10., 9.)\n#define _k vec2(11., 9.)\n#define _l vec2(12., 9.)\n#define _m vec2(13., 9.)\n#define _n vec2(14., 9.)\n#define _o vec2(15., 9.)\n#define _p vec2(0., 8.)\n#define _q vec2(1., 8.)\n#define _r vec2(2., 8.)\n#define _s vec2(3., 8.)\n#define _t vec2(4., 8.)\n#define _u vec2(5., 8.)\n#define _v vec2(6., 8.)\n#define _w vec2(7., 8.)\n#define _x vec2(8., 8.)\n#define _y vec2(9., 8.)\n#define _z vec2(10., 8.)\n\n#define _COLON vec2(10., 12.)\n#define _CS vec2(8., 13.)\n#define _CE vec2(9., 13.)\n#define _EQ vec2(13., 12.)\n#define _PLUS vec2(11., 13.)\n#define _MINUS vec2(13., 13.)\n#define _COMMA vec2(12., 13.)\n\n\n#define _DRAW vec2[10](_D, _R, _A, _W, _X, _X, _X, _X, _X, _X)\n#define _ERASE vec2[10](_E, _R, _A, _S, _E, _X, _X, _X, _X, _X)\n#define _VELOCITY vec2[10](_V, _E, _L, _O, _C, _I, _T, _Y, _X, _X)\n#define _ERP vec2[10](_E, _R, _P, _X, _X, _X, _X, _X, _X, _X)\n#define _GUI vec2[10](_G, _U, _I, _X, _X, _X, _X, _X, _X, _X)\n#define _SIMULATION vec2[10](_S, _I, _M, _U, _L, _A, _T, _I, _O, _N)\n#define _SHAPE_TEXT vec2[10] (_S, _h, _a, _p, _e, _X, _X, _X, _X, _X)\n#define _OVERRIDE_TEXT vec2[10] (_O, _p, _e, _r, _a, _t, _i, _o, _n, _X)\n#define _3D_TEXT vec2[10] (_3, _D, _X, _X, _X, _X, _X, _X, _X, _X)\n#define _TEXTURES vec2[10] (_T, _E, _X, _T, _U, _R, _E, _S, _X, _X)\n\n#define _DIFFUSEMAP vec2[10] (_C, _o, _l, _o, _r, _, _M, _a, _p, _X)\n#define _HEIGHTMAP vec2[10] (_H, _e, _i, _g, _h, _t, _, _M, _a, _p)\n#define _SPECULAR vec2[10] (_S, _p, _e, _c, _u, _l, _a, _r, _X, _X)\n#define _SECONDARY vec2[10](_S, _e, _c, _o, _n, _d, _a, _r, _y, _COLON)\n\n#define _INSTRUCTIONS vec2[32](_I, _N, _S, _T, _R, _U, _C, _T, _I, _O, _N, _S, _COLON, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X, _X)\n#define _I1 vec2[32](_1, _dot, _, _S, _e, _t, _, _R, _a, _d, _i, _u, _s, _, _a, _n, _d, _, _d, _r, _a, _w, _, _a, _, _p, _a, _t, _h, _dot, _X, _X)\n#define _I15 vec2[32](_, _, _, _CS, _U, _s, _e, _, _D, _R, _A, _W, _, _a, _n, _d, _, _E, _R, _A, _S, _E, _, _m, _o, _d, _e, _s, _CE, _dot, _dot, _X)\n#define _I2 vec2[32](_2, _dot, _, _M, _a, _r, _k, _, _v, _e, _l, _o, _c, _i, _t, _y, _, _o, _n, _, _a, _, _p, _a, _t, _h, _dot, _X, _X, _X, _X, _X)\n#define _I3 vec2[32](_, _, _, _R, _a, _d, _i, _u, _s, _, _a, _f, _f, _e, _c, _t, _s, _, _a, _p, _p, _l, _i, _e, _d, _, _a, _r, _e, _a, _dot, _X)\n#define _I4 vec2[32](_, _, _, _M, _a, _y, _, _a, _f, _f, _e, _c, _t, _, _p, _e, _r, _f, _o, _r, _m, _a, _n, _c, _e, _dot, _m, _a, _n, _s, _dot, _X)\n#define _I5 vec2[32](_3, _dot, _, _M, _a, _r, _k, _, _R, _e, _f, _a, _c, _t, _o, _r, _y, _, _p, _e, _r, _i, _o, _d, _, _CS, _E, _R, _P, _CE, _dot, _X)\n#define _I6 vec2[32](_4, _dot, _, _S, _t, _a, _r, _t, _, _s, _i, _m, _u, _l, _a, _t, _i, _o, _n, _, _b, _y, _, _c, _l, _i,_c, _k, _i, _n, _g, _X)\n#define _I7 vec2[32](_, _, _, _o, _n, _, _t, _h, _e, _, _c, _r, _e, _a, _t, _e, _d, _, _p, _a, _t, _h, _dot, _d, _, _CS, _E, _R, _P, _CE, _dot, _X)\n\n#define _I8 vec2[32](_U, _s, _e, _, _r, _a, _d, _i, _o, _, _b, _u, _t, _t, _o, _n, _, _f, _o, _r, _, _d, _i, _f, _f, _e, _r, _e, _n, _t, _n, _X)\n#define _I9 vec2[32](_m, _o, _d, _e, _s, _dot, _d, _i, _o, _, _b, _u, _t, _t, _o, _n, _, _f, _o, _r, _, _d, _i, _f, _f, _e, _r, _e, _n, _t, _n, _X)\n\n\nvec4 drawLetter(in vec2 uv, in vec2 start, in float size, vec2 letter)\n{\n    vec4 col;\n    vec2 pos;\n    \n    vec2 inbound = step(start, uv) - step(start + vec2(size), uv);\n    \n    if (inbound.x*inbound.y > 0.5)\n    {\n    \t_CHAR(start, size, uv, letter);\n    \tcol.g = col.b = col.r;\n    \tcol.w = col.r*0.7;\n    }\n    return col;\n}\n\nvec4 drawTextHorizontal(in vec2 uv, in vec2 start, in float lsize, in vec2 _text[10], in int _tsize)\n{\n    vec4 tcol;\n    \n    for (int i_letter = 0; i_letter < _tsize; i_letter++)\n    {\n        tcol += drawLetter(uv, start + float(i_letter)*vec2(lsize*.5, 0.), lsize, _text[i_letter]);\n    }\n    \n    return clamp(tcol, 0., 1.);\n}\n\nvec4 mainMenuButton(in vec2 uv, in vec2 min_b, in vec2 max_b, in float _val, in float n)\n{\n    vec2 center = (min_b + max_b)*0.5;\n    vec2 size1 = (max_b - min_b) * 0.5;\n    vec2 frame = size1*vec2(0.98, 0.93);\n    \n    float ratio = iResolution.x / iResolution.y;\n    vec2 scl_uv = uv;\n    scl_uv.x *= ratio;\n    \n    vec3 background = vec3(0.18, 0.18, 0.18);\n    \n    float inside = step(sdBox(uv - center, frame) - 0.01*frame.x, 0.);\n    float boundary = step(sdBox(uv - center, size1), 0.) - inside;\n    float val = 0.5 + 0.3*sin(PI*0.5 + PI2*saturate(uv.x, min_b.x, max_b.x));\n    float start_x = center.x - size1.x;\n    float bval = saturate(uv.x, start_x, center.x + size1.x);\n    \n    float inv_n = 1. / n;\n    \n    float modeDiscr = floor(_val * n)*inv_n;\n    \n    vec2 dstart = min_b + vec2(size1.x*.1, size1.y*.75);\n    vec4 tcol;\n    float tsize = size1.y * .4;\n    tcol += drawTextHorizontal(uv, dstart, tsize, vec2[10](_T, _o, _o, _l, _s, _X, _X, _X, _X, _X), 5);\n    \n    dstart = min_b + vec2(size1.x*.6, size1.y*.75);\n    tcol += drawTextHorizontal(uv, dstart, tsize, vec2[10](_C, _o, _l, _o, _r, _X, _X, _X, _X, _X), 5);\n    \n    dstart = min_b + vec2(size1.x*1.1, size1.y*.75);\n    tcol += drawLetter(uv, dstart, tsize, _3);\n    dstart.x += tsize*.5;\n    tcol += drawLetter(uv, dstart, tsize, _D);\n    \n    dstart = min_b + vec2(size1.x*1.47, size1.y*.75);\n    tcol += drawTextHorizontal(uv, dstart, tsize, vec2[10](_T, _e, _x, _t, _u, _r, _e, _X, _X, _X), 7);\n    \n    float selZone = (step(modeDiscr, bval) - step(modeDiscr + inv_n, bval));\n    tcol.z *= selZone;\n    \n    vec4 color = clamp(vec4(inside, boundary, \n                            tcol.x, selZone), 0., step(0.5, inside+boundary));\n\n    return color;\n}\n\nvec4 verticalRadioButton(in vec2 uv, in vec2 min_b, in vec2 max_b, in float _val, in float n)\n{\n    vec2 center = (min_b + max_b)*0.5;\n    vec2 size1 = (max_b - min_b) * 0.5;\n    vec2 frame = 0.98 * size1;\n    \n    float ratio = iResolution.x / iResolution.y;\n    vec2 scl_uv = uv;\n    scl_uv.x *= ratio;\n    \n    vec3 background = vec3(0.05, 0.02, 0.01);\n    \n    float inside = step(sdBox(uv - center, frame) - 0.05*size1.y, 0.);\n    float boundary = step(sdBox(uv - center, size1) - 0.06*size1.y, 0.) - inside;\n    float val = 0.5 + 0.3*sin(PI*0.5 + PI2*saturate(uv.y, min_b.y, max_b.y));\n    float start_y = center.y - size1.y;\n    float bval = saturate(uv.y, start_y, center.y + size1.y);\n    \n    float inv_n = 1. / n;\n    \n    float modeDiscr = floor(_val * n)*inv_n;\n    vec2 center_button = vec2(center.x*ratio, start_y + (modeDiscr + inv_n*0.5)*size1.y*2.);\n    float bcircle = length(scl_uv - center_button);\n    float button = smoothstep(0.005, 0.007, bcircle) - smoothstep(0.007, 0.009, bcircle);\n    \n    vec4 color = clamp(vec4(background.x + 0.15*button, background.y + button*0.45 + boundary*val, \n                            button*0.5 + background.z +boundary*val, 1.), 0., step(0.5, inside+boundary));\n\n    return color;\n}\n\nvec4 horizontalRadioButton(in vec2 uv, in vec2 min_b, in vec2 max_b, in float _val, in float n)\n{\n    vec2 center = (min_b + max_b)*0.5;\n    vec2 size1 = (max_b - min_b) * 0.5;\n    vec2 frame = 0.98 * size1;\n    \n    float ratio = iResolution.x / iResolution.y;\n    vec2 scl_uv = uv;\n    scl_uv.x *= ratio;\n    \n    vec3 background = vec3(0.05, 0.02, 0.01);\n    \n    float inside = step(sdBox(uv - center, frame) - 0.04*size1.x, 0.);\n    float boundary = step(sdBox(uv - center, size1) - 0.08*size1.x, 0.) - inside;\n    float val = 0.5 + 0.3*sin(PI*0.5 + PI2*saturate(uv.x, min_b.x, max_b.x));\n    float start_x = center.x - size1.x;\n    float bval = saturate(uv.x, start_x, center.x + size1.x);\n    \n    float inv_n = 1. / n;\n    \n    float modeDiscr = floor(_val * n)*inv_n;\n    vec2 center_button = vec2(start_x + (modeDiscr + inv_n*0.5)*size1.x*2., center.y);\n    center_button.x *= ratio;\n    float bcircle = length(scl_uv - center_button);\n    float button = smoothstep(0.003, 0.005, bcircle) - smoothstep(0.005, 0.007, bcircle);\n    \n    vec4 color = clamp(vec4(background.x + 0.15*button, background.y + button*0.45 + boundary*val, \n                            button*0.5 + background.z +boundary*val, 1.), 0., step(0.5, inside+boundary));\n\n    return color;\n}\n\nvec4 checkButton(in vec2 uv, in vec2 min_b, in vec2 max_b, in bool _val)\n{\n    vec2 center = (min_b + max_b)*.5;\n    vec2 size = (max_b - min_b)*.5;\n    vec2 frame1 = size * 0.95;\n    vec2 fuv = abs(uv - center);\n    \n    vec2 fs = max(vec2(0.), fuv - size);\n    vec2 fr1 = max(vec2(0.), fuv - frame1);\n    \n    float f1 = step(fs.x+fs.y, 0.);\n    float f2 = step(fr1.x+fr1.y, 0.);\n    vec4 color = vec4(f2, f1 - f2, float(_val)*f2, f1);\n    \n    return color;\n}\n\nvec4 functionPlot(in vec2 uv, \n                  in vec2 bmin,\n                  in vec2 bmax,\n                  in float f_value)\n{\n    float ratio = iResolution.x / iResolution.y;\n    vec4 color;\n    vec2 center = (bmin + bmax)*0.5;\n    vec2 size1 = (bmax - bmin) * 0.5;\n    vec2 frame = 1.01 * size1;\n    vec2 innerMin = center - size1*.8;\n    vec2 innerMax = center + size1*.8;\n    vec2 d_inner = innerMax - innerMin;\n    \n    int funcEnum = getIValue(f_value, INTERP_FUNC_NUM);\n    \n\n    float f_x = (uv.x - innerMin.x) / (d_inner.x);\n    \n    vec2 fx = getGradFunction(f_x, funcEnum);\n    \n    float y_val = innerMin.y +  fx.x * d_inner.y;\n    float nf_x = -1. / fx.y;\n    vec2  n2 = normalize(vec2(1., nf_x));\n    \n    vec2 xyUv = vec2(uv.x, y_val);\n    \n    float inside = step(sdBox(uv - center, size1) - 0.05*size1.y, 0.);\n    float boundary = step(sdBox(uv - center, frame) - 0.06*size1.y, 0.) - inside;\n    \n    vec2 duv = uv - xyUv;\n\n    float f = abs(dot(duv, n2));\n    f = step(f, 0.003);\n    //f = .3*length(xyUv - uv);\n    \n    vec2 fv = step(innerMin - 0.003, uv) - step(innerMax + 0.003, uv);\n    f *= fv.x*fv.y;\n    color = vec4(f, inside, boundary, inside + boundary);\n    \n    return color;\n}\n\nvec4 slider(in vec2 uv,\n            in vec2 bmin, \n            in vec2 bmax, \n            in float factor, \n            in float value)\n{\n    vec3 col;\n    float rad = 0.5*(bmax.x - bmin.x);\n    float range = bmax.x - bmin.x;\n    float center = factor*0.5*(bmax.x + bmin.x);\n    float rect = float(in_zone(uv, vec2(center - rad, bmin.y + rad), \n                         vec2(center + rad, bmax.y - rad), 1.));\n    \n    float fc1 = max(circle(uv, vec2(center, bmin.y + rad),rad),0.);\n    float fc2 = max(circle(uv, vec2(center, bmax.y - rad),rad),0.);\n\n    \n    float srad = rad - 0.003;\n    float margin = 0.003;\n    float rect2 = float(in_zone(uv, vec2(center - rad + margin, bmin.y + rad), \n                          vec2(center + rad - margin, bmax.y - rad), 1.));\n    float fc12 = max(circle(uv, vec2(center, bmin.y + rad),srad),0.);\n    float fc22 = max(circle(uv, vec2(center, bmax.y - rad),srad),0.);\n\n    float frect =  step(0.001, rect + fc1 + fc2);\n    float frect2 = step(0.001, rect2 + fc12 + fc22);\n    col.r += step(0.001, frect);\n    col.r -= frect2;\n    \n    \n    float vcol = (uv.y - bmin.y)/(bmax.y - bmin.y);\n    \n    col.r *= sin(0.5*PI + 2.*PI2*vcol);\n\n    col.b = sqrt(frect2*vcol*step(vcol, value));\n    //col.b *= col.b;\n    \n    // debug lines\n    //col.g += smoothstep(bmax.y - 0.005, bmax.y, uv.y) - smoothstep(bmax.y, bmax.y + 0.005, uv.y);\n    //col.g += smoothstep(bmin.y - 0.005, bmin.y, uv.y) - smoothstep(bmin.y, bmin.y + 0.005, uv.y);\n    \n    return vec4(clamp(col, 0., 1.), clamp(frect*.3 + frect2, 0., 1.));\n}\n\nvec4 drawLine(in vec2 uv, in vec2 start, in float lsize, in vec2 _text[32], in int _tsize)\n{\n    vec4 tcol;\n    \n    for (int i_letter = 0; i_letter < _tsize; i_letter++)\n    {\n        tcol += drawLetter(uv, start + float(i_letter)*vec2(0.02, 0.), lsize, _text[i_letter]);\n    }\n    \n    return clamp(tcol, 0., 1.);\n}\n\nvec4 drawTextVertical(in vec2 uv, in vec2 start, in float lsize, in vec2 _text[10], in int _tsize)\n{\n    vec4 tcol;\n    \n    for (int i_letter = 0; i_letter < _tsize; i_letter++)\n    {\n        tcol += drawLetter(uv, start - float(i_letter)*vec2(0., lsize), lsize, _text[i_letter]);\n    }\n    \n    return clamp(tcol, 0., 1.);\n}\n\nvec4 drawRelativeToSecondary(in vec2 uv, in bool rel)\n{\n    float lsize = 0.015;\n    vec2 start = vec2(0.016, 0.35);\n    vec4 tcol;\n    \n    if (rel)\n    {\n        tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_R, _e, _l, _a, _t, _i, _v, _e, _X, _X), 8);\n        tcol += drawTextHorizontal(uv, start + vec2(lsize * 4.5, 0.), lsize, vec2[10](_T, _o, _X, _X, _X, _X, _X, _X, _X, _X), 2);\n        tcol += drawTextHorizontal(uv, start + vec2(lsize * 6., 0.), lsize, _SECONDARY, 9);\n    }\n    \n    return tcol;\n}\n\nvec4 drawOperation(in vec2 uv, in float _operation)\n{\n    float lsize = 0.015;\n    vec2 start = vec2(0.016, 0.09);\n    vec4 tcol;\n    \n    tcol += drawTextHorizontal(uv, start + vec2(0., 0.024), lsize, vec2[10](_C, _o, _l, _o, _r, _X, _X, _X, _X, _X), 5);\n    tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_O, _p, _e, _r, _a, _t, _i, _o, _n, _COLON), 10);\n    int operEnum = getIValue(_operation, BLEND_OPER_NUM);\n    \n    start += 6.*vec2(lsize, 0.);\n    \n    switch (operEnum)\n    {\n        case BLEND_OPER_FIRST:\n        \ttcol += drawTextHorizontal(uv, start, lsize, vec2[10](_A, _PLUS, _B, _EQ, _A, _p, _t, _y, _X, _X), 5);\n        \tbreak;\n        case BLEND_OPER_SECOND:\n        \ttcol += drawTextHorizontal(uv, start, lsize, vec2[10](_A, _PLUS, _B, _EQ, _B, _p, _t, _y, _X, _X), 5);\n        \tbreak;\n        case BLEND_OPER_MIX:\n        \ttcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _I, _X, _CS, _A, _COMMA, _B, _CE, _X, _X), 8);\n        \tbreak;\n        case BLEND_OPER_MAX:\n        \ttcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _A, _X, _CS, _A, _COMMA, _B, _CE, _X, _X), 8);\n        \tbreak;\n        case BLEND_OPER_MIN:\n        \ttcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _I, _N, _CS, _A, _COMMA, _B, _CE, _X, _X), 8);\n        \tbreak;\n        case BLEND_OPER_BIN:\n        \ttcol += drawTextHorizontal(uv, start, lsize, vec2[10](_B, _EQ, _N, _O, _T, _CS, _A, _CE, _X, _X), 8);\n        \tbreak;\n        case BLEND_OPER_SMOOTH:\n        \ttcol += drawTextHorizontal(uv, start, lsize, vec2[10](_S, _m, _o, _o, _t, _h, _B, _CE, _X, _X), 6);\n        \tbreak;\n        case BLEND_OPER_COL_PICK:\n        \ttcol += drawTextHorizontal(uv, start, lsize, vec2[10](_C, _o, _l, _o, _r, _, _p, _i, _c, _k), 10);\n        \tbreak;\n    }\n    return tcol;\n}\n\nvec4 drawTextureValues(in vec2 uv, in float mode, in int menu, in vec2 tvals)\n{\n    vec4 tcol;\n    float lsize = 0.015;\n    vec2 start = vec2(0.016, 0.18);\n    \n    int mval = getIValue(tvals.x, TEXTURES_NUM);\n    int sval = getIValue(tvals.y, TEXTURES_NUM);\n    \n    if (in_zone(mode, APPL_UI) && menu == MENU_OPT_TEXTURE)\n    {\n        tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _a, _i, _n, _COLON, _X, _X, _X, _X, _X), 5);\n        tcol += drawTextHorizontal(uv, start - vec2(0., 0.03), lsize, _SECONDARY, 10);\n        \n        vec2 mstart = start + 6.*vec2(lsize, 0.);\n        vec2 ststart = start + 6.*vec2(lsize, 0.) - vec2(0., 0.03);\n        \n        if (mval == DIFFUSE_MAP)\n        {\n            tcol += drawTextHorizontal(uv, mstart, lsize, _DIFFUSEMAP, 9);\n        }\n        else if (mval == HEIGHT_MAP)\n        {\n            tcol += drawTextHorizontal(uv, mstart, lsize, _HEIGHTMAP, 10);\n        }\n        else if (mval == SPECULAR_MAP)\n        {\n            tcol += drawTextHorizontal(uv, mstart, lsize, _SPECULAR, 8);\n        }\n        \n        if (sval == DIFFUSE_MAP)\n        {\n            tcol += drawTextHorizontal(uv, ststart, lsize, _DIFFUSEMAP, 9);\n        }\n        else if (sval == HEIGHT_MAP)\n        {\n            tcol += drawTextHorizontal(uv, ststart, lsize, _HEIGHTMAP, 10);\n        }\n        else if (sval == SPECULAR_MAP)\n        {\n            tcol += drawTextHorizontal(uv, ststart, lsize, _SPECULAR, 8);\n        }\n    }\n    \n    return tcol;\n}\n\nvec4 drawMode(in vec2 uv, in float mode)\n{\n    \n    float lsize = 0.03;\n    vec2 start = vec2(0.01, 0.05);\n    vec4 tcol;\n    \n    tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _O, _D, _E, _COLON, _X, _X, _X, _X, _X), 5);\n    start += 3.*vec2(lsize, 0.);\n    \n    if (in_zone(mode, APPL_DRAW))\n    {\n         tcol += drawTextHorizontal(uv, start, lsize, _DRAW, 4);\n    }\n    else if (in_zone(mode, APPL_ERASE))\n    {\n         tcol += drawTextHorizontal(uv, start, lsize, _ERASE, 5);\n    }else if (in_zone(mode, APPL_UI))\n    {\n         tcol += drawTextHorizontal(uv, start, lsize, _GUI, 3);\n    }\n    else if (in_zone(mode, APPL_3D))\n    {\n         tcol += drawTextHorizontal(uv, start, lsize, _3D_TEXT, 2);\n    }\n    else if (in_zone(mode, APPL_TEXTURES))\n    {\n         tcol += drawTextHorizontal(uv, start, lsize, _TEXTURES, 8);\n    }\n    return tcol;\n}\n\nvec4 drawSliderText(in vec2 uv, float mode, in int submenu, int _mainTex)\n{\n    vec4 tcol = vec4(0.);\n    if (in_zone(mode, APPL_UI))\n    {\n        float lsize = 0.02;\n        float y_offset = lsize*2.;\n        float x_offset = 0.5*(SELECTION_RADIUS_MAX.x + SELECTION_RADIUS_MIN.x) - lsize*0.5 - SELECTION_RADIUS_MIN.x;\n        \n        //vec2 sstart = vec2(SELECTION_SHAPE_MIN.x + 4.*x_offset, SELECTION_SHAPE_MIN.y - y_offset);\n        //vec2 ovstart = vec2(SELECTION_OVERRIDE_MIN.x + 4.*x_offset, SELECTION_SHAPE_MIN.y - y_offset);\n    \n        if (submenu == MENU_OPT_TOOLS)\n        {\n            vec2 rstart = vec2(SELECTION_RADIUS_MIN.x + x_offset, SELECTION_RADIUS_MAX.y - y_offset);\n            vec2 brushstart = vec2(SELECTION_BRUSH_MIN.x + x_offset, SELECTION_BRUSH_MAX.y - y_offset);\n            vec2 blendstart = vec2(SELECTION_BLEND_FACTOR_MIN.x + x_offset, SELECTION_BLEND_FACTOR_MAX.y - y_offset);\n            tcol += drawTextVertical(uv, rstart, lsize, vec2[10](_R, _a, _d, _i, _u, _s, _X, _X, _X, _X), 6);\n            tcol += drawTextVertical(uv, blendstart, lsize, vec2[10](_B, _l, _e, _n, _d, _ , _F, _a, _c, _t), 5);\n            tcol += drawTextVertical(uv, brushstart, lsize, vec2[10](_B, _r, _u, _s, _h, _X, _X, _X, _X, _X), 5);\n        }\n        else if (submenu == MENU_OPT_COLOR)\n        {\n            \n            vec2 castart = vec2(SELECTION_COLOR_A_MIN.x + x_offset, SELECTION_COLOR_A_MIN.y + y_offset);\n            vec2 cbstart = vec2(SELECTION_COLOR_B_MIN.x + x_offset, SELECTION_COLOR_B_MIN.y + y_offset);\n            vec2 ccstart = vec2(SELECTION_COLOR_C_MIN.x + x_offset, SELECTION_COLOR_C_MIN.y + y_offset);\n            vec2 heightstart = vec2(SELECTION_COLOR_A_MIN.x + x_offset, SELECTION_COLOR_A_MAX.y - y_offset);\n            vec2 specstart = vec2(SELECTION_COLOR_A_MIN.x + 0.002, SELECTION_COLOR_A_MAX.y - .6*y_offset);\n            //vec2 shinestart = vec2(SELECTION_COLOR_B_MIN.x + 0.0022, SELECTION_COLOR_B_MAX.y - .5*y_offset);\n            \n            if (_mainTex == DIFFUSE_MAP)\n            {\n                tcol += drawLetter(uv, castart, lsize, _R);\n            \ttcol += drawLetter(uv, cbstart, lsize, _G);\n            \ttcol += drawLetter(uv, ccstart, lsize, _B);\n            }\n            else if (_mainTex == HEIGHT_MAP)\n            {\n                tcol += drawTextVertical(uv, heightstart, lsize, vec2[10](_H, _e, _i, _g, _h, _t, _X, _X, _X, _X), 6);\n            }\n            else if (_mainTex == SPECULAR_MAP)\n            {\n                tcol += drawTextVertical(uv, specstart, lsize*.8, vec2[10](_S, _p, _e, _c, _u, _l, _a, _r, _X, _X), 8);\n                //tcol += drawTextVertical(uv, shinestart, lsize*.76, vec2[10](_S, _h, _i, _n, _i, _n, _e, _s, _s, _X), 9);\n            }\n        }\n        else if (submenu == MENU_OPT_TEXTURE)\n        {\n            vec2 mainTexStart = vec2(SELECTION_TEXTURE_MIN.x + x_offset, SELECTION_TEXTURE_MIN.y - y_offset);\n\t\t\tvec2 secTexStart = vec2(SELECTION_SECONDARY_TEXTURE_MIN.x + x_offset, SELECTION_SECONDARY_TEXTURE_MIN.y - y_offset);\n            vec2 loadTexStart = vec2(SELECTION_LOAD_TEXTURE_MIN.x + x_offset, SELECTION_LOAD_TEXTURE_MIN.y + .5*y_offset);\n            vec2 blendTexStart = vec2(SELECTION_TEXTURE_ALPHA_MIN.x + x_offset, SELECTION_TEXTURE_ALPHA_MAX.y - y_offset);\n            \n            tcol += drawTextVertical(uv, mainTexStart, lsize, vec2[10](_M, _a, _i, _n, _X, _X, _X, _X, _X, _X), 4);\n            tcol += drawTextVertical(uv, secTexStart, lsize, vec2[10](_S, _e, _c, _o, _n, _d, _a, _r, _y, _X), 9);\n            tcol += drawTextHorizontal(uv, loadTexStart, lsize, vec2[10](_L, _o, _a, _d, _X, _X, _X, _X, _X, _X), 4);\n            tcol += drawTextVertical(uv, blendTexStart, lsize, vec2[10](_B, _l, _e, _n, _d, _ , _F, _a, _c, _t), 5);\n        }\n\t\telse if (submenu == MENU_OPT_3D)\n        {\n            vec2 starsStart = vec2(SELECTION_STARS_MAX.x + x_offset, SELECTION_STARS_MIN.y);\n            tcol += drawTextHorizontal(uv, starsStart, lsize, vec2[10](_S, _t, _a, _r, _s, _X, _X, _X, _X, _X), 5);\n        }\n        \n    }\n    if (in_zone(mode, APPL_TEXTURES))\n    {\n        float lsize = 0.02;\n        float y_offset = lsize*2.;\n        float x_offset = .001;\n        vec2 hideUiStart = vec2(SELECTION_HIDE_UI_MIN.x + x_offset, SELECTION_HIDE_UI_MIN.y + .5*y_offset);\n        \n        tcol += drawTextHorizontal(uv, hideUiStart, lsize, vec2[10](_1, _0, _s, _, _h, _i, _d, _e, _X, _X), 8);\n    }\n    return tcol;\n}\n\n\n\nvec4 drawRadius(in vec2 uv, in float mode, in float radius, vec3 fill, in float brush, in float grad_func)\n{\n    vec4 tcol = vec4(0.);\n    if (in_zone(mode, APPL_UI))\n    {\n        float draw_rad = radius*RADIUS_COEFF;\n        float ratio = iResolution.x / iResolution.y;\n        vec2 draw_center = vec2(.2*ratio, (SELECTION_MODE_MAX.y + SELECTION_MODE_MIN.y)*0.5);\n        float rad = 10.*length(vec2(uv.x*ratio, uv.y) - draw_center);\n        float bound = step(rad, radius);\n        bound *= step(sqrt(brush), hash12(3096.314*uv));\n        vec2 gradFn = getGradFunction(clamp((radius-rad)/radius, 0., 1.), getIValue(grad_func, INTERP_FUNC_NUM));\n        bound *= gradFn.x;\n        float ring = smoothstep(rad - 0.03, rad, radius) - smoothstep(rad, rad + 0.03, radius);\n        tcol.xyz = fill*bound;\n        tcol.x += ring;\n        tcol.w = clamp(bound + ring, 0., 1.);\n    }\n    \n    return tcol;\n}\n\nvec4 drawModeRadius(in vec2 uv, in float mode, in float radius)\n{\n    vec4 tcol;\n    if ((in_zone(mode, APPL_DRAW) || in_zone(mode, APPL_ERASE)) && iMouse.z > 0.5)\n    {\n        float ratio = iResolution.x / iResolution.y;\n        float eps = 2. / iResolution.y;\n        vec2 muv = iMouse.xy / iResolution.xy;\n        vec2 diff = abs(muv - uv);\n        diff.x *= ratio;\n        diff = min((diff), (ratio - diff));\n        float draw_rad = radius * RADIUS_COEFF;\n        float rad = length(diff);\n        \n        float f = smoothstep(draw_rad - eps, draw_rad, rad) - smoothstep(draw_rad, draw_rad + eps, rad);\n        float f2 = smoothstep(draw_rad - eps*2., draw_rad - eps, rad) - smoothstep(draw_rad - eps, draw_rad, rad);\n        float f3 = smoothstep(draw_rad - eps*1.5, draw_rad - eps*.5, rad) - smoothstep(draw_rad - eps*.5, draw_rad + eps*.5, rad);\n        \n        \n        tcol.x = f;\n        tcol.y = .6 * f2;\n        tcol.z = .7*f3;\n    }\n    \n    return tcol;\n}\n\nvec4 drawModes(in vec2 uv, in float mode, in float n)\n{\n    vec4 tcol = vec4(0.);\n    \n    if (in_zone(mode, APPL_UI))\n    {\n        float y_range = SELECTION_MODE_MAX.y - SELECTION_MODE_MIN.y;\n        //float _x = SELECTION_MODE_MAX.x + 0.03;\n        float lsize = 0.01;\n    }\n    \n    return tcol;\n}\n\n\nfloat stars(in vec2 uv, in vec2 center, in vec2 offset)\n{\n    vec2 cuv = uv - center;\n    float lc = length(cuv);\n    float starSize = .1;\n    float gridSize = 100./(1. + lc);\n    vec2 grid = gridSize*cuv;\n    \n    grid += offset;\n    \n    vec2 igrid = floor(grid);\n    vec2 fgrid = fract(grid);\n    \n    vec3 hsh = hash32(igrid);\n    \n    starSize *= hsh.y;\n    vec2 cc = vec2(0.5); // cell center;\n    vec2 auv = abs(fgrid - cc);\n    \n    vec2 cic = vec2(starSize); // circle center;\n    float f = step(starSize, (length(auv - cic)));\n    float f2 = step(length(fgrid - cc), starSize);\n    \n    return f*f2*step(.8, hsh.x)*hsh.z;\n}\n\n\nfloat geom(in vec3 p)\n{\n    vec2 tuv;\n        tuv.x = atan(p.z , p.x)/PI2 + .5;\n        tuv.y = .5 + asin(p.y/1.)/PI;\n    tuv = clamp(tuv, 0.001, 0.999);\n    //tuv = clamp(tuv, 0.01, 0.99);\n    vec2 tex = normToTextureUv(tuv, 1., iResolution.xy);\n    \n    vec3 offset = texture(iChannel2, tex).xyz;\n    \n    return 1.*(length(p + vec3(0., 0., 0.)) - 1. -offset.r*0.02);\n}\n\nvec3 getCentralDiff(vec3 o, vec3 d, float t)\n{\n    vec3 norm;\n    vec3 e = vec3(0.00001, 0.0, 0.0)*t;\n\n    vec3 p = o + t*d;\n\n    norm.x = geom(p + e.xyy) - geom(p - e.xyy);\n    norm.y = geom(p + e.yxy) - geom(p - e.yxy);\n    norm.z = geom(p + e.yyx) - geom(p - e.yyx);\n\n    norm = normalize(norm);\n    \n    return norm;\n}\n\nfloat trace(in vec3 o, in vec3 d, out float t) {\n    float mint = 10.;\n    float eps = 0.0001;\n    float prev_t = 0.;\n    for (int it = 0; it < 256; it++) {\n        \n        vec3 p = o + d*t;\n\n        mint = geom(p);\n        \n        if (mint < eps*t || mint > 10.) \n            break;\n       \n        prev_t = t;\n        t += mint;\n    }\n    \n    if (mint < -eps)\n    {\n        \n       float ft = t;\n       //t = prev_t;\n       //while (t < ft)\n       //{\n       //    \n        //   t += dt;\n       //}\n    }\n    \n    return mint;\n}\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar, in vec3 up) {\n  vec3 dir = normalize(o - tar);\n  vec3 right = normalize(cross(dir, up));\n  up = normalize(cross(right,dir));\n\n  mat3 view = mat3(right,up,dir);\n  return (view*d);\n}\n\nvoid scene3D(out vec4 fragColor, in vec2 fragCoord, in vec4 _status)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ouv = uv;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    vec3 col = vec3(0.);\n    vec3 o = vec3(0., 0., 1.75);\n    vec3 d = normalize(vec3(-1. + 2.*(uv-vec2(0.4, 0.)), -1.));\n    \n    mat3 mx, my;\n    \n    o = get_cam_location(iChannel1);\n    \n    d = camera(o, d, get_target_vector(iChannel1), \n              get_up_vector(iChannel1));\n    \n    float mu = dot(d, normalize(vec3(1., 1., 1.)));\n    float phaseR = 3./(16.*PI)*(1.+mu*mu);\n    float atm_step = 0.1;\n    \n    float t;\n    float eps = trace(o, d, t);\n    \n    vec3 light = -d;\n    \n    if (eps < 0.001)\n    {\n        vec3 p = o + d*t;\n        \n        vec3 norm = getCentralDiff(o, d, t);\n        \n        vec2 tuv;\n        tuv.x = atan(p.z , p.x)/PI2 + .5;\n        tuv.y = .5 + asin(p.y/1.)/PI;\n        tuv = clamp(tuv, 0.001, 0.999);\n        //tuv.y = SEL_ZONE_Y + (1. - SEL_ZONE_Y)*tuv.y;\n        \n        vec2 tex = normToTextureUv(tuv, 0., iResolution.xy);\n        vec2 ltex = normToTextureUv(tuv, 2., iResolution.xy);\n        \n        vec3 tcol = texture(iChannel2, tex).xyz;\n        float texSpec = texture(iChannel2, ltex).r;\n        //float texShine = texture(iChannel2, ltex).g;\n        \n        float I = dot(light, norm);\n        \n        vec3 rfl = reflect(light, norm);\n        float spec = clamp(dot(rfl, d), 0., 1.);\n        col = clamp(0.05*tcol + 0.85*tcol*I + texSpec*pow(spec, 32.), 0., 1.);\n    }\n    else if (_status.x > 0.5)\n    {\n        vec2 offset = 10.*get_accumulated_move(iChannel1);\n        col = vec3(stars(uv, vec2(.5*ratio, .5), offset));\n    }\n    \n    \n    fragColor = vec4(col.xyz, 1.);\n}\n\nvoid scene2D( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 muv = iMouse.xy/iResolution.xy;\n   \tvec4 map = texture(iChannel1, uv);\n    // Output to screen\n    \n    float mode = get_ctrl_mode(iChannel1);\n    float radius = get_radius(iChannel1);\n    vec3 pickRGB = get_color(iChannel1);\n    float is_ui = get_ui(iChannel1);\n    float override = get_override(iChannel1);\n    //float shape = get_shape(iChannel1);\n    float blend = get_blend_factor(iChannel1);\n    float gradient_func = get_gradient_func(iChannel1);\n    float brush = get_brush_type(iChannel1);\n    vec4 texParams = get_texture_params(iChannel1);\n    float texIdx = texParams.w;\n    float stexIdx = texParams.z;\n    float texAlpha = texParams.x;\n    //float defaultCol = get_default_draw_color(iChannel1);\n    float mainMenuVal = get_main_menu_val(iChannel1);\n    float stars = get_stars(iChannel1);\n    bool hide_ui = get_hide_ui(iChannel1);\n    \n    float col_block = get_color_block(iChannel1);\n    \n    float m_in_mode = iMouse.z*float(in_zone(muv, SELECTION_MODE_MIN, SELECTION_MODE_MAX, 1.));\n    \n    int   menu_option = getIValue(mainMenuVal, MENU_OPT_NUM);\n    \n    vec4 appl_button = verticalRadioButton(uv, SELECTION_MODE_MIN, SELECTION_MODE_MAX, mode, 5.);\n    vec4 rad_slider = slider(uv, SELECTION_RADIUS_MIN, SELECTION_RADIUS_MAX, 1., radius);\n    vec4 col_a_slider = slider(uv, SELECTION_COLOR_A_MIN, SELECTION_COLOR_A_MAX, 1., pickRGB.r);\n    vec4 col_b_slider = slider(uv, SELECTION_COLOR_B_MIN, SELECTION_COLOR_B_MAX, 1., pickRGB.g);\n    vec4 col_c_slider = slider(uv, SELECTION_COLOR_C_MIN, SELECTION_COLOR_C_MAX, 1., pickRGB.b);\n    vec4 override_button = verticalRadioButton(uv, SELECTION_OVERRIDE_MIN, SELECTION_OVERRIDE_MAX, override, BLEND_OPER_NUM);\n    //vec4 shape_button = verticalRadioButton(uv, SELECTION_SHAPE_MIN, SELECTION_SHAPE_MAX, shape, 2.);\n    vec4 blend_factor = slider(uv, SELECTION_BLEND_FACTOR_MIN, SELECTION_BLEND_FACTOR_MAX, 1., blend);\n    vec4 fade_button = verticalRadioButton(uv, SELECTION_FADE_MIN, SELECTION_FADE_MAX, gradient_func, 7.);\n    vec4 brush_button = slider(uv, SELECTION_BRUSH_MIN, SELECTION_BRUSH_MAX, 1., brush);\n    vec4 texture_selection = verticalRadioButton(uv, SELECTION_TEXTURE_MIN, SELECTION_TEXTURE_MAX, texIdx, TEXTURES_NUM);\n    vec4 secondary_texture_select = verticalRadioButton(uv, SELECTION_SECONDARY_TEXTURE_MIN, SELECTION_SECONDARY_TEXTURE_MAX, stexIdx, TEXTURES_NUM);\n    vec4 tex_alpha_select = slider(uv, SELECTION_TEXTURE_ALPHA_MIN, SELECTION_TEXTURE_ALPHA_MAX, 1., texAlpha);\n    vec4 main_menu_select = mainMenuButton(uv, SELECTION_MAIN_MENU_MIN, SELECTION_MAIN_MENU_MAX, mainMenuVal, 4.);\n    vec4 stars_select = horizontalRadioButton(uv, SELECTION_STARS_MIN, SELECTION_STARS_MAX, stars, 2.);\n    vec4 func_color = functionPlot(uv, vec2(0.02, 0.15), vec2(0.14, 0.32), gradient_func);\n    vec4 hide_b_color = checkButton(uv, SELECTION_HIDE_UI_MIN, SELECTION_HIDE_UI_MAX, hide_ui);\n   \tvec4 load_tex_color = checkButton(uv, SELECTION_LOAD_TEXTURE_MIN, SELECTION_LOAD_TEXTURE_MAX, get_load_texture(iChannel1));\n    //vec4 def_tex_color = horizontalRadioButton(uv, SELECTION_DEF_DRAW_COLOR_MIN, SELECTION_DEF_DRAW_COLOR_MAX, defaultCol, 2.);\n    vec4 col_block_color = verticalRadioButton(uv, SELECTION_COLOR_BLOCK_MIN, SELECTION_COLOR_BLOCK_MAX, col_block, 2.);\n    \n    // text\n    vec4 tcol;\n    \n    vec2 minMain, maxMain, minSecond, maxSecond;\n    \n    float i_main = getTextureIndex(texIdx);\n    float i_second = getTextureIndex(stexIdx);\n    \n    getTexBBox(i_main, minMain, maxMain);\n    getTexBBox(i_second, minSecond, maxSecond);\n    \n    vec4 fromUv = vec4(0., 0., 1., 1.);\n   \tvec4 toUv = vec4(minMain, maxMain);\n    vec2 tuv = convertUv(uv, fromUv, toUv);\n    \n    vec4 stoUv = vec4(minSecond, maxSecond);\n    vec2 stuv = convertUv(uv, fromUv, stoUv);\n\n    vec3 col;\n    vec3 sccol;\n    vec3 main = texture(iChannel2, tuv).xyz;\n    vec3 secondary = texture(iChannel2, stuv).xyz;\n    \n    if (int(i_main) != int(i_second))\n    {\n        sccol = mix(secondary, main, texAlpha);\n    }\n    else\n    {\n        sccol = main;\n    }\n    \n    if (in_zone(mode, APPL_3D) || (in_zone(mode, APPL_UI) && menu_option == MENU_OPT_3D))\n    {\n        vec4 col3D;\n        vec4 status;\n        status.x = 1. - stars;\n        scene3D(col3D, fragCoord, status);\n        sccol = col3D.xyz;\n    }\n    else if (in_zone(mode, APPL_TEXTURES))\n    {\n        sccol = texture(iChannel2, uv).xyz;\n    }\n    \n    if (in_zone(mode, APPL_UI) && uv.x <= SELECTION_MAIN_MENU_MAX.x + 0.015)\n    {\n        col = mix(vec3(0.132), sccol, 0.25);\n    }\n    else\n    {\n        col = sccol;\n    }\n    \n    if (hide_ui == false)\n    {\n        vec3 grad_col_a_slider = mix(col_a_slider.zxx, col_a_slider.zzz, float(int(i_main) != DIFFUSE_MAP));\n        vec3 grad_col_b_slider = mix(col_b_slider.xzx, col_b_slider.zzz, float(int(i_main) != DIFFUSE_MAP));\n        vec3 slideCol; // color of sliders;\n        \n        col = mix(col, appl_button.xyz, appl_button.w);\n        col = mix(col, vec3(0.7, 0.6, 0.1)*rad_slider.x + rad_slider.zzz, \n                  float(menu_option == MENU_OPT_TOOLS) * is_ui*rad_slider.w);\n        col = mix(col, grad_col_a_slider, float(menu_option == MENU_OPT_COLOR) * is_ui*col_a_slider.w);\n        col = mix(col, grad_col_b_slider, float(menu_option == MENU_OPT_COLOR) * is_ui*col_b_slider.w * float(int(i_main) == DIFFUSE_MAP));\n        col = mix(col, col_c_slider.xxz, float(menu_option == MENU_OPT_COLOR) * is_ui*col_c_slider.w * float(int(i_main) == DIFFUSE_MAP));\n        col = mix(col, override_button.z*vec3(.9, .6, .1), float(menu_option == MENU_OPT_TOOLS) * is_ui*override_button.w);\n        //col = mix(col, shape_button.xyz, float(menu_option == MENU_OPT_TOOLS) * is_ui*shape_button.w);\n        col = mix(col, vec3(0.1, 0.8, 0.5)*blend_factor.x + vec3(0.9, .1, 0.3)*blend_factor.z, \n                  float(menu_option == MENU_OPT_TOOLS) * is_ui*blend_factor.w);\n        col = mix(col, fade_button.z*vec3(.05, .23, .45), float(menu_option == MENU_OPT_TOOLS) * is_ui*fade_button.w);\n        col = mix(col, brush_button.xzz, float(menu_option == MENU_OPT_TOOLS) * is_ui*brush_button.w);\n        col = mix(col, texture_selection.yzx, float(menu_option == MENU_OPT_TEXTURE) * is_ui*texture_selection.w);\n        col = mix(col, secondary_texture_select.zxx, float(menu_option == MENU_OPT_TEXTURE) * is_ui*secondary_texture_select.w);\n        col = mix(col, vec3(0.3, 0.7, 0.9)*tex_alpha_select.x + tex_alpha_select.zxz, float(menu_option == MENU_OPT_TEXTURE) * is_ui*tex_alpha_select.w);\n        col = mix(col, func_color.zzx, float(menu_option == MENU_OPT_TOOLS) * is_ui*func_color.w);\n        col = mix(col, \n                  main_menu_select.x*vec3(0.15) +\n                  main_menu_select.y*vec3(0.1) +\n                  main_menu_select.z*vec3(0.51, 0.5, 0.52) +\n                  main_menu_select.z*main_menu_select.w*vec3(.41, -0.33, -0.46), is_ui*(main_menu_select.x + main_menu_select.y));\n\n        col = mix(col, stars_select.xyz, is_ui*float(menu_option == MENU_OPT_3D)*stars_select.w);\n        col = mix(col, hide_b_color.yyy, float(in_zone(mode, APPL_TEXTURES)) * hide_b_color.w), \n\t\tcol = mix(col, load_tex_color.xxx*.11 - load_tex_color.zzz*.15 + load_tex_color.yyy,\n                  is_ui*float(menu_option == MENU_OPT_TEXTURE)*load_tex_color.w);\n       // col = mix(col, step(.5, defaultCol)*def_tex_color.zzz + def_tex_color.yyy, is_ui*float(menu_option == MENU_OPT_COLOR) * def_tex_color.w);\n        col = mix(col, col_block_color.xyz, float(menu_option == MENU_OPT_TOOLS) * is_ui * col_block_color.w * float(int(i_main) != int(i_second)));\n        \n        tcol += drawMode(uv, mode);\n        tcol += drawOperation(uv, override);\n        tcol += drawTextureValues(uv, mode, menu_option, vec2(texIdx, stexIdx));\n        tcol += drawSliderText(uv, mode, menu_option, int(i_main));\n        tcol += drawRelativeToSecondary(uv, bool(is_ui) && menu_option == MENU_OPT_TOOLS && int(i_main) != int(i_second) && col_block > 0.5);\n        vec4 rcol = drawRadius(uv, mode, radius, pickRGB, brush, gradient_func);\n        col = mix(col, rcol.xyz, rcol.w);\n\n        if (m_in_mode < 0.5)\n        {\n            col += drawModeRadius(uv, mode, radius).xyz;\n        }\n        \n        col += tcol.xyz;\n    }\n\n    col = clamp(col, 0., 1.);\n    \n    fragColor = vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   scene2D(fragColor, fragCoord);\n   //scene3D(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Color Your Planet, Selection buffer.\n    please see Documentation in Buffer C.\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 lctrl = texture(iChannel0, uv);\n    float mode = get_ctrl_mode(iChannel0);\n    bool click = iMouse.z > 0.5;\n    float draw_rad = RADIUS_COEFF*get_radius(iChannel0);\n    float oper = get_override(iChannel0);\n    bool hide_ui = get_hide_ui(iChannel0);\n    bool load_texture = get_load_texture(iChannel0);\n    \n \tvec4 ctrl = lctrl;\n\n    float shape = get_shape(iChannel0);\n    float brush = get_brush_type(iChannel0);\n    int   mainTexIdx = int(getTextureIndex(get_texture_index(iChannel0)));\n    int   secTexIdx = int(getTextureIndex(get_secondary_texture_index(iChannel0)));\n    int   nextTexIdx = mainTexIdx;\n    \n    int fgx = int(fragCoord.x);\n    bool in_y_zone = int(fragCoord.y) == 0;\n    \n    vec2 muv = iMouse.xy/iResolution.xy;\n    bool in_ui = (fgx == CTRL_GUI.x) && in_y_zone;\n    \n    int optMenu = getIValue(get_main_menu_val(iChannel0), MENU_OPT_NUM);\n    \n    bool inTools = optMenu == MENU_OPT_TOOLS;\n    bool inColor = optMenu == MENU_OPT_COLOR;\n    bool in3D = optMenu == MENU_OPT_3D;\n    bool inTexture = optMenu == MENU_OPT_TEXTURE;\n    \n    float m_in_mode = iMouse.z*float(in_zone(muv, SELECTION_MODE_MIN, SELECTION_MODE_MAX, 1.));\n    bool in_mode = (fgx == CTRL_MODE.x) && in_y_zone;\n    bool m_in_radius = inTools && in_zone(muv, SELECTION_RADIUS_MIN, SELECTION_RADIUS_MAX, 1.);\n    bool in_radius = (fgx == CTRL_RADIUS.x) && in_y_zone;\n    bool m_in_color_a = inColor && in_zone(muv, SELECTION_COLOR_A_MIN, SELECTION_COLOR_A_MAX, 1.);\n    bool m_in_color_b = inColor && in_zone(muv, SELECTION_COLOR_B_MIN, SELECTION_COLOR_B_MAX, 1.);\n    bool m_in_color_c = inColor && in_zone(muv, SELECTION_COLOR_C_MIN, SELECTION_COLOR_C_MAX, 1.);\n    bool in_color = (fgx == CTRL_COLOR_ABC.x) && in_y_zone;\n    bool m_in_override = inTools && in_zone(muv, SELECTION_OVERRIDE_MIN, SELECTION_OVERRIDE_MAX, 1.);\n    bool in_override = (fgx == CTRL_OVERRIDE.x) && in_y_zone;\n    bool m_in_shape = inTools && in_zone(muv, SELECTION_SHAPE_MIN, SELECTION_SHAPE_MAX, 1.);\n    bool in_shape = (fgx == CTRL_SHAPE.x) && in_y_zone;\n    bool m_in_blend = inTools && in_zone(muv, SELECTION_BLEND_FACTOR_MIN, SELECTION_BLEND_FACTOR_MAX, 1.);\n    bool in_blend = (fgx == CTRL_BLEND_FACTOR.x) && in_y_zone;\n    bool m_in_fade = inTools && in_zone(muv, SELECTION_FADE_MIN, SELECTION_FADE_MAX, 1.);\n    bool in_fade = (fgx == CTRL_GRADIENT_FUNC.x) && in_y_zone;\n    bool m_in_brush = inTools && in_zone(muv, SELECTION_BRUSH_MIN, SELECTION_BRUSH_MAX, 1.);\n    bool in_brush = (fgx == CTRL_BRUSH.x) && in_y_zone;\n    bool m_in_texture = inTexture && in_zone(muv, SELECTION_TEXTURE_MIN, SELECTION_TEXTURE_MAX, 1.);\n    bool in_texture = (fgx == CTRL_TEXTURE.x) && in_y_zone;\n    bool m_in_stexture = inTexture && in_zone(muv, SELECTION_SECONDARY_TEXTURE_MIN, SELECTION_SECONDARY_TEXTURE_MAX, 1.);\n    bool m_in_atexture = inTexture && in_zone(muv, SELECTION_TEXTURE_ALPHA_MIN, SELECTION_TEXTURE_ALPHA_MAX, 1.);\n\tbool m_in_stars = in_zone(muv, SELECTION_STARS_MIN, SELECTION_STARS_MAX, 1.);\n    bool in_stars = (fgx == CTRL_STARS.x) && in_y_zone;\n    \n    bool in_main_menu = (fgx == CTRL_GUI_MENU.x) && in_y_zone;\n    bool m_in_main_menu = in_zone(muv, SELECTION_MAIN_MENU_MIN, SELECTION_MAIN_MENU_MAX, 1.);\n    \n    bool in_orbit_control = (fgx == CTRL_ORBIT_3D.x) && in_y_zone;\n    bool in_up_control = (fgx == CTRL_UP_VECTOR_3D.x) && in_y_zone;\n    bool in_location_control = (fgx == CTRL_LOCATION_3D.x) && in_y_zone;\n    bool in_accumulated_move = (fgx == CTRL_ACC_MOVE_3D.x) && in_y_zone;\n    \n    bool in_hide_ui = (fgx == CTRL_HIDE_UI.x) && in_y_zone;\n    bool m_in_hide_ui = in_zone(muv, SELECTION_MAIN_MENU_MIN, SELECTION_MAIN_MENU_MAX, 1.);\n    bool in_load_texture = (fgx == CTRL_LOAD_TEXTURE.x) && in_y_zone;\n    bool m_in_load_texture = in_zone(muv, SELECTION_LOAD_TEXTURE_MIN, SELECTION_LOAD_TEXTURE_MAX, 1.);\n    \n    \n    bool in_def_color = (fgx == CTRL_DEF_COLOR.x) && in_y_zone;\n    bool m_in_def_color = in_zone(muv, SELECTION_DEF_DRAW_COLOR_MIN, SELECTION_DEF_DRAW_COLOR_MAX, 1.);\n    \n    bool in_color_block = (fgx == CTRL_COLOR_BLOCK.x) && in_y_zone;\n    bool m_in_color_block = in_zone(muv, SELECTION_COLOR_BLOCK_MIN, SELECTION_COLOR_BLOCK_MAX, 1.);\n    \n    float block = 0.;\n    \n    if (mainTexIdx != secTexIdx && get_color_block(iChannel0) > 0.5)\n    {\n        vec2 minSecond, maxSecond;\n        getTexBBox(float(secTexIdx), minSecond, maxSecond);\n    \tvec4 stoUv = vec4(minSecond, maxSecond);\n        vec4 fromUv = vec4(0., SEL_ZONE_Y, 1., 1.);\n        vec2 stuv = convertUv(uv, fromUv, stoUv);\n        vec2 mstuv = convertUv(muv, fromUv, stoUv);\n        \n        vec4 muvcol = texture(iChannel1, mstuv);\n        vec4 uvcol = texture(iChannel1, stuv);\n        \n        vec4 dv = abs(muvcol - uvcol);\n        \n        block = step(0.01, max(dv.x, max(dv.y, dv.z)));\n    }\n    \n    if (click && m_in_mode > 0.5 && in_mode)\n    {\n       ctrl.w = saturate(muv.y, SELECTION_MODE_MIN.y, SELECTION_MODE_MAX.y);\n    }\n    else if (in_mode)\n    {\n        ctrl = lctrl;\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_main_menu && in_main_menu)\n    {\n        ctrl.w = saturate(muv.x, SELECTION_MAIN_MENU_MIN.x, SELECTION_MAIN_MENU_MAX.x);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_radius && in_radius)\n    {\n        ctrl.w = saturate(muv.y, SELECTION_RADIUS_MIN.y, SELECTION_RADIUS_MAX.y);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_color_a && in_color)\n    {\n        ctrl.r = saturate(muv.y, SELECTION_COLOR_A_MIN.y, SELECTION_COLOR_A_MAX.y);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_color_b && in_color)\n    {\n        ctrl.g = saturate(muv.y, SELECTION_COLOR_B_MIN.y, SELECTION_COLOR_B_MAX.y);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_color_c && in_color)\n    {\n        ctrl.b = saturate(muv.y, SELECTION_COLOR_C_MIN.y, SELECTION_COLOR_C_MAX.y);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_override && in_override)\n    {\n        ctrl.w = saturate(muv.y, SELECTION_OVERRIDE_MIN.y, SELECTION_OVERRIDE_MAX.y);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_blend && in_blend)\n    {\n        ctrl.w = saturate(muv.y, SELECTION_BLEND_FACTOR_MIN.y, SELECTION_BLEND_FACTOR_MAX.y);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_fade && in_fade)\n    {\n        ctrl.w = saturate(muv.y, SELECTION_FADE_MIN.y, SELECTION_FADE_MAX.y);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_brush && in_brush)\n    {\n        float brsh = saturate(muv.y, SELECTION_BRUSH_MIN.y, SELECTION_BRUSH_MAX.y);\n        brsh *= step(0.01, brsh);\n        \n        ctrl.w = brsh;\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_texture && in_texture && inTexture)\n    {\n        ctrl.w = saturate(muv.y, SELECTION_TEXTURE_MIN.y, SELECTION_TEXTURE_MAX.y);\n        nextTexIdx = int(getTextureIndex(ctrl.w));\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_stexture && in_texture && inTexture)\n    {\n        ctrl.z = saturate(muv.y, SELECTION_SECONDARY_TEXTURE_MIN.y, SELECTION_SECONDARY_TEXTURE_MAX.y);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_atexture && in_texture && inTexture)\n    {\n        ctrl.x = saturate(muv.y, SELECTION_TEXTURE_ALPHA_MIN.y, SELECTION_TEXTURE_ALPHA_MAX.y);\n    }\n    /*else if (in_zone(mode, APPL_UI) && click && m_in_def_color && in_def_color && inColor)\n    {\n        ctrl.w = saturate(muv.x, SELECTION_DEF_DRAW_COLOR_MIN.x, SELECTION_DEF_DRAW_COLOR_MAX.x);\n    }*/\n    else if (in_zone(mode, APPL_UI) && click && m_in_stars && in_stars && in3D)\n    {\n        ctrl.w = saturate(muv.x, SELECTION_STARS_MIN.x, SELECTION_STARS_MAX.x);\n    }\n    else if (in_zone(mode, APPL_UI) && click && m_in_color_block && in_color_block && inTools && mainTexIdx != secTexIdx)\n    {\n        ctrl.w = saturate(muv.y, SELECTION_COLOR_BLOCK_MIN.y, SELECTION_COLOR_BLOCK_MAX.y);\n    }\n    else if (in_zone(mode, APPL_TEXTURES) && click && m_in_hide_ui && in_hide_ui && !hide_ui)\n    {\n        ctrl.w = 1.;\n    }\n    else if (in_hide_ui)\n    {\n        ctrl.w = max(0., ctrl.w - iTimeDelta * 0.1);\n    }\n    else if (load_texture == false && inTexture && in_zone(mode, APPL_UI) && click && m_in_load_texture && in_load_texture)\n    {\n        ctrl.w = 1.;\n    }\n    else if (in_load_texture)\n    {\n        ctrl.w = max(0., ctrl.w - iTimeDelta);\n    }\n    else if (in_zone(mode, APPL_UI) && inTexture && in_color && !texture_store(iChannel0))\n    {\n        ctrl.xyz = vec3(0.); // if we're changing textures, reset the color bar.\n    }\n    else if ((in_zone(mode, APPL_DRAW) || in_zone(mode, APPL_UI)) && click && getIValue(oper, BLEND_OPER_NUM) == BLEND_OPER_COL_PICK\n             && in_color && m_in_mode < 0.5 && !m_in_override && !m_in_main_menu)\n    {\n        vec2 minMain, maxMain;\n\n        getTexBBox(float(mainTexIdx), minMain, maxMain);\n\n        vec4 fromUv = vec4(0., SEL_ZONE_Y, 1., 1.);\n        vec4 toUv = vec4(minMain, maxMain);\n        vec2 tuv = convertUv(muv, fromUv, toUv);\n        \n        ctrl.rgb = texture(iChannel1, tuv).rgb;\n    }\n    else if (in_zone(mode, APPL_DRAW) && click && get_simulation_zone(muv) > 0.5 &&\n            get_simulation_zoneI(uv) > 0.5) // drawing mode\n    {\n        float ratio = iResolution.x / iResolution.y;\n        \n        vec2 scl_muv = vec2(muv.x*ratio, muv.y);\n        vec2 scl_uv = vec2(uv.x*ratio, uv.y);\n        vec2 diff = abs(scl_uv - scl_muv);\n        diff.x = min(diff.x, ratio - diff.x); // cyclic difference;\n        \n        float f = step(length(diff), draw_rad) * (1. - block);\n        f *= step(sqrt(brush), hash13(vec3(3059.521*scl_uv, iTime)));\n        \n        ctrl.z = step(0.5, f);\n        ctrl.w = max(f, lctrl.w);\n    }\n    else if (in_zone(mode, APPL_ERASE) && click && get_simulation_zone(muv) > 0.5) // drawing mode\n    {\n        float ratio = iResolution.x / iResolution.y;\n        vec2 scl_muv = vec2(muv.x*ratio, muv.y);\n        vec2 scl_uv = vec2(uv.x*ratio, uv.y);\n        \n        vec2 diff = abs(scl_uv - scl_muv);\n        \n        float f = step(length(diff), draw_rad);\n        f *= step(sqrt(brush), hash13(vec3(3059.521*scl_uv, iTime)));\n        \n        ctrl.w = min(1.-f, lctrl.w);\n    }\n    else if (iFrame == 0 && in_up_control)\n    {\n        ctrl.xyz = vec3(0., 1., 0.);\n    }\n    else if (iFrame == 0 && in_location_control)\n    {\n        ctrl.xyz = vec3(0., 0., 1.75);\n    }\n    else if (m_in_mode < 0.5 && click && in_zone(mode, APPL_3D) && in_up_control)\n    {\n        float dy = -5.*get_control_orbit(iChannel0).y;\n        vec3 pos = get_cam_location(iChannel0);\n        vec3 up = get_up_vector(iChannel0);\n        vec3 tar = get_target_vector(iChannel0);\n        vec3 front = normalize(tar - pos);\n        \n        //float d = length(tar - pos);\n        \n        vec3 newUp = cos(dy)*up + sin(dy)*front;\n        \n        ctrl.xyz = normalize(newUp);\n    }\n    else if (m_in_mode < 0.5 && click && in_zone(mode, APPL_3D) && in_location_control)\n    {\n        vec2 dxy = 5.*get_control_orbit(iChannel0);\n        dxy.y = -dxy.y;\n        vec3 pos = get_cam_location(iChannel0);\n        vec3 up = get_up_vector(iChannel0);\n        vec3 tar = get_target_vector(iChannel0);\n        vec3 front = normalize(tar - pos);\n        vec3 left = cross(up, front);\n        \n        float d = length(tar - pos);\n        \n        vec3 sUp = up*dot(up, pos);\n        \n\t\t// rotate around up:\n        vec3 vx = cos(dxy.x)*front + sin(dxy.x)*left;\n        \n        // rotate around left\n        vec3 vy = cos(dxy.y)*front + sin(dxy.x)*up;\n        \n        vec3 newPos = sUp + vx + vy;\n        \n        // normalize to orbit distance\n        vec3 np = tar - d * normalize(newPos - tar);\n        \n        ctrl.xyz = np;\n    }\n    else if (m_in_mode < 0.5 && click && in_zone(mode, APPL_3D) && in_orbit_control)\n    {\n        ctrl.zw = muv.xy;\n        if (lctrl.w > SEL_ZONE_Y) // last mouse pick\n        {\n            ctrl.xy = (ctrl.zw - lctrl.zw);\n            //ctrl.xy = mod(ctrl.xy, vec2(1.));\n        }\n    }\n    else if (m_in_mode < 0.5 && in_zone(mode, APPL_3D) && in_orbit_control)\n    {\n        ctrl.xy = lctrl.xy; // phi, theta angles\n        ctrl.zw = vec2(0.); // last mouse pick\n        \n        //ctrl.xy = vec2(0.);\n    }\n    else if (m_in_mode < .5 && click && in_zone(mode, APPL_3D) && in_accumulated_move)\n    {\n        ctrl.zw = muv.xy;\n        if (lctrl.w > SEL_ZONE_Y) // last mouse pick\n        {\n            ctrl.xy += (ctrl.zw - lctrl.zw);\n            //ctrl.xy = mod(ctrl.xy, vec2(1.));\n        }\n    }\n    else if (m_in_mode < .5 && in_zone(mode, APPL_3D) && in_accumulated_move)\n    {\n        ctrl.xy = lctrl.xy; // phi, theta angles\n        ctrl.zw = vec2(0.);\n    }\n    else if (m_in_mode > 0.5 && click && get_simulation_zoneI(uv) > 0.5)\n    {\n        ctrl.z = 0.;\n    }\n    else\n    {\n        ctrl = lctrl;\n    }\n    \n    if (in_zone(mode, APPL_UI) && in_ui) // drawing mode\n    {\n        ctrl.w = 1.;\n    }\n    else if (in_ui)\n    {\n        ctrl.w = 0.;\n    }\n    \n    if ((get_load_texture(iChannel0) || !texture_store(iChannel0)) && get_simulation_zoneI(uv) > 0.5)\n    {\n        vec2 minMain, maxMain;\n\n        getTexBBox(float(mainTexIdx), minMain, maxMain);\n\n        vec4 fromUv = vec4(0., SEL_ZONE_Y, 1., 1.);\n        vec4 toUv = vec4(minMain, maxMain);\n        vec2 tuv = convertUv(uv, fromUv, toUv);\n\n        \n        ctrl.w = texture(iChannel1, tuv).w;\n    }\n    \n    if (in_texture && mainTexIdx != nextTexIdx)\n    {\n        ctrl.y = 1.;\n    }\n    else if (in_texture && ctrl.y > 0.5)\n    {\n        ctrl.y = 0.;\n    }\n    \n    \n    fragColor = vec4(ctrl);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Color Your Planet, Coloring buffer.\n    please see Documentation in Buffer C.\n*/\n\nvec3 fadeColor(in vec3 xyz, in float fade, in float radius, in vec2 muv, in vec2 uv)\n{\n    float ratio = iResolution.x / iResolution.y;\n    vec2 diff = abs(muv - uv);\n    diff.x *= ratio;\n    \n    float fx = clamp(1. - length(diff) / radius, 0., 1.);\n    int funcEnum = getIValue(fade, INTERP_FUNC_NUM);\n\n    vec2 grad = getGradFunction(fx, funcEnum);\n\n    xyz *= grad.x;\n    \n    return xyz;\n}\n\nvoid scene2D( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    vec4 incol = texture(iChannel0, uv);\n    float colored = 0.;\n    \n    bool isPath = bool(incol.w);\n    bool isCurrent = bool(incol.z);\n    \n    vec3 pickRGB = get_color(iChannel0);\n    float override = get_override(iChannel0);\n    bool click = iMouse.z > 0.5;\n    float blend_factor = get_blend_factor(iChannel0);\n    float fade = get_gradient_func(iChannel0);\n    \n    vec2 minMain, maxMain;\n\n    getTexBBox(getTextureIndex(get_texture_index(iChannel0)), minMain, maxMain);\n\n    vec4 fromUv = vec4(0., SEL_ZONE_Y, 1., 1.);\n    vec4 toUv = vec4(minMain, maxMain);\n    vec2 tuv = convertUv(uv, fromUv, toUv);\n\n    vec4 ccol = texture(iChannel1, uv);\n    vec4 switchCol = texture(iChannel2, tuv);\n    float radius = RADIUS_COEFF*get_radius(iChannel0);\n    \n    //float defaultCol = get_default_draw_color(iChannel0);\n    \n    vec4 texParams = get_texture_params(iChannel0);\n    float texIdx = texParams.w;\n    float stexIdx = texParams.z;\n    \n    float i_main = getTextureIndex(texIdx);\n    float i_second = getTextureIndex(stexIdx);\n    \n    bool block = false;\n    \n    if ((i_main) != (i_second) && get_color_block(iChannel0) > 0.5)\n    {\n        vec2 minSecond, maxSecond;\n        getTexBBox(i_second, minSecond, maxSecond);\n    \tvec4 stoUv = vec4(minSecond, maxSecond);\n        vec2 stuv = convertUv(uv, fromUv, stoUv);\n        vec2 mstuv = convertUv(muv, fromUv, stoUv);\n        \n        vec4 muvcol = texture(iChannel2, mstuv);\n        vec4 uvcol = texture(iChannel2, stuv);\n        \n        vec4 dv = abs(muvcol - uvcol);\n        \n        block = step(0.01, max(dv.x, max(dv.y, dv.z))) > 0.5;\n    }\n    \n    vec3 col;\n    \n    if (get_load_texture(iChannel0) || !texture_store(iChannel0))\n    {\n        col = switchCol.rgb;\n        colored = switchCol.w;\n    }\n    else if (isPath && isCurrent && block)\n    {\n        col = ccol.rgb;\n        colored = ccol.w;\n    }\n    else if (isPath && ccol.w < 0.5 && click && isCurrent && getIValue(override, BLEND_OPER_NUM) != BLEND_OPER_SMOOTH)\n    {\n        col.rgb = fadeColor(pickRGB, fade, radius, muv, uv);\n        colored = 1.;\n    }\n    else if (isPath && ccol.w > 0.5 && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_FIRST)\n    {\n        col.rgb = ccol.rgb;\n        colored = 1.;\n    }\n    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_SECOND)\n    {\n        \n        col.rgb = fadeColor(pickRGB, fade, radius, muv, uv);\n        colored = 1.;\n    }\n    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_MIX && click)\n    {\n        col.rgb = mix(ccol.rgb, fadeColor(pickRGB, fade, radius, muv, uv), blend_factor);\n        colored = 1.;\n    }\n    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_MAX && click)\n    {\n        col.rgb = max(ccol.xyz, fadeColor(pickRGB, fade, radius, muv, uv));\n        colored = 1.;\n    }\n    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_MIN && click)\n    {\n        col.rgb = min(ccol.rgb, fadeColor(pickRGB, fade, radius, muv, uv));\n        colored = 1.;\n    }\n    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_BIN && click)\n    {\n        col.rgb = fadeColor(pickRGB, fade, radius, muv, uv);\n        //colored = 1.;\n    }\n    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_SMOOTH && click)\n    {\n        vec3 ncol = vec3(0.);\n        ivec2 nr = ivec2(mod(fragCoord + vec2(1., 0.), iResolution.xy));\n        ivec2 nl = ivec2(mod(fragCoord - vec2(1., 0.), iResolution.xy));\n        ivec2 nu = ivec2(fragCoord + vec2(0., 1.));\n        ivec2 nd = ivec2(fragCoord - vec2(0., 1.));\n        \n        float wr = step(.5, iResolution.x - float(nr.x));\n        float wl = step(-.5, float(nl.x));\n        float wu = step(.5, iResolution.y - float(nu.y));\n        float wd = step(.5, float(nd.y) - ceil(SEL_ZONE_Y*iResolution.y));\n        \n        vec4 cr = texelFetch(iChannel1, nr, 0);\n        vec4 cl = texelFetch(iChannel1, nl, 0);\n        vec4 cu = texelFetch(iChannel1, nu, 0);\n        vec4 cd = texelFetch(iChannel1, nd, 0);\n        \n        float nnum = 0.;\n        if (wr > 0.5 && cr.w > 0.5)\n        {\n            ncol += cr.rgb;\n            nnum += 1.;\n        }\n        if (wd > 0.5 && cd.w > 0.5)\n        {\n            ncol += cd.rgb;\n            nnum += 1.;\n        }\n        if (wl > 0.5 && cl.w > 0.5)\n        {\n            ncol += cl.rgb;\n            nnum += 1.;\n        }\n        if (wu > 0.5 && cl.w > 0.5)\n        {\n            ncol += cu.rgb;\n            nnum += 1.;\n        }\n        \n        ncol /= nnum;\n        \n        if (length(ncol - ccol.rgb) > blend_factor*0.1)\n        {\n            col.rgb = ncol;\n        }\n        else\n        {\n            col = ccol.rgb;\n        }\n        colored = 1.;\n    }\n    else if (isPath && ccol.w > 0.5)\n    {\n        col.xyz = ccol.xyz;\n        colored = 1.;\n    }\n    else if (!isPath)\n    {\n        col.xyz = vec3(0.);\n    }\n    \n    if (get_control_zone(uv) > 0.5) // ctrl zone.\n    {\n        col.xyz = vec3(0.0);\n    }\n    \n    fragColor = vec4(col.xyz, colored);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    scene2D(fragColor, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Color Your Planet, common functionality.\n    please see Documentation in Buffer C.\n */\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_H 1.57079632679\n\n#define HERM3(x) (3.*x*x - 2.*x*x*x)\n#define DHERM3(x) (6.*x - 6.*x*x)\n#define SQUARE(x) (x*x)\n#define DSQUARE(x) (2.*x)\n#define LINEAR(x) (x)\n#define DLINEAR(X) 1.\n\n#define CIRCLE_CENTER vec2(0.5)\n#define CIRCLE_RADIUS 0.3\n#define CIRCLE_WIDTH 0.01\n#define LEFT_BRANCH vec2(0., 0.2)\n#define RIGHT_BRANCH vec2 (0.8, 1.)\n#define PACING_RADIUS 0.005\n#define REFACTORY_THR 0.2\n#define RADIUS_COEFF 0.1\n\n\n#define ERP_U_FACTOR 0.99999\n#define ERP_L_FACTOR 0.1\n\n#define SEL_ZONE_Y 0.01\n\n#define CTRL_MODE ivec2(0)\n#define CTRL_GUI ivec2(1, 0)\n#define CTRL_RADIUS ivec2(2, 0)\n#define CTRL_COLOR_ABC ivec2(3,0)\n#define CTRL_SHAPE ivec2(4, 0)\n#define CTRL_OVERRIDE ivec2(5, 0)\n#define CTRL_BLEND_FACTOR ivec2(6, 0)\n#define CTRL_GRADIENT_FUNC ivec2(7, 0)\n#define CTRL_BRUSH ivec2(8, 0)\n#define CTRL_BRUSH_FACTOR ivec2(9, 0)\n#define CTRL_TEXTURE ivec2(10, 0)\n#define CTRL_SHININESS ivec2(11, 0)\n#define CTRL_GUI_MENU ivec2(12, 0)\n#define CTRL_STARS ivec2(13, 0)\n\n#define CTRL_ORBIT_3D ivec2(15, 0)\n#define CTRL_UP_VECTOR_3D ivec2(16, 0)\n#define CTRL_TARGET_3D ivec2(17, 0)\n#define CTRL_LOCATION_3D ivec2(18, 0)\n#define CTRL_ACC_MOVE_3D ivec2(19, 0)\n\n#define CTRL_HIDE_UI ivec2(20, 0)\n#define CTRL_LOAD_TEXTURE ivec2(21, 0)\n#define CTRL_DEF_COLOR ivec2(22, 0)\n#define CTRL_COLOR_BLOCK ivec2(23, 0)\n\n\n#define SELECTION_MODE_MIN vec2(0.02, 0.78)\n#define SELECTION_MODE_MAX vec2(0.06, 0.95)\n\n#define SELECTION_RADIUS_MIN vec2(0.02, 0.45)\n#define SELECTION_RADIUS_MAX vec2(0.04, 0.6)\n\n#define SELECTION_COLOR_A_MIN vec2(0.02, 0.45)\n#define SELECTION_COLOR_A_MAX vec2(0.04, 0.6)\n\n#define SELECTION_COLOR_B_MIN vec2(0.05, 0.45)\n#define SELECTION_COLOR_B_MAX vec2(0.07, 0.6)\n\n#define SELECTION_COLOR_C_MIN vec2(0.08, 0.45)\n#define SELECTION_COLOR_C_MAX vec2(0.10, 0.6)\n\n#define SELECTION_SHAPE_MIN vec2(0.052, 0.46)\n#define SELECTION_SHAPE_MAX vec2(0.068, 0.6)\n\n#define SELECTION_OVERRIDE_MIN vec2(0.052, 0.46)\n#define SELECTION_OVERRIDE_MAX vec2(0.068, 0.6)\n\n#define SELECTION_BLEND_FACTOR_MIN vec2(0.11, 0.45)\n#define SELECTION_BLEND_FACTOR_MAX vec2(0.13, 0.6)\n\n#define SELECTION_FADE_MIN vec2(0.082, 0.46)\n#define SELECTION_FADE_MAX vec2(0.098, 0.6)\n\n#define SELECTION_BRUSH_MIN vec2(0.14, 0.45)\n#define SELECTION_BRUSH_MAX vec2(0.16, 0.6)\n\n#define SELECTION_TEXTURE_MIN vec2(0.022, 0.46)\n#define SELECTION_TEXTURE_MAX vec2(0.038, 0.6)\n\n#define SELECTION_SECONDARY_TEXTURE_MIN vec2(0.052, 0.46)\n#define SELECTION_SECONDARY_TEXTURE_MAX vec2(0.068, 0.6)\n\n#define SELECTION_TEXTURE_ALPHA_MIN vec2(0.08, 0.455)\n#define SELECTION_TEXTURE_ALPHA_MAX vec2(0.1, 0.605)\n\n#define SELECTION_MAIN_MENU_MIN vec2 (0.01, 0.65)\n#define SELECTION_MAIN_MENU_MAX vec2 (0.3, 0.74)\n\n#define SELECTION_STARS_MIN vec2(0.02, 0.6)\n#define SELECTION_STARS_MAX vec2(0.07, 0.62)\n\n#define SELECTION_HIDE_UI_MIN vec2(0.015, 0.7)\n#define SELECTION_HIDE_UI_MAX vec2(0.107, 0.76)\n\n#define SELECTION_LOAD_TEXTURE_MIN vec2(0.115, 0.54)\n#define SELECTION_LOAD_TEXTURE_MAX vec2(0.165, 0.60)\n\n#define SELECTION_DEF_DRAW_COLOR_MIN vec2(0.025, 0.39)\n#define SELECTION_DEF_DRAW_COLOR_MAX vec2(0.095, 0.43)\n\n#define SELECTION_COLOR_BLOCK_MIN vec2(0.176, 0.46)\n#define SELECTION_COLOR_BLOCK_MAX vec2(0.192, 0.6)\n\n\n#define BLEND_OPER_FIRST 0\n#define BLEND_OPER_SECOND 1\n#define BLEND_OPER_MIX 2\n#define BLEND_OPER_MAX 3\n#define BLEND_OPER_MIN 4\n#define BLEND_OPER_BIN 5\n#define BLEND_OPER_SMOOTH 6\n#define BLEND_OPER_COL_PICK 7\n\n#define BLEND_OPER_NUM 8.\n\n#define TEXTURES_NUM 4.\n#define TEXTURES_ROW 2.\n#define TEXTURES_INV_ROW .5\n\n#define MENU_OPT_TOOLS 0\n#define MENU_OPT_COLOR 1\n#define MENU_OPT_3D    2\n#define MENU_OPT_TEXTURE 3\n\n#define MENU_OPT_NUM 4.\n\n#define APPL_DRAW vec2(0., 0.2)\n#define APPL_ERASE vec2(0.2, 0.4)\n#define APPL_UI   vec2(0.4, .6)\n#define APPL_3D   vec2(0.6, .8)\n#define APPL_TEXTURES  vec2(0.8, 1.)\n\n#define INTERP_FUNC_FULL 0\n#define INTERP_FUNC_LINEAR 1\n#define INTERP_FUNC_QUAD 2\n#define INTERP_FUNC_HERM3 3\n#define INTERP_FUNC_INV_LINEAR 4\n#define INTERP_FUNC_INV_QUAD 5\n#define INTERP_FUNC_INV_HERM3 6\n\n#define INTERP_FUNC_NUM 7.\n\n#define DIFFUSE_MAP 0\n#define HEIGHT_MAP 1\n#define SPECULAR_MAP 2\n#define UNSPECIFIED 3\n\n#define SECONDARY_TEXTURE_DRAW_NONE    0\n#define SECONDARY_TEXTURE_DRAW         1\n#define SECONDARY_TEXTURE_DRAW_INVERSE 2\n\nbool in_zone(in vec2 uv, in vec2 zmin, in vec2 zmax, in float factor)\n{\n    return step(zmin.x*factor, uv.x)*step(zmin.y, uv.y)\n        *(1.-step(zmax.x*factor, uv.x))*(1.-step(zmax.y, uv.y)) > 0.5;\n}\n\nbool in_zone(in float val, in vec2 bound)\n{\n    return (step(bound.x, val) - step(bound.y, val)) > 0.5;\n}\n\nfloat get_ctrl_mode(in sampler2D s)\n{\n    return texelFetch(s, CTRL_MODE, 0).w;\n}\n\nfloat get_ui(in sampler2D s)\n{\n    return texelFetch(s, CTRL_GUI, 0).w;\n}\n\nfloat get_radius(in sampler2D s)\n{\n    return texelFetch(s, CTRL_RADIUS, 0).w;\n}\n\nvec3 get_color(in sampler2D s)\n{\n    return texelFetch(s, CTRL_COLOR_ABC, 0).rgb;\n}\n\nfloat get_override(in sampler2D s)\n{\n    return texelFetch(s, CTRL_OVERRIDE, 0).w;\n}\nfloat get_shape(in sampler2D s)\n{\n    return texelFetch(s, CTRL_SHAPE, 0).w;\n}\nfloat get_blend_factor(in sampler2D s)\n{\n    return texelFetch(s, CTRL_BLEND_FACTOR, 0).w;\n}\n\nfloat get_gradient_func(in sampler2D s)\n{\n    return texelFetch(s, CTRL_GRADIENT_FUNC, 0).w;\n}\n\nfloat get_brush_type(in sampler2D s)\n{\n    return texelFetch(s, CTRL_BRUSH, 0).w;\n}\n\nfloat get_texture_index(in sampler2D s)\n{\n    return texelFetch(s, CTRL_TEXTURE, 0).w;\n}\n\nfloat get_secondary_texture_index(in sampler2D s)\n{\n    return texelFetch(s, CTRL_TEXTURE, 0).z;\n}\n\nvec4 get_texture_params(in sampler2D s)\n{\n    return texelFetch(s, CTRL_TEXTURE, 0);\n}\n\nfloat get_default_draw_color(in sampler2D s)\n{\n    return texelFetch(s, CTRL_DEF_COLOR, 0).w;\n}\n\nvec3 get_up_vector(in sampler2D s)\n{\n    return texelFetch(s, CTRL_UP_VECTOR_3D, 0).xyz;\n}\n\nvec3 get_target_vector(in sampler2D s)\n{\n    return texelFetch(s, CTRL_TARGET_3D, 0).xyz;\n}\n\nvec3 get_cam_location(in sampler2D s)\n{\n    return texelFetch(s, CTRL_LOCATION_3D, 0).xyz;\n}\n\nfloat get_stars(in sampler2D s)\n{\n    return texelFetch(s, CTRL_STARS, 0).w;\n}\n\nbool get_hide_ui(in sampler2D s)\n{\n    return texelFetch(s, CTRL_HIDE_UI, 0).w > 0.05;\n}\n\nbool get_load_texture(in sampler2D s)\n{\n    return texelFetch(s, CTRL_LOAD_TEXTURE, 0).w > 0.05;\n}\n\nbool texture_store(in sampler2D s)\n{\n    return texelFetch(s, CTRL_TEXTURE, 0).y < 0.5;\n}\n\nfloat get_texture_switch_alpha(in sampler2D s)\n{\n    return texelFetch(s, CTRL_TEXTURE, 0).x;\n}\n\nfloat get_main_menu_val(in sampler2D s)\n{\n    return texelFetch(s, CTRL_GUI_MENU, 0).w;\n}\n\nvec2 get_control_orbit(in sampler2D s)\n{\n    return texelFetch(s, CTRL_ORBIT_3D, 0).xy;\n}\n\nfloat get_color_block(in sampler2D s)\n{\n    return texelFetch(s, CTRL_COLOR_BLOCK, 0).w;\n}\n\nvec2 get_accumulated_move(in sampler2D s)\n{\n    return texelFetch(s, CTRL_ACC_MOVE_3D, 0).xy;\n}\n\nfloat get_simulation_zone(in vec2 uv)\n{\n    bool not_on_button = !in_zone(uv, SELECTION_MODE_MIN, SELECTION_MODE_MAX, 1.);\n    return float(uv.y > SEL_ZONE_Y) * float(not_on_button);\n}\n\nfloat get_simulation_zoneI(in vec2 uv)\n{\n    return float(uv.y > SEL_ZONE_Y);\n}\n\nfloat saturate(in float value, in float bmin, in float bmax)\n{\n    return clamp((value - bmin) / (bmax - bmin), 0., 1.);\n}\n\nfloat get_control_zone(in vec2 uv)\n{\n    return float(uv.y <= SEL_ZONE_Y);\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(in vec2 uv, in vec2 c, in float r)\n{\n    return r - length(uv - c);\n}\n\n\nfloat circle(vec2 _uv, float _radius)\n{\n    return step(_radius, length(_uv));\n}\n\nint getIValue(float _v, float _n)\n{   \n    return int(_v * _n);\n}\n\nfloat getTextureIndex(float _v)\n{\n    return floor(_v * TEXTURES_NUM);\n}\n\nvec2 normToTextureUv(in vec2 normUv, float texIdx, vec2 resolution)\n{\n    vec2 texMinRC = vec2(0., floor(texIdx * TEXTURES_INV_ROW));\n    texMinRC.x = texIdx - texMinRC.y*TEXTURES_ROW;\n    vec2 texMin = TEXTURES_INV_ROW * texMinRC;\n    vec2 texMax = texMin + vec2(TEXTURES_INV_ROW); \n    \n    vec2 btexMin = ceil(texMin * resolution + 2.) / resolution;\n    vec2 btexMax = floor(texMax * resolution - 2.) / resolution;\n    \n    vec2 resUv = normUv * (btexMax - btexMin);\n    \n    vec2 tuv = btexMin + resUv;\n\n    return tuv;\n}\n\nvoid getTexBBox(float texIdx, out vec2 _min, out vec2 _max)\n{\n    vec2 texMinRC = vec2(0., floor(texIdx * TEXTURES_INV_ROW));\n    texMinRC.x = texIdx - texMinRC.y*TEXTURES_ROW;\n    _min = TEXTURES_INV_ROW * texMinRC;\n    _max = _min + vec2(TEXTURES_INV_ROW);\n}\n\nvec2 convertUv(in vec2 uv, in vec4 from, in vec4 to)\n{\n    vec2 nd = (uv - from.xy) / (from.zw - from.xy);\n    vec2 cuv = to.xy + (to.zw - to.xy) * nd;\n    return cuv;\n}\n\nvec2 getGradFunction(in float fx, in int funcEnum)\n{\n    float of_x, df_x;\n    switch(funcEnum)\n    {\n        case INTERP_FUNC_FULL:\n        \tof_x = 1.;\n        \tdf_x = 1.;\n        \tbreak;\n        case INTERP_FUNC_LINEAR:\n        \tof_x = LINEAR(fx);\n        \tdf_x = DLINEAR(fx);\n        \tbreak;\n        case INTERP_FUNC_QUAD:\n        \tof_x = SQUARE(fx);\n        \tdf_x = DSQUARE(fx);\n        \tbreak;\n        case INTERP_FUNC_HERM3:\n        \tof_x = HERM3(fx);\n        \tdf_x = DHERM3(fx);\n        \tbreak;\n        case INTERP_FUNC_INV_LINEAR:\n        \tof_x = 1. - LINEAR(fx);\n        \tdf_x = -DLINEAR(fx);\n        \tbreak;\n        case INTERP_FUNC_INV_QUAD:\n        \tof_x = 1. - SQUARE(fx);\n        \tdf_x = -DSQUARE(fx);\n        \tbreak;\n        case INTERP_FUNC_INV_HERM3:\n        \tof_x = 1. - HERM3(fx);\n        \tdf_x = -DHERM3(fx);\n        \tbreak;\n    }\n    \n    return vec2(of_x, df_x);\n}\n\nfloat rect(vec2 _uv, vec4 _bxy)\n{\n    vec2 f2 = step(_bxy.xy, _uv) - step(_bxy.zw, _uv);\n    \n    return f2.x*f2.y;\n}\n\n/*vec3 rgb2hsv( const in vec3 c )\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n//--------------------------------------------------------------------------------------------------------------------//\nvec3 hsv2rgb( const in vec3 c )\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n*/\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/* Color Your Planet:\n\n   Intended for full screen usage. \n   It runs on UHD 630 (notebook) at about 10 - 15 fps (full HD). \n\n   Acknowledments: Dave Hoskins for hash functions.\n\n    Usage example 1:\n    https://youtu.be/ea_E4zCeYyM\n\n    Usage example 2:\n    https://youtu.be/CUfh76ndGDA\n                  \n   Main Menu (5 options radio button): Draw, Erase, GUI, 3D, Textures\n\n   GUI Menu:\n\n   Tools:\n     Radius slider - drawing radius.\n     Operation radio button (8 options): \n       A + B = A --> draw on empty. Doesn't draw on already colored pixel.\n       A + B = B --> draw on top.\n       MIX(A,B) --> mix new with existing colors. use Blend slider as blending alpha.\n       MAX(A,B) --> maximum of existing and a new colors (on each channel).\n       MIN(A,B) --> minimum of existing and a new colors (on each channel).\n       B = NOT(A) --> if pixel is colored than clear, otherwise draw a new color.\n       Smooth --> smooth/blur via laplace. Blend slider controls interpolation threshold.\n       Color pick --> picks a color from scene. Select different drawing operation once\n                      picked required color.\n     \n     Function radio button (7 options): interpolation function. given a pixel inside drawing radius\n              the applied color will be: color * f(distance(pixel, mouse pixel)). \n     \n     Blend slider --> used in MIX and Smooth operations.\n     Brush slider --> Fill/Brush. Works both in DRAW and ERASE modes.\n     Secondary texture context radio button (2 options) --> available only if secondary texture index\n              differs from the main texture index. If turned on (upper selection) the color\n              of a pixel within drawing radius is applied only if its' color on secondary\n              texture equals the color under mouse position (drawing radius center). Thus\n              different height or specular can be applied based on different diffuse color\n              and vice versa.\n    Color:\n     Coloring channels. RGB for diffuse, R for height and specular. The final color is\n              reflected in the radius UI.\n    3D:\n     Stars background on/off (2 options radio button).\n    Textures:\n      Main radio button (3 options, the fourth is unused): The painted texture (diffuse, height specular).\n      Secondar radio button (3 options, the fourth is unused): reference texture.\n      Blend: Main on Secondary texture blending.\n      Load: load the packed texture that contains the diffuse, height and specular parts.\n            The loaded texture is taken from channel 3 buffer C (this one). To load a custom\n            texure one needs to either use a server or a custom shadertoy texture add-on.\n\n    \n    Textures mode shows the packed texture. the 10s hide button hides all UI for 10 seconds\n    to allow to save/print screen the texture in this period. This saved texture may be \n    loaded later via the Load button in GUI -> Textures tab.\n*/   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 frameMin, frameMax;\n    float texIdx = getTextureIndex(get_texture_index(iChannel2));\n    getTexBBox(texIdx, frameMin, frameMax);\n    \n    if (get_load_texture(iChannel2))\n    {\n        fragColor = texture(iChannel3, uv);\n    }\n    else if (in_zone(uv, frameMin, frameMax, 1.) && texture_store(iChannel2))\n    {\n        vec4 from = vec4(frameMin, frameMax);\n        vec4 to = vec4(0., SEL_ZONE_Y, 1., 1.);\n        vec2 tuv = convertUv(uv, from, to);\n        fragColor = texture(iChannel0, tuv);\n    }\n    else\n    {\n        fragColor = texture(iChannel1, uv);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}