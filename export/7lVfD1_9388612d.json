{"ver":"0.1","info":{"id":"7lVfD1","date":"1664466611","viewed":134,"name":"Parabola Circle Intersection 2","username":"jt","description":"Applied mla's implementation of depressed quartic solver from [url=https://www.shadertoy.com/view/7dSBWz]Cyclides[/url] to extend [url= https://www.shadertoy.com/view/NtyfD1]Parabola Circle Intersection[/url] for arbitrary offsets and scale.\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["intersection","circle","quartic","parabola","depressed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/7lVfD1 Parabola Circle Intersection 2 by jt\n// Apply depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n// to https://www.shadertoy.com/view/NtyfD1 Parabola Circle Intersection by jt\n\n// Intersections between parabolas and primitives could be used to animate collisions (for stability) of bouncing balls without actually simulating the physics.\n\n// tags: intersection, circle, parabola, depressed, quartic\n\n// Potentially relevant links:\n// https://en.wikipedia.org/wiki/Quartic_function\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf (thanks, mla!)\n// https://www.nickalls.org/dick/papers/maths/quartic2009.pdf\n// https://www.maa.org/press/periodicals/convergence/descartes-method-for-constructing-roots-of-polynomials-with-simple-curves-depressed-quartics-and\n\n// NOTE: For a possible OTHER shader, parabola-parabola intersection, from https://www.geogebra.org/m/X2E9Dzvs \"Intersection of a vertical and horizontal parabola\"\n//       \"The intersection points of a vertical and horizontal parabola lie on a circle whose centre's distance from the directrices is the sum of distances of the foci from the directrices (in both the x and y directions.\"\n\n#define POINTSIZE 0.01\n#define draw_point(q) o *= smoothstep(0.0, POINTSIZE, abs(q))\n#define draw_circle(r, I) draw_point(length(I) - r)\n#define draw_quadratic(A, B, C, I) draw_point(draw_quadratic_helper(A, B, C, I))\n\nfloat parabola(float A, float B, float C, float x)\n{\n    return A*x*x+B*x+C;\n}\n\nfloat parabola_derivative(float A, float B, float x) // NOTE: C disappears due by derivative\n{\n    return 2.0*A*x+B;\n}\n\nfloat draw_quadratic_helper(float A, float B, float C, vec2 I)\n{\n    return (parabola(A, B, C, I.x)-I.y)/length(vec2(parabola_derivative(A, B, I.x),-1.0)); // divide by length of the gradient to get a constant width line \n}\n\n// START depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  x1 = C/r;\n  x2 = r/A;\n  res = vec2(x1,x2);\n  return 2;\n}\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nvoid eval(float X, float B, float C, float D,\n          out float Q, out float DQ, out float B1,out float C2) {\n  float q0 = X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  DQ = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\nfloat qcubic(float B, float C, float D)\n{\n  float X,b1,c2;\n  X = -B/3.0;\n  float t,r,s,q,dq,x0;\n  eval(X,B,C,D,q,dq,b1,c2);\n  t = q; r = pow(abs(t),1.0/3.0); s = sgn(t);\n  t = -dq; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n  x0 = X - s*r;\n  if (x0 != X) {\n    X = x0;\n    for (int i = 0; i < 4; i++) {\n      eval(X,B,C,D,q,dq,b1,c2);\n      if (dq == 0.0) break;\n      X -= q/dq;\n    }\n    if (X*X > abs(D/X)) {\n      c2 = -D/X; b1 = (c2 - C)/X;\n    }\n  }\n  vec2 res;\n  if (quadratic(1.0,b1,c2,res) == 0) return X;\n  X = max(X,res[0]);\n  X = max(X,res[1]);\n  return X;\n}\n\nint biquadratic(float p, float r, out vec4 res)\n{\n  // Solve x^4 + px^2 + r = 0 (ie. a quadratic equation in x^2)\n  vec2 t;\n  if (quadratic(1.0,p,r,t) == 0) return 0;\n  int n = 0;\n  for (int i = 0; i < 2; i++) {\n    if (t[i] >= 0.0) {\n      float x = sqrt(t[i]);\n      res[n++] = -x;\n      res[n++] = x;\n    }\n  }\n  return n;\n}\n\n// Descartes solver for depressed quartics\n// ie. x^4 + px^2 + qx + r = 0\nint dquartic(float p, float q, float r, out vec4 res) {\n  if (abs(q) < 0.001) return biquadratic(p,r,res);\n  float A = 2.0*p;\n  float B = p*p-4.0*r;\n  float C = -q*q;\n  float U = qcubic(A,B,C);\n  //assert(U >= 0.0);\n  float u = sqrt(U);\n  float s = -u;\n  float t = 0.5*(p+U+q/u);\n  float v = 0.5*(p+U-q/u);\n  int n1 = quadratic(1.0,s,t,res.xy);\n  int n2 = quadratic(1.0,u,v,res.zw);\n  if (n1 == 0) res.xy = res.zw;\n  return n1+n2;\n}\n\n// END depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n\nvoid mainImage(out vec4 o, vec2 I)\n{\n    vec2 R = iResolution.xy;\n    I = (I+I-R)/R.y;\n\n    o = vec4(1);\n\n    float d = mix(0.9, 0.75, cos(iTime/2.0) * 0.5 + 0.5);\n    draw_point(length(I) - d); // circle\n\n    float x0 = cos(iTime * 0.2) * d * mix(0.5, 1.0, cos(iTime/3.0) * 0.5 + 0.5);\n    float y0 = sin(iTime * 0.2) * d * mix(-1.5, 0.5, cos(iTime) * 0.5 + 0.5);\n\n    float s = mix(0.2, 2.0, cos(iTime) * 0.5 + 0.5); // scale parabola\n\n    // y = ((x - x0)/s)^2 + y0 by solving x = s*t + x0 for t then plugging into y = t*t + y0\n    // y = x^2/s^2 - 2*x*x0/s^2 + x0^2/s^2 + y0\n    // y = A * x^2 + B * x + C\n    float A = 1.0/(s*s), B = -2.0*x0/(s*s), C = x0*x0/(s*s)+y0;\n    draw_quadratic(A, B, C, I);\n\n    // x = s*t + x0\n    // y = t*t + y0\n    // d^2 = x*x+y*y\n    // d^2 = (s*t+x0)^2 + (t^2+y0)^2\n    // d^2 = s^2*t^2 + 2*s*t*x0 + x0^2 + t^4 + 2*t^2*y0 + y0^2\n    // 0 = t^4 + t^2*(s^2+2*y0) + 2*s*t*x0 + (x0^2+y0^2-d^2)\n    // 0 = t^4 + p * t^2 + q * t + r\n    float p = s*s+2.0*y0;\n    float q = 2.0*s*x0;\n    float r = x0*x0+y0*y0-d*d;\n\n    vec4 roots;\n    int n = dquartic(p, q, r, roots);\n\n    if(n > 0) draw_circle(0.025, I - vec2(s*roots.x+x0, roots.x*roots.x+y0));\n    if(n > 1) draw_circle(0.025, I - vec2(s*roots.y+x0, roots.y*roots.y+y0));\n    if(n > 2) draw_circle(0.025, I - vec2(s*roots.z+x0, roots.z*roots.z+y0));\n    if(n > 3) draw_circle(0.025, I - vec2(s*roots.w+x0, roots.w*roots.w+y0));\n}\n","name":"Image","description":"","type":"image"}]}