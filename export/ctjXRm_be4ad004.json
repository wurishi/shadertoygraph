{"ver":"0.1","info":{"id":"ctjXRm","date":"1675967099","viewed":70,"name":"LightStyleGoggleGam","username":"RedWool","description":"Colorful stuff","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["adw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgb2hcv(in vec3 rgb)\n{\n    // Credit: https://www.shadertoy.com/view/4dKcWK\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + 1e-10) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 rgb2hsv(in vec3 rgb)\n{\n    // Credit: https://www.shadertoy.com/view/4dKcWK\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = rgb2hcv(rgb);\n    float s = hcv.y / (hcv.z + 1e-10);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1.);\n\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nfloat rand (float r)\n{\n    return fract(sin(r*728.731)*847.315)*38.92;\n}\n\nfloat metaCircle(vec2 uv)\n{\n    float minDist = 10.;\n    vec2 minPos = vec2(0), f = fract(uv), i = floor(uv);\n\n    for (int x = -2; x < 3; x++)\n    {\n        for (int y = -2; y < 3; y++)\n        {\n            vec2 c = i + vec2(x,y),\n            d = sin(vec2(rand(c.x*38.4+c.y)+iTime*.07,rand(c.y*92.1+c.x)+iTime*.06)+iTime*.2)*1.,\n            p = c+d;\n            float dif = length(uv - p), v = clamp((minDist-dif)/.5 * .5 + .5,0.,1.);\n            dif = mix(minDist, dif, v) - .5 * v * (1.-v);\n            \n            if (minDist > dif)\n            {\n                minPos = p;\n                minDist = dif;\n                \n            }\n            \n            \n        }\n    }\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    uv.x *= .7;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv-.5).xyz;\n    vec3 hsv = rgb2hsv(col);\n    \n    float d = metaCircle(uv*2.)+sin(length(uv)*30.+atan(uv.y,uv.x)*10. + iTime*.3)*.05 ;\n    d *= step(d,.5);\n    hsv.z += d*1.;\n    hsv.x += (d*2.+step(1e-5,d)*step(d,.4)*length(uv))-step(.4,d)*iTime*.1;\n    col = hsv2rgb(hsv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}