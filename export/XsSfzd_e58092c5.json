{"ver":"0.1","info":{"id":"XsSfzd","date":"1501619408","viewed":497,"name":"Connected Particles","username":"clintolibre","description":"Wandering Particles connected by lines. Adjust numParticles for performance/complexity. Based off of https://threejs.org/examples/#webgl_buffergeometry_drawcalls","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ideas borrowed heavily from https://www.shadertoy.com/view/lsy3R1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    //root of the number of particles, adjust for complexity\n    int numParticles = 20;\n    \n    float maxDistance = .6;\n    float minDistance = 0.0;\n    \n    //these two loops determine how many particles render.\n    for (int x = 0; x<=numParticles; x++) {\n        //fetch particle\n        vec4 particle = texture(iChannel0, vec2(x, 0)/iResolution.xy);\n        //get pixel coords for particles   \n        vec2 nearestP = vec2(floor(iResolution.x*particle.x), floor(iResolution.y*particle.y));\n        //draw point\n        \n        for (int a = 0; a<=numParticles; a++) {\n            //remove 1/numParticles of the work\n            if (x != a) {\n                //fetch particle\n                vec4 particle2 = texture(iChannel0, vec2(a, 0)/iResolution.xy);\n                //get pixel coords for particles        \n                vec2 nearestP2 = vec2(floor(iResolution.x*particle2.x), floor(iResolution.y*particle2.y));\n\t\t\t\t\n                //diffs used for distance and slope\n                float diffy = nearestP.y-nearestP2.y;\n                float diffx = nearestP.x-nearestP2.x;\n\t\t\t\t\n          \t\t//distance between points\n                float addExp = pow(diffx/iResolution.x, 2.0) + pow(diffy/iResolution.x,2.0);\n                float ldistance = pow(addExp, .5);\n                \n                if (ldistance < maxDistance && ldistance > minDistance) {\n                    //line equation\n                    float slope = (diffy)/(diffx);\n                    float intercept = nearestP.y-(slope*nearestP.x);\n\n                    //find out what pixel would be on the line for these two points\n                    vec2 intended = vec2(floor(fragCoord.x), floor((fragCoord.x*slope)+intercept));\n\n                    //throw away the points that are not between the two points\n                    vec2 mins = min(nearestP, nearestP2);\n                    vec2 maxs = max(nearestP, nearestP2);\n                    intended = clamp(intended, mins, maxs);\n\n                    //draw Lines\n                    if (floor(fragCoord) == intended) {\n                        //variation by length, adjusts for max Distance\n                        float col = pow(1.0-ldistance, 8.0/maxDistance);\n                        //always draw brightest line on top\n                        if (col > fragColor.x) {\n                            fragColor = vec4(vec3(col), 1.0);\n                        }\n                    }\n                }\n            }\n        }\n        //draw points;\n        if (floor(fragCoord) == (floor(nearestP))) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ideas borrowed heavily from https://www.shadertoy.com/view/lsy3R1\n\n// Random function from https://www.shadertoy.com/view/4ssXRX\n// note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //we'll use this normalized uv to generate our random starting position and grab textures\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if (iFrame == 1)\n    {\n        //randomize positions on first frame\n        fragColor = vec4(nrand(uv), nrand(uv.yx), 0.0 , 0.0);\n        return;\n    }\n    //dont want to do additional work for non-used pixels\n\n    //grab particle data from last frame\n    vec4 previousFrameValues = texture(iChannel0, uv);\n    vec4 noise = texture(iChannel1, uv);\n\n    //position and velocity\n    vec2 pos = previousFrameValues.xy;\n    vec2 vel = previousFrameValues.zw;\n\n    //random variable to change velocities, hence \"wandering\"\n    //I might take the noise back out, I was having trouble with random movement.\n    float rand = nrand(vec2(sin(iTime)+noise.x, sin(iTime)+noise.y))-.499;\n    float rand2 = nrand(vec2(sin(iTime)+noise.y, sin(iTime)+noise.x))-.499;\n\n    //accelerate particles\n    vel.x = vel.x + (rand/5000.0);\n    vel.y = vel.y + (rand2/5000.0);\n\n    //cancel particle velocity  on mouse click\n    if (iMouse.w>0.01)\n    {\n        vel = vec2(0.0);\n    }\n\n    //limit particle velocity for smooth movement\n    vel.x = clamp(vel.x, -0.004, 0.004);\n    vel.y = clamp(vel.y, -0.004, 0.004);\n\n    //calculate new position of particles\n    pos.x = pos.x + vel.x;\n    pos.y = pos.y + vel.y;\n    //if particles drift outside the line, stop em in their tracks!\n    if (pos.x < -0.2) {\n        pos.x = 1.0;\n    } else if (pos.x > 1.2) {\n        pos.x = 0.0;\n    }\n    if (pos.y < -0.2) {\n        pos.y = 1.0;\n    } else if (pos.y > 1.2) {\n        pos.y = 0.0;\n    }\n\n    //send particle information to buffer!\n    fragColor = vec4(pos.x, pos.y, vel.x, vel.y);\n}","name":"Buffer A","description":"","type":"buffer"}]}