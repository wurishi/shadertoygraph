{"ver":"0.1","info":{"id":"dtK3WG","date":"1684603905","viewed":318,"name":"20230520_balancing act","username":"0b5vr","description":"Balancing Act by 0b5vr\nAppeared in Outline 2023 4k Executable Graphics Compo\n\nHeavily inspired by Masoud Yasami's painting works, of course.\nOriginally made with Blossom, the 4k exegfx framework. Shoutouts to yx!\n","likes":37,"published":1,"flags":32,"usePreview":0,"tags":["3d","cubes","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Present\n\n#define saturate(i) clamp(i,0.,1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec4 tex = texelFetch( iChannel0, ivec2( fragCoord ), 0 );\n\n  vec3 color = tex.rgb / tex.a;\n  color = mix(\n    12.92 * color,\n    pow( 1.055 * color, vec3( 1.0 / 2.4 ) ) - 0.055,\n    step( 0.0031308, color )\n  );\n\n  fragColor = vec4( color, 1 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Draw\n\n// Originally made with Blossom, the 4k exegfx framework\n// https://github.com/lunasorcery/Blossom\n\nconst float TAU = acos( -1. ) * 2.0;\nconst float FAR = 100.0;\n\nuvec3 pcg3d( uvec3 s ) {\n  s = s * 1145141919u + 1919810u;\n\n  s.x += s.y * s.z;\n  s.y += s.z * s.x;\n  s.z += s.x * s.y;\n\n  s ^= s >> 16;\n\n  s.x += s.y * s.z;\n  s.y += s.z * s.x;\n  s.z += s.x * s.y;\n\n  return s;\n}\n\nvec3 pcg3df( vec3 s ) {\n  uvec3 r = pcg3d( floatBitsToUint( s ) );\n  return vec3( r ) / float( -1u );\n}\n\nuvec3 seed;\nvec3 random3() {\n  seed = pcg3d( seed );\n  return vec3( seed ) / float( -1u );\n}\n\nfloat safeDot( vec3 a, vec3 b ) {\n  return clamp( dot( a, b ), 0.0001, 1.0 );\n}\n\nmat2 rotate2D( float t ) {\n  float c = cos( t ), s = sin( t );\n  return mat2( c, s, -s, c );\n}\n\nmat3 orthBas3( vec3 z, vec3 t ) {\n  z = normalize( z );\n  vec3 x = normalize( cross( normalize( t ), z ) );\n  return mat3( x, cross( z, x ), z );\n}\n\nmat3 orthBas( vec3 z ) {\n  z = normalize( z );\n  vec3 up = abs( z.y ) < 0.999 ? vec3( 0.0, 1.0, 0.0 ) : vec3( 0.0, 0.0, 1.0 );\n  return orthBas3( z, up );\n}\n\nvec3 cyclicNoise( vec3 p ) {\n  vec4 sum = vec4( 0.0 );\n  mat3 basis = orthBas( vec3( -1.0, 2.0, -3.0 ) );\n\n  for ( int i = 0; i < 5; i ++ ) {\n    p *= basis;\n    p += 0.6 * sin( p.yzx );\n    sum += vec4(\n      cross( cos( p ), sin( p.zxy ) ),\n      1.0\n    );\n    sum *= 2.0;\n    p *= 2.0;\n  }\n\n  return sum.xyz / sum.w;\n}\n\nvec3 importanceSampleLambert( vec3 N ) {\n  vec3 dice = random3();\n  float phi = TAU * dice.x;\n  float cosTheta = clamp( sqrt( dice.y ), 0.0, 1.0 );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\nvec3 importanceSampleGGX( float roughness, vec3 N ) {\n  vec3 dice = random3();\n  float phi = TAU * dice.x;\n  float cosTheta = dice.y;\n  cosTheta = clamp(\n    sqrt( ( 1.0 - cosTheta ) / ( 1.0 + ( pow( roughness, 4.0 ) - 1.0 ) * cosTheta ) ),\n    0.0,\n    1.0\n  );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\nvec4 isectSphere( vec3 ro, vec3 rd, float r ) {\n  float b = dot( ro, rd );\n  float c = dot( ro, ro ) - r * r;\n  float h = b * b - c;\n\n  if ( h < 0.0 ) { return vec4( FAR ); }\n\n  float t = -b - sqrt( h );\n  if ( 0.0 < t ) {\n    return vec4( normalize( ro + rd * t ), t );\n  }\n\n  return vec4( FAR );\n}\n\nvec4 isectISphere( vec3 ro, vec3 rd, float r ) {\n  float b = dot( ro, rd );\n  float c = dot( ro, ro ) - r * r;\n  float h = b * b - c;\n\n  if ( h < 0.0 ) { return vec4( FAR ); }\n\n  float t = -b + sqrt( h );\n  if ( 0.0 < t ) {\n    return vec4( -normalize( ro + rd * t ), t );\n  }\n\n  return vec4( FAR );\n}\n\nvec4 isectPillar( vec3 ro, vec3 rd, float r, float len ) {\n  float sqLenXY = 1.0 - rd.z * rd.z;\n\n  float b = dot( ro, rd ) - ro.z * rd.z;\n  float c = dot( ro, ro ) - ro.z * ro.z - r * r;\n  float h = b * b - sqLenXY * c;\n\n  if ( h < 0.0 ) { return vec4( FAR ); }\n\n  h = sqrt( h );\n  float t = -( b + h ) / sqLenXY;\n  vec3 rp = ro + rd * t;\n  if ( abs( rp.z ) < len && 0.0 < t ) {\n    return vec4(\n      vec3( 1.0, 1.0, 0.0 ) * rp / r,\n      t\n    );\n  }\n\n  float capDir = sign( rp.z );\n  float dCap = ( capDir * len - ro.z ) / rd.z;\n  if ( abs( sqLenXY * dCap + b ) < h && 0.0 < dCap ) {\n    vec3 N = vec3( 0.0, 0.0, capDir );\n    return vec4( N, dCap );\n  }\n\n  return vec4( FAR );\n}\n\nvec4 isectIPillar( vec3 ro, vec3 rd, float r, float len ) {\n  float sqLenXY = 1.0 - rd.z * rd.z;\n\n  float b = dot( ro, rd ) - ro.z * rd.z;\n  float c = dot( ro, ro ) - ro.z * ro.z - r * r;\n  float h = b * b - sqLenXY * c;\n\n  if ( h < 0.0 ) { return vec4( FAR ); }\n\n  h = sqrt( h );\n  float t = -( b - h ) / sqLenXY;\n  vec3 rp = ro + rd * t;\n  if ( abs( rp.z ) < len && 0.0 < t ) {\n    return vec4(\n      -vec3( 1.0, 1.0, 0.0 ) * rp / r,\n      t\n    );\n  }\n\n  float capDir = sign( rp.z );\n  float dCap = ( capDir * len - ro.z ) / rd.z;\n  if ( abs( sqLenXY * dCap + b ) < h && 0.0 < dCap ) {\n    vec3 N = vec3( 0.0, 0.0, -capDir );\n    return vec4( N, dCap );\n  }\n\n  return vec4( FAR );\n}\n\nvec4 isectBox( vec3 ro, vec3 rd, vec3 s ) {\n  vec3 xo = -ro / rd;\n  vec3 xs = abs( s / rd );\n\n  vec3 dfv = xo - xs;\n  vec3 dbv = xo + xs;\n\n  float df = max( dfv.x, max( dfv.y, dfv.z ) );\n  float db = min( dbv.x, min( dbv.y, dbv.z ) );\n  if ( df < 0.0 || db < df ) { return vec4( FAR ); }\n\n  vec3 n = -sign( rd ) * step( vec3( df ), dfv );\n  return vec4( n, df );\n}\n\nvec4 isectIBox( vec3 ro, vec3 rd, vec3 s ) {\n  vec3 xo = -ro / rd;\n  vec3 xs = abs( s / rd );\n\n  vec3 dbv = xo + xs;\n\n  float db = min( dbv.x, min( dbv.y, dbv.z ) );\n  if ( db < 0.0 ) { return vec4( FAR ); }\n\n  vec3 n = -sign( rd ) * step( dbv, vec3( db ) );\n  return vec4( n, db );\n}\n\nvec4 isectPlane( vec3 ro, vec3 rd, vec3 n ) {\n  n = dot( n, rd ) < 0.0 ? n : -n;\n  float t = -dot( ro, n ) / dot( rd, n );\n  return mix( vec4( FAR ), vec4( n, t ), step( 0.0, t ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  mat3 ROT_DISC = orthBas( vec3( -0.3, 0.0, 1.0 ) );\n  mat3 ROT_BOARD = orthBas3( vec3( -0.1, -0.1, 1.0 ), vec3( 0.2, 1.0, 0.0 ) );\n\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  seed = uvec3( gl_FragCoord.xy, iFrame );\n\n  vec2 p = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n\n  float inMedium = 0.0;\n\n  vec3 ro, rd, ro2, rd2;\n\n  float ampRem;\n  float amp;\n  float wave;\n  float ior;\n  vec4 col = vec4( 0.0 );\n\n  vec4 isect, isect2;\n\n  for ( int i = 0; i < 60; i ++ ) {\n    if ( ampRem < 0.001 ) {\n      // cringe\n      col += vec4(\n        amp * smoothstep( 0.1, 0.0, abs( wave - vec3( 0.7, 0.6, 0.5 ) ) ),\n        1.0\n      );\n\n      ro = vec3( 2.0 * ( p + 2.0 * random3().xy / iResolution.y ), 5.0 );\n      rd = normalize( vec3( 0.001, 0.001, -1.0 ) );\n      ampRem = 4.0;\n      amp = inMedium = 0.0;\n      wave = mix( 0.4, 0.8, random3().x );\n      ior = 1.4 + 0.04 / wave / wave; // cringe\n    }\n\n    const float REFRACT_ROUGH = 0.2;\n    const float DISC_RAD = 0.65;\n    const float DISC_THIC = 0.04;\n    const vec3 DISC_POS = vec3( 0.2, -0.25, 0.0 );\n\n    const float SPHERE_RAD = 0.3;\n    const vec3 SPHERE_POS = vec3( -2.55, 0.8, 0.0 );\n\n    const vec3 BOARD_SIZE = vec3( 0.5, 1.27, 0.04 );\n    const vec3 BOARD_POS = vec3( 2.0, -1.1, 0.0 );\n\n    if ( inMedium > 0.0 ) {\n      // inside\n      if ( inMedium == 1.0 ) {\n        isect = isectIPillar( ROT_DISC * ( ro - DISC_POS ), ROT_DISC * rd, DISC_RAD, DISC_THIC );\n        isect.xyz *= ROT_DISC;\n        // fragColor=vec4(0.5+0.5*isect.xyz,1.0);\n        // return;\n      } else if ( inMedium == 2.0 ) {\n        isect = isectISphere( ro - SPHERE_POS, rd, SPHERE_RAD );\n      } else if ( inMedium == 3.0 ) {\n    \t\tisect = isectIBox( ROT_BOARD * ( ro - BOARD_POS ), ROT_BOARD * rd, BOARD_SIZE );\n        isect.xyz *= ROT_BOARD;\n      }\n      ro += isect.w * rd;\n\n      // refract\n      // cringe\n      vec3 H = importanceSampleGGX( REFRACT_ROUGH, isect.xyz );\n      vec3 wo = refract( rd, H, ior );\n      if ( wo == vec3( 0.0 ) ) {\n        rd = reflect( rd, H );\n      } else {\n        rd = wo;\n        inMedium = 0.0;\n        ampRem *= 0.7;\n      }\n\n      ro += 0.001 * rd;\n\n      continue;\n    }\n\n    // disk\n    ro2 = ROT_DISC * ro;\n    rd2 = ROT_DISC * rd;\n    isect = isectPillar( ROT_DISC * ( ro - DISC_POS ), ROT_DISC * rd, DISC_RAD, DISC_THIC );\n    isect.xyz *= ROT_DISC;\n\n    float roughness = 0.1;\n    float metallic = 0.0;\n    float baseColor = smoothstep( 0.2, 0.0, abs( 0.6 - wave ) );\n    float emissive = 0.0;\n\n    inMedium = 1.0;\n\n    // gay bar\n    ro2 = ( ro - vec3( 0.0, 0.45, 0.0 ) ).yzx;\n    rd2 = rd.yzx;\n    isect2 = isectPillar( ro2, rd2, 0.05, 3.0 );\n    if ( isect2.w < isect.w ) {\n      isect2.xyz = isect2.zxy;\n      isect = isect2;\n      vec3 rp = ro + rd * isect.w;\n      roughness = 0.2;\n      metallic = 0.0;\n      baseColor = smoothstep( 0.1, 0.0, abs( 0.62 + 0.06 * rp.x - wave ) );\n      inMedium = 0.0;\n    }\n\n    // pillar\n    ro2 = ( ro - vec3( 0.7, -1.75, 0.0 ) ).zxy;\n    rd2 = rd.zxy;\n    isect2 = isectPillar( ro2, rd2, 0.5, 0.85 );\n    if ( isect2.w < isect.w ) {\n      // cringe\n      isect2.z += 3.0 * ( random3().x - 0.5 );\n      isect2.xyz = normalize( isect2.xyz );\n\n      isect2.xyz = isect2.yzx;\n      isect = isect2;\n      vec3 rp = ro + rd * isect.w;\n      roughness = 0.2;\n      metallic = 1.0;\n      baseColor = smoothstep( 0.2, 0.0, abs( 0.4 - wave ) ) + 0.8 * smoothstep( 0.1, 0.0, abs( 0.8 - wave ) );\n      inMedium = 0.0;\n    }\n\n    // tilt board\n    isect2 = isectBox( ROT_BOARD * ( ro - BOARD_POS ), ROT_BOARD * rd, BOARD_SIZE );\n    if ( isect2.w < isect.w ) {\n      vec3 rp = ro + rd * isect2.w;\n      isect2.xyz *= ROT_BOARD;\n      isect = isect2;\n      roughness = 0.2;\n      metallic = 0.0;\n      baseColor = smoothstep( 0.5, 0.0, abs( 0.5 - wave ) );\n      inMedium = 3.0;\n    }\n\n    // sphere right\n    const vec3 SPHERE_RIGHT_POS = vec3( 1.2, 1.0, 0.0 );\n    isect2 = isectSphere( ro - SPHERE_RIGHT_POS, rd, 0.5 );\n    if ( isect2.w < isect.w ) {\n      vec3 rp = ro + rd * isect2.w;\n      isect = isect2;\n      roughness = 0.2;\n      metallic = 0.0;\n      baseColor = smoothstep( 0.1, 0.0, abs( 0.76 - wave ) ) + 0.01 * smoothstep( 0.4, 0.0, abs( 0.6 - wave ) );\n      inMedium = 0.0;\n    }\n\n    // sphere left\n    isect2 = isectSphere( ro - SPHERE_POS, rd, SPHERE_RAD );\n    if ( isect2.w < isect.w ) {\n      vec3 rp = ro + rd * isect2.w;\n      isect = isect2;\n      roughness = 0.2;\n      metallic = 0.0;\n      baseColor = smoothstep( 0.24, 0.0, abs( 0.5 - wave ) );\n      inMedium = 2.0;\n    }\n\n    // grid\n    isect2 = isectPlane( ro + vec3( 0.0, 0.0, 1.0 ), rd, vec3( 0.0, 0.0, 1.0 ) );\n    if ( isect2.w < isect.w ) {\n      vec3 rp = ro + rd * isect2.w;\n      if ( max( cos( 14.0 * rp.x ), cos( 14.0 * rp.y ) ) > 0.99 ) {\n        isect = isect2;\n        roughness = 0.2;\n        metallic = 0.0;\n        baseColor = 0.8;\n        inMedium = 0.0;\n      }\n    }\n\n    // half circle\n    isect2 = isectPlane( ro + vec3( 0.0, 0.0, 0.7 ), rd, vec3( 0.0, 0.0, 1.0 ) );\n    if ( isect2.w < isect.w ) {\n      vec3 rp = ro + rd * isect2.w + vec3( 1.15, 1.9, 0.0 );\n      if ( length( rp.xy ) < 1.8 && rp.y > 0.0 ) {\n        isect = isect2;\n        roughness = 0.2;\n        metallic = 0.0;\n        baseColor = smoothstep( 0.3, 0.0, abs( 0.7 - wave ) );\n        inMedium = 0.0;\n      }\n    }\n\n    // background\n    isect2 = isectPlane( ro + vec3( 0.0, 0.0, 1.1 ), rd, vec3( 0.0, 0.0, 1.0 ) );\n    if ( isect2.w < isect.w ) {\n      vec3 rp = ro + rd * isect2.w;\n      isect = isect2;\n      roughness = 0.2;\n      metallic = 0.0;\n      baseColor = mix(\n        clamp( 0.3 + 0.6 * cyclicNoise( 29.0 + vec3( 10.0 * wave ) + 0.3 * rp.y ).x, 0.0, 1.0 ),\n        smoothstep( 0.5, 0.0, abs( 0.76 - wave ) ),\n        pow( abs( cyclicNoise( vec3( rp.xy, 1.0 ) ).x ), 2.0 )\n    \t);\n      inMedium = 0.0;\n    }\n\n    // light\n    isect2 = isectSphere( ro - vec3( 3.0, 6.0, 5.0 ), rd, 2.0 );\n    if ( isect2.w < isect.w ) {\n      isect = isect2;\n      roughness = 1.0;\n      metallic = 0.0;\n      baseColor = 0.0;\n      emissive = 50.0;\n      inMedium = 0.0;\n    }\n\n    if ( isect.w < FAR ) {\n      ro += isect.w * rd;\n\n      amp += emissive * ampRem;\n\n      float NdotV = safeDot( isect.xyz, -rd );\n      float Fn = mix( 0.04, 1.0, pow( 1.0 - NdotV, 5.0 ) );\n\n      if ( metallic == 1.0 || random3().x < Fn ) {\n        // specular\n        vec3 H = importanceSampleGGX( roughness, isect.xyz );\n        vec3 wo = reflect( rd, H );\n        if ( dot( wo, isect.xyz ) < 0.0 ) {\n          ampRem *= 0.0;\n          continue;\n        }\n\n        float VdotH = safeDot( -rd, H );\n        float NdotL = safeDot( isect.xyz, wo );\n        float NdotH = safeDot( isect.xyz, H );\n\n        // g_smith\n        roughness *= roughness / 2.0;\n\n        float G1V = NdotV / ( NdotV * ( 1.0 - roughness ) + roughness );\n        float G1L = NdotL / ( NdotL * ( 1.0 - roughness ) + roughness );\n\n        float G =\n          NdotV / ( NdotV * ( 1.0 - roughness ) + roughness ) * // G1V\n          NdotL / ( NdotL * ( 1.0 - roughness ) + roughness ); // G1L\n\n        if ( metallic == 1.0 ) {\n          float Fh = mix( baseColor, 1.0, pow( 1.0 - VdotH, 5.0 ) );\n          ampRem *= Fh * G * VdotH / ( NdotH * NdotV );\n        } else {\n          float Fh = mix( 0.04, 1.0, pow( 1.0 - VdotH, 5.0 ) );\n          ampRem *= Fh / Fn * G * VdotH / ( NdotH * NdotV );\n        }\n        rd = wo;\n      } else {\n        if ( inMedium > 0.0 ) {\n          // refract\n          // cringe\n          vec3 H = importanceSampleGGX( REFRACT_ROUGH, isect.xyz );\n          rd = refract( rd, H, 1.0 / ior );\n          ro += 0.001 * rd;\n          ampRem *= baseColor;\n          continue;\n        }\n\n        // diffuse\n        vec3 wo = importanceSampleLambert( isect.xyz );\n        vec3 H = normalize( -rd + wo );\n        if ( dot( wo, isect.xyz ) < 0.0 ) {\n          ampRem *= 0.0;\n          continue;\n        }\n\n        float VdotH = safeDot( -rd, H );\n        float Fh = mix( 0.04, 1.0, pow( 1.0 - VdotH, 5.0 ) );\n\n        ampRem *= ( 1.0 - Fh ) / ( 1.0 - Fn ) * baseColor;\n        rd = wo;\n      }\n\n      ro += 0.001 * rd;\n    } else {\n      ampRem *= 0.0;\n    }\n  }\n\n  fragColor = col / col.w;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Accumulate\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  // accumulate using backbuffer\n  fragColor = texture( iChannel0, uv );\n\n  if ( iFrame > 1 && iMouse.w < 0.5 ) {\n    fragColor += texture( iChannel1, uv );\n  }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}