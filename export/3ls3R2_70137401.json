{"ver":"0.1","info":{"id":"3ls3R2","date":"1556934158","viewed":464,"name":"Worley segment noise","username":"tpfto","description":"A variant of [url=\"https://doi.org/10.1145/237170.237267\"]Worley noise[/url] where feature (line) segments are generated instead of feature points in each cell, and the distances to them are evaluated.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","voronoi","noise","worley","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comparing normal Worley noise with \"segment Worley noise\"\n// A little bit of something old, something new, and something borrowed.\n\n// XY range of the display.\n#define DISP_SCALE 6.0\n\n// rescaling function\n\nfloat rescale(float x, vec2 range)\n{\n\t  float a = range.x, b = range.y;\n      return (x - a)/(b - a);\n}\n\n// modified MATLAB hot colormap\n\nvec3 hot( float t )\n{\n\t return clamp(vec3(3.0, 3.0, 4.0) * t - vec3(0.0, 1.0, 3.0), 0.0, 1.0);\n}\n\n// simple LCG\n\n#define LCG(k) k = (65 * k) % 1021\n#define lr(k) float(k)/1021.\n\n// permutation polynomial\n\nint permp (int i1, int i2)\n{\n      int t = (i1 + i2) & 255;\n        \n      return ((112 * t + 153) * t + 151) & 255;\n}\n\n// normal (Euclidean) Worley noise\n// return the two closest distances\n\nvec2 worley(vec2 p)\n{\n    vec2 dl = vec2(20.0);\n    ivec2 iv = ivec2(floor(p));\n    vec2 fv = fract(p);\n    \n\tfor (int j = -1; j <= 1; j++)\n\t\tfor (int i = -1; i <= 1; i++)\n\t\t{\n\t\t\tint s = permp(permp(0, iv.y + j), iv.x + i); LCG(s); // seeding\n            \n\t\t\tfor (int m = 0; m < 2; m++) // two points per cell\n            {\n                LCG(s); float sy = lr(s);\n                LCG(s); float sx = lr(s);\n                \n                vec2 tp = vec2(i, j) + vec2(sx, sy) - fv;\n                float c = dot(tp, tp);\n                \n                float m1 = min(c, dl.x), m2 = max(c, dl.x); // ranked distances\n                dl = vec2(min(m1, dl.y), max(m1, min(m2, dl.y)));\n            }\n\t\t}\n        \n      return sqrt(dl);\n}\n\n// Worley variant using point-segment distance.\n// instead of \"feature points\", \"feature segments\" are generated per cell\n// everything else is the same\n\nvec2 worleyseg(vec2 p)\n{\n    vec2 dl = vec2(20.0);\n    ivec2 iv = ivec2(floor(p));\n    vec2 fv = fract(p);\n    \n\tfor (int j = -1; j <= 1; j++)\n\t\tfor (int i = -1; i <= 1; i++)\n\t\t{\n\t\t\tint s = permp(permp(0, iv.y + j), iv.x + i); LCG(s); // seeding\n            \n\t\t\tfor (int m = 0; m < 2; m++) // two segments per cell\n            {\n                LCG(s); float sy2 = lr(s); // generate line segment joining (sx1, sy1), (sx2, sy2)\n                LCG(s); float sy1 = lr(s);\n                LCG(s); float sx1 = lr(s);\n                LCG(s); float sx2 = lr(s);\n                \n                vec2 sv = fv - vec2(i, j) - vec2(sx1, sy1);\n                vec2 sp = vec2(sx2 - sx1, sy2 - sy1);\n                vec2 tp = sp * clamp(dot(sp, sv)/dot(sp, sp), 0.0, 1.0) - sv; // point-segment distance\n                float c = dot(tp, tp);\n                \n                float m1 = min(c, dl.x), m2 = max(c, dl.x); // ranked distances\n                dl = vec2(min(m1, dl.y), max(m1, min(m2, dl.y)));\n            }\n\t\t}\n        \n      return sqrt(dl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n        uv *= DISP_SCALE;\n    \n        // transition between normal and segment noise\n\n        vec2 w = mix(worleyseg(uv + iTime), worley(uv + iTime), smoothstep(-0.5, 0.5, cos(0.2 * iTime)));\n\n        // split image adapted from Inigo Quilez; https://www.shadertoy.com/view/ll2GD3\n\n        float ry = fragCoord.y / iResolution.y;\n        vec3                  col = hot(rescale(w.x, vec2(0.0, 1.0)));\n        if ( ry > (1.0/3.0) ) col = hot(rescale(0.5 * (w.y + w.x)/length(w) - w.x, vec2(0.0, 1.0)));\n        if ( ry > (2.0/3.0) ) col = hot(rescale((2.0 * w.y * w.x)/(w.y + w.x) - w.x, vec2(0.0, 0.2)));\n\n        // borders\n        col *= smoothstep( 0.5, 0.48, abs(fract(3.0 * ry) - 0.5) );\n\n        fragColor = vec4( vec3(col), 1.0 );\n}","name":"Image","description":"","type":"image"}]}