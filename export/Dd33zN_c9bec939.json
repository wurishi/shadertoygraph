{"ver":"0.1","info":{"id":"Dd33zN","date":"1677024580","viewed":82,"name":"Fork The Rabbit reverland 554","username":"reverland","description":"bad to eyes.","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["2d","droste","escher","kifs","fold"],"hasliked":0,"parentid":"Md3yRf","parentname":"The Rabbit Hole"},"renderpass":[{"inputs":[{"id":"ll2SWc","filepath":"https://soundcloud.com/yuyang-liu-250513074/rabbit-impact?si=a3f2991b858447679512ce5e991f4d3a&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/yuyang-liu-250513074/rabbit-impact?si=a3f2991b858447679512ce5e991f4d3a&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Rigel rui@gil.com\n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/Md3yRf\n\n\n/*\nThis was inpired by Escher painting \"Print Gallery\" and this lecture\nhttps://youtu.be/clQA6WhwCeA?t=7m50s\n\nI wanted to do something with the Escher/Droste effect, and I discovered \nthis blog post http://roy.red/droste-.html#droste \nby user Roy Wiggins https://www.shadertoy.com/user/roywig\n\nAnd his other post about KIFS (Kaleidoscopic Iterated Function Systems)\nhttp://roy.red/folding-the-koch-snowflake-.html#folding-the-koch-snowflake\n\nAn this sended me along a rabbit hole of folding space, and constructing \nKIFS with escher like spiral zooms :) \n\nThere are plenty of Escher/Droste effect on shadertoy, but this one by reinder\nis like total magic. https://www.shadertoy.com/view/Mdf3zM\n*/\n\n#define PI 3.141592653\n\n// utility functions\n// conversion from cartesian to polar\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n// conversion from polar to cartesian\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n// complex division in polar form z = vec2(radius,angle)\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x/z2.x,z1.y-z2.y); }\n// complex log in polar form z = vec2(radius,angle)\nvec2 zlog(vec2 z) { return toPolar(vec2(log(z.x),z.y)); }\n// complex exp in polar form z = vec2(radius,angle)\nvec2 zexp(vec2 z) { z = toCarte(z); return vec2(exp(z.x),z.y); }\n// smoothstep antialias with fwidth\nfloat ssaa(float v) { return smoothstep(-1.,1.,v/fwidth(v)); }\n// stroke an sdf 'd', with a width 'w', and a fill 'f' \nfloat stroke(float d, float w, bool f) {  return abs(ssaa(abs(d)-w*.5) - float(f)); }\n// fills an sdf 'd', and a fill 'f'. false for the fill means inverse \nfloat fill(float d, bool f) { return abs(ssaa(d) - float(f)); }\n// a signed distance function for a rectangle 's' is size\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// a signed distance function for a circle, 'r' is radius\nfloat sdfCircle(vec2 uv, float r) { return length(uv)-r; }\n// a signed distance function for a hexagon\nfloat sdfHex(vec2 uv) { vec2 auv = abs(uv); return max(auv.x * .866 + auv.y * .5, auv.y)-.5; }\n// a signed distance function for a equilateral triangle\nfloat sdfTri(vec2 uv) { return max(abs(uv.x) * .866 + uv.y * .5, -uv.y)-.577; }\n// a 'fold' is a kind of generic abs(). \n// it reflects half of the plane in the other half\n// the variable 'a' represents the angle of an axis going through the origin\n// so in normalized coordinates uv [-1,1] \n// fold(uv,radians(0.)) == abs(uv.y) and fold(uv,radians(90.)) == abs(uv.x) \nvec2 fold(vec2 uv, float a) { a -= 1.57; vec2 axis = vec2(cos(a),sin(a)); return uv-(2.*min(dot(uv,axis),.0)*axis); }\n// 2d rotation matrix\nmat2 uvRotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// the scene\nvec3 TheRabbitHole(vec2 uv) {\n\n    // a flag for the scene\n    float sc = -1.;\n    float offsetx = 1.;\n    float offsety = 1.;\n    float fx = 1.;\n    float fy = 1.;\n\t// save current uv for the rabbit\n    vec2 uvr = uv;\n\n    // if mouse clicked apply the Escher/Droste transform\n    if (iMouse.z >.0) {\n        sc = -sc;\n    }\n    if (sin(iTime*PI/30.*sin(5.*iTime*PI)) > 0. && cos(iTime*PI/33.33) < 0.2) {\n        sc = -sc;\n        if (sin(5.*iTime*PI) > 0.5) {\n        offsetx = 100.;\n        offsety = 100.;\n        fx = 2.;\n        fy = 2.;\n        }\n        \n    }\n  \n    // uv for the rabbit\n    uvr = uvr*.2+vec2(cos(iTime*5.*offsetx+0.33)*0.005*fx,sin(iTime*3.*offsety) * 0.005*fy + 0.15);\n    \n    \n    // uv for the rabbit ears\n    vec2 uvears = vec2(abs(uvr.x),uvr.y)*uvRotate(radians(-20.)); \n    float ears = stroke(sdfCircle(vec2(-abs(uvears.x),uvears.y)-vec2(.26,.34),.3),.04,true); \n    \n    // uv for the rabbit eyes\n    vec2 uveyes = vec2(abs(uvr.x),uvr.y)*uvRotate(radians(-40.)); \n    float eyes = fill(sdfCircle(vec2(-abs(uveyes.x),uveyes.y)-vec2(.05,.1),.07),false); \n\n    // nose ant teeth\n    float nose = fill(sdfCircle(vec2(abs(uvr.x),uvr.y)-vec2(.008,.0),.02),false);\n    float teeth = fill(sdfRect(vec2(abs(uvr.x),uvr.y)-vec2(.007,-.045),vec2(.005,.015)),false);\n\n    // the face is just a bunch of circles\n    float face = max(max(\n        fill(sdfCircle(uvr-vec2(.0,.0),.07),true),\n        fill(sdfCircle(vec2(abs(uvr.x),uvr.y)-vec2(.078,.05),.07),true)),\n        fill(sdfCircle(uvr-vec2(.0,.1),.12),true));\n    \n    // compose the rabbit\n    float rabbit = min(min(min(eyes,nose),teeth),max(ears,face));\n\n    vec3 c = vec3(1.) * (sc == -1. ? 1.: 0.);\n    \n    if (iTime < 10.) {\n        c = -c;\n    } else if (iTime < 20. && iTime > 10.) {\n        c = vec3(1.) * (sc == -1. ? tan((iTime-10.)/10.) : 1. - tan((iTime-10.)/10.));\n    }\n\n    c = mix(c,vec3(sc),rabbit);\n    c = mix(vec3(1.0, uv.xy - vec2(-cos(iTime), -sin(iTime))), c, eyes);\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n\n\tfragColor = vec4( TheRabbitHole(uv*6.), 1.0 );\n}","name":"Image","description":"","type":"image"}]}