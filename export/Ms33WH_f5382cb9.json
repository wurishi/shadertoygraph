{"ver":"0.1","info":{"id":"Ms33WH","date":"1449271393","viewed":239,"name":"SierpinskiTriangle","username":"jt","description":"Good old Sierpinski Triangle - tiny version.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","triangle","sierpinski","short"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Sierpinski Triangle (https://en.wikipedia.org/wiki/Sierpinski_triangle) - Shader 2015 by JT\n// shortest codegolfed 127char version by FabriceNeyret2\nvoid mainImage( out vec4 o, vec2 I )\n{\n    I /= iResolution.xy;\n    o -= o; \n    I.x-=.5*I.y; \n    for(int i = 0; i < 9; i++)\n        I = 2.*fract(I),\n        I.x>=1.&&I.y>=1. ? o++ : o;\n}\n\n// NOTE: using fuzzy-operators derived from probability-theory:\n//       0 == FALSE\n//       1 == TRUE\n//       1-a == NOT a\n//       a*b == a AND b\n//       1-(1-a)*(1-b) == a+b-ab == NOT ((NOT a) AND (NOT b)) == a OR b via deMorgan rule\n/*\nvoid mainImage( out vec4 o, in vec2 I ) // my original version (159char): upside-down & inverted\n{\n    I /= iResolution.xy;\n    o = vec4(1); // o := TRUE\n    I.x += .5-.5*I.y; // (un)shear coordinates\n    for(int i = 0; i < 9; i++)\n    {\n        I = 2.*fract(I);\n        vec2 w = step(1.,I);\n        o *= 1.-(1.-w.x)*(1.-w.y); // o := o AND (x OR y) apply deMorgan o := o AND (NOT(NOT x)AND(NOT y))\n    }\n}\n*/\n/*\nvoid mainImage( out vec4 o, in vec2 I ) // my attempt to code-golf it (138chars)\n{\n    I /= iResolution.xy;\n    o -= o; // initialization: o := FALSE (at least if o not NaN)\n    I.x-=.5*I.y; // (un)shear coordinates\n    for(int i = 0; i < 9; i++)\n    {\n        I = 2.*fract(I);\n        vec2 w = step(1.,I);\n        //o = 1. - (1.-o)*(1.-w.x*w.y); // o := o OR (x AND y) apply deMorgan o := NOT ((NOT o) AND (NOT(x AND y)))\n        o += w.x*w.y; // approximation of the above, relying on o beeing constrained to interval [0..1]\n    }\n}\n*/\n","name":"","description":"","type":"image"}]}