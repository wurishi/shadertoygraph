{"ver":"0.1","info":{"id":"ldGyz1","date":"1520990345","viewed":120,"name":"noise simplex - gradient","username":"ilaschino","description":"noise // senpai IQ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 red = vec3(1,0,0);\nvec3 green = vec3(0,1,0);\nvec3 blue = vec3(0,0,1);\n\nmat2 rotate(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle),cos(angle));\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2(value.x,0,0,value.y);\n}\n\nfloat rand(vec2 uv){\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n//====== GRADIENT ==============\nvec2 ghash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( ghash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( ghash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( ghash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( ghash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//=================================\n\n// ======  SIMPLEX ==================\nvec2 shash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,shash(i+0.0)), dot(b,shash(i+o)), dot(c,shash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nfloat circle(vec2 uv,float radius, vec2 shapePos)\n{\n     \n    float dist = distance(shapePos,uv);\n    float value = step(radius,dist);\n    \n    return value; \n}\n\n//=======================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;  \n    float ratio = iResolution.x / iResolution.y;\n    \n    //uv.x *= ratio;\n    \n    \n    float value;\n    float zoom = 9.;\n    vec3 color;\n   \tfloat scale = .02;\n    \n    //uv *= rotate(iTime);\n    \n    float offset = snoise(uv * 9. + iTime );\n    value = step(.4 + offset,uv.x) - step(.8 + offset,uv.x);\n\tcolor = mix(blue,red * iTime, value);\n\n    \n    \n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}