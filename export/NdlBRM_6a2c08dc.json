{"ver":"0.1","info":{"id":"NdlBRM","date":"1644611386","viewed":143,"name":"Vector field animations","username":"cybershiptrooper","description":"Vector field animations tool for this question: https://math.stackexchange.com/questions/4376755/what-is-the-noise-equation-used-in-this-vector-field-animation\n\nTo modify the patterns, go to ~line 100","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["visualization","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 filled(float distance, float linewidth, float antialias, vec4 fill)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = fill;\n    // Within shape\n    else if( signed_distance < 0.0 )\n        frag_color = fill;\n    //else\n        // Outside shape\n        //if( border_distance > (linewidth/2.0 + antialias) )\n        //   frag_color = vec4(0.0);\n        //else // Line stroke exterior border\n        //frag_color = vec4(fill.rgb*alpha, 1.0);\n\n    return frag_color;\n}\n\n// Computes the signed distance from a line\nfloat line_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    return dot(rel_p, vec2(dir.y, -dir.x));\n}\n\n// Computes the signed distance from a line segment\nfloat segment_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    float dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n    float dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n    return max(dist1, dist2);\n}\n\n\nfloat arrow_triangle(vec2 texcoord,\n                     float body, float head, float height,\n                     float linewidth, float antialias,\n                     float denom)\n{\n    float w = linewidth/2.0 + antialias;\n    float r = denom;\n    vec2 start = vec2(0.0, 0.0);//-vec2(body/r, 0.0);\n    vec2 end   = +vec2(body*r, 0.0);\n    head = head*r;\n    // Head : 3 lines\n    float d1 = line_distance(texcoord, end, end - head*vec2(+1.0,-height));\n    float d2 = line_distance(texcoord, end - head*vec2(+1.0,+height), end);\n    float d3 = texcoord.x - end.x + head;\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    float d = min(max(max(d1, d2), -d3), d4);\n    return d;\n}\n\nfloat arrow_triangle_60(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias, \n                        float denom)\n{\n    return arrow_triangle(texcoord, body, head, 0.5, linewidth, antialias, denom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float M_PI = 3.14159265358979323846;\n    const float SQRT_2 = 1.4142135623730951;\n    const float linewidth = 2.5;\n    const float antialias =  .4;\n    //////////////////////////////////\n    ////change no. of arrows here/////\n    //////////////////////////////////\n    const float rows = 16.0;\n    const float cols = 20.0;\n    //////////////////////////////////\n    float body = min(iResolution.x/cols, iResolution.y/rows) / SQRT_2;\n    vec2 texcoord = fragCoord.xy;\n    vec2 size   = iResolution.xy / vec2(cols,rows);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n    texcoord -= center;\n    float theta = (iTime);//+ M_PI*(center.x / cols + center.y / rows)/4.0;\n    \n    vec2 xs =  center/size;\n    xs = 2.0*xs / vec2(cols,rows);\n    xs = xs - 1.0;\n    \n                    \n    //////////////////////////////////\n    ////create patterns here//////////\n    //////////////////////////////////\n    //theta as a function of time and space\n    float alpha = xs.x>0.0?1.0:-1.0;\n    //if(xs.x+xs.y > 1.0) alpha = -1.0;\n    //else if(xs.x-xs.y > 1.0) alpha = -1.0;\n    //else if(-xs.x-xs.y > 1.0) alpha = -1.0;\n    //else if(-xs.x+xs.y > 1.0) alpha = -1.0;\n    //alpha = 1.0 + abs(xs.x+xs.y)/4.0;\n    theta = alpha*theta;\n    \n    //radius as a function of time and space\n    //pattern 2: ellipse\n    float b = max(0.05, abs(xs.x-xs.y)/6.0 + abs(xs.x-xs.y+1.0)/6.0);\n    float a = 0.9;\n    \n    \n    float phi_t = abs(xs.x+xs.y)+abs(xs.x-xs.y); \n        //+ ( (xs.y-.5)*(xs.y-.5) + (xs.x-.5)*(xs.x-.5));\n        //+( (xs.y+.5)*(xs.y+.5) + (xs.x+.5)*(xs.x+.5))\n        //+( (xs.x-1.0)*(xs.x-1.0) + (xs.y)*(xs.y));\n    phi_t = sin(4.0*xs.x) + cos(xs.y/.25) + sin(xs.x+xs.y) + sin((xs.y-.5)*(xs.y-.5) + (xs.x-.5)*(xs.x-.5));\n    float phi_r = M_PI/4.0;\n    theta = theta + phi_t;\n    //////////////////////////////////\n    \n    ///////////////pattern 1/////////////                \n    //float scale = 0.3;\n    //float denom = max(scale*abs(\n    //sin(iTime/2.0 \n    //     + pattern\n    //) ), 1.5); \n    //denom = 1/denom;\n    ////////////////////////////////////\n    \n    ///////pattern 2///////////\n    float esq = 1.0-b*b/(a*a);\n    float denom = b/sqrt(1.0-esq*pow(cos(theta+phi_r), 2.0));\n    ///////////////////////////\n    \n    \n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    texcoord = vec2(cos_theta*texcoord.x - sin_theta*texcoord.y,\n                    sin_theta*texcoord.x + cos_theta*texcoord.y);\n    \n    float d;\n    d = arrow_triangle_60(texcoord, body, 0.4*body, linewidth, antialias, denom);\n    \n    //grid\n    vec2 grb = (fragCoord.xy+vec2(size/2.0))/size-floor((fragCoord.xy+vec2(size/2.0))/size);\n    vec2 gri = (fragCoord.xy)/size-floor((fragCoord.xy)/size);\n    if( grb.x < 0.02 || grb.y<0.02 ) fragColor = vec4(0.0, 0.4, 0.5, 0.3);\n    else if( gri.x < 0.02 || gri.y<0.02 ) fragColor = vec4(0.0, 0.4, 0.5, 0.3);\n    fragColor = fragColor+ filled(d, linewidth, antialias, vec4(1,1,1,1));\n        \n}\n","name":"Image","description":"","type":"image"}]}