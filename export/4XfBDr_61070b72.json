{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n// Kirby SDF and texture - Thanks Fizzer - https://www.shadertoy.com/view/lt2fD3\n// Visible GGX Normals - Thanks Jonathan Dupuy (Intel) - https://arxiv.org/pdf/2306.05044\n// ACES fitted tonemap - Thanks TheRealMJP - https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n// SDF curvature - Thanks Nimitz - https://www.shadertoy.com/view/Xts3WM\n\nconst float exposure = 2.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = linear_srgb(ACESFitted(\n        exposure * fragColor.rgb / fragColor.a\n    ));\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define USE_DFD_SMOOTH\n\n// math constants\nconst highp float\n    SQRT2 = 1.4142136, SC45 = 0.7071068, D2R = 0.0174533,\n    eps = 0.001, ieps = 0.999, epsCol = 0.0039062,\n    QTRPI = 0.7853981, HPI = 1.5707963, PI = 3.1415926, TWOPI = 6.2831853,\n    iQTRPI = 1.2732396, iHPI = 0.6366197, iPI = 0.3183098, iTWOPI = 0.1591549;\n\nconst highp float PHI1 = 1.0 - 1.0 / float(1.61803398);\nconst highp vec2  PHI2 = 1.0 - 1.0 / pow(vec2(1.32471795), vec2(1.0, 2.0));\nconst highp vec3  PHI3 = 1.0 - 1.0 / pow(vec3(1.22074408), vec3(1.0, 2.0, 3.0));\n\n// camera properties\nconst float\tznear = 0.03125, zfar = 64.0, FOV = 60.0;\nconst int MAX_RAY_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 32;\nconst int TEMPORALSMOOTHING = 8;\n\n// thanks iradicator\nfloat dfSmooth1(in vec2 fc, in float v) { \n    vec2 q = vec2(uvec2(fc.xy) & uvec2(1));\n    q = q * 2.0 - 1.0;    \n    v -= 0.5 * dFdx(v) * q.x;\n    v -= 0.5 * dFdy(v) * q.y;\n    return v;\n}\nvec3 dfSmooth3(in vec2 fc, in vec3 v) { \n    vec2 q = vec2(uvec2(fc.xy) & uvec2(1));\n    q = q * 2.0 - 1.0;    \n    v -= 0.5 * dFdx(v) * q.x;\n    v -= 0.5 * dFdy(v) * q.y;\n    return v;\n}\n\n// generate a z order curve for each pixel/frame\nint genSeed(in int f, in ivec2 c) {\n    return (c.x + c.y*2 + f) + (c.x*1155 ^ c.y*2244);\n}\n\n// r2 low discrepancy sequence\nfloat r21(in int v) {\n    return fract(PHI1 * float(v));\n}\nvec2 r22(in int v) {\n    return fract(PHI2 * float(v));\n}\nvec3 r23(in int v) {\n    return fract(PHI3 * float(v));\n}\n\n// orthonormal basis assuming up is +y\nmat3 basisUp(in vec3 forward) {\n    vec3 down = vec3(0.0, -1.0, 0.0);\n    vec3 right = normalize(cross(forward, down));\n    return mat3(right, normalize(cross(forward, right)), forward);\n}\n\nvec2 rotate2d(in vec2 v, in float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n// Sampling the visible hemisphere as half vectors\nvec3 SampleVndf_Hemisphere(vec2 u, vec3 wi) {\n    // sample a spherical cap in (-wi.z, 1]\n    float phi = 2.0 * PI * u.x;\n    float z = (1.0 - u.y) * (1.0 + wi.z) - wi.z;\n    float sinTheta = sqrt(clamp(1.0 - z * z, 0.0, 1.0));\n    float x = sinTheta * cos(phi);\n    float y = sinTheta * sin(phi);\n    vec3 c = vec3(x, y, z);\n    // compute halfway direction\n    vec3 h = c + wi;\n    // return without normalization (as this is done later)\n    return h;\n}\n\n// Sampling Visible GGX Normals with Spherical Caps - https://arxiv.org/pdf/2306.05044\nvec3 SampleVndf_GGX(vec2 u, vec3 wi, vec2 alpha) {\n    // warp to the hemisphere configuration\n    vec3 wiStd = normalize(vec3(wi.xy * alpha, wi.z));\n    // sample the hemisphere (see implementation 2 or 3)\n    vec3 wmStd = SampleVndf_Hemisphere(u, wiStd);\n    // warp back to the ellipsoid configuration\n    vec3 wm = normalize(vec3(wmStd.xy * alpha, wmStd.z));\n    // return final normal\n    return wm;\n}\n\n// fast orthogonal matrix inverse\nmat4 orthoInverse(in mat4 m) {\n    mat3 r = transpose(mat3(m));\n    return mat4(\n        vec4(r[0], 0.0),\n        vec4(r[1], 0.0),\n        vec4(r[2], 0.0),\n        vec4(r * -m[3].xyz, 1.0)\n    );\n}\n\n// construct 4x4 view mat from camera origin, forward direction\nmat4 viewMat(in vec3 origin, in vec3 direction) {\n    mat3 bas = basisUp(direction);\n    return mat4(\n        vec4(bas[0], 0.0),\n        vec4(bas[1], 0.0),\n        vec4(bas[2], 0.0),\n        vec4(origin, 1.0)\n    );\n}\n\n// construct 4x4 projection mat using offaxis parameters, aspect ratio, FOV\nmat4 projectionMat(in vec2 offaxis, in float aspect, in float fov) {\n    // proj parameters\n    float f = zfar;\n    float n = znear;\n    float fovrad = fov * D2R;\n    float r =  n * aspect * tan(0.5 * (fovrad - offaxis.x));\n    float l = -n * aspect * tan(0.5 * (fovrad + offaxis.x));\n    float t =  n          * tan(0.5 * (fovrad - offaxis.y));\n    float b = -n          * tan(0.5 * (fovrad + offaxis.y));\n    // construct proj mat\n    return mat4(\n        2.0*n/(r-l),         0.0, (r+l)/(r-l),           0.0,\n                0.0, 2.0*n/(t-b), (t+b)/(t-b),           0.0,\n                0.0,         0.0, (f+n)/(f-n), 2.0*f*n/(f-n),\n                0.0,         0.0,         1.0,           0.0\n    );\n}\n\n// project the pixel at ndc into a worldspace ray\nvoid getCameraRay(in mat4 view, in mat4 proj, in vec2 ndc, out vec3 ro, out vec3 rd) {\n    ro = view[3].xyz;\n    vec4 ndch = transpose(inverse(proj)) * vec4(ndc, 1.0, 1.0);\n    rd = normalize(mat3(view) * vec3(ndch.xy, 1.0));\n}\n\n// project a worldspace location hl into camera NDC using its view projection\nvec3 reprojCoordsNDC(in mat4 view, in mat4 proj, in vec3 hl) {\n    vec4 camspace = orthoInverse(view) * vec4(hl, 1.0);\n    vec4 ndch = camspace * proj;\n    return vec3(ndch.xy / ndch.w, length(camspace));\n}\n\n// 3D reproject given image, distance, pixel location (see reprojCoordsNDC)\nvec4 reprojectBuffer(in sampler2D iChannel, in ivec2 iChanRes, in vec2 fc) {\n    ivec2 ifc = ivec2(fc);\n    // bound check\n    if (any( lessThan( ifc, ivec2(0) )) || any( greaterThan( ifc, iChanRes - 1)))\n        return vec4(0.0);\n    // get the 4 neighboring pixel values\n    vec4 b   = texelFetch(iChannel, ifc,               0);\n    vec4 bx  = texelFetch(iChannel, ifc + ivec2(1, 0), 0);\n    vec4 by  = texelFetch(iChannel, ifc + ivec2(0, 1), 0);\n    vec4 bxy = texelFetch(iChannel, ifc + ivec2(1, 1), 0);\n    // fancy bilinear interpolation\n    vec2 a = fract(fc);\n    return max(vec4(eps), mix(mix(b, bx, a.x), mix(by, bxy, a.x), a.y));\n}\n\n// Thanks Paniq - (many sources)\nvec3 linear_srgb(in vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x, vec3(0.0031308)));\n}\n\nvec3 srgb_linear(in vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x, vec3(0.04045)));\n}\n\n// Thanks TheRealMJP - https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(in vec3 color) {\n    // ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color = color * mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color = a / b;\n    // Back to color space\n    color = color * mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\nvec2 sdMin(in vec2 a, in vec2 b) {\n    return (a.x < b.x)? a: b;\n}\n\n// Thanks iq and Dave Smith - (many sources)\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*0.25;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a,-b,k);\n}\n\nconst float mat_air = 0.0;\nconst float mat_ground = 1.0;\nconst float mat_kirby = 2.0;\nconst float mat_shoe = 3.0;\nconst float mat_star = 4.0;\nconst float mat_handle = 5.0;\nconst float mat_hammer = 6.0;\nconst float mat_white = 7.0;\nconst float mat_blue = 8.0;\n\n// kirby parameters\nvec3 kirbyLoc = vec3(0.0, 1.0, 0.0); // kirby world location\nvec2 kirbyRot = vec2(0.0); // kirby object rotation\nvec2 kirbyFac = vec2(0.0); // kirby face rot\nvec4 kirbyArm = vec4(0.0, 0.0, -0.5, 0.0); // left arm rot UD, FB, right arm rot UD, FB\nvec4 kirbyLeg = vec4(0.0, -0.2, 0.0, 0.2); // left leg rot UD, FB, right leg rot UD, FB\nfloat squishingAway = 0.0;\n\n// star parameters\nvec3 kirbyStarLoc = vec3(0.0, 0.4, 0.0);\nfloat kirbyStarRadius = 1.0;\nvec3 kirbyStarScale = vec3(0.477, 2.0, 0.477);\n\n// hammer parameters\nvec3 hammerLoc = vec3(1.3, 3.8, -0.2);\nvec3 hammerDir = vec3(0.0, 0.0, 1.0);\nvec3 handleLoc = vec3(1.3, 3.25, -0.2);\nvec3 handleDir = vec3(0.0, 1.0, 0.0);\n\n// Thanks Fizzer - https://www.shadertoy.com/view/lt2fD3\nvec2 shoesDist(vec3 p) {\n    vec3 op=p;\n    float d=zfar;\n    p.y-=1.5;\n    // right shoe\n    op=p;\n    p-=vec3(-.5, -1.1, -.1);\n    p.yz=rotate2d(p.yz, kirbyLeg.z);\n    p.xz=rotate2d(p.xz, kirbyLeg.w);\n    d=min(d,-smin(p.y,-(length(p*vec3(1.5,1.,.8))-.64),.2));\n    p=op;\n    // left shoe\n    op=p;\n    p-=vec3(.5, -1.1, -.1);\n    p.yz=rotate2d(p.yz, kirbyLeg.x);\n    p.xz=rotate2d(p.xz, kirbyLeg.y);\n    d=min(d,-smin(p.y,-(length(p*vec3(1.5,1.,.8))-.64),.2));\n    p=op;\n    return vec2(d, mat_shoe);\n}\n\nvec2 kirby(in vec3 l) {\n    vec3 p=l;\n    vec3 op=l;\n    float d=zfar;\n    p.y-=1.5;\n    // torso\n    d=min(d,length(p*vec3(1.,1.,1.))-1.);\n    // left arm\n    op=p;\n    p-=vec3(.75-kirbyArm.x*0.2,.2+kirbyArm.x*0.5,-.1+kirbyArm.y*0.2);\n    p.xy=rotate2d(p.xy, -kirbyArm.x);\n    p.xz=rotate2d(p.xz, -kirbyArm.y);\n    d=smin(d,(length(p*vec3(.9,1.5,1.5))-.54),.05);\n    p=op;\n    // right arm\n    op=p;\n    p-=vec3(-.75+kirbyArm.z*0.2,.2+kirbyArm.z*0.5,-.1+kirbyArm.w*0.2);\n    p.xy=rotate2d(p.xy, kirbyArm.z);\n    p.xz=rotate2d(p.xz, kirbyArm.w);\n    d=smin(d,(length(p*vec3(.9,1.5,1.5))-.54),.05);\n    op = op + vec3(0., .1 * max(0., squishingAway - 1.), 0.);\n    p=op;\n    // mouth\n    p.xy = rotate2d(p.xy, kirbyFac.x);\n    p.xz = rotate2d(p.xz, kirbyFac.y);\n    p.z *= 1.1;\n    float md=smax(p.z+.74,smax(smax(p.x-.2,p.y-.075,.2),dot(p,vec3(.7071,-.7071,.01))-.1,.08),.04);\n    p.x=-p.x;\n    md=smax(md,smax(p.z+.74,smax(smax(p.x-.2,p.y-.075,.2),dot(p,vec3(.7071,-.7071,.01))-.1,.08),.01),.13);\n    d = smax(d,-md,.012);\n    // tongue\n    p=op;\n    p.xy = rotate2d(p.xy, kirbyFac.x);\n    p.xz = rotate2d(p.xz, kirbyFac.y);\n    p.z *= 1.1;\n    d=smin(d,length((p-vec3(0,-.09,-.875))*vec3(.8,1.6,.8))-.082,.01);\n    return vec2(d, mat_kirby);\n}\n\nvec2 kirbyHammer(in vec3 l) {\n    // handle\n    float handleRad = 0.1;\n    vec3 _l = l - handleLoc;\n    float d1 = length(_l.xz) - handleRad;\n    float d2 = abs(dot(_l, handleDir)) - 1.333;\n    // hammer head\n    _l = l - hammerLoc;\n    float d3 = length(_l * vec3(1.0, 1.0, 0.4)) - 0.7;\n    float d4 = abs(dot(_l, hammerDir)) - 1.0;\n    _l = abs(l - hammerLoc) - hammerDir;\n    float d5 = length(_l) - 0.5;\n    float d6 = abs(dot(_l, hammerDir)) - 0.1;\n    return sdMin(\n        vec2(max(d1, d2), mat_handle),\n        vec2(max(max(d3, d4), -max(d5, d6)), mat_hammer)\n    );\n}\n\nvec2 kirbyStar(in vec3 l) {\n    // star\n    float rad = 1.0;\n    rad += 1.25 / (1.0 + TWOPI * pow(mod(atan(l.x, l.z), TWOPI*0.2) - TWOPI*0.1, 2.0));\n    // cyl\n    float f = length(l.xz) - rad;\n    // cap\n    f = smax(f, (distance(l * kirbyStarScale, vec3(0.,1.,0.)) - 1.), .5);\n    return vec2(f, mat_star);\n}\n\nvec2 kirbyHeadband(in vec3 l) {\n    vec3 ringCenter = vec3(0.0, 3.25, 0.0);\n    vec3 ringNormal = vec3(0.0, 1.0, 0.0);\n    vec3 l_ring = l - ringCenter;\n    float ndist = dot(l_ring, ringNormal);\n    l_ring -= ndist * ringNormal;\n    l_ring = normalize(l_ring) * 0.75;\n    float ang = atan(l_ring.x, l_ring.z) * 14.0;\n    vec3 offset1 = ringCenter + (ringNormal * sin(ang) * 0.025 + l_ring * cos(ang) * 0.025);\n    vec3 offset2 = ringCenter - (ringNormal * sin(ang) * 0.025 + l_ring * cos(ang) * 0.025);\n    return sdMin(\n        vec2(distance(l, l_ring + offset1) - 0.075, mat_white),\n        vec2(distance(l, l_ring + offset2) - 0.075, mat_blue)\n    );\n    \n}\n\nvec2 sdf(in vec3 c, in float t) {\n    vec2 d = vec2(zfar, mat_air);\n    // plain floor for now\n    d = sdMin(d, vec2(c.y, mat_ground));\n    // place Kirby\n    vec3 c_k = c - kirbyLoc;\n    float kd = length(c_k - vec3(0.0, 0.5, 0.0));\n    // kirby acceleration sphere\n    if (kd < 3.0) {\n        d = sdMin(d, kirby(c_k));\n        d = sdMin(d, shoesDist(c_k));\n        d = sdMin(d, kirbyHeadband(c));\n    } else {\n        d = sdMin(d, vec2(kd - 2.0, mat_kirby));\n    }\n    // kirby hammer acceleration sphere\n    vec3 c_h = c - hammerLoc;\n    float kh = length(c_h + vec3(0.0, 0.5, 0.0));\n    if (kh < 3.0) {\n        d = sdMin(d, kirbyHammer(c));\n    } else {\n        d = sdMin(d, vec2(kh - 2.0, mat_hammer));\n    }\n    // place his warp star\n    vec3 c_s = c - kirbyStarLoc;\n    float ks = length(c_s);\n    // star acceleration sphere\n    if (ks < 3.0) {\n        d = sdMin(d, kirbyStar(c_s));\n    } else {\n        d = sdMin(d, vec2(ks - 2.0, mat_star));\n    }\n    return d;\n}\n\n// Thanks Nimitz - https://www.shadertoy.com/view/Xts3WM\nvec4 norcurv(in vec3 p, in float t, in float ep) {\n    vec2 e = vec2(-1.0, 1.0)*ep;\n    float t1 = sdf(p + e.yxx, t).x, t2 = sdf(p + e.xxy, t).x;\n    float t3 = sdf(p + e.xyx, t).x, t4 = sdf(p + e.yyy, t).x;\n    return vec4(normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4), (t1+t2+t3+t4 - 4.0*sdf(p, t))/(ep*ep));\n}\n\nvoid raymarch(in vec3 rayPos, in float time, in vec3 rayDir, const int MAX_STEPS, out float t, out float mat, out vec3 hitloc) {\n    hitloc = rayPos;\n    mat = mat_air;\n    t = eps;\n    float m = mat_air;\n    float inside = sign(sdf(hitloc, time).x);\n    float relax = 1.0;\n    float lastT = t;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 sd = sdf(hitloc, time) * inside;\n        if (sd.x < eps) {\n            if (relax >= 1.0) {\n                relax = 0.5;\n                t = lastT;\n            } else {\n                mat = sd.y;\n                return;\n            }\n        }\n        lastT = t;\n        t += sd.x * relax;\n        m = sd.y;\n        hitloc = rayPos + rayDir * t;\n        if (t > zfar) {\n            return;\n        }\n    }\n    mat = m;\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Rendering\n\nvec3 kirbyColor = vec3(0.3, 0.125, 0.125) * 5.0;\nvec3 kirbyShoeColor = vec3(0.2, 0.04, 0.035) * 5.0;\nvec3 kirbyStarColor = vec3(0.4, 0.2, 0.1) * 5.0;\n\nvec3 skyCol(in vec3 rd) {\n    vec3 col1 = pow(vec3(1.83, 2.15, 2.45), vec3(1.1)) * 0.4;\n    vec3 col2 = pow(vec3(1.83, 2.15, 2.45), vec3(2.2)) * 0.2;\n    vec3 sky = mix(col1, col2, (max(eps, rd.y)));\n    return sky;\n}\n\nvec3 kirbyTextureMap(in vec3 rp) {\n    vec3 orp=rp;\n    vec3 ret = kirbyColor; // reflection color\n    if (rp.z < 0.0) {\n        // mouth\n        float g = smoothstep(.97,.99,length(rp-vec3(0,1.6,0)));\n        ret *= mix(vec3(2.,.6,.4), vec3(1), g);\n        // blushes\n        rp.xy = rotate2d(rp.xy, kirbyFac.x);\n        rp.xz = rotate2d(rp.xz, kirbyFac.y);\n        rp.y -= 1.5;\n        rp.x = abs(rp.x);\n        g = length((rp.xy-vec2(.4,.2))*vec2(1,1.65));\n        ret *= mix(vec3(1.,.5,.5),vec3(1),smoothstep(.1,.15,g));\n        // eye outline\n        rp.xy -= vec2(.16,.45);\n        rp.xy *= .9;\n        orp = rp;\n        rp.y = pow(abs(rp.y),1.4)*sign(rp.y);\n        g = length((rp.xy)*vec2(.9,.52));\n        ret *= smoothstep(.058,.067,g);\n        // eye reflections\n        rp = orp;\n        rp.y += .08;\n        rp.y -= pow(abs(rp.x),2.)*16.;\n        ret += vec3(.1,.4,1.)*(1.-smoothstep(.03,.036,length((rp.xy)*vec2(.7,.3))))*max(0.,-rp.y)*24.;\n        // eye highlights\n        rp = orp;\n        rp.y -= .12;\n        g = length((rp.xy)*vec2(1.,.48));\n        ret += 2.0-2.0*smoothstep(.03,.04,g);\n    }\n    return ret;\n}\n\nvec3 hammerTextureMap(in vec3 p) {\n    vec3 pl = p - hammerLoc;\n    float u = dot(pl, hammerDir);\n    pl -= hammerDir * u;\n    float v = acos(dot(normalize(pl), handleDir)) / TWOPI;\n    vec3 wood = step(fract(v*14.0-0.025), 0.95)*(textureLod(iChannel1, vec2(u+0.5, v*5.0), 0.0).rgb);\n    float rad2 = length(pl);\n    if (rad2 < 0.47) {\n        float rad3 = 0.175 + 0.2 / (1.0 + TWOPI * pow(mod(atan(pl.x, pl.y) - PI, TWOPI*0.2) - TWOPI*0.1, 2.0));\n        if (rad3 > rad2)\n            return kirbyStarColor;\n        return vec3(1.0,0.1,0.1);\n    }\n    if (abs(u) > 0.75)\n        return vec3(1.0);\n    return wood;\n}\n\nvoid textureMap(in float mat, in vec3 hitloc, in vec3 normal, out vec3 diffCol, out vec3 specCol, out vec3 emisCol, out float rough, out float alpha) {\n\n    if (mat == mat_ground) {\n        \n        diffCol = vec3(1.0);\n        specCol = vec3(0.0);\n        emisCol = vec3(0.0);\n        rough = 1.0;\n        alpha = 1.0;\n        \n    } else if (mat == mat_kirby) {\n    \n        diffCol = kirbyTextureMap(hitloc - kirbyLoc + vec3(0.0, 0.1, 0.0));\n        specCol = vec3(0.0);\n        emisCol = vec3(0.0);\n        rough = 1.0;\n        alpha = 1.0;\n    \n    } else if (mat == mat_shoe) {\n    \n        diffCol = kirbyShoeColor;\n        specCol = vec3(0.0);\n        emisCol = vec3(0.0);\n        rough = 0.5;\n        alpha = 1.0;\n    \n    } else if (mat == mat_star) {\n    \n        diffCol = vec3(1.0);\n        specCol = vec3(0.0);\n        emisCol = kirbyStarColor;\n        rough = 1.0;\n        alpha = 1.0;\n    \n    } else if (mat == mat_air) {\n    \n        diffCol = vec3(0.0);\n        specCol = vec3(0.0);\n        emisCol = skyCol(normalize(hitloc));\n        rough = 1.0;\n        alpha = 1.0;\n\n    } else if (mat == mat_handle) {\n        \n        diffCol = (textureLod(iChannel1, vec2(hitloc.y, hitloc.x+hitloc.z), 0.0).rgb);\n        specCol = vec3(1.0);\n        emisCol = vec3(0.0);\n        rough = 1.0;\n        alpha = 1.0;\n        \n    } else if (mat == mat_hammer) {\n        \n        diffCol = hammerTextureMap(hitloc);\n        specCol = vec3(1.0);\n        emisCol = vec3(0.0);\n        rough = 1.0;\n        alpha = 1.0;\n        \n    } else if (mat == mat_white) {\n        \n        diffCol = vec3(1.0);\n        specCol = vec3(1.0);\n        emisCol = vec3(0.0);\n        rough = 1.0;\n        alpha = 1.0;\n        \n    } else if (mat == mat_blue) {\n        \n        diffCol = vec3(0.1,0.25,0.4);\n        specCol = vec3(1.0);\n        emisCol = vec3(0.0);\n        rough = 1.0;\n        alpha = 1.0;\n        \n    }\n    \n}\n\nvec3 interaction(in vec2 fc, inout vec3 ro, inout vec3 rd, in float t, in float m, in vec3 h, in vec3 n, inout vec3 rc) {\n\n    // main material properties\n    vec3 diffCol = vec3(0.0);\n    vec3 specCol = vec3(0.0);\n    vec3 emisCol = vec3(0.0);\n    float rough = 0.0;\n    float alpha = 0.0;\n    textureMap(m, h, n, diffCol, specCol, emisCol, rough, alpha);\n\n#ifdef USE_DFD_SMOOTH\n    emisCol = mix(emisCol, dfSmooth3(fc, emisCol), 0.5);\n#endif\n\n    // conservation of energy\n    vec3 contrib = rc * emisCol;\n\n    // surface normal (+y) to spherical cap hemi (+z)\n    mat3 rot = basisUp(n);\n    // visible normal distribution\n    vec3 vndf = rot * SampleVndf_GGX(eps + r22(genSeed(iFrame, ivec2(fc))), rd, vec2(rough));\n\n    rd = normalize(reflect(rd, vndf));\n    ro = h + n * eps;\n    rc *= diffCol;\n\n    return contrib;\n    \n}\n\nvoid getCameraMatrices(in float time, out mat4 view, out mat4 proj) {\n    \n    // camera parameters\n    vec3 pos = vec3(-2.0 * cos(time), 4.0 + sin(time), -5.0);\n    vec3 fwd = -normalize(pos - vec3(0.0, 2.25, 0.0));\n    \n    // camera matrices\n    view = viewMat(pos, fwd);\n    proj = projectionMat(vec2(0.0), iResolution.x / iResolution.y, FOV);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float time = float(iFrame) * 0.005;\n    \n    // display\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    \n    // camera matrices\n    mat4 view = mat4(1.0);\n    mat4 proj = mat4(1.0);\n    getCameraMatrices(time, view, proj);\n    \n    // get ray to trace\n    vec3 ro, rd;\n    getCameraRay(view, proj, ndc, ro, rd);\n    \n    // remember first hit for reprojection depth\n    float firstMat = 0.0;\n    vec3 firstHit = vec3(0.0);\n    vec3 firstNorm = vec3(0.0);\n    float ttlt = 0.0;\n    \n    // output, conservation of energy\n    vec3 col = vec3(0.0);\n    vec3 rc = vec3(1.0);\n    for (int i = 0; i < 3; i++) {\n        \n        // raymarch scene\n        float dist = zfar;\n        float mat = mat_air;\n        vec3 hit = vec3(0.0);\n        raymarch(ro, time, rd, MAX_RAY_STEPS, dist, mat, hit);\n\n        // normal xyz, isotropic curvature w\n        vec4 nc = norcurv(hit, time, eps);\n        \n        // record first hit?\n        if (firstMat < eps) {\n            firstMat = mat;\n            firstHit = hit;\n            firstNorm = nc.xyz;\n        }\n        \n        // surface interaction with ray\n        ttlt += dist;\n        col += interaction(fragCoord - float(i), ro, rd, ttlt, mat, hit, nc.xyz, rc);\n        \n        // not enough energy to continue? gtfo\n        if (dot(rc, rc) < eps) {\n            break;\n        }\n        \n    }\n    \n#ifdef USE_DFD_SMOOTH\n    if (dot(dfSmooth3(fragCoord, firstNorm), firstNorm) > 0.9)\n        col = mix(col, dfSmooth3(fragCoord, col), 0.5);\n#endif\n    \n    // vignette\n    col *= min(1.0, 1.414 - 0.5 * dot(ndc, ndc));\n    col = max(vec3(eps), col);\n    \n    float lsttime = float(iFrame - 1) * 0.005;\n    \n    // last camera matrices\n    mat4 lstview = mat4(1.0);\n    mat4 lstproj = mat4(1.0);\n    getCameraMatrices(lsttime, lstview, lstproj);\n    \n    // last frame reprojection\n    vec3 lastNDC = reprojCoordsNDC(lstview, lstproj, firstHit);\n    vec2 lastPx = (lastNDC.xy * 0.5 + 0.5) * iChannelResolution[0].xy - 0.5;\n    vec4 lastFrame = reprojectBuffer(iChannel0, ivec2(iChannelResolution[0].xy), lastPx);\n    \n    // temporal smoothing\n    if (lastFrame.a > float(TEMPORALSMOOTHING))\n        lastFrame *= float(TEMPORALSMOOTHING) / lastFrame.a;\n    \n    // encode sample number in w componenet\n    fragColor = lastFrame + vec4(col, 1.0);\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"4XfBDr","date":"1735171337","viewed":168,"name":"Hammer Kirby","username":"KylBlz","description":"Firmly grasp it. Rendered Fizzer's Kirby with only the Intel VNDF","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["hammer","ggx","kirby","vndf"],"hasliked":0,"parentid":"","parentname":""}}