{"ver":"0.1","info":{"id":"MscGW4","date":"1449600274","viewed":869,"name":"Matrix89","username":"trashrabbit","description":".","likes":14,"published":1,"flags":2,"usePreview":0,"tags":["matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// inputs:\n//  iChannel0: webcam image\n//  iChannel1: matrix characters image.\n//             should be a small b&w image with a single row of pixelated matrix-font characters.\n//             for example, a 64 x 16 image with a row of 8 x 16 pixel characters.\n\n\n#define N_CHARS 2.0    // how many characters are in the character image\n#define Y_PIXELS 24.0  // reduce input image to this many mega-pixels from top to bottom\n#define DROP_SPEED 0.5 // how fast the drips fall\n#define ASPECT 2.7     // aspect ratio of input webcam image relative to matrix characters\n#define MIN_DROP_SPEED 0.2    // range 0-1. is added to column speeds to avoid stopped columns.\n#define STATIC_STRENGTH 0.1   // range 0-1. how intense is the tv static\n#define SCANLINE_STRENGTH 0.4 // range 0-1. how dark are the tv scanlines\n#define NUM_SCANLINES 70.0    // how many scanlines in entire image\n#define GRADIENT_BLACK 0.2    // range 0-1. how dark do the darkest parts of the drip-gradients\n#define MATRIX_OPACITY 0.8    // range 0-1. matrix effect has this much solidity over original image\n\n// random functions adapted from https://www.shadertoy.com/view/lsXSDn                  \nfloat rand2d(vec2 v){\n    return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float x) {\n    return fract(sin(x) * 3928.2413);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // pixelate webcam image into mega-pixels\n    float xPix = floor(uv.x * Y_PIXELS * ASPECT) / Y_PIXELS / ASPECT;\n    float yPix = floor(uv.y * Y_PIXELS) / Y_PIXELS;\n    vec2 uvPix = vec2(xPix, yPix);\n    // ideally we should blur the input image to reduce flickering\n    vec4 pixelColor = texture(iChannel0, uvPix);\n\n    // compute uv within each mega-pixel\n    vec2 uvInPix = vec2(\n    \tmod(uv.x * Y_PIXELS * ASPECT, 1.0),\n    \tmod(uv.y * Y_PIXELS, 1.0)\n    );\n\n    // offset char image to appropriate char\n    float charOffset = floor(pixelColor.r * N_CHARS * 0.999) / N_CHARS;\n    uvInPix.x = uvInPix.x / N_CHARS + charOffset;\n    vec4 charColor = texture(iChannel1, uvInPix);\n    \n    // falling drip highlight\n    float highlightClock = -2.0 + yPix + iTime*DROP_SPEED + rand(xPix);\n    float highlight = mod(1.0 - max(0.0, highlightClock), 1.0);\n    highlight = mix(highlight, 1.0, GRADIENT_BLACK);\n    charColor *= highlight * 1.5;\n    \n\t// mixer controls where the original image is visible\n    // before the drips cover it\n    float mixer = clamp(highlightClock * 100.0, 0.0, 1.0);\n    \n    // multiply char images and webcam mega-pixels\n    float result = charColor.r * pixelColor.r;\n\n    // add scanlines\n    result *= 1.0 - SCANLINE_STRENGTH * (sin(uv.y * NUM_SCANLINES*3.14159*2.0)/2.0+0.5);\n    \n\t// map to a black->green->white gradient\n    vec4 greenResult = vec4(\n        max(0.0, result*3.0 - 1.2),\n        result*1.6,\n        max(0.0, result*3.0 - 1.5),\n        1.0\n    );\n        \n    // add tv static\n    float stat = rand2d(uv * vec2(0.0005, 1.0) + iTime * 0.1) * STATIC_STRENGTH;\n    greenResult += stat;\n    greenResult = mix(pixelColor, greenResult, MATRIX_OPACITY);\n    \n    // mix original image behind drips\n    vec4 origImage = texture(iChannel0, uv);\n    fragColor = mix(origImage, greenResult, mixer);\n}","name":"","description":"","type":"image"}]}