{"ver":"0.1","info":{"id":"MlXyzf","date":"1505998319","viewed":479,"name":"Smooth Life Variation","username":"decrooks","description":"A version of smooth life, based on \"Generalization of Conway’s 'Game of Life, to a continuous domain - SmoothLife\" by Stephan Rafler\nhttps://arxiv.org/pdf/1111.1567.pdf\n","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["automata","life","conway","continuous","smoothlife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 yellow = vec3(1.0,1.0,0.75);\nconst vec3 blue\t= vec3(0.8,0.8,1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 uv_0p = ( fragCoord.xy +vec2(0.0,1.0)) / iResolution.xy;\n    vec2 uv_0m = ( fragCoord.xy +vec2(0.0,-1.0)) / iResolution.xy;\n\n    vec4 c = texture(iChannel0,uv);\n    \n    if(c.b>0.5){\n        //show transition function\n        fragColor = vec4(vec3(c.r),1.0);\n        return;\n    }\n    \n    vec4 c_0p = texture(iChannel0,uv_0p);\n    vec4 c_0m = texture(iChannel0,uv_0m);\n    \n    //take a derivitive to add light and shadow, as if lit from above.\n    vec4 dcbydy = c_0p - c_0m;\n    \n    //A subtle texture for the background\n    float organicTex = mix( texture(iChannel1,uv + vec2(0.01*iTime)).b,1.0,0.9);\n\n \n    vec3 color = mix(organicTex*blue,yellow,c.r) - dcbydy.rgb;\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Based on \"Generalization of Conway’s 'Game of Life' to a continuous domain - SmoothLife\"\n    by Stephan Rafler\n    https://arxiv.org/pdf/1111.1567.pdf\n\t\n*/\n\nconst float dt = 0.1;\nconst bool showTransitionFunction = false;\nconst bool continuousTime = false;\n//Cell radii\nconst float innerRadius = 4.0;\nconst float outerRadius = 12.0;\n\n\nstruct CellDensity {\n    vec4 inner;\n    vec4 outter; \n};\n\n\n//If the inner cell is dead (inner = 0.0), then these are the conditions for birth\nconst float birth_min =  0.294;\nconst float birth_max = 0.335;\n\n//If the inner cell is alive (inner = 1.0), then these are the conditions for survival\nconst float survival_min = 0.256;\nconst float survival_max = 0.475; \n\n//Interploating with smooth transitions\nconst float smooth_i = 1.0; //inner smoothness\nconst float smooth_o = 0.09; //outer smoothness\nconst int max_it = 12;\n\n\n\n\nconst float PI = 3.14159265359;\n\n\n/*\n\tpaint to stimulate life\n*/\nfloat paint(vec2 uv){\n    \n    vec2 p = iMouse.xy/ iResolution.xy;\n    \n    float brushSize = 0.05;\n    \n    float r =  distance(p,uv);\n    float amp = 0.5+0.5*sin(-3.0*iTime + 12.0*r/brushSize);\n    if (r<brushSize && iMouse.z > 0.0 ) {\n        return (1.0 - r/brushSize)*amp;\n    }\n    else {\n     \treturn 0.0;   \n    }\n    \n}\n\n\n  \nCellDensity computeCellDensity(vec2 fragCoord,float r_min,float r_max){\n    \n    CellDensity d = CellDensity(vec4(0.0),vec4(0.0));\n    float norm_i = 0.0;\n    float norm_o = 0.0;\n    \n    const bool smoothEdges = true;\n    \n    \n    if( smoothEdges) {\n        //Some crude anti aliasing.\n        //This doesn't seem to make much differance apart from slowing things down.\n        //But it was going to fast, so good!\n     \tfloat dr = 0.5;\n        float a = 0.0;\n        for(int i=-max_it;i<max_it;i++){\n            for(int j=-max_it;j<max_it;j++){\n                vec2 du = vec2(i,j);\n                float r = length(du);\n                if(r<(r_max + dr)){\n                    vec2 uv = mod((fragCoord + du) / iResolution.xy,vec2(1.0));\n                    vec4 f = texture(iChannel0,uv);\n\n                    if(r<(r_min - dr) ){\n                       //inner \n                        d.inner += f;    \n                        norm_i += 1.0;\n\n                    }\n                    else if(r<(r_min + dr)){\n                        //inner edge transition\n\n                        a = r - r_min + dr;\n\n                        d.inner += f*(1.0-a);    \n                        norm_i += (1.0-a);\n                        d.outter += f*a;\n                        norm_o += a;\n                    }\n                    else if(r<(r_max - dr) ){\n                        //outer\n                        d.outter += f;    \n                        norm_o += 1.0;\n                    }\n                    else {\n                         //outer edge transition   \n                        a = r - r_max + dr;\n                        d.outter += f*(1.0-a);    \n                        norm_o += (1.0-a);\n                    }\n\n                }         \n\n            }\n        }\n    }\n   \telse {\n        for(int i=-max_it;i<max_it;i++){\n            for(int j=-max_it;j<max_it;j++){\n                vec2 du = vec2(i,j);\n                float r = length(du);\n                if(r<r_max ){\n                    vec2 uv = mod((fragCoord + du) / iResolution.xy,vec2(1.0));\n                    vec4 f = texture(iChannel0,uv);\n                    if (r<r_min){\n                        d.inner += f;    \n                        norm_i += 1.0;\n                    }\n                 \n                    else{\n                        d.outter += f;    \n                        norm_o += 1.0;\n                    }\n                 }\n            }\n        }\n    }\n\n    d.inner = d.inner/norm_i;\n    d.outter = d.outter/norm_o;\n    \n    return d;\n}\n\n\n\n/*\n\t\t   -----\n          |\t \t|\n    ------a\t\tb------\n*/\nfloat squareStep(float a, float b, float smoothness ,float t) {\n    return smoothstep(a-smoothness,a+smoothness,t)*(1.0-smoothstep(b-smoothness,b+smoothness,t));\n}\n\n\n/*\n             -------b\n            /\n     a-----/\n\nfloat smoothSwitch(float a,float b,float smoothness,float t){\n     return mix(a,b,smoothstep(0.5-smoothness,0.5+smoothness,t));\n    // return mix(a,b,t);\n}\n*/\n\nfloat smoothSwitch(float a,float b,float smoothness,float t){\n    float st = smoothstep( 0.5 - smoothness,0.5+smoothness ,t);\n    float s = mix( st, t,smoothness);\n    if(smoothness <0.5){\n        float st = smoothstep( 0.5 - smoothness,0.5+smoothness ,t);\n        return mix(a,b, st);\n    }\n    else {\n       float st = smoothstep( 0.0,1.0 ,t);\n        float s = mix( st, t,2.0*(smoothness-0.5));\n        return mix(a,b,s);\n    }\n  \n}\n\n/*\n\tThis is the function that gives us a new state for our pixel based on the old \n\tstate of its neigborhood. Its is different function to s(n,m) given in the paper. \n\tIts a good approximation, and seems a little clearer, at least to me.\n*/\nfloat transitionFunction(float outter, float inner){\n    \n  \tfloat a = smoothSwitch(birth_min,survival_min,smooth_i,inner);\n    float b = smoothSwitch(birth_max,survival_max,smooth_i,inner);\n   // return inner;\n   \treturn  squareStep(a,b,smooth_o,outter);\n}\n\n\n/*\n\tReinterpreting the transition function for continuous time.\n\tWe want df/dt\n*/\nfloat continuousTransitionFunction(float outter, float inner){\n    float s = transitionFunction(outter,  inner);\n    //return tan(PI*(0.5+s));  \n    return 2.0*s - 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = (fragCoord.xy ) / iResolution.xy;\n    \n    //Uncomment to plot transitionFunction:\n    if(showTransitionFunction){\n    \tfragColor = vec4(transitionFunction(uv.x,uv.y),0.0,1.0,1.0);\n        return;\n    }\n    \n    if(iTime<0.3) {\n        fragColor = vec4(texture(iChannel1,uv).r,0.0,0.0,1.0);\n        return;\n    }\n    \n   \tCellDensity cell = computeCellDensity(fragCoord.xy,innerRadius,outerRadius);\n    \n    float paintAlpha = paint(uv);\n   \tfloat newState;\n   \n     float f = texture(iChannel0,uv).r;\n    \n    if(continuousTime){\n        //I have not found constants that yield similar or good results for continuous time.\n       \n       \n        float s =  continuousTransitionFunction(cell.outter.r,cell.inner.r);\n         newState = clamp( f + dt*s,0.0,1.0);\n    }\n    else{\n        //discrete time\n        newState =  transitionFunction(cell.outter.r,cell.inner.r);\n    }\n\n    \n \tnewState = mix(newState,1.0,paintAlpha);\n    //vec3 color = vec3(newState);\n\tfragColor = vec4(newState,0.0,0.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}