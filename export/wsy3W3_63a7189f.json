{"ver":"0.1","info":{"id":"wsy3W3","date":"1586681277","viewed":173,"name":"World in motion","username":"DamnBirds","description":"Dynamic 3d projection of lines.\nPress SPACE to clear the screen.","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["2d","animation","fade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p=(fragCoord.xy*2.-iResolution.xy)/iResolution.x;\n    float tex = texture(iChannel0,uv).x;\n    float rate = 2.5;\n    tex = 1.-exp(-tex*rate);\n\n    fragColor.xyzw = vec4(mix(vec3(0.15),vec3(1.0),pow(tex,0.750)),1.0);\n    fragColor.xyz = pow(1.0-fragColor.xyz,vec3(1.0/2.2));\n    //fragColor.xyz = 1.0-fragColor.xyz; //reversed colors\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FADERATE 0.63925\n#define W_PLANET (1.0)\n#define W_ORBIT (0.08)\n#define W_SATELLITE (14.0)\n#define R_ORBIT 2.0\n#define R_PLANET 1.0\n#define R_SATELLITE 0.05\n#define iterations 4\n#define PI 3.1415926535898\n#define TWOPI 6.283185307179\n#define PROJECTION fisheye\n#define FOV radians(44.0)\n#define CS(a) vec2(cos(a),sin(a))\n\nvec2 ortho(vec3 point,float fov,vec3 ro,vec3 dir,vec3 up,vec3 right)\n{\n    point-=ro;\n    point*=mat3(right,up,dir);\n    point.xy*=fov;\n    if(point.z<0.0)\n        return vec2(10e8,10e8);\n    return point.xy;\n}\nvec2 persp(vec3 point,float fov,vec3 ro,vec3 dir,vec3 up,vec3 right)\n{\n    point-=ro;\n    point*=mat3(right,up,dir);\n    point.xy/=(point.z*tan(fov*0.5));\n    if(point.z<0.0)\n        return vec2(10e8,10e8);\n    return point.xy;\n}\nvec2 fisheye(vec3 point,float fov,vec3 ro,vec3 dir,vec3 up,vec3 right)\n{\n    point-=ro;\n\tpoint*=mat3(right,up,dir);\n    float theta = atan(point.y,point.x);\n    float r = length(point.xy);\n    float phi = atan(r,point.z)/fov;\n    point.xy=CS(theta)*phi;\n    if(point.z<0.0)\n        return vec2(10e8,10e8);\n    return point.xy;\n}\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdPoint(in vec2 p,in vec2 c)\n{\n\treturn length(p-c);\n}\nfloat periodCapture = 1.0/60.0;\n\nvec3 xyz(float t)\n{\n    vec2 z = CS(t*W_PLANET*TWOPI);\n    float halfperiod = 0.5/(W_PLANET);\n    float a = floor(t/halfperiod)/(4.0*halfperiod/W_ORBIT);\n    return vec3(CS(a*TWOPI).yx*abs(z.y),z.x);\n}\nvec3 xyz2(float t)\n{\n    vec2 z = CS(t*W_PLANET*0.04*TWOPI);\n    return vec3(CS(t*W_PLANET*TWOPI).yx*abs(z.y),z.x);\n}\n\nfloat xyzSystem(vec2 st,float time,float dt)\n{\n    float fov=FOV;\n    float r = 3.15;\n    vec3 eye=vec3(0,r,0.8);\n    vec3 target=vec3(0.0,-0.,0.0);\n    vec3 dir=normalize(target-eye);\n    vec3 up=vec3(0.,0.,1.);\n    vec3 right=normalize(cross(dir,up));\n    up=normalize(cross(right,dir));\n    float sd = 10.0e8;\n    vec3 p1 = xyz2(time)*R_PLANET;\n    float _time = time;\n    for(int i=0;i<iterations;i++)\n    {\n        _time+=dt;\n        vec3 p2 = xyz2(_time+0.0)*R_PLANET;\n        vec2 _p1=PROJECTION(p1,fov,eye,dir,up,right);\n        vec2 _p2=PROJECTION(p2,fov,eye,dir,up,right);\n    \tp1 = p2;\n        float dist = sdLine(st,_p1,_p2);\n        sd = min(dist,sd);\n    }\n    p1 = xyz(time)*R_PLANET;\n    _time = time;\n    for(int i=0;i<iterations;i++)\n    {\n        _time+=dt;\n        vec3 p2 = xyz(_time+0.0)*R_PLANET;\n        vec2 _p1=PROJECTION(p1,fov,eye,dir,up,right);\n        vec2 _p2=PROJECTION(p2,fov,eye,dir,up,right);\n    \tp1 = p2;\n        float dist = sdLine(st,_p1,_p2);\n        sd = min(dist,sd);\n    }\n    //orbit\n    _time = time;\n    {\n        float r = 2.0;\n    \tp1 = vec3(CS(_time*W_ORBIT*TWOPI).yx,0.0)*R_ORBIT;\n        _time+=dt*4.;\n    \tvec3 p2 = vec3(CS(_time*W_ORBIT*TWOPI).yx,0.0)*R_ORBIT;\n        vec2 _p1=PROJECTION(p1,fov,eye,dir,up,right);\n        vec2 _p2=PROJECTION(p2,fov,eye,dir,up,right);\n        float dist = sdPoint(st,_p1);\n        sd = min(dist,sd);\n        \n        _time = time;\n        vec2 sat = CS(_time*W_SATELLITE*TWOPI);\n        p1 +=vec3(sat.y*CS(_time*W_ORBIT*TWOPI).yx,\n                  sat.x)*R_SATELLITE;\n        _time+=dt*4.;\n        sat = CS(_time*W_SATELLITE*TWOPI);\n        p2 +=vec3(sat.y*CS(_time*W_ORBIT*TWOPI).yx,\n                  sat.x)*R_SATELLITE;\n        _p1=PROJECTION(p1,fov,eye,dir,up,right);\n        _p2=PROJECTION(p2,fov,eye,dir,up,right);\n        sd = min(sdPoint(st,_p1),sd);\n    }\n    float mask = exp(-pow(sd*700.0,0.5))*1.0;\n    mask = max(1.0/(pow(sd*800.,3.0)+1.0),mask);\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p=(fragCoord.xy*2.-iResolution.xy)/iResolution.x;\n    float dt = 1.0/120.0;\n    float time = float(iFrame*iterations)*dt;\n    float lastValue = texture(iChannel0,uv).x;\n    if(iFrame==0||texture(iChannel1,vec2((32.0+0.5)/256.0, 0.5/3.)).x>0.5)\n    {\n        lastValue = 0.0;\n    }\n    float curValue = xyzSystem(p,time,dt);\n    float fade = exp(-pow(periodCapture*FADERATE,1.0));\n    fragColor.x = min(curValue+lastValue*fade,10.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}