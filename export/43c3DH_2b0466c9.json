{"ver":"0.1","info":{"id":"43c3DH","date":"1724164016","viewed":14,"name":"gummmy","username":"miyaya","description":"Practice of ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","fresnel","phongmodel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define BACKGROUND_COLOR vec3(100.0 / 255.0, 149.0 / 255.0, 237.0 / 255.0)\n//mix(vec3(1, .341, .2), vec3(0,1,1), uv.y)*1.6\n#define AMBIENT_INTENSITY .0\n#define AMBIENT_LIGHT BACKGROUND_COLOR * AMBIENT_INTENSITY\n\nmat3 camera(vec3 cameraPos, vec3 lookAt)\n{\n  vec3 front = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(vec3(0,1,0), front));\n  vec3 up = normalize(cross(front, right));\n  \n  return mat3(-right, up, -front);\n}\n\n// sphere - rgb:color, w:sdf\nvec4 sdSphere(vec3 p, float r, vec3 center, vec3 col)\n{\n  float displace = sin(5.*p.x)*sin(6.*p.y)*sin(7.*p.z)*.125;\n  return vec4(col, length(p - center) - r) + displace;\n}\n\n// floor - rgb:color, w:sdf\nvec4 sdFloor(vec3 p, vec3 col)\n{\n  //col = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  return vec4(col, p.y + 1.);\n}\n\nfloat sdCube(vec3 p, vec3 dimension)\n{\n    vec3 d = abs(p) - dimension;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvec4 minWithColor(vec4 o1, vec4 o2)\n{\n  if(o1.w < o2.w) return o1;\n  return o2;\n}\n\nvec3 track(float t) \n{\n  //vec3 track = vec3(sin(iTime)+2.*sin(2.*iTime), cos(iTime)-2.*cos(2.*iTime), sin(3.*iTime))*.1;\n  float pp=2.;\n  float q=3.;\n  return vec3(cos(pp*t)*(3.+cos(q*t)), sin(pp*t)*(3.+cos(q*t)), sin(q*t))*.3;\n}\n\nvec4 sdScene(vec3 p)\n{\n    vec4 s1 = sdSphere(p, .2, track(iTime), vec3(0., 1., 1.));\n    vec4 s2 = sdSphere(p, .2, track(iTime+.7), vec3(1., 1., 0.));\n    vec4 s3 = sdSphere(p, .2, track(iTime+1.2), vec3(1., 0., 1.));\n    vec4 s4 = sdSphere(p, .2, track(iTime+1.9), vec3(1., 1., 1.));\n    vec4 s5 = sdSphere(p, .2, track(iTime+2.3), vec3(.5, 6., 1.));\n    vec4 s6 = sdSphere(p, .2, track(iTime+2.6), vec3(1., .5, .8));\n    vec4 s7 = sdSphere(p, .2, track(iTime+2.9), vec3(.2, .4, .5));\n    vec4 f1 = sdFloor(p, vec3(0., 0., 1.));\n    \n    return minWithColor(s1, minWithColor(s2, minWithColor(s3, minWithColor(s4, \n           minWithColor(s5, minWithColor(s6, minWithColor(s7, f1)))))));\n}\n\nmat3 rotate(float theta, int dir) \n{\n  float c = cos(theta);\n  float s = sin(theta);\n  switch(dir)\n  {\n  case 0: //x\n    return mat3(vec3(1,0,0), vec3(0,c,-s), vec3(0,s,c));\n  case 1: //y\n    return mat3(vec3(c,0,s), vec3(0,1,0), vec3(-s,0,c));\n  case 2: //z\n    return mat3(vec3(c,-s,0), vec3(s,c,0), vec3(0,0,1));\n  }\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end) \n{\n  float depth = start;\n  vec4 closestObj;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n  {\n    vec3 p = ro + depth * rd;\n    closestObj = sdScene(p);\n    \n    depth += closestObj.w;\n    \n    if (closestObj.w < PRECISION || depth > end)\n        break;\n  }\n\n  return vec4(closestObj.rgb, depth);\n}\n\nbool hit(float d)\n{\n  return d < 100.0;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec2 epsilon = vec2(1.0, -1.0) * 0.0005;\n  float r = .3; // radius of sphere\n  vec3 center = vec3(0, 0, -1);\n  \n  return normalize(\n    epsilon.xyy * sdScene(p + epsilon.xyy).w + epsilon.yyx * sdScene(p + epsilon.yyx).w +\n    epsilon.yxy * sdScene(p + epsilon.yxy).w + epsilon.xxx * sdScene(p + epsilon.xxx).w);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rayDir, vec3 ambCol, vec3 lightCol)\n{\n  float k_a = .3;\n  vec3 ambient = k_a * ambCol;\n\n  float k_d = .3;\n  float dotLN = clamp(dot(normal, lightDir), 0., 1.);\n  vec3 diffuse = k_d * dotLN * lightCol;\n\n  float k_s = .25;\n  vec3 R = reflect(-normal, lightDir);\n  float dotRV = clamp(dot(R, -rayDir), 0., 1.);\n  vec3 i_s = vec3(.8, .8, .8);\n  float alpha = 12.;\n  vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\n  return ambient + diffuse + specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy - .5;\n    \n    vec3 lookat = vec3(0, 0, 0);\n    float rotateR = 5.;\n    //vec3 ro = vec3(sin(iTime*2.5) * rotateR, sin(iTime*.5) * 0.5, cos(iTime*2.5) * rotateR); // ray origin: pos of camera\n    vec3 ro = vec3(0., 0., 4.);\n    vec3 rd = camera(ro, lookat) * normalize(vec3(uv, -1)); // ray direction: each ray is fired toward `lookat`\n    \n    //rd *= rotate(mouse.x, 1) * rotate(mouse.y, 0); // tilt\n    vec4 d = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n\n    vec3 col = BACKGROUND_COLOR;\n    if (hit(d.w))\n    {\n      vec3 p = ro + rd * d.w; // point on sphere we discovered from ray marching\n      \n      vec3 lightPosition = vec3(sin(iTime)*4., 0., 2);\n      //vec3 lightPosition = vec3(((iMouse.x / iResolution.x) - 0.5) * 3.0, 0.0, 2);\n      vec3 lightDirection = normalize(lightPosition - p);\n      \n      vec3 normal = calcNormal(p);\n      \n      float fresnel = pow(clamp(1.-dot(normal, -rd), 0., 1.), .8);\n      vec3 rimCol = vec3(1., 1., 0.);\n      \n      //float dif = clamp(dot(normal, lightDirection), 0.0, 1.0);\n      //col = ((vec3(dif) * d.rgb) + AMBIENT_LIGHT); // * BACKGROUND_COLOR;\n      col = phong(lightDirection, normal, rd, d.rgb, vec3(.8, .1, .1));\n      col += phong(normalize(vec3(3., 1., 3.)-p), normal, rd, d.rgb, vec3(.1, .9, .3));\n      col += clamp(fresnel, .1, .6) * rimCol;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}