{"ver":"0.1","info":{"id":"NtVcDm","date":"1661607423","viewed":137,"name":"Morton conversion","username":"Suslik","description":"A simple shader that converts morton curve(z-curve) to uvec2 and back","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["zcurve","morton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Z-curve45.svg/1024px-Z-curve45.svg.png\n//https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n\n//0b0000dcba -> 0b0d0c0b0a\nuint SpreadBits(uint x)\n{\n  x &= 0x0000ffffu;                   // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  x = (x ^ (x <<  8u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x <<  4u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x <<  2u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x <<  1u)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  return x;\n}\n\n//0b0d0c0b0a -> 0b0000dcba\nuint GatherBits(uint x)\n{\n  x &= 0x55555555u;                   // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  x = (x ^ (x >>  1u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x >>  2u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x >>  4u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x >>  8u)) & 0x0000ffffu; // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  return x;\n}\n\n//0bhgfedcba -> (0b0000geca, 0b0000hfdb)\nuvec2 MortonToVec2(uint morton)\n{\n    uvec2 res;\n    res.x = GatherBits(morton >> 0);\n    res.y = GatherBits(morton >> 1);\n    return res;\n    \n    //return uvec2(GatherBits(morton), GatherBits(morton >> 1)); //this makes shader compiler explode\n}\n\n//(0b0000dcba, 0b0000hgfe) -> 0bhdgcfbea\nuint Vec2ToMorton(uvec2 vec)\n{\n  return SpreadBits(vec.x) | (SpreadBits(vec.y) << 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uvec2 pixel_index = uvec2(fragCoord);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    uint test_size = 256u;\n    if(pixel_index.x < test_size)\n    {\n        float norm_curve = float(Vec2ToMorton(pixel_index)) / float(test_size * test_size);\n        col = (norm_curve < fract(iTime * 0.1f)) ? vec3(norm_curve) : vec3(uv, 0.0f);\n    }else\n    if(pixel_index.x < 2u * test_size)\n    {\n        uvec2 curve_vec = pixel_index - uvec2(test_size, 0);\n        uint curve_val = Vec2ToMorton(curve_vec);\n        uvec2 curve_vec_test = MortonToVec2(curve_val);\n        \n        col = (length(vec2(curve_vec_test) - vec2(curve_vec)) > 0.5f) ? vec3(1.0f, 0.0f, 0.0f) : vec3(0.0f, 1.0f, 0.0f);\n    }\n    \n    // Time varying pixel color\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}