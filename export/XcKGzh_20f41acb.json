{"ver":"0.1","info":{"id":"XcKGzh","date":"1732049853","viewed":145,"name":"Watery Wavelet Experiment","username":"gehtsiegarnixan","description":"A little experiment in making wavelets as water-like as possible with pushing wave tops in wind direction and making them more crest shaped.","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["wave","water","normal","gabor","wavelet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nA little experiment in making wavelets as water-like as possible with \nmy current skills. I didn't read much up and made my own functions for \nthis purpose and gave them terrible names. I recommend looking at the \nDesmos graphs of them if you want to understand what they do, as they \nare a bit odd. See https://www.desmos.com/calculator/u95gjsesrr\n\nI am not very happy with the normal generation using three height \nsamples and finite difference. However, the analytical method becomes \nquite difficult considering the amplitude will also vary dynamically\nwhen laying waves randomly in Gabor noise. I may revisit this later \nfor a faster, more elegant solution. \n\nYou can change the wave direction using the mouse.\n\nNext up: Optimizing Fractal Gabor noise using these pretty wavelets\nhttps://www.shadertoy.com/view/lf3GzB\n*/\n\n// Disable to get vanilla Sinus waves; otherwise, water-like waves\n#define WATER_WAVE\n\n// Radius of the wavelet\n#define RADIUS 0.5\n\n// Wave length\n#define WAVE_LENGTH 0.3\n\n// Nudge the water wave crest towards the movement direction, values -0.99 to 0.99\n#define PUSH 0.5\n\n// How steep the water wave crest is, values 0 to 1 (but can go higher)\n#define CREST 0.3\n\n// Disable to have straight wavelets\n#define ROUNDED\n\n// Switch SHOW_VALUES to enable different views\n// 0 = colormap of height\n// 1 = lit flat color\n// 2 = normal vectors with quiver plot\n#define SHOW_VALUES 0\n\n// comment this to disable a line graph of the height\n#define SIDE_VIEW\n\n// Calculate the Gaussian distribution value. Result at radious is 0.05\nfloat gauss(float sqrtdist, float radius) {\n\n    // Gaussian formula\n    return exp(LN_005 * sqrtdist / (radius * radius));\n}\n\n// Nudge the x.5 values towards either the closed smaller or larger full number\nfloat nudge(float x, float push) {\n\n    // Rescale push to be a 0-1 value from -1 to 1\n    push = push * 0.5 + 0.5;\n    float grid = fract(x);\n\n    // Moving the half point towards\n    float nudged = 0.5 * clamp(grid          /        push,  0.0, 1.0) + \n                   0.5 * clamp((grid - push) / (1.0 - push), 0.0, 1.0);\n\n    // Add the floor again to negate fract\n    return floor(x) + nudged;\n}\n\n// Wave function controlling the cresent shape, could be better ...\n// See: https://www.desmos.com/calculator/njitivdjjj\nfloat cresent(float gradient, float crest) {\n\n    // approximating cresent shape of gerstner waves\n    float cosValue = cos(gradient);\n    return ((-cosValue - 1.0) / (4.0 * crest * (cosValue - 1.0) - 1.0)) - 1.0;\n}\n\n// More water-like wave height\n// See https://www.desmos.com/calculator/u95gjsesrr\nfloat waterWave(float gradient, float wavelength, float push, float crest) {\n\n    // Gradient calculation using nudge\n    float nudgedGradient = TWO_PI * (nudge(gradient / wavelength, push) + 0.5);\n    \n    // Calculate wave height using cresent function\n    return cresent(nudgedGradient, crest);\n}\n\n// Simple sinus wave for comparison\nfloat sinusWave(float gradient, float wavelength) {\n\n    // scale gradient\n    float frequency = TWO_PI / wavelength;\n    gradient *= frequency;\n    \n    // Calculate wave height at the original gradient\n    return sin(gradient);\n}\n\n// Generates a gabor wavelet with normals\nfloat wavelet (vec2 position, vec2 direction, float time, float radius,  float wavelength) {\n    \n    // Generate gradient\n    #ifdef ROUNDED                \n        // Offset the wave center for rounded waves\n        vec2 waveCenter = position + direction * radius; \n        // maybe the offset should be seperate to radius ...\n\n        // Calculate the gradient as the distance from the wave center\n        float gradient = length(waveCenter);\n\n        // Direction of the spherical wave\n        vec2 waveDirection = safeNormalize(waveCenter);\n    #else\n        // Calculate the gradient as the dot product with the current direction\n        float gradient = dot(position, direction);\n\n        // Direction of the straight wave\n        vec2 waveDirection = direction;\n    #endif\n    \n    // Calculate wave speed based on wavelength in meters (for deep-water)\n    #define GRAVITY 9.807 // m/s^2\n    // float waveSpeed = sqrt(GRAVITY * wavelength / (TWO_PI)); \n\n    // Add time offset\n    // Not realistic, as the length is not meters and is for baking into a texture. \n    // If using waveSpeed, ensure the random time offset allows for one period variation.\n    gradient -= time * wavelength; \n    \n    // sample wave\n    #ifdef WATER_WAVE\n        // Water like wave\n        float wave = waterWave(gradient, wavelength, PUSH, CREST);\n    #else\n        // basic Sinus wave\n        float wave = sinusWave(gradient, wavelength);\n    #endif\n    \n    // Gauss/normal distribution to disance for amplitude falloff\n    float amplitude = gauss(dot(position, position), radius);\n    \n    // apply amplitude to wave\n    return wave * amplitude;\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormal(vec2 uv, vec2 direction, float time, float radius, float wavelength, float strength) {  \n\n    const float epsilon  = 1.0/1024.0; // 1024 arbitrary\n    \n    // Sample 3 positions offset by small epsilon\n    float p = wavelet(uv, direction, time, radius, wavelength);\n    float h1 = wavelet(uv + vec2(epsilon, 0.0), direction, time, radius, wavelength);\n    float v1 = wavelet(uv + vec2(0.0, epsilon), direction, time, radius, wavelength);\n\n    vec2 xy = (p - vec2(h1, v1)) * 1024.0; // corrected for epsilon\n    return normalize(vec3(xy * strength, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Square UVs with (0,0) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;  \n    \n    // If the mouse was not clicked, animate\n    vec2 direction;\n    if (iMouse.x > 0.0) {\n        // Scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n                \n        // Normalize the vector\n        direction = -safeNormalize(mouse - 0.5);\n        \n    } else {\n        // Animated vector\n        float angle = iTime * 0.1;\n        \n        // Calculate normalized direction from angle\n        direction = -vec2(sin(angle), cos(angle));      \n    }    \n    \n    // Scale animation time\n    float time = iTime * 0.2;\n    \n    // Sample the wavelet \n    float height = wavelet(uv, direction, time, RADIUS, WAVE_LENGTH);\n    \n    // Test if normals are correct\n    vec3 normal = HeightToNormal(uv, direction, time, RADIUS, WAVE_LENGTH, 0.1);\n    \n    #if SHOW_VALUES == 0\n        // Show height as colormap\n        vec3 color = viridis(height * 0.5 + 0.5);\n        \n    #elif SHOW_VALUES == 1\n        // Make base color slightly blueish based on height\n        vec3 color = mix(vec3(0.043,0.353,0.400), vec3(0.102,0.953,1.000), height * 0.5 + 0.5);\n        \n        // Apply lighting to show the normals too\n        const vec3 lightDir = normalize(vec3(1, 1, 0.5));\n        const vec3 ambientLight = vec3(0.000,0.192,0.482);\n        const vec3 sunColor = vec3(1.000,0.925,0.702);\n        color = phongLighting(color, normal, vec3(0,0,1), lightDir, ambientLight, sunColor, 1.0);\n        \n    #elif SHOW_VALUES == 2\n        // Show normals as 0-1 color\n        vec3 color = normal * 0.5 + 0.5;\n        \n        // Debug quiver plot for the normals\n        color *= 1.0 - quiverPlot(uv, normal.xy, iResolution.x / 64.0);  \n    #endif\n    \n    #ifdef SIDE_VIEW\n        // Sample the water wave flowing down the y axis\n        float side = waterWave(-uv.y -time * WAVE_LENGTH, \n                    WAVE_LENGTH, PUSH, CREST) * gauss(uv.y * uv.y, RADIUS);       \n        \n        // make kinda distance field for line and AA smoothing\n        float dist = (0.75 + uv.x - side * 0.05); // abs makes steep lines too thin\n        float aa = fwidth(dist) * 1.0;    \n        float thickness = 0.01;\n        float line = smoothstep(thickness +aa, thickness -aa, dist);\n        float fade = smoothstep(-0.9, -0.7, uv.x); // cosmetic fading of line\n        \n        // add line to color\n        color = mix(color, vec3(0.274,0.004,0.329), min(line, fade));\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Constants\n#define LN_005 -2.99573227355 // natural logarithm of 0.05\n#define TWO_PI  6.28318530718\n#define SMALLEST_FLOAT (1.0 / float(0xffffffffU))\n\n// GENERIC FUNCTIONS ___________________________________________________\n\n// Safe Normalization using dot product and square root\nvec2 safeNormalize(vec2 vector) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLEST_FLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a default vector\n        return vec2(0,1);\n    }\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// LIGHTING FUNCTIONS _______________________________________________\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir, \n                   vec3 ambientLightColor, vec3 sunColor, float specularStrength) {\n    // Ambient\n    vec3 ambient = ambientLightColor * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 8.0);\n    vec3 specular = specularStrength * spec * sunColor;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// DEBUG FUNCTIONS _________________________________________________\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize) {\n\n    // constants that maybe should be input variables\n    const float lineThickness = 0.03;    // Thickness of the arrow line\n    const float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    const float maxSize = 0.8;           // Maximum arrow length (1 should be the max)\n    const float minSize = 0.1;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the direction vector length is almost 0\n    if (lenSq > SMALLEST_FLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        //return step(arrowDist, 0.0); // no AA\n        float blur = (gridSize * 1.0)/(size * 420.);\n        return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}","name":"Common","description":"","type":"common"}]}