{"ver":"0.1","info":{"id":"mt2BDV","date":"1694587233","viewed":150,"name":"sRGB Dithering","username":"ttg","description":"Comparison of various wrong, good, better and best sRGB dithering/quantization.\n\nSee Buffer A for rows top to bottom.\nMouse up/down: select row,\nMouse left to right selects mode: temporal, average over time, plot proportionate error, average longer time.","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["dithering","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nsRGB Dithering\nhttps://www.shadertoy.com/view/mt2BDV\n\nComparison of various wrong, good, better and best sRGB dithering/quantization.\n\nSee Buffer A for rows top to bottom.\nMouse up/down: select row,\nMouse left to right selects mode:\n  temporal, average over time, plot proportionate error, average longer time.\n\n\nCopyright 2023 Theron Tarigo.  All rights reserved.\n\nThis shader may be copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this shader is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/mt2BDV\", is displayed within the source.\n\n*/\n\n\nvoid mainImage (out vec4 ImgOut, vec2 f) {\n  vec2 R = iResolution.xy;\n  ivec2 I = ivec2(f);\n  ivec2 N = ivec2(R);\n  int rs = N.y/nrows;\n  int rb = I.y/rs*rs;\n  int i = nrows-1-I.y/rs;\n  vec2 u = f/R;\n\n  vec3 O = vec3(0.);\n  \n  int my = int(iMouse.y);\n  int rbm = my/rs*rs;\n  if(iMouse.x==0.)rbm=1*rs;\n  \n  if(u.x<.5) {\n    O = texture(iChannel0,u*vec2(2,1)).rrr;\n    if(I.y==rbm+rs/2) O.g=1.;\n  } else {\n    vec4 d = texelFetch(iChannel0,ivec2((u.x*2.-1.)*R.x,rbm),0);\n    float y,t,s=exp2(3.-float(nbits));\n    \n    if(iMouse.x/R.x>.8) d=.5*d/d.w;\n    \n    y=u.y; t=1./R.y;\n    // grey plot: exact value\n    if (t>abs(-y+d.w)) O+=.1;\n    // blue plot: average result\n    if (t>abs(-y+d.x)) O.b++;\n    \n    y=(u.y*2.-1.)*.2*s; t=.4/R.y*s;\n    // grey plot: zero line\n    if (t>abs(-y)) O+=.1;\n    // red plot: error\n    if (t>abs(-y+d.x-d.w)) O.r++;\n    \n    y=u.y*.1*s*s; t=.1/R.y*s*s;\n    // green plot: variance (noise)\n    if (t>abs(-y+d.y)) O.g++;\n  }\n\n  ImgOut.rgb = srgb_oetf(O);\n}\n\n/*\nCopyright 2023 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst int nrows = 10;\nconst int nbits = 4;\n\nvec3 srgb_oetf (vec3 c) {\n  return mix(12.92*c,1.055*pow(c,vec3(1./2.4))-.055,step(.0031308,c));\n}\n\nvec3 srgb_eotf (vec3 e) {\n  return mix(e/12.92,pow((e+.055)/1.055,vec3(2.4)),step(.04045,e));\n}\n\nfloat srgb_oetf (float c) { return srgb_oetf(vec3(c)).x; }\nfloat srgb_eotf (float e) { return srgb_eotf(vec3(e)).x; }\n\nuint hash_triple32(uint x) {\n  // https://nullprogram.com/blog/2018/07/31/\n  x ^= x >> 17;\n  x *= 0xED5AD4BBu;\n  x ^= x >> 11;\n  x *= 0xAC4C1B51u;\n  x ^= x >> 15;\n  x *= 0x31848BABu;\n  x ^= x >> 14;\n  return x;\n}\n#define hash hash_triple32\nint hash(int x) { return int(hash(uint(x))); }\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\nhttps://www.shadertoy.com/view/mt2BDV\n\nThis shader may be copied under the terms of the ISC License; see end of file.  As an exception, the full permission notice may be omitted where this shader is copied within Shadertoy and the full URL, \"https://www.shadertoy.com/view/mt2BDV\", is displayed within the source.\n\n*/\n\n\nfloat probmix(float A, float B, float C, float var, float rnd) {\n  float PB = clamp((A*C+var)/((B-A)*(B-C)),0.,.75);\n  float PA = mix(C,B,PB)/(C-A);\n  /* float PC = 1.-PA-PB; */\n  \n  // sanity check probabilities\n  // some fail, but with insignificant consequence\n  //if(PA<0.||PC<0.)return 10.;\n  //if(PA>1.||PC>1.)return 10.;\n\n  if(rnd<PA)\n    return A;\n  if(rnd<PA+PB)\n    return B;\n  /* if(rnd<PA+PB+PC) */ // cum prob = 1\n    return C;\n}\n\nvoid mainImage (out vec4 O, vec2 f) {\n  vec2 R = iResolution.xy;\n  ivec2 I = ivec2(f);\n  ivec2 N = ivec2(R);\n  int rs = N.y/nrows;\n  int i = nrows-1-I.y/rs;\n  int seed = I.x+N.x*I.y;\n  seed = hash(seed)^iFrame;\n  vec2 rnd = .5*unpackSnorm2x16(hash(uint(seed)));\n#ifdef BLUENOISE\n  rnd = -.5+texelFetch(iChannel3,(I+hash(iFrame))&1023,0).xy;\n#endif\n  \n  float rpdf = rnd.x;\n  float tpdf = dot(vec2(1),rnd);\n\n  float x = f.x/R.x;\n  x=x*x;\n\n  float bitres = 1./(exp2(float(nbits))-1.);\n  \n  #define EOTF srgb_eotf\n  #define OETF srgb_oetf\n\n  float y;\n  if (i==0) {\n    // no dither\n    y = OETF(x);\n  }\n  if (i==1) {\n    // bad: RPDF dither before OETF\n    float xd = x + rpdf*.05;\n    y = OETF(xd);\n  }\n  if (i==2) {\n    // bad: TPDF dither before OETF\n    float xd = x + tpdf*.05;\n    y = OETF(xd);\n  }\n  if (i==3) {\n    // bad: RPDF dither in the space that will be quantized\n    y = OETF(x);\n    y += rpdf*bitres;\n  }\n  if (i==4) {\n    // bad: TPDF dither in the space that will be quantized\n    //      with no avoidance of clipping\n    y = OETF(x);\n    y += tpdf*bitres;\n  }\n  if (i==5) {\n    // good: TPDF dither in the space that will be quantized\n    // Note that with 8 bit depth, errors are imperceptible.\n    // Any further refinement yields especially high accuracy, or\n    // else improvements noticeable only at lower bit depths.\n    // 6 bits is common for low cost LCDs.\n    x *= (1.-bitres);\n    y = OETF(x);\n    y += tpdf*bitres;\n  }\n  if (i==6) {\n    // better: quantized space TPDF dither, hacky linear quantization\n    x *= (1.-bitres);\n    y = OETF(x);\n    y += tpdf*bitres;\n    float yl = floor(y/bitres)*bitres;\n    float yh = yl+bitres;  /* ceil(y/bitres)*bitres */\n    y = 2.*EOTF(y) > EOTF(yl)+EOTF(yh) ? yh : yl;\n  }\n  if (i==7) {\n    // bad: quantized space RPDF dither, optically linear quantization\n    x *= (1.-bitres);\n    y = OETF(x);\n    // lower possible value\n    float yc = floor(y/bitres)*bitres;\n    // delta to upper possible value\n    float yd = bitres;\n    // what fraction is optical intensity between these values\n    float f = (x-EOTF(yc))/(EOTF(yc+yd)-EOTF(yc));\n    // select value depending on random threshold\n    y = f-.5>rpdf ? yc+yd : yc;\n  }\n  if (i==8) {\n     // best: probabilistic mix of 3 quantized values for carefully controlled variance\n    y = OETF(x);\n    float yb = round(y/bitres)*bitres;\n    float A = EOTF(clamp(yb-bitres,0.,1.));\n    float B = EOTF(yb);\n    float C = EOTF(clamp(yb+bitres,0.,1.));\n    float d = (EOTF(y+.01*bitres)-x)/.01;\n    float var = d*d*.25;\n    float xd = x+probmix(A-x,B-x,C-x,var,rnd.x+.5);\n    y = OETF(xd);\n    y = round(y/bitres)*bitres;\n    \n    //y=srgb_oetf_dither(vec3(x)).x;\n  }\n  \n  // quantize\n  y = round(y/bitres)*bitres;\n  y = clamp(y,0.,1.);\n  \n  if (i==9) {\n    y = OETF(x);\n  }\n  \n  O.x = y;\n  O.w = x;\n}\n\n/*\nCopyright 2023 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage (out vec4 O, vec2 f) {\n  vec2 R = iResolution.xy;\n  ivec2 I = ivec2(f);\n  ivec2 N = ivec2(R);\n  int rs = N.y/nrows;\n  int rb = I.y/rs*rs;\n  int i = nrows-1-I.y/rs;\n\n  O = texelFetch(iChannel0,I,0);\n  vec4 d = texelFetch(iChannel1,I,0);\n  vec4 v = vec4(0.);\n  v.rgb = srgb_eotf(d.rgb);\n  \n  if(I.y==rb) {\n    v = vec4(0.);\n    for (int i=0;i<rs;i++) {\n      float x = srgb_eotf(texelFetch(iChannel1,ivec2(I.x,rb+i),0).r);\n      v.x += x;\n      v.y += x*x;\n    }\n    v /= float(rs);\n    v.y -= v.x*v.x;\n    v.w = d.w;\n  }\n  float M=iMouse.x/R.x;\n  O = M<.4?v:mix(O,v,M<.95?.01:.001);\n}","name":"Buffer B","description":"","type":"buffer"}]}