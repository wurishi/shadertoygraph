{"ver":"0.1","info":{"id":"tdGyRc","date":"1603365031","viewed":348,"name":"Laser pt","username":"boris159","description":"Small path tracing for laser","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","pathtracing","montecarlo","laser","raytrcing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 col = tex.xyz / tex.a;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 256.0\n#define MAX_STEPS 256\n#define bounces 8\n#define points 7\n\nvec3 pointArr[points];\n\nstruct BounceData\n{\n    vec3 emitt;\n    vec3 ref;\n};\n\nfloat seed;\n\nfloat rand()\n{\n    seed += 0.15342;\n    return fract(sin(seed) * 35423.7652344);\n}\n\nfloat randUnit(float a, float b)\n{\n\treturn a + (b - a) * rand();\n}\n\nvec3 randDir(vec3 dir, float spread)\n{\n    vec3 b3 = normalize(dir);\n    vec3 different = (abs(b3.x) < 0.5) ? vec3(1, 0, 0) : vec3(0, 1, 0);\n    vec3 b1 = normalize(cross(b3, different));\n    vec3 b2 = cross(b1, b3);\n\n    float z = randUnit(cos(spread * PI), 1.0);\n    float r = sqrt(1.0 - z * z);\n    float theta = randUnit(-PI, PI);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n\n    return b1 * x + b2 * y + b3 * z;\n}\n\nmat2 rot(float ang)\n{\n    float s = sin(ang);\n    float c = cos(ang);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotVec(vec3 p, vec3 r)\n{\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 makeRay(vec2 origin)\n{\n    vec2 res;\n    res.x = origin.x - iResolution.x * 0.5;\n    res.y = origin.y - iResolution.y * 0.5;\n    return normalize(vec3(res / iResolution.yy, 3));\n}\n\nfloat box(vec3 b, vec3 pos, vec3 p)\n{\n    vec3 q = abs(p - pos) - b;\n  \treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat capsule(vec3 a, vec3 b, float r, vec3 p)\n{\n    vec3 pa = p - a, ba = b - a;\n  \tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  \treturn length(pa - ba * h) - r;\n}\n\nfloat laser(vec3 origin)\n{\n    float sd = MAX_DIST;\n    \n    for (int i = 0; i < points - 1; i++)\n        sd = min(sd, capsule(pointArr[i], pointArr[i + 1], 0.005, origin));\n    \n    return sd;\n}\n\nvec3 laserCol(float z)\n{\n    return mix(vec3(0, 0.05, 1), vec3(1, 0.05, 0), z / 6.0);\n}\n\nvec2 getDist(vec3 origin)\n{\n    float sd = MAX_DIST;\n    float id = 0.0;\n    float las = laser(origin);\n    float box = -box(vec3(1, 0.6, 6), vec3(0), origin);\n    \n    if (las < sd)\n    {\n        sd = las;\n        id = 1.0;\n    }\n    \n    if (box < sd)\n    {\n        sd = box;\n        id = 2.0;\n    }\n    \n    return vec2(sd, id);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p).x;\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).x,\n        getDist(p-e.yxy).x,\n        getDist(p-e.yyx).x\n    );\n    \n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 origin, vec3 direct)\n{\n    float res = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 tmp = origin + direct * res;\n        vec2 d = getDist(tmp);\n        res += d.x;\n        \n        if (d.x < EPSILON)\n        \treturn vec2(res, d.y);\n        \n        if (res >= MAX_DIST)\n            return vec2(MAX_DIST, 0);\n    }\n\n    return vec2(MAX_DIST, 0);\n}\n\nvec3 trace(vec3 origin, vec3 dir)\n{\n\tvec3 globalCol = vec3(0);\n    BounceData cols[bounces];\n    vec3 p = origin, e;\n    \n    for (int b = 0; b < bounces; b++)\n    {\n        vec2 res = rayMarch(origin, dir);\n        origin += dir * res.x;\n       \n        if (b == 0)\n            e = origin;\n        \n        if (res.y == 0.0)\n        {\n        \tcols[b] = BounceData(vec3(0), vec3(0));\n            break;\n        }\n        else if (res.y == 1.0)\n        {\n            if (b == 0)\n                return vec3(1.0);\n            \n            cols[b] = BounceData(laserCol(origin.z) * 4.0, vec3(0));\n        }\n        else\n            cols[b] = BounceData(vec3(0), vec3(1));\n        \n        vec3 normal = getNormal(origin);\n        origin += normal * EPSILON * 5.0;\n        dir = randDir(normal, 0.5);\n    }\n    \n    for (int i = bounces - 1; i >= 0; i--)\n    \tglobalCol = cols[i].emitt + globalCol * cols[i].ref;\n    \n    for (int i = 0; i < bounces; i++)\n    {\n        vec3 tmp = mix(p, e, rand());\n       \tglobalCol += 0.02 * laserCol(tmp.z) / pow(laser(tmp), 2.0) / float(bounces);\n    }\n    \n    return globalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pointArr[0] = vec3(-1, -0.6, 0);\n    pointArr[1] = vec3(1, 0, 1);\n    pointArr[2] = vec3(-1, 0.6, 2);\n    pointArr[3] = vec3(0, -0.6, 3);\n    pointArr[4] = vec3(1, 0.6, 4);\n    pointArr[5] = vec3(-1, -0.6, 5);\n    pointArr[6] = vec3(0, 0.6, 6);\n    \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 pos = vec3(0, 0, -4);\n    vec3 dir = makeRay(fragCoord);\n    \n    vec4 col = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 traced = trace(pos, dir);\n   \tcol += vec4(traced, 1);\n    \n    if (iMouse.z > 0.0)\n        col = vec4(0);\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}