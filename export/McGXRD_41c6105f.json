{"ver":"0.1","info":{"id":"McGXRD","date":"1714912736","viewed":184,"name":"Ray Grid Intersections","username":"chronos","description":"Yes, it's another one of these :P","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["ray","grid","intersection","traversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Ray grid intersections by chronos\n    --------------------------------------\n    \n    Nothing special, just doing some more practice in DDA grid traversal.\n    \n*/\n\n\nfloat segment(vec2 a, vec2 b, vec2 p)\n{\n    p-=a; b-=a;\n    return length(clamp(dot(p, b)/dot(b,b), 0. , 1.) * b - p);\n}\n\nfloat line(vec2 a, vec2 b, vec2 p)\n{\n    p-=a; b-=a;\n    return length(dot(p, b)/dot(b,b) * b - p);\n}\n\nfloat stipples(vec2 a, vec2 b, vec2 p)\n{\n    p-=a; b-=a;\n    return length(round(dot(p, b)/dot(b,b)*8.)/8. * b - p);\n}\n\nfloat half_stipples(vec2 a, vec2 b, vec2 p)\n{\n    p-=a; b-=a;\n    return length(round(max(dot(p, b)/dot(b,b), 0.)*8.)/8. * b - p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 4.;\n    vec2 uv = scale*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = scale*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse2 = scale*(2.*abs(iMouse.zw)-iResolution.xy)/iResolution.y;\n    float ps = scale *2. / iResolution.y;\n    \n    vec2 ro = length(iMouse.xy) > 10. ? mouse2 : vec2(0);\n    vec2 rd = length(iMouse.xy) > 10. ? normalize(mouse - mouse2): vec2(cos(iTime), sin(iTime));\n    \n    vec3 color = vec3(0);\n\n    vec2 grid_uv = fract(uv);\n    vec2 grid_id = floor(uv);\n\n    float axes_thickness = 0.01;\n    vec2 grid_axes = smoothstep(axes_thickness+ps, axes_thickness-ps, grid_uv) + smoothstep(axes_thickness+ps, axes_thickness-ps, grid_uv);\n    color = mix(color, vec3(0., 0.3, 0.7), 0.01 + 0.99 * grid_axes.x);\n    color = mix(color, vec3(0.7 , 0., 0.3), 0.01 + 0.99 * grid_axes.y);\n\n    float alpha = smoothstep(ps, -ps, length(uv-ro) - 0.1);\n    color = mix(color, vec3(1), .5*alpha);\n\n    float d = half_stipples(ro, ro + rd, uv);\n    alpha = smoothstep(0.01 + ps, 0.01-ps, d);\n    color = mix(color, vec3(1), 0.5*alpha);\n\n    const float n = 2.; // number of intersections per axis\n    for(float i = 0.; i <= n; i++)\n    {\n        // Ray intersection time per axis (x and y)\n        // derived from solving axis-aligned ray-plane intersection, e.g:\n        // ro.x + rd.x * t = i\n        // t = (i - ro.x) / rd.x\n        \n        vec2 T = ( step(0.0, rd) + sign(rd) * i - fract(ro) ) / rd;\n\n        // Intersecting vertical grid lines, going in horizontal (x) direction\n        vec2 p = rd * T.x + ro;\n        \n        alpha = smoothstep(ps, -ps, length(uv - p) - 0.1);\n        color = mix(color, vec3(0), alpha);\n        alpha = smoothstep(ps, -ps, length(uv - p) - 0.09);\n        color = mix(color, vec3(0,0.3, 0.7), alpha);\n\n        // Intersecting horizontal grid lines, going in vertical (y) direction\n        p = rd * T.y + ro; \n        \n        alpha = smoothstep(ps, -ps, length(uv - p) - 0.1);\n        color = mix(color, vec3(0), alpha);\n        alpha = smoothstep(ps, -ps, length(uv - p) - 0.09);\n        color = mix(color, vec3(0.7,0,0.3), alpha);\n    }\n    \n    \n    vec2 steps = vec2(0);\n    for(float i = 0.; i <= 10.; i++)\n    {\n        vec2 p = steps*sign(rd) + floor(ro);    // current cell id ( add +.5 for cell center )\n\n        if(floor(p) == grid_id) color += 0.05;  // Highlight current cell\n    \n        // Cell intersection times. Note that the only difference from the previous loop is using 'steps' instead of 'i'\n        // and how they are incremented.\n        vec2 T = ( step(0.0, rd) + sign(rd) * steps - fract(ro) ) / rd;  \n\n        //if(T.x < T.y) steps.x += 1.; else steps.y += 1.;\n        steps[int(T.x > T.y)] += 1.;\n    }\n    \n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}