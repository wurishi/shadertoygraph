{"ver":"0.1","info":{"id":"llV3zh","date":"1473282788","viewed":647,"name":"Montebox","username":"zackpudil","description":"Path tracing a mandelbox.  Sorry about your gpu.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["fractal","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    if(iFrame > 0) {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n        col = pow(col, vec3(1.0/2.2));\n    }\n    \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 res() { return iResolution.xy; }\n\nvec3 key = vec3(-0.2, 0.4, -3.0);\nfloat frame() { return  float(iFrame); }\n\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat de(vec3 p) {\n\tvec4 q = vec4(p, 1);\n    vec4 c = q;\n        \n    for(int i = 0; i < 10; i++) {\n        q.xyz = 2.0*clamp(q.xyz, -1.5, 1.5) - q.xyz;\n        q *= clamp(1.0/dot(q.xyz, q.xyz), 1.0, 1.0/0.15);\n        q = 3.0*q - c;\n\t}\n    \n    return length(q.xyz)/q.w;\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n    float res = -1.0;\n    float t = 0.001;\n    \n    for(int i = 0; i < 300; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.0001 || t >= mx) break;\n        t += d*0.25;\n    }\n    \n    if(t < mx) res = t;\n    return res;\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        de(p + h.xyy) - de(p - h.xyy),\n        de(p + h.yxy) - de(p - h.yxy),\n        de(p + h.yyx) - de(p - h.yyx)\n\t);\n    return normalize(n);\n}\n\nvec3 cone(float s) {\n    float a = 3.14159*hash(s + 12.23);\n    float b = 6.28238*hash(s + 83.34);\n    \n    return vec3(sin(a)*sin(b), sin(a)*cos(b), cos(a));\n}\n\nvec4 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = n*n;\n    \n    vec4 x = texture(s, p.zy);\n    vec4 y = texture(s, p.xz);\n    vec4 z = texture(s, p.xy);\n    \n    return (x*m.x + y*m.y + z*m.z)/(m.x + m.y + m.z);\n}\n\nvec3 render(vec3 ro, vec3 rd, float sa) {\n    vec3 col = vec3(0);\n    vec3 mat = vec3(1);\n    \n    vec3 oro = ro;\n    vec3 ord = rd;\n    \n    float idis = 0.0;\n    \n    for(float b = 0.0; b < 4.0; b++) {\n        rd = normalize(rd);\n        \n        float t = trace(ro, rd, 50.0);\n        if(t < 0.0) break;\n        \n        if(b == 0.0) idis = t;\n        \n        float se = sa + 24.*b + 39.34*frame();\n\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);\n\n        vec3 lig = normalize(key - pos);\n        float dis = length(key - pos);\n        \n        vec3 icol = vec3(0);\n\n        icol += clamp(dot(lig, nor), 0.0, 1.0)\n            *step(0.0, -trace(pos + nor*0.001, lig, dis));\n        \n        mat *= texcube(iChannel1, pos, nor).xyz;\n        \n        col += icol*mat;\n        \n        ro = pos;\n        if(hash(se) < 0.2) {\n        \trd = nor + cone(se);\n        } else {\n            rd = normalize(reflect(rd, nor)) + cone(se)*0.01;\n        }\n    }\n    \n    float acc = 0.0;\n    for(float i = 0.0; i < 5.0; i++) {\n        float t = idis*hash(sa + 12.23*i + 24.34*frame());\n        vec3 pos = oro + ord*t;\n        acc += 0.15*step(0.0, -trace(pos, normalize(key - pos), length(key - pos)));\n    }\n    \n    col += pow(acc, 6.0)*vec3(1.00, 0.95, 0.85);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sa = hash(dot(fragCoord, vec2(12.232, 73.232)) + 1232.0*frame());\n    vec2 of = -0.5 + vec2(hash(sa + 12.232), hash(sa + 93.34));\n    \n    vec2 p = (-res() + 2.0*(fragCoord + of))/res().y;\n    \n    vec3 ro = vec3(0.28, 0.0, -3.01);\n    vec3 rd = normalize(vec3(p.x, 1.97, p.y));\n    \n    vec3 col = vec3(0);\n    if(iFrame > 0) col = texture(iChannel0, fragCoord/res()).xyz;\n    \n    col += render(ro, rd, sa);\n    \n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}