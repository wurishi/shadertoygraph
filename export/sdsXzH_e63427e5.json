{"ver":"0.1","info":{"id":"sdsXzH","date":"1618901803","viewed":74,"name":"Sierpiński Carpet Threads","username":"adamjmurray","description":"Sierpiński Carpet with movement, this time zooming. \n\nSee also: https://www.shadertoy.com/view/sssSRj","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tiles"],"hasliked":0,"parentid":"7ssSzH","parentname":"Sierpiński Carpet (Basic)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool aa = true; // antialiased, disable for better performance\n\nvec3 palette(float idx) {\n    float i = mod(idx,4.);\n    if      (i < 1.) return vec3(0.80,0.78,0.99); \n    else if (i < 2.) return vec3(0.71,0.93,0.80);\n    else if (i < 3.) return vec3(0.99,0.93,0.65);  \n    else             return vec3(1.00,0.70,0.65); \n}\n\nvec3 draw(vec2 p, float start, float end, float iterations) \n{    \n    float iter = min(20., iterations);\n    float len = end - start;\n    float x = p.x - start;\n    float y = p.y - start;\n    float thresh = 0.005;\n    // for added fun:\n    // thresh = 0.3 + 0.25*-cos(iTime/5.);\n    \n    float pct = 0.;\n    float i;\n    for(i=0.; i<iter+1.; i++) {\n        len /= 3.;       \n        float xd = mod(x/len-1.,3.);\n        float yd = mod(y/len-1.,3.);\n        if (xd < 1. && yd < 1.) {\n            pct = (smoothstep(0.,thresh,xd) - smoothstep(1.-thresh,1.,xd))\n                * (smoothstep(0.,thresh,yd) - smoothstep(1.-thresh,1.,yd));\n            if (i>iter) {\n                pct *= (1.-(i-iter)); // fade in partial iterations\n            }\n            break;\n        }       \n    }\n    \n    vec3 color = palette(i);\n    // alternately, an algorithmic palette (needs some work):\n    // color = vec3(-cos(i)/3. + 0.34, -sin(i*3.)/2.+0.5, sin(i)/2.+0.5);\n    \n    return mix(vec3(0,0,0), color, pct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    float speed = 0.25;\n    float zRange = 0.92;\n    float zMin = 0.025;\n    float z = (1.+cos(iTime*speed))/2. * zRange + zMin;\n    // for testing formulas at the edges of the zoom range:\n    // z = zRange + zMin;\n    // z = zMin;\n    \n    float zoom = 5.*(pow(z,3.));\n    vec2 offset = vec2(0.5,0.3);\n    vec3 color = vec3(0,0,0);\n    float samples = 0.;\n    \n    float sampStart = 0.;\n    float sampEnd = 0.1;\n    if (aa) {\n        sampStart = -0.33;\n        sampEnd = 0.34;\n    }    \n    \n    for (float x=sampStart; x<sampEnd; x+=0.33) {\n        for (float y=sampStart; y<sampEnd; y+=0.33) {\n            vec2 p = (2.*(fragCoord + vec2(x,y)) - iResolution.xy)/iResolution.y; // [-1,1] vertically    \n            p *= zoom;\n            p += offset;\n            \n            // Aliasing is horrible when hard-coding iteration values > ~10 (depending on resolution)\n            // We need to adjust the iterations depending on the resolution, zoom factor, and antialias setting:\n            float iterations = 16.-(12.25+1000./(iResolution.x))*pow(z-zMin,0.25) - (aa ? 0. : 0.5);\n            \n            color += draw(p, -1., 1., iterations);\n            samples++;\n        }\n    }\n    \n    fragColor = vec4(color/samples,1);\n}","name":"Image","description":"","type":"image"}]}