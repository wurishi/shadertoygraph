{"ver":"0.1","info":{"id":"XtBGW1","date":"1428395549","viewed":196,"name":"Plain metaballs","username":"such","description":"https://en.wikipedia.org/wiki/Metaballs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define RM_MAX_ITER 40\n#define DISTANCE 4\n#define NBLOBf 3.\n\nconst float eps = 0.01;\n\nvec3 rand3(float co){\n    return fract(sin(co*vec3(12.9898,78.233,43.2311)) * 43758.5453);\n}\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat multisphere(in vec3 p)\n{\n    float x = cos(iTime);\n    \n    const float N = 2.;\n    float l = 0.;\n    float r = 0.3;\n    float r2 = 0.6 + 0.5*sin(1.12*iTime);\n    vec3 f = rand3(1.);\n    for (float i=1.; i<=NBLOBf; ++i)\n    {\n        vec3 q = sin(f*i*iTime);\n        q = (q - 0.5)*1.75;\n        l += 1./(sphere(p-q,r) + r2);\n        //l += 1./distance(p,q);\n    }\n    return 1./l - r2;\n    //return 1./l;\n}\n\nfloat scene(in vec3 p)\n{\n//    float s1 = sphere(p,0.3);\n//    float s2 = sphere(p+vec3(sin(iTime)*1.0,0.,0.),0.5);\n    // return sqrt(s1*s1 + s2*s2);\n//    return min(s1,s2);\n    //return (s1+s2)*0.5;\n    float s3 = multisphere(p);\n//    return min(s1,s3);\n    return s3;\n}\n\n// gradient normal\nvec3 getNormal(in vec3 p)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x = scene(p + ep.xyz) - scene(p - ep.xyz);\n    normal.y = scene(p + ep.yxz) - scene(p - ep.yxz);\n    normal.z = scene(p + ep.yzx) - scene(p - ep.yzx);\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy;    \n    \n    vec3 rayStart = vec3(0,0,DISTANCE);\n    vec3 rayDir = normalize(vec3(uv,-1));\n    \n    float a = 0.4*iTime;\n    float ca = cos(a);\n    float sa = sin(a);\n    rayStart = vec3(rayStart.z*sa + rayStart.x*ca, rayStart.y, rayStart.z*ca - rayStart.x*sa);\n    rayDir = vec3(rayDir.z*sa + rayDir.x*ca, rayDir.y, rayDir.z*ca - rayDir.x*sa);\n    \n    vec3 p;\n    float t = 0.0;\n    float dist;\n    for (int i=0; i<RM_MAX_ITER; ++i)\n    {\n        p = rayStart + rayDir*t;\n        dist = scene(p);\n\t\tt += dist;\n    }\n\n    vec3 finalColor = vec3(0,0,0);\n    vec3 normal = getNormal(p.xyz);\n    vec3 light1 = vec3(sin(iTime),cos(iTime),0);\n    vec3 light2 = vec3(0,0,-1);\n    float diffuse1 = 0.1+dot(light1,normal);\n    float diffuse2 = 0.1+dot(light2,normal);\n    float specular = pow(max(0.,dot(light1,normal)),21.);\n\n    float ambient = 0.5;\n    finalColor = vec3(1,0,1) *\n        (ambient + max(0.,0.5* diffuse1) + 0.5*diffuse2 + specular);\n\n    if (dist>eps)\n\t{\n    \tfinalColor = vec3(0,0,0);\n\t}\n    \n\tfragColor = vec4(finalColor, min(1.,max(0.,1.-dist) + length(finalColor)));\n    \n    fragColor = mix(vec4(pow(texture (iChannel0,fragCoord/iResolution.xy).r,21.)), fragColor, fragColor.a);\n}","name":"","description":"","type":"image"}]}