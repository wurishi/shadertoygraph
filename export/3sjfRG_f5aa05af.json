{"ver":"0.1","info":{"id":"3sjfRG","date":"1590359145","viewed":55,"name":"voxel-traversal-algorithm","username":"vizaxo","description":"voxel","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const bool[6*6] data = bool[](false, false, true, true, false, false,\n                              false, true, true, true, true, false,\n                              true, true, true, true, true, true,\n                              true, true, true, true, true, true,\n                              false, true, true, true, true, false,\n                              false, false, true, true, false, false);\n\nconst float pi = 3.141592;\nconst float tau = 2.0*pi;\n\n//#define TIME 0.5\n#define TIME iTime/2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cells = 50.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = uv * cells;\n    \n    vec2 offset = fract(p);\n    vec2 cell = floor(p);\n    vec2 ro = vec2(20, 20);\n    vec2 rd = normalize(vec2(sin(TIME), cos(TIME)));\n    \n    vec2 hyp = p - ro; //hypotenuse\n    float theta = acos(dot(hyp, rd) / length(hyp)); //angle between ray and p\n        \n    float d = length(hyp) * sin(theta);\n    \n    bool posT = theta <= tau/4.0 || theta > 3.0*tau/4.0;\n    float ray = posT ? 1.0-smoothstep(d, 0.00, 0.007) : 0.0;\n    \n    \n    \n    float phi = mod(atan(rd.y, rd.x), tau);//angle between ray and horizontal\n        //voxel intersection algorithm\n    float x = floor(ro.x);\n    float y = floor(ro.y);\n    float stepX = rd.x > 0.0 ? 1.0 : -1.0;\n    float stepY = rd.y > 0.0 ? 1.0 : -1.0;\n    \n    float tMaxX, tMaxY;\n    if (phi < tau/4.0 || phi >= 3.0*tau/4.0)\n    \ttMaxX = (1.0 - fract(ro.x)) / cos(phi);\n\telse\n        tMaxX = fract(ro.x) / cos(pi - phi);\n \n    if (phi < tau/2.0)\n    \ttMaxY = (1.0 - fract(ro.y)) / sin(phi);\n    else\n        tMaxY = fract(ro.y) / sin(tau - phi);\n\n    float tDeltaX = stepX * 1.0 / cos(phi);\n    float tDeltaY = stepY * 1.0 / sin(phi);\n        vec4 currentCell = vec4(0,0,0,0);\n\n    int maxTrace = 50;\n    if (cell == vec2(x,y)) currentCell += vec4(1.0 / float(maxTrace), 1.0 / float(maxTrace), 0, 0);\n\n    for (int i = 0; i < maxTrace-1; i++) {\n        if (tMaxX < tMaxY) {\n            tMaxX += tDeltaX;\n            x += stepX;\n        } else {\n            tMaxY += tDeltaY;\n            y += stepY;\n        }\n        if (cell == vec2(x,y)) currentCell += vec4(float(i+2) / float(maxTrace), float(i+2) / float(maxTrace), 0, 0);\n    }\n    \n    float t =tMaxY + 2.0*tDeltaY*stepY;\n    vec2 point = ro + t*rd;\n    \n    float target = smoothstep(0.1, 0.0, length(p-point));\n    \n    int index = int(cell.y*6.0 + cell.x );\n    bool inBounds =  cell.x < 6.0 && cell.y < 6.0;\n    \n    vec4 cellColor = inBounds ? (data[index] ? vec4(1, 0, 0, 0) : vec4(0,0,0,0)) : vec4(0,0,0,0);\n    \n    \n\n    //fragColor = cellColor + vec4(0, target, target, 0) + 0.7*(vec4(ray) + vec4(cell / cells, 0, 0));\n    fragColor = ray + currentCell + vec4(cell / cells, 0, 0);\n}","name":"Image","description":"","type":"image"}]}