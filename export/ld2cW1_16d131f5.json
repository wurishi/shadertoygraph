{"ver":"0.1","info":{"id":"ld2cW1","date":"1491969598","viewed":1025,"name":"Fourier Lighting Bumps","username":"slembcke","description":"Experimenting with using Fourier series for 2D lighting.\n\nBasically, it generates a per pixel diffuse light probe map stored using a Fourier series, similar to spherical harmonics. Using it, all lights can be applied to an object in a single pass.","likes":18,"published":1,"flags":0,"usePreview":1,"tags":["2d","fourierseries"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tForward rendering for 2D lighting doesn't seem like the best idea to me.\n\tIn particular, alpha blending means you can't reorder draw calls for better batching,\n\tand combined with a lack of z-testing it makes for a lot of overdraw.\n\n\tWhat if instead you could precalculate all the lighting, and look it up using the normal?\n\tThat's basically the idea here. You can bake a high quality lightprobe texture offline\n\tor render a realtime one in screen space.\n\n\tApplying the probe values should be pretty cheap, requiring only some basic arithmetic.\n\tHowever, it will require 6 texture samples per shaded pixel (1x albedo, 1x normal, 4x light).\n\tSeems like it shouldn't be worse than deferred, though that's not a low bar exactly.\n\t\n\tI also have an interactive MathStudio notebook I used to figure out some of the math.\n\thttp://mathstud.io/V9GLZ5\n*/\n\n// Fourier series coefficients for a diffuse light probe.\nstruct Probe {vec3 a0, a1, b1, a2, b2;};\n\n// Double angle identities for cos() and sin()\nvec2 DoubleAngle(vec2 n){\n\treturn vec2(n.x*n.x - n.y*n.y, 2.0*n.x*n.y);\n}\n\nvoid FourierAccum(vec3 delta, vec3 color, inout Probe probe){\n    vec3 direction = normalize(delta);\n    float dist_ratio = min(1.0, 0.1/length(delta.xy));\n    float dist_factor = sqrt(1.0 - dist_ratio*dist_ratio);\n    //if(delta.x > 0.0) dist_factor = 1.0;\n    \n    // Kinda mostly workable hack to approximate a light not on the xy plane.\n    // Should figure out a more accurate curve for this.\n    const float C0 = 0.318309886184; // 1/pi\n    probe.a0 += mix(C0, 1.0, direction.z)*color;\n    \n    float C1 = 0.3183 + 0.1817*dist_factor;\n    vec2 g1 = -C1*direction.xy;\n    probe.a1 += g1.x*color;\n    probe.b1 += g1.y*color;\n    \n    float C2 = 0.2122*dist_factor;\n    vec2 g2 = C2*DoubleAngle(-direction.xy);\n    probe.a2 += g2.x*color;\n    probe.b2 += g2.y*color;\n}\n\nvec3 FourierApply(vec3 n, Probe probe){\n    vec2 g1 = n.xy;\n    vec2 g2 = DoubleAngle(g1);\n    return probe.a0 + probe.a1*g1.xxx + probe.b1*g1.yyy + probe.a2*g2.xxx + probe.b2*g2.yyy;\n}\n\nvec3 SphereBumps(vec2 uv){\n    vec2 uv2 = 2.0*fract(10.0*uv) - 1.0;\n    float z = 1.0 - dot(uv2, uv2);\n\tvec3 n = vec3(uv2, z);\n    float mask = step(1.0, length(uv2));\n    return mix(n, vec3(0, 0, 1), mask);\n}\n\nvec2 TransformGradient(vec2 basis, float h){\n    vec2 m1 = dFdx(basis), m2 = dFdy(basis);\n    mat2 adjoint = mat2(m2.y, -m2.x, -m1.y, m1.x);\n\n    float eps = 1e-7; // Avoid divide by zero.\n    float det = m2.x*m1.y - m1.x*m2.y + eps;\n    return vec2(dFdx(h), dFdy(h))*adjoint/det;\n}\n\nvec3 BumpMap(vec2 uv, float height){\n    float value = height*texture(iChannel0, uv).r;\n    vec2 grad = TransformGradient(uv, value);\n    return vec3(grad, 1.0 - dot(grad, grad));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= 2.0;\n    \n    vec3 ambient = vec3(0.0, 0.0, 0.2);\n    Probe probe = Probe(ambient, vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    \n    // Spinning directional light at z=0\n    vec3 dir = vec3(cos(iTime), sin(iTime), 0.0);\n    FourierAccum(dir, vec3(0.0, 0.4, 0.2), probe);\n\t\n    // Mouse controlled light at z=0.2\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x *= 2.0;\n    vec2 delta = uv - mouse;\n    vec3 dirMouse = vec3(delta, 0.1);\n    vec3 colorMouse = vec3(1, 1, 1)*max(0.0, 0.7 - length(delta)/2.75);\n    FourierAccum(dirMouse, colorMouse, probe);\n    \n    // Generate some fun normals to use to light stuff up.\n//    vec3 n = SphereBumps(uv);\n\tvec3 n = BumpMap(uv, 0.1);\n//    fragColor = vec4(0.5*n + 0.5, 1.0); return;\n\n    // The magic!\n    // Calculate the lighting for the current pixel based on the normal\n    // and Fourier series approximation.\n    fragColor.rgb = FourierApply(n, probe).rgb;\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}