{"ver":"0.1","info":{"id":"tdtSD8","date":"1571918313","viewed":156,"name":"Hilbert's curve.","username":"Anskiere","description":"-","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","curve","hilbert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int getCellNumber(vec2 uv, int steps, out int pos,out int neg)\n{\n    int n = 0;\n    int r = 0;\n    bool inv = false;\n\n    //   0\n    // 1   3\n    //   2\n\n    pos = 3;\n    neg = 1;\n\n    for (int i = 0; i < steps; i++)\n    {\n        bvec2 c = bvec2(uv.x >= 0., uv.y >= 0.);\n\n        int ln = 0;\n\n        uv = fract(uv)*2.-1.;\n\n        // rotate bottom cells\n        uv = c.y ? uv :\n        rot90(uv * float(c.x ? 1 : -1));\n\n        // local indices:\n        // 1 2\n        // 0 3\n        ln = c.y ? (c.x ? 2 : 1) : (c.x ? 3 : 0);\n\n        pos = ln == 3 ? \n            pos : \n        \tpos = -r + (inv ? ln : -ln);\n\n        neg = ln == 0 ?\n            neg :\n        \tneg = 3 + r + (inv ? ln : -ln);\n\n        uv.x = c.y ? uv.x : -uv.x;\n        r += c.y ? 0 : (c.x ? -1 : 1)*(inv?-1:1);\n        inv = c.y ? inv : !inv;\n\n        n = 4*n + ln;\n    }\n\n    pos = modi(pos, 4);\n    neg = modi(neg, 4);\n\n    return n;\n}\n\nvec2 getLocalUV(vec2 luv, ivec2 posd, ivec2 negd)\n{\n    int p =  doti(posd, negd);\n\n    vec2 puv;\n\n    if (p == -1)\n    {\n        float x = dot(luv, vec2(posd));\n        float y = dot(luv, vec2(rot90(posd)));\n\n        puv = fract(vec2(x,y));\n        puv.y -= .5;\n    }\n    else if (p == 0)\n    {\n        vec2 corner = vec2(posd+negd)*.5+.5;\n        vec2 delta = luv - corner;\n        float ld = length(delta);\n\n        float x =\n            acos(dot(delta,-vec2(posd))/ld);\n        x /= (pi / 2.);\n\n        float y = ld;\n        y -= .5;\n\n        //part of cross product to determinate\n        //the order of pos/neg vectors\n        int zz = posd.x*negd.y-posd.y*negd.x;\n        y = zz < 0 ? -y : y;\n\n        puv = vec2(x , y);\n    }\n\n    return puv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int maxSteps = 7;\n    int steps = int(floor(fract(iTime * 0.15) * float(maxSteps)));\n    \n    if (iMouse.z > 0.)\n    {\n        steps = int(floor(iMouse.x / iResolution.x * 8.));\n    }\n    \n    vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy);\n    uv /= iResolution.y;\n\n    uv *= 2.01;\n\n    vec2 tuv = uv * .5 + .5;\n    float size = exp2(-float(steps));\n    vec2 luv = fract(tuv / size);\n\n    int posRot;\n    int negRot;\n    int n = getCellNumber(uv, steps, posRot, negRot);\n    \n    ivec2\n        posd = rot90ccw(ivec2(0,1), posRot),\n        negd = rot90ccw(ivec2(0,1), negRot);\n\n    vec2 puv = getLocalUV(luv, posd, negd);\n    \n    vec2 guv = vec2(puv.x + float(n), puv.y);\n\n    vec3 col = texture(iChannel0,\n                       vec2(guv.x*0.5-iTime*.1, pow(abs(guv.y)*2., 1.7)/2.-0.5)).rgb;\n\n    col *= smoothstep(.25, .2, abs(guv.y));\n    col = pow(col, vec3(.7));\n    fragColor = vec4(col, 0);\n\n    fragColor *= float(all(bvec2(1.-step(1., abs(uv)))));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ROTATE_TEMPLATE(type) type rot90(type uv) { return type(uv.y, -uv.x); }\n#define fori(n) for (int i = 0; i < n; i++)\n\nROTATE_TEMPLATE(vec2)\nROTATE_TEMPLATE(ivec2)\n\nvec2 rot(vec2 uv, float a)\n{\n    float ca = cos(a), sa = sin(a);\n    mat2 m = mat2(ca, sa, -sa, ca);\n    \n    return uv * m;\n}\n\nint doti(ivec2 a, ivec2 b)\n{\n    return a.x*b.x + a.y*b.y;\n}\n\nconst float pi = 3.145926;\n\nint modi(int x, int b)\n{\n    return int( mod(float(x), float(b)));\n}\n    \nivec2 rot90(ivec2 uv, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        uv = rot90(uv);\n    }\n\n    return uv;\n}\n\nivec2 rot90ccw(ivec2 uv, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        uv = rot90(-uv);\n    }\n\n    return uv;\n}","name":"Common","description":"","type":"common"}]}