{"ver":"0.1","info":{"id":"MXXBDj","date":"1731330525","viewed":50,"name":"3D-scene (practice)","username":"ArtemDvornikov","description":"3D-scene (practice)","likes":0,"published":1,"flags":48,"usePreview":1,"tags":["3dscenepractice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nvec3 tankTowerPosition = vec3(0.0, 0.2, 1); // x, y, z\nvec3 tankMuzzlePosition = vec3(0, 0.3, 0.3); // x, y, z\nvec3 tankMuzzleDirection = vec3(0.0);\nfloat tankTowerRotationY = 0.0;\nfloat tankTowerRotationX = 0.0;\n\nbool isFired = false;\nfloat lastFiredTime = -1.0;\n\nvec3 shellPosition;  // Позиция снаряда\nfloat shellVelocity = 1.0; // Скорость снаряда\n\nvec3 floorColor = vec3(0.0);\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdTorus( vec3 p, vec2 t, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform; // apply transformation matrix\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float d = length(q)-t.y;\n  return Surface(d, col);\n}\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform; // apply transformation matrix\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdRoundBox( vec3 p, vec3 b, float r, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform; // apply transformation matrix\n  vec3 q = abs(p) - b + r;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  return Surface(d, col);\n}\n\nSurface sdLink( vec3 p, float le, float r1, float r2, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform; // apply transformation matrix\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  float d = length(vec2(length(q.xy)-r1,q.z)) - r2;\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 0.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 1.0)) * vec3(0.1, 0.5, 0.1);\n  Surface co = sdFloor(p, floorColor);\n  \n  //tank 1\n  co = minWithColor(co, sdRoundBox(p, vec3(0.3, 0.2, 0.5), 0.05, vec3(0, 0, 1), vec3(0.5, 0.6, 0.2), identity()));\n  co = minWithColor(co, sdLink(p, 0.4, 0.09, 0.015, vec3(-0.29, 0.1, 1.02), vec3(0.5, 0.5, 0.5), rotateX(1.57)*rotateY(1.57)));\n  co = minWithColor(co, sdLink(p, 0.4, 0.09, 0.015, vec3(0.29, 0.1, 1.02), vec3(0.5, 0.5, 0.5), rotateX(1.57)*rotateY(1.57)));\n  //co = minWithColor(co, sdRoundBox(p, vec3(0.1, 0.05, 0.1), 0.08, vec3(-0.3, 0.1, 1.4), vec3(0.5, 0.5, 0.5), rotateZ(30.0)));\n  co = minWithColor(co, sdRoundBox(p, vec3(0.2, 0.2, 0.2), 0.05, tankTowerPosition, vec3(0.3, 0.4, 0.0), rotateY(sin(tankTowerRotationY))*rotateX(sin(tankTowerRotationX))));\n  co = minWithColor(co, sdRoundBox(p, vec3(0.03, 0.03, 0.5), 0.05, tankTowerPosition + tankMuzzleDirection, vec3(0.3, 0.4, 0.0), rotateY(sin(tankTowerRotationY))*rotateX(sin(tankTowerRotationX))));\n  \n  if (isFired) {\n      co = minWithColor(co, sdBox(p,\n                                  vec3(0.05),\n                                  //tankTowerPosition + tankMuzzleDirection * iTime,\n                                  //tankTowerPosition + tankMuzzleDirection * iTime,\n                                  shellPosition,\n                                  vec3(0.5, 0.5, 0.5),\n                                  identity()));\n  }\n  \n  vec3 secondTankOffset = vec3(5.0, 0.0, -9.0);\n  vec3 tank2MuzzleDirection = vec3(0.0, 0.1, 0.2);\n  \n  //tank 2\n  co = minWithColor(co, sdRoundBox(p, vec3(0.3, 0.2, 0.5), 0.05, vec3(0, 0, 1) + secondTankOffset, vec3(0.5, 0.6, 0.2), identity()));\n  co = minWithColor(co, sdLink(p, 0.4, 0.09, 0.015, vec3(-0.29, 0.1, 1.02) + secondTankOffset, vec3(0.5, 0.5, 0.5), rotateX(1.57)*rotateY(1.57)));\n  co = minWithColor(co, sdLink(p, 0.4, 0.09, 0.015, vec3(0.29, 0.1, 1.02) + secondTankOffset, vec3(0.5, 0.5, 0.5), rotateX(1.57)*rotateY(1.57)));\n  co = minWithColor(co, sdRoundBox(p, vec3(0.2, 0.2, 0.2), 0.05, tankTowerPosition + secondTankOffset, vec3(0.3, 0.4, 0.0), identity()));\n  co = minWithColor(co, sdRoundBox(p, vec3(0.03, 0.03, 0.5), 0.05, tankTowerPosition + tank2MuzzleDirection + secondTankOffset, vec3(0.3, 0.4, 0.0), identity()));\n  \n  \n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n  \n  tankTowerRotationX = texture(iChannel1, vec2(0, 0)).w;\n  tankTowerRotationY = texture(iChannel1, vec2(0, 0)).z;\n  isFired = bool(int(texelFetch(iChannel1, ivec2(0, 0), 0).y));\n  tankMuzzleDirection = tankMuzzlePosition - tankTowerPosition;\n  tankMuzzleDirection *= rotateY(-sin(tankTowerRotationY)) * rotateX(-sin(tankTowerRotationX));\n  \n  shellPosition = texelFetch(iChannel1, ivec2(0, 1), 0).xyz;\n  \n  vec2 uv2 = uv;\n  uv2.x *= 3.5;\n  uv2.y *= 9.5;\n  //uv2*=mat2(cos(iTime * 0.5), -sin(iTime * 0.5), sin(iTime * 0.5), cos(iTime * 0.5));\n  floorColor = texture(iChannel0, uv2).xyz * vec3(0.1, 0.6, 0.1);  \n  \n  vec3 col = vec3(0);\n  \n  vec3 lp = tankTowerPosition + vec3(0.0, 0.0, 0.0); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 3, 2.5); // ray origin that represents camera position\n  \n  \n  float cameraRadius = 1.7;\n  ro.x = cameraRadius * -sin(tankTowerRotationY) + lp.x; // convert x-component to polar and add offset\n  ro.y = cameraRadius * sin(tankTowerRotationX) + 4.0*lp.y;\n  //ro.z = cameraRadius * -sin(tankTowerRotationX) + lp.z; // convert z-component to polar and add offset\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n  \n  //vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  rd *= rotateX(-0.05); ////\n  //rd *= rotateY(0.7);\n  //ro *= rotateY(sin(tankTowerRotation));\n  //rd *= rotateY(sin(tankTowerRotation));\n  //rd *= rotateY(sin(iTime) * 0.5);\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 1);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n  \n  if (isFired) {\n      //col = vec3(1.0, 0.0, 0.0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 gravity = 1.0 * vec3(0.0, -9.81, 0.0); // Ускорение свободного падения (м/с^2)\nfloat initialVelocity = 35.0;  // Начальная скорость снаряда (м/с)\n\nfloat tankTowerRotationX = 0.0;\nfloat tankTowerRotationY = 0.0;\nconst float tankTowerRotationVelocity = 0.001;\nvec3 secondTankOffset = vec3(5.0, 0.0, -9.0);\n\nbool isFired = false;\nfloat lastFiredTime = 0.0;\n\nvec3 shellPosition = vec3(-0.5, 0.1, 1.0);  // Позиция снаряда\n\nvec3 tankTowerPosition = vec3(0.0, 0.2, 1); // x, y, z\nvec3 tankMuzzlePosition = vec3(0, 0.3, 0.3); // x, y, z\nvec3 tankMuzzleDirection = vec3(0.0);\nvec3 currentTankMuzzleDirection = vec3(0.0);\nvec3 shellVelocity = vec3(0.0); // Начальная скорость снаряда\n\nconst int keyA = 65;\nconst int keyD = 68;\nconst int keyS = 83;\nconst int keyW = 87;\nconst int keySpace = 32;\n\nvec2 inputKeyboard(float tankTowerRotationX, float tankTowerRotationY) {\n\n    float left = texelFetch(iChannel1, ivec2(keyA, 0), 0).x * -1.0;\n    float right = texelFetch(iChannel1, ivec2(keyD, 0), 0).x * 1.0;\n\n    float newOffsetX = tankTowerRotationX + (left + right) * tankTowerRotationVelocity;\n    \n    float up = texelFetch(iChannel1, ivec2(keyW, 0), 0).x * -1.0;\n    float down = texelFetch(iChannel1, ivec2(keyS, 0), 0).x * 1.0;\n\n    float newOffsetY = tankTowerRotationY + (up + down) * tankTowerRotationVelocity;\n    \n    return vec2(newOffsetX, newOffsetY);\n}\n\nbool isTankFired() {\n    \n    float space = texelFetch(iChannel1, ivec2(keySpace, 0), 0).x;\n    \n    if (space == 0.0)\n        return false;\n    \n    return true;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    if (iFrame != 0) {\n        tankTowerRotationX = texture(iChannel0, vec2(0, 0)).z;\n        tankTowerRotationY = texture(iChannel0, vec2(0, 0)).w;\n        isFired = bool(int(texelFetch(iChannel0, ivec2(0, 0), 0).y));\n        lastFiredTime = float(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n        \n        shellPosition = texelFetch(iChannel0, ivec2(0, 1), 0).xyz;\n        shellVelocity = texelFetch(iChannel0, ivec2(0, 3), 0).xyz;\n        currentTankMuzzleDirection = texelFetch(iChannel0, ivec2(0, 2), 0).xyz;\n    }\n    \n    tankTowerRotationX = clamp(inputKeyboard(tankTowerRotationX, tankTowerRotationY).x, -0.9, 0.9);\n    tankTowerRotationY = clamp(inputKeyboard(tankTowerRotationX, tankTowerRotationY).y, -0.2, 0.1);\n    \n    \n    /*if (int(fragCoord.x) == 0 && int(fragCoord.y) == 1) {\n        if (isTankFired() && isFired == false) {\n            if (currentTankMuzzleDirection == vec3(0.0)) {\n                currentTankMuzzleDirection = tankMuzzlePosition - tankTowerPosition;\n            }\n            if (lastFiredTime == 0.0)\n                lastFiredTime = iTime;\n            //shellPosition = currentTankMuzzleDirection + vec3(0.0, 0.2, 0.0) * (iTime-lastFiredTime);\n            shellPosition = tankTowerPosition + currentTankMuzzleDirection * (iTime-lastFiredTime);\n            //shellPosition = vec3(0.0, 1.0, -3.0);\n            isFired = true;\n        }\n        else if (isFired == true && shellPosition.z < -10.0) {\n            isFired = false;\n        }\n    }*/\n    \n    //if (int(fragCoord.x) == 0 && int(fragCoord.y) == 1) {\n        if (isTankFired() && !isFired) {\n            // Вычисляем начальное направление движения снаряда\n            currentTankMuzzleDirection = normalize(tankMuzzlePosition - tankTowerPosition);\n            currentTankMuzzleDirection *= rotateY(-sin(tankTowerRotationX)) * rotateX(-sin(tankTowerRotationY));\n            \n            // Вычисляем начальную скорость снаряда по направлению башни\n            //shellVelocity = currentTankMuzzleDirection * initialVelocity;\n            shellVelocity = initialVelocity * normalize( (vec3(0, 0, 1) + secondTankOffset) - vec3(0, 0, 1) );\n            \n            \n            lastFiredTime = iTime;  // Запоминаем время выстрела\n            shellPosition = tankTowerPosition + currentTankMuzzleDirection;  // Устанавливаем начальную позицию снаряда\n            isFired = true;\n        }\n        \n        // Если снаряд был выпущен, обновляем его позицию\n        if (isFired) {\n            float flightTime = iTimeDelta;  // Время полёта\n            \n            \n            //shellVelocity = initialVelocity * normalize(tankTowerPosition + secondTankOffset - shellVelocity);\n            \n            // Уравнение движения с учётом гравитации: x = x0 + v0 * t + 0.5 * a * t^2\n            shellPosition += shellVelocity * flightTime;\n            shellVelocity += (gravity * flightTime);  // Обновляем скорость под действием гравитации\n\n            \n\n            // Останавливаем снаряд, если он достиг земли\n            if (shellPosition.y < 0.0 || shellPosition.y > 15.0 || shellPosition.z < -15.0) {\n                isFired = false;\n                shellPosition.y = 0.0;  // Устанавливаем на поверхность земли\n            }\n    }\n        \n    //}\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0) {\n        fragColor = vec4(lastFiredTime, int(isFired), tankTowerRotationX, tankTowerRotationY);\n    }\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 2) {\n        fragColor = vec4(currentTankMuzzleDirection, 1.0);\n    }\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 1) {\n        fragColor = vec4(shellPosition, 1.0);\n    }\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 3) {\n        fragColor = vec4(shellVelocity, 1.0);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}