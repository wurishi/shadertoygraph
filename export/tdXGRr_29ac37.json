{"ver":"0.1","info":{"id":"tdXGRr","date":"1554129685","viewed":166,"name":"City Diffusion","username":"arthursw","description":"A small city generator","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["diffusion","buffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 t = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n   // float w = 0.1*t.w;// 0.5+0.5*sin(2.90*t.w);\n    //fragColor = vec4(t.x*0.76, t.x*0.4+w*0.95, t.x+w*0.97, 1.0);\n    float pw = pow(t.w, 6.0);\n    fragColor = vec4(t.xxx + vec3(pw)*vec3(0.3, 0.2, 0.7), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Arthur Masson, after \"Conway's Game of Life\" from the great inigo quilez - iq/2016\n// License Creative Commons Attribution-ShareAlike 3.0 (The Game of Life of Inigo Quilez is Non Commercial)\n\n\n// Conway's Game of Life - https://iquilezles.org/articles/gameoflife\n\n#define VARIANT 0\n#define PI 3.1416\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nfloat hash2( vec2 n, float a, float b )\n{\n    return abs(hash1(n.x*a+hash1(n.y*b)));\n}\n\nfloat hashi2( ivec2 n, float a, float b )\n{\n    return hash2(vec2(n), a, b);\n}\n\nvec4 Cell( in ivec2 p , ivec2 d)\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+d+r) % r;\n\n    // fetch texel\n    return texelFetch(iChannel0, p, 0 );\n}\n\nvec4 IsNeighbourComing( in ivec2 p , ivec2 d, bool couldBeEmitting, bool couldChangeDirection)\n{\n    vec4 c = Cell(p, d);\n    \n    bool isComing = c.x > 0.9 && d.x == int(c.y) && d.y == int(c.z);\n    \n    float rand = hashi2(p, 13.43, 16.31);\n    \n    bool isEmitting = !isComing && c.x > 0.9 && couldBeEmitting;\n    float w = 0.25+rand;//0.75+0.5*sin(rand*iTime*2.0*PI/0.10);\n    if(isComing) {\n        bool changeDirection = couldChangeDirection;//hashi2(p, 43.03, 42.34) > 0.99;\n        float dx = c.y;\n        float dy = c.z;\n        if(changeDirection) {\n            dx = rand > 0.5 ? c.z : -c.z;\n            dy = rand > 0.5 ? c.y : -c.y;\n            \n        }\n        return vec4(c.x, dx, dy, w);\n    } else if (isEmitting) {\n    \treturn vec4(1.0, d.x, d.y, w);\n    } else {\n        return vec4(0.0, c.yzw);\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    vec4 current = Cell(px,ivec2(0, 0));\n    \n    vec4 k = vec4(0.0);\n    \n    float radius = 100.0;\n    float lm = length(iMouse.xy - vec2(px));\n    \n    if(lm > radius) {\n        \n        if(current.x > 0.9) {\n            k = current;\n        } else {\n            //float pulse = 0.5 + 0.5 * sin(iTime*0.10*2.0*3.1416);\n            float emittingProbability = 0.8 + pow(10.0, -2.0 + 2.0 * iMouse.x / iResolution.x);\n            float changeDirectionProbability = 0.8 + pow(10.0, -3.0 + 3.0 * iMouse.y / iResolution.y);\n\t\t\tbool couldBeEmitting = hashi2(px, 87.03, 123.34) > emittingProbability;\n\t\t\tbool couldChangeDirection = hashi2(px, 43.03, 42.34) > changeDirectionProbability;\n            vec4 kym1 = IsNeighbourComing(px,ivec2(0,-1), couldBeEmitting, couldChangeDirection);\n            vec4 kxm1 = IsNeighbourComing(px,ivec2(-1, 0), couldBeEmitting, couldChangeDirection);\n            vec4 kxp1 = IsNeighbourComing(px,ivec2(1, 0), couldBeEmitting, couldChangeDirection);\n            vec4 kyp1 = IsNeighbourComing(px,ivec2(0, 1), couldBeEmitting, couldChangeDirection);\n\n            k = kym1.x > 0.9 ? kym1 : kym1.w > 0.01 ? kym1 : k;\n\n            k = kxm1.x > 0.9 ? kxm1 : kxm1.w > 0.01 && k.x < 0.01 && kxm1.w > k.w ? kxm1 : k;\n            k = kxp1.x > 0.9 ? kxp1 : kxp1.w > 0.01 && k.x < 0.01 && kxp1.w > k.w ? kxp1 : k;\n            k = kyp1.x > 0.9 ? kyp1 : kyp1.w > 0.01 && k.x < 0.01 && kyp1.w > k.w ? kyp1 : k;\n\n            /*\n            k = kxm1.x > 0.9 ? kxm1 : kxm1.w > 0.01 && k.x < 0.01 ? kxm1 : k;\n            k = kxp1.x > 0.9 ? kxp1 : kxp1.w > 0.01 && k.x < 0.01 ? kxp1 : k;\n            k = kyp1.x > 0.9 ? kyp1 : kyp1.w > 0.01 && k.x < 0.01  ? kyp1 : k;\n            */\n\n            // k.w *= 0.999;//hash2(fragCoord, 21.43, 23.2);\n            //float pulse = 0.95+0.05*sin(iTime*2.0*PI/3.40);\n            bool pulse = sign(mod(iTime, 5.40)-0.1) > 0.0;\n            k.w *= pulse ? 0.999 : 0.0; //+ pow(10.0, -5.0 + 2.1 * pulse);\n            \n            float change = hash2(fragCoord, 11.43, 14.31);\n            k.w *= 0.994 + 0.006 * change;\n            \n            if( iFrame==0 ) {\n                k.x = step(0.999, hash2(fragCoord, 2.43, 43.2));\n\n                float rand = hash2(fragCoord, 23.43, 6.31);\n                k.y = rand > 0.75 ? 1.0 : rand > 0.5 ? 0.0 : rand > 0.25 ? -1.0 : 0.0;\n                k.z = rand > 0.75 ? 0.0 : rand > 0.5 ? 1.0 : rand > 0.25 ? 0.0 : -1.0;\n            }\n        }\n    }\n\tfragColor = k;\n}","name":"Buffer A","description":"","type":"buffer"}]}