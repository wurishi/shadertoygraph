{"ver":"0.1","info":{"id":"wts3Df","date":"1680968393","viewed":59,"name":"workshop fuz say supair","username":"zerkman","description":"exercice pour lâ€™atelier shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// alt+enter pour compiler\n// references -> shaderific.com\n// fct distance https://iquilezles.org/articles/distfunctions\n\nmat2 rotation(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\nmat3 rotzyx(float x, float y, float z) {\n    float c,s;\n    mat3 m;\n    c = cos(x);\n    s = sin(x);\n    m = mat3(1,0,0,0,c,s,0,-s,c);\n    c = cos(y);\n    s = sin(y);\n    m = mat3(c,0,-s,0,1,0,s,0,c)*m;\n    c = cos(z);\n    s = sin(z);\n    m = mat3(c,s,0,-s,c,0,0,0,1)*m;\n    return m;\n}\n\nfloat sphere(vec3 pos,float radius) {\n    return length(pos)-radius;\n}\n\nfloat box(vec3 pos,float radius) {\n    pos = abs(pos);\n    return max(pos.x,max(pos.y,pos.z))-radius;\n}\n\nfloat cylinder(vec3 pos,float radius) {\n    return length(pos.xy)-radius;\n}\n\nfloat map(vec3 pos) {\n    pos.xy *= rotation(pos.z*.06);\n \tpos.z += iTime*.5;\n    //pos.xz *= rotation(iTime*.01);\n    //pos.yz *= rotation(iTime*.05);\n    float size = 3.5;\n    pos = mod(pos,size)-size/2.;\n    float radius = .5;\n    //float geometry = 10000.;\n    float geometry = 0.;\n    geometry = max(geometry,box(rotzyx(iTime*.3,iTime*.3,iTime*.3)*pos,radius));\n    geometry = max(geometry,sphere(pos,radius*1.2));\n    //geometry = min(geometry,cylinder(pos,radius*.2));\n    //geometry = min(geometry,cylinder(pos.yzx,radius*.2));\n    //geometry = min(geometry,cylinder(pos.zxy,radius*.2));\n    return geometry;\n}\n\n// fragCoord (en pixels)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 position = fragCoord/iResolution.xy*2.-1.;\n    position.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 eye = vec3(0,0,-2);\n    vec3 ray = normalize(vec3(position,1.));\n    vec3 pos = eye;\n\tfloat shade = 0.0;\n    for\t(int index = 0; index < 20; ++index) {\n        float dist = map(pos);\n        if (dist < 0.001) {\n            shade = 1.0-float(index)/20.;\n            break;\n        }\n        pos += ray *dist;\n    }\n\n    // Output to screen\n    fragColor = vec4(shade);\n}\n","name":"Image","description":"","type":"image"}]}