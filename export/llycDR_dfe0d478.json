{"ver":"0.1","info":{"id":"llycDR","date":"1535716465","viewed":546,"name":"color blending: reality-check","username":"hornet","description":"Please squint :)\ntop to bottom: Blending in: RGB - RGB_gammacorrect - LCH\ninspired by http://eastfarthing.com/blog/2017-09-23-dithering/\nchecking the results of https://www.shadertoy.com/view/MljGDV","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["colorblending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://code.google.com/p/colorjizz/source/browse/#svn%2Ftrunk%2FC%23%2FColorJizz\n// https://github.com/THEjoezack/ColorMine/blob/master/ColorMine/ColorSpaces/Conversions/RgbConverter.cs\n\n#define SRGB_CORRECT\n\n//////////////////////////////\nvec3 rgb2xyz( vec3 rgb );\nvec3 xyz2lab( vec3 xyz );\nvec3 lab2lch( vec3 lab );\nvec3 rgb2lab( vec3 rgb );\nvec3 rgb2lch( vec3 rgb );\nvec3 lch2lab( vec3 lch );\nvec3 lab2xyz( vec3 lab );\nvec3 xyz2rgb( vec3 xyz );\nvec3 lab2rgb( vec3 lab );\nvec3 lch2rgb( vec3 lch );\nvec3 rgb2yuv(vec3 RGB);\nvec3 yuv2rgb(vec3 YUV);\nvec3 srgb2lin( vec3 c );\nvec3 lin2srgb( vec3 c );\n\n///////////////////\n\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\n//remaps inteval [a;b] to [0;1]\nfloat remap( float t, float a, float b )\n{\n\treturn clamp( (t - a) / (b - a), 0.0, 1.0 );\n}\n\n\nconst vec3 c0_lin = vec3(1.0, 0.0, 0.0 );\nconst vec3 c1_lin = vec3(0.0, 1.0, 0.0 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float bn = texelFetch( iChannel0, ivec2(fragCoord.xy)%ivec2(textureSize(iChannel0,0).xy), 0 ).x;\n\n    vec2 luv = vec2( uv.x, fract(3.0*uv.y) );\n    //fragColor = vec4( luv, 0, 1 ); return; \n\n    float t = remap( uv.x, 0.05, 0.4 );\n\t//fragColor = vec4( vec3(t), 1 ); return;\n\n    float co = remap( uv.x, 0.4, 1.0 );\n    co = co*0.75;\n    float co_quant = floor(co*4.0)/4.0 + 0.25;\n\n    if ( uv.x > 0.4 && luv.y > 0.5 )\n    {\n        //t = floor(co*4.0)/4.0 + 0.25;\n        t = co_quant;\n        //fragColor = vec4( vec3(t), 1 ); return;\n    }\n\n    if ( uv.x < 0.4 && luv.y <= 0.5 )\n    {\n        //note: dithered gradient on the left\n        fragColor.rgb = bn>t ? c0_lin : c1_lin;\n    }\n    else if ( uv.x >= 0.4 && luv.y <= 0.5 )\n    {\n        //note: 2x2 ordered dithering, ALU-based (omgthehorror)\n\t\t//vec2 ij = floor(mod( fragCoord.xy, vec2(2.0) ));\n\t\t//float idx = ij.x + 2.0*ij.y;\n\t\t//vec4 m = step( abs(vec4(idx)-vec4(0,1,2,3)), vec4(0.5) ) * vec4(0.75,0.25,0.00,0.50);\n\t\t//float d = m.x+m.y+m.z+m.w;\n        //\n        \n        float d = bn;\n       \n        vec3 c_lin = (d>=co_quant) ? c0_lin : c1_lin;\n        fragColor.rgb = lin2srgb(c_lin);\n\n    }\n\telse if ( uv.y > 2.0 / 3.0 )\n    {\n        //note: example of wrong interpolation in srgb space\n        //      without final conversion to monitor srgb too...\n        vec3 c0_srgb = lin2srgb( c0_lin );\n        vec3 c1_srgb = lin2srgb( c1_lin );\n        fragColor.rgb = mix( c0_srgb, c1_srgb, t ); //note: no conversion to monitor gamma\n    }\n    else if ( uv.y > 1.0 / 3.0 )\n    {\n        //note: correct interpolation in linear-space + conversion to monitor gamma\n        vec3 c0_lin = mix( c0_lin, c1_lin, t );\n        fragColor.rgb = lin2srgb( c0_lin );\n    }\n    else\n    {\n        //note: interpolation in lch-space\n        vec3 c0_lch = rgb2lch( c0_lin );\n        vec3 c1_lch = rgb2lch( c1_lin.rgb );\n        vec3 c_lch = mix( c0_lch, c1_lch, t );\n        vec3 c_srgb = lch2rgb( c_lch ); //note: conversion outputs srgb-space\n        fragColor.rgb = c_srgb;\n    }\n \n    fragColor.rgb *= step( 0.02, luv.y); //note: lines\n    \n    fragColor.rgb += (hash32n( uv ) + hash32n(uv+0.1337) - 1.0) / 255.0; //tripdf-dither before quantisation\n    fragColor.a = 1.0;\n}\n\n///////////////////////////////////////\n// Color-spaces\n// TODO: add ranges to each colorspace\n\nconst float PI = 3.14159265359; \n\nvec3 rgb2xyz( vec3 rgb )\n{\n\tfloat tmp_r = rgb.x;\n\tfloat tmp_g = rgb.y;\n\tfloat tmp_b = rgb.z;\n\tif (tmp_r > 0.04045)\n\t{\n\t\ttmp_r = pow((tmp_r + 0.055) / 1.055, 2.4);\n\t}\n\telse\n\t{\n\t\ttmp_r = tmp_r / 12.92;\n\t}\n\tif (tmp_g > 0.04045)\n\t{\n\t\ttmp_g = pow((tmp_g + 0.055) / 1.055, 2.4);\n\t}\n\telse\n\t{\n\t\ttmp_g = tmp_g / 12.92;\n\t}\n\tif (tmp_b > 0.04045)\n\t{\n\t\ttmp_b = pow((tmp_b + 0.055) / 1.055, 2.4);\n\t}\n\telse\n\t{\n\t\ttmp_b = tmp_b / 12.92;\n\t}\n\ttmp_r = tmp_r * 100.0;\n\ttmp_g = tmp_g * 100.0;\n\ttmp_b = tmp_b * 100.0;\n\tfloat x = tmp_r * 0.4124 + tmp_g * 0.3576 + tmp_b * 0.1805;\n\tfloat y = tmp_r * 0.2126 + tmp_g * 0.7152 + tmp_b * 0.0722;\n\tfloat z = tmp_r * 0.0193 + tmp_g * 0.1192 + tmp_b * 0.9505;\n\n\treturn vec3(x, y, z);\n}\n\n//TODO: faster? https://github.com/THEjoezack/ColorMine/blob/master/ColorMine/ColorSpaces/Conversions/LabConverter.cs\nvec3 xyz2lab( vec3 xyz )\n{\n\tconst float Xn = 95.047;\n\tconst float Yn = 100.000;\n\tconst float Zn = 108.883;\n\n\tfloat x = xyz.x / Xn;\n\tfloat y = xyz.y / Yn;\n\tfloat z = xyz.z / Zn;\n\n\tif (x > 0.008856)\n\t{\n\t\tx = pow(x, 1.0 / 3.0);\n\t}\n\telse\n\t{\n\t\tx = (7.787 * x) + (16.0 / 116.0);\n\t}\n\tif (y > 0.008856)\n\t{\n\t\ty = pow(y, 1.0 / 3.0);\n\t}\n\telse\n\t{\n\t\ty = (7.787 * y) + (16.0 / 116.0);\n\t}\n\tif (z > 0.008856)\n\t{\n\t\tz = pow(z, 1.0 / 3.0);\n\t}\n\telse\n\t{\n\t\tz = (7.787 * z) + (16.0 / 116.0);\n\t}\n\n\tfloat l;\n\tif (y > 0.008856)\n\t{\n\t\tl = (116.0 * y) - 16.0;\n\t}\n\telse\n\t{\n\t\tl = 903.3 * y;\n\t}\n\tfloat a = 500.0 * (x - y);\n\tfloat b = 200.0 * (y - z);\n\n\treturn vec3(l, a, b);\n}\n\nvec3 lab2lch( vec3 lab )\n{\n\t//float h = atan2(lab.z, lab.y);\n\tfloat h = atan(lab.z, lab.y);\n\n\tif ( h < 0.0 )\n\t{\n\t\th = 2.0*PI - abs(h);\n\t}\n\n\tif (h < 0.0)\n\t{\n\t\th += 2.0*PI;\n\t}\n\telse if ( h >= 2.0*PI )\n\t{\n\t\th -= 2.0*PI;\n\t}\n\n\tfloat l = lab.x;\n\tfloat c = sqrt( lab.y*lab.y + lab.z*lab.z );\n\n\treturn vec3(l, c, h);\n}\n\nvec3 rgb2lab( vec3 rgb )\n{\n\treturn xyz2lab( rgb2xyz( rgb ) );\n}\nvec3 rgb2lch( vec3 rgb )\n{\n\treturn lab2lch( rgb2lab( rgb ) );\n}\n\n\n////////////////////////////////////////////////\n\nvec3 lch2lab( vec3 lch )\n{\n\tfloat l = lch.x;\n\tfloat a = cos(lch.z) * lch.y;\n\tfloat b = sin(lch.z) * lch.y;\n\treturn vec3(l, a, b);\n}\n\nvec3 lab2xyz( vec3 lab )\n{\n\tconst float ref_X = 95.047;\n\tconst float ref_Y = 100.000;\n\tconst float ref_Z = 108.883;\n\n\tfloat var_Y = (lab.x + 16.0) / 116.0;\n\tfloat var_X = lab.y / 500.0 + var_Y;\n\tfloat var_Z = var_Y - lab.z / 200.0;\n\n\tif (pow(var_Y, 3.0) > 0.008856)\n\t{\n\t\tvar_Y = pow(var_Y, 3.0);\n\t}\n\telse\n\t{\n\t\tvar_Y = (var_Y - 16.0 / 116.0) / 7.787;\n\t}\n\tif (pow(var_X, 3.0) > 0.008856)\n\t{\n\t\tvar_X = pow(var_X, 3.0);\n\t}\n\telse\n\t{\n\t\tvar_X = (var_X - 16.0 / 116.0) / 7.787;\n\t}\n\tif (pow(var_Z, 3.0) > 0.008856)\n\t{\n\t\tvar_Z = pow(var_Z, 3.0);\n\t}\n\telse\n\t{\n\t\tvar_Z = (var_Z - 16.0 / 116.0) / 7.787;\n\t}\n\tfloat x = ref_X * var_X;\n\tfloat y = ref_Y * var_Y;\n\tfloat z = ref_Z * var_Z;\n\n\treturn vec3(x, y, z);\n}\n\nvec3 xyz2rgb( vec3 xyz )\n{\n\tfloat var_X = xyz.x / 100.0;\n\tfloat var_Y = xyz.y / 100.0;\n\tfloat var_Z = xyz.z / 100.0;\n\tfloat var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;\n\tfloat var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;\n\tfloat var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;\n\n\tif (var_R > 0.0031308)\n\t{\n\t\tvar_R = 1.055 * pow(var_R, 1.0 / 2.4) - 0.055;\n\t}\n\telse\n\t{\n\t\tvar_R = 12.92 * var_R;\n\t}\n\tif (var_G > 0.0031308)\n\t{\n\t\tvar_G = 1.055 * pow(var_G, 1.0 / 2.4) - 0.055;\n\t}\n\telse\n\t{\n\t\tvar_G = 12.92 * var_G;\n\t}\n\tif (var_B > 0.0031308)\n\t{\n\t\tvar_B = 1.055 * pow(var_B, 1.0 / 2.4) - 0.055;\n\t}\n\telse\n\t{\n\t\tvar_B = 12.92 * var_B;\n\t}\n\treturn vec3( var_R, var_G, var_B );\n}\n\nvec3 lab2rgb( vec3 lab )\n{\n\treturn xyz2rgb( lab2xyz( lab ) );\n}\n\nvec3 lch2rgb( vec3 lch )\n{\n\treturn lab2rgb( lch2lab( lch ) );\n}\n\n//note: ntsc, http://en.wikipedia.org/wiki/YUV\nvec3 rgb2yuv(vec3 RGB)\n{\n\tfloat y = dot( RGB, vec3( 0.299, 0.587, 0.114 ) );\n\tfloat u = dot( RGB, vec3( -0.14713, -0.28889, 0.436 ) );\n\tfloat v = dot( RGB, vec3( 0.615, -0.51499, -0.10001 ) );\n\treturn vec3(y,u,v);\n}\n\n//note: ntsc, http://en.wikipedia.org/wiki/YUV\nvec3 yuv2rgb(vec3 YUV)\n{\n\tfloat r = dot( YUV, vec3( 1, 0, 1.13983) );\n\tfloat g = dot( YUV, vec3( 1, -0.39465, -0.58060 ) );\n\tfloat b = dot( YUV, vec3( 1, 2.03211, 0 ));\n\treturn vec3( r, g, b );\n}\n\n#if defined( SRGB_CORRECT )\n// see http://www.opengl.org/registry/specs/ARB/framebuffer_sRGB.txt\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs / 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) / 1.055, vec3(2.4,2.4,2.4) );\n\treturn vec3( (cs.r<0.04045) ? c_lo.r : c_hi.r, \n                 (cs.g<0.04045) ? c_lo.g : c_hi.g, \n                 (cs.b<0.04045) ? c_lo.b : c_hi.b );\n\n}\nvec3 lin2srgb( vec3 cl )\n{\n\tcl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666,0.41666,0.41666)) - 0.055;\n\treturn vec3( (cl.r<0.0031308) ? c_lo.r : c_hi.r,\n                (cl.g<0.0031308) ? c_lo.g : c_hi.g,\n                (cl.b<0.0031308) ? c_lo.b : c_hi.b );\n}\n#else\nconst float gamma = 2.4;\nvec3 srgb2lin( vec3 c )\n{\n    return pow( c, vec3(gamma) );\n}\nvec3 lin2srgb( vec3 c )\n{\n    return pow( c, vec3(1.0 / gamma) );\n}\n#endif","name":"Image","description":"","type":"image"}]}