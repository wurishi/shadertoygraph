{"ver":"0.1","info":{"id":"wdBBDD","date":"1590062829","viewed":112,"name":"Glitch 2020-0521","username":"rn49","description":"glitch shader 01","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution iResolution\n#define time iTime\n#define PI 3.1415926535897932384626433832\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat random (float v) {\n    return random(vec2(v));\n}\n\nfloat remap(float a, float b, float c, float d, float x)\n{\n    return (x - a) / (b - a) * (d - c) + c;\n}\n\nfloat quantize(float a, float b)\n{\n    return floor(a * b) / b;\n}\n\nvec2 quantize(vec2 a, vec2 b)\n{\n    return floor(a * b) / b;\n}\n\nvec4 getColor(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / resolution.y;\n\n    // wave 1\n    float wave = sin(uv.y * PI * 2.0 * 6.5 + time * 1.0);\n    wave = remap(-1.0, 1.0, 0.8, 1.0, wave);\n\n    // wave 2\n    float wave2 = sin(uv.y * PI * 2.0 * 2.5 - time * 7.0);\n    wave2 = remap(-1.0, 1.0, 0.1, 1.0, wave2);\n\n    // compute glitch\n    float glitch_peak = sin(uv.y * PI * 2.0 * 500.0 - time * 4.0);\n    glitch_peak = abs(glitch_peak);\n    glitch_peak = smoothstep(0.3, 0.5, glitch_peak) \n        * smoothstep(0.5, 0.3, glitch_peak);\n    glitch_peak *= wave2;\n    glitch_peak *= 0.01;\n\n    // block noise small\n    float quat_N = mix(20.0, 160.0, 0.5 * sin(time * 4.0) + 0.5); \n    float noise_block_small = random(vec2(quantize(uv.y, quat_N)) - time * 123.0)\n        * (0.5 + 0.5 * sin(time * 32.0 * PI))\n        * (1.0 + smoothstep(0.45, 1.0, random(vec2(uv.y + time * 24.0))) * 1.5);\n\n    // UVずらし(タテ)\n    float noise_block_large_y = 0.0;\n    {\n        float noise = + random(vec2(quantize(uv.x + 4.0, 24.0)) - time * 21.0);\n        noise = smoothstep(0.97, 0.98, noise);;\n\n        noise_block_large_y += noise;\n    }\n    \n    // UVずらし(ヨコ)\n    float noise_block_large_x_slow = random(\n        // vec2(quantize(uv.y * 1.3 + 241.0, 8.0)) \n        vec2(quantize(uv.y * 1.3 + 241.0, 24.0)) \n            - quantize(time + 0.13, 8.0) * 9.0);\n    noise_block_large_x_slow = \n        -smoothstep(0.5, 1.0, noise_block_large_x_slow)\n        * random(quantize(time, 4.0)) * 2.0\n        ;\n\n    float noise_block_large_y_slow = random(vec2(quantize(uv.x * 1.3 + 4.0, 8.0)) - quantize(time, 8.0) * 21.0);\n    noise_block_large_y_slow = -smoothstep(0.95, 0.96, noise_block_large_y_slow);\n    noise_block_large_y_slow *= 3.0;\n    noise_block_large_y_slow *= random(vec2(quantize(time, 3.0)));\n\n    float noise_block_large_x = random(vec2(quantize(uv.y, 12.0)) - time * 23.0);\n    noise_block_large_x = smoothstep(0.95, 1.0, noise_block_large_x)\n        * (1.0 + smoothstep(0.65, 1.0, random(vec2(time * 4.0))) * 0.5)\n    ;\n\n    float glitch_sin = sin(uv.y * PI * 2.0 * 10.0 - time * 27.0);\n    glitch_sin *= smoothstep(0.8, 1.0, glitch_sin) * pow(random(time), 4.0);\n    glitch_sin *= pow(abs(sin(uv.y * PI * 2.0 * 500.0 - time * 27.0)), 64.0);\n    \n    // glitch\n    float glitch =\n        + glitch_sin * 0.03\n        + glitch_peak * 3.0\n        + noise_block_small * 0.005\n        + noise_block_large_x * 0.014\n        ;    \n\n    // gradient_radial\n    float gradient_radial = distance(vec2(0.5, 0.5), uv);\n    gradient_radial = min(1.0, gradient_radial);\n\n    // block noise (small)\n    #define BLOCK_SIZE_SMALL (vec2(4.0, 2.0) * mix(0.1, 1.0, random(time)))\n    float block_noise_small = smoothstep(\n            0.96, 1.0, \n            random(quantize(uv, resolution.xy / BLOCK_SIZE_SMALL) + random(quantize(time, 24.0)))\n        );\n    block_noise_small = pow(block_noise_small, 4.0);\n    block_noise_small = step(0.98, block_noise_small);\n    block_noise_small *= smoothstep(0.5, 1.0, random(quantize(time, 4.0)));\n    block_noise_small *= gradient_radial;\n    \n    // block noise (large)\n    #define BLOCK_SIZE_LARGE (vec2(4.0, 2.0) * 8.0 * mix(1.5, 2.0, random(time)))\n    float block_noise_large = smoothstep(\n            0.98, 1.0, \n            random(quantize(uv, resolution.xy / BLOCK_SIZE_LARGE) + random(quantize(time, 1.0)))\n        );\n    block_noise_large = step(0.99, block_noise_large) * smoothstep(0.5, 1.0, random(quantize(time, 4.0)));\n    \n    // scanline\n    float scanline = sin(uv.y * PI * 2.0 * 128.0 - time * 4.0);\n    scanline = abs(scanline);\n    scanline = smoothstep(0.2, 1.0, scanline);\n    scanline = remap(0.0, 1.0, 0.9, 1.0, scanline);\n\n    // UVずらし\n    uv.x += noise_block_large_x_slow * 0.005 + glitch;\n    uv.y += noise_block_large_y_slow * 0.005;\n\n    // 色収差(chromatic aberration)\n    #define COLOR_SHIFT_X (noise_block_large_x * 0.001)\n    #define COLOR_SHIFT_Y (noise_block_large_y * 0.012)\n    float r = getColor(uv + random(time + 32.1) * vec2(+COLOR_SHIFT_X, COLOR_SHIFT_Y)).r;\n    float g = getColor(uv).g;\n    float b = getColor(uv + random(time + 132.1) * vec2(-COLOR_SHIFT_X, -COLOR_SHIFT_Y)).b;\n\n    fragColor = \n     + vec4(vec3(r, g, b) * scanline * wave, 1.0) * 1.4\n     + block_noise_small\n     + block_noise_large \n     ;\n}","name":"Image","description":"","type":"image"}]}