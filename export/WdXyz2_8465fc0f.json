{"ver":"0.1","info":{"id":"WdXyz2","date":"1597805809","viewed":234,"name":"2D Light Distance Map","username":"elci","description":".","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["2d","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 RenderSDF( vec2 uv ){\n    float d = SDF(uv, iTime);\n    vec2 uvf = 0.5-abs(fract(uv)-0.5);\n\tvec3 col = vec3(0.4,0.5,0.7);\n\tcol = mix(vec3(1), col, step(0.0, d));\n\tcol -= 0.2 * abs(sin(d*20.0 + sign(d)));\n\tcol *= 1.0 - exp(-33.0*abs(d));\n\tcol += smoothstep(0.05,0.0,abs(d));\n    return vec4(col, 1.0);\n}\n\n\nfloat shadow( vec2 uv ){\n    const float q = 2.0;\n    float s = 3.0/iChannelResolution[0].y;\n    float v;\n\tvec2 o;\n\tfor( o.x = -q; o.x < q; o.x++ )\n\tfor( o.y = -q; o.y < q; o.y++ ){\n\t\tv += texture(iChannel1, uv+(o*s)).r;\n\t}\n    return v/(q*q*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if( gl_FragCoord.y < LightCount ){\n    \tfragColor = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n        return;\n    }\n    \n    vec2 uv = (gl_FragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n\tvec2 p = uv * 16.0;\n    vec3 col = RenderSDF(p).rgb;\n    \n    float hl = 0.0;\n    for( float i = 0.0; i < LightCount; i++ ){\n    \tvec3 L = GetLight(i, iTime);\n\t\tvec2 lr = L.xy-p; // light ray\n\t\tfloat d = length(lr); // light distance\n\t\thl += smoothstep(0.0, abs(d-0.03),0.001)*25.0;\n    }\n    \n    //float s = shadow( gl_FragCoord.xy/iResolution.xy );\n    float s = texture(iChannel1, gl_FragCoord.xy/iResolution.xy).r;\n    \n\tcol *= (vec3(0.5+s)); // apply shadows\n\tcol += hl;\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float TAU = 6.2831853071;\nconst float LightCount = 4.0;\n\nvec3 GetLight(float i, float t){\n    t *= 0.25;\n\treturn vec3(sin(t-i)*(1.0+i*3.0), cos(t-i)*(1.0+i*1.0), 25.0);\n}\n\nfloat CircleSD( in vec2 p, in float r ){\n    return length(p)-r;\n}\nfloat RectSD( in vec2 p, in vec2 r ){\n    p = abs(p)-r;\n    return length(max(vec2(0.0),p)) + min(0.0,max(p.x,p.y));\n}\nfloat CrossSD( in vec2 p, in float w ){\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5);\n}\nfloat NgramSD(in vec2 p, in float r, in float n, in float m){\n    float an = 3.141593/n;\n    float en = 3.141593/min(m,n);\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en));\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\nfloat ArcSD( in vec2 p, in float r, in float a ){\n    p.x = abs(p.x);\n\tvec2 av = vec2(sin(a),cos(a));\n    float k = (av.y*p.x>av.x*p.y) ? dot(p.xy,av) : length(p.xy);\n    return sqrt( dot(p,p) + r*r - 2.0*r*k );\n}\n\nmat2 Rotate( float a ){\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\nvec2 SpacedRepeatFi( in vec2 p, in vec2 c, in vec2 n ){\n    return p-c*clamp(round(p/c),-n,n);\n}\n\nfloat SDF(vec2 p, float t){\n    mat2 r = Rotate(t);\n    float d;\n\td = (CircleSD((p+vec2(4.0,0.0)), 1.5));\n\td = min(d, ArcSD((p+vec2(0.0,0.0))*r, 1.5, 2.5) );\n\td = min(d, NgramSD((p+vec2(-4.0,0.0)), 2.0, 5.0, 3.0) );\n\td = min(d, RectSD((p+vec2(-8.0,0.0)), vec2(1.0)) );\n\td = min(d, CrossSD((p+vec2(8.0,0.0))*r, 3.0) );\n\treturn d;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 1D light distance map\nfloat TraceLight( vec2 lp, vec2 rd, float r ){\n\tfloat s = 0.0;\n\tfor( uint i = 0u; i < 64u; i++ ){\n\t\tfloat d = SDF(lp + rd*s, iTime);\n\t\tif( d < 0.01 ) break; // hit something\n\t\ts += d*0.9;\n\t\tif( s > r ) break; // exceeded light range\n\t}\n\treturn s/r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat i = gl_FragCoord.y;\n    if( i > LightCount ){\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec3 L = GetLight(floor(i), iTime);\n    \n\tfloat angle = gl_FragCoord.x / (iResolution.x / TAU);\n\tvec2 rd = vec2(sin(angle), cos(angle));\n\t\n    // 4 rays slightly offset from the light point\n\tfragColor.r = TraceLight( L.xy - (rd.yx*0.02), rd, L.z );\n\tfragColor.g = TraceLight( L.xy + (rd.yx*0.02), rd, L.z );\n\tfragColor.b = TraceLight( L.xy - (rd.yx*0.05), rd, L.z );\n\tfragColor.a = TraceLight( L.xy + (rd.yx*0.05), rd, L.z );\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float shadow( vec2 p, vec3 L, float i ){\n\tvec2 lr = L.xy-p; // light ray\n    float r = L.z; // light radius\n\tfloat d = length(lr); // light distance\n\n\tvec2 LDMp = vec2( // Light Distance Map texture sample position\n\t\t(atan(lr.x, lr.y) / TAU) + 0.5, // angle to sample\n\t\t1.0/iChannelResolution[0].y * ((i)+0.5) // light index\n\t);\n\n\tvec4 t = texture(iChannel0, LDMp);\n\tt = smoothstep( 0.005, 0.0, (d/r)-t ); // our 4 shadow states\n\tfloat v = (t.x + t.y + t.z + t.w)*0.25; // combine them?\n\treturn v;\n}\n\nfloat softshadow( vec2 p, vec3 L, float i, float f ){\n\tconst float q = 2.0; // penumbra quality\n\n\tvec2 lr = L.xy-p; // light ray\n    vec2 rd = normalize(lr.yx); // ray direction (perpendicular to lr)\n\tvec2 rs = (rd*f) / float(q); // ray step\n\n\tfloat v = 0.0;\n\n\t// ray 1\n\tvec2 sp = p;\n\tfor( float j = 0.0; j < q; j++ ){\n\t\tfloat d = SDF(sp, iTime);\n\t\tv += shadow( sp, L, i ) * (1.0-(j/q));\n\t\tif( d < 0.1 ) break; // hit something\n\t\tsp += rs;\n\t}\n\t// ray 2\n\tsp = p;\n\tfor( float j = 1.0; j < q; j++ ){\n\t\tfloat d = SDF(sp, iTime);\n\t\tv += shadow( sp, L, i ) * (1.0-(j/q));\n\t\tif( d < 0.1 ) break; // hit something\n\t\tsp -= rs;\n\t}\n\n\tv *= (1.0/float(q));\n\treturn v;\n}\n\n// sample position, light index\nfloat smoothlight( vec2 p, vec3 L, float i ){\n\tvec2 lr = L.xy-p; // light ray\n\tfloat d = length(lr); // light distance\n    \n\tfloat f = pow(d/L.z, 0.4);\n\t//float v = softshadow( p, L, i, f );\n    float v = shadow(p, L, i);\n    \n\tv *= pow(smoothstep(L.z, 0.0, d),3.0); // smooth for distance\n    \n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (gl_FragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n\tvec2 p = uv * 16.0;\n\n\tfloat s; // shadow/lighting value\n    float hl = 0.0;\n    for( float i = 0.0; i < LightCount; i++ ){\n    \tvec3 L = GetLight(i, iTime);\n\t\ts += smoothlight(p, L, i);\n    }\n\n\t//s /= float(LightCount);\n    s /= 2.0;\n    \n\tfragColor.r = s;\n}","name":"Buffer B","description":"","type":"buffer"}]}