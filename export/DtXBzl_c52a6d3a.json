{"ver":"0.1","info":{"id":"DtXBzl","date":"1693394421","viewed":35,"name":"Raymarching Test - DiogoMJP","username":"DiogoMJP","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdf_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat get_distance(vec3 point) {\n    float displacement = sin(5.0*sin(iTime)*point.x) * sin(5.0*sin(2.0*iTime)*point.y) * cos(5.0*sin(1.5*iTime)*point.z) * 0.25;\n    float d_sphere = sdf_sphere(point, vec3(cos(2.0*iTime), cos(0.6*iTime), sin(3.0*iTime)), 1.0);\n    \n    return d_sphere + displacement;\n}\n\nvec3 get_normal(vec3 point)\n{\n    vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = get_distance(point + small_step.xyy) - get_distance(point - small_step.xyy);\n    float gradient_y = get_distance(point + small_step.yxy) - get_distance(point - small_step.yxy);\n    float gradient_z = get_distance(point + small_step.yyx) - get_distance(point - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 get_light_value(vec3 point, vec3 normal) {\n    vec3 light_1_pos = vec3(0.0, 3.0, 0.0);\n    vec3 light_1_col = vec3(1.0, 0.0, 0.0);\n    vec3 light_2_pos = vec3(0.0, -3.0, 0.0);\n    vec3 light_2_col = vec3(0.0, 0.0, 1.0);\n    vec3 ambient_light = vec3(0.4);\n    \n    vec3 light_dir_1 = normalize(light_1_pos - point);\n    vec3 light_dir_2 = normalize(light_2_pos - point);\n    \n    float light_v_1 = max(0.0, dot(normal, light_dir_1));\n    float light_v_2 = max(0.0, dot(normal, light_dir_2));\n    \n    return ambient_light + light_v_1*light_1_col + light_v_2*light_2_col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord / iResolution.xy) - 1.0;\n    \n    float v_angle = 3.14519/3.0;\n    float h_angle = (iResolution.x/iResolution.y) * v_angle;\n    \n    // Origin\n    vec3 origin = vec3(0, 0, -4.0);\n    \n    // Unit Directional Vector\n    v_angle = uv.y*(v_angle/2.0);\n    h_angle = -uv.x*(h_angle/2.0);\n    vec3 v = vec3(sin(h_angle), sin(v_angle), 1.0 - pow(sin(h_angle),2.0) - pow(sin(v_angle),2.0));\n    \n    vec3 point = origin;\n    float dist;\n    do {\n        point += get_distance(point)*v;\n        dist = get_distance(point);\n    } while (dist > 0.001 && dist < 20.0);\n    vec3 col;\n    if (dist < 0.001) {\n        vec3 normal = get_normal(point);\n        vec3 light_v = get_light_value(point, normal);\n        col = light_v*(vec3(0.4) + 0.6*normal);\n    } else {col = vec3(0.0, 0.0, 0.0);}\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}