{"ver":"0.1","info":{"id":"MddfD7","date":"1525553807","viewed":652,"name":"Cannon-Thurston for fig 8 knot","username":"henryseg","description":"Joint work with Dave Bachman. An approximation to the Cannon-Thurston map from the boundary circle of the universal cover of the fiber of the figure eight knot complement to the boundary of 3D hyperbolic space.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["fractal","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Joint work with Dave Bachman. \n// An approximation to the Cannon-Thurston map from the boundary circle of the \n// universal cover of the fiber of the figure eight knot complement to the \n// boundary of 3D hyperbolic space.\n\n// This is a view of a horizontal slice through the upper half space model \n// of three-dimensional hyperbolic space. The height varies with time from \n// 0.001 to 0.201. The pattern is made as follows: Each pixel is inside of \n// a tetrahedron of the lift of the triangulation of the figure eight knot\n// complement to H^3. We move it by elements of the fundamental group until\n// it is inside of the fundamental domain, which consists of two tetrahedra\n// with vertices (infinity, 0, 1, e^(i pi/6)), and (infinity, 0, 1, e^(-i pi/6)).\n// As we go, we track how many times we cross through the fiber. If the answer is\n// zero we colour the pixel grey (0.5,0.5,0.5). If the number of times we\n// cross through is positive then the pixel gets more white, and if it\n// is negative then the pixel gets more black. \n\n// The result is that as we decrease the height of the horizontal slice down\n// towards zero, the points coloured (0.5,0.5,0.5) form a better and better\n// approximation to the image of the Cannon-Thurston map, a sphere-filling curve.\n\n// Works interestingly with 3d \"Chromadepth\" glasses\n\nvec4 c2q(in vec2 a){\n    return vec4(a, 0.0, 0.0);\n}\nvec4 qonj(in vec4 q){\n    return vec4(q.x, -q.yzw);\n}\nvec4 qinv(in vec4 q){\n \treturn qonj(q) / dot(q,q);\n}\nvec4 qmul(in vec4 p, in vec4 q){\n    return vec4(p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,\n                p.x*q.y + p.y*q.x + p.z*q.w - p.w*q.z,\n                p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,\n                p.x*q.w + p.y*q.z - p.z*q.y + p.w*q.x);\n}\nvec4 qdiv(in vec4 p, in vec4 q){\n    return qmul(p, qinv(q));\n}\nvec4 qmob(in vec2[4] M, in vec4 z){ // see Ahlfors 1981 Mob tsfms p14\n    vec4 a = c2q(M[0]);\n    vec4 b = c2q(M[1]);\n    vec4 c = c2q(M[2]);\n    vec4 d = c2q(M[3]);\n    return qdiv( qmul(a,z)+b, qmul(c,z)+d ); // if z.w = 0 then result.w = 0\n}\n\nconst float sqrt3 = sqrt(3.0);\nconst vec2 w = vec2(0.5, 0.5*sqrt3);\nconst vec2 winv = vec2(0.5, -0.5*sqrt3);\nconst vec2 c0 = vec2(0.0,0.0);\nconst vec2 c1 = vec2(1.0,0.0);\nconst vec2 ci = vec2(0.0,1.0);\n\nbool needt1(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 1\n\treturn q.x*(-0.5*sqrt3) + q.y*0.5 > 0.0;}\nbool needt1inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 1\n    vec4 center = c2q((c1 + winv)/3.0);\n    vec4 qmc = q - center;\n    return qmc.x*qmc.x + qmc.y*qmc.y + qmc.z*qmc.z < 1.0/3.0;}\nbool needt2(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 2\n\treturn q.x*(-0.5*sqrt3) + q.y*(-0.5) > 0.0;}\nbool needt2inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 2\n\treturn (q.x-1.0)*(0.5*sqrt3) + q.y*(0.5) > 0.0;}\nbool needt3(in vec4 q){ // q is wrong side of face of fund domain corresponding to transformation 3\n    return (q.x-1.0)*(0.5*sqrt3) + q.y*(-0.5) > 0.0; }\nbool needt3inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 3\n    vec4 center = c2q((c1 + w)/3.0);\n\tvec4 qmc = q - center;\n    return dot(qmc.xyz, qmc.xyz) < 1.0/3.0;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t1[4];\n\tt1[0] = c1;\n\tt1[1] = -w;\n\tt1[2] = c1;\n\tt1[3] = winv;  // is this really the only way to assign values to the array??\n    vec2 t1inv[4];\n    t1inv[0] = winv;\n    t1inv[1] = w;\n    t1inv[2] = -c1;\n    t1inv[3] = c1;\n    vec2 t2[4];\n    t2[0] = c1;\n    t2[1] = w;\n    t2[2] = c0;\n    t2[3] = c1;\n    vec2 t2inv[4];\n    t2inv[0] = c1;\n    t2inv[1] = -w;\n    t2inv[2] = -c0;\n    t2inv[3] = c1;\n    vec2 t3[4];\n    t3[0] = -winv;\n    t3[1] = -w;\n    t3[2] = w;\n    t3[3] = -w - c1;\n    vec2 t3inv[4];\n    t3inv[0] = -w - c1;\n    t3inv[1] = w;\n    t3inv[2] = -w;\n    t3inv[3] = -winv; //all these should have det 1 now\n    \n    vec2 p = vec2(0.1,0.001) + 1.5*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    vec4 q = vec4(p, 0.001+0.1*(0.75 + cos(iTime) + 0.25*cos(2.0*iTime)), 0.0);\n\t//vec4 q = vec4(p, 0.0001, 0.0);\n    \n    int crossing_count = 0;\n    bool inside_fund_dom = false;\n    for(int i=0;i<512;i++){\n        if (needt1(q)) q = qmob(t1, q);\n        else if (needt1inv(q)) q = qmob(t1inv, q);\n        else if (needt2(q)) { q = qmob(t2, q);\n                             crossing_count -= 1;}\n        else if (needt2inv(q)) { q = qmob(t2inv, q);\n                             crossing_count += 1;}\n        else if (needt3(q)) { q = qmob(t3, q);\n                             crossing_count -= 1;}        \n        else if (needt3inv(q)) { q = qmob(t3inv, q);\n                             crossing_count += 1;}\n        else{\n            inside_fund_dom = true;\n            break;\n        }\n    }\n    vec3 col;\n    if (inside_fund_dom){\n        //float c = 0.5 + float(crossing_count)/10.0;\n        float d = float(crossing_count)/15.0;\n        if (d > 0.0){\n            col = vec3(d,0.5*(1.0-d),0.5*(1.0-d));\n        }\n        else{\n            col = vec3(0.0,0.5*(1.0+d),0.5*(1.0+d)); \n        }\n        \n    }\n    else{\n        col = vec3(0.0,0.0,0.5);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}