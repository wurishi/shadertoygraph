{"ver":"0.1","info":{"id":"mtGGzG","date":"1684194343","viewed":121,"name":"Moon surface shader public","username":"Longinus","description":"Tries to mimic moon surface","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["moon","sand","crater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float M_PI2 = 3.14159265359*2.0;\nconst float M_PI6 = 3.14159265359/6.0;\nconst float M_PI3 = 3.14159265359/3.0;\nconst float sqrt32 = 2.0/sqrt(3.0);\nconst float sr = sqrt(3.0)/2.0;\nconst vec2 rat = vec2(1.0,sr);\n\n// From https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nfloat hash(vec2 v) { return dot(v,vec2(1., -1178.65)); }\nfloat rnd(float x) { return fract(sin(234.56*x)); }\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\n\nfloat noiseAngle(float angle){\n    float segments = 64.;\n    float value = segments*mod(angle,M_PI2)/M_PI2;\n    float afloor= floor(value);\n    float aceil = ceil(value);\n    float a = rnd(afloor);\n    float b = rnd(aceil);\n    return mix(a,b, fract(value));\n}\n\nfloat HexagonCircles(vec2 uv){\n    vec2 uv2 = (uv)/rat;\n    float height = 0.0;\n    vec2 uv3 = uv2-vec2(0.5,0.75);\n    vec2 hexas = uv3+vec2(floor(uv3.y)*0.5,1.0);      \n    vec2 c = uv3+vec2(1.0,1.0)-fract(hexas);\n    vec2 seed = floor(hexas);\n    vec3 offset = rnd3(seed.y*23.4+seed.x*6.47);\n    float n = hash(floor(hexas));\n    float radius = 0.125*(rnd(n)*0.5+1.0);\n    vec2 dv = (c-uv2)*rat+offset.zx*(0.5-radius);\n    float d = length(dv);\n    float angle = atan(dv.y,dv.x);\n    float radius2 = radius*(1.0+0.2*offset.z*noiseAngle(angle));\n    float slopeUp = d/radius2;\n    float slopeDown = (radius2-(d-radius2))/radius2;\n    float dHeight = d<radius2?slopeUp*slopeUp:max(slopeDown*slopeDown,0.5);\n    height = radius2*2.>d?dHeight:0.5;       \n    \n    return (min(max(0.0,height),1.0)*2.)-1.0;\n}\n\n\nfloat Craters(vec2 uv){\n    float sum=0.0;\n    float times = 3.;\n    for(int i=0; i< int(times*2.);i++){\n        sum +=HexagonCircles((uv+vec2(1.,1)*float(i))*2.)/(times*4.);\n    }\n    for(int i=0; i< int(times);i++){\n        sum +=HexagonCircles(uv+vec2(1,1)*float(i))/(times*2.);\n    }\n    sum += HexagonCircles((uv+vec2(3.,3))/2.0)/4.;\n    sum += HexagonCircles(uv/2.0)/3.;\n    sum += HexagonCircles(uv/4.0)/2.;\n    sum += HexagonCircles(uv/16.0)/1.5;\n    return sum;\n}\n\n\nvec2 calcuv(vec2 uv){\n    float d = (sin(iTime*0.057843));\n    float r = iTime*0.054387;\n    float sr= sin(r);\n    float cr= cos(r);\n    float zx= 8.0-6.0*d;\n    uv= uv- vec2(iResolution.x/iResolution.y, 1.0)*0.5;\n    uv= uv* mat2(sr,cr,-cr,sr)*zx;\n    uv= uv + vec2(iResolution.x/iResolution.y,1.0)*0.5;\n    return uv;    \n}\n\nfloat Moon(vec2 uv) {\n    uv = calcuv(uv);\n    \n    float craters=Craters(uv);\n    return craters+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = vec2(fragCoord.xy / iResolution.xy)*\n      vec2(iResolution.x/iResolution.y,1.0); //scale to normal width\n\n    vec2 step = 1.0/iResolution.xy;\n\n    float moon = Moon(uv);\n    float moondx = Moon(uv+step.x);\n    float moondy = Moon(uv+step.y);\n    vec2 sand = hash22(floor(calcuv(uv)*iResolution.xy*0.25));\n    vec2 moondxy = vec2(moondx-moon, moondy-moon)+0.01*sand;\n    \n    vec3 light = normalize(vec3(0.75,0.5,0.5));\n    \n    vec3 moonnormal = normalize(vec3(moondxy,0.0))*0.75;\n    float lumina = dot(moonnormal,light);\n    float depth =moon;\n\tfloat ambient =0.5;\n    float lightness= lumina*depth+ambient;\n    vec3 color = vec3(0.9,0.86,0.82);\n    fragColor = vec4(lightness*color,1.0);\n}","name":"Image","description":"","type":"image"}]}