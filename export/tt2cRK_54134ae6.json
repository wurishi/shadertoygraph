{"ver":"0.1","info":{"id":"tt2cRK","date":"1594863424","viewed":66,"name":"Apollonian-2020-v2","username":"jorge2017a1","description":"Apollonian-2020","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["apollonian","2020"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by evilryu..........\n//y modificado por Jorge flores///---2020-jul-15\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ITERATION 8\n\nvec4 orb;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n\n\n///---------------------------------------\nfloat intersectSDF(float distA, float distB) \n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n///---------------------------------------\n\n\nfloat apollonian(vec3 p)\n{\n   \tfloat scale = 1.0;\n\torb = vec4(9999.0); \n    float tmp;\n\t\n\tfor( int i=0; i < ITERATION;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n        float r2 = dot(p,p);\n        orb = min( orb, vec4(abs(p+ sin(p)),r2) );\n        float k = 1.8*cos(iTime*0.45)/ r2;\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n    \n    \n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    vec3 q=p;\n\n    float d0=apollonian(p*0.41)*5.;;\n    //float d1=abs(p.y-0.02);\n    float d3 = box(q+vec3(0.,-2.,0.), vec3(4.,4.,4.0));\n    \n    float d=d0;\n    d= intersectSDF(d3, d0); \n    \n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n    \n    return normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\n                          map(p + e.yyx)-map(p - e.yyx)));\n    \n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.y * 2.0);\n\n    float t = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c<0.5*pixel_size*t ) break;\n        t += c;\n        if( t>100.0 ) return -1.0;\n    }\n    return t;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    \n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( abs(res)<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tonemap(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\n\n\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    float tt=iTime*0.5;\n    \n    vec3 lookat = vec3(0.0, 1.5, 0.);\n\tvec3 ro = 1.4*vec3(-1.+2.0*cos(tt), 1.5,-4.5+2.0*sin(tt));\n    ro=get_mouse(ro);\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 ld0=normalize(vec3(-12., 2.0, -5.));\n        \n        float ao = pow(clamp(orb.w*2.0,0.0,1.0), 1.2);\n        float c0=pow(clamp(orb.w, 0.0, 1.0), 2.);\n        float c1=pow(clamp(orb.x, 0.0, 1.0), 2.);\n    \tvec3 col0=c0*vec3(0.0,1.0,1.0);\n\t\tvec3 col1=vec3(1.);\n        col1 = mix(col1, vec3(0.4,1.0,0.5), clamp(3.5*orb.y,0.,1.));\n\n\n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float bac2=max(0.0, dot(n, -vec3(0.,1.,0.)));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 64.0));\n        float sha=softshadow( pos+0.01*n, ld0, 0.005, 32.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.5)*amb*ao;\n        lin+=vec3(2.5,1.8,0.7)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(1.,0.8,0.3)*bac2*ao;\n        lin+=vec3(spec*6.2)*sha;\n        \n       \tcol=(lin*col1-col0)*.2;\n        col=mix(col,vec3(0.), 1.0-exp(-0.001*t*t)); \n        col *= min(20000.0*exp(-0.74*t),1.0);\n\n     }\n    \n    col=tonemap(col);\n    //col=pow(col,vec3(1.3,1.,1.));\n    col=pow(clamp(col,0.0,1.0),vec3(0.25));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    \n    \n    \n    fragColor.xyz=col;\n}","name":"Image","description":"","type":"image"}]}