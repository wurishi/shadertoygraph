{"ver":"0.1","info":{"id":"3dscDN","date":"1584824929","viewed":92,"name":"MCG: Hermite curve","username":"tale3d","description":"Cubic Hermite curve, to illustrate the lecture \"Parametric curves\"","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Hermite(vec2 p0, vec2 p1, vec2 m0, vec2 m1, float t)\n{\n    //precompute powers of t\n    float t2 = t*t;\n    float t3 = t2*t;\n    //calculate four terms that make cubic Hermite curve, see lecture for the equation\n    vec2 term1 = p0*(2.0*t3-3.0*t2 + 1.0);\n    vec2 term2 = m0*(t3-2.0*t2 + t);\n    vec2 term3 = p1*(-2.0*t3+3.0*t2);\n    vec2 term4 = m1*(t3-t2);\n    return term1+term2+term3+term4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n\n    //Adding more to the common section:\n    //This example has a mouse as an input device.\n    //The mouse coordinates are taking in uv space, and then is modified in the same way\n    //  as the pixel coordinates (see above). \n    vec2 mouse = 2.0*(iMouse.xy / iResolution.xy) - vec2(1.0,1.0);\n    mouse.x *= aspect_ratio;\n\n\n    //Background colour (default)\n    vec3 colour = vec3(1.0,1.0,1.0);\n\n    //the first point of our curve is pre-defined\n    vec2 p0 = vec2(-0.5,0.3);\n    //the second point is given by our mouse + click\n    vec2 p1 = mouse;\n    \n    //tangents are also pre-defined, you can try to change them!\n    //note that I normalise the tangents, but it is not necessary.\n    vec2 m0 = normalize(vec2(1.0, 1.0));\n    vec2 m1 = normalize(vec2(1.0, -1.0));\n    \n    //draw the first and the last point\n    if (dot(c-p0, c-p0) < 0.001) colour = vec3(1.0,0.0,0.0);\n    if (dot(c-p1, c-p1) < 0.001) colour = vec3(1.0,0.0,0.0);\n\n    //Here we calculate some large number of points lying on the curve.\n    for (int n = 0; n <= 1000; n++)\n    {\n        float t = float(n)/1000.0;\n        vec2 pos = Hermite(p0,p1,m0,m1,t);\n        //If our pixel is close to one of these points, we colour it black.\n        //That is now we draw our curve.\n\t    if (dot(c-pos, c-pos) < 0.0001) colour = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(colour,1.0);\n\n}","name":"Image","description":"","type":"image"}]}