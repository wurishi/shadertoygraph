{"ver":"0.1","info":{"id":"DdBfRG","date":"1690054702","viewed":13,"name":"RayTracing multi-item ","username":"alejoXD","description":"RayMarching multi-object with blending modes","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"RayMarching Template v2\" by alejoXD. https://shadertoy.com/view/msBfWw\n// 2023-07-19 23:42:50\n\n#define TAU 6.283185\n#define PI 3.141592\n\n\nfloat doModel( vec3 p ) //SDF Calc\n{\n\n    //float rombo = doRombo(vec3(p.x -1.5, p.y -0.5, p.z + 0.6));\n    \n    float caja = doRombo(vec3(p.x -1.5, p.y -0.3, p.z + 0.6));\n    float rombo2 = doRombo(vec3(p.x +sin(iTime*.5) +.1, p.y -0.5, p.z + 0.8));\n    float plane = sdPlane(p);\n    \n    float rombusUnion = opSmoothUnion(caja, rombo2, .2);\n    \n    float finalResult = opUnion(rombusUnion, plane);\n    \n    return finalResult;\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 finalColor = vec3(.0,.0,.0);\n    if(nor.y >= 0.5){finalColor += vec3(1.000,0.439,0.722);}\n    \n    if(nor.y < 0.5){finalColor += vec3(0.302,0.663,0.996);}\n    \n    if(nor.y == 1.){finalColor = vec3(0.125,0.812,0.298);}\n    \n    return finalColor;\n    \n    //return vec3(0.224,0.796,0.835); //Devuelve un color plano de momento\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k ) //Soft shadows between objects\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = doModel( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.5,1.3)); //Dirección de la luz\n    float dif = max(dot(nor,lig),0.0);\n    \n    float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n    lin += dif*vec3(0.910,0.910,0.910) *sha; //Color de la luz\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.30,0.30,0.30); //Color de la ambient light\n    \n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c); //Función de rotacíon de cámara\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar)\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float an = 4.7; //* iTime;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    //camPos = vec3(3.5,1.,4);\n    camTar = vec3(0.,0.,0.);\n    \n    camPos.xz *= Rot(-0.6 * TAU);\n    camPos.yz *= Rot(-0.2 * PI+1.);\n    camPos.yz *= Rot(-m.y * PI+1.);\n    camPos.xz *= Rot(-m.x * TAU); //Rotación con el ratón hand-made\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0); //Color Background\n}\n\n//------------------------------------------------\n\nvec3 compute_normal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd ) //Realiza el RayMarching\n{\n\tconst float maxd = 20.0; //Máxima distancia           \n    float t = 0.0; //Distancia\n    for( int i=0; i<128; i++ )          // max number of raymarching iterations is 90\n    {\n\t    float d = doModel( ro+rd*t );\n        if( d<0.001 || t>maxd ) break;  // precision 0.001, maximum distance 20\n        t += d;\n    }\n    return (t<maxd) ? t : -1.0;\n}\n\nvec3 color( in vec2 uv )\n{\n    // camera movement (ro is ray origin, ta is the target location we are looking at)\n    vec3 ro, ta; \n    doCamera( ro, ta);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    mat3 camMat = mat3( uu, vv, ww ); //Matriz de cámara\n    \n\t// create ray\n\tvec3 rd = normalize( camMat * vec3(uv,2.0) ); // 2.0 is the lens length\n\n    // compute background\n\tvec3 col = doBackground();\n\n\t// project/intersect through raymarching of SDFs\n    float t = intersect( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd; //Origen del rayo + distancia * dirección\n        vec3 nor = compute_normal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        // lighting\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n    // monitor gamma adjustnment\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    fragColor = vec4( color(uv), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//--- SDF Functions\nfloat doRombo(vec3 p)\n{\n    float s = 1.;\n\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n\n    return min( min( length(p.xyz)-1.0, length(p.xy)-0.2 ),\n                min( length(p.yz )-0.2, length(p.zx)-0.2 ) );\n}\nfloat sdBox(vec3 pt, vec3 b) {\n    vec3 box = abs(pt) - b;\n    return length(max(box, 0.0)) + min(max(box.x, max(box.y, box.z)), 0.0);\n}\nfloat mengerSponge(vec3 pt) {\n    float scale = 1.0;\n    float offset = -2.;\n    float iterations = 3.;\n\n    float dist = sdBox(vec3(pt.x, pt.y+offset, pt.z), vec3(scale));\n    \n    float s = 1.;\n    \n    float da, db, dc;\n    \n    for(int i = 0; i < 4; i++) {\n        vec3 a = mod(pt * s, 2.0) - 1.0;\n        s *= iterations;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        \n        da = max(r.x, r.y);\n        db = max(r.y, r.z);\n        dc = max(r.z, r.x);\n        \n        float c = (min(da, min(db, dc)) - 1.) / s;\n        if ( c > dist) dist = c;\n    }\n    \n    return dist;\n}\n\nfloat sdPlane( vec3 p)\n{\n\n  vec3 n = vec3(0., 1., 0.);\n  float h = .6;\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n//--- Combination Functions\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    return -opSmoothUnion(-d1,-d2,k);\n}","name":"Common","description":"","type":"common"}]}