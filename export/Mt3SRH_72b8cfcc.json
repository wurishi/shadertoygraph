{"ver":"0.1","info":{"id":"Mt3SRH","date":"1478232960","viewed":440,"name":"SmoothLifeL","username":"sparrow","description":"Another riff of Smooth Life Gliders.  (See: https://www.shadertoy.com/view/Msy3RD).  Using continuous timestepping, tweaked parameters to get SmoothLifeL rule working.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["automata","continuous","smoothlife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float s = texture(iChannel0, uv).r;\n    // TODO: more interesting color functions.\n    vec3 color = vec3(0.5, 0.36, 1.0);\n\tfragColor = vec4(color * s, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// based on <https://git.io/vz29Q>\n// Copied from davidar's Smooth Life Gliders (https://www.shadertoy.com/view/Msy3RD)\n//\n// ---------------------------------------------\n// SmoothLife (discrete time stepping 2D)\nstruct SmoothLifeParameters {\n\tfloat ra;       // outer radius\n\tfloat rr;       // ratio of radii\n\tfloat b;        // smoothing border width\n\tfloat b1;       // birth1\n\tfloat b2;       // birth2\n\tfloat d1;       // survival1\n\tfloat d2;       // survival2\n\tfloat sn;       // sigmoid width for outer fullness\n\tfloat sm;       // sigmoid width for inner fullness\n    float dt;       // dt per frame\n};\n\n// SmoothLifeL\nconst SmoothLifeParameters p = SmoothLifeParameters(10.0,\n                                                    3.0,\n                                                    1.0,\n                                                    0.257,\n                                                    0.336,\n                                                    0.365,\n                                                    0.549,\n                                                    0.028,\n                                                    0.147,\n                                                    .1);\n    \nfloat smooth_s(float x, float a, float ea) \n{ \n    return 1.0 / (1.0 + exp((a - x) * 4.0 / ea));\n}\n\nfloat sigmoid_ab(float x, float a, float b)\n{\n    return smooth_s(x, a, p.sn) * (1.0 - smooth_s(x, b, p.sn));\n}\n\nfloat sigmoid_mix(float x, float y, float m)\n{\n    float sigmoidM = smooth_s(m, 0.5, p.sm);\n    return mix(x, y, sigmoidM);\n}\n\n// the transition function\n// (n = outer fullness, m = inner fullness)\nfloat snm(float n, float m)\n{\n    return sigmoid_mix(sigmoid_ab(n, p.b1, p.b2), sigmoid_ab(n, p.d1, p.d2), m);\n}\n\nfloat func_linear(float x, float a, float b)\n{\n    if (x < a - b / 2.0) {\n        return 0.0;\n    }\n    else if (x > a + b / 2.0) {\n        return 1.0;\n    }\n    else {\n        return (x - a + b / 2.0) / b;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // inner radius:\n    const float rb = p.ra / p.rr;\n    // area of annulus:\n    const float SUM_OUTER = 279.216;    // Computed the sums offline.\n    const float SUM_INNER = 35.524;     // TODO: compute from radii\n    \n    // how full are the annulus and inner disk?\n    float outf = 0.0, inf = 0.0;\n    for (float dx = -p.ra; dx <= p.ra; dx++) {\n        for (float dy = -p.ra; dy <= p.ra; dy++) {\n            vec2 d = vec2(dx, dy);\n            float r = length(d);\n        \tvec2 txy = fract((fragCoord + d) / iResolution.xy);\n        \tfloat val = texture(iChannel0, txy).x;\n        \tfloat kr = func_linear(r, rb, p.b);\n        \tfloat inner_kernel = 1.0 - kr;\n        \tfloat outer_kernel = (1.0 - func_linear(r, p.ra, p.b)) * kr;\n        \tinf  += val * inner_kernel;\n        \toutf += val * outer_kernel;\n        }\n    }\n    outf /= SUM_OUTER; // normalize by area\n    inf /= SUM_INNER; // normalize by area\n    \n    float s = texture(iChannel0, uv).x;\n    float deriv = 2.0 * snm(outf, inf) - 1.0;\n    s = clamp(s + (deriv * p.dt), 0.0, 1.0);  // Apply delta to state\n    if (iFrame < 10 || iMouse.z > 0.0) {\n        s = clamp(s + texture(iChannel1, uv).x, 0.0, 1.0);\n    }\n    fragColor = vec4(s, s, s, 1);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;    \n    // Random-ish width and height\n    float sx = mod((t + 41.0) * 17.0, 79.0) + 15.0;\n    //float sy = mod((t + 47.0) * 11.0, 67.0) + 25.0;\n    float sy = sx;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n\tvec2 drawPosition = iMouse.xy;\n    if (iFrame < 10) {\n    \tdrawPosition = iResolution.xy * .5; // center\n    }\n    \n    if (abs(fragCoord.x - drawPosition.x) <= sx && abs(fragCoord.y - drawPosition.y) <= sy) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n\tfragColor = vec4(color ,1.0);\n\n}","name":"Buf B","description":"","type":"buffer"}]}