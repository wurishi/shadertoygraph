{"ver":"0.1","info":{"id":"7sSSWV","date":"1621016165","viewed":1184,"name":"Creative Block [Outline 2021]","username":"yx","description":"Released in the Executable Graphics compo at Outline 2021.\n\nDownload the executable version here: [url]https://demozoo.org/graphics/294426/[/url]\n\nNote: All comments on how to minify the shader further will be deleted.","likes":60,"published":1,"flags":32,"usePreview":0,"tags":["sdf","pathtracing","outline","sizecoding","demoparty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n \t// seed the RNG (again taken from Devour)\n    seed = float((int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\tvec4 tex = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0);\n    \n    // divide by sample-count\n\tvec3 color = tex.rgb/tex.a;\n\n\t// vignette to darken the corners\n\tuv-=.5;\n\tcolor *= 1.-dot(uv,uv)*.1;\n\n    // exposure and tonemap\n    color *= 3.5;\n    //color = 1.-exp(color*-2.);\n    color = mix(color,1.-exp(color*-2.),.5);\n\n    // subtle warm grade\n    color = pow(color,vec3(1,1.02,1.05));\n    \n\t// gamma correction as the final step\n\tcolor = pow(color, vec3(.45));\n\n    // grain\n    color += (vec3(hash(),hash(),hash())-.5)*.01;\n\n    // aspect ratio\n    uv*=iResolution.xy/iResolution.yx;\n    color *= step(abs(uv.y),.5/(16./9.));\n    color *= step(abs(uv.x),.5*(16./9.));\n\n    // \"final\" color\n    fragColor = vec4(vec3(color),1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n~ Creative Block\n  by yx\n\n~ 4kb executable graphics\n  released at Outline 2021\n\n~ tools:\n  crinkler by loonies & tbc\n  shader minifier by llb\n  blossom by yx\n\n~ note:\n  the party exe runs at 1080p,\n  with a 30-second rendering limit.\n  --\n  the other exe will match your\n  display's resolution, and takes\n  as long as it needs to reach\n  1024 samples.\n\n~ greetings:\n  alia\n  alkama\n  bitnenfer\n  blackle\n  cpdt\n  darya\n  evvvvil\n  fizzer\n  flopine\n  fms_cat\n  iq\n  molive\n  noby\n  nusan\n  slerpy\n  tdhooper\n  wrighter\n*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi acos(-1.)\n#define tau (pi*2.)\n\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\nvec2 hash2(){return vec2(hash(),hash());}\n\n\nmat2 rotate(float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0));\n}\n\nfloat sdBox(vec2 p, vec2 b, float r)\n{\n    return sdBox(p,b-r)-r;\n}\n\nfloat sdRoundedCylinder(vec3 p, float radius, float halfHeight, float bevel)\n{\n    vec2 p2 = vec2(length(p.xz),p.y);\n    return sdBox(p2,vec2(radius,halfHeight),bevel);\n}\n\nfloat hexa(vec2 p, float r1, float r2)\n{\n    float ang = pi/3.;\n    float x= (r1-r2)/tan(ang)+r2;\n    vec2 v = vec2(x,r1);\n    mat2 rot = rotate(ang);\n    float hex1 = sdBox(p,v,r2); p.xy *= rot;\n    float hex2 = sdBox(p,v,r2); p.xy *= rot;\n    float hex3 = sdBox(p,v,r2);\n    return min(hex1,min(hex2,hex3));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\nint mat = -1;\nconst int kMatGround = 0;\nconst int kMatPlasticRed = 1;\nconst int kMatWood = 2;\nconst int kMatLead = 3;\n\nbool doWoodDisplacement = true;\n\nfloat scene(vec3 p)\n{\n    vec3 op=p;\n    \n    float ground = p.y - (cos(min(100.,p.z)*.03)-1.)*2.;\n\n    p.y -= 4.;\n    p.xz *= rotate(2.1);\n    p.z-=10.;\n    float a = 0.23;\n    float cone = sdCone(p.xzy,vec2(sin(a),cos(a)));\n    float paintShell = hexa(p.xy,4.,1.);\n    float woodCenter = hexa(p.xy,3.95,.95);\n    float leadCore = length(p.xy)-1.1;\n    \n    paintShell = max(paintShell,max(cone,-woodCenter));\n    woodCenter = max(woodCenter,cone);\n    \n    woodCenter = max(woodCenter,.01-leadCore);\n    if (doWoodDisplacement)\n        woodCenter += (texture(iChannel1,p.xy*.25).r-.4)*0.1;//*.075;\n    leadCore = max(leadCore,cone);\n    leadCore = max(leadCore,p.z+1.);\n    leadCore = min(leadCore,length(p+vec3(0,0,1.05))-sin(a)*1.);\n    leadCore += (texture(iChannel1,vec2(atan(p.x,p.z)*.5)).r-.3)*.05;\n    \n\n    float best = ground;\n    best=min(best,paintShell);\n    best=min(best,woodCenter);\n    best=min(best,leadCore);\n\n    \n    if(best==ground)\n    {\n        mat = kMatGround;\n    }\n    else if (best == leadCore)\n    {\n        mat = kMatLead;\n    }\n    else if (best==woodCenter)\n    {\n        mat = kMatWood;\n    }\n    else if (best == paintShell)\n    {\n        mat = kMatPlasticRed;\n    }\n    \n    return best;\n}\n\nfloat flip = 1.;\nconst float IOR = 1.584;\n\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,-1),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// various bits of lighting code \"borrowed\" from \n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 sky(vec3 sunDir, vec3 viewDir) {\n    float softlight = max(0.,dot(normalize(sunDir*vec3(-1,1.,-1)),viewDir)+.2);\n    float keylight = pow(max(0.,dot(sunDir,viewDir)-.5),3.);\n    \n    return vec3(\n\t\tsoftlight*.015 + keylight * 10.\n\t)*1.5;\n    \n    /*return vec3(\n\t\tsoftlight*vec3(.03,.06,.1)*2. + keylight * vec3(10,7,4)\n\t)*1.5;*/\n\n    /*float softlight = max(0.,dot(sunDir,viewDir)+.2);\n    float keylight = pow(max(0.,dot(sunDir,viewDir)-.5),3.);\n    \n    return vec3(\n\t\tsoftlight*.5 + keylight * 10.\n\t)*1.5;*/\n}    \n\nbool trace5(vec3 cam, vec3 dir, float nearClip, out vec3 h, out vec3 n, out float k) {\n\tfloat t=nearClip;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t)*flip;\n        if (abs(k) < .001)\n            break;\n        t += k;\n    }\n\n    h = cam+dir*t;\n\t\n    // if we hit something\n    if(abs(k)<.001)\n    {\n        vec2 o = vec2(.001, 0);\n        n = normalize(vec3(\n            scene(h+o.xyy) - k,\n            scene(h+o.yxy) - k,\n            scene(h+o.yyx) - k \n        ))*flip;\n        return true;\n    }\n    return false;\n}\n\nfloat floorPattern(vec2 uv)\n{\n    float kUnit1 = 10.;\n    float kUnit2 = 5.;\n    float kUnit3 = 1.;\n    float kThick1 = 0.1;\n    float kThick2 = 0.05;\n    float kThick3 = 0.03;\n\n    vec2 uv1 = abs(mod(uv,kUnit1)-kUnit1*.5);\n    vec2 uv2 = abs(mod(uv,kUnit2)-kUnit2*.5);\n    vec2 uv3 = abs(mod(uv,kUnit3)-kUnit3*.5);\n    float lines1 = -max(uv1.x,uv1.y)+kUnit1*.5-kThick1;\n    float lines2 = -max(uv2.x,uv2.y)+kUnit2*.5-kThick2;\n    float lines3 = -max(uv3.x,uv3.y)+kUnit3*.5-kThick3;\n    \n    return min(lines1,min(lines2,lines3));\n}\n\nvec3 trace2(vec3 cam, vec3 dir, float nearClip)\n{\n    const vec3 sunDirection = normalize(vec3(-1.,.8,-.7));\n    //const vec3 sunDirection = normalize(vec3(1.,.7,-.3));\n    //const vec3 sunDirection = normalize(vec3(.5,.3,1));\n    //const vec3 sunDirection = normalize(vec3(0,1,0));\n    \n    vec3 accum = vec3(1);\n    for(int ibounce=0;ibounce<10;++ibounce)\n    {\n        vec3 h,n;\n        float k;\n        if (trace5(cam,dir,ibounce==0?nearClip:0.,h,n,k))\n        {\n            cam = h+n*.01;\n            if (mat == kMatGround)\n            {\n            \tdir=getSampleBiased(n,1.);\n\t\t\t\taccum *= mix(vec3(.25,.3,.35),vec3(.8),step(0.,floorPattern(h.xz)));\n                if (ibounce==0)\n                    doWoodDisplacement=false;\n            }\n            else if (mat == kMatWood)\n            {\n            \tdir=getSampleBiased(n,1.);\n                vec3 col = vec3(211,183,155)/255.;\n\t\t\t\taccum *= col*col*col;\n            }\n            else if (mat == kMatPlasticRed)\n            {\n                float fresnel = pow(1.-min(.99,dot(-dir,n)),5.);\n                fresnel = mix(.04,1.,fresnel);\n                if (hash() < fresnel)\n                {\n                \tdir=reflect(dir,n);\n                }\n                else\n                {\n            \t\tdir=getSampleBiased(n,1.);\n                    accum *= vec3(180,2,1)/255.;\n                }\n            }\n            else if (mat == kMatLead)\n            {\n                float fresnel = pow(1.-min(.99,dot(-dir,n)),5.);\n                fresnel = mix(.04,1.,fresnel);\n                dir=getConeSample(reflect(dir,n),0.3);\n                accum *= .05;\n            }\n        }\n        else if (abs(k) > .1) {\n            return sky(sunDirection, dir) * accum;\n        } else {\n            break;\n        }\n    }\n    \n    return sky(sunDirection, dir) * accum;\n    \n    // deliberately fail the pixel\n    return vec3(-1);\n}\n\nvec2 bokeh(){\n    // hexagon\n    vec2 a = hash2();\n    a.x=a.x*3.-1.;\n    a-=step(1.,a.x+a.y);\n\ta.x += a.y * .5;\n\ta.y *= sqrt(.75);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n    if (iMouse.z > 0.) {\n        fragColor = vec4(0.);\n    }\n\n\t// seed the RNG (again taken from Devour)\n    //seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n    seed = float((iFrame*73856093)%38069);\n\n    // get UVs\n    vec2 uv = (gl_FragCoord.xy+hash2()-.5)/iResolution.xy-.5;\n    \n    // correct UVs for aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    uv.x*=aspect;\n\tuv *= max(1.,(16./9.)/aspect);\n\n    // camera params\n    const vec3 camPos = vec3(140,60.,60)*1.5;\n    const vec3 lookAt = vec3(0,4.,0);\n    const float focusDistance=distance(camPos,lookAt)*.99;\n    const vec2 apertureRadius=vec2(1)*3.;\n    \n    // make a camera\n    vec3 cam = vec3(0);\n    vec3 dir = normalize(vec3(uv,6.5));\n    \n    // add some bokeh\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*apertureRadius;\n    dir.xy-=bokehJitter*apertureRadius*dir.z/focusDistance;\n    \n    // rotate/move the camera\n    vec3 lookDir = lookAt-camPos;\n    float pitch = -atan(lookDir.y,length(lookDir.xz));\n    float yaw = -atan(lookDir.x,lookDir.z);\n    cam.yz *= rotate(pitch);\n    dir.yz *= rotate(pitch);\n    cam.xz *= rotate(yaw);\n    dir.xz *= rotate(yaw);\n    cam += camPos;\n    \n    // compute the pixel color\n\tvec3 pixel = trace2(cam,dir,length(camPos)*.7);\n    \n    fragColor += (!isnan(pixel.r) && pixel.r >= 0.) ? vec4(pixel,1) : vec4(0);\n}","name":"Buffer A","description":"","type":"buffer"}]}