{"ver":"0.1","info":{"id":"mtdfWN","date":"1701268670","viewed":328,"name":"Teddy Cloud","username":"denosya","description":"Some clouds have a special shape, don't they ?\nUse mouse to rotate.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["cloud","perlin","bear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CAMERA_DIST     = 45.;\nconst float CLOUD_THICKNESS = 2.;\nconst vec3  SUN = vec3(-20., 20., 0.); \n\nfloat map(vec3 m) {\n    return sdGoldBear(m);   \n}\n\n// iq made it\nfloat perlin(vec3 v) {\n    vec3 p = floor(v);\n    vec3 f = fract(v);\n\tf = f*f*(3.0-2.0*f);\n    v = p + f;\n    \n    return (textureLod(iChannel0,(v+0.5)/32.0,0.0).x - 0.5)*2.;\n}\n\nfloat noise(vec3 pos) {\n\n    float total = 0.;\n\n    float t = iTime * 1.0;\n\n    total += perlin((pos+t) * 0.5)* 0.25;\n    total += perlin((pos+t) * 1.) * 0.25;\n    total += perlin((pos+t) * 2.) * 0.25;\n\n    return total;\n}\n\nbool rayMarching(vec3 ro, vec3 rd, out vec3 m, float margin) {\n    \n    float marchingDist = 0.0;\n    const float maxDist = 100.;\n\n    float matter = 0.;\n\n    for(int i = 0; i<100; i++) {\n        \n        m = ro + rd * marchingDist;    \n        \n        float dist = map(m) - margin*1.1;\n        \n        if(dist<0.01) {\n            return true;\n        }\n    \n        marchingDist += dist;\n            \n        if(marchingDist >= maxDist) {\n            break;\n        }\n    }\n    \n\treturn false;    \n}\n\nfloat density(vec3 m) { \n    float dist = map(m);\n    float shape = 1. - dist/CLOUD_THICKNESS;  \n    return max(0., noise(m)*0.5 + shape * 1.)*0.1;\n}\n\nfloat computeLight(vec3 m) {\n\n    vec3 rd = normalize(SUN-m);   \n    \n    float matter = 0.;\n\n    float _step = 4.;\n\n    for(int i=0; i<3; i++) {\n        m += rd * _step;\n        _step *= 1.5;\n        matter += density(m);\n    }\n\n    return 1. - smoothstep(0., 1.25, matter);\n}\n\n\nvec3 matterMarch(vec3 ro, vec3 rd, vec3 sky) {\n    \n    float marchingDist = 0.;\n    vec3 finalColor = vec3(0.);\n\n    vec3 m;\n    int i;\n    float matter = 0.;\n    float totalAlpha = 0.;\n\n    float _step = 0.1;\n\n    for(i = 0; i<20; i++) {\n        \n        m = ro + rd * marchingDist;    \n        \n        float lighting = computeLight(m);\n        \n        float d = density(m)*3.;\n        \n        float alpha = (1. - totalAlpha) * d;\n        \n        totalAlpha += alpha;\n        \n        finalColor += alpha * vec3(lighting);\n        \n        if(totalAlpha>=0.99) break;\n        if(alpha == 0.1234) break; // please do not unroll my loop !\n        \n        marchingDist += _step;\n        _step += 0.1;\n     }\n    \n\treturn finalColor += (1. - totalAlpha) * sky;  \n}\n\nvec3 sky(vec2 uv, vec3 ro, vec3 rd) {\n\n    const vec3 skycolor = vec3(0.6,0.8,1.0)*0.9;\n    const vec3 suncolor = (skycolor + 1.) * 0.5;\n    \n    float corner = 1. - pow(length(uv), 2.) * 0.25;\n    \n    vec3 sunDir = normalize(SUN - ro);\n    float specular = pow(max(0., dot(rd, sunDir)), 1.5)*0.25;\n    \n    return mix(skycolor * corner, suncolor, specular);\n}\n\nvec3 computeNormal(in vec3 pos) { // iq\n\tvec3 eps = vec3( 0.1, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nvec3 run(vec2 fragCoord) {\n\n    vec3 m;\n    vec2 uv;\n    vec3 camera = vec3(0, 1., -CAMERA_DIST);\n    vec3 ro = camera;\n    vec3 rd;\n\n    uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    rd\t= normalize(vec3(uv.xy, 0.85));\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    mat3 transfo = rotY(-mouse.x*4.*3.1415+0.3) * rotX(-mouse.y*4.*3.1415);\n\n    ro = transfo * ro;\n    rd = transfo * rd;    \n\n    float lighting = 1.;\n    float matter = 0.;\n\n    vec3 sky = sky(uv, ro, rd);\n\n    return rayMarching(ro, rd, m, CLOUD_THICKNESS) ? matterMarch(m, rd, sky) : sky;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    fragColor = vec4(run(fragCoord), 1.);\n} \n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float Y_OFFSET = -10.;\nconst float PAW_SPACING = 7.;\nconst float PAW_HEIGHT = 12.;\nconst float HEAD_Y = 22.;\nconst float HEAD_Z = 2.;\nconst vec3  EYE_POS = vec3(-2.5, 12.5, -4.1);\nconst vec3  EAR_POS = vec3(6.0, 16., 1.);\nconst float DETAIL_K = 3.0;\nconst float MASS_K = 1.0;\n \nmat3 rotX(float angle) { float cosa = cos(angle); float sina = sin(angle); return mat3(vec3(1., 0., 0.), vec3(0., cosa, sina), vec3(0., -sina, cosa));}\nmat3 rotY(float angle) { float cosa = cos(angle); float sina = sin(angle); return mat3(vec3(cosa, 0., sina), vec3(0., 1., 0.), vec3(-sina, 0., cosa));}\nmat3 rotZ(float angle) { float cosa = cos(angle); float sina = sin(angle); return mat3(vec3(cosa, sina, 0.), vec3(-sina, cosa, 0.), vec3(0., 0., 1.));}\n \nvec3 transfo(vec3 m, float rx, float ry, float rz, float x, float y, float z) {\n    \n    mat3 rotation = rotX(rx) * rotY(ry) * rotZ(rz);\n    vec3 translation = vec3(x, y, z);\n    \n    return transpose(rotation) * (m - translation);\n}\n\n// iq made it\nfloat smin( float a, float b, float k) {\n    //k = k*2.;\n    return min(a, b);\n    //float res = exp2( -k*a ) + exp2( -k*b );\n    //return -log2( res)/k  ;\n}\n\nfloat sdEllipsoid(vec3 m, vec3 r) {\n    float k = length(m/r);\n    return (k-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdGoldBear(vec3 m) {\n\n    m.y += 3.;\n\n    float paw1 = sdEllipsoid(transfo(m, 0., 0., 0., -PAW_SPACING, Y_OFFSET+3., -5.), vec3(4., 4., 4.));  \n    float paw2 = sdEllipsoid(transfo(m, 0., 0., 0.,  PAW_SPACING, Y_OFFSET+3., -5.), vec3(4., 4., 4.));    \n    float paw3 = sdEllipsoid(transfo(m, 0., 0., 0., -PAW_SPACING, Y_OFFSET+PAW_HEIGHT, -5.), vec3(3., 3., 3.));  \n    float paw4 = sdEllipsoid(transfo(m, 0., 0., 0.,  PAW_SPACING, Y_OFFSET+PAW_HEIGHT, -5.), vec3(3., 3., 3.));   \n\n    float paws = smin(smin(paw1, paw2, MASS_K), smin(paw3, paw4, MASS_K), MASS_K*0.8);\n\n    vec3 headm = transfo(m, 0.0, 0.0, 0., 0., HEAD_Y+Y_OFFSET, HEAD_Z);\n    float head = sdEllipsoid(headm, vec3(8.5, 8., 6.));\n    \n    float eye1 = sdEllipsoid(transfo(headm, 0., 0., 0., -EYE_POS.x, EYE_POS.y + Y_OFFSET, EYE_POS.z), 0.9*vec3(1.3, 1.3, 0.6));     \n    float eye2 = sdEllipsoid(transfo(headm, 0., 0., 0., +EYE_POS.x, EYE_POS.y + Y_OFFSET, EYE_POS.z), 0.9*vec3(1.3, 1.3, 0.6));         \n    float nose = sdEllipsoid(transfo(headm, 0., 0., 0., 0., EYE_POS.y - 2.2 + Y_OFFSET, EYE_POS.z), vec3(1., 1., 0.6));             \n\n    float headDetails = min(eye1, eye2);//min(min(eye1, eye2), nose);\n\n    head = smin(head, headDetails, 10.);    \n\n    float ear1 = sdEllipsoid(transfo(headm, 0., 0., 0., -EAR_POS.x, EAR_POS.y + Y_OFFSET, EAR_POS.z), vec3(2., 1.8, 1.)*1.2);     \n    float ear2 = sdEllipsoid(transfo(headm, 0., 0., 0., +EAR_POS.x, EAR_POS.y + Y_OFFSET, EAR_POS.z), vec3(2., 1.8, 1.)*1.2);         \n\n    float body = smin(head, paws, MASS_K);\n    float body_and_ears = min(smin(body, ear1, DETAIL_K), smin(body, ear2, DETAIL_K));\n    \n    float body1 = sdEllipsoid(transfo(m, 0., 0., 0., 0., -2., 0.), vec3(10., 10., 8.));     \n\n\n    return min(body_and_ears, body1);\n}\n","name":"Common","description":"","type":"common"}]}