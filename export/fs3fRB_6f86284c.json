{"ver":"0.1","info":{"id":"fs3fRB","date":"1657433399","viewed":83,"name":"小渲渲","username":"RosyFu","description":"时间捡屎","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float scene(vec3 pos){\n    vec3 p = pos;\n    \n    vec3 pos1 = vec3(p.x+1.,p.y,p.z);\n    float ellipse = ellipse(pos1,vec3(.5,.1,.1));\n    vec3 pos2 = vec3(p.x-1.,p.y,p.z);\n    float cube = cube(pos2,vec3(0.2,0.1,0.2));\n    float scene = merge(ellipse,cube);\n    vec3 pos3 = vec3(p.x,p.y,p.z);\n    float cylinder = cylinder(pos3, .2,.1);\n    scene = merge(scene, cylinder);\n    \n    p.z+=1.;\n    vec3 pos4 = vec3(p.x,p.y,p.z);\n    float sphere = sphere(pos4, .2);\n    scene = merge(scene, sphere);\n    vec3 pos5 = vec3(p.x+1.,p.y,p.z);\n    float capsule = capsule (pos5, .2,.1);\n    scene = merge(scene, capsule);\n    vec3 pos6 = vec3(p.x-1.,p.y,p.z);\n    float torus = torus(pos6,.1,.1);\n    scene = merge(scene, torus);\n    \n    p.z-=2.;\n    vec3 pos7 = vec3(p.x-1.,p.y,p.z);\n    float cone = cone(pos7,.4,.4);\n    scene = merge(scene, cone);\n    vec3 pos8 = vec3(p.x,p.y,p.z);\n    float capCone = rounding(capCone(pos8,.3,.1,.2),0.1);\n    scene = merge(scene, capCone);\n    vec3 pos9 = vec3(p.x+1.,p.y,p.z);\n    float roundCone = roundCone(pos9,.3,.1,.05);\n    scene = merge(scene, roundCone);\n\n    p = pos;//reset\n    p.y -=.5;\n    vec3 pos10 = vec3(p.x,p.y,p.z);\n    float pyramid = rounding(pyramid(pos10,.2,.1, .02),0.1);\n    scene = merge(scene, pyramid);\n\n    \n\n    return scene;\n\n}\n\nfloat map(vec3 pos){\n    float t = fract(iTime);\n    float y = 4.*t*(1.-t);\n    float sy = 0.2*(0.5+0.5*y);\n    float h = 0.3;\n    vec3 center = vec3(0.,sy,0.);\n    float d = scene(pos-center);\n    float ground = pos.y+sy + h;// pos.y - (floor height)\n    return min(d, ground);\n}\n\n\nvec3 calcN(vec3 pos){// approx normal, crazy bump(?\n    vec3 e = vec3(0.0001,0.,0.);\n    \n    return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                          map(pos+e.yxy)-map(pos-e.yxy),\n                          map(pos+e.yyx)-map(pos-e.yyx)\n    ));\n}\n\nvec3 pos;\nfloat castRay(vec3 ro, vec3 rd){\n    float t = 0.;\n    \n    for(int i = 0;i<100;i++){\n        pos = ro + t*rd;//raymarch current step pos\n        float h = map(pos);      \n        \n        if(h<0.0001) break;\n            t+=h;\n        if(t>40.) break;        \n    }\n    if(t>20.)\n        t = -1.;\n    return t;\n} \n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;//(*2-1=> -1-1)    \n    vec2 rad = 10.*iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(sin(rad.x),exp(-rad.y)+1.5,cos(rad.x)); //cam pos, radius 1 circle\n    vec3 ta = vec3(0.);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = cross(uu,ww);\n    vec3 rd = normalize(p.x*uu+p.y*vv+1.5*ww);//unit*dir\n    \n    vec3 col = vec3(0.);\n    float t = castRay(ro, rd);\n    \n    if(t>0.){\n        setup.N = calcN(pos);\n        setup.stencil = 1.0;\n        setup.depth = 1.-pos.z;\n        setup.col = albedo;\n    }    \n    \n    //apply light    \n    float diffuse = saturate(dot(LDir, setup.N));\n    float spec = saturate(pow(saturate(dot(LDir, HDir)),exp(gloss)));    \n    float sunShadow = softshadow(pos + setup.N*.0001, LDir,1.,10.,32.);\n    float bLight = saturate(0.5+0.5*dot(setup.N, -skyDir))*0.5;\n    float fresnel = pow(1.-dot(-rd, setup.N),6.0) * fuzz;\n    \n    vec3 skyCol = ambient*saturate(0.5+0.5*dot(setup.N, skyDir));\n    col = spec + (diffuse * sunCol * sunShadow + skyCol + bLight + fresnel) * setup.col ;\n    \n    vec3 bg = normalize(mix(vec3(155., 226., 230.),vec3(122., 182., 255.),p.y));\n    \n    //blend\n    col = pow(col, vec3(0.4545));//2.2^0.4545 = 1.0, gamma correct for eye\n    col = mix(bg,col,setup.stencil);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Gbuffer{\n    vec3 N;\n    float stencil;\n    vec3 col;\n    float depth;\n    int objectID;\n};\n\nfloat saturate(float a){\n    return clamp(a, 0., 1.);\n}\n\n//3D SDF\nfloat rounding( float d, float r ){\n    return d-r;\n}\n\nfloat sphere(vec3 pos, float r){\n    float d = length(pos)-r;\n    return d;\n}\n\nfloat ellipse(vec3 pos, vec3 rad){\n    float k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);       \n    return k0*(k0-1.)/k1;\n}\n\nfloat cube(vec3 pos, vec3 rad){\n    vec3 _pos = abs(pos);\n    return length(max(_pos-rad/2.,0.));\n}\n\nfloat cylinder(vec3 pos, float h, float r){\n    vec3 _pos = abs(pos);\n    float d = length(_pos.xy)-r;\n    return max(_pos.z-h/2., d);\n}\n\nfloat capsule(vec3 pos, float h, float r){\n    vec3 _pos = abs(pos);\n    _pos.z -= h/2.;\n    float d1 = length(_pos)-r;\n    float d2 = cylinder(pos,h,r);\n    return min(d1,d2);\n}\n\nfloat torus(vec3 pos, float r, float width){\n    vec3 dir = vec3(normalize(pos.xy), 0.)*r;\n    return length(pos-dir)-width;\n}\n\nfloat cone(vec3 pos, float h, float r){\n    float d = abs(pos.z)-h/2.;\n    float d2 = length(pos.xy)-r*(-pos.z);\n    return max(d,d2);\n}\n\nfloat capCone(vec3 pos, float h, float r1, float r2){//r1: bottom, r2: top\n    float d = abs(pos.z)-h/2.;\n    float d2 = length(pos.xy)-mix(r1, r2,(pos.z+h/2.)/h);\n    return max(d,d2);\n}\n\nfloat roundCone(vec3 pos, float h, float r1, float r2){//r1: bottom, r2: top\n    float d = abs(pos.z)-h/2.;\n    float d2 = length(pos.xy)-mix(r1, r2,(pos.z+h/2.)/h);\n    float d3 = length(pos+vec3(0.,0.,h/2.))-r1;\n    float d4 = length(pos-vec3(0.,0.,h/2.))-r2;\n    \n    d3 = max(min(d3,d4), -d);\n    return min(max(d,d2),d3);\n}\n\nfloat pyramid(vec3 pos, float h, float r1, float r2){\n    vec3 _pos = abs(pos);\n    float d0 = _pos.x-mix(r1,r2 ,(pos.y+h/2.)/h);\n    float d1 = _pos.z-mix(r1,r2 ,(pos.y+h/2.)/h);\n    float d2 = _pos.y - h/2.;\n    return max(d2,max(d1,d0));\n}\n\nfloat merge(float shape1, float shape2){\n    return min(shape1, shape2);\n}\n\nfloat exclude(float shape1, float shape2){\n    return max(shape1, shape2);\n}\n\nGbuffer setup = Gbuffer(vec3(0.), 0., vec3(0.),-1., -1);//init\n\n#define LDir normalize(vec3(0.8,0.4,0.7))\n#define VDir normalize(vec3(-0.5,-0.3, -0.3))\n#define HDir normalize(setup.N - VDir)\n#define sunVal 6.\n#define ambientVal 5.\n\n#define skyDir normalize(vec3(0.,1.0,0.))\n#define sunCol vec3(1.0,0.7,0.4) * sunVal\n#define ambient vec3(0.,0.05,0.2) * ambientVal\n\n#define albedo vec3(.2)\n#define gloss 6.0\n#define fuzz .7\n\n#define height 0.1","name":"Common","description":"","type":"common"}]}