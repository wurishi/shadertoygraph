{"ver":"0.1","info":{"id":"3lfyz7","date":"1591635956","viewed":81,"name":"Raymarching - Blobby","username":"emaldonado_gamedev","description":"Practicing with offset and displacement functions","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Author: Esteban Enrique Maldonado Cab√°n\n\n/*\nReferences:\n\n1) For noise functions:\nhttps://www.youtube.com/watch?v=zXsWftRdsvU\n\n2) For Raymarching:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nhttps://iquilezles.org/articles/distfunctions   IQ's website\n\n3) Cubemapping & Key Press:\nhttps://www.shadertoy.com/view/4sjcz1\n\n*/\n\n\n/*\nDetects if the specified keyCode is pressed\n*/\nfloat keyPressed(int keyCode) {\n\treturn texture(iChannel3, vec2((float(keyCode)) / 256., .5/3.)).r;   \n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    \n    //Modify the scene you'd like to render here...\n    \n    float ballOffsetX = sin(0.0 * iTime);\n    float ballOffsetZ = sin(0.0 * iTime);\n    \n    float d2 = 0.0;\n    \n    d2 = \n        pow(samplePoint.x, 7.) * \n        pow(samplePoint.y, 7.) * \n        pow(samplePoint.z, 7.);\n    \n    //d2 = \n    //    sin(6.*samplePoint.x)*sin(0.89*samplePoint.y * sin(iTime) * 5.0)*sin(0.08*samplePoint.z);\n    \n    float dist = sdSphere(samplePoint + vec3(ballOffsetX * 2.0,0,ballOffsetZ * 2.0), 3.0) + d2;\n    \n    return unionSDF(dist, sdBox(samplePoint, vec3(1, 1,1)));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface\n *  along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    testRotation += iTime * 0.2;\n    \n    eyePosition= vec3(cos(testRotation) * 5.0 ,0 ,sin(testRotation) * 5.0);\n    \n    //view space ray coming from the pixel\n    vec3 viewDir = rayDirection(iResolution.xy, fragCoord);\n \n    //get the view to world matrix\n    mat3 viewToWorld = viewMatrixToWorld(eyePosition, \n\t\tvec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    //transform the ray direction from view to world space\n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eyePosition, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        \n        //TODO: Cheap cubemap, replace with better \n        //fragColor = texture(iChannel0, worldDir);\n        fragColor = vec4(0,0,0,0);\n\n\t\treturn;\n    }\n    \n    //Calculate the normal of the intersection\n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eyePosition + dist * worldDir;\n    vec3 n = estimateNormal(p);\n    \n    //Note: to show normals\n    //fragColor = vec4(abs(n),1);\n    //return;\n    \n    ////// SIMPLE TEST PHONG LIGHT //////\n    vec3 lPos = vec3(eyePosition);// * -sin(iTime);\n    vec3 L = lPos - p; //light vector\n    float L_length = length(L);\n    L /= L_length;\n    \n    vec3 V = normalize(eyePosition - p); // view vector\n    \n    vec3 Kd = vec3(sin(iTime),abs(sin(iTime)),abs(cos(iTime))) * max(dot(n,L), 0.0);\n    vec3 H = normalize(L + V);\n    vec3 Ks = vec3(1,0.12,0.9) * pow(max(0.0, dot(n, H)), 40.0);\n    \n    // Output to screen\n    fragColor = vec4(Kd + Ks, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//const variables\nconst float PI = 3.141592653;\nconst float Two_PI = 2.0 * PI;\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_W     = 87.5/256.0;\n\n//Raymarching constants\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 cubeCenter = vec3(0);\nfloat cubeW = 10.0;\nfloat cubeH = 10.;\n\n// vertical field of view in degrees\nconst float fieldOfView = 120.0;\n\n#define SPOT_LIGHT 0\n#define DIRECTIONAL_LIGHT 1\n\nstruct Light\n{\n    vec3 position; \n    int lightType;\n    \n    vec3 lightColor;\n};\n    \n    \n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * imageSize: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(vec2 imageSize, vec2 fragCoord) {\n    vec2 xy = fragCoord - imageSize / 2.0;\n    float z = imageSize.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/////////////////////////////////////////////////////////////////\n//CAMERA\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nvec3 eyePosition = vec3(0.0, 0.0, 8.0);\nfloat testRotation = 0.;\n\nmat4 viewMatrix(vec3 eyePos, vec3 shapeCenter, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 front = normalize(shapeCenter - eyePos);\n    vec3 right = normalize(cross(front, up));\n    vec3 u = normalize(cross(right, front));\n    return mat4(\n        vec4(right, 0.0),\n        vec4(u, 0.0),\n        vec4(-front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat3 viewMatrixToWorld(vec3 eyePos, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eyePos);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/////////////////////////////////////////////////////////////////\n\n\n\n/////////////////////////////////////////////////////////////////\n//SDF - Shape primitives\n/*\nAll primitives are centered at the origin. You will have to transform the point to \nget arbitrarily rotated, translated and scaled objects (see below).\n*/\nfloat sdSphere(vec3 samplePoint, float radius) {\n    return length(samplePoint) - radius;\n}\n\nfloat sdBox( vec3 samplePoint, vec3 box ) {\n  return length(max(abs(samplePoint)-box, 0.0));\n}\n\n/////////////////////////////////////////////////////////////////\n\n\n/////////////////////////////////////////////////////////////////\n//SDF - Operations\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n/////////////////////////////////////////////////////////////////\n//Noise functions\nfloat Noise_2in_1out(vec2 inputVal)\n{\n    return fract(\n        sin(inputVal.x * 100. + inputVal.y*6574.) \n        * 5647.);\n}\n\nfloat SmoothNoise_2in_1out(vec2 inputVal, float gridCellSize)\n{\n       //OLD TV static effect\n   //float c = Noise_2in_1out(uv + vec2(sin(iTime), 0.0));\n    \n    //This line subdivides the screen in nxn grid spaces \n   \t//\teg(uv * 10. will be 10x10 grid\n    //Note: fract gets the decimal part of the float value\n    vec2 localUVcoordinates = fract(inputVal * gridCellSize);\n    \n    //alternate smoothstep\n    localUVcoordinates = localUVcoordinates * localUVcoordinates * (3. - 2. * localUVcoordinates);\n    \n    //Gets the id of the grid cell\n    //Note: floor returns the integer component of the decimal\n    vec2 gridCellID = floor(inputVal*gridCellSize);\n    \n    //Get the noise values at the 4 corners of the current grid cell\n    float bottomLeft = Noise_2in_1out(gridCellID);\n    float bottomRight = Noise_2in_1out(gridCellID + vec2(1,0));\n    float bottom = mix(bottomLeft, bottomRight, localUVcoordinates.x);\n    \n    float topLeft = Noise_2in_1out(gridCellID + vec2(0,1));\n    float topRight = Noise_2in_1out(gridCellID + vec2(1,1));\n    float top = mix(topLeft, topRight, localUVcoordinates.x);\n    \n    return mix(bottom, top, localUVcoordinates.y);\n}","name":"Common","description":"","type":"common"}]}