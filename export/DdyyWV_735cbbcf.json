{"ver":"0.1","info":{"id":"DdyyWV","date":"1696597220","viewed":174,"name":"Volumetric 3D Gaussian","username":"chronos","description":"I heard 3D gaussians are popular these days :)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","volumetric","box","gaussian","viewer"],"hasliked":0,"parentid":"DdGyDy","parentname":"Viewer Template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 quadratic_formula(float a, float b, float c)\n{\n    // 0 = b * x + c\n    // x = (0 - c) / b\n\n    if( a == 0.) return vec3(-c / b, 0, 0);\n\n    float discriminant = b * b - 4. * a * c;\n\n    float disc = sqrt(abs(discriminant));\n\n    vec3 result = \n        vec3(\n            (-b + disc) / (2. * a),\n            (-b - disc) / (2. * a),\n            float(discriminant > 0.)\n        );\n\n    return result;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    // o = ro - center\n    // p = o + rd * t\n    // dot(p, p) = r * r\n    // dot(o + rd * t, o + rd * t) = r * r\n    // dot(o,o) - r * r + 2. * t * dot(o, rd) + t * t * dot(rd, rd) = 0\n    \n    vec3 o = ro - center;\n    \n    float a = dot(rd, rd);\n    float b = 2. * dot(o, rd);\n    float c = dot(o, o) - radius * radius;\n    \n    float discriminant = b * b - 4. * a * c;\n    \n    if(discriminant < 0.)\n        return vec2(-1);\n    \n    float t1 = .5 * (sqrt(abs(discriminant)) - b) / a;\n    float t2 = .5 * (-sqrt(abs(discriminant)) - b) / a;\n    \n    float t_min = min(t1, t2);\n    float t_max = max(t1, t2);\n    \n    return vec2(t_min, t_max);\n}\n\nfloat RayPlane(vec3 ro, vec3 rd, vec3 center, vec3 normal)\n{\n    // dot(ro - center, normal) + t * dot(rd, normal) = 0.\n    return -dot(ro - center, normal) / dot(rd, normal);\n}\n\nvec2 RayBox(vec3 ro, vec3 rd, vec3 center, vec3 halfextents)\n{\n    vec3 t1, t2;\n    \n    // X planes\n    vec3 N = vec3(1, 0, 0);\n    t1.x = RayPlane(ro, rd, center + N * halfextents.x,  N);\n    t2.x = RayPlane(ro, rd, center - N * halfextents.x, -N);\n    \n    // Y planes\n    N = vec3(0, 1, 0);\n    t1.y = RayPlane(ro, rd, center + N * halfextents.y,  N);\n    t2.y = RayPlane(ro, rd, center - N * halfextents.y, -N);\n    \n    // Z planes\n    N = vec3(0, 0, 1);\n    t1.z = RayPlane(ro, rd, center + N * halfextents.z,  N);\n    t2.z = RayPlane(ro, rd, center - N * halfextents.z, -N);\n\n    float t_min = -1.;\n    float t_max = -1.;\n    vec3 p = vec3(0);\n    float pmax = 9e9;\n    \n    vec3 o = (ro - center);\n    \n    const float eps = 1e-3;\n    \n    for(int i = 0; i < 3; i++)\n    {\n        p = abs(t1[i] * rd + o);\n        pmax = max(p.x-halfextents.x, max(p.y-halfextents.y, p.z-halfextents.z));\n        if(((t1[i] < t_min) || t_min < 0.) && pmax <= eps) { t_min = t1[i]; }\n        if(((t1[i] > t_max) || t_max < 0.) && pmax <= eps) { t_max = t1[i]; }\n   \n        p = abs(t2[i] * rd + o);\n        pmax = max(p.x-halfextents.x, max(p.y-halfextents.y, p.z-halfextents.z));\n        if(((t2[i] < t_min) || t_min < 0.) && pmax <= eps) { t_min = t2[i]; }\n        if(((t2[i] > t_max) || t_max < 0.) && pmax <= eps) { t_max = t2[i]; }\n    }\n\n    return vec2(t_min, t_max);\n}\n\nfloat BoxDist(vec3 p, vec3 center, vec3 halfextents)\n{\n    vec3 o = abs(p - center) - halfextents;\n    \n    float d = min(max(o.x, max(o.y, o.z)), 0.);\n    \n    return length(length(max(o, 0.))) + d;\n}\n\nfloat SphereDist(vec3 p, vec3 center, float radius)\n{\n    return length(p - center) - radius;\n}\n\nfloat gaussian3D(vec3 mean, vec3 scale, vec3 axis, float angle, vec3 p)\n{\n    vec3 v = rot(p - mean, axis, angle);\n    return exp(-dot(v,scale * v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    float pix_size = 2. / iResolution.y;\n    float focal = 2.;\n\n    vec3 ro = vec3(0, 2, 4);               // TODO: Control translation\n    vec3 rd = normalize(vec3(uv, -focal)); // TODO: Control rotation + zoom/fov\n    \n    rd = rot(rd, vec3(1,0,0), -.5);\n    \n    float time = iTime * 1.;\n    \n    float angle = time;//-mouse.x * PI;\n    \n    ro = rot(ro, vec3(0,1,0), angle);\n    rd = rot(rd, vec3(0,1,0), angle);\n\n    vec3 color = vec3(0);\n\n    vec3 sphere_center = vec3(0, 0, 0);\n    float sphere_radius = 1.;\n\n    // Ray tracing\n    #if 1\n    {\n        vec2 T = RaySphere(ro, rd, sphere_center, sphere_radius);\n\n        T = RayBox(ro, rd, sphere_center, vec3(sphere_radius));\n\n        float t_enter = min(T.x, T.y);\n        float t_exit = max(T.x, T.y);\n        float t = T.x;\n        if(T.t >= 0. && (T.y < T.x)) t = T.y;\n\n        if(t > 0.)\n        {\n            vec3 p = rd * t + ro;\n            vec3 pos_color = (normalize(p - sphere_center) + 1.) / 2.;\n\n            float opacity = 0.9;\n            // Volume density integration\n            //color += (1.-exp(-(T.y - T.x))) * opacity;\n            color += exp(-2.5*(T.y - T.x)) * opacity * pos_color;\n            \n            // Replace lines with corresponding commented out code marked \"Alternate\" for an equivalent result\n            \n            float density = 0.; // 1.; // Alternate\n            float stepsize = 0.001;\n            \n            for(t = t_enter; t <= t_exit; t+=stepsize)\n            {\n                vec3 mean = sphere_center;\n                vec3 scale = vec3(24, 6, 1) * 5.;\n                vec3 axis = normalize(vec3(1,1,1));\n                float angle = 1.;//*iTime;\n\n                p = rd * t + ro;\n                float g = gaussian3D(mean, scale, axis, angle, p);\n                \n                density += g * stepsize;\n                //density *= (1.-g*stepsize); // Alternate\n            }\n            \n            color += 1.-exp(-density);\n            //color += 1.-density; // Alternate\n        }\n    }\n    #else\n    {\n        float t = 0.;\n        const int max_iter = 100;\n        // Sphere tracing\n        for(int i = 0; i < max_iter; i++)\n        {\n            vec3 p = ro + t * rd;\n            vec3 center = sphere_center;\n            float radius = 1.;\n            //float d = BoxDist(p, center, vec3(radius));\n            float d = SphereDist(p, center, radius);\n            if(d < 0.001)\n            {\n                \n                vec3 pos_color = (normalize(p - sphere_center) + 1.) / 2.;\n                color = pos_color;\n                break;\n            }\n            t+= d;\n        }\n    }\n    #endif\n    \n    color = tanh(color);\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    \n    // Project p onto axis:\n    vec3 proj = dot(axis, p) * axis;\n    \n    // Reject p from axis:\n    vec3 rjct = p - proj;\n    \n    // Construct helper axes ( such that cross(a, b) = axis ):\n    // Constructing the axes un-normalized allows up to skip multiplication by length(rjct) later\n    vec3 a = /*normalize*/(rjct);\n    vec3 b = cross(axis, a);\n    \n    vec3 result = // length(rjct) *\n        (cos(angle) * a + sin(angle) * b) + proj;\n    \n    return result;\n}","name":"Common","description":"","type":"common"}]}