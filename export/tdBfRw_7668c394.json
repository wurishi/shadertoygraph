{"ver":"0.1","info":{"id":"tdBfRw","date":"1589692986","viewed":179,"name":"Simulating the Colors of the Sky","username":"jamelouis","description":"https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926f;\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6f);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5f;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 16u;\n    uint numSamplesLight = 8u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3.f / (16.f * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaR * phaseR + sumM * betaM * phaseM) * 20.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy  * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float angle = M_PI / 2.0 * (fract(float(iFrame)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n    \n    float x = uv.x;\n    float y = uv.y;\n    float z2 = x*x + y*y;\n    \n    vec3 col = vec3(0.0);\n    if(z2 <= 1.){\n        float phi = atan(y,x);\n        float theta = acos(1.-z2);\n        vec3 dir = vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n        col = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir, 0., INFINITY, sunDirection);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}