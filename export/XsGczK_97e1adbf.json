{"ver":"0.1","info":{"id":"XsGczK","date":"1522544617","viewed":310,"name":"Square Matrix","username":"Hamneggs","description":"Classic DirecTV music channel animations, anyone? This is just the classic local-space grid trick combined with a trick triangle wave and some PRNs from that noise texture.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","oldschool","animation","square","matrix","directv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Update: Golfed version, with different square size and cooler transition.\n\n//#define G_DIM 12.0\n//#define TSCALE .2\n\n//#define hue(h) ( .6 + .6 * cos( 6.3 * (h)  + vec4(0,23,21,0)  ) )\n//#define grid(u,l,a) hue(iTime*.05+l*.0005)*step(max(u.x,u.y),.8)*a*.9;\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 u = U/12., i = floor(u), f = 2.*fract(u)-1.;\n    \n    // Texture lookup animation offset and triangle wave.\n    float o = texture( iChannel0, i.xx*12./iResolution.x ).r*127.12,\n          t = 1.-mod( (i.y*.33/12.) + (iTime*.2) + o, 4. );\n\n    // Grid color and shape.\n    vec4 g = ( .6 + .6 * cos( 6.3 * (iTime*.05+i.x*.0005)  + vec4(0,23,21,0)  ) )*\n             step(max(f.x,f.y),.8)*t;\n    \n    O = mix(g,1.-g, clamp(cos(iTime*.2)*4.,0.,1.));\n}\n\n/* Old version 1.0\n\n// IQ's smooth HSV.\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 shadeGrid( in vec2 uv, in vec2 g, in float anim )\n{\n    uv = abs(uv);\n    anim *= .9;\n    float square = smoothstep(.05,.2,1.0-max(uv.x,uv.y));\n    return hsv2rgb_smooth(vec3(iTime*.05+g.x*.0005,1,1))*square*anim;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Work relative to pixel count, rather than screen size.\n    vec2 uv = fragCoord/GRID_DIM;\n    \n    vec2 i = floor(uv); // Per square coordinates\n    \n    vec2 f = (fract(uv)-.5) * 2.0; // square-local [0,1] space\n    \n    // Texture lookup animation offset.\n    float offset = texture( iChannel0, vec2(i.x*GRID_DIM/iResolution.x) ).r*1234.12384;\n    \n    // Triangle wave with a healthy bit of darkness afterwards. It's also\n    // stretched and translated.\n    float tri = 4.0-mod( (i.y*.333/GRID_DIM) + (iTime*TIMESCALE) + offset, 4. );\n    tri = clamp(tri-3., 0., 1.);\n    \n    // Shade the grid.\n    vec3 norm = shadeGrid(f,i,tri);\n    \n    // Invert every once in a while.\n\tvec3 inv = 1.0-norm;\n    fragColor = vec4(mix(norm,inv, clamp(cos(iTime*TIMESCALE)*4.0,0.,1.)),1.);\n}\n*/","name":"Image","description":"","type":"image"}]}