{"ver":"0.1","info":{"id":"tddcD8","date":"1600885736","viewed":275,"name":"Specular quad sample","username":"Shcherbakov","description":"Sample written on the stream about specular quads.\nStream: https://www.youtube.com/watch?v=xQZD2B_gIkk","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["specular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Quad {\n    vec3 pos[4];\n    vec3 color;\n    vec3 normal;\n};\n\nconst float FAR_INF = 1e10;\nconst float EPS = 1e-3;\nconst float PI = 3.14159265359;\n    \nfloat ray_triangle_intersection(Quad q, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, q.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(q.pos[0] - origin, q.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[4] = vec3[4](\n        q.pos[1] - q.pos[0],\n        q.pos[2] - q.pos[1],\n        q.pos[3] - q.pos[2],\n        q.pos[0] - q.pos[3]\n    );\n    float square = length(cross(edges[0], edges[1])) + length(cross(edges[2], edges[3]));\n    vec3 toHitVecs[4] = vec3[4](\n        hitPos - q.pos[0],\n        hitPos - q.pos[1],\n        hitPos - q.pos[2],\n        hitPos - q.pos[3]\n    );\n    float testSq[4] = float[4](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2])),\n        length(cross(toHitVecs[3], edges[3]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2] - testSq[3]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat pow2(float x) { return x * x; }\n\nvec3 getLightSpecular(Quad light, vec3 worldPos, vec3 viewVec, vec3 normal, float specFactor) {\n    vec3 r = reflect(viewVec, normal);\n    float sp = 0.0;\n    for (int i = 0; i < 4; ++i) {\n        vec3 vi = normalize(light.pos[i] - worldPos);\n        vec3 vi1 = normalize(light.pos[(i + 1) % 4] - worldPos);\n        vec3 ni = -normalize(cross(vi, vi1));\n        vec3 ti = normalize(cross(vi, ni));\n        float c;\n        float delta;\n        {\n            float a = max(dot(vi, r), 1e-9);\n            float b = max(dot(ti, r), 1e-9);\n            c = sqrt(a * a + b * b);\n            delta = atan(b / a);\n        }\n        float Imin = 0.0;\n        float Imax = (pow(c, specFactor + 2.0) - 1.0) / (pow2(c) - 1.0);\n        float xw = PI / 3.0 * sqrt(1.0 - pow2(c - c / float(specFactor)));\n        float cosxw = cos(xw);\n        float fxw = c * cosxw;\n        float Ixw = (pow(fxw, specFactor + 2.0) - fxw) / (pow2(fxw) - 1.0);\n        float yw = (Ixw - Imin) / (Imax - Imin);\n        float a = (1.0 - yw - 4.0 * pow2(xw / PI)) / yw / pow2(xw);\n        float Pmax = 1.0 / (1.0 + a * pow2(0.0));\n        float Pmin = 1.0 / (1.0 + a * pow2(PI / 2.0));\n        float s = (Imax - Imin) / (Pmax - Pmin);\n        float t = Imin - s * Pmin;\n        float Phi = acos(dot(vi, vi1));\n        float sqrt_a = sqrt(a);\n        float F = s / sqrt_a * (\n            atan(sqrt_a * (Phi - delta)) - atan(-sqrt_a * delta)\n        ) + t * Phi;\n        float l = F * dot(ni, r);\n        sp += max(l, 0.0);\n\t}\n    return light.color * sp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 3, -5);\n    float AxisY = 0.5;\n    float AxisZ = 0.0;\n\tvec2 lightsPos[3];\n    for (int i = 0; i < 3; ++i) {\n        lightsPos[i] = vec2(sin(float(i) * 2.0 * PI / 3.0 + iTime) + 1.0, cos(float(i) * 2.0 * PI / 3.0 + iTime)) * 0.5;\n    }\n    float flagLerp = sin(iTime) * 0.5 + 0.5;\n    \n    Quad light;\n    light.pos = vec3[4](\n        vec3(-1.75, 0.0 + lightsPos[0].x, lightsPos[0].y),\n        vec3(-1.75, 0.5 + lightsPos[0].x, lightsPos[0].y),\n        vec3( 1.75, 0.5 + lightsPos[0].x, lightsPos[0].y),\n        vec3( 1.75, 0.0 + lightsPos[0].x, lightsPos[0].y)\n    );\n    light.color = mix(vec3(1, 0, 0), vec3(1, 1, 0), flagLerp);\n    light.normal = vec3(0, 0, -1);\n    Quad light2;\n    light2.pos = vec3[4](\n        vec3(-1.75, 0.0 + lightsPos[1].x, lightsPos[1].y),\n        vec3(-1.75, 0.5 + lightsPos[1].x, lightsPos[1].y),\n        vec3( 1.75, 0.5 + lightsPos[1].x, lightsPos[1].y),\n        vec3( 1.75, 0.0 + lightsPos[1].x, lightsPos[1].y)\n    );\n    light2.color = mix(vec3(0, 0, 1), vec3(1, 0, 0), flagLerp);\n    light2.normal = vec3(0, 0, -1);\n    \n    Quad light3;\n    light3.pos = vec3[4](\n        vec3(-1.75, 0.0 + lightsPos[2].x, lightsPos[2].y),\n        vec3(-1.75, 0.5 + lightsPos[2].x, lightsPos[2].y),\n        vec3( 1.75, 0.5 + lightsPos[2].x, lightsPos[2].y),\n        vec3( 1.75, 0.0 + lightsPos[2].x, lightsPos[2].y)\n    );\n    light3.color = mix(vec3(1, 1, 1), vec3(0, 0, 0), flagLerp);\n    light3.normal = vec3(0, 0, -1);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    vec3 front = normalize(vec3(0, -1, 2));\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = cross(right, front);\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n\n    // (cameraPos + viewVec * t).y = 0\n    float t = -cameraPos.y / viewVec.y;\n    vec3 worldPos = cameraPos + viewVec * t;\n    \n    vec3 color = texture(iChannel0, worldPos.xz).rgb;\n    vec3 floorNormal = normalize(vec3(0, 1, 0) + (texture(iChannel0, worldPos.xz).rgb * 2.0 - 1.0) * 0.2);\n    float specFactor = 32.0 * 2.0 + 1.0;\n    //specFactor = mix(2.0, 1024.0, clamp(worldPos.x * 0.5 + 0.5, 0.0, 1.0))) * 2.0 + 1.0;\n    float d = ray_triangle_intersection(light, cameraPos, viewVec);\n    bool lightIntersect = false;\n    if (d < t) {\n        color = light.color;\n        t = d;\n        lightIntersect = true;\n    }\n    d = ray_triangle_intersection(light2, cameraPos, viewVec);\n    if (d < t) {\n        color = light2.color; \n        t = d;\n        lightIntersect = true;\n    }\n    d = ray_triangle_intersection(light3, cameraPos, viewVec);\n    if (d < t) {\n        color = light3.color;\n        t = d;\n        lightIntersect = true;\n    }\n    if (!lightIntersect) {\n        color = getLightSpecular(light, worldPos, viewVec, floorNormal, specFactor) / 2.0 / PI;\n        color += getLightSpecular(light2, worldPos, viewVec, floorNormal, specFactor) / 2.0 / PI;\n        color += getLightSpecular(light3, worldPos, viewVec, floorNormal, specFactor) / 2.0 / PI;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}