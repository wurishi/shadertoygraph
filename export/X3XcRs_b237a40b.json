{"ver":"0.1","info":{"id":"X3XcRs","date":"1726527662","viewed":23,"name":"Emerald in frame 2","username":"skynex","description":"HW2","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["tpi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst vec3  lightGreen = vec3 ( 0.0, 0.0, 2.0 );\nconst vec3  lightRed = vec3 (0.0, 3.0, 1.0);\nconst vec3  lightBlue = vec3 (0.0, 0.0, 0.0);\nconst int   maxSteps = 50;\nconst float eps      = 0.01;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 6.0 ) + pow ( p.y, 6.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length8 ( p.xz ) - t.x, p.y);\n\treturn length8 ( q ) - t.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p, in mat3 m, out bool isRoundBox )\n{\n   vec3 q = m * p;\n   float roundBoxDist = sdRoundBox(q, vec3 ( 0.5, 0.5, 0.8), 1.0);\n   float torusDist = dTorus ( q, vec2 ( 1.0, 0.3 ) );\n   isRoundBox = roundBoxDist < torusDist;\n   \n   return smin(roundBoxDist, torusDist, 10.0);\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n   return smin(sdRoundBox(q, vec3 ( 0.5, 0.5, 0.8), 1.0), dTorus ( q, vec2 ( 1.0, 0.3 ) ), 10.0);\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, out bool isRoundBox )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m, isRoundBox );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float roughness = 0.2;\nconst vec3  r00   = vec3 ( 1.0, 0.92, 0.23 );\nconst vec3  r01   = vec3 ( 0.7, 0.7, 0.7 );\nconst float gamma = 2.2;\nconst float pi    = 3.1415926;\nconst float FDiel = 0.04;\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 stretch_texture(in vec3 n, in vec3 p, sampler2D channel){\n    n = abs(n);\n    return texture(channel, p.xy) * n.z + texture(channel, p.yz) * n.x + texture(channel, p.zx) * n.y;\n}\n\nvec4 get_texture(in vec3 normal, in vec3 p){\n    return stretch_texture(normal,p, iChannel0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit;\n\tbool isRoundBox;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = texture(iChannel2, dir);\n    vec3 p     = trace ( eye, dir, hit, m, isRoundBox );\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize      ( light - p );\n        vec3  lg = normalize      ( lightGreen - p );\n        vec3  lr = normalize      ( lightRed - p );\n        vec3  lb = normalize      ( lightBlue - p );\n        vec3  v  = normalize      ( eye - p );\n\t\tvec3  n  = generateNormal ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        float nlGreen = max(0.0, dot(n, lg));\n        float nlRed = max(0.0, dot(n, lr));\n        float nlBlue = max(0.0, dot(n, lb));\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n        vec3 normal = abs(n);\n        vec3 texel =\n            normal.x * texture(iChannel1, p.yz * 0.01).rgb +\n            normal.y * texture(iChannel1, p.xz * 0.01).rgb +\n            normal.z * texture(iChannel1, p.xy * 0.01).rgb;\n        if (isRoundBox) {\n            color += vec4(vec3(lg), 1.0);\n            color += vec4(vec3(lr), 1.0);\n            color += vec4(vec3(lb), 1.0);\n            color *= vec4(texel, 1.0);\n        } else {\n            vec3 localPos = inverse(m) * p;\n            color = vec4(vec3(l), 1.0);\n            color.rgb += vec3(0.0, 0.2, 0.0);\n            color.rgb += vec3(0.2, 0.0, 0.0);\n            color.rgb += get_texture(n, p).rgb;\n        }\n        \n\t}\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    rayDir = normalize(vec3(uv, 1.0));\n    rayDir = sin(rayDir * 120.0 + iTime * 3.0);\n    rayDir *= smoothstep(0.0, 1.0, rayDir);\n    float level = dot(rayDir, vec3(1.0, 0.8, 0.6));\n    if (level <= 0.3) {\n        fragColor = vec4(0.0, 0.0, 0.1, 1.0);\n    } else if (level <= 0.6) {\n        vec3 caveColor = mix(vec3(0.1, 0.2, 0.3), vec3(0.4, 0.1, 0.5), level);\n        fragColor = vec4(caveColor, 1.0);\n    } else {\n        vec3 glowColor = mix(vec3(0.2, 0.4, 0.5), vec3(0.4, 0.8, 0.4), level);\n        fragColor = vec4(glowColor, 1.0);\n    }\n    fragColor.rgb *= (0.5 + 0.5 * sin(iTime + level * 5.0));\n    \n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x += 10.0;\n    uv = sin(uv * 100.0 + iTime * 0.3);\n    uv *= uv;\n    float level = dot(uv, vec2(1.0));\n    vec4 emeraldColor;\n    if (abs(level) <= 0.5) {\n        emeraldColor = vec4(0.0, 0.8, 0.4, 1.0);\n    } else {\n        emeraldColor = vec4(0.0, 0.5, 0.7, 1.0);\n    }\n    fragColor = emeraldColor * (0.5 + 0.5 * sin(iTime + level * 10.0));\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}