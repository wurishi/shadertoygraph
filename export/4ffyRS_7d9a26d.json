{"ver":"0.1","info":{"id":"4ffyRS","date":"1721294915","viewed":27,"name":"Mitsubishi","username":"_TAU_","description":"demo","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pills"],"hasliked":0,"parentid":"X3cXRH","parentname":"Ray Marching Engine Easy"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV =  2.0;\nconst int MAX_STEPS = 500;\nconst float MAX_DIST = 120.0;\nconst float EPSILON = 0.008;\nconst float BLUR = .0003;\nconst float BASE = .00001;\n\nfloat mollyDist(vec3 p){\n\n    float t = 5.*iTime;\n\n    //main body\n    vec3 cyl_p = p;\n    pR(cyl_p.yz, PI/2.);\n    pR(cyl_p.xy, t);\n    float cylinder = sdRoundedCylinder( cyl_p, .5, .08, 0.2 );\n    \n    //logo\n    vec3 logo1_p = p;\n    pR(logo1_p.yz, -PI/2.);\n    pR(logo1_p.xy, -t);\n    pR(logo1_p.xz, 0.88*PI);\n    float logo1 = fRhombus(logo1_p+ vec3(0.4,0.3,0.), 0.35, 0.175, 0.1, 0.02 );\n    \n    vec3 logo2_p = p;\n    pR(logo2_p.yz, -PI/2.);\n    pR(logo2_p.xy, -t);\n    pR(logo2_p.xz, -PI/2.);\n    float logo2 = fRhombus(logo2_p+ vec3(0.4,0.3,0.), 0.35, 0.175, 0.1, 0.02 );\n    \n    vec3 logo3_p = p;\n    pR(logo3_p.yz, -PI/2.);\n    pR(logo3_p.xy, -t);\n    pR(logo3_p.xz, .094*PI);\n    float logo3 = fRhombus(logo3_p+ vec3(0.4,0.3,0.), 0.35, 0.175, 0.1, 0.02 );\n\n    //gap    \n    vec3 gsp_p = p;    \n    pR(gsp_p.xy, -PI/2.); \n    pR(gsp_p.yz, t);\n    float gap = sdRoundedCylinder( gsp_p  + vec3(0.,0.,.35) , .05, .08, .75 );\n\n    // result\n    float molly_dist = opSubtraction(logo1, cylinder);\n    molly_dist = opSubtraction(logo2, molly_dist);\n    molly_dist = opSubtraction(logo3, molly_dist);\n    molly_dist = opSubtraction(gap, molly_dist);\n    return molly_dist;\n\n}\n\nfloat repeated( vec3 p, float s )\n{\n    vec3 id = round(p/s);\n    vec3 r = p - s*round(p/s);\n    \n    r = vec3( ((int(id.x)&1)==0) ? -r.x : r.x,\n              ((int(id.y)&1)==0) ? -r.y : r.y, \n              ((int(id.z)&1)==0) ? -r.z : r.z\n             );          \n    \n    //logo rotation\n    pR(r.xy, iTime * hash1( 58. ));\n    \n    return mollyDist(r);\n}\n    \nvec2 map(vec3 p){\n// this function contains the distance functions of all objects and returns the closest one\n// using the union operator\n\n    vec3 p_E = p;\n    // falling effect\n    p_E.y +=  7. * iTime;\n    \n    vec2 obj = vec2(repeated(p_E, 18.), 1.0);\n    \n    return obj;\n\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd){\n// the rayMarch function returns a 2-dimensiona vector object in order to store\n// the distance to the object in the X component, and get the object ID ( it's color) \n// in the Y component\n    vec2 hit, object;\n    for(int i = 0; i < MAX_STEPS; i++){\n        // march the ray p ...\n        vec3 p = ro + object.x * rd;\n        // and compute distance from the objects\n        hit = map(p);\n        // update distance from the objects and ID\n        object.x += hit.x;\n        object.y = hit.y;\n        // stop is object is hit ( really small distance ) or ray has travelled to far away\n        if(abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p).x) - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 rd, vec3 color){\n// Lighting model based on the Lambert Law: \n// amount of reflected light is proportional to the scalar product of the vector\n// directed to the light source and the normal to the surface\n    vec3 lightPos = vec3(30., 40., -30.);\n    vec3 L = normalize(lightPos - p); // vector from surface element directed to the light source\n    vec3 N = getNormal(p);  \n    \n    // return N; //check normals\n    // compute the Lambert Law\n    vec3 diffuse = color * clamp(dot(L, N), 0.0, 1.0);\n    \n    // shadows\n    float d = rayMarch(p + N * 0.02, normalize(lightPos)).x; // cast ray from surface point p towards the light and get distance\n    // if the distance travelled from p to the ligth is lower that the distance from the point to the light, it means we've hit an object\n    // which is obstructing the light, so we cast a shadow for point p\n    if (d < length(lightPos - p)) return vec3(0.0);\n    \n    return diffuse;\n}\n\nvec3 getMaterial(vec3 p, float id) {\n// Gives the color based on the ID of the hit object\n    return vec3(0.1);\n}\n\nvoid render(inout vec3 col, in vec2 uv){\n    // sets ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    // sets ray directionS -> points towards xy plane \n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    vec3 bck_col = vec3(0.); // vec3(0., 1., 0.);\n    \n    vec2 object = rayMarch(ro, rd);\n    \n    if(object.x < MAX_DIST){\n        vec3 p = ro + object.x * rd;\n        vec3 material = getMaterial(p, object.y);\n        col += getLight(p, rd, material);\n        col = smoothstep(BASE-BLUR,BASE+BLUR,col);\n        // remove crappy background elements\n        if(object.x > 72.){\n            col = bck_col;\n        }\n        \n    }else{\n        col = bck_col;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (x,y in (-1,1))\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) /iResolution.y;\n\n    vec3 col;\n    //AA setting\n    int aa_factor = 4;\n    \n    // Supersampling - nxn grid within each pixel\n    for(int x = 0; x < aa_factor; x++) {\n        for(int y = 0; y < aa_factor; y++) {\n            // Offset for each sample - shifts within the pixel grid\n            vec2 offset = vec2(x, y) * (1. / float(aa_factor)) / iResolution.y;\n            // Adjusted UV for current sample\n            vec2 sampleUV = uv + offset;\n            // Render scene for this sample\n            vec3 sampleColor;\n            render(sampleColor, sampleUV);\n            col += sampleColor;\n        }\n    }\n\n    // Average the color from the samples\n    col /= float(aa_factor * aa_factor);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat fRhombus( vec3 p, float la, float lb, float h, float ra )\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             RANDOM\n//\n////////////////////////////////////////////////////////////////\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\n\n","name":"Common","description":"","type":"common"}]}