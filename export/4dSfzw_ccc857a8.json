{"ver":"0.1","info":{"id":"4dSfzw","date":"1499935043","viewed":407,"name":"Spherical mask","username":"Ultraviolet","description":"Fork of [url]https://www.shadertoy.com/view/Xdf3zB[/url]\nUse the mouse to move the camera.\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sphere","scattering","mask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork from https://www.shadertoy.com/view/Xdf3zB\n// Experiment on light scattering by Ulysse Vimont (aka Ultraviolet)\n\n#define PI\t\t\t\t3.1415926535\n#define SIGMA\t\t\t2.0\n#define STEP_COUNT\t\t64\n#define DIST_MAX\t\t10.0\n#define LIGHT_POWER\t\t10.0\n#define SURFACE_ALBEDO\t0.1\n#define EPS\t\t\t\t0.01\n\n#define LIGHT_COLOR\t\tvec3(0.9, 0.77, 0.27)\n#define LIGHT_POS\t\tvec3(0.0)\n#define SPHERE_POS\t\tvec3(0.0)\n#define SPHERE_RAD\t\t0.25\n\n// shamelessly stolen from iq!\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// also stolen from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nbool mask(vec3 p)\n{\n    //return noise(p*100.0+vec3(iTime))> 0.5;\n    return noise(p*75.0+vec3(0.0, iTime, 0.0))> 0.5;\n    \n    float period = 0.1;\n    //float period = 0.1 + 0.05*cos(iTime);\n    vec3 disp = vec3(iTime)*0.01*vec3(3.0, 5.0, 7.0);\n    p += disp;\n    \n    bool res;\n    res =  mod(p.x, period)>0.5*period ;\n    res = (mod(p.y, period)>0.5*period)?res:!res;\n    res = (mod(p.z, period)>0.5*period)?res:!res;\n    return res;\n}\n\nvoid intersectSphere(vec3 ro, vec3 rd, vec3 spherePosition, float sphereRadius, inout float t, out vec3 n)\n{    \n    float delta = pow(dot(rd, ro) - dot(spherePosition,rd), 2.0) - (dot(spherePosition, spherePosition)+dot(ro,ro)-20.*dot(spherePosition, ro)-sphereRadius*sphereRadius);\n    \n    if(delta < 0.0)\n    \treturn;\n    delta = sqrt(delta);\n    float t1 = dot(spherePosition, rd) - dot(rd, ro) - delta;\n    float t2 = t1 + 2.0*delta;\n    \n    float t_ = (t1 > 0.0 && mask(ro+t1*rd)) ? t1 : mask(ro+t2*rd) ? t2 : t;\n    t = min(t, t_);\n    n = normalize(ro+t*rd - spherePosition);\n}\n\nvoid intersectScene(\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tinout float rayT,\n\tinout vec3 geomNormal)\n{\n\tintersectSphere(rayOrigin, rayDir, SPHERE_POS, SPHERE_RAD, rayT, geomNormal);\n}\n\nvoid sampleEquiAngular(\n\tfloat u,\n\tfloat maxDistance,\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 lightPos,\n\tout float dist,\n\tout float pdf)\n{\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(lightPos - rayOrigin, rayDir);\n\t\n\t// get distance this point is from light\n\tfloat D = length(rayOrigin + delta*rayDir - lightPos);\n\n\t// get angle of endpoints\n\tfloat thetaA = atan(0.0 - delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\t\n\t// take sample\n\tfloat t = D*tan(mix(thetaA, thetaB, u));\n\tdist = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    \n\tvec3 lightPos = vec3(0.0);\n\tvec3 lightIntensity = vec3(LIGHT_POWER);\n\tvec3 surfIntensity = vec3(SURFACE_ALBEDO/PI);\n\tvec3 particleIntensity = vec3(1.0/(4.0*PI));\n    \n    float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n    float psi = -((iMouse.y-0.5)/iResolution.y-0.5) * PI;\n    \n    if(iMouse.x<1.0 && iMouse.y < 1.0)\n    {\n        phi = iTime * PI * 2.0*0.1;\n        psi = cos(iTime*PI*2.0*0.1)*PI*0.25;\n    }\n    \n    vec3 cameraPosition = 2.0*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n    vec3 cameraTarget = vec3(0.0);\n    mat3 m = setCamera(cameraPosition, cameraTarget, 0.0);\n\t\n\tvec3 rayOrigin, rayDir;\n    rayOrigin = cameraPosition;\n    rayDir = m*normalize(vec3(p, 3.5));\n\t\n\tvec3 col = vec3(0.0);\n\tfloat t = DIST_MAX;\n\t{\n\t\tvec3 n;\n\t\tintersectScene(rayOrigin, rayDir, t, n);\n\t\t\n\t\tif (t < DIST_MAX) {\n\t\t\t// connect surface to light\n\t\t\tvec3 surfPos = rayOrigin + t*rayDir;\n\t\t\tvec3 lightVec = lightPos - surfPos;\n\t\t\tvec3 lightDir = normalize(lightVec);\n\t\t\tvec3 cameraDir = -rayDir;\n\t\t\tfloat nDotL = dot(n, lightDir);\n\t\t\tfloat nDotC = dot(n, cameraDir);\n\t\t\t\n\t\t\t// only handle BRDF if entry and exit are same hemisphere\n\t\t\tif (nDotL*nDotC > 0.0) \n            {\n\t\t\t\tfloat d = length(lightVec);\n                float t2 = d;\n                vec3 n2;\n                vec3 rayDir = normalize(lightVec);\n\t\t\t\tintersectScene(surfPos + EPS*rayDir, rayDir, t2, n2);\n                \n                // accumulate surface response if not occluded\n                if (t2 == d) {\n\t\t\t\t\tfloat trans = exp(-SIGMA*(d + t));\n\t\t\t\t\tfloat geomTerm = abs(nDotL)/dot(lightVec, lightVec);\n\t\t\t\t\tcol = surfIntensity*lightIntensity*geomTerm*trans;\n                }\n\t\t\t}\n            else\n            {\n                col = vec3(0.02, 0.01, 0.0);\n            }\n\t\t}\n\t}\n\t\n\tfloat offset = hash(fragCoord.y*iResolution.x + fragCoord.x + iTime);\n\tfor (int stepIndex = 0; stepIndex < STEP_COUNT; ++stepIndex) {\n\t\tfloat u = (float(stepIndex)+offset)/float(STEP_COUNT);\n\t\t\n\t\t// sample along ray from camera to surface\n\t\tfloat x;\n\t\tfloat pdf;\n\t\tsampleEquiAngular(u, t, rayOrigin, rayDir, lightPos, x, pdf);\n\t\t\n\t\t// adjust for number of ray samples\n\t\tpdf *= float(STEP_COUNT);\n\t\t\n\t\t// connect to light and check shadow ray\n\t\tvec3 particlePos = rayOrigin + x*rayDir;\n\t\tvec3 lightVec = lightPos - particlePos;\n\t\tfloat d = length(lightVec);\n\t\tfloat t2 = d;\n\t\tvec3 n2;\n\t\tintersectScene(particlePos, normalize(lightVec), t2, n2);\n\t\t\n\t\t// accumulate particle response if not occluded\n\t\tif (t2 == d) {\n\t\t\tfloat trans = exp(-SIGMA*(d+x)*1.0);\n\t\t\tfloat geomTerm = 1.0/dot(lightVec, lightVec);\n\t\t\tcol += SIGMA*particleIntensity*lightIntensity*geomTerm*trans/pdf*LIGHT_COLOR;\n\t\t}\n\t}\n\t\n\tcol = pow(col, vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}