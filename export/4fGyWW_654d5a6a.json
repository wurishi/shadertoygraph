{"ver":"0.1","info":{"id":"4fGyWW","date":"1731841882","viewed":82,"name":"Atmosphere Attempt","username":"s_fx","description":"bw atmospheric scattering","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["sdf","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* (c) 2024 s.fx */\n\nconst int   I  = 128;  // max iterations\nconst float A  = 7.5;  // inverse atmosphere scale (density)\nconst float MA = 100.; // max distance\nconst float MI = .001; // min distance\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x   *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);          // output color\n    vec3  ro = vec3(0., 0., -2.); // ray origin position\n    vec3  rd = vec3(uv, 1.);      // ray direction\n    float dt = 0.;                // distance traveled (multiple of rd)\n    float ds = 0.;                // distance from sphere\n    float dm = -1.;               // distance minimum to sphere\n    vec3  p  = ro;                // current position of ray\n    vec3  c  = vec3(0.);          // sphere center\n    vec3  l  = vec3(sin(.25*iTime) * -2., sin(iTime * .2) * 2., cos(.25*iTime) * -4.); // rotating light\n    \n    for (int i = 0; i < I; i++)\n    {\n        p   = ro + rd * dt;\n        ds  = length(c - p) - 1.;\n        dt += ds;\n        \n        // if minimum not set or ray is moving closer\n        if (dm == -1. || ds < dm)\n            dm = ds;\n        \n        // if ray touches surface\n        if (ds <= MI)\n        {\n            col = vec3(max(dot(normalize(c - p), normalize(p - l)), 0.));\n            break;\n        }\n        \n        // if ray is moving away from sphere\n        if (ds >= MA)\n        {\n            // if ray dir close to light set white (draws little sun)\n            if (dot(normalize(rd), normalize(l - ro)) > .9999)\n                col = vec3(1.);\n            // else draw atmosphere\n            else\n                // atmosphere = max(1 - minimum distance from planet * density, 0)\n                // opacity    = max(ray direction * light direction, 0)\n                // color      = opacity * atmosphere\n                // i also added some offset to the opacity so the atmosphere doesn't look to cut off\n                col = vec3(max(dot(normalize(rd), normalize(l - ro)) + .15, 0.) / 1.15 * max(1. - dm * A, 0.));\n            \n            break;\n        }\n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}