{"ver":"0.1","info":{"id":"lllcWX","date":"1506735307","viewed":905,"name":"CIE 1931 xy chromaticity diagram","username":"Tynach","description":"Shows the gamut and white point for an RGB colorspace.\n\nNow modified to accurately portray the cyan portion of the spectrum that's out of gamut.\n\nHeavily cleaned up the gamut scaling part. Removed most of the commented out code, for example.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["rgb","xyz","colorspace","gamut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/******************************************************************************\n * Scroll to just above the functions to change the parameters used to draw   *\n * the diagram                                                                *\n ******************************************************************************/\n\nprecision highp float;\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n\n\t// Gamma-corrected values should be in the range 16-235\n\tbool tvRange;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 whitePoint;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define \\\nprimaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\tr1, r2, 1.0 - r1 - r2,\\\n\t\tg1, g2, 1.0 - g1 - g2,\\\n\t\tb1, b2, 1.0 - b1 - b2)\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define \\\nwhite(x, y)\\\n\tvec3(x, y, (1.0 - x - y))\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define \\\ndiag(v)\\\n\tmat3(\\\n\t\tv.x, 0.0, 0.0,\\\n\t\t0.0, v.y, 0.0,\\\n\t\t0.0, 0.0, v.z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define \\\nrgbToXyz(space)\\\n\tspace.primaries*diag((inverse(space.primaries)*(space.whitePoint/space.whitePoint.y)))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define \\\nxyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define \\\nconversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// Original CIE RGB primaries, formed from monochromatic (single-wavelength) colors:\n// R = 700nm, G = 546.1nm, B = 435.8nm\nconst mat3 primariesCie = primaries(\n\t0.734690, 0.265310,\n\t0.273675, 0.717432,\n\t0.166536, 0.008881\n);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// Never-popular and antiquated 'HDTV' primaries based mostly on 1953 NTSC\nconst mat3 primaries240m = primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC and Rec. 601 (525 lines)\nconst mat3 primariesSmpteC = primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = white(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = vec3(1.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = white(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = white(0.312713, 0.329016);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = white(0.34567, 0.35850);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = white(0.283, 0.298);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0, true);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0, true);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0, true);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0, true);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018, true);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308, false);\n\n// This is sRGB's gamma, but set to TV value ranges (16-235)\nconst transfer gamSrgbTv = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308, true);\n\n\n/*\n * RGB Colorspaces\n */\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma and full range values)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// Same as sRGB, but with limited range values (16-235)\nconst rgb_space SrgbTv = rgb_space(primaries709, whiteD65, gamSrgbTv);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65, gam170m);\n\n\n/*************************************************************************\n * Change these to change what colorspace is being converted from/to     *\n * Note: since the output is designed to look correct on displays using  *\n * the 'to' colorspace, you might want to set 'toTrc.tvRange' to 'false' *\n *************************************************************************/\nconst transfer fromTrc = gamSrgb;\nconst transfer toTrc = gamSrgb;\nconst rgb_space from = rgb_space(primaries709, whiteD65, fromTrc);\nconst rgb_space to = rgb_space(primaries709, whiteD65, toTrc);\n\n\n/*\n * Conversion Functions\n */\n\n// Converts RGB colors to a linear light scale\nvec4 toLinear(vec4 color, const transfer trc)\n{\n\tif (trc.tvRange) {\n\t\tcolor = color*85.0/73.0 - 16.0/219.0;\n\t}\n\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\tvec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec4 toGamma(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\tvec4 neg = (-1.0 - trc.off)*pow(-1.0*color, vec4(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\tif (trc.tvRange) {\n\t\tcolor = color*73.0/85.0 + 16.0/255.0;\n\t}\n\n\treturn color;\n}\n\n// Scales a color to the closest in-gamut representation of that color\nvec4 gamutScale(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = (high - 1.0)/(high - luma);\n\tfloat scale = max(lowScale, highScale);\n\tcolor.rgb += scale*(luma - color.rgb);\n\n\treturn color;\n}\n\n// Converts from xy to RGB\nvec4 convert(vec4 color)\n{\n\tfloat luma = 1.001;\n\n\tconst mat3 toRGB = xyzToRgb(from);\n\tconst mat3 toXYZ = rgbToXyz(from);\n\tconst mat3 convert = conversionMatrix(from, to);\n\n\t// Convert from xyY to XYZ, then RGB\n\tcolor.xyz *= luma/color.y;\n\tcolor.rgb = toRGB*color.xyz;\n\n\t// Max normalization\n\t//color.rgb /= max(color.r, max(color.g, color.b));\n\n\t// Standard Euclidian normalization (equivalent to 'norm = 2.0' below)\n\t//color.rgb = normalize(color.rgb);\n\n\t// Custom normalization for brighter white point\n\t// Wikipedia's chart roughly uses 'norm = 5.0'\n\tconst float norm = 4.0;\n\tcolor.rgb /= pow(dot(pow(abs(color.rgb), vec3(norm)), vec3(1.0)), 1.0/norm);\n\n\t// Wikipedia's description for one of their chromaticity diagrams claims\n\t// that the top left should have more cyan than most charts do. This\n\t// is solved by scaling out-of-gamut colors to be in-gamut\n\tcolor = gamutScale(color, luma);\n\n\t// Scale colors so that the highest RGB value for the white point or primaries\n\t// of the 'from' colorspace, is scaled to equal 1.0 in the 'to' colorspace\n\tconst vec3 newCyan = convert*vec3(0, 1, 1);\n\tconst vec3 newMagenta = convert*vec3(1, 0, 1);\n\tconst vec3 newYellow = convert*vec3(1, 1, 0);\n\tconst vec3 newWhite = convert*vec3(1);\n\tconst vec3 maxColors =\n\t\tmax(convert[0], max(convert[1], max(convert[2],\n\t\tmax(newCyan, max(newMagenta, max(newYellow, newWhite))))));\n\n\tcolor.rgb /= max(maxColors.r, max(maxColors.g, maxColors.b));\n\n\t// Grab new luma values to emulate display brightness more accurately\n\tluma = (toXYZ*color.rgb).y;\n\n\t// Convert from one colorspace to another, to show how one display\n\t// might show the colorspace of another\n\tcolor.rgb = convert*color.rgb;\n\tcolor = gamutScale(color, luma);\n\n\tcolor = toGamma(color, to.trc);\n\n\treturn color;\n}\n\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n\t// Chromaticities are usually charted with a max of (0.8, 0.9), so I'm\n\t// scaling it to max out at 0.9, then centering it\n\tconst vec2 bounds = vec2(0.8, 0.9);\n\tcolor.xy = bounds.y*fragCoord/iResolution.y;\n\tcolor.x -= (bounds.y*iResolution.x/iResolution.y - bounds.x)/2.0;\n\tcolor.z = 1.0 - color.x - color.y;\n\n\tcolor = convert(color);\n}","name":"Image","description":"","type":"image"}]}