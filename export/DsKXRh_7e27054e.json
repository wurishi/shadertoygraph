{"ver":"0.1","info":{"id":"DsKXRh","date":"1680783356","viewed":86,"name":"Inside the clouds Altin","username":"devkosov","description":"clouds","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/DdGXzz\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance value from SDF\n  Material mat; // material of object\n};\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial cloudsColor() {\n  vec3 aCol = .8 * vec3(193,190,186) / 255.;\n  vec3 dCol = .5 * vec3(193,190,186) / 255.;\n  vec3 sCol = .8 * vec3(193,190,186) / 255.;\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat hash13(vec3 p) {\n    return fract(sin(dot(p,vec3(12.9898,78.233,45.5432)))*43758.5453123);\n}\n\nfloat vnoise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(p+vec3(0.,0.,0.)),hash13(p+vec3(1.,0.,0.)),f.x),\n                      mix(hash13(p+vec3(0.,1.,0.)),hash13(p+vec3(1.,1.,0.)),f.x),f.y),\n                mix(mix(hash13(p+vec3(0.,0.,1.)),hash13(p+vec3(1.,0.,1.)),f.x),\n                      mix(hash13(p+vec3(0.,1.,1.)),hash13(p+vec3(1.,1.,1.)),f.x),f.y),f.z);\n}\n\nfloat sdSphere(vec3 p, float r,vec3 offset)\n{\n    return length(p - offset) - r;\n}\n\nfloat sdFloor(vec3 p) {\n  return p.y + 1.;\n}\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nSurface opSmoothUnionSurface(Surface s1, Surface s2, float k, Material mat)\n{\n    float d1 = s1.sd;\n    float d2 = s2.sd;\n\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    float sd = mix(d2, d1, h) - k * h * (1.0 - h);\n\n    Material finalMat = mat;\n    if (s1.id != s2.id)\n    {\n        finalMat.ambientColor = mix(s1.mat.ambientColor, s2.mat.ambientColor, h);\n        finalMat.diffuseColor = mix(s1.mat.diffuseColor, s2.mat.diffuseColor, h);\n        finalMat.specularColor = mix(s1.mat.specularColor, s2.mat.specularColor, h);\n        finalMat.alpha = mix(s1.mat.alpha, s2.mat.alpha, h);\n    }\n\n    int finalId = (d1 < d2) ? s1.id : s2.id;\n    return Surface(finalId, sd, finalMat);\n}\n\nfloat opUnion( float d1, float d2 ) \n{ \n    return min(d1,d2); \n}\n\nSurface cloud(int id, vec3 p, vec3 b, float e, vec3 col )\n{\n    p = abs(p  )-b;\n    vec3 q = abs(p+e)-e;\n    float d =  min(min(\n    length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n    length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n    length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    \n  //d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.0;\n\n  d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);  \n  float sphere = sdSphere(p,0.001,vec3(-.01));\n  \n  float res = opSmoothUnion(d,sphere,clamp(abs(sin(iTime/5.)),.75,1.25) );\n  \n  return Surface(1,res, gold());\n}\n\nSurface applyWaveEffect(Surface s, vec3 p, float waveAmplitude, float waveFrequency)\n{\n    float waveOffset = waveAmplitude * \n                        sin(iTime /4. * waveFrequency + p.x) * \n                        sin(iTime /4. * waveFrequency + p.y) * \n                        sin(iTime /4. * waveFrequency + p.z);\n                        \n    float animatedSD = s.sd + waveOffset;\n    return Surface(s.id, animatedSD, s.mat);\n}\n\nSurface clouds( in int id, in vec3 p, in vec3 b, in float e, in vec3 col, in float c )\n{\n    if (id == 1){\n        vec3 q = vec3(mod(p.x * c, c) - 0.5 * c, p.y, mod(p.z - iTime/5. + 0.5 * c, c) - 0.5 * c);\n        return cloud(id,q, b, e, col);\n    }else{\n        vec3 q = vec3(mod(p.x * c, c) - 0.5 * c, p.y, mod(p.z + iTime/6. + 0.5 * c, c) - 0.5 * c);\n        return cloud(id,q, b, e, col);\n    }\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n    \n    p.x = p.x + .5 * sin(p.z * 2. + iTime);\n    p.y = p.y + .2 * sin(p.x * 2. + iTime );\n    p.z = p.z + .15 * sin(p.y * 2. + iTime );\n    \n    Surface bottomGrid = clouds(1, p, vec3(.2,0.0,.2), 0.025, vec3(1.,0.25,0.4), .5);\n    Surface topGrid = clouds(2,p - vec3(0,1.5,0), vec3(0.4,0.0,.2), 0.025, vec3(1.,0.25,0.25), .6);\n  \n    Surface co = opSmoothUnionSurface(bottomGrid, topGrid, 0.25, cloudsColor());\n    \n    Surface res = applyWaveEffect(co, p, 0.2, .6);\n    res = applyWaveEffect(res, p, 0.5, .8);\n  \n    return res;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = sdScene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //vec3 backgroundColor = vec3(0.85, .95, 1);\n    //vec3 backgroundColor = 0.5 +0.5*uv.xyx+vec3(.5,.75,.95);\n    // Gradient color\n    vec3 col1 = vec3(200, 230, 255) / 255.0;\n    vec3 col2 = vec3(84, 185, 255) / 255.0;\n\n    // Center of the gradient\n    vec2 center = vec2(0, 1);\n\n    // Gradiant\n    vec3 backgroundColor = mix(col2, col1, distance(uv, center));\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 0.75, 1.5); // ray origin that represents camera position\n\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\n    vec3 rd = normalize(vec3(uv, -1)); // ray direction\n    rd *= rotateY(-mouse.x * 5.); // apply yaw and pitch\n\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n    if (co.sd > MAX_DIST) {\n        col = backgroundColor; // ray didn't hit anything\n    } else {\n        vec3 p = ro + rd * co.sd; // point on sphere or floor we discovered from ray marching\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(0, 15, -5);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection clamped between zero and one\n        float softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.7, 1.0);\n\n        col = (dif*1.3) * phong(lightDirection, normal, rd, co.mat) * softShadow;\n\n        col = mix(col, backgroundColor, 1. - exp(-0.01 * co.sd * co.sd * co.sd)); // fog\n      }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}