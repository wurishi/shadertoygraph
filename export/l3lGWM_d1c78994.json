{"ver":"0.1","info":{"id":"l3lGWM","date":"1707732537","viewed":34,"name":"[inspirnathan] 14 - snowman","username":"hrst4","description":"[inspirnathan] 14 - snowman","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/61-snowman-shader-in-shadertoy/\n// [0-22]\n#define PART 0\n\n/*\nhttps://inspirnathan.com/_nuxt/img/gif-1.ae894df.gif\n\nVoulez-vous construire un homme de neigennnnnnnn ?\n\nAllez, on y va et on code.\n\nCroyez-moi, ce ne sera pas ennuyeux.\n\nPréparez votre clavier.\n\nIl est temps de faire marcher les rayonsyyyyyyyy !!!!\n\nBonjour, chers amis ! Vous êtes arrivés jusqu'ici dans votre voyage Shadertoy ! \nJ'en suis très fier ! Même si vous n'avez lu aucun de mes articles précédents et que vous avez atterri ici depuis Google,\nje suis quand même fier que vous ayez visité mon site. \n\nSi vous êtes nouveau à Shadertoy ou même aux shaders en général, veuillez visiter la partie 1 de ma série de tutoriels Shadertoy:\nhttps://inspirnathan.com/posts/47-shadertoy-tutorial-part-1\n\nDans cet article, je vais vous montrer comment faire un shader de bonhomme de neige en utilisant les leçons de ma série \nde tutoriels Shadertoy. \n\nNous allons créer un bonhomme de neige simple, ajouter de la couleur en utilisant des structs, \net ensuite ajouter beaucoup de détails à notre scène pour créer un shader incroyable !\n\n\n# Setup initial\n\nNous allons commencer par le modèle de ray marching que nous avons utilisé au début de la partie 14 de ma série de tutoriels Shadertoy.\n\nLorsque vous exécutez ce code, vous devriez voir une sphère apparaître au centre de l'écran. \nCela ressemble un peu à une boule de neige, n'est-ce pas ?\n\nhttps://inspirnathan.com/_nuxt/img/img-1.352bf2a.png\n*/\n\n#if PART == 0\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat scene(vec3 p) {\n  return sdSphere(p, 1., vec3(0, 0, 0));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Construction d'un modèle de bonhomme de neige\n\nLorsque l'on construit des modèles 3D à l'aide du ray marching, il est préférable de réfléchir aux SDF\ndont on aura besoin pour construire un bonhomme de neige. \n\nUn bonhomme de neige est généralement fabriqué à l'aide de deux ou trois sphères. \nPour notre bonhomme de neige, nous allons rester simples et le construire en utilisant seulement deux sphères.\n\nDessinons deux sphères dans la scène. Nous pouvons utiliser la fonction opUnion que nous avons apprise dans la partie 14\npour dessiner plus d'une forme dans la scène.\n\nNous avons déjà utilisé cette fonction dans les tutoriels précédents.\nElle prend simplement la \"distance signée\" minimale entre deux SDF.\n\n*/\n\n#elif PART == 1\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  \n  return opUnion(bottomSnowball, topSnowball);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nTout de suite, vous pouvez voir que notre bonhomme de neige commence à prendre forme, \nmais il semble maladroit à l'intersection où les deux sphères se rencontrent.\n\nComme nous l'avons appris dans la partie 14 de ma série de tutoriels Shadertoy, nous pouvons mélanger deux formes \nen douceur en utilisant la fonction opSmoothUnion ou la fonction smin, si vous voulez utiliser un nom plus court.\n\nhttps://inspirnathan.com/_nuxt/img/img-3.c0d8fee.png\n\n*/\n\n#elif PART == 2\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  \n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  return d;\n}\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nC'est beaucoup mieux ! Il manque cependant des yeux au bonhomme de neige. \nLes gens ont tendance à leur donner des yeux en utilisant des boutons ou d'autres objets ronds. \nNous allons donner à notre bonhomme de neige des yeux sphériques. Commençons par l'œil gauche.\n\nhttps://inspirnathan.com/_nuxt/img/img-4.980b155.png\n\n*/\n\n#elif PART == 3\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  float leftEye = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  \n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  return d;\n}\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nL'oeil droit utilisera la même valeur de décalage que l'œil gauche, à l'exception de l'axe des x qui sera inversé.\n\nhttps://inspirnathan.com/_nuxt/img/img-5.b671f50.png\n*/\n\n#elif PART == 4\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  float leftEye = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  float rightEye = sdSphere(p, .1, vec3(0.2, 0.6, 0.7));\n  \n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  return d;\n}\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nEnsuite, le bonhomme de neige a besoin d'un nez. \nLes gens ont tendance à fabriquer des nez de carottes pour les bonshommes de neige.\nNous pouvons simuler un nez de carotte en utilisant un SDF de cône de la liste des SDF 3D d'Inigo Quilez.\nNous choisirons le SDF appelé \"Cone - bound (not exact)\" qui a la déclaration de fonction suivante :\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nNous devons également ajouter un paramètre de décalage à cette fonction, \nafin de pouvoir déplacer le cône dans l'espace 3D. Nous obtenons donc la déclaration de fonction suivante pour le cône SDF.\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nPour utiliser ce SDF, nous devons créer un angle pour le cône. \nPour cela, il faut jouer un peu avec la valeur. Une valeur de 75 degrés semble convenir.\nVous pouvez utiliser la fonction radians intégrée au langage GLSL pour convertir un nombre de degrés en radians.\nLes paramètres c et h sont utilisés pour contrôler les dimensions du cône.\n\nAjoutons un nez à notre bonhomme de neige !\n\nhttps://inspirnathan.com/_nuxt/img/img-6.d4d2125.png\n\nVous pouvez utiliser votre souris pour déplacer la caméra autour du bonhomme de neige afin de vous assurer que le cône est bien visible.\n\nhttps://inspirnathan.com/_nuxt/img/img-7.02cf46a.png\n\n*/\n\n#elif PART == 5\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n\n  float leftEye = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  float rightEye = sdSphere(p, .1, vec3(0.2, 0.6, 0.7));\n\n  float noseAngle = radians(75.);\n  float nose = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n\n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  return d;\n}\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nAjoutons des bras au bonhomme de neige. \nGénéralement, les bras sont faits de bâtons. \nNous pouvons simuler des bâtons en utilisant une ligne 3D ou une \"capsule\".\nDans la liste des SDF 3D d'Inigo Quilez, il y a un SDF appelé \"Capsule / Line - exact\" que nous pouvons utiliser \npour construire un bras de bonhomme de neige.\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nAjoutez un paramètre de décalage à cette fonction, afin de pouvoir déplacer la capsule dans l'espace 3D.\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nEnsuite, nous ajouterons une capsule dans notre scène 3D pour simuler le bras gauche du bonhomme de neige.\n\nhttps://inspirnathan.com/_nuxt/img/img-8.51c042d.png\n*/\n\n#elif PART == 6\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n\n  float leftEye = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  float rightEye = sdSphere(p, .1, vec3(0.2, 0.6, 0.7));\n\n  float noseAngle = radians(75.);\n  float nose = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n\n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, mainBranch);\n  return d;\n}\n\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLe bras semble un peu trop petit et un peu maladroit. \nAjoutons quelques petites capsules qui se ramifient à partir du bras de la \"branche principale\",\nde sorte que le bras semble construit à partir d'une branche d'arbre.\nhttps://inspirnathan.com/_nuxt/img/img-9.90cb95c.png\n*/\n\n#elif PART == 7\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n\n  float leftEye = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  float rightEye = sdSphere(p, .1, vec3(0.2, 0.6, 0.7));\n\n  float noseAngle = radians(75.);\n  float nose = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n\n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, mainBranch);\n  d = opUnion(d, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return d;\n}\n\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nPour le bras droit, nous devons appliquer les trois mêmes SDF de capsules, mais inverser le signe de la composante x pour \n\"refléter\" le bras de l'autre côté du bonhomme de neige. \n\nNous pourrions écrire trois autres lignes pour le bras droit, une pour chaque SDF de capsule,\nou nous pourrions faire preuve d'ingéniosité. \n\nLe bonhomme de neige est actuellement centré au milieu de notre écran. \nNous pouvons profiter de la symétrie pour dessiner le bras droit avec le même décalage que le bras gauche,\nmais avec une composante x positive au lieu de négative.\n\nCréons un SDF personnalisé qui fusionne les trois branches en un seul SDF appelé sdArm.\n\nfloat sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return d;\n}\n\nNous pouvons ensuite utiliser cette fonction dans notre fonction de scène.\n\n\n*/\n\n#elif PART == 8\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return d;\n}\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n\n  float leftEye = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  float rightEye = sdSphere(p, .1, vec3(0.2, 0.6, 0.7));\n\n  float noseAngle = radians(75.);\n  float nose = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n\n  float leftArm = sdArm(p);\n\n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, leftArm);\n  return d;\n}\n\n\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nCréons une opération personnalisée appelée opFlipX qui inversera le signe de la composante x du point qui lui est transmis.\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n\nEnsuite, nous pouvons utiliser cette fonction à l'intérieur de la fonction scene pour dessiner le bras droit.\nhttps://inspirnathan.com/_nuxt/img/img-10.5e87f94.png\n\n*/\n\n\n#elif PART == 9\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return d;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n\n  float leftEye = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  float rightEye = sdSphere(p, .1, vec3(0.2, 0.6, 0.7));\n\n  float noseAngle = radians(75.);\n  float nose = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n\n  float leftArm = sdArm(p);\n  float rightArm = sdArm(opFlipX(p));\n\n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, leftArm);\n  d = opUnion(d, rightArm);\n  return d;\n}\n\n\n\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nVoilà ! Nous avons utilisé la symétrie pour dessiner le bras droit du bonhomme de neige ! \nSi nous décidons de bouger un peu le bras, cela se reflétera automatiquement dans le décalage du bras droit.\n\nNous pouvons également utiliser la nouvelle opération opFlipX pour l'œil droit du bonhomme de neige.\nCréons un SDF personnalisé pour un œil du bonhomme de neige.\n\nfloat sdEye(vec3 p) {\n  return sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n}\n\nEnsuite, nous pouvons l'utiliser dans la fonction scene pour dessiner l'oeil gauche et l'oeil droit.\n\n*/\n\n#elif PART == 10\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return d;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n\nfloat sdEye(vec3 p) {\n  return sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n}\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n\n  float leftEye = sdEye(p);\n  float rightEye = sdEye(opFlipX(p));\n\n  float noseAngle = radians(75.);\n  float nose = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n\n  float leftArm = sdArm(p);\n  float rightArm = sdArm(opFlipX(p));\n\n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, leftArm);\n  d = opUnion(d, rightArm);\n  return d;\n}\n\n\n\n\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nPour l'instant, le bonhomme de neige est très beau, mais il manque un peu de piquant.\nIl serait parfait si le bonhomme de neige était coiffé d'un haut-de-forme.\nNous pouvons simuler un haut-de-forme en combinant deux cylindres. \nPour cela, nous devons récupérer le SDF de cylindre intitulé \"Cylindre capped - exact\" dans la liste des SDF 3D d'Inigo Quilez.\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nAjoutons un offset:\n\nfloat sdCappedCylinder( vec3 p, float h, float r, vec3 offset )\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nNous pouvons créer un cylindre fin pour la partie inférieure du chapeau et un cylindre haut pour la partie supérieure du chapeau.\n\n*/\n\n#elif PART == 11\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return d;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n\nfloat sdEye(vec3 p) {\n  return sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r, vec3 offset )\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat scene(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n\n  float leftEye = sdEye(p);\n  float rightEye = sdEye(opFlipX(p));\n\n  float noseAngle = radians(75.);\n  float nose = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n\n  float leftArm = sdArm(p);\n  float rightArm = sdArm(opFlipX(p));\n  \n  float hatBottom = sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0));\n  float hatTop = sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0));\n\n  float d = opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, leftArm);\n  d = opUnion(d, rightArm);\n  d = opUnion(d, hatBottom);\n  d = opUnion(d, hatTop);\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nhttps://inspirnathan.com/_nuxt/img/img-11.46475a9.png\n\nNotre bonhomme de neige a l'air bien habillé maintenant !\n\n# Organiser le code avec des SDF personnalisés\n\nLorsque nous colorons le bonhomme de neige, nous devons cibler les parties individuelles du bonhomme de neige qui \nont des couleurs uniques. \n\nNous pouvons organiser le code en créant des SDF personnalisés pour chaque partie du bonhomme de neige qui aura une couleur unique.\n\nCréons un SDF appelé sdBody pour le corps du bonhomme de neige.\n\nfloat sdBody(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nNous avons déjà créé un SDF pour les yeux appelé sdEyes, mais nous devons créer un SDF pour le nez. \nCréez une nouvelle fonction appelée sdNose avec le contenu suivant.\n\nfloat sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  return sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n}\n\nNous avons déjà créé un SDF personnalisé pour les bras, mais créons-en un pour le chapeau, appelé sdHat, avec le code suivant.\n\nfloat sdHat(vec3 p) {\n  float hatBottom = sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0));\n  float hatTop = sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0));\n  \n  return opUnion(hatBottom, hatTop);\n}\n\nNous pouvons maintenant ajuster notre fonction de scène pour utiliser tous nos SDF personnalisés\nqui prennent déjà en compte le décalage ou la position de chaque partie du bonhomme de neige à l'intérieur \nde la déclaration de la fonction.\n\nfloat scene(vec3 p) {\n  float body = sdBody(p);\n  float leftEye = sdEye(p);\n  float rightEye = sdEye(opFlipX(p));\n  float nose = sdNose(p);\n  float leftArm = sdArm(p);\n  float rightArm = sdArm(opFlipX(p));\n  float hat = sdHat(p);\n\n  float d = body;\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, leftArm);\n  d = opUnion(d, rightArm);\n  d = opUnion(d, hat);\n  return d;\n}\n\nC'est beaucoup plus propre maintenant ! Il y a encore une chose que nous pouvons faire pour rendre ce code \nun peu plus abstrait. \n\nSi nous prévoyons de dessiner plusieurs bonshommes de neige dans la scène, \nnous devrions créer un SDF personnalisé qui dessine un bonhomme de neige entier.\n\nCréons une nouvelle fonction appelée sdSnowman qui fera exactement cela.\n\nfloat sdSnowman(vec3 p) {\n  float body = sdBody(p);\n  float leftEye = sdEye(p);\n  float rightEye = sdEye(opFlipX(p));\n  float nose = sdNose(p);\n  float leftArm = sdArm(p);\n  float rightArm = sdArm(opFlipX(p));\n  float hat = sdHat(p);\n\n  float d = body;\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, leftArm);\n  d = opUnion(d, rightArm);\n  d = opUnion(d, hat);\n  return d;\n}\n\nEnfin, notre fonction scène renverra simplement la valeur du bonhomme de neige SDF.\n\nfloat scene(vec3 p) {\n return sdSnowman(p);\n}\n\nNotre bonhomme de neige est maintenant construit et prêt à être colorié ! Vous trouverez ci-dessous le code final de cette scène.\n\n*/\n\n#elif PART == 12\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r, vec3 offset )\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBody(vec3 p) {\n  float bottomSnowball = sdSphere(p, 1., vec3(0, -1, 0));\n  float topSnowball = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nfloat sdEye(vec3 p) {\n  return sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n}\n\nfloat sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  return sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n}\n\nfloat sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return d;\n}\n\nfloat sdHat(vec3 p) {\n  float hatBottom = sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0));\n  float hatTop = sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0));\n  \n  return opUnion(hatBottom, hatTop);\n}\n\nfloat sdSnowman(vec3 p) {\n  float body = sdBody(p);\n  float leftEye = sdEye(p);\n  float rightEye = sdEye(opFlipX(p));\n  float nose = sdNose(p);\n  float leftArm = sdArm(p);\n  float rightArm = sdArm(opFlipX(p));\n  float hat = sdHat(p);\n\n  float d = body;\n  d = opUnion(d, leftEye);\n  d = opUnion(d, rightEye);\n  d = opUnion(d, nose);\n  d = opUnion(d, leftArm);\n  d = opUnion(d, rightArm);\n  d = opUnion(d, hat);\n  return d;\n}\n\nfloat scene(vec3 p) {\n return sdSnowman(p);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Coloriage du bonhomme de neige\n\nMaintenant que nous avons construit le modèle de bonhomme de neige,\najoutons de la couleur ! \n\nNous pouvons déclarer quelques constantes au début de notre code.\n\nNous avons déjà des constantes déclarées pour la couleur d'arrière-plan et la couleur ambiante de notre scène.\nAjoutons des couleurs pour chaque partie du bonhomme de neige.\n\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\nconst vec3 COLOR_BODY = vec3(1);\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_HAT = vec3(0);\n\nNotez que la couleur finale du bonhomme de neige est actuellement déterminée par la réflexion diffuse \nlambertienne plus la couleur ambiante. \n\nPar conséquent, la couleur que nous avons définie dans nos constantes sera mélangée à la couleur ambiante. \nSi vous préférez, vous pouvez supprimer la couleur ambiante pour voir la vraie couleur de chaque partie du bonhomme de neige.\n\nfloat dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5;\ncol = vec3(dif) + COLOR_AMBIENT; \n\nComme nous l'avons appris dans la partie 7 de ma série de tutoriels Shadertoy, (https://inspirnathan.com/posts/53-shadertoy-tutorial-part-7),\nnous pouvons utiliser des structures pour contenir plusieurs valeurs. \n\nNous allons créer une nouvelle structure qui contiendra la \"distance signée\" entre la caméra et la surface d'un objet de notre scène, \nainsi que la couleur de cette surface.\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nNous devrons modifier quelques opérations pour qu'elles renvoient des structures de surface au lieu de simples valeurs flottantes.\n\nPour l'opération opUnion, nous allons en fait surcharger cette fonction.\nNous garderons la fonction originale intacte, mais nous créerons une nouvelle fonction opUnion \nqui transmettra des structures Surface au lieu de valeurs flottantes.\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nLa surcharge des fonctions est très répandue dans les différents langages de programmation. \nElle nous permet de définir le même nom de fonction, mais nous pouvons passer un nombre différent de paramètres ou différents\ntypes de paramètres. \n\nPar conséquent, si nous appelons opUnion avec des valeurs flottantes, la première définition de fonction sera appelée.\nSi nous appelons opUnion avec des structures Surface, il appellera la deuxième définition.\n\nPour la fonction opSmoothUnion, nous n'aurons pas besoin de surcharger cette fonction.\nNous modifierons cette fonction pour qu'elle accepte les structures Surface au lieu des valeurs flottantes.\nPar conséquent, nous devons appeler mix à la fois sur la distance signée, sd, et sur la couleur, col.\n\nCela nous permet de fusionner en douceur deux formes et de mélanger leurs couleurs.\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nNous laisserons les SDF pour les formes primitives (sphère, cône, capsule, cylindre) tranquilles.\nIls continueront à renvoyer une valeur flottante. \n\nCependant, nous devrons ajuster nos SDFs personnalisés qui renvoient une partie du bonhomme de neige.\nNous voulons renvoyer une structure Surface qui contient une couleur pour chaque partie de notre bonhomme de neige, \nde sorte que nous puissions transmettre la valeur de la couleur au cours de notre boucle de ray marching.\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface scene(vec3 p) {\n  return sdSnowman(p);\n}\n\nNotre boucle de ray marching devra être ajustée, puisque nous renvoyons maintenant une structure Surface au lieu d'une valeur flottante.\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nNous devons également ajuster la fonction calcNormal pour qu'elle utilise la valeur de la distance signée, sd.\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nDans la fonction mainImage, la boucle de ray marching est utilisée pour renvoyer un flottant.\n\nfloat d = rayMarch(ro, rd);\n\nNous devons remplacer le code ci-dessus par le suivant, puisque la boucle de ray marching renvoie maintenant une structure Surface.\n\nSurface co = rayMarch(ro, rd);\n\nEn outre, nous devons vérifier si co.sd est supérieur à MAX_DIST au lieu de d :\n\nif (co.sd > MAX_DIST)\n\nDe même, nous devons utiliser co au lieu de d pour définir p :\n\nvec3 p = ro + rd * co.sd;\n\nDans la fonction mainImage, nous avons défini une couleur égale à la couleur diffuse plus la couleur ambiante.\n\ncol = vec3(dif) + COLOR_AMBIENT;\n\nNous devons maintenant remplacer la ligne ci-dessus par la suivante, puisque la couleur est également déterminée \npar la partie du bonhomme de neige touchée par le rayon.\n\ncol = dif * co.col + COLOR_AMBIENT;\n\nVotre code terminé devrait ressembler à ce qui suit :\n\n*/\n\n#elif PART == 13\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\nconst vec3 COLOR_BODY = vec3(1);\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_HAT = vec3(0);\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface scene(vec3 p) {\n  return sdSnowman(p);\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLorsque vous exécutez ce code, vous devriez voir le bonhomme de neige en couleur !\nhttps://inspirnathan.com/_nuxt/img/img-12.4152243.png\n\n# Création de plusieurs bonshommes de neige\n\nMaintenant que nous avons ajouté de la couleur à notre bonhomme de neige, \ncréons une scène impressionnante à l'aide de notre nouveau modèle de bonhomme de neige !\n\nLe modèle de bonhomme de neige flotte actuellement dans l'air. \nAjoutons maintenant un sol sous le bonhomme de neige.\n\nNous allons créer un nouveau SDF personnalisé qui renvoie une structure Surface.\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2.;\n  vec3 snowFloorCol = vec3(1);\n  return Surface(snowFloor, snowFloorCol);\n}\n\nEnsuite, nous ajusterons notre fonction de scène pour ajouter le sol à notre scène 3D.\n\nhttps://inspirnathan.com/_nuxt/img/img-13.b50c663.png\n*/\n\n#elif PART == 14\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\nconst vec3 COLOR_BODY = vec3(1);\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_HAT = vec3(0);\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2.;\n  vec3 snowFloorCol = vec3(1);\n  return Surface(snowFloor, snowFloorCol);\n}\n\n\nSurface scene(vec3 p) {\n  return opUnion(sdSnowman(p), sdFloor(p));\n}\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLes couleurs que nous avons choisies donnent l'impression qu'il fait beau dehors. \nEt si nous voulions donner l'impression qu'il fait nuit ?\nNous pouvons ajuster la couleur de la lumière ambiante pour changer l'ambiance de la scène.\n\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\n\nLa scène apparaît immédiatement différente.\nhttps://inspirnathan.com/_nuxt/img/img-14.9f99892.png\n*/\n\n#elif PART == 15\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\nconst vec3 COLOR_BODY = vec3(1);\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_HAT = vec3(0);\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2.;\n  vec3 snowFloorCol = vec3(1);\n  return Surface(snowFloor, snowFloorCol);\n}\n\n\nSurface scene(vec3 p) {\n  return opUnion(sdSnowman(p), sdFloor(p));\n}\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLa surface de la neige semble un peu plate. \nEt si nous voulions lui ajouter un peu de texture ? \nNous pouvons utiliser les \"channels\" dans Shadertoy pour ajouter une texture à notre shader.\n\nSous la section code de Shadertoy, vous devriez voir quatre canaux : iChannel0, iChannel1, iChannel2 et iChannel3.\nhttps://inspirnathan.com/_nuxt/img/img-15.855df06.png\n\nVous pouvez utiliser les canaux pour ajouter de l'interactivité à votre shader, comme une webcam, \nune entrée de microphone ou même un son provenant de SoundCloud ! \n\nDans notre cas, nous voulons ajouter une texture. \n\nCliquez sur la case de iChannel0. Une fenêtre modale devrait s'ouvrir. \nCliquez sur l'onglet \"Textures\", et vous devriez voir une sélection de textures à choisir.\n\nhttps://inspirnathan.com/_nuxt/img/img-16.fb8ba87.png\n\nSélectionnez la texture appelée \"Gray Noise Small\". \nUne fois sélectionnée, elle doit apparaître dans la boîte iChannel0 sous votre code.\n\nhttps://inspirnathan.com/_nuxt/img/img-17.de810dd.png\n\nLe bruit nous permet d'ajouter un peu de faux hasard ou de \"pseudo-aléatoire\" à notre code. \nCe n'est pas vraiment aléatoire parce que le shader aura la même apparence à chaque exécution. \nCela rend le shader déterministe, ce qui est utile pour s'assurer que tout le monde voit le même shader. \nLe bruit donnera l'impression que le sol a un motif \"aléatoire\". \n\nNous n'avons pas accès à quelque chose comme Math.random dans le code GLSL, comme c'est le cas en JavaScript.\nPar conséquent, les auteurs de shaders doivent généralement s'appuyer sur la génération procédurale de bruit par le biais\nd'un algorithme ou en utilisant des textures d'images comme nous allons le faire.\n\nRevenez à la fonction sdFloor que nous avons définie plus tôt et remplacez-la par le code suivant.\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n  vec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n  return Surface(snowFloor, snowFloorCol);\n}\n\nLa fonction texture nous permet d'accéder à la texture stockée dans iChannel0.\nChaque texture possède un ensemble de coordonnées UV, tout comme le canevas Shadertoy.\n\nLe premier paramètre de la fonction texture sera iChannel0. \nLe second paramètre est le point de l'image \"Gray Noise Small\" que nous souhaitons sélectionner.\n\nNous pouvons ajuster la hauteur du sol en échantillonnant des valeurs de la texture.\n\nfloat snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n\nNous pouvons également ajuster la couleur du sol en échantillonnant des valeurs de la texture.\n\nvec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n\nJ'ai joué avec les facteurs d'échelle et les valeurs de la fonction de mélange jusqu'à ce que je trouve un matériau \nsuffisamment proche de la neige.\n\nhttps://inspirnathan.com/_nuxt/img/img-18.d521f48.png\n\n*/\n\n#elif PART == 16\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\nconst vec3 COLOR_BODY = vec3(1);\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_HAT = vec3(0);\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n  vec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n  return Surface(snowFloor, snowFloorCol);\n}\n\n\n\nSurface scene(vec3 p) {\n  return opUnion(sdSnowman(p), sdFloor(p));\n}\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLe bonhomme de neige a l'air un peu seul, alors pourquoi ne pas lui donner des amis ? \nNous pouvons utiliser l'opération opRep dont j'ai parlé dans la partie 14 de ma série de tutoriels \nShadertoy pour créer de nombreux bonshommes de neige !\n\nSurface opRep(vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSnowman(q);\n}\n\nDans la fonction de scène, nous pouvons définir l'espacement entre les bonshommes de neige et les directions\nque les bonshommes de neige doivent répéter.\n\nSurface scene(vec3 p) {\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\nLe bonhomme de neige n'est plus seul ! Cependant, un bonhomme de neige semble accaparer toute l'attention de la scène.\nhttps://inspirnathan.com/_nuxt/img/img-19.fa6294c.png\n\n\n*/\n\n#elif PART == 17\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\nconst vec3 COLOR_BODY = vec3(1);\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_HAT = vec3(0);\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n  vec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n  return Surface(snowFloor, snowFloorCol);\n}\n\nSurface opRep(vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSnowman(q);\n}\n\n\n\nSurface scene(vec3 p) {\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n/*\nProcédons à quelques ajustements. \nNous allons modifier la position par défaut de la souris au chargement de la page,\nafin qu'elle soit légèrement décalée par rapport au centre de l'écran.\n\nif (mouseUV == vec2(0.0)) mouseUV = vec2(0.5, 0.4);\n\nEnsuite, nous allons ajuster le point d'observation :\n\nvec3 lp = vec3(0, 0, -2);\n\nEnfin, nous ajusterons l'angle et la position de départ de la scène lors du chargement de la page :\n\nSurface scene(vec3 p) {\n  p.x -= 0.75; // move entire scene slightly to the left\n  p.xz *= rotate2d(0.5); // start scene at an angle\n\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\nMaintenant, la scène est configurée de telle sorte que les personnes qui visitent votre shader pour la première fois\nverront un tas de bonshommes de neige sans qu'aucun des bonshommes de neige ne se trouve sur le chemin de la caméra.\nVous pouvez toujours utiliser votre souris pour faire tourner la caméra autour de la scène.\n\nhttps://inspirnathan.com/_nuxt/img/img-20.8ae8bca.png\n*/\n\n#elif PART == 18\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\nconst vec3 COLOR_BODY = vec3(1);\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_HAT = vec3(0);\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n  vec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n  return Surface(snowFloor, snowFloorCol);\n}\n\nSurface opRep(vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSnowman(q);\n}\n\n\n\nSurface scene(vec3 p) {\n  p.x -= 0.75; // move entire scene slightly to the left\n  p.xz *= rotate2d(0.5); // start scene at an angle\n\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\n\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5, 0.4); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0, 0, -2); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLa scène commence à s'améliorer, mais lorsque vous regardez l'allée de bonhommes de neige,\nelle semble trop artificielle.\n\nAjoutons un peu de brouillard pour donner de la profondeur à notre scène. \n\nNous avons appris ce qu'est le brouillard dans la partie 13 de ma série Shadertoy. \n\nJuste avant que la valeur finale de fragColor ne soit définie, ajoutez la ligne suivante :\n\ncol = mix(col, COLOR_BACKGROUND, 1.0 - exp(-0.00005 * co.sd * co.sd * co.sd)); // fog\n\nhttps://inspirnathan.com/_nuxt/img/img-21.36fd260.png\n\n*/\n\n#elif PART == 19\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\nconst vec3 COLOR_BODY = vec3(1);\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_HAT = vec3(0);\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n  vec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n  return Surface(snowFloor, snowFloorCol);\n}\n\nSurface opRep(vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSnowman(q);\n}\n\n\n\nSurface scene(vec3 p) {\n  p.x -= 0.75; // move entire scene slightly to the left\n  p.xz *= rotate2d(0.5); // start scene at an angle\n\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\n\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5, 0.4); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0, 0, -2); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n  col = mix(col, COLOR_BACKGROUND, 1.0 - exp(-0.00005 * co.sd * co.sd * co.sd)); // fog\n  \n  fragColor = vec4(col, 1.0);\n}\n\n/*\nC'est beaucoup mieux ! Les bonshommes de neige semblent être tournés vers l'arrière de la lumière.\nModifions la direction de la lumière pour qu'ils soient plus lumineux.\nDans la fonction mainImage, nous ajusterons la valeur de la position de la lumière.\n\nvec3 lightPosition = vec3(0, 2, 0);\n\nNous allons également rendre la couleur du corps et du chapeau de chaque bonhomme de neige un peu plus claire.\n\nconst vec3 COLOR_BODY = vec3(1.15);\nconst vec3 COLOR_HAT = vec3(0.4);\n\nhttps://inspirnathan.com/_nuxt/img/img-22.b192aa4.png\n*/\n\n#elif PART == 20\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_BODY = vec3(1.15);\nconst vec3 COLOR_HAT = vec3(0.4);\n\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n  vec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n  return Surface(snowFloor, snowFloorCol);\n}\n\nSurface opRep(vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSnowman(q);\n}\n\n\n\nSurface scene(vec3 p) {\n  p.x -= 0.75; // move entire scene slightly to the left\n  p.xz *= rotate2d(0.5); // start scene at an angle\n\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\n\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5, 0.4); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0, 0, -2); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 0);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n  col = mix(col, COLOR_BACKGROUND, 1.0 - exp(-0.00005 * co.sd * co.sd * co.sd)); // fog\n  \n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLeurs chapeaux sont plus visibles ! Ensuite, rendons les bonshommes de neige un peu plus vivants.\nNous allons les agiter un peu et les faire rebondir de haut en bas.\n\nNous pouvons les faire bouger un peu en appliquant une matrice de transformation à chaque bonhomme de neige. \nCréez une fonction appelée wiggle et utilisez la fonction rotateZ dont j'ai parlé dans la partie 8.\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\n\nmat3 wiggle() {\n  return rotateZ(mix(-0.01, 0.01, cos(iTime * SPEED)));\n}\n\nNous définirons une constante SPEED au début de notre code. Fixons-la à une valeur de quatre.\n\nconst float SPEED = 4.;\n\nEnsuite, nous appliquerons la fonction wiggle à l'intérieur de la fonction opRep, \nde manière à ce qu'elle soit appliquée à chaque bonhomme de neige.\n\nSurface opRep(vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSnowman(q * wiggle());\n}\n\nEnsuite, nous voulons que les bonshommes de neige rebondissent un peu de haut en bas. \nNous pouvons ajouter la ligne suivante à notre fonction scene.\n\np.y *= mix(1., 1.03, sin(iTime * SPEED));\n\nCela déformera les bonshommes de neige autour de l'axe des ordonnées dans une très faible mesure.\nNous utilisons la fonction mix pour réaffecter la valeur de la fonction sin à des valeurs comprises entre 1.0 et 1.03.\n\nVotre fonction scene devrait maintenant ressembler à ce qui suit.\n\nSurface scene(vec3 p) {\n  p.x -= 0.75; // move entire scene slightly to the left\n  p.xz *= rotate2d(0.5); // start scene at an angle\n  p.y *= mix(1., 1.03, sin(iTime * SPEED)); // bounce snowman up and down a bit\n\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\nLorsque vous exécutez le code, vous devriez voir les bonshommes de neige commencer à s'agiter !\n\nhttps://inspirnathan.com/_nuxt/img/gif-2.e2a6caa.gif\n\n*/\n\n#elif PART == 21\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_BODY = vec3(1.15);\nconst vec3 COLOR_HAT = vec3(0.4);\nconst float SPEED = 4.;\n\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\n\nmat3 wiggle() {\n  return rotateZ(mix(-0.01, 0.01, cos(iTime * SPEED)));\n}\n\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n  vec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n  return Surface(snowFloor, snowFloorCol);\n}\n\nSurface opRep(vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSnowman(q * wiggle());\n}\n\n\n\n\nSurface scene(vec3 p) {\n  p.x -= 0.75; // move entire scene slightly to the left\n  p.xz *= rotate2d(0.5); // start scene at an angle\n  p.y *= mix(1., 1.03, sin(iTime * SPEED)); // bounce snowman up and down a bit\n\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\n\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5, 0.4); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0, 0, -2); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 0);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n  col = mix(col, COLOR_BACKGROUND, 1.0 - exp(-0.00005 * co.sd * co.sd * co.sd)); // fog\n  \n  fragColor = vec4(col, 1.0);\n}\n\n/*\nEnfin, nous pouvons \"laisser tomber la neige\" en superposant des chutes de neige sur la scène. \nIl existe déjà de nombreux shaders de neige sur Shadertoy. \n\nNous utiliserons \"snow snow\" de l'auteur de Shadertoy, changjiu. https://www.shadertoy.com/view/3ld3zX\n\nVeillez toujours à créditer les auteurs lorsque vous utilisez leurs shaders. \n\nSi vous utilisez un shader d'un auteur pour des applications commerciales telles qu'un jeu, \nassurez-vous d'abord de lui demander la permission !\n\nDans Shadertoy, nous pouvons utiliser les canaux pour ajouter un tampon, de la même manière que nous avons ajouté une texture plus tôt.\nLes tampons vous permettent de créer des shaders \"multi-pass\" qui vous permettent de passer la sortie ou la couleur finale de \nchaque pixel d'un shader à un autre shader. \n\nIl s'agit en quelque sorte d'un pipeline de shaders. Nous pouvons transmettre la sortie du tampon A au programme principal\nqui s'exécute dans l'onglet \"Image\" de votre environnement Shadertoy.\n\nCliquez sur la case iChannel1 dans la section située sous votre code. Une fenêtre popup devrait apparaître.\n\nCliquez sur l'onglet \"Misc\" et sélectionnez Buffer A.\n\nhttps://inspirnathan.com/_nuxt/img/img-23.2557005.png\n\nUne fois que vous avez ajouté le tampon A, vous devriez le voir apparaître dans la boîte iChannel1.\n\nhttps://inspirnathan.com/_nuxt/img/img-24.5b36409.png\n\nEnsuite, nous devons créer le shader Buffer A. \nEnsuite, nous allons ajouter du code à l'intérieur de cette passe de shader. \n\nEn haut de votre écran, vous devriez voir un onglet \"Image\" au-dessus de votre code.\n\nÀ gauche de cet onglet, vous trouverez un onglet avec un signe plus (+).\n\nCliquez sur le signe plus et choisissez \"Buffer A\" dans la liste déroulante qui apparaît.\n\nhttps://inspirnathan.com/_nuxt/img/img-25.3a8589a.png\n\nDans le tampon A, ajoutez le code suivant : (voir onglet buffer A)\n\nEnsuite, retournez à l'onglet \"Image\" où se trouve le code principal de notre shader. \nEn bas de notre code, nous allons utiliser le Buffer A pour ajouter de la neige tombante à notre scène \ndevant tous les bonhommes de neige. \n\nJuste après le brouillard et avant que la fragColor finale ne soit définie, ajoutez la ligne suivante :\n\ncol += texture(iChannel1, fragCoord/iResolution.xy).rgb;\n\nNous utilisons la fonction texture pour accéder à iChannel1 qui contient la texture du Buffer A. \nLe deuxième paramètre de la fonction texture sera des coordonnées UV normales allant de zéro à un.\n\nCela nous permettra d'accéder à chaque pixel du shader dans le Buffer A comme s'il s'agissait d'une image.\n\nUne fois le code exécuté, vous devriez voir une scène hivernale étonnante avec des bonhommes de neige \nqui s'agitent et de la neige qui tombe ! Félicitations ! Vous avez réussi !\n\n*/\n\n#elif PART == 22\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.0, 0.20, 0.8) * 0.3;\nconst vec3 COLOR_EYE = vec3(0);\nconst vec3 COLOR_NOSE = vec3(0.8, 0.3, 0.1);\nconst vec3 COLOR_ARM = vec3(0.2);\nconst vec3 COLOR_BODY = vec3(1.15);\nconst vec3 COLOR_HAT = vec3(0.4);\nconst float SPEED = 4.;\n\n\nstruct Surface {\n  float sd; // signed distance\n  vec3 col; // diffuse color\n};\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\n\nmat3 wiggle() {\n  return rotateZ(mix(-0.01, 0.01, cos(iTime * SPEED)));\n}\n\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nSurface opUnion(Surface d1, Surface d2) {\n  if (d2.sd < d1.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n  Surface s;\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n  s.col = mix( d2.col, d1.col, h ) - k*h*(1.0-h);\n\n  return s;\n}\n\nvec3 opFlipX(vec3 p) {\n  p.x *= -1.;\n  return p;\n}\n \nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h, vec3 offset )\n{\n  p -= offset;\n  float q = length(p.xy);\n  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 offset )\n{\n  p -= offset;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r, vec3 offset)\n{\n  p -= offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSurface sdBody(vec3 p) {\n  Surface bottomSnowball = Surface(sdSphere(p, 1., vec3(0, -1, 0)), COLOR_BODY);\n  Surface topSnowball = Surface(sdSphere(p, 0.75, vec3(0, 0.5, 0)), COLOR_BODY);\n  \n  return opSmoothUnion(bottomSnowball, topSnowball, 0.2);\n}\n\nSurface sdEye(vec3 p) {\n  float d = sdSphere(p, .1, vec3(-0.2, 0.6, 0.7));\n  return Surface(d, COLOR_EYE);\n}\n\nSurface sdNose(vec3 p) {\n  float noseAngle = radians(75.);\n  float d = sdCone(p, vec2(sin(noseAngle), cos(noseAngle)), 0.5, vec3(0, 0.4, 1.2));\n  return Surface(d, COLOR_NOSE);\n}\n\nSurface sdArm(vec3 p) {\n  float mainBranch = sdCapsule(p, vec3(0, 0.5, 0), vec3(0.8, 0, 0.), 0.05, vec3(-1.5, -0.5, 0));\n  float smallBranchBottom = sdCapsule(p, vec3(0, 0.1, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  float smallBranchTop = sdCapsule(p, vec3(0, 0.3, 0), vec3(0.5, 0, 0.), 0.05, vec3(-2, 0, 0));\n  \n  float d = opUnion(mainBranch, smallBranchBottom);\n  d = opUnion(d, smallBranchTop);\n  return Surface(d, COLOR_ARM);\n}\n\nSurface sdHat(vec3 p) {\n  Surface bottom = Surface(sdCappedCylinder(p, 0.5, 0.05, vec3(0, 1.2, 0)), COLOR_HAT);\n  Surface top = Surface(sdCappedCylinder(p, 0.3, 0.3, vec3(0, 1.5, 0)), COLOR_HAT);\n  \n  return opUnion(bottom, top);\n}\n\nSurface sdSnowman(vec3 p) {\n  Surface body = sdBody(p);\n  Surface leftEye = sdEye(p);\n  Surface rightEye = sdEye(opFlipX(p));\n  Surface nose = sdNose(p);\n  Surface leftArm = sdArm(p);\n  Surface rightArm = sdArm(opFlipX(p));\n  Surface hat = sdHat(p);\n\n  Surface co = body;\n  co = opUnion(co, leftEye);\n  co = opUnion(co, rightEye);\n  co = opUnion(co, nose);\n  co = opUnion(co, hat);\n  co = opUnion(co, leftArm);\n  co = opUnion(co, rightArm);\n  \n  return co;\n}\n\nSurface sdFloor(vec3 p) {\n  float snowFloor = p.y + 2. + texture(iChannel0, p.xz).x * 0.01;\n  vec3 snowFloorCol = 0.85 * mix(vec3(1.5), vec3(1), texture(iChannel0, p.xz/100.).x);\n  return Surface(snowFloor, snowFloorCol);\n}\n\nSurface opRep(vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSnowman(q * wiggle());\n}\n\n\n\n\nSurface scene(vec3 p) {\n  p.x -= 0.75; // move entire scene slightly to the left\n  p.xz *= rotate2d(0.5); // start scene at an angle\n  p.y *= mix(1., 1.03, sin(iTime * SPEED)); // bounce snowman up and down a bit\n\n  Surface sdSnowmen = opRep(p - vec3(0, 0, -2), vec3(5, 0, 5));\n\n  return opUnion(sdSnowmen, sdFloor(p));\n}\n\n\n\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5, 0.4); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0, 0, -2); // lookat point\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 0);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = dif * co.col + COLOR_AMBIENT;\n  }\n  col = mix(col, COLOR_BACKGROUND, 1.0 - exp(-0.00005 * co.sd * co.sd * co.sd)); // fog\n  col += texture(iChannel1, fragCoord/iResolution.xy).rgb;\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nVous pouvez voir le code fini en visitant mon shader sur Shadertoy. (https://www.shadertoy.com/view/fsBSzW)\n\nN'oubliez pas que vous pouvez utiliser l'un des canaux pour ajouter de la musique à votre shader.\n\nVous pouvez utiliser l'un des canaux pour ajouter de la musique à votre shader en sélectionnant SoundCloud \net en collant une URL dans le champ de saisie.\n\n# Conclusion\n\nJ'espère que vous vous êtes amusés à construire un modèle de bonhomme de neige, à apprendre à le colorer, \npuis à dessiner plusieurs bonhommes de neige dans une belle scène avec de la neige qui tombe. \n\nVous avez appris à utiliser le ray marching pour construire un modèle 3D, à ajouter un sol texturé à une scène 3D,\nà ajouter du brouillard pour donner de la profondeur à votre scène et à utiliser des buffers pour créer un shader multi-pass !\n\nSi cela vous a aidé d'une manière ou d'une autre ou vous a inspiré, pensez à faire un don. (https://ko-fi.com/inspirnathan)\n\nVeuillez consulter les ressources pour le code fini de chaque partie de ce tutoriel. \n\nJusqu'à la prochaine fois, bon codage ! Restez inspirés !\n*/\n\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n** Buffer A\n** Credit: This buffer contains code forked from \"snow snow\" by changjiu: https://www.shadertoy.com/view/3ld3zX\n*/\n\nfloat SIZE_RATE = 0.1;\nfloat XSPEED = 0.5;\nfloat YSPEED = 0.75;\nfloat LAYERS = 10.;\n\nfloat Hash11(float p)\n{\n  vec3 p3 = fract(vec3(p) * 0.1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z); \n}\n\nvec2 Hash22(vec2 p)\n{\n  vec3 p3 = fract(vec3(p.xyx) * 0.3);\n  p3 += dot(p3, p3.yzx+19.19);\n  return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 Rand22(vec2 co)\n{\n  float x = fract(sin(dot(co.xy ,vec2(122.9898,783.233))) * 43758.5453);\n  float y = fract(sin(dot(co.xy ,vec2(457.6537,537.2793))) * 37573.5913);\n  return vec2(x,y);\n}\n\nvec3 SnowSingleLayer(vec2 uv,float layer){\n  vec3 acc = vec3(0.0,0.0,0.0);\n  uv = uv * (2.0 + layer);\n  float xOffset = uv.y * (((Hash11(layer)*2.-1.)*0.5+1.)*XSPEED);\n  float yOffset = YSPEED * iTime;\n  uv += vec2(xOffset,yOffset);\n  vec2 rgrid = Hash22(floor(uv)+(31.1759*layer));\n  uv = fract(uv) - (rgrid*2.-1.0) * 0.35 - 0.5;\n  float r = length(uv);\n  float circleSize = 0.04*(1.5+0.3*sin(iTime*SIZE_RATE));\n  float val = smoothstep(circleSize,-circleSize,r);\n  vec3 col = vec3(val,val,val)* rgrid.x ;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 acc = vec3(0,0,0);\n  for (float i = 0.; i < LAYERS; i++) {\n    acc += SnowSingleLayer(uv,i); \n  }\n\n  fragColor = vec4(acc,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}