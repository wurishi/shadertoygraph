{"ver":"0.1","info":{"id":"3t3Szr","date":"1580251759","viewed":2065,"name":"Lanczos Filter","username":"eyebrowsoffire","description":"Lanczos filter stolen from https://gitlab.com/higan/xml-shaders/blob/master/shaders/OpenGL/v1.0/Lanczos%20(6tap).shader","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["filter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FIX(c) max(abs(c), 1e-5);\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvec3 weight3(float x)\n{\n    const float radius = 3.0;\n    vec3 texel = FIX(2.0 * PI * vec3(x - 1.5, x - 0.5, x + 0.5));\n\n    // Lanczos3. Note: we normalize outside this function, so no point in multiplying by radius.\n    return /*radius **/ sin(texel) * sin(texel / radius) / (texel * texel);\n}\n\nvec3 pixel(float xpos, float ypos)\n{\n    return texture(iChannel0, vec2(xpos, ypos)).rgb;\n}\n\nvec3 line(float ypos, vec3 xpos1, vec3 xpos2, vec3 linetaps1, vec3 linetaps2)\n{\n    return\n        pixel(xpos1.r, ypos) * linetaps1.r +\n        pixel(xpos1.g, ypos) * linetaps2.r +\n        pixel(xpos1.b, ypos) * linetaps1.g +\n        pixel(xpos2.r, ypos) * linetaps2.g +\n        pixel(xpos2.g, ypos) * linetaps1.b +\n        pixel(xpos2.b, ypos) * linetaps2.b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 stepxy = 1.0 / iChannelResolution[0].xy;\n    vec2 texCoord = fragCoord / iResolution.xy;\n    \n    vec2 pos = texCoord.xy + stepxy * 0.5;\n    vec2 f = fract(pos / stepxy);\n    \n    float dividerPosition = fract(iTime);\n    float dividerWidth = 0.01;\n    if(texCoord.x < dividerPosition + dividerWidth)\n    {\n        if(texCoord.x < dividerPosition)\n        {\n            fragColor = texture(iChannel0, texCoord);\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n        return;\n    }\n\n    vec3 linetaps1   = weight3(0.5 - f.x * 0.5);\n    vec3 linetaps2   = weight3(1.0 - f.x * 0.5);\n    vec3 columntaps1 = weight3(0.5 - f.y * 0.5);\n    vec3 columntaps2 = weight3(1.0 - f.y * 0.5);\n\n    // make sure all taps added together is exactly 1.0, otherwise some\n    // (very small) distortion can occur\n    float suml = dot(linetaps1, vec3(1.0)) + dot(linetaps2, vec3(1.0));\n    float sumc = dot(columntaps1, vec3(1.0)) + dot(columntaps2, vec3(1.0));\n    linetaps1 /= suml;\n    linetaps2 /= suml;\n    columntaps1 /= sumc;\n    columntaps2 /= sumc;\n\n    vec2 xystart = (-2.5 - f) * stepxy + pos;\n    vec3 xpos1 = vec3(xystart.x, xystart.x + stepxy.x, xystart.x + stepxy.x * 2.0);\n    vec3 xpos2 = vec3(xystart.x + stepxy.x * 3.0, xystart.x + stepxy.x * 4.0, xystart.x + stepxy.x * 5.0);\n\n    fragColor = vec4(\n        line(xystart.y                 , xpos1, xpos2, linetaps1, linetaps2) * columntaps1.r +\n        line(xystart.y + stepxy.y      , xpos1, xpos2, linetaps1, linetaps2) * columntaps2.r +\n        line(xystart.y + stepxy.y * 2.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps1.g +\n        line(xystart.y + stepxy.y * 3.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps2.g +\n        line(xystart.y + stepxy.y * 4.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps1.b +\n        line(xystart.y + stepxy.y * 5.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps2.b,\n        1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}