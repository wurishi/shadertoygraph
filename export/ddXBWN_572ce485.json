{"ver":"0.1","info":{"id":"ddXBWN","date":"1688734217","viewed":65,"name":"Perception illusion","username":"Envy24","description":"The black spot looks like it's slowly growing.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["illusion","perception"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 2. )\n#define ORIGIN                    ( vec2(0) )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\n#define R              ( iResolution )\n#define AR             ( iResolution.x / iResolution.y )\n#define CELL_SIZE_SC   ( 25. )\n#define CELL_SIZE_NDC  ( (2.*CELL_SIZE_SC*SCENE_SCALE) / R.y )\n#define RANGES         ( map_to_centered_ndc(R.xy, SCENE_SCALE, vec2(0), false) )\n\nvec3 scene(in vec2 SC)\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false), \n         ranges = RANGES;\n         NDC.x/=AR; \n         \n    vec3 color = vec3(1);\n    \n    float x_count = R.x/CELL_SIZE_SC,     y_count = R.y/CELL_SIZE_SC,\n          dx = (ranges.x*2.) / (x_count), dy = (ranges.y*2.) / (y_count);\n    \n    vec2 offset = \n        vec2(CELL_SIZE_NDC*0.5) // cell center offset,\n        - ranges                // center cells grid,\n        - ORIGIN;               // match with NDC coordinates.\n    \n    for (float y = -1.; y < y_count; y += 1.)\n    {       \n        for (float x = -1.; x < x_count; x += 1.)\n        {\n            // Calculate current cell center.\n            vec2 CC = offset + vec2(x*dx, y*dy);\n            \n            /* Optimization. If NDC is far from CC, then skip this cell. */\n            vec2 diff = CC - NDC; \n            if (dot(diff, diff) > CELL_SIZE_NDC) { continue; }\n            /**/\n            \n            // Draw cell center.\n                 color = mix( color, vec3(0,0,0), smoothstep(4./R.y, 0., diskSDF_L2(NDC, CC, 25./R.y)) );\n                 color = mix( color, vec3(0,0,0), smoothstep(4./R.y, 0., diskSDF_L2(NDC, CC + CELL_SIZE_NDC*0.5, 25./R.y)) );\n        }\n    }\n    \n    color = mix( vec3(0,0,0), color, pow(diskSDF_L2(NDC, vec2(0), 240./R.y), 1.4));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = vec4(scene(SC),1.0);\n}","name":"Image","description":"","type":"image"}]}