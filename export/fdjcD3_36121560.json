{"ver":"0.1","info":{"id":"fdjcD3","date":"1644239193","viewed":207,"name":"Analytical ambient occlusion?","username":"AwareStubMan","description":"It's analytical I guess? It works similarly to HBAO being that I calculate the maximum horizon angle. Had to make an assumption that ruins accuracy but eh it works.\nBroken ray marching, oof","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["ray","occlusion","ambient","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRNG(fragCoord, float(iFrame));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb / texture(iChannel0, uv).a;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Ray marching settings\n#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n\n\n\n// Mathematical constants\n#define PI 3.14159265359\n\n\n\n// Constants\n#define epsilon 1e-5\n\n\n\n// Global variables\nfloat time;\n\n\n\n// RNG functions\nfloat _Seed;\nvec2 _Co;\nvoid initRNG(vec2 fragCoord, float seed) { _Seed = seed; _Co = fragCoord; }\nfloat rand()\n{\n    _Seed++;\n\treturn fract(sin(_Seed / 100.0 * dot(_Co, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n\nfloat nearestDist(vec3 position)\n{\n    // A plane and sphere should do just fine\n    float sphereDist = length(position - vec3(1.0, 0.5, 0.0)) - (sin(time)*0.5+0.5)*0.5;\n    sphereDist = min(length(position - vec3(-1.0, 0.5, 0.0)) - (cos(time)*0.5+0.5)*0.5, sphereDist);\n    float planeDist = position.y;\n    \n    return min(sphereDist, planeDist);\n}\nfloat raymarch(vec3 origin, vec3 direction)\n{\n    // This function returns the time for intersection\n    // March the ray MAX_STEPS amount of times\n    \n    float marchedDist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (marchedDist > MAX_DISTANCE) break;\n        \n        // Calculate march length\n        vec3 p = origin + direction*marchedDist;\n        float dist = nearestDist(p);\n        \n        // No need to march when already inside geometry\n        if (dist <= epsilon) break;\n        \n        // March the ray by adding distance\n        marchedDist += dist;\n    }\n    \n    return marchedDist;\n}\nvec3 getNormals(vec3 position)\n{\n    // Calculate normals using derivatives\n    vec2 a = vec2(1e-3, 0.0);\n    \n    float x = nearestDist(position + a.xyy);\n    float y = nearestDist(position + a.yxy);\n    float z = nearestDist(position + a.yyx);\n    \n    return normalize(vec3(x, y, z));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AO_STEPS 24\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    initRNG(fragCoord, float(iFrame));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    \n    vec3 ro = vec3(0.0, 1.0, -2.0);\n    vec3 rd = normalize(vec3((uv*2.0-1.0) * vec2(iResolution.x/iResolution.y, 1.0), 1.0));\n    \n    float t = raymarch(ro, rd);\n    vec3 pos = ro + rd*t;\n    vec3 norm = getNormals(pos);\n    \n    {\n        float horizonAng = 0.0;\n        float marchedDist = 0.0;\n        float dither = rand();\n        for (int i = 0; i < AO_STEPS; i++)\n        {\n            vec3 p = pos + norm*marchedDist;\n            float dist = max(nearestDist(p), 0.0);\n            \n            marchedDist += dist;\n            \n            // Now, to calculate the maximum horizon angle\n            horizonAng = max(horizonAng, atan(marchedDist / dist));\n        }\n        \n        // Calculate ambient occlusion using the horizon angle\n        float ao = 2.0 * max(sin(PI*0.5 - horizonAng), 0.0);\n        col = vec3(ao);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);// + texture(iChannel0, uv);\n}","name":"Buffer A","description":"","type":"buffer"}]}