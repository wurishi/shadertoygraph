{"ver":"0.1","info":{"id":"ctsXRN","date":"1674524085","viewed":133,"name":"REP3","username":"BrushC","description":"Testing volumetric rendering and attempting to make something cloud-like. Not super happy with the results, for some reason my brain just refuses to wrap itself around getting the volume lit properly and everything I try is just slightly wrong.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple function so that everything is using the same light\nvec3 getLightDirection() {\n    return normalize(vec3(sin(iTime), 1.0, cos(iTime)));\n}\n\nvec3 getLightColor() {\n    return vec3(1.0, 0.95, 0.95);\n}\n\nfloat distanceEstimator(vec3 samplePoint) {\n    float sphere = length(samplePoint - vec3(2.0 * cos(iTime), 0.0, 2.0 * sin(2.0 * iTime))) - 1.0;\n    return sphere;\n}\n\nfloat volumeDensity(vec3 samplePoint) {\n    float sphere = length(samplePoint - vec3(0.0, 0.0, 0.0)) - 2.5;\n    sphere = min(1.0, max(0.0, -sphere));\n    \n    vec3 uv = (samplePoint * 1.2) + iTime / 2.0;\n    \n    float noise = 0.8 * (gradientNoise(uv) + 0.5);\n    noise += 0.15 * (gradientNoise(uv * 4.0) + 0.5);\n    noise += 0.05 * (gradientNoise(uv * 8.0) + 0.5);\n    \n    // float voronoi = 1.0 - voronoi3D(uv * 2.0);\n    // noise += 0.2 * voronoi;\n    \n    return smoothstep(0.5, 0.8, noise) * 2.0;\n}\n\nvec4 raymarchGeometry(vec3 rayOrigin, vec3 rayDirection) {\n    vec4 marchPoint = vec4(rayOrigin, 0.0);\n    \n    for (int i = 0; i < MAX_STEP_COUNT; i++) {\n        float estimatedDistance = distanceEstimator(marchPoint.xyz);\n        marchPoint.xyz += rayDirection * estimatedDistance;\n        marchPoint.w += estimatedDistance;\n        \n        if (marchPoint.w >= MAX_DISTANCE || estimatedDistance <= MIN_STEP) {\n            break;\n        }\n    }\n    return marchPoint;\n}\n\nvec3 geometryNormal(vec3 samplePoint) {\n    vec2 d = vec2(0.01, 0.0);\n    \n    vec3 normal = distanceEstimator(samplePoint) - vec3(\n        distanceEstimator(samplePoint - d.xyy),\n        distanceEstimator(samplePoint - d.yxy),\n        distanceEstimator(samplePoint - d.yyx)\n    );\n    return normalize(normal);\n}\n\nfloat raymarchVolumeLight(vec3 rayOrigin, vec3 rayDirection, Box box) {\n    float stepDistance = rayBoxIntersection(box, rayOrigin, rayDirection).y / float(VOLUME_LIGHT_STEPS);\n    vec3 lightRay = rayOrigin + rayDirection * stepDistance;\n    float density = 0.0;\n    \n    for (int i = 0; i < VOLUME_LIGHT_STEPS; i++) {\n        float pointLightDensity = volumeDensity(lightRay) * stepDistance;\n        density += max(0.0, pointLightDensity);\n        lightRay += rayDirection * stepDistance;\n    }\n    \n    return density;\n}\n\nvec2 raymarchVolume(vec3 rayOrigin, vec3 rayDirection, Box box, vec2 boundingDistances) {\n    vec3 volumeRay = rayOrigin + rayDirection * max(boundingDistances.x, 0.0);\n    vec3 lightDirection = getLightDirection();\n    float stepDistance = boundingDistances.y / float(VOLUME_STEPS);\n    \n    float density = 0.0;\n    float lightIntensity = 0.0;\n    float transmittance = 1.0;\n    \n    float cosTheta = dot(lightDirection, rayDirection);\n    \n    for (int i = 0; i < VOLUME_STEPS; i++) {\n    \n        float pointDensity = volumeDensity(volumeRay);\n        \n        density += pointDensity * stepDistance;\n        \n        float pointLightDensity = raymarchVolumeLight(volumeRay, lightDirection, box);\n        float pointTransmittance = exp(VOLUME_K * -pointLightDensity * anisotropicScattering(VOLUME_V, cosTheta));\n        pointTransmittance = LIGHT_THRESHOLD + pointTransmittance * (1.0 - LIGHT_THRESHOLD);\n        transmittance *= exp(VOLUME_K * -pointDensity * stepDistance * density);\n        lightIntensity += (pointTransmittance * pointDensity) * stepDistance * transmittance;\n        \n        volumeRay += rayDirection * stepDistance;\n    }\n    \n    float finalDensity = exp(VOLUME_K * -density);\n    float finalLightIntensity = lightIntensity;\n    return vec2(finalDensity, finalLightIntensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Prep setup\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera setup\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0);\n    vec3 rayDirection = vec3(uv, rayOrigin.z + 1.0) - rayOrigin;\n    \n    vec2 mouseNormalized = (vec2(iMouse) / vec2(iResolution)) * 2.0 - 1.0;\n    rayOrigin.yz *= rotation(1.57 + mouseNormalized.y);\n    rayDirection.yz *= rotation(1.57 + mouseNormalized.y);\n    rayOrigin.xz *= rotation(3.14 * mouseNormalized.x);\n    rayDirection.xz *= rotation(3.14 * mouseNormalized.x);\n    \n    rayDirection = normalize(rayDirection);\n\n    // Raymarch\n    vec4 marchOutput = raymarchGeometry(rayOrigin, rayDirection);\n    \n    // Box Intersection\n    vec3 boxCenter = vec3(0, 0, 0);\n    vec3 boxDimensions = vec3(4.0, 4.0, 4.0);\n    Box box = Box(boxCenter - 0.5*boxDimensions, boxCenter + 0.5*boxDimensions);\n    \n    vec2 intersection = rayBoxIntersection(box, rayOrigin, rayDirection);\n    \n    // There was no geometry hit\n    if (marchOutput.w >= MAX_DISTANCE && intersection.y <= 0.0) {\n        fragColor = vec4(vec3(0.2, 0.2, 0.25), 1.0);\n        return;\n    }\n    \n    // There was a geometry hit\n    vec3 normal = geometryNormal(marchOutput.xyz);\n    \n    // Fog calculations\n    float innerDistance = min(intersection.y, marchOutput.w - intersection.x);\n    vec2 volumeData = raymarchVolume(rayOrigin, rayDirection, box, vec2(intersection.x, innerDistance));\n    float fogDensity = 1.0 - volumeData.x;\n    float lightIntensity = volumeData.y;\n    \n    // 3D Composition\n    float fog = exp(0.025 * -marchOutput.w);\n    float lighting = max(0.0, dot(normal, getLightDirection()));\n    vec3 composition = mix(vec3(0.1) + getLightColor() * lighting, vec3(0.2, 0.2, 0.25), 1.0 - fog);\n    \n    // Mixing fog with geometry\n    if (intersection.y > 0.0 && intersection.x < marchOutput.w) {\n        composition = mix(composition, getLightColor() * lightIntensity, fogDensity);\n    }\n    \n    fragColor = vec4(composition, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEP_COUNT 64\n#define MAX_DISTANCE 2e2\n#define MIN_STEP 1e-2\n\n#define VOLUME_STEPS 32\n#define VOLUME_LIGHT_STEPS 4\n#define VOLUME_K 1.5\n#define VOLUME_V 0.65\n#define LIGHT_THRESHOLD 0.2\n\nstruct Box {\n    vec3 topCorner;\n    vec3 bottomCorner;\n};\n\nvec2 rayBoxIntersection(Box box, vec3 rayOrigin, vec3 rayDirection) {\n    vec3 t0 = (box.bottomCorner - rayOrigin) / rayDirection;    \n    vec3 t1 = (box.topCorner - rayOrigin) / rayDirection;\n    vec3 tMin = min(t0, t1);\n    vec3 tMax = max(t0, t1);\n    \n    float aDistance = max(max(tMin.x, tMin.y), tMin.z);\n    float bDistance = min(min(tMax.x, tMax.y), tMax.z);\n    \n    float surfaceDistance = max(0.0, aDistance);\n    float insideDistance = max(0.0, bDistance - surfaceDistance);\n    \n    return vec2(surfaceDistance, insideDistance);\n}\n\nfloat anisotropicScattering(float g, float cosTheta) {\n    return 1.0 - (1.0 / 12.566) * ((1.0 - g*g) / pow(1.0 + g*g - 2.0*g * cosTheta, 1.5));\n}\n\nfloat beersPowder(float x) {\n    return exp(x) * (1.0 - exp(2.0 * x));\n}\n\nmat2 rotation(float theta) {\n    return mat2(sin(theta), -cos(theta),\n                cos(theta),  sin(theta));\n}\n\nvec3 rand3(vec3 x) {\n    vec3 r = (x + vec3(386.2, 865.33, 9.767)) * cos(x.y * x.x * x.z);\n    r *= sin(x * 952.52) * 3.57;\n    r += tan(dot(x + r, vec3(372.6, 773.44, 169.573)));\n    return fract(r);\n}\n\nfloat voronoi3D(vec3 point) {\n    vec3 cellId = floor(point + vec3(0.5));\n    vec3 gridCoords = fract(point + vec3(0.5));\n    \n    float nearestDistance = 1.0;\n    \n    // Loop over nearby cells\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 offset = vec3(x, y, z);\n                vec3 currentCell = cellId + offset;\n                vec3 randomValue = rand3(currentCell);\n                vec3 cellPosition = offset + randomValue;\n                float pointDistance = length(gridCoords - cellPosition);\n\n                nearestDistance = min(nearestDistance, pointDistance);\n            }\n        }\n    }\n    \n    return nearestDistance;\n}\n\n\n\n// Everything below was stolen from https://www.shadertoy.com/view/3dVXDc\n\n// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat gradientNoise(vec3 x)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    \n    // gradients\n    vec3 ga = hash33(p + vec3(0., 0., 0.));\n    vec3 gb = hash33(p + vec3(1., 0., 0.));\n    vec3 gc = hash33(p + vec3(0., 1., 0.));\n    vec3 gd = hash33(p + vec3(1., 1., 0.));\n    vec3 ge = hash33(p + vec3(0., 0., 1.));\n    vec3 gf = hash33(p + vec3(1., 0., 1.));\n    vec3 gg = hash33(p + vec3(0., 1., 1.));\n    vec3 gh = hash33(p + vec3(1., 1., 1.));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}","name":"Common","description":"","type":"common"}]}