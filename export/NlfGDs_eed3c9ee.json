{"ver":"0.1","info":{"id":"NlfGDs","date":"1623076711","viewed":324,"name":"Ray Marching - Diffuse Light","username":"ChaosOfZen","description":"A basic ray marching shader.\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","color"],"hasliked":0,"parentid":"flfGDs","parentname":"Ray Marching - Normal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/\n\n\n// Constants\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n \nfloat GetDist(vec3 p) \n{\n    vec4 s = vec4(0,1,6. + sin(iTime)*3.,1); //Sphere xyz is position w is radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist  = p.y;\n    float d = min(sphereDist,planeDist);\n \n    return d;\n}\n \n/*\n\nDistance field\nThe ray march loop marches from the origin/camera into the direction of the scene. \nAfter each iteration it checks if the distance to the scene is smaller than the minimum distance(SURACE_DIST). \nIf so, it returns the distance to the object. If the distance is greater than the max distance, \nmeaning the ray hasnâ€™t hit an object it also breaks out of the loop.\n*/ \n \nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.; //Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p); // ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    return dO;\n}\n\n/*\n\nNormals\nTo get the normals the point where the raymarch hits is used and a small amount (Epsilon) \nis added to the point in the right, up and forward direction. This new offset point is \nthen normalized to turn it into a unit vector/direction.\n*/\n\nvec3 GetNormal(vec3 p)\n{ \n    float d = GetDist(p); // Distance\n    vec2 e = vec2(.01,0); // Epsilon\n    vec3 n = d - vec3(\n    GetDist(p-e.xyy),  \n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n   \n    return normalize(n);\n}\n\n/*\nDiffuse light (Directional)\nTo calculate diffuse light, the angle between the surface normal and the light vector \nfrom a raymarched point is used. To get the angle, the Dot product is used which returns \nthe angle in a -1 <> 1 range. So when the light vector is perpendicular to the normal \nvector the Dot product is 1 and if its parralel to the normal vector it is 0.\n*/\n\nfloat GetLight(vec3 p)\n{ \n    // Light (directional diffuse)\n    vec3 lightPos = vec3(5.*sin(iTime),5.,5.0*cos(iTime)); // Light Position\n    vec3 l = normalize(lightPos-p); // Light Vector\n    vec3 n = GetNormal(p); // Normal Vector\n   \n    float dif = dot(n,l); // Diffuse light\n    dif = clamp(dif,0.,1.); // Clamp so it doesnt go below 0\n \n    return dif;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,1,0); // Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv.x,uv.y,1)); // Ray Direction\n   \n    float d = RayMarch(ro,rd); // Distance\n   \n    vec3 p = ro + rd * d;\n    float dif = GetLight(p); // Diffuse lighting\n    d *= .2;\n    vec3 color = vec3(0);\n    color = vec3(dif);\n \n    // Set the output color\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}