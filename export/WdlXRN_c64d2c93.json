{"ver":"0.1","info":{"id":"WdlXRN","date":"1550749129","viewed":759,"name":"3d Primitives  transparent anim.","username":"tholzer","description":"A set of animated 3d transparent primitives and combined objects.\nUse mouse to rotate scene or set ROTATE_SCENE = true.\nOriginal shader created by Inigo Quilez!","likes":10,"published":1,"flags":64,"usePreview":1,"tags":["procedural","3d","raymarching","primitives","animated","transparent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtX3D4","filepath":"https://soundcloud.com/grizzogor/alkis-livathinos-dearest-hue","previewfilepath":"https://soundcloud.com/grizzogor/alkis-livathinos-dearest-hue","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------\n// Shader:   3dPrimitivesTransAnim.glsl   \n//\n//  v1.1   4/2015  animation added to IQs original\n//  v1.2  12/2016  using new objects  \n//  v1.3  11/2018  antialasing added, see AA\n//  v1.4  12/2018  icosahedron & dodecahedron added\n//  v1.5   2/2019  mainImage & calcNormal adaption\n//  v1.6   2/2019  merging transparent version\n//\n// tags: 3d, primitives, procedural, raymarching, animated, transparent\n//\n// see also:\n//   original:     https://www.shadertoy.com/view/Xds3zN   IQ, colored\n//   gray scaled:  http://glslsandbox.com/e#20839          \n//   transparent:  https://www.shadertoy.com/view/tdsXRn \n//   sdSuperprim:  https://www.shadertoy.com/view/Xdy3Rm\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// A list of useful distance function to simple primitives (animated), \n// and examples on how to do some interesting boolean operations, \n// repetitions and displacements you'll finder under\n//   https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------\n\n// Question: Can fps be increased by checking first if we are \n//           intersecting an circumsphere first?\n//           This means 1. step raytracing 2. step rayMarching. \n\n#define AA 2   // make this 1 if your machine is too slow\n\n#define ANIMATE_OBJECTS true\n\n//#define ROTATE_SCENE true\n#define ROTATE_SCENE false\n\n#define flag true\n\n#define MODE 1\n// make this 0,1,2 for reflection,refraction,both objects\n#define REFRACTIDX 1.2\n\n#define PI 3.14159265359\n\nfloat time = 0.0;\nfloat aTime = 0.0;\nfloat sinTime = 0.0;\n\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a), ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n//---------------------------------------------------------\n// distance functions - distance operations - domain operations\n// https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------\nfloat length2( vec2 p )  // sqrt(x^2+y^2) \n{\n  return sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )  // (x^6+y^6)^(1/6)\n{\n  p = p*p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )  // (x^8+y^8)^(1/8)\n{\n  p = p*p; \n  p = p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/8.0 );\n}\n\n//---------------------------------------------------------\n// distance operations\n//---------------------------------------------------------\n#define opUnion(a,b)      min(a,b)\n#define opIntersect(a,b)  max(a,b)            \n#define opDifference(a,b) max(a,-b)\n#define opSubstraction(a,b) max(-a,b)\n#define opExklusiveOr(a,b)  min(max(-a,b),max(-b,a))\n\n// Union: d1 + d2\nvec2 opU( in vec2 d1, in vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------------------\n// domain operations\n//---------------------------------------------------------\n\n// Repetition x,y,z:\n// vec3 opRepeat (vec3 p, vec3 c)  {  return mod(p, c)-0.5*c;   }\n#define opRepeat(p,c) (mod(p,c)-0.5*c)\n\n//---------------------------------------------------------\n// domain deformations: p=position\n//---------------------------------------------------------\n// Twist: angle = twist angle\nvec3 opTwist (vec3 p, float angle)\n{\n  float c = cos(10.0*p.y + angle);\n  float s = sin(10.0*p.y + angle);\n  mat2  m = mat2(c, -s, s, c);\n  return vec3(m*p.xz, p.y);\n}\n\n//---------------------------------------------------------\n//  3d primitives: p = position\n//---------------------------------------------------------\n\nfloat sdPlane1 (vec3 p)\n{\n  return p.y;\n}\n\nfloat sdPlane (vec3 p, vec4 n)  // n must be normalized\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float radius )\n{\n  return length(p) - radius;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    //old: return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdEgg1(in vec3 p, float radius)\n{\n  p.y = 0.8*p.y + 0.15 * pow(1.9*dot(p.xz, p.xz), 0.65);\n  return length(p) - radius;\n}\n\n// egg2:  https://www.shadertoy.com/view/lsXSWf\nfloat sdEgg2(vec3 p, float r)\n{\n    p.y -= r*0.5;\n    p.y *= 0.8;\n    return length(p) - 1.7 * r * cos(p.y + 1.36);\n}\n\n// signed box: b=size\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// unsigned box: b=size\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// unsigned rounded box: b=size, r=round radius\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b, 0.0))-r;\n}\n\n// Torus:  t.x = torus radius,  t.y = ring radius\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length(vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x, p.y);\n  return length8(q) - t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x, p.y);\n  return length8(q)-t.y;\n}\n\n// Capsule:  a,b = end points, r = cylinder radius\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// Triangle prism:  base radius, prism height\nfloat sdTrianglePrism( vec3 p, float radius, float height )\n{\n  vec3 q = abs(p);\n  #ifdef flag\n    return max(q.z-height, max(q.x*0.866025 +p.y*0.5, -p.y) - radius*0.5);\n  #else\n    float d1 = q.z-height;\n    float d2 = max(q.x*0.866025+p.y*0.5, -p.y) - radius*0.5;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n  #endif\n}\n\n// Hexagonal Prism:  base radius, prism height\nfloat sdHexagonalPrism( vec3 p, float radius, float height)\n{\n  vec3 q = abs(p);\n  #ifdef flag\n    return max(q.z-height, max((q.x*0.866025 +q.y*0.5), q.y) - radius);\n  #else\n    float d1 = q.z-heighty;\n    float d2 = max((q.x*0.866025 +q.y*0.5), q.y)-radius;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\n// Cylinder: h.x=radius, h.y=height\nfloat sdCylinder(in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Cylinder: h=dimension, h.y=height\nfloat sdCylinder (in vec3 p, in vec3 h)\n{\n  return length(p.xz - h.xy) - h.z;\n}\n\n// Cylinder6: h.xy = base rectangle size, h.z=height\nfloat sdCylinder6 (in vec3 p, in vec3 h)\n{\n  return max( length6(p.xz) - h.x, abs(p.y) - h.z );\n}\n\n// Cone: c=dimension\nfloat sdCone (in vec3 p, in vec3 c)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  #if 0\n    return max( max( dot(q, c.xy), p.y), -p.y -c.z );\n  #else\n    float d1 = -p.y - c.z;\n    float d2 = max( dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\n// Dodecahedron: radius = circumsphere radius\nfloat sdDodecahedron(vec3 p, float radius)\n{\n  const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;  \n  const vec3 n = normalize(vec3(phi,1,0));\n\n  p = abs(p / radius);\n  float a = dot(p, n.xyz);\n  float b = dot(p, n.zxy);\n  float c = dot(p, n.yzx);\n  return (max(max(a,b),c)-n.x) * radius;\n}\n\n// Icosahedron: radius = circumsphere radius\nfloat sdIcosahedron(vec3 p, float radius)\n{\n  const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n  const vec3 n1 = normalize(vec3(q,1,0));\n  const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);\n\n  p = abs(p / radius);\n  float a = dot(p, n1.xyz);\n  float b = dot(p, n1.zxy);\n  float c = dot(p, n1.yzx);\n  float d = dot(p, n2) - n1.x;\n  return max(max(max(a,b),c)-n1.x,d) * radius;\n}\n\n\nfloat sdIcosDodecaStar(vec3 p, float radius)\n{\n  return min(sdDodecahedron(p,radius),  sdIcosahedron(p.zyx,radius));\n}\n\n// 4-sided Pyramid:  h = (cos a, sin a, height)\nfloat sdPyramid4(vec3 p, vec3 h )\n{\n  // Tetrahedron = Octahedron - Cube\n  float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n  float d = 0.0;\n  d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n  d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n  d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n  d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n  float octa = d - h.z;\n  return max(-box,octa); // subtraction\n}\n\n// https://www.shadertoy.com/view/lsBGzG\nfloat sdPyramid( vec3 p, float h) \n{\n  vec3 q=abs(p);\n  return max(-p.y, (q.x +q.y +q.z -h)/3.0 );\n}\n\n\n//=== Additional shapes ===\n\n//---------------------------------------------------------\nfloat sdWaveSphere(vec3 p, float radius, int waves, float waveSize) \n{\n  //bounding Sphere\n  float d = length(p) - radius*2.2;\n  if(d > 0.0) return 0.2;\n\n  // deformation of radius\n//d = waveSize * (radius - abs(p.y));\n  d = waveSize * (radius*radius-(p.y*p.y));\n  radius += d * cos(atan(p.x,p.z) * float(waves));\n  return 0.5*(length(p) - radius);\n}\n//---------------------------------------------------------\nfloat sdBlob (in vec3 pos, in float r)\n{\n  vec3 v1 = pos * 6.0;\n  return 0.05*(r + 0.5* (length(dot(v1, v1)) -0.51*(cos(4.*v1.x) +cos(4.*v1.y) +cos(4.*v1.z))));\n}\n   \n//---------------------------------------------------------\n// 3d cross: s=cross size\n//---------------------------------------------------------\nfloat sdCross( in vec3 p, in float s)\n{\n  float da = max (abs(p.x), abs(p.y));\n  float db = max (abs(p.y), abs(p.z));\n  float dc = max (abs(p.z), abs(p.x));\n  return min(da,min(db,dc)) - s;\n}\n//---------------------------------------------------------\n// 3d CrossInSphere: r=sphere radius, s=cross size\n//---------------------------------------------------------\nfloat CrossInSphere( in vec3 p, in float r, in float s )\n{\n  float d1 =  sdCross(p, s);  // cross\n  float d2 = length(p) - r;   // sphere\n  return max (d1,d2);         // intersection\n}\n//---------------------------------------------------------\n// sphere cutted out from a rounded box\n//---------------------------------------------------------\nfloat sdBoxMinusSphere( in vec3 pos, in float radius)\n{\n  return opDifference (udRoundBox(pos, vec3(0.15), 0.05)\n                      ,sdSphere(  pos, radius - 0.012 + 0.02*sinTime));\n}\n//---------------------------------------------------------\n// rack-wheel with holes\n//---------------------------------------------------------\nfloat sdRackWheel( in vec3 pos)\n{\n  return opDifference(sdTorus82(pos, vec2(0.20, 0.1)), \n    sdCylinder (opRepeat (vec3 (atan(pos.x, pos.z)/6.2831 + 0.1*aTime \n                               ,pos.y\n                               ,0.02+0.5*length(pos))\n                         ,vec3(0.05, 1.0, 0.05))\n               ,vec2(0.02, 0.6)));\n}\n//---------------------------------------------------------\nfloat sdBallyBall( in vec3 pos)\n{\n  return 0.7 * sdSphere(pos, 0.2 ) \n    + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y + 8.0*aTime)*sin(50.0*pos.z);\n}\n//---------------------------------------------------------\nfloat sdTwistedTorus( in vec3 pos, float angle)\n{\n  return 0.5*sdTorus( opTwist(pos,angle), vec2(0.20, 0.05));\n}\n//---------------------------------------------------------\n// render object positions\n\nconst vec3 p01 = vec3(-2.0, 0.25, -2.0);\nconst vec3 p02 = vec3(-1.0, 0.25, -2.0);\nconst vec3 p03 = vec3( 0.0, 0.25, -2.0);\nconst vec3 p04 = vec3( 1.0, 0.25, -2.0);\nconst vec3 p05 = vec3( 2.0, 0.20, -2.0);\n\nconst vec3 p11 = vec3(-2.0, 0.25, -1.0);\nconst vec3 p12 = vec3(-1.0, 0.50, -1.0);\nconst vec3 p13 = vec3( 0.0, 0.25, -1.0);\nconst vec3 p14 = vec3( 1.0, 0.25, -1.0);\nconst vec3 p15 = vec3( 2.0, 0.25, -1.0);\n\nconst vec3 p21 = vec3(-2.0, 0.20, 0.0);\nconst vec3 p22 = vec3(-1.0, 0.20, 0.0);\nconst vec3 p23 = vec3( 0.0, 0.25, 0.0);\nconst vec3 p24 = vec3( 1.0, 0.25, 0.0);\nconst vec3 p25 = vec3( 2.0, 0.25, 0.0);\n\nconst vec3 p31 = vec3(-2.0, 0.20, 1.0);\nconst vec3 p32 = vec3(-1.0, 0.25, 1.0);\nconst vec3 p33 = vec3( 0.0, 0.25, 1.0);\nconst vec3 p34 = vec3( 1.0, 0.25, 1.0);\nconst vec3 p35 = vec3( 2.0, 0.25, 1.0);\n\nconst vec3 p41 = vec3(-2.0, 0.25, 2.0);\nconst vec3 p42 = vec3(-1.0, 0.25, 2.0);\nconst vec3 p43 = vec3( 0.0, 0.25, 2.0);\nconst vec3 p44 = vec3( 1.0, 0.25, 2.0);\nconst vec3 p45 = vec3( 2.0, 0.30, 2.0);\n\nvec2 map( in vec3 pos )\n{\n  vec3 r1, r2;\n  \n//vec2 res = vec2 (sdPlane1(pos), 1.0); \n  vec2 res = vec2 (sdPlane(pos, vec4(0,1,0,0)), 1.0); \n  \n  //---0---\n    \n  res = opU(res, vec2( sdWaveSphere ( pos-p01, 0.18 , 10, sinTime*0.4), 99));\n\n                                    r1 = rotateY (pos-p02, aTime*0.5);\n  res = opU(res, vec2( sdDodecahedron(r1, 0.2), 55));\n\n                                    r1 = rotateX (pos-p03, sinTime*0.8);\n  res = opU(res, vec2( sdIcosDodecaStar(r1, 0.18), 177));\n\n                                    r1 = rotateZ (pos-p04, sinTime*0.8);\n  res = opU(res, vec2( sdIcosahedron(r1, 0.16), 222));\n    \n                                    float h1 = 0.2 + 0.1 * abs(sinTime);\n//  res = opU(res, vec2( sdPyramid4  (pos-p05, vec3(0.8,0.6,h1) ), 8 ) );\n  res = opU(res, vec2( sdPyramid  (pos-p05, h1 ), 8));\n\n  //---1---\n                                    r1 = rotateY (pos-p11, aTime*0.5);\n  res = opU(res, vec2( sdTrianglePrism( r1, 0.1*sinTime + 0.25, 0.05 ), 44));\n    \n                                    r1 = rotateX (pos-p12, sinTime*0.8);\n  res = opU(res, vec2( sdCone      (r1, vec3(0.8, 0.5+0.2*sinTime, 0.3)), 222));\n    \n  res = opU(res, vec2( sdBlob      (pos-p13, -0.5 - 0.45*sinTime ), 244));\n    \n                                    h1 = 0.2 + 0.06 * sinTime;\n  res = opU(res, vec2( sdCylinder  (pos-p14, vec2(0.1, h1) ), 130));\n\n               vec3 a = vec3( 0.1, 0.0, 0.0);  float sr1 = 0.1+0.05*sinTime;\n               vec3 b = vec3(-0.1, 0.3, 0.1);  float sr2 = 0.05;\n  res = opU(res, vec2( sdRoundCone( pos-p15, a,b, sr1,sr2), 51.7));\n\n  //---2---\n    \n  res = opU(res, vec2( CrossInSphere ( pos-p21, 0.2+0.05*sinTime, 0.05), 51));\n   \n                                    r1 = p22 + rotateY (vec3(-0.22, 0, 0), aTime);\n                                    r2 = p22 - rotateY (vec3(-0.22, 0, 0), aTime);\n  res = opU(res, vec2( sdCapsule   (pos, r1, r2, 0.1), 32));\n\n                                    r1 = vec3( 0.0, 0.1 + 0.1 * sinTime, 0.0);\n  res = opU(res, vec2( sdSphere    (pos-p23-r1, 0.25-0.5*r1.y), 111));\n \n  res = opU(res, vec2( sdBox       (pos-p24, vec3(0.20)), 3));\n    \n  res = opU(res, vec2( sdEgg1      (pos-p24-r1, 0.21), 47));\n\n  res = opU(res, vec2( sdEgg2      (pos-p25, 0.18+h1), 47));\n\n  //---3---\n  res = opU(res, vec2( sdBoxMinusSphere (pos-p31, 0.25), 13));\n    \n                                    r1 = rotateX (pos-p32, aTime*0.5);\n  res = opU(res, vec2( sdHexagonalPrism ( r1, 0.25, 0.05 ), 17.0));\n    \n                                    r1 = rotateX (pos-p33, sinTime*1.2);\n                                    r1 = rotateZ (r1, aTime*2.0);\n  res = opU(res, vec2( sdTorus(     r1, vec2(0.20, 0.05) ), 25.0));\n    \n  res = opU(res, vec2( udRoundBox(  pos-p34, vec3(0.12), 0.05+0.05*+sinTime), 77));\n    \n  res = opU(res, vec2( sdBallyBall ( pos-p35), 65.0));\n\n  //---4---\n    \n  res = opU(res, vec2( sdTwistedTorus( pos-p41, 6.0*sinTime ), 46.7));\n\n                                    r1 = rotateY (pos-p42, aTime*0.25);\n  res = opU(res, vec2( sdTorus88(   r1, vec2(0.20, 0.05) ), 43.0));\n    \n  res = opU(res, vec2( sdTorus82(   pos-p43, vec2(0.20-0.05*sinTime, 0.05)), 77));\n    \n  res = opU(res, vec2( sdRackWheel( pos-p44 ), 51));\n\n                                    r1 = rotateY (pos-p45, aTime*0.25);\n  res = opU(res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, 0.25) ), 12));\n    \n  return res;   // return x=distance, y=color id\n}\n\n//---------------------------------------------------------\n// https://iquilezles.org/articles/boxfunctions\n//---------------------------------------------------------\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad )\n{\n    vec3 m = 1.0001/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n}\n//---------------------------------------------------------\nconst float maxHei = 0.8;\nconst float minRay = 0.01;\nfloat minRefrac = 0.0;\n//---------------------------------------------------------\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = minRay;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0001 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n\n    // raymarch primitives\n    vec2 tb = iBox( ro-vec3(0.0,0.4,0.0), rd, vec3(2.5,0.41,2.5) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = max(tmin,minRefrac);\n#if AA>1\n        for( int i=0; i<70 * AA && t<tmax; i++ )\n#else\n        for( int i=0; i<70 && t<tmax; i++ )\n#endif\n        {\n            vec2 h = map( ro+rd*t );\n\n            t = minRefrac > 0. ? abs(t) : t;\n            if( abs(h.x)<(0.0001*t) )\n            {\n                res = vec2(t,h.y);\n                break;\n            }\n            t +=  minRefrac > 0. ? -(h.x) : h.x;\n        }\n    }\n    return res;\n}\n\n//---------------------------------------------------------\n// https://iquilezles.org/articles/rmshadows\n//---------------------------------------------------------\n#define ZERO (min(iFrame,0))\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n    \n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n//---------------------------------------------------------\n// https://iquilezles.org/articles/normalsSDF\n//---------------------------------------------------------\nvec3 calcNormal( in vec3 pos )   // get surface normal\n{\n    const vec2 e = vec2(0.0003,-0.0003);\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n//---------------------------------------------------------\n// https://en.wikipedia.org/wiki/Ambient_occlusion\n// https://de.wikipedia.org/wiki/Umgebungsverdeckung\n//---------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )  // get ambient occlusion\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<4; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n//---------------------------------------------------------\n// https://iquilezles.org/articles/checkerfiltering\n//---------------------------------------------------------\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n//---------------------------------------------------------\n// return antialiased hexagonal grid color\n//---------------------------------------------------------\nfloat HexagonalGrid (in vec2 position\n                    ,in float gridSize\n                    ,in float gridThickness)\n{\n  vec2 pos = position / gridSize;\n  pos.x *= 0.57735 * 2.0;\n  pos.y += 0.5 * mod(floor(pos.x), 2.0);\n  pos = abs(fract(pos) - 0.5);\n  float d = abs(max(pos.x*1.5 + pos.y, pos.y*2.0) - 1.0);\n  return smoothstep(0.0, gridThickness, d);\n}\n//---------------------------------------------------------\n#if MODE > 1\n  #define isReflection(m) (m < 15.)\n#elif MODE > 0\n  #define isReflection(m) (m < 2.)\n#else\n  #define isReflection(m) (m > 6999.)\n#endif\n//---------------------------------------------------------\nconst vec3 skyColor   = vec3(0.6, 0.8, 0.9);\nconst vec3 planeColor = vec3(0.8, 0.7, 0.6);\n    \nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n    float fDis = 100.;\n    for( int bounce = 0; bounce < 6; bounce++ ) // bounces of GI\n    {\n        vec2 res = castRay(ro,rd);\n        float t = res.x;\n        float m = res.y;\n\n        if(m < -0.5)\n        {\n           if(bounce == 0)\n              accumulatedColor = skyColor;\n\n           return vec3( clamp(accumulatedColor,0.0,1.0) );\n        }\n\n        if(bounce == 0) fDis = t;\n\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n\n        bool reflection = isReflection(m);\n\n        //nor = reflection || minRefrac < minRay ? nor : -nor;\n\n        // material\n        if( m<1.5 )\n        {\n      //    float f = checkersGradBox( 5.0*pos.xz );\n            float f = HexagonalGrid (4.*pos.xz, 0.8, 0.2);\n            colorMask *= 0.2 + f*vec3(0.1);\n        }\n        else\n            colorMask *= 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\n        vec3 ref = reflect( rd, nor );\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5*occ+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n            dif *\n            (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.130*amb*skyColor;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n        nor = reflection || minRefrac < minRay ? nor : -nor;\n\n        if(reflection)\n        {\n            accumulatedColor += colorMask*(lin + 9.00*spe*vec3(1.00,0.90,0.70));\n\n            colorMask *= clamp(1.0+0.77*dot(nor,rd),0.0,1.0);\n            rd = ref;\n            ro = pos;\n            minRefrac = 0.;\n\n            accumulatedColor = mix( accumulatedColor, skyColor, 1.0-exp( -0.0004*fDis*fDis*fDis ) );\n        }\n        else\n        {\n            accumulatedColor += colorMask*fre*(lin + 9.00*spe*vec3(1.00,0.90,0.70));\n\n            rd = refract(rd, nor, 1.0/ REFRACTIDX);\n            ro = pos;\n\n            minRefrac = minRefrac < minRay ? minRay : 0.;\n\n        }\n    }\n    minRefrac = 0.;\n    return vec3( clamp(accumulatedColor,0.0,1.0) );\n}\n//---------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 15.0 + iTime;\n    float rtime = ROTATE_SCENE ? 0.1*time : 0.0;\n    aTime = ANIMATE_OBJECTS ? iTime : 0.0;\n    sinTime = sin(aTime);\n    \n    // camera\n    float mx = 2.0 * PI * mo.x;           // mouse.x set horizontal rotation\n    vec3 ta = vec3( 0.0, -0.1, 0.0 );     // target position\n    vec3 ro = vec3( 4.0*cos(rtime + mx)\n                  , 0.2 + 3.3*mo.y        // mouse.y set vertical view angle\n                  , 4.2*sin(rtime + mx) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}