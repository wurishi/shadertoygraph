{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord);\nvec4 Sort(vec4 n);\nvec4 RayTorus(vec3 ro, vec3 rd, float R, float r);\nfloat sdTorus( vec3 p, vec2 t );\nvec3 nTorus( in vec3 pos, vec2 tor );\n\n#define pi 3.1415927\n\n\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvec3 RotZ(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.y*s,\n\t\t\t\t-p.x*s+p.y*c,\n\t\t\t\tp.z);\n}\n\nfloat r=.75;\nfloat R =1.2;\n\n\nvec3 offAxis = normalize(vec3(-.25,1,1));\n\nvec3 TexturedLight(vec3 p)\n{\n//\treturn vec3(1);\n\tmat3 m = mat3(  \n\t\tvec3(0.970142,-0.000000,0.242536),\n\t\tvec3(0.168880,0.717741,-0.675521),\n\t\tvec3(-0.174078,0.696311,0.696311));\n\tp = RotY(p,-iTime);\n\tp = m * p;\n\t\n\tvec3 L = texture(iChannel2,p.xz*.1-vec2(0.25,0.5),3.).xyz;\n\tL+=sin(iTime)*0.4+0.5;\n\tL+=0.25;\n//\tL=clamp(L,0.,1.);\n\tL*=L;\n\tL*=L;\n\treturn L;\n}\n\nvec3 Trans(float thick)\n{\n\tvec3 beer = vec3(0.793,3.955,0.453);;\n\tvec3 transmittance = exp(-beer*thick*4.);\n\treturn transmittance;\n}\n\nvec4 march(vec4 accum, vec3 viewP, vec3 viewD, float tt, float end, vec3 lightDir)\n{\n\t//exponential stepping\n\tfloat slices = 300.;\n\tfloat Far = 10.;\n\t\n\tfloat sliceStart = log2(tt)*(slices/log2(Far));\n\tfloat sliceEnd = log2(end)*(slices/log2(Far));\n\t\t\n\tfloat sliceRate = 1./ exp2(log2(Far)/slices);\n\t\n\tfloat last_tt = tt;\n\t\n#define STEPS\t64\t\n\tif (tt< 1e5)\t\t\n\tfor (int i=0; i<STEPS; i++)\n\t{\t\t\t\t\n\t\tfloat sliceI = sliceStart + float(i);\t//advance an exponential step\n\t\ttt = exp2(sliceI*(log2(Far)/slices));\t//back to linear\n\n\t\tvec3 p = viewP+tt*viewD;\n\t\t\n\t\t#define UNIFORM_DENSITY 0.02\n\t\t\n\t\tfloat dens = UNIFORM_DENSITY;\n\t\t\t\n\t\tdens *= (tt-last_tt)*100.;\t//density ought to be proportional to integral over step length?\n\t\tlast_tt = tt;\n\t\t\n\t\t//amount of stuff light had to go through to get here\n\t\tvec4 shadow_roots = RayTorus(p, lightDir, R, r);\n\n\t\tfloat thick=0.;\n\t\tthick += shadow_roots[0];\t//well this must be an exit cos we started inside\n\t\tif (shadow_roots[1]<1e5)\t//and there might be another segment\n\t\t{\n\t\t\tthick += shadow_roots[2]-shadow_roots[1];\n\t\t}\n\t//\tthick *= UNIFORM_DENSITY;\n\t\tfloat shadow = max(1.-thick,0.);\n\t\t\n\t\t//surface-like reflection term falling off towards interior of torus\n\t\tvec3 n = nTorus( p, vec2(R, r) );\n\t\tfloat dif = max(dot(n,lightDir),0.);\n\t\tfloat sd = sdTorus( p, vec2(R, r) );\n\t\tfloat reflective = 1.-(abs(sd)/r);\n\t\treflective*=reflective;\n\t\treflective*=reflective;\n\t\tdif *= reflective*4.;\n\t\t\n\t\tvec3 difColor = vec3(0.875,0.974,0.000);\n\t\tvec3 transColor = vec3(0.205,0.000,0.405);\n\t\t\n//\t\tvec3 beer = vec3(0.793,3.955,0.453);;\n//\t\tvec3 transmittance = exp(-beer*thick*4.);\n\t\t\n\t\tvec3 transmittance = Trans(thick);\n\t\t\t\n\t//\tvec3 c = vec3(transColor+dif*difColor) * shadow;\n\t\t\n\t\tvec3 c = vec3(transColor+dif*difColor) * transmittance;\n\t\tc *= TexturedLight(p);\n\t\t\n\t\tvec4 col = vec4(c,dens);\n\t\tcol = clamp(col,vec4(0),vec4(1));\t\n\t\tcol.rgb *= col.a; \n\t\taccum = accum + col*(1.0 - accum.a);\t\n\n\t\tif (accum.a > 1.) break;\n\t\t\n\t\tif (sliceI > sliceEnd) break; //out of exponential steps\t\n\t}\t\n\t\n\treturn accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightDir = RotY( offAxis, iTime );\n \n\tvec3 viewP, viewD;\n\tMakeViewRay(viewP, viewD, fragCoord);\n\n\t//ground plane\n\tfloat floor_height = -(R+r);\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\tvec3 c = texture(iChannel0,p.xz*0.1).xyz;\n\tc = pow(c,vec3(2.2));\n\tc = vec3(length(c));\n#if 1\t\n\t//darken by shadow ray through torus\n\tvec4 shadow_roots = RayTorus(p, lightDir, R, r);\n\tfloat thick=0.;\n\tfor (int i=0; i<4; i+=2)\n\t{\n\t\tif (shadow_roots[i+1]<1e5)\n\t\t{\n\t\t\tvec3 sp = p + lightDir * ((shadow_roots[i+1]+shadow_roots[i])*0.5);\n\n\t\t\tthick += (shadow_roots[i+1]-shadow_roots[i]);\n\t\t}\n\t}\n\t\n\tc *= clamp(Trans(thick*.5)+.1,0.,1.)*TexturedLight(p);\n\t\n#endif\t\n\n\t//ray marching segments of torus intersections\n\tvec4 roots = RayTorus(viewP, viewD, R, r);\n\n\tvec4 accum = vec4(0);\n\taccum = march(accum,viewP, viewD, roots[0],roots[1],lightDir);\n\taccum = march(accum,viewP, viewD, roots[2],roots[3],lightDir);\n\n\t//comp over background \n\tc = mix( c, accum.xyz, accum.a);\n\n\t\n\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.);\n\teye = vec3(2.5,3.,-2.5) * 1.5; \t\n\teye = RotY(eye,iTime*.4);\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\t//jitter to de-band\n\teye += ray * texture(iChannel1,p).x;\n}\n\nvec4 Sort( vec4 a)\n{\n\tvec4 m = vec4(min(a.xz,a.yw), max(a.xz,a.yw) );\n\tvec4 r = vec4(min(m.xz,m.yw), max(m.xz,m.yw) ); \n\ta = vec4( r.x, min(r.y,r.z),  max(r.y,r.z), r.w );\n\treturn a;\n}\n\n#define SMALL_ENOUGH 1e-4\n\n\n//thanks iq!\n//https://www.shadertoy.com/view/4sBGDy\n//slight modifications to return ALL intersections\nvec4 RayTorus( in vec3 ro, in vec3 rd, float torus_R, float torus_r )\n{\n\tfloat Ra2 = torus_R*torus_R;\n\tfloat ra2 = torus_r*torus_r;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\t\t\n\tfloat k = (m - ra2 - Ra2)*0.5;\n\tfloat a = n;\n\tfloat b = n*n + Ra2*rd.z*rd.z + k;\n\tfloat c = k*n + Ra2*ro.z*rd.z;\n\tfloat d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    //----------------------------------\n\n\tfloat p = -3.0*a*a     + 2.0*b;\n\tfloat q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;\n\tfloat r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;\n\tp /= 3.0;\n\tr /= 3.0;\n\tfloat Q = p*p + r;\n\tfloat R = 3.0*r*p - p*p*p - q*q;\n\t\n\tfloat h = R*R - Q*Q*Q;\n\tfloat z = 0.0;\n\tif( h < 0.0 )\n\t{\n\t\tfloat sQ = sqrt(Q);\n\t\tz = 2.0*sQ*cos( acos(R/(sQ*Q)) *(1.0/3.0) );\n\t}\n\telse\n\t{\n\t\tfloat sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n\t\tz = sign(R)*abs( sQ + Q/sQ );\n\n\t}\n\t\n\tz = p - z;\n\t\n    //----------------------------------\n\t\n\tfloat d1 = z   - 3.0*p;\n\tfloat d2 = z*z - 3.0*r;\n\n\tif( abs(d1)<SMALL_ENOUGH ) //this tolerance appears to be deeply annoying to tune. :(\n\t{\n\t\tif( d2<0.0 ) return vec4(1e20);\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\tif( d1<0.0 ) return vec4(1e20);\n\t\td1 = sqrt( d1*0.5 );\n\t\td2 = q/d1;\n\t}\n\t\n    //----------------------------------\n\t\n\tvec4 result = vec4(1e20);\n\n\th = d1*d1 - z + d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = -d1 - h - a;\n\t\tfloat t2 = -d1 + h - a;\n\t\t\n\t\tresult[0]=t1;\n\t\tresult[1]=t2;\n\t}\n\n\th = d1*d1 - z - d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = d1 - h - a;\n\t\tfloat t2 = d1 + h - a;\n\t\tresult[2]=t1;\n\t\tresult[3]=t2;\n\t}\n\t\n\tfor (int i=0; i<4; i++) if (result[i]<0.) result[i]=1e20;\n\tresult = Sort(result);\n\treturn result;\n}\n\n//iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n\n/*\n$num = hex $ARGV[0];\nprint \"vec3(\";\nfor ($i=0; $i<3; $i++)\n{\n\t$c = ($num >> ((2-$i)*8))&255;\n\t$f = $c / 255.0;\n\t$f = $f ** 2.2;\n\t$f = -log($f)/$thickness;\n\tprintf( \"%.3f\", $f);  \n\tif ($i < 2)\n\t{\n\tprint \",\";\n\t}\n}\nprint \");\";\n*/\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sB3Dy","date":"1392907334","viewed":349,"name":"Torus n Beer","username":"Antonalog","description":"Beers law vs torus raymarching with analytic intersections per march step for shadow rays, thanks to iq for the torus intersection. :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["torus"],"hasliked":0,"parentid":"","parentname":""}}