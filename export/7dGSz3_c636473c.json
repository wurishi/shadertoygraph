{"ver":"0.1","info":{"id":"7dGSz3","date":"1635020124","viewed":199,"name":"Eikonal FIM","username":"spalmer","description":"fixes inaccurate distance fields so they're accurate, iteratively, doesn't converge quickly but tends to improve the fields over time.  Draw w mouse.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["sdf","distance","eikonal","fim"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 o, vec2 p)\n{\n    o = texelFetch(iChannel0, ivec2(p), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this basically implements an iterative Eikonal marching method\n// Not sure if it's exactly FIM but it does about the same thing\n// and is fast enough (on gpgpu anyway) and simple and pretty robust.\n\n// see also Eikonal FIM 1D http://shadertoy.com/view/mdXSDH\n\n// Apparently implements something akin to Rouy et al's\n// (slow) iterative method from back in 1992:\n// \"A viscosity solutions approach to shape-from-shading\" by Rouy & Tourin\n// Try http://hal.inria.fr/inria-00377394/document \n// huh I guess that is the correct paper title but it's by\n// Emmanuel Prados, Fabio Camilli and Olivier Faugeras, not Rouy et al.\n// getting hard to find this nowadays!  Try http://scholar.google.com/scholar?cluster=10901608921506581386\n// \"which updates the solution for every point iteratively\n// until it converges using a Godunov discretization of Hamiltonian\"\n// according to A_fast_eikonal_equation_solver_for_parallel_system.pdf by Jeong and Whitaker 2007.\n// try here: http://researchgate.net/publication/228739801_A_fast_eikonal_equation_solver_for_parallel_systems\n// The convergence feedback isn't used here, though, and \n// it just continually iterates the entire field each frame.\n// So far, incrementally solving these fields hasn't shown itself to be much of a bottleneck,\n// as I can tolerate rather slow wavefront propagation speeds in most cases.\n\n// TODO adjustable Eikonal field exponent, wave propagation speed, currently hard-coded at 1.0\n\n//#define T(x) texelFetch(iChannel0, ivec2(x), 0)\n#define T(x) textureLod(iChannel0, vec2(x)/iResolution.xy, 0.)\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    const float e = exp2(8.)\n    , clip = .9, initclip = clip * 1.5;\n    vec3 c = vec3(1);\n    float d;\n    if (iFrame < 3 || p.x < 1.) {\n        float s = .06 * (iTime - 20. * p.x / r.x);\n        s += .1 * sin(sqrt(5.)*iTime) * sin(.2 * iTime) * (1.-exp2(-.01*iTime)); // fade in chaos later\n        d = (sin(12. * s) * .14 + .5) * r.y - p.y; // squiggles\n        //d *= .7;\n        //if (d < 0.)\n        //d = min(d, distance(vec2(mod(s, 2.), p.y / r.y), vec2(.5)) * p.y - 14.);\n     //   d = min(d, distance(vec2(fract(s) * p.x, p.y), vec2(30.,r.y*.25)) - 10.);\n     //   d = max(d, 10. - distance(vec2(fract(s) * p.x, p.y), vec2(50.,r.y*.75)));\n        //d = min(d, distance(vec2(mod(s*3., 10.), p.y / r.y), vec2(4., sin(floor(s*3.)*333.))) - 4.);\n        // TODO some brute force search to ensure initial values near surface are accurate!\n        if (abs(d) > initclip)\n        {\n            //d = sign(d) * initclip;\n            //d *= .1; //2.; // botch the distances somehow; it will handle some of it but tends to warp the final result\n            d = (d - sign(d) * initclip) * 1.5 + sign(d) * initclip;\n        }\n        //d = clamp(d, -initclip, initclip);\n        o.w = d / e;\n    } else {\n        --p.x; // scroll!\n        o = T(p); // old value\n        d = o.w * e;\n        if (abs(d) > clip) { // don't mess w data near surface\n            // Eikonal field straightening\n            // compute local gradient\n            vec2 g = vec2(T(p + vec2(1,0)).w\n                        - T(p - vec2(1,0)).w\n                        , T(p + vec2(0,1)).w\n                        - T(p - vec2(0,1)).w) * .5 * e;\n            float gsq = dot(g, g);\n            const float gsqthresh = .1;\n            // near ridges, where gradient length != 1 / non-eikonal field zones, busted derivative areas, gsq will be < 1\n            if (gsq < gsqthresh) {\n                //c = vec3(1,0,1);\n                o.w *= 1.01; // busted gradients\n            } else {\n                float dsgn = sign(d);\n                // slight stretch factor should eventually fix the field\n                const float stretch = 1.002; // factor makes it work for even bad CSG interiors with enough iterations!  But requires fine tuning.  Should be slightly larger than 1.0\n                // sample point precisely 1 unit away in the direction indicated by gunit; we should be about 1 unit from that.\n                vec2 q = p - dsgn * inversesqrt(gsq) * g;\n                d = T(q).w //textureLod(iChannel0, q, 0.).w //\n                    * e + dsgn * stretch;\n                if (d * dsgn > 0.) // on same side still?\n                    o.w = d / e;\n            }\n        }\n    }\n    float m = distance(iMouse.xy, p) - 12.;\n    if (iMouse.z > 1. && m < 2.) {\n        if (iMouse.y < iResolution.y * .5) //o.w > 0.)\n            o.w = min(o.w, m / e);\n        else\n            o.w = max(o.w, -m / e);\n        d = o.w * e;\n    }\n    c = (1. - exp2(-.5 * abs(d))) * (sin(.4*d) * .2 + .8)\n        * (d < 0. ? vec3(1,.8,.5) : vec3(.5,.8,1));\n    o.rgb = sqrt(c);\n}","name":"Buffer A","description":"","type":"buffer"}]}