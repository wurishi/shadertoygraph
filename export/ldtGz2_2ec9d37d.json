{"ver":"0.1","info":{"id":"ldtGz2","date":"1451079115","viewed":214,"name":"syltefar:Wobbly","username":"syltefar","description":"The shader I wrote for my first attempt at WebGL back in 2012. I copied a shader example and implemented some very basic and probably very buggy ray marching of a signed distance field, based on an explanation by Mikkel GjÃ¸l. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// The shader I wrote for my first attempt at WebGL back in 2012.\n// I copied a shader example and implemented some very basic and probably very\n// buggy ray marching of a signed distance field,\n// based on an explanation by Mikkel GjÃ¸l. \n\nprecision mediump float;\n\nfloat sphere( vec3 p ) { return length(p) - 1.0; }\nfloat box( vec3 p )\n{\n    return max(\n             max(\n               p.x * p.x - 0.4,\n\t           p.y * p.y - 0.4\n\t         ),\n\t       p.z * p.z - 0.4\n\t  );\n}\n\n// basic sdf stuff\nvec3 translate(vec3 p, vec3 v) { return p - v; } \nfloat or( float a, float b ) { return min(a,b); }\nfloat and( float a, float b ) { return max(a,b); }\n\nfloat sdf( vec3 p, float time) {\n    //vec3 c = vec3(8.0, 8.0, 8.0);\n    //vec3 v = p;//mod(p,c)-0.5*c;\n    float ripple = 0.05;\n    //return min( box(p), sphere(p));\n\n    //return box(translate(p, vec3(0., 0., 2.)));\n    //return and( box(p), sphere(p * 1.5) );\n\n    /*\n      return or(\n\t  sphere(translate(p, vec3(-0.5, 0., 2.))),\n\t  sphere(translate(p, vec3(+0.5, 0., 2.)))\n      );\n    */\n\n    // Wobbly\n    return distance(p, vec3(\n\t  0.0+sin(p.y* 20.0 * sin(time*2.) + time * 10.)*ripple * sin(time*5.) * 2.,\n\t  0.0+sin(p.x* 20.0 * sin(time*2.7) + time * 10.)*ripple * sin(time*3.) * 2.,\n\t  2.0)) - 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.yy * 2.2;\n    vec3 pos = vec3(uv.x-1.9, uv.y-1.1, 0.0);\n    vec3 direction = pos - vec3(0.0, 0.0, -1.0);\n\n    // ray marching\n    float d = 10.0;\n    for(int i =0; i < 256; i++) {\n\t  d = sdf(pos, iTime );\n\t  pos += direction * d;\n\t  if(d < 0.02 || pos.z > 100.0) break;\n    }\n\n    float r = 0.0, g = 0.0, b = 0.0;\n    \n    if(d<=0.02) {\n\n\t  // estimate normal based on finite difference approx of gradient\n\t  vec3 gradient = sdf(pos, iTime) - vec3(\n\t      sdf(pos + vec3(.001,.000,.000), iTime),\n\t      sdf(pos + vec3(.000,.001,.000), iTime),\n\t      sdf(pos + vec3(.000,.000,.001), iTime)\n\t      );\n      \t  vec3 normal = normalize( gradient );\n\n\t  // red diffuse light\n\t  vec3 l = normalize(vec3(0.5,-0.5,+0.5));\n\t  r = dot( normal, l ) * 1.0;\n\t  //r = normal.x * 0.5 + 0.5;\n\t  //g = normal.y * 0.5 + 0.5;\n\t  //b = normal.z * 0.5 + 0.5;\n\t  // green diffuse light\n\t  g = dot( normal, normalize(vec3(-0.4,0.4,+0.4))) * 0.2;\n\t  // blue diffuse light\n\t  b = dot( normal, normalize(vec3(0.9,-0.3,+0.4))) * 0.3;\n    }\n    fragColor = vec4(r, g, b, 1.0);\n}","name":"","description":"","type":"image"}]}