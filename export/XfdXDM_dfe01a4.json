{"ver":"0.1","info":{"id":"XfdXDM","date":"1714205250","viewed":221,"name":"Supersonic wind tunnel 3","username":"ukeshet","description":"Object selection (before run)+colorbars+zoom added to V2 (https://www.shadertoy.com/view/4f3SDH)\nSolver and visualization: see de Laval nozzle 2 (https://www.shadertoy.com/view/lcdXRn)\nLower timestep (delta) if instability starts developing.","likes":8,"published":1,"flags":32,"usePreview":1,"tags":["simulation","fluid","physics","gui","wing","finitedifferences","idealfluid","windtunnel"],"hasliked":0,"parentid":"4f3SDH","parentname":"Supersonic wind tunnel 2"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Compressible 2D ideal flow simulation of objects in a controllable wind.\n// Demo for ICP + Astrophysics 1 courses, by ukeshet.\n//\n// V3: added zoom (click anywhere), color bar (numbers are w.r.t injection values)\n// and object selection (before run). Also fixed minor bugs.\n// Presently available objects: standard bullet (22mm Para), wing (NACA 2315: not \n// supersonic), ball, converging nozzle, converging-diverging (de Laval) nozzle. \n//\n// 2D compressible solver from de Laval nozzle (https://www.shadertoy.com/view/XcyGW3)\n// Blob visualization from de Laval nozzle 2 (https://www.shadertoy.com/view/lcdXRn)\n// V1 (wing vs. sphere): Supersonic wind tunnel (https://www.shadertoy.com/view/4cdXz7)\n// V2 (bullet vs. wing): Supersonic wind tunnel 2 (https://www.shadertoy.com/view/4f3SDH)\n// \n// Buffer A sets up initial and boundary conditions. Revise for different objects.\n// Buffer B is a simple 2D ideal fluid solver.\n// Buffer C traces T-blobs (moving at 3*velocity) and monitors controls.\n//\n// Controls: M=Mach number, theta=wind angle (above horizon, deg), delta=time step (cell units).\n// Moving controls aggressively after run already started might crash the solver.\n// Lowering the time step (delta control) slows the evolution but stabilizes the solver. \n// Visualization cycles through field views unless you click on a field name or elsewhere.\n\n#define y0 .71\n#define y1 .64\n#define y2 .57\n#define y3 .50\n#define y4 .43\n#define y5 .36\n#define ysh -.36\n#define Btxt .0 \n#define Control(frx, fry, h, c) {if (abs(abs(uv.x-frx*Bx)-ClLdW)<dy && abs(uv.y-fry)<CldH) Col=vec4(1.); if (abs(abs(uv.y-fry)-CldH)<dy && abs(uv.x-frx*Bx)<ClLdW) Col=vec4(1.); if (iMouse.z>0. && max(abs(M.x-frx*Bx),abs(M.y-h))<ClBdW) {if (max(2.*abs(uv.x-frx*Bx+ClBdW),abs(uv.y-h))<ClBdH) Col=vec4(1.,0,0,1.);} else if (max(abs(uv.x-frx*Bx+ClBdW),abs(uv.y-h))<ClBdH) Col=vec4(1.,0,0,1.); if (max(abs(uv.x-frx*Bx),abs(uv.y-h))<ClBdW && length(uv-vec2(frx*Bx,h))<.175*Bx) Col=vec4(.5,.0,.5,1.); k=vec2((frx-.125)*Bx,h-ClTdH); Col+=vec4(K(c).x);}\n#define CBx (.75*Bx)\n#define CBy .47\n#define CBdx (.05*Bx)\n#define CBdy .12\n#define CBdY .14\n#define CP0(x,ic) (ic==0? vec3(x,0,0):(ic==1? vec3(0.,x,0):(ic==2? vec3(0.,0,x):vec3(x))))\n#define ColBar(ic,iRn,cp) {if (abs(uv.x-CBx)<CBdx && abs(uv.y-CBy)<CBdy) {Col.xyz=cp(smoothstep(-CBdy,+CBdy,uv.y-CBy),ic);} k=vec2(CBx-0.35*Bx,CBy-CBdY); Col.xyz+=cp((K(240+int(mod(.1*Rn[iRn].x,10.)))+K(240+int(mod(Rn[iRn].x,10.)))+K(238)+K(240+int(mod(10.*Rn[iRn].x,10.)))+K(240+int(mod(100.*Rn[iRn].x,10.)))).x,ic); k=vec2(CBx-0.35*Bx,CBy+CBdY); Col.xyz+=cp((K(240+int(mod(.1*Rn[iRn].y,10.)))+K(240+int(mod(Rn[iRn].y,10.)))+K(238)+K(240+int(mod(10.*Rn[iRn].y,10.)))+K(240+int(mod(100.*Rn[iRn].y,10.)))).x,ic); }\n#define DrawBall(uv1,dyB,dyT,scl) {if (length(uv1)<Br) Col=vec4(0.);  if (abs(length(uv1)-Br)<1.1*dy) Col=vec4(1.); }\n#define DrawBullet(uv1,dyB,dyT,scl) {if (ordQ(PxL,uv1.x,PxR)) {if (ordQ(dyT,0.,dyB)) Col=vec4(0.); if ((abs(AspR*dyB)<dy*Zm/scl) || (abs(AspR*dyT)<dy*Zm/scl) || (abs(uv1.y)<PxW*PGd1 && abs(dxLP(uv1-vec2(0.)))<dx*Zm) || (abs(uv1.y)<2.*dy*Zm && abs(uv1.x)<dx*Zm)) Col=vec4(1.); }}\n#define DrawWing(uv1,dyB,dyT,scl) {if (ordQ(WxL,uv1.x,WxR)) {if (ordQ(dyT,0.,dyB)) Col=vec4(0.); if ((abs(AspR*dyB)<dy*Zm/scl) || (abs(AspR*dyT)<dy*Zm/scl)) Col=vec4(1.); }}\n#define DrawNoz(uv1,dyB1,dyT1,dyB2,dyT2,dyB3,dyT3,scl) {if (ordQ(xL0N,uv1.x,0.)) {if (ordQ(dyT1,0.,dyB1)||ordQ(dyT2,0.,dyB2)) {Col=vec4(0.); if (uv1.x-xL0N<dx*Zm/scl) Col=vec4(1.);} if (min(min(abs(dyB1),abs(dyT1)),min(abs(dyB2),abs(dyT2)))<dy*Zm/scl) Col=vec4(1.);} else if (ordQ(0.,uv1.x,xR0N)) {if (ordQ(dyT3,0.,dyB3)) Col=vec4(0.); if ((abs(dyB3)<dy*Zm/scl) || (abs(dyT3)<dy*Zm/scl)) Col=vec4(1.);}}\n        \nvec2 uv, k;\n\nvec4 K(int c) { // Type a character\n    vec2 p=(uv-k)*22.; k.x+=.02;\n    if (p.x<.0||p.x>1.||p.y<0.||p.y>1.) return vec4(0.);\n    return textureGrad(iChannel1,p/16.+fract(vec2(c+64,15-(c+64)/16)/16.),dFdx(p/16.),dFdy(p/16.));\n}\n\nvec3 CP(float x, int dummy) { // Heat color palette\n    x=smoothstep(0.,1.,x);\n    float x2=x*x, x4=x2*x2, x8=x4*x4;\n    return vec3(x,x2,x8*x8);\n}\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n    uv = Coo.xy/iResolution.y;\n    float T, dx, dy, Lx=iResolution.x/iResolution.y, AspR, t=mod(iTime,27.), v0=M0*sqrt(G*P0/rho0), Zm=1., Sx=Bx+1./nBut;\n    dx=dy=1./iResolution.y; AspR=dy/dx;\n    vec2 uv0=uv, Rn[4], str=vec2(1./Lx,1.), M=iMouse.xy/iResolution.y, ofs, uvN;\n    Dx=round(iResolution.y/Nx)/iResolution.x; Dy=round(iResolution.y/Ny)/iResolution.y;\n    vec4 Ranges=texture(iChannel2, vec2(0.05,.95)*str);\n    for (int j=0;j<=3;j++) Rn[j]=Sunpack(Ranges[j]);\n    if (uv.x<Bx) Col=vec4(0.);\n    else if (iMouse.z>0. && M.x>Bx && length(uv-M)<.4) { // Zoom\n        vec2 uvZ=M+.2*length(uv-M)*normalize(uv-M); Zm=.7; \n        uv=vec2(dx*floor(uvZ.x/dx),dy*floor(uvZ.y/dy)); }\n    vec4 A=texture(iChannel0, uv*str);\n    if (uv.x>Bx) Col = vec4(log(A.z/min(.95*rho0,Rn[1].x))/log(max(1.05*rho0,Rn[1].y)/min(.95*rho0,Rn[1].x)),\n                            log(A.w/min(.95*P0,Rn[2].x))/log(max(1.05*P0,Rn[2].y)/min(.95*P0,Rn[2].x)),\n                            (length(A.xy)*sqrt(A.z/(G*A.w))-max(.05*v0,Rn[0].x))/(max(1.05*v0,Rn[0].y)-max(.05*v0,Rn[0].x)),1.); \n    int V; // visualization status flag\n    if ((uv.x<Bx) && ordQ(y5,uv.y-ysh,y1)) Col*=0.; // Text box and text:\n    k=vec2(Btxt,ysh+.57); Col += vec4(0.,(K(16)+K(50)+K(37)+K(51)+K(51)+K(53)+K(50)+K(37)).x,0.,1.);\n    k=vec2(Btxt,ysh+.51); Col += vec4(0.,0.,(K(13)+K(33)+K(35)+K(40)).x,1.);\n    k=vec2(Btxt,ysh+.45); Col += vec4((K(4)+K(37)+K(46)+K(51)+K(41)+K(52)+K(57)).x,0.,0.,1.);\n    k=vec2(Btxt,ysh+.39); Col += vec4(vec2((K(20)+K(37)+K(45)+K(48)+K(232)+K(54)+K(234)+K(243)+K(233)).x),0.,1.);\n    if(iMouse.z<=0. || M.y>y0+ysh || M.x>Bx) V=0; \n        else if ordQ(y1,M.y-ysh,y0) V=5;\n        else if ordQ(y2,M.y-ysh,y1) V=1;\n        else if ordQ(y3,M.y-ysh,y2) V=2;\n        else if ordQ(y4,M.y-ysh,y3) V=3;\n        else if ordQ(y5,M.y-ysh,y4) V=4; \n    if (V==5 || ((V==0) && ordQ(7.5,t,15.))) {       // Show (rho,P,M)\n        if ((uv.x<Bx) && ordQ(y5,uv.y-ysh,y4)) Col*=0.; }\n    if (V==1 || (V==0 && ordQ(15.,t,19.))) {         // Show (0,P,0)\n        Col.xz*=0.; if ((uv.x<Bx) && (ordQ(y5,uv.y-ysh,y2))) Col*=0.; \n        ColBar(1,2,CP0); }\n    if (V==2 || (V==0 && ordQ(19.,t,23.))) {         // Show (0,0,Mach)\n        Col.xy*=0.; if ((uv.x<Bx) && (ordQ(y5,uv.y-ysh,y3) || ordQ(y2,uv.y-ysh,y1) )) Col*=0.; \n        ColBar(2,0,CP0); }\n    if (V==3 || (V==0 && t>23.)) {                   // Show (rho,0,0)\n        Col.yz*=0.; if ((uv.x<Bx) && (ordQ(y5,uv.y-ysh,y4) || ordQ(y3,uv.y-ysh,y1))) Col*=0.; \n        ColBar(0,1,CP0); }\n    if (V==4 || (V==0 && ordQ(0.,t,7.5))) {          // Show T blobs\n        if (uv.x>Bx) { \n            Col=vec4(0.,0.,0.,1.);\n            if (Separatrix==false || abs(uv.y-.5)>.5*Dy) { // plot blobs\n                for(float ix=-1.; ix<1.5; ix+=1.) for(float iy=-1.; iy<1.5; iy+=1.) {\n                    vec2 uv1=uv+vec2(Dx*ix,Dy*iy);\n                    if (ordQ(0.,uv1.x,Lx) && ordQ(0.,uv1.y,1.)) {\n                        vec4 B=texture(iChannel2,uv1*str);\n                        for (int j=0; j<4; j++) {\n                            vec3 q=unpack(B2i(B[j]));\n                            if (length(uv-vec2(Dx*floor(uv1.x/Dx),Dy*floor(uv1.y/Dy))-vec2(Dx*q.x,Dy*q.y))<.005*(1.-.8*log(1.*A.z/rho0)))\n                                Col.xyz=max(Col.xyz,CP(log(A.w/A.z/min(.9*P0/rho0,Rn[3].x))/log(max(1.1*P0/rho0,Rn[3].y)/min(.9*P0/rho0,Rn[3].x)),7));\n                        }}}}\n        } else {\n            if (ordQ(y4,uv.y-ysh,y1)) Col*=0.; \n            ColBar(7,3,CP); }\n    }\n    k=vec2(Btxt,ysh+.64); Col += vec4((K(6)+K(41)+K(37)+K(44)+K(36)+K(51)+K(250)).x);\n\n    vec4 Objs=texture(iChannel2, vec2(0.05,0.55)*str); \n    for (int i=0; i<=1; i++)  // Draw the two objects\n        if (Objs[i]==5.)      {uvN=uv-vec2(Ox*Lx+Bx0,Oy[i]); DrawBall(uvN,0,0,1);}\n        else if (Objs[i]==4.) {uvN=uv-vec2(Lx*(Ox+Px0),Oy[i]+Py0); DrawBullet(uvN,dyBP(uvN),dyTP(uvN),1.);}\n        else if (Objs[i]==3.) {uvN=uv-vec2(Lx*(Ox+Wx0),Oy[i]+Wy0); DrawWing(uvN,dyBW(uvN),dyTW(uvN),1.);}\n        else if (Objs[i]==2.) {uvN=uv-vec2(Lx*Ox+dxN,Oy[i]); DrawNoz(uvN,dyBbN1(uvN),dyBN1(uvN),dyTN1(uvN),dyTbN1(uvN),dyBhN1(uvN),dyThN1(uvN),1.);}\n        else if (Objs[i]==1.) {uvN=uv-vec2(Lx*Ox+dxN,Oy[i]); DrawNoz(uvN,dyBbN2(uvN),dyBN2(uvN),dyTN2(uvN),dyTbN2(uvN),dyBhN2(uvN),dyThN2(uvN),1.);}\n    \n    if (Separatrix && uv.x>Bx && ordQ(.5-dy,uv.y,.5+dy)) Col=vec4(1.);      // mark separatrix\n    if (iMouse.z>0. && M.x>Bx && uv.x>Bx && abs(length(uv-M)-.4)<1.1*dx) Col=vec4(1.); // mark zoom\n\n    // Display controls: Mach number, angle theta, time step parameter delta.\n    vec4 Ctrl=texture(iChannel2, vec2(0.05,0.05)*str); \n    float hM=hM(Ctrl.x), hT=hT(Ctrl.y), hC=hC(Ctrl.z);\n    Control(.25, ClH1, hM, 13);\n    k=vec2(.005,.66); Col+=vec4((K(240+int(Ctrl.x))+K(238)+K(240+int(mod(10.*Ctrl.x,10.)))).x);\n    Control(.25, ClH2, hT, 69);\n    k=vec2(.001,.33); if (Ctrl.y>=0.) Col+=vec4(K(235).x); else Col+=vec4(K(237).x);\n    Col += vec4((K(240+int(abs(Ctrl.y)/10.))+K(240+int(mod(abs(Ctrl.y),10.)))).x);\n    Control(.75, ClH1, hC, 67);\n    k=vec2(.09,.66); Col+=vec4((K(238)+K(240+int(mod(10.*Ctrl.z,10.)))+K(240+int(mod(100.*Ctrl.z,10.)))+K(240+int(mod(1000.*Ctrl.z,10.)))).x);\n\n    float ofx, ofy, scl, ofIm;\n    if (iTime<.1)        \n        if (ordQ(Bx,uv0.x,Sx)) { // Object selection\n            Col=vec4(0.,0,0,1);\n            if (ordQ(Objs.x,uv0.y*nBut,Objs.x+1.) || ordQ(Objs.y,(uv0.y-.5)*nBut,Objs.y+1.)) Col.y=.7;\n            if (uv0.x-Bx<1.1*dx || Sx-uv0.x<1.1*dx || mod(uv0.y,1./nBut)<1.1*dy) Col=vec4(1.);\n            for (int i=0; i<=1; i++) {\n                ofIm=float(i)*6.;\n                ofx=Bx+.5*(Sx-Bx); scl=10./nBut; ofy=(5.5+ofIm)/nBut; DrawBall(uv0-vec2(ofx,ofy),0,0,scl);\n                ofx=Bx+.8*(Sx-Bx); scl=10./nBut; ofy=(4.5+ofIm)/nBut; uvN=(uv0-vec2(ofx,ofy))/scl; DrawBullet(uvN,dyBP(uvN),dyTP(uvN),scl);\n                ofx=Bx+.5*(Sx-Bx); scl=3.5/nBut; ofy=(3.5+ofIm)/nBut; uvN=(uv0-vec2(ofx,ofy))/scl; DrawWing(uvN,dyBW(uvN),dyTW(uvN),scl);\n                ofx=Bx+.53*(Sx-Bx); scl=3.3/nBut; ofy=(2.5+ofIm)/nBut; uvN=(uv0-vec2(ofx,ofy))/scl; DrawNoz(uvN,dyBbN1(uvN),dyBN1(uvN),dyTN1(uvN),dyTbN1(uvN),dyBhN1(uvN),dyThN1(uvN),scl);\n                ofx=Bx+.53*(Sx-Bx); scl=3.3/nBut; ofy=(1.5+ofIm)/nBut; uvN=(uv0-vec2(ofx,ofy))/scl; DrawNoz(uvN,dyBbN2(uvN),dyBN2(uvN),dyTN2(uvN),dyTbN2(uvN),dyBhN2(uvN),dyThN2(uvN),scl);\n            }\n        }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common: Geometry and parameter setup.\n// ______________________________________\n\n#define pi    3.14159265358979\n#define pi2   6.28318530717959\n#define pi05  1.57079632679490\n#define piInv 0.31830988618379\n#define Deg  0.01745329251994\n#define ordQ(i,j,k) (i<=j? (j<=k? true:false) : false)\n\n// Time stepping (CFL) parameter:\n#define CFL0 .055 // lower value if code crashes on your setup.\n\n// Hydro params:\n#define rho0 1.\n#define P0 1.\n#define M0 2.0\n#define Theta0 0.\n#define G 1.4 // adiabatic index\n\n// Nozzle inlets\n#define P1 20.\n#define rho1 5.\n\n// Separate the two objects?\n#define Separatrix true\n\n// T-blob visualization\n#define SU 3.\n#define DT .05\n#define Nx 40.\n#define Ny 40.\nfloat Dx,Dy;\n\n// Object select\n#define nBut 12.\n\n// Controls\n#define Bx .20 \n#define Mmax 10.\n#define Tmax 20.\n#define Cmax .3\n#define ClH1 .85\n#define ClH2 .52\n#define CldH .12\n#define CldW .03\n#define ClLdW .005\n#define ClBdW .03\n#define ClBdH .01\n#define ClTdH .02\nfloat hM(float M) { return ClH1+CldH*log(M*10./Mmax)/log(10.); }\nfloat hT(float T) { return ClH2+CldH*T/Tmax; }\nfloat hC(float C) { return ClH1+CldH*log(C*10./Cmax)/log(10.); }\n\n// Object positions\n#define Ox .8\n#define Oy vec2(.2495,.7505)\n\n// Wing 1 (NACA 2315) geometry:\n#define Wdx .22\n#define Wx0 (-.28*Wdx)\n#define Wy0 0. \n#define WxL (-.5*Wdx)\n#define WxR (+.5*Wdx)\n#define Wm .02\n#define Wp .3\n#define Wt .15\n\nfloat dyTW(vec2 xy) { // Oriented distance from top edge of object 1\n    float Wc, x1=(.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) Wc=(Wm/Wp/Wp)*(2.*Wp*x1-x2);\n    else Wc=(Wm/(1.-Wp)/(1.-Wp))*(1.-2.*Wp+2.*Wp*x1-x2);\n    return xy.y-((+5.*Wt*(.2969*sqrt(x1)-.126*x1-.3516*x2+.2843*x2*x1-.1015*x2*x2)+Wc)*Wdx); \n}\n\nfloat dyBW(vec2 xy) { // Oriented distance from bottom edge of object 1\n    float Wc, x1=(.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) Wc=(Wm/Wp/Wp)*(2.*Wp*x1-x2);\n    else Wc=(Wm/(1.-Wp)/(1.-Wp))*(1.-2.*Wp+2.*Wp*x1-x2);\n    return xy.y-((-5.*Wt*(.2969*sqrt(x1)-.126*x1-.3516*x2+.2843*x2*x1-.1015*x2*x2)+Wc)*Wdx); \n}\n\nvec2 NormTW(vec2 xy) { // Normal to top edge of object 1\n    float dWc, x1=(.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*Wp*Wp);\n    else dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*(-1.+Wp)*(-1.+Wp));\n    float a=atan(dWc + Wt*(.63+(3.516*x1)/Wdx-(4.2645*x2)/Wdx/Wdx+(2.03*x1*x2)/(Wdx*Wdx*Wdx)-.74225/pow(x1/Wdx,.5)));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormBW(vec2 xy) { // Normal to bottom edge of object 1\n    float dWc, x1=(.5*Wdx-xy.x)/Wdx, x2=x1*x1;\n    if (x1<=Wp) dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*Wp*Wp);\n    else dWc=(-2.*Wdx*Wm*Wp+2.*Wm*x1)/(Wdx*(-1.+Wp)*(-1.+Wp));\n    float a=atan(dWc - Wt*(.63+(3.516*x1)/Wdx-(4.2645*x2)/Wdx/Wdx+(2.03*x1*x2)/(Wdx*Wdx*Wdx)-.74225/pow(x1/Wdx,.5)));\n    return vec2(-sin(a),cos(a));\n}\n\n// Bullet (9mm para) geometry:\n#define Px0 0.\n#define Py0 0.\n#define PxW .06\n#define PxL -PxW\n#define PxR 0.\n#define PGa0 -0.9593547317\n#define PGa1 0.3796971491\n#define PGa2 1.00765454176\n#define PGa3 0.1\n#define PGb0 -0.6499357907\n#define PGb1 0.2804347826\n#define PGc1 0.5125832490\n#define PGc2 -0.0018639770\n#define PGc3 0.7279912002\n#define PGc4 1.2399299790\n#define PGc5 0.4\n#define PGd1 0.25358466168\n\nfloat dyTP(vec2 xy) { // Oriented distance from top edge of bullet\n    float x=xy.x/PxW;\n    if (x<PGa0) return xy.y-PxW*(PGa1*pow(PGa2+x,PGa3));\n    if (x<PGb0) return xy.y-PxW*PGb1;\n    return xy.y-PxW*PGc1*pow(PGc2-x-PGc3*pow(-x,PGc4),PGc5);\n}\n\nfloat dyBP(vec2 xy) { // Oriented distance from bottom edge of bullet\n    float x=xy.x/PxW;\n    if (x<PGa0) return xy.y+PxW*(PGa1*pow(PGa2+x,PGa3));\n    if (x<PGb0) return xy.y+PxW*PGb1;\n    return xy.y+PxW*PGc1*pow(PGc2-x-PGc3*pow(-x,PGc4),PGc5);\n}\n\nfloat dxLP(vec2 xy) { // Oriented distance from left edge of bullet\n    return -PxW-xy.x;\n}\n\nvec2 NormTP(vec2 xy) { // Normal to top edge of bullet\n    float a, x=xy.x/PxW;\n    if (x<PGa0)\n        a=(PGa3*PGa1*pow(PGa2+x,PGa3-1.));\n    else if (x<PGb0)\n        a=pi05;\n    else a=PGc5*PGc1*pow(PGc2-x-PGc3*pow(-x,PGc4),PGc5-1.)*(-1.+PGc3*PGc4*pow(-x,PGc4-1.));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormBP(vec2 xy) { // Normal to bottom edge of bullet\n    float a, x=xy.x/PxW;\n    if (x<PGa0)\n        a=-(PGa3*PGa1*pow(PGa2+x,PGa3-1.));\n    else if (x<PGb0)\n        a=-pi05;\n    else a=-PGc5*PGc1*pow(PGc2-x-PGc3*pow(-x,PGc4),PGc5-1.)*(-1.+PGc3*PGc4*pow(-x,PGc4-1.));\n    return vec2(-sin(a),cos(a));\n}\n\n// Ball geometry\n#define Br .02\n#define Bx0 -Br\n\n// Nozzle geometries\n#define dxN -0.12\n#define xR0N 0.12\n#define xL0N -.12\n#define xLN -.12\n#define xRN -.02\n\n// Nozzle 1 geometry\n#define yBN -.028\n#define yTN +.028\n#define yfON 1.16\n#define dyN (yTN-yBN)*.34\n#define oN1phi -1.0472\n\nfloat dyBN1(vec2 xy) { // Oriented distance from bottom inner edge of nozzle 1\n    return xy.y-(yBN-dyN*cos(pi2*(oN1phi+1.-xy.x/xLN)));\n}\n\nfloat dyBbN1(vec2 xy) { // Oriented distance from bottom outer edge of nozzle 1\n    return xy.y-yfON*(yBN-dyN*cos(pi2*oN1phi));\n}\n\nfloat dyTN1(vec2 xy) { // Oriented distance from top inner edge of nozzle 1\n    return xy.y-(yTN+dyN*cos(pi2*(oN1phi+1.-xy.x/xLN)));\n}\n\nfloat dyTbN1(vec2 xy) { // Oriented distance from top outer edge of nozzle 1\n    return xy.y-yfON*(yTN+dyN*cos(pi2*oN1phi));\n}\n\nvec2 NormBN1(vec2 xy) { // Normal to bottom inner edge of nozzle 1\n    float a=atan(pi2*dyN*sin(pi2*(oN1phi+1.-xy.x/xLN))/(-xLN));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormTN1(vec2 xy) { // Normal to top inner edge of nozzle 1\n    float a=atan(pi2*dyN*sin(pi2*(oN1phi+1.-xy.x/xLN))/(xLN));\n    return vec2(-sin(a),cos(a));\n}\n\nfloat dyBhN1(vec2 xy) { // Oriented distance from bottom edge of head 1\n    return xy.y-(yfON*(yBN-dyN*cos(pi2*oN1phi))*cos(pi05*xy.x/xR0N));\n}\n\nfloat dyThN1(vec2 xy) { // Oriented distance from top edge of head 1\n    return xy.y-(yfON*(yTN+dyN*cos(pi2*oN1phi))*cos(pi05*xy.x/xR0N));\n}\n\nvec2 NormBhN1(vec2 xy) { // Normal to bottom edge of head 1\n    float a=atan(yfON*(yBN-dyN*cos(pi2*oN1phi))*(-pi05/xR0N)*sin(pi05*xy.x/xR0N));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormThN1(vec2 xy) { // Normal to top edge of head 1\n    float a=atan(yfON*(yTN+dyN*cos(pi2*oN1phi))*(-pi05/xR0N)*sin(pi05*xy.x/xR0N));\n    return vec2(-sin(a),cos(a));\n}\n\n// Nozzle 2 geometry\n#define yBN2 -0.035\n#define yTN2 +0.035\n#define dyN2 (yTN2-yBN2)*.2\n#define fN2 7.853981\n#define phN2 11.799\n#define yfON2 1.19\n\nfloat dyBN2(vec2 xy) { // Oriented distance from bottom inner edge of nozzle 2\n    return xy.y-(yBN2-dyN2*cos(fN2*xy.x+phN2));\n}\n\nfloat dyBbN2(vec2 xy) { // Oriented distance from bottom outer edge of nozzle 2\n    return xy.y-yfON2*(yBN2-dyN2*cos(phN2));\n}\n\nfloat dyTN2(vec2 xy) { // Oriented distance from top inner edge of nozzle 2\n    return xy.y-(yTN2+dyN2*cos(fN2*xy.x+phN2));\n}\n\nfloat dyTbN2(vec2 xy) { // Oriented distance from top outer edge of nozzle 2\n    return xy.y-yfON2*(yTN2+dyN2*cos(phN2));\n}\n\nvec2 NormBN2(vec2 xy) { // Normal to bottom inner edge of nozzle 2\n    float a=atan(fN2*dyN2*sin(fN2*xy.x+phN2));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormTN2(vec2 xy) { // Normal to top inner edge of nozzle 2\n    float a=atan(-fN2*dyN2*sin(fN2*xy.x+phN2));\n    return vec2(-sin(a),cos(a));\n}\n\nfloat dyBhN2(vec2 xy) { // Oriented distance from bottom edge of head 2\n    return xy.y-(yfON2*(yBN2-dyN2*cos(phN2))*cos(pi05*xy.x/xR0N));\n}\n\nfloat dyThN2(vec2 xy) { // Oriented distance from top edge of head 2\n    return xy.y-(yfON2*(yTN2+dyN2*cos(phN2))*cos(pi05*xy.x/xR0N));\n}\n\nvec2 NormBhN2(vec2 xy) { // Normal to bottom edge of head 2\n    float a=atan(yfON2*(yBN2-dyN2*cos(phN2))*(-pi05/xR0N)*sin(pi05*xy.x/xR0N));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormThN2(vec2 xy) { // Normal to top edge of head 2\n    float a=atan(yfON2*(yTN2+dyN2*cos(phN2))*(-pi05/xR0N)*sin(pi05*xy.x/xR0N));\n    return vec2(-sin(a),cos(a));\n}\n\n// Sample packing/unpacking:\n#define B2f(i) intBitsToFloat(i)\n#define B2i(f) floatBitsToInt(f)\n#define Spack(qx, qy) intBitsToFloat((B2i(qx)&0xFFFF0000)|((B2i(qy)>>16)&0xFFFF))\n#define Spack2(q) intBitsToFloat((B2i(q.x)&0xFFFF0000)|((B2i(q.y)>>16)&0xFFFF))\n#define Sunpack(Q) vec2(B2f(B2i(Q)&0xFFFF0000), B2f((B2i(Q)&0xFFFF)<<16))\n\n// T-blob packing/unpacking:\n#define B1 14\n#define B2 14\n#define B3 4\nfloat b1=float((1<<B1)), b2=float((1<<B2)), b3=float((1<<B3));\n#define pack(qx,qy,qT) intBitsToFloat( (int(b1*qx)<<(B2+B3)) | (int(b2*qy)<<B3) | int(b3*qT) )\n#define unpack(Q) vec3(float(((Q>>(B2+B3))&((1<<B1)-1)))/b1,float(((Q>>B3)&((1<<B2)-1)))/b2,float(Q&((1<<B3)-1))/b3)\n\n// Hash\nfloat h(float I, float F) {\n    float combined = log(abs(I))/53.432 - log(abs(F))/23.364;\n    combined = fract(sin(combined*8264.2352)*4758.5453);\n    return fract(combined);\n}\n#define pack01 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N11*Dx,(1.+floor(uv.y/Dy))*n11*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N12*Dx,(1.+floor(uv.y/Dy))*n12*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N13*Dx,(1.+floor(uv.y/Dy))*n13*Dy)) )\n#define pack02 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N21*Dx,(1.+floor(uv.y/Dy))*n21*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N22*Dx,(1.+floor(uv.y/Dy))*n22*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N23*Dx,(1.+floor(uv.y/Dy))*n23*Dy)) )\n#define pack03 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N31*Dx,(1.+floor(uv.y/Dy))*n31*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N32*Dx,(1.+floor(uv.y/Dy))*n32*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N33*Dx,(1.+floor(uv.y/Dy))*n33*Dy)) )\n#define pack04 intBitsToFloat( (int(b1*h((1.+floor(uv.x/Dx))*N41*Dx,(1.+floor(uv.y/Dy))*n41*Dy))<<(B2+B3)) | (int(b2*h((1.+floor(uv.x/Dx))*N42*Dx,(1.+floor(uv.y/Dy))*n42*Dy))<<B3) | int(b3*h((1.+floor(uv.x/Dx))*N43*Dx,(1.+floor(uv.y/Dy))*n43*Dy)) )\n\n// Hash parameters (meaningless):\n#define n11 25236.264\n#define n12 46247.964\n#define n13 85446.343\n#define n21 74447.543\n#define n22 89345.434\n#define n23 78446.211\n#define n31 27242.754\n#define n32 93546.123\n#define n33 62147.141\n#define n41 57342.548\n#define n42 17445.547\n#define n43 56781.135\n#define N11 12411.346\n#define N12 76235.373\n#define N13 33743.748\n#define N21 72361.843\n#define N22 26898.834\n#define N23 58133.782\n#define N31 81345.853\n#define N32 82788.286\n#define N33 17457.842\n#define N41 14825.174\n#define N42 45856.723\n#define N43 56823.432\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: Initial and boundary conditions.\n// Two objects placed according to choices in Channel1.\n// ____________________________________________________\n\n\n#define N1or2(a,b) (Objs[i]==2.? a:b)\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    float dx, dy, Lx=iResolution.x/iResolution.y, AspR;\n    vec2 rV, Asp=vec2(1.,AspR), uv=Coo.xy/iResolution.y, str=vec2(1./Lx,1.);\n    dx=dy=1./iResolution.y; AspR=dy/dx;\n    vec4 Ctrl=texture(iChannel1, vec2(.05,.05)*str);\n    vec2 vIn=Ctrl.x*sqrt(G*P0/rho0)*vec2(-cos(Ctrl.y*Deg),sin(Ctrl.y*Deg));\n\n    Col = texture(iChannel0, uv*str); // Fetch pixel and neighbors\n    vec4 AR=texture(iChannel0, (uv+vec2(dx,.0))*str);\n    vec4 AL=texture(iChannel0, (uv-vec2(dx,.0))*str);\n    vec4 AU=texture(iChannel0, (uv+vec2(.0,dy))*str);\n    vec4 AD=texture(iChannel0, (uv-vec2(.0,dy))*str);\n\n    // Box boundary conditions\n    if (uv.x<1.1*dx)                           // Left boundary\n        Col = vec4(-abs(AR.x),AR.yzw);                     // outflow\n    if (uv.x>Lx-1.1*dx)                        // Right boundary\n        Col = vec4(vIn,rho0,P0);                           // ambient inflow\n    if (Separatrix && ordQ(-dy,uv.y-.5,dy))    // Inside separatrix\n            Col = vec4(0.,0.,rho0,P0);                     // ambient stationary\n    if (uv.y<1.1*dy || (Separatrix && ordQ(dy,uv.y-.5,2.1*dy)) ) {     // A bottom boundary\n        if (Ctrl.y<=0.) Col = vec4(AU.x,-abs(AU.y),AU.zw); // outflow\n        else Col = vec4(vIn,rho0,P0); }                    // ambient inflow\n    if (uv.y>1.-1.1*dy || (Separatrix && ordQ(-2.1*dy,uv.y-.5,-dy))) { // A top boundary                        // Top boundary\n        if (Ctrl.y>=0.) Col = vec4(AD.x,+abs(AD.y),AD.zw); // outflow\n        else Col = vec4(vIn,rho0,P0); }                    // ambient inflow\n\n\n    // Object boundary + initial conditions\n    vec4 ColI=vec4(vIn,rho0,P0), Objs=texture(iChannel1, vec2(0.05,0.55)*str); \n    for (int i=0; i<=1; i++) \n        if (Objs[i]==5.) { // Ball\n            float phi, r=length(rV=uv-vec2(Ox*Lx+Bx0,Oy[i]));\n            if (r<=Br) ColI=Col=vec4(0.,0.,rho0,P0);  // steady ambient inside ball\n            else if (r<Br+1.1*dx) {               // slip around ball\n                phi=atan(rV.y,rV.x)*piInv; rV=normalize(rV);\n                if (abs(phi)<=.25) Col = vec4(AR.xy-rV*dot(AR.xy,rV),AR.zw); \n                else if (abs(phi-.5)<=.25) Col = vec4(AU.xy-rV*dot(AU.xy,rV),AU.zw); \n                else if (abs(phi+.5)<=.25) Col = vec4(AD.xy-rV*dot(AD.xy,rV),AD.zw); \n                else Col = vec4(AL.xy-rV*dot(AL.xy,rV),AL.zw);\n            }\n        }\n        else if (Objs[i]==4.) { // Bullet\n            vec2 uvP=uv-vec2(Lx*(Ox+Px0),Oy[i]+Py0);\n            if ordQ(PxL-1.1*dx,uvP.x,PxR+1.1*dx) {   // near-body x range\n                float dyB=AspR*dyBP(uvP), dyT=AspR*dyTP(uvP);\n                if ordQ(PxL,uvP.x,PxR) {             // body x range\n                    if (ordQ(dyT,0.,dyB)) ColI=Col=vec4(0.,0.,rho0,P0); // steady ambient inside body\n                    else if ordQ(dyT-1.1*dy,0.,dyB) Col = vec4(AU.xy-NormTP(uvP)*Asp*dot(AU.xy,NormTP(uvP)*Asp),AU.zw); // slip\n                    else if ordQ(dyT,0.,dyB+1.1*dy) Col = vec4(AD.xy-NormBP(uvP)*Asp*dot(AD.xy,NormBP(uvP)*Asp),AD.zw); // slip\n                } else {\n                    if (uvP.x>PxR && abs(uvP.y)<2.1*dy) Col = vec4(0.,AR.yzw);    // nose slip                  \n                    else if (uvP.x<PxL && abs(uvP.y)<PxW*PGd1) Col = vec4(0.,AL.yzw);  // tail slip\n                }\n            }\n        }\n        else if (Objs[i]==3.) { // Wing\n            vec2 uvP=uv-vec2(Lx*(Ox+Wx0),Oy[i]+Wy0);\n            if ordQ(WxL-1.1*dx,uvP.x,WxR+1.1*dx) {   // near-body x range\n                float dyB=AspR*dyBW(uvP), dyT=AspR*dyTW(uvP);\n                if ordQ(WxL,uvP.x,WxR) {             // body x range\n                    if (ordQ(dyT,0.,dyB)) ColI=Col=vec4(0.,0.,rho0,P0); // steady ambient inside body\n                    else if ordQ(dyT-1.1*dy,0.,dyB) Col = vec4(AU.xy-NormTW(uvP)*Asp*dot(AU.xy,NormTW(uvP)*Asp),AU.zw); // slip\n                    else if ordQ(dyT,0.,dyB+1.1*dy) Col = vec4(AD.xy-NormBW(uvP)*Asp*dot(AD.xy,NormBW(uvP)*Asp),AD.zw); // slip\n                } else {\n                    if (uvP.x>WxR && abs(uvP.y)<1.1*dy) Col = vec4(0.,AR.yzw);  // nose slip                  \n                    else if (uvP.x<WxL && abs(uvP.y)<1.1*dy) Col = vec4(0.,AL.yzw);  // tail slip\n                }\n            }\n        }\n        else if (Objs[i]==2.||Objs[i]==1.) {     // nozzles\n            vec2 uvN=uv-vec2(Lx*Ox+dxN,Oy[i]);\n            if ordQ(.0001,uvN.x,xR0N+1.1*dx) {   // near-head x range\n                float dyB=AspR*N1or2(dyBhN1(uvN),dyBhN2(uvN)),dyT=AspR*N1or2(dyThN1(uvN),dyThN2(uvN));\n                if (uvN.x<=xR0N) {                                // head x range\n                    if (ordQ(dyT,0.,dyB)) ColI=Col=vec4(0.,0.,rho0,P0); // steady ambient inside head\n                    else if ordQ(dyT-1.1*dy,0.,dyB) Col = vec4(AU.xy-N1or2(NormThN1(uvN),NormThN2(uvN))*Asp*dot(AU.xy,N1or2(NormThN1(uvN),NormThN2(uvN))*Asp),AU.zw); // slip\n                    else if ordQ(dyT,0.,dyB+1.1*dy) Col = vec4(AD.xy-N1or2(NormBhN1(uvN),NormBhN2(uvN))*Asp*dot(AD.xy,N1or2(NormBhN1(uvN),NormBhN2(uvN))*Asp),AD.zw); // slip\n                } else if (abs(uvN.y)<1.6*dy) Col = vec4(0.,AR.yzw);    // nose slip                  \n            } \n            else if ordQ(xL0N-1.1*dx,uvN.x,xL0N) {                // Nozzle tail\n                float dyB=AspR*N1or2(dyBN1(uvN),dyBN2(uvN)),dyBb=AspR*N1or2(dyBbN1(uvN),dyBbN2(uvN)),dyT=AspR*N1or2(dyTN1(uvN),dyTN2(uvN)),dyTb=AspR*N1or2(dyTbN1(uvN),dyTbN2(uvN));          \n                if (ordQ(dyB,0.,dyBb)||ordQ(dyTb,0.,dyT)) Col = vec4(0.,AL.yzw);  // tail slip\n            }\n            else if ordQ(xL0N,uvN.x,0.) {                         // nozzle range\n                float dyB=AspR*N1or2(dyBN1(uvN),dyBN2(uvN)),dyT=AspR*N1or2(dyTN1(uvN),dyTN2(uvN));\n                if (ordQ(dyT,0.,dyB)) {                           // inside nozzle\n                    if (uvN.x>=xRN) ColI=Col=vec4(0.,0.,rho1,P1); // inlet\n                    else {\n                        float sm=(uvN.x-xL0N)/(xRN-xL0N); \n                        ColI=vec4(0.,0.,rho0+(rho1-rho0)*sm,P0+(P1-P0)*sm);\n                        if (dyB<1.1*dy)       Col = vec4(AU.xy-N1or2(NormBN1(uvN),NormBN2(uvN))*Asp*dot(AU.xy,N1or2(NormBN1(uvN),NormBN2(uvN))*Asp),AU.zw); // slip\n                        else if (dyT>-1.1*dy) Col = vec4(AD.xy-N1or2(NormTN1(uvN),NormTN2(uvN))*Asp*dot(AD.xy,N1or2(NormTN1(uvN),NormTN2(uvN))*Asp),AD.zw); // slip\n                    }\n                }\n                else {\n                    float dyBb=AspR*N1or2(dyBbN1(uvN),dyBbN2(uvN)),dyTb=AspR*N1or2(dyTbN1(uvN),dyTbN2(uvN));\n                    if ordQ(dyTb-1.1*dy,0.,dyTb) Col = vec4(AU.x,0.,AU.zw);      // outer slip\n                    else if ordQ(dyBb,0.,dyBb+1.1*dy) Col = vec4(AD.x,0.,AD.zw); // outer slip\n                }\n            }\n        }\n\n    if (iTime<.1) Col=ColI;  // Apply initial conditions\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: 2D ideal fluid solver, by ukeshet.\n// Simplest version: nearest neighbors only, operator splitting, donor-cell advection.\n// ____________________________________________________________________________________\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    float CV = 1./(G-1.), minV = .01;\n\n    // Grid\n    float dt, dx=1./iResolution.y, dy=dx; // lower CFL (defined in Common line 6) if crash.\n    vec2 uv = Coo.xy/iResolution.y, str=vec2(iResolution.y/iResolution.x,1.);\n    vec4 Ctrl=texture(iChannel1, vec2(0.05,0.05)*str);\n    float CFL=Ctrl.z;\n    dt = CFL*min(dx,dy);\n\n    // Fetch pixel and neighbours\n    vec4 A = texture(iChannel0, uv*str);\n    vec4 AR = texture(iChannel0, (uv+vec2(dx,.0))*str);\n    vec4 AL = texture(iChannel0, (uv-vec2(dx,.0))*str);\n    vec4 AU = texture(iChannel0, (uv+vec2(.0,dy))*str);\n    vec4 AD = texture(iChannel0, (uv-vec2(.0,dy))*str);\n\n    // Edge veclocities\n    float uR = .5*(AR.x+A.x), uL = .5*(AL.x+A.x);\n    float vU = .5*(AU.y+A.y), vD = .5*(AD.y+A.y);\n\n    // Mass flux\n    float frhoR = uR*(step(0.,uR)*A.z + step(uR,0.)*AR.z);\n    float frhoL = uL*(step(0.,uL)*AL.z + step(uL,0.)*A.z);\n    float frhoU = vU*(step(0.,vU)*A.z + step(vU,0.)*AU.z);\n    float frhoD = vD*(step(0.,vD)*AD.z + step(vD,0.)*A.z);\n    float rho2 = A.z - dt*( (frhoR-frhoL)/dx + (frhoU-frhoD)/dy );\n    rho2 = max(minV,rho2);\n\n    // x-momentum flux\n    float fpxR = uR*(step(0.,uR)*A.z*A.x + step(uR,0.)*AR.z*AR.x);\n    float fpxL = uL*(step(0.,uL)*AL.z*AL.x + step(uL,0.)*A.z*A.x);\n    float fpxU = vU*(step(0.,vU)*A.z*A.x + step(vU,0.)*AU.z*AU.x);\n    float fpxD = vD*(step(0.,vD)*AD.z*AD.x + step(vD,0.)*A.z*A.x);\n    float vx2 = ( A.z*A.x - dt*( (fpxR-fpxL)/dx + (fpxU-fpxD)/dy + (AR.w-AL.w)/dx/2. ) )/rho2;\n\n    // y-momentum flux\n    float fpyR = uR*(step(0.,uR)*A.z*A.y + step(uR,0.)*AR.z*AR.y);\n    float fpyL = uL*(step(0.,uL)*AL.z*AL.y + step(uL,0.)*A.z*A.y);\n    float fpyU = vU*(step(0.,vU)*A.z*A.y + step(vU,0.)*AU.z*AU.y);\n    float fpyD = vD*(step(0.,vD)*AD.z*AD.y + step(vD,0.)*A.z*A.y);\n    float vy2 = ( A.z*A.y - dt*( (fpyR-fpyL)/dx + (fpyU-fpyD)/dy + (AU.w-AD.w)/dy/2. ) )/rho2;\n\n    // Total energy*density\n    float erho = CV*A.w+.5*A.z*(A.x*A.x+A.y*A.y);\n    float erhoR = CV*AR.w+.5*AR.z*(AR.x*AR.x+AR.y*AR.y);\n    float erhoL = CV*AL.w+.5*AL.z*(AL.x*AL.x+AL.y*AL.y);\n    float erhoU = CV*AU.w+.5*AU.z*(AU.x*AU.x+AU.y*AU.y);\n    float erhoD = CV*AD.w+.5*AD.z*(AD.x*AD.x+AD.y*AD.y);\n\n    // Energy flux\n    float feR = uR*(step(0.,uR)*erho + step(uR,0.)*erhoR);\n    float feL = uL*(step(0.,uL)*erhoL + step(uL,0.)*erho);\n    float feU = vU*(step(0.,vU)*erho + step(vU,0.)*erhoU);\n    float feD = vD*(step(0.,vD)*erhoD + step(vD,0.)*erho);\n    float erho2 = erho - dt*( (feR-feL)/dx + (feU-feD)/dy +\n                              (AR.w*AR.x-AL.w*AL.x)/dx/2. + (AU.w*AU.y-AD.w*AD.y)/dy/2. );\n\n    // Reconstruct pressure\n    float P2 = (erho2 - .5*rho2*(vx2*vx2+vy2*vy2))/CV;\n    P2 = max(minV,P2);\n\n    Col = vec4(vx2,vy2,rho2,P2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C: controls + temperature blob evolution.\n// ________________________________________________\n\n\nvoid mainImage(out vec4 Col, in vec2 Coo)\n{\n    float dx, dy, dt, Lx=iResolution.x/iResolution.y, Sx=Bx+1./nBut;\n    vec2 uv=Coo.xy/iResolution.y, str=vec2(iResolution.y/iResolution.x,1.);\n    dx=dy=1./iResolution.y; \n    vec4 Ctrl=texture(iChannel1, vec2(0.05,0.05)*str);\n    dt=Ctrl.z*min(dx,dy);\n    vec2 M=iMouse.xy/iResolution.y; float Mz=iMouse.z;\n    Dx=round(iResolution.y/Nx)/iResolution.x; Dy=round(iResolution.y/Ny)/iResolution.y;\n    if (iFrame<1) {\n        if (uv.x<Bx) {               // Outside displayed simulation box\n            if (uv.y<.1)             // encode controls here\n                Col=vec4(M0,Theta0,CFL0,0.);\n            if (uv.y>.9)             // encode colormap sampling here\n                Col=vec4(Spack2(M0*vec2(.9,1.1)),Spack2(rho0*vec2(.9,1.1)),\n                         Spack2(P0*vec2(.9,1.1)),Spack2(P0/rho0*vec2(.9,1.1)));\n            if (ordQ(.5,uv.y,.6))    // encode buttons here\n                Col=vec4(1.,2.,0,0); // Default objects\n        } \n        else Col=vec4(pack01,pack02,pack03,pack04);\n    } else {\n        vec4 B=texture(iChannel1, uv*str);\n        for (int j=0; j<4; j++) {\n            vec2 cell=vec2(Dx*floor(uv.x/Dx),Dy*floor(uv.y/Dy));\n            vec3 q=unpack(B2i(B[j]));\n            float rx=Dx*q.x, ry=Dy*q.y;\n            vec4 A=texture(iChannel0, (cell+vec2(rx,ry))*str);\n                rx+=A.x*dt*SU;\n                ry+=A.y*dt*SU;\n            float crossed, qT=q[2];\n            if (abs(crossed=floor(rx/Dx))>0.) { // blob crossed to next cell\n                ry=Dy*h(n22*(1.+cell.x)*iTime,N22*(1.+cell.y)*iTime);\n                rx=Dx*(.45*(1.-crossed)+.1*h(n12*(1.+cell.x)*iTime,N12*(1.+cell.y)*iTime));\n            }\n            if (abs(crossed=floor(ry/Dy))>0.) { // blob crossed to next cell\n                rx=Dx*h(n22*(1.+cell.x)*iTime,N22*(1.+cell.y)*iTime);\n                ry=Dy*(.45*(1.-crossed)+.1*h(n12*(1.+cell.x)*iTime,N12*(1.+cell.y)*iTime));\n            }\n            Col[j]=pack(fract(rx/Dx),fract(ry/Dy),qT);\n        }\n        if (uv.x<Bx) {\n            if (uv.y<.1) { // controls encoded here\n                Col=B;\n                if (Mz>0.) {\n                    if (abs(M.x-.25*Bx)<CldW && abs(M.y-ClH1)<CldH)\n                        Col.x=(Mmax/10.)*pow(10.,(M.y-ClH1)/CldH);\n                    if (abs(M.x-.25*Bx)<CldW && abs(M.y-ClH2)<CldH)\n                        Col.y=Tmax*(M.y-ClH2)/CldH;\n                    if (abs(M.x-.75*Bx)<CldW && abs(M.y-ClH1)<CldH)\n                        Col.z=(Cmax/10.)*pow(10.,(M.y-ClH1)/CldH);\n                }\n            }\n            if (ordQ(.5,uv.y,.6)) {    // buttons encoded here\n                Col=B;\n                if (Mz>0. && ordQ(Bx,M.x,Sx)) \n                    if (!ordQ(0.,M.y,1./nBut) && !ordQ(0.,M.y-.5,1./nBut)) // button available\n                        if (M.y<.5) Col.x=floor(M.y*nBut); \n                        else Col.y=floor((M.y-.5)*nBut);\n            }\n            if (uv.y>.9) { // colormap sampling here\n                vec4 S0=vec4(Ctrl.x,rho0,P0,P0/rho0), Smin=S0, Smax=Smin;\n                for (float x=5.*dx; x<Lx; x+=(Lx-10.*dx)/2.)\n                    for (float y=5.*dy; y<1.; y+=(1.-10.*dx)/2.) { // sample edges\n                        vec4 Samp=texture(iChannel0, vec2(x,y)*str);\n                        Smin=min(Smin,vec4(length(Samp.xy)*sqrt(Samp.z/(G*Samp.w)),Samp.zw,Samp.w/Samp.z));\n                        Smax=max(Smax,vec4(length(Samp.xy)*sqrt(Samp.z/(G*Samp.w)),Samp.zw,Samp.w/Samp.z));\n                    }\n                vec4 objXY=vec4(Ox*Lx,Oy[0],Ox,Oy[1]);\n                for (int obj=0; obj<=1; obj++) // sample around both bodies\n                    for (float r=.07; r<0.21; r+=.05)\n                        for (float phi=-pi; phi<=.99*pi; phi+=pi/6.) {\n                            vec4 Samp=texture(iChannel0, vec2(objXY[2*obj]+Lx*r*cos(phi),objXY[2*obj+1]+r*sin(phi))*str);\n                            Smin=min(Smin,vec4(length(Samp.xy)*sqrt(Samp.z/(G*Samp.w)),Samp.zw,Samp.w/Samp.z));\n                            Smax=max(Smax,vec4(length(Samp.xy)*sqrt(Samp.z/(G*Samp.w)),Samp.zw,Samp.w/Samp.z));\n                    }\n                vec4 pSamp=texture(iChannel1, vec2(0.05,.95)*str);\n                Smin=max(Smin,.01); // Spack fails on 0.\n                for (int j=0;j<=3;j++) {\n                    vec2 pSampj=Sunpack(pSamp[j]);\n                    Col[j]=Spack(mix(pSampj[0],Smin[j],.2),mix(pSampj[1],Smax[j],.2));\n                }\n            }\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}