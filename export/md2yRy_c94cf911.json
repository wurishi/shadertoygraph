{"ver":"0.1","info":{"id":"md2yRy","date":"1687868471","viewed":81,"name":"树 - 黏土风","username":"amuda","description":"render a tree, maybe add same detail later","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","model"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE 1000.0\n#define LIGHT0_COLOR vec3(0.8, 0.8, 0.75)\n#define LIGHT0_DIR vec3(1.0, 1.0, 0.5)\n\n// 第一个枝丫\nfloat treeBranch1(in vec3 p)\n{\n    p -= vec3(0.2, 2.0, 0.0);\n    p = p.xzy;\n    float h = sdTorus(p, vec2(1.0, 0.17));\n    h = opSubtraction(p.x, h);\n    h = opSubtraction(-p.z, h);\n    return h;\n}\n\n// 第二个枝丫\nfloat treeBranch2(in vec3 p)\n{\n    p -= vec3(0.0, 3.0, 0.0);\n        float theta = -PI / 3.0;\n    mat3 rotateMat = mat3(\n        cos(theta), 0, -sin(theta),\n        0, 1, 0, sin(theta),\n        0, cos(theta));\n    p = p * rotateMat;\n    p = p.xzy;\n    float h = sdTorus(p, vec2(1.0, 0.13));\n    h = opSubtraction(p.x, h);\n    h = opSubtraction(-p.z, h);\n    return h;\n}\n\n// 第三个枝丫\nfloat treeBranch3(in vec3 p)\n{\n    p -= vec3(0.0, 3.8, 0.0);\n        float theta = PI / 3.0;\n    mat3 rotateMat = mat3(\n        cos(theta), 0, -sin(theta),\n        0, 1, 0, sin(theta),\n        0, cos(theta));\n    p = p * rotateMat;\n    p = p.xzy;\n    float h = sdTorus(p, vec2(0.3, 0.15));\n    h = opSubtraction(p.x, h);\n    h = opSubtraction(-p.z, h);\n    return h;\n}\n\n// 第四个枝丫\nfloat treeBranch4(in vec3 p)\n{\n    p -= vec3(0.0, 3.2, 0.0);\n\n    float theta = PI / 6.0;\n    \n    theta = 0.0 / 6.0;\n    mat3 rotateMat = mat3(\n        1, 0, 0,\n        0, cos(theta), sin(theta),\n        0, -sin(theta), cos(theta));\n    p = p * rotateMat;\n\n    theta = PI / 6.0;\n    rotateMat = mat3(\n        cos(theta), sin(theta), 0,\n        -sin(theta), cos(theta), 0,\n        0, 0, 1);\n    p = p * rotateMat;\n\n    rotateMat = mat3(\n         cos(theta), 0, -sin(theta),\n         0, 1, 0, \n        sin(theta), 0, cos(theta));\n    p = p * rotateMat;\n\n    float h = sdVerticalCapsule(p, 1.5, 0.13);\n    return h;\n}\n\n\n\nvec2 map(vec3 p)\n{\n    float d = 9999999.0;\n    int mat = 0;\n    float h;\n\n    // h = sdSphere(p - vec3(0.0, 1.0, 0.0), 0.15);\n\n    // 树干\n    h = treeBody(p, 3.5, 0.27);\n    float branch1 = treeBranch1(p);\n    h = opSmoothUnion(branch1, h, 0.1);\n\n    float branch2 = treeBranch2(p);\n    h = opSmoothUnion(branch2, h, 0.1);\n\n    float branch3 = treeBranch3(p);\n    h = opSmoothUnion(branch3, h, 0.1);\n\n    float branch4 = treeBranch4(p);\n    h = opSmoothUnion(branch4, h, 0.15);\n\n    // testFunc();\n    // h = sdSphere(p, 0.1);\n    if (h < d)\n    {\n        d = h;\n        mat = 0;\n    }\n\n    // 树叶\n    float leaves1 = sdLeave(p - vec3(1.3, 2.0, 0.0), 0.7);\n    h = opUnion(h, leaves1);\n    if (h < d)\n    {\n        d = h;\n        mat = 1;\n    }\n\n    float leaves2 = sdLeave(p - vec3(0.5, 2.8, 1.0), 1.0);\n    h = opUnion(h, leaves2);\n    if (h < d)\n    {\n        d = h;\n        mat = 2;\n    }\n\n    float leaves3 = sdLeave(p - vec3(0.3, 4.0, -0.22), 0.4);\n    h = opUnion(h, leaves3);\n    if (h < d)\n    {\n        d = h;\n        mat = 2;\n    }\n\n    float leaves4 = sdLeave(p - vec3(-1.2, 4.7, 0.0), 1.3);\n    h = opUnion(h, leaves4);\n    if (h < d)\n    {\n        d = h;\n        mat = 3;\n    }\n\n    return vec2(d, mat);\n}\n\nvec2 rayMarching(vec3 startPoint, vec3 direction)\n{\n    float t = 0.0;\n    vec3 newPoint = startPoint;\n    while(t < MAX_DISTANCE)\n    {\n        vec2 result = map(newPoint);\n        t += result.x * 0.6;\n        if (result.x < 0.01)\n        {\n            return vec2(t, result.y);\n        }\n        newPoint = startPoint + t * direction;\n    }\n    return vec2(-1.0, 0);\n}\n\n\nvec3 materail0(vec3 lighDir, vec3 normal, vec3 viewDir, float shadow)\n{\n    vec3 ambient = vec3(0.13, 0.08,  0.03);\n    vec3 diffusion = vec3(0.2);\n    float diffusionRatio = clamp(dot(lighDir, normal), 0.0, 1.0);\n    vec3 specular = vec3(0.03);\n    float specularRatio = pow(clamp(dot(normalize((viewDir + lighDir) / 2.0), normal), 0.0, 1.0), 2.0);\n    \n    // rim\n    vec3 rim = vec3(0.1) * clamp((1.0 - dot(viewDir, normal)), 0.0, 1.0);\n    \n    return ambient + (diffusion * diffusionRatio + specular * specularRatio) * LIGHT0_COLOR * shadow + rim;\n}\n\nvec3 materail1(vec3 lighDir, vec3 normal, vec3 viewDir, float shadow)\n{\n    vec3 ambient = vec3(0.04, 0.13,  0.01);\n    vec3 diffusion = vec3(0.1);\n    float diffusionRatio = clamp(dot(lighDir, normal), 0.0, 1.0);\n    vec3 specular = vec3(0.03);\n    float specularRatio = pow(clamp(dot(normalize((viewDir + lighDir) / 2.0), normal), 0.0, 1.0), 2.0);\n    \n    // rim\n    vec3 rim = vec3(0.16) * clamp((1.0 - dot(viewDir, normal)), 0.0, 1.0);\n    \n    return ambient + (diffusion * diffusionRatio + specular * specularRatio) * LIGHT0_COLOR * shadow + rim;\n}\n\nvec3 materail2(vec3 lighDir, vec3 normal, vec3 viewDir, float shadow)\n{\n    vec3 ambient = vec3(0.04, 0.33,  0.01);\n    vec3 diffusion = vec3(0.1, 0.1, 0.1);\n    float diffusionRatio = clamp(dot(lighDir, normal), 0.0, 1.0);\n    vec3 specular = vec3(0.1, 0.1, 0.1);\n    float specularRatio = pow(clamp(dot(normalize((viewDir + lighDir) / 2.0), normal), 0.0, 1.0), 2.0);\n    \n    // rim\n    vec3 rim = vec3(0.18) * clamp((1.0 - dot(viewDir, normal)), 0.0, 1.0);\n    \n    return ambient + (diffusion * diffusionRatio + specular * specularRatio) * LIGHT0_COLOR * shadow + rim;\n}\n\nvec3 materail3(vec3 lighDir, vec3 normal, vec3 viewDir, float shadow)\n{\n    vec3 ambient = vec3(0.1, 0.46,  0.1);\n    vec3 diffusion = vec3(0.1, 0.1, 0.1);\n    float diffusionRatio = clamp(dot(lighDir, normal), 0.0, 1.0);\n    vec3 specular = vec3(0.1, 0.1, 0.1);\n    float specularRatio = pow(clamp(dot(normalize((viewDir + lighDir) / 2.0), normal), 0.0, 1.0), 2.0);\n    \n    // rim\n    vec3 rim = vec3(0.23) * clamp((1.0 - dot(viewDir, normal)), 0.0, 1.0);\n    \n    return ambient + (diffusion * diffusionRatio + specular * specularRatio) * LIGHT0_COLOR * shadow + rim;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec3 e = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(p + e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p + e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p + e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    for(float t = 0.1; t < 8.0;)\n    {\n        float h = map(ro + t * rd).x;\n        if (h < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, 8.0*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvec3 shade(vec3 pos, float mat, vec3 eyePos)\n{\n    vec3 normal = calcNormal(pos);\n    vec3 viewDir = normalize(eyePos - pos);\n    // vec3 lighDir = normalize(LIGHT0_POS - pos);\n    vec3 lighDir = normalize(LIGHT0_DIR);\n    float shadowRatio = softShadow(pos, lighDir);\n    switch(int(mat))\n    {\n        case 0:\n            return materail0(lighDir, normal, viewDir, shadowRatio);\n        case 1:\n            return materail1(lighDir, normal, viewDir, shadowRatio);\n        case 2:\n            return materail2(lighDir, normal, viewDir, shadowRatio);\n        case 3:\n            return materail3(lighDir, normal, viewDir, shadowRatio);\n        default:\n            return vec3(1.0, 0.0, 1.0);\n            break;\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 backgroundColor = vec3(0.1f, 0.31f, 0.36f);\n    vec3 color = backgroundColor;\n\n    // camera setting\n    vec3 rayOrigin = vec3(0.0, 3.0, 0.0) + 6.0 * vec3(sin(iTime), 0.0, cos(iTime));\n    // vec3 rayOrigin = vec3(0.0, 3.0, 5.0);\n    float fov = 20.0;\n    vec3 rayDirection = getRayDirection(uv, rayOrigin, vec3(0.0, 0.0, 0.0), fov);\n\n\n    vec2 result = rayMarching(rayOrigin, rayDirection);\n\n    if (result.x > 0.0)\n    {\n        color = shade(rayOrigin + rayDirection * result.x, result.y, rayOrigin);\n    }\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n\nvec3 getRayDirection(vec2 uv, vec3 cameraPos, vec3 lookPos, float fov)\n{\n    vec3 z = normalize(lookPos - cameraPos);\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 x = cross(y, z);\n    z = cross(x, y);\n    mat3 cameraMat = mat3(x, y, z);\n\n    return normalize(cameraMat * vec3(uv, 0.5 / tan(fov / 180.0 * PI)));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat sdLeave(in vec3 p, in float r)\n{\n    p.x *= 1.2;\n    p.z *= 1.3;\n    return sdSphere(p, r);\n}\n\nfloat treeBody(in vec3 p, in float l, in float r)\n{\n    // float w = 0.1;\n    // p += 0.5 * vec3(sin(w * p.x), 0.0, sin(wp.z));\n    p.xz *= 0.97 * clamp(p.y, 0.2, 1.5);\n    return sdVerticalCapsule(p, l, r);\n}\n\n\n","name":"Common","description":"","type":"common"}]}