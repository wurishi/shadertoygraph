{"ver":"0.1","info":{"id":"3tdyRl","date":"1610237594","viewed":298,"name":"gear grind","username":"valalalalala","description":"I was going to make a scene with gears, but then.... they were so hypnotic...\n\nAnd... still artifacts...","likes":7,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","gears"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"gear grind\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n/////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////\n// scene specific settings\n\n#define GEAR_REPEAT   5.0\n#define TEXTURE_GEARS 0.9\n\n/////////////////////////////////////////////////////////////////////////////\n// ray marching values\n\n#define RAY_MARCH_STEPS    88\n#define RAY_MARCH_TOO_FAR  float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE    .0001\n#define RAY_EPSILON        vec2( RAY_MARCH_CLOSE, .0 )\n#define RAY_SHORTENING\n#define RAY_RELAX_        0.1\n\n/////////////////////////////////////////////////////////////////////////////\n// anti-aliasing\n\n#define ANTI_ALIAS_STEPS    1\n#define ANTI_ALIAS_DISTANCE 3.\n\n/////////////////////////////////////////////////////////////////////////////\n// reflections\n\n#define REFLECTION_NONE   0.\n#define REFLECTION_SIMPLE 1.\n#define REFLECTION_NICER  2.\n\nfloat REFLECTION_LEVEL_ = REFLECTION_SIMPLE; // toggle with 'r' key\n\n/////////////////////////////////////////////////////////////////////////////\n// camera\n\nconst float CAMERA_SCALE = 6.;\n\n/////////////////////////////////////////////////////////////////////////////\n// useful constants and macros\n\n#define PI2             6.283185307179586\n#define TRIG(d, a)      ( d * vec2( cos( a ), sin( a ) ) )\n#define RGB(r,g,b)      vec3( float(r)/255., float(g)/255., float(b)/255. )\n#define EQUALS(a,b)     step( a, b ) * step( b, a )\n#define VEC3Y(y)        vec3( .0, y, .0 )\n#define VEC3Z(z)        vec3( .0, .0, z )\n#define RAND2(v)        fract( 333433.444469 * sin( dot( v, vec2( 449.457, 359.367 ) ) ) )\n\n#define MODO(v,f) ( mod( v + .5 * f, f ) - .5 * f )\n#define DOT_DIFFERENCE(a,b) dot( a - b, a - b )\n\n/////////////////////////////////////////////////////////////////////////////\n//\n\nmat2 rotate2d( in float angle ) {\n    vec2 t = TRIG( 1., angle );\n    return mat2( t.x, -t.y, t.y, t.x );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// signed distance functions for types\n\n// https://iquilezles.org/articles/distfunctions\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// https://mercury.sexy/hg_sdf/\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y) - height);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// create the scene\n\n#define GEAR  1.\n\nvec2 which( in vec2 current, in vec2 test ) {\n    return mix( current, test, step( test.x, current.x ) );\n}\n\nfloat gearAngleOffset( in vec3 point ) {    \n    vec3 q = point.xzy;\n    \n#ifdef GEAR_REPEAT\n    //q.xz = MODO( q.xz, GEAR_REPEAT );\n    q = MODO( q, GEAR_REPEAT );\n#endif\n\n    vec2 id = point.xy - q.xz;\n    float eo = mod( id.x + id.y + 77., 2. ) * 2. -1.;\n    \n    ///////////////////////////\n        \n    float angle_inc = .0; //offset for each gear\n    angle_inc += floor( mod(id.x+id.y,2.) ) * .2; // alternate \n    angle_inc += eo * iTime; // spin the right way\n    return angle_inc;\n}\n\nmat2 gearAngleMatrix( in vec3 point ) {\n    return rotate2d( -gearAngleOffset( point ) * .4 );\n}\n\nfloat gearDistance( in vec3 point ) {\n    vec3 q = point.xzy;\n    \n#ifdef GEAR_REPEAT\n    q = MODO( q, GEAR_REPEAT );    \n#endif\n    \n    vec2 id = point.xy - q.xz;\n    float eo = mod( id.x + id.y + 77., 2. ) * 2. -1.;\n    \n    vec3 og = q;\n    \n    ///////////////////////////\n    \n    float angle = atan( q.x, q.z );\n    \n    float angle_inc = .0; //offset for each gear\n    angle_inc += floor( mod(id.x+id.y,2.) ) * .2; // alternate \n    angle_inc += eo *iTime; // spin the right way\n    \n    mat2 rot = rotate2d( -angle_inc * .4 ); // sync is off...\n    vec3 xo = og;\n    xo.xz *= rot;  \n    \n    ///////////////////////////\n    \n    // this took a lot of fiddling...\n    float r = 2.5 - .2 * step(.0,sin( 48.* angle + 20. * angle_inc ) );\n    \n    float gear = fCylinder( xo, r, .1 );\n    gear = max( gear, -fCylinder( q, 1.86, .33 ) );\n        \n    ///////////////////////////\n    // the inset cross\n\n    float inset = fCylinder( xo, 2., .1 );\n\n    r = .8;\n    float f = -.77;\n    float o = 1.1;\n    o = 1.18;\n    vec3 nSpot = vec3( -o, f - .4, +o );\n    vec3 nSize = vec3( o * .5 );\n    nSize.xz /= 2.;    \n    \n    float negative_inset = 1e33;\n    negative_inset = min( negative_inset, sdBox( xo + nSpot.xyx, nSize ) );\n    negative_inset = min( negative_inset, sdBox( xo + nSpot.xyz, nSize ) );\n    negative_inset = min( negative_inset, sdBox( xo + nSpot.zyx, nSize ) );\n    negative_inset = min( negative_inset, sdBox( xo + nSpot.zyz, nSize ) );\n    negative_inset -= r;\n    //return min(inset,negative_inset);\n\n    inset = max( inset, -negative_inset );\n    //return inset; // like a squared off flat cross\n\n    gear = min( gear, inset );\n\n    // cross\n    float crozz = 1e33;\n    crozz = min( crozz, sdRhombus( xo.xzy + VEC3Z( .18 ), 2.5, .5,.04,.1 ) -.04 );\n    crozz = min( crozz, sdRhombus( xo.zxy + VEC3Z( .18 ), 2.5, .5,.04,.1 ) -.04 );\n  \n    // topper\n    \n    float topper = 1e33;\n    topper = min( topper, sdRoundedCylinder( xo.xyz, .25,.2, .2 ) );\n    topper = min( topper, sdRoundedCylinder( xo.xyz - VEC3Y( .3 ), .15,.06, .1 ) );\n    //return topper;\n    \n    crozz = min( crozz, topper );\n    crozz = max( crozz, -xo.y );\n    gear = min( gear, crozz );\n\n    return gear;\n}\n\nvec2 sceneDistance( in vec3 point ) {\n    float gear = gearDistance( point );\n    float back = point.z + 11.;\n        \n    vec2 closest = vec2( RAY_MARCH_TOO_FAR );\n    closest = which( closest, vec2( gear, GEAR ));\n#ifdef GEARS_REPEAT\n    closest = which( closest, vec2( back, GEAR ));\n#endif\n    return closest;\n}\n\n//set color per object\nvec3 colorFor( in float which ) {\n    return vec3( .33 );\n}\n\n//set reflection per object\nfloat reflectionFor(  in float which ) {\n    return .6;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// the ray marching bits\n\nvec2 rayMarch( in vec3 origin, in vec3 direction ) {\n    vec2 total = vec2(.0);\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total.x;\n        vec2 current = sceneDistance( point );\n\n#ifdef RAY_SHORTENING\n        if ( total.x > RAY_MARCH_TOO_FAR || abs( current.x ) < RAY_MARCH_CLOSE ) {\n            break;\n        }\n        // Note: Ray advancement occurs after checking for a surface hit.\n        // Ray shortening: Shorter for the first few iterations.\n        total.x += i<22? current.x*.33 : current.x*.88; \n        total.y = current.y;\n#else\n        total.x += current.x;\n        total.y = current.y;\n\n        if ( total.x > RAY_MARCH_TOO_FAR || abs(current.x) < RAY_MARCH_CLOSE ) {\n            break;\n        }     \n#ifdef RAY_RELAX\n        total.x += RAY_RELAX * current.x;\n#endif\n\n#endif\n    }\n    return total;\n}\n\nvec3 sceneNormal( in vec3 point ) {\n    return normalize( sceneDistance( point ).x - vec3(\n        sceneDistance( point - RAY_EPSILON.xyy ).x,\n        sceneDistance( point - RAY_EPSILON.yxy ).x,\n        sceneDistance( point - RAY_EPSILON.yyx ).x\n    ));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// lighting\n\nvec3 textureForPoint( in vec3 point ) {\n    vec2 center = iChannelResolution[1].xy * .5;\n    vec2 uv = point.xy;\n    uv *= gearAngleMatrix( point );\n    uv += center;\n    return texture( iChannel1, uv, .0 ).xyz;\n}\n\nfloat pointLight( vec3 point, vec3 normal, vec4 light ) {  \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n\n#ifdef TEXTURE_GEARS\n    towardLight = mix( towardLight, textureForPoint( point ), TEXTURE_GEARS );\n#endif\n    towardLight = normalize( towardLight );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight ).x;\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .7 + .3 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point, vec3 normal, vec2 d, vec3 eye ) {\n    eye.z-=5.;\n    eye.x-=2.;\n\n    vec4 light    = vec4( eye, 180. );\n    float ambient = 0.07;\n    float gamma   = .33;\n    \n    float lighting = pointLight( point, normal, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n\n    vec3 color = colorFor( d.y );\n    \n    //meh.. color += texture( iChannel1, point.xy, .0 ).xyz;\n\treturn vec3( color * ambient + color * lighting );\n}\n\nvec3 mixInReflection( vec3 point, float which, vec3 normal, vec3 color, vec3 eye ) {\n    float reflectionFactor = reflectionFor( which );\n    float noReflection = step( .0, reflectionFactor );\n\n    vec3 reflectionStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    vec2 reflectAt       = noReflection * rayMarch( reflectionStart, normal );\n    float reflected      = noReflection * ( 1. - step( RAY_MARCH_TOO_FAR, reflectAt.x ) );\n\n    vec3 reflectPoint = reflectionStart + normal * reflectAt.x;\n    vec3 reflectNormal = reflected * sceneNormal( reflectPoint  );\n    //reflectNormal += .25 * texture( iChannel1, point.xy, .0 ).xyz;\n\n#ifdef REFLECTION_LEVEL\n    vec3 reflection;  \n    if ( REFLECTION_NICER == REFLECTION_LEVEL ) { \n        reflection = reflected * colorPoint( reflectPoint, reflectNormal, reflectAt, eye );\n    } else {\n        reflection = reflected * colorFor( reflectAt.y );\n    }\n    color = mix( color, mix( color, reflection, reflectionFactor ), reflected );\n#endif \n    \n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// simple camera\n\nstruct Ray {\n    vec3 eye;\n    vec3 direction;\n};\n\n// from https://github.com/glslify/glsl-look-at\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3( sin( roll ), cos( roll ), .0 );\n\tvec3 zz = normalize( target - origin );\n\tvec3 xx = normalize( cross( zz, up ) );\n\tvec3 yy = normalize( cross( xx, zz ) );\n\treturn mat3( xx, yy, zz );\n}\n\nRay lookAtTheCamera( in vec2 uv, in vec3 eye, in vec3 look, in float roll, in float zoom ) {\n    mat3 camera = makeCamera( eye, look, roll );\n    vec3 direction = normalize( camera * vec3( uv.xy, zoom ) );\n\n    return Ray( eye, direction );\n}\n\nRay mouseCamera( in vec2 uv ) {    \n    vec2 mx = ( iMouse.xy / iResolution.xy ) -.5;\n        \n    vec2 T = TRIG( CAMERA_SCALE, mx.x * PI2 );\n    vec3 eye  = vec3( T.x, mx.y * CAMERA_SCALE + 2. , T.y );\n    vec3 look = vec3( .0 );\n    \n    float roll = .0;\n    float zoom = 1.8;\n    \n    return lookAtTheCamera( uv, eye, look, roll, zoom );\n}\n\nRay demoCamera( in vec2 uv ) {\n    vec2 T = TRIG( CAMERA_SCALE, iTime );\n    vec3 eye  = vec3( T.x, CAMERA_SCALE * .5, T.y );\n    vec3 look = vec3( .0 );\n    \n    float roll = 0.02 * T.x;\n    float zoom = 1. + .25 * abs( sin( iTime * .66 ) );\n    \n    eye = vec3( cos(iTime *.1)*33., T.x * .2, 4. );\n    look = eye;\n    look.z -= 4.;\n    roll = cos( iTime * .07 );\n    zoom = 1.;\n    \n    return lookAtTheCamera( uv, eye, look, roll, zoom );\n}\n\nRay cameraRay( in vec2 uv ) {\n    float down = iMouse.z;\n\n#ifndef GEAR_REPEAT\n    down = 1.;\n    //ray = lookAtTheCamera( uv, vec3(.0,.0,4.), vec3(.0), .0, 1. );\n#endif\n    if  ( down > .0 ) return mouseCamera( uv ); else return demoCamera( uv );\n\n//    return ( down > .0 ) ? mouseCamera( uv ) : demoCamera( uv );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// input\n\n// from https://www.shadertoy.com/view/4dsGRl\n// keycode table: https://css-tricks.com/snippets/javascript/javascript-keycodes/\nbool readKey( in int key, in bool toggle ) {\n    float keyVal = textureLod( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25), 0.0 ).x;\n\treturn ( keyVal>.5 );\n}\n\nbool readKey( in int key ) {\n    return readKey( key, true );\n}\n\nvoid handleInput() {\n#ifdef REFLECTION_LEVEL\n    REFLECTION_LEVEL = mod( REFLECTION_LEVEL + ( readKey( 82 ) ? 1. : 0. ), 1. + REFLECTION_NICER );\n#endif\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/tlccWN\n\n#define FONT_SAMPLER    iChannel2\n#define FONT_STRIDE(n)  ((n)*vec2( .5, .0 ))\n\n#define FONT_STAR 28\n#define FONT_0    48\n#define FONT_DASH 45\n#define FONT_DOT  46\n#define FONT_T    84\n#define FONT_e    101\n#define FONT_s    115\n#define FONT_t    116\n\nfloat characterDistance( vec2 point, int character ) {\n    vec2 charAt = vec2( character % 16, 15 - character / 16 ) / 16. + 1./32.;    \n    float w = textureLod( FONT_SAMPLER, charAt + point / 16., .0 ).w;\n    vec2 box = abs( point / .8 );\n    return max( w, max( box.x, box.y ) );\n}\n\nfloat characterLength( int value ) {\n    return floor( 1. + log2( float( abs( ( value == 0 ) ? 1 : value ) ) ) / log2( 10.) );\n}\n\nfloat numericStringDistance( vec2 point, int value ) {\n    point -= FONT_STRIDE( characterLength( value ) - 1. );\n    float d = 0 == value ? characterDistance( point, FONT_0 ) : 1e33;  \n    for( int v = abs( value ) ; 0 != v ; v /= 10, point += FONT_STRIDE( 1. ) ) {\n        d = min( d, characterDistance( point, FONT_0 + v % 10 ) );\n    }  \n    return min( d, value < 0 ? characterDistance( point, FONT_DASH ) : 1e33 );\n}\n\nfloat numericStringDistance( in vec2 point, in float value, int decimals ) {\n    int vi = int( sign( value ) * floor( abs( value ) ) );\n    float d = numericStringDistance( point, vi );  \n    \n    point -= FONT_STRIDE( characterLength( vi ) );\n    d = min( d, characterDistance( point, FONT_DOT ) );\n\n    point -= FONT_STRIDE(1.);\n    \n    float vf = fract( abs( value ) ) * 10.;\n    int max = int( pow( 10., float( decimals ) ) );\n    for ( int i = 1 ; i <= decimals ; i++, vf *=10. , point -= FONT_STRIDE( 1. ) ) {\n        int n = int( vf ) % 10;\n        d = min( d, characterDistance( point, FONT_0 + n % 10 ) );\n    }\n\n    return d;\n}\n\nfloat distanceToShape( float d, float t ) {\n    return smoothstep( .5 - t, .5 + t, 1.-d );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// main function\n\nvec3 mainly( in vec2 fragCoord ) {\n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    Ray ray = cameraRay( uv );\n    \n    vec2 d = rayMarch( ray.eye, ray.direction );\n    float missed = step( RAY_MARCH_TOO_FAR, d.x );\n    \n    vec3 point = ray.eye + ray.direction * d.x;\n    vec3 normal = sceneNormal( point );\n        \n    vec3 background = mix( vec3(.9,.4,.0), vec3(.0,.4,.9), uv.y * .8 );\n    vec3 color = colorPoint( point, normal, d, ray.eye );\n    \n\n#ifdef REFLECTION_LEVEL\n    if ( REFLECTION_NONE != REFLECTION_LEVEL ) {\n        color = mixInReflection( point, d.y, normal ,color, ray.eye );\n    }\n#endif\n\n#ifndef GEAR_REPEAT\n    float q = 1e33;\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.8))/.1, ray.eye.x, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.7))/.1, ray.eye.y, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.6))/.1, ray.eye.z, 4 ) );\n    \n    q = min( q, numericStringDistance( (uv - vec2(1.3,.4))/.1, ray.direction.x, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.3))/.1, ray.direction.y, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.2))/.1, ray.direction.z, 4 ) );\n    \n    q = min( q, numericStringDistance( (uv - vec2(1.3,-.1))/.1, iMouse.x, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,-.2))/.1, iMouse.y, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,-.3))/.1, iMouse.z, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,-.4))/.1, iMouse.w, 4 ) );\n    \n    if ( missed > .0 ) {\n        color = vec3( distanceToShape( q, .07 ) );\n        missed = .0;\n    }\n#endif\n\n    return mix( color, background, missed );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    handleInput();\n#if ANTI_ALIAS_STEPS == 1\n    fragColor = vec4( mainly( fragCoord ) , 1. );\n#else\n    vec3 color = vec3( .0 );\n    float a = ANTI_ALIAS_DISTANCE / float( ANTI_ALIAS_STEPS );\n    \n    for ( int y = 0 ; y < ANTI_ALIAS_STEPS ; y++ ) {\n        float ya = float( y ) * a;\n        for ( int x = 0 ; x < ANTI_ALIAS_STEPS ; x++ ) {\n            vec2 aa = vec2( float( x ) * a, ya );          \n            color += mainly( fragCoord + aa );\n        }\n    }\n    fragColor = vec4( color / float( ANTI_ALIAS_STEPS * ANTI_ALIAS_STEPS ), 1. );  \n#endif\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"}]}