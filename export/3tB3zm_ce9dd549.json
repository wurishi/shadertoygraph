{"ver":"0.1","info":{"id":"3tB3zm","date":"1558817100","viewed":388,"name":"Wang Dominos","username":"postrediori","description":"Aperiodic Wang tiles with a procedural texture.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","tiling","tile","maze","wang","generation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iSCREEN_TILES (12)\n#define SCREEN_TILES (float(iSCREEN_TILES))\n\n#define AA_BORDER 0.01\n\n#define Circle vec3\n#define Rectangle vec4\n\n// Random functions\n// https://www.shadertoy.com/view/4sKGzV\nfloat RandomH(vec2 coord)\n{\n    float value = texture(iChannel0, coord.xy/iChannelResolution[0].xy).x;\n    return fract(value * 373.7681691);\n}\n\nfloat RandomV(vec2 coord)\n{\n    float value = texture(iChannel0, coord.xy/iChannelResolution[0].xy).x;\n    return fract(value * 789.1798684);\n}\n\n// Get edge flags\nvec4 WangEdges(vec2 xy)\n{\n    float t = iTime*0.002;\n    return vec4(RandomH(xy + vec2(t,t)), // Top\n                RandomV(xy + vec2(t+1.,t)), // Right\n                RandomH(xy + vec2(t,t+1.)), // Bottom\n                RandomV(xy + vec2(t,t))); // Left\n}\n\n// Get tile by edge flags\nvec2 EdgeTile(vec4 e)\n{\n    int tile = (e.x > .5 ? 1 : 0) +\n        (e.y > .5 ? 2 : 0) +\n        (e.z > .5 ? 4 : 0) +\n        (e.w > .5 ? 8 : 0);\n    \n\tconst int EdgesToPos[16] = int[16](\n        \t12, 8, 13, 9,\n            0, 4, 1, 5,\n            15, 11, 14, 10,\n            3, 7, 2, 6\n    \t);\n    tile = EdgesToPos[tile];\n    return vec2(ivec2(tile % 4, tile / 4));\n}\n\n// Simple texture\n// Functions for geometric primitives\n\n// Circle\nfloat InCircle(Circle c, vec2 uv)\n{\n    float radius = c.z;\n    \n    float dist = radius - length(c.xy - uv);\n    \n    return smoothstep(.1, .9, dist / AA_BORDER);\n}\n\nfloat InvertCircle(Circle c, vec2 uv)\n{\n    return 1.0 - InCircle(c, uv);\n}\n\n// Rectangle\nfloat InRectangle(Rectangle r, vec2 uv)\n{\n    vec2 p1 = r.xy, p2 = r.zw;\n    return (\n        \t(p1.x < uv.x && uv.x < p2.x) &&\n        \t(p1.y < uv.y && uv.y < p2.y)\n    \t) ? 1. : 0.;\n}\n\nfloat InvertRectangle(Rectangle r, vec2 uv)\n{\n    return 1.0 - InRectangle(r, uv);\n}\n\n\n// Functions for combining primitives\nfloat AddCircle(Circle c, vec2 uv, float k)\n{\n    return max(InCircle(vec3(c), uv), k);\n}\n\nfloat NotCircle(Circle c, vec2 uv, float k)\n{\n    return min(InvertCircle(c, uv), k);\n}\n\nfloat AddRectangle(Rectangle r, vec2 uv, float k)\n{\n    return max(InRectangle(r, uv), k);\n}\n\nfloat NotRectangle(Rectangle r, vec2 uv, float k)\n{\n    return min(InvertRectangle(r, uv), k);\n}\n\n// Combined texture\nfloat WangTileTexture(vec2 uv)\n{    \n    float flag = 0.;\n    \n    // Vertical bar\n    flag = AddCircle(vec3(.5,.5,.25), uv, flag);\n    flag = AddRectangle(vec4(.25,.5,.75,2.5), uv, flag);\n    flag = AddCircle(vec3(.5,2.5,.25), uv, flag);\n    \n    // Horizontal bar\n    flag = AddCircle(vec3(1.5,3.5,.25), uv, flag);\n    flag = AddRectangle(vec4(1.5,3.25,3.5,3.75), uv, flag);\n    flag = AddCircle(vec3(3.5,3.5,.25), uv, flag);\n    \n    // Big blue part\n    flag = AddRectangle(vec4(1.5,.25,3.5,2.75), uv, flag);\n    flag = AddRectangle(vec4(1.25,.5,1.5,2.5), uv, flag);\n    flag = AddRectangle(vec4(3.5,.5,3.75,2.5), uv, flag);\n    \n    //Corners of blue part\n    flag = AddCircle(vec3(1.5,.5,.25), uv, flag);\n    flag = AddCircle(vec3(3.5,.5,.25), uv, flag);\n    flag = AddCircle(vec3(1.5,2.5,.25), uv, flag);\n    flag = AddCircle(vec3(3.5,2.5,.25), uv, flag);\n    \n    \n    flag = NotCircle(vec3(2.,1.,.25), uv, flag);\n    flag = NotCircle(vec3(3.,1.,.25), uv, flag);\n    flag = NotCircle(vec3(2.,2.,.25), uv, flag);\n    flag = NotCircle(vec3(3.,2.,.25), uv, flag);\n    \n    return flag;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = .5+(fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // UV within a tile\n    vec2 tileuv = fract(uv * SCREEN_TILES);    \n    \n    // Coordinate of the tile\n    vec2 tileIdxf = uv * SCREEN_TILES - tileuv;\n    \n    // Get texture coordinate of a tile\n    vec4 edges = WangEdges(tileIdxf);\n    vec2 tile = EdgeTile(edges);\n    \n    // Pixel color\n    float k = WangTileTexture(tile+tileuv);\n    vec3 col = vec3(\n            smoothstep(1., 0., k),\n            smoothstep(1., 0., k),\n            smoothstep(.33, .67, k)\n    \t);\n\n    // Output to screen\n    //float inViewport = step(abs(uv.x-.5),.5);\n    //col *= vec3(inViewport);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}