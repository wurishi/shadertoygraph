{"ver":"0.1","info":{"id":"43XBWS","date":"1728810240","viewed":100,"name":"spheric of pain","username":"nayk","description":"originals https://www.shadertoy.com/view/wdXBzs#","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define n1Q(p) p *= 2.*ri(round(atan(p.x, p.y) * 4.) / 4.)\n#define ri(a) mat2(cos(a + asin(vec4(0,1,-1,0))))\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvec2 z,v,e=vec2(.05,-.05);float t,tt,spo,g,gg;vec3 np,bp,pp,cp,po,no,al,ld;//global vars. About as boring as being stuck in lockdown with your wife and kids.\nfloat cy(vec3 p,vec3 r){return max(abs(length(p.xz)-r.x)-r.y,abs(p.y)-r.z/2.);} //my own primitive function which I didn't steal from IQ. Not bad for an ageing bitter skateboarder. It makes a hollow tube\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//rotate function. Short and sweet, just like Napoleon before his megalomaniac fit.\nvec2 fb( vec3 p,float s,float m) // fb \"fucking bit\" function make a base geometry which we use to make gyro and flying objects\n{\np.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),  cos(iTime));\n\n\n  for(int i=0;i<10;i++){\n\n    p=abs(p);//People against unemployment benefit are heartless like people annoyed at my humourous comments are boring\n    p.xy*=r2(.48);//clone along xy axis with rotation\n  \n    p.yz*=r2(s*sin(p.z*.5)*.3);//this tweaks the gyro into much different shape for flying objects\n  }\n  vec2 h,t=vec2(cy(p,vec3(2,.3,.4)),m);//Make thin hollow tube either yellow or blue \n  h=vec2(cy(p,vec3(2,.1,.6)),6); //Make white hollow tube\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  h=vec2(cy(p,vec3(2.,.4,.2)),3); //Make black hollow tube\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  return t;\n}\n\nvec2 mp( vec3 p )\n{ \n  bp=np=cp=pp=p;\n  n1Q(p.xy);//GYROBULLSHIT starts here\n  p.z+=3.5;\n  bp.xy*=r2(tt); //We make two positions bp and np, one rotate clockwise the other anti-clockwise\n  np.xy*=r2(-tt);\n  n1Q(bp.xy);\n  n1Q(np.xy);\n //None of those positions are either right or wrong in terms of movements direction, get out of your hemisphere-centric bubble, Steve.\n  vec2 h,t=fb(bp*.6,0.,5.); //Make first gyro bit and spin the fucker\n  t.x/=0.6; //Since we scale the pos we must tweak domain into shape to avoid artifact\n  n1Q(h.xy);\n  //remove middle bit of outter gyro\n  h=fb(np,1.,5.); //Make another fucking gyro and make it spin\n  t=t.x<h.x?t:h;  //Mege both spinning gyros, bit like \"Mr Speaker\" trying to order the parliament with both parties spinning out of control around their own lame centre of political gravity\n  h=fb(bp*1.7,0.,5.);h.x/=1.7;t=t.x<h.x?t:h; //Yeah yeah one more gyro, blah blah blah, something about distance fucking fields, man I'm so borded when is football restarting, being a geek is cool, but hooliganism is more rewarding.\n  h=vec2(length(p)-.2);//Dumb fucking sphere in middle, make it glow, call the Tate Modern, tell them about my struggle as a child in our anonymous post-post-modern society and give me the Turner Prize.\n   pp.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),  cos(iTime));\n   pp.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),  cos(iTime));\n   pp.yz*=mat2(cos(iTime),sin(iTime),-sin(iTime),  cos(iTime));\n //Objects flying around, there is actually a sick position trick in there\n  pp.xy=abs(pp.xy);//Rotate first, then abs symetry on xy axis\n; //push position along circle\n ;//Rotate the fucking whole thing back and forth\n  h=fb(pp*3.5,3.,7.);//And that's how we get satisfying pandular action. Please note \"satisfying pandular action\" is also what wives want.\n  h.x*=0.15;  t=t.x<h.x?t:h;//since we scaled position, tweak back domain\n  h=vec2(length(pp)-.2);//Blue glow sphere inside flying objects\n ; //Make it glow and collect some Italia'90 football cards for your meak effort\n\n\n  return t; //I'm done commenting this and can go back to pointing menacingly at the neighbour's dog\n}\nvec2 tr( vec3 ro, vec3 rd,float _max,int iter) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1);\n   //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<iter;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.00001||t.x>_max) break;//Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>_max) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\n\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=iTime;//Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  v=mix(vec2(3.,8.8),vec2(12.,16.),ceil(cos(tt*.4)));//Reuse the v variable as holder of camera variables\n  vec3 ro=vec3(0.,0.,1.),\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)), //camera forward, left and up vector.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.5,-.1)); //ld=light direction\n  co=fo=vec3(.09)-length(uv*.2)*.107;//background is dark with vignette\n  z=tr(ro,rd,50.,128);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying to throw a spear at a pig. We wouldnt have survive the ice age with you and your nerdy mates.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n\n    al=vec3(1.,.5,2);//albedo is base colour by default it's yellow \n    if(z.y<5.) spo=40.,al=vec3(0); //material system if less than 5 make it black, with specular power 40 and no reflections\n    if(z.y>5.) spo=40.,al=vec3(1); //material system if more than 5 make it white, with specular power 40 and no reflections\n    if(z.y>6.) al=mix(vec3(.1,.2,.4),vec3(.1,.35,.6),sin(cp*.5)*.5+.5); //Material Id more than 6 makes it blue / green gradient\n   //Material ID more than 7 makes it yellow and we re adapt the specular power and refraction index\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);//Sp=specular, stolen from shane\n    co=mix(sp+mix(vec3(.8,0.1,2.),vec3(1.,0.,10.),abs(rd))*al*(a(.1)*a(.2)+.2)*(dif+s(13.)),fo,min(fr,5.2));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    if(z.y>7.||z.y==5.){ //If material id is 5 or more than 7 then we do reflections\n      rd=refract(rd,-no,1.-(spo*.0005));//reflect rd with refraction\n      z=tr(po+rd*0.01,rd,50.,80); //Throw another ray from surface, shift ray start position a bit and shoot\n      if(z.y>0.){ //If we hit something in reflection ray... (optimization and cleanup this)\n        po=po+rd*z.x; //Get where we at\n        no=no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);//More broing normals calculations\n        al=vec3(0.,.5,0);//Gotta give it the material id thing so we know how to colour what\n        if(z.y<5.) al=vec3(0);//ya ya give it back the colours\n        if(z.y>5.) al=vec3(1);//Still pretty boring shit\n       \n        float dif=max(0.,dot(no,ld));\n        co=co+(dif*al*fr);\n      }\n    }\n    co=mix(fo,co,exp(-.0001*t*t*t)); //Fog soften things, but it won't stop your mother from being unimpressed by your current girlfriend\n  } \n  fragColor = vec4(pow(co+g*.2+gg*.3*vec3(.5,.1,.7),vec3(.45,.1,1.)),1);\n   uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.55), 1.0);\n}","name":"Image","description":"","type":"image"}]}