{"ver":"0.1","info":{"id":"XtBXRc","date":"1445309563","viewed":262,"name":"[CIS565 2015F] GLSL-Ray-Marcher","username":"zhuxinyue","description":"https://github.com/CIS565-Fall-2015/Project5-GLSL-Ray-Marcher\nThis Shadertoy uses material from the following resources:\niq Cloudy Terrain: https://www.shadertoy.com/view/MdlGW7\niq RayMarching Primitives: https://www.shadertoy.com/view/Xds3zN\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define EPSILON 0.00001\n#define MinStep 0.01\n#define MaxDis 120.0\n#define R 0.25\n#define cpt vec3(0.0,R,0.0)\n#define disi 1.2\n\n//#define debugView1\n//#define debugView2\n//#define naive\n//#define terrMap\nfloat iterate_num=0.0;\nfloat terrain_y=0.0;\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdWheel( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n//----------------------------------------------------------------------\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n   return (d1.x< -d2.x)?-d2:d1;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nvec3 opTrans( vec3 p, vec3 s,vec3 r,vec3 t )//m:tranformation matrxi,s scale parameter\n{\n    \n     mat4 S_inv = mat4(vec4(1.0/s.x,0,0,0),\n                       vec4(0,1.0/s.y,0,0),\n                       vec4(0,0,1.0/s.z,0),\n                       vec4(0,0,0,1));\n    \n     mat4 T_inv = mat4(vec4(1,0,0,0),\n                       vec4(0,1,0,0),\n                       vec4(0,0,1,0),\n                       vec4(vec3(-t),1));\n    float sx = sin(r.x);\n    float sy = sin(r.y);\n    float sz = sin(r.z);\n    \n    float cx = cos(r.x);\n    float cy = cos(r.y);\n    float cz = cos(r.z);\n  \n   \n    mat4 Rmatrix = mat4(\tcy*cz,\tcx*sz+cz*sx*sy,\tsx*sz-cx*cz*sy,\t0,\n                      \t   -cy*sz,\tcx*cz-sx*sy*sz,\tcz*sx+cx*sy*sz,\t0,\n                        \tsy,\t\t-cy*sx,\t\t\tcx*cy,\t\t\t0,\n                        \t0,\t\t0,\t\t\t\t0,\t\t\t\t1);\n    mat4 R_inv = mat4(\tcy*cz,\t        -cy*sz,\t         sy,    0,\n                     \tcx*sz+cz*sx*sy,\tcx*cz-sx*sy*sz, -cy*sx, 0,\n                     \tsx*sz-cx*cz*sy, cz*sx+cx*sy*sz,  cx*cy, 0,\t\n                     \t0,0,0,1);\n\n    \n    mat4 invertMatrix = S_inv*R_inv*T_inv;\n    \n    vec4 p_transformed = invertMatrix*vec4(p,1.0);\n   \n    return p_transformed.xyz;\n\n}\n//----------------------------------------------------------------------\n\n\nfloat Textyrek( vec3 point )\n{\n    \n\tfloat k = 1.0-smoothstep( 0.42, 0.95, texture( iChannel0, 0.04*point.xz,-70.0).x);\n\treturn  k*texture( iChannel1, 0.02*point.zx ).x;\n\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y - Textyrek(pos);\n}\n\nvec2 setGeo( in vec3 point )\n{\n    //plane,box,rounded box,shpere,wheel,cylinder\n    //sphere:0,0,0,R=0.25\n    \n    vec2 res = opU(vec2( sdPlane(point), 1.0 ), vec2( sdSphere(point-cpt, R ), 50.0 ) );\n#ifdef terrMap\n    float tt=0.5;\n    \n    res = opU(vec2( mapTerrain(point), 1.0 ), vec2( sdSphere(point-cpt-0.5, R ), 50.0 ) );\n#else \n    float tt=0.0;\n    res = opU(res, vec2(  sdBox  (point-vec3(cpt.x+disi,cpt.y, cpt.z)-tt, vec3(R) ),21.0 ) );\n #endif \n    res = opU( res, vec2( udRoundBox(point-vec3( cpt.x-disi,cpt.y, cpt.z)-tt, vec3(R-0.1), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus   (point-vec3( cpt.x-2.0*disi,cpt.y,cpt.z)-tt, vec2(R,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdWheel   (point-vec3( cpt.x+2.0*disi,cpt.y,cpt.z)-tt, vec2(R,0.05) ), 35.0 ) );    \n#ifdef terrMap\n#else \n    res = opU( res, vec2( sdBox   (point-vec3(cpt.x+disi, cpt.y, cpt.z+disi)-tt, vec3(R/3.0) ),60.0 ));\n    res = opU( res, vec2( sdCone  (point-vec3(cpt.x+disi, cpt.y+0.1, cpt.z-disi)-tt, vec3(R) ),31.0 ) );\n\n    //operation:subtraction,repeat, transform\n    res = opS( res, vec2( sdSphere (point-vec3(cpt.x+disi,cpt.y, cpt.z)-tt,R+0.05 ), 0.0 ));\n    //repeatl;\n    vec3 p1 = opRep(point-vec3(cpt.x+disi, cpt.y, cpt.z+disi), vec3(2.0) );\n    res = opU(res,vec2( sdBox (p1, vec3(R/3.0) ),10.0 ) );\n   //transform\n    vec3 sm=vec3(12.5,1.5,1.0);\n    vec3 rm=vec3(45.0,0.0,0.0);\n    vec3 tm=vec3(0.0,0.0,0.8);\n    vec3 p2 = opTrans(point-vec3(cpt.x, cpt.y, cpt.z+disi)-tt,sm,rm,tm);\n    res = opU(res, vec2( sdCylinder (p2, vec2(R/2.0,R/2.0) ), 15.0 ) );\n\n#endif\n    return res;\n}\n\n\nvec2 acc_rayMarching(vec3 dir, vec3 ori)\n{\n    \n    vec3 point;\n    vec2 h;\n    float t=1.0;\n    float m=0.0;\n    for(float s=0.0;s<MaxDis;s+=MinStep)\n\t{\n        point = ori+t*dir;\n       //***********************//\n        h= setGeo(point);\n        //*************************//\n        if(h.x<EPSILON)\n        {  \n          break;\n        }\n        if(t>MaxDis)break;\n        t+= max(h.x,MinStep);\n        iterate_num++;\n        m =h.y;\n\t}\n     return vec2( t, m );\n}\nvec2 naive_rayMarching(vec3 dir, vec3 ori)\n{\n    vec3 point;\n    vec2 dis;\n    float m=0.0;\n    float t_temp=0.0;\n    for(float t=.0;t<MaxDis;t+=MinStep)\n    {\n          point=ori+dir*t;\n          dis= setGeo(point);//length(point-centerPoint)-R;\n         \n       if(dis.x<.0){break;}\n        m=dis.y;\n        t_temp=t;\n        iterate_num++;\n    }\n    return vec2(t_temp,m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt,in float k )\n{\n\n    float t = mint;\n\tfloat res = 1.0;\n    for ( float i = 0.0; i < MaxDis; i++ )\n    {\n        float h = setGeo( ro + rd * t ).x;\n        if ( h < EPSILON ){return 0.0;break;}\t\n\t\tres = min( res, k * h / t );\n        t += h;\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\nvec3 calTerrNor()\n{\nreturn vec3(1.0,1.0,1.0);\n}\nvec3 diffNormal( in vec3 point )\n{\n\tvec3 eps = vec3( EPSILON, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    setGeo(point+eps.xyy).x - setGeo(point-eps.xyy).x,\n\t    setGeo(point+eps.yxy).x - setGeo(point-eps.yxy).x,\n\t    setGeo(point+eps.yyx).x - setGeo(point-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    float d=0.0;\n    for( int i=0; i<6; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * h + pos;\n        d = setGeo(aopos).x;\n        occ += -(d-h)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    //two method of ray marching:\n#ifdef naive\n    vec2 res = naive_rayMarching(rd,ro);\n#else\n    vec2 res = acc_rayMarching(rd,ro);\n#endif\n    \n#ifdef debugView1\n    //res = acc_rayMarching(rd,ro);\n\tfloat tv = res.x/25.0;\n    col = vec3(tv);\n\treturn vec3( clamp(col,0.0,1.0));\n#else\n#endif\n    \n#ifdef debugView2\n   // res = acc_rayMarching(rd,ro);\n    //res = naive_rayMarching(rd,ro);\n    col=vec3(float(iterate_num/(2.0*MaxDis)));\n    return vec3( clamp(col,0.0,1.0));\n#else\n#endif\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n      \n        vec3 point = ro + t*rd;\n        vec3 normal = diffNormal( point );\n        vec3 ref = reflect( rd, normal );\n        vec3 lightpos=vec3(0.8, 0.6, -0.5);\n        vec3 lightdir=lightpos-point;        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.20)*(m-1.0) );\n\n        if( m<2.0 )//m=1.0(plane)\n        {\n            \n            float f = mod( floor(5.0*point.z) + floor(5.0*point.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n        // material  \n        float occ = calAO( point, normal );\n       //float occ=1.0;\n\t\tfloat amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n        float dif = clamp( dot( normal, lightdir ), 0.0, 1.0 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        \n        float light_len=length(lightdir);\n        vec3 H=normalize(lightdir+normalize(ro-point));\n        float hdot=dot(H,normal);\n        float spec = float(max(pow(hdot,10.0),0.0));\n        float fre = pow( clamp(1.0+dot(normal,rd),0.0,1.0), 2.0 );\n        float attn = 1.0 - pow( min( 1.0, length(lightdir) / 10.0 ), 2.0 );\n        dif *= softshadow( point, lightpos, 0.02, 2.5,8.0 );\n        dom *= softshadow( point, ref, 0.02, 2.5,8.0 );\n        \n\t\tfloat phong_color =0.0;\n        phong_color= 1.5*dif+1.3*spec+0.1*amb*occ;\n        phong_color += 0.40*dom*occ;\n        phong_color += 0.40*fre*occ;\n\t\tcol = col*phong_color*attn;\n#ifdef terrMap\n        if(m<1.5){\n            float f = mod( floor(5.0*point.z) + floor(5.0*point.x), 2.0);\n            vec3 basec=vec3(0.75,0.75,0.75);\n            col = basec;\n            col*=1.0*dif+0.2*amb*occ;\n            col.xyz = mix( col.xyz, basec, 0.2);\n            col*=0.9;\n            // col*=vec3(0.2,0.8,0.7);\n            \n        }\n        //the terrin map\n#else\n#endif\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}