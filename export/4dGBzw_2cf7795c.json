{"ver":"0.1","info":{"id":"4dGBzw","date":"1572985686","viewed":108,"name":"agnes","username":"hclarke","description":"it's a flame\n\nbezier modified from here: https://www.shadertoy.com/view/ltXSDB","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//color\nconst mat3 YUV_to_RGB = mat3(\n         1.0,1.0,1.0,\n        0.0,-0.39465,2.03211,\n        1.13983,-0.58060,0.0);\n\nconst mat3 XYZ_to_RGB = mat3(\n    3.2406, -0.9689, 0.0557,\n    -1.5372, 1.8758, -0.2040,\n    -0.4986, 0.0415, 1.0570);\n\nconst vec3 D65_XYZ = vec3(.95047, 1.0, 1.08883);\nconst vec3 D65_xyY = vec3(0.31271, 0.32902, 1.0);\nconst vec3 D65_Yuv = vec3(1.0, 0.19784, 0.46834);\nconst vec3 ONE = vec3(1.0,1.0,1.0);\n\nvec3 XYZ_to_xyY(vec3 XYZ) {\n \tfloat inv_sum = 1.0/dot(XYZ,ONE);\n    return XYZ.xyy * vec3(inv_sum,inv_sum,1.0);\n}\n\nvec3 xyY_to_XYZ(vec3 xyY) {\n \tfloat s = xyY.z/xyY.y;\n    float z = 1.0-dot(vec2(1.0,1.0), xyY.xy);\n    return vec3(xyY.x, xyY.z, z) * vec3(s,1.0,s);\n}\n\nvec3 LUV_to_XYZ(vec3 LUV) {\n    vec2 uv = LUV.yz / (13.0*LUV.x) + D65_Yuv.yz;\n    float Y = LUV.x > 8.0 ? \n        D65_Yuv.x * pow((LUV.x+16.0)/116.0, 3.0) : \n    \tLUV.x * D65_Yuv.x * 0.00110705645;\n    float X = Y * 9.0 * uv.x / (4.0*uv.y);\n    float Z = Y * (12.0-3.0*uv.x-20.0*uv.y)/(4.0*uv.y);\n    return vec3(X,Y,Z);\n}\nvec3 LUV_to_RGB(vec3 LUV) {\n \treturn XYZ_to_RGB * LUV_to_XYZ(LUV);   \n}\nvec3 HCL_to_LUV(vec3 HCL) {\n \tvec2 uv = vec2(cos(HCL.x), sin(HCL.x)) * HCL.y;\n    return vec3(HCL.z, uv);\n}\n\n//other stuff\nvec2 lmin(vec2 a, vec2 b) {\n    if(abs(a.x-b.x) < 0.0000000001) {\n      return a.y > b.y ? a : b;\n    }\n    \n    return a.x < b.x ? a : b;\n}\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the distance to the curve, and signed distance to unclamped curve\nvec2 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = solveCubic(k.x, k.y, k.z);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    float unclamped = dis * signBezier(A, B, C, p);\n    \n    t = clamp(t, 0.0, 1.0);\n    pos = A + (c + b*t.x)*t.x;\n    dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    \n    return vec2(dis, unclamped);\n}\n\nvec3 sdFlame(vec2 pos) {\n    \n    if(dot(pos,pos) > 4.0) return vec3(length(pos)-2.0, 0.0, 0.0);\n    \n    float yd = clamp((pos.y + 1.0)* 0.5,0.0, 1.0);\n    \n    pos.x += sin((iTime+yd*0.1)*30.0) * yd * 0.06;\n    pos.x += sin((iTime+yd*0.3)*23.12) * yd * 0.01;\n    pos.y += sin((iTime+yd*0.1 + 1.0)*30.0) * yd * 0.03;\n    pos.x = -abs(pos.x);\n    float w = 0.3;\n    float b = -0.7;\n    float m = -0.3;\n    float t = 1.0;\n    vec2 p0 = vec2(0.0, -1.0);\n    vec2 p1 = vec2(-w, m);\n    vec2 p2 = vec2(-0.2, 0.5);\n    vec2 p3 = vec2(0.0, t);\n    vec2 c0 = vec2(-w, b);\n    vec2 c1 = vec2(-w, -0.2);\n    vec2 c2 = p2 + (p2-c1) * 0.5;\n    vec2 sd = vec2(1000.0, 0.0);\n    sd = lmin(sd, sdBezier(p0, c0, p1, pos));\n    sd = lmin(sd, sdBezier(p1, c1, p2, pos));\n    sd = lmin(sd, sdBezier(p2, c2, p3, pos));\n    \n    float d = sd.x * -sign(sd.y);\n    float id = 1.0;\n    float grad = sd.x*5.0 + (1.-yd) * 4.0;\n    return vec3(d, id, grad);\n}\n\nvec3 sdMidPetal(vec2 pos) {\n    \n    if(dot(pos,pos) > 16.0) return vec3(length(pos)-4.0, 0.0, 0.0);\n    pos.x = abs(pos.x);\n    float w = 0.5;\n    float m = -0.6;\n\tvec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(w, m);\n    vec2 p2 = vec2(0.05, m*2.0);\n    vec2 c0 = vec2(w+0.3, -0.2);\n    vec2 c1 = vec2(0.05, m-0.3);\n    \n    vec2 sd = vec2(1000.0, 0.0);\n    sd = lmin(sd, sdBezier(p0, c0, p1, pos));\n    sd = lmin(sd, sdBezier(p1, c1, p2, pos));\n    \n    float d = sd.x * -sign(sd.y);\n    float id = 2.0;\n    float grad = sqrt(sd.x / w * 1.0);\n    return vec3(d, id, grad);\n}\n\nvec3 sdSidePetal(vec2 pos) {\n    if(dot(pos,pos) > 4.0) return vec3(length(pos)-2.0, 0.0, 0.0);\n    pos.x = abs(pos.x);\n    float w = 0.8;\n    float m = -0.65;\n    float t = 0.1;\n\tvec2 p0 = vec2(0.1, m);\n    vec2 p1 = vec2(w, t);\n    vec2 p2 = vec2(w*1.5, t-0.4);\n    vec2 p3 = vec2(w, m-0.2);\n    vec2 p4 = vec2(0.01, m-0.6);\n    vec2 c0 = vec2(w-0.1, t-0.1);\n    vec2 c1 = vec2(w*1.5, t);\n    vec2 c2 = vec2(w*1.5-0.1, m-0.1);\n    vec2 c3 = vec2(0.1, m-0.2);\n    \n    vec2 sd = vec2(1000.0, 0.0);\n    sd = lmin(sd, sdBezier(p0, c0, p1, pos));\n    sd = lmin(sd, sdBezier(p1, c1, p2, pos));\n    sd = lmin(sd, sdBezier(p2, c2, p3, pos));\n    sd = lmin(sd, sdBezier(p3, c3, p4, pos));\n    \n    float d = sd.x * -sign(sd.y);\n    float id = 2.0;\n    float grad = sqrt(sd.x / w * 2.0);\n    return vec3(d, id, grad);\n}\n\nvec3 scene_min(vec3 a, vec3 b) {\n \treturn a.x < b.x ? a : b;   \n}\n\nvec3 scene_overlay(vec3 a, vec3 b) {\n \treturn b.x < 0.0 ? b : a;   \n}\n\nvec3 sdFlower(vec2 pos) {\n    float h = (pos.y + 4.0) / 5.0;\n    pos.x += sin(iTime*4.0) * 0.04 * h;\n\tvec3 sd = sdFlame(pos);\n    vec2 offset = vec2(0., -0.7);\n    sd = scene_overlay(sd, sdSidePetal(pos-offset));\n    sd = scene_overlay(sd, sdMidPetal(pos-offset));\n    return sd;\n}\n\n\n\nvec3[2] blues = vec3[2](\n  vec3(34.95159658785063, -10.59331738558413, -132.52535570823173),\n  vec3(20.661436824954606, -6.625557844192029, -69.5615969239433)  \n);\n\nvec3[2] golds = vec3[2](\n  vec3(83.81308085207128, 36.40725312134432, 87.9260601163343),\n  vec3(97.9969146434447, 3.902148804569638, 38.55489135455387)\n\n);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv *= 2.0;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 sd = sdFlower(uv * 2.0);\n\t\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if(sd.x >= 0.0) {\n        col = LUV_to_RGB(mix(blues[0], blues[1], min(1., length(uv * 0.1))));\n    }\n    else if(sd.y == 1.0) {\n        vec3 a = HCL_to_LUV(vec3(1.269591657661457,66.76847476254702,91.24781583307198));\n        \n        vec3 b = HCL_to_LUV(vec3(1.21570998919011,32.3252321015046,94.58142126830768));\n        col = LUV_to_RGB(mix(a,b, max(0.,sd.z)));\n    }\n    else if(sd.y == 2.0) {\n     \t\n        col = LUV_to_RGB(mix(golds[0], golds[1], clamp(sd.z, 0.0, 1.0)));  \n    }\n    \n    \n\n\tfragColor = vec4( col, 1.0 );;\n}","name":"Image","description":"","type":"image"}]}