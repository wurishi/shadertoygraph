{"ver":"0.1","info":{"id":"Nl33zl","date":"1636511261","viewed":70,"name":"lighting practice(schzna)","username":"schzna","description":"schzna is my name.\nThe title \"lighting practice\" is already used by another user.\nThat is why title conatins my name.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265358979;\n\nfloat atan2(in float y, in float x){\n    return x == 0.0 ? sign(y)*PI/2.0 : atan(y, x);\n}\n\n//solve k such that |k*rd - (p-ro)| = radius, and the normal vector\n//this leads a quadratic equation, k*k*|rd|^2 - 2*k*dot(p-ro,rd) + |p-ro|^2 - radius^2 = 0\nvec4 sphere(vec3 ro, vec3 rd, vec3 p, float radius){\n    float c = dot(p-ro, p-ro) - radius*radius;\n    float b = dot(p-ro, rd);\n    float a = dot(rd, rd);\n    float D = b*b - a*c; //Discriminant\n    float k = (b-sqrt(abs(D)))/a * step(0.0, D);\n    return vec4(normalize(rd*k-(p-ro)), k);\n}\n\n//length of n is required to be equal to 1\nfloat light(vec3 ro, vec3 p, vec3 l, vec3 n){\n    float c = dot(l - p, n)/length(l-p);\n    float dif = c*step(0.0, c-0.1);\n    float amb = step(0.9, length(p)) * 0.1 * (1.0 - c);\n    float spe = step(0.0, c)*smoothstep(0.02, 0.0, length(cross(l-p, ro-p))/length(l-p)/length(ro-p));\n    return (dif + amb + spe)*0.8;\n}\n\n//length of n is required to be equal to 1\nfloat sunlight(vec2 p, vec3 n){\n    vec3 l = vec3(cos(p.y)*sin(p.x), sin(p.y), cos(p.y)*cos(p.x));\n    float f = dot(l, n)/length(l);\n    return step(0.0, f)*f;\n}\n\nvec3 skyback(vec3 rd){\n    float l = length(rd);\n    float v = rd.y/l;\n    float ef = smoothstep(0.0, 1.0, abs(v*3.1));\n    return ef*vec3(0.0, 0.1, 0.2) + (1.0-ef)*vec3(0.4, 0.7, 0.9);\n}\n\nvec3 sunback(vec3 rd, vec2 pos, float radius){\n    float l = length(rd);\n    float u = atan2(rd.x, rd.z);\n    float v = asin(rd.y)/l;\n    float d = length(vec2(u,v)-pos);\n    float dy = abs((vec2(u,v)-pos).y)+0.001*abs((vec2(u,v)-pos).x)+0.05;\n    return smoothstep(radius, radius*0.9, d)*vec3(1.0, 1.0, 1.0)+0.8*radius/d*vec3(1.0, 0.7, 0.1)+0.8*radius/dy*vec3(1.0, 0.7, 0.1);\n}\n\nvec3 sky(vec3 rd, vec3 n){\n    vec3 r = reflect(rd, n);\n    return skyback(r);\n}\n\nvec3 sun(vec3 rd, vec3 n, vec2 pos, float radius){\n    vec3 r = reflect(rd, n);\n    return sunback(r, pos, radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime * 2.0;\n    \n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 dir = normalize(vec3(cos(t), 0.0, 0.9));\n    vec3 scx = vec3(dir.z, 0.0, -dir.x);\n    vec3 scy = cross(dir, scx);\n    vec3 rd = normalize(dir*1.0+uv.x*scx+uv.y*scy);\n    \n    vec3 p = vec3(15.0*cos(t), cos(t), 5.0*sin(t) + 5.0);\n    \n    vec3 l = vec3(0.0, 2.0, -5.0);\n    \n    vec2 p_sun = vec2(0.0, 0.0);\n    float r_sun = 0.03;\n    \n    vec4 nk = sphere(ro, rd, p, 0.6);\n    float ef = smoothstep(0.0, 1.0,nk.w);\n    //float d = step(0.0,nk.w)*0.1+0.1*light(ro, nk.w*rd, l, nk.xyz)+0.7*sunlight(p_sun, nk.xyz);\n    \n    vec3 col = (1.0-ef)*(sunback(rd, p_sun, r_sun)+skyback(rd))+ef*(\n        (sunlight(p_sun, nk.xyz)+0.3*light(ro, nk.w*rd, l, nk.xyz)+0.03)*(0.3*sun(rd, nk.xyz, p_sun, r_sun)+0.1*sky(rd, nk.xyz)+0.7*vec3(1.0, 1.0, 1.0))\n    );\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}