{"ver":"0.1","info":{"id":"l32cD3","date":"1727830957","viewed":26,"name":"DeepDarkDweller","username":"Creatorbyte","description":"I thought it would be fun to recreate my personal logo with some shader techniques I've been playing with lately. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fbm","colorful","rainbow","noisy"],"hasliked":0,"parentid":"MXjcD3","parentname":"noisy rainbow warp"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n*\n* NOTE: THIS SHADER IS A REPRODUCTION OF MY PERSONAL LOGO AS AS SUCH IT BELONGS TO ME (CREATORBYTE/DEEPDARKDWELLER) \n* AND MAY NOT BE USED WITHOUT BEING MODIFIED SO AS TO BE VISUALLY DISTINCT. \n*\n* HOWEVER, I DON'T PRETEND TO CLAIM OWNERSHIP OF THE ACTUAL SHADER CODE SINCE, FOR THE MOST PART, ITS JUST MATH AND NOBODY OWNS MATH.\n* MOST OF THE FUNCTIONS USED IN THIS SHADER WERE THINGS I LEARNED FROM TALENTED SHADERTOY USERS SUCH AS IQ, XOR, AND MANY OTHERS.\n* \n* IN SUMMARY, FEEL FREE TO LEARN FROM THIS CODE BUT THE LOGO IS MINE.\n*/\n\n\nconst float PI = 3.14159265359;\n\nvec3 palette(float t) {\n    vec3 b = vec3(0.45); //brightness \n    vec3 c = vec3(0.35); //contrast\n    return b + c * cos(6.28318 * (t * vec3(1.0) + vec3(0.7, 0.39, 0.2)));\n}\n\nvec3 palette2(float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.283185*(c*t+d) );\n}\n\nvec3 palette_eye(float t){\n    return palette2(t,\n        vec3(0.5, 0.5, 0.5),\n        vec3(0.6, 0.5, 0.2),\n        vec3(1.0, 1.0, 1.0),\n        vec3(-0.022, 0.738, 0.428)//vec3(-0.252, 0.018, 0.378) //vec3(0.000, 0.333, 0.667)//vec3(0.828, 1.458, 0.158)//\n    );\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat value_noise(vec2 p) {\n    vec2 cell = floor(p);\n    vec2 sub = p - cell;\n    vec2 cube = sub * sub * (3.0 - 2.0 * sub);\n    const vec2 off = vec2(0, 1);\n    return mix(\n        mix(hash12(cell + off.xx), hash12(cell + off.yx), cube.x),\n        mix(hash12(cell + off.xy), hash12(cell + off.yy), cube.x),\n        cube.y\n    );\n}\n\nfloat fbm(vec2 p, int octaves) {\n    float total = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float max_value = 0.0;\n    int fbm_octaves = octaves;\n    float fbm_persistence = 0.5;\n\n    for (int i = 0; i < fbm_octaves; i++) {\n        total += value_noise(p * frequency) * amplitude;\n        max_value += amplitude;\n        amplitude *= fbm_persistence;\n        frequency *= 2.0;\n    }\n\n    return total / max_value;\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opDifference(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0/(1.0-sqrt(0.5));\n    float x = (b-a)/k;\n    float g = (x> 1.0) ? x :\n              (x<-1.0) ? 0.0 :\n              1.0+0.5*(x-sqrt(2.0-x*x));\n    return b - k * g;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {  \n    /* Calculate UVs and Scale Clip Space */\n    float aspectRatio = iResolution.x/iResolution.y;// Calculate the aspect ratio (g_Screen.x/g_Screen.y)\n\tvec2 normalized_uv = fragCoord/iResolution.xy; // Calculate UVs\n\tnormalized_uv = normalized_uv - 0.5; // Adjust clip space to put (0,0) at center of screen\n\tnormalized_uv = normalized_uv * 2.0; // Scale clip space\n\tnormalized_uv.x *= aspectRatio; // Adjust for aspect ratio\n\t//uv.y *= -1.0; // Flip Y coordinates if using GODOT engine\n    \n    vec2 center = vec2(0, 0); // Centered at normalized UVs\n    vec2 noise_uv = normalized_uv;\n    vec2 noise_uv2 = normalized_uv;\n    \n    /* Compute \"Rainbow Warp Noise\" */\n    noise_uv.x += sin(noise_uv.y * 1.54 * PI + iTime) * cos(noise_uv.y * 1.31 * PI + iTime) * 0.1;\n    noise_uv.y += cos(noise_uv.x * 1.74 * PI + iTime) * -sin(noise_uv.y * 1.64 * PI + iTime) * 0.1;\n    \n    /* Compute less wiggly distortion */\n    noise_uv2.x += sin(noise_uv.y * 1.54 * PI + iTime) * cos(noise_uv.y * 1.31 * PI + iTime) * 0.01;\n    noise_uv2.y += cos(noise_uv.x * 1.74 * PI + iTime) * -sin(noise_uv.y * 1.64 * PI + iTime) * 0.01;\n\n    float noise_scale = 7.392; // 11.392\n    float value_noise_freq = 1.456;\n    float palette_mod_scale = 1.469;\n\n    float noise = fbm(noise_uv * noise_scale + iTime, 2);\n    float distance = length(noise_uv - center) + noise * value_noise_freq;\n    float t = mod(distance * palette_mod_scale + iTime, 1.0);\n    vec3 rainbowColor = palette_eye(t);\n    \n\n    /* Compute Mask SDF */\n    vec2 p = noise_uv2; // Centered at normalized UVs\n    \n    float dCircle1 = sdCircle(p - vec2(0.0, 0.0), 0.355);\n    float dBox1 = sdRhombus(p - vec2(0.25, 0.0), vec2(0.25, 0.25));\n    float dBox2 = sdRhombus(p + vec2(0.25, 0.0), vec2(0.25, 0.25));\n    \n    float dCircle2 = sdCircle(p - vec2(0.0, 0.0), 0.25);\n    float dCircle3 = sdCircle(p - vec2(0.0, 0.0), 0.15);\n    float dCircle4 = sdCircle(p - vec2(0.0, 0.0), 0.075);\n    \n    float i = opDifference(dCircle2, dCircle3);\n          i = opUnion(i, dCircle4);\n    \n    float d = opUnion(dBox1, dBox2);\n          d = smin(d, dCircle1, 0.001); // hides discontinuity better than basic union?\n          d = opDifference(d, i);\n    \n     \n    /* Final */\n    float edgeWidth = 0.005;\n    float mask = smoothstep(0.0, edgeWidth, -d); // Mask using SDF\n \n    vec3 backgroundColor = vec3(0.0); // Background color\n    vec3 color = mix(backgroundColor, rainbowColor, mask); // mix final color with mask\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}