{"ver":"0.1","info":{"id":"tdVyWW","date":"1602875175","viewed":203,"name":"UPBP 0.4 - Light path direct","username":"rory618","description":"Casting one light beam (reflecting, not scattering) and using each bounce as a point source for direct lighting\nhttps://cs.dartmouth.edu/~wjarosz/publications/krivanek14upbp.html","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","lighttransport"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sf;\n\nfloat lineDist(vec2 z, vec2 a, vec2 b){\n    \n    z -= a; b -= a;                        // go to A referential\n    float q = dot(z, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate\n    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P     \n    return length( z - b);\n}\n\nvec2 project(vec3 right, vec3 forward, vec3 up, vec3 coord, vec3 r0){\n    vec3 delta = coord-r0;\n    vec3 dir = (delta);\n    float f = dot(dir,forward);\n    float r = dot(dir,right);\n    float u = dot(dir,up);\n    return vec2(r/f,u/f);\n    \n}\n\nvoid plotPoint(vec2 point, vec2 uv, inout vec4 O){\n    if(abs(length(point-uv)-10./sf)<2./sf) O += 1.;\n}\n\nvoid plotLine(vec2 A, vec2 B, vec2 uv, inout vec4 O){\n    O = mix(vec4(1,0,0,1),O,clamp(lineDist(uv,A,B)*sf/2.,0.,1.));\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    sf = iResolution.y*1.8;\n    vec2 uv = (I*2.-iResolution.xy)/sf;\n    vec2 m = iMouse.z>0.?(iMouse.xy*2.-iResolution.xy)/sf:.3*sin(iTime*vec2(.13,.14));\n    \n    \n    vec3 eye_path_r0 = vec3(17,1,8);\n    vec3 forward = normalize(vec3(3,17,3)-eye_path_r0);\n    vec3 right = normalize(cross(forward,vec3(0,0,1)));\n    vec3 up = cross(right,forward);\n    vec3 eye_path_rd = normalize(forward + right*uv.x + up*uv.y);\n    \n    vec3 rd_m = normalize(forward + right*m.x + up*m.y);\n    \n    surface_intersection eye_hit = ray_scene(eye_path_r0, eye_path_rd);\n    O = vec4(0);\n    \n    float eye_light = 0.;\n    \n    surface_intersection m_hit = ray_scene(eye_path_r0, rd_m);\n    \n    \n    vec3 light_path_r0 = vec3(10,3,11.8);\n    vec3 light_path_rd = normalize(m_hit.coord - light_path_r0);\n    surface_intersection light_path_hit = ray_scene(light_path_r0, light_path_rd);\n    \n    vec2 light_path_r0_proj = project(right,forward,up,light_path_r0,eye_path_r0);\n    vec2 light_path_hit_proj = project(right,forward,up,light_path_hit.coord,eye_path_r0);\n    \n    plotPoint(light_path_hit_proj, uv, O);\n    plotLine(light_path_r0_proj,light_path_hit_proj, uv, O);\n    \n    vec3 eye_light_rd = normalize(light_path_hit.coord - eye_hit.coord);\n    surface_intersection eye_light_hit = ray_scene(eye_hit.coord, eye_light_rd);\n    if(length(eye_light_hit.coord-light_path_hit.coord)<1e-3){\n        eye_light += dot(eye_hit.normal, eye_light_rd);\n    }\n    float light = 1.;\n    for(int b = 0; b < 10; b++){\n        light *= .6;\n        vec3 light_path_rd_next = reflect(light_path_rd, light_path_hit.normal);\n        surface_intersection light_path_hit_next = ray_scene(light_path_hit.coord, light_path_rd_next);\n        \n        \n        eye_light_rd = normalize(light_path_hit_next.coord - eye_hit.coord);\n        surface_intersection eye_light_hit = ray_scene(eye_hit.coord, eye_light_rd);\n        if(length(eye_light_hit.coord-light_path_hit_next.coord)<1e-3){\n            eye_light += dot(eye_hit.normal, eye_light_rd)*light;\n        }\n        \n        \n    \tvec2 light_path_hit_proj_next = project(right,forward,up,light_path_hit_next.coord,eye_path_r0);\n        \n        plotLine(light_path_hit_proj,light_path_hit_proj_next, uv, O);\n        \n        light_path_hit = light_path_hit_next;\n        light_path_rd = light_path_rd_next;\n        light_path_hit_proj = light_path_hit_proj_next;\n    \tplotPoint(light_path_hit_proj,uv,O);\n    }\n    O = mix(vec4(eye_light/2.),O,O.w);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct surface_intersection {\n    vec3 coord;\n    vec3 normal;\n    float d;\n    int type;\n};\n\nstruct AABB {\n    vec3 a;\n    vec3 b;\n};\n    \nAABB[] walls = AABB[] (\n\tAABB(vec3(0,0,0),vec3(20,20,12)),\n\tAABB(vec3(0,3,0),vec3(3,20,12)),\n\tAABB(vec3(17,3,0),vec3(20,20,12)),\n\tAABB(vec3(8,10,0),vec3(10,12,12)),\n\tAABB(vec3(3,19,0),vec3(6,20,12)),\n\tAABB(vec3(9,19,0),vec3(11,20,12)),\n\tAABB(vec3(14,19,0),vec3(17,20,12)),\n\tAABB(vec3(6,19.4,0),vec3(9,20,3)),\n\tAABB(vec3(6,19.4,9),vec3(9,20,12)),\n\tAABB(vec3(11,19.4,0),vec3(14,20,3)),\n\tAABB(vec3(11,19.4,9),vec3(14,20,12))\n);\n\nAABB[] sunlights = AABB[] (\n\tAABB(vec3(6,19.9,3),vec3(9,20,9)),\n\tAABB(vec3(11,19.9,3),vec3(14,20,9))\n);\n\nAABB[] lamplights = AABB[] (\n\tAABB(vec3(9,2,11.9),vec3(11,4,12))\n);\n\n    \nbool inAABB(AABB box, vec3 p){\n    return (p.x>box.a.x && p.y>box.a.y && p.z>box.a.z && \n            p.x<box.b.x && p.y<box.b.y && p.z<box.b.z);\n}\n\nsurface_intersection ray_AABB(vec3 r0, vec3 rd, AABB box){\n    \n    vec3 tMin = (box.a - r0) / rd;\n    vec3 tMax = (box.b - r0) / rd;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    \n    vec3 nNear = vec3(equal(t1,vec3(tNear)));\n    vec3 nFar = vec3(equal(t2,vec3(tFar)));\n    \n    \n    if(inAABB(box,r0)){\n    \treturn surface_intersection(r0 + rd*length(rd*tFar), -nFar*sign(rd),length(rd*tFar),0);\n    } else{\n    \tif(tNear>tFar || tNear < 1e-5){\n        \treturn surface_intersection(r0,vec3(0),1e8,0);\n    \t} else{\n            return surface_intersection(r0 + rd*length(rd*tNear),-nNear*sign(rd),length(rd*tNear),0);\n        }\n    }\n}\n\nsurface_intersection ray_scene(vec3 r0, vec3 rd){\n    r0 += rd*1e-4;\n    surface_intersection intersect_final = ray_AABB(r0,rd,walls[0]);\n    for(int i = 1; i < walls.length(); i++){\n        surface_intersection intersect = ray_AABB(r0,rd,walls[i]);\n        if(intersect.d<intersect_final.d){\n            intersect_final = intersect;\n        }\n    }\n    for(int i = 0; i < sunlights.length(); i++){\n        surface_intersection intersect = ray_AABB(r0,rd,sunlights[i]);\n        if(intersect.d<intersect_final.d){\n            intersect_final = intersect;\n            intersect_final.type = 1;\n        }\n    }\n    for(int i = 0; i < lamplights.length(); i++){\n        surface_intersection intersect = ray_AABB(r0,rd,lamplights[i]);\n        if(intersect.d<intersect_final.d){\n            intersect_final = intersect;\n            intersect_final.type = 2;\n        }\n    }\n    return intersect_final;\n}","name":"Common","description":"","type":"common"}]}