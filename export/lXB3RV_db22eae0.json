{"ver":"0.1","info":{"id":"lXB3RV","date":"1708623259","viewed":100,"name":"Simple dither","username":"GTG3000","description":"Wanted to see how hard it'd be to do a simple hacky dither approach like this.\nNot *too* difficult, but probably could figure out a better way to align pixels with the noise textures than \"fudge the scale factors until it works\".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["dither"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHER\n#define SIDE_GRADIENT\n#define FULL_GRADIENT_\n#define SIMPLE_\n\n#define scale 3.0\n#define pixel 8.0\n#define mask  8.0\n\nfloat subSample(float value, float threshold) {\n    float v1 = value * scale;\n    float diff = fract(v1);\n\n    #ifdef DITHER\n        v1 = floor(v1);\n        return clamp((v1 + float(diff > threshold))/scale, 0., 1.);\n    #else\n        v1 = floor(v1 + .5);\n        return clamp(v1 / scale, 0., 1.);\n    #endif\n}\n\n\n// Official HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4. ,2.), 6.) - 3.) - 1., 0., 1.);\n\n\treturn c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = floor(fragCoord / pixel)*pixel/iResolution.xy;\n    \n    \n    #ifdef FULL_GRADIENT\n        // Time varying pixel color\n        vec4 col = vec4(.5 + .5 * cos(iTime + uv.xyx + vec3(0, 2, 4)), 1.);\n    #else\n        // Input image\n        vec4 col = texture(iChannel1, uv);\n    #endif\n    \n    // add a gradient to the left\n    #ifdef SIDE_GRADIENT\n        vec4 gradient = vec4(hsv2rgb(vec3(uv.y, clamp(2. - uv.x * 10., 0., 1.), clamp(uv.x * 10., 0., 1.))), 1.);\n        col = mix(col, gradient, float(uv.x < 0.2));\n    #endif\n    \n    // no reason to sample three times\n    vec4 threshold = texture(iChannel0, fragCoord / (pixel * mask));\n    \n    // Output to screen\n    #ifdef SIMPLE\n        #ifdef DITHER\n            fragColor = vec4(clamp(floor(col.xyz * scale + threshold.xxx) / scale, 0., 1.), 1.);\n        #else\n            fragColor = vec4(clamp(floor(col.xyz * scale + .5) / scale, 0., 1.), 1.);\n        #endif\n    #else\n        fragColor = vec4(\n            subSample(col.x, threshold.x),\n            subSample(col.y, threshold.x),\n            subSample(col.z, threshold.x),\n        1.0);\n    #endif\n    \n}","name":"Image","description":"","type":"image"}]}