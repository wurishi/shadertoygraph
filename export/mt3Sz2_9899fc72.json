{"ver":"0.1","info":{"id":"mt3Sz2","date":"1685678950","viewed":166,"name":"3D Brute Force Graph Renderer","username":"hlidskjalf","description":"This shader graphs equations of x, y, and z by calculating the difference between two functions of x/y/z at points along a ray formed for each pixel. Lots of cool parameters to change (especially render_method)!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This graphing calculator approximates the solutions of\n// an equation by finding the difference between the two sides.\n// If the difference is close to zero ('close' can be defined\n// with the parameters below), it can be represented as a\n// solution.\n\n// Each pixel's alpha value is defined by a ray. The alpha of\n// a variable amount of points along this ray are averaged to \n// get the alpha of the pixel.\n\n// Useful Constants\n\nconst float PI = 3.14159;\nconst float E = 2.71828;\n\n// Equation\n\nfloat left_side(float x, float y, float z) {\n    return \n        tan(sin(x) + cos(y))\n    ;\n}\n\nfloat right_side(float x, float y, float z) {\n    return\n        z\n    ;\n}\n\nfloat get_alpha(\n    vec3 pos,\n    float lower_threshold,\n    float upper_threshold\n) {\n    float diff = abs(\n        left_side(pos.x, pos.y, pos.z) - \n        right_side(pos.x, pos.y, pos.z)\n    );\n    \n    // Normalize difference and smoothstep\n    \n    diff = 1.0 / (diff + 1.0);\n    \n    return smoothstep(lower_threshold, upper_threshold, diff);\n}\n\nbool is_in_range(\n    vec3 pos,\n    vec2 x_range,\n    vec2 y_range,\n    vec2 z_range\n) {\n    if (\n        pos.x < x_range.x || pos.x > x_range.y ||\n        pos.y < y_range.x || pos.y > y_range.y ||\n        pos.z < z_range.x || pos.z > z_range.y\n    ) {\n        return false;\n    } return true;\n}\n\nvec3 get_ray_direction (\n    vec3 cam_direction,\n    vec3 up_vector,\n    vec2 pixel,\n    float horizontal_fov,\n    float aspect_ratio\n) {\n    // Calculate the projection plane's size\n\n    float vertical_fov = 2.0 * atan(tan(horizontal_fov / 2.0) / aspect_ratio);\n    vec2 screen_size = vec2(\n        2.0 * tan(horizontal_fov / 2.0), \n        2.0 * tan(vertical_fov / 2.0));\n        \n    // Calculate the pixel's position on the projection plane,\n    // giving the ray within the camera's local space\n        \n    vec3 ray_direction = vec3(1.0,\n        screen_size.x * (pixel.x - 0.5), \n        screen_size.y * (pixel.y - 0.5));\n    \n    // Apply the camera's rotation to the ray\n    \n    vec3 J = (cross(cam_direction, up_vector));\n    ray_direction = ray_direction.x * cam_direction + \n                    ray_direction.y * J + \n                    ray_direction.z * (cross(J, cam_direction));\n    \n    return normalize(ray_direction);\n}\n\n// Goes over points along the ray and averages the alpha values\n// obtained.\n\nfloat get_ray_alpha (\n    vec3 ray_pos,\n    vec3 ray_direction,\n    float sampling_distance,\n    int sampling_points,\n    float lower_threshold,\n    float upper_threshold,\n    float brightness,\n    vec2 x_range,\n    vec2 y_range,\n    vec2 z_range,\n    bool render_method\n) {\n    float step_size = sampling_distance / float(sampling_points);\n    \n    if (render_method) {\n        float sum = 0.0;\n        for (int i = 1; i <= sampling_points; ++i) {\n            vec3 pos = ray_pos + step_size * ray_direction * float(i);\n            if (is_in_range(pos, x_range, y_range, z_range)) {\n                sum = sum + get_alpha(pos, lower_threshold, upper_threshold);\n            }\n        }\n        float alpha = sum / float(sampling_points);\n        return alpha * brightness;\n    } else {\n        for (int i = 1; i <= sampling_points; ++i) {\n            vec3 pos = ray_pos + step_size * ray_direction * float(i);\n            float alpha = get_alpha(pos, lower_threshold, upper_threshold);\n            if (is_in_range(pos, x_range, y_range, z_range) && alpha > 0.9) {\n                return brightness / (distance(ray_pos, pos) + 1.0);\n            }\n        }\n        return 0.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Parameters\n    \n      // render_method = false corresponds to opaque rendering,\n        // where alpha is lower the further away the closest surface is.\n        // Requires much higher sampling_points to create a solid surface\n        \n      // render_method = true corresponds to transparent rendering,\n        // where alpha is averaged over points along each pixel's ray.\n    bool render_method = true;\n    \n        // Restricts the range the graph can render in\n    float lower_x = -10.0;\n    float upper_x = 10.0;\n\n    float lower_y = -10.0;\n    float upper_y = 10.0;\n\n    float lower_z = -10.0;\n    float upper_z = 10.0;\n    \n        // Threshold controls smoothstep; if screen is black, try \n        // increasing brightness\n    float lower_threshold = 0.9;\n    float upper_threshold = 1.0;\n        // Line artifacts are more visible with high brightness;\n        // lowering lower_threshold neccessitates lower brightness,\n        // so line artifacts can be reduced by lowering lower_threshold\n        // at the cost of blurry rendering\n    float brightness = 100.0;\n    \n    vec3 cam_pos = vec3(sin(iTime * 0.25) * 20.0, cos(iTime * 0.25) * 20.0, 10.0);\n        // These vectors must be normalized\n    vec3 cam_direction = normalize(-cam_pos);\n    vec3 up_vector = vec3(0.0, 0.0, 1.0);\n    \n    vec3 color = vec3(1.0, 0.5, 0.0);\n    \n    float horizontal_fov = radians(130.0);\n    float aspect_ratio = 16.0 / 9.0;\n    \n        // Line artifacts can be caused by low \n        // sampling_distance/sampling_points\n    float sampling_distance = 35.0; \n    int sampling_points = 1000;\n\n    // Computing\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 ray_direction = get_ray_direction (\n        cam_direction,\n        up_vector,\n        uv,\n        horizontal_fov,\n        aspect_ratio\n    );\n        \n    float alpha = get_ray_alpha(\n        cam_pos,\n        ray_direction,\n        sampling_distance,\n        sampling_points,\n        lower_threshold,\n        upper_threshold,\n        brightness,\n        vec2(lower_x, upper_x),\n        vec2(lower_y, upper_y),\n        vec2(lower_z, upper_z),\n        render_method\n    );\n    \n    fragColor = vec4(color * alpha, 1.0);\n}","name":"Image","description":"","type":"image"}]}