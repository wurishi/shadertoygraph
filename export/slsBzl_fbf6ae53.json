{"ver":"0.1","info":{"id":"slsBzl","date":"1651543171","viewed":71,"name":"Landscape Shader","username":"matthatter419","description":"Made following the maths laid out in Inigo Quilez's video: \n\nhttps://www.youtube.com/watch?v=BFld4EBO2RE&list=PL0EpikNmjs2CYUMePMGh3IjjP4tQlYqji","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Globals\nconst float PI = 3.1415926535897932384626433832795;\nconst float INVERSE_PI = 0.3183099; // 1/PI \nfloat aspectRatio; // defined in main\nconst float farClipPlane = 30.0;\nconst float degreesToRads = (PI / 180.0);\nconst float sunPhiDegrees = degreesToRads * 10.0;   // angle off horizon\nconst float sunThetaDegrees = degreesToRads * 0.0;  // angle around UP direction\n// direction of a beam of light from the sun\nconst vec3 sun = normalize(vec3(-cos(sunPhiDegrees) * cos(sunThetaDegrees), -sin(sunPhiDegrees) * cos(sunThetaDegrees), -sin(sunThetaDegrees))); \nconst float cloudHeight = 15.0;\nconst mat2 fbmRotateMat = mat2(  0.80,  0.60,\n                                -0.60,  0.80 ); // rotation numbers come from 3-4-5 pythagorean triple\n\nconst mat2 inverseFbmRotateMat = mat2(0.80, -0.60,\n                                      0.60, 0.80);\n\n// Color palette\nconst vec3 landColor = vec3(0.27, 0.18, 0.15);\nconst vec3 grassColor = vec3(0.33, 0.50, 0.27);\nconst vec3 skyColor = vec3(0.35, 0.62, 1.0);\nconst vec3 cloudColor = vec3(1.0, 1.0, 1.0);\nconst vec3 hazeColor = vec3(1,1,1);\n\n// Refinement factors\nconst int terrain_resolution_factor = 9; // number of layers of increasingly higher frequency noise\nconst float domainNoiseScaleFactor = 4.0;      // controls domain scale of noise pattern\nconst float rangeNoiseScaleFactor = 3.0;       // controls range scale of noise pattern\nconst vec3 atmosphericDecayFactor = .004 * vec3( -1.5, -2.2, -1.5);\n\n// Render-target enums\nconst int unknown_targetID = -1;\nconst int mountain_targetID = 1;\nconst int cloud_targetID = 2;\n\n//====== Helper / Generic functions ======= //\n\n// Takes in two input numbers and spits out a (very crude) pseudo-\n// random number.\nfloat pseudoRandom(in vec2 seed) {\n    vec2 intermediate = 50.0*fract(seed*INVERSE_PI);\n    return fract((intermediate.x + intermediate.y)*(intermediate.x * intermediate.y));\n}\n\n// Even cruder pseudo-random number generator; this time taking in a 1D input\n// and an output range.\nfloat pseudoRandomRange(float seed, float minRange, float maxRange) {\n    return ((maxRange - minRange) * fract(sin(seed) * 1000000.0)) + minRange;\n} \n\n// Only valid for values of 'pos' between 0 and 1\nvec2 smoothstepDeriv(vec2 pos) {\n    return 6.0*pos*(1.0-pos);\n}\n\n// Continuous, smoothly varying noise function\nfloat noise(in vec2 position) { \n    position /= domainNoiseScaleFactor;  \n\n    vec2 ij = floor(position);\n    vec2 posFraction = fract(position);\n    vec2 smoothedPositionFract = smoothstep(0.0,1.0,posFraction);\n\n    // Coefficients for noise function\n    float a = pseudoRandom(ij + vec2(0,0));\n    float b = pseudoRandom(ij + vec2(1,0));\n    float c = pseudoRandom(ij + vec2(0,1));\n    float d = pseudoRandom(ij + vec2(1,1));    \n    \n    float noise = a \n        + (b-a)*smoothedPositionFract.x\n        + (c-a)*smoothedPositionFract.y \n        + (a-b-c+d)*smoothedPositionFract.x*smoothedPositionFract.y; \n        \n    return rangeNoiseScaleFactor * noise;\n}\n\nvec2 noiseDeriv(in vec2 position) {\n    position /= domainNoiseScaleFactor;\n\n    vec2 ij = floor(position);\n    vec2 posFraction = fract(position);    \n    vec2 smoothedPositionFract = smoothstep(0.0,1.0,posFraction);\n    vec2 dSmoothedPositionFract = smoothstepDeriv(posFraction);\n\n    // Coefficients for noise function\n    float a = pseudoRandom(ij + vec2(0,0));\n    float b = pseudoRandom(ij + vec2(1,0));\n    float c = pseudoRandom(ij + vec2(0,1));\n    float d = pseudoRandom(ij + vec2(1,1));  \n    \n    return rangeNoiseScaleFactor * dSmoothedPositionFract * vec2(\n        (b-a) + (a-b-c+d) * smoothedPositionFract.y,\n        (c-a) + (a-b-c+d) * smoothedPositionFract.x\n    );\n\n}\n\nvec3 rayPosition(in vec3 rayOrigin, in vec3 rayDirection, in float t) {\n    return (rayOrigin + (rayDirection * t));\n}\n\n// Fractal Brownian Motion - a type of noise made by combining\n// different frequency layers of base noise.\nfloat fbm(in vec2 seed, int iterations) {\n    float value = noise(seed);\n    float domainScale = 1.0;\n    float rangeScale = 1.0;\n            \n    for (int i = 1; i < iterations; i++) {\n        domainScale *= 2.0;\n        rangeScale /= 2.0;\n\n        // (Instead of matrix * matrix to get a new rotation matrix, computationally cheaper to do mat*vec mult)\n        seed = fbmRotateMat * seed;\n        \n        float value_i = rangeScale * noise(domainScale * seed);\n        value += value_i;\n    }\n\n    return value;\n}\n\nvec2 fbm_deriv(in vec2 seed, int iterations) {\n    vec2 derivs = noiseDeriv(seed);\n    float domainScale = 1.0;\n    float rangeScale = 1.0;\n\n    mat2 inverseRotation = mat2(1, 0, 0, 1);\n            \n    for (int i = 1; i < iterations; i++) {\n        domainScale *= 2.0;\n        rangeScale /= 2.0;\n\n        // (Instead of matrix * matrix to get a new rotation matrix, computationally cheaper to do mat*vec mult)\n        seed = fbmRotateMat * seed;\n        inverseRotation *= inverseFbmRotateMat;\n        \n        vec2 derivs_i = inverseRotation * domainScale * rangeScale * noiseDeriv(domainScale * seed);\n        derivs += derivs_i;\n    }\n\n    return derivs;  \n}\n\n//========== END helper functions =========//\n\n// Sum of different frequency noise patterns (fourier series, basically)\nfloat terrainHeight(in vec2 position) {\n    return fbm(position, terrain_resolution_factor);\n}\n\nvec2 terrainDerivative(in vec2 position) {\n    return fbm_deriv(position, terrain_resolution_factor);\n}\n\nvec3 terrainNormal(in vec3 position) {\n    vec2 terrainDerivs = terrainDerivative(position.xz);\n\n    // Precalculated cross-product of slopes in x and z directions \n    return normalize(vec3(-terrainDerivs.x, 1, -terrainDerivs.y)); \n}\n\nfloat terrainSDF(in vec3 position) {\n    return position.y - terrainHeight(position.xz);\n}\n\n// Shadow from other mountains blocking sun. Returns float in range (0, 1).\n// Cast a ray from terrainPosition towards sun. Get distance from ray to terrain\n// along ray's journey and use to calc shadow.\nfloat terrainShadow(in vec3 terrainPosition) {\n\n    float softnessFactor = 32.0;\n    float minT = 0.5;\n    float maxT = 10.0; \n    float dt = 0.1;\n    // Start at 1, can only get smaller (down to 0) in the following process.\n    float minNormalizedTerrainSDF = 1.0;\n    \n    for (float t = minT; t < maxT; t += dt) {\n        vec3 rayPos = rayPosition(terrainPosition, -sun, t);\n        float distToTerrain = terrainSDF(rayPos);\n        if (distToTerrain <= 0.01) { \n            // Ray intersects terrain, return 0 to indicate total shadow.\n            return 0.0;\n        }\n        // Otherwise, depending on how close ray is to terrain, shadow is not total, but fuzzy.\n        float normalizedTerrainSDF = softnessFactor * (distToTerrain / t);\n        minNormalizedTerrainSDF = min(minNormalizedTerrainSDF, normalizedTerrainSDF);\n    }\n\n    return smoothstep(0.0, 1.0, minNormalizedTerrainSDF);\n}\n\nfloat cloudStrength(vec3 intersectionPosition) {\n    return 0.5*smoothstep(-1.0, 8.0, fbm(2.0 * intersectionPosition.xz, 9));\n}\n\nfloat cloudIntersect(in vec3 rayOrigin, in vec3 rayDirection) {\n    // Treat cloud as plane at y = cloudHeight\n    // Equation of ray: ray_O + ray_D*t = (x,y,z)\n    // Isolating the y component: ray_O_y + ray_D_y*t = cloudHeight\n    // Thus we can easily solve for t, where the plane and ray intersect.\n    return (cloudHeight - rayOrigin.y) / rayDirection.y;\n}\n\n// Cast ray at shapes in the scene and see what it intersects\n// Returns ID of object it hit, if any. Also returns intersection distance as out param.\nint castRay(in vec3 rayOrigin, in vec3 rayDirection, out float dist) {\n    int ID = unknown_targetID;\n    float maxT = farClipPlane; \n    float minT = 0.1;  // near-clip plane\n    float dt = 0.1;\n    float t, terrainSdfValue, cloudSdfValue;\n    float oldT = minT;\n    float oldSdfValue = 0.0;\n    float intersectionThreshold = 0.0;\n\n    for (t = minT; t < maxT; t += dt) {\n        vec3 rayPos = rayPosition(rayOrigin, rayDirection, t);\n        \n        // Test for intersection with terrain by comparing heights.\n        // As t increases, resolution decreseases, so we get less picky about what we consider a \"hit\"\n        terrainSdfValue = terrainSDF(rayPos);\n        intersectionThreshold = 0.001*t;\n        if (terrainSdfValue <= intersectionThreshold) {\n            ID = mountain_targetID;\n            // interpolate to give much more accurate results (otherwise shadows are banded and ugly)\n            t = oldT + (intersectionThreshold - oldSdfValue) * (t - oldT) / (terrainSdfValue - oldSdfValue); \n            break;\n        }\n        \n        // Increase dt in proportion to t because as we go \n        // further, detail matters less, so take bigger steps.\n        dt = max(dt, 0.01*t);\n\n        // Save off old values to help interpolate\n        oldT = t;\n        oldSdfValue = terrainSdfValue;\n    }\n\n    // If we didn't hit anything, we'll default to drawing clouds.\n    if (ID == unknown_targetID) {\n        // The cloud intersection distance can be negative (if the ray direction points away from the clouds)\n        // We'll cheat a bit and use an absolute value to put it back in the positive range. Works well enough.\n        dist = abs(cloudIntersect(rayOrigin, rayDirection));\n        return cloud_targetID;\n    }\n    \n    dist = t;\n    return ID;\n}\n\n// Real atmosphere haze follows an exponential decay\nvec3 addAtmosphere(in vec3 color, in float dist) {\n    vec3 haze = exp(atmosphericDecayFactor * dist);      // one exp for each RGB color channel\n    return (haze * color) + ((1.0 - haze) * hazeColor); \n}\n\nvec3 skyGradient(in vec3 rayDirection) {\n    vec3 topColor = vec3(0.81, 0.29, 0.58);\n    vec3 bottomColor = vec3(0.95, 0.68, 0.38);\n    return (topColor * rayDirection.y) + (bottomColor * (1.0 - rayDirection.y));\n}\n\nvec3 reflectedSkyLight(in float terrainNormal_y) {\n    return ((1.0 + terrainNormal_y) / 2.0) * (skyColor / 10.0);\n}\n\n// Some sun light is reflected off the ground onto other spots in the ground.\n// Take a dot product with the _opposite_ sun direction as used for areas in the sun,\n// and use about a 10th of the reflected light to in these spots.\nvec3 reflectedGroundLight(in vec3 terrainNormal) {\n    return  (dot(terrainNormal, sun) * (landColor / 5.0));\n}\n\n// Shift UVs into -1:1 domain and scale to aspect ratio\nvec2 scaleUV(in vec2 uv) {\n    return (( -1.0 + 2.0 * uv) * vec2(aspectRatio, 1.0));\n}\n\n// Create the land material by mixing the land color with snow color where\n// the vertical normal is strong enough to support snow.\nvec3 landMaterial(float yNormal, float yPos) {\n    // Mix land and snow\n    float lambda = smoothstep(0.20, 0.25, yNormal);\n\n    return (landColor * (1.0 - lambda) + (landColor * lambda));\n}\n\n// Create a coordinate system for a camera placed at the ray cast origin and\n// pointed at the given angle\nmat3 createCamera(in vec2 angles) {\n    vec3 UP = vec3(0.0,1.0,0.0); // global up direction\n\n    vec3 cameraDirection = normalize(vec3(cos(angles.x)*cos(angles.y), -cos(angles.x)*sin(angles.y), cos(angles.y)));\n    vec3 cameraRight = normalize(cross(UP, cameraDirection));\n    vec3 cameraUp = normalize(cross(cameraDirection, cameraRight));\n    \n    // This is a change-of-basis matrix. When applied to a vector represented in\n    // the space of the ray/target, it transforms the vector to the camera-space.\n    return mat3(cameraRight, cameraUp, cameraDirection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aspectRatio = iResolution.x/iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scaledUV = scaleUV(uv);\n    \n    // Cast rays via a camera. The ray and target are defined in global 3D space,\n    // The camera is a change-of-basis matrix that takes vectors in camera-space to\n    // global-space. In camera-space we aim a ray at each UV coordinate,\n    // then transform that ray into its global-space representation and cast it out. \n    vec3 cameraPos = vec3(-5.0, 3.0, 0.0); \n    vec2 cameraAngles = vec2(degreesToRads * 0.0, degreesToRads * 15.0);\n    mat3 camera = createCamera(cameraAngles);\n    vec3 rayDirection = camera * normalize(vec3(scaledUV, -1.5)); \n\n    // Cast ray and find point of intersection\n    float distIntersect;\n    int intersectionID = castRay(cameraPos, rayDirection, distIntersect);\n    vec3 intersectionPosition = rayPosition(cameraPos, rayDirection, distIntersect);\n    \n    // Default color to sky\n    vec3 col = skyGradient(rayDirection);\n    switch (intersectionID) {\n    case mountain_targetID: \n        vec3 normal = terrainNormal(intersectionPosition);\n        float sun_shading = -dot(sun, normal);\n        float shadow = terrainShadow(intersectionPosition); // shadow from other mountains blocking sun\n        vec3 reflectedSkyLight = reflectedSkyLight(normal.y);\n        vec3 reflectedGroundLight = reflectedGroundLight(normal);\n        vec3 landColor = landMaterial(normal.y, intersectionPosition.y);\n        col = (landColor * sun_shading * shadow) + reflectedSkyLight + reflectedGroundLight;\n        break;\n    case cloud_targetID:\n        float cloudMixStrength = cloudStrength(intersectionPosition);\n        col = (col * (1.0 - cloudMixStrength)) + (cloudMixStrength * cloudColor);\n        // col = vec3(cloudMixStrength);\n        break;\n    }\n\n   \n    // Add atmosphere haze\n    col = addAtmosphere(col, distIntersect);\n\n    // Smoothstep the color to make dark colors darker and light colors lighter\n    // col = smoothstep(0.0, 1.0, col);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}