{"ver":"0.1","info":{"id":"NtdXzr","date":"1638630495","viewed":124,"name":"Look at me go","username":"SwampFall","description":"Watch it move!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","music","eye","sphere","trippy","laser","dj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 calculateNormals(vec2 uv, float r, float dist, float mask) {\n    return normalize(vec3(sin(uv.x/r*THIRD_PI), sin(uv.y/r*THIRD_PI), sqrt(cos(dist/r*HALF_PI)))) * mask;\n}\n\nvoid drawEye(vec2 uv, vec3 eyePos, vec3 eyeDir, float eyeRadius, float energy, out vec3 col) {\n\n    // Eye dimensions\n    float irisRadius = 0.1 * (1. + 2.*(1.+energy));\n    float pupilRadius = 0.01 * (1. + 2.*(1.+energy));\n    const float irisBorder = 0.01;\n\n    // Compensation factor for iris size\n    float irisSizeComp = 0.5 + 0.5 * eyeDir.z;\n    // Compensation factor for iris texture position\n    const float irisPosComp = 0.2;\n    const vec3 irisCol = vec3(1.0, 1.0, 0.0);\n\n    // Light properties\n    vec3 lightPos = vec3((-3.+2.*energy),3.+2.*energy,1.) + eyeDir * 2.;\n    vec3 lightCol = vec3(0.9, 0.8, 0.6);\n    lightCol = (0.8 + 0.2*cos(iTime+lightCol.xyx+vec3(0,2,4))) * (0.1+energy) * 3.;\n    // Glossiness for specular highlight\n    float gloss = 70.0 - 35.*energy;\n    // Camera position\n    const vec3 camPos = vec3(0.0, 0.0, 1.0);\n\n    vec2 eyeUv = uv - eyePos.xy;\n    float zoff = clamp((eyeDir.z - 1.0) * 0.5, -1.0, 0.0);\n    vec2 irisUv = eyeUv - eyeDir.xy * eyeRadius - irisPosComp * eyeDir.xy * zoff * zoff;\n\n    float dist = length(eyeUv);\n    float eyeMask = float(dist < eyeRadius);\n\n    vec3 normals = calculateNormals(eyeUv, eyeRadius, dist, eyeMask);\n    \n    float angle = atan(irisUv.y / irisUv.x) * (1. - 2. * float(irisUv.x < 0.)) * energy * 2.;\n\n    float eyeDirDist = 1.0 - clamp((dot(normals, normalize(eyeDir))),0.0,1.0);\n    \n    float irisPupilMask = float(eyeDirDist < irisRadius * irisSizeComp - irisBorder);\n    float pupilMask = float(eyeDirDist < pupilRadius * irisSizeComp) * irisPupilMask;\n    float ringMask = float(eyeDirDist - irisSizeComp * irisRadius < 1.*irisBorder) - float(eyeDirDist - irisSizeComp * irisRadius < -1.*irisBorder);\n    float irisMask = irisPupilMask - pupilMask;\n    \n    vec3 pixelPos = normals * eyeRadius + eyePos;\n\n    float ambientLight = 0.1 * (eyeMask - pupilMask) - 0.04 * irisMask - 0.05 * ringMask;\n    \n    vec3 L = normalize(lightPos - pixelPos);\n    vec3 H = normalize(camPos + L);\n    float specularLight = pow(clamp(dot(H, normals), 0.0, 1.0), gloss);\n    \n    float diffuseLight = clamp(dot(normals, normalize(lightPos - eyePos))*0.4*(1.+0.3*energy),0.0,1.0);\n    \n    float light = clamp(diffuseLight + specularLight, 0.0, 1.0);\n\n    col = clamp(col - eyeMask, 0.0, 1.0);\n    \n    vec3 laserCol = (0.5 + 0.5*cos(iTime+col.xyx+vec3(0,2,4)));\n    \n    float irisTexture = texture(iChannel0, fract(vec2(angle/4.0,0.0))).x * irisMask * clamp(light + 3.*energy, 0., 1.);\n    col = clamp(col + ambientLight * lightCol / (0.1+energy)/3. + light * lightCol + irisTexture * irisCol, 0.0, 1.0);\n    \n    float energyDist = smoothstep(-1., 0., -uv.y + energy * 2. * eyeRadius - eyeRadius);\n    float fresnel = pow(clamp(1. + dot(-camPos, normals), 0., 1.), (3. - 2.*energy*energyDist));\n    \n    col += vec3(fresnel) * laserCol * eyeMask * energyDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy / min(iResolution.x, iResolution.y);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 bufferA = texture(iChannel1, uv);\n    float energy = bufferA.a;\n    vec3 col = bufferA.rgb;\n    \n    vec3 lookDir = texelFetch(iChannel2, ivec2(0), 0).xyz;\n    //float t = steppedTime(EYE_MOV_SPEED, EYE_MOV_INTERVAL, EYE_MOV_OFFSET);\n    //vec3 lookPos = randomPos(t, .1, 5.0 * float(energy > ACTIVATION_ENERGY));\n    \n    \n    // Credit to Danilo Guanabara (Danguafer on shadertoy)\n    vec3 c;\n\tfloat l,z=iTime*EYE_MOV_INTERVAL;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv2,p=fragCoord.xy/iResolution.xy;\n\t\tuv2=p;\n\t\tp-=.5;\n\t\tp.x*=iResolution.x/iResolution.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv2+=p/l*(sin(z*2.*PI/EYE_MOV_INTERVAL)+15.)*abs(sin(l*3.-z-z));\n\t\tc[i]=.3/length(mod(uv2,1.)-.5);\n\t}\n    \n    if (energy > ACTIVATION_ENERGY)\n        col = clamp(col + c/l * 0.25 * energy, 0., 1.);\n    \n    drawEye(uv * resolution *2. - resolution, vec3(0., 0., 0.), lookDir, 0.7, energy, col);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float steppedTime(float speed, float interval, float offset) {\n    float t = (iTime - offset) / interval;\n    float ft = fract(t) - 1.;\n    if (ft > - speed)\n        return (floor(t) + (ft + speed) / speed) * 0.0078125;\n    else\n        return floor(t) * 0.0078125;\n}\n\nvec3 randomPos(float xoff, float yoff, float amp) {\n    return vec3(texture(iChannel1, fract(vec2(xoff, 11.0 * yoff))).x * 2.0 * amp - amp,\n                texture(iChannel1, fract(vec2(xoff, 13.0 * yoff))).x * 2.0 * amp - amp,\n                texture(iChannel1, fract(vec2(xoff, 31.0 * yoff))).x * 2.0 * 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float energy = 0.;\n    vec3 lookPos = vec3(0.);\n    if (fragColor.xy == vec2(0.)) {\n        // calculate energy\n        for (int i = 0; i < N_SAMPLES; i++) {\n            energy += pow(texture(iChannel0, vec2(MIN_FREQ + float(i) * FREQ_STEP, 0.)).x, 2.) / float(N_SAMPLES);\n        }\n\n        energy = clamp((energy - MIN_ENERGY) / ENERGY_RANGE, 0., 1.);\n\n        energy = pow(energy, ENERGY_POWER);\n        \n        float t = steppedTime(EYE_MOV_SPEED, EYE_MOV_INTERVAL, EYE_MOV_OFFSET);\n        lookPos = normalize(randomPos(t, .1, 5. * float(energy > ACTIVATION_ENERGY)));\n    }\n    fragColor = vec4(lookPos, energy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#ifdef GL_ES\nvec4 texelFetch(sampler2D tex, ivec2 uv, int lod) { return texture(tex, vec2(float(uv.x),float(uv.y))); }\n#endif\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n#define THIRD_PI 1.0471975512\n\n// Sound Energy\n#define MIN_FREQ 0.\n#define MAX_FREQ .7\n#define N_SAMPLES 200\n#define FREQ_STEP (MAX_FREQ - MIN_FREQ) / float(N_SAMPLES)\n\n#define MIN_ENERGY 0.\n#define MAX_ENERGY 0.3\n#define ENERGY_RANGE MAX_ENERGY - MIN_ENERGY\n#define ENERGY_POWER 3.\n\n#define ACTIVATION_ENERGY 0.00001\n\n\n// Blur\n#define KERNEL_SIZE 1\n#define BLUR_FADE 0.985\n\n\n// Eye movement\n#define EYE_MOV_SPEED 0.05\n// 60./BPM of ourpithyator\n#define EYE_MOV_INTERVAL 60./125.\n#define EYE_MOV_OFFSET 0.","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy / min(iResolution.x, iResolution.y);\n\n    vec2 uv = fragCoord / iResolution.xy;    \n\n    \n    //float energy = 0.;\n    //for (float i = MIN_FREQ; i < MAX_FREQ; i += FREQ_STEP) {\n    //    energy += pow(texture(iChannel1, vec2(i, 0.)).x, 2.) / N_SAMPLES;\n    //}\n    //energy = clamp((energy - MIN_ENERGY) / ENERGY_RANGE, 0., 1.);\n    //energy = pow(energy, ENERGY_POWER);\n    \n    float energy = texelFetch(iChannel1, ivec2(0), 0).a;\n    \n    \n    float width = 0.01 * (1.+6.*energy);\n    float radius = 0.7 + width;\n    \n    vec2 luv = uv * resolution * 2. - resolution;\n    \n    float dist = length(luv);\n    \n    float circleThreshold = -radius + radius * 2. * energy;\n    float circle = (float(dist < radius + width) - float(dist < radius - width)) * float(luv.y < circleThreshold);\n    \n    float x1 = cos(asin(circleThreshold / radius)) * radius;\n    float x2 = -x1;\n    float y = circleThreshold;\n    \n    float m1 = -x1 / y;\n    float m2 = -x2 / y;\n    \n    float c1 = y - m1 * x1;\n    float c2 = y - m2 * x2;\n    \n    float eq1d = abs(m1 * luv.x + luv.y - c1) / sqrt(m1 * m1 + 1.);\n    float eq2d = abs(m2 * luv.x + luv.y - c2) / sqrt(m2 * m2 + 1.);\n    \n    float lineThreshold = float(circleThreshold < luv.y);\n    \n    float l1 = float(eq1d < width) * lineThreshold;\n    float l2 = float(eq2d < width) * lineThreshold;\n\n    int count = 0;\n    vec3 blur = vec3(0.,0.,0.);\n    for (int i = -KERNEL_SIZE; i < KERNEL_SIZE + 1; i++) {\n        for (int j = -KERNEL_SIZE; j < KERNEL_SIZE + 1; j++) {\n            vec2 uvk = vec2(fragCoord.x + float(i), fragCoord.y + float(j)) / iResolution.xy;\n            blur += texture(iChannel0, uvk).xyz;\n            count++;\n        }\n    }\n    \n    vec3 col = vec3(circle + l1 + l2, 0., 0.);\n    col = clamp(BLUR_FADE * blur / float(count) + (0.5 + 0.5*cos(iTime+col.xyx+vec3(0,2,4))) * (l1 + circle + l2), 0., 1.);\n\n    fragColor = vec4(col, energy);\n}","name":"Buffer B","description":"","type":"buffer"}]}