{"ver":"0.1","info":{"id":"dtyfz1","date":"1701831326","viewed":123,"name":"aesthetic","username":"jneen","description":"its an aesthetic","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["aesthetic","jneen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float E=.0001;\n\nfloat T;\n\n#define nsin(X) (.5+.5*sin(X))\n\nvec2 uv;\nvec2 absuv;\nfloat box(vec3 p, vec3 a) {\n  vec3 q=abs(p)-a;\n  \n  return length(max(q,0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nfloat studio(vec3 n) { return length(.5+.5*sin(n))/sqrt(3.); }\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nfloat G = 0.;\nfloat w(vec3 p) {\n  G += 1.;\n  float O;\n  p.xz *= rot(T);\n  p.xy *= rot(T *.5);\n  \n  O = length(p) - 2.;\n  \n  vec3 p2 = p.xyz;\n  p2.yz *= rot(T*2.);\n  p2.xz *= rot(T*.5);\n  O = max(O, -box(p2, vec3(1.7)));\n  O = min(O, length(p)-.8);\n  \n  O = max(O, -length(p.xz) + .5);\n  O = max(O, -length(p.xy) + .5);\n  O = max(O, -length(p.yz) + .5);\n  \n\n  return O-.01;\n}\n\nvec3 P;\nfloat D;\nvec3 dir;\nfloat H=0.;\nvoid march() {\n  D = 0.1;\n  P += dir*0.1;\n  H=0.;\n  for (int i=0; i<100; i+=1) {\n    float d=w(P)*.4;\n    D += d;\n    P += d*dir;\n    if (d<E)break;\n    if (D>1000.)return;\n  }\n  H=1.;\n}\n\nvec3 N;\nvoid norm() {\n  mat3 k=mat3(P,P,P)-mat3(E);\n  N=normalize(w(P)-vec3(w(k[0]),w(k[1]),w(k[2])));\n}\n\nfloat point(vec3 n, vec3 p, vec3 l) {\n  return max(0., dot(n, normalize(l-p)));\n}\n\nvec3 render() {\n  vec3 bg = vec3(0,.2,.3);\n  if (H == 0.) {\n    return mix(vec3(0,.2,.3),bg+.7,1.-pow(abs(absuv.y-sin(pow(absuv.x,3.)+iTime*10.)*.1), .4));\n  }\n  \n  norm();\n  \n  //return vec3(dot(N,-dir));\n  float diff = studio(N);//length(nsin(N))/sqrt(3.);\n  float pt = point(N, P, vec3(0)); //max(0., dot(N, normalize(-P)));\n  \n  float refl = 0.;\n/*  for (float i=0.; i < 1.; i+=1.) {\n      dir = reflect(dir, N);\n      P += 0.1*dir;\n      march();\n\n      if (H==0.) break;\n      norm();\n      refl += length(nsin(N))/sqrt(3.)*pow(.01,i+1.);\n  }*/\n  \n  \n  return vec3(.2,.8,.6)*diff+vec3(.6,.2,.8)*pt + refl;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    /*uv.x += sin(sin(iTime*20.)*.05)*.15;\n    uv.x += sin(sin(iTime*10.1)*.06)*.1;\n\n    uv.y += sin(sin(iTime*20.123)*.05)*.1;\n    uv *= 1.+abs(sin(sin(iTime*6.)*.06));\n*/\n\n    absuv = uv.xy;\n    float r = 1.;\n    \n    if (iTime > 60.) r = abs(sin(.2*iTime));\n    \n    if (iTime > 30.) uv *= rot(iTime);\n\n    uv = tan(uv*r)/r;\n    uv *= rot(-.5*iTime);\n\n    T = iTime + uv.y;\n\n    P = vec3(0,0, -3);\n\n    if (iTime > 60.) { P.z *= abs(sin(.2*iTime)); }\n    dir = normalize(vec3(-uv, 1));\n    //dir.xz *= rot(2.*iTime);\n\n    march();\n    float glow = G;\n    \n\n    vec3 col = render();\n    //col = vec3(0);\n    // Output to screen\n    col += G/200.;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}