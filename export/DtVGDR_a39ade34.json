{"ver":"0.1","info":{"id":"DtVGDR","date":"1683895735","viewed":161,"name":"Particle sim 2","username":"Nazlbit","description":"Particle sim 2. Integrated the Voronoi Tracking algorithm from [url]https://www.shadertoy.com/view/WltSz7[/url]","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["particles","sim"],"hasliked":0,"parentid":"dtV3Rm","parentname":"Particle sim"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nivec4 getClosest(ivec2 xy){\n    return ivec4(texelFetch(iChannel1, xy, 0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n\n    ivec4 ids = getClosest(ivec2(fragCoord));\n    int id = ids[0];\n    vec2 pos = get_particle(iChannel0, id).xy;\n\n    float d = distance(fragCoord / iResolution.y, pos);\n    float a = d * scale / radius;\n    color += hsv2rgb(vec3(float(id) / float(num_particles), 1.0, 1.0)) * pow(1.0 / (a * a + 1.0), 5.0) * 2.0;\n\n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.0);\n\n    //draw voronoi outlines\n    //get the position of the closest particle\n    //vec2  p1 = get_particle(iChannel0, ids.x).xy;\n    //get the position of the second closest particle\n    //vec2  p2 = get_particle(iChannel0, ids.y).xy;\n    //get the distance to voronoi edge\n    //float r = dot(fragCoord/iResolution.y-(p1+p2)/2.,normalize(p2-p1));\n    //fragColor += smoothstep(1.0 / iResolution.y,0.,abs(r))*.3;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int num_particles = 5000;\nconst float radius = 0.02;\nconst float dt = 0.0007;\nconst float G = 0.003;\nconst float friction_factor = 4.0;\nconst float collision_factor = 2.0;\nconst float the_force_factor = 10.0;\nconst float initial_angular_momentum_factor = 0.3;\nconst float scale = 10.0;\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat noise(vec2 uv, int frame, inout int seed)\n{\n    return random(uv + vec2(frame, seed++));\n}\n\nvec2 noise2(vec2 uv, int frame, inout int seed)\n{\n    return vec2(noise(uv, frame, seed), noise(uv, frame, seed));\n}\n\nvec4 sample_data_channel(sampler2D data_channel, ivec2 uv)\n{\n    return texelFetch(data_channel, uv, 0);\n}\n\nconst int data_array_width = int(ceil(sqrt(float(num_particles))));\n\nint get_index(vec2 frag_coord)\n{\n    return int(frag_coord.x) + int(frag_coord.y) * int(data_array_width);\n}\n\nvec4 get_particle(sampler2D channel, int i)\n{\n    ivec2 uv;\n    uv.x = i % data_array_width;\n    uv.y = i / data_array_width;\n    return sample_data_channel(channel, uv);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int seed = 0;\n\nvoid walls(inout vec4 p)\n{\n    const float r = radius / scale;\n    if(p.x - r < 0.0)\n    {\n        p.x = r;\n        p.z = abs(p.z);\n    }\n    else if(p.x + r > iResolution.x / iResolution.y)\n    {\n        p.x = iResolution.x / iResolution.y - r;\n        p.z = -abs(p.z);\n    }\n    if(p.y - r < 0.0)\n    {\n        p.y = r;\n        p.w = abs(p.w);\n    }\n    else if(p.y + r > 1.0)\n    {\n        p.y = 1.0 - r;\n        p.w = -abs(p.w);\n    }\n}\n\nvec2 the_force(const vec4 p)\n{\n    bool lmb = iMouse.z > 0.0;\n    if(!lmb)\n    {\n        return vec2(0);\n    }\n\n    vec2 mouse_pos = iMouse.xy / iResolution.y;\n\n    vec2 dp = mouse_pos - p.xy;\n    float d_2 = dot(dp, dp);\n    vec2 dpn = dp / sqrt(d_2);\n\n    float f = the_force_factor / (d_2 + 1.0);\n    return f * dpn;\n}\n\nfloat erf_inv(float x) // https://en.wikipedia.org/wiki/Error_function\n{\n    const float a = 6.802721;\n    const float b = 4.330747;\n\n    float u = log(1.0 - x*x);\n    float c = u * 0.5 + b;\n    return sqrt(sqrt(c*c - u*a) - c) * sign(x);\n}\n\nvec4 init_point(vec2 uv)\n{\n    vec4 p0;\n    p0.xy = noise2(uv, 0, seed) * 2.0 - 1.0;\n    p0.xy = vec2(erf_inv(p0.x), erf_inv(p0.y)) * 0.2;\n    p0.xy = normalize(p0.xy) * sqrt(noise(uv, 0, seed)) * 0.8;\n    p0.zw = p0.xy;\n    p0.xy = p0.xy * 0.5 + 0.5 * vec2(iResolution.x / iResolution.y, 1.0);\n    p0.zw = vec2(p0.w, -p0.z) * initial_angular_momentum_factor;\n    return p0;\n}\n\nvoid update_point(inout vec4 p0, int index0)\n{\n    vec2 a = vec2(0);\n\n    for(int i = 0; i < num_particles; ++i)\n    {\n        if(i == index0)\n        {\n            continue;\n        }\n\n        vec4 p1 = get_particle(iChannel0, i);\n\n        vec2 dp = p1.xy - p0.xy;\n        float d_2 = dot(dp, dp);\n        float d = sqrt(d_2);\n        vec2 dpn = dp / d;\n\n        float c = smoothstep(0.0, 2.0 * radius / scale, d);\n\n        float f = G / (d_2 * scale * scale + 1.0) * c\n                - collision_factor * (1.0 - c)\n                + friction_factor * dot(p1.zw - p0.zw, dpn) * (1.0 - c);\n\n        a += f * dpn;\n    }\n\n    a += the_force(p0);\n\n    walls(p0);\n\n    p0.xy += (p0.zw + a * dt * 0.5) * dt;\n    p0.zw += a * dt;\n}\n\nvoid mainImage( out vec4 p0, in vec2 frag_coord )\n{\n    vec2 uv = frag_coord / iResolution.xy;\n    int index0 = get_index(frag_coord);\n    \n    if(index0 >= num_particles)\n    {\n        return;\n    }\n    \n    if(0 == iFrame)\n    {\n        p0 = init_point(uv);\n        \n    }\n    else\n    {\n        p0 = get_particle(iChannel0, index0);\n        \n        update_point(p0, index0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\n//returns the ids of the four closest particles from the input\nivec4 getClosest(ivec2 xy){\n    return ivec4(texelFetch(iChannel1, xy, 0));\n}\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = get_particle(iChannel0, id).xy - fragCoord / iResolution.y;\n    return dot(delta, delta);\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e20);\n    \n    //get all known closest particles from old self and neighbours  \n    ivec4 old   = getClosest( iFragCoord + ivec2( 0, 0) );      \n    ivec4 east  = getClosest( iFragCoord + ivec2( 1, 0) );\n\tivec4 north = getClosest( iFragCoord + ivec2( 0, 1) );\n    ivec4 west  = getClosest( iFragCoord + ivec2(-1, 0) );\n    ivec4 south = getClosest( iFragCoord + ivec2( 0,-1) );\n    \n    //collect them in a array so we can loop over it\n    ivec4[5] candidates = ivec4[5](old, east, north, west, south); \n    \n    for(int i=0; i<5; i++){\n        for(int j=0; j<4; j++){\n            int id = candidates[i][j];\n            float dis2 = distance2Particle(id, fragCoord);\n            insertion_sort( new, dis, id, dis2 );\n        }\n    }\n    \n    for(int k = 0; k < 1; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(num_particles));\n        insertion_sort(new, dis, p, distance2Particle(p, fragCoord) );\n    }\n    \n    fragColor = vec4(new); \n    \n}","name":"Buffer B","description":"","type":"buffer"}]}