{"ver":"0.1","info":{"id":"7lKGR1","date":"1637189189","viewed":84,"name":"Ray Marching Apple Watch","username":"allisj","description":"lots of rounded shapes","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"wdKyD3","parentname":"Ray marching SDFs 2021"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// BASIC RAY-MARCHING CLASS DEMO!\n//\n// Numerous methods borrowed from iq articles:\n//   https://iquilezles.org/www/index.htm\n// \n// 3D signed distance functions:\n//   https://iquilezles.org/articles/distfunctions\n// \n// Shadows:\n//   https://iquilezles.org/articles/rmshadows\n// \n// Ray-marching SDFs:\n//   https://iquilezles.org/articles/raymarchingdf\n// \n// Normals for SDFs:\n//   https://iquilezles.org/articles/normalsSDF\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nvec4  opUnion(vec4 d1, vec4 d2) {\n return (d1.x < d2.x ? d1 : d2);   \n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nvec4  opIntersection( vec4  d1, vec4  d2 ) {\n return (d1.x > d2.x ? d1 : d2);   \n    \n}\n\n// subtracts d1 from d2\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec4  opSubtraction( vec4  d1, vec4  d2 ) { \n  return opIntersection(vec4(-d1.x,d1.yzw), d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// 3D gradient noise methods. \n// https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat fbm( in vec3 pos )\n{\n    vec3  q = 8.0*pos;\n    float f = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); //q = m*q*2.02;\n    //f += 0.1250*noise( q ); q = m*q*2.03;\n    //f += 0.0625*noise( q ); \n    return f;\n}\n\n\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, 0.,\n\t\t+.0, +.0, 1.);\n}\n\n// iq distance functions, \n// See https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdSphere(vec3 p, float radius )\n{\n  return length(p)-radius;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// not exact\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// See https://www.shadertoy.com/view/Wdjfz3\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x);\n    \n    float r = ra - rb;\n\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 bendPoint( in vec3 p , float amt)\n{\n    float k = amt; //  some amount, e.g., 10.\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n// Function to y-axis revolve a 2D SDF into a 3D SDF.\nvec2 revolvePoint( in vec3 p, float radius )\n{\n    return vec2( length(p.xz) - radius, p.y );\n}\n\n// Simple ellipsoidal SDF pumpkin at origin.\nfloat sdPumpkin(vec3 p) \n{\n\tfloat sdf = 100.;\n    for(int i=0; i<10; i++) {// somewhat expensive\n    \tvec3  rp = rotate_y(p, 6.28*float(i)/10.+0.27);\n        vec3  q  = rotate_z(rp-vec3(0.6,0.,0.),-0.1);\n\t    float d  = sdEllipsoid(q, vec3(0.8, 1., 0.6));\n        sdf = opSmoothUnion(d, sdf, 0.03);\n        //sdf = opUnion(d, sdf);\n    }\n    \n    return sdf;\n}\n\n\n/// SCENE PARAMETERS (feel free to add your own):\nconst vec3 pumpkinCenter     = vec3(0., -0.15, -8.0);\nconst vec3 Cd_pumpkinOutside = vec3(231./255., 111./255., 3./255.); \nconst vec3 Cd_pumpkinInside  = vec3(1.,0.7,0.);\nconst vec3 Cd_stem           = vec3(0.35,0.25,0.15);\n\n// SDF implementation for our scene. \n// Returns 4 values: (sdf, Cd)\n//   .x: SDF distance, \n//   .y: Cd.r\n//   .z: Cd.g\n//   .w: Cd.b\n// NOTE: You could return other things for yzw, e.g., y:objectID int to set more colors in \"render.\"\nvec4 mapV4(in vec3 p)\n{\n    // SDF vector (sdf, r,g,b) to be returned:\n    vec4 sdf = vec4(100000., -1., 0., 0.);\n    \n    float mx = iMouse.x/iResolution.x;\n\n\n    // TODO: REPLACE THE FOLLOWING WITH YOUR SCENE CODE:\n    \n    // Translate coordinate to pumpkin center:\n    vec3 c = pumpkinCenter;\n    p -= c;\n    \n    if(false) { // test stuff:\n    \n        //Yellow sphere:\n        float d1   = sdSphere(p-vec3(1.,0.,0.), 2.);\n        vec4  sdf1 = vec4(d1, vec3(1., 1., 0.));\n        \n        //Red sphere:\n        float d2   = sdSphere(p+vec3(1.,0.,1.), 2.);\n        vec4  sdf2 = vec4(d2, vec3(1., 0., 0.));\n        \n        vec4  sdfU = opUnion(sdf1, sdf2);\n        vec4  sdfS = opSubtraction(sdf1, sdf2);\n        vec4  sdfI = opIntersection(sdf1, sdf2);\n        return sdfU;\n\n    }  \n    \n    \n    \n    // watch\n    if(true){\n        p = rotate_x(p, 1.0 - 2.0*iMouse.y/iResolution.y);\n        p = rotate_y(p, iMouse.x/iResolution.x);\n    \n        float halfPi = 1.5708;\n    \n        // colors\n        vec3 strap = vec3(0.95);\n        vec3 screen = vec3(0.2);\n        vec3 frame = vec3(0.6);\n        vec3 button = vec3(1.0, 0.0, 0.0);\n        \n        // screen: a round box\n        vec4 screenSDF = vec4(sdRoundBox(p, vec3(0.34,0.29,0.09), 0.06), screen);\n        \n        // frame: a rounder round box\n        vec4 frameSDF = vec4(sdRoundBox(p, vec3(0.35,0.3,0.04), 0.1), frame);\n        \n        vec4 faceSDF = opUnion(screenSDF, frameSDF);\n        \n        // button: round cylinder with another red round cylinder\n        vec4 buttonSDF = vec4(sdRoundedCylinder(p+vec3(0.2, -0.4, 0.0), 0.04, 0.02, 0.04), frame);\n        buttonSDF = opUnion(buttonSDF, vec4(sdRoundedCylinder(p+vec3(0.2, -0.401, 0.0), 0.036, 0.02, 0.04), button));\n        \n        faceSDF = opUnion(buttonSDF, faceSDF);\n        \n        // strap: a rounded box and two rounded cylinders\n        vec4 bandSDF = vec4(sdRoundBox(p, vec3(2.5,0.2,0.02), 0.04), strap);\n        \n        // round the ends of the strap\n        vec3 rightSide = p + vec3(2.5, 0.0, 0.0);\n        rightSide = rotate_x(rightSide, halfPi);\n        vec4 rightTipSDF = vec4(sdRoundedCylinder(rightSide, 0.12, 0.05, 0.01), strap);\n        \n        vec4 strapSDF = opUnion(bandSDF, rightTipSDF);\n        \n        vec3 leftSide = p - vec3(2.5, 0.0, 0.0);\n        leftSide = rotate_x(leftSide, halfPi);\n        vec4 leftTipSDF = vec4(sdRoundedCylinder(leftSide, 0.12, 0.05, 0.01), strap);\n        \n        strapSDF = opUnion(strapSDF, leftTipSDF);\n        \n        // put the holes in the strap\n        vec3 holeLocation = p - vec3(1.1, 0.0, 0.0);\n        holeLocation = rotate_x(holeLocation, halfPi);\n        \n        for (int i=0; i<6; i++) {\n            vec4 holeSDF = vec4(sdRoundedCylinder(holeLocation-vec3(float(i)*0.2, 0.0, 0.0), 0.028, 0.5, 0.0), strap);\n            strapSDF = opSubtraction(holeSDF, strapSDF);\n        }\n        \n        // put the clasp on the strap\n        vec3 claspLocation = p + vec3(2.0, 0.0, 0.0);\n        claspLocation = rotate_x(claspLocation, -halfPi);\n        vec4 claspSDF = vec4(sdRoundCone(claspLocation, 0.0, 0.03, 0.01), frame);\n        \n        //strapSDF = opUnion(strapSDF, claspSDF);\n        \n        return opUnion(faceSDF, strapSDF);\n        \n    }\n    \n    \n    if(true){// BODY:\n\t\t// OUTSIDE: Union of ellipsoids\n        vec3 q = p;//local copy\n        sdf.x = sdPumpkin(q);\n        sdf.yzw = Cd_pumpkinOutside;// + 0.1*vec3(1.,1.,0.)*length(q.xz);\n        if(sdf.x < 0.01) {\n            float theta = atan(q.z,q.x) + 0.015*noise(10.*p);\n            sdf.yz += 0.02*abs(sin(40.*theta)-0.9)*abs(sin(100.*theta)-0.9);\n\n            // INSIDE: Subtract ellipsoid\n            float cutoutSD  = sdEllipsoid(q, vec3(1.1, 0.7, 1.1)); \n            vec3  cutoutCol = Cd_pumpkinInside; \n            vec4  cutout    = vec4(cutoutSD, cutoutCol);\n            sdf = opSubtraction(cutout, sdf);\n        }\n    }\n   \n    if(true){//STEM:\n        vec3 q = p; \n        q.y *= -1.;\n        vec3 tmpq = q;\n\t    q.yxz = bendPoint(q.yxz, 0.4);\n        q = rotate_z(q, 0.4);\n    \tfloat stemSD  = sdCappedCone(q + vec3(.0, 1.25,0.), 0.45, 0.1, 0.2);// (p, h, r1, r2)\n        vec3  stemCol = Cd_stem*2.;\n        if(stemSD<0.01){// modify color\n\t        float theta = atan(q.z, q.x);// + 0.015*noise(10.*p);\n            stemCol.xy += 0.02*abs(sin(40.*theta)-0.9)*abs(sin(100.*theta)-0.9);\n            //stemSD *= (1. + 1.*abs(sin(10.*theta)-0.9));\n        }\n        \n        vec4  stem = vec4(stemSD, stemCol);\n    \tsdf   = opUnion(sdf, stem);\n    }\n\n    if(true){// ADD NOISE:  (use sparingly--ruins signed-distance property)\n        sdf += 0.006*noise(8.*p);\n        //sdf.x += 0.015*fbm(0.65*p); // costly. \n    }\n\n    if(true){// CARVE:\n\t\t// NOSE:\n        float noseSD = sdTriPrism(p-vec3(0.,0.,1.2), vec2(.2, 1.));\n        vec4  noseCutout = vec4(noseSD, Cd_pumpkinInside);\n        sdf = opSubtraction(noseCutout, sdf);\n        \n        // EYES:\n        vec2  xyEye = vec2(0.45, 0.35);\n        float eyeSD = sdCapsule(vec3(abs(p.x),p.yz), vec3(xyEye, 0.), vec3(xyEye, 2.), 0.2);\n        vec4  eyeCutout = vec4(eyeSD, Cd_pumpkinInside);\n        sdf = opSubtraction(eyeCutout, sdf);\n        \n        \n        // MOUTH: \n        //vec3  q = vec3(p.x, -p.y+0.5, p.z-.5);\n        float d = sdRoundBox(p + vec3(0.,0.5, -0.8), vec3(0.5, 0.01, 0.8), 0.1);\n            //sdCappedTorus(q, vec2(0.866025,-0.5), 0.55, 0.05);//vec2(0.8, 0.0), 1., 0.2);\n        vec4  mouth = vec4(d, Cd_pumpkinInside);\n        sdf = opSubtraction(mouth, sdf);\n        \n        \n    }\n\n    if(true){// TABLE: \n        //float d = sdPlane(p, normalize(vec3(0.,1.,0.)), 1.2);\n        //float d = sdBox(p-vec3(0.,-1.3,0.), vec3(5., 0.1, 10.));\n        float d = sdRoundedCylinder(p-vec3(0.,-1.2,0.), 1.2, 0.1, 0.1);\n        vec4  table = vec4(d, vec3(0.5,0.,0.));\n\t\tsdf = opUnion( sdf, table );       \n    }\n\n    // CUTAWAY PLANE:\n    #if 0\n        float d = sdPlane( p, normalize(vec3(-1.,0.,-1.)), 3.*(mx-0.5));\n        vec4 cutPlane = vec4(d, vec3(1.,0.,0.)); //Cd_pumpkinInside);\n        //sdf = opIntersection(sdf, cutPlane); \n        sdf = opSubtraction(cutPlane, sdf); \n    #endif\n    \n    #if 0   \n    {// COORDINATE BOX GUIDE:\n    \tfloat d = sdBoundingBox(p, vec3(1.), 0.02);\n        sdf = opUnion(sdf, vec4(d, vec3(0.8)));\n    }\n    #endif \n    \n    return sdf;\n}\n\n\n// Scalar SDF implementation for our scene\nfloat map(in vec3 p)\n{\n    return mapV4(p).x;// just sdf value\n}\n\n//vec3 calcNormal( in vec3 p ) // for function map(p)\n//{\n//    const float eps = 0.0001; // or some other value\n//    const vec2  h   = vec2(eps,0);\n//    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n//                          map(p+h.yxy) - map(p-h.yxy),\n//                           map(p+h.yyx) - map(p-h.yyx) ) );\n//}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e);\n    }\n    return normalize(n);\n#endif    \n}\n\n// Vector raymarch: \n// .x   : t* value of surface, or -1 if didn't hit anything.\n// .yzw : pass-thru from mapV4.yzw\n// \nvec4 raymarchV4(in vec3 ro, in vec3 rd) \n{\n    //int steps = int(round(200.0*iMouse.y/iResolution.y));\n    float t = 0.0;\n    for(int i=0; i<513; i++) {\n        vec3  rt = ro + rd*t;\n        vec4  f  = mapV4(rt);\n\t\tfloat d  = f.x;\n        \n        if(d<0.001) {// We hit it or went too far\n            f.x = t; // replace .x's sdf with t*\n            //f.yzw = vec3(1.,0.,0.);\n            return f;\n        }\n        else {// keep marching\n         \tt += 0.95*d; // conservative/smaller step for inexact/warped SDFs\n        }\n        \n        if(t > 100.) {\n            f.x = -1.;// -ve t* --> didn't hit anything\n            return f;\n        }\n    }\n    \n\treturn vec4(-1., vec3(0.)); // didn't hit anything\n}\n\n/// Returns t* value of surface, or -1. if didn't hit anything.\nfloat raymarch(in vec3 ro, in vec3 rd) \n{\n    return raymarchV4(ro,rd).x;  \n}\n\n// Raymarch SDF: \n// Returns: t* value of surface, or -1.0 if didn't hit anything.\nfloat raymarchVanilla(in vec3 ro, in vec3 rd) \n{\n    float t = 0.0;\n    for(int i=0; i<200; i++) {\n        vec3  rt = ro + rd*t;\n        float d  = map(rt); // SDF of scene\n        \n        if(d<0.001) {// We hit it (or went too far)\n            return t;\n        }\n        else {// keep marching\n         \tt += d; // Assumes exact SDFs\n        }\n        \n        if(t > 100.) {\n            return -1.0;\n        }\n    }\n    \n\treturn -1.0; // didn't hit anything\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.;\n        t += 0.95*h;//can do slightly less for not-quite-SDFs\n    }\n    return 1.0;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += 0.95*h;//slightly less for not-quite-SDFs\n    }\n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) \n{\n    vec3  col = vec3(0.,0.,0.);    // init color to background\n    vec4  ray = raymarchV4(ro, rd);// compute distance along ray to surface\n    float t   = ray.x;\n    vec3  Cd  = ray.yzw;// can passthru other shading values, e.g., objectID, but we did color.\n    \n    vec2  mouse = iMouse.xy/iResolution.xy; \n    mouse = vec2(0.5, 0.5);\n\n    \n    if(t>0.0) {//hit surface --> shade it:   \n\n\t    vec3  p  = ro + rd*t; // point on surface\n        vec3  N  = calcNormal(p); // sdf normal\n        \n        // DETERMINE MATERIAL COLOR: (todo: all orange for now)\n        //vec3  Cd = vec3(231./255., 111./255., 3./255.); // diffuse color\n        \n        // DIRECTIONAL LIGHT:\n        vec3  posL   = ro+ 30.*vec3(mouse.x-0.5, mouse.y-0.5,0.);// light at eye (safe!)\n        vec3  L      = normalize(posL - p);\n        vec3  CL     = vec3(1.);// directional light color\n        float LdotN  = clamp(dot(L,N), 0., 1.);\n        //float shadL  = shadow(p, L, 0.01, 10.);\n        float sshadL = softshadow(p, L, 0.01, length(posL-p), 2.);\n\t    col = Cd * CL * LdotN * sshadL;// * sshadL; // * occ;\n        \n        // CANDLE LIGHT (#2):\n        if(false) {\n            //vec3  dp     = 2.*vec3(0., mouse.y-0.5, mouse.x-0.5);\n            vec3  posL2  = pumpkinCenter + .15*vec3(sin(20.*iTime),cos(7.*iTime),cos(14.*iTime));\n            vec3  L2     = normalize(posL2 - p);\n            vec3  CL2    = vec3(1.,1.,.2);// candle light color\n            float L2dotN = clamp(dot(L2,N), 0., 1.);\n            float shadL2  = shadow(p, L2, 0.02, length(posL2-p));\n            //float sshadL2 = softshadow(p, L2, 0.01, length(posL2-p), 8.);\n            col += Cd * CL2 * L2dotN * shadL2; // * occ;       \n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pXY = (fragCoord - 0.5*iResolution.xy)/iResolution.y; // normalized coordinates (unit height)\n    vec3 pix = vec3(pXY,    0.);    // position of virtual pixel (Z=0 depth)\n    vec3 ro  = vec3(0., 0., 3.);    // ray origin (EYE POSITION).. controls field-of-view\n    vec3 rd  = normalize(pix - ro); // ray direction\n    \n    vec3 col = render(ro, rd); // ray-march and evaluate color\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}