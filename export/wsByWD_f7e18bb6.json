{"ver":"0.1","info":{"id":"wsByWD","date":"1587352301","viewed":83,"name":"Raycaster (Water Bottle)","username":"KhanGressman","description":"Okay, I give up.  I'll lay aside my explorations of ray tracing for now and find out all the cool things you can do with ray marching.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MAX_DIST 1000.\n#define SURF_DIST .001\n\n\n// noise (from https://www.shadertoy.com/view/3d23z1)\nfloat N21(vec2 p) {\n    return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv, int octaves) {\n    float c = SmoothNoise(uv*2.);\n    \n    float sca;\n    float mag = 1.;\n    for (int i = 1; i < 3; i++) {\n    \tsca = pow(2.,float(i+1));\n        mag += 1./sca;\n        c += SmoothNoise(uv*sca) / sca;\n    }\n    c /= mag;\n    \n    return c;\n}\n\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\n// Materials\nstruct MATE {\n\tvec3 col;\n    vec3 specCol; // vec3(1) to reflect light color, col to reflect object color\n    float diff;\n    float spec;\n};\nMATE mate1;\nMATE mate2;\n\n// Shapes\nint HIT_OBJECT; // keeps track of which object was hit\nfloat sdSphere (vec3 p, float r) {\n\treturn length(p)-r;\n}\nfloat sdCapsule (vec3 p, vec3 a, vec3 b, float radius) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    float d = length(p-c) - radius;\n    return d;\n}\nfloat sdTorus (vec3 p, vec2 r) {\n\tfloat x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat sdCylinder (vec3 p, vec3 a, vec3 b, float radius) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    float x = length(p-c) - radius;\n    float y = (abs(t-.5)-.5) * length(ab);\n    float e = length(max(vec2(x,y), 0.));\n    float i = min(max(x,y), 0.);\n    return e+i;\n}\nfloat sdPlane (vec3 p, vec3 normal) {\n\treturn dot(p, normalize(normal));\n}\n\n// Boolean Opperations\nfloat boolSubtract(float d1, float d2) {\n\treturn max(-d2, d1);\n}\nfloat boolIntersect(float d1, float d2) {\n\treturn max(d1, d2);\n}\nfloat boolUnion(float d1, float d2, float smoothness) {\n\treturn smin(d1, d2, smoothness);\n}\nfloat boolMix(float d1, float d2, float amount) {\n\treturn mix(d1, d2, amount);\n}\n\n// Render\nfloat GetDist(vec3 p) {\n    vec2 t = -vec2(-6,-4);\n    float pd = 1e20;//dot(p, normalize(vec3(0,1,0)))+1.;\n    \n    // Bottle\n    vec3 cp = p;\n    \n    float ang = atan(cp.x,cp.z);\n    float dent = 5.*cos(ang*5.) * smoothstep(0.1,0.03,cp.y)*cos(cp.y*20.) * smoothstep(-0.3,0.03, cp.y) * (sin(ang*cos(ang*3.))-1.)*0.01;\n    cp.x -= (dent) * cos(ang);\n    cp.z += (dent) * sin(ang);\n    \n\tfloat r = .2 + (sin(cp.y*3.14+0.5)*0.5+0.5)*0.04;\n    float roundness = (1.3-cp.y)*0.02 + 0.05;\n    float bd = sdCylinder(cp, vec3(0), vec3(0,1,0), r-roundness)-roundness;\n    \n    // Cap\n    cp = p;\n    cp.y -= 1.;\n    cp.y *= (1.-cp.x)*0.2 + 0.8;\n    cp.y += 1.;\n    r = 0.211 + smoothstep(1., 1.2, cp.y)*.01;\n    roundness = 0.01;\n    float cd = sdCylinder(cp, vec3(0,1,0), vec3(0,1.2,0), r-roundness)-roundness;\n    cd *= .5;\n    \n    // Cap Inside\n    cp = p;\n    cp.y -= 1.2;\n    \n    // sphere\n    r = 0.2;\n    float sd = sdSphere(cp, 0.21);\n    \n    // plane\n    cp = p;\n    cp.y += cp.x*0.03;\n    float cpd = dot(cp, vec3(0,-1,0)) + 1.175;\n    sd = smin(sd, cpd, -0.005);\n    \n    cd = smin(cd, -sd, -0.01);\n    \n    // mouth piece\n    cp = p;\n    cp.y -= 1.17;\n    cp.y *= 0.5;\n    cp.z *= cp.x*4.;\n    cp.x -= .175;\n    sd = sdSphere(cp, 0.03);\n    \n    cd = smin(cd, -sd, -0.01);\n    \n    // button\n    cp = p;\n    cp.y -= 1.05;\n    \n    cp.x += .23;\n    cp.yz *= 1. + clamp(pow(0.04-cp.x, 4.),0.,1.)*10000.*vec2(1.,2.);\n    roundness = clamp(0.04-cp.x,0.01,0.015);\n    float bnd = dBox(cp, vec3(.03,.15,.1)-roundness)-roundness;\n    \n    bnd = smin(-bd+0.03, bnd, -0.01);\n    \n    bnd /= 10.;\n    cd = smin(cd, bnd, 0.02);\n    \n    float d = pd;\n    if (bd < cd) { HIT_OBJECT = 0; d = min(d,bd); }\n    else { HIT_OBJECT = 1; d = min(d,cd); }\n    return d;\n}\n\nvec3 GetNormal (vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarch (vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i ++) {\n    \tvec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dS < SURF_DIST || abs(dO) > MAX_DIST) { break; }\n    }\n    return dO;\n}\n\nstruct LIGHT {\n\tvec3 pos;\n    vec3 col;\n};\n\nvec3 GetLight (vec3 p, vec3 camPos, MATE mate, LIGHT light) {\n    vec3 lightPos = light.pos;\n    vec3 lightCol = light.col;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    vec2 rl = reflect(l.xz, n.xz);\n    \n    float diff = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float spec = clamp(dot(normalize(p.xz-camPos.xz), rl)*.5+.5, 0., 1.)*1.3;\n    spec = pow(spec, 8.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n   \tif (/*p.y < SURF_DIST && */d < length(lightPos-p)) {diff *= 0.2; spec *= 0.2; }\n    \n\treturn ((diff*mate.diff+0.2)*mate.col*lightCol + spec*mate.specCol*mate.spec*lightCol);\n}\n\nvec3 GetRay(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy - vec2(0.5,0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.5, 2, -1);\n    ro.yz *= Rot(-m.y*1.5);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRay(uv, ro, vec3(-0.,0.75,0), 1.3); \n    \n    \n    mate1.col = vec3(0.7);\n    mate1.specCol = vec3(1);\n    mate1.diff = 1.;\n    mate1.spec = 0.5;\n    \n    mate2.col = vec3(0.3);\n    mate2.specCol = vec3(1);\n    mate2.diff = 1.;\n    mate2.spec = 0.01;\n    \n    float d = RayMarch(ro, rd);\n    \n    MATE hitMate;\n    if (HIT_OBJECT == 0) { hitMate = mate1; }\n    else { hitMate = mate2; }\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        \n        LIGHT light1;\n        light1.pos = vec3(3,4.,-2);\n        light1.col = vec3(1,0.9,0.9);\n        \n        LIGHT light2;\n        light2.pos = vec3(-2,2, -1);\n        light2.col = vec3(0.3,0.5,0.5);\n        \n        LIGHT light3;\n        light3.pos = vec3(0,-0.5,2);\n        light3.col = vec3(0.2,0.2,0.2);\n        \n        col = GetLight(p, ro, hitMate, light1);\n        col += GetLight(p, ro, hitMate, light2);\n        col += GetLight(p, ro, hitMate, light2);\n        col /= 3.;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}