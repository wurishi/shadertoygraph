{"ver":"0.1","info":{"id":"dsl3W2","date":"1666837076","viewed":96,"name":"Fork Fork GPVM  - Week 2","username":"rockes","description":"GPVM Path Tracing Week 2\n\nLive coded in this meeting: https://www.meetup.com/graphics-programming-virtual-meetup/events/289232636/\n\nPath Tracing logic is in Buffer A.\n\nWASD: camera movement\nMouse drag: change the view direction","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"mslGDj","parentname":"Fork GPVM Path  cdgiessen 354"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n  * Path Tracing\n  */\n\nuint rngState;\n\nfloat pi = 3.; // close enough\n\n// Ray\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nvec3 rayAt(Ray ray, float t) {\n  return ray.origin + t * ray.direction;\n}\n\nstruct Material {\n    int type;\n    vec3 color;\n    float roughness;\n}; \n\nMaterial materials[] = Material[](\n    Material(1, vec3(1.0, 0.0, 1.0), 0.1),\n    Material(0, vec3(0.0, 0.0, 1.0), 0.),\n    Material(1, vec3(0.9, 0.9, 0.9), 0.5)\n);\n\nstruct Sphere {\n  vec3 center;\n  float radius;\n  int material_index;\n};\n\nSphere spheres[] = Sphere[](\n  Sphere(vec3(-1.5, 0.0, 3.0), 1.0, 0),\n  Sphere(vec3(1.5, 0.0, 3.0), 1.0, 1),\n  Sphere(vec3(0.0, -101.0, 0.0), 100.0, 2)\n);\n\n// Scene\nvec3 background(Ray ray)\n{\n    //return texture(iChannel2, ray.direction).rgb;\n    float x = -ray.direction.x;\n    vec3 col = vec3(0.7, 0.8, 1.0) - 0.5 * x;\n    col = mix(col, vec3(0.8, 0.9, 1.0), min(exp(-10.0*x), 0.0));\n    return col;\n}\n\nstruct HitRecord {\n  float t;\n  vec3 position;\n  vec3 normal;\n  int material_index;\n};\n\nbool raySphereIntersection(Ray ray, int index, inout HitRecord hit)\n{\n  Sphere sphere = spheres[index];\n  float radius = sphere.radius;\n  \n  //if (index == 1) {\n  //  sphere.center += vec3(sin(iTime * 0.1), 0.0, 0.0);\n  //}\n  \n  vec3 oc = ray.origin - sphere.center;\n  float a = dot(ray.direction, ray.direction);\n  float b = 2.0 * dot(oc, ray.direction);\n  float c = dot(oc, oc) - radius*radius;\n  float discriminant = b*b - 4.0*a*c;\n  \n  if (discriminant >= 0.0) {\n    float t = (-b - sqrt(discriminant) ) / (2.0*a);\n    \n    if (t > 0.0) {\n      vec3 hitPoint = rayAt(ray, t);\n    \n      if (t < hit.t) {\n        hit.t = t;\n        hit.material_index = sphere.material_index;\n        hit.position = hitPoint;\n        hit.normal = normalize(hitPoint - sphere.center);\n      }\n      return true;\n    }\n    \n  }\n  return false;\n}\n\n\n// TODO: Replace stub ray marching code with proper ray tacing\nbool castRay(Ray ray, out HitRecord hit)\n{\n    bool hitSomething = false;\n    for (int i = 0; i < spheres.length(); i++) {\n      hitSomething = hitSomething || raySphereIntersection(ray, i, hit);\n    }    \n    return hitSomething;\n}\n\nvec3 random_direction() {\n  return normalize(vec3(uniformFloat01(rngState), uniformFloat01(rngState), uniformFloat01(rngState)) * 2. - 1.);\n}\n\n// Path tracing\nvec3 traceRay(Ray ray, inout uint rngState)\n{\n  vec3 color = vec3(1.0);\n  \n  for (int i = 0; i < 20; ++i) {\n    HitRecord hit;\n    hit.t = 10000.0;\n  \n    if (castRay(ray, hit)) {\n      Material mat = materials[hit.material_index];\n      switch(mat.type) {\n        case(0): // perfectly specular\n          color *= mat.color;\n          ray = Ray(hit.position /* + hit.normal * 1e-4*/, reflect(ray.direction, hit.normal));\n        break;\n        case(1): // diffuse\n         \n          vec3 v = normalize( hit.normal + mat.roughness * random_direction());\n          ray = Ray(hit.position, v);\n          color *= mat.color * (max(dot(v, hit.normal),0.));\n        break;\n        case(2):\n          \n          // mix of diffuse & specular?\n        break;\n      }\n      \n      \n    } else {\n      return color * background(ray);\n    }\n  }\n  return color;\n}\n\nRay generateRay(vec2 fragCoord, inout uint rngState) {\n    vec2 rotation = load(ROTATION_INDEX).xy / iResolution.x;\n    \n    vec2 jitter = vec2(uniformFloat01(rngState), uniformFloat01(rngState)) - 0.5f;\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = normalize(vec3((fragCoord + jitter - iResolution.xy*0.5)*a, 0.5));\n    rd *= CameraRotation(rotation);\n    return Ray(ro, rd);\n}\n\n\nvec3 finalGather(vec3 color, vec2 fragCoord) {\n    int frameCount = getFrameCount();\n    if (frameCount != 0) {\n        vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        color = mix(lastFrameColor, color, 1.0f / float(frameCount+1));\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    Ray ray = generateRay(fragCoord, rngState);\n\n    vec3 col = traceRay(ray, rngState);\n    col = finalGather(col, fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n  * Persistent states\n  */\n#define store(pos, value) if (all(equal(ivec2(fragCoord), (pos)))) { fragColor = (value); }\n\nvoid updateCamera(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0) {\n        store(PREVIOUS_ROTATION_INDEX, vec4(0.0, 0.0, 0.0, 0.0));\n        store(ROTATION_INDEX, vec4(0.0, 0.0, 0.0, 0.0));\n    }\n    \n    vec2 prevRotation = load(PREVIOUS_ROTATION_INDEX).xy;\n    vec3 rotation = load(ROTATION_INDEX).xyz;\n\n    bool mouseButtonDown = iMouse.z > 0.0;\n    vec2 mouseCurrentPos = iMouse.xy;\n    vec2 mouseClickPos = abs(iMouse.zw);\n        \n    const float moveSpeed = 0.01;\n    \n    vec2 rotation2 = rotation.xy / iResolution.x;\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n    rd *= CameraRotation(rotation2);\n    \n    if (mouseButtonDown) {\n        store(ROTATION_INDEX, vec4(prevRotation + mouseClickPos - mouseCurrentPos, 1.0, 0.0));\n    } else if (rotation.z != 0.0) {\n        store(PREVIOUS_ROTATION_INDEX, vec4(rotation.xy, 0.0, 0.0));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = load(ivec2(fragCoord));\n\n    bool isResolutionChanged = any(notEqual(load(RESOLUTION_INDEX).xy, iResolution.xy));\n    store(RESOLUTION_INDEX, vec4(iResolution, 0.0));\n    \n    bool atStart = iFrame == 0;\n    updateCamera(fragColor, fragCoord);\n\n    store(MOUSE_POS_INDEX, iMouse);\n    \n    bool isMouseMoved = !all(equal(load(MOUSE_POS_INDEX), iMouse));\n    bool needResetFrame = atStart || isMouseMoved || isResolutionChanged;\n    int frameCount = needResetFrame ? 0 : getFrameCount() + 1;\n    store(FRAME_COUNT_INDEX, vec4(float(frameCount), 0.0, 0.0, 0.0));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define load(pos) texelFetch(iChannel1, (pos), 0)\n\nconst ivec2 MOUSE_POS_INDEX = ivec2(0, 0);\nconst ivec2 RESOLUTION_INDEX = ivec2(1, 0);\n\nconst ivec2 FRAME_COUNT_INDEX = ivec2(0, 1);\n\nconst ivec2 PREVIOUS_ROTATION_INDEX = ivec2(2, 0);\nconst ivec2 ROTATION_INDEX = ivec2(2, 1);\n\n#define getFrameCount() int(load(FRAME_COUNT_INDEX).x)\n\nmat3 CameraRotation(vec2 m)\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotX * rotY;\n}\n\nvec3 lessThanV3(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n// Random\nuint pcg(uint seed)\n{\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n \nfloat uniformFloat01(inout uint state)\n{\n    state = pcg(state);\n    return float(state) / 4294967296.0;\n}","name":"Common","description":"","type":"common"}]}