{"ver":"0.1","info":{"id":"lldXRn","date":"1477831009","viewed":376,"name":"Amiga-Style Copper Bars","username":"GeekyMcGeekface","description":"This is my first ShaderToy. It's a nod to the old-school Amiga Copper bars.\nFeedback is very welcome, in particular if you think any of my code idioms could be improved.","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["2d","retro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsB3WR","filepath":"https://soundcloud.com/maniacs-of-noise/jeroen-tel-cybernoid-ii-master","previewfilepath":"https://soundcloud.com/maniacs-of-noise/jeroen-tel-cybernoid-ii-master","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// COPPER BARS, AMIGA STYLE!\n// 30 Oct 2016\n\n// Follow me on Twitter : @GeekyMcGeekface\n// Feedback welcome, this is my first ShaderToy.\n\n// v1.1 (1/11/2016) : Factored into vectors. Thanks for FabriceNeyret2 for the suggestions.\n// v1.2 (1/11/2016) : ADD_SOME_PLOP. (Thanks https://www.shadertoy.com/view/MlSSDV). Also music.\n\n#define ADD_SOME_PLOP\n\n//#define DO_BRIGHTNESS_SNAP\n#define BRIGHTNESS_SNAP\t(0.2)\n\n#define QUANTIZE_X\t\t\t\t// Comment out to show smooth sine-waves. Enable for Amiga-style copper.\n#define QUANTIZE_SIZE\t\t8.0\n#define BAR_SIZES\t\t\tvec3(3.0, 2.5, 2.0)\t\t// Bigger = Thinner bars\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef ADD_SOME_PLOP\n    // Funky plasma-type effect\n    // Tweaked version of : https://www.shadertoy.com/view/MlSSDV\n\tfloat t = iTime/2.;\n    vec2 U = 8.* fragCoord / iResolution.xy - 4.;\n//    U = 4.* U / iResolution.xy;\n    \n    for (int i=0; i<8; i++)\n    \tU += cos( U.yx *3. + vec2(t,1.6)) / 3.,\n        U += sin( U.yx + t + vec2(1.6,0)) / 2.,\n        U *= 1.3;\n    \n    vec4 o;\n//\to += length(mod(U,2.)-1.);  // black & white\n\to += length(U) / 32.0;\n#endif\n\n    vec2 fragPos = vec2(2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;   \n\n#ifdef QUANTIZE_X\n    fragPos.x = (floor(fragPos.x * QUANTIZE_SIZE) / QUANTIZE_SIZE);\n#endif\n\n    float xQuant = fragPos.x + iTime;\n    float xQuant2 = xQuant + iTime;\n    vec3 c;\n\n    c.x = ((sin(xQuant*2.5)*0.5) * (cos((xQuant2*1.7)+0.55) * 0.5)) + iTime * 0.2;\n    c.y = sin(xQuant2*3.8+0.3)*0.13 * sin(iTime * 0.9);\n    c.z = cos(xQuant*3.1) * 0.07;\n    c = (c + fragPos.y) * BAR_SIZES;\n  \n    // This line injects gaps between the bars, otherwise all components of c\n    // are continuous (non-zero) values, which means that c.x (=red) is\n    // a continuous signal & only red bars are visible.\n    c *= step( vec3(1.0, 2.0, 0.0), mod(c, vec3(2.0, 4.0, 1.0) ));\n\n    // See : http://pietermans.com/blog/triangle-wave-algorithms/\n    // Move to range [-1,+1] (0.5 ensures round bars /\\ vs \\/)\n    // and abs() fn makes signal into sawtooth [0,1]\n    c = abs((fract(c+0.5) * 2.0) - 1.0);\n\n    // Snap values < BRIGHTNESS_SNAP down to 0.\n#ifdef DO_BRIGHTNESS_SNAP\n    c *= step( BRIGHTNESS_SNAP, c );\n#endif\n\n   \tfragColor = c.x > 0.0 ? vec4(c.x, 0.0, 0.0 , 1.0)\n        \t:\tc.y > 0.0 ? vec4(0.0, c.y, 0.0 , 1.0)\n            :\t\t\t\tvec4(0.0, 0.0, c.z, 1.0);\n#ifdef ADD_SOME_PLOP\n    fragColor *= o;\n#endif\n}\n","name":"Image","description":"","type":"image"}]}