{"ver":"0.1","info":{"id":"wdfXW2","date":"1553960081","viewed":733,"name":"Trippy Music Visualizer","username":"IsaacAndersen","description":"simple pattern that looks pretty good with music. ","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4tfGD7","filepath":"https://soundcloud.com/lowkey-darksoul/fkj-masego-tadow","previewfilepath":"https://soundcloud.com/lowkey-darksoul/fkj-masego-tadow","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SS smoothstep\n#define PI 3.14159\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat maxFreq() {\n    float numChannels = 64.; // all 512 seems overkill\n    float maxFreq = 0.;\n    for(float i = 0.; i < 1.; i += 1./numChannels) {\n        float fft  = texture( iChannel0, vec2(i,0.25) ).x;\n        \n        if (fft > 0.5) maxFreq = i;\n    }\n    \n    return maxFreq;\n}\n\nfloat CC(vec2 uv, vec2 p, float freq) {\n    float dist = length(p-uv);\n    return .5+.5*sin(2.*PI*freq*dist);\n}\n\nfloat C(vec2 uv, vec2 p) {\n    return length(p-uv);\n}\n\nvec3 circleGrid(vec2 uv, float td, float direction) {\n    float t = iTime + td;\n    \n    float sF = 4.; // scale\n    \n    float tp = mod(t,sF)/sF;\n    float stp = SS(.8,.1,tp);\n    \n    vec3 col = vec3(0);\n    \n    vec2 p = vec2(0,0);\n    \n    vec2 newUV = 2.*uv*(mod(-t,sF));\n    \n\n    float a = PI*t*0.25*direction;\n    newUV *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    \n    vec2 cellID = floor(newUV);\n    \n    vec2 pv = 1.*(fract(newUV)-.5);\n    \n    \n    float r = 0.25+stp;\n    float fracPercent = 1.-stp;\n    \n   \tfloat mx = maxFreq();\n    \n    for (int i = 0; i < 3; i++) {\n        r *= 0.95;\n        \n        float freq = 5.+10.*mx;\n    \tcol[i] += fracPercent*smoothstep(r, r*.5,max(CC(pv,p,freq),C(pv,p)));\n    \n    }\n    \n    col = col.bgr;\n    \n   \treturn col;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float t = iTime/3.0;\n    vec3 R = iResolution;\n    vec2 uv = (U - R.xy*.5)/ R.y;\n\n    vec3 col = vec3(0);\n    \n    vec2 shift = vec2(0);\n    \n    col += circleGrid(uv,0.0,1.);  \n    col += circleGrid(uv,2.5,-1.);\n   \n    if (maxFreq() > 0.75) {\n        col += circleGrid(uv,0.0,-1.);\n    \tcol += circleGrid(uv,2.5,1.);\n    }\n    \n    O = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}