{"ver":"0.1","info":{"id":"llSBWm","date":"1515976614","viewed":101,"name":"13/2018","username":"rimina","description":"This shader is part of my daily shader challenge. Today I continued exploring voronoi pattern. This time I tried to do it in 3d. I have no idea how to visualize it properly but I think this looks kind of pretty.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","dailyshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define PIXELR 0.5/iResolution.x\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\nfloat dist(vec3 q){\n    vec3 f = fract(q);\n    vec3 i = floor(q);\n    \n    vec3 n[27];  \n    n[0] = vec3(-1.0, -1.0, -1.0);\n    n[1] = vec3(-1.0,  0.0, -1.0);\n    n[2] = vec3(-1.0,  1.0, -1.0);\n    \n    n[3] = vec3(0.0,  -1.0, -1.0);\n    n[4] = vec3(0.0,   0.0, -1.0);\n    n[5] = vec3(0.0,   1.0, -1.0);\n    \n    n[6] = vec3(1.0,  -1.0, -1.0);\n    n[7] = vec3(1.0,   0.0, -1.0);\n    n[8] = vec3(1.0,   1.0, -1.0);\n    \n    n[9] = vec3(-1.0, -1.0,\t 0.0);\n    n[10] = vec3(-1.0, 0.0,  0.0);\n    n[11] = vec3(-1.0, 1.0,  0.0);\n    \n    n[12] = vec3(0.0,  -1.0,  0.0);\n    n[13] = vec3(0.0,   0.0,  0.0);\n    n[14] = vec3(0.0,   1.0,  0.0);\n    \n    n[15] = vec3(1.0,  -1.0,  0.0);\n    n[16] = vec3(1.0,   0.0,  0.0);\n    n[17] = vec3(1.0,   1.0,  0.0);\n    \n    n[18] = vec3(-1.0, -1.0,  1.0);\n    n[19] = vec3(-1.0,  0.0,  1.0);\n    n[20] = vec3(-1.0,  1.0,  1.0);\n    \n    n[21] = vec3(0.0,  -1.0,  1.0);\n    n[22] = vec3(0.0,   0.0,  1.0);\n    n[23] = vec3(0.0,   1.0,  1.0);\n    \n    n[24] = vec3(1.0,  -1.0,  1.0);\n    n[25] = vec3(1.0,   0.0,  1.0);\n    n[26] = vec3(1.0,   1.0,  1.0);\n    \n    float t = 1000.0;\n    for(int it = 0; it < 27; ++it){\n        vec3 p = hash33(i+n[it]);\n        p = (1.0+sin(iTime*0.25 + 2.0*PI*p))*0.5;\n        float d = length(n[it]+p-f);\n        t = min(t, d);\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = mat3(x, y, z)*vec3(uv, radians(50.0));\n    \n    //Tiling space..\n    vec3 q = rd*12.0;\n    \n    float t = dist(q);\n    vec3 p = ro+rd*t;\n    vec3 col = p+t+vec3(0.6, 0.6, 0.8);\n    col *= 0.2;\n    \n    col = pow(col, 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}