{"ver":"0.1","info":{"id":"lfcSzl","date":"1714306336","viewed":56,"name":"cel shading experience","username":"leftonred","description":"i'm just trying to learn about cel shading in order to do something complex with hlsl\n\nREFERENCES:  ** https://www.shadertoy.com/view/ll33Wn **\n                      ** https://iquilezles.org/articles/distfunctions/ **","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","celshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// REFERENCES:  ** https://www.shadertoy.com/view/ll33Wn **\n//              ** https://iquilezles.org/articles/distfunctions/ **\n\n\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 1.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n\n#define AMBIENT 0.25\n#define EDGE_THICKNESS 0.05\n#define SHADES 4.0\n\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sdSphere( vec3 p)\n{\n  return length(p)- 1.5;\n}\n\n\nfloat sdBox( vec3 p)\n{\n  p += vec3(1.0f, 0.5f, 5.0f);\n  vec3 q = abs(p) - 1.;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus(vec3 p, vec2 dimensions)\n{\n    p += vec3(6.0f, 0.5f, 5.0f);\n\treturn length( vec2(length(p.xz)-dimensions.x,p.y) )-dimensions.y;\n}\nfloat sdOctahedron( vec3 p, float s )\n{\n  p += vec3(6.0f, 0.5f, 0.0f); \n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float distToBox = sdBox(samplePoint);\n    float distToSphere = sdSphere(samplePoint);\n    float distToTorus = sdTorus(samplePoint,  vec2(1.3, 0.45));\n    float distToOctahedron = sdOctahedron(samplePoint,  2.0);\n    \n    \n    float minDistance = min(min(distToBox,distToOctahedron), min(distToSphere, distToTorus));\n    \n    return minDistance;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, out float steps,inout float edgeLength) {\n    \n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        edgeLength = min(dist, edgeLength);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        if (dist > edgeLength && edgeLength <= EDGE_THICKNESS ) // Edge hit\n            return 0.0;\n        \n        depth += dist;\n        steps ++;\n        if (depth >= end) {\n            return end;\n        }\n        \n    }\n    return end;\n}\n            \nvec3 EstimateNormal(vec3 point)\n{\n    return normalize(vec3(sceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - sceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n                          sceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - sceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n                          sceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - sceneSDF(vec3(point.x, point.y, point.z - EPSILON))));\n}\n\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 ComputeLighting(vec3 point, vec3 lightDir, vec3 lightColor)\n{\n    vec3 color = vec3(AMBIENT);\n    float intensity = dot(EstimateNormal(point), normalize(lightDir));\n    intensity = ceil(intensity * SHADES) / SHADES;\n    intensity = max(intensity, AMBIENT);\n    color = lightColor * intensity;\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n\n    vec3 lp = vec3(0, 0.5, 10); \n      \n    vec3 eye = vec3(0, 1.5, -10.);\n      \n      \n    float cameraRadius = 20.;\n          \n    eye.x = cameraRadius * cos(iTime / 7.) + lp.x;\n    eye.z = cameraRadius * sin(iTime / 7.) + lp.z; \n    eye.y = cameraRadius * cos(iTime / 7.) + lp.y;\n\n    vec3 dir = camera(eye, lp) * normalize(vec3(uv, -1)); // ray direction\n      \n      \n    \n    float steps = 0.;\n    \n\n    float edgeLength = MAX_DIST;\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST, steps, edgeLength);\n\n\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.94, 0.95, 0.98, 0.0);\n\t\treturn;\n    }\n    \n\n    vec3 hitPoint = eye + (dist * dir);\n\n    vec3 color = vec3(0.0, 0.71, 0.85);\n    vec3 lightDir = vec3(sin(iTime * 2.0) * 6.0, 4.0, sin(iTime * 1.25) * 5.0);\n    \n    color = ComputeLighting(hitPoint, lightDir, color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}