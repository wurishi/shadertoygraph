{"ver":"0.1","info":{"id":"WlXyW8","date":"1596729551","viewed":235,"name":"DG Water marching","username":"DG622","description":"This is my first attempt at a procedural ocean using raymarching and some colour blending (well blue and green), at times it looks good at others not so good. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","water","ocean","undulating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//This code is dervived from the you tube tutorials of the Art of Code aka BigWings\n//and some helpful articles by Inigo Quilez\n//appologies for my comments\n\nfloat N21a (vec2 p){//simple noise 1 dimensional, x and y need to have different multipliers\n    return  fract(sin(p.x*10.0 + p.y * 64.0) *57.0);\n}\n\nfloat smoothNoise (vec2 uv){// this is essentiually a mixing function\n   uv.xy -= iTime*.57;\n    uv*=1.5;\n    //we are going to get the value of the blue at each corner and then interpolate between that\n    \t\t// and a uv point in the cell to get the pattern, lv meaning 'local uv'\n    vec2 lv = fract(uv);//these 2 go together fract giving the fraction and floor the integer of the cells\n    vec2 id = floor(uv);\n   \n   lv = lv * lv *(3. - 2. *lv);//interpolation for dummies video but this is essentially a smoothstep\n    \t\t\t\t\t\t\t//lv = smoothstep ( 0.0, 1.0, fract(uv * 10.0));\n    \n    float bl = N21a(id);//bottom left\n    float br = N21a(id + vec2(1, 0));//bottom right\n    float b = mix( bl, br, lv.x);//so mix them to get the bottom line using the local uv.x              \n    \n    float tl = N21a(id + vec2(0, 1));//top left etc\n    float tr = N21a(id + vec2(1, 1));\n    float t = mix( tl, tr, lv.x);\n       \n    return mix(b, t, lv.y);    \n}\n\nfloat smoothNoise2 (vec2 uv){\n    if(true){//original Perlin set\n    float c;\n      c = smoothNoise(uv*4.);  // So (uv * frequency ) * Amplitude\n    c+= smoothNoise(uv* 8. ) * .5;//add another layer/octave, each time double the frequency \n    \t\t\t\t\t\t\t\t//and halve the amplitude\n    c+= smoothNoise(uv* 16. ) * .25;\n    c+= smoothNoise(uv* 32. ) * .125;\n    c+= smoothNoise(uv* 65. ) * .0625;\n    return c/2.0;\t\t\t//need to divide by a factor to make sure c does not breach 1.0\n    }\n    if(false){//tweaked set\n     float c;\n      c = smoothNoise(uv*4.) * 0.25;  // So (uv * frequency ) * Amplitude\n    c+= smoothNoise(uv* 8. ) * .125;//add another layer/octave, each time double the frequency \n    \t\t\t\t\t\t\t\t//and halve the amplitude\n    c+= smoothNoise(uv* 16. ) * .0625;\n    c+= smoothNoise(uv* 64. ) * .01225;\n    c+= smoothNoise(uv* 125. ) * .01225;\n    return c/2.0;\t\t\t//need to divide by a factor to make sure c does not breach 1.0\n    }\n}\n\nvec2 GetDist (vec3 p, float depth){ \n    //\tfloat v_time = iTime*0.5;   \t\t\t\n    \tfloat wave; \n        vec2 returnVal= vec2(0.0);;\n  \t\tp.xz*=0.03;\n        float dPlane = 0.0;\n        float Mist;\n    //water \t\n    if(depth == 0.0){\n    \twave = sin((p.x+p.z)*0.7751)*1.7351 ;//x direction separate out from z (freq)*amplitude\n \t\twave+=sin(p.x*0.937)*1.773;\n  \t\twave += smoothNoise2(vec2(sin(p.x), sin(p.z)));\n   \t\twave+=smoothNoise2(vec2(sin(p.x+0.13), sin(p.z+0.57)));    \n        dPlane = dot(vec3(p.x,p.y-2.5-wave,p.z), normalize(vec3 (0.0,1.0,0.0)));\n        returnVal.x =dPlane;\n       \n    }else{\n    //mist\n       float Mist = dot(p-vec3(0.0,0.0,-5.0 * depth), normalize(vec3 (0.0,0.0,1.0)));\n      \n        \n        returnVal.x = Mist;\n        returnVal.y = depth;\n        \n        }\n        return returnVal;\n      \t\t\t\t\t\t\t               \n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float depth){\n            vec2 dO = vec2(0.0);\n            \n            for(int i = 0; i < 100; i++){\n                vec3 p = ro + dO.x * rd;\n                vec2  dS = GetDist(p, depth);                      \t\t\n                dO += dS.x;\n                if( dS.x < 0.01 || dO.x > 100.0){\n                    break;\n                    }\n              }   \n          \treturn  dO;                     \n       }\nvec3 GetNormal (vec3 p){\n            vec2 e = vec2(0.01, 0.0);\n            float d = GetDist(p , 0.0).x;          \t          \n            vec3 n = d - vec3(GetDist(p-e.xyy, 0.0).x,GetDist(p-e.yxy, 0.0).x, GetDist(p-e.yyx,0.0).x);           \n            n = normalize(n);\n            return n;           \n       }\n        vec2 GetLight(vec3 p){\n         \tvec3 lightPos = vec3( 0.0, 25.0, 15.0);\n            lightPos.xz += vec2(sin(iTime), cos(iTime));\n            vec3 light = normalize(lightPos - p);\n            vec3 n = GetNormal(p);           \n            vec2 dif = vec2(clamp(dot(n,light), 0.0, 1.0),n);// so no negative numbers, last one just to carry the normal back\n            //for the shadow\n            vec2 d  = RayMarch(p+ n   , light, 0.0);//this adding the n  is a work around            \n            if (d.x < length (lightPos - p )) dif *= 0.1;                                                    \n         dif.y = n.y;\n            return dif;\n        }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;     \n\tvec3 col = vec3(0.0);\n    float Mist1;\n    float Mist2;\n    vec3 RGBblue = vec3(0.05, 0.13, 0.19);\n    vec3 RGBgreen = vec3(0.05, 0.17, 0.35);\n    vec3 RGB = vec3(0.0);\n   // vec3 LightCol = vec3(0.15, 0.1, 0.1);\n    vec3 ro = vec3(15.0 , 15.0 ,-15.0  );\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n    vec2 d = RayMarch(ro,rd,0.0);\t\t//water\t            \n    vec3 p= ro+rd*d.x;\n    vec2 diff = GetLight(p);\n   \tRGB = mix(RGBblue, RGBgreen, smoothstep(0.05, 0.6, diff.y));//mix green and blu via the normal\n    col = vec3(diff.x*RGB );  \n         \n    \n    if(d.x > 100.0)col=vec3(smoothNoise2(uv))*0.5;//vec3(0.1,0.2,0.2);\n    \n     \n       // Mist1 =  RayMarch(ro,rd,1.5).x;\n      //  p = ro + rd*Mist1;\n     //   col*= vec3(smoothNoise2(p.xy));\n       // col*=vec3(GetLight(p).x);\n     //  Mist2 =  RayMarch(ro,rd,2.0).x;\n       \n   \n  \n col*=2.0;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}