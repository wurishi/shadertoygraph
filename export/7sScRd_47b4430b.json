{"ver":"0.1","info":{"id":"7sScRd","date":"1643934173","viewed":154,"name":"Beaming Down Sheep","username":"stegu","description":"All those sheep that are being beamed up by aliens have to be beamed *down* again somewhere, right? This is the place. With an infinite plane of green grass to graze, they seem to be doing fine.\n\nZoom in and out with mouse drags. Click to reset zoom.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["spiral","animation","fibonacci","phyllotaxis","startrek","baa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Teleport in new sheep for this portion of the time,\n    // move flock to make room for more the rest of the time.\n    float beamtime = 0.5;\n    float SPS = 0.5; // Sheep per second\n    \n    float starttime = 0.0; // Increase this to start with some sheep already arrived\n    float sheeptime = starttime+iTime*SPS; // Our preferred time unit is \"1 sheep\"\n    \n    float intN = floor(sheeptime); // Current number of sheep\n    float fracN = (clamp(fract(sheeptime), beamtime, 1.0)-beamtime)/(1.0-beamtime);\n    bool scotty = (fract(sheeptime) < beamtime); // Livestock transport beam active,\n    float fadein = clamp(fract(sheeptime)/beamtime, 0.0, 1.0); // please stand back\n    \n    // Zoom out to fit most of the flock in the viewport as it grows\n    float scale = 1.5*max(4.0, sqrt(sheeptime));\n    float uvscale = 1.0/max(iResolution.x, iResolution.y);\n    vec2 uvcenter = 0.5*iResolution.xy;\n    // Adjust scale by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = pow(0.99,iMouse.y-abs(iMouse.w));\n    vec2 uv = zoom*scale*(uvscale*(fragCoord-uvcenter));\n\n    // This is for frequency clamping of the noise sum for the grass\n\tfloat dP = max(length(dFdx(uv)), length(dFdy(uv)));\n\n    vec2 g, gsum; // To hold gradient from psrdnoise\n    float blend1, blend2; // Blend weights for noise clamping\n    float grassnoise = 0.0;\n    if(dP < 1.0/10.0) {\n\t\tblend1 = smoothstep(10.0, 20.0, 1.0/dP);\n        grassnoise = blend1*psrdnoise(uv*10.0,vec2(0.0), 0.0, gsum);\n        if(dP < 1.0/17.0) {\n            blend2 = smoothstep(17.0, 37.0, 1.0/dP);\n            grassnoise += 0.5*blend2*psrdnoise(uv*17.0-gsum*0.1, vec2(0.0), 0.0, g);\n            if(dP < 1.0/37.0) { // Allow this one to pop in, it's low-contrast\n                gsum += g;\n                grassnoise += 0.25*psrdnoise(uv*37.0-gsum*0.1, vec2(0.0), 0.0, g);\n            }\n        }\n    }\n    vec3 bgcolor = vec3(0.0,0.6+0.1*grassnoise, 0.0);\n\n    // Find the nearest neighbor to uv among the Fibonacci spiral point set\n    vec3 nn = inversePF(uv, intN, fracN);\n\n    float beamnoise, beampattern;\n    vec3 beamcolor;\n    if(nn.z >= intN) {\n        fragColor = vec4(bgcolor, 1.0); // Hide cells with index > intN\n    } else {\n        float sheepnumber = intN-nn.z; // Count the sheep\n        // Mask out discontinuities in local uv (for auto-derivative AA)\n        float mask = 1.0-step(0.77, length(uv-nn.xy)); // Sheep is inside this circle\n        vec2 localuv = vec2(0.5,0.45)+(uv-nn.xy)*0.5; // Scale 2x and reposition\n        localuv.x = (mod(sheepnumber, 2.0) >= 0.5) ? localuv.x : 1.0-localuv.x; // Flip odd sheep\n        vec4 sheepRGBA = sheep(localuv, sheepnumber*vec2(sqrt(3.0), sqrt(5.0)), iTime);\n        vec3 mixcolor = mix(bgcolor, sheepRGBA.rgb, sheepRGBA.a*mask);\n        if(scotty && (nn.z == 0.0)) { // Beam-in visual effect on sheep #0 (\"#N\", but really #0)\n            beamnoise = psrdnoise(localuv*vec2(10.0, 20.0), vec2(0.0), iTime*30.0, g);\n            beamnoise += 0.6*psrdnoise(localuv*vec2(17.0,33.0)+0.1*g, vec2(0.0), iTime*15.0, g);\n            beampattern = aastep(fadein, 0.5+0.5*beamnoise);\n            beamcolor = mix(bgcolor, vec3(1.0,0.0,1.0), beampattern*sheepRGBA.a*mask);\n            mixcolor = mix(beamcolor, mixcolor,\n                (1.0-beampattern)*sheepRGBA.a*mask*clamp(fadein, 0.3, 1.0)); // Ugh, that blend\n        }\n        fragColor = vec4(mixcolor,1.0);\n     }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// Anti-aliased implicit line around v == t, in the spirit of\n// aastep(), with line width w specified in fragment space (pixels)\nfloat aaline(float t, float v, float w) {\n  float fw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n  return smoothstep(t-0.5*w*fw-fw, t-0.5*w*fw+fw, v)\n\t- smoothstep(t+0.5*w*fw-fw, t+0.5*w*fw+fw, v);\n}\n\n// Compute the shortest distance from p to a line segment from p1 to p2.\nfloat lined(vec2 p1, vec2 p2, vec2 p) {\n    vec2 p1p2 = p2 - p1;\n    vec2 v = normalize(p1p2);\n    vec2 s = p - p1;\n    float t = dot(v, s);\n    if (t<0.0) return length(s);\n    if (t>length(p1p2)) return length(p - p2);\n    return length(s - t*v);\n}\n\n// Compute the shortest distance from p to a circle\n// with center at c and radius r.\nfloat circled(vec2 c, float r, vec2 p) {\n    return abs(length(p - c) - r);\n}\n\n// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n#define Phi 0.618033988749895\n\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction)\n\treturn k * Phi - floor(k * Phi);\n}\n\n//\n// Find nearest neighbor in an N-point Fibonacci spiral,\n// not scaled to fit in the unit circle but growing\n// with N to a radius of ~sqrt(N) around the origin.\n// Modified version of the algorithm from the article\n// \"Spherical Fibonacci Mapping\" by Keinert et al,\n// ACM Trans. on Graphics 34 (2015), 6, 193.\n// Ported from HLSL to GLSL by Stefan Gustavson 2021,\n// edited for planar mapping and modified for animation\n// by Stefan Gustavson 2022.\n// This version is Copyright 2022 Stefan Gustavson, released\n// under the terms of the MIT license (\"use freely with\n// credit\"): https://opensource.org/licenses/MIT\n// \n// The vec3 return value has the position of the nearest\n// neighbor in .xy, and its integer index (k) in .z.\n// A gradual blend between configurations with N and N+1\n// points can be achieved by calling the function with\n// intN = floor(t), fracN = fract(t), N <= t < N+1.\n// Indices are numbered from 0 up outwards from the origin.\n// If you want the index to \"follow\" a point as it \"moves\n// outwards\" with an animated N, the index needs to be\n// recomputed as (intN - k). The point set is not limited\n// to N points -- the point returned is the nearest neighbor\n// on the infinite plane, with k as large as it takes.\n// Mask on k if you want to limit the number of cells.\n//\nvec3 inversePF(vec2 p, float intN, float fracN) {\n\tvec3 nn;\n\tfloat theta = min(atan(p.y, p.x), PI); // min() to dodge NaN\n\tfloat r2 = dot(p,p);\n    float i = max(0.0, r2-0.5+fracN);\n    float k = max(2.0, 1.0+floor(log(sqrt(5.0)*PI*(i+0.5))/2.0/log(PHI)));\n\t// F0, F1 are actually faster to compute with pow()\n\t// than by using an array of precomputed values\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 =  floor(Fk * PHI + 0.5);\n    float B0 = fracmodphi(F0);\n    B0 = (B0 > 0.62) ? B0-1.0 : B0;\n    float B1 = fracmodphi(F1);\n    B1 = (B1 > 0.62) ? B1-1.0 : B1;\n\tmat2 B = mat2(2.0*PI*B0, F0,  // Note how simple this B is, compared to\n                  2.0*PI*B1, F1); // the spherical mapping in the reference\n\tmat2 invB = inverse(B);\n    float ctheta = theta + 2.0*PI*fracmodphi(intN);\n    float ci = i + 0.5 + fracN;\n    vec2 c = floor(invB * vec2(ctheta, ci));\n\tfloat dsqmin = 4.0; // Actual min dsq is always less than this\n    float r, dsq;\n    vec2 q;\n\tfor (float s = 0.0; s < 4.0; s++) { // This loop is a little awkward\n\t\ti = dot(vec2(F0, F1),\n\t\t\tvec2(mod(s, 2.0), floor(s*0.5)) + c); // (0,0),(1,0),(0,1),(1,1)\n        i = abs(i); // abs() eliminates some misses near the origin\n        theta = 2.0*PI*fracmodphi(i-intN); // Set theta=0 at index intN\n\t\tr = sqrt(i+0.5+fracN);\n\t\tq = vec2(cos(theta)*r, sin(theta)*r);\n\t\tdsq = dot(p-q, p-q); // Most numerically sound measure\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tnn.xy = q;\n\t\t\tnn.z = i;\n\t\t}\n\t}\n    // The algorithm finds the closest point in the set for fracN=0,\n    // but it has a few glitches close to some Voronoi boundaries\n    // near the origin, where points move around a lot with fracN.\n    // The most blatant error is that we sometimes miss cell 0\n    // near the origin. Let's fix that, because it encroaches on\n    // the useful circular portion of cell 0, but leave the rest.\n    // (Straightening out the loop above and just adding this at\n    // the end would make it less of a \"repeated code\" boo-boo,\n    // but GLSL compilers inline almost everything anyway.)\n    if(r2 < 3.0) {\n        theta = 2.0*PI*fracmodphi(0.0-intN);\n\t\tr = sqrt(0.0+0.5+fracN);\n\t\tq = vec2(cos(theta)*r, sin(theta)*r);\n\t\tdsq = dot(p-q, p-q);\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tnn.xy = q;\n\t\t\tnn.z = 0.0;\n\t\t}\n    }\n    return nn;\n}\n\nvec4 sheep(vec2 uv, vec2 noiseoffset, float time) {\n    // A cartoon-style drawing of a sheep (RGB color and alpha mask).\n    // Copyright 2022 Stefan Gustavson (stefan.gustavson@gmail.com).\n    // This function is released under the MIT license:\n    // https://opensource.org/licenses/MIT\n    //\n    // The sheep is centered at (0.5,0.5), with a body of radius ~ 0.3.\n    // It has a bounding box of approximately (0.15, 0.1, 0.85, 0.85),\n    // and fits inside a circle af radius 0.4 centered at (0.5, 0.45).\n    float r = length(uv-0.5);\n    vec2 g;\n    float rn = r - 0.025*abs(psrdnoise((uv+noiseoffset)*6.0, vec2(0.0), 0.0, g));\n    rn -= 0.012*abs(psrdnoise((uv+noiseoffset)*12.0, vec2(0.0), 0.0, g));\n\n    float sheepbody = 1.0-aastep(0.3, rn);\n    float sheepoutline = aaline(0.3, rn, 2.0);\n    vec2 headpos = vec2(0.62, 0.55);\n    float sheephead = 1.0-aastep(0.1, lined(headpos, headpos+vec2(0.05, -0.08), uv));\n    float sheepleftear = 1.0 - aastep(0.03, \n        lined(headpos+vec2(-0.07, 0.01), headpos+vec2(-0.13, -0.07), uv));\n    float sheeprightear = 1.0 - aastep(0.03, \n        lined(headpos+vec2(0.05, 0.05), headpos+vec2(0.14, 0.03), uv));\n    const vec2 eyepos1 = vec2(-0.01, -0.01);\n    const vec2 eyepos2 = vec2(0.06, 0.01);\n    float sheepeyes = 1.0-aastep(0.03, min(length(uv-vec2(headpos+eyepos1)),\n                                           length(uv-vec2(headpos+eyepos2))));\n    psrdnoise(noiseoffset+time*0.1*vec2(sqrt(3.0), sqrt(5.0)), vec2(0.0), 0.0, g);\n    vec2 sheeplook = 0.003*g; // gaze direction, keep within radius 0.015\n    float sheeppupils = 1.0-aastep(0.015, min(length(uv-vec2(headpos+eyepos1+sheeplook)),\n                                              length(uv-vec2(headpos+eyepos2+sheeplook))));\n    float sheepleg1 = aastep(0.03,lined(vec2(0.45,0.25), vec2(0.43,0.15), uv));\n    float sheepleg2 = aastep(0.03,lined(vec2(0.65,0.25), vec2(0.67,0.15), uv));\n    float sheepfrontlegs = 1.0 - min(sheepleg1, sheepleg2);\n    float sheepleg3 = aastep(0.03,lined(vec2(0.35,0.28), vec2(0.33,0.18), uv));\n    float sheepleg4 = aastep(0.03,lined(vec2(0.55,0.28), vec2(0.57,0.18), uv));\n    float sheephindlegs = 1.0 - min(sheepleg3, sheepleg4);\n    vec3 bgcolor = vec3(0.0); // \"Transparent black\" outside alpha-mask\n    vec3 woolcolor = vec3(1.0); // Snow white - they had a bath in the spaceship\n    vec3 skincolor = vec3(0.0); // Black\n    vec3 sheepcolor;\n    sheepcolor = mix(bgcolor, vec3(0.0), sheephindlegs);\n    sheepcolor = mix(sheepcolor, woolcolor, sheepbody);\n    sheepcolor = mix(sheepcolor, skincolor, sheepfrontlegs);\n    sheepcolor = mix(sheepcolor, skincolor, sheepoutline);\n    sheepcolor = mix(sheepcolor, skincolor, sheepleftear);\n    sheepcolor = mix(sheepcolor, skincolor, sheeprightear);\n    sheepcolor = mix(sheepcolor, skincolor, sheephead);\n    sheepcolor = mix(sheepcolor, vec3(1.0), sheepeyes); // flat white\n    sheepcolor = mix(sheepcolor, vec3(0.0), sheeppupils); // flat black\n    \n    float sheepmask = max(max(sheepbody, sheepoutline), max(sheephindlegs, sheepfrontlegs));\n    sheepmask = max(sheepmask, sheeprightear); // Might poke out for some noise offsets\n    return vec4(sheepcolor, sheepmask);\n}\n","name":"Common","description":"","type":"common"}]}