{"ver":"0.1","info":{"id":"DlffR8","date":"1711739031","viewed":27,"name":"Hitsuono_Raymarch","username":"Hitsuono","description":"Raymarch based on \"The Art of Code\"s great YouTube tutorials.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define MAX_DISTANCE 100.\n#define MAX_STEPS 100\n#define SURFACE_DIST .005\n#define PI 3.141592\n#define TAU 6.283185\n#define SPHERE_CENTER vec3(0.,0.,0.)\n\nconst int MAT1 = 1;\nconst int MAT2 = 2;\n\nmat2 Rot(float a){\n    return mat2(cos(a), -sin(a), \n                sin(a), cos(a));\n}\nmat3 Rot3(float a){\n    return mat3(cos(a), -sin(a), 0,\n                sin(a), cos(a),  0,\n                0     , 0     ,  1);\n}\nfloat maxComp(vec3 v){ return max(v.x, max(v.y, v.z));}\n\n\nfloat sdSphere(vec3 p, float r){\n    return length(p)-r;\n}\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y))-r.y;\n}\nfloat sdBox(vec3 p, vec3 r){\n    vec3 q = abs(p) - r;\n    return length(max(q,0.)) + min(maxComp(q),0.);\n}\nfloat sdRoundBox(vec3 p, vec3 r, float s){\n    vec3 q = abs(p) - r;\n    return length(max(q,0.)) + min(maxComp(q),0.) - s;\n}\nfloat sdLineSegment(vec3 p, vec3 a, vec3 b){\n    vec3 ap = p-a, ab= b-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    vec3 c = a + t* ab;\n    return length (p-c);\n}\n\nvec3 Transform(vec3 p){\n    return p;\n}\n\nvec2 GetDistance(vec3 p){\n    vec4 sphere = vec4(SPHERE_CENTER, 1);\n    float dSphere = sdSphere(p - sphere.xyz, sphere.w);\n    //float dTorus = sdTorus(Rot3(-PI/6.)*(p - vec3(0., 1., 0.)), vec2(1.,0.5));\n    //float dS = sdRoundBox(p, vec3(1.,1.,.5), .5);\n    float dBox = sdBox(p + vec3(2.5,0.,0.) , vec3(1.,1.,5.));\n    dBox += sin(p.z *2.)*.1;\n    dBox=min(dBox, sdSphere(p - sphere.xyz - vec3(2.5,0.,0.), sphere.w));\n    //float dS = sdLineSegment(p, vec3(0.), vec3(0.,2.,2.));\n    \n    //float dP = p.y + 1.;\n    //float d = min (dS, dP);\n    float dS = min(dSphere,dBox);\n    \n    int mat = 0;\n    if(dS == dSphere){\n        mat = MAT1;\n    }\n    else if (dS == dBox ){\n        mat = MAT2;\n    }\n    \n    \n    return vec2(dS, mat);\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDistance(p).x;\n    \n    vec2 e = vec2(0.01,0.);\n    \n    vec3 n = d- vec3(\n        GetDistance(p - e.xyy).x,\n        GetDistance(p - e.yxy).x,\n        GetDistance(p - e.yyx).x);\n    return normalize(n);\n    \n}\n\nvec2 RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    vec2 mat = vec2(0.);\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p = Transform(ro + dO * rd);\n        float dS=GetDistance(p).x;\n        mat = GetDistance(p);\n        dO+=dS;\n        if(dS<SURFACE_DIST || dO>MAX_DISTANCE) break;\n    }\n    return vec2(dO, mat.y);\n}\n\nfloat GetLight(vec3 p){\n    vec3 LightPos = SPHERE_CENTER + vec3(3.,0.,0.);\n    vec3 l = normalize (LightPos - p);\n    float d = dot(l, GetNormal(p));\n    \n    d= clamp(d, 0.01, 1.);\n    \n    vec3 LightPos1 = SPHERE_CENTER + vec3(-3.,0.,0.);\n    vec3 l1 = normalize (LightPos1 - p);\n    float d1 = dot(l1, GetNormal(p));\n    \n    d1=clamp(d1,0.01,1.);\n    \n    float r = d + d1;\n    //Shadows\n    float dif = RayMarch(p + GetNormal(p) *SURFACE_DIST*20., l).x;\n    float dif2 = RayMarch(p + GetNormal(p) *SURFACE_DIST*20., l1).x;\n    if (dif < length(LightPos-p)) d *= .5;\n    if (dif2 < length(LightPos1-p)) d1 *= .5;\n\n    return  max(d1, d) + .5;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref){\n\n//col = vec3(GetLight(p));\n    /*\n    col = vec3(GetLight(p) * 0.7, 0.*GetLight(p), 0.*GetLight(p));\n\n    if(sdSphere(p - vec3(0., 0., 0.), 1.) < 0.01){\n        col = length(GetLight(p)) * normalize(vec3(0.,1.,0.) + 1.5 * col);\n    }\n    */\n    vec3 p = ro + RayMarch(ro,rd).x * rd;\n    vec3 col = texture(iChannel2, rd).rgb;\n    vec3 n = vec3(0.);\n    ref = vec3(0.);\n\n    if (RayMarch(ro,rd).x< MAX_DISTANCE){\n        p = Transform(p);\n        n = GetNormal(p);\n           \n        float dif = dot(n, normalize(vec3(1.,2.,3.)))*.5;\n        float fresnel = 1. - dot(n, -rd);\n        /*\n        n*= pow(n, vec3(30.));\n        n/=n.x+n.y+n.z;\n        \n\n        vec3 colXZ=texture(iChannel0, p.xz * .5 + .5).rgb;\n        vec3 colXY=texture(iChannel0, p.xy * .5 + .5).rgb;\n        vec3 colYZ=texture(iChannel0, p.yz * .5 + .5).rgb;\n\n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n        \n        uv = vec2(atan(p.x, p.z)/TAU, 2. * p.y/3.) + 0.5;\n        uv.x -= iTime * 0.1;\n        vec4 cats = texture(iChannel1, uv);\n        cats.a *= smoothstep(.6, .5, abs(p.y));\n        \n        col = mix(col, cats.rgb, cats.a);\n        */\n        vec3 rm = reflect(rd, n);\n        //vec3 ref = texture(iChannel2, rm).rgb;\n        col = vec3(dif);\n        \n        if (RayMarch(ro,rd).y == 2.){\n            col = vec3(.1*dif);\n            ref = vec3(.9);\n            //col = fresnel * vec3(0.,0.,1.);\n        }\n        else if(RayMarch(ro,rd).y == 1.){\n            col = vec3(.1 * dif);\n            ref = vec3(1.,1.,1.);\n        }\n        \n        ro = p + n * SURFACE_DIST * 3.;\n        rd = rm;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * R)/R.y;\n    vec2 m = iMouse.xy/R;\n\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0., 1., -6.);\n    float original = ro.y;\n    vec3 orro = ro;\n    ro.yz *= Rot(-m.y * PI + 1.);\n    ro.xz *= Rot(-m.x * TAU);\n    \n    //if(ro.y<-1.) ro=orro;\n\n    vec3 rd = GetRayDir(uv, ro, SPHERE_CENTER, 1.);\n    //vec3 rd = normalize( vec3(uv.x, uv.y, 1.) );\n    \n    vec3 ref = vec3(.0);\n    vec3 fill = vec3(1.);\n\n    const int REFL_NUM = 7;\n    for (int i = 0; i < REFL_NUM; i++){\n        vec3 bounce = fill*Render(ro, rd, ref);\n        fill *= ref;\n        col += bounce;\n    }\n    \n    \n    \n    col = pow(col, vec3(.6));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}