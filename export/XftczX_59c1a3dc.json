{"ver":"0.1","info":{"id":"XftczX","date":"1730960769","viewed":79,"name":"Ethereal Whispers 1","username":"darrinm","description":"Made with https://hatch.one","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["hatch","ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made with Hatch.one\n// License: MIT\n\n/* https://hatch.one uniforms.\nuniform float speed; // default: 1.0, min: 0.1, max: 5.0, step: 0.1, title: \"Color Speed\"\nuniform float waves; // default: 10.0, min: 1.0, max: 50.0, step: 1.0, title: \"Number of Waves\"\nuniform float direction; // default: 0.0, min: 0.0, max: 360.0, step: 1.0, title: \"Direction\"\nuniform float mouseInfluence; // default: 0.5, min: 0.0, max: 1.0, step: 0.01, title: \"Mouse Influence\"\nuniform float waveHeight; // default: 0.5, min: 0.0, max: 2.0, step: 0.1, title: \"Wave Height\"\nuniform float metallic; // default: 0.5, min: 0.0, max: 1.0, step: 0.01, title: \"Metallic\"\nuniform vec4 baseColor; // default: #4411ff, type: Color, title: \"Base Color\"\n*/\n\n#define speed 1.0\n#define waves 10.0\n#define direction 305.\n#define mouseInfluence 0.5\n#define waveHeight .5\n#define metallic 0.5\n#define baseColor vec4(0.267, 0.067, 1.0, 1.0)\n\n// Function to get height at a point\nfloat getHeight(vec2 uv) {\n    // Calculate direction\n    float angle = direction * 3.14159 / 180.0;\n    float x = uv.x * cos(angle) + uv.y * sin(angle);\n    \n    // Get normalized mouse position\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    //if (iMouse.z <= 0.0) mouse = vec2(0.5);\n    \n    // Calculate distance from current pixel to mouse\n    float distToMouse = distance(uv, mouse);\n    float mouseWave = sin(distToMouse * 10.0) * mouseInfluence;\n    \n    // Create base wave pattern\n    return sin(iTime * speed + x * waves + mouseWave) * waveHeight;\n}\n\n// Function to calculate surface normal from heightmap\nvec3 getNormal(vec2 uv, float height, float eps) {\n    vec2 e = vec2(eps, 0.0);\n    float h = height;\n    float hx = getHeight(uv + e.xy) - getHeight(uv - e.xy);\n    float hy = getHeight(uv + e.yx) - getHeight(uv - e.yx);\n    return normalize(vec3(-hx, -hy, eps * 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Get height at this point\n    float h = getHeight(uv);\n    \n    // Calculate normal for lighting\n    vec3 normal = getNormal(uv, h, 0.01);\n    \n    // Light direction (animated)\n    vec3 lightDir = normalize(vec3(cos(iTime * 0.5), sin(iTime * 0.5), 1.0));\n    \n    // Basic lighting calculation\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    \n    // Specular reflection\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    \n    // Create base color with height influence\n    vec3 color = baseColor.rgb;\n    \n    // Add lighting\n    vec3 ambient = color * 0.2;\n    vec3 diffuseColor = color * diffuse;\n    vec3 specColor = mix(vec3(1.0), color, metallic) * spec;\n    \n    // Combine all lighting components\n    vec3 finalColor = ambient + diffuseColor + specColor;\n    \n    // Add subtle height-based color variation\n    finalColor *= 1.0 + h * 0.2;\n    \n    // Output final color\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}