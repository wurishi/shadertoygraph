{"ver":"0.1","info":{"id":"WlSczG","date":"1594655418","viewed":67,"name":"RayTracinggg","username":"Amirh","description":"Raytracing learning attempt","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    float camPosition;\n} camera;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;\n} sphere;\n\nstruct Light\n{\n    vec3 direction;\n    \n} light;\n\nstruct Material\n{\n    float diffuse;\n    float ambient;\n    float specular;\n    float shine;\n    \n} material;\n\nvoid setupScene()\n{    \n    camera.position = vec3(0.0, 0.0, 3.5);\n    camera.direction = vec3(0.0, 0.0, -1.0);\n    camera.camPosition = 2.6;\n    \n    sphere.position = vec3(0.0, 0.0, 2.5);\n    sphere.radius = 0.2;\n    sphere.color = vec3(0.3, 0.5, 0.3);\n   \n    light.direction = normalize(vec3(0.0, -1.0, -0.78));\n    \n    material.ambient = 0.3;\n    material.diffuse = 0.7;\n    material.specular = 1.0;\n    material.shine = 8.0;\n}\n\nbool solveQuadratic( float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b*b - 4.0 * a * c;\n    \n    if (disc < 0.0)\n    {\n        return false;\n    }\n    if (disc == 0.0)\n    {\n        float t0 = -b / ( 2.0 * a);\n        return true;\n    }\n    t0 = (-b + sqrt(disc)) / (2.0 * a);\n    t1 = (-b - sqrt(disc)) / (2.0 * a);\n     return true;\n    \n}\n\nbool intersect(vec3 direction, out vec3 surfaceNormal)\n{\n    vec3 L = camera.position - sphere.position;\n    \n    float a = dot(direction, direction); // 1\n    float b = 2.0 * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.0);\n    \n    float t0;\n    float t1;\n    \n    if ( solveQuadratic( a, b, c, t0, t1))\n        {\n          float t = t0;\n          if( t1 < t0)\n           {\n              t = t1;\n           }\n            \n           vec3 Phit = camera.position + t * direction;\n            surfaceNormal = normalize( Phit - sphere.position);\n            \n    \treturn true;\n       \t}\n    return false;\n}\n\nvec3 rayTrace( vec3 direction )\n{\n    vec3 surfaceNormal;\n   \n    if(intersect(direction, surfaceNormal))\n    {\n      float    coeff = -dot(light.direction, surfaceNormal);\n        \n      vec3 reflectRay = reflect(direction, surfaceNormal);\n      vec3 reflectColor = texture(iChannel0, reflectRay).rgb;\n      sphere.color = mix(sphere.color, reflectColor, material.specular);\n      \n      vec3 ambient = material.ambient * sphere.color;\n      vec3 diffuse = material.diffuse *  max(coeff, 0.0) * sphere.color;\n      float shine  =  pow(max(-dot( direction, reflect(light.direction, surfaceNormal)), 0.), material.shine);\n      vec3 specular = material.specular * shine * sphere.color;\n      \n      return ambient + diffuse + specular;\n    }\n    \n    return texture(iChannel0, direction).rgb;;\n}\n\n\n\n//This function gets called for every pixel on screen\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    setupScene();\n    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    vec3 direction = normalize(vec3(uv, camera.camPosition) - camera.position);\n    \n     light.direction.x = -(iMouse.x / iResolution.x - 0.5);\n     light.direction.y = -(iMouse.y / iResolution.y - 0.5);\n     light.direction = normalize(light.direction);\n    \n    \n    sphere.color = rayTrace(direction);\n    \n    //cubemap code\n    vec3 col = rayTrace(direction);\n    \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}