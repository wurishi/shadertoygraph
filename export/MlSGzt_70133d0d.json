{"ver":"0.1","info":{"id":"MlSGzt","date":"1431354099","viewed":361,"name":"Tutorial 2D Triangle Wave","username":"DavidBraun","description":"tutorial, 2d, wave, signal","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","wave","tutorial","signal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We will start out a little abstract and come back to this.\n    float signal = uv.y;\n        \n    if (sin(iTime*1.0) > 0.) {\n        // This section is the trickiest. Read this last.\n        // modify our signal using a signal based on uv.x\n        signal += sin(iTime*1.0)*.03*(abs(2.0*mod(uv.x*30.0+iTime,1.)-1.)-.5);\n    }\n        \n    // uv.y goes from 0 to 1, but saw goes from 0 to 1 20.0 times\n    float saw = mod(signal*20., 1.);\n    \n    // tri goes from (1 to 0 to 1) 20.0 times;\n    float tri = abs(2.0*saw-1.0);\n    \n    // convert tri into a meaningful number from 0 to 1\n    // shaderific.com/glsl-functions/\n    float f = smoothstep(0.8, 0.95, tri);\n    \n    // I have a habit of calling things factor:\n    // circleFactor, lineFactor, rectFactor\n    // Sometimes I just write f\n    // I use factors as \"masks\" in photoshop terms.\n    // I also often multiply masks, but you can use other\n    // compositing ideas like taking the minimum of two masks.\n    \n    // a gradient\n    vec3 colorA = vec3(uv.x, uv.y, 1.0);\n    \n  \t// a solid color\n    vec3 colorB = vec3(1., 1., 0.);\n    \n    // mix the colors according to our factor\n    vec3 c = mix(colorA, colorB, f);\n    \n\tfragColor = vec4(c,1.0);\n}","name":"","description":"","type":"image"}]}