{"ver":"0.1","info":{"id":"dsKBD3","date":"1698737223","viewed":11,"name":"WIP: Simple [SLOW] Raster-Render","username":"definecindyconst","description":"Tries to implement the crucial steps of the render pipeline but entirely within the fragment shader that we have access to here lol.\n\nI'm yet to implement most primitives, and haven't added a model system for stateful physics yet... but maybe soon?","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["wip","renderpipeline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Credit: I used https://www.shadertoy.com/view/XdlGzn as inspiration for this.\n//         I found https://www.songho.ca/opengl/ very helpful for understanding vertex projections throughout a rendering pipeline.\n\nVertex GetVertex(in int vidx) {\n  return SampleVertex(iChannel0, vidx);\n}\n\nPrimitive GetPrimitive(in int pidx) {\n  return SamplePrimitive(iChannel0, pidx);\n}\n\nvoid Draw(inout vec4 color, inout float minz, in float z, in vec2 uv) {\n  if (z > minz && z < 0.) {\n    minz = z;\n    color = vec4(uv, 0, 1);  // TODO: shade\n  }\n}\n\n// Accepts a screen space coordinate and three (CC-oriented) vertices.\n// Returns TRUE if this pixel should render this triangle.\n// Sets the uv sample and depth value IFF this function returns true.\n// EXPECTS that the vertices are in screen space (where z is the **inverted** depth)\nbool RasterizeTriangle(out float z, out vec2 uv, in vec2 fragCoord, in Vertex v0, in Vertex v1, in Vertex v2) {\n  vec2 p0 = v0.coord.xy, p1 = v1.coord.xy, p2 = v2.coord.xy;\n  vec3 inv_z = vec3(v0.coord.z, v1.coord.z, v2.coord.z);\n  \n  // Sub areas\n  vec3 sa = vec3(cross2d(p1 - p0, fragCoord - p0),\n                 cross2d(p2 - p1, fragCoord - p1),\n                 cross2d(p0 - p2, fragCoord - p2));\n  \n  // Boundary check.\n  if (any(greaterThan(sa, ZERO.xyz))) return false;\n  \n  // Barycentric coords.\n  vec3 ba = sa.yzx / (sa.x + sa.y + sa.z);\n  \n  // Barycentric interp.\n  z = 1.0 / dot(ba, inv_z);\n  uv = z*(mat3(v0.uv, 0.0,\n               v1.uv, 0.0,\n               v2.uv, 0.0) * ba).xy;\n                  \n  return true;\n}\n\nvoid DrawTriangles(inout vec4 color, inout float minz, in Primitive p, in vec2 fragCoord) {\n  for (int vidx = p.start; vidx < p.end - 2;) {\n    float z; vec2 uv;\n    if (RasterizeTriangle(z, uv, fragCoord, GetVertex(vidx++), GetVertex(vidx++), GetVertex(vidx++)))\n      Draw(color, minz, z, uv);\n  }\n}\n\nvoid DrawTriangleStrip(inout vec4 color, inout float minz, in Primitive p, in vec2 fragCoord) {\n  float z; vec2 uv;\n  int vidx = p.start;\n  Vertex v0 = GetVertex(vidx++), v1 = GetVertex(vidx++), v2, v3;\n  \n  while (vidx < p.end - 1) {\n    v2 = GetVertex(vidx++); v3 = GetVertex(vidx++);\n    if (RasterizeTriangle(z, uv, fragCoord, v0, v1, v2)) Draw(color, minz, z, uv);\n    if (RasterizeTriangle(z, uv, fragCoord, v2, v1, v3)) Draw(color, minz, z, uv);\n    v0 = v2; v1 = v3;\n  }\n  \n  if (vidx < p.end) {\n    if (RasterizeTriangle(z, uv, fragCoord, v0, v1, GetVertex(vidx))) Draw(color, minz, z, uv);\n  }\n}\n\nvoid FragmentShader(out vec4 color, in vec2 fragCoord) {\n  color = ZERO;\n  float minz = -1.0/0.0;\n  \n  Primitive p;\n  for (int idx = 0; IsValid(p = GetPrimitive(idx)); ++idx) {\n    switch(p.type) {\n      #ifdef ENABLE_POINT\n      case PRIMITIVE.POINT:\n        // NYI\n        break;\n      #endif\n      #ifdef ENABLE_LINE\n      case PRIMITIVE.LINE:\n        // NYI\n        break;\n      #endif\n      #ifdef ENABLE_LINE_STRIP\n      case PRIMITIVE.LINE_STRIP:\n        // NYI\n        break;\n      #endif\n      #ifdef ENABLE_LINE_LOOP\n      case PRIMITIVE.LINE_LOOP:\n        // NYI\n        break;\n      #endif\n      #ifdef ENABLE_TRIANGLE\n      case PRIMITIVE.TRIANGLE: DrawTriangles(color, minz, p, fragCoord);\n        break;\n      #endif\n      #ifdef ENABLE_TRIANGLE_STRIP\n      case PRIMITIVE.TRIANGLE_STRIP: DrawTriangleStrip(color, minz, p, fragCoord);\n        break;\n      #endif\n      #ifdef ENABLE_TRIANGLE_FAN\n      case PRIMITIVE.TRIANGLE_FAN:\n        // NYI\n        break;\n      #endif\n    }\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // === FRAGMENT SHADING ===\n    FragmentShader(fragColor, fragCoord);\n}\n\n\n\n\n/* === GRAVEYARD ===\n\n// Convenience checks on a primitive type:\nbool IsControlType(int type) {\n  return type == PRIMITIVE.TERMINATION || type == PRIMITIVE.CONTINUATION;\n}\n\n// This is WAY too slow :(\nvoid FragmentShader(out vec4 color, in vec2 fragCoord) {\n    color = ZERO;\n    float minz = -1.0/0.0;\n    Vertex v0, v1, v2;\n    int state = PRIMITIVE.TERMINATION, vidx = -1;\n    \n    do {\n      float z;\n      vec2 uv;\n      \n      // Start of a new primitive.\n      if (state == PRIMITIVE.TERMINATION) {\n        v0 = vertices[++vidx]; \n        \n        if (IsControlType(v0.type)) continue;  // Unexpected control value, skip.\n        if (v0.type == PRIMITIVE.POINT) {\n          // Special case for the only single-vertex primitive.\n          // TODO: impl.\n          continue;\n        }\n        \n        // All other primitives need a second vertex.\n        v1 = vertices[++vidx];  if(!IsControlType(v1.type)) { --vidx; continue; }\n        state = v0.type;\n      }\n      \n      // NOTE: Most cases start by setting state to TERMINATION s.t. early exits default to starting a new primitive.\n      //       Additionally, most error cases decrement vidx to re-interpret the vertex.\n      switch (state) {\n        case PRIMITIVE.TRIANGLE: {\n          state = PRIMITIVE.TERMINATION;\n        \n          if (v1.type != PRIMITIVE.CONTINUATION) { --vidx; break; }\n          v2 = vertices[++vidx];  if (v2.type != PRIMITIVE.TERMINATION) { --vidx; break; }\n          if (RasterizeTriangle(z, uv, fragCoord, v0, v1, v2)) {\n            Draw(color, minz, z, uv);\n          }\n          \n          break;\n        }\n        \n        case PRIMITIVE.TRIANGLE_STRIP: {\n          state = PRIMITIVE.TERMINATION;\n        \n          if (v1.type != PRIMITIVE.CONTINUATION) { --vidx; break; }\n          v2 = vertices[++vidx];  if (!IsControlType(v2.type)) { --vidx; break; }\n          if (RasterizeTriangle(z, uv, fragCoord, v0, v1, v2)) {\n            Draw(color, minz, z, uv);\n          }\n          if (v2.type == PRIMITIVE.TERMINATION) break;\n          \n          v0 = vertices[++vidx];  if (!IsControlType(v0.type)) { --vidx; break; }\n          if (RasterizeTriangle(z, uv, fragCoord, v2, v1, v0)) { // NB: reverse winding\n            Draw(color, minz, z, uv);\n          }\n            \n          if (v0.type == PRIMITIVE.TERMINATION) break;\n          \n          state = PRIMITIVE.TRIANGLE_STRIP;\n          v1 = v0;\n          v0 = v2;\n          break;\n        }\n      }\n    } while (vidx < N_VERT);\n}\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// NOTE: Each primitive type that is enabled costs performance.\n//       Disabling un-needed primitives can boost frames!\n//#define ENABLE_POINT;\n//#define ENABLE_LINE;\n//#define ENABLE_LINE_STRIP;\n//#define ENABLE_LINE_LOOP;\n#define ENABLE_TRIANGLE;\n#define ENABLE_TRIANGLE_STRIP;\n//#define ENABLE_TRIANGLE_FAN;\n\nconst int MAX_VERT = 1 << 6;\nconst int MAX_GEO  = 1 << 6;\n\nconst vec4 ZERO = vec4(0);\nconst vec4 ONE = vec4(1);\nconst ivec4 iZERO = ivec4(0);\nconst float PI = 3.14159265359;\n\n// === RASTER ABSTRACTIONS ===\n\nconst struct PrimitiveTypes {\n  int INVALID;         // Invalid state.\n  int POINT;           // NYI\n  int LINE;            // NYI\n  int LINE_STRIP;      // NYI\n  int LINE_LOOP;       // NYI\n  int TRIANGLE;        // Disjoint sets of 3 vertices form a triangle.\n  int TRIANGLE_STRIP;  // Every 3 adjacent vertices forms a triangle, winding alternates for each triangle.\n  int TRIANGLE_FAN;    // NYI\n} PRIMITIVE = PrimitiveTypes(0, 1, 2, 3, 4, 5, 6, 7);\n\nstruct Primitive {\n  // The type of the primitive (see above).\n  int type;\n  \n  // Vertex start (inclusive) and end (exclusive).\n  int start;\n  int end;\n};\n\nbool IsValid(in Primitive p) {\n  return p.type != PRIMITIVE.INVALID;\n}\nconst Primitive INVALID_PRIMITIVE = Primitive(0, 0, 0);\n\nstruct Vertex {\n  // This vertex is only valid if true.\n  bool valid;\n  \n  // The coordinate of this vertex (in object-space).\n  vec3 coord;\n  \n  // The UV coordinate of this vertex.\n  vec2 uv;\n  \n  // The index of the model instance this vertex is part of.\n  // TODO: uint model_idx;\n};\nVertex MakeVertex(in vec3 coord, in vec2 uv) {\n  return Vertex(true, coord, uv);\n}\n\nbool IsValid(in Vertex v) {\n  return v.valid;\n}\nconst Vertex INVALID_VERTEX = Vertex(false, ZERO.xyz, ZERO.xy);\n\n// === DATA MODEL ===\n\n// Returns the upper-left pixel for storing data corresponding to `idx`.\nivec2 BaseCoord(in ivec2 res, in int idx) {\n  // Currently we index 2x2 pixel chunks.\n  int halfX = res.x >> 1;\n  return ivec2(idx % halfX, idx / halfX) << 1;\n}\n\nint Index(in vec3 res, in ivec2 iCoord) {\n  // Returns the index of the data chunk this pixel belongs to.\n  ivec2 halfCoord = iCoord >> 1;\n  return halfCoord.x + halfCoord.y*(int(res.x) >> 1);\n}\n\n// INTERNAL: Samples a vertex relative to a data chunk base coord.\nVertex _SampleVertex(in sampler2D tex, in ivec2 base) {\n  Vertex v;\n  vec4 enc1 = texelFetch(tex, base, 0);\n  vec4 enc2 = texelFetchOffset(tex, base, 0, ivec2(1, 0));\n  \n  v.valid = bool(enc1.w);\n  v.coord = enc1.xyz;\n  v.uv = enc2.xy;\n  return v;\n}\n\n// Reads the vertex data stored in the data chunk this pixel belongs to.\n// EXPECTS that (iCoord.y % 2) == 0.\nVertex SampleVertex(in sampler2D tex, in ivec2 iCoord) {\n  ivec2 base = (iCoord >> 1) << 1;\n  return _SampleVertex(tex, base);\n}\n\n// Reads the vertex specified by `vidx` from the given texture.\n// EXPECTS that vertex data is encoded via `EncodeVertex` into rows where (y%2==0).\nVertex SampleVertex(in sampler2D tex, in int vidx) {\n  ivec2 base = BaseCoord(textureSize(tex, 0), vidx);\n  return _SampleVertex(tex, base);\n}\n\n// Encodes the given vertex into a vec4 color relevant to this coord.\n// EXPECTS that (iCoord.y % 2 == 0).\nvec4 EncodeVertex(in Vertex v, in ivec2 iCoord) {\n  if (iCoord.x % 2 == 0) {\n    return vec4(v.coord, float(v.valid));\n  } else {\n    return vec4(v.uv, 0, 0);\n  }\n}\n\n// Reads the primitive specified by `pidx` from the given texture.\n// EXPECTS that primitive data is encoded via `EncodePrimitive` into pixels where (x%2 == 0 && y%2==1).\nPrimitive SamplePrimitive(in sampler2D tex, in int pidx) {\n  ivec2 base = BaseCoord(textureSize(tex, 0), pidx);\n  \n  Primitive p;\n  ivec4 enc = floatBitsToInt(texelFetchOffset(tex, base, 0, ivec2(0, 1)));\n  p.type = enc.x;\n  p.start = enc.y;\n  p.end = enc.z;\n  \n  return p;\n}\n\n// Enocdes the given primitive into a vec4 color relevant to this coord.\n// EXPECTS that (iCoord.y % 2 == 1 && iCoord.x % 2 == 0).\nvec4 EncodePrimitive(in Primitive p, in ivec2 iCoord) {\n  return vec4(intBitsToFloat(ivec3(p.type, p.start, p.end)), 0);\n}\n\n// === VIEW ABSTRACTIONS ===\n\nstruct Camera {\n  // Position in world space.\n  vec3 pos;\n  \n  // NB: up and look are both **normalized** and **orthogonal**.\n  // Look vector (direction the camera is looking, normal to the screen).\n  vec3 look;\n  // Up vector (represents the +Y direction of the screen space).\n  vec3 up;\n  \n  // Ratio 2n/w where n is near plane distance and w is the viewport width.\n  float zoom;\n};\n\nconst ivec2 CAMERA_OFFSET = ivec2(0, 0);\nCamera SampleCamera(in sampler2D tex) {\n  Camera cam;\n  vec4 enc = texelFetchOffset(tex, ivec2(0, 0), 0, CAMERA_OFFSET);\n  cam.pos = enc.xyz;\n  cam.zoom = enc.w;\n  cam.look = texelFetchOffset(tex, ivec2(0, 1), 0, CAMERA_OFFSET).xyz;\n  cam.up = texelFetchOffset(tex, ivec2(0, 2), 0, CAMERA_OFFSET).xyz;\n  \n  return cam;\n}\n\nvec4 EncodeCamera(Camera cam, in ivec2 iCoord) {\n  ivec2 shift = iCoord - CAMERA_OFFSET;\n  if (shift.x == 0) {\n    if (shift.y == 0) return vec4(cam.pos, cam.zoom);\n    if (shift.y == 1) return vec4(cam.look, 0);\n    if (shift.y == 2) return vec4(cam.up, 0);\n  }\n  \n  return ZERO;\n}\n\n// Returns a translation matrix applying the given vector offset.\nmat4 Translation(in vec3 offset) {\n  const vec4 tmp = vec4(ZERO.xyz, 1);\n  return mat4(tmp.wxyz,\n              tmp.xwyz,\n              tmp.xywz,\n              offset, 1);\n}\n\n// Returns a rotation matrix for the given Euler angles.\n// The order of rotation is Pitch->Yaw->Roll (Rz*Ry*Rx)\n// NB: The \"facing\" direction is +Z, we take Y-axis as yaw, and X-axis as pitch.\nmat3 Rotation(in vec3 angles) {\n  vec3 s = sin(angles);\n  vec3 c = cos(angles);\n  \n  vec3 circ = s.xyz * c.yzx;  // product with circular shift of cosines\n  \n  return mat3(c.y*c.z,              c.y*s.z,               -s.y,\n              s.x*circ.y - circ.z,  s.x*s.y*s.z + c.x*c.z, circ.x,\n              c.x*circ.y - s.x*s.z, s.y*circ.z - s.x*c.z,  c.x*c.y);\n}\n\n// Given a camera, returns the view matrix mapping world-space -> view-space.\n// NOTE: This is essentially the _inverse_ transform needed to place the camera where it is.\nmat4 ViewMatrix(in Camera cam) {\n  // The math here is a bit easier with a target-centric forward vector, rather than camera look.\n  vec3 forward = -cam.look;\n  vec3 left = cross(cam.up, forward);\n  \n  // NB: mat4 extends the matrix with the last row of the I4.\n  return mat4(\n    mat4x3(left.x, cam.up.x, forward.x,\n           left.y, cam.up.y, forward.y,\n           left.z, cam.up.z, forward.z,\n           dot(left, -cam.pos), dot(cam.up, -cam.pos), dot(forward, -cam.pos)));\n}\n\n// === UTILITY ===\n\nfloat cross2d(in vec2 a, in vec2 b) {\n  return cross(vec3(a, 0.0), vec3(b, 0.0)).z;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Vertex vertices[MAX_VERT];\nint N_VERT = 0;\n\nPrimitive primitives[MAX_GEO];\nint N_GEO = 0;\n\nvoid PushQuad(vec3 tl, vec3 ll, vec3 lr, vec3 tr) {\n  int start = N_VERT;\n  vertices[N_VERT++] = MakeVertex(ll, vec2(0, 0));\n  vertices[N_VERT++] = MakeVertex(lr, vec2(1, 0));\n  vertices[N_VERT++] = MakeVertex(tl, vec2(0, 1));\n  vertices[N_VERT++] = MakeVertex(tr, vec2(1, 1));\n  \n  primitives[N_GEO++] = Primitive(PRIMITIVE.TRIANGLE_STRIP, start, N_VERT);\n}\n\nvoid init_geometry() { \n  // === TEST GEO ===\n  vertices[0] = MakeVertex(vec3(-1, -1, -1), vec2(0, 0));\n  vertices[1] = MakeVertex(vec3( 1, -1, -1), vec2(1, 0));\n  vertices[2] = MakeVertex(vec3(-1, -1,  1), vec2(0, 1));\n  vertices[3] = MakeVertex(vec3( 1, -1,  1), vec2(1, 1));\n  vertices[4] = MakeVertex(vec3(-1, -1,  1), vec2(0, 1));\n  vertices[5] = MakeVertex(vec3( 1, -1, -1), vec2(1, 0));\n  vertices[6] = MakeVertex(vec3(-1, -1,  1), vec2(0, 0));\n  vertices[7] = MakeVertex(vec3( 1, -1,  1), vec2(0, 1));\n  vertices[8] = MakeVertex(vec3(-1,  0,  1), vec2(1, 0));\n  vertices[9] = MakeVertex(vec3( 1,  0,  1), vec2(1, 1));\n  N_VERT = 10;\n  \n  primitives[0] = Primitive(PRIMITIVE.TRIANGLE, 0, 6);\n  primitives[1] = Primitive(PRIMITIVE.TRIANGLE_STRIP, 6, 10);\n  N_GEO =    2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iCoord = ivec2(fragCoord);\n\n    // TODO: Make once-init pattern work...?\n    //       As-is, this is equivalent to recomputing all vertices/primitives on each pixel each frame :(\n    if (false) {\n      fragColor = texelFetch(iChannel0, iCoord, 0);\n    } else {\n      int idx = Index(iResolution, iCoord);\n      \n      init_geometry();\n      \n      if (iCoord.y % 2 == 0) {\n        if (idx >= N_VERT) discard;\n      \n        fragColor = EncodeVertex(vertices[idx], iCoord);\n      } else {\n        if (idx >= N_GEO) discard;\n      \n        fragColor = EncodePrimitive(primitives[idx], iCoord);\n      }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Accepts a world space vertex, and projects into view space.\nvoid ToViewSpace(inout Vertex v, in mat4 view_matrix) {\n  v.coord = (view_matrix * vec4(v.coord, 1.0)).xyz;\n}\n\n// Accepts a view space vertex, and projects into clip space.\n// NOTE: v.coord.z is stored as its inverse.\nvoid ToClipSpace(inout Vertex v, float zoom, float aspect_ratio) {\n  // Standard clip matrix (row-major):\n  //   ( n/r   0      0           0       )\n  //   (  0   n/t     0           0       )\n  //   (  0    0  (f+n)/(n-f)  2fn/(n-f)  )\n  //   (  0    0      -1          0       )\n  // n:= near plane dist, f:= far plane dist, r:= w/2, t:= h/2\n  // Let a:= w/h (aspect ratio),\n  //      -> r/t = a.\n  // Observe that r = O(n), t = O(n).\n  // If we take n/r = s -> n/r*r/t = s*a -> n/t = s*a\n  // Now consider n -> 0 (no near plane clipping), f -> inf (no far plane clipping).\n  // =>( s   0   0   0 )\n  //   ( 0  sa   0   0 )\n  //   ( 0   0   -1  ? )\n  //   ( 0   0   -1  0 )\n  // => x' = sx, y' = say\n  // => s is a scaling factor -> zoom\n\n  v.coord.z = 1.0/v.coord.z;\n  v.coord.xy *= zoom*vec2(1, aspect_ratio) * -v.coord.z;  // -1/z perspective scaling.\n  v.uv *= v.coord.z;\n}\n\n// Accepts a clip space vertex, and projects into screen space.\n// NOTE: v.coord.z is left as-is (inverted depth).\nvoid ToScreenSpace(inout Vertex v, in vec2 res) {\n  v.coord.xy += 1.0;\n  v.coord.xy *= 0.5*res;\n}\n\nvoid VertexShader(inout Vertex v, in Camera cam, in vec3 res) {\n  mat4 view_matrix = ViewMatrix(cam);\n  ToViewSpace(v, view_matrix);\n  ToClipSpace(v, cam.zoom, res.x/res.y);\n  ToScreenSpace(v, res.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iCoord = ivec2(fragCoord);\n    \n    #if 0 /*test camera code*/\n    float th = mix(-.3, .1, sin(iTime));\n    Camera cam = Camera(/*pos=*/vec3(0, -.5, -2),\n                        /*look=*/vec3(0, sin(th), abs(cos(th))),\n                        /*up=*/vec3(0, abs(cos(th)), -sin(th)),\n                        /*zoom=*/1.0);\n    #endif\n    \n    Camera cam = SampleCamera(iChannel1);\n    \n    if (iCoord.y % 2 == 0) {\n      Vertex v = SampleVertex(iChannel0, iCoord);\n      \n      // Only shade valid vertices.\n      if (!IsValid(v)) discard;\n      \n      VertexShader(v, cam, iResolution);\n      fragColor = EncodeVertex(v, iCoord);\n    } else {\n      // Don't need to \"shade\" the non-vertex data, just copy over.\n      fragColor = texelFetch(iChannel0, iCoord, 0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  Camera cam;\n\n  if (iFrame == 0) {\n    cam = Camera(/*pos=*/vec3(0, -.5, -2),\n                 /*look=*/vec3(0, 0, 1),\n                 /*up=*/vec3(0, 1, 0),\n                 /*zoom=*/1.0);\n  } else {\n    cam = SampleCamera(iChannel0);\n  }\n  \n  if (iMouse.z > 0.) {\n    // The vector pointing from the click to current mouse pos, in uv space.\n    vec2 uv = (iMouse.xy - abs(iMouse.zw)) / min(iResolution.y, iResolution.x);\n    uv *= -1.;    // invert for panning.\n    uv *= uv*uv;  // simple easing.\n\n    // NOTE: `Rotation` expects that x is pitch, y is yaw.\n    mat4 rot = mat4(Rotation(.3*vec3(uv.yx, 0)));\n    cam.look = (rot * vec4(cam.look, 1)).xyz;\n    cam.up = (rot * vec4(cam.up, 1)).xyz;\n  }\n  \n  fragColor = EncodeCamera(cam, ivec2(fragCoord));\n}","name":"Buffer C","description":"","type":"buffer"}]}