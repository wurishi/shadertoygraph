{"ver":"0.1","info":{"id":"fsyyzh","date":"1654362239","viewed":45,"name":"Fork Field-fx w dratini0 668","username":"dratini0","description":"Look, I made an array of objects!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["basic","tutorial","boilerplate","workshop"],"hasliked":0,"parentid":"sdVczz","parentname":"Field-fx workshop boilerplate"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\n//GLOBAL VARIABLES\nfloat time;\n//PRIMITIVE FUNCTIONS\nfloat box(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat sphere(vec3 p,float r){return length(p)-r;}\nfloat torus(vec3 p,vec2 t ){vec2 q=vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\n//MAP / SCENE FUNCTION\nfloat map(vec3 p)\n{\n  p = mod(p + vec3(2., 10., 5.), vec3(4., 20., 10.)) - vec3(2., 10., 5.);\n  float mainBox=box(p,vec3(sin(iTime)/2. + .5));\n  float leftSphere=sphere(p+vec3(0,0,3),sin(iTime + PI*2./3.)/2. + .5);\n  float rightTorus=torus(p-vec3(0,0,3),vec2(1.,(sin(iTime + PI*4./3.)/2. + .5)*.5));\n  float scene=min(mainBox,leftSphere);\n  scene=min(scene,rightTorus);\n  return scene;\n}\n//RAY CAST / TRACE LOOP FUNCTION\nfloat raycast( vec3 ro, vec3 rd )\n{\n  float dist,res=0.;\n  for(int i=0;i<128;i++){ \n    dist=map(ro+rd*res); \n    if(dist<.0001||res>120.) break;\n    res+=dist;\n  }\n  if(res>120.) res=0.;\n  return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //UV.y from -.5 to .5 and UV.x from -.88 to .88 (aspect ratio broooh)\n  time=mod(iTime,62.82); //Modulo time to avoid sin glitch noise due to floating point precision\n  // CAMERA  \n  vec3 rayOrigin=vec3(cos(time*.2)*5.,2,sin(time*.2)*5.);\n  vec3 cameraForward=normalize(vec3(0)-rayOrigin);\n  vec3 cameraLeft=normalize(cross(cameraForward,vec3(0,1,0)));\n  vec3 cameraUp=normalize(cross(cameraLeft,cameraForward));\n  vec3 rayDirection=mat3(cameraLeft,cameraUp,cameraForward)*normalize(vec3(uv,.5)); \n  // LIGHT DIRECTION & BACKGROUND SETUP   \n  vec3 lightDirection=normalize(vec3(-.1,.4,-.3));  \n  vec3 backgroundColor=vec3(.1,.1,.1)-length(uv)*.1;\n  vec3 color=backgroundColor;\n  // TRACE AND GET RESULT FOR THIS PIXEL\n  float result=raycast(rayOrigin,rayDirection);\n  // IF WE HIT SOMETHING THEN DO SOME LIGHTING  \n  if(result>0.){ \n    vec3 hitPos=rayOrigin+rayDirection*result; // GET POSITION OF WHERE WE HIT\n    vec2 e=vec2(.00035,-.00035); // e=ESPILON = OFFSET NUMBER FOR NORMALS CALCULATION\n    vec3 normals=normalize(e.xyy*map(hitPos+e.xyy)+e.yyx*map(hitPos+e.yyx)+e.yxy*map(hitPos+e.yxy)+e.xxx*map(hitPos+e.xxx)); //CALCULATE NORMALS FOR WHERE WE HIT\n    vec3 albedo=vec3(.0,.2,.4); // SETUP BASE COLOUR\n    float diffuse=max(0.,dot(normals,lightDirection)); // SIMPLE DIFFUSE LIGHTING\n    float fresnel=pow(1.+dot(normals,rayDirection),4.); // FRESNEL = BACKGROUND REFLECTIONS ADDED TO EDGES OF GEOMETRY TO COMPOSITE IT BETTER IN THE SCENE\n    float specular=pow(max(dot(reflect(-lightDirection,normals),-rayDirection),0.),30.);// SPECULAR LIGHTING = Bright highlights, the shiny white flashy bit especially visible on metallic objects\n    float ao=clamp(map(hitPos+normals*.05)/.05,0.,1.); // AO = AMBIENT OCCLUSION = Small shadows where geometries touch due to ambient lighting\n    float sss=smoothstep(0.,1.,map(hitPos+lightDirection*.4)/.4);// SSS = Sub surface scattering = Light penetrating through edges of a translucent object, especially visible on candle wax or skin. Can be used as backlight too.\n    if(specular<1.) color=mix(specular+albedo*(ao+.2)*(diffuse+sss*.1),backgroundColor,fresnel); // Final lighting result made of all the above and then mixed with fresnel\n    color=mix(backgroundColor,color,exp(-.002*result*result*result)); // Add fog right at the end\n  }\n  fragColor = vec4(pow(color,vec3(.4545)),1);// RETURN FINAL COLOR WITH GAMMA CORRECTION (pow(color,vec3(.4545)))\n}","name":"Image","description":"","type":"image"}]}