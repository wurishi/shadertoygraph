{"ver":"0.1","info":{"id":"MdKSDz","date":"1463935466","viewed":355,"name":"Self-reflecting Metablobs","username":"jolle","description":"Self-reflecting metablobs. Variable length stepped rays + Newton-Raphson at edge. Optional multisampling (default 4). Fixed number of blobs.\n\nUse mouse to rotate. Default view is a bit off to let mouse rotation be more natural.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["reflection","blob","metablob","cubemapped"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int multisamples = 4; // Max 4\nconst int max_reflections = 6;\nconst float zoom = 2.0;\n\nconst float eyedistance = 7.5; // Note: These depend on each other\nconst float min_distance = 3.0;\nconst float max_distance = 10.5;\nconst float min_stepsize = 0.25;\nconst int maxsteps = 30;\n\nconst float pi = 3.1415926326;\n\nvec4 sphere1;\nvec4 sphere2;\nvec4 sphere3;\n\nfloat sq(float x) { return x * x; }\nfloat sq(vec3 x) { return dot(x, x); }\n\nfloat f(vec3 p)\n{\n    return 1.0 - (\n        sphere1.w / sq(sphere1.xyz - p) + \n        sphere2.w / sq(sphere2.xyz - p) +\n        sphere3.w / sq(sphere3.xyz - p));\n}\n\nvec3 fd(vec3 p)\n{\n    vec3 d1 = sphere1.xyz - p;\n    vec3 d2 = sphere2.xyz - p;\n    vec3 d3 = sphere3.xyz - p;\n    return 2.0 * (\n        sphere1.w * d1 / sq(sq(d1)) +\n        sphere2.w * d2 / sq(sq(d2)) +\n        sphere3.w * d3 / sq(sq(d3)));\n}\n\nfloat stepsize(vec3 p)\n{\n    float md = sqrt(min(min(\n        sq(p - sphere1.xyz), \n        sq(p - sphere2.xyz)), \n        sq(p - sphere3.xyz)));\n    return max(min_stepsize, (md - 1.0) * 0.667);\n}\n\nvec4 ray(vec3 p, vec3 d)\n{\n    float k = min_distance;\n    for (int j = 0; j < max_reflections; ++j)\n    {\n        for (int i = 0; i < maxsteps; ++i)\n        {\n            if (k > max_distance)\n                return texture(iChannel0, d);\n            float ss = stepsize(p + d * k);\n            if (f(p + d * (k + ss)) < 0.0)\n            {\n                k += ss - min_stepsize * 0.5;\n                k += f(p + d * k) / dot(d, fd(p + d * k));\n                k += f(p + d * k) / dot(d, fd(p + d * k));\n                p += d * k;\n                d = reflect(d, normalize(fd(p)));\n                k = 0.0;\n                break;\n            }\n            k += ss;\n        }\n    }\n    return texture(iChannel0, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\n    vec4 vs1 = cos(t * vec4(0.87, 1.13, 1.2, 1.0) + vec4(0.0, 3.32, 0.97, 2.85)) * vec4(-1.7, 2.1, 2.37, -1.9);\n    vec4 vs2 = cos(t * vec4(1.07, 0.93, 1.1, 0.81) + vec4(0.3, 3.02, 1.15, 2.97)) * vec4(1.77, -1.81, 1.47, 1.9);\n\n    sphere1 = vec4(vs1.x, 0.0, vs1.y, 1.0);\n\tsphere2 = vec4(vs1.z, vs1.w, vs2.z, 0.9);\n\tsphere3 = vec4(vs2.x, vs2.y, vs2.w, 0.8);\n\n    float ry = -iMouse.x / iResolution.x * pi * 2.0;\n    float rx = -(iMouse.y / iResolution.y - 0.5) * pi;\n\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n    vec3 eye = -forward * eyedistance;\n\n\tvec2 uv = zoom * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\n    vec3 dirs[4];\n    dirs[0] = vec3(forward + uv.y * up + uv.x * left);\n\tdirs[1] = vec3(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left);\n\tdirs[2] = vec3(forward + (uv.y + uvh.y) * up + uv.x * left);\n\tdirs[3] = vec3(forward + uv.y * up + (uv.x + uvh.x) * left);\n    \n    vec4 color = vec4(0.0);\n    for (int i = 0; i < multisamples; ++i)\n        color += ray(eye, normalize(dirs[i]));\n    fragColor = color / float(multisamples);\n}\n","name":"Image","description":"","type":"image"}]}