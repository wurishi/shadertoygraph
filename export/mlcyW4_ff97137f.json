{"ver":"0.1","info":{"id":"mlcyW4","date":"1699395600","viewed":105,"name":"MPR 3D collision","username":"kastorp","description":"this [url=https://youtu.be/ajv46BSqcK4?si=PRgAlizDPuCn-QMF]algorithm[/url] is so cool!\nmouseable; if intersecting, penetration vector and collision point are displayed\n","likes":13,"published":1,"flags":16,"usePreview":0,"tags":["collision","physics","minkowski","mpr","gjk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MPR 3D collision by kastorp\n//-----------------------------------\n//  MPR 3D algorithm porting from libccd\n//  credits in common file\n//\n//  mouse: move shape \n//  space: align shapes\n//  A: debug support function (MPR intersection with ray)\n//  1: toggle sphere\n//  2: toggle cylinder\n//  3: toggle cone\n//-----------------------------------\n\n#define R iResolution.xy\n\nobj o1,o2;\n\n//ray-object intersection\nvoid debug( out vec4 O, in vec2 uv ,vec3 rd,vec3 ro)\n{   \n\n\n#if 1 \n    obj o3;  \n    //ray from ro to ro+rd*10.\n    o3.c=ro+rd*5.;\n    o3.b=rd*5.;\n    o3.r=vec4(1,0,0,0);\n    o3.s = 5;\n    int  inside1 = MPRIntersect(o1,o3);        \n    int  inside2 = MPRIntersect(o3,o2); \n    vec3 col=vec3(inside1>0,0,inside2>0);\n    O = vec4(col,1.0);\n#else \n    float depth; vec3 n;\n    vec3 l = vec3(-0.5, 0.888, 0.58);\n    int res =MPRNormal( o1  , depth, n,  rd, ro);\n    if(res>0){O.rgb=res==2?vec3(1): vec3(1,0,0)* max(0.2, dot(n, l));}\n    res=MPRNormal( o2  , depth, n,  rd, ro);\n    if(res>0){O.rgb=res==2?vec3(1): vec3(0,0,1)* max(0.2, dot(n, l));}\n    \n#endif    \n\n}\n#define seg(  pa,  ba ) length( pa - (ba)*clamp( dot(pa,ba)/dot(ba,ba), 0., 1. ) ) \n#define gBox( p, b ) sign(p)*(max(abs(p)-b,0.))\n#define dBox( p, b ) (length(max(abs(p)-b+.002,0.)) -.002)  //normal trick \n\n\n\nvec3 va,vb,vc;\nbool intersect ;\n\nvoid getIntersect(){\n    \n    float depth; \n    vec3 dir, pos;\n    int res=  MPRPenetration( o1 ,  o2 , depth,  dir,   pos );\n    intersect=res>0;\n    va=vec3(0,.0,-.35) ;\n    vb=vec3(0,.0,-.35)+ dir.xyz*depth*1.;\n    vc= pos;\n\n}\n\n// vertical cylinder\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//cone\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdf(vec3 p, obj o ){\n    if(o.s==1) return length(p) -o.b.x;\n    else if(o.s==2) return sdCylinder(p.xzy,o.b.x,o.b.y);\n    else if(o.s==3) return sdCone(p.xzy,vec2(1),o.b.z);\n    return dBox(p,o.b);\n}\n\nvec4 mmin(vec4 a, float b ,vec3 c){return a.x<b?a:vec4(b,c);}\nvec4  mapScene( vec3 p )\n{\n   vec4 m =vec4(1000.,0,0,0);\n   if(intersect){\n       m=mmin(m,seg(p-va,vb-va) -.005,vec3(0.,.5,0));  \n       m=mmin(m,length(p-va) -.006,vec3(1.,1,0));\n       m=mmin(m,length(p-vc) -.05,vec3(1.,1,0));\n   }\n \n   float da=sdf(erot(p-o1.c,o1.r),o1),\n         db=sdf(erot(p-o2.c,o2.r),o2),\n         dh=length(p-vc);\n   m =mmin(m,da,intersect? (.5+.5*cos(dh*200.))*vec3(1,0,0):vec3(1,0,0));\n   m =mmin(m,db,intersect? (.5+.5*cos(dh*200.))*vec3(0,0,1):vec3(0,0,1));\n   return m;\n}\n\n\nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    for(int i=min(iFrame,0);i<=2;i++){\n        vec3 e=  0.001* ((i==0)?vec3(1,0,0):(i==1)?vec3(0,1,0):vec3(0,0,1));\n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapScene(p + j* e).x ;\n    }\n    return normalize(n); \n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 0, 1), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    \n    vec2 uv = (I - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m=(iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    O = vec4(.5, .5, .5, 1.0);\n     float tm = .5*iTime;\n\n    o1.c= iMouse.z>0.?  vec3(m.x,0,m.y):vec3(-.2,0,0); \n    o1.b= vec3(.4,.05,.05);\n    o1.s=0;\n    o1.r= vec4(normalize(vec3(1,1,0)),0.5*tm);\n\n    o2.c= vec3(.2,0,0.05); \n    o2.r= vec4(normalize(vec3(0,1,1)),tm);\n    if(texelFetch(iChannel3,ivec2(49,2),0).x>.5){\n        o2.b= vec3(.25,.25,.4);\n        o2.s=1; \n    }else if(texelFetch(iChannel3,ivec2(50,2),0).x>.5){\n        o2.b= vec3(.25,.25,.4);\n        o2.s=2; \n    }else if(texelFetch(iChannel3,ivec2(51,2),0).x>.5){\n        o2.b= vec3(.25,.25,.4);\n        o2.s=3;        \n    } else {\n        o2.b= vec3(.25,.25,.02);\n        o2.s=0; \n    }\n\n    vec3 ro = vec3(0,1.,0. );\n    vec3 rd = getRayDir( ro,vec3(0),uv);\n    \n    if(texelFetch(iChannel3,ivec2(32,2),0).x>.5) o2.r=o1.r;\n    if(texelFetch(iChannel3,ivec2(65,2),0).x>.5){\n     debug(O,uv,rd,ro);return;\n    }\n    getIntersect();\n  \n\n      \n    float t = 0.0;\n    for (float iters=0.0; iters < 80.0; iters++) {\n        vec3 p = ro + rd * t;   \n        vec4 m = mapScene(p);\n        if (m.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.5, 0.888, 0.58);\n\n            O.rgb +=m.yzw;\n            O.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n        if (t > 50.0) {\n            break;\n        }\n        t += m.x;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// MPR - Algorithm port from libccd\n//--------------------------------------------------\n// https://github.com/danfis/libccd\n//\n// libccd is library for a collision detection between two convex shapes. \n// libccd implements variation on Gilbert–Johnson–Keerthi algorithm \n// plus Expand Polytope Algorithm (EPA) and also implements algorithm \n// Minkowski Portal Refinement (MPR, a.k.a. XenoCollide) \n// as described in Game Programming Gems 7.\n//\n// libccd is the only available open source library of my knowledge \n// that include MPR algorithm working in 3-D space. \n// For implementation details on GJK algorithm, see http://www.win.tue.nl/~gino/solid/jgt98convex.pdf.\n//\n// BSD-LICENSE\n// Copyright (c)2010-2012 Daniel Fiser <danfis@danfis.cz>,\n// Intelligent and Mobile Robotics Group, Department of Cybernetics,\n// Faculty of Electrical Engineering, Czech Technical University in Prague.\n// All rights reserved.\n//-----------------------------------------------------\nstruct obj{\n    vec3 c; //center\n    vec3 b; //bounding box\n    vec4 r; //rotation (xyz=axis, w=angle)\n    int s; //shape (0=box,1=sphere,2=cylinder,3=cone, 5=segment)\n};\n\nobj _ob1,_ob2;\nvec3 a,b,c,d; //difference simplex\nvec3 a1,b1,c1,d1; //obj1 simplex\nvec3 a2,b2,c2,d2; //obj2 simplex\n\n//mat3 rt;\n\n#define  tripleCross(a,b,c) cross(a,cross(b,c))\nvec3 erot(vec3 p, vec4 ax) {\n    return mix(dot(p,ax.xyz)*ax.xyz,p,cos(ax.w))+sin(ax.w)*cross(ax.xyz,p);\n}\nmat3 mrot(vec4 ra){\n    return mat3(erot(vec3(1,0,0),ra),erot(vec3(0,1,0),ra),erot(vec3(0,0,1),ra));\n}\n\n#define MAX_ITER 10\n//-------------------\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\nvec3 supNgon(vec3 d, float n)\n{\n\n    float a = atan(d.y, d.x);\n    float f = 6.2830 / n;\n    a = (floor(a/f)+.5)*f;\n    return vec3(cos(a), sin(a), .0);\n}\n\nvec3 support(vec3 dir, obj o){\n\n    if(o.s==1) return dir*o.b.x;\n    else if(o.s==2) return  supMax( dir,        \n            vec3(normalize(dir.xy)*o.b.x, o.b.y), \n            vec3(normalize(dir.xy)*o.b.x, -o.b.y) \n        );\n    else if(o.s==3) return  supMax( dir,        \n            vec3(normalize(dir.xy)*o.b.z, o.b.z) ,\n            vec3(0,0,0)\n        );\n   else if(o.s==5) return  supMax( dir,        \n            vec3(o.b) ,\n            vec3(-o.b)\n        ) +dir*.001; \n    else if(o.s==-1) return vec3(0);\n    else return sign(dir)*o.b;\n\n} \n\n//Minkowsky difference support function\nvec3 support(vec3 dir,out vec3  s1, out vec3 s2){\n\n    mat3 rt = mrot(_ob1.r);\n    s1 = support(rt*dir,_ob1);   \n    s1=  transpose(rt)*(s1 +rt*(_ob1.c)); \n    \n    rt = mrot(_ob2.r);\n    s2 = support(rt*dir,_ob2);\n    s2=  transpose(rt)*(s2 -rt*(_ob2.c));\n    \n    return s1+s2;\n}\n\n//------------------------------------\n\nint discoverPortal()\n{\n    vec3 dir; \n   \n    // vertex a is center of portal\n    a1=_ob1.c;a2=-_ob2.c; a= a1+a2; \n    \n    if (a==vec3(0)) {a1+= vec3(1e-3,0,0); a+=vec3(1e-3,0,0);}\n\n    // vertex b = support in direction of origin\n\tdir= -normalize(a);  \n    b = support(dir,b1,b2);\n\n    // test if origin isn't outside of b\n    if ( dot(b, dir) <=0.) return -1;\n\n    // vertex c\n\tdir = cross(a, b);\t\t\t\t\t \t\t\t\t\t   \n    if (length(dir)==0.){\n        if (b == (_ob1.c-_ob2.c)) return 1; // origin lies on b\n        else return 2; // origin lies on a-b segment\n    }\n    \n\tc= support(normalize(dir),c1,c2);\n    if ( dot(c, dir) <=0.) return -1;\n\n    // vertex d direction\n\n\tdir= normalize(cross(b-a,c-a));\n\n    // it is better to form portal faces to be oriented \"outside\" origin\n\n    if (dot(dir, a) > 0.){\n        vec3 t =b; b=c;c=t; t =b1; b1=c1;c1=t; t =b2; b2=c2;c2=t;//swap\n        dir *=-1.;\n    }\n    \n    \n    int cont=1;\n    int iter=0;\n    while (cont>0 && iter <20){\n        \n\t\td= support(dir,d1,d2);        \n        if (dot(d, dir) <=0.) return -1;\n        cont = 0;\n\n        // test if origin is outside (b, a, d) - set c as d and continue\n        if ( dot(cross (b,d), a)  < 0. ){\n\t\t\tc=d;c1=d1;c2=d2;\n            cont = 1;      \n        }\n        \n        if (cont==0){\n            // test if origin is outside (d, a, c) - set b as d and continue\n            if (dot(cross (d,c), a) < 0. ){\n                b=d;b1=d1;b2=d2;\n                cont = 1;               \n            }\n        }\n        if (cont!=0) dir =normalize(cross( b-a, c-a));\n        iter++;\n    }\n    return 0;\n}\n\n\nint refinePortal()\n{\n    vec3 dir;\n    vec3 v4,v41,v42;\n    int iter=2;\n    \n    while (iter<20){\n        iter++;\n        // compute direction outside the portal (from v0 throught v1,v2,v3 face)\n        dir= normalize(cross( c-b, d-b));\n\n        // test if origin is inside the portal\n        if ( dot(dir, b)>= 0.) return iter;\n\n        // get next support point\n        v4 = support(dir,v41,v42);\n       \n        // find the smallest dot product of dir and {a-v4, b-v4, c-v4}\n        float dv1 = dot(a, dir);\n        float dv2 = dot(b, dir);\n        float dv3 = dot(c, dir);\n        float dv4 = dot(v4, dir);\n        bool portalReachTolerance=   (min(min(dv4 - dv1, dv4 - dv2),dv4 - dv3)  <= 1e-4);\n\n        // test if v4 can expand portal to contain origin and if portal\n        // expanding doesn't reach given tolerance\n        if ( dot(v4, dir)<0.  || portalReachTolerance)  return -iter;\n        \n        // expandPortal( v4);\n        // b-c-d triangle must be rearranged to face outside Minkowski\n        // difference (direction from a).     \n        vec3 v4a =cross( v4,a);   \n        if (dot(b, v4a) > 0.) {\n            if(dot (c, v4a) > 0.) {b=v4;b1=v41;b2=v42;}\n            else  {d=v4;d1=v41;d2=v42;}\n        }\n        else{\n            if(dot(d, v4a) > 0.)  {c=v4;c1=v41;c2=v42;}\n            else {b=v4;b1=v41;b2=v42;}\n        }        \n    }\n\n    return -iter;\n}\n\n// return value:\n//  <=0 ouside \n//  >0 inside \nint MPRIntersect(obj o1 , obj o2)\n{\n\n    int res;\n    _ob1 =o1;\n    _ob2=o2;\n    // Phase 1: Portal discovery - find portal that intersects with origin\n    // ray (ray from center of Minkowski diff to origin of coordinates)\n    res = discoverPortal();\n    if (res != 0) return res;\n\n    // Phase 2: Portal refinement\n    res = refinePortal();\n    return res; \n}\n\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n// Iq:  https://www.shadertoy.com/view/ttfGWl\nfloat  PointTriDist2(in vec3 p,  in vec3 v0, in vec3 v1, in vec3 v2, out vec3 dir  )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross( v10, v02 );\n\n    if( dot(cross(v10,nor),p0)<0.0 ) dir=  v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    else if( dot(cross(v21,nor),p1)<0.0 ) dir= v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    else if( dot(cross(v02,nor),p2)<0.0 ) dir= v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    else dir= p - nor*dot(nor,p0)/dot2(nor);\n    return dot2(p-dir);  \n}\n\nvoid findPos(out vec3 pos)\n{\n    vec3  dir;\n    float k0,k1,k2,k3, sum;\n\n    dir= normalize(cross( c-b, d-b));\n    \n    // use barycentric coordinates of tetrahedron to find origin    \n    k0 = dot(cross(b,c),d);\n    k1 = dot(cross(d,c),a);\n    k2 = dot(cross(a,b),d); \n    k3 = dot(cross(c,b),a);  \n\n\tsum = k0 + k1 + k2 + k3;\n    if (sum<=0.){\n\t\tk0 = 0.;\n        k1 = dot(cross(b,c),dir);  \n        k2 = dot(cross(d,b),dir);  \n        k3 = dot(cross(b,c),dir);   \n\t\tsum = k1 + k2 + k3;\n\t}\n    \n    vec3 p1= a1*k0+b1*k1+c1*k2+d1*k3;\n    vec3 p2= a2*k0+b2*k1+c2*k2+d2*k3;\n\n    pos=.5*(p1-p2)/sum;\n}\nvoid findPenetr(out float depth, out vec3 dir, out vec3 pos){\n\n    \n    vec3 v4,v41,v42;\n    int iterations;\n\n    iterations = 0;\n    while (true){\n        // compute portal direction and obtain next support point\n        dir= normalize(cross( c-b, d-b));\n        v4 =support(dir,v41,v42);\n\n        float dv1 = dot(a, dir);\n        float dv2 = dot(b, dir);\n        float dv3 = dot(c, dir);\n        float dv4 = dot(v4, dir);\n        bool portalReachTolerance=   (min(min(dv4 - dv1, dv4 - dv2),dv4 - dv3)  <= 1e-4);\n        \n        // reached tolerance -> find penetration info\n        if (portalReachTolerance|| iterations > MAX_ITER){\n            depth = PointTriDist2(vec3(0) ,b,c,d, dir);\n            depth = sqrt(depth);\n            if (depth==0.){\n                // If depth is zero, then we have a touching contact.\n                // So following findPenetrTouch(), we assign zero to\n                // the direction vector (it can actually be anything\n                // according to the decription of ccdMPRPenetration\n                // function).\n                dir=vec3(0);\n            }else{\n                dir=normalize(dir);\n            }\n\n            // barycentric coordinates:\n            findPos(pos);\n\n            return;\n        }\n\n        //ExpandPortal(v4)\n        // b-c-d triangle must be rearranged to face outside Minkowski\n        // difference (direction from a).     \n        vec3 v4a =cross( v4,a);   \n        if (dot(b, v4a) > 0.) {\n            if(dot (c, v4a) > 0.) {b=v4;b1=v41;b2=v42;}\n            else  {d=v4;d1=v41;d2=v42;}\n        }\n        else{\n            if(dot(d, v4a) > 0.)  {c=v4;c1=v41;c2=v42;}\n            else {b=v4;b1=v41;b2=v42;}\n        } \n        iterations++;\n    }\n}\n\nint MPRPenetration(obj o1 , obj o2 , out float depth, out vec3 dir, out vec3 pos)\n{\n    \n    int res;\n    _ob1 =o1;\n    _ob2 =o2;\n    \n    // Phase 1: Portal discovery\n    res = discoverPortal();\n    if (res < 0){\n        // Origin isn't inside portal - no collision.\n        return -1;\n\n    }else if (res == 1){\n        // Touching contact on portal's b.\n            // Touching contact on portal's b - so depth is zero and direction\n            // is unimportant and pos can be guessed\n            depth = 0.;\n            dir= vec3(0); \n            pos=(b1+b2)*.5;\n\n    }else if (res == 2){\n        // Origin lies on a-b segment.\n        // Depth is distance to b, direction also and position must be\n        // computed\n         pos=(b1+b2)*.5;\n         depth = length(b);\n         dir =normalize(b);\n\n    }else if (res == 0){\n        // Phase 2: Portal refinement\n        res = refinePortal();\n        if (res < 0)  return -1;\n        // Phase 3. Penetration info\n        findPenetr(depth, dir, pos);\n        return res;\n    }\n\n    return 0;\n}\n\n//inspired by https://www.shadertoy.com/view/wstyRB\nint  MPRNormal(obj o1 , out float depth, out vec3 normal, vec3 rd, vec3 ro){\n\n    obj o3;  \n    //ray from ro to ro+rd*10.\n    o3.c=ro+rd*1.2;\n    o3.b=rd*1.2;\n    o3.r=vec4(1,0,0,0);\n    o3.s = 5;\n     \n    int  res = MPRIntersect(o1,o3);  \n    if(res<=0) return res;\n      \n    for (int i = 0; i < 20; ++i)\n    {\n        vec3 dir = normalize(cross(b-a, c-a));\n        d = support(dir,d1,d2);\n        \n        if (dot(dir, d) - dot(dir, a) < 1e-4) break;\n        \n        #define nr(x) (x-dot(x,rd)*rd)\n        bool ad = dot(cross(nr(d-a),rd), nr(d)) > 0.;\n        bool bd = dot(cross(nr(d-b),rd), nr(d)) > 0.;\n        bool cd = dot(cross(nr(d-c),rd), nr(d)) > 0.;\t\n       \n        \n        // Choose triangle that intersects z-axis furthest in z direction\n        if (ad && !bd)      {c = d; c1=d1; c2=d2;}\n        else if (bd && !cd) {a = d; a1=d1; a2=d2;}\n        else if (cd && !ad) {b = d; b1=d1; b2=d2;}\n        else return 2; // Should not happen\n\n\t}\n    \n    normal = normalize(cross(b-a, c-a));\n    depth = length(ro - a);\n    return 1;\n}","name":"Common","description":"","type":"common"}]}