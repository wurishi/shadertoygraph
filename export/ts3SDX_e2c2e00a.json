{"ver":"0.1","info":{"id":"ts3SDX","date":"1572983846","viewed":101,"name":"flying squirrels","username":"thisisthais","description":"my output from the devtea led by char ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tiling","distancefunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530718\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat equiTri(vec2 p){\n  float side=sqrt(3.);\n  p.x=abs(p.x)-1.;\n  p.y=p.y+1./side;\n  if(p.x+side*p.y>0.){\n    p=vec2(p.x-side*p.y,-side*p.x-p.y)/2.;\n  }\n  p.x-=clamp(p.x,-2.,0.);\n  return-length(p)*sign(p.y);\n}\n\nfloat sdCircle(vec2 p,float r)\n{\n  return length(p)-r;\n}\n\nfloat sdPentagon(in vec2 p,in float r)\n{\n  const vec3 k=vec3(.809016994,.587785252,.726542528);\n  p.x=abs(p.x);\n  p-=2.*min(dot(vec2(-k.x,k.y),p),0.)*vec2(-k.x,k.y);\n  p-=2.*min(dot(vec2(k.x,k.y),p),0.)*vec2(k.x,k.y);\n  return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);\n}\n\n// https://iquilezles.org/articles/palettes\n// As t runs from 0 to 1 (our normalized palette index or domain),\n//the cosine oscilates c times with a phase of d.\n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette(float t,vec3 a,vec3 b,vec3 c,vec3 d)\n{\n  return a+b*cos(6.28318*(c*t+d));\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p,float a){\n  p=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nvec2 tile(vec2 st,float zoom){\n  st*=zoom;\n  // _st.x += step(1., mod(_st.y,2.0)) * 0.5;\n  return fract(st+iTime);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 myRes = iResolution.yy;\n  vec2 st=fragCoord/myRes.xy;\n  vec3 color=vec3(0.);\n\n  st=tile(st,4.);\n\n  // normalize the coordinate space\n  st-=vec2(.5);\n  st*=2.;\n\n  // spiiiiiin\n  pR(st,mod(iTime,TWO_PI));\n  \n  // distance shapes\n  float triangle=equiTri(st*vec2(3.));\n  float circle=sdCircle(st*vec2(3.),.5);\n  float pentagon=sdPentagon(st*vec2(3.),.5);\n  float changingShape=sin(iTime)*(triangle-circle)+circle;\n  // this makes a flying squirrel\n  changingShape=sin(iTime)*(changingShape-pentagon)+pentagon;\n  \n  vec3 col=cosPalette(.5,vec3(.5),vec3(.5),vec3(1.),vec3(iTime*.01,iTime*.1,iTime*.2));\n  \n  // lighting: darken at the center\n  col=vec3(changingShape)*col;\n  \n  // output: pixel color\n  fragColor=vec4(col.rgb,1.);\n}","name":"Image","description":"","type":"image"}]}