{"ver":"0.1","info":{"id":"Wsjczh","date":"1586104221","viewed":279,"name":"Menger Tunnel Shiny Surfaces","username":"kevs3d","description":"Some pleasingly shiny richly textured surfaces within a menger sponge based tunnel system.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["fractal","tunnel","raymarched","lighting","menger","surfacing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Distance field ray-marching demo - by Kevin Roast\n   Uses code by other authors - as credited in method comments.\n\n   http://www.kevs3d.co.uk/dev/shaders\n\nSome pleasingly shiny richly textured surfaces within a menger sponge based tunnel system.\n\nAs ever, I stand on the shoulders of giants as I have only half an idea what i'm doing most of the time!\nTHANKS GO GREATLY TO: IQ, Shane, TekF, Anatole Duprat and others thank you for your inspirational code.\n*/\n\n#define RAY_DEPTH 200\n#define MAX_DEPTH 50.0\n#define DISTANCE_MIN 0.001\n#define PI 3.14159265\n\n#define MATERIAL_0 0.0\n#define MATERIAL_1 1.0\n#define MATERIAL_2 2.0\n#define MATERIAL_3 3.0\n\n#define SPEED 1.0\n#define TSCALE 4.0\n\nconst vec2 delta = vec2(DISTANCE_MIN, 0.0);\nconst vec3 cameraPos = vec3(0.,4.,0.);\nconst vec3 cameraLookat = vec3(0.,4.0,10.);\nconst bool shadows = true;\nconst bool occlusion = true;\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 Tex3D(in vec3 p, in vec3 n, in sampler2D t)\n{\n   n = max(n*n, .001);\n   n /= (n.x + n.y + n.z);  \n\treturn (texture(t, p.yz*TSCALE)*n.x + texture(t, p.zx*TSCALE)*n.y + texture(t, p.xy*TSCALE)*n.z).xyz;\n}\n\nfloat Hash(in float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec2 max2(vec2 a, vec2 b) { return a.x > b.x ? a : b; }\nvec2 min2(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\nfloat smin(float a, float b, float k)\n{\n   float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n   return mix(b, a, h) - k*h*(1.0-h);\n}\n// Menger tunnel - originally based on examples by Shane, modified\nvec2 Tunnel(vec3 q)\n{\n   float s = 4.;\n\n   vec3 p = abs(fract(q/s)*s - s*.5);\n   vec2 d = vec2(smin(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z)), 0.05) - s/3.0, MATERIAL_1);\n\n   s /= 2.;\n   p = abs(fract(q/s)*s - s*.5);\n   d = max2(vec2(d.x+0.085, d.y), vec2(smin(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z)), 0.1) - s/3.0, MATERIAL_2));\n\n   s /= 3.;\n   p = abs(fract(q/s)*s - s*.5);\n   d = max2(d, vec2(smin(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z)), 0.01) - s/3.0, MATERIAL_3));\n      \n   return d;\n}\n\nvec2 Map(vec3 pos)\n{\n   return Tunnel(pos);\n}\n\n// Fast 3-tap normal as we know the final distance\nvec3 GetNormal(vec3 pos, float s)\n{\n   vec3 n;\n   n.x = s - Map(pos - delta.xyy).x;\n   n.y = s - Map(pos - delta.yxy).x;\n   n.z = s - Map(pos - delta.yyx).x;\n   return normalize(n);\n}\n\n// IQ, we all thank you...\nfloat SoftShadow(vec3 ro, vec3 rd, float lightDistance)\n{\n   float k = 128.0;              // softness\n   float res = 1.0;\n   float t = 0.001;              // min-t see https://iquilezles.org/articles/rmshadows\n   for (int i=0; i<64; i++)\n   {\n      float h = Map(ro + rd * t).x;\n      res = min(res, k*h/t);\n      t += h;\n      if (res < 0.0001 || t > lightDistance) break;    // max-t\n   }\n   return clamp(res, 0.3, 1.0);  // avoid darkening too much\n}\n\nvec3 RandomSphereDir(vec2 rnd)\n{\n   float s = rnd.x*PI*2.;\n   float t = rnd.y*2.-1.;\n   return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 RandomHemisphereDir(vec3 dir, float i)\n{\n   vec3 v = RandomSphereDir( vec2(Hash(i+1.0), Hash(i+33.0)) );\n   return v * sign(dot(v, dir));\n}\n// Anatole Duprat's amazing hemispherical AO routine\n// ...takes some tweaking per scene to get it right compared to the traditional IQ routine - first three values...\nfloat CalcHemisphereAO(in vec3 p, in vec3 n)\n{\n   float maxDist = 0.3;    // NOTE: fine turned per scene! Could be 0.2->2.0 easily...\n   float falloff = 1.5;    // Typically, close to 2.0\n\n   const int nbIte = 16;       // 32/64 etc. gives better results - scenes where object parts stay relative need less\n   const float nbIteInv = 1.0 / float(nbIte);\n   const float rad = 1.0 - 1.0*nbIteInv;        // hemispherical factor (self occlusion correction)\n\n   float ao = 0.0;\n   for (int i=0; i<nbIte; i++)\n   {\n      float len = Hash(float(i)) * maxDist;\n      vec3 rd = normalize(n+RandomHemisphereDir(n, len) * rad) * len; // mix dir with normal to correct self occlusion issues\n      ao += (len - max(Map( p + rd ).x, 0.0)) / maxDist * falloff;\n   }\n\n   return clamp(1.0 - ao*nbIteInv, 0.0, 1.0);\n}\n\nconst vec3 lightColour = vec3(1.55,1.50,1.45);\nconst vec3 surfaceColour1 = vec3(0.05,0.05,0.053) * 1.25; // nudge my original colours because will multiply by texture\nconst vec3 surfaceColour2 = vec3(0.80,0.30,0.10)  * 1.25;\nconst vec3 surfaceColour3 = vec3(0.10,0.10,0.125) * 1.5;\nconst float specular1 = 1.0;\nconst float specularHardness1 = 16.0;\nconst float specular2 = 0.3;\nconst float specularHardness2 = 32.0;\nconst float specular3 = 0.5;\nconst float specularHardness3 = 24.0;\nconst float lightAttenuation = 0.15;\n/**\n * Point light based multi-material shading.\n * Applies hemispherical occlusion and shadows based on light.\n * Return rgb colour and the shadow occlusion is returned as the 4th component.\n */\nvec4 Shading(vec3 pos, vec3 ro, vec3 rd, vec3 norm, float mat)\n{\n   // simple materials\n   if (mat == MATERIAL_0) return vec4(0.0);\n   \n   // shaded materials\n   vec3 colour;\n   float sp;\n   float sph;\n   vec3 texture;\n   if (mat == MATERIAL_1) {\n      texture = Tex3D(pos, norm, iChannel0);\n      colour = surfaceColour1 * texture;\n      sp = specular1;\n      sph = specularHardness1;\n   }\n   if (mat == MATERIAL_2) {\n      texture = Tex3D(pos, norm, iChannel1);\n      colour = surfaceColour2 * texture;\n      sp = specular2;\n      sph = specularHardness2;\n   }\n   if (mat == MATERIAL_3) {\n      texture = Tex3D(pos, norm, iChannel2);\n      colour = surfaceColour3 * texture;\n      sp = specular3;\n      sph = specularHardness3;\n   }\n\n   float ao = 1.0;\n   if (occlusion) ao = 0.25 + CalcHemisphereAO(pos, norm) * 0.75;   // fudge a little to avoid darkening\n   \n   // shaded materials\n   vec3 light = vec3(0.0);\n   float shadow = 1.0;\n   \n   // light position relative to camera\n   vec3 lightPos = cameraPos;\n   float offset = iTime * SPEED;\n   lightPos.y += 0.30;\n   lightPos.z += offset - 0.5;\n\n   // point lighting calculation\n   vec3 toLight = lightPos - pos;                                 // vector to the point light\n   float dist = length(toLight);                                  // distance to light position\n   vec3 toLightDir = toLight / dist;                              // normalised direction to the point light\n   float dotVP = dot(norm, toLightDir);                           // shading angle from point light \n   float attenuation = 1.0 / (dist * lightAttenuation);           // distance attenuation\n   light = lightColour * ao * max(0.0, dotVP) * attenuation;      // phong shade with occlusion\n   if (shadows) shadow = SoftShadow(pos, toLightDir, dist);\n\n   vec3 halfV = normalize(toLightDir - rd);\t\t                  // blinn specular highlight calculation\n   float spec = pow(max(0.0, dot(norm, halfV)), sph) * attenuation;\n   \n   // light level multipled by colour add in specular component, use texture as spec map, occuled by shadow\n   light = (light * colour + sp * spec * texture * ao) * shadow;\n\n   return vec4(light, shadow);\n}\n\n// Camera function by TekF\n// Compute ray from camera parameters\nvec3 GetRay(vec3 dir, vec2 pos)\n{\n   pos = pos - 0.5;\n   pos.x *= iResolution.x/iResolution.y;\n   \n   dir = normalize(dir);\n   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n   vec3 up = normalize(cross(dir,right));\n   \n   return dir + right*pos.x + up*pos.y;\n}\n\n// Original method by David Hoskins\n#define GAMMA 0.85\n#define CONTRAST 1.1\n#define SATURATION 1.1\n#define BRIGHTNESS 1.1\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(GAMMA));\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\n\treturn rgb;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\n// Thanks Shane for this routine, seen in several of his shaders\nfloat getGrey(vec3 p)\n{\n   return dot(p, vec3(0.299, 0.587, 0.114));\n}\nvec3 BumpMap(in vec3 p, in vec3 nor, float bumpfactor, sampler2D t)\n{\n   const float eps = DISTANCE_MIN;\n\n   vec3 grad = vec3( getGrey(Tex3D(vec3(p.x - eps, p.y, p.z), nor, t)),\n                     getGrey(Tex3D(vec3(p.x, p.y - eps, p.z), nor, t)),\n                     getGrey(Tex3D(vec3(p.x, p.y, p.z - eps), nor, t)));\n\n   grad = (grad - getGrey(Tex3D(p, nor, t))) / eps; \n   \n   grad -= nor * dot(nor, grad);          \n   \n   return normalize(nor + grad*bumpfactor);\n}\n\nvec2 March(vec3 ro, vec3 rd, inout vec3 p)\n{\n   float t = 0.0;\n   float d = 0.0;\n   for (int i=0; i<RAY_DEPTH; i++)\n   {\n      p = ro + rd * t;\n      vec2 dm = Map(p);\n      if (dm.x < DISTANCE_MIN * (t * 0.25 + 1.00)) // thanks Shane for this speed adjustment idea\n      {\n         return dm;\n      }\n      t += dm.x;\n      if (t >= MAX_DEPTH) break;\n   }\n   return vec2(0.0, MATERIAL_0);\n}\n\nvec2 MarchReflect(vec3 ro, vec3 rd, inout vec3 p)\n{\n   float t = 0.0;\n   float d = 0.0;\n   for (int i=0; i<50 ; i++)\n   {\n      p = ro + rd * t;\n      vec2 dm = Map(p);\n      if (dm.x < 0.002 * (t * 0.5 + 1.00))\n      {\n         return dm;\n      }\n      t += dm.x;\n      if (t >= MAX_DEPTH) break;\n   }\n   return vec2(0.0, MATERIAL_0);\n}\n\nvoid mainImage(out vec4 glFragColor, in vec2 glFragCoord)\n{\n   vec3 lookAt = cameraLookat;\n   float offset = iTime * SPEED;\n   lookAt.y = sin(iTime*0.15)*40.0;\n   lookAt.x = cos(iTime*0.275)*30.0;\n   lookAt.z = sin(iTime*0.1)*65.0 + offset;\n   vec3 cpos = vec3(cameraPos.x, cameraPos.y, cameraPos.z + offset);\n\n   vec4 res = vec4(0.0);\n   vec3 hit;\n   vec3 ro = cpos;\n   \n   vec2 p = vec2(glFragCoord.x / iResolution.x, glFragCoord.y / iResolution.y);\n   \n   vec3 rd = normalize(GetRay(lookAt-cpos, p));\n   vec2 dm = March(ro, rd, hit);\n\n   vec3 refShade = vec3(0.0);\n   float matReflect;\n   vec3 pnorm = GetNormal(hit, dm.x);\n   vec3 norm;\n   if (dm.y == MATERIAL_1) {\n      norm = BumpMap(hit, pnorm, +0.003, iChannel0);\n      matReflect = 0.70;\n   }\n   if (dm.y == MATERIAL_2) {\n      norm = BumpMap(hit, pnorm, -0.003, iChannel1);\n      matReflect = 0.30;\n   }\n   if (dm.y == MATERIAL_3) {\n      norm = BumpMap(hit, pnorm, +0.008, iChannel2);\n      matReflect = 0.40;\n   }\n\n   float refMatReflect;\n   if (dm.y != MATERIAL_0) {\n      vec3 refRd = reflect(rd, normalize(pnorm + norm * 0.3)); // tame the bump down little [thanks Shane]\n      vec3 refRo = hit + refRd * 0.01;\n      vec3 refHit;\n      vec2 refDM = MarchReflect(refRo, refRd, refHit);\n      vec3 refNorm = GetNormal(refHit, refDM.x);\n      refShade = Shading(refHit, refRo, refRd, refNorm, refDM.y).rgb;\n      if (refDM.y == MATERIAL_1) {\n         refMatReflect = 0.70;\n      }\n      if (refDM.y == MATERIAL_2) {\n         refMatReflect = 0.30;\n      }\n      if (refDM.y == MATERIAL_3) {\n         refMatReflect = 0.40;\n      }\n   }\n\n   // 4th vector element is shadow occlusion, yes i know...\n   vec4 shade = Shading(hit, ro, rd, norm, dm.y);\n   res.rgb = (shade.rgb * (1.0 - matReflect)) + (refShade.rgb * matReflect * (1.0 - refMatReflect) * shade.w);\n   \n   glFragColor = vec4(PostEffects(res.rgb, p), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}