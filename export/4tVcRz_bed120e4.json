{"ver":"0.1","info":{"id":"4tVcRz","date":"1637336495","viewed":107,"name":"Simple Raytracing","username":"drcd1","description":"Raytracer","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE 1\n#define TRIANGLE 2\n#define INF 1e9\n#define EPS 1e-3\n#define N_SHAPES 3\n#define N_LIGHTS 2\n#define DEPTH 3\n#define M_PI 3.14159265358979323846 \nstruct shape{\n\tvec3 q[3];\n    int type;\n    int material;\n};\n\n\nstruct ray{\n\tvec3 o;\n    vec3 d;\n    float tMax;\n    int depth;\n    \n};\nshape make_sphere(vec3 center, float r){\n\tshape ret;\n    ret.q[0] = center;\n    ret.q[1].x = r;\n    ret.type = SPHERE;\n    ret.material = 0;\n    return ret;\n}\n\nstruct intersection{\n    float t;\n    vec3 normal;\n    int material;\n};\n\nbool solve_quadratic(float a, float b, float c, out float tMin, out float tMax){\n\tfloat d = b*b-4.0f*a*c;\n    if(d<0.0f)\n        return false;\n    tMin = (-b-sqrt(d))/(2.0f*a);\n    tMax = (-b+sqrt(d))/(2.0f*a);\n    return true;\n}\n\nbool intersect_sphere(inout ray r, in shape s, inout intersection i){\n    vec3 delta = s.q[0] - r.o;\n   \tfloat c = dot(delta,delta) - s.q[1].x*s.q[1].x;\n    float b = -2.0f*dot(r.d, delta);\n    float a = dot(r.d, r.d);\n    \n    float tMin, tMax;\n    \n    if(solve_quadratic(a,b,c,tMin,tMax)){\n        if(tMin>EPS && tMin<r.tMax){\n            i.t = tMin;\n            i.normal = normalize(i.t*r.d - delta);\n            r.tMax = i.t;\n            i.material = s.material;\n            return true;\n        } else if(tMax>EPS && tMax<r.tMax){\n        \ti.t = tMax;\n            i.normal =  normalize(i.t*r.d - delta);\n            r.tMax = i.t;\n            i.material = s.material;\n            return true;\n        } else {\n        \treturn false;\n        }\n    \n    } else {\n       return false;\n    }    \n\treturn false;\n}\n\n\n\nshape make_tri(vec3 v1, vec3 v2, vec3 v3){\n\tshape ret;\n    ret.q[0] = v1;\n    ret.q[1] = v2;\n    ret.q[2] = v3;\n    return ret;\n    \n}\n\nray getRay(vec2 fragCoord, mat3 rot){\n\tvec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    ray r;\n    r.o.x=0.0f;\n    r.o.y=0.0f;\n    r.o.z=3.0f;\n    \n\tr.d.x = (uv.x-0.5f)*aspect;\n    r.d.y = uv.y-0.5f;\n    r.d.z = -1.0f;\n    \n    r.o = rot*r.o;\n    r.d = rot*r.d;\n    \n    r.d = normalize(r.d);\n    \n    r.tMax = INF;\n    return r;\n\n}\n\nray makeRay(){\n    ray r;\n    r.o = vec3(0,0,0);\n    r.d = vec3(0,0,0);\n    r.tMax = INF;\n    r.depth = 0;\n    return r;\n}\nstruct light{\n\tvec3 o;\n    vec3 col;\n};\n\nstruct material{\n\tvec3 diff_col;\n    vec3 spec_col;\n    vec3 trans_col;\n    float d; //albedo\n    float r; //reflectance\n    float t; //transmittance\n    \n};\nstruct scene{\n   \tshape shapes[N_SHAPES];\n\tlight lights[N_LIGHTS];\n\tmaterial materials[2];\n};\n\n\n\nvec3 raycast(ray r, scene s){\n    vec3 colFin = vec3(0,0,0);\n    vec3 colMul = vec3(1,1,1);\n    while(r.depth<=DEPTH){ \n        vec3 col = vec3(0,0,0);\n    \n   \t\tbool hit = false;\n   \t\tintersection inter;\n   \t\tfor(int i = 0; i<N_SHAPES; i++){\n   \t\t    bool prev_hit = hit;\n   \t\t\thit = intersect_sphere(r, s.shapes[i], inter);\n   \t\t   \thit = hit || prev_hit;\n   \t\t}\n   \t\t\n   \t\t\n   \t\t\n   \t\tif(hit){\n            \n            //for every light\n            for(int i = 0 ; i<N_LIGHTS; i++){\n                \n           \t\thit = false;\n                ray sr;\n                sr.o = r.o + inter.t*r.d;\n                sr.d = s.lights[i].o-sr.o;\n                float l_sq = dot(sr.d,sr.d);\n                sr.d = normalize(sr.d);\n                sr.tMax = sqrt(l_sq);\n                //for all the scene\n           \t\tfor(int j = 0; j<N_SHAPES; j++){\n                intersection dummy;\n   \t\t   \t\t \tbool prev_hit = hit;\n   \t\t\t\t\thit = intersect_sphere(sr, s.shapes[j], dummy);\n   \t\t   \t\t\thit = hit || prev_hit;\n   \t\t\t\t}\n                \n                //add light if not hit\n                if(!hit){\n                    vec3 l_dir = sr.d;\n                    \n                    col += s.materials[inter.material].diff_col*s.lights[i].col\n                        \t*max(dot(l_dir, inter.normal),0.0f)*(1.0f/l_sq); \n   \t\t    \n                }\n                \n                \n            }\n            \n            //global illumination\n            if(s.materials[inter.material].r>EPS){\n                ray rr;\n                rr.o =  r.o + inter.t*r.d;\n                rr.d = normalize(r.d - 2.0f*dot(inter.normal, r.d)*inter.normal);\n                rr.depth = r.depth+1;\n                rr.tMax = INF;\n                r = rr;\n                colFin+=col*colMul;\n       \n                colMul = colMul*s.materials[inter.material].spec_col*s.materials[inter.material].r;\n    \n            } else {\n            \tcolFin+=col*colMul;\n            }\n        } else {\n        \tcol = vec3(1,0,1);\n            colFin+=col*colMul;\n            break;\n        }\n    }\n    return colFin;\n}\n\nmaterial make_material(vec3 dif, vec3 spec, vec3 trans,float d, float r, float t){\n\tmaterial mat;\n    mat.diff_col = dif;\n    mat.spec_col = spec;\n    mat.trans_col = trans;\n    mat.d = d;\n    mat.r = r;\n    mat.t = t;\n    return mat;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scene s;\n    s.shapes[0] = make_sphere(vec3(0.0f,0.0f,-1000.5f), 1000.0f);\n    s.shapes[1] = make_sphere(vec3(0.0f,0.0f,0.2f), 0.7f);\n    s.shapes[2] = make_sphere(vec3(0.0f,0.9f,-0.1f), 0.4f);\n    s.shapes[1].material = 1;\n    s.materials[0] = make_material(vec3(.8f, .2f, .8f), vec3(1,1,1),vec3(0.9f,0.2f,0.0f), .8f, .2f, 0.0f);\n    s.materials[1] = make_material(vec3(.5f, .5f, .5f), vec3(0.1f,0.1f,1.0f),vec3(0.0f,0.0f,0.9f), .8f, .2f, 0.0f);\n\n    \n    s.lights[0].o = vec3(2,2,2);\n    s.lights[0].col = vec3(2,2,2);\n    s.lights[1].col = vec3(4,1,1);\n    s.lights[1].o = vec3(-4,-1,2);\n\n   \n\tfloat theta = (iMouse.x/iResolution.x-0.5f)*2.0f*M_PI;\n\tfloat phi = iMouse.y/iResolution.y*M_PI;\n    theta = iTime;\n    phi= 1.0;\n\n   \tmat3 rot;\n    \n    float a = cos(-theta);\n    float b = sin(-theta);\n    float c = cos(phi);\n    float d = sin(phi);\n    \n    rot[0][0]=a;\n    rot[1][0]=-b*c;\n    rot[2][0]= b*d;\n    rot[0][1]= b;\n    rot[1][1]= a*c;\n    rot[2][1]= -a*d;\n    rot[0][2]= 0.0f;\n    rot[1][2]= d;\n    rot[2][2]= c;\n    \n  \tray r = getRay(fragCoord, rot);\n    \n   \t\t        \n   \tfragColor = vec4(raycast(r,s), 1.0f);\n    \n}","name":"Image","description":"","type":"image"}]}