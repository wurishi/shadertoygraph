{"ver":"0.1","info":{"id":"4lKGzW","date":"1473540835","viewed":243,"name":"Phoenix sets-orbit traps","username":"stduhpf","description":"The phoenix julia sets are defined by: \nz(n)=z(n-1)Â²+c+z(n-2)*p\nwith c and p complex (here they are real,beacause there can be only one mouse input)\nI added some orbit traps, because it looks better;\nIf you want, you can change supersampling at line 1","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","orbittraps","phoenix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ss 2\n//supersampling (anti aliasing) if you don't care about framerate, or if your gpu is unbreakable(<=>better than mine<=>not a poato),\n//you can set it to 2 or even 3 (more than 4 is useless)\n\n\n//if you want some documentation: http://usefuljs.net/fractals/docs/mandelvariants.html\n\n\n//#define mandelbrot_mode //(very ugly and useless to map the julia set)\n\n#define zoom 1.\n#define position vec2(0)\n\n#define iterations 150\n\n\n#define zoomspeed 1.\n\n\nvoid mainImage( out vec4 fColor, in vec2 fragCoord )\n{\n    vec4 fragColor=vec4(0);\n    vec2 p = iMouse.xy / iResolution.y-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5);\n    \n    \n    vec2 c =vec2(p.x,0);\n    p=vec2(p.y,0);\n    \n    p*=3.;\n    for(int i =0;i<ss*ss;i++)\n    {\n    vec2 uv = (fragCoord.xy+(vec2(mod(float(i),float(ss)),floor(float(i)/float(ss)))+.5)/float(ss))\n        / iResolution.y-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5);\n    \n   uv*=3.*zoom;\n    uv+=position;\n    \n      #ifdef mandelbrot_mode\n    p=vec2(uv.y,0);\n    c=vec2(uv.x,0);\n    #endif\n    if(iMouse.xy==vec2(0))\n    {\n        uv/=exp(12.*(.5-cos(zoomspeed*iTime*acos(-1.)/60.)*.5));        //periodic zoom (1min zooming,1min unzooming)\n         //uv*=mat2(cos(.1*iTime*acos(-1.)),sin(.1*iTime*acos(-1.)),-sin(.1*iTime*acos(-1.)),cos(.1*iTime*acos(-1.)));//rotate the plane\n        uv+=vec2(.41002,.22);\n       \n        \n       p= vec2(-.5,0);\n     c=vec2(.56667,0)  ;\n    }\n    vec2 z1=uv;\n    vec2 z=uv;\n  \n    vec4 dmin=vec4(1000);\n    for(int i =0;i<iterations;i++)\n    {\n        vec2 z2 = z;\n        z=z*mat2(z.x,-z.y,z.yx)+c+z1*mat2(p.x,-p.y,p.yx);\n        z1=z2;\n        \n\t\tdmin=min(dmin, vec4(abs(length(z1)-length(z))\n                           ,length(sin(z))*length(uv)\n                           ,abs(z.x)\n                           ,abs(dot(z,z1))));\n    }    \n    vec3 color = vec3( pow(dmin.r,0.6) );\n\tcolor = mix( color, vec3(1.00,0.50,0.20), min(1.0,pow(dmin.w*0.5,0.40)) );\n    color = mix( color, vec3(0.4,0.70,0.40), min(1.0,pow(dmin.y*.1,0.50)) );\n\tcolor = mix( color, vec3(1.00,.70,.50), 1.0-min(1.0,pow(dmin.z*1.00,0.15) ));\n\n\n\tfragColor += vec4(color,1.0);\n    }\n    fColor = fragColor/float(ss*ss);\n}","name":"Image","description":"","type":"image"}]}