{"ver":"0.1","info":{"id":"fsffWH","date":"1644769153","viewed":1107,"name":"Holographic storage","username":"tdhooper","description":"Noodling with the 'ol xray effect","likes":67,"published":1,"flags":32,"usePreview":1,"tags":["vfx","neon","xray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec3 col = tex.rgb / tex.a;\n\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    col += (texture(iChannel1, fragCoord / iChannelResolution[1].xy).rgb * 2. - 1.) * .005;\n\n    fragColor = vec4(col, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nstruct Model {\n    float d;\n    vec3 col;\n    int id;\n};\n\nfloat t;\n\nModel map(vec3 p) {\n    \n    vec3 col = normalize(p) * .5 + .5;\n\n    p -= sin(p.y * 15. + t * PI * 2. * 3.) * .05;\n\n    vec3 ps = p * mix(50., 100., smoothstep(-1., 1., p.y));\n    p += ((sin(ps.x) + sin(ps.z) + sin(ps.y))) * .02 * smoothstep(-1., 1., p.y);\n\n    p += sin(p.y * 10. + t * PI * 2. * 3.) * .05;\n    p += sin(p * 8. + t * PI * 2.) * .1;\n    \n    float r = 1.;\n    p -= r * .5;\n    vec3 o = floor(p / r + .5);\n    o = clamp(o, vec3(-1,-2,-1), vec3(0,1,0));\n    p -= o * r;\n    col = mix(col, normalize(p) * .5 + .5, .5);\n\n    float d = sdBoundingBox(p, vec3(.3), .5);\n    return Model(d, col, 1);\n}\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst float sqrt3 = 1.7320508075688772;\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvec3 draw(vec2 fragCoord, int frame) {\n\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n        \n    vec2 seed = hash22(fragCoord + (float(frame)) * sqrt3);\n    \n    p += 2. * (seed - .5) / iResolution.xy;\n\n    vec3 camPos = vec3(0,0,8);\n    \n    pR(camPos.yz, PI * .2);\n    pR(camPos.xz, PI * .25);\n\n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0), vec3(0,1,0));\n    \n    float focalLength = 60.;\n    camPos *= focalLength / 3.;\n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n    \n    vec3 col = vec3(0);\n\n    vec3 rayPosition;\n    float rayLength = 0.;\n    Model model;\n        \n    float maxlen = 10. * focalLength;\n    int iter = 200;\n    float eps = .00004;\n    \n    for (int i = 0; i < iter; i++) {\n        rayPosition = origin + rayDir * rayLength;\n        model = map(rayPosition);\n        \n        float d = max(eps, abs(model.d));\n        rayLength += d * (1. - seed.x * .125);\n        \n        seed = hash22(seed);\n \n        if (rayLength > maxlen) {\n            break;\n        }\n        \n        col += model.col / pow(d, .125) * .002;\n    }\n\n    return col;\n}\n\n#define ANIMATE\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    t = .1;\n    \n    #ifdef ANIMATE\n        t = fract(iTime / 4.);\n        vec4 col = vec4(0.);\n        const int c = 4;\n        for (int i = 0; i < c; i++) {\n            col += vec4(draw(fragCoord, iFrame * c + i), 1);\n        }\n        col /= float(c);\n    #else\n        vec4 col = vec4(draw(fragCoord, iFrame), 1);\n        if (iFrame > 0 && iMouse.z <= 0.) {\n            vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n            col += lastCol;\n        }\n    #endif\n    \n    fragColor = col;\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}