{"ver":"0.1","info":{"id":"tdlBz4","date":"1587830264","viewed":102,"name":"Pinwheel Tiling","username":"notfancy","description":"The Radin-Conway, or Pinwheel Tiling is a nonperiodic tiling in which triangles appear in countably infinite rotations. Each triangle is shaded with a red value proportional to the rotation angle, reduced to between 0° and 90° and discounting reflections.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See http://tilings.math.uni-bielefeld.de/substitution/pinwheel/\n\n#define NITERS 7 // Change to alter the subdivision fineness\n#define BORDER 0\n#define T (iTime / 10.0) // Change to alter speed\n\n/*\n * In the following, let P, Q, R denote the vertices of a right triangle PQR of\n * sides 1:2:√5, with short side PQ and long side QR, like the following:\n * \n *   P\n *   +\n *   |\\__\n *   |   \\_____\n *   |         \\____\n *   |              \\____\n *   |                   \\_____  √5\n * 1 |                         \\____\n *   |                              \\____\n *   |                                   \\_____\n *   |                                         \\___\n *   +-+                                           \\\n *   +-+--------------------------------------------+\n * Q                       2                        R\n *\n */\n\n/*\n * The vector ⟂{x, y} == {-y, x} perpendicular to the given vector.\n * The key properties of this \"2D cross vector\" are, for all vectors u, v:\n *\n * - ⟂⟂v == -v\n * - v•⟂v == 0\n * - u•⟂v == -v•⟂u\n * - u•⟂v == |u|*|v|*sin(α), with α the angle between u and v in that order\n *\n * When u•v is the parallel component of v along u,\n * then u•⟂v is the perpendicular component of v along u.\n *\n * See Francis S. Hill, \"The Pleasures of 'perp dot' Products\", in Graphics Gems IV\n */\n#define PERP(v) (vec2(-v.y, v.x))\n\n/*\n * A point X is inside the triangle PQR iff its barycentric coordinates (s:t:1-s-t) are\n * in the range [0, 1]; that is, iff there exist 0 ≤ s, t ≤ 1; 0 ≤ s + t ≤ 1 such that\n * X == s*P + (1 - s - t)*Q + t*R == s*(P - Q) + Q + t*(R - Q).\n *\n * In the 1:2:√5 right triangle, ±2*(P - Q) = ⟂(R - Q), with the plus-minus sign\n * accounting for orientation. Substituting and solving for s, t we have:\n *\n * s == (X - Q)•(P - Q) / (P - Q)•(P - Q)\n * t == (X - Q)•(R - Q) / (R - Q)•(R - Q)\n *\n * The point X is then inside the triangle PQR iff s, t, s + t are all in range [0, 1].\n */\n\n/*\n * Return the barycentric coordinates (s : t : 1-s-t) of point X in 1:2:√5 triangle PQR.\n */\nvec3 barycentric(in vec2 x, in vec2 p, in vec2 q, in vec2 r)\n{\n    vec2 u = x - q;\n    vec2 v = p - q;\n    vec2 w = r - q;\n    float s = dot(u, v)/dot(v, v);\n    float t = dot(u, w)/dot(w, w);\n    return vec3(s, t, 1.0 - s - t);\n}\n\n/*\n * Test if point X lies inside the 1:2:√5 triangle PQR.\n * The predicate rearranges the calculation above to avoid divisions.\n */\nbool ptInTriangle(in vec2 x, in vec2 p, in vec2 q, in vec2 r)\n{\n    vec2 u = x - q;\n    vec2 v = p - q;\n    vec2 w = r - q;\n    float a = dot(u, v);\n    float b = dot(v, v);\n    float c = dot(u, w);\n    float d = dot(w, w);\n    return 0.0 <= a && a <= b && 0.0 <= c && c <= d && a*d + b*c <= b*d;\n}\n\n/*\n * Return +1 if the 1:2:√5 triangle PQR is in CCW orientation, that is,\n * if the short side PQ is CCW to the long side QR; otherwise return -1.\n */\nfloat ccw(in vec2 p, in vec2 q, in vec2 r)\n{\n    vec2 u = p - q;\n    vec2 v = r - q;\n    vec2 w = PERP(v);\n    return 2.0 * dot(u, w) / dot(v, v);\n}\n\n#define PI 3.14159265359\n\n/*\n * Compute the orientation α ∈ [0, 1] of the 1:2:√5 triangle PQR,\n * as a fraction of π/2, modulo vertical reflections and rotations by π/2.\n */\nfloat rot(in vec2 p, in vec2 q, in vec2 r)\n{\n    vec2 u = r - q;\n    float a = (2.0 / PI) * ccw(p, q, r) * atan(u.y, u.x);\n    return fract(a);\n}\n\n/*\n * Color point X in triangle PQR with hash H according to its orientation.\n */\nvec3 color(in vec2 x, in float h, in vec2 p, in vec2 q, in vec2 r)\n{\n    vec3 c = vec3(1.0, h, h);\n    vec3 y = barycentric(x, p, q, r);\n    //c = y;\n#if BORDER\n    float s = min(y.x, min(y.y, y.z));\n    c = mix(vec3(0.0), c, smoothstep(0.0, 5.0*float(NITERS)/iResolution.x, s));\n#endif\n    return c;\n}\n\n/*\n * The base case decides in which of the two triangles resulting from dividing a\n * 1:2 rectangle along the diagonal the point X lies.\n * \n * This triangle is then subdivided in points S, T, U, V with QU ⟂ RP, ST ⟂ RP and\n * SV ⟂ QU, such that the resulting triangles are similar, in the following order:\n * \n * P=(0,1)                                      (2,1)\n * +------------------------------------------------+\n * |\\__                                             |\n * |   \\____U=(2/5,4/5)                             |\n * |       /\\_____                                  |\n * |  1   /  \\_   \\____                             |\n * |     /     \\_      \\____                        |\n * |  V /   3    \\_         \\____T=(6/5,2/5)        |\n * |   /\\__        \\_    4      /\\____              |\n * |  /    \\____     \\_        /      \\_____        |\n * | /   2      \\___   \\_     /    5        \\____   |\n * |/               \\____\\_  /                   \\__|\n * +-----------------------\\/-----------------------+\n * Q=(0,0)               S=(1,0)              R=(2,0)\n *\n * V=(1/5,2/5)\n *\n * The point X is tested against each of these five smaller triangles, and the process\n * is repeated with new points P, Q, R in the same order as above, to the specified\n * number of iterations.\n *\n * By keeping track of the triangle index at each subdivision, one can compute\n * a hash of the input point X corresponding uniquely to the triangle containing it.\n */\n\n/*\n * Test point X with 0 ≤ X.x ≤ 2, 0 ≤ X.y ≤ 1 against the tiling of depth n.\n * Return the tile color as a vec3.\n */\nvec3 tile(in vec2 x, in int n)\n{\n    float h = 0.0; // hash, or sequence of triangles in the subdivision\n    \n    // Base case\n    vec2 p, q, r;\n    if (x.y + 0.5 * x.x <= 1.0) {\n        p = vec2(0.0, 1.0);\n        q = vec2(0.0, 0.0);\n        r = vec2(2.0, 0.0);\n        h = 0.0;\n    } else {\n        p = vec2(2.0, 0.0);\n        q = vec2(2.0, 1.0);\n        r = vec2(0.0, 1.0);\n        h = 0.5;\n    }\n\n    // Subdivide\n    for (int i = 0; i < n; i++) {\n\t\tvec2 s = mix(q, r, 0.5);\n        vec2 u = mix(p, r, 0.2);\n        vec2 t = mix(u, r, 0.5);\n        vec2 v = mix(q, u, 0.5);\n        // Find the enclosing triangle among\n        // {p, u, q}, {q, v, s}, {u, v, s}, {s, t, u}, {s, t, r}\n        if (ptInTriangle(x, p, u, q)) {\n            r = q;\n            q = u;\n            h += 0.0;\n        } else if (ptInTriangle(x, q, v, s)) {\n            p = q;\n            q = v;\n            r = s;\n            h += 1.0;\n        } else if (ptInTriangle(x, u, v, s)) {\n            p = u;\n            q = v;\n            r = s;\n            h += 2.0;\n        } else if (ptInTriangle(x, s, t, u)) {\n            p = s;\n            q = t;\n            r = u;\n            h += 3.0;\n        } else if (ptInTriangle(x, s, t, r)) {\n            p = s;\n            q = t;\n            h += 4.0;\n        }\n        h *= 0.2;\n    }\n    // At this point, 0 ≤ h < 1\n    return color(x, h, p, q, r);\n}\n\nfloat triangle(in float x)\n{\n    return 1. - 2.*abs(fract(x) - 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float k = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / k;\n    // 0 ≤ p.x < 2, 0 ≤ p.y < 1\n\tvec2 p = vec2(2.0*fract(uv.x), fract(2.0*uv.y));\n    int n = int(round(float(NITERS) * triangle(T)));\n    vec3 col = tile(p, n);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}