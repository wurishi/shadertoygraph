{"ver":"0.1","info":{"id":"Mf2GWK","date":"1704654191","viewed":58,"name":"Happy Tetrahedral 2024 New Year!","username":"sylvain69780","description":"Happy Tetrahedral 2024 New Year!\n\nThere are 2024 balls; you can count them!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","tetrahedron","fcc"],"hasliked":0,"parentid":"ttyfDV","parentname":"Egg Hunt"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Happy Tetrahedral 2024 New Year!\n    --------\n\n    Happy new year to you all the great Shadertoy community !\n\n    Related references\n    \n    2024 année tétraédrique ! - Micmaths (french)\n    https://www.youtube.com/watch?v=i31mOUnHT-E\n        \n    Tetrahedron SDF - xy\n    https://www.shadertoy.com/view/Ws23zt\n\n    Tetrahedral Voxel Traversal - fizzer\n    https://www.shadertoy.com/view/wtfXWB\n\n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n    \n    BigWIngs code for domain repetition\n    Comment in Blackle shader \n    https://www.shadertoy.com/view/Wl3fD2    \n    \n    iResolution, iMouse, iDate, etc - Fabrice Neyrey \n    https://www.shadertoy.com/view/llySRh\n    \n*/\n\n\n#define MAX_STEPS 200\n#define MAX_DIST 60.\n#define SURF_DIST .001\n\n#define T (iTime+2.)\n\n// Blackle Mori\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n// Tetrahedron SDF - xy\n// https://www.shadertoy.com/view/Ws23zt\nfloat sdTetrahedron (vec3 p)\n{\n    return (max(\n\t    abs(p.x+p.y)-p.z,\n\t    abs(p.x-p.y)+p.z\n\t)-1.)/sqrt(3.);\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nconst vec3 up = vec3(1./sqrt(3.));\n\nvec2 GetDist2(vec3 p,vec3 id) \n{\n\n    const vec3 spheres[4] = vec3[](\n        vec3(1.0),\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n    vec3 par = mod(id,2.0);\n    vec3 octant = 2.*par-1.;\n    vec2 dm = vec2(1e10,0);\n    float hideLevels = smoothstep(-1.0,1.0,cos(T))*30.;\n    for (int i=0;i<4;i++)\n    {\n        vec3 sphere = spheres[i];\n        vec3 qq = id+.5-par+sphere*octant;\n         float density = sdTetrahedron(qq)-7.;\n         if (density > sqrt(3.)) return dm;\n         float dup = dot(qq,up);\n         float bottom = 5.3+dup;     \n         float hide =  dup+8.5-hideLevels;     \n         density = max(density,-bottom);     \n        if ( density < 0. && ( hide <2.5 || bottom <= 2.) )\n        {\n            vec3 q = p*octant + .5 - sphere;\n            float r = 0.74;\n            if ( bottom > 2.)\n                r*=smoothstep(2.5,-2.5,hide);\n            dm = opU(dm,vec2(length(q)-r,float(i)+1.0));\n        }\n    }\n    return dm;\n}\n    \nfloat GetDist(vec3 p,vec3 id)\n{\n    return GetDist2(p,id).x;\n}\n\n// BigWIngs code for domain repetition\n// Comment in Blackle shader https://www.shadertoy.com/view/Wl3fD2\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec3 dir = sign(rd)*.5;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        vec3 q = fract(p)-.5,    // get repeated domain   //// p-clamp(round(p),0.,3.),    // get repeated domain\n        rC = (dir-q)/rd;\t// ray to cell boundary\n        float dC = min(min(rC.x, rC.y), rC.z)+.0001;// distance to cell just past boundary\n        vec3 id=floor(p);\n        float dS = GetDist(q,id);\n        // get either distance to object in current cell\n        // or distance (along ray) to cell boundary\n        dO += min(dS, dC);                \n        //dO += dS;        // normal version, with artifacts\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p,vec3 id) {\n\tfloat d = GetDist(p,id);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy,id),\n        GetDist(p-e.yxy,id),\n        GetDist(p-e.yyx,id));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 2.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        vec3 q=fract(opos)-.5;\n        vec3 id=floor(opos);\n        float d = GetDist(q,id);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx, dFdy );\n}\n\nvec3 Print2024(vec2 uv, vec3 col)\n{\n    // usage of text texture\n    // --- chars\n        /*\n            int CAPS=0;\n            #define low CAPS=32;\n            #define caps CAPS=0;\n            #define spc  U.x-=.5;\n            #define C(c) spc O+= char(U,64+CAPS+c);\n            // NB: use either char.x ( pixel mask ) or char.w ( distance field + 0.5 )\n     */\n    if ( uv.y < 0. || uv.y >= 1. || uv.x <0. || uv.x >= 4.)\n        return col;\n    int _c;                         \n    int idx=int(uv.x);\n    //int a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9,j=10,k=11,l=12,m=13,n=14,o=15,p=16,q=17,r=18,s=19,t=20,u=21,v=22,w=23,x=24,y=25,z=26,num0=48-64,num2=50-64,num1=49-64,num4=52-64;\n    _c = 64 + int[]( -14,-16,-14,-12) [idx];\n    vec4 text = char((fract(uv)),_c);\n    return mix(col,vec3(0),text.r);    \n}\n\nvec3 PrintTetrahedral(vec2 uv, vec3 col)\n{\n    if ( uv.y < 0. || uv.y >= 1. || uv.x <0. || uv.x >= 11.)\n        return col;\n    int _c;                         \n    int idx=int(uv.x);\n    int a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9,j=10,k=11,l=12,m=13,n=14,o=15,p=16,q=17,r=18,s=19,t=20,u=21,v=22,w=23,x=24,y=25,z=26,num0=48-64,num2=50-64,num1=49-64,num4=52-64;\n    _c = 64 + int[](t,e+32,t+32,r+32,a+32,h+32,e+32,d+32,r+32,a+32,l+32) [idx];\n    vec4 text = char((fract(uv)),_c);\n    return mix(col,vec3(0),text.r);\n}\n\nvec3 PrintYear(vec2 uv, vec3 col)\n{\n    if ( uv.y < 0. || uv.y >= 1. || uv.x <0. || uv.x >= 4.)\n        return col;\n    int _c;                         \n    int idx=int(uv.x);\n    int a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9,j=10,k=11,l=12,m=13,n=14,o=15,p=16,q=17,r=18,s=19,t=20,u=21,v=22,w=23,x=24,y=25,z=26,num0=48-64,num2=50-64,num1=49-64,num4=52-64;\n    _c = 64 + int[](y,e+32,a+32,r+32) [idx];\n    vec4 text = char((fract(uv)),_c);\n    return mix(col,vec3(0),text.r);\n}\n\nvec3 PrintHappy(vec2 uv, vec3 col)\n{\n    if ( uv.y < 0. || uv.y >= 1. || uv.x <0. || uv.x >= 5.)\n        return col;\n    int _c;                         \n    int idx=int(uv.x);\n    int a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9,j=10,k=11,l=12,m=13,n=14,o=15,p=16,q=17,r=18,s=19,t=20,u=21,v=22,w=23,x=24,y=25,z=26,num0=48-64,num2=50-64,num1=49-64,num4=52-64;\n    _c = 64 + int[](h,a+32,p+32,p+32,y+32) [idx];\n    vec4 text = char((fract(uv)),_c);\n    return mix(col,vec3(0),text.r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;   \n    vec3 ro = vec3(0, 9, 38.);\n    vec3 ta = vec3(0,0,0);\n    \n    if ( iMouse.x > 0.0 ) {\n        m=2.0*iMouse.xy/iResolution.xy-1.0;\n        ro *= (1.+m.y*.4);\n        ro = erot(ro,up,m.x*3.15149);\n    }\n    else\n        ro = erot(ro,up,iTime*.5);\n    vec3 rd = GetRayDir(uv-vec2(0,-.15), ro, ta, 1.);\n    vec3 bgCol = vec3(1.0)*cos(length(1.2*uv));;\n    vec3 col = bgCol; \n        \n    float d = RayMarch(ro, rd);\n    if(d<MAX_DIST) { \n        vec3 p = ro + rd * d,\n        q = fract(p)-.5;\n        vec3 id=floor(p);\n        vec2 dm = GetDist2(q,id);\n        float m = dm.y;\n        vec3 hu = hue(m*.25).rgb;\n        vec3 c = .6+.38*cos(6.2832*(m-1.)*.25+vec3(0,1,2)); // Palette https://www.shadertoy.com/view/Dddfz7\n        vec3 n = GetNormal(q,id);\n        vec3 r = reflect(rd, n);\n        vec3 ld = normalize(ro);\n        float dif = dot(n,ld)*.5+.5;\n        vec3 ref = texture(iChannel0, r).rgb;\n        if ( dm.y == 10.)\n            ref = vec3(.5);\n        float occ = calcOcclusion(p,n);\n        col = ref*dif*c*occ;\n        // fog\n        float fog=smoothstep(35.0,80.0,d);\n        col = mix(col,bgCol, fog);\n    }\n    float slider = smoothstep(-.3,1.,cos(T));\n    col = Print2024(uv*9.-vec2(1.+12.*slider,2.9+.2*abs(cos(iTime*10.))),col);\n    col = PrintHappy(uv*10.-vec2(-4.-12.*slider,3.5),col);\n    col = PrintTetrahedral(uv*12.-vec2(-5.+slider*20.,2.5),col);\n    col = PrintYear(uv*10.-vec2(-1.5-slider*12.,0.6),col);\n    col = pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}