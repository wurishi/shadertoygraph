{"ver":"0.1","info":{"id":"cdd3W7","date":"1677371455","viewed":109,"name":"Pebbled column","username":"greatbluewhale","description":"Uses a simply/hacky layer-slicing of a heightmap to give a 3D effect to the pebbles.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["heightmap","deptheffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SQRT3D2 = sqrt(3.0)/2.0;\nconst float PI = 3.14159;\n// don't need to prebake hexagonal prism, we'll be rotating it anyways\n// so just as easy to dynamically define planes\n// for angle a, plane.n = (cos(a), 0, sin(a)), plane.r = sqrt(3)/4\nconst int SLICES = 8;\nconst float DEPTH = 0.1;\n\nfloat tex(vec2 uv) {\n    float h = texture(iChannel0, uv).r;\n    // add a border to make edges nicer\n    if (uv.x >= 0.2 && uv.x <= 0.8 && uv.y >= 0.1 && uv.y <= 0.9) {\n        return h;\n    }\n    float d = min(min(uv.x, 1.0 - uv.x) / 0.2, min(uv.y, 1.0 - uv.y) / 0.1);\n    return 1.0 - d * (1.0 - h);\n}\n\nfloat getHeight(vec2 uv, vec2 duv) {\n    for (int d = 0; d < SLICES; ++d) {\n        vec2 hit = uv + float(d) / float(SLICES - 1) * DEPTH * duv;\n        float h = tex(hit);\n        float minH = float(SLICES - d - 1) / float(SLICES);\n        float maxH = float(SLICES - d) / float(SLICES);\n        if (h >= minH) {\n            return 0.8 * clamp(h, minH, maxH);  // clamp alleviates some ringing artifacts and improves edge behaviour\n            return 0.8 * (1.0 - float(d) / float(SLICES - 1));  // this does flat-out toon shading\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const vec3 eye = vec3(0.0, 0.0, 2.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screen = (fragCoord - iResolution.xy / 2.0) / iResolution.yy;\n    vec3 view = vec3(screen.x, screen.y, -SQRT3D2);\n    \n    float angle = (1.0 - fract(iTime)) * PI / 3.0; // rotate at PI/3 rad/s, want base angle\n\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    // Test ray against each forward-facing plane\n    for (int i = 0; i < 3; ++i) {\n        float sideA = angle + float(i) * PI / 3.0;\n        vec3 sideN = vec3(cos(sideA), 0, sin(sideA));\n        vec3 sideC = SQRT3D2 / 2.0 * sideN;\n        // ray-plane intersection\n        float l = dot(view, sideN);\n        // We have a front-facing hit\n        if (l < 0.0) {\n            float d = dot(sideC - eye, sideN) / l;\n            vec3 hit = eye + d * view;\n            vec3 off = hit - sideC;\n            vec3 rTan = cross(vec3(0.0, 1.0, 0.0), sideN);\n            vec2 uv = vec2(dot(off, rTan), off.y);\n            uv = uv / vec2(0.5, 1.5) + vec2(0.5, 0.5);\n            if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {\n                vec2 duv = vec2(dot(view, rTan), view.y) / -l;\n                float h = getHeight(uv, duv);\n                fragColor = vec4(h, h, h, 1.0);\n                break;\n            }\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}