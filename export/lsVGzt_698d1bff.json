{"ver":"0.1","info":{"id":"lsVGzt","date":"1456002374","viewed":693,"name":"Shadow casting 2D point lights","username":"dine909","description":"An experiment using raymarching in a 2d world to map light casted to a point.  The idea was to use the same sdf map function to draw the solids, and cast the shadows.  \n\nIt's not very accurate, but was fun to write.\n\nMousing encouraged.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","light","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nconst vec2 constantList = vec2(1.0, 0.0);\n\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\n\nfloat asrat;\nstruct Obj{    int type;    vec3 col;    vec2 pos;    float emis;}T_Obj;\nstruct Hit{    float d,t;    vec2 pos;    Obj obj;}T_Hit;\nstruct Ray{    vec2 ro,rd;    float tmin,tmax;}T_Ray;\nconst Obj NoObj=Obj(-1,vec3(0.),vec2(0.),0.);\nconst Hit NoHit=Hit(400.,400.,vec2(0.),NoObj);\n\nfloat sdCircle(vec2 p){    return distance(p,vec2(0.));}\nfloat sdBox(vec2 p, vec2 size, float radius)\n{\n    vec2 d = abs(p) - size-vec2(radius);\n    return clamp(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius,0.,1.);\n}\n\nHit renderSdf(vec2 p,inout Obj o)\n{\n    Hit hit=NoHit;\n    if(o.type==1) hit= Hit(sdCircle(p-o.pos),0.,p,o);\n    if(o.type==2) hit= Hit(sdBox(p-o.pos,vec2(0.02),0.),090.1,p,o);\n    return hit;\n}\nHit sdU(in Hit a,vec2 p,in Obj d)\n{\n    Hit hit=renderSdf(p,d);\n    if (a.d<hit.d) \n        return (a); else return (hit);\n}\n\nHit map(vec2 p, in Obj oo)\n{\n\t//----8<----- SOLIDS ----8<-----//\n\n    const vec3 solidCol=vec3(0.95,0.57,0.);\n\n    Hit hit=NoHit;\n    hit=sdU(hit,p,Obj(1,solidCol,vec2(0.5*asrat,0.5),0.));\n    hit=sdU(hit,p,Obj(1,solidCol,vec2(0.5*asrat,0.8),0.));\n    hit=sdU(hit,p,Obj(2,solidCol,vec2(0.53*asrat,0.2),0.));\n    hit=sdU(hit,p,Obj(2,solidCol,vec2(0.53*asrat,0.3),0.));\n    hit=sdU(hit,p,Obj(2,solidCol,vec2(0.47*asrat,0.2),0.));\n    hit=sdU(hit,p,Obj(2,solidCol,vec2(0.47*asrat,0.3),0.));\n    return hit;\n}\n\nvec3 render(vec3 incol,inout Hit hit)\n{\n    float aares=clamp(antiAlias(smoothstep(((1.-hit.d)), .977, 0.)),0.,1.);\n    if(aares==0.)\n    {\n        hit=NoHit;    \n    }\n    return mix(incol,hit.obj.col,aares);\n}\nHit castRay(in Ray ray){\n    float precis =.023;\n    float t = ray.tmin;\n    Hit hit=NoHit;\n    vec2 p;\n    for( int i=0; i<200; i++ )\n    {\n        p=ray.ro+ray.rd*t;\n        hit = map( p,NoObj );\n        if( hit.d<precis || t>ray.tmax ) break;\n        t += hit.d;\n    }\n    hit.t=t;\n\n    if( t>ray.tmax ) return NoHit;\n    return hit;\n\n}\nfloat getFloor(vec2 uv){    return mod( floor(32.0*(uv.x/asrat)) + floor(18.0*(uv.y)), 2.0);}\n\nvec3 getLight(vec2 uv, Obj light)\n{\n    float rot=atan(uv.y-light.pos.y, uv.x-light.pos.x);\n    Hit hit=castRay(Ray(light.pos.xy,vec2(sin(rot),cos(rot)).yx,.0001,distance(light.pos,uv)));\n\n    render(vec3(0.),hit);\n\n    float lamnt=10.5*distance(uv,light.pos);\n    lamnt=pow((1.2/(lamnt*lamnt)),.5)*0.39*light.emis;\n\n    vec3 lcol=vec3(0.01);        \n    if(hit==NoHit)\n    {\n        lcol+=light.col*lamnt;\n    }\n\n    lcol-=lamnt*light.col*0.5*getFloor(uv);\n\n\n    return lcol;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 um = iMouse.xy / iResolution.xy;\n    vec4 col = vec4(0.0);\n\n    asrat=iResolution.x/iResolution.y;\n\n    if(iMouse.z<0.5)\n    {\n        um=0.5+0.4*vec2(sin(iTime),cos(iTime));\n    }\n\n    uv.x*=asrat;um.x*=asrat;\n\n    Hit hit=map(uv,NoObj);\n    col.rgb +=render(vec3(0.),hit);\n\n    if(hit==NoHit)\n    {\n        //----8<----- LIGHTS ----8<-----//\n\n        col.rgb+=getLight(uv, Obj(1,vec3(0.5,1.,.5),um,1.));\n        col.rgb+=getLight(uv, Obj(1,vec3(1.,.5,.5),vec2(asrat-um.x,1.-um.y),2.));\n    }\n\n    fragColor = col.xyzw * constantList.xxxy + constantList.yyyx;\n}","name":"Image","description":"","type":"image"}]}