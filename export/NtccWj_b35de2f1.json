{"ver":"0.1","info":{"id":"NtccWj","date":"1660655238","viewed":104,"name":"To the Earthend!","username":"mielikki","description":"Hatapon-*\nI'm just learning and this is my first animated glsl shader drawing UwU\nthat was hard and took many days","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","patapon","hatapon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//global const, shouldn't be changed\nconst float groundSize = 0.2;\nconst float treeRad = 0.4;\n\nbool isCircle(in vec2 uv, in float radius){\n     return length(uv)-radius<0.0;\n}\nbool isRectangle( in vec2 uv, in vec2 size )\n{\n    vec2 dist = abs(uv)-size;\n    return length(max(dist,0.0)) + min(max(dist.x,dist.y),0.0) < 0.0;\n}\nbool isRoundRectangle( in vec2 uv, in vec2 size ){\n    vec2 p1;\n    vec2 p2;\n    if(size.x>size.y) {\n        p1 = uv - vec2(size.x,0.0);\n        p2 = uv + vec2(size.x,0.0);\n    }\n    else{\n        p1 = uv - vec2(0.0,size.y);\n        p2 = uv + vec2(0.0,size.y);\n    }\n    float rad = min(size.x,size.y);\n    return isRectangle(uv, size) || isCircle(p1, rad) || isCircle(p2, rad);\n}\nbool isRoundRectangleFromPoint(in vec2 start, in vec2 end){\n\n    vec2 length = abs(end-start);\n    length*=0.5;\n    vec2 startPoint = vec2(\n        min(start.x, end.x),\n        min(start.y, end.y)\n    );\n    startPoint.x+=length.x;\n    return isRoundRectangle(\n        startPoint-length,\n        length\n    );\n}\nbool isFeather(vec2 uv)\n{\n    float r1=0.02;\n    float r2=0.04;\n    float height = 0.18;\n    uv.x = abs(uv.x);\n    float b = (r1-r2)/height;\n    float a = sqrt(1.0-b*b);\n    float k = dot(uv,vec2(-b,a));\n    if( k < 0.0 ) return false;\n    if( k > a*height ) return length(uv-vec2(0.0,height))<r2;\n    return dot(uv, vec2(a,b) ) - r1<0.0;\n}\nmat2 getAngleMultiplier(in float angle){\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\nvoid drawTree(in vec2 uv, in float treeHeight, inout vec4 fragColor){\n    if(isCircle(uv-vec2(0.0,treeHeight-treeRad*0.309),0.4)){\n        fragColor*=vec4(0.6,1.0,0.8,0.8);\n    }\n\n    if(isRoundRectangleFromPoint(uv,uv+vec2(0.05,treeHeight))){\n        fragColor=vec4(0.8,1.0,1.0,1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 group1 = uv;\n    vec4 black = vec4(0.0,0.0,0.0,1.0);\n    vec4 white = vec4(1.0,1.0,1.0,1.0);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //bg----------------------------------\n    //sky\n    fragColor=vec4(-uv.y*0.1+0.9,uv.y*0.2+0.8,uv.y*1.5+1.8,1.0);\n\n    \n    //trees\n        vec2 treeStart = uv;    \n        treeStart.y+=1.0-groundSize;\n        treeStart.x+=iTime;\n        treeStart.x = mod(treeStart.x+iTime*0.02, 4.0) - 2.5;\n        //treeStart.x = mod(treeStart.x, 2.7) - 0.5;\n    for(int i=0;i<2;i++){\n        float floatI = float(i);\n        vec2 tree = treeStart+vec2(floatI*2.0,0.0);\n        tree*=1.0+floatI*0.2;\n        vec2 treeOrigin = tree;\n        drawTree(tree, 0.6, fragColor);\n        tree.y-=0.2;\n        tree*=getAngleMultiplier(0.8+floatI*0.4);\n        tree*=3.0-floatI*0.5;\n        drawTree(tree, 1.2-floatI*0.4, fragColor);\n                if(i==0){\n                vec2 tree2 = treeOrigin;\n        tree2*=3.2;\n        tree2.y-=0.25;\n        tree2*=getAngleMultiplier(-1.2);\n        drawTree(tree2, 0.8, fragColor);\n                }\n        \n    }\n    \n    //tree.x+=mod(tree.x,3.0);\n    /*for(int i=0;i<3;i++){\n        vec2 tree1 = tree;\n        tree1.y+=1.0-groundSize;\n        tree1.x+=iTime;\n        tree1.x = mod(tree1.x, 1.5);\n        drawTree(tree1, 0.6, fragColor);\n        tree1.y-=0.2;\n        tree1*=getAngleMultiplier(1.0);\n        tree1*=2.8;\n        drawTree(tree1, 1.2, fragColor);\n    }*/\n    \n    //ground\n    if(uv.y<-1.0+groundSize){\n        fragColor=vec4(uv.y*1.8+2.2,0.1,0.5,1.0);\n    }\n    \n    //[[[ non bg part ]]]---------------------------------\n    //flag\n    group1*=getAngleMultiplier(cos(iTime)*0.1);\n    \n    float flagPos = 0.3;\n    float flagSize = 0.5;\n    float flagHeight = 0.85;\n    float flagShape = 2.2;\n    float flagSensitivity = 5.2;\n    float poleHeight=0.7;\n    float top = 0.2;\n    float lineThickness=0.02;\n    float polePos = poleHeight-top;\n    group1.y-=flagPos;\n    group1.x+=flagSize*0.5;\n    vec2 pole0 = group1-vec2(flagSize*polePos,flagPos);\n    //pole horizontal\n    if(isRoundRectangle(pole0,vec2(flagSize*0.6,lineThickness))){\n        fragColor = black;\n    }\n    //decoration\n    vec2 topDeco = pole0-vec2(0.0,top);\n    topDeco.y*=0.92;\n    if(isCircle(topDeco, 0.1)){\n        fragColor = black;\n    }\n    topDeco.y*=1.6;\n    topDeco.y -= 0.15;\n    vec2 topDecoMinus = topDeco - vec2(0.0,0.03);\n    if(isCircle(topDeco, 0.08) && !isCircle(topDecoMinus, 0.06)){\n        fragColor = black;\n    }\n    topDeco.y+=0.32;\n    if(isCircle(topDeco, 0.06)){\n        fragColor = black;\n    }\n    topDeco.y*=1.25;\n    vec2 decoP1 = topDeco - vec2(0.12,0.1);\n    vec2 decoP2 = topDeco - vec2(-0.12,0.1);\n    if(isCircle(decoP1,0.05) || isCircle(decoP2,0.05)){\n        fragColor = black;\n    }\n    //pole vertical\n    vec2 pole1 = pole0 + vec2(0.0,polePos);\n    if(isRectangle(pole1, vec2(lineThickness,poleHeight))){\n        fragColor = black;\n    }\n    //top--------------------------------------------------------\n    //cloth\n    float leftHandler = sin((flagShape*(group1.y-flagPos))*cos(iTime+1.5));\n    if(leftHandler<group1.x*flagSensitivity\n    && leftHandler>(group1.x-flagSize)*flagSensitivity\n    && group1.y<flagPos\n    ){\n        vec2 hole = group1;\n        hole.x-=flagSize/8.0;\n        hole.y-=flagPos;\n        hole.y*=2.2;\n        hole.x-=0.018;\n        bool isHole = false;\n        for(int i=0;i<3;i++){\n            isHole = isHole || isCircle(hole,0.072);\n            hole.x-=flagSize/3.0;\n        }\n        if(group1.y>flagPos-flagHeight\n        && (-group1.y+flagPos-flagHeight+0.2)*8.0<abs((group1.x-flagSize*0.5)*flagSensitivity-leftHandler)\n        && !isHole){\n            fragColor=black;\n        }\n    }\n    \n    //circle on flag\n    group1.y-=0.2*flagPos;\n    group1.x-=(leftHandler/flagSensitivity)+flagSize*0.5;\n    if(\n        isCircle(group1, 0.08) || (!isCircle(group1, 0.12) && isCircle(group1,0.16))\n    ){\n        fragColor=white;\n    }\n    //hat\n    vec2 group2 = uv;\n    group2.y+=0.25+cos(iTime*5.0)*0.05;\n    group2*=getAngleMultiplier(sin(iTime*2.5)*0.25);\n    \n    if(isRectangle(group2, vec2(0.125,0.03)))\n    {\n        fragColor=black;\n    }\n    vec2 p1 = (group2 - vec2(0.07,0.0))*getAngleMultiplier(0.2)*1.2;\n    vec2 p2 = (group2 + vec2(0.07,0.0))*getAngleMultiplier(-0.2)*1.2;\n    \n    if(isFeather(group2)\n    || isFeather(p1)\n    || isFeather(p2))\n    {\n        fragColor=black;\n    }\n    //body-------------------------------\n    //arms\n    float bodySize = 0.2;\n    float armThickness=0.021;\n    float armRad = 0.16+cos(iTime)*0.01;\n    float armRad2 = 0.18+sin(iTime)*0.01;\n    vec2 group3 = uv;\n    group3.y += 0.5;\n    group3 *= getAngleMultiplier(0.1*cos(iTime+0.1));\n    vec2 armPos1 = group3-vec2(-0.05,armRad);\n    vec2 armPos2 = group3-vec2(0.02,armRad2);\n    if(\n    (isCircle(armPos1,armRad) && !isCircle(armPos1,armRad-armThickness) && group3.x>0.0)\n    || (isCircle(armPos2,armRad) && !isCircle(armPos2,armRad-armThickness) && group3.x<0.0)\n    ){\n        fragColor=black;\n    }\n    vec2 hand1 = group3-vec2(0.0, armRad*2.0-armThickness);\n    vec2 hand2 = group3-vec2(0.0, armRad2*2.0-armThickness);\n    if(isCircle(hand1,0.03) || isCircle(hand2, 0.03)){\n        fragColor=black;\n    }\n    //legs\n    vec2 legUv1=group3;\n    vec2 legUv2=group3;\n        \n    float legHeight=0.12;\n    float legRad = 0.2-abs(cos(iTime))*0.02;\n    float legRad2 = 0.2+abs(sin(iTime))*0.02;\n    \n    legUv1.y+=legRad;\n    legUv2.y+=legRad;\n    legUv1*=getAngleMultiplier(cos(iTime*2.0));\n    legUv2*=getAngleMultiplier(-cos(iTime*2.0));\n\n    vec2 legDrawingUv1=legUv1;\n    vec2 legDrawingUv2=legUv2;\n    \n    legDrawingUv1.x += legRad;\n    legDrawingUv2.x += legRad;\n    \n    if(\n        (isCircle(legDrawingUv1, legRad) && !isCircle(legDrawingUv1, legRad-armThickness)\n        && legUv1.x>-0.1 && legUv1.y>-legHeight && legUv1.y<0.05\n        || isRoundRectangle(vec2(legDrawingUv1.x-legRad+armThickness*0.5,legUv1.y+legHeight),vec2(0.05,armThickness*0.5))\n        )\n         ||\n        (isCircle(legDrawingUv2, legRad2) && !isCircle(legDrawingUv2, legRad2-armThickness)\n        && legUv2.x>-0.1 && legUv2.y>-legHeight && legUv2.y<0.05\n        || isRoundRectangle(vec2(legDrawingUv2.x-legRad2+armThickness*0.5,legUv2.y+legHeight),vec2(0.05,armThickness*0.5))\n        )\n    ){\n    fragColor=black;\n    }\n    \n    //eye\n    if(isCircle(group3, bodySize)){\n        fragColor=black;\n    }\n    vec2 eye = group3;\n    eye-=0.01*vec2(sin(iTime),abs(cos(iTime))+bodySize*1.2);\n    if(isCircle(eye, bodySize*0.8)){\n        fragColor=white;\n    }\n    eye-=0.02*vec2(sin(iTime),abs(0.5*cos(iTime))+bodySize*10.0);\n    if(isCircle(eye, bodySize*0.55)){\n        fragColor=black;\n    }\n    ///TEST\n}","name":"Image","description":"","type":"image"}]}