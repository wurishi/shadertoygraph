{"ver":"0.1","info":{"id":"clfSR4","date":"1674332489","viewed":99,"name":"Earth, Moon Sun","username":"ianertson","description":"The earth, the moon, and the sun.\nThe constellation & location of things are probably wrong, but it was fun to make.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["3d","sun","earth","space","moon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n\n\nvec3 render(vec2 uv) {\n\nvec3 col = vec3(0.0);\n\n\n  col = texture(iChannel0, uv).rgb;\n  float lum = luma(col);\n  \n  vec3 blurred = texture(iChannel1, uv).rgb;\n  float lum2 = luma(blurred);\n  \n  lum = clamp(((lum + lum2) / 2.0) * 1.6, 0.0, 1.0);\n  \n  col = mix(col, blurred, lum);\n\n  return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = render(uv);\n    \n    fragColor = vec4(col, 1.0);\n    \n }","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.14159265359\n\nint HASH[256] = int[256](\n    208, 34,  231, 213, 32,  248, 233, 56,  161, 78,  24,  140, 71,  48,  140,\n    254, 245, 255, 247, 247, 40,  185, 248, 251, 245, 28,  124, 204, 204, 76,\n    36,  1,   107, 28,  234, 163, 202, 224, 245, 128, 167, 204, 9,   92,  217,\n    54,  239, 174, 173, 102, 193, 189, 190, 121, 100, 108, 167, 44,  43,  77,\n    180, 204, 8,   81,  70,  223, 11,  38,  24,  254, 210, 210, 177, 32,  81,\n    195, 243, 125, 8,   169, 112, 32,  97,  53,  195, 13,  203, 9,   47,  104,\n    125, 117, 114, 124, 165, 203, 181, 235, 193, 206, 70,  180, 174, 0,   167,\n    181, 41,  164, 30,  116, 127, 198, 245, 146, 87,  224, 149, 206, 57,  4,\n    192, 210, 65,  210, 129, 240, 178, 105, 228, 108, 245, 148, 140, 40,  35,\n    195, 38,  58,  65,  207, 215, 253, 65,  85,  208, 76,  62,  3,   237, 55,\n    89,  232, 50,  217, 64,  244, 157, 199, 121, 252, 90,  17,  212, 203, 149,\n    152, 140, 187, 234, 177, 73,  174, 193, 100, 192, 143, 97,  53,  145, 135,\n    19,  103, 13,  90,  135, 151, 199, 91,  239, 247, 33,  39,  145, 101, 120,\n    99,  3,   186, 86,  99,  41,  237, 203, 111, 79,  220, 135, 158, 42,  30,\n    154, 120, 67,  87,  167, 135, 176, 183, 191, 253, 115, 184, 21,  233, 58,\n    129, 233, 142, 39,  128, 211, 118, 137, 139, 255, 114, 20,  218, 113, 154,\n    27,  127, 246, 250, 1,   8,   198, 250, 209, 92,  222, 173, 21,  88,  102,\n    219);\n\nint noise2(int x, int y, int seed) {\n  int yindex = (y + seed) % 256;\n  if (yindex < 0) yindex += 256;\n  int xindex = (HASH[yindex] + x) % 256;\n  if (xindex < 0) xindex += 256;\n  return HASH[xindex];\n}\n\nfloat lin_inter(float x, float y, float s) {\n  return x + s * (y - x);\n}\n\nfloat smooth_inter(float x, float y, float s) {\n  return lin_inter(x, y, s * s * (3. - 2. * s));\n}\n\nfloat noise2d(float x, float y, int seed) {\n  int x_int = int(floor(x));\n  int y_int = int(floor(y));\n  float x_frac = float(x - float(x_int));\n  float y_frac = y - float(y_int);\n  int s = noise2(x_int, y_int, seed);\n  int t = noise2(x_int + 1, y_int, seed);\n  int u = noise2(x_int, y_int + 1, seed);\n  int v = noise2(x_int + 1, y_int + 1, seed);\n  float low = smooth_inter(float(s), float(t), float(x_frac));\n  float high = smooth_inter(float(u), float(v), float(x_frac));\n  return smooth_inter(float(low), float(high), float(y_frac));\n}\n\nfloat perlin_get2d(vec2 p, float freq, int depth, int seed) {\n  depth = min(depth, 8); // too slow otherwise\n  float xa = p.x * freq;\n  float ya = p.y * freq;\n  float amp = 1.0;\n  float fin = 0.;\n  float div = 0.0;\n  for (int i = 0; i < depth; i++) {\n    div += 256. * amp;\n    fin += noise2d(xa, ya, seed) * amp;\n    amp /= 2.;\n    xa *= 2.;\n    ya *= 2.;\n  }\n  return clamp(fin / div, -1.0, 1.0);\n}\n\nfloat perlin_get2d(vec2 p, float freq, float depth, float seed) {\n  return perlin_get2d(p, freq, int(depth), int(seed));\n}\n\nvec3 perlin_vec3(vec2 p, float freq, int depth, int seed) {\n  float x = perlin_get2d(p, freq, depth, seed);\n  float y = perlin_get2d(p, freq, depth, int(seed+int(freq)));\n  float z = perlin_get2d(p, freq, depth, int(seed+int(ceil(freq))+int(ceil(freq))));\n  \n  return vec3(x, y, z);\n}\n\nmat2 rot(float a) {\n    float s = sin(a); \n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\nvec3 tonemap(vec3 col) {\n    vec3 x = col;\n    vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n    float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n    \n    x = clamp(\n        (x * (2.51 * x + 0.03)) /\n        (x * (2.23 * x + 1.0392) + 0.98),\n    0.0, 1.0);\n   \n    x = saturate(x, dotVio);\n    x = mix(x, pow(x, vec3(2.0)), 0.3491*pow(dotVio, 2.0));\n    x += luma(x)/6.28;\n    x = clamp(x+(x/6.28), 0.0, 1.0);\n    \n    return pow(x, vec3(0.5125));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define R iResolution.xy\n\nvec3 blur(sampler2D tex, vec2 uv, vec2 dir) {\n    vec2 tsize = vec2(textureSize(tex, 0).xy);\n    dir /= tsize;\n    \n    dir *= (tsize.x/tsize.y)*12.0;\n    \n    return textureGrad(tex, uv, dir, dir).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec2 uv = fc/R.xy;\n    vec3 col = vec3(0.0);\n    \n    \n    vec3 L = blur(iChannel0, uv, vec2(1.0, 0.0));\n    vec3 U = blur(iChannel0, uv, vec2(0.0, 1.0));\n    \n    col = mix(L, U, 0.5);\n    col += luma(col);\n    \n    fragColor = vec4(col, 1.0);\n    \n }","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define R iResolution.xy\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    vec3 next = texture(iChannel0, uv).rgb;\n    vec3 old = texture(iChannel1, uv).rgb;\n\n    \n    if (iFrame > 0) {\n        col = mix(old, next, 0.35);\n    } else {\n        col = next;\n    }\n    \n    \n    fragColor = vec4(col, 1.0);\n    \n }\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEPS 64\n#define VOLUME_STEPS 29\n#define VOLUME_STEPSIZE 0.39\n\n#define NEAR 0.02\n#define FAR 100.0\n#define R iResolution.xy\n#define M_PI 3.14159265359\n#define TAU (M_PI*2.0)\n#define T (2.50+(iTime*0.25))\n\n#define ENTITY_NONE 0\n#define ENTITY_EARTH 1\n#define ENTITY_MOON 2\n#define ENTITY_SUN 3\n\n#define EARTH_POS vec3(0.0, 0.0, 0.0)\n#define SUN_POS vec3(cos((T+0.5)*1.1), 0.0, sin((T+0.5)*1.1)) * (TAU*4.2)\n#define SUN_COLOR (vec3(253, 184, 19)/255.0)\n#define SUN_RADIUS 3.5\n#define MOON_POS (vec3(cos(T*3.0), 0.0, sin(T*3.0)) * (M_PI*1.6))\n\n#define SKIP_CAP 4\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    vec3 albedo;\n    int entity;\n    int skips[SKIP_CAP];\n    int nr_skips;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float strength;\n};\n\nvec3 earthMap(vec2 uv) {\n    vec3 grassColor = vec3(0.1, 0.8, 0.4);\n    vec3 waterColor = vec3(0.2, 0.3, 0.8);\n    vec3 cloudColor = vec3(1.0);\n    \n    float g = perlin_get2d(uv, 0.2, 2, 828145);\n    float w = perlin_get2d(uv, 0.1, 2, 983815);\n    \n    vec2 cuv = (uv+vec2(g, w)) + vec2(cos(T + (g*0.2)), sin(T + (w*0.2)))*60.0;\n    \n    float c = perlin_get2d(cuv, 0.2, 3, 182387);\n    \n    vec3 col = vec3(0.0);\n    col = mix(col, grassColor, g);\n    col = mix(col, waterColor, w);\n    col += (cloudColor * c)*0.5;\n    \n    return col;\n}\n\nvec3 moonMap(vec2 uv) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = vec3(183.,176.,156.)/255.0;\n    vec3 c2 = vec3(99.,102.,106.)/255.0;\n    vec3 c3 = vec3(219.,226.,233.)/255.0;\n    \n    float a = texture(iChannel0, uv*0.5).r;\n    float b = texture(iChannel0, uv+vec2(0.1291, -1.1902)).r;\n    float c = texture(iChannel0, uv*0.3).r;\n    \n    col = mix(col, c1, a);\n    col = mix(col, c2, b);\n    col = mix(col, c3, c);\n    \n    col += vec3(0.0, 0.0, 0.16);\n    \n    return col;\n}\n\nvec3 sunMap(vec2 uv) {\n    vec3 col = vec3(0.0);\n  \n    vec3 c1 = vec3(253., 184., 19.)/255.0;\n    vec3 c2 = vec3(0.97, 0.74, 0.10);\n    vec3 c3 = vec3(1.0);\n    \n    float a = texture(iChannel0, uv*0.5).r;\n    float b = texture(iChannel0, uv+vec2(0.1291, -1.1902)).r;\n    float c = texture(iChannel0, uv*0.3).r;\n    \n    col = mix(col, c1, a);\n    col = mix(col, c2, b);\n    col = mix(col, c3, c);\n    \n    col = saturate(col, 1.0);\n    \n    return col;\n}\n\nfloat getDistEarth(vec3 p) {\n    vec3 spherePos = EARTH_POS;\n    float sphereRadius = 1.0;\n    \n    return length(p - spherePos) - sphereRadius;\n}\n\nfloat getDistMoon(vec3 p) {\n    vec3 spherePos = MOON_POS;\n    float sphereRadius = 0.25;\n    \n    return length(p - spherePos) - sphereRadius;\n}\n\nfloat getDistSun(vec3 p) {\n    vec3 spherePos = SUN_POS;\n    float sphereRadius = SUN_RADIUS;\n    \n    vec3 uv = p / (sphereRadius*M_PI);\n    float x = texture(iChannel0, uv.xy / 8.0).r;\n    float y = texture(iChannel0, uv.zy / 8.0).r;\n    float z = texture(iChannel0, uv.xz / 8.0).r;\n    float m = (x+y+z) / 3.0;\n    \n    vec3 offset = m*vec3(cos(T+x), sin(T+y), sin(T+z)) * 0.16;\n    \n    p += offset;\n    \n \n    \n    return (length(p - spherePos) - sphereRadius) / (1.0 + m);\n}\n\nbool shouldSkip(Data data, int e) {\n    for (int i = 0; i < data.nr_skips; i++) if (data.skips[i] == e) return true;\n    return false;\n}\n\nfloat getDist(vec3 p, inout Data data) {\n    float earth = getDistEarth(p);\n    float moon = getDistMoon(p);\n    float sun = getDistSun(p);\n    \n    int entity = ENTITY_NONE;\n    int entities[3] = int[3](ENTITY_EARTH, ENTITY_MOON, ENTITY_SUN);\n    float distances[3] = float[3](earth, moon, sun);\n    float minDist = FAR;\n    \n    for (int i = 0; i < 3; i++) {\n        int e = entities[i];\n        if (shouldSkip(data, e)) continue;\n        float d = distances[i];\n        if (d < minDist) {\n            minDist = d;\n            entity = e;\n        }\n    }\n    \n    data.entity = entity;\n    \n    return minDist;\n    \n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    Data data;\n    \n    return normalize(getDist(p, data) - vec3(\n        getDist(p+e.xyy, data),\n        getDist(p+e.yxy, data),\n        getDist(p+e.yyx, data)\n    ));\n}\n\nvec2 getUv(vec3 p) {\n    p.xz *= rot(T);\n    p.yz *= rot(M_PI-(T*0.5));\n    float u = atan(p.x, -p.z) / (2. * M_PI) + .5;\n    float v = p.y * .5 + .5;\n    return vec2(u, v);\n}\n\nvec3 getAlbedo(Data data) {\n    switch (data.entity) {\n        case ENTITY_EARTH: return earthMap(data.uv*128.0); break;\n        case ENTITY_MOON: return moonMap(data.uv); break;\n        case ENTITY_SUN: return sunMap(data.uv); break;\n        default: return vec3(0.0); break;\n    }\n    \n    return vec3(0.0);\n}\n\n\nvoid getData(vec3 p, inout Data data) {\n    data.dist = getDist(p, data);\n    data.normal = getNormal(p);\n    data.uv = getUv(data.normal);\n    data.albedo = getAlbedo(data);\n}\n\nvec3 noise(vec3 p, float freq) {\n     vec3 s1 = texture(iChannel1, (p + vec3(7.92251, -1.529156, 2.0192))*freq).xyz;\n     vec3 s2 = texture(iChannel1, (p + vec3(-72.12251, 10.529156, 3.0192))*(freq*0.5)).xyz;\n     vec3 s = (s1+s2) / 2.0;\n     vec3 a = vec3(0.0);\n     \n     float scalar = 1.0;\n     \n     a += scalar * texture(iChannel1, p*freq).xyz; freq *= 2.0; scalar /= 2.0;\n     a += scalar * texture(iChannel1, p*freq).xyz; freq *= 2.0; scalar /= 2.0;\n     a += scalar * texture(iChannel1, p*freq).xyz; freq *= 2.0; scalar /= 2.0;\n     a += scalar * texture(iChannel1, p*freq).xyz; freq *= 2.0; scalar /= 2.0;\n     a += scalar * texture(iChannel1, p*freq).xyz; freq *= 2.0; scalar /= 2.0;\n     a += scalar * texture(iChannel1, p*freq).xyz; freq *= 2.0; scalar /= 2.0;\n     a += scalar * texture(iChannel1, p*freq).xyz; freq *= 2.0; scalar /= 2.0;\n     \n     a *= mix(vec3(-1.0), vec3(1.0), s*a);\n     \n     return a;\n}\n\nfloat getVolumeDist(vec3 p) {\n    \n    \n    vec3 np = normalize(p);\n    \n    float freq = 0.01;\n    float pfreq = 3.0;\n    \n    \n    vec3 perl = noise(p, 0.06);\n\n    \n    return abs(dot(np, normalize(perl)));\n}\n\n\nvoid getVolumeData(vec3 ro, vec3 rd, vec3 p, inout Data data) {\n    \n    data.dist = getVolumeDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    data.normal = normalize(data.dist - vec3(\n        getVolumeDist(p+e.xyy),\n        getVolumeDist(p+e.yxy),\n        getVolumeDist(p+e.yyx)\n    ));\n    \n    data.normal += (-rd);\n    data.normal = normalize(data.normal);\n}\n\nvec3 shadeStars(vec3 ro, vec3 rd, inout Data data, in Light light) {\n    vec3 color = abs(noise(data.point+rd, 0.1))*1.6;\n    vec3 L = normalize(data.point - light.position);\n    float distLight = abs(distance(data.point, light.position));\n    vec3 normal = data.normal;\n    float NdotL = max(0.0, dot(normal, L));\n    float att = NdotL* (pow(light.strength, 2.0) / max(0.0001, pow(distLight, 2.0)));\n    att /= 2.0;\n    att = max(att, 0.03);\n    \n    \n    return light.color * (vec3(0.33) + color) * att;\n}\n\nbool marchStars(vec3 ro, vec3 rd, inout Data data, in Light light) {\n    float dist = 0.0;\n    data.dist = FAR;\n    data.albedo = vec3(0.0);\n    float stepSize = VOLUME_STEPSIZE;\n    \n    int count = 0;\n  //  vec3 p = ro+rd*dist;\n    \n    for (float i = 0.; i < float(VOLUME_STEPS); i+=stepSize) {\n        vec3 p = ro+rd*dist;\n        getVolumeData(ro, rd, p, data);\n        dist += data.dist;\n        count++;\n    //    p += rd*stepSize;\n       if (abs(dist) >= FAR) break;\n       \n       data.point = p;\n       data.albedo += shadeStars(ro, rd, data, light);\n       \n    }\n    \n    dist = dist / float(count);\n    data.albedo /= float(count);\n    dist = min(abs(dist), FAR);\n    data.dist = dist;\n    data.point = ro+rd*dist;\n    \n    return dist < FAR;\n}\n\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    data.dist = FAR;\n    \n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        getData(p, data);\n        dist += data.dist;\n       \n       if ((data.dist) <= NEAR || (dist) >= FAR) break;\n       \n    }\n    \n    dist = min(abs(dist), FAR);\n    data.dist = dist;\n    data.point = ro+rd*dist;\n    \n    return dist < FAR;\n}\n\nvec3 render(vec3 ro, vec3 rd, inout Data data) {\n    vec3 col = vec3(0.0);\n    data.nr_skips = 0;\n    \n    Light light = Light(SUN_POS, (vec3(1.0 / M_PI) + (SUN_COLOR / M_PI))*M_PI, 16.0);\n    float ambient = 0.01;\n    \n    if (march(ro, rd, data)) {\n        vec3 normal = data.normal;\n        vec3 L = normalize(data.point - light.position);\n        float NdotL = max(0.0, dot(normal, L));\n        float lightDist = distance(data.point, light.position);\n        float att = NdotL*((light.strength*SUN_RADIUS) / max(0.0001, pow(lightDist, 2.0)));\n        \n        float occlusion = 0.0;\n        Data ocData;\n        vec3 ocPoint = data.point;\n        vec3 ocDir = L*-1.0;\n        ocData.skips[0] = ENTITY_SUN;\n        ocData.skips[1] = data.entity;\n        ocData.nr_skips = 2;\n        if (\n            NdotL > -0.0001 &&\n            data.entity != ENTITY_SUN &&\n            march(ocPoint, ocDir, ocData) &&\n            ocData.dist < lightDist\n        ) {\n           occlusion = lightDist / max(0.001, ocData.dist);\n           occlusion *= NdotL;\n        }\n        \n        \n        \n        att += float(data.entity == ENTITY_SUN) / M_PI;\n        \n    \n        vec3 albedo = data.albedo;//earthMap(data.uv*128.0);\n        col += albedo * light.color * (att + ambient) * max(0.0, (1.0-occlusion));\n        \n        \n       \n        \n  \n      //  col *= (1.0 - occlusion);\n        \n    } else {\n        vec3 stars1 = texture(iChannel1, rd*16.0).rgb;\n        vec3 stars2 = texture(iChannel1, rd*8.0).rgb;\n        vec3 stars = (stars1+stars2) / 1.6;\n        stars = pow(stars, vec3(64.0));\n        col += stars.x;\n    }\n    \n    Data volumeData;\n    \n    if (marchStars(ro, rd, volumeData, light)) {\n        col += volumeData.albedo * volumeData.dist;\n    }\n    \n    return col;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    \n    \n    vec3 ro = vec3(0.0, 0.0, -10.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    vec2 m = iMouse.xy / R.xy;\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(-m.y*M_PI+1.);\n        ro.xz *= rot(-m.x*TAU);\n        ro.y = max(ro.y, 2.5);\n    } else {\n        ro.xz *= rot(T);\n        ro.yz *= rot(T*0.01);\n    }\n    \n    rd = getRayDir(uv, ro, vec3(0.0), 1.0);\n    \n    Data data;\n    col += render(ro, rd, data);\n    \n    col += luma(col) / M_PI;\n    \n    col = tonemap(col);\n    \n    col += col / M_PI;\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}