{"ver":"0.1","info":{"id":"lfGyRV","date":"1732092244","viewed":16,"name":"Random Pos, Rot, Moving Bread","username":"vitasa","description":"randomly sized slices of bread moving from right to left with different rotations","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["random","moving","rotation","position","bread"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy code to render multiple rotated bread slices moving from right to left at random speeds\n\n// Hash function to generate pseudo-random numbers\nfloat hash(float n) {\n    return fract(sin(n) * 3728.5452168);\n}\n\n// 2D rotation function\nmat2 rotate2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Signed distance function for an ellipse (oval)\nfloat sdEllipse(vec2 p, vec2 r) {\n    vec2 k = abs(p) / r;\n    return (length(k) - 1.0) * min(r.x, r.y);\n}\n\n// Signed distance function for a square (box)\nfloat sdSquare(vec2 p, vec2 size) {\n    vec2 d = abs(p) - size / 2.0;\n    return max(d.x, d.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    // Adjust for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Number of slices\n    const int numSlices = 10;\n\n    // Initialize minimum distance to a large value\n    float d = 1e10;\n\n    // Loop over slices\n    for (int i = 0; i < numSlices; i++) {\n        // Generate pseudo-random parameters based on the slice index\n        float index = float(i);\n\n        // Random position\n        float randX = hash(index * 12.9898);\n        float randY = hash(index * 78.233);\n        vec2 position = vec2(randX * 2.0 - 1.0, randY * 2.0 - 1.0);\n        position.x *= iResolution.x / iResolution.y; // Adjust for aspect ratio\n\n        // Random size\n        float sizeFactor = 0.1 + 0.5 * hash(index * 93.433);\n        vec2 squareSize = vec2(sizeFactor, sizeFactor);\n        vec2 ovalRadii = vec2(sizeFactor * 0.6, sizeFactor * 0.3);\n\n        // Random rotation angle\n        float angle = hash(index * 45.352) * 6.2831; // 0 to 2*pi\n\n        // Random speed (from 0.1 to 0.3)\n        float speed = 0.2 + 0.5 * hash(index * 99.123);\n\n        // Adjust position over time to move slices from right to left\n        float newX = position.x - speed * iTime;\n\n        // Wrap the x-coordinate when it goes off-screen\n        float bound = 1.5 * iResolution.x / iResolution.y; // Adjust bound for aspect ratio\n        newX = mod(newX + bound, 2.0 * bound) - bound;\n\n        // Use the adjusted position\n        vec2 p = uv - vec2(newX, position.y);\n\n        // Apply rotation\n        p = rotate2D(angle) * p;\n\n        // Square parameters (body of the bread)\n        vec2 squareCenter = vec2(0.0, -ovalRadii.y);\n        float dSquare = sdSquare(p - squareCenter, squareSize);\n\n        // Oval parameters (top of the bread)\n        vec2 ovalCenter = vec2(0.0, squareSize.y / 2.0 - ovalRadii.y);\n        float dOval = sdEllipse(p - ovalCenter, ovalRadii);\n\n        // Combine the square and oval using union operation\n        float dSlice = min(dSquare, dOval);\n\n        // Update minimum distance\n        d = min(d, dSlice);\n    }\n\n    // Smooth edges for anti-aliasing\n    float thickness = 0.002;\n    float color = smoothstep(0.0, thickness, -d);\n\n    // Set the fragment color (black shape on white background)\n    fragColor = vec4(vec3(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}