{"ver":"0.1","info":{"id":"wsSXzh","date":"1554033407","viewed":333,"name":"isolines & capsules","username":"wj","description":"Combined iq's shaders https://www.shadertoy.com/view/XdfXDB & https://www.shadertoy.com/view/MsXGz8 to create the \"capsules\" music visualization effect on my page http://www.wothke.ch/playmod/","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["audiovisualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// isolines & capsules\n// by wj\n\n\n// a slightly adapted version of https://www.shadertoy.com/view/XdfXDB & https://www.shadertoy.com/view/MsXGz8 \n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash1( vec2 n )\n{\n    return fract(sin(dot(n,vec2(1.0,113.0)))*43758.5453123);\n}\n\nfloat map( vec2 c ) \n{\n\t//height map: mirror texture so there are no edges\t\n\tvec2 cc= abs(fract((c+0.5)/iChannelResolution[0].xy) *2. -1.);\n\n\treturn 9.0*textureLod( iChannel0, cc, 0.0 ).x;\n}\n\nvec3 calcNormal( in vec3 pos, in float id, float ic, in vec3 cen )\n{\n\tif( ic>2.5 ) return normalize(vec3(pos-cen));\n\tif( ic>1.5 ) return vec3(0.0,1.0,0.0);\n\treturn normalize((pos-cen)*vec3(1.0,0.0,1.0));\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec2 oVos, out vec2 oDir )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat ic = 0.0;\n\t\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<450; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\tvec3  ce = vec3( pos.x+0.5, ma, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\t\n\t\t// cylinder\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.45*0.45;\n\t\tfloat h = b*b - a*c;\n\n\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t1 = (-b-sqrt(h))/a;\n\t\t\tif( t1>0.0 && (ro.y+t1*rd.y)<ma )\n\t\t\t{\n\t\t\t\tt = t1;\n\t\t\t\tic = 1.0;\n    \t\t\tbreak; \n\t\t\t}\n\n\t\t\t// sphere\n\t\t\tb = dot( rd, rc );\n\t\t\tc = dot( rc, rc ) - 0.45*0.45;\n\t\t\th = b*b - c;\n\t\t\tif( h>0.0 )\n\t\t\t{\n\t\t\t\tt = -b-sqrt(h);\n\t\t\t \tic = 3.0;\n\t\t\t \tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\toDir = mm;\n\toVos = pos;\n\n\treturn vec2( t, ic );\n\n}\n\nfloat castVRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat res = 1.0;\n\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\n\tfor( int i=0; i<48; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\tvec3  ce = vec3( pos.x+.5, ma, pos.y+.5 );\n        \n\t\tvec3  rc = ro - ce;\n\t\t\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.45*0.45;\n\t\tfloat h = b*b - a*c;\n                \n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n                        \n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t\tb = dot( rd, rc );\n\t\t\tc = dot( rc, rc ) - 0.45*0.45;\n\t\t\th = b*b - c;\n\t\t\tif( h>0.0 )\n\t\t\t{\n\t\t\t\tres = 0.0;\n\t\t\t \tbreak;\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\n\treturn res;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 DirLight( in vec3 l, in vec3 ligColor,\n\t\t\t  \n\t\t\t   in vec3 n, in vec3 v,\n               in vec3 matColor, in float matR, \n\t\t\t   \n               in float sha )\n{\n\tvec3 h = normalize(v+l);\n\tvec3 r = reflect( -v, n );\n\n\tfloat nl = clamp(dot(n,l),0.0,1.0);\n\tfloat nv = clamp(dot(n,v),0.0,1.0);\n\tfloat nh = clamp(dot(n,h),0.0,1.0);\n    float hl = clamp(dot(h,l),0.0,1.0);\n\n    vec3 sunDiff = matColor * nl;\n\t\n\t//-------------------\n\n\tfloat fresnel = 0.04 + (1.0-0.04)*pow( 1.0-hl, 5.0 );\t\n\tfloat a = pow( 1024.0, 1.0-matR);\n\t\n\tfloat blinnPhong = ((6.0+a)/8.0) * pow( nh, a );\n\ta *= 0.2; blinnPhong += ((6.0+a)/8.0) * pow( nh, a );\n\tfloat k = 2.0/sqrt(3.1416*(a+2.0));\n\tfloat v1 = nl*(1.0-k)+k;\n\tfloat v2 = nv*(1.0-k)+k;\n\tvec3 sunSpec = 10.0*matColor * nl * fresnel * blinnPhong / (v1*v2);\n\t\n\t//-------------------\n\t\n    return ligColor * (sunDiff + sunSpec) * sha;\n}\n\nvec3 DomeColor( in vec3 rd )\n{\n\tfloat cho = max(rd.y,0.0);\n\treturn 1.0*mix( mix(vec3(0.03,0.06,0.43), \n\t\t\t\t        vec3(1.04,0.08,0.15), pow(cho,2.0)), \n                        vec3(2.6,2.6,2.6), pow(1.-cho,15.0) );\n}\n\nvec4 CapsuleColor( in vec3 pos, in vec3 nor, in float hei, in float cid )\n{\n    vec4 mate = vec4(0.8, 0.5, 0.3, 1.0);\n    // avoid color changes.. too much movement already...\n //   mate.xyz = texture( iChannel3, vec2(0.5,0.04*hei), -100.0 ).xyz;\n    vec3 te = texcube( iChannel3, 0.4*pos+ 13.13*cid, nor ).xyz;\n\n\tmate.xyz *= 0.4 + 1.8*te.x;\n    mate.w = clamp(2.0*te.x*te.x,0.0,1.0);\n    mate.xyz *= 0.6;\n    mate.xyz *= 1.0 - 0.8*smoothstep(0.4,0.8,cid);\n    \n    return mate;\n}\n\nfloat CalcOcclusion( in vec2 vos, in vec3 pos, in vec3 nor )\n{\n\tfloat occ  = nor.y*0.55;\n\tocc += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n\tocc += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n\tocc += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n\tocc += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n\tocc = 0.2 + 0.8*occ;\n\tocc *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n\tocc = occ*0.5+0.5*occ*occ;\n    return occ;\n}\n\n// camera flight path\nvec3 path( float t )\n{\n    vec2 p  = 100.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,1.1) );\n\t     p +=  50.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\n\treturn vec3( p.x, 20.0 + 4.0*sin(0.05*t), p.y );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n\t\tvec3 bgcol = DomeColor( rd )*smoothstep(-0.7,1.1,rd.y);\n        vec3 col = bgcol;\n        \n\t\t// raymarch\t\n        vec2 vos, dir;\n\t\tvec2 res = castRay( ro, rd, vos, dir );;\n        float t = res.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + rd*t;\n\t\t\tfloat cid = hash1( vos );\n\t\t\tfloat hei = map(vos);\n\t\t\tvec3  cen = vec3(vos.x+0.5, hei, vos.y+0.5 );\n\t\t\tvec3  nor = calcNormal( pos, cid, res.y, cen );\n\n            // material\t\t\t \n\t\t\tvec4 mate = CapsuleColor( pos, nor, hei, cid );\n\n            // lighting\n\t\t\tcol = vec3(0.0);\n\t\t\t\n\t\t\tfloat occ  = CalcOcclusion( vos, pos, nor );\n\n\t\t\t// key light\n\t\t\tvec3  lig = normalize(vec3(-0.7,0.24,0.6));\n\t\t\tfloat sha = castVRay( pos, lig );\n\t\t\tcol += DirLight( lig, 4.0*vec3(2.8,1.5,1.0), nor, -rd, mate.xyz, mate.w, sha );\n\t\t\t\n            \n            \n            // back light\t\t\t\n\t\t\tvec3  blig = normalize(vec3(-lig.x,0.0,-lig.z));\n            col += DirLight( blig, 1.5*vec3(0.9,0.8,0.7), nor, -rd, mate.xyz, 1.0, occ );\n\t\t\t\n            // dome/fill light\t\t\t\n\t        float sp = clamp(dot(-rd,nor),0.0,1.0);\n\t\t\tcol += sp*3.0*mate.xyz*occ*vec3(0.4,0.5,1.0)*smoothstep(0.0,1.0,reflect(rd,nor).y)*(0.3+0.7*sha);\n\t\t\tcol += sp*3.0*mate.xyz*occ*vec3(0.4,0.5,1.0)*smoothstep(-0.5,0.5,nor.y);\n\t\t\t\n            col*=0.2;\t// hack: make it darker\n            \n\t\t\t// fog\t\t\t\n\t\t\tfloat ff = 1.0 - 0.8*smoothstep( 200.0, 400.0, t*1.4 );\n\t\t\tff *= exp( -pow(0.003*t,1.5) );\n            col = mix( bgcol, col, ff );\n\t\t}\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t\n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n\tint a = 0;\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy + 0.5+113.3137*float(a))/iChannelResolution[1].xy  ).xzyw;\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 75.0 + 6.0*iTime;\n\n\t\t// camera\n        vec3 ro = path( time );\n        vec3 ta = path( time+15.0 ) - vec3(40.0,3.0,0.0);\n        float cr = 0.2*cos(0.1*time*0.25);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        \n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\t\n\t// gamma\t\n\ttot = pow( clamp( tot, 0.0, 1.0 ), vec3(0.45) );\n\t\t\n\t// vignetting\t\n    tot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}\n    \n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 doit( in vec2 p, in float off, float amp )\n{\n    float f = 0.0;\n\tfloat a = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n  \t    float h = float(i)/10.0;\n  \t    float g = texture( iChannel1, vec2(0.01+h*0.5, 0.25)).x;\n  \t    float k = 1.0 + 0.4*g*g;\n\n        vec2 q;\n\t\tq.x = sin(0.67*g*(1.0+amp) + off + float(i)*121.45) * 0.5 + 0.5;\n\t\tq.y = cos(0.016+0.63*g*(1.0+amp) + off + float(i)*134.76) * 0.5 + 0.5;\n\t    vec2 d = p - q;\n\t\tfloat at = 1.0/(0.01+dot(d,d));\n        f += k*0.1*at;\n\t\ta += 0.5 + 0.5*sin(2.0*atan(d.y,(d.x)))*at;\n    }\n\t\n    return vec2(f,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    vec2 ref = doit( p, 0., 0. );\n    float b = ref.x;\t\n\n\t\n    vec3 col = texture( iChannel0,vec2(pow(0.25*ref.x,0.25), 0.5)).xyz\n             * texture( iChannel0,vec2(0.1*pow(ref.y,1.2), 0.6)).xyz;\n\n    col = sqrt(col)*2.0;\n\tfragColor = vec4( col, 1.0 );;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}