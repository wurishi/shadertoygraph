{"ver":"0.1","info":{"id":"td3cWs","date":"1602505728","viewed":815,"name":"Voxel Castle","username":"kastorp","description":"Procedural generation of castles & villages\nmouse: turn view,  keybord: move, T: teleport\nI tried to keep decent compilation time and framerate","likes":26,"published":1,"flags":48,"usePreview":1,"tags":["voxel","castle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Voxel Castle by Kastorp\n\nvec4 fxaa_3_11(sampler2D color_buffer, vec2 uv, vec2 uv_step);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float pixelSize = load(_pixelSize).r;\n\n    vec2 uv_step = 1.0/pixelSize/iResolution.xy;\n    vec2 uv = fragCoord * uv_step;\n    \n    fragColor = fxaa_3_11(iChannel3, uv, uv_step);\n        \n    \n}\n\n\n//--------------------------------------------\n//fxaa 3.11  by jiangdunchun \n//https://www.shadertoy.com/view/stlSzf\n\n/* pixel index in 3*3 kernel\n    +---+---+---+\n    | 0 | 1 | 2 |\n    +---+---+---+\n    | 3 | 4 | 5 |\n    +---+---+---+\n    | 6 | 7 | 8 |\n    +---+---+---+\n*/\n#define UP_LEFT      0\n#define UP           1\n#define UP_RIGHT     2\n#define LEFT         3\n#define CENTER       4\n#define RIGHT        5\n#define DOWN_LEFT    6\n#define DOWN         7\n#define DOWN_RIGHT   8\nvec2 KERNEL_STEP_MAT[] = vec2[9](\n    vec2(-1.0, 1.0), vec2(0.0, 1.0), vec2(1.0, 1.0),\n    vec2(-1.0, 0.0), vec2(0.0, 0.0), vec2(1.0, 0.0),\n    vec2(-1.0, -1.0), vec2(0.0, -1.0), vec2(1.0, -1.0)\n);\n\n\n\n/* in order to accelerate exploring along tangent bidirectional, step by an increasing amount of pixels QUALITY(i) \n   the max step count is 12\n    +-----------------+---+---+---+---+---+---+---+---+---+---+---+---+\n    |step index       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10 |11 |\n    +-----------------+---+---+---+---+---+---+---+---+---+---+---+---+\n    |step pixels count|1.0|1.0|1.0|1.0|1.0|1.5|2.0|2.0|2.0|2.0|4.0|8.0|\n    +-----------------+---+---+---+---+---+---+---+---+---+---+---+---+\n*/\n#define STEP_COUNT_MAX   12\nfloat QUALITY(int i) {\n    if (i < 5) return 1.0;\n    if (i == 5) return 1.5;\n    if (i < 10) return 2.0;\n    if (i == 10) return 4.0;\n    if (i == 11) return 8.0;\n}\n\n\n// L = 0.299 * R + 0.587 * G + 0.114 * B\nfloat RGB2LUMA(vec3 color) {\n    return dot(vec3(0.299, 0.578, 0.114), color);\n}\n\n\n#define EDGE_THRESHOLD_MIN  0.0312\n#define EDGE_THRESHOLD_MAX  0.125\n#define SUBPIXEL_QUALITY    0.75\n#define GRADIENT_SCALE      0.25\n\nvec4 fxaa_3_11(sampler2D color_buffer, vec2 uv, vec2 uv_step) {\n    // get luma of kernel\n    float luma_mat[9];\n    for (int i = 0; i < 9; i++) {\n        luma_mat[i] = RGB2LUMA(texture(color_buffer, uv + uv_step * KERNEL_STEP_MAT[i]).xyz);\n    }\n    \n    // detecting where to apply FXAA, return the pixel color if not\n    float luma_min = min(luma_mat[CENTER], min(min(luma_mat[UP], luma_mat[DOWN]), min(luma_mat[LEFT], luma_mat[RIGHT])));\n    float luma_max = max(luma_mat[CENTER], max(max(luma_mat[UP], luma_mat[DOWN]), max(luma_mat[LEFT], luma_mat[RIGHT])));\n    float luma_range = luma_max - luma_min;\n    if(luma_range < max(EDGE_THRESHOLD_MIN, luma_max * EDGE_THRESHOLD_MAX)) return texture(color_buffer, uv);\n    \n    // choosing edge tangent\n    // horizontal: |(upleft-left)-(left-downleft)|+2*|(up-center)-(center-down)|+|(upright-right)-(right-downright)|\n    // vertical: |(upright-up)-(up-upleft)|+2*|(right-center)-(center-left)|+|(downright-down)-(down-downleft)|\n    float luma_horizontal = \n        abs(luma_mat[UP_LEFT] + luma_mat[DOWN_LEFT] - 2.0 * luma_mat[LEFT])\n        + 2.0 * abs(luma_mat[UP] + luma_mat[DOWN] - 2.0 * luma_mat[CENTER])\n        + abs(luma_mat[UP_RIGHT] + luma_mat[DOWN_RIGHT] - 2.0 * luma_mat[RIGHT]);\n    float luma_vertical = \n        abs(luma_mat[UP_LEFT] + luma_mat[UP_RIGHT] - 2.0 * luma_mat[UP])\n        + 2.0 * abs(luma_mat[LEFT] + luma_mat[RIGHT] - 2.0 * luma_mat[CENTER])\n        + abs(luma_mat[DOWN_LEFT] + luma_mat[DOWN_RIGHT] - 2.0 * luma_mat[DOWN]);\n    bool is_horizontal = luma_horizontal > luma_vertical;\n    \n    // choosing edge normal \n    float gradient_down_left = (is_horizontal ? luma_mat[DOWN] : luma_mat[LEFT]) - luma_mat[CENTER];\n    float gradient_up_right = (is_horizontal ? luma_mat[UP] : luma_mat[RIGHT]) - luma_mat[CENTER];\n    bool is_down_left = abs(gradient_down_left) > abs(gradient_up_right);\n    \n    // get the tangent uv step vector and the normal uv step vector\n    vec2 step_tangent = (is_horizontal ? vec2(1.0, 0.0) : vec2(0.0, 1.0)) * uv_step;\n    vec2 step_normal =  (is_down_left ? -1.0 : 1.0) * (is_horizontal ? vec2(0.0, 1.0) : vec2(1.0, 0.0)) * uv_step;\n    \n    // get the change rate of gradient in normal per pixel\n    float gradient = is_down_left ? gradient_down_left : gradient_up_right;\n    \n    // start at middle point of tangent edge\n    vec2 uv_start = uv + 0.5 * step_normal;\n    float luma_average_start = luma_mat[CENTER] + 0.5 * gradient;    \n    //return vec4(luma_average_start, luma_average_start,luma_average_start, 1.0);\n    \n    // explore along tangent bidirectional until reach the edge both\n    vec2 uv_pos = uv_start + step_tangent;\n    vec2 uv_neg = uv_start - step_tangent;\n    \n    //return texture(iChannel0, uv_neg);\n    \n    float delta_luma_pos = RGB2LUMA(texture(color_buffer, uv_pos).rgb) - luma_average_start;\n    float delta_luma_neg = RGB2LUMA(texture(color_buffer, uv_neg).rgb) - luma_average_start;\n    \n    bool reached_pos = abs(delta_luma_pos) > GRADIENT_SCALE * abs(gradient);\n    bool reached_neg = abs(delta_luma_neg) > GRADIENT_SCALE * abs(gradient);\n    bool reached_both = reached_pos && reached_neg;\n    \n    if (!reached_pos) uv_pos += step_tangent;\n    if (!reached_neg) uv_neg -= step_tangent;\n    \n    if (!reached_both) {\n        for(int i = 2; i < STEP_COUNT_MAX; i++){\n            if(!reached_pos) delta_luma_pos = RGB2LUMA(texture(color_buffer, uv_pos).rgb) - luma_average_start;\n            if(!reached_neg) delta_luma_neg = RGB2LUMA(texture(color_buffer, uv_neg).rgb) - luma_average_start;\n            \n            bool reached_pos = abs(delta_luma_pos) > GRADIENT_SCALE * abs(gradient);\n            bool reached_neg = abs(delta_luma_neg) > GRADIENT_SCALE * abs(gradient);\n            bool reached_both = reached_pos && reached_neg;\n            \n            if (!reached_pos) uv_pos += (QUALITY(i) * step_tangent);\n            if (!reached_neg) uv_neg -= (QUALITY(i) * step_tangent);\n            \n            if (reached_both) break;\n        }\n    }\n    \n    //return texture(iChannel0, uv_neg);\n    \n    // estimating offset\n    float length_pos = max(abs(uv_pos - uv_start).x, abs(uv_pos - uv_start).y);\n    float length_neg = max(abs(uv_neg - uv_start).x, abs(uv_neg - uv_start).y);\n    bool is_pos_near = length_pos < length_neg;\n    \n    float pixel_offset = -1.0 * (is_pos_near ? length_pos : length_neg) / (length_pos + length_neg) + 0.5;\n    \n    // no offset if the bidirectional point is too far\n    if(((is_pos_near ? delta_luma_pos : delta_luma_neg) < 0.0) == (luma_mat[CENTER] < luma_average_start)) pixel_offset = 0.0;\n    \n    // subpixel antialiasing\n    float luma_average_center = 0.0;\n    float average_weight_mat[] = float[9](\n        1.0, 2.0, 1.0,\n        2.0, 0.0, 2.0,\n        1.0, 2.0, 1.0\n    );\n    for (int i = 0; i < 9; i++) luma_average_center += average_weight_mat[i] * luma_mat[i];\n    luma_average_center /= 12.0;\n    \n    float subpixel_luma_range = clamp(abs(luma_average_center - luma_mat[CENTER]) / luma_range, 0.0, 1.0);\n    float subpixel_offset = (-2.0 * subpixel_luma_range + 3.0) * subpixel_luma_range * subpixel_luma_range;\n    subpixel_offset = subpixel_offset * subpixel_offset * SUBPIXEL_QUALITY;\n    \n    // use the max offset between subpixel offset with before\n    pixel_offset = max(pixel_offset, subpixel_offset);\n    \n    \n    return texture(color_buffer, uv + pixel_offset * step_normal);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* ----------------------------------------------------------\n\tDETAIL_LEVEL 2=MAX, 1=MEDIUM, 0=LOW\n//----------------------------------------------------------*/\n#define DETAIL_LEVEL 2\n\n/* ----------------------------------------------------------\n\tLANDSCAPE 1=MOUNTAIN 2=PLAIN\n//----------------------------------------------------------*/\n#define LANDSCAPE 1\n\n\n//-------------------------------------------------\n// RENDERING PARAMETERS\n#if DETAIL_LEVEL==2\n\t//\tOCCLUSION: 0=none 1=interpolated 2=montecarlo (very slow) \n    #define OCCLUSION 1\n    //  SUBVOXEL:  shapes inside voxels\n    #define SUBVOXEL\n    //  TEXTURE  on voxels surface; in not defined, blocks have uniform color;if=0 moire effect..\n    #define TEXTURE 4\n    //\tTREE_DETAIL: if enabled, tree blocks are detailed with subvoxels \n    #define TREE_DETAIL\n    //  GRASS_DETAIL: enable grass\n    #define GRASS_DETAIL\n    //  SHADOW 0.=disabled else shadow intensity\n    #define SHADOW 1.5  \n#endif\n#if DETAIL_LEVEL==1\n   #define OCCLUSION 1 \n   #define SHADOW 1.5\n   #define TEXTURE 1\n#endif\n#if  DETAIL_LEVEL==0\n   #define OCCLUSION 1 \n   #define SHADOW 0. \n#endif\n\n    \n// TERRAFORMING PARAMETERS\n#if LANDSCAPE==1\n    #define WATER_LEVEL 15.\n    #define MOUNTAIN_LEVEL 120.\n    #define PLAIN_RATIO 30.\n    #define TREE_DENSITY .2\n    #define TREE_SIZE 9.\n    #define SLOPE .5\n    #define MAX_GRASS_LEVEL 65.\n#endif\n#if LANDSCAPE==2\n    #define WATER_LEVEL 1.\n    #define MOUNTAIN_LEVEL 20.\n    #define PLAIN_RATIO 1.\n    #define TREE_DENSITY .1\n    #define TREE_SIZE 10.\n    #define SLOPE 1.\n    #define MAX_GRASS_LEVEL 40.\n#endif\n\n#define AREA_SIZE 300.\n#define MAX_PIXELSIZE 2.\n#define MIN_PIXELSIZE 1.\n#define LOAD_TIME 10.\n\n\n//UNUSED HERE\n//#define MAP\n//#define STATS\n//#define XRAY_MODE\n//#define SUBTEXTURE\n//#define MAX_PICK_DISTANCE 10.\n//#define ACTIONS\n//------------------------------------------------------\n\n// MACROS\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy)) \n#define getTexture( id,  c) texture(iChannel0, 16. * (clamp(c,0.001,.999) + vec2(mod(id, 8.), floor(id / 8.)+2.)) / iChannelResolution[0].xy, 0.0)\n#define TS vec2(textureSize(iChannel3,0))\n\n//shared variables are stored in buffer A where  y=0\nvar(_pos, 0, varRow);//_old _pos\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange_C, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);//_old _pick\nvar(_pickTimer, 8, varRow);  //_old _pickTimer\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_stats, 14, varRow);\nvar(_rayDistMax,15,varRow);\n//var(_loadDistLimit,16,varRow);\nvar(_rayLimit,17,varRow);\nvar(_map,18,varRow);\nvar(_pixelSize,19,varRow);\nvar(_inventory,20,varRow);\nvar(_demo,21,varRow);\nvar(_mouseBusy,22,varRow);\nvar(_torch,23,varRow);\nvar(_textureSize,24,varRow);\nvar(_cachePos, 25, varRow);\nvar(_freeze,26,varRow);\n//old value are stored in rows with y=n where n is the iFrame difference\nvar(_old, 0, 1); \n\n\n//BUFFER C\nconst int  BUFFER_C = 2;\nconst vec2 packedChunkSize_C = vec2(1,1);\nconst float heightLimit_B =MOUNTAIN_LEVEL+10.;\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n\n//INVENTORY ITEMS FOR EACH ROW\nconst float NUM_ITEMS=8.;\n//INVENTORY ROWS\nconst float NUM_ITEM_ROWS=2.;\n//\nconst float N_SUBVOXEL=5.;\n\n   \n// VOXEL CACHE FUNCTION\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\n\nfloat calcLoadDist_C(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_C); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_C(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_C(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset,int bufferId) {\n\n    vec2 packedChunkSize= packedChunkSize_C;\n\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord,int bufferId) {\n\n    vec2 packedChunkSize= packedChunkSize_C;\n\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\n\n\n \n//---------------------\n// BIT LEVEL FUNCTIONS\n//--------------------\n\n#define BITS 32.\n#define MAXUINT  0xFFFFFFFFu \n// pixel is a 128 bit mask (0-31 -> x, 32-63 -> y, 64-95 -> z, 96-127 -> w)\nuint getBit(inout uvec4 bm, uint i)\n{\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n       \n    return  (bm[bv]  &  (1u<<bi) )>0u?1u:0u;\n}\n\n//works only if n<=32u \nuint getBits(inout uvec4 bm, uint k, uint n){\n   \n    \n    uint bv = k/uint(BITS),  bi= k%uint(BITS);\n    if(n+bi<=32u){\n        //inside vec4 dimension\n        uint m = (1u<<n)-1u; \n        return (bm[bv] & (m<<bi) )>>bi;\n    }\n    else\n    {\n        //cross dimension\n        uint n1= 32u-bi, n2 = bi+n-32u;\n        uint m1 =(1u<<n1)-1u, m2= (1u<<n2)-1u;\n        return ((bm[bv] & (m1<<bi) )>>bi) \n             + ((bm[bv+1u] & m2 )<<n1);\n    }\n}\n\n// set bit value in a 128 bit mask \nvoid setBit(inout uvec4 bm, uint i, uint val){\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    bm[bv]  &= ( MAXUINT - (1u<<bi) );\n    if(val>0u)  bm[bv]  +=(1u<<bi);\n}\n\nvoid setBits(inout uvec4 bm, uint i, uint n, uint val){\n    val =clamp( val, 0u, (1u<<n)-1u) ;\n\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    if(n+bi<=32u){\n        bm[bv]  &= ( MAXUINT - (((1u<<n)-1u ) <<bi) );\n        bm[bv]  +=(val<<bi);\n    }\n    else\n    {\n        for(uint j=0u; j<n;j++) \n        {\n            uint b = (val  &  (1u<<j) )>0u?1u:0u;\n            setBit(bm, i+j, b);\n        }\n    }\n}\n\n//https://www.shadertoy.com/view/wtKyR1 by ttg\nvec4 b127_ieee754_encode (uvec4 v) {\n  v.w&=0x7FFFFFFFu;\n  uvec4 l = uvec4( v.xyz&0xFFFFFFu , v.x>>24 | v.y>>24<<8 | v.z>>24<<16 );\n  return uintBitsToFloat( (l&0x800000u)<<8 | l&0x7FFFFFu\n   | 1u+uvec4(v.w/uvec4(1,254,254*254,254*254*254))%254u <<23 );\n}\n\nuvec4 b127_ieee754_decode (vec4 f) {\n  uvec4 e = floatBitsToUint(f);\n  uvec4 l = (e&0x80000000u)>>8 | e&0x7FFFFFu;\n  uvec4 h = (e>>23&0xFFu)-1u;\n  return uvec4(\n    l.xyz | uvec3(l.w)>>uvec3(0,8,16)<<24,\n    h.x+254u*h.y+(254u*254u)*h.z+(254u*254u*254u)*h.w );\n}\n\nstruct voxel {\n\tfloat id;\n    int value; //1=border\n    vec2 light;\n    float life;\n    int shape;\n    float rotation;\n    float ground;\n    float surface;\n    float groundLod;\n    int buffer;\n    \n     \n};\n// each voxel is decoded/encoded with the pixel 64 bits\n// r bit 1-6 id        bit 7-8 value     bit 9-12 light.s   bit 13-16 light.t\n// g bit 1-8 unused    bit 9-16 life\n// b bit 1-4 shape     bit 5-8 rotation  bit 9-16 unused \n// a bit 1-8 ground                      bit 9-16 surface\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    uvec4 iv =  b127_ieee754_decode(t);\n    o.id        = float(getBits(iv,0u,6u));  \n    o.value     = int(getBits(iv,6u,2u));  \n    \n    o.light.s   = float(getBits(iv,8u,4u)); \n    o.light.t   = float(getBits(iv,12u,4u)); \n    o.life      = float(getBits(iv,16u,8u)); \n    \n    o.shape     = int(getBits(iv,24u,4u));\n    o.rotation  =  float(getBits(iv,28u,4u)); \n    \n    o.ground    = float(getBits(iv,32u,8u));\n    o.surface    = float(getBits(iv,40u,8u));\n    o.groundLod    = float(getBits(iv,48u,8u));\n\t\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tuvec4 iv = uvec4(MAXUINT);\n    setBits(iv, 0u,6u,uint(v.id));\n    setBits(iv, 6u,2u,uint(v.value));\n    \n    setBits(iv, 8u,4u,uint(v.light.s));\n    setBits(iv, 12u,4u,uint(v.light.t));\n    setBits(iv, 16u,8u,uint(v.life)); \n    \n    setBits(iv, 24u,4u,uint(v.shape));\n    setBits(iv, 28u,4u,uint(v.rotation));\n    \n    setBits(iv, 32u,8u,uint(v.ground));\n    setBits(iv, 40u,8u,uint(v.surface));\n    setBits(iv, 48u,8u,uint(v.groundLod));\n    \n    return b127_ieee754_encode(iv);\n}\n\nfloat lightDefault(float z){\n\tif(z>WATER_LEVEL) return 15.;\n    else  return 14.; \n\n}\n\nvoxel newVox(float z){\n    voxel vox;\n    vox.life=0.;\n    vox.rotation=0.;\n    vox.value=0;\n    vox.shape=0;\n    vox.ground=250.;\n    vox.groundLod=0.;\n    vox.surface=0.;\n    \n\tvox.id=0.;\n    vox.light.t = 4.;\n    vox.light.s = lightDefault(z);\n \tvox.id=0.;\n    vox.buffer=0;\n    return vox;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {\n    return texture(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);   \n \n}\n\n\nvoxel getCachedVoxel(vec2 p,sampler2D iChannel,vec3 resolution,int bufferId) {\n    //if(p.z>heightLimit_B || p.z<0.){voxel vox; vox.id=0.; return vox;}\n    voxel vox= decodeVoxel(readMapTex(voxToTexCoord(vec3(p,0.), bufferId),iChannel,resolution));\n    vox.buffer=bufferId;\n    return vox;\n}\n\n\nfloat isSolidVoxel(voxel vox) {\n    \n    return (vox.id==0. )?0.:1.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\n\n\n// WORLD GENERATION \n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nconst float PI = 3.14159265359;\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n    \nfloat hash2(in vec2 p) { return hash(dot(p, vec2(87.1, 313.7))); }\n\nvec2 hash22(in float p) {\n\tfloat x = hash(p);\n\treturn vec2(x, hash(p+x));\n}\n//vec2 hash22(in vec2 p) { return hash2(dot(p, vec2(87.1, 313.7))); }\n\n\nvec2 hash22( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\n// Fork of \"Optimized Ashima SimplexNoise3D\" by Makio64. https://shadertoy.com/view/Xd3GRf\n// 2020-04-23 14:52:01\n\n// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n\n\n\nfloat noise(in vec2 p) {\n\tvec2 e=vec2(1.,0.), F = floor(p), f = fract(p), k = (3. - 2.*f) * f * f;\n\treturn mix(mix(hash2(F),      hash2(F+e.xy), k.x),\n\t\t\t   mix(hash2(F+e.yx), hash2(F+e.xx), k.x), k.y);\n}\n\nvec2 noise2(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash22(F), \t\t\t  hash22(F+vec2(1.,0.)), f.x),\n\t\tmix(hash22(F+vec2(0.,1.)), hash22(F+vec2(1.)),\tf.x), f.y);\n}\n\nfloat fnoise(in vec2 p) {\n\treturn .5 * noise(p) + .25 * noise(p*2.03) + .125 * noise(p*3.99);\n}\n\n// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\nfloat fbm(vec2 uv) {\n\tfloat v = 0.6;\n    const int steps = 7;\n    for(int i = 0; i < steps; i++){\n        float factor = pow(2.,float(i + 1)) / 2.;\n    \tv += snoise(uv * factor) / factor;\n    }\n    return v / ((pow(.5,float(steps))- 1.) / -.5);\n}\n\n\n\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCross( vec3 p, vec3 b )\n{\n  float d1 = length(max( abs(p) - b,0.));\n  float d2 = length(max( abs(p) - b.zyx,0.));\n  float d3 = length(max( abs(p) - b.xzy,0.));\n  return min(d1, min(d2,d3));\n}\n\n\n\n\nfloat mapTerrain( vec2 p) {\n\n    vec2 uv =  p  / 300. *SLOPE;\n  \tfloat n = .1  +max(fbm(uv * 1.2 ) - .2, 0.); \n    n =  n * n * (3. - 2. * n);  \n    //n*= (.3 + snoise(p/120.)); //islands\n    //n= mix(n, .4,snoise(p/120.)); //plains\n    return floor(clamp( n*MOUNTAIN_LEVEL,1.,MOUNTAIN_LEVEL));\n\n}\n\n\nvec3  getPOI(vec3 pos){\n    vec2 POI_Coord = floor(pos.xy/AREA_SIZE)*AREA_SIZE ;\n    POI_Coord = POI_Coord + floor(hash13(vec3(POI_Coord,2.))*(AREA_SIZE-100.)) +50.5;\n        return vec3( POI_Coord , mapTerrain(POI_Coord));\n}\n\nvoxel getGeneratedVoxel(vec3 voxelCoord){\n\n    \tvoxel vox=newVox(voxelCoord.z);\n\n    \t//vox.id=(voxelCoord.z>=mapTerrain(voxelCoord.xy)?0.:3.);\n\n        float h= mapTerrain(voxelCoord.xy);       \n    \tbool solid = voxelCoord.z<=h;\n      \n    \tfloat h2= snoise(voxelCoord.xy/30.)*10.;\n    \n    \tif(h> WATER_LEVEL) h = WATER_LEVEL + (MOUNTAIN_LEVEL-WATER_LEVEL)* pow((h-WATER_LEVEL)/(MOUNTAIN_LEVEL-WATER_LEVEL),PLAIN_RATIO);\n        if (solid) {\n         \n          \t\n            if (voxelCoord.z <200.) vox.id=13.; // snow\n            if (voxelCoord.z < 95.+h2) vox.id=28.; // snowy rock\n            \n            if (voxelCoord.z < 75.+h2) vox.id=1.; // moutain rocks\n            if (voxelCoord.z < MAX_GRASS_LEVEL+h2) {\n                if(h < voxelCoord.z+.5)   vox.id=3.; // grass \n                else vox.id=2.; //dirt\n                //if (hash13(voxelCoord) > 0.9 && voxelCoord.z < 55.+h2   && h<voxelCoord.z+1. && voxelCoord.z>WATER_LEVEL+2.) {vox.id = 10.;vox.life = 3.; vox.shape=9;}\n            }\n\n            \n            if (voxelCoord.z < WATER_LEVEL+0.) vox.id=21.; // wet sand\n              \n       \n        } else vox.id=0.;\n    \n    \t//WATER\n    \tif(vox.id == 0. && voxelCoord.z <= WATER_LEVEL) {\n            vox.id=12.; \n            if(voxelCoord.z > WATER_LEVEL -2.) vox.shape=3;\n          \n         }\n         //BEDROCK\n        if (voxelCoord.z < 1.) vox.id = 16.; \n    \n      return vox;\n\t\t\n}\n\n\n\n// MIX PROCEDURAL AND MEMORY VOXEL\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\n\nvoxel getVoxelData( vec3 voxelCoord,                    \n                   sampler2D iChannel_C, \n                   int frame,                     \n                   vec3 resolution_C,                   \n                   vec4 range_C,\n                   vec3 offset,\n                   int caller){\n\n\n\n    if (inRange(voxelCoord.xy,range_C) && frame > 0){\n        if ( voxelCoord.z == 0.  && (caller==2) ) {\n            // BUFFER C previous frame\n            return getCachedVoxel(voxelCoord.xy - offset.xy,iChannel_C,resolution_C,BUFFER_C); \n        }\n        if(caller!=2){\n            voxel vo= getCachedVoxel(voxelCoord.xy - offset.xy,iChannel_C,resolution_C,BUFFER_C);\n            if(vo.ground>0. && vo.ground< heightLimit_B  ){\n                //Above max height of BUFFER C --> air\n                float h=floor(voxelCoord.z-vo.ground);\n                \n                if(h==0. ) { return vo;}\n\n                voxel vox=newVox(voxelCoord.z);\n                vox.ground=vo.ground;\n                vox.groundLod= vo.groundLod;\n                vox.light.t=vo.light.t;\n                if(h>0. ) { \n\n                    //GRASS\n                     if(h==1. &&vo.id==3.) {vox.life=1.;}\n\n                    //TREE TRUNK - WOOD\n                    else if(h>0.  && h<= 3. && vo.id==10.&& caller==3) \n                    {\n                        vox.id=10.; vox.shape=9;\n                    }\n                    //TREE TRUNK - LEAF\n                    else if(h> 3. &&h<=TREE_SIZE+2. &&   vo.id==10. ) {\n                        vox.id=11.; vox.shape=8;\n                    }  \n                    //TREE LEAF\n                    else if(h< 3.   && vo.id==11. ) {\n                        vox.id=11.; vox.shape=8;\n                    } \n                    \n                    //AIR\n                    else {vox.id=0.;}\n                    return vox;\n                }\n\n                //WATER\n                if(h<0. && vo.id==12. ){\n                    if( h>=-vo.surface ) vox.id=12.;\n                    else vox.id=21.;\n                    return vox;\n                }\n                //HOUSE\n                if(h<0. && vo.id==20. ){\n                    if( h>=-3.-vo.life ){\n                        if(vo.life>0.) vox.id=7.;\n                        else vox.id=0.;\n                    }\n                    else vox.id=1.;\n                    \n                    return vox;\n                }\n                //CASTLE BASE\n                if(h<0. && (vo.id==3.  )){\n                    vox.id=2.;\n                    \n                    //else vox.id=21.;\n                    return vox;\n                }\n                //CASTLE WALL\n                if(h<0. && (vo.id==5. || vo.id==9. )){\n                    vox.id=vo.id;\n                    \n                    //else vox.id=21.;\n                    return vox;\n                }\n\n            }\n        }\n    }    \n\n    voxel vox=  getGeneratedVoxel(voxelCoord);\n    //DEBUG CACHE MISS\n    //if(vox.id!=0. &&caller==3) vox.id=8.; \n    return vox;\n}\n\n\n#define getVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec3 offset =  floor(vec3(load(frame+_cachePos).xy, 0.));   \\\n    vec4 range_C= calcLoadRange_C(offset.xy,iChannelResolution[2].xy,0.);\\\n    v= getVoxelData(p,iChannel2,iFrame,iChannelResolution[2],range_C,offset,id);}\n\n   //vec4 range_C = load(frame+_loadRange_C);  \\ \n      \n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_SHAPE 82\n#define KEY_ROTATE_Z 70\n#define KEY_ROTATE_Y 71\n#define KEY_MULTISELECT 67\n#define KEY_DECREASE_ZOOM 33\n#define KEY_INCREASE_ZOOM 34\n#define KEY_DECREASE_PIXELSIZE 75\n#define KEY_INCREASE_PIXELSIZE 76\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_STATS 114\n#define KEY_DUMP1 115\n#define KEY_DUMP2 116\n#define KEY_TORCH 118\n#define KEY_TELEPORT 84\n#define KEY_INCREASE_PERFORMANCE 117\n#define KEY_FREEZE 89\n#define KEY_MAP 77\n#define KEY_INVENTORY 73\n\n\n//ACTIONS \n\n\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n    if (inBox(currentCoord, vec4(coord, 1., 1.))) {\n        outValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n    return texture(iChannel1, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n    return texture(iChannel1, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n    bool now = bool(keyDown(keycode));\n    bool previous = bool(texture(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\n\nfloat keyToggled(int keyCode) {\n    return texture(iChannel1, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n    return float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\n\n\n\nfloat isSolidVoxel(bool slope,vec3 p) {\n    voxel t;\n    getVoxel(p,t,3);\n    return isSolidVoxel(t) * (!slope?1.:0.  );//|| t.shape!=6?1.:0.);\n}\n\n#ifdef ACTIONS\nstruct rayCastResults {\n    bool hit;\n    vec3 mapPos;\n    vec3 normal;\n};\n\nrayCastResults  getMouseRay(){\n       \n   vec4 mouseRay=  texture(iChannel3, vec2(0.));\n   rayCastResults res;\n   res.hit = mouseRay.a!=0.;\n   res.mapPos = mouseRay.rgb;\n    \n   float eN = mouseRay.a -1.;\n   res.normal=vec3(mod(eN,3.),floor(mod(eN,9.)/3.),floor(eN/9.))- vec3(1.);  \n   return res;\n}\n\nfloat mouseSelect(vec2 c,float h) {\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    float xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n    c.x -= xStart;\n    if (c.x <NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.*h) {\n        float slot = floor(c.x / 16.) + NUM_ITEMS*floor(c.y / 16.);\n    \treturn slot;\n    }\n\n    return -1.;\n}\n\nbool mouseDoubleClick(){\n    \n    if(iMouse.z <1. ) {\n   \n        int changeCount=0;\n        for(int i=0;i<20;i++){\n\n            int mouseChange=          \n               (load(_old *vec2(i) + _mouse ).z>0.?0:1)\n              +(load( _old * vec2(i+1) +_mouse ).z>0.?0:1);\n\n\n            if(mouseChange==1)changeCount++;\n            if(load(_mouseBusy).r>0.) {store1(_mouseBusy,float(1.));return false;}\n                               \n            if(changeCount>2){\n                //if(load(_time).r - load(_old*vec2(i) +_time).r<1.) return false;\n                if(length(load(_mouse).xy -load(_old * vec2(i+1) +_mouse).xy)>.05) return false;\n                store1(_mouseBusy,float(1.));\n                return true;\n\n            }         \n        }\n    }\n    store1(_mouseBusy,float(0.));\n    return false; \n}\n#endif\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n\tfloat d = 1.0e10;\n    //t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = hash22(p )-.5; //texture(iChannel1, vec2(4, i) / 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) / length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n\n\n\n//textures from https://www.shadertoy.com/view/4ds3WS by Reinder\nvoid setTexture( out vec4 o, in vec2 fragCoord )\n{\n    \n \tif(fragCoord.x>8.*16. || fragCoord.y >10.*16.) discard;\n    vec2 gridPos = floor((fragCoord -vec2(0.,32.))/ 16.) ;\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 8.);\n \n   \n    vec2 uv = floor( c );\t\n    float h = hash12(uv +vec2(float(id)));\n    float br = 1. - h * (96./255.);\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\n    if (iFrame > 10 && iChannelResolution[0].x > 0. && id!=32  ) discard;\n    o.a = 1.;\n    if (id == 0) { //NO TEXTURE\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) { //STONE\n       \n        o.rgb =  vec3( 127./255., 127./255., 55./255.) *br;        \n    }\n    if (id == 2) { //GRASS DOWN\n        \n        //o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n        o.rgb = vec3( 127./255., 86./255.,  39./255.)*br;\n    }\n    if (id == 3) { //GRASS LATERAL\n        \n         o.rgb = vec3( 127./255., 86./255.,  39./255.)*br;\n        if (c.y  + hash( c.x*2.) *3.  > 14. ) \n         o.rgb = //vec3(.5,.3,.05)*br;\n        vec3(.2, .22, .08)*1.4*br;\n       \n    }\n    if (id == 4) { //GRASS UP\n   \t\t\n        //o.rgb = vec3( 106./255., 157./255.,  59./255.)*br;\n        o.rgb = vec3(.2, .22, .08)*1.4*br;\n    }\n    \n    if (id == 5) { //ROCK\n       \n        o.rgb = vec3( 106./255., 170./255.,  64./255.)*br;\n        o.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.));\n \n    }\n    \n\n    if (id == 7) { //BRICK\n        o.rgb = vec3( 1.1)*br; \n       \n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\t\n            o.rgb = vec3(.9,.9,.7)*br;\n\t\t}\n        \n    \t//o.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n\t/*\n    if (id == 6 || id == 26) {//LIGHT OR FIREFLY\n        float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n\t*/\n    if (id == 8) {//GOLD\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n\t\n    if (id == 9) { //ROAD\n        \n         o.rgb= vec3(0.8,0.7,0.2)*(.8 + 0.2 * woodPattern(c))*br;        \n    }    \n    if (id == 10) {//TREE\n\t\t\n        if ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\n        o.rgb = vec3( 103./255., 82./255.,  49./255.)*br; \t\t\t\t\n\t}\t\n    if (id == 11) {//LEAF\n            o.rgb=  vec3(  .12, .35,  .05 )*br;\n\t        //o.rgb=  vec3(  .6, .3,  .05 )*br;\t\t//AUTUMN\n\t}\n    if (id == 12) {//WATER\t\t\n        o.rgb=vec3(  64./255.,  64./255., 255./255.)*br;\t\t\n\t}\t\n    if (id == 13) {//SAND\n\t\t//getMaterialColor(10,c,o.rgb);\n\t\to.rgb= vec3(0.74,0.78,0.65);\n\t}\n    /*\n    if (id == 14) {//RED APPLE\t- MIRROR\t\n\t\to.rgb= vec3(.95,0.,0.05);\n       \n\t}\n    if (id == 15) {//PINK MARBLE\t\n        o.rgb= vec3(.95,0.5,.5)*br;\n    \t//o.rgb = mix(vec3(.2,1,1), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n       // if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n\t\n    if (id == 16) { //BEDROcK\n        \n    \n        o.rgb =   .2*vec3( 127./255., 127./255., 127./255.) *br;   \n    }\n    if (id == 17) {//DIAMOND\t\n       \n    \to.rgb = mix(vec3(.2,1,1), vec3(.1,.8,1), sin((c.x - c.y) / 3.) * .5 + .5);\n       if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n    */\n    if (id == 20) {//\tROOF\n        o.rgb= vec3(0.94, 0.1, 0.1)*br;\n       \n\t}   \n\n    if (id == 21) {//\tNEAR WATER\n        //o.rgb= vec3(0.68, 0.66, 0.38)*br;\n        o.rgb =  vec3( 127./255., 86./255.,  39./255.)*1.2*br;\n       \n\t}\n\n    if (id == 28) {//\t\n        o.rgb= vec3(0.74, 0.67, 0.64)*br;\n              \n\t}  \n\n\t/*\n    if (id == 32) { //DESTROYING BLOCK ANIMATION\n    \to.rgb = vec3(crackingAnimation(c / 16., load(_pickTimer).r));\n    }\n    if (id == 48) { \n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n\t*/\n    \n}\n\n/*--------------------\n\nx=0 && y<256: global variables\nx=0 &&  256<=y<512: keyboard state for each ascii code with millisecs since laste change\n1<=x<16 y<512: previous values fo variables and keys\nx<= 128 && 16<=y< 140 : textures \n\n\n*///-------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    if(fragCoord.x>512. || fragCoord.y >160.) discard;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512. && texCoord.y<32.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n                fragColor.r = texture(iChannel1, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iChannelResolution[0].xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n            }\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse / length(iResolution.xy);\n                float renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n                float rayDistMax = max(load(_rayDistMax).r,50.);\n\t\t\t\t\n                float pixelSize =load(_pixelSize).r;\n                float inventory =load(_inventory).r;\n                float demo =load(_demo).r;\n\t\t\t\tfloat map=load(_map).r;;\n                float freeze = load(_freeze).r;\n\t\t\t\tvec3 texSize=load(_textureSize).xyz;\n                    \n                if (iFrame <2  ) {\n  \n                    //pos = vec3(2942.,10240.,45.);\n                    pos = getPOI( vec3(0.,0.,55.)) +vec3(20.,30.,30.);\n                   \n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    angle = vec2(-2.4,2.1  );                   \n                  \n                    demo=1.;\n                    freeze=0.;\n                    flightMode.rg=vec2(.3,1.);\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -3.;\n                    time = vec2(1150.,6.);\n                    selected = 0.;\n                    inventory=0.;\n                    rayDistMax=250.;\n                    map=0.;\n                    pixelSize=2.;\n                    texSize=vec3( TS, 0.);\n                }\n                \n\n                if(float(iFrame)-texSize.z >LOAD_TIME*.72 && float(iFrame)-texSize.z <LOAD_TIME*.78)  pixelSize=max(MAX_PIXELSIZE-1.,2.);\n                \n                if(float(iFrame)-texSize.z >LOAD_TIME-5. && float(iFrame)-texSize.z <LOAD_TIME)  pixelSize=(TS.x<1025.?1.: MIN_PIXELSIZE);\n                \n                freeze =bool(keyToggled(KEY_FREEZE))?1.:0.;\n                    \n                if(demo>0. && \n                   (keyDown(KEY_JUMP)>.0||keyDown(KEY_FORWARDS)>0. || iMouse.z>0. ))\n                {\n                    inventory=0.;\n                    map=0.;\n                    demo=0.;\n                    \n                }\n                if(demo>0.) {\n                     angle = vec2(iTime*.5,2.1  );\n                    pos = getPOI( pos) -vec3(cos(angle.x),sin(angle.x)  ,-1.)*30.;\n                \t\n                }\n                \n                if ( bool(keyDown(KEY_TELEPORT))) {\n\t\t\t\t\t\n                     //pos =vec3(hash33(pos).xy *10000.,115.);\n                    \n                    angle = vec2(hash33(pos +iTime).x,2.1  );\n                    pos = getPOI( hash33(pos +iTime) *10000.) -vec3(cos(angle.x),sin(angle.x)  ,-1.)*30.;\n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    time.r=hash13(pos)*1200.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);                                   \n                    selected = 0.;                   \n                    flightMode.rg=vec2(.3,1.);\n                    demo=1.;\n                }\n                \n                if(texSize.x != TS.x  ||  bool(keyDown(KEY_TELEPORT))) {\n                    texSize=vec3( TS, float(iFrame));\n                    pixelSize=max((TS.x<1025.?2.: MAX_PIXELSIZE),pixelSize);\n                }\n                \n                if (oldMouse.z > 0. && iMouse.z > 0. && map<1.5)\n                    if(1==1){\n                        float zoom = pow(10., load(_renderScale).r/10.);\n                        angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1)/zoom;\n                        angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                    }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                \n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                    vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                \n                float inBlock = 0.;      \n                vec3  vColPos, hColPos;\n                \n                //z of closest  blocks below\n                float minHeight = 0.; \n                \n                //z of closest  blocks above\n                float maxHeight = 1000.;\n                \n                //XY of closest lateral blocks\n                float minX = pos.x - 1000.; \n                float maxX = pos.x + 1000.;\n                float minY = pos.y - 1000.;\n                float maxY = pos.y + 1000.;\n#ifndef XRAY_MODE\n                \n                //AUTO ADJUST HEIGHT OVER TERRAIN\n                if(isSolidVoxel(false,pos) >.5)  pos.z+=clamp(3./iTimeDelta,.3,1.);\n                \n                //DOWN\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    float solid=0.;\n                    for(int j=0;j<4;j++){\n                        solid+=\n                          isSolidVoxel(false,vColPos  + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                    }\n                    if ( solid> .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n\t\t\t\t\n                //UP\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                float solidUp=0.;\n                for(int j=0;j<4;j++){\n                 \tsolidUp+= isSolidVoxel(false,vColPos  + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                }\n\t\t\t\tif(  solidUp > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;     \n\n                }\n               \n                //LATERAL\n                float solidL[4];\n                for(int i=0;i<4;i++){\n                    vec2 posL;\n                    vec2 hColPosL;\n                    if(i==0) {hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z)); hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==1) {hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==2) {hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    if(i==3) {hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    solidL[i]=0.;\n                    for(int j=0;j<6;j++){\n                        \n       \n                        solidL[i ] += isSolidVoxel(true,hColPos  + vec3((i/2)*(j%2),(1-i/2)*(j%2),(j/2)+min(iFrame,0))) \n                            * horizontalPlayerCollide(hColPosL + vec2(0.5+float(j%2), 0.5+float(j/2)), posL, 1.8);\n                    }\n                \n                    if(i==0 && solidL[i]>.5) minX = hColPos.x + 1.301;\n                    if(i==1 && solidL[i]>.5) maxX = hColPos.x - .301;\n                    if(i==2 && solidL[i]>.5) minY = hColPos.y + 1.301;\n                    if(i==3 && solidL[i]>.5) maxY = hColPos.y - .301;\n                }\n                \n\n                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.; \n#else\n                flightMode.rg=vec2(.3,1.);\n                if(iFrame==0) pos.z=65.;\n#endif\n                \n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n\n                if (bool(keySinglePress(KEY_FORWARDS))) {\n                    if (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\n                vec3 stats =vec3(\n                    bool(keyToggled(KEY_STATS))?1.:0.,\n                    bool(keyToggled(KEY_DUMP1))?1.:0.,\n                    bool(keyToggled(KEY_DUMP2))?1.:0.\n                );\n                float torch = bool(keyToggled(KEY_TORCH))?1.:0.;\n                \n                \n                map = mod( map +keyPress(KEY_MAP),3.);\n                inventory = floor(mod( inventory + keyPress(KEY_INVENTORY),3.));\n                if(inventory<2.) selected=clamp(selected,0., NUM_ITEMS-1.);\n\n                \n                float rayLimit=700.; \n                if(bool(keyToggled(KEY_INCREASE_PERFORMANCE))){        \n                    pixelSize=max(2.,pixelSize) ;                    \n                    rayLimit=300.;\n                }\n                pixelSize=clamp( pixelSize  + keyPress(KEY_INCREASE_PIXELSIZE) - keyPress(KEY_DECREASE_PIXELSIZE)  ,1.,4.);\n\n\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    \n                    else {\n                        //voxel t;\n                        //getCVoxel(pos -offset,t,0);\n                        //bool isWater=(t.id ==12.);\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n\t\t\t\t\t\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\n\n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight ) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                \n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n#ifdef ACTIONS  \n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n\n              \n                rayCastResults mousePointer = getMouseRay();\n            \n                bool dblClk =mouseDoubleClick();\n                if(dblClk){\n                    if (mousePointer.hit ) {\n                        \n                            pick.xyz = mousePointer.mapPos;\n                            pick.a = 7.;\n                  }                \n                }\n                \n                if (iMouse.z > 0. ) {                    \n                    \n                    float h= (inventory>1.?NUM_ITEM_ROWS:1.);\n                    float slot = mouseSelect(iMouse.xy,h);\n                    if(slot>= 0. && inventory>0. ){\n                        selected = slot;\n                    }\n                    else {\t\n                    \n                    if (mousePointer.hit ) {\n                        pick.xyz = mousePointer.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (dblClk || bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += mousePointer.normal;                         \n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                         else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt / 0.25;\n                        }\n                        if (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        //pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                }\n                else { \n                    \n                    // NO MOUSE KEY PRESSED  \n                    //pick = vec4(-1,-1,-1,0);\n\t\t\t\t\t\tif (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                        else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt / 0.25;                   \n                        }else timer = 0.;\n                }\n#endif\n\n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_ZOOM) - keySinglePress(KEY_INCREASE_ZOOM), -5., 10.);\n                time.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n                time.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                bool still= length(pos-oldPos)<0.01 && length(angle -load(_angle).xy )<0.01  &&  iMouse.z<1. ;\n                if(freeze>.0) still= keyDown(KEY_PLACE)<.5 ;\n                \n                if(!still){\n                    texSize.z=max(texSize.z,float(iFrame)-LOAD_TIME*.8);\n                    pixelSize=max((TS.x<801.?1.: MAX_PIXELSIZE),pixelSize);\n                }\n                \n                rayDistMax= rayLimit;/*clamp(rayDistMax  \n                                  +(still?10.:0.) \n                                  - ((iTimeDelta>0.03 && !still)?5.:0.)\n                                  -((iTimeDelta>0.1)?1.:0.) \n                                  -((iTimeDelta>0.1  && !still)?50.:0.) \n                                  + ((iTimeDelta<0.03 && still)?20.:0.)\n                                  ,loadDistLimit*2.5,rayLimit);*/\n\n                vec3 cachePos =pos;\n                if(float(iFrame)-texSize.z > LOAD_TIME && freeze>0.){               \t\n                    cachePos = load(_cachePos).xyz;\n                    \n                } \n                if(abs(float(iFrame)-texSize.z - LOAD_TIME)<2. && freeze>0.){\n                    vel=vec3(0.);\n                }\n                \n                store3(_pos, pos);\n                store2(_angle, angle);               \n\n\n                store3(_cachePos, cachePos);\n                store4(_loadRange_C,calcLoadRange_C(cachePos.xy,iChannelResolution[2].xy,0.));\n\n                store4(_mouse, mouse);\n                //store1(_inBlock, inBlock);\n                store3(_vel, vel);\n#ifdef ACTIONS                  \n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_inventory,inventory);\n                store1(_selectedInventory, selected);\n#endif                \n                store1(_renderScale, renderScale);\n\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                store3(_stats, stats);\n                store1(_rayDistMax, rayDistMax);\n                //store1(_loadDistLimit, loadDistLimit);\n                store1(_rayLimit, rayLimit);\n                store1(_map,map);\n                store1(_pixelSize,pixelSize);\n                \n                store1(_demo,demo);\n                store1(_freeze,freeze);\n                store1(_torch,torch);\n                store3(_textureSize,texSize);\n               \n\n\n                fragColor = outValue;\n            }\n        }  \n        else {\n            fragColor = texture(iChannel0, (fragCoord - _old) / iChannelResolution[0].xy);\n        }\n    }\n    else setTexture(fragColor,fragCoord);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\nVOXEL MEMORY 2 - SURFACE \n\n*/\n\n\n//KEYBOARD\n#define CH_R 82\n#define CH_F 70 \n#define keyboard(k) (texelFetch(iChannel1, ivec2(k,0), 0).r>.5)\n\n\nvoid mainImage( out vec4 Q, in vec2 fragCoord )\n{\n    float loading= float(iFrame) -load(_textureSize).z ;\n    if(loading>LOAD_TIME ) discard;\n    \n    \n    vec2 texelCoord = floor(fragCoord);\n    vec3 new_offset = floor(vec3(load(_cachePos).xy, 0.));\n    \n    vec3 voxelCoord = texToVoxCoord(texelCoord, new_offset,BUFFER_C); \n   \n    vec4 Range_C= load(_old +_loadRange_C );\n\n    \n    vec4 newRange_C= calcLoadRange_C(new_offset.xy,iChannelResolution[2].xy,0.);\n    if(!inRange(voxelCoord.xy, newRange_C)) {\n        discard;\n    }\n    else {\n        voxel vox;  \n        getVoxel( voxelCoord,vox,2);\n\n        //INITIALIZE \n        if(vox.ground >heightLimit_B || vox.ground<1.){\n\n\t\t\t\n            voxel temp;\n            //float h= vox.ground-heightLimit_B;\n            float s=   mapTerrain(voxelCoord.xy);\n            vox.ground=s;\n            vox.surface=0.;\n            \n            float h= max(s,WATER_LEVEL);\n            getVoxel(vec3(voxelCoord.xy,h),temp,2);\n            float id = temp.id;\n            if(id !=0.){\n                vox=temp;\n                vox.ground=h;\n                if(id==12.) vox.surface=h-s;\n            }\n\n\t\t\tvec3 POI_Coord = getPOI(voxelCoord) ;\n            float pd=sdBox(voxelCoord.xy-POI_Coord.xy,vec2(17.));\n            bool goodPOI=(POI_Coord.z>WATER_LEVEL);\n            \n            //TREE:\n            if(h<MAX_GRASS_LEVEL && h > (WATER_LEVEL)+1. && (pd>14. || !goodPOI)\n               && hash13(voxelCoord)<TREE_DENSITY *min(MAX_GRASS_LEVEL-h +2.,h+1.- WATER_LEVEL )/(MAX_GRASS_LEVEL+2.- WATER_LEVEL ) ) //&& length(POI_Coord-U.xy +.5)>12.) \n            {\n                vox.id = 10.;vox.life = 3.; vox.shape=9;\n                vox.surface=10.;\n            }\n            \n            if(goodPOI){\n                //CASTLE AREA\n                if(pd<3.) {\n\n                        float b= min(max(pd,0.),3.);\n                        if(b>0.) { \n                            vox.ground = (s * b + POI_Coord.z * (3.-b)) /3.;\n                            if(vox.ground<WATER_LEVEL) {  vox.surface=WATER_LEVEL-vox.ground; vox.ground=WATER_LEVEL; vox.id=12.;}\n                        }\n                        else { vox.ground= POI_Coord.z; }\n                        if(abs(POI_Coord.z-s)<1.) vox.id=9.; else vox.id=3.;\n\n                        vox.life=1.;\n                        vox.surface=max(POI_Coord.z-s,0.);\n                        vox.shape=0;\n                    \tvox.light.t=5.;\n                        vox.value=1;\n                }\n\n                //HOUSES\n                if(( abs(pd-9.)<2. || abs(pd-23.)<2. || abs(pd-37.)<2. ) && vox.ground>  WATER_LEVEL \n                   && mod(voxelCoord.x + hash(voxelCoord.x)*4. ,12. ) + mod(voxelCoord.y +hash(voxelCoord.y)*4. ,12.) < 4.\n                ){ \n                    vox.id=20.; //vox.shape=3;\n                    vox.life=3.;\n                    vox.ground+= 7.;\n                    vox.surface=7.;\n                    vox.light.t=10.;\n                    vox.value=1;\n                }         \n\n               //ROAD\n                if( ( abs(pd-4.)<1. ||abs(pd-16.)<1. || abs(pd-30.)<1.  ) && vox.ground>  WATER_LEVEL \n                  ){  \n                    vox.id=9.;vox.shape=0;\n                    vox.light.t=10.;\n                    vox.shape=0;\n                    vox.ground-= 1.;\n                    vox.value=1;\n                }   \n                \n\t\t\t\t//EXTERNAL WALL\n                if( abs(pd+1.01)< .5 && vox.ground>  WATER_LEVEL &&  vox.id!=9.\n                   ){\n                    //vox.value=1;\n                    vox.id=7.;\n                    vox.light.t=10.;\n                    vox.shape=0;\n                    vox.ground+=4.;\n                    //vox.surface+=4.;\n                    vox.life=1.;\n                    \n                }\n                \n                //CASTLE\n                if( pd <-8. && vox.ground>  WATER_LEVEL\n                   ){\n                    vox.value=1;\n                    vox.id=   7.;\n                    vox.light.t=10.;\n                    vox.shape=0;\n                    vox.ground+=8. + (length(abs(voxelCoord.xy-POI_Coord.xy))>11.  ?10. :0.);\n                    //vox.surface+=4.;\n                    vox.life= pd<-9.? 0.: 2.;\n                    \n                }\n                //RIVER:\n                \n                //if(c.isRiver  &&vox.id!=20. ) { vox.id=12.;vox.shape=3;vox.surface=2.; vox.ground=float(c.height-1); } \n                \n                //WALL                  \n                //    if(vox.id==11.) {vox.id=3.;vox.surface=0.; vox.ground= float(c.height);vox.shape=0;vox.life=0.;}\n                //    if(vox.id==10.) { vox.ground= float(c.height);vox.shape=0;vox.surface=0.; vox.life=0.;}\n\n            }\n        } \t\n\t\t\n\n        \n       \n        if(  vox.ground<heightLimit_B){\n            \n            \n             //NEIGHBOURS\n           vec3 s = vec3(1.,0.,0. );\n           vec3 t = vec3(0.,1.,0. );    \n           voxel v[9];    \n           for (int i =-1; i <=1; i++) {\n                for (int j =-1; j <=1  ; j++) {\n\n                    getVoxel(voxelCoord + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,2 );                     \t\n                    voxel temp = v[4+ i+3*j ];\n                    //i+3*j !=0\n                    //HOUSE\n                    if(i+3*j !=0 &&   temp.id==20. && (temp.life> vox.life || (vox.id==10. &&temp.life>0.))\n                       && temp.ground <heightLimit_B  ) {\n                        vox.id=20.; vox.shape=0;                   \n                        vox.ground=temp.ground-1.;\n                        vox.life=temp.life-1.;\n                        vox.surface==6.;\n                        vox.light.t=temp.light.t-1.;\n                        vox.value=1;\n                        \n                    }      \n                     \n                    //WALLS\n                    if(abs(i)+abs(j)==1 &&  (temp.id==5.||temp.id==7.)  && temp.life> 0. && (vox.id!=7. && vox.id!=5.)\n                       && temp.ground <heightLimit_B  ) {\n                        vox.id=5.; vox.shape=0;                   \n                        vox.ground=temp.ground+  ( mod(voxelCoord.x,3.) <2. && mod(voxelCoord.y,3.) <2.  ?1.:0.);\n                        vox.life=temp.life-1.;\n                        //vox.surface==6.;\n                        vox.light.t=temp.light.t-1.;\n                        vox.value=1;\n                        \n                    }      \n                    \n                    //TREE TRUNK\n                    if(abs(i)+abs(j)==1 &&  vox.surface==0. && temp.id==10. &&vox.value!=1\n                       && temp.ground <heightLimit_B && temp.ground> vox.ground -TREE_SIZE -1.) {\n                        vox.id=11.; vox.shape=8;\n                        vox.surface=TREE_SIZE +2. -vox.ground+temp.ground;\n                        vox.ground=temp.ground-3. +TREE_SIZE;\n\n                        vox.life=1.;\n                    }\n\t\t\t\t\t//TREE LEAF\n                    if(abs(i)+abs(j)==1 && vox.surface==0. &&vox.value!=1 &&  temp.id==11. &&temp.life> 0. \n                       && temp.ground <heightLimit_B && temp.ground> vox.ground -TREE_SIZE -1.) {\n                        vox.id=11.; vox.shape=8;\n                        vox.surface=-vox.ground+temp.ground-2.;\n                        vox.ground=temp.ground-2.;\n                        ;vox.life=0.;\n                    }\n                    \n\n                }\n            }\n       \n       \n           //0202 0202\n           //0000 0000\n           //0202 0202\n           //0400 0400\n           \n           //0202 0202\n           //0000 0000\n           //0202 0202\n           //8400 0400\n           \n           //WIP:  MIPMAP with max height for each  8x8 chunk\n           int lod=0;\n           ivec2 off=ivec2(0);\n           ivec2 c= ivec2(fract(voxelCoord.xy/8.)*8.);          \n           //vox.groundLod=0.;\n           \n           if((c.x&7)==0 && (c.y&7)==0) {lod=8;off=ivec2(0,1);}\n           else if ((c.x&3)==1 && (c.y&3)==0) {lod=4;off=ivec2(0,1);}\n           else if ((c.x&1)==1 && (c.y&1)==1) {lod=2;;off=ivec2(-1,-1);}\n           vox.groundLod= max(vox.ground+ (vox.id==10.|| vox.id==11.? TREE_SIZE+2.:0.),vox.groundLod);\n           \n           if(lod>0)for(int i=0;i<4;i++) {\n               voxel nvox;\n               \n               vec3 nCoord= vec3(voxelCoord.xy,0) + vec3(off.x+(lod/2 * (i&1)) ,off.y+(lod/2 * (i/2)), 0);\n               getVoxel(nCoord,nvox ,2 );     \n               if(vox.groundLod<nvox.groundLod  ) vox.groundLod=nvox.groundLod;\n               \n               //if(nvox.groundLod< nvox.ground &&lod==2 && iFrame>10) vox.id=8.;\n               //if(lod==8 && vox.groundLod>vox.ground){vox.ground=vox.groundLod;vox.id=8.;}\n           }\n          // if( iFrame>20 &&lod==8  &&vox.groundLod<vox.ground) vox.id=8.;  \n           \n           \n       }\n        \n        Q = encodeVoxel(vox);\n        return;\n    }\n\n    \n\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"int st=0;\n\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(in vec2 light) {\n    light = 15. - light;\n\tif(load(_torch).r>0.5) light.t=13.;\n    \n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n\n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;\n}\n\nfloat opaque(float id) {\n\t//return id > .5 ? 1. : 0.;\n    return  id != 0. && id!= 12. && id!= 26. ? 1. :0.;\n}\n\nvec3 calcOcclusion(vec3 r,vec3 n, vec2 uv,voxel vox) {\n#if OCCLUSION!=1\n    return vec3(vox.light , .75);\n#else \n \t//tangents:\n    vec3 s = vec3(step(.1,abs(n.y)), 1.- step( .1, abs(n.y)) ,0.                  );\n    vec3 t = vec3(step(.1,abs(n.z)), 0.                   ,1.- step(.1,abs(n.z)  ));\n    \n   //neightbours vector\n   //v[0],v[1],v[2]\n   //v[3],v[4],v[5]\n   //v[6],v[7],v[8]\n   voxel v[9]; \n   \n   for (int i =-1; i <=1; i++) {\n        for (int j =-1; j <=1  ; j++) {            \n             getVoxel(r +n + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,3 ); \n             \n             st++;\n        }\n    }\n      \n    \n    vec2 lightm=vox.light;\n\n#if DETAIL_LEVEL==2\n \tvec2 light[4];\n    for(int i=0;i<=3;i++){\n        \n        ivec4 ids;\n        if(i==0) ids=ivec4(6,7,3,4);\n        if(i==1) ids=ivec4(7,8,4,5);\n        if(i==2) ids=ivec4(3,4,0,1);\n        if(i==3) ids=ivec4(4,5,1,2);\n    \tlight[i +min(iFrame,0)] =max24(v[ids.x].light, v[ids.y].light, v[ids.z].light, v[ids.w].light);\n    }\n    lightm = mix(mix(light[2], light[3], uv.x), mix(light[0], light[1], uv.x), uv.y);\n#endif\n        float aom, ao[4];\n    for(int i=0;i<=3 ;i++){\n\n        ivec3 ids;\n        if(i==0) ids=ivec3(7,3,6);\n        if(i==1) ids=ivec3(7,5,8);\n        if(i==2) ids=ivec3(1,3,0);          \n        if(i==3) ids=ivec3(1,5,2);;\n        ao[i] = vertexAo(opaque(v[ids.x].id), opaque(v[ids.y].id), opaque(v[ids.z].id));\n    }\n    aom = mix(mix(ao[2], ao[3], uv.x), mix(ao[0], ao[1], uv.x), uv.y);\n   if(opaque(v[4].id)>0.) {aom*=0.75;}  \n    \n     \n    return vec3(lightm , aom);\n#endif    \n\n    \n}\n\n// RENDERING\n#define FISHEYE 0.\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n    float fish = 1.0 - dot(uv, uv) * FISHEYE;\n\treturn normalize(cameraDir*fish + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n#ifdef SUBTEXTURE  \n    vec2 uv_txt;\n#endif    \n    float dist;\n    voxel vox;\n    float water;\n    float fog;\n    bool grass;\n    bool mirror;\n    vec3 color;\n    float fresnel;\n\n};\nmat3 rotate(float theta,int axis) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    if (axis==1) return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n    if (axis==2) return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 sun(){\n    float t = load(_time).r;\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    const float risingAngle=PI/6.;\n    return  vec4(cos(sunAngle)*sin(risingAngle), cos(sunAngle)*cos(risingAngle), sin(sunAngle),lightLevelCurve(t));\n}\n\n\n//GRASS ADAPTED FROM POLYANKA by W23\n//https://www.shadertoy.com/view/MdsGzS\n#ifdef GRASS_DETAIL\nconst int c_grassmarch_steps = 48;\nconst float c_gscale = 37.;\nconst float c_gheight = 0.4;\n//const float c_rgslope = 2. / (c_gscale * c_gheight);\n\n\nvec2 wind_displacement(in vec2 p) {\n\treturn noise2(p*.1+iTime)/100. - 0.005;\n}\n\nfloat grass_height(in vec3 p,float gheight) {\n\tfloat base_h= 0.15;\n\tfloat depth = 1. - (base_h - p.z) / gheight;\n\tvec2 gpos = (p.xy  + depth * wind_displacement(p.xy));\n\treturn base_h - noise(gpos * c_gscale) * gheight;\n}\n\n\nstruct xs_t {\n    bool hit;\n\tvec3 pos; \n\tfloat occlusion;\n    float dist;\n};\n\nxs_t trace_height(vec3 o, vec3 d) {\n    bool hit=false;\n\tfloat L = 0.;\n    \n\tfor (int i = 0; i < c_grassmarch_steps; ++i) {\n\t\tvec3 pos = o + d * L ;\n        \n\t\tfloat h = 1. - length(pos.xy -.5);\n\t\tfloat dh = abs(pos.z - h);\n        if (dh < .02) {hit=true; break;}\n\t\tL += .02 ;\n        vec3  dist = abs(pos-.5);\n       \n\t\tif (max(dist.z, max(dist.x,dist.y))>.5) break;\n\t}\n\tvec3 pos = o + d * L;\n\tfloat occlusion =pos.z;\n\treturn xs_t(hit, pos ,  max(.1,occlusion),L);\n}\n\nxs_t trace_grass(vec3 o, vec3 d,vec3 mapPos,float gheight) {\n    bool hit=false;\n\tfloat L = .005;\n    //float Lmax= 1.8;\n\tfor (int i = 0; i < c_grassmarch_steps; ++i) {\n\t\tvec3 pos = o + d * L ;\n\t\tfloat h = grass_height(pos +mod(mapPos,10.),gheight);\n\t\tfloat dh = pos.z - h;\n        if (dh < .005) {hit=true; break;}\n\t\tL += dh * 2. / (c_gscale * gheight);\n        vec3  dist = abs(pos-.5);\n        //if (L > Lmax) break;\n\t\tif (max(dist.z, max(dist.x,dist.y))>.5) break;\n\t}\n\tvec3 pos = o + d * L;\n\tfloat occlusion = 1. - 2.*(0. - pos.z) / gheight;\n\treturn xs_t(hit, pos + mod(mapPos,99.),  (hit)?1.:min(1.,occlusion),L);\n}\n\nvec3 shade_grass(in xs_t xs) {\n    \n\tvec2 typepos = xs.pos.xy + wind_displacement(xs.pos.xy);\n\tfloat typemask1 = fnoise(2.5*typepos);\n\tfloat typemask2 = pow(fnoise(.4*typepos), 3.);\n\tfloat typemask3 = step(.71,fnoise(.8*typepos));\n\tvec3 col1 =  vec3(.7, .7, .2)*.7; //leaf\n\tvec3 col2 = vec3(.2, .2, .1)*.3;\n\tvec3 col3 =  vec3(.0, .0, .0); //vec3(.5, .5, .1);\n\tvec3 col4 = vec3(.6, .1, 1.); //flower\n\tvec3 color = mix(mix(mix(col1, col2, typemask1),\n\t\t\tcol3, typemask2), col4, typemask3) *.8;\n\tcolor *= xs.occlusion;\n\treturn color;\n}\t\n#endif\n//-----------------------------\n//water reflection: https://www.shadertoy.com/view/MdXGW2\n#define BUMPFACTOR 0.3\n#define EPSILON 0.1\n\nfloat waterHeightMap( vec2 pos ) {\n    return 0.9+.1*snoise( pos/2. +iTime/3.);\n}\n\nfloat fresnelR(vec3 d, vec3 n)\n{\n    //float a = clamp(1.0-dot(n,-d), 0.0, 1.0);   \n   // return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n    return pow( clamp( 1.0 + dot(d,n), 0.0, 1.0 ), 5.0 );\n}\n//------------------------*/\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\n#ifdef SUBVOXEL\nrayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,float rotation,vec3 seed){\n \n\trayCastResults  res;\n    \n    \n    vec3 c=vec3(.5);\n    float theta1= PI/2.*floor(mod(rotation,4.));\n    rayPosOrig = rotate( theta1,3) *(rayPosOrig-c) +c;\n    rayDir= rotate( theta1,3)*rayDir; \n    float theta2= PI/2.*(floor(rotation/4.));\n    rayPosOrig = rotate( theta2,2) *(rayPosOrig-c)+c;\n    rayDir= rotate( theta2,2)*rayDir; \n       \n     vec3 ro = (rayPosOrig) *N_SUBVOXEL;\n   \n\t//if(abs(ro.x -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2.)return vec4(0.,0.,0.,1.);\n       \n\tvec3 ri = 1.0/rayDir;\n\tvec3 rs = sign(rayDir);\n    vec3 pos = floor(ro-rayDir*0.002);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tres.hit=false;\n\tvec3 mm = vec3(0.);\n    float t=0.;\n       \n\tfor( int i=0; i<int(N_SUBVOXEL)*3; i++ ) \n    {\t\n        \n        \n\t\tif(i>=0){\n       \t mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);           \n        }\n         dis += mm * rs * ri;\n         pos += mm * rs;\n        \n        //if( sdBox( ro+t*rayDir-vec3(N_SUBVOXEL/2.),vec3(N_SUBVOXEL/2.) )>.05) {res.hit=false; break;}\n        \n        //float timestep= floor(mod(iTime,N_SUBVOXEL));\n        //SHAPES\n       \n        //SINGLE BLOCK\n        //if( sdBox( pos-vec3(x,x,x) +rs*0.001 ,vec3(.5,.5,.5) )<.01) {res.hit=true; break;}\n     \n\n        if(shape==1){// POLE\n        \tif( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n\t      \n        }else if(shape==2){//STEP 1\n            if(sdBox( pos-vec3(2.,2.,0.)  ,vec3(2.5,2.5,0.5) )<.001) {res.hit=true; break;}\n          \n        }else if(shape==3){//STEP 2\n             if( sdBox( pos-vec3(2.,2.,0.) ,vec3(2.5,2.5,1.5) )<.001) {res.hit=true; break;}\n\n#ifdef ACTIONS\n        }else if(shape==4){//FENCE 1\n         \tif( sdBox( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,2.,4.)  ,vec3(.5,2.5,.5) )<.001) {res.hit=true; break;}\n          \n        }else if(shape==5){//FENCE 2\n        \tif( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(1.,2.,4.)  ,vec3(1.5,.5,.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,1.,4.)  ,vec3(.5,1.5,.5) )<.001) {res.hit=true;break;}\n\n        }else if(shape==6){//SLOPE 1\n            if( dot(pos,  vec3(0.,sqrt(2.),sqrt(2.))) -6. <0.001 \n            && sdBox( pos-vec3(2.,2.,2.),vec3(2.5,2.5,2.5) )<.001  ) {res.hit=true; break;}\n            \n        }else if(shape==7){//PANEL\n            if(sdBox( pos-vec3(0.,2.,2.)  ,vec3(.5,2.5,2.5) )<.001) {res.hit=true; break;}\n#endif           \n        }\n#ifdef TREE_DETAIL        \n        else if(shape==8){//TREE W LEAFS\n            \n     \t\tif( sdCross( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,1.5) )<.001) {res.hit=true; res.vox.id=10.; break;}\n            //vec3 applePos= vec3(1.,1.,1.);//floor(hash33(seed)*5.);\n            //if( sdBox( pos-applePos  ,vec3(.5,.5,.5) )<.01 ){res.hit=true; res.vox.id=14.; break;}\n\n            if( sdBox( pos-vec3(2.,2.,2.)  ,vec3(2.5,2.5,2.5) )<.001 && hash13(floor(pos)+seed+.5 )  >.75){res.hit=true; res.vox.id=11.; break;}\n    \n            //\n        }else if(shape==9){//TRUNK\n\t\t\tvec3 p=pos-vec3(2.,2.,2.);\n            //p= vec3(abs(p.x)+abs(p.y),max(p.x,p.y),p.z);\n            if(sdBox( p ,vec3(1.5,1.5,2.5) )<.001){res.hit=true; res.vox.id=10.; break;}\n         \n        }\n#endif        \n\t}\n\t\n\t\n    if(res.hit){\n        res.normal = - mm*rs; \n        vec4 hitPos=VoxelHitPos(pos,ro,rayDir);\n        res.dist=hitPos.a/N_SUBVOXEL;\n        vec3 xyz = hitPos.xyz - pos;\n        res.uv = vec2( dot(mm.yzx, xyz), dot(mm.zxy, xyz) );\n        if(abs(mm.x)>0.) res.uv=res.uv.yx; //invert xz \n        //relative to absolute normals:\n   \t\tres.normal  = rotate( -theta2,2) * rotate(- theta1,3) *res.normal;\n    }\n    return res;  \n}\n#endif\n\nvec3 skyColor(vec3 rayDir) {\n    \n    vec4 s= sun();\n    float lightLevel = s.w;\n\n    vec3 sunDir=s.xyz;\n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor =mix(vec3(.5,.75,1),vec3(1.,.5,.3),1.-abs(dot(sunDir,vec3(0.,0.,1.))));\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\n\nrayCastResults rayCast(vec3 rayPos0, vec3 rayDir,int maxRayDist,vec4 range,int rayType) {\n\t   \n    voxel vox;\n    vox.id=0.;\n    float waterDist=0.;\n    float fog=0.; \n    rayCastResults res;\n    res.hit = false;\n    res.color=vec3(-1.);\n    res.fresnel=0.;\n    res.mirror=false;\n    rayCastResults subRes;\n    subRes.hit=false;\n\n    vec3 raySign= sign(rayDir);\n    vec3 rayInv = 1./rayDir;\n\tvec3 rayPos=rayPos0;\n    \n    vec3 mapPos=floor(rayPos);\n    if ( rayPos.z >= heightLimit_B && rayDir.z<0.){\n       \n        //MAP RAY FROM ABOVE\n        float nstep= (rayPos.z - heightLimit_B)*rayInv.z;\n        mapPos = floor(rayPos-rayDir *nstep+ raySign*0.001);\n    }\n    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;\n    vec3 mask=vec3(0.); \n\n    \n    //vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    voxel currentVoxel;\n    getVoxel( mapPos,currentVoxel,3);\n    st++;\n\tvec3 hitWater = (currentVoxel.id==12.? rayPos: vec3(0.));\n\tbool xRay=(currentVoxel.id!=0. && currentVoxel.id!=12.);\n     \n    \n    vec3 gLod=vec3(0.);\n    \n    for (int i = 0; i < 1000; i++) {\n\n        \n        if(i>0){\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\n        }\n\t\tsideDist += mask *  raySign *rayInv;\n        mapPos += mask *  raySign;\n        \n        if ( mapPos.z < 0. ) break;\n        if ( mapPos.z >= heightLimit_B && rayDir.z > 0.)  break;\n                   \n     \n         //WIP get chunk max height \n         vec2 c= floor(mapPos.xy/8.)*8.;\n         if(c!=gLod.xy){\n             voxel lod;\n             getVoxel( vec3(c,0), lod ,3 );\n             st++;\n             gLod=vec3(c.xy,lod.groundLod);\n            \n         }\n         //and skip voxel traversal if above max height or max height undefined\n         if(gLod.z==0. || gLod.z>=mapPos.z-5. ) \n         {\n         getVoxel( mapPos, vox ,3 );\n         st++;\n         \n         //if(gLod.z==mapPos.z && vox.id==0.) vox.id=8.; \n         \n        //GRASS\n#ifdef  GRASS_DETAIL      \n        if(vox.id==0. && vox.life>0. && rayType==1 ){\n\t\t\tvec4 vd =VoxelHitPos(mapPos,rayPos,rayDir);\n            res.rayPos= vd.xyz;\n            res.dist=vd.a;\n    \t\tvec3 relativePos = res.rayPos -mapPos;\n            \n            float grass = c_gheight*vox.life;\n           \txs_t xs = trace_grass(relativePos,rayDir,mapPos,grass);\n            \n            if (xs.hit ) {\n                \n                //color = mix(color, c_skycolor, smoothstep(c_maxdist*.35, c_maxdist, xs.l));\n            \tres.hit = true;                \n                res.vox=vox;\n                res.grass=true;\n                res.color=shade_grass(xs);\n                res.mapPos = mapPos;\n                res.water =waterDist;\n    \t\t\tres.fog=fog;\n                res.normal = vec3(0,0,1);\n                res.dist+=  xs.dist ;\n    \t\t\tres.rayPos += rayDir * xs.dist ;\n                return res;\n            } \n\t\n        }\n#endif        \n       \n#ifdef SUBVOXEL        \n        if(vox.shape!=0 && vox.id!=0. ){ \n            //SUB VOXEL\n\n    \t\tvec3 hitVoxelPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            \n            if( sdBox( mapPos+vec3(.5) -rayPos,vec3(.5,.5,.5) )<.001) hitVoxelPos=rayPos;\n            float rotation= vox.rotation;\n            \n             subRes = raySubCast( hitVoxelPos - mapPos ,  rayDir, vox.shape,rotation,mapPos);\n            if(subRes.hit && vox.id!=12.) { \t\t\n       \t\t \tres.hit = true; \n                if(subRes.vox.id!=0.) vox.id=subRes.vox.id;             \n                break;\n            }\n            else if(vox.id==12. && subRes.hit && rayType!=3) { \n            \t//nothing to do\n            }\n            else {vox.id=0.;res.hit = false;}\n        }\n#endif        \n        if(vox.id==14. &&rayType!=3){ //&& length(rayPos-mapPos -vec3(0.,0.,1.))<=6.){\n            //MIRROR \n                \n            vec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            rayDir*= (vec3(1.) - 2.* mask); \t\t\t\t\n            rayDir=normalize(rayDir);rayInv=1./rayDir;raySign= sign(rayDir);\n\n            sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) /rayDir;\n            vox.id=0.;\n            res.mirror=true;\n            rayPos=endRayPos;\n            continue;\n        }\n        if(vox.id==12.  ){ //vox.life < WATER && vox.life>0.){\n        \t//ENTERING WATER\n            if(hitWater.z<1.) {\n                \n                // deviate ray xy if intercept water NOT EXACT                \n    \t\t\tvec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                vec3 n=mask;\n                if(subRes.hit) {\n                    \tendRayPos+=rayDir * subRes.dist;                    \t\n                        n=subRes.normal;\n                }\n     \t\t\thitWater=endRayPos;\n\n                if(abs(n.z)>0.) {\n                    vec2 coord = hitWater.xy;\n                    vec2 dx = vec2( EPSILON, 0. );\n                    vec2 dy = vec2( 0., EPSILON );\n                    float bumpfactor = BUMPFACTOR ;//* (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\n                    vec3 normal = vec3( 0., 0., 1. );\n                    normal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) / (2. * EPSILON);\n                    normal.y = -bumpfactor * (waterHeightMap(coord + dy) - waterHeightMap(coord-dy) ) / (2. * EPSILON);\n                    normal = normalize( normal );\n                   \n                    vec3 rayDirOld=rayDir;\n                    \n                    res.fresnel=fresnelR(rayDir, normal);\n    \t\t\t\t\n                    \n                    rayDir = refract( rayDir, normal ,0.7);\n                    if(res.fresnel>.005){\n                        rayDir = reflect( rayDirOld, normal );\n                        hitWater=vec3(0.,0.,-1.);\n                    }\n                }else if(abs(n.x)>0.) rayDir.yz*=(0.7+.4*noise(endRayPos.yz+iTime));\n                else  rayDir.xz*=(0.7+.4*noise(endRayPos.xz+iTime));\n                rayDir=normalize(rayDir);rayInv=1./rayDir;raySign=sign(rayDir);\n\n                rayPos=endRayPos;\n                sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) /rayDir;\n                               \n            }\n            subRes.hit=false;\n            //vox.id=0.;\n            continue;\n        }\n        if( vox.id !=0. && vox.id!=26. && vox.id!=12. ){\n        \tif(xRay) continue;\n            else{\n            \tres.hit = true; \n                break;\n            }\n        } \n        }\n        \n        //NO HIT\n        xRay=false; \n        if(hitWater.z>0. && vox.id==0.)  {waterDist +=length(hitWater-mapPos); hitWater=vec3(-1.);res.fresnel=.001;}\n        \n        if(!inRange(mapPos.xy, range) || i> maxRayDist) break;\n            \n        \n        //if(i > int( load(_rayLimit).r)) break;\n            \n        \n\t}\n    \n    \n    \n    //END FOR\n    \n    if(hitWater.z>0.)  waterDist +=length(hitWater-mapPos);\n    if(hitWater.z<0.)  waterDist =0.;   //reflection\n    \n    \n    if(load(_stats).r>0.5){\n       \n        vec4 range_C1= calcLoadRange_C(rayPos.xy,iResolution.xy,1.);\n        \n        vec4 range_C0= load(_old +_loadRange_C );\n\n        if(res.hit && inRange(mapPos.xy, range_C0)  && !inRange(mapPos.xy, range_C1)) vox.id = 17.;    \n\n    }\n        \n    if(!res.hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){\n        if(mapPos.z>WATER_LEVEL) {vox.id = 0.; res.hit=false;}\n        else { vox.id=12.; vox.shape=0; res.hit = true;}\n    }\n    \n    res.mapPos = mapPos;\n    res.normal = res.hit? -raySign * mask:vec3(0.);\n    res.rayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n    res.dist = length(rayPos0 - res.rayPos);\n    res.vox=vox;\n    res.water =waterDist;\n    res.fog=fog;\n    \n    if(subRes.hit){\n        \n       \tres.normal=  subRes.normal; \n      \tmask=abs(subRes.normal);\n        res.rayPos += rayDir * subRes.dist ;\n        res.dist = length(rayPos - res.rayPos);\n        \n#ifdef SUBTEXTURE\n        // uv coordinates are relative to subvoxel (more detailed but aliased)\n    \tres.uv_txt = subRes.uv ;\n    \t//return res;\n#endif\n    }\n    \n    //uv coordinates are relative to block (also with subvoxels)                       \n    if (abs(mask.x) > 0.) {\n        res.uv = fract(res.rayPos.yz);\n    }\n    else if (abs(mask.y) > 0.) {\n        res.uv = fract(res.rayPos.xz);\n    }\n    else {\n        res.uv = fract(res.rayPos.yx);\n    }  \n    if(res.hit && !res.grass){\n        float textureId = res.vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        vec2 uv_txt= res.uv;\n#ifdef SUBTEXTURE                \n        if(res.vox.shape!=0) uv_txt= res.uv_txt;\n#endif               \n\n#ifdef TEXTURE\n#if TEXTURE>1        \n        for(int i= min(iFrame,0);i<TEXTURE;i++) {\n            float d = min(.005 * res.dist,1.);           \n            vec2 uv = uv_txt + d* (hash33(res.rayPos).xy-.5);\n    \t\tres.color = getTexture(textureId, uv).rgb;\n        }\n#else\n        res.color = getTexture(textureId, uv_txt).rgb;\n#endif \n#else        \n        res.color = getTexture(textureId, vec2(0.)).rgb;\n#endif        \n        \n    } \n    if(!res.hit){   \t\n         res.color = skyColor(rayDir);\n    ;\n    }\n    return res;\n}\n\n\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n#define NB_AO 4 // Reduce if slow\n\n#if OCCLUSION==2\nvec3 randomHemisphereDirectiond(vec3 n,  float seed) {\n    vec2 r = 2.*PI*hash22(seed);\n    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n    float k = dot(dr,n);\n    return k == 0. ? n : normalize(k*dr);\n}\n\nfloat calcAmbientOcclusion( vec3 ro,  vec3 n, float dMax, int maxRayDist,vec4 range_C) {\n    float val, ao = 0., seed = ro.x+ro.y+.12345*ro.z;\n    vec3 n2, rd;\n    rayCastResults  res;\n    for (int i=0;i<NB_AO; i++){\n        rd = randomHemisphereDirection(n, seed);    \n        seed += .1;\n               \n        res=rayCast(ro, rd,maxRayDist,range_C,3);\n        if (res.hit && res.dist< dMax) {\n            ao += clamp((dMax-res.dist)/dMax,0.,1.);\n        }\n    }\n    return (ao/float(NB_AO));\n}\n#endif\n\nvoid render( out vec4 fragColor, vec3 rayPos, vec3 rayDir ,int  maxRayDist, int rayType) {\n\n    vec3 old_offset = floor(vec3(load(_old+_cachePos).xy, 0.));\n    vec4 range_C= calcLoadRange_C(old_offset.xy,iChannelResolution[2].xy,0.);\\\n    //vec4 range_C = load(_old+_loadRange_C);\n    vec3 sunDir = sun().xyz; sunDir *= sign(sunDir.z);\n      \n    rayCastResults rays[2] ;//0=view,1 =shadow\n    vec3 ro=rayPos;\n    vec3 rd=rayDir;\n    int rt=rayType;\n    for(int i=0; i<=1;i++){\n    \trays[i]=rayCast(ro, rd,maxRayDist,range_C,rt);\n\t\tif(!rays[i].hit) break;\n \t\tif(SHADOW<0.) break;\n        ro=rays[i].rayPos +rays[i].normal*0.001;\n        rd=sunDir;\n        maxRayDist=  inRange(rays[i].rayPos.xy, range_C) ? 75:5;\n        rt=3;\n            \n    }\n    \n   rayCastResults res = rays[0];\n\t\n\tvec3 color = vec3(0.);\n    vec3 wcolor= vec3(.03,.2,.4) //vec3(.03,.1,.60)\n        * lightmap( vec2(res.vox.light.s,res.vox.light.t)   );\n    \n    if (res.hit) {\n        \n\t\t\t\n        float shadow =mix(rays[1].hit  ?SHADOW:0.  ,SHADOW, 1.- pow(abs(dot(sunDir,vec3(0.,0.,1.))),.3)) ;\n\n        color=res.color;\n\n\n        if(rayType==1 ){\n         \n            if(res.grass) {              \n            \tcolor *= lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );                 \n            }else{\n               #if OCCLUSION==2\n                \t\n                \tcolor *= lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );\n                    color*= 1. - .8*calcAmbientOcclusion( res.rayPos+res.normal*0.001, res.normal, 2.,  3, range_C) ;\n                #else\n                if(inRange(res.rayPos.xy, range_C)){\n              \t\tvec3 occ=calcOcclusion(res.mapPos, res.normal, res.uv,res.vox);\n                    color *= lightmap(vec2(occ.x*(1.-shadow*.2),occ.y)) *occ.z; \n                }else{\n                \tcolor *= .75*lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );\n                }\n                #endif\n            }\n#ifdef ACTIONS\t\t\t\n            // SELECTION AND MOUSE OVER\n            vec4 pick = load(_pick);\n            if (res.mapPos == pick.xyz || res.vox.value==2) {\n                if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n                else if (res.vox.value==2) color = mix(color, vec3(1.,0.,0.), 0.5);\n                \n                else color = mix(color, vec3(1), 0.2);\n            }\n#endif            \n        }else\n        {\t\n            //MAP\n \t\t\t color *=  clamp( (res.mapPos.z-30.) /30.,0.,1.);\n            color = mix(color, vec3(1), 0.2);\n          \n        }\n        \n    }\n     else color = res.color;\n     \n    \n    \n    //if(res.water>0.) color *= pow( wcolor ,vec3(sqrt(res.water)/(7. + res.fresnel*1000.)));\n    if(res.water>0.) {\n        color *= pow( wcolor ,vec3(sqrt(res.water)/7.));\n        color = mix(color,wcolor, clamp(res.fresnel*500.,0.3,1.));\n    }\n    else if(res.fresnel>0. ) color =mix(wcolor ,color,clamp(res.fresnel*4.,0.,.75));\n    if(res.mirror) color *= vec3(.9,.5,.5);\n    if(rayType==1) {\n\n        color = pow( color, vec3(1./1.5) );\n            \n    }\n    fragColor.rgb = color; //pow(color, vec3(1.));\n#ifdef ACTIONS    \n    if(rayType==3 ) {\n        \n        float encodeNormal=14.+ res.normal.x + res.normal.y*3. + res.normal.z*9.;\n        fragColor=vec4(res.mapPos,(res.hit && res.dist >1. && res.dist <MAX_PICK_DISTANCE ? encodeNormal:0.));\n    }  \n#endif     \n    //DEBUG:\n    //fragColor=vec4( vec2(1.- res.dist /50.),  res.hit?1.:0.,1.);\n    //fragColor=vec4( (1.-.5* sign(res.normal))* abs(res.normal) ,1.);\n    //fragColor=vec4( res.uv,max(abs(res.uv -.5).x,abs(res.uv-.5).y)<.5?1:0 ,1.);\n    //if(res.vox.id==12.) fragColor=vec4(vec2(res.vox.life<2. ? .5:0.),1.- res.vox.life/255.,1.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n    float loading= float(iFrame) -load(_textureSize).z;\n    if(loading>LOAD_TIME  && iFrame% 4>0  ){\n        fragColor=texture(iChannel3, fragCoord/iChannelResolution[3].xy );\n    \treturn;\n    }\n        \n    vec3 cameraPos;    \n    vec3 cameraDir;\n    int  rayType = 1;\n \n#ifdef MAP    \n    float MAP_SIZE= iResolution.y/8./pixelSize; \n    vec2 MapCenter=vec2(iResolution.x/pixelSize -MAP_SIZE , iResolution.y/pixelSize - MAP_SIZE);\n    if(abs(load(_map).r-1.) <.1 && distance(fragCoord,MapCenter)<MAP_SIZE) rayType=2;\n    if(abs(load(_map).r-2.) <.1) {\n        rayType=2;\n        MapCenter=vec2(iResolution.x/pixelSize/2. , iResolution.y/pixelSize/2.);\n    }\n    \n#endif    \n \n#ifdef ACTIONS\n    if(max(fragCoord.x,fragCoord.y)<1. ) rayType=3;\n    if(rayType==3){\n        //MOUSE RAY\n        float zoom = pow(10., load(_renderScale).r/10.);///pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (iMouse.xy- renderCenter) / renderResolution - (renderCenter/zoom);//  /pixelSize;\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n  \n    } else\n#endif        \n#ifdef MAP \n     if(rayType==2){\n     \n        // MAP CAMERA\n        float cameraHeight =1500.;\n        float zoom = cameraHeight/iResolution.x/pixelSize*(load(_map).r>1.5?1.6:.4);\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=MapCenter/iResolution.xy*pixelSize;\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);    \n        vec2 angle = vec2(0.,PI);\n        if(load(_map).r>1.5){\n        \tangle=iMouse.xy/iResolution.xy*vec2(PI,-PI/3.)+vec2(0,PI);\n        }\n        cameraDir = rayDirection(angle,uv,renderResolution); \n        vec3 cameraCenterDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n        cameraPos = load(_pos).xyz -cameraCenterDir* cameraHeight;\n    }  else     \n#endif            \n     if(rayType==1) \n    {    \n        // MAIN CAMERA\n        float zoom = pow(10., load(_renderScale).r/10.)/pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n           \n    }   \n\t\n    //MOTION BLUR\n    render(fragColor,cameraPos, cameraDir, int(load(_rayDistMax).r),rayType);\n     \n     if(loading>LOAD_TIME +2.) fragColor=mix(fragColor,texture(iChannel3, fragCoord/iChannelResolution[3].xy ),.1);\n    \n    if(loading<LOAD_TIME  && fragCoord.y >renderResolution.y-1.) fragColor=vec4(1.);\n    //MAP BORDER:\n#ifdef MAP\n    if(rayType==2){\n        if(load(_map).r <1.5){\n        \tif(abs(distance(fragCoord,MapCenter)-MAP_SIZE)<1.) fragColor.rgb=vec3(0.);    \n        \tif(distance(fragCoord,MapCenter + vec2(sin( load(_angle).x), -cos( load(_angle).x))*MAP_SIZE )<3.) fragColor.rgb= vec3(1.,0.,0.);\n        }\n    }\n#endif        \n    //fragColor = texture(iChannel2, fragCoord / 3. / iResolution.xy);\n    //if(st>150) fragColor.x= float(st)/300.;\n}","name":"Buffer D","description":"","type":"buffer"}]}