{"ver":"0.1","info":{"id":"fsj3DD","date":"1619789368","viewed":176,"name":"MM TaikooHui Environment iris","username":"Corstiaan","description":"Creating particles for a work (Unity) project","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["radial","particles","work"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// AntiAlias, scale with UV scale\nfloat aa(float localScale)\n{\n    float smoothness = 2.0;\n    return smoothness/iResolution.x*localScale*SCALE;\n}\n\n// SDF\nfloat sdfPoint(vec2 p)\n{\n    return length(p);\n}\n\n// Mask\nfloat Circle(vec2 p, float r, float blur)\n{\n    return 1.-thresh(length(p), r, aa(blur*1.5));\n}\n\n// animation\nfloat tween(float t, float start, float end)\n{\n    t =  max(0., min(1.,t));\n    return start + t * (end - start);\n}\n\nfloat tLoopOffset(float duration, float offset)\n{\n    return fract((iTime * SPEED - offset) / duration);\n}\n\nvec4 GlowCircle(vec2 p, vec3 colorCenter, vec3 colorGlow, float r, float blur)\n{\n    float layerGlow = \tCircle(p, r+.01, blur);\n    float layerCenter =  Circle(p, r, blur / 2.);\n    \n    vec4 layers = vec4(0.);\n    layers = blend(layers, vec4(colorGlow, layerGlow), layerGlow);\n    layers = blend(layers, vec4(colorCenter, layerCenter), layerCenter);\n    \n    return layers;\n}\n\nvec4 Particle(vec2 uv, int id, float rnd, float size, vec3 colorCenter, vec3 colorGlow, float angle, float time, float dist)\n{\n    float translate = easeOutCube(time) * dist;\n    float lifeAlpha = (1.-cos((pow(time,1.2))*TWO_PI))/2.;\n    angle = angle + ((rnd * 2.)-1.) * 20. * pow(lifeAlpha,(rnd * 1.15));// wiggle\n    vec2 rotUV = uv * rot2d(angle) - vec2(translate, 0.);\n    \n    size = mix(size*.3, size*.1, easeOutCube(time)) * (1.+(rnd-0.5)*2.);\n    float blur = mix(100., 5., lifeAlpha);\n    \n    vec4 prtcl = GlowCircle(rotUV, colorCenter, colorGlow, size, blur);\n    prtcl.w *= lifeAlpha;\n    \n    return prtcl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    UV *= SCALE;\n    vec2 mouse = (iMouse.xy / iResolution.xy);\n    \n    float timeOffset = 0.;\n    float time = tLoopOffset(10., timeOffset);\n        \n    vec4 col = vec4(BLACK, 0.);\n    int prtCount = 1500;\n    float lifeTime = 5.;\n    float prtSize = .07;\n    float irisSize = 0.45;\n    float angleFill = mouse.x;\n    \n    // angle 0 - 1\n    float a = fract((atan(UV.y, UV.x) + PI)/TWO_PI)*TWO_PI;\n    \n    float laneWidth = 0.3;\n    \n    float minA = a - (laneWidth * 0.5);\n    if (minA < 0.) minA += 1.;\n    float maxA = a + (laneWidth * 0.5);\n    if (maxA > 1.) maxA -= 1.;\n    \n    // system\n    for(int i = 0; i < prtCount; i++)\n    {\n        float fI = float(i);\n        float normalizedI = fI / float(prtCount);\n    \n        float rndA = hash12(vec2(0.1237, i));\n        float rndB = hash12(vec2(1.7365, i));\n        float locTime = tLoopOffset(lifeTime + (rndA * 0.2)-0.1, rndB * lifeTime);\n        float angle = normalizedI * 360.;\n        \n        vec4 prtcl = vec4(0.);\n        prtcl = Particle(UV, i, rndA, prtSize, BLUE, BLUE, angle, locTime, irisSize);\n        col = blendAdd(col, prtcl, prtcl.w);\n        prtcl = Particle(UV, i, rndA, prtSize, BLUE, BLUE, angle, locTime, irisSize*0.6);\n        col = blendAdd(col, prtcl, prtcl.w*0.3);\n    }\n\n    // Output to screen\n    vec4 tex = texture(iChannel0, UV/SCALE) * 0.7;\n    fragColor = blendAdd(tex, col, col.w);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433832795\n#define TWO_PI (2.0*PI)\n#define HALF_PI (0.5*PI)\n#define sat(a) clamp(a,0.,1.)\n\nconst float SPEED = 1.0;\nconst float SCALE = 1.0;\nconst vec3 BRIGHTNESS = vec3(1.);\nconst vec3 BLUE = vec3(0.398,0.808,1.0);\nconst vec3 YELLOW = vec3(1.,1.,0.);\nconst vec3 WHITE = vec3(1.);\nconst vec3 BLACK = vec3(0.);\n\nfloat sgm(float f)\n{\n    float a = 15.;\n    return 1.0/(1.0 + exp(-(f-0.5)*a));\n}\n\nfloat clamp01(float n) {     return clamp(n,0.,1.); }\nfloat easeInQuad(float t) {  return t*t; }\nfloat easeOutExpo(float x) { return x == 1. ? 1. : 1. - pow(2., -10. * x); }\nfloat easeOutCube(float x) { return 1. - pow(1. - x, 3.); }\n\nmat2 rot2d(float deg)\n{\n    float rad = radians(deg);\n    return mat2(cos(rad), -sin(rad),\n                sin(rad), cos(rad));\n}\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 1 input (source: https://www.shadertoy.com/view/ttc3zr) thnx!\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 2 inputs (source: https://www.shadertoy.com/view/ttc3zr) thnx!\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nvec2 Polar(vec2 p, float radRot)\n{\n    float rho = length(p);\n    float phi = fract((atan(p.y, p.x) + PI + radRot)/TWO_PI)*TWO_PI;\n    \n    return vec2(rho, phi);\n}\n\nvec4 blend(vec4 bot, vec4 top, float p)\n{\n \tvec3 bot2 = pow(bot.rgb, vec3(2.2));\n    vec3 top2 = pow(top.rgb, vec3(2.2));\n    float alpha = mix(bot.a, top.a, p);\n    \n    return vec4(pow(mix(bot2, top2, p), vec3(1.0 / 2.2)), alpha);\n}\n\nvec4 blendAdd(vec4 bot, vec4 top, float factor)\n{\n    float glow = 0.;\n    \n    top.rgb *= factor;\n    top.a *= (1.-glow) * factor;\n\n    vec3 rgb = top.rgb + (bot.rgb * (1.0 - top.a));\n    float a = top.a   + (bot.a   * (1.0 - top.a));\n\n    return vec4(rgb, a);\n}\n\nfloat thresh(float base, float val, float blur)\n{\n    // divides a gradient 0-1 in black and white with:\n    // base: the gradient / coordinate system\n    // val: middle of the threshold\n    // width: width of the threshold\n    return smoothstep(val-(blur/2.), val+(blur/2.), base);\n}\n","name":"Common","description":"","type":"common"}]}