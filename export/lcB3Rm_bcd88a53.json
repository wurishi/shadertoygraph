{"ver":"0.1","info":{"id":"lcB3Rm","date":"1703983279","viewed":80,"name":"Nitzanim Logo","username":"andersource","description":"nitzanim.tech","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["logo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 shadow_col = texture(iChannel1, uv).xyz;\n    if (length(col) == sqrt(3.) && length(shadow_col) < sqrt(3.)) col = shadow_col;\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat circleSDF(in vec2 p, in vec2 c, in float r)\n{\n    return length(p - c) - r;\n}\n\nfloat roundOrientedBoxSDF(in vec2 p, in vec2 a, in vec2 b, float th)\n{\n    return min(\n        min(circleSDF(p, a, th / 2.), circleSDF(p, b, th / 2.)),\n        sdOrientedBox(p, a, b, th)\n    );\n}\n\nvec2 get_p1()\n{\n    vec2 p1 = vec2(51., -13.) / 135. * 2. - vec2(1., -1.07);\n    p1 *= 0.;\n    p1.x += .75 * sin(iTime * 1.3);\n    p1.y += .81 * sin(iTime * 2.1);\n    return p1;\n}\n\nvec2 get_p2()\n{\n    vec2 p2 = vec2(117., -24.) / 135. * 2. - vec2(1., -1.07);\n    p2 *= 0.;\n    p2.x += .7 * sin(iTime * .4);\n    p2.y += .65 * sin(iTime * 3.);\n    return p2;\n}\n\nvec2 get_p3()\n{\n    vec2 p3 = vec2(121., -90) / 135. * 2. - vec2(1., -1.07);\n    p3 *= 0.;\n    p3.x += .85 * sin(iTime * 2.7);\n    p3.y += .72 * sin(-iTime * .6);\n    return p3;\n}\n\nvec2 get_p4()\n{\n    vec2 p4 = vec2(13., -132.) / 135. * 2. - vec2(1., -1.07);\n    p4 *= 0.;\n    p4.x += .6 * sin(-iTime * 2.);\n    p4.y += .65 * sin(iTime * 1.6);\n    return p4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float THICKNESS = .225;\n    const float METABALL_THRESHOLD = 5.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.- iResolution.xy) / iResolution.y;\n\n    vec2 p1 = get_p1();\n    vec2 p2 = get_p2();\n    vec2 p3 = get_p3();\n    vec2 p4 = get_p4();\n    \n    vec3 c1 = vec3(190., 21., 34.) / 255.; // red\n    vec3 c2 = vec3(0., 129., 201.) / 255.; // middle blue\n    vec3 c3 = vec3(143., 212., 246.) / 255.; // light blue\n    vec3 c4 = vec3(0., 79., 145.) / 255.; // dark blue\n    vec3 c1_3 = vec3(130., 38., 44.) / 255.;\n    vec3 c1_4 = vec3(40., 40., 42.) / 255.;\n    vec3 c4_2 = vec3(1., 65., 134.) / 255.;\n    \n    float d1 = roundOrientedBoxSDF(uv, p1, p2, THICKNESS);\n    float d2 = roundOrientedBoxSDF(uv, p3, p4, THICKNESS);\n    float d3 = roundOrientedBoxSDF(uv, p2, p4, THICKNESS);\n    float d4 = roundOrientedBoxSDF(uv, p3, p1, THICKNESS);\n    \n    vec3 col = vec3(1., 1., 1.);\n    \n    if (d1 < 0.){\n        if (d3 < 0.) col = c1_3;\n        else if (d4 < 0.) col = c1_4;\n        else col = c1;\n    }\n    else if (d2 < 0.) {\n        if (d4 < 0.) col = c4_2;\n        else col = c2;\n    }\n    else if (d3 < 0.) {\n        col = c3;\n    }\n    else if (d4 < 0.) {\n        col = c4;\n    }\n    \n    if (length(col) == sqrt(3.))\n    {\n        float total_d1, total_d2, total_d3, total_d4;\n        total_d1 = total_d2 = total_d3 = total_d4 = 0.;\n        for (float x = -1.7; x < 1.9; x += .23)\n        {\n            for (float y = -1.2; y < 1.2; y += .23)\n            {\n                vec2 center = vec2(x, y);\n                float r = .02 + sin(iTime + (y / x) * 102.5) * .02;\n                float r1 = min(r * .18 / (.14 + d1), .5);\n                float r2 = min(r * .18 / (.14 + d2), .5);\n                float r3 = min(r * .18 / (.14 + d3), .5);\n                float r4 = min(r * .18 / (.14 + d4), .5);\n                center.x += sin(iTime + 1001. * (x + y)) * .1;\n                center.y += sin(iTime + x * y * 504.) * .24;\n                float d_d1 = r1 / length(uv - center);\n                float d_d2 = r2 / length(uv - center);\n                float d_d3 = r3 / length(uv - center);\n                float d_d4 = r4 / length(uv - center);\n                total_d1 += d_d1;\n                total_d2 += d_d2;\n                total_d3 += d_d3;\n                total_d4 += d_d4;\n            }\n        }\n\n        if (total_d1 > METABALL_THRESHOLD) col = c1;\n        else if (total_d2 > METABALL_THRESHOLD) col = c2;\n        else if (total_d3 > METABALL_THRESHOLD) col = c3;\n        else if (total_d4 > METABALL_THRESHOLD) col = c4;\n        // if (total_d + d1_t > 104.6) col = c1;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float BLUR_SIZE = 25.;\n    const float BLUR_STEP = 3.;\n    vec2 uv = fragCoord / iResolution.xy;\n    float c = 0.;\n    vec3 shadow_col;\n    float count = 0.;\n    for (float i = -BLUR_SIZE + 1.; i < BLUR_SIZE; i += BLUR_STEP)\n    {\n        for (float j = -BLUR_SIZE + 1.; j < BLUR_SIZE; j += BLUR_STEP)\n        {\n            shadow_col = texture(iChannel0, uv + 1.5 * vec2(-.01, .02) + vec2(i, j) / iResolution.xy).xyz;\n            c += length(shadow_col) < sqrt(3.) ? 1. : 0.;\n            count += 1.;\n        }\n    }\n    \n    c /= count;\n    c *= .5;\n    vec3 col = vec3(1. - c, 1. - c, 1. - c);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}