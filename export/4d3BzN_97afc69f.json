{"ver":"0.1","info":{"id":"4d3BzN","date":"1524162355","viewed":212,"name":"Modulo with walls","username":"Daedelus","description":"Modulo with walls to show how you can do random shapes and offsets in a grid while reducing glitches\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdfmodulu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// an example of a 2D distance field with modulo\n// that includes boundaries per-cell in the distance function\n// to avoid glitches\n\n// comment out the define \"boundaries\" to show glitches that occur\n// when having randomness per cell\n\n// Because the ray has to slow down and consider every wall this does \n// require a lot more sphere tracing steps than usual but I find, when\n// used in the right way (with e.g. a max() to contain it inside another\n// shape, or under a certain plane) it works wonders for randomness.\nfloat fField(vec3 point)\n{\n    // modulo by vec3(1.0)\n    vec3 cell = floor(point + 0.5);\n    point = fract(point + 0.5) - 0.5;\n    \n    // random sized sphere per cell\n    // normally I'd use a hash function:\n    // like https://www.shadertoy.com/view/4djSRW\n    // to get a random value\n    float sphere = length(point) - fract(sin(cell.x + cell.y * 123.0 + cell.z * 0.321)) * 0.4;\n    \n    // Cell boundary shape computed with fBox()\n    vec3 q = abs(point);\n    float boundary = max(q.x, max(q.y, q.z));\n    // we want the cube to be the walls, so it has to be negative\n    boundary = 0.51 - boundary;\n    \n    // half the cell size is 0.5, but adding that 0.01 pushes the box outside of the cell\n    // making it invisible, and in return it means that objects inside the cell have to be at least 0.1 away from the edge\n    // which is why the max sphere radius = 0.4\n    \n    // push the box more to avoid the box appearing in the distance when sphere tracing\n    // this does mean the sphere should also decrease in size by distance\n    // to adhere to the \"minimum distance from cell boundary == box overshooting\" rule\n    \n    return min(boundary, sphere);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Aspect ratio corrected UV\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Scale UV so we can have enough cells of size 1 on the screen\n    // uv *= 4.0;\n    \n    // because it's 2D I'm not doing any sphere tracing\n    // but the distance field remains the same\n    float d = fField(vec3(uv, 0.0));\n\n    // visualize the object and the signed distance gradient\n    // you can see the colored rings don't match up, this is the glitch\n    // you'll see when sphere tracing\n    fragColor = vec4((vec3(fract(d * 2.0),\n                           fract(d * 8.0),\n                           fract(d * 20.0)) + step(0.0, -d)) * 0.5, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}