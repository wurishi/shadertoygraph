{"ver":"0.1","info":{"id":"NlVcWw","date":"1661614104","viewed":76,"name":"MicroLife","username":"Nicemice","description":"This shader was inspired from: https://www.youtube.com/watch?v=0Kx4Y9TVMGg ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["particles","life","signeddistancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// the sigend distance field renderingi s based on: https://www.shadertoy.com/view/4dfXDn\n\nint particlesPerGroup = 200;\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nfloat computeDistance(int groupIndex, vec2 p) {\n    float dist = 100000.0;\n    for(int i = 0; i < particlesPerGroup; ++i) {\n        ivec2 uv = ivec2(i, groupIndex);\n        vec4 other_particle = texelFetch(iChannel0, uv,0);\n        float posX = other_particle.x;\n        float posY = other_particle.y;\n        dist = merge(dist, circleDist(translate(p,other_particle.xy),10.0));\n    }\n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n    \n    float dist1 = computeDistance(0,p);\n    float dist2 = computeDistance(1,p);\n    float dist3 = computeDistance(2,p);\n    //float dist4 = computeDistance(3,p);\n    //float dist5 = computeDistance(4,p);\n   \n\tvec4 col = vec4(1.0, 0.0, 0.1, 1.0) * fillMask(dist1);\n    col += vec4(1.0, 1.0, 0.0, 1.0) * fillMask(dist2);\n    col += vec4(0.0, 1.0, 0.0, 0.6) * fillMask(dist3);\n    //col += vec4(0.0, 0.0, 1.0, 1.0) * fillMask(dist4);\n    //col += vec4(1.0, 1.0, 0.0, 1.0) * fillMask(dist5);\n\tfragColor = clamp(col, 0.0, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// the particle model is based on: https://www.youtube.com/watch?v=0Kx4Y9TVMGg\n\nint particlesPerGroup = 200;\n\nvec2 computeForce(float g, vec4 particle, int groupIndex, int self) {\n    vec2 force = vec2(0.0,0.0);\n    for(int i = 0; i < particlesPerGroup; ++i) {\n        ivec2 uv = ivec2(i, groupIndex);\n        vec4 other_particle = texelFetch(iChannel0, uv,0);\n        vec2 delta = particle.xy - other_particle.xy;\n        float d =sqrt(dot(delta,delta));\n        if (d > 0.0) {\n            float F = g / exp(d/20.0);\n            force += F * delta;\n        }\n    }\n    return force;\n}\n\nint groups = 3;\nint red = 0;\nint yellow = 1;\nint green = 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(fragCoord.x) >= particlesPerGroup || int(fragCoord.y) >= groups) {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n    vec4 particle = texelFetch(iChannel0, ivec2(fragCoord),0);\n       \n    float t = 0.05;\n    \n    int self = int(fragCoord.x);\n    int group = int(fragCoord.y);\n    \n    vec2 f = vec2(0.0,0.0);\n    \n    if (group == red) {\n        f += computeForce(-0.1,particle, red, self );\n        f += computeForce(-0.34, particle, green, self);\n        //particle.zw += t * computeForce(-0.04,particle, 3);\n        //particle.zw += t * computeForce(-0.05,particle, 4);\n    } else if (group == yellow) {\n        f += computeForce(0.15,particle, yellow, self);\n        f += computeForce(-0.2,particle, red, self);\n    } else if (group == green) {\n        f += computeForce(-0.32,particle, green, self);\n        f += computeForce(-0.17,particle, red, self);\n        f += computeForce(0.34,particle, yellow, self);\n    }\n       \n    \n    if (iFrame <= 0) {\n        // initialization\n        particle.xy = 40.0 * vec2(texelFetch(iChannel1, ivec2(fragCoord),0).x,texelFetch(iChannel1, ivec2(fragCoord)+10,0).x);\n    } else {\n        particle.zw = f + particle.zw * 0.95;\n        particle.xy += particle.zw;\n    }\n    \n    if (particle.x < 0.0 || particle.x > iResolution.x) {\n        particle.x = clamp(particle.x,0.0, iResolution.x);\n        particle.z = -particle.z;\n        particle.zw *= 0.5;\n    }\n    if (particle.y < 0.0 || particle.y > iResolution.y) {\n        particle.y = clamp(particle.y,0.0, iResolution.y);\n        particle.zw *= 0.5;\n        particle.w = -particle.w;\n    }\n   \n       \n    \n    fragColor = particle;\n}","name":"Buffer A","description":"","type":"buffer"}]}