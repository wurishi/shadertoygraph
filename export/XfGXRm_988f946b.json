{"ver":"0.1","info":{"id":"XfGXRm","date":"1715184429","viewed":33,"name":"CubeWave","username":"Plastic","description":"Heightmap represented by cubes.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rot(vec3 ang)\n{\n    mat3 rotx = mat3(\n        1., .0, .0,\n        .0, cos(ang.x), sin(ang.x),\n        .0, -sin(ang.x), cos(ang.x)\n    );\n    \n    mat3 roty = mat3(\n        cos(ang.y), .0, sin(ang.y),\n        .0, 1., .0,\n        -sin(ang.y), .0, cos(ang.y)\n    );\n    \n    mat3 rotz = mat3(\n        cos(ang.z), sin(ang.z), .0,\n        -sin(ang.z), cos(ang.z), .0,\n        .0, .0, 1.\n    );\n    \n    return rotx*roty*rotz;\n\n}\n\n\nfloat box(vec3 p, vec3 r, vec3 o)\n{\n    float d = length(max(abs(p-o)-r, .0));\n    \n    return d;\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return length(c-p)-r;\n}\n\nfloat whatever(vec3 p, vec3 c)\n{\n    vec3 f = p-c;\n    return dot(sin(f*0.07), cos(f*0.07)*rot(vec3(.0, atan(f.x/f.z), .0)));\n}\n\nfloat random(vec3 p)\n{\n    float a = (sin(0.3*p.x+iTime))+(sin(0.3*p.z-iTime));\n    \n    return a*a*2.;\n}\n\nvec3 blockid(vec3 p)\n{\n    return floor(0.5*p+0.5);\n}\n\nfloat torender(vec3 p)\n{\n    vec3 repeat = vec3(2.*((0.5*p+0.5)-floor(0.5*p+0.5))-1.);\n    \n    float offsety = p.y-(random(blockid(p)));\n    \n    float a = box(vec3(repeat.x, offsety, repeat.z), vec3(0.5), vec3(.0));\n    float b = sphere(p, 20., vec3(.0, 20, .0));\n    float c = whatever(p*rot(vec3(.0, iTime, .0)), vec3(.0, 30., .0));\n    \n    return min(a-4., b);\n    //return max(c, b);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, .0);\n    vec3 normal = normalize(vec3(\n        torender(p)-torender(p-e.xyy),\n        torender(p)-torender(p-e.yxy),\n        torender(p)-torender(p-e.yyx)\n    ));\n    \n    return normal;\n}\n\nfloat general(vec3 o, vec3 d, float fac)\n{\n    int iter = 100;\n    \n    float sens = 0.001;\n    \n    float travdist = sens;\n    float resetdist = 200.;\n    \n    float penumbra = 1.;\n    \n    for(int i = 0; i<iter; i++)\n    {\n        vec3 currentpos = o + travdist * d;\n        float check = torender(currentpos);\n        if(check < sens)\n        {\n            return .0;\n        }\n        \n        penumbra = min(penumbra, fac*check/travdist);\n        \n        if(travdist > resetdist)\n        {\n            break;\n        }\n        \n        travdist += check*0.25;\n        \n    }\n    \n    return penumbra;\n    \n}\n\nvec3 calcol(vec3 o, vec3 currentpos, vec3 lightpos, vec3 sky)\n{\n    vec3 viewdir = normalize(currentpos - o);\n    vec3 halfway = (lightpos-viewdir)/length(lightpos-viewdir);\n    vec3 n = normal(currentpos);\n            \n    //float diffuse = max(dot(reflect(viewdir, n), lightpos), 0.8);\n            \n    vec3 col = mix(vec3(0.2, 0.5, 0.2), vec3(0., 0.5, 0.5), sin(currentpos.y*0.2)*0.5+0.5)+pow(max(dot(halfway, n), .0), 40.)*0.9;\n    return mix(sky, col*max(general(currentpos, lightpos, 2.), 0.2), exp(-0.006*distance(o, currentpos)));\n\n}\n\nvec3 ambient(vec3 o, vec3 d, vec3 lightpos, vec3 sky)\n{\n    int iter = 300;\n    float travdist = 0.0015;\n    float resetdist = 300.;\n    \n    for(int i = 0; i<iter; i++)\n    {\n        vec3 pos = o + travdist * d;\n        float check = torender(pos);\n        \n        if(check < 0.001)\n        {\n            return calcol(o, pos, lightpos, sky);\n        }\n        if(travdist > resetdist)\n        {\n            break;\n        }\n        \n        travdist += check*0.25;\n        \n    }\n    \n    return sky;\n\n}\n\nvec3 March(vec3 o, vec3 dir)\n{\n    int iter = 300;\n    float travdist = .0;\n    float resetdist = 300.;\n    \n    vec3 reference = vec3(1., 4., 10.);\n    \n    vec3 lightpos = normalize(reference);\n    vec3 sky = vec3(0.7, 0.9, 0.9);\n    \n    for(int i = 0; i<iter; i++)\n    {\n        vec3 currentpos = o + travdist * dir;\n        \n        vec3 id = blockid(currentpos);\n        \n        float check = torender(currentpos);\n        \n        if(check < 0.1)\n        {\n            vec3 skin = calcol(o, currentpos, lightpos, sky);\n            \n            vec3 viewdir = normalize(currentpos - o);\n            vec3 n = normal(currentpos);\n            \n            vec3 rfl = ambient(currentpos, reflect(viewdir, n), lightpos, sky);\n            return mix(skin, rfl, 0.2);\n        }\n        if(travdist > resetdist)\n        {\n            break;\n        }\n        \n        travdist += check*0.25;\n    }\n    \n    return sky;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 cam = vec3(30., 40., -40.);\n    //vec3 cam = vec3(0., 0., -60.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1.))*rot(vec3(-0.4, -0.6, .0));\n    //vec3 dir = normalize(vec3(uv.x, uv.y, 1.));\n\n    vec3 final = March(cam, dir);\n    \n    fragColor = vec4(final,1.0);\n}","name":"Image","description":"","type":"image"}]}