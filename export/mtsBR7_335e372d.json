{"ver":"0.1","info":{"id":"mtsBR7","date":"1694058438","viewed":89,"name":"Raymarch tracing refraction","username":"flooferdoodle","description":"raymarching with glass","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV = 90.0;\n\nconst int MAX_BOUNCES = 20;\n\nconst int MAX_MARCH_STEPS = 100;\nconst float MIN_DIST = 0.0; // analogous to near plane/far place clipping\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001; //distance threshold to count as a \"hit\" on SDF\n\nconst float BOUNDARY_EPSILON_SCALE = 10.0; // value to make sure rays are correctly inside or outside of geometry\n\nconst int SAMPLES_PER_PIXEL = 1; // somehow more samples screws with the torus?? not sure\n    // suspicion is that the offset rays exit without refracting or reflecting as often, perhaps the sample distance should be reduced\nconst float SAMPLE_WEIGHT = 1.0/float(SAMPLES_PER_PIXEL);\n\n\nconst float ROUGHNESS = 0.03;\nconst int LIGHTING_SQRT_NUM_SAMPLES = 8;\nconst float LIGHTING_FALLOFF_INTENSITY = 3.0; // falloff to taste, not physically accurate\nconst float LIGHTING_INTENSITY = 0.6;\n\nconst float IOR = 1.5; // Index of Refraction\nconst float invIOR = 1.0/IOR; // ratio of atmosphere to glass index of refraction\n\nconst vec3 IORrgb = vec3(1.49, 1.5, 1.51);\nconst vec3 invIORrgb = 1.0/IORrgb;\n\n\n\nconst float FRESNEL_POWER = 5.0; // The accurate value is 5.0, but is extremely subtle above 2.0\nconst float fresnel_approxReflectance = (1.0 - IOR)/(1.0 + IOR) * (1.0 - IOR)/(1.0 + IOR);\nfloat reflectance( vec3 incident, vec3 normal )\n{\n    float val = 1.0 - abs(dot(incident, normal));\n    val = pow(val, FRESNEL_POWER);\n    return fresnel_approxReflectance + (1.0 - fresnel_approxReflectance) * val;\n}\n\n\nfloat sceneSDF( vec3 point)\n{\n    float dist;\n\n    //return min(min(sdSphere(point, 0.5), sdSphere(point + vec3(1.0, 0.0, 0.0), 0.3)), sdSphere(point + vec3(-1.5,0.,0.), 0.7));\n    //return sdSphere(point, 0.5);\n    \n    float t = iTime;//min(iTime, 2.*PI);\n    mat3 rotMat = rotateYAxis(t) * rotateXAxis(1.57 + t * .7);\n    point *= rotMat;\n    \n    //dist = sdBox( point - vec3(0.,.3,0.), vec3(.5, .1, .5));\n    \n    //dist = sdOctahedron(point, .5);\n    //dist = min(dist, sdOctahedron(point * rotateYAxis(PI * 0.25), .5));\n    \n    \n    //dist = min(dist, sdBox());\n    \n    \n    //dist = sdTorus(point, vec2(0.5, 0.2));\n    dist = sdTorus(point, vec2(1.,0.4));\n    //dist = sdSphere(point, 1.);\n    //dist = sdBox(point, vec3(1.));\n    \n    //dist += 0.02*(clamp(sin(iTime * 0.5 - PI * 0.5) + 1.0, 0.0, 1.0)) * (sin(sin(point.x * 3.)*2. + iTime + 0.4982) + sin(sin(point.y * 2.) * 6. + iTime + 1.3) + sin(sin(point.z * 4.) * 2. + iTime + 0.8));\n    \n    //float yScale = (point.y - 0.5) * 2.;\n    //dist += 0.01 * (sin(point.y * 25. + iTime * 2.) + 1.) * yScale * yScale;\n    \n    //dist = min(dist, sdTorus(point, vec2(.9,0.4)));\n    \n    //float d1 = sdTorus(point, vec2(1., 0.4));\n    //float d2 = sdBox((point + vec3(0.,0.,3.*sin(t))) * rotateYAxis(t) * rotateXAxis(t * .5), vec3(.6));\n    //dist = opSmoothUnion(d1, d2, 0.5);\n    \n    return dist;\n    \n}\n\n\nvec3 sceneNormal( vec3 point ) // estimate the normal by heuristically getting gradient\n{\n    // n = [df/dx, df/dy, df/dz]\n    // df/dx ~= (f(v + dx) - f(v)) / ||dx||\n    // since we normalize, we disregard the division\n    float dfdx = sceneSDF(point + vec3(EPSILON, 0.0, 0.0)) - sceneSDF(point - vec3(EPSILON, 0.0, 0.0));\n    float dfdy = sceneSDF(point + vec3(0.0, EPSILON, 0.0)) - sceneSDF(point - vec3(0.0, EPSILON, 0.0));\n    float dfdz = sceneSDF(point + vec3(0.0, 0.0, EPSILON)) - sceneSDF(point - vec3(0.0, 0.0, EPSILON));\n    \n    return normalize(vec3(dfdx, dfdy, dfdz));\n}\n\nfloat distToGeometry( vec3 pos, vec3 lookDir, out int numIterations)\n{\n    float depth = MIN_DIST;\n    for(int i = 0; i < MAX_MARCH_STEPS; i++)\n    {\n        numIterations = i;\n        float dist = abs(sceneSDF(pos + depth*lookDir));// absolute value so marching works inside or outside\n        \n        if(dist < EPSILON) //hit geometry\n        {\n            return depth;\n        }\n        \n        // didn't hit, continue marching from next closest point\n        depth += dist; // * sign(sceneSDF(pos + depth*lookDir)); // interesting effect\n        \n        //make sure not past max distance\n        if(depth >= MAX_DIST)\n        {\n            return MAX_DIST;\n        }\n    }\n    \n    // if marched without hitting anything, return max dist\n    return MAX_DIST;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0; // normalize coords so that 0,0 is center\n    float z = size.y / tan(radians(fieldOfView) / 2.0); // FOV formula (?)\n    return normalize(vec3(xy, -z));\n}\n\n\n\nvec3 raySphereIntersection( vec3 pos, vec3 dir, vec3 spherePos, float sphereRadius )\n{\n    // Note: dir MUST be a unit vector\n    // dir = normalize(dir);\n    \n    vec3 relPos = pos - spherePos;\n    float a = dot(dir, relPos);\n    float discrim = a*a - dot(relPos,relPos) + sphereRadius * sphereRadius;\n    \n    if( discrim < 0.0 ) return vec3(0.0); // no intersection\n    \n    float dist = -a + sqrt(discrim);\n    return pos + dist * dir;\n}\n// Cubemaps only care about direction, not position, which is an issue when modeling refraction\n    // This function approximates positional offset by adjusting the direction\nconst float CUBEMAP_DEPTH = 10.0;\nvec3 cubeMapSampleRay( vec3 pos, vec3 dir )\n{\n    // Oh cruel irony! This is the function used in ray tracing, which I'm using to approximate in ray marching\n    return raySphereIntersection(pos, dir, vec3(0.0), CUBEMAP_DEPTH);\n}\n\n\nvec2 subsampleOffset(vec2 offset, inout uint seed)\n{\n    //TODO: implement different subsampling functions\n    return vec2(rand(seed), rand(seed)) - vec2(0.5);\n}\n\n//https://www.rorydriscoll.com/2009/01/07/better-sampling/\nvec3 cosineSampleHemisphere(float u1, float u2)\n{\n    float r = sqrt(u1);\n    float theta = 2.0 * PI * u2;\n    \n    // Note that this function creates a sample of hemisphere facing forwards\n        // i.e. (0,0,1) in local space should equal the normal vector in world space\n        // Because the sampling is spherical, the x/y rotation does not really matter\n    return vec3(r * cos(theta), r * sin(theta), sqrt(1.0 - u1));\n}\nvec3 sampleLighting(vec3 pos, vec3 incident, vec3 normal, int sampleGridSize, inout uint randSeed)\n{\n    // For simplicity, we will not consider any collisions or indirect lighting, and only sample from the cubemap\n    \n    // calculate a rotation matrix for given normal by creating a TNB frame\n    vec3 Ntemp = vec3(normal.z, 0.0, max(abs(normal.x), abs(normal.y)));\n    vec3 Nb = normalize(cross(normal, Ntemp));\n    vec3 Nt = normalize(cross(normal, Nb));\n    \n    // Recall that the columns of the matrix correspond to the new bases (see the sample function)\n    mat3 rotMat = transpose(mat3(Nt, Nb, normal));\n    \n    // Stratified cosine sampling to get the most out of the fewest samples\n    // On top of sampling from the blurred cubemap, we should get a good estimation of global direct diffuse\n    \n    float sampleGridWidth = 1.0 / float(sampleGridSize);\n    float sampleWeight = 1.0 / float(sampleGridSize * sampleGridSize);\n    vec3 diffuseColor = vec3(0.0);\n    \n    vec3 reflectDir = reflect(incident, normal);\n    \n    for(float r = 0.0; r < 0.999; r += sampleGridWidth)\n    {\n        for(float c = 0.0; c < 0.999; c += sampleGridWidth)\n        {\n            // Stratified sampling\n            float r1 = r + rand(randSeed) * sampleGridWidth;\n            float r2 = c + rand(randSeed) * sampleGridWidth;\n            \n            // Cosine weighted Hemisphere sampling\n            // By virtue of cosine sampling, the cosine term disappears so we don't need to further multiply by the angle\n            vec3 randDirection = cosineSampleHemisphere(r1, r2) * rotMat;\n            \n            // transform to world space, and lerp to reflection direction for specular highlights\n            vec3 sampleRay = cubeMapSampleRay(pos, mix(reflectDir, randDirection, ROUGHNESS));\n            vec3 col = mix(linTexture(iChannel0, sampleRay).rgb, linTexture(iChannel1, sampleRay).rgb, ROUGHNESS);\n            diffuseColor += col;\n        }\n    }\n    \n    diffuseColor *= sampleWeight; // normalize\n    vec3 hsv = rgb2hsv(diffuseColor); // convert to hsv\n    hsv.z = pow(hsv.z, LIGHTING_FALLOFF_INTENSITY); // scale value by falloff\n    diffuseColor = hsv2rgb(hsv); // return to rgb\n    \n    return diffuseColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float IOR = 1.0 + clamp(pow(sin(iTime)*1.,4.), 0.0, 5.0);\n    //float invIOR = 1./IOR;\n    uint RAND_STATE = floatBitsToUint(iTime);\n\n    // translate mouse position to rotation in radians on X and Y axes\n    float rotX = (iMouse.x / iResolution.x) * 2.0 * 3.14;\n    float rotY = (iMouse.y / iResolution.y) * 3.14 - 1.57;\n    \n    //rotX = 0.65 * 2.0 * PI; rotY = -0.3;\n    \n    \n    //fragColor = texture(iChannel0, rayDirection(45.0, iResolution.xy, fragCoord) * rotateZAxis(iTime));\n    //return;\n    \n    mat3 rotMat = rotateXAxis(rotY) * rotateYAxis(rotX);\n    \n    \n    vec3 lookDir = rayDirection(FOV, iResolution.xy, fragCoord) * rotMat;\n    vec3 camPos = vec3(0.0, 0.0, 5.0) * rotMat;\n    \n    \n    vec4 col = vec4(0.0);\n    bool insideGeometry = false;\n    \n    for( int currSample = 0; currSample < SAMPLES_PER_PIXEL; currSample++ )\n    {\n        vec2 pixelOffset = subsampleOffset(fragCoord.xy, RAND_STATE);\n        pixelOffset = vec2(0.); // causes shakiness at low sample rates, so disabling for now\n    \n        vec3 rayPos = camPos;\n        vec3 rayDir = rayDirection(FOV, iResolution.xy, fragCoord + pixelOffset) * rotMat;\n        vec3 rayDirR = rayDir;\n        vec3 rayDirG = rayDir;\n        vec3 rayDirB = rayDir;\n        \n        // vec2 rayOffset = subsampleOffset(lookDir.xy) - vec2(0.5);\n        \n        vec4 reflectColor = vec4(0.0);\n        vec3 lightingColor = vec3(0.0);\n        \n        float totalInternalDist = 0.0;\n        \n        int bounce = 0;\n        for(; bounce < MAX_BOUNCES; bounce++ )\n        {\n            //DEBUG\n            /*if(bounce == 0)\n            {\n                col = vec4(abs(rayDir), 1.0);\n                //break;\n            }*/\n            \n            // calculate ray collision\n            int numRayMarchIterations = 0;\n            float dist = 0.0;\n            dist = distToGeometry( rayPos, rayDir, numRayMarchIterations );\n            \n            if(insideGeometry) totalInternalDist += dist;\n            \n            \n            // DEBUG: to view number of raymarch iterations of given point\n            //col += vec4(float(numRayMarchIterations) / float(MAX_MARCH_STEPS) * SAMPLE_WEIGHT);\n            //break;\n            \n            // If didn't hit anything, break\n            if(dist > MAX_DIST - EPSILON)\n            {\n                break;\n            }\n            \n            \n            // Calculate normal, always from outside the geometry (otherwise errors from sdf)\n                // if inside geometry, use additional offset to ensure outside of geometry\n                // if inside, normal also points inwards\n            vec3 norm = (insideGeometry?-sceneNormal( rayPos + rayDir * (dist + BOUNDARY_EPSILON_SCALE * EPSILON))\n                                        :sceneNormal( rayPos + rayDir * dist ));\n                                    \n            // Refract ray over normal with correct ratio of refractive indices\n            vec3 refractedRay = refract(rayDir, norm, (insideGeometry?IOR:invIOR));\n            \n            vec3 refractedRayR = refract(rayDirR, norm, (insideGeometry?IORrgb.r:invIORrgb.r));\n            vec3 refractedRayG = refract(rayDirG, norm, (insideGeometry?IORrgb.g:invIORrgb.g));\n            vec3 refractedRayB = refract(rayDirB, norm, (insideGeometry?IORrgb.b:invIORrgb.b));\n            \n            // Add some noise due to internal roughness\n                // would need to probably due via hemisphere sampling\n            \n            // Check for total internal reflection\n            if(refractedRay == vec3(0.0))\n            {\n                rayPos += dist * rayDir;\n                rayDir = reflect(rayDir, norm);\n                \n                rayDirR = reflect(rayDirR, norm);\n                rayDirG = reflect(rayDirG, norm);\n                rayDirB = reflect(rayDirB, norm);\n            }\n            else\n            {\n                // If on the outside, calculate reflectance \n                if(!insideGeometry)\n                {\n                    \n                    // Calculate reflection coefficient via Schlick's Approximation\n                    float reflectance = reflectance(rayDir, norm);\n\n                    vec3 reflectedRay = cubeMapSampleRay(rayPos, reflect(rayDir, norm));\n\n                    // Sample from blurred cubemap to get brighter highlights\n                        // scaled by reflectance and bounce, as initial bounces have higher impact on reflectance color\n                    //reflectColor += vec4(1.0) * reflectance / float(bounce + 1); // pure white\n                    //reflectColor += texture(iChannel0, reflectedRay) * reflectance / float(bounce + 1);\n                    //reflectColor += texture(iChannel1, reflectedRay) * reflectance / float(bounce + 1);\n                    reflectColor += mix(linTexture(iChannel0, reflectedRay), linTexture(iChannel1, reflectedRay), ROUGHNESS) * reflectance / float(bounce + 1);\n\n                    if(bounce == 0)\n                    {\n                        // Calculate diffuse lighting\n                        lightingColor = sampleLighting(rayPos, rayDir, norm, LIGHTING_SQRT_NUM_SAMPLES, RAND_STATE);\n                    }\n                }\n            \n                // hacky way to ensure new ray goes THROUGH geometry boundary\n                rayPos += (dist + BOUNDARY_EPSILON_SCALE * EPSILON) * rayDir;\n                rayDir = refractedRay;\n                insideGeometry = !insideGeometry;\n            }\n            \n            \n            \n            //DEBUG\n            /*if(bounce == 0 && true)\n            {\n                col = vec4(abs(rayDir), 1.0);\n                break;\n            }*/\n            \n        }\n        \n        \n        if(bounce == 0)\n        {\n            col += linTexture(iChannel0, rayDir) * SAMPLE_WEIGHT;\n            continue;\n        }\n        \n        vec3 addedColor = vec3(0.0,0.0,0.0);\n        \n        vec3 sampleDir = cubeMapSampleRay(rayPos, rayDir);\n        //reflectColor *= 1.5; // boosting the reflectColor looks a bit better\n        \n        // (Poor) Approximation of translucency due to internal scattering\n            // random chance scaled by distance travelled internally, so more distance = more scattering\n            // then sample from blurred cubemap to simulate sampling multiple scattered rays\n        /*float r = rand(RAND_STATE) * (1.0 - 1./(totalInternalDist/0.1 + 1.0));\n        if (r > 0.1)\n        {\n            col += texture(iChannel1, sampleDir) * SAMPLE_WEIGHT;\n            continue;\n        }*/\n        \n        /*\n        if(int(round(col.a / SAMPLE_WEIGHT)) > currSample)\n        {\n            col += vec4(texture(iChannel0, sampleDir).rgb, 1.0) * SAMPLE_WEIGHT;\n            continue;\n        }*/\n        \n        // Cheap and relatively unrealistic simulation of roughness causing ray blurring by sampling blurred cubemap\n        //vec3 rayColor = mix(texture(iChannel0, sampleDir).rgb, texture(iChannel1, sampleDir).rgb, ROUGHNESS/* * (1.0 - 1./(totalInternalDist/0.01 + 1.0))*/);\n        \n        vec3 rayColor = linTexture(iChannel0, sampleDir).rgb;\n        \n        addedColor += rayColor;\n        \n        // Add diffuse and specular lighting\n        addedColor += lightingColor * LIGHTING_INTENSITY;\n        \n        //reflectColor = mix(reflectColor, vec4(vec3(0.545,0.996,0.635),1.0), 0.5); // tints the glass\n        \n        //addedColor += vec3(reflectColor.a); // shows reflectance values\n        \n        //addedColor += reflectColor.rgb; // show only the reflected color\n        \n        // With fresnel\n        addedColor += reflectColor.rgb * reflectColor.a;\n        \n        \n        \n        // Show ray directions\n        //addedColor += abs(rayDir);\n        \n        \n        col += vec4(addedColor, 1.0) * SAMPLE_WEIGHT;\n        \n        // I have zero idea why, but this increases clarity on the edges\n        continue;\n     }\n     \n     // Gamma correction\n     col.rgb = pow(col.rgb, vec3(1.0/2.2));\n     \n     fragColor = col;\n    \n    /*\n    for( sample < samples )\n    {\n        for( i < MAX_RAYMARCH_STEPS )\n        {\n            ray march to scene\n            On collision:\n            if( object material is refractive or whatever )\n                do refractive calcuation, continue raymarch but update ray position and direction to \n                 boundary of hit geometry\n            else\n                do bounce light? or just return basic lighting?\n        }\n    }\n    \n    */\n    \n    /*\n    TODO: specular and diffuse approximations\n    Fresnel approximations - DONE\n    \n    Diffuse approximation\n        idea is to sample a hemisphere at reflection point and average color\n        sampling from blurred cubemap may be useful\n        use cosine weighted sampling based on view direction so that follows lambert's cosine law\n    \n    specular approximation\n    https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission#\n        \n    \n    */\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"const float HALF_WIDTH = 1.0/sqrt(3.0);\n\nconst int GRID_LENGTH = 8;\nconst float GRID_FRAC = 1.0/float(GRID_LENGTH);\n\nconst float GRID_SIZE = HALF_WIDTH * 2.0 / float(GRID_LENGTH);\n\nvec2 map(vec2 value, float min1, float max1, float min2, float max2) {\n  return vec2(min2) + (value - vec2(min1)) * (max2 - min2) / (max1 - min1);\n}\n\nfloat max3(vec3 rd) {\n   return max(max(rd.x, rd.y), rd.z);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    rayDir = normalize(rayDir);\n    vec3 rd = abs(rayDir);\n    \n    vec3 col = vec3(0);\n    if (max3(rd) == rd.x)\n    {\n        float d = 1.0/rd.x;\n        vec3 pos = rayDir * d;\n        vec2 cellCoord = floor(map(pos.yz, -HALF_WIDTH, HALF_WIDTH, 0.0, float(GRID_LENGTH)));\n        bool evenCell = mod(cellCoord.x + cellCoord.y, 2.0) == 0.0;\n        \n        if(rayDir.x > 0.0) col = evenCell ? vec3(0.996,0.584,0.584) : vec3(0.761,0.000,0.000);\n        else               col = evenCell ? vec3(0.992,0.580,1.000) : vec3(0.839,0.000,0.839);\n    }\n    if (max3(rd) == rd.y)\n    {\n        float d = 1.0/rd.y;\n        vec3 pos = rayDir * d;\n        vec2 cellCoord = floor(map(pos.xz, -HALF_WIDTH, HALF_WIDTH, 0.0, float(GRID_LENGTH)));\n        bool evenCell = mod(cellCoord.x + cellCoord.y, 2.0) == 0.0;\n        \n        if(rayDir.y > 0.0) col = evenCell ? vec3(0.639,1.000,0.647) : vec3(0.000,0.761,0.000);\n        else               col = evenCell ? vec3(0.965,1.000,0.702) : vec3(0.788,0.800,0.000);\n    }\n    if (max3(rd) == rd.z)\n    {\n        float d = 1.0/rd.z;\n        vec3 pos = rayDir * d;\n        vec2 cellCoord = floor(map(pos.xy, -HALF_WIDTH, HALF_WIDTH, 0.0, float(GRID_LENGTH)));\n        bool evenCell = mod(cellCoord.x + cellCoord.y, 2.0) == 0.0;\n        \n        if(rayDir.z > 0.0) col = evenCell ? vec3(0.400,0.580,1.000) : vec3(0.000,0.000,1.000);\n        else               col = evenCell ? vec3(0.541,0.992,1.000) : vec3(0.000,0.580,0.580);\n    }\n    \n    fragColor = vec4(col,1.0); // Output cubemap\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926535897932384626433832795;\n\n// Random------------------------------------------------------------------------------\nfloat rand(inout uint seed)\n{\n    seed = seed * uint(747796405) + uint(2891336453);\n    uint v = ((seed >> ((seed >> uint(28)) + uint(4))) ^ seed) * uint(277803737);\n    v = (v >> uint(22)) ^ v;\n    return float(v) / 4294967295.0;\n}\nfloat rand(vec2 co, inout uint seed)\n{\n    return fract(sin(dot(co + vec2(cos(rand(seed)), sin(rand(seed))), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// RGB and HSV Conversion--------------------------------------------------------------\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Rotation Matrices-------------------------------------------------------------------\nmat3 rotateXAxis(float theta)\n{\n    return mat3(1, 0, 0,\n               0, cos(theta), -sin(theta),\n               0, sin(theta), cos(theta));\n}\nmat3 rotateYAxis(float theta)\n{\n    return mat3(cos(theta), 0, sin(theta),\n                0, 1, 0,\n                -sin(theta), 0, cos(theta));\n}\nmat3 rotateZAxis(float theta)\n{\n    return mat3(cos(theta), -sin(theta), 0,\n                sin(theta), cos(theta), 0,\n                0, 0, 1);\n}\n\n// SDFs----------------------------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// SDF Blend-----------------------------------------------------------------------------\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \n// Other---------------------------------------------------------------------------------\nfloat gain( float x, float k ) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvec4 linTexture(samplerCube cubemap, vec3 P)\n{\n    vec4 col = texture(cubemap, P);\n    col.rgb = pow(col.rgb, vec3(2.2));\n    return col;\n}","name":"Common","description":"","type":"common"}]}