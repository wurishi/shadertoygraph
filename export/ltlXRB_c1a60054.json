{"ver":"0.1","info":{"id":"ltlXRB","date":"1437880315","viewed":217,"name":"metaballs 9000","username":"rcbuchanan","description":"Pretty much everywhere it's gonna to be metaballs","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","moremetaballs","stillmetaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n\n#define EPSILON 0.01\n#define MAXDEPTH 10.0\n\n#define JUMPFWD 0.25\n#define MAXSTEPS int(100.0 / JUMPFWD)\n\nbool hit = false;\nint steps = 0;\n\nfloat map (vec3 p);\n\nvec3 mapnorm (vec3 p)\n{\n\tvec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(\n\t\t    map(p + e.xyy) - map(p-e.xyy),\n\t\t    map(p + e.yxy) - map(p-e.yxy),\n\t\t    map(p + e.yyx) - map(p-e.yyx)));\n}\n\nvec3 look (vec3 eye, vec3 obj, vec2 uv)\n{\n\tvec3 at = normalize(obj - eye);\n\tvec3 up = vec3(0, 0, 1);\n\tvec3 right = cross(up, at);\n\tvec3 down = cross(at, right);\n    \n\treturn normalize(right * uv.x + down * uv.y + at);   \n}\n\nfloat meta (float d)\n{\n\treturn 0.05 / (d * d);\n\t//return pow(0.75 / d, 2.0);\n}\n\nvec3 findax2 (vec3 ax1) {\n\tvec3 ax2 = dot(ax1, vec3(1, 0, 0)) > dot(ax1, vec3(0, 1, 0)) ? vec3(0, 1, 0) : vec3(1, 0, 0);\n\tax2 = normalize(ax2 - dot(ax2, ax1) * ax2);\n\treturn ax2;\n}\n\nfloat map (vec3 p)\n{\n\tfloat w = 0.;\n\n\tfloat t;\n\tvec3 ax1, ax2, r;\n\t\n\t//t = 0.5 * PI;\n\t//t = 0.;\n\n\tax1 = normalize(vec3(0.00000000,  0.00000000, -0.95105650));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.00000000,  0.85065080, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.80901698,  0.26286556, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.50000000, -0.68819095, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(-0.50000000, -0.68819095, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\t\n\tax1 = normalize(vec3(-0.80901698,  0.26286556, -0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.50000000,  0.68819095,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.80901698, -0.26286556,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.00000000, -0.85065080,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(-0.80901698, -0.26286556,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(-0.50000000,  0.68819095,  0.42532537));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\n\tax1 = normalize(vec3(0.00000000,  0.00000000,  0.95105650));\n\tt = iTime + dot(ax1, vec3(1, 2, 3));\n\tr = ax1 * sin(t) + findax2(ax1) * cos(t);\n\tw += meta(length(p - r));\n\t\n\treturn -w + 1.0;\n}\n\nvec3 march (vec3 ro, vec3 rd)\n{\n\tfloat k = 0.0;\n    \n\tfor (int i = 0; i < MAXSTEPS; i++) {\n\t\tfloat leap = map(ro + k * rd);\n        \n\t\tif (leap < EPSILON)\n\t\t\thit = true;\n        \n\t\tif (hit || k > MAXDEPTH)\n\t\t\tbreak;\n        \n\t\t// TODO: wat.\n\t\tk += leap * JUMPFWD;\n\t\tsteps = i;\n\t}\n\treturn ro + k * rd;\n}\n\n/*\nfloat map (vec3 p)\n{\n\treturn length(p) - 1.0;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.xx;\n\tfloat igt = iTime * 0.25;\n\tvec3 eye = vec3(2. * sin(igt), 2. * cos(igt), 0);\n\tvec3 obj = vec3(0, 0, 0);\n\n\tvec3 p = march (eye, look(eye, obj, uv));\n\t//fragColor = vec4(map(p), hit ? 1.0 : 0.0, float(steps) / float(MAXSTEPS), 1.0);\n\tfragColor = vec4(hit ? mapnorm(p) : vec3(floor(mod(iTime * 100., 2.0))), 1.0);\n\t//fragColor = vec4(map(p), 0.0, 0.0, 1.0);\n}","name":"","description":"","type":"image"}]}