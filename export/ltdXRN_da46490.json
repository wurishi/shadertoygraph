{"ver":"0.1","info":{"id":"ltdXRN","date":"1478544051","viewed":1328,"name":"Anisotropic Specular","username":"toffanim","description":"Implementation of anisotropic specular. Tangent Space computation is not good enough to have good looking results.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["specular","anisotropy","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple shader implementation of Alex Vlachos 2015 idea for Anisotropiuc Specular in his talk at GDC \n// http://www.gdcvault.com/play/1021771/Advanced-VR-2015\n//\n// The tangent space computation is not good at the poles\n\n// Mathematical approximation\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n\n//Globals\n#define SPHERE_GRID_NUM_ROWS 7\n#define SPHERE_GRID_NUM_COLS 7\n//\tRay marching parameters\n#define RAY_MARCHING_STEPS 100\n#define RAY_MARCHING_MAX_DISTANCE 20.\n#define RAY_MARCHING_MIN_HIT_VALUE 0.001\n//\tLight parameters\nconst vec3 LightColor = vec3(1.);\nconst vec3 LightPosition = vec3( 0, 0, -1 );\n//\tSphere parameters\nconst float SphereRadius = 1.;\nvec3 SphereInitialPosition = vec3(0.);\n//\tCameraVectors\nvec3 Eye = vec3(0.);\nvec3 ForwardVector = normalize( vec3( 0., 0., 1.) );\nvec3 UpVector = normalize( vec3( 0., 1., 0.) );\nvec3 RightVector = normalize( vec3( -1., 0., 0.) );\n\n//Structs\nstruct material\n{\n    vec2 Roughness;\n    vec3 BaseColor;\n};\n           \nstruct map_result\n{\n    float dp;\n    vec3 Normal; \n    material Material;\n};\n    \nstruct hit_result\n{\n    bool Hit;\n    float T;\n    map_result Geometry;\n};\n    \n    \n// Geometry definition and resolution through RayMarching\nfloat Sphere( vec3 p, float r )\n{\n    return ( length(p) - r );   \n}\n\nmap_result Map( vec3 p )\n{\n    //Grid layout of spheres\n    vec3 SpherePosition = SphereInitialPosition;\n    //\tCompute steps for spheres spacing and roughness value\n    float SphereXStep = (SphereRadius * float(SPHERE_GRID_NUM_COLS+10)) / float(SPHERE_GRID_NUM_COLS);\n    float SphereYStep = (SphereRadius * float(SPHERE_GRID_NUM_ROWS+10)) / float(SPHERE_GRID_NUM_COLS);\n    float RoughnessXStep = 0.9 / float(SPHERE_GRID_NUM_COLS);\n    float RoughnessYStep = 0.9 / float(SPHERE_GRID_NUM_ROWS);\n    \n    map_result Result;\n    Result.dp = RAY_MARCHING_MAX_DISTANCE;\n    Result.Material.BaseColor = vec3(1.,0.,0.);\n    Result.Material.Roughness.x = 0.1;\n    Result.Material.Roughness.y = 0.1;\n    \n    float NewDp;\n    for ( int i = 0; i < SPHERE_GRID_NUM_COLS; ++i)\n    {\n        SpherePosition = SphereInitialPosition - 10. * UpVector;\n        SpherePosition -= float(i) * SphereXStep * RightVector;\n        for ( int j = 0; j < SPHERE_GRID_NUM_ROWS; ++j )\n        {\n            SpherePosition += SphereYStep * UpVector;\n            NewDp = Sphere( p - SpherePosition, SphereRadius );\n            if(Result.dp > NewDp)\n            {\n                Result.dp = NewDp;\n                Result.Normal = normalize(p - SpherePosition); \n                Result.Material.Roughness.x = 0.1 + float(j) * RoughnessXStep;\n                Result.Material.Roughness.y = 0.1 + float(i) * RoughnessYStep;\n            }\n         }\n    } \n    return (Result) ;  \n}\n\nhit_result March(vec3 ro, vec3 rd)\n{\n    hit_result Result;\n    Result.Hit = false;\n    Result.T = 0.0;\n    map_result MapResult;\n    \n    for(int i=0; i<RAY_MARCHING_STEPS; ++i)\n    {\n        MapResult = Map(ro+rd*Result.T);\n        if(abs(MapResult.dp)<RAY_MARCHING_MIN_HIT_VALUE){Result.Hit=true; break;}\n        if(Result.T>RAY_MARCHING_MAX_DISTANCE) break;\n        Result.T += MapResult.dp;\n        Result.Geometry = MapResult; \n    }    \n    return (Result) ;\n}\n\nvoid RoughnessEllipseToScaleAndExp( vec2 Roughness, out float DiffExp, out vec2 SpecExp, out vec2 SpecScale )\n{\n    DiffExp = (1. - (Roughness.x + Roughness.y) * 0.5 * 0.8 ) + 0.6;\n    SpecExp = exp2( pow( 1. - Roughness, vec2(1.5)) * 14. );\n    SpecScale = 1. - clamp( Roughness * 0.5,  0., 1.);\n}\n\nfloat IsotropicSpecular( float NDotH, float SpecularExponent, float SpecularScale )\n{\n    float NDotHk = pow( NDotH, dot(SpecularExponent, 0.5));\n    NDotHk *= dot( SpecularScale, 0.3333 );\n    return( NDotHk );\n}\n\n\nfloat AnisotropicSpecular( vec2 SpecularExponent, vec2 SpecularScale, vec3 TangentU, vec3 TangentV, vec3 H, vec3 N )\n{\n    vec3 SpecNormalX = H - (TangentU * dot( H, TangentU ));\n    vec3 SpecNormalY = H - (TangentV * dot( H, TangentV ));\n    float NDotHX = max( 0., dot(SpecNormalX, H) );\n    float NDotHXk = pow( NDotHX, SpecularExponent.x * 0.5);\n    NDotHXk *= SpecularScale.x;\n    \n    float NDotHY = max( 0., dot(SpecNormalY, H) );\n    float NDotHYk = pow( NDotHY, SpecularExponent.y * 0.5);\n    NDotHYk *= SpecularScale.y;\n    \n    float SpecTerm = NDotHXk * NDotHYk;\n    return(SpecTerm);\n}\n\nvoid CalcTangentSpace( vec3 N, out vec3 TangentU, out vec3 TangentV )\n{\n\tvec3 UpVector = vec3( 0., 1., 0. );\n    TangentV = cross( N, UpVector );\n    TangentU = cross( N, TangentV );\n}\n\n\nvec3 Shade( vec3 Eye, vec3 View, hit_result HitResult )\n{\n    vec3 FragWorldPosition = (Eye + View * HitResult.T);\n    vec3 Normal = HitResult.Geometry.Normal;\n    material Material = HitResult.Geometry.Material;\n    float DiffExp;\n    vec2 SpecExp, SpecScale;\n    RoughnessEllipseToScaleAndExp( Material.Roughness, DiffExp, SpecExp, SpecScale);\n    vec3 H = normalize (-View + LightPosition);\n    float NDotH = clamp (dot (Normal, H), 0.0, 1.0);\n    float NDotL = clamp (dot (Normal, LightPosition), 0.0, 1.0);\n    //Diffuse\n    float DiffuseTerm = pow(NDotL, DiffExp) * ((DiffExp + 1.) * 0.5);\n    // Light Specular\n    vec3 TangentU, TangentV;\n    CalcTangentSpace( Normal, TangentU, TangentV );\n    vec3 LightSpecular = LightColor * AnisotropicSpecular( SpecExp, SpecScale, TangentU, TangentV, H, Normal);      \n\n    vec3 Result = Material.BaseColor * DiffuseTerm + LightSpecular;\n    return (Result);   \n}\n                                                         \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Screen coordinates\n\tvec2 UV = fragCoord.xy / iResolution.xy;   \n    //vec2 P = -1.0 + 2.0*UV;\n    //P.x *= iResolution.x / iResolution.y;\n    vec2 P = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec3 View = normalize(vec3( P, 1.0 ));\n    \n    // Billboarding of the grid\n    SphereInitialPosition = Eye + ForwardVector * 10.0;\n    SphereInitialPosition += 8. * RightVector;\n    \n    // Ray marching\n    hit_result HitResult  = March( Eye,  View);\n    \n    // Shading\n    vec3 Color = vec3(0.);\n    if( HitResult.Hit )\n    {\n        Color = Shade( Eye, View , HitResult );\n    }\n    \n\tfragColor = vec4(Color,1.0);\n}","name":"Image","description":"","type":"image"}]}