{"ver":"0.1","info":{"id":"lllyR2","date":"1505597977","viewed":126,"name":"Signal progression","username":"pohar","description":"4k intro with sdf","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["in4k"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define EPSILON 0.00001\n\nvec3 ambientColor = vec3(0.2, 0.2, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nbool mode2d;\n\nvec3 mymod(vec3 p, vec3 m)\n{\n    return mod(p,m)-m/2.;\n}\n\n// https://commons.wikimedia.org/wiki/File:Dynamical_plane_with_Julia_set_for_c%3D0.35_with_binary_decomposition.png#cite_note-1\n\n// compute color of pixel\nfloat color(vec2 z, float time) \n{\n    const int iMax=100;\n    vec2 c = vec2(0.35+sin(time/3.33)*0.7,0.0+sin(time/2.0));  // initial value\n    float er2 = 10000.0;\n\n    // iteration\n    for ( int i = 0; i < iMax; i++) \n    {\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y) +  c; // z= z^2+c\n        if (dot(z,z)> er2)   // escape test \n            // exterior\n            if (z.x>0.0)\n            { \n                return (float(i)/1000.);\n            } // upper part of the target set \n       \t\telse \n                return (0.); //false; //lower part of the target set \n    }\n    return (0.); //false; //interior\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( (2.0*PI)*(c*t+d) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) \n{\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\nvec3 myFold(vec3 z)\n{  \n    if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n    if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n    if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\n    \n    return z;\n}\n\nvec3 twist(vec3 p, float tw)\n{\n    float c = cos(tw);\n    float s = sin(tw);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    return q;\n}\n\nvec3 rotX(vec3 p, float a)\n{\n    mat3 rot = mat3(1.,0.,0.,\n                    0., cos(a), -sin(a),\n                   0., sin(a), cos(a));\n    return p * rot;\n}\n\nvec3 rotZ(vec3 p, float a)\n{\n    mat3 rot = mat3(cos(a), 0., sin(a),\n        \t\t\t0., 1., 0.,\n                   -sin(a), 0., cos(a));\n    return p * rot;\n}\n\nvec3 rotY(vec3 p, float a)\n{\n    mat3 rot = mat3(cos(a), -sin(a), 0.,\n                    sin(a), cos(a), 0.,\n        \t\t\t0., 0., 1. \n                   );\n    return p * rot;\n}\n\n// octohedron\nfloat so(vec3 p,float s) { \n     return dot(p,normalize(sign(p+1e-6)))-s;\n}\n\n//Chamfered box\nfloat sbc(vec3 p,vec3 d,float c, float w) {\n    p=max(abs(p)-d, w);\n    return so(p,c);\n}\n\nfloat myshape(vec3 p,vec3 d,float c, float w) {\n    p=max(abs(p)-d, w);   \n    return so(p, c);\n}\n\nfloat map3(vec3 p)\n{\n    float d;\n    d =       myshape(rotZ(rotY(p  - vec3(-1.0, 0., 2.),iTime/2.),iTime/3.), vec3(0.4,  .2, 0.2 ), 0.25, 0. );\n    d = min(d,myshape(rotX(rotZ(p  - vec3( 0.0, 0., 3.),iTime/4.),iTime/1.), vec3(0.15, .3, 0.15), 0.2 , 0.1));\n    d = min(d,myshape(rotX(rotY(p  - vec3( 1.0, 0., 2.),iTime/3.),iTime/2.), vec3(0.15, .4, 0.15), 0.2 ,-0.10));\n    \n    return d;\n}\n\nfloat map4(vec3 p)\n{\n    return sdSphere(mymod(p, vec3(2.)), 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map3(vec3(p.x + EPSILON, p.y, p.z) ),\n        map3(vec3(p.x, p.y + EPSILON, p.z) ),\n        map3(vec3(p.x, p.y, p.z  + EPSILON) )\n    ));\n}\n\nvec4 ChamferedBoxes(vec2 uv)\n{\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(2.*uv.x-1., 1.33*uv.y-0.66, 1.));\n    vec3 color;\n    vec4 fragColor = vec4(0.);\n    float t = 0.;\n    for(int i=0; i<130 && t<40.; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float d = map3(p);\n        if(d<EPSILON)\n        {\n            vec3 norm = estimateNormal(p);\n\n            float occ = 0.5 + 0.5 * norm.y;\n\n            float amb = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n            float dif = clamp(dot(lightDir, norm), 0.0, 1.0);\n\n            vec3 h = normalize(-rd + lightDir);\n            float spe = pow(clamp(dot(h, norm), 0.0, 1.0), 64.0);\n\n            diffuseColor = vec3(map4(p+norm));\n            color = amb * ambientColor\n             + dif * (diffuseColor + spe * specularColor) ;\n            \n            fragColor = vec4(vec3(1.)-(color * occ),1.);\n            \n           break;\n        }\n        t += d;\n    }\n    \n    return fragColor;\n}\n\nfloat map(in vec3 p, in float time)\n{   \n\tvec3 q = time>80.0?myFold(twist(p,time)):twist(p,time);\n    float c = pModPolar(q.xy,8.0);\n    /*\n    if(c<-1.0)\n        return 0.0;\n    */\n\tfloat d = sdBox(mymod(q,vec3(1.0)),vec3(0.5*sin(time*3.33)+0.5,0.3,0.2));\n\n\tq.yz+=0.5*sin(-time*3.0);\n    d = min(d,sdSphere(mymod(q,vec3(1.0)),0.1));\n\n    if(!mode2d)\n    {\n\t\tpModPolar(q.zy,4.0);\n\t\td = min(d,fCylinder(mymod(q.yzx,vec3(1.0)),0.05,1.1));\n    } \n\treturn d;\n}\n/*\nvec3 getNormal(vec3 p, float eps) \n{\n    vec3 n;\n    n.y = map(p);\n    n.x = map(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n*/\n\nvec4 trace(in vec3 rs, in vec3 rd, in float time)\n{\n    const float EPSILON_NRM = 0.1 / 1280.0;\n    vec4 ret=vec4(0.0);\n    float t = 0.0;\n    const int maxSteps = 30;\n    for(int i = 0; i < maxSteps ; ++i)\n    {\n        vec3 p = rs + normalize(rd) * t;\n        float d = map(p, time);\n        if(d < 0.000001 )\n        {\n            ret = vec4(palette(abs(d+1.0*p.z),vec3(0.5, 0.5, 0.5),vec3(0.5, 0.5, 0.5),vec3(1.0, 0.7, 0.4),vec3(0.00, 0.15, 0.20)),1.);\n            break;\n        }\n        t += d*1.0;\n    }\n\n    return ret;\n}\n\nvoid  mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    fragColor.a = 0.0;\n    float myTime = iTime*1.0;\n    \n    //  camera    \n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, 0.8*iResolution.y));\n    vec3 org = vec3(0.,0.,myTime);\n    \n    /*if(myTime<20.0)\n    {\n        vec2 uv = fragCoord/iResolution.xy;\n        fragColor = ChamferedBoxes(uv);\n    }      \n    \n    if(fragColor.a == 0.0)*/\n    { \n        mode2d = (myTime<30.0) || (fract(myTime/10.0)<0.5);\n\n        fragColor = trace(org, twist(mode2d?dir:dir.xzy,myTime*0.5), myTime);\n        float bindecomp = 0.0; // color(dir.xy, myTime);\n        if((myTime>6.0) && bindecomp > 0.0)\n        {\n            fragColor.rgb = vec3(1.)-fragColor.rgb;\n            fragColor.a = bindecomp;\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}