{"ver":"0.1","info":{"id":"wltBWs","date":"1615789645","viewed":93,"name":"Dice at the beach","username":"sahemera","description":"Remix of David Crook's platonics shader. I added a non-platonic solid to complete the rpg set, a d10 (pentagonal trapezohedron). I wanted to add volumetrics inside the dice, but it's already quite slow, so maybe I'll try just the icosahedron later.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","platonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Remix from David Crook's shader:\n\n// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// An exercise in platonic geometry with signed distance funcions.\n// https://en.wikipedia.org/wiki/Platonic_solid\n// SDF\n// https://iquilezles.org/articles/distfunctions\n// http://www.alanzucconi.com/2016/07/01/signed-distance-functions/\n\n\n////MATHEMATICAL CONSTANTS\n#define TAU 6.283185\n#define PI 3.14159265359\n\n//Golden mean and inverse -  for the icosohedron and dodecadron\n#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\n////RAYMARCHING CONSTANTS\n#define MAX_STEPS 100\n#define SURFACE_DISTANCE 0.001\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n    float mirror;\n    float refractiveIndex;\n    float opacity;  \n};\n    \n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    vec3 normal;\n    Ray \t ray;\n    Ray reflection;\n    Material material;\n    bool hit;\n};\n    \nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n\nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n\n//I want to bake in a bunch of time based effects, so lets save some cycles using global, not that itll save much\nfloat camPos;\nfloat time;\nfloat stepTime;\n//////////////////////////////////////////////////////////\n//---------------Setup Scene Lights---------------------//\n//////////////////////////////////////////////////////////\n\nPointLight  light1,light2;\nDirectionalLight light3;\nMaterial blueMat2,whiteMat,reflectiveBlueMat,blueMat1, brownMat;\n\nvoid setupLights(){\n    vec3 specular = vec3(1.0);\n    \n  \t\n    light1 = PointLight(vec3(3.5*0.7501, 0.8, 1.5*-0.6614), LightColor( vec3(1.0),specular));\n  \tlight2 = PointLight(vec3(3.0, 1.4+ 0.35*-0.5464, 2.8 - camPos), LightColor(vec3(1.0, 0.8, 0.6),vec3(1.0, 0., 0.))); \n    \n    light3 = DirectionalLight(normalize(vec3(0.6,1.0, 0.005)),LightColor( vec3(2.0),specular));\n    \n    //light1 = PointLight(vec3(1,1.0,1),LightColor( vec3(1.0),specular));\n  \t//light2 = PointLight(vec3(0.7,1.1+ 0.35,0.7),LightColor(vec3(1.0),specular)); \n} \n\nvoid setupMaterials() {\n    \n    vec3 specular = vec3(0.3); \n    float shininess = 8.0 + 8.*pow(cos(iTime*1.5),3.);\n    \n    //Material {LightColor {diffuse specular}, shininess, mirror, refractiveindex, opactity}\n    brownMat = Material(LightColor(vec3(1.0, 0.46, 0.168)/1.55,vec3(0.8, 0.56, 0.068)/1.45), 20.0, 0.20, 100.0, 1.0);\n    whiteMat = Material(LightColor(vec3(0.30),vec3(1.0, 0.3, 0.8)),                        4. , 0.25,0.0,1.0);\n    reflectiveBlueMat  = Material(LightColor(vec3(0.1,0.1,0.75),vec3(0.3,0.3,1.0)),       shininess ,0.75,1.0,1.0);\n    blueMat2 = Material(LightColor(vec3(0.2,0.2,0.5)*4.,vec3(0.6,0.6,1.5)*4.),        25. ,0.0,10.0,1.0);\n    blueMat1= Material(LightColor(vec3(0.2,0.2,0.5),vec3(0.6,0.6,1.5)),        0.15 ,0.0,2.0,1.0);\n}\n\n\n//////////////////////////////////////////////////////////\n//--------------Raymarch Fundamentals-------------------//\n//////////////////////////////////////////////////////////\n\n//Get point along the ray at the provided distance\nvec3 rayPoint(Ray r,float t) {\n    return r.origin +  t*r.direction;\n}\n\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\nMapValue subtractObjects( MapValue A, MapValue B )\n{\n    //A-B\n    if (-B.signedDistance>A.signedDistance){\n        B.signedDistance *= -1.0;\n        B.material = A.material;\n    \treturn    B ;\n    }\n    else {\n       \n    \treturn A;\n    }\n}\n\n//Returns a rotation matrix for rotating an object by this angle along the provided axis\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    //http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//Returns distance from point to a plane defined by its origin and its normal\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n    return dot(p - origin,normal);   \n}\n\n//Returns distance from point to either this plane or another parallel plane across the origin?\nfloat  doubleplane(vec3 p, vec3 origin, vec3 normal){ \n    return max(dot(p - origin,normal),dot(-p - origin,normal));   \n}\n\n//Returns the distance from a point to a plane\n//using the plane origin and its normal\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n\n    MapValue mv;\n    mv.material = m;\n\n    mv.signedDistance = plane(p,origin,normal);\n    return mv;\n}\n\n//Sphere by the provided radius at the center\nMapValue sphere(vec3 p, float radius, Material m) {\n    MapValue mv;\n    mv.material = m;\n    mv.signedDistance =length(p) - radius;\n    return mv;\n}\n\n//A ground plane at the provided y height\nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n    MapValue mv;\n    mv.material = m;\n    mv.signedDistance = p.y - y;\n    return mv;\n}\n\n//Wall\nMapValue yzPlane( vec3 p ,float x, Material m)\n{\n    MapValue mv;\n    mv.material = m;\n    mv.signedDistance = p.x - x;\n    return mv;\n}\n\n//Source: User teadrinker for their tetrahedron sdf\n//https://www.shadertoy.com/view/tlXBR8\nfloat roundmax(float a, float b, float c, float d) \n{\n    return length(max(vec4(a, b, c, d), 0.0)) + min(max(max(a, b), max(c, d)), 0.0);\n}\n\n//////////////////////////////////////////////////////////\n//---------------Platonic Solid SDFs--------------------//\n//////////////////////////////////////////////////////////\n\n//cube by iq\nMapValue cube( vec3 p, float d , Material m)\n{\n    MapValue mv;\n    mv.material = m;\n\n    mv.signedDistance = length(max(abs(p) -d,0.0));\n    return mv; \n}\n\nMapValue notcube( vec3 p, float d , Material m)\n{\n    MapValue mv;\n    mv.material = m;\n\n    mv.signedDistance = max(1.-length(max(abs(p) -d,0.0)),0.0);\n    return mv; \n}\n\n\nMapValue tetrahedron(vec3 p, float d, Material m) {\n    \n    MapValue mv;\n    mv.material = m;\n \n     //Source: user teadrinker\n    float sdf = roundmax(\n         (p.x + p.z) - p.y - d,\n        -(p.x + p.z) - p.y - d,\n         (p.x - p.z) + p.y - d,\n        -(p.x - p.z) + p.y - d\n        ) * (1. / sqrt(3.));\n \n     mv.signedDistance = sdf;\n     return mv; \n \n  //There was some weird behaviour at the extents of the scene with\n  //the plane based tetrahedron. Might look fine now that there's a floor and walls.\n  \n   //The tetrahedran is the intersection of four planes:\n    //float sd1 = plane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    //float sd2 = plane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n \t//float sd3 = plane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n \t//float sd4 = plane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n  \n    //max intersects shapes\n    //mv.signedDistance = max(max(sd1,sd2),max(sd3,sd4));\n  return mv; \n}\n\n\nMapValue octahedron(vec3 p,  float d, Material m) {\n \n    //The octahedron is the intersection of two dual tetrahedra.  \n    MapValue mv = tetrahedron(p,d,m);\n    MapValue mv2 = tetrahedron(-p,d,m);\n\n    mv = intersectObjects(mv,mv2);\n\n    mv.signedDistance = mv.signedDistance;\n\n    return mv; \n}   \n\nMapValue alternativeOctahedron(vec3 p,  float d, Material m) {\n   //Alternative construction of octahedran.\n   //The same as for a terahedron, except intersecting double planes (the volume between two paralell planes). \n    \n    MapValue mv;\n    mv.material = m;\n\n    float dn =1.0/sqrt(3.0);\n    float sd1 = doubleplane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    float sd2 = doubleplane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n    float sd3 = doubleplane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n    float sd4 = doubleplane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n\n    mv.signedDistance = max(max(sd1,sd2),max(sd3,sd4));\n    return mv; \n}\n\nMapValue dodecahedron(vec3 p,  float d, Material m) {\n  \n    MapValue mv;\n    mv.material = m;\n\n    //Some vertices of the icosahedron.\n    //The other vertices are cyclic permutations of these, plus the opposite signs.\n    //We don't need the opposite sign because we are using double planes - two faces for the price of one. \n    vec3 v = normalize(vec3(0.0,1.0,PHI));\n    vec3 w = normalize(vec3(0.0,1.0,-PHI));\n       \n    //The dodecahedron is dual to the icosahedron. The faces of one corespond to the vertices of the oyther.\n    //So we can construct the dodecahedron by intersecting planes passing through the vertices of the icosohedran.\n    float ds = doubleplane(p,d*v,v);\n    //max == intesect objects\n    ds = max(doubleplane(p,d*w,w),ds); \n\n    ds = max(doubleplane(p,d*v.zxy,v.zxy),ds);\n    ds = max(doubleplane(p,d*v.yzx,v.yzx),ds);\n\n\n    ds = max(doubleplane(p,d*w.zxy,w.zxy),ds);\n    ds = max(doubleplane(p,d*w.yzx,w.yzx),ds);\n    \n    mv.signedDistance = ds;\n  \n       \n    return mv; \n}   \n\n//Pentagonal trapezohedron is the same as the dodecahedron, but minus two faces\n//Note: a nominal pentagonal trapezohedron is \"diamond\" shaped does not look exactly like a d10, so\n//I modified the normals of the sides to be more shallow like a d10 one would probably own\nMapValue pentagonalTrapezohedron(vec3 p,  float d, Material m) {\n  \n    MapValue mv;\n    mv.material = m;\n\n    //p.xz = p.xz * (d - p.xz); //Cool shape!\n    \n    //Some vertices of the icosahedron.\n    //The other vertices are cyclic permutations of these, plus the opposite signs.\n    //We don't need the opposite sign because we are using double planes - two faces for the price of one. \n    \n    d = d*1.3333; //MAke it bigger so that it appears proportionally the same size as icosahedron\n    vec3 v = normalize(vec3(0.0,1.0,PHI));\n    vec3 w = normalize(vec3(0.0,1.0,-PHI));\n    \n    //Modify the normals so that they face a little bit closer to the axis of the die\n    vec3 norm = v/3.33;\n    \n    float ds = doubleplane(p,d*w, (w -  norm) / 2.); \n\n    ds = max(doubleplane(p,d*v.zxy,(v.zxy + norm) / 2.),ds);\n    ds = max(doubleplane(p,d*v.yzx,(v.yzx + norm) / 2.),ds);\n\n\n    ds = max(doubleplane(p,d*w.zxy,(w.zxy + norm)/ 2.),ds);\n    ds = max(doubleplane(p,d*w.yzx,(w.yzx - norm) / 2.),ds);\n    \n    \n    mv.signedDistance = ds;\n      \n    return mv; \n}   \n\n\nMapValue icosahedron(vec3 p,  float d, Material m) {\n  \n  \tMapValue mv;\n  \tmv.material = m;\n  \tfloat h=1.0/sqrt(3.0);\n    \n    \n    //Same idea as above, using the vertices of the dodecahedron\n    vec3 v1 = h* vec3(1.0,1.0,1.0);\n    vec3 v2 = h* vec3(-1.0,1.0,1.0);\n    vec3 v3 = h* vec3(-1.0,1.0,-1.0);\n    vec3 v4 = h* vec3(1.0,1.0,-1.0);\n   \n    vec3 v5 = h* vec3(0.0,INV_PHI,PHI);\n    vec3 v6 = h* vec3(0.0,INV_PHI,-PHI);\n    \n    float ds = doubleplane(p,d*v1,v1);\n    //max == intesect objects\n \tds = max(doubleplane(p,d*v2,v2),ds);\n    ds = max(doubleplane(p,d*v3,v3),ds); \n    ds = max(doubleplane(p,d*v4,v4),ds);\n    ds = max(doubleplane(p,d*v5,v5),ds); \n    ds = max(doubleplane(p,d*v6,v6),ds);\n    \n    //plus cyclic permutaions of v5 and v6:\n    ds = max(doubleplane(p,d*v5.zxy,v5.zxy),ds); \n    ds = max(doubleplane(p,d*v5.yzx,v5.yzx),ds);\n    ds = max(doubleplane(p,d*v6.zxy,v6.zxy),ds);\n    ds = max(doubleplane(p,d*v6.yzx,v6.yzx),ds);\n    \n        mv.signedDistance = (ds - d/3.);\n    \n  \treturn mv;\n}   \n\n//from iq https://iquilezles.org/articles/distfunctions\n//...but I added some wacky wobbles to it\nMapValue sdRoundBox( vec3 p, vec3 b, float r, Material m)\n{\n    MapValue mv;\n    mv.material = m;\n    vec3 q = abs(p) - b;\n    \n    q = q +(sin(p.x*16.-iTime)/18. + sin(p.x*8.)/32. + cos(-2.*p.x+p.z*4.)/16.)/2.;\n    q.y = (3.0*q.y+q.x)/4.0;\n    \n    mv.signedDistance = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) -r;\n    return mv;\n}\n\n\n//////////////////////////////////////////////////////////\n//-------------------Define Scene-----------------------//\n//////////////////////////////////////////////////////////\n\n//Process the geometry of the scene and return the distance to the\n//nearest object and that objects' material in a MapValue\nMapValue scene(vec3 p){\n   MapValue objects;\n   //objects.signedDistance = 100.0;\n   //objects.material = whiteMat;\n   \n   objects = sdRoundBox((p + vec3(2.5, 0.56, 0.0125)), vec3(2,0.35,7.0), 0.03, brownMat);\n   \n   mat3 R = rotationMatrix(vec3(sin(time),1.5*cos(p.z + p.x )*sin(time),cos(time)),camPos + stepTime);\n   \n   float toss; //\"toss\" each shape at a different time in the cycle, by supplying a downward curved parabola as the y position\n   \n   toss = max(-0.05, -2.*pow(time - 3.0,2.) + 0.3);\n   objects = addObjects(objects,tetrahedron(R*(p - vec3(-0.2, toss, 1.6)), 0.15,whiteMat));\n   toss = max(-0.05, -2.*pow(time - 4.8,2.) + 0.3);\n   objects = addObjects(objects,cube( R*(p - vec3(-0.2, toss, 1.0)),       0.145,whiteMat));\n   toss = max(-0.05, -2.*pow(time - 6.6,2.) + 0.3);\n   objects = addObjects(objects,octahedron(R*(p - vec3(-0.2, toss, 0.4)),  0.215,whiteMat));\n   \n   toss = max(-0.05, -2.*pow(time - 8.4,2.) + 0.3);\n   objects = addObjects(objects,pentagonalTrapezohedron(R*(p - vec3(-0.2, toss, -0.2)),0.095,whiteMat));\n   toss = max(-0.05, -2.*pow(time - 10.2,2.) + 0.3);\n   objects = addObjects(objects,pentagonalTrapezohedron(R*(p - vec3(-0.2, toss, -0.8)),0.095,whiteMat));\n\n   toss = max(-0.05, -2.*pow(time - 12.0,2.) + 0.3);\n   objects = addObjects(objects,dodecahedron(R*(p - vec3(-0.2, toss, -1.4)),0.16,whiteMat));\n   toss = max(-0.05, -2.*pow(time - 13.8,2.) + 0.3);\n   objects = addObjects(objects,icosahedron(R*(p - vec3(-0.2, toss, -2.0)), 0.135,whiteMat));\n   \n   // Add walls and ceiling with wave shape\n   if(p.y > sin((p.z + p.x + time)*2.)/2. + 1.0)\n       objects = addObjects(objects,notcube(p - vec3(0.0, -1.65, -camPos + 2.0), 2.3,blueMat2)); //Walls\n   else\n       objects = addObjects(objects,notcube(p - vec3(0.0, -1.65, -camPos + 2.0), 2.3,blueMat1)); //Walls\n       \n   //Reflective floor\n   objects = addObjects(objects,xzPlane(p, -0.28,reflectiveBlueMat)); //Floor\n   \n   MapValue walls;\n   walls.signedDistance = length(abs(p) - 6.0);\n   walls.material = whiteMat;\n   objects = addObjects(objects, walls);\n   \n   return objects;\n}\n\n//////////////////////////////////////////////////////////\n//-------------------Raymarch Scene---------------------//\n//////////////////////////////////////////////////////////\n\n//Gets the normal of a point to the nearest part of the scene defined by GetDist\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    //Get the slope by subtracting nearby points from the point and normalizing their direction\n    \n    //Is it more accurate to do it this way rather than d = scene(p); vec3(d - scene(p - {epsilon,0,0}), d - scene(p - {0,epsilon,0}), d - scene(p - {0,0,epsilon}))?\n    vec3 normal = vec3(\n                       scene(p +vec3(epsilon,0,0)).signedDistance - scene(p - vec3(epsilon,0,0)).signedDistance,\n                       scene(p +vec3(0,epsilon,0)).signedDistance - scene(p - vec3(0,epsilon,0)).signedDistance,\n                       scene(p +vec3(0,0,epsilon)).signedDistance - scene(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\n//Move from the rayOrigin in the rayDistance until we collide with the scene or fly off into INF.\n//\n//return a Trace to the point that collided (or no collision) with the scene\nTrace rayMarch(in Ray rayOrigin, float maxDistance) {\n\n    //Distance from ray origin. \n    //March along the ray, accumulating the distance traveled\n    float dist = 0.01;\n    \n\tvec3 p;\n    bool hit = false;\n    MapValue nextDist;\n    \n    for(int i=0; i < MAX_STEPS; i++)\n    {    \n        //Get the next point along the ray\n        p = rayPoint(rayOrigin, dist);\n        nextDist = scene(p);\n        dist += 0.5*nextDist.signedDistance; //Why are we halving? Can't we trust that we're this whole distance away? I see weird artifacts when I remove it\n        \n        if(nextDist.signedDistance < SURFACE_DISTANCE) //Marched sufficiently close to scene\n        {\n            hit = true; \n            break;\n        }\n        \n        if(dist > maxDistance) //Marched too far\n            break;\n    }\n    \n    //Avoid the extra work of finding the normal and reflection that are returned with the trace for efficiency\n    return Trace(dist,p,p,rayOrigin,rayOrigin,nextDist.material,hit);\n}\n\n//Complete wrapper for rayMarch that fills in the normal and reflection of the trace\nTrace traceRay(in Ray ray, float maxDistance) {\n\n    Trace trace = rayMarch(ray, maxDistance);\n    trace.normal = calculateNormal(trace.p);\n    trace.reflection = Ray(trace.p,reflect(ray.direction, trace.normal));\n\n    return trace;\n}\n\n\n//Get a ray for a pixel using a viewpoint and center of focus.\n//d is a scalar for the distance from the center\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p, float dist){\n\n\tvec3 v = normalize(lookAtCenter -viewPoint); //Get a vector pointing at lookAtCenter from the viewpoint    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0)); //Get first vector orthagonal to it, but how come we can choose (0,1,0) and it will always do what we want?\n    vec3 n2 = cross(n1,v);  \n    \n    //Define a 3d point for our [x,y] pixel using our new orthogonal axes\n    vec3 lookAtPoint = lookAtCenter + dist*(p.y*n2 + p.x*n1);\n    \n    //Create a ray from the viewpoint to this point\n    Ray ray;\n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\n\n//////////////////////////////////////////////////////////\n//---------------Raytrace Scene Lights------------------//\n//////////////////////////////////////////////////////////\n\n// Basic diffuse lighting\n// Multiply the object's diffuse material and the light color together, and scale intensity by the dot product of light ray and surface normal\nvec3 diffuseLighting(in Trace trace, vec3 lightColor,vec3 lightDir){\n\n    float lambertian = max(dot(lightDir,trace.normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\nvec3 specularLighting(in Trace trace, vec3 lightColor,vec3 lightDir){\n    //blinn-phong\n    //https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    vec3 viewDir = -trace.ray.direction;\n\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float specAngle = max(dot(halfDir, trace.normal), 0.0);\n    float specular = pow(specAngle, trace.material.shininess);\n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\nvec3 cookTorranceSpecularLighting(in Trace trace, vec3 lightColor,vec3 L){\n    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n    //https://renderman.pixar.com/view/cook-torrance-shader\n    \n    vec3 V = -trace.ray.direction;\n\n    vec3 H = normalize(L + V);\n    \n    float NdotH = dot(trace.normal, H);\n    float NdotV = dot(trace.normal, V);\n    float VdotH = dot(V ,H );\n    float NdotL = dot(trace.normal , L);\n    \n    float lambda  = 0.25;\n    float F = pow(1.0 + NdotV, lambda);\n    \n    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));\n    \n    \n   // Beckmann distribution D\n    float alpha = 5.0*acos(NdotH);\n    float gaussConstant = 1.0;\n\tfloat D = gaussConstant*exp(-(alpha*alpha));\n    \n    \n    float c = 1.0;\n    float specular = c *(F*D*G)/(PI*NdotL*NdotV);\n    \n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\n//Get a value between 0 and 1 for how shadowed this ray is.\n//Intensity is based on the distance from the light versus the magnitude of the light? probablyt?\nfloat castShadow(in Ray ray, float maxDistance){\n\n    Trace trace = rayMarch(ray, maxDistance);\n    float maxDist = min(1.0,maxDistance);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nvec3 pointLighting(in Trace trace, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, light.color.diffuse, lightDir);\n\n    //color += specularLighting(trace, light.color.specular, lightDir);\n    color += cookTorranceSpecularLighting(trace, light.color.specular, lightDir);\n\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, light.color.diffuse, light.direction);\n    \n    color += specularLighting(trace, light.color.specular, light.direction);\n    \n    if(trace.material != blueMat1)\n    {\n        float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n        color *= shadow;\n    }\n    return  color;\n}\n\nvec3 lighting(in Trace trace, vec3 color){\n    \n\tcolor += directionalLighting(trace,light3);\n    color += pointLighting(trace, light1);\n\tcolor += pointLighting(trace, light2);\n    \n    return color;\n}\n\n\n//////////////////////////////////////////////////////////\n//--------------------Render Loop-----------------------//\n//////////////////////////////////////////////////////////\n\nvec3 render(vec2 p){\n\n   \n    //Setup camera ray for this pixel\n    vec3 viewpoint = vec3(1.,0.55 - 0.6*pow(cos(camPos),2.),2.8 - camPos);\n    \n    vec3 lookAt = vec3(-0.3 + sin(camPos*1.5)/2.,0.1, 2.6 - camPos);\n  \tRay ray = cameraRay(viewpoint,lookAt,p,1.0);\n    \n    //Define ambient color outside of the lighting loop so that it isn't incorporated for each lighting call\n    vec3 color = vec3(0.003,0.0015,0.005);//ambient color\n    float frac = 1.0;\n    //Change max distance as we raymarch so that maxdistance isn't reset in reflections\n    float maxDistance = 7.; \n    \n    \n    for(int i = 0; i<3; i++) {\n        Trace trace = traceRay(ray, maxDistance);\n        \n        maxDistance -= trace.dist;\n        \n        \n        //Make sure you have walls set for your scene, because the fact that the lighting happens whether you have a \n        //hit or not means wahetver normals were used last in raymarching will be used for lighting.\n        //I had this placed afterward and I thought it looked better, but there was black outlining around the shapes\n        //that goes away with it here.\n        color += lighting(trace, color)*(1.0 - trace.material.mirror)*frac;\n        if(!trace.hit) break;\n        \n        frac *= trace.material.mirror;\n        if(frac < 0.1 || maxDistance<0.0) break;\n        ray = trace.reflection;\n    }\n   \n   \treturn color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    \n    camPos = mod(iTime / 3., 6.);\n    time = mod(iTime, 18.);\n    stepTime = cos(iTime*2.)/0.5;\n\n  \tsetupLights();\n    setupMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    \n    //Perform gamma correction to make the colors look nicer\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}","name":"Image","description":"","type":"image"}]}