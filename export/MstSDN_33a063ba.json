{"ver":"0.1","info":{"id":"MstSDN","date":"1721862916","viewed":35,"name":"Pacific Petals","username":"vochsel","description":"petals","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["petals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Inspiration https://www.shadertoy.com/view/XsG3z1\n\nvec4 tx(vec2 co) { return texture(iChannel0, co); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 c = tx(uv).xyz;\n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Cheap vec3 to vec3 hash. Works well enough, but there are other ways.\nvec3 hash33(in vec2 p){ \n    float n = sin(dot(p, vec2(41, 289)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nvec4 tx(vec2 co) { return texture(iChannel0, co); }\n\n// Weighted blur function. Pretty standard.\nfloat blur(in vec2 p){\n    \n    // Used to move to adjoining pixels. - uv + vec2(-1, 1)*px, uv + vec2(1, 0)*px, etc.\n    vec3 e = vec3(1, 0, -1);\n    vec2 px = 1./iResolution.xy;\n    \n    // Weighted 3x3 blur, or a cheap and nasty Gaussian blur approximation.\n\tfloat res = 0.0;\n    // Four corners. Those receive the least weight.\n\t//res += tx(p + e.xx*px ).x + tx(p + e.xz*px ).x + tx(p + e.zx*px ).x + tx(p + e.zz*px ).x;\n    // Four sides, which are given a little more weight.\n    res += (tx(p + e.xy*px ).x + tx(p + e.yx*px ).x + tx(p + e.yz*px ).x + tx(p + e.zy*px ).x)*2.;\n\t// The center pixel, which we're giving the most weight to, as you'd expect.\n\tres += tx(p + e.yy*px ).x*4.;\n    // Normalizing.\n    return res/12.;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = 1./iResolution.xy;\n    \n    vec3 noise = hash33(uv + vec2(53, 43)*iTime)*.6 + .2;\n    \n\tfloat avgReactDiff = blur(uv);    \n    \n    vec3 e = vec3(1, 0, -1);\n    vec2 pwr = p*3.; \n    vec2 lap = vec2(tx(uv + e.xy*pwr).y - tx(uv - e.xy*pwr).y, tx(uv + e.yx*pwr).y - tx(uv - e.yx*pwr).y);//\n    \n    uv = uv + lap*p*2.0; \n    \n    float newReactDiff = tx(uv).x + (noise.z - 0.5)*0.0025 - 0.002; \n    \n    // Reaction-diffusion.\n\tnewReactDiff += dot(tx(uv + (noise.xy-0.5)*p).xy, vec2(1, -1))*0.145; \n    \n    if(iTime < 0.1)\n        fragColor.xyz = noise;\n    else\n    {\n        fragColor.xy = clamp(vec2(newReactDiff, avgReactDiff/.98), 0., 1.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}