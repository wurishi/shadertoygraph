{"ver":"0.1","info":{"id":"dsXyDS","date":"1700964789","viewed":11,"name":"neato.gc","username":"orblivius","description":"More shader art for your entertainment :)\nTry in fullscreen!\n\nIf the effect doesn't play, press pause and then play again!","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Lunaphobia\" by srtuss. https://shadertoy.com/view/4d3fDX\n// 2023-06-19 04:45:44\n\n// srtuss, 2017\n// music: Oska - Leviathan (1997)\n\nfloat hash(float p)\n{\n    return fract(sin(p * 11.33123) * 128934.4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float tbeat = texture(iChannel0, uv).w;\n    uv.x -= hash(uv.y * 10. + tbeat) * .02 * exp(mod(tbeat, 16.) * -.5);\n    \n    vec3 col = vec3(0.);\n    vec2 h = vec2(0.014 * exp(mod(tbeat, 16.) * -.5) + .002, 0.);\n   \tcol += texture(iChannel0, uv - h.xy).xyz * vec3(1., 0., 0.);\n    col += texture(iChannel0, uv).xyz * vec3(0., 1., 0.);\n    col += texture(iChannel0, uv + h.xy).xyz * vec3(.0, .0, 1.);\n    //col /= 3.;\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// srtuss, 2017\n//\n// A 2D-effect made out of simple mathematical functions, inspired by the song you're hearing in the background.\n// Simple, yet aesthetically pleasing. :)\n//\n// music: Oska - Leviathan (1997)\n\n#define TIME iTime\n#define TRAIL(y) sin((y) * 4. + TIME * 1.)\n#define PI 3.1415926535897932384626433832795\n#define iBPM 165.325\n#define TBEAT (TIME * iBPM / 60. - 2.05)\n\n\nfloat hash(float p)\n{\n    return fract(sin(p * 11.33123) * 128934.4);\n}\n\nvec2 hash(vec2 p)\n{\n    float s = p.x + p.y * 11.;\n    return vec2(fract(cos(s) * 219861.5124), fract(sin(s) * 219861.5124)) - .5;\n}\n\nfloat nse(float p)\n{\n    float v = floor(p);\n    float u = fract(p);\n    u = u * u * (3. - 2. * u);\n    return mix(hash(v), hash(v + 1.), u);\n}\n\nfloat lengthc(vec2 p)\n{\n    return max(abs(p.x) + .5, abs(p.y));\n}\n\nfloat voro(vec2 p)\n{\n    float d = 1000.;\n    vec2 fl = floor(p);\n    for(int i = -1; i <= 1; ++i)\n    {\n        for(int j = -1; j <= 1; ++j)\n        {\n          \tvec2 q = vec2(j, i);\n            d = min(d, lengthc(p - fl - q - hash(fl + q) - .5));\n        }\n    }\n    return d;\n}\n\nfloat voro2(vec2 p, float ts)\n{\n    p *= ts;\n    vec2 h = vec2(ts * .005, 0.);\n    float v = (voro(p - h.xy) - voro(p + h.xy)) * .5 / h.x;\n    \n    return max(v, 0.);\n}\n\nvec2 rotate(vec2 v, float a)\n{\n    float si = sin(a), co = cos(a);\n    return v * mat2(co, si, -si, co);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2. * uv - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uvo = vec2(uv.x, uv.y + .3);\n    uv.y = abs(uv.y + .3);\n    \n    uv *= exp2((nse(TIME * .4) - 1.) * .5);\n    vec2 p = uv;\n    \n    vec2 cam = vec2(0., TIME * .3);\n   cam += vec2(hash(TIME), hash(TIME + .125)) * .1 * exp(mod(TBEAT, 16.) * -1.);\n    \n    p -= cam * .5;\n    \n    // background\n    float a = voro2(p, 4.);\n    \n    a *= voro2(p, 1.);\n    \n    float v = voro2(p.yx, .7) * .3 + .5;\n    \n    v *= mix(a, 1. - a, smoothstep(0., 1., fract(length(p))));\n    \n    v += smoothstep(0.006, 0., abs(mod(length(p) - 2.4, 2.33) - .5));\n    \n    // light burst\n    v += exp(mod(TBEAT, 16.) * -1.);\n    \n    // trail\n    float vtrail = 0.;\n    \n    vec4 rnd = vec4(1., 2., 3., 4.);\n    for(int i = 0; i < 20; ++i)\n    {\n        rnd = fract(sin(rnd) * 986721.);\n        \n        float ro = rnd.x * 6. + uv.y * 1. - TIME * 1.;\n        \n        vec2 ra = vec2(cos(ro), sin(ro)) * uv.y * .2;\n       vtrail += exp(abs(TRAIL(uv.y + ra.y) - uv.x + ra.x) * -20.) * rnd.z * (sin(uv.y * 10. + rnd.w * 6. + 5. * TIME) * .5 + .5);\n    }\n    \n  vtrail += exp(length(vec2(uv.x - TRAIL(0.), uv.y)) * -10.) * (.1 + hash(TIME));\n    \n  v += vtrail * exp(max(mod(TBEAT + uv.y, 16.) - 4., 0.) * -1.);\n  \n    // wave\n    float k = smoothstep(.8, 1., sin(TBEAT * PI * .25));\n    \n\n    v += smoothstep(0.02, 0.0, abs(sin((uv.x + TIME * 5.) * 5.) * sin((uv.x + TIME * 5.) * 61.) * sin(TBEAT * PI * 2.)\n        * .2 - uv.y)) * k;\n    v *= exp(max(-uvo.y, 0.) * -10.);\n    \n    \n    // blurry foreground\n  v *= 1. - smoothstep(0., .1, voro(uv + 40. - cam) - .9);\n    \n    // vertical blends\n    v *= exp((abs(uv.y) - .2) * -10.);\n  //  v *= exp(max(abs(uvo.y - .3) - .7, 0.) * -100.);\n    \n    // tint\n    vec3 col = pow(vec3(v), vec3(1., .8, .4)) * 1.5;\n    \n    col = pow(col, vec3(1. / 2.2));\n    \n\tfragColor = vec4(col, -2.);\n}","name":"Buffer A","description":"","type":"buffer"}]}