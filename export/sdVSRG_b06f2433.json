{"ver":"0.1","info":{"id":"sdVSRG","date":"1635231915","viewed":105,"name":"Interpolating functions","username":"mikelsv","description":"Show result inteprolating functions.\nUse mouse for select.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["contrast","graph","inverse","step","shape","slope","interpolate","ease"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on: https://www.shadertoy.com/view/Xd2yRd\n// Show result inteprolating functions.\n// From here: https://thebookofshaders.com/edit.php#06/\n// And here: https://github.com/glslify/glsl-easings\n\n// --->> Use mouse for select. <<---\n\n#define ERASE_SPEED .5\n\n// List\n#define EF_BACK_IN 0\n#define EF_BACK_INOUT 1\n#define EF_BACK_OUT 2\n#define EF_BOUNCE_IN 3\n#define EF_BOUNCE_INOUT 4\n#define EF_BOUNCE_OUT 5\n#define EF_CIRC_IN 6\n#define EF_CIRC_INOUT 7\n#define EF_CIRC_OUT 8\n#define EF_CUBIC_IN 9\n#define EF_CUBIC_INOUT 10\n#define EF_CUBIC_OUT 11\n#define EF_ELAST_IN 12\n#define EF_ELAST_INOUT 13\n#define EF_ELAST_OUT 14\n#define EF_EXP_IN 15\n#define EF_EXP_INOUT 16\n#define EF_EXP_OUT 17\n#define EF_LINEAR 18\n#define EF_QUAD_IN 19\n#define EF_QUAD_INOUT 20\n#define EF_QUAD_OUT 21\n#define EF_QUART_IN 22\n#define EF_QUART_INOUT 23\n#define EF_QUART_OUT 24\n#define EF_QINT_IN 25\n#define EF_QINT_INOUT 26\n#define EF_QINT_OUT 27\n#define EF_SINE_IN 28\n#define EF_SINE_INOUT 29\n#define EF_SINE_OUT 30\n\n// Js: var t = 'linear', ts = t.length; while(t.length < 15) t+= ' ';\n// ts + ', ' + t.split('').map(x=>x.charCodeAt(0)).reduce((a,b)=>a + ', ' + b);\n\n// Messages\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.), dFdy(U/16.) )\n\nint nameList[] = int[](\n    // backIn\n6, 98, 97, 99, 107, 73, 110, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n    //backInOut\n9, 98, 97, 99, 107, 73, 110, 79, 117, 116, 32, 32, 32, 32, 32, 32,\n    // backOut\n7, 98, 97, 99, 107, 79, 117, 116, 32, 32, 32, 32, 32, 32, 32, 32,\n    // bounceIn\n8, 98, 111, 117, 110, 99, 101, 73, 110, 32, 32, 32, 32, 32, 32, 32,\n    // bounceInOut\n11, 98, 111, 117, 110, 99, 101, 73, 110, 79, 117, 116, 32, 32, 32, 32,\n    // bounceOut\n9, 98, 111, 117, 110, 99, 101, 79, 117, 116, 32, 32, 32, 32, 32, 32,\n    // circularIn\n10, 99, 105, 114, 99, 117, 108, 97, 114, 73, 110, 32, 32, 32, 32, 32,\n    // circularInOut\n13, 99, 105, 114, 99, 117, 108, 97, 114, 73, 110, 79, 117, 116, 32, 32,\n    // circularOut\n11, 99, 105, 114, 99, 117, 108, 97, 114, 79, 117, 116, 32, 32, 32, 32,    \n    // cubicIn\n7, 99, 117, 98, 105, 99, 73, 110, 32, 32, 32, 32, 32, 32, 32, 32,\n    // cubicInOut\n10, 99, 117, 98, 105, 99, 73, 110, 79, 117, 116, 32, 32, 32, 32, 32,\n    // cubicOut\n8, 99, 117, 98, 105, 99, 79, 117, 116, 32, 32, 32, 32, 32, 32, 32,\n    // elasticIn\n9, 101, 108, 97, 115, 116, 105, 99, 73, 110, 32, 32, 32, 32, 32, 32,\n    // elasticInOut\n12, 101, 108, 97, 115, 116, 105, 99, 73, 110, 79, 117, 116, 32, 32, 32,\n    // elasticOut\n10, 101, 108, 97, 115, 116, 105, 99, 79, 117, 116, 32, 32, 32, 32, 32,\n    // exponentialIn\n13, 101, 120, 112, 111, 110, 101, 110, 116, 105, 97, 108, 73, 110, 32, 32,\n    // exponentialInOut\n15, 101, 120, 112, 111, 110, 101, 110, 116, 105, 97, 108, 73, 110, 79, 117,\n    // exponentialOut\n14, 101, 120, 112, 111, 110, 101, 110, 116, 105, 97, 108, 79, 117, 116, 32,\n    // linear\n6, 108, 105, 110, 101, 97, 114, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n    // quadraticIn\n11, 113, 117, 97, 100, 114, 97, 116, 105, 99, 73, 110, 32, 32, 32, 32,\n    // quadraticInOut\n14, 113, 117, 97, 100, 114, 97, 116, 105, 99, 73, 110, 79, 117, 116, 32,\n    // quadraticOut\n12, 113, 117, 97, 100, 114, 97, 116, 105, 99, 79, 117, 116, 32, 32, 32,\n    // quarticIn\n9, 113, 117, 97, 114, 116, 105, 99, 73, 110, 32, 32, 32, 32, 32, 32,\n    // quarticInOut\n12, 113, 117, 97, 114, 116, 105, 99, 73, 110, 79, 117, 116, 32, 32, 32,\n    // quarticOut\n10, 113, 117, 97, 114, 116, 105, 99, 79, 117, 116, 32, 32, 32, 32, 32,\n    // qinticIn\n8, 113, 105, 110, 116, 105, 99, 73, 110, 32, 32, 32, 32, 32, 32, 32,\n    // qinticInOut\n11, 113, 105, 110, 116, 105, 99, 73, 110, 79, 117, 116, 32, 32, 32, 32,\n    // qinticOut\n9, 113, 105, 110, 116, 105, 99, 79, 117, 116, 32, 32, 32, 32, 32, 32,\n    // sineIn\n6, 115, 105, 110, 101, 73, 110, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n    // sineInOut\n9, 115, 105, 110, 101, 73, 110, 79, 117, 116, 32, 32, 32, 32, 32, 32,\n    // sineOut\n7, 115, 105, 110, 101, 79, 117, 116, 32, 32, 32, 32, 32, 32, 32, 32    \n);\n\n#define ERASE_COUNT float(nameList.length() / 16)\n#define ERASE_WIDTH (iResolution.x / ERASE_COUNT)\n\nfloat callErase(int id, float x){\n    switch(id){\n        case EF_BACK_IN: return backIn(x); \n        case EF_BACK_INOUT: return backInOut(x);        \n        case EF_BACK_OUT: return backOut(x);\n        case EF_BOUNCE_IN: return bounceIn(x);        \n        case EF_BOUNCE_INOUT: return bounceInOut(x);\n        case EF_BOUNCE_OUT: return bounceOut(x);        \n        case EF_CIRC_IN: return circularIn(x);\n        case EF_CIRC_INOUT: return circularInOut(x);\n        case EF_CIRC_OUT: return circularOut(x);        \n        case EF_CUBIC_IN: return cubicIn(x);        \n        case EF_CUBIC_INOUT: return cubicInOut(x);\n        case EF_CUBIC_OUT: return cubicOut(x);        \n        case EF_ELAST_IN: return elasticIn(x);\n        case EF_ELAST_INOUT: return elasticInOut(x);\n        case EF_ELAST_OUT: return elasticOut(x);\n        case EF_EXP_IN: return exponentialIn(x);\n        case EF_EXP_INOUT: return exponentialInOut(x);\n        case EF_EXP_OUT: return exponentialOut(x);\n        case EF_LINEAR: return linear(x);\n        case EF_QUAD_IN: return quadraticIn(x);\n        case EF_QUAD_INOUT: return quadraticInOut(x);\n        case EF_QUAD_OUT: return quadraticOut(x);\n        case EF_QUART_IN: return quarticIn(x);\n        case EF_QUART_INOUT: return quarticInOut(x);\n        case EF_QUART_OUT: return quarticOut(x);\n        case EF_QINT_IN: return qinticIn(x);\n        case EF_QINT_INOUT: return qinticInOut(x);\n        case EF_QINT_OUT: return qinticOut(x);        \n        case EF_SINE_IN: return sineIn(x);\n        case EF_SINE_INOUT: return sineInOut(x);\n        case EF_SINE_OUT: return sineOut(x);\n    }\n\n    return x;\n}\n\nfloat callText(int id, vec2 U) {\n    vec4 T = vec4(0);\n    int sz = nameList[id * 16 + 0] + 1;\n    \n    for(int i = 1; i < (16 - sz) / 2; i ++){\n        C(32);\n    }\n    \n    for(int i = 1; i < sz; i ++){\n       C(nameList[id * 16 + i]);\n    }\n    \n    return length(T.yz)==0. ? -1. : T.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    setupGraph(vec2(0.5), vec2(1.4), fragCoord, iResolution);\n\n\t// background\n\tfcol = mix(vec4(0.1, 0.25, 0.35, 1.0), vec4(0.05, 0.125, 0.175, 1.0), sqrlength(xy - graphCenter) / sqrlength(graphSize * 0.5));\n    \n\t// grid\n\tdrawGrid(0.1, px, vec4(1.0, 1.0, 1.0, 0.125));\n\tdrawGrid(0.5, px, vec4(1.0, 1.0, 1.0, 0.25));\n\tdrawGrid(1.0, px, vec4(1.0, 1.0, 1.0, 0.5));\n\n    // mouse\n    vec2 auto = vec2(0.5 + 0.5 * sin(iTime), fract(iTime / (6.2832 * 2.0)));\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = iMouse.z <= 0.0 ? auto : mouse;\n    // translate x coordinate to a slope value between 0.01 and 100\n\tfloat k = pow(10.0, (-0.5 + mouse.x) * 4.0);\n    float lerpTime = clamp(fract(iTime * 0.25) * 2.0 - 0.5, 0.0, 1.0);\n\n    float r = 3.0 * px;\n    // mask curve drawing in y, since verticals x = 0 and x = 1 would be drawn with inverse functions\n    float mask = lerpstep(-r - aa, -r + aa, xy.y) - lerpstep(1.0 + r - aa, 1.0 + r + aa, xy.y);\n\n    // function id\n    int id = int(mod(iTime * ERASE_SPEED, ERASE_COUNT));\n    float time = mod(iTime * ERASE_SPEED, 1.) * 1.5 - .25;\n    float vis = quadraticOut(time + .5);\n    \n    // mouse\n    if(iMouse.z > 0.)\n        id = int(iMouse.x / ERASE_WIDTH);\n\n    // dual ease function on bottom half\n    vec4 col = vec4(1, 0.45, 0.1, 1.0);\n    mixColor(col, lerpstep(r + aa, r - aa, abs(xy.y - callErase(id, xy.x)) / vis));\n\n    // move point\n\tvec4 dimCol = vec4(vec3(0.2, 0.7, 1.0), 1.5) * vis;\n    drawCircle(vec2(time, callErase(id, xy.x)), 8.0 * px, dimCol);\n\n    // draw top list\n    if(xy.y > 1.1){\n        int idi = int(fragCoord / ERASE_WIDTH);\n        float idx = (fragCoord.x - ERASE_WIDTH * float(idi)) / ERASE_WIDTH;\n        \n        if(idx > .1 && idx < .9)\n            fcol.x += ( .4 + (idi == id ? .5 : 0.));// * quadraticOut(3. * idx - 0.);\n    }\n    \n    // draw name\n    if(callText(id, (fragCoord / iResolution.y - vec2(.65,.85)) * 16.) > 0.1)\n        fcol.xyz = vec3(1.) * vis;\n       \n    // draw bottom line   \n    drawGradientRect(graphPos, vec2(graphSize.x, 0.1), callErase(id, xy.x), vec4(0.0, 0.0, 0.0, 1.0), col);\n\n    // result\n    fragColor = fcol;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n\nvec2 graphSize;\nvec2 graphCenter;\nvec2 graphPos; // bottom left\n\nvec2 xy;\t// current graph coords\nfloat px;\t// pixel size in graph units, assumes uniform graph\nfloat aa;\t// aa falloff radius\nvec4 fcol;\t// current fragment color\n\nfloat lerpstep(float a, float b, float x)\n{\n    return (a == b) ? step(x, a) : clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nfloat sqrlength(vec2 v)\n{\n    return dot(v, v);\n}\n\nvoid mixColor(vec4 col, float alpha)\n{\n    fcol = vec4(mix(fcol.rgb, col.rgb, alpha * col.a), 1.0);\n}\n\nvoid drawGrid(float stepSize, float r, vec4 col)\n{\n\tvec2 grid = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) / stepSize));\n    float d = min(grid.x, grid.y) * stepSize;\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\nvoid drawCircle(vec2 pos, float r, vec4 col)\n{\n    float d = length(pos - xy);\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\n// Draws an explicit function of x with a known derivative.\n// Uses y distance to curve, breaks with great derivatives and discontinuities.\nvoid drawFunc(float y, float dy, float r, vec4 col)\n{\n    float d = abs(y - xy.y);\n    float yspan = sqrt(1.0 + dy * dy); // accurate, decent approximate: abs(dy) + 1.0 / (abs(dy) + 1.0)\n\tmixColor(col, lerpstep(yspan * (r + aa), yspan * (r - aa), d));\n}\n\n// Draws an explicit function of x, uses screen space derivative.\nvoid drawFunc(float y, float r, vec4 col)\n{\n    drawFunc(y, dFdx(y) / px, r, col);\n}\n\n// Draws an explicit function of x with a known inverse.\n// Uses distance to curve in both y and x.\nvoid drawFuncWithInverse(float y, float x, float r, vec4 col)\n{\n    vec2 d = abs(vec2(xy.x - x, xy.y - y));\n    mixColor(col, lerpstep(r + aa, r - aa, max(d.x, d.y) / length(d) * min(d.x, d.y)));\n}\n\nvoid setupGraph(vec2 center, vec2 size, vec2 fragcoord, vec3 resolution)\n{\n    graphSize = size * (resolution.xy / resolution.y);\n    graphCenter = center;\n    graphPos = graphCenter - 0.5 * graphSize;\n    xy = graphPos + fragcoord / resolution.xy * graphSize;\n\tpx = graphSize.y / resolution.y;\n    aa = 0.5 * px;\n}\n\nvoid drawGradientRect(vec2 pos, vec2 size, float t, vec4 startCol, vec4 endCol)\n{\n\tvec2 inside = step(pos, xy) * step(xy, pos + size);\n\tmixColor(mix(startCol, endCol, t), inside.x * inside.y);\n}\n\n// Functions\n// https://github.com/glslify/glsl-easings\n\nfloat bounceOut(float t);\n\nfloat backIn(float t) {\n  return pow(t, 3.0) - t * sin(t * PI);\n}\n\nfloat backInOut(float t) {\n  float f = t < 0.5\n    ? 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n\n  float g = pow(f, 3.0) - f * sin(f * PI);\n\n  return t < 0.5\n    ? 0.5 * g\n    : 0.5 * (1.0 - g) + 0.5;\n}\n\nfloat backOut(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\n\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat circularIn(float t) {\n  return 1.0 - sqrt(1.0 - t * t);\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nfloat cubicIn(float t) {\n  return t * t * t;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nfloat elasticIn(float t) {\n  return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat linear(float t) {\n  return t;\n}\n\nfloat quadraticIn(float t) {\n  return t * t;\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat quadraticOut(float t) {\n  return -t * (t - 2.0);\n}\n\nfloat quarticIn(float t) {\n  return pow(t, 4.0);\n}\n\nfloat quarticInOut(float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n\nfloat quarticOut(float t) {\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\n\nfloat qinticIn(float t) {\n  return pow(t, 5.0);\n}\n\nfloat qinticInOut(float t) {\n  return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\nfloat qinticOut(float t) {\n  return 1.0 - (pow(t - 1.0, 5.0));\n}\n\nfloat sineIn(float t) {\n  return sin((t - 1.0) * HALF_PI) + 1.0;\n}\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat sineOut(float t) {\n  return sin(t * HALF_PI);\n}","name":"Common","description":"","type":"common"}]}