{"ver":"0.1","info":{"id":"dsjGRD","date":"1667337696","viewed":136,"name":"Geometric Series Mesh Tower 2d","username":"jt","description":"Using [url=https://en.wikipedia.org/wiki/Geometric_series]Geometric Series[/url] to calculate a loopless exact euclidean SDF describing a simple [url=https://en.wikipedia.org/wiki/Lattice_tower]Lattice Tower[/url].\nDebugger highlights internal symmetries.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdf","space","square","distance","tiling","infinite","euclidean","geometric","lattice","frame","loopless","series","exact","sum","telescoping"],"hasliked":0,"parentid":"ddjGzW","parentname":"Geom. Series Square Tiling SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/dsjGRD Geometric Series Mesh Tower 2d 2022-11-01 by Jakob Thomsen\n// based on https://www.shadertoy.com/view/ddjGzW Geometric Series Square Tiling SDF\n// based on https://www.shadertoy.com/view/dd2GRW Geometric Series Square Tiling\n// based on https://www.shadertoy.com/view/Ds23zD Textured Geometric Series Coords\n// based on https://www.shadertoy.com/view/fd2czy Textured Geometric Series\n// based on https://www.shadertoy.com/view/7dScRG 1/4+1/16+1/64+1/256+...\n\n// tags: sdf, space, square, distance, tiling, infinite, euclidean, geometric, lattice, frame, loopless, series, exact, sum, telescoping\n\n// A space frame tower / mesh tower / lattice tower,\n// loopless exact euclidean SDF based on Geometric Series.\n\nfloat geometric_series_mesh_tower(vec2 p, float n)\n{\n    mat2 R = mat2(+1,-1,-1,-1)/sqrt(2.0);\n    p = R*p;\n    p = p.x < p.y ? p.yx : p;\n    float n1 = n - 1.0;\n    if(dot(vec2(n,n1), p) < 0.0) return length(p);\n    float d0 = -dot(normalize(vec2(n1,-n)), p);\n    float b = n / n1;\n    vec2 s = floor(log2(p)/log2(b));\n    float m = max(s.x, s.y);\n    p = fract(p/pow(b,m)*n1);\n    p = (0.5-abs(p-0.5))*pow(b, m)*b/n;\n    float d1 = min(abs(p.y-p.x)/sqrt(2.0), min(p.x, p.y));\n    return abs(min(d0, d1));\n}\n\nfloat map(vec2 p, float n)\n{\n    p.y -= 0.75;\n    return geometric_series_mesh_tower(p, n);\n}\n\n#define EPSILON 0.001\n\nvec2 gradient(vec2 p, float n) // NOT normalized so we can use it's length to detect errors in the SDF.\n{\n    vec2 h = vec2(EPSILON, 0);\n    return (vec2(map(p + h.xy, n) - map(p - h.xy, n),\n                 map(p + h.yx, n) - map(p - h.yx, n))) / EPSILON / 2.0;\n}\n\n#define pi 3.1415926\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    vec2 R = iResolution.xy;\n\ti = (2.0 * i - R) / R.y;\n    vec2 m = (2.0 * iMouse.xy - R) / R.y;\n\n    float n = floor((0.5 - 0.5 * cos(iTime)) * 5.0 + 2.0);\n    float d = map(i, n);\n    \n\t// using iq's sdf visualization\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(150.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n\n    if(iMouse.z > 0.001)\n    {\n        d = map(m, n);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(i - m) - abs(d)) - 0.0025));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(i - m) - 0.015));\n    }\n\n    // sdf error-detection from https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors\n    {\n        float error = map(i - gradient(i, n) * map(i, n), n);\n        col.r += smoothstep(0.0, EPSILON, abs(error)) * (cos(iTime * 2.0 * pi) * 0.5 + 0.5); // detect some (interior and exterior) sdf inconsistencies\n    }\n\n    o = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}