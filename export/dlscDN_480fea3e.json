{"ver":"0.1","info":{"id":"dlscDN","date":"1690791724","viewed":16,"name":"齐次坐标演示","username":"Leslie","description":"本例中采用图形pipeline中primitive shader采用的，多边形各边依次叉乘方式来判断fragment是否在多边形内。\n这种方法才能完美契合齐次坐标，可以实现旋转、缩放和平移。\n上一例中的直线采用了固定距离值判断有效范围，只用单位向量来判断方向，所以缩放无效。","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 frg )\n{\n    vec3 red=vec3(1.,0.,0.);\n    vec3 green=vec3(0.,1.,0.);\n    \n    float scale=min(iResolution.x, iResolution.y);\n    \n    vec3 uv=vec3(frg/scale, 1.);\n    vec3 res=vec3(iResolution.xy/scale, 1.);\n    vec3 pt0=vec3(0., 0., 1.);\n    vec3 pt1=vec3(0.25*res.x, 0., 1.);\n    vec3 pt2=vec3(0., 0.5*res.y, 1.);\n    \n    float an=iTime;\n    \n    // 旋转矩阵\n    mat3 m1=mat3(\n        cos(an), -sin(an), 0.,\n        sin(an), cos(an),0.,\n        0.,       0.,     1.\n    );\n    \n    // 缩放矩阵\n    mat3 m2=mat3(\n        2., 0., 0.,\n        0., 1., 0.,\n        0., 0., 1.\n    );\n    \n    // 平移矩阵\n    mat3 m3=mat3(\n        1., 0., (sin(iTime)+1.)*res.x*.5,\n        0., 1., (sin(iTime)+1.)*res.y*.5,\n        0., 0., 1.\n    );\n\n    // 一定要缩放后再平移，不然平移量也会被缩放\n    pt0*=m1*m2*m3;\n    pt1*=m1*m2*m3;\n    pt2*=m1*m2*m3;\n    \n    if(cross(uv-pt0, pt1-pt0).z<0. && cross(uv-pt1, pt2-pt1).z<0. && cross(uv-pt2, pt0-pt2).z<0.) fragColor = vec4(red,1.); else fragColor = vec4(green,1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float cross2( vec2 a, vec2 b )\n{\n    return (a.x*b.y - a.y*b.x);\n}","name":"Common","description":"","type":"common"}]}