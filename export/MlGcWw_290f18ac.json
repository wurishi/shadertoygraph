{"ver":"0.1","info":{"id":"MlGcWw","date":"1536842179","viewed":132,"name":"try volumetric sphere","username":"cailuming","description":"try constant density volumetric sphere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["volumetricconstantdensity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 64\n#define PI 3.1415926\nstruct Ray {\n   vec3 o;\n   vec3 d;\n};\n\nmat2 rot2D(float arc){\n    float c = cos(arc);\n    float s = sin(arc);\n    return mat2(c,s,-s,c);\n}\n \n\nvec2 sphere(vec3 p,vec3 c){\n    p-=c;\n    p.z+=iTime;\n    float mdr = 1.5;\n    \n    p.xz=mod(p.xz,mdr);\n    p.xz-=(mdr*0.5);\n  \n    return vec2(length(p)-1.0,0.0);\n}\n\nvec2 sphere1(vec3 p,vec3 c){\n    p-=c;\n     \n    return vec2(length(p)-2.0,0.0);\n}\n\nvec2 box(vec3 p,vec3 c){\n    p-=c;\n    p.xz*=rot2D(iTime);\n    p.xy*=rot2D(iTime);\n    \n    float arc = atan(p.y,p.x);\n    float v = max(max(abs(p.x),abs(p.y)),abs(p.z))-1.0;\n    float v1 = length(p)-1.0;\n    \n    float ts = clamp(cos(iTime*6.0),0.,1.0);\n    ts = pow(ts,3.0);\n    v = mix(v,v1,ts);\n    return vec2(v,1.0);\n}\n\n\nvoid cmp(vec2 a,inout vec2 r){\n    r=r.x>a.x?a:r;\n}   \n \nvec2 map(vec3 p){\n   vec2 ref = vec2(1000);\n   \n   cmp(sphere(p,vec3(0,0,5)),ref);\n   cmp(box(p,vec3(0.0,3.0,16.0)),ref);\n\n   return ref;\n}\n\nvec2 rayHit(Ray r){\n    vec2 h = vec2(0);\n    float t = 1.0;\n    \n    for (int i=0;i<FAR;i++){\n        h= map(r.o+t*r.d);\n        if(h.x<=0.005){\n           break;\n        }else{\n           t+=h.x;\n        }\n    }\n    return vec2(t,h.y);\n}\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 dir,vec2 uv){\n    vec3 look  = normalize(dir-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up    = normalize(cross(look,right));\n    \n    r.o = eye;\n    r.d = normalize(uv.x*right+uv.y*up+look);\n}\n\n//evaluate the gradient\nvec3 getNormal(vec3 p,float t){\n   vec2 e = vec2(1,0)*0.01*t;\n   float m = map(p).x;\n   return normalize(\n       vec3(\n        map(p+e.xyy).x-m,\n        map(p+e.yxy).x-m,\n        map(p+e.yyx).x-m\n       )\n     ); \n}\n       \nvoid doShade(inout vec3 col,Ray r,vec3 lp,vec2 sv){\n    vec3 hp    = r.o+sv.x*r.d; \n    vec3 ld    = normalize(lp-hp);\n    vec3  n    = getNormal(hp,sv.x);\n    vec3 rd    = reflect(ld,n);\n    vec3 lkdir = normalize(hp-r.o);\n    float nl   = smoothstep(-1.0,1.0,dot(n,ld));\n    float nr   = smoothstep(-1.0,1.0,dot(lkdir,rd));\n    \n    float nn   = 1.0;\n   \n    nl+=pow(nr,50.0)*0.3;\n    if(sv.y == 0.){\n       \n        nn = smoothstep(-0.1,1.,pow(dot(lkdir,n),2.0));\n        col = mix(col,vec3(nl),nn);\n    }else if(int(sv.y) == 1){\n       \n        col = mix(col,vec3(nl),0.7)*vec3(cos(iTime)*0.2+0.8,sin(iTime)*0.3+0.8,cos(iTime*0.4)*0.5+0.6);\n    } \n    col = mix(col,vec3(0.6,0.7,0.8),1.-exp(-sv.x*sv.x*0.0002)); \n}\n\nvoid drawVolumeSphere(Ray r,float refz,vec3 lp,vec3 eye,inout vec3 col)\n{\n    float t = 0.;\n    float d = 0.;\n    float freq = texture(iChannel2,vec2(0.5,0.0)).x;\n    vec3 c = vec3(10.0*sin(iTime),2.0+freq*6.0,20.0+10.0*cos(iTime));\n    \n    for (int i=0;i<32;i++){\n       d = sphere1(r.o+r.d*t,c).x;      \n        if(d<=0.0001){\n          break;     \n        }\n        t+=d;\n    }\n\n    if(refz>=t){\n       vec3 hp = r.o+t*r.d;\n       hp-= c;\n       vec3 n = normalize(hp);\n       vec3 spColor = vec3(0.9,1.0,0.3);\n       vec3 ld    = normalize(lp-hp);\n       vec3 rd    = reflect(-ld,n);\n       float scatter = clamp(dot(n,normalize(eye-c)),0.0,1.);\n       scatter = smoothstep(0.,1.,scatter);\n       scatter = pow(scatter,10.);\n       float nl =smoothstep(-2.0,1.0,dot(n,ld));\n       \n       float nr = max(0.3,dot(n,rd));\n       float rnl = clamp(1.0-nl,0.,1.);\n       \n       col = mix(col,spColor*nl,scatter);\n       col = mix(col,spColor*rnl,-pow(nr,3.0));\n       \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv  = fragCoord/iResolution.xy;\n    vec2 cuv = uv-vec2(0.5,0.5);\n    vec2 sv  = vec2(0);\n    vec3 col = vec3(.5,0.6,0.7);\n    vec3 lp  = vec3(10.0*cos(iTime),10,10.0*sin(iTime));\n    vec3 eye = vec3(0,5,-2);\n    vec3 dir = vec3(0,3.5,3.0);\n    \n    float as = iResolution.x/iResolution.y;\n  \n    Ray r;\n  \n    cuv.x*=as;\n    \n    setCamera(r,eye,dir,cuv);\n  \n    sv=rayHit(r);\n    \n    doShade(col,r,lp,sv);     \n   \n    drawVolumeSphere(r,sv.x,lp,eye,col);\n    //color correction\n    col.x = pow(col.x,0.8);\n    col.y = pow(col.y,0.9);\n    col.z = pow(col.z,0.6);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}