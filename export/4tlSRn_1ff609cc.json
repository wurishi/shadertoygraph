{"ver":"0.1","info":{"id":"4tlSRn","date":"1434081686","viewed":372,"name":"SimulateSubsurfaceStudy","username":"tyleeer","description":"The lighting direction is toward the camera. Therefore without subsurface scattering everything is black.\nThere are lots of artifacts, e.g., on the ground plane. (Need to check some corner cases)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// simple testing of ray marching\n\nconst vec3 lightDirection = vec3(0.0,0.0,0.2);\n\nfloat distanceToSphere(vec3 p, float r) {\n    return length(p)-r;   \n}\n\nfloat distanceToGroundPlane(vec3 p) {\n     return p.y+0.5;   \n}\n\nfloat distanceToObjects(vec3 p) {\n    float d1 = distanceToSphere(p,0.5);\n\tfloat d2 = distanceToGroundPlane(p);\n    \n    return min(d1,d2);\n}\n\nvec3 calculateGradientFromDistanceField(vec3 p) {\n    \n    float d = 0.001;\n    float Dx = (distanceToObjects(p+vec3(d,0.0,0.0))-distanceToObjects(p+vec3(-d,0.0,0.0)))/(2.0*d);\n    float Dy = (distanceToObjects(p+vec3(0.0,d,0.0))-distanceToObjects(p+vec3(0.0,-d,0.0)))/(2.0*d);\n    float Dz = (distanceToObjects(p+vec3(0.0,0.0,d))-distanceToObjects(p+vec3(0.0,0.0,-d)))/(2.0*d);\n    return vec3(Dx,Dy,Dz);\n}\n\nvec3 calculateNormal(vec3 p) {\n    return calculateGradientFromDistanceField(p);\n}\n\nvec4 shade(vec3 p, vec3 n) {\n    float c = max(0.0,dot(-lightDirection,n));\n    //return vec4(c,c,c,1.0);\n    return vec4(c,c,c,1.0);\n}\n\nvec4 subRayCast(vec3 ro, vec3 rd) {\n    \n    vec4 color = vec4(1.0,1.0,1.0,1.0);\n \tvec4 color1 = vec4(0.0,1.0,0.2,1.0);\n    vec4 color2 = vec4(0.0,0.2,1.0,1.0);\n        \n    float t = 0.0;\n    const int N = 80; // iteration number\n    for (int i = 0; i < N; i++) {\n        vec3 p = ro+t*rd;\n     \tfloat d = -distanceToObjects(p);\n        if (d < 0.01) {\n        \t//color = mix(color1,color2,float(i)/float(N));\n            float a = pow(1.5,-2.5*t);\n            color = a*shade(p,calculateNormal(p));\n            break;\n        }\n        else {\n            t += d;\n        }\n    }\n    \n    return color;\n}\n\nfloat F(float c) {\n   return (pow(2.0,c)-1.0)/pow(2.0,c);  \n}\n\nvec4 rayCast(vec3 ro, vec3 rd, float flag) {\n    \n    vec4 color = vec4(1.0,1.0,1.0,1.0);\n \tvec4 color1 = vec4(0.0,1.0,0.2,1.0);\n    vec4 color2 = vec4(0.0,0.2,1.0,1.0);\n        \n    float t = 0.0;\n    const int N = 80; // iteration number\n    for (int i = 0; i < N; i++) {\n        vec3 p = ro+t*rd;\n     \tfloat d = distanceToObjects(p);\n        if (d < 0.01) {\n        \t//color = mix(color1,color2,float(i)/float(N));\n            if (flag < 0.0) {\n                vec4 subColor = subRayCast(p-0.2*calculateNormal(p),-lightDirection);\n                float b = 0.50;\n                float c = 80.0*subColor.r;\n                c = F(c);\n                color = vec4(c,c,c,1.0);\n            }\n            else {\n                color = 30.0*shade(p,calculateNormal(p));\n            }\n            break;\n        }\n        else {\n            t += d;\n        }\n    }\n    \n    return min(color,1.0);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    // convert pixel space to UV[0,1]x[0,1] space \n\tvec2 uv = 2.0*(fragCoord.xy/iResolution.xy)-1.0;\n    // this will preserve the aspect ratio in U\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //camera coordinate system\n    vec3 C_o = vec3(0.0,0.0,0.0);\n    vec3 C_x = vec3(1.0,0.0,0.0);\n    vec3 C_y = vec3(0.0,1.0,0.0);\n    vec3 C_z = vec3(0.0,0.0,1.0);\n    float f = 3.0;\n    \n    // camera Transformation\n    vec3 T = vec3(0,0,4);\n    mat3 R = mat3(cos(0.0),0.0,-sin(0.0), // first column\n                  0.0,1.0,0.0, // second column\n                  sin(0.0),0.0,cos(0.0)); // third column\n    \n    // Shoot a ray\n    vec3 ray_o = (uv[0]*C_x+uv[1]*C_y-f*C_z);\n    vec3 ray_dir = (normalize(ray_o));\n    \n    vec3 ray_o_g = R*ray_o+R*T;\n    vec3 ray_dir_g = R*ray_dir;\n    \n    float ds = fragCoord.x-(iMouse.z > 0.0 ? iMouse.x: iResolution.x/2.0);\n    \n    fragColor = mix(rayCast(ray_o_g,ray_dir_g,ds),vec4(1.0,0.0,0.0,1.0),1.0-smoothstep(0.0,3.0,abs(ds)));\n}","name":"","description":"","type":"image"}]}