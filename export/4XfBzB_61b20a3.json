{"ver":"0.1","info":{"id":"4XfBzB","date":"1728512703","viewed":25,"name":"path concatenate","username":"Elsio","description":"need organization ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["animate","pentagon","loopless","geometri","dodecagon","slip","heptagon","tetra","octogono","octagono","cabri","geogebra"],"hasliked":0,"parentid":"M3XBDN","parentname":"Polygon slip (bit more accurate)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.)\n#define TAU 2. * PI\n\nfloat Poly(vec2 p, float k, float ra, float T) {\n    float d;\n    d = atan(p.y, p.x) - T;\n    d = mod(d, TAU / k) - PI / k;\n    d = cos(d) * length(p) - ra;\n    return min(abs(d), abs(length(p) - .005));\n}\n\nvec3 Enum(vec2 R, int n, int m) {\n    vec2 ret;\n    \n    if(n == 0) ret = vec2(-1, -1) * (R.y - R.x * vec2(1, 0));\n    if(n == 1) ret = vec2(-1,  1) * (R.y - R.x * vec2(1, 0));\n    if(n == 2) ret = vec2( 1, -1) * (R.y - R.x * vec2(1, 0));\n    if(n == 3) ret = vec2( 1,  1) * (R.y - R.x * vec2(1, 0));\n    if(n == 4) ret = vec2(-1, -1) * (R.y - R.x * vec2(0, 1));\n    if(n == 5) ret = vec2(-1,  1) * (R.y - R.x * vec2(0, 1));\n    if(n == 6) ret = vec2( 1, -1) * (R.y - R.x * vec2(0, 1));\n    if(n == 7) ret = vec2( 1,  1) * (R.y - R.x * vec2(0, 1));\n    \n    float t = fract(iTime) + float(m);\n    return vec3(ret, t * PI / 4.);\n}\n\nfloat mark(vec2 u, vec2 R) {\n    float t = floor(iTime);\n    t = mod(t, 8.);\n    vec3 k;\n    \n    if(t == 0.) k = Enum(R, 0, 3);\n    if(t == 1.) k = Enum(R, 4, 6);\n    if(t == 2.) k = Enum(R, 6, 5);\n    if(t == 3.) k = Enum(R, 2, 0);\n    if(t == 4.) k = Enum(R, 3, 7);\n    if(t == 5.) k = Enum(R, 7, 2);\n    if(t == 6.) k = Enum(R, 5, 1);\n    if(t == 7.) k = Enum(R, 1, 4);\n    \n    u += k.xy;\n    float t2 = k.z;\n    return smoothstep(\n               .005, .0, \n               abs(\n                   abs(length(u) - R.x / 2. - .01) \n                   - R.x / 2. \n                   + .01\n               ) \n               - .001\n           ) * .1 \n           \n           + smoothstep(\n                 .005, .0, \n                 length(u + cos(t2 + vec2(0, 11)) * R.x) \n                 - .01\n             ) * .8;\n}\n\nvoid mainImage(out vec4 o, vec2 U) {\n    vec2 r = iResolution.xy,\n         u = (U - r / 2.) / r.y;\n    \n    o *= .0;\n    float k = 4.;\n    float scale = .7 + cos(iTime * .5) * .05,\n          c = cos(PI / (k * 2.)) * scale;\n    \n    vec2 R = vec2(1, cos(PI / k)) * c /(cos(PI / k) + 1.);\n    \n    o += mark(u, R);\n    o += smoothstep(\n             2. / r.y, .0, \n             Poly(u, k * 2., c, PI /(2. * k))\n         ) * .4 \n         \n         + mix(\n               o, \n               vec4(0, .4, 0, 0), \n               smoothstep(\n                   4. / r.y, .0, \n                   length(u) - scale\n               )\n           ) \n           \n         + smoothstep(2. / r.y, .0, Poly(u + vec2( R.x, 0), k, R.y, PI / k )) * .2 \n         + smoothstep(2. / r.y, .0, Poly(u + vec2(-R.x, 0), k, R.y, PI / k )) * .2 \n         + smoothstep(2. / r.y, .0, Poly(u + vec2(0,  R.x), k, R.y, PI / k )) * .2 \n         + smoothstep(2. / r.y, .0, Poly(u + vec2(0, -R.x), k, R.y, PI / k )) * .2 \n         + smoothstep(2. / r.y, .0, Poly(u,                 k, R.y, 0.     )) * .2 \n         //+ smoothstep(2. / r.y, .0, Poly(u,                 k, R.y, PI / 4.)) * .2\n     ;\n}","name":"Image","description":"","type":"image"}]}