{"ver":"0.1","info":{"id":"XtVBRc","date":"1543440810","viewed":125,"name":"First Attempt at a RayMarcher","username":"foodini","description":"Just trying to build a ray marching demo that will be easily modiiable by someone trying to learn the concepts. \n\nVery much a work in progress.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dist1(vec3 p) {\n    p = mod(p+0.5,1.0)-vec3(0.5);\n    return length(p) - 0.3;\n}\n\nfloat dist2(vec3 p) {\n    float single = length(p) - sin(iTime)*sin(iTime);\n  \n    //p = mod(p,1.0)-vec3(0.5); // instance on xy-plane\n    vec3 folded = fract(p+0.5)-vec3(0.5); // instance on xy-plane\n    float infinite = length(folded)-abs(sin(length(p))/4.0);\n  \n    return min(infinite, single);\n}\n\n\nint iterations = 15;\nfloat scale = 2.0;\nfloat dist3(vec3 z) {\n\tvec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < iterations) {\n\t\t c = a1; dist = length(z-a1);\n\t     d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n\t\tz = scale*z-c*(scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(z) * pow(scale, float(-n))-0.001;\n}\n\nfloat dist4(vec3 z) {\n    float r;\n    int n = 0;\n    while (n < iterations) {\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n       z = z*scale - vec3(1.,1.,1.)*(scale-1.0);\n       n++;\n    }\n    return (length(z) ) * pow(scale, -float(n));\n}\n\nfloat dist(vec3 p) {\n    return dist4(p);\n}\n\nvec3 dx = vec3(0.0001, 0.0, 0.0);\nvec3 dy = vec3(0.0, 0.0001, 0.0);\nvec3 dz = vec3(0.0, 0.0, 0.0001);\n\nvec3 norm(vec3 p) {\n    return normalize(\n        vec3(dist(p+dx)-dist(p-dx),\n\t\t     dist(p+dy)-dist(p-dy),\n\t\t     dist(p+dz)-dist(p-dz))\n    );   \n}\n\nfloat rand(float seed) {\n    float s = sin(seed*iTime + 3872983.9);\n    return s*s;\n}\n\n//rd MUST BE NORMALIZED, or distance estimation will march the ray in incorrect step sizes.\nbool march(out int iterations, out vec3 point, out float smallest_dist, in vec3 r0, in vec3 rd) {\n    float total_dist = 0.0;\n    float cur_dist;\n    smallest_dist = 10000000.0;\n    \n    point = r0 + rd * total_dist;\n    for (iterations=0; iterations<120; iterations++) {\n        cur_dist = dist(point);\n        if(cur_dist < smallest_dist) {\n            smallest_dist = cur_dist;\n        }\n        if(cur_dist < 0.001) {\n            return true;\n        }\n        total_dist += cur_dist;\n    \tpoint = r0 + rd * total_dist;\n    }\n    return false;\n}\n\nvec3 ortho_light_dir = vec3(0.57735, -0.57735, 0.57735);\nvec3 ortho_light_color = vec3(0.8, 0.5, 1.0);\n\nvec4 lighting(vec3 p, vec3 n) {\n    //AMBIENT (currently 0) Should be multiplied by diffuse color.\n    vec3 retval = vec3(0., 0., 0.); \n    float dprod = dot(n, ortho_light_dir);\n    if(dprod >= 0.0) {\n        retval += ortho_light_color * (\n            //DIFFUSE\n            vec3(0.7, 0.8, 1.0) * dprod +\n            //SPECULAR\n            //pow(dprod, 40.0)\n            0.0\n        );\n    }\n    return vec4(retval, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Screen x goes from -1.0 to 1.0\n\tvec2 screen_coord = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n    float aspect_ratio = iResolution.x/iResolution.y;\n    //Screen y goes from (-1.0/aspect_ratio to 1.0/aspect_ratio)\n    screen_coord.y /= aspect_ratio;\n\n    //Given a viewpoit (location of the eye) and a point to look at,\n    //compute the vector out the top of the viewer's head (up) and out\n    //his right ear (right);\n\tvec3 viewpoint = vec3(2.5*sin(iTime/8.), 2.5*cos(iTime/8.), sin(iTime/16.));\n    vec3 lookat = vec3(0., 0.0, 0.0);\n    vec3 lookdir = lookat - viewpoint;\n    vec3 right = normalize(cross(lookdir, vec3(0., 0., 1.)));\n    vec3 up = normalize(cross(right, lookdir));\n    \n    //Scale right and up to fix the 'focal length' of the camera. By\n    //doing this, I can make the distance between viewpoint and lookat\n    //arbitrarily large or small and the camera doesn't jump from zoom\n    //to fisheye. Change the 1.0s to something larger for fisheye, smaller\n    //for zoom.\n    float looklen = length(lookdir);\n    right *= looklen * 0.5;\n    up *= looklen * 0.5;\n    \n    //From the viewpoint, the ray we'll travel along to pass through the\n    //appropriate pixel:\n    vec3 ray_d = \n        normalize(\n        \tlookat\n            + screen_coord.x * right\n            + screen_coord.y * up\n            - viewpoint\n        );\n    \n    int iterations;\n    vec3 intersection;\n    float smallest_dist;\n    bool hit = march(iterations, intersection, smallest_dist, viewpoint, ray_d);\n    if(hit) {\n        //\n        fragColor = lighting(intersection, norm(intersection));\n    } else {\n        float sky_brightness = max(dot(ray_d, ortho_light_dir), 0.0);\n        vec3 sky_color = sky_brightness * ortho_light_color;\n    \tfragColor = vec4(sky_color, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}