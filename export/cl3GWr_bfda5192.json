{"ver":"0.1","info":{"id":"cl3GWr","date":"1682255015","viewed":539,"name":"simple and great lighting model","username":"Poisson","description":"A simple but very nice lighting model.\nFeatures: lambert, phong, blinn, ggx brdf, roughness, schlick fresnel, ior","likes":62,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","reflection","raytracer","ray","d","lighting","light","sphere","antialiasing","specular","lambert","aa","model","diffuse","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// top -> dielectric with blinn ggx\n// middle -> metal with blinn ggx\n// bottom -> metal with phong ggx\n\n#define AA 2 // antialiasing\n\n// ray sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    \n    if(h<0.) return -1.;\n    return -b - sqrt(h);\n}\n\n// intersection function\nfloat intersect(vec3 ro, vec3 rd, float tmax, out vec3 on, out int oid) {\n    float t = tmax;\n    \n    for (int i=0; i<18; i++) {\n        vec3 ce = vec3((i%6)*2-5, i/6*2-2, 0); // sphere center\n        float h = sphIntersect(ro, rd, ce, .95);\n        if (h>0. && h<t) {\n            on = normalize(ro-ce + rd*h); // normal\n            oid = i;\n            t = h;\n        }\n    }\n\n    return t<tmax ? t : -1.;\n}\n\n// my lighting model\n// lambert + blinn/phong ggx + shlick\n\n// type -> blinn or phong\n// n -> normal\n// l -> light direction\n// rd -> ray direction\n// kl -> light color\n// kd -> diffuse color\n// ks -> specular color\n// km -> roughness / microfacet amount\n// kn -> refraction index\nvec3 lighting(int type, vec3 n, vec3 l, vec3 rd, vec3 kl, vec3 kd, vec3 ks, float km, float kn) {\n    float ndl = clamp(dot(n, l), 0., 1.); // diffuse/lambert / N⋅L\n    \n    float ndh;\n    if (type==0) { // blinn\n        vec3 h = normalize(l - rd); // half vector\n        ndh = dot(n, h); // N⋅H\n    } else { // phong\n        vec3 r = reflect(rd, n); // reflected vector\n        ndh = dot(r, l); // R⋅L\n    }\n    // ggx / Trowbridge and Reitz specular model approximation\n    float g = ndh*ndh * (km*km - 1.) + 1.;\n    float ggx = km*km / (3.141592*g*g);\n\n    // shlick approximation\n    float fre = 1.+dot(rd, n); // fresnel\n    // fresnel amount\n    float f0 = (kn-1.)/(kn+1.);\n          f0 = f0*f0;\n    float kr = f0 + (1.-f0)*(1.-km)*(1.-km) * pow(fre, 5.); // reflectivity\n    \n    return kl*ndl*(kd + ks*kr*ggx); // diffuse + specular\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(.5+.5*rd.y)*.02; // background\n    \n    vec3 n; int id;\n    float t = intersect(ro, rd, 1e10, n, id);\n    \n    if (t>0.) {\n        vec3 p = ro + rd*t; // hit point\n        \n        vec3 difCol;\n        vec3 speCol;\n        float rou;\n        float ior;\n        int type;\n        \n        int row = id/6;\n        if (row==2) { // dielectric\n            difCol = vec3(.5,.1,.01);\n            speCol = vec3(1); // dieletrics have always white specular\n            rou = float(id%6)/5.;\n            rou = .002+.998*rou*rou;\n            ior = 1.65;\n            type = 0; // blinn\n        } else {\n            difCol = vec3(0);\n            speCol = vec3(1,.5,.1);\n            rou = float(id%6)/5.;\n            rou = .002+.998*rou*rou*1.5;\n            ior = 0.; // 0 ior for metals (full specular)\n            type = 1-row; // blinn or phong\n        }\n                        \n        col = lighting(type, n, normalize(vec3(1, 1,  1)), rd, vec3(2), difCol, speCol, rou, ior) + // key light\n              lighting(type, n, normalize(vec3(0,-1, -2)), rd, vec3(.4), difCol, speCol, rou, ior) + // rim light\n              lighting(type, n, normalize(vec3(-2,0,-.5)), rd, vec3(.1), difCol, speCol, rou, ior); // fill light\n    }\n        \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // up vector\n    vec3 v = cross(u, w); // side vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized mouse coordinates\n    vec2 mo = (iMouse.xy - .5*iResolution.xy)/iResolution.y;\n\n    float an = .6*iTime + mo.x*3.141592; // camera xz rotation\n    vec3 ro = 22.*vec3(sin(an),0,cos(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 tot = vec3(0);\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n        \n        vec3 rd = ca * normalize(vec3(p,3)); // ray direction\n        vec3 col = render(ro, rd); // render\n        \n        col = 2.1*col/(1.+1.5*col); // tonemapping\n        col = pow(col, vec3(.4545)); // gamma correction\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .3+.7*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n\n    // output\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}