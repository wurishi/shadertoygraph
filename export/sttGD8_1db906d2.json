{"ver":"0.1","info":{"id":"sttGD8","date":"1636169929","viewed":590,"name":"PS2 Tube v2","username":"an0nymooose","description":"Edited from Tater's Mystery Tube https://www.shadertoy.com/view/sdfXW2\nand thanks Tater for fixing a lot of lighting bugs ;)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MY_BRAIN small\n#define STEPS 1.0\n#define MDIST 950.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define RGB_TRIANGLE_NOISE 0.0\n#define da dot(p,p)\n#define ta texture(iChannel0, vec2( \nvec3 glow = vec3(0);\nvec3 ro = vec3(0);\nfloat sts(float x){ return x-sin(x); }\nfloat rotation (float t){\n    float r = sin(t*2.)*sin(t);\n    r += t;\n    r+=2.0*abs(t*0.2);\n    r+=smoothstep(0.0,1.0,sin(t*0.25))*14.0;\n    r+=tan(sin(t)*0.4);\n    r+=smoothstep(0.5,1.0,sin(t*0.25+2.0))*sin((t*10.0)/10.0);\n   \n    r -= sts(sts(sts(t*2.0)))*pi/8.;\n    return r;\n}\n\nfloat box( vec3 p, vec3 s ){\n  vec3 d = abs(p) - s;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 path(vec3 p){\n    return vec3(sin(p.z*0.1)*3.0,cos(p.z*0.1)*2.0,0);\n}\n\nfloat spinBox(vec3 p ,float t){\n    float yy = sin(t*2.0)*6.0;\n    p.xz*=rot(yy*1.5);\n    p.y+= yy;\n    float b = box(p-vec3(0,0,0), vec3(0.7));\n    return b;\n\n}\n\n\nvec2 map(vec3 p){\n    vec2 a,b;\n    \n    //Assign material IDs to differentiate between objects and the tunnel\n    a.y = 1.0;\n    b.y = 2.0;\n    \n    float t = mod((iTime),1000.0);\n    \n    //Tunnel\n    float tunSize = ((iTime)*4.5) < 8.0 ? ((iTime)*4.5) : 8.0;\n    //float tunSize =9.0;\n    a = vec2(length(p.xy-path(p).xy)-tunSize, 2.0);\n    a.x=-a.x*.8;\n    \n    vec3 p2 = p;\n    p2-=path(p2);\n    float modd = 30.0;\n    vec3 id = floor((p2)/modd+modd*0.5);\n    p2.z = mod(p2.z,modd)-modd*0.5;\n    p2.y += -5.0;\n    \n    \n    //Tunnel Lights\n    b = vec2(box(p2-vec3(0,0,0), vec3(0.1,-1.5,0.1)), 1.0);\n    float lightCurveFormula = ((a.x)*(b.x*.3))*(a.x*.9);\n    vec3 tunnelcolor = (vec3(.7,0.378,0.943)*.55);\n    glow+=0.07/(0.7+lightCurveFormula)*tunnelcolor;\n    a = (a.x<b.x)?a:b;\n\n    float glowAmn = .012;\n    float spikeglowAmn = .012;\n    vec3 red = vec3(0.980,0.180,0.180);\n    vec3 purp = vec3(0.306,0.157,1.000);\n    vec3 green = vec3(0.157,1.000,0.282);\n    p2 = p-path(p);\n    id = floor((p2+15.0)/modd+modd*0.5);\n    \n    //Glow Boxes\n    if(mod(id.z,3.0)==0.0){\n        p2.z-=20.0;\n        p2.z = mod(p2.z,modd)-modd*0.5;\n        modd = 10.0;\n\n        p2.xy*=rot(4.2);\n        b.x = spinBox(p2-vec3(0,8.5,0),t+2.5);\n        a = (a.x<b.x)?a:b;\n        glow+=glowAmn/(0.01+(b.x*b.x))*green;\n\n        p2.xy*=rot(2.0);\n        b.x = spinBox(p2-vec3(0,8.5,0),t);\n        a = (a.x<b.x)?a:b;\n        glow+=glowAmn/(0.01+b.x*b.x)*red;\n\n        p2.xy*=rot(5.0);\n        b.x = spinBox(p2-vec3(0,83.5,0),t+1.0);\n        a = (a.x<b.x)?a:b;\n        glow+=glowAmn/(0.01+b.x*b.x)*green;\n\n        p2.z+=5.0;\n        p2.xy*=rot(2.0);\n        b.x = spinBox(p2-vec3(0,8.5,0),t+1.1);\n        a = (a.x<b.x)?a:b;\n        glow+=glowAmn/(0.01+b.x*b.x)*red;\n\n        p2.z+=5.0;\n        p2.xy*=rot(2.0);\n        \n        //you can remove this if statment (keep line 118), \n        //i just delayed the box to not\n        //appear when the ostrich head comes up on the left\n        if(iTime > 5.3 && iTime < 7.91){\n            b.x = spinBox(p2-vec3(0,15,0),t+3.2);\n        } else{\n            b.x = spinBox(p2-vec3(0,8.5,0),t+3.2);\n        }\n        a = (a.x<b.x)?a:b;\n        glow+=glowAmn/(0.01+b.x*b.x)*purp;\n    }\n    \n    \n    //Glow Spikeys\n    if(mod(id.z,3.0)==1.0){\n        p2.z-=15.0;\n        p2.z = mod(p2.z,modd)-modd*0.5;\n\n        vec3 tp2 = p2;\n        p2.z-=7.5;\n        p2.xy=tp2.xy*rot(rotation(t*1.5));\n        b.x = length(p2.xz)-p2.y*0.3+1.0;\n        glow+=spikeglowAmn/(0.01+b.x*b.x)*red;\n        a = (a.x<b.x)?a:b;\n\n        p2.z+=7.5;\n        p2.xy=tp2.xy*rot(rotation(t*1.5+5.0));\n        b.x = length(p2.xz)-p2.y*0.3+1.0;\n        glow+=spikeglowAmn/(0.01+b.x*b.x)*purp;\n        a = (a.x<b.x)?a:b;\n\n        p2.z+=7.5;\n        p2.xy=tp2.xy*rot(rotation(t*1.5+10.0));\n        b.x = length(p2.xz)-p2.y*0.3+1.0;\n        glow+=spikeglowAmn/(0.01+b.x*b.x)*green;\n        a = (a.x<b.x)?a:b;\n    }\n    \n    //More Boxes\n    if(mod(id.z,3.0)==2.0){\n        p2.z-=15.0;\n\n        p2.z = mod(p2.z,modd)-modd*0.5;\n        modd = 2.0;\n\n        //you can remove this if statment (keep line 164), \n        //i just delayed the box to not\n        //appear when the ostrich head comes up on the left\n        p2.xy*=rot(2.0);\n        if(iTime >4.92 && iTime < 6.6){\n            b.x = spinBox(p2-vec3(0,12,0),t);\n        } else{\n            b.x = spinBox(p2-vec3(0,8.5,0),t);\n        }\n        a = (a.x<b.x)?a:b;\n        glow+=glowAmn/(0.01+b.x*b.x)*green;\n\n        p2.z+=5.0;\n        p2.xy*=rot(2.0);\n        b.x = spinBox(p2-vec3(0,8.5,0),t+1.0);\n        a = (a.x<b.x)?a:b;\n        glow+=glowAmn/(0.01+b.x*b.x)*purp;\n\n        p2.z+=5.0;\n        p2.xy*=rot(2.0);\n        b.x = spinBox(p2-vec3(0,8.5,0),t+2.0);\n        a = (a.x<b.x)?a:b;\n        glow+=glowAmn/(0.01+b.x*b.x)*green;\n    }\n    \n    return a;\n}\n// unused for adding noise\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\n// spiral tube ////\nvec3 wtexture(vec2 pos,float posz)\n{\n    float sprialStrength = 0.09;\n    float lineThick = 0.33; //should be a multiple of 1.0\n    pos.xy-=path(vec3(0,0,posz)).xy;\n    pos.xy*=rot(-posz*sprialStrength);\n    return mix(vec3(0.211,0.101,0.266)*clamp(iTime*.5,0.0,0.85),vec3(0.070,0.035,0.090),\n    step(mod(atan(pos.x,pos.y)/pi*0.5-0.5,lineThick),lineThick*0.5))*1.4;\n}\n\nvec3 dcol(vec3 p, vec2 uv)\n{\n\tp.xyz += path(p);\n    \n\treturn wtexture(vec2(p.x,p.y),p.z);\n}\n///////////////////\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 pos = ( fragCoord.xy / iResolution.xy );\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime*10.0,5000.0)*5.0+2.0;\n    ro = vec3(0,0,t);\n    ro+=path(ro);\n    vec3 look = vec3(0,0,t+20.0);\n    look+=path(look);\n    vec3 f = normalize(look-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    \n    //Warp in effect for intro\n    float warp = (iTime*.08)*(iTime*0.7) <= 0.75 ? (iTime*.08)*(iTime*0.7) : 0.75;\n    vec3 rd = f*warp+uv.x*r+uv.y*cross(f,r);\n        \n    //Offset initial ray position with blue noise\n    float blueNoise = texelFetch(iChannel0, ivec2(fragCoord)% textureSize(iChannel0, 0) , 0).r;\n    \n    //Make sure not to offset too much to avoid going into geometry\n    \n    //This line adds a lot to the compile time for some reason.\n    //you could comment it out if you're not rendering\n    ro+=rd*blueNoise*min(5.0,map(ro).x*0.8);\n    \n    // R A Y M A R C H I N G\n    float dO; \n    vec2 d;\n    vec3 p = ro;\n    float defMaxStep = 100.0;\n    float maxStep = STEPS*(t*2.2) <= defMaxStep ? STEPS*(t*2.2) : defMaxStep;\n    for(float i = 0.0; i<maxStep; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO += d.x*0.60;\n         \n        if(d.x <=0.005||dO>=MDIST){\n            break;\n        }\n    }\n    \n    // fade tube rings in for intro\n    if(iTime<4.){\n        col = pow(dcol(p,uv),vec3(5.-iTime));\n    } else{\n        //Color the walls \n        if(d.y==2.0) col = dcol(p,uv);\n        //Color the objects\n        //Idk how the dcol function works so I just put in a random point\n        if(d.y==1.0) col = dcol(vec3(0),uv);\n    }\n    \n    // fade glow in for intro\n    float glowtime = (iTime*.2 < .40) ? (iTime*.2) : 0.40;\n    col+=glow*(.50-glowtime);\n    col = mix(col,0.01*vec3(1.000,0.886,0.251),dO/(MDIST+50.0));\n    //col = vec3(1.4, 1.4, 1.5) * col / (1.0 + col); \n   \n   \n    // color banding removal, hopefully youtube's codec\n    // does not NUKE us due to it.\n    vec2 seed = pos;\n    vec3 rnd = vec3( hash32( sin(seed)+iTime ) );\n\tcol = vec3( col ) + rnd/255.0;\n\n    fragColor = vec4(col,1.0);\n}\n\n#define AA 2.0\n#define ZERO min(iTime,0.0)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float px = 1.0/AA; vec4 col = vec4(0),col2;\n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    for(float i = 0.; i <AA; i++){\n        for(float j = 0.; j <AA; j++){\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col+=col2;\n            glow = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}