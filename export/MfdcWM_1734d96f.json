{"ver":"0.1","info":{"id":"MfdcWM","date":"1730937554","viewed":66,"name":"Door test ","username":"byname777","description":"Door test ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["door"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getSphereDist(vec3 p, float r) {\nfloat dist = length(p)-r;\nreturn dist;\n}\nfloat getBoxDist(vec3 p, vec3 s) {\nvec3 q = abs(p)-s;\nfloat dist = length(max(q, 0.0));\nreturn dist;\n}\n\n\nfloat getIndexOfMaterial(vec2 objs[6], float minDist) {\nfloat index = 0.0;\nfor(int i=0; i<6; i++) {\n  if(objs[i].x==minDist)\n\tindex = objs[i].y;\n}\nreturn index;\n}\nfloat smoothMax(float a, float b, float k) { \nreturn log(exp(k*a)+exp(k*b))/k;\n}\nfloat smoothMin(float a, float b, float k) { \nreturn -smoothMax(-a, -b, k);\n}\nmat2 rotation(float angle) {\nreturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 getObj(vec3 p) {\nvec2 objs[6];\nfloat sphereMainDistA = getSphereDist(p-vec3(0.0, 1.2, 1.6), 0.4);\nfloat sphereMainDistB = getSphereDist(p-vec3(0.0, 1.2, 1.3), 0.3);\nfloat sphereInsideDistA = getSphereDist(p-vec3(0.0, 1.2, 2.5), 0.2);\nfloat sphereOtherDist = getSphereDist(p-vec3(0.0, 1.2, 3.0), 0.7);\nfloat sphereMiniDist = getSphereDist(p-vec3(0.0, 1.2, 2.0), 0.2);\nfloat doorDist = getBoxDist(p-vec3(1.0, 1.0, 3.0), vec3(2.0,2.5, 0.3))-0.18;\nfloat boxForSphereDist = getBoxDist(p-vec3(1.0, 1.0, 2.99), vec3(2.0,2.5, 0.3))-0.18;\nfloat jDist = getBoxDist(p-vec3(-1.57, 1.0, 3.0), vec3(0.3,2.5, 0.3))-0.14;\nfloat wallDist = getBoxDist(p-vec3(0.0, 1.0, 3.3), vec3(10.0,2.5, 0.3))-0.18;\nfloat sphereInsideDist = smoothMin(sphereMainDistA, sphereInsideDistA, 8.0);\nfloat sphereMainDist = max(sphereMainDistA, -sphereMainDistB);\nfloat mainToMiniDist = smoothMin(sphereMainDist, sphereMiniDist, 8.0);\nfloat sphereOtherEditDist = max(-boxForSphereDist, sphereOtherDist);\nfloat miniToOtherDist = smoothMin(mainToMiniDist, sphereOtherEditDist, 8.0);\nobjs[0] = vec2(sphereMainDist, 2.0);\nobjs[1] = vec2(miniToOtherDist, 2.0);\nobjs[2] = vec2(doorDist, 1.0);\nobjs[3] = vec2(jDist, 1.0);\nobjs[4] = vec2(wallDist, 3.0);\nobjs[5] = vec2(sphereInsideDist, 2.0);\nfloat minDist = min(min(min(sphereMainDist, miniToOtherDist), wallDist), min(doorDist, min(jDist, sphereInsideDist)));\nfloat material = getIndexOfMaterial(objs, minDist);\nreturn vec2(minDist, material);\n}\n\nvec2 rayMarching(vec3 c, vec3 d) {\nfloat t=0.0;\nfloat material=0.0;\nfor(int i=0; i<80; i++) {\nvec3 p = c+d*t;\nvec2 obj = getObj(p);\nt+=obj.x;\nmaterial=obj.y;\n if(t>100.0 || obj.x < 0.001) break;\n}\n\nreturn vec2(t, material);\n}\nvec3 getNormal(vec3 p) {\nfloat d = getObj(p).x;\nvec2 e = vec2(0.01, 0.0);\nvec3 n = d - vec3(\ngetObj(p-e.xyy).x,\ngetObj(p-e.yxy).x,\ngetObj(p-e.yyx).x\n);\nreturn normalize(n);\n}\n\nfloat getLight(vec3 p) {\nvec3 light = vec3(sin(iTime)*2.0, 5.0, -4.0);\nvec3 ray = normalize(light-p);\nvec3 normal = getNormal(p);\nfloat diff = clamp(dot(ray, normal), 0.0, 1.0);\nfloat d = rayMarching(p+normal*0.01, ray).x;\nif(d<length(p-light))\ndiff*=0.1;\nreturn diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 col = vec3(0.0);\n\tvec3 c = vec3(-0.8, 1.4, -2.0);\n\tvec3 d = normalize(vec3(uv.x, uv.y, 2.8));\n\tvec2 point = rayMarching(c, d);\n\tfloat diff = getLight(c+d*point.x);\n    vec3 r = reflect(d, getNormal(c+d*point.x));\n\tvec3 ref=texture(iChannel0, r).rgb;\n    vec3 doorText=texture(iChannel1, uv).rgb;\n\tif(point.y==2.0)\n\t\tcol = vec3(diff*ref*vec3(1.0, 1.0, 0.0));\n\tif(point.y==1.0)\n\t  col = vec3(diff*doorText);\n\tif(point.y==3.0)\n      col = vec3(diff*vec3(0.9, 0.7, 0.5));\n\tfragColor=vec4(col, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}