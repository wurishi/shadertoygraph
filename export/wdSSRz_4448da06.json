{"ver":"0.1","info":{"id":"wdSSRz","date":"1553470856","viewed":604,"name":"Torus UV-Mapping","username":"Rloret","description":"Trying to map Uvs of a torus locally.\nNot really managed to get a signed angle for the V of the UV, so the texture repeats ¯\\_(ツ)_/¯","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["simple","marcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define E 0.001\n#define NE 0.01\n#define NSTEPS 100\n#define pi acos(-1.)\n\nvec2 torus =  vec2(3.0,1);\nvec2 tuv = vec2(0,0);\n\n\nfloat sdSphere(vec3 p,float R){\n\treturn length(p) -R;\n\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nvec2 getTorusUV(vec3 p,vec3 c){\n    \n    vec3 j = vec3(0,1,0);\n    \n    vec3 D = (p);\n    vec3 projDN = ((dot(D,j)) * j);\n    \n    vec3 R  = normalize(D);\n    vec3 cR = normalize(D-projDN);\n\n    vec3 C = cR * (torus.x + torus.y * 0.5);\n    vec3 V =  normalize(p-C);\n    \n    vec2 uv = vec2(atan(C.x,C.z)/pi, acos(dot(cR,V))/pi);\n\tuv.x= (uv.x+1.)*0.5;\n\n\t\n    return uv;\n}\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat scene(vec3 p )\n{\n    \n    vec3 rp =  p;\n   \n    rp.yz = rot(rp.yz,iTime*0.01);\n    rp.xz = rot(rp.xz,iTime*0.05);\n    rp.yz = rot(rp.yz,iTime*0.08);\n    tuv =getTorusUV(rp,vec3(0.,0.,0.));\n    return sdTorus(rp,torus);\n\treturn sdSphere(rp,1.);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 nd =  vec2(1.,0.) * NE;\n    return normalize(vec3(\n    \t\t\t\t scene( p + nd.xyy) - scene(p - nd.xyy),\n            \t\t scene( p + nd.yxy) - scene(p - nd.yxy),\n            \t\t scene( p + nd.yyx) - scene(p - nd.yyx)\n    \t\t\t\t));\n    \n}\n\nvec2 march(vec3 ro, vec3 rd){\n    \n  \tfloat t=0.;\n    float mat =1.;\n     float dt=0.;\n\tfor(int i=0;i<NSTEPS;i++){\t\n        dt = scene(ro+rd*t);\n        if(dt<E) {mat = 0.; break;}\n        t+=dt;\n    }\n    return vec2(t,mat);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv - 0.5;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    vec3 cam = vec3(0,0,0);    \n    cam += vec3(0,0,10);\n \n    \n    vec3 d =  normalize(vec3(uv,-1.));\n    \n\tvec2 result =  march(cam,d);\n    vec3 p = cam + d *result.x;\n    vec3 N = getNormal(p);\n\t\n    vec4 t =texture(iChannel0,tuv.xy * vec2(1.5,.5));\n    vec3 LD = normalize(vec3(1,1,1));\n    LD.xz = rot(LD.xz,iTime);\n    float S  = pow(max(dot(-d,N),0.01),79.);\n    float nl =dot(N,LD);\n        float scribble = scribbleTexture(tuv* vec2(5,.5),20,1.-nl,iTime);\n\n    vec3 c = vec3(t.x*scribble)  +S;\n    \n    float l =cubicPulse(0.,1.,uv.x);\n\tfragColor=result.y==0.?vec4( c,0):vec4((1.-dot(uv,uv))*0.1);\n    //fragColor = vec4(scribble);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------------\n//iq noise https://www.shadertoy.com/view/lsf3WH\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat noise(float x)\n{\n    float i=floor(x);\n    float f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float y=3.0*mix(hash11(i), hash11(i+1.), f);\n    return y;\n}\n//---------------------------------------------------------\n\n\n//-----------------Utils---------------------\nvec2 rot(vec2 p , float a){\n\tfloat s=sin(a),c=cos(a);\n    return vec2(p.x *c -p.y*s, p.x*s + p.y*c);\n\n}\n\n\nvec2 fMod(inout vec2 p, vec2 cellsize){\n\tvec2 cell =  floor(p/cellsize);\n    p = mod(p,cellsize)-cellsize*0.5;\n    return cell;\n}\n\nfloat sdCircunf(vec2 p,float r,float t){\n\n\treturn abs(length(p)-r)-t;\n}\n\n\n//-------------------------------------------\n\nfloat scribbleTexture(vec2 uv,int str,float ink,float iTime){\n    \n    float cs;\n    float c,ln,m;\n    float fc=0.;\n\tvec2 duv,cell;\n    \n    for(int i=1;i<str;i++){\n    \n     \tcs= float(i+1)/(float(str)*2.);\n        float h =noise(float(i)*2. );\n\t\tduv = uv + rot(uv+ noise(uv*0.1 +iTime*0.1),h) ;/*vec2(cos(float(iTime)),sin(float(iTime)))*0.3*/;\n\n\t\tcell =fMod(duv,vec2(cs));\n    \t\n    \tln =noise(duv *10./cs +cell.x/cs +cell.y);\n    \tc = sdCircunf(duv,mix(cs*0.45,cs*0.49,ln),mix(0.04*cs,0.006*cs,ln)*smoothstep(ink,0.,1.));\n        m =1.- round(smoothstep(c,cs*0.1*ink*ink,-cs*0.01*ink*ink));\n        \n        fc += m*ink;\n\n    \t\n    }\n    return (1.0-fc*pow(smoothstep(ink,0.,0.18),.4) );\n    \n   \n    \n   \n}\n","name":"Common","description":"","type":"common"}]}