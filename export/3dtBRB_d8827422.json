{"ver":"0.1","info":{"id":"3dtBRB","date":"1605439894","viewed":456,"name":"City Game  II ","username":"kastorp","description":"new version... with complete game/simulation!\ninstructions inside code \n\nalternate version here [url]https://www.shadertoy.com/view/tsVBzR[/url] (30s compilation time)","likes":22,"published":1,"flags":48,"usePreview":1,"tags":["game","simulation","city","traffic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// City Game  II by KASTORP\n// Fork of \"City Game\" by kastorp. https://shadertoy.com/view/3d3fR4\n// 2020-11-12 14:49:09\n/*------------------------------------------------------\n\nthe city needs your help!\n- connects all road to the center (yellow square)\n- connect all buildings to roads\n- convert congested semaphores & overpass into roundabouts\n- let all taxis (yellow cars) reach the center\n\nUnconnected roads/building are darker\nThe overall % of connected is shown up/right\nThe counter of remaining taxis is shown uu/right \n\nblock types and actions:\n   ROAD: add road\n   SEMAphore:  use with care! if 4 connections --> overpass\n   ROUNdabout: best solution for crossing\n   BUILding: add skyscraper\n   GRASs: clear block \n\nControls:\n   click on block type: select \n   click or drag on map: add selected block \n   CAPS-LOCK:  view mode / game mode\n   click + SHIFT or CTRL: special actions for selected block type\n\t\tROAD: +SHIFT: disabile auto roundabout, +CTRL= remove single connection between blocks\n\t\tGRASS: +SHIFT=increase altitude, +CTRL=decrease altitude\n   SPACE BAR: reset map and show demo mode\n   mouse in right panel: zoom & rotate view\n   Z: switch 2D/isometric view in right panel (2D is faster)\n\nother features:\n  multiple lanes: set LANES 2 in common file (requires >20s compilation)\n  set CITY_SIZE to 100 to see mega city\n\ntodo features:\n   rendering: more decorations\n   vehicles: pathfinding with overpass\n\nThe game is tested only on windows + chrome + Angle \n(sorry I can't help with compatibility issues)\n------------------------------------------------------*/\n\n#define GCOL(th) (th +float(THEIGHT)*.3 )/float(THEIGHT)/1.3*(.8+.2*hash(P0*4.))\n\nvec4 char(vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    return textureGrad( iChannel2, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n}\n\n// --- display int4\nvec4 pInt(float d, vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = d-1.; i>=0.; i--) \n        n /= 10.,\n        v += char(p - vec2(.5*i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n#define pString(p,st)  for(int _i= st.length()-1 ;_i>=0;_i-- ) Q+= char(p -vec2(.5*float(_i),0.), st[_i]).x; \n#define pStringC(p,st,c) for(int _i= st.length()-1 ;_i>=0;_i-- ) Q+= c* char(p -vec2(.5*float(_i),0.), st[_i]).x; \n\nmat2 rot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\nvec2 rpos(int ni,int no, float off, int di, int dout){\n    #if LANES >1\n    float ki= ni==1? -.5:.5,  ko= no==1? -.5:.5 ;\n    #else    \n    float ki=0.,ko=0.;\n    #endif\n    vec2 pOut=DIRS[dout]+ ko*DIRS[(dout+1)%4];\n    vec2 pIn=DIRS[di]+ki*DIRS[(di+3)%4];\n\n    return mix(\n        //45° path\n        .5 + mix(pIn, pOut,.5+off)*.5,\n         \n        //90° path\n        (off<0.? .5- pIn*off: .5+ pOut*off),\n        1. -float(LANES)/2.);\n}\n\nfloat vdist(vec2 p, vehicle nv,bool top){\n    \n    #if LANES >1\n    \tint lane_out=nv.lane_out;\n    #else\n        int lane_out=nv.lane;\n    #endif\n    vec2 dir = normalize(rpos(nv.lane,lane_out, nv.offset+.5,nv.dir_in,nv.dir_out)-rpos(nv.lane,lane_out,nv.offset-.5,nv.dir_in,nv.dir_out));\n    vec2 pos=p-rpos(nv.lane,lane_out,nv.offset,nv.dir_in,nv.dir_out);\n    pos= vec2(pos.x* dir.x + pos.y*dir.y , pos.y*dir.x-pos.x*dir.y);\n    return sdBox(pos,vec2(top? 0.2: 0.3 ,0.2));\n}\n\nvec2 position(vec2 U, float j){\n    //smooth position change \n    float \n        rz= CONF(vec2(3.,0.)).z\n        ,zz= .2 + CONF(vec2(3.,0.)).w*8. *.2\n        ,zh= 3.5 - CONF(vec2(3.,0.)).w*2.5;\n\n    \n    vec2 M =CONF(vec2(3.,0.)).xy/ZOOM;  \n\n    float h=  ZOOM2V* float(j)* zz ;\n\n    if(zoomMode|| WIN || DEMO)\n        return  (rot( rz +3.14)* ((U - vec2(0.,-R.y/5.+h)) *vec2(1.,zh)-vec2(R.x*(.5+ (DEMO||WIN?0.: ZX*.5)),R.y*zh/2.)) /ZOOM/ZOOM2H /zz  +M ); \n    else\n        return  (rot( rz )* ((U - vec2(0.,-R.y/5.+h)) -vec2(R.x*(.5+ (DEMO||WIN?0.: ZX*.5)),R.y*.5)) /ZOOM/ZOOM2H /zz  +M ); \n\n}\n\n\nvec4 map(in vec2 P, in float j, in block b,bool zoomView){\n\n    vec4 Q=vec4(0.);\n\n    vec2 P0 = floor(P)+.5; //position center\n    vec4 data=CELL(P0);\n    vec3 coord= buffer2coord(P0);\n    vec3 bcoord= vec3( coord.xy,0.);\n\n    cell c = decodeCell(data,coord); //CURRENT VEHICLE        \n    vec2 point = buffer2point(P); //RELATIVE COORDS\n    bool outside = bcoord.x <0. || bcoord.y<0. || bcoord.x>=BMAX.x || bcoord.y>= BMAX.y; //true if outside buffer A\n\n    //TERRAIN HEIGHT AND SLOPE\n\n\tvec2 pointH=point;\n    #if QUALITY>1\n    //ROAD  HEIGHT\n    \n    if((b.btype==4 || b.btype==2 || b.btype==5) && isRoad_(b,point)){ \n        if(b.conns==10) pointH.x=point.x;\n        else if(abs(point.x-3.)<1.) pointH.x=3.;\n        else if(point.x>4.) pointH.x=6.- (6.-point.x)*1.5;\n        else pointH.x=point.x*1.5;\n\n        if(b.conns==5) pointH.y=point.y;\n        else if(abs(point.y-3.)<1.) pointH.y=3.;\n        else if(point.y>4.) pointH.y=6.- (6.-point.y)*1.5;\n        else pointH.y=point.y*1.5;\n\n    }\n    #endif  \n    //BUSH HEIGHT\n    bool bushPoint=((b.btype==0 && b.ltype==0) ||(b.btype>0 && abs(point.x-3.)> 1.5 &&  abs(point.y-3.)> 1.5 )) && hash(P0*3.)>.8 && !isRoad_(b,point) ;\n    if(bushPoint ) pointH=floor(point)+.5;\n\n      \n    //TERRAIN HEIGHT INTERPOLATION\n    float th = +float(b.th);\n    if(int(mod(bcoord.x,2.))==1 && int(mod(bcoord.y,2.))==0) {\n        vec3 bcoord1 = vec3(coord.xy + DIRS[0],0.);\n        float th1= float(decodeBlock(BLOCK(coord2buffer(bcoord1)),bcoord1.xy).th);\n        vec3 bcoord2 = vec3(coord.xy + DIRS[2],0.);\n        float th2= float(decodeBlock(BLOCK(coord2buffer(bcoord2)),bcoord2.xy).th);\n        th=(th1*pointH.y +th2*(6.-pointH.y))/6.;\n    }\n    else if(int(mod(bcoord.x,2.))==0 && int(mod(bcoord.y,2.))==1){\n        vec3 bcoord1 = vec3(coord.xy + DIRS[1],0.);\n        float th1= float(decodeBlock(BLOCK(coord2buffer(bcoord1)),bcoord1.xy).th);\n        vec3 bcoord2 = vec3(coord.xy + DIRS[3],0.);\n        float th2= float(decodeBlock(BLOCK(coord2buffer(bcoord2)),bcoord2.xy).th);\n        th=(th1*pointH.x +th2*(6.-pointH.x))/6.;\n    }\n    else if( int(mod(bcoord.x,2.))==0 && int(mod(bcoord.y,2.))==0){\n        vec3 bcoord1 = vec3(coord.xy + DIRS[0]+ DIRS[1],0.);\n        float th1= float(decodeBlock(BLOCK(coord2buffer(bcoord1)),bcoord1.xy).th);\n        vec3 bcoord2 = vec3(coord.xy + DIRS[2]+ DIRS[1],0.);\n        float th2= float(decodeBlock(BLOCK(coord2buffer(bcoord2)),bcoord2.xy).th);\n        vec3 bcoord3 = vec3(coord.xy + DIRS[2]+ DIRS[3],0.);\n        float th3= float(decodeBlock(BLOCK(coord2buffer(bcoord3)),bcoord3.xy).th);\n        vec3 bcoord4 = vec3(coord.xy + DIRS[0]+ DIRS[3],0.);\n        float th4= float(decodeBlock(BLOCK(coord2buffer(bcoord4)),bcoord4.xy).th);\n\n        th=(th1*pointH.y*pointH.x \n            +th2*(6.-pointH.y)*( pointH.x)  \n            + th3*(6.-pointH.y)*(6.- pointH.x) \n            +th4*pointH.y*(6.-pointH.x))/36.;\n\n\n    }\n\n    #if QUALITY>1\n    //ROAD OVER WATER LEVEL\n    if((c.road || b.btype==1 && sdBox(point-3.,vec2(1.))<0.)  &&  c.pos>0 && !outside) th=max(th,5.);\n    #endif\n    \n\n\n    //OPTIMIZATION #2\n    if( float(j)<=max(th+10.,float(b.bh)) ) {\n\n\t\t//used by stripes \n        float fJun= (b.btype==1)?2.:(b.btype==2 ?1.: 0.);        \n    \t//roundabout center\n    \tbool roadP= c.road || (abs(length(point.xy-3.)-1.5)<.5 && !c.road && b.btype==1) ;\n\n        #if DEBUG>0\n        if( DEBUG>0 && (abs(point.x-3.)>2.8 || abs(point.y-3.)>2.8)) Q=vec4(0.); //DEBUG borders\n        else if (             \n            (b.th>0 && th<1. && b.conns==0 && b.ltype==2 && b.btype==0)|| \n            (b.th>0 && th<1. && b.btype>0 && UNCONNECTED)\n        ) Q=vec4(1.,0.,.0,0.); //DEBUG HIDDEN UNCONNECTEDS\n        else\n        #endif\n            //RENDERING---------------------\n\n\n            //BUILDINGS\n        if(j<=float(b.bh) + th && b.btype==0 && b.ltype>0 && b.th>=1 &&!outside \n               &&  sdBox(point - vec2(3.),vec2(1.7))<1. \n\n              ) {\n\n               float h= float(b.bh) + th;\n               float shadow= abs(point.x-3.)>  abs(point.y-3.)?.5:1.+sign(point.y-3.);\n               //if(zoomMode &&  iMouse.x>R.x/2. && iMouse.y >R.y*.55) h=th+15.;\n               h= (floor(h/10.)*10.);\n\n               float fl=j >= (h) ||  int(j)%5==0  ? .5:.5+float(j-th)/float(HEIGHT)*2.;\n\n               if(b.ltype==3 &&b.dist<=1) Q= vec4(1.6*fl,1.6*fl,0. ,h  );\n               \n               else Q= vec4(vec3(.8+ hash22(coord.xy).x*.3,.6, .6+hash22(coord.xy).y*.3)*fl*(b.conns==0 && GAME ?.3:1.),h  );\n               Q.xyz*= (.4+shadow*.3);\n               //Q= vec4(.5*fl,.3*fl,.3*fl + hash22(coord.xy).x*.3 ,h); \n\n            }\n\n\n\n        #if QUALITY>1\n        //RONDABOUT SIDEWALKS\n        else if(j<= max(th+1.5,5.)  && b.btype==1 //&&  sdBox(point.xy-3.,vec2(1.))<2. \n                && abs(length(point.xy-3.)-2.5)<.2 \n                && min(abs(point.x-3.),abs(point.y-3.))>1.\n               )  Q= vec4(vec3(UNCONNECTED?.2:.6)*(j>0.&& max(th+1.5,5.)-j>1.?.5:1.),max(th+1.5,5.));\n        #endif   \n\t\t\n        //else if(c.shift && c.v[0].vtype>0) Q= vec4(vec3(1.),max(th+1.5,5.)); //DEBUG OVERPASS\n\n        //NOT ROAD\n        else if( j<= th +12.   &&( isBlockCoord(coord) || !roadP  || b.btype==0  || outside  ) ){\n\n                \n                #if QUALITY>0\n            \t//ROUNDABOUT CENTER GRASS\n                bool rag= (j<= th+1.5  && b.btype==1 && sdBox(point.xy-3.,vec2(1.))<0.);                    \n                    \n         \t\tvec2 rp= mod(point+.5,1.)-.5;\n            \n               //SEMAPHORE\n                 if(j<= th+10.  && b.btype==2 && sdBox(point.xy-3.,vec2((zoomView?1.2 : 1.5)))<0. && min(abs(point.x-3.),abs(point.y-3.) )>1. ) \n                   Q=vec4( abs(j-th-4.)>3. && sign((point.x-3.)*(point.y-3.))!=sign(float(b.semaphore*2-1))?1.:0. ,0.,0.,th +10.);\n\n\n                //ROAD SIDEWALKS\n                else if(j<= max(5.,th+1.5)  && b.btype!=0 && !roadP && !rag && (\n                    (abs(point.x-3.)<1.3   && ((b.conns&1)==1 ||( b.btype==1&& point.y<5.4 )) && point.y>2.)|| \n                    (abs(point.x-3.)<1.3  && ((b.conns&4)==4 ||( b.btype==1 && point.y>.6 ) )&& point.y<4.)|| \n                    (abs(point.y-3.)<1.3   && ((b.conns&2)==2 || ( b.btype==1 && point.x<5.4)) && point.x>2.)||\n                    (abs(point.y-3.)<1.3  && ((b.conns&8)==8 || ( b.btype==1 && point.x>.6) ) && point.x<4.)||\n                    sdBox(point-3.,vec2(1.3))<0. \n\n                )) Q=vec4(vec3(UNCONNECTED?.2:.6)*(j>0.&& max(th+1.5,5.)-j>1.?.2:1.),max(th+1.5,5.));\n                     \n\n                //BUILDING SIDEWALK\n                else if(j<= th+1.5  && b.btype==0 && b.ltype>0 && b.th>=1 &&!outside \n                        &&  sdBox(point -3.,vec2(1.7))<1.3       \n                       ) Q=vec4(vec3(b.conns>0?.6:.2),th+1.5);\n              \n                else  \n                #endif\n                    //WATER\n                 if( th<1.) Q=vec4(  vec3(0.,.7,.9)*GCOL(th)*2. ,0.);\n                            \n                 //BUSH\n                 #if QUALITY>0\n                else if(j<= th+12. && bushPoint  && length(rp)*20.>j-th ){\n                    \n                    float shadow= //abs(atan(-rp.y,rp.x)/3.14-1.57);\n                        abs(rp.x)<  abs(rp.y)?.5:1.+sign(rp.y);\n\n                    Q=vec4(0.,GCOL(th)*(.7-shadow*.3),0.,10.+th);\n                    \n                }\n                #endif\n                //GRASS\n                else if(j<= th+.5 && j>=th || j<1. ) Q=vec4(0.,GCOL(th)*1.2,0. ,th+.5);\n                    \n                //DIRT\n                else Q=vec4(vec3(.6,.4,.4)*GCOL(th),th);\n\n        } \n\n        //ROAD       \n        else if (j<= th +(b.btype==5?15.:10.)  &&  roadP  ) {\n            float thr=th;\n            float thm= -1.;\n            \n            //OVERPASS \n            if(b.btype==5) {\n                if(abs(point.x-3.)<1. && abs(point.y-3.)<1. && j>th ) thr=th+5.;\n                else if(abs(point.x-3.)<1. && abs(point.y-3.)<1. && j<=th) thr=th-5.;\n            \telse if(point.x>4. && abs(point.y-3.)<1.) thr = th +(6.-point.x)*2.5;\n                else if(point.x<2. && abs(point.y-3.)<1.) thr = th + (point.x)*2.5;\n                else if(point.y<2.) thr = th - (point.y)*2.5;\n                else if(point.y>4.) thr = th - (6.-point.y)*2.5;\n                thm=  thr-2.;\n            \n                if(j<=th ){\n                    vec3 ncoord =vec3(c.block_pos,float(c.pos));\n                    if(c.pos==15) ncoord.z=10.;\n                     if(c.pos==14) ncoord.z=7.;\n                     if(c.pos==20) ncoord.z=25.;\n                     if(c.pos==21) ncoord.z=28.;\n                    vec4 ndata = CELL(coord2buffer(ncoord)); \n                    c = decodeCell(ndata,ncoord);\n                    \n                }\n            }\n            //VEHICLE\n            float pd= 10.;\n            int vtype=0;\n            bool brake =false;\n            bool lanechange=false;\n            if(j<= thr+5.){\n\n            if(float(j)<thr+5. && (j>=thr || j<=0.)){\n                for(int n =0;n<LANES;n++){\n                    float pdi =  c.v[n].vtype==0? 10.:vdist(mod(point,1.),c.v[n],float(j) -thr>1.5); //DISTANCE FROM VEHICLE\n                    if(pdi<pd){\n                        pd=pdi;\n                        vtype =c.v[n].vtype; //closest vheicle type\n                        brake = c.v[n].brake;\n                        #if LANES>1\n                        lanechange =c.v[n].lane_out!=n;\n                        #endif\n                    }\n                }\n\n\n                //neghtbours\n                for(int i =min(iFrame,0);i<4;i++){\n                    for(int n=0;n<LANES;n++){\n                        vec3 ncoord =nextCoord(c,i,b.btype);\n                        vec4 ndata = CELL(coord2buffer(ncoord)); \n                        cell nc = decodeCell(ndata,ncoord);\n                        bool show= b.btype!=5 || ((i%2)==1  && j>=th )||  ((i%2)==0  && j< th );\n                        \n                        if(nc.v[n].vtype>0 && show ) {\n                            float npd=vdist(mod(point,1.) - DIRS[i],nc.v[n],float(j) -thr>1.5);\n                            if(pd>npd) {\n                                pd=npd;\n                                brake=nc.v[n].brake;\n                                vtype=nc.v[n].vtype;\n                                #if LANES>1\n                        \t\tlanechange =nc.v[n].lane_out!=n;\n                        \t\t#endif\n                            }\n                        }\n                    }\n                }\n            }\n            }\n             if( pd<.0 ) Q=vec4( (brake||lanechange) && abs(j-thr-1.)<.4 ? vec3(brake&&(!lanechange)?1.:0.,lanechange?1.:0.,0.): VCOLOR[vtype-1]*(j-thr>=1.5?.9:1.)*(pd >-.05?.5:1.),3.+thr);\n\n             //ROAD LIGHTS... TODO should be moved on road sides\n             #if QUALITY>1\n             //else if(j<= thr+10.&& j>= thm && b.btype==4&& abs(point.x-3.05 ) <.1 &&  abs(point.y-3.05 )<.1 )  Q=vec4(j-thr<8.?vec3(.5):vec3(1.,1.,.7),thr+10.);\n  \t          \n\n            //STRIPES            \n  \t        else if(j<= thr+.5 && j>= thm && j<th +.5  && mod(point.y,1.)<.5 && (b.conns&1)>0 &&  abs(point.x-3.05 ) <(zoomView?.03:.15)   &&  point.y>3. + fJun)  Q=vec4(1.,1.,1.,thr+.5);\n            else if(j<= thr+.5 && j>= thm && j<th +.5 && mod(point.y,1.)<.5 && (b.conns&4)>0 &&  abs(point.x-3.05 ) <(zoomView?.03:.15)   &&  point.y<3. - fJun)  Q=vec4(1.,1.,1.,thr+.5);\n            else if(j<= thr+.5 && j>= thm && (j>th -.5 ||j==0.) && mod(point.x,1.)<.5 && (b.conns&2)>0 &&  abs(point.y-3.05 ) <(zoomView?.03:.15)  &&  point.x>3. + fJun)  Q=vec4(1.,1.,1.,thr+.5);\n            else if(j<= thr+.5 && j>= thm && (j>th -.5 ||j==0.) && mod(point.x,1.)<.5 && (b.conns&8)>0 &&  abs(point.y-3.05 ) <(zoomView?.03:.15)   &&  point.x<3. - fJun)  Q=vec4(1.,1.,1.,thr+.5);\n\t\t\t#endif\n             //ASPHALT \n            else if(( j<= thr && j>= thm) || (j==0.&&b.btype==5))\n                Q=vec4(// (isDoubleLane(c.pos,b)?1.:.5)*\n                       vec3(.4)*(j>0. && thr-j>1.?.5:1.) *(.9- (th-thr)/20.) * (UNCONNECTED ?.3:.8),thr);\n            \n            \n\t\t\telse Q=vec4(vec3(0.),j >thm? thr: th-5.);\n\t\t }\n    }\n    return Q;\n}\n\nMain {\n\n    if(RESET<20.) {Q=vec4(0.); return; }//Q=vec4(.4); return;} \n\n    int sel = int(CONF(vec2(2.,0.)).x);\n\n    //if isometric 3d, the tracing is on horizontal slices\n    float dj=2.5;\n    int k=0;\n    block b;\n    b.block_pos=vec2(-100.);\n\n    for(float j =float(!zoomMode && !WIN && !DEMO ?0 : HEIGHT+THEIGHT) ; j>=0. ;j-=dj){\n\n        //SETUP VIEW---------------------\n        vec2 P= (U -SHIFT_VIEW)/ ZOOM; \n        if( U.x>R.x*ZX || WIN || DEMO)  {\n            P=position(U,float(j));\n        } \n\n        //BLOCK VARIABLES----------------------      \n        vec2 P0 = floor(P)+.5; //position center\n        vec3 coord= buffer2coord(P0);\n        vec3 bcoord= vec3( coord.xy,0.); \n\n        //OPTIMIZATION #3\n        if(length(b.block_pos-coord.xy)>.5)  \n            b = decodeBlock(BLOCK(coord2buffer(bcoord)),bcoord.xy); //CURRENT BLOCK\n        \t//if(b.btype==5 ) b.conns &= 10; //overpass down\n        \t//if(b.btype==6 ) b.conns &= 5; //overpass up\n\n\n        //OPTIMIZATION #1     \n        if(j<= float(b.th)  + (b.btype==0 && b.ltype>0 ? float(b.bh)+5.:HEIGHT_MARGIN)) {\n            k++;\n            Q= map(P,j,b,zoomMode|| WIN || DEMO);\n            float th=Q.w;\n            //if(k>30) Q*=.2;\n\n            //HIGHLIGHT\n            vec2 m =  CONF(vec2(0.,0.)).xy;\n            if( !DEMO && U.x< R.x*ZX &&   length(buffer2coord(  (m )/ZOOM +.5).xy-bcoord.xy )<1. )  Q+= sel==4|| sel==5 ? vec4(1.,0.,0.,0.): vec4(0.,1.,0.,0.);\n\n            if(th>= float(j)) { \n                break;\n            };\n\n\n            dj=2.5;\n            #if QUALITY>0           \n            if(j <= th+10.) dj=.5;\n            if(j <= th+1.) dj=.2;\n            #else\n            if(j > th +10.) dj=2.5;  \n            if(j <= th+5.) dj=1.;         \n            #endif\n        }\n\n\n    } \n\n   Q.rgb =pow( clamp(Q.rgb*.75,0.,1.) , vec3(.6));\n\t\n\n    //DEBUG HEIGHT    \n    //Q=vec4(Q.a/float(THEIGHT+ HEIGHT),mod(Q.a,10.),.5,0.);\n\n\n    #ifdef HELP \n\n    //VERTICAL BAR\n    if(((!WIN && !DEMO )) && abs(U.x-iResolution.x*ZX)<2. ) {Q=vec4(0.);return;}\n\n\n    //INSTRUCTIONS\n    #if QUALITY>0\n    if((DEMO || WIN) && iMouse.z>0. ){\n        if(length(U-vec2(R.x/2.,R.y/3.))<R.x/150.) Q=vec4(1.,0.,0,0.);\n        if(abs(U.x-iResolution.x*ZX)<2.  && abs(iMouse.x-iResolution.x*ZX)<R.x/10.) Q=vec4(0.);\n        if(iMouse.x> R.x*ZX){\n\t        pString( U/R*22. -vec2(17.,20.), int[] (82,79,84,65,84,69));\n            pString( U/R*22. -vec2(17.,19.), int[] (90,79,79,77));\n        }\n        else{\n        \tpString( U/R*22. -vec2(2.,20.), int[] (77,79,86,69));\n        }\n    }else{\n    \tif(iMouse.z>0.  && length(U-vec2(R.x*(ZX*.5+.5),R.y/3.))<R.x/150.) Q=vec4(1.,0.,0,0.);\n    }\n    #endif        \n\n    if(DEMO){\n        #if QUALITY>0\n        if(RESET<100.) pString( U/R*22. -vec2(7.5,1.), int[] (80,82,69,83,83,32,83,80,65,67,69));\n        #endif\n    }else{\n        //COUNTER\n        vec4 c= CONF(vec2(1.,0.));\n        //CARS\n        if(c.g>0.){\n            pString( U/R*22. -vec2(16.,19.), int[] (67,65,82,83,58));\n            if(pInt(5., U/R*22. -vec2(19.,19.),(c.g ) ).x >0.4) Q=vec4(1.,1.,0.,0.); \n        }\n\n\n        //WIN\n        if(GAME){\n            if(c.b<1. && c.g<1.){\n                U.x+=  (-1.+ mod(iTime/3.,2.))*R.x;\n                pString( U/R*3. -vec2(1.,1.), int[] (64+23,64+9,64+14));\n            }else {\n                if(c.b>0.){\n                    Q += char(U/R*11. -vec2(8.,10.) ,29   ).x;\n                    Q +=pInt(2., U/R*11. -vec2(9.,10.),(100.- c.b/c.r*100. ) ).x; \n                    Q += char(U/R*11. -vec2(10.2,10.) ,37   ).x;\n            }\n        }\n    }\n        vec4 Q0=Q;\n        if(sdBox(U/R*20. -vec2(10.*ZX,.6 ),vec2(10.*ZX -.2 ,.4 ))<0. &&!keyToggle(CH_CAPS) ){\n            Q= vec4(1.);\n\n            vec4 C=vec4(1,.5,.5,1);\n            if(abs(floor(U.x/R.x/(ZX-.1)*4.5 +.8*(ZX/.7))-float(sel))<.5) C=vec4(.5,1.,.5,1);\n            pStringC( U/R*20.*vec2(.7/ZX) -vec2(1.,.1), int[] (82,79,65,68,32, //ROAD\n                                                               83,69,77,65,32, //SEMA\n                                                               82,79,85,78,32, //ROUN\n                                                               66,85,73,76,32, //BUIL\n                                                               71,82,65,83     //GRAS\n                                                              ),C);\n\n            if(Q.x>1.) Q-=vec4(1.,1.,1.,1.);else Q=mix(Q0,Q,.3);\n        }\n        \n      \n    }\n    #endif    \n\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*   POSITIONS\n5\t11\t17\t23\t29\t35\n4\t10\t16\t22\t28\t34\n3\t9\t15\t21\t27\t33\n2\t8\t14\t20\t26\t31\n1\t7\t13\t19\t25\t31\n0\t6\t12\t18\t24\t30\n--------------*/\n\n\n    \n    //ROUTING\n\nvec2  next_(vec2 point, in block b,bool turn){\n    \n    //block position is always excluded\n\tif( abs(point.x-.5) <.5 && abs(point.y-.5)<.5) return vec2(0.);\n     \n    vec2 d = (vec2(point.x-3.,point.y-3.));\n    \n    float dm=max(abs(d.x),abs(d.y));\n          \n\n    // CROSS   \n    if(b.btype==1  ){\n        //TURN DIRECTION\n        if(turn==true){\n        \tif(abs(point.x-4.5) <.5 && abs(point.y-2.5)<.5 && (b.conns&2)>0) return vec2(1.,2.);\n            if(abs(point.y-4.5) <.5 && abs(point.x-3.5)<.5 && (b.conns&1)>0) return vec2(0.,2.);\n            if(abs(point.x-1.5) <.5 && abs(point.y-3.5)<.5 && (b.conns&8)>0) return vec2(3.,2.);\n            if(abs(point.y-1.5) <.5 && abs(point.x-2.5)<.5 && (b.conns&4)>0) return vec2(2.,2.);\n        \n        }\n        // DEFAULT DIRECTION\n        else{\n            if( (abs(point.x-3.5) <1.5 && abs(point.y-4.5)<.5 ) || (abs(dm-2.5) <.5 && abs(d.y-.5)<.5 )) return vec2(3.,15.);   \n            if( (abs(point.x-4.5) <.5 && abs(point.y-2.5)<1.5)  || (abs(dm-2.5) <.5 && abs(d.x-.5)<.5 ))return vec2(0.,15.);\n            if( (abs(point.x-2.5) <1.5 && abs(point.y-1.5)<.5)  || (abs(dm-2.5) <.5 && abs(d.y+.5)<.5 ))return vec2(1.,15.);\n            if( (abs(point.x-1.5) <.5 && abs(point.y-3.5)<1.5)  || (abs(dm-2.5) <.5 && abs(d.x+.5)<.5 )) return vec2(2.,15.);\n        }\n    }\n    //SEMAPHORE\n    if(b.btype==2 && turn==true){\n        int pos= 1+int(floor(mod(point.x, BLOCK_BUFFER.x))* BLOCK_BUFFER.x +floor(mod((point.y-1.), BLOCK_BUFFER.y)));\n    \tint k=100;//set to 0 to enable left turn\n        if((pos==14+k || (pos==20 && (b.conns&2)>0)) && b.semaphore==0) return vec2(1.,2.);\n        if((pos==21+k || (pos==15 && (b.conns&8)>0))  && b.semaphore==0) return vec2(3.,2.);\n        if((pos==20+k || (pos==21 && (b.conns&1)>0)) && b.semaphore==1) return vec2(0.,2.);\n        if((pos==15+k || (pos==14 && (b.conns&4)>0)) && b.semaphore==1) return vec2(2.,2.);\n\n    }\n    \n    //JUNCTION\n\tif((b.btype==4 || b.btype==2 || b.btype==5 || b.btype==6)&& turn==false){ \n        \n\n        \n        bool central = (abs(dm) <1.);\n        if(b.btype==2 && central){\n       \t\t if(b.semaphore>0) b.conns &= 10; else b.conns &= 5;\n   \t\t}\n        \n        \n        //OVERPASS\n\n        float shift_out = 0.;\n        if(b.btype==5){                    \n        \tif( central ) b.conns &= 10; //overpass down              \n            int pos= 1+int(floor(mod(point.x, BLOCK_BUFFER.x))* BLOCK_BUFFER.x +floor(mod((point.y-1.), BLOCK_BUFFER.y)));\n   \t\t\t\n            if(pos==25 || pos==28) return vec2(0.,15.);  //overpass up\n            if(pos==7 || pos==10) return vec2(2.,15.);  //overpass up\n        }\n\n        \n        //UP\n        if(abs(point.x-3.5)<.5 &&(\n            ( (b.conns&1)>0 && abs(point.y-5.)<1.  )  \n            ||( (b.conns&4)>0 && abs(point.y-1.)<1.  )  \n            ||( (b.conns&2)==0 && abs(point.y-2.5)<.5  )  \n            ||( (b.conns&1)==1 && abs(point.y-3.5)<.5  )  \n        )) return vec2(0.,15.);\n\t\t//DOWN\n         if(abs(point.x-2.5)<.5 &&(\n            ( (b.conns&4)>0 && abs(point.y-1.)<1.  )  \n            ||( (b.conns&1)>0 && abs(point.y-5.)<1.  )  \n            ||( (b.conns&8)==0 && abs(point.y-3.5)<.5  )  \n            ||( (b.conns&4)==4 && abs(point.y-2.5)<.5  )  \n        )) return vec2(2.,15.);\n        //RIGHT\n        if(abs(point.y-2.5)<.5 &&(\n            ( (b.conns&2)>0 && abs(point.x-5.)<1.  )  \n            ||( (b.conns&8)>0 && abs(point.x-1.)<1.  )  \n            ||( (b.conns&4)==0 && abs(point.x-2.5)<.5  )  \n            ||( (b.conns&2 )==2 && abs(point.x-3.5)<.5  )  \n        )) return vec2(1.,15.);\n        //LEFT\n        if(abs(point.y-3.5)<.5 &&(\n            ( (b.conns&2)>0 && abs(point.x-5.)<1.  )  \n            ||( (b.conns&8)>0 && abs(point.x-1.)<1.  )  \n            ||( (b.conns&1)==0 && abs(point.x-3.5)<.5  )  \n            ||( (b.conns&8 )==8 && abs(point.x-2.5)<.5  )  \n        )) return vec2(3.,15.);\n        \n    }\n    \n    return vec2(0.);\n\n    \n}\nvec2  next(int pos, in block b,bool turn){\n    vec2 point=  vec2(\n         floor(float(pos)/BLOCK_BUFFER.x),\n         floor(mod(float(pos),BLOCK_BUFFER.x)) \n    ) +.5;\n    return  next_(point,  b, turn);\n}\n\ncell nextCell(cell c, int i , int btype){\n    vec3 ncoord = nextCoord(c,i,btype); \n    vec4 ndata = CELL(coord2buffer(ncoord));       \n    return decodeCell(ndata,ncoord); \n}\n\n\n\n//STOP\nbool stop(block b, cell c){\n    if(b.btype==2 && b.semaphore==1 && (c.pos==16 || c.pos==117 || c.pos==118 || c.pos==19 ) ) return true;\n    if(b.btype==2 && b.semaphore==0 && (c.pos==102 || c.pos==8 || c.pos==27 || c.pos==133 ) ) return true;\n    return false;\n}\n\n\nbool isShift(in block b, int pos){\n    if(b.btype==5 &&  (pos==7 || pos==10 || pos==25 || pos==28 ) ) return true;    \n\treturn false;\n}\n\n\nMain {\n    \n \tQ =vec4(0.);\n \n\tvec3 coord = buffer2coord(U);\n    vec3 bcoord= vec3( coord.xy,0.);\n    \n      \n    \n    //discard texels outside view\n    if(coord.x>=BMAX.x || coord.y>= BMAX.y) { return;}\n    \n    //reset:\n    if (iFrame<2 || TS.x != CONF(vec2(0.)).z\n\t\t|| (RESET <2. && (DEMO|| WIN))\n       ){\n        \n        \n\n       \tint ltype= int(.8+ fbm_noise(100. + bcoord.xy/30.+iTime*100.,2))*2;\n        int btype=min(int(.5 + hash(U +iTime)*(ltype==2?1.8: .7)),1)*4;\n       \n     \n        if(isBlockCoord(coord)){\n            \n            float thp=float(THEIGHT+5) * (1.- length(coord.xy -vec2(BMAX/2.)) /length(BMAX/2.)  );\n             int th=  max(0, -5+ int(fbm_noise(bcoord.xy/15.+iTime*100.,2)*thp));\n\t\t\t\t\n            th= int(float(th+6)/10.)*10;\n            \n            if(mod(coord.x,2.)+mod(coord.y,2.)<.5)  btype= 0;     \n            \n            if(th<=1) {btype=0; ltype=0;}\n            \n            int bh= 50+ int(floor(hash(bcoord.xy)*float(HEIGHT-50)/10.)*10.);\n            \n            float ctr=sdBox(bcoord.xy-vec2(8.),vec2(.5));\n            if(ctr<=0.) {\n                ltype=3;\n                btype=0;\n                bh=HEIGHT;\n                th=max(th,10);\n            }\n            else if(ctr<=1.) {btype=1;}\n            \n        \tblock b = newBlock(coord,btype,ltype,bh,th);\n            \n            Q= encodeBlock(b);\n        \n        }       \n        else {\n            \n            vehicle empty0 = newVehicle(0, 0.,0. ,vec2(0.),0,0,0);\n            vehicle empty1 = newVehicle(0, 0.,0. ,vec2(0.),0,0,0);\n            cell c = newCell( coord, false,false, vehicle[LANES] (empty0\n                                                            #if LANES>1\n                                                            ,empty1\n                                                            #endif\n             ));\n            \n            for(int n=0;n<LANES;n++){\n                if(hash(U*float(n+2))<VEHICLE_DENSITY) {\n                     c.v[n] = newVehicle(\n                        LANES>1 ? n+1:int(1.5+ hash(U*5.)*1.4),\n                        3./  VSTEP,\n                        -.52,\n                        vec2(vec2(mod(U.x , BMAX.x), mod(U.y ,  BMAX.y))),\n                        0,\n                        0,\n                         n\n                        );\n\n                }\n            }\n        \t//packing\n            Q= encodeCell(c);\n        }\n        \n    \n    } else if(U.y>0.5){\n        \n        Q = BLOCK(U);\n        \n        block b = decodeBlock(BLOCK(coord2buffer(bcoord)),bcoord.xy);\n        \n        int sel = int(CONF(vec2(2.,0.)).x);\n        \n        //block logic\n        if(isBlockCoord(coord)){\n            \n\n            //mouse ACTIONS\n            vec3 mcoord=buffer2coord(  (MOUSE_INPUT-SHIFT_VIEW) /ZOOM +.5);\n            vec2 mcoords= buffer2point( (MOUSE_INPUT-SHIFT_VIEW) /ZOOM +.5)-vec2(3.);\n            int mdir =abs(mcoords.x)>abs(mcoords.y)?(mcoords.x>0.?2:8):(mcoords.y>0.?1:4);\n            if(!keyToggle(CH_CAPS) && !DEMO &&!WIN  && !zoomMode  &&b.ltype!=3) \n            { \n                \n                float l= length(mcoord.xy-bcoord.xy );\n                \n                if(l<2.&&sel==5 && iMouse.z>0.){\n                    int thd=0;\n                    if(keyDown(CH_SH)) thd+= 6 -int(l*3.);\n                    if(keyDown(CH_CTRL)) thd-= 6 -int(l*3.);\n                \t b.th =clamp( b.th + thd,0,THEIGHT);\n                }\n                \n                if(l<1.){\n                    if(sel==5) { b.btype= 0; b.ltype=0;b.dist=MAX_DIST;b.aconns=15;}\n                    else if(sel==4) {b.btype= 0; b.ltype=2;b.dist=MAX_DIST; b.aconns=15;}\n                    else if(sel==3) {b.btype=1; b.aconns=15;}\n                    else if(sel==2)  {b.btype=2; b.aconns=15;}\n                    else {\n                        \n                        if(keyDown(CH_CTRL)) b.aconns = b.aconns & (15-mdir);\n                        else if(!keyDown(CH_SH) && (b.conns&1) + (b.conns&2)/2 + (b.conns&4)/4 + (b.conns&8)/8 >=3 ) {b.btype=1; } \n                        else {b.btype=4;}\n                    }\n                }\n            }\n            \n\n            \n            \n        \t//connections:\n        \tint conX =0,conY=0, conns=0 , dmin=MAX_DIST,dir=0,buildings=0,th=0;\n            for(int i=0;i<4;i++){\n            \tvec3 nbCoord=vec3(coord.xy + DIRS[i], coord.z);\n                if(nbCoord.x>=0. && nbCoord.x< BMAX.x && nbCoord.y>=0. && nbCoord.y< BMAX.y){\n                    block nb = decodeBlock(BLOCK(coord2buffer(nbCoord)),nbCoord.xy);\n                    int bit =int(pow(2., float(i))), bitn=int(pow(2., float( (i+2)%4))) ;\n                    if ((b.aconns & bit )> 0 && (nb.aconns&bitn)>0){\n                        if((nb.btype>0  )  && i%2==0) conY++;\n                        if((nb.btype>0 ) && i%2==1) conX++;\n                        if(nb.btype>0 || nb.ltype==3 ) conns +=  bit;// 1>>i;\n                        if(nb.btype==0 && nb.ltype>0 ) buildings +=1;\n                    }\n                    if(nb.dist<dmin) {dmin= nb.dist;dir=i;}\n                    \n                    \n                    //max th\n                    if(int(mod(bcoord.x,2.))==0 && int(mod(bcoord.y,2.))==0 ) {\n                        th=b.th;\n                    }\n                    else th=max(th,nb.th); \n\t\t\t\t\t\n                    \n                } \n            }\n            #if QUALITY>1\n            if(b.btype==0 && b.ltype==2 && th>b.bh) b.bh=th+40;\n            if(b.btype==0 && b.ltype==2 && th<1) b.ltype=0;\n            #endif\n            \n            //DISTANCE FROM CENTER\n            if(b.ltype==3 ) b.dist=!DEMO?0:MAX_DIST;\n            else if( dmin< b.dist && b.btype>0 ){b.dist=dmin+1; b.dir=dir;}\n            else if( b.dist<  dmin ){ b.dist =MAX_DIST;}\n            \n            //if(mod(coord.x,2.)+mod(coord.y,2.)<.5) b.btype=0; else \n            \n            \n            if( RESET <5. ){\n                if(conX+conY<1 && b.btype!=0 ) b.btype=0;\n                if(conX+conY==1  && b.btype!=0  && buildings==0 ) b.btype=0; \n                if(conX+conY==3 &&  b.btype!=0  ) b.btype=2; \n                else if(conX+conY==4 &&  b.btype!=0  ) b.btype=5;\n                else if(conX+conY==2 &&  b.btype!=0  ) b.btype=4;\n                else if(b.btype!=0 ) b.btype=4;\n            }\n            b.conns=conns;\n            \n            //semaphore-->OVERPASS\n            if(b.btype==5 && b.conns<15){\n            \tb.btype==2;\n            }\n            if(b.btype==2 && b.conns==15){\n            \tb.btype=5; \n\n            }\n\n            \n             //SEMAPHORE switch every 5 secs\n            if(b.btype==2){\n            \tb.semaphore = int(mod(iTime/5. +hash(coord.xy*7.),2.));\n            }\n                \n                \n\t\t\t//COUNTER\n            b.counter=0.;\n            for(float k=1.;k<36.;k++){\n            \tvec3 vcoord =vec3(coord.xy,k);\n        \t\tvec4 vdata = CELL(coord2buffer(vcoord));\n        \t\tcell c = decodeCell(vdata,vcoord);\n                for(int n=0;n<LANES;n++){\n                    bool carCounter= GAME?c.v[n].vtype==1: c.v[n].vtype>0;\n                \tif(carCounter &&c.road)b.counter+=1.;\n                }\n            }     \n                \n            Q= encodeBlock(b);\n                \n                \n        }\n        //vehicle logic\n        else{\n            //unpacking\n            cell c = decodeCell(Q,coord);\n            \n            \n            c.road=isRoad( b,  c.pos);          \n            c.shift=isShift( b,  c.pos);\n                     \n\n\t\t\tvehicle empty0 = newVehicle(0, 0.,0. ,vec2(0.),0,0,0);\n            vehicle empty1 = newVehicle(0, 0.,0. ,vec2(0.),0,0,1);\n            \n\t\t\t//clean vehicles outside road\n            if(!c.road && !c.shift ) c = newCell( coord, false,false, vehicle[LANES] (empty0\n                                                                    #if LANES >1\n                                                                    ,empty1\n                                                                    #endif\n           ));\n                      \n            else for(int n=0;n<LANES;n++){\n                \n             \n                if(c.v[n].vtype>0 ) {\n                \n                    c.v[n].brake=false;\n                    //next direction (initialization)\n                    if(c.v[n].offset <=-.5){\n                        vec2 nx =next(c.pos,b,false);\n                        if(nx.y>0.) {c.v[n].dir_out=int(nx.x); }\n\n                        vec2 nx2 =next(c.pos,b,true);\n                        if(nx2.y>0.  ) {c.v[n].dir_out=int(nx2.x); nx=nx2;}\n                    }\n\n\t\t\t\t\t\n                    cell nc = nextCell(c,c.v[n].dir_out,b.btype);\n                    #if LANES>1\n                    // in every momenty, revert lane change if other lane is busy\n                    if(c.v[n].lane_out!= n && c.v[1-n].vtype>0) c.v[n].lane_out=n;\n                    \n                    int n_out = c.v[n].lane_out;\n                    #else\n                    int n_out =n;\n                    #endif\n                    \n\t\t\t\t\t//check vehicle in same target  lane of next cell\n                    float dist =(nc.v[n_out].vtype==0) ? ACC_DIST : (1.+ nc.v[n_out].offset-c.v[n].offset +nc.v[n_out].vel- c.v[n].vel);                \n \t\t\t\t\t\n                        \n                    #if LANES >1\n                     \n                        \n                    int n2 = 1- n;\n                    int n_ch = 1- c.v[n].lane_out;\n                    \n                    //check distance of vehicle changing line in the next cell\n                    float dist2 =(nc.v[n2].vtype==0 || nc.v[n2].lane_out!=n_out ) ? ACC_DIST : (1.+ nc.v[n2].offset-c.v[n].offset +nc.v[n2].vel- c.v[n].vel);                \n          \t\t\t// distance on alternate lane\n                    float dist_ch =(nc.v[n_ch].vtype==0) ? ACC_DIST : (1.+ nc.v[n_ch].offset-c.v[n].offset +nc.v[n_ch].vel- c.v[n].vel);                \n    \n                    dist=min(dist,dist2);\n                    dist_ch=min(dist_ch,dist2);\n                    \n                    #endif\n\t\t\t\t\t\n                    vec2 nx1 =next(nc.pos ,b,false);\n                                      \n                    \n                    //precedence of from other cells\n                    for(int i =0;i<4;i++){\n\n                       cell nc2 =nextCell(nc,i,b.btype);\n                        \n                        //check vehicle on cells with precedence\n                        if(nc2.road && nc2.v[n].vtype>0 \n                           && abs( nc2.v[n].dir_out -i)==2 \n                           && c.v[n].dir_out!=nc2.v[n].dir_out\n                           && int(nx1.x) == nc2.v[n].dir_out\n                          \n                          ) dist=-1.; //  brake if an incoming car (same lane)has precedence over next cell/lane\n\n                        #if LANES >1     \n                        if(nc2.road && nc2.v[n2].vtype>0 \n                           && abs( nc2.v[n2].dir_out -i)==2 \n                           && c.v[n].dir_out!=nc2.v[n2].dir_out\n                           && int(nx1.x) == nc2.v[n2].dir_out\n                           //&& nc2.v[n2].lane_out==n // c.v[n].lane_out\n                           \n                          ) dist=-1.; // brake if an incoming car  (other lane) has precedence over next cell/lane\n                        \n                        //collision with other lane (only in semaphere and roundabout)\n                        if(c.v[n2].vtype>0  &&(b.btype==1 && b.btype==2) && n==1 && c.v[n2].dir_out== ((c.v[n].dir_out+1)%4) ) dist=-1.;\n                        #endif\n                    \t\n  \n                    }\n                    \n                    \n                    #if LANES >1            \n                    if( \n                        c.v[n].offset <=-.4 \n                       && ((dist<=DEC_DIST &&  dist_ch>DEC_DIST) //begin passing \n                       //|| (dist_ch>= ACC_DIST   && n==1) ) //end passing\n                       )\n                       //&& c.v[n].vtype==1\n                      ){\n                        \n                        float dist_inc=ACC_DIST;\n                        for(int i =min(iFrame,0);i<4;i++){\n\n                        \tcell pc = nextCell(c,i,b.btype);\n                            //incoming vehicle distance\n                        \tif(pc.v[n2].vtype>0 && abs(nc.v[1-n].dir_out -i)==2 )\n                    \t\t\t dist_inc = min (dist_inc, 1.- nc.v[n2].offset+c.v[n].offset -nc.v[n2].vel+ c.v[n].vel);                \n\n                         }\n                        \n                        \n                        //other line is free\n                        if(c.v[n2].vtype==0 && c.v[n].lane_out==n && dist_inc>=ACC_DIST){\n                        \tc.v[n].lane_out=n2;\n                            dist=dist_ch;\n                        }\n                        //change idea...\n                        else {\n                        \tc.v[n].lane_out=n;\n                            dist=dist_ch;\n                        }                              \n                    } \n                    #endif\n                   \n                    \n\t\t\t\t\t\n                     if(dist < DEC_DIST || stop(b,c) ) {\n                         \n                        c.v[n].vel=  clamp(c.v[n].vel-1./VSTEP,0.,3./VSTEP)  ;\n                        c.v[n].brake=true;\n                    } \n                    \n                    \n                    else if(dist >=ACC_DIST){\n                        float vmax= VMAX[c.v[n].vtype-1];\n                        if(n==1) vmax+=1.;\n                        c.v[n].vel = clamp(c.v[n].vel+1./VSTEP,1.,vmax/VSTEP)  ;\n                    }\n\n                    //update offset                          \t                \n                    c.v[n].offset += c.v[n].vel;\n\n                    //vehicle leaving cell\n                    if(c.v[n].offset>=.5) {\n                        c.v[n].offset=-.5;c.v[n].vel=1./VSTEP;\n                        c.v[n] = newVehicle( 0, 0.,0. ,vec2(0.),0,0,n);\n                        c.road= !c.shift;\n\n                    };\n\n\n                }\n\n \t            else if(c.v[n].vtype==0){ \n                    //incoming vehicles   \n                    for(int i =min(iFrame,0);i<4;i++){\n\n                        cell nc = nextCell(c,i,b.btype);\n                        bool incoming=false;\n                            #if LANES >1\n                                int nlane_out=nc.v[n].lane_out;\n                            #else\n                                int nlane_out=n;\n                            #endif\n                        if(nc.v[n].vtype>0 && nlane_out==n && nc.v[n].offset+nc.v[n].vel>=.5 && abs(nc.v[n].dir_out -i)==2 ){\n\n                                c.v[n].vtype=nc.v[n].vtype;\n                                c.v[n].offset=nc.v[n].offset+nc.v[n].vel -1.;\n                                c.v[n].vel=nc.v[n].vel;\n                                c.v[n].dir_in= i;\n                            \t\n                            #if LANES>1\n                            \tc.v[n].lane_out=n;\n                            #endif\n                            \tincoming=true;\n                         }\n#if LANES >1\n                        // incoming vehicle with line change\n                        if(!incoming && nc.v[1-n].vtype>0 && nc.v[1-n].lane_out==n && nc.v[1-n].offset + nc.v[1-n].vel>=.5 && abs(nc.v[1-n].dir_out -i)==2 ){\n\n                                c.v[n].vtype=nc.v[1-n].vtype;\n                                c.v[n].offset=nc.v[1-n].offset+nc.v[1-n].vel -1.;\n                                c.v[n].vel=nc.v[1-n].vel;\n                                c.v[n].dir_in= i;\n                            \tc.v[n].lane_out=n;\n                            \tincoming=true;\n                         }\n#endif\n                                \n                         if(incoming==true){\n                                //next direction                          \n                                vec2 nx =next(c.pos,b,false);\n\n                                //default direction\n                                if(nx.y>0.) {c.v[n].dir_out=int(nx.x); }\n\n                                //turn direction (if allowed)\n                                vec2 nx2 =next(c.pos,b,true);\n                                //connected... turn only if direction to destination\n                                if(nx2.y>0. && b.dist<MAX_DIST  &&nc.v[n].vtype== 1){\n                                   if( int(nx2.x)==b.dir ) {c.v[n].dir_out=int(nx2.x); nx=nx2;}\n                                }\n                                //else turn randomly \n                                else if(nx2.y>0. && hash(iTime +U)> TURN ) {c.v[n].dir_out=int(nx2.x); nx=nx2;}\n              \n                         }\n                    }\n                   \n    \n            \t}\n             \n        \t}\n            //packing\n            \n            Q= encodeCell(c);\n        }\n   \n    } else {\n    //COUNTERS\n    \n        int sh = int(mod(U.x -.5,BLOCK_BUFFER.x));\n        Q=vec4(0.); //r=?,g=?, b=unconnected,a=?\n                \n\n         if(sh==1){\n            vec3 coord = buffer2coord(U+vec2(-1.,1.));\n\n            //subtotal over columns\n            for(float k=  -1.;k<BMAX.y;k++){\n                vec3 nbCoord=vec3(coord.xy +DIRS[0]*k, coord.z);\n                block nb = decodeBlock(BLOCK(coord2buffer(nbCoord)),nbCoord.xy);\n\n                Q.g += nb.counter;\n\t\t\t\tif(nb.th>=1 && ( nb.btype>0  || (nb.ltype==2 && nb.btype==0))) Q.r+=1.;\n                if(nb.th>=1 && nb.conns==0 && nb.ltype==2 && nb.btype==0) Q.b +=1.;\n                if(nb.th>=1 && nb.btype>0 && nb.dist>=MAX_DIST) Q.b +=1.;\n            }\n\n            //total over rows\n            if(U.x <6.)for(float k=1.;k<BMAX.x+1. ;k++){\n                Q +=CONF(U + vec2(BLOCK_BUFFER.x,0)*k );\n            }\n        } \n        else if( U.x <6. && sh==2){\n            \n            //MOUSE POSITION\n            \n            if(sdBox(iMouse.xy/R*20. -vec2(10.*ZX,.6 ),vec2(10.*ZX -.2 ,.4 ))<0.)             \n            Q.x= floor(iMouse.x/R.x/(ZX-.1)*4.5 +.8*(ZX/.7));\n            else Q.x=max(CONF(vec2(2.,0.)).x,1.);\n            \n            Q.y= 0.;// keyToggle(CH_SPACE)?1.:0.;\n            Q.z=  mod((iMouse.x>R.x*ZX)?((iMouse.x-R.x*ZX)/(R.x*ZX) *3.14*2.) : (iMouse.x<1.? iTime/4.:3.4),6.28);           \n            Q.w= clamp(RESET<5.? 1.5:  (iMouse.x>R.x*ZX)? iMouse.y/R.y:.3,.0,10.);\n        }\n        else if( U.x <6. && sh==3){\n            \n            \n            //SMOOTH CAMERA POSITION\n            //xy=position, z=rotation w= zoom \n             \n            \n            float mx =  RESET<5.  ?1.: clamp(1./iFrameRate,0.,1.); //(iFrameRate>10.?.07:.15) ;                  \n            Q.xy=mix(CONF(vec2(3.,0.)), CONF(vec2(0.,0.)),mx).xy;\n            \n            float rz1=CONF(vec2(3.,0.)).z, rz2= CONF(vec2(2.,0.)).z;\n            //if(abs(rz1-rz2)>6.28) {mx=1.;}\n            \n            if(rz2<rz1  && rz1-rz2>3.14) {rz2=rz1+.5; }\n            \n            Q.z= mod(mix(rz1, rz2,mx),6.28); \n            Q.w=  mix(CONF(vec2(3.,0.)), CONF(vec2(2.,0.)),mx).w;\n        }\n    }\n    \n    // save CURRENT TEXTURE SIZE\n    if(max(U.x,U.y)<1.) {\n        Q= vec4(\n            iMouse.x<1. || RESET<5.? R/4.: iMouse.x>iResolution.x*ZX? CONF(U).xy: iMouse.xy-SHIFT_VIEW,\n            TS.x, \n            iFrame==0 || TS.x != CONF(vec2(0.)).z || ( keyDown(CH_SPACE) ) ? float(iFrame):CONF(vec2(0.)).w);\n    } \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//SETTINGS\n#define QUALITY 2 //0=LOW,1=MEDIUM, 2=HIGH\n#define MIN_ZOOM 3. //minimum zoom (for small resolutions)\n#define CITY_SIZE 30. //20 small 40 medium 100 big\n#define LANES 1 //1 = sigle lane, 2 = double lane (takes up to 40s compilation time)\n\n#define VEHICLE_DENSITY 0.5 //0.=no traffic 1.= full\n#define ZOOM2H 5. // horizontal zoom for right panel\n#define ZOOM2V (3. *ZOOM/6.) // vertical zoom for right panel\n#define HEIGHT 80 //max building height\n#define THEIGHT 120 // max terrain height (-5 water level)\n#define VMAX float[2] (5.,3.) // max speed by vehicle type\n#define VCOLOR vec3[2] (vec3(1.,1.,0.) ,vec3(0.,.2,1.)) // color by vehicle type\n#define ACC_DIST 1.8 // higher value: less reactive cars\n#define DEC_DIST 1.7 //lower values causes vehicle crashes and disappereance\n#define TURN 0. //0.= always (no congestions) , 1.= never (high congestions)\n#define HEIGHT_MARGIN 25.\n#define HELP  //+1s compilation time...\n\n\n\n//DEBUG\n#define DEBUG 0 // set to 1 to display debug colors\n#if DEBUG>0\n    #define ALERT_COLOR vec3(0.,1.,1.)\n    #define DEBUG_COLOR vec3(.3,0.,0.)\n    #define DEBUG_COLOR2 vec3(.5,0.,0.)\n#endif\n\n\n//INTERNAL\n#define CH_Z 90  \n#define CH_SPACE 32\n#define CH_SH 16\n#define CH_CAPS 20\n#define CH_CTRL 17\n//#define CH_ALT 18\n#define keyDown(k) (texelFetch(iChannel1, ivec2(k,0), 0).r>.5)\n#define keyPress(k) (texelFetch(iChannel1, ivec2(k,1), 0).r>.5)\n#define keyToggle(k) (texelFetch(iChannel1, ivec2(k,2), 0).r>.5)\n#define DEMO  !keyToggle(CH_SPACE)\n#define GAME !keyToggle(CH_CAPS) //false to disable connection counters \n#define zoomMode  (!DEMO && !keyToggle(CH_Z) &&  U.x > iResolution.x*(!WIN?ZX:0.))\n#define CITY_SIZE2  CITY_SIZE //(DEMO?15.:CITY_SIZE)\n#define R iResolution.xy\n#define ZOOM max(MIN_ZOOM, (R.y)/6./(CITY_SIZE2) ) //zoom factor for left panel\n#define VP 5.\n#define VSTEP pow(2.,VP)\n#define BLOCK_BUFFER vec2(6.,6.)\n#define ZX .5 // split screen ratio from 0 to 1 (.3= big preview, .7=small preview )\n#define BMAX floor(iResolution.xy/BLOCK_BUFFER/ZOOM*vec2(ZX,1.) -2.)\n#define OSTEP VSTEP\n#define MAX_DIST min((1<<10)-2,int(CITY_SIZE*3.))\n#define UNCONNECTED (GAME &&  b.dist>=MAX_DIST)\n#define SHIFT_VIEW vec2(3.,R.y/20. )\n#define MOUSE_INPUT  iMouse.xy\n#define RZ (R/ZOOM)\n#define Main void mainImage(out vec4 Q, vec2 U) \n#define CELL(U) texelFetch(iChannel0, ivec2(U), 0) //texture(iChannel0,(U)/R)\n#define BLOCK(U) texelFetch(iChannel0, ivec2(U ), 0) //texture(iChannel0,(U)/R)\n#define CONF(U) texelFetch(iChannel0, ivec2(U ), 0) //texture(iChannel0,(U)/R)\n#define WIN (CONF(vec2(1.,0.)).b<1. && CONF(vec2(1.,0.)).g<1. && GAME)\n#define TS vec2(textureSize(iChannel0,0))\n#define RESET abs(float(iFrame)-max(CONF(vec2(0.)).w,0.)) \n\n#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits    \nconst vec2 DIRS[4] = vec2[] (vec2(0,1), vec2(1,0),vec2(0,-1) ,vec2(-1,0));  \nconst float PI = 3.14159265359;\n\n//iq\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n//Hash/noise utils (copied from others)\nfloat hash(in float x) { return fract(sin(x*.0007)*29835.24389); }\nfloat hash(in vec2 x) { return hash(dot(x,vec2(23.17,17.23))); }\nvec2 hash22( vec2 p ) { float t = hash(p);\treturn vec2( t,hash(t)); }\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\nfloat fbm_noise(vec2 uv, int steps) {\n\tfloat v = 0.;\n    for(int i = 0; i < steps; i++){\n        float factor = pow(2.,float(i + 1)) / 2.;\n    \tv += snoise(uv * factor) / factor;\n    }\n    return v / ((pow(.5,float(steps))- 1.) / -.5);\n}\n \n     \n//CELL-VEHICLE\nstruct vehicle {\n\n    //V1\n    int vtype; //2 bit 0=none 1=car,2=slowcar \n    int dir_in; // 0..3 DIRS[i]\n    int dir_out;   // 0..3 DIRS[i]     \n\tfloat offset; // -.5 ... +.5\n\tfloat vel; // 0. ...  +1.\t\n    bool brake; \n    int lane; //lane\n    #if LANES>1\n    int lane_out;\n    #endif\n};\n \nvehicle newVehicle( int vtype,float vel, float off, vec2 tg , int di, int dout,int lane){\n    vehicle o;\n\n    o.vtype=vtype; \n    o.dir_in= di ;\n    o.dir_out=dout;\n\to.offset= off; \n\to.vel=vel; \n    o.brake=false;\n    o.lane=lane;\n    #if LANES>1\n    o.lane_out=lane;\n    #endif\n    return o;\n}\n\n\nstruct cell {\n    vec2 block_pos; // block xy  (not persistent)\n    int pos; //  (not persistent)\n    bool road;\n    bool shift;\n    \n\tvehicle[LANES] v;  //vehicles (max 2)\n    \n    \n};\n \ncell newCell(vec3 coord, bool road,bool shift, vehicle[LANES] v){\n//cell newCell(vec3 coord, bool road, int vtype,float vel, float off, vec2 tg , int di, int dout){\n    cell o;\n    o.block_pos=coord.xy;   \n    o.pos=int(coord.z); \n    o.road=road;\n    o.shift=shift;\n    o.v[0]= v[0];\n    o.v[0].lane=0;\n#if LANES >1    \n    o.v[0].lane_out=0;\n\n    o.v[1]= v[1];\n    o.v[1].lane=1;\n    o.v[1].lane_out=1;\n#endif\n\n    return o;\n}\n\ncell decodeCell(vec4 t,vec3 coord) {\n\tcell o;\n    o.pos=int(coord.z);\n    o.block_pos= coord.xy;\n    \n    //VEHICLES\n    for(int n=0;n<LANES;n++){\n\t\tfloat f = (n==0 ? t.b:t.r);\n        o.v[n].offset= gb(f,0., VP) /pow(2.,VP)  -.51; \n        o.v[n].vel= gb(f,5., VP) /pow(2.,VP);\n        o.v[n].vtype= int(gb(f,10., 2.));  \n        o.v[n].dir_in = int(gb(f,12., 2.));\n        o.v[n].dir_out = int(gb(f,14., 2.));\n        o.v[n].lane=n;\n    }\n    \n\t//CELL\n    o.road=gb(t.a,0., 1.)<.5;\n    o.shift =gb(t.a,1., 1.)<.5;\n    o.v[0].brake=gb(t.a,2., 1.)<.5;\n#if LANES>1\n    o.v[0].lane_out=int(gb(t.a,3., 1.));\n\n    o.v[1].brake=gb(t.a,4., 1.)<.5;\n    o.v[1].lane_out=int(gb(t.a,5., 1.));\n#endif\n    \n    \n    return o;\n}\n\n\nvec4 encodeCell(cell o) {\n\tvec4 t=vec4(0.);\n  \n    //VEHICLES\n    for(int n=0;n<LANES;n++){\n        float f=0.;\n        sb(f,0.,VP,(o.v[n].offset +.51)* pow(2.,VP));\n        sb(f,5.,VP,o.v[n].vel * pow(2.,VP));  \n        sb(f,10.,2.,float(o.v[n].vtype));\n        sb(f,12.,2.,float(o.v[n].dir_in));\n        sb(f,14.,2.,float(o.v[n].dir_out));       \n        if(n==0) t.b=f; else t.r=f;\n    }\n\n    \n    //CELL\n    sb(t.a,0.,1.,o.road?0.:1.);\n    sb(t.a,1.,1.,o.shift?0.:1.);\n\tsb(t.a,2.,1.,o.v[0].brake?0.:1.);\n#if LANES>1\n    sb(t.a,3.,1.,float(o.v[0].lane_out)); \n\n    sb(t.a,4.,1.,o.v[1].brake?0.:1.); \n    sb(t.a,5.,1.,float(o.v[1].lane_out));\n#endif\n    \n    return t;\n}\n\n//BLOCK (or Tile)\nstruct block {\n    vec2 block_pos;\n    int btype; //3 bit 0=none 1=roundabout 2=semaphore 4=street 5 =overpass \n    int ltype; //0=none  2=building 3=center\n    int bh; //building height\n    int th; //terrain height\n    int conns; // current connections (bitmask)\n    float counter;\n    int dist; //distant from center\n    int dir; //dir to center\n    int aconns;// allowed connections (bitmask)\n    \n    int semaphore; //0:YELLOW 2:VERTICAL 1:HORIZONTAL\n       \n};\n\nblock newBlock(vec3 coord, int btype,int ltype, int bh, int th ){\n\tblock o;\n    o.block_pos= coord.xy;\n    o.btype=btype; \n    o.ltype=ltype;\n    o.th=th;\n    o.bh=bh;\n    o.conns=15;\n  \to.counter=0.;\n    o.dist=MAX_DIST;\n    o.dir=0;\n    o.semaphore=0;\n    o.aconns=15;\n    return o;               \n}              \n                 \nblock decodeBlock(vec4 t,vec2 coord) {\n\tblock o;\n    o.block_pos= coord;\n    o.btype=int(gb(t.r,0., 3.));\n    o.ltype = int(gb(t.r,3., 3.)); \n    o.conns = int(gb(t.r,6., 4.));\n    o.semaphore = int(gb(t.r,10., 2.));\n    o.aconns =int(gb(t.r,12., 4.));\n    \n    o.bh = int(gb(t.g,0., 8.));\n    o.th = int(gb(t.g,8., 8.));\n    o.counter=t.b;\n    o.dist= int(gb(t.a,0., 10.));\n    o.dir= int(gb(t.a,10., 2.));\n    return o;\n}\n\nvec4 encodeBlock(block o) {\n\tvec4 t=vec4(0.);\n    \n    sb(t.r,0.,3.,float(o.btype));\n    sb(t.r,3.,3.,float(o.ltype));\n    sb(t.r,6.,4.,float(o.conns));\n    sb(t.r,10.,2.,float(o.semaphore));\n    sb(t.r,12.,4.,float(o.aconns));\n    sb(t.g,0.,8.,float(o.bh));\n    sb(t.g,8.,8.,float(o.th));\n    \n    t.b=o.counter;\n    sb(t.a,0.,10.,float(o.dist));\n    sb(t.a,10.,2.,float(o.dir));\n    return t;\n}\n\n//MAPPING FUNCTIONS\nbool isBlockCoord(vec3 coord) {\n    return (int(coord.z)== 0);\n}\n    \nvec3 buffer2coord(vec2 b) {  \n    return vec3(\n        floor(b.x/BLOCK_BUFFER.x),\n        floor((b.y-1.)/BLOCK_BUFFER.y),\n        floor(mod(b.x, BLOCK_BUFFER.x))* BLOCK_BUFFER.x +floor(mod((b.y-1.), BLOCK_BUFFER.y))\n     );\n\n}\n\nvec2 buffer2point(vec2 b){\n\treturn vec2(\n    \t\tmod(b.x, BLOCK_BUFFER.x),\n        \tmod((b.y-1.), BLOCK_BUFFER.y)\n    );\n}\n    \nvec2 coord2buffer(vec3 c){\n\treturn vec2(\n        floor(c.x) * BLOCK_BUFFER.x  + floor(c.z/BLOCK_BUFFER.x),\n        floor(c.y) * BLOCK_BUFFER.y  + floor(mod(c.z,BLOCK_BUFFER.x)) +1.\n    );\n}\n\nvec3 nextCoord(cell c, int d, int btype){\n    \n    vec2 dir=DIRS[d];\n    if(btype==5){\n       \tint npos=-1;\n        if(d==0) switch (c.pos){\n\t\t\tcase 19: npos=25;break;\n            case 25: npos=28;break;\n            case 28: npos=22;break;\n            case 10: npos=16;break;\n            case 7: npos=10;break;\n            case 13: npos=7;break;\n            default: break;\n\n        }else if(d==2) switch (c.pos){\n        \tcase 25: npos=19;break;\n            case 28: npos=25;break;\n            case 22: npos=28;break;\n            case 16: npos=10;break;\n            case 10: npos=7;break;\n            case 7: npos=13;break;\n            default: break;\n        }\n        \n        if((d%2)==0 &&\n            (c.pos==9 || c.pos==14 ||c.pos==15 ||c.pos==20 ||c.pos==21 ||c.pos==26 )    \n                ) npos=5;\n\n        if(npos!=-1) return vec3(c.block_pos,float(npos));\n    }\n\treturn buffer2coord(coord2buffer(vec3(c.block_pos,c.pos)) +dir);\n}\n\n/*\n//SLOW COMPILATION\nvec3 nextCoord(cell c, int d, int btype){\n    \n    vec2 dir=DIRS[d];\n    if(btype==5){\n    \tif(c.pos==19 && d==0) return vec3(c.block_pos,25.);\n        if(c.pos==25 && d==2) return vec3(c.block_pos,19.);\n        if(c.pos==25 && d==0) return vec3(c.block_pos,28.);\n        if(c.pos==28 && d==2) return vec3(c.block_pos,25.);\n        if(c.pos==28 && d==0) return vec3(c.block_pos,22.);\n        if(c.pos==22 && d==2) return vec3(c.block_pos,28.);\n        \n        if(c.pos==16 && d==2) return vec3(c.block_pos,10.);\n        if(c.pos==10 && d==0) return vec3(c.block_pos,16.);\n        if(c.pos==10 && d==2) return vec3(c.block_pos,7.);\n        if(c.pos==7  && d==0) return vec3(c.block_pos,10.);\n        if(c.pos==7  && d==2) return vec3(c.block_pos,13.);\n    \tif(c.pos==13 && d==0) return vec3(c.block_pos,7.);\n        \n        if(c.pos==15 && (d%2)==0) return vec3(c.block_pos,5.);\n        if(c.pos==9 && (d%2)==0) return vec3(c.block_pos,5.);\n        if(c.pos==26 && (d%2)==0) return vec3(c.block_pos,5.);\n        if(c.pos==14 && ( d%2)==0 ) return vec3(c.block_pos,5.);\n        if(c.pos==20 && ( d%2)==0) return vec3(c.block_pos,5.);\n        if(c.pos==21 && ( d%2)==0) return vec3(c.block_pos,5.);\n    }\n\treturn buffer2coord(coord2buffer(vec3(c.block_pos,c.pos)) +dir);\n}*/\n\n//ROAD\nbool isRoad_(in block b, vec2 point){\n            \n    float fCross= (b.btype==1)?1.:0.;\n    \n    bool road=true;\n    //if(b.btype==5 ) b.conns &= 10; //overpass down\n    //if(b.btype==6 ) b.conns &= 5; //overpass up\n    \n    if( b.btype==0 )  road=false;\n    else if(b.btype==1 &&  (abs(point.x-3.) +abs(point.y-3.) >3.  || abs(point.x-3.) +abs(point.y-3.) <2. )) road=false;    \n        \n    else if((b.conns&1)==0 &&  abs(point.y-1. ) >3. +fCross  )  road=false;\n    else if((b.conns&2)==0 &&  abs(point.x-1. ) >3. +fCross )  road=false;\n    else if((b.conns&4)==0 &&  abs(point.y-5. ) >3. +fCross  )  road=false;\n    else if((b.conns&8)==0 &&  abs(point.x-5. ) >3. + fCross )  road=false;\n    else if(( b.btype==4 || b.btype==2 || b.btype==5  )&&  (min(abs(point.x-3.),abs(point.y-3.)) >1.)    ) road=false;\n        \n\treturn road;\n}\nbool  isRoad(in block b, int pos){\n    vec2 point=  vec2(\n         floor(float(pos)/BLOCK_BUFFER.x),\n         floor(mod(float(pos),BLOCK_BUFFER.x)) \n    ) +.5;\n    return  isRoad_( b, point);\n}\n\n\n","name":"Common","description":"","type":"common"}]}