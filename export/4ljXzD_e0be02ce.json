{"ver":"0.1","info":{"id":"4ljXzD","date":"1442233558","viewed":305,"name":"pattern2561512","username":"vortex","description":"pattern343412562","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["pattern3665425312"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float s= 30.0;\nconst float h1= 12.0;\n\n\nconst float h=h1*4.0;\n\n//noise function for a single cell\nfloat n(vec2 x,float s)\n{\n    vec2 g=floor(x/s);\n    vec2 f=floor(x)-g*s;\n    // a second order polynomial x*(a+x*b+y*c)+y*(d+y*e)\n    vec2 c=floor((vec2(0.25)+vec2(0.5)*fract(\n        g.xy*(vec2(0.44343,0.54248)\n             +vec2(0.57418,0.81702)*g.xy\n             +vec2(0.45737,0.94279)*g.yx)+\n        g.yx*(vec2(0.98713,0.84138)\n             +vec2(0.27139,0.21677)*g.yx)))*s);\n    \n    //this makes a kind of a pyramid \n    return max(0.0,s/4.0-max(abs(f.x-c.x),abs(f.y-c.y)));\n}\n\n// combining 4 cells together\nfloat N(vec2 x,float s)\n{\n    return max(max(n(x+vec2(  0.0,   0.0)*s,s),\n                   n(x+vec2( 20.5,  30.0)*s,s)),\n               max(n(x+vec2( 13.0,-224.5)*s,s),\n                   n(x+vec2(178.5,-285.5)*s,s)));\n}\n\n// making the pyramids more dense by combining a few noises\nfloat M(vec2 x,float s)\n{\n    return max(\n        max(N(x+vec2(  0.0,   0.0)*s,s),\n            N(x+vec2( 37.0, -52.0)*s,s)),\n        max(N(x+vec2(251.0, 217.0)*s,s),\n            N(x+vec2(-12.0,-167.0)*s,s)));\n}\n\n// arrow X is position in the cell, D is direction\nfloat arrow(vec2 x,vec2 d)\n{\n    // return a dot if the direction is close to a null vector\n    if (dot(d,d)<1e-5) return min(1.0,floor(dot(x-vec2(0.5),x-vec2(0.5))/(0.1*0.1)));\n    \n    // tranforming with an orthonormal matrix, which rotates to D\n    x=mat2(normalize(d),normalize(vec2(d.y,-d.x)))*(x-vec2(0.5));\n    \n    return min(max(floor(abs(x.y)-0.05)+1.0,floor(abs(x.x)-0.25)+1.0 ),//arrow body\n               x.x-0.25>0.0 && x.x-0.25+abs(x.y)<0.25 ? 0.0 : 1.0 );   //and arrow head\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2  x= s*(fragCoord.xy-1.0*iMouse.xy)/iResolution.x\n        +vec2(0,floor(iTime*2.0)*0.5);\n    \n    float c= M(x,h);\n    \n    float r= M(x+vec2( 1, 0),h);\n    float l= M(x+vec2(-1, 0),h);\n    float u= M(x+vec2( 0, 1),h);\n    float d= M(x+vec2( 0,-1),h);\n    \n    vec2 g=vec2(r-l,u-d);//the gradient of the noise (well it's not exatly noise, but rather\n                          //some random pattern\n    \n    float ar=arrow(fract(x),vec2(g.y,-g.x));//the arrows are set to be \n                                             //perpendicular to the gradient\n    \n    //the arrow combined with a random colour\n\tfragColor = vec4(ar*fract((c+vec3(1.0))*vec3(0.245,0.7151,6.5671)),1.0);\n}","name":"","description":"","type":"image"}]}