{"ver":"0.1","info":{"id":"td3SRH","date":"1571402422","viewed":142,"name":"ShaderTober - Ornament","username":"Flopine","description":"A small doodle with inktober's theme \"Ornament\"","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 100.\n#define PI 3.141592\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat necklace (vec3 p)\n{\n    vec3 pp = p;\n    p.y += 1.5;\n    p.x = abs(p.x)-0.5;\n    p.y += sin(p.x);\n    p.xy *= rot(-PI/4.);\n    p.xz *= rot(p.y*2.-iTime);\n    moda(p.xz, 5.);\n    p.x -= 0.2;\n    float n = cyl(p.xz,0.1);\n    \n    p = pp;\n    p.y -= 0.5;\n    float r = max(abs(cyl(p.xy,1.7))-0.2,abs(p.z)-0.12);\n    \n    return stmin(r,n,0.2,3.) ;\n}\n\nfloat g1 = 0.;\nfloat gem (vec3 p)\n{\n    p.y -= 0.5;\n    p.xz *= rot(iTime);\n   \tfloat d = dot(p, normalize(sign(p)))-0.85;\n    g1 += 0.1/(0.1+d*d);\n\treturn d ;\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    p.y += 0.4;\n    float g = gem(p);\n    float n = necklace(p);\n    float d = min(g,n);\n    \n    if (d == n) mat_id =1;\n    if (d == g) mat_id = 2;\n    \n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),\n                                 SDF(p-eps.yxy),\n                                 SDF(p-eps.yyx)));\n}\n\nvoid gold (inout vec3 color, vec3 n, vec3 l, vec3 rd)\n{\n    // fresnel\n    float fre = pow(clamp(1.-dot(-rd,n),0.,1.), 2.);\n    color += fre*vec3(0.8,0.5,0.2);\n    \n    // specular\n    vec3 h = normalize(l-rd);\n    float spe = pow(max(0.,dot(h,n)),10.);\n    color += spe*vec3(0.8,0.5,0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.001,0.001,-3.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        l = vec3(1.,-3.,-5.),\n        col = vec3(1.);\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        if (mat_id == 1)\n        {\n            col = vec3(0.7,0.5,0.1);\n            gold(col,n,l,rd);\n        }\n        if (mat_id == 2)\n        {\n            col = vec3(shad);\n        }\t\n    }\n    \n    col -= g1*0.1;\n\tcol = clamp(col,0.,1.);\n    \n    // vignetting (from iq)\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.15);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}