{"ver":"0.1","info":{"id":"slX3Rl","date":"1622598470","viewed":45,"name":"even worse 3d sdf","username":"AlexApps99","description":"bruh","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ideas:\n// Specify properties of materials as function\n// Use cubemap reflection\n// Ambient occulusion/shadows\n\nvec3 SunDir = vec3(0., -1., 0.);\nvec3 SunCol = vec3(1.);\n\nstruct Out {\n    // X: distance, YZW: normal\n    vec4 Value;\n    vec3 Color;\n    float Specular;\n    // TODO specular etc\n};\n\n#define RADIUS (0.2*sin(iTime)+0.65)\n// Self explanatory :)\nOut sdf_sphere(in vec3 pos) {\n    float d = length(pos);\n    Out o;\n    o.Value = vec4(d-RADIUS, pos / d);\n    o.Color = vec3(0., 1., 0.);\n    o.Specular = .9;\n    return o;\n}\n\n// TODO get it right!\n#define rDIMS (vec3(0.5))\nOut sdf_box(in vec3 pos) {\n    Out o;\n    vec3 q = abs(pos) - rDIMS;\n    o.Value.x = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    o.Color = vec3(.1, .6, .1);\n    o.Specular = 0.0;\n    return o;\n}\n\n#define R1 (1.3)\n#define R2 (0.1)\nOut sdf_torus(in vec3 pos) {\n  Out o;\n  float h = length(pos.xz);\n  o.Value = vec4(length(vec2(h-R1,pos.y))-R2, normalize(pos*vec3(h-R1,h,h-R1)));\n  o.Color = vec3(0., .4, .8);\n  o.Specular = 0.7;\n  return o;\n}\n\n\n#define FLOOR_HEIGHT (-1.)\nOut sdf_floor(in vec3 pos) {\n    Out o;\n    o.Value = vec4(0.f);\n    o.Value.x = abs(pos.y - FLOOR_HEIGHT);\n    o.Value.z = sign(pos.y - FLOOR_HEIGHT);\n    o.Color = vec3(1.);\n    o.Specular = 0.2;\n    return o;\n}\n\nOut sdf_min(in Out a, in Out b) {\n    if (a.Value.x < b.Value.x) return a;\n    else return b;\n}\n\nOut sdf_max(in Out a, in Out b) {\n    if (a.Value.x > b.Value.x) return a;\n    else return b;\n}\n\nOut sdf(in vec3 pos) {\n    vec3 rot_pos = vec3(pos.x*sin(iTime)-pos.y*cos(iTime), pos.x*cos(iTime)+pos.y*sin(iTime), pos.z);\n    Out o;\n    Out box = sdf_box(rot_pos);\n    Out sphere = sdf_sphere(pos);\n    sphere.Value.x = -sphere.Value.x;\n    Out floor_ = sdf_floor(pos);\n    Out torus = sdf_torus(pos);\n    o = sdf_min(\n        sdf_min(\n            sdf_max(box, sphere),\n            floor_\n        ), torus\n    );\n    return o;\n}\n\n#define MIN_D (0.)\n#define MAX_D (100.)\n#define THRESHOLD (1e-2)\n// Returns distance from camera to object, or -1 if no object\nOut castRay(in vec3 ro, in vec3 rd, out vec3 pos) {\n    float d = MIN_D;\n    while (d<MAX_D) {\n        pos = ro + rd*d;\n        Out obj = sdf(pos);\n        float dist = obj.Value.x;\n        if (dist < THRESHOLD) return obj;\n        d += dist;\n    }\n    Out fail;\n    fail.Value = vec4(-1.);\n    return fail;\n}\n\n#define SUN_MIN_D (1e-2)\n#define SUN_MAX_D (5.)\n#define SUN_THRESHOLD (1e-4)\n#define SUN_COL (0.2)\nfloat castSun(in vec3 ro, in vec3 rd){\n    float d = SUN_MIN_D;\n    while (d<SUN_MAX_D) {\n        float dist = sdf(ro + rd*d).Value.x;\n        if (dist < SUN_THRESHOLD && d != SUN_MIN_D) return SUN_COL;\n        d += dist;\n    }\n    return 1.;\n}\n\n// Basically just shows the depth\nvec3 render(in vec3 ro, in vec3 rd){\n    vec3 pos;\n    Out o = castRay(ro, rd, pos);\n    float d = o.Value.x;\n    if (d >= 0.) {\n        vec3 ref = rd - 2. * dot(rd, o.Value.yzw) * o.Value.yzw;\n        float bright = castSun(pos, -SunDir);\n        return bright * mix(o.Color, texture(iChannel0, ref).rgb, o.Specular);\n    } else {\n        return texture(iChannel0, rd).rgb;\n    }\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);\n    vec3 cp = vec3(sin(r), cos(r), 0.);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Screen coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    // Ray origin (camera position)\n    vec3 ro = vec3(-8.*(iMouse.xy/iResolution.xy-0.5), 4.);\n    // Eye target (origin)\n    vec3 tar = vec3(0.);\n    vec3 rd = lookAt(ro, tar, 0.)*normalize(vec3(uv, 1.0));\n    vec3 col = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}