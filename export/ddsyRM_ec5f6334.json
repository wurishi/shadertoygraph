{"ver":"0.1","info":{"id":"ddsyRM","date":"1686678557","viewed":74,"name":"My Second Shader: Strobo","username":"goshanov","description":"My second shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["second"],"hasliked":0,"parentid":"dttXDl","parentname":"Fork My First S goshanov 174"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t)\n{\n    const vec3 a = vec3(0.508, .558, .688);\n    const vec3 b = vec3(.5, .498, .318);\n    const vec3 c = vec3(-0.472, 1., .648);\n    const vec3 d = vec3(-1.082, -1.792, .498);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 rotate2D(in vec2 vec, float rotateAngle) {\n    return vec2(\n        vec.x * cos(rotateAngle) - vec.y * sin(rotateAngle), \n        vec.x * sin(rotateAngle) + vec.y * cos(rotateAngle)\n    );\n    \n}\n\n\nfloat tripleWave(in float x, in float y, in float z, in float t) {\n    return (sin(t * x) + sin(t * y) + sin(t * z)) / 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    float spedUpTime = iTime * 1000.;\n\n    uv = uv * 2.;\n    uv = fract(uv);\n    uv = uv - 0.5;\n    \n    float centerDistance = length(uv0);\n    \n    vec2 rotated = rotate2D(uv0, iTime);\n    \n    \n\n    float combinedFrequency = tripleWave(3., 5., 1., iTime / 2.);\n    float doubleCombinedFrequency = tripleWave(3., 5., 1., iTime);\n    float doublePeakVibration = smoothstep(0.2, 0.8, abs(doubleCombinedFrequency));\n    float peakVibration = smoothstep(0.2, 0.8, abs(combinedFrequency));\n\n    float MAX_FLUCTUATION = 100.;\n    float fluctuatedCircleVibration = MAX_FLUCTUATION - MAX_FLUCTUATION * combinedFrequency;\n\n    float MAGIC_REMOVE_DARK_SPOT_IN_CENTER = 14.;\n    float circleDistance = sdCircle(uv, 0.04 * centerDistance);\n    \n    float formFactor = max(sin(uv.x * uv.y), cos(uv.y * uv.y - uv.x * uv.x));\n    float formFactor2 = (sin(uv.y) + cos(uv.x)) / 2.;\n    float circleSize = 1.2 + 7. * abs(sin(combinedFrequency));\n\n    circleDistance = sin(circleDistance * 2.5) \n        * circleDistance * circleSize\n        - sin(formFactor * fluctuatedCircleVibration + centerDistance) / MAGIC_REMOVE_DARK_SPOT_IN_CENTER;\n    \n    float d0 = sdPentagon(rotate2D(uv0, -iTime / 2.), 0.4 + doublePeakVibration * 0.1);\n    \n    // moving pentagon\n    float d = sin(5. * d0 + iTime) / 2.;\n    d = abs(d);\n    \n    float dTri = sdEquilateralTriangle(\n        rotated, \n        1. + doublePeakVibration // move triangle outside based on time\n    );\n\n    dTri = abs(dTri);\n    \n    vec3 constColorTri = vec3(dTri, 0, 0);\n\n    vec3 color = palette(d * 5. + iTime * 1.5) / d * 0.04;\n    float fixedCircleDistance = (circleDistance + smoothstep(0.2, 0.5, circleDistance) + 0.075);\n    vec3 colorTri = palette(dTri);\n    \n    color = color / fixedCircleDistance ;\n    \n    float DIMMER = -0.4;\n    \n    color += colorTri * peakVibration * 0.8 + DIMMER * combinedFrequency;\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}