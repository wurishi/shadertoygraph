{"ver":"0.1","info":{"id":"ttGXWG","date":"1583458992","viewed":181,"name":"mandala1â™¡","username":"HaleyHalcyon","description":"no flash","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float gau(float x, float y, float stdev) {\n    float s = length(vec2(x, y)) / stdev;\n    return exp(-s * s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float w = 3.;\n    const float stdev = 2.;\n    \n    float radius = length(\n        (2. * fragCoord.xy - iResolution.xy)\n        / length(iResolution.xy)\n    );\n    \n    float sum = 0.;\n    for (float x = -w; x <= w; x++) {\n        for (float y = -w; y <= w; y++) {\n            sum += gau(x, y, stdev);\n        }\n    }\n    vec3 col = vec3(0.);\n    for (float x = -w; x <= w; x++) {\n        for (float y = -w; y <= w; y++) {\n            col += (\n                texture(\n                    iChannel0,\n                    (fragCoord.xy) / iResolution.xy  + vec2(x, y) / vec2(1920., 1080.)\n                ).xyz\n            ) * gau(x, y, stdev);\n        }\n    }\n    col /= sum;\n    col = mix(\n        col, \n        texture(\n            iChannel0,\n            fragCoord.xy / iResolution.xy\n        ).xyz,\n        smoothstep(0.02, 0.07, radius)\n    );\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float TURN = 2. * acos(-1.);\n\n// adjusts the saturation\nvec3 sat(vec3 rgb, float sat)\n{\n    // Algorithm from Chapter 16 of \"OpenGL Shading Language\"\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, sat); // adjust strength here\n}\n\nfloat fn2(float x)\n{\n    x = fract(x) * 2. - 1.;\n    float n = x * x * x;\n\treturn (n - x);\n}\n\n// brightness of the grid lines\nfloat fn(float x)\n{\n    float n = sin(x * TURN) * 0.5 + 0.5;\n    return n * n;\n    //return smoothstep(0., 1., fract(x));\n}\n\nfloat vignette(float v, float d)\n{\n    return v * (0.8 - 0.7 * d);\n}\n\nvec3 colorize(float x, float ofs) {\n    return 0.5 + 0.5 * vec3(\n        cos((x + (ofs     ) / 3.) * TURN),\n        cos((x + (ofs + 1.) / 3.) * TURN),\n        cos((x + (ofs + 2.) / 3.) * TURN)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float speed = 1./4.;\n    float t = fract(iTime * speed);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    \n    //float distance = length(uv);\n    //float distance = pow(sqrt(uv.x*uv.x+uv.y*uv.y), 1./3.);\n    float distance = log(uv.x*uv.x+uv.y*uv.y);\n    float angle = atan(uv.y, uv.x) / TURN;\n    \n    // Time varying pixel color\n    // spiral 1\n    float c1 = vignette(\n        fn(\n            distance * .25 +\n            angle * 3.0 +\n            fn2(t) * 4.0\n        ), distance\n    );\n    // spiral 2\n    float c2 = vignette(\n        fn(\n            distance * .25 -\n            angle * 3.0 +\n            fn2((t) + 2. / 3.) * 4.0\n        ), distance\n    );\n    // rings \n    float c3 = vignette(\n        max(\n            0.,//fn(angle * 8.0 + sin(iTime) * 8.0 - iTime * 0.5) * 0.5,\n            fn(\n                distance * 0.8 +\n                fn2((t) + 4. / 3.) * 3.0\n            )\n        ), distance\n    );\n    \n\n    // Output to screen\n    vec3 col = clamp(\n        sat(\n            0.7 * (\n                c1 * colorize(t, 0.) +\n                c2 * colorize(t, 1.) +\n                c3 * colorize(t, 2.)\n            ),\n            1.5\n        ), vec3(0.0), vec3(1.0)\n    );\n    \n    fragColor = vec4(\n        col,\n        //colorize(t, uv.y),\n        1\n    );\n}","name":"Buffer A","description":"","type":"buffer"}]}