{"ver":"0.1","info":{"id":"4fcyRB","date":"1730948815","viewed":113,"name":"SolarFlare_UX","username":"kosalos","description":"ray marching fractal\n\nCross-eyed 3D\nSit as far back from the screen as possible\nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n","likes":5,"published":3,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"MXcGWr","parentname":"cycle3 v2"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis sketch has two phases:\n1. User Interface mode, where you alter the fractal parameters via the arrows keys and the mouse.\n   At any time you can capture the settings and save them in the source code as keyframes.\n2. Keyframe display mode, where the settings are interpolated between the keyframes.\n\n\nUserInterface mode:\nEnable \"#define USER_INTERFACE\" at the top of the Common tab.\nThe interface is described just below.\nNote the color bar drawn at screen bottom (when settings are displayed).\nFollow the instructions in the \"Console Transmit\" sketch:   https://www.shadertoy.com/view/4XVGR3\nto acquire the settings to raw text you can add to the keyframe array storage (line 52 of this tab).\nA little tedious, but I don't know of any other way to get the settings out of the shader.\n\nKeyframe display mode:\nComment out \"#define USER_INTERFACE\" at the top of the Common tab.\nNo user interface except: click the mouse on left/right side of the screen to disable/enable cross eyed stereo.\nThe speed of keyframe transistion is set via the \"iFramesPerKeyFrame\" on line 416 of this tab.\n\nHope you find this technique useful in your experiments.\n\n*/\n\n\n/* USER_INTERFACE -----------------------\nKey Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<Spc> : reset\n\nNote: hold down <Shift> then drag mouse to affect camera.xy regardless of focus.\nNote: hold down <Alt><Shift> then drag mouse to affect aim.xy regardless of focus.\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1\nHold down <Z> for change Amount * 10.\nHold down both <A><Z> for change Amount * 50.\n\nClick the mouse on left/right side of the screen to disable/enable cross eyed stereo.\n\n*/\n\n// --------------------------------------------------------\n\nconst float keyFrame[] = float[](\n   1.04, 7.43, -4.97, 0.92, 0.59, 9.16, -0.6, 9.90, 1.29, -0.51, 3.22, 9.90, -8.57, -7.59, -9.99, 9.90, 2.36, -0.07, 2.85, 9.90, 0.97, 5.0, 9.90, 9.90, -1.69, 1.28, -0.13, 9.90, 1.28, 3.03, 9.90, 9.90, -1.15, 1.10, -0.29, 9.90, -9.49, 2.56, 2.98, 9.90,\n   1.04, 2.95, -0.06, 2.29, 1.13, -4.60, -0.61, 9.90, 1.55, -0.51, 3.22, 9.90, -8.57, -7.59, -9.99, 9.90, 2.36, -0.07, 2.85, 9.90, 0.97, 5.0, 9.90, 9.90, -1.69, 1.28, -0.13, 9.90, 1.28, 3.03, 9.90, 9.90, -1.15, 1.10, -0.29, 9.90, -9.49, 2.56, 2.98, 9.90, \n   1.14, 6.43, -1.90, 2.05, 0.58, 7.65, -0.6, 9.90, 1.29, -0.51, 3.22, 9.90, -8.57, -7.59, -9.99, 9.90, 2.36, -0.07, 2.85, 9.90, 0.97, 5.0, 9.90, 9.90, -1.69, 1.28, -0.13, 9.90, 1.28, 3.03, 9.90, 9.90, -1.89, 0.84, -0.52, 9.90, 0.03, 10.79, 8.65, 9.90, \n   1.24, 5.43,  1.90, 3.05, 0.58, 7.65, -0.6, 9.90, 1.29, -0.51, 3.22, 9.90, -8.57, -7.59, -9.99, 9.90, 2.36, -0.07, 2.85, 9.90, 1.43, 5.41, 9.90, 9.90, -1.83, 1.28, -0.13, 9.90, 1.28, 3.03, 9.90, 9.90, -1.91, 1.20, -0.32, 9.90, 2.16, 7.65, 8.65, 9.90 \n);\n\nconst int keyframeEntryLength = QSIZE * 4;    // vec4 for each q[] entry\nconst int keyFrameCount = keyFrame.length() / keyframeEntryLength; // # q[] datasets in storage\n\n// --------------------------------------------------------------------\n// given 0..1, output ease in/out rendition 0..1\n// https://stackoverflow.com/questions/13462001/ease-in-and-ease-out-animation-formula\n\nfloat parametricBlend(float ratio) {\n\tfloat sqt = ratio * ratio;\n\treturn sqt / (2.0 * (sqt - ratio) + 1.);\n}\n\nfloat bezierBlend(float ratio) {\n\treturn ratio * ratio * (3. - 2. * ratio);\n}\n\nfloat parabolicBlend(float ratio) {\n\tfloat y = 2. * ratio * ratio;\n\n\tif (ratio > 0.5) {\n\t\tratio -= 1.;\n\t\ty = -2. * ratio * ratio + 1.;\n\t}\n\n\treturn y;\n}\n\nvoid loadKeyFrame(int keyFrameIndex,float mixRatio) {\n    int index1 = keyFrameIndex * keyframeEntryLength;\n    int index2 = ((keyFrameIndex+1) % keyFrameCount) * keyframeEntryLength;\n\n    float r = parametricBlend(mixRatio);\n    \n    for(int i=0;i<QSIZE;++i)   // vec4 q[] index\n        for(int j=0;j<4;++j)   // x,y,z,w field index\n            q[i][j] = mix(keyFrame[index1++],keyFrame[index2++],r);\n}\n\n// --------------------------------------------------------\n\n#define CRYSTAL_EFFECT\n\nconst int maxSteps = 2;\nconst float epsilon = 0.0001;\nconst float fogDistance =  -0.5; // set to 0.0 to disable fog\nconst float fogAmount = 0.021;\nconst float fogColor = 0.32;\n    \nconst float parallax = 0.02; // use smaller values when viewing closeup objects\n\nfloat ambient,contrast,vibrant,dim;\nfloat Ostrength; // 0.0 -> disable orbit trapping\nfloat Ocycle;\nfloat OXwt,OXcr; // weight, color code\nfloat OYwt,OYcr;\nfloat OZwt,OZcr;\nfloat OWwt,OWcr;\nvec3  Ocenter;   // origin offset\n\n// calculated params\nvec3 direction;\nvec3 normal;\nvec3 position;\nvec3 color;\nfloat depth;\nint iter;\nvec4 orbitTrap;\n\nint focus,row,displayCount;\nbool stereoEnable;\nvec3 viewVector,sideVector,topVector;\n\n// --------------------------------------------------------\n\nvec3 boxFold(vec3 z, float dz) { return clamp(z, -dz, dz) * 2.0 - z; }\n\nvec2 rotate(vec2 p, float angle) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    return mat2(cosA, -sinA, sinA, cosA) * p; \n}\n\n// --------------------------------------------------------\n\nfloat DE(vec3 pos) {\n    vec4 nz;\n    float md2 = 1.0;\n    vec4 z = vec4(pos,0);\n    float mz2 = dot(z,z);\n    const float hk = .6;\n    vec3 ot;\n\n    for (int i = 0; i < 10; ++i)    {\n        if(i >= maxSteps) break;\n        md2 *= 4.0 * mz2;\n        nz.x = z.x * z.x - dot(z.yzw,z.yzw);\n        nz.yzw = 2.0 * z.x * z.yzw;\n        z = nz * 0.5 + qshape;\n\n        z.x = qscale.x * log(z.x + sqrt(z.x*z.x + hk));\n        z.y = qscale.y * log(z.y + sqrt(z.y*z.y + hk));\n        z.z = qscale.z * log(z.z + sqrt(z.z*z.z + hk));\n\n        z.x = qsine.x * sin(z.x + qoffset.x)+(z.x * qslope.x);\n        z.y = qsine.y * sin(z.y + qoffset.y)+(z.y * qslope.y);\n        z.z = qsine.z * sin(z.z + qoffset.z)+(z.z * qslope.z);\n\n        z.xyz = boxFold(z.xyz,qangle.x);\n        z.xz = rotate(z.xz,qangle.y);\n\n        mz2 = dot(z,z);\n        if(mz2 > 12.0) break;\n\n        ot = z.xyz - orbit4;\n        orbitTrap = min(orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n    \n  return sqrt(mz2/md2) * log(mz2);\n}\n\nfloat DE_plusSpherical(vec3 pos) { // spherical inversion\n    pos = pos - qinvpos.xyz;\n    float r = length(pos);\n    float r2 = r*r;\n    float radius2 = qinvrad.x * qinvrad.x;\n    pos = (radius2 / r2) * pos + qinvpos.xyz;\n\n    float an = atan(pos.y,pos.x) + qinvrad.y;\n    float ra = length(pos.xy);\n    pos.x = cos(an) * ra;\n    pos.y = sin(an) * ra;\n\n    float de = DE(pos);\n    return r2 * de / (radius2 + r * de);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n    if(weight == 0.0) return vec3(0.0);\n\n    x = cos(x);\n    //x=abs(sin(x)); // limits colors\n\n    // bezier, you can rearange the functions for different color combos but this one is best\n    float r = (1.0-x)*(1.0-x);\n    float g = x*x;\n    float b = 2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    vec3 orbitColor;\n    \n    if (Ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(Ocycle,generateColor(OXwt,OXcr), orbitTrap.x) * OXwt * orbitTrap.x +\n        orbitTrapCycle(Ocycle,generateColor(OYwt,OYcr), orbitTrap.y) * OYwt * orbitTrap.y +\n        orbitTrapCycle(Ocycle,generateColor(OZwt,OZcr), orbitTrap.z) * OZwt * orbitTrap.z +\n        orbitTrapCycle(Ocycle,generateColor(OWwt,OWcr), orbitTrap.w) * OWwt * orbitTrap.w;\n    } else {\n        orbitColor =\n            generateColor(OXwt,OXcr) * OXwt * orbitTrap.x +\n            generateColor(OYwt,OYcr) * OYwt * orbitTrap.y +\n            generateColor(OZwt,OZcr) * OZwt * orbitTrap.z +\n            generateColor(OWwt,OWcr) * OWwt * orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\n// --------------------------------------------------------\n// phongParam = diffuse,spec,ambient\n\nvoid phongLight() {\n    vec3 L = normalize(phongPosition - position);\n    float dotLN = dot(L, normal);\n    if (dotLN < 0.) return;\n        \n    float t1 = phongParam.x * dotLN;\n    vec3 V = normalize(qcamera.xyz - position);\n    vec3 R = normalize(reflect(-L, normal));\n    float dotRV = dot(R, V);\n\n    if (dotRV < 0.0) {\n        color += phongColor * t1;\n        return;\n    }\n\n    float t2 = phongParam.y * pow(abs(dotRV), phongParam.z);\n    color += phongColor * (t1 + t2);\n}\n\n// spotLightParam = strength,x,y,exp\nconst float PI = acos(-1.);\n\nvoid spotLight() {\n    float a1 = spotLightParam.y * PI;\n    float a2 = spotLightParam.z * PI * 0.5;\n    float s1 = sin(a1);\n    vec3 spotDir = normalize(vec3(s1 * cos(a2), s1 * sin(a2), cos(a1)));\n    vec3 halfVector = normalize(spotDir - direction);\n\n    float nDotL = max(0., dot(normal, spotDir));\n    float hDotN = max(0., dot(normal, halfVector));\n\n    vec3 c = spotLightColor;// * spotLightParam.x;\n    float sexp = spotLightParam.w;\n\n    color += c * ((sexp + 2.) / 2.) * pow(hDotN, sexp)\n        * (sexp + (1. - sexp) * pow(1. - hDotN, 5.)) * nDotL * spotLightParam.x;\n}\n\n#define animate(v,v1,v2,speed) v = mix(v1,v2,0.5 + sin(iTime * speed) * 0.5)\n#define animate2(v,base,delta,speed) v = mix(base-delta,base+delta,0.5 + sin(iTime * speed) * 0.5)\n#define animate3(v,base,delta,speed) v = mix(base - base*delta,base + base*delta,0.5 + sin(iTime * speed) * 0.5)\n\nvoid lighting() {\n    animate2(phongParam.x,0.2,0.3,0.3);\n    animate2(phongParam.y,0.,0.1,0.35);\n    animate2(phongParam.z,8.,2.,0.4);\n    animate2(phongColor.x,0.5,0.5,0.3);\n    animate2(phongColor.y,0.5,0.5,0.7);\n    animate2(phongColor.z,0.5,0.5,0.9);\n    animate2(phongPosition.x,0.,2.,0.01);\n    animate2(phongPosition.y,0.,2.,0.05);\n    animate2(phongPosition.z,-5.,2.,0.07);\n\n    animate2(spotLightParam.x,1.,0.5,0.3);\n    animate2(spotLightParam.y,0.,1.5,0.03);\n    animate2(spotLightParam.z,0.,1.5,0.035);\n    animate2(spotLightParam.w,0.7,0.2,0.4);\n    animate2(spotLightColor.x,0.5,0.5,0.1);\n    animate2(spotLightColor.y,0.5,0.5,0.2);\n    animate2(spotLightColor.z,0.5,0.5,0.4);\n\n    animate(ostrength,0.,0.62,0.1);\n    animate(ocycle,0.,3.,0.18);\n    animate(orbit2.x,-0.,3.,0.011);  // X wt,color\n    animate(orbit2.y,-3.,3.,0.013);\n    animate(orbit2.z,-0.,3.,0.015);  // Y wt,color\n    animate(orbit2.w,-3.,3.,0.017);\n    animate(orbit3.x,-0.,3.,0.019);  // Z wt,color\n    animate(orbit3.y,-3.,3.,0.021);\n    animate(orbit4.x,-3.,3.,0.023);  // center\n    animate(orbit4.y,-3.,3.,0.025);\n    animate(orbit4.z,-3.,3.,0.027);\n\n    color += vec3(0.4 + ostrength) + vec3(1.0 - (normal * vibrant + sqrt(float(iter) * dim)));\n    color = vec3(0.5) + (color - vec3(0.5)) * (contrast + Ostrength);\n\n    phongLight();\n    spotLight();\n    \n    if(ostrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        color = mix(color, oColor, ostrength);\n    }\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 5.0;\nconst float EPSILON = 0.001; \n\nvoid rayMarch() {\n    float distance;\n    position = qcamera.xyz;\n    iter = 0;\n    depth = MIN_DIST;\n    \n    orbitTrap = vec4(10000.);\n    \n    for(int i = 0;i < 50;++i) {\n        distance = DE_plusSpherical(position);\n        if(abs(distance) < EPSILON || depth > MAX_DIST) break;\n        iter += 1;\n        \n        depth += distance;\n        position += direction * distance;\n    }\n}\n\n// --------------------------------------------------------\n// normal vector for 3D coordinate determined by comparing values of neighboring positions\n\nvoid calcNormal() {\n    float ex = epsilon;\n    float ey = -ex;\n    vec3 pos = position;\n    \n    vec3 t1 = vec3( pos[0] + ex, pos[1] + ey, pos[2] + ey); float a1 = DE_plusSpherical(t1);\n    vec3 t2 = vec3( pos[0] + ey, pos[1] + ey, pos[2] + ex); float a2 = DE_plusSpherical(t2);\n    vec3 t3 = vec3( pos[0] + ey, pos[1] + ex, pos[2] + ey); float a3 = DE_plusSpherical(t3);\n    vec3 t4 = vec3( pos[0] + ex, pos[1] + ex, pos[2] + ex); float a4 = DE_plusSpherical(t4);\n\n    normal = normalize(vec3(\n        ex * a1 + ey * a2 + ey * a3 + ex * a4,\n        ey * a1 + ey * a2 + ex * a3 + ex * a4,\n        ey * a1 + ex * a2 + ey * a3 + ex * a4 ));\n}\n\n// --------------------------------------------------------\n// viewVectors already calculated in Buffer A\n\nvoid setDirection(vec2 fragCoord) {\n    // cross eyed stereo ------------------------------------\n    vec2 srcP = fragCoord;        // copy of pixel coordinate; x is altered for stereo\n    float xsize = iResolution.x;  // copy of window size; x is altered for stereo\n    \n    if(stereoEnable) {\n        vec3 soffset = sideVector * parallax;\n        xsize *= 0.5;             // window x size adjusted for 2 views side by side\n        if(srcP.x >= xsize) {     // right side of stereo pair?\n            srcP.x -= xsize;      // base 0  X coordinate\n            qcamera.xyz -= soffset;// adjust for right side parallax\n        }\n        else {\n            qcamera.xyz += soffset;// adjust for left side parallax\n        }\n    }\n    \n    vec2 vPos = (srcP - iResolution.xy * 0.5)/iResolution.y;\n    direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\n#ifdef USER_INTERFACE // ==========================================\n\nvoid loadDEParams() {\n    for(int i=0;i<QSIZE;++i)\n       q[i] = fetchData(iChannel0, storeAddr[i]);\n    \n    vec3 sd = fetchData(iChannel0, FOCUS_ADDR).xyz;\n    focus = int(sd.x);\n    displayCount = int(sd.y);\n\n    sd = fetchData(iChannel0, UNIFORM_1).xyz;\n    stereoEnable = bool(sd.x > 0.);\n\n    viewVector = fetchData(iChannel0, VV_1).xyz;\n    sideVector = fetchData(iChannel0, VV_2).xyz;\n    topVector = fetchData(iChannel0, VV_3).xyz;\n}\n\n#else // ==========================================================\n\nconst int iFramesPerKeyFrame = 400;  // # image frames between keyframes (for me: 30 == 1 second)\n\nvoid loadDEParams() {\n    int keyFrameIndex = (iFrame/iFramesPerKeyFrame) % keyFrameCount;\n    float ratio = float(iFrame % iFramesPerKeyFrame) / float(iFramesPerKeyFrame);\n    \n    loadKeyFrame(keyFrameIndex,ratio);\n    \n    \n    // fudge the data a little\n    for(int i=0;i<QSIZE;++i) {\n        float fi = float(i);\n        q[i] += sin(iTime * (0.1 + fi * 0.2)) * q[i] * 0.03;\n    }\n    \n    viewVector = normalize(q[9].xyz);  // aim\n    sideVector = normalize(cross(vec3(0.,1.,0.),viewVector));\n    topVector = cross(viewVector,sideVector);\n}\n\n#endif // USER_INTERFACE ============================================\n\n\n#ifdef CRYSTAL_EFFECT\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( length(orbitTrap)*10.*(c*t) );\n}\n\nvec3 doPalette( in float val , in mat4 pType) {\n  return palette( val ,  pType[0].xyz , pType[1].xyz , pType[2].xyz , pType[3].xyz );\n}\n\n#endif\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 U) {\n    loadDEParams();    \n    \n    ambient = 0.025;\n    contrast = 1.8;\n    vibrant = 0.01;\n    dim = 0.05;\n    \n    color = vec3(0.);\n    stereoEnable = iMouse.x > iResolution.x * 0.5;\n    \n    setDirection(U);\n    rayMarch();\n    \n    if(depth < MAX_DIST) {\n        calcNormal();\n \n#ifdef CRYSTAL_EFFECT\n        vec3 refr = refract(direction,normal, 1./1.1);\n        vec3 refl = normalize(reflect(vec3(0.,3.,0.),normal));\n \n        // when using 3D cubemaps \n        //vec3 refrCol = texture(iChannel2,refr).xyz;\n        //vec3 reflCol = texture(iChannel2,refl).xyz;\n        \n        // when using 2D textures\n        vec3 refrCol = texture(iChannel2,refr.xy).xyz;\n        vec3 reflCol = texture(iChannel2,refl.xy).xyz;\n        \n        float reflectVal = pow( max( 0., dot(refl,direction)), 20.);\n\n        const  mat4  paletteVal = mat4( .5 , .5 , .5 , 0.\n                 , .5 , .5 , .5 , 0.\n                 , 2. , 1. , 0. , 0.\n                 , .5 , .2 , .25 , 0.);\n        \n        vec3 palCol = doPalette(sin(iTime * .002) * 0.002, paletteVal);\n        vec3 refCol = doPalette( reflectVal , paletteVal ) * reflectVal;\n        color = refCol + (palCol * refrCol);\n#else\n        ambient = 0.5;\n        contrast = 1.2;\n        vibrant = 0.1;\n        dim = 0.04;\n#endif\n   \n        lighting();\n    }\n    \n    if(fogDistance != 0.0) {\n        float f = depth - fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * fogAmount);\n            color = mix(color, vec3(0.2 + f * fogColor),f);\n        }\n    }\n\n    O.xyz = color;\n\n    if(stereoEnable && abs(U.x - iResolution.x * 0.5) < 1.5) O = vec4(1.0);\n    \n#ifdef USER_INTERFACE    \n    if(displayCount > 0) {\n        displayData(iChannel3,iResolution.xy,focus,O,U);\n        console(O,U);\n    }\n#endif\n\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define USER_INTERFACE\n\nfloat ostrength = 0.;\nfloat ocycle = 0.;\nvec4 orbit2 = vec4( 0.38347405, 1.86336986, -0.01788503, -2.71105793);\nvec4 orbit3 = vec4(0.87534959, 1.04847687, 0.03234359, 0.00505466);\nvec3 orbit4 = vec3(-2.19183836, 1.41098694, 1.56200985);\nvec3 phongColor =  vec3(0.6,0.2,0.);\nvec3 phongPosition = vec3(1.,-2.,6.);\nvec3 phongParam = vec3(1.1,0.2,1.1);\nvec4 spotLightParam = vec4(0.,2.1,-4.,0.09);\nvec3 spotLightColor = vec3(0.783,0.422,0.0056);\n\n#define qshape  q[0]\n#define qscale  q[1]\n#define qsine   q[2]\n#define qoffset q[3]\n#define qslope  q[4]\n#define qangle  q[5]\n#define qinvpos q[6]\n#define qinvrad q[7]\n#define qcamera q[8]\n#define qaim    q[9]\n\nconst int QSIZE = 10;\nvec4 q[QSIZE];\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\n// ========================================================================\n#ifdef USER_INTERFACE\n\nconst vec4  qqshape  = vec4(1.04,7.43,-4.97,1.12);\nconst vec4  qqscale  = vec4(0.59,9.16,-0.6,1.29);\nconst vec4  qqsine   = vec4(1.29,-0.51,3.22,0.);\nconst vec4  qqoffset = vec4(-8.57,-7.59,-9.99,0.);\nconst vec4  qqslope  = vec4(2.36,-0.07,2.85,0.);\nconst vec4  qqangle  = vec4(0.97,5.,0.,0.);\nconst vec4  qqinvpos = vec4(-1.69,1.28,-0.13,0.);\nconst vec4  qqinvrad = vec4(1.28,3.03,0.,0.);\nconst vec4  qqcamera = vec4(-1.15,1.1,-0.29,0.);\nconst vec4  qqaim    = vec4(-9.49,2.56,2.98,0.);\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\n// leave room for future entries without having to adjust hardwired array positions\n#define UNUSED  9.9\n#define UNUSEDP ParamData(UNUSED,UNUSED,UNUSED,UNUSED)\n\nconst ParamData[] pData = ParamData[]( \n    //  0 p0 shape ---------------\n    ParamData(qqshape.x, -10.,10.,0.01),\n    ParamData(qqshape.y, -10.,10.,0.01),\n    ParamData(qqshape.z, -10.,10.,0.01),\n    ParamData(qqshape.w, -10.,10.,0.01),\n    //  4 p1 scale ---------------\n    ParamData(qqscale.x, -10.,10.,0.01),\n    ParamData(qqscale.y, -10.,10.,0.01),\n    ParamData(qqscale.z, -10.,10.,0.01),\n    UNUSEDP,\n    //  8 p2 sine ---------------\n    ParamData(qqsine.x, -10.,10.,0.01),\n    ParamData(qqsine.y, -10.,10.,0.01),\n    ParamData(qqsine.z, -10.,10.,0.01),\n    UNUSEDP,\n    // 12 p3 offset ---------------\n    ParamData(qqoffset.x, -10.,10.,0.01),\n    ParamData(qqoffset.y, -10.,10.,0.01),\n    ParamData(qqoffset.z, -10.,10.,0.01),\n    UNUSEDP,\n    // 16 p4 slope ---------------\n    ParamData(qqslope.x, -10.,10.,0.01),\n    ParamData(qqslope.y, -10.,10.,0.01),\n    ParamData(qqslope.z, -10.,10.,0.01),\n    UNUSEDP,\n    // 20 p5 angle ---------------\n    ParamData(qqangle.x, -10.,10.,0.01),\n    ParamData(qqangle.y, -10.,10.,0.01),\n    UNUSEDP,\n    UNUSEDP,\n    // 24 p6 invpos ---------------\n    ParamData(qqinvpos.x, -10.,10.,0.01),\n    ParamData(qqinvpos.y, -10.,10.,0.01),\n    ParamData(qqinvpos.z, -10.,10.,0.01),\n    UNUSEDP,\n    // 28 p7 invradius,angle---------------    \n    ParamData(qqinvrad.x, -10.,10.,0.01),\n    ParamData(qqinvrad.y, -10.,10.,0.01),\n    UNUSEDP,\n    UNUSEDP,\n    // 32 p8 camera ---------------\n    ParamData(qqcamera.x, -20., 20., 0.01), \n    ParamData(qqcamera.y, -20., 20., 0.01), \n    ParamData(qqcamera.z, -20., 20., 0.01), \n    UNUSEDP,\n    // 36 p9 aim ---------------\n    ParamData(qqaim.x, -20., 20., 0.01), \n    ParamData(qqaim.y, -20., 20., 0.01), \n    ParamData(qqaim.z, -20., 20., 0.01), \n    UNUSEDP\n); \n\nconst int PDATA_SIZE = 40;\n\nconst int indexInversion = 20;\nconst int indexCamera = 32;\nconst int indexAim = 36;\n\nconst ivec2 FOCUS_ADDR = ivec2(1, 0);\nconst ivec2 P0_ADDR =  ivec2( 2, 0);\nconst ivec2 P1_ADDR =  ivec2( 3, 0);\nconst ivec2 P2_ADDR =  ivec2( 4, 0);\nconst ivec2 P3_ADDR =  ivec2( 5, 0);\nconst ivec2 P4_ADDR =  ivec2( 6, 0);\nconst ivec2 P5_ADDR =  ivec2( 7, 0); \nconst ivec2 P6_ADDR =  ivec2( 8, 0); \nconst ivec2 P7_ADDR =  ivec2( 9, 0); \nconst ivec2 P8_ADDR =  ivec2(10, 0); \nconst ivec2 P9_ADDR =  ivec2(11, 0); \nconst ivec2 UNIFORM_1= ivec2(12, 0); // booleans\nconst ivec2 VV_1     = ivec2(13, 0); // view vectors\nconst ivec2 VV_2     = ivec2(14, 0);\nconst ivec2 VV_3     = ivec2(15, 0);\n\nconst ivec2[] storeAddr = ivec2[](\n    P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR,P7_ADDR,P8_ADDR,P9_ADDR);\n\n// =======================================================================\n// font display technique I learned from cmgz's \"The Chaos factory\".  Thank you sir.\n// https://www.shadertoy.com/view/XfdyRX\n\nfloat drawChar(sampler2D chan,vec2 char_p, int char_id) { // https://www.shadertoy.com/view/llySRh\n    if (char_p.x < .0 || char_p.x>1. || char_p.y<0. || char_p.y>1.) return 0.;\n    vec2 p = char_p/16.; \n    return textureGrad(chan, p + fract(vec2(char_id,15-char_id/16)/16.), dFdx(p), dFdy(p)).x;\n}\n\nvoid printChar(sampler2D chan,inout vec2 position,int ascii,inout float result) {\n    result = max(result, drawChar(chan,position,ascii));\n    position.x -= 0.5;\n}\n\n#define printString(chan,position,asciiArray,result) for(int i=0;i< asciiArray.length();i++) printChar(chan,position,asciiArray[i],result);\n\nvoid printInt(sampler2D chan,inout vec2 position,int value, inout float result) {\n    int[8] digits;\n    int count = 0;\n    if(value < 0) { printChar(chan,position,45,result);  value = -value; }\n    \n    for(;;) {\n        digits[count] = value % 10;        \n        if(++count >= 8) break;\n        \n        value /= 10;        \n        if(value == 0) break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(chan,position,48+digits[i],result);\n}\n\nvoid printFloat(sampler2D chan,inout vec2 position,float value, inout float result) {\n    if(value < 0.) { printChar(chan,position,45,result); value = -value; }        \n    int i = int(value);\n    printInt(chan,position,i,result);\n    printChar(chan,position,46,result);\n    i = int(fract(value) * 1000.);\n    printInt(chan,position,i,result);\n}\n\n// 0123456789 +-.[]  48..57,  43,45,46,91,92\n// A65,B66,C67,D68, E69, F70, G71, H72, I73, J74, K75, L76, M77, N78, O79, P80, Q81, R82, S83, T84, U85, V86, W87, X88, Y89, Z90\n// a97,b98,c99,d100,e101,f102,g103,h104,i105,j106,k107,l108,m109,n110,o111,p112,q113,r114,s115,t116,u117,v118,w119,x120,y121,z122\n\nconst int tShapeX[] = int[](83,104,97,112,101,88);\nconst int tShapeY[] = int[](83,104,97,112,101,89);\nconst int tShapeZ[] = int[](83,104,97,112,101,90);\nconst int tShapeW[] = int[](83,104,97,112,101,87);\nconst int tScaleX[] = int[](83,99,97,108,101,88);\nconst int tScaleY[] = int[](83,99,97,108,101,89);\nconst int tScaleZ[] = int[](83,99,97,108,101,90);\nconst int tSineX[] = int[](83,105,110,101,88);\nconst int tSineY[] = int[](83,105,110,101,89);\nconst int tSineZ[] = int[](83,105,110,101,90);\nconst int tOffsetX[] = int[](79,102,102,115,101,116,88);\nconst int tOffsetY[] = int[](79,102,102,115,101,116,89);\nconst int tOffsetZ[] = int[](79,102,102,115,101,116,90);\nconst int tSlopeX[] = int[](83,108,111,112,101,88);\nconst int tSlopeY[] = int[](83,108,111,112,101,89);\nconst int tSlopeZ[] = int[](83,108,111,112,101,90);\nconst int tAngle1[] = int[](65,110,103,108,101,49);\nconst int tAngle2[] = int[](65,110,103,108,101,50);\nconst int tInvposX[] = int[](73,110,118,112,111,115,88);\nconst int tInvposY[] = int[](73,110,118,112,111,115,89);\nconst int tInvposZ[] = int[](73,110,118,112,111,115,90);\nconst int tInvRad[] = int[](73,110,118,114,97,100);\nconst int tInvAng[] = int[](73,110,118,65,110,103);\nconst int tCameraX[] = int[](67,97,109,101,114,97,88);\nconst int tCameraY[] = int[](67,97,109,101,114,97,89);\nconst int tCameraZ[] = int[](67,97,109,101,114,97,90);\nconst int tAimX[] = int[](65,105,109,88);\nconst int tAimY[] = int[](65,105,109,89);\nconst int tAimZ[] = int[](65,105,109,90);\n\nconst float textSize = 13.; // smaller value -> larger text   \nconst vec2 textUL = vec2(1.78,-0.88);\n\n#define Entry(legend,value) \\\n    printString(channel,p2,legend,char_d); \\\n    printChar(channel,p2,32,char_d); \\\n    printFloat(channel,p2,value,char_d); \\\n    entry = true;\n\nvoid displayData(sampler2D channel, vec2 R, int focusIndex, inout vec4 O, vec2 U) {\n    vec2 uv = (2.0 * U - R.xy)/R.y;   // screen resolution\n    vec2 p2,p = textSize * (textUL + uv);\n    vec3 col = vec3(0.);\n    bool entry;\n    float char_d = 0.;\n    \n    for(int i=0;i< PDATA_SIZE;++i) {\n        entry = false;\n        p2 = p;\n        \n        switch(i) {\n            case 0 : Entry(tShapeX,qshape.x); break;\n            case 1 : Entry(tShapeY,qshape.y); break;\n            case 2 : Entry(tShapeZ,qshape.z); break;\n            case 3 : Entry(tShapeW,qshape.w); break;\n            case 4 : Entry(tScaleX,qscale.x); break;\n            case 5 : Entry(tScaleY,qscale.y); break;\n            case 6 : Entry(tScaleZ,qscale.z); break;\n            case 8 : Entry(tSineX,qsine.x); break;\n            case 9 : Entry(tSineY,qsine.y); break;\n            case 10: Entry(tSineZ,qsine.z); break;\n            case 12: Entry(tOffsetX,qoffset.x); break;\n            case 13: Entry(tOffsetY,qoffset.y); break;\n            case 14: Entry(tOffsetZ,qoffset.z); break;\n            case 16: Entry(tSlopeX,qslope.x); break;\n            case 17: Entry(tSlopeY,qslope.y); break;\n            case 18: Entry(tSlopeZ,qslope.z); break;\n            case 20: Entry(tAngle1,qangle.x); break;\n            case 21: Entry(tAngle2,qangle.y); break;\n            case 24: Entry(tInvposX,qinvpos.x); break;\n            case 25: Entry(tInvposY,qinvpos.y); break;\n            case 26: Entry(tInvposZ,qinvpos.z); break;\n            case 28: Entry(tInvRad,qinvrad.x); break;\n            case 29: Entry(tInvAng,qinvrad.y); break;\n            case 32: Entry(tCameraX,qcamera.x); break;\n            case 33: Entry(tCameraY,qcamera.y); break;\n            case 34: Entry(tCameraZ,qcamera.z); break;\n            case 36: Entry(tAimX,qaim.x); break;\n            case 37: Entry(tAimY,qaim.y); break;\n            case 38: Entry(tAimZ,qaim.z); break;\n        }\n\n        if(entry) {\n            if(char_d > 0.5) {\n                col = (i == focusIndex) ? vec3(1.,0.,0.) : vec3(1.);    \n                O = vec4(col,1.0);\n                return;\n            }\n        \n            p.y += 0.84;\n        }\n    }\n}\n\n// COLOR CODED CONSOLE =============================================================\n#define _MINUS   10\n#define _DECIMAL 11\n#define _COMMA   12\n#define _CR      13\n#define _SPC     14\n#define _END     15\n#define DP_MAXLENGTH 500\n\nstruct Chars {\n    int[DP_MAXLENGTH+1] data;\n    int index;\n}; \n\nbool printFloat2(inout Chars c,float val,int fCount) {\n    if(c.index >= DP_MAXLENGTH - 15) return false; // nearing buffer overflow\n        \n    // truncate digits\n    int t = int(val * 1000.0);\n    val = float(t) * 0.001;    \n    \n    if(val < 0.) {\n        c.data[c.index++] =_MINUS;\n        val = -val;\n    }\n    \n    int[8] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;) {\n        digits[count++] = iVal % 10;\n        if(count >= 8) break;\n        iVal /= 10;\n        if(iVal == 0) break;\n    }    \n    for(int i = count-1; i >= 0; i--)\n        c.data[c.index++] = digits[i];\n        \n    if(fCount == 0) return true;\n    \n    c.data[c.index++] = _DECIMAL;\n        \n    for(int i = 0; i < fCount;++i) {\n        val *= 10.0;\n        int digit = int(val);\n        c.data[c.index++] = digit;\n        val -= float(digit);\n        if(val <= 0.0) break;\n    }\n    \n    return true; \n}\n\nbool printFloat(inout Chars c,float val) { return printFloat2(c,val,2); }\nbool printInt(  inout Chars c,int val)   { return printFloat2(c,float(val),0); }\n\nvoid console(inout vec4 fragColor, vec2 fragCoord) {\n\n    if(fragCoord.y >= 10.) return;\n\n    Chars chr;\n    chr.index = 0;\n\n    // encode your data in the buffer ----------\n    for(int i=0;i<QSIZE;++i) {\n        for(int j=0;j<4;++j) {\n            if(!printFloat(chr,q[i][j])) break;\n            chr.data[chr.index++] = _COMMA;\n            chr.data[chr.index++] = _SPC;\n        }\n    }\n\n    for(int i=0;i<3;++i) \n        chr.data[chr.index++] = _END;  // signal console to stop parsing the pixels\n\n    // ------------------------------------------\n    // all data is encoded in the buffer.\n    // now grab the value assigned to the current pixel \n    fragColor = vec4(0.,0.,0.,1.);\n\n    int index = int(fragCoord.x) / 3;       // each character cell is drawn 3 pixel wide\n\n    if(index < chr.index) {                \n        int v = chr.data[index];            // 0 ... 15\n        fragColor.z = float(v & 3) * 0.25;  // low 2 bits\n        v >>= 2;\n        fragColor.y = float(v & 3) * 0.25;  // high 2 bits        \n    }\n}\n\n#endif // USER_INTERFACE","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef USER_INTERFACE\n\nvoid initializeStorage(inout vec4 O,vec2 U) {\n    if (storeDataAddr(U, FOCUS_ADDR)) O.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<QSIZE;++i) {\n        if(storeDataAddr(U, storeAddr[i])) {\n            O = vec4(0.);\n            if(pIndex+0 < PDATA_SIZE) O.x = pData[pIndex+0].start;\n            if(pIndex+1 < PDATA_SIZE) O.y = pData[pIndex+1].start;\n            if(pIndex+2 < PDATA_SIZE) O.z = pData[pIndex+2].start;\n            if(pIndex+3 < PDATA_SIZE) O.w = pData[pIndex+3].start;\n        }\n        \n        pIndex += 4;\n    }\n}\n\n// --------------------------------------------------------\n// determine these values as seldom as possible to save work for image shader\n\nvoid updateViewVectors(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, VV_1) || storeDataAddr(fragCoord, VV_2) || storeDataAddr(fragCoord, VV_3)) {\n        vec3 viewVector = normalize(fetchData(iChannel0, P9_ADDR).xyz);  // aim\n        vec3 sideVector = normalize(cross(vec3(0.,1.,0.),viewVector));\n        vec3 topVector = cross(viewVector,sideVector);\n        \n        if(storeDataAddr(fragCoord, VV_1)) fragColor = vec4(viewVector,1.);\n        if(storeDataAddr(fragCoord, VV_2)) fragColor = vec4(sideVector,1.);\n        if(storeDataAddr(fragCoord, VV_3)) fragColor = vec4(topVector,1.);\n    }\n}\n\n// --------------------------------------------------------\n// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT  = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT  = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nbool alterFocusedVariable(int focus,int axis) {\n    if(focus > PDATA_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 4;  // memory index\n    int focusField = focus % 4;  // x,y,z,w field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        q[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.001;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n                if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = -delta.y; // flip Y axis\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            q[focusIndex][focusField] += changeAmount;\n        }\n    }\n       \n    q[focusIndex][focusField] = clamp(q[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = vec4(0.); \n    if(U.x > 30.0 || U.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 2 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(O,U);\n        return; \n    }\n           \n    updateViewVectors(O,U);\n    \n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry)\n           \n    // fetch current values\n    for(int i=0;i<QSIZE;++i) {\n        q[i] = fetchData(iChannel0, storeAddr[i]);\n      \n      // animate\n      //if(i < QSIZE - 2) // not camera,aim\n      //    q[i] *= (1. + sin(iTime * float(i) * 0.03) * (0.00003 + float(i) * 0.00001));\n    }\n    \n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    //-------------\n    // if <Alt><Shift> alter target position.xy regardless of focus    \n    if(getKeyState(KEY_SHIFT) && getKeyState(KEY_ALT)) \n        focus = indexAim;\n    else\n    \n    // if <Shift> alter camera position.xy regardless of focus\n    if(getKeyState(KEY_SHIFT)) \n        focus = indexCamera;\n    //-------------\n    \n    if(alterFocusedVariable(focus,  0)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1)) resetDisplayCount = true;\n    \n    // output possibly altered values0-----------\n    for(int i=0;i<QSIZE;++i)\n        if (storeDataAddr(U, storeAddr[i])) \n            O = q[i];\n    // ==========================================================       \n\n    // alter focus.  update displayCount --------\n    if (storeDataAddr(U, FOCUS_ADDR)) {\n        O = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange == 0. && (iFrame % 12 == 0)) { // slow down auto repeat of up/dn arrows\n            if(getKeyState(KEY_UP))   focusChange = -1.;\n            if(getKeyState(KEY_DOWN)) focusChange = +1.;\n        }\n\n        if(focusChange != 0.) {\n        \n            //skip past UNUSED rows\n            while(true) {\n                O.x += focusChange;\n                if(O.x < 0.0) O.x = float(PDATA_SIZE-1); else\n                if(O.x >= float(PDATA_SIZE)) O.x = 0.0;\n                \n                if(pData[int(O.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) O.y = iFrameRate * 2.; else\n        if(--O.y < 0.0) O.y = 0.0;  // so widget display times out \n    }   \n      \n    // ---------------------------------------------------\n    if (storeDataAddr(U, UNIFORM_1)) {\n        O = fetchData(iChannel0, UNIFORM_1); \n        if(iFrame < 10) \n            O.xyz = vec3(0.);\n        else {\n            if(getKeyClick(83)) O.x = (O.x == 0.) ? 1. : 0.; // S\n        }\n    }\n}\n\n#else\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = vec4(0.); \n}\n\n#endif // USER_INTERFACE","name":"Buffer A","description":"","type":"buffer"}]}