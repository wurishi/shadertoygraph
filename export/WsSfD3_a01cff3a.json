{"ver":"0.1","info":{"id":"WsSfD3","date":"1590934732","viewed":49,"name":"Phong Spheres","username":"Helliaca","description":"phong spheres","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Constants #######################################################################\n\nconst vec3 cameraPos = vec3(0.0, 1.3, 0.0);\t// Position of the camera in world space\nconst vec3 viewPlane = cameraPos + vec3(0.0, 0.0, 1.0);\t// Position of the view-plane in world space (point that camera is looking at)\n#define noMat Material(0.0, 0.0, 0.0, 0.0, vec3(0.0, 0.0, 0.0))\n\n\n\n// Structs #########################################################################\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    vec3 att; //constant, linear, quadratic attenuation factors\n};\n\nstruct Material {\n    float ambient_str;\n    float diffuse_str;\n    float specular_str;\n    float shininess;\n    vec3 color;\n};\n\nstruct Plane {\n    vec3 pos;\n    vec3 nrm;\n    Material mat;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float r;\n    Material mat;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Hit {\n    bool hit;\n    vec3 pos;\n    vec3 nrm;\n    Material mat;\n};\n    \n    \n    \n// Scene Objects ####################################################################\n    \n//Lights\nLight lights[] = Light[](\n    //    position             //color              //attenuation\n    Light(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 0.5, 0.5)),\t// Moving white Light\n    Light(vec3(-1.5, 0.0, -1.5), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.2, 0.2)),\t// Red light bottom left\n    Light(vec3(1.5, 0.0, -1.5), vec3(0.0, 0.8, 0.0), vec3(0.0, 0.2, 0.2)),\t// Green light bottom right\n    Light(vec3(0.0, 2.5, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.5))\t// Blue light top blinking\n);\n    \n// Planes\nPlane planes[] = Plane[](\n    //    position             // surface-normal    //mat    //a  //d  //s  //sh  //color\n    Plane(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), Material(0.1, 1.0, 1.0, 32.0, vec3(1.0, 1.0, 1.0)) ),\n    Plane(vec3(-2.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), Material(0.1, 1.0, 1.0, 32.0, vec3(1.0, 1.0, 1.0)) ),\n    Plane(vec3(2.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), Material(0.1, 1.0, 1.0, 32.0, vec3(1.0, 1.0, 1.0)) )\n);\n\nSphere spheres[] = Sphere[](\n    //     position                //r   //mat    //a  //d  //s  //sh  //color\n    Sphere(vec3(-1.50, 0.3, -3.0), 0.3f, Material(0.08, 0.0, 3.0, 512.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(-1.50, 1.0, -3.0), 0.3f, Material(0.08, 1.0, 0.5, 016.0, vec3(1.0, 0.3, 3.3)) ),\n    Sphere(vec3(-1.50, 1.7, -3.0), 0.3f, Material(0.08, 1.0, 5.0, 016.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(-1.50, 2.4, -3.0), 0.3f, Material(0.08, 1.0, 0.0, 002.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(-0.75, 0.3, -3.0), 0.3f, Material(0.08, 1.0, 0.2, 064.0, vec3(0.0, 1.0, 0.0)) ),\n    Sphere(vec3(-0.75, 1.0, -3.0), 0.3f, Material(0.08, 1.0, 1.0, 032.0, vec3(0.5, 0.5, 0.5)) ),\n    Sphere(vec3(-0.75, 1.7, -3.0), 0.3f, Material(0.50, 1.0, 5.0, 128.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(-0.75, 2.4, -3.0), 0.3f, Material(0.08, 0.1, 8.0, 001.0, vec3(0.0, 1.0, 1.0)) ),\n    Sphere(vec3(00.00, 0.3, -3.0), 0.3f, Material(0.50, 0.1, 0.5, 032.0, vec3(1.0, 1.0, 0.0)) ),\n    Sphere(vec3(00.00, 1.0, -3.0), 0.3f, Material(0.08, 1.0, 1.0, 032.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(00.00, 1.7, -3.0), 0.3f, Material(0.08, 1.0, 0.0, 016.0, vec3(0.2, 0.2, 0.2)) ),\n    Sphere(vec3(00.00, 2.4, -3.0), 0.3f, Material(0.08, 2.5, 0.1, 001.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(00.75, 0.3, -3.0), 0.3f, Material(0.08, 0.6, 0.1, 128.0, vec3(0.9, 0.2, 0.2)) ),\n    Sphere(vec3(00.75, 1.0, -3.0), 0.3f, Material(0.25, 1.0, 0.1, 001.0, vec3(0.24, 0.14, 0.0)) ),\n    Sphere(vec3(00.75, 1.7, -3.0), 0.3f, Material(0.08, 1.0, 1.0, 016.0, vec3(1.0, 0.0, 0.0)) ),\n    Sphere(vec3(00.75, 2.4, -3.0), 0.3f, Material(0.15, 1.5, 1.0, 128.0, vec3(0.0, 1.0, 0.35)) ),\n    Sphere(vec3(01.50, 0.3, -3.0), 0.3f, Material(0.08, 1.0, 9.0, 001.0, vec3(0.01, 0.01, 0.01)) ),\n    Sphere(vec3(01.50, 1.0, -3.0), 0.3f, Material(0.00, 0.7, 0.0, 032.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(01.50, 1.7, -3.0), 0.3f, Material(0.20, 0.8, 1.0, 128.0, vec3(1.0, 0.7, 0.2)) ),\n    Sphere(vec3(01.50, 2.4, -3.0), 0.3f, Material(0.08, 1.0, 1.0, 002.0, vec3(0.0, 0.0, 1.0)) ) \n);\n\n\n\n// Math ######################################################################\n\n// Returns point where a ray intersects a given plane p\nHit ray_plane(Ray r, Plane p) {    \n    // Check if ray is parallel to plane\n    if(dot(p.nrm, r.dir)==0.0) return Hit(false, vec3(0.0), vec3(0.0), noMat);\n    \n    // See: https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n    float d = dot((p.pos-r.origin), p.nrm) / dot(r.dir, p.nrm);\n    if(d<=0.0) return Hit(false, vec3(0.0), vec3(0.0), noMat); //collision *behind* origin -> no collision\n    return Hit(true, r.origin + d*r.dir, p.nrm, p.mat);\n}\n\n// Returns points where a ray intersects a given sphere sph\nHit ray_sphere(Ray r, Sphere sph) {\n    // A sphere is characterized by dot(P-s_origin, P-s_origin) - r^2 = 0\n    // A ray is characterized by p(t) = r_origin + t*dir\n    // Inserting p(t) into P of the sphere equation yields: dot(p(t)-s_origin, p(t)-s_origin) - r^2 = 0\n    // When expanded and solved for t we get following: http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/\n    float a = dot(r.dir, r.dir);\n    vec3 so_ro = r.origin - sph.pos;\n    float b = 2.0 * dot(r.dir, so_ro);\n    float c = dot(so_ro, so_ro) - (sph.r * sph.r);\n    \n    float disr = b*b - 4.0*a*c; //discriminant\n    \n    // Doesn't hit\n    if (disr < 0.0) {\n        return Hit(false, vec3(0.0), vec3(0.0), noMat);\n    }\n    // hits\n    vec3 hitpos = r.origin + r.dir*(-b - sqrt(disr))/(2.0*a);\n    vec3 normal = normalize(hitpos-sph.pos);\n    return Hit(true, hitpos, normal, sph.mat);\n}\n\n\n\n// Shading ######################################################################\n\nvec3 phong(vec3 pos, vec3 nrm, Material mat, Light light, vec3 viewPos) {\n    // Ambient\n    vec3 ambient = mat.ambient_str * light.color;\t\t\t// ambient color\n  \t\n    // Diffuse\n    vec3 lightDir = normalize(light.pos - pos);\t\t\t\t// Direction of lightsource\n    float diff = max(dot(nrm, lightDir), 0.0);\t\t\t\t// diffuse factor\n    vec3 diffuse = mat.diffuse_str * diff * light.color;\t// diffuse color\n\n    // Glossy\n    vec3 viewDir = normalize(viewPos - pos);\t\t\t\t// View direction\n    vec3 reflectDir = reflect(-lightDir, nrm); \t\t\t\t// Perfect reflectance direction \n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), 8.0); // specular factor\n    vec3 specular = mat.specular_str * spec * light.color;  // Specular color\n\n    // Attenuation (Const. Lin. Quadratic)\n    float dist = length(light.pos - pos);\n    float attenuation = 1.0f / (light.att.x + light.att.y * dist + light.att.z * (dist * dist));\n    \n    // Final result\n    return (ambient + diffuse + specular) * mat.color * attenuation;\n}\n\n// Returns a ray through any given fragment coordinate of a virtual camera\nRay cameraRay(vec2 fragCoord) {\n    // Viewplane x-Axis is cross product of global up-Vector and camera forward vector\n    vec3 xvec = normalize(cross(vec3(0.0, 1.0, 0.0), cameraPos-viewPlane));\n    // Viewplane y-Axis is cross product of viewplane x-Axis and camera forward vector\n    vec3 yvec = normalize(cross(xvec, cameraPos-viewPlane));\n    \n    vec2 uv = fragCoord/iResolution.xy; \t// Normalized screen coordiantes [0, 1]\n    uv -= 0.5;\t\t\t\t\t\t\t\t// Screen coordiantes centered [0,1] -> [-0.5, 0.5]\t\n    uv.x *= iResolution.x / iResolution.y; \t// Apply aspect ration of resolution\n    \n    // Get virtual pixel position on virtual screen at viewPlane in world space\n    vec3 vpp = viewPlane + xvec*uv.x + yvec*uv.y;\n    // This gives us the desired ray direction\n    vec3 rayDir = cameraPos - vpp;\n    \n    return Ray(cameraPos, rayDir);\n}\n\n// Returns closest collision point of any given ray on all objects\nHit rayTrace(Ray ray) {\n    // Set some non-collision point very far away as the closest\n    Hit closest = Hit(false, vec3(9999.0, 9999.0, 9999.0), vec3(0), noMat);\n    \n    // Trace to each sphere, if collision -> keep closest point  to ray-origin\n    for(int i=0; i<spheres.length(); i++) {\n        Hit h = ray_sphere(ray, spheres[i]);\n        if(h.hit && length(h.pos - ray.origin) < length(closest.pos - ray.origin)) {\n            closest = h;\n        }\n    }\n    \n    // Trace to each plane, if collision -> keep closest point  to ray-origin\n    for(int i=0; i<planes.length(); i++) {\n        Hit h = ray_plane(ray, planes[i]);\n        if(h.hit && length(h.pos - ray.origin) < length(closest.pos - ray.origin)) {\n            closest = h;\n        }\n    }\n    \n    return closest;\n}\n\n// Move lights over time\nvoid updateLights() {\n    lights[0].pos = vec3(1.9*sin(iTime), 1.5, -3.0+1.3*cos(iTime));\n    lights[3].color.b = sin(iTime*0.8f);    \n}\n\n\n// Main shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    updateLights();\n    \n    // Trace a ray through the respective pixel\n    Hit h = rayTrace(cameraRay(fragCoord));\n    \n    // If we hit something, calculate respective phong color\n    //if(h.hit) fragColor = vec4(phong(h.pos, h.nrm, vec3(0.0, 1.0, 0.0)) ,1.0);    \n    //else fragColor = vec4(0.0);\n    \n    vec3 col = vec3(0.0);\n    if(h.hit) {\n    \tfor(int i=0; i<lights.length(); i++) {\n        \tcol += phong(h.pos, h.nrm, h.mat, lights[i], cameraPos);\n    \t}\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}