{"ver":"0.1","info":{"id":"Xfy3zt","date":"1713130096","viewed":33,"name":"Sphere on surface with light","username":"SilverMetz","description":"This time the sphere on a surface","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["light","sphere","surface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Volgende values gebruikt voor Ray Marching\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//Afstand tussen gegeven punt en ofwel de bol of het vlakke oppervlak\nfloat getDist(vec3 p) {\n\tvec4 s = vec4(0, 2, 8, 2);//waarden van de bol (x, y, z, w) = (middelpunt waar tov breedte billboard, middelpunt waar tov hoogte billboard, middelpunt waar tov diepte billboard, straal van bol)\n    \n    float sphereDist =  length(p-s.xyz)-s.w;//standaardformule voor berekenen afstand tussen punt p en de bol\n    float planeDist = p.y;//standaardformule afstand punt p tot vlakke ondergrond (letterlijk de hoogte van dat punt)\n    \n    float d = min(sphereDist, planeDist);//De kleinste afstand geldt, want het gaat om min. afstand tussen punt p en het eerste op het pad van punt p.\n    \n    return d;\n}\n\n//Berekent lengte van een lichtstraal vanuit ro (point of origin) naar rd (point of destination), is een standaardalgoritme. Doet dit door stapsgewijs langs de lichtstraal te bewegen.\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;//beginnen met lengte 0, wordt later aangepast\n    \n    for(int i=0; i<MAX_STEPS; i++) { //for loop, max 100 keer herhalen is genoeg, anders te langzaam\n    \tvec3 p = ro + rd*dO; //vector berekenen van positie p op de lichtstraal vanuit plaatsvector ro, met richting rd, keer de telkens berekende d0.\n        float dS = getDist(p);//Lengte van vector p berekenen, geeft de huidig afgelegde afstand van de vector in deze ronde van de for loop.\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;//als d0>MAX_DIST, dan bereikt lichtstraal nooit een object, dus blijft die pixel donker, als SURF_DIST is bereikt, dan is de afgelegde afstand van de straal tot een oppervlak erg klein in de huidige stap en dit betekent dat de lichtstraal een opperval heeft geraakt. Dan wordt d0 teruggegeven.\n    }\n    \n    return dO;\n}\n\n//Berekent richtingsvectoren in het huidige punt. (richting breedte, hoogte, diepte)\nvec3 GetNormal(vec3 p) {\n\tfloat d = getDist(p); //lengte vector p\n    vec2 e = vec2(0.01, 0);//e wordt gebruikt om de afzonderlijke x, y, z richtingen te bepalen\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),//richtingsvector breedte (x)\n        getDist(p-e.yxy),//richtingsvector hoogte (y)\n        getDist(p-e.yyx));//richtingsvector diepte(z)\n    \n    return normalize(n); //Richtingsvector, dus lengte 1 is handig\n}\n\nfloat GetLight(vec3 p) {\n    const vec3 lightPos = vec3(3, 7, 6); // Positie van de lichtbron (breedte, hoogte, diepte)\n\n    //Richting van het licht (richtingsvector) tussen lichtbron en gegeven punt p\n    vec3 lightDir = normalize(lightPos - p);\n\n    //Richtingsvector van het punt p\n    vec3 n = GetNormal(p);\n    \n    //Cosinus van hoek tussen richtingsvector van het licht en van het punt p berekenen, clamp om zeker te weten dat het tussen 0 en 1 ligt (er kunne altijd fouten optreden).\n    float diffuse = clamp(dot(n, lightDir), 0.0, 1.0);\n\n    //Met rayMarch lengte berekenen van een lichtstraal vanuit het huidige punt, richting de lichtbron, tot aan het eerste oppervlak in de weg van de lichtstraal.\n    float shadowFactor = rayMarch(p + n * SURF_DIST * 2.0, lightDir);\n    \n    //Als de lengte van die (onzichtbare) lichtstraal korter is dan de lengte van de werkelijke lichtbron naar punt p, dan ligt er een object in de weg en is er dus schaduw zichtbaar.\n    if (shadowFactor < length(lightPos - p)) {\n        diffuse *= 0.1; // Diffuse wordt klein gemaakt, zorgt voor schaduw-effect.\n    }\n\n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;//Allereerst moeten de pixels genormaliseerd worden. Elk scherm is anders, de lengte en breedte van het scherm spelen altijd een rol bij het renderen. UV zijn de coordinaten van de huidige pixel, tov het scherm.\n\n    vec3 color = vec3(0);//De kleurvector initializeren met (0, 0, 0), makkelijker om later mee te werken.\n    \n    vec3 rOrigin = vec3(1, 4, 0);//Positie van de camera\n    \n    // Snelheid waarmee camera beweegt\n    float rotationSpeed = 0.5;\n    \n    // Camerapositie telkens opnieuw berekenen, op basis van de tijd.\n    rOrigin = vec3(\n        cos(iTime * rotationSpeed) * 4.0,  // X-coordinaat (rondom bol)\n        4.0,                                 // Y-coordinaat (vaste hoogte)\n        sin(iTime * rotationSpeed) * 4.0    // Z-coordinaat (rondom de bol)\n    );\n    \n    \n    vec3 rDestination = normalize(vec3(uv.x-.15, uv.y-.2, 1));//Richting van de huidige lichtstraal berekenen.\n\n    float rDist = rayMarch(rOrigin, rDestination); //rayMarch berekent de afgelegde afstand van een lichtstraal voor deze iets raakt\n    \n    vec3 p = rOrigin + rDestination * rDist;//Punt berekenen waar de lichtstraal een object raakt, met behulp van de raymarch values.\n    \n    float dif = GetLight(p);//De waarde van het licht in de huidige pixel berekenen.\n    color = vec3(dif);//Deze waarden toevoegen aan de kleurvector\n    \n    color = pow(color, vec3(.8));//Gamma-correctie om de lichtsterktes en over- of onderbelichting te voorkomen.\n    \n    fragColor = vec4(color,1.0);//Shaders outputten maar 1 ding: de rgba waarden van de pixel waar het programma nu draait: fragColor\n}","name":"Image","description":"","type":"image"}]}