{"ver":"0.1","info":{"id":"MfdBz4","date":"1732799490","viewed":32,"name":"rabbit sound wave","username":"pascalchang","description":"rabbit sound wave","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sound","wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.14159265359\n\n// 圆环参数\nconst float circleSize = 0.5; // 控制整体圆圈大小\nfloat innerRadius = 0.46 * circleSize;\nfloat outerRadius = 0.5 * circleSize;\nconst int segments = 365;\n\n// 动态延伸参数\nconst float earSize = 0.8; // 控制耳朵大小\nfloat extendFactor = 1.1 * earSize;\nfloat extendSpeed = 0.5;\nfloat minExtend = 1.0;\nfloat maxExtend = 1.6 * earSize;\n\nfloat extendFactor1 = 1.1;\nfloat extendSpeed1 = 0.3;\nfloat minExtend1 = 1.0;\nfloat maxExtend1 = 1.3;\n\n// 耳朵角度范围\nfloat rightEarMinAngle = 45.0;\nfloat rightEarMaxAngle = 70.0;\nfloat leftEarMinAngle = 110.0;\nfloat leftEarMaxAngle = 135.0;\n\nint CircleFlag = 0;   // 0 兔耳朵   1 圆环\n\nfloat EarMinAngle1 = 285.0, EarMaxAngle1 = 315.0;\nfloat EarMinAngle2 = 225.0, EarMaxAngle2 = 255.0;\nfloat EarMinAngle3 = 150.0, EarMaxAngle3 = 180.0;\nfloat EarMinAngle4 = 0.0, EarMaxAngle4 = 30.0;\nfloat EarMinAngle5 = 60.0, EarMaxAngle5 = 90.0;\nfloat EarMinAngle6 = 90.0, EarMaxAngle6 = 120.0;\n\n// 声波参数\nfloat waveAmplitude = 0.03 * circleSize;\nfloat waveFrequency = 20.0;\nfloat waveSpeed = 2.0;\n\n// 整体动画速度\nfloat animationSpeed = 10.0;\n\n// 辉光参数\nfloat glowIntensity = 0.5;\nfloat glowSize = 0.02 * circleSize;\n\n// 随机函数\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid updateExtendFactor(float time) {\n    extendFactor = minExtend + (maxExtend - minExtend) * (sin(time * extendSpeed * animationSpeed) * 0.5 + 0.5);\n}\n\nvoid updateExtendFactor1(float time) {\n    extendFactor1 = minExtend1 + (maxExtend1 - minExtend1) * (sin(time * extendSpeed1 * animationSpeed) * 0.5 + 0.5);\n}\n\nfloat calculateScaleFactor(float angleDeg, float minAngle, float maxAngle) {\n    float midAngle = (minAngle + maxAngle) / 2.0;\n    float totalRange = (maxAngle - minAngle) / 2.0;\n    float distanceFromMid = abs(angleDeg - midAngle) / totalRange;\n    return (1.0 + (extendFactor - 1.0) * (1.0 - distanceFromMid));\n}\n\nfloat calculateScaleFactor1(float angleDeg, float minAngle, float maxAngle) {\n    float midAngle = (minAngle + maxAngle) / 2.0;\n    float totalRange = (maxAngle - minAngle) / 2.0;\n    float distanceFromMid = abs(angleDeg - midAngle) / totalRange;\n    return (1.0 + (extendFactor1 - 1.0) * (1.0 - distanceFromMid));\n}\n\nvec2 getCircleVertex(float angle, float radius, float scaleFactor, float time) {\n    float randomOffset = (rand(vec2(angle, time)) - 0.5) * 0.01 * circleSize;\n    float waveOffset = waveAmplitude * pow(sin(waveFrequency * angle - waveSpeed * time * animationSpeed), 3.0);\n    waveOffset += randomOffset * waveAmplitude * 2.0; // 添加随机波动\n    return vec2(radius * scaleFactor * (1.0 + waveOffset) * cos(angle), radius * scaleFactor * (1.0 + waveOffset) * sin(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    updateExtendFactor(iTime);\n    updateExtendFactor1(iTime);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < segments; i++) {\n        float angle = 2.0 * M_PI * float(i) / float(segments);\n        float angleDeg = angle * 180.0 / M_PI;\n        \n        float scaleFactor = 1.0;\n        if (CircleFlag == 0) {\n            if (angleDeg >= rightEarMinAngle && angleDeg <= rightEarMaxAngle) {\n                scaleFactor = calculateScaleFactor(angleDeg, rightEarMinAngle, rightEarMaxAngle);\n            } else if (angleDeg >= leftEarMinAngle && angleDeg <= leftEarMaxAngle) {\n                scaleFactor = calculateScaleFactor(angleDeg, leftEarMinAngle, leftEarMaxAngle);\n            }\n        } else {\n            if (angleDeg >= EarMinAngle1 && angleDeg <= EarMaxAngle1) {\n                scaleFactor = calculateScaleFactor1(angleDeg, EarMinAngle1, EarMaxAngle1);\n            } else if (angleDeg >= EarMinAngle2 && angleDeg <= EarMaxAngle2) {\n                scaleFactor = calculateScaleFactor1(angleDeg, EarMinAngle2, EarMaxAngle2);\n            } else if (angleDeg >= EarMinAngle3 && angleDeg <= EarMaxAngle3) {\n                scaleFactor = calculateScaleFactor1(angleDeg, EarMinAngle3, EarMaxAngle3);\n            } else if (angleDeg >= EarMinAngle4 && angleDeg <= EarMaxAngle4) {\n                scaleFactor = calculateScaleFactor1(angleDeg, EarMinAngle4, EarMaxAngle4);\n            } else if (angleDeg >= EarMinAngle5 && angleDeg <= EarMaxAngle5) {\n                scaleFactor = calculateScaleFactor1(angleDeg, EarMinAngle5, EarMaxAngle5);\n            } else if (angleDeg >= EarMinAngle6 && angleDeg <= EarMaxAngle6) {\n                scaleFactor = calculateScaleFactor1(angleDeg, EarMinAngle6, EarMaxAngle6);\n            }\n        }\n        \n        vec2 innerVertex = getCircleVertex(angle, innerRadius, scaleFactor, iTime);\n        vec2 outerVertex = getCircleVertex(angle, outerRadius, scaleFactor, iTime);\n        \n        float dist = min(length(uv - innerVertex), length(uv - outerVertex));\n        float glow = exp(-dist / glowSize) * glowIntensity;\n        color += vec3(1.0) * (1.0 - smoothstep(0.0, 0.005 * circleSize, dist) + glow);\n    }\n    \n    // 应用辉光效果\n    color = min(color, vec3(1.0));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}