{"ver":"0.1","info":{"id":"MsGcDG","date":"1523118250","viewed":201,"name":"RayCubesLearning - parametrized","username":"leewz","description":"Comments and parameters for https://www.shadertoy.com/view/4ljSDt","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarchcubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shape sizes.\n    //Should fit into a 2x2x2 box.\nconst float CUBE_LENGTH = 0.25;\nconst vec3 RECT_DIMENSIONS = vec3(CUBE_LENGTH);\nconst float SPHERE_RADIUS = 0.1;\nconst vec2 TORUS_RADII = vec2(0.4, 0.2); //inner and outer radii\n\n//Camera.\nconst float CAMERA_DISTANCE = 2.0;\nconst float CAMERA_ROTATION_TIMESCALE = 0.25; //2pi = one second per revolution.\nconst vec3 CAMERA_PAN_TIMESCALE = vec3(0.0, 1.0, 1.0);\n\n//Raymarch.\nconst float RAY_FUZZ_TIMESCALE = 1.0; //distorts the ray based on time.\nconst float RAY_FUZZ_MIN = 0.2, RAY_FUZZ_MAX = 1.0; //1.0 = exact.\nconst int RAYMARCH_STEPS = 32; //raymarch steps. fewer = blurrier.\n\n\n/// Time ///\n\n/** Sine oscillation.\n    x : Input value, in radians.\n    ymin, ymax : Minimum and maximum output values.\n */\nfloat oscillate(float x, float ymin, float ymax)\n{\n    float range = ymax - ymin;\n    float x1 = (sin(x)+1.0)/2.0; \n    return ymin + range*x1;\n}\n\n\n/// Geometry ///\n\n//Signed distance to a box.\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//Sphere\nfloat sdSphere( vec3 p, float radius )\n{\n    return length(p) - radius; //sphere\n}\n\n//Torus around the y axis.\n    //Another torus function is here: https://iquilezles.org/articles/distfunctions\nfloat sdTorus(vec3 p, float r0, float r1)\n{\n    float c = (r0 + r1) / 2.0; //ring radius\n    float a = abs(r0 - r1) / 2.0; //thickness; tube radius\n    \n    float d0 = abs(c - length(p.xz)); // Horizontal distance from ring.\n    vec2 point = vec2(d0, p.y); //Project to cross-plane.\n    return length(point) - a; //Distance from ring.\n}\n\n\n/// Marching ///\n\n/** Wraps 3-space \"into\" a 1x1x1 box, and draws a shape inside it.\n    This gives the repetition effect. It's not that there are infinitely many cubes, but that it's the same cube being seen infinitely many times.\n    \n    Returns distance from p to the shape, measured within the 1x1x1 box.\n */\nfloat map(vec3 p)\n{\n    //Take the fractional parts of the coordinates.\n        //[math] This defines a quotient of R^3 onto T^3.\n    //Then send [0,1) to [-1,1), so the shape is centered at 0.\n        //Note: This doubles distances and lengths, because [-1,1) is twice as big as [0,1).\n        //Notation: [x,y) means \"numbers between x and y, including x but not y\".\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    //return 0.5*sdTorus(q, TORUS_RADII[0], TORUS_RADII[1]);\n    //return 0.5*sdSphere(q, SPHERE_RADIUS); //sphere\n    return 0.5*sdBox(q, RECT_DIMENSIONS); //rectangle\n}\n\n/** March from `origin` in the direction `ray`.\n    \n    `ray` is possibly not length 1, which would have these effects:\n    1. The apparent distance will be wrong, making the object brighter or darker due to distance fog. For example, if the ray is length 2, the returned distance will be half the real distance.\n    2. The algorithm may overshoot or undershoot at each step, causing it to not reach the target or overshoot the target.\n */\nfloat trace(vec3 origin, vec3 ray)\n{\n    float t = 0.0;  //Estimated distance to object.\n    for (int i = 0; i < RAYMARCH_STEPS; ++i)\n    {\n        vec3 p = origin + ray * t;\n        float d = map(p);\n        t += d;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, 1] screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // [-1, 1] screen coordinates.\n    uv = uv * 2.0 - 1.0;\n    // Scale x to aspect ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Camera:\n    //Puts screen at distance from camera, and r points to current pixel.\n    vec3 r = normalize(vec3(uv, CAMERA_DISTANCE));\n    //Rotate camera around y-axis over time.\n    float the = iTime * CAMERA_ROTATION_TIMESCALE;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    //Pan camera over time.\n    vec3 o = iTime * CAMERA_PAN_TIMESCALE;\n    \n    //Distortion factor for the ray.\n    float st = oscillate(iTime*RAY_FUZZ_TIMESCALE, RAY_FUZZ_MIN, RAY_FUZZ_MAX);\n    \n    //Distance to a visible object from this ray.\n    float t = trace(o, r * st);\n    \n    //Distance fog.\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = vec3(fog * 2.0);\n    \n    //Tint based on distortion factor.\n    vec3 tint = vec3(st - 0.5,st,st + 0.5);\n    \n    fragColor = vec4(fc * tint, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}