{"ver":"0.1","info":{"id":"cd3czl","date":"1696111180","viewed":46,"name":"Abobus","username":"loochek","description":"abebus","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 0.0, 5.0 );\nconst int   maxSteps = 30;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat dSphere( vec3 p, float r )\n{\n    return length( p ) - r;\n}\n\nfloat dRoundedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.06;\n}\n\nfloat opUnion ( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat speeds[] = float[9]\n(\n    10.0, 8.0, 15.0,\n    13.0, 12.0, 11.0,\n    15.0, 9.0, 7.0\n);\n\nfloat verticalStrides[] = float[9]\n(\n    4.0, 1.0, 3.0,\n    3.0, 3.0,  1.0,\n    2.0, 4.0, 5.0\n);\n\nfloat dVerticalCapsulesStream ( vec3 p, float radius)\n{\n    const float stride = 2.0;\n\n    float result = 1000000.0;\n    for (int i = -1; i <= 1; i++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            float iF = float(i);\n            float jF = float(j);\n            vec3 p1 = p +vec3(iF * stride, -iTime / 10.0 * speeds[i * 3 + j], jF * stride);\n            float verticalStride = verticalStrides[i * 3 + j];\n            vec3 p2 = vec3(p1.x, p1.y - verticalStride * round(p1.y / verticalStride), p1.z);\n        \n            result = opUnion(result, dSphere(p2, radius));\n        }\n    }\n\n    return result;\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p;\n    // float innerCapsules = dVerticalCapsulesStream(q, 0.2);\n    float outerCapsules = dVerticalCapsulesStream(q, 0.4);\n    float box = dRoundedBox(q, vec3(2.0, 0.1, 2.0));\n    return opSmoothSubtraction(outerCapsules, box, 0.2);\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n    vec3\tp         = from;\n    float\ttotalDist = 0.0;\n    \n    hit = false;\n    \n    for ( int steps = 0; steps < maxSteps; steps++ )\n    {\n        float\tdist = sdf ( p, m );\n        \n        if ( dist < 0.001 )\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist;\n        \n        if ( totalDist > 20.0 )\n            break;\n            \n        p += dist * dir;\n    }\n    \n    return p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*15.0 ) * rotateY ( 6.0* 10.995);\n    vec2 scale = 15.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n    vec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n    \n    if ( hit )\n    {\n        vec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n        vec3  n  = generateNormal   ( p, 0.001, m );\n        float nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 32.0 );\n        \n        color = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 1, 1, 1, 1 );    \n        fragColor = color;\n    }\n    else\n        fragColor = vec4(0.44, 0.67, 0.88, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}