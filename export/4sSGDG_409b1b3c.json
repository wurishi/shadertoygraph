{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define LOOP_BODY p = pos;tof = time + i*0.5;p = vec3(p.x*sin(tof) + p.z*cos(tof),p.y, p.x*cos(tof) - p.z*sin(tof));tof*=1.3*i;p += vec3(4.,0.,0.);\tp = vec3(p.x*sin(tof) + p.z*cos(tof),p.y,p.x*cos(tof) - p.z*sin(tof));\th = Hit(box(p, vec3(.4,20.,.2)),i); \ttotalHit = hitUnion(h,totalHit);\ti+=1.;\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\t\nstruct Hit\n{\n\tfloat dist;\n\tfloat index;\n};\n\t\nfloat time;\nfloat glowAmt;\n\nfloat onOff(float a, float b, float c)\n{\n\treturn clamp(c*sin(time + a*cos(time*b)),0.,1.);\n}\n\nfloat glows(float index)\n{\n\treturn onOff(5.+index*0.5,index+3.,3.);\n}\n\t\nfloat box(vec3 pos, vec3 dims)\n{\n\tpos = abs(pos) - dims;\n\treturn max(max(pos.x,pos.y),pos.z);\n}\n\n\nHit hitUnion(Hit h1, Hit h2)\n{\n\t//return h1.dist < h2.dist ? h1 : h2; // this stopped working at some point?\n    if (h1.dist < h2.dist){\n        return h1;\n    }\n    return h2;\n}\n\t\nHit scene(vec3 pos)\n{\n\tHit totalHit;\n\ttotalHit.dist = 9000.;\n\t/*for (float i = 0.; i < 5.; i+=1.)\n\t{\n\t\tvec3 p = pos;\n\t\tfloat tof = time + i*0.5;\n\t\tp = vec3(p.x*sin(tof) + p.z*cos(tof), \n\t\t\t\t\t   p.y,\n\t\t\t\t\t   p.x*cos(tof) - p.z*sin(tof));\n\t\tp += vec3(4.,0.,0.);\n\t\t\n\t\ttof*=1.3*i;\n\t\tp = vec3(p.x*sin(tof) + p.z*cos(tof), \n\t\t\t\t\t   p.y,\n\t\t\t\t\t   p.x*cos(tof) - p.z*sin(tof));\n\t\t\n\t\tHit h = Hit(box(p, vec3(.4,20.,.2)),i);\n\t\ttotalHit = hitUnion(h,totalHit);\n\t}*/\n\tfloat i = 0.;\n\tHit h;\n\tvec3 p;\n\tfloat tof;\n\t// Unrolling the loop seems to make it work on my windows machine\n\tLOOP_BODY //each loop iteration evaluates a box distance function\n\tLOOP_BODY\t\n\tLOOP_BODY\t\n\tLOOP_BODY\t\n\tLOOP_BODY\n\treturn totalHit;\n}\n\nHit raymarch(Ray ray)\n{\n\tvec3 pos;\n\tHit hit;\n\thit.dist = 0.;\n\tHit curHit;\n\tfor (int i = 0; i < 40; i++)\n\t{\n\t\tpos = ray.org + hit.dist * ray.dir;\n\t\tcurHit = scene(pos);\n\t\thit.dist += curHit.dist;\n\t\tglowAmt += clamp(pow(curHit.dist+0.1, -8.),0.,0.15)*glows(curHit.index);\n\t}\n\thit.index = curHit.index;\n\thit.index = curHit.dist < 0.01 ? hit.index : -1.;\n\treturn hit;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).dist - scene(pos-eps.xyy).dist,\n\t    scene(pos+eps.yxy).dist - scene(pos-eps.yxy).dist,\n\t    scene(pos+eps.yyx).dist - scene(pos-eps.yyx).dist );\n\treturn normalize(nor);\n}\n\nvec3 render(Ray ray)\n{\n\tHit hit = raymarch(ray);\n\tvec3 pos = ray.org + hit.dist*ray.dir;\n\tvec3 col = vec3(0.);\n\tif (hit.index != -1.)\n\t{\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 l = normalize(vec3(3.,0.,0.) - pos);\n\t\tcol = vec3(.3,.5,.7);\n\t\t\n\t\tfloat diff = clamp(dot(nor,l),0.,1.);\n\t\tvec3 r = normalize(2.*dot(nor,l)*nor-l);\n\t\tvec3 v = normalize(ray.org-pos);\n\t\tfloat spec = clamp(dot(v,r),0.,1.);\n\t\tfloat ao = 1.;\n\t\tcol = diff*col*ao + pow(spec,10.)*vec3(1.)*ao + vec3(0.5,0.7,1.)*1.9*glows(hit.index);\n\t\tcol*= clamp(1. - hit.dist*0.03,0.,1.);\n\t\t\n\t}\n\tcol += clamp(glowAmt*0.4,0.,1.)*vec3(.3,.5,.7);\n\treturn col;\n}\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415/180.;\n\tray.dir = dir + tan(fov/2.) * right * uv.x + tan(fov/2.) / aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tglowAmt = 0.;\n\ttime = iTime + uv.y*(0.17 + .14*clamp(sin(iTime*1.2)*2.,-1.,1.));\n\tvec3 cameraPos = vec3(6.,3.,-6.);\n\tvec3 lookAt = vec3(0.);\n\tvec3 up = vec3(sin(0.6*sin(time*1.4)),cos(0.6*sin(time*1.4)),0.);\n\tfloat aspect = iResolution.x/iResolution.y;\n\tRay ray = createRay(cameraPos, lookAt, up, uv, 90., aspect);\n\tvec3 col = render(ray);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sSGDG","date":"1392641559","viewed":1691,"name":"on a frontier of wires","username":"ryk","description":"I had something in mind when I made this. Then I forgot what that was. It ended up like this.\nApologies to anyone trying to make sense of the code. I will refactor it. Eventually.\n(Resubmitting after changes to make it work on my windows machine.)","likes":53,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","glow","slitscan"],"hasliked":0,"parentid":"","parentname":""}}