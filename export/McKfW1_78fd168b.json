{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nconst float PI = 3.141592653589793;\nconst float TAU = 2.0 * PI;\nconst float TAU_INVERSE = 1.0 / TAU;\n\nvec2 uv2xy(vec2 uv) {\n    float aspect = iResolution.y / iResolution.x;\n    return 2.0 * (uv - vec2(0.5)) * vec2(1.0, aspect);\n}\n\nvec2 xy2polar(vec2 xy) {\n    return vec2(\n        length(xy),\n        atan(xy.y, xy.x)\n    );\n}\n\nvec2 polar2xy(vec2 polar) {\n    float r = polar.x;\n    float a = polar.y;\n    return vec2(\n        r * cos(a),\n        r * sin(a)\n    );\n}\n\nconst vec3 COLOR1 = vec3(1.0, 0.666, 0.0);\nconst vec3 COLOR2 = vec3(0, 0.333, 1.0);\n\nfloat between(float a, float b, float t1, float t2) {\n  float v = 0.5 + 0.25 * (sin(t1) + cos(t2));\n  return a + (b - a) * v;\n}\n\nvec2 findDisk(vec2 polar, float time, float i, float minSectors, float sectorsScale) {\n    float threshold = between(0.2, 0.4, time * 0.001074, time * 0.001247);\n    float len = polar.x;\n    float ang = polar.y;    \n    if (len < threshold) {\n        float spiral = between(-10.0, 10.0, time * 0.001078, time * 0.001777);\n        float ellipse = 0.8 - sin(ang * 4.0) * 0.2;\n        return vec2(ellipse * len / threshold, ang + time * 0.001 + spiral * len);\n    }\n    \n    float sectors = floor(i * 1.0 + minSectors);\n    float len2 = threshold + 0.5 * (1.0 - threshold);    \n    float ang2 = TAU * (0.5 + floor(ang * TAU_INVERSE * sectors)) / sectors;\n    vec2 center = polar2xy(vec2(len2, ang2));\n    vec2 xy = polar2xy(polar) - center;\n    vec2 polar2 = xy2polar(xy);\n    float effect = between(0.0, 4.0, i * time * 0.001574, -time * 0.000754);\n    polar2.x *= effect / (1.0 - threshold);\n    polar2.y += i * between(-2.0, 2.0, time * 0.000451, time * 0.0004995);\n    return polar2;\n}\n\nvec3 computeColor(float time, vec2 polar, vec3 colSub, vec3 colAdd, float minSectors, float sectorsScale) {\n    vec3 col = colSub;\n    for (float i=0.0; i<8.0; i++) {\n        float a = smoothstep(0.49, 0.51, polar.x);\n        col += (mix(colSub, colAdd, a) - mix(colAdd, colSub, a)) * 0.1;\n        float light = 1.0 - smoothstep(0.75, 1.0, polar.x);\n        col *= 0.7 + (light * .3);\n        vec3 tmp = colAdd;\n        colAdd = colSub;\n        colSub = tmp;\n        polar = findDisk(polar, time, i, minSectors, sectorsScale);\n    }\n    return col;\n}\n\nfloat getSectorsMin(float stageI) {\n  return floor(between(2.0, 23.0, stageI, stageI * stageI));\n}\n\nfloat getSectorsScale(float stageI) {\n  return floor(between(0.0, 4.0, 74.458 * stageI, stageI * 7.14545));\n}\n#define S 0.05\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 uv = C/iResolution.xy;\nfloat time = iTime*10.;\n    vec2 xy = uv2xy(uv);\n    vec2 polar = xy2polar(xy);\n  \n    vec2 P = vec2(0.5, 0.5)*vec2(iResolution.x/iResolution.y, 1.);\n    float z = -S/length(uv*vec2(iResolution.x/iResolution.y, 1.)-P);\n    vec2 dir = normalize(P-uv*vec2(iResolution.x/iResolution.y, 1.));\n    uv += dir*z+cos(iTime);\n    float stage = time * 0.0001;\n    float stageI = floor(stage);\n    float stageF = fract(stage);\n     vec3 colSub = COLOR1;\n    vec3 colAdd = COLOR2;\n    \n    polar+=uv;\n    vec3 col1 = computeColor(time, polar, colSub, colAdd, getSectorsMin(stageI), getSectorsScale(stageI));\n    vec3 col2 = computeColor(time, polar, colSub, colAdd, getSectorsMin(stageI + 1.0), getSectorsMin(stageI + 1.0));\n    \n    vec3 col = mix(col1, col2, smoothstep(0.9, 1.0, stageF));\n    vec3 p,r=iResolution,\n    \n  \n   \n\n\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.18*exp(-i*i*e))\n    {\n        p=g*d;\n        p.xy*=uv*10.;\n        \n        p+=col;\n        p.z-=.6;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.0);\n        s=4.;\n        for(int j=0;j++<8;)\n            p=abs(p),p=p.x<p.y?p.zxy:p.zyx,\n            s*=e=1.8/min(dot(p,p),1.3),\n            p=p*e-vec3(12,3,3);\n        g+=e=length(p.xz)/s;\n  \n    }\n    O=pow(O,vec4(5));\n }","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McKfW1","date":"1734021547","viewed":95,"name":"singularity   on color fractal","username":"nayk","description":"origianals fractal 77 https://www.shadertoy.com/view/MfGBDz  https://www.shadertoy.com/view/lcyBDR","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}