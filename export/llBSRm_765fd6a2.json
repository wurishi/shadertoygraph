{"ver":"0.1","info":{"id":"llBSRm","date":"1442490893","viewed":193,"name":"Raymarch Engine - First Attempt","username":"cenau","description":"Simple Raymarch engine attempt\nbased on bits from https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nand https://www.shadertoy.com/view/ls2SWD and the articles on IQs site","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","raymarch","probablyawful"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float EPSILON = 0.001; // jump distance - go this far every iteration not to accidentally go through something\nconst int MAX_ITERATIONS = 100;\t // number of iterations - less is faster, more is more accurate\nconst float MAX_DISTANCE = 30.; // maximum distance to travel before giving up - things more than this distance will not be rendered!\n\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphere( q,0.1 );\n}\n\n\nfloat distanceFunction(vec3 pos)\n{\n    float scene = opRep(pos,vec3(0.9));\n    return scene;\n    \n}\n\n\n\n\nvec3 getNormal(vec3 pos){ \n//sample points using the distance function and some swizzling- got this from \n//https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\n    \n    vec2 eps = vec2(0.0, EPSILON);\n\tvec3 normal = normalize(vec3(\n    distanceFunction(pos + eps.yxx) - distanceFunction(pos - eps.yxx),\n    distanceFunction(pos + eps.xyx) - distanceFunction(pos - eps.xyx),\n    distanceFunction(pos + eps.xxy) - distanceFunction(pos - eps.xxy)));\n    return normal;\n}\n\n\n\nvec3 render(vec2 st){\n   \n\n   \n   // vec3 cameraPosition = vec3(4.,4.,1.); //camera position\n    vec3 cameraPosition = vec3((smoothstep(-2., 2., sin(iTime*0.2+cos(iTime)))-0.5)*2., sin(iTime)*2.-1., iTime*2. + sin(iTime));\n    vec3 cameraTarget = vec3((smoothstep(-2., 2., cos(iTime*0.2+sin(iTime)))-0.5)*2., cos(iTime)*2.-1., iTime*2.5 + cos(iTime)); //place that camera points at \n\n   \n    vec3 cameraUp = normalize(vec3(0.,0.,1.));  //positive Z axis is 'up' \n    \n    \n   \n    \n\tvec3 cameraDirection = normalize(cameraTarget - cameraPosition);\n\t\n\tvec3 cameraRight = normalize(cross(cameraUp,cameraDirection));\n\n\tcameraUp = normalize(cross(cameraDirection,cameraRight));\n    \n    vec3 rayDirection = normalize(cameraDirection+st.x*cameraRight+st.y*cameraUp);\n    \n    \n    //raymarch loop\n\tfloat dist = distanceFunction(cameraPosition); //first distance to jump \n\t\n\tfloat total = dist; //total distance travelled\n\t\n\t// march along ray\n\tfor(int i = 0;i<MAX_ITERATIONS;i++){\n\t\tdist = distanceFunction(cameraPosition+rayDirection*total); //jump\n\t\ttotal += dist;\t\t\t\t\t\t    // add jumped distance to total\n\t\tif(dist<EPSILON || dist>MAX_DISTANCE){continue;}   //break if object hit OR reached maximum distance\n\t}\n\tvec3 finalDist = cameraPosition+rayDirection*total; \n\tvec3 colour;\t\t\t\t\t\n\tif(dist<EPSILON){\t\t\t\t\t \n\t\tcolour = getNormal(finalDist);         \n\t\t\t\t\t\t\t\t\t \n\t}else{\t\t\t\t\t\t\t \n\t\tcolour = vec3(0.0); \n    }\n        \n        \n    return vec3(colour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\t\n    vec2 st = fragCoord.xy / iResolution.xy;\t// normalise screen coords \n    st = (st-.5);\t\t\t\t\t\t\t\t// centre the coordinate system from https://www.shadertoy.com/view/ls2SWD\n    st.y /= (iResolution.x)/iResolution.y;\t// add vertical space for aspect ratio thing - modified from above shader\n\t\n    vec3 c = render(st); //raymarch!\n  \n\t\n\tfragColor = vec4(c,1.0); //assign colours, with alpha. \n}","name":"","description":"","type":"image"}]}