{"ver":"0.1","info":{"id":"MlXcDB","date":"1506256489","viewed":375,"name":"Bouncing Ball With Trail","username":"isak","description":"First experiment with buffers in shadertoy. Please suggest improvements and better tricks.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["ball","bouncing","trail","buffers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define DENOM (iResolution.x)\n\nvec2 ball_hash(int);\nfloat d_circ(vec2, float);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n       \n    vec2 UV = fragCoord.xy/iResolution.xy;\n    fragColor = texture(iChannel1, UV);\n    \n   \tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    uv *= 2.0/iResolution.y;\n    \n    \n    for (int i = 0; i < NUM_BALLS; i++) {\n        vec4 ball = texture(iChannel0, ball_hash(i));\n        fragColor += d_circ(uv - ball.xy, BALL_RAD);\n    }\n    \n    \n    fragColor += 1.0*clamp(1.3 - pot(length(uv)), 0.0, 1.0)*0.5*vec4(0.1, 0.8, 1.0, 1.0);\n    \n}\n\nvec2 ball_hash(int i) {\n\treturn vec2( (float(i) + 0.5)/DENOM , 0.0);\n}\n\nfloat d_circ(vec2 p, float r) {\n    float len = length(p)/r;\n    float dw = fwidth(len);\n\treturn smoothstep(1.0 + dw, 1.0 - dw,  len);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer is for the physics\n\n// The upper part of the texture is used to store the physics data\n// (R, G, B, A) --> (x, y, vx, vy)\n// Therefore the first thing we do inside mainImage(...){ }\n// is to check if we're inside this part of the texture\n// we only want to do expensive physics computations on this subset\n// the line is : if ( FC.y > 1.0 || FC.x > 3.0 ) return;\n\nconst float dt = 0.01;\nconst float PI = 3.1415926535897932384626433832795;\n\nvoid physics_update(out vec4, in vec4);\n\nvec2 ball_hash(int);\nint  ball_hash_index(float);\n\nvec4 initState(int);\n\nvoid mainImage( out vec4 nextState, in vec2 FC ){\n    \n    // default fragColor and filter statement to avoid overcomputing    \n\tnextState = vec4(0.0);\n    if ( FC.y > 1.0 || FC.x > float(NUM_BALLS) ) return;\n    \n    // get ball index from hash\n\tint i = ball_hash_index(FC.x);\n    \n    // initialize state\n    if (iFrame == 0) {\n        nextState = initState(i);\n        return;\n    }\n    \n    // get the previous state\n    vec4 prevState = texture( iChannel0, ball_hash(i) );\n    \n    // Update the state by generating a next state\n    physics_update(nextState, prevState);\n    \n}\n\n\nvec4 initState( int c ) { \n    \n    float fc = float(c);\n    float t_res = 1000.0;\n    \n    vec2 time_v = vec2( fc, mod(iDate.w, t_res)/t_res );\n    \n    float x = rand( time_v + 1.0);\n    float y = rand( time_v );\n    \n    vec2 p = vec2(x,y) - 0.5;        \n\n    float vx = rand( time_v - 1.0);\n    float vy = rand( time_v );\n    vec2 v = 3.0*( vec2(vx,vy) - 0.5);\n\n    return vec4(p,v);      \n}\n\n// State of eaxh particle is stored in a vec4( vec2 pos, vec2 velocity )\n\nvoid physics_update(out vec4 next, in vec4 prev) {\n   \n    vec2 r = prev.xy;\n    vec2 v = prev.zw;\n    vec2 a = vec2(0.0);\n    \n    vec2 rn = normalize(r);\n    \n    // collision with screen edge\n \n    vec2 box = iResolution.xy/iResolution.y;\n\tvec2 b_test = step(box, abs(r) + BALL_RAD);\n    v -= 2.0*b_test*v;\n    \n    \n    // central gravity \n    \n    #ifdef CENTRAL_GRAV\n    //a += -GRAV_CONST*rn/dot(r,r);\n    \n    float R = length(r);\n    \n    // Steming from the potential 5.0 + 5.0/((x + 0.45)) - 15.0/((x + 1.0)) \n    a += -rn*GRAV_CONST*( -5.0/((R + 0.45)*(R + 0.45)) + 15.0/((R + 1.0)*(R + 1.0))  );\n    \n    \n    #endif\n    \n    // artificial drag to force stability\n    a += - 10.0*step(3.0, length(v))*v;\n   \n    \n    // update\n    v += a*dt;\n    r += v*dt;\n    \n    \n    next = vec4(r, v);\n}\n\nint ball_hash_index (float c) {\n    return int( round(c - 0.5) );\n}\n\nvec2 ball_hash(int i) {\n\treturn vec2( (float(i) + 0.5)/DENOM , 0.0);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer is for the tail\n\n#define DENOM (iResolution.x)\n#define WIND\n\nvec2 ball_hash(int);\nint  ball_hash_index(float);\n\nfloat d_circ(vec2, float);\nfloat d_radial(vec2, float);\nmat2 rot(float);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    uv *= 2.0/iResolution.y;  \n    \n    fragColor = vec4(0.0);\n    \n    #ifdef TRAIL\n\n    // generate more trail\n    \n    \n    float pulse_f = 1.5*BALL_RAD + 0.01*sin(25.0*iTime);\n    float snake_f = 0.01*(sin(31.0*iTime)); \n\n    float d_rad = 0.0;\n    \n    for (int i = 0; i < NUM_BALLS; i ++) {\n        \n        vec4 ball  = texture(iChannel0, ball_hash(i));\n        vec2 ort_v = normalize( vec2(-ball.w, ball.z) );\n    \t\n        d_rad += d_radial(uv - ball.xy - snake_f*ort_v, pulse_f);\n    }\n    \n    float more_trail = (1.0 -  0.35*(1.0 + sin(100.0*iTime)))*d_rad ;\n    \n    // distort the trail by wind\n    \n    \n    vec2 UV = fragCoord.xy/iResolution.xy;\n    \n    #ifdef WIND\n    float amount = 0.5; // + 0.5*sin(iTime);\n    UV = mix( 1.0, 0.97, amount)*(UV - 0.5) + 0.5;\n    #endif\n    \n    // compose trail : \"new trail\" = trail + more_trail\n    \n    vec4 trail = texture(iChannel1, UV);\n    trail.rg = rot(0.1)*trail.rg;  // color change\n    \n    fragColor = vec4(0.93*trail.rg, mix(0.93, 0.98, clamp(trail.b, 0.0, 1.0))*trail.b, 1.0)\n        \t  + vec4(0,1,0.5,1)*more_trail;\n    \n    #endif\n      \n}\n\nint ball_hash_index (float c) {\n    return int( round(c - 0.5) );\n}\n\nvec2 ball_hash(int i) {\n\treturn vec2( (float(i) + 0.5)/DENOM , 0.0);\n}\n\n\nfloat d_radial(vec2 p, float r) {\n\treturn smoothstep(1.0, 0.0, length(p)/r);\n}\n\nfloat d_circ(vec2 p, float r) {\n    float len = length(p)/r;\n    float dw = fwidth(len);\n\treturn smoothstep(1.0 + dw, 1.0 - dw,  len);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2( c, -s, s, c);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// This is probably the one you want to change, go CRAAZY\n\n#define NUM_BALLS 4\n\n\n\n#define CENTRAL_GRAV\n\n#define GRAV_CONST 20.0\n\n//#define WIND\n\n#define TRAIL\n\n#define BALL_RAD 0.02\n\n\n#define DENOM (iResolution.x)\n\n\nfloat pot( float r ) {\n    return 5.0 + 5.0/((r + 0.45)) - 15.0/((r + 1.0));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}","name":"Common","description":"","type":"common"}]}