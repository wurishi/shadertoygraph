{"ver":"0.1","info":{"id":"llV3Dt","date":"1477534605","viewed":175,"name":"Test using buffer as a loop","username":"xdaimon","description":".","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","sphere","loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragCoord.xy /= iResolution.xy;\n\n    vec2 info = texture(iChannel0, fragCoord).xy;\n    float t = info.x;\n    float dist = info.y;\n\n    fragCoord=fragCoord*2.-1.;\n    fragCoord.x *= iResolution.x/iResolution.y;\n    \n    // a = 1\n    // b = phi^.5\n    // c = phi\n    // a^2 + b^2 = c^2\n    // 1 + phi = phi^2\n    // angle opposite side b = atan(phi^.5)\n    // place abc triangle such that side c is on the y axis and corner ac is at the origin\n    // then the vector which points from the origin to the corner ab on the triangle has length 1\n    // which means adding 1 to the z component of the vector then dividing the vector by root 2\n    // is a 45 degree rotation out of the xy plane. ok let me get back to playing with buffers and stuff.\n    const float phi = (1. + sqrt(5.))/2.;\n    const float pi_2 = asin(1.);\n    const vec3 ro = vec3(cos(pi_2 - atan(sqrt(phi))), sin(pi_2 - atan(sqrt(phi))), 1.)/sqrt(2.);\n    \n    const vec3 ta = vec3(0.);\n    const vec3 ww = normalize( ta - ro );\n    const vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    const vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( fragCoord.x*uu + fragCoord.y*vv + phi*ww );\n    \n    const float minDist = 0.00001;\n\tfragColor = vec4(1.-smoothstep(0., minDist, dist));\n    \n    vec3 p = ro+rd*t;\n    \n    if (p.y+1. < minDist)\n    {\n        float on_off = mod(floor(p.x),2.) + mod(floor(p.z),2.);\n        fragColor = .5 - .5 * vec4(smoothstep(0., 1., on_off));\n    }\n    \n    fragColor *= 1. - smoothstep(1., 25., length(p.xz));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdf(vec3 p)\n{\n    float dist = length(p) - .25;\n    dist = min(dist, p.y+1.);\n    return dist;\n}\n\nvoid mainImage( out vec4 Out, in vec2 In )\n{\n\n    In /= iResolution.xy;\n\n    float t;\n    float dist;\n    if (iFrame == 1)\n    {\n        t = 0.;\n        dist = 1.;\n    }\n    else\n    {\n        vec2 info = texture(iChannel0, In).xy;\n        t = info.x;\n        dist = info.y;\n        \n        if (dist > 1.)\n        {\n            Out.x = 0.;\n            Out.y = 1.;\n        }\n    }\n\n    In = In*2.-1.;\n    In.x *= iResolution.x/iResolution.y;\n\n    const float phi = (1. + sqrt(5.))/2.;\n    const float pi_2 = asin(1.);\n    const vec3 ro = vec3(cos(pi_2 - atan(sqrt(phi))), sin(pi_2 - atan(sqrt(phi))), 1.)/sqrt(2.);\n    \n    //float t = iTime/3.;\n    //mat3 rotator = mat3(cos(t), 0., sin(t), 0.,1.,0., -sin(t),0.,cos(t));\n    \n    const vec3 ta = vec3(0.);\n    const vec3 ww = normalize( ta - ro );\n    const vec3 uu = normalize( cross(ww,vec3(0.,1.,0.) ) );\n    const vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( In.x*uu + In.y*vv + phi*ww );\n    \n    //const float minDist = 0.00001;\n\n\tdist = sdf(ro+rd*t);\n    t += dist;\n    \n    Out.x = t;\n    Out.y = dist;\n    \n    if (iMouse.z > 0.)\n    {\n        Out.x = 0.;\n        Out.y = 1.;\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}