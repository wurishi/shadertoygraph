{"ver":"0.1","info":{"id":"Wl3yWl","date":"1610115524","viewed":170,"name":" faster raymarching test","username":"gaz","description":"3d","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void lookAt(inout vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    rd=rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nfloat map(vec3 p)\n{\n\trot(p,vec3(cos(iTime*.3),sin(iTime*.3),1),iTime*.3);\n    float d=1.;\n    for(float i=0.;i<80.;i++)\n    {\n        vec3 c=hash31(i+123.1)*2.-1.;\n        c*=2.;\n        d=min(d,length(p-c)-.3);\n    }\n    return d;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat fixedMarch(vec3 ro, vec3 rd, float pitch, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<50;i++)\n    {\n        d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n        t+=pitch;\n    }\n    return far;\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow(vec3 light, vec3 ld, float len)\n{\n\tfloat depth=march(light,ld,.01,len);\t\n\treturn step(len-depth,.01);\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.3,.5,.8)+cos(p*.2)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,8);\n    vec3 rd = normalize(vec3(uv,2));\n    vec3 ta =vec3(0);\n    lookAt(rd,ro,ta,vec3(0,1,0));    \n    vec3 col= vec3(0);\n    \n    // bounding sphere\n    float r=3.2;\n    vec3 o=vec3(0);\n    vec3 u=cross(o-ro,rd);\n    float h=sqrt(r*r-dot(u,u));\n    float g=dot(o-ro,rd);\n    float near=g-h;\n\tfloat far=g+h;\n    //near=0.;\n\n#if 1\n    float pitch = .3;\n    float t=fixedMarch(ro,rd,pitch,near,far);\n    if(t<far)t=march(ro,rd,t-pitch,far);\n#else\n    float t=march(ro,rd,near,far);\n#endif\n\n    if(t<far)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(0,3,0);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        float sha=calcShadow(lightPos,-li,len);\n        col*=max(sha*dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n    }\n    fragColor.xyz=col;\n}","name":"Image","description":"","type":"image"}]}