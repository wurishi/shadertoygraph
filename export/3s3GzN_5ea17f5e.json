{"ver":"0.1","info":{"id":"3s3GzN","date":"1567887528","viewed":92,"name":"DotMatrix_Shader","username":"wimachtendink","description":"I'm just trying to copy a tutorial, nothing to see here :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uniform float uScale; // For imperfect, isotropic anti-aliasing in\nuniform float uYrot;  // absence of dFdx() and dFdy() functions\n \nfloat aastep(float threshold, float value) {\n  float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n  return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n \n// Explicit bilinear texture lookup to circumvent bad hardware precision.\n// The extra arguments specify the dimension of the texture. (GLSL 1.30\n// introduced textureSize() to get that information from the sampler.)\n// 'dims' is the width and height of the texture, 'one' is 1.0/dims.\n// (Precomputing 'one' saves two divisions for each lookup.)\nvec4 texture2D_bilinear(sampler2D tex, vec2 st, vec2 dims, vec2 one) {\n  vec2 uv = st * dims;\n  vec2 uv00 = floor(uv - vec2(0.5)); // Lower left corner of lower left texel\n  vec2 uvlerp = uv - uv00 - vec2(0.5); // Texel-local lerp blends [0,1]\n  vec2 st00 = (uv00 + vec2(0.5)) * one;\n  vec4 texel00 = texture(tex, st00);\n  vec4 texel10 = texture(tex, st00 + vec2(one.x, 0.0));\n  vec4 texel01 = texture(tex, st00 + vec2(0.0, one.y));\n  vec4 texel11 = texture(tex, st00 + one);\n  vec4 texel0 = mix(texel00, texel01, uvlerp.y); \n  vec4 texel1 = mix(texel10, texel11, uvlerp.y); \n  return mix(texel0, texel1, uvlerp.x);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frequency = 180.;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    // Distance to nearest point in a grid of\n    // (frequency x frequency) points over the unit square\n    vec2 st2 = mat2(0.707, -0.707, 0.707, 0.707) * st;\n    vec2 nearest = 2.0*fract(frequency * st2) - 1.0;\n    float dist = length(nearest);\n    // Use a texture to modulate the size of the dots\n    vec3 texcolor = texture2D_bilinear(iChannel0, st, iResolution.xy, 1.0/iResolution.xy).rgb;\n    float radius = sqrt(1.0-texcolor.g); // Use green channel\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 fragcolor = mix(black, white, aastep(radius, dist));\n    fragColor = vec4(fragcolor, 1.0);\n}","name":"Image","description":"","type":"image"}]}