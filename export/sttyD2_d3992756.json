{"ver":"0.1","info":{"id":"sttyD2","date":"1660612510","viewed":201,"name":"Color Tile Ball","username":"pb","description":"Drag the Mouse if you wish!\n\nAdded a blue-ish, sphere-ish refractive disturbance you can move with the mouse. ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fbm","raysphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// philip.bertani@gmail.com\n\n//#define oct 5   //number of fbm octaves\n#define pi  3.14159265\n#define sphr .3\n\nint oct=5;\n\nstruct RayInfo  {\n    vec3 p1,p2;\n    bool hit;\n};\n\nRayInfo RaySphereIntersect(vec3 ro, vec3 rd, vec3 spherepos, float r) {\n\n    vec3  a = (spherepos - ro);\n    float b = dot(rd, a);\n    float c = dot(a,a) - r*r;\n    float d = b*b - c;\n\n    RayInfo ri; ri.hit=false;\n\n    if ( d < 0.0 ) return ri;\n\n    float sd = sqrt(d);\n    float t1 = b - sd, t2 = b + sd;\n\n    ri.p1 = ro + rd * t1;\n    ri.p2 = ro + rd * t2;\n  \n    ri.hit = true;\n\n    return ri;\n\n}\n\nfloat dist_func01(vec3 p) {\n    return length(p) - sphr;\n}\n\nvec3 gradient(vec3 p) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = .01 * dpn; \n\n    vec3 df = dpn.xxx * dist_func01(p+dp.xxx) +\n              dpn.yyx * dist_func01(p+dp.yyx) +\n              dpn.xyy * dist_func01(p+dp.xyy) +\n              dpn.yxy * dist_func01(p+dp.yxy);\n\n    return normalize(df); \n\n}\n\nfloat random(vec3 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec3(12., 90., -.8)))* 1e5 );\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float a = random(i + vec3(1.,1.,1.));\n    float b = random(i + vec3(1.,-1.,-1.));\n    float c = random(i + vec3(-1.,1.,1.));\n    float d = random(i + vec3(-1.,1.,-1.));\n     vec2 u = f.yz *f.xy*(3.-2.*f.xz);\n    \n    return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n\n}\n\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .5;\n  \n    for (int i=0; i<oct; i++) {\n        v += a * noise(p);\n        p = p * 2.;\n        a *= .7;  //changed from the usual .5\n    }\n    return v;\n}\n\nmat3 rxz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(cc,0.,-ss,\n                0.,1.,0.,\n                ss,0.,cc);                \n}\nmat3 ryz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(1.,0.,0.,\n                0.,cc,-ss,\n                0.,ss,cc);\n}   \n\nvec3 get_color(vec3 p) {\n    vec3 q;\n    q.x = fbm3d(p);\n    q.y = fbm3d(p.yzx);\n    q.z = fbm3d(p.zxy);\n\n    float f = fbm3d(p + q);\n    \n    return q*f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec3 light; \n    float myTime = 10. + iTime; // mod(iTime,120.);\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mm = (2.*iMouse.xy-iResolution.xy)/iResolution.y/2.;\n\n    vec3 rd = normalize( vec3(uv, -2.) );  \n    vec3 ro = vec3(0.,0.,0.);\n    \n    float delta = 2.*pi/10.;\n \n    mat3 rot = rxz(-2.*delta) * ryz(.2*delta); \n    \n    ro -= rot[2]*myTime/4.;\n    \n    rd = rot * rd;\n    \n    vec3 p = ro + rd;\n    \n    vec3 cc = vec3(0.);\n\n    float stepsize = .01;\n    float totdist = stepsize;\n  \n    vec3 spherepos = ro + .7*rot[2];\n    if ( iMouse.w != 0. ) spherepos += -mm.x*rot[0] - mm.y*rot[1];\n\n    RayInfo ri = RaySphereIntersect(ro,rd,spherepos,sphr);    \n    vec3  nn;\n    \n    if ( ri.hit ) {  \n    \n        nn = gradient( ri.p1 );\n        vec3 rd2 =  refract( rd, -nn, .1);  //change ray direction\n        //p+= 3.*(ri.p2-ri.p1)*rd2;   //this was a mistake - but looked cool\n        p+= 1.3*(length(ri.p2-ri.p1))*rd2;   //move the ray to exit  the sphere\n        oct = 7;   //make the sphere noisier \n    }\n  \n    for (int i=0; i<16; i++) {\n       vec3 cx = get_color(p);\n       p += stepsize*rd;\n       float fi = float(i);\n       cc += exp(-totdist*totdist*float(i))* cx;\n       totdist += stepsize;\n       rd = ryz(.4)*rd;   //yz rotation here\n               \n    }\n    \n    if ( ri.hit ) {\n        cc *= .8 ; \n        cc.b += 2.*fbm3d(ri.p2);\n    }\n    \n    cc = .5 + 1.3*(cc-.5);  //more contrast makes nice shimmering blobs\n    cc = pow( cc/15. , vec3(3.));    //play with this\n\n    fragColor = vec4(cc,1.0);\n    \n    \n}\n","name":"Image","description":"","type":"image"}]}