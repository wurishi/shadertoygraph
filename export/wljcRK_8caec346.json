{"ver":"0.1","info":{"id":"wljcRK","date":"1594863976","viewed":140,"name":"error diffusion sampling","username":"BigotedSJW","description":"essentially a remix of https://www.shadertoy.com/view/XslXDS\nloosely inspired by the dithering in the software renderer of the original Unreal, but of course no where near as elegant.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","dithering","errordiffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 ditherTexture(vec2 uv, vec2 res)\n{\n    vec2 invRes = 1.0/res;\n    \n    vec2 actualTexel = uv*res + vec2(0.5);\n    vec2 texelOffset = fract(actualTexel);\n    \n    vec2 centerUV = floor(actualTexel)*invRes;\n    vec2 offCenterUV = ceil(actualTexel)*invRes;\n    vec2 rightUV = vec2(offCenterUV.x, centerUV.y);\n    vec2 downUV = vec2(centerUV.x, offCenterUV.y);\n   \t\n    float noise = texture(iChannel2, texelOffset).r;\n    vec2 biasVector = step(noise, texelOffset);\n    \n    //these names are likely entirely wrong\n   \tfloat isOffCenter = min(biasVector.x, biasVector.y);\n    float isCenter = min(1.0 - biasVector.x, 1.0 - biasVector.y);\n    float isDown = min(1.0 - biasVector.x, biasVector.y);\n    float isRight = min(biasVector.x, 1.0 - biasVector.y);\n\n\tvec2 finalUV = centerUV*isCenter\n        + offCenterUV*isOffCenter\n\t\t+ rightUV*isRight\n\t\t+ downUV*isDown;\n    \n\treturn texture(iChannel1,finalUV);\n}\n\n//rotate and translate\nvec2 rNt(vec2 start, vec4 t)\n{\tmat2 rot = mat2(t.x,t.y,-t.y,t.x);\n\tvec2 end = rot*start + t.zw;\n\treturn end;\t}\n\nvec4 sampleTexture1d( float v )\n{\n    float tv = v*256.0;\n    float iv = floor(tv);\n    float fv = tv - iv;\n    vec4 a = texture(iChannel0,vec2(0.5,(iv+0.0)/256.0),-100.0);\n    vec4 b = texture(iChannel0,vec2(0.5,(iv+1.0)/256.0),-100.0);\n    return mix( a, b, fv );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n\tvec4 smpl = -1. + 2.*sampleTexture1d(iTime/1000.0);\n\tuv = rNt(uv,smpl);\n\n    fragColor = ditherTexture(uv,iChannelResolution[1].xy);\n}","name":"Image","description":"","type":"image"}]}