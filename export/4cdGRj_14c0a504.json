{"ver":"0.1","info":{"id":"4cdGRj","date":"1711931402","viewed":112,"name":"Abstract sphere attempt","username":"Krafpy","description":"Some experiment with iterated objects.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, vec4 sph){\n    return length(p - sph.xyz) - sph.w;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf(vec3 p){\n    float d = 10000.;\n    \n    vec3 q = p;\n    \n    p.xz *= rot(p.y);\n    \n    vec3 o = vec3(0.);\n    float s = 1.4;\n    vec3 b = vec3(0.5);\n    for(float i = 0.; i < 15.; i++){\n        vec3 h = hash31(i);\n        \n        p.xz *= rot(0.1*0.4*iTime + h.x);\n        p.yx *= rot(0.1*-0.3*iTime + h.y);\n        \n        p = abs(p) - o;\n        if(i > 3.){\n            //float m = mix((sdBox(p/s, b)-0.05)*s, (length(p/s)-0.5)*s, 0.5);\n            float m = (sdBox(p/s, b)-0.05)*s;\n            d = min(d, m);\n        }\n        s *= 0.5;\n        o = vec3(s) + s*h;\n    }\n    \n    d = max(d, sdSphere(q, vec4(vec3(0.), 2.)));\n    \n    /*s = 5.;\n    q.xz *= rot(iTime);\n    d = max(d, -sdGyr(q*s)/s);*/\n    return d*0.4;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, float mint){\n    float eps = 0.001;\n    float maxIters = 64.;\n    float shad = 1.;\n    float t = mint;\n    for(float i = 0.; i < maxIters; ++i){\n        float d = sdf(ro + rd*t);\n        shad = min(shad, 10.*d/t);\n        if(d < eps){\n            return vec3(t, i/maxIters, 0.);\n        }\n        t += d;\n    }\n    return vec3(-1.,-1.,shad);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd){\n    return raymarch(ro, rd, 0.);\n}\n\nvec3 normal(vec3 p){\n    vec2 h = 0.001*vec2(1.,-1.);\n    return normalize(\n        h.xyy*sdf(p+h.xyy) +\n        h.yxy*sdf(p+h.yxy) +\n        h.yyx*sdf(p+h.yyx) +\n        h.xxx*sdf(p+h.xxx)\n    );\n}\n\nfloat ao(vec3 p, vec3 n){\n    float occ = 0.;\n    float s = 2.;\n    for(int i = 0; i < 5; i++){\n        float t = 0.01 + float(i)*0.13;\n        float d = sdf(p + t*n);\n        occ += s*(t-d);\n        s *= 0.5;\n    }\n    return clamp(1.-occ, 0., 1.);\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = vec3(0.);\n    vec3 hit = raymarch(ro, rd);\n    if(hit.x > 0.) {\n        col = vec3(1.);\n        \n        vec3 p = ro + rd*hit.x;\n        vec3 n = normal(p);\n        \n        vec3 ud = normalize(vec3(1));\n        vec3 ld = ud;\n        ld.xz *= rot(2.);\n        vec3 h = normalize(ld + -rd);\n        \n        \n        col = mix(col, col*vec3(0.,0.5,1.), sdot(n,ud));\n        col = mix(col, col*vec3(1.,0.5,0.), sdot(-n,ud));\n        \n        float NdV = sdot(n, -rd);\n        vec3 F0 = vec3(0.04);\n        vec3 F = F0 + (1.-F0)*pow(1.-NdV, 5.);\n        col += F;\n        col += 0.5*pow(sdot(n,h), 10.);\n        \n        col *= 1.-sdot(n,ud);\n        \n        float shad = 0.;\n        vec3 hit = raymarch(p+n*0.002,ld, 0.001);\n        shad = clamp(hit.z, 0.1, 1.);\n        col *= shad;\n        col *= ao(p, n);\n    }\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 mr = iMouse.xy/iResolution.xy;\n    mr -= 0.5;\n    mr.x *= iResolution.x / iResolution.y;\n    mr *= 3.141592;\n    \n    vec3 ro, rd;\n    ro = vec3(0.,0.,-5.);\n    rd = normalize(vec3(uv, 1.));\n    if(iMouse.z > 0.){\n        ro.yz *= rot(mr.y);\n        rd.yz *= rot(mr.y);\n        ro.xz *= rot(mr.x);\n        rd.xz *= rot(mr.x);\n    } else {\n        float x = mod(iTime-1., 5.);\n        float w = smoothstep(0., 0.5, x)*smoothstep(3., 2.5, x);\n        ro.z += 2.*w;\n        \n        mat2 a = rot(sin(-0.3*iTime));\n        mat2 b = rot(1.2*sin(-0.2*iTime) - 0.5);\n        //mat2 b = rot(0.2*iTime);\n        ro.yz *= a;\n        ro.xz *= b;\n        rd.yz *= a;\n        rd.xz *= b;\n    }\n    \n    col = render(ro, rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ============================ CONSTANTS\n\n#define PI 3.14159265\n#define TWOPI 6.28318530\n\n\n// ============================ ROTATIONS\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 rot(vec2 u, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * u;\n}\n\n\n// Rodrigues' rotation formula : rotates v around u\nvec3 rot(vec3 v, vec3 u, float a){\n    float c = cos(a);\n    float s = sin(a);\n    return v * c + cross(u, v) * s + u * dot(u, v) * (1. - c);\n}\n\n// MATH\n\nfloat sdot(vec2 a, vec2 b){\n    return clamp(dot(a,b),0.,1.);\n}\n\nfloat sdot(vec3 a, vec3 b){\n    return clamp(dot(a,b),0.,1.);\n}\n\n\n// ============================ COORDINATES\n\nvec3 sphericalToCartesian(float lat, float lon){\n    float x = cos(lat) * cos(lon);\n    float y = sin(lat);\n    float z = cos(lat) * sin(lon);\n    return vec3(x, y, z);\n}\n\nmat3 lookAt(vec3 eye, vec3 target){\n    vec3 up = vec3(0.,1.,0.);\n    vec3 newZ = normalize(target - eye);\n    vec3 newX = normalize(cross(up, newZ));\n    vec3 newY = cross(newX, newZ);\n    return mat3(newX, newY, newZ);\n}\n\n\n// ============================ HASH FUNCTIONS\n\n// from https://www.shadertoy.com/view/4djSRW\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"}]}