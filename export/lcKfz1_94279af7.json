{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Ever-falling Truchet Tubes\n    12/09/2024  @byt3_m3chanic\n    \n    Ever falling illusion with Linear interpolation.\n    Began as another shader project that I kept working on to take 2D to 3D.\n\n*/\n\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.1415926\n#define PI2 6.2831853\n\n#define MIN_DIST 1e-4\n#define MAX_DIST 40.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,35.23)+iDate.z)) *472.323-iDate.y); }\n\n// timing functions\nfloat lerp (float b, float e, float t) { return clamp((t - b) / (e - b), 0., 1.); }\nfloat eoc (float t) { return (t = t-1.)*t*t+1.; }\nfloat eic (float t) { return  t*t*t; }\n\n//@iq extrude sdf and capped cylinder\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat cap( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.) + length(max(d,0.))-.03;\n}\n\n//globals\nvec3 s_hit, g_hit;\nvec2 s_id, g_id;\nfloat tspeed=0., tmod=0., t1=0., t3=0., t4=0.;\n\n//scales for all things\nconst float scale = 2.;\nconst float scale_h = 1.;\nconst vec2 s = vec2(4.);\n\nconst vec2 pos = vec2(.5,-.5);\nconst vec2[4] ps4 = vec2[4](pos.yx,pos.xx,pos.xy,pos.yy);\n\nvec2 pattern(inout vec2 q, vec2 id) {\n\n    float rnd = hash21(id.xy);\n    if(rnd>.5) q.y = -q.y;\n    rnd = fract(rnd*32.27);\n\n    float ths =length(abs(id*.3));\n    float shs = (rnd*3.)+fract(ths*324.5);\n\n    t1 = lerp(shs,shs+.5,tmod);\n    t1 = eoc(t1); t1 = eic(t1);\n\n    ths = hash21(id)*2.5;\n    t3 = lerp(ths+4.,ths+4.5,tmod);\n    t3 = eoc(t3); t3 = eic(t3);\n    \n    q.xy*=rot((t1-t3)*1.5707);\n    \n    vec2 q2 = length(q-scale_h)<length(q+scale_h) ? q-scale_h : q+scale_h;\n    \n    float thickness = .2;\n    float d1 = abs(length(q2)-scale_h)-thickness;\n    if(rnd>.85) d1 = min(length(q.x)-thickness,length(q.y)-thickness);\n    d1=max(d1,length(q)-1.);\n    return vec2(d1,shs);\n}\n\n// block map -v4 tap technique from @Shane\nvec2 map(vec3 q3){\n    vec2 res = vec2(1e5,0.), p, ip, ct = vec2(0);\n\n    q3.y+=(t4*2.);\n    \n    float t=1e5, y=1e5, m=1.;\n    for(int i =0; i<4; i++){\n    \n        ct = ps4[i]/2. -  ps4[0]/2.;\n        p = q3.xz - ct*s;\n        ip = floor(p/s) + .5;\n        p -= (ip)*s;\n        vec2 idi = (ip + ct)*s;\n \n        vec2 b = pattern(p,idi);\n        float k = opx(b.x,q3.y,5.);\n        float j = cap(vec3(p.x,q3.y-t1,p.y),2.+t1,.96);\n        float kj=max(j,-k);\n        \n        if(j<t ) {     \n            m = j<k-.08 ? kj<k ? mod(float(i),2.)<1.? 5.: 4. : 7. : 6.;   \n            \n            t =kj;\n            s_id = idi;\n            s_hit = vec3(p.x,q3.y-t1*2.,p.y)+(idi.xyx*vec3(.5)+float(i));\n        }\n    }\n    \n\tif(t<res.x) res = vec2(t,m);\n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec4 FC = vec4(.07,.07,.06,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0), p = ro;\n    float m = 0.;\n\n    for(int i=0;i<100;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.25: ray.x;\n        m  = ray.y;\n    } \n    g_hit = s_hit;\n    g_id = s_id;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 l = normalize(vec3(-7.+tspeed,15,-4)-p);\n        float diff = clamp(dot(n,l),0.,1.);\n        \n        int face;\n        vec3 cuv = s_hit;\n           \n        if(m>3.) { // quick find the correct face with normal\n            vec3 tn = n;\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n\n            if(face==0||face==5) cuv = s_hit.yzx;\n            if(face==1||face==4) cuv = s_hit.xzy+vec3(.5);\n            if(face==2||face==3) cuv = s_hit.xyz-vec3(.5);\n        }\n        \n        vec3 h = vec3(.15);\n\n        if( m==5.) {\n            float hs = clamp(hash21(g_id),.25,.85);\n            h = texture(iChannel0,cuv.xy).rgb*vec3(.9,vec2(.8,.2)*hs);\n            ref = h*.75;\n        }\n        if( m==4.) {\n            h = texture(iChannel1,cuv.xy*.125).rgb;\n            ref = h*.25;\n        }\n        if( m==6.) {\n            h = vec3(.8);\n            ref = vec3(.2);\n        }\n        if( m==7.) {\n            h = vec3(.0);\n            ref = vec3(.2);\n        }\n        \n        float shdw = 1.;\n        for( float t=.01; t < 8.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>18. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        C = h * diff;\n        ro = p+n*1e-3;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC.rgb;\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    tspeed = T*.4;\n    tmod = mod(tspeed,8.);\n    t4 = lerp(0.,8.,tmod);\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(uv*9.,-12.);\n    vec3 rd = vec3(0,0,1.);\n    \n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y * .06-.03)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x * 1.0-.50)*PI;\n    mat2 rx =rot(.68-x), ry =rot(-.48-y);\n    \n    ro.zy*=rx, ro.xz*=ry;\n    rd.zy*=rx, rd.xz*=ry;\n    ro.xy += vec2(tspeed,2.);\n    vec3 C = vec3(0),ref=vec3(0),fil=vec3(1);\n    \n    float d = 0.,a = 0.;\n\n    float numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        d = 0.;\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) a = d;\n    }\n\n    C = mix(FC.rgb,C, exp(-.0002*a*a*a));\n    O = vec4(pow(C, vec3(.4545)),1);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcKfz1","date":"1733803720","viewed":214,"name":"Ever-falling Truchet Tubes","username":"byt3_m3chanic","description":"Ever falling illusion with Linear interpolation.\nBegan as another shader project that I kept working on to take 2D to 3D.","likes":32,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","truchet","lerp","rotation","cylinder"],"hasliked":0,"parentid":"","parentname":""}}