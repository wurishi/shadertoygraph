{"ver":"0.1","info":{"id":"XlVyWd","date":"1538616002","viewed":203,"name":"REND_SHD_A1_P11","username":"theTDC","description":"Takes the last shader and clamps the maximum size. This means that we will never get that ugly square effect when a pixel is at or near full brightness.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circles","vfs","pesce"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader 4.5, load in texture, then make circle large depending on brightness. Do this seperately for different channels.\n// Also, calculate a drop off/fuzziness effect around the edges of each circle.\n\n/********************************************************************************************************\nThis function now guarantees that the fuzziness will not go \"outside\" the grid, and get clamped into an ugly\nsquare. We also have the circles perfectly formed.\n********************************************************************************************************/\n\nvec4 calcChannel(vec4 channel, float rad, vec2 fCoord, vec4 outCol){    \n    \n    // can now take totally arbitrary size, and spit out grid of circles.\n    vec2 spot = mod(fCoord, vec2(rad*2., rad*2.));\n\n    vec2 center = vec2(rad+1., rad+1.);\n    \n    // replace distance with brightness\n    vec4 pxCol = texture(iChannel0, fCoord/iResolution.xy);\n    \n    // here we actually need to get the pxCol for the center of our \"grid\"\n    vec2 gridCent = fCoord;\n    gridCent.x += center.x-spot.x;\n    gridCent.y += center.y-spot.y;\n    \n    // fixed...\n    \n    pxCol = texture(iChannel0, gridCent/iResolution.xy);\n    \n    // Not that it really matters here, but I decided to use \"correct\" rgb->grey.\n    float brightness = pxCol.r*0.2126 + pxCol.g*0.7152 + pxCol.b*0.0722;\n    \n    // The true radius of the circle we're checking against is now actually the maxRadius * brightness, which is 0-1\n    float trueRad = rad * brightness;\n    \n    vec2 disVec = vec2((spot.x-center.x), (spot.y-center.y));\n    float dis = sqrt(disVec.x*disVec.x + disVec.y*disVec.y);\n    \n    // We need to modify the radius, or else a very bright pixel will be \"banded\"\n    // fudge-1.0 == extra distance.\n    float fudge = 1.6;\n\tdis*=fudge;\n        \n    // if inside the circle.\n    if(dis < trueRad)\n        outCol += channel;\n    \n    float ultraMaxRad = trueRad*fudge;\n        \n    if(dis > trueRad && dis < ultraMaxRad){\n        float disPerc = (dis/trueRad);\n        disPerc -= 1.0;\n        \n        disPerc = (fudge-1.0) - disPerc;\n        \n        disPerc/=(fudge-1.0);\n        outCol += channel*disPerc;\n    }\n    \n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 red = vec4(1, 0, 0, 1);\n    vec4 green = vec4(0,1,0,1);\n    vec4 blue = vec4(0,0,1,1);\n    \n    fragColor = vec4(0,0,0,1);\n    \n    float constRad = 5.;\n    \n    // At home, set the channels differently again.\n    /*\n    fragColor = calcChannel(red, constRad, fragCoord, fragColor);\n    fragColor = calcChannel(green, constRad, fragCoord, fragColor);\n    fragColor = calcChannel(blue, constRad, fragCoord, fragColor);\n    */\n    \n\t//fragColor = calcChannel(red, 2.5, fragCoord, fragColor);\n    fragColor = calcChannel(green, 4.2, fragCoord, fragColor);\n    fragColor = calcChannel(blue, 7.6, fragCoord, fragColor);\n\t\n    \n}","name":"Image","description":"","type":"image"}]}