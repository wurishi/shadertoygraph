{"ver":"0.1","info":{"id":"WsKSDm","date":"1574242845","viewed":162,"name":"simple ray intersection 2","username":"neur0sys","description":"learning ray intersection stuff","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["lineplaneintersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://en.wikipedia.org/wiki/Specular_reflection#Law_of_reflection\n// https://en.wikipedia.org/wiki/Lambertian_reflectance\n\n#define M_PI 3.14159265358979\n\n\nstruct Hit {\n\tvec3 c;\n    vec3 p;\n    bool h;\n};\n\nvec3 traceAmbient()\n{\n    // ambient\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * vec3(1.0);\n    return ambient;\n}\n\nvec3 traceDiffuse(vec3 lightDir, vec3 n)\n{\n    // diffuse\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(1.0);\n    \n    vec3 c = vec3(1.0);\n    \n    return diffuse * c;\n}\n\nvec3 traceSpecular(vec3 lightDir, vec3 hit, vec3 l0, vec3 n)\n{\n    // specular\n    vec3 viewDir = normalize(hit - l0);\n    vec3 reflectDir = reflect(lightDir, n); \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);\n    return vec3(spec);\n}\n\nvec3 getLightPos()\n{\n    float t0 = iTime;\n    vec3 lightPos = vec3(0.0, 6.0, -10.0);\n    lightPos.z += cos(t0) * 8.0;\n    lightPos.x += sin(t0) * 8.0;\n    return lightPos;\n}\n\n\nvec3 traceLight(vec3 n, vec3 hit, vec3 l0)\n{\n    vec3 lightDir = normalize(getLightPos() - hit);\n    \n    vec3 ambient = traceAmbient();\n\n    vec3 diffuse = traceDiffuse(lightDir, n);\n\n    vec3 spec = traceSpecular(lightDir, hit, l0, n);\n   \n    return ambient + diffuse + spec;\n}\n\n// https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\nHit tracePlane(vec3 l0, vec3 l)\n{\n \t// plane equation\n    // (p - p0) . n = 0\n    \n    // t = ((p0 - l0) . n) / (l . n)\n \n    vec3 n = vec3(0.0, 1.0, 0.0);\n    vec3 p0 = vec3(-1.0, -1.0, -1.0);\n    \n    float denom = dot(n, l);\n    if (denom < 1e-6) {\n    \tfloat t = dot((p0 - l0), n) / denom;\n        vec3 hit = l0 + l * t;\n        \n        vec3 light = traceLight(n, hit, l0);\n        \n        vec3 c = vec3(1.0);\n        c += -1.0 * texture(iChannel0, hit.xz / 7.0).xyz * vec3(0.4, 0.9, 0.9);\n        \n        // checker board\n        float u = mod(hit.x, 2.0);\n        float v = mod(hit.z, 2.0);\n        \n        if ((u > 1.0 && v > 1.0) || (u < 1.0 && v < 1.0)) {\n            c -= 0.5;\n        }\n\n        return Hit(c * light, hit, true);\n    } else {\n    \treturn Hit(vec3(0.0), vec3(0.0), false);\n    }\n}\n\n\n// https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\nHit traceSphere(vec3 l0, vec3 l, vec3 o, float r, bool isFlat)\n{\n    // sphere: dot((p - c), (p - c)) = r * r\n    // line = a + t * b\n    \n    // t = (-b -+ sqrt(b*b - 4*a*c)) / 2*a\n    \n    // a = dot (b, b)\n    // b = 2 * dot (b, a-c)\n    // c = dot (a - c, a - c) - r * r\n   \n    float yOffset = cos(iTime / 3.0) * 2.0;\n    float zOffset = sin(iTime / 3.0) * 2.0;\n    float xOffset = sin(iTime / 3.0) * 2.0;\n    \n    //o.y += yOffset;\n    //o.z += zOffset;\n    //o.x += xOffset;\n    \n    float a = dot(l, l);\n    float b = 2.0 * dot(l, l0 - o);\n    float c = dot(l0 - o, l0 - o) - r * r;\n    float dis = b * b - 4.0 * a * c;\n    \n    if (dis < 0.) {\n        return Hit(vec3(0.0), vec3(0.0), false);\n    }\n    \n    float t = (-b - sqrt(dis)) / (2.0*a);\n    \n    vec3 hit = l0 + l * t;\n    vec3 n = normalize(hit - o);\n    vec3 light = traceLight(n, hit, l0);\n    \n    if (isFlat) {\n    \treturn Hit(vec3(1.0), hit, true);\n    }\n    \n    vec3 c0 = vec3(1.0);\n    \n    // https://en.wikipedia.org/wiki/UV_mapping#Finding_UV_on_a_sphere\n    // u = 0.5 + (arctan2(dz, dx)) / 2 * pi\n    // v = 0.5 - arcsin(dy) / pi\n    vec3 d = normalize(hit - o);\n    float u = mod(atan(d.z, d.x) / (2.0 * M_PI), 1.0);\n    float v = mod(asin(d.y) / M_PI, 1.0);\n    c0 = texture(iChannel1, vec2(u + iTime / 8.0, v)).xyz * 1.5;\n  \n    c0 = c0 * light;\n    \n    return Hit(c0, hit, true);\n}\n\nvec3 render(vec2 uv)\n{\n    // ray equation\n    // p = l0 + l * t\n    \n\tvec3 l0 = vec3(0.0, 0.0, 1.0);\n    vec3 l = normalize(vec3(uv, -1.0));\n \n    float yOffset = sin(iTime / 2.0) * 2.0 + 2.0;\n    float zOffset = cos(iTime / 2.0) * 3.0 + 3.0;\n    float xOffset = cos(iTime / 2.0) * 4.0 + 4.0;\n    \n    l0.y += yOffset;\n    l0.z += zOffset;\n    l0.x += xOffset;\n    \n    vec3 c = vec3(0.0);\n    \n    Hit hits[3];\n    \n    hits[0] = tracePlane(l0, l);\n    \n    hits[1] = traceSphere(l0, l, vec3(3.0, 0.0, -4.0), 1.0, false);\n    \n    hits[2] = traceSphere(l0, l, getLightPos(), 0.3, true);\n\n    Hit closest = Hit(vec3(0.0), vec3(0.0), false);\n    \n    for (int i = 0; i < 3; i++) {\n        if (hits[i].h && distance(hits[i].p, closest.p) > 0.0) {\n        \tclosest = hits[i];\n        }\n    }\n    \n    // Very naive and dumb way to calculate dynamic shadows I pulled out of the hat.\n    // Cast from hit point to light source, if intersects with any object it's in dark\n    if (closest.h) {\n    \tvec3 hit = closest.p;\n        vec3 light = getLightPos();\n        \n        // Add 1e-3 to the sphere radius size to get rid of an artifact (not sure).\n        Hit occluded = traceSphere(hit, light, vec3(3.0, 0.0, -4.0), 1.0 + 1e-3, false);\n        \n        if (occluded.h) {\n            closest.c *= 0.5;\n        }\n        \n    }\n    \n    return closest.c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //uv.y = 1.0 - uv.y;\n    uv = uv * 2.0 - 1.0;\n \tuv.x *= iResolution.x / iResolution.y;\n\n    vec3 c = render(uv);\n\n    // c += render(uv + vec2(-0.001, 0.001));\n    // c += render(uv + vec2( 0.000, 0.001));\n    // c += render(uv + vec2( 0.001, 0.001));\n    // c += render(uv + vec2(-0.001, 0.000));\n    // c += render(uv + vec2( 0.000, 0.000));\n    // c += render(uv + vec2( 0.001, 0.000));\n    // c += render(uv + vec2(-0.001,-0.001));\n    // c += render(uv + vec2( 0.000, 0.001));\n    // c += render(uv + vec2( 0.001,-0.001));\n    \n    // c /= 9.0;\n    fragColor = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}