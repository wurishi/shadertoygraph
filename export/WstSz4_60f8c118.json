{"ver":"0.1","info":{"id":"WstSz4","date":"1571603869","viewed":194,"name":"Kuramoto-Sivashinsky","username":"vdecaria","description":"Kuramoto-Sivashinsky - Fourth order in space, chaotic pde.\n\nPress space to reset. Use mouse to place source.\n\nChange nonlin_type to 1 (common, line 27) for sweeping effect.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["pde","kuramotosivashinsky","fourthorder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Navier-Stokes equation\" by vdecaria. https://shadertoy.com/view/tsK3DK\n// 2019-10-20 13:20:49\n/*\nhttps://en.wikipedia.org/wiki/Kuramoto%E2%80%93Sivashinsky_equation\nWas going to a steady state, so I modulate the nonlinear term to keep\nit interesting.\n*/\nvec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 temp_all = texture(iChannel0,fragCoord.xy / iResolution.xy)/view_scaling;\n    vec2 temp = temp_all.xy;\n    temp = vec2(max(0.,temp.x),max(0.,-temp.x));\n    fragColor = vec4(temp,0.,0.);\n\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvec2 euler(sampler2D g, vec2 p){\n    vec2 middle    = getT(g,p).xy;   \t\n    vec2 up        = getT(g,p+vec2( 0, int(grid_level))).xy;\n    vec2 down      = getT(g,p+vec2( 0,-int(grid_level))).xy;\n    vec2 right     = getT(g,p+vec2( int(grid_level), 0)).xy;\n    vec2 left      = getT(g,p+vec2(-int(grid_level), 0)).xy;\n    vec2 upright   = getT(g,p+vec2( int(grid_level), int(grid_level))).xy;\t\n    vec2 upleft    = getT(g,p+vec2(-int(grid_level), int(grid_level))).xy;\n    vec2 downright = getT(g,p+vec2( int(grid_level),-int(grid_level))).xy;\n    vec2 downleft  = getT(g,p+vec2(-int(grid_level),-int(grid_level))).xy;\n\t\n    //laplacian(u) = div(grad(u))\n    //Gijs ninepoint stensil.\n    vec2 laplacian\\\n    = (-8.*middle + up + left + right + down + upright + upleft + downright + downleft)/(3.*pow(grid_level,2.)*dx*dx); \n    float grad_square;\n    //grad-squared\n    if(nonlin_type ==0)\n        grad_square = sin(float(iFrame)/period)*0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n    else if(nonlin_type == 1)\n        grad_square = sin(float(iFrame)/period + space_period*3.14*p.x/iResolution.x)*0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n    else if(nonlin_type ==2)\n        grad_square = 0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n\n    return  vec2(middle.x + dt*(-viscosity*laplacian.x - hyper_viscosity*laplacian.y - nonlin_strength*grad_square),laplacian.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float key = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x;\n    \n    if(key >= 1e-1){ //Restart if space bar pressed.\n    \tfragColor.xy = vec2(0.);\n    }\n\n    else{\n       vec2 uv = fragCoord.xy/iResolution.xy;\n\t\n       if(distance(vec2(0.),iMouse.xy) > 1e-3 && distance(iMouse.xy,fragCoord)<circle_radius){\n           fragColor.xy = sin(float(iFrame)/mouse_per)*mouse_speed*dt*vec2(smoothstep(0.,1.,(circle_radius-distance(iMouse.xy,fragCoord))/circle_radius),0.);\n       }  \n       else if(distance(fragCoord.xy,.5*iResolution.xy)<circle_radius ){\n            fragColor.xy = sin(float(iFrame)/mouse_per)*mouse_speed*dt*vec2(smoothstep(0.,1.,(circle_radius-distance(.5*iResolution.xy,fragCoord))/circle_radius),0.);\n        }  \n\n        fragColor.xy += euler(iChannel0,fragCoord);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float viscosity = 0.5;                //Tested down to .01. Gets slow...0.1 is kind of interesting\n                                           //Seems unstable for bigger viscosity.\nconst float hyper_viscosity =1.; \n\nconst float dx = 1.;\nconst float grid_level = 1.;\nconst float dt = hyper_viscosity*dx*dx*dx*dx*.05;    //Smaller value enforces incompressibility more.\nconst float nonlin_strength = 0.0001;         //Proportional to Reynolds number.\n\nconst float mouse_speed = -5000.;   //Set equal to zero to turn mouse 50000\n                                     //into an obstacle.\n\n\nconst float circle_radius = 10.;\n\nint view_option = 1;      // 0 - Green x component of velocity, Red y component\n                            // 1 - Red green vorticity, blue divergence.\nconst float period = 100.;\nconst float mouse_per = period;\n\nconst float view_scaling = 220000.;\n\nconst float space_period = 1.;\n\n\nconst int nonlin_type = 0;    //Change to 1 for different effect.\n\nconst int KEY_SPACE  = 32;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvec2 euler(sampler2D g, vec2 p){\n    vec2 middle    = getT(g,p).xy;   \t\n    vec2 up        = getT(g,p+vec2( 0, int(grid_level))).xy;\n    vec2 down      = getT(g,p+vec2( 0,-int(grid_level))).xy;\n    vec2 right     = getT(g,p+vec2( int(grid_level), 0)).xy;\n    vec2 left      = getT(g,p+vec2(-int(grid_level), 0)).xy;\n    vec2 upright   = getT(g,p+vec2( int(grid_level), int(grid_level))).xy;\t\n    vec2 upleft    = getT(g,p+vec2(-int(grid_level), int(grid_level))).xy;\n    vec2 downright = getT(g,p+vec2( int(grid_level),-int(grid_level))).xy;\n    vec2 downleft  = getT(g,p+vec2(-int(grid_level),-int(grid_level))).xy;\n\t\n    //laplacian(u) = div(grad(u))\n    //Gijs ninepoint stensil.\n    vec2 laplacian\\\n    = (-8.*middle + up + left + right + down + upright + upleft + downright + downleft)/(3.*pow(grid_level,2.)*dx*dx); \n    float grad_square;\n    //grad-squared\n    if(nonlin_type ==0)\n        grad_square = sin(float(iFrame)/period)*0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n    else if(nonlin_type == 1)\n        grad_square = sin(float(iFrame)/period + space_period*3.14*p.x/iResolution.x)*0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n    else if(nonlin_type ==2)\n        grad_square = 0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n\n    return  vec2(middle.x + dt*(-viscosity*laplacian.x - hyper_viscosity*laplacian.y - nonlin_strength*grad_square),laplacian.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float key = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x;\n    \n    if(key >= 1e-1){ //Restart if space bar pressed.\n    \tfragColor.xy = vec2(0.);\n    }\n\n    else{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t\n    if(distance(vec2(0.),iMouse.xy) > 1e-3 && distance(iMouse.xy,fragCoord)<circle_radius){\n           fragColor.xy = sin(float(iFrame)/mouse_per)*mouse_speed*dt*vec2(smoothstep(0.,1.,(circle_radius-distance(iMouse.xy,fragCoord))/circle_radius),0.);\n    }\n    else if(distance(fragCoord.xy,.5*iResolution.xy)<circle_radius ){\n         fragColor.xy = sin(float(iFrame)/mouse_per)*mouse_speed*dt*vec2(smoothstep(0.,1.,(circle_radius-distance(.5*iResolution.xy,fragCoord))/circle_radius),0.);\n     }  \n\n    fragColor.xy += euler(iChannel0,fragCoord);\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvec2 euler(sampler2D g, vec2 p){\n    vec2 middle    = getT(g,p).xy;   \t\n    vec2 up        = getT(g,p+vec2( 0, int(grid_level))).xy;\n    vec2 down      = getT(g,p+vec2( 0,-int(grid_level))).xy;\n    vec2 right     = getT(g,p+vec2( int(grid_level), 0)).xy;\n    vec2 left      = getT(g,p+vec2(-int(grid_level), 0)).xy;\n    vec2 upright   = getT(g,p+vec2( int(grid_level), int(grid_level))).xy;\t\n    vec2 upleft    = getT(g,p+vec2(-int(grid_level), int(grid_level))).xy;\n    vec2 downright = getT(g,p+vec2( int(grid_level),-int(grid_level))).xy;\n    vec2 downleft  = getT(g,p+vec2(-int(grid_level),-int(grid_level))).xy;\n\t\n    //laplacian(u) = div(grad(u))\n    //Gijs ninepoint stensil.\n    vec2 laplacian\\\n    = (-8.*middle + up + left + right + down + upright + upleft + downright + downleft)/(3.*pow(grid_level,2.)*dx*dx); \n    float grad_square;\n    //grad-squared\n    if(nonlin_type ==0)\n        grad_square = sin(float(iFrame)/period)*0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n    else if(nonlin_type == 1)\n        grad_square = sin(float(iFrame)/period + space_period*3.14*p.x/iResolution.x)*0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n    else if(nonlin_type ==2)\n        grad_square = 0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n\n    return  vec2(middle.x + dt*(-viscosity*laplacian.x - hyper_viscosity*laplacian.y - nonlin_strength*grad_square),laplacian.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float key = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x;\n    \n    if(key >= 1e-1){ //Restart if space bar pressed.\n    \tfragColor.xy = vec2(0.);\n    }\n\n    else{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t\n    if(distance(vec2(0.),iMouse.xy) > 1e-3 && distance(iMouse.xy,fragCoord)<circle_radius){\n           fragColor.xy = sin(float(iFrame)/mouse_per)*mouse_speed*dt*vec2(smoothstep(0.,1.,(circle_radius-distance(iMouse.xy,fragCoord))/circle_radius),0.);\n    }\n    else if(distance(fragCoord.xy,.5*iResolution.xy)<circle_radius ){\n         fragColor.xy = sin(float(iFrame)/mouse_per)*mouse_speed*dt*vec2(smoothstep(0.,1.,(circle_radius-distance(.5*iResolution.xy,fragCoord))/circle_radius),0.);\n     }  \n\n    fragColor.xy += euler(iChannel0,fragCoord);\n    }\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvec2 euler(sampler2D g, vec2 p){\n    vec2 middle    = getT(g,p).xy;   \t\n    vec2 up        = getT(g,p+vec2( 0, int(grid_level))).xy;\n    vec2 down      = getT(g,p+vec2( 0,-int(grid_level))).xy;\n    vec2 right     = getT(g,p+vec2( int(grid_level), 0)).xy;\n    vec2 left      = getT(g,p+vec2(-int(grid_level), 0)).xy;\n    vec2 upright   = getT(g,p+vec2( int(grid_level), int(grid_level))).xy;\t\n    vec2 upleft    = getT(g,p+vec2(-int(grid_level), int(grid_level))).xy;\n    vec2 downright = getT(g,p+vec2( int(grid_level),-int(grid_level))).xy;\n    vec2 downleft  = getT(g,p+vec2(-int(grid_level),-int(grid_level))).xy;\n\t\n    //laplacian(u) = div(grad(u))\n    //Gijs ninepoint stensil.\n    vec2 laplacian\\\n    = (-8.*middle + up + left + right + down + upright + upleft + downright + downleft)/(3.*pow(grid_level,2.)*dx*dx); \n    float grad_square;\n    //grad-squared\n    if(nonlin_type ==0)\n        grad_square = sin(float(iFrame)/period)*0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n    else if(nonlin_type == 1)\n        grad_square = sin(float(iFrame)/period + space_period*3.14*p.x/iResolution.x)*0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n    else if(nonlin_type ==2)\n        grad_square = 0.5*( pow((up.x - down.x)/(2.*dx),2.) + pow((left.x - right.x)/(2.*dx),2.) );\n\n    return  vec2(middle.x + dt*(-viscosity*laplacian.x - hyper_viscosity*laplacian.y - nonlin_strength*grad_square),laplacian.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float key = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x;\n    \n    if(key >= 1e-1){ //Restart if space bar pressed.\n    \tfragColor.xy = vec2(0.);\n    }\n\n    else{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t\n    if(distance(vec2(0.),iMouse.xy) > 1e-3 && distance(iMouse.xy,fragCoord)<circle_radius){\n           fragColor.xy = sin(float(iFrame)/mouse_per)*mouse_speed*dt*vec2(smoothstep(0.,1.,(circle_radius-distance(iMouse.xy,fragCoord))/circle_radius),0.);\n    }\n    else if(distance(fragCoord.xy,.5*iResolution.xy)<circle_radius ){\n         fragColor.xy = sin(float(iFrame)/mouse_per)*mouse_speed*dt*vec2(smoothstep(0.,1.,(circle_radius-distance(.5*iResolution.xy,fragCoord))/circle_radius),0.);\n     }  \n\n    fragColor.xy += euler(iChannel0,fragCoord);\n    }\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}