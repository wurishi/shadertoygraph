{"ver":"0.1","info":{"id":"NtcSDs","date":"1639954353","viewed":351,"name":"chocolate swirl Commented","username":"wnu","description":"normals!\n\nIf anyone has an approach that can help with the aliasing, while still keeping the detail, that would be appreciated!","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["normal","height"],"hasliked":0,"parentid":"NstSRH","parentname":"height based normals"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1.;\n\n// Swirly function\n\nfloat height(vec2 p){\n    for(int i=1; i<10; i++){\n        p.x+=.3/float(i)*sin(float(i)*4.*p.y+iTime*1.);\n        p.y+=.3/float(i)*cos(float(i)*4.*p.x+iTime*1.);\n    }\n    \n    float r = cos(p.x+p.y+1.)*.5+.5;\n    \n    return r/5.;\n}\n\n// Get normal from height function using derivatives\n\nvec3 normal(vec2 p) {\n  // Originally inspired by IQ from the source I copied this from.\n  vec2 eps = -vec2(1.0/iResolution.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p + eps.xy) - height(p - eps.xy); //left height - right height\n  n.y = height(p + eps.yx) - height(p - eps.yx); //down height - up height\n  n.z = 2.0*eps.x;\n  \n  return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy/iResolution.xy- vec2(0.5))*2.0;\n    p.x *= iResolution.x/iResolution.y;\n    p *= 0.3;\n    \n    // Get height and normal\n    \n    \n    \n    float h = height(p);\n    vec3 n = normal(p);\n    \n    #ifdef AA \n    vec3 r = vec3(1. / iResolution.xy, 0.);\n    \n    n = normal(p + r.xz);\n    n += normal(p - r.xz);\n    n += normal(p + r.zy);\n    n += normal(p - r.zy);\n    n /= 4.;\n    #endif\n    \n    // Height augmented position\n    \n    vec3 ph = vec3(p.x,p.y,h);\n    \n    // Light position and direction from points to the light\n    \n    vec3 light = vec3(0.8,0.9,-0.9);\n    vec3 ldir = normalize(light-ph);\n    \n    // Get shine based on angle of normal to light direction\n    \n    float shine = max(dot(ldir,n),0.);\n    \n    // Choose color, and create variable for the dark spots of the height function\n    \n    float fillDark = smoothstep(0.75,0.0,h*5.);\n    vec3 chocolateColor = vec3(139.,69.,19.)/255.;\n    \n    // Base coloring\n    \n    vec3 col = chocolateColor +fillDark*vec3(2.,1.,1.);\n    col *= h*5.;\n    \n    // Add 2 layers of exponentiated shine for highlights\n    \n    col += 0.5*pow(shine,8.);\n    col += 0.1*pow(shine,2.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}