{"ver":"0.1","info":{"id":"Ms3yzS","date":"1519313305","viewed":640,"name":"Splat Mapping","username":"PrzemyslawZaworski","description":"Seamless blending between three textures. Opacity map is procedural.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","terrain","blur","map","blending","mapping","texturing","splat","seamless","splatting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//reference: https://www.gamedev.net/articles/programming/graphics/advanced-terrain-texture-splatting-r3287/\n//Shader created by Przemyslaw Zaworski 22.02.2018\n\n//#define show_opacity_map\n\nfloat hash(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n    float a = hash(ip+vec2(0.0,0.0));\n    float b = hash(ip+vec2(1.0,0.0));\n    float c = hash(ip+vec2(0.0,1.0));\n    float d = hash(ip+vec2(1.0,1.0));\n\tfloat res = mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm( vec2 p )\n{\n    mat2 m2 = mat2(0.8,-0.6,0.9,0.6);\n    float f = 0.0;\n    f += 0.5000*noise(p); p = m2*p*2.02;\n    f += 0.2500*noise(p); p = m2*p*2.03;\n    f += 0.1250*noise(p); p = m2*p*2.01;\n    f += 0.0625*noise(p);\n    return f/0.9375;\n}\n\nvec3 surface(vec2 uv)\n{\n   \tfloat color = fbm(uv);\n    if (color<0.2) return vec3(1,0,0);\n    else if (color<0.5) return vec3(0,1,0);       \n\telse return vec3(0,0,1);\n}\n\nvec3 blur(vec2 uv,float rad)\n{\n    mat2 rot = mat2(cos(2.399),sin(2.399),-sin(2.399),cos(2.399));\n\tvec3 acc=vec3(0.0,0.0,0.0);\n    vec2 pixel=vec2(0.002*iResolution.y/iResolution.x,0.002),angle=vec2(0.0,rad);;\n    rad=1.0;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1.0/rad;\n\t    angle*=rot;\n        vec4 col=vec4(surface(uv+pixel*(rad-1.0)*angle),1.0); \n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.0;\n}\n\nfloat make_depthmap (vec3 color)\n{\n\treturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 blend(vec4 texture1, float a1, vec4 texture2, float a2, vec4 texture3, float a3)\n{\n    float d1 = make_depthmap(texture1.rgb);\n    float d2 = make_depthmap(texture2.rgb);\n    float d3 = make_depthmap(texture3.rgb);\n\tfloat ma = max(max(d1 + a1, d2 + a2),d3 + a3) - 0.6;\n\tfloat b1 = max(d1 + a1 - ma, 0.0);\n\tfloat b2 = max(d2 + a2 - ma, 0.0);\n\tfloat b3 = max(d3 + a3 - ma, 0.0);\n\treturn (texture1.rgb * b1 + texture2.rgb * b2 + texture3.rgb * b3) / (b1 + b2 + b3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float m1 = blur(p,3.0).r;\n\tfloat m2 = blur(p,3.0).g;\n\tfloat m3 =blur(p,3.0).b;\n\tvec3 color = blend(texture(iChannel0,uv),m1,texture(iChannel1,uv),m2,texture(iChannel2,uv),m3);\n    fragColor = vec4(color,1.0);\n    #ifdef show_opacity_map\n    fragColor = vec4(blur(p,3.0),1.0);\n    #endif\n}","name":"Image","description":"","type":"image"}]}