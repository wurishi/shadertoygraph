{"ver":"0.1","info":{"id":"mtjBWK","date":"1694551751","viewed":28,"name":"Newton's Fractal (bruh)","username":"DanielKh","description":"It's Newton's fractal (it only seems to work on some devices, I don't know why)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","newtonsfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//there's a bunch of junk from a better version that I was planning to make\n\n/*\nvec3 hsv(float h, float s, float v) {\n    h=mod(h,360.0);\n    vec3 rpgpbp;\n    float c=v*s;\n    float x=c*(1.0-abs(mod(h/60.0,2.0)-1.0));\n    float m=v-c;\n    if (h<60.0) {\n        rpgpbp=vec3 (c,x,0.0);\n    } else if (h<120.0) {\n        rpgpbp=vec3 (x,c,0.0);\n    } else if (h<180.0) {\n        rpgpbp=vec3 (0.0,c,x);\n    } else if (h<240.0) {\n        rpgpbp=vec3 (0.0,x,c);\n    } else if (h<300.0) {\n        rpgpbp=vec3 (x,0.0,c);\n    } else {\n        rpgpbp=vec3 (c,0.0,x);\n    }\n    return vec3 (rpgpbp.r+m,rpgpbp.g+m,rpgpbp.b+m);\n}\n\n//coloration based on position\n//vec3 randomcolorbyxy(vec2 fcoord) {\n//    return hsv(180.0 + 180.0*cos(fcoord.x/30.0)+500.0/sin((fcoord.y-iResolution.y/2.0)/100.0),0.7,1.0);\n//}\n\nvec3 randomcolorbyxy(vec2 fcoord) {\n    if (fcoord.x<0.0&&fcoord.y>0.0) {\n        return vec3 (1.0,0.0,0.0);\n    } else if (fcoord.x<0.0&&fcoord.y<0.0) {\n        return vec3 (0.0,1.0,0.0);\n    } else {\n        return vec3 (0.0,0.0,1.0);\n    }\n}\n\n//this is a procedure to multiply two complex numbers\nvec2 cmult (vec2 a, vec2 b) {\n    return vec2 (a.x*b.x-a.y*b.y,a.y*b.x+a.x*b.y);\n}\n\n\n\n//this is the subject function defined in terms of complex numbers\nvec2 function (vec2 z) {\n    return cmult(z, vec2 (z.x,z.y))-7.0;\n}\n\n//this is the derivative of the subject function in terms of complex numbers\nvec2 derivative (vec2 z) {\n    return 2.0*z;\n}\n\n\n\nvec2 function (vec2 z) {\n    return cmult(z,cmult(z, vec2 (z.x,z.y)))+3.0*cmult(z, vec2 (z.x,z.y))+z-5.0;\n}\n\n//this is the derivative of the subject function in terms of complex numbers\nvec2 derivative (vec2 z) {\n    return 3.0*cmult(z, vec2 (z.x,z.y))+6.0*z+1.0;\n}\n\n*/\n\n//this is the Newton Raphson method. It looks so complicated mostly because of the complex number division\nvec2 math (vec2 gcoord, int iterations) {\n    vec2 guess = gcoord;\n    for (int i=0;i<iterations;i++) {\n        float a = guess.x;\n        float b = guess.y;\n        guess.x=guess.x-((3.*pow(a,5.)+20.*pow(a,4.)+6.*pow(a,3.)*(pow(b,2.)+6.)+6.*pow(a,2.)*(4.*pow(b,2.)-11.)+a*(3.*pow(b,4.)+32.*pow(b,2.)-207.)+2.*(2.*pow(b,4.)+41.*pow(b,2.)-13.))/(9.*pow(a,4.)+48.*pow(a,3.)+(2.*pow(a,2.))*(9.*pow(b,2.)+35.)+16.*a*(3.*pow(b,2.)+1.)+9.*pow(b,4.)+58.*pow(b,2.)+1.));\n        guess.y=guess.y-(((3.*pow(a,4.)+16.*pow(a,3.)+2.*pow(a,2.)*(3.*pow(b,2.)+16.)+4.*a*(4.*pow(b,2.)+41.)+3.*pow(b,4.)+28.*pow(b,2.)+209.)*b)/(9.*pow(a,4.)+48.*pow(a,3.)+(2.*pow(a,2.))*(9.*pow(b,2.)+35.)+16.*a*(3.*pow(b,2.)+1.)+9.*pow(b,4.)+58.*pow(b,2.)+1.));\n    }\n    return guess;\n}\n\n//coloration based on position\nvec3 randomcolorbyxy(vec2 fcoord) {\n    if (fcoord.x<0.0&&fcoord.y>0.0) {\n        return vec3 (0.0,0.0,1.0);\n    } else if (fcoord.x<0.0&&fcoord.y<0.0) {\n        return vec3 (0.0,0.7,1.0);\n    } else {\n        return vec3 (0.7,0.0,1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int iterations = 45;\n    vec2 gspace = (fragCoord.xy-iResolution.xy*vec2(0.5,0.5))*(vec2 (10.0*iResolution.x/iResolution.y,10.0)/iResolution.xy);\n    vec3 col = randomcolorbyxy(math(gspace, iterations));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}