{"ver":"0.1","info":{"id":"wsGBRw","date":"1606776687","viewed":42,"name":"tinyurl.com/SDF-014 ","username":"DEKTEN","description":"BUGFIX: #MINUS_EPSILON# I tried really hard to keep all of the rendering math DISCRETE.\nBut I guess there is no way to avoid the inevitable. Some calculations require you think of\n[pixels/fragments] as having a width & height.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","voxel","pixels","debug","edges","tiles","tilemap","voxelmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** ************************************************ ***\n***                                                  ***\n***     Live Stream Of Me Working On This Code:      ***\n***                                                  ***\n*** ************************************************ ***\n\n                twitch.com/kanjicoder    \n\n*** ************************************************ ***\n***                                                  ***\n*** EASY___SOURCE:  tinyurl.com/SDF-014              ***\n*** DIRECT_SOURCE:  pastebin.com/7xEKkhTB            ***\n***                                                  ***\n*** EASY_____DEMO:  tinyurl.com/SDF-014-DEMO         ***\n*** DIRECT___DEMO:  shadertoy.com/view/wsGBRw        ***\n***                                                  ***\n*** About: Voxel Rendering For Patent Drawings.      ***\n***        This version is a work in progress.       ***\n***                                                  ***\n***        Voxel edge debugging continued.           ***\n***                                                  ***\n*** ************************************************ **/\n//:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM://\n/** M: Macros Section **/\n \n    #define V_4  vec4\n    #define V_3  vec3\n    #define V_2  vec2\n    #define F32 float\n    #define I32   int\n    #define U32  uint\n\n/** M: Macros Section **/\n//:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM://\n//:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD://\n/** D: Data Section **/\n\n    //:DEBUGGING:====================================://\n\n        V_4 THE_COLOR_OF_EMPTY_SPACE=V_4(\n            0.0 , 0.0 , 0.0 , 1.0\n        /** RED   GRE   BLU   ALP **/\n        );\n\n    //:====================================:DEBUGGING://\n    //:CONFIGURATION:================================://\n\n        //:CAMERA_SETTINGS:==========================://\n        /** **************************************** ***\n        PREFIX:\n\n            OGP: OrthoGraphicProjection\n            P3D: Perspective_3D \n            T3O: TUBE360_OUT (TubeCam Looking OUTWARD)\n            T3I: TUBE360_INN (TubeCam Looking INWARD )\n\n        POSTFIX: (SUFFIX ):\n            TOP: Top View\n            34D: 3/4 Tilted DOWN view. \n            AAZ: Around_Axis_Z (NOT:WAZ)\n\n        NOTES:\n\n            T3O    : commonly known as PANORAMIC 360  \n            TubeCam: Revolve Around Axis As Camera.\n                     Literally \"Tube Camera\"\n\n        *** **************************************** **/\n\n            #define OGP_TOP ( 1 ) /** Good For Debug **/\n            #define OGP_34D ( 2 ) /** PATENT_DRAWING **/\n            #define T3O_AAZ ( 3 ) /** Outward: Z-Axis**/\n            #define T3I_AAZ ( 4 ) /** Inward : Z-Axis**/\n\n            /** Selected Camera Type **/\n            #define CAMTYPE ( OGP_34D )\n        //  #define CAMTYPE ( OGP_TOP )\n        //  #define CAMTYPE ( T3I_AAZ )\n\n        //:==========================:CAMERA_SETTINGS://\n\n        /** SLICE_RENDER_USING_CAMERA_PLANE **/\n        int CFG_SLICE_RENDER=( 0 );\n\n    //:================================:CONFIGURATION://\n    //:RAYMARCHING_AND_VOXEL_CONSTANTS:==============://\n\n        //:These defines are for ray marching when using\n        //:fragment coordinates as our coordinate space.\n        #define MAX_STE 1000   //:Max Step\n        #define MIN_DIS 0.02   //:Min Dist (SurfaceDist)\n        #define MAX_DIS (64.0*16.0 * 1.0) //:Max Dist\n\n        //:Number of tiles on each axis:\n        #define TILEMAP_PRESET ( 333 )\n        #if( 847 == TILEMAP_PRESET ) /** 8 x 4 x 7 **/\n\n            #define NTX  8  //: Number Of [tiles/voxels]\n            #define NTY  4  //: Number Of [tiles/voxels]\n            #define NTZ  7  //: Number Of [tiles/voxels]\n\n        #endif\n        #if( 111 == TILEMAP_PRESET )\n\n            #define NTX  1  //: Number Of [tiles/voxels]\n            #define NTY  1  //: Number Of [tiles/voxels]\n            #define NTZ  1  //: Number Of [tiles/voxels]\n\n        #endif\n        #if( 222 == TILEMAP_PRESET )\n\n            #define NTX  2  //: Number Of [tiles/voxels]\n            #define NTY  2  //: Number Of [tiles/voxels]\n            #define NTZ  2  //: Number Of [tiles/voxels]\n\n        #endif\n        #if( 333 == TILEMAP_PRESET )\n\n            #define NTX  3  //: Number Of [tiles/voxels]\n            #define NTY  3  //: Number Of [tiles/voxels]\n            #define NTZ  3  //: Number Of [tiles/voxels]\n\n        #endif\n\n        #define VOXEL_SIZE_PRESET ( 555 )\n        #if( 555 == VOXEL_SIZE_PRESET )\n\n            //:Size_Of_A_Voxel_Tile_Measured_In_Pixels:\n            #define NPX  5 //: NPX : Num_Pixels_X \n            #define NPY  5 //: NPY : Num_Pixels_Y \n            #define NPZ  5 //: NPZ : Num_Pixels_Z \n\n        #endif\n        #if( 567 == VOXEL_SIZE_PRESET )\n\n            //:Size_Of_A_Voxel_Tile_Measured_In_Pixels:\n            #define NPX  5 //: NPX : Num_Pixels_X \n            #define NPY  6 //: NPY : Num_Pixels_Y \n            #define NPZ  7 //: NPZ : Num_Pixels_Z \n\n        #endif\n        #if( 579 == VOXEL_SIZE_PRESET )\n\n            //:Size_Of_A_Voxel_Tile_Measured_In_Pixels:\n            #define NPX  5 //: NPX : Num_Pixels_X \n            #define NPY  7 //: NPY : Num_Pixels_Y \n            #define NPZ  9 //: NPZ : Num_Pixels_Z \n\n        #endif\n        #if( 51015 == VOXEL_SIZE_PRESET )\n\n            //:Size_Of_A_Voxel_Tile_Measured_In_Pixels:\n            #define NPX   5 //: NPX : Num_Pixels_X \n            #define NPY  10 //: NPY : Num_Pixels_Y \n            #define NPZ  15 //: NPZ : Num_Pixels_Z \n\n        #endif\n\n        //:Total__number_of__Pixels__in_entire_voxel_map\n        #define TPX  ( NTX * NPX ) //: Total_Pixels_X\n        #define TPY  ( NTY * NPY ) //: Total_Pixels_Y\n        #define TPZ  ( NTZ * NPZ ) //: Total_Pixels_Z\n\n    //: - :// \n        #define _  U32( 0 )                                         \n        #define X  U32( 1 )  \n        #define R  U32( 0xFF0000ff ) //: PRIMARY\n        #define r  U32( 0x880000ff ) //: PRIMARY\n        #define G  U32( 0x00FF00ff ) //: PRIMARY\n        #define g  U32( 0x008800ff ) //: PRIMARY\n        #define B  U32( 0x0000FFff ) //: PRIMARY\n        #define b  U32( 0x000088ff ) //: PRIMARY\n    //: - ://              \n        #define C  U32( 0x00FFFFff ) //: SECONDARY\n        #define c  U32( 0x008888ff ) //: SECONDARY\n        #define M  U32( 0xFF00FFff ) //: SECONDARY\n        #define m  U32( 0x880088ff ) //: SECONDARY\n        #define Y  U32( 0xFFFF00ff ) //: SECONDARY\n        #define y  U32( 0x888800ff ) //: SECONDARY\n    //: - ://      \n        #define L  U32( 0x88FF00ff ) //: TERTIARY\n        #define l  U32( 0x448800ff ) //: TERTIARY\n        #define O  U32( 0xFF8800ff ) //: TERTIARY\n        #define o  U32( 0x884400ff ) //: TERTIARY\n    //: - ://    \n        #define K  U32( 0x212121ff ) //: BLACK | GRAY\n        #define k  U32( 0x323232ff ) //: BLACK | GRAY\n    //: - :// \n\n        #if( 1 == NTX && 1 == NTY && 1 == NTZ )\n\n            U32  \n            VAT[ NTX * NTY * NTZ ]= U32[ 1 * 1 * 1 ](   \n\n                C /** <<<< JUST ONE TILE(VOXEL) **/\n\n            );\n\n        #endif\n        #if( 2 == NTX && 2 == NTY && 2 == NTZ )\n\n            U32  \n            VAT[ NTX * NTY * NTZ ]= U32[ 2 * 2 * 2 ](   \n\n                C,M,\n                Y,_,\n\n                c,m,\n                y,_ //:<---NO_COMMA_LAST\n\n            );\n\n        #endif\n        #if( 3 == NTX && 3 == NTY && 3 == NTZ )/**333**/\n\n            U32  \n            VAT[ NTX * NTY * NTZ ]= U32[ 3 * 3 * 3 ](  \n\n                /** Something about the bounding   **/\n                /** calculations is definitely off **/\n\n                _,_,R,  //: <<< PROBLEM HERE\n                _,_,_,   \n                _,_,G,  //: <<< LOOKS GOOD\n                         \n                _,_,_,   \n                _,_,_,   \n                _,_,_,   \n                         \n                _,_,_,   \n                _,_,_,   \n                _,_,_    \n \n            );\n\n        #endif\n        #if( 8 == NTX && 4 == NTY && 7 == NTZ ) \n\n            U32  \n            VAT[ NTX * NTY * NTZ ]= U32[ 8 * 4 * 7 ](   \n\n            /** TODO: Eventually use an integer      **/\n            /**       texture for this tilemap data. **/\n                \n            /** #STRATA_OF_2D_TILEMAPS#        * * * **/\n            /** #BACK_SLASH_COMMENT_FUCKERY#   * * * **/\n            \n            //: 1 2 3 4 5 6 7 8  \n                _,_,_,_,_,_,_,_, //: 1 ---+\n                _,_,_,_,_,_,_,_, //: 2    |__ Z == 0\n                _,_,_,_,_,_,_,_, //: 3    |\n                _,_,_,_,_,_,_,_, //: 4 ---+     \n            //: 1 2 3 4 5 6 7 8         \n                _,_,_,_,_,_,_,_, //: 1 ---+\n                _,_,_,_,_,_,_,_, //: 2    |__ Z == 1\n                _,_,_,_,_,_,_,_, //: 3    |\n                _,_,_,_,_,_,_,_, //: 4 ---+           \n            //: 1 2 3 4 5 6 7 8         \n                _,_,_,_,_,R,_,_, //: 1 ---+\n                _,_,_,_,Y,_,_,_, //: 2    |__ Z == 2\n                _,_,_,M,_,_,_,_, //: 3    |\n                _,_,C,_,_,_,_,_, //: 4 ---+     \n            //: 1 2 3 4 5 6 7 8      \n                _,_,_,_,_,_,_,_, //: 1 ---+\n                _,_,_,_,_,_,_,_, //: 2    |__ Z == 3\n                _,_,_,_,_,_,_,_, //: 3    |\n                _,_,_,_,_,_,_,_, //: 4 ---+     \n            //: 1 2 3 4 5 6 7 8 \n                _,_,_,_,_,_,_,_, //: 1 ---+\n                _,_,_,_,_,_,_,_, //: 2    |__ Z == 4\n                _,_,_,_,_,_,_,_, //: 3    |\n                _,_,_,_,_,_,_,_, //: 4 ---+     \n            //: 1 2 3 4 5 6 7 8 \n                _,_,_,_,_,_,_,_, //: 1 ---+\n                _,_,_,_,_,_,_,_, //: 2    |__ Z == 5\n                _,_,_,_,_,_,_,_, //: 3    |\n                _,_,_,_,_,_,_,_, //: 4 ---+     \n            //: 1 2 3 4 5 6 7 8 \n                _,_,_,_,_,_,_,_,\n                _,_,_,_,_,_,_,_,\n                _,_,_,_,_,_,_,_,\n                _,_,_,_,_,_,_,_ //:<<< NO_COMMA_ON_LAST\n\n            );  \n\n\n        #endif /** [ 8 x 4 x 7 ] **/\n                                             \n    //: - ://       \n        #undef  _               \n        #undef  X   \n        #undef  R   \n        #undef  r   \n        #undef  G   \n        #undef  g   \n        #undef  B   \n        #undef  b   \n    //: -undef      \n        #undef  C   \n        #undef  c   \n        #undef  M   \n        #undef  m   \n        #undef  Y   \n        #undef  y   \n    //: -undef      \n        #undef  L   \n        #undef  l   \n        #undef  O   \n        #undef  o   \n    //: -undef      \n        #undef  K   \n        #undef  k   \n    //: - :// \n\n    //:==============:RAYMARCHING_AND_VOXEL_CONSTANTS://\n    //:STRUCTS:======================================://\n\n        //:RWC_AND_RWN:------------------------------://\n\n            struct  RWC_AND_RWN{\n                V_3 rwC        ;\n                V_3         rwN;\n            };\n        \n        //:------------------------------:RWC_AND_RWN://\n        //:VOX_000:----------------------------------://\n\n            /** VOC: VOxel_Current(information) **/\n            struct VOC{   \n                U32 has    ;  //  voxel:exists?    : 1 :  \n                U32 val    ;  //  voxel:tile_value : 2 :  \n                              //                   :---:  \n                I32 til_d3d;  //  voxel:1d_index   : 3 :  \n                I32 t_x    ;  //  voxel:tile_x     : 4 :  \n                I32 t_y    ;  //  voxel:tile_y     : 5 :  \n                I32 t_z    ;  //  voxel:tile_z     : 6 :  \n                              //\n                I32 pix_d3d;  //  voxel:pixel_d    : 7 :\n                I32     p_x;  //  voxel:pixel_x    : 8 :\n                I32     p_y;  //  voxel:pixel_y    : 9 :\n                I32     p_z;  //  voxel:pixel_z    :10 :\n            };                                 \n\n            /** VOD: VOxel_Distance(information) **/\n            struct VOD{  \n                F32     dis_nex; //:Distance_To_Next\n                F32     dis_sur; //:Distance_To_Surface\n                                 //:Within_Current_Voxel\n            };\n\n            struct VOE{\n                F32  msg_err;\n            };\n\n            struct VOX_000{ /** var: vox_000 **/\n                        \n                VOC     voc; //:Voxel_Current_Info\n                VOD     vod; //:Voxel_Distance_Info\n                VOE     voe; //:Voxel_Error____Info\n           \n            };\n\n        //:----------------------------------:VOX_000://\n        //:VOX_MAR:----------------------------------://\n        \n            struct VOX_MAR{ //:SEE[ #VOX_MAR_ABOUT# ]\n\n                uint exit;\n\n            };\n\n        //:----------------------------------:VOX_MAR://\n\n    //:======================================:STRUCTS://\n\n/** D: Data Section **/\n//:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD://\n//:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII://\n/** I: Inifnite Degree Functions. Always At Top.     **/\n\n    //:NO_HALT_USE_ERROR_PIXEL:======================://\n    //:PIX_ERR:======================================://\n\n        #define ERR_001  1  /** msg_err #1 (0x101010)**/\n                            /** msg_err #1 (0x010101)**/\n\n        #define ERR_002  2  /** msg_err #2 (0x202020)**/\n                            /** msg_err #2 (0x020202)**/\n\n        #define ERR_003  3  /** msg_err #3 (0x303030)**/\n                            /** msg_err #3 (0x030303)**/\n\n        V_4     PIX_ERR( \n            int msg_err /** EX: MSG_ERR_001 **/\n        ,   V_4 pix_err /** Previous Pixel Error **/\n        ,   int   o_k\n        )\n        {\n            /** Muddy Pastel Yellow For When You     **/\n            /** forget to set the pix_err_out value. **/\n            V_4 pix_err_out=V_4(0.5,0.5,0.2,1);\n\n            float flux=( mod(iTime,1.0) );\n\n            //:COLOR_PICKER_DEBUG_HEX:---------------://\n        \n            /** Make it easy to find source of error **/\n            /** in code by using color picker on     **/\n            /** shader output and then doing a       **/\n            /** CTRL+F with that hex code to find    **/\n            /** the offending source code.           **/\n\n                F32 _ =F32( 0.0    );\n                F32 MAX =F32( 255.0  ); // MaxIntensity\n                F32  A  =F32( 1.0    ); // Alpha_Max\n\n                //:ERROR_CODE_STROBE_COLORS:---------://\n\n                F32 _01_ =( F32(0x01) / MAX );\n                F32 _10_ =( F32(0x10) / MAX );\n                // \n                F32 _02_ =( F32(0x02) / MAX );\n                F32 _20_ =( F32(0x20) / MAX );\n                // \n                F32 _03_ =( F32(0x03) / MAX );\n                F32 _30_ =( F32(0x30) / MAX );\n                // \n                F32 _04_ =( F32(0x04) / MAX );\n                F32 _40_ =( F32(0x40) / MAX );\n                // \n                F32 _05_ =( F32(0x05) / MAX );\n                F32 _50_ =( F32(0x50) / MAX );\n                // \n                F32 _06_ =( F32(0x06) / MAX );\n                F32 _60_ =( F32(0x60) / MAX );\n                // \n                F32 _07_ =( F32(0x07) / MAX );\n                F32 _70_ =( F32(0x70) / MAX );\n                // \n                F32 _08_ =( F32(0x08) / MAX );\n                F32 _80_ =( F32(0x80) / MAX );\n                // \n                F32 _09_ =( F32(0x09) / MAX );\n                F32 _90_ =( F32(0x90) / MAX );\n\n                V_4 _0x010101_ = V_4(_01_,_01_,_01_, A);\n                V_4 _0x101010_ = V_4(_10_,_10_,_10_, A); \n\n                V_4 _0x020202_ = V_4(_02_,_02_,_02_, A);\n                V_4 _0x202020_ = V_4(_20_,_20_,_20_, A); \n\n                V_4 _0x030303_ = V_4(_03_,_03_,_03_, A);\n                V_4 _0x303030_ = V_4(_30_,_30_,_30_, A); \n\n                V_4 _0x040404_ = V_4(_04_,_04_,_04_, A);\n                V_4 _0x404040_ = V_4(_40_,_40_,_40_, A); \n\n                V_4 _0x050505_ = V_4(_05_,_05_,_05_, A);\n                V_4 _0x505050_ = V_4(_50_,_50_,_50_, A); \n\n                V_4 _0x060606_ = V_4(_06_,_06_,_06_, A);\n                V_4 _0x606060_ = V_4(_60_,_60_,_60_, A); \n\n                V_4 _0x070707_ = V_4(_07_,_07_,_07_, A);\n                V_4 _0x707070_ = V_4(_70_,_70_,_70_, A); \n\n                V_4 _0x080808_ = V_4(_08_,_08_,_08_, A);\n                V_4 _0x808080_ = V_4(_80_,_80_,_80_, A); \n\n                V_4 _0x090909_ = V_4(_09_,_09_,_09_, A);\n                V_4 _0x909090_ = V_4(_90_,_90_,_90_, A); \n\n                //:---------:ERROR_CODE_STROBE_COLORS://\n                //:ERROR_ZERO_COLORS:----------------://\n                #define F float\n                #define V vec4\n                /** If you forget to set error code, **/\n                /** you will see flashing red and    **/\n                /** blue. ( _0xFF0666_ & _0x6660FF_ )**/\n                  \n                F   _FF_=( F32(0xFF) / MAX );\n                //  _06_=( F32(0x06) / MAX );\n                //  _60_=( F32(0x60) / MAX );\n                F   _66_=( F32(0x66) / MAX );\n                V   _0xFF0666_ =V_4(_FF_,_06_,_66_,A);\n                V   _0x6660FF_ =V_4(_66_,_60_,_FF_,A);\n\n                #undef F\n                #undef V\n                //:----------------:ERROR_ZERO_COLORS://\n                //:BAD_OK_ERROR_COLOR:---------------://\n                #define F float\n                #define V vec4\n                /** You will see this if you init    **/\n                /** o_k to a value other than 1 in   **/\n                /** your source code.                **/\n                /** Strobes between orange and lime. **/\n                /** ( _0xFF7700_ & _0x77FF00_ )      **/\n                  \n                //  _FF_=( F32(0xFF) / MAX );\n                F   _77_=( F32(0x77) / MAX );\n                F   _00_=( F32(0x00) / MAX );\n                V   _0xFF7700_ =V_4(_FF_,_77_,_00_,A);\n                V   _0x77FF00_ =V_4(_77_,_FF_,_00_,A);\n\n                #undef F\n                #undef V\n                //:---------------:BAD_OK_ERROR_COLOR://\n\n            //:---------------:COLOR_PICKER_DEBUG_HEX://\n\n            if( o_k <= 0 ){\n                pix_err_out = pix_err;\n            }else\n            if( 1 == o_k ){\n\n                /** table of error \"messages\" #0 **/\n                V_4 tab_err_000[10]=V_4[10](        \n                                                \n                    // 0: Invalid Error Code    \n                    _0xFF0666_  // RED_FLASH \n                          \n                    // Odd Frame Error Colors:\n                ,   _0x010101_  //  ERR_001 : ODD_FRAME\n                ,   _0x020202_  //  ERR_002 : ODD_FRAME\n                ,   _0x030303_  //  ERR_003 : ODD_FRAME\n                ,   _0x040404_  //  ERR_004 : ODD_FRAME\n                ,   _0x050505_  //  ERR_005 : ODD_FRAME\n                ,   _0x060606_  //  ERR_006 : ODD_FRAME\n                ,   _0x070707_  //  ERR_007 : ODD_FRAME\n                ,   _0x080808_  //  ERR_008 : ODD_FRAME\n                ,   _0x090909_  //  ERR_009 : ODD_FRAME\n                );;        \n                /** table of error \"messages\" #1 **/\n                V_4 tab_err_001[10]=V_4[10](        \n                                                \n                    // 0: Invalid Error Code    \n                    _0x6660FF_ // BLUE_FLASH    \n                          \n                    // Even Frame Error Colors:\n                ,   _0x101010_  //  ERR_001 : EVE_FRAME\n                ,   _0x202020_  //  ERR_002 : EVE_FRAME\n                ,   _0x303030_  //  ERR_003 : EVE_FRAME\n                ,   _0x404040_  //  ERR_004 : EVE_FRAME\n                ,   _0x505050_  //  ERR_005 : EVE_FRAME\n                ,   _0x606060_  //  ERR_006 : EVE_FRAME\n                ,   _0x707070_  //  ERR_007 : EVE_FRAME\n                ,   _0x808080_  //  ERR_008 : EVE_FRAME\n                ,   _0x909090_  //  ERR_009 : EVE_FRAME\n                );;                      \n\n                if( mod(iTime*16.0,2.0) < 1.0 ){\n                    pix_err_out =( tab_err_000\n                                 [ msg_err ] );;\n                }else{\n                    pix_err_out =( tab_err_001\n                                 [ msg_err ] );;\n                };;\n\n            }else{\n                /** Orange strobe for an o_k value   **/\n                /** that is NOT expected. (o_k >= 2) **/\n\n                if( mod(iTime*2.0,2.0) < 1.0 ){\n                    pix_err_out = _0xFF7700_; // ORANGE\n                }else{\n                    pix_err_out = _0x77FF00_; // LIME\n                };;\n\n            };;\n                \n            return( pix_err_out );\n        }\n\n    //:======================================:PIX_ERR://\n    //:======================:NO_HALT_USE_ERROR_PIXEL://\n    //:MAX_OF_3:=====================================://\n\n        F32\n        max_003( F32 a , F32 b , F32 c )\n        {\n            return( max( max(a,b) , c ) );\n        }\n\n    //:=====================================:MAX_OF_3://\n\n/** I: Inifnite Degree Functions. Always At Top.     **/\n//:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII://\n//:22222222222222222222222222222222222222222222222222://\n\n    //:INTERPOLATION_3D:=============================://\n    //:sfd_i3d:======================================://\n\n        V_3 sdf_i3d(\n        /**/V_3 _1_\n        ,   V_3 _2_\n        ,   F32 f_p\n        ){\n            return( _1_ + ( ( _2_ - _1_ )*f_p ) );\n        }\n\n    //:=============================:INTERPOLATION_3D://\n    //:======================================:sfd_i3d://\n    //:FIRST_VOXEL_QUERY_NEEDED:=====================://\n    //:@WHATVOX@\n    // ############################# //\n    #define T_X ( vox_000.voc.t_x     )\n    #define T_Y ( vox_000.voc.t_y     )\n    #define T_Z ( vox_000.voc.t_z     )\n    // ############################# //\n    #define P_X ( vox_000.voc.p_x     )\n    #define P_Y ( vox_000.voc.p_y     )\n    #define P_Z ( vox_000.voc.p_z     )\n    #define P_I ( vox_000.voc.pix_d3d )\n    // ############################# //\n\n        /** rwN used to find distance to NEXT voxel. **/\n            VOX_000 \n        GET_vox_000_USE_xyz_rwN( \n                        V_3 xyz \n                    ,   V_3     rwN \n        )\n        {\n            VOX_000 vox_000;\n\n            /** f: floor(xyz) values: **/\n            F32 f_x = floor( xyz.x );\n            F32 f_y = floor( xyz.y );\n            F32 f_z = floor( xyz.z );\n\n            //:CURRENT_VOXEL_CELL:-------------------://\n\n            vox_000.voc.val = U32( 0 );\n            T_X = ( int(floor( xyz.x / float( NPX ))));\n            T_Y = ( int(floor( xyz.y / float( NPY ))));\n            T_Z = ( int(floor( xyz.z / float( NPZ ))));\n\n            //:-------------------:CURRENT_VOXEL_CELL://\n            //:GET_VOXEL_CELL_VALUE:-----------------://\n\n            /** Voxel Volume Is Hard Coded To have   **/\n            /** voxel__tile[0,0,0] stuck at world    **/\n            /** world_coord[0,0,0]                   **/\n            if( T_X >= 0 && T_X < NTX \n            &&  T_Y >= 0 && T_Y < NTY \n            &&  T_Z >= 0 && T_Z < NTZ \n            ){\n\n                //: Index2D -and- Index3D\n                int D2D = T_X + ( NTX    *    T_Y );\n                int D3D = D2D + ( NTX * NTY * T_Z );\n\n                vox_000.voc.til_d3d=(      D3D   );\n                vox_000.voc.val    =( VAT[ D3D ] );\n\n                /** NOTE: Voxel value 0 will NOT get **/\n                /**       special treatment. It could**/\n                /**       contain geometry if we     **/\n                /**       really wanted it to.       **/\n                vox_000.voc.has= U32(  1  );\n                \n            }else{\n                /** Using a \"has\" flag so we         **/\n                /** can keep more logic UNSIGNED.    **/\n                /** (No need for negative value to ) **/\n                /** (be used for invalid dex or val) **/\n                vox_000.voc.til_d3d= int(  0  );\n                vox_000.voc.val    = U32(  0  );\n                vox_000.voc.has    = U32(  0  );\n            };;\n            //:-----------------:GET_VOXEL_CELL_VALUE://\n            //:DIST_TO_NEXT_VOXEL:-------------------://    \n            /** ************************************ ***\n                                x_bound\n                                |||\n                                |||\n                                |||\n            ====+-----+---[i]----+====== y_bound ====\n                |     |   /      ||\n                |     |  /       ||\n                |     | /        ||\n                |     |/         ||\n                +- - -P----------+|\n                |     .          ||\n                |     .          ||\n                +-----+----------+|\n                                |||\n                                |||\n                                |||\n                                |||\n            *** ************************************ **/\n            #define P xyz /** Point  **/\n            #define N rwN /** Normal **/\n\n                //:SIGNS_OF_RAY_VECTOR:--------------://\n                /** We need to know if the ray is    **/\n                /** moving forwards to HIGHER tile   **/\n                /** values or BACKWARDS to LOWER     **/\n                /** tile values.                     **/\n\n                /**  SEE[ #CONSISTENT_VOXEL_COORDS# **/\n                F32  b_x  /** x_bound       **/     ;  \n                F32  b_y  /** y_bound       **/     ;  \n                F32  b_z  /** z_bound       **/     ;  \n                          /**               **/     ;\n                F32  x_0  /** x_bound : MIN **/     ;  \n                F32  y_0  /** y_bound : MIN **/     ;  \n                F32  z_0  /** z_bound : MIN **/     ;  \n                          /**               **/     ;\n                F32  x_1  /** x_bound : MAX **/     ;  \n                F32  y_1  /** y_bound : MAX **/     ;  \n                F32  z_1  /** z_bound : MAX **/     ;  \n                                                    ;\n                x_1 =F32( ( T_X +  1 ) * NPX )      ;\n                y_1 =F32( ( T_Y +  1 ) * NPY )      ;\n                z_1 =F32( ( T_Z +  1 ) * NPZ )      ;\n                                                    ;\n                x_0 =F32( ( T_X -  0 ) * NPX )- 0.0001 ; //:<---WTF ?\n                y_0 =F32( ( T_Y -  0 ) * NPY )- 0.0001 ; //:<---WTF ?\n                z_0 =F32( ( T_Z -  0 ) * NPZ )- 0.0001 ; //:<---WTF ?\n                                                    ;\n                b_x = N.x >= 0.0 ? x_1 : x_0        ;\n                b_y = N.y >= 0.0 ? y_1 : y_0        ;\n                b_z = N.z >= 0.0 ? z_1 : z_0        ;\n\n                //:--------------:SIGNS_OF_RAY_VECTOR://\n                /** ******************************** ***\n                SEE[ #NEXT_VOXEL_BOUNDING_VOLUME# ]     \n                The intersection point to next voxel    \n                (By using plane intersections) should   \n                not be further than ONE PIXEL away      \n                from the current voxel we are inside.   \n            \n                +----------------+----------------+\n                | +- - -  - - -+ | +- - -  - - -+ |\n                | |            | | |            | |\n                |                |                |\n                | |            | | |            | |\n                |                |                |\n                | |            | | |            | |\n                | +- - -  - - -+ | +- - -  - - -+ |\n                +----------------+----------------+\n                | +- - -  - - -+ | +- - -  - - -+ |\n                | |            | | |            | |\n                |                |                |\n                | |     CV     | | |            | |\n                |   (CurVoxel)   |                |\n                | |            | | |            | |\n                | +- - -  - - -+ | +- - -  - - -+ |\n                +----------------+----------------+\n\n                *** ******************************** **/\n                /** ******************************** ***\n                ___ == DONT CARE ABOUT\n                P   + (N   * S   )==[ b_x, ___ , ___ ]\n                P.x + (N.x * S.x )==  b_x\n                      (N.x * S.x )==  b_x - P.x\n                             S.x  == (b_x - P.x) / N.x\n                *** ******************************** **/\n                //:FIRST_PIXEL_OF_NEXT_VOXEL:--------://\n                #define N_X ( 0.0 != N.x )\n                #define N_Y ( 0.0 != N.y )\n                #define N_Z ( 0.0 != N.z )\n\n                //:Scalar for point normal form.\n             //:F32 MAX_F32=intBitsToFloat(0x7f7fFFFF);\n             //:F32 MAX_F32=F32( 2147483647 );\n                F32 MAX_F32=F32( 1000 * 1000 );\n                V_3 S = V_3(MAX_F32,MAX_F32,MAX_F32);\n                //:V_3 S = V_3( 0,0,0 );\n\n                /**  [f_x,f_y,f_z] or [ P.x,P.y,P.z ]**/\n                if( N_X ){ S.x = ( b_x - P.x ) / N.x; }; //:<<<<<<<<<<< THIS EQUATION MINUS BY floored or by P ?\n                if( N_Y ){ S.y = ( b_y - P.y ) / N.y; };\n                if( N_Z ){ S.z = ( b_z - P.z ) / N.z; };\n    \n                /** #TRAP_VALUE_MUST_BE_NEG_666# **/\n                #define _666_ ( 0.0 - 666.0  )\n                F32 shortest_scalar_distance=( _666_ );\n                V_3 first_pixel_of_next_voxel;\n                #undef  _666_\n\n                if( N_X && S.x <= S.y && S.x <= S.z ){\n                    shortest_scalar_distance=(  S.x );\n                }else\n                if( N_Y && S.y <= S.x && S.y <= S.z ){\n                    shortest_scalar_distance=(  S.y );\n                }else\n                if( N_Z && S.z <= S.x && S.z <= S.y ){\n                    shortest_scalar_distance=(  S.z );\n                };;\n\n                /** Not using this anywhere, BUT KEEP**/\n                /** for now. Now is not the time     **/\n                /** to optimize.                     **/\n                first_pixel_of_next_voxel=(\n                //: P + ( N * [ S.x | S.y | S.z ] )\n                    P + ( N * shortest_scalar_distance )\n                );;\n\n                vox_000.vod.dis_nex=( \n                        shortest_scalar_distance );;\n\n                //:vox_000.vod.dis_nex=( 8.0 );\n\n                #undef  N_X  \n                #undef  N_Y  \n                #undef  N_Z  \n                //:--------:FIRST_PIXEL_OF_NEXT_VOXEL://\n\n            \n            #undef  P /** Point  **/\n            #undef  N /** Normal **/\n            //:-------------------:DIST_TO_NEXT_VOXEL://\n            //:GET_VOXEL_PIXEL:----------------------://\n            if( vox_000.voc.has >= U32(1) ){ //:-----://\n\n                /** If you are inside a voxel, than  **/\n                /** you by definition MUST be at a   **/\n                /** certain pixel within that voxel. **/\n\n                P_X = I32( f_x ) - (T_X * NPX);\n                P_Y = I32( f_y ) - (T_Y * NPY);\n                P_Z = I32( f_z ) - (T_Z * NPZ);\n\n\n                /** ******************************** ***\n\n                This is why we should FLOOR xyz\n                values when figuring out what \n                Tile(voxel) or Pixel(VoxelSubCell)\n                we are inside of.\n\n                |<- 0 ->|<- 1 ->| <-- DISCREET_MODEL\n                +---+---+---+---+\n                |   .   |   .   |\n                + - + - + - + - +\n                |   .   |   .   |\n                +---+---+---+---+\n                ^       ^\n                |       |\n                0       1 <---------- FRACTIONAL_MODEL\n\n                *** ******************************** **/\n                \n                //: Index2D -and- Index3D\n                int D2D = P_X + ( NPX    *    P_Y );\n                int D3D = D2D + ( NPX * NPY * P_Z );\n\n                P_I = ( D3D /** inDEX_3D **/ );\n\n            };; //:------------------:GET_VOXEL_PIXEL://\n          \n            return( vox_000 );\n\n        } // <<<<<<<<<<<<<{ GET_vox_000_USE_xyz_rwN } //\n\n    // ---------------------------------------------- //\n    #undef  T_X   // ( vox_000.voc.t_x ) // --------- //\n    #undef  T_Y   // ( vox_000.voc.t_y ) // --------- //\n    #undef  T_Z   // ( vox_000.voc.t_z ) // --------- //\n    // ---------------------------------------------- //\n    #undef  P_X   // ( vox_000.voc.p_x     ) // ----- //\n    #undef  P_Y   // ( vox_000.voc.p_y     ) // ----- //\n    #undef  P_Z   // ( vox_000.voc.p_z     ) // ----- //\n    #undef  P_I   // ( vox_000.voc.pix_d3d ) // ----- //\n    //:=====================:FIRST_VOXEL_QUERY_NEEDED://\n    //:MARCH_INTO_VOXEL:=============================://\n    VOX_MAR sdf_MarchIntoVoxel(\n        VOX_000 vox_000\n    ,   V_3     xyz\n    ,   V_3     rwN\n    )\n    {\n\n        VOX_MAR vox_mar;\n        vox_mar.exit=U32( 1 );\n\n\n        return( vox_mar );\n    }\n    //:=============================:MARCH_INTO_VOXEL://\n    #define  F    float\n    #define  U    uint\n    #define _FF_  uint( 0xFF )\n\n        V_4 u32_CTO_c4d( \n            U32 u32\n        ){\n            V_4\n            c4d = V_4( /** c4d:Color_4_Dimensional **/\n                F( ( u32 >> U(24) ) & _FF_ ) / 255.0\n            ,   F( ( u32 >> U(16) ) & _FF_ ) / 255.0\n            ,   F( ( u32 >> U( 8) ) & _FF_ ) / 255.0\n            ,   F( ( u32 >> U( 0) ) & _FF_ ) / 255.0\n            );;\n            return( c4d );\n        }\n\n    #undef  F  \n    #undef  U  \n    #undef _FF_\n    //:INTEGER_MODULO:===============================://\n\n    #ifndef I32\n    #define I32 int\n    #endif\n\n    #ifndef F32\n    #define F32 float\n    #endif\n\n        /** PRIVATE: Called only by I32_MOD **/\n        I32 i32_mod_neg( I32 neg_a , I32 pos_d ){\n\n            /** ************************************ ***\n            Function Calculates:\n            \n            FIXED: (d-1)-[ mod(abs(a)+1 , d) ]\n\n            GOAL: Negatives keep exact same tiling\n                  pattern as the positives.\n\n            IN : -6 -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 +6\n            OUT:  2  3  0  1  2  3  0  1  2  3  0  1  2\n\n            0123 -> 0123 -> 0123 -> 0123 -> 0123 -> ect\n\n            \n\n            *** ************************************ **/\n\n            I32 pos_a = ( 0 - neg_a ) + 1;\n            \n            F32 A = F32( pos_a ); \n            F32 D = F32( pos_d );\n            \n            //: GLSL_MODULUS_WITH_INTEGERS_FORMULA\n            //: WARD:Wholepart,All,Remainder,Divisor \n            int W = int(  trunc( A / (          D  )) );\n            int R = int(         A - ( F32(W) * D  )  );\n            \n            return( (pos_d-1) - R );\n        }\n\n        I32\n        I32_MOD(\n        /**/I32 a /** ALL     : CAN BE NEGATIVE **/\n        ,   I32 d /** DIVISOR : ALWAYS POSITIVE **/\n        ){\n\n            /** ************************************ ***\n\n            Allow for I32_MOD to be used for wrapping\n            even when the input to wrap[ a ] goes\n            negative. d should always be positive.\n\n            EX: mod( x , 2 ) , where x == -1\n            | -1 | 0 [ 1 ] 2 |\n            |  1 | 0 [ 1 ] 0 | 1 | 0 |\n            d + 1 == 2 + (-1) == 1\n            *** ************************************ **/\n\n            int R;\n\n            if( a < 0 ){\n\n                //:This is CLOSE but then new problem\n                //:of lots of green checkers is showing\n                //:up. No clue...\n                R = i32_mod_neg( a , d );\n\n            }else{\n\n                F32 A = F32( a ); \n                F32 D = F32( d );\n                            //:<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<FIX_THE_OVERFLOW_BELOW\n                //: GLSL_MODULUS_WITH_INTEGERS_FORMULA\n                //: WARD:Wholepart,All,Remainder,Divisor \n                int W = int(  trunc( A / (          D  )) );\n                    R = int(         A - ( F32(W) * D  )  );\n\n            };;\n\n            return( R );\n        }\n    //:===============================:INTEGER_MODULO://\n    //:MAX_OF_3_NAMED_BY_USE_CASE:===================://\n    #define F float\n    #define M max\n\n        F32 \n        GET_npm_USE_npx_npy_npz( \n            I32     npx         /** I32 so we don't  **/\n        ,   I32         npy     /** need to CAST when**/\n        ,   I32             npz /** calling this.    **/\n        ){                      /** ACTUALLY U32 vals**/\n\n            //: npm: Number_of_Pixels_Max(x,y,z)\n            F32 npm = M( M( F(NPX),F(NPY) ),F(NPZ) );\n            return( npm );\n        }\n\n    #undef  F\n    #undef  M\n    //:===================:MAX_OF_3_NAMED_BY_USE_CASE://\n    //:VOXEL_TO_DEBUG_COLOR:=========================://\n    /** @VOXBUGCOLOR@ **/\n    #define P_X ((( vox_000.voc.p_x ))) \n    #define P_Y ((( vox_000.voc.p_y ))) \n    #define P_Z ((( vox_000.voc.p_z ))) \n    #define ALP ( 1.0 )\n\n        V_4 vox_000_CTO_c4d(\n\n            VOX_000 vox_000\n        )\n        {\n            V_4 c4d; /** [output/return/result] **/\n\n            /** base color **/\n            V_4 b_c=( u32_CTO_c4d( vox_000.voc.val ));\n\n            #define F float\n            F d_x = min( F(P_X) , F( NPX - P_X - 1 ));\n            F d_y = min( F(P_Y) , F( NPY - P_Y - 1 ));\n            F d_z = min( F(P_Z) , F( NPZ - P_Z - 1 ));\n            #undef  F\n\n            F32 m2d ; /** m2d: Minimum 2D **/\n            \n            if( d_x <= d_y && d_x <= d_z ){\n            /** d_x == X_PLANE == [ y , z ] **/\n\n                m2d = min( d_y , d_z );\n                //: c4d =V_4( 1,0,0,  ALP );\n            }else\n            if( d_y <= d_x && d_y <= d_z ){\n            /** d_y == Y_PLANE == [ x , z ] **/\n\n                m2d = min( d_x , d_z );\n                //: c4d =V_4( 0,1,0,  ALP );\n\n            }else\n            if( d_z <= d_x && d_z <= d_y ){\n            /** d_z == Z_PLANE == [ x , y ] **/\n\n                m2d = min( d_x , d_y );\n                //: c4d =V_4( 0,0,1,  ALP );\n\n            }else{\n                /** This should never execute **/\n            };;\n\n            #define F float\n            F32 n_p = max_003( F(NPX),F(NPY),F(NPZ) );\n            F32 per =( m2d*2.0 ) / n_p ;\n            #undef  F\n\n            if( per > 0.0 ){\n\n                c4d =V_4(\n                    b_c.x * per\n                ,   b_c.y * per\n                ,   b_c.z * per\n                ,   b_c.w * 1.0\n                );;\n            }else{\n            #define X d_x\n            #define Y d_y\n            #define Z d_z\n\n                /** #VOXEL_EDGE_COLOR#          **/\n                /** #NO_ELSE_FOR_EDGE_COLORING# **/\n\n                F32 R=( 0.0 );\n                F32 G=( 0.0 );\n                F32 B=( 0.0 );\n                \n                if( X <= Y && X <= Z ){  /** X_PLANE **/\n\n                    R =( 1.0 );\n\n                };; /** NO ELSE! **/\n                if( Y <= X && Y <= Z ){  /** Y_PLANE **/\n\n                    G =( 1.0 );\n\n                };; /** NO ELSE! **/\n                if( Z <= X && Z <= Y ){  /** Z_PLANE **/\n\n                    B =( 1.0 );\n\n                };; /** NO ELSE! **/\n\n                c4d =V_4( R,G,B, ALP );\n\n            #undef  X  \n            #undef  Y  \n            #undef  Z  \n            };;\n\n            return( c4d );\n        }\n\n    #undef  P_X   \n    #undef  P_Y   \n    #undef  P_Z   \n    #undef  ALP   \n    //:=========================:VOXEL_TO_DEBUG_COLOR://\n\n//:22222222222222222222222222222222222222222222222222://\n//:11111111111111111111111111111111111111111111111111://\n\n    //:FRAGCOORD_TO_FRAGPERCENT:=====================://\n    //:f_c_CTO_f_p:==================================://\n\n        V_2 f_c_CTO_f_p( V_2 f_c ){\n        V_2         f_p;\n            f_p = f_c / ( iResolution.xy - 1.0 );\n            return(  f_p );\n        }\n\n    //:==================================:f_c_CTO_f_p://\n    //:=====================:FRAGCOORD_TO_FRAGPERCENT://\n    //:FRAGPER_TO_CAMERA_RAY:========================://\n    //:f_p_CTO_rwC_AND_rwN_CAMTYPE_OGP_TOP:==========://\n\n                RWC_AND_RWN \n        f_p_CTO_rwC_AND_rwN_CAMTYPE_OGP_TOP( \n            V_2 f_p /** 2 dimensional percentage **/ \n        )\n        {\n            F32 bug = ( F32(NPZ) * 4.0 ); //:DEBUG_ONLY\n            F32 spd     =( 0.5 /**SPEED FACTOR **/ );\n            F32 pos_cos =( cos(iTime*spd)+1.0 ) / 2.0;\n            F32 neg_cos =( cos(iTime*spd)-1.0 ) / 2.0;\n            bug=bug*pos_cos;\n            //:bug = ( (-16.1) * bug ); \n            //:bug = ( -1036.8 );\n            //:bug=( -32.2   ); \n\n            /** ************************************ ***\n            TODO: Fix bug...\n                bug=( -   0.2 ); <<<<< OK\n                bug=( -  16.2 ); <<<<< OK\n                bug=( -  32.2 ); <<<<< ERR\n                bug=( -  48.2 ); <<<<< OK\n                bug=( -  64.2 ); <<<<< ERR\n                bug=( -  80.2 ); <<<<< OK\n                bug=( -  96.2 ); <<<<< ERR\n                bug=( - 112.2 ); <<<<< OK\n                bug=( - 128.2 ); <<<<< ERR\n                bug=( -1036.8 );\n\n            *** ************************************ **/\n         \n            V_3 rwC; //:ray_word__COORDINATE\n            V_3 rwN; //:ray_world_NORMAL____\n\n            //:#FIND_POINT_ON_SCREEN_PLANE#\n            F32 H = F32( 0 - 9 );; //:Cam Height Pos\n            F32 X = iResolution.x - 1.0;\n            F32 Y = iResolution.y - 1.0;\n            /** ************************************ ***\n                            A_B\n                        A----|------B\n                        |    |      |\n                        |   rwC     |\n                        |    |      |\n                        C----|------D\n                            C_D\n                                \n            *** ************************************ **/\n\n            F32  _ =F32( 0.0 /**ALWAYS_ZERO **/ );\n            F32 XOS=F32( 0 );\n            F32 YOS=F32( 0 );\n            F32 ZOS=F32( 0 );\n\n            V_3 _A_ = V_3( _+XOS,_+YOS,  bug+H+ZOS );  \n            V_3 _B_ = V_3( X+XOS,_+YOS,  bug+H+ZOS );  \n                                      \n            V_3 _C_ = V_3( _+XOS,Y+YOS,  bug+H+ZOS );  \n            V_3 _D_ = V_3( X+XOS,Y+YOS,  bug+H+ZOS );  \n                                      \n\n            V_3 A_B = sdf_i3d( _A_ , _B_ , f_p.x );\n            V_3 C_D = sdf_i3d( _C_ , _D_ , f_p.x );\n                rwC = sdf_i3d( A_B , C_D , f_p.y );\n\n                //:#POSITIVE_Z_DIVES_INTO_SCREEN#://\n                rwN = normalize( V_3( 0 , 0 , 1 ) );\n\n                    RWC_AND_RWN\n                    rwC_AND_rwN;\n                    rwC_AND_rwN.rwC = rwC;\n                    rwC_AND_rwN.rwN = rwN;\n            return( rwC_AND_rwN );\n        }\n\n    //:==========:f_p_CTO_rwC_AND_rwN_CAMTYPE_OGP_TOP://\n    //:f_p_CTO_rwC_AND_rwN_CAMTYPE_OGP_34D:==========://\n    #define _0_  (0.0)\n    #define  _   (0.0)\n\n                RWC_AND_RWN \n        f_p_CTO_rwC_AND_rwN_CAMTYPE_OGP_34D( \n            V_2 f_p /** 2 dimensional percentage **/ \n        )\n        {\n            RWC_AND_RWN  /** OUTPUT_OBJECT **/\n            rwC_AND_rwN; /** OUTPUT_OBJECT **/\n\n            V_3 rwC; //:ray_word__COORDINATE\n            V_3 rwN; //:ray_world_NORMAL____\n\n            //:#FIND_POINT_ON_SCREEN_PLANE#\n            /** ************************************ ***\n            Could possibly use these as slice planes.\n            But for now using these to navigate our\n            voxel map bounds.\n\n            [ A ]Is_Directly_Above[ E ]On_Z_Axis\n            [ B ]Is_Directly_Above[ F ]On_Z_Axis\n            [ C ]Is_Directly_Above[ G ]On_Z_Axis\n            [ D ]Is_Directly_Above[ H ]On_Z_Axis\n            \n                        (In World/Frag Coords)\n                            [0,0,0] \n                                \\\n                A_B              \\\n            A----|------B  A -->  +=======+  <-- B\n            |    |      |        /.       .\\\n            | rwC_001   |       / .       . \\\n            |    |      |      /  .       .  \\\n            C----|------D  C->+===============+<-D\n                C_D           [   ._....._.   ]\n                              [  /         \\  ]\n                              [ .           . ]\n                              [/             \\]\n                              +===============+<-H\n\n                              +===============+  \n                              [\\             /]\n                              [ .           . ]\n                              [  \\_......._/  ]\n                E_F           [   .       .   ]\n            E----|------F  G->+===============+<-H\n            |    |      |      \\  .       .  /\n            | rwC_002   |       \\ .       . /\n            |    |      |        \\.       ./\n            G----|------H  E -->  +=======+  <-- F\n                G_H          \n                            \n            *** ************************************ **/\n\n            //:Dimensions Of Voxel Volume:\n            //:As maximum indexes.\n            F32 M_X =( F32(TPX) - 1.0 );\n            F32 M_Y =( F32(TPY) - 1.0 );\n            F32 M_Z =( F32(TPZ) - 1.0 );\n\n            //:TOP LAYER OF PIXELS OF VOXEL VOLUME:\n            //:(INCLUSIVE MATH. We are inside the)\n            //:(first layer of pixels of the first)\n            //:(layer of voxels)\n            V_3 _A_ = V_3( _-_ , _-_ , _-_ );\n            V_3 _B_ = V_3( M_X , _-_ , _-_ );       \n            V_3 _C_ = V_3( _-_ , M_Y , _-_ );\n            V_3 _D_ = V_3( M_X , M_Y , _-_ );\n\n            //:BOTTOM LAYER OF PIXELS OF VOXEL VOLUME\n            //:(Incluseive Math. We are inside the )\n            //:(last layer of pixels of the last   )\n            //:(layer of voxels.                   )\n            V_3 _E_ = V_3( _-_ , _-_ , M_Z );\n            V_3 _F_ = V_3( M_X , _-_ , M_Z );       \n            V_3 _G_ = V_3( _-_ , M_Y , M_Z );\n            V_3 _H_ = V_3( M_X , M_Y , M_Z );\n\n            /** ************************************ ***\n            Take our plane and pretend it is\n            the top of a cube that we want to \n            get plane in an isometric position to.\n            Where the new plane tangents corner _D_\n            \n            \n                   A------_B_            vec_D_B\n                  /|       \\\\                  \\\n                 / |       |\\\\                  \\\n                /  |       | \\\\      vec_D_C <---D\n              _C_============_D_                 ^\n               |   |_ _ _ _|  ||                 |\n               |  /E       F\\ ||            vec_H_D\n               | /           \\||\n               |/             ||     Corner_Vector:\n               G-------------_H_  \n            *** *** * * * * * * **** * * * * * * *** **/\n\n            /** Edge Vectors **/\n\n            V_3 vec_C_D = normalize( _D_ - _C_ );\n            V_3 vec_D_C = normalize( _C_ - _D_ );\n            V_3 vec_D_B = normalize( _B_ - _D_ );\n            V_3 vec_H_D = normalize( _D_ - _H_ );\n            V_3 vec_D_H = normalize( _H_ - _D_ );\n\n            /** *** * * * * * * **** * * * * * * *** ***\n            Use Corner_Vector to calculate a 3/4        \n            perspective plane that tangents _D_.\n            *** ************************************ **/\n            /** ************************************ ***\n    \n            X axis vector is pretty easy because the\n            camera X axis does not move in the Z\n            direction.\n                    ^         /\n                    |       /    ^\n            A-------B     /      |    a_x Is Average\n            |       |   /        |   \n            |       | /     vec_D_B\n            C-------D-->    vec_C_D ----->\n                  /\n                /\n              /<-- goal is THIS line for X-axis.(a_x)\n            /\n            *** *** * * * * * * **** * * * * * * *** **/\n            #define _X_ vec_C_D\n            #define _Y_ vec_D_B\n            V_3 a_x =normalize(\n\n                /** 45 degree line on XY plane **/\n                ( _X_ + _Y_ ) / 2.0  \n\n            );;\n            #undef  _X_\n            #undef  _Y_\n            /** *** * * * * * * **** * * * * * * *** ***\n            \n            Y axis vector is a bit tricky because it\n            moves on all axis(es). XYZ.\n\n            +--B  If we average vec_D_C & vec_D_B\n            |\\ |  To get a 45 degree on the XY plane,\n            | \\|  we can then tilt that vector up\n            C--D  by 45 degrees by averaging it\n               |  with vec_H_D\n               |\n               H\n\n            *** ************************************ **/\n\n            //: a_y: Axis_Y\n            #define _X_ vec_D_C\n            #define _Y_ vec_D_B\n            #define _Z_ vec_H_D\n            V_3 a_y =normalize(\n\n                ( \n                    normalize( (_X_ + _Y_)/2.0 )\n                    +        (     _Z_         )\n                ) /2.0\n            );;\n            #undef  _X_\n            #undef  _Y_\n            #undef  _Z_\n\n            \n            /** Looking into the voxel volume from   **/\n            /** a 3/4 isometric direction.           **/\n            V_3 a_z = normalize( \n                ( vec_D_C + vec_D_B + vec_D_H ) / 3.0 \n            );;\n\n            /** ************************************ ***\n\n            We can now use point-normal form to\n            build our camera polygon. We will start\n            from point _D_ and walk HALFWAY the\n            WIDTH in both directions on our altered\n            x-axis vector( a_x ) and HALFWAY the\n            HEIGHT in both directions on our altered\n            y-axis vector( a_y ).\n\n            HEIGHT: The height of our camera plane.\n             WIDTH: The width  of our camera plane.\n\n                      P_X                   +---+\n                +------+------+             |   |\n                |      |      |         +---+---+\n            N_Y +---- _D_ ----+ P_Y     |_D_|\n                |      |      |     +---+---+\n                +------+------+     |   |#DIA_CAMCENTER#\n                      N_X           +---+\n\n                #CAMCENTER#:\n                In order for the camera to be 100%\n                centered, it may be necessary to \n                squash or stretch the camera by 1\n                pixel IF the camera is NOT an odd\n                number of pixels on that axis.\n                SEE_DIAGRAM[ #DIA_CAMCENTER# ]\n\n                    +0 +1 +2 +2.5       +0 +1 +2 +3   \n                    [D]   [+]           ||     [+]    \n                [ ][ ][ ][ ][ ]   [ ][ ][ ][ ][ ][ ]  \n                |<---- 5 ---->|   |<------ 6 ----->|  \n\n            *** ************************************ **/\n\n            #define ZOOMED_IN_CAMERA_2020_11_26 ( 1 )\n            float H_W ; //:H_W:Halfway_Width\n            float H_H ; //:H_H:Halfway_Height\n            if( ZOOMED_IN_CAMERA_2020_11_26 >= 1 ){\n\n                F32 npm = GET_npm_USE_npx_npy_npz(\n                                      NPX,NPY,NPZ);;\n\n                /** Display Size Of  A Single Voxel  **/\n                /** In Terms Of PIXELS/FRAGS         **/\n                F32 zoo_mul =( 128.0 );\n                F32 zoo_div =( zoo_mul / npm );\n    \n                /** Camera surface smaller than      **/\n                /** client viewport means zoomed in  **/\n                //: H_W = ( F32(TPX) / 2.0 );\n                //: H_H = ( F32(TPY) / 2.0 );\n\n                H_W = ( iResolution.x / 2.0 );\n                H_H = ( iResolution.y / 2.0 );\n\n                H_W = ( H_W / zoo_div );\n                H_H = ( H_H / zoo_div );\n\n            }else\n            if( ZOOMED_IN_CAMERA_2020_11_26 <= 0 ){\n\n                /** Camera surface exactly same size **/\n                /** as client viewport means no zoom.**/\n                H_W = ( iResolution.x / 2.0 );\n                H_H = ( iResolution.y / 2.0 );\n\n            };;\n            #undef  ZOOMED_IN_CAMERA_2020_11_26\n\n            /** To be pixel-perfect, floor and ceil  **/\n            /** need to be used. This is an OCD      **/\n            /** optimization that can probably       **/\n            /** be removed without noticable         **/\n            /** difference in the result.            **/\n            //- P_X = floor( _D_ + ( a_x * H_W ) );  -//\n            //- N_X =  ceil( _D_ - ( a_x * H_W ) );  -//\n            //- P_Y = floor( _D_ + ( a_y * H_H ) );  -//\n            //- N_Y =  ceil( _D_ - ( a_y * H_H ) );  -//\n            //+ We can't do it this way, because the +//\n            //+ plane is not aligned with our native +//\n            //+ XYZ axis.                            +//\n            //+ What I mean is we can't get the top  +//\n            //+ left corner by saying:               +//\n            //+ vec3( N_Y.x , P_X.y , _D_.z )        +//\n            /** ************************************ ***\n            RASTER_GRAPHICS_STYLE_TOP_LEFT_ORIGIN\n               \\\n                +----------- +X ------------>\n                |    \n                |     _I_              _J_\n                |       \\      P_X      /   \n                |        +------+------+        ^\n                |        |      |      |        |\n               +Y    N_Y +---- _D_ ----+ P_Y [ -y ]\n                |        |      |      |        |\n                |        +------+------+        |\n                |       /      N_X      \\       |\n                V     _K_               _L_     |\n                                                |\n                    <---------[ -x ]------------+\n\n            *** *** * * * * * * **** * * * * * * *** **/\n    \n            V_3 _I_ = _D_  - ( a_x * H_W )\n                           - ( a_y * H_H ) ;;\n\n            V_3 _J_ = _D_  + ( a_x * H_W )\n                           - ( a_y * H_H ) ;;\n\n            V_3 _K_ = _D_  - ( a_x * H_W )\n                           + ( a_y * H_H ) ;;\n\n            V_3 _L_ = _D_  + ( a_x * H_W )\n                           + ( a_y * H_H ) ;;\n                    \n            /** ************************************ **/\n            #define USE_ANIMATED_DOLLY_FOR_DEBUG  ( 1 )\n            if(     USE_ANIMATED_DOLLY_FOR_DEBUG >= 1 ){\n\n                F32 max_dolly =max(\n                            F32(TPX) \n                ,\n                        max(\n                            F32(TPY)\n                            ,\n                            F32(TPZ)\n                        )\n                );;\n\n                F32 pos_cos=( (cos(iTime)/2.0)+0.5 );\n                F32 neg_cos=( (cos(iTime)/2.0)-0.5 );\n\n                F32 dolly_amount =(\n                    pos_cos * max_dolly\n                );;\n                \n                _I_ += ( a_z * dolly_amount );\n                _J_ += ( a_z * dolly_amount );\n                _K_ += ( a_z * dolly_amount );\n                _L_ += ( a_z * dolly_amount );\n\n            };;\n            #undef  USE_ANIMATED_DOLLY_FOR_DEBUG\n            \n            V_3 I_J = sdf_i3d( _I_ , _J_ , f_p.x );\n            V_3 K_L = sdf_i3d( _K_ , _L_ , f_p.x );\n                rwC = sdf_i3d( I_J , K_L , f_p.y );\n\n                //:#POSITIVE_Z_DIVES_INTO_SCREEN#://\n                rwN = normalize( a_z );\n\n                    rwC_AND_rwN.rwC = rwC;\n                    rwC_AND_rwN.rwN = rwN;\n            return( rwC_AND_rwN );\n        }\n    #undef  _0_\n    #undef   _\n    //:==========:f_p_CTO_rwC_AND_rwN_CAMTYPE_OGP_34D://\n    //:f_p_CTO_rwC_AND_rwN_CAMTYPE_T3O_AAZ:==========://\n\n                RWC_AND_RWN \n        f_p_CTO_rwC_AND_rwN_CAMTYPE_T3O_AAZ( \n            V_2 f_p /** 2 dimensional percentage **/ \n        )\n        {\n            RWC_AND_RWN \n            rwC_and_rwN;\n\n            //:TODO: Logic.\n\n            return( rwC_and_rwN );\n\n        }\n\n    //:==========:f_p_CTO_rwC_AND_rwN_CAMTYPE_T3O_AAZ://\n    //:f_p_CTO_rwC_AND_rwN_CAMTYPE_T3I_AAZ:==========://\n    /** TAGS[ t3i_aaz : t3i:aaz ] **/\n    #define RWC rwC_and_rwN.rwC\n    #define RWN rwC_and_rwN.rwN\n\n                RWC_AND_RWN \n        f_p_CTO_rwC_AND_rwN_CAMTYPE_T3I_AAZ( \n            V_2 f_p /** 2 dimensional percentage **/ \n        )\n        {\n            RWC_AND_RWN \n            rwC_and_rwN;\n\n            F32 pos_cos=(cos(iTime)+1.0) / 2.0 ;\n\n            #define F float\n            #define M max\n            F32 N_T = M( M( F(NTX),F(NTY) ),F(NTZ) );\n            F32 N_P = M( M( F(NPX),F(NPY) ),F(NPZ) );\n            F32 rad =( N_T * N_P ) * 2.0 * pos_cos;\n            #undef  F\n            #undef  M\n\n            //:           123456789\n            F32 PI2 = ( 3.141592653 * 2.0 );\n            F32 hig = (  400.0 ); //:Cylinder Height.\n\n            F32 pop = f_p.x     ; //: Percent_On_Path\n            V_2 c_n             ; //: Circle_Normal\n            F32 ang = pop * PI2 ; //: Angle\n            RWC.x = c_n.x = (0.0+rad) +cos(ang)*rad;\n            RWC.y = c_n.y = (0.0+rad) +sin(ang)*rad;\n            RWC.z = hig * f_p.y ;\n        \n            RWN.x = 0.0 - c_n.x;\n            RWN.y = 0.0 - c_n.y;\n            RWN.z = 0.0; //:Perpendicular To Z axis.\n    \n            return( rwC_and_rwN );\n        }\n\n    #undef  RWC \n    #undef  RWN \n    //:==========:f_p_CTO_rwC_AND_rwN_CAMTYPE_T3I_AAZ://\n    //:f_p_CTO_rwC_AND_rwN:==========================://\n    #define ogp_top f_p_CTO_rwC_AND_rwN_CAMTYPE_OGP_TOP\n    #define ogp_34d f_p_CTO_rwC_AND_rwN_CAMTYPE_OGP_34D\n    #define t3o_aaz f_p_CTO_rwC_AND_rwN_CAMTYPE_T3O_AAZ\n    #define t3i_aaz f_p_CTO_rwC_AND_rwN_CAMTYPE_T3I_AAZ\n\n                RWC_AND_RWN \n        f_p_CTO_rwC_AND_rwN( \n            V_2 f_p /** 2 dimensional percentage **/ \n        )\n        {\n            RWC_AND_RWN \n            rwC_and_rwN;\n\n            switch( CAMTYPE ){\n\n                case          OGP_TOP : \n                rwC_and_rwN = ogp_top( f_p ); break;\n\n                case          OGP_34D : \n                rwC_and_rwN = ogp_34d( f_p ); break;\n\n                case          T3O_AAZ : \n                rwC_and_rwN = t3o_aaz( f_p ); break;\n\n                case          T3I_AAZ : \n                rwC_and_rwN = t3i_aaz( f_p ); break;\n            \n                default : /** OGP_TOP **/\n                rwC_and_rwN = ogp_top( f_p ); break;\n\n            };;  \n\n            return( rwC_and_rwN );\n        }\n\n    #undef  ogp_top  \n    #undef  ogp_34d  \n    #undef  t3o_aaz  \n    #undef  t3i_aaz  \n    //:==========================:f_p_CTO_rwC_AND_rwN://\n    //:========================:FRAGPER_TO_CAMERA_RAY://\n    //:RENDER_SCENE:=================================://\n    //:sdf_RenderScene:==============================://\n    #define T_X vox_000.voc.t_x\n    #define T_Y vox_000.voc.t_y\n    #define T_Z vox_000.voc.t_z\n    #define HAS vox_000.voc.has \n    #define VAL vox_000.voc.val\n    #define D_N vox_000.vod.dis_nex\n\n        V_4 sdf_RenderScene( RWC_AND_RWN rwC_AND_rwN )\n        {\n            I32 o_k = I32( 1 );\n            V_4 c4d = THE_COLOR_OF_EMPTY_SPACE ;\n\n            V_3 rwN = rwC_AND_rwN.rwN; \n            V_3 rwC = rwC_AND_rwN.rwC;\n\n            V_3 xyz = rwC;\n            F32 xyz_TDF_rwC=(0.0);\n            /** xyz_total_distance_from_rwC **/\n         \n            VOX_000\n            vox_000; \n\n            VOX_MAR vox_mar;\n\n            //:dis_nex: Distance To NEXT voxel.\n            //:dis_sur: Distance To Surface Geometry inside\n            //:     the current voxel. In world coords.\n            vox_000.vod.dis_nex =( 0.0 );  \n        //: vox_000.vod.dis_sur =( 0.0 );  \n\n            //:Voxels will be thought of as 3D tiles:\n            vox_000.voc.has     = uint( 0 ); // :1: //\n            vox_000.voc.val     = uint( 0 ); // :2: //\n            vox_000.voc.til_d3d =  int( 0 ); // :3: //\n            vox_000.voc.t_x     =  int( 0 ); // :4: //\n            vox_000.voc.t_y     =  int( 0 ); // :5: //\n            vox_000.voc.t_z     =  int( 0 ); // :6: //\n\n            //:RAY_MARCH_LOOP:-----------------------://\n            /** #ABOUT_RAY_MARCH_LOOP# **/\n\n                //:(RayMarch)March to VOXEL:\n                for( int i = 0; i < MAX_STE ; i++ ){\n\n                    //:March by distance to next voxel:\n                    \n                    //:Point_Normal_Form_To_Get:xyz\n                    //:#DISTANCE_IS_NOT_CUMULATIVE#\n                    rwN=normalize(rwN); //:TEMP_DEBUG\n                    xyz =  xyz + ( rwN * (D_N+0.0) );; \n                //: xyz =  xyz + ( rwN * -8.0 );\n\n                    /** B4 : GET_vox_000_USE_xyz_rwN **/\n                    xyz_TDF_rwC += D_N;\n                    if( xyz_TDF_rwC > MAX_DIS ){break;};\n                \n                    //:@WHATVOX@://\n                        vox_000 = \n                    GET_vox_000_USE_xyz_rwN( \n                                    xyz,rwN );;\n\n                    //:if( D_N <= 0.0 we have trouble )\n                    F32 MF3=intBitsToFloat(0x7f7fFFFF);\n                    if( 0.0 - 666.0 == D_N ){\n\n                        /** Exit On Error            **/\n                        /** #DIST_NEXT_NEVER_ZERO#   **/\n                        c4d=PIX_ERR(ERR_003,c4d,o_k--);\n                        break;\n\n                    }else\n                    if( vox_000.vod.dis_nex <= 0.0 ){\n                        //:PULSING:ORANGE:VIA:POS_COS:\n                        F32 p_c=((cos(iTime)+1.0)/2.0);\n                        c4d=V_4(V_3(1,0.5,0)*p_c,1.0);\n                        break;\n                    }else\n                    if( D_N == MF3 /** MaxFloat32 **/ ){\n                        F32 p_c=((cos(iTime)+1.0)/2.0);\n                        c4d=V_4(V_3(1,0.5,1)*p_c,1.0);\n                        break;\n                    }else\n                    if( isinf( D_N ) ){\n                        c4d=u32_CTO_c4d(U32( \n                                    0xE0E0E0FF ));\n                    };;\n\n                    //:If voxel is not empty, ray march\n                    //:inside of the voxel.\n                    #define _0_ U32( 0 ) //:#########://\n\n                    if( HAS > _0_ && _0_ == VAL ){\n\n                        //:EMPTY_TILE_INSIDE_MAP_BOUNDS:\n                        c4d=u32_CTO_c4d(U32( \n                                    0x003300FF ));\n\n                    }else\n                    if( _0_ == HAS ){\n\n                        //:OUT_OF_MAP_BOUNDS:\n                    //  c4d=u32_CTO_c4d(U32( \n                    //              0x330011FF ));\n    \n                        xyz_TDF_rwC=(length(xyz - rwC));\n                        F32 per=(xyz_TDF_rwC / MAX_DIS);\n                        F32 inv=( 1.0 - per );\n\n                        c4d=V_4( V_3(1)*(inv) , 1.0 );\n\n                    }else\n                    if( HAS > _0_ && VAL > _0_  ){\n    \n                        vox_mar =(\n                        sdf_MarchIntoVoxel(\n                            vox_000,xyz,rwN\n                        ));;\n                        \n                        /*[FIX]: ALWAYS RETURNS EXIT */\n                        if( vox_mar.exit >= U32(1) ){\n                        \n                            //: c4d=( u32_CTO_c4d( \n                            //: vox_000.voc.val ) );;\n\n                            c4d =( vox_000_CTO_c4d(\n                                   vox_000         ));;\n                        \n                            break;\n                        };;\n\n                    }else{\n\n                        //:SHOULD_NEVER_EXECUTE:\n                        c4d=V_4(1,0,0,1);\n\n                    };;\n\n                    #undef  _0_  //:#################://\n\n                    /** Don't move the ray anywhere  **/\n                    /** We are going to slice into   **/\n                    /** whatever voxels the camera   **/\n                    /** plane passes through.        **/\n                    if( CFG_SLICE_RENDER >= 1 ){ \n                        break; \n                    };;\n\n                };;\n\n            //:-----------------------:RAY_MARCH_LOOP://\n\n\n            if( CFG_SLICE_RENDER >= 1 ){\n\n                //:Layer value, 1 or 0\n                int lay = I32_MOD( T_Z, 2 );\n                \n                //:#MODULO_CHECKER_PATTERN#://\n                int chk =(  \n                    I32_MOD( //:<<<<<<<<<<<<<<:SET_003\n                        I32_MOD( T_Y, 2 )   //:SET_YYY\n                    +   I32_MOD( T_X, 2 )   //:SET_XXX\n                    ,                 2\n                    )\n                );;\n            \n                if(   0 != 0\n                || ( lay < 0 )\n                || ( lay > 1 )\n                || ( chk < 0 || chk > 1 )\n                || ( HAS > uint(1)      )\n                ){\n                    //: _0x010101_ & _0x101010_\n                    c4d=PIX_ERR(ERR_001,c4d,o_k--);\n                };;\n\n               \n                F32 M =( 255.0); //:Max RGB value.\n                F32 X =( 1.0  ); //:FOR_DEBUGGING_COLORS\n             //:F32 ...........;    Replace with \"_\" \n             //:F32 ...........;    when done debugging.\n                F32 a =( 1.0  ); //:ALPHA\n                F32 _ =( 0.0  );\n                F32 g =( F32(0x33)/M ); //:DARK-GREY\n                F32 G =( F32(0x38)/M );\n                F32 w =( F32(0xE5)/M ); //:WHITE-GREY\n                F32 W =( F32(0xF2)/M );\n\n                V_4 _0x333333_ =V_4(g,g,g,a);\n                V_4 _0x383838_ =V_4(G,G,G,a);\n                V_4 _0xE5E5E5_ =V_4(w,w,w,a);\n                V_4 _0xF2F2F2_ =V_4(W,W,W,a);\n                V_4 _0x003300_ =V_4(_,g,_,a);\n                V_4 _0x003800_ =V_4(_,G,_,a);\n                V_4 _0x00E500_ =V_4(_,w,_,a);\n                V_4 _0x00F200_ =V_4(_,W,_,a);\n\n                V_4 tab_000[8]=V_4[8](\n                    //:OUT OF BOUNDS:       //:HAS?\n                    _0x333333_ , _0x383838_ //:LAY0\n                   ,_0xE5E5E5_ , _0xF2F2F2_ //:LAY1\n                //: |   CHK0   |     CHK1   |::::::::://\n                                   \n                    //:IN BOUNDS:           //:HAS?\n                   ,_0x003300_ , _0x003800_ //:LAY0\n                   ,_0x00E500_ , _0x00F200_ //:LAY1\n                //: |   CHK0   |     CHK1   |::::::::://\n                );;\n                \n                I32 pik = (\n                   (4 * ( HAS >= uint(1) ? 1 : 0 ))\n                +  (2 * lay ) //: LAY0 -or- LAY1\n                +  (1 * chk ) //: CHK0 -or- CHK1\n                );;\n\n                if( pik < 0 || pik >= 8 ){\n                    c4d=PIX_ERR(ERR_002,c4d,o_k--);\n                };;\n                \n                //:TODO: Why is not rendering as\n                //:      checker?\n                if( 1 == o_k ){\n                    c4d = tab_000[ pik ];\n                };;\n\n            }else{\n                //:DEBUG ONLY.\n                //:c4d=V_4(1,1,1,1);\n            };;\n\n            return( c4d );\n        } \n\n    #undef  T_X \n    #undef  T_Y \n    #undef  T_Z \n    #undef  HAS\n    #undef  VAL\n    #undef  D_N\n    //:==============================:sdf_RenderScene://\n    //:=================================:RENDER_SCENE://\n\n//:11111111111111111111111111111111111111111111111111://\n//:00000000000000000000000000000000000000000000000000://\n\n    void mainImage( \n        out vec4 fragColor\n    ,   in  V_2 fragCoord \n    )\n    {\n            \n        #define R_Y iResolution.y\n            V_2 f_c = V_2(\n            //:( FLIP? )       ( Discrete XY       ) ://\n               (  0.0  )   +   ( fragCoord.x - 0.5 )\n            ,  (R_Y-1.0)   -   ( fragCoord.y - 0.5 )\n            );;\n        #undef R_Y  \n        V_2 f_p = f_c_CTO_f_p( f_c );\n\n\n        //:CAMERA_RAY_FOR_CURRENT_PIXEL:-------------://\n\n            /** The coordinate and direction of the  **/\n            /** camera ray [rwC,rwN] are closely     **/\n            /** related, so return them using the    **/\n            /** same function. This will save        **/\n            /** processing power when we decide      **/\n            /** to create a camera lense that        **/\n            /** is a 360 degree cylinder around      **/\n            /** an object. (for fun)                 **/\n\n            RWC_AND_RWN\n            rwC_AND_rwN;\n\n            rwC_AND_rwN = f_p_CTO_rwC_AND_rwN( f_p );\n\n        //:-------------:CAMERA_RAY_FOR_CURRENT_PIXEL://\n\n        fragColor = sdf_RenderScene( rwC_AND_rwN );\n\n    }\n//:00000000000000000000000000000000000000000000000000://\n//:DOCUMENTATION:====================================://\n/** ************************************************ ***\n    ABBREVIATIONS:\n\n        f : fragment\n        p : percent (Never Position, use C for coord)\n        c : coordinate\n        r : ray\n        n : normal, for directions.\n        d : distance. NEVER DIRECTION.( use: n:normal )\n        \n    IDENTIFIERS:\n\n        CTO: Convert_TO\n        rwC: RayWorldCoord\n        rwN: RayWorldNormal\n        f_p: FragPercent\n        f_c: FragCoord (With Discrete Pixel Coords)\n                    (instead of pixel centers  )\n        dad: Distance_And_inDEX \n            Index is 1D index of XYZ voxel tile\n            coordinate.\n        vat: Voxel_Array__of__Tiles\n        c4d: Color_4_Dimensional(RGBA)\n\n    FUNCTIONS:\n\n        f_c_CTO_f_p : FragmentCoord -CTO- FragPercent\n        f_c_CTO_per : USE[ f_c_CTO_f_p ]\n        sdf_i3d     : Interpolate_Two_3D_Points\n\n    CTRL_F_INDEX: (CTRL+F:INDEX, Search Phrases)\n                  (CTR + F)<-- Spaces Between Letters\n\n        Which Voxel Am I On? .... SEE[  @WHATVOX@  ]\n        What Voxel Am I On? ..... SEE[  @WHATVOX@  ]\n        Find Current Voxel ...... SEE[  @WHATVOX@  ]\n        pix_3d3 ................. TYPOFIX[ pix_d3d ]\n        til_3d3 ................. TYPOFIX[ til_d3d ]\n        cd4 ..................... TYPOFIX[   c4d   ]\n        m3d ..................... TYPOFIX[   m2d   ]\n        Voxel To Color Debug .... SEE[ @VOXBUGCOLOR@ ]\n        gradient,Gradient........ SEE[ @VOXBUGCOLOR@ ]\n        which voxel are we in ... SEE[ @WHATVOX@   ]\n\n    EXTRACTED_BLOCK_COMMENTS:\n\n        #ABOUT_RAY_MARCH_LOOP###########################\n\n            Ray marching loop should be able to look    \n            at the current voxel coordinate returned    \n            and decide to STOP marching if it wants.    \n            By stopping immediately without marching    \n            at all we can make the camera phosphore     \n            surface a slice plane that renders          \n            cross sectional views of tilemap data.      \n    \n        ##########################ABOUT_RAY_MARCH_LOOP##\n        #POSITIVE_Z_DIVES_INTO_SCREEN###################\n\n            Positive Z is further back into screen.\n            This way to help normalize voxel grid math.\n        \n        ###################POSITIVE_Z_DIVES_INTO_SCREEN#\n        #FIND_POINT_ON_SCREEN_PLANE#####################\n\n            ORIGINAL_COMMENT:\n\n                Polygon in 3d space to serve as the\n                phosphor surface the CRT monitor \n                electrons will be projected onto.\n                Could probably use a mat4 for this.\n\n            MORE_INFORMATION_IN_RETROSPECT:\n\n                \"Screen Plane\" is also known as \n                \"CRT Phospore\" or \"PHO\" for short.\n                This is a plane put into 3D space that\n                represents the pixels of the client\n                viewport (physical monitor).\n\n                The \"IMAGE\" plane from this diagram:\n                https://tinyurl.com/IMAGE-PLANE\n\n        #####################FIND_POINT_ON_SCREEN_PLANE#\n        #MODULO_CHECKER_PATTERN#########################\n\n            // Checker pattern value, 1 or 0.         //\n            // Combine Sets so that they create       //\n            // a checkerboard of odd/even values,     //\n            // and then convert even to 0 and         //\n            // odd to 1.                              //\n            //                                        //\n            // SET_YYY:[ 0 1 0 1 0 1 0 ]              //\n            // SET_XXX:[ 0 1 0 1 0 1 0 ]              //\n            //                                        //\n            // SET_XXX:     [ 0 1 0 1 0 1 0 ]         //\n            //                | | | | | | |           //\n            // SET_YYY:[ 0 ]- 0 1 0 1 0 1 0           //\n            //         [ 1 ]- 1 2 1 2 1 2 1           //\n            //         [ 0 ]- 0 1 0 1 0 1 0           //\n            //         [ 1 ]- 1 2 1 2 1 2 1           //\n            //         [ 0 ]- 0 1 0 1 0 1 0           //\n            //         [ 1 ]- 1 2 1 2 1 2 1           //\n            //         [ 0 ]- 0 1 0 1 0 1 0           //\n            int chk =(  \n                I32_MOD( // <<<<<<<<<<<<<< SET_003\n                    I32_MOD( T_Y, 2 )   // SET_YYY\n                +   I32_MOD( T_X, 2 )   // SET_XXX\n                ,                 2\n                )\n            );;\n\n        #########################MODULO_CHECKER_PATTERN#\n        #CONSISTENT_VOXEL_COORDS########################\n\n            The tilemap math for calculating what\n            [voxel/tile] we are inside of is \n            geometrically consistent, even when\n            given NEGATIVE numbers.\n\n            Meaning: The FIRST PIXELS of any\n                     [tile/voxel] are in the same\n                     relative position.\n\n            +-+-----+-+-----+-+-----+-+-----+\n            | | -1  | |  0  | |  +1 | |  +2 |\n            | |     | |     | |     | |     |\n            | +-----| +-----| +-----| +-----+\n            +-------+-------+-------+-------+\n\n            +-+ \n            | |   <--- The first edge of pixels for \n            | |        [voxel/tile] seen on the X/Y\n            | +-----|  axis.\n            +-------+\n        ########################CONSISTENT_VOXEL_COORDS#\n        #NEXT_VOXEL_BOUNDING_VOLUME#####################\n\n            Assuming vectors are moving in a positive\n            direction, the intersection point to \n            next voxel MUST be within the bounds of\n            the CURRENT VOXEL + One Pixel All Around.\n\n            Because we know the DIRECTION of the\n            ray vector, we don't need a bounding volume\n            and can just check that the respective\n            X,Y,Z bounding planes have\n            not been exceeded.\n\n            +--------------------+--------------------+ \n            |                    |                    |\n            |   +- - -  - - -+   |   +- - -  - - -+   | \n            |   |            |   |   |            |   | \n            |                    |                    | \n            |   |            |   |   |            |   | \n            |                    |                    | \n            |   |            |   |   |            |   | \n            |   +- - -  - - -+   |   +- - -  - - -+   | \n         111111111111111111111111111                  |\n         1  +--------------------+-1------------------+ \n         1  |                    | 1                  |\n         1  |   +- - -  - - -+   | 1 +- - -  - - -+   | \n         1  |   |            |   | 1 |            |   | \n         1  |                    | 1                  | \n         1  |   |     CV     |   | 1 |            |   | \n         1  |     (CurVoxel)     | 1                  | \n         1  |   |            |   | 1 |            |   | \n         1  |   +- - -  - - -+   | 1 +- - -  - - -+   | \n         1  |                    | 1                  |\n         1  +--------------------+-1------------------+ \n         111111111111111111111111111\n\n        #####################NEXT_VOXEL_BOUNDING_VOLUME#\n        #VOX_MAR_ABOUT##################################\n\n            VOX_MAR: ( VOXel_MARch )\n\n                    Holds information about ray\n                    marching WITHIN a single voxel.\n\n        ##################################VOX_MAR_ABOUT#\n        #DISTANCE_IS_NOT_CUMULATIVE#####################\n\n            WRONG: xyz =  rwC + ( rwN * D_N );\n            RIGHT: xyz =  xyz + ( rwN * D_N );\n\n            The distance is NOT cumulative. Our ray\n            marching is not anchored to the original\n            ray world coordinate ( rwC ). \n\n            Reason: \n                Collision with the first pixel of\n                the next voxel is PIXEL PERFECT and\n                if[  D_N  ]were a cumulative distance \n                over multiple iterations we would \n                probably see weird artifacts as slight \n                rounding errors compound.\n\n                Thus do NOT anchor to[  rwC  ]but \n                rather make a new origin location at\n                [  xyz  ]each loop iteration.\n    \n                Think: Folds in orgami.\n    \n        #####################DISTANCE_IS_NOT_CUMULATIVE#\n        #DIST_NEXT_NEVER_ZERO###########################\n\n            Even if you are 1 pixel away from the next\n            voxel, the distance to the next voxel should\n            NEVER be zero. It should always be a \n            POSITIVE NON-ZERO value. \n    \n            If this is NOT the case, your point-normal\n            form ray marching will fail.\n\n        ###########################DIST_NEXT_NEVER_ZERO#\n        #TRAP_VALUE_MUST_BE_NEG_666#####################\n\n            Using ( 0.0 - 666.0 ) as a trap value\n            in our code that determines the distance\n            to the next voxel. If you detect (-666.0)\n            in your ray march loop, it means that\n            the distance to the next voxel was never\n            set. Distance to next voxel should ALWAYS\n            be NON-ZERO and POSITIVE.\n\n        #####################TRAP_VALUE_MUST_BE_NEG_666#\n        #PIXEL_PROBABILITY_CLOUD########################\n\n            [TODO](MAYBE)\n\n            We should probably have 1 pixel equal to\n            3 native frag coords. That way if you\n            are in the CENTER of the pixel, you know\n            you don't need to alias. But if you are\n            on one of the boarder edges, you know\n            you need to use some aliasing.\n\n               [ONE FRAG COORD]\n                     _|_\n                    /   \\\n                    +   +     X: CENTER, no aliasing\n                    |   |        required.\n                    V   V\n            +---+---+---+ <--+\n            |   |   |   |     \\\n            +---+---+---+      \\\n            |   | X |   |       +--[ ONE PIXEL ]\n            +---+---+---+      /\n            |   |   |   |     /\n            +---+---+---+ <--+\n\n        ########################PIXEL_PROBABILITY_CLOUD#\n        #VOXEL_EDGE_COLOR###############################\n                \n            When percent(per) is zero the edges are    \n            BLACK and blend with background. That is       \n            not very useful for debugging, so lets \n            give the  edges a useful color coding to     \n            identify which planes of the voxel are  \n            intersecting at that edge.     \n\n\n            +--.--+--.--+\n            1\\     \\     \\     [X]: X_Plane: RED\n            1 \\  --[Z]--  \\    [Y]: Y_PLANE: GREEN\n            1  \\     \\     \\   [Z]: Z_PLANE: BLUE\n            1   +--.--+--.--+\n            1[X]2           3   1: Edge 1, YELLOW (R+G)\n            +   2           3   2: Edge 2, YELLOW (R+G)\n             \\  2    [Y]    3   3: Edge 3, YELLOW (R+G)\n              \\ 2           3\n               \\2           3\n                +--.--+--.--+\n\n            +--.--+--.--+       4: Edge 4, MAGENTA (R+B)\n            |4     \\     \\      5: Edge 5, CYAN    (G+B)\n            | 4  --[Z]--  \\     6: Edge 6, YELLOW  (R+G)\n            |  4     \\     \\ \n            |   +55555555555+\n            |[X]6           |  (Edge #'s Are Arbitrary)\n            +   6           |  (and do NOT reflect    )\n             \\  6    [Y]    |  (values in our code.   )\n              \\ 6           |\n               \\6           |  (Aritrary as in for    )\n                +--.--+--.--+  (illustrative purposes.)\n\n        ###############################VOXEL_EDGE_COLOR#\n        #NO_ELSE_FOR_EDGE_COLORING######################\n\n            Statement for calculating edge colors\n            should NOT have \"else\" or \"if else\" \n            because 2 planes intersect at edges \n            and 3 planes intersect at vertex.\n\n            THUS: EDGES : 2ndary(secondary) colors.(CMY)\n                  VERTEX: WHITE (R+G+B)\n\n        ######################NO_ELSE_FOR_EDGE_COLORING#\n        #STRATA_OF_2D_TILEMAPS##########################\n\n            We abstract the 3D tilemap (voxelmap) data\n            as a series of 2-dimensional tile maps \n            that are stacked on top of each other.\n\n            Because positive Z moves DOWN INTO THE\n            MONITOR, larger Z-layers go further\n            back into the screen.\n\n\n            U32  \n            VAT[ NTX * NTY * NTZ ]= U32[ 8 * 4 * 7 ](   \n\n            //: Z == 0 === First 2D TileMap\n\n            //: 1 2 3 4 5 6 7 8        --- -------------\n                _,_,_,_,_,_,_,_, //: 1  |        ^\n                _,_,_,_,_,_,_,_, //: 2  | Z == 0 |\n                _,_,_,_,_,_,_,_, //: 3  |        |\n                _,_,_,_,_,_,_,_, //: 4  |        |\n            //:                        ---       |\n            //: 1 2 3 4 5 6 7 8        ---       |\n                _,_,_,_,_,_,_,_, //: 1  | TILEMAP_STRATA\n                _,_,_,_,_,_,_,_, //: 2  |        |\n                _,_,_,_,_,_,_,_, //: 3  | Z == 1 |\n                _,_,_,_,_,_,_,_, //: 4  |        |\n            //:                        ---       |\n            //: 1 2 3 4 5 6 7 8        ---       |\n                _,_,_,_,_,R,_,_, //: 1  |        |\n                _,_,_,_,Y,_,_,_, //: 2  | Z == 2 |\n                _,_,_,M,_,_,_,_, //: 3  |        |\n                _,_,C,_,_,_,_,_, //: 4  |        V\n            //:                        --- -------------\n\n            );\n\n            //: Z == 2 === First 2D TileMap\n\n        ##########################STRATA_OF_2D_TILEMAPS#\n        #BACK_SLASH_COMMENT_FUCKERY#####################\n\n            The use of \"\\\" in a comment line seems\n            to be erroneously interpreted as a newline.\n\n            Example: Below wil NOT compile, even\n                     though it is syntactically correct.\n\n            U32  \n            VAT[ NTX * NTY * NTZ ]= U32[ 8 * 4 * 1 ](   \n\n            //: 1 2 3 4 5 6 7 8         \n                _,_,_,_,_,_,_,_, //: 1 \\\n                _,_,_,_,_,_,_,_, //: 2  \\__ Z == 0\n                _,_,_,_,_,_,_,_, //: 3  /\n                _,_,_,_,_,_,_,_, //: 4 /   \n\n            );\n\n        #####################BACK_SLASH_COMMENT_FUCKERY#\n\n\n*** ************************************************ **/\n//:====================================:DOCUMENTATION://\n//:UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU://\n/** U : Undefine Macros Section **/\n\n    #undef  V_4  \n    #undef  V_3  \n    #undef  V_2  \n    #undef  F32  \n    #undef  I32  \n    #undef  U32  \n\n/** U : Undefine Macros Section **/\n//:UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU://","name":"Image","description":"","type":"image"}]}