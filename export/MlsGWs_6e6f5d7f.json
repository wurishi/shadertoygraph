{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by nick whitney - nwhit/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Due to the use of single-precision floats, this deep zoom eventually runs into precision errors.\n// These errors seem to originate in the calculation of z over multiple iterations.\n// The closer to 0,0 the zoom is, the longer it takes to develop errors.\n\n//#define LessError\n\n/////////////////////////////////\n// Zoom Centers\n/////////////////////////////////\nconst vec2 fillErUp = vec2(0.3585614710926859372,\n                           0.3229491840959411351);\n\nconst vec2 sunflowers = vec2(-1.985540371654130485531439267191269851811165434636382820704394766801377,\n                             0.000000000000000000000000000001565120217211466101983496092509512479178);\n\nconst vec2 custom = vec2(0.2500001, 0.);\n\n/////////////////////////////////\n// General Constants\n/////////////////////////////////\nconst int maxIterations = 4096;\nconst float zoomSpeed = .35;\nconst float radius = 20.;\n\n/////////////////////////////////\n// Mandelbrot\n/////////////////////////////////\n// Calculate and return the iteration depth for the current pixel\nfloat Mandelbrot(vec2 p, vec2 c, float zoom)\n{       \n    //calculate the initial real and imaginary part of z, based on the pixel location and zoom and position values    \n    c = p / zoom + c;\n    \n    vec2 z = c;\n\n    //start the iteration process  \n    for(int i = 0; i < maxIterations; i++)\n    {          \n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        \n        if((z.x*z.x + z.y*z.y) > radius) \n        {\n            #ifdef LessError\n            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n            iter +=2;\n            #endif\n            \n            float modulus = sqrt(z.x*z.x + z.y*z.y);\n            \n            return(float(i) + 1. - log(log(modulus)) / log(2.));\n        }\n    }\n    \n    return 0.;\n}\n\n// generates a color based on the iteration depth of each pixel\nvec3 color(float i)\n{      \n    vec3 color = vec3((-cos(0.025 * i) + 1.0) / 2.0,\n                      (-cos(0.08 * i) + 1.0) / 2.0,\n                      (-cos(0.12 * i) + 1.0) / 2.0);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    /////////////////////////////////////////////////////////\n    // set the zoom center here using one of the vec2s above.\n    /////////////////////////////////////////////////////////\n    vec2 c = sunflowers;\n\n    // animation\t\n    float zoom = pow( 0.5, -zoomSpeed * mod(iTime, 30. / zoomSpeed) );\n    \n\tfloat iter = Mandelbrot(p, c, zoom);\n    \n    vec3 col = color(iter);\n    \n   \tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlsGWs","date":"1426314827","viewed":307,"name":"Mandelbrot Deep Zoom - Single P","username":"Razaekel","description":"Attempted Deep Zoom into the Mandelbrot set.\n\nUses Single Precision floats, so it develops errors after zoom level ~17.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","mandelbrot","deepzoom"],"hasliked":0,"parentid":"","parentname":""}}