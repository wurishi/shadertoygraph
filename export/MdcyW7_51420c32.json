{"ver":"0.1","info":{"id":"MdcyW7","date":"1519139994","viewed":186,"name":"Cuty pusheen","username":"Flopine","description":"Little tribute to our beloved pusheen the cat : http://www.pusheen.com/\n\nYou can use your mouse to move a little bit around the cat! ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","cat","pusheen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind and Leon for teaching me :) \n\n\n#define ITER 90\n#define PI 3.141592\n\n#define MAT_BODY 0.0\n#define MAT_PART 1.0\n\n\n/////////////////////// UTILITIES\nmat2 rot (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 mat_min (vec2 obj1, vec2 obj2)\n{\n    if (obj1.x < obj2.x)\n    {\n        return obj1;\n    }\n    else\n    {\n        return obj2;\n    }\n}\n\nfloat  random (vec2 obj)\n{\n\t  return fract(sin(dot(obj,vec2(131,648)))*415461.);  \n}\n\n\n///////////////////////\tSHAPES\nfloat sphe (vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat cylY (vec3 p, float r, float h)\n{\n    return max(length(p.xz)-r, abs(p.y)-h);\n}\n\n// iq's formula\n//c = vec3 (?, largeur de la base, longueur du cone)\nfloat sdCone( in vec3 p, in vec3 c) \n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n// iq's formula\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// iq's formula\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\n//////////////////////// MODELING\nfloat tail (vec3 p)\n{\n    p *= 1.5;\n    p.xy*= rot(-PI/4.);\n    p.x -= cos(p.y);\n   float cyl = cylY(p, (p.y+1.5)*0.25,1.);\n    p.y -= 1.2;\n    float sphere = sphe(p, 0.67);\n    return smin(sphere,cyl,0.1); \n}\n\nfloat mouth (vec3 p)\n{\n    p *= 2.;\n    float nose = sdCapsule(p, vec3 (0.), vec3 (0.,.4,0.),0.1);\n   \tp.x = abs(p.x);\n   \tp.y -= sin((p.x-1.)/0.4);\n    p.y -= 0.7;\n    float lips1 = sdCapsule(p, vec3 (0.), vec3 (0.6,.0,0.),0.1);\n    float prim = smin(nose,lips1,0.2);\n    return prim;\n}\n\nfloat mustaches (vec3 p)\n{   \n    p.xz *= rot(PI/25.);\n    p.x = abs(p.x);\n    p.xz *= rot(-PI/15.);\n    p.x -= .6;\n    p.xy *= rot(-PI/5.);\n    p.y -= sin(p.x-2.3/0.4);\n    float must1 = sdCapsule(p, vec3 (0.), vec3(0.6,0.,0.),0.06);\n    float must2 = sdCapsule(p, vec3 (0.,-0.3,0.), vec3(0.6,-0.5,0.),0.05);\n    return min(must1, must2);\n}\n\nfloat ears(vec3 p)\n{\n    vec3 cone_parameters = vec3(1.,0.4,1.); \n    p.x -= 1.;\n    float ears_R = sdCone(p, cone_parameters);\n    p.x += 1.5;\n    float ears_L = sdCone(p, cone_parameters);\n   return min(ears_R, ears_L);\n}\n\nfloat head (vec3 p)\n{\n    float head_shapes = sphe(p, 1.5);\n    float _ears = ears(vec3(p.x,p.y-2.1,p.z));\n    return smin(head_shapes, _ears, 0.5);\n}\n\nfloat body (vec3 p)\n{\n    p.x *= .7;\n    p.z *= 1.4;\n    return udRoundBox(p,vec3 (.2),2.);   \n}\n\nfloat paw (vec3 p)\n{\n    p.y *= 0.9;\n    return sphe(p,0.3);\n}\n\nvec2 basic_shape (vec3 p)\n{\n    float _body = body(vec3(p.x,p.y,p.z));\n    float _head = head(vec3(p.x+2., p.y-0.8,p.z+0.4));\n    float _tail = tail(vec3(p.x-2.5, p.y-0.8,p.z-0.2));\n    float _paw1 = paw(vec3(p.x+2.,p.y+1.8,p.z-0.6));\n    float _paw2 = paw(vec3(p.x+1.,p.y+1.9,p.z+0.8));\n    float _paw3 = paw(vec3(p.x-2., p.y+1.8, p.z -0.6));\n    float _paw4 = paw(vec3 (p.x-.9,p.y+1.9,p.z+0.8));\n    float _paws = min(min(min(_paw1,_paw2),_paw3), _paw4);\n    \n    return vec2(smin(_paws,smin(smin(_body,_head, 0.5), _tail,0.5), 0.5), MAT_BODY);\n}\n\n\nvec2 face (vec3 p)\n{\n    float _eyes1 = sphe(vec3 (p.x+0.2,p.y-0.5,p.z+1.45), .1);\n    float _eyes2 = sphe(vec3 (p.x-0.8,p.y-0.5,p.z+1.25), .1);   \n    float _mouth = mouth(vec3 (p.x-0.3,p.y-0.4,p.z+1.5));\n    float _must = mustaches(vec3 (p.x-0.3,p.y-0.2,p.z+1.));\n    float _face = min(_must,min(_mouth,min(_eyes1, _eyes2)));\n    return vec2(_face, MAT_PART);\n}\n\nvec3 heart (vec2 uv)\n{\n    uv.x += sin(iTime/0.7)*0.2;\n    uv.x = abs(uv.x);\n\n    uv.y -= uv.x*0.7;\n    float circle = step(length(uv), .12); \n    return vec3(0.,1.,1.)*circle;\n}\n\nvec3 background (vec2 uv)\n{\n    float per = 0.7;\n    uv.y += iTime;\n\n    uv = mod(uv-per/2.,per)-per/2.;\n    return 1.-heart(uv); \n}\n\n\n////////////////////////////////////////////////////////////////////\n// CAMERA\nvec3 getcam (vec3 eye, vec3 lookat, vec2 uv, float fov)\n{\n    vec3 forward = normalize(lookat-eye);\n    vec3 right = normalize(cross(vec3(0.,1.,0.),forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward*fov+right*uv.x+up*uv.y);\n}\n\n\n//////////////////////// MAP\nvec2 SDF (vec3 p)\n{\n    p.xz *= rot(iTime);\n\treturn mat_min(basic_shape(p), face(vec3(p.x+2., p.y-0.8,p.z+0.4)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = 2.*(iMouse.xy/iResolution.xy)-1.;\n    vec3 p = vec3(mouse*5.,-6.);\n    vec3 dir = getcam(p, vec3(0.),uv,1.);\n\n    float shad = 0.;\n    vec3 col = vec3 (0.);\n    \n    for (int i = 0; i<ITER; i++)\n    {\n        vec2 d = SDF(p);\n        if (d.x<0.001)\n        {\n            if (d.y == MAT_BODY) shad = float(i)/float(ITER);\n            else if (d.y == MAT_PART) shad = 1.;\n            \n            col = vec3(1.-shad);\n            break;\n        }\n        else col = background(uv);\n        p+=d.x*0.7*dir;\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}