{"ver":"0.1","info":{"id":"NtjGWw","date":"1624959755","viewed":127,"name":"SDF Implementation","username":"Ondra09","description":"Test implementation of SDF.\nFeatures:\ngluLookAt like camera position\nphong lighting\nsoft shadows\nreflections\nambient occlusion\ngamma correction\nantialiasing \n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////////////////////////\n// Intro tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// https://www.shadertoy.com/view/4dSfRc\n// TODO: add checkerbox texture and filter it: https://www.shadertoy.com/view/XlcSz2\n//===============================================================================================\n// Scene objects\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m =  p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n//------------------------------------------------------------------\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// worldMap defintion\n\nvec3 worldMap( in vec3 pos )\n{\n    vec3 res = vec3(1e10, 0.0, 1.0);\n    \n    res = opU(res, vec3( sdPlane(pos-vec3(0, -0.5, 0)), 2.95, 0. ) ); // pos, color, reflection\n    res = opU(res, vec3( sdSphere(pos-vec3(.0,-0.25, 0.0), 0.25 ), 10.2, 1.) );\n    res = opU(res, vec3( sdBoundingBox(pos-vec3( -1.0, -0.25, 0.0), vec3(0.3,0.25,0.2), 0.025), 11.12, 1.0) );\n    res = opU(res, vec3( sdTorus((pos-vec3(-0.3, -0.25, 1.0)).xzy, vec2(0.25,0.05) ), 25.0, 1.0) );\n    \n    res = opU(res, vec3( sdOctahedron(pos-vec3(.750,0.25, 0.0), 0.4325 ), 10.8, 1.0) );\n    \n    \n    return res;\n}\n\nvec3 rayCast(in vec3 ro, in vec3 rd) \n{\n    vec3 res = vec3(-1.0, 0.0, 0.0);\n    \n    float tmin = 1.0;\n    float tmax = 20.0; // max step distance    \n    \n    int steps = 0;\n    for (float tstep = tmin; tstep < tmax;) \n    {   \n        vec3 h = worldMap(ro + tstep * rd);       \n        \n        if (h.x < 0.0001 )\n        {\n            res.x = tstep;\n            res.y = h.y;\n            res.z = h.z;\n            return res;\n        }            \n        \n        tstep += h.x;\n        \n        // just to be sure we do not end in endless loop if during development\n        steps++;        \n        if (steps > 1750)\n            return vec3(20000.0, 1.0, 0.0);\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\n// https://www.shadertoy.com/view/lsKcDD\n// it still suffers from some self shadow and minro light bleeding artifats however, even with  Sebastian Aaltonen's improvement\nfloat softShadows(in vec3 ro, in vec3 lightPos) \n{\n    vec3 rd = normalize(lightPos - ro);           \n    const float k = 8.0;\n    float tmin = 0.0090;\n    float tmax = 2.0; // max step distance    \n    \n    float res = 1.0;\n    float prevh = 1e20; // infinity\n    for( float t = tmin; t < tmax; )\n    {\n        float h = worldMap(ro + rd * t).x;\n        if(h < 0.001*t)\n            return 0.0;            \n        \n        float y = h * h / (2.0 * prevh);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0.0,t-y));\n        prevh = h;\n        t += h;\n    }\n    \n    res = clamp(res, 0.0, 1.0);\n    return res * res * (3.0 - 2.0 * res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    // central differencing\n    // line 444: https://www.shadertoy.com/view/Xds3zN\n    return normalize( e.xyy * worldMap( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx * worldMap( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy * worldMap( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx * worldMap( pos + e.xxx ).x );\n}\n\n\nfloat ambientOcclusion(in vec3 ro, in vec3 normal)\n{\n    float sum = 0.0;\n    float pointWeight = 1.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        float normalStep = 0.001 + 0.15 * float(i) / 4.0; // we perform step along normal\n        \n        float distanceToNormalPoint = worldMap(ro + normalStep * normal).x;\n        sum += (normalStep - distanceToNormalPoint) * pointWeight;\n        pointWeight *= 0.95;\n    }\n    \n    return clamp(1.0-1.5*sum, 0.0, 1.0);\n}\n\nvec3 colorFromMaterial(in float mat)\n{\n    return 0.2 + 0.2*sin(mat*2.0 + vec3(0.0,1.0,2.0));\n}\n\n// https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\n// interesting post pointing to this article:\n// https://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/\nvec4 computeBlinnPhongLighting(in vec3 depthMaterial, in vec3 ro, in vec3 rd, in vec3 lightPos) \n{    \n    vec3 col = colorFromMaterial(depthMaterial.y);\n    \n    vec3 surfacePoint = ro + rd * (depthMaterial.x);\n    \n    vec3 normal = calcNormal(surfacePoint);\n    \n    vec3 lightDir = normalize(lightPos - surfacePoint);\n    \n    float diffuse = clamp(dot(lightDir, normal), 0.0, 1.0);\n    \n    const float kShininess = 16.0;\n    const float kPi = 3.1415926;\n    const float kEnergyConservation = ( 2.0 + kShininess ) / ( 2.0 * kPi );\n    \n    vec3 reflectV = normalize(reflect(-lightDir, normal));\n    float specular = pow(clamp(dot(-rd, reflectV), 0.0, 1.0), kShininess);\n    \n    float amb = clamp(0.2+0.5*depthMaterial.y, 0.0, 1.0) * 0.2;\n    float shadow = softShadows(surfacePoint, lightPos);\n    float ao = ambientOcclusion(surfacePoint, normal);\n    vec3 reflected = reflect(rd, normal);\n    \n    float dom = smoothstep(-1.50, 0.51, reflected.y);\n    \n    float reflection = softShadows(surfacePoint, reflected);\n    \n    float lightning =  ao * shadow *( diffuse + diffuse * (kEnergyConservation*specular)) // * (0.04 + 0.96*pow( clamp(1.0+dot(reflectV,rd),0.0,1.0), 5.0 ))) \n                      + amb;\n                      \n    /*\n    vec3 lin = 0.090 * dom * vec3(0.80, 0.7, 1.0) * ao + 0.0031; // this gives objects glossy look \n    \n    col += lin;\n    col += depthMaterial.z * 0.01 * reflection * vec3(0.8, 0.7, 1.0) * ao;    \n    col *= lightning; \n    */\n    \n    vec3 lin = vec3(0.0);\n    \n    lin += col * 0.750 * dom * vec3(0.80, 0.7, 1.0) * ao; \n    \n    lin += col * depthMaterial.z * 0.35 * reflection * vec3(0.8, 0.7, 1.0) * ao;    \n    \n    col = lin;\n    \n    col *= lightning; \n    \n    return vec4(col, 1.0);\n}\n\n\nmat4 lookAt(in vec3 pos, in vec3 target, in vec3 up) \n{\n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(cross(forward, up));\n    vec3 y = normalize(cross(right, forward));   \n   \n    return mat4(vec4(right, 0.0),\n                vec4(y, 0.0),\n                vec4(-forward, 0.0),\n                vec4(0.0, 0.0, 0.0, 0.1));\n}\n\nmat3 rotateY(in float alpha) \n{\n    return mat3(cos(alpha), 0., sin(alpha),\n                0         , 1.,          0, \n                -sin(alpha), 0., cos(alpha));\n}\n\nvec3 castVector(in vec3 uv, in vec3 cameraOrigin) \n{\n    // orthogonal to origin by setting z = 1\n    return  normalize(uv - cameraOrigin);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)    \n    float ratio = iResolution.x / iResolution.y;\n    \n        \n    vec3 camPos = vec3(0.0, 0.8, 2.7);\n    vec3 lightPos = vec3(10.0, 10.0, 10.0);\n    mat3 rotM = rotateY(iTime * 0.5);\n    lightPos = rotM * lightPos;\n    \n    vec4 color = vec4(0.0);\n    //mulitsampling\n    const int MULTISAMPLE = 2;\n    for (int i = 0; i < MULTISAMPLE; ++i) \n    {\n        for (int j = 0; j < MULTISAMPLE; ++j)\n        {                           \n            vec2 shift = (vec2(float(i), float(j)) / float(MULTISAMPLE) - 0.5f);            \n            vec2 uv = (fragCoord+shift)/iResolution.xy;            \n            \n            uv = uv - 0.5;    \n            uv.x *= ratio;\n            \n            // focal length from camera is -z\n            vec4 uvPos = vec4(uv.xy, -1.0, 1.0);           \n\n            mat4 viewM = lookAt(camPos, vec3(0.0, .2, 0), vec3(0,1,0));\n\n            uvPos = (viewM) * uvPos;    \n            uvPos.xyz += camPos.xyz;\n\n            vec3 rd = castVector(uvPos.xyz, camPos);\n\n            vec3 res = rayCast(camPos, rd);\n\n            color += computeBlinnPhongLighting(res, camPos, rd, lightPos * 1.0);\n        }\n    }\n    \n    color /= float(MULTISAMPLE * MULTISAMPLE);\n    // gamma\n    color = pow(color, vec4(0.4545)); // value 1/2.22 is good for LCD displays\n    \n    // Output to screen    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}