{"ver":"0.1","info":{"id":"DtfBzB","date":"1693156724","viewed":35,"name":"ocean w/ray marching","username":"IBJ","description":"An ocean, made using a sum of e^sin() waves.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define E 2.71828182845\n#define RAY_LENGTH 1.0\n\n#define MAX_DIST 200.0\n#define MIN_LENGTH 0.3\n#define MAX_RAYS 100\n\nmat3 xyzRot3(vec3 a) {\n    vec3 s = sin(a), c = cos(a);\n    return mat3( c.z, s.z,   0,\n                -s.z, c.z,   0,\n                   0,   0,   1 ) *\n                   \n           mat3( c.y,   0,-s.y,\n                   0,   1,   0,\n                 s.y,   0, c.y ) *\n                 \n           mat3(   1,   0,   0,\n                   0, c.x, s.x,\n                   0,-s.x, c.x );\n}\n\nfloat sine3(vec3 p, vec3 r, float h, float f, float phase) {\n    p = xyzRot3(r/180.0*PI)*p;\n    return exp(sin(p.x*f+iTime*phase)-1.0)*h;\n}\n\nfloat sdSphere(vec3 p1, float s) {\n    return length(p1)-s;\n}\n\nfloat sdInfSphere(vec3 p1, vec3 c, float s) {\n  return length( mod(p1,c)-0.5*c ) - s;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdSine(vec3 p, float h, float f) {\n    return ((p.y/f)-sin(p.x/f)*(1.0/f)*h)*f;\n}\n\nfloat sdSineSum(vec3 p, int it, float am, float fm) {\n    float s = 0.0, r = 0.0;\n    float a = 1.0, f = 1.0;\n    for (int i = 0; i<it; i++) {\n        s += sine3(p, vec3(0.0, r, 0.0), a, f/3.0, 1.0);\n        r = mod(r+572.3923, 360.0);\n        a *= am, f *= fm;\n    }\n    \n    return p.y - s;\n}\n\n\nvec4 unionSDF(vec4 a, vec4 b) {\n    return a.w < b.w? a : b;\n}\n\nvec4 intersectSDF(vec4 a, vec4 b) {\n    return a.w > b.w ? a : b;\n}\n\nvec4 dist(vec3 pos, float od) {\n    \n    vec4 d = vec4(0.75, 0.0, 0.0, sdSine(xyzRot3(vec3(0.0, -50.0, 0.0)/180.0*PI)*pos, 1.0, 1.0));\n    d = vec4(0.0, 0.0, 0.8, sdSineSum(pos, int(floor(50.0/max(od,5.0)))+5, 0.78, 1.18));\n\n    \n    return vec4(d.xyz,d.w*RAY_LENGTH);\n}\n\nvec3 getNormal(vec3 p, float od) {\n    float epsilon = 0.001;\n    float centerDistance = dist(p,od).w;\n    float xDistance = dist(p + vec3(epsilon, 0, 0),od).w;\n    float yDistance = dist(p + vec3(0, epsilon, 0),od).w;\n    float zDistance = dist(p + vec3(0, 0, epsilon),od).w;\n    return ((vec3(xDistance, yDistance, zDistance) - centerDistance) / epsilon);\n}\n\nvec3 march(in vec3 position, vec3 rd) {\n    vec3 po = position;\n    float od = 0.0;\n    for (int i = 0; i < int(MAX_RAYS); i++) {\n        vec4 d = dist(po, od);\n        od += d.w;\n        po = position + rd * od;\n        if (abs(d.w) < MIN_LENGTH, od > MAX_DIST) {\n            break;\n        }\n    }\n    return po;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x *= aspect;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    \n    vec3 po = vec3(0.0, 5.0, 0.0);\n    \n    if (iMouse.z > 0.0) {\n    ro = vec3(((iMouse.yx / iResolution.yx) * 180.0 - 90.0), 0.0);\n    }\n    \n    ro = ro / 180.0 * PI;\n    ro = xyzRot3(ro) * (normalize(vec3(uv, 1.0)));\n    \n    vec3 pos = march(po, ro);\n    vec3 color = dist(pos, length(pos-po)).rgb;\n    vec3 nor = getNormal(pos, length(pos-po));\n    float s = (dot(normalize(vec3(0.0, 1.0, 1.0)), nor));\n    s = ((abs(s) + s) / 2.0)*(1.0/RAY_LENGTH);\n    \n    //shadows\n    //vec3 shadowp = march(pos, normalize(vec3(0.0, 1.0, 0.0)));\n    //if (length(shadowp - pos) < 10.0) {\n    //    s = s * 0.7;\n    //}\n    //vec3 color = vec3(3.0/dist-0.1, 3.0/dist-0.1, 3.0/dist-0.1);\n    \n    color = max(color*s - length(pos-po)/MAX_DIST,0.0) + vec3(texture(iChannel0, ro)) * min(length(pos-po)/MAX_DIST,1.0);\n    \n    //if (length(pos-po) > MAX_DIST) {\n    //    color = vec3(texture(iChannel0, ro));\n    //}\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n    col = vec3(0.0, 0.0, 1.0);\n    \n    float sun = clamp(4.0*pow(max(dot(vec3(0.0, 1.0, 1.0), rayDir),0.0)/1.6,10.0),0.0, 1.0);\n    \n    col = (col*(1.0-sun) + vec3(1.0, 1.0, 0.0)*sun);\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}