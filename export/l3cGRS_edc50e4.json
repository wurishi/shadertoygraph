{"ver":"0.1","info":{"id":"l3cGRS","date":"1716823469","viewed":176,"name":"Phosphor Physarum","username":"coposuke","description":"Reference: @Sage Jenson\nhttps://cargocollective.com/sagejenson/physarum\n\nThe total number of scenes is 9. (loop)\n\nR: Reset","likes":24,"published":1,"flags":48,"usePreview":0,"tags":["voronoi","simulation","tracking","jump","particle","flooding","jfa","physarum"],"hasliked":0,"parentid":"433GW4","parentname":"Ball Pool"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Visualize Pheromone Trails\n//\n// Buffer A: Particle Buffer\n// Buffer B: Voronoi Tracking Buffer\n// Buffer C: Trail buffer\n// \nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float pheromone = texture(iChannel2, uv).x;\n    \n    PhysarumParam param = getPhysarumParam(iFrame, iResolution.xy, fragCoord);\n    \n    float hTime = fract(iTime * 1e-3) * TAU;\n    float hOffset = param.sensorDistance * 1e-2 * PI;\n    vec3 color = hsv2rgb(vec3(hOffset + hTime, 0.25, 0.9));\n    color = pheromone * color * 0.25;\n    \n    fragColor.rgb = color;\n\n    // debug\n    //fragColor = texture(iChannel0, uv);\n    //fragColor += texture(iChannel1, uv) / float(PARTICLES);\n    //fragColor = texture(iChannel2, uv).xxxx * 0.3;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Update Physarum Particle\n// \n// xy: position\n// z: direction (radian)\n// w: prev position(half x, half y)\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\n    int particles = getParticleCount(iResolution.xy);\n    int particleID = getParticleID(fragCoord, iResolution.xy);\n    if (particleID >= particles)\n        return;\n        \n    vec4 particle = getParticle(iChannel0, iResolution.xy, particleID); // ==texture(iChannel0, fragCoord / iResolution.xy);\n    vec2 position = particle.xy;\n    vec2 prevPosition = particle.xy;\n    float direction = particle.z;\n    \n    // Initialize & Reset\n    if (iFrame < 10 || 0.0 < getKeyR(iChannel3, 0))\n    {\n        position.x = hash(fragCoord.xy);\n        position.y = hash(fragCoord.xy * 0.5);\n        position *= iResolution.xy;\n        \n        direction = hash(float(particleID)) * TAU;\n    }\n    // Update\n    else\n    {\n        // Physarum parameters\n        PhysarumParam param = getPhysarumParam(iFrame, iResolution.xy, position);\n        float sensorRadian = param.sensorRadian;\n        float sensorDistance = param.sensorDistance;\n        float rotateRadian = param.rotateRadian;\n        float moveDistance = param.moveDistance;\n        \n        // Sampling sensing 3 points\n        vec2 sensorFrontPoint = position + sensorDistance * vec2(cos(direction), sin(direction));\n        vec2 sensorLeftPoint = position + sensorDistance * vec2(cos(direction - sensorRadian), sin(direction - sensorRadian));\n        vec2 sensorRightPoint = position + sensorDistance * vec2(cos(direction + sensorRadian), sin(direction + sensorRadian));\n        sensorFrontPoint = repeat(sensorFrontPoint, iResolution.xy);\n        sensorLeftPoint = repeat(sensorLeftPoint, iResolution.xy);\n        sensorRightPoint = repeat(sensorRightPoint, iResolution.xy);\n        \n        vec4 trailFront = texture(iChannel2, sensorFrontPoint / iResolution.xy);\n        vec4 trailLeft = texture(iChannel2, sensorLeftPoint / iResolution.xy);\n        vec4 trailRight = texture(iChannel2, sensorRightPoint / iResolution.xy);\n        \n        float pheromoneFront = trailFront.x;\n        float pheromoneLeft = trailLeft.x;\n        float pheromoneRight = trailRight.x;\n        \n        // Determining direction.\n        bool isFront = pheromoneLeft <= pheromoneFront && pheromoneRight <= pheromoneFront;\n        bool isRandom = !isFront && pheromoneLeft == pheromoneRight;\n        bool isLeft = !isFront && pheromoneLeft > pheromoneRight;\n        bool isRight = !isFront && pheromoneLeft < pheromoneRight;\n        \n        if(isRandom)\n            direction += (particleID % 2 == 0) ? -rotateRadian : rotateRadian;\n        else if(isLeft)\n            direction -= rotateRadian;\n        else if(isRight)\n            direction += rotateRadian;\n        \n        // Move\n        vec2 velocity = vec2(cos(direction), sin(direction));\n        position += velocity * moveDistance;\n        \n        // Loop screen(In Scene Index 1, there is a bug that the particles go straight after warping.)\n        position = repeat(position, iResolution.xy);\n    }\n    \n    particle.xy = position;\n    particle.z = mod(direction, TAU);\n    particle.w = uintBitsToFloat(packHalf2x16(prevPosition));\n    fragColor = particle;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//\n// Physarum Simulation\n//\n// Buffer A: Particle Buffer\n// Buffer B: Voronoi Tracking Buffer\n// Buffer C: Trail buffer\n// \n\n/// Other ///\nconst float PI = 3.14159265358979;\nconst float TAU = PI * 2.0;\n\nfloat getKeyR(sampler2D keyboardBuffer, int state)\n{\n    return texelFetch(keyboardBuffer, ivec2(82, state), 0).x;\n}\n\nvec2 repeat(vec2 point, vec2 resolution)\n{\n    return mod(point, resolution);\n}\n\n/// Hash ///\nfloat hash(float v)\n{\n    return fract(sin(v) * 43758.5453123);\n}\n\nfloat hash(vec2 v)\n{\n    return fract(sin(dot(v, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n/// Physarum Paramters ///\nstruct PhysarumParam\n{\n    float sensorRadian;\n    float sensorDistance;\n    float rotateRadian;\n    float moveDistance;\n    float decayTrail;\n};\n\nconst PhysarumParam[10] PHYSARUM_PARAMS = PhysarumParam[10]\n(\n    PhysarumParam(PI * 0.001,  9.0, PI * 0.1,  4.0, 0.8), // Plasmodium\n    PhysarumParam(PI * 0.8,   15.0, PI * 0.2,  2.0, 0.9), // Fruiting Body\n    PhysarumParam(PI * 0.8,    4.0, PI * 0.9,  4.0, 0.7), // Bacteria\n    PhysarumParam(PI * 0.001, 10.0, PI * 0.9,  4.0, 0.7), // Microbe Colony\n    PhysarumParam(PI * 0.01,   5.0, PI * 0.3,  3.0, 0.9), // Transport Network\n    PhysarumParam(PI * 0.001, 30.0, PI * 0.1,  4.0, 0.9), // Big rope\n    PhysarumParam(PI * 0.001, 15.0, PI * 0.1,  4.0, 0.8), // Perforated Sweater\n    PhysarumParam(PI * 0.02, 100.0, PI * 0.02,20.0, 0.7), // Lines\n    PhysarumParam(PI * 0.6,   10.0, PI * 0.1,  3.0, 0.9), // Rings\n    PhysarumParam(PI * 0.01,   5.0, PI * 0.01, 2.0, 0.8)  // Break\n);\n\nconst ivec2 [9] SCENE = ivec2[9]\n(\n    ivec2(9, 0),\n    ivec2(1, 1),\n    ivec2(8, 4),\n    ivec2(6, 5),\n    ivec2(7, 7),\n    ivec2(4, 7),\n    ivec2(0, 0),\n    ivec2(2, 3),\n    ivec2(0, 9)\n);\n\nPhysarumParam getPhysarumParam(int frame, vec2 resolution, vec2 fragCoord)\n{\n    vec2 halfResolution = resolution.xy * 0.5;\n    float circleRadius = min(halfResolution.x, halfResolution.y) * 0.8;\n    float circleDist = distance(halfResolution, fragCoord);\n    circleDist = step(circleRadius, circleDist);\n\n    ivec2 scene = SCENE[int(frame / 300) % 9];\n    \n    PhysarumParam p0 = PHYSARUM_PARAMS[scene.x];\n    PhysarumParam p1 = PHYSARUM_PARAMS[scene.y];\n    vec4 m0 = vec4(p0.sensorRadian, p0.sensorDistance, p0.rotateRadian, p0.moveDistance);\n    vec4 m1 = vec4(p1.sensorRadian, p1.sensorDistance, p1.rotateRadian, p1.moveDistance);\n    vec4 mixed = mix(m0, m1, circleDist);\n    float mixedDecay = mix(p0.decayTrail, p1.decayTrail, circleDist);\n    \n    p0.sensorRadian = mixed.x;\n    p0.sensorDistance = mixed.y;\n    p0.rotateRadian = mixed.z;\n    p0.moveDistance = mixed.w;\n    p0.decayTrail = mixedDecay;\n    return p0;\n}\n\n\n/// Particle ///\nfloat getParticleRadius(vec2 resolution)\n{\n    return 1.5;\n}\n\nint getParticleCount(vec2 resolution)\n{\n    float radius = getParticleRadius(resolution);\n    float fullCount = floor(resolution.x * resolution.y / (4.0 * radius * radius));\n    return int(fullCount * 1.0);\n}\n\nint getParticleID(ivec2 fragCoord, ivec2 resolution)\n{\n    return fragCoord.x + fragCoord.y * resolution.x;\n}\n\nint getParticleID(vec2 fragCoord, vec2 resolution)\n{\n    return getParticleID(ivec2(fragCoord), ivec2(resolution));\n}\n\nvec4 getParticle(sampler2D aBuffer, vec2 resolution, int pid)\n{\n    int particles = getParticleCount(resolution);\n    pid = abs(pid) % particles; // round to within limit\n\n    int rx = int(resolution.x);\n    int ux = pid % rx;\n    int uy = pid / rx;\n    return texelFetch(aBuffer, ivec2(ux, uy), 0); // aBuffer = ParticleBuffer\n}\n\n\n/// Voronoi Tracking ///\nivec4 getClosest(sampler2D bBuffer, ivec2 fragCoord)\n{\n    return ivec4(texelFetch(bBuffer, fragCoord, 0));\n}\n\nivec4 getClosest(sampler2D bBuffer, vec2 fragCoord)\n{\n    return getClosest(bBuffer, ivec2(fragCoord));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// Voronoi Tracking (Same from forked)\n// \n// x: closest no.1\n// y: closest no.2\n// z: closest no.3\n// w: closest no.4\n//\n\n//#define MODE_VERY_HIGH_PERFORMANCE\n#define MODE_HIGH_PERFORMANCE\n//#define MODE_MIDDLE_PERFORMANCE\n//#define MODE_LOW_PERFORMANCE\n\nvoid insertClosest(inout ivec4 srcIDs, inout vec4 srcDist, in int dstID, in float dstDist)\n{\n    if (dstDist < srcDist.x)\n    {\n        srcIDs = ivec4(dstID, srcIDs.xyz);\n        srcDist = vec4(dstDist, srcDist.xyz);\n    }\n    else if(dstDist < srcDist.y)\n    {\n        srcIDs = ivec4(srcIDs.x, dstID, srcIDs.yz);\n        srcDist = vec4(srcDist.x, dstDist, srcDist.yz);\n    }\n    else if(dstDist < srcDist.z)\n    {\n        srcIDs = ivec4(srcIDs.xy, dstID, srcIDs.z);\n        srcDist = vec4(srcDist.xy, dstDist, srcDist.z);\n    }\n    else if(dstDist < srcDist.w)\n    {\n        srcIDs = ivec4(srcIDs.xyz, dstID);\n        srcDist = vec4(srcDist.xyz, dstDist);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec4 closestList = ivec4(-1);  // new closest list (particleIDs)\n    vec4 distanceList = vec4(1e+8); // new distance list\n\n    // Reset\n    if (0.0 < getKeyR(iChannel2, 1))\n    {\n        fragColor = vec4(closestList);\n        return;\n    }\n\n    // setting parameters (by mode performance)\n    float jfStart = min(10.0, floor(log2(max(iResolution.x, iResolution.y))));\n    int offsetLoops = 9;\n    const vec2 [9] OFFSETS = vec2[9]\n    (\n        vec2(-1.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(0.0, -1.0), vec2(0.0,  0.0), // Left, Up, Right, Down, Center\n        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0,  1.0), vec2(1.0,  1.0) // 4 corners\n    );\n    int closestLoops = 4;\n    \n#ifdef MODE_VERY_HIGH_PERFORMANCE\n    // very high (max loops: 11 * 9 * 4 = 396)\n#elif defined(MODE_HIGH_PERFORMANCE)\n    // high      (max loops: 11 * 9 * 2 = 198)\n    closestLoops = 2;\n#elif defined(MODE_MIDDLE_PERFORMANCE)\n    // middle    (max loops:  9 * 5 * 2 = 90)\n    jfStart = floor(jfStart * 0.8);\n    offsetLoops = 5;\n    closestLoops = 2;\n#else //MODE_LOW_PERFORMANCE\n    // low       (max loops:  7 * 5 * 1 = 35)\n    jfStart = floor(jfStart * 0.6);\n    offsetLoops = 4;\n    closestLoops = 1;\n#endif\n\n    // jump flooding loops\n    for (float jf = jfStart; jf >= 0.0; jf--)\n    {\n        float jfLength = pow(2.0, jf);\n        \n        // getting neighbor closest particleID list\n        for (int i = 0; i < offsetLoops; ++i)\n        {\n            vec2 offset = OFFSETS[i];\n            vec2 uv = repeat(fragCoord + offset * jfLength, iResolution.xy);\n            ivec4 neighbor = getClosest(iChannel1, uv);\n\n            for(int ci = 0; ci < closestLoops; ci++) // closest index\n            {\n                int particleID = neighbor[ci];\n\n                // continue when closestList contain the particleID\n                if (any(equal(closestList, ivec4(particleID))))\n                    continue;\n\n                vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n                vec2 particlePos = particle.xy;\n\n                // comparing distance fragCoord to particlePos, and insert one closest.\n                float dist = distance(fragCoord, particlePos);\n                insertClosest(closestList, distanceList, particleID, dist);\n            }\n        }\n    }\n    \n    // random pick a particleID, and insert one closest.\n    // we need to find closest particle IDs, with in the area between particles.\n    {\n        int particles = getParticleCount(iResolution.xy);\n    \n        int [2] particleIDs = int[2](0, 0);\n        particleIDs[0] = int(hash(fragCoord + iTime * 0.1) * float(particles));            // random pick\n        particleIDs[1] = (getParticleID(fragCoord, iResolution.xy) + iFrame) % particles;  // fixed pick\n\n        for (int i = 0; i < 2; ++i)\n        {\n            int particleID = particleIDs[i];\n            \n            // Same as above\n            if (!any(equal(closestList, ivec4(particleID))))\n            {\n                vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n                vec2 particlePos = particle.xy;\n\n                float dist = distance(fragCoord, particlePos);\n                insertClosest(closestList, distanceList, particleID, dist);\n            }\n        }\n    }\n    \n    // TODO: floatBitsToUint, intBitsToFloat\n    fragColor = vec4(closestList);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//\n// Update Physarum Trail\n// \n// x: Pheromone trail\n// y: Blank\n// z: Blank\n// w: Blank\n//\nfloat sdfLine(vec2 l0, vec2 l1, vec2 p)\n{\n    vec2 v01 = (l1 - l0);\n    vec2 v0p = ( p - l0);\n    vec2 vh = v0p - v01 * clamp(dot(v01, v0p) / dot(v01, v01), 0.0, 1.0);\n    return length(vh);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 trail = texture(iChannel2, uv);\n    \n    // Initialize & Reset\n    if (iFrame < 10 || 0.0 < getKeyR(iChannel3, 0))\n    {\n        trail = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    // Update\n    else\n    {\n        // Diffusing pheromone trails (Averaging Filter)\n        float pheromone = 0.0;\n        for (int x = -1; x <= 1; x++)\n        {\n            for (int y = -1; y <= 1; y++)\n            {\n                vec2 uvOffset = vec2(x, y) / iResolution.xy;\n                vec4 neighbor = texture(iChannel2, uv + uvOffset);\n                pheromone += neighbor.x;\n            }\n        }\n        pheromone = pheromone / 9.0;\n\n        // Attenuation pheromon trails\n        float decay = getPhysarumParam(iFrame, iResolution.xy, fragCoord).decayTrail;\n        pheromone *= decay;\n        trail.x = pheromone;\n\n        // Particles attach the pheromone trail\n        float dist = 1e+8;\n        ivec4 closest = getClosest(iChannel1, fragCoord);\n\n        for (int i = 0; i < 4; ++i)\n        {\n            int particleID = closest[i];\n            vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n            vec2 particlePos = particle.xy;\n            vec2 particlePrevPos = unpackHalf2x16(floatBitsToUint(particle.w));\n\n            //dist = min(dist, distance(fragCoord, particlePos));               // dot\n            dist = min(dist, sdfLine(particlePrevPos, particlePos, fragCoord)); // line\n        }\n\n        float particleRadius = getParticleRadius(iResolution.xy);\n        pheromone = step(dist, particleRadius);\n\n        trail.x += pheromone;\n    }\n    \n    fragColor = trail;\n}","name":"Buffer C","description":"","type":"buffer"}]}