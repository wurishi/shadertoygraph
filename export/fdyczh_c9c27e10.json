{"ver":"0.1","info":{"id":"fdyczh","date":"1654362138","viewed":40,"name":"finallobna","username":"Lobnajbeniani1998","description":"The basecode to use for Tasks 4+","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["vcl"],"hasliked":0,"parentid":"fsVyRz","parentname":"Fork Task6 Lobn Lobnajbeni 615"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//citations: kysen osbourn as a main collaborator\n#define DIELECTRIC 2\n#define NUM_SPHERES 5\nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\nstruct camera\n{\n    vec3 lookfrom;\n    vec3 lookat;\n    vec3 vup;\n    vec3 w;\n    vec3 u;\n    vec3 v;\n    float aspect_ratio;\n    float aperture;\n    float focus_dist;\n    float lens_radius;\n    float focal_length;\n    vec3 origin;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 lower_left_corner;\n    float v_fov;\n    float theta;\n    float h;\n    float viewport_height;\n    float viewport_width;\n};\n// holds information about the sphere's material/how light should interact with the sphere\nstruct material\n{\n    vec3 albedo;\n    int mat_type;\n    float mat_dependent;\n};\n// keeps track of where we hit a sphere and whether we hit inside or outside\nstruct hit_record\n{\n    vec3 p;\n    vec3 normal;\n    float t;\n    bool front_face;\n};\n// defines a sphere\nstruct sphere\n{\n    vec3 center;\n    float radius;\n    hit_record rec;\n    bool hit;\n    material mat;\n};\n// moves the ray along some distance t\nvec3 rayAt(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n// returns the camera ray given data about the camera\nray get_camera_ray(float u, float v, camera cam) {\n    vec2 rd = cam.lens_radius * random_in_unit_disk(g_seed);\n    vec3 offset = cam.u * rd.x + cam.v * rd.y;\n    return ray(cam.origin + offset, cam.lower_left_corner + u * cam.horizontal + v * cam.vertical - cam.origin - offset);\n}\nbool near_zero(vec3 vec) {\n    float epsilon = 1e-8;\n    return (vec.x < epsilon) && (vec.y < epsilon) && (vec.z < epsilon);\n}\nfloat reflectance(float cosine, float ref_idx) {\n    float r0 = (1.-ref_idx)/(1.+ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1.-cosine), 5.);\n}\nbool material_scatter(material mat, inout ray r, hit_record rec, inout vec3 attenuation) {\n    if (mat.mat_type == DIFFUSE) {\n        vec3 scatter_direction = rec.normal + random_in_unit_sphere(g_seed);\n        if (near_zero(scatter_direction)) {\n            scatter_direction = rec.normal;\n        }\n        r = ray(rec.p, scatter_direction);\n        attenuation *= mat.albedo;\n        return true;\n    }\n    else if (mat.mat_type == METAL) {\n        vec3 reflected = reflect(normalize(r.direction), rec.normal);\n        r = ray(rec.p, reflected + mat.mat_dependent * random_in_unit_sphere(g_seed));\n        attenuation *= mat.albedo;\n        return (dot(r.direction, rec.normal) > 0.);\n    }\n    else if (mat.mat_type == DIELECTRIC) {\n        //vec3 attenuation = vec3(1., 1., 1.);\n        float refraction_ratio = rec.front_face ? (1. / mat.mat_dependent) : mat.mat_dependent;\n        vec3 unit_direction = normalize(r.direction);\n        float cos_theta = min(dot(-unit_direction, rec.normal), 1.);\n        float sin_theta = sqrt(1. - cos_theta * cos_theta);\n        bool cannot_refract = refraction_ratio * sin_theta > 1.;\n        vec3 direction;\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > rand1(g_seed)) {\n            direction = reflect(unit_direction, rec.normal);\n        }\n        else {\n            direction = refract(unit_direction, rec.normal, refraction_ratio);\n        }\n        r = ray(rec.p, direction);\n        attenuation *= mat.albedo;\n        return true;\n    }\n}\n// determines whether the ray intersected the inside our outside of sphere and sets normal accordingly\nvoid set_face_normal(ray r, vec3 outward_normal, out hit_record rec)\n{\n    rec.front_face = dot(r.direction, outward_normal) < 0.;\n    rec.normal = rec.front_face ? outward_normal :-outward_normal;\n}\n// calculates whether we've hit a sphere by solving a quadratic equation\nbool hit_sphere(vec3 center, float radius, ray r, float min_t, float max_t, out hit_record rec) {\n    vec3 originToCenter = r.origin - center;\n    float distanceSquared = length(r.direction) * length(r.direction);\n    float dotProduct = dot(originToCenter, r.direction);\n    float d2Minusr2 = length(originToCenter) * length(originToCenter) - radius * radius;\n    float discriminant = dotProduct * dotProduct - distanceSquared * d2Minusr2;\n    // if no real solution, return false as we didn't intersect a sphere\n    if (discriminant < 0.) {\n        return false;\n    }\n    float sqrtDiscriminant = sqrt(discriminant);\n    float root = (-dotProduct - sqrtDiscriminant) / distanceSquared;\n    // if the first root we find (-b - sqrt(discriminant)) is beyond our bounds\n    if (root < min_t || root > max_t) {\n        // check the second root (-b + sqrt(discriminant))\n        root = (-dotProduct + sqrtDiscriminant) / distanceSquared;\n        // if the second root is beyond our bounds, there is no real solution (no intersection)\n        if (root < min_t || root > max_t) {\n            return false;\n        }\n    }\n    // update the components of the record_hit struct\n    rec.t = root;\n    rec.p = rayAt(r, rec.t);\n    vec3 outward_normal = (rec.p - center) / radius;\n    set_face_normal(r, outward_normal, rec);\n    return true;\n}\nvec3 ray_color(ray r, int depth, sphere[NUM_SPHERES] spheres) {\n    // define a minimum and maximum possible value for the root calculated in the intersection\n    float t_min = 0.001;\n    float t_max = 10000.;\n    ray currRay = r;\n    vec3 attenuation = vec3(1.);\n    vec3 diffuse = vec3(0., 0., 0.);\n    for (int diffuseRay=0; diffuseRay<depth; diffuseRay++) {\n        // calculate the intersection of the ray and each sphere\n        for (int i=0; i < NUM_SPHERES; i++) {\n            bool hit = hit_sphere(spheres[i].center, spheres[i].radius, currRay, t_min, t_max, spheres[i].rec);\n            spheres[i].hit = hit;\n        }\n        bool hitSphere = false;\n        // if the ray intersected, assign a color to visualize the normal of the sphere at that intersection\n        for (int i=0; i<NUM_SPHERES; i++) {\n            if (spheres[i].hit && !hitSphere) {\n                material_scatter(spheres[i].mat, currRay, spheres[i].rec, attenuation);\n                hitSphere = true;\n            }\n        }\n        if (!hitSphere) {\n            vec3 unit_direction = normalize(r.direction);\n            float t = 0.5 * (unit_direction.y + 1.);\n            diffuse = (1. - t) * vec3(0., 0., 0.) + t * vec3(0.2, 0.2, 0.2);\n            //diffuse = vec3(0., 0., 0.);\n            break;\n        }\n    }\n    return attenuation * diffuse;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    material matr1 = material(vec3(0.1, 0.3, 0.5), DIFFUSE, 0.);\n    material matr2 = material(vec3(0.5, 0.2, 0.), METAL, 0.);\n    material matr3 = material(vec3(1., 1., 1.), DIELECTRIC, 1.2);\n    material matr33 = material(vec3(1., 1., 1.), DIELECTRIC, 1.2);\n    material matr4 = material(vec3(1000., 1000., 1000.), DIFFUSE, 0.);\n    // define the small sphere and the big sphere that acts as the ground in the image\n    sphere sphere1 = sphere(vec3(0., 0., -1.), 0.5, hit_record(vec3(0.), vec3(0.), 0., true), false, matr1);\n    sphere sphere3 = sphere(vec3(-1., 0., -1.), 0.5, hit_record(vec3(0.), vec3(0.), 0., true), false, matr3);\n    sphere sphere2 = sphere(vec3(0., -100.5, -1.), 100., hit_record(vec3(0.), vec3(0.), 0., true), false, matr2);\n    sphere sphere33 = sphere(vec3(1., 0., -1.), 0.5, hit_record(vec3(0.), vec3(0.), 0., true), false, matr33);\n    //sphere sphere3point5 = sphere(vec3(-1., 0., -1.), -0.4, hit_record(vec3(0.), vec3(0.), 0., true), false, matr3);\n    sphere sphere4 = sphere(vec3(sin(iTime)*1.5, 1., cos(iTime)*1.5), 0.1, hit_record(vec3(0.), vec3(0.), 0., true), false, matr4);\n    sphere spheres[NUM_SPHERES] = sphere[NUM_SPHERES](sphere1, sphere3, sphere33, sphere4, sphere2);\n    // Image:\n    float aspect_ratio = iResolution.x / iResolution.y;\n    int samples_per_pixel = 50;\n    // Camera:\n    float focal_length = 1.;\n    float v_fov = 20.0;\n    float theta = radians(v_fov);\n    float h = tan(theta/2.);\n    float viewport_height = 2. * h;\n    float viewport_width = aspect_ratio * viewport_height;\n    vec3 eyepoint = vec3(5., 2., 10.);\n    vec3 lookat = vec3(0., 1.5, -1.);\n    vec3 vup = vec3(0., 1., 0.);\n    vec3 w = normalize(eyepoint - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n    float aperture = 0.;\n    float dist_to_focus = length(eyepoint-lookat);\n    float lens_radius = aperture / 2.;\n    vec3 origin = eyepoint;\n    vec3 horizontal = dist_to_focus * viewport_width * u;\n    vec3 vertical = dist_to_focus * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal/2. - vertical/2. - dist_to_focus * w;\n    camera cam = camera(eyepoint, lookat, vup, w, u, v, aspect_ratio, aperture, dist_to_focus,\n                        lens_radius, focal_length, origin, horizontal, vertical,\n                        lower_left_corner, v_fov, theta, h, viewport_height, viewport_width);\n    // Render:\n    vec3 pixel_color = vec3(0.,0.,0.);\n    init_rand(fragCoord, iTime);\n    for (int s=0; s<samples_per_pixel; s++) {\n        float newSeed = g_seed + float(s);\n        vec2 noise = rand2(newSeed);\n        float u = (fragCoord.x + noise.x) / (iResolution.x - 1.);\n        float v = (fragCoord.y + noise.y) / (iResolution.y - 1.);\n        ray r = get_camera_ray(u, v, cam);\n        vec3 color = ray_color(r, 100, spheres);\n        pixel_color += color;\n    }\n    // take average of all samples\n    pixel_color = pixel_color / float(samples_per_pixel);\n    // gamma correction\n    pixel_color = pow(pixel_color, vec3(1./2.2));\n    fragColor = vec4(pixel_color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Ray tracing in one weekend basecode for Dartmouth CS 77/177 \n// by Wojciech Jarosz, 2019\n\n#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 5\n#define DIFFUSE 20\n#define METAL 500\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n","name":"Common","description":"","type":"common"}]}