{"ver":"0.1","info":{"id":"dddyDj","date":"1695513951","viewed":107,"name":"Fork Midnight c tytr 424","username":"tytr","description":"Trippy cosmic river expansion","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","perlin","star","fog","moon","turbulence","city","river","mountain"],"hasliked":0,"parentid":"mstyzf","parentname":"Midnight city"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* PARAMETERS */\n\n// Moon and Glow\nfloat moon_radius = 0.02;\nfloat moon_glow_radius = 0.2;\nfloat glow_intense = 2.;\nvec3 moon_color = vec3(0.95, 0.95, 1.);\nvec3 glow_color = vec3(0.8, 0.3, 1.);\n\n// City\nfloat city_seed = .8;\nfloat city_height = 4.;\n\n// River\nfloat curve_strength = 1.;\nfloat curve_amount = 6.7;\nfloat distortion_amount = 50.;\nvec3 river_color = vec3(0., 0.25, 0.5);\n\n// Fog\nfloat fog_thickness = 0.75;\nvec3 fog_color = vec3(0., 0.5, 0.9);\n\n// Horizon\nfloat horizon_back = 2.0; // range from 2 - 5\nfloat horizon_front = 4.5; // range from 2 - 5\nfloat horizon_below = 3.2; // range from 1 - 4\nvec3 horizon_color = vec3(0.8, 0.5, 1.);\n\n// Mountain\nfloat mountain_height = 0.25;\n\n// Grass\nvec3 grass_color = vec3(0.3, 0.9, 0.4);\n\n/* END PARAMETERS */\n\n// SPAGHETTI\n\nconst float PI = 3.14159265359;\nconst float TAU = PI * 2.;\n\nvec2 rotate2d(vec2 uv, float angle)\n{\n    mat2 rot = mat2(cos(angle), -sin(angle),\n                   sin(angle), cos(angle));\n    uv -= 0.5;\n    uv = rot * uv;\n    uv += 0.5;\n    return uv;\n}\n\n// cheap anti-aliasing\nfloat fill(float sdf, float s)\n{\n    return smoothstep(s, s - 0.02, sdf);\n}\n\n\nfloat stroke(float sdf, float s, float w)\n{\n\treturn fill(sdf, s + w * 0.25) - fill(sdf, s - w * 0.25);\n\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// NOISE\nfloat N11(float x)\n{\n    return fract(sin(x) * 999.);\n}\n\nfloat N21(vec2 co) { \n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); \n}\n\nfloat smoothNoise(float x)\n{\n    float f = fract(x);\n    float i = floor(x);\n    \n    f = f * f * (3. - 2. * f);\n    return mix(N11(i), N11(i + 1.), f);\n}\n\n// value noise\nfloat vNoise(vec2 uv)\n    {\n    vec2 lv = fract(uv);\n    lv *=  lv * (3. - 2. * lv);\n    vec2 id = floor(uv);\n    float bl = N21(id);\n    float br = N21(id + vec2(1., 0.));\n    float bot = mix(bl, br, lv.x);\n    float tl = N21(id + vec2(0., 1.));\n    float tr = N21(id + vec2(1., 1.));\n    float top = mix(tl, tr, lv.x);\n    return mix(bot, top, lv.y);\n}\n\n#define OCTAVES 4\nfloat fbm(vec2 st)\n{\n    float lacunarity = 2.;\n    float gain = 0.5;\n    \n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * vNoise(st);\n        st *= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nfloat fbm1d(float x)\n{\n    float lacunarity = 2.;\n    float gain = 0.5;\n    \n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * smoothNoise(x);\n        x *= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n// Simplex Noise by Ian McEwan, Ashima Arts\nfloat sNoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat turbulence(vec2 st)\n{\n    float lacunarity = 2.;\n    float gain = 0.5;\n    \n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * abs(sNoise(st));\n        st *= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nfloat rectSDF(vec2 st, float tb, float lr)\n{\n    st = abs(st * 2. - 1.);\n    st.x -= lr;\n    st.y -= tb;\n    return max(st.x, st.y);\n}\n\n// SHAPE DRAWING\nfloat river(vec2 st)\n{\n    float sine = sin(st.y * TAU * curve_amount \n                + N11(floor(st.y * distortion_amount)));\n                \n    sine *= (st.y * curve_strength); // swing strength\n    sine += 1. - st.x; // adjust pos to middle\n    \n    // step value to make the river\n    float timeSin = cos(iTime + 11.0) * 2.6;\n    float timeMax = clamp(timeSin, 0.0, 1.8);\n    float o = stroke(sine, 0.5 , (1. - st.y - 0.55) * 2.75 + timeMax);\n    return clamp(o, 0., 1.);\n}\n\nfloat fog(vec2 st)\n{\n    float n = fbm(vec2(st.x - iTime * 0.015, st.y - iTime * 0.02) * 5.);\n\tn *= sin(st.y * 3.1416 + 1.85); // mask\n    return n;\n}\n\nfloat ray(vec2 st, float radius)\n{\n    // make radial noise\n    vec2 pc = st * 2. - 1.;\n    pc = vec2(atan(pc.x, pc.y), pow(length(pc) * 0.25, 15.5));\n    float r = vNoise(vec2(pc.x - iTime * 0.05, pc.y) * 12.);\n    \n    float cMask = 1. - length(st - 0.5) - radius;\n    cMask *= glow_intense;\n    r *= cMask;\n    \n    // radial noise that goes the other way\n    r += vNoise(vec2(pc.x + iTime * 0.1, pc.y) * 4.) * cMask;\n    r = clamp(r, 0., 1.);\n    return r;\n}\n\n// designed specially for midnight City\nfloat city(vec2 st, float off)\n{\n    float sine = sin(st.x * PI);\n\n    float n = N11(floor(st.x * 50. - off - city_seed));\n    n *= floor(sine * city_height) * 0.1 ; // city\n    n *= 1. - floor(abs(st.x - 0.5) * 70.) * 0.1; // castle\n    \n    // remove surrounding blocks\n    //n *= step(abs(st.x - 0.5), 0.5);\n    // lessen surrounding blocks\n    n *= floor(sine * 14.) * 0.1 * 0.5 + 0.35; \n    \n    //n = max(0., n); // make n >= 0.\n    n = abs(n);\n    \n    if (st.x > .7 || st.x < 0.3)\n    {\n        float diff = abs(st.x - 0.5);\n        n = n * diff * 10.0 * 0.2;\n    }\n    \n    \n    return n;\n}\n\n// MAIN SPAGHETTI\nvec3 midnightCity(vec2 st)\n{\n    float n = city(st, 0.);\n    \n    float halfMask = step(0.5, st.y);\n    vec2 moonPos = vec2(0.5, 0.2);\n    \n    float r = river(st);\n    r *= pow(st.y, .2); // gradient\n    \n    // distorted surface texture (or UV)\n    vec2 dst = vec2(0.);\n\tdst.y = vNoise(vec2(st.x , iTime * sin(st.y) ) * 30.) \n                        * (1. - halfMask);\n    dst.y = st.y + dst.y * pow(st.y, 1.25);\n    \n    // city reflection\n    float sine = sin(st.y * TAU * 68. +iTime * 3.);\n    float cityShadow = city(st, sine);\n    r *= step(cityShadow, abs(dst.y - 0.5)); \n    \n    float city = step(n, st.y - 0.5);\n    float cityMask = city;\n    float moon = length(vec2(st.x, abs(dst.y - 0.5)) - moonPos);\n    moon = smoothstep(moon_radius, moon_radius - 0.005, moon) * max(city , r);\n    \n    // glow\n    moon_glow_radius = 1. - moon_glow_radius;\n    float glow = distance(vec2(st.x, abs(dst.y - 0.5) ), moonPos);\n    glow = 1. - glow - moon_glow_radius;\n    glow *= glow_intense;\n    glow = clamp(glow * city - moon, 0., 1.);\n    \n    // ray of reflection in water\n    float ray = ray(vec2(st.x, abs(dst.y - 0.5) + 0.3), moon_glow_radius) * 2.;\n    ray *= 1. - halfMask;\n    ray = min(ray, r);\n    ray *= r;\n    \n    // moon += max(ray, moon);\n    \n    // horizon\n    float horizon = city * pow(1. - st.y + 0.5, exp(horizon_back));\n    horizon += pow(1. - st.y + 0.5, exp(horizon_front)) * halfMask; \n    horizon = clamp(horizon, 0., 1.);\t\n    horizon += pow(st.y + 0.5, exp(horizon_below)) * (1. - halfMask);\n\n    float fog = fog(vec2(st.x, abs(st.y - 0.5))) * fog_thickness;  \n    fog *= max(r, halfMask); \n    fog = clamp(fog, 0., 1.);\n    fog = max(horizon, fog) * (1. - moon);\n\n    float grass = turbulence(st * 2.5 + normalize(st - vec2(0.5, 0.5)) * 2.);\n    grass *= 1. - halfMask;\n    grass *= pow(st.y, 1.5);\n    grass *= 1.- ceil(r);\n    grass *= 1. - pow(sin(st.x * 3.1416) * 1. + 0., 3.);\n    \n    float star = N21(st);\n    star = smoothstep(0.01, 0., star);\n    star *= clamp(1. - fog * 3., 0., 1.);\n    star *= 1. - ceil(moon);\n    star *= max(r, halfMask);\n    // star *= step(n, max(st.y - 0.5, r)); // clear the stars in city\n    // star = clamp(star, 0., 1.);\n    \n    float mountain = fbm1d(st.x * 7.);\n    mountain *= 1. - st.y + 0.2;\n    mountain *= 1. - sin(st.x * PI) * 2.5;\n    mountain = 1. - step(mountain, st.y - mountain_height);\n    mountain *= halfMask * cityMask;\n    \n    star *= 1. - mountain;\n    \n    // mountain shading\n    mountain *= fbm(st * 15. + normalize(st - (vec2(0.5, 0.))) * 18.);\n    mountain *= (st.y - 0.5) * 1.5;\n    mountain *= 1. - abs(st.x - 0.5) * 1.; \n\n    // COLORING\n    \n    // Rainbow setting\n    float t = sin(iTime * 0.25) * 0.5 + 0.5;\n    vec3 hsb = hsb2rgb(vec3(t, 1., 1.));\n    hsb = vec3(0., 0.5, 1.);\n    \n    vec3 glowc = mix(vec3(0.), glow_color, glow + ray);\n    glowc = mix(glowc, moon_color, \n            moon + moon * (1. - halfMask) * 0.5); // lighten up the reflection\n            \n    vec3 grassc = grass_color * grass;\n    vec3 starc = vec3(N21(st * 2.1) * 2., 1., 1.) * star;\n    \n    vec3 fogc = mix(vec3(0.), fog_color, fog);\n    fogc = mix(fogc, horizon_color,  horizon);\n    \n    vec3 riverc = river_color * r;\n    \n    vec3 o = vec3( mountain);\n    // colorless version\n    // o += max(horizon, fog) + grass + moon + glow + ray + star + r * 0.25;\n    o += fogc + glowc + grassc + starc + riverc;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x += 0.5;\n\n    vec3 col = midnightCity(uv);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}