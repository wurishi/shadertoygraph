{"ver":"0.1","info":{"id":"l3jBWh","date":"1729412511","viewed":44,"name":"bulb3","username":"Wotan","description":"brdf wip, ray march mandelbulb","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst float PI = 3.14159265359;\nconst float EXPOSURE = 200.0;  // Exposure control for brightness\n\n// Material struct\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    float specular;\n};\n\n// Fresnel-Schlick function\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Mandelbulb distance estimator with mouse-driven evolution\nfloat mandelbulb(vec3 p, vec2 mouseOffset) {\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n\n    float exponent = 7.0 + mouseOffset.x * 5.0;\n    float phaseShift = mouseOffset.y * PI;\n\n    for (int i = 0; i < 7; i++) {\n        r = length(z);\n        if (r > 2.0) break;\n\n        float theta = acos(z.z / r) + phaseShift;\n        float phi = atan(z.y, z.x) + phaseShift;\n\n        dr = pow(r, exponent) * exponent * dr + 1.0;\n        float zr = pow(r, exponent);\n\n        theta = theta * exponent + iTime * 0.1;\n        phi = phi * exponent;\n\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// Normal estimation\nvec3 estimateNormal(vec3 pos, vec2 mouseOffset) {\n    float h = 0.001;\n    return normalize(vec3(\n        mandelbulb(pos + vec3(h, 0.0, 0.0), mouseOffset) - mandelbulb(pos - vec3(h, 0.0, 0.0), mouseOffset),\n        mandelbulb(pos + vec3(0.0, h, 0.0), mouseOffset) - mandelbulb(pos - vec3(0.0, h, 0.0), mouseOffset),\n        mandelbulb(pos + vec3(0.0, 0.0, h), mouseOffset) - mandelbulb(pos - vec3(0.0, 0.0, h), mouseOffset)\n    ));\n}\n\n// Ray marching function with early exit\nfloat rayMarch(vec3 ro, vec3 rd, vec2 mouseOffset) {\n    float totalDist = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 pos = ro + rd * totalDist;\n        float dist = mandelbulb(pos, mouseOffset);\n        totalDist += dist;\n        if (dist < 0.001 || totalDist > 50.0) break;\n    }\n    return totalDist;\n}\n\n// Shadow ray casting function\nfloat shadowRay(vec3 pos, vec3 lightDir, vec2 mouseOffset) {\n    float NdotL = dot(estimateNormal(pos, mouseOffset), lightDir);\n    if (NdotL <= 0.0) return 1.0; // No shadow if the surface is facing away from the light\n\n    float totalDist = 0.01;  // Start just above the surface\n    for (int i = 0; i < 32; i++) {\n        vec3 currentPos = pos + lightDir * totalDist;\n        float dist = mandelbulb(currentPos, mouseOffset);\n        totalDist += dist;\n\n        if (dist < 0.001) return 0.0;  // In shadow\n        if (totalDist > 50.0) break;   // Out of shadow range\n    }\n    return 1.0;  // Fully lit\n}\n\n\n// Tone mapping and exposure control\nvec3 applyExposure(vec3 color) {\n    return 1.0 - exp(-color * EXPOSURE);\n}\n\n// Cook-Torrance BRDF function\nvec3 cookTorranceBRDF(Material mat, vec3 normal, vec3 lightDir, vec3 viewDir) {\n    vec3 F0 = mix(vec3(0.04), mat.albedo, mat.metallic);\n\n    // Calculate the half-vector\n    vec3 H = normalize(lightDir + viewDir);\n\n    float NdotV = max(dot(normal, viewDir), 0.0);\n    float NdotL = max(dot(normal, lightDir), 0.0);\n    float NdotH = max(dot(normal, H), 0.0);\n    float VdotH = max(dot(viewDir, H), 0.0);\n\n    vec3 fresnel = fresnelSchlick(VdotH, F0);\n\n    float alpha = mat.roughness * mat.roughness;\n    float alpha2 = alpha * alpha;\n    float denom = NdotH * NdotH * (alpha2 - 1.0) + 1.0;\n    float NDF = alpha2 / (PI * denom * denom);\n\n    float k = (alpha + 1.0) * (alpha + 1.0) / 8.0;\n    float G_V = NdotV / (NdotV * (1.0 - k) + k);\n    float G_L = NdotL / (NdotL * (1.0 - k) + k);\n    float G = G_V * G_L;\n\n    vec3 numerator = NDF * G * fresnel;\n    float denominator = 4.0 * NdotV * NdotL + 0.001;\n    vec3 specular = numerator / denominator;\n\n    vec3 kD = vec3(1.0) - fresnel;\n    vec3 diffuse = kD * mat.albedo / PI;\n\n    return diffuse + specular;\n}\n\n\n// Cubemap lookup using the surface normal\nvec3 sampleCubemap(vec3 normal) {\n    return texture(iChannel0, normal).rgb;\n}\n\n// Lighting function with shadowing\nvec3 lighting(Material mat, vec3 pos, vec3 normal, vec3 viewDir, vec2 mouseOffset) {\n    vec3 lightPos = vec3(10.0, 10.0, 10.0);\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 lightColor = vec3(4.0);\n\n    float NdotL = dot(normal, lightDir);\n\n    // Check if the surface is facing the light\n    if (NdotL <= 0.0) {\n        // Only ambient lighting\n        vec3 ambient = sampleCubemap(normal) * 0.1;\n        return ambient;\n    }\n\n    float shadow = shadowRay(pos + normal * 0.01, lightDir, mouseOffset);\n\n    NdotL = max(NdotL, 0.0);\n    vec3 radiance = lightColor * NdotL / (length(lightPos - pos) * length(lightPos - pos));\n    vec3 brdfColor = cookTorranceBRDF(mat, normal, lightDir, viewDir);\n\n    // Ambient lighting from the cubemap\n    vec3 ambient = sampleCubemap(normal) * 0.1;  // Adjust ambient intensity\n\n    return applyExposure(radiance * brdfColor * shadow) + ambient;\n}\n\n\n// Render function\nvec3 render(vec3 ro, vec3 rd, vec2 mouseOffset) {\n    float totalDist = rayMarch(ro, rd, mouseOffset);\n    if (totalDist > 50.0) return vec3(0.0);\n\n    vec3 pos = ro + rd * totalDist;\n    vec3 normal = estimateNormal(pos, mouseOffset);\n    vec3 viewDir = normalize(-rd);\n\n    Material ceramic;\n    ceramic.albedo = vec3(0.4, 0.6, 1.0);\n    ceramic.metallic = 0.0;\n    ceramic.roughness = 0.5;\n    ceramic.specular =0.8;\n\n    return lighting(ceramic, pos, normal, viewDir, mouseOffset);\n}\n\n// Draw light indicator\nvoid drawLightIndicator(inout vec4 fragColor, vec2 fragCoord, vec3 lightPos, vec3 cameraPos) {\n    vec3 lightDir = normalize(lightPos - cameraPos);\n    vec3 forward = normalize(-cameraPos);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 lightScreenPos = vec2(dot(lightDir, right), dot(lightDir, up));\n    float distToLight = length(uv - lightScreenPos);\n\n    if (distToLight < 0.02) {\n        fragColor = vec4(1.0);\n    }\n}\n\n// Main entry point\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 0.55;\n\n    float angle = iTime * 0.2;\n    vec3 ro = vec3(3.0 * sin(angle), 1.5, 3.0 * cos(angle)) ;\n    vec3 target = vec3(0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    vec2 mouseOffset = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n\n    vec3 color = render(ro, rd, mouseOffset);\n    fragColor = vec4(color, 1.0);\n\n    drawLightIndicator(fragColor, fragCoord, vec3(10.0, 10.0, 10.0), ro);\n}\n","name":"Image","description":"","type":"image"}]}