{"ver":"0.1","info":{"id":"4lKSRm","date":"1483601872","viewed":99,"name":"GR - A Rotating Line","username":"bradleygriffith","description":"angle line","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["line","angle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nfloat whenEq(float x, float y) {\n  return 1.0 - abs(sign(x - y));\n}\n\nfloat whenNeq(float x, float y) {\n  return abs(sign(x - y));\n}\n\nfloat whenGt(float x, float y) {\n  return max(sign(x - y), 0.0);\n}\n\nfloat whenLt(float x, float y) {\n  return max(sign(y - x), 0.0);\n}\n\n// Useful for adjusting x or y distances in accordance with screen ratio.\nvec2 stepAdjustment () {\n    vec2 adjustment = vec2(1.0);\n\n    adjustment.x -= (1.0 - iResolution.y / iResolution.x) * whenGt(iResolution.y, iResolution.x);\n    adjustment.y -= (1.0 - iResolution.x / iResolution.y) * whenGt(iResolution.x, iResolution.y);\n   \n\treturn adjustment;\n}\n\n// Slope from degrees, adjusted for screen ratio.\nfloat normalizedSlopeForDegrees(float deg) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n    \n    // Ensure degrees stay withing 0.0 - 360.0\n    deg = mod(deg, 360.0);\n    \n    float radians = deg * (PI / 180.0);\n    float slope = tan(radians);\n\n    return ((slope * 100.0) / p.x) / (100.0 / p.y);\n}\n\n// Given x, a slope, and another point, find y for x.\nfloat yForXOnSlope(float x, float slope, vec2 p2) {\n\treturn -1.0 * ((slope * (p2.x - x)) - p2.y);\n}\n\n// Given y, a slope, and another point, find x for y.\nfloat xForYOnSlope(float y, float slope, vec2 p2) {\n    return ((y - p2.y) + (slope * p2.x)) / slope;\n}\n\nvec2 offsetsForUvAtDistanceOnSlope(float d, float slope) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n    float slopeAdjustment = 0.0;\n\n    slopeAdjustment += (iResolution.y / iResolution.x) * whenGt(iResolution.y, iResolution.x);\n    slopeAdjustment += (iResolution.x / iResolution.y) * whenGt(iResolution.x, iResolution.y);\n    \n\treturn vec2(\n        ((d * p.x) * cos(atan(slope / slopeAdjustment))),\n        ((d * p.y) * sin(atan(slope / slopeAdjustment)))\n    );\n}\n\n\n/*\n1. Cut width in half.\n2. Find perpendicular angle from line angle (and its 180 degree oposite)\n3. Using the two angles and the half width, find two points at half width \n   distance from center point. These are the edges of our line at the given \n   point.\n4. Taking the above two points, we then ask for the Y value for our UVâ€™s X, \n   on a line with the given slope (taken from original degrees) that cuts \n   through the center point of offset A or B.\n5. The result of `length(step(uvB, uv) - step(uvA, uv))` from UV to the point \n   determined in step 4, determines if the UV is or is not within the concept \n   of this line.\n*/\nfloat isLine(vec2 uv, vec2 centerUv, float deg, float width) {\n    float intersectDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0\n    float halfWidth = width / 2.0;\n    \n    float angleA = intersectDeg;\n    float angleB = mod(intersectDeg + 180.0, 360.0); // Offset angle by 180.0, but keep it from exceeding 360.0\n    \n    float slopeA = normalizedSlopeForDegrees(angleA);\n    float slopeB = normalizedSlopeForDegrees(angleB);\n    \n    vec2 kA = offsetsForUvAtDistanceOnSlope(halfWidth, slopeA);\n    vec2 kB = offsetsForUvAtDistanceOnSlope(halfWidth, slopeB);\n    \n    vec2 posA = centerUv;\n    vec2 posB = centerUv;\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        posA += kA;\n    }\n    else {\n        posA -= kA;\n    }\n    \n   \tif (angleB <= 90.0 || angleB >= 270.0) {\n\t\tposB += kB;\n    }\n    else {\n    \tposB -= kB;\n    }\n    \n    \n    float slope = normalizedSlopeForDegrees(deg);\n    vec2 uvA = vec2(uv.x, yForXOnSlope(uv.x, slope, posA));\n    vec2 uvB = vec2(uv.x, yForXOnSlope(uv.x, slope, posB));\n    \n    return length(step(uvB, uv) - step(uvA, uv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 stepAdjustment = stepAdjustment();\n    \n    vec2 position = vec2(0.5);\n    float deg = 0.0;\n    if (iMouse.z > 0.0) {\n        position = iMouse.xy / iResolution.xy;\n        deg = position.x * 360.0;\n    }\n    \n    float width = 50.0;\n\tfloat speed = 0.25;\n    \n    // Prepare Line -------------------------------\n\n\t//deg = fract(iTime * speed) * 360.0;\n    float line = isLine(uv, position, deg, width);\n    \n    fragColor = 1.0 - vec4(line);\n}","name":"Image","description":"","type":"image"}]}