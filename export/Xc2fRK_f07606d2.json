{"ver":"0.1","info":{"id":"Xc2fRK","date":"1725205559","viewed":21,"name":"Rainbow Strobe","username":"SirShart","description":"Random illusion","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n// 3D Noise function\nfloat noise3(vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);  // Smooth interpolation\n\n    #define hash3(p)  fract(sin(1e3 * dot(p, vec3(1, 57, -13.7))) * 4375.5453)\n    \n    return mix( \n        mix(mix(hash3(p + vec3(0, 0, 0)), hash3(p + vec3(1, 0, 0)), f.x),\n            mix(hash3(p + vec3(0, 1, 0)), hash3(p + vec3(1, 1, 0)), f.x), f.y),\n        mix(mix(hash3(p + vec3(0, 0, 1)), hash3(p + vec3(1, 0, 1)), f.x),\n            mix(hash3(p + vec3(0, 1, 1)), hash3(p + vec3(1, 1, 1)), f.x), f.y), f.z);\n}\n\n// Pseudo-Perlin noise function\n#define noise(x) (noise3(x) + noise3(x + 11.5)) / 2.0\n\n// Function to generate neon chimerical colors\nvec3 chimericalColor(float t, float offset) {\n    float r = 0.5 + 0.5 * sin(3.0 * t + offset);\n    float g = 0.5 + 0.5 * sin(3.0 * t + offset + 2.0);\n    float b = 0.5 + 0.5 * sin(3.0 * t + offset + 4.0);\n    return vec3(r, g, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord / R;\n    vec2 center = R * 0.5;\n\n    float t = iTime;\n    float dist = length(fragCoord - center);  // Distance from the center\n\n    // Generate noise based on position and time\n    float n = noise(vec3(fragCoord * 8.0 / R.y, 0.1 * iTime));\n\n    // Create a pulsating effect with the noise and distance\n    float v = sin(2.0 * PI * 10.0 * n - 5.0 * dist + t * 5.0);\n\n    // Smoothstep to define the edges, modulated by distance to create ripple effect\n    float edge = smoothstep(0.5, 0.0, abs(v));\n\n    // Dynamic neon chimerical colors with an offset based on distance\n    vec3 neonColor = chimericalColor(t, dist * 0.1);\n\n    // Final color with neon effect\n    vec3 finalColor = neonColor * edge;\n\n    // Output the final fragment color\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}