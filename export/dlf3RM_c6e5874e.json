{"ver":"0.1","info":{"id":"dlf3RM","date":"1671490078","viewed":71,"name":"shiny ray-traced sphere","username":"ianertson","description":"shiny sphere","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere","shiny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool sphere(\nin Ray ray,\nin Light light,\nvec3 position,\nfloat radius,\ninout vec3 color\n) {\n  if (!intersectRaySphere(\n        ray,\n        position,\n        radius\n   )) return false;\n   \n   vec3 albedo = texture(iChannel1, ray.result.uv).rgb;\n   float roughness = 0.009;\n   vec3 f0 = vec3(0.04);\n   \n   \n   \n   vec3 viewdir = normalize(ray.orig - ray.result.point);\n     vec3 reflection_dir = reflect(viewdir, ray.result.normal) * -1.0;\n   float NdotV = abs(dot(ray.result.normal, viewdir)) + 0.000001;\n   vec3 amb = texture(iChannel0, normalize(reflection_dir)).rgb;\n   vec3 envBRDF = EnvBRDFApprox(vec3(0.01), pow(roughness, 2.0), NdotV);\n   vec3 F = fresnelSchlickRoughness(NdotV, f0, roughness);\n   vec3 indirectSpecular = amb * (F * envBRDF.x + envBRDF.y);\n   \n   vec3 L = normalize(ray.result.point - light.pos);\n   float NdotL = max(dot(ray.result.normal, L), 0.0);\n   \n   vec3 specDir = reflect(L, ray.result.normal);\n   float VdotR = max(dot(viewdir, specDir), 0.0);\n\n   float specFres = pow(VdotR, 32.0) * 0.5;\n\n\n   \n   float dist = abs(distance(ray.result.point, light.pos));\n   \n   float att = pow(light.strength, 2.0) / max(0.0001, pow(dist, 2.0));\n   \n   \n   vec3 refl = indirectSpecular;\n   \n   refl += (albedo / M_PI + specFres) * light.color * NdotL * att;\n   \n   \n   color = refl * M_PI;\n   \n   return true;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   Ray ray;\n\n   vec3 lookDir = vec3(0, 0, 1) + (normalize(vec3(cos(iTime*0.4), sin(iTime*0.5)*0.9, sin(iTime))) * 0.07);\n   float fov = 60.0;\n   float near = 0.01;\n   float far = 400.0;\n\n   getPrimaryRay(\n        fragCoord.xy,\n        vec2(iResolution.xy),\n        lookDir,\n        fov,\n        near,\n        far,\n        ray\n   );\n  \n   Light light;\n   light.strength = 24.0;\n   light.color = mix(vec3(0.5, 0.3, 0.7), vec3(0.7, 0.4, 0.5), 0.5 + (0.5*cos(iTime)));\n   light.pos = vec3(5.0, 5.0, 0.5) * 3.14;\n  \n   vec3 spherePos = vec3(0.0, 0.0, 5.0);\n   spherePos += vec3(sin(iTime*0.5), cos(iTime*0.9)*0.9, 0.0)*0.5;\n  \n   vec3 color = vec3(0.0);\n   if (!sphere(ray, light, spherePos, 1.0, color)) {\n       color = texture(iChannel0, normalize(ray.dir)).rgb;\n   }\n   \n   //color = pow(color, vec3(1.6));\n \n   //color = fromLinear(color);\n \n   color = aces(color);\n   color = pow(color, vec3(1.0 / 1.9));\n \n   \n   fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\nstruct RayResult {\n    vec3 point;\n    vec3 normal;\n    float dist;\n    vec2 uv;\n};\n\nstruct Ray {\n    vec3 dir;\n    vec3 orig;\n    RayResult result;\n};\n\nstruct Light {\n    vec3 pos;\n    float strength;\n    vec3 color;\n};\n\n\nmat4 proj(float fovy,\n                      float aspect,\n                      float nearZ,\n                      float farZ) {\n                      \n   \n  mat4 dest = mat4(0.0);\n  float f  = 1.0f / tan(fovy * 0.5f);\n  float fn = 1.0f / (nearZ - farZ);\n\n  dest[0][0] = f / aspect;\n  dest[1][1] = f;\n  dest[2][2] =-farZ * fn;\n  dest[2][3] = 1.0f;\n  dest[3][2] = nearZ * farZ * fn;\n  return dest;\n    \n}\n\nmat4 look(vec3 eye, vec3 center, vec3 up) {\nmat4 dest = mat4(0.0);\n  vec3 f = vec3(0.0); vec3 u = vec3(0.0); vec3 s = vec3(0.0);\n\n  f = normalize(center - eye);\n\ns = cross(up, f);\n  u = cross(f, s);\n\n  dest[0][0] = s[0];\n  dest[0][1] = u[0];\n  dest[0][2] = f[0];\n  dest[1][0] = s[1];\n  dest[1][1] = u[1];\n  dest[1][2] = f[1];\n  dest[2][0] = s[2];\n  dest[2][1] = u[2];\n  dest[2][2] = f[2];\n  dest[3][0] =-dot(s, eye);\n  dest[3][1] =-dot(u, eye);\n  dest[3][2] =-dot(f, eye);\n  dest[0][3] = dest[1][3] = dest[2][3] = 0.0f;\n  dest[3][3] = 1.0f;\n  \n  return dest;\n}\n\n\nvoid getPrimaryRay(\nvec2 coord,\nvec2 res,\nvec3 lookDir,\nfloat fov,\nfloat near,\nfloat far,\ninout Ray ray\n) {\n    float x = coord.x;\n    float y = coord.y;\n    float w = res.x;\n    float h = res.y;\n    \n    float aspect = w / h;\n\n    vec3 origin = vec3(0.0, 0.0, 1.0);\n   \n    mat4 projection = proj(radians(fov), aspect, near, far);\n    mat4 view = look(lookDir, vec3(0.0), vec3(0, 1, 0));\n    mat4 iprojection = inverse(projection * view);\n    \n    float ray_x = ((x - w / 2.0)) / w;\n    float ray_y = ((y - h / 2.0)) / h;\n    \n    vec2 pos = vec2(ray_x, ray_y);\n    \n    ray.orig = origin;\n    vec4 dir = vec4(pos/0.5, 1.0, 1.0);\n    dir = iprojection * dir;\n    \n    ray.dir = dir.xyz;\n\n\n}\n\nvec2 sphereUV(vec3 point, vec3 position, float radius) {\n    \n    vec3 p = point - position;\n    float theta = atan(p.x-radius/2.0, p.z-radius/2.0);\n    float phi = acos(p.y / radius);\n    float raw_u = theta / (2.0 * M_PI);\n    \n    float u = 1.0 - (raw_u + 0.5);\n    float v =  1.0 - (phi / M_PI);\n    \n    return vec2(u, v);\n}\n\nbool intersectRaySphere(\ninout Ray ray,\nvec3 sphereCenter,\nfloat sphereRadius\n) {\n    vec3 rayOrigin = ray.orig;\n    vec3 rayDirection = ray.dir;\n    vec3 rayOriginToSphereCenter = rayOrigin - sphereCenter;\n\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayOriginToSphereCenter);\n    float c = dot(rayOriginToSphereCenter, rayOriginToSphereCenter) - sphereRadius * sphereRadius;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        ray.result.point = vec3(0.0);\n        ray.result.normal = vec3(0.0);\n        ray.result.uv = sphereUV(ray.result.point, sphereCenter, sphereRadius);\n\n        return false;\n    }\n\n    if (discriminant == 0.0) {\n        float t = -0.5 * b / a;\n        ray.result.point = rayOrigin + t * rayDirection;\n        ray.result.normal = normalize(ray.result.point - sphereCenter);\n        ray.result.uv = sphereUV(ray.result.point, sphereCenter, sphereRadius);\n\n        return true;\n    }\n\n    if (discriminant > 0.0) {\n        float t1 = (-0.5 * b - sqrt(discriminant)) / a;\n        float t2 = (-0.5 * b + sqrt(discriminant)) / a;\n        float t = min(t1, t2);\n        ray.result.point = rayOrigin + t * rayDirection;\n        ray.result.normal = normalize(ray.result.point - sphereCenter);\n        ray.result.uv = sphereUV(ray.result.point, sphereCenter, sphereRadius);\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 unreal(vec3 x) {\n  return x / (x + 0.155) * 1.019;\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 gammaCorrect(vec3 color, float gamma) {\n  return pow(color, vec3(1.0 / gamma));\n}\n\nvec3 toLinear(vec3 sRGB)\n{\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB/vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec3 fromLinear(vec3 linearRGB)\n{\n    bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n    vec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n    vec3 lower = linearRGB * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n","name":"Common","description":"","type":"common"}]}