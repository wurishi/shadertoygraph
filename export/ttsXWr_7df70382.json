{"ver":"0.1","info":{"id":"ttsXWr","date":"1562621647","viewed":558,"name":"[twitch] Hanging Plants","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/HangingPlants.glsl","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/HangingPlants.glsl\n*/\n\nfloat time=0.0;\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat mat=0.0;\nfloat at=0.0;\nfloat map(vec3 p) {\n  \n  vec3 bp2 = p;\n  \n  float tt = time*0.5;\n  p.xz += sin(p.zx*vec2(0.1,0.07)+tt*1.3)*2.0;\n  //p.y += sin(p.x*0.1+tt)*5 + sin(p.y*0.25+tt)*3;\n  \n  p.y+=100.0;\n  float t2=sin(time*0.3 + p.y*0.005)*0.5;\n  p.yz *= rot(t2*0.5);\n  p.xy *= rot(t2);\n  p.y-=100.0;\n  \n  float s=32.0;\n  for(float i=0.0; i<5.0; ++i) {\n    p.xz*=rot(0.3+i);\n    p.xz+=s;\n    p.xz=abs(p.xz);\n    p.xz-=s;\n    s*=0.6;\n  }\n  \n  float zone = 30.0;\n  p.xz = (fract(p.xz/zone-.5)-.5)*zone;\n  \n  vec3 bp=p;\n  \n  float d = 10000.0;\n  float prevd = length(p.xz)-1.0;\n  float off=p.y;\n  \n  float dist=4.0;\n  p.y = (fract(p.y/dist-.5)-.5)*dist;\n  p.y=abs(p.y);\n  p.y=smin(p.y,-p.y,-1.0);\n  p.y=dist*0.5-smin(dist*0.5-p.y,-(dist*0.5-p.y),-1.0);\n  \n  p.y-=dist*0.25;\n  \n  for(float i=0.0; i<7.0; i++) {\n    float t=time*0.2+i + off*0.1+22.7;\n    p.xy *= rot(t);\n    p.yz *= rot(t-1.2);\n    d = smin(d, length(p-vec3(0,1.3,0))-1.0, 0.3);\n  }\n  \n  \n    \n  at += 0.2/(0.2+abs(d));\n  \n  mat=clamp((d-prevd+0.1)/0.3,0.0,1.0);\n  d = smin(d, prevd, 0.3);\n  \n  d = smin(d, bp.y-sin(bp.x*0.02)*10.0-sin(bp.z*0.034)*8.0, -2.0);\n    \n  d *= 0.7;\n    \n  return d;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(-0.5);\n  p.xz *= rot(time*0.2);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  // this fixes glitches when time is too high, but cause a cam cut every two minutes\n  time = mod(iTime, 120.0);\n\n  vec3 s=vec3(5,0,-40);\n  vec3 r=normalize(vec3(-uv, 1.0));\n  \n  cam(s);\n  cam(r);\n  \n  float maxdist = 300.0;\n  \n  vec3 p=s;\n  float dd=0.0;\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(abs(d)<0.001) {\n      break;\n    }\n    if(dd>maxdist) {dd=maxdist; break;}\n    p+=d*r;\n    dd+=d;\n  }\n  \n  float curmat = mat;\n  float curat = at;\n  \n  vec3 col=vec3(0);\n  \n  vec2 off=vec2(0.05,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l= normalize(-vec3(1,3,2));\n  vec3 h=normalize(l-r);\n  float fog = pow(1.0-clamp(dd/maxdist,0.0,1.0), 1.0);\n  float fre=pow(1.0-abs(dot(n,r)),2.0);\n  \n  float sss=smoothstep(0.0,1.0,map(p+l*10.0)/10.0)+smoothstep(0.0,1.0,map(p+l*5.0)/5.0)+smoothstep(0.0,1.0,map(p+l*1.0));\n  float spec = max(0.0, dot(n,h));\n  \n  vec3 sky = mix(vec3(1,0.3,0.2), vec3(1.0,0.6,1.0)*2.0, pow(abs(r.y),2.0) * pow(1.0-fog,1.0));\n  \n  col += (dot(n, l)*0.5+0.5) * fog * (vec3(0.2,0.6,0.3)*0.5) * curmat;\n  col += max(dot(n, l),0.0) * fog * (pow(spec,10.0)*2.0);\n  col += sky*sss*fog * 1.0 * (1.0-curmat) * 0.5;\n  \n  col += pow((1.0-fog)*1.7, 3.0) * sky;\n  col += sky*fre*fog;\n    \n  col += pow(curat * 0.05,0.8) * sky;\n  \n  col *= 1.2-length(uv);\n  \n  col = 1.0-exp(-col*2.0);\n  col = pow(col, vec3(1.5));\n  \n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}