{"ver":"0.1","info":{"id":"lldfR4","date":"1538865099","viewed":137,"name":"v0+mgr0","username":"teraspora","description":".","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["multiple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// v0+mgr0 - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Date: 06 OCT 2018.\n\n// Just combining voronoigo x8 with merry-go-round in the middle\n// -----------------------------------------------------------------------------\n\n// Copyright Â© 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// -----------------------------------------------------------------------------\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\nconst float HALF_PI = 1.5707963267948966;\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.3  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\n// float dot(vec2 u, vec2 v) {\n// \treturn u.x * v.x + u.y * v.y;\n// }\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n// =======================================\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\nvec2 psrandv2(float seed, int i) {\n    vec2 a;\n    a.x = cos(fract(cos(seed * 458333.003736561)) * (319.50207 + 10352.9911 * float(i)));\n\ta.y = sin(cos(fract(sin(seed * 4032.9908442016)) * (2786.2227 + 7046.88813 * float(i))));\n\ta.x *= fract(100000. * fract(dot(a, a.yx + vec2(26332.16598469, 7004.8112))));\n    a.y *= fract(1000. * fract(dot(rotate(a, float(i) * 69.4177), a.yx + vec2(91104.33554432, 8112.7004))));\n    return a * 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance; order = 1\n    if (order <= 0.) return 0.;\t\t\t\t// => Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\n\nfloat mtime(float period) {\n\treturn mod(iTime, period) / period;\n}\n\n\n\n// ..........................................................\n\nfloat f(float x, float tile) {\n    float t = iTime * 0.01;\n    return exp(cos(15. * mtime(182.) * x) / 4. + cos(11. * mtime(113.) * x) * 1.2);       \n}\n\nfloat g(float x, float tile) {\n \tfloat t = iTime * 0.01;\n    return log(sin(3. * mtime(193.) * x) * 69. + cos(119. * mtime(252.) * x) / 12. + sin(7. * x) / 17.);       \n}\n\n\n// MAIN METHOD:\n\nvec3 doStuff(vec2 pixel, vec2 res) {\n    // just takes a pixel and a context and outputs a\n    // colour to mainImage, which keeps things organised\n    // and encapsulated.\n    \n    \n    // Set this var to the number of tiles across and down:\n    float tileDim = 3.;\n    float numTiles = tileDim * tileDim;\n        \n    // the output vector, before normalisation,\n    // giving the position the program needs to know!-\n    vec2 pp = pixel;\n    vec2 hr = res / tileDim;\t// resolution of one tile\n    vec3 col = magenta;\n    \n    // ===============================================================\n    \n    // Normalisation and tiling:\n    // ========================\n    \n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(pixel.x / res.x * tileDim)), float(int(pixel.y / res.y * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.; \n    // start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // Offset the start of each rendition:\n    float time = tile * 32. + iTime;\n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, then shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     \n    // then scale:\n    float scaleFactor = 1.0;\n    // q /= scaleFactor;\n       \n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Main code for the shader goes here:\n    // ===============================================================================================\n    \n    if (tile != 4.) {\n    // q *= 2.; \n    q = rotate(q, toe * (iTime * 0.02 * (numTiles - tile - 1.) + (tile - 1.) * 0.25 * PI));\t// vary angle for each tile\n    \n    float inc = 0.003;\n    vec2[4] k = vec2[](vec2(-1., -1.), vec2(-1., 1.), vec2(1., -1.), vec2(1., 1.));\n    \n    float order = 1.;\t// minkowski order (1 = Euclidean, 2 = Manhattan)\n    \n    \n    //Initialise points[] array:\n    \n    // int numPoints = 6 + int(mod(iTime * 0.125, 128.));\n    int numPoints = 8 + int(128. * sin (iTime / 512.));\n    \n    vec2 points[140];\n    \n    float sa = 313.95920007897932 * (numTiles - tile);\n    float sb = 25.2649677703343 * tile;\n    float rseed = fract(cos(fract(sin(sa + cos(fract(sa) * sb)))));\n    \n    for (int i = 0; i < numPoints; i++) {\n    \tpoints[i] = psrandv2(rseed, i) + k[int(mod(float(i), 4.))] * inc * mod(iTime, 128.) * 2.8;\n        float hue = float(i) / float(numPoints - 1);\n        col = hue2rgb(hue);\n    }\n    \n    // My algorithm to draw the edges:\n    // Iterate through the points and find the two nearest to q.\n    // Give our point a hue determined by the i0, index of the \n    // closest point.\n    // Then if the differences in the distances of q to each of\n    // these two points is less than some small threshold value, \n    // it's roughly equidistant from the two nearest points, so \n    // make q black, as it's on the border.\n    \n    // Note: old code commented out and left ror reference and possible later re-use\n    \n    float mind0 = 1.;   // set min distances high\n    float mind1 = 1.;  // 2nd smallest distance\n    int i0 = 144;\n    int i1 = 144;\n    for (int i = 0; i < numPoints; i++) {   // find two closest points\n        \n        // TEST:\n        float k = 0.01;\n        q += k * sin(iTime / 20.);\n        \n        float d = minkd(q, points[i], 1.);\n        if (d <= mind0) {\t\t// new closest pt.\n            mind1 = mind0;\n            mind0 = d;\n            i1 = i0;\n            i0 = i;\n        }\n        else if (d <= mind1) {\t// new next-closest pt.\n            mind1 = d;\n            i1 = i;\n        }        \n    }\n    \n    // float hue = float(toe < 0. ? i0 : (numPoints - 1 - i0)) / float(numPoints - 1);\n    // float hueInv = 1. - hue;\n    // col = hue2rgb(toe > 0. ? hue : hueInv);\n    // col.g *= 0.8;\n    \n    col = vec3(abs(mod(float(i0), 3.) - 1.));\n    // col = vec3(mod(float(i0), 3.) / 2., mod(float(i0), 5.) / 4., mod(float(i0), 7.) / 6.);\n    col.g *=  sqrt(mind1);\n    //col.b *= distance(q, points[i0]);\n    col.b *= length(q) * nsin(iTime / 3.);\n    \n    //col *= smoothstep(0.01, 0.02, abs(minkd(q, points[i0], order) - minkd(q, points[i1], order)));\n    col = toe > 0. ? col : col.bgr;\n    col.g *= 0.8;\n    // draw coloured dots:\n    float d = 0.005;\n    float m = mod(iTime, 32.) - 28.;\n    if (m > 0.) {\n        d *=2. * (m + tile / numTiles);\n        col *= step(0.5, 1. - col.g); // make white rings black\n    }\n    float s = iTime + 50. * length(q);\n    float c = float(cols.length());\n    if (col.r == 0. && mind0 < d) col = cols[int(mod(s, c))];\n    \n    // todo: convert above to step /smoothstep\n    col.g *= nsin(tile * tile);\n    }\n    // .................................\n    \n    \n    \n    \n    else {\n    \n    // .................................\n    // other code for centre tile:\n    \n    float t = iTime / 2048.;;\n    \n    // first scale:\n    float scaleFactor = 15.0;\n    float yscale = 0.2;\n    q *= scaleFactor;\n    q.y *= yscale;\n    t = t * 128.;\n    q.y *= hr.x /hr.y;\n    q.x *= 0.35;\n    q = abs(q);\n    q = rotate(q, t * 6.);\n    float phi = abs(arg(q));\n    q = polar(length(q), mod(phi, PI / 16.)); \n    \n    vec2 s0 = vec2(q.x - t, q.y);\n    vec2 s1 = vec2(q.x + 2. * t, q.y);\n    float k = 1.;\n    float delta = 0.4;\n    float yd0 = s0.y + delta;\n    float yd1 = s1.y + delta;\n    \n    float rc = f(s0.x, k) * q.x;\n    float bc = g(s1.x, k) * q.x;\n        \n    float hue = (smoothstep(s0.y, yd0, rc) - smoothstep(yd0, yd0 + delta, rc))\n     + (smoothstep(s1.y, yd1, bc) - smoothstep(yd1, yd1 + delta, bc));\n    col = hue2rgb(hue);\n    col.r = 0.6;\n    col.g = 0.;\n    col *= 0.7;\n    hue = rgb2hsl(col).x;\n        \n    col.g  = 0.;\n    col.b += nsin(iTime / 4.) / 2.;    \n    col.r += nsin(iTime / 7.) / 5.;    \n    //col = black;\n      \n    }\n\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Border code:    \n    // ===============================================================================================\n    \n    float borderWidth = 3.;\n    vec3 borderInsetLineColour = white;\n    col = drawBorder(col, borderWidth, borderInsetLineColour, pp, hr, tile);\n    \n    // finally return the colour to caller(mainImage()):\n    return col;\n}\t// END doStuff()\n    \n// ===============================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tvec3 col = doStuff(fragCoord, iResolution.xy);\n    col = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    // finally return the colour:\n    fragColor = vec4(col, 1.0);        \n}\n","name":"Image","description":"","type":"image"}]}