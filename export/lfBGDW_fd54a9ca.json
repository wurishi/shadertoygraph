{"ver":"0.1","info":{"id":"lfBGDW","date":"1704216802","viewed":15,"name":"Collision test(ik its ugly)","username":"Monetenbube","description":"Dw i'll change the visualization to the one from IQ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["collision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R 1.0\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdMandelBulb(vec3 pos,float power, int max_i) {//Taken from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < max_i ; i++) {\n\t\tr = length(z);\n\t\tif (r>4.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr ;\n}\n\n\nfloat sdf(vec2 p) {\n    //return sdMandelBulb(vec3(p, 0.0),8.0,5);\n    //return length(p) - 1.0;\n    return sdBox(p, vec2(10.0, 10.0));\n    //return abs(p.x);\n}\n\nvec2 normal(vec2 p) {\n    const vec2 s = vec2(0.001, 0.0);\n\n    float gradient_x = sdf(p + s.xy) - sdf(p - s.xy);\n    float gradient_y = sdf(p + s.yx) - sdf(p - s.yx);\n\n    vec2 normal = vec2(gradient_x, gradient_y);\n    return normalize(normal);\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx * 50.0 - 25.0 + vec2(0.0, 8.0);\n    vec3 c;\n\n    float d  = sdf(uv);\n    float t = sin(d);\n    \n    if (d > 0.1) {\n        c = vec3(t, t, 1.0 -t);\n    }\n    else if (d < -0.1) {\n        c = vec3(t, 1.0 -t, t);\n    }\n    else {\n        c = vec3(0.0);\n    }\n    vec2 mp = iMouse.xy/iResolution.xx * 50.0 - 25.0 + vec2(0.0, 8.0);\n    \n    float md = sdf(mp); \n    vec2 np = mp -  md * normal(mp);\n    if (md < R) {\n            mp += (-md + R + 0.01) * normal(mp);\n    }\n    if (length(uv - mp) < R) {\n        if (sdf(mp) < R) {\n            c = vec3(0.0);\n        }\n        else {\n            c = vec3(1.0);\n        }\n    }\n    if (length(uv - np) < 0.7) {\n        \n        c = vec3(1.0, 0.0, 0.0);\n        \n    }\n    \n    \n\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}