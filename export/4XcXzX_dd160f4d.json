{"ver":"0.1","info":{"id":"4XcXzX","date":"1719324145","viewed":46,"name":"gradient flow animation","username":"mikssx","description":"Moving gradient","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\n//Addapted from: tholzer\n//https://www.shadertoy.com/view/4tsXRS\n\n//--------------------------------------------------------------------\n// Shader: burn\n// Yuldashev Mahmud Effect took from shaderToy mahmud9935@gmail.com\n// original:  http://glslsandbox.com/e#26733.0\n//--------------------------------------------------------------------\nfloat snoise(vec3 uv, float res)\n{\n    const vec3 s = vec3(1e1, 1e3, 1e4);\n    uv *= res;\n    vec3 uv0 = floor(mod(uv, res))*s;\n    vec3 uv1 = floor(mod(uv+1., res))*s;\n    vec3 f = fract(uv); \n    f = f*f*(3.0-2.0*f);\n    vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n                  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n    vec4 r = fract(sin(v*1e-1)*1e3);\n    float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n    r = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n    float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n    return mix(r0, r1, f.z)*2.-1.;\n}\n\nvec3 burn(vec2 p, float size)\n{\n    float radius = length(p); // Distance from the center\n    \n    // Define the gradient colors\n    vec3 color_inside = vec3(1.0, 0.867, 0.792); // #FFDDCA\n    vec3 color_middle = vec3(1.0, 0.686, 0.686); // #FFAFAF\n    vec3 color_outside = vec3(0.878, 0.027, 0.4); // #E00766\n    \n    // Use smoothstep to create smooth transitions\n    vec3 color = mix(color_middle, color_outside, smoothstep(0., 1.5, radius));\n    \n    // Calculate the noise-based effect\n    float color1 = size * 3.0 - 3.0 * length(2.5 * p);\n    vec3 coord = vec3(atan(p.x, p.y) / 6.2832 + 0.5, length(p) * 0.4, 0.5);\n    \n    for (int i = 1; i <= 3; i++)\n    {\n        float power = exp2(float(i));\n        color1 += 0.3 * (1.5 / power) * snoise(coord + vec3(0.0, -iTime * 0.05, -iTime * 0.01), power * 15.0);\n    }\n    \n    color1 *= 0.5;\n    \n    // Combine the noise effect with the radial gradient color\n    return mix(color, vec3(color1), 0.22); // Adjust the mix factor as needed\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y - vec2(0.0, 0.9);\n    \n    vec3 color2 = burn(p, 1.5); // Get the color from the burn function\n    \n    if (color2.r < 0.2 && color2.g < 0.2 && color2.b < 0.2) {\n        fragColor = vec4(0.071, 0.071, 0.071, 1.0);\n    } else {\n        fragColor = vec4(color2, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}