{"ver":"0.1","info":{"id":"4dtGDB","date":"1452068555","viewed":159,"name":"Spaceball","username":"hypothete","description":"balls in space - working back from earlier project","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distancefunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define minStep 1.\n#define maxStep 4.0\n#define delta 0.01\n#define damping 0.9\n#define numSteps 100\n\nstruct camera {\n    vec3 position;\n    vec3 direction;\n};\n    \nconst vec3 worldUp = vec3(0.0,1.0,0.0);\n\nmat3 getViewMatrix (vec3 t, vec3 d, vec3 k) // position, direction, worldUp\n{\n\tvec3 z = normalize(d);\n    vec3 x = normalize(cross(d,k));\n    vec3 y = -normalize(cross(z,x));\n    return mat3(x,y,z);\n}\n\nfloat sdSphere( vec3 p, float s ) //sphere distf\n{\n  return length(p)-s;\n}\n\nfloat sdDisplace(vec3 p){\n    float sc = 4.;\n    return  sin(sc*p.x+iTime)*sin(sc*p.y+iTime)*sin(sc*p.z+iTime);\n}\n\nfloat distf (vec3 pos) //scene distance function\n{\n    float dist = sdSphere(pos,3.);\n   \tdist += sdDisplace(pos)*0.1;\n\treturn dist;\n}\n\nvec3 normal (vec3 p) //borrowed from https://www.shadertoy.com/view/ltfXDM\n{\n    vec2 h = vec2(delta, -delta);\n\treturn normalize (\n\t\th.xxx * distf(p + h.xxx) +\n\t\th.xyy * distf(p + h.xyy) +\n\t\th.yxy * distf(p + h.yxy) +\n\t\th.yyx * distf(p + h.yyx)\n\t);\n}\n\nfloat castRay ( vec3 pos, vec3 dir, out vec3 norm)\n{\n    float dist = minStep;\n    for(int step = 0; step < numSteps; step++)\n    {\n        norm = pos + dir*dist;\n        float normL = distf(norm);\n        if(normL > delta || dist > maxStep){\n            dist += normL*damping;\n        }\n    }\n    return dist;\n}\n\nvec4 smoothFakeLod(samplerCube cubeA, samplerCube cubeB, vec3 nml, float x){\n\tvec4 cubeAColor = texture(cubeA, nml);\n    vec4 cubeBColor = texture(cubeB, nml);\n    return mix(cubeAColor, cubeBColor, smoothstep(0.,1.,x));\n}\n\nvec4 render(in vec2 xy)\n{\n    camera myCam = camera( \n    \tvec3(0,1,-5.),\n    \tvec3( 3.14*(2.*iMouse.x/iResolution.x - 1.), -(2.*iMouse.y/iResolution.y - 1.), 1.0)\n\t);\n    \n    mat3 viewMatrix = getViewMatrix(myCam.position, myCam.direction, worldUp);\n    \n\tvec3 rayDir = viewMatrix * normalize(vec3(xy, 1.0));\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec4 colToRtn = vec4(0,0,1.,1.);\n    float histDistanceFunction = castRay(myCam.position, rayDir, ro);\n    vec3 nml = normal(ro);\n    if(histDistanceFunction < maxStep){\n        rayDir = reflect(rayDir,nml);\n\t\tcolToRtn = smoothFakeLod(iChannel0,iChannel1, rayDir, min(1.,histDistanceFunction/maxStep));\n    \tcolToRtn.xyz *= min(1.,(0.5 + dot(nml, worldUp)));\n    }\n    else{\n        colToRtn = smoothFakeLod(iChannel0,iChannel1, rayDir, min(1.,0.5*length(xy)));\n    }\n    return colToRtn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    fragColor = render(uv);\n}","name":"","description":"","type":"image"}]}