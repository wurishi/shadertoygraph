{"ver":"0.1","info":{"id":"stlSRf","date":"1626264318","viewed":172,"name":"Path tracing 2nd","username":"TheoWU","description":"Drag mouse to change the view or refresh the scene when full screen.\n","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    col = ACESFilm(col*0.5);\n    col = gammaDecode(col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float RandomFloat(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomDirVector(inout uint state)\n{\n    float z = RandomFloat(state) * 2.0f - 1.0f;\n    float a = RandomFloat(state) * 2.0* c_pi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct material{\n    vec3 specularColor;\n    float specularRate;\n    float specularRoughness;\n    float IOR;\n    float refractionRate;\n    float refractionRoughness;\n    vec3 refractionColor;\n    vec3 emission;\n    vec3 albedo;\n};\n\nmaterial materialInit()\n{\n    material m;\n    m.albedo = vec3(0.0f, 0.0f, 0.0f);\n    m.emission = vec3(0.0f, 0.0f, 0.0f);\n    m.specularRate = 0.0f;\n    m.specularRoughness = 0.0f;\n    m.specularColor = vec3(0.0f, 0.0f, 0.0f);\n    m.IOR = 1.0f;\n    m.refractionRate = 0.0f;\n    m.refractionRoughness = 0.0f;\n    m.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n    return m;\n}\n\nstruct hitInfo{\n  bool inside;\n  vec3 pos;\n  float dist;\n  vec3 normal;\n  material m;\n};\n\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0) //if the direction is the same as ray, turn it around\n    {\n        normal *= -1.0;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;\n        info.pos = intersectPos;\n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins. Distance\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w; //w is radius\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray cannot reach sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;//distance of interaction  \n        info.pos = rayDir * dist;\n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo hit)\n{  \n#if SCENE == 0\n//light\n    {\n        vec3 A = vec3(10.0f, 25.0f, 30.0f);\n        vec3 B = vec3(-10.0f, 25.0f, 30.0f);\n        vec3 C = vec3(-10.0f, 25.0f, 20.f);\n        vec3 D = vec3(10.0f, 25.0f, 20.f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            hit.m.emission = vec3(1.0, 1.0, 1.0)*20.;\n        }\n    }\n    //buttom\n    {\n        vec3 A = vec3(25.0f, -5.0f, 50.0f);\n        vec3 B = vec3(-25.0f, -5.0f, 50.0f);\n        vec3 C = vec3(-25.0f, -5.0f, 0.0f);\n        vec3 D = vec3(25.0f, -5.0f, 0.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            hit.m.albedo = vec3(0.7f, 0.7f, 0.7f);\n        }\n    }\n    //top\n    {\n        vec3 A = vec3(10.0f, 25.1f, 30.0f);\n        vec3 B = vec3(-10.0f, 25.1f, 30.0f);\n        vec3 C = vec3(-10.0f, 25.1f, 20.0f);\n        vec3 D = vec3(10.0f, 25.1f, 20.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            hit.m.albedo = vec3(0.5f, 0.5f, 0.5f);\n        }\n    }\n\n    //left ball \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-10.0f, 0.f, 40.0f, 3.0f)))\n    {\n        hit.m.albedo = vec3(0.9f, 0.9f, 0.5f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);   \n        hit.m.specularColor = vec3(0.9f, 0.9f, 0.9f);\n        hit.m.specularRate = 0.1;\n        hit.m.specularRoughness = 0.04;\n        hit.m.IOR = 1.1f;\n    } \n    //mid ball \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(0.0f, 0.f, 40.0f, 3.0f)))\n    {\n        hit.m.albedo = vec3(0.9f, 0.8f, 0.8f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);  \n        hit.m.specularColor = vec3(0.9f, 0.9f, 0.9f);\n        hit.m.specularRate = 0.5;\n        hit.m.specularRoughness = 0.04;\n        hit.m.IOR = 1.1f;\n    }    \n    //right ball \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(10.0f, 0.f, 40.0f, 3.0f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.1f, 0.7f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.9f, 0.9f, 0.9f);\n        hit.m.specularRate = 0.7;\n        hit.m.specularRoughness = 0.04;\n        hit.m.IOR = 1.1f;\n    }\n\n    //1\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-10.0f, 0.f, 30.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 0.;\n        hit.m.IOR = 1.1f;\n    }\n    //2\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-5.0f, 0.f, 30.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 0.0625;\n        hit.m.IOR = 1.1f;\n    }\n    //3\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(0.0f, 0.f, 30.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 0.25;\n        hit.m.IOR = 1.1f;\n    }\n    //4\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(5.f, 0.f, 30.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 0.5625;\n        hit.m.IOR = 1.1f;\n    }\n    //5\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(10.0f, 0.f, 30.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 1.;\n        hit.m.IOR = 1.1f;\n    }\n\n    //A\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-10.0f, 0.f, 20.0f, 2.5f)))\n    {\n        hit.m = materialInit();\n        hit.m.albedo = vec3(0.9f, 0.9f, 0.9f);\n        hit.m.specularColor = vec3(0.8f, 0.8f, 0.8f);\n        hit.m.specularRate = 0.02;\n        hit.m.IOR = 1.5f;\n        hit.m.refractionRate = 1.0;\n        hit.m.refractionColor = vec3(0.8f, 0.8f, 0.8f);\n    }  \n    //B\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(0.0f, 0.f, 20.0f, 2.5f)))\n    {\n        hit.m = materialInit();\n        hit.m.albedo = vec3(0.9f, 0.25f, 0.25f);\n        hit.m.specularColor = vec3(0.8f, 0.8f, 0.8f);\n        hit.m.specularRate = 0.0;\n        hit.m.IOR = 1.5f;\n        hit.m.refractionRate = 1.0;\n    }  \n    //C\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(10.0f, 0.f, 20.0f, 2.5f)))\n    {\n        hit.m = materialInit();\n        hit.m.albedo = vec3(0.9f, 0.25f, 0.25f);\n        hit.m.specularColor = vec3(0.8f, 0.8f, 0.8f);\n        hit.m.specularRate = 0.02;\n        hit.m.IOR = 1.5f;\n        hit.m.refractionRate = 1.0;\n    }  \n    //first line\n    {\n        vec3 A = vec3(15.1f,-4.9f, 25.f);\n        vec3 B = vec3(-15.1f, -4.9f, 25.f);\n        vec3 C = vec3(-15.1f, -4.9f, 15.f);\n        vec3 D = vec3(15.1f, -4.9f, 15.f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            vec3 hitPos = rayPos + rayDir * hit.dist;\n            \n            float shade = floor(mod(hitPos.x, 1.0f) * 2.0f);\n            hit.m.albedo = vec3(shade, shade, shade);\n        }\n    }\n    #elif SCENE == 2\n    //front\n    {\n        vec3 A = vec3(-25.0f, -15.0f, 35.0f);\n        vec3 B = vec3( 25.0f, -15.0f, 35.0f);\n        vec3 C = vec3( 25.0f,  15.2f, 35.0f);\n        vec3 D = vec3(-25.0f,  15.2f, 35.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            hit.m.albedo = vec3(0.7f, 0.7f, 0.7f);\n        }\n    }\n    //buttom\n    {\n        vec3 A = vec3(25.1f, -15.0f, 35.0f);\n        vec3 B = vec3(-25.1f, -15.0f, 35.0f);\n        vec3 C = vec3(-25.1f, -15.0f, 20.0f);\n        vec3 D = vec3(25.1f, -15.0f, 20.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            hit.m.albedo = vec3(0.7f, 0.7f, 0.7f);\n        }\n    }\n    //top\n    {\n        vec3 A = vec3(25.0f, 15.1f, 35.0f);\n        vec3 B = vec3(-25.0f, 15.1f, 35.0f);\n        vec3 C = vec3(-25.0f, 15.1f, 20.0f);\n        vec3 D = vec3(25.0f, 15.1f, 20.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            hit.m.albedo = vec3(0.5f, 0.5f, 0.5f);\n        }\n    }\n    //light\n    {\n        vec3 A = vec3(17.0f, 15.0f, 25.0f);\n        vec3 B = vec3(-17.0f, 15.0f, 25.0f);\n        vec3 C = vec3(-17.0f, 15.0f, 22.f);\n        vec3 D = vec3(17.0f, 15.0f, 22.f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            hit.m.emission = vec3(1.0, 1.0, 1.0)*20.;\n        }\n    }\n\n\n    //left ball \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-10.0f, 11.f, 30.0f, 3.0f)))\n    {\n        hit.m.albedo = vec3(0.9f, 0.9f, 0.5f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);   \n        hit.m.specularColor = vec3(0.9f, 0.9f, 0.9f);\n        hit.m.specularRate = 0.1;\n        hit.m.specularRoughness = 0.04;\n        hit.m.IOR = 1.1f;\n    } \n    //mid ball \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(0.0f, 11.f, 30.0f, 3.0f)))\n    {\n        hit.m.albedo = vec3(0.9f, 0.8f, 0.8f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);  \n        hit.m.specularColor = vec3(0.9f, 0.9f, 0.9f);\n        hit.m.specularRate = 0.5;\n        hit.m.specularRoughness = 0.04;\n        hit.m.IOR = 1.1f;\n    }    \n    //right ball \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(10.0f, 11.f, 30.0f, 3.0f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.1f, 0.7f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.9f, 0.9f, 0.9f);\n        hit.m.specularRate = 0.7;\n        hit.m.specularRoughness = 0.04;\n        hit.m.IOR = 1.1f;\n    }\n\n\n    //1\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-10.0f, -5.f, 33.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 0.;\n        hit.m.IOR = 1.1f;\n    }\n    //2\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-5.0f, -5.f, 33.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 0.0625;\n        hit.m.IOR = 1.1f;\n    }\n    //3\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(0.0f, -5.f, 33.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 0.25;\n        hit.m.IOR = 1.1f;\n    }\n    //4\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(5.f, -5.f, 33.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 0.5625;\n        hit.m.IOR = 1.1f;\n    }\n    //5\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(10.0f, -5.f, 33.0f, 1.7f)))\n    {\n        hit.m.albedo = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.emission = vec3(0.0f, 0.0f, 0.0f);\n        hit.m.specularColor = vec3(0.0f, 0.7f, 0.0f);\n        hit.m.specularRate = 1.;\n        hit.m.specularRoughness = 1.;\n        hit.m.IOR = 1.1f;\n    }\n\n    //A\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-10.0f, -11.f, 30.0f, 2.5f)))\n    {\n        hit.m = materialInit();\n        hit.m.albedo = vec3(0.9f, 0.9f, 0.9f);\n        hit.m.specularColor = vec3(0.8f, 0.8f, 0.8f);\n        hit.m.specularRate = 0.02;\n        hit.m.IOR = 1.5f;\n        hit.m.refractionRate = 1.0;\n        hit.m.refractionColor = vec3(0.8f, 0.8f, 0.8f);\n    }  \n    //B\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(0.0f, -11.f, 30.0f, 2.5f)))\n    {\n        hit.m = materialInit();\n        hit.m.albedo = vec3(0.9f, 0.25f, 0.25f);\n        hit.m.specularColor = vec3(0.8f, 0.8f, 0.8f);\n        hit.m.specularRate = 0.0;\n        hit.m.IOR = 1.5f;\n        hit.m.refractionRate = 1.0;\n    }  \n    //C\n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(10.0f, -11.f, 30.0f, 2.5f)))\n    {\n        hit.m = materialInit();\n        hit.m.albedo = vec3(0.9f, 0.25f, 0.25f);\n        hit.m.specularColor = vec3(0.8f, 0.8f, 0.8f);\n        hit.m.specularRate = 0.02;\n        hit.m.IOR = 1.5f;\n        hit.m.refractionRate = 1.0;\n    }  \n    //first line\n    {\n        vec3 A = vec3(15.1f,-13.5f, 34.9f);\n        vec3 B = vec3(-15.1f, -13.5f, 34.9f);\n        vec3 C = vec3(-15.1f, -10.f, 34.9f);\n        vec3 D = vec3(15.1f, -10.f, 34.9f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.m = materialInit();\n            vec3 hitPos = rayPos + rayDir * hit.dist;\n            \n            float shade = floor(mod(hitPos.x, 1.0f) * 2.0f);\n            hit.m.albedo = vec3(shade, shade, shade);\n        }\n    }\n#endif\n}\n\nvec3 getColor(vec3 rayori, vec3 raydir, inout uint seed){\n    vec3 color = vec3(0.0,0.0,0.0);\n    vec3 throughput = vec3(1.0,1.0,1.0);\n    \n    for(int i = 0; i <= max_bounce; i++){\n        hitInfo hit;\n        hit.dist = c_superFar;\n        hit.inside = false;\n        TestSceneTrace(rayori,raydir,hit); //return hit info\n        \n        if(hit.dist == c_superFar){ //if the ray not hit\n            color += gammaEncode(texture(iChannel1, raydir).rgb)*throughput*0.9;\n            break;\n        }\n        if(hit.inside){//absorption of refraction\n            throughput *= exp(-hit.m.refractionColor*hit.dist);\n        }\n        float specularRateNew = hit.m.specularRate;\n        float refractionRateNew = hit.m.refractionRate;\n        float rayPosibility = 1.0;\n        \n        if(hit.m.specularRate > 0.0){\n            specularRateNew = Fresnel(1.0, hit.m.IOR, hit.normal, raydir, hit.m.specularRate); //use fresnel\n            refractionRateNew *= (1.0-specularRateNew)/(1.0-hit.m.specularRate); // keep the rate of refraction since the rate of specular has changed\n        }\n        \n        float isSpecular = 0.0;\n        float isRefraction = 0.0;\n        \n        if(specularRateNew > 0.0 && RandomFloat(seed) < specularRateNew){//this ray specular\n            isSpecular = 1.0;\n            rayPosibility = specularRateNew;\n        }else if (refractionRateNew > 0.0 && RandomFloat(seed) < refractionRateNew){//this ray refract\n            isRefraction = 1.0;\n            rayPosibility = refractionRateNew;\n        }else{//this ray diffuse\n            rayPosibility = 1.0 - (specularRateNew + refractionRateNew);\n        }\n        \n        rayPosibility = max(rayPosibility,0.001);\n        \n        if(isRefraction == 1.0){\n            rayori = (rayori + raydir * hit.dist) - hit.normal * c_rayPosNormalNudge;//is inside away from inside direction\n        }else{\n            rayori = (rayori + raydir * hit.dist) + hit.normal * c_rayPosNormalNudge;//slightly away from surface\n        }\n      \n        vec3 diffusedir = normalize(hit.normal + RandomDirVector(seed));\n        \n        vec3 V = hit.pos-rayori;\n        vec3 H = normalize(V+raydir);\n        //float NDF = DistributionGGX(hit.normal, H, roughness);\n        float k_direct = pow(hit.m.specularRoughness+1.0,2.0)/8.0;\n        float k_image = pow(hit.m.specularRoughness,2.0)/2.0;\n        float G = GeometrySmith(hit.normal, V, raydir, k_direct);  \n        \n        vec3 speculardir = reflect(raydir,hit.normal);\n        //speculardir = normalize(mix(speculardir, diffusedir, hit.m.specularRoughness));//affected by diffuse property, not using normal distribution\n        speculardir = normalize(mix(speculardir, diffusedir, DistributionGGX(hit.normal, H, hit.m.specularRoughness)));\n        \n        vec3 refractiondir = refract(raydir,hit.normal,hit.inside ? hit.m.IOR : 1.0/hit.m.IOR);\n        refractiondir = normalize(mix(refractiondir, normalize(-hit.normal+RandomDirVector(seed)), hit.m.refractionRoughness));//affected by random, not inside diffuse yet\n        \n        raydir = mix(diffusedir,speculardir,isSpecular);//for next TestSceneTrace\n        raydir = mix(raydir,refractiondir,isRefraction);//for next TestSceneTrace\n        \n        color += hit.m.emission * throughput;\n        \n        if(isRefraction == 0.0){ //if no refraction, only specular ray need to carry color(add to throughput)\n            throughput *= mix(hit.m.albedo, hit.m.specularColor, isSpecular);// if no specular, diffuse don't have to add throughput\n        }\n        throughput /= rayPosibility;\n        \n        //GeometrySmith block\n        if (RandomFloat(seed) > (1.0-G))//continue path trace\n            break;\n        throughput *= 1.0/(1.0-G);\n        \n        //Russian Roulette\n        float p = max(throughput.r, max(throughput.g, throughput.b));\n        if (RandomFloat(seed) > p)\n            break;\n        throughput *= 1.0f / p;\n    }\n    \n    return color;\n}\n\n// mouse camera control parameters\nconst float c_minCameraAngle = 0.01f;\nconst float c_maxCameraAngle = (c_pi - 0.01f);\nconst vec3 cameraAt = vec3(0.0f, 0.0f, 30.0f); //the coord of objects\nvec2 recentMo;\nvec2 mo;\nconst float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f); \nvec3 cameraPos;\nvec3 cameraFwd, cameraUp, cameraRight;\n\nvoid GetCameraVectors(out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight, in float cameraDistance)\n{\n    mo = ((iMouse.xy)/iResolution.xy*2.0-1.0); //-1.0~0.0~1.0\n    mo *= c_pi; //-pi~0~pi\n    recentMo += mo;\n    cameraPos = vec3(40.0*sin(recentMo.x),40.0*sin(recentMo.y)+40.0,40.0*(1.0-cos(recentMo.x)*cos(recentMo.y)));\n    cameraFwd = normalize(cameraAt - cameraPos);\n    cameraRight = normalize(cross(vec3(0.0f, 1.0f, 0.0f), cameraFwd));\n    cameraUp = normalize(cross(cameraFwd, cameraRight));\n    return ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint seed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat(seed),RandomFloat(seed))-0.5;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord+jitter)/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 raytarget = vec3(uv,cameraDistance);//cameraDistance is around 2.\n    \n    GetCameraVectors(cameraFwd, cameraUp, cameraRight, cameraDistance); \n    \n    vec3 cameraDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * raytarget);\n    \n    vec3 col = vec3(0.,0.,0.);\n    for(int i=0;i<32;i++){\n        seed += uint(200*i);\n        col += getColor(cameraPos,cameraDir,seed)/32.0;\n    }\n    \n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n    \n    vec4 lastFrame = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    float blend = (lastFrame.a == 0.0 || spacePressed) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrame.a));\n    float changeView = (lastFrame.a == 0.0 || iMouse.z > 0. ) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrame.a));\n    col = mix(lastFrame.rgb,col,changeView);\n    // Output to screen\n    \n    fragColor = vec4(col,changeView);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float c_minimumRayHitTime = 0.1f;\nconst float c_superFar = 10000.0f;\nconst int max_bounce = 8;\nconst float c_pi = 3.1415926;\nconst float c_rayPosNormalNudge = 0.01f;\nconst float c_FOVDegrees = 30.0;\n#define SCENE 0\nvec3 gammaEncode(vec3 rgb)\n{\n    rgb = pow(rgb,vec3(2.4));\n    return rgb;\n}\n\nvec3 gammaDecode(vec3 rgb)\n{\n    rgb = pow(rgb,vec3(1./2.4));\n    return rgb;\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nfloat Fresnel(float n1, float n2, vec3 normal, vec3 incident, float specularRate)\n{\n        // Schlick aproximation\n        float f0 = pow((n1-n2)/(n1+n2),2.0);\n        \n        float ret = f0+(1.0-f0)*pow((1.0-dot(normal,-incident)),5.0);\n\n        return mix(specularRate,1.0,ret);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float a)\n{\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = c_pi * denom * denom;\n\t\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);//view\n    float NdotL = max(dot(N, L), 0.0);//light\n    float ggx1 = GeometrySchlickGGX(NdotV, k); // view\n    float ggx2 = GeometrySchlickGGX(NdotL, k); // light\n\t\n    return ggx1 * ggx2;\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}\n","name":"Common","description":"","type":"common"}]}