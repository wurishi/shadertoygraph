{"ver":"0.1","info":{"id":"XdtGWn","date":"1449011080","viewed":295,"name":"ColorBleeding","username":"kuvkar","description":"Quick test to see if color bleeding could be made similar way as ambient occlusion is made. ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","colorbleeding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n*\n* A test to see if color bleeding (contributing color of an object to nearby objects) could be made similar way as ambient occlusion. \n* \n* The objects have a arbitrary \"roughness\" value which determines how much they bleed color to surroundings and \n* receive color from other sources.\n* \n* makes code a bit more complex, I'm relying on some global variables here to make it work.\n*/\n\n\n\n/// Distance Functions from  \n///\thttps://iquilezles.org/articles/distfunctions\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n////////////////////////////\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n#define OBJECTS 4\n\n\nvec4 colors[4];\n\nvec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n\n\n// \n// different types of objects, can be changed from code in main function.\n//\nconst int SPHERE = 0;\nconst int PLANE = 1;\nconst int CUBE = 2;\nconst int PRISM = 3;\n\nstruct Object\n{\n    vec3 position;\n    int colorIndex;\n    float size;\n    int type;\n    float roughness;\n    \n};\n\nObject objects[OBJECTS];\nfloat distances[OBJECTS];\nint minIndex = 0;\n\n\nObject getObject(int index)\n{\n    if(index == 0) return objects[0];\n    if(index == 1) return objects[1];\n    if(index == 2) return objects[2];\n    if(index == 3) return objects[3];\n    return objects[0];\n}\n\n\nvec4 getColor(int index)\n{\n    if(index == 0) return colors[0];\n    if(index == 1) return colors[1];\n    if(index == 2) return colors[2];\n    if(index == 3) return colors[3];\n    return colors[0];\n}\n\n\nfloat getDist(in vec3 rp, int objectIndex)\n{\n    \n    Object o = getObject(objectIndex);\n    vec3 p = rp - o.position;\n    int type = o.type;\n    \n    if(type == SPHERE)\n    {\n    \treturn sdSphere(p, o.size);\n    }\n    else if(type == PLANE)\n    {\n        return sdPlane(p, normalize(vec4(0.0, 1.0, 0.0, 0.1)));\n    } \n    else if (type == CUBE)\n    {\n        return sdBox(p, vec3(o.size));\n    } \n    else if (type == PRISM)\n    {\n        return sdTriPrism(p, vec2(o.size));\n    }\n    \n\treturn 99.0;    \n}\n\nfloat scene(in vec3 rp)\n{\n    float mind = 999.0;\n\tminIndex = 0;\n    \n    for (int i = 0; i < OBJECTS; ++i)\n    {\n        float dist = getDist(rp, i);\n        distances[i] = dist;\n        \n        if(dist < mind) \n        {\n        \tminIndex = i;\n\t        mind = dist;\n        }\n    }\n    return mind;\n}\n\n\n\nvec3 grad(vec3 rp)\n{\n    vec2 offset = vec2(0.001, 0.0);\n    vec3 g = vec3(\n        scene(rp + offset.xyy) - scene(rp - offset.xyy),\n        scene(rp + offset.yxy) - scene(rp - offset.yxy),\n        scene(rp + offset.yyx) - scene(rp - offset.yyx));\n    return normalize(g);\n}\n\n/**\n* here's the actual color bleeding function.\n* Basicly same thing as AO, but summing colors together from nearby sources,\n* weighted by their distances.\n*/\nvec4 colorbleed(in vec3 rp, in vec3 g)\n{\n    const float range = 0.05;\n    vec4 clr = vec4(0.0);\n    \n\tconst int samples = 6;\n    for (int j = 1; j <= samples; ++j)\n    {\n        // recalculate distances\n        scene(rp + g * range * float(j));\n        \n        for (int i = 0; i < OBJECTS; ++i)\n        {\n            float d = distances[i];\n\n            d = 1.0 - clamp(d, 0.0, range) / range;\n            d *= (float(samples) - float(j)) / float(samples);\n            vec4 curcol = colors[i];\n            clr += d * curcol * objects[i].roughness;\n        }\n    \n    }\n    return clr;\n}\n\nfloat shadow(vec3 rp)\n{\n    float softness = 0.02;\n    rp += lightDir * softness;\n    float d = dot(lightDir, vec3(0.0, 1.0, 0.0));\n    \n    float mind = 99.0;\n    \n    for (int i = 0; i < 25; ++i)\n    {\n        float dist = scene(rp);\n        \n        rp += lightDir * max(dist, 0.005);\n        mind = min(mind, dist);\n    }\n    mind = max(0.0, mind);\n    float shadow = smoothstep(0.0, d * softness, mind);\n    return shadow;\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    float closestDist = 99.0;\n    \n\tfor (int i = 0; i < 450; ++i)\n    {\n        float dist = scene(rp);\n        closestDist = min(dist, closestDist);    \n        if(dist < 0.)\n        {\n            break;\n        }\n        rp += rd * max(dist, 0.00001);\n        \n        if(rp.z > 2.0) break;\n    }\n\n    int hitInd = minIndex;\n    \n    vec4 hitColor = getColor(minIndex);\n    \n    vec3 g = grad(rp);\n    if(hitInd == 0)\n    {\n        vec2 uv = rp.zx * 1.4;\n        hitColor = texture(iChannel0, uv).rrrr * hitColor;\n        vec2 off = vec2(0.005, 0.0);\n        \n        // some bump mapping\n        float h1 = texture(iChannel0, uv + off).r;\n        float h2 = texture(iChannel0, uv - off).r;\n\n        float h3 = texture(iChannel0, uv + off.yx).r;\n        float h4 = texture(iChannel0, uv - off.yx).r;\n        \n        g = cross( normalize(vec3(0.0, h4 - h3, off.x * 2.0)), normalize(vec3(off.x * 2.0, h2 - h1, 0.0)));\n        g = normalize(g) * 0.7;\n    }\n\n    float d = dot(g, lightDir);\n    d = clamp(d, 0.0, 1.0);\n    d = mix(d, 1.0, 0.5);\n\n    \n    Object hitobj = getObject(hitInd);\n    float roughness = hitobj.roughness;\n    \n    //default shading things\n    vec3 H = normalize(lightDir - rd);\n    float spcd = dot(H, g);\n\n    spcd = clamp(spcd, 0.0, 1.0);\n    spcd = pow(spcd, 5.0);\n    color = mix(spcd * hitColor, d * hitColor, roughness);\n\n    // adding the received color from bleeding.\n    color += colorbleed(rp, g) * roughness;\n    color = mix(vec4(0.0), color, mix(1.0, shadow(rp), 0.7));\n    \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5); \n    uv.y /= iResolution.x / iResolution.y;\n    \n    colors[0] = vec4(.9, .6, .4, 1.0) * 1.;\n    colors[1] = vec4(0.0, 1.0, 0.0, 0.0) * 0.8;\n    colors[2] = vec4(.0, .2, 1.0, 0.0) * .7;\n    colors[3] = vec4(1.0, .0, 0.0, 0.0);\n    \n    \n    objects[0].position = vec3(-0., 0.0, 0.0);\n    objects[0].type = PLANE;\n    objects[0].size = 0.1;\n    objects[0].colorIndex = 0;\n    objects[0].roughness = .1;\n    \n    objects[1].position = vec3(0.22, 0., 0.0) * roty(iTime * 0.5);\n    objects[1].type = SPHERE;\n    objects[1].size = 0.08;\n    objects[1].colorIndex = 1;\n    objects[1].roughness = .2;\n    \n    objects[2].position = vec3(0., 0., 0.0);\n    objects[2].type = SPHERE;\n    objects[2].size = 0.1;\n    objects[2].colorIndex = 2;\n    objects[2].roughness = .2;\n\n    objects[3].position = (objects[1].position) + vec3(0.1, -0.07, 0.0) * roty(iTime * 1.0);\n    objects[3].type = SPHERE;\n    objects[3].size = 0.04;\n    objects[3].colorIndex = 3;\n    objects[3].roughness = .2;\n    \n    vec3 rd = normalize(vec3(uv, 1.2 + sin(iTime * 0.2) * 0.2));\n    rd = rd * rotx(0.7);\n    vec3 rp = vec3(0.0, .8, -1.);\n    fragColor = vec4(.1);\n    \n    trace(rp, rd, fragColor);\n    \n    float m = max(fragColor.g, max(fragColor.r, fragColor.b));\n    fragColor /= max(m, 1.0);\n    fragColor = vec4(pow(fragColor.rgb, vec3(1./2.2)),1.0);\n    \n}","name":"Image","description":"","type":"image"}]}