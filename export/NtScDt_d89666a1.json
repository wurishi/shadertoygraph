{"ver":"0.1","info":{"id":"NtScDt","date":"1650381493","viewed":68,"name":"squares test","username":"ph04","description":"test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define MAX_STEPS 128\n# define SURFACE_DIST .01\n# define MAX_DIST 128.\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Light {\n    vec3 position;\n};\n\nstruct Rectangle {\n    vec3 position;\n    vec3 dimensions;\n};\n\nfloat getDistanceFromSphere(vec3 intersectionPoint) {\n    //Sphere sphere = Sphere(vec3(0, 1, 6), 1.); // TODO: move this out of here\n    Rectangle r = Rectangle(vec3(0, .5, 3), vec3(.5));\n    \n    // the distance from the surface of the sphere is\n    // the norm of the difference vector of\n    // the center and the given direction,\n    // minus the radius of the sphere\n    //float dstSphere = length(sphere.center - intersectionPoint) - sphere.radius;\n    float dstSphere = length(max(abs(\n        intersectionPoint - r.position\n    ) - r.dimensions, 0.));\n    \n        // if the axis are aligned, the distance\n    // to the plane is the height of the point\n    // of intersection\n    float dstPlane = intersectionPoint.y;\n    \n    return min(dstPlane, dstSphere);\n}\nfloat ABCgetDistanceFromSphere(vec3 p){\n    float s = 0.5;\n    vec3 q = abs(p) - vec3(s);\n    float dist = max(max(q.x, q.y), q.z);\n    if(q.x > 0.0 && q.y > 0.0 && q.z > 0.0){\n        dist = length(q);\n    }\n    return dist;\n}\n\nfloat rayMarchSphere(vec3 camPosition, vec3 rayDirection) {\n    // the distance from the origin\n    float dstOrigin = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        // the point of intersection between\n        // the rayDirection and the ray-marched sphere\n        vec3 intersectionPoint = camPosition + dstOrigin * rayDirection;\n        \n        // the distance from the ray-marched scene\n        // (the radius of the sphere)\n        float dstScene = getDistanceFromSphere(intersectionPoint);\n       \n        if (dstScene < SURFACE_DIST) break;\n       \n        // add the current distance from the sphere\n        // to the current distance from the origin\n        // (move the center of the sphere)\n        dstOrigin += dstScene;\n        \n        if (dstOrigin > MAX_DIST) break;\n    }\n    \n    // return the distance from the origin\n    // to the hit location (if any)\n    return dstOrigin;\n}\n\nvec3 getSphereNormal(vec3 point) {\n    float d = getDistanceFromSphere(point); // ???\n    \n    // slight movement in one direction\n    // used to quickly perform a movement\n    // in every direction\n    vec2 almostZero = vec2(.01, 0);\n    \n    // calculate the pseudo-gradient by\n    // evaluating the direction of the difference\n    // vector between the distance from the sphere\n    // and a very small movement in every direction\n    vec3 almostGradientVector = d - vec3(\n        getDistanceFromSphere(point - almostZero.xyy),\n        getDistanceFromSphere(point - almostZero.yxy),\n        getDistanceFromSphere(point - almostZero.yyx)\n    );\n    \n    // return the pseudo-gradient vector normalized\n    return normalize(almostGradientVector);\n}\n\nfloat getLight(vec3 point) {\n    Light light = Light(vec3(0, 5, 6)); // TODO: move this out of here\n    \n    // get the light normalized light vector\n    vec3 lightVector = normalize(light.position - point);\n    \n    // get the normalized sphere gradient\n    // on the given point\n    vec3 normalVector = getSphereNormal(point);\n    \n    // calculate the lighting on the given\n    // point by evaluating the dot product\n    // between the normalized light vector and\n    // the normal on the given point\n    float diffuseLighting = dot(normalVector, lightVector);\n    \n    // we just want to use positive values\n    // because if the dot product is negative\n    // the angle between the two vectors is obtuse\n    // and there is no light hitting the given point\n    return clamp(diffuseLighting, 0., 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 camPosition = vec3(iMouse.x * .003 - 0.5 * iResolution.x * 0.003, iMouse.y * .003, 0);\n    vec3 rayDirection = normalize(vec3(uv.xy, 1)); // normalized ray direction\n    \n    float dstSphere = rayMarchSphere(camPosition, rayDirection);\n    \n    vec3 intersectionPoint = camPosition + rayDirection * dstSphere;\n    \n    float diffuseLighting = getLight(intersectionPoint);\n    \n    vec3 col = vec3(diffuseLighting);\n    //vec3 col = vec3(dstSphere) / 6.;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}