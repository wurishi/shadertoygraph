{"ver":"0.1","info":{"id":"dlcXR7","date":"1685177293","viewed":55,"name":"electric field revised","username":"Fuergu","description":"based on shader : https://www.shadertoy.com/view/XsSyzc\nadd potential","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["electric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nh:              Time step for integration\nMAX_STEPS：     Maximum number of steps for numerical integration, i.e. maximum length of power line\nTAU：           2pi\nLINES：         Number of power lines\nLINESS:         Number of equipotential surfaces (lines)\nLINESS_WIDTH \nLINESS_SMOOTH:  Anti-aliasing level\n*/\n\n#define h 0.03\n#define MAX_STEPS 100\n#define TAU 6.28318530718\n#define LINES 20.\n#define LINESS 6.\n#define LINEWIDTH 0.004\n#define LINESS_WIDTH 0.004\n#define LINESS_SMOOTH 3.\n\n//potential\nfloat phi(vec2 p,vec2 q,vec2 q1,vec2 q2){\n\treturn q.x/length(q1-p)+q.y/length(q2-p);\n}\n\n// field\nvec2 E(vec2 p,vec2 q,vec2 q1,vec2 q2){\n\treturn normalize(q.x*(p-q1)/pow(length(q1-p),3.)+q.y*(p-q2)/pow(length(q2-p),3.));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) ); \n\n}\n\nvec2 RK4(vec2 p,vec2 q,vec2 q1,vec2 q2){\n    vec2 k1 = E(p,q,q1,q2);\n    vec2 k2 = E(p+0.5*h*k1,q,q1,q2);\n    vec2 k3 = E(p+0.5*h*k2,q,q1,q2);\n    vec2 k4 = E(p+h*k3,q,q1,q2);\n    return h/3.*(0.5*k1+k2+k3+0.5*k4);\n}\n\nbool integrate(inout float d,vec2 p,vec2 q,vec2 q1,vec2 q2,vec2 start,vec2 end){\n    d = min(d, line(p,mix(q1,q2,float(length(q1-start)>h*1.001)),start));\n    vec2 pn;\n    vec2 po = start;\n    for(int i = 0;i<MAX_STEPS;i++){\n    \tpn = po+RK4(po,q,q1,q2);\n        d = min(d,line(p,po,pn));\n        po=pn;\n        if(length(end-po)<h){\n            d = min(d,line(p,po,end));\n            return false;\n        }\n        if(abs(po.x)>iResolution.x/iResolution.y||abs(po.y)>1.0)return true;\n    }\n    return true;\n}\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv = (2.*C-iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    vec2 q1 = vec2(-.5,0);\n    vec2 q2 = vec2(mouse.x,0);\n    vec2 q = vec2(0.1,0.2*smoothstep(-0.7,0.7,mouse.y)-0.1);\n    //Determining whether it's static mode\n    float idle = float(iMouse.z<0.||iMouse.x<0.001)*0.1,d=1.;\n    O = vec4(0);\n    if(idle>0.){q2.x=.4;q.y=.1;}   \n    for(float o = 0.;o<TAU;o+=TAU/LINES){\n        float angle = iTime*idle+TAU/(2.*LINES)+o;\n        vec2 os = vec2(cos(angle),sin(angle))*0.01;\n    \tif(integrate(d,uv,q,q1,q2,q1+os,q2)&&abs(q.y)>0.){\n    \t\tintegrate(d,uv,q.y/abs(q.y)*q,q1,q2,q2+mat2(-1,0,0,1)*os,q1);\n    \t}\n        float f = phi(uv, q, q1, q2);\n        O = .8* vec4( max(f, 0.), max(-f, 0.), 0,0)\n             +  smoothstep(3./iResolution.y,.0, d);\n    }\n    \n\nfloat isoLevel = 0.03; \nfor(float i00=0.;i00<1.;i00=i00+LINESS/200.)\n{\n    isoLevel+=i00;\n    vec2 electricField = E(uv, q, q1, q2);\n    float potential = phi(uv, q, q1, q2);\n    if (potential >= isoLevel && potential <= isoLevel+LINESS_WIDTH-i00*.006) \n    {\n        float i=1.;\n        if (mouse.y<0.) i=1.*(-mouse.y+1.);\n        vec3 color = vec3(1.,(1.-i00*6.)*i,0.); \n            O.rgb=color;\n            if(potential >= isoLevel && potential <= isoLevel+(LINESS_WIDTH-i00*.006)/LINESS_SMOOTH)\n             O.rgb = color*smoothstep(isoLevel, isoLevel+(LINESS_WIDTH-i00*.006)/LINESS_SMOOTH, potential);\n            if(potential >= (isoLevel+(LINESS_WIDTH-i00*.006)*(1.-1./LINESS_SMOOTH)) && potential <= isoLevel+LINESS_WIDTH-i00*.006)\n             O.rgb = color*smoothstep( isoLevel+LINESS_WIDTH-i00*.006, isoLevel+(LINESS_WIDTH-i00*.006)*(1.-1./LINESS_SMOOTH),potential);\n\n    }\n}\n\n\nfloat isoLevel1 = 0.03; \nfor(float i00=0.;i00<1.;i00=i00+LINESS/200.)\n{\n    isoLevel1+=i00;\n    vec2 electricField = E(uv, q, q1, q2);\n    float potential = -phi(uv, q, q1, q2);\n    if (potential >= isoLevel1 && potential <= isoLevel1+LINESS_WIDTH-i00*.006) \n    {\n         O.a=0.;\n            float i=1.;\n            if (mouse.y<0.) i=1.*(-mouse.y+1.);\n            vec3 color = vec3(i*(1.-i00*6.),1.,0.);\n            O.rgb=color;\n            if(potential >= isoLevel1 && potential <= isoLevel1+(LINESS_WIDTH-i00*.006)/LINESS_SMOOTH)\n             O.rgb = color*smoothstep(isoLevel1, isoLevel1+(LINESS_WIDTH-i00*.006)/LINESS_SMOOTH, potential);\n            if(potential >= (isoLevel1+(LINESS_WIDTH-i00*.006)*(1.-1./LINESS_SMOOTH)) && potential <= isoLevel1+LINESS_WIDTH-i00*.006)\n             O.rgb = color*smoothstep( isoLevel1+LINESS_WIDTH-i00*.006, isoLevel1+(LINESS_WIDTH-i00*.006)*(1.-1./LINESS_SMOOTH),potential);\n\n    }\n}\n}","name":"Image","description":"","type":"image"}]}