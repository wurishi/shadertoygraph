{"ver":"0.1","info":{"id":"MfSyDW","date":"1722315806","viewed":20,"name":"Setik","username":"setik","description":"setik shows shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["djsetik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 opRep( in vec3 p, in vec3 c, out vec3 idx)\n{\n    p = (p + 0.5 * c) / c;\n    vec3 floorP = floor(p);\n    vec3 fractP = fract(p);\n    idx = floorP;\n    return fractP * c - 0.5 * c;\n}\n\nfloat hash13(vec3 p3)\n{\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 idx;\n    p = opRep(p, vec3(6.0, 3.0, 5.0), idx);\n    \n    vec2 res = vec2(0.0, 0.0);\n    float thickness = 0.275;\n    float fwaD = 100.0;\n    \n    float r = hash13(idx * 100.0 + floor(iTime * 2.14));\n    \n    if (r > 0.2 + step(dot(idx, idx), 0.5)) {\n        return vec2(0.75, 0.0);\n    }\n    \n    // Definindo as capsulas para formar 'SETIK'\n    // Letra 'S'\n    fwaD = min(fwaD, sdCapsule(p, vec3(-2.5, 0.5, 0.0), vec3(-1.5, 0.5, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(-2.5, 0.0, 0.0), vec3(-1.5, 0.0, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(-2.5, -0.5, 0.0), vec3(-1.5, -0.5, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(-2.5, 0.5, 0.0), vec3(-2.5, 0.0, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(-1.5, 0.0, 0.0), vec3(-1.5, -0.5, 0.0), thickness));\n\n    // Letra 'E'\n    fwaD = min(fwaD, sdCapsule(p, vec3(-1.0, 0.5, 0.0), vec3(0.0, 0.5, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(-1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(-1.0, -0.5, 0.0), vec3(0.0, -0.5, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(-1.0, 0.5, 0.0), vec3(-1.0, -0.5, 0.0), thickness));\n    \n    // Letra 'T'\n    fwaD = min(fwaD, sdCapsule(p, vec3(0.5, 0.5, 0.0), vec3(1.5, 0.5, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(1.0, 0.5, 0.0), vec3(1.0, -0.5, 0.0), thickness));\n    \n    // Letra 'I'\n    fwaD = min(fwaD, sdCapsule(p, vec3(2.0, 0.5, 0.0), vec3(2.0, -0.5, 0.0), thickness));\n    \n    // Letra 'K'\n    fwaD = min(fwaD, sdCapsule(p, vec3(2.5, 0.5, 0.0), vec3(2.5, -0.5, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(2.5, 0.0, 0.0), vec3(3.5, 0.5, 0.0), thickness));\n    fwaD = min(fwaD, sdCapsule(p, vec3(2.5, 0.0, 0.0), vec3(3.5, -0.5, 0.0), thickness));\n    \n    res.x = fwaD;\n    res.y = step(0.24, p.z);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, s, -s, c);\n    return m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n    \n    float t = iTime * 0.2;\n    vec3 off0 = fract(vec3(t * 2.516 - 0.642, -t * 0.541 - 0.624, t * 0.532 - 0.74)) - 0.5;\n    vec3 off1 = fract(vec3(-t * 0.512 - 0.3412, t * 2.537 - 0.92, -t * 0.5327 - 0.24)) - 0.5;\n    vec3 off2 = fract(vec3(t * 0.47 - 0.835, t * 0.537 - 0.753, -t * 0.47 - 0.845)) - 0.5;\n    vec3 off3 = fract(vec3(t * 0.324 - 0.23, -t * 0.537 - 0.324, t * 2.5327 - 0.56)) - 0.5;\n    \n    vec3 rayOri = vec3(0.0, 0.0, 3.0) + off0 * off2 * vec3(12.0, 12.0, 6.0);\n    vec3 target = vec3(rotate((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0), dot(off0, off1) * 3.0) * 6.0, 0.0) + off1 * off3 * vec3(12.0, 12.0, 6.0);\n    vec3 rayDir = normalize(target - rayOri);\n    \n    float depth = 0.0;\n    vec3 p;\n    vec2 res;\n    \n    for(int i = 0; i < 64; i++) {\n        p = rayOri + rayDir * depth;\n        res = map(p);\n        depth += res.x;\n        if (res.x < 1e-5) {\n            break;\n        }\n    }\n    \n    depth = min(50.0, depth);\n    vec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = mix(vec3(0.5), vec3(1.0), b) * 1.75;\n    col *= exp((-depth + 0.5) * 0.15);\n    col *= max(smoothstep(0.1, 0.5, res.x) + 0.075 * b, res.y);\n    \n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 1.0) / 20.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}