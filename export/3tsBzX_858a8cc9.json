{"ver":"0.1","info":{"id":"3tsBzX","date":"1597738277","viewed":296,"name":"noise and raymarch","username":"zhengxiangkui","description":"noise and raymarch","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEP 200.\n\nfloat hash(float x) {\n\treturn fract(sin(x * 13452.) * 1000.);\n}\n\nfloat hash2(vec2 v) {\n\treturn fract(sin(dot(v, vec2(64.24232, 87.873)))*10232.);\n}\n\nfloat hash3(vec3 v) {\n\treturn fract(sin(dot(v, vec3(64.24232, 87.873, 76.635)))*10232.);\n}\n\nfloat valueNoise(vec2 v) {\n\tvec2 f = floor(v);\n    vec2 r = smoothstep(vec2(0.), vec2(1.), fract(v));\n    \n    float lb = hash2(f);\n    float rb = hash2(f+vec2(1.,0.));\n    float lt = hash2(f+vec2(0.,1.));\n    float rt = hash2(f+vec2(1.,1.));\n    \n    float b_line = mix(lb, rb, r.x);\n    float t_line = mix(lt, rt, r.x);\n    \n    return mix(b_line, t_line, r.y);\n}\n\nfloat valueNoise3(vec3 v) {\n\tvec3 f = floor(v);\n    vec3 r = smoothstep(vec3(0.), vec3(1.), fract(v));\n    \n    return mix(\n    \tmix(mix(hash3(f), hash3(f+vec3(1.,0.,0.)), r.x), \n            mix(hash3(f + vec3(0.,1.,0.)), hash3(f + vec3(1.,1.,0.)), r.x), \n            r.y),\n        mix(mix(hash3(f+vec3(0.,0.,1.)), hash3(f+vec3(1.,0.,1.)), r.x), \n            mix(hash3(f + vec3(0.,1.,1.)), hash3(f + vec3(1.,1.,1.)), r.x), \n            r.y),\n        r.z\n    );\n}\n\nfloat sphere(vec3 p) {\n    // p.x += dot(p.yz, p.yz);\n    // p.z -= dot(p.xy, p.xy) * cos(iTime);\n    float fireK = smoothstep(0.9,.5,valueNoise3(p*10.+iTime*3.));\n    // vec3 fire = mix(vec3(1.,0.,0.), vec3(1., 1., 1.), fireK);\n    p.y -=  fireK;\t\n\treturn length(p) - 1.;\n}\n\nvec2 dist(vec3 p) {\n    vec2 sphereDist = vec2(sphere(p-vec3(0., 0., 0.)), 2.);\n\tvec2 tableDist = vec2(p.y + 1., 1.);\n    return tableDist.x < sphereDist.x?tableDist:sphereDist;\n}\n\nvec3 calNormal(vec3 p) {\n\tvec2 k = vec2(0.001, 0.);\n    return normalize(vec3(\n    \tdist(p + k.xyy).x - dist(p - k.xyy).x,\n        dist(p + k.yxy).x - dist(p - k.yxy).x,\n        dist(p + k.yyx).x - dist(p - k.yyx).x\n    ));\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float y = -1.;\n    for(float i = 0.; i<STEP; i++) {\n    \tvec2 d = dist(ro + rd*t);\n        if(d.x < .001) {\n            y = d.y;\n        \tbreak;\n        }\n        if(t > STEP) {\n            t = -1.;\n            break;\n        }\n        t += d.x;\n    }\n    return vec2(t, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2. * (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 skyCol = vec3(0.2, 0.6, 1.) - 0.3 * uv.y;\n\tvec3 col = skyCol;\n    vec3 ro = vec3(0.,0.,3.);\n    vec3 rd = normalize(vec3(uv.xy, -1.));\n    vec2 t = raymarch(ro, rd);\n    if(t.x > 0.) {\n        vec3 mate = vec3(0.2);\n        vec3 sunCol = vec3(1.);\n        vec3 p = ro + rd*t.x;\n        vec3 n = calNormal(p);\n        vec3 sunDir = normalize(vec3(0.8,0.4,0.2));\n        float sunDiff = max(0., dot(n, sunDir));\n        float skyDiff = clamp(0.5 + 0.5*dot(vec3(0.,1.,0.), n), 0., 1.);\n    \tfloat sunShadow = step(raymarch(p + n*0.01, sunDir).x, 0.);\n        \n        col = mate * vec3(8.0,5.0,3.0) * sunDiff * sunShadow;\n        col += mate * skyDiff * vec3(0.2, 0.6, 1.);\n        if(t.y > 1.) {\n            float fireK = smoothstep(0.2,.5,valueNoise3(p*10.+iTime*3.));\n            vec3 fire = mix(vec3(1.), vec3(1., 0.5, 1.), fireK);\n        \tcol *= fire;\n        } else {\n        \t// col += hash(uv.y);\n        }\n    }\n    col = pow(col, vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}