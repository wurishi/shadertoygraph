{"ver":"0.1","info":{"id":"ls33WH","date":"1460190537","viewed":287,"name":"Sanctuary","username":"cabbibo","description":"working on some more emotional scenes.","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["sdf","monk","relaxtion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldX3Rf","filepath":"https://soundcloud.com/whoarei/i-love-you-cookie","previewfilepath":"https://soundcloud.com/whoarei/i-love-you-cookie","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Trying to understand the code from\n// http://lgdv.cs.fau.de/get/2234\n\n\n// Using some noise code : https://www.shadertoy.com/view/4sfGzS\n// And space twist code: https://www.shadertoy.com/view/XtjSDK\nconst float t_min = .00001;\nconst float t_max = 35.;\nconst int MAX_ITERATIONS = 200;\nconst float infinite = 100000.;\nconst float PI = 3.14159;\n\nconst float MAX_TRACE_DISTANCE = 40.0; // max trace distance\nconst float INTERSECTION_PRECISION = 0.001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 1000;\n\nconst bool forceHit = false;\n\nfloat pixelRadius;\n\nfloat cycleTime;\n\nvec4 grow = vec4( 1. );\n\nvec3 lightPos = vec3( 0. , 6. , 0.);\n\n#define time iTime\n\nvec3 hsv(float h, float s, float v){\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ){\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( float radius , out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse ){\n    float an = 0.3 + 10.0*mouse.x;\n\tcamPos = vec3(radius*sin(an),2.,radius*cos(an));\n    camTar = vec3(0.0,1.0,0.0);\n}\n\n\n\n\n\n\n\n\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x ){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n  \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat fNoise( vec3 p ){\n   \n    float n;\n    \n    n += noise( p * 20. ) * .5;\n    n += noise( p * 200. ) * .1;\n    n += noise( p * 60. ) * .3;\n    n += noise( p * 5. );\n\n    n /= 2.;\n    \n    return n;\n   \n}\n\n// From: https://www.shadertoy.com/view/4sfGzS\nfloat tnoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nvec3 xrotate(vec3 pos , float t) {\n  return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t)) * pos;\n}\nvec3 yrotate(vec3 pos , float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t)) * pos;\n}\nvec3 zrotate(vec3 pos , float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0) * pos;\n}\n\n\n\nfloat sdPlane( vec3 p, vec4 n ){\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdCone( vec3 p, vec2 c ){\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\nfloat sdCappedCone( in vec3 p, in vec3 c ){\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\nfloat sdHexPrism( vec3 p, vec2 h ){\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\n\nfloat opS( float d1, float d2 ){\n    return max(-d1,d2);\n}\nvec2 opS( vec2 d1, vec2 d2 ){\n    return  -d1.x > d2.x  ? vec2(-d1.x , d1.y) : d2 ;\n}\nfloat opU( float d1, float d2 ){\n    return  d1 < d2 ? d1 : d2 ;\n}\nvec2 opU( vec2 d1, vec2 d2 ){\n    return  d1.x < d2.x ? d1 : d2 ;\n}\n\nvec2 smoothU( vec2 d1, vec2 d2, float k){\n    float a = d1.x;\n    float b = d2.x;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return vec2( mix(b, a, h) - k*h*(1.0-h), mix(d2.y, d1.y, pow(h, 2.0)));\n}\n\nfloat opRepSphere( vec3 p, vec3 c , float r){\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q  , r );\n}\n\n\n\n\nfloat cBase( vec3 pos ){\n\n  float c = sdCone( pos , normalize(vec2( 1. , 1. )));\n  float s = sdPlane( pos , vec4( 0 , 0. , 1. , 1.4 ) );\n\n  return opS( s , c );\n\n}\n\n\n// give a base ID to pass out of\n// first build the fields\n// than connnect to ID numbers, using  by passing through baseID\n// write out baseID for later use.\nvec2 body( vec3 pos , out float baseID ){\n\n  float c = sdSphere( pos* vec3( 1. , .55 , 1. )  , 1. );\n  float p = sdPlane( pos * vec3( 1. , .5 , 1. ), vec4( -1. , 0. , 0. , 0. ) );\n\n  \n  //baseID += 1.;\n  vec2 torso = opS( vec2( p , baseID + 1. ) , vec2( c , baseID + 1. )  );\n\n\n  //float cb = sdCappedCone( pos - vec3( 1. ) , normalize(vec3( 1. , 1. , 1. )));\n\n  vec3 q = xrotate( pos - vec3( -.2 , -.8 , 0. ) , -PI / 2. );\n\n  float cb = cBase( q );\n  vec2 cloakBase = vec2( cb , baseID + 0. );\n\n    \n   // head\n  float n = 0.;// abs( noise( pos * 10.1 + time * .5 ));\n  vec2 h = vec2( sdSphere( pos - vec3( 0.2 , 1.2 , 0. ) , .45 - n * .05 )   , baseID + 7. );\n\n  vec2 bod = smoothU( cloakBase, torso ,.9);\n\n // float n2 =  abs( noise( pos * 3. + time * .5 ));\n  //bod.x -= n2 * .06;\n    \n\n\n  vec2 fullBod = smoothU( bod , h , .3 );\n   \n  float b1 = sdSphere( pos - vec3( 0.3 , 1.2 , 0.1 ) , .32);\n  float b2 = sdSphere( pos - vec3( 0.3 , 1.2 , -0.1 ) , .32);\n  float balls= opU( b1, b2 );\n   \n  vec2 eyes = vec2( balls , baseID + 8.);\n  return  opS(  eyes ,smoothU( bod , h , .3 ));\n  //return vec2( c , 1. );\n\n\n}\n\n// from  https://www.shadertoy.com/view/XtjSDK\nvec3 mapP( vec3 p )\n{\n    p.xyz += .400*sin(  3.*p.yzx )*grow.x;\n    p.xyz += 0.300*sin(  6.0*p.yzx )*grow.y;\n    p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;\n    p.xyz += 0.100*sin( 20.0*p.yzx )*grow.w;\n    return p;\n}\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos , float io){  \n    \n  \tfloat id = 0.;\n \tvec2 res = vec2( 100000. , -1.);\n    \n    vec3 p2 = pos;// - vec3( -4. , 0., 0.);\n    \n    //pos.x = mod( pos.x , 1.5 );\n    float degree = atan( p2.x , p2.z );\n    \n    float ogD = degree;\n    \n    ///degree += iTime;// * (1. + lor * .2);\n    float l = length( p2.xz );\n    \n    degree = mod( degree - 3.14159  / 8. , 3.14159  / 4. );\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n\n    \n    //bodys\n   \tres = body( yrotate( p2 - vec3(3. , 0., 6.) ,-PI/2.) , id );\n    \n    \n    float n = tnoise( pos + vec3( 0. , iTime , 0.) ) + tnoise( pos * 2. + vec3( 0. , iTime * 1.4 , 0.) ) ;\n   \n    \n    \n    // Shrine\n    res = smoothU( res , vec2( sdPlane( pos , vec4( 0., 1. , 0. , 2.)) , id + 3. ) , 1. );\n    res = smoothU( res , vec2( -sdSphere( pos - vec3( 0. , -16. , 0.) , 23. ) , id + 4.) ,1.);\n    \n    \n    \n    \n     //light\n    res = smoothU( res , vec2( (sdSphere( pos - lightPos  , 3. ) + n * .8)   , id+5.) , 2.5);\n    \n   // res = smoothU( res , vec2( (sdSphere( pos - lightPos - vec3( 0. , 1.5 , 0.)  , 1. ))  , id+5.) , .0);\n    \n    \n    \n    // Pedestal\n    vec3 q = xrotate( pos  - vec3( 0 , -1.2, 0.)  , -PI / 2. );\n    res = smoothU( res , vec2( sdHexPrism(q , vec2( .5 , 1. ) ) , id + 5.) ,.6);\n    \n    \n    //JEWEL\n    \n    q = mapP( pos + vec3( 0. , -1. , 0.) );\n    //res = opU( res , vec2( (length(q)-(.4 + .6 * -cycleTime) ) * .1, id + 7.)  );\n     res = opU( res , vec2( (length(q)-.4) * .1, id + 7.)  );\n    \n    vec2 eyes = vec2( length(pos + vec3( 0. , -1. , 0.))-(.3 + .15 * -cycleTime)  , id + 8. );\n    \n    eyes.x += noise( pos  * 20.) * .04;\n    res = opS(  eyes ,res);\n    \n    eyes = vec2( length(pos + vec3( 0. , -1. , 0.))-(.2 + .1 * -cycleTime)  , id + 6. );\n    eyes.x += noise( pos  * 20.) * .04;\n    res = opU(  eyes ,res);\n    //res = opS(vec2(sdSphere( pos - vec3( 0. , -1. , 0.) , 1.3 ), id + 7. ),  res );\n    \n    \n    // Inside trace function\n   \n    if( io < 0. ){\n        \n        res = vec2( -(sdSphere( pos - lightPos  , 3. ) - n * .8) * .1  , id+5.);\n    }\n    \n    return res;\n    \n}\nvec2 calcIntersection( in vec3 ro, in vec3 rd , float io ){\n    float h = INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n    if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n    vec2 m = map( ro+rd*t , io );\n    h = m.x;\n    t += h;\n    id = m.y;\n\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return vec2( res , id );\n}\n\n\n\n\n\n\n//From\n//http://lgdv.cs.fau.de/get/2234\nvec2 calcIntersection( vec3 ro , vec3 rd , float io , float TAKEMEEOUT){\n    \n    // o, d : ray origin, direction (normalized)\n    // t_min, t_max: minimum, maximum\n    // pixelRadius: radius of a pixel\n    // forceHit: boolean enforcing to\n    // candidate_t value as result \n    \n\tfloat omega = 1.2;\n    float t = t_min;\n    float candidate_error = infinite;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float id = -10.;\n\n    // are we inside or outside the object?\n    // if inside reverse the field!\n    float functionSign = map(ro, io).x < 0. ? -1. : 1.;\n   // functionSign = 1.;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++ ) {\n        \n        vec2 mapVal = map(rd*t + ro,io); \n        \n        id = mapVal.y;\n        \n        float signedRadius = functionSign * mapVal.x; \n\n        float radius = abs(signedRadius);\n\n        bool sorFail = omega > 1. && (radius + previousRadius) < stepLength;\n\n        if (sorFail) { \n\n            stepLength -= omega * stepLength;\n            omega = 1.;\n\n        } else {\n\n            stepLength = signedRadius * omega;\n\n        } \n\n        previousRadius = radius; \n        \n        float error = radius / t;\n\n\n        if (!sorFail && error < candidate_error) { \n            candidate_t = t;\n            candidate_error = error;\n        }\n\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n\n        t += stepLength; \n\n    }\n\n    if ((t > t_max || abs(candidate_error) > pixelRadius) && !forceHit){\n       // return vec2( infinite , -1. );\n    }\n\n    return vec2( candidate_t , id );\n\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos  , float io ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n    \n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy,io).x - map(pos-eps.xyy,io).x,\n\t    map(pos+eps.yxy,io).x - map(pos-eps.yxy,io).x,\n\t    map(pos+eps.yyx,io).x - map(pos-eps.yyx,io).x );\n    \n\treturn normalize(nor);\n}\n\n\n\n\n\nvec3 doMonkCol( vec3 rd , vec3 p , vec3 n , float match, vec2 res){\n    \n    vec3 color;\n    \n    vec3 tmpCol;\n    float fN = (noise( p * 20. ) * .6  + noise( p * 2. ) * .3 + noise( p * .5) +  noise( p * .1) + noise( p * 5. ));\n    vec3 nNorm =  n +.3 * normalize(vec3( tnoise( p * 5. ) , tnoise( p * 10. ),tnoise( p * 13. )));\n  \n      vec3 refl = reflect( rd , nNorm );\n        vec3 cubeCol = texture( iChannel2 ,refl ).xyz;\n        vec3 buildingCol =  cubeCol * vec3( 1. , .6 , .4 ) * 2.;//vec3( match ) * fN * fN *fN * .1 * ;\n\t\t\n        \n     color = mix(cubeCol * vec3( 0.6 , .6 , 1. ) * 2.,buildingCol, p.y * 2. );\n   \n    \n   \n    float eyeM = dot( rd , n );\n    \n    \n    vec3 lightDir = p - vec3( 0.,1. ,0.);\n    \n    \n    vec3 refl2 = reflect( normalize( lightDir ) , normalize(nNorm) );\n    float rMatch = dot( refl2, rd );\n    \n    \n    \n    color += 2. * vec3( .5 , .2 , .1 ) * max( 0. , pow(rMatch,4.));\n    \n     \n    color += pow( rMatch , 4. ) * vec3( 1. , .1 , .2 );\n     \n    \n    \n    vec4 tCol = texture( iChannel0 , vec2( -rMatch,0. ) );\n    color *= (tCol.x+.2);\n    \n    \n    //color += (1.-tCol.x* 2.) * vec3( .3 , .5 , 1. );\n    \n    \n    float v = pow((1.+eyeM),5.);\n    color += vec3(1. , .2 , 0.) * abs(v);\n    if(  res.y == 2. ){\n     color = vec3( 1. , 0., 0.);   \n    }else if( res.y == 3. ){\n     //color = n * .5 + .5;   \n    }\n    \n    tmpCol = color;\n   \n   // color= mix(tmpCol, vec3( 1. ), cycleTime) ;\n    \n \treturn color;// * (n * .5 + .5);   \n}\n\n\nvec3 doSecondColor(vec2 res, vec3 rd , vec3 p , vec3 n ){\n    \n    vec3 color;\n    vec3 lightDir = normalize(p - lightPos);\n    float match = dot( -lightDir , n );\n    \n \t// MONKS\n    if( res.y < 2.4 ){\n\n        color = doMonkCol( rd, p , n , match, res );  \n\n    }\n\n    //Building\n    if( res.y >= 2.4 && res.y < 6. ){\n        color = vec3(match);\n\n\n        float fN = (noise( p * 20. ) * .6  + noise( p * 2. ) * .3 + noise( p * .5) +  noise( p * .1) + noise( p * 5. ));\n       \n        \n        vec3 refl = reflect( rd , n );\n        vec3 cubeCol = texture( iChannel2 ,refl ).xyz;\n        vec3 buildingCol =  cubeCol * vec3( 0.2 , .4 , 1. ) * 2.;\n        \n        buildingCol = match * match * fN * fN * vec3( 1. , .4 , .2 );//vec3( match ) * fN * fN *fN * .1 * ;\n\t\t\n        \n        color = buildingCol;\n   \n\n\n    }\n    \n    return color;\n           \n    \n    \n}\n\nvec3 doLightCol( vec3 rd , vec3 p , vec3 n ){\n \n    vec3 refr = refract( rd , n , .9 );\n    \n    vec2 res = calcIntersection( p + refr * .1 , refr , -1.);\n    \n    if( res.y > -.5 ){\n        \n      vec3 p2 = p + refr * ( res.x + .1);\n      vec3 n2 = calcNormal( p2 , -1. );\n        \n        \n        if( res.y < 5.){\n         return vec3( 1. );   \n            \n        }\n        \n      vec3 refr2 = refract( refr , n2 , .9 );\n        \n      vec2 res2 = calcIntersection( p2 + refr2 * .1 , refr2, 1.);\n        \n        if( res2.y >-.5){\n            \n            vec3 p3 = p2 + refr2 * ( res2.x + .1 );\n      \t\tvec3 n3 = calcNormal( p3 , 1. );\n            \n            \n            \n            return doSecondColor( res2 , refr2,p3,n3);\n            \n        }else{\n         return vec3( 1. , 0. , 0.);   \n        }\n       \n        \n        \n    }else{\n     return vec3( 1. ,0., 0.);   \n    }\n   \n    \n}\n\n\n\nvec3 doColor(vec2 res, vec3 rd , vec3 p , vec3 n , float skip){\n    \n    vec3 color;\n    vec3 lightDir = normalize(p - lightPos);\n    float match = dot( -lightDir , n );\n    \n \t// MONKS\n    if( res.y < 2.4 ){\n\n        color = doMonkCol( rd, p , n  , match, res );  \n\n    }\n\n    //Building\n    if( res.y >= 2.4 && res.y < 6. ){\n        color = vec3(match);\n\n\n        float fN =   noise( p * 2. ) * .4 + noise( p * .5) +  noise( p * .1) ;\n       // vec3 buildingCol = vec3(1. - fN * fN * .03 , .5 , .4) * vec3( match ) * fN * fN *fN * .1;\n\n        n = normalize( n + .3 * vec3( tnoise( p * 2. + iTime) , tnoise( p * 2. + 100. + iTime) ,tnoise( p * 2. + 400.+ iTime )));\n        \n        vec3 refl = reflect( rd , n );\n        vec3 cubeCol = texture( iChannel2 ,refl ).xyz;\n        \n        \n        vec3 buildingCol =  cubeCol * vec3( 0.2 , .4 , 1. ) * 2.;//vec3( match ) * fN * fN *fN * .1 * ;\n\t\t\n        if( skip == 0. ){\n            \n        vec3 lightCol = doLightCol(  rd, p , n );\n\n        float mixVal = clamp( (res.y - 4.4) * 5. , 0. , 1.);\n            \n        if( p.y < 1. ){ mixVal = 0.; }\n\n        color = mix( buildingCol , lightCol , mixVal );\n            \n        }else{\n            \n            color = buildingCol;\n        }\n        \n        vec3 monkCol = doMonkCol( rd, p , n  , match, res );\n        \n       color = mix(  monkCol, color , clamp((res.y - 2.4) *.6 , 0., 1.) );\n\n\n    }\n    \n    //Pedestal\n    if( res.y >= 6. && res.y < 7. ){\n        \n       float fN =   noise( p * 2. ) * .4 + noise( p * .5) +  noise( p * .1) ;\n        color = vec3(1. - fN * fN * .03 , .5 , .4)  * fN * fN *fN * .1;\n        \n        //n = normalize( n + .3 * vec3( noise( p * 20. + iTime) , noise( p * 20. + 100. + iTime) ,noise( p * 20. + 400.+ iTime )));\n        \n        vec3 refl = reflect( rd , n );\n        vec3 cubeCol = texture( iChannel2 ,refl ).xyz;\n\n      \tcolor = (cubeCol * dot( -n , rd )) + texture( iChannel2 ,refract(rd, n,.8)).xyz;\n        color *= vec3( 1. , .8 , .3 );\n    }\n    \n    if( res.y >= 7. && res.y < 8. ){\n        //float fN = (noise( p * 20. ) * .6  + noise( p * 2. ) * .3 + noise( p * .5) +  noise( p * .1) + noise( p * 5. ));\n        //vec3 buildingCol = vec3(1. - fN * fN * .03 , .5 , .4) * vec3( match ) * fN * fN *fN * .1;\n\t\t\n        vec3 nNorm = n;// n +.3 * normalize(vec3( hash( p.x * 100. ) , hash(p.y * 20. ), hash( p.z * 100.)));\n        vec3 refl = reflect( lightDir , normalize(nNorm) );\n        float m = dot( refl , -rd );\n        vec3 refr = refract(rd , n,.4 );\n        \n        vec3 cubeMap = texture( iChannel2 , refl ).xyz;\n        \n        float refrMatch  = dot( lightDir , refr );\n        vec3 aCol = texture( iChannel0 , vec2( abs( match )* .2, 0. )).xyz;\n       \t//\n        //pow( m , 21. ) * \n        color =cubeMap * hsv( aCol.x * .2  , 1. , 1.);// +  max( pow(m , 11. ) ,0.) * vec3( 1. , .5 , 0.) + match * vec3( .6 , .3 , .2 ) ;\n    }\n    \n    if( res.y >= 8. ){\n        \n        vec3 refl = reflect( lightDir , normalize(n) );\n        vec3 cubeMap = texture( iChannel2 , refl ).xyz;\n        \n        \n    \tcolor = cubeMap * vec3( 1.4 , .2 , 1. ) * 2.;\n    }\n    \n    return color;\n           \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 10.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    cycleTime = sin( iTime * .6 );\n    \n    \n    grow.x = .1 * (1. - cycleTime);\n    grow.y = .6 * (1. - cycleTime);\n    grow.z = .4 * (1. - cycleTime);\n    grow.w = .6 * (1. - cycleTime);\n    \n    \n    vec2 mPos = vec2( iTime * .03 , 0.);\n    \n    doCamera( ( cycleTime + 1.3) * 6. , ro , ta , time , mPos );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    \n    float pixel = .5 / iResolution.y;\n    \n  \tvec3 rdu = normalize( camMat * vec3(p.xy + vec2(pixel, 0.) ,2.0) );\n    vec3 rdd = normalize( camMat * vec3(p.xy - vec2(pixel, 0.),2.0) );\n\n    vec3 pu = ro + rdu;\n    vec3 pd = ro + rdd;\n    \n    // Can probably alter this for a speed up too\n    pixelRadius = length( pu - pd ) / 1.;\n    \n    \n    vec2 res = calcIntersection( ro , rd  , 1.);\n\n\t\n    vec3 color = vec3( 1. );\n    \n    if( res.y > -.5 ){ \n        \n        vec3 pos = ro + rd * res.x;\n        vec3 n = calcNormal( pos , 1.);\n        color = doColor( res , rd , pos , n , 0. );\n        \n        float moreCenter = clamp( 1.0 - (length(pos - vec3( 0. , 1. , 0.)) * (.5 + .5 * -cycleTime)) * .2 , 0. , 1.);\n        color *= moreCenter;\n\n    }\n    \n   //color = abs( color );\n    \n    \n    \n\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}","name":"Image","description":"","type":"image"}]}