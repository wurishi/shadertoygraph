{"ver":"0.1","info":{"id":"3tsfW4","date":"1596744600","viewed":76,"name":"fork- [steb] raymarcher","username":"jorge2017a1","description":"fork- [steb] raymarcher","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["forkstebraymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//modificado por jorge2017a1\n\n//referencia https://www.shadertoy.com/view/wty3DK\n//Creado por steb en 2020-01-25\n\nconst float SURFACE_DISTANCE = .0001;\n\nconst int MAX_STEPS = 500;\nconst int MAX_SHADOW_STEPS = 50;\n\nconst float MAX_DISTANCE = 50.;\nconst float MAX_REFLECT_DISTANCE = 5.;\nconst float MAX_SHADOW_DISTANCE = 15.;\n\nconst float FOV = 600.;\nconst vec2 NORMAL = vec2(0, 0.01);\n\nconst vec3 SUN_DIRECTION = normalize(vec3(0, -1, 1));\nconst vec3 AMBIENT_COL = vec3(0.08, 0.1, 0.14);\nconst float SHADOW_SOFTNESS = .25;\n\nconst float DEG_TO_RAD = 0.01745329251;\n\n\n\n#define ZERO \t\tvec3(0.0)\n#define X\t\tvec3(1.0,0.0,0.0)\n#define Y\t\tvec3(0.0,1.0,0.0)\n#define Z\t\tvec3(0.0,0.0,1.0)\n#define R\t\t2.0\n#define T\t\t4\n\n\nconst vec3 CAMERA_ROTATION = vec3(-25. * DEG_TO_RAD, 35. * DEG_TO_RAD, -15. * DEG_TO_RAD);\nconst mat3 CAMERA_ROTATION_MATRIX = mat3(1, 0, 0,\n                                         0, cos(CAMERA_ROTATION.x), -sin(CAMERA_ROTATION.x),\n                                         0, sin(CAMERA_ROTATION.x), cos(CAMERA_ROTATION.x)) * \n    \t\t\t\t\t\t\t\tmat3(cos(CAMERA_ROTATION.y), 0, sin(CAMERA_ROTATION.y),\n                                        0, 1, 0,\n                                        -sin(CAMERA_ROTATION.y), 0, cos(CAMERA_ROTATION.y)) * \n    \t\t\t\t\t\t\t\tmat3(cos(CAMERA_ROTATION.z), -sin(CAMERA_ROTATION.z), 0,\n                                        sin(CAMERA_ROTATION.z), cos(CAMERA_ROTATION.z), 0,\n                                         0, 0, 1);\n\nvec3 mcolor;\n\n\n\n\n\n//-----------------------------\n\nfloat rand(vec3 seed){\n\treturn fract(sin(dot(seed, vec3(12.9898,78.233,233.33))) * 43758.5453);\n}\n\nfloat rand(vec2 seed)\n{\n\treturn rand(vec3(seed,0.0));\n}\n\nfloat rand(float seed)\n{\n\treturn rand(vec3(seed,0.0,0.0));\n}\n\nfloat noise3(vec3 pos)\n{\n\tfloat t = -iTime*0.0;\n\tvec3 base = floor(pos*R+t);\n\tvec3 pot = fract(pos*R+t);\n\tvec3 f = smoothstep(0.0,1.0,pot);\n\tfloat w1 = mix(rand(base),    rand(base+X),    f.x);\n\tfloat w2 = mix(rand(base+Z),  rand(base+X+Z),  f.x);\n\tfloat w3 = mix(rand(base+Y),  rand(base+X+Y),  f.x);\n\tfloat w4 = mix(rand(base+Y+Z),rand(base+X+Y+Z),f.x);\n\treturn mix(\n\t\tmix(w1,w3,f.y),\n\t\tmix(w2,w4,f.y),\n\t\tf.z\n\t);\n}\n\n\nfloat fbm3(vec3 pos)\n{\n\tfloat total = 0.0, amp = 1.0;\n\tfor (int i = 0; i < T; i++){\n\t\ttotal += noise3(pos) * amp; \n\t\tpos *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn 1.0-exp(-total*total);\n}\n//\n\n//------------------------------------------\nfloat SDF_Plane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat SDF_Sphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat SDF_Box(vec3 p, vec3 c, vec3 b)\n{\n    p -= c;\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat SDF_Torus(vec3 p, vec3 c, vec2 t)\n{\n    p -= c;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\n\n#define X\t\tvec3(1.0,0.0,0.0)\n#define Y\t\tvec3(0.0,1.0,0.0)\n#define Z\t\tvec3(0.0,0.0,1.0)\n\nfloat sdplane(vec3 pos,vec3 normal,float h)\n{\n\treturn dot(pos,normalize(normal))-h;\n}\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdtorus( vec3 p, vec3 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y+t.z);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat solidSphere(vec3 pos, vec3 center, float radius)\n{\n\tfloat d = distance(pos,center)-radius;\n\treturn d;\n}\n\nfloat sdsphere(vec3 pos, vec3 center, float radius)\n{\n\tfloat d = solidSphere(pos,center,radius);\n\treturn d;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdbox(vec3 pos,vec3 center,vec3 size)\n{\n  \tvec3 d = abs(pos-center) - size;\n \treturn length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n///------------------------------------\n\n\nvec4 getDist(vec3 p)\n{\n\tfloat id = 0.0;\n\tfloat d = 9999.0;\n    \n\tfloat obj = id;\n\t#define RADIUS\t\t2.0\n    \n    vec2 res = vec2(9999, 0);\n    \n    float sdpl1=sdplane(p,Y,-RADIUS);\n    float sds1= sdSphere(p-vec3(-10.0,0.0,0.0), 2.0 );\n    float sdb1= sdBox(p-7.0*Z-5.0*X,vec3(RADIUS) );\n    \n    float sdb3= sdbox( p,vec3(-10.0,0.0,-10.0), vec3(2.0,1.0,2.0) );\n    float sdc1 =sdCylinder(p+5.*X-5.*Z,vec2(1.0,5.0));\n    float sdt1=sdtorus(p+5.*X-5.*Z,vec3(2.0,0.5,1.5));\n    float sdpl2=sdsphere(p,1.25*(0.0*X-1.0*Z-Z)*RADIUS,RADIUS);\n    float sdpl3=sdsphere(p,1.25*(2.0*X-2.0*Z-Z)*RADIUS,RADIUS);\n        \n    \n    res =opU(res, vec2(sdb1,1.0)); \n    res =opU(res, vec2(sdb3,2.0)); \n    res =opU(res, vec2(sdpl1,3.0)); \n    res =opU(res, vec2(sdc1,4.0)); \n    res =opU(res, vec2(sdt1,6.0)); \n    \n    res =opU(res, vec2(sds1,7.0)); \n    res =opU(res, vec2(sdpl2,8.0)); \n    res =opU(res, vec2(sdpl3,9.0)); \n    \n    \n   \n    vec3 color=GetColor(int(res.y));\n  \n    return vec4(res.x, color);\n}\n\n\n\n\nvec4 rayMarch(vec3 rO, vec3 rD, float maxDistance)\n{   \n    float dist = 0.;\n    vec3 col;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec4 dS = getDist(rO + rD * dist);\n        dist += dS.x;\n        col = dS.yzw;\n        //col = mcolor;\n        if (dS.x < SURFACE_DISTANCE || dist > MAX_DISTANCE) \n        {\n            break;\n        }\n    }\n    \n    return vec4(dist, col.rgb);\n}\n\nfloat shadows(vec3 rO, vec3 lD)\n{\n    float shadow = 1.;\n    float t = 0.;\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++)\n    {\n        float d = getDist(rO + lD*t).x;\n        shadow = min(shadow, 0.5 + 0.5 * d / (SHADOW_SOFTNESS * t));\n        if (shadow < 0. || t > MAX_SHADOW_DISTANCE) break;\n        t += d;\n    }\n    shadow = max(shadow, 0.);\n    return smoothstep(.5, 1., shadow);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n        getDist(p - NORMAL.yxx).x,\n        getDist(p - NORMAL.xyx).x,\n        getDist(p - NORMAL.xxy).x\n        ));\n}\n\nvec3 shade(vec3 p, vec3 lightDir, vec3 rD, vec3 nrm, vec3 baseCol)\n{\n    vec3 col = vec3(0,0,0);\n    vec3 diff = vec3(max(0., dot(nrm, lightDir))) * baseCol;\n    float spec = pow(max(0., dot(-rD, reflect(lightDir, nrm))), 40.) * .6;\n    col = diff + spec;\n\n    col *= vec3(shadows(p - lightDir * 0.01, -lightDir));\n    col += AMBIENT_COL;\n    return col;\n}\n\nvec3 renderSky(vec3 rD)\n{\n    return vec3((1. - rD.y) / 3. + 0.25, (1. - rD.y) / 5. + 0.3, 0.8 - rD.y / 8.);\n}\n\n\n//----------------------------------------------------\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    vec2 uv = fragCoord - iResolution.xy / vec2(2,2);\n    uv = uv - vec2(0.5, 0.5);\n    uv /= FOV;\n    \n    \n    \n    float t=mod(iTime, 200.0);\n    \n    vec3 rO = vec3(15.0+2.0*cos(t), 10., -26.0+2.0*sin(t));\n    \n    //rO= getMouse(rO);\n    vec3 rD = CAMERA_ROTATION_MATRIX * normalize(vec3(uv.x, uv.y, 1));\n\n    vec4 dist = rayMarch(rO, rD, MAX_DISTANCE);\n    vec3 col = vec3(0,0,0);\n    \n    if (dist.x < MAX_DISTANCE)\n    {\n        vec3 p = rO + dist.x * rD;\n    \tvec3 nrm = getNormal(p);\n        \n        vec3 lightDir = normalize(SUN_DIRECTION );\n        \n        float k = smoothstep(0.4,0.7,fbm3(p));\n        vec3 albedo =dist.yzw;\n        albedo = mix(vec3(1.0),mix(vec3(0.5,0.32,1.0),albedo,1.0-k),0.5);\n        \n        col = shade(p, lightDir, rD, nrm, dist.yzw*albedo);\n        \n        vec3 ref = reflect(rD, nrm);\n        vec4 refDist = rayMarch(p + (ref * 0.01), ref, MAX_REFLECT_DISTANCE);\n\t\tvec3 reflectCol;\n        \n        if (refDist.x < MAX_REFLECT_DISTANCE)\n        {\n            vec3 refP = (p + ref * 0.01) + (ref * refDist.x);\n            vec3 refNrm = getNormal(refP);\n            reflectCol = shade(refP, lightDir, ref, refNrm, refDist.yzw);\n        }\n        else\n        {\n        \n            reflectCol = renderSky(ref);\n        }\n        \n        col = mix(col, reflectCol, clamp(pow(1. - dot(rD, nrm), 4.), 0., 1.));\n    }\n    else \n    {\n    \t\n        col = renderSky(rD);\n    }\n\n    //fragColor = vec4(col,1.0);\n      fragColor = vec4(pow(max(col, 0.), vec3(1./1.63)), 1); \n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n\n\nvec3 GetColor(int i)\n{\n    \n    float m;\n    \n\nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n\n\n} ","name":"Common","description":"","type":"common"}]}