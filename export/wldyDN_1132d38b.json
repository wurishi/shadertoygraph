{"ver":"0.1","info":{"id":"wldyDN","date":"1609187156","viewed":169,"name":"Noisy Snowglobe","username":"lirfu","description":"A simple snowglobe with noise used as snow.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise","christmas","cubemap","tree","snow","snowglobe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A simple little snowglobe.\n//\n// Use the mouse to drag the camera around for a better view.\n\n\n#define PI 3.14159265359\n#define sample(x) texture(iChannel0, (x)/iResolution.xy)\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nfloat G( in vec2 p, in float sigma ) {\n\treturn exp(-(dot(p,p)) / (2. * sigma * sigma)) / (2. * PI * sigma * sigma);\n}\n\nvec3 GaussBlur( in vec2 co, in int dim, in float sigma ) {\n    vec3 c = vec3(0);\n    float z = 0.;\n    for (int i = -dim; i <= dim; ++i) {\n\t\tfor (int j = -dim; j <= dim; ++j) {\n\t\t\tfloat g = G(vec2(i,j), sigma);\n            c += g * sample( co + vec2(i,j) ).rgb;\n            z += g;\n\t\t}\n\t}\n    return c / z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = GaussBlur(fragCoord, 3, .8);\n    fragColor.rgb = ACESFilm(fragColor.rgb);\n    fragColor = pow(fragColor, vec4(1./2.4));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\nstruct Ray {\n    vec3 r0;\n    vec3 rd;\n    float t;\n};\n\nstruct Hit {\n    vec3 p;\n    float d;\n    int id;\n    vec3 n;\n};\n\nvec3[] diffuse = vec3[] (\n    vec3(0.),\n    vec3(.9),\n    vec3(0.),\n    vec3(1.2,1.2,1.2),\n    vec3(.5,.9,.5),\n    vec3(0.)\n);\n\nvec3[] metallic = vec3[] (\n    vec3(0.),\n    vec3(0.),\n    vec3(.9,.7,.4),\n    vec3(0.),\n    vec3(0.),\n    vec3(0.)\n);\n\nvec3[] emissive = vec3[] (\n    vec3(0.),\n    vec3(0.),\n    vec3(0.),\n    vec3(0.),\n    vec3(0.),\n    vec3(10.,10.,.0)\n);\n\nbool[] refractive = bool[] (\n    false, true, false, false, false, false\n);\n\n\nRay r;\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCone( in vec3 p, in vec2 q, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  //vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 opTwist(in vec3 p )\n{\n    const float k = 80.0; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\nvoid updateHit(inout Hit h, float d, int id, vec3 n) {\n    if (d < h.d)\n    {\n        h.d = d;\n        h.id = id;\n        h.n = n;\n    }\n}\n\nHit scene(vec3 x) {\n    Hit h;\n    h.d = 1e32;\n    h.id = 0;\n    h.p = x;\n    float d;\n    \n    // Glass orb.\n    d = sdSphere(x, 1.);\n    if (d > 0.) {\n        updateHit(h, d, 1, normalize(x - vec3(0.,0.,0.)));\n    } else {  // Inside orb.\n        vec3 l = 0.5*texture(iChannel1, x - vec3(0.,-.2*iTime,0.)).xyz \n            + 0.5* texture(iChannel1, x - vec3(0.01,-.2*iTime+0.03,0.02)).xyz;\n        \n        // Tree.\n        float b = d;\n        d = sdCone(x - vec3(0.,.27,0.), vec2(.1,-.33), .1);\n        updateHit(h, d, 4, -r.rd);\n        d = sdCone(x - vec3(0.,.03,0.), vec2(.2,-.33), .1);\n        updateHit(h, d, 4, -r.rd);\n        d = sdCone(x - vec3(0.,-.2,0.), vec2(.3,-.33), .1);\n        updateHit(h, d, 4, -r.rd);\n        \n        /*if (d < b && d < 1e-1) { // Lights.\n            b = 0.;\n            updateHit(h, d-b, 5, -r.rd);\n        }*/\n        \n        \n        if (length(l) < 0.3) {\n            d = length(l) - 0.4;\n            updateHit(h, d, 3, -r.rd);\n        }\n        \n        \n        \n        // Star.\n        d = sdTorus(opTwist(x - vec3(0.,.3,0.)), vec2(.06,.018));\n        updateHit(h, d, 5, -r.rd);\n        \n        // Bottom.\n        d = x.y + .6;\n        updateHit(h, d, 3, -r.rd);\n    }\n        \n    // Holder.\n    d = sdRoundBox(x - vec3(0.,-.98,0.), vec3(.6,.02,.6), .1);\n    updateHit(h, d, 2, vec3(0.));\n    \n    return h;\n}\n\nvec3 normal(vec3 x) {\n    float eps = 1e-1;\n    vec2 e = vec2(-1.,1.);\n    return normalize(e.yxx * scene(x + e.yxx*eps).d \n        + e.xxy * scene(x + e.xxy*eps).d\n        + e.xyx * scene(x + e.xyx*eps).d\n        + e.xxx * scene(x + e.xxx*eps).d);\n}\n\nHit trace(inout Ray r) {\n    Hit h;\n    h.d = 1e32;\n    for (int i=0; i<80 && h.d > 1e-3; i++) {\n        h = scene(r.r0 + r.rd * r.t);\n        r.t += h.d;\n    }\n    if (h.n == vec3(0.)) {\n        h.n = normal(h.p);\n    }\n    if (h.d > 1e-2) {\n        h.id = 0;\n        h.n = -r.rd;\n    }\n    return h;\n}\n\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055, vec3(2.4)), x / 12.92, step(x, vec3(0.04045)));\n}\n\nvec3 envmap(vec3 r) {\n    return srgb_linear(texture(iChannel0, r).xyz);\n}\n\n#define JUMPS 5\n\nvec3 shade(Ray r) {\n    Hit h = trace(r);\n    vec3[JUMPS] rads;\n    \n    int i;\n    for (i = 0; i < JUMPS; i++) {\n        if (h.id == 0) {\n            rads[i] = envmap(r.rd);\n            break;\n        }\n        \n        if (refractive[h.id]) {  // Transparent.\n            rads[i] = diffuse[h.id];\n            r = Ray(h.p, normalize(refract(r.rd, h.n, 1./1.4)), 0.03);\n        }\n        else if (emissive[h.id] != vec3(0.)) {\n            rads[i] = emissive[h.id];\n            break;\n        }\n        else if (metallic[h.id] != vec3(0.)) {  // Metallic.\n            rads[i] = metallic[h.id] * sqrt(abs(dot(r.rd, h.n)));\n            r = Ray(h.p, normalize(reflect(r.rd, h.n)), 1. * 0.03);\n        }\n        else {  // Diffuse.\n            rads[i] = diffuse[h.id] * abs(dot(r.rd, h.n));\n        }\n        \n        h = trace(r);\n    }\n    \n    //return h.n;\n    //return vec3(float(i) / 5.);\n    \n    vec3 col = vec3(1.);\n    for (; i >= 0; i--) {\n        col *= rads[i];\n    }\n    \n    return col;\n    \n    \n    /*return diffuse[h.id] * envmap(reflect(r.rd, h.n));*/\n    \n    //return diffuse[h.id] * shade(rf);\n}\n\nRay perspective(in vec3 c0, in vec3 cd, in vec3 up, in vec2 uv, float fov)\n{\n    vec3 X = cross(up, cd);\n    vec3 sensor = uv[0] * X + uv[1] * up + cd / tan(fov / 2.);\n    return Ray(c0 + sensor, normalize(sensor), 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv * 2.) - 1.;\n    uv *= vec2(1., iResolution.y / iResolution.x);\n\n    // Rotate camera.    \n    float phi = PI * (iMouse.x / iResolution.x * 2. - 1. + 0.5);\n    float theta = PI * (iMouse.y / iResolution.y * 0.6 - 0.1);\n    float sp = sin(phi);\n    float cp = cos(phi);\n    float st = sin(theta);\n    float ct = cos(theta);\n    vec3 c0 = 2.5 * vec3(ct*cp, st, ct*sp);\n    vec3 cd = normalize(-c0);\n    vec3 up = vec3(-st*cp, ct, -st*sp);\n\n    \n    r = perspective(c0, cd, up, uv, PI * .5);\n\n    vec3 col = shade(r);\n    \n    fragColor = vec4(col, r.t);\n}","name":"Buffer A","description":"","type":"buffer"}]}