{"ver":"0.1","info":{"id":"llKfW1","date":"1542484877","viewed":162,"name":"Morpheous","username":"Jangalomph","description":"Learning ray marching + sdf's. \nClicking changes atmospherics from spherical to flat.\n\nRaymarching is from a tutorial, atmospherics from another shader.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------\n// Rayleigh and Mie scattering atmosphere system\n//\n// implementation of the techniques described here:\n// http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\n// ----------------------------------------------------------------------------\n\n//atmospherics from https://www.shadertoy.com/view/XtBXDz\n#ifdef GL_ES\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define mul(a, b) (a) * (b)\n#endif\n\n#define PI 3.14159265359\n\n// Shadertoy specific uniforms\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nmat3 rotate_around_x(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t\t_end;\n\treturn r;\n}\n\nbool isect_sphere(_in(ray_t) ray, _in(sphere_t) sphere, _inout(float) t0, _inout(float) t1)\n{\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2) return false;\n\tfloat thc = sqrt(radius2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\n\treturn true;\n}\n\n// scattering coefficients at sea level (m)\nconst vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6); // Rayleigh \nconst vec3 betaM = vec3(21e-6); // Mie\n\n// scale height (m)\n// thickness of the atmosphere if its density were uniform\nconst float hR = 7994.0; // Rayleigh\nconst float hM = 1200.0; // Mie\n\nfloat rayleigh_phase_func(float mu)\n{\n\treturn\n\t\t\t3. * (1. + mu*mu)\n\t/ //------------------------\n\t\t\t\t(16. * PI);\n}\n\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\nconst float g = 0.76;\nfloat henyey_greenstein_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t\t(1. - g*g)\n\t/ //---------------------------------------------\n\t\t((4. + PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\n// Schlick Phase Function factor\n// Pharr and  Humphreys [2004] equivalence to g above\nconst float k = 1.55*g - 0.55 * (g*g*g);\nfloat schlick_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t(1. - k*k)\n\t/ //-------------------------------------------\n\t\t(4. * PI * (1. + k*mu) * (1. + k*mu));\n}\n\nconst float earth_radius = 6360e3; // (m)\nconst float atmosphere_radius = 6420e3; // (m)\n\nvec3 sun_dir = vec3(0, 1, 0);\nconst float sun_power = 20.0;\n\nconst sphere_t atmosphere = _begin(sphere_t)\n\tvec3(0, 0, 0), atmosphere_radius, 0\n_end;\n\nconst int num_samples = 16;\nconst int num_samples_light = 8;\n\nbool get_sun_light(\n\t_in(ray_t) ray,\n\t_inout(float) optical_depthR,\n\t_inout(float) optical_depthM\n){\n\tfloat t0, t1;\n\tisect_sphere(ray, atmosphere, t0, t1);\n\n\tfloat march_pos = 0.;\n\tfloat march_step = t1 / float(num_samples_light);\n\n\tfor (int i = 0; i < num_samples_light; i++) {\n\t\tvec3 s =\n\t\t\tray.origin +\n\t\t\tray.direction * (march_pos + 0.5 * march_step);\n\t\tfloat height = length(s) - earth_radius;\n\t\tif (height < 0.)\n\t\t\treturn false;\n\n\t\toptical_depthR += exp(-height / hR) * march_step;\n\t\toptical_depthM += exp(-height / hM) * march_step;\n\n\t\tmarch_pos += march_step;\n\t}\n\n\treturn true;\n}\n\nvec3 get_incident_light(_in(ray_t) ray)\n{\n\t// \"pierce\" the atmosphere with the viewing ray\n\tfloat t0, t1;\n\tif (!isect_sphere(\n\t\tray, atmosphere, t0, t1)) {\n\t\treturn vec3(0);\n\t}\n\n\tfloat march_step = t1 / float(num_samples);\n\n\t// cosine of angle between view and light directions\n\tfloat mu = dot(ray.direction, sun_dir);\n\n\t// Rayleigh and Mie phase functions\n\t// A black box indicating how light is interacting with the material\n\t// Similar to BRDF except\n\t// * it usually considers a single angle\n\t//   (the phase angle between 2 directions)\n\t// * integrates to 1 over the entire sphere of directions\n\tfloat phaseR = rayleigh_phase_func(mu);\n\tfloat phaseM =\n#if 1\n\t\thenyey_greenstein_phase_func(mu);\n#else\n\t\tschlick_phase_func(mu);\n#endif\n\n\t// optical depth (or \"average density\")\n\t// represents the accumulated extinction coefficients\n\t// along the path, multiplied by the length of that path\n\tfloat optical_depthR = 0.;\n\tfloat optical_depthM = 0.;\n\n\tvec3 sumR = vec3(0);\n\tvec3 sumM = vec3(0);\n\tfloat march_pos = 0.;\n\n\tfor (int i = 0; i < num_samples; i++) {\n\t\tvec3 s =\n\t\t\tray.origin +\n\t\t\tray.direction * (march_pos + 0.5 * march_step);\n\t\tfloat height = length(s) - earth_radius;\n\n\t\t// integrate the height scale\n\t\tfloat hr = exp(-height / hR) * march_step;\n\t\tfloat hm = exp(-height / hM) * march_step;\n\t\toptical_depthR += hr;\n\t\toptical_depthM += hm;\n\n\t\t// gather the sunlight\n\t\tray_t light_ray = _begin(ray_t)\n\t\t\ts,\n\t\t\tsun_dir\n\t\t_end;\n\t\tfloat optical_depth_lightR = 0.;\n\t\tfloat optical_depth_lightM = 0.;\n\t\tbool overground = get_sun_light(\n\t\t\tlight_ray,\n\t\t\toptical_depth_lightR,\n\t\t\toptical_depth_lightM);\n\n\t\tif (overground) {\n\t\t\tvec3 tau =\n\t\t\t\tbetaR * (optical_depthR + optical_depth_lightR) +\n\t\t\t\tbetaM * 1.1 * (optical_depthM + optical_depth_lightM);\n\t\t\tvec3 attenuation = exp(-tau);\n\n\t\t\tsumR += hr * attenuation;\n\t\t\tsumM += hm * attenuation;\n\t\t}\n\n\t\tmarch_pos += march_step;\n\t}\n\n\treturn\n\t\tsun_power *\n\t\t(sumR * phaseR * betaR +\n\t\tsumM * phaseM * betaM);\n}\n\n\n\nfloat Sphere(vec3 center, float radius, vec3 point)\n{\n    return length(center-point)-radius;\n}\n\nfloat Cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//float opDisplace( in Sphere, in vec3 p )\n//{\n //   float d1 = primitive(p);\n //   float d2 = displacement(p);\n //   return d1+d2;\n//}\n\nvoid Rotate( inout vec3 vector, vec2 angle)\n{\n    vector.yz = cos(angle.y)*vector.yz+sin(angle.y)*vec2(-1,1)*vector.zy;\n    vector.xz = cos(angle.x)*vector.xz+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nfloat Scene(vec3 pos)\n{\n    float t = iTime;\n    vec2 angle = vec2(iTime,.3);\n   // float f= Sphere(vec3(-1,-1,0),1.,pos);\n   // f= min(f,Sphere(vec3(1,-1,0),1.,pos));\n   // f= min(f,Sphere(vec3(0,1,0),2.,pos));\n    vec3 overload = vec3(0.0);\n    \n    float s1 = Sphere(vec3(sin(t), cos(t), 0), 1.,pos + sin(2.2*pos.x)*cos(2.2*pos.y)*cos(1.2*pos.z));\n\n    float s2 = Sphere(vec3(sin(-t), cos(2.*t), 1), .6,pos);\n    float s3 = Sphere(vec3(1,cos(t),1), .5,pos);\n    //float c1 = Cylinder(\n    //float \n    s1 = opSmoothUnion(s1,s2,2.);\n    s1 = opSmoothUnion(s1,s3,2.);\n    return s1;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-iResolution.xy*-.5)/iResolution.x;\n    \n    vec3 ray = normalize( vec3( (fragCoord-iResolution.xy*.5)/iResolution.x, 1. ) );\n    \n    vec3 pos = vec3(0,0,-15);\n    \n    vec2 angle = vec2(iTime,.3);\n    \n    if ( iMouse.z >= .0 ) angle = (iMouse.xy/iResolution.xy-.5)*3.14;\n\n\n\n    //Rotate(pos,angle);\n   // Rotate(ray,angle);\n    vec3 bgcolor1 = vec3(1.0, 0.2, 0.05);\n    vec3 bgcolor2 = vec3(.5, .35, 0.01);\n    \n    vec3 bgColor = mix(bgcolor2,bgcolor1,dot(uv.x, uv.y));\n    \n    //***************\n    \n    \tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(45.0));\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n\tvec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * fov, -1.0);\n\n\tvec3 col = vec3(0);\n\n\t// sun\n\tmat3 rot = rotate_around_x(-abs(sin(u_time / 2.)) * 90.);\n\tsun_dir *= rot;\n\n    if (u_mouse.z < 0.1) {\n        // sky dome angles\n        vec3 p = point_cam;\n        float z2 = p.x * p.x + p.y * p.y;\n        float phi = atan(p.y, p.x);\n        float theta = acos(1.0 - z2);\n        vec3 dir = vec3(\n            sin(theta) * cos(phi),\n            cos(theta),\n            sin(theta) * sin(phi));\n\n        ray_t ray = _begin(ray_t)\n            vec3(0, earth_radius + 1., 0),\n            dir\n        _end;\n\n        col = get_incident_light(ray);\n    } else {\n        vec3 eye = vec3 (0, earth_radius + 1., 0);\n        vec3 look_at = vec3 (0, earth_radius + 1.5, -1);\n\n        ray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n        if (dot(ray.direction, vec3(0, 1, 0)) > .0) {\n            col = get_incident_light(ray);\n        } else {\n            col = vec3 (0.333);\n        }\n    }\n   \n    \n\n\t//fragColor = vec4(col, 1);\n    \n    //******************************\n    \n    \n  \n    fragColor = vec4(col, 1);\n    \n    \n \tfor ( int i=0; i < 100; i++ )\n    {\n        float h = Scene(pos);\n        if (h <.01)\n        {\n            fragColor = vec4(0);\n            break;\n        }\n    pos+=ray*h;\n    }\n    \n    if ( Scene(pos) < .01 ) // Did the ray hit anything?\n    {\n        vec3 normal;\n        normal.x = Scene(pos+vec3(.01,0,0)) - Scene(pos-vec3(.01,0,0));\n        normal.y = Scene(pos+vec3(0,.01,0)) - Scene(pos-vec3(0,.01,0));\n        normal.z = Scene(pos+vec3(0,0,.01)) - Scene(pos-vec3(0,0,.01));\n\t\tnormal = normalize(normal);\n        vec3 lightSource = vec3(0,0.5*sin(iTime)*15.,-15);\n        //Rotate(lightSource,angle);\n        float light = max(.0,dot(normal,normalize(lightSource-pos)));\n        vec3 ambient= vec3(.1,.1,0.1);\n        vec3 lightCol = vec3(col*5.);\n       \tfragColor.rgb = light*lightCol+ambient;\n    }\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2) );\n}","name":"Image","description":"","type":"image"}]}