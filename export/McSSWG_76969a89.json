{"ver":"0.1","info":{"id":"McSSWG","date":"1706744667","viewed":73,"name":"zozuar fractal raycasting","username":"vampyrashu","description":"A tinkered and converted snippet of code sourced from: https://twitter.com/zozuar . All credits for the original code creation goes to him/her.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this is a sloppy commented and tinkered code \n// all credits tword the source code snipped: https://twitter.com/zozuar\n\n// Define Pi, a mathematical constant representing the ratio of a circle's circumference to its diameter.\nconst float PI = 3.14159265358979323846264338327950288;\n\n\n\n// Function to create a 2D rotation matrix given an angle theta.\nmat2 rotate2D(float theta) {\n    float c = cos(theta); // Calculate the cosine of theta.\n    float s = sin(theta); // Calculate the sine of theta.\n    return mat2(c, -s, s, c); // Return a 2D rotation matrix.\n}\n\n// Main function for ShaderToy to render each pixel of the screen.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 r = iResolution.xy; // Get the resolution of the viewport as a 2D vector.\n    vec3 outputColor = vec3(0.0); // Initialize a vector to accumulate color values.\n    \n    \n    \n    float t = iTime; // Get the current time, used for animations.\n\n\n    float loopDuration = 21.0; // Duration of one loop cycle in seconds\n    float minValue = -1.; // Set your desired minimum value\n    float maxValue = 3.0;  // Set your desired maximum value\n\n    float amplitude = (maxValue - minValue) / 2.0; // Half the range of the values\n    float offset = (maxValue + minValue) / 2.0;    // Midpoint of the values\n\n    // Adjusting the loopingValue to oscillate between minValue and maxValue\n    float loopingValue = amplitude * sin(t * 2.10 * PI / loopDuration) + offset;\n\n\n\n  \n\n    // Calculate the rotation amount based on mouse x-coordinate and time.\n    // Normalize mouse position and modify with time for dynamic rotation.\n    float mouseX = iMouse.x / iResolution.x; // Normalize the mouse position to range [0, 1].\n    float mouseY = iMouse.y / iResolution.y; // Normalize the mouse position to range [0, 1].\n    float rotationAmount = t/8.; // Compute rotation amount from mouse position and time. alt (mouseX / 20.0) * (t / 2.0)\n\n    float iteration, stepSize, estimation; // Declare variables for iteration (i), step size (s), and distance estimation (e).\n    for (vec3 positionOftheRay, q, directionOftheRay = vec3((fragCoord.xy - .5 * r) / r.y, -1); iteration++ < 100.; estimation = length(positionOftheRay) / stepSize*2.) //SOME SORT OF DENSITY ->  stepSize*range(1.-2.)\n    { \n        // Ray marching loop: iterate over ray steps to compute the scene.\n        // d is the initial direction of the ray.\n\n        // Calculate the next position along the ray.\n        // Use a different approach for the first 50 iterations.\n        positionOftheRay = q += iteration < 50. ? directionOftheRay * estimation : positionOftheRay - positionOftheRay + 1e-4 + estimation;\n        positionOftheRay.z += loopingValue; // Add a constant value to the z-coordinate of point p.\n        outputColor += sqrt(estimation) / 70.; // Accumulate the color based on the square root of the step size.\n\n        // Apply 2D rotation to the xz-plane of point p based on the computed rotation amount.\n        positionOftheRay.xz *= rotate2D(rotationAmount) ; //rotate2D(rotationAmount);\n\n        // Transform point p and update the step size s.\n        // This involves complex transformations for a fractal-like effect.\n        positionOftheRay = vec3(atan(stepSize = length(positionOftheRay)), atan(positionOftheRay.y, positionOftheRay.x), cos(rotationAmount + positionOftheRay.z / stepSize)); //THE OVERALL LOOK Default values -> new values  > log, atan, sin -> exp, tan, cos\n        stepSize = 1.;\n\n        // Nested loop for additional fractal-like transformations.\n        for (int j = 0; j < 12; j++) // j< density of details in the fractal, higher number > more dense (min 2 - max 20)\n        {\n            // Update s and transform point p to create intricate patterns.\n            stepSize *= estimation = PI / min(dot(positionOftheRay, positionOftheRay), 1.05); //ZOOM IN AND OUT mouseY instead of 1. \n            positionOftheRay = abs(positionOftheRay) * estimation - 2.; //range 2-3\n            positionOftheRay.y -= round(positionOftheRay.y); // Subtract the rounded y-coordinate from y.\n        }\n    }\n\n    // Set the final color of the pixel.\n    fragColor = vec4(outputColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}