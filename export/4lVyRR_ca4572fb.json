{"ver":"0.1","info":{"id":"4lVyRR","date":"1536190622","viewed":1761,"name":"[ZMB] Voronoi (Distance types)","username":"ZiMMaBuE","description":"Voronoi distances:\nCell, Standard, Chebyshev, Minkowski","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------------------------------------\n//------VORONOI---------------------------------------\n//------by-ZiMMaBuE--------(@zimmabue Twitter)--------\n//----------------------------------------------------\n//\tHold left mouse button and\n//\tMove the mouse to see the differences\n//\tTopLeft: \tdistance difined by the MODE parameter\n//\t\t\t\t0: Chebyshev distance\n//\t\t\t\t1: Triangular distance [by iq!]\n//\tTopRight:\tstandard voronoi\n//\tBottom:\t\tcell subdivisions\n//\n//\tComment the RGB to see the distance\n//\n//\tUncomment MINKOWSKI_DISTANCE and move the mouse on\n//\tthe x axis to see how the Minkowski distance works\n//\thttps://en.wikipedia.org/wiki/Minkowski_distance\n\n#define RGB\n#define MODE 0\n//#define MINKOWSKI_DISTANCE\n#define ANIMATE\n\n//----------------------------------------------------\n//----------------------------------------------------\n//----------------------------------------------------\n\nvec2 hash(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi(vec2 pos, float u, float v)\n{\n    vec2 p = floor(pos);\n    vec2 f = fract(pos);\n    \n    float minDist = 8.0;\n    vec2 val = vec2(0.);\n    for(int j = -2; j <= 2; j++)\n    {\n    \tfor(int i = -2; i <= 2; i++)\n    \t{\n    \t\tvec2 id = vec2(float(i), float(j));\n            vec2 point = hash(id + p);\n            vec2 realPoint = id + point - f;\n            \n            float d = 0.0;\n            #ifndef MINKOWSKI_DISTANCE\n            \trealPoint = mix(id - f, realPoint, v);\n            \td = dot(realPoint, realPoint);\n                #if MODE == 0\n                \td = mix(max(abs(realPoint.x), abs(realPoint.y)), d, u);\n                #endif\n            \n                #if MODE >= 1\n                \td = mix(max(abs(realPoint.x)*0.866025+realPoint.y*0.5,-realPoint.y), d, u);\n                #endif\n            #endif\n            \n            #ifdef MINKOWSKI_DISTANCE\n                float p = pow(2.0, u * 4.);\n                d = pow(abs(realPoint.x), p) + pow(abs(realPoint.y), p);\n                d = pow(d, 1.0 / p);\n            #endif\n            \n            \n            if(d < minDist){\n            \tminDist = d;\n                val = point;\n            }\n    \t}\n    }\n    \n    return vec3(val * (1.-minDist), minDist);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    uv *= 10.;\n    #ifdef ANIMATE\n    \tuv += vec2(iTime * .5, iTime*.3);\n    #endif\n    \n    float inputX = 1.0;\n\tfloat inputY = 1.0;\n    \n    if(iMouse.z > 0.0){\n    \tinputX = iMouse.x / iResolution.x;\n    \tinputY = iMouse.y / iResolution.y;\n    }\n    \n    #ifdef RGB\n    \tvec3 col = vec3(voronoi(uv, inputX, inputY).xy, 0.);\n\t#else\n    \tvec3 col = vec3(voronoi(uv, inputX, inputY).z);\n    #endif\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}