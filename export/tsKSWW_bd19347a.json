{"ver":"0.1","info":{"id":"tsKSWW","date":"1574128580","viewed":86,"name":"Training 03 (Copo)","username":"coposuke","description":"training","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["training"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct geometry\n{\n    int type;\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float shadow;\n};\n\nstruct object\n{\n    int type;\n    float dist;\n};\n    \nfloat sdSphere(vec3 rayPos, float radius)\n{\n    return length(rayPos) - radius;\n}\n\nfloat sdBox(vec3 rayPos, vec3 size)\n{\n    vec3 b = abs(rayPos) - size;\n    return length(max(b, 0.0)) + min(max(b.x, max(b.y, b.z)), 0.0);\n}\n\nfloat sdShape(vec3 rayPos, vec3 offset)\n{\n    vec3 shapePos = rayPos + offset;\n    mat3 shapeMat = rotate(rayPos.y * 2.0, vec3(0,1,0));\n    float type = mod(floor(iTime), 2.0);\n    float time = fract(iTime);\n    time = time * time * time;\n    return \n        float(type == 0.0) * mix(sdSphere(shapePos, 1.0), sdBox(shapeMat * shapePos, vec3(0.5, 4.0, 0.5)), time) + \n\t   \tfloat(type == 1.0) * mix(sdBox(shapeMat * shapePos, vec3(0.5, 4.0, 0.5)), sdSphere(shapePos, 1.0), time);\n}\n\nvec2 opMin(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nobject map(vec3 rayPos)\n{\n    vec2 result;\n    \n    const float GRID = 10.0;\n    float random = rand(floor(rayPos.xz / GRID)) * 2.0 - 1.0;\n    float dust   =(rand(floor(rayPos.xz * GRID)) * 2.0 - 1.0) * 20.0;\n    rayPos.xz = mod(rayPos.xz, GRID);\n    rayPos.xz += -GRID * 0.5;\n    \n    float ratio = sin(iTime) * 0.5 + 0.5;\n    ratio = ratio * ratio * ratio;\n    float offset = mix(random, dust, ratio * 0.1);\n    mat3 shape2Mat = rotate(iTime * sign(offset) + offset, vec3(0,1,0));\n    \n    result = vec2(dot(rayPos + 1.0, vec3(0,1,0)), 1.0);\n    result = opMin(result, vec2(sdShape(rayPos, shape2Mat * vec3(4,0,0)), 2.0));\n    result = opMin(result, vec2(sdShape(rayPos, vec3(0,0,0)), 2.0));\n    \n    object obj;\n    obj.dist = result.x;\n    obj.type = int(result.y);\n    return obj;\n}\n\nvec3 computeNormal(vec3 rayPos)\n{\n    const float EPSILON = 1e-3;\n    return normalize(vec3(\n        map(vec3(rayPos.x + EPSILON, rayPos.y, rayPos.z)).dist - map(vec3(rayPos.x - EPSILON, rayPos.y, rayPos.z)).dist,\n        map(vec3(rayPos.x, rayPos.y + EPSILON, rayPos.z)).dist - map(vec3(rayPos.x, rayPos.y - EPSILON, rayPos.z)).dist,\n        map(vec3(rayPos.x, rayPos.y, rayPos.z + EPSILON)).dist - map(vec3(rayPos.x, rayPos.y, rayPos.z - EPSILON)).dist\n    ));\n}\n\ngeometry raymarch(vec3 camPos, vec3 camRay)\n{\n    geometry result;\n    vec3 rayPos = camPos;\n    float dist = 0.0;\n    \n    for(int i=0 ; i<200 ; ++i)\n    {\n        rayPos += camRay * dist;\n        object obj = map(rayPos);\n        dist = obj.dist;\n        \n        if(dist < 1e-3)\n        {\n            result.type = obj.type;\n            result.position = rayPos + camRay * dist;\n            result.normal = computeNormal(result.position);\n            result.dist = distance(camPos, result.position);\n            return result;\n        }\n    }\n    \n    return result;\n}\n\ngeometry shadow(vec3 rayPos, vec3 rayDir, float rayMin, float rayMax, float k)\n{\n    geometry result;\n    result.shadow = 1.0;\n    \n    for(float dist = rayMin; dist < rayMax ;)\n    {\n        vec3 pos = rayPos + rayDir * dist;\n        object obj = map(pos);\n        dist += obj.dist;\n        result.shadow = min(result.shadow, k * obj.dist / dist);\n        \n        if(obj.dist < 1e-3)\n        {\n            result.type = obj.type;\n            result.position = rayPos + rayDir * dist;\n            //result.normal = computeNormal(result.position);\n            result.dist = dist;\n            return result;\n        }\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    mat3 camMat = rotate(iTime * 0.25, vec3(0,1,0)) * rotate(0.3, vec3(0.2,0,0));\n    vec3 camPos = camMat * vec3(0,0,-10) + vec3(0,0,iTime*2.0);\n    vec3 camRay = camMat * normalize(vec3(uv,3.0));\n    vec3 lightDir = normalize(vec3(-1,1,-1));\n    \n    geometry result = raymarch(camPos, camRay);\n    geometry shadow = shadow(result.position, lightDir, 0.01, 100.0, 8.0);\n\n\tfloat light = clamp(dot(lightDir, result.normal), 0.3, 1.0);\n    float shade = max(shadow.shadow, 0.7);\n    float fog = result.dist / 100.0;\n    \n    vec3 diffuse = vec3(1) * float(result.type >= 1) * max(light * shade, 0.35) +\n \t\t\t\t   vec3(1) * float(result.type <= 0);\n    \n\tfragColor.xyz = mix(vec3(1), diffuse, clamp(1.0 - fog, 0.0, 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI      3.14159265357989\n#define PI_2    6.28318530715978\n#define PI_HALF 1.57079632678994\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat3 rotate(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}\n","name":"Common","description":"","type":"common"}]}