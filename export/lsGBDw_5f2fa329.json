{"ver":"0.1","info":{"id":"lsGBDw","date":"1529022316","viewed":264,"name":"SampleToy","username":"tepSHATOY","description":"Just a simple shader toy to explore sampling patterns","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sampletoy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SampleToy - shader toy to visualize samples\n//\n\n// samples\n/*\nconst int SAMPLE_COUNT = 8;\nvec2 samplePos[SAMPLE_COUNT] = vec2[](\n\tvec2( -0.7071,  0.7071 ),\n\tvec2(  0.0000, -0.9308 ),\n\tvec2(  0.5997,  0.5997 ),\n\tvec2( -0.7516,  0.0000 ),\n\tvec2(  0.4531, -0.4531 ),\n\tvec2(  0.0000,  0.5148 ),\n\tvec2( -0.2633, -0.2633 ),\n\tvec2(  0.2100,  0.0000 )\n);\n*/\n\n/*\nconst int SAMPLE_COUNT = 32;\nvec2 samplePos[SAMPLE_COUNT] = vec2[](\n\tvec2( 0, 0 ),\n\tvec2( -0.206667, -0.380511 ),\n\tvec2( -0.135091, 0.542448 ),\n\tvec2( 0.551415, -0.365296 ),\n\tvec2( -0.74083, -0.116924 ),\n\tvec2( 0.516601, 0.648555 ),\n\tvec2( 0.0621466, -0.899243 ),\n\tvec2( -0.701708, 0.667162 ),\n\tvec2( 1.0306, -0.0191066 ),\n\tvec2( -0.817036, -0.721078 ),\n\tvec2( 0.121296, 1.1392 ),\n\tvec2( 0.71173, -0.964853 ),\n\tvec2( -1.22664, 0.240506 ),\n\tvec2( 1.10881, 0.676794 ),\n\tvec2( -0.373542, -1.29343 ),\n\tvec2( -0.618548, 1.24696 ),\n\tvec2( 1.33963, -0.517572 ),\n\tvec2( -1.37735, -0.538892 ),\n\tvec2( 0.669958, 1.36516 ),\n\tvec2( 0.439564, -1.49809 ),\n\tvec2( -1.3699, 0.828179 ),\n\tvec2( 1.60737, 0.322264 ),\n\tvec2( -0.989786, -1.35382 ),\n\tvec2( -0.188713, 1.70349 ),\n\tvec2( 1.317, -1.15239 ),\n\tvec2( -1.78489, -0.0406894 ),\n\tvec2( 1.31366, 1.25968 ),\n\tvec2( -0.119956, -1.85017 ),\n\tvec2( -1.18224, 1.47133 ),\n\tvec2( 1.89806, -0.291297 ),\n\tvec2( -1.62317, -1.08527 ),\n\tvec2( 0.471329, 1.92752 )\n);\n*/\n\n// Halton Sequence (sampleIndex starts from 1)\n//\t\tfloat x = HaltonSequence( 2, sampleIndex );\n//\t\tfloat y = HaltonSequence( 3, sampleIndex );\nconst int SAMPLE_COUNT = 32;\nvec2 samplePos[SAMPLE_COUNT] = vec2[](\n        vec2( 0.5, 0.333333),\n        vec2( 0.25, 0.666667),\n        vec2( 0.75, 0.111111),\n        vec2( 0.125, 0.444444),\n        vec2( 0.625, 0.777778),\n        vec2( 0.375, 0.222222),\n        vec2( 0.875, 0.555556),\n        vec2( 0.0625, 0.888889),\n        vec2( 0.5625, 0.037037),\n        vec2( 0.3125, 0.37037),\n        vec2( 0.8125, 0.703704),\n        vec2( 0.1875, 0.148148),\n        vec2( 0.6875, 0.481481),\n        vec2( 0.4375, 0.814815),\n        vec2( 0.9375, 0.259259),\n        vec2( 0.03125, 0.592593),\n        vec2( 0.53125, 0.925926),\n        vec2( 0.28125, 0.0740741),\n        vec2( 0.78125, 0.407407),\n        vec2( 0.15625, 0.740741),\n        vec2( 0.65625, 0.185185),\n        vec2( 0.40625, 0.518519),\n        vec2( 0.90625, 0.851852),\n        vec2( 0.09375, 0.296296),\n        vec2( 0.59375, 0.62963),\n        vec2( 0.34375, 0.962963),\n        vec2( 0.84375, 0.0123457),\n        vec2( 0.21875, 0.345679),\n        vec2( 0.71875, 0.679012),\n        vec2( 0.46875, 0.123457),\n        vec2( 0.96875, 0.45679),\n        vec2( 0.015625, 0.790123)\n);\n\n\n// enums\nconst int DOMAIN_01 = 0;\t\t// 0..1\nconst int DOMAIN_11 = 1;\t\t// -1..1\nconst int DOMAIN_22 = 2;\t\t// -2..2\n\nconst vec3 WHITE = vec3(1.0f);\nconst vec3 BLACK = vec3(0.0f);\nconst vec3 GRAY = vec3(0.5f);\nconst vec3 LT_GRAY = vec3(0.75f);\nconst vec3 RED = vec3(1.0f, 0.0f, 0.0f);\n\n\n// config\nconst bool  drawCenterPoint   = true;\nconst bool  drawCircle        = true;\nconst int   domain            = DOMAIN_01;\nconst float SAMPLE_POINT_SIZE = 10.0f;        // pixels\nconst float CIRCLE_LINE_SIZE  = 3.0f;\n\n\nstruct Context\n{\n    vec2 uv;\n    float texelSize;\n    // canvas info\n    vec2 origin;\n    float radius;\n};\n    \n\nfloat CircleDistFunc( vec2 v, vec2 c, float r )\n{\n   return sqrt(dot(v-c,v-c)) - r;\n}\n\n\nvoid DrawCircle( inout vec3 result, Context ctxt, vec2 origin, float radius, vec3 color, bool fill, float thickness )\n{\n    float d    = CircleDistFunc( ctxt.uv, origin, radius );\n    float eps  = ctxt.texelSize;\n    \n    float t = smoothstep( 0.0f*eps, thickness*eps, fill ? d : abs(d) );\n    \n    result = mix( color, result, t );\n}\n\n\nvoid DrawSamples( inout vec3 result, Context ctxt, float sampleSize )\n{\n    for ( int i = 0; i < SAMPLE_COUNT; i++ )\n        DrawCircle( result, ctxt, samplePos[i], sampleSize, BLACK, true, 3.0f );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = min( iResolution.x, iResolution.y );\n\tfloat minX = ( iResolution.x - size ) * 0.5f;\n    float minY = ( iResolution.y - size ) * 0.5f;\n    \n    // gray - outside of domain\n    fragColor = vec4(0.5f,0.5f,0.5f,1.0f);\n    \n    vec2 uv = ( fragCoord - vec2( minX, minY ) ) / size;\n    if ( uv == clamp( uv, 0.0f, 1.0f ) )\n    {\n        // init context\n        Context ctxt;\n        ctxt.uv        = uv;\n        ctxt.texelSize = 1.0f / size;\n        ctxt.origin    = vec2(0.5f);\n        ctxt.radius    = 0.5f;\n\n        if ( domain == DOMAIN_11 )\n        {\n            ctxt.uv      = ctxt.uv*2.0f - 1.0f;\n            ctxt.origin  = ctxt.origin*2.0f - 1.0f;\n            ctxt.radius *= 2.0f;\n        }\n        else if ( domain == DOMAIN_22 )\n        {\n            ctxt.uv      = ctxt.uv*4.0f - 2.0f;\n            ctxt.origin  = ctxt.origin*4.0f - 2.0f;\n            ctxt.radius *= 4.0f;\n        }\n            \n\n        fragColor.rgb = WHITE;\n        \n        if ( drawCenterPoint )\n            DrawCircle( fragColor.rgb, ctxt, ctxt.origin, SAMPLE_POINT_SIZE * ctxt.texelSize, RED, true, 3.0f );\n        \n        if ( drawCircle )\n            DrawCircle( fragColor.rgb, ctxt, ctxt.origin, ctxt.radius, LT_GRAY, false, CIRCLE_LINE_SIZE );\n        \n        DrawSamples( fragColor.rgb, ctxt, SAMPLE_POINT_SIZE * ctxt.texelSize );\n    }\n}","name":"Image","description":"","type":"image"}]}