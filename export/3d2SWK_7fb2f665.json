{"ver":"0.1","info":{"id":"3d2SWK","date":"1555002230","viewed":2722,"name":"Second Image of a Black Hole","username":"BigWIngs","description":"Its a black hole, from my imagination, not reality.\nUse mouse to move.","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Second Image of a Black Hole\" by Martijn Steinrucken aka BigWings - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n//\n// In honor of the amazing achievement of the photographing of a real black hole,\n// behold my 100% fake one. I know next to nothing about black holes other than\n// that it distorts spacetime so much that it visibly affects light.\n//\n// Just marching the light rays and bending them towards the hole bulges the accretion disc\n// over the top when you look at it from the side, similar to the way it looked in\n// interstellar. I didn't specifically code this, it just came out that way\n// so I figure my 'physics' is not completely wrong ;)\n//\n// The jets coming out the top and bottom I just added because lots of black hole \n// illustrations have them and they look cool :)\n//\n// Code is a bit of a mess. It annoys me that step size has to be super small in order\n// for it to look halfway decent. \n\n#define SURFDIST .001\n#define MAXSTEPS 200\n#define MAXDIST 20.\n#define TAU 6.2832\n\n#define USEDISC\n#define USESTREAM\n\nmat2 Rot(float a) {\n\tfloat s = sin(a), c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(123.34,345.35));\n    p += dot(p, p+34.53);\n    return fract(p.x*p.y);\n}\n\nfloat Noise(vec2 p) {\n\tvec2 gv = fract(p);\n    vec2 id = floor(p);\n    \n    gv = smoothstep(0.,1.,gv);\n    \n    float b = mix(N21(id+vec2(0,0)), N21(id+vec2(1, 0)), gv.x);\n    float t = mix(N21(id+vec2(0,1)), N21(id+vec2(1, 1)), gv.x);\n    \n    return mix(b, t, gv.y);\n}\n\nfloat Noise3(vec2 p) {\n    return \n        (Noise(p) + \n        .50*Noise(p*2.12*Rot(1.)) +\n        .25*Noise(p*4.54*Rot(2.)))/1.75;\n}\n\nvec3 GetRd(vec2 uv, vec3 ro, vec3 lookat, vec3 up, float zoom, inout vec3 bBend) {\n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(up, f)),\n        u = cross(f, r),\n        c = ro + zoom * f,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-ro);\n \t\n    vec3 offs = normalize(uv.x*r + uv.y*u);\n    bBend = rd-.1*offs/(1.+dot(uv,uv));\n    return rd;   \n}\n\nvec3 GetBg(vec3 rd) {\n\tfloat x = atan(rd.x, rd.z);\n    float y = dot(rd, vec3(0,1,0));\n    \n    float size = 10.;\n    vec2 uv = vec2(x, y)*size;\n    float m = abs(y);\n    \n    float side = Noise3(uv);\n    float stars = pow(Noise(uv*20.)*Noise(uv*23.), 10.);\n    \n    vec2 puv = rd.xz*size;\n    float poles = Noise3(rd.xz*size);\n    float stars2 = pow(Noise(puv*21.)*Noise(puv*13.), 10.);\n    \n    stars = mix(stars, stars2, m*m);\n    float n = mix(side, poles, m*m);\n    n = pow(n, 5.);\n    \n    vec3 nebulae = n * vec3(1., .7, .5);\n    \n    return nebulae + stars*4.;\n}\n\nfloat GetDist(vec3 p) {\n    float d = length(p)-.15;\n    \n    //d = min(d, max(length(p.xz)-2., abs(p.y)));\n    return d;\n}\n\nfloat GetDisc(vec3 p, vec3 pp) {\n\t\n    float t = iTime;\n    \n    // calculate plane intersection point\n    vec3 rd = p-pp;\t\t\t// local ray direction\n    vec3 c = pp + rd*pp.y;\t// intersection point\n    rd = normalize(rd)*.5;\n    p = c-rd;\n    rd *= 2.;\n    \n    // myeah this seemed like a good idea at some point... doesn't add as much as it should\n    float m = 0.;\n    const float numSamples = 3.;\n    for(float i=0.; i<1.; i+=1./numSamples) {\n    \tc = p + i*rd;\n        \n        float d = length(c.xz);\n    \tfloat l = smoothstep(3.5, .6, d);\n    \tl *= smoothstep(.1, .6, d);\n    \t\n        float x = atan(c.x, c.z);\n    \tl *= sin(x*floor(5.)+d*20.-t)*.3+.7;\n        m += l;\n    }\n    \n    return 1.5*m/numSamples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0, 0, -4.+sin(iTime*.2));\n    ro.yz *= Rot(m.y*TAU+iTime*.05);\n    ro.xz *= Rot(-m.x*TAU+iTime*.1);\n    \n    vec3 lookat = vec3(0);\n    float zoom = .8;\n    vec3 up = normalize(vec3(.5, 1,0));\n    vec3 bBend;\n    vec3 rd = GetRd(uv, ro, lookat, up, zoom, bBend);\n    vec3 eye = rd;\n    \n    float dS, dO;\n    float disc = 0.;\n    vec3 p=ro;\n    p += N21(uv)*rd*.05;\n    vec3 pp;\n    \n    float stream = 0.;\n    \n    for(int i=0; i<MAXSTEPS; i++) {\n        rd -= .01*p/dot(p,p);\t\t// bend ray towards black hole\n        \n        pp = p;\n        p += dS*rd;\n        \n        if(p.y*pp.y<0.)\n            disc += GetDisc(p, pp);\n        \n        float y = abs(p.y)*.2;\n        stream += smoothstep(.1+y, 0., length(p.xz))*\n            smoothstep(0., .2, y)*\n            smoothstep(1., .5, y)*.05;\n        \n        dS = GetDist(p);\n        dS = min(.05, dS);\n        dO += dS;\n        if(dS<SURFDIST || dO>MAXDIST) break;\n    }\n    \n    col = GetBg(bBend);\n    \n    if(dS<SURFDIST) {\n        col = vec3(0);      // its black!\n    }\n    \n    #ifdef USEDISC\n    col += disc*vec3(1,.8,.5)*1.5;\n    #endif\n    #ifdef USESTREAM\n    col += min(.5, stream)*vec3(.7, .7, 1.);\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}