{"ver":"0.1","info":{"id":"tttGDr","date":"1576081069","viewed":169,"name":" Famous solid [glitched]","username":"frankiezafe","description":"based on \"Famous solid\" by nimitz : https://www.shadertoy.com/view/ltlGWM","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Famous solid by nimitz 2015 (twitter: @stormoid)\n// https://www.shadertoy.com/view/ltlGWM\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tQuick laydown of what's going on:\n\t\t-knighty's folding technique to get dodecahedron distance (see: https://www.shadertoy.com/view/XlX3zB)\n\t\t-Linear extrapolation of sphere to \"hyberbolize\" the dodecahedron\n\t\t-Fold symmetries are used to displace, shade and color\n\t\t-Cheap analytic curvature for shading (see: https://www.shadertoy.com/view/Xts3WM)\n\t\t-Wave noise for bump mapping (generalized triangle noise: https://www.shadertoy.com/view/XtX3DH)\n\t\t-eiffie's auto-overstep raymarching method: https://www.shadertoy.com/view/ldSSDV\n\t\t-Lighting mostly from iq\n*/\n\n//Type 1 to 4, Let me know which one you think looks best.\n#define TYPE 4\n\n#define ITR 400\n#define FAR 20.\n#define time iTime\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 fold(in vec3 p)\n{\n    const vec3 nc = vec3(-0.5,-0.809017,0.309017);\n    for(int i=0;i<5;i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tfloat t = 2.*min(0.,dot(p,nc));\n\t\tp -= t*nc;\n\t}\n    return p;\n}\n\nfloat smax(float a, float b)\n{\n    const float k = 2.;\n    float h = 1.-clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)*2.;}\n\nfloat map(in vec3 p)\n{\n    vec3 fp = fold(p) - vec3(0.,0.,1.275);\n    float mt = pow( ( sin( time * 2.134 ) + 1.75 ) * 0.35, 2.0 ) ;\n    //float mt = float((time * 1000) % 1000) * 0.001;\n    //float d = mix(dot(fp,vec3(.618,0,1.)), length(p)-1.15,-3.6);\n    float d = mix(dot(fp,vec3(mt,0,1.)), length(p)-1.15,-3.6);\n    \n    #if (TYPE == 1)\n    d += tri(fp.x*8.+fp.z*3.)*0.05+tri(fp.x*fp.y*40.+time*0.2)*0.07-0.17;\n    d += tri(fp.y*5.)*0.04;\n    d*= 0.9;\n    #elif (TYPE == 2)\n    d*= 0.7;\n    d += sin(time+fp.z*5.+sin(fp.x*20.*fp.y*8.)+1.1)*0.05-0.08;\n    d += sin(fp.x*20.*sin(fp.z*8.+time*0.2))*0.05;\n    d += sin(fp.x*20.*sin(fp.z*8.-time*0.3)*sin(fp.y*10.))*0.05;\n    #elif (TYPE == 3)\n    d = smax(d+.5, -(d+sin(fp.y*20.+time+fp.z*10.)+1.5)*0.3)*.55;\n    d += sin(max(fp.x*1.3,max(fp.z*.5,fp.y*1.))*35.+time)*0.03;\n    #else\n    d = smax(d+.5, -(d+sin(fp.z*10.+sin(fp.x*20.*fp.y*9.)+1.1)*0.3-0.3))*.5;\n    #endif\n    \n    return d*0.25;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.0005;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*( 3.8 + sin(time*1.4)*0.15 + sin(time*0.283)*0.15 );\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.0001;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//Cheap analytic curvature: https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p)\n{\n    vec2 e = vec2(-1., 1.)*0.03;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .15/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nfloat wav(in float x){return sin(x*6.283)*0.25+0.25;}\nvec2 wav2(in vec2 p){return vec2(wav(p.x+wav(p.y*1.5)),wav(p.y+wav(p.x*1.5)));}\n\nfloat wavenoise(in vec2 p)\n{\n    float z=2.;\n    float z2=1.;\n\tfloat rz = 0.;\n    vec2 bp = p;\n    rz+= (wav(-time*0.5+p.x*(sin(-time)*0.3+.9)+wav(p.y-time*0.2)))*.7/z;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec2 dg = wav2(bp*2.)*.8;\n        dg *= mm2(time*.2);\n        p += dg/z2;\n\n        bp *= 2.4;\n        z2 *= 1.05;\n\t\tz *= 2.4;\n\t\tp *= 1.4;\n        \n        rz+= (wav(p.x+wav(p.y)))/z;\n\t}\n\treturn rz;\n}\n\nvec3 tex(in vec3 p)\n{    \n    #if (TYPE == 1)\n    float rz= p.y*115.+p.x*30.+p.z*25.;\n    vec3 col = (sin(vec3(.7,2.,.1-rz*0.2)+rz*.1+0.45))*0.5+0.5;\n    #elif (TYPE==2)\n    float rz= (sin(p.x*0.+p.z*20.)-p.y*20.);\n    vec3 col = (sin(vec3(2.1,.7,.1)+rz*.09+4.15))*0.5+0.5;\n    #elif (TYPE==3)    \n    float rz= sin(p.z*3.+p.x*6.)*0.5+0.5;\n    vec3 col = mix(vec3(.7,0.1,0.),vec3(1,.5,0.4),rz)*0.5+0.05;\n    #else\n    float rz= p.z*15. + p.x*30. + time;\n    vec3 col = (sin(vec3(2.2,.1,.9)+rz*.1+4.2))*1.3+1.3;\n    #endif\n    \n    return col;\n}\n\n//Bump mapping\nfloat bumptex(in vec3 p)\n{\n    #if (TYPE == 1)\n    return wavenoise(mix(p.zy,p.yx,1.)*0.55);\n    #elif (TYPE == 2)\n    return wavenoise(mix(p.yz,p.xy,.5)*0.55);\n    #elif (TYPE == 3)\n    return wavenoise(mix(p.zy,p.xy,.5)*0.44);\n    #else\n    return wavenoise(mix(p.zy,p.xy,.1)*0.85);\n    #endif\n}\n\nvec3 bump(in vec3 p, in vec3 n)\n{\n    vec2 e = vec2(.01,0);\n    float n0 = bumptex(p);\n    vec3 d = vec3(bumptex(p+e.xyy)-n0, bumptex(p+e.yxy)-n0, bumptex(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*.3);\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<15; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.01, .1 );\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    // zoom\n    p *= 0.65;\n    \n\tvec2 mo = iMouse.xy / iResolution.xy*1.5-.75;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo += vec2(time*0.03, time*0.04);\n    \n\tvec3 ro = vec3(.0,0.0,-5.7);\n    vec3 rd = vec3(p,1.2);\n\tro = rotx(ro, -mo.y*3.0);ro = roty(ro, mo.x*3.0);\n\trd = rotx(rd, -mo.y*3.0);rd = roty(rd ,mo.x*3.0);\n\t\n    float rz = march(ro,rd);\n    vec3 col = vec3(1.);\n    \n    if ( rz < FAR )\n    {\n        //setup\n        vec3 pos = ro+rz*rd;\n        float crv= curv(pos);\n        vec3 nor = normal(pos);\n       \tvec3 fpos = fold(pos);\n        vec3 lgt = normalize(vec3(.0, 1., 0.9));\n        float shd = shadow( pos, lgt * 2., 0.2, 30.0 );\n        nor = bump(fpos, nor);\n        \n        //components\n        float dif = max(dot(nor,lgt),0.0)*shd;\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lgt.x,lgt.y,-lgt.z)),0.0);\n        float fre = clamp(pow(1.0+dot(nor,rd),3.),0.,10.)*shd;\n        vec3 haf = normalize(lgt - rd);\n        float spe = pow(clamp(dot(nor,haf),0.0,1.0),50.0)*shd;\n        float occ= crv*0.25+0.75;\n\t\t\n        //compose\n        col  = 0.2*occ + dif*vec3(1.0,0.8,0.6) \n            + 0.4*bac*vec3(1.0)*occ;\n        col *= 0.5*pow(tex(fpos),vec3(.5));\n        col += .4*fre*vec3(1.0) + .35*spe*vec3(1.0);\n        col *= ao(pos,nor);\n        col = pow(col,vec3(.75))*1.3;\n    }\n    \n    //vignetting from iq\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.5+0.5;\n\t\n\tfragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}