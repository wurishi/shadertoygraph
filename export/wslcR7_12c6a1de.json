{"ver":"0.1","info":{"id":"wslcR7","date":"1584486381","viewed":140,"name":"Where they come from?","username":"raabix","description":"My relevation moment of doing the math to derive the classic tunnel effect as seen in many (old) demos. For a moment I felt like Neo in the matrix. I then added some more spice of my very first shader, \"Contamination\". Shadertoy is awesome!","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["simple","demo","classic","trench","contamination"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\tvec2 uv = U/iResolution.xy;\n    O = vec4(texture(iChannel0, uv));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SMOOTH 0.03\n#define S(a,b,x) smoothstep((a),(b),(x))\n\n// Hash by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\nfloat sphere(vec2 pos, float r, vec2 uv)\n{\n    return length(uv - pos) -r;\n}\n\nfloat ring(vec2 pos, float r, vec2 uv)\n{\n    return abs(sphere(pos, r, uv));\n}\n\nfloat box(vec2 lw,  vec2 uv )\n{\n    vec2 d = abs(uv)-lw;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rot(vec2 pos, float angle, vec2 uv)\n{\n    uv -= pos; \n    uv = vec2(uv.x * cos(angle) - uv.y * sin(angle) , uv.x * sin(angle) + uv.y * cos(angle));\n    return uv + pos;\n}\n\nfloat biohazard(vec2 pos, float size, vec2 uv)\n{\n    uv *= size;\n    uv = rot(vec2(0), float(iTime)*4., uv);\n    float val = 0.;\n    float ring_punchout = 0.;\n    float ring_w;\n    // Doing the first part of the Symbol\n    for(float i = 0.; i<3. ; i++)\n    {\n        float th_rad = .5;\n        float dist = 0.;\n        float angle = 3.1415/1.5 * i;\n        vec2 uv_tmp = rot(vec2(0., -th_rad), angle, uv - vec2(0.0, 0.5));\n        val = max(S(SMOOTH, 0.0, sphere(vec2(0.0), th_rad , uv_tmp)), val);\n        val -= S(SMOOTH, 0.0, sphere(vec2(0.0, 0.11), .39, uv_tmp));\n        // center of 2nd sphere, but smaller\n        dist = ring(vec2(0.0, 0.11), th_rad - .125 , uv_tmp) ;\n        \n        float ring_w = 0.022;\n        ring_punchout = max(S(SMOOTH+ring_w, ring_w, dist), ring_punchout);\n        \n        uv_tmp = rot(vec2(0., -th_rad), angle, uv - vec2(0.0, 0.5)) + vec2(0, 0.34); //UV for box\n        val = min(S(0., SMOOTH,  ( box(vec2(0.023, 0.06), uv_tmp)) ), val); // BOX\n\n    }\n    // the punchout ring\n    ring_w = 0.04;\n    \n    val = max(val,S(SMOOTH + ring_w, ring_w,   ring(vec2(0), .4, uv)));\n    val -= ring_punchout;\n    \n    \n    val -= S(SMOOTH, 0.0, sphere(vec2(0), 0.11, uv));\n    \n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord)/iResolution.xy) ;\n    \n    vec2 offs_x = vec2(uv.x/iResolution.x, 0.);\n    vec2 offs_y = vec2(0., uv.y/iResolution.y);\n    \n    vec4 previous = (texture(iChannel0, uv) +\n                     texture(iChannel0, uv + offs_x) +\n                     texture(iChannel0, uv - offs_x) +\n                     texture(iChannel0, uv + offs_y) +\n                     texture(iChannel0, uv - offs_y)) / 5.;\n    //uv.x = uv.x * iResolution.x/iResolution.y;\n    uv -= 0.5; //vec2(0., float(iFrame)/30.);\n    \n    \n    float v = atan(uv.x, uv.y);\n    float r = length(uv.xy);\n    \n    float x0 = uv.x;\n    \n    float a = iTime * 0.2 - sin(r*5.-iTime*3.)*.2;\n    uv.x = x0 * cos(a) - uv.y * sin(a);\n    uv.y = x0 * sin(a) + uv.y * cos(a);\n    \n    // ---------------------\n    \n    float ty = uv.y;\n    uv.y = .7/(abs(uv.y));\n    uv.x = uv.x / (ty);\n    \n    // Depth\n    float depth = 1./(pow(uv.y, .8));\n    uv.y += iTime;\n    \n    if(mod(floor(uv.y), 2.) == 0.)\n    \tuv.x += iTime;\n    else\n        uv.x -= iTime;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(fract(uv), 0,1.0);\n   \n    \n    vec3 val = vec3(sin(uv.y + iTime*5.)*0.8 + 0.4,\n                    sin(uv.y*0.89 + iTime*6.)*0.9 + 0.6,\n                    sin(uv.y*0.79 + iTime*7.)*0.7 + 0.8);\n    \n    vec4 values = hash42(floor(uv));\n    //float intensities = smoothstep(sin(iTime) * 0.5 +0.4, .9, values.w)*2.;\n    float intensities = clamp(sin(iTime*values.w*2.15 +values.w*6.15), 0., 1.);\n    \n     fragColor = vec4(clamp(biohazard(vec2(0.), 2., fract(uv)-vec2(0.5, 0.5)), 0., 1.)\n                     ) * depth * values * intensities;\n    fragColor += previous * 0.92;\n    // psychedelic fragColor     \n    //fragColor =  mix(fragColor, vec4(1.),clamp((.1- depth),0.,1.));\n    //fragColor = vec4(depth);\n}","name":"Buffer A","description":"","type":"buffer"}]}