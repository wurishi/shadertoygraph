{"ver":"0.1","info":{"id":"ddBGRW","date":"1667287787","viewed":155,"name":"Happy Birthday YC","username":"reforia","description":"For someone's special's bd","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["fun"],"hasliked":0,"parentid":"wsdXzn","parentname":"Happy Birthday!!!!!!"},"renderpass":[{"inputs":[{"id":"XtX3Wf","filepath":"https://soundcloud.com/fernandohenri/happy-birthday-songs","previewfilepath":"https://soundcloud.com/fernandohenri/happy-birthday-songs","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nfloat scale = 1.0 / 6.0;\n\nfloat epsilon = 1e-3;\nfloat infinity = 1e6;\n\n#define N_POPS 6\n#define TIME_BETWEEN_POPS 1.9\n#define TIME_BETWEEN_POPS_RANDOM 0.6\n#define N_CONFETTI 100\n#define PI 3.1415926535\n#define SQUARE_HARDNESS 10.0\n#define GLOW_INTENSITY 0.8\n#define HUE_VARIANCE 0.2\n\n#define V_INITIAL 600.0\n#define V_RANDOM 300.0\n#define GRAVITY 17.81\n#define TERMINAL_VELOCITY 60.0\n#define TERMINAL_VELOCITY_RANDOM 10.0\n\n#define GLOW_WHITENESS 0.30\n#define SQUARE_WHITENESS 0.86\n\n#define USE_CHEAP_ARCS\n\n\n#define BORDER_COLOR vec3(0.05, 0.20, 1.00)\n\n#define BRIGHTNESS 0.004\n#define THICKNESS  0.003\n\n\nbool ApproxEqual(float a, float b)\n{\n    return abs(a - b) <= epsilon;\n}\n\n\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;  \n\tuv -= origin;\n    \n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n    #ifdef USE_CHEAP_ARCS\n        if(ApproxEqual(sweep, pi)) \n        {\n            float d = abs(length(uv) - radius) + step(uv.y, 0.0) * infinity;\n            d = min(d, min(length(uv - vec2(radius, 0)), length(uv + vec2(radius, 0))));\n            return d;\n        }\n        else if(ApproxEqual(sweep, pi/2.0)) \n        {\n            float d = abs(length(uv) - radius) + step(min(uv.x, uv.y), 0.0) * infinity;\n            d = min(d, min(length(uv - vec2(0, radius)), length(uv - vec2(radius, 0))));\n            return d;\n        }\n        else //Others\n        {\n            float offs = (sweep / 2.0 - pi);\n            float ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n            ang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\n            return distance(radius * vec2(cos(ang), sin(ang)), uv); \n        }\n    #else\n        float offs = (sweep / 2.0 - pi);\n        float ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n        ang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\n        return distance(radius * vec2(cos(ang), sin(ang)), uv);\n\t#endif\n}\n\nfloat dfLogo(vec2 uv)\n{\n\tfloat dist = infinity;\n    //Name row\n    dist = min(dist, dfLine(vec2(5.6,3.500), vec2(6.0,3), uv));\n    dist = min(dist, dfLine(vec2(6.0,3.00), vec2(6.6,3.5),uv));\n    dist = min(dist, dfLine(vec2(6.0,3.00), vec2(6.0,2.0), uv));\n    dist = min(dist, dfLine(vec2(6.9,2.0), vec2(6.9,1.9), uv));\n    dist = min(dist, dfArc(vec2(8.4, 2.6),1.5, 3.442, .767, uv));\n    //Up row\n\tdist = min(dist, dfLine(vec2(0.0,0.000), vec2(0.0,1.40), uv));\n    dist = min(dist, dfLine(vec2(0.70,0.000), vec2(0.70,1.40), uv));\n\tdist = min(dist, dfLine(vec2(0.0,0.700), vec2(0.7,0.700), uv));\n    dist = min(dist, dfLine(vec2(1.00,0.000), vec2(1.5,1.40), uv));\n    dist = min(dist, dfLine(vec2(2.,0.000), vec2(1.5,1.40), uv));\n    //dist = min(dist, dfLine(vec2(0.0,0.000), vec2(0.0,1.40), uv));\n    dist = min(dist, dfLine(vec2(2.3,0.000), vec2(2.3,1.40), uv));\n    dist = min(dist, dfArc(vec2(2.4,1.0),3.142, -4.142, .567, uv));\n    dist = min(dist, dfArc(vec2(3.4,1.0),3.142, -4.142, .567, uv));\n    dist = min(dist, dfLine(vec2(3.3,0.000), vec2(3.3,1.40), uv));\n    dist = min(dist, dfLine(vec2(4.6,0.000), vec2(4.6,0.7), uv));\n    dist = min(dist, dfLine(vec2(4.2,1.400), vec2(4.6,0.7), uv));\n    dist = min(dist, dfLine(vec2(5.0,1.400), vec2(4.6,0.7), uv));\n    //dist = min(dist, dfLine(vec2(0.0,0.000), vec2(0.0,1.40), uv));\n    dist = min(dist, dfLine(vec2(1.25,0.750), vec2(1.75,0.75), uv));\n    //Low row\n    dist = min(dist, dfLine(vec2(1.5,-0.200), vec2(1.5,-2.0), uv));\n    dist = min(dist, dfArc(vec2(1.6,-0.6),5.142, 3.142, .567, uv));\n    dist = min(dist, dfArc(vec2(1.6,-1.6),5.142, 2.642, .567, uv));\n    //dist = min(dist, dfArc(vec2(1.6,-1.6),5.142, 2.642, .567, uv));\n    dist = min(dist, dfLine(vec2(1.25,0.750), vec2(1.75,0.75), uv));\n    dist = min(dist, dfLine(vec2(2.7,-0.2), vec2(2.7,-2.0), uv));\n    dist = min(dist, dfLine(vec2(3.2,-0.200), vec2(3.2,-2.00), uv));\n    dist = min(dist, dfArc(vec2(3.2,-.6),3.142, -4.142, .567, uv));\n    dist = min(dist, dfArc(vec2(3.2,-1.8),6.12, 1.942, .567, uv));\n    dist = min(dist, dfLine(vec2(4.0,-0.200), vec2(5.,-0.20), uv));\n    dist = min(dist, dfLine(vec2(4.5,-0.200), vec2(4.5,-2.00), uv));\n    dist = min(dist, dfLine(vec2(5.3,-0.200), vec2(5.3,-2.0), uv));\n    dist = min(dist, dfArc(vec2(5.3,-1.),4.62, 3.442, .967, uv));\n    dist = min(dist, dfLine(vec2(6.30,-2.00), vec2(6.8,-0.20), uv));\n    dist = min(dist, dfLine(vec2(7.3,-2.00), vec2(6.8,-0.20), uv));\n    dist = min(dist, dfLine(vec2(6.55,-1.00), vec2(7.075,-1.0), uv));\n    \n    dist = min(dist, dfLine(vec2(7.6,-0.200), vec2(8.0,-1.0), uv));\n    dist = min(dist, dfLine(vec2(8.0,-1.00), vec2(8.6,-0.2),uv));\n    dist = min(dist, dfLine(vec2(8.0,-1.00), vec2(8.0,-2.0), uv));\n    dist = min(dist, dfLine(vec2(9.2,-0.20), vec2(8.9,-1.6), uv));\n    dist = min(dist, dfLine(vec2(8.9,-2.0), vec2(8.9,-2.0), uv));\n\treturn dist;\n}\n\nfloat dfBorder(vec2 uv)\n{\n    float dist = infinity;\n    \n\t\n    \n    return dist;\n}\n\n\nfloat trapezium(float x)\n{\n    \n\treturn min(1.0, max(0.0, 1.0 - abs(-mod(x, 1.0) * 3.0 + 1.0)) * 2.0);\n}\n\nvec3 colFromHue(float hue)\n{\n\treturn vec3(trapezium(hue - 1.0/3.0), trapezium(hue), trapezium(hue + 1.0/3.0));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat getPopRandom(float time, float random) {\n    time = floor(time / TIME_BETWEEN_POPS);\n    return rand(vec2(time, random));\n}\n\nfloat getPopTime(float time) {\n    float pop_start_time = floor(time / TIME_BETWEEN_POPS) * TIME_BETWEEN_POPS\n        + (getPopRandom(time, 2.2)) * TIME_BETWEEN_POPS_RANDOM;\n    return iTime - pop_start_time;\n}\n\nfloat xposition(float time, float angle, float v_initial, float terminal_v) {\n    float g = GRAVITY;\n    float v = v_initial;\n    float t = time;\n    float sin_amp = 20.0 * (1.0 - exp(-pow(time / 7.0, 2.0)));\n    float x_t = sin(time / 5.0) * sin_amp + time * 3.0;\n    return v * terminal_v / g * (1.0 - exp(-g*t/terminal_v)) * cos(angle) + x_t;\n}\n\nfloat yposition(float time, float angle, float v_initial, float terminal_v) {\n    float g = GRAVITY;\n    float v = v_initial;\n    float t = time;\n    return v * terminal_v / g * (1.0 - exp(-g*t/terminal_v)) * sin(angle) - terminal_v * t;\n}\n\nfloat isInExtendedTriangle(vec2 b, vec2 a, vec2 c, vec2 p)\n{\n           \n    vec2 v0 = c - a;\n    vec2 v1 = b - a;\n    vec2 v2 = p - a;\n\n   \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    \n    float denom = (dot00 * dot11 - dot01 * dot01);\n    if (denom < 0.001) {\n     \treturn 0.0;   \n    }\n    float invDenom = 1.0 / denom;\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    \n    return clamp(u * SQUARE_HARDNESS, 0.0, 1.0) *\n           clamp(v * SQUARE_HARDNESS, 0.0, 1.0);  \n}\n\nfloat isInQuad(vec2 a, vec2 b, vec2 c, vec2 d, vec2 p)\n{\n    return isInExtendedTriangle(a, b, c, p) * isInExtendedTriangle(c, d, a, p);\n}\n\nvec4 rotate(float phi, float theta, float psi) {\n    float cosPhi = cos(phi), sinPhi = sin(phi);\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n    float cosPsi = cos(psi), sinPsi = sin(psi);\n    mat3 matrix;\n    \n    vec3 row0 = vec3(cosTheta * cosPsi, -cosTheta * sinPsi, sinTheta);\n    \n    vec3 row1 = vec3(cosPhi * sinPsi + sinPhi * sinTheta * cosPsi, \n                     cosPhi * cosPsi - sinPhi * sinTheta * sinPsi, \n                     -sinPhi * cosTheta);\n    \n    vec3 a = row0 - row1;\n    \n    vec3 b = row0 + row1;\n    \n    return vec4(a, b);\n}\n\nfloat isInRotatedQuad(vec4 offsets, vec2 center, vec2 p)\n{\n    return isInQuad(center + offsets.xy, \n                    center + offsets.zw, \n                    center - offsets.xy,\n                    center - offsets.zw, p);\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\t\n    float tf_text = max(epsilon, iTime - 1.7);\n    \n    \n    vec2 scaledFragCoord = fragCoord / iResolution.xy * vec2(800.0, 450.0);\n\tconst float size = 6.0;\n    const float max_square_dist = size * size * 128.0;\n    float max_dist = sqrt(max_square_dist);\n    const float confettiRotateTimeScale = 2.0;\n    \n    float t = iTime * confettiRotateTimeScale / 5.0 + 1.3;\n    vec4 matrix1 = rotate(t * 8.0, sin(t) * 0.5, t / 4.0) * size;\n    t = iTime * confettiRotateTimeScale / 5.1 + 92.2;\n    vec4 matrix2 = rotate(t * 8.0, sin(t) * 0.5, t / 4.0) * size;\n    t = iTime * confettiRotateTimeScale / 5.5 + 7.1;\n    vec4 matrix3 = rotate(t * 8.0, sin(t) * 0.5, t / 4.0) * size;\n    t = iTime * confettiRotateTimeScale / 4.3 + 1.0;\n    vec4 matrix4 = rotate(t * 8.0, sin(t) * 0.5, t / 4.0) * size;\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<N_POPS; i++) {\n        float sampleTime = iTime - float(i) * TIME_BETWEEN_POPS;\n        float popTime = getPopTime(sampleTime);\n        vec2 point = vec2(getPopRandom(sampleTime, 3.1) * 800.0, 0);\n        float baseHue = getPopRandom(sampleTime, 3.5);\n        \n        if (abs(scaledFragCoord.x - point.x) > 300.0) {\n            continue;\n        }\n        \n        \n        for (int j=0; j<N_CONFETTI; j++) {\n            float angle = PI / 2.0 + PI / 4.0 * (getPopRandom(sampleTime, float(j)) - 0.5);\n            float v_initial =  V_INITIAL + V_RANDOM * getPopRandom(sampleTime, float(j - 5));\n            float terminal_v = TERMINAL_VELOCITY + TERMINAL_VELOCITY_RANDOM * (getPopRandom(sampleTime, float(j - 10)) - 0.5);\n                \n            float alterTime = popTime * 10.0;\n            float x = xposition(alterTime, angle, v_initial, terminal_v) / 5.0;\n            float y = yposition(alterTime, angle, v_initial, terminal_v) / 5.0;\n            \n            vec2 confettiLocation = vec2(point.x + x, y);\n            vec2 delta = confettiLocation - scaledFragCoord;\n            float dist = dot(delta, delta);\n            if (dist > max_square_dist) {\n             \tcontinue;   \n            }\n            //dist = sqrt(dist);\n            float glowIntensity = (clamp(1.0 - pow(dist / max_square_dist, 0.05), 0.0, 1.0) / 1.0) * GLOW_INTENSITY;\n            float f = getPopRandom(sampleTime, float(j - 2));\n            vec4 matrix;\n            float matrixIndex = mod(f * 4.0, 4.0);\n            if (matrixIndex < 1.0) {\n                matrix = matrix1;\n            } else if (matrixIndex < 2.0) {\n                matrix = matrix2;\n            } else if (matrixIndex < 3.0) {\n                matrix = matrix3;\n            } else {\n                matrix = matrix4;\n            }\n            float squareIntensity = isInRotatedQuad(matrix,\n                                  \t\t\t        confettiLocation, \n                                                    scaledFragCoord);\n            vec3 pastelColour = colFromHue(baseHue + getPopRandom(sampleTime, float(j - 15)) * HUE_VARIANCE);\n            vec3 pastelGlowColour = glowIntensity * (pastelColour * (1.0 - GLOW_WHITENESS) + vec3(GLOW_WHITENESS, GLOW_WHITENESS, GLOW_WHITENESS));\n            vec3 pastelSqColour = squareIntensity * (pastelColour * (1.0 - SQUARE_WHITENESS) + vec3(SQUARE_WHITENESS, SQUARE_WHITENESS, SQUARE_WHITENESS));\n            col += vec4(pastelGlowColour + pastelSqColour, 0.0);\n        }\n    }\n    float bright_confetti = BRIGHTNESS * min(1.0, 1.0 - sin(tf_text\t* pi * 50.0) / (tf_text * pi * 1.3));\n    col.a = 1.0;\n    col.z*= bright_confetti;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    vec3 TEXT_COLOR;\n    TEXT_COLOR = vec3(abs(sin(iTime)), 0.4, abs(cos(iTime)));\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n\t\n    vec2 offs = vec2(9.0, 1.5) * scale/2.0;\n    \n    float dist = 0.0;\n    float shade = 0.0;\n    vec3 color = vec3(0);\n    \n    float bright_text = BRIGHTNESS * min(1.0, 1.0 - sin(tf_text * pi * 50.0) / (tf_text * pi * 1.3));\n    \n    float tf_bord = max(epsilon, iTime - 0.5);\n    float bright_bord = BRIGHTNESS * min(1.0, 1.0 - sin(tf_bord * pi * 50.0) / (tf_bord * pi * 1.3));\n    \n    dist = dfLogo(uv + offs);\n\t\n\tshade = bright_text / max(epsilon, dist - THICKNESS);\n\t\n\tcolor += TEXT_COLOR * shade;\n    \n    dist = dfBorder(uv + offs);\n\t\n\tshade = bright_bord / max(epsilon, dist - THICKNESS);\n\t\n\tcolor += BORDER_COLOR * shade;\n    color+= col.xyz;\n\tfragColor = vec4(color, 1.0)  ;\n}\n","name":"Image","description":"","type":"image"}]}