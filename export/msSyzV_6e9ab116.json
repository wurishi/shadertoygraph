{"ver":"0.1","info":{"id":"msSyzV","date":"1687900127","viewed":186,"name":"GPU-Centered Font Rendering","username":"lohann","description":"glyph outlines\n\nOriginal implementation: https://jcgt.org/published/0006/02/02/","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["slugfontgpu"],"hasliked":0,"parentid":"mtGSz1","parentname":"GPU-Centered Font Rendering Slug"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n// Author: Lohann Paterno Coutinho Ferreira\n// This is a implementation of a Pixel-Perfect zoom indenpendent Font rendering,\n// this is based in article from Eric Lengyel, who created the original method.\n//\n// Article: GPU-Centered Font Rendering Directly from Glyph Outlines\n// Link: https://jcgt.org/published/0006/02/02/\n\n// All quadratic bezier points which compose the letter \"a\"\nivec2 beziers[62] = ivec2[](\n    // First glyph\n    ivec2(46127, 22077), // 0\n    ivec2(46127, 33000),\n    ivec2(46127, 33000), // 2\n    ivec2(43680, 31929),\n    ivec2(40261, 31271), // 4\n    ivec2(36843, 30614),\n    ivec2(28314, 29630), // 6\n    ivec2(19416, 28541),\n    ivec2(15453, 25883), // 8\n    ivec2(11490, 23225),\n    ivec2(11565, 18475), // 10\n    ivec2(11931, 8976),\n    ivec2(25257, 8715),  // 12\n    ivec2(34994, 8744),\n    ivec2(41740, 14176), // 14\n    ivec2(46426, 17691),\n    ivec2(46127, 22077),\n    \n    // Second glyph\n    ivec2(65535, 8599),  // 17\n    ivec2(65535, 1278),\n    ivec2(65535, 1278),  // 19\n    ivec2(62843, 679),\n    ivec2(61248, 450),   // 21\n    ivec2(59653, 222),\n    ivec2(57958, 232),   // 23\n    ivec2(47456, 0),\n    ivec2(46526, 9180),  // 25\n    ivec2(35393, 0),\n    ivec2(22864, 232),   // 27\n    ivec2(12188, 323),\n    ivec2(6148, 5098),   // 29\n    ivec2(108, 9873),\n    ivec2(0, 18243),     // 31\n    ivec2(33, 30037),\n    ivec2(12230, 34510), // 33\n    ivec2(14946, 35571),\n    ivec2(19109, 36282), // 35\n    ivec2(23271, 36994),\n    ivec2(34562, 38229), // 37\n    ivec2(41204, 38944),\n    ivec2(43684, 40422), // 39\n    ivec2(46164, 41900),\n    ivec2(46127, 44968), // 41\n    ivec2(46127, 47524),\n    ivec2(46127, 47524), // 43\n    ivec2(45928, 56414),\n    ivec2(30574, 56588), // 45\n    ivec2(15320, 56762),\n    ivec2(14224, 45782), // 47\n    ivec2(3057, 45782),\n    ivec2(3057, 45782),  // 49\n    ivec2(3257, 54293),\n    ivec2(7843, 58447),  // 51\n    ivec2(15320, 65390),\n    ivec2(30973, 65535), // 53\n    ivec2(56928, 65332),\n    ivec2(57160, 48919), // 55\n    ivec2(57160, 13130),\n    ivec2(57160, 13130), // 57\n    ivec2(57260, 8482),\n    ivec2(63142, 8366),  // 59\n    ivec2(63940, 8308),\n    ivec2(65535, 8599)\n);\n\nvec2 fetchBezier(int i)\n{\n    // Normalize point between -1.0 and 1.0\n\treturn vec2(beziers[i] - 32768) / 32767.0;\n}\n\nvec2 solvePoly(vec2 p1, vec2 p2, vec2 p3) {\n    vec2 a = p1 - (p2 * 2.0) + p3;\n    vec2 b = p1 - p2;\n    float ra = 1.0 / a.y;\n    float rb = 0.5 / b.y;\n\n    float d = sqrt(max(b.y * b.y - a.y * p1.y, 0.0));\n    float t1 = (b.y - d) * ra;\n    float t2 = (b.y + d) * ra;\n\n    // Verify if a.y is near zero\n    if (abs(a.y) < 0.0001) {\n        t1 = t2 = p1.y * rb;\n    }\n\n    return vec2(\n        (a.x * t1 - b.x * 2.0) * t1 + p1.x,\n        (a.x * t2 - b.x * 2.0) * t2 + p1.x\n    );\n}\n\nuint calcRootCode(float y1, float y2, float y3) {\n    uint i1 = floatBitsToUint(y1) >> 31;\n    uint i2 = floatBitsToUint(y2) >> 30;\n    uint i3 = floatBitsToUint(y3) >> 29;\n    \n    uint shift = (i2 & 2u) | (i1 & ~2u);\n    shift = (i3 & 4u) | (shift & ~4u);\n    \n    return ((0x2E74u >> shift) & 0x0101u);\n}\n\nbool testCurve(uint code) {\n    return (code != 0u);\n}\n\nbool testRoot1(uint code) {\n    return ((code & 1u) != 0u);\n}\n\nbool testRoot2(uint code) {\n    return code > 1u;\n}\n\nvoid updateCoverage(in vec2 pixelsPerEm, in vec2 p1, in vec2 p2, in vec2 p3, inout float coverage)\n{\n    uint code = calcRootCode(p1.y, p2.y, p3.y);\n    if (testCurve(code)) {\n        vec2 r = solvePoly(p1, p2, p3);\n        r.x = clamp(r.x * pixelsPerEm.x + 0.5, 0.0, 1.0);\n        r.y = clamp(r.y * pixelsPerEm.x + 0.5, 0.0, 1.0);\n        if (testRoot1(code)) coverage += r.x;\n        if (testRoot2(code)) coverage -= r.y;\n    }\n\n    p1 = vec2(p1.y, -p1.x);\n    p2 = vec2(p2.y, -p2.x);\n    p3 = vec2(p3.y, -p3.x);\n\n    code = calcRootCode(p1.y, p2.y, p3.y);\n    if (testCurve(code)) {\n        vec2 r = solvePoly(p1, p2, p3);\n        r.x = clamp(r.x * pixelsPerEm.y + 0.5, 0.0, 1.0);\n        r.y = clamp(r.y * pixelsPerEm.y + 0.5, 0.0, 1.0);\n        if (testRoot1(code)) coverage += r.x;\n        if (testRoot2(code)) coverage -= r.y;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize fragment position between -1 and 1\n\tvec2 position = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Antialiasing, calculate how many pixels are used to render this glyph\n    // Ref: https://gamedev.stackexchange.com/a/130933\n    vec2 pixelsPerEm = vec2(\n        1.0 / fwidth(position.x),\n\t    1.0 / fwidth(position.y)\n    );\n    \n    // Zoom animation, scale is a value between 0.16 and 16.0\n    float scale = abs(cos(iTime/2.0)) * 0.99 + 0.01;\n    scale = scale * scale * 16.0;\n    position *= scale;\n    pixelsPerEm /= scale;\n\n    // Calculate pixel coverage\n    float coverage = 0.0;\n    for (int i=0;i<=14;i+=2) {\n        vec2 p0 = fetchBezier(i+0) - position;\n        vec2 p1 = fetchBezier(i+1) - position;\n        vec2 p2 = fetchBezier(i+2) - position;\n        updateCoverage(pixelsPerEm, p0, p1, p2, coverage);\n    }\n    for (int i=17;i<=59;i+=2) {\n        vec2 p0 = fetchBezier(i+0) - position;\n        vec2 p1 = fetchBezier(i+1) - position;\n        vec2 p2 = fetchBezier(i+2) - position;\n        updateCoverage(pixelsPerEm, p0, p1, p2, coverage);\n    }\n    \n    // Normalize coverage\n    coverage = sqrt(clamp(abs(coverage) * 0.5, 0.0, 1.0));\n    \n    // Final color\n    fragColor = vec4(coverage, coverage, coverage, 1.0);\n}","name":"Image","description":"","type":"image"}]}