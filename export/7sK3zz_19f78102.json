{"ver":"0.1","info":{"id":"7sK3zz","date":"1631018297","viewed":99,"name":"Domain Colouring","username":"ashishkingdom","description":"Original (by Vince) - https://www.qb64.org/forum/index.php?topic=2923.0\nMore info - https://en.wikipedia.org/wiki/Domain_coloring","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["colorful","geometric","maths","complexnumbers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Converted into GLSL by Ashish\n    Originally from Vince - https://www.qb64.org/forum/index.php?topic=2923.0\n\n    Thanks to FabriceNeyret2 for suggestion in code. :)\n*/\n#define PI 3.14159265358979323\n\n#define mode int(iTime)%8\n#define S(v,l) smoothstep( -.7*fwidth(v), .7*fwidth(v), abs(fract(v +.5)-.5) -  (l) / (2.*PI)/2. )\n\nvec3 hrgb (float h, float m)\n{\n    vec3 c;\n    float mm;\n    \n    c.r = 0.5 - 0.5 * sin(2.0 * PI * h - PI / 2.0);\n    c.g = (0.5 + 0.5 * sin(2.0 * PI * h * 1.5 - PI / 2.0)) * float(h < 0.66);\n    c.b = (0.5 + 0.5 * sin(2.0 * PI * h * 1.5 + PI / 2.0)) * float(h > 0.33);\n    \n    mm = fract(m); //mod(m * 100.0, 100.0) * 0.01;\n    \n    if (fract(m)<.5/(2.*PI) || (mod(h * 2.0 * PI * 100.0, 4.0 * 2.0 * PI) < 6.0))\n    {\n        //return normalize(abs(vec3(c.r * 0.058 , 0.607 * c.g, 0.607 * c.b)));\n    }\n    else {\n        //return normalize(c);\n        return S(m,.5) * S(h*25.,1.5) * normalize(c);\n    }\n}\n\nvec2 compute (vec2 r, int n)\n{\n    vec2 p0 = r;\n    vec2 r2;\n    for(int i=0;i<=n;++i) {\n        r2 = mat2(r,-r.y,r.x) * r + p0;//vec2(r.x*r.x - r.y*r.y + p0.x, 2.0*r.x*r.y + p0.y);\n        r = r2;\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = iResolution.xy;\n    vec2 q = fragCoord;\n    vec2 uv, p;\n    uv = q - s/2.;//vec2(q.x - s.x/2.0, s.y/2.0 - q.y);\n    \n    switch(mode) {\n        case 0: // z\n            uv *= 0.015;\n            p = uv;\n            break;\n        case 1: // exp(z)\n            uv *= 0.01;\n            uv.x += 2.0;\n            p = vec2(exp(uv.x)*cos(uv.y), exp(uv.x)*sin(uv.y));\n            break;\n        case 2: // sin(z)\n             uv *= 0.015;\n             p = vec2(sin(uv.x)*cosh(uv.y), cos(uv.x)*sinh(uv.y));\n             break;\n        case 3: //f(z) = z^2 + c\n            uv *= 0.005;\n            uv.x -= 0.5;\n            p = compute(uv, 0);\n            break;\n        case 4: //f(f(z))\n            uv *= 0.005;\n            uv.x -= 0.5;\n            p = compute(uv, 1);   \n            break;\n        case 5: //f(f(f(f(z))))\n            uv *= 0.005;\n            uv.x -= 0.5;\n            p = compute(uv, 3);\n            break;\n        case 6: //f(f(f(f(f(f(f(f(f(f(z))))))))))\n            uv *= 0.005;\n            uv.x -= 0.5;\n            p = compute(uv, 9);\n            break;\n        case 7: //sin(1/z)\n            uv *= 0.005;\n            p.x = sin(uv.x/dot(uv,uv)) * cosh(-uv.y/dot(uv, uv));\n            p.y = cos(uv.x/dot(uv,uv)) * sinh(-uv.y/dot(uv, uv));\n            break;\n    }\n    \n    float m = length(p);\n    float a = (PI + atan(p.y, p.x)) / (2.0 * PI);\n    fragColor = vec4(hrgb(a,m), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}