{"ver":"0.1","info":{"id":"NdcGzj","date":"1630150040","viewed":143,"name":"Black-body spectrum","username":"Althar","description":"The spectrum is computed via integration, rather than the approximated planckian locus formula (e.g. 'https://www.shadertoy.com/view/tsKczy' which matches very closely). Mouse click and drag to show a single temperature or let the cursor slide by itself.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blackbody","colortemperature","cie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst float pi                   = 3.14159265359;\nconst float plancks_constant     = 6.62607015 * 10e-35;\nconst float boltzmanns_constant  = 1.38064852 * 10e-24;\nconst float speed_of_light       = 299792458.0;\n\n// Settings\nconst uint number_of_iterations       = 64u;\nconst float min_temperature_in_kelvin = 1000.0;\nconst float max_temperature_in_kelvin = 12000.0;\n\n// Gaussian function - see : https://en.wikipedia.org/wiki/CIE_1931_color_space\nfloat gaussian(float x, float a, float u, float a1, float a2)\n{\n    float t = (x - u) / (x < u ? a1 : a2);\n\treturn a * exp(-(t * t) / 2.0);\n}\n\n// Wave length to XYZ conversion - see : https://en.wikipedia.org/wiki/CIE_1931_color_space\nvec3 convert_wave_length_to_XYZ(float wave_length_nm)\n{\n\t// The analytical approximation assumes the wave length is measured in angstroms\n\tfloat wave_length_angstroms = wave_length_nm * 10.0;\n    \n\t// Approximate with the sum of gaussian functions\n\tvec3 XYZ;\n\tXYZ.x = gaussian(wave_length_angstroms, 1.056, 5998.0, 379.0, 310.0) + gaussian(wave_length_angstroms, 0.362, 4420.0, 160.0, 267.0) + gaussian(wave_length_angstroms, -0.065, 5011.0, 204.0, 262.0);\n\tXYZ.y = gaussian(wave_length_angstroms, 0.821, 5688.0, 469.0, 405.0) + gaussian(wave_length_angstroms, 0.286, 5309.0, 163.0, 311.0);\n\tXYZ.z = gaussian(wave_length_angstroms, 1.217, 4370.0, 118.0, 360.0) + gaussian(wave_length_angstroms, 0.681, 4590.0, 260.0, 138.0);\n    \n    // Done\n\treturn XYZ;\n}\n\n// XYZ to sRGB conversion - see : https://en.wikipedia.org/wiki/SRGB\nvec3 convert_XYZ_to_sRGB(vec3 XYZ)\n{\n\t// CIE XYZ -> sRGB\n\tvec3 sRGB;\n\tsRGB.x =  3.2406 * XYZ.x - 1.5372 * XYZ.y - 0.4986 * XYZ.z;\n\tsRGB.y = -0.9689 * XYZ.x + 1.8758 * XYZ.y + 0.0415 * XYZ.z;\n\tsRGB.z =  0.0557 * XYZ.x - 0.2040 * XYZ.y + 1.0570 * XYZ.z;\n\t\n\t// Apply gamma correction\n\tfloat a = 0.055;\n\tsRGB.x = (sRGB.x <= 0.0031308) ? 12.92 * sRGB.x : (1.0 + a) * pow(sRGB.x, 1.0 / 2.4) - a;\n\tsRGB.y = (sRGB.y <= 0.0031308) ? 12.92 * sRGB.y : (1.0 + a) * pow(sRGB.y, 1.0 / 2.4) - a;\n\tsRGB.z = (sRGB.z <= 0.0031308) ? 12.92 * sRGB.z : (1.0 + a) * pow(sRGB.z, 1.0 / 2.4) - a;\n\t\n\t// Done\n\treturn vec3(sRGB.x, sRGB.y, sRGB.z);\n}\n\n// Implementation of Planck's law - see : https://en.wikipedia.org/wiki/Planck%27s_law\nfloat convert_wave_length_to_black_body_spectrum(float wave_length_nm, float temperature_in_kelvin)\n{\n    float wave_length_in_meters = wave_length_nm * 1e-9;\n    float c1                    = 2.0 * pi * plancks_constant * speed_of_light * speed_of_light;\n    float c2                    = plancks_constant * speed_of_light / boltzmanns_constant;\n    float m                     = c1 / pow(wave_length_in_meters, 5.0) * 1.0 / (exp(c2 / (wave_length_in_meters * temperature_in_kelvin)) - 1.0);\n    return m;\n}\n\n// Information on remapping the black body temperature to sRGB - see : https://astronomy.stackexchange.com/questions/39994/what-is-the-rgb-curve-for-blackbodies\n// Another good reference for implementation : https://www.fourmilab.ch/documents/specrend/specrend.c\nvec3 convert_black_body_temperature_to_sRGB(float temperature_in_kelvin) \n{\n\tvec3 XYZ = vec3(0.0);\n\n    // Integrate\n    for (uint k = 0u ; k < number_of_iterations ; ++k)\n    {\n        float wave_length_nm = mix(380.0, 780.0, float(k) / float(number_of_iterations - 1u));\n        float spectrum       = convert_wave_length_to_black_body_spectrum(wave_length_nm, temperature_in_kelvin);\n\n        // Accumulate\n        XYZ += spectrum * convert_wave_length_to_XYZ(wave_length_nm);\n    }\n\n    // Normalize to the tristimulus values\n    vec2 xy = XYZ.xy / (XYZ.x + XYZ.y + XYZ.z);\n\n\t// The sRGB colour space assumed that the XYZ has been scaled to (0.9505, 1, 1.0890) for CIE D65, i.e. Y = 1\n\tXYZ = vec3(xy.x / xy.y, 1.0, (1.0 - xy.x - xy.y) / xy.y);\n\t\n\t// XYZ to sRGB\n\tvec3 sRGB = convert_XYZ_to_sRGB(XYZ);\n\n    // Normalize RGB to preserve chromaticity\n\treturn sRGB / max(sRGB.x, max(sRGB.y, sRGB.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     \n    // Normalised cursor\n    float cursor_position = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) : cos(0.25 * iTime) * 0.5 + 0.5;\n    \n    if( uv.y < 0.5 )\n    {\n        // Black body temperature\n        float temperature_in_kelvin = mix(min_temperature_in_kelvin, max_temperature_in_kelvin, cursor_position);\n        vec3 sRGB = convert_black_body_temperature_to_sRGB(temperature_in_kelvin);\n        \n        fragColor = vec4(sRGB,1.0);\n    }\n    else\n    {\n        // Black body temperature\n        float temperature_in_kelvin = mix(min_temperature_in_kelvin, max_temperature_in_kelvin, uv.x);\n        vec3 sRGB = convert_black_body_temperature_to_sRGB(temperature_in_kelvin);\n\n        // Output to screen\n        fragColor = vec4(sRGB,1.0);\n        \n        // Show cursor\n        if( abs(fragCoord.x - cursor_position * iResolution.x) < 1.0 )\n        {\n            fragColor = mix(fragColor, vec4(1.0) - fragColor, 0.1);\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}