{"ver":"0.1","info":{"id":"NdlBDS","date":"1645321051","viewed":84,"name":"modifiedAbs 6","username":"gaz","description":"test","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["modifiedabs"],"hasliked":0,"parentid":"NdsBWS","parentname":"modifiedAbs 5"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nconst float maxd=80.0;\n\nvec3 rot(vec3 p, vec3 axis,float theta){\n\taxis=normalize(axis);\n\treturn mix(axis*dot(p,axis),p,cos(theta))+sin(theta)*cross(p,axis);\n}\n\n#if 1\nfloat modifiedAbs(float x){\n    float h=tanh(x*5.);\n    float k=.2+sin(iTime)*.1;\n    x=abs(x);\n    //return h*h*x;\n    return mod(iTime,2.)>1.?\n        x*pow(min(1.,x/k),2.):\n        h*h*x*pow(min(1.,x/k),2.);\n}\n\n#else\nfloat modifiedAbs(float x){\n    float k=.2+sin(iTime)*.1;\n    x=abs(x);\n    return x+(k-x)*mix(1.,0.,pow(min(1.,x/k),3.));\n}\n\n#endif\n\nfloat modifiedMin(float a, float b){\n    return (a+b-modifiedAbs(a-b))*.5;\n}\n\nfloat modifiedMax(float a, float b){\n    return (a+b+modifiedAbs(a-b))*.5;\n}\n\nvec2 modifiedFold(vec2 p, vec2 v)\n{\n    float g=dot(p,v);\n    return p-(g-modifiedAbs(g))*v;\n}\n\n// inspired https://twitter.com/7CIT/status/1235459606840610816\nvec2 signedModifiedFold(inout vec2 p, vec2 v)\n{\n    float g=dot(p,v);\n    return (p-(g-modifiedAbs(g))*v)*vec2(sign(g),1);\n}\n\nvec2 mirrorVic(float a)\n{\n    a=radians(a)*.5;\n    return vec2(cos(a),sin(a));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(vec3 p)\n{\n    float de0=p.y+2.2;\n    p=rot(p,normalize(vec3(0,1,0)),iTime*.5);\n    float de1=length(p)-1.;\n    float de2=sdRoundBox(p,vec3(1,.1,.1),.2);\n    p.z=abs(p.z)-3.;\n    p.z+=1.;\n    p.zy=signedModifiedFold(p.zy,mirrorVic(30.*sin(iTime)));\n    p.z+=1.;\n    p.zy=signedModifiedFold(p.zy,mirrorVic(-30.*sin(iTime)));\n    p.z+=1.; \n    float de3=sdRoundBox(p,vec3(3,.3,.05).yzx,.1);\n    return min(de0,modifiedMin(modifiedMax(de1,-de2),de3))*.8;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 doColor(vec3 p)\n{\n     return mix(vec3(1),H(.05),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(2.5);\n    vec3 ta = vec3(0);\n    vec3 rd = normalize(vec3(uv,2.0));\n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n    vec3 v = cross(u,w);\n    rd = mat3(u,v,w) * rd;\n    vec3 col= vec3(0.05,0.05,0.1);\n    float t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n    \tvec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(5,5,1);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        float sha = min(1.,calcShadow( lightPos, -li, len )+.8);\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn;\n    \tcol*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.3,.3,.3)*pow(clamp(dot(reflect(rd,n),li),0.,1.),80.);\n    }\n    fragColor.xyz = col;\n}\n\n     ","name":"Image","description":"","type":"image"}]}