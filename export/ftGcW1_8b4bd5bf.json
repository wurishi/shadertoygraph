{"ver":"0.1","info":{"id":"ftGcW1","date":"1661364442","viewed":278,"name":"Robot Design","username":"Poisson","description":"A small robot that I modeled with raymarching","likes":24,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d","raymarching","ray","raymarcher","robot","bot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TAU 6.283185\n#define MAX_DIST 100.\n#define DESAT .5+.5* // remap from -1 to 1 to 0 to 1\n#define SUN_POS vec3(-4,8,12)\n#define AA 2 // antialiasing / set it to 1 if you have a slow computer\n\n// ray setup function\nvec3 getRayDir(vec2 uv, vec3 c, vec3 t, float z) {\n    vec3 f = normalize(t - c);\n    vec3 s = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f, s);\n    return  normalize(f*z + uv.x*s + uv.y*u);\n}\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// chebyshev distance: https://www.desmos.com/calculator/d5tuwnadvh\n\nfloat chebyshev(vec3 p, float k) {\n    p = abs(p);\n    return pow(pow(p.x, k)+pow(p.y, k)+pow(p.z, k), 1./k);\n}\n\nfloat chebyshev(vec2 p, float k) {\n    p = abs(p);\n    return pow(pow(p.x, k)+pow(p.y, k), 1./k);\n}\n\n// signed distance functions\n// https://iquilezles.org/articles/distfunctions/\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0., h);\n    return length(p) - r;\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2.*ra+rb, abs(p.y) - h);\n    return min(max(d.x,d.y),0.) + length(max(d,0.)) - rb;\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h, float k) {\n    vec2 d = vec2(chebyshev(p.xz, k) - 2.*ra+rb, abs(p.y) - h);\n    return min(max(d.x,d.y),0.) + length(max(d,0.)) - rb;\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat sdRoundBox(vec3 p, vec3 s, float r) {\n    p = abs(p) - s;\n    return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0) - r;\n}\n\n// hollow cylinder function by me\nfloat sdHollowCylinder(vec3 p, vec3 s) {\n    return length(vec2(length(p.yz) - s.x, max(0., abs(p.x) - s.y))) - s.z;\n}\n\nfloat sdSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h) - r;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float r) {\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.,x-((paba<.5)?ra:rb));\n    float cay = abs(paba-.5)-.5;\n    float k = rba*rba + baba;\n    float f = clamp((rba*(x-ra)+paba*baba)/k, 0., 1.);\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx<0. && cay<0.) ? -1. : 1.;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba)) - r;\n}\n\nfloat sdHorseshoe(vec3 p, float a, float r, float le, vec2 w, float r1) {\n    float c = cos(a), s = sin(a);\n    p.x = abs(p.x);\n    float l = length(p.xy);\n    p.xy = mat2(-c, s, \n              s, c)*p.xy;\n    p.xy = vec2((p.y>0. || p.x>0.)?p.x:l*sign(-s),\n                (p.x>0.)?p.y:l );\n    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.);\n    \n    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.,max(p.x,p.y)),p.z);\n    vec2 d = abs(q) - w;\n    return min(max(d.x,d.y),0.) + length(max(d,0.)) - r1;\n}\n\nfloat sdScene(vec3 p) {\n    float d = 1e10;\n    \n    // head\n    \n    d = min(d, chebyshev(p, 2.3) - .48);\n    d = max(d, -p.y);\n    d = min(d, sdRoundedCylinder(p - vec3(0,-.1,0), .25,.025,.1, 2.3));\n    \n    // eyes\n    \n    vec3 q = p.zyx;\n    d = max(d, -sdSphere(q - vec3(.425,.025,.175), .09));\n    d = max(d, -sdSphere(q - vec3(.425,.05,-.175), .12));\n    \n    d = min(d, sdHollowCylinder(q - vec3(.25,.025,.175), vec3(.08,.25,.0125)));\n    d = min(d, sdHollowCylinder(q - vec3(.25,.05,-.175), vec3(.11,.25,.0125)));\n    d = min(d, sdSphere(q - vec3(.35,.025,.175), .075));\n    d = min(d, sdSphere(q - vec3(.35,.05,-.175), .105));\n    \n    // bolts\n    \n    q = p;\n    for (int i = 0; i < 4; i++) {\n        q.xz *= rot(float(i)*PI*.5);\n        d = min(d, sdSphere(q - vec3(.5,-.1,0), .025));\n    }\n    \n    // neck\n    \n    d = min(d, sdCylinder(p - vec3(0,-.325,0), .1,.1));\n    d = min(d, sdRoundedCylinder(p.yxz - vec3(-.225,0,0), .02, .025, .125));\n    \n    // body\n    \n    d = min(d, sdRoundedCylinder(p - vec3(0,-.525,0), .15, .025, .15+.025, 3.));\n    d = min(d, sdRoundBox(p - vec3(0,-.55,.225), vec3(.1,.06,.1), .015));\n    d = min(d, sdRoundedCylinder(p.yxz - vec3(-.79-.025,0,0), .045, .01, .125));\n    \n    // bolts\n    \n    q = p;\n    q -= vec3(0,-.55,.35);\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    d = min(d, sdSphere(q - vec3(.085,.045,-.01), .015));\n\n    // legs\n    \n    q = p;\n    q.x = abs(q.x);\n    d = min(d, sdSphere(q - vec3(.19-.025-.005,-.79-.025,0), .065));\n    q -= vec3(.19-.025-.005,-.785-.025,0);\n    q.yz *= rot(.2);\n    d = min(d, max(sdRoundBox(q, vec3(.0025,.25,.025), .01), p.y + .785));\n    d = min(d, sdSphere(q - vec3(0,-.25,0), .05));\n    d = min(d, sdCappedCone(q, vec3(0,-.25,0), vec3(0,-.45,-.1), .06, .095, .01));\n    d = min(d, .5*sdCappedCone(q * vec3(1.7,1,1), vec3(0,-.45,-.1), vec3(0,-.55,-.15), .05, .17, .01));\n    \n    // arms\n    \n    q = p;\n    q.x = abs(q.x);\n    d = min(d, sdSphere(q - vec3(.175*2.-.025,-.45,0), .075));\n    d = min(d, sdSegment(q, vec3(.175*2.-.025,-.45,0), vec3(.4,-.7,-.025), .025));\n    d = min(d, sdSphere(q - vec3(.4,-.7,-.025), .05));\n    d = min(d, sdCappedCone(q, vec3(.4,-.7,-.025), vec3(.375,-.9,.05), .06, .095, .01));\n    q = q.zyx * vec3(1,-1,1) - vec3(.05,.925,.375);\n    q.zx *= rot(.2);\n    d = min(d, sdHorseshoe(q, 1.3, .075, .075, vec2(.01,.01), .01));\n    \n    // support\n    \n    d = min(d, sdRoundedCylinder(p - vec3(0,-1.6,0), .25, .01, .05, 3.));\n    \n    // output\n    return d;\n}\n\n// main raymarching loop\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0; i < 512; i++) {\n        vec3 p = ro + rd * d;\n        float s = sdScene(p);\n        d += s;\n        if (s < .001 || d > MAX_DIST) break;\n    }\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(.0001,0);\n    float d = sdScene(p);\n    \n    return normalize(d - vec3(sdScene(p - e.xyy),\n                              sdScene(p - e.yxy),\n                              sdScene(p - e.yyx)));\n}\n\n// soft shadow function by iq: https://iquilezles.org/articles/rmshadows/\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k)\n{\n\tfloat res = 1.;\n    float t = .01;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 64; i++) {\n\t\tfloat h = sdScene(ro + rd * t);\n        float y = h * h/ (2.*ph);\n        float d = sqrt(h*h - y*y);\n        res = min(res, k*d / max(0., t - y));\n        ph = h;\n        \n        t += h;\n        if( res < .001 || t > 16.) {\n            break;\n        }\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// ambient occlusion by iq: https://www.shadertoy.com/view/Xds3zN\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = sdScene( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// biplanar mapping function\n\nvec3 applyTexture(sampler2D tex, vec3 p, vec3 n, float k) {\n     p = DESAT p;   \n     \n     vec3 xy = texture(tex, p.xy).rgb;\n     vec3 xz = texture(tex, p.xz).rgb;\n     vec3 yz = texture(tex, p.yz).rgb;\n            \n     n = abs(n);\n     n = pow(n, vec3(k));\n     n /= dot(n, vec3(1));\n            \n     return xy*n.z + xz * n.y + yz*n.x;\n}\n\n// background color\n\nvec3 background(vec3 rd) {\n    vec3 sky = mix(vec3(1), vec3(.5,.7,1), DESAT rd.y);\n    \n    vec3 sunpos = vec3(-1,2,3)*4.;\n    vec3 p = rd * max(0., dot(SUN_POS, rd));\n    float sun = .1/length(SUN_POS - p);\n    \n    return sky + sun * vec3(1,.6,.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // antialiasing by iq\n    \n    vec3 tot = vec3(0);\n    for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n        vec2 o = vec2(i, j) / float(AA) - .5;\n        vec2 uv = (fragCoord + o - .5 * iResolution.xy) / iResolution.y;\n        \n        // setup camera\n        \n        vec3 ro = vec3(0,(mouse.y-.5) * 4.,-3);\n        ro.xz *= rot(iTime-mouse.x*TAU);\n        \n        vec3 rd = getRayDir(uv, ro, vec3(0,-.5,0), 1.);\n\n        float d = rayMarch(ro, rd);\n        \n        vec3 col = background(rd);\n        if (d < MAX_DIST) {\n        \n            // coloring and lighting\n            \n            vec3 p = ro + rd * d;\n            vec3 n = calcNormal(p);\n            vec3 r = reflect(rd, n);\n            \n            vec3 mat = .7+.3*applyTexture(iChannel0, p, n, 32.);\n            col = vec3(0);\n            \n            vec3 lig = normalize(SUN_POS);\n            float dif = clamp(dot(n, lig), 0., 1.); // diffuse lighting\n            float sha = calcSoftshadow(p, lig, 16.); // soft shadow\n            float occ = calcAO(p, n); // ambient occlusion\n            float glo = DESAT -n.y;\n            float sky = 1. - dif*sha;\n\n            col += mat * sqrt(dif * sha); // base ligthing\n            col += mat * .4*vec3(1,.5,.3) * glo * occ; // global illumination (fake)\n            col += occ*mat * .2*sky; // indirect sky illumination (fake)\n        }\n        col = pow(col, vec3(.4545)); // gamma correction\n        tot += col;\n    }\n    }\n    tot /= float(AA*AA);\n    tot = clamp(tot, 0., 1.);\n    \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}