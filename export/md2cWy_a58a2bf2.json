{"ver":"0.1","info":{"id":"md2cWy","date":"1688139355","viewed":131,"name":"Platonic DOP","username":"spalmer","description":"Was working on Icosahedron and wound up with way more cool stuff than I needed, so I moved the generalized platonic solids here.\n\nby time I debugged the ray clipping method, I had the raymarching working just as well, so I kept both.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","polyhedra","platonic","discreteorientedpolytope","dop"],"hasliked":0,"parentid":"Dts3z7","parentname":"Icosahedron DOP"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// idea from http://shadertoy.com/view/Mtc3RX\n\nconst float\n    P = sqrt(1.25) + .5, //(sqrt(5.)+1.)/2., //1.6180339887498948482045868343656 phi\n    U = P + 1., //P * P, // amazingly these  //2.6180339887498948482045868343656 // are the same number!!\n    T = inversesqrt(P+2.), //inversesqrt(P*P+1.), //sqrt(2.)/sqrt(sqrt(5.)+5.), //0.52573111211913360602566908484788\n    V = P * T, //(sqrt(2.)*sqrt(5.)+sqrt(2.))/(2.*sqrt(sqrt(5.)+5.)) //0.85065080835203993218154049706302\n    Q = inversesqrt(U*U+1.), //inversesqrt((P+1.)*(P+1.)+1.), //0.35682208977308993194196984304609\n    R = U * Q, //0.93417235896271569645111862354806\n    W = sqrt(1./2.), //0.70710678118654752440084436210485\n    S = sqrt(1./3.); //0.57735026918962576450914878050196\n// phi is a cool number, P - 1. = 1. / P and other such divine co-incidences.  It's the most irrational!\n// these (plus their negatives) are the plane normals for the slabs of the DOP\n\n// can easily do most of the platonic solids,\n// tetrahedron requires some modification to the slab clipper to just do planes\n\nconst vec3 N[] = vec3[] (\n #if 0\n    // cube, squished a bit\n    vec3(1.1,0,0),\n    vec3(0,1.1,0),\n    vec3(0,0,1.1)\n #elif 0\n    // rhombic dodecahedron; vec3(0, W, W) = normalize(vec3(0, 1, 1)), something I stumbled on one day\n    vec3( 0, W, W),\n    vec3( 0,-W, W),\n    vec3( W, 0, W),\n    vec3(-W, 0, W),\n    vec3( W, W, 0),\n    vec3(-W, W, 0)\n #elif 1\n    // dodecahedron; vec3(0, T, V) = normalize(vec3(0, 1, P))\n    vec3( 0, T, V),\n    vec3( 0,-T, V),\n    vec3( V, 0, T),\n    vec3(-V, 0, T),\n    vec3( T, V, 0),\n    vec3(-T, V, 0)\n #elif 0\n    // octahedron\n    vec3( S, S, S), // half of cube's vertices gives tetrahedron; as slabs, makes octahedron\n    vec3(-S, S, S),\n    vec3( S,-S, S),\n    vec3( S, S,-S)\n #else\n    // icosahedron combines the octahedron above with vec3(0, Q, R) = normalize(vec3(0,1,P+1.))\n    vec3( S, S, S),\n    vec3(-S, S, S),\n    vec3( S,-S, S),\n    vec3( S, S,-S),\n    vec3( 0, Q, R),\n    vec3( 0,-Q, R),\n    vec3( R, 0, Q),\n    vec3(-R, 0, Q),\n    vec3( Q, R, 0),\n    vec3(-Q, R, 0)\n #endif\n);\n\nconst float size = 1.4; //.5; //.9; //\n\n#define IZERO min(0, iFrame)\n\nfloat dshape(vec3 q)\n{\n    float d = -3.4e38;\n    for (int i = N.length(); i-- > 0; d = max(d, abs(dot(q, N[i])) - size)); // DOP\n    return d;\n}\n\nfloat dscene(vec3 q)\n{\n    return min(dshape(q), 6. - length(q) + dot(sin(q*32.), vec3(1)) * .0008); // add bg\n}\n\n// mini spherecast raymarcher from http://shadertoy.com/view/DlBGWz\nvec3 gscene(vec3 q, float h)\n{\n    vec3 e = vec3(1,0,0), g = e.zzz;\n    for (int i = IZERO + 6; \n            i-- > 0;\n            g += dscene(q + h * e) * e, e = e.zxy)\n        if (i == 2) e = -e;\n    return .5 * g;\n}\n\nvoid march(inout vec3 q, vec3 r, int n, float e)\n{\n    float d = 1.;\n    for (int i = IZERO + n; i-- > 0 && abs(d) > e;\n         q += r * (d = dscene(q)));\n}\n\n// trace slabs clipping\n// analytic ray/DOP\n// would need modified to draw tetrahedrons\nvoid trace(vec3 f, vec3 d, out vec3 n, inout vec2 r)\n{\n    vec3 n1 = -d;\n    // ray intersection with intersection of all halfspaces\n    for (int i = IZERO + N.length(); i-- > 0; ) {\n        vec3 n2 = N[i];\n        float df = dot(n2, f),\n          dp = dot(n2, d), // ray/slab intersection setup\n          a = abs(dp);\n        if (a < 1e-7) continue;\n        vec2 r2 = (size * vec2(-1,1) - sign(dp) * df) / a; // entry/exit of slab\n        if (r2.x > r.x)\n            n1 = n2 * sign(df);\n        r = vec2(max(r.x, r2.x), min(r.y, r2.y)); // clip ray\n        //if (!(r.x < r.y)) break; // may as well stop when totally clipped, but will diverge execution threads\n    }\n    n = n1;\n}\n\nconst float e = 5.; // how far eye is back from origin\n\nfloat shootray(vec3 q, vec3 r, out vec3 n)\n{\n #if 1\n    vec3 o = q;\n    march(q, r, 96, .001);\n    float d = length(q - o),\n        precis = d * .0006;\n    vec3 g = gscene(q, precis);\n    /*if (!(d > 0.))  {\n        d = 2.*e;\n        g = -r;\n    }*/\n    n = normalize(g);\n    return d;\n #else\n    vec2 d = vec2(0,e+size); //9e9); //\n    trace(q, r, n, d);\n    bool hit = d.x > 0. && d.x < d.y;\n    if (!hit) {\n        d.x = 2.*e; //9.; //-1.; //\n        q += d.x*r;\n        n = -r + .02*sin(28.*q);\n    }\n    n = normalize(n);\n    return d.x;\n #endif\n}\n// TODO needs AA - especially the analytical slabs version.\n// I hacked Fabrice's easy AA into Common for now, helps a lot!\n\n// Fabrice-style golf rotate\nmat2 rot(float c)\n{\n    return mat2(cos((c) + vec4(0,33,11,0)));\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec3 r = iResolution, n, f = vec3(0,0,1);\n    float t0 = .3 * sin(.1*iTime), t1 = .05*iTime;\n    r = vec3(p - .5 * r.xy, min(r.x,r.y));\n    r.zy *= rot(t0);  r.zx *= rot(t1);\n    f.zy *= rot(t0);  f.zx *= rot(t1);\n    r = normalize(r);\n    f = normalize(f);\n    float t = shootray(-e*f, r, n);\n    bool bg = t > e+size;\n    o = textureLod(iChannel0, reflect(r, n), bg ? 5. : 0.); // mirror reflection\n}\n\n    //vec3 L = normalize(vec3(7,9,8)), //vec3(sqrt(1./3.)), //\n    //O.rgb *= dot(n, L) * .5 + .5; // lit\n    //O.rgb *= n * .5 + .5;\n    //O.rgb *= exp2(-.02*d); // black fog\n    //O = sqrt(O); // gamma (no need since using gamma texture)\n\n// TODO when ready to get more advanced, see http://shadertoy.com/view/4ltBDH or http://shadertoy.com/view/7ldfzS","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// easy antialiasing based on Fabrice http://shadertoy.com/view/NdyfRz\n#if 1\nint _AA = 3;\n#define mainImage _mainImage_(out vec4 O, vec2 U); \\\nvoid mainImage(out vec4 O, vec2 U) {               \\\n    vec4 o; O = vec4(0);                           \\\n    for (int j=0; j < _AA; ++j)                    \\\n    for (int i=0; i < _AA; ++i)                    \\\n    { vec2 V = U + (vec2(i,j))/float(_AA) - .5;    \\\n       _mainImage_(o, V);                          \\\n        O += pow(o, vec4(2.2)); }                  \\\n    O = pow(O / float(_AA*_AA), vec4(1./2.2));     \\\n} \\\nvoid _mainImage_\n#endif","name":"Common","description":"","type":"common"}]}