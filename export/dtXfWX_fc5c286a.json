{"ver":"0.1","info":{"id":"dtXfWX","date":"1693518571","viewed":66,"name":"Sketch #11: Warped Grid","username":"MOONtyzoo","description":"This time I tried warping the uv coordinates by scaling them according to noise instead of rotating them. The grid grows outwards when the noise value is high (the red spots) and stays in place for low noise (white)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nfloat smoothmix(float a, float b, float x)\n{\n    return (1.0-smoothstep(0.0, 1.0, x))*a + smoothstep(0.0, 1.0, x)*b;\n}\n\nfloat grid(in vec2 uv, in float size)\n{\n    uv = fract(uv);\n    return smoothstep(0.0, size*0.05, abs(uv.x-0.5))\n            *smoothstep(0.0, size*0.05, abs(uv.y-0.5));\n}\n\nmat2 rotate2D(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nmat2 scale2D(float scalar)\n{\n    return mat2(scalar, 0.0,\n                0.0, scalar);\n}\n\nfloat random(float x)\n{\n    return fract(439029.0*sin(x));\n}\n\nfloat random(vec2 uv)\n{\n    return fract(439029.0*sin(dot(uv, vec2(85.3876, 9.38532))));\n}\n\nvec2 randomGradientVec(vec2 uv)\n{\n    float angle = 2.0*PI*random(uv);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat noise(in vec2 uv, in float sampleNum)\n{\n    /*\n        Creates gradients at sample points\n        \n        Quadrants 1, 2, 3, 4 correspond to letters d, c, a, b\n    */\n    vec2 uv_i = floor(uv*sampleNum);\n    vec2 uv_f = fract(uv*sampleNum);\n    float time_i = floor(iTime);\n    float time_f = fract(iTime);\n    \n    vec2 gradA = randomGradientVec(uv_i);\n    vec2 gradB = randomGradientVec(uv_i + vec2(1.0, 0.0));\n    vec2 gradC = randomGradientVec(uv_i + vec2(0.0, 1.0));\n    vec2 gradD = randomGradientVec(uv_i + vec2(1.0, 1.0));\n    \n    /*\n        Dot product and interpolation to get noise value at each pixel\n    */\n    float valA = dot(uv_f, gradA);\n    float valB = dot(uv_f - vec2(1.0, 0.0), gradB);\n    float valC = dot(uv_f - vec2(0.0, 1.0), gradC);\n    float valD = dot(uv_f - vec2(1.0, 1.0), gradD);\n    float valAB = smoothmix(valA, valB, uv_f.x);\n    float valBC = smoothmix(valC, valD, uv_f.x);\n    float val = 0.8*smoothmix(valAB, valBC, uv_f.y) + 0.5;\n    \n    return val;\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n// ------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    /*\n        Warps the uv coordinates and draws grid\n    */\n    uv *= 10.0;\n    float normalGrid = grid(uv, 1.0);\n    float noise = noise(uv + vec2(2.0)*iTime, 0.2);\n    uv *= 1.0 - 0.2*noise;\n    float warpedGrid = grid(uv, 1.0);\n    \n    /*\n        Coloring\n    */\n    \n    vec3 HSV = vec3(0.0, 0.0, 0.0);\n    HSV[0] = 0.0;\n    HSV[1] = 0.4*noise;\n    HSV[2] = normalGrid*warpedGrid + 0.5*smoothstep(1.0, 0.0, normalGrid);\n    vec3 color = hsv2rgb(HSV);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}