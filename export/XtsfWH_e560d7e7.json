{"ver":"0.1","info":{"id":"XtsfWH","date":"1511790887","viewed":357,"name":"Infinite road illusion","username":"Otringal","description":"A simple 3D faking of an infinitely-long running road using 2D functions.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","illusion","road","infinite","rolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getAspectRatio()\n{\n    return iResolution.x / iResolution.y;\n}\n\nvec2 getUVCoords(in vec2 fragCoords)\n{\n    return ((fragCoords - 0.5) / (iResolution.xy - 1.0) - 0.5) * vec2(getAspectRatio(), 1.0);\n}\n\nvoid drawSky(in vec2 uvCoords, inout vec4 canvas)\n{\n    vec4 sky = vec4(1.0 - 1.4 * sqrt(uvCoords.y),\n                  \t0.5 - 3.7 * uvCoords.y,\n                  \t0.5 - 0.8 * uvCoords.y,\n                  \t1.0);\n    \n    canvas = clamp(sky, 0.0, 1.0); //needed due to sqrt() of negative values\n}\n\nvoid drawSun(in vec2 uvCoords, inout vec4 canvas)\n{\n    vec2 origin = vec2(0.0, 0.0);\n    float radius = 0.25;\n    float blurAmount = 0.4;\n    vec3 color = vec3(1.0, 1.0, 0.2);\n    origin.x *= getAspectRatio();\n    float color_amount = 1.0 - smoothstep(radius - blurAmount, radius + blurAmount, distance(origin, uvCoords));\n    canvas += vec4(color_amount * color, 0.0);\n}\n\nvoid drawRoad(in vec2 uvCoords, inout vec4 canvas)\n{\n    float s = step(0.0, uvCoords.y);\n    float t = mod(iTime, 60.0); //needed hack for long-running scenes\n    vec4 road = vec4(vec3(sign(sin(70.0 * pow(-uvCoords.y, 0.3) - 25.0 * t))), 1.0);\n    \n    road = clamp(road, 0.0, 1.0); //needed due to sqrt() of negative values\n    road *= vec4(2.0 * (0.5 + uvCoords.y),\n                 1.6 * (0.5 + uvCoords.y),\n                 1.8 * (0.5 + uvCoords.y),\n                 1.0);\n    canvas = mix(road, canvas, s);\n}\n\nvoid drawSidewalk(in vec2 uvCoords, inout vec4 canvas)\n{\n    float s = step(0.85 * (0.015 - uvCoords.y), abs(uvCoords.x) / getAspectRatio()) * step(0.0, -uvCoords.y);\n    vec4 sidewalk = vec4(0.8 * (0.5 + uvCoords.y),\n                 \t\t 0.6 * (0.5 + uvCoords.y),\n                 \t\t 1.3 * (0.5 + uvCoords.y),\n                 \t\t 1.0);\n    \n    canvas = mix(canvas, sidewalk, s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = getUVCoords(fragCoord);\n    \n    drawSky(uv, fragColor);\n    drawSun(uv, fragColor);\n    drawRoad(uv, fragColor);\n    drawSidewalk(uv, fragColor);\n}","name":"Image","description":"","type":"image"}]}