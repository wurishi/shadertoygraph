{"ver":"0.1","info":{"id":"3df3zr","date":"1544663354","viewed":82,"name":"1 2DLine/Circle (Lesson Plan)","username":"CuttyFlamingo","description":"Line Lesson First Lesson","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["linelesson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Unity / HLSL Compatible Defines ////////////////////////////////////////\n#define saturate(a) clamp( a, 0.0, 1.0)\n#define frac fract\n#define lerp mix\n#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n#define uv fragCoord / iResolution.xy\n///////////////////////////////////////////////////////////////////////////\n\n// Definitions / Lesson ///////////////////////////////////////////////////\n\n//Dot / Dot Product\n\t//Source Code\n\t\t//dot stands for (a.x * b.x + a.y * b.y + a.z * b.z).\n\t//Description\n\t\t//A Dot used with normalized directions will result in a value representing inputs localised rotations from eachother,\n\t\t//ussually purposed for lighting where it results in: -1( 180 degree differance(Opposite)), 0( 90 degree differance(Tangent)), 1( 0 degrees differance(Same))\n\t\t//depending on the light direction and normal direction respectively.\n\n\t\t//However a Dot products secondary use is to work out how long one direction is along another.\n\t\t//Allowing for a point parallel to place along line ab to be found of which can be used in a distance comparison,\n\t\t//while trying to produce a line, as shown in this demo.\n\n//Length / Euclidean Length / Pythagorean Theorem\n\t//Source Code\n\t\t//length stands for sqrt(a.x * a.x + a.y * a.y + a.z * a.z).\n\t//Description\n\t\t//length is the distance of point a from origin point floatN(0.0).\n\n///////////////////////////////////////////////////////////////////////////\n\n// Antialiasing Power, Number of pixles to blend.\n#define PixelAA 2.0\n// mouse uv position\n#define mouse iMouse.xy / iResolution.xy\n// mouse down boolian\n#define MBD (iMouse.w > 0.0)\n\n//Returns Gradient 0 to 1\nfloat LineGradient( float2 p, float2 a, float2 b){\n    float2 V0 = b - a, V1 = p - a;\n    return saturate(dot( V0, V1) / dot(V0, V0));\n}\n//Returns the alpha of a Circle\nfloat DrawCircle( float2 p, float2 a, float radius){\n    float Distance\t\t= length( p - a) - radius;\n    return 1.0 - saturate(ceil(Distance));\n}\n//Returns the alpha of a Line\nfloat DrawLine( float2 p, float2 a, float2 b, float radius){\n    float2 V0\t\t\t= b - a, V1 = p - a;\n    float Inter \t\t= saturate(dot( V0, V1) / dot(V0, V0));\n    float Distance \t\t= length(V1 - V0 * Inter) - radius;\n    return 1.0 - saturate(ceil(Distance));\n}\n//Returns the alpha of an Antialised Circle\nfloat DrawCircleAA( float2 p, float2 a, float radius){\n    float Distance\t\t= length( p - a) - radius;\n    float AntiAlias\t\t= saturate(-(Distance * ( iResolution.y / PixelAA)));\n    return AntiAlias;\n}\n//Returns the alpha of an Antialised Line\nfloat DrawLineAA( float2 p, float2 a, float2 b, float radius){\n    float2 V0\t\t\t= b - a, V1 = p - a;\n    float Inter \t\t= saturate(dot( V0, V1) / dot(V0, V0));\n    float Distance \t\t= length(V1 - V0 * Inter) - radius;\n    float AntiAlias \t= saturate(-(Distance * ( iResolution.y / PixelAA)));\n    return AntiAlias;\n}\n\n//To be used to blend fully Colourised Drawings, dont worry about doing this with each first rendering.\nfloat4 AlphaBlend( float4 a, float4 b){\n    return saturate(float4(lerp(a.rgb, b.rgb, b.a), a.a + b.a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect fixed pixel coordinates with centre set to (0.0,0.0).\n    vec2 ScreenCoord = uv * 2.0 - 1.0;\n\tScreenCoord.x *= iResolution.x / iResolution.y;\n    \n    // Aspect fixed mouse coordinates with centre set to (0.0,0.0).\n    vec2 MousePos = mouse * 2.0 - 1.0;\n    MousePos.x *= iResolution.x / iResolution.y;\n    \n    // Drawn Line\n    float Line = DrawLineAA( ScreenCoord, float2(-1.0,-0.5), ((MBD)? MousePos: float2( 1.0, 0.5)), 0.1);\n    \n    // Output to screen\n    fragColor = vec4(vec3(Line),1.0);\n}","name":"Image","description":"","type":"image"}]}