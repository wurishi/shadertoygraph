{"ver":"0.1","info":{"id":"dsVfzd","date":"1698554970","viewed":99,"name":"PolyRefraction Parallax || P=NP","username":"ElSolem","description":"Test of the simple parrallax thingy. It applies the symbol equation for calculating parallax. Biconvex Parallax, and Biconcave Parallax. It calculates the line through an Abs(0) and then plots points around it. It starts at 1 and increases exponentially. ","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["simple","parallax","fun","polyrefraction","biconvex","biconcave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float d){\n\treturn mix(vec3(0.1,0.94,0.98),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = -5; i<25; ++i){\n        float t = iTime*-.314;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*1.50);\n        p.xz = abs(p.xz);\n        p.xz-=.12;\n\t}\n\treturn dot(sign(p),p)/1.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 20.;\n    vec3 col = vec3(0.0);\n    float d;\n    for(float i =3.; i<270.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.3;\n        if(d<.02){\n            break;\n        }\n        if(d>30.){\n        \tbreak;\n        }\n        //col+=vec3(2.64,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*100.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,8.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n    }\n    else\n    {\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,8.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n    }\n}\n\n// https://www.shadertoy.com/view/dsVBRd - Set as default cause if you aren't careful it can turn into flash\n\n// Needed to test this further so used the shader from this link\n// and this one\n// https://www.shadertoy.com/view/Mdt3Df\n\n// You can put any? into the if-else blocks. If you change the origin from 0 to any number the view because bigger/wider\n\n// https://www.shadertoy.com/view/dsyBDy - double mod by Xor","name":"Image","description":"","type":"image"}]}