{"ver":"0.1","info":{"id":"43fyR2","date":"1726402378","viewed":29,"name":"SpikeBall evolution","username":"w2w3","description":"Spikeball","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spikeball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 pIntersect(vec3 p1, vec3 p2) {\n    return max(p1, p2);\n}\n\nvec3 pUnion(vec3 p1, vec3 p2) {\n    return min(-p1, p2);\n}\n\nvec3 pSubtraction(vec3 p1, vec3 p2) {\n    return max(-p1, p2);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat dFig(vec3 p, vec3 center, float size, float spikes, float sharpness) {\n    float pi = acos(-1.0);\n    float x = (p - center).x;\n    float y = (p - center).y;\n    float z = (p - center).z;\n    float alpha = asin(x / sqrt(x * x + z * z));\n    float beta = asin(y / sqrt(x * x + y * y));\n    float gamma = asin(z / sqrt(y * y + z * z));\n    float spikeA = pow(sin(alpha * spikes), sharpness);\n    float spikeB = pow(sin(beta * spikes), sharpness);\n    float spikeC = pow(sin(gamma * spikes), sharpness);\n    return length(p - center) - size - min(spikeA, min(spikeB, spikeC));\n}\n\nfloat sdf(vec3 p, mat3 rotate) {\n    p *= rotate;\n    return dFig(p, vec3(0, 0, 0), 1.0, 1.0 + pow(iTime, 2.0) * 0.01, 5.0);\n}\n\n#define MAX_STEPS 2000\n#define MAX_DIST 50.0\n#define EPS 0.00001\n#define TRUST 0.1\n\nvec3 trace (in vec3 from, in vec3 dir, out bool hit, in mat3 rotate) {\n    vec3 p = from;\n    float totalDist = 0.0;\n    hit = false;\n    for (int steps = 0; steps < MAX_STEPS; ++steps) {\n        float dist = sdf(p, rotate);\n        if (dist < EPS) {\n            hit = true;\n            break;\n        }\n        totalDist += dist;\n        if (totalDist > MAX_DIST)\n            break;\n        p += dist * dir * TRUST;\n    }\n    return p;\n}\n\nvec3 normal(vec3 z, float d, mat3 rotate) {\n    float step = max(d * 0.5, EPS);\n    float dx1 = sdf(z + vec3(step, 0, 0), rotate);\n    float dx2 = sdf(z - vec3(step, 0, 0), rotate);\n    float dy1 = sdf(z + vec3(0, step, 0), rotate);\n    float dy2 = sdf(z - vec3(0, step, 0), rotate);\n    float dz1 = sdf(z + vec3(0, 0, step), rotate);\n    float dz2 = sdf(z - vec3(0, 0, step), rotate);\n    return normalize(vec3 (dx1 - dx2, dy1 - dy2, dz1 - dz2));\n\n}\n\nconst vec3 eye = vec3(0, 0, 3);\nconst vec3 light = vec3(0.0, 3.0, 5.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool hit;\n    vec4 color = vec4(0, 0, 0, 1);\n    vec4 colorTimed = vec4(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.5 + 0.5, 1, 1);\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat3 rotate = rotateX(-mouse.y * 6.0) * rotateY(-mouse.x * 6.0);\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5)) * 10.0 * iResolution.xy / max ( iResolution.x, iResolution.y );\n    vec3 dir = normalize(vec3(uv, 0) - eye);\n    vec3 p = trace(eye, dir, hit, rotate);\n    if (hit) {\n        vec3 l = normalize(light - p);\n        vec3 v = normalize(eye - p);\n        vec3 n = normal(p, EPS, rotate);\n        float nl = max(0.0, dot(n, l));\n        vec3 h = normalize(l + v);\n        float nh = max(0.0, dot(n, h));\n        float blick = pow(nh, 100.0);\n        color = vec4(nl) * 0.5 * colorTimed + 0.5 * blick;\n    }\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}