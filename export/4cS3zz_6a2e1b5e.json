{"ver":"0.1","info":{"id":"4cS3zz","date":"1703718715","viewed":85,"name":"FDM 2D wave with click","username":"zeroDarkThirty","description":"â€¢ press [r] to reset or start\nâ€¢ bounds are not correct!\nâ€¢ this is my sandbox, the math and approximations may not be correct","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["fdm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 H = texelFetch( iChannel0, ivec2( fragCoord ), 0 );\n    \n    // tanH helps keep it bounded, setting a value -1<>1 to a color pallete to make it look nice!\n    \n    vec3 col = pal( tanh(H.x), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    fragColor.xyz = col;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Use this site to find JS event key code\n   https://www.toptal.com/developers/keycode\n   I used [r]\n*/\n\nconst int KEY_RESET  = 82;\n#define KEY(N) texelFetch( iChannel1, ivec2( N, 0 ), 0 ).x\n\n\n/* goal is to approximate Uð‘¡ð‘¡ = Î±Uð‘¥ð‘¥ using FDM\n   Î± == cÂ² * dtÂ² / dxÂ², here Î± is, arbitrarily, set to .1\n   \n   update logic (not at bounds):\n   -----------------------------\n   \n       uNext = Î±( uLeft - 2*uCenter + uRight ) + 2*uCenter - uCenterPrev\n       \n       \n   shader explanation:\n   ------------------- \n   \n       â€¢ iChannel0 is stored in Buffer A, everytime it is called, it accesses the current rgba pixel value\n       using this and texelFetch we can access neighboring pixels!\n       \n       â€¢ uCenterPrev is tricky, fragColor is a 4D vector. We can store the current\n       uCenter value in fragColor.y. This vector is saved in buffer A. When the next frame comes,\n       accessing fragColor.y will contain the prevoius uCenter.\n   \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float alpha = 0.1; // Arbitrary! but should be lower than 0.5\n    \n    vec3 coordXYZ = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    float uCx = coordXYZ.x; // ux Centered \n    float uPx = coordXYZ.y; // ux Previous \n    float uPy = coordXYZ.z; // uy Previous \n    \n    float uLx = texelFetch(iChannel0, ivec2(fragCoord + vec2(-1., 0.)), 0).x; // ux Left\n    float uRx = texelFetch(iChannel0, ivec2(fragCoord + vec2(1., 0.)), 0).x; // ux Right\n    \n    float uLy = texelFetch(iChannel0, ivec2(fragCoord + vec2(0., -1.)), 0).x; // uy Left\n    float uRy = texelFetch(iChannel0, ivec2(fragCoord + vec2(0., 1.)), 0).x; // uy Right    \n    \n    \n    float ux = alpha * (uLx + uRx - 2.*uCx) + 2.*uCx - uPx;\n    \n    float uy = alpha * (uLy + uRy - 2.*uCx) + 2.*uCx - uPy; // uCx == uCy\n    \n    //float uMag = sqrt(ux*ux + uy*uy);\n    \n    float uFinal = (ux + uy)/2.; // just add x comp and y comp and divide by two (the potential max?)\n    \n    \n        \n    fragColor = vec4(uFinal,uCx,uCx,0.0);\n    \n    //fragColor.y = uC;\n    \n    if ( KEY(KEY_RESET) > 0.5 || iFrame < 11  ) \n    {\n    \n        // reset, set middle of frame to be a circle\n\n        fragCoord.y-=iResolution.y/2.;\n        fragCoord.x-=iResolution.x/2.;\n        float d = step(length(fragCoord.xy),iResolution.x/128.);\n        fragColor = vec4(d,d,d,d);\n    };    \n\n\n\n    if (iMouse.z > 0.01)\n    {\n        vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        \n        fragCoord.x -= iMouse.x;\n        fragCoord.y -= iMouse.y;\n        \n        //fragColor = prevColor;\n\n        \n        float d = step(length(fragCoord.xy),iResolution.x/128.);\n        \n        if (d == 1.)\n        {\n            // if the user is clicking just keep setting that area to vect4(0.5)\n            // like putting energy into the system and clipping the amplitude at .5\n            \n            fragColor = vec4(d/2.,d/2.,d/2.,d/2.);\n            //fragColor = vec4(d,d,d,d);\n\n            //vec2 maxPairs = max(fragColor.xy, fragColor.zw);\n            //float maxValue = max(maxPairs.x, maxPairs.y);\n            //fragColor /= maxValue;        \n        }\n\n\n    }\n\n\n}","name":"Buffer A","description":"","type":"buffer"}]}