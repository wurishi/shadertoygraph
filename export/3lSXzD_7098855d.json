{"ver":"0.1","info":{"id":"3lSXzD","date":"1565165897","viewed":179,"name":"Weyl hash continued...","username":"Carandiru","description":"continuing where  https://www.shadertoy.com/view/4dlcR4  left off.\nVery fast and great quality for a float in and float out hash function.\nThis contiuation finishes with the hash(out,in) variants. hash11 -> hash44\nIn an easy to reuse form aswell.\nCheers!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fast","hash","float"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wely hash continued....\n// original shader source: https://www.shadertoy.com/view/4dlcR4\n// extended by Carandiru - http://www.supersinfulsilicon.com\n\n// Math background: http://marc-b-reynolds.github.io/math/2016/02/24/weyl.html\n// Hash function:   http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\n// Status? Unfinished.\n\n// This contiuation has not been tested - however quality and speed are \n// very good.\n\n// ###################################################################\n#ifndef _RANDOM_GLSL\n#define _RANDOM_GLSL\n\n// 2D Weyl hash 32-bit XOR  - https://www.shadertoy.com/view/4dlcR4\n\n#define _W0 0x3504f335u   \n#define _W1 0x8fc1ecd5u  \n#define _W2 0xbb67ae85u\n#define _W3 0xf1bbcdcbu\n\n// 741103597u, 1597334677u, 204209821u, 851723965u  // MLCG constants\n#define _M0 741103597u    \n#define _M1 1597334677u\n#define _M2 204209821u\n#define _M3 851723965u\n\n#define _FSCALE 256.0f\n#define _FNORM (1.0f/16777216.0f/_FSCALE)\n\n// private //\nuint base_hash_1D(in uvec2 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.x ^= n.y;    // combine\n  n.x *= _M0;    // MLCG constant\n\n  return( n.x ^ (n.x >> 16) );\n}\n\nuvec2 base_hash_2D(in uvec2 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.x ^= n.y;    // combine\n\n  return( (n.x * uvec2(_M0, _M1)) ^ (n.x >> 16) ); // MLCG constant\n}\n\nuvec3 base_hash_3D(in uvec3 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.z *= _W2;\t  // z' = Fz(z)\n  n.x ^= n.y;    // combine\n  n.x ^= n.z;    // combine\n\n  return( (n.x * uvec3(_M0, _M1, _M2)) ^ (n.x >> 16) ); // MLCG constant\n}\nuint base_hash_3D_to_1D(in uvec3 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.z *= _W2;\t  // z' = Fz(z)\n  n.x ^= n.y;    // combine\n  n.x ^= n.z;    // combine\n  n.x *= _M0;    // MLCG constant\n\n  return( n.x ^ (n.x >> 16) );\n}\n\nuvec4 base_hash_4D(in uvec4 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.z *= _W2;\t// z' = Fz(z)\n  n.w *= _W3;\t// w' = Fw(w)\n  n.x ^= n.y;    // combine\n  n.x ^= n.z;    // combine\n  n.x ^= n.w;    // combine\n\n  return( (n.x * uvec4(_M0, _M1, _M2, _M3)) ^ (n.x >> 16) ); // MLCG constant\n}\n\n// public //\n\n// ####### hash(out,in)\n\nfloat hash11(in float x) \n{\n\treturn float(base_hash_1D(uvec2(uint(_FSCALE * x)))) * _FNORM;\n}\n\nfloat hash12(in vec2 xy)\n{\n\treturn float(base_hash_1D(uvec2(_FSCALE * xy))) * _FNORM;\n}\n\nfloat hash13(in vec3 xyz)\n{\n\treturn float(base_hash_3D_to_1D(uvec3(_FSCALE * xyz))) * _FNORM;\n}\n\nvec2 hash21(in float x)\n{\n\treturn vec2(base_hash_2D(uvec2(uint(_FSCALE * x)))) * _FNORM;\n}\n\nvec2 hash22(in vec2 xy)\n{\n\treturn vec2(base_hash_2D(uvec2(_FSCALE * xy))) * _FNORM;\n}\n\nvec3 hash31(in float x)\n{\n\treturn vec3(base_hash_3D(uvec3(uint(_FSCALE * x)))) * _FNORM;\n}\n\nvec3 hash32(in vec2 xy)\n{\n\treturn vec3(base_hash_3D(uvec3(_FSCALE * xy, 0))) * _FNORM;\n}\n\nvec3 hash33(in vec3 xyz)\n{\n\treturn vec3(base_hash_3D(uvec3(_FSCALE * xyz))) * _FNORM;\n}\n\nvec4 hash41(in float x) \n{\n\treturn vec4(base_hash_4D(uvec4(uint(_FSCALE * x)))) * _FNORM;\n}\n\nvec4 hash42(in vec2 xy) \n{\n\treturn vec4(base_hash_4D(uvec4(_FSCALE * xy, 0, 0))) * _FNORM;\n}\n\nvec4 hash43(in vec3 xyz) \n{\n\treturn vec4(base_hash_4D(uvec4(_FSCALE * xyz, 0))) * _FNORM;\n}\n\nvec4 hash44(in vec4 xyzw) \n{\n\treturn vec4(base_hash_4D(uvec4(_FSCALE * xyzw))) * _FNORM;\n}\n\n\n#endif\n// ###################################################################\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tint wx = int(fragCoord.x) - int(0.5*iResolution.x);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = vec3(0);\n    \n    if (wx < 0) {\n    \tcolor = hash32(uv + float(iFrame) * 0.002f);\n        \n        if ( sin(uv.y + iTime) > 0.0f ) {\n            color = vec3(hash12(uv + float(iFrame) * 0.002f));\n        }\n    }\n    else if (wx > 1) {\n    \tcolor = hash33(vec3(uv, iTime * 0.02f));\n        \n        if ( sin(uv.y + iTime) < 0.0f ) {\n            color = vec3(hash13(vec3(uv, iTime * 0.02f)));\n        }\n    }\n      \n\n\tfragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}