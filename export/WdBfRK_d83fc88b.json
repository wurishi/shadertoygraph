{"ver":"0.1","info":{"id":"WdBfRK","date":"1590861910","viewed":270,"name":"Shadertoy Strike","username":"rjs","description":"See notes at the top of the Image code -  AA needs setting to 3+. ","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","motionblur","wood","bowling","tenpin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Shadertoy Strike\" by rjs 05/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// An attempt to copy the image \"Textbook Strike\" by Tom Porter & Flip Phillips\n// from Steve Upstill's book The Renderman Companion  ISBN 0-201-50868-0\n//\n// Uses code and ideas from shadertoys published by iq, BigWings and P_Malin\n// but all errors, misconceptions, howlers and gross neglect of best practice are \n// solely my own work.\n\n// Use the mouse to orbit the scene.\n// Click bottom left-hand corner to reset view.\n\n// This is not an animation so I've paid no regard to rendering speed.\n// AA needs to be at least 3 to get a half-decent impression of motion blur\n// in a small image. Fullscreen will benefit from a higher value.\n// Default to 1 for fast compile.\n\n#define AA 1\n\n#define MAX_STEPS 100\n#define MAX_DIST  10.0\n#define HIT_DIST  0.0001\n\n#define MOUSE 1\n\n#define SHOWALLPINS 1\n\n#define PIN   4.\n#define BALL  2.\n#define ALLEY 1.\n#define NONE  0.\n\n#define ZERO (min(iFrame,0))\n\n\nconst vec3 lampCol = vec3(60.0, 60.0, 50.0);\nconst vec3 lampPos = vec3(0, 6, -5);\nconst vec3 woodFinish = vec3(0.7, 0.7, 0.4);\n\n\n// from BigWings https://www.shadertoy.com/view/XlcSzM\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\nconst float twopi = 6.283185307179586;\nfloat remap01(float a, float b, float t) {return (t-a)/(b-a);}\n\n\nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\nfloat smin( float a, float b, float k ) \n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax( float a, float b, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\nfloat sdBox( vec3 p, vec3 b ) \n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdSphere( vec3 p, vec3 pos, float r ) \n{ \n    return length(p-pos)-r; \n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 pos, in vec3 r ) \n{\n    p -= pos;\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return 0.6*(k1*(k1-1.0)/k2);\n}\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ) \n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\nconst vec3 alleySize = vec3(.55, .001, 1.5);\nconst vec3 alleyOff = vec3(.0, alleySize.y, -1.0);\n\nfloat sdAlley(in vec3 p) \n{\n    p -= alleyOff;\n    return sdBox(p, alleySize);\n}\n\n\n#define ELL_MIDY  0.1143\n#define ELL_CHOP  0.1143\n#define ELL_RADV  0.12514\n#define ELL_RADH  0.063\n#define TOP_RADV  0.10\n#define CAP_BTM   (ELL_CHOP)\n#define CAP_TOP   (CAP_BTM+.13+.1)\n#define CAP_RAD   0.012\n#define CAP_TRAD  0.0325\n\nvec3[10] pinOff;\nvec3[10] pinRot;\n\n\n\nvec3 PinTrans(vec3 p, vec3 rot, vec3 tran) \n{\n    //  no rot about y axis - only done when texturing\n\tp -= vec3(0, ELL_MIDY, 0) + tran;\n    p.yz *= Rot(rot.x);\n    p.xy *= Rot(rot.z);\n    p += vec3(0, ELL_MIDY, 0);\n    return p;\n}\n\n\nvoid sdPin(in vec3 p, inout vec3 res, in int inst, in vec3 off, in vec3 rot) \n{\n    p = PinTrans(p, rot, off);\n    float ell = sdEllipsoid( p, vec3(0, ELL_MIDY, 0), vec3(ELL_RADH, ELL_RADV, ELL_RADH) );\n    ell = smax(ell, -p.y, 0.0005);\n    float d = max(ell, p.y-ELL_CHOP);\n    ell = sdEllipsoid(p, vec3(0.0, ELL_CHOP, 0.0), vec3( ELL_RADH, TOP_RADV, ELL_RADH) );\n    d = min(d, ell);\n    float cap = sdRoundCone( p - vec3(0.0, CAP_BTM, 0.0), CAP_RAD, CAP_TRAD, CAP_TOP - CAP_BTM);\n    d = smin(d, cap, 0.03);\n\n    if (d < res.x) { \n        res = vec3(d, PIN, inst);\n        pinOff[inst] = off;\n        pinRot[inst] = rot;\n    }\n}\n\n\n#define PZ .2639\n#define PX .1524\n\n// Pin 'home' positions would be:\n//    vec3(0)\n//    vec3(PX,      0, PZ)\n//    vec3(-PX,     0, PZ)\n//    vec3(2.0*PX,  0, 2.0*PZ)\n//    vec3(0,       0, 2.0*PZ)\n//    vec3(-2.0*PX, 0, 2.0*PZ)\n//    vec3(3.0*PX,  0, 3.0*PZ)\n//    vec3(PX,      0, 3.0*PZ)\n//    vec3(-PX,     0, 3.0*PZ)\n//    vec3(-3.0*PX, 0, 3.0*PZ)\n\n\nvec3 Map(vec3 p, float time)    // .x = distance .y = object type  .z = instance\n{\n    vec3 res = vec3(sdAlley(p), ALLEY, 0);\n\n#if SHOWALLPINS\n    vec3 pp = vec3(0.1*PX,  0.004, 1.8*PZ-0.5);\n    vec3 pr = vec3(0.1, 0.45*twopi, -twopi*(0.05-0.95*time));\n    sdPin(p, res, 1, pp, pr);\n\n    pp = vec3(PX, 0.001, 3.0*PZ+(0.2*time)-0.48);\n    pr = vec3(0, -.4*twopi, 0);\n    sdPin(p, res, 7, pp, pr);\n    \n    pp = vec3(0.05, 0.03, 2.5*PZ-0.5);\n    pr = vec3(twopi*(0.1), .5*twopi, twopi*(0.27+4.*time));\n    sdPin(p, res, 4, pp, pr);\n\n \n    if (p.x > 0.18)\n    {\n        pp = vec3(3.1*PX+time*2.7, -0.02, 1.9*PZ-0.47);\n        pr = vec3(twopi*(0.34-4.*time), 0, -twopi*0.21);\n        sdPin(p, res, 0, pp, pr);\n\n        pp = vec3(3.0*PX, 0.004, 2.5*PZ-0.45);\n        pr = vec3(-twopi*(0.07-0.7*time), .32*twopi, -twopi*(0.04-0.7*time));\n        sdPin(p, res, 3, pp, pr);\n\n        pp = vec3(3.0*PX, 0.004, 3.0*PZ-0.45);\n        pr = vec3(-twopi*(0.03-0.3*time), 0, twopi*(0.02-0.7*time));\n        sdPin(p, res, 6, pp, pr);\n    }\n    \n    if (p.x < 0.)\n    {\n        pp = vec3(-PX*0.9, 0.004, 2.9*PZ-0.5);\n        pr = vec3(twopi*(0.06-0.7*time), 0, -twopi*(0.01-0.4*time));\n        sdPin(p, res, 2, pp, pr);\n\n        pp = vec3(1.475*-PX, 0.004, 3.28*PZ+(0.5*time)-0.5);\n        pr = vec3(-.1, .35*twopi, -twopi*(0.03-1.3*time));\n        sdPin(p, res, 8, pp, pr);\n    \n        if (p.x < -0.2)\n        {\n            pp = vec3(-2.9*PX-(0.4*time), 0.004, 1.9*PZ-0.5);\n            pr = vec3(-twopi*(0.03-0.3*time), .4*twopi, twopi*(0.05-0.3*time));\n            sdPin(p, res, 5, pp, pr);\n\n            pp = vec3(-3.0*PX, 0.001, 3.0*PZ-0.5);\n            pr = vec3(0, .25*twopi, 0);\n            sdPin(p, res, 9, pp, pr);\n        }\n    }\n#endif\n\n    float d = sdSphere(p, vec3(-0.26, 0.108, 0.1+time*3.), 0.108);\n    if (d < res.x) res = vec3(d, BALL, 0);\n\n    return res;\n}\n\n\nvec3 March(vec3 ro, vec3 rd, float time) \n{\n    vec3 res = vec3(-1, NONE, 0);\n    for(float d = 0.; d < MAX_DIST;) \n    {\n        vec3 pos = ro + rd * d;\n        vec3 m = Map(pos, time);\n        if (m.x < HIT_DIST) \n        {\n            res = vec3(d, m.yz);\n            break;\n        }\n        d += m.x;\n    }\n    return res;\n}\n\n\nvec3 calcNormal( in vec3 pos, float time )\n{   // https://iquilezles.org/articles/normalsSDF\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*Map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*Map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*Map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*Map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{   // https://www.shadertoy.com/view/3lsSzf\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.0005 + 0.04*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = Map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n\n\nfloat SoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float time) \n{\t// https://iquilezles.org/articles/rmshadows\n    float res = 1.0;\n    float k = 16.0;\n    for (float t = tmin; t <= tmax;) \n    {\n\t\tfloat m = Map(ro + rd*t, time).x;\n\t\tif (m < HIT_DIST)\n\t\t\treturn 0.0;\n\t\tres = min(res, k*m/t);\n\t\tt += m;\n\t}\n\treturn res;\n}\n\n\nfloat PinMarks(vec2 uv)\n{   //  pin home marks\n    vec2 st = uv / vec2(PX, PZ) + 0.5;\n    \n    float ci = floor(st.s);\n    bool eci = mod(ci, 2.0) == 0.0;\n    float ri = floor(st.t);\n    bool eri = mod(ri, 2.0) == 0.0;\n    \n    vec2 grid = fract(st) - 0.5;\n    \n    grid.s  = abs(grid.s);\n    grid.t *= PZ/PX;\n    float d = length(grid);\n    \n    return (   (d < 0.2 && d > 0.15)             // in ring\n            && (ri > -1. && ri < 4.)             // in 1st four rows (0..3)\n            && (!eri || eci)                     // odd row alternate\n            && (eri  || !eci)                    // even row opposite alternate\n            && (abs(ci) <= ri)                   // N+1 pins in row N\n           ) ? 0.6 : 1.0;\n}\n\n\nvec3 Surface(vec3 pos, vec3 rd, vec3 norm, float objId, int inst, float time) \n{\n    float specP = 80.;\n    float spec;\n\tvec3 col;\n\tif (objId == BALL) \n    {\n\t\tspec = 0.5;\n\t\tcol = vec3(0.01);\n\t} \n    else if (objId == PIN) \n    {\n        vec3 p = PinTrans(pos, pinRot[inst], pinOff[inst]);\n        p.xz *= Rot(pinRot[inst].y);\n        vec2 uv = vec2(0.5-atan(p.x, p.z)/twopi, remap01(0., CAP_TOP+CAP_RAD, p.y));\n        // base pin color\n        col = mix(vec3(0.1), vec3(0.15), smoothstep(0.003, 0.005, uv.y));\n        col = mix(col, vec3(0.8, 0.8, 0.5), smoothstep(0.03, 0.035, uv.y));\n        // brand label\n        uv.y = clamp((uv.y-0.3)*1.8, 0., 1.);\n        vec4 label = texture(iChannel1, uv);\n        label.g = 0.1;\n        col = mix(col, label.rgb, label.a);\n\t\tspec = 0.25;\n    } \n    else // if (objId == ALLEY)\n    {\n        vec3 p = (pos - alleyOff + alleySize) / (2.0 * alleySize);\n        col = texture(iChannel2, vec2(p.z, p.x)).rgb; \n        col *= (pos.y > 0.0) ? PinMarks(vec2(pos.x, pos.z+0.5)) : 1.0;\n\t\tspec = 0.6;\n        specP = 200.;\n\t}\n    float occ = calcOcclusion(pos, norm, time);\n\tvec3  lDir = normalize(lampPos - pos);\n\tfloat lDist = length(lampPos - pos);\n\tfloat lFoff = 1.0 / (lDist * lDist);\n\tfloat lDiff = 0.1 + 0.9 * clamp(dot(norm, lDir), 0.0, 1.0);\n\tvec3  lHalf = normalize(lDir - rd);\n\tfloat lSpec = spec * pow(clamp(dot(norm, lHalf), 0.0, 1.0), specP); \n\tfloat lShad = 0.3 + 0.7 * SoftShadow(pos + norm * HIT_DIST, lDir, HIT_DIST, lDist, time);\n\n    vec3  bDir = lDir * vec3(1, -1, 1);\n    float lBou = 0.1/(0.2+(10.*pos.y)) * (clamp(dot(norm, bDir), 0.0, 1.0));\n\n    float room = sqrt(clamp( 0.5+0.5*norm.y, 0.0, 1.0 ));\n\n    vec3 light = room * vec3(0.15, 0.15, 0.2) * occ;\n    light += lampCol * lFoff * lDiff * lShad * occ; \n    light += lampCol * lFoff * lBou * woodFinish * occ;\n    \n    col *= light;\n    col += lampCol * lFoff * lShad * lSpec;\n    return col;\n}\n\n\nvec3 AlleyRefl(vec3 pos, vec3 rd, vec3 norm, float objId, int inst, float time) \n{   // copy of Surface() except can only see pin or ball in reflection\n    float specP = 80.;\n    float spec;\n\tvec3 col;\n\tif (objId == BALL) \n    {\n\t\tspec = 0.5;\n\t\tcol = vec3(0.01);\n\t} \n    else if (objId == PIN) \n    {\n        vec3 p = PinTrans(pos, pinRot[inst], pinOff[inst]);\n        p.xz *= Rot(pinRot[inst].y);\n        vec2 uv = vec2(0.5-atan(p.x, p.z)/twopi, remap01(0., CAP_TOP+CAP_RAD, p.y));\n        // base pin color\n        col = mix(vec3(0.1), vec3(0.15), smoothstep(0.003, 0.005, uv.y));\n        col = mix(col, vec3(0.8, 0.8, 0.5), smoothstep(0.03, 0.035, uv.y));\n        // brand label\n        uv.y = clamp((uv.y-0.3)*1.8, 0., 1.);\n        vec4 label = texture(iChannel1, uv);\n        label.g = 0.1;\n        col = mix(col, label.rgb, label.a);\n\t\tspec = 0.25;\n    } \n    float occ = calcOcclusion(pos, norm, time);\n\tvec3  lDir = normalize(lampPos - pos);\n\tfloat lDist = length(lampPos - pos);\n\tfloat lFoff = 1.0 / (lDist * lDist);\n\tfloat lDiff = 0.1 + 0.9 * clamp(dot(norm, lDir), 0.0, 1.0);\n\tvec3  lHalf = normalize(lDir - rd);\n\tfloat lSpec = spec * pow(clamp(dot(norm, lHalf), 0.0, 1.0), specP); \n\tfloat lShad = 0.3 + 0.7 * SoftShadow(pos + norm * HIT_DIST, lDir, HIT_DIST, lDist, time);\n\n    vec3  bDir = lDir * vec3(1, -1, 1);\n    float lBou = 0.1/(0.2+(10.*pos.y)) * (clamp(dot(norm, bDir), 0.0, 1.0));\n\n    float room = sqrt(clamp( 0.5+0.5*norm.y, 0.0, 1.0 ));\n\n    vec3 light = room * vec3(0.15, 0.15, 0.2) * occ;\n    light += lampCol * lFoff * lDiff * lShad * occ; \n    light += lampCol * lFoff * lBou * woodFinish * occ;\n    \n    col *= light;\n    col += lampCol * lFoff * lShad * lSpec;\n    return col;\n}\n\n\nvec3 Ray(vec2 uv, vec3 l, float z, vec3 ro) \n{\n    vec3 f = normalize(l - ro),\n    r = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f, r),\n    c = ro + f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i - ro);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    mat2 mrx = Rot(-m.y*3.14 + 1.0);\n    mat2 mry = Rot(-m.x*6.2831);\n    float ml = length(iMouse.xy);\n\n    fragColor = vec4(0, 0, 0, 1);\n    // motion blur technique from iq https://www.shadertoy.com/view/3lsSzf\n    float time;\n#if AA > 1\n    for( int j=0; j<AA; j++ )\n    for( int k=0; k<AA; k++ )\n    {\n        vec2 o = vec2(float(j),float(k)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        time = 0.5*(1.0/24.0)*(float(j*AA+k)+d)/float(AA*AA);\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        time = 0.0;\n#endif\n\t\tvec3 ro = vec3(1.0, 1.0, -7.5);\n\n#if MOUSE\n        if (ml > 15.) \n        {\n            ro.yz *= mrx;\n            ro.xz *= mry;\n        }\n#endif\n        vec3 rd = Ray(p, vec3(0.05, 0.18, 0), 20.0, ro);\n        vec3 col = vec3(0);\n\n        vec3 res = March(ro, rd, time);\n        if (res.x >= 0.0) \n        {\n            vec3 pos = ro + rd * res.x;\n            vec3 norm = calcNormal(pos, time);\n            col = Surface(pos, rd, norm, res.y, int(res.z), time);\n            if (res.y == ALLEY) \n            {\n                float refl = 0.3 + 0.7 * (1.0 + dot(norm, rd));\n                rd = reflect(rd, norm);\n                ro = pos + rd * 0.001;\n                vec3 res = March(ro, rd, time);\n                if (res.x >= 0.0) \n                {\n                    pos = ro + rd * res.x;\n                    norm = calcNormal(pos, time);\n                    col += refl * woodFinish * AlleyRefl(pos, rd, norm, res.y, int(res.z), time);\n                }\n            }\n        }\n        fragColor.rgb += sqrt(col);\n\n#if AA > 1\n    }\n    fragColor.rgb /= float(AA*AA);\n#endif\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Modified version of https://www.shadertoy.com/view/lslGDn:\n\n// Shadertoy font shader - @P_Malin\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ----------------------------------------------------------------------------------------\n\n//#define LOW_QUALITY\n\n// The main characters are made up from a number of curve segments.\n// I made another shader to illustrate how these work:\n//\n//     https://www.shadertoy.com/view/Xds3Dn\n//\n// The middle of the characters are filled in triangles or convex quadrilaterals\n// Enable this define to see just the curved sections:\n\n//#define CURVES_ONLY\n\n// Initially I made most of characters this way but I ran into the constant register limit. \n// To avoid this, the curved sections of the â€˜oâ€™, â€˜aâ€™ and â€˜dâ€™ are oval shapes. \n// Also I managed to cut the constant data down dramatically by sharing a lot of\n// the shapes in the font (see the comments in the function Shadertoy() ). \n// For example the tails for â€˜hâ€™, â€™aâ€™, â€˜dâ€™, â€˜tâ€™, the left hand side of the â€˜yâ€™ and the \n// top of the â€˜hâ€™ all use the same shape! \n// I was probably more happy that I should have been when I realised I could share\n// the shape making the curve of the â€˜râ€™ with the little loop on the â€˜oâ€™.\n//\n// I experimented with a distance field version but it looked like it would involve \n// a lot more work and I thought Iâ€™d already spent too much time on this shader :)\n\n#ifdef LOW_QUALITY\n\n\t#define AA_X 1\n\t#define AA_Y 1\n\n#else\n\n\t#define AA_X 2\n\t#define AA_Y 2\n\n#endif\n\nconst float twopi = 6.283185307179586;\n\n\nfloat TestCurve(vec2 uv)\n{\n\tuv = 1.0 - uv;\n    return 1.0 - dot(uv, uv);\n}\n\nfloat Cross( const in vec2 A, const in vec2 B )\n{\n    return A.x * B.y - A.y * B.x;\n}\n\nvec2 GetUV(const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P)\n{\n    vec2 vPB = B - P;\n    float f1 = Cross(A-B, vPB);\n    float f2 = Cross(B-C, vPB);\n    float f3 = Cross(C-A, C-P);\n    \n    return vec2(f1, f2) / (f1 + f2 + f3);\n}\n\nfloat InCurve( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n    \n    float fResult = -1.0;\n\n\tfResult = max(fResult, (-vCurveUV.x));\n\tfResult = max(fResult, (-vCurveUV.y));\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\n\tfloat fCurveResult = TestCurve(vCurveUV);\n\t\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InCurve2( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n\t\n    float fResult = -1.0;\n\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\t\n\tfloat fCurveResult = -TestCurve(vCurveUV);\n\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InTri( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(A-C, C-P);\n\t\n    return (max(max(f1, f2), f3));\n}\n\nfloat InQuad( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 D, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(D-C, C-P);\n    float f4 = Cross(A-D, D-P);\n    \n    return (max(max(max(f1, f2), f3), f4));\n}\n\n\nfloat Glyph0(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.112, 0.056 );\n    const vec2  vP1 = vec2 ( 0.136, 0.026 );\n    const vec2  vP2 = vec2 ( 0.108, 0.022 );\n    const vec2  vP3 = vec2 ( 0.083, 0.017 ); \n    const vec2  vP4 = vec2 ( 0.082, 0.036 ); \n    const vec2  vP5 = vec2 ( 0.088, 0.062 ); \n    const vec2  vP6 = vec2 ( 0.115, 0.086 ); \n    const vec2  vP7 = vec2 ( 0.172, 0.147 ); \n    const vec2  vP8 = vec2 ( 0.100, 0.184 ); \n    const vec2  vP9 = vec2 ( 0.034, 0.206 ); \n    const vec2 vP10 = vec2 ( 0.021, 0.160 ); \n    const vec2 vP11 = vec2 ( 0.011, 0.114 ); \n    const vec2 vP12 = vec2 ( 0.052, 0.112 ); \n    const vec2 vP13 = vec2 ( 0.070, 0.108 ); \n    const vec2 vP14 = vec2 ( 0.075, 0.126 );\n    const vec2 vP15 = vec2 ( 0.049, 0.124 );\n    const vec2 vP16 = vec2 ( 0.047, 0.148 );\n    const vec2 vP17 = vec2 ( 0.046, 0.169 );\n    const vec2 vP18 = vec2 ( 0.071, 0.171 );\n    const vec2 vP19 = vec2 ( 0.098, 0.171 ); \n    const vec2 vP20 = vec2 ( 0.097, 0.143 ); \n    const vec2 vP21 = vec2 ( 0.100, 0.118 ); \n    const vec2 vP22 = vec2 ( 0.080, 0.100 ); \n    const vec2 vP23 = vec2 ( 0.055, 0.083 ); \n    const vec2 vP24 = vec2 ( 0.050, 0.052 ); \n    const vec2 vP25 = vec2 ( 0.052, 0.004 ); \n    const vec2 vP26 = vec2 ( 0.107, 0.010 ); \n    const vec2 vP27 = vec2 ( 0.148, 0.011 ); \n    const vec2 vP28 = vec2 ( 0.140, 0.041 ); \n    const vec2 vP29 = vec2 ( 0.139, 0.069 ); \n\n    float fDist = 1.0;\n\n\tfDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n\tfDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\tfDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) );\n    fDist = min( fDist, InCurve(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve(vP20,vP21,vP22, uv) );\n\tfDist = min( fDist, InCurve2(vP22,vP23,vP24, uv) );\n    fDist = min( fDist, InCurve2(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve2(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve2(vP28,vP29,vP0, uv) );\n\tfDist = min( fDist, InCurve(vP0,vP1,vP2, uv) );\n\tfDist = min( fDist, InCurve(vP2,vP3,vP4, uv) );\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n\n\n    fDist = min( fDist, InTri(vP0, vP1, vP28, uv) );\n\tfDist = min( fDist, InQuad(vP26, vP1, vP2, vP3, uv) );\n    fDist = min( fDist, InTri(vP3, vP4, vP24, uv) );\n    fDist = min( fDist, InTri(vP4, vP5, vP24, uv) );\n    fDist = min( fDist, InTri(vP24, vP5, vP22, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP22, uv) );\n    fDist = min( fDist, InTri(vP22, vP6, vP21, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP21, uv) );\n    fDist = min( fDist, InTri(vP21, vP8, vP20, uv) );\n    fDist = min( fDist, InTri(vP20, vP8, vP19, uv) );\n    fDist = min( fDist, InTri(vP19, vP8, vP18, uv) );\n    fDist = min( fDist, InTri(vP18, vP8, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP16, vP17, uv) );\n    fDist = min( fDist, InTri(vP10, vP15, vP16, uv) );\n    fDist = min( fDist, InTri(vP10, vP12, vP16, uv) );\n    fDist = min( fDist, InTri(vP12, vP14, vP15, uv) );\n\n    return fDist;\n}\n\nfloat Glyph1(const in vec2 uv, const in vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.171, 0.026 ) + vOffset;\n    vec2 vP1 = vec2 ( 0.204, 0.022 ) + vOffset;\n    const vec2 vP2 = vec2 ( 0.170, 0.185 );\n    const vec2 vP3 = vec2 ( 0.137, 0.185 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\nfloat Glyph3(const in vec2 uv, vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.212, 0.112 ) + vOffset;\n    vec2 vP2 = vec2 ( 0.243, 0.112 ) + vOffset;\n    const vec2  vP4 = vec2 ( 0.234, 0.150 );\n    const vec2  vP5 = vec2 ( 0.230, 0.159 );\n    const vec2  vP6 = vec2 ( 0.243, 0.164 );\n    const vec2  vP7 = vec2 ( 0.257, 0.164 );\n    const vec2  vP8 = vec2 ( 0.261, 0.148 );\n    const vec2 vP10 = vec2 ( 0.265, 0.164 );\n    const vec2 vP11 = vec2 ( 0.256, 0.180 );\n    const vec2 vP12 = vec2 ( 0.239, 0.185 );\n    const vec2 vP13 = vec2 ( 0.194, 0.194 );\n    const vec2 vP14 = vec2 ( 0.203, 0.150 );\n    const vec2 vP16 = vec2 ( 0.212, 0.113 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP14, uv) );\n    fDist = min( fDist, InTri(vP14, vP4, vP5, uv) );\n    fDist = min( fDist, InTri(vP14, vP5, vP12, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP7, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP10, vP12, uv) );\n    fDist = min( fDist, InTri(vP8, vP10, vP7, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph4(const in vec2 uv)\n{\n    vec2 vP = uv - vec2(0.305, 0.125);\n    vP /= 0.065;\n    vP.x *= 1.5;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n\n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.2;\n    float f2 = length(vP2 * 1.5 - vec2(0.6, 0.0));\n        \n    return max(f - 1.0, 1.0 - f2) / 20.0;\n} \n\nfloat Glyph5(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.507, 0.138 );\n    const vec2  vP1 = vec2 ( 0.510, 0.065 );\n    const vec2  vP2 = vec2 ( 0.570, 0.066 );\n    const vec2  vP3 = vec2 ( 0.598, 0.066 );\n    const vec2  vP4 = vec2 ( 0.594, 0.092 );\n    const vec2  vP5 = vec2 ( 0.599, 0.131 );\n    const vec2  vP6 = vec2 ( 0.537, 0.137 );\n    const vec2  vP8 = vec2 ( 0.538, 0.125 );\n    const vec2  vP9 = vec2 ( 0.564, 0.129 );\n    const vec2 vP10 = vec2 ( 0.574, 0.100 );\n    const vec2 vP11 = vec2 ( 0.584, 0.085 );\n    const vec2 vP12 = vec2 ( 0.571, 0.079 );\n    const vec2 vP13 = vec2 ( 0.557, 0.081 );\n    const vec2 vP14 = vec2 ( 0.549, 0.103 );\n    const vec2 vP15 = vec2 ( 0.518, 0.166 );\n    const vec2 vP16 = vec2 ( 0.557, 0.166 );\n    const vec2 vP17 = vec2 ( 0.589, 0.163 );\n    const vec2 vP18 = vec2 ( 0.602, 0.137 );\n    const vec2 vP20 = vec2 ( 0.602, 0.152 );\n    const vec2 vP21 = vec2 ( 0.572, 0.194 );\n    const vec2 vP22 = vec2 ( 0.537, 0.185 );\n    const vec2 vP23 = vec2 ( 0.503, 0.189 );\n    \n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) ); \n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) ); \n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) ); \n    fDist = min( fDist, InCurve2(vP22,vP23,vP0, uv) );\n\n    fDist = min( fDist, InTri(vP0, vP2, vP13, uv) );\n    fDist = min( fDist, InTri(vP13, vP2, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP11, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP4, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP4, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP4, vP9, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP9, uv) );\n    fDist = min( fDist, InTri(vP0, vP13, vP14, uv) );\n    fDist = min( fDist, InTri(vP0, vP14, vP15, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP22, uv) );\n    fDist = min( fDist, InTri(vP16, vP17, vP22, uv) );\n    fDist = min( fDist, InTri(vP17, vP18, vP20, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph6(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.638 , 0.087 ); \n    const vec2  vP1 = vec2 ( 0.648 , 0.073 ); \n    const vec2  vP2 = vec2 ( 0.673 , 0.068 ); \n    const vec2  vP3 = vec2 ( 0.692 , 0.069 ); \n    const vec2  vP4 = vec2 ( 0.687 , 0.086 ); \n    const vec2  vP5 = vec2 ( 0.688 , 0.104 ); \n    const vec2  vP6 = vec2 ( 0.672 , 0.102 ); \n    const vec2  vP7 = vec2 ( 0.659 , 0.099 ); \n    const vec2  vP8 = vec2 ( 0.663 , 0.092 ); \n    const vec2  vP9 = vec2 ( 0.662 , 0.086 ); \n    const vec2 vP10 = vec2 ( 0.655 , 0.086 ); \n    const vec2 vP11 = vec2 ( 0.644 , 0.087 ); \n    const vec2 vP12 = vec2 ( 0.637 , 0.102 ); \n    const vec2 vP13 = vec2 ( 0.638 , 0.094 ); \n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) ); \n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) ); \n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) );\n\n    fDist = min( fDist, InQuad(vP2, vP4, vP6, vP8, uv) );\n    fDist = min( fDist, InTri(vP9, vP2, vP8, uv) );\n    fDist = min( fDist, InTri(vP10, vP2, vP9, uv) );\n    fDist = min( fDist, InQuad(vP0, vP2, vP10, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP12, vP0, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph7(const in vec2 uv)\n{\n    const vec2 vP0 = vec2 ( 0.693 , 0.068 );\n    const vec2 vP1 = vec2 ( 0.748 , 0.069 );\n    const vec2 vP2 = vec2 ( 0.747 , 0.078 );\n    const vec2 vP3 = vec2 ( 0.691 , 0.077 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\n\nfloat Glyph8(const in vec2 uv)\n{ \n    vec2 vP = uv - vec2(0.788, 0.125);\n    vP /= 0.065;\n    vP.x *= 1.4;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n    \n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.5;\n    float f2 = length(vP2 * 1.5 - vec2(0.3, 0.0));\n    \n    \n    return max(f - 1.0, 1.0 - f2) / 20.0;\n}\n\nfloat Glyph11(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.921 , 0.070 );\n    const vec2  vP2 = vec2 ( 0.955 , 0.070 );\n    const vec2  vP4 = vec2 ( 0.926 , 0.202 );\n    const vec2  vP5 = vec2 ( 0.926 , 0.240 );\n    const vec2  vP6 = vec2 ( 0.885 , 0.243 );\n    const vec2  vP7 = vec2 ( 0.852 , 0.239 );\n    const vec2  vP8 = vec2 ( 0.859 , 0.219 );\n    const vec2  vP9 = vec2 ( 0.862 , 0.192 );\n    const vec2 vP10 = vec2 ( 0.889 , 0.189 );\n    const vec2 vP12 = vec2 ( 0.928 , 0.178 );\n    const vec2 vP13 = vec2 ( 0.949 , 0.173 );\n    const vec2 vP14 = vec2 ( 0.951 , 0.162 );\n    const vec2 vP15 = vec2 ( 0.960 , 0.150 );\n    const vec2 vP16 = vec2 ( 0.960 , 0.144 );\n    const vec2 vP18 = vec2 ( 0.971 , 0.144 );\n    const vec2 vP19 = vec2 ( 0.968 , 0.157 );\n    const vec2 vP20 = vec2 ( 0.957 , 0.171 );\n    const vec2 vP21 = vec2 ( 0.949 , 0.182 );\n    const vec2 vP22 = vec2 ( 0.922 , 0.189 );\n    const vec2 vP24 = vec2 ( 0.900 , 0.196 );\n    const vec2 vP25 = vec2 ( 0.866 , 0.205 );\n    const vec2 vP26 = vec2 ( 0.871 , 0.217 );\n    const vec2 vP27 = vec2 ( 0.871 , 0.225 );\n    const vec2 vP28 = vec2 ( 0.880 , 0.224 );\n    const vec2 vP29 = vec2 ( 0.889 , 0.218 );\n    const vec2 vP30 = vec2 ( 0.893 , 0.203 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve2(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) );\n\n    fDist = min( fDist, InCurve(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve(vP28,vP29,vP30, uv) );\n    \n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP30, uv) );\n\n    fDist = min( fDist, InQuad(vP10, vP12, vP22, vP24, uv) );\n        \n    fDist = min( fDist, InTri(vP30, vP4, vP6, uv) );\n    fDist = min( fDist, InTri(vP30, vP6, vP29, uv) );\n    fDist = min( fDist, InTri(vP28, vP29, vP6, uv) );\n    fDist = min( fDist, InTri(vP28, vP6, vP27, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP27, vP6, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP26, vP27, uv) );\n    fDist = min( fDist, InTri(vP8, vP25, vP26, uv) );\n    fDist = min( fDist, InTri(vP25, vP10, vP24, uv) );\n    \n    fDist = min( fDist, InTri(vP12, vP13, vP20, uv) );\n    fDist = min( fDist, InTri(vP12, vP20, vP22, uv) );\n    fDist = min( fDist, InTri(vP13, vP14, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP20, vP14, uv) );\n    fDist = min( fDist, InTri(vP15, vP18, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP18, uv) );\n    \n    return fDist;\n}\n\n\nfloat BigS(in vec2 uv)\n{\n    return min(1.0, Glyph0(uv)); // S\n}\n\n\nfloat Shadertoy(in vec2 uv)\n{\n    float fResult = 1.0;\n    \n    fResult = min(fResult, Glyph0(uv)); // S\n\n    vec2 vUVOffset = vec2(0.001, 0.0); // tail of h\n    vec2 vTailOffset = vec2(0.0, 0.0);  \n    float fUVScale = 1.0;\n\n    if(uv.x < 0.3)\n    {\n        if(uv.y < 0.12)\n        {\n            // top of h\n            fUVScale = -1.0;\n            vUVOffset = vec2(0.448, 0.25);  \n            vTailOffset = vec2(0.0, 0.0);   \n        }\n    }\n    else if(uv.x < 0.4)    \n    {\n        // tail of a\n        vUVOffset = vec2(-0.124, 0.0);  \n        vTailOffset = vec2(0.01, -0.04);    \n    }\n    else if(uv.x < 0.6)\n    {\n        // tail of d\n        vUVOffset = vec2(-0.248, 0.0);  \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else if(uv.x < 0.83)\n    {\n        // stalk of t\n        vUVOffset = vec2(-0.48, 0.0);   \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else\n    {\n        // start of y\n        vUVOffset = vec2(-0.645, 0.0);  \n        vTailOffset = vec2(0.005, -0.042);  \n    }\n    \n    fResult = min(fResult, Glyph3(uv * fUVScale + vUVOffset, vTailOffset)); // tails h, a, d, t, start of y and top of h\n\n\n    vec2 vUVOffset3 = vec2(0.0, 0.0);   // vertical of h\n    vec2 vTailOffset3 = vec2(0.0, 0.0);\n    \n    if(uv.x > 0.5)\n    {\n        // vertical of r\n        vUVOffset3 = vec2(-0.45, 0.0);  \n        vTailOffset3 = vec2(-0.01, 0.04);   \n    }\n    \n    fResult = min(fResult, Glyph1(uv + vUVOffset3, vTailOffset3)); // vertical of h, r\n\n    vec2 vUVOffset2 = vec2(0.0, 0.0); // curve of a\n    if(uv.x > 0.365)\n    {\n        vUVOffset2 = vec2(-0.125, 0.0); // curve of d\n    }\n\n    fResult = min(fResult, Glyph4(uv + vUVOffset2)); // curve of a, d\n    \n    fResult = min(fResult, Glyph5(uv)); // e\n\n    vec2 vUVOffset4 = vec2(0.001, 0.0); // top of r\n    vec2 vUVScale4 = vec2(1.0, 1.0);        \n    \n    if(uv.x > 0.7)\n    {\n        // o loop\n        vUVOffset4.x = 1.499;\n        vUVOffset4.y = 0.19;\n        \n        vUVScale4.x = -1.0;\n        vUVScale4.y = -1.0;\n    }\n\n    fResult = min(fResult, Glyph6(uv * vUVScale4 + vUVOffset4)); // top of r and o loop\n\n    fResult = min(fResult, Glyph7(uv)); // cross t    \n    \n    fResult = min(fResult, Glyph8(uv)); // o1\n\n    fResult = min(fResult, Glyph11(uv)); // y2        \n\n    return fResult; \n}\n\n\n// Paint the brand label during first 5 frames or if resolution changes.\n// Note that the .g component is used to carry the resolution from\n// frame to frame.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    fragColor = texture(iChannel1, uv);\n\n    if(iFrame<5 || abs(iResolution.x - fragColor.g)>.001) \n    {\n        uv *= vec2(1, -1);\n                \n        float fPaint = Shadertoy(vec2(3.0, 2.5) * (uv + vec2(-0.37, 0.2)));\n        fragColor = vec4(0.6, 0, 0.1, 1.0) * step(fPaint, 0.0);\n\n        fPaint = BigS(vec2(0.9, 0.7) * (uv + vec2(-.45, 0.5)));\n        fragColor += vec4(0.1, 0, 0.7, 1.0) * step(fPaint, 0.0);\n       \n        // wavey red band\n        float wr = 0.025 * sin(5.0*twopi*uv.x);\n        float t = smoothstep(-0.70 + wr, -0.705 + wr, uv.y);\n        t *= 1.0 - smoothstep(-0.85 + wr, -0.855 + wr, uv.y);\n        \n        fragColor += t * vec4(0.6, 0.1, 0.1, 1.0);\n\n    }\n\n    fragColor.g = iResolution.x;\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    fragColor = texture(iChannel1, uv);\n\n    if(iFrame<5 || abs(iResolution.x - fragColor.a)>.001) \n    {\n        uv *= vec2(2.9, 20.0);\n        uv.x += fract(sin(floor(uv.y)*37.1));\n        vec2 st = fract(uv) * vec2(0.9, 0.6);\n        // split into blocks\n        float w = fract(779.31*sin(1107.3 * (floor(uv.y)*17.11 + floor(uv.x)*261.076)));\n        st += vec2(sin(w*32.4), sin(w*57.1));\n        // process raw wood texture\n        fragColor.rgb = texture(iChannel0, st).rgb; \n        fragColor.rgb *= fragColor.rgb;\n        // less red & lighter\n        fragColor.rgb *= vec3(0.4, 1.0, 1.0) + vec3(0.2);\n        // each block has different shade\n        fragColor.rgb *= 1.6 + (2.*w);\n        fragColor.a = iResolution.x;\n    }\n\n}\n","name":"Buffer B","description":"","type":"buffer"}]}