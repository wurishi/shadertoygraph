{"ver":"0.1","info":{"id":"wdlfz7","date":"1587967754","viewed":74,"name":"synthesis","username":"blepfo","description":"    -\n-      -\n    -","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.141)\n#define TWOPI (2. * PI)\n#define RAND_SEED (403939.232)\n\nstruct PolarCoord {\n    float r;\n    float theta;\n};\n    \n\n// Polar coord centered at [0, 0] with theta in [0, TWOPI]\nPolarCoord toPolar(vec2 uv) {\n    return PolarCoord(\n        length(uv),\n        mod(atan(uv.y, uv.x), TWOPI)\n    );\n}\n\n\n// Random float given vec2\nfloat random(vec2 uv) {\n    return fract(\n        sin(dot(uv, vec2(17.343, 9.12)))\n        * cos(dot(uv, vec2(21.34, 15.324)))\n        * RAND_SEED\n    );\n}\n\n\n// Random noise generated for N arcs arount a circle\nfloat circNoise(float theta, int N, float smoothLeft, float smoothRight) {\n\t// Map theta in [0, TWOPI] into [0, N]\n    float x = (mod(theta, TWOPI) / TWOPI) * float(N);\n    float i = floor(x);\n    // Identify 0 with N to interpolate at the boundary\n    float iNext = mod(i + 1., float(N));\n    return mix(\n        random(vec2(i)),\n        // Identify 0 with N \n        random(vec2(iNext)),\n        smoothstep(smoothLeft, smoothRight, fract(x))\n    );\n}\n\n// Translate\nvec2 translate(vec2 uv, vec2 t) {\n    return uv - t;\n}\n\n// Rotate\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\n// Circle centered at [0,0]\nfloat circSdf(vec2 uv, float r) {\n    return length(uv) - r;\n}\n\n// Circle with randomly purturbed edge\nfloat splotchSdf(vec2 uv, float r, float noiseScale, int noiseResolution, vec2 noiseSmooth) {\n    PolarCoord cPolar = toPolar(uv);\n    float c = circSdf(uv, r);\n    // Randomly purturb boundary\n    float cNoise = noiseScale * (\n        (2.*circNoise(cPolar.theta, noiseResolution, noiseSmooth[0], noiseSmooth[1]))-1.\n\t);\n    return c + cNoise;\n}\n\nfloat annularSdf(float sdf, float r) {\n    return abs(sdf) - r;\n}\n\n// Exponential smooth max\nfloat smoothMax(float a, float b, float k) {\n    return (1. / k) * log2(exp2(k*a) + exp2(k*b));\n}\n\nfloat smoothMin(float a, float b, float k) {\n    return -smoothMax(-a, -b, k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x -= 0.5;\n    uv.x *= iResolution.x/iResolution.y; \n    uv.y -= 0.5;\n    \n    float scaleFactor = 0.8;\n    vec2 scaleLayer = uv * scaleFactor;\n    \n    vec2 splotch1Layer = scaleLayer * rotate2d(iTime * .4);\n    float splotch1 = splotchSdf(splotch1Layer, 0.136, 0.045, 64, vec2(0.));\n    \n    // 4 big circles going around on the outside\n    float c = 1.;\n    for(int i = 0; i<4; i++) {\n  \t  \tfloat thetaOffset = float(i) * (TWOPI / 4.);\n   \t\tfloat theta = iTime*.08 + thetaOffset;\n   \t\tvec2 center = 0.955 * vec2(cos(theta), sin(theta));\n    \tvec2 cLayer = translate(scaleLayer, center);\n    \tc = smoothMin(c, circSdf(cLayer, 0.572), 64.);\n    }\n    \n    float shape = smoothMin(splotch1, c, 11.);\n    shape = annularSdf(shape, 0.005);\n    shape = step(0., shape);\n    \n    vec3 color = vec3(0.990,0.941,0.580);\n    color = mix(color, vec3(0.020,0.020,0.020), 1.-shape);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}