{"ver":"0.1","info":{"id":"XdBBRV","date":"1501540794","viewed":564,"name":"[SH17C] Hemisphere Approximation","username":"kig","description":"Store the first bounce point and result for each pixel. Then construct a hemisphere for the primary ray by sampling the bounce points of surrounding pixels. ","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","research"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tSingle-sample bidirectional path tracing + hemisphere approximation\n\n\tSmooth indirect illumination by creating the incoming light hemisphere on the fly\n    based on the hemisphere samples of the surrounding pixels.\n\n\tSee also: Virtual point lights, bidirectional instant radiosity\n\n\tFirst pass: Create path suffixes = point with incoming ray of light.\n\t\t1. Shoot out primary ray and bounce it off the hit surface.\n    \t2. Trace the first bounce and store its hit point, normal and material.\n    \t3. Trace the rest of the path from the first bounce point and store the direction of the path.\n\t\t4. Store the amount of light at the first bounce point.\n\n\tNow you have a path suffix at each pixel that has enough info to connect any other path to it.\n\n\tSecond pass: Connect the primary ray to path suffixes in surrounding pixels.\n\t\t1. Shoot out primary ray and calculate direct light for it\n\t\t2. Sample NxN samples around the pixel from the path suffix buffer\n\t\t3. Accumulate the light from the hemisphere. For each sample:\n\t\t\t3.1. Calculate the direction to it: hd = normalize(sample.p - primary.p)\n\t\t\t3.2. Accumulate light according to the BRDFs of the primary point and the hemisphere point.\n\t\t\t[3.3. Scale the light contribution with a pixel distance filter for smoother transitions]\n\n\tExtra passes: Create new path suffixes by connecting points in path suffix buffer to other path suffixes\n\t\t1. Primary ray hits can act as path suffixes for hemisphere points (and have nice geometric connection at same px coord).\n\t\t2. Hemisphere points can act as path suffixes for hemisphere points (but may lie on the same plane near px coord).\n\t\t3. Add light from new path suffixes to primary hits.\n\n\tWhy this might be nice?\n\t\t- Get more mileage from paths: in scenes with difficult lighting conditions, the chances of \n\t\t\tfinding light are low for any given path. By summing up the contributions of 10000 paths, \n\t\t\tyou've got a much higher chance of finding light for a pixel.\n\t\t- Less noise: noise is variance in hemisphere sampling. If neighbouring pixels have similar \n\t\t\themispheres, there's smooth variance and little noise.\n\t\t- If you have the budget, you can cast shadow rays to each hemisphere point and get correct lighting.\n\t\t- If you don't have the budget, you can use the hemi points as soft light and get blurry lighting\n\t\t- You can use the found hemisphere light to approximate a point's light distribution and guide your sampler.\n\t\t- You can use light samples from previous frames.\n\n\tWhat sucks?\n\t\t- If you don't cast shadow rays, you get light bleeding and everything's blurry.\n\t\t\t- Casting 1000 shadow rays per pixel is going to have an impact on performance\n\t\t- Direct lighting remains noisy \n\t\t\t(you can use direct light as a hemisphere sample but it causes even more light bleeding w/o shadow rays)\n\t\t- This scene smooths out at 64x64 hemisphere samples per pixel, which is expensive to sample\n\t\t- Increasing the size of your sampling kernel increases inaccuracies w/o shadow rays\n\t\t- It seems like you trade high-frequency noise for low-frequency noise\n\t\t- Glossy stuff is hard\n\n\tThe ugly:\n\t\t- Using three buffers to trace because no MRTs, otherwise could store hemi hit, normal, dir, primary hit, \n\t\themi color, primary color on a single trace, and recombine on the second pass.\n\t\t- Slow SDF ray marcher as the rendering engine\n\t\t- Not storing incoming light dir atm, all the lighting equations are hacks in this demo\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 accum = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    accum.rgb /= abs(accum.a);\n    fragColor = (1.0 - exp(-accum * 2.5));\n    fragColor.a = accum.a;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define THRESHOLD 0.009\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 120\n#define LIGHT_STEPS 20\n#define SHADOW_STEPS 20\n\nconst float pi2 = 6.28318530718;\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n    \nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat cylinder(vec3 p, vec3 c, float r) {\n    return length(p.yz-c.yz) - r;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat cube = length(max(abs(p + vec3(0.5, 2., 1.)) - vec3(0.25, 1.07, 0.25), 0.0)) - 0.025;\n\tcube = min(cube, length(max(abs(p + vec3(-0.25, 2.5, -1.4)) - vec3(0.25, 1.07, 0.25), 0.0)) - 0.025);\n\tfloat s1 = length(p+vec3(-2.0, -2.0*abs(sin(iTime))+1.25, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s3 = length(max(abs(p+vec3(-2.5, -1.3, 0.0)) - vec3(0.05, 1.0 + abs(sin(0.2*iTime))*2.5, 2.5), 0.0));\n    s3 = max(s3, -(length(max(abs(p - vec3(2.5, 0., 2.)) - vec3(0.25, 3.0, 0.035), 0.0)) - 0.025));\n    s3 = max(s3, -(max(cylinder(p, vec3(2.5, 1.85, -1.8), 0.35), -cylinder(p, vec3(2.5, 1.85, -1.8), 0.28))));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.25, 0.035), 0.0)) - 0.025));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.035, 0.25), 0.0)) - 0.025));\n\tfloat s4 = length(max(abs(p+vec3(0.0, 0.0, 2.5)) - vec3(8.5, 2.95, 0.05), 0.0));\n\t//s4 = min(s4, length(max(abs(p+vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(0.0, 2.5, 0.0)) - vec3(8.5, 0.05, 8.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(2.0, -2.5, 0.0)) - vec3(4.5, 0.05, 2.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(-0.7, 0.0, -2.5)) - vec3(8.5, 2.5, 0.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(3.75, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));;\n\ts4 = min(s4, length(max(abs(p+vec3(-3.9, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));\n\treturn min( min( min( min(cube, s1), s2 ), s3 ), s4);\n}\n\nmat material(vec3 p, float rayNumber)\n{\n\t//float cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-2.0, -2.0*abs(sin(iTime))+1.25, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s5 = length(max(abs(p+vec3(-1.0, 1.5, 1.2)) - vec3(1.0, 0.05, 1.65), 0.0));\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n/*\tif (cube < s1 && cube < s2 && cube < s5) {\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.6;\n\t} else */\n    if (s2 < 0.01) {\n\t\tm.emit = vec3(5.0, 3.5, 3.0)*2.0;\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.85;\n\t} else if (s1 < 0.01 || abs(sin(p.z+p.y)) < 0.5) {\n\t\tm.transmit = vec3(0.8, 0.6, 0.4);\n        //if (s1 < 0.01 && abs(p.z-2.0) < 0.1)\n\t    //    m.emit = vec3(1.1, 0.2, 0.1);\n\t\tm.diffuse = 0.25;\n\t} else {\n\t\tm.diffuse = 0.85;\n\t\tm.transmit = 0.5 * vec3(0.9, 0.93, 0.96); //min(vec3(1.0), abs(p));\n\t}\n    m.diffuse = 1.0;\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, float t)\n{\n    return vec3(0.0);\n    \n    vec3 lightPos_ = vec3(\n        -cos(t)*-8.5, \n        sin(t)*3.0 - 4.0, \n        -(sin(t)*4.0)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += bgDiff*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvec3 randomUnitVector(float u1, float u2) {\n    float r = sqrt(u1);\n\tfloat rx = r*cos(u2*pi2);\n\tfloat ry = r*sin(u2*pi2);\n\tfloat rz = sqrt(max(0.0, 1.0-u1));\n    vec3  rr = vec3(rx, ry, rz);\n    rr.z *= float(u1 > 0.5) * 2.0 - 1.0;\n    return rr;\n}\n\nvec3 randomHemiVector(vec3 nml, float u1, float u2) {\n\tvec3  uu  = normalize( cross( nml, vec3(.001,1.,.001) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n    float r = sqrt(u1);\n\tfloat rx = r*cos(u2*pi2); \n\tfloat ry = r*sin(u2*pi2);\n\tfloat rz = sqrt(max(0.0, 1.0-u1));\n    vec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n    return rr;\n}\n\nvoid offset(inout vec3 nml, vec2 fragCoord, vec2 rand, float diffuse, float sz) {\nsz=1.;\n    vec2 uv = mod(floor(fragCoord)+rand, vec2(sz)) / sz;\n    \n    vec3 rr = randomHemiVector(nml, uv.x, uv.y);\n\n    nml = normalize(mix(nml, rr, diffuse));\n}\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nray setupRay(vec2 uv, float k, float t) {\n\n\tmat3 rot = rotationXY( vec2( t*0.501, t*0.602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(0.3, -2.0, -3.5);\n\tr.d = rot * normalize(vec3(uv.x, uv.y+0.75, 1.3));\n\n\treturn r;\n}\n\nvec3 traceLight(ray r, vec3 nml, ray light) {\n    vec3 dir = normalize(light.p - r.p);\n    vec3 col = vec3(0.0);\n    for (int i=0; i<SHADOW_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * dir;\n\t\tif (length(r.p - light.p) < THRESHOLD*4.0) {\n            col = abs(dot(nml, dir)) * abs(dot(light.d, dir)) * light.light;\n            break;\n\t\t} else if (dist < THRESHOLD || dist > MAX_DISTANCE) {\n            mat m = material(r.p, 0.0);\n            col = max(0.0, dot(nml, dir)) * m.emit;\n            break;\n    \t}\n    }\n\treturn col;\n}\n\nvec4 trace(vec2 fragCoord, vec2 uv, vec2 uvD, inout float rayNumber, float convergeCount)\n{\n\tvec3 accum = vec3(0.0);\n    \n    float k = 0.0;\n\n    vec2 rc = fragCoord + (5.0+mod(iTime, 1.73728))*vec2(rayNumber*37.0, rayNumber*63.0);\n    vec4 rand = texelFetch(iChannel0, ivec2(mod(rc, vec2(256.0))), 0);\n\n    float time = 64.0 + 11.3 + 0.2*sin(iTime); //floor(float(iFrame)/300.0);\n    float shutterSpeed = 0.01;\n    \n    float t = time + shutterSpeed*rand.x;\n\t\n    int bounces = 0;\n    ray lights[2];\n\n    ray r;\n    r.d = randomUnitVector(rand.x, rand.y);\n    rand = rand.zwxy;\n    r.p = vec3(2.75, -1.35, 0.) + r.d * 0.0;\n    r.d = normalize(r.p - vec3(2.75, -1.35, 0.));\n    r.light = vec3(5.0, 3.5, 3.0)*2.0;\n    r.transmit = vec3(1.0);\n    lights[0] = r;\n    \n    for (int i=0; i<LIGHT_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n            mat m = material(r.p, rayNumber);\n            if (bounces == 0) {\n                r.transmit *= m.transmit;\n                lights[1] = r;\n                lights[1].light = r.light * r.transmit;\n\t            bounces++;\n                float diffuse = m.diffuse;\n                vec3 rd = r.d;\n                vec3 pnml;\n                offset(nml, fragCoord, rand.zw, diffuse, 1.0);\n                r.d = reflect(r.d, nml);\n                lights[1].d = nml;\n                r.p += THRESHOLD * pnml + (max(0.0, dot(rd, r.d))*10.0+4.0)*THRESHOLD * r.d;\n            }\n            break;\n\t\t} else if (dist > MAX_DISTANCE) {\n            break;\n    \t}\n    }\n        \n    rand = texelFetch(iChannel0, ivec2(mod(rc+vec2(37.0,63.0), vec2(256.0))), 0);\n\tr = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k+rayNumber, t);\n    bounces = 0;\n    k = 0.0;\n    \n    vec3 maxContrib = vec3(0.0);\n    vec3 maxLightContrib = vec3(0.0);\n    vec3 maxLightD = vec3(0.0);\n    vec3 maxLight = vec3(0.0);\n\n    vec3 o = r.p;\n\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n            if (bounces == 1) {\n                maxContrib = r.p;\n            }\n            mat m = material(r.p, rayNumber);\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n            float diffuse = m.diffuse;\n            if (bounces > 0) {\n\t            r.light += r.transmit * m.emit;\n\t            r.transmit *= m.transmit;\n            }\n            vec3 pnml = nml;\n            offset(nml, fragCoord, rand.zw, diffuse, 1.0 + floor(diffuse * 4.0));\n            vec3 rd = r.d;\n            r.d = reflect(r.d, nml);\n            r.p += 1.0 * THRESHOLD * pnml;\n\t\t\tr.p += (max(0.0, dot(rd, r.d))*10.0+4.0)*THRESHOLD * r.d;\n\t\t\t\n            vec3 collected = vec3(0.0);\n\n            vec3 light = traceLight(r, nml, lights[0]);\n            collected += light;\n            float dd = dot(r.d, normalize(lights[0].p-r.p));\n\n            light = traceLight(r, nml, lights[1]);\n            collected += light;\n            dd = dot(r.d, normalize(lights[1].p-r.p));\n            if (bounces == 0 && length(dd*light) > length(maxLight)) {\n                maxLightContrib = lights[1].p;\n                maxLight = dd*lights[1].light;\n            }\n                \n            if (bounces > 0) {\n\t            accum += r.light*2.0 + r.transmit * collected;\n    \t        k += 2.0;\n            }\n\t\t\t\n            rand = rand.yzwx;\n            bounces++;\n            if (bounces > 3) {\n                break;\n            }\n\t\t} else if (dist > MAX_DISTANCE) {\n            if (bounces <= 1) {\n\t            maxContrib = r.p;\n            }\n            break;\n\t\t}\n\t}\n    \n    accum += r.light;\n    k++;\n\n    if (length(maxLight) > length((accum-maxLight)) / k) {\n        maxContrib = maxLightContrib;\n        accum = maxLight;\n        k = 1.0;\n    }\n    \n    maxLightD = accum / k;\n\trayNumber += k;\n    return vec4(maxLightD, length(maxContrib - o));\n\t//return accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (2.0*uv - 1.0) * aspect;\n\n    vec2 uvD = ((2.0*(fragCoord.xy+vec2(1.0, 1.0)) / iResolution.xy - 1.0) * aspect) - uv;\n    float rayNumber = 0.0;\n    float convergeCount = 1.0;\n\n    fragColor = trace(fragCoord, uv, uvD, rayNumber, convergeCount);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define THRESHOLD 0.009\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 120\n#define LIGHT_STEPS 20\n#define SHADOW_STEPS 20\n\nconst float pi2 = 6.28318530718;\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n    \nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat cylinder(vec3 p, vec3 c, float r) {\n    return length(p.yz-c.yz) - r;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat cube = length(max(abs(p + vec3(0.5, 2., 1.)) - vec3(0.25, 1.07, 0.25), 0.0)) - 0.025;\n\tcube = min(cube, length(max(abs(p + vec3(-0.25, 2.5, -1.4)) - vec3(0.25, 1.07, 0.25), 0.0)) - 0.025);\n\tfloat s1 = length(p+vec3(-2.0, -2.0*abs(sin(iTime))+1.25, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s3 = length(max(abs(p+vec3(-2.5, -1.3, 0.0)) - vec3(0.05, 1.0 + abs(sin(0.2*iTime))*2.5, 2.5), 0.0));\n    s3 = max(s3, -(length(max(abs(p - vec3(2.5, 0., 2.)) - vec3(0.25, 3.0, 0.035), 0.0)) - 0.025));\n    s3 = max(s3, -(max(cylinder(p, vec3(2.5, 1.85, -1.8), 0.35), -cylinder(p, vec3(2.5, 1.85, -1.8), 0.28))));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.25, 0.035), 0.0)) - 0.025));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.035, 0.25), 0.0)) - 0.025));\n\tfloat s4 = length(max(abs(p+vec3(0.0, 0.0, 2.5)) - vec3(8.5, 2.95, 0.05), 0.0));\n\t//s4 = min(s4, length(max(abs(p+vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(0.0, 2.5, 0.0)) - vec3(8.5, 0.05, 8.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(2.0, -2.5, 0.0)) - vec3(4.5, 0.05, 2.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(-0.7, 0.0, -2.5)) - vec3(8.5, 2.5, 0.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(3.75, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));;\n\ts4 = min(s4, length(max(abs(p+vec3(-3.9, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));\n\treturn min( min( min( min(cube, s1), s2 ), s3 ), s4);\n}\n\nmat material(vec3 p, float rayNumber)\n{\n\t//float cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-2.0, -2.0*abs(sin(iTime))+1.25, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s5 = length(max(abs(p+vec3(-1.0, 1.5, 1.2)) - vec3(1.0, 0.05, 1.65), 0.0));\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n/*\tif (cube < s1 && cube < s2 && cube < s5) {\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.6;\n\t} else */\n    if (s2 < 0.01) {\n\t\tm.emit = vec3(5.0, 3.5, 3.0)*2.0;\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.85;\n\t} else if (s1 < 0.01 || abs(sin(p.z+p.y)) < 0.5) {\n\t\tm.transmit = vec3(0.8, 0.6, 0.4);\n        //if (s1 < 0.01 && abs(p.z-2.0) < 0.1)\n\t    //    m.emit = vec3(1.1, 0.2, 0.1);\n\t\tm.diffuse = 0.25;\n\t} else {\n\t\tm.diffuse = 0.85;\n\t\tm.transmit = 0.5 * vec3(0.9, 0.93, 0.96); //min(vec3(1.0), abs(p));\n\t}\n    m.diffuse = 1.0;\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, float t)\n{\n    return vec3(0.0);\n    \n    vec3 lightPos_ = vec3(\n        -cos(t)*-8.5, \n        sin(t)*3.0 - 4.0, \n        -(sin(t)*4.0)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += bgDiff*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvec3 randomUnitVector(float u1, float u2) {\n    float r = sqrt(u1);\n\tfloat rx = r*cos(u2*pi2);\n\tfloat ry = r*sin(u2*pi2);\n\tfloat rz = sqrt(max(0.0, 1.0-u1));\n    vec3  rr = vec3(rx, ry, rz);\n    rr.z *= float(u1 > 0.5) * 2.0 - 1.0;\n    return rr;\n}\n\nvec3 randomHemiVector(vec3 nml, float u1, float u2) {\n\tvec3  uu  = normalize( cross( nml, vec3(.001,1.,.001) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n    float r = sqrt(u1);\n\tfloat rx = r*cos(u2*pi2); \n\tfloat ry = r*sin(u2*pi2);\n\tfloat rz = sqrt(max(0.0, 1.0-u1));\n    vec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n    return rr;\n}\n\nvoid offset(inout vec3 nml, vec2 fragCoord, vec2 rand, float diffuse, float sz) {\nsz=1.;\n    vec2 uv = mod(floor(fragCoord)+rand, vec2(sz)) / sz;\n    \n    vec3 rr = randomHemiVector(nml, uv.x, uv.y);\n\n    nml = normalize(mix(nml, rr, diffuse));\n}\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nray setupRay(vec2 uv, float k, float t) {\n\n\tmat3 rot = rotationXY( vec2( t*0.501, t*0.602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(0.3, -2.0, -3.5);\n\tr.d = rot * normalize(vec3(uv.x, uv.y+0.75, 1.3));\n\n\treturn r;\n}\n\nvec3 traceLight(ray r, vec3 nml, ray light) {\n    vec3 dir = normalize(light.p - r.p);\n    vec3 col = vec3(0.0);\n    for (int i=0; i<SHADOW_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * dir;\n\t\tif (length(r.p - light.p) < THRESHOLD*4.0) {\n            col = abs(dot(nml, dir)) * abs(dot(light.d, dir)) * light.light;\n            break;\n\t\t} else if (dist < THRESHOLD || dist > MAX_DISTANCE) {\n            mat m = material(r.p, 0.0);\n            col = max(0.0, dot(nml, dir)) * m.emit;\n            break;\n    \t}\n    }\n\treturn col;\n}\n\nvec4 trace(vec2 fragCoord, vec2 uv, vec2 uvD, inout float rayNumber, float convergeCount)\n{\n\tvec3 accum = vec3(0.0);\n    \n    float k = 0.0;\n\n    vec2 rc = fragCoord + (5.0+mod(iTime, 1.73728))*vec2(rayNumber*37.0, rayNumber*63.0);\n    vec4 rand = texelFetch(iChannel0, ivec2(mod(rc, vec2(256.0))), 0);\n\n    float time = 64.0 + 11.3 + 0.2*sin(iTime); //floor(float(iFrame)/300.0);\n    float shutterSpeed = 0.01;\n    \n    float t = time + shutterSpeed*rand.x;\n\t\n    int bounces = 0;\n    ray lights[2];\n\n    ray r;\n    r.d = randomUnitVector(rand.x, rand.y);\n    rand = rand.zwxy;\n    r.p = vec3(2.75, -1.35, 0.) + r.d * 0.0;\n    r.d = normalize(r.p - vec3(2.75, -1.35, 0.));\n    r.light = vec3(5.0, 3.5, 3.0)*2.0;\n    r.transmit = vec3(1.0);\n    lights[0] = r;\n    \n    for (int i=0; i<LIGHT_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n            mat m = material(r.p, rayNumber);\n            if (bounces == 0) {\n                r.transmit *= m.transmit;\n                lights[1] = r;\n                lights[1].light = r.light * r.transmit;\n\t            bounces++;\n                float diffuse = m.diffuse;\n                vec3 rd = r.d;\n                vec3 pnml;\n                offset(nml, fragCoord, rand.zw, diffuse, 1.0);\n                r.d = reflect(r.d, nml);\n                lights[1].d = nml;\n                r.p += THRESHOLD * pnml + (max(0.0, dot(rd, r.d))*10.0+4.0)*THRESHOLD * r.d;\n            }\n            break;\n\t\t} else if (dist > MAX_DISTANCE) {\n            break;\n    \t}\n    }\n        \n    rand = texelFetch(iChannel0, ivec2(mod(rc+vec2(37.0,63.0), vec2(256.0))), 0);\n\tr = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k+rayNumber, t);\n    bounces = 0;\n    k = 0.0;\n    \n    vec3 maxContrib = vec3(0.0);\n    vec3 maxLightContrib = vec3(0.0);\n    float maxLightD = 0.0;\n    float maxLight = 0.0;\n\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n            if (bounces == 1) {\n                maxContrib = r.p;\n            }\n            mat m = material(r.p, rayNumber);\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n            float diffuse = m.diffuse;\n            if (bounces > 0) {\n\t            r.light += r.transmit * m.emit;\n\t            r.transmit *= m.transmit;\n            }\n            vec3 pnml = nml;\n            offset(nml, fragCoord, rand.zw, diffuse, 1.0 + floor(diffuse * 4.0));\n            vec3 rd = r.d;\n            r.d = reflect(r.d, nml);\n            r.p += 1.0 * THRESHOLD * pnml;\n\t\t\tr.p += (max(0.0, dot(rd, r.d))*10.0+4.0)*THRESHOLD * r.d;\n\t\t\t\n            vec3 collected = vec3(0.0);\n\n            vec3 light = traceLight(r, nml, lights[0]);\n            collected += light;\n            float dd = dot(r.d, normalize(lights[0].p-r.p));\n\n            light = traceLight(r, nml, lights[1]);\n            collected += light;\n            dd = dot(r.d, normalize(lights[1].p-r.p));\n            if (bounces == 0 && dd*light.r > maxLight) {\n                maxLightContrib = lights[1].p;\n                maxLight = dd*lights[1].light.r;\n            }\n                \n            if (bounces > 0) {\n\t            accum += r.light*2.0 + r.transmit * collected;\n    \t        k += 2.0;\n            }\n\t\t\t\n            rand = rand.yzwx;\n            bounces++;\n            if (bounces > 3) {\n                break;\n            }\n\t\t} else if (dist > MAX_DISTANCE) {\n            if (bounces <= 1) {\n\t            maxContrib = r.p;\n            }\n            break;\n\t\t}\n\t}\n    \n    accum += r.light;\n    k++;\n\n    if (maxLight > (accum.r-maxLight) / k) {\n        maxContrib = maxLightContrib;\n        accum.r = maxLight;\n        k = 1.0;\n    }\n    \n    maxLightD = accum.r / k;\n\trayNumber += k;\n    return vec4(maxContrib, maxLightD);\n\t//return accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (2.0*uv - 1.0) * aspect;\n\n    vec2 uvD = ((2.0*(fragCoord.xy+vec2(1.0, 1.0)) / iResolution.xy - 1.0) * aspect) - uv;\n    float rayNumber = 0.0;\n    float convergeCount = 1.0;\n\n    fragColor = trace(fragCoord, uv, uvD, rayNumber, convergeCount);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define THRESHOLD 0.001\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 200\n#define SHADOW_STEPS 120\n\nconst float pi2 = 6.28318530718;\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n    \nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat cylinder(vec3 p, vec3 c, float r) {\n    return length(p.yz-c.yz) - r;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat cube = length(max(abs(p + vec3(0.5, 2., 1.)) - vec3(0.25, 1.07, 0.25), 0.0)) - 0.025;\n\tcube = min(cube, length(max(abs(p + vec3(-0.25, 2.5, -1.4)) - vec3(0.25, 1.07, 0.25), 0.0)) - 0.025);\n\tfloat s1 = length(p+vec3(-2.0, -2.0*abs(sin(iTime))+1.25, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s3 = length(max(abs(p+vec3(-2.5, -1.3, 0.0)) - vec3(0.05, 1.0 + abs(sin(0.2*iTime))*2.5, 2.5), 0.0));\n    s3 = max(s3, -(length(max(abs(p - vec3(2.5, 0., 2.)) - vec3(0.25, 3.0, 0.035), 0.0)) - 0.025));\n    s3 = max(s3, -(max(cylinder(p, vec3(2.5, 1.85, -1.8), 0.35), -cylinder(p, vec3(2.5, 1.85, -1.8), 0.28))));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.25, 0.035), 0.0)) - 0.025));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.035, 0.25), 0.0)) - 0.025));\n\tfloat s4 = length(max(abs(p+vec3(0.0, 0.0, 2.5)) - vec3(8.5, 2.95, 0.05), 0.0));\n\t//s4 = min(s4, length(max(abs(p+vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(0.0, 2.5, 0.0)) - vec3(8.5, 0.05, 8.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(2.0, -2.5, 0.0)) - vec3(4.5, 0.05, 2.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(-0.7, 0.0, -2.5)) - vec3(8.5, 2.5, 0.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(3.75, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));;\n\ts4 = min(s4, length(max(abs(p+vec3(-3.9, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));\n\treturn min( min( min( min(cube, s1), s2 ), s3 ), s4);\n}\n\nmat material(vec3 p, float rayNumber)\n{\n\t//float cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-2.0, -2.0*abs(sin(iTime))+1.25, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s5 = length(max(abs(p+vec3(-1.0, 1.5, 1.2)) - vec3(1.0, 0.05, 1.65), 0.0));\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n/*\tif (cube < s1 && cube < s2 && cube < s5) {\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.6;\n\t} else */\n    if (s2 < 0.01) {\n\t\tm.emit = vec3(5.0, 3.5, 3.0)*.2;\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.85;\n\t} else if (s1 < 0.01 || abs(sin(p.z+p.y)) < 0.5) {\n\t\tm.transmit = vec3(0.8, 0.6, 0.4);\n        //if (s1 < 0.01 && abs(p.z-2.0) < 0.1)\n\t    //    m.emit = vec3(1.1, 0.2, 0.1);\n\t\tm.diffuse = 0.25;\n\t} else {\n\t\tm.diffuse = 0.85;\n\t\tm.transmit = 0.5 * vec3(0.9, 0.93, 0.96); //min(vec3(1.0), abs(p));\n\t}\n    m.diffuse = 1.0;\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, float t)\n{\n    return vec3(0.0);\n    \n    vec3 lightPos_ = vec3(\n        -cos(t)*-8.5, \n        sin(t)*3.0 - 4.0, \n        -(sin(t)*4.0)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += bgDiff*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\n\nvec3 randomUnitVector(float u1, float u2) {\n    float r = sqrt(u1);\n\tfloat rx = r*cos(u2*pi2);\n\tfloat ry = r*sin(u2*pi2);\n\tfloat rz = sqrt(max(0.0, 1.0-u1));\n    vec3  rr = vec3(rx, ry, rz);\n    rr.z *= float(u1 > 0.5) * 2.0 - 1.0;\n    return rr;\n}\n\nvec3 randomHemiVector(vec3 nml, float u1, float u2) {\n\tvec3  uu  = normalize( cross( nml, vec3(.001,1.,.001) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n    float r = sqrt(u1);\n\tfloat rx = r*cos(u2); \n\tfloat ry = r*sin(u2);\n\tfloat rz = sqrt(max(0.0, 1.0-u1));\n    vec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n    return rr;\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nray setupRay(vec2 uv, float k, float t) {\n\n\tmat3 rot = rotationXY( vec2( t*0.501, t*0.602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(0.3, -2.0, -3.5);\n\tr.d = rot * normalize(vec3(uv.x, uv.y+0.75, 1.3));\n\n\treturn r;\n}\n\n\nvec3 traceLight(ray r, vec3 nml, ray light) {\n    vec3 dir = normalize(light.p - r.p);\n    vec3 col = vec3(0.0);\n    for (int i=0; i<SHADOW_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * dir;\n\t\tif (length(r.p - light.p) < THRESHOLD*4.0) {\n            col = abs(dot(nml, dir)) * light.light;\n            break;\n\t\t} else if (dist < THRESHOLD || dist > MAX_DISTANCE) {\n            mat m = material(r.p, 0.0);\n            col = abs(dot(nml, dir)) * m.emit;\n            break;\n    \t}\n    }\n\treturn col;\n}\n\nbool hitScene(ray r, vec3 target) {\n    vec3 dv = normalize(target - r.p);\n    //r.p += dv * 4.0 * THRESHOLD;\n    for (int i=0; i<120; i++) {\n        float dist = scene(r.p);\n        r.p += dist * dv;\n        bool approach = length(target - r.p) < 4.0*THRESHOLD;\n        if (dist < THRESHOLD || approach) {\n            return !approach;\n        }\n    }\n    return true;\n}\n/*\nhit traceScene(ray r) {\n    vec3 nml;\n    float diffuse;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n            mat m = material(r.p, rayNumber);\n\t\t\tr.p -= dist * r.d;\n\t\t\tnml = normal(r, dist);\n            diffuse = m.diffuse;\n            r.transmit *= m.transmit;\n            r.light = m.emit;\n\n            //offset(nml, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), 0.0);\n            r.d = reflect(r.d, nml);\n\t\t\tr.p += THRESHOLD * nml;\n            \n            directLight = traceLight(r, nml, light);\n\n            r.p += dist * r.d;\n\n            rand = rand.yzwx;\n            bounces++;\n            break;\n\t\t} else if (dist > MAX_DISTANCE) {\n            break;\n\t\t}\n\t}\n}*/\n\nvec3 trace(vec2 fragCoord, vec2 uv, vec2 uvD, inout float rayNumber)\n{\t\n\tvec3 accum = vec3(0.0);\n    \n    float k = 0.0;\n\n    vec2 rc = fragCoord + (5.0+mod(iTime, 1.73728))*vec2(rayNumber*37.0, rayNumber*63.0);\n    vec4 rand = texelFetch(iChannel0, ivec2(mod(rc, vec2(256.0))), 0);\n\n    float time = 64.0 + 11.3 + 0.2*sin(iTime); //floor(float(iFrame)/300.0);\n    float shutterSpeed = 0.0;\n    \n    float t = time + shutterSpeed*rand.x;\n\t\n    int bounces = 0;\n\n\n    ray r;\n    r.d = normalize(randomUnitVector(rand.x, rand.y));\n    rand = rand.zwxy;\n    r.p = vec3(2.75, -1.35, 0.) + r.d * 0.0;\n    r.d = normalize(r.p - vec3(2.75, -1.35, 0.));\n    r.light = vec3(5.0, 3.5, 3.0)*0.2;\n    r.transmit = vec3(1.0);\n    \n    vec3 directLight = vec3(0.0);\n    \n    ray light = r;\n\n    r = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k+rayNumber, t);\n    bounces = 0;\n    k = 0.0;\n    \n    vec3 nml;\n    float diffuse;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n            mat m = material(r.p, rayNumber);\n\t\t\tr.p -= dist * r.d;\n\t\t\tnml = normal(r, dist);\n            diffuse = m.diffuse;\n            r.transmit *= m.transmit;\n            r.light = m.emit;\n\n            //offset(nml, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), 0.0);\n            r.d = reflect(r.d, nml);\n\t\t\tr.p += THRESHOLD * nml;\n            \n            directLight = traceLight(r, nml, light);\n\n            r.p += dist * r.d;\n\n            rand = rand.yzwx;\n            bounces++;\n            break;\n\t\t} else if (dist > MAX_DISTANCE) {\n            break;\n\t\t}\n\t}\n\n    vec3 collected = vec3(0.0);\n    float scale = 0.0;\n    const int sz = 32;\n    for (int y=-sz; y<sz; y++) {\n        for (int x=-sz; x<sz; x++) {\n            vec4 contrib = texelFetch(iChannel1, ivec2(fragCoord + vec2(x,y)), 0);\n            vec4 color = texelFetch(iChannel2, ivec2(fragCoord + vec2(x,y)), 0);\n            vec3 cv = normalize(contrib.xyz - r.p); // direction to hemisphere point\n            float d = pow(max(0.0, dot(cv, r.d)), 1.0); // / (diffuse*diffuse*diffuse));\n            d *= 2.0 * max(0.0, dot(nml, cv));\n            float pxScale = 1.0 - (length(vec2(x,y)) / float(sz)/sqrt(2.0));\n            float s = d * pxScale;\n            scale += s;\n            contrib.a *= s;\n            collected += s * max(vec3(0.0), color.rgb);\n        }\n    }\n\n    //accum += r.light + r.transmit * ((directLight*float(sz*sz) + collected) / (float(sz*sz)+scale));\n\n    k += 1.0;\n\n\trayNumber += k;\n    //accum += abs(vec3(normalize(texelFetch(iChannel2, ivec2(fragCoord), 0).rgb)));\n    accum = r.transmit * collected / scale; //texelFetch(iChannel2, ivec2(fragCoord), 0).rgb;\n    accum += r.light + r.transmit * directLight;\n\treturn 3.0*accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (2.0*uv - 1.0) * aspect;\n\n    vec2 uvD = ((2.0*(fragCoord.xy+vec2(1.0, 1.0)) / iResolution.xy - 1.0) * aspect) - uv;\n\n    float rayNumber = 0.0;\n    vec3 light = trace(fragCoord, uv, uvD, rayNumber);\n    fragColor = vec4(light, rayNumber);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n}","name":"Buf D","description":"","type":"buffer"}]}