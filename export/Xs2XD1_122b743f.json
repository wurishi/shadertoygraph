{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define FOV_FACTOR 1.5\n#define ITERATIONS 10\n\n//reflection vs refraction; 0.0 = only refraction (glass), 1.0 = only reflection (metal)\n#define REFLECTION_PERCENTAGE 0.3\n\n#define LIGHT_COLOR vec4(1.0,0.85,0.5,1.0)\n#define LIGHT_INTENSITY 0.5\n#define HUGE_FLOAT 99999.0\n#define E 2.7182818284\n#define NUM_BALLS 7\n//#define MOUSE_CAMERA\n\nstruct Ball {\n    vec3 center;\n    float radius;\n    vec4 color;\n    float attenuationCoefficient;\n    float relativeIndexOfRefraction;\n    float bumpIntensity;\n};\n    \nBall getBall(int i)\n{\n    vec2 center = vec2(iResolution.x/iResolution.y/2.0,0.5);\n    \n    if(i == 0)\n    {\n#ifdef MOUSE_CAMERA\n        return Ball(vec3(center.x,0.9,0.9), 0.024, vec4(1.0,1.0,1.0,1.0), 0.0, 0.0, 0.0);\n#else\n        return Ball(vec3(iMouse.xy / iResolution.yy,1.0), 0.024, vec4(1.0,1.0,1.0,1.0), 0.0, 0.0, 0.0);\n#endif\n    }\n    else if(i == 1)\n    {\n        return Ball(vec3(center.x,sin(iTime)*0.2+0.5,0.6), 0.16, vec4(0.9,0.99,0.9,1.0), 4.0, 0.6, 0.0);\n    }\n    else if(i == 2)\n    {\n        return Ball(vec3(center.x+0.35,0.5,sin(iTime)*0.2+0.5), 0.14, vec4(0.9,0.9,0.99,1.0), 12.0, 0.4, 1.1);\n    }\n    else\n    {\n    \treturn Ball(vec3(sin(iTime)*0.02+center.x-0.35,float(i-3)*0.2+0.2,0.6), 0.08, vec4(0.96,0.99,0.99,1.0), 5.0+float(i-3)*4.0, 0.5 + float(i-3)*0.07, float(i-3)*0.25);\n    }\n}\n\n//P is the point in local ball space, N is the normal at that point.\nvec3 transformNormalWithHeightMap(vec3 N, vec3 P, float bumpIntensity)\n{\n    float texelWidth = 1.0/iChannelResolution[1].x;\n    float texelHeight = 1.0/iChannelResolution[1].y;\n    float c = \ttexture(iChannel1,P.xy).x;\n\tfloat n = \ttexture(iChannel1,vec2(P.x,P.y+texelHeight)).x;\n\tfloat s = \ttexture(iChannel1,vec2(P.x,P.y-texelHeight)).x;\n\tfloat e = \ttexture(iChannel1,vec2(P.x+texelWidth,P.y)).x;\n\tfloat w = \ttexture(iChannel1,vec2(P.x-texelWidth,P.y)).x;\n    \n    //find perpendicular vector to norm:\t\t\n\tvec3 temp = N; //a temporary vector that is not parallel to norm\n\tif(N.x==1.0)\n\t\ttemp.y+=0.5;\n\telse\n\t\ttemp.x+=0.5;\n    \n    //form a basis with norm being one of the axes:\n\tvec3 perp1 = normalize(cross(N,temp));\n\tvec3 perp2 = normalize(cross(N,perp1));\n \n\t//use the basis to move the normal in its own space by the offset\t\t\n\tvec3 normalOffset = -bumpIntensity * ( ((n-c)-(s-c))*perp1 + ((e-c)-(w-c))*perp2 );\n\tN += normalOffset;\n    \n\treturn normalize(N);\n}\n\n//from https://gist.github.com/num3ric/4408481\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDirection, Ball sphere)\n{\n    vec3 oc = rayOrigin - sphere.center;\n    float b = 2.0 * dot(rayDirection, oc);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n    float disc = b * b - 4.0 * c;\n \n    if (disc < 0.0)\n        return -1.0;\n \n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n \n    float t0 = q;\n    float t1 = c / q;\n \n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n \n    // if t1 is less than zero, the object is in the ray's negative direction\n    // and consequently the ray misses the sphere\n    if (t1 < 0.0)\n        return -1.0;\n \n    // if t0 is less than zero, the intersection point is at t1\n    if (t0 < 0.0) {\n        return t1;\n    } else {\n        return t0; \n    }\n}\n\n\n//http://tavianator.com/2011/05/fast-branchless-raybounding-box-intersections/\nvec3 intersectBoundingCube(vec3 origin, vec3 direction)\n{\n    vec3 boxMin = vec3(-2.0,-2.0,-2.0);\n    vec3 boxMax = vec3(2.0,2.0,2.0);\n    vec3 directionInverse = 1.0 / direction;\n    \n    float tx1 = (boxMin.x - origin.x)*directionInverse.x;\n  \tfloat tx2 = (boxMax.x - origin.x)*directionInverse.x;\n \n  \tfloat tmin = min(tx1, tx2);\n  \tfloat tmax = max(tx1, tx2);\n \n  \tfloat ty1 = (boxMin.y - origin.y)*directionInverse.y;\n  \tfloat ty2 = (boxMax.y - origin.y)*directionInverse.y;\n \n  \ttmin = max(tmin, min(ty1, ty2));\n  \ttmax = min(tmax, max(ty1, ty2));\n    \n    float tz1 = (boxMin.z - origin.z)*directionInverse.z;\n  \tfloat tz2 = (boxMax.z - origin.z)*directionInverse.z;\n    \n    tmin = max(tmin, min(tz1, tz2));\n  \ttmax = min(tmax, max(tz1, tz2));\n    \n    if(tmax >= tmin)\n    {\n        return origin + tmax*direction;\n    }\n    \n    return vec3(HUGE_FLOAT);\n}\n\n//http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-plane-and-ray-disk-intersection/\nfloat intersectPlane(vec3 n, vec3 p0, vec3 l0, vec3 l)\n{\n    // assuming vectors are all normalized\n    float denom = dot(n, l);\n    if (denom > 1e-6)\n    {\n        return dot(p0 - l0, n) / denom;\n    }\n    return -1.0;\n}\n\n//http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    //assuming axis is normalized\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n//returns the color at the hit point.\nint castRay(vec3 origin, vec3 direction, bool doRefract, int exclude, out vec3 newOrigin, out vec3 newDirection, out vec4 newColor, out vec3 normal, out vec3 frontPoint)\n{\n    int closestIndex = -1;\n    Ball closestBall;\n    float closestHitT = HUGE_FLOAT;\n    for(int i = 0; i < NUM_BALLS; ++i)\n    {\n        if(exclude != i) //no self-test!\n        {\n            Ball ball = getBall(i);\n        \tfloat hitT = intersectSphere(origin,direction,ball);\n            if(hitT != -1.0 && hitT < closestHitT)\n            {\n                closestHitT = hitT;\n                closestIndex = i;\n                closestBall = ball;\n            }\n        \t\n        }\n    }\n    if(closestHitT != HUGE_FLOAT)\n    {\n    \tvec3 hitP = origin + (direction * closestHitT);\n        normal = transformNormalWithHeightMap(normalize(hitP - closestBall.center), hitP-closestBall.center, closestBall.bumpIntensity);\n        if(doRefract)\n        {\n            vec3 refraction = refract(normalize(hitP-origin), normal, closestBall.relativeIndexOfRefraction);\n            vec3 farOrigin = hitP + refraction * 10.0;\n            float hitT2 = intersectSphere(farOrigin,-refraction,closestBall);\n            vec3 hitP2 = farOrigin + (-refraction * hitT2);\n            vec3 normal2 = transformNormalWithHeightMap(normalize(closestBall.center - hitP2), hitP2-closestBall.center, closestBall.bumpIntensity);\n            vec3 refraction2 = refract(normalize(hitP2-hitP), normal2, closestBall.relativeIndexOfRefraction);\n            newOrigin = hitP2;\n            newDirection = refraction2;\n            newColor = closestBall.color;\n            frontPoint = hitP;\n            \n        }\n        else\n        {\n        \tvec3 reflection = reflect(normalize(hitP-origin), normal);\n        \tnewOrigin = hitP;\n        \tnewDirection = reflection;\n        \tnewColor = closestBall.color;\n        }\n    }\n    else\n    {\n        //Intersect with the cubemap.\n        //TODO: Use intersectBoundingCube instead of individually intersecting with 6 planes.\n        normal = vec3(0.0,0.0,-1.0);\n        float t = intersectPlane(normal,vec3(0.0,0.0,-2.0),origin,direction);\n\t\tif(t >= 0.0)\n        {\n            newOrigin = origin + t * direction;\n            frontPoint = newOrigin;\n            newColor = texture(iChannel0, (origin + direction * t).xyz);\n            return closestIndex;\n        }\n        normal = vec3(0.0,0.0,1.0);\n        t = intersectPlane(normal,vec3(0.0,0.0,2.0),origin,direction);\n        if(t >= 0.0)\n        {\n            newOrigin = origin + t * direction;\n            frontPoint = newOrigin;\n            newColor = texture(iChannel0, (origin + direction * t).xyz);\n            return closestIndex;\n        }\n        normal = vec3(0.0,-1.0,0.0);\n        t = intersectPlane(normal,vec3(0.0,-2.0,0.0),origin,direction);\n        if(t >= 0.0)\n        {\n            newOrigin = origin + t * direction;\n            frontPoint = newOrigin;\n            newColor = texture(iChannel0, (origin + direction * t).xyz);\n            return closestIndex;\n        }\n        normal = vec3(0.0,1.0,0.0);\n        t = intersectPlane(normal,vec3(0.0,2.0,0.0),origin,direction);\n        if(t >= 0.0)\n        {\n            newOrigin = origin + t * direction;\n            frontPoint = newOrigin;\n            newColor = texture(iChannel0, (origin + direction * t).xyz);\n            return closestIndex;\n        }\n        normal = vec3(-1.0,0.0,0.0);\n        t = intersectPlane(normal,vec3(-2.0,0.0,0.0),origin,direction);\n        if(t >= 0.0)\n        {\n            newOrigin = origin + t * direction;\n            frontPoint = newOrigin;\n            newColor = texture(iChannel0, (origin + direction * t).xyz);\n            return closestIndex;\n        }\n        normal = vec3(1.0,0.0,0.0);\n        t = intersectPlane(normal,vec3(2.0,0.0,0.0),origin,direction);\n        if(t >= 0.0)\n        {\n            newOrigin = origin + t * direction;\n            frontPoint = newOrigin;\n            newColor = texture(iChannel0, (origin + direction * t).xyz);\n            return closestIndex;\n        }\n               \n        \n    }\n    return closestIndex;\n}\n\nvec4 castLightRay(vec3 lightOrigin, vec3 lightTarget, vec3 normalAtTarget, vec3 eyePos)\n{\n    vec3 lightDir = lightTarget - lightOrigin;\n    vec3 normalizedLightDir = normalize(lightDir);\n    float targetT = length(lightDir);\n    float currentIntensity = LIGHT_INTENSITY;\n    for(int i = 0; i < NUM_BALLS; ++i)\n    {\n        Ball ball = getBall(i);\n    \tfloat lightHitT = intersectSphere(lightOrigin, normalizedLightDir, ball);\n       \tif(lightHitT != -1.0 && targetT - lightHitT > 0.01)\n        {\n            //Beer-Lambert\n            vec3 farOrigin = lightTarget + lightDir * 10.0;\n            float hitT2 = intersectSphere(farOrigin, (-normalizedLightDir), ball);\n            vec3 backPoint = farOrigin + -normalizedLightDir * hitT2;\n            vec3 frontPoint = lightOrigin + normalizedLightDir * lightHitT;            \n            float lengthInsideBall = length(frontPoint - backPoint);\n            currentIntensity *= pow(E, -lengthInsideBall * ball.attenuationCoefficient);\n            //\n        }\n    }\n    vec3 newLightDir = reflect(lightDir, normalAtTarget);\n    currentIntensity *= dot(newLightDir, eyePos-lightTarget);\n   \treturn LIGHT_COLOR * clamp((currentIntensity/(targetT*targetT)), 0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 center = vec2(iResolution.x/iResolution.y/2.0,0.5);\n\tvec2 uv = fragCoord.xy / iResolution.yy; //Avoid stretching by dividing both dimensions by y.\n    \n    //Let's do everything in uv space!\n    \n    //Spreading out the source \"rays\" for \"perspective\"\n    vec3 p2 = vec3((uv-center)*FOV_FACTOR+center, 0.0); \n    vec3 p1 = vec3(uv, 1.0);\n    \n#ifdef MOUSE_CAMERA\n    vec3 center3 = vec3(center,0.5);\n    \n    mat4 cameraRotation = rotationMatrix(vec3(0.0,1.0,0.0),6.26 * iMouse.x / iResolution.x);\n    p2 = (vec4(p2-center3,0.0) * cameraRotation).xyz+center3;\n    p1 = (vec4(p1-center3,0.0) * cameraRotation).xyz+center3;\n    \n    cameraRotation = rotationMatrix(vec3(1.0,0.0,0.0),6.26 * iMouse.y / iResolution.y);\n    p2 = (vec4(p2-center3,0.0) * cameraRotation).xyz+center3;\n    p1 = (vec4(p1-center3,0.0) * cameraRotation).xyz+center3;\n#endif\n    \n    vec3 lightPos = getBall(0).center;\n    \n    vec4 color1 = vec4(1.0);\n    vec4 color2 = vec4(0.0);\n    \n    vec3 origin = p1;\n    vec3 direction = normalize(p2-p1);\n    \n    int currentSphereHit = -1;\n    \n    for(int i = 0; i < ITERATIONS; ++i)\n    {       \n     \tvec4 newColor;\n        vec3 normal;\n        vec3 prevOrigin = origin;\n        vec3 frontPoint;\n        currentSphereHit = castRay(origin, direction, false, currentSphereHit, origin, direction, newColor, normal, frontPoint);\n        \n        color1 -= (vec4(1.0,1.0,1.0,2.0) - newColor) * REFLECTION_PERCENTAGE;\n        \n        color2 += castLightRay(lightPos, origin, normal, prevOrigin) * REFLECTION_PERCENTAGE;\n        \n        if(currentSphereHit == -1)\n        {\n            break;\n        }        \n    }\n    \n    origin = p1;\n    direction = normalize(p2-p1);\n    currentSphereHit = -1;\n    \n    for(int i = 0; i < ITERATIONS; ++i)\n    {       \n     \tvec4 newColor;\n        vec3 normal;\n        vec3 frontPoint;\n        vec3 prevOrigin = origin;\n        currentSphereHit = castRay(origin, direction, true, currentSphereHit, origin, direction, newColor, normal, frontPoint);\n        \n        color1 -= (vec4(1.0,1.0,1.0,2.0) - newColor) * (1.0 - REFLECTION_PERCENTAGE);\n        \n        color2 += castLightRay(lightPos, frontPoint, normal, prevOrigin) * (1.0 - REFLECTION_PERCENTAGE);\n                \n        if(currentSphereHit == -1)\n        {\n            break;\n        }        \n    }\n        \n   \tfragColor = color1 + color2;\n    \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xs2XD1","date":"1411602119","viewed":292,"name":"Noobie Rays!","username":"Xytor","description":"Trying \"raytracing\" without reading any literature to see if i can figure it out with just a vague idea.\nUse the mouse to move the light around. Unless MOUSE_CAMERA is defined, then the light is static while the mouse position determines camera orbit.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","reflection","refraction","lighting","bumpmapping"],"hasliked":0,"parentid":"","parentname":""}}