{"ver":"0.1","info":{"id":"432yzG","date":"1727392844","viewed":63,"name":"newton 3d ","username":"pb","description":"here is some interesting structure generated by running newton's method in 3d, makes nice color gradients if nothing else ","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["3d","newtonsmethod","volumetriccolor"],"hasliked":0,"parentid":"7dcfD2","parentname":"Newton3D"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n        \n    O = fwidth(iResolution.y/50.*O*O);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define too_small 1e-8\n\n//common math objects everyone knows about and can use freely\n\nvec3 angle_axis_rotation( vec3 v, vec3 k, float a ) {\n\n    //rotates vector:v around axis: k (normalized) by angle:a\n    //https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n    //Euler already knew it though..\n    \n    //Please use it, Abuse it!\n    float cc=cos(a), ss=sin(a);\n    \n    return v*cc + cross(k,v)*ss + k*dot(k,v)*(1.-cc);\n}\n\n\nmat3 inv3d( mat3 a ) {\n\n    //good ol' fashioned inverse of 3x3 matrix\n    //Please use it, Abuse it!\n\n    //determinant\n    float det = \n        a[0][0] * a[1][1] * a[2][2] \n      + a[1][0] * a[2][1] * a[0][2]\n      + a[2][0] * a[0][1] * a[1][2]\n      - a[2][0] * a[1][1] * a[0][2]\n      - a[1][0] * a[0][1] * a[2][2]\n      - a[0][0] * a[2][1] * a[1][2];\n \n    if ( abs(det) < too_small ) \n    { det = sign(det) * 1./too_small; }\n    else { det = 1./det; }\n\n    return det * \n    mat3( a[1][1]*a[2][2]-a[2][1]*a[1][2], a[2][0]*a[1][2]-a[1][0]*a[2][2], a[1][0]*a[2][1]-a[2][0]*a[1][1],\n          a[2][1]*a[0][2]-a[0][1]*a[2][2], a[0][0]*a[2][2]-a[2][0]*a[0][2], a[2][0]*a[0][1]-a[0][0]*a[2][1],\n          a[0][1]*a[1][2]-a[1][1]*a[0][2], a[1][0]*a[0][2]-a[0][0]*a[1][2], a[0][0]*a[1][1]-a[1][0]*a[0][1] );\n\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat sc;\n\nvec3 newton_color( vec3 p ) {\n\n    vec3 q ; mat3 dq;\n    \n    vec3 op = vec3(1,0,0);\n    \n    sc = 1.;\n    \n    for (float i=0.;i<6.;i++) {\n    \n        //you can plug and play with your own \n        //vector functions and derivatives here\n        float pxx=p.x*p.x,pyy=p.y*p.y,pzz=p.z*p.z;\n        \n        //vector function\n        q = vec3(p.y*pyy, p.z*pzz, p.x*pxx) - vec3(5);\n        \n        //matrix of partial derivatives\n        dq = mat3( 0.,0.,3.*pxx,\n                   3.*pyy,0.,0.,\n                   0.,3.*pzz,0.);\n          \n        \n        p -= inv3d(dq) * q;  //the \"Newton Step\"\n        \n        sc *= length(p)/length(op);\n        \n        op = p;\n\n    }\n    \n    return vec3(p)/sc;\n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec3 ro = vec3(20)+19.*cos(iTime);  \n    \n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y *2.;\n    \n    vec3 rd = normalize( vec3(uv,-1.4) );\n    \n    vec3 p = ro;\n    \n#define rot(a)  mat2( cos(a + vec4(0,11,33,0) ) )\n\n    rd.yz *= rot(.7);\n    rd.xz *= rot(.8); \n    //rd.xy *= rot(iTime/3.);\n    \n    vec3 color = vec3(0.5);\n    float totdist = 0.;\n    float stepsize;\n    \n    for (float i=0.; i<7.; i++) {\n    \n        vec3 newton = newton_color(p);\n        float stepsize = length(newton)/6.;\n        p += stepsize*rd;\n        totdist += stepsize;\n        \n        color +=   newton*newton * exp(-totdist*4.);\n\n    }\n    \n    color = tanh(color*color*color*color);\n    \n    color = clamp(color, 0., 1.);\n    \n    fragColor = vec4(color,1.);\n\n}","name":"Buffer A","description":"","type":"buffer"}]}