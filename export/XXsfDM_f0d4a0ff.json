{"ver":"0.1","info":{"id":"XXsfDM","date":"1728563561","viewed":108,"name":"Bagua Yin Yang Tai Chi","username":"dray","description":"Inspired by discussion [url]https://www.shadertoy.com/view/M3XBDN[/url]\nand [url]https://www.jadeladytaichi.com.au/8-trigrams-ba-men[/url]\nMixed 2d + 3d, multiple marches","likes":8,"published":3,"flags":0,"usePreview":0,"tags":["yinyang","taichi","bagua"],"hasliked":0,"parentid":"43jyDG","parentname":"another Bagua (250 chars)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMy little green men/women from https://www.shadertoy.com/view/4f2fz3 & etc\nI still have to fix those arms ... missing an internal 45deg rotation I think\n\nFast compile & run on multiple platforms !\n\nSome other Yin-Yangs:\nhttps://www.shadertoy.com/view/XlfGD8 - anti aliased\nhttps://www.shadertoy.com/view/ldX3Rr - tiny\n*/\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define min3(A,B,C) min(A,min(B,C))\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nmat3 MAT3xz(float ANG) { return mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) ); }\nmat3 MAT3zy(float ANG) { return mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) ); }\nmat3 MAT3xy(float ANG) { return mat3( cos(ANG),sin(ANG),0, -sin(ANG),cos(ANG),0, 0,0,1 ); }\n\n// *********************************************************************************\n\nstruct DAN {\n    float luarm, ruarm;   // spread arms apart 0-3 radians\n    float lelbow, relbow; // bend elbows 0-3 radians\n    float lshoulder, rshoulder; // raise arms in front 0-3 radians\n    //float lrota, rrota; // upper arm rotation -1 - 1 radians\n    float lknee, rknee;  // bend knees 0-3 radians\n    float luleg, ruleg;  // spread legs apart 0-1.5 radians\n    float lhip, rhip;    // raise legs in front 0-3 radians\n    float spin;\n    float leanl, leanf;\n    float hop;\n    // results\n    vec3 _head, _hips; // body\n    vec3 _lshoulder,_lelbow, _lhand;\n    vec3 _rshoulder, _relbow, _rhand;\n    vec3 _lknee, _lhip, _lfoot;\n    vec3 _rknee, _rhip, _rfoot;\n    float _bottom;\n};\n\n#define DANIni(D) \\\n  D.luarm=0.; D.lelbow=0.; D.ruarm=0.; D.relbow=0.; D.luleg=0.; D.lknee=0.; D.ruleg=0.; D.rknee=0.; \\\n  D.lshoulder=0.; D.rshoulder=0.; D.lhip=0.; D.rhip=0.; \\\n  D.spin=0.; D.leanl=0.; D.leanf=0.; D.hop=0.; \\\n  /* D.lrota=0.; D.rrota=0.; */\n\n// alternative to .5-.5*cos(P)\n//float tri(float i) {  return 1. - abs( fract(i)*2. - 1. ); }\n//#define cosp(P) SS(tri((P))) \n\n#define SINM(P,L,H) ((.5-.5*sin(P))*((H)-(L))+(L))\n#define COSM(P,L,H) ((.5-.5*cos(P))*((H)-(L))+(L))\n#define MOVE(FLD,P,L,H) FLD=((.5-.5*cos(P))*((H)-(L))+(L));\n#define HOP(D,V0,G,T)  STDY( D.hop, max( 0., (V0)*(T) - (G)*(T)*(T) ) );\n#define STDY(FLD,VAL) FLD = (VAL);\n\n// *********************************************************************************\n\nDAN Jill;\n\n#define HandsInFront(D) \n#define LegsApart(D) D\nvoid animJill(inout DAN m) {\n    DANIni(m);\n    HandsInFront(m)\n    \n    m.luleg=m.ruleg=.2;\n    m.rhip = m.lhip = ( m.lknee = m.rknee = SINM(iTime,.3,1.3) ) * .5;\n    \n    m.luarm=cos(iTime)*3.+2.;\n    m.ruarm=sin(iTime)*3.+2.;\n    m.lelbow=m.relbow=1.;\n    \n    //m.lshoulder=m.rshoulder=1.5;\n    MOVE(m.rshoulder,iTime,0.,2.);\n    m.lshoulder=m.rshoulder;\n    \n    //m.spin = .3;\n    //STDY( m.spin, -iTime*2. );\n    MOVE(m.spin,iTime*2.,-.3,.3)\n    MOVE(m.leanf,iTime*2.,-.3,.3)\n    \n    /*\n    m.lshoulder =  ( m.rshoulder = 1. );\n    m.ruarm = m.luarm = .5;\n    */\n    //STDY( m.spin, -iTime*2. );    \n    /*\n    MOVE(Jill.lelbow,iTime*1.,.2,1.);\n    MOVE(Jill.relbow,iTime*4.,.1,1.);\n    MOVE(Jill.lshoulder,iTime*-4.,0.,2.2);\n    MOVE(Jill.rshoulder,iTime*-1.,0.,1.8);\n    MOVE(Jill.luarm,iTime*1.,0.,.5);\n    MOVE(Jill.ruarm,iTime*3.,0.,1.5);\n    MOVE(Jill.rhip,iTime*5.,0.,1.);\n    MOVE(Jill.rknee,iTime*-7.,0.,1.);\n    MOVE(Jill.ruleg,iTime*3.,0.,1.);\n    STDY( Jill.luleg, -.075 );\n    STDY( Jill.spin, -iTime*4. );\n    MOVE(Jill.leanf,iTime*1.5,-.5,.5);\n    */\n}\n\n// -----------------------------------------------------------------------------\n\n#define DSZ 20.\n\nvoid CompDancer(inout DAN m) {\n    m._hips = vec3(0,0,0); // origin !\n    mat3 rott =  MAT3zy(m.leanf) * MAT3xz( m.spin ) * MAT3xy(m.leanl);\n    m._head = m._hips + vec3(0,.33,0)*DSZ * rott;\n\n    vec3 shoulders = mix( m._hips, m._head, .8 );\n\n    mat3 sav = rott;\n  \n    // left arm\n    m._lshoulder = shoulders - vec3(.075,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.lshoulder ) * MAT3xy( m.luarm ) * rott;\n    m._lelbow = m._lshoulder + vec3(0,-.12,0)*DSZ * rott;\n    rott = MAT3zy( -m.lelbow ) * rott;\n    m._lhand = m._lelbow + vec3(0,-.12,0)*DSZ * rott;\n  \n    rott = sav;\n\n    // right arm\n    m._rshoulder = shoulders + vec3(.075,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.rshoulder ) * MAT3xy( -m.ruarm ) * rott;\n    m._relbow = m._rshoulder + vec3(0,-.12,0)*DSZ * rott;\n    rott = MAT3zy( -m.relbow ) * rott;\n    m._rhand = m._relbow + vec3(0,-.12,0)*DSZ * rott;\n\n    rott = sav;\n\n    // left leg\n    m._lhip = m._hips - vec3(.025,0,0)*DSZ * rott;\n    rott =  MAT3xy( m.luleg - m.leanl ) * MAT3zy( -m.lhip -  m.leanf ) * rott;\n    m._lknee = m._lhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.lknee ) * rott;\n    m._lfoot = m._lknee + vec3(0,-.18,0)*DSZ * rott;\n\n    rott = sav;\n\n    // right leg\n    m._rhip = m._hips + vec3(.025,0,0)*DSZ * rott;\n    rott = MAT3xy( -m.ruleg - m.leanl ) * MAT3zy( -m.rhip  - m.leanf ) * rott;\n    m._rknee = m._rhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.rknee ) * rott;\n    m._rfoot = m._rknee + vec3(0,-.18,0)*DSZ * rott;\n\n    m._bottom = min3( m._lfoot.y, m._rfoot.y, m._hips.y-.035*DSZ/3. ) - m.hop;\n\n}\n\n/*\nfloat Dancer2(vec3 pt,DAN m) {\n    pt.y += m._bottom;\n    float dist = sdCapsule( pt, m._head, m._hips, .035*DSZ ); // body\n    float tmp;\n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); if ( tmp < dist ) dist = tmp;\n    ADD(m._lshoulder,m._lelbow,.02)\n    ADD(m._lhand,m._lelbow,.02)\n    ADD(m._rshoulder,m._relbow,.02)\n    ADD(m._rhand,m._relbow,.02)\n    ADD(m._lshoulder,m._rshoulder,.02)\n    ADD(m._lknee,m._lhip,.025)\n    ADD(m._lfoot,m._lknee,.025)\n    ADD(m._rknee,m._rhip,.025)\n    ADD(m._rfoot,m._rknee,.025)\n    return dist;\n}\n*/\n\n\nfloat Dancer2(vec3 pt,DAN m) {\n    pt.y += m._bottom;\n    float dist = 0.;\n    float tmp;\n    float ctrl = -.2;\n#undef ADD    \n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); \\\n dist += 1. / max( 1e-10, (tmp)+ctrl );\n    ADD(m._head,m._hips,.035)\n    #define AT .015\n    ADD(m._lshoulder,m._lelbow,AT)\n    ADD(m._lhand,m._lelbow,AT)\n    ADD(m._rshoulder,m._relbow,AT)\n    ADD(m._rhand,m._relbow,AT)\n    ADD(m._lshoulder,m._rshoulder,.02)\n    ADD(m._lknee,m._lhip,.025)\n    ADD(m._lfoot,m._lknee,.025)\n    ADD(m._rknee,m._rhip,.025)\n    ADD(m._rfoot,m._rknee,.025)\n    return 1. / dist;\n}\n\n\n// Map --------------------------------------------------------------\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n    T( Dancer2( (pt-vec3(0,0,-3)), Jill ) )\n    clr = 3.;\n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 300; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( pos.z < -80. ) return vec4( pos, 91. );\n        if ( obj.x < .01 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\n// *********************************************************************************\n\nvec4 Window(vec2 u) {\n  if ( length(u) >.4 ) return vec4(0);\n  vec3 cam = vec3( 0, 10, -64);\n  vec3 camdir = normalize( vec3( u*.4, 1 ) );\n  vec3 Light = vec3( 30, 30, -30 );\n  vec4 hit = March( cam, camdir );\n  vec3 dir = normalize( Light - hit.xyz );\n  vec3 norm = Normal(hit.xyz);\n  float difu = dot( norm, dir );\n  difu = .3 + .7*difu;\n#define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n  return color4(hit.w*.4) * difu;\n}\n\n// *********************************************************************************\n\n// Continuing from https://www.shadertoy.com/view/l32yRt\n\n#define J(Q) O += clamp(-(max(abs(u.y-Q)*8.,abs(u.x))-.14)*1e2,0.,float(abs(u.x)<.03?m&1:1)); m>>=1;\n#define Z J(.7) J(.6) J(.5) u*=mat2(1,1,-1,1)*.707;\n\nvoid mainImage( out vec4 O, vec2 u ) \n{\n  O.xyz = iResolution;\n  u = (u+u-O.xy)/O.y * 1.5;\n\n  // Bagua\n  int m = 6850935; \n  O -= O;\n  Z Z Z Z Z Z Z Z    // Snoring here\n  \n  // Tai Chi\n  animJill(Jill);\n  CompDancer(Jill);\n  #define TRY(P) if ( length( (t=.9*(u*1.1+vec2(0,-.1) P))+vec2(0,.1) ) < .35 ) ; else\n  vec2 t=u;\n  TRY(-.9)\n  TRY(+.9)\n  TRY(+vec2(1.2,.1))\n  TRY(+vec2(-1.2,.1))\n  TRY(+vec2(0,1.2))\n  TRY(+vec2(0,-1.2))\n  TRY(+vec2(.9,-.9))\n  TRY(+vec2(-.9,.9))\n  ;\n  O += Window(t);\n  \n  /*\n  O += Window(u-.7);\n  O += Window(u+.7);\n  O += Window(u-vec2(.9,.1));\n  O += Window(u+vec2(.9,-.1));\n  O += Window(u-vec2(0,1));\n  O += Window(u+vec2(0,.95));\n  O += Window(u+vec2(.7,-.7));\n  O += Window(u-vec2(.7,-.7));\n  */\n  \n  // Yin and Yang\n  #define C(L,O) smoothstep( L+.01, L, length(u+vec2(O)) )\n  O += clamp( C(.4,0) - min( smoothstep( .49, .51, (u.y-u.x)*50. )*.9, C(.385,0) )\n    - C(.19, .137 ) + C(.19, -.137 )\n    - C(.04,-.15)*2. + C(.04,.15)*2.\n    , 0., 1. );\n}\n\n\n// *********************************************************************************\n\n","name":"Image","description":"","type":"image"}]}