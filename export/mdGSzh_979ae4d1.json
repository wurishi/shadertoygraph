{"ver":"0.1","info":{"id":"mdGSzh","date":"1680702095","viewed":127,"name":"Directional vs Simple Kuwahara ","username":"benjik42","description":"Here a directional (on left) and a simple (on right) kuwahara filter implementation !\nGood work for the directional with the sidewalks and the arch on the right. But seam that there is a problem with windows. \nI've still a lot of research !!","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["filterkuwahara"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 DirectionalKuwahara(vec2 uv){\n    float Gradient_X = 5.;\n    float Gradient_Y = 5.;\n    vec3 col;\n    vec2 pos;\n    vec2 RADIUS = vec2(Gradient_X,Gradient_Y);\n    vec2 texelSize = vec2(1.)/iResolution.xy;\n    float SobelX[9] = float[9](-1., -2., -1., 0., 0., 0., 1., 2., 1.);\n    float SobelY[9] = float[9](-1., 0., 1., -2., 0., 2., -1., 0., 1.);\n    int a=1;\n    \n    for(int x=-1;x<1;x++){\n        for(int y=-1;y<1;y++){\n            //1\n            vec2 offset = vec2(x,y)+texelSize;\n            vec3 PixelColor = texture(iChannel0,uv+offset).rgb;\n            float PixelValue = dot(PixelColor, vec3(0.3,0.59,0.11));\n            // 2\n            Gradient_X += PixelValue * SobelX[a];\n            Gradient_Y += PixelValue * SobelY[a];\n            a++;\n        \n        }\n    \n    \n    }\n    \n    float Angle = atan(Gradient_X/Gradient_Y);\n    \n    \n    \n    vec3 mean[4] = vec3[4](\n    \n        vec3(0.,0.,0.),\n        vec3(0.,0.,0.),\n        vec3(0.,0.,0.),\n        vec3(0.,0.,0.)\n    );\n    \n    vec3 sigma[4] = vec3[4](\n    \n        vec3(0.,0.,0.),\n        vec3(0.,0.,0.),\n        vec3(0.,0.,0.),\n        vec3(0.,0.,0.)\n    );\n    \n    vec2 offsets[4] = vec2[4](\n    \n        vec2(-RADIUS.x,-RADIUS.y),\n        vec2(-RADIUS.x,0.),\n        vec2(0.,-RADIUS.y),\n        vec2(0.,0.)\n    );\n    \n    \n    for(int i =0;i<4;i++){\n        for(int j=0;j<=int(RADIUS.x);j++){\n            for(int k = 0;k<=int(RADIUS.y);k++){\n            \n                pos = (vec2(j,k)+offsets[i])*mat2(cos(Angle), -sin(Angle), sin(Angle), cos(Angle));;\n                vec2 uvpos = uv+pos/iResolution.xy;\n                vec3 col = vec3(texture(iChannel0,uvpos));\n                mean[i] += col;\n                sigma[i] += col*col;\n        \n            }\n        \n        \n        \n        }\n    \n    \n    \n    }\n    \n    float Samples = (float(RADIUS)+1.)*(float(RADIUS)+1.);\n    \n    float Variance;\n    float min = 1.;\n    \n    for(int i=0;i<4;i++){\n    \n        mean[i]/=Samples;\n        sigma[i] = sigma[i]/Samples -mean[i]*mean[i]; \n        Variance = sigma[i].r+sigma[i].g+sigma[i].b;\n        \n        if(Variance<min){\n            min =Variance ;\n            col = mean[i];\n        \n        }\n    \n    }\n    \n    return col;\n}\n\nvec3 SimpleKuwahara(vec2 uv){\n  int RADIUS = 5;\n  vec2 pos;\n  vec3 col;\n\n\n  vec3 mean[4] = vec3[4](vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.));\n  vec3 sigma[4] = vec3[4](vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.),vec3(0.,0.,0.));\n\n  vec2 offsets[4] = vec2[4](vec2(-RADIUS,-RADIUS),vec2(-RADIUS,0.),vec2(0.,-RADIUS),vec2(0.,0.));\n  \n  \n  for(int i = 0;i<4;i++){\n      for(int j =0; j<= RADIUS; j++){\n          for(int k = 0;k<=RADIUS;k++){\n          \n          pos = vec2(j,k)+offsets[i];\n          vec2 uvpos = uv+pos/iResolution.xy;\n          col = vec3(texture(iChannel0, uvpos));\n          \n          mean[i] +=col;\n          sigma[i] += col*col;\n          \n          }\n      \n      }\n  \n  }\n  \n  float n = (float(RADIUS)+1.)*(float(RADIUS)+1.);\n  \n  float sigma_f;\n  \n  float min = 1.;\n  \n  \n  for(int i =0;i<4;i++){\n  \n      mean[i] /= n;\n      sigma[i] = abs(sigma[i]/n - mean[i] * mean[i]);\n      sigma_f = sigma[i].r+sigma[i].g+sigma[i].b;\n      \n      if(sigma_f< min){\n          \n          min = sigma_f;\n          col = mean[i];\n      \n      }\n      \n  \n  }\n\n\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n\n    vec3 f_col;\n    \n    \n    \n    float offsett = (sin(iTime)+1.)/2.;\n    float side = floor(uv.r+offsett);\n    f_col = mix(DirectionalKuwahara(uv),SimpleKuwahara(uv),side);\n    \n    \n    fragColor = vec4(f_col,1.0);\n}","name":"Image","description":"","type":"image"}]}