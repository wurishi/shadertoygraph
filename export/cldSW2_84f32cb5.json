{"ver":"0.1","info":{"id":"cldSW2","date":"1685790712","viewed":56,"name":"Fork Snufffffff (Morning Glory)","username":"voodoovoid","description":"Enjoying @Braek's music","likes":0,"published":1,"flags":64,"usePreview":0,"tags":["light","beats"],"hasliked":0,"parentid":"DttSW2","parentname":"Snuffffffffff"},"renderpass":[{"inputs":[{"id":"lstGz4","filepath":"https://soundcloud.com/braekkkkkk/crunch-snuff-braek-flip","previewfilepath":"https://soundcloud.com/braekkkkkk/crunch-snuff-braek-flip","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n// Mapping function to interpolate a value from one range into another range\nfloat map(float value, float inputMin, float inputMax, float outputMin, float outputMax) {\n    return outputMin + ((value - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin);\n}\n\n// Pseudo-random number generator\nfloat random(in float x) {\n    return fract(sin(x)*43758.5453);\n}\n\nvec3 colorGradient(float t) {\n    vec3 lightPink = vec3(1.0, 0.71, 0.76);\n    vec3 gold = vec3(1.0, 0.84, 0.0);\n    vec3 azure = vec3(0.0, 0.5, 1.0);\n    vec3 deepBlue = vec3(0.0, 0.0, 0.8);\n\n    float gradientPos = sin(t);\n\n    // Blend the colors of the gradient based on the position\n    if (gradientPos < 0.25)\n        return mix(lightPink, gold, map(gradientPos, 0.0, 0.25, 0.0, 1.0));\n    else if (gradientPos < 0.50)\n        return mix(gold, azure, map(gradientPos, 0.25, 0.50, 0.0, 1.0));\n    else if (gradientPos < 0.75)\n        return mix(azure, deepBlue, map(gradientPos, 0.50, 0.75, 0.0, 1.0));\n    else\n        return mix(deepBlue, lightPink, map(gradientPos, 0.75, 1.0, 0.0, 1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    // Rotate uv coordinates by 90 degrees to the right\n    uv = mat2(0.0, 1.0, -1.0, 0.0) * uv;\n    \n    float zoom = pow(2.0, sin(iTime*0.1));\n    uv /= zoom;\n    \n    float radius = length(uv);\n    float angle = atan(uv.y, uv.x);\n    \n    float mandala = 0.0;\n    \n    // Get sound data\n    vec4 sound = texture(iChannel0, vec2(uv.x, 0.0));\n    float bass = sound.x; // Lower frequencies (bass) are in the earlier parts of the FFT data\n\n    float time = iTime * 10.05;\n    float arms = 16.0 + sin(time)*8.0 + bass*16.0; // Modify the number of arms based on bass data\n\n    // Add randomness to the number of arms\n    arms += random(iTime);\n    \n    angle += time + sin(time)*PI/arms;\n    \n    for(float i = 0.0; i < 6.0; i++) {\n        float pattern = mod(angle * zoom + i*PI/3.0, PI/arms) * arms/PI;\n        pattern = abs(1.0 - pattern);\n        \n        pattern *= sin(radius*20.0 - iTime*0.5 + bass*20.0); // Modify the radius based on bass data\n        \n        radius = pow(radius, map(sin(time), -1.0, 1.0, 0.8, 1.2));\n        pattern *= exp(-radius);\n        \n        mandala += pattern;\n    }\n    \n    // Adjust color according to mandala value and gradient\n    vec3 color = colorGradient(mandala);\n    color *= mandala;\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}