{"ver":"0.1","info":{"id":"ft3Sz7","date":"1647702696","viewed":242,"name":"Purkinje Shift","username":"_marcussvensson","description":"Simulating Purkinjie Shift using a method described in \"Rod Contributions to Color Perception: Linear with Rod Contrast\" by Cao et al. Idea from \"Real-Time Samurai Cinema\" by Jasmin Patry.\n\nNot certain whether I've gotten it right yet...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["purkinjeshift"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 color_sweep(vec2 uv)\n{\n    const vec3 colors[] = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(1.0, 1.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 1.0, 1.0),\n        vec3(0.0, 0.0, 1.0),\n        vec3(1.0, 0.0, 1.0),\n        vec3(1.0, 0.0, 0.0)\n    );\n    const int num_colors = 7;\n    const int num_rows = 19;\n    const int num_cols = 50;\n    \n    int row_index = clamp(int((1.0 - uv.y) * float(num_rows)), 0, num_rows - 1);\n    float row_factor = float(row_index) / float(num_rows - 1);\n    \n    float index = row_factor * float(num_colors - 1);\n    float t = fract(index);\n    int index_0 = clamp(int(index), 0, num_colors - 1);\n    int index_1 = clamp(index_0 + 1, 0, num_colors - 1);\n    vec3 color = colors[index_0] * (1.0 - t) + colors[index_1] * t;\n    \n    int col_index = clamp(int(uv.x * float(num_cols)), 0, num_cols - 1);\n    float col_factor = float(col_index) / float(num_cols - 1);\n    color *= vec3(exp2((col_factor - 1.0) * 10.0));\n    \n    return color;\n}\n\n// https://advances.realtimerendering.com/s2021/jpatry_advances2021/index.html\n// https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.9608&rep=rep1&type=pdf\nvec4 rgb_to_lmsr(vec3 c)\n{\n    const mat4x3 m = mat4x3(\n        0.31670331, 0.70299344, 0.08120592, \n        0.10129085, 0.72118661, 0.12041039, \n        0.01451538, 0.05643031, 0.53416779, \n        0.01724063, 0.60147464, 0.40056206);\n    return c * m;\n}\nvec3 lms_to_rgb(vec3 c)\n{\n    const mat3 m = mat3(\n         4.57829597, -4.48749114,  0.31554848, \n        -0.63342362,  2.03236026, -0.36183302, \n        -0.05749394, -0.09275939,  1.90172089);\n    return c * m;\n}\n\n// https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2630540/pdf/nihms80286.pdf\nvec3 apply_purkinje_shift(vec3 c)\n{\n    const vec3 m = vec3(0.63721, 0.39242, 1.6064);\n    const float K = 45.0;\n    const float S = 10.0;\n    const float k3 = 0.6;\n    const float k5 = 0.2;\n    const float k6 = 0.29;\n    const float rw = 0.139;\n    const float p = 0.6189;\n    \n    vec4 lmsr = rgb_to_lmsr(c);\n    \n    vec3 g = vec3(1.0) / sqrt(vec3(1.0) + (vec3(0.33) / m) * (lmsr.xyz + vec3(k5, k5, k6) * lmsr.w));\n    \n    float rc_gr = (K / S) * ((1.0 + rw * k3) * g.y / m.y - (k3 + rw) * g.x / m.x) * k5 * lmsr.w;\n    float rc_by = (K / S) * (k6 * g.z / m.z - k3 * (p * k5 * g.x / m.x + (1.0 - p) * k5 * g.y / m.y)) * lmsr.w;\n    float rc_lm = K * (p * g.x / m.x + (1.0 - p) * g.y / m.y) * k5 * lmsr.w;\n    \n    vec3 lms_gain = vec3(-0.5 * rc_gr + 0.5 * rc_lm, 0.5 * rc_gr + 0.5 * rc_lm, rc_by + rc_lm);\n    vec3 rgb_gain = lms_to_rgb(lms_gain);\n    \n    return c + rgb_gain;\n}\n\nfloat luminance(vec3 c)\n{\n    return dot(c, vec3(0.2126390059, 0.7151686788, 0.0721923154));\n}\nvec3 tonemap(vec3 c)\n{\n    float luminance = luminance(c);\n    float tonemapped_luminance = 1.0 - exp(-luminance);\n    return c * vec3(tonemapped_luminance / luminance);\n}\n\nvec3 linear_to_srgb(vec3 c)\n{\n    const float yb = pow(0.055 * 2.4 / ((2.4 - 1.0) * (1.0 + 0.055)), 2.4);\n\tconst float rs = pow((2.4 - 1.0) / 0.055, 2.4 - 1.0) * pow((1.0 + 0.055) / 2.4, 2.4);\n    return vec3(\n        (c.x >= yb) ? ((1.0 + 0.055) * pow(c.x, 1.0 / 2.4) - 0.055) : (c.x * rs),\n        (c.y >= yb) ? ((1.0 + 0.055) * pow(c.y, 1.0 / 2.4) - 0.055) : (c.y * rs),\n        (c.z >= yb) ? ((1.0 + 0.055) * pow(c.z, 1.0 / 2.4) - 0.055) : (c.z * rs));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Color sweep\n    vec3 col = color_sweep(uv);\n    \n    // Apply purkinje shift\n    if (iMouse.z < 0.5)\n    {\n        col = apply_purkinje_shift(col);\n    }\n    \n    // Tonemap\n    col = tonemap(col);\n    \n    // Linear -> sRGB\n    col = linear_to_srgb(col);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}