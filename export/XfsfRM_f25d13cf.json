{"ver":"0.1","info":{"id":"XfsfRM","date":"1723517190","viewed":48,"name":"ZH3 + L1 Quantization Example","username":"vertver","description":"Example usage of ZH3 with non-negative function quantization packing (reference - https://www.activision.com/cdn/research/Tighter_Quantization_Bound.pdf)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics","sh","zonalharmonics","i3d24"],"hasliked":0,"parentid":"Xfj3RK","parentname":"ZH3: Quadratic Zonal Harmonics"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ZH3: Quadratic Zonal Harmonics, i3D 2024\n// http://torust.me/ZH3.pdf\n// Thomas Roughton, Peter-Pike Sloan, Ari Silvennoinen, Michal Iwanicki, and Peter Shirley; Activision Research.\n//\n// This ShaderToy compares linear SH and quadratic SH irradiance reconstruction\n// with both hallucinated and computed/stored ZH3.\n//\n// Images are: [Linear SH]     [ZH3 (Hallucinated)]    [ZH3 (Hallucinated) (Lum Axis)]              \n//             [Quadratic SH]  [ZH3 (Computed)]        [ZH3 (Computed) (Lum Axis)]   \n// [Quadratic SH] in the bottom-left is the reference. \n//\n// Mouse X (phi) and Y (theta) control the camera direction in world space.\n//\n// The choice of environment map is given by the 'environment' variable on line 86. \n\nconst bool drawBackground = false; // Whether to draw the SH radiance behind the probes.\n\n// St Peter's Basilica: https://www.pauldebevec.com/Probes/, \n// with SH coefficients from https://www.shadertoy.com/view/Mt23zW.\nconst vec3 stpeter[9] = vec3[](\n    8.0 * vec3( 0.3623915,  0.2624130,  0.2326261 ),\n    8.0 * vec3( 0.1759131,  0.1436266,  0.1260569 ),\n    8.0 * vec3(-0.0247311, -0.0101254, -0.0010745 ),\n    8.0 * vec3( 0.0346500,  0.0223184,  0.0101350 ),\n    8.0 * vec3( 0.0198140,  0.0144073,  0.0043987 ),\n    8.0 * vec3(-0.0469596, -0.0254485, -0.0117786 ),\n    8.0 * vec3(-0.0898667, -0.0760911, -0.0740964 ),\n    8.0 * vec3( 0.0050194,  0.0038841,  0.0001374 ),\n    8.0 * vec3(-0.0818750, -0.0321501,  0.0033399 ) \n);\n\n// Pisa Courtyard: https://vgl.ict.usc.edu/Data/HighResProbes/\nconst vec3 pisa[9] = vec3[](\n    vec3( 0.732668,  0.610310,  0.585349),\n    vec3(-0.506687, -0.417720, -0.429780),\n    vec3(-0.031983, -0.252292, -0.411999),\n    vec3( 0.103438,  0.139038,  0.167152),\n    vec3(-0.102849, -0.141602, -0.169318),\n    vec3(-0.038356,  0.214884,  0.408204),\n    vec3( 0.119999,  0.129040,  0.123580),\n    vec3( 0.009767, -0.113339, -0.185314),\n    vec3(-0.017577,  0.000823, -0.014609)\n);\n\n// Ennis-Brown House Dining Room: https://vgl.ict.usc.edu/Data/HighResProbes/\nconst vec3 ennis[9] = vec3[](\n    0.2 * vec3( 4.531689,  4.308981,  4.520285),\n    0.2 * vec3(-1.057496, -1.336207, -1.825209),\n    0.2 * vec3(-6.188428, -6.201931, -6.694056),\n    0.2 * vec3(-0.407847, -0.405074, -0.416838),\n    0.2 * vec3( 0.179401,  0.180498,  0.212682),\n    0.2 * vec3( 2.653277,  2.971460,  3.824151),\n    0.2 * vec3( 7.051956,  6.934999,  7.286222),\n    0.2 * vec3( 0.795407,  0.720389,  0.719510),\n    0.2 * vec3( 0.079124, -0.100926, -0.384239)\n);\n\n// Uffizi: https://vgl.ict.usc.edu/Data/HighResProbes/\nconst vec3 uffizi[9] = vec3[](\n    (1.0 / 3.0) * vec3( 3.171716,  3.076861,  3.500972),\n    (1.0 / 3.0) * vec3(-3.701456, -3.673000, -4.282978),\n    (1.0 / 3.0) * vec3(-0.077917, -0.080867, -0.109681),\n    (1.0 / 3.0) * vec3( 0.027043,  0.024597,  0.031224),\n    (1.0 / 3.0) * vec3(-0.095452, -0.088531, -0.102552),\n    (1.0 / 3.0) * vec3( 0.181852,  0.183784,  0.241100),\n    (1.0 / 3.0) * vec3(-0.697054, -0.708923, -0.866909),\n    (1.0 / 3.0) * vec3(-0.005508, -0.003777, -0.002297),\n    (1.0 / 3.0) * vec3(-3.610548, -3.575409, -4.168227)\n);\n\n// A production probe with ZH3 color fringing issues\n// if the shared luminance axis isn't used.\n// (The fringing is much more prominent when \n// the zonal axis/linear coeffs are solved for).\nconst vec3 productionProbe[9] = vec3[](\n    vec3( 1.063877,  1.005969,  1.139061),\n    vec3(-0.171134, -0.102052, -0.025571),\n    vec3( 0.004089,  0.148585,  0.437148),\n    vec3(-0.358268, -0.343352, -0.371353),\n    vec3(-0.277614, -0.279779, -0.313043),\n    vec3( 0.514214,  0.427734,  0.360189),\n    vec3(-0.084615, -0.073269, -0.032683),\n    vec3(-0.362233, -0.387163, -0.451868),\n    vec3( 0.149837,  0.170355,  0.221346)\n);\n\nconst vec3 environment[9] = pisa;\n\nconst float PI = 3.141592653589793;\n\n// Luminance of a colour using sRGB coefficients.\nfloat Color_Luminance(vec3 color) {\n    return dot(color, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\n// Evaluate linear SH in a direction.\nvoid SH2_InDirection(vec3 direction, out float sh[4]) {\n     sh[0] = 0.5 * sqrt(1.0 / PI);\n        \n     sh[1] = -sqrt(0.75 / PI) * direction.y;\n     sh[2] = sqrt(0.75 / PI) * direction.z;\n     sh[3] = -sqrt(0.75 / PI) * direction.x;\n}\n\n// Evaluate quadratic SH in a direction.\nvoid SH3_InDirection(vec3 direction, out float sh[9]) {\n     sh[0] = 0.5 * sqrt(1.0 / PI);\n        \n     sh[1] = -sqrt(0.75 / PI) * direction.y;\n     sh[2] = sqrt(0.75 / PI) * direction.z;\n     sh[3] = -sqrt(0.75 / PI) * direction.x;\n     \n     sh[4] = 0.5 * sqrt(15.0 / PI) * direction.x * direction.y;\n     sh[5] = -0.5 * sqrt(15.0 / PI) * direction.y * direction.z;\n     sh[6] = 0.25 * sqrt(5.0 / PI) * (-1.0 + 3.0 * direction.z * direction.z);\n     sh[7] = -0.5 * sqrt(15.0 / PI) * direction.z * direction.x;\n     sh[8] = 0.25 * sqrt(15.0 / PI) * (direction.x * direction.x - direction.y * direction.y);\n}\n\n// Convolve linear SH with a normalized cosine lobe to produce an irradiance function.\nvoid SH2_ConvCos(inout float sh[4]) {\n    sh[0] *= 1.0;\n    \n    sh[1] *= 2.0 / 3.0;\n    sh[2] *= 2.0 / 3.0;\n    sh[3] *= 2.0 / 3.0;\n}\n\n// Convolve quadratic SH with a normalized cosine lobe to produce an irradiance function.\nvoid SH3_ConvCos(inout float sh[9]) {\n    sh[0] *= 1.0;\n    \n    sh[1] *= 2.0 / 3.0;\n    sh[2] *= 2.0 / 3.0;\n    sh[3] *= 2.0 / 3.0;\n    \n    sh[4] *= 0.25;\n    sh[5] *= 0.25;\n    sh[6] *= 0.25;\n    sh[7] *= 0.25;\n    sh[8] *= 0.25;\n}\n\n// Dot two linear SH vectors, used for reconstructing c in the direction given by sh.\nfloat SH2_Dot(float c[4], float sh[4]) {\n    float result = 0.0;\n    \n    for (int i = 0; i < 4; i += 1) {\n        result += c[i] * sh[i];\n    }\n    \n    return result;\n}\n\n// Dot two linear SH vectors, used for reconstructing c in the direction given by sh.\nvec3 SH2_Dot(vec3 c[4], float sh[4]) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < 4; i += 1) {\n        result += c[i] * sh[i];\n    }\n    \n    return result;\n}\n\n// Dot two quadratic SH vectors, used for reconstructing c in the direction given by sh.\nfloat SH3_Dot(float c[9], float sh[9]) {\n    float result = 0.0;\n    \n    for (int i = 0; i < 9; i += 1) {\n        result += c[i] * sh[i];\n    }\n    \n    return result;\n}\n\n// Dot two quadratic SH vectors, used for reconstructing c in the direction given by sh.\nvec3 SH3_Dot(vec3 c[9], float sh[9]) {\n    vec3 result = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < 9; i += 1) {\n        result += c[i] * sh[i];\n    }\n    \n    return result;\n}\n\n// Extract the zonal L2 SH coefficient in the direction N. \nfloat SH_ExtractL2Zonal(float sh[9], vec3 N) {\n    float inDirection[9];\n    SH3_InDirection(N, inDirection);\n    \n    float s = 0.0;\n    for (int i = 4; i < 9; i += 1) {\n        s += inDirection[i] * sh[i];\n    }\n    \n    s /= 0.5 * sqrt(5.0 / PI);\n\n    return s;\n}\n\n// Extract the zonal L2 SH coefficient in the direction N.\nvec3 SH_ExtractL2Zonal(vec3 sh[9], vec3 N) {\n    float inDirection[9];\n    SH3_InDirection(N, inDirection);\n    \n    vec3 s = vec3(0.0);\n    for (int i = 4; i < 9; i += 1) {\n        s += inDirection[i] * sh[i];\n    }\n    \n    s /= 0.5 * sqrt(5.0 / PI);\n\n    return s;\n}\n\n// Evaluate irradiance in direction nor from the linear SH env.\nfloat SH2_EvalIrradiance(float env[4], vec3 nor) {\n    float shDir[4];\n    SH2_InDirection(nor, shDir);\n    \n    SH2_ConvCos(shDir);\n    return SH2_Dot(env, shDir);\n}\n\n// Evaluate irradiance in direction nor from the linear SH env.\nvec3 SH2_EvalIrradiance(vec3 env[4], vec3 nor) {\n    float shDir[4];\n    SH2_InDirection(nor, shDir);\n    \n    SH2_ConvCos(shDir);\n    return SH2_Dot(env, shDir);\n}\n\n// Evaluate radiance in direction nor from the quadratic SH env.\nvec3 SH3_EvalRadiance(vec3 env[9], vec3 nor) {\n    float shDir[9];\n    SH3_InDirection(nor, shDir);\n    \n    return SH3_Dot(env, shDir);\n}\n\n// Evaluate irradiance in direction nor from the quadratic SH env.\nvec3 SH3_EvalIrradiance(vec3 env[9], vec3 nor) {\n    float shDir[9];\n    SH3_InDirection(nor, shDir);\n    \n    SH3_ConvCos(shDir);\n    return SH3_Dot(env, shDir);\n}\n\n// Evaluate irradiance in direction normal from the quadratic SH sh,\n// extracting the ZH3 coefficient and then using that and linear SH\n// for reconstruction.\nfloat ZH3_EvalIrradiance(float sh[9], vec3 normal) {\n    vec3 zonalAxis = normalize(vec3(-sh[3], -sh[1], sh[2]));\n    \n    float zonalL2Coeff = SH_ExtractL2Zonal(sh, zonalAxis); // Usually this would be passed in instead of the quadratic SH.\n    \n    float fZ = dot(zonalAxis, normal);\n    float zhNormal = sqrt(5.0f / (16.0f * PI)) * (3.0f * fZ * fZ - 1.0f);\n\n    float linearSH[4] = float[](sh[0], sh[1], sh[2], sh[3]);\n    float result = SH2_EvalIrradiance(linearSH, normal);\n    result += 0.25f * zhNormal * zonalL2Coeff;\n    return result;\n}\n\n// Evaluate irradiance in direction normal from the quadratic SH sh,\n// extracting the ZH3 coefficient and then using that and linear SH\n// for reconstruction.\nvec3 ZH3_EvalIrradiance(vec3 sh[9], vec3 normal) {\n    vec3 result = vec3(0.0);\n    for (int c = 0; c < 3; c += 1) {\n        float shChannel[9];\n        for (int i = 0; i < 9; i += 1) {\n            shChannel[i] = sh[i][c];\n        }\n        \n        result[c] = ZH3_EvalIrradiance(shChannel, normal);\n    }\n    return result;\n}\n\n// Evaluate irradiance in direction normal from the quadratic SH sh,\n// computing a shared luminance axis from the linear components,\n// extracting the ZH3 coefficienst along that axis,\n// and then using ZH3 and linear SH for reconstruction in the direction normal.\nvec3 ZH3_EvalIrradianceLumAxis(vec3 sh[9], vec3 normal) {\n    vec3 zonalAxis = normalize(vec3(-Color_Luminance(sh[3]), -Color_Luminance(sh[1]), Color_Luminance(sh[2])));\n    \n    vec3 zonalL2Coeff = SH_ExtractL2Zonal(sh, zonalAxis); // Usually this would be passed in instead of the quadratic SH.\n    \n    float fZ = dot(zonalAxis, normal);\n    float zhNormal = sqrt(5.0f / (16.0f * PI)) * (3.0f * fZ * fZ - 1.0f);\n\n    vec3 linearSH[4] = vec3[](sh[0], sh[1], sh[2], sh[3]);\n    vec3 result = SH2_EvalIrradiance(linearSH, normal);\n    result += 0.25f * zhNormal * zonalL2Coeff;\n    return result;\n}\n\n\n// Evaluate irradiance in direction normal from the linear SH sh,\n// hallucinating the ZH3 coefficient and then using that and linear SH\n// for reconstruction.\nfloat ZH3Hallucinate_EvalIrradiance(float sh[4], vec3 normal) {\n    vec3 zonalAxis = vec3(-sh[3], -sh[1], sh[2]);\n    float l1Length = length(zonalAxis);\n    zonalAxis /= l1Length;\n\n    float ratio = l1Length / sh[0];\n\tfloat zonalL2Coeff = sh[0] * ratio * (0.08 + 0.6 * ratio); // Curve-fit.\n    \n    float fZ = dot(zonalAxis, normal);\n    float zhNormal = sqrt(5.0f / (16.0f * PI)) * (3.0f * fZ * fZ - 1.0f);\n    \n    float result = SH2_EvalIrradiance(sh, normal);\n    result += 0.25f * zhNormal * zonalL2Coeff;\n    return result;\n}\n\n// Evaluate irradiance in direction normal from the linear SH sh,\n// hallucinating the ZH3 coefficient and then using that and linear SH\n// for reconstruction.\nvec3 ZH3Hallucinate_EvalIrradiance(vec3 sh[4], vec3 normal) {\n    vec3 result = vec3(0.0);\n    result.r = ZH3Hallucinate_EvalIrradiance(float[](sh[0].r, sh[1].r, sh[2].r, sh[3].r), normal);\n    result.g = ZH3Hallucinate_EvalIrradiance(float[](sh[0].g, sh[1].g, sh[2].g, sh[3].g), normal);\n    result.b = ZH3Hallucinate_EvalIrradiance(float[](sh[0].b, sh[1].b, sh[2].b, sh[3].b), normal);\n    return result;\n}\n\n// Evaluate irradiance in direction normal from the linear SH sh,\n// computing a shared luminance axis from the linear components,\n// hallucinating the ZH3 coefficients along that axis,\n// and then using ZH3 and linear SH for reconstruction in the direction normal.\nvec3 ZH3Hallucinate_EvalIrradianceLumAxis(vec3 sh[4], vec3 normal) {\n    vec3 zonalAxis = normalize(vec3(-Color_Luminance(sh[3]), -Color_Luminance(sh[1]), Color_Luminance(sh[2])));\n\n    vec3 ratio = vec3(0.0);\n    ratio.r = dot(vec3(-sh[3].r, -sh[1].r, sh[2].r), zonalAxis);\n    ratio.g = dot(vec3(-sh[3].g, -sh[1].g, sh[2].g), zonalAxis);\n    ratio.b = dot(vec3(-sh[3].b, -sh[1].b, sh[2].b), zonalAxis);\n    ratio /= sh[0];\n    ratio = abs(ratio);\n\n\tvec3 zonalL2Coeff = sh[0] * ratio * (0.08 + 0.6 * ratio); // Curve-fit.\n    \n    float fZ = dot(zonalAxis, normal);\n    float zhNormal = sqrt(5.0f / (16.0f * PI)) * (3.0f * fZ * fZ - 1.0f);\n\n    vec3 result = SH2_EvalIrradiance(sh, normal);\n    result += 0.25f * zhNormal * zonalL2Coeff;\n    return result;\n}\n\n// pack 4 floating point numbers that are in [-1,1] to be in [0,2*bitVal], optionally computing a sqrt, store in a uint\nuint Pack4( in vec4 v, in float bv, bool isSqrt )\n{\n    if ( isSqrt ) v = sign(v)*sqrt(abs(v));\n    v = vec4(bv+0.5f, bv+0.5f, bv+0.5f, bv+0.5f ) + v * bv; // round\n    return uint(v.x) | (uint(v.y) << 8) | (uint(v.z) << 16) | (uint(v.w) << 24);\n}\n\nvoid CompressSH2( in float sh[9], in int bits, in float nonZbound, in bool isSqrt, in bool isIrrad, out uint bo[2] )\n{\n    float bv = float((1<<(bits-1))) - 1.0f;\n    float lc = 1.0f/(sh[0] * sqrt(3.0f) * (isIrrad?2.0f/3.0f:1.0f));\n    float qz = 1.0f/(sh[0] * sqrt(5.0f) * (isIrrad?0.25f:1.0f));\n    float nz = 1.0f/(sh[0] * nonZbound * (isIrrad?0.25f:1.0f));\n\n    bo[0] = Pack4( vec4(sh[1],sh[2],sh[3],sh[4]) * vec4(lc,lc,lc,nz), bv, isSqrt );\n    bo[1] = Pack4( vec4(sh[5],sh[6],sh[7],sh[8]) * vec4(nz,qz,nz,nz), bv, isSqrt );\n}\n\n// unpack the results from pack4 - squaring on reconstruction\nvec4 Unpack4( in uint r, in float bv, bool isSqrt )\n{\n    const uint m8 = 0xFFu;\n    vec4 tmp = vec4(r&m8, (r>>8)&m8, (r>>16)&m8, (r>>24) )/bv;\n    tmp -= vec4(1.0f,1.0f,1.0f,1.0f);    \n    if ( isSqrt ) tmp = sign(tmp)*(tmp*tmp);\n    return tmp;\n}\n\nvoid UncompressSH2( in uint shBits[2], in float DC, in int bits, in float nonZbound, in bool isSqrt, in bool isIrrad, out float shOut[9])\n{\n    float bv = float((1<<(bits-1))) - 1.0f;\n    float lc = DC * sqrt(3.0f) * (isIrrad?2.0f/3.0f:1.0f);\n    float qz = DC * sqrt(5.0f) * (isIrrad?0.25f:1.0f);\n    float nz = DC * nonZbound * (isIrrad?0.25f:1.0f);\n    vec4 shA = Unpack4( shBits[0], bv, isSqrt) * vec4(lc,lc,lc,nz);\n    vec4 shB = Unpack4( shBits[1], bv, isSqrt) * vec4(nz,qz,nz,nz);;\n\n    shOut[0] = DC;\n    shOut[1] = shA.x; shOut[2] = shA.y; shOut[3] = shA.z; shOut[4] = shA.w;\n    shOut[5] = shB.x; shOut[6] = shB.y; shOut[7] = shB.z; shOut[8] = shB.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragCoord.y = iResolution.y - fragCoord.y;\n    \n    float phi = 2.0 * PI * iMouse.x / iResolution.x - PI;\n    float theta = clamp(PI * iMouse.y / iResolution.y, 0.001, PI - 0.001);\n    float sinTheta = sin(theta);\n    vec3 forward = vec3(sinTheta * cos(phi), cos(theta), sinTheta * sin(phi));\n    \n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = cross(right, forward);\n    mat3 cam = mat3(right, up, forward);\n\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(p.x, -p.y, 1.0));   \n    vec3 color = drawBackground ? SH3_EvalRadiance(environment, rd) : vec3(0.0);\n\n    // Boxes.\n    float boxSize = min(iResolution.x / 3.0, iResolution.y / 2.0);\n    const float sphereRadius = 0.47;\n    const float sphereRadiusSq = sphereRadius * sphereRadius;\n    \n    vec2 margin = 0.5 * vec2(iResolution.x - 3.0 * boxSize, iResolution.y - 2.0 * boxSize);\n    vec2 coord = fragCoord - margin;\n    \n    float boxX = floor(coord.x / boxSize);\n    float boxY = floor(coord.y / boxSize);\n    coord.x -= boxX * boxSize;\n    coord.y -= boxY * boxSize;\n    \n    float boxNumber = 2.0 * boxX + boxY;\n    if (clamp(boxX, 0.0, 2.0) != boxX || clamp(boxY, 0.0, 1.0) != boxY) {\n        boxNumber = -1.0;\n    }\n   \n    vec2 uv = coord / boxSize; \n    vec2 spherePoint = (uv - 0.5) / sphereRadius;\n\n    float rSq = dot(spherePoint, spherePoint);\n\n    if (rSq <= 1.0) {\n        vec3 localNormal = vec3(spherePoint.x, -spherePoint.y, -sqrt(1.0 - rSq));\n        vec3 worldNormal = cam * localNormal;\n        \n        if (boxNumber == 0.0) {\n            // Top-left: linear SH.\n            vec3 linearEnv[4] = vec3[](environment[0], environment[1], environment[2], environment[3]);\n            color = SH2_EvalIrradiance(linearEnv, worldNormal);\n        } else if (boxNumber == 1.0) {\n            // Bottom-left: quadratic SH.\n            color = SH3_EvalIrradiance(environment, worldNormal);\n        } else if (boxNumber == 2.0) {\n            // Top-centre: ZH3 hallucinate.\n            float nonZbound = sqrt(4.0f); // change this value to adapt to your env\n            bool isSqrt = false;  \n            bool isIrrad = false; // must be used with irradiance fields\n            bool compress = true; // A/B compression\n            int bits = 4; // up to 8\n            \n            float L1[9] = float[](\n                environment[1].x, environment[1].y, environment[1].z, \n                environment[2].x, environment[2].y, environment[2].z, \n                environment[3].x, environment[3].y, environment[3].z\n            );\n            \n            if (compress) {\n                float DC = L1[0];\n                uint compressedSH[2];\n                CompressSH2(L1, bits, nonZbound, isSqrt, isIrrad, compressedSH);\n                UncompressSH2(compressedSH, DC, bits, nonZbound, isSqrt, isIrrad, L1);\n            }\n            \n            vec3 uncompressedSH[4] = vec3[](\n                environment[0],\n                vec3(L1[0], L1[1], L1[2]),\n                vec3(L1[3], L1[4], L1[5]),\n                vec3(L1[6], L1[7], L1[8])\n            );\n            \n            color = ZH3Hallucinate_EvalIrradiance(uncompressedSH, worldNormal);\n        }  else if (boxNumber == 3.0) {\n            // Bottom-centre: ZH3.\n            color = ZH3_EvalIrradiance(environment, worldNormal);\n        } else if (boxNumber == 4.0) {\n            // Top-right: ZH3 hallucinate lum axis.\n            vec3 linearEnv[4] = vec3[](environment[0], environment[1], environment[2], environment[3]);\n            color = ZH3Hallucinate_EvalIrradianceLumAxis(linearEnv, worldNormal);\n        } else if (boxNumber == 5.0) {\n            // Bottom-right: ZH3 lum axis.\n            color = ZH3_EvalIrradianceLumAxis(environment, worldNormal);\n        } \n    }\n\n\tfragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}