{"ver":"0.1","info":{"id":"ssjfWK","date":"1647149954","viewed":81,"name":"Green Enso","username":"do","description":"enso","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["enso"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//enso\n//2022\n//Dan Olson\n\n//Within imperfection is beauty \n//Even so, there is a path to perfection.\n\n#define FC fragCoord.xy\n#define RE iResolution\n#define T iTime\n\n#define EPS 0.000313\n#define STEPS 75\n#define NEAR 0.\n#define FAR 5.\n\n//zero for no gamma\n#define GAMMA .4545\n\n#define PI radians(180.)\n\nfloat h(float p) {\n    return fract(sin(p)*float(43758.98));\n}\n\nfloat cell(vec3 x,float n) {\n    x *= n;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n \n    float min_dist = 1.0;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            for(int k = -1; k <= 1; k++) { \n\n                vec3 b = vec3(float(k),float(j),float(i));\n                vec3 r = vec3(h(p.x+b.x+h(p.y+b.y+h(p.z+b.z))));\n                \n                vec3 diff = (b + r - f);\n\n                float d = length(diff);\n                min_dist = min(min_dist,d);\n    \n            }\n        }\n    }\n \n    return min_dist;  \n\n}\n\nfloat n3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n    float q = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix(h(q + 0.0),h(q + 1.0),f.x),\n           mix(h(q + 157.0),h(q + 158.0),f.x),f.y),\n           mix(mix(h(q + 113.0),h(q + 114.0),f.x),\n           mix(h(q + 270.0),h(q + 271.0),f.x),f.y),f.z);\n}\n\nfloat expstep(float x,float k) {\n    return exp((x*k)-k);\n}\n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nfloat lv(vec3 p,float d,float h) {\n    vec2 w = vec2(d,abs(p.z) - h);\n    return min(max(w.x,w.y),0.) + length(max(w,0.)); \n} \n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nmat3 camera(vec3 ro,vec3 ta,float r) {\n     \n    vec3 w = normalize(ta - ro); \n    vec3 p = vec3(sin(r),cos(r),0.);           \n    vec3 u = normalize(cross(w,p)); \n    vec3 v = normalize(cross(u,w));\n\n    return mat3(u,v,w); \n}\n\nfloat arc(vec2 p,vec2 sca,vec2 scb,float ra,float rb) {\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(dot(p,p)+ra*ra-2.*ra*k)-rb;\n}\n\nfloat plane(vec3 p,vec4 n) {\n    return dot(p,n.xyz) + n.w;\n}\n\n#define R res = opu(res,vec2(\nvec2 scene(vec3 p) { \n\nvec2 res = vec2(1.0,0.0);\n\nvec3 q = p;\nR plane(q,vec4(0.,1.,0.,1.)),2.));\n\np.xz *= rot(T * .1);\nq.xz *= rot(T * .3);\n\nfloat a = 2.5;\nR lv(p.xzy,arc(q.xz+n3(p+n3(p*.1) )*.5  ,vec2(.5,.5), \nvec2(sin(a),cos(a)),3.25,.5),\n.1),1.));\n\nR length(p-vec3(0.,2.,0.))-1.5,2.)); \n\nreturn res;\n\n}\n\nvec4 trace(vec3 ro,vec3 rd) { \n    float d = -1.0;\n    float s = NEAR;\n    float e = FAR; \n\n    float h = 0.;\n\n    for(int i = 0; i < STEPS; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n        h = 1.;   \n\n        if(abs(dist.x) < EPS || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n\n        }\n\n        if(e < s) { d = -1.0; }\n        return vec4(s,d,h,1.);\n\n}\n\nfloat shadow(vec3 ro,vec3 rd ) {\n    float res = 1.0;\n    float dmax = 124.;\n    float t = 0.5;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 125; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,24. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < EPS || t*rd.y+ro.y > dmax) { break; }\n\n        }\n        return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0,-1.0) * EPS;\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));    \n}\n\nvec3 aces(vec3 x) {\n    return clamp((x*(2.51*x+.03))/(x*(2.43*x+.59)+.14),0.,1.);\n}  \n\nvec3 glow_exp(vec3 c,vec3 rd,vec3 l) {\n    float rad = dot(rd,l);\n    c += c * vec3(2.,1.,.1) * expstep(rad,250.);\n    c += c * vec3(2.,.5,1.) * expstep(rad,125.);  \n    c += c * vec3(1.,.1,.5) * expstep(rad,100.);       \n    c += c * vec3(.5,1.,1.) * expstep(rad,75.);\n    return c;\n}\n\nfloat ambient(vec3 n) {\n    return sqrt(clamp(.5+.5*n.y,0.,1.));\n}\n\nfloat fresnel(vec3 n,vec3 rd) {\n    return pow(clamp(1.+dot(n,rd),0.,1.),2.);    \n}\n\nfloat diffuse(vec3 n,vec3 l) {\n    return clamp(dot(n,l),0.0,1.0);\n} \n\nfloat specular(vec3 n,vec3 rd,vec3 l) {\n    vec3 h = normalize(l-rd);\n    float spe = pow(clamp(dot(n,h),0.0,1.0),16.);\n    spe *= pow(clamp(1.+dot(h,l),0.,1.),5.);\n    return spe;\n}\n\nvec3 linear(vec3 ro,\n            vec3 rd,\n            vec3 n,            \n            vec3 l,           \n            vec4 d\n            ) {\n\n    vec3 p = ro + rd * d.x;\n\n    vec3 linear = vec3(0.);\n\n    float amb = ambient(n);\n    float dif = diffuse(n,l);\n    float spe = specular(n,rd,l);\n    float fre = fresnel(n,rd);   \n  \n    float sh = shadow(p,l);\n         \n    linear += dif * vec3(.5) * sh;\n    linear += amb * vec3(0.01);\n    linear += 1. * fre * vec3(.1);\n    linear += .95 * spe * vec3(1.,.75,.91);                \n\n    return linear;   \n    \n}\n\nvec3 render(vec3 ro,vec3 rd,vec3 l) {\n\n    vec3 c = vec3(0.),\n         fc = vec3(.5);   \n    \n    vec4 d;\n\n    for(int i = 0; i < 3; i++) {\n       d = trace(ro,rd);\n        \n       vec3 p = ro + rd * d.x;\n       vec3 n = calcNormal(p);\n       vec3 r = reflect(rd,n);\n       c += linear(p,rd,n,l,d);\n       ro = p + n * .005;  \n      \n       if(d.y >= 0.) {\n\n            if(d.y == 1.) {\n               c *= vec3(.5,1.,.5);\n               p.xz *= rot(T*.12);           \n               c *= mix(c,vec3(0.,1.,0.),n3(p+n3(p*12. ) ));           \n               c += mix(c,vec3(.1),cell(p,2.));  \n\n           }\n    \n           if(d.y == 2.) {\n               rd = r;   \n               c += vec3(.5);\n           }        \n       }\n       fc *= mix(c,vec3(1.),1. - exp(-.5 * float(i)));\n}\nreturn fc;\n}\n\n\n#define AA 1\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) { \n\nvec3 fc = vec3(0.);\n\nvec3 ta = vec3(0.);\nvec3 ro = vec3(2.,13.,3.);\nvec3 rd = vec3(0.);\nvec3 l = normalize(vec3(34.));\nl.xz *= rot(T*.1);\n\nfor(int i = 0; i < AA; i++ ) {\n   for(int k = 0; k < AA; k++) {\n   \n       vec2 o = vec2(float(i),float(k)) / float(AA) * .5;\n       vec2 uv = (2.* (FC+o) -\n       RE.xy)/RE.y;\n \n       mat3 cm = camera(ro,ta,2.);\n       rd = cm * normalize(vec3(uv.xy,3.));\n       vec4 d = trace(ro,rd);            \n       vec3 p = ro + rd * d.x;\n       vec3 n = calcNormal(p);\n       vec3 c = render(ro,rd,l);\n\n       c *= c + glow_exp(c,rd,l);  \n\n       c = aces(c);\n     \n       c = pow(c,vec3(GAMMA));\n       fc += c;\n   }\n}   \n  \n\n   fc /= float(AA*AA);\n\n   fragColor = vec4(fc,1.0);\n\n\n}\n","name":"Image","description":"","type":"image"}]}