{"ver":"0.1","info":{"id":"mtBcRt","date":"1692152185","viewed":98,"name":"Path Tracing Tutorial for TF 1","username":"MacLin","description":"This is the basic shader for TF","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb, vec3(1.0 / 2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define INFINITY 9999999.0\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON 0.0000001\n\n////////////////////////////////////////////////\n// Random\nint seed;\nint flat_idx;\n\nvoid InitRandom(float iTime)\n{\n\tseed = int(iTime * 100000.0);\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n}\n\nvoid EncryptTea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor (int i = 0; i < 32; i++) \n    {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2 Random2()\n{\n\tuvec2 arg = uvec2(flat_idx, seed++);\n\tEncryptTea(arg);\n\t\n    return fract(vec2(arg) / vec2(0xffffffffu));\n}\n\nfloat Random()\n{\n    return Random2().x;\n}\n\nvec2 Castesian2Spherical(vec3 dir)\n{\n    float theta = acos(dir.y) / -PI;\n    float phi = atan(dir.x, -dir.z) / -PI * 0.5;\n    \n    return vec2(theta, phi);\n}\n\nvec2 RandomInsideUnitCircle()\n{\n    vec2 p;\n    do\n    {\n        p = Random2();\n    }while(length(p)>1.0);\n    \n    return p;\n}\n\nvec3 Spherical2Castesian(float r, float theta, float phi)\n{\n    float st = sin(theta);\n    float ct = cos(theta);\n    float sp = sin(phi);\n    float cp = cos(phi);\n    \n    float x = r * st * cp;\n    float y = r * st * sp;\n    float z = r * ct;\n    \n    return vec3(x, y, z);\n}\n\nvec3 hsv2rgb(float H, float S, float V) \n{\n\tfloat r, g, b;\n\t\n\tfloat h = H;\n\tfloat s = S;\n\tfloat v = V;\n\t\n\tint i = int(floor(h * 6.0));\n\tfloat f = h * 6.0 - float(i);\n\tfloat p = v * (1.0 - s);\n\tfloat q = v * (1.0 - f * s);\n\tfloat t = v * (1.0 - (1.0 - f) * s);\n\t\n\tswitch (i % 6) \n    {\n\t\tcase 0: r = v, g = t, b = p; break;\n\t\tcase 1: r = q, g = v, b = p; break;\n\t\tcase 2: r = p, g = v, b = t; break;\n\t\tcase 3: r = p, g = q, b = v; break;\n\t\tcase 4: r = t, g = p, b = v; break;\n\t\tcase 5: r = v, g = p, b = q; break;\n\t}\n\t\n\tvec3 color;\n\tcolor.r = r;\n\tcolor.g = g;\n\tcolor.b = b;\n\t\n\treturn color;\n}\n\nvec3 ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax)\n{\n    float value = Random();\n    \n    float h = mix(hueMin, hueMax, value);\n    float s = mix(saturationMin, saturationMax, value);\n    float v = mix(valueMin, valueMax, value);\n    \n    vec3 result;\n    result = hsv2rgb(h, s, v);\n    return result;\n}\n\nvec3 ColorHSV()\n{\n    return ColorHSV(0.0, 1.0, 0.0, 1.0, 0.0, 1.0);\n}\n\nfloat sdot(vec3 x, vec3 y, float f)\n{\n    return clamp(dot(x, y) * f, 0.0, 1.0);\n}\n\nbool anyNonZero(vec3 c)\n{\n    return c.x!=0. || c.y!=0. || c.z!=0.;\n}\n\nbool allNonZero(vec3 c)\n{\n    return c.x!=0. && c.y!=0. && c.z!=0.;\n}\n\nfloat energy(vec3 color)\n{\n    return 0.257 * color.x + 0.504 * color.y + 0.098 * color.z;\n}\n\nmat4 calculateLookAtMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    mat4 lookAtMatrix;\n    \n    vec3 zaxis = normalize(center - eye);\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n\n    lookAtMatrix[0][0] = xaxis.x;\n    lookAtMatrix[0][1] = yaxis.x;\n    lookAtMatrix[0][2] = zaxis.x;\n\n    lookAtMatrix[1][0] = xaxis.y;\n    lookAtMatrix[1][1] = yaxis.y;\n    lookAtMatrix[1][2] = zaxis.y;\n\n    lookAtMatrix[2][0] = xaxis.z;\n    lookAtMatrix[2][1] = yaxis.z;\n    lookAtMatrix[2][2] = zaxis.z;\n\n    lookAtMatrix[3][0] = dot(xaxis, -eye);\n    lookAtMatrix[3][1] = dot(yaxis, -eye);\n    lookAtMatrix[3][2] = dot(zaxis, -eye);\n\n    lookAtMatrix[3][3] = 1.0;\n    \n    return lookAtMatrix;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_DOWN(key)   (texture(iChannel2, vec2((float(key+1) + 0.5)/256.0, (0.0 + 0.5)/3)).r == 0)\n#define KEY_CLICK(key)  (texture(iChannel2, vec2((float(key+1) + 0.5)/256.0, (1.0 + 0.5)/3)).r == 0)\n#define KEY_TOGGLE(key) (texture(iChannel2, vec2((float(key+1) + 0.5)/256.0, (2.0 + 0.5)/3)).r == 0)\n\nconst vec2 acc_start_coord       = vec2(0, 0);\nconst vec2 metallic_coord        = vec2(1, 0);\nconst vec2 camerapos_coord       = vec2(2, 0);\n\nint getStartFrame()\n{\n    return int(texture(iChannel0, (acc_start_coord + vec2(0.5, 0.5)) / iResolution.xy).r);\n}\n\nfloat getMetallic()\n{\n    return texture(iChannel0, (metallic_coord + vec2(0.5, 0.5)) / iResolution.xy).r;\n}\n\nfloat getRougness()\n{\n    return texture(iChannel0, (metallic_coord + vec2(0.5, 0.5)) / iResolution.xy).g;\n}\n\nvec3 OutputColor(vec3 color, in vec2 fragCoord)\n{\n// \t    if(iMouse.z > 0.0 || KEY_DOWN('r') || KEY_DOWN('f') || KEY_DOWN('t') || KEY_DOWN('g'))\n    if(all(equal(floor(fragCoord.xy).xy, acc_start_coord)))\n    {\n\t    if(iMouse.z > 0.0 )\n            return vec3(iFrame);    // save Start Frame in pixel\n        else \n            return vec3(getStartFrame()); // return Start Frame in pixel\n    }\n    /*\n    else if(all(equal(floor(fragCoord.xy).xy, camerapos_coord)))\n    {\n        vec3 cameraPos = getCameraPos();\n\n        if(iFrame==0)\n        {\n            cameraPos = vec3(50.0, 40.8, 172.0);\n        }\n\n\t    if(KEY_DOWN('w'))\n        {\n            cameraPos += getViewDir();\n        }\n\t    else if(KEY_DOWN('s'))\n        {\n            cameraPos -= getViewDir();\n        }\n\n        return cameraPos;\n    }\n    else if(all(equal(floor(fragCoord.xy).xy, metallic_coord)))\n    {\n        float metallic = getMetallic();\n\t    if(KEY_DOWN('r'))\n        {\n            metallic += 0.001;\n            if(metallic > 1.0)\n                metallic = 1.0;\n        }\n\t    else if(KEY_DOWN('f'))\n        {\n            metallic -= 0.001;\n            if(metallic < 0.0)\n                metallic = 0.0;\n        }\n\n        float roughness = getMetallic();\n\t    if(KEY_DOWN('t'))\n        {\n            roughness += 0.001;\n            if(roughness > 1.0)\n                roughness = 1.0;\n        }\n\t    else if(KEY_DOWN('g'))\n        {\n            roughness -= 0.001;\n            if(roughness < 0.0)\n                roughness = 0.0;\n        }\n        \n        return vec3(metallic, roughness, 1.0);\n    }\n    */\n    else\n    {\n        int frame = iFrame - getStartFrame();\n        \n        vec3 oldcolor = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n        \n        color = oldcolor * float(frame) / float(frame + 1) + color / float(frame + 1);\n\n        return color;\n    }\n}\n\n\n////////////////////////////////////////////////////////////////\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    vec3 energy;\n};\n\nstruct RayHit\n{\n    vec3 position;\n    float t;\n    vec3 normal;\n    vec3 albedo;\n    vec3 specular;\n    float smoothness;\n    vec3 emission;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    \n    vec3 albedo;\n    vec3 specular;\n    float smoothness;\n    vec3 emission;\n};\n\n#define NUM_SPHERES 30\nSphere spheres[NUM_SPHERES] = Sphere[]\n(\n    Sphere(vec3(1.156948, 1.093681, -7.140715), 1.093681, vec3(0, 0, 0), vec3(0.2936478, 0.197123, 0.7239537), 0.2085083, vec3(0, 0, 0)),\n    Sphere(vec3(-2.679304, 1.710367, 4.932371), 1.710367, vec3(0.2799795, 0.2253416, 0.3830366), vec3(0.04, 0.04, 0.04), 0.9304398, vec3(0, 0, 0)),\n    Sphere(vec3(-5.128378, 1.334248, 1.31306), 1.334248, vec3(0, 0, 0), vec3(0.9989762, 0.8810199, 0.5546346), 0.4535502, vec3(0, 0, 0)),\n    Sphere(vec3(3.121773, 1.716433, 0.5316908), 1.716433, vec3(0.01511412, 0.01593054, 0.008303878), vec3(0.04, 0.04, 0.04), 0.4785737, vec3(0, 0, 0)),\n    Sphere(vec3(2.409412, 1.554493, 8.397848), 1.554493, vec3(0, 0, 0), vec3(0.6939513, 0.2488536, 0.3630533), 0.8470323, vec3(0, 0, 0)),\n    Sphere(vec3(-2.540945, 1.106817, -2.001277), 1.106817, vec3(0.3437244, 0.3492539, 0.342655), vec3(0.04, 0.04, 0.04), 0.5703722, vec3(0, 0, 0)),\n    Sphere(vec3(9.703676, 1.927112, -2.228094), 1.927112, vec3(0, 0, 0), vec3(0, 0, 0), 0.0, vec3(0.5451509, 2.246424, 3.320993)),\n    Sphere(vec3(1.244251, 1.045728, -4.704848), 1.045728, vec3(0, 0, 0), vec3(0.02365752, 0.09684564, 0.03993712), 0.5299671, vec3(0, 0, 0)),\n    Sphere(vec3(8.072565, 1.022666, 3.248825), 1.022666, vec3(0.1453352, 0.164089, 0.1084757), vec3(0.04, 0.04, 0.04), 0.4441155, vec3(0, 0, 0)),\n    Sphere(vec3(6.682734, 1.258379, 6.802286), 1.258379, vec3(0, 0, 0), vec3(0, 0, 0), 0.0, vec3(2.490077, 1.497741, 5.759071)),\n    Sphere(vec3(6.419971, 1.552787, -4.444652), 1.552787, vec3(0.2449335, 0.351425, 0.2428978), vec3(0.04, 0.04, 0.04), 0.2946651, vec3(0, 0, 0)),\n    Sphere(vec3(-9.402631, 1.853397, -0.9970126), 1.853397, vec3(0, 0, 0), vec3(0.00232565, 0.04248521, 0.05344952), 0.7781689, vec3(0, 0, 0)),\n    Sphere(vec3(2.43484, 1.411097, 4.52638), 1.411097, vec3(0, 0, 0), vec3(0.287586, 0.6366081, 0.2288994), 0.7958542, vec3(0, 0, 0)),\n    Sphere(vec3(-6.861821, 1.259868, -3.895629), 1.259868, vec3(0.02265733, 0.02483499, 0.02013938), vec3(0.04, 0.04, 0.04), 0.09388162, vec3(0, 0, 0)),\n    Sphere(vec3(-1.07497, 1.940796, 9.348866), 1.940796, vec3(0, 0, 0), vec3(0.2180877, 0.2224313, 0.2209103), 0.01493728, vec3(0, 0, 0)),\n    Sphere(vec3(3.897766, 1.054659, -5.693988), 1.054659, vec3(0, 0, 0), vec3(0.4224965, 0.43979, 0.6885458), 0.5265467, vec3(0, 0, 0)),\n    Sphere(vec3(-1.702148, 1.424313, -8.234821), 1.424313, vec3(0, 0, 0), vec3(0.6923285, 0.8391109, 0.8382956), 0.9054835, vec3(0, 0, 0)),\n    Sphere(vec3(-4.835083, 1.397155, -7.987012), 1.397155, vec3(0, 0, 0), vec3(0.350755, 0.3878988, 0.4074546), 0.3741118, vec3(0, 0, 0)),\n    Sphere(vec3(6.764691, 1.493521, -0.004372807), 1.493521, vec3(0, 0, 0), vec3(0.102218, 0.5550403, 0.3609966), 0.9266146, vec3(0, 0, 0)),\n    Sphere(vec3(-1.191206, 1.086745, 0.9066531), 1.086745, vec3(0.6698647, 0.02313589, 0.3088503), vec3(0.04, 0.04, 0.04), 0.950848, vec3(0, 0, 0)),\n    Sphere(vec3(-2.451898, 1.345356, -5.082565), 1.345356, vec3(0.04997491, 0.09998728, 0.02583434), vec3(0.04, 0.04, 0.04), 0.6489202, vec3(0, 0, 0)),\n    Sphere(vec3(-8.336807, 1.653751, 2.616103), 1.653751, vec3(0.3897177, 0.5997107, 0.6021966), vec3(0.04, 0.04, 0.04), 0.9747565, vec3(0, 0, 0)),\n    Sphere(vec3(-6.663369, 1.24894, 6.001589), 1.24894, vec3(0.6626552, 0.6646308, 0.6535686), vec3(0.04, 0.04, 0.04), 0.9283251, vec3(0, 0, 0)),\n    Sphere(vec3(3.358527, 1.10426, -2.968534), 1.10426, vec3(0, 0, 0), vec3(0.3947442, 0.4659265, 0.5040199), 0.4048422, vec3(0, 0, 0)),\n    Sphere(vec3(-4.191335, 1.164075, 7.849207), 1.164075, vec3(0, 0, 0), vec3(0, 0, 0), 0.0, vec3(4.909746, 3.613276, 3.927177)),\n    Sphere(vec3(5.600569, 1.047177, 2.414735), 1.047177, vec3(0.4527525, 0.3436455, 0.6409165), vec3(0.04, 0.04, 0.04), 0.008512021, vec3(0, 0, 0)),\n    Sphere(vec3(3.408995, 1.650327, -9.15805), 1.650327, vec3(0, 0, 0), vec3(0.2378731, 0.2383068, 0.2419303), 0.3996018, vec3(0, 0, 0)),\n    Sphere(vec3(0.2125529, 1.413564, -2.261059), 1.413564, vec3(0.6282106, 0.6027594, 0.651789), vec3(0.04, 0.04, 0.04), 0.5640097, vec3(0, 0, 0)),\n    Sphere(vec3(-5.032301, 1.209769, -1.523415), 1.209769, vec3(0, 0, 0), vec3(0, 0, 0), 0.0, vec3(3.559655, 3.622234, 1.988985)),\n    Sphere(vec3(0.6184586, 1.165437, -9.540567), 1.165437, vec3(0.3438887, 0.349723, 0.3457641), vec3(0.04, 0.04, 0.04), 0.8508559, vec3(0, 0, 0))   \n);\n\nvec2 _PixelOffset;\nmat4 _CameraToWorld;\nmat4 _CameraInverseProjection;\nfloat _SphereRadiusMin = 1.0;\nfloat _SphereRadiusMax = 2.0;\nfloat _SpherePlacementRadius = 10.0;\n\n////////////////////////////////////////////////////////////////\nmat3 GetTangentSpace(vec3 normal)\n{\n    // Choose a helper vector for the cross product\n    vec3 helper = vec3(1, 0, 0);\n    if (abs(normal.x) > 0.99)\n        helper = vec3(0, 0, 1);\n\n    // Generate vectors\n    vec3 tangent = normalize(cross(normal, helper));\n    vec3 binormal = normalize(cross(normal, tangent));\n    return mat3(tangent, binormal, normal);\n}\n\nvec3 SampleHemisphere(vec3 normal, float alpha)\n{\n    // Sample the hemisphere, where alpha determines the kind of the sampling\n    float cosTheta = pow(Random(), 1.0 / (alpha + 1.0));\n    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);\n    float phi = 2.0 * PI * Random();\n    vec3 tangentSpaceDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\n    // Transform direction to world space\n    return tangentSpaceDir * GetTangentSpace(normal);\n}\n\n\n//-------------------------------------\nRay CreateRay(vec3 origin, vec3 direction)\n{\n    Ray ray;\n    ray.origin = origin;\n    ray.direction = direction;\n    ray.energy = vec3(1.0f, 1.0f, 1.0f);\n    return ray;\n}\n\nRay CreateCameraRay(vec2 uv)\n{\n    // Transform the camera origin to world space\n    vec3 origin = (_CameraToWorld * vec4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;\n    \n    // Invert the perspective projection of the view-space position\n    vec3 direction = (_CameraInverseProjection * vec4(uv, 0.0f, 1.0f)).xyz;\n    // Transform the direction from camera to world space and normalize\n    direction = (_CameraToWorld * vec4(direction, 0.0f)).xyz;\n    direction = normalize(direction);\n\n    return CreateRay(origin, direction);\n}\n\n//-------------------------------------\nRayHit CreateRayHit()\n{\n    RayHit hit;\n    hit.position = vec3(0.0f, 0.0f, 0.0f);\n    hit.t = INFINITY;\n    hit.normal = vec3(0.0f, 0.0f, 0.0f);\n    hit.albedo = vec3(0.0f, 0.0f, 0.0f);\n    hit.specular = vec3(0.0f, 0.0f, 0.0f);\n    hit.smoothness = 0.0f;\n    hit.emission = vec3(0.0f, 0.0f, 0.0f);\n    return hit;\n}\n\n//-------------------------------------\nvoid IntersectGroundPlane(Ray ray, inout RayHit bestHit)\n{\n    // Calculate distance along the ray where the ground plane is intersected\n    float t = -ray.origin.y / ray.direction.y;\n    if (t > 0.0 && t < bestHit.t)\n    {\n        bestHit.t = t;\n        bestHit.position = ray.origin + t * ray.direction;\n        bestHit.normal = vec3(0.0f, 1.0f, 0.0f);\n        bestHit.albedo = vec3(0.5);\n        bestHit.specular = vec3(0.03);\n        bestHit.smoothness = 0.2;\n        bestHit.emission = vec3(0.0, 0.0, 0.0);\n    }\n}\n\n//-------------------------------------\nvoid IntersectSphere(Ray ray, inout RayHit bestHit, Sphere sphere)\n{\n    // Calculate distance along the ray where the sphere is intersected\n    vec3 d = ray.origin - sphere.position;\n    float p1 = -dot(ray.direction, d);\n    float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;\n    if (p2sqr < 0.0)\n        return;\n    float p2 = sqrt(p2sqr);\n    float t = p1 - p2 > 0.0 ? p1 - p2 : p1 + p2;\n    if (t > 0.0 && t < bestHit.t)\n    {\n        bestHit.t = t;\n        bestHit.position = ray.origin + t * ray.direction;\n        bestHit.normal = normalize(bestHit.position - sphere.position);\n        bestHit.albedo = sphere.albedo;\n        bestHit.specular = sphere.specular;\n        bestHit.smoothness = sphere.smoothness;\n        bestHit.emission = sphere.emission;\n    }\n}\n\nbool IntersectTriangle_MT97(Ray ray, \n                            vec3 vert0, vec3 vert1, vec3 vert2,\n                            inout float t, inout float u, inout float v)\n{\n\t// find vectors for two edges sharing vert0\n\tvec3 edge1 = vert1 - vert0;\n\tvec3 edge2 = vert2 - vert0;\n\n\t// begin calculating determinant - also used to calculate U parameter\n\tvec3 pvec = cross(ray.direction, edge2);\n\n\t// if determinant is near zero, ray lies in plane of triangle\n\tfloat det = dot(edge1, pvec);\n\n\t// use backface culling\n\tif (det < EPSILON)\n\t\treturn false;\n\tfloat inv_det = 1.0f / det;\n\n\t// calculate distance from vert0 to ray origin\n\tvec3 tvec = ray.origin - vert0;\n\n\t// calculate U parameter and test bounds\n\tu = dot(tvec, pvec) * inv_det;\n\tif (u < 0.0 || u > 1.0f)\n\t\treturn false;\n\n\t// prepare to test V parameter\n\tvec3 qvec = cross(tvec, edge1);\n\n\t// calculate V parameter and test bounds\n\tv = dot(ray.direction, qvec) * inv_det;\n\tif (v < 0.0 || u + v > 1.0f)\n\t\treturn false;\n\n\t// calculate t, ray intersects triangle\n\tt = dot(edge2, qvec) * inv_det;\n\n\treturn true;\n}\n\n/*\nvoid IntersectMeshObject(Ray ray, inout RayHit bestHit, MeshObject meshObject)\n{\n\tuint offset = meshObject.indices_offset;\n\tuint count = offset + meshObject.indices_count;\n\tfor (uint i = offset; i < count; i += 3)\n\t{\n\t\tvec3 v0 = (mul(meshObject.localToWorldMatrix, vec4(_Vertices[_Indices[i]], 1))).xyz;\n\t\tvec3 v1 = (mul(meshObject.localToWorldMatrix, vec4(_Vertices[_Indices[i + 1]], 1))).xyz;\n\t\tvec3 v2 = (mul(meshObject.localToWorldMatrix, vec4(_Vertices[_Indices[i + 2]], 1))).xyz;\n\n\t\tfloat t, u, v;\n\t\tif (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v))\n\t\t{\n\t\t\tif (t > 0 && t < bestHit.distance)\n\t\t\t{\n\t\t\t\tbestHit.distance = t;\n\t\t\t\tbestHit.position = ray.origin + t * ray.direction;\n\t\t\t\tbestHit.normal = normalize(cross(v1 - v0, v2 - v0));\n\t\t\t\tbestHit.albedo = 0.0f;\n\t\t\t\tbestHit.specular = 0.65f;\n\t\t\t\tbestHit.smoothness = 0.99f;\n\t\t\t\tbestHit.emission = 0.0f;\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n\nRayHit Trace(Ray ray)\n{\n\tRayHit bestHit = CreateRayHit();\n\n\t// Trace ground plane\n\tIntersectGroundPlane(ray, bestHit);\n\n\t// Trace spheres\n\tfor (int i = 0; i < NUM_SPHERES; i++)\n\t{\n\t\tIntersectSphere(ray, bestHit, spheres[i]);\n\t}\n\n\t// Trace mesh objects\n\t//_MeshObjects.GetDimensions(count, stride);\n\t//for (i = 0; i < count; i++)\n\t//{\n\t\t//IntersectMeshObject(ray, bestHit, _MeshObjects[i]);\n\t//}\n\n\treturn bestHit;\n}\n\nfloat SmoothnessToPhongAlpha(float s)\n{\n    return pow(1000.0, s * s);\n}\n\nvec3 Shade(inout Ray ray, RayHit hit)\n{\n    if (hit.t < INFINITY)\n    {\n        // Calculate chances of diffuse and specular reflection\n        hit.albedo = min(1.0 - hit.specular, hit.albedo);\n        float specChance = energy(hit.specular);\n        float diffChance = energy(hit.albedo);\n\n        // Roulette-select the ray's path\n        float roulette = Random();\n        if (roulette < specChance)\n        {\n            // Specular reflection\n            ray.origin = hit.position + hit.normal * 0.001f;\n            \n            float alpha = SmoothnessToPhongAlpha(hit.smoothness);\n            ray.direction = SampleHemisphere(reflect(ray.direction, hit.normal), alpha);\n            \n            float f = (alpha + 2.0) / (alpha + 1.0);\n            \n            ray.energy *= (1.0 / specChance) * hit.specular * sdot(hit.normal, ray.direction, f);\n        }\n        else if (roulette < (specChance + diffChance) && (diffChance > 0.0))\n        {\n            // Diffuse reflection\n            ray.origin = hit.position + hit.normal * 0.001f;\n            \n            ray.direction = SampleHemisphere(hit.normal, 1.0f);\n            \n            ray.energy *= (1.0f / diffChance) * hit.albedo;\n        }\n        else\n        {\n            // Terminate ray\n            ray.energy = vec3(0.0);\n        }\n\n        return hit.emission;\n    }\n    else\n    {\n        // Erase the ray's energy - the sky doesn't reflect anything\n        ray.energy = vec3(0.0);\n        \n        // Sample the skybox and write it\n        float theta = acos(ray.direction.y) / -PI;\n        float phi = atan(ray.direction.x, -ray.direction.z) / -PI * 0.5f;        \n        \n        return texture(iChannel3, vec2(phi, theta)).rgb;\n\n        // Sample the skybox and write it        \n        //return texture(iChannel3, dir).rgb;\n    }\n}\n\nvoid InitScene()\n{\n    _CameraToWorld = transpose(mat4\n    (\n       -0.794, -0.208, 0.570, 17.11, \n        0.000,  0.939, 0.343, 10.90,\n        0.607, -0.273, 0.746, 22.38,\n        0.000,  0.000, 0.000, 1.000\n    ));\n      \n    _CameraInverseProjection = transpose(mat4\n    (\n        0.253, 0.000, 0.000, 0.000, \n        0.000, 0.187, 0.000, 0.000,\n        0.000, 0.000,-0.005,-1.000,\n        0.000, 0.000,-1.666, 1.666\n    ));\n    \n    _SphereRadiusMin = 1.0;\n    \n    _SphereRadiusMax = 2.0;  \n    \n    _SpherePlacementRadius = 5.0;\n    \n    _PixelOffset = Random2();    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    InitRandom(iTime);\n    \n    InitScene();\n    \n    vec2 uv = ((fragCoord + _PixelOffset) / iResolution.xy) * 2.0 - 1.0;\n\n    Ray ray = CreateCameraRay(uv);\n    \n    vec3 result = vec3(0, 0, 0);\n    for (int i = 0; i < 8; i++)\n    {\n        RayHit hit = Trace(ray);\n        result += ray.energy * Shade(ray, hit);\n\n        if (!anyNonZero(ray.energy))\n            break;\n    }\n\n    fragColor = vec4(OutputColor(result, fragCoord), 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}