{"ver":"0.1","info":{"id":"Mt2BDt","date":"1518125660","viewed":161,"name":"ÃŠ, lipse!","username":"mmutai","description":"The title, in Portuguese, translates to \"Oh, lipse!\", like what you would say to the \"lipse\" if it just did something dumb.\nThe point is that the title sounds like \"ellipse\" said in Portuguese.\n\"Lipse\", of course, is completely meaningless. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["geometry","homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Extra Credit #defines:\n//#define FLIP\n//#define ADD_LIGHT_BLEND\n//#define ADD_DARK_BLEND\n//#define PULSATING_COLOR\n\n// can switch to fixed value for easier debugging/tweaking (a.k.a TOKI YO TOMARE)\n// can also change general speed with this\n#define U_TIME (0.75 * iTime + 0.0)\n\n\nconst float LIMIT_EPSILON = 0.04; // controls size of white limit dot\nconst float ELLIPSE_EPSILON = 0.018; // controls thickness of ellipse\n\n#ifdef PULSATING_COLOR\n#define ELLIPSE_COLOR (mix(vec3(245.0, 92.0, 59.0) / 255.0, vec3(255.0, 190.0, 190.0) / 255.0, cos(U_TIME * PI * 1.5) * 0.5 + 0.5))\n#define LIMIT_COLOR (mix(vec3(0.7, 0.6, 1.1), vec3(0.9), cos(U_TIME * PI * 1.5) * 0.5 + 0.5))\n#else\nconst vec3 ELLIPSE_COLOR = vec3(245.0, 92.0, 59.0) / 255.0;\nconst vec3 LIMIT_COLOR = vec3(0.9, 0.9, 0.9);\n#endif\nconst vec3 BG_COLOR = vec3(42.0, 29.0, 69.0) / 255.0;\nconst float PI = 3.14159265;\nconst float ROT_OFFSET = PI * 1.23;//-PI * 0.5;\nconst float LIMIT_OFFSET = -PI;\nconst float SCALE_OFFSET = -PI;\nconst float LIMIT_ORIGIN = -PI * 0.18;\nconst float GAIN_PARAM_LIMIT = 0.3;\nconst float GAIN_PARAM_ROT = 0.2;\n\n\n// note to self: edge(a, b) returns (a >= b) ? 1.0 : 0.0\n\n// http://demofox.org/biasgain.html\n// bias and gain functions\nfloat getBias(float time, float bias) {\n  return (time / ((((1.0 / bias) - 2.0) * (1.0 - time)) + 1.0));\n}\n\nfloat getGain(float time, float gain) {\n    if(time < 0.5) {\n        return getBias(time * 2.0, gain) / 2.0;\n    }\n    else {\n        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\n    }\n}\n\n// !!! assumes LIMIT_ORIGIN <= 0.0 !!!\n// from here on, LIMIT_ORIGIN is shortened to L_O for brevity\n// if L_O != 0.0, there's a special region in\n// [PI + L_O, PI] where checking just angle < angleLimit fails\n// because adding L_O to angleLimit shifts its range to [-PI + L_O, PI + L_O]\n// but atan() returns [-PI, PI]\n// now, we could add L_O to angle and hope it works...\n// this makes the correct amount of ellipse to exposed, but it's still\n// starting in the wrong place (at the -PI point)\n// so we need to identify when angle is in this special region\n// and perform a special computation\n// note about assuming L_O <= 0.0:\n// this is needed because the checks to see if angle is in the special region\n// change if L_O > 0.0. they change in a trivial way, so a function that\n// handles L_O > 0.0 could also be written.\nbool isBehindAngleLimit(float angle, float angleLimit) {\n    if (PI + LIMIT_ORIGIN <= angle && angle <= PI) {\n        // if angleLimit >= -PI, then we are certainly behind it already\n        if (angleLimit >= -PI) {\n            return true;\n        }\n        // else, angleLimit is also in the special region\n        // we can subtract -2 * PI to keep our angle in the same place,\n        // but numerically make it comparable to angleLimit\n        else {\n            return (angle - 2.0 * PI) < angleLimit; \n        }\n    }\n    else {\n        return angle < angleLimit;\n    }\n}\n\n// blendColor should be the color obtained from sampling previous layer\nvec3 getEllipseColor(vec2 p, vec3 blendColor, out bool hitGeometry) {\n    const float a = 1.0;\n    const float b = 1.0;\n    \n    hitGeometry = false;\n    float adjTime = U_TIME * PI * 0.5;\n    float modAdjTime = mod(adjTime, 2.0 * PI);\n    \n#ifdef FLIP\n    if (0.5 * PI < modAdjTime && modAdjTime < 1.5 * PI) {\n        //p.x /= cos(modAdjTime * 4.0) * 0.5 + 0.75;\n    \tp.y /= cos(modAdjTime * 4.0);\n    }\n#endif\n    float angle = atan(p.y, p.x);// + LIMIT_ORIGIN;\n    vec2 ellipse = vec2(a * cos(angle), b * sin(angle));\n\n    // this gives us a \"square wave\" with 50% duty cycle\n    // and frequency of 2 PI\n    bool goingBack = modAdjTime > PI;\n    if (goingBack) {\n        adjTime *= -1.0;\n    }\n    else {\n        // this offset shifts adjTime so it's in the correct\n        // part of the cos() domain\n\t    adjTime += LIMIT_OFFSET;        \n    }\n\n    // [-1, 1] -> [0, 1] -(gain)-> [0, 1] -> [-1, 1]\n    float adjCos = getGain(cos(adjTime) * 0.5 + 0.5, GAIN_PARAM_LIMIT) * 2.0 - 1.0;\n    float angleLimit = -(adjCos) * PI + LIMIT_ORIGIN;\n    vec2 limit = vec2(a * cos(angleLimit), b * sin(angleLimit));\n    \n    float distToEllipse = distance(p, ellipse);\n    float distToLimit = distance(p, limit);\n\tbool isBehind = isBehindAngleLimit(angle, angleLimit);\n\tif (goingBack) {\n        isBehind = !isBehind;\t\n\t}\n    \n    // we could just return color\n    // but this leads to a very binary effect\n    // i.e. pixel is either on ellipse or not,\n    // which leads to pixellated/aliased effect\n    // solution: blend based on distance to ellipse\n    \n    // remap to [0, 1] and \"flip\"\n    float proximity = 1.0 - distToEllipse / ELLIPSE_EPSILON;\n    // bias towards higher values\n    float blend = smoothstep(0.0, 0.2, proximity);\n    //vec3 blendedEllipseColor = mix(BG_COLOR, ELLIPSE_COLOR, blend);\n    vec3 blendedEllipseColor = mix(blendColor, ELLIPSE_COLOR, blend);\n    \n    if (distance(p, limit) < LIMIT_EPSILON) {\n        hitGeometry = true;\n        // do same thing, but blend with blendedEllipseColor\n        \n        // remap to [0, 1] and \"flip\"\n        float proximity = 1.0 - distToLimit / LIMIT_EPSILON;\n        // bias towards higher values\n        float blend = smoothstep(0.0, 0.2, proximity);\n        // pick either background or ellipse depending on our angle\n        // this prevents the ellipse from showing under the limit point\n        //vec3 otherColor = mix(BG_COLOR, blendedEllipseColor, step(angleLimit, angle));\n        vec3 otherColor = (isBehind ? blendColor : blendedEllipseColor);\n        return mix(otherColor, LIMIT_COLOR, blend);\n        //return ELLIPSE_COLOR; \n        \n        //return LIMIT_COLOR; \n    }\n    else if (isBehind) {\n    //else if (angle + LIMIT_ORIGIN < angleLimit) {\n        return BG_COLOR;\n    }\n    else if (distToEllipse < ELLIPSE_EPSILON) {\n        hitGeometry = true;\n        //return ELLIPSE_COLOR;\n        return blendedEllipseColor; \n    }\n    else {\n        return BG_COLOR;\n        //return vec3(0,1,0);\n    }\n}\n\nvec3 ellipse(vec2 p, vec3 blendColor, float rotOffset, float rotSpeed, float scale, out bool hitGeometry) {\n    vec2 transP;\n    \n    // make ellipse rotate\n    // [-1, 1] -> [0, 1] -(gain)-> [0, 1] -> [-1, 1]\n    float adjCos = getGain(cos(U_TIME * PI * 0.5) * 0.5 + 0.5, GAIN_PARAM_ROT) * 2.0 - 1.0;\n    float angle = adjCos * rotSpeed;\n    float c = cos(angle + rotOffset);\n    float s = sin(angle + rotOffset);\n    mat2 rot = mat2(vec2(c, s), vec2(-s, c));\n    transP = p * rot;\n    \n    // make ellipse more stretched over time\n    float yScale = mix(1.0, 2.8,  cos(U_TIME * PI * 0.5 + SCALE_OFFSET) * 0.5 + 0.5);\n    float totalScale = mix(0.82, 1.1,  -cos(U_TIME * PI * 0.5 + SCALE_OFFSET) * 0.5 + 0.5);\n    transP *= vec2(1.0, yScale) * scale * totalScale;\n    return getEllipseColor(transP, blendColor, hitGeometry);\n\n}\n\nvoid blend(bool hitGeometry, in vec3 ellipseColor, inout vec3 blendColor) {\n#if defined(ADD_LIGHT_BLEND) || defined(ADD_DARK_BLEND)\n    blendColor += hitGeometry ? ellipseColor : vec3(0.0);//blendColor;\n#else\n    blendColor = hitGeometry ? ellipseColor : blendColor;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    \n    // basic idea:\n    // there is a sequence of ellipses, where each:\n    //   is smaller than the previous\n    //   has a different rotation speed\n    //   has a different initial rotation offset (to account for speed)\n    // in order to achieve correct blending, we have to:\n    //   init blendColor = BG_COLOR\n    //   from big to small ellipse:\n    //     sample ellipse, passing in blendColor\n    //     if we hit geometry, update blendColor w/ return value\n    // at the end, this will give us the correctly blended color.\n    // we go from big to small because bigger ellipses seem to\n    // be closer to the background in the original GIF, hence they\n    // should be blended with the background first.\n    bool hitGeometry = false;\n    vec3 blendColor = BG_COLOR;\n\n    // 1st ellipse\n    vec3 col = ellipse(p, blendColor, ROT_OFFSET, PI * 0.45, 1.0, hitGeometry);\n    blend(hitGeometry, col, blendColor);\n    \n\tcol = ellipse(p, blendColor, ROT_OFFSET + 0.41, PI * 0.32, 1.15, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 0.76, PI * 0.21, 1.32, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 1.2, PI * 0.07, 1.50, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    // 5th ellipse\n    col = ellipse(p, blendColor, ROT_OFFSET + 1.55, -PI * 0.04, 1.7, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 1.99, -PI * 0.18, 1.9, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 2.335, -PI * 0.29, 2.15, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 2.775, -PI * 0.43, 2.4, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 3.12, -PI * 0.54, 2.65, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    // 10th ellipse\n    col = ellipse(p, blendColor, ROT_OFFSET + 3.559, -PI * 0.68, 2.93, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 3.93, -PI * 0.795, 3.25, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n    col = ellipse(p, blendColor, ROT_OFFSET + 4.318, -PI * 0.92, 3.55, hitGeometry);    \n    blend(hitGeometry, col, blendColor);\n    \n#ifdef ADD_LIGHT_BLEND\n    blendColor =  2.0 * pow(blendColor / 1.0, vec3(2.2));\n#elif defined(ADD_DARK_BLEND)    \n    blendColor = 32.0 * pow(blendColor / 6.0, vec3(2.4));\n#endif    \n    fragColor = vec4(blendColor, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}