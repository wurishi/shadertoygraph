{"ver":"0.1","info":{"id":"lcfyRS","date":"1721233075","viewed":238,"name":"Warning colors","username":"shadertoyjiang","description":"lit. ten  kilometers  snake \nN > 13\n\nThe number of iterations (N) can be controlled using the UP, DOWN, and HOME keys. \nLEFT or RIGHT  buttons to change the surface shape\n","likes":29,"published":3,"flags":48,"usePreview":0,"tags":["mouse","colors","warning","scary","hirbert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024年7月17日\n\n// hilbert curve  349.7161.\n\n// The number of iterations (N) can be controlled using the UP(N+=1), DOWN(N-=1), and HOME(N=0) keys. \n\n// LEFT or RIGHT  buttons to change the surface shape\n\n\n\n\nfloat dln(in vec3 a, in vec3 b, in vec3 p){b-=a; p-=a;float h = clamp(dot(p,b)/dot(b,b), 0., 1.);return length(p - b * h);}\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nbool calcText=true;\nvec4 clr;\nfloat mrx;\n\n// 2024年7月18日\nfloat shape2(vec3 p)\n{\n        vec2 f=vec2(3,3);\n        vec2 u = p.xy;\n        u *= f; \n        u += iTime * vec2(5,1);\n        u = abs(u-round(u))/f;\n        vec2 v = vec2( min(u.x,u.y), p.z  * .8 ); // 不太正确的方法\n        return length(v)-.08;\n}\n\n\nfloat shape1(vec3 p)\n{ \n        p.xy+=iTime*.1;\n        vec3 sz=vec3(3,6,2);\n        p*=sz;\n        vec2 c = vec2(.433, .5);\n        p.xy = p.xy / c * .5;\n        p.xy = p.xy - round(p.xy);\n        p.xy = p.xy * c / .5;\n        p.yz = p.yz * sign(p.y);\n        p.x = abs(p.x);\n        p.y = p.y - .25;\n        p.yz = p.yz *  sign(p.y);\n\n        p.xy = p.xy - c/vec2(2,4);\n\n        p.xyz = p.xyz * sign(p.x);\n        p.xy = p.xy - c/vec2(2,4);\n        float fz =.2, r =.06;\n        float d1 = dln(vec3(0,0,-fz),vec3(0,-.5, fz),p);\n        float d2 = dln(vec3(0,0, fz),vec3(-.433,-.25, -fz),p);\n  clr /=clr;\n  clr=vec4(2,1.2,.5,1)*.3+.3;\n        return (min(d1,d2)-r)/6.;\n}\n\nvoid txtu(vec2 u)\n{\n        u *=3.; \n        u += iTime*vec2(5,1);\n        u -= round(u);\n        u = abs(u);\n        clr = clr*0.+1.-exp(-20.*min(u.x,u.y))-2.*(abs(u.y/3.-.5)-.4);\n}\n\nfloat texX(vec3 p, float f)\n{\n        float a = atan(p.y,p.x)/1.57;\n        return (a-.5)*f+.5; // + ind;\n}\n\nfloat texY(vec3 p, float f)\n{\n        float r = length(p.xy)-2.;\n        float a = atan(r,p.z)/6.28+.5;\n        return (a-.5)*f+.5;\n}\n\nfloat hilbert(vec3 p)\n{\n        int N = int(texture(iChannel0, vec2(.5)).x);\n        //int N = int(ky.x);\n        float dBox = length(  max(abs(p)-2., 0.) );\n        if(dBox>.051)return dBox;\n        const vec3 Z=vec3(-1,0,1); \n        vec3 f[] = vec3[](Z.zyy, Z.yyz,-Z.yzy,-Z.yyz, Z.zyy, Z.yyz, Z.yzy,-Z.yyz,Z.yzy);\n        vec3 c[] = vec3[](Z.yxy, Z.zyy, Z.zyy, Z.yxy, Z.yxy, Z.xyy, Z.xyy, Z.zyy); // c[i]=cross(f[i],f[i+1])\n        vec3 x,y,z,w;\n        float s=1.,h,k=1., a=0. ;\n        int e, t=0;//, N = 17; \n        for(int i=0;i<N;i++)// 可能可以去除循环，\n        {\n                w = sign(p); w.y *= w.x; w.z *= -w.y;\n                e = int( dot(vec3(4,2,1), w*.5+.5) );\n                t = t * 8 + (k<0.?7-e:e);\n                x = f[e];\n                y = f[e+1];\n                z = c[e];// =cross(x,y);\n                h = 0.;\n                if(p.z<0. && e>0)z=-z, s=-s, h=.25; // e==3,4,7\n                if(e<2 || e==3 || e==5)w=-x, x=-y, y=w, k=-k;\n                mat3 m = mat3(x,y,z);\n                p += p - 2.*sign(p);\n                p *= m;\n                //\n                if(calcText==true){\n                   if(i==N-1)h=(e>0 && e<7 ? .25 : 0.)-h;\n                   if(i==N-2)h=(e>0 && e<7 ? .5  : 0.)+h;\n                   a += h * s;\n                }\n        }\n        //float n = 1.;\n        //if(t==0 || t==(1<<N*3)-1)//\n          //if(-p.x<p.y)p=-p.yxz;//, n =-n;// sun=-sun.yxz;\n        \n        p -= vec3(-2,2,0);\n        float tx,ty,tz;\n                tz = length(vec2(length(p.xy)-2., p.z));      \n        \n        if(calcText==true){\n                tx = texX(p, k) + float(t);\n                ty = texY(p, s) + a ; ty = fract(ty+5000.);\n           \n                txtu(vec2(tx,ty));\n        }\n        float d,d1=1e8,d2=1e8;\n        //if(mrx<.5)\n        //    d1 = (tz -1.3)/float(1<<N);\n        //else\n        //    d2 = shape1(vec3(tx,ty,tz-1.2))/float(1<<N);\n        //d=min(d1,d2);\n        \n        switch (int(texture(iChannel0, vec2(.5)).w))\n        {\n              case 0:{ d = shape1(vec3(tx,ty,tz-1.2))/float(1<<N);break;}\n              case 1:{ d = shape2(vec3(tx,ty,tz-1.2))/float(1<<N);break;}\n              case 2:{ d = (tz -1.3)/float(1<<N)    ;break;}\n        }\n        \n        return max(d, dBox);\n}\n\n\n\n\n\nfloat map(vec3 p)\n{\n        float t = iTime*.33;\n        vec2 ms = iMouse.xy/iResolution.xy*6.28+t;\n        p.xy = p.xy * rot(t +1.);\n        p.xz = p.xz * rot(ms.x);\n        p.yz = p.yz * rot(ms.y);\n        return hilbert(p);\n}\n\nbool keypress(int keycode){if(int(texture(iChannel0, vec2(keycode, .5)).x)==keycode)return true;return false;}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        //const int KEY_UP = 38;\n        //const int KEY_DOWN = 40;\n        //const int KEY_HOME = 36;\n        //if(keypress(KEY_UP)==true)N=N+1;\n        //if(keypress(KEY_DOWN)==true && N>0)N=N-1;\n        //if(keypress(KEY_HOME)==true)N=0;\n        O = vec4(.5);\n        mrx = 1.-iMouse.x/iResolution.x;\n        //if(texture(iChannel0, vec2(.5)).w<.5)mrx=1.-mrx;\n        if(mrx>.5)calcText=true;\n        vec2 R = iResolution.xy,\n             u = (U+U - R) / R.y;\n        if(length(u)>1.4)return;\n        vec3 eye = vec3(0, 0, -4),\n             dir = normalize(vec3(u, 1)),\n             sun = 5. * ( .2*cos(iTime+vec3(7,11,13)) + vec3(-1,2,-3)/3.74 ),\n             eps = vec3(0, .0001, 0),\n             nor, p;\n        float d , t=0.;\n        for(int i=0; i<328 ;i++)\n        {\n                if(t>7.)break;\n                p = eye + dir * t;\n                d = map(p);\n                if( d<.001 ) // if N>5 then set .001\n                {       // phong 光照模型\n                        \n                        float cx,cy,cz;\n                        cx=map(p+eps.yxx);\n                        cy=map(p+eps);\n                        calcText=true;\n                        cz=map(p+eps.xxy);\n                        nor = normalize(vec3(cx, cy, cz)-d); \n                        vec3  sp = normalize(sun-p), ep=normalize(eye-p);\n                        float ln = max(0., dot(nor,sp)),               // light norm\n                              er = max(0., dot(ep, reflect(-sp,nor))); // eye ray\n                        float ambt=.3, difu=.6, spec=80.;\n                        vec4  lightClr = vec4(1,.5,0,1);\n                        O = lightClr * (ambt + difu*ln + pow(er, spec));\n                        O *= clr;\n                        if(mrx>-.5)O *= 2.*exp(-.5*(t-1.5));\n                        break;\n                }\n                t += d * .5;\n        }\n        \n}\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2024年7月18日\n// keypress thx to FabriceNeyret2\n#define keypress(ascii)   ( texelFetch(iChannel1,ivec2(ascii,1),0).x > 0.)\n//bool keypress(int keycode){if( int(texture(iChannel1, vec2(keycode, .5)).x)==keycode )return true;return false;}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n        const int KEY_UP = 38;\n        const int KEY_DOWN = 40;\n        const int KEY_HOME = 36;\n        const int KEY_LEFT = 37;\n        const int KEY_RIGHT = 39;\n\n        O = texture(iChannel0, vec2(.01));\n        if     ( keypress(KEY_HOME)==true          )O=vec4(0);\n        else if( keypress(KEY_UP)==true            )O.x=O.x+1.;\n        else if( keypress(KEY_DOWN)==true && O.x>.5)O.x=O.x-1.;\n        \n        if( keypress(KEY_LEFT)==true && O.w>.5)O.w=O.w-1.;\n        if( keypress(KEY_LEFT)==true )O.w=1.+O.w;\n        O.w = float( int(O.w)%3 );\n        if(length(iMouse.xy)>5. || length(O.xyz- vec3(2,-1,0))>.5 )O.y=0.;\n        if(iFrame<10)O = vec4(2,-1,0,2);\n        if(O.y<0.)O.w = mod(floor(iTime*.3), 3.);\n        O = round(O);        \n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}