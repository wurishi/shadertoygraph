{"ver":"0.1","info":{"id":"wsySzw","date":"1573614273","viewed":111,"name":"blob spheres","username":"dma","description":"Two spheres with phong lighting and smooth unioned so they blob together.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["phong","raymarch","smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 union_objs(in vec2 obj0, in vec2 obj1) {\n    if (obj0.x < obj1.x) return obj0;\n    return obj1;\n}\n\nvec2 smoothUnion(in vec2 obj0, in vec2 obj1, in float k) {\n    float h = clamp(0.5 + 0.5 * (obj1.x - obj0.x)/k, 0., 1.);\n    return vec2(\n        mix(obj1.x, obj0.x, h) - k * h * (1.0 - h),\n        obj0.y\n    );\n}\n\nvec2 plane(in vec3 p) {\n    return vec2(p.y + 4., 0);\n}\n\nvec2 sphere(in vec3 p, in float r) {\n    float d = length(p) - r;\n    return vec2(d, 1.);\n}\n\nvec2 scene(in vec3 p) {\n    return union_objs(\n        plane(p),\n        smoothUnion(\n\t        sphere(vec3(p.x, p.y+sin(2.*iTime)*1.5, p.z), 1.5),\n            sphere(vec3(p.x+sin(iTime)*3., p.y, p.z), 1.0),\n            0.3\n        )\n    );\n}\n\nvec3 floor_color(in vec3 p) {\n    if (fract(p.x * 0.2) > 0.2) {\n        if (fract(p.z * 0.2) > 0.2) return vec3(0., 1., 0.);\n        return vec3(0.5, 0.6, 0.);\n    }\n    return vec3(0.5, 0.6, 0.);\n}\n\nvec3 prim_color(in vec3 p) {\n    return vec3(0.6, 0.6, 0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n\n    vec2 vPos = -1. + 2. * uv;\n    \n    // up vector\n    vec3 vuv = vec3(0,1,0);\n    \n    // lookat\n    vec3 vrp = vec3(0);\n    \n    // cam pos\n    vec3 prp = vec3(-3, 2, -6);\n    \n    // light pos\n    vec3 lrp = vec3(-1, 6.5, -8);\n    \n    \n    // set up cam\n    vec3 vpn = normalize(vrp - prp);\n    vec3 u = normalize(cross(vuv, vpn));\n    vec3 v = cross(vpn, u);\n    vec3 vcv = (prp + vpn);\n    \n    vec3 scrCoord = vcv + vPos.x * u * 1. + vPos.y * v * ar;\n    vec3 scp = normalize(scrCoord-prp);\n    \n    // raymarch!\n    const vec3 e = vec3(0.02, 0, 0);\n    const float maxd = 100.;\n    vec2 d = vec2(0.02, 0.);\n    vec3 p;\n    \n    float f = 1.;\n    for (int i = 0; i < 256; i++) {\n        if ((abs(d.x) < .001) || f > maxd) break;\n        f += d.x;\n        p = prp + scp*f;\n        d = scene(p);\n    }\n    \n    vec3 c;\n    if (f < maxd) {\n        if (d.y == 0.) {\n            c = floor_color(p);\n        } else {\n            c = prim_color(p);\n        }\n        \n        vec3 n = vec3(d.x - scene(p - e.xyy).x,\n                      d.x - scene(p - e.yxy).x,\n                      d.x - scene(p - e.yyx).x);\n        vec3 N = normalize(n);\n        float b = dot(N, normalize(lrp-p));\n        \n        // phong lighting\n        c = vec3((b*c + pow(b,64.))*(1. - f*.02));\n    } else {\n\t    c = vec3(.0, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}