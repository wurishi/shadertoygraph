{"ver":"0.1","info":{"id":"dljyDV","date":"1692327789","viewed":60,"name":"Mandelbulb Fractal DOF","username":"Anto_Crasher555","description":"cool","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TIME texelFetch(iChannel0, ivec2(0,0), 0).x * 3.0\n#define T texelFetch(iChannel0, ivec2(0,0), 0).y\n\n#define MAX_ITERS 500\n#define EPSILON 0.0001\n#define MAX_DISTANCE 100.0\n\n#define TIME_SCALE 1.0\n#define TIME_OFFSET 5.616\n\n#define FOV 12.0\n\n#define FOCAL_LENGTH 1.220\n#define FOCAL_OFFSET 0.1\n#define APERTURE 0.024\n#define NUM_SAMPLES 1\n\n#define COLOR_SCALE 0.018\n#define COLOR_OFFSET 2.520\n\n#define USE_DOF true\n\n#define COLOR_A 0.500, 0.500, 0.500\n#define COLOR_B 0.500, 0.500, 0.500\n#define COLOR_C 1.000, 1.000, 1.000\n#define COLOR_D 0.000, 1.058, 0.058\n//#define COLOR_D 0.000, 0.948, 0.888\n\nstruct GetAngleBetVecRet {\n    float theta;\n    vec3 axis;\n};\n\n// COLOR PALETTE\nvec3 palette(float t) {\n    vec3 a = vec3(COLOR_A);\n    vec3 b = vec3(COLOR_B);\n    vec3 c = vec3(COLOR_C);\n    vec3 d = vec3(COLOR_D);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n// MANDEL BULB SIGNED DISTANCE FUNCTION\nfloat mandelbulb_distance(vec3 point) {\n    vec3 z = point;\n    float dr = 1.0;\n    float r = 0.0;\n    float max_pow = 11.640;\n    float power = (((sin(TIME * 0.132 * TIME_SCALE + TIME_OFFSET) + 1.0) / 2.0) * max_pow) + 4.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_ITERS; i++) {\n        iters = i;\n        r = length(z);\n        if (r > 2.0)\n            break;\n        float theta = atan(z.y, z.x);\n        float phi = acos(z.z / r);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi)) * zr + point;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// RAY MARCH FRACTAL TOWARDS DIRECTION\nvec3 ray_march_fractal(vec3 origin, vec3 direction) {\n    float dist = 0.0;\n    float total_dist = 0.0;\n    vec3 pos = origin;\n    for (int i = 0; i < MAX_ITERS; i++) {\n        dist = mandelbulb_distance(pos);\n        pos = pos + direction * dist;\n        total_dist += dist;\n        if (dist < EPSILON) {\n            float s = (1.0 + sin(float(i) * COLOR_SCALE + COLOR_OFFSET)) / 2.0 * 2.296 + 2.216;\n            float ao = pow((0.9 - max(float(i) / float(MAX_ITERS), 0.0)), 3.800) + 0.5;\n            return palette(s) * ao;\n        }\n        if (total_dist > MAX_DISTANCE) {\n            break;\n        }\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// RANDOM 0-1 FROM SEED\nfloat rand(vec2 seed)\n{\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// GET ANGLE AND AXIS FROM 2 VECTORS\nGetAngleBetVecRet angle_between_vectors(vec3 v1, vec3 v2) {\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);\n    vec3 axis = normalize(cross(v1, v2));\n    return GetAngleBetVecRet(-theta, axis);\n}\n\n// ROTATE VECTOR BY ANGLE AROUND AXIS\nvec3 rotate_vector(vec3 vector, vec3 axis, float angle) {\n    vec3 normalizedAxis = normalize(axis);\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    vec3 crossed = cross(vector, normalizedAxis);\n    float dotted = dot(vector, normalizedAxis);\n    vec3 rotatedVector = vector * cosTheta + crossed * sinTheta + normalizedAxis * dotted * (1.0 - cosTheta);\n    return rotatedVector;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV COORDS\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // INIT CAMERA PARAMS\n    float size = sin(TIME * TIME_SCALE + TIME_OFFSET) * 0.0 + FOCAL_LENGTH + FOCAL_OFFSET;\n    float speed = 0.000;\n    float cam_offset = 0.000;\n    float t = -1.592 + sin(TIME * 0.132 * TIME_SCALE + TIME_OFFSET) * 0.8 + cam_offset;\n    float look_size = 1.0;\n\n    // TARGET CENTER / CAM POS\n    vec3 center = vec3(cos(-1.592) * look_size, 0.0, sin(-1.592) * look_size);\n    vec3 cam_pos = vec3(size * cos(t), 0.0, size * sin(t)) + center;\n\n    // GET FOV PIXEL COORDS\n    float fovRad = FOV * (3.141 / 180.0);\n    float tanHalfFov = tan(fovRad * 0.5);\n    float ny = tanHalfFov * uv.y;\n    float nx = tanHalfFov * uv.x;\n\n    // GET DIRECTION\n    vec3 direction = normalize(vec3(nx, ny, 1.0));\n    vec3 newdir = normalize(center - cam_pos);\n    GetAngleBetVecRet v = angle_between_vectors(vec3(0.0, 0.0, 1.0), newdir);\n    direction = rotate_vector(direction, v.axis, v.theta);\n\n    // GET AXIS DIRECTIONS\n    vec3 up = normalize(cross(direction, vec3(0.0, 1.0, 0.0)));\n    vec3 right = normalize(cross(up, direction));\n    \n    // GET FOCUS DISTANCE\n    float focus_distance = length(center - cam_pos) * FOCAL_LENGTH;\n    \n    vec3 out_color = vec3(0.0, 0.0, 0.0);\n\n    if (USE_DOF) {\n        vec3 dof_color = vec3(0.0, 0.0, 0.0);\n        for (int i = 0; i < NUM_SAMPLES; i++) {\n            // GENERATE SAMPLE\n            float randX = (2.0 * rand(uv.xy + vec2(cos(float(i)), sin(float(i))))) - 1.0;\n            float randY = (2.0 * rand(uv.xy - vec2(sin(float(i)), cos(float(i))))) - 1.0;\n            vec3 aperture_offset = vec3(randX, randY, 0.0) * APERTURE;\n\n            // NEW ORIGIN / DIRECTION\n            vec3 new_cam_pos = cam_pos + aperture_offset;\n            vec3 focal_point = cam_pos + direction * FOCAL_LENGTH;\n            vec3 new_direction = normalize(focal_point - new_cam_pos);\n\n            // CALCULATE SAMPL<E\n            vec3 sampleColor = ray_march_fractal(new_cam_pos, new_direction);\n\n            // ACCUMULATE COLOR\n            dof_color = dof_color + sampleColor;\n        }\n        // GET AVERAGE COLOR\n        dof_color = dof_color / float(NUM_SAMPLES);\n        out_color = dof_color;\n    }\n    else {\n        out_color = ray_march_fractal(cam_pos, direction);\n    }\n\n    // OUTPUT COLOR\n    \n    fragColor = vec4(out_color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int BRACKET_LEFT = 219;\nconst int BRACKET_RIGHT = 221;\n\nvec3 handleKeyboard(vec3 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(-1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    float fov_up = texelFetch(iChannel1, ivec2(BRACKET_RIGHT, 0), 0).x * -1.0;\n    float fov_down = texelFetch(iChannel1, ivec2(BRACKET_LEFT, 0), 0).x * 1.0;\n    \n    offset.xy += (left + up + right + down) * velocity;\n    offset.z += (fov_up + fov_down) * velocity;\n    \n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec3 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xyz;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 65;\nconst int KEY_UP    = 87;\nconst int KEY_RIGHT = 68;\nconst int KEY_DOWN  = 83;\nconst int BRACKET_LEFT = 186;\nconst int BRACKET_RIGHT = 222;\n\nvec3 handleKeyboard(vec3 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    float fov_up = texelFetch(iChannel1, ivec2(BRACKET_RIGHT, 0), 0).x * -1.0;\n    float fov_down = texelFetch(iChannel1, ivec2(BRACKET_LEFT, 0), 0).x * 1.0;\n    \n    offset.xy += (left + up + right + down) * velocity;\n    offset.z += (fov_up + fov_down) * velocity;\n    \n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec3 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xyz;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0);\n}","name":"Buffer B","description":"","type":"buffer"}]}