{"ver":"0.1","info":{"id":"csdGR7","date":"1677420071","viewed":229,"name":"Raymarched AO and reflections","username":"Poisson","description":"A simple shader showing raymarched ambient occlusion and rough reflections + motion blur and antialiasing.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","ray","sdf","cubemap","raymarcher","box","ao","aa","ambient","skybox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2 // antialiasing, set it to 1 if you have a slow computer\n#define SHUTTER_SPEED 24. // motion blur amount\n\n// ACES tonemapping\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nfloat time; // time value\n\n// ray box intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nvec2 boxIntersect(vec3 ro, vec3 rd, vec3 ce, vec3 ra) {\n    vec3 oc = ro - ce;\n    vec3 m = 1./rd;\n    vec3 n = -m*oc;\n    vec3 k = abs(m)*ra;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\t\n\tif(tN>tF || tF<0.) return vec2(-1);\n    \n    return vec2(tN, tF);\n}\n\n// 2d rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a); // sine and cosine\n    return mat2(c, -s, s, c);\n}\n\n// random number between 0 and 1\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// 3d noise function by iq\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f); // S curve\n\n    float n = p.x + p.y*157. + 113.*p.z;\n\n    return mix(mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n                   mix(hash(n+157.), hash(n+158.),f.x),f.y),\n               mix(mix(hash(n+113.), hash(n+114.),f.x),\n                   mix(hash(n+270.), hash(n+271.),f.x),f.y),f.z);\n}\n\n// 3d fractal noise\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    f += .0625*noise(8.*p);\n    return f;\n}\n\n// box sdf\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// vec3 to vec3 hash (between 0 and 1)\nvec3 hash(vec3 p) {\n\tp = vec3(dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\n// scene sdf\nfloat map(vec3 p) {\n    float d = 1e10; // distance\n    \n    for (int i=0; i<8; i++) { // generate eight boxes\n        vec3 n = hash(vec3(2+i)); // random vec3\n        \n        vec3 q = p-sin(n*time)*vec3(1.25,1,1.25); // box position\n        q.yz *= rot(3.*sin(n.x*time-2.)); // rotation around the x axis\n        q.xz *= rot(2.*sin(n.x*time+7.)); // rotation around the y axis\n        \n        // add the box\n        float b = max(sdBox(q,vec3(.3,.15,.3))-.01, -sdBox(q,vec3(.2)));\n        d = min(d, b);\n    }\n    \n    // floor\n    d = min(d, sdBox(p-vec3(0,-1.3,0),vec3(1.8,.2,1.8)-.02)-.02);\n      \n    return d;\n}\n\n// raymarching function\nfloat intersect(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin; // distance travelled\n    \n    for (int i=0; i<256; i++) { // marching loop\n        vec3 p = ro + rd*t; // current point\n        \n        float h = map(p); // distance to the scene\n        if (h<.001) return t; // we hit the surface\n        \n        t += h; // march\n        if (t>tmax) break;\n    }\n    return -1.;\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p);\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy),\n                              map(p-e.yxy),\n                              map(p-e.yyx)));\n}\n\n// soft shadow function\n// thanks to iq: https://iquilezles.org/articles/rmshadows/\n// k is the softness of the shadow\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.; // final result\n    for (float t=0.; t<tmax;) {\n        vec3 p = ro + rd*t;\n        \n        float h = map(p);\n        if (h<.001) return 0.;\n        \n        res = min(res, k*h/t); // get the closest penumbra\n        t += h;\n    }\n    return res*res*(3.-2.*res); // S curve\n}\n\n// ambient occlusion function by me\n// ra is the occlusion distance\nfloat occlusion(vec3 p, vec3 n, float ra) {\n    float res = 0.;\n    const int N = 16; // samples\n        \n    for (int i=0; i<N; i++) {\n        float h = ra * float(i)/float(N); // sampling distance\n        res += clamp(.5+.5*map(p + n*h)/h,0.,1.);\n    }\n    res /= float(N);\n    \n    return res*res*res;\n}\n\nfloat pattern(vec3 p) {\n    return noise(p*1.5+3.*fbm(p*3.));\n}\n\n// cubemap texture\nvec3 skybox(vec3 rd) {\n    return vec3(1,.8,.8)*pow(texture(iChannel0, rd+.5*fbm(rd*5.)).rgb, 1.7*vec3(.5,1,1));\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = .35*skybox(rd); // background\n    \n    // bounding volume\n    vec2 bound = boxIntersect(ro, rd, vec3(0), vec3(1.8,1.5,1.8));\n    float tmin = bound.x;\n    float tmax = bound.y;\n    float t = intersect(ro, rd, tmin, tmax); // distance\n    \n    if (t>0.) { // we hit the surface\n        vec3 p = ro + rd*t; // hit point\n        vec3 n = calcNormal(p); // surface normal\n        vec3 r = reflect(rd, n); // reflected vector\n        \n        float occ = occlusion(p, n, .5); // ambient occlusion\n        float fre = 1.+dot(rd, n); // fresnel\n        float ref = shadow(p+n*.002, r, 4., 16.); // reflection\n        \n        // final color\n        col = vec3(0);\n        col += pattern(p*3.)*.1*occ*(.5+.5*n.y); // diffuse\n        col += .9*(.04+.96*pow(fre,5.))*ref*skybox(r); // specular\n    }\n    // output\n    return col*1.8;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // side vector\n    vec3 v = cross(u, w); // up vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0); // final color\n    \n    // AA for loops\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n        // motion blur\n        float mb = float(m + n*AA);\n        mb += texelFetch(iChannel1, ivec2(fragCoord)&1023, 0).x; // blue noise\n        time = 6.+iTime - mb/float(AA*AA) / SHUTTER_SPEED; // time value\n\n        float an = .3*time; // camera angle\n        vec3 ro = vec3(7.*sin(an),2.5,7.*cos(an)); // ray origin\n        vec3 ta = vec3(0); // target\n        mat3 ca = setCamera(ro, ta); // camera matrix\n\n        vec3 rd = ca * normalize(vec3(p,2.1)); // ray direction\n\n        // render\n        vec3 col = render(ro, rd);\n        \n        col = pow(col, vec3(.4545)); // gamma correction\n        col = ACES(col);\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    tot = tot*tot*(3.-2.*tot); // contrast\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .2+.8*pow(32. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    \n    tot = tot*vec3(1.3,1.2,1) - vec3(.15,.1,0); // color grading\n            \n    // output\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}