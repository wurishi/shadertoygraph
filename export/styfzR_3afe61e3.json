{"ver":"0.1","info":{"id":"styfzR","date":"1663918261","viewed":65,"name":"Ryan Menger Sponge","username":"rmccampbell7","description":"Menger sponge","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEPTH 4\n#define AA 2\n\n#define clamp01(x) clamp(x, 0., 1.)\n\nconst float TAU = 6.28318530718;\n\nstruct DistId {\n    float dist;\n    int matId;\n};\n\nstruct Material {\n    vec3 diff_color;\n    vec3 spec_color;\n    float shininess;\n    float reflectivity;\n};\n\nMaterial getMaterial(int matId) {\n    switch (matId) {\n    case 0: // Floor\n        return Material(vec3(.1), vec3(.25), 10., .5);\n    case 1: // Menger Sponge\n        return Material(vec3(.3), vec3(1.), 20., .8);\n    default:\n        return Material(vec3(0), vec3(0), 0., 0.);\n    }\n}\n\n\nfloat sdPlane(vec3 pos, vec3 norm, float d) {\n    return abs(dot(pos, norm) - d);\n}\n\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat udBox(vec3 pos, vec3 bounds) {\n    return length(max(abs(pos) - bounds, 0.));\n}\n\n\nfloat udMengerSponge(vec3 p, int depth) {\n    float d = udBox(p-.5, vec3(.5));\n    float s = 1.;\n    for (int i = 0; i < depth; i++) {\n        vec3 dd = (1./6. - abs(p - .5))*s;\n        d = max(d, min(dd.x, dd.y));\n        d = max(d, min(dd.y, dd.z));\n        d = max(d, min(dd.x, dd.z));\n        p = fract(3.*p);\n        s /= 3.;\n    }\n    return d;\n}\n\n\nfloat opUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat opIntersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat opSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nDistId opUnion(DistId a, DistId b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\n\nDistId map(vec3 pos) {\n    // Floor\n    DistId res = DistId(sdPlane(pos, vec3(0,1,0), -1.), 0);\n    // Cube\n    //res = opUnion(res, DistId(udBox(pos-vec3(0,5,0), vec3(5)), 1));\n    res = opUnion(res, DistId(udMengerSponge((pos-vec3(0,4,0))/8.+.5, DEPTH)*8., 1));\n    return res;\n}\n\n\nDistId castRay(vec3 origin, vec3 dir) {\n    float minDist = 1.;\n    float maxDist = 100.;\n\n    float t = minDist;\n    int matId = -1;\n    for (int i=0; i<128; i++) {\n        float eps = 1e-4*t;\n        DistId res = map(origin + dir*t);\n        matId = res.matId;\n        if (res.dist < eps || t > maxDist) break;\n        t += res.dist;\n    }\n    if (t > maxDist)\n        matId = -1;\n    return DistId(t, matId);\n}\n\n\nfloat softshadow(vec3 ro, vec3 rd) {\n    float res = 1.0;\n    for (float t=1.; t<10.;) {\n        float h = map(ro + rd*t).dist;\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, 8.*h/t);\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 1e-3;\n    return normalize(e.xyy * map(pos + e.xyy).dist +\n                     e.yxy * map(pos + e.yxy).dist +\n                     e.yyx * map(pos + e.yyx).dist +\n                     e.xxx * map(pos + e.xxx).dist);\n}\n\n\nvec3 shadeBase(vec3 pos, vec3 normal, vec3 dir, Material mat, bool shadows) {\n    float ambient = .12*(1.0 + .6*normal.y);\n\n    vec3 light1 = normalize(vec3(1, .5, -2));\n    float shadow1 = shadows ? softshadow(pos, light1) : 1.;\n    float diffuse = clamp01(dot(normal, light1)) * shadow1;\n    float specular = pow(clamp01(dot(reflect(-light1, normal), -dir)), mat.shininess) * shadow1;\n\n    vec3 light2 = normalize(vec3(1, 1, 3));\n    float shadow2 = shadows ? softshadow(pos, light2) : 1.;\n    diffuse += .8 * clamp01(dot(normal, light2)) * shadow2;\n    specular += .8 * pow(clamp01(dot(reflect(-light2, normal), -dir)), mat.shininess) * shadow2;\n\n    vec3 col = clamp01(diffuse + ambient)*mat.diff_color;\n    col += clamp01(specular)*mat.spec_color;\n\n    return clamp01(col);\n}\n\nvec3 render2(vec3 origin, vec3 dir) {\n    //vec3 col = vec3(.5, .8, 1.)*(1.+1.5*dir.y);\n    vec3 col = texture(iChannel0, vec3(-dir.z,dir.yx)).rgb;\n    DistId res = castRay(origin, dir);\n    if (res.matId >= 0) {\n        vec3 pos = origin + res.dist*dir;\n        col = shadeBase(pos, calcNormal(pos), dir, getMaterial(res.matId), false);\n    }\n    return col;\n}\n\n\nvec3 shade(vec3 pos, vec3 normal, vec3 dir, Material mat) {\n    vec3 col = shadeBase(pos, normal, dir, mat, true);\n    if (mat.reflectivity > 0.) {\n        col *= mix(vec3(1), render2(pos, reflect(dir, normal)), mat.reflectivity);\n    }\n    return col;\n}\n\nvec3 render(vec3 origin, vec3 dir) {\n    //vec3 col = vec3(.5, .8, 1.)*(1.+1.5*dir.y);\n    vec3 col = texture(iChannel0, vec3(-dir.z,dir.yx)).rgb;\n    DistId res = castRay(origin, dir);\n    if (res.matId >= 0) {\n        vec3 pos = origin + res.dist*dir;\n        col = shade(pos, calcNormal(pos), dir, getMaterial(res.matId));\n    }\n    return col;\n}\n\n\nmat3 lookAt(vec3 cameraPos, vec3 center, vec3 up) {\n    vec3 forward = normalize(center - cameraPos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy == vec2(0) ?\n        vec2(0) : (2.*iMouse.xy - iResolution.xy) / iResolution.xy;\n\n    float r = 20.;\n    float theta = TAU*(mouse.x*.5 + .25 + iTime/20.);\n    float phi = -mouse.y*TAU/4.;\n    vec3 cameraPos = vec3(r*cos(theta)*cos(phi), r*sin(phi)+5., r*sin(theta)*cos(phi));\n    vec3 center = vec3(0, 5, 0);\n    mat3 cameraRot = lookAt(cameraPos, center, vec3(0, 1, 0));\n\n    float fov = 45.0;\n    float screenDist = 1. / tan(fov/2.*TAU/360.);\n\n    vec3 col = vec3(0);\n    for (int i=0; i<AA; i++) {\n        for (int j=0; j<AA; j++) {\n            vec2 pix = fragCoord + vec2(i, j)/float(AA);\n            vec2 uv = (2.*pix - iResolution.xy) / iResolution.y;\n            vec3 rayDir = cameraRot * normalize(vec3(uv, screenDist));\n            col += render(cameraPos, rayDir);\n        }\n    }\n    col /= float(AA*AA);\n\n    // gamma\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}