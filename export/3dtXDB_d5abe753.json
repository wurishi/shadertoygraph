{"ver":"0.1","info":{"id":"3dtXDB","date":"1572981338","viewed":122,"name":"Horizontal scroller","username":"oktomus","description":"With the help of https://casual-effects.com/research/McGuire2019ProcGen/McGuire2019ProcGen.pdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n// Map functions.\n//\n// From https://github.com/msfeldstein/glsl-map.\n//\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat safeMap(float value, float inMin, float inMax, float outMin, float outMax)\n{\n    if (value > inMax)\n        return outMax;\n    else if (value < inMin)\n        return outMin;\n    else\n        return map(value, inMin, inMax, outMin, outMax);\n}\n\n\n//\n// Random functions\n//\n\nuint hash(uint x) \n{\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat random(uint hashed_value) \n{\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n    \n    hashed_value &= mantissaMask;\n    hashed_value |= one;\n\n    float  r2 = uintBitsToFloat(hashed_value);\n    return r2 - 1.0;\n}\n\n\nfloat random(float f) \n{    \n    return random(hash(floatBitsToUint(f)));\n}\n\nfloat random(vec2 v)\n{\n    uint hashed =\n        hash(\n            floatBitsToUint(v.x) \n            ^ hash(floatBitsToUint(v.y)));\n    return random(hashed);\n}\n\nfloat random(vec3 v)\n{\n    uint hashed =\n        hash(\n            floatBitsToUint(v.x) \n            ^ hash(floatBitsToUint(v.y))\n            ^ hash(floatBitsToUint(v.z)));\n    return random(hashed);\n}\n\n//\n// Utility functions.\n//\n\nfloat noise(float x) \n{\n    float \ti = floor(x), \n        \tf = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);    \n    return 2.0 * mix(random(i), random(i + 1.0), u) - 1.0;\n}\n\n//\n// Advanced functions.\n//\n\nvoid getSkyColor(vec2 uv, inout vec3 color)\n{\n    float h = max(0.0, 1.4 - uv.y - pow(abs(uv.x - 0.5), 3.0));\n    color.r = pow(h, 3.0);\n    color.g = pow(h, 7.0);\n    color.b = 0.2 + pow(max(0.0, h - 0.1), 10.0);    \n}\n\nfloat terrain(float x)\n{   \n    x += 0.1;\n    float y = 0.0;\n    float k;\n    for (int octave = 0; octave < 7; ++octave)\n    {\n        k = pow(2.0, float(octave));\n        y += noise(x * k) / k;\n    }\n\treturn y * 0.6 + 0.8;\n}\n\nfloat water(float x)\n{   \n    x += 0.5;\n    float y = 0.0;\n    float k;\n    for (int octave = 0; octave < 10; ++octave)\n    {\n        k = pow(2.0, float(octave));\n        y += noise(x * k) / k;\n    }\n\treturn y * 0.05 + 0.4;\n}\n\nfloat tree(float x, float h)\n{\n  \n    float k;\n    float y = noise(x * 81.5);\n    \n    return safeMap(h, 0.45, 0.55, 0.0, 1.0) * max(0.0, y * 0.2);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float shift = 0.09 * iTime + 0.2;\n    float x = uv.x + shift;\n\n    vec3 col;\n    \n    float h = max(water(x), terrain(x));\n    h += tree(x, h);\n    \n    if (uv.y < h)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {\n    \tgetSkyColor(uv, col);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}