{"ver":"0.1","info":{"id":"sdlfR8","date":"1644506078","viewed":90,"name":"Soft LoS, look into occluders","username":"WorkingJoe","description":"Soft shadows in 2D using raycasts and radial blur for penumbra. Click anywhere to cast the shadows.\n\nWith a too small step size occluders can be missed. Additionally, it is possible to see occluders behind other thin occluders if the in-depth is larger.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"Nssfz8","parentname":"Fork 2D soft sh WorkingJoe 804"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ########################## CONSTS ##########################\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n// TAU, 2*Pi\nconst float M_TAU = 6.28318530717958647692528676655900577;\n\n// The reciprocal of pi (1/pi)\nconst float M_1_PI = 0.318309886183790671537767526745028724;\n\n// ########################## INPUT PARAMS ##########################\n\n// Bias used to convert the noise to an occlusion map\nconst float BIAS = 0.75f;\n\n// Distance into objects that is seen\nconst float IN_DIST = 0.05f;\n\n// Number of radial samples in each direction taken for the penumbra\nconst int STEPS_PENUMBRA = 4;\n\n// Angle offset between the samples taken for the penumbra\nconst float ANGLE_PENUMBRA = 0.002f;\n\n// Strenght increase of the penumbra with distance from the occluder\nconst float FALLOFF_PENUMBRA = 0.75f;\n\n// Strength decrease of the effect of samples of the penumbra with angle from the viewray\nconst float ANGULAR_FALLOFF_PENUMBRA = 15.0f;\n\n// Maximum length of the raycasts\nconst float RAYLENGTH = 0.75f;\n\n// Strength with which the at the edge of the ray length\nconst float SIGHT_FALLOFF = 6.f;\n\n// Strength of the noise used to dither penumbra bands\nconst highp float NOISE_GRANULARITY = .2/255.0;\n\n\n// ########################## MAIN CODE ##########################\n\n// This shader calculates the actual shaders using the distances in the LUT\n// in buffer A. \n\nhighp float random(vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n// Classic function to calculate noise\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = iMouse.xy/iResolution.xy;\n    \n    vec2 norm = p-uv;\n\n    // Is done more often than inverse conversion?\n    float theta = 0.5f+0.5f*M_1_PI*atan(norm.y,norm.x);\n\n    // Occlusion\n    vec4 color = texture(iChannel0, uv);\n    \n    float dist = length(norm);\n    float dist_occluder = texture(iChannel0, vec2(theta,0.0f)).r;\n    \n    // Pixel is occluded if distance from p greater than ray hit\n    float shadow = 0.0f;\n    if(color.g>BIAS)\n        // On top of the occluder, reduce occlusion close to ray hit\n        shadow = max(0., dist-dist_occluder)/IN_DIST;\n    else\n        shadow = float(dist_occluder < dist);\n    \n    // Penumbra\n    float penumbra = 0.0f;\n    for(float angle=ANGLE_PENUMBRA; angle<=float(STEPS_PENUMBRA)*ANGLE_PENUMBRA; angle+=ANGLE_PENUMBRA)\n    {\n        // Can probably be optimised a bit further\n        penumbra += max(0.,(FALLOFF_PENUMBRA-angle*ANGULAR_FALLOFF_PENUMBRA)*(dist-texture(iChannel0, vec2(theta+angle+mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv+vec2(0.0f, iTime))),0.0f)).r));\n        penumbra += max(0.,(FALLOFF_PENUMBRA-angle*ANGULAR_FALLOFF_PENUMBRA)*(dist-texture(iChannel0, vec2(theta-angle+mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv+vec2(0.0f, iTime))),0.0f)).r));\n    }\n    \n    shadow += penumbra;\n    \n    shadow += max(0., 1.-SIGHT_FALLOFF*(RAYLENGTH-length(norm)));\n    \n    fragColor = vec4(0.5f-0.5f*shadow, color.g-shadow, 0.3*color.g, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ########################## CONSTS ##########################\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n// TAU, 2*Pi\nconst float M_TAU = 6.28318530717958647692528676655900577;\n\n// The reciprocal of pi (1/pi)\nconst float M_1_PI = 0.318309886183790671537767526745028724;\n\n// ########################## INPUT PARAMS ##########################\n\n// Bias used to convert the noise to an occlusion map\nconst float BIAS = 0.5f;\n\n// Number of steps per ray\nconst int STEPS = 256;\n\n// Maximal ray length\nconst float RAYLENGTH = 0.75f;\n\n// Amplitude of the noise in step size\nconst highp float NOISE_GRANULARITY = 1./255.0;\n\n// ########################## MAIN CODE ##########################\n\n// This shader pre-calculates the distance map used to draw the shadows.\n// The raycast function should be called for an Nx1 texture to create a LUT.\n// There will be a bit of branching, but this should still be performant \n// because of the small texture size\n\n// Because of shadertoy limitations RayCast is called for the full res of pixels\n// here rather than just a 1xN LUT, so all columns use the same calculation.\n\n\n// Classic function to calculate noise\nhighp float random(vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Calculate the value of the occlusion map at a certian coordinate \nfloat geometry(vec2 uv, float bias)\n{     \n    return step(bias, texture(iChannel0, uv).r);\n}\n\n// Calculate the distance of a ray from the center p in the direction theta\nfloat rayCast(vec2 p, float theta, float bias, float rayLength, int steps)\n{\n    float stepSize = rayLength/float(steps);\n    for(float y = 0.0f; y<rayLength; y+= stepSize){\n        vec2 coord = p + vec2(y * cos(theta), y * sin(theta));\n        if(texture(iChannel0, coord).r > bias)\n        {\n            return y;\n        }  \n    }\n    return rayLength;\n}\n\n// Store the distance in iResolution.y directions in the columns of the r channel\n// and store the occlusion map in the green channel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = iMouse.xy/iResolution.xy;\n\n    float geom = geometry(uv,BIAS);\n        \n    // vary ray length with time to ensure less funky business with clearly defined step size\n    // (especially at lower step sizes)\n    float raylength = RAYLENGTH + mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(vec2(uv.x, iTime)));\n    float ray = rayCast(p, M_TAU*uv.x, BIAS, raylength, STEPS);\n\n    \n    fragColor = vec4(ray,geom,0,1);\n}","name":"Buffer A","description":"","type":"buffer"}]}