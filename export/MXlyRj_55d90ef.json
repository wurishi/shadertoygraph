{"ver":"0.1","info":{"id":"MXlyRj","date":"1726439880","viewed":32,"name":"Raymarch template w/ flycam","username":"twixuss","description":".","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","ray","raymarch","camera","marching","template","control","fly","flycam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Left mouse button to look around\n// WASDQE to move, Shift to speed up\n// Input settings in Buffer A\n\n// Raymarch settings\n#define MAX_STEPS 512\n#define MAX_DIST 100.\n#define SURF_DIST 1e-3\n#define RAY_STEP_FACTOR 1.0\n\nfloat sdBox(vec3 p, vec3 radius) {\n    vec3 c = clamp(p, -radius, +radius);\n    if (c == p) {\n        vec3 d = abs(radius - p);\n        return -min(min(d.x, d.y), d.z);\n    }\n    return distance(p, c);\n}\n\nfloat scene_distance(vec3 p) {\n    float d = 1e30;\n    \n    d = min(d, sdBox(p - 0.5, vec3(0.5)));\n    \n    d = min(d, length(p - vec3(-0.5,0.5,-0.5)) - 0.5);\n    \n    d = min(d, p.y);\n    \n    return d;\n}\n\nstruct Material {\n    vec3 albedo;\n    float shiny;\n};\n\nMaterial scene_material(vec3 p) {\n    Material result;\n    \n    if (p.y < 1e-2) {\n        result.albedo = vec3(0.5);\n\n        vec2 t = abs(fract(p.xz+0.5)-0.5);\n        vec2 w = max(fwidth(p.xz), 1e-3);\n        result.albedo = mix(result.albedo, vec3(0.4), mapc(t.x - 0.02, -w.x, w.x, 1.0, 0.0));\n        result.albedo = mix(result.albedo, vec3(0.4), mapc(t.y - 0.02, -w.y, w.y, 1.0, 0.0));\n\n        t = abs(fract(p.xz*0.1+0.5)-0.5);\n        w = max(fwidth(p.xz*0.1), 1e-3);\n        result.albedo = mix(result.albedo, vec3(0.3), mapc(t.x - 0.003, -w.x, w.x, 1.0, 0.0));\n        result.albedo = mix(result.albedo, vec3(0.3), mapc(t.y - 0.003, -w.y, w.y, 1.0, 0.0));\n    } else {\n        result.albedo = vec3(0.9,0.6,0.3);\n    }\n    \n    result.shiny = 1.0;\n    \n    return result;\n}\n\nstruct RaymarchResult {\n    vec3 p;\n    float d;\n};\n\nRaymarchResult ray_march(vec3 ro, vec3 rd, float stepFactor) {\n\tRaymarchResult r; \n    \n    r.d = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*r.d;\n        float dS = scene_distance(p);\n        r.d += dS * stepFactor;\n        if(r.d>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    r.p = ro + rd * r.d;\n    \n    return r;\n}\n\nvec3 scene_normal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = scene_distance(p) - \n        vec3(scene_distance(p-e.xyy), scene_distance(p-e.yxy),scene_distance(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (1.0-ro.y)/rd.y;\n    if( tp>0.0 ) \n    tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=min(int(iTime),0); i<24; i++ )\n    {\n\t\tfloat h = scene_distance( ro + rd*t );\n        float s = clamp(2.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    LOAD_STATE;\n\n    vec3 ro = camPos.xyz;\n    vec3 rd = normalize(vec3(uv, 1));\n    rd.yz *= rotmat2(camRot.x);\n    rd.xz *= rotmat2(camRot.y);\n    \n    vec3 col = vec3(0);\n   \n    vec3 V = normalize(rd);\n   \n    RaymarchResult r = ray_march(ro, rd, RAY_STEP_FACTOR);\n    Material material;\n    if (r.d < MAX_DIST)\n        material = scene_material(ro+rd*r.d);\n\n    float depth = r.d;\n    \n    vec3 L = normalize(vec3(2,3,1));\n    vec3 ambient = vec3(.5,.7,.9);\n\n    if(r.d<MAX_DIST) {\n        vec3 N = scene_normal(r.p);\n        vec3 H = normalize(L-V);\n        vec3 dif = material.albedo * max(0.,dot(N, L));\n        vec3 indirect = material.albedo * ambient / PI;\n        float specular = pow(max(0.001, dot(N, H)), material.shiny * 100.) * pow(material.shiny, 2.0);\n\n        float lightness = calcSoftshadow(r.p, L, 0.02, 2.5);\n        dif *= lightness;\n        specular *= lightness;\n\n        col = dif + specular + indirect;\n    } \n    \n    vec3 sky = vec3(1.2, 1.1, 1.0) * pow(ambient, vec3((-dot(V,L)+1.) * 2.));\n\n    col = mix(col, sky, pow2(clamp(depth/MAX_DIST, 0.0, 1.0)));\n\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ENUMERATE_STATE(x) \\\n    x(camPos,   ivec2(0, 0)) \\\n    x(camRot,   ivec2(1, 0)) \\\n    x(oldMouse, ivec2(2, 0)) \\\n    x(didMove,  ivec2(3, 0)) \\\n    \n#define STATE_LOADER(name, loc) vec4 name = texelFetch(iChannel0, loc, 0);\n    \n#define LOAD_STATE ENUMERATE_STATE(STATE_LOADER)\n\n\n#define STATE_SAVER(name, loc) if (ivec2(fragCoord) == loc) fragColor = vec4(name);\n    \n#define SAVE_STATE ENUMERATE_STATE(STATE_SAVER)\n\n\n#define kdown(k) (texelFetch(iChannel1, ivec2(k, 1), 0).x > 0.5)\n#define kheld(k) (texelFetch(iChannel1, ivec2(k, 0), 0).x > 0.5)\n\n#define KSHIFT 16\n#define KALT 18\n#define K0 48\n#define K1 49\n#define K2 50\n#define K3 51\n#define K4 52\n#define K5 53\n#define K6 54\n#define K7 55\n#define K8 56\n#define K9 57\n#define KA 65\n#define KB 66\n#define KC 67\n#define KD 68\n#define KE 69\n#define KF 70\n#define KG 71\n#define KH 72\n#define KI 73\n#define KJ 74\n#define KK 75\n#define KL 76\n#define KM 77\n#define KN 78\n#define KO 79\n#define KP 80\n#define KQ 81\n#define KR 82\n#define KS 83\n#define KT 84\n#define KU 85\n#define KV 86\n#define KW 87\n#define KX 88\n#define KY 89\n#define KZ 90\n\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI*2.0)\n\n\nmat2 rotmat2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define pow2(x) ((x)*(x))\n\n#define map(v,a,b,c,d) ((v-a)/(b-a)*(d-c)+c)\n#define mapc(v,a,b,c,d) map(clamp(v,min(a,b),max(a,b)),a,b,c,d)\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KFORWARD KW\n#define KBACK    KS\n#define KLEFT    KA\n#define KRIGHT   KD\n#define KUP      KE\n#define KDOWN    KQ\n#define KSPEED   KSHIFT\n\n#define MOUSE_SENSITIVITY 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    LOAD_STATE;\n    \n    if (iFrame == 0) {\n        fragColor = vec4(0);\n        \n        // Setup initial camera orientation here\n        camPos.xyz = vec3(1.6,2,-5);\n        camRot.xyz = vec3(0.2,0.3,0);\n    }\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec4 mouse = iMouse;\n    \n    if (oldMouse.z > 0.0 && mouse.z > 0.0) {\n        vec2 ad = oldMouse.xy - mouse.xy;\n    \n        if (length(ad) > 1e-3) {\n            didMove.x = 1.;\n        }\n\n        camRot.yx += ad / 256. * float(MOUSE_SENSITIVITY);\n    }\n    \n    vec3 pd = vec3(\n        float(kheld(KRIGHT  )) - float(kheld(KLEFT)),\n        float(kheld(KUP     )) - float(kheld(KDOWN)),\n        float(kheld(KFORWARD)) - float(kheld(KBACK))\n    );\n    \n    if (length(pd) > 1e-3) {\n        didMove.x = 1.;\n    }\n    \n    if (kheld(KSHIFT)) {\n        pd *= 5.;\n    }\n    \n    if (kheld(KALT)) {\n        pd /= 5.;\n    }\n    \n    pd.yz *= rotmat2(camRot.x);\n    pd.xz *= rotmat2(camRot.y);\n    \n    if (didMove.x > 0.5) {\n        camPos.xyz += iTimeDelta * 10. * pd;\n    } else {\n        // Add initial camera animation here\n    }\n    \n    oldMouse = mouse;\n    \n    SAVE_STATE;\n}","name":"Buffer A","description":"","type":"buffer"}]}