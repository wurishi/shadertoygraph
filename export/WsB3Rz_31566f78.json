{"ver":"0.1","info":{"id":"WsB3Rz","date":"1547904484","viewed":163,"name":"Raining Spheres","username":"Elyxian","description":"Attempting to create a sparse distance field of 'randomly' placed spheres where a sample of the distance field doesn't need to calculate the position of the neighbouring spheres.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Returns the matrix that rotates a given point by 'a' radians\n\nmat2 mm2(in float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n\n}\n\nfloat saturate(float t) {\n\t\n    return clamp(t, 0.0, 1.0);\n    \n}\n\n// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat sphereDist(vec3 p) {\n\t\n    // Get the position of the current box and position in that box\n    float boxSize = 2.0;\n    vec3 i = floor(p / boxSize) * boxSize;\n    vec3 f = fract(p / boxSize) * boxSize;\n    \n    // Get the position of the center of the ball inside the box\n    // Designed so that the ball can't within a certain radius of the boundary of the box\n    float ballRadius = 0.025;\n    float edgeRadius = 0.1;\n    float radiusSum = ballRadius + edgeRadius;\n    vec3 hashVal = hash33(i);\n    //vec3 relativeSpherePos = vec3(boxSize / 2.0);\n    vec3 relativeSpherePos = vec3(radiusSum) + hashVal * (boxSize - 2.0 * radiusSum);\n    \n    // Get the distance to the sphere\n    float sphereDist = distance(f, relativeSpherePos) - ballRadius;\n    \n    // Get the distance to the nearest possible other circle box\n    float xDist = min(distance(f.x, -edgeRadius), distance(f.x, boxSize + edgeRadius));\n    float yDist = min(distance(f.y, -edgeRadius), distance(f.y, boxSize + edgeRadius));\n    float zDist = min(distance(f.z, -edgeRadius), distance(f.z, boxSize + edgeRadius));\n    float nearestBox = min(xDist, min(yDist, zDist));\n    \n    // Calculate and return a lower bound on the distance to the nearest sphere\n    float dist = min(sphereDist, nearestBox);\n    return dist;\n    \n}\n\nfloat distanceMap(vec3 p) {\n    \n  \tfloat dist = sphereDist(p);\n    return dist;\n    \n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n\t\n    // Parameters\n    int maxSteps = 200;\n    float maxDist = 250.0;\n    float surfaceDist = 0.005;\n    \n    // Main raymarching loop\n    float t = 0.0;\n    for (int i = 0; i < maxSteps; i++) {\n    \t\n        vec3 p = ro + t * rd;\n        float d = distanceMap(p);\n        \n        // A surface is found\n        if (d < surfaceDist) {\n        \treturn t;\n        }\n        \n        // The ray has travelled too far from the origin\n        if (t > maxDist) {\n        \treturn -1.0;\n        }\n        \n        t += d;\n    }\n    \n    // Too many steps were taken from the origin\n    return -1.0;\n\n}\n\nvec3 getNormal(vec3 p) {\n    \n    // Samples neighbouring points to generate a normal vector\n    vec2 eps = vec2(0.005, 0.00);\n    float dist = distanceMap(p);\n    vec3 normal = vec3(\n    \tdist - distanceMap(p - eps.xyy),\n\t\tdist - distanceMap(p - eps.yxy),\n\t\tdist - distanceMap(p - eps.yyx)\n    );\n    normal = normalize(normal);\n    return normal;\n    \n}\n\nvec3 getColor(vec3 p) {\n\t\n    // Directional light source\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n    \n    // The intensity/color of light (all three values are the same for white light)\n    vec3 lightCol = vec3(1.0);\n    \n    // Applies the 'base color' of the light\n    vec3 baseLightCol = vec3(1.0, 1.0, 1.0);\n    lightCol *= baseLightCol;\n    \n    // Applies normal-based lighting\n    vec3 normal = getNormal(p);\n    float normalLight = saturate(dot(normal, lightDir));\n    lightCol *= normalLight;\n    \n    // Applies hard-shadow lighting\n    //float eps = 0.01;\n    //bool isInShadow = (raymarch(p + normal * eps, lightDir) > 0.00);\n    //if (isInShadow) {\n    //\tlightCol *= 0.3;\n    //}\n    \n    // Gets the diffuse lighting\n    // Color function from iq https://www.shadertoy.com/view/Xds3zN\n   \t//vec3 diffuse = 0.45 + 0.35*sin(vec3(0.05,0.08,0.10)*(iTime*5.0));\n    //vec3 diffuse = vec3(0.992, 0.627, 0.251);\n    vec3 diffuse = vec3(0.663, 0.388, 0.106);\n    \n    // Get the final color\n    vec3 col = lightCol * diffuse;\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\t\n    float t = raymarch(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (t >= 0.0) {\n    \tcol = getColor(ro + t * rd);\n    }\n    \n    else {\n        col = vec3(0.9, 0.9, 0.9);\n    }\n    \n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, 0.0, 0.0) + vec3(0.0, 1.0, 0.0) * iTime;\n    vec3 rd = normalize(vec3(p, 0.9));\n\n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.2,0.2):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x);\n    \n    // Render and output the ray to screen\n    vec3 col = render(ro, rd);\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}