{"ver":"0.1","info":{"id":"WtyyWD","date":"1610987280","viewed":530,"name":"atan2 approximation","username":"nebbul","description":"two ways of doing an atan2 approximation\n\nno clue if this is cheaper or more expensive than the actual atan2() on the GPU - I suppose it should be?\n\natan2_approximation2(x, y) [b] seem to have some artefacts going to the corners of the screen","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["atan2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from:\n// https://gist.github.com/volkansalma/2972237\n// source:\n// http://dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization/\n\n#define PI_FLOAT     3.14159265f\n#define PIBY2_FLOAT  1.5707963f\n\nfloat atan2_approximation1(float y, float x)\n{\n    //http://pubs.opengroup.org/onlinepubs/009695399/functions/atan2.html\n    //Volkan SALMA\n\n    float ONEQTR_PI = PI_FLOAT / 4.0;\n\tfloat THRQTR_PI = 3.0 * PI_FLOAT / 4.0;\n\tfloat r, angle;\n\tfloat abs_y = abs(y) + 1e-10f;      // kludge to prevent 0/0 condition\n\tif ( x < 0.0f )\n\t{\n\t\tr = (x + abs_y) / (abs_y - x);\n\t\tangle = THRQTR_PI;\n\t}\n\telse\n\t{\n\t\tr = (x - abs_y) / (x + abs_y);\n\t\tangle = ONEQTR_PI;\n\t}\n\tangle += (0.1963f * r * r - 0.9817f) * r;\n\tif ( y < 0.0f )\n\t\treturn( -angle );     // negate if in quad III or IV\n\telse\n\t\treturn( angle );\n\n\n}\n\n// |error| < 0.005\nfloat atan2_approximation2( float y, float x )\n{\n\tif ( x == 0.0f )\n\t{\n\t\tif ( y > 0.0f ) return PIBY2_FLOAT;\n\t\tif ( y == 0.0f ) return 0.0f;\n\t\treturn -PIBY2_FLOAT;\n\t}\n\tfloat atan;\n\tfloat z = y/x;\n\tif ( abs( z ) < 1.0f )\n\t{\n\t\tatan = z/(1.0f + 0.28f*z*z);\n\t\tif ( x < 0.0f )\n\t\t{\n\t\t\tif ( y < 0.0f ) return atan - PI_FLOAT;\n\t\t\treturn atan + PI_FLOAT;\n\t\t}\n\t}\n\telse\n\t{\n\t\tatan = PIBY2_FLOAT - z/(z*z + 0.28f);\n\t\tif ( y < 0.0f ) return atan - PI_FLOAT;\n\t}\n\treturn atan;\n}\n\nfloat remap(float x, float in_min, float in_max, float out_min, float out_max)\n{\n    return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tiling = 13.0;\n    float speed = 0.0 * iTime / (1.0 / tiling);\n\n    float u = uv.x - 0.5;\n    float v = uv.y - 0.5;\n    \n    // atan2_a\n    float atan2_a = atan2_approximation1(u, v);\n    atan2_a = mod(remap(atan2_a, -PI_FLOAT, PI_FLOAT, 0.0, 1.0) * tiling + speed, 1.0);\n    \n    vec3 atan2_a_clr = vec3(atan2_a, atan2_a, atan2_a);\n    \n    // atan2_b\n    float atan2_b = atan2_approximation2(u, v);\n    atan2_b = mod(remap(atan2_b, -PI_FLOAT, PI_FLOAT, 0.0, 1.0) * tiling + speed, 1.0);\n    \n    vec3 atan2_b_clr = vec3(atan2_b, atan2_b, atan2_b);\n    \n    // ground truth atan2\n    float atan2 = atan(u, v);\n    atan2 = mod(remap(atan2, -PI_FLOAT, PI_FLOAT, 0.0, 1.0) * tiling + speed, 1.0);\n    \n    vec3 atan2_clr = vec3(atan2, atan2, atan2);\n\n    float line = (sin(iTime * 2.) + 1.0) / 2.0;\n    // compare approximation a and b\n    if(uv.x < line - 0.001) fragColor = vec4(atan2_a_clr, 1.0);\n    if(uv.x > line + 0.001) fragColor = vec4(atan2_b_clr, 1.0);\n    \n    // compare approximation a and ground truth\n    //if(uv.x < line - 0.001) fragColor = vec4(atan2_a_clr, 1.0);\n    //if(uv.x > line + 0.001) fragColor = vec4(atan2_clr, 1.0);\n    \n    // compare approximation b and ground truth\n    //if(uv.x < line - 0.001) fragColor = vec4(atan2_b_clr, 1.0);\n    //if(uv.x > line + 0.001) fragColor = vec4(atan2_clr, 1.0);\n}","name":"Image","description":"","type":"image"}]}