{"ver":"0.1","info":{"id":"fd3fR2","date":"1656770422","viewed":114,"name":"2D cubic caves","username":"alezen","description":"cubic caves procedural generation\ncan be expanded to 3d\n\nCONTROLS\nmove - LEFT, RIGHT, UP, DOWN","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["2d","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GRID_OUTLINE 0\n#define DEBUG 0\n\n#define NOISE_THRESHOLD .46\n#define CAVE_THRESHOLD .81\n#define SCALE 30.\n\n\nfloat caveNoiseValue(vec2 uv) {\n    vec2 gv = fract(uv);\n    vec2 gi = floor(uv);\n    float n = hash1(gi);\n    float rand = hash1(gi*20.)*2000.;\n    \n    float maskx = smoothstep(.5 - EPS, .5 + EPS,gv.x);\n    if(mod(rand,2.)<1.) maskx = 1.-maskx;\n    float masky = smoothstep(.5 - EPS,.5 + EPS,gv.y);\n    if(mod(rand,4.)<1.) masky = 1.-masky;\n    float mask = maskx*masky;\n    \n    const float threshold = NOISE_THRESHOLD;\n\n    return smoothstep(threshold - EPS,threshold + EPS,n)*mask;\n}\n\n#if DEBUG\nvec2\n#else\nfloat\n#endif\nperlinWorm(vec2 uv) {\n    float sum = EPS;\n    vec2 c = vec2(0.);\n    vec2 o;\n    for(o.y = -1.;o.y<=1.;o.y++)\n        for(o.x = -1.;o.x<=1.;o.x++) {\n            vec2 p = floor(uv*2.+o)*.5 + vec2(.25);\n            \n            float v = caveNoiseValue(p);\n            sum+=v;\n            c+=o*v;\n        }\n        \n    float d = sum*(3.-sum);\n    d *= smoothstep(0.,EPS, CAVE_THRESHOLD - length(c)/sum);\n    d = clamp(d , 0., 1.);\n#if DEBUG\n    return vec2(caveNoiseValue(uv), d);\n#else\n    return caveNoiseValue(uv) + d;\n#endif\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w = iMouse.x/iResolution.y;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec2 camPos = texelFetch(iChannel0, CAM_POS_LOCATION, 0).xy;\n    uv += camPos;\n    uv *= SCALE;\n    w *= SCALE;\n    vec3 uvw = vec3(uv,w);\n#if DEBUG\n    col = vec3(perlinWorm(uv),0.);\n#else\n    col = vec3(perlinWorm(uv));\n#endif\n    \n#if GRID_OUTLINE\n    vec2 outline = abs(fract(uv) - .5)*2.;\n    outline = smoothstep(1.-0.006*SCALE,1., outline);\n    float grid = max(outline.x, outline.y);\n    col =mix(col, vec3(0.,0.,1.), grid);\n#endif\n\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n#define SPEED 1.\nfloat getKey(int code)\n{\n    return texelFetch(iChannel0, ivec2(code,0),0).x;\n}\n\nvec2 getMotionVec2() {\n    return vec2(getKey(KEY_RIGHT)-getKey(KEY_LEFT),getKey(KEY_UP)-getKey(KEY_DOWN));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 outColor = vec4(0.);\n\n    vec4 val = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec2 motion = getMotionVec2();\n    \n    outColor = val;\n    outColor.xy += motion * SPEED * iTimeDelta;\n        \n    fragColor = outColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EPS .0000001\n\nfloat hash1(float p)\n{\n \tp = fract(p * 8794.45764);\n    p += p*(p + 34.23);\n    return fract(p);\n}\n\nfloat hash1(vec2 p)\n{\n \tp = fract(p * vec2(325.23454, 874.45764));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\nfloat hash1(vec3 p)\n{\n    return hash1(vec2(hash1(p.xy), p.z));\n}\n\nfloat noise(float p)\n{\n    float ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec2(1,0));\n    float o = p-ip;\n    o = smoothstep(0.,1.,o);\n    return a*(1. - o) + b*o;\n}\n\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec2(1,0));\n    float c = hash1(ip+vec2(0,1));\n    float d = hash1(ip+vec2(1,1));\n    vec2 o = p-vec2(ip);\n    o = smoothstep(0.,1.,o);\n    return (a*(1. - o.x) + b*o.x)*(1. - o.y) + (c*(1. - o.x) + d*o.x)*o.y;\n}\n\nfloat noise(vec3 p)\n{\n    vec3 ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec3(1,0,0));\n    float c = hash1(ip+vec3(0,1,0));\n    float d = hash1(ip+vec3(1,1,0));\n    \n    float a1 = hash1(ip + vec3(0,0,1));\n    float b1 = hash1(ip + vec3(1,0,1));\n    float c1 = hash1(ip + vec3(0,1,1));\n    float d1 = hash1(ip + vec3(1,1,1));\n    vec3 o = p-vec3(ip);\n    //o = 1.-cos(o*PI);\n    //o*=.5;\n    o = smoothstep(0.,1.,o);\n    return\n    ((a*(1. - o.x) + b*o.x)*(1. - o.y) + (c*(1. - o.x) + d*o.x)*o.y)*(1. - o.z) +\n    ((a1*(1. - o.x) + b1*o.x)*(1. - o.y) + (c1*(1. - o.x) + d1*o.x)*o.y)*o.z;\n}\n\n#define CAM_POS_LOCATION ivec2(1,1)\n\nbool isLocated(vec2 fragCoord, ivec2 location) {\n    return length(fragCoord-vec2(location)) < 1.;\n}","name":"Common","description":"","type":"common"}]}