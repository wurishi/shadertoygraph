{"ver":"0.1","info":{"id":"WtVGzK","date":"1580418569","viewed":161,"name":"Glider","username":"psandahl","description":"Take a ride in the glider and slowly travel the procedural world. Simple and mostly fake, but still quite nice.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fun and simple demo to explore more procedural techniques.\n// Patrik Sandahl, 2020.\n#define EPSILON 0.01\n#define FAR 100.0\n\n// Materials.\n#define NOTHING 0\n#define SKYSPHERE 1\n#define SEA 2\n#define GROUND 3\n\n#define CLOUD_INTENSITY 0.53\n#define SKYSPHERE_RADIUS 95.0\n#define TERRAIN_HEIGHT 9.0\n\n// Morning sky.\n#define ZENIT vec3(0.0 / 255.0, 5.0 / 255.0, 25.0 / 255.0)\n#define HORIZON vec3(71.0 / 255.0, 118.0 / 255.0, 172.0 / 255.0)\n\n// Object intersection.\nstruct Intersection {\n    float dist;\n    int material;\n};\n\n// A ray with origin and direction.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n     \n// Make a ray. The direction is forced to be normalized.\nRay makeRay(vec3 origin, vec3 direction);\n\n// Get a point a the given distance along the ray.\nvec3 point(Ray ray, float dist);\n\n// The position of the eye.\nvec3 eyePosition();\n\n// The view vector of the eye.\nvec3 viewVector();\n\n// The sun's direction.\nvec3 sunDirection();\n\n// The sun's color.\nvec3 sunColor();\n\n// The origo of the skysphere.\nvec3 skySphereOrigo();\n\n// Generate a camera ray.\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv);\n\n// Intersect the scene, and retrive the closest distance and its material.\nIntersection intersectScene(vec3 pos);\n\n// Ray march the scene.\nIntersection march(Ray ray, float far);\n\n// Color the skysphere.\nvec3 skySphere(Ray ray, float dist);\n\n// Color the sea.\nvec3 sea(Ray ray, float dist);\n\n// Color the ground.\nvec3 ground(Ray ray, float dist);\n\n// Distance function for a sphere.\nfloat sphere(vec3 pos, float radius);\n\n// Distance function for a plane.\nfloat plane(vec3 pos);\n\n// Fractional brownian motion.\nfloat fbm(vec2 x, int octaves);\nfloat fbm(vec3 x, int octaves);\n\n// Calculate the normal for a position.\nvec3 calcNormal(vec3 pos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\n    vec3 eye = eyePosition();\n    \n    Ray ray = cameraRay(eye, eye + viewVector(), vec3(0.0, 1.0, 0.0), 1.0, uv);    \n    Intersection intersection = march(ray, FAR);\n    \n    vec3 pos = point(ray, intersection.dist);\n\n    vec3 color = vec3(0.0);\n    float fogMix = 0.0;\n    switch (intersection.material) {\n        case SKYSPHERE:\n        {\n            color = skySphere(ray, intersection.dist);\n            // A little fog at the horizon line.\n            fogMix = 1.0 - clamp(pos.y / 1.2, 0.0, 1.0);\n        }\n        break;\n        \n        case SEA:\n        {\n            color = sea(ray, intersection.dist);\n            fogMix = smoothstep(FAR - 3.0, FAR, intersection.dist);\n        }        \n        break;\n        \n        case GROUND:\n        {\n        \tcolor = ground(ray, intersection.dist);\n            fogMix = smoothstep(FAR - 3.0, FAR, intersection.dist);\n        }\n        break;\n        \n        default:\n        \t// Make unknown things red.\n        \tcolor = vec3(1.0, 0.0, 0.0);\n        \tbreak;\n    }\n        \n    vec3 fog = vec3(0.3, 0.3, 0.33);\n    \n    color = mix(color, fog, fogMix);\n    color = pow(color, vec3(1.0 / 1.6));\n    color *= 1.-dot(uv,uv)*.7;\n    \n    fragColor = vec4(color, 1.0);\n}\n\nRay makeRay(vec3 origin, vec3 direction)\n{\n    return Ray(origin, normalize(direction));\n}\n\nvec3 point(Ray ray, float dist)\n{\n    return ray.origin + ray.direction * dist;\n}\n\nvec3 eyePosition()\n{\n    vec3 start = vec3(149.0, 28.0, 1927.0);\n    start.z = iTime;\n    \n    return start;\n}\n\nmat2 calcRotate2d(float theta)\n{\n    return mat2(vec2(cos(theta), -sin(theta)), vec2(sin(theta), cos(theta)));\n}\n\nvec3 viewVector()\n{    \n    vec3 dir = normalize(vec3(0.0, -0.23, 1.0));\n    dir.xz = calcRotate2d(iTime * 0.01) * dir.xz;\n    return dir;\n}\n\nvec3 sunDirection()\n{\n    return normalize(vec3(4.0, 1.0, 0.0));\n}\n\nvec3 sunColor()\n{\n    return vec3(0.75, 0.7, 0.65);\n}\n\nvec3 skySphereOrigo()\n{\n    vec3 origo = eyePosition();\n    origo.y = 0.0;\n    return origo;\n}\n\nRay cameraRay(vec3 eye, vec3 at, vec3 up, float focalLength, vec2 uv)\n{\n    vec3 zAxis = normalize(at - eye);\n    vec3 xAxis = normalize(cross(zAxis, up));\n    vec3 yAxis = cross(xAxis, zAxis);\n    \n    vec3 center = eye + zAxis * focalLength;\n    vec3 xy = center + uv.x * xAxis + uv.y * yAxis;\n    \n    return makeRay(eye, xy - eye);\n}\n\nIntersection intersectScene(vec3 pos)\n{\n    // We're inside the skysphere, so the distance is negative. That's\n    // why the abs is needed.\n    float sdSky = abs(sphere(pos - skySphereOrigo(), SKYSPHERE_RADIUS));\n    \n    // Sea.\n    float sdSea = plane(pos);\n    \n    // Ground.\n    float sdGround = pos.y - fbm(pos.xz * 0.01, 10) * TERRAIN_HEIGHT;    \n    \n    if (sdSky < sdSea && sdSky < sdGround) {\n        return Intersection(sdSky, SKYSPHERE);\n    } else if (sdSea < sdSky && sdSea < sdGround) {\n        return Intersection(sdSea, SEA);\n    } else {\n        return Intersection(sdGround, GROUND);\n    }\n}\n\nIntersection march(Ray ray, float far)\n{\n    Intersection intersection = Intersection(far, NOTHING);\n    float d0 = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        vec3 pos = point(ray, d0);\n        intersection = intersectScene(pos);\n        \n        d0 += intersection.dist;\n        if (intersection.dist < EPSILON) break;\n        if (d0 >= far) {\n            intersection.material = NOTHING;\n            break;\n        }\n    }\n    \n    intersection.dist = d0;\n    \n    return intersection;\n}\n\nvec3 skySphere(Ray ray, float dist)\n{\n    // Intersection point of the sphere - must be transformed\n    // back to global origo for the uv mapping to work.\n    vec3 pos = point(ray, dist) - skySphereOrigo();  \n                           \n    // Normalize position.\n    pos = pos / length(pos);\n        \n    vec3 offset = pos * CLOUD_INTENSITY;\n    offset.xy += iTime * 0.0025;\n    vec3 cloud = vec3(abs(fbm(offset, 8)));\n            \n    // Sky color gradient.\n    vec3 sky = mix(ZENIT, HORIZON, smoothstep(0.5, 0.0, pos.y));\n            \n    return mix(sky, cloud * 1.4, smoothstep(0.0, 0.5, cloud.x));            \n}\n\nvec3 sea(Ray ray, float dist)\n{    \n    vec3 pos = point(ray, dist);\n    \n    // The sea is a flat plane, but the normals are manipulated to give the\n    // impression of waves.\n    vec3 n0 = vec3(0.0); // Origo.\n    vec3 n1 = vec3(1.0, cos(pos.x * 5.1 + iTime) * 0.002, 0.0); // Vector in x dir.\n    vec3 n2 = vec3(0.0, cos(pos.z * 8.1 + iTime) * 0.004, 1.0); // Vector in z dir.\n    \n    vec3 normal = normalize(cross(normalize(n2 - n0), normalize(n1 - n0)));    \n        \n \tvec3 reflectDir = reflect(ray.direction, normal);\n    \n    Ray reflectRay = makeRay(pos + vec3(0.0, EPSILON * 2.0, 0.0), reflectDir);\n    \n    Intersection intersection = march(reflectRay, FAR);\n\n    // The base color for the sea.\n    vec3 color = vec3(0.0);    \n    switch (intersection.material) {\n        case SKYSPHERE:\n            color = mix(color, skySphere(reflectRay, intersection.dist), 0.5);        \n        \tbreak;\n        \n        case GROUND:\n        \tcolor = mix(color, ground(reflectRay, intersection.dist), 0.5);\n        \tbreak;\n        \n        default:\n        \t// Mark unknown things yellow.\n        \tcolor = vec3(1.0, 1.0, 0.0);\n        \tbreak;\n    }\n        \n    return color;\n}\n\nvec3 ground(Ray ray, float dist)\n{\n    vec3 pos = point(ray, dist);\n    vec3 normal = calcNormal(pos);\n    float diffuse = dot(normal, sunDirection());\n    \n    vec3 diffuseLight = diffuse * sunColor();\n    \n    vec3 clay = vec3(127.0 / 255.0, 95.0 / 255.0, 63.0 / 255.0);\n    vec3 fern = vec3(79.0 / 255.0, 121.0 / 255.0, 66.0 / 255.0);\n    vec3 forest = vec3(11.0 / 255.0, 102.0 / 255.0, 35.0 / 255.0);\n    vec3 granite = vec3(97.0 / 255.0, 97.0 / 255.0, 97.0 / 255.0);\n    vec3 snow = vec3(1.0, 250.0 / 255.0, 250.0 / 255.0);\n    \n    float offset = abs(pos.y) / 4.0;\n    \n    vec3 color = mix(clay, fern, smoothstep(0.0, 0.1, offset));\n    color = mix(color, forest, smoothstep(0.1, 0.3, offset));\n    color = mix(color, granite, smoothstep(0.3, 0.6, offset));\n    color = mix(color, snow, smoothstep(0.65, 1.0, offset));\n    \n    return color * diffuseLight;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat plane(vec3 pos)\n{\n    return pos.y;\n}\n\nvec3 permute(vec3 x) \n{ \n    return mod(((x*34.0)+1.0)*x, 289.0); \n}\n\nfloat snoise(vec2 v)\n{\n  \tconst vec4 C = vec4(0.211324865405187, 0.366025403784439,\n  \t\t\t\t        -0.577350269189626, 0.024390243902439);\n  \tvec2 i  = floor(v + dot(v, C.yy) );\n  \tvec2 x0 = v -   i + dot(i, C.xx);\n  \tvec2 i1;\n    \n  \ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  \tvec4 x12 = x0.xyxy + C.xxzz;\n  \tx12.xy -= i1;\n  \ti = mod(i, 289.0);\n  \tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  \t                + i.x + vec3(0.0, i1.x, 1.0 ));\n  \tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    \t\t dot(x12.zw,x12.zw)), 0.0);\n  \tm = m*m;\n  \tm = m*m;\n  \tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n  \tvec3 h = abs(x) - 0.5;\n  \tvec3 ox = floor(x + 0.5);\n  \tvec3 a0 = x - ox;\n  \tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  \tvec3 g;\n  \tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n  \tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  \treturn 130.0 * dot(m, g);\n}\n\nfloat fbm(vec2 x, int octaves)\n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < octaves; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x) {return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v)\n{ \n  \tconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  \tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n  \tvec3 i = floor(v + dot(v, C.yyy) );\n  \tvec3 x0 = v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n  \tvec3 g = step(x0.yzx, x0.xyz);\n  \tvec3 l = 1.0 - g;\n  \tvec3 i1 = min( g.xyz, l.zxy );\n  \tvec3 i2 = max( g.xyz, l.zxy );\n\n  \t//  x0 = x0 - 0. + 0.0 * C \n  \tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  \tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  \tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n\t// Permutations\n  \ti = mod(i, 289.0 ); \n  \tvec4 p = permute( permute( permute( \n    \t              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        \t   \t\t  + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients\n\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  \tfloat n_ = 1.0/7.0; // N=7\n  \tvec3  ns = n_ * D.wyz - D.xzx;\n\n  \tvec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  \tvec4 x_ = floor(j * ns.z);\n  \tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  \tvec4 x = x_ *ns.x + ns.yyyy;\n  \tvec4 y = y_ *ns.x + ns.yyyy;\n  \tvec4 h = 1.0 - abs(x) - abs(y);\n\n  \tvec4 b0 = vec4( x.xy, y.xy );\n  \tvec4 b1 = vec4( x.zw, y.zw );\n\n  \tvec4 s0 = floor(b0)*2.0 + 1.0;\n  \tvec4 s1 = floor(b1)*2.0 + 1.0;\n  \tvec4 sh = -step(h, vec4(0.0));\n\n  \tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  \tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  \tvec3 p0 = vec3(a0.xy,h.x);\n  \tvec3 p1 = vec3(a0.zw,h.y);\n  \tvec3 p2 = vec3(a1.xy,h.z);\n  \tvec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n  \tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  \tp0 *= norm.x;\n  \tp1 *= norm.y;\n  \tp2 *= norm.z;\n  \tp3 *= norm.w;\n\n\t// Mix final noise value\n  \tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  \tm = m * m;\n  \treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                  dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm(vec3 pos, int numOctaves) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < numOctaves; ++i) {\n\t\tv += a * snoise(pos);\n\t\tpos = pos * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat calcDiffEpsilon(float dist)\n{\n    // Estimating some sort of epsilon usable for normal calculations.\n    float res = max(iResolution.x, iResolution.y);\n    float eps = mix(0.1, 0.4, 1.0 - smoothstep(320.0, 2560.0, res));\n    \n    return mix(eps, eps * 4.0, dist / SKYSPHERE_RADIUS);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    float dist = intersectScene(pos).dist;\n    vec2 e = vec2(calcDiffEpsilon(dist), 0.0);\n    \n    vec3 n = dist - vec3(\n        intersectScene(pos - e.xyy).dist,\n        intersectScene(pos - e.yxy).dist,\n        intersectScene(pos - e.yyx).dist\n    );\n    \n    return normalize(n);\n}","name":"Image","description":"","type":"image"}]}