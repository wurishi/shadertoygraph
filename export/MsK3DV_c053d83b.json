{"ver":"0.1","info":{"id":"MsK3DV","date":"1474385550","viewed":490,"name":"sky rendering","username":"public_int_i","description":"Sky rendering.\nHere's a more refined version where you can save the generated cubemap http://xaloez.com/projects/projects/skybox%20renderer/index.html ","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["sky","rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ethan Alexander Shulman 2016\n//displays cubemap\n\n\n\n// CREDITS\n//glk7(genis sole)'s cube mapping functions https://www.shadertoy.com/view/XdKGW1\n\n\n#define pi 3.1415926\n\n\n\n//cube map to texture functions are from glk7(genis sole)'s shader https://www.shadertoy.com/view/XdKGW1\nfloat aspect;\nvec2 dirToMap(in vec3 d) {\n        vec3 c = 0.5 / d;\n    vec3 t = min(-c, c);\n    float f = max(max(t.x, t.y), t.z);\n    \n    vec3 p = -d*f;\n    vec3 n = step(1e-7, abs(p + 0.5)) - step(1e-7, abs(0.5 - p));\n    \n    vec2 px = vec2(-p.z*n.x, p.y) * abs(n.x);\n    vec2 py = vec2(p.x*n.y, -p.z) * abs(n.y);\n    vec2 pz = vec2(p.x*n.z, p.y) * abs(n.z);\n\n    float tx = ((1.0 - step(-0.5, n.z))*2.0 + \n                abs(n.x) + (1.0 - step(-0.5, n.x))*2.0) * (1.0 - abs(n.y)) +\n                (1.0 - step(-0.5, n.y))*3.0 * abs(n.y);\n    \n\tfloat ty = abs(n.y) * (1.0 - (2.0 - 4.0/aspect));\n    \n    vec2 uv = (vec2(tx, ty) + (px + py + pz) + 0.5) * vec2(0.25, aspect*0.25);\n    return uv;\n}\n\nvec2 rot(vec2 p, float a) {\n    return p*mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    //shoddy projection\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    vec2 mc = vec2(iMouse.y/iResolution.y*-pi,\n                   iMouse.x/iResolution.x*pi*2.);\n    if (iMouse.w < 1.0) {\n        mc = vec2(-2.4,2.0);\n    }\n    rd.yz = rot(rd.yz,mc.x);\n    rd.xz = rot(rd.xz,mc.y);\n    \n    //display cubemap\n    aspect = iResolution.x/iResolution.y;\n\tfragColor = pow( texture(iChannel0, dirToMap(rd))/float(iFrame-120),\n                     vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n//cloud/sky rendering and storing in texture as cubemap\n\n// CREDITS\n//glk7(genis sole)'s cube mapping functions https://www.shadertoy.com/view/XdKGW1\n\n\n\n//constants and sky parameters\n#define pi 3.1415926\n#define iterations 512\n#define minDelta .2\n#define maxDelta .6\n#define range 1024.\n#define yRange 64.\n\nconst vec3 sunDirection = normalize(vec3(1.,-0.3,0.)),\n    \t   sunColor = vec3(1.,.74,.94)*2.,\n    \t   skyColor = vec3(40., 70., 130.)/255.,\n    \t   cloudColor = vec3(.99),\n    \t   ambientColor = vec3(.95,.46,.75),\n    \t   cloudMovement = vec3(0., 100., 0.);\n\nconst float sunSize = .01,//0-1, relative to the result of dot product\n    \t\tcloudDensity = .3,//0-2, density/alpha of the clouds\n    \t\tcloudFluff = .8,//0-1, fluffiness/alpha fade of clouds\n    \t\tcloudRoughness = 0.,//0-1, roughness of the clouds features\n            ambientDensity = .01,//0-2, global mist\n    \t\tcloudCoverage = .5;//0-1, the amount of sky the clouds cover\n\n\n\n#define devrender 0\n\n\n//texture to cube map functions are from glk7(genis sole)'s shader https://www.shadertoy.com/view/XdKGW1\nfloat square(float x) \n{\n\treturn floor(3.0*x) - 2.0*floor(1.5*x);    \n}\n\nvec3 CubemapNormal(in vec2 tile) \n{   \n    float s = (2.0*square((tile.x + 1.0)*0.5) - 1.0);\n    \n    float x = square(tile.x) * square(tile.y + 1.0) * s;\n    float y = square(tile.y) * s;\n    float z = square(tile.x + 1.0) * square(tile.y + 1.0) * s;\n \n    return vec3(x, y, z);\n}\nvec3 mapToDir(in vec2 fragCoord) {\n    vec2 t = fragCoord.xy*vec2(4.0, 2.0) / iResolution.xy;\n    vec3 n = CubemapNormal(floor(t));\n    \n    float g = 4.0 / iResolution.x;\n    float vo = iResolution.x*0.5 - iResolution.y;\n    \n    vec2 xzp = fract(min(vec2(4.0, 0.99999), fragCoord.xy * g));\n    \n    vec2 ypp = vec2(min(0.99999, fragCoord.x * g), max(1.0, (fragCoord.y + vo) * g));\n    vec2 ypn = vec2(max(3.0,     fragCoord.x * g), max(1.0, (fragCoord.y + vo) * g));\n    vec2 yp = fract(ypp * step(-0.5, n.y) + ypn * (1.0 - step(-0.5, n.y)));\n    \n    vec2 p = (xzp * (1.0 - abs(n.y)) + yp * abs(n.y)) - 0.5;\n    \n    vec3 px = vec3(0.5*n.x, p.y, -p.x*n.x) * abs(n.x);\n    vec3 py = vec3(p.x*n.y, 0.5*n.y, -p.y) * abs(n.y);\n    vec3 pz = vec3(p.x*n.z, p.y, 0.5*n.z) * abs(n.z);\n    \n   \tvec3 rd = px + py + pz; \n    return normalize(rd);\n}\n\n\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 randomHemiRay(in vec3 d, in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n//random ray using p as a seed\nvec3 randomRay(in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand;\n}\n\n//static backgrund\nvec3 background(vec3 d) {\n    float sun = dot(normalize(sunDirection), d);\n    return mix(skyColor,\n               sunColor,\n               max(pow(max(0.,sun*.5),2.),\n                   pow(max(0., sun-(1.-sunSize))/sunSize,.3)));\n}\n\n//distance function defining the clouds shape\nfloat df(vec3 p) {\n    float dst = 60.-max(abs(fract(p.x/60.)*60.-30.),\n                       abs(fract(p.z/60.)*60.-30.));\n    \n    for (int k = 0; k < 2; k++) {\n        float fp = floor(p.x/60.-float(k)*.5)+floor(p.z/60.-float(k)*.5)*64.;\n        vec3 lp = vec3( mod(p.xz-float(k)*30.,60.)-30., p.y+20.+hash(fp*.00972+.0247)*20.).xzy;\n        if (hash(fp*.00368) < cloudCoverage) {\n            vec3 sz;\n            sz.x = 1.+pow(hash(fp*.00124),1.-cloudCoverage)*20.;\n            sz.z = 1.+pow(hash(fp*.00124+249.234),1.-cloudCoverage)*20.;\n            sz.y = 1.+hash(fp*.00124+732.512)*max(sz.x,sz.z);\n            \n            float ldst = length(max(abs(lp)-\n                                    sz,\n                                    0.))-1.;\n            for (int i = 1; i < 4; i++) {\n                float pfi = pow(float(i),2.);\n                ldst += (cos(p.x/pfi+cos(26.2348+ldst*cloudRoughness+(p.y*.39)/pfi)*4.)*\n                         cos(p.y/pfi+cos(29.8937+ldst*cloudRoughness+(p.z*.37)/pfi)*4.)*\n                         cos(p.z/pfi+cos(14.9725+ldst*cloudRoughness+(p.x*.41)/pfi)*4.))*pfi;\n            }\n            dst = min(dst, ldst);\n        }\n    }\n    /*\n        max( length(p-vec3(0.,-10.,0.))-5.,\n              dst);\n    */\n    return max(.2, dst);\n}\n//calculates density of cloud from distance d and point p\nfloat dstToDensity(float d, vec3 p) {\n    return mix(cloudDensity, ambientDensity, min(1., (d-.1)*(1.-cloudFluff)));\n}\n\nvec3 normal(vec3 p) {\n    const vec2 NE = vec2(1, 0.);\n    return normalize(vec3( df(p+NE.xyy)-df(p-NE.xyy),\n                           df(p+NE.yxy)-df(p-NE.yxy),\n                           df(p+NE.yyx)-df(p-NE.yyx) ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 120) {\n        //initialize frame data\n        fragColor = vec4(0.);\n        return;\n    }\n       \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //ray direction from uvs and ray position at origin\n    vec3 rd = mapToDir(fragCoord),\n         ird = rd,\n         rp = cloudMovement;\n    \n    float ifrm = float(iFrame);\n    #define rndifrm(s) fract(fract(ifrm*.044877+s)*256.494+ifrm*.02934)\n    \n    vec4 c = vec4(1,1,1,0);\n    \n    #if devrender == 0\n    \n    \n    //render\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp),\n              dt = d*(minDelta+hash3(rp+rndifrm(rp)*1024.)*(maxDelta-minDelta)),\n              k = dstToDensity(d,rp);\n        if (k*max(1.,dt*.1) > hash3(rp+rndifrm(rp)*256.)) {//if density > random then ray hits cloud\n            c.xyz *= pow(mix(cloudColor,ambientColor,min((d-.1)*(1.-cloudFluff),1.)),\n                             vec3(1.));\n            c.w = 1.;\n            rd = mix(sunDirection, randomRay(rp+rndifrm(rp*1024.)*1024.), floor(hash3(rp*.9+rndifrm(rp*1.5)*512.)+.5));\n            //rd = mix(sunDirection, randomRay(rp+rndifrm(rp)*1024.), floor(hash3(rp+rndifrm(rp)*512.)+.5)*clamp(max(d,abs(d)-abs(df(rp-sunDirection))),0.,1.));\n        }\n        \n        rp += rd*dt;\n        if (max(length(rp.xz-cloudMovement.xz)/range,max(0.,-rp.y)/yRange) > 1.) break;\n    }\n   \n    c.xyz *= background(rd)*float(max(length(rp.xz-cloudMovement.xz)/range,max(0.,-rp.y)/yRange) > 1.);//if light ray makes it too edge of world illuminate it  \n    fragColor = mix(vec4(background(ird),1.), c, c.w)+texture(iChannel0, uv);//blend result with background and add to buffer\n\n    \n    \n    \n    #else\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp);\n        if (d < .2 || c.w > range) break;\n        \n        rp += rd*d;\n        c.w += d;\n    }\n    if (df(rp) < .2) {\n       c = vec4(cloudColor*(.3+max(0.,(df(rp)-df(rp-sunDirection)))),1.);\n    } else {\n       c = vec4(background(ird),1.); \n    }\n    fragColor = c+texture(iChannel0,uv);\n    #endif\n}","name":"Buf A","description":"","type":"buffer"}]}