{"ver":"0.1","info":{"id":"Xc2fzR","date":"1724585833","viewed":25,"name":"metashapes 595811366887422226","username":"HaleyHalcyon","description":"asasas","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sasasasa"],"hasliked":0,"parentid":"XfsBDs","parentname":"triangle in triangle ___________"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TURN = 2. * acos(-1.);\n#define QTURN (TURN * 0.25)\n#define ROT(x) mat2x2(cos((x) + vec4(0, QTURN, -QTURN, 0)))\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n\n/* vec3 colormap(float x){\n    const int colorCount = 16;\n    vec3[] c = vec3[](\n        HEX(0xfaf875),\n        HEX(0xfcfc26),\n        HEX(0xbcde26),\n        HEX(0x5CC863),\n        \n        HEX(0x1FA088),\n        HEX(0x33638D),\n        HEX(0x3D4285),\n        HEX(0x1F0269),\n        \n        HEX(0x25024D),\n        HEX(0x430787),\n        HEX(0x6F00A8),\n        HEX(0x9814A0),\n        \n        HEX(0xC23C81),\n        HEX(0xF07F4F),\n        HEX(0xFDB22F),\n        HEX(0xFAEB20)\n    );\n    int lo = int(floor(x));\n    \n    return mix(\n        c[lo],\n        c[(lo + 1) % colorCount],\n        fract(x)\n    );\n}*/\n\nvec3 colormap(int x) {\n    vec3[] c = vec3[](\n        //vec3(0),\n        HEX(0xe020c0),\n        HEX(0xf0e040),\n        HEX(0xc0ff80),\n        vec3(1),\n        HEX(0xa0ffe0),\n        HEX(0x7080F0),\n        HEX(0x8000a0)\n    );\n    return c[x % 7];\n}\n\nfloat polygonR(float theta, float sides) {\n    // pi over S appears a lot\n    float pi_s = 0.5 * TURN / sides;\n    // figured this out on desmos\n    //return cos(pi_s) / cos(mod(theta + pi_s, 2.0 * pi_s) - pi_s);\n    return  cos(pi_s) / cos(mod(theta + pi_s, 2.0 * pi_s) - pi_s);\n}\n\n// mask for that regular `sides`-gon\nfloat shapeV(vec2 xy, float sides) {\n    return step(\n        length(xy) * 16.0,\n        polygonR(\n            atan(xy.x, xy.y),\n            sides\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 3 rotate, 1 change side count\n    float t = mod(iTime, 12.);\n    float tCycle = mod(iTime, 4.);\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n    \n    float canvasRot =\n    2.0 + smoothstep(\n        0.0, 1.0, t\n    ) - 2.0 * step(\n        1.0, t\n    ) + smoothstep(\n        4.0, 5.0, t\n    ) - 0.8 * step(\n        5.0, t\n    ) + 0.8 * smoothstep(\n        8.0, 9.0, t\n    );\n    \n    float canvasScale = 1.0 - 0.75 * (\n        smoothstep(1.75, 2.25, mod(t + 2.0, 4.0)) -\n        smoothstep(2.75, 3.25, mod(t + 2.0, 4.0))\n    );\n    \n    uv *= canvasScale * ROT(QTURN * canvasRot);\n\n    float sides = 3.0 + smoothstep(\n        0.0, 1.0, t\n    ) + smoothstep(\n        4.0, 5.0, t\n    ) - 2.0 * smoothstep(\n        8.0, 9.0, t\n    );\n    \n    vec4 col = vec4(0);\n    float rotateBy = (smoothstep(0.0, 1.0,\n        smoothstep(1.0, 4.0, tCycle)\n    ) - 0.5) / sides;\n    float scale = polygonR((rotateBy) * TURN, sides);\n    float LAYERS = mix(1.0, 128., step(1.0, tCycle));\n    for (float i = 0.; i < LAYERS; i++) {\n        vec2 rotated = vec2(\n            uv.x   * cos((rotateBy + .5/sides) * i * TURN)\n            + uv.y * sin((rotateBy + .5/sides) * i * TURN),\n            uv.y   * cos((rotateBy + .5/sides) * i * TURN)\n            - uv.x * sin((rotateBy + .5/sides) * i * TURN)\n        );\n        float v = shapeV(\n            rotated * pow(scale, i),\n            sides\n        );\n        col = mix(\n            col,\n            vec4(colormap(\n                int(i)\n                + 3\n                //+ int(tCycle > 1.0) * iFrame\n            ), 1.),\n            v\n        );\n        if (col.a == 1.0) break;\n    }\n    //col.rgb = vec3(fract(atan(uv.x, uv.y)));\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}