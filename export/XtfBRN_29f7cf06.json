{"ver":"0.1","info":{"id":"XtfBRN","date":"1511192109","viewed":2210,"name":"Fluid Sandbox","username":"riouxld","description":"Add obstacles with LEFT CLICK, reset fluid by pressing SPACEBAR (keeps obstacles).\nChange radius of drawn obstacles in all buffer.\nA Lot of energy is lost due to large time-step and bad poisson solver.","likes":40,"published":1,"flags":48,"usePreview":0,"tags":["simulation","fluid","advection","multipass","navierstokes","jacobi","multistep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Variation of a precedent project\n// https://www.shadertoy.com/view/MllBzr\n\n\n\n\n\n//macro\n\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n#define GetDensity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).z\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).w\n#define GetDivergence(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).y\n#define GetVorticity(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).z\n\nfloat isKeyPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// COLORMAP\nfloat segment(float edge0, float edge1, float x)\n{\n    return step(edge0,x) * (1.0-step(edge1,x));\n}\n\n\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\n\n\nvec3 ice(float t)\n{\n   return vec3(t, t, 1.0);\n}\n\nvec3 fire(float t)\n{\n    return mix( mix(vec3(1,1,1), vec3(1,1,0), t),\n                mix(vec3(1,1,0), vec3(1,0,0), t*t), t);\n}\n\nvec3 ice_and_fire(float t)\n{\n    return segment(0.0,0.5,t) * ice(2.0*(t-0.0)) +\n           segment(0.5,1.0,t) * fire(2.0*(t-0.5));\n}\n\n\n// for testing purpose, https://www.shadertoy.com/view/4dlczB\nvec3 blackbody(float t)\n{\n\tfloat Temp = t*7500.0;\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    // no-flow inside obstacle\n    float stateij = GetState(0,0);   \n    \n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0.5);\n        return;\n    }\n    \n    \n\t/// show field\n    vec2 vit = GetVelocity(0,0); \n    float pres = GetPressure(0,0); \n    float dens = GetDensity(0,0); \n    float div = GetDivergence(0,0);\n    float vort = GetVorticity(0,0);\n    \n\n    if ( isKeyPressed(KEY_ONE)!=0.0 )\n    {\n        fragColor =vec4(hot(0.25*(length(vit)+1.0)),1);\n        //fragColor =vec4(1.0-hot(0.5*(length(vit)+1.0)),1);\n        return;\n    }\n    if ( isKeyPressed(KEY_TWO)!=0.0 )\n    {\n        fragColor =vec4(1.0-hot(0.0005*(pres+800.0)),1);\n        \n        return;\n    }\n    if ( isKeyPressed(KEY_THREE)!=0.0 )\n    {\n        fragColor =vec4(1.0-hot(0.1*(div+5.0)),1);\n        \n        return;\n    }\n    if ( isKeyPressed(KEY_FOUR)!=0.0 )\n    {\n        fragColor =vec4(1.0-hot(0.1*(vort+5.0)),1);\n        return;\n    }\n\n    //fragColor = vec4(ice_and_fire(clamp(dens,0.01,0.99)),1);\n    //fragColor = vec4(1.0-blackbody(1.0-dens),1);\n    fragColor = vec4(blackbody(dens),1);\n  \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Set initial condition / reset / obstacle / advection / force\n\n\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n#define GetDensity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).z\n#define GetVorticity(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).z\n\n#define GetVelocityUV(XY) texture( iChannel3, vec2(XY)).xy\n#define GetDensityUV(XY) texture( iChannel3, vec2(XY)).z\n\nfloat isKeyPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x;\n}\n\nvec2 Euler(vec2 posUV){\n    return dt*GetVelocityUV(posUV);\n}\n\nvec2 Runge(vec2 posUV){\n    vec2 k1 = GetVelocityUV(posUV);\n    vec2 k2 = GetVelocityUV(posUV-0.5*k1*dt);\n    vec2 k3 = GetVelocityUV(posUV-0.5*k2*dt);\n    vec2 k4 = GetVelocityUV(posUV-k3*dt);\n    return dt/6.*(k1+2.0*k2+2.0*k3+k4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    //set die parameters\n    float bandWidth = 1.0/float(bandDens*bandNb);\n    float gapWidth = (1.0-float(bandNb)*bandWidth)/float(bandNb+1);\n    \n    \n    \n    // initial condition\n    if (iFrame==0) {\n        float densityAdv = 0.;\n        \n        // set obstacle\n        float pert = length((fragCoord.xy) / iResolution.y-  vec2(0.15,0.5));   \n        if( pert < (1.5*radiusObs)) {\n            fragColor = vec4(0,0,0,1);\n            return;\n        }\n        \n        for (int k = 1;k<=bandNb;k++)\n        {\n            if (uvCoord.y >= gapWidth*float(k)+bandWidth*float(k-1) && \n                uvCoord.y <=  gapWidth*float(k)+bandWidth*float(k))\n            {\n                densityAdv = clamp(source*4.0*uvCoord.y*(1.0-uvCoord.y),0.0,0.5);\n                break;\n            }\n        }\n        fragColor = vec4(flowSpeed*uvCoord.y*(1.0-uvCoord.y),0,densityAdv,0);\n        return;\n    }\n    // set obstacle\n    float pert = length((fragCoord.xy - iMouse.xy) / iResolution.y);   \n    if(iMouse.z > 0.0 && pert < radiusObs) {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    \n    // no-flow inside obstacle\n    float stateij = GetState(0,0);\n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    \n    // restet fluid keep obstacles\n    if ( isKeyPressed(KEY_SPACE)!=0.0 )\n    {\n        fragColor = vec4(flowSpeed*uvCoord.y*(1.0-uvCoord.y),0,0,stateij);\n        return;\n    }\n    \n    // advect via semi-lagrangian method\n    \n    vec2 posUV =fragCoord/iResolution.xy;\n    #ifdef EULER\n    vec2 posAdvUV = posUV-Euler(posUV);\n    #endif\n    #ifdef RUNGE\n    vec2 posAdvUV = posUV-Runge(posUV);\n    #endif\n    \n    vec2 vitAdv;\n    if(posAdvUV.x <= 0.0)  vitAdv = vec2(flowSpeed*posAdvUV.y*(1.0-posAdvUV.y),0.0);\n    else vitAdv = GetVelocityUV(posAdvUV);\n        \n    float densityAdv = GetDensityUV(posAdvUV)/(1.0+dt*alpha);\n\n    \n    // vorticity confinement\n    //to compute density finite difference approximaton\n    \n    float vortij = GetVorticity(0,0); \n    float vortip1j = GetVorticity(1,0); \n    float vortim1j = GetVorticity(-1,0); \n    float vortijp1 = GetVorticity(0,1); \n    float vortijm1 = GetVorticity(0,-1);\n    \n    vec3 gradVort = vec3(vortip1j-vortim1j,vortijp1-vortijm1,0.0);\n    vec3 psi = gradVort / (length(gradVort)  + 1e-8);\n    vec2 fv = cross(psi,vec3(0.0,0.0,vortij)).xy;\n    \n    vitAdv += epsilon*dt*dx*fv;\n\t\n    \n    // add force and sources\n    vitAdv += dt*force;\n    \n    if(ijCoord.x == 0)\n    {\n        for (int k = 1;k<=bandNb;k++)\n        {\n            if (uvCoord.y >= gapWidth*float(k)+bandWidth*float(k-1) && \n                uvCoord.y <=  gapWidth*float(k)+bandWidth*float(k))\n            {\n                densityAdv = clamp(densityAdv+dt*source*4.0*uvCoord.y*(1.0-uvCoord.y),0.0,1.0);\n                break;\n            }\n        }\n    }\n    \n    fragColor = vec4(vitAdv, densityAdv, 0); \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// solve for diffusion\n\n\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n#define GetDensity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).z\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    //set die parameters\n    float bandWidth = 1.0/float(bandDens*bandNb);\n    float gapWidth = (1.0-float(bandNb)*bandWidth)/float(bandNb+1);\n    \n    // no-flow inside obstacle\n    float stateij = GetState(0,0);\n    float stateip1j = GetState(1,0);\n    float stateim1j = GetState(-1,0);\n    float stateijp1 = GetState(0,1);\n    float stateijm1 = GetState(0,-1);    \n\n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    //to compute velocity finite difference approximaton\n    vec2 vitij = GetVelocity(0,0); \n    vec2 vitip1j = mix(GetVelocity(1,0),-vitij, stateip1j);\n    vec2 vitim1j = mix(GetVelocity(-1,0),-vitij, stateim1j);\n    vec2 vitijp1 = mix(GetVelocity(0,1),-vitij, stateijp1);\n    vec2 vitijm1 = mix(GetVelocity(0,-1),-vitij, stateijm1);\n    \n    \n    //to compute density finite difference approximaton\n    float densij = GetDensity(0,0); \n    float densip1j = mix(GetDensity(1,0),-densij, stateip1j);\n    float densim1j = mix(GetDensity(-1,0),-densij, stateim1j);\n    float densijp1 = mix(GetDensity(0,1),-densij, stateijp1);\n    float densijm1 = mix(GetDensity(0,-1),-densij, stateijm1);\n    \n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        vitip1j = vitij;\n        densip1j = densij;\n    }\n    \n    if(ijCoord.x == 0)\n    {\n        vitim1j = 2.0*vec2(flowSpeed*uvCoord.y*(1.0-uvCoord.y),0.0)-vitij;\n        densim1j =-densij;\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        vitijp1 = -vitij;\n        densijp1 = -densij;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        vitijm1 = -vitij; \n        densijm1 = -densij; \n    }\n    \n   \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    float coef = dt/(dxPow*reynold);\n    vec2 vitaux = (vitij+coef*(vitip1j+vitim1j+vitijp1+vitijm1))/(1.0+4.0*coef);\n \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    coef = kappa*dt/(dxPow);\n    float densDiff = (densij+coef*(densip1j+densim1j+densijp1+densijm1))/(1.0+4.0*coef);\n \n    \n    fragColor = vec4(vitaux,densDiff,0.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// solve for pressure\n\n\n//macro\n\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).w\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    \n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // no-flow inside obstacle\n    float stateij = GetState(0,0);\n    float stateip1j = GetState(1,0);\n    float stateim1j = GetState(-1,0);\n    float stateijp1 = GetState(0,1);\n    float stateijm1 = GetState(0,-1);    \n\n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    //to compute velocity finite difference approximaton\n    vec2 vitauxij = GetVelocity(0,0); \n    vec2 vitauxip1j = mix(GetVelocity(1,0),-vitauxij, stateip1j);\n    vec2 vitauxim1j = mix(GetVelocity(-1,0),-vitauxij, stateim1j);\n    vec2 vitauxijp1 = mix(GetVelocity(0,1),-vitauxij, stateijp1);\n    vec2 vitauxijm1 = mix(GetVelocity(0,-1),-vitauxij, stateijm1);\n    \n    //to compute pressure finite difference approximaton\n    float presij = GetPressure(0,0); \n    float presip1j = mix(GetPressure(1,0),presij,stateip1j);\n    float presim1j = mix(GetPressure(-1,0),presij,stateim1j);\n    float presijp1 = mix(GetPressure(0,1),presij,stateijp1);\n    float presijm1 = mix(GetPressure(0,-1),presij,stateijm1);\n    \n    \n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        vitauxip1j = vitauxij;\n        presip1j = presij;\n    }\n    if(ijCoord.x == 0)\n    {\n        vitauxim1j =  2.0*vec2(flowSpeed*uvCoord.y*(1.0-uvCoord.y),0.0)-vitauxij;\n        presim1j = -presij;\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        vitauxijp1 = -vitauxij;\n        presijp1 = presij;\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        vitauxijm1 =  -vitauxij;\n        presijm1 = presij;\n    }\n    \n    \n    // compute velocity divergence\n    float div = 0.5*(vitauxip1j.x-vitauxim1j.x+vitauxijp1.y-vitauxijm1.y)/dx;\n    float vort = 0.5*(vitauxijp1.y-vitauxim1j.y + vitauxijp1.x-vitauxijm1.x)/dx;\n    // should use more than 1 iteration...\n    // compute pressure (auxiliary) via jacobi iteration... \n    float presDiff = 0.25*((presip1j+presim1j)+(presijp1+presijm1)-dxPow*reynold*div/dt);\n        \n    fragColor = vec4(presDiff, div, vort,0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// project for incompressibility\n\n\n\n//macro\n#define GetState(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).w\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetDensity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).z\n\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n#define GetDivergence(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).y\n\nfloat pres(float coef, ivec2 ijCoord,int i, int j){\n    \n    \n    float stateip1j = GetState(i+1,j);\n    float stateim1j = GetState(i-1,j);\n    float stateijp1 = GetState(i,j+1);\n    float stateijm1 = GetState(i,j-1);    \n    \n    \n    float div = GetDivergence(i,j); \n    float presij = GetPressure(i,j); \n    \n    \n    float presip1j = mix(GetPressure(i+1,j),presij,stateip1j);\n    float presim1j = mix(GetPressure(i-1,j),presij,stateim1j);\n    float presijp1 = mix(GetPressure(i,j+1),presij,stateijp1);\n    float presijm1 = mix(GetPressure(i,j-1),presij,stateijm1);\n    \n// set outer boundary conditions\n    if(ijCoord.x >=  int(iResolution.x)-1)\n    {\n        presip1j = presij;\n    }\n    if(ijCoord.x <= 0)\n    {\n        presim1j = -presij;\n    }\n    if(ijCoord.y >=  int(iResolution.y)-1)\n    {\n        presijp1 = presij;\n    }\n    \n    if(ijCoord.y <= 0)\n    {\n        presijm1 = presij;\n    }\n    \n    return 0.25*((presip1j+presim1j)+(presijp1+presijm1)-coef*div);\n}\n\n\nfloat pres2(float coef, ivec2 ijCoord,int i, int j){\n    float div = GetDivergence(i,j); \n    float presij = pres(coef, ijCoord, i,j);\n    float presip1j = pres(coef, ijCoord, i+1,j);\n    float presim1j = pres(coef, ijCoord, i-1,j);\n    float presijp1 = pres(coef, ijCoord, i,j+1);\n    float presijm1 = pres(coef, ijCoord, i,j-1);\n    \n\n\n    return 0.25*((presip1j+presim1j)+(presijp1+presijm1)-coef*div);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    float coef = dxPow*reynold/dt;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // no-flow inside obstacle\n    float stateij = GetState(0,0);\n    float stateip1j = GetState(1,0);\n    float stateim1j = GetState(-1,0);\n    float stateijp1 = GetState(0,1);\n    float stateijm1 = GetState(0,-1);    \n\n    if (stateij == 1.0) \n    {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    //to compute diveergence finite difference approximaton\n    //to compute velocity finite difference approximaton\n    vec2 vitauxij = GetVelocity(0,0); \n    \n    \n    float presij = pres2(coef, ijCoord, 0,0);\n    float presip1j = pres(coef, ijCoord, 1,0);\n    float presim1j = pres(coef, ijCoord, -1,0);\n    float presijp1 = pres(coef, ijCoord, 0,1);\n    float presijm1 = pres(coef, ijCoord, 0,-1);\n    \n    \n    \n    //compute gradiant of pressure\n    vec2 presGrad = 0.5*vec2(presip1j-presim1j, presijp1-presijm1)/dx;\n    \n    //projection (helmholtz-hodge) to obtain divergence free\n    vec2 vit;\n    \n    if (ijCoord.x < 10 ) {\n        vit = vec2(flowSpeed*uvCoord.y*(1.0-uvCoord.y),0.0);\n    }\n    else\n    {\n        vit = vitauxij-dt/reynold*presGrad;\n    }\n    float dens = GetDensity(0,0);\n    \n    \n    \n    \n    \n    fragColor = vec4(vit, dens, presij);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// THE FELOWWING MUST BE MODFIED IN ALL BUFFER AND IMAGE (until macro)\n\n\n//Select scheme to do backward advection\n//#define EULER\n#define RUNGE\n\n// radius of obstacle \n#define radiusObs 0.03\n\n// simulation parameters\nconst float dt = 1.0/500.0; //time-stepping\nconst vec2 force = vec2(0., 0.); //constant pressure gradiant flow\nconst float reynold = 25000.0; //constant defining the flow ~high=water, ~low=vscous\n\t\t\t\t\t\t\t //large reynold number, diffuse substance faster.\n\nconst float flowSpeed = 4.0; // max speed of flow\nconst float source = 1.0; //source density\nconst float kappa = 0.0; //substance diffusion constant\nconst float alpha = 0.1; //substance dissipation rate\n\nconst int bandNb = 20; //number of die line\nconst int bandDens = 6; //density of die line (high mean less dense)\n\n// Keyboard\nconst int KEY_ONE  = 49;\nconst int KEY_TWO  = 50;\nconst int KEY_THREE  = 51;\nconst int KEY_FOUR  = 52;\nconst int KEY_FIVE  = 53;\n\nconst int KEY_SPACE  = 32;\nconst int KEY_C  = 67;\n\nconst float epsilon = 30.0;","name":"Common","description":"","type":"common"}]}