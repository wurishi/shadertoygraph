{"ver":"0.1","info":{"id":"Ws3fz7","date":"1604603497","viewed":95,"name":"Ray Marching - 2D Circle","username":"yonng","description":"Refer to the great tutorial: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nSimple Ray Tracing Tutorial: https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n#define SURF_DIST .01\n\n/**\n * Signed distance function for a sphere centered at the 's' point with arbitrary radius;\n */\nfloat sphereSDF(vec3 samplePoint, float radius) {\n    vec4 s = vec4(0,1,6,radius);   //Z component is the distance from the screen\n    return length(samplePoint - s.xyz) - s.w;\n}\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd,float radius)\n{\n     float d0 =0.;\n     for (int i=0;i<MAX_MARCHING_STEPS;i++)\n     {\n          vec3 p = ro + rd*d0;\n          float ds = sphereSDF(p, radius);\n          d0+=ds;\n         \n         if(d0 > MAX_DIST || ds<SURF_DIST) break;\n         \n     }\n    \n    return d0;\n    \n}\n                                \n                            \n//return the normalized direction from the eye point for a single pixel\n//currently, I am not using this way for the rayDirection\nvec3 rayDirection(float fieldofView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size /2.0;  //change coordinates to the center\n    float z = size.y / tan(radians(fieldofView)/2.0);\n    return normalize(vec3(xy,-z));   \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  //make it equally in the 2 directions\n\n    vec3 ro = vec3(0.0,1,0.0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));   //this is the way I am using for the ray direction, directly go from the screen\n    \n    float t = iTime;  //use iTime to vary the radius\n    float radius = sin(t)+1.5;\n    float d = RayMarch(ro,rd,radius);\n    \n    if(d> MAX_DIST - EPSILON){\n         fragColor = vec4(0.0,0.0,0.0,0.0);\n         return ;\n    }\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n}","name":"Image","description":"","type":"image"}]}