{"ver":"0.1","info":{"id":"4cGcDW","date":"1732176516","viewed":80,"name":"CapsuleTileRayIntersection","username":"bloxard","description":"This is a RayIntersect version of this shader https://www.shadertoy.com/view/4fcyW7\nRaymarching require a loop and in this case it can be optimized using RayIntersect.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["ray","tile","intersect","capsule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is a RayIntersect version of this shader https://www.shadertoy.com/view/4fcyW7\nRaymarching require a loop and in this case it can be optimized using RayIntersect.\n*/\n\n#define TILE_SIZE 32.0\n#define MAX_DIST 1e10\n\nfloat RayLineSegmentDistance(vec3 ro, vec3 rd, vec3 pa, vec3 pb)\n{\n    vec3 pbpaD = pb-pa;\n\tfloat bL = length(pbpaD);\n\tvec3 pD = pbpaD/bL;\n\tvec3 prD = pa-ro;\n\tfloat rDp = dot(rd,pD);\n\tfloat rDpr = dot(rd,prD);\n\tfloat pDpr = dot(pD,prD);\n\tfloat u = (rDpr-pDpr*rDp)/(1.-rDp*rDp);\n\tfloat v = max(min(u*rDp-pDpr,bL),0.);\n\tu = max(min(v*rDp+rDpr,1e6),0.);\n\treturn length((ro+rd*u)-(pa+pD*v));\n}\n\nfloat iCapsule(in vec3 ro, in vec3 rd, out vec3 normal, in vec3 pa, in vec3 pb, in float r)\n{\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if (h >= 0.)\n    {\n        float t = (-b-sqrt(h))/a;\n        float d = MAX_DIST;\n        float y = baoa + t*bard;\n        if (y>0. && y<baba) // body\n        {\n            d = t;\n        }\n        else // caps\n        {\n            vec3 oc = (y <= 0.) ? oa : ro - pb;\n            b = dot(rd,oc);\n            c = dot(oc,oc) - r*r;\n            h = b*b - c;\n            if (h>0.0)\n            {\n                d = -b - sqrt(h);\n            }\n        }\n        vec3 pa = ro + rd * d - pa;\n        float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n        normal = (pa - h*ba)/r;\n        return d;\n    }\n    return MAX_DIST;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3( cos(iTime*0.17)*0.67, sin(iTime*0.23)*0.4,0.);\n    vec3 ta = vec3( 0.0, 0.0, 0.6 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.2,1.,0.) ) );\n    vec3 vv = normalize( cross(uu,ww));   \n    vec3 color = vec3(0.0);\n    vec3 normal = vec3(0.);\n    float a = cos(iTime*0.37)*3.8;\n    vec3 pa = vec3(cos(a*1.7)*0.8,-sin(a)*0.3,1.2+cos(iTime*0.04)*0.5);\n    vec3 pb = vec3(-cos(a*2.)*0.3,sin(a*0.34)*-0.5,1.7+sin(iTime*0.07)*0.4);\n    float r = 0.15;\n    vec2 pCenter = (2.*((floor(fragCoord / TILE_SIZE) + vec2(0.5,0.5)) * TILE_SIZE) - iResolution.xy)/iResolution.y; \n    vec3 rdCenter = normalize(pCenter.x*uu + pCenter.y*vv + 1.5*ww);\n    float d = RayLineSegmentDistance(ro,rdCenter,pa,pb);\n    if(d > (0.21+clamp((800./iResolution.x)-1.,0.0,0.09)))\n    {\n        color += vec3(0.2,0.3,0.4);\n    }\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    float t = iCapsule(ro, rd, normal, pa, pb, r);\n    if (t < MAX_DIST)\n    {\n        color = (dot(rd, -normal) + 0.3) * vec3(0.5,0.6,0.7);\n    }\n    if (uint(fragCoord.x) % uint(TILE_SIZE) == 0u || uint(fragCoord.y) % uint(TILE_SIZE) == 0u)\n    {\n        color = vec3(1.);\n    }\n\tfragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}