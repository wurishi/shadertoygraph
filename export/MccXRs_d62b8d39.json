{"ver":"0.1","info":{"id":"MccXRs","date":"1714569518","viewed":38,"name":"Collatz Fractal4 -Fastaro","username":"robfast","description":"another collatz","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math","recursion","collatzconjecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float collatzconv(float x, int maxIter){\nint iter=0;\n    while (x > 1.0 && iter < maxIter) {\n        float prevX = x;\n        x = floor((3.0 * x + 1.0) * mod(x, 2.0) + (x / 2.0) * (1.0 - mod(x, 2.0)));\n        iter++;\n        if (x == prevX) break;\n        // Prevent infinite loops\n        return float(iter)/x;\n    }\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Transform pixel coordinates to [-1,1] range for both axes\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    // Time-based dynamics for continuous sequence generation\n    float timeOffset = mod(iTime,9.2); // Every 10 seconds change base\n    float base = 2.0 + floor(timeOffset*29.7); // Change base from 1 to 10\n\n    // Calculate sequence value and Collatz path dynamically\n    float x = smoothstep(0.0,1.0,base + length(uv) * 1.0); // Starting value based on position\n    float originalX = x;\n    int steps = 0;\n    float steps2=0.0;\n    float n = 4.0*base + 1.0;\n    \n    const int maxSteps = 266; // Maximum steps to simulate Collatz convergence\n\n    // Simulate the sequence generation and its path back to 1\n\n    int iter = 0;\n    int maxIter = 21;  \n    float normalizedSteps = smoothstep(0.0,1.0,float(collatzconv(steps2,maxSteps))) / float(maxSteps);\n    float radius = float(iter)*iTime / float(maxIter);\n    float angle = smoothstep(-9.0,10.0,atan(uv.y, uv.x)); // Angle in polar coordinates\n    \n     for(int i = 0; i < maxSteps; i++) {\n        radius = radius + 1.0;\n        angle = (4.0 + 3.0 * n) * pow(4.0, angle);\n        angle /= 3.0;  // Apply your sequence formula\n        steps2++;\n        if(i<maxSteps){  normalizedSteps = smoothstep(0.0,1.0,float(collatzconv(0.0,(maxSteps))) / float(i)); n= 4.0*n+1.0;\n     \n        break; } // Escape condition\n    \n    \n    }\n\n    \n   \n\n\n\n    // Use steps to determine color; more steps -> closer to red\n\n    \n    \n    // Draw each point based on its Collatz path length\n\n\n    // Position points in a spiral based on their original base value\n    float spiralRadius = 0.02 + 0.05 * base; // Spiral radius grows with base\n     float theta =  3.14159* angle;\n    // Map to cartesian coordinates for output\n    vec2 pos = smoothstep(0.0,1.0,vec2(radius/(117.0)-spiralRadius *0.2*rand(uv)* cos(theta), (0.2)-1.0/rand(uv)*spiralRadius * sin(theta)));\n    vec3 color =  smoothstep(0.0,1.0,vec3(cos(length(pos)*4.5),\n                      sin(length(pos)*-normalizedSteps),\n                      12.0+ cos(length(pos))));\n    \n    \n    if(length(pos - uv) < spiralRadius){ // Check proximity to the calculated position\n        fragColor = vec4(color, 1.0); }// Assign color based on steps\n    else{\n         fragColor = vec4(mix(2.0*(color-1.0/color),vec3(1.0,1.0,1.0),1.0), 1.0); // Background is black\n}}\n\n\n\n","name":"Image","description":"","type":"image"}]}