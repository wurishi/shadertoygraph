{"ver":"0.1","info":{"id":"tsVGRz","date":"1569624964","viewed":234,"name":"Oddtiles (optimized)","username":"stb","description":"Procedural tiles, now a public shader.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","random","bricks","tiles","tiles","oddtiles","odd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\tOddtiles (optimized)\n\t2019 stb\n \tMight still be somewhat unoptimized :)\n\t\n    First findable instance of the idea (2011):\n    https://news.povray.org/povray.binaries.scene-files/thread/%3C4dee7899%40news.povray.org%3E/?ttop=436504&toff=200\n      \n    \n    Also discovered by Shane: https://www.shadertoy.com/view/Ws3GRs\t\n*/\n\nfloat rand(vec2 p){\n\treturn\n\t\tfract(\n\t\t\tsin(\n\t\t\t\tdot(\n\t\t\t\t\tp,\n\t\t\t\t\tvec2(12.989, 78.233)\n\t\t\t\t)\n\t\t\t)*43758.545\n\t\t);\n}\n\nvec4 oddTiles(vec2 p)\n{\n\tfloat C = rand(floor(p));\n\tfloat N, S, E, W, NE, SE, NW, SW;\n\t\n\tvec2 c1, c2;\n\tif(fract(p.x*.5) > .5 ^^ fract(p.y*.5) > .5)\n\t{\n\t\tif(fract(p.y)-C > .0)\n        {\n            N = rand(floor(p+vec2(0., 1.)));\n            if(fract(p.x) > N)\n\t\t\t{\n\t\t\t\tE = rand(floor(p+vec2(1., 0.)));\n                NE = rand(floor(p-vec2(-1., -1.)));\n                c1 = vec2(N, C);\n\t\t\t\tc2 = vec2(E+1., NE+1.);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tW = rand(floor(p-vec2(1., 0.)));\n                NW = rand(floor(p-vec2(1., -1.)));\n                c1 = vec2(W-1., C);\n\t\t\t\tc2 = vec2(N, NW+1.);\n\t\t\t}\n        }\n\t\telse\n        {\n            S = rand(floor(p-vec2(0., 1.)));\n            if(fract(p.x) > S)\n\t\t\t{\n\t\t\t\tE = rand(floor(p+vec2(1., 0.)));\n                SE = rand(floor(p-vec2(-1., 1.)));\n                c1 = vec2(S, SE-1.);\n\t\t\t\tc2 = vec2(E+1., C);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tW = rand(floor(p-vec2(1., 0.)));\n                SW = rand(floor(p-vec2(1., 1.)));\n                c1 = vec2(W-1., SW-1.);\n\t\t\t\tc2 = vec2(S, C);\n\t\t\t}\n        }\n\t}\n\telse\n\t{\n\t\tif(fract(p.x)-C > 0.)\n        {\n            E = rand(floor(p+vec2(1., 0.)));\n            if(fract(p.y) > E)\n\t\t\t{\n\t\t\t\tN = rand(floor(p+vec2(0., 1.)));\n                NE = rand(floor(p-vec2(-1., -1.)));\n                c1 = vec2(C, E);\n\t\t\t\tc2 = vec2(NE+1., N+1.);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS = rand(floor(p-vec2(0., 1.)));\n                SE = rand(floor(p-vec2(-1., 1.)));\n                c1 = vec2(C, S-1.);\n\t\t\t\tc2 = vec2(SE+1., E);\n\t\t\t}\n        }\n\t\telse\n        {\n            W = rand(floor(p-vec2(1., 0.)));\n            if(fract(p.y) > W)\n\t\t\t{\n\t\t\t\tN = rand(floor(p+vec2(0., 1.)));\n                NW = rand(floor(p-vec2(1., -1.)));\n                c1 = vec2(NW-1., W);\n\t\t\t\tc2 = vec2(C, N+1.);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS = rand(floor(p-vec2(0., 1.)));\n                SW = rand(floor(p-vec2(1., 1.)));\n                c1 = vec2(SW-1., S-1.);\n\t\t\t\tc2 = vec2(C, W);\n\t\t\t}\n        }\n\t}\n\treturn vec4(c1, c2);\n}\n\nfloat roundBoxPlusRand(in vec2 p, vec2 c1, vec2 c2, float rad)\n{\n\tvec2 c1_ = -c1 * sign(c2-c1);\n\tvec2 c2_ = c2 * sign(c2-c1);\n    float f = rand( (floor(p)-fract(c1+c2)/2.) );\n    return f * clamp(1.-length(max(abs(p-(c1+c2)/2.)-(c2_+c1_)/2.+rad, 0.))/rad, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvOrig = fragCoord.st;\n\t\n    vec2 uv = 16. * uvOrig / iResolution.x;\n    \n    uv.y -= iTime;\n    vec4 ot = oddTiles(uv);\n    float f;\n    f = roundBoxPlusRand(fract(uv), ot.xy, ot.zw, .2);\n    f = pow(f, .5);\n    vec3 tex = vec3(f, f*.75, f*.5);\n        \n    \n    fragColor = vec4(tex, 1.);\n}","name":"Image","description":"","type":"image"}]}