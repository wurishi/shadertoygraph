{"ver":"0.1","info":{"id":"MlB3Ry","date":"1429981975","viewed":737,"name":"Skircle Mountains 2","username":"BntChvn","description":"Squircle based mountains, with a telepheric, with the Sun and the Moon (some snow too)\nUpdate: added sheep, return for the telepheric :)\nUpdate: added minimal depth fog, stars.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","squircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//\n// #TeamSquircle\n//\n#define PI\t\t\t\t3.1415926535\n#define EPS\t\t\t\t0.005\n#define MNTPOWER        0.9\n#define STARPOWER       0.6\n#define NB_MNT          6\n#define NB_CABIN        7\n#define NB_SHEEP        6\n\nstruct mountain {\n    vec3 base; \n    float sharpness; \n    float highness;\n};\n\nstruct sheep {\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat TIME ()\n{\n    return sin(iTime)/3.0;\n}\n\nfloat CTIME ()\n{\n    return cos(iTime)/3.0;\n}\n    \n///////////////////////////////////////////////////////////////\n// Squircle Tools\n///////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////\n// classical squircle\n///////////////////////////////////////////////////////////////\nbool Squircle(in vec2 center, in float radius, in vec2 pos, in float ratio)\n{\n    float dist =  pow(abs(center.x-pos.x)*ratio, 4.0)\n                + pow(abs(center.y-pos.y), 4.0);\n\n    return( dist < pow(radius, 4.0));\n}\n\nbool Star(in vec2 center, in float radius, in vec2 pos, in float ratio)\n{\n    float dist =  pow(abs(center.x-pos.x)*ratio, STARPOWER)\n                + pow(abs(center.y-pos.y), STARPOWER);\n\n    return( dist < pow(radius, STARPOWER));\n}\n\n///////////////////////////////////////////////////////////////\n// mountain squircle\n///////////////////////////////////////////////////////////////\nbool Mountain(\n    in mountain mnt,\n    in vec2 pos, \n    inout vec3 color,\n\tinout float depth)\n{\n    // there is no mountain underground\n    if(pos.y > mnt.base.y)\n    {\n        float dist =  pow(abs(mnt.base.x-pos.x*mnt.sharpness),MNTPOWER)\n            \t\t+ pow(abs(mnt.base.y-pos.y),MNTPOWER);\n\n        if( dist < pow(mnt.highness,MNTPOWER))\n        {\n            color = vec3(0.47,0.46,0.42);\n            color*= abs(dist);\n            depth = mnt.base.z + 0.3*dist*mnt.highness;\n            \n            // compute snow\n            if(   pos.y > 0.32/mnt.sharpness*mnt.highness/1.7 \n               && pos.y > mnt.base.y + 0.8*(mnt.base.y + mnt.highness))\n            {\n                color = vec3(0.96,\n                             0.96 + 0.05*TIME(),\n                             0.96 + 0.051*TIME());\n                \n                depth = 0.1;\n            }\n            \n            return true;\n        }\n    }\n\n    return false;\n}\n\n///////////////////////////////////////////////////////////////\n// transform fragCoord => uv\n///////////////////////////////////////////////////////////////\nvec2 toUV(in vec2 pos)\n{\n    vec2 q = pos.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    return uv;\n}\n\n///////////////////////////////////////////////////////////////\n// transform uv => fragCoord\n///////////////////////////////////////////////////////////////\nvec2 toCoord(in vec2 pos)\n{\n    pos.x *= iResolution.y/iResolution.x;\n    return (pos.xy + 1.0)*iResolution.xy/2.0;\n}\n\n\n///////////////////////////////////////////////////////////////\n// determine the pos from x on line AB\n///////////////////////////////////////////////////////////////    \nvec2 getPosInLine(in vec2 a, in vec2 b, in float x)\n{\n    float m = (b.y-a.y)/(b.x-a.x);\n    float p = a.y - m*a.x;\n    \n    return vec2(x, m*x+p);\n}\n\n///////////////////////////////////////////////////////////////\n// determine is the pos is on line AB\n///////////////////////////////////////////////////////////////    \nbool Line(in vec2 a, in vec2 b, in vec2 pos)\n{\n    float m = (b.y-a.y)/(b.x-a.x);\n    float p = a.y - m*a.x;\n    \n    if( abs(pos.y-(m*pos.x + p)) < EPS)\n    {\n        return true;\n    }\n    return false;\n}\n\n///////////////////////////////////////////////////////////////\n// determine is the pos is in segment [AB]\n///////////////////////////////////////////////////////////////\nbool Segment(in vec2 a, in vec2 b, in vec2 pos)\n{\n    if( Line(a, b, pos))\n    {\n        if(   ((a.x < b.x) && (a.x < pos.x) && (pos.x < b.x))\n           || ((a.x > b.x) && (a.x > pos.x) && (pos.x > b.x)))\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid drawCabin (in vec2 center, in vec2 pos, inout vec3 color)\n{\n    if(Squircle(center, 0.05, pos, 1.0))\n    {\n        color = vec3(1.0, 0.0, 0.0);\n        \n        \n        if(Squircle ( vec2(center.x - 0.025, center.y + 0.020), 0.019, pos, 1.0))\n        {\n            color = vec3(0.0, 0.0, 0.0);\n        }\n        \n        if(Squircle ( vec2(center.x + 0.025, center.y + 0.020), 0.019, pos, 1.0))\n        {\n            color = vec3(0.0, 0.0, 0.0);\n        }\n    }\n}\n\nvoid drawCabinLine(in vec2 start, in vec2 end, in vec2 pos, inout vec3 color)\n{\n    if(Segment(start, end, pos))\n    {\n        color = vec3(0.0, .0, .0);\n    }\n\n    for(int i=0; i< NB_CABIN; i++)\n    {\n        float running = 0.0;\n        float dist = 1.87/float(NB_CABIN);\n        if(TIME () > 0.0)\n        {\n            running = 10.0*TIME()*dist;\n        }\n\n        float x = start.x + 0.14 + running\n            + 0.04*TIME() // oscillation\n            + dist*float(i);\n\n        if(x >= end.x)\n        {\n            x -= (end.x-start.x);\n        }\n        \n        if(x <= start.x)\n        {\n            x -= end.x-abs(start.x - end.x);\n        }\n        \n        vec2 cabin = getPosInLine(start, end, x); // step on the wire\n\n        cabin.y += -0.07;\n        drawCabin(cabin, pos, color);\n    }\n}\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nbool isTelepherique (in vec2 pos, inout vec3 color)\n{\n    // draw up cabin\n    vec2 start = vec2(0.17, 0.03);\n    vec2 end   = vec2(2.0, 0.7 );\n\tdrawCabinLine(start, end, pos, color);\n\n    return false;\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid drawSun (in vec2 pos, inout vec3 color)\n{\n    vec2 sun= vec2(-2.0, 0.5);\n\n    sun.x = cos(iTime);\n    sun.y = TIME()*2.3;\n\n    float dist =  pow(abs(sun.x-pos.x),4.0)\n        \t\t+ pow(abs(sun.y-pos.y),4.0);\n\n    if( dist < pow(0.13, 4.0))\n    {\n        color = vec3(1.0,1.0, 0.0);\n        color/= abs(dist);\n    }\n\n    if(dist < pow(0.13, 4.0) + 0.0015)\n    {\n        color = 0.5*color + 0.5*vec3(1.0, 0.7, 0.0);\n    }\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid drawMoon (in vec2 pos, inout vec3 color)\n{\n    vec2 moon= vec2(-2.0, 0.5);\n\n    moon.x = -cos(iTime);\n    moon.y = -TIME()*2.0;\n\n    if(Squircle (moon, 0.10, pos, 1.0))\n    {\n        color = vec3(0.7);\n\n        if(Squircle(vec2(moon.x - 0.04, moon.y + 0.040), 0.040, pos, 1.0))\n        {\n            color = vec3(0.8);\n        }\n\n        if(Squircle(vec2(moon.x + 0.035, moon.y + 0.010), 0.022, pos, 1.0))\n        {\n            color = vec3(0.85);\n        }\n\n        if(Squircle(vec2(moon.x, moon.y - 0.041), 0.038, pos, 1.0))\n        {\n            color = vec3(0.85);\n        }\n    }\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid drawSheep(in sheep s, in float radius, in vec2 pos, inout vec3 color)\n{\n    float dir = -1.0;\n    float d = 0.0;\n    \n    \n    if(TIME()>0.0) {\n        s.pos.x += 1.5*TIME()*(s.dir.x - s.pos.x);\n        s.pos.y += TIME()*(s.dir.y - s.pos.y);\n    }\n    \n    if(cos(iTime)*(s.pos.x-s.dir.x) <= 0.){dir=1.0;}\n    \n    if(TIME()<0.0) { d = -radius;}\n    \n    \n    // draw the body\n    if(Squircle(vec2(s.pos.x, s.pos.y+d), radius, pos, 1.0))\n    {\n        color = vec3(0.5);\n    }\n    \n    // draw the head\n    s.pos.x += radius*1.7*dir;\n    if(Squircle(vec2(s.pos.x, s.pos.y+d), radius*0.7, pos, 1.0)){ color = vec3(0.55);}\n    \n    // draw the legs\n    if(TIME()>0.0)\n    {\n        s.pos.x -= radius*2.2*dir;\n        s.pos.y -= radius*1.4;\n        if(Squircle(s.pos.xy, radius*0.5, pos, 1.0)){ color = vec3(0.4);}\n\n        s.pos.x += (radius + radius*0.1)*dir;\n        if(Squircle(s.pos.xy, radius*0.5, pos, 1.0)){ color = vec3(0.4);}\n    }\n}\n\nvoid DrawCloud(in vec2 pos, inout vec3 color)\n{ \n    for(float i=0.; i<8.0; i+=1.0)\n    {\n        vec2 center = vec2(.5,.5);\n        center.x = 1.7-2.*TIME() - cos(i)*0.12;\n        center.y = 1.7*TIME() + sin(i)*0.07;\n        \n        if(Squircle(center, 0.0988, pos, 1.0))\n        {\n            if( CTIME() > 0.)\n            {\n            \tcolor = (1.0-CTIME())*color \n                \t   + CTIME()*vec3(0.8,0.8,0.8);\n            }\n            \n        }\n    }  \n\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 FOG = vec3(0.7,0.7,0.7);\n    float depth=0.3;\n        \n    // mountains added from left to right\n    // row from close to far\n    mountain mountains[NB_MNT];\n    \n    mountains[1] = mountain(vec3(-1.5,-0.5, .1), 2.4, 1.4);\n    mountains[4] = mountain(vec3(-1.5,-0.5, .4), 1.0, 1.2);\n    mountains[5] = mountain(vec3(-0.4,-0.5, .6), 1.0, 1.0);\n    mountains[0] = mountain(vec3(0.2, -0.5, .8), 1.8, 1.0);\n    mountains[3] = mountain(vec3(1.38,-0.5, .4), 1.5, 0.7);\n    mountains[2] = mountain(vec3(2.1, -0.5, .3),  1.0, 1.4);\n\n    // sheep arre added from left to right\n    sheep bunchOfSheep [NB_SHEEP];\n    \n    bunchOfSheep[0] = sheep(vec3(-1.3, -0.55, 0.01),vec3(-0.8, -0.65, 0.5));\n    bunchOfSheep[1] = sheep(vec3(-1.4, -0.6, 0.01), vec3(-1.9, -0.8, 0.5));\n    bunchOfSheep[2] = sheep(vec3(-1.5, -0.67, 0.01), vec3(-2.0, -0.8, 0.5));\n    bunchOfSheep[3] = sheep(vec3(-1.45, -0.59, 0.01), vec3(-0.7, -0.8, 0.5));\n    bunchOfSheep[4] = sheep(vec3(-2.0, -0.85, 0.01),vec3(-1.1, -0.8, 0.5));\n    bunchOfSheep[5] = sheep(vec3(-1.7, -0.57, 0.01), vec3(-1.0, -0.8, 0.5));\n    \n    // get the frag uv\n\tvec2 pos = toUV(fragCoord.xy);\n    vec3 color = vec3(1.0);\n    \n    // draw the sky\n    color *= vec3(0.3, 0.34, 0.55);\n    color *= (1.0-sin(pos.y))*3.0;\n    color *= 0.25 + TIME();\n    \n    // draw the stars\n    if(TIME()<0.0)\n    {\n        for(float i=-5.; i<5.; i+=1.)\n        for(float j=0.; j<20.; j+=1.)\n        {\n            float X = i*0.3 + cos(i*j);\n            float Y = sin(i*j);\n            if(abs(i-j)<4.)\n            {\n                X += 0.02*TIME() - 0.002*tan(i);\n                Y += 0.01*TIME() - 0.002*tan(j);\n            }\n            \n            if(Star(vec2(X, Y), 0.02, pos, 1.0))\n            {\n                color = vec3(1.0);\n            }\n        }\n    }\n    else\n    {\n        DrawCloud(pos, color);\n    }\n    // draw the moon/sun\n    drawSun(pos, color);\n \tdrawMoon(pos, color);   \n    \n    // draw the mountains\n    for(int i=0; i< NB_MNT; i++)\n    {\n\t\tMountain(mountains[i], pos, color, depth);\n    }\n    \n    // draw the telepherique\n    isTelepherique (pos, color);\n        \n    // add some grass\n    if(pos.y<=-0.5)\n    {\n        color = vec3(0.25, 0.7, 0.3);\n        color.r += cos(pos.y)/2.0;\n        \n        // add depth\n        depth = 0.5+pos.y;\n    }\n    \n    // draw the sheep\n    for(int a=0; a<5; a++)\n    for(int i=0; i<NB_SHEEP; i++)\n    {\n        sheep s = bunchOfSheep[i];\n        s.pos.x += float(a); \n\n        drawSheep(s, 0.05, pos, color);\n    }\n    \n    // simple linear depth fog\n    vec3 foggycolor = (1.0-depth)*color + depth*FOG;\n    \n    fragColor = vec4(foggycolor,1.0);\n}","name":"Image","description":"","type":"image"}]}