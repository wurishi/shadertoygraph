{"ver":"0.1","info":{"id":"3tV3zd","date":"1579642305","viewed":59,"name":"RayTraceSphereNoLight","username":"JackSolace","description":"Basic Raytracing example of a sphere with no lights","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere","graphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Jan 2020\n//Basic Raytrace of a sphere, no lights.\n//Base is altered version based on pix 2013 (https://www.shadertoy.com/view/Xdj3zz)\n\n\nstruct Ray {\n\tvec3 origin; // Origin\n\tvec3 direction; // Direction\n};\n\nstruct Sphere {\n\tvec3 center;  // Center\n\tfloat radius; // Radius\n};\n\n// From the Wikipedia page on Line-sphere intersection\nfloat intersectSphere(in Ray ray, in Sphere sphere) {\n\t// Sphere center to ray origin\n\tvec3 co = ray.origin - sphere.center;\n\n\t// The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance from the ray origin to point of intersection\n    //bear in mind that there may be more than one solution\n\tfloat discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n\t\t\t- (dot(co, co) - sphere.radius * sphere.radius);\n\n\t// If answer is not negative, get ray intersection depth\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.direction, co) - sqrt(discriminant);\n\telse\n\t\treturn -1.; // Any negative number to indicate no intersect\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // output a 4d fragment color vector [R,G,B,A]\n    // input is a 2d fragment Co-ordinate vector [X,Y]\n    // can interpret input vector as a pixel (function is called 640x360 times by default per frame)\n    \n\t// Converting all coordinates (x,y) to be in the range [0,1]\n\tfloat u = fragCoord.x / iResolution.x; // iResolution.x is width in pixels\n\tfloat v = fragCoord.y / iResolution.y; // iResolution.y is height in pixels\n\n\t// Now convert from coordinate range [0,1] to [-1,1]\n\t// This moves pixel (0,0) to the middle of the image\n\tu = u * 2.0 - 1.0;\n\tv = v * 2.0 - 1.0;\n\n    //the following line is necessary since the image may not be a square\n    //removing this line results in the x or y dimension being stretched\n    u *= (iResolution.x/iResolution.y);\n    \n    \n\t// The position of this pixel in 3D space \n    //(imagine a plane centered at the origin perpendicular to the camera, what would be the 3d coordinates of this pixel?)\n\tvec3 pixelPos = vec3(u, v, 0);\n\n    // The camera position in this example is fixed.\n    vec3 cameraPos = vec3(0, 0, -4.0); // Some distance in front of the screen (sometimes called focal distance)\n    \n\t// The ray direction is ray from the camera through the pixel\n\tvec3 rayDir = normalize(pixelPos - cameraPos);\n    \n    Sphere sphere = Sphere(vec3(0.0, 0.0, 7.0), 1.0); // The Sphere is 11 deep from the camera and centered \n\n\t// Check if the ray from the camera through the pixel intersects the sphere\n\tfloat intersectionDepth = intersectSphere(Ray(cameraPos, rayDir), sphere);\n\n\t// If the depth at which the ray intersects the sphere is positive (in front of camera)\n\tif (intersectionDepth >= 0.5)\n\t{//draw the sphere color (white)\n\t\tfragColor = vec4(1,1,1,1);\n    } else\n        // else draw background color (black)\n\t\tfragColor = vec4(0, 0, 0, 1);\n}\n\n","name":"Image","description":"","type":"image"}]}