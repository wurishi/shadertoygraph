{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#ifdef GL_ES\nprecision highp float;\nprecision lowp int;\n#endif\n\nfloat intersectPlane(in vec3 origin, in vec3 direction, out vec3 normal) {\n\n\tnormal = vec3(0.0, 1.0, 0.0);\n\treturn -origin.y / direction.y;\n}\n\nfloat intersectSphere(in vec3 origin, in vec3 direction, in vec4 sphere, out vec3 position, out vec3 normal) {\n\n\tvec3 center = origin - sphere.xyz;\n\t\n\tfloat b = 2.0 * dot(center, direction);\n\tfloat c = dot(center, center) - sphere.w * sphere.w;\n\tfloat h = b * b- 4.0 * c;\n\t\n\tif(h < 0.0)\n\t\treturn -1.0;\n\t\t\n\tfloat t = (-b - sqrt(h)) / 2.0;\n\t\n\tposition = origin + direction * t;\n\t\n\tnormal = normalize(position - sphere.xyz);\n\t\n\treturn t;\n}\n\nvec3 light = vec3(4.0, 5.0, 0.0);\nvec4 sphere1 = vec4(0.0, 1.0, 1.0, 1.0);\nvec4 sphere2 = vec4(0.0, 1.0, 1.0, 0.5);\n\nfloat intersect(in vec3 origin, in vec3 direction, out float t, out vec3 position, out vec3 normal) {\n\n\tt = 100000.0;\n\tfloat id = -1.0; \n\tvec3 normals1;\n\tvec3 normals2;\n\tvec3 normalp;\n\t\n\tfloat ts1 = intersectSphere(origin, direction, sphere1, position, normals1);\n\tfloat ts2 = intersectSphere(origin, direction, sphere2, position, normals2);\n\tfloat tp = intersectPlane(origin, direction, normalp);\n\t\n\tif(ts1 > 0.0) {\n\t\n\t\tid = 1.0;\n\t\tt = ts1;\n\t\tnormal = normals1;\n\t}\n\t\t\n\tif(ts2 > 0.0 && ts2 < t) {\n\t\n\t\tid = 1.5;\n\t\tt = ts2;\n\t\tnormal = normals2;\n\t}\n\t\t\n\tif(tp > 0.0 && tp < t) {\n\t\tid = 2.0;\n\t\tt = tp;\n\t\tnormal = normalp;\n\t}\n\t\t\n\tposition = origin + (t - 0.0001) * direction;\n\t\t\n\treturn id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tsphere1.x = sin(iTime / 1.0);\n\tsphere1.z = cos(iTime / 1.0);\n\n\tsphere2.x = sphere1.x + sin(iTime / 0.5) * 1.5;\n\tsphere2.z = sphere1.z + cos(iTime / 0.5) * 1.5;\n\n\tfloat aspect = iResolution.y / iResolution.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy * vec2(1, aspect);\n\tvec3 origin = vec3(0.0, 2.0, 4.0);\n\tvec3 direction = normalize(vec3(-1.0 + 2.0 * uv, -1.0));\n\t\n\tfloat distance;\n\tvec3 normal;\n\tvec3 position;\n\tfloat id = intersect(origin, direction, distance, position, normal);\n\n\tvec3 col = vec3(0.0);\n\t\n\tvec3 lightDir = normalize(light - position);\n\t\t\n\tfloat diffuse = clamp(dot(normal, lightDir), 0.0, 1.0) * 0.9;\n\tvec3 ambient = vec3(0.4, 0.4, 0.4);\n\t\n\tif(id > 0.9 && id < 1.1) {\n\t\t\n\t\tcol = vec3(1.0, 0.8, 0.9);\n\t\tcol *= 0.7 + 0.3 * normal.y; // hacked AO\n\t}\n\t\t\n\telse if(id > 1.4 && id < 1.6) {\n\t\t\n\t\tcol = vec3(0.8, 1.0, 0.7);\n\t\tcol *= 0.7 + 0.3 * normal.y; // hacked AO\n\t}\n\t\t\n\telse if(id > 1.9 && id < 2.1) {\n\t\n\t\tcol = vec3(0.7, 0.7, 0.9);\n\t\t\n\t\tif(fract(position.x / 10.0) > 0.5 ^^ fract(position.z / 10.0) > 0.5)\n\t\t\tcol *= 0.9;\n\t\t\n\t}\n\t\n\tvec3 shadowRay = normalize(light - position);\n\t\n\tfloat shadowT;\n\tvec3 shadowP;\n\tvec3 shadowN;\n\t\n\tfloat shadow = 1.0;\n\t\n\tif(intersect(position, shadowRay, shadowT,  shadowP, shadowN) > 0.0)\n\t\tshadow = 0.5;\n\t\t\n\tcol = col * ambient + col * diffuse * shadow;\n\t\n\tfragColor = vec4(col, min(1.0, iTime));\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslXz8","date":"1396944434","viewed":197,"name":"raytracer - test #1","username":"remonvv","description":"First test with GLSL real-time raytracer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}