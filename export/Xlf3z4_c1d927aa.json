{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// DEFINES\n\n#define COWL_MATL 1.\n#define LAMP_MATL 2.\n#define BULB_MATL 3.\n#define FLOOR_MATL 4.\n#define SPRING_MATL 5.\n#define TAIL_MATL 6.\n#define WALL_MATL 7.\n#define DEBUG_MATL 10.\n\n//#define DEBUG_ACCEL_MARCH 1\n#define CALC_SHADOWS 1\n//#define CALC_AMBIENTOCCLUSION 1\n\n// **************************************************************************\n// KINEMATIC STATE\n\nstruct LuxoData\n{\n    vec3 footorient;\n    vec3 footjoint;\n    vec3 midjoint;\n    vec3 headjoint;\n    vec3 headorient;\n    float celbowang;\n    float selbowang;\n};\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin   = vec3(0.);\n\nfloat g_time        = 0.;\nvec4  g_debugcolor  = vec4(0.);\n\n// Default Pose\nLuxoData g_lux = LuxoData(vec3(0., -.4, 0.),\n                          vec3(0., -.1, 0.),\n                          vec3(.22, .18, 0.),\n                          vec3(-0.16, .76, 0.),\n                          vec3(-1.0, 0.5, 0.),\n                          1., 0.);\n\n// **************************************************************************\n// UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a  cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice.\nvec3 rot_around_y( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n                point.y,\n                point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a  cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice.\nvec3 rot_around_x( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n                point.y * cosangle - point.z * sinangle,\n                point.y * sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the 2d origin by the angle given as a cos(angle)\n// and sin(angle) argument.\nvec2 rot_vec2( vec2 xy, float cosangle, float sinangle )\n{\n    return vec2(xy.x * cosangle - xy.y * sinangle,\n                xy.x * sinangle + xy.y * cosangle);\n}\n\nvec3 orient_to_y( vec3 p, vec3 lookdir )\n{\n    // assume lookdir is a normalized vector that we will use to\n    // normalize with the y-axis\n\n    // if lookdir is pointing exactly in the positive or negative\n    // y direction, then we can return the positive or negative\n    // identity respectively.\n    if (abs(lookdir.y) >= 1.) return sign(lookdir.y) * p;\n\n    vec3 v1 = lookdir;\n    vec3 up = vec3(0., 1., 0.); // assuming up vector in world is y\n    vec3 v3 = normalize( cross(v1, up) );\n    vec3 v2 = cross(v3, v1);\n    \n    // orthogonal matrix so inverse == transpose\n    return vec3( dot(p,v2),\n                 dot(p,v1),\n                 dot(p,v3) );\n}\n\nfloat pow5(float v)\n{\n    float tmp = v*v;\n    return tmp*tmp*v;\n}\n\nvec2 mergeobjs(vec2 a, vec2 b) { return mix(b, a, step(a.x, b.x)); }\nfloat uniondf(float a, float b) { return min(a, b); }\nfloat intersdf(float a, float b) { return max(a, b); }\nfloat diffdf(float a, float b) { return max(a, -b); }\n\n#define NOISE_DIMENSION 64.\n\nfloat noise1f( float n )\n{   \n    \n    vec2 coords = vec2(mod(floor(n),NOISE_DIMENSION)/NOISE_DIMENSION, \n                       floor(n/NOISE_DIMENSION)/NOISE_DIMENSION);\n    \n    return texture(iChannel0, coords, -100. ).r;\n} \n\n// **************************************************************************\n// INTERSECTION FOR ACCELERATION STRUCTURE\n\n// intersection for a sphere with a ray. If the ray origin is inside the\n// sphere or there is any interesection, >1 is returned, otherwise 0.\n\nfloat intersect_sphere(vec3 ro, vec3 rd, float r, vec3 sphc)\n{\n\n    vec3 so = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(so, rd);\n    float c = dot(so, so) - r*r;\n    float discr = b*b - a*c;\n\n    float zero_discr = step(SMALL_FLOAT, discr);\n    float tmin = (-b - sqrt(discr))/a;\n\n    return zero_discr * (step(0., tmin) + step(dot(so, so), r*r)); \n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat roundboxdf( vec3 p, vec3 bounds, float r )\n{\n    return length(max(abs(p)-bounds * vec3(1., .5, 1.),0.0))-r;\n}\n\nfloat cylinderdf( vec3 p, float r, float h)\n{\n    return max( length(p.xz)-r, abs(p.y) - h*.5 );\n}\n\nfloat spheredf( vec3 p, float r )\n{\n    return length(p) - r;    \n}\n\nfloat clippedconedf( vec3 p, vec2 dims, vec2 clips )\n{\n    \n    vec2 q = vec2( length(p.xz), p.y );\n    return max( max( dot(q, dims.xy), p.y), max(p.y+clips.x, -p.y-clips.y ));\n}\n\nfloat torusdf( vec3 p, float r, float d )\n{\n  vec2 q = vec2(length(p.xz)-r,p.y);\n  return length(q)-d;\n}\n\nfloat oroundboxdf( vec3 p, vec3 a, vec3 b, \n                   vec3 bounds, float r )\n{\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); o.y -= bounds.y * .5;\n    return roundboxdf(o, bounds, r);\n}\n\nfloat ocylinderdf( vec3 p, vec3 a, vec3 b, \n                   float r, float h)\n{\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); o.y -= h * .5;\n    return cylinderdf(o, r, h);\n}\n\n\nfloat ospheredf( vec3 p, vec3 a, vec3 b,\n                float r )\n{\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); o.y *= -1.; o.y += r;\n    return spheredf(o, r);\n}\n\nfloat oclippedconedf( vec3 p, vec3 a, vec3 b, \n                      vec2 dims, vec2 clips)\n{\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a));\n    \n    return clippedconedf(o, dims, clips);\n}\n\n\nvec2 lampobj( vec3 p, vec3 rd, vec3 a, vec3 b )\n{\n\n    vec2 obj = vec2(BIG_FLOAT, -1.);\n\n    vec3 o = p - a;    \n    o = orient_to_y(o, normalize(b - a)); // EXPENSIVE\n    \n    obj.x = uniondf( obj.x, spheredf(o - vec3(0., .16, 0.), .365));\n    \n    o.x += -.09;\n    \n    float ty = -.04;\n\n    // cowl\n    vec2 cowl = vec2(BIG_FLOAT, COWL_MATL);\n    vec3 cowlo = o; cowlo.y += ty;\n\n    float c = min(0., -.55*cos(4.8*cowlo.y-.25)*(1.2 * cowlo.y- .06) - .1);\n\n    cowlo.xz += .7 * c * normalize(cowlo.xz);\n    \n    float m = .11;\n\n    cowlo *= -1.; cowlo.y -= .4;\n    cowl.x = clippedconedf(cowlo, \n                  vec2(.4, m), vec2(0.21, 0.7));\n\n    cowl.x = diffdf( cowl.x, clippedconedf( cowlo, \n                     vec2(.4, m * .95), vec2(0.22, 1.)));\n\n    // - vent slits\n    float numSlits = 16.;\n    float ang = TWO_PI * (mod(atan(o.x,o.z)/TWO_PI, 1./numSlits) - (.5/numSlits));\n    float l = length(o.xz);\n    vec3 modo = vec3(l * cos(ang), o.y + ty, l * sin(ang));\n\n    cowl.x = diffdf(cowl.x, ocylinderdf(modo, \n                                         vec3(.08, -0.16, 0.0), vec3(.42, 1., 0.), \n                                        .008, .07)); // EXPENSIVE\n\n\n    // + nubbin and base\n    cowl.x = uniondf(cowl.x, cylinderdf(o + vec3(0., .18 + ty, 0.), .017, .08));\n    cowl.x = uniondf(cowl.x, spheredf((vec3(.6, 1., 0.6) * o) + vec3(0., .22 + ty, 0.), .018));\n\n    // + bulb seat\n    cowl.x = uniondf(cowl.x, cylinderdf(o + vec3(0., .12 + ty, 0.), .045, .12));\n                     \n    // + bulb\n    vec2 bulb = vec2(BIG_FLOAT, BULB_MATL);\n    bulb.x = spheredf(o - vec3(0., .12 - ty, 0.), .15);\n\n    obj = mergeobjs(cowl, bulb);\n\n    return obj;\n}\n\nvec2 upperarm( vec3 p, vec3 rd, vec3 a, vec3 b)\n{\n    vec2 obj = vec2(BIG_FLOAT, LAMP_MATL);\n\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); // EXPENSIVE\n\n    vec3 t = vec3(-0.05, -.045, 0.);\n    o += t;\n\n    // symmetry along the xy plane\n    o.z = abs(o.z);\n\n    // neck\n    obj.x = cylinderdf(o - vec3(-.05, .51, 0.), .025, .12);\n\n    obj.x = uniondf( obj.x, cylinderdf(o - vec3(-.05, .59, 0.),  .04, .07));\n\n    // + rear top block\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.06, .5,.035),\n                                        vec3(0.), vec3(.25, -.25, .0),\n                                        vec3(.022, .19, .01), .002)); // EXPENSIVE\n\n    // + front top block\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.05, .5, .035),\n                                        vec3(.0), vec3(-.08, -.3, .0),\n                                        vec3(.022, .19, .01), .002)); // EXPENSIVE\n\n    // + rear top rod\n    obj.x = uniondf( obj.x,\n                    cylinderdf(o - vec3(.06, .24, .0), .025, .35));\n\n    // + front top rod\n    obj.x = uniondf( obj.x,\n                    cylinderdf(o - vec3(-.09, .22, .0), .025, .35));\n\n    // + bolts\n    obj.x = uniondf( obj.x, spheredf(o - vec3(-.05,  .48, .04), .016));\n    obj.x = uniondf( obj.x, spheredf(o - vec3(.06, .38, .04), .016));\n    obj.x = uniondf( obj.x, spheredf(o - vec3(-.09, .35, .04), .016));\n\n    // + horizontal rods and nubs\n    vec3 hrodo = o - vec3(0.06, .09, 0.);\n    hrodo = orient_to_y(hrodo, normalize(vec3(0., 0., 1.))); // EXPENSIVE\n\n    obj.x = uniondf( obj.x, cylinderdf(hrodo, .01, .15));\n    obj.x = uniondf( obj.x, cylinderdf(hrodo - vec3(.0, .07, .0), .015, .01));\n    obj.x = uniondf( obj.x, cylinderdf(hrodo - vec3(.125, .0, .15), .01, .15));\n    obj.x = uniondf( obj.x, cylinderdf(hrodo - vec3(.125, .07, .15), .015, .01));\n\n    // + upper spring\n    vec2 springobj = vec2(BIG_FLOAT, SPRING_MATL);\n\n    vec3 springo = o;\n    springo -= vec3(.055, .09, .06);\n    springo = orient_to_y(springo, normalize(vec3(-1., 0.85, 0.))); // EXPENSIVE\n    springo.y -= .1;\n    float  c = cos(240.0*springo.y);\n    float  s = sin(240.0*springo.y);\n    mat2   m = mat2(c,s,-s,c);\n    springo.xz = m*springo.xz;\n    springo -= vec3(.0, .0, .01);\n    springobj.x = cylinderdf(springo, .0095, .2);\n\n    obj = mergeobjs(obj, springobj);\n\n\n    return obj;\n}\n\nvec2 elbow( vec3 p, vec3 rd, vec3 a, vec3 b)\n{\n    \n    vec2 obj = vec2(BIG_FLOAT, LAMP_MATL);\n    \n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); // EXPENSIVE\n\n    vec3 t = vec3(-0.05, -.045, 0.);\n    o += t;\n\n    // symmetry along the xy plane\n    o.z = abs(o.z);\n\n    // rear mid block   \n    vec3 baro = o - vec3(-.063, -.04, .035);\n    vec3 barb = vec3(.3, .3, .01);\n    vec3 bounds = vec3(.05, .21, .01);\n    baro = orient_to_y(baro, normalize(barb)); baro.y -= bounds.y * .5; // EXPENSIVE\n    baro.x *= mix(1., 2.5, smoothstep(-.2, .26, baro.y));\n    obj.x = uniondf( obj.x, roundboxdf(baro, bounds, .002));\n\n    // + front mid block\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.06, -.08, .035),\n                                        vec3(.0), vec3(-.1644, .9864, .0),\n                                        vec3(.025, .21, .01), .002)); // EXPENSIVE  \n    // + bolt\n    obj.x = uniondf( obj.x, spheredf(o - vec3(.0, .0, .04)-t, .016));\n\n    return obj;\n}\n\nvec2 lowerarm( vec3 p, vec3 rd, vec3 a, vec3 b)\n{\n    vec2 obj = vec2(BIG_FLOAT, LAMP_MATL);\n\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); \n\n    // symmetry along the xy plane\n    o.z = abs(o.z);\n\n    // rear bottom rod\n    obj.x = roundboxdf(o - vec3(0.01, .2, 0.),\n                       vec3(0.022, .35, 0.012), .007);\n\n    // + rear ankle joint    \n    vec2 rearank = rot_vec2(vec2(0.9578, 0.2873), g_lux.celbowang, g_lux.selbowang);\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.01, .04,.035),\n                                        vec3(0.), vec3(rearank.x, rearank.y, .0),\n                                        vec3(.022, .25, .01), .002));\n\n    // + front ankle joint\n    vec2 frontank = rot_vec2(vec2(0.9987, -.05), g_lux.celbowang, g_lux.selbowang);\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.01, .04,.035),\n                                        vec3(0.), vec3(frontank.x, frontank.y, .0),\n                                        vec3(.018, .18, .01), .002));\n\n    // + horizontal rods and nubs\n    \n    vec2 tfo = vec2(-.01, .04) + .155 * frontank;\n    vec2 tro = vec2(-.01, .04) + .22 * rearank;\n\n    vec3 hrodo = orient_to_y(o, normalize(vec3(0., 0., 1.)));\n\t\n    obj.x = uniondf( obj.x, cylinderdf(hrodo-vec3(tfo.y, 0., -tfo.x), .01, .26));    \n    obj.x = uniondf( obj.x, cylinderdf(hrodo-vec3(tfo.y + 0.15, 0., -tfo.x), .01, .2));\n    obj.x = uniondf( obj.x, cylinderdf(hrodo-vec3(tro.y, 0., -tro.x), .01, .16));\n\n    // + zig zag strut    \n    obj.x = uniondf( obj.x, roundboxdf(o - vec3(tfo.x, tfo.y + .09, 0.105),\n                       vec3(0.011, .2, 0.008), .007));\n\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(tfo.x, tfo.y + .185, 0.105),\n                                        vec3(0.), vec3(0., 1., -1.),\n                                        vec3(0.008, .05, 0.011), .007));\n\n    obj.x = uniondf( obj.x, roundboxdf(o - vec3(tfo.x, tfo.y + .285, 0.07),\n                       vec3(0.011, .13, 0.008), .007));\n\n    // + bolts\n    vec2 bfo = vec2(-.01, .04) + .02 * frontank;\n    obj.x = uniondf( obj.x, spheredf(o - vec3(bfo.x, bfo.y, .04), .016));\n    obj.x = uniondf( obj.x, spheredf(o - vec3(tfo.x, tfo.y + .33, .085), .016));\n\n    // + lower spring\n    vec2 springobj = vec2(BIG_FLOAT, SPRING_MATL);\n\n    vec3 so = vec3(tfo.x + .03, tfo.y + .115, .07);\n    vec3 springo = orient_to_y(o - so, normalize(vec3(tro.x - so.x, tro.y - so.y, 0.)));\n    springo.y *= 0.06/length(vec3(tro.x - so.x, tro.y - so.y, 0.));\n    float  c = cos(300.0*springo.y);\n    float  s = sin(300.0*springo.y);\n    mat2   m = mat2(c,s,-s,c);\n    springo.xz = m*springo.xz;\n    springo -= vec3(.0, .0, .01);\n    springobj.x = cylinderdf(springo, .0095, .1);\n\n    obj = mergeobjs(obj, springobj);\n    \n    return obj;\n}\n\nvec2 base( vec3 p, vec3 rd, vec3 a, vec3 b)\n{    \n    vec2 obj = vec2(BIG_FLOAT, LAMP_MATL);\n\n    vec3 o = p - a;    \n\n    o = orient_to_y(o, normalize(b - a));\n    \n    vec3 baseo = o;\n    baseo *= vec3(.9, .9, .9);\n    baseo.y += -.16;\n\n    // base ring rounded curve\n    obj.x = torusdf( baseo, .3, .05);\n\n    // + base cylinder\n    obj.x = uniondf( obj.x, cylinderdf( baseo, .3, .1));\n\n    // - base bottom\n    obj.x = diffdf( obj.x, -baseo.y );\n\n    // + base bottom piping\n    obj.x = uniondf( obj.x, torusdf(baseo, .35, .015));\n\n    baseo.y += .0603;\n\n    // + base neck scarf\n    float baseneck = cylinderdf( baseo, .08, .05);\n    baseneck = diffdf( baseneck, torusdf(baseo + vec3(0., .012, 0.), .07, .024));\n    obj.x = uniondf( obj.x, baseneck);\n\n    baseo.y += .025;\n\n    // + base neck piping \n    obj.x = uniondf( obj.x, torusdf(baseo, .045, .015));\n\n    // + base neck\n    obj.x = uniondf( obj.x, cylinderdf(baseo, .025, .2));\n    \n    return obj;\n}\n\nvec2 tailobj( vec3 p, vec3 rd, vec3 a)\n{    \n    vec2 obj = vec2(BIG_FLOAT, TAIL_MATL);\n\n    vec3 o = p - a;    \n    \n    o.z += .2 * sin(2. * o.x);\n\n    obj.x = ocylinderdf( o, vec3(.4, -.18, 0.2), vec3(1., -.18, 0.2), .015, 5.);// EXPENSIVE\n\n    return obj;\n}\n\nvec2 floorobj( vec3 pos ) \n{\n    return vec2(abs( pos.y + 0.3 ), FLOOR_MATL);\n}\n\nvec2 wallsobj( vec3 pos )\n{\n    return vec2(10. - length(pos.xz), WALL_MATL);\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\nvec2 scenedf( vec3 pos, vec3 rd )\n{\n    vec2 obj = vec2(BIG_FLOAT, -1.);\n    \n    // Base\n    vec3 sphc = g_lux.footjoint - vec3(0., .34, .0);\n    float sphr = .44;\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, base( pos, rd, g_lux.footjoint, g_lux.footorient));\n\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n\n    // Lower Arm\n    sphc = .4 * (g_lux.footjoint + g_lux.midjoint);\n    sphr = .85 * length(g_lux.midjoint - g_lux.footjoint);\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, lowerarm( pos, rd, g_lux.footjoint, g_lux.midjoint));\n\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n    \n    // Elbow\n    sphc = g_lux.midjoint + vec3(-.01, .12, .0);\n    sphr = .18;\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, elbow(pos, rd, g_lux.midjoint, g_lux.headjoint));\n\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n\n    // Upper Arm\n    sphc = .5 * (g_lux.midjoint + g_lux.headjoint);\n    sphr = .5 * length(g_lux.headjoint - g_lux.midjoint);\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, upperarm(pos, rd, g_lux.midjoint, g_lux.headjoint));\n\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n\n    // Lamp Head \n    sphc = g_lux.headjoint + vec3(-.2, .05, 0.);\n    sphr = .5;\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, lampobj( pos, rd, g_lux.headjoint, g_lux.headorient) );\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n\n    // Lamp Tail\n    obj = mergeobjs(obj, tailobj( pos, rd, g_lux.footjoint) );\n\n    // distance from a floor\n    obj = mergeobjs(obj, floorobj( pos ));\n    \n    // distance from surrounding cylinder wall\n    obj = mergeobjs(obj, wallsobj( pos ));\n    \n    return obj;\n}\n\n#define DISTMARCH_STEPS 60\n#define DISTMARCH_MAXDIST 40.\n\nvec2 distmarch( vec3 ro, vec3 rd, float maxd )\n{    \n    float dist = 10. * SMALL_FLOAT;\n    float t = 0.;\n    float material = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < SMALL_FLOAT || t > maxd ) break;\n        // advance the distance of the last lookup\n        t += dist;\n        vec2 dfresult = scenedf( ro + t * rd, rd );\n        dist = dfresult.x;\n        material = dfresult.y;\n    }\n\n    if( t > maxd ) material = -1.0; \n    return vec2( t, material );\n}\n\n// **************************************************************************\n// SHADOWING & NORMALS\n\nvec3 compute_normal( vec3 p )\n{\n    vec3 d = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scenedf(p + d.xyy, normalize(d.xyy)).x - scenedf(p - d.xyy, -normalize(d.xyy)).x,\n        scenedf(p + d.yxy, normalize(d.yxy)).x - scenedf(p - d.yxy, -normalize(d.yxy)).x,\n        scenedf(p + d.yyx, normalize(d.yyx)).x - scenedf(p - d.yyx, -normalize(d.yyx)).x );\n    return normalize( n );\n}\n\n#define SOFTSHADOW_STEPS 90\n#define SOFTSHADOW_STEPSIZE .025\n\nfloat soft_shadow( vec3 ro, \n                      vec3 rd, \n                      float mint, \n                      float maxt, \n                      float k )\n{\n    float shadow = 1.0;\n    float t = mint;\n\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\n    {\n        if( t < maxt )\n        {\n            float h = scenedf( ro + rd * t, rd ).x;\n            shadow = min( shadow, k * h / t );\n            t += SOFTSHADOW_STEPSIZE;\n        }\n    }\n    return clamp( shadow, 0.0, 1.0 );\n\n}\n\n#define AO_NUMSAMPLES 8\n#define AO_STEPSIZE .02\n#define AO_STEPSCALE .7\n\nfloat ambient_occlusion( vec3 p, \n              vec3 n )\n{\n    float ao = 0.0;\n    float aoscale = 1.0;\n\n    for( int aoi=0; aoi < AO_NUMSAMPLES ; aoi++ )\n    {\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\n        vec3 aop =  n * step + p;\n        \n        float d = scenedf( aop, n ).x;\n        ao += -(d-step)*aoscale;\n        aoscale *= AO_STEPSCALE;\n    }\n    \n    return clamp( ao, 0.0, 1.0 );\n}\n\n// **************************************************************************\n// CAMERA\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setup_camera(vec2 fragCoord)\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + 1.0 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\n// **************************************************************************\n// SHADING\n\nstruct SurfaceData\n{\n    vec3 point;\n    vec3 normal;\n    vec3 basecolor;\n    vec3 emissive;\n    float roughness;\n    float specular;\n    float metallic;\n    float ambocc_amount;\n    float cowl_shadow;\n};\n\n#define INITSURF(p, n) SurfaceData(p, n, vec3(0.), vec3(0.), 0., 1., 0., 1., 1.)\n\nstruct BRDFVars\n{\n    // vdir is the view direction vector\n    vec3 vdir;\n    // The half vector of a microfacet model \n    vec3 hdir;\n    // cos(theta_h) - theta_h is angle between half vector and normal\n    float costh; \n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\n    float costd;      \n    // cos(theta_l) - theta_l is angle between the light vector and normal\n    float costl;\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\n    float costv;\n};\n\n\nvoid calc_material(float matid,\n                   inout SurfaceData surf)\n{\n    vec3 surfcol = vec3(1.);\n    if (matid - .5 < COWL_MATL) \n    { \n        surf.basecolor = vec3(.95); \n        surf.roughness = .25;\n        surf.metallic = .0;\n        surf.specular = 1.;\n        surf.ambocc_amount = 0.;\n        surf.cowl_shadow = 0.;\n    } \n    else if (matid - .5 < LAMP_MATL) \n    { \n        surf.basecolor =  vec3(.95); \n        surf.roughness = .25;\n        surf.metallic = 0.;\n        surf.specular = 1.;\n    } \n    else if (matid - .5 < BULB_MATL)\n    {\n        surf.ambocc_amount = 0.;\n        surf.basecolor = vec3(.3);\n        surf.emissive = 2.8 * vec3(1., 1., .6);\n        surf.roughness = 0.;\n        surf.specular = 1.;\n    }\n    else if (matid - .5 < FLOOR_MATL)\n    {\n        float board = 1.2 * surf.point.x;\n        float rboard = noise1f(floor(board));\n        float grainrot = mix(-.5, .5, rboard);\n        vec2 boarduv = rot_vec2(vec2(.5, 1.) * surf.point.zx, cos(grainrot), sin(grainrot)) + vec2(40.323, 17.232) * rboard;\n        \n        vec4 pavem = texture(iChannel1, boarduv);\n        float floordivide = smoothstep(.0, .03, fract(board)) * smoothstep(1., .99, fract(board));\n        surf.basecolor = pavem.rgb * (.3 + .7 * floordivide);\n        surf.metallic = .0;\n        surf.roughness = .2;\n        surf.specular = .1;\n\n        // hacky bump map\n        surf.normal.xz += .2 * pavem.bg + vec2(mix(-.1, .1, rboard), 0.);\n        surf.normal = normalize(surf.normal);\n    }\n    else if (matid - .5 < SPRING_MATL)\n    {\n        surf.basecolor = vec3(.2, .2, .3);\n        surf.metallic = 1.;\n        surf.roughness = .02;\n        surf.specular = .5;\n    }\n    else if (matid - .5 < TAIL_MATL)\n    {\n        surf.basecolor = vec3(1.);\n        surf.metallic = .0;\n        surf.roughness = .8;\n        surf.specular = .2;\n    }\n    else if (matid - .5 < DEBUG_MATL)\n    {\n        surf.basecolor = vec3(.6, 0., 0.);\n        surf.metallic = 0.;\n        surf.roughness = 1.;\n        surf.specular = 0.;\n        surf.emissive = vec3(.3, 0., 0.);\n    }\n\n}\n\n\nBRDFVars calc_BRDFvars(SurfaceData surf, vec3 ldir)\n{\n    vec3 vdir = normalize( g_camOrigin - surf.point );\n    vec3 hdir = normalize(ldir + vdir);\n\t/*\n    float costh = max(0., dot(surf.normal, hdir)); \n    float costd = max(0., dot(ldir, hdir));      \n    float costl = max(0., dot(surf.normal, ldir));\n    float costv = max(0., dot(surf.normal, vdir));\n\t*/\n    \n    float costh = dot(surf.normal, hdir); \n    float costd = dot(ldir, hdir);      \n    float costl = dot(surf.normal, ldir);\n    float costv = dot(surf.normal, vdir);\n    return BRDFVars(vdir, hdir, costh, costd, costl, costv);\n\n}\n\nvec3 integrate_dirlight(vec3 ldir, vec3 lcolor, float shadowAtten, SurfaceData surf)\n{\n\n    BRDFVars bvars = calc_BRDFvars( surf, ldir );\n\n    vec3 cout = vec3(0.);\n\n    if (bvars.costl > SMALL_FLOAT)\n    {\n        float frk = .5 + 2.* bvars.costd * bvars.costd * surf.roughness;        \n        vec3 diff = surf.basecolor * ONE_OVER_PI * (1. + (frk - 1.)*pow5(1.-bvars.costl)) * (1. + (frk - 1.) * pow5(1.-bvars.costv));\n\n        float rroughness = max(0.05, surf.roughness);\n        // D(h) factor\n        // using the GGX approximation where the gamma factor is 2.\n\n        float alpha = rroughness * rroughness;\n        float denom = bvars.costh * bvars.costh * (alpha*alpha - 1.) + 1.;\n        float D = (alpha*alpha)/(PI * denom*denom); \n\n        // G(h,l,v) factor    \n        // remap hotness of roughness for analytic lights\n        float k = rroughness / 2.;\n        float Gv = step(0., bvars.costv) * (bvars.costv/(bvars.costv * (1. - k) + k));\n        float Gl = step(0., bvars.costl) * (bvars.costl/(bvars.costl * (1. - k) + k));\n\n        float G = Gl * Gv;\n\n        // F(h,l) factor\n        vec3 F0 = surf.specular * mix(vec3(1.), surf.basecolor, surf.metallic);\n        vec3 F = F0 + (1. - F0) * pow5(1. - bvars.costd);\n\n        vec3 spec = D * F * G / (4. * bvars.costl * bvars.costv);\n        \n        float shad = 1.;\n        #ifdef CALC_SHADOWS\n        if ( bvars.costl > SMALL_FLOAT && shadowAtten > SMALL_FLOAT)\n        {        \n            shad = mix(1., soft_shadow( surf.point, ldir, 0.1, 2.5, 50.), shadowAtten);\n        }\n        #endif\n\n        cout  += diff * bvars.costl * shad * lcolor;\n        cout  += spec * bvars.costl * shad * lcolor;\n    }\n    cout += surf.emissive;\n    \n    return cout;\n}\n\nvec3 shade(SurfaceData surf)\n{    \n\n    // ambient occlusion is amount of occlusion.  So 1 is fully occluded\n    // and 0 is not occluded at all.  Makes math easier when mixing \n    // shadowing effects.\n    float ao = 0.;\n    #ifdef CALC_AMBIENTOCCLUSION\n    ao = ambient_occlusion(surf.point, surf.normal) * surf.ambocc_amount;\n    //g_debugcolor = vec4(vec3(ao), 1.);\n    #endif\n    \n    // MAIN KEY\n    vec3 keydir = normalize(vec3(-1.5, 1.,-0.8));\n    vec3 keyillum  = vec3(3.);\n    vec3 cout   = (1. - 2.5 * ao) * integrate_dirlight(keydir, keyillum, 1., surf);\n    \n    // LAMP\n    vec3 lamporient = normalize(g_lux.headorient - g_lux.headjoint);\n    vec3 lamppos = .32 * lamporient + g_lux.headjoint;\n    \n    vec3 lampv = lamppos - surf.point;\n    float lampvl = length(lampv);\n    vec3 lampdir = normalize(lampv);\n    \n    float lampatten = 15./(lampvl * lampvl);\n    lampatten *= mix(1., smoothstep(.0, .4, dot(-lamporient, lampdir)), surf.cowl_shadow);\n    lampatten *= .04 + .96 * surf.cowl_shadow;\n    vec3 lampillum = lampatten * vec3(1., 1., .8);    \n    \n    if (lampatten > SMALL_FLOAT)\n    {\n        cout   += integrate_dirlight(lampdir, lampillum, 0., surf);\n    }\n    \n    // AMBIENT\n    vec3 amb = vec3(.15) * surf.basecolor;\n    \n    // BOUNCE\n    vec3 bncpos = (.5 * lamporient + g_lux.headjoint) * vec3(1., -1., 1.);\n    vec3 bncv = bncpos - surf.point;\n    float bncvl = length(bncv);\n    vec3 bncdir = normalize(bncv);\n    float ndbnc =  max(0., dot(bncdir, surf.normal));\n    vec3 bnc = surf.basecolor * vec3(1., .9, .8) * (1./(bncvl * bncvl)) * ndbnc * ndbnc;\n    //g_debugcolor = vec4(bnc, 1.) * max(0., (1. - 5.5 * ao));\n    cout       += (amb + bnc) * max(0., (1. - 5.5 * ao));\n\n    return cout;\n\n}\n\n// **************************************************************************\n// GLOBALS\n\n// reference: https://www.shadertoy.com/view/ldlGR7\nvec3 ik_solve( vec3 foot,\n               vec3 head,\n               float larm,\n               float uarm)\n{\n \n    vec3 q = head - foot;\n    q = q * ( 0.5 + 0.5*(larm*larm-uarm*uarm)/dot(q, q ) );\n    float s = larm*larm/dot(q,q) - 1.0;\n    return q + q.yxz*sqrt( s ) + foot;\n}\n\nvoid animate_globals()\n{\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;    \n    click = 2.0 * click - 1.0;  \n    \n    g_time = iTime;\n\n    // camera position\n    g_camOrigin = vec3(3., 0.0, 3.);\n    \n    float rotXAng    = -PI * (.5 * sin(.88 * PI * click.y) + .5);\n    float cosrotXAng = cos(rotXAng);\n    float sinrotXAng = sin(rotXAng);\n    \n    float rotYAng    = .2 * g_time + TWO_PI * click.x;\n    float cosrotYAng = cos(rotYAng);\n    float sinrotYAng = sin(rotYAng);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rot_around_x(g_camOrigin, cosrotXAng, sinrotXAng);\n    g_camOrigin = rot_around_y(g_camOrigin, cosrotYAng, sinrotYAng);\n\n    g_camPointAt   = vec3(0., 0.2, 0.);\n\n    // animate luxo\n    g_lux.headjoint.y += -.03 + .12 * sin(3.8 * g_time);\n    g_lux.headorient.z += .05 * cos(3.6 * g_time);   \n    g_lux.headorient.y += .2 * sin(.8 * g_time) - .1;    \n     \n    \n    g_lux.midjoint = ik_solve(g_lux.footjoint, \n                              g_lux.headjoint,\n                              .45, .6);\n    \n    vec3 larmv = normalize(g_lux.midjoint - g_lux.footjoint);\n    vec3 uarmv = normalize(g_lux.headjoint - g_lux.midjoint);\n    float larmang = atan( larmv.y, larmv.x );\n    float uarmang = atan( uarmv.y, uarmv.x );\n    // change in elbow angle from the default modeled position\n    float elbowang = -(.9048 - 2.1508) + (larmang - uarmang);\n    g_lux.celbowang = cos(elbowang);\n    g_lux.selbowang = sin(elbowang);\n    \n    g_lux.headorient.z += .5 * sin(3.8 * g_time);  \n\n}\n\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // ----------------------------------\n    // Animate globals\n\n    animate_globals();\n\n    // ----------------------------------\n    // Setup Camera\n\n    CameraData cam = setup_camera(fragCoord);\n\n    // ----------------------------------\n    // SCENE MARCHING\n\n    vec2 scenemarch = distmarch( cam.origin, \n                                 cam.dir, \n                                 DISTMARCH_MAXDIST );\n    \n    // ----------------------------------\n    // SHADING\n    vec3 scenecol = vec3(0.);\n    if (scenemarch.y > 0.5)\n    {\n        vec3 mp = cam.origin + scenemarch.x * cam.dir;\n        vec3 mn = compute_normal( mp );\n\n        SurfaceData currSurf = INITSURF(mp, mn);\n        calc_material(scenemarch.y, currSurf);\n\n        scenecol = shade( currSurf );\n    }\n    \n    // ----------------------------------\n    // POST PROCESSING\n    \n    // fall off exponentially into the distance (as if there is a spot light\n    // on the point of interest).\n    scenecol *= exp( -0.05*scenemarch.x*scenemarch.x );\n\n    // Gamma correct\n    scenecol = pow(scenecol, vec3(0.45));\n\n    if (g_debugcolor.a > 0.) {        \n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scenecol;\n    }\n    fragColor.a = 1.;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xlf3z4","date":"1418890547","viewed":6193,"name":"Congrats Luxo Jr","username":"mplanck","description":"Rendering a film resolution frame of Pixar's Luxo Jr. back in 1986 took hours.  This takes millseconds (the hard way).  A love letter to Pixar...  [url]http://www.loc.gov/today/pr/2014/14-210.html[/url]","likes":59,"published":1,"flags":0,"usePreview":1,"tags":["distancefields","luxo","pixar"],"hasliked":0,"parentid":"","parentname":""}}