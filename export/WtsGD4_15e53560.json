{"ver":"0.1","info":{"id":"WtsGD4","date":"1557153545","viewed":869,"name":"Vomiting gnome from GravityFalls","username":"skaplun","description":"Tribute to 'Gravity Falls' show.\nInteractive!!!\nUncomment '#define ANIMATE_LAYERS' to enable layers animation.\n","likes":55,"published":1,"flags":32,"usePreview":0,"tags":["2d","animation","gravityfalls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 makeGnome(vec2 uv, vec2 st){\n\tfloat stage = iMouse.x/iResolution.x;\n    stage = min(1., stage * 1.5);\n    float invstage = 1. - stage;\n\tvec4 result = vec4(0.);\n#ifdef ANIMATE_LAYERS\n    if(layer(st, iTime) >= 1)\n#endif\n    {\n    \tvec4 body = body(uv, stage);\n    \tresult = body;\n    }\n    \n    vec4 face = vec4(0.);\n    vec4 chk1 = vec4(0.);\n    vec4 nos = vec4(0.);\n    vec4 mstchs = vec4(0.);\n    \n#ifdef ANIMATE_LAYERS\n    if(layer(st, iTime) >= 2)\n#endif\n    {\n\t\tvec2 muv = uv + vec2(-stage, stage) * .2;\n    \n        vec4 head = head(muv, stage, st, iTime);\n        face = vec4(mix(head.rgb, head.rgb, head.a), max(head.a, face.a));\n\n#ifdef ANIMATE_LAYERS\n\t    if(layer(st, iTime) >= 5)\n#endif\n        {\n        \tvec4 mouth = mouth(muv, stage, st, iTime);\n        \tface = vec4(mix(face.rgb, mouth.rgb, mouth.a), max(mouth.a, face.a));\n        }\n        \n\n        chk1 = cheek1(muv, stage);\n        face = vec4(mix(face.rgb, chk1.rgb, chk1.a), max(chk1.a, face.a));\n        vec4 cheek2 = cheek2(muv, stage);\n        face = vec4(mix(face.rgb, cheek2.rgb, cheek2.a), max(cheek2.a, face.a));\n\n#ifdef ANIMATE_LAYERS\n\t    if(layer(st, iTime) >= 8)\n#endif\n        {\n        \tmstchs = mustaches(muv, stage);\n        \tface = vec4(mix(face.rgb, mstchs.rgb, mstchs.a), max(mstchs.a, face.a));    \n        }\n\n#ifdef ANIMATE_LAYERS\n\t    if(layer(st, iTime) >= 9)\n#endif\n        {\n        \tnos = nose(muv, stage);\n        \tface = vec4(mix(face.rgb, nos.rgb, nos.a), max(nos.a, face.a));\n        }\n        \n#ifdef ANIMATE_LAYERS\n\t    if(layer(st, iTime) >= 10)\n#endif\n        {\n        \tvec4 eyes = eyes(muv, stage, nos.a, mstchs.a);\n        \tface = vec4(mix(face.rgb, eyes.rgb, eyes.a), max(eyes.a, face.a));\n        }\n    }\n    result = vec4(mix(result.rgb, face.rgb, face.a), max(result.a, face.a));\n    \n#ifdef ANIMATE_LAYERS\n\tif(layer(st, iTime) >= 11)\n#endif\n    {\n    \tvec3 rnbState = texture(iChannel0, vec2(0.)).xyz;\n        if(length(rnbState) > 0.){\n            vec2 muv = uv + vec2(-1., 1.) * .2;\n            vec4 rainbow = rainbow(muv, rnbState, st, iTime);\n            result = vec4(mix(result.rgb, rainbow.rgb, rainbow.a * (1. - chk1.a) * (1. - nos.a) * (1. - mstchs.a)), max(result.a, rainbow.a));\n        }\n    }\n    \n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    AA = (5./iResolution.y);\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;    \n    vec3 bg = GREY * (1. - smoothstep(.6, .3, distance(uv * vec2(1., 4.), vec2(-.3, -3.6)))*.5);\n    fragColor = vec4(bg, 1.);\n#ifdef ANIMATE_LAYERS\n    if(layer(st, iTime) >= 1)\n#endif\n    {\n\t\tvec4 gnome = makeGnome(uv * 1.4, st);\n    \tfragColor = vec4(mix(bg, gnome.rgb, gnome.a), 1.);    \n    }\n#ifdef ANIMATE_LAYERS\n    fragColor.rgb *= stripe(st, iTime);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define STROKE .0025\n#define EYE_SIZE .2\n#define HEAD_SIZE .6\n#define NOSE_SIZE .15\n#define HAIR vec3(247., 204., 238.)/255.\n#define OUTLINE vec3(0.)\n#define MOUTH vec3(104., 73., 76.)/255.\n#define TEETH vec3(1.)\n#define TONGUE vec3(197., 103., 120.)/255.\n#define SKIN vec3(241., 179., 196.)/255.\n#define NOSE vec3(226., 134., 144.)/255.\n#define HAT vec3(212., 76., 92.)/255.\n#define GREY vec3(36., 44., 44.)/255.\n#define LID vec3(201., 132., 148.)/255.\n#define SHIRT vec3(157., 180., 192.)/255.\n#define PENTH vec3(96., 99., 122.)/255.\n#define BOOTS vec3(75., 49., 64.)/255.\n\n//#define ANIMATE_LAYERS\n\nfloat AA;\n\nvec2 rotate2D(vec2 _st, vec2 center, float _angle){\n    _st -= center;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += center;\n    return _st;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nfloat fbm(float x){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01;\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y *= amplitude*0.06;\n    return y;\n}\n\nfloat rfbm(float x, float time){\n\treturn fbm1x(x, time)*.5+.5;\n}\n\nfloat rfbm(float x){\n\treturn fbm(x)*.5+.5;\n}\n\nfloat rnd(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n#define LAYERS_CNT 13.\nint layer(vec2 uv, float time){\n    return int(floor(mod(abs(uv.x*.25 - time - uv.y*.5), LAYERS_CNT)));\n}\n\nfloat stripe(vec2 uv, float time){\n    return smoothstep(.4975, .495, distance(fract(uv.x*.25 - time - uv.y*.5), .5));\n}\n\nvec4 mustaches(vec2 uv, float stage){\n\tvec3 lc1 = mix(vec3(0., -.35, .35), vec3(.25, -.24, .3), stage);\n    vec3 lc2 = mix(vec3(.35, .12, .5), vec3(.2, .875, 1.),stage);\n    vec3 rc1 = mix(vec3(-.15, -.37, .35), vec3(-.3, -.35, .4),stage);\n    vec3 rc2 = mix(vec3(-.38, .12, .5), vec3(-.3, 1.05, 1.2),stage);\n    \n    \n    float lArea = min(smoothstep(lc1.z + .01, lc1.z, distance(uv, lc1.xy)),\n                      smoothstep(lc2.z + .01, lc2.z, distance(uv, lc2.xy)));\n    \n    float rArea = min(smoothstep(rc1.z + .01, rc1.z, distance(uv, rc1.xy)),\n                      smoothstep(rc2.z + .01, rc2.z, distance(uv, rc2.xy)));\n    \n    float lOutline = max(smoothstep(STROKE+AA, STROKE, distance(distance(uv, lc1.xy), lc1.z)),\n                        smoothstep(STROKE+AA, STROKE, distance(distance(uv, lc2.xy), lc2.z)))\n        \t\t  * lArea * (1. - rArea);\n    float rOutline = max(smoothstep(STROKE+AA, STROKE, distance(distance(uv, rc1.xy), rc1.z)),\n                        smoothstep(STROKE+AA, STROKE, distance(distance(uv, rc2.xy), rc2.z)))\n        \t\t  * rArea * (1. - lArea);\n    \n    vec3 clr = HAIR * max(lArea, rArea);\n    clr = mix(clr, OUTLINE, max(lOutline, rOutline));\n    return vec4(clr, max(max(lOutline, rOutline), max(lArea, rArea)));\n}\n\nvec4 mouth(vec2 uv, float stage, vec2 coord, float time){\n\tfloat invstage = 1. - stage;\n    vec2 muv = uv + vec2(.1 - stage*.15, .33 - stage * .15);\n    muv.x *= 1. + stage*.2;\n    vec2 st = rotate2D(muv, vec2(/*.05 * stage*/0., -.2), muv.x * -PI);\n    float ang = (atan(muv.y, muv.x) + PI) / TAU;\n    float dst = length(st * vec2(1., 1. + stage));\n    float creaseArea = step(dst, .166);\n    float creaseOutline = max(step(abs(ang - .42), .06 - stage * .032), step(abs(ang - .083), .05 - stage * .025))\n                       * smoothstep(.01, .001, distance(dst, .166));\n    vec4 clr = vec4(mix(SKIN, OUTLINE, creaseOutline), max(creaseOutline, creaseArea));\n    \n    muv = uv + vec2(.05 * invstage, .33 - pow(stage, 4.) * .15);\n    dst = length(st * vec2(1., 1. + pow(stage, 2.) * 20.));\n    float mouthArea = step(dst, .125 * invstage);\n    float mouthOutline = smoothstep(.01 + .2 * pow(stage, 4.), .001, distance(dst, .125 * invstage));\n\t\n    vec3 mouthClr = MOUTH;\n    \n#ifdef ANIMATE_LAYERS\n\tif(layer(coord, time) >= 6)\n#endif\n    {\n    \tdst = distance(muv, vec2(-.25, -.3 + stage * .1));\n        float tongueArea = step(.3, dst);\n        float tongueOutline = smoothstep(.01, .001, distance(.3, dst));\t\n    \n        mouthClr = mix(TONGUE, MOUTH, tongueArea);\n    \tmouthClr = mix(mouthClr, OUTLINE, tongueOutline);\n    }\n    \n#ifdef ANIMATE_LAYERS\n\tif(layer(coord, time) >= 7)\n#endif\n    {\n    \tdst = distance(muv, vec2(-.1, 3.02));\n        float teathArea = step(3., dst);\n        float teathOutline = smoothstep(.01, .001, distance(3., dst));\n    \t\n        mouthClr = mix(TEETH, mouthClr, teathArea);\n    \tmouthClr = mix(mouthClr, OUTLINE, teathOutline);\n    }\n\t\n    mouthClr = mix(mouthClr, OUTLINE, mouthOutline);\n\treturn vec4(mix(clr.rgb, mouthClr, max(mouthOutline, mouthArea)), max(max(mouthOutline, mouthArea), clr.a));\n}\n\nvec4 cheek1(vec2 uv, float stage){\n\tuv.x *= 1. + stage;\n    if(stage < .25)\n        return vec4(0.);\n    stage = (stage - .25)/.75;\n    vec3 rcheek = mix(vec3(-.6, -.3, .15), vec3(-.65, -.1, .3), stage);\n    vec2 cutoff = mix(vec2(.45, .1), vec2(.4, .2), stage);\n    float dst = distance(uv, rcheek.xy);\n    float ang = (atan(uv.y - rcheek.y, uv.x - rcheek.x) + PI) / TAU;\n    float coff = smoothstep(cutoff.y + .01, cutoff.y, abs(ang - cutoff.x));\n    float cheekArea = step(dst, rcheek.z) * coff;\n    float cheekOutline = smoothstep(.01, .001, distance(dst, rcheek.z)) * coff;\n    \n    return vec4(mix(SKIN, OUTLINE, cheekOutline * smoothstep(0., .1, stage)), max(cheekOutline, cheekArea));\n}\n\nvec4 cheek2(vec2 uv, float stage){\n\tif(stage < .25)\n        return vec4(0.);\n    stage = (stage - .25)/.75;\n    vec3 lcheek = mix(vec3(.5, -.25, .05), vec3(.51, -.16, .165), stage);\n    vec2 cutoff = mix(vec2(.5, .01), vec2(.5, .45), stage);\n    float dst = distance(uv * vec2(1.7, 1.), lcheek.xy);\n    float ang = (atan(uv.y - lcheek.y, uv.x * 2. - lcheek.x) + PI) / TAU - stage * .15;\n    float coff = smoothstep(cutoff.y + .01, cutoff.y, abs(ang - cutoff.x));\n    float cheekArea = step(dst, lcheek.z);\n    float cheekOutline = smoothstep(.01, .001, distance(dst, lcheek.z)) * coff;\n    \n    return vec4(mix(SKIN, OUTLINE, cheekOutline * smoothstep(0., .1, stage)), max(cheekOutline, cheekArea));\n}\n\nvec4 nose(vec2 uv, float stage){\n\tfloat invstage = 1. - stage;\n    uv = rotate2D(uv, vec2(0.), .25);\n    uv *= vec2(1. + invstage * uv.y * 1.5, 1. - invstage * .2);\n    float noseArea = step(length(uv), NOSE_SIZE);\n    float noseOutline = smoothstep(STROKE + AA, STROKE, distance(length(uv), NOSE_SIZE));\n    vec3 clr = NOSE * step(length(uv), noseArea);\n    clr = mix(clr, OUTLINE, noseOutline);\n    return vec4(clr, max(noseOutline, noseArea));\n}\n\nvec4 beard(vec2 uv, float stage){\n\tfloat len = length(uv);\n    float ang = atan(uv.x * 4., -uv.y + 1.);\n    float f = ang * step(1., abs(ang)) * 30. - PI/2.;\n    float a = mix(.5 * pow(smoothstep(1., 0., abs(ang)), .25), .15 + smoothstep(1.1, 1., abs(ang)) * .1, step(1., abs(ang)));\n    float size = (.9 - smoothstep(1., 1.1, abs(ang)) * .1) + abs(sin(f)) * a;\n    float beardArea = step(len, size);\n    float beardOutline = smoothstep(mix(.03, STROKE+AA, step(abs(ang), 1.)), STROKE, abs(len - size));\n    float cutoff = step(abs(ang), mix(1.2, 1.1, step(0., ang)));\n    return vec4(mix(HAIR, OUTLINE, beardOutline), max(beardArea, beardOutline) * cutoff);\n}\n\nvec4 head(vec2 uv, float stage, vec2 st, float time){\n\tvec4 head = vec4(0.);\n    {\n    \tvec2 muv = rotate2D(uv, vec2(0.), .1);\n    \tvec2 mult = vec2(1.4 + muv.y * .6, 1.);\t\n    \thead = beard((muv + vec2(.15, -.55))  * mult, stage);\n    }\n\n#ifdef ANIMATE_LAYERS\n    \tif(layer(st, time) >= 3)\n#endif\n    {\n    \tvec2 c = vec2(-.15, .2);\n        float len = distance(uv, c);\n        float ang = atan(uv.y - c.y, uv.x - c.x);\n        float size = HEAD_SIZE + (cos((ang + 1.5) * 2.) * .25 - smoothstep(.5, 0., distance(ang, -1.525)) * .1);\n        float faceArea = step(len, size);\n        float faceOutline = smoothstep(STROKE+AA, STROKE, abs(len - size));\n        vec3 clr = SKIN;\n        clr = mix(clr, OUTLINE, faceOutline);\n\n        head = vec4(mix(head.rgb, clr, max(faceOutline, faceArea)), max(max(faceOutline, faceArea), head.a));\n\n        {\n            vec3 ear = vec3(-1.1, -.01, .25);\n            float dst = distance(uv * vec2(1.5, 1.), ear.xy);\n            float earArea = step(dst, ear.z);\n            float earOutline = smoothstep(STROKE+AA, STROKE, distance(dst, ear.z));\n            vec3 clr = mix(SKIN, OUTLINE, earOutline);\n            head = vec4(mix(head.rgb, clr, max(earOutline, earArea) * (1. - head.a)), max(max(earOutline, earArea), head.a));\n        }\n    }\n    \n    \n#ifdef ANIMATE_LAYERS\n    if(layer(st, time) >= 4)\n#endif\n    {\n        vec4 lrtb = vec4(-.78 + uv.y * .175, -uv.y * .5 + .35, 1.26, .25);\n        head *= step(uv.y, lrtb[3]);\n        float hatArea = max(step(lrtb[3], uv.y) * step(lrtb[0], uv.x) * step(uv.x, lrtb[1]) *\tstep(uv.y, lrtb[2]),\n            \t\t\t    step(distance(uv, vec2(-.42, lrtb[2] - .04)), .145));\n\t\tfloat hatOutline = max(\n                               max(\n                                    smoothstep(STROKE + AA, STROKE, distance(uv.x, lrtb[0])),\n                                    smoothstep(STROKE + AA, STROKE, distance(uv.x, lrtb[1]))\n                                  ) * step(lrtb[3], uv.y) * step(uv.y, lrtb[2]),\n                               max(\n                                    smoothstep(STROKE + AA, STROKE, distance(uv.y, lrtb[3])) * step(lrtb[0], uv.x) * step(uv.x, lrtb[1]),\n                                    smoothstep(STROKE + AA, STROKE, distance(distance(uv, vec2(-.42, lrtb[2] - .04)), .145)) * step(lrtb[2], uv.y)\n                                  )\n            \t\t\t\t  );\n        vec3 clr = mix(vec3(0.), HAT, hatArea);\n        clr = mix(clr, OUTLINE, hatOutline);\n\t\thead = vec4(mix(head.rgb, clr, max(hatOutline, hatArea)), max(max(hatOutline, hatArea), head.a));\n    }\n    \n    return head;\n}\n\nvec4 eyes(vec2 uv, float stage, float nose, float mustaches){\n\tconst float pupilSize = .025;\n    vec4 res = vec4(0.);\n    {\n        vec2 muv = rotate2D(uv - vec2(.1, .2), vec2(0.), -.1);\n        float slope = sin(muv.x * 5. + PI*.5) * .1 - .075;\n        float lEyeArea = step(length(muv), EYE_SIZE);\n\t\tfloat lEyeOutline = smoothstep(STROKE + AA, STROKE, distance(length(muv), EYE_SIZE));\n    \tvec3 clr = vec3(step(length(muv), EYE_SIZE)) * smoothstep(pupilSize, pupilSize + AA, distance(muv, vec2(stage * .1, .025)));\n        clr = mix(clr, LID, step(stage * EYE_SIZE, distance(muv.y, slope)));\n        clr = mix(clr, OUTLINE, lEyeOutline);\n        clr = mix(clr, OUTLINE, smoothstep(STROKE + AA, STROKE, distance(stage * EYE_SIZE, distance(muv.y, slope))));\n        res = vec4(mix(res.rgb, clr, max(lEyeOutline, lEyeArea)), max(max(lEyeOutline, lEyeArea), res.a));\n    \t\n        slope = mix(sin(muv.x * 5. - PI*.42), sin(muv.x * 5. - PI*.46 + PI), stage) * .1 + .5 + stage * .05;\n        float browArea = step(distance(uv.y, slope), .025 - stage * .01) * step(distance(uv.x, .1 + .1 * stage), .15 + .01 * stage);\n        float browOutline = max(smoothstep(STROKE + AA, STROKE, distance(distance(uv.y, slope), .025 - stage * .01)) * step(distance(uv.x, .1 + .1 * stage), .15 + .01 * stage + STROKE/2.),\n            \t\t\t\t\tsmoothstep(STROKE + AA, STROKE, distance(distance(uv.x, .1 + .1 * stage), .144 + .01 * stage)) * step(distance(uv.y, slope), .025 - stage * .01 + STROKE));\n        clr = mix(vec3(0.), HAIR, browArea);\n        clr = mix(clr, OUTLINE, browOutline);\n        res = vec4(mix(res.rgb, clr, max(browOutline, browArea)), max(max(browOutline, browArea), res.a));\n        res.a *= (1. - nose) * (1. - mustaches);\n    }\n    {\n        vec2 muv = rotate2D(uv - vec2(-.25, .2), vec2(0.), .1);\n        float slope = sin(muv.x * 5. + PI*.5) * .1 - .075;\n    \tfloat lEyeArea = step(length(muv), EYE_SIZE);\n\t\tfloat lEyeOutline = smoothstep(STROKE + AA, STROKE, distance(length(muv), EYE_SIZE));\n    \tlEyeOutline = max(lEyeOutline,\n                          smoothstep(STROKE*.5 + AA*.5, STROKE*.5, distance(length(muv), EYE_SIZE + .025))\n                         *smoothstep(stage*.3 + AA, stage*.3, distance(atan(muv.x, muv.y), -1.85))\n                         *smoothstep(.1, .5, stage));\n        \n        vec3 clr = vec3(step(length(muv), EYE_SIZE)) * smoothstep(pupilSize, pupilSize + AA, distance(muv, vec2(stage * -.1, .025)));\n        clr = mix(clr, LID, step(stage * EYE_SIZE, distance(muv.y, slope)));\n        clr = mix(clr, OUTLINE, lEyeOutline);\n        clr = mix(clr, OUTLINE, smoothstep(STROKE + AA, STROKE, distance(stage * EYE_SIZE, distance(muv.y, slope))));\n        res = vec4(mix(res.rgb, clr, max(lEyeOutline, lEyeArea)), max(max(lEyeOutline, lEyeArea), res.a));\n    \t\n        slope = mix(sin(muv.x * 5. - PI*.5), sin(muv.x * 5. - PI*.6 + PI), stage) * .1 + .475 + stage * .1;\n        float browArea = step(distance(uv.y, slope), .035 - stage * .01) * step(distance(uv.x, -.25 + -.05 * stage), .15 + .05 * stage);\n        float browOutline = max(smoothstep(STROKE + AA, STROKE, distance(distance(uv.y, slope), .035 - stage * .01)) * step(distance(uv.x, -.25 - .05 * stage), .15 + .05 * stage + STROKE/2.),\n            \t\t\t\t\tsmoothstep(STROKE + AA, STROKE, distance(distance(uv.x, -.25 - .05 * stage), .144 + .05 * stage)) * step(distance(uv.y, slope), .035 - stage * .01 + STROKE));\n        clr = mix(vec3(0.), HAIR, browArea);\n        clr = mix(clr, OUTLINE, browOutline);\n        res = vec4(mix(res.rgb, clr, max(browOutline, browArea)), max(max(browOutline, browArea), res.a));\n        res.a *= 1. - mustaches;\n    }\n    return res;\n}\n\nvec4 body(vec2 uv, float stage){\n\tfloat mask = step(sin(uv.y * 4. + .9) * .1 + -1.1 + smoothstep(-.5, .5, uv.y) * (.25 + stage * .75), uv.x)\n        \t   * step(uv.y, .25 + uv.x * .1)\n        \t   * step(-1.2, uv.y)\n        \t   * step(uv.x, sin(uv.y * 5. + .3) * .1)\n        \t   * (1. - step(distance(uv.x, -.475), .125) * step(distance(uv.y, -1.1), .1));\n    float shirtArea = step(distance(uv, mix(vec2(-.3, .3), vec2(0., .1), stage)), 1.);\n    float sleeveOutline = 0.;\n    float sleeve = 0.;\n    float hand = 0.;\n    {\n    \tsleeve = step(distance(uv.y, uv.x * (.3)), .15) * step(0., uv.x)\n               * step(uv.x, sin(uv.y * 8. - .1 + stage*.2) * .1 + .6);\n        sleeveOutline = max(smoothstep(STROKE+AA, STROKE, distance(distance(uv.y, uv.x * (.3)), .15)) * step(0., uv.x) * step(uv.x, sin(uv.y * 8. - .1 + stage*.2) * .1 + .6),\n                            smoothstep(STROKE+AA, STROKE, distance(uv.x, sin(uv.y * 8. - .1 + stage*.2) * .1 + .6)) * step(distance(uv.y, uv.x * (.3)), .16));\n        float h1 = step(distance(rotate2D(uv, vec2(1.2, .2), -.2) * vec2(1.75, 1.), vec2(1.2, .2)), .225);\n        float h2 = step(distance(rotate2D(uv, vec2(.65, .35), .3) * vec2(1., 3.), vec2(.65, .35)), .2);\n        hand = max(h1, h2) * (1. - sleeve);\n        sleeveOutline = max(sleeveOutline,\n                           max(smoothstep(STROKE+AA, STROKE, distance(distance(rotate2D(uv, vec2(1.2, .2), -.2) * vec2(1.75, 1.), vec2(1.2, .2)), .225)) * (1. - h2),\n                           \t   smoothstep(STROKE+AA, STROKE, distance(distance(rotate2D(uv, vec2(.65, .35), .3) * vec2(1., 3.), vec2(.65, .35)), .2)) * (1. - h1))\n                           * (1. - sleeve));\n        sleeveOutline = max(sleeveOutline,\n                            smoothstep(STROKE+AA, STROKE, distance(.05, distance(uv.x, uv.y * .1 + .67))) * h1 * step(.35, uv.y)\n                            );\n        mask = max(hand, max(sleeve, mask));\n        \n        vec2 uv = rotate2D(uv * 1.2, vec2(0.), 2.1 - stage*.2) + vec2(stage * .4, -.3 + stage * .2);\n        sleeve = max(sleeve,\n            \t\t step(distance(pow(cos(uv.x), 8.), uv.y), .25 + stage * (1. - uv.y) * .125) * step(abs(uv.x), uv.y));\n            \t\t\n        shirtArea = max(shirtArea, sleeve);\n        hand = max(hand,\n            \t   step(distance(pow(cos(uv.x), 8.), uv.y), .25 + stage * (1. - uv.y) * .125) * step(distance(uv.y + uv.x, .2 - stage*.1), .35));\n        sleeveOutline = max(sleeveOutline,\n                            max(\n                                smoothstep(STROKE*2.+AA*1.5, STROKE*2., distance(distance(pow(cos(uv.x), 8.), uv.y), .25 + stage * (1. - uv.y) * .125)) * step(abs(uv.x), uv.y),\n                                smoothstep(STROKE*2.+AA*2., STROKE*2., distance(distance(uv.y + uv.x, .2 - stage*.1), .35)) * step(distance(pow(cos(uv.x), 8.), uv.y), .25 + stage * (1. - uv.y) * .125) * step(0., uv.y)\n                                ));\n    }\n    float boots = max(\n                      max(\n                      step(distance(uv, vec2(-.578, -1.25)), .075),\n                      step(distance(uv.y, sin(uv.x * 4. + 1.15) * .1 - 1.16), .075)\n                    * step(uv.y, sin(uv.x * 3. + 1.) * .1 - 1.1)\n                    * step(-1.33 - uv.y * .25, uv.x)\n                    * step(uv.x, -.91 - uv.y * .25)),\n                      max(\n                      step(distance(uv, vec2(.075, -1.265)), .075),\n                      step(distance(uv.y, sin(uv.x * 3. + 4.4) * .1 - 1.165), .075)\n                    * step(uv.x, -.25 - uv.y * .25)\n                    * step(-.06 + uv.y * .25, uv.x)\n                    * step(uv.y, -1.2))\n        \t\t\t);\n    float outline = smoothstep(STROKE+AA, STROKE, distance(uv.x, sin(uv.y * 5. + .3) * .1)) * step(-1.2, uv.y) * step(uv.y, 0.)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(uv.x, sin(uv.y * 5. + .8) * .1 - .44)) * step(-1.25, uv.y) * step(uv.y, -1.)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(uv.x, sin(uv.y * 5. + .7) * .1 - .7)) * step(-1.18, uv.y) * step(uv.y, -.85)\n\t\t\t\t  + smoothstep(STROKE+AA, STROKE, distance(sin(uv.y * 4. + .9) * .1 + -1.1 + smoothstep(-.5, .5, uv.y) * (.25 + stage * .75), uv.x)) * step(-1.266, uv.y) * step(uv.y, 0.)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(uv.y, sin(uv.x * 2.) * .05 - .95)) * step(-.6, uv.x) * step(uv.x, -.2)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(uv.y, sin(uv.x * 3. + 1.) * .1 - 1.1)) * step(-1.04, uv.x) * step(uv.x, -.6)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(uv.y, sin(uv.x * 3. + 5.3) * .1 - 1.12)) * step(-.365, uv.x) * step(uv.x, .075)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(distance(uv, mix(vec2(-.3, .3), vec2(0., .1), stage)), 1.)) * mask * (1. - sleeve) * step(uv.y, 0.)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(distance(uv, vec2(.075, -1.265)), .075)) * step(-.25 - uv.y * .25, uv.x)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(uv.y, sin(uv.x * 3. + 4.4) * .1 - 1.24)) * step(uv.x, -.25 - uv.y * .25) * step(-.06 + uv.y * .25, uv.x)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(distance(uv, vec2(-.578, -1.25)), .075)) * step(-.91 - uv.y * .25, uv.x)\n        \t\t  + smoothstep(STROKE+AA, STROKE, distance(uv.y, sin(uv.x * 4. + 1.15) * .1 - 1.234)) * step(-1.33 - uv.y * .25, uv.x) * step(uv.x, -.91 - uv.y * .25)\n        \t\t  + sleeveOutline;\n    outline = clamp(0., 1., outline);\n    vec3 color = PENTH * mask;\n    color = mix(color, SHIRT, shirtArea);\n    color = mix(color, SKIN, hand);\n    color = mix(color, BOOTS, boots);\n    color = mix(color, OUTLINE, outline);\n    return vec4(color, max(max(mask, boots), outline));\n}\n\n#define WIDTH (PI*.1)\nvec4 rainbow(vec2 uv, vec3 state, vec2 st, float time){\n\tuv.x += PI*.1;\n    float curve = sin(uv.y + 2.6) * .5 - fbm1x(uv.y, time * 10.) * .025;\n    float upperCutoff = (state.y - time) * 8. * step(.00001, state.y);\n    if(upperCutoff < 0.)\n        upperCutoff -= fbm1x(uv.x * 10., time) * .1;\n    float lowerCutoff = max((state.x - time) * 8., -1.125);\n    vec4 rnb = vec4(hsv2rgb(vec3((uv.x - curve), 1., 1.)), 1.)\n             * smoothstep(WIDTH + AA*2., WIDTH, distance(uv.x, curve))\n             * smoothstep(upperCutoff+AA, upperCutoff, uv.y)\n             * step(lowerCutoff, uv.y);\n    \n#ifdef ANIMATE_LAYERS\n\tif(layer(st, time) >= 12)\n#endif\n    {\n\t\tfloat size = smoothstep(0., .5, (time - state.x) * 4.);\n        float s = 0.;\n        if(lowerCutoff > -1.125){\n            for(int i=-2; i<=2; i++){\n                float fx = curve + WIDTH*.5*float(i);\n\n                lowerCutoff = max((state.x - time) * 8., -1.1);\n                lowerCutoff -= fbm1x(fx * 10., state.x) * .1;\n\n                float splash = rfbm(fx, lowerCutoff) * .25 * size;\n                splash = smoothstep(splash + AA*8., splash, distance(vec2(fx + WIDTH*.25, lowerCutoff), uv));\n                s = max(s, splash);\n            }\n        }\n        if (lowerCutoff < -1.){\n            vec2 cntr = vec2(4., -9.2);\n            uv *= 8.;\n            float xsgn = sign(uv.x - cntr.x);\n            vec2 dst = abs(uv - cntr);\n            uv.y -= pow(dst.x/8., 8.);\n\n            float seed = (uv.x - (dst.y + time * 12.) * xsgn) - cntr.x;\n            float splashHeight = mix(.4 - sin(time * 10.)*.1, smoothstep(-1., 1., fbm(seed)), smoothstep(0., 2., dst.x))\n                               * (4. - cos(dst.x) * 1.5)\n                               * smoothstep(8., 0., dst.x)\n                               * max(step(.00001, state.x), state.z);\n            float splash = smoothstep(cntr.y, cntr.y+AA*12., uv.y)\n                         * smoothstep(cntr.y + splashHeight + AA*12., cntr.y + splashHeight, uv.y)\n                         * smoothstep(8., 7., dst.x);\n\n            s = mix(s, splash, smoothstep(-1., -1.1, lowerCutoff));\n        }\n        rnb.rgb = mix(rnb.rgb, vec3(1.), s);\n        rnb.a = max(rnb.a, s);    \t\n    }\n    \n    return rnb;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord){\n    float m = iMouse.x/iResolution.x;\n    if(ivec2(fragCoord) == ivec2(0)){\n        vec4 state;\n        if(iFrame == 0){\n        \tstate = vec4(0.);\n        }else{\n        \tstate = texture(iChannel0, vec2(0.));\n\t\t\t\n        \tfloat puke = step(.5, m);\n            float prevPuke = step(.00001, state.x);\n\n            if(puke > prevPuke){\n                state.x = iTime;\n                state.y = 0.;\n            }else if(puke < prevPuke){\n                state.y = state.w = iTime;\n                state.x = 0.;\n            }else if(puke == 0.){\n            \tstate.z = smoothstep(2., 1.15, distance(iTime, state.w) * 6.);\n                if(state.z == 0.)\n                    state.y = 0.;\n            }\n        }\n        fragColor = state;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}