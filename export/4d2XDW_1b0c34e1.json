{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const vec3 background  = vec3(0.0, 0.0, 0.2);\nconst vec3 light_1     = vec3(4.0, 8.0,  3.0);\nconst vec3 light_2     = vec3(-4.0, 8.0, -7.0);\nconst vec2 eps         = vec2(0.001, 0.0);\nconst int maxSteps     = 164;\n\n//const float time = iTime;\n\nvec3 shade(vec3 color, vec3 point, vec3 normal, vec3 rd)\n{\n\t\n\tvec3 dtl       = normalize(light_1 - point);\n\tfloat diffuse  = dot(dtl, normal); //diffuse\n\tfloat specular = 0.75 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 64.0); //specular\n\tvec3 c = (diffuse + specular) * color * 0.85;\n\t\n\tdtl      =  normalize(light_2 - point);\n\tdiffuse  = dot(dtl, normal); //more diffuse\n\tspecular = 0.9 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 128.0); //more specular\n\treturn clamp( c + (diffuse + specular) * 0.25 * color, 0.0, 1.0);\n}\n\n// estimates the distance from Point p to implicit given geometry\nfloat distanceEstimator(vec3 p)\n{\n\tfloat t = mod(iTime, 70.0);\n\tp = p - vec3(t, t * 0.5, t * 0.3);\n\t\n\tfloat rpm = 1.0;\n\tvec3 repeater = mod(p, vec3(rpm)) - 0.5 * vec3(rpm);\n\n\tfloat sphere = length(repeater) - 0.06 * rpm;\n\t\n\tvec2 cylinder = vec2(min(length(repeater.xz) - 0.59, .015), repeater.y);\n\tfloat doughnut = length(cylinder) - 0.015 * rpm;\n\t//return doughnut;\n\treturn min(doughnut, sphere);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tfloat ratio  = iResolution.x / iResolution.y;\n\tvec2 fragment = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 uv = -1.0 + 2.0 * fragment;\n\tuv.x *= ratio;\n\t\n\t//camera setup taken from iq's raymarching box: https://www.shadertoy.com/view/Xds3zN\n\tvec3 ta = vec3( 0.0, 0.0, -3.5 );\n\tvec3 ro = vec3( -3.0 + 3.2*cos(0.3*iTime + 6.0), 4.0, 1.0 + 3.2*sin(0.2*iTime + 6.0) );\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 2.5*cw );\n\t\n\tvec3 col             = background;\n\tfloat t              = 0.0;\n\tvec3 p               = vec3(0.0);\n\t\n\t// march\n\tfloat steps = 0.0;\n\tfor (int i = 0; i < maxSteps; i++) {\n\t\tp = ro + t * rd;\n\t\tfloat distanceEstimation = distanceEstimator(p);\n\t\tif (distanceEstimation > 0.0005) {\n\t\t\tt += distanceEstimation;\n\t\t\tsteps += 1.0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//vec3 c = (cos(p * 0.5 - 0.5) + 1.0) / 2.0;\n    vec3 c = vec3(1.0);\n\tvec3 normal = normalize(vec3(distanceEstimator(p + eps.xyy) - distanceEstimator(p - eps.xyy),\n\t\t\t\t\t\t\t\t distanceEstimator(p + eps.yxy) - distanceEstimator(p - eps.yxy),\n\t\t\t\t\t\t\t\t distanceEstimator(p + eps.yyx) - distanceEstimator(p - eps.yyx)));\n\t\n\tcol = shade(c, p, normal, rd);\n\t//col = mix(col, background, smoothstep(0.8, 1.0, float(steps) / float(maxSteps)));\n\t\n\t\n\tfragColor = vec4(col, 1.0); \n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2XDW","date":"1412140800","viewed":199,"name":"ufo diamonds","username":"rickiters","description":"slight mods to lsd ufos","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}