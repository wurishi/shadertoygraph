{"ver":"0.1","info":{"id":"XtGXW1","date":"1484058951","viewed":233,"name":"Lambertian Lighting","username":"sakib","description":"Simple lambertian lit sphere","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lighting","sphere","lambertian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/********************************************************************\nRendering a Lambertian sphere through ray tracing\n\nAuthor : Sakib Saikia 1/10/2017\n********************************************************************/\n\nvec3 spherePos = vec3(0.0,0.0,0.0);\nfloat sphereRadius = 1.0;\nvec3 albedo = vec3(1.0,0.0,0.0);\nvec3 bgColor = vec3(0.6,0.6,0.6);\nvec3 eye = vec3(0.0,0.0,-2.0);\nvec3 lightDir = vec3(1.0,2.0,-1.0);\nvec3 ambient = vec3(0.02);\n\n// Construct inverse LookAt matrix. Convert from view space to world space\n// eyePos \t- eye/camera position in World Space\n// v \t\t- LookAt position in world space\nmat3 invLookAt(vec3 eyePos, vec3 v)\n{\n    vec3 worldUpDir = vec3(0.0,1.0,0.0);\n    vec3 viewLookDir = normalize(v - eyePos);\n    vec3 viewRightDir = normalize(cross(worldUpDir, viewLookDir));\n    vec3 viewUpDir = normalize(cross(viewLookDir, viewRightDir));\n    \n    return mat3(viewRightDir, viewUpDir, viewLookDir);\n}\n\n// Sphere ray trace\n// p - ray trace origin in world space\n// d - ray direction in world space\n// o - sphere origin in world space\n// r - sphere radius\n// See : http://www.cs.virginia.edu/~gfx/Courses/2008/AdvancedGraphics/lectures/lecture07_implicit.pdf\nfloat rayTrace(vec3 p, vec3 d, vec3 o, float r)\n{\n    vec3 op = p - o;\n    \n    float a = 1.0;\n    float b = 2.0 * dot(d, op);\n    float c = dot(op, op) - r * r;\n    \n    float t = b*b - 4.0*a*c;\n    if(t >= 0.0)\n    {\n        return (-b - sqrt(t))/(2.0 * a);\n    }\n    else\n    {\n        return -1.0;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixelColor = bgColor;\n    \n    // NDC\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Inverse View matrix\n    mat3 viewMat = invLookAt(eye, spherePos); \n    \n    // Ray direction in world space\n    vec3 rayDir = viewMat * normalize(vec3(p.xy, 0.75));\n    \n    // Ray trace!\n    float t = rayTrace(eye, rayDir, spherePos, sphereRadius);\n    \n    if(t > 0.0)\n    {\n        vec3 pos = eye + t * rayDir;\n        vec3 normal = normalize(pos - spherePos);\n    \tpixelColor = albedo * max(dot(normal, normalize(lightDir)), 0.0) + ambient * albedo;\n    }\n    \n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(pixelColor,gamma),1.0);\n}","name":"Image","description":"","type":"image"}]}