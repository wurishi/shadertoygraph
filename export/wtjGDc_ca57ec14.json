{"ver":"0.1","info":{"id":"wtjGDc","date":"1561412690","viewed":371,"name":"[twitch] Sable Bat","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SableBat.glsl","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animal","sand"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SableBat.glsl\n*/\n\nfloat time;\nfloat pi=acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*.5+.5,0.0,1.0);\n  return mix(a,b,k) - k * (1.0-k) * h;\n}\n\nfloat wings(vec3 p) {\n  \n  p.x = abs(p.x);\n  \n  float flop = pow(max(0.0,sin(time*4.0 - p.x*0.15)*0.8+0.2),10.0);\n  p.xz *= rot(clamp(p.x,0.0,2.0) * 0.3 * flop);\n  \n  float ang = p.x + p.y*0.5;\n  float decal = -2.0;\n  p.y -= decal;\n  p.xy *= rot(-0.2 * clamp(ang*0.9-ang*ang*0.3, -5.0, 2.0));\n  p.y += decal;\n  \n  vec3 p2 = p;\n  float size = 0.4;\n  p2.x = (fract(p2.x/size+0.5)-0.5)*size;\n  p2.y -= clamp(p2.y,-2.0 + cos(p.x*0.5)*1.5,0.0);\n  float d = max(length(p2)-0.2, abs(p.x)-5.0);\n  \n  p.xz *= rot(p.x * 0.012);  \n  \n  vec3 p3 = p;\n  float size2 = 0.3;\n  p3.x = (fract(p3.x/size2+0.5)-0.5)*size2;\n  p3.y -= clamp(p3.y,-1.0 + cos(p.x*0.5)*0.8,-0.5);\n  p3.z =abs(p.z+0.1)-0.15;\n  d = smin(d, max(length(p3)-0.17, abs(p.x)-4.2), 0.2);\n  d = smin(d, p.z+0.16, -0.12);\n  \n  \n  d*=0.5;\n  \n  return d;\n  \n}\n\nfloat body(float d, vec3 p) {\n  \n  vec3 bp = p;\n  vec3 bp2 = p;\n  \n  p.y-=0.4;\n  p.zy *= rot(abs(p.y)*0.2);\n    \n  vec3 p2 = p;\n  \n  p2.y -= clamp(p2.y,-1.0,2.0);\n    \n  d = smin(d, length(p2)-0.5 + p.y*0.19, 0.8);\n  d = smin(d, length(bp+vec3(0,1.3,-0.9))-0.9, 0.2);\n  //bp.x=abs(bp.x)-0.4;\n  bp.x=smin(bp.x,-bp.x, 0.2)+0.4;\n  bp.xy *= rot(bp.x*0.5);\n  d = smin(d, -(length(bp+vec3(0,1.3,-1.4))-0.12), -0.6);\n  d = smin(d, -(length(bp+vec3(-0.17,0.7,-1.4))-0.1), -0.2);\n  \n  bp2.x = abs(bp2.x);\n  bp2.xz *= rot(-bp2.x*0.3 + bp2.y*0.14);\n  bp2.yz *= rot(-0.6);\n  bp2 -= vec3(0.1,0.0,-1.2);\n  float hear = length(bp2 + vec3(-0.5,2.5,-1.2))-0.6;\n  hear = smin(hear, -(length(bp2 + vec3(-0.5,2.5,-1.6))-0.6), -0.3);\n  hear = smin(hear, -(length(bp2 + vec3(-0.9,2.1,-1.1))-0.1), -0.4);\n  \n  d=smin(d, hear, 0.17);\n  \n  return d;\n}\n\nfloat claws(float d, vec3 p) {\n  \n  p.x=-abs(p.x);\n  vec3 bp=p;\n  \n  p += vec3(0.5,-2.0,0);\n  \n  p.zy *= rot(sin(time*4.0+1.0)*0.5+0.3);\n  p.y -= 0.5;\n  \n  p.x=-abs(p.x);\n  p.xz *= rot(0.4);\n  p.x=-abs(p.x);\n  p.xz *= rot(0.2);\n  \n  float donut = length(vec2(length(p.zy)-0.6, p.x)) - 0.2;\n  donut = smin(donut, -(length(p-vec3(0,1,-0.4))-0.7), -1.4 + clamp(-bp.x*0.5,0.0,1.0)-0.4);\n  bp.xy *= rot(0.15);\n  donut = smin(donut, max(length(bp.xz+vec2(0.2,0.0))-0.12, abs(bp.y-1.0)-1.0), 0.2);\n  d = smin(d, donut, 0.2);\n  \n  return d;\n  \n}\n\nfloat noise(vec2 p) {\n  vec2 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec2 st=vec2(37,133);\n  vec4 val = fract(sin(dot(ip, st) + vec4(0,st.x, st.y, st.x+st.y))*2375.655);\n  vec2 v = mix(val.xz,val.yw, p.x);\n  return mix(v.x, v.y, p.y);\n}\n\nfloat mat = 0.0;\nfloat map(vec3 p) {\n  \n  vec3 tp = p;\n  tp.z += time*10.0;\n  tp.y += sin(time*0.7)*5.0;\n  float f = noise(tp.xz*0.08)*0.5;\n  f += noise(tp.xz*0.16)*0.25;\n  f += noise(tp.xz*0.32)*0.125;\n  f = abs(f-0.5);\n  float d2 = 8.0-tp.y + f*13.0;\n  d2 *= 0.7;  \n  \n  \n  p.yx *= rot(sin(time*0.7) * 0.3);\n  p.yz *= rot(-0.7 + sin(time) * 0.3);\n  \n  \n  p.y += sin(time*4.0 + 2.5 + abs(p.x)*0.4)*0.3;\n  \n  float d = wings(p);\n  \n  d = body(d, p);\n  \n  d = claws(d, p);\n  \n  \n  d = min(d, d2);\n  \n  mat = abs(d-d2)<0.01?1.0:0.0;\n  \n  return d;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(sin(time)*0.2+0.2);\n  p.xz *= rot(2.7 + time*0.4);\n  p.yz *= rot(sin(time)*0.1-0.1);\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  // We mod the time to make it repeat, because as we scroll the ground, the lack of precision start to be visible\n  time = mod(iTime, 50.0);\n\n  vec3 s=vec3(0,0,-18);\n  vec3 r=normalize(vec3(-uv, 1));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 p=s;\n  float i=0.0;\n  float dd=0.0;\n  for(i=0.0; i<100.0; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      i += d/0.001;\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n  \n  float curmat=mat;\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n = normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  float itfog = pow((1.0-i/100.0)*1.1,3.0);\n  float fog = 1.0-clamp(dd/100.0,0.0,1.0);\n  \n  vec3 l=normalize(-vec3(1,3,-2));\n  vec3 h=normalize(l-r);\n  float fre=pow(1.0-abs(dot(n,r)),3.0);\n  \n  float ao = clamp(map(p+n*0.5)/0.5,0.0,1.0);\n    \n  vec3 col = vec3(0);\n  vec3 diff = mix(vec3(0.4,0.5,0.9)*2.0, vec3(0.9,0.6,0.5)*2.0, curmat);\n  col += max(0.0, dot(n,l)) * fog * ao * (diff +  2.0*pow(max(0.0,dot(h,n)), 10.0)*(1.0-curmat));\n  col += (n.y * 0.5 + 0.5) * vec3(1,0.5,0.3) * 0.8 * fog;\n  col += fre * vec3(1,0.7,0.5) * 3.0 * fog * ao * (-n.y*.5+.5) * (1.0-curmat*0.6);\n  \n  vec3 rr = normalize(p);\n  vec2 skyuv = vec2(abs(atan(rr.x,rr.z)), rr.y);\n  float ff = (-noise(skyuv*vec2(4,30))*0.1-noise(skyuv*vec2(6,19)*2.0)*0.05) * 0.33;\n  vec3 sky = mix(vec3(1,0.7,0.5)*0.3, vec3(1.0,0.2,0.2)*3.0, pow(max(0.0,r.z), 80.0)) * pow(max(0.0,-r.y*0.5+1.2 + ff),5.0);\n  col += sky * pow((1.0-fog)*1.2, 3.0);\n          \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}