{"ver":"0.1","info":{"id":"mscyzS","date":"1695266924","viewed":221,"name":"Slime Molds 2.0","username":"01000001","description":"My first ever voronoi tracking shader :) I couldn't resist taking it to perfection.\nClick to erase. Shift click to create attractor\n\nbit of an improvement from version 1 eh? https://www.shadertoy.com/view/NlyyD1","likes":18,"published":3,"flags":48,"usePreview":0,"tags":["thingy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Buffer A : Particle control\n// Buffer B : Voronoi Tracking\n// Buffer C : Rendering\n// Buffer D : Post processing\n\n// See Buffer A to play around with particle configurations\n// I've included a few fun presets to try :D\n\n// You may wanna use the shadertoy unofficial plugin\n// to speed it up by increasing drawcalls\n// For interactivity though, realtime is nice\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    O = texture(iChannel2, uv);\n    \n        \n    O = vec4(\n        O.x * O.x, \n        O.x, \n        sqrt(O.x), \n    1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Particle Buffer\n\n#define direction -1.\n\n#define PRESET 3\n// 0 : Boring\n// 1 : Squiggly\n// 2 : High Velocity\n// 3 : Dendrites\n// 4 : Stable\n// 5 : Bipolar                          // I asked friends to help me find the word that means a system that\n                                        // will converge to a stable state, but explode at tiny perturbations\n                                        // and this is the suggestion I received. It's true ¯\\_(ツ)_/¯\n// 6 : Angular\n// 7 : Cellular\n\n// Alright that's enough. Have fun exploring :)\n\n\n#if PRESET == 0\nconst float searchRange = 1.;\nconst float searchAngle = .4;\nconst float turnAngle = .02;\n// Less than one gets funky\n#endif\n\n#if PRESET == 1\nconst float searchRange = 1.;\nconst float searchAngle = pi/3.;\nconst float turnAngle = .02;\n#endif\n\n#if PRESET == 2\nconst float searchRange = 5.;\nconst float searchAngle = .1;\nconst float turnAngle = .05;\n#endif\n\n#if PRESET == 3\nconst float searchRange = 5.;\nconst float searchAngle = .1;\nconst float turnAngle = .2;\n#endif\n\n#if PRESET == 4\nconst float searchRange = 1.;\nconst float searchAngle = 1.;\nconst float turnAngle = .2;\n#endif\n\n#if PRESET == 5\nconst float searchRange = 2.;\nconst float searchAngle = 2.*pi/3.;\nconst float turnAngle = 2.*pi/3.;\n#endif\n\n#if PRESET == 6\nconst float searchRange = 2.;\nconst float searchAngle = pi/2.;\nconst float turnAngle = pi/2.;\n#endif\n\n#if PRESET == 7\nconst float searchRange = 1.;\nconst float searchAngle = 0.01;\nconst float turnAngle = pi/7.;\n#endif\n\n\nconst float randomization = 5e-4;\n\n\n\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    //if (uv.x * scale > 1. || uv.y * scale > 1.) return;\n    \n    if (iFrame < 30){\n    \n        O.xy = (circleSample(uvec3(U, iDate.w)))*.25 * vec2(1, aspect) + .5;\n        O.zw = normalize(hash(uvec3(U, iDate.w)).xy*2.-1.) * rot(pi/2.);\n        return;\n        \n    } else {\n        \n        O = texture(iChannel0, uv);\n        \n        vec2 pos = O.xy;        \n        vec2 vel = O.zw;\n        \n        const int rayCount = 3;\n        float rays[rayCount];\n        \n        float x = 20.;\n                \n        for (int ray = 0; ray < rayCount; ray++){\n            vec2 rayDir = vel * rot(-searchAngle+float(ray)*searchAngle);\n                        \n            x = texture(iChannel2, pos + rayDir*scale/r.x*searchRange).x;\n            \n            rays[ray] = x;\n        }\n        \n        vec3 h = hash(uvec3(U, iDate.w*1000.));\n        if (h.x < randomization){ // Crazy tiny amount of divergents.\n                         // That's all it takes to break up regularity with millions of particles :) \n            vel *= rot(h.y);\n        } else {\n            if (rays[0] > rays[2]){\n                vel *= rot(direction*turnAngle);\n            } else if (rays[2] > rays[0]) {\n                vel *= rot(-direction*turnAngle);\n            } else {\n                // Centre\n                \n                //vel *= rot(h.y);\n            }\n        }\n        \n        pos += vel * scale/r.x * 2e-2 * searchRange * vec2(1, aspect);\n        \n        pos = mod(pos, 1.);\n        \n        O = vec4(pos, vel);\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Voronoi buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    if (iFrame < 20){\n        O = vec4(0);\n        O.xy = uv;\n        return;\n    }\n    \n    \n    O = texture(iChannel1, uv);\n    // xy is data location of my particle\n    \n    vec2 myParticle = texture(iChannel0, O.xy/scale).xy;\n    \n    \n    for (int i = 0; i < 8; i++){\n        vec2 samp = texture(iChannel1, mod(myParticle\n            + (normal(uvec3(U, iFrame - i)).xy\n            +  normal(uvec3(U, iFrame * i)).xy\n            +  normal(uvec3(U, iFrame + i)).xy)/(r.x/scale)\n        ,1.)).xy;\n        \n        vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n\n        if (length(newParticle - uv) < length(myParticle - uv)){\n//            O.zw = O.xy;\n            O.xy = samp;\n        }\n        // Secondary distance might be handy? Dunno. Might explore later.\n    }\n    \n    \n    for (int i = 0; i < 2; i++){\n        vec2 samp = hash(uvec3(U, iFrame * i)).xy;\n        \n        vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n\n        if (length(newParticle - uv) < length(myParticle - uv)){\n//            O.zw = O.xy;\n            O.xy = samp;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.14159;\nconst float scale = 6.;\n// Try big number to see what's going on. 5 is about the minimum that works coherently.\n// Any improvements to accurately render an even larger quanitity of particles would be appreciated :D\n// I have a few ideas but I'd love to learn about the community's knowledge\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(v=hash(x+uint(v*1e9)).xy*2.-1.;\n        dot(v,v)<1.;)\n    return v;\n}\n\nvec3 normal( uvec3 x ){\n    \n    vec3 h = hash(x)*2.-1.;\n    return h/exp(pow(abs(h), vec3(6)));\n\n}\n\nmat2 rot( float rad ){\n    return mat2(\n        cos(rad), sin(rad),\n        -sin(rad), cos(rad)\n    );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Render Buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    O = texture(iChannel0, uv);\n    \n    float minD = 2.;\n    float x = 0.;\n    for (int i = 0; i<8; i++){\n        x = length(\n            (texture(iChannel0, texture(iChannel1, \n                uv + (i>0?circleSample(uvec3(U, iFrame * i)) / (r.x / scale):vec2(0))\n            ).xy/scale).xy - uv) * vec2(1, 1./aspect)\n        );\n        \n        if (x < minD){\n            minD = x;\n        }\n    }\n    \n    O = texture(iChannel2, uv\n        //+ (vec2(scale*3e-3)/r)*rot(float(iFrame) * pi/2.)\n    );\n    O *= .98;\n    O+= smoothstep(scale/r.x * .2, 0., minD);\n    \n    //if (mod(iTime * .5,1.) > iMouse.x/r.x * 2. - .5) O = texture(iChannel1, uv);\n    // Display voronoi buffer. WARNING: The particles read this buffer to decide where to go\n    // so enabling this comment will cause chaos in their motion\n    \n    \n    if (iMouse.z > 0.){\n        if (texelFetch(iChannel3, ivec2(16, 0), 0).x > .0){\n            O.x += max(0., 1.-length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 500.);\n        } else {\n            O *= min(1., length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 200.);   \n        }\n    }\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Post Processing\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    O = texture(iChannel3, uv);\n    O *= .95;\n    \n    O += texture(iChannel2, uv)*1e-2;\n\n    // Because of SIMD, vector as opposed to operating on only O.x\n    // should be the same speed right? I hope? Pls lmk in comments :)\n}","name":"Buffer D","description":"","type":"buffer"}]}