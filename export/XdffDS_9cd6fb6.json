{"ver":"0.1","info":{"id":"XdffDS","date":"1497712139","viewed":191,"name":"Expensive Iterative Catmull-Rom","username":"andras","description":"Implementing the algorithm.\nCouldn't get this to work: :((\nhttps://stackoverflow.com/a/23980479","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spline","catmull","rom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Control points\n// x, y and t\nvec3 c0 = vec3(-0.0, 0.4, 0.0);\nvec3 c1 = vec3(-0.77, -0.4, 1.0);\nvec3 c2 = vec3(1.0, 0.5, 2.0);\nvec3 c3 = vec3(1.0, 1.0, 3.0);\n\nvec2 calcIter(vec3 p0, vec3 p1, float t){\n \t\n    float delta = p1.z - p0.z;\n    \n    float ta = (p1.z - t) / delta;\n    vec2 pa = vec2(p0.xy) * ta;\n    \n    float tb = (t - p0.z) / delta;\n   \tvec2 pb = vec2(p1.xy) * tb;\n    \n    return pa + pb;    \n}\n\n// https://stackoverflow.com/a/19283471\nvec2 calcPoint(\n    vec3 p0,\n    vec3 p1,\n    vec3 p2,\n    vec3 p3,\n    float t)\n{\n \n    vec2 L01 = calcIter(p0, p1, t);\n\tvec2 L12 = calcIter(p1, p2, t);\n\tvec2 L23 = calcIter(p2, p3, t);\n\tvec2 L012 = calcIter(vec3(L01, p0.z), vec3(L12, p2.z), t);\n\tvec2 L123 = calcIter(vec3(L12, p1.z), vec3(L23, p3.z), t);\n\tvec2 C12 = calcIter(vec3(L012, p1.z), vec3(L123, p2.z), t);\n    return C12;\n}\n\nfloat controlCircle(vec2 p, vec2 m) {\n    return 1.0 - smoothstep( 0.05, 0.06, length(m - p));\n}\n\nfloat circle(vec2 p, vec2 m) {\n    return 1.0 - smoothstep( 0.02, 0.021, length(m - p));\n}\n\nfloat drawPoints(vec2 p) {\n    \n    float c = 0.0;\n    \n    const float MAX_VAL = 30.0;\n    \n    for(float i = 0.0; i <= MAX_VAL; ++i)\n    {\n     \n        float t = i / MAX_VAL;\n        // Set range\n        \n        t = t * (c2.z - c1.z) + c1.z;\n        \n        vec2 m = calcPoint(c0, c1, c2, c3, t);\n        \n        c += circle(p, m);\n    }\n    \n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n   \tp = p * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 c = vec3(0.0);\n    \n    c += drawPoints(p);\n        \n    c.yz += controlCircle(p, c0.xy) * 0.7;\n    c.yz += controlCircle(p, c1.xy) * 0.7;\n    c.yz += controlCircle(p, c2.xy) * 0.7;\n    c.yz += controlCircle(p, c3.xy) * 0.7;\n    \n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}