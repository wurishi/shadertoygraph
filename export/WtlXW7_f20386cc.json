{"ver":"0.1","info":{"id":"WtlXW7","date":"1563218823","viewed":475,"name":"Toxic fractal","username":"jblanper","description":"3d fractal using the ray marching algorithm. Inspired by evvvvil's fractals that he shows in twitch.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float tt, g;\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin( float a, float b, float k ) {\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sphereSDF (vec3 p, vec3 c, float r) {\n  return length(c - p) - r;\n}\n\nfloat cubeSDF (vec3 p, vec3 c, vec3 dimensions, float borderRoundness) {\n  vec3 pos = abs(c - p) - dimensions;\n  return length(max(pos, 0.)) - borderRoundness + min(max(pos.x, max(pos.y, pos.z)), 0.);\n}\n\nvec2 map (vec3 p) {\n  //fractal\n  for (int i=0; i<3; i++) {\n    p = abs(p) - vec3(6.);\n\n    p.xz *= rotate(sin(tt) * .5 + .6);\n    p.yz *= rotate(cos(tt) * .5 + .8);\n    p += length(p.yx * sin(tt) * .2 + .4) * .2;\n  }\n\n  p *= .4; // to scale fractal\n\n  // primitives\n  float s1 = sphereSDF(p, normalize(vec3(5., 8., 3.)), .3);\n  vec3 p2 = p;\n  p2.xz *= rotate(tt * 10.);\n  float s2 = sphereSDF(p2, normalize(vec3(-5., -3., -4.)), .2);\n\n  vec2 t = vec2(min(s1 * .5, s2 * .5), 5.);\n  g += .1 / (.1 + t.x * t.x * t.x * 50.); // for glow, 100 for tight glow (small = more spread)\n\n  \n  float c1 = cubeSDF(abs(p) - vec3(length(p.yz) + .2, .1, .8), vec3(0.), vec3(.5, .2, .8), .05);\n  c1 += sin(p.x * 30. * sin(tt * .4) * 2.) * cos(p.y * 35. * sin(tt * .5) * 3.) * cos(p.z * 30.) * .03 + cos(tt * .08) * .01;\n  float c2 = cubeSDF(abs(p) - vec3(.5, .3, 2.), vec3(0.), vec3(.3, .1, .8), .01);\n\n  vec2 h = vec2(smin(c1 * .8, c2 * .8, 1.2), 1.);\n\n  t = (t.x < h.x) ? t : h; // merge materials\n\n  return t / .5;\n}\n\nvec2 trace (vec3 ro, vec3 rd) {\n  const float MAX_DEPTH = 50.;\n  vec2 h, t = vec2(.1);\n\n  for (int i = 0; i < 128; i++) {\n    h = map(ro + rd * t.x);\n    if (h.x < .0001 || t.x > MAX_DEPTH) break;\n    t.x += h.x; t.y = h.y;\n  }\n  if (t.x > MAX_DEPTH) t.x = 0.;\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    map(p - e.xyy).x,\n    map(p - e.yxy).x,\n    map(p - e.yyx).x));\n}\n\nstruct Material {\n  float ambient;\n  float diffuse;\n  float specular;\n};\n\nfloat getLight (vec3 lightPos, vec3 p, vec3 rd, float lightOcclusion, Material material) {\n  // https://www.shadertoy.com/view/ll2GW1\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  // phong reflection\n  float ambient = clamp(.5 + .5 * normal.y, 0., 1.);\n  float diffuse = clamp(dot(normal, light), 0., 1.);\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 16.);\n\n  return (ambient * material.ambient * lightOcclusion) +\n   (diffuse * material.diffuse * lightOcclusion) +\n   (diffuse * specular * material.specular * lightOcclusion);\n}\n\nvec3 getRayDirection (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  // https://www.youtube.com/watch?v=PBxuVlp7nuM\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  tt = mod(iTime * .1, 100.);\n\n  // camera\n  vec3 ro = vec3(0., 0., 20. + sin(tt) * 10. + 15.);\n  ro.xz *= rotate(tt * .25);\n  ro.yz *= rotate(tt * .5);\n  vec3 rd = getRayDirection(uv, ro, vec3(0.), 2.);\n\n  // color, fog and light direction\n  // vec3 ld = normalize(vec3(.5, .8, .5));\n  // vec3 ld1 = vec3(5., 8., 3.);\n  vec3 ld1 = vec3(5., 8., 3.);\n  // vec3 ld2 = vec3(15., 28., 13.);\n  vec3 ld2 = vec3(-5., -3., -4.);\n  vec3 fog = vec3(.09, .08, .02) * (.5 + (length(uv) - .3));\n  vec3 color = fog;\n\n  // scene\n  vec2 sc = trace(ro, rd);\n  float t = sc.x;\n\n  if (t > 0.) {\n    vec3 p = ro + rd * t;\n    vec3 normal = getNormal(p);\n    vec3 albido = vec3(.5, .5, .2);//base color\n\n    if (sc.y < 3.) {\n      albido = vec3(.8, .2, .3);\n    }\n\n    // lightning\n    // float diff = clamp(dot(p, ld), 0., 1.) * .5;\n    color *= getLight(ld1, p, rd, .2, Material(.1, .5, .2));\n    ld2.xz *= rotate(tt * 10.);\n    color += getLight(ld2, p, rd, .5, Material(.1, .8, 3.2));\n    color *= albido;\n    color = mix(color, fog, 1. - exp(-.0001*t*t*t)); //gradient\n  }\n\n  color += vec3(.5, .5, .2) * g * .03; // for glow\n  fragColor = vec4(pow(color, vec3(.45)), 1.);\n}","name":"Image","description":"","type":"image"}]}