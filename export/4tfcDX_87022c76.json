{"ver":"0.1","info":{"id":"4tfcDX","date":"1506863956","viewed":129,"name":"Torus (cloned) with Twin Shade C","username":"tgsstdio","description":"Twin shade of torus with variable sized duo-shade\n\nORIGINAL code of TORUS -https://www.shadertoy.com/view/ll33Wn\nTorus with Twin Shade B - https://www.shadertoy.com/view/lllyDB\nTwin Shade C - https://www.shadertoy.com/view/XtfcDX","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// USE ANY CUTOFF VALUES YOU LIKE. \n\n#define LIGHT_SHADE_CUTOFF 0.43\n#define DARK_SHADE_CUTOFF 0.15\nconst vec3 TORUS_COLOR = vec3(1.0, 0.5, 0.1);\n\n/// FORK of https://www.shadertoy.com/view/ll33Wn (95% of code is from here)\n/// MY CHANGES due to diffuse toon shading\n\n#define EPSILON 0.0001\n#define MAX_STEPS 500\n#define MIN_DIST 0.0\n#define MAX_DIST 25.0\n\n#define AMBIENT 0.1\n#define EDGE_THICKNESS 0.015\n#define SHADES 4.0\n\nfloat TorusSDF(vec3 samplePoint, vec2 dimensions)\n{\n\treturn length( vec2(length(samplePoint.xz)-dimensions.x,samplePoint.y) )-dimensions.y;\n}\n\nfloat SceneSDF(vec3 samplePoint)\n{\n    return TorusSDF(samplePoint, vec2(1.3, 0.45));\n}\n\nfloat March(vec3 origin, vec3 direction, float start, float stop, inout float edgeLength)\n{\n    float depth = start;\n    \n    for\t(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = SceneSDF(origin + (depth * direction)); // Grab min step\n        edgeLength = min(dist, edgeLength);\n        \n        if (dist < EPSILON) // Hit\n            return depth;\n        \n        if (dist > edgeLength && edgeLength <= EDGE_THICKNESS ) // Edge hit\n            return 0.0;\n        \n        depth += dist; // Step\n        \n        if (depth >= stop) // Reached max\n            break;\n    }\n    \n    return stop;\n}\n\nvec3 RayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - (size / 2.0);\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 EstimateNormal(vec3 point)\n{\n    return normalize(vec3(SceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - SceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n                          SceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n                          SceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - SceneSDF(vec3(point.x, point.y, point.z - EPSILON))));\n}\n\nmat4 LookAt(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - camera);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    \n    return mat4(vec4(s, 0.0),\n        \t\tvec4(u, 0.0),\n        \t\tvec4(-f, 0.0),\n        \t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\n// NEW CODE HERE (START)\n\n// isLight: true for light shade pattern, false for darker shade pattern\n// uv: normalized uv coordinates\n// cellSize: in pixel size (0, inf)\n// screenRect: screen dimensions in pixels\n// lineWidth: percentage (0 - 1.0)\n// gradientWidth: percentage [0 - 1.0) w.r.t lineWidth\nfloat twinShadeC(bool isLight, vec2 uv, float cellSize, vec2 screenRect, float lineWidth, float gradientWidth)\n{\n   vec2 cellDims = cellSize / iResolution.xy;    \n    \n   vec2 bckSlash = normalize(vec2(screenRect.x / screenRect.y, 1.));\n   vec2 fwdSlash = normalize(vec2(-1, iResolution.y / iResolution.x));      \n  \n   vec2 bottomLeft = floor(uv / cellDims) * cellDims;          \n   vec2 bottomRight = bottomLeft + vec2(cellDims.x, 0.);   \n   \n   vec4 d0, d1;   \n   d0.xy = vec2(dot(fwdSlash, bottomLeft)); // fd0\n   d0.zw = vec2(dot(bckSlash, bottomRight)); // bd0\n    \n   d1.x = dot(fwdSlash, bottomRight); // fd2\n   d1.y = dot(fwdSlash, uv); // fd1\n\n   d1.z = dot(bckSlash, bottomLeft); // bd2    \n   d1.w = dot(bckSlash, uv); // bd1                                   \n\n   vec4 d2 = abs(d1 - d0);    \n    \n   float percent = lineWidth * (0.5 - gradientWidth);\n    \n   vec4 dMinMax = d2.xzxz;\n   dMinMax.xy *= percent;\n   dMinMax.zw *= (1. - percent);    \n   \n   float cutoff = isLight \n       ? dMinMax.z\n       : dMinMax.x;  \n    \n   vec3 compareLeft = vec3(d2.yw, cutoff);\n   vec3 compareRight = vec3(dMinMax.xy, d2.y);\n   \n   bvec3 result = lessThanEqual(compareLeft, compareRight);\n   \n   float color = 0.;    \n   if (any(bvec2(result.x, all(result.yz))))\n   {\n      color = 0.;\n   }\n   else\n   {              \n      vec2 halves = vec2(lineWidth, dMinMax.z + dMinMax.x) * 0.5;       \n\n      vec2 lightMin = d2.xz * halves.x;   \n      \n      vec3 lightGrad = abs(vec3(dMinMax.x, lightMin.x, d2.y) - halves.y);\n\n      vec3 low = vec3(lightGrad.x, dMinMax.x, dMinMax.y);\n      vec3 high = vec3(lightGrad.y, lightMin.xy);\n      vec3 value = vec3(lightGrad.z, d2.y, d2.w);\n       \n      vec3 blending = smoothstep(low, high, value);      \n       \n\n      vec4 shadeLeft = vec4(d2.yw, lightMin.xy);\n      vec4 shadeRight = vec4(lightMin.xy, d2.yw);\n       \n      bvec4 shadeTest = greaterThanEqual(shadeLeft, shadeRight);\n       \n      \n       float factor = 1.;       \n       if (isLight)\n       {                       \n          factor = blending.x;                    \n       }      \n       else \n       {\n          bvec3 darkBlend0 = bvec3(!result.x, shadeTest.zy);\n           \n          //if (!result.x && shadeTest.z && shadeTest.y)\n          if (all(darkBlend0))\n   \t      {\n       \t\t factor = blending.y; \n  \t\t  }                                   \n           \n          bvec3 darkBlend1 = bvec3(!result.y, shadeTest.wx);\n           \n          //if (!result.y && shadeTest.w && shadeTest.x)\n          if (all(darkBlend1))\n   \t      {\n       \t\t factor = blending.z; \n  \t\t  } \n           \n          if (all(shadeTest.wz))\n    \t  // if (shadeTest.w && shadeTest.z)\n    \t  {         \n    \t     factor = clamp(blending.y * blending.z, 0., 1.0); \n          }            \n       }              \n       \n       color = factor;\n   }\n   return color;\n}\n\n\nvec3 ComputeLighting(vec3 point, vec2 uv, vec3 lightDir, vec3 lightColor,\n\tfloat cellSize, vec2 screenRect, float lineWidth, float gradientWidth)\n{\n    vec3 color = vec3(AMBIENT);\n    float diffuse = dot(EstimateNormal(point), normalize(lightDir));\n    float colorIntensity = ceil(diffuse * SHADES) / SHADES;\n    colorIntensity = max(colorIntensity, AMBIENT);    \n   \n    if (diffuse >= LIGHT_SHADE_CUTOFF)        \n    \tcolor = lightColor * colorIntensity;\n    else if (diffuse >= DARK_SHADE_CUTOFF) \n    {\n\t\tfloat lightShade =twinShadeC(\n            true,\n            uv,\n            cellSize,\n            screenRect,\n            lineWidth,\n            gradientWidth\n        );        \n        color = lightShade * colorIntensity * lightColor;\n    }\n     else\n     {\n      \tfloat darkShade = twinShadeC(\n            false,\n            uv,\n            cellSize,\n            screenRect,\n            lineWidth,\n            gradientWidth\n        );     \n        color = darkShade * colorIntensity * lightColor;\n     }\n    return color;\n}\n\n// SHOULD BE SQUARE ON SCREEN NOT RECTANGULAR\n#define SUBDIVISION_LOOP_IN_SECS 18.0\n#define NO_OF_DIVISIONS 4\n\n#define MID_POINT 0.4\n#define TWO_PI 6.283185307179586476925286766559\n#define FREQUENCY 0.255\n#define RANGE_OF_TRIG_FUNC 0.2\n\n#define GRAD_MID_POINT 0.25\n#define GRAD_FREQUENCY 0.155\n#define GRAD_RANGE_OF_TRIG_FUNC 0.2\n\n// NEW CODE HERE (END)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 origin = vec3(sin(iTime) * 9.0, (sin(iTime * 2.0) * 4.0) + 6.0, cos(iTime) * 9.0);\n    mat4 viewTransform = LookAt(origin, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    viewDir = (viewTransform * vec4(viewDir, 0.0)).xyz;\n    \n    float edgeLength = MAX_DIST;\n    float dist = March(origin, viewDir, MIN_DIST, MAX_DIST, edgeLength);\n    \n    if (dist > MAX_DIST - EPSILON) // No hit\n    {\n        fragColor = vec4(0.6);\n        return;\n    }\n    \n    if (dist < EPSILON) // Edge hit\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 hitPoint = origin + (dist * viewDir);\n    vec3 lightDir = vec3(sin(iTime * 2.0) * 6.0, 4.0, sin(iTime * 1.25) * 5.0);\n   \n    // SELECTING CELL SIZE\n    float gapTimeStep = mod(iTime, SUBDIVISION_LOOP_IN_SECS) / SUBDIVISION_LOOP_IN_SECS;\n\n    float sections[4] = float[](    \n        4.,\n        8.,\n        12.,\n        16.\n   ); \n    \n   float lineWidth = MID_POINT + RANGE_OF_TRIG_FUNC * sin( FREQUENCY * TWO_PI * iTime);    \n    \n   float gradientWidth = GRAD_MID_POINT + GRAD_RANGE_OF_TRIG_FUNC * sin( GRAD_FREQUENCY * TWO_PI * iTime);    \n\n   float cellSize = sections[int(gapTimeStep * float(NO_OF_DIVISIONS))];     \n   \n   vec2 uv = fragCoord.xy / iResolution.xy; \n   vec3 color = ComputeLighting(hitPoint, uv, lightDir, TORUS_COLOR, cellSize, iResolution.xy, lineWidth, gradientWidth);\n    \n   fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}