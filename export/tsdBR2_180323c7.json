{"ver":"0.1","info":{"id":"tsdBR2","date":"1605591780","viewed":135,"name":"Torus Sphere Marching","username":"KJK","description":"My first sphere marching shader.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spheremarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mapSdf(vec3 p, float t);\nfloat trace(vec3 ro, vec3 dir, float t);\nvec3 mapNormal(vec3 p, float t);\nvec3 pointLight(vec3 p, vec3 nor, vec3 light, vec3 color);\nvec3 directionalLight(vec3 p, vec3 nor, vec3 dir, vec3 color);\nfloat torusSdf(vec3 p, vec3 center, vec3 axis, float R, float r);\nvec3 rayDir(vec3 camDir, vec2 uv);\nfloat calcAO(vec3 p, vec3 nor, float t);\nfloat calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k, float time, int maxSteps );\nfloat diskSdf(vec3 p, vec3 center, vec3 axis, float r);\nvec3 render(vec2 uv, float t);\nfloat boxSdf(vec3 p, vec3 r);\n\nfloat TAU = 6.283185307;\nvec3 ONE3 = vec3(1.0);\nvec3 ZERO3 = vec3(0.0);\nvec3 UP = vec3(0.0, 1.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 e = vec2(.75, 0.0);\n    vec3 col = render(fragCoord, iTime);\n    \n    // Take extra samples in high contrast regions.\n    float brightness = length(col);\n    vec2 gradient = vec2(dFdx(brightness), dFdy(brightness));\n    float relativeContrast = length(gradient) / brightness;\n    if (relativeContrast >= 0.02) {\n        col += render(fragCoord + e.xy, iTime).xyz\n            +  render(fragCoord + e.yx, iTime).xyz\n            +  render(fragCoord - e.xy, iTime).xyz\n            +  render(fragCoord - e.yx, iTime).xyz;\n        col *= 1.0 / 5.0;\n        //col = vec3(1.0);\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n\nvec3 render(vec2 uv, float t) {\n    // Normalized x coordinates (from -.5 to .5)\n    uv = (uv - iResolution.xy * .5) / iResolution.x;\n\n    vec3 camPos = vec3(.0,130.0,-250.0);\n    vec3 camDir = normalize(vec3(0.0, -.4, 1.0));\n    vec3 rd = rayDir(camDir, uv);\n    float dist = trace(camPos, rd, t);\n    \n    vec3 col;\n    \n    if (dist >= 0.0) {\n        vec3 hit = camPos + rd * dist;\n        vec3 nor = mapNormal(hit, t);\n\n        vec3 l1pos = normalize(vec3(1.0, 1.0, .5)) * 1500.0;\n        vec3 l1col = vec3(.7, .7, 1.0) * 1000000.0;\n        vec3 l1 =  pointLight(hit, nor, l1pos, l1col) *  calcSoftShadow(hit, normalize(l1pos - hit), 1.0, 1000.0, 10.0, t, 100);\n\n        vec3 ambientLight = vec3(1.0, .7, .7) * .02;\n        vec3 l2 = directionalLight(hit, nor, -UP, ambientLight) + ambientLight * calcAO(hit, nor, t);\n\n        vec3 l3pos = normalize(vec3(-1.0, 1.0, .5)) * 1500.0;\n        vec3 l3col = vec3(1.0, .8, .5) * 1000000.0;\n        vec3 l3 =  pointLight(hit, nor, l3pos, l3col) *  calcSoftShadow(hit, normalize(l3pos - hit), 1.0, 1000.0, 10.0, t, 100);\n\n        col = l1 + l2 + l3;\n        //col *= 1.0 - pow(abs(dot(nor, rd)), 4.0);\n        //col *= mix((nor + ONE3) * .5, ONE3, .0);\n        //col.x = col.y = col.z;\n    }\n    \n    return col;\n}\n\nvec3 rayDir(vec3 camDir, vec2 uv) {\n    float fovAngle = 90.0 * TAU / 360.0;\n    float focalLength = .5 / tan(fovAngle *.5);\n    vec3 camRight = cross(UP, camDir);\n    vec3 camUp = cross(camDir, camRight);\n    vec3 rd = camDir * focalLength + uv.x * camRight + uv.y * camUp;\n    return normalize(rd);\n}\n\n// Lighting\n\nvec3 pointLight(vec3 p, vec3 nor, vec3 light, vec3 color) {\n    vec3 toLight = light - p;\n    vec3 toLightNor = normalize(toLight);\n    float distSq = dot(toLight, toLight);\n    return max(vec3(.0), dot(nor, toLightNor) * color / distSq);\n}\n\nvec3 directionalLight(vec3 p, vec3 nor, vec3 dir, vec3 color) {\n    return max(vec3(.0), dot(nor, dir) * color);\n}\n\nfloat calcAO(vec3 p, vec3 nor, float t) {\n    float occ = 0.0;\n    float scale = 0.02;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.01 + 3.0 * float(i);\n        float d = mapSdf(p + nor * h, t);\n        occ += (h - d) * scale;\n        scale *= 0.95;\n    }\n    return clamp(1.0 - 1.0 * occ, 0.0, 1.0);\n}\n\n// Sebastian Aaltonen's algorithm\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k, float time, int maxSteps ) {\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for( float t=mint; t<maxt; ) {\n        if (i++ > maxSteps) return res;\n        float h = mapSdf(ro + rd*t, time);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// Ray Marching\n\nfloat trace(vec3 ro, vec3 rd, float t) {\n    float epsilon = .1;\n    float dist = .0;\n    for(int i = 0; i < 500; i++) {\n        float d = mapSdf(ro + rd * dist, t);\n        dist += d;\n        if (d < epsilon) return dist;\n    }\n    return -1.0;\n}\n\nfloat mapSdf(vec3 p, float t) {\n    //t = TAU / 16.0;\n    // Rotating Torus\n    float phi = TAU / 8.0;    \n    float theta = t * 2.0;\n    vec3 axis = vec3(sin(theta) * sin(phi), cos(phi), cos(theta) * sin(phi));\n    float R = 50.0;\n    float r = 10.0;\n    float torusY = R * sin(phi) + r + 1.0;\n    vec3 torusCenter = ZERO3 + UP * torusY;\n    float torusD = torusSdf(p, torusCenter, axis, R, r );\n    \n    float groundD = p.y;\n    float wallD = 2000.0 - p.z;\n    \n    float d = min(groundD, torusD);\n    d = min(d, wallD);\n    return d;\n}\n\nvec3 mapNormal(vec3 p, float t) {\n    vec2 e = vec2(1.0, .0);\n    float d = mapSdf(p, t);    \n    float dx = (mapSdf(p + e.xyy, t) - d) / e.x;\n    float dy = (mapSdf(p + e.yxy, t) - d) / e.x;\n\tfloat dz = (mapSdf(p + e.yyx, t) - d) / e.x;\n    return normalize(vec3(dx, dy, dz));\n}\n\n// SDFs\n\nfloat torusSdf(vec3 p, vec3 center, vec3 axis, float R, float r) {\n    vec3 d = p - center;\n    float v = dot(d, axis);            // Vertical displacement (along axis).\n    float h = sqrt(dot(d, d) - v * v); // Horizontal displacment (normal to axis).\n    float x = h - R;\n    return sqrt(v * v + x * x) - r;\n}\n\nfloat diskSdf(vec3 p, vec3 center, vec3 axis, float r) {\n    vec3 d = p - center;\n    float h = dot(d, axis);\n    float v = sqrt(dot(d, d) - h * h);\n    float x = abs(v - r);\n    return x > r ? sqrt(x*x + h*h) : h;\n}\n\nfloat boxSdf(vec3 p, vec3 r) {\n    p = abs(p);\n    vec3 q = min(p, r);\n    return length(q - p);\n}","name":"Image","description":"","type":"image"}]}