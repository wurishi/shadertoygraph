{"ver":"0.1","info":{"id":"MdcBD7","date":"1525395962","viewed":161,"name":"BadTv","username":"IthsMaze","description":"a shader to represent a bad tv signal\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// luminance constants\n\nconst vec3\tCOLOR_601LUMINANCEWEIGHTS = vec3( 0.298939, 0.586625, 0.114436 );\n\n\n// BadTV Constants\nconst float ScrollDirection = 0.0;\nconst float BadTv_ScrollSpeed = 0.0;\nconst float BadTv_ScrollDir = 1.0;\nconst float BadTv_ColorOffsetRX = 0.01;\nconst float BadTv_ColorOffsetRY = 0.01;\nconst float BadTv_ColorOffsetGX = 0.009;\nconst float BadTv_ColorOffsetGY = 0.005;\nconst float BadTv_ColorOffsetBX = 0.005;\nconst float BadTv_ColorOffsetBY = 0.005;\nconst float BadTv_ScanLineThickness  = 2.0;\nconst float BadTv_ScanLineDistance   = 3.0;\nconst float BadTv_ScanLineBrightness = 1.1;\nconst float BadTv_Saturation = 0.0;\nconst float BadTv_GrainSize = 1.0;\nconst float BadTv_GrainIntensity = 0.0;\nconst float BadTv_WaveRepitition = 0.0;\nconst float BadTv_WaveWidth = 0.00;\n\nfloat rand(float n)\n{\n    return fract(cos(n*89.42)*343.42);\n}\n\nfloat Color_RGBToLuminance( vec3 C )\n{\n    return dot( C, COLOR_601LUMINANCEWEIGHTS );\n}\n\n\nvec4 CFX_TiledText2D( sampler2D Source, vec2 TexCoord )\n{\n\tvec2 Offset = step( vec2(1.0,1.0), TexCoord ) + step( TexCoord, vec2(0.0,0.0) ) * -1.0;\n\treturn texture( Source, TexCoord - Offset );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float PixelWidth = 1.0/iResolution.x;\n    float PixelHeight = 1.0/iResolution.y;\n\n\tvec4 FinalColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    \n    vec4 Random_24fps = vec4( rand(iTime), rand(iTime), rand(iTime), rand(iTime) );\n\n\t// screen scroll\n\t// scroll the screen up or down\n\tfloat ScrollTimer = iTime * BadTv_ScrollSpeed;\n\tfloat Scroll = ( ( ScrollTimer - floor( ScrollTimer ) ) * BadTv_ScrollDir );\n\n\t// wave with noise:\n\tvec4 WaveRand = texture( iChannel1, abs( Random_24fps.xz ) );\n\tfloat WaveRepitition = ( uv.y * ( BadTv_WaveRepitition * WaveRand.x ) );\n\tfloat WaveWidth = BadTv_WaveWidth * WaveRand.z;\n\tfloat Wave = max(0.0, WaveWidth - abs( WaveWidth - mod( WaveRepitition, ( 2.0 * WaveWidth ) ) ) );\n\t// if Wave is off we need to make sure it is 0. Kinda a hack.\n\n\t// ColorShift\n\t// red\n\t// offset for colorshift\n\tvec2 OffsetR = vec2( uv.x - BadTv_ColorOffsetRX, uv.y - BadTv_ColorOffsetRY );\n\t// offset for scroll and wave\n\tOffsetR.y += Scroll;\n\tOffsetR.x += Wave;\n\n\t// green\n\t// offset for colorshift\n\tvec2 OffsetG = vec2( uv.x - BadTv_ColorOffsetGX, uv.y - BadTv_ColorOffsetGY );\n\t// offset for scroll and wave\n\tOffsetG.y += Scroll;\n\tOffsetG.x += Wave;\n\n\t// blue\n\t// offset for colorshift\n\tvec2 OffsetB = vec2( uv.x - BadTv_ColorOffsetBX, uv.y - BadTv_ColorOffsetBY );\n\t// offset for scroll and wave\n\tOffsetB.y += Scroll;\n\tOffsetB.x += Wave;\n\n\t// apply color shift, scroll, and wave\n\tFinalColor.r = CFX_TiledText2D( iChannel0, OffsetR ).r;\n\tFinalColor.g = CFX_TiledText2D( iChannel0, OffsetG ).g;\n\tFinalColor.b = CFX_TiledText2D( iChannel0, OffsetB ).b;\n\n\t// ScanLine\n\t// scan line thickness\n\t// find the height\n\tfloat ScanLineSize = BadTv_ScanLineThickness + BadTv_ScanLineDistance;\n\tfloat ScanLineNorm = (uv.y * ( 1.0 / PixelHeight ) ) / ScanLineSize;\n\tfloat ShouldBrighten = step( BadTv_ScanLineDistance / ScanLineSize, ScanLineNorm - floor(ScanLineNorm) );\n\n\t// find out if it should be a scanline or not\n\tfloat Brighten = ShouldBrighten * BadTv_ScanLineBrightness;\n\n\t// apply scan lines\n\tFinalColor.rgb *= Brighten + ( 1.0 - ShouldBrighten );\n\n\t// saturation\n    float Luminance = Color_RGBToLuminance( FinalColor.rgb );\n\tvec3 Lum = vec3( Luminance, Luminance, Luminance );\n\tFinalColor = vec4( mix( Lum, FinalColor.rgb, BadTv_Saturation), FinalColor.a );\n\n\t// static\n\tfloat Grain = texture( iChannel1, ( uv.xy + Random_24fps.zw ) / ( 256.0 * BadTv_GrainSize * vec2( PixelWidth, PixelHeight ) ) ).b;\n\tFinalColor.rgb -= vec3( Grain, Grain, Grain ) * BadTv_GrainIntensity;\n\n\tFinalColor = clamp(FinalColor, 0.0, 1.0);\n    \n\n    // Output to screen\n    fragColor = FinalColor;\n}","name":"Image","description":"","type":"image"}]}