{"ver":"0.1","info":{"id":"ftyczz","date":"1660833149","viewed":146,"name":"Uniform foliage simplex","username":"GribUser","description":"Same as https://www.shadertoy.com/view/NtccWs, but simplex noise instead of perlin","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["dots","uniform","foliage","trianglegrid"],"hasliked":0,"parentid":"NtccWs","parentname":"Uniform non-colliding foliage"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 DotColor, vec2 inCoords) {\n\tvec2 ScaledCOords = inCoords / iResolution.x * VoxelsOnScreen;\n\n\tvec2 RelCoords = inCoords / iResolution.xy;\n\tvec2 VoxelSizeOnTexture = vec2(1.0 / VoxelsOnScreen * iResolution.y / iResolution.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t 1.0 / VoxelsOnScreen);\n\n\tfloat HasYong = 0.0;\n\tfloat HasMature = 0.0;\n\tfloat HasAging = 0.0;\n\tfloat StageProgress = fract(iTime/FOliageLifetime);\n\n\tfor (float x = -TreeSize; x < TreeSize; x += 1.0) {\n\t\tfor (float y = -TreeSize; y < TreeSize; y += 1.0) {\n\t\t\tvec2 Shift = vec2(x, y);\n\t\t\tfloat L = length(Shift);\n\t\t\tif (L > TreeSize) { continue; }\n\t\t\tvec2 ARelCoords = RelCoords + VoxelSizeOnTexture * vec2(x, y);\n\t\t\tfloat TreeMode = texture(iChannel0, ARelCoords).r;\n\t\t\tif (TreeMode >= 0.8) {\n\t\t\t\tfloat F = L > TreeCenterSize ? 0.3 : 0.6;\n\t\t\t\tif (F > HasAging) { HasAging = F; }\n\t\t\t} else if (TreeMode >= 0.4) {\n\t\t\t\tfloat F = L > TreeCenterSize ? 0.3 : 0.6;\n\t\t\t\tif (F > HasMature) { HasMature = F; }\n\t\t\t} else if (TreeMode > 0.0) {\n\t\t\t\tfloat GrowingTreeSize = TreeSize * StageProgress * 0.8 + 0.2;\n\t\t\t\tif (L <= GrowingTreeSize) {\n\t\t\t\t\tfloat F = L > GrowingTreeSize/2.0 ? 0.4 : 0.8;\n\t\t\t\t\tif (F > HasYong) { HasYong = F; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tDotColor = vec4(HasYong, HasMature, HasAging, 1.0);\n//\treturn;\n\tDotColor = texture(iChannel0, RelCoords);\n\n\tif (DotColor.r != 0.0) {\n        DotColor = vec4(0.1, 1.0, 0.1, 1.0);\n    } else {\n\t\tif (HasAging > 0.0 && (StageProgress < 0.5 || HasMature == 0.0)) {\n\t\t\tDotColor.r = HasAging * smoothstep(0.0, 1.0, StageProgress);\n\t\t\tDotColor.g = HasAging - DotColor.r / 2.0;\n\t\t} else if (HasMature > 0.0) {\n\t\t\tDotColor.g = HasMature;\n\t\t} else if (HasYong > 0.0) {\n\t\t\tDotColor.g = HasYong;\n\t\t\tDotColor.r = HasYong / 3.0;\n\t\t}\n\t}\n//\tfloat Noise = noise_sum(floor((ScaledCOords + iTime * 3.0)) / 100.0, 0.0) * 0.5 + 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Technical\nfloat NoiseYshift = 5834.32;\n\nfloat NoiseAt(in vec2 p, float NoisePhase) {\n\tp += NoisePhase * 7.31;\n\tvec2 m = vec2(1.6, 1.2);\n\tfloat dx = 0.0;\n\tdx = 0.5000 * noise(p); p = m * p;\n\tdx += 0.2500 * noise(p); p = m * p;\n\tdx += 0.1250 * noise(p); p = m * p;\n\tdx += 0.0625 * noise(p); p = m * p;\n\treturn dx;\n}\n\nvec2 ShiftAt(in vec2 Coord) {\n\tvec2 p = Coord.xy * noise1Scale;\n\treturn vec2(NoiseAt(p, 0.0), NoiseAt(p + Noiseyshift, 0.0));\n}\n\n#define sqrt3 1.7320508\n\nvec2 HexCoords(vec2 inCoords) {\n\treturn inCoords * mat2(1, -1. / sqrt3, 0, 2. / sqrt3);\n}\n\nbool DCells(vec2 ScaledCOords) {\n\tvec2 VoxelTLCoords = ScaledCOords + ShiftAt(ScaledCOords * noise1Scale) * noise1Power;\n\n\tfloat CellY00 = VoxelTLCoords.y / (Dencity * sqrt3 / 2.0);\n\tfloat FloorecCellY00 = floor(CellY00);\n\tfloat CellX00 = VoxelTLCoords.x / Dencity * 2.0;\n\tfloat FloorecCellX00 = floor(CellX00);\n\tbool ModY = mod(FloorecCellY00, 2.0) == 0.0;\n\tbool ModX = mod(FloorecCellX00, 2.0) == 0.0;\n\n\tvec2 VoxelBRCoords = ScaledCOords + 1.0;\n\tVoxelBRCoords += ShiftAt(VoxelBRCoords * noise1Scale) * noise1Power;\n\tfloat CellY11 = VoxelBRCoords.y / (Dencity * sqrt3 / 2.0);\n\tfloat FloorecCellY11 = floor(CellY11);\n\tfloat CellX11 = VoxelBRCoords.x / Dencity * 2.0;\n\tfloat FloorecCellX11 = floor(CellX11);\n\n\tbool BothGo = FloorecCellX00 != FloorecCellX11\n\t\t&& FloorecCellY00 != FloorecCellY11;\n//\treturn BothGo;\n\treturn (ModY != ModX) && BothGo;\n}\n\n// Main func\nvoid mainImage(out vec4 DotColor, vec2 inCoords) {\n\n\tvec2 ScaledCOords = floor(inCoords / iResolution.x * VoxelsOnScreen + iTime * 3.0);\n\n\tfloat TreeState = 0.0; // no tree\n\n\tfloat NoisePhase = floor(iTime / FOliageLifetime);\n\tbool PrevGrow = NoiseAt(ScaledCOords / 10.0, NoisePhase) > GrowIntencity * 2.0 - 1.0;\n\tif (PrevGrow) {\n\t\tTreeState = 0.5; // mature tree\n\t} else {\n\t\tNoisePhase += 1.0;\n\t\tbool NowGrow = NoiseAt(ScaledCOords / 10.0, NoisePhase) > GrowIntencity * 2.0 - 1.0;\n\t\tif (NowGrow) {\n\t\t\tTreeState = 0.1; // start growing\n\t\t} else {\n\t\t\t// Not in this turn and not in previous, but what about -2?\n\t\t\tNoisePhase -= 2.0;\n\t\t\tbool WasAgesAgo = NoiseAt(ScaledCOords / 10.0, NoisePhase) > GrowIntencity * 2.0 - 1.0;\n\t\t\tif (WasAgesAgo) {\n\t\t\t\tTreeState = 0.9; // fading out tree\n\t\t\t}\n\t\t}\n\t}\n\tNoisePhase = 0.0;\n\n\tbool CanPlantThisPhase = TreeState != 0.0;\n\n\n\tbool BysyHere = DCells(ScaledCOords + vec2(1.0, -1.0))\n\t\t|| DCells(ScaledCOords + vec2(0.0, -1.0))\n\t\t|| DCells(ScaledCOords + vec2(-1.0, -1.0))\n\t\t|| DCells(ScaledCOords + vec2(1.0, 0.0));\n\tif (BysyHere || !DCells(ScaledCOords)) { TreeState = 0.0; }\n\tbool Dot = !BysyHere && DCells(ScaledCOords);\n\n\n\tif (CanPlantThisPhase) {\n\t\tDotColor = vec4(TreeState, TreeState, TreeState, TreeState);\n\t} else {\n\t\tDotColor = vec4(0.0, Dot ? 0.3 : 0.0, Dot ? 0.1 : 0.0, 1.0);\n\t}\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Visual setup\nconst float VoxelsOnScreen = 200.0;\nconst float Dencity = 6.0;\n\nconst float noise1Power = 7.0;\nconst float noise1Scale = 20.0;\nconst float GrowIntencity = 0.62; // 0..1\nconst float FOliageLifetime = 5.0; //sec\nconst float TreeSize = 7.0;\nconst float TreeCenterSize = TreeSize/2.0;\n\nvec2 hash(vec2 p) // replace this by something better\n{\n\tp = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed) {\n\treturn fract(tan(distance(xy * PHI, xy) * seed) * xy.x);\n}\n\nfloat noise(in vec2 p) {\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor(p + (p.x + p.y) * K1);\n\tvec2  a = p - i + (i.x + i.y) * K2;\n\tfloat m = (a.x < a.y) ? 0.0 : 1.0;\n\tvec2  o = vec2(m, 1.0 - m);\n\tvec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0 * K2;\n\tvec3  h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n\tvec3  n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n\treturn dot(n, vec3(70.0));\n}\n// setup\nfloat scale = 8.0;\nfloat step = 20.0;\nfloat noiseStrength = 2.0;\nfloat RandSeed = 69.0;\nfloat TreeChance = 0.999;\n\n// Technical\nfloat Noiseyshift = 500.2319;\n","name":"Common","description":"","type":"common"}]}