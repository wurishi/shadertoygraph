{"ver":"0.1","info":{"id":"Ds2fzy","date":"1703421164","viewed":77,"name":"New year in winter hut","username":"kryden","description":"This was supposed to look a thousand times better in my imagination. :(","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEP_SIZE        0.5\n#define EPSILON          0.001\n#define MAXIMUM_STEPS    500\n#define FAR              100.0\n\n#define FIREPLACE_POSITION    vec3(-4.5, 0.0, 6.5)\n#define FIREPLACE_SIZE        vec3(2.0, 2.0, 1.0)\n#define FIREPLACE_SHELF_SIZE  0.1\n#define FIRE_COLOR            10.0 * vec3(1.0, 0.25, 0.1)\n\n#define TABLE_XZSIZE          vec2(1.5, 2.0)\n#define TABLE_POSITION        vec3(0.0, 0.0, -ROOM_SIZE.z + TABLE_XZSIZE.y + 1.0)\n#define TABLE_BOARD_YSIZE     0.1\n#define TABLE_PILLAR_YSIZE    1.0\n\n#define BENCH_POSITION        vec3(-4.0, 0.0, -ROOM_SIZE.z + TABLE_XZSIZE.y + 1.0)\n#define BENCH_PILLAR_SIZE     vec2(0.5, 0.5)\n#define BENCH_BOARD_YSIZE     0.1\n\n#define LADDER_POSITION       vec3(6.0, 0.0, ROOM_SIZE.z - SIN_PI12 * 5.5 - 0.1)\n#define BARREL_POSITION       vec3(3.0, 0.0, 6.5)\n\n#define LAMP_0_COLOR          6.0 * vec3(0.5, 0.5, 0.1)\n#define LAMP_0_POSITION       (SHELF_POSITION + vec3(0.0, SHELF_SIZE.y - 0.7, 0.0))\n#define LAMP_1_COLOR          5.0 * vec3(0.2, 2.0, 0.2)\n#define LAMP_1_POSITION       (FIREPLACE_POSITION + vec3(1.5, 2.0 * FIREPLACE_SIZE.y + 2.0 * FIREPLACE_SHELF_SIZE, 0.0))\n\n#define CANDLE_POSITION       vec3(0.0, 2.0 * TABLE_PILLAR_YSIZE + 2.0 * TABLE_BOARD_YSIZE, TABLE_POSITION.z)\n#define CANDLE_COLOR          vec3(1.0, 1.0, 0.0)\n#define BOTTLE_POSITION       vec3(1.0, 2.0 * TABLE_PILLAR_YSIZE + 2.0 * TABLE_BOARD_YSIZE, TABLE_POSITION.z + 1.5)\n\nLight lights[4] = Light[4](\n  Light(FIRE_COLOR,   vec3(0.0, 0.0, 0.0), vec3(0.0), vec3(0.02, 0.2, 1.0)),\n  Light(CANDLE_COLOR, vec3(0.0, 0.0, 0.0), vec3(0.0), vec3(0.02, 0.2, 1.0)),\n  Light(LAMP_0_COLOR, vec3(0.0, 0.0, 0.0), vec3(0.0), vec3(0.01, 0.1, 1.0)),\n  Light(LAMP_1_COLOR, vec3(0.0, 0.0, 0.0), vec3(0.0), vec3(0.02, 0.2, 1.0))\n);\n\nfloat fireNoise(in vec3 p) {\n  p.y -= 10.0 * iTime;\n  return Noise(p, iChannel3);\n}\n\nfloat fire(vec3 p) {\n  float h = 0.0;\n  float r = 0.3 * Noise(10.0 * p, iChannel3);\n  if (length(p.xz * vec2(1.0, 2.0)) > 1.0 + r) return p.y - 1.0;\n  h = 1.3 * fireNoise(20.0 * p);\n  h = pow(h, 3.0);\n  return h;\n}\n \nvec2 fireplace(vec3 p, vec3 position) {\n  vec3 q = p - position;\n  q.xz = abs(q.xz); vec3 size = FIREPLACE_SIZE; float pillar_r = 0.2;\n  float pillar = sdCylinder(q - size, vec2(pillar_r, size.y)); float fin_size = 0.4;\n  float fout = sdBox(p - vec3(position.x, size.y, position.z), vec4(size, 0.0));\n  float fin  = sdBox(p - vec3(position.x, size.y, position.z), vec4(size - vec3(fin_size), 0.0));\n  float cut  = sdBox(p - vec3(position.x, size.y, position.z - size.z), vec4(1.0, 1.0, 0.5, 0.3));\n  float tube_size = 0.5 * (ROOM_SIZE.y - 2.0 * size.y); \n  float tube = sdBox(p - vec3(position.x, 2.0 * size.y + tube_size, position.z), vec4(0.5 * size.x, tube_size, 0.5 * size.z, 0.0));\n  float shelf_size = FIREPLACE_SHELF_SIZE;\n  float shelf = sdBox(p - vec3(position.x, 2.0 * size.y + shelf_size, position.z), vec4(size.x + pillar_r, shelf_size, size.z + pillar_r, 0.0));\n  float ret = min(shelf, min(tube, max(-cut, max(-fin, min(fout, pillar)))));\n  vec3 fire_position = position + vec3(0.0, fin_size, 0.0);\n  float fire = p.y - fire(p - fire_position);\n  ret = min(ret, fire);\n  lights[0].position = fire_position + vec3(0.0, 1.8, 0.0);\n  float id = FIREPLACE_ID * float(ret == fout || ret == -fin|| ret == -cut || ret == tube) +\n             PILLAR_ID * float(ret == pillar) + SHELF_ID * float(ret == shelf) + FIRE_ID * float(ret == fire);\n  return vec2(ret, id);\n}\n\n// Idea from https://www.shadertoy.com/view/Xss3DH\nvec3 halo(in Ray ray, Light light, float dh) {\n  if (dh < distance(ray.origin, light.position)) return vec3(0.0);\n  float t = dot(ray.direction, light.position - ray.origin);\n  float d = length(light.position - (ray.origin + ray.direction * max(t, 0.0)));\n  float h = 1.0 / (d + 1.0);\n  return light.color * pow(h, 7.0);\n}\n\nvec2 table(vec3 p) {\n  vec3 q = p; q.xz = abs(q.xz); \n  q.xz -= vec2(TABLE_XZSIZE);\n  float pillars = sdCylinder(q - vec3(0.0, TABLE_PILLAR_YSIZE, 0.0), vec2(0.2, TABLE_PILLAR_YSIZE));\n  float board = sdBox(p - vec3(0.0, 2.0 + TABLE_BOARD_YSIZE, 0.0), vec4(TABLE_XZSIZE.x + 0.5, TABLE_BOARD_YSIZE, TABLE_XZSIZE.y + 0.5, 0.0));\n  float ret = min(pillars, board);\n  float id = PILLAR_ID * float(ret == pillars) + TABLE_ID * float(ret == board);\n  return vec2(ret, id);\n}\n\nvec2 bottle1(vec3 p, vec3 hrr) {\n  float s1 = sdCylinder(p - vec3(0.0, 0.5 * hrr.x, 0.0), vec2(hrr.y, 0.5 * hrr.x));\n  float s2 = sdCylinder(p - vec3(0.0, hrr.x, 0.0), vec2(hrr.z, hrr.x));\n  return vec2(smoothMin(s1, s2, 0.4), BOTTLE_ID);\n}\n\nfloat bottle2(vec3 p, vec3 hrr) {\n  float s1 = sdSphere(p, vec4(0.0, -0.5 * hrr.x, 0.0, hrr.y));\n  float s2 = sdCylinder(p, vec2(hrr.z, hrr.x));\n  return smoothMin(s1, s2, 0.4);\n}\n\nvec2 lamp(vec3 p, int i, vec3 position) {\n  vec2 rh = vec2(0.25, 0.15);\n  lights[i].position = position + vec3(0.0, 3.0 * rh.y, 0.0);\n  p -= position;\n  float pillar = sdCylinder(p - vec3(0.0, rh.y, 0.0), rh);\n  float lamp = sdSphere(p, vec4(0.0, 3.0 * rh.y, 0.0, rh.x));\n  float ret = min(pillar, lamp);\n  float id = LAMP_ID * float(ret == lamp) + LAMP_PILLAR_ID * float(ret == pillar); \n  return vec2(ret, id);\n}\n\nvec2 shelf(vec3 p, vec3 size, float f, float is) {\n  vec3 v = p; v.x = abs(v.x); float d = 0.1;\n  float side = sdBox(v - vec3(size.x - d, 0.0, 0.0), vec4(d, size.y + 0.1, size.z, 0.0));\n  float idy = clamp(f * floor(p.y / f), -size.y + 1.0, size.y - 1.0);\n  p.y -= idy; p.y -= 0.2;\n  float shelf = sdBox(p, vec4(size.x, 0.1, size.z, 0.0));\n  vec2 bottle = bottle1(p - vec3(0.0, 0.2, 0.0), vec3(0.5, 0.1, 0.05));\n  vec2 ret = vec2(min(shelf, side), SHELF_ID);\n  if (is == 1.0) {\n    ret = MIN(bottle, ret);\n  }\n  return ret;\n}\n\nvec2 room(vec3 p) {\n  vec3 q = p; \n  q.y -= clamp(2.0 * LOG_R * round(0.5 * q.y / LOG_R), 0.0, ROOM_SIZE.y);\n  vec3 r = p - vec3(0.0, LOG_R, 0.0); r.y -= clamp(2.0 * LOG_R * round(0.5 * r.y / LOG_R), -1.0, ROOM_SIZE.y);\n  q.x = abs(q.x); r.z = abs(r.z);\n  float wall_x = sdCylinder(q.xzy - vec3(ROOM_SIZE.x + LOG_R, 0.0, 0.0), vec2(LOG_R, ROOM_SIZE.z + 2.0 * LOG_R));\n  float wall_y = sdCylinder(r.yxz - vec3(0.0, 0.0, ROOM_SIZE.z + LOG_R), vec2(LOG_R, ROOM_SIZE.x + 2.0 * LOG_R));\n  // Floor\n  vec3 s = p; s.z -= clamp(0.5 * round(s.z / 0.5), -ROOM_SIZE.z, ROOM_SIZE.z);\n  s.y = abs(s.y - ROOM_SIZE.y / 2.0);\n  float floor = sdBox(s - vec3(0.0, ROOM_SIZE.y / 2.0 + LOG_R, 0.0), vec4(ROOM_SIZE.x + 2.0 * LOG_R, BOARD_YSIZE, 0.235, 0.0));\n  // Window\n  float window_out = sdBox(p - WINDOW_POSITION, WINDOW_OSIZE);\n  float window_in  = sdBox(p - WINDOW_POSITION - vec3(0.0, 0.0, 0.3), WINDOW_ISIZE);\n  float glass      = sdBox(p - WINDOW_POSITION + vec3(0.0, 0.0, 0.3), GLASS_SIZE);\n  // Beam\n  vec3 u = p; u.x -= clamp(3.0 * round(u.x / 3.0), -ROOM_SIZE.x, ROOM_SIZE.x); float beam_r = 0.1;\n  float beam = sdBox(u - vec3(0.0, ROOM_SIZE.y - BEAM_YSIZE , 0.0), vec4(0.1, BEAM_YSIZE, ROOM_SIZE.z, beam_r));\n  float ret = min(window_out, min(beam, min(floor, min(wall_x, wall_y))));\n  // Door\n  float door_out = sdBox(p - DOORWAY_POSITION, vec4(0.5, 2.5, 1.5, 0.1));\n  float door_in  = sdBox(p - DOORWAY_POSITION, vec4(0.6, 2.2, 1.2, 0.1));\n  vec3 v = p - DOORWAY_POSITION; v.z -= clamp(0.5 * round(v.z / 0.5), -1.0, 1.0);\n  float door = sdBox(v, vec4(0.1, 2.2, 0.21, 0.0));\n  float handle = sdLink(p - vec3(DOORWAY_POSITION.xy, 2.0), 0.2, 0.5, 0.1);\n  vec3 w = p - DOORWAY_POSITION; w.y = abs(w.y);\n  float crossbar = sdBox(w - vec3(0.0, 1.5, 0.0), vec4(0.2, 0.2, 1.0, 0.0));\n  ret = min(crossbar, min(handle, min(door, max(-door_in, min(ret, door_out)))));\n  // Shelf\n  ret = max(-glass, max(-window_in, ret));  \n  float id = ROOM_WALL_ID    * float(ret == wall_x || ret ==  wall_y) +\n             DOOR_ID         * float(ret == door   || ret == crossbar)  + \n             ROOM_FLOOR_ID   * float(ret == floor)  + WINDOW_GLASS_ID * float(ret == -glass)  + \n             ROOM_BEAM_ID    * float(ret == beam)   +  \n             DOORWAY_ID      * float(ret == door_out   || ret == -door_in) + \n             ROOM_WINDOW_ID  * float(ret == window_out || ret == -window_in);\n  return vec2(ret, id);\n}\n\nvec2 bench(vec3 p) {\n  vec3 q = p; q.x = abs(q.x);\n  float basic = sdCylinder(q - vec3(1.5, BENCH_PILLAR_SIZE.y, 0.0), BENCH_PILLAR_SIZE);\n  float h = 2.0 * BENCH_PILLAR_SIZE.y + BENCH_BOARD_YSIZE;\n  float bench = sdBox(p - vec3(0.0, h, 0.0), vec4(2.5, BENCH_BOARD_YSIZE, 1.0, 0.0));\n  float ret = min(basic, bench);\n  float id = PILLAR_ID * float(ret == basic) + BENCH_ID * float(ret == bench);\n  return vec2(ret, id);\n}\n\nvec2 ladder(vec3 p) {\n  vec3 q = p; q = abs(q);\n  float v = sdCapsule(q - vec3(1.0, 0.15, 0.0), vec2(0.15, 5.5));\n  p.y -= clamp(round(p.y), 1.0, 5.0);\n  float c = sdCylinder(p.yxz, vec2(0.15, 1.0));\n  float ret = min(v, c);\n  return vec2(ret, LADDER_ID);\n}\n\nfloat flame(vec3 p) {\n  p.y *= 0.5;\n  p.y += 0.4 * length(p.xz);\n  float ret = sdSphere(p, vec4(0.0, 0.0, 0.0, 0.1));\n  return ret;\n}\n \nvec2 candle(vec3 p, int i, vec3 position) {\n  vec2 rh = vec2(0.2, 0.5), wrh = vec2(0.02, 0.1);\n  p -= position; vec3 q = p - vec3(0.0, rh.y, 0.0);\n  float candle = sdCylinder(q, rh);\n  q -= vec3(0.0, rh.y, 0.0);\n  float flame_offset = 3.0 * wrh.y;\n  lights[i].position = position + vec3(0.0, 2.0 * rh.y + flame_offset , 0.0);\n  float wick = sdCylinder(q, wrh);\n  float flame = flame(q - vec3(0.0, flame_offset, 0.0));\n  float ret = min(flame, min(wick, candle));\n  float id = CANDLE_ID * float(ret == candle) + CANDLE_WICK_ID * float(ret == wick) + \n             CANDLE_FLAME_ID * float(ret == flame);\n  return vec2(ret, id);\n}\n\nvec2 barrel(vec3 p, vec3 position, float size) {\n  vec3 q = p - position - vec3(0.0, size, 0.0); \n  q.zx = abs(q.zx); q.zx *= PI6;\n  q.zx = abs(q.zx); q.zx *= PI6;\n  q.zx = abs(q.zx); q.zx *= PI12;\n  float board = sdBox(q - vec3(0.0, 0.0, 1.0), vec4(PI / 12.0, size, 0.05, 0.0));\n  q.y = abs(q.y);\n  float hoop = sdTorus(q - vec3(0.0, size * 0.5, 0.0), vec2(1.0, 0.1));\n  float ret = min(board, hoop);\n  float id = BARREL_ID * float(ret == board) + HOOP_ID * float(ret == hoop);\n  return vec2(ret, id);\n}\n\nvec2 branch(vec3 p, vec2 rh, vec3 frh, float n) {\n  float branch = sdCapsule(p, rh);\n  float idy = clamp(frh.x * floor(p.y / frh.x), 0.0, rh.y);\n  p.xz *= rotate(idy);\n  p.y -= idy; p.y -= frh.y;\n  float ida = repeatAngle(p.xz, n);\n  p.xz *= rotate(ida + PI / n); p.x -= rh.x + frh.y;\n  p.xy *= rotate(atan(frh.x / frh.z)); frh.z -= 0.04 * idy;\n  float needle = sdCapsule(p.yxz, frh.yz);\n  float ret = min(branch, needle);\n  float id = TREE_BRANCH_ID * float(ret == branch) + TREE_NEEDLE_ID * float(ret == needle);\n  return vec2(ret, id);\n}\n\nvec2 layer(vec3 p, vec2 trh, vec4 fnrh, bool is_bubble) {\n  float idy = clamp(fnrh.x * floor(p.y / fnrh.x), 0.0, trh.y - 1.0);\n  p.y -= idy; p.y -= fnrh.z;\n  float n = fnrh.y - idy;\n  float ida = repeatAngle(p.xz, n);\n  float length = fnrh.w - 0.2 * idy;\n  p.xz *= rotate(ida + PI / n); p.x -= trh.x; float delta = 0.1;\n  p.xy *= rotate(atan(fnrh.x / fnrh.w) - delta);\n  vec2 ret = branch(p.yxz, vec2(fnrh.z, length), vec3(0.1, 0.01, 0.2), 13.0);\n  if (is_bubble && idy < 6.0) {\n    vec2 bubble = vec2(sdSphere(p, vec4(length, 0.0, 0.0, 0.2)), TREE_BUBBLE_ID);\n    ret = MIN(ret, bubble);\n  }\n  return ret;\n}\n\nvec2 gifts(vec3 p) {\n  float n = 9.0;\n  float phi = repeatAngle(p.xz, n);\n  p.xz *= rotate(PI / n + phi);\n  p.y -= 0.2 + 0.05 * phi;\n  float gift = sdBox(p - vec3(1.5 + 0.2 * phi, 0.0, 0.0), vec4(0.2, 0.2 + 0.05 * phi, 0.2, 0.0));\n  return vec2(gift, GIFT_ID);\n}\n\nvec2 tree(vec3 p) {\n  vec2 tree_rh  = vec2(0.05, 7.0);\n  float body = sdCapsule(p, tree_rh);  \n  vec2 branch1 = layer(p, tree_rh, vec4(1.0, 12.0, 0.02, 1.7), false); \n  vec3 q = p; q.y -= 0.5; q.xz *= PI6;\n  vec2 branch2 = layer(q, tree_rh, vec4(1.0, 11.0, 0.01, 1.5), true);\n  vec2 ret = MIN(vec2(body, 1.0), MIN(branch1, branch2));\n  ret = MIN(ret, gifts(p));\n  return ret;\n}\n\nvec3 scene(vec3 p) {\n  vec2 ret = room(p);\n  ret = MIN(ret, table(p - TABLE_POSITION));\n  ret = MIN(ret, bench(p.zyx - BENCH_POSITION.zyx));\n  vec3 q = p - LADDER_POSITION; q.yz *= PI12;\n  ret = MIN(ret, ladder(q));\n  ret = MIN(ret, barrel(p, BARREL_POSITION, 1.0));\n  ret = MIN(ret, candle(p, 1, CANDLE_POSITION));\n  ret = MIN(ret, bottle1(p - BOTTLE_POSITION, vec3(0.7, 0.2, 0.1)));\n\n  ret = MIN(ret, shelf(p.zyx - SHELF_POSITION.zyx, SHELF_SIZE, 1.0, 0.0));\n  ret = MIN(ret, shelf(p - SHELF2_POSITION, SHELF2_SIZE, 2.0, 1.0));\n\n  if (length(p.xz - TREE_POSITION.xz) < 2.5) {\n    ret = MIN(ret, tree(p - TREE_POSITION));\n  }\n  \n  vec2 lamp_1 = lamp(p, 2, LAMP_0_POSITION);\n  vec2 lamp_2 = lamp(p, 3, LAMP_1_POSITION);\n  ret = MIN(ret, lamp_1);\n  ret = MIN(ret, lamp_2);\n  ret = MIN(ret, fireplace(p, FIREPLACE_POSITION));\n  \n  float id = 0.0;\n  if (ret == lamp_1) id = 1.0;\n  if (ret == lamp_2) id = 3.0;\n\n  return vec3(ret, id);\n}\n\nvec3 getNormal(in vec3 p) {\n  const float h = 0.01; \n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(k.xyy * scene(p + k.xyy * h).x + \n                   k.yyx * scene(p + k.yyx * h).x + \n                   k.yxy * scene(p + k.yxy * h).x + \n                   k.xxx * scene(p + k.xxx * h).x);\n}\n\nHit rayMarch(in Ray ray, float near) {\n  Hit hit;\n  hit.id = -1.0;\n  float t = near;\n  for (int i = 0; i < MAXIMUM_STEPS; i++) {\n    vec3 p = ray.origin + ray.direction * t;\n    vec3 d = scene(p);\n    if (d.x < EPSILON) {\n      hit.id = d.y;\n      hit.sub = d.z;\n      hit.position = p; hit.normal = getNormal(hit.position);\n      break;\n    }\n    t += STEP_SIZE * d.x;\n    if (t > FAR) { break; }\n  }\n  return hit;\n}\n\nvec3 getSnow(vec2 uv) {\n  vec3 snow = vec3(0.0);\n  float v = iTime;\n  vec2 pq = uv;\n  for (float j = 1.0; j < J; j += 1.0) {\n    uv *= 1.0 + 0.1 * j;\n    for (float i = 1.0; i < S; i += 1.0) {\n      vec2 id = vec2(i, j);\n      float size = 0.01 / j + 0.01 * random(id);\n      pq.y = uv.y + (v + i + j) * random(id);\n      pq.x = uv.x - 1.0 + 0.5 * i * random(id);\n      pq *= rotate(random(id));\n      pq = fract(pq + vec2(0.5, 0.0) * rotate(0.1 * iTime));\n      float d = step(length(pq - vec2(0.1, 0.1)), size);\n      snow += vec3(0.01, 0.01, 0.2 + random(id)) * d;\n    }\n  }\n  return snow;\n}\n\nvec3 sky(vec2 uv) {\n  vec3 snow = getSnow(uv);\n  return snow;\n}\n\nvec3 getBoxAlbedo(float id, vec3 p, vec3 n) {\n  vec3 texture;\n  if (id == FIREPLACE_ID) {\n    texture = getTexture(iChannel2, p, n).xyz;\n  } else if (id == TABLE_ID) {\n    texture = getTexture(iChannel0, p, n).xyz;\n  } else if (id == GIFT_ID) {\n    texture = getTexture(iChannel1, 10.0 * p, n).xyz;\n  } else {\n    p *= 0.2;\n    texture = getTexture(iChannel1, p, n).xyz;\n  }\n  return texture;\n}\n\nvec3 getBubbleAlbedo(vec3 p) {\n  float b = smoothstep(0.5, 2.5, p.y) - smoothstep(2.5, 4.5, p.y);\n  float g = smoothstep(2.5, 4.5, p.y) - smoothstep(4.5, 6.5, p.y);\n  float r = smoothstep(4.5, 6.5, p.y) - smoothstep(6.5, 7.5, p.y);;\n\n  return vec3(r, g, b);\n}\n\n//Black body radiation function from Fabrice Neyret\n//https://www.shadertoy.com/view/4tdGWM\n\nvec3 blackBodyToRGB(float temp, float brightness) {\n  vec3 color; \n  for (float i = 0.0; i < 3.0; i++) {\n    float f = 1.0 + 0.5 * i; \n    color[int(i)] += brightness * (f * f * f) / (exp((19E3 * f / temp)) - 1.0);\n  }  \n  return color;\n}\n\nMaterial getMaterial(float id, vec3 p, vec3 n) {\n  Material m = Material(vec3(0.2), 0.5, 0.5);\n  if (id >= 0.0 && id < 25.0) m = materials[int(id)]; \n  if (isBox(id)) {\n    m.albedo = getBoxAlbedo(id, p, n); \n  } else if (id == TREE_BUBBLE_ID) {\n    m.albedo = getBubbleAlbedo(p);\n    m.metallic = 2.0;\n    m.roughness = 0.2;\n  } else if (id == LADDER_ID) {\n    vec2 uv = vec2(p.x + p.y, atan(n.x + n.y, n.x + n.z));\n    vec3 texture = texture(iChannel1, 0.1 * uv).xyz;\n    m.albedo = texture;\n  } else if (id == ROOM_WALL_ID) {    \n    vec2 uv = vec2(p.x + p.z, atan(n.x + n.z, n.y));\n    uv -= vec2(p.y); vec3 texture = texture(iChannel1, 0.2 * uv).xyz;\n    m.albedo = mix(m.albedo, texture, 0.8);\n    m.albedo /= (1.0 + abs(n.y));\n  } else if (id == PILLAR_ID || id == LAMP_PILLAR_ID) {\n    vec2 uv = vec2(p.y, atan(n.z, n.x));\n    vec3 tex_tree = texture(iChannel1, 0.2 * uv).xyz;\n    m.albedo = tex_tree;\n  } else if (id == FIRE_ID) {\n    m.albedo = blackBodyToRGB(1000.0 + p.y * 2500.0, 2000.0);\n  } else if (id == WINDOW_GLASS_ID) {\n    m.albedo = getTexture(iChannel0, 0.5 * p, n.xyx).xyz;\n    m.metallic = 1.5 * n.z;\n    m.roughness = 0.1 * n.z;\n  } else if (id == CANDLE_FLAME_ID) {\n    m.albedo = vec3(1.0, 1.0, 0.0);\n  }\n  return m;\n}\n\n// https://iquilezles.org/articles/rmshadows/\n\nbool isLight(float id) {\n  return id == LAMP_ID || id == FIRE_ID || id == CANDLE_FLAME_ID;\n}\n\nbool isRoom(float id) {\n  return id == ROOM_FLOOR_ID || id == ROOM_WALL_ID || id == DOOR_ID;\n}\n\nfloat softShadow(in Ray ray, float near, int steps, float id, vec3 position) {\n  float ret = 1.0;\n  float t = near;\n  for (int i = 0; i < steps && t < FAR; i++) {\n\t  vec3 p = ray.origin + ray.direction * t;\n    vec3 d = scene(p);\n    float distance = distance(p, position);\n    if (d.x < EPSILON && (d.y != id || distance > 0.5) && !isLight(d.y)) return 0.0;\n    if ((d.y!= id || distance > 0.5) && !isLight(d.y)) ret = min(ret, 30.0 * d.x / t);\n    t += d.x;\n  }\n  return ret;\n}\n\nvec3 GetLo(vec3 normal, Ray ray, Light light, Material material) {\n  vec3 halfway_direction = normalize(light.direction - ray.direction);\n  vec3 F0 = vec3(0.04); F0 = mix(F0, material.albedo, material.metallic);\n  float NDF = distributionGGX(normal, halfway_direction, material.roughness); \n  float G = geometrySmith(normal, -ray.direction, light.direction, material.roughness);  \n  vec3  F = fresnelSchlick(max(dot(halfway_direction, -ray.direction), 0.0), F0);\n  float NdotL = max(dot(normal, light.direction), 0.0);\n  vec3 specular = NDF * G * F / (4.0 * max(dot(normal, -ray.direction), 0.0) * NdotL + 0.0001);\n  vec3 kD = (vec3(1.0) - F) * (1.0 - material.metallic);\n  vec3 Lo = (kD * material.albedo / PI + specular) * light.color * NdotL;\n  return Lo;\n}\n\nvoid notLight(Ray ray, Hit hit, Material m, inout vec3 color) {\n  for (int i = 0; i < 4; i++) {\n    Light light = lights[i];\n    light.direction = normalize(light.position - hit.position);\n    light.color *= getAttenuation(length(hit.position - light.position), light.attenuation);\n    Ray light_shadow = Ray(light.position, -light.direction);\n    vec3 LoLight = GetLo(hit.normal, ray, light, m);\n    color += LoLight * softShadow(light_shadow, 0.4, 32, hit.id, hit.position);\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {      \n  vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.xy;\n\n  uv.y *= iResolution.y/iResolution.x;\n\n  Ray ray;\n  ray.origin = vec3(0.0, 4.0, 0.0);\n  vec3 target =  vec3(-5.0, 4.0, 4.0);\n  ray.direction = normalize(lookAt(ray.origin, target) * vec3(uv, -1.0));\n\n  ray.direction.xz *= rotate(0.5 * iTime);\n\n  vec3 color = sky(uv);\n\n  Hit hit = rayMarch(ray, 0.0);\n\n  if (hit.id != -1.0) {\n    Material m = getMaterial(hit.id, hit.position, hit.normal);\n    if (hit.id != LAMP_ID && hit.id != CANDLE_FLAME_ID && hit.id != FIRE_ID) {\n      color = 0.1 * m.albedo;\n      notLight(ray, hit, m, color);\n    } else {\n      color = 2.0 * lights[int(hit.sub)].color;\n    }\n\n    if (hit.id == WINDOW_GLASS_ID && hit.normal.z == 1.0) {\n\n      Ray reflected = Ray(hit.position, reflect(ray.direction, hit.normal));\n\n      Hit reflected_hit = rayMarch(reflected, 0.1);\n\n      Material reflected_m = getMaterial(reflected_hit.id, reflected_hit.position, reflected_hit.normal);\n      vec3 reflected_color = 0.1 * reflected_m.albedo;\n      if (reflected_hit.id != LAMP_ID && reflected_hit.id != CANDLE_FLAME_ID && reflected_hit.id != FIRE_ID) {\n          notLight(reflected, reflected_hit, reflected_m, reflected_color);\n      } else {\n          color = 2.0 * lights[int(reflected_hit.sub)].color;\n      }\n      color += reflected_color;\n    }\n\n    color += halo(ray, lights[1], distance(ray.origin, hit.position));\n    color += halo(ray, lights[2], distance(ray.origin, hit.position));\n    color += halo(ray, lights[3], distance(ray.origin, hit.position));\n  }\n  \n  color = color / (color + vec3(1.0));\n  color = pow(abs(clamp(color, 0.0, 1.0)), vec3(0.45));\n\n\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI    3.141592653589793\n\n#define SIN_PI3  0.8660254037844386\n#define COS_PI3  0.5\n#define SIN_PI6  COS_PI3\n#define COS_PI6  SIN_PI3\n#define SIN_PI12 0.25881904510252074\n#define COS_PI12 0.9659258262890683\n#define SIN_PI24 0.13052619222005157\n#define COS_PI24 0.9914448613738104\n\n#define PI3     mat2(COS_PI3,  SIN_PI3,  -SIN_PI3,  COS_PI3)\n#define PI6     mat2(COS_PI6,  SIN_PI6,  -SIN_PI6,  COS_PI6)\n#define PI12    mat2(COS_PI12, SIN_PI12, -SIN_PI12, COS_PI12)\n#define PI24    mat2(COS_PI24, SIN_PI24, -SIN_PI24, COS_PI24)\n\n// Structures \nstruct Hit { float id; vec3 normal; vec3 position; float sub; };\nstruct Light { vec3 color; vec3 position; vec3 direction; vec3 attenuation; };\nstruct Material { vec3 albedo; float metallic; float roughness; };\nstruct Ray { vec3 origin; vec3 direction; };\n\n// Transformations\nmat2 rotate(float a) {\n  return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nmat3 lookAt(vec3 origin, vec3 target) {\n  vec3 wu = vec3(0.0, 1.0, 0.0);\n  vec3 f = normalize(origin - target);\n  vec3 r = normalize(cross(wu, f));\n  vec3 u = normalize(cross(f, r));\n  return mat3(r, u, f);\n}\n\n// https://iquilezles.org/articles/sdfrepetition/\nfloat repeatAngle(vec2 p, float n) {\n  float sp = 2.0 * PI / n;\n  float an = atan(p.y, p.x);\n  float id = floor(an / sp);\n  return sp * id;\n}\n\n// SDF\n// https://iquilezles.org/articles/distfunctions/\n\nfloat sdSphere(vec3 p, vec4 v) {\n  return length(p - v.xyz) - v.w;\n}\n\nfloat sdCapsule(vec3 p, vec2 rh) {\n  p.y -= clamp(p.y, 0.0, rh.y);\n  return length(p) - rh.x;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2) {\n  vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);\n  return length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat sdCylinder(in vec3 p, in vec2 size) {\n  vec2 d = vec2(length(p.xz), abs(p.y)) - vec2(size.x, size.y);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdBox(in vec3 p, in vec4 size) {\n  vec3 q = abs(p) - size.xyz;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - size.w;\n}\n\n// Random and noise\n\nfloat random(in vec2 p) {\n  float q = dot(p, vec2(12.9898, 78.233));\n  return fract(sin(q) * 43758.5453123);\n}\n\nfloat noise(in vec2 uv) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n    \n  float a = random(i + vec2(0.0, 0.0));\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n  return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n// https://www.shadertoy.com/view/Mdj3zD\nfloat Noise(in vec3 p, sampler2D noise) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n\tf = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = texture(noise, (uv + 0.5) / 256.0, 0.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nvec2 MIN(vec2 a, vec2 b) {\n  if (a.x < b.x) return a;\n  return b;\n}\n\nfloat smoothMin( float a, float b, float k ) {\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - 0.25 * h * h * k;\n}\n\n// Lighting\n\nfloat getAttenuation(float d, vec3 v) {\n  return 1.0 / dot(vec3(d * d, d, 1.0), v);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float roughness) {\n  float a = pow(roughness, 4.0);\n  float NdotH = max(dot(N, H), 0.0);\n  float denom = (NdotH * NdotH * (a - 1.0) + 1.0);\n  return a / (PI * denom * denom);\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n  float k = 0.125 * (roughness + 1.0) * (roughness + 1.0);\n  return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = geometrySchlickGGX(NdotV, roughness);\n  float ggx1 = geometrySchlickGGX(NdotL, roughness);\n  return ggx1 * ggx2;\n}\n\nfloat koch(vec2 uv, float n) {\n  vec2 pq = -abs(uv);\n  float c = sqrt(3.0);\n  for (float i = 0.0; i < n; i += 1.0) {\n    pq = c * pq.yx * rotate(-PI / 3.0);\n    pq.y = 1.0 * c - abs(pq.y);\n  }\n  vec3 color = vec3(0.0);\n  return -pq.x * step(length(uv), sqrt(3.0) / 2.0);\n}\n\n#define S 12.0\n#define J 5.0\n\n// ID\n\n#define ROOM_WALL_ID     0.0\n#define ROOM_FLOOR_ID    1.0\n#define ROOM_WINDOW_ID   2.0\n#define WINDOW_GLASS_ID  3.0\n#define ROOM_BEAM_ID     4.0\n#define DOORWAY_ID       5.0\n#define DOOR_ID          6.0\n#define DOOR_HANDLE_ID   7.0\n#define LAMP_PILLAR_ID   8.0\n#define BENCH_ID         9.0\n#define SHELF_ID         10.0\n#define PILLAR_ID        11.0\n#define FIREPLACE_ID     12.0\n#define TABLE_ID         13.0\n#define LADDER_ID        14.0\n#define TREE_BRANCH_ID   15.0\n#define TREE_NEEDLE_ID   16.0\n#define CANDLE_ID        17.0\n#define CANDLE_WICK_ID   18.0\n#define BARREL_ID        19.0\n#define HOOP_ID          20.0\n#define BOTTLE_ID        21.0\n#define GIFT_ID          22.0\n#define TREE_BUBBLE_ID   24.0\n#define LAMP_ID          25.0\n#define FIRE_ID          26.0\n#define CANDLE_FLAME_ID  23.0\n\nMaterial materials[22] = Material[22](\n  Material(vec3(0.500, 0.250, 0.180), 0.3, 1.5), // ROOM_WALL_ID\n  Material(vec3(0.968, 0.562, 0.376), 0.2, 1.4), // ROOM_FLOOR_ID\n  Material(vec3(0.500, 0.500, 0.500), 0.2, 1.4), // ROOM_WINDOW_ID\n  Material(vec3(1.000, 1.000, 1.000), 0.5, 0.9), // WINDOW_GLASS_ID\n  Material(vec3(1.000, 1.000, 0.000), 0.5, 0.5), // ROOM_BEAM_ID\n  Material(vec3(0.312, 0.312, 0.312), 0.3, 0.9), // DOORWAY_ID\n  Material(vec3(0.000, 0.000, 0.000), 0.5, 0.5), // DOOR_ID\n  Material(vec3(0.700, 0.700, 0.700), 0.9, 0.2), // DOOR_HANDLE_ID\n  Material(vec3(0.500, 0.500, 0.500), 0.3, 0.9), // LAMP_PILLAR_ID\n  Material(vec3(0.500, 0.500, 0.500), 0.5, 0.5), // BENCH_ID\n  Material(vec3(0.500, 0.250, 0.188), 0.5, 0.8), // SHELF_ID\n  Material(vec3(0.500, 0.500, 0.500), 1.0, 0.9), // PILLAR_ID\n  Material(vec3(0.500, 0.500, 0.500), 1.0, 0.9), // FIREPLACE_ID\n  Material(vec3(0.500, 0.500, 0.500), 1.0, 0.9), // TABLE_ID\n  Material(vec3(0.500, 0.500, 0.500), 1.0, 0.9), // LADDER_ID\n  Material(vec3(0.790, 0.510, 0.066), 1.0, 0.9), // TREE_BRANCH_ID\n  Material(vec3(0.000, 0.220, 0.130), 1.0, 0.4), // TREE_NEEDLE_ID\n  Material(vec3(1.000, 1.000, 0.000), 1.0, 0.5), // CANDLE_ID\n  Material(vec3(0.500, 0.500, 0.500), 1.0, 0.9), // CANDLE_WICK_ID\n  Material(vec3(0.500, 0.500, 0.500), 1.0, 0.9), // BARREL_ID\n  Material(vec3(0.500, 0.500, 0.500), 3.0, 0.4), // HOOP_ID\n  Material(vec3(0.200, 0.400, 1.000), 2.0, 0.2)  // BOTTLE_ID\n);\n\nbool isBox(float id) {\n  return (id == ROOM_BEAM_ID)  || (id == ROOM_WINDOW_ID) || \n         (id == DOORWAY_ID)    || (id == DOOR_ID)        || \n         (id == SHELF_ID)      || (id == BENCH_ID)       ||\n         (id == ROOM_FLOOR_ID) || (id == TABLE_ID)       ||\n         (id == FIREPLACE_ID)  || (id == GIFT_ID)        ||\n         (id == BARREL_ID);\n}\n\n// Position and Size\n#define ROOM_SIZE          vec3(8.0, 8.0, 8.0) // xz - half size\n#define LOG_R              0.5\n#define BOARD_YSIZE        0.5\n#define BEAM_YSIZE         0.1\n\n#define WINDOW_YPOSITION   ROOM_SIZE.y / 2.0\n#define WINDOW_POSITION    vec3(0.0, WINDOW_YPOSITION, -ROOM_SIZE.z - LOG_R)\n#define WINDOW_OSIZE       vec4(2.0, 1.5, 0.5, 0.1)\n#define WINDOW_ISIZE       vec4(1.8, 1.3, 0.4, 0.1)\n#define GLASS_SIZE         vec4(1.8, 1.3, 0.2, 0.0)\n\n#define SHELF_SIZE         vec3(2.0, 3.0, 0.5)\n#define SHELF_POSITION     vec3(ROOM_SIZE.x - SHELF_SIZE.z - 0.5, SHELF_SIZE.y, -ROOM_SIZE.z + SHELF_SIZE.x + 0.5)\n\n#define SHELF2_SIZE        vec3(1.5, 3.0, 1.0)\n#define SHELF2_POSITION    vec3(0.0, SHELF2_SIZE.y, ROOM_SIZE.z - SHELF2_SIZE.z - 0.5)\n     \n#define DOORWAY_POSITION   vec3(ROOM_SIZE.x + LOG_R, 3.0, 1.0)\n#define TREE_POSITION      vec3(-6.0, 0.0, 1.0)\n\n// Texture\n\nvec3 getTexture(sampler2D s, vec3 p, vec3 n) {\n  return texture(s, p.xy).xyz * abs(n.z) +\n         texture(s, p.xz).xyz * abs(n.y) +\n         texture(s, p.zy).xyz * abs(n.x); \n}","name":"Common","description":"","type":"common"}]}