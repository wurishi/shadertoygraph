{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Chocolate Creation 2014\n\n// Based on Dave Hoskins awesome Rendezvous shader: https://www.shadertoy.com/view/ldjGDw\n\n// Mouse y blends in fractal iterations\n\n// Fractal surface dilated in distance as an AA test. The goal is to eliminate\n// thin slithers that fall between pixels, which is a type of aliasing that rasterization\n// is prone to.\n\n// If this had edge AA (such as MSAA), the result might be nice like eiffie et al's soft distance\n// fields.\n\n// However there is no edge AA, nor is the surface shading AA'd, hence aliasing is still\n// visible, and I'm not going to bother to derive the equations to dilate the surfaces\n// by exactly the pixel width.\n\n#define CSize  vec3(.808, .8, 1.137)\n\n#define MOUSEX (iMouse.x/iResolution.x)\n#define MOUSEY (iMouse.y/iResolution.y)\n\n#define DILATE_IN_DIST\n\n//----------------------------------------------------------------------------------------\nfloat Map( vec3 p, float dist )\n{\n\tfloat scale = 1.0;\n\n\tfloat mousey = iMouse.z > 0. ? MOUSEY : 1.;\n\tfloat itercnt =1. + 9. * mousey; //+ iTime/3.;// 7. * iMouse.x / iResolution.x;\n\tfor( float i=0.; i < 9.;i+=1. )\n\t{\n\t\tvec3 newP = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat blend = clamp(itercnt-i, 0., 1.);\n\t\tp = (1.-blend) * p + blend * newP;\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = max(1.1/r2, 1.);\n\t\tp     = (1.-blend) * p + blend * k * p;\n\t\tscale = (1.-blend) * scale + blend * k * scale;\n\t\t//scale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 4.0;\n\tfloat n = l * p.z;\n\t//rxy = max(rxy, -n / length(p));\n\trxy = -n / (length(p) + .5*.0 + 0.*9.5*MOUSEY + 4.*log(1.+.6*dist));\n\t//rxy = max(rxy, -(n) / (length(p))-.07+sin(iTime*2.0+23.5*p.z)*.02);\n\treturn (rxy) / abs(scale);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Colour( vec3 p )\n{\n\treturn 1.6*vec3(0.07,0.01,0.005);\n}\n\n//----------------------------------------------------------------------------------------\nfloat RayMarch( in vec3 ro, in vec3 rd )\n{\n\tfloat precis = 0.0005;\n    float h\t\t = precis*.2;\n    float t\t\t = 0.01;\n\tfloat res\t = 2000.0;\n\tbool hit\t = false;\n\n    for( int i=0; i< 150; i++ )\n    {\n\t\tif (!hit && t < 8.0)\n\t\t{\n\t\t\th = Map(ro + rd * t, t);\n\t\t\tt += h * .8;\n\t\t\tif (h < precis)\n\t\t\t{\n\t\t\t\tres = t;\n\t\t\t\thit = true;;\n\t\t\t}\n            \n            #ifdef DILATE_IN_DIST\n\t\t\tprecis *= 1.03;\n            #endif\n\t\t}\n    }\n\t\n    return res;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd, float dist)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n\tfloat h = 0.0;\n    \n\tfor (int i = 0; i < 12; i++)\n\t{\n\t\tif(t < dist)\n\t\t{\n\t\t\th = Map(ro + rd * t, dist);\n\t\t\tres = min(4.0*h / t, res);\n\t\t\tt += h + 0.002;\n\t\t}\n\t}\n\t\n    return clamp(res, 0.0, 1.0);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos, in float dist )\n{\n\tvec3  eps = vec3(0.0002,0.0,0.0);\n\tvec3 nor = vec3(Map(pos+eps.xyy, dist) - Map(pos-eps.xyy, dist),\n\t\t\t\t\tMap(pos+eps.yxy, dist) - Map(pos-eps.yxy, dist),\n\t\t\t\t\tMap(pos+eps.yyx, dist) - Map(pos-eps.yyx, dist));\n\treturn normalize(nor);\n}\n\nfloat LightGlow(vec3 light, vec3 ray, float t)\n{\n\tfloat ret = 0.0;\n\tif (length(light) < t)\n\t{\n\t\tlight = normalize(light);\n\t\tret = pow(max(dot(light, ray), 0.0), 3000.0)*1.5;\n\t}\n\t\t\n\treturn ret;\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tfloat time = sin(-3.14159 + 1.6+iTime*.05 /*+ iMouse.x*.005*/)*9.5;\n    // camera\n\tvec3 origin = vec3( 1.075, 0.05*time-3.65, 2.52);\n\tvec3 target = vec3(.0, 0.0, 2.5);\n\t\n\tvec3 cw = normalize( target-origin);\n\tvec3 cp = normalize(vec3(0.0, 0.0, 1.));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = cross(cu,cw);\n\tvec3 ray = normalize( p.x*cu + p.y*cv + 2.6*cw );\t\n\t\n\tvec3 lightPos = origin+vec3(-0.56-cos(time*2.0+1.3)*.3, -1.5, .25+cos(time*2.0)*.3);\n\tfloat intensity = .8+.075*sin(time*200.0);\n\n    // trace\t\n\tvec3 col = vec3(0.0);\n\tfloat t = RayMarch(origin, ray);\n\tif(t < 2000.0)\n\t{\n\t\tvec3 pos = origin + t * ray;\n\t\tvec3 nor = Normal(pos, t);\n\n\t\tvec3  light1 = lightPos-pos;\n\t\tfloat lightDist = length(light1);\n\t\tvec3  lightDir = normalize(light1);\n\t\t\t\t\n\t\tfloat key = clamp( dot( lightDir, nor ), 0.0, 1.0 ) * intensity;\n\t\tfloat spe = max(dot(reflect(ray, nor), lightDir), 0.0);\n\t\tfloat amb = max(nor.z*.1, 0.0);\n\t\tfloat ao = clamp(Shadow(pos+nor*0.005, lightDir, lightDist) / max(lightDist-2.0, 0.1), 0.0, 1.0);\n\n\t\tvec3 brdf  = amb + vec3(1.0)* key * ao;\n\n\t\tcol =  Colour(pos) * brdf + .1*pow(spe, 6.0)*ao*.4;\n\t\tcol *= exp(-0.5*max(t-1.0, 0.0));\n\t}\n\t\n\t// Effects...\n\tcol += LightGlow(lightPos-origin, ray, t) * intensity;\n\tcol = clamp(col, 0.0, 1.0);\n\t//col *= smoothstep(.0, .25, col);\n\tcol = pow(col, vec3(.45))*1.2;\n\tcol *= pow(50.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25);\n\t\n\tfragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2GWm","date":"1389827360","viewed":510,"name":"Chocolate Creation","username":"huwb","description":"Hacking around with Dave Hoskins' Rendezvous shader: https://www.shadertoy.com/view/ldjGDw . All of the hard work was done by him!\n\nChanges:\n\n* Blending in iterations of the kleinan fractal (mouse y).\n* AA experiment (see comments)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}