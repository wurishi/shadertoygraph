{"ver":"0.1","info":{"id":"4t23Ww","date":"1429541476","viewed":954,"name":"Hartverdrahtet","username":"remonvv","description":"Quick port of hartverdrahtet shader from 4k intro. Skips intro. To be perfectly clear, this is a complete port of the original intro and in no way, shape or form my own work. See comment for details. Slow due to enabled AA. Disable at line 274","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","port","hartverdrahtet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/**\n **   __ __|_  ___________________________________________________________________________  ___|__ __\n **  //    /\\                                           _                                  /\\    \\\\  \n ** //____/  \\__     __ _____ _____ _____ _____ _____  | |     __ _____ _____ __        __/  \\____\\\\ \n **  \\    \\  / /  __|  |     |   __|  _  |     |  _  | | |  __|  |     |   __|  |      /\\ \\  /    /  \n **   \\____\\/_/  |  |  |  |  |  |  |     | | | |   __| | | |  |  |  |  |  |  |  |__   \"  \\_\\/____/   \n **  /\\    \\     |_____|_____|_____|__|__|_|_|_|__|    | | |_____|_____|_____|_____|  _  /    /\\     \n ** /  \\____\\                       http://jogamp.org  |_|                              /____/  \\    \n ** \\  /   \"' _________________________________________________________________________ `\"   \\  /    \n **  \\/____.                                                                             .____\\/     \n **\n ** JOGL2 port of my PC 4k intro competition entry for Revision 2012. This is the raymarching fragment\n ** shader that is rendered to a fullscreen billboard. The shader basically encapsulates a \n ** sphere-tracing based raymarcher for a single fractal formula with camera handling. The different \n ** intro parts are all parameter and camera position variations of the same fractal.\n **\n ** This is the 'normal', unminified version I used during development.\n **\n ** Papers and articles you should be familiar with before trying to understand the code:\n **\n ** Distance rendering for fractals: https://iquilezles.org/articles/distancefractals\n ** Ambient occlusion techniques: https://iquilezles.org/articles/ao/ao.htm\n ** Sphere tracing: A geometric method for the antialiased ray tracing of implicit surfaces: http://graphics.cs.uiuc.edu/~jch/papers/zeno.pdf\n ** Rendering fractals with distance estimation function: https://iquilezles.org/articles/mandelbulb\n **\n ** For an impression how this routine looks like see here: http://www.youtube.com/watch?v=UjgRGDhgehA\n ** Original release from the Revision 2012 can be found here: http://www.pouet.net/prod.php?which=59086\n **/\n\n//base\n//uniform vec2 rs;  //resolution\n\n//scene timing\nint sn = 1;   //scene number\n\nfloat lt = 23.0; //previous/last scene time\n\n//camera\nvec3  cp; //camera position\nmat3  cr; //camera rotation\n\n//coloring\nfloat ff; //fog falloff\n\n//ifs\nfloat fu; //fractal_spheresubstract\nfloat fd; //fractal_distancemult\nvec3 cs;  //fractal_csize\nfloat fs; //fractal_size\nvec3 fc;  //fractal_c\n\nfloat dE(vec3 p) {\n   float dEfactor=1.;\n   //int fractal_iterations = 12;\n   for(int i=0;i<12;i++){\n      //box folding\n      p=2.*clamp(p, -cs, cs)-p;\n      //inversion\n      float k=max(fs/dot(p,p),1.);\n      p*=k;\n      dEfactor*=k;\n      //julia seed\n      p+=fc;\n   }\n   //call basic shape and scale its DE\n   //need to adjust fractal_distancemult with non zero julia seed\n   float rxy=length(p.xy)-fu;\n   //distance from pos to the pseudo kleinian basic shape ...\n   return (fd*max(rxy,abs(length(p.xy)*p.z)/sqrt(dot(p,p)))/abs(dEfactor));\n}\n\nvec4 rd(vec2 fragment_coordinates) {   \n   //calculate ray direction from fragment coordinates ...\n   vec2 ray_position = (0.5*iResolution.xy-fragment_coordinates)/vec2(iResolution.x,iResolution.y);   \n   ray_position.x *= (iResolution.x/iResolution.y); //aspect_ratio\n   vec3 ray_direction = normalize(cr * vec3(ray_position.x * vec3(1, 0, 0) + ray_position.y * vec3(0, 1, 0) - .9 * vec3(0, 0, 1)));\n   //sphere tracing initialization ...\n   float ray_length = 0.0;\n   vec3  ray = cp+ray_length*ray_direction;\n   float epsilon = 0.0000006;\n   float  calculated_distance;\n   int   tracingsteps = 0;\n   bool  hit = false;\n   ray = cp+ray_length*ray_direction;\n   //magic :) DO NOT TOUCH!\n   float eps_factor = 2.0*.294*(1.0/iResolution.y)*.6;\n   //actual sphere tracing ...\n   //#define tracingsteps_max 200\n   for (int i=0; i<100; i++) {\n      tracingsteps = i;\n      calculated_distance = dE(ray);     \n      //small stepback to remove 'fuzzel'-structures near inside shooting range\n      //#define raylength_max 10000.0\n       if (hit && calculated_distance<epsilon || ray_length>1000.0){\n         tracingsteps--;\n         break;\n      }\n      hit = false;\n      ray_length += calculated_distance;\n      ray = cp+ray_length*ray_direction;\n      epsilon = ray_length * eps_factor;\n      if (calculated_distance<epsilon) {\n         hit = true;\n      }\n   }\n   //---   \n   //intersects ?\n   //#define tracingsteps_max 200\n   float glow_amount = float(tracingsteps)/float(200);\n   vec4 color_primary = vec4(1.0,1.0,1.0,0.45);             //alpha-channel represents intensity\n   vec4 color_background_primary = vec4(1.0,1.0,0.0,1.0);\n   vec4 color_background_secondary = vec4(0.0,0.0,0.0,1.0);\n   vec4 color_glow_inside = vec4(0.0,1.0,1.0,0.55);         //alpha-channel represents intensity \n   float aof = 1.0;\n   //asin(1.0)=pi/2\n   vec4  bg_color = vec4(clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(ray_direction.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0), 1.0);\n   vec4 color = color_primary;\n   if (hit) {\n      float glow = clamp(glow_amount * color_glow_inside.a * 3.0, 0.0, 1.0);\n      //---      \n      //calculate_normal: gradient calculation in x,y and z from intersection position\n      //#define normal_min 1.5e-7\n      float epsilon_normal = max(epsilon*0.5,1.5e-7);\n      vec3 normal = normalize(vec3(\n         dE(ray+vec3(epsilon_normal, 0, 0))-dE(ray-vec3(epsilon_normal, 0, 0)),\n         dE(ray+vec3(0, epsilon_normal, 0))-dE(ray-vec3(0, epsilon_normal, 0)),\n         dE(ray+vec3(0, 0, epsilon_normal))-dE(ray-vec3(0, 0, epsilon_normal)))\n      );\n      //---\n      //AO approximation: https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n      float occlusion_factor = 1.0;\n      //float ambientocclusion_spread = 9.00000;\n      //float ambientocclusion_intensity = 0.15000;   \n      //float surface_offset = epsilon;\n      //surface_offset *= 9.;\n      float surface_offset = epsilon*9.;\n      float ao_contribution = .15/surface_offset;\n      //start with small offset from surface ...\n      float surface_distance = 2.0*surface_offset;\n      //#define ambientocclusion_iterations 4\n      for (int i=0; i<8; ++i) {\n         occlusion_factor -= (surface_distance-dE(ray+normal*surface_distance))*ao_contribution;\n         surface_distance += surface_offset;\n         //contribution lowers with distance to surface\n         ao_contribution *= 0.5; \n      }\n      aof = clamp(occlusion_factor, 0.0, 1.0);\n      //--- \n      //blinn phong shading model\n      //base color, incident, point of intersection, normal\n      //ambient colour based on background gradient\n      //asin(1.0)=pi/2  \n      vec3 ambColor = clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(normal.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0);\n      ambColor = mix(vec3(.5), ambColor, .3);\n      //vec3 light_position = vec3(-16.00000,100.00000,-60.00000);\n      float diffuse = max(dot(normal, normalize(vec3(-16.,100.,-60.)-ray)), 0.0);       \n      //vec3 clamped_ambientcolor = clamp(color.rgb * color_primary.a, 0.0, 1.0);\n      vec3 clamped_ambientcolor = color.rgb * color_primary.a;\n      //float light_specular = 0.80000;\n      //float light_specular_exponent = 4.00000;\n      //float temp_specular = pow(diffuse, 4.);\n      color.rgb = (ambColor * clamped_ambientcolor + clamped_ambientcolor * diffuse + pow(diffuse, 4.) * .8)*aof;\n      color.rgb = mix(color.rgb, color_glow_inside.rgb, glow);\n    } else {\n        //Zzzzz ... no intersection ...\n    } \n    //float color_fog_intensity = 0.01;   \n    color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(ray_length * exp(ff), 2.0) * .01));\n    return vec4(color.rgb,1.0);\n}\n\n//return rotation matrix for rotating around vector v by angle\nmat3 mr(vec3 v, float angle) {\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n    return mat3(c+(1.0-c)*v.x*v.x   , (1.0-c)*v.x*v.y-s*v.z  , (1.0-c)*v.x*v.z+s*v.y,\n               (1.0-c)*v.x*v.y+s*v.z, c+(1.0-c)*v.y*v.y      , (1.0-c)*v.y*v.z-s*v.x,\n               (1.0-c)*v.x*v.z-s*v.y, (1.0 - c)*v.y*v.z+s*v.x, c+(1.0-c)*v.z*v.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //camera\n    float camera_roll = 0.;\n    float camera_pitch = 90.;\n    float camera_yaw = 0.;\n    fd = 0.763;\n    fu = 10.0;\n    fs = 1.0;\n    fc = vec3(0);\n    ff = -0.50000;\n    cs = vec3(0.80800,0.80800,1.16700);\n    float gamma_correction = 1.00000;    \n    //float temp_scenetimer = clamp(current_scene_timer,0.0,100.0);\n    float temp_scenetimer = iTime;\n    int temp_scene_number = int(iTime / 10.0) + 1;\n    vec2 custom_glFragCoord = fragCoord.xy;    \n    float noise = 1.0;//fract(sin(dot(custom_glFragCoord.xy ,vec2(12.9898,78.233))) * 43758.5453+(temp_scenetimer*0.25))*(sin(temp_scenetimer+custom_glFragCoord.y)*2.0+4.0); \n    if (temp_scene_number>=1) {\n       if (noise>temp_scenetimer) {\n          temp_scenetimer = 0.0;\n          temp_scene_number = temp_scene_number-1;\n       }\n    }  \n    //#define scene_fadein 0 \n    if (temp_scene_number==0) {\n       gamma_correction = clamp(temp_scenetimer*0.055,0.0,1.0);\n       camera_pitch = 23.9;\n       cp = vec3(0.8,-1.16339+16.0-temp_scenetimer*0.095,-1.80153);\n       cs.y = 0.58000;\n    }\n    //#define scene_wires_sidescroller 1\n    if (temp_scene_number==1) {\n       cp = vec3(0.23212+temp_scenetimer*0.00068,0.10000,-2.35000);\n       cs.xy = vec2(0.50000);\n    }\n    //#define scene_wires_insidescroller 2\n    if (temp_scene_number==2) {\n       cp = vec3(0.7+(-0.0092+temp_scenetimer*0.000180),0.1,-2.3495);\n       cs.xy = vec2(0.50000);\n    }\n    //#define scene_grid_hallofharad 3\n    if (temp_scene_number==3) {\n       fu = 1.01000;\n       cp = vec3(temp_scenetimer*0.05,0.02000,2.00000-100.0*0.1);\n       cs.x = 0.90000;\n    }\n    //#define scene_grid_sideoverview 4\n    if (temp_scene_number==4) {\n       fu = 1.01000;\n       cp = vec3(0.0008,0.02000,0.10000-temp_scenetimer*0.00028);\n       camera_pitch = 0.0;\n       camera_yaw = temp_scenetimer*0.009*180.0;\n       cs.x = 0.90000;\n    }\n    //#define scene_spike_verticalcore 5    \n    if (temp_scene_number==5) {\n       fu = 2.0;\n       cp = vec3(0.0+temp_scenetimer*0.00025,1.40000+0.004,-2.38200+(-0.05+temp_scenetimer*0.002));\n    }\n    //#define scene_spike_introduction 6  \n    if (temp_scene_number==6) {  \n       cp = vec3(1.18000,0.08000+temp_scenetimer*0.000055,-0.24000);\n       camera_pitch = 120.0;\n       cs = vec3(0.50000,0.50000,1.04000);\n    }\n    //#define scene_spike_wiredballsvertical 7   \n    if (temp_scene_number==7) {\n       fd = 0.70000;\n       fs = 1.34000;\n       cp = vec3(0.69+(-0.0092+temp_scenetimer*0.0008),0.1,-2.3495);\n       camera_pitch = 130.0+sin(temp_scenetimer*0.075)*50.0;\n       camera_roll = 90.0;\n       cs.xy = vec2(0.50000);\n    }\n    //#define scene_alien_backbone 8\n    if (temp_scene_number==8) {\n       cp = vec3(0.0,-0.86000+temp_scenetimer*0.0003,0.30000);\n       camera_pitch = 80.0+(temp_scenetimer*0.65);     \n       fc.z = -0.38000;\n    }    \n    float brightness = 0.0;\n    //#define scene_alien_reactorcore 9\n    if (temp_scene_number==9) {\n       gamma_correction = clamp(temp_scenetimer*0.025,1.0,100.0);\n       fu = 1.20000;\n       cp = vec3(0.00,1.40000+(-0.020+temp_scenetimer*0.0018),-2.34100);\n       fc.z = 0.25840;\n       ff =  clamp(temp_scenetimer*0.05,3.6,100.0);\n       brightness = clamp((temp_scenetimer-35.0)*0.005,0.0,1.0);       \n    }\n    cr = mr(vec3(0, 1, 0), 180.0 - camera_yaw) * mr(vec3(1, 0, 0), -camera_pitch) * mr(vec3(0, 0, 1), camera_roll);    \n    //super sampling support\n    vec4 color = vec4(0.0);\n#define antialiasing 0.5       \n#ifdef antialiasing\n    float n = 0.0;\n    for (float x = 0.0; x < 1.0; x += float(antialiasing)) {\n        for (float y = 0.0; y < 1.0; y += float(antialiasing)) {\n            color += rd(custom_glFragCoord.xy + vec2(x, y));\n            n += 1.0;\n        }\n    }\n    color /= n;\n#else\n    color = rd(custom_glFragCoord.xy);\n#endif    \n    //output\n    fragColor = vec4(pow(color.rgb+brightness, vec3(1.0 / gamma_correction)), color.a);\n} ","name":"Image","description":"","type":"image"}]}