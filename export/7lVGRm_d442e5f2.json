{"ver":"0.1","info":{"id":"7lVGRm","date":"1675459507","viewed":96,"name":"Noise3D+raymarch","username":"SteelFlame","description":"0","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["0"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightDir = vec3(0.,1.5,0.8);\nconst float normalDelta = 0.00001;\nconst float maxMarchDst = 0.3;\n\nfloat defaultNoise(vec3 pos) {\n    return (pow(fbm(pos,.7,30.,1,.7),1.)*.5+.5);//exp2(-pow((pos.y-0.5)*.5,2.))\n    //return (voronoiFbm(pos,0.8,1.3,1,1.));\n}\n\nvec2 volumetricMarch(vec3 origin, vec3 direction, float maxStepsCount, float lightStepsCount) {\n    float v = 0.;\n    float fullLightLevel = 1.;\n    for (float i = 0.; i < maxStepsCount; i+=1.) {\n        vec3 pos = origin + direction * i;\n        float c = defaultNoise(pos)/pow(i+1.,0.5);\n        float lightLevel = c;\n        for (float j = 1.; j < lightStepsCount; j++) {\n            lightLevel += pow(defaultNoise(pos + -lightDir*j),1.);\n        }\n        v += c;\n        fullLightLevel += lightLevel;\n    }\n    return vec2(v/maxStepsCount,exp2(-fullLightLevel*0.08));\n}\nvec3 march(vec3 origin, vec3 direction, float pathToPass) {\n    const float maxDst = 0.3;\n\n    float passedPath = 0.;\n    vec3 pos = origin;\n    float l = 1.;\n    while (passedPath < pathToPass) {\n        l = defaultNoise(pos);\n        pos += direction*l;\n        if (l < maxDst) {\n            break;\n        }\n        passedPath++;\n    }\n    float sfbm = defaultNoise(pos);\n    vec3 normal = vec3(defaultNoise(pos+vec3(normalDelta,0.,0.))-sfbm,defaultNoise(pos+vec3(0.,normalDelta,0.))-sfbm,defaultNoise(pos+vec3(0.,0.,normalDelta))-sfbm);\n    if (l < maxDst)\n        return vec3(1.,passedPath/pathToPass,passedPath/pathToPass) * dot(normalize(lightDir),normalize(normal));\n    return vec3(passedPath,passedPath,passedPath)/pathToPass;\n}\n\nvec3 camPos = vec3(0.,0.,0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseUv = iMouse.xy/iResolution.xy;\n    vec3 viewDir = normalize(vec3((-1.+uv.x*2.),(-1.+uv.y*2.),.8));\n    \n    camPos = vec3(mouseUv.x+1.,mouseUv.y+1.,0.)/2.*15.;\n    //camPos.x += cos(iTime*4.)*.3;\n    //camPos.z += sin(iTime*4.)*.3;\n    \n    //vec3 col = march(vec3(mouseUv.x+1.,mouseUv.y+1.,0.)/2.*15.,viewDir,20.);\n    vec2 m = volumetricMarch(camPos, viewDir, 8., 5.);\n    vec3 col = mix(mix(vec3(0.,0.6,1.),vec3(.47,.79,1.),uv.y),vec3(1.,1.,1.),m.x)*m.y;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float smoothh(float x) {\n    return x*x*x*(x*(x*6.0-15.0)+10.0);\n    return -2.0*x*x*x+3.0*x*x;\n}\nfloat lerp1d(float a, float b, float t) {\n    return a+(b-a)*t;\n}\nvec2 lerp(vec2 a, vec2 b, float t) {\n    return a+(b-a)*t;\n}\nfloat clamp01(float x) {\n    if (x>1.0) return 1.0;\n    if (x<0.0) return 0.0;\n    return x;\n}\nfloat frac(float x) {\n    return x-floor(x);\n}\nfloat random(vec3 uv) {\n    return frac(sin(dot(uv,vec3(12.9898,78.233,153.8465)))*43758.5453123);\n}\nvec3 getVector(vec3 x) {\n    return normalize(vec3(-1.0+random(x)*2.0, -1.0+random(x*100.0)*2.0, -1.0+random(x*100.0*100.0)*2.0));\n    \n}\nfloat noise(vec3 x) {\n    vec3 xInEdge = floor(x);\n    vec3 localX = vec3(frac(x.x),frac(x.y),frac(x.z));\n    \n    vec3 side000 = vec3(xInEdge+vec3(0,0,0));\n    vec3 side001 = vec3(xInEdge+vec3(0,0,1));\n    vec3 side010 = vec3(xInEdge+vec3(0,1,0));\n    vec3 side011 = vec3(xInEdge+vec3(0,1,1));\n    vec3 side100 = vec3(xInEdge+vec3(1,0,0));\n    vec3 side101 = vec3(xInEdge+vec3(1,0,1));\n    vec3 side110 = vec3(xInEdge+vec3(1,1,0));\n    vec3 side111 = vec3(xInEdge+vec3(1,1,1));\n    \n    vec3 vector000 = getVector(side000);\n    vec3 vector001 = getVector(side001);\n    vec3 vector010 = getVector(side010);\n    vec3 vector011 = getVector(side011);\n    vec3 vector100 = getVector(side100);\n    vec3 vector101 = getVector(side101);\n    vec3 vector110 = getVector(side110);\n    vec3 vector111 = getVector(side111);\n    \n    vec3 dir000 = x-side000;\n    vec3 dir001 = x-side001;\n    vec3 dir010 = x-side010;\n    vec3 dir011 = x-side011;\n    vec3 dir100 = x-side100;\n    vec3 dir101 = x-side101;\n    vec3 dir110 = x-side110;\n    vec3 dir111 = x-side111;\n    \n    float dot000 = dot(dir000,vector000);\n    float dot001 = dot(dir001,vector001);\n    float dot010 = dot(dir010,vector010);\n    float dot011 = dot(dir011,vector011);\n    float dot100 = dot(dir100,vector100);\n    float dot101 = dot(dir101,vector101);\n    float dot110 = dot(dir110,vector110);\n    float dot111 = dot(dir111,vector111);\n    \n    localX.x = smoothh(localX.x);\n    localX.y = smoothh(localX.y);\n    localX.z = smoothh(localX.z);\n    \n    float lerp1 = lerp1d(lerp1d(dot000,dot001,localX.z),lerp1d(dot010,dot011,localX.z),localX.y);\n    float lerp2 = lerp1d(lerp1d(dot100,dot101,localX.z),lerp1d(dot110,dot111,localX.z),localX.y);\n    \n    return lerp1d(lerp1,lerp2,localX.x);\n}\nfloat voronoi(vec3 uv) {\n    vec3 flooredUv = floor(uv);\n    vec3 localUv = uv - flooredUv;\n    \n    float y = 1.0;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            for (int k = -1; k <= 1; k++) {\n                vec3 grid = vec3(j,i,k);\n                vec3 r = (grid+vec3(random(flooredUv+grid), random(flooredUv*1000.+grid*1000.), random(flooredUv*1000.*1000.+grid*1000.*1000.)))-localUv;\n\n                y = min(y,(length(r)*length(r)));\n            }\n        }\n    }\n    \n    return sqrt(y);\n}\n\nfloat fbm(vec3 uv, float startFrequency, float startIntensity, int octavesCount, float persistance) {\n    float freq = startFrequency;\n    float intens = startIntensity;\n    float v = 0.;\n    for (int i = 0; i < octavesCount; i++) {\n        v += noise(uv*freq)*intens;\n        freq *= 2.;\n        intens *= persistance;\n    }\n    return v/float(octavesCount);\n}\nfloat voronoiFbm(vec3 uv, float startFrequency, float startIntensity, int octavesCount, float persistance) {\n    float freq = startFrequency;\n    float intens = startIntensity;\n    float v = 0.;\n    for (int i = 0; i < octavesCount; i++) {\n        v += voronoi(uv*freq)*intens;\n        freq *= 2.;\n        intens *= persistance;\n    }\n    return v/float(octavesCount);\n}","name":"Common","description":"","type":"common"}]}