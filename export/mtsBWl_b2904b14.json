{"ver":"0.1","info":{"id":"mtsBWl","date":"1693631118","viewed":34,"name":"00Graphics bug pc","username":"mariano_dm","description":"in pc looks black","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","interview"],"hasliked":0,"parentid":"mlsBWB","parentname":"00GraphicsClassLesson04"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Things to have a student do:\n// * MAKE IT PRETTY! I'm color blind, so you're going to have to fix the colors yourself!!!\n// * Explain why the ground plane has blinking band in the distance. Why does it bend\n//   near the object? How might it be reduced? How might it be elimininated (almost)\n//   entirely with minimal computational cost?\n// * Write a function that can be used to recenter any object to <0.5, 0.5, 0.5>\n//   * Use this function to get rid of the hard-coded offset in map_ground_plane\n//   * Instance the recentered object. (In-person only.)\n// * Make the object reflective. GLSL has a reflect() function.\n// * How would you support lots of unrelated objects, each with their own shading \n//   functions? What are the advantages/drawbacks of doing a trace of the whole world\n//   in one loop, versus having one loop for each compound object?\n// * Multiple light sources? If you put several light sources close enough together,\n//   it can look like you have \"soft\" shadows.\n\nconst float PI = 3.141592657;\n\nfloat map_composite_object( in vec3 p) {\n    //p = mod(p, 10.0) - 5.0;\n    if(true) {\n        float dist = sdf_sphere(p - vec3(1.0,0.0,0.0), 1.5);\n        //return hard_intersection(dist, sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5));\n        //return hard_subtraction(sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5), dist);\n        return smooth_union(\n            dist, \n            sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5),\n            0.1);\n    }\n\n    if(false) {\n        mat4 rot_x = rotation_x(p.x);\n        p.xyz = (vec4(p, 1.0) * rot_x).xyz;\n        vec2 torus_radii = vec2(1.5, 0.12);\n        float dist = sdTorus(p, torus_radii);\n        return dist;\n    }\n\n    if(true) {\n        vec2 torus_radii = vec2(1.5, 0.12);\n        float dist = sdTorus(p, torus_radii);\n        mat4 rot_x = rotation_x(PI/5.0); // IT IS DANGEROUS TO REPEATEDLY ALTER FLOATS....\n        for(float rad=PI/5.0; rad<PI; rad += PI/5.0) {\n            p.xyz = (vec4(p, 1.0) * rot_x).xyz;\n            dist = smooth_union(dist, sdTorus(p, torus_radii), 0.1);\n        }\n        return dist;   \n    }\n    \n    if(false) {\n        float dist;\n        float dn;\n        float sphere_r;\n        vec3 sphere_pos;\n        sphere_pos = vec3(sin(iTime), cos(iTime*1.2), .7*sin(iTime*0.6));\n        sphere_r = 0.5 + 0.3*sin(iTime*9.0);\n        dist = sdf_sphere(p-sphere_pos, sphere_r);\n        \n        sphere_pos = vec3(-0.5*sin(2.7*iTime), 1.2*cos(iTime*0.5), .2*sin(iTime*1.3));\n        sphere_r = 0.6 + 0.2*sin(iTime*3.6);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.57*sin(1.3*iTime), 0.74*cos(iTime*7.5), .475*sin(iTime*6.3));\n        sphere_r = 0.49 + 0.355*sin(iTime*6.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.75*sin(3.14*iTime), 1.77*cos(iTime*5.29), .392*sin(iTime*3.98));\n        sphere_r = 0.73 + 0.297*sin(iTime*5.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.23*sin(1.19*iTime), 0.53*cos(iTime*0.92), .297*sin(iTime*0.95));\n        sphere_r = 0.35 + 0.297*sin(iTime*0.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        return dist;\n    }\n    \n    if(false) {\n        return smooth_subtraction(\n            sdf_rounded_box(p, vec3(1.0), 0.425),\n            sdf_sphere(p, 1.74),\n            0.2);\n    }\n    if(false) {\n        float dist = hard_intersection(\n            hard_subtraction(\n                sdf_rounded_box(p, vec3(1.0), 0.425),\n                sdf_sphere(p, 1.74)),\n            sdf_sphere(p, 1.9));\n        vec3 dx = vec3(1.0, 0.0, 0.0);\n        vec3 dy = vec3(0.0, 1.0, 0.0);\n        vec3 dz = vec3(0.0, 0.0, 1.0);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy - dz, 0.3), 0.1);\n        return dist;\n    } \n    if(true) {\n        float mod_time = mod(iTime, 22.0);\n        float dist = sdf_rounded_box(p, vec3(1.0), 0.425);\n        if(mod_time < 2.0) return dist;\n        dist = hard_subtraction(dist, sdf_sphere(p, 1.74));\n        if(mod_time < 4.0) return dist;\n        dist = hard_intersection(dist, sdf_sphere(p, 1.9));\n\n        vec3 dx = vec3(1.0, 0.0, 0.0);\n        vec3 dy = vec3(0.0, 1.0, 0.0);\n        vec3 dz = vec3(0.0, 0.0, 1.0);\n        if(mod_time < 6.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy + dz, 0.3), 0.1);\n        if(mod_time < 8.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy - dz, 0.3), 0.1);\n        if(mod_time < 10.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy + dz, 0.3), 0.1);\n        if(mod_time < 12.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy - dz, 0.3), 0.1);\n        if(mod_time < 14.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy + dz, 0.3), 0.1);\n        if(mod_time < 16.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy - dz, 0.3), 0.1);\n        if(mod_time < 18.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy + dz, 0.3), 0.1);\n        if(mod_time < 20.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy - dz, 0.3), 0.1);\n\n        return dist;\n    }\n}\n\nfloat map_ground_plane( in vec3 p) {\n    return p.y + 2.0;\n}\n\nvec3 calc_normal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    vec3 normal = normalize( \n        vec3(map_composite_object(p+h.xyy) - map_composite_object(p-h.xyy),\n             map_composite_object(p+h.yxy) - map_composite_object(p-h.yxy),\n             map_composite_object(p+h.yyx) - map_composite_object(p-h.yyx) ) );\n    return normal;\n}\n\n// Nothing says the light_col is limited to values <= 1.0!!!\nvec3 light_col = vec3(0.6, 0.3, 0.9);\nvec3 light_pos = vec3(2.0, 5.0, 2.0);\nfloat light_size = 1.0;\n\nbool is_shadowed(in vec3 p, in vec3 normal, in vec3 light_pos) {\n    float distance_travelled = 0.0;\n    \n    // p is already very close to a surface. If we just check to see how far from\n    // that surface we are and assume we've hit it when d<0.001, we'll always think\n    // we've hit it in the first iteration. What happens if this value is too small?\n    p += normal * 0.002;\n    vec3 light_dir = light_pos - p;\n    float dist_to_light = length(light_dir);\n    //normalize light_dir:\n    light_dir /= dist_to_light;\n    \n    for(int iterations = 0; iterations < 150; iterations++) {\n        float d = map_composite_object(p);\n        distance_travelled += d;\n        if(distance_travelled > dist_to_light) {\n            return false;\n        }\n        if(d < 0.001) {\n            return true;\n        }\n        p += d * light_dir;\n    }\n    \n    // you could make an argument to go either way... true is probably better.\n    return true;\n}\n    \n// MAKE VERY SURE THAT to_viewpoint and normal ARE NORMALIZED (length == 1.0)\nvec3 lighting(in vec3 p, in vec3 to_viewpoint, in vec3 normal, in vec3 light_col, in vec3 light_pos, in vec3 surface_col) {\n    float shadow_test_count = 4.0;\n    vec3 lit_color = vec3(0.0);\n    for(float shadow_test=1.0; shadow_test<=shadow_test_count; shadow_test++) {\n        vec3 area_light_pos = light_pos + rand_vector(p.xy + 13.773*shadow_test) * light_size;\n    \n        vec3 area_light_dir = normalize(area_light_pos - p);\n        float diffuse_brightness = dot(normal, area_light_dir);\n        if(diffuse_brightness > 0.0) {\n            if(!is_shadowed(p, normal, area_light_pos)) {\n                lit_color += diffuse_brightness * light_col * surface_col;\n                \n                vec3 reflection = 2.0 * normal * dot(normal, area_light_dir) - area_light_dir;\n                lit_color += light_col * pow(dot(reflection, to_viewpoint), 100.0); \n            }\n        }\n    }\n    \n    return lit_color/shadow_test_count;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Making random numbers is hard AFF:\n    srand(iTime);\n    //fragColor.rgb = rand_vector(fragCoord);\n    //return;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // We want 0,0 to be the center of the screen, so rescale and recenter:\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // The pixels in the image now go from <-1.0, -1.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Rescale\n    // in the y direction to compensate:\n    uv.y /= (iResolution.x/iResolution.y);\n    \n    // Set up the camera:\n    float camera_distance_from_origin = 8.0;\n    vec3 camera_position = vec3(\n        sin(iTime/2.0) * camera_distance_from_origin,\n        1.0,\n        cos(iTime/2.0) * camera_distance_from_origin);\n        \n    vec3 camera_lookat_point = vec3(0.0, -0.2, 0.0);\n    \n    // Setting up the camera takes a bit of magic. The cross product of two vectors gives\n    // you a third vector at right angles to both of the input vectors. Our camera is at \n    // some arbitrary point in space, pointing at some other arbitrary point in space. To\n    // figure out which way is up and which way is right, we have to do some assuming. We\n    // want the camera to be level, so the right vector must be perpendicular to <0, 1, 0>\n    // AND the look direction, so let's start with that:\n    // !!!!NOTE!!!!\n    // This all goes to hell if your camera is directly above or below the lookat point,\n    // because the cross product of the look vector and <0, 1, 0> is undefined. Don't.\n    vec3 look_direction = normalize(camera_lookat_point - camera_position);\n    vec3 right = normalize(cross(look_direction, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, look_direction));\n    \n    // To get the direction a \"reverse photon\" travels from the eyepoint, we put the uv \n    // \"screen\" in front of the eyepoint and find the vector from the eyepoint through\n    // the pixel we're currently processing:\n    float eyepoint_to_screen_distance = 2.0;\n    vec3 pixel_location = camera_position + eyepoint_to_screen_distance * look_direction +\n        right * uv.x + up * uv.y;\n    vec3 ray_direction = normalize(pixel_location - camera_position);\n    \n    // 1) Start at the camera position.\n    // 2) Check to see how far current_position is from object(s).\n    // 3) Move along the camera->pixel direction by that distance.\n    // 4) goto 2, until you've either gone too far from objects to expect to ever hit them,\n    //    or, you're so close to one that we'll assume you've hit the object.\n    // 5) If you hit the compound object, find its normal and just use that as its color,\n    //    otherwise, you hit the ground plane and choose a color that paints the grid.\n    // 6) If you've iterated too many times, give up and return blinking green to draw\n    //    attention to the issue.\n    vec3 current_position = camera_position;\n\n    for(int iterations=0; iterations<150; iterations++) {\n        float comp_dist = map_composite_object(current_position);\n        float plane_dist = map_ground_plane(current_position);\n        float dist = min(comp_dist, plane_dist);\n        current_position += dist * ray_direction;\n        if(dist < 0.001) {\n            vec3 diffuse_col;\n            vec3 to_viewpoint = normalize(current_position - camera_position);\n            if(comp_dist < plane_dist) {\n                vec3 normal = calc_normal(current_position);\n                diffuse_col = lighting(current_position, to_viewpoint, normal, light_col, light_pos, vec3(1.0));\n            } else {\n                // Compute the ground plane color intensity:\n                vec3 c = vec3(0.9 + 0.05*cos(current_position.x) + 0.05*cos(current_position.z));\n                diffuse_col = lighting(current_position, to_viewpoint, vec3(0.0, 1.0, 0.0), light_col, light_pos, c);\n\n            }\n            fragColor.rgb = diffuse_col;\n            return;\n        } else if (dist > 10.0) {\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            return;\n        }\n    }    \n    \n    // This is our error case. We didn't hit anything, but we iterated so long that we\n    // had to give up. \n     fragColor.g = 0.1;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hard_union( float d0, float d1 ) {\n    return(min(d0, d1));\n}\n\nfloat hard_subtraction( float d0, float d1 ) {\n    return(max(d0, -d1));\n}\n\nfloat hard_intersection( float d0, float d1 ) {\n    return(max(d0, d1));\n}\n\nfloat smooth_union( float d0, float d1, float k ) {\n    float h = clamp( 0.5 + 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) - k*h*(1.0-h); }\n\nfloat smooth_subtraction( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0+d1)/k, 0.0, 1.0 );\n    return mix( d0, -d1, h ) + k*h*(1.0-h); }\n\nfloat smooth_intersection( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) + k*h*(1.0-h); }\n\n// TODO: \n// * more shapes!\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_x(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,   0.0,\n                0.0, s,   c,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_y(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,   0.0, -s,  0.0,\n                0.0, 1.0, 0.0, 0.0,\n                s,   0.0, c,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_z(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,   -s,  0.0, 0.0,\n                s,   c,   0.0,  0.0,\n                0.0, 0.0, 1.0,  0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point along the rotation axis,\n// this is a clockwise rotation (in our left-handed coordinate system.)\nmat4 rotation_arbitrary(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translate(vec4 delta) {\n    return mat4(1.0, 0.0, 0.0, delta.x,\n                0.0, 1.0, 0.0, delta.y,\n                0.0, 0.0, 1.0, delta.z,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nfloat rand_accum = 2986.17;\nfloat rand(vec2 co){\n    return fract(sin(rand_accum + dot(co, vec2(12.9898, 78.233))) * 4358.5453);\n}\n\nvoid srand(float seed) {\n    rand_accum = seed;\n}\n\nvec3 rand_vector(vec2 chaos) {\n    vec3 retval = vec3(rand(chaos * 1.73 + 1.76), rand(chaos * 3.28 + 8.16), rand(chaos * 3.99 + 0.33));\n    //TODO: THIS IS VERY BADLY DISTRIBUTED!!!!!\n    return normalize(retval);\n}\n\n// LOOK AT https://iquilezles.org/articles/distfunctions/ for the best SDF reference\n// anywhere.\n\n// The \"signed distance function\" for a box with rounded corners. \nfloat sdf_rounded_box( in vec3 p, in vec3 r, in float radius) {\n    return length(max(abs(p) - r, 0.0)) - radius;\n}\n\nfloat sdf_sphere( in vec3 p, in float radius) {\n    return length(p) - radius;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}","name":"Common","description":"","type":"common"}]}