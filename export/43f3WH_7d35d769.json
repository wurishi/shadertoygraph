{"ver":"0.1","info":{"id":"43f3WH","date":"1707383898","viewed":86,"name":"Tarkov Bleeding Screen Effect v1","username":"oxi_dev","description":"This is an attempt to recreate Escape from Tarkov's bleeding screen effect. I will probably rewrite it soon to look more like blood.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","animated","blood","screeneffect","tarkov"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.14159265358979323846\n\nconst int pointCount = 8;\nconst float pointRadius = 40.f;\nconst float radiusDivergence = 30.f;\nconst float radiusDivergenceScale = 6000.f;\n\n// Timings\nconst float splatterTime = 0.003f;\nconst float fadeTime = 0.2f;\nconst float splatterSegment = 0.15f; // Relative Length\nconst float constSegment = 0.2f; // Relative Length\nconst float totalTime = 14.f; // Seconds\nconst float splatterDivergenceScale = 10000.f;\nconst float fadeDivergenceScale = 8000.f;\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(M_PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat map(float x, float minA, float maxA, float minB, float maxB) {\n    return ((x-minA)/(maxA-minA)) * (maxB-minB) + minB;\n}\n\nvec2 getPoint(int i, float loopBaseTime) {\n    return vec2(rand(vec2(i, i) * loopBaseTime), rand(vec2(i, -i) * loopBaseTime));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float loopTime = mod(iTime, totalTime);\n    float loopBaseTime = (iTime - loopTime) + totalTime;\n    \n    // Calculate min dist from points\n    float minDist = 99999.f;\n    int targetP = 0;\n    for (int i = 0; i < pointCount; i++) {\n        vec2 p = getPoint(i, loopBaseTime) * iResolution.xy;\n        float dist = length(fragCoord-p);\n        if (dist < minDist) {\n            targetP = i;\n            minDist = dist;\n        }\n    }\n    \n    float radius = pointRadius + (2.f*pNoise(getPoint(targetP, loopBaseTime) * radiusDivergenceScale * loopBaseTime, 6) - 1.f) * radiusDivergence;\n    \n    // Discard if too far away for perf\n    if (minDist > radius) {\n        fragColor = vec4(0.f,0.f,0.f,1.f);\n        return;\n    }\n    \n    // Calculate strength alpha\n    float alpha = map(minDist, 0.f, radius, 1.f, 0.f);\n    alpha = clamp(alpha, 0.f, 1.f);\n    alpha = 1.f - pow(1.f - alpha, 2.f);\n    float maskAlpha = 1.f - pow(1.f - alpha, 2.f);\n    \n    if (loopTime < totalTime * splatterSegment) {\n        float startTimeMax = (splatterSegment-splatterTime)*totalTime;\n        float startTime = pNoise(getPoint(targetP, loopBaseTime) * splatterDivergenceScale * loopBaseTime, 6) * startTimeMax;\n        \n        if (loopTime > startTime) {\n            float rAlpha = map(loopTime, startTime, startTime + splatterTime*totalTime, 0.f, 1.f);\n            rAlpha = clamp(rAlpha, 0.f, 1.f);\n            radius = radius * rAlpha;\n            maskAlpha *= rAlpha;\n        } else {\n            radius = 0.f;\n            maskAlpha = 0.f;\n        }\n    } else if (loopTime > totalTime * constSegment) {\n        float fadeSegment = 1.f - constSegment;\n        float startTimeMax = (fadeSegment - fadeTime) * totalTime;\n        float startTime = totalTime*constSegment + pNoise(getPoint(targetP, loopBaseTime) * fadeDivergenceScale * loopBaseTime, 6) * startTimeMax;\n        \n        if (loopTime > startTime){\n            float fAlpha = map(loopTime, startTime, startTime + fadeTime*totalTime, 0.f, 1.f);\n            fAlpha = clamp(fAlpha, 0.f, 1.f);\n            maskAlpha *= (1.f-fAlpha);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(mix(vec3(0.851, 0.298, 0.255), vec3(0.451, 0.067, 0.035), 1.f-alpha) * maskAlpha, 1.f);\n}","name":"Image","description":"","type":"image"}]}