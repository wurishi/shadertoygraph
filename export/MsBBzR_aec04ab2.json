{"ver":"0.1","info":{"id":"MsBBzR","date":"1625659980","viewed":114,"name":"Raymarch 9001","username":"johannesCmayer","description":"Raymarch","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int maxSteps = 100;\nfloat epsilon = .001;\n\nstruct Sphere\n{\n    int id;\n    vec3 pos;\n    float r;\n};\n    \nstruct HitData\n{\n    bool hit;\n    vec3 hitP;\n};\n\nSphere createSphere(int id, vec3 pos, float r)\n{\n    Sphere sp;\n    sp.id = id;\n    sp.pos = pos;\n\tsp.r = r;\n    \n    return sp;\n}\n\nvec3 RotateX(vec3 toRotate, vec3 camRot)\n{\n    mat3 rX = mat3 (\n        1.0, 0.0, 0.0,\n        0.0, cos(camRot.x), -sin(camRot.x),\n        0.0, sin(camRot.x), cos(camRot.x)\n        );  \n\n        return toRotate * rX;\n}\n\nvec3 RotateY(vec3 toRotate, vec3 camRot)\n{\n    mat3 rY = mat3 (\n        cos(camRot.y), 0.0,sin(camRot.y),\n        0.0, 1.0, 0.0,\n        -sin(camRot.y), 0.0, cos(camRot.y)\n        );  \n\n        return toRotate * rY;\n}\n\nvec3 RotateZ(vec3 toRotate, vec3 camRot)\n{\n    mat3 rZ = mat3 (\n        cos(camRot.z), -sin(camRot.z), 0.0,\n        sin(camRot.z), cos(camRot.z), 0.0,\n        0.0, 0.0, 1.0\n        );  \n\n        return toRotate * rZ;\n}\n\nvec3 Rotate(vec3 toRotate, vec3 camPos, vec3 camRot)\n{\n    vec3 tp = toRotate - camPos;\n    tp = RotateZ(RotateY(RotateX(tp, camRot), camRot), camRot);\n    return tp + camPos;\n}\n\nfloat sceneDistance(vec3 pos, Sphere s)\n{\n    return length(s.pos - pos) - s.r;\n}\n\nvec3 CalcNormal(Sphere sp, vec3 hitpoint)\n{    \n    vec3 n = normalize(hitpoint - sp.pos);\n    n = vec3((n.x + 1.) / 2., (n.y + 1.) / 2., (n.z + 1.) / 2.);\n    return n;\n}\n\nHitData raymarch(vec3 rayOrigin, vec3 rayDirection, Sphere sp)\n{\n    float t = 0.;\n    HitData hd;\n    rayDirection = normalize(rayDirection);\n    \n    for (int i = 0; i < maxSteps; i++)\n    {\n        float d = sceneDistance(rayOrigin + rayDirection * t, sp);\n        if (d < epsilon)\n        {\n            hd.hit = true;\n            hd.hitP = rayOrigin + rayDirection * t;            \n            return hd;\n        }\n        t += d;\n    }\n    hd.hit = false;\n    hd.hitP = rayOrigin + rayDirection * t;\n    return hd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Sphere sp = createSphere(0, vec3(0., 0.1, 1.), .1);\n    Sphere sp2 = createSphere(1, vec3(0., 0.1, -1.), .1);\n        \n    //camera\n    vec3 camPos = vec3(0., 0.1, 0.);\n    vec3 camRot = vec3(0.2, iTime, 0.1);\n    \n    float screenSpaceX = fragCoord.x;\n    float screenSpaceY = fragCoord.y;\n    \n    screenSpaceX = (screenSpaceX - iResolution.x / 2.) / iResolution.y;\n    screenSpaceY = (fragCoord.y - iResolution.y / 2.) / iResolution.y;\n       \n    HitData hit = raymarch(camPos, Rotate(vec3(screenSpaceX, screenSpaceY, 1.), camPos, camRot) + camPos, sp);\n    HitData hit2 = raymarch(camPos, Rotate(vec3(screenSpaceX, screenSpaceY, 1.), camPos, camRot) + camPos, sp2);\n        \n    if (hit.hit || hit2.hit)\n    {\n\tfragColor = vec4(CalcNormal(sp, hit.hitP).x + CalcNormal(sp2, hit2.hitP).x, \n                     CalcNormal(sp, hit.hitP).y + CalcNormal(sp2, hit2.hitP).y, \n                     CalcNormal(sp, hit.hitP).z + CalcNormal(sp2, hit2.hitP).z, 1.);\n    }\n    else if (hit.hitP.y > -0.1 && hit2.hitP.y > -0.1)\n    {\n        fragColor = vec4(0., 0., 0.2, 1.);\n    }\n    else\n    {\n        fragColor = vec4(0., 0.3, 0., 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}