{"ver":"0.1","info":{"id":"WtycDc","date":"1611851754","viewed":61,"name":"Dancing Spheres in mirror box","username":"ma38su","description":"Path Tracing in mirror box","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nconst int LEN_SPHERES = 10;\nconst int LEN_RECTS = 5;\n\nconst int NS = 4;\nconst int ITER = 12;\n\nconst float fov = 1.0;\nconst float EPS = 0.00001;\nconst float INF = 100000.0;\n\nconst float aperture = 0.00;\nconst float sense = 10.0;\n\nconst int LAMBERTIAN = 0;\nconst int METAL = 1;\nconst int DIELECTRIC = 2;\n\nconst int TEX_COLOR = 0;\nconst int TEX_CHECK2 = 1;\nconst int TEX_CHECK3 = 2;\nconst int TEX_BACKBUF = 3;\n\nstruct Hit {\n  vec3 rp;\n  vec3 nv;\n  vec2 uv;\n  int index;\n};\n\nstruct Sphere {\n  vec3 center;\n  float radius;\n};\n\nconst int XY = 0;\nconst int YZ = 1;\nconst int XZ = 2;\n\nstruct Rect {\n  vec3 center;\n  vec2 size;\n  int axis;\n};\n\nstruct Material {\n  int type;\n  int texture;\n  \n  vec3 albedo;\n  vec3 emit;\n};\n\nconst uint K = 0x456789abU;\nconst float uint_range = 1. / float(0xFFFFFFFFU);\n\nvoid xorshift(inout uint seed) {\n  seed ^= seed << 13;\n  seed ^= seed >> 17;\n  seed ^= seed << 5;\n}\n\nfloat next_float(inout uint seed) {\n  xorshift(seed);\n  return float(seed - 1U) * uint_range;\n}\n\nfloat atan2(float y, float x){\n  return x == 0.0 ? sign(y) * PI/2.0 : atan(y, x);\n}\n\nvec3 texture_check(vec2 uv, vec3 color) {\n  if (sin(uv.x * 8.0 * PI) * sin(uv.y * 8.0 * PI) > 0.0) {\n    return vec3(1.0);\n  } else {\n    return color;\n  }\n}\n\nvec3 texture_check(vec3 uv) {\n  if (sin(uv.x * 4.0 * PI) * sin(uv.y * 2.0 * PI) * sin(uv.z * 4.0 * PI) > 0.0) {\n    return vec3(1.0);\n  } else {\n    return vec3(0.1);\n  }\n}\n\nvec2 random_in_disk(inout uint seed) {\n  float r1 = next_float(seed);\n  float r2 = next_float(seed);\n\n  float r = sqrt(r1);\n  float theta = 2.0 * PI * r2;\n  float x = r * cos(theta);\n  float y = r * sin(theta);\n  return vec2(x, y);\n}\n\nvec3 random_in_sphere(inout uint seed) {\n  vec3 v;\n  for (int i = 0; i < 1024; ++i) {\n    v.x = next_float(seed) - 0.5;\n    v.y = next_float(seed) - 0.5;\n    v.z = next_float(seed) - 0.5;\n    if (length(v) < 0.5) return v * 2.0;\n  }\n  return normalize(v);\n}\n\nvec3 random_unit_vector(inout uint seed) {\n  return normalize(random_in_sphere(seed));\n}\n\nvec3 background(vec3 rd) {\n  return vec3(0.2);\n}\n\nfloat hit_sphere(vec3 ro, vec3 rd, vec3 center, float radius) {\n  vec3 oc = ro - center;\n  float a = dot(rd, rd);\n  float b = 2.0 * dot(oc, rd);\n  float c = dot(oc, oc) - radius * radius;\n  float discriminant = b * b - 4.0 * a * c;\n  if (discriminant < 0.0) {\n    return -1.0;\n  }\n  return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nbool hit_xy_rect(vec3 ro, vec3 rd, vec3 center, vec2 size, float tMin, float tMax, out float t, out vec3 rp, out vec2 uv) {\n  float k = center.z;\n  t = (k - ro.z) / rd.z;\n  if (t < tMin || t > tMax) {\n    return false;\n  }\n  \n  vec2 min_p = center.xy - size;\n  vec2 max_p = center.xy + size;\n\n  vec3 p = ro + t * rd;\n  if (p.x < min_p.x || p.x > max_p.x\n    || p.y < min_p.y || p.y > max_p.y) {\n    return false;\n  }\n\n  rp = p;\n  uv = (p.xy - min_p) / (max_p - min_p);\n  return true;\n}\n\nbool hit_yz_rect(vec3 ro, vec3 rd, vec3 center, vec2 size, float tMin, float tMax, out float t, out vec3 rp, out vec2 uv) {\n  float k = center.x;\n  t = (k - ro.x) / rd.x;\n  if (t < tMin || t > tMax) {\n    return false;\n  }\n  \n  vec2 min_p = center.zy - size;\n  vec2 max_p = center.zy + size;\n\n  vec3 p = ro + t * rd;\n  if (p.z < min_p.x || p.z > max_p.x\n    || p.y < min_p.y || p.y > max_p.y) {\n    return false;\n  }\n\n  rp = p;\n  uv = (p.zy - min_p) / (max_p - min_p);\n  return true;\n}\n\nbool hit_xz_rect(vec3 ro, vec3 rd, vec3 center, vec2 size, float tMin, float tMax, out float t, out vec3 rp, out vec2 uv) {\n  float k = center.y;\n  t = (k - ro.y) / rd.y;\n  if (t < tMin || t > tMax) {\n    return false;\n  }\n  \n  vec2 min_p = center.xz - size;\n  vec2 max_p = center.xz + size;\n\n  vec3 p = ro + t * rd;\n  if (p.x < min_p.x || p.x > max_p.x\n    || p.z < min_p.y || p.z > max_p.y) {\n    return false;\n  }\n\n  rp = p;\n  uv = (p.xz - min_p) / (max_p - min_p);\n  return true;\n}\n\nvec2 get_sphere_uv(vec3 p) {\n  float phi = atan2(p.z, p.x);\n  float theta = asin(p.y);\n  float u = 1.0 - (phi + PI) / (2.0 * PI);\n  float v = theta / PI + 0.5;\n  return vec2(u,v);\n}\n\nbool raytracing(vec3 ro, vec3 rd, in Sphere spheres[LEN_SPHERES], in Rect rects[LEN_RECTS], out Hit hit) {\n  float t_min = EPS;\n  float t_max = INF;\n  Sphere sph;\n  bool hit_flag = false;\n  vec3 nv;\n  vec3 rp;\n  vec2 uv;\n  \n  int geo_idx = 0;\n  \n  float t;\n\n  for (int i = 0; i < LEN_SPHERES; i++) {\n    Sphere sphere = spheres[i];\n    float t = hit_sphere(ro, rd, sphere.center, sphere.radius);\n    if (t >= t_min && t < t_max) {\n      rp = ro + t * rd;\n      nv = (rp - sphere.center) / sphere.radius;\n      t_max = t;\n      uv = get_sphere_uv((rp - sphere.center) / sphere.radius);\n      geo_idx = i;\n      hit_flag = true;\n    }\n  }\n  for (int i = 0; i < LEN_RECTS; ++i) {\n    Rect rect = rects[i];\n    if (rect.axis == XY) {\n      if (hit_xy_rect(ro, rd, rect.center, rect.size, t_min, t_max, t, rp, uv)) {\n        nv = vec3(0., 0., 1.0);\n        geo_idx = LEN_SPHERES + i;\n        hit_flag = true;\n        t_max = t;\n      }\n    } else if (rect.axis == YZ) {\n      if (hit_yz_rect(ro, rd, rect.center, rect.size, t_min, t_max, t, rp, uv)) {\n        nv = vec3(1.0, 0., 0.);\n        geo_idx = LEN_SPHERES + i;\n        hit_flag = true;\n        t_max = t;\n      }\n    } else if (rect.axis == XZ) {\n      if (hit_xz_rect(ro, rd, rect.center, rect.size, t_min, t_max, t, rp, uv)) {\n        nv = vec3(0.0, -1.0, 0.);\n        geo_idx = LEN_SPHERES + i;\n        hit_flag = true;\n        t_max = t;\n      }\n    }\n  }\n  if (!hit_flag) return false;\n\n  hit = Hit(rp, nv, uv, geo_idx);\n  return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 r = iResolution.xy;\n  vec2 uv = gl_FragCoord.xy/r;\n\n  vec3 black = vec3(0.);\n  vec3 white = vec3(1.);\n  Sphere spheres[LEN_SPHERES];\n  Rect rects[LEN_RECTS];\n  Material materials[LEN_SPHERES + LEN_RECTS];\n\n  {\n    float rotation_speed = 0.5;\n    int i = 0;\n    uint j = 11U;\n    float r, l, phi;\n    float phiStep = 2.0 * PI / float(LEN_SPHERES - 1);\n\n    phi = iTime * rotation_speed;\n    l = 0.0;\n\n    r = 1000.;\n    spheres[i] = Sphere(vec3(0., -r, 0.), r);\n    materials[i] = Material(METAL, TEX_CHECK3, vec3(0.7, 0.7, 0.4), black);\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.2;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(METAL, TEX_CHECK2, vec3(0., .0, .9), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) + 1.0;\n    r = 0.1 + next_float(j) * 0.2;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(0.9, 0.9, 0.9), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.2;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(0.8, 0.3, 0.3), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(0.9, .9, .9), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(.9, .1, .0), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(METAL, TEX_COLOR, white * 0.9, black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(0.8, 0.6, 0.2), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(0., .9, .1), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(0.9, 0.0, 0.9), black);\n    phi += phiStep;\n    i++;\n\n    float w = 1.6;\n    float h = 0.4;\n    rects[i - LEN_SPHERES] = Rect(vec3(0., h, 1.6), vec2(w, h), XY);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n    \n    rects[i - LEN_SPHERES] = Rect(vec3(0., h, -1.6), vec2(w, h), XY);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n\n    rects[i - LEN_SPHERES] = Rect(vec3(1.6, h, 0.), vec2(w, h), YZ);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n\n    rects[i - LEN_SPHERES] = Rect(vec3(-1.6, h, 0.), vec2(w, h), YZ);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n\n    rects[i - LEN_SPHERES] = Rect(vec3(-0., h * 2.0, 0.), vec2(w, w), XZ);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n  }\n\n  float t = iTime * 0.25;\n    \n  float rate = 2.0;\n  for (int i = 1; i < LEN_SPHERES; i += 3) {\n    float jumpY = spheres[i].radius * (pow(abs(sin((rate * t + 1.) * PI)), 16.0) + 1.0);\n    spheres[i].center.y = jumpY;\n    rate *= 2.0;\n  }\n\n  uint sseed = uint(t + 1.5);\n  for (int i = 0; i < 3; ++i) {\n    int li = 2 + i * 3 + int(next_float(sseed) * 2.0);\n    materials[li].emit = vec3(3.0 * pow(abs(sin(t * PI + PI * 0.5)), 8.0));\n  }\n\n  float r_rate = 1./min(r.x,r.y);\n  vec2 p = (gl_FragCoord.xy*2.-r)*r_rate;\n  vec3 ro0 = vec3(0.0, 0.5, 0.0);\n\n  vec3 ta = vec3(0., 0.5, 2.);\n  \n  float focus_dist = length(ta - ro0);\n  vec3 cdir = normalize(ta - ro0);\n  vec3 side = cross(cdir,vec3(0.,1.,0.));\n  vec3 up = cross(side, cdir);\n\n  vec3 rd0 = normalize(p.x*side+p.y*up+cdir*fov);\n\n  vec3 col = vec3(0.);\n  int n = 0;\n\n  int total_depth = 0;\n\n  uint seed = uint(gl_FragCoord.y * r.x + gl_FragCoord.x);\n\n  vec3 ro;\n  vec3 rd;\n  for (int s = 0; s < NS; ++s) {\n    ro = ro0;\n    rd = rd0;\n\n    vec3 attenuation = vec3(1.);\n    int depth = 0;\n\n    for (int i = 0; i < ITER; ++i) {\n\n      Hit ret;\n      if (!raytracing(ro, rd, spheres, rects, ret)) {\n        col += attenuation * background(rd);\n        n++;\n        break;\n      }\n\n      vec3 rp = ret.rp;\n      Material material = materials[ret.index];\n\n      if (length(material.emit) > 0.1) {\n        col += attenuation * material.emit;\n        n++;\n        break;\n      }\n\n      vec3 albedo;\n      if (material.texture == TEX_CHECK2) {\n        albedo = texture_check(ret.uv, material.albedo);\n      } else if (material.texture == TEX_CHECK3) {\n        albedo = texture_check(rp);\n      } else {\n        albedo = material.albedo;\n      }\n\n      int type = material.type;\n      if (type == LAMBERTIAN) {\n        rd = ret.nv + random_unit_vector(seed);\n      } else {\n        vec3 reflected = reflect(rd, ret.nv);\n        rd = reflected;\n      }\n      \n      rd = normalize(rd);\n      ro = rp;\n      attenuation *= albedo;\n      depth++;\n    }\n    if (depth == 0) break;\n    total_depth += depth;\n  }\n  col = n > 0 ? sqrt(col / float(n)) : vec3(0.05);\n  fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}