{"ver":"0.1","info":{"id":"wlGcWc","date":"1682080804","viewed":52,"name":"Raytracing_shader_pointlight","username":"mms2020","description":"raytracing with shader and pointlight","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ambient = 0.1;\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom;\n} camera;\n\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n} sphere;\n\nstruct PointLight\n{\n    vec3 position;\n} pointLight;\n\nvoid setupScene()\n{\n    camera.position = vec3(0, 0., 3.5);\n    camera.direction = vec3(0., 0., -1.);\n    camera.zoom = 1.0;\n    sphere.position = vec3(0., 0., 0.);\n    sphere.radius = 0.3;\n    pointLight.position = vec3(0., 0., 0.8);  \n}\n\n\n//vrijednosti t0 i t1 ce biti dostupne van funkcije ako su postavljene\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n\n    else if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n\n    else\n    {\n        t0 = (-b + sqrt(disc)) / (2. * a);\n        t1 = (-b - sqrt(disc)) / (2. * a);\n        return true;     \n    }\n}\n\nbool intersect(vec3 direction, out float refl)\n{\n    vec3 L = camera.position - sphere.position; \n    \n    //racunanje a, b, c za rjesavanje kvadratne jednadzbe\n    float a = dot(direction, direction); //1    \n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    //vrati udaljenosti do dvije tocke koje zraka pogada\n    if(solveQuadratic(a, b, c, t0, t1))\n    {   \n        //manji t je udaljenost od ishodista do pogodene tocke\n        float t = t0;\n        if(t1 < t0)\n        {\n            t = t1;\n        }\n        \n        //vektor odreden pogodenom tockom\n        vec3 PointHit = camera.position + t * direction;\n        //normalizirani vektor od sredista sfere prema tocki PointHit\n        vec3 surfaceNormal = normalize(PointHit - sphere.position);\n        vec3 newDirection = normalize(PointHit - pointLight.position);\n        //kut izmedu ta dva vektora - reflection factor\n        refl = -dot(newDirection, surfaceNormal);\n        \n        return true;\n    }\n    return false;\n}\n\nvec3 rayTrace(vec3 direction)\n{\n    float refl = 1.;\n    //ako zraka pogada sferu\n    if(intersect(direction, refl))\n    {\n        return ambient + refl * vec3(0.9, 0.3, 0.1); //neka boja sfere\n    }\n    //ako zraka ne pogada sferu\n    else\n    {\n        return vec3(0., 0., 0.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupScene();\n    \n        \n    //normalizirane koordinate (od -0.5 do 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    //prilagoditi osi tako da slika nije razduzena\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    \n    //vektor smjera (gledamo na sferu s pozicije kamere - ovisi o zoomu)\n    vec3 direction = normalize(vec3(uv, camera.zoom) - camera.position);\n    \n    //sfera odskace\n    sphere.position.y = sin(iTime * 6.) / 3.;\n   \n    //pozivamo raytracing algoritam u smjeru vektora direction\n    vec3 col = rayTrace(direction); \n\n    //output\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}