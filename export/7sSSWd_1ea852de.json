{"ver":"0.1","info":{"id":"7sSSWd","date":"1621274368","viewed":36,"name":"octahedron zoom","username":"vjbob0","description":"i was playing around with raymarching while watching LunaSorcery's video: https://www.twitch.tv/videos/339397877 \ncode is based on Lunas Shader: https://www.shadertoy.com/view/XtGfRG","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","octahedron"],"hasliked":0,"parentid":"sdSSDt","parentname":"trippy triangle mess"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat noise(vec3 p)\n{\n    return fract(\n        sin(\n            dot(p, vec3(12.4536728,432.45673828,32.473682))\n        )*43762.342);\n}\n\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nvec3 translate(vec3 p, vec3 t)\n{\n     mat4 T = mat4(\n     vec4(1, 0, 0, t.x),\n     vec4(0, 1, 0, t.y),\n     vec4(0, 0, 1, t.z),\n     vec4(0, 0, 0, 1));\n     p = (vec4(p, 1) * inverse(T)).xyz;\n     return p;\n\n}\n\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  //source: https://iquilezles.org/articles/distfunctions\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nfloat scene(vec3 p)\n{\n   float n = noise(floor((p-2.)/4.))*2.;\n   //float n = noise(p-2.); add this to make noise pased on p\n   //fractals\n   p = mod(p- 2., 4.)- 2.;\n   p.xz = rotate(p.xz, n);\n   p.yz = rotate(p.yz, n);\n   \n   p = translate(p, vec3(sin(iTime)-.3, 0., 0.));\n   float triangle = udTriangle(vec3(p.x, p.y , p.z + iMouse.x/iResolution.x), vec3(-.2, 1. ,0. ), vec3(-.2, -1. ,0. ),vec3(.8, 0,0. ));\n   float octa = sdOctahedron(p, .5);\n   return octa;//triangle;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n\t//Sampling around the point\n\tvec2 o = vec2(0.01, 0.0);\n\tfloat d = scene(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tscene(p-o.xyy),\n\t\t\t\t\tscene(p-o.yxy),\n\t\t\t\t\tscene(p-o.yyx));\n\treturn normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 cam = vec3(0,0,-5.);\n    vec3 dir = normalize(vec3(uv, 1));\n    \n    //cam.yz = rotate(cam.yz, .3);\n    //dir.yz = rotate(dir.yz, .3);\n    \n    //cam = translate(cam, vec3(iTime * .3, 0,0));\n    \n    //cam.xz = rotate(cam.xz, iTime*.3);\n    //dir.xz = rotate(dir.xz, iTime*.3);\n    \n    float t = 0.;\n    float k = 0.;\n    int i;\n    for(i = 0; i<100; i++)\n    {\n        k = scene(cam + dir * t);\n        t += k;\n        if (k < 0.001) break;\n    }\n    \n    vec3 h = cam+dir*t;\n    vec3 n = getNormal(h);\n        \n    // Time varying pixel color\n    float fog = 1.-(float(i)/100.)*1.8;\n    vec3 col = (n.xxy * .8 + .5);\n    col.x = col.x + sin(iTime+1.9)+1.;\n    \n    col *= fog;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}