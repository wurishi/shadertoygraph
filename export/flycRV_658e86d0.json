{"ver":"0.1","info":{"id":"flycRV","date":"1698616360","viewed":81,"name":"Turtle - Ray Marching","username":"Programmer025","description":"A turtle defined with 3D Ray Marching.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","turtle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*  Math Constants  */\nconst float PI = 3.1415926538;\nconst float PI_2 = 1.5707963268;\nconst float PI_3 = 1.0471975512;\nconst float SQRT3 = sqrt(3.);\nconst float SQRT3_2 = SQRT3 * .5;\n\n/*  Color Calculations Constants  */\nconst int RGB_COLOR_BASE = 256;\n\n\n/*  Ray Casting Structs  */\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    vec3 UDirection;\n    vec3 VDirection;\n    float fov;\n    vec2 screenFOVSize;\n    float closePlaneDist;\n    float farPlaneDist;\n    vec3 exactViewDirection;\n};\n\nstruct SimpleRayCastOutput\n{\n    float dist;\n};\n\nstruct Material\n{\n    vec3 color;\n    float shininess;\n};\n\nstruct ComplexRayCastOutput\n{\n    float dist;\n    Material material;\n};\n\nstruct DirectionalLight\n{\n    vec3 direction;\n    vec3 lightColor;\n    vec3 shadowColor;\n    vec3 lightColor2;\n    vec3 lightColor3;\n};\n\n\n/*  Scene Constants  */\nconst float MAX_DIST = 1e3;\nconst int MAX_NUM_STEPS = 110;\nconst float EPS = .001; // epsilon\nconst vec3 UP_DIRECTION = vec3(0., 0., 1.);\n\nconst SimpleRayCastOutput DEFAULT_SIMPLE_RAYCAST_OUTPUT = SimpleRayCastOutput(MAX_DIST);\nconst ComplexRayCastOutput DEFAULT_COMPLEX_RAYCAST_OUTPUT = ComplexRayCastOutput(\n    /* dist = */ MAX_DIST, \n    Material(/* color = */ vec3(0.), /* shininess = */ 0.)\n);\n\nconst float SKY_SPHERE_RADIUS = MAX_DIST;\nconst DirectionalLight SUN_LIGHT = DirectionalLight(\n    /* direction = */ normalize(vec3(10., 6., -18.)),\n    /* lightColor = */ vec3(255., 251., 166.) / float(RGB_COLOR_BASE),\n    /*shadowColor = */ vec3(89., 88., 65.) / float(RGB_COLOR_BASE),\n    /* lightColor2 = */ vec3(252., 252., 232.) / float(RGB_COLOR_BASE),\n    /* lightColor3 = */ vec3(1.)\n    \n);\n\n\n/*  Colors  */\nconst int SKY_COL_1 = 0x89c8f5;\nconst int SKY_COL_2 = 0xb0deff;\nconst int SKY_COL_3 = 0xffffff;\n\n\n/*  Objects Constants  */\nconst float hexRadiusWithOffset = .46;\nconst float hexRadius = .37;\nconst float turtleShellPentagonRadius = 1.;\nconst float turtleShellPentagonRounding = 1.;\nconst float turtleShellLengthStretch = .1;\n\n\n/*  Materials  */\nconst Material turtleShellLight = Material(vec3(195., 105., 53.) / float(RGB_COLOR_BASE), .7);\nconst Material turtleShellShadow = Material(vec3(155., 69., 44.) / float(RGB_COLOR_BASE), .3);\nconst Material turtleShellShade = Material(vec3(128., 52., 31.) / float(RGB_COLOR_BASE), .3);\nconst Material turtleShellBottom = Material(vec3(96., 120., 2.) / float(RGB_COLOR_BASE), .2);\nconst Material turtleSkin = Material(turtleShellBottom.color, .6);\nconst Material eyeBall = Material(vec3(237., 237., 202.) / float(RGB_COLOR_BASE), .9);\nconst Material iris = Material(vec3(27., 161., 181.) / float(RGB_COLOR_BASE), .9);\nconst Material pupil = Material(vec3(51.) / float(RGB_COLOR_BASE), .9);\n\n\n/*  Ray Casting  */\nComplexRayCastOutput complexMap(in vec3 pos);\nSimpleRayCastOutput simpleMap(in vec3 pos);\n\nComplexRayCastOutput castRay(in vec3 position, in vec3 direction)\n{\n    float totalDistance = 0., currentDistance;\n    vec3 currentPosition;\n    for(int i = 0; i < MAX_NUM_STEPS; i++)\n    {\n        currentPosition = position + totalDistance * direction;\n        currentDistance = simpleMap(currentPosition).dist;\n        if(currentDistance >= MAX_DIST)\n        {\n            return DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n        }\n        totalDistance += currentDistance;\n        if(currentDistance <= EPS)\n        {\n            ComplexRayCastOutput result = complexMap(currentPosition);\n            result.dist = totalDistance;\n            return result;\n        }\n    }\n    \n    return DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n}\n\nvec3 getSceneNormalDirection(in vec3 location)\n{\n    const vec2 e = vec2(EPS, 0.);\n    return normalize(vec3(\n        simpleMap(location + e.xyy).dist - simpleMap(location - e.xyy).dist, \n        simpleMap(location + e.yxy).dist - simpleMap(location - e.yxy).dist, \n        simpleMap(location + e.yyx).dist - simpleMap(location - e.yyx).dist\n    ));\n}\n\n\n/*  Color Functions  */\nvec3 fromIntToRGB(in int color, in bool doClamp)\n{\n    vec3 result = vec3(\n        color / (RGB_COLOR_BASE * RGB_COLOR_BASE),\n        color / RGB_COLOR_BASE % RGB_COLOR_BASE,\n        color % RGB_COLOR_BASE\n    ) / float(RGB_COLOR_BASE);\n    result = doClamp ? clamp(result, 0., 1.) : result;\n    return result;\n}\n\nvec4 fromRGBToCMYK(in vec3 color)\n{\n    color = clamp(color, 0., 1.);\n    float k = 1. - max(color.r, max(color.g, color.b));\n    return vec4(\n        /* C = */ (1. - color.r - k) / (1. - k),\n        /* M = */ (1. - color.g - k) / (1. - k),\n        /* Y = */ (1. - color.b - k) / (1. - k),\n        /* K = */ k\n    );\n}\n\nvec3 fromRGBToHSV(in vec3 color)\n{\n    color = clamp(color, 0., 1.);\n    float cMax = max(color.r, max(color.g, color.b));\n    float delta = cMax - min(color.r, min(color.g, color.b));\n    return vec3(\n        /* H = */ delta == 0. ? 0. : PI_3 * (\n            cMax == color.r ? mod((color.g - color.b) / delta, 6.) :\n            cMax == color.g ? (color.b - color.r) / delta + 2. :\n            cMax == color.b ? (color.r - color.g) / delta + 4. : -1.\n        ),\n        /* S = */ cMax == 0. ? 0. : delta / cMax,\n        /* V = */ cMax\n    );\n}\n\nvec3 fromHSVToRGB(in vec3 color)\n{\n    /*  (X, Y, Z) = (H, S, V)  */\n    float c = color.y * color.z; // S * V\n    float x = c * (1. - abs(mod(color.x / PI_3, 2.) - 1.)); // X = C × (1 - |(H / 60°) mod 2 - 1|)\n    float m = color.z - c; // V - C\n    vec3 result = (\n               0. <= color.x && color.x <      PI_3 ? vec3(c, x, 0.) :\n             PI_3 <= color.x && color.x < 2. * PI_3 ? vec3(x, c, 0.) :\n        2. * PI_3 <= color.x && color.x < 3. * PI_3 ? vec3(0., c, x) :\n        3. * PI_3 <= color.x && color.x < 4. * PI_3 ? vec3(0., x, c) :\n        4. * PI_3 <= color.x && color.x < 5. * PI_3 ? vec3(x, 0., c) :\n        5. * PI_3 <= color.x && color.x < 6. * PI_3 ? vec3(c, 0., x) :\n        vec3(-1.)\n    );\n    return result;\n}\n\nvec3 blendColorsInHSL(in vec3 colorRGB1, in vec3 colorRGB2, in float t) // Clamped\n{\n    colorRGB1 = fromRGBToHSV(colorRGB1);\n    colorRGB2 = fromRGBToHSV(colorRGB2);\n    vec3 result = mix(colorRGB1, colorRGB2, clamp(t, 0., 1.));\n    result = fromHSVToRGB(result);\n    return result;\n}\n\n\n/*  Random Generators  */\nfloat random (in vec2 st) \n{\n    return fract(sin(\n        dot(st.xy, vec2(12.9898, 78.233))\n    ) * 43758.5453123);\n}\n\nvec3 random3(in vec3 p) // Random Direction Generator\n{\n    return normalize(vec3(\n        fract(sin(random(p.xy) * 34.5446 + 5.343) + 34.245),\n        fract(sin(random(p.yz) * 45.9457 + 2.434) + 67.343),\n        fract(sin(random(p.zx) * 29.8398 + 7.079) + 46.357)\n    ));\n}\n\n\n/*  Math Functions  */\nfloat smoothStep(in float x)\n{\n    return pow(smoothstep(0., 1., x), 2.);\n}\n\nMaterial mix(in Material m1, in Material m2, in float t)\n{\n    return Material(mix(m1.color, m2.color, t), mix(m1.shininess, m2.shininess, t));\n}\n\nfloat maxV(vec3 v)\n{\n    return v.x > v.y && v.x > v.z ? v.x : v.y > v.z ? v.y : v.z;\n}\n\nfloat minV(vec3 v)\n{\n    return v.x < v.y && v.x < v.z ? v.x : v.y < v.z ? v.y : v.z;\n}\n\nvec2 smoothMinN(float a, float b, float k, float n)\n{\n    if(a == MAX_DIST) return vec2(b, 1.);\n    if(b == MAX_DIST) return vec2(a, 0.);\n    float h = max(k - abs(a - b), 0.) / k;\n    float m = pow(h, n) * .5;\n    float s = m * k / n; \n    return (a < b) ? vec2(a - s, m) : vec2(b - s, 1. - m);\n}\n\nvec2 smoothMin2(float a, float b, float k)\n{\n    return smoothMinN(a, b, k, 2.);\n}\n\nvec2 smoothMin3(float a, float b, float k)\n{\n    return smoothMinN(a, b, k, 3.);\n}\n\n\nfloat simpleSmoothMinN(float a, float b, float k, float n)\n{\n    a = a == MAX_DIST ? b : a;\n    b = b == MAX_DIST ? a : b;\n    float h = max(k - abs(a - b), 0.) / k;\n    float m = pow(h, n) * .5;\n    float s = m * k / n; \n    return (a < b) ? a - s : b - s;\n}\n\nfloat simpleSmoothMin2(float a, float b, float k)\n{\n    return simpleSmoothMinN(a, b, k, 2.);\n}\n\nfloat simpleSmoothMin3(float a, float b, float k)\n{\n    return simpleSmoothMinN(a, b, k, 3.);\n}\n\nfloat dot2(in vec3 v) { return dot(v,v); }\n\nfloat sqr(in float num) { return num * num; }\n\nmat3x3 rotXY(in float angle)\n{\n    return mat3x3(\n        cos(angle), -sin(angle), 0.,\n        sin(angle),  cos(angle), 0.,\n                0.,          0., 1.\n    );\n}\n\n\nmat3x3 rotYZ(in float angle)\n{\n    return mat3x3(\n        1.,         0.,          0.,\n        0., cos(angle), -sin(angle),\n        0., sin(angle),  cos(angle)\n    );\n}\n\n\nmat3x3 rotXZ(in float angle)\n{\n    return mat3x3(\n        cos(angle), 0., -sin(angle),\n        0.,         1.,          0.,\n        sin(angle), 0.,  cos(angle)\n    );\n}\n\n\n/*  Sky  */\nvec3 getIntersectionDirectionRayWithSkySphere(in vec3 position, in vec3 direction)\n{\n      /*\n      l: p  + d * t (t - parameter)\n      S: x^2 + y^2 + z^2 = R^2\n      ...\n      (d.x^2 + d.y^2 + d.z^2) * t ^ 2 +\n      2 * (p.x * d.x + p.y * d.y + p.z * d.z) * t +\n      (p.x^2 + p.y^2 + p.z^2 - R^2) = 0\n      */\n      float a = (\n                direction.x * direction.x + \n                direction.y * direction.y + \n                direction.z * direction.z\n            ),\n            b = 2. * (\n                position.x * direction.x + \n                position.y * direction.y + \n                position.z * direction.z\n            ),\n            c = (\n                position.x * position.x + \n                position.y * position.y + \n                position.z * position.z - \n                SKY_SPHERE_RADIUS * SKY_SPHERE_RADIUS\n      );\n      // a * t^2 + b * t + c = 0\n      /*\n      Because the radius of the sphere is really big, \n      and the camera's parameters are expected to be way smaller,\n      we can assume that the quadratic equation always has 2 roots.\n      */\n      float D = b * b - 4. * a * c;\n      float t1 = .5 * (-b + sqrt(D)) / a,\n            t2 = .5 * (-b - sqrt(D)) / a;\n      vec3 intersectionDirection1 = normalize(position + t1 * direction),\n           intersectionDirection2 = normalize(position + t2 * direction);\n      return dot(intersectionDirection1, direction) > 0. ? intersectionDirection1 : intersectionDirection2;\n}\n\nfloat getGradientLocation(in vec3 direction)\n{\n    return (atan(direction.z, length(direction.xy)) + PI_2) / PI;\n}\n\nvec3 getSkyColor(in vec3 position, in vec3 direction)\n{\n    const int numSkyColors = 5;\n    vec3 skyColors[] = vec3[numSkyColors](\n        fromIntToRGB(SKY_COL_1, true), \n        fromIntToRGB(SKY_COL_2, true), \n        fromIntToRGB(SKY_COL_3, true), \n        fromIntToRGB(SKY_COL_2, true), \n        fromIntToRGB(SKY_COL_1, true)\n    );\n    const float skyColorLocations[] = float[numSkyColors](0., .35, .5, .75, 1.);\n    \n    vec3 viewerDirection = getIntersectionDirectionRayWithSkySphere(position, direction);\n    float location = getGradientLocation(viewerDirection);\n    \n    int index = (\n        skyColorLocations[0] <= location && location <= skyColorLocations[1] ? 0 :\n        skyColorLocations[1] <= location && location <= skyColorLocations[2] ? 1 :\n        skyColorLocations[2] <= location && location <= skyColorLocations[3] ? 2 :\n        skyColorLocations[3] <= location && location <= skyColorLocations[4] ? 3 :\n        0\n    );\n    \n    vec3 color = mix(\n        skyColors[index], \n        skyColors[index + 1], \n        smoothstep(0., 1., \n            (location - skyColorLocations[index]) / \n            (skyColorLocations[index + 1] - skyColorLocations[index])\n        )\n    );\n    \n    return color;\n}\n\n/*  Camera  */\nvoid calculateUVDirections(in vec3 frontDirection, out vec3 sideDirection, out vec3 upDirection)\n{\n    if(frontDirection == UP_DIRECTION)\n    {\n        sideDirection = vec3(0., 1., 0.);\n        upDirection = vec3(1., 0., 0.);\n    }\n    else if(frontDirection == -UP_DIRECTION)\n    {\n        sideDirection = vec3(1., 0., 0.);\n        upDirection = vec3(0., 1., 0.);\n    }\n    else\n    {\n        sideDirection = normalize(cross(frontDirection, UP_DIRECTION));\n        upDirection = normalize(cross(sideDirection, frontDirection));\n    }\n}\n\nvec3 getCameraPixelDirection(in Camera camera, in vec2 centralizedUV)\n{\n    return normalize(\n        camera.direction + \n        centralizedUV.x * camera.screenFOVSize.x * camera.UDirection +\n        centralizedUV.y * camera.screenFOVSize.y * camera.VDirection\n    );\n}\n\nvoid UpdateCamera(inout Camera camera, in vec2 centralizedUV)\n{\n    calculateUVDirections(camera.direction, camera.UDirection, camera.VDirection);\n    camera.screenFOVSize.x = tan(camera.fov * .5);\n    camera.screenFOVSize.y = camera.screenFOVSize.x * iResolution.y / iResolution.x;\n    camera.exactViewDirection = getCameraPixelDirection(camera, centralizedUV);\n}\n\nCamera SetUpCamera(in vec2 centralizedUV)\n{\n    float time = iTime * .3;\n    vec3 position = vec3(cos(time), sin(time), 0.) * 8.5 + \n        vec3(0., 0., 6.* ((iMouse.y / iResolution.y) * 2. - 1.));\n    Camera camera = Camera( \n        /* position = */ position,\n        /* direction = */ normalize(-position),\n        /* UDirection = */ vec3(0.),\n        /* VDirection = */ vec3(0.),\n        /* fov = */ PI_2,\n        /* screenFOVSize = */ vec2(0.),\n        /* closePlaneDist = */ 1.5,\n        /* farPlaneDist = */ MAX_DIST,\n        /* exactViewDirection = */ vec3(0.)\n    );\n    UpdateCamera(camera, centralizedUV);\n    return camera;\n}\n\n/*  Color Functionality  */\nvec3 addLightShadows(\n    in DirectionalLight light, \n    in vec3 normalDirection, \n    in Material material,\n    in vec3 viewerDirection\n)\n{\n    vec3 color = material.color;\n    float coefficient = dot(-light.direction, normalDirection);\n    \n    /*  Lighted Color  */\n    vec3 lightedResultColor = mix(color, light.lightColor, 0.7 * smoothStep(coefficient));\n    lightedResultColor = mix(\n        lightedResultColor, \n        light.lightColor2, \n        0.6 * smoothStep(1. - 4. * (1. - coefficient))\n    ); \n    /* Specular Light  */\n    float specularLightCoefficient = 0.6 * pow(\n        dot(-viewerDirection, reflect(light.direction, normalDirection)), 5.);\n    specularLightCoefficient = clamp(specularLightCoefficient, 0., 1.);\n    lightedResultColor = mix(\n        lightedResultColor, \n        light.lightColor3, \n       4.2 * material.shininess * smoothStep(1. - 1.6 * (1. - specularLightCoefficient * 1.1))\n    );\n   \n    /*  Shadowed Color  */\n    vec3 shadowedResultColor = mix(color, light.shadowColor, 0.8 * smoothStep(-coefficient));\n    \n    vec3 resultColor = coefficient >= 0. ? lightedResultColor : shadowedResultColor;\n    return resultColor;\n}\n\nvec3 getColor(in Camera camera, in vec2 centralizedUV)\n{\n    vec3 color;\n    ComplexRayCastOutput rayCastOutput = castRay(camera.position, camera.exactViewDirection);\n    \n    if(rayCastOutput == DEFAULT_COMPLEX_RAYCAST_OUTPUT)\n    {\n        return getSkyColor(camera.position, camera.exactViewDirection);\n    }\n    \n    vec3 scenePosition = camera.position + rayCastOutput.dist * camera.exactViewDirection;\n    Material material = rayCastOutput.material;\n    \n    \n    vec3 normalDirection = getSceneNormalDirection(scenePosition);\n    \n    material.color = addLightShadows(SUN_LIGHT, normalDirection, material, camera.exactViewDirection);\n    \n    return material.color;\n}\n\n\n/*  Signed Distance Functions  */\nfloat sdfEllipsoid(in vec3 pos, in vec3 loc, in vec3 radii)\n{\n    pos -= loc;\n    float k0 = length(pos / radii);\n    float k1 = length(pos / (radii * radii));\n    return k0 * (k0-1.0) / k1;\n}\n\nfloat sdfSphere(in vec3 pos, in vec4 sph)\n{\n    return length(pos - sph.xyz) - sph.w;\n}\n\nfloat sdfBox(in vec3 pos, in vec3 loc, in vec3 halfSizes)\n{\n    pos -= loc;\n    pos = abs(pos);\n    vec3 distances = pos - halfSizes;\n    return abs(distances) == -distances ? \n        minV(distances) : \n        length(max(vec3(0.), distances));\n}\n\nfloat sdfCube(in vec3 pos, in vec4 cube)\n{\n    pos -= cube.xyz;\n    pos = abs(pos);\n    vec3 distances = pos - vec3(cube.w);\n    return abs(distances) == -distances ? \n        minV(distances) :\n        length(max(vec3(0.), distances));\n}\n\nfloat sdfNGon(\n    in vec2 pos, \n    in vec2 loc, \n    in int n, \n    in float radius, \n    in bool shouldCornerBeOnY, \n    in float rotateAngle\n)\n{\n    pos -= loc;\n    // these 2 lines can be precomputed\n    float angle = 2. * PI / float(n);\n    float height = radius * tan(.5 * angle);\n\n    // rotate to first sector\n    pos = shouldCornerBeOnY ? pos : -pos.yx;\n    float modAngle = angle * floor((atan(pos.y, pos.x) + .5 * angle) / angle) - rotateAngle;\n    vec2 direction = vec2(cos(modAngle), sin(modAngle));\n    pos = mat2(direction.x, -direction.y, direction.y, direction.x) * pos;\n    \n    return length(pos - vec2(radius, clamp(pos.y, -height, height))) * sign(pos.x - radius);\n}\n\n// for the distance result of any 2D SDF, returns a 3D prism for the 3rd axis position value v\nfloat toPrism(in float sd2D, in float z, in float size)\n{\n    vec2 d = vec2(sd2D, abs(z) - .5 * size);\n    return length(max(d, .0)) + min(max(d.x, d.y), .0);\n}\n\nfloat sdfNPrism(\n    in vec3 pos,\n    in vec3 loc, \n    in int n, \n    in float radius, \n    in bool shouldCornerBeOnY, \n    in float rotateAngle, \n    in float depth\n)\n{\n    pos -= loc;\n    float sd2D = sdfNGon(pos.xy, vec2(0.), n, radius, shouldCornerBeOnY, rotateAngle);\n    return toPrism(sd2D, pos.z, depth);\n}\n\nfloat sdfHexagonalPrism(\n    in vec3 pos,\n    in vec3 loc,\n    in float radius, \n    bool shouldCornerBeOnY, \n    in float rotateAngle, \n    in float depth\n)\n{\n    return sdfNPrism(pos, loc, 6, radius, shouldCornerBeOnY, rotateAngle, depth);\n}\n\nfloat sfdPlane(in vec3 pos, in float zLevel)\n{\n    return pos.z - zLevel;\n}\n\nfloat sdfCone(in vec3 pos, in vec3 loc, in mat3x3 rot, in float angle, in float height)\n{\n    pos -= loc;\n    pos *= rot;\n    // c is the sin/cos of the angle\n    vec2 c = vec2(sin(angle), cos(angle));\n    float q = length(pos.xz);\n    return max(dot(c, vec2(q, pos.y)), -height - pos.y);\n}\n\nfloat sdfInfiniteCone(in vec3 pos, in vec3 loc, in mat3x3 rot, in float angle)\n{\n    pos -= loc;\n    pos *= rot;\n    // c is the sin/cos of the angle\n    vec2 c = vec2(sin(angle), cos(angle));\n    vec2 q = vec2(length(pos.xz), -pos.y);\n    float d = length(q - c * max(dot(q, c), 0.));\n    return d * ((q.x * c.y - q.y * c.x < 0.) ? -1. : 1.);\n}\n\nfloat sdfRoundCone(in vec3 pos, in vec3 locA, in vec3 locB, in float radiusA, in float radiusB)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = locB - locA;\n  float l2 = dot(ba,ba);\n  float rr = radiusA - radiusB;\n  float a2 = l2 - rr * rr;\n  float il2 = 1. / l2;\n    \n  // sampling dependant computations\n  vec3 pa = pos - locA;\n  float y = dot(pa, ba);\n  float z = y - l2;\n  float x2 = dot2(pa * l2 - ba * y);\n  float y2 = y * y * l2;\n  float z2 = z * z * l2;\n\n  // single square root!\n  float k = sign(rr) * rr * rr * x2;\n  if(sign(z) * a2 * z2 > k) return  sqrt(x2 + z2) * il2 - radiusB;\n  if(sign(y) * a2 * y2 < k) return  sqrt(x2 + y2) * il2 - radiusA;\n  return (sqrt(x2 * a2 * il2) + y * rr) * il2 - radiusA;\n}\n\nfloat addRounding(in float sd, in float radius)\n{\n    return sd - radius;\n}\n\nfloat makeAnnular(in float sd, in float radius)\n{\n  return abs(sd) - radius;\n}\n\n\n/*  Scene Distance Function  */\nComplexRayCastOutput complexMap(in vec3 pos)\n{\n    ComplexRayCastOutput result = DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n    float d, coefficient, sgn;\n    vec2 sMin;\n    vec3 loc, pos2;\n    int i, j;\n\n    \n    ComplexRayCastOutput turtleShell = DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n    /*  Turtle Shell Form  */\n    ComplexRayCastOutput turtleShellForm = DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n    d = addRounding(sdfNPrism(pos, vec3(0., 0., -.7), \n        5, turtleShellPentagonRadius, true, 0., 2.), turtleShellPentagonRounding);\n    if (d < turtleShellForm.dist) {\n        turtleShellForm.dist = d;\n        turtleShellForm.material = turtleShellLight;\n    }\n    \n    d = sdfEllipsoid(pos, vec3(0., 0., -.1), vec3(vec2(turtleShellPentagonRadius * 2.35), 1.2));\n    sMin = smoothMin2(-turtleShellForm.dist, -d, .5);\n    turtleShellForm.dist = -sMin.x;\n    turtleShellForm.material = mix(turtleShellForm.material, turtleShellShade, sMin.y);\n    d = sfdPlane(pos, -.2);\n    sMin = smoothMin2(-turtleShellForm.dist, d, .5);\n    turtleShellForm.dist = -sMin.x;\n    turtleShellForm.material = mix(turtleShellForm.material, turtleShellShade, sMin.y);\n    \n    \n    if (turtleShellForm.dist < turtleShell.dist)\n    {\n        turtleShell = turtleShellForm;\n    }\n    \n    /* Hexagons*/\n    ComplexRayCastOutput hexagons = DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n    for(int k = 0; k < 11; k++)\n    {\n        i = k - 5;\n        for(int t = 0; t < 11; t++)\n        {\n            j = t - 5;\n            if (i * i + j * j < 36)\n            {\n                loc = vec3(\n                    (float(i) + float((j % 2 + 2) % 2) * .5) * SQRT3 * hexRadiusWithOffset, \n                    (float(j) * 1.5) * hexRadiusWithOffset,\n                    .8\n                );\n                d = sdfHexagonalPrism(\n                    pos, \n                    loc, \n                    hexRadius, true, 0., 2.\n                );\n                if (d < hexagons.dist) {\n                    coefficient = sdfNGon(pos.xy, loc.xy, 6, hexRadius, true, 0.) / (SQRT3_2 * hexRadius);\n                    coefficient = coefficient - .2;\n                    hexagons.dist = d;\n                    hexagons.material = Material(\n                        mix(turtleShellLight.color, turtleShellShadow.color, coefficient), \n                        .8\n                    );\n                }            \n            }\n        }\n    }\n    \n    ComplexRayCastOutput turtleShellHexagonsForm = DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n    d = addRounding(sdfNPrism(pos, vec3(0., 0., 0.), \n        5, turtleShellPentagonRadius, true, 0., 2.), turtleShellPentagonRounding);\n    if (d < turtleShellHexagonsForm.dist) {\n        turtleShellHexagonsForm.dist = d;\n        turtleShellHexagonsForm.material = turtleShellLight;\n    }\n    \n    d = sdfEllipsoid(pos, vec3(0., 0., 0.), vec3(vec2(turtleShellPentagonRadius * 2.35), 1.2));\n    sMin = smoothMin2(-turtleShellHexagonsForm.dist, -d, .5);\n    turtleShellHexagonsForm.dist = -sMin.x;\n    turtleShellHexagonsForm.material = mix(turtleShellHexagonsForm.material, turtleShellShadow, sMin.y);\n    d = sfdPlane(pos, 0.);\n    sMin = smoothMin2(-turtleShellHexagonsForm.dist, d, .5);\n    turtleShellHexagonsForm.dist = -sMin.x;\n    turtleShellHexagonsForm.material = mix(turtleShellHexagonsForm.material, turtleShellShadow, sMin.y);\n    \n    hexagons.dist = max(hexagons.dist, turtleShellHexagonsForm.dist);\n   \n    if (hexagons.dist < turtleShell.dist)\n    {\n        turtleShell = hexagons;\n    }\n    \n    if(turtleShell.dist < result.dist)\n    {\n        result = turtleShell;\n    }\n    \n    ComplexRayCastOutput turtleHead = DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n    d = sdfRoundCone(\n        pos, \n        vec3(turtleShellPentagonRadius * 1., 0., 0.), \n        vec3(turtleShellPentagonRadius * 2., 0., .1), \n        .3, .1\n    );\n    sMin = smoothMin2(turtleHead.dist, d, .5);\n    turtleHead.dist = sMin.x;\n    turtleHead.material = mix(turtleHead.material, turtleSkin, sMin.y);\n    \n    d = sdfRoundCone(\n        pos, \n        vec3(turtleShellPentagonRadius * 2., 0., .1), \n        vec3(turtleShellPentagonRadius * 2.9, 0., .4), \n        .15, .4\n    );\n    sMin = smoothMin2(turtleHead.dist, d, .5);\n    turtleHead.dist = sMin.x;\n    turtleHead.material = mix(turtleHead.material, turtleSkin, sMin.y);\n    \n    d = sdfEllipsoid(pos, vec3(0., 0., -.1), vec3(vec2(turtleShellPentagonRadius * 1.79), .45));\n    if (d < turtleHead.dist) {\n        turtleHead.dist = d;\n        turtleHead.material = turtleShellBottom;\n    }\n    \n    d = sdfCone(pos, vec3(3.1, 0., .6),\n        mat3x3(0., 1., 0.,\n               0., 0., 1.,\n               1., 0., 0.), \n        PI_2 * .5, .3\n    );\n    \n    sMin = smoothMin2(turtleHead.dist, d, .07);\n    turtleHead.dist = sMin.x;\n    turtleHead.material = mix(turtleHead.material, turtleSkin, sMin.y);\n    \n    \n    ComplexRayCastOutput turtleLimbs = DEFAULT_COMPLEX_RAYCAST_OUTPUT;\n    for(int k = 0; k < 2; k++)\n    {\n        sgn = k == 0 ? -1. : 1.;\n        /*  Eye holes  */\n        d = sdfSphere(pos, vec4(3.1, sgn * 0.25, .56, 0.12));\n        sMin = smoothMin2(-turtleHead.dist, d, .07);\n        turtleHead.dist = -sMin.x;\n        turtleHead.material = mix(turtleHead.material, turtleSkin, sMin.y);\n        \n        /*  Eyes  */\n        d = sdfSphere(pos, vec4(3.1, sgn * 0.25, .56, 0.12));\n        sMin = smoothMin2(turtleHead.dist, d, .02);\n        turtleHead.dist = sMin.x;\n        turtleHead.material = mix(turtleHead.material, eyeBall, sMin.y);\n        \n        d = sdfEllipsoid(pos, vec3(3.185, sgn * 0.25, .56), vec3(0.04, vec2(0.09)));\n        if(d < turtleHead.dist)\n        {\n            turtleHead.dist = d;\n            turtleHead.material = iris;\n        }\n        \n        d = sdfSphere(pos, vec4(3.19, sgn * 0.25, .56, 0.05));\n        if(d < turtleHead.dist)\n        {\n            turtleHead.dist = d;\n            turtleHead.material = pupil;\n        }\n        \n        /*  Fore Limbs  */\n        d = sdfRoundCone(\n            pos, \n            vec3(1.4, sgn * turtleShellPentagonRadius * 1.5, .15), \n            vec3(1.2, sgn * turtleShellPentagonRadius * 1.9, 0.),\n            k == 0 ? .1 : .15, k == 0 ? .0667 : .1\n        );\n        sMin = smoothMin2(turtleLimbs.dist, d, .2);\n        turtleLimbs.dist = sMin.x;\n        turtleLimbs.material = mix(turtleLimbs.material, turtleSkin, sMin.y);\n        \n        loc = vec3(.6, sgn * turtleShellPentagonRadius * 1.98, .09);\n        pos2 = pos - loc;\n        pos2.z -= clamp(pos2.x * .35 - .2, -.48, .08);\n        pos2.y += sgn * max((sqr(pos2.x) * -.3 + 4.2), 4.008);\n        d = sdfEllipsoid(pos2, vec3(0.), vec3(.8, .1, .23));\n        sMin = smoothMin2(turtleLimbs.dist, d, .3);\n        turtleLimbs.dist = sMin.x;\n        turtleLimbs.material = mix(turtleLimbs.material, turtleSkin, sMin.y);\n        \n        \n        /*  Back Limbs  */\n        d = sdfRoundCone(\n            pos, \n            vec3(-.4, sgn * turtleShellPentagonRadius * 1.8, .15), \n            vec3(-.5, sgn * turtleShellPentagonRadius * 2.2, 0.), \n            k == 1 ? .1 : .15, k == 1 ? .0667 : .1\n        );\n        sMin = smoothMin2(turtleLimbs.dist, d, .5);\n        turtleLimbs.dist = sMin.x;\n        turtleLimbs.material = mix(turtleLimbs.material, turtleSkin, sMin.y);\n        \n        loc = vec3(-1.2, sgn * turtleShellPentagonRadius * 1.68, .09);\n        pos2 = pos - loc;\n        pos2.z -= clamp(pos2.x * .35 - .2, -.48, .08);\n        pos2.y += sgn * max((sqr(pos2.x) * -.3 + 4.2), 4.008);\n        d = sdfEllipsoid(pos2, vec3(0., 0., 0.), vec3(.8, .1, .23));\n        sMin = smoothMin2(turtleLimbs.dist, d, .3);\n        turtleLimbs.dist = sMin.x;\n        turtleLimbs.material = mix(turtleLimbs.material, turtleSkin, sMin.y);\n    }\n    \n    d = sdfRoundCone(\n        pos, \n        vec3(-turtleShellPentagonRadius * 1.9, 0., .15), \n        vec3(-turtleShellPentagonRadius * 2.6, 0., 0.), \n        .2, .05\n    );\n    if(d < turtleLimbs.dist)\n    {\n        turtleLimbs.dist = d;\n        turtleLimbs.material = turtleSkin;\n    }\n        \n    if(turtleLimbs.dist < turtleHead.dist)\n    {\n        turtleHead.dist = turtleLimbs.dist;\n        turtleHead.material = turtleLimbs.material;\n    }\n    \n    if(turtleHead.dist < result.dist)\n    {\n        result = turtleHead;\n    }\n    \n    return result;\n}\n\nSimpleRayCastOutput simpleMap(in vec3 pos)\n{\n    SimpleRayCastOutput result = DEFAULT_SIMPLE_RAYCAST_OUTPUT;\n    float d, coefficient, sgn;\n    vec3 loc, pos2;\n    int i, j;\n\n    \n    SimpleRayCastOutput turtleShell = DEFAULT_SIMPLE_RAYCAST_OUTPUT;\n    /*  Turtle Shell Form  */\n    SimpleRayCastOutput turtleShellForm = DEFAULT_SIMPLE_RAYCAST_OUTPUT;\n    d = addRounding(sdfNPrism(pos, vec3(0., 0., -.7), \n        5, turtleShellPentagonRadius, true, 0., 2.), turtleShellPentagonRounding);\n    turtleShellForm.dist = min(d, turtleShellForm.dist);\n    \n    d = sdfEllipsoid(pos, vec3(0., 0., -.1), vec3(vec2(turtleShellPentagonRadius * 2.35), 1.2));\n    turtleShellForm.dist = -simpleSmoothMin2(-turtleShellForm.dist, -d, .5);\n    d = sfdPlane(pos, -.2);\n    turtleShellForm.dist = -simpleSmoothMin2(-turtleShellForm.dist, d, .5);\n    \n    \n    turtleShell.dist = min(turtleShellForm.dist, turtleShell.dist);\n    \n    /* Hexagons*/\n    SimpleRayCastOutput hexagons = DEFAULT_SIMPLE_RAYCAST_OUTPUT;\n    for(int k = 0; k < 11; k++)\n    {\n        i = k - 5;\n        for(int t = 0; t < 11; t++)\n        {\n            j = t - 5;\n            if (i * i + j * j < 36)\n            {\n                loc = vec3(\n                    (float(i) + float((j % 2 + 2) % 2) * .5) * SQRT3 * hexRadiusWithOffset, \n                    (float(j) * 1.5) * hexRadiusWithOffset,\n                    .8\n                );\n                d = sdfHexagonalPrism(\n                    pos, \n                    loc, \n                    hexRadius, true, 0., 2.\n                );\n                hexagons.dist = min(d, hexagons.dist);          \n            }\n        }\n    }\n    \n    SimpleRayCastOutput turtleShellHexagonsForm = DEFAULT_SIMPLE_RAYCAST_OUTPUT;\n    d = addRounding(sdfNPrism(pos, vec3(0., 0., 0.), \n        5, turtleShellPentagonRadius, true, 0., 2.), turtleShellPentagonRounding);\n    turtleShellHexagonsForm.dist = min(d, turtleShellHexagonsForm.dist);\n    \n    d = sdfEllipsoid(pos, vec3(0., 0., 0.), vec3(vec2(turtleShellPentagonRadius * 2.35), 1.2));\n    turtleShellHexagonsForm.dist = -simpleSmoothMin2(-turtleShellHexagonsForm.dist, -d, .5);\n    d = sfdPlane(pos, 0.);\n    turtleShellHexagonsForm.dist = -simpleSmoothMin2(-turtleShellHexagonsForm.dist, d, .5);\n    \n    hexagons.dist = max(hexagons.dist, turtleShellHexagonsForm.dist);\n   \n    turtleShell.dist = min(hexagons.dist, turtleShell.dist);\n    \n    result.dist = min(turtleShell.dist, result.dist);\n    \n    SimpleRayCastOutput turtleHead = DEFAULT_SIMPLE_RAYCAST_OUTPUT;\n    d = sdfRoundCone(\n        pos, \n        vec3(turtleShellPentagonRadius * 1., 0., 0.), \n        vec3(turtleShellPentagonRadius * 2., 0., .1), \n        .3, .1\n    );\n    turtleHead.dist = simpleSmoothMin2(turtleHead.dist, d, .5);\n    \n    d = sdfRoundCone(\n        pos, \n        vec3(turtleShellPentagonRadius * 2., 0., .1), \n        vec3(turtleShellPentagonRadius * 2.9, 0., .4), \n        .15, .4\n    );\n    turtleHead.dist = simpleSmoothMin2(turtleHead.dist, d, .5);\n    \n    d = sdfEllipsoid(pos, vec3(0., 0., -.1), vec3(vec2(turtleShellPentagonRadius * 1.79), .45));\n    turtleHead.dist = min(d, turtleHead.dist);\n    \n    d = sdfCone(pos, vec3(3.1, 0., .6),\n        mat3x3(0., 1., 0.,\n               0., 0., 1.,\n               1., 0., 0.), \n        PI_2 * .5, .3\n    );\n    \n    turtleHead.dist = simpleSmoothMin2(turtleHead.dist, d, .07);\n    \n    SimpleRayCastOutput turtleLimbs = DEFAULT_SIMPLE_RAYCAST_OUTPUT;\n    for(int k = 0; k < 2; k++)\n    {\n        sgn = k == 0 ? -1. : 1.;\n        /*  Eye holes  */\n        d = sdfSphere(pos, vec4(3.1, sgn * 0.25, .56, 0.12));\n        turtleHead.dist = -simpleSmoothMin2(-turtleHead.dist, d, .07);\n        \n        /*  Eyes  */\n        d = sdfSphere(pos, vec4(3.1, sgn * 0.25, .56, 0.12));\n        turtleHead.dist = simpleSmoothMin2(turtleHead.dist, d, .02);\n        \n        d = sdfEllipsoid(pos, vec3(3.185, sgn * 0.25, .56), vec3(0.04, vec2(0.09)));\n        turtleHead.dist = min(d, turtleHead.dist);\n        \n        d = sdfSphere(pos, vec4(3.19, sgn * 0.25, .56, 0.05));\n        turtleHead.dist = min(d, turtleHead.dist);\n        \n        /*  Fore Limbs  */\n        d = sdfRoundCone(\n            pos, \n            vec3(1.4, sgn * turtleShellPentagonRadius * 1.5, .15), \n            vec3(1.2, sgn * turtleShellPentagonRadius * 1.9, 0.), \n            k == 0 ? .1 : .15, k == 0 ? .0667 : .1\n        );\n        turtleLimbs.dist = simpleSmoothMin2(turtleLimbs.dist, d, .2);\n        \n        loc = vec3(.6, sgn * turtleShellPentagonRadius * 1.98, .09);\n        pos2 = pos - loc;\n        pos2.z -= clamp(pos2.x * .35 - .2, -.48, .08);\n        pos2.y += sgn * max((sqr(pos2.x) * -.3 + 4.15), 4.008);\n        d = sdfEllipsoid(pos2, vec3(0.), vec3(.8, .1, .23));\n        turtleLimbs.dist = simpleSmoothMin2(turtleLimbs.dist, d, .3);\n        \n        \n        /*  Back Limbs  */\n        d = sdfRoundCone(\n            pos, \n            vec3(-.4, sgn * turtleShellPentagonRadius * 1.8, .15), \n            vec3(-.5, sgn * turtleShellPentagonRadius * 2.2, 0.), \n            k == 1 ? .1 : .15, k == 1 ? .0667 : .1\n        );\n        turtleLimbs.dist = simpleSmoothMin2(turtleLimbs.dist, d, .5);\n        \n        loc = vec3(-1.2, sgn * turtleShellPentagonRadius * 1.68, .09);\n        pos2 = pos - loc;\n        pos2.z -= clamp(pos2.x * .35 - .2, -.48, .08);\n        pos2.y += sgn * max(sqr(pos2.x) * -.3 + 4.2, 4.008);\n        d = sdfEllipsoid(pos2, vec3(0., 0., 0.), vec3(.8, .1, .23));\n        turtleLimbs.dist = simpleSmoothMin2(turtleLimbs.dist, d, .3);\n    }\n    \n    d = sdfRoundCone(\n        pos, \n        vec3(-turtleShellPentagonRadius * 1.9, 0., .15), \n        vec3(-turtleShellPentagonRadius * 2.6, 0., 0.), \n        .2, .05\n    );\n    turtleLimbs.dist = min(d, turtleLimbs.dist);\n    \n    \n    turtleHead.dist = min(turtleHead.dist, turtleLimbs.dist);\n    \n    result.dist = min(result.dist, turtleHead.dist);\n    \n    return result;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 centralizedUV = (fragCoord - iResolution.xy / 2.) / iResolution.xy;\n    \n    Camera camera = SetUpCamera(centralizedUV);\n     \n    vec3 col = getColor(camera, centralizedUV);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}