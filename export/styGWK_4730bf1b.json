{"ver":"0.1","info":{"id":"styGWK","date":"1638317260","viewed":247,"name":"BallsRender.png but on Shadertoy","username":"trigophers","description":"All code by me other than code credited within comments","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["raytracer","pathtracer","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Path Tracer (oopsie)\" by trigophers. https://shadertoy.com/view/fdBXRm\n// 2021-11-30 23:49:22\n\n/*\nTo save an image, right click and wait until the noise goes away.\nPath traced spheres and planes\nNot super accurate to real life...\n*/\n\n\nfloat vignette(float x, float intensity) {\n    intensity = 1.-intensity;\n    return (4.-4.*intensity)*(x-x*x)+intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n    vec3 col = data.xyz/data.w;\n    col *= vec3(vignette(uv.x, 0.75)*vignette(uv.y, 0.75));\n    \n\tfragColor = vec4( pow(col, vec3(0.45)), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.1415926536\n#define SCENE 0\nvec2 pixel;\nvec3 color;\nvec3 c;\nvec3 finC;\nvec3 point;\nvec3 vec;\nvec3 normal;\nvec4 temp;\nfloat rDist;\nint material;\nbool AspectDim;\n// - - - - - - - - - - - - - - - - - Common Functions - - - - - - - - - - - - - - - -\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\nvoid aspectNorm(vec2 fragCoord, vec2 scale) {\n    if (iResolution.x<iResolution.y) {\n        pixel = scale*(fragCoord/iResolution.xx-vec2(0.5, iResolution.y/iResolution.x/2.0));\n        AspectDim = false;\n    } else {\n        pixel = scale*(fragCoord/iResolution.yy-vec2(iResolution.x/iResolution.y/2.0, 0.5));\n        AspectDim = true;\n    }\n    \n}\n\nfloat calcFresnel(float n0, float n1) {\n    float r = (n0-n1)/(n0+n1);\n    r = r*r;\n    float a = dot(vec, normal);\n    return r+(1.-r)*pow((1.+a), 5.);\n}\nvec3 randVec(float seed) {\n    vec3 randV = vec3(1, 1, 1);\n    while (length(randV) > 1.0) {\n        randV = vec3(hash1(seed), hash1(seed), hash1(seed));\n    }\n    return randV;\n}\n// - - - - - - - - - - - - - - - - - Distance Functions - - - - - - - - - - - - - - - -\nvoid sphere(vec3 sPos, float rad, vec3 sColor, int mat, float seed) {\n    vec3 obj = sPos - point;\n    temp.x = dot(obj, vec);\n    temp.y = dot(obj, obj);\n    if ((temp.x > 0.0) && (rad * rad > (temp.y - temp.x * temp.x))) {\n        temp.z = sqrt(rad * rad - (temp.y - temp.x * temp.x));\n        if ((temp.y > rad * rad) && rDist > temp.x - temp.z) {\n            rDist = temp.x - temp.z;\n            normal = normalize(point + vec * rDist - sPos);\n            c = sColor;\n            if (mat == 3) {\n                material = 0;\n                float f = calcFresnel(1.0, 1.25);\n                if (hash1(seed)<f) {\n                    material = 1;\n                    c = vec3(255);\n                }\n            } else {\n                material = mat;\n            }\n        }\n    }\n}\nvoid fPlane(int t, vec3 pPos, vec2 dim, vec3 pColor, vec3 pColor2, float scale, int mat, float seed) {\n    if (t == 0) { //x normal\n        temp.x = 0.0-(point.x - pPos.x)/vec.x;\n        if ((vec.x != 0.0) && ((0.0-temp.x) < 0.0) && (temp.x < rDist)) {\n            if ((pPos.y-dim.x)<(vec.y*temp.x+point.y)&&\n                (pPos.y+dim.x)>(vec.y*temp.x+point.y)&&\n                (pPos.z-dim.y)<(vec.z*temp.x+point.z)&&\n                (pPos.z+dim.y)>(vec.z*temp.x+point.z)) {\n                rDist = temp.x;\n                if (int(mod( round((rDist*vec.y+point.y)/scale) + round((rDist*vec.z+point.z)/scale) , 2.0)) == 1) {\n                    c = pColor;\n                } else {\n                    c = pColor2;\n                }\n                normal = vec3((point.x>pPos.x)?1.0:-1.0, 0.0, 0.0);\n                material = 0;\n                if (mat == 3) {\n                    float f = calcFresnel(1.0, 1.5);\n                    if (hash1(seed)<f) {\n                        material = 1;\n                        c = vec3(255);\n                    }\n                } else {\n                    material = mat;\n                }\n            }\n        }\n    } else if (t == 1) { //y normal\n        temp.x = 0.0-(point.y - pPos.y)/vec.y;\n        if ((vec.y != 0.0) && ((0.0-temp.x) < 0.0) && (temp.x < rDist)) {\n            if ((pPos.x-dim.x)<(vec.x*temp.x+point.x)&&\n                (pPos.x+dim.x)>(vec.x*temp.x+point.x)&&\n                (pPos.z-dim.y)<(vec.z*temp.x+point.z)&&\n                (pPos.z+dim.y)>(vec.z*temp.x+point.z)) {\n                rDist = temp.x;\n                if (int(mod( round((rDist*vec.x+point.x+19.)/scale) + round((rDist*vec.z+point.z+19.)/scale) , 2.0)) == 1) {\n                    c = pColor;\n                } else {\n                    c = pColor2;\n                }\n                normal = vec3(0.0, (point.y>pPos.y)?1.0:-1.0, 0.0);\n                material = 0;\n                if (mat == 3) {\n                    float f = calcFresnel(1.0, 1.5);\n                    if (hash1(seed)<f) {\n                        material = 1;\n                        c = vec3(255);\n                    }\n                } else {\n                    material = mat;\n                }\n            }\n        }\n    } else { //z normal\n        temp.x = 0.0-(point.z - pPos.z)/vec.z;\n        if ((vec.z != 0.0) && ((0.0-temp.x) < 0.0) && (temp.x < rDist)) {\n            if ((pPos.x-dim.x)<(vec.x*temp.x+point.x)&&(pPos.x+dim.x)>(vec.x*temp.x+point.x)&&(pPos.y-dim.y)<(vec.y*temp.x+point.y)&&(pPos.y+dim.y)>(vec.y*temp.x+point.y)) {\n                rDist = temp.x;\n                if (int(mod( round((rDist*vec.x+point.x)/scale) + round((rDist*vec.y+point.y)/scale) , 2.0)) == 1) {c = pColor; } else { c = pColor2; }\n                normal = vec3(0.0, 0.0, (point.z>pPos.z)?1.0:-1.0); material = 0;\n                if (mat == 3) {\n                    float f = calcFresnel(1.0, 1.5);\n                    if (hash1(seed)<f) { material = 1; c = vec3(255); }\n                } else { material = mat; }\n            }\n        }\n    }\n}\n// - - - - - - - - - - - - - - - - - - - - Scene - - - - - - - - - - - - - - - - - - - -\nvoid scene(float seed) {\n  if (SCENE == 0) {\n    fPlane(1, vec3(60., 80, -80.)*4., vec2(64, 64), vec3(1000000, 1000000, 1000000), vec3(20000000, 20000000, 20000000), 1.0, 2, seed);\n    fPlane(1, vec3(0, -0.75, 0)*4., vec2(20000, 20000), vec3(80, 80, 80),  vec3(50, 50, 50), 38.0, 3, seed);\n    sphere(vec3(05.38326, 09.48362, -109.691)*4., 09.75855*4., vec3(70, 70, 70), 3, seed);\n    sphere(vec3(-11.8142, 06.83359, -94.0422)*4., 07.11052*4., vec3(25, 8, 95), 3, seed);\n    sphere(vec3(-34.1409, 07.85611, -95.5498)*4., 08.13467*4., vec3(5, 90, 5), 3, seed);\n    sphere(vec3(-23.9994, 18.7003, -124.832)*4., 18.9863*4., vec3(130, 5, 5), 3, seed);\n    sphere(vec3(32.3795, 11.6985, -98.1731)*4., 11.9819*4., vec3(5, 5, 90), 3, seed);\n    sphere(vec3(36.9962, 14.3103, -139.278)*4., 14.5811*4., vec3(35, 8, 95), 3, seed);\n    sphere(vec3(27.3374, 07.51414, -115.845)*4., 07.7825*4., vec3(130, 10, 10), 3, seed);\n    sphere(vec3(14.9821, 05.74386, -124.279)*4., 06.00562*4., vec3(5, 90, 5), 3, seed);\n    sphere(vec3(-01.04378, 11.5052, -146.261)*4., 11.7685*4., vec3(5, 5, 90), 3, seed);\n  }\n}\n// - - - - - - - - - - - - - - - - - - - Rendering - - - - - - - - - - - - - - - - - - -\nvoid setVec(vec3 cameraPosition, vec3 cameraVector) {\n    point = cameraPosition;\n    vec = normalize(cameraVector);\n}\nvoid dirVec(vec2 cameraDirection) {\n    temp.x = vec.z;\n    vec.z = vec.z * cos(cameraDirection.y) - vec.y * sin(cameraDirection.y);\n    vec.y = vec.y * cos(cameraDirection.y) + temp.x * sin(cameraDirection.y);\n    temp.x = vec.z;\n    vec.z = vec.z * cos(cameraDirection.x) - vec.x * sin(cameraDirection.x);\n    vec.x = vec.x * cos(cameraDirection.x) + temp.x * sin(cameraDirection.x);\n}\nvec3 raytrace(vec3 cameraPosition, vec2 cameraDirection, float FoV, float RenderDistance, int maxRefs, float fogFact, float seed) {\n    setVec(cameraPosition, vec3(pixel+(AspectDim?vec2(hash1(seed)/iResolution.yy):vec2(hash1(seed)/iResolution.xx)), FoV));\n    dirVec(cameraDirection);\n    finC = vec3(1.0, 1.0, 1.0); c = vec3(0.0, 0.0, 0.0);\n    rDist = 0.0; material = 0;\n    \n    int refsI = 0;\n    while ((rDist < RenderDistance) && (refsI < maxRefs) && !(finC == vec3(0.0, 0.0, 0.0)) && !(material == 2)) {\n        rDist = RenderDistance;\n        scene(seed);\n        if (rDist<RenderDistance) {\n            if (hash1(seed)>(1.0/(rDist*fogFact))) {\n                setVec(point+vec*rDist*hash1(seed)+normal, normal+(randVec(seed)-vec3(0.5))*4.0);\n            } else { \n                finC *= c/vec3(255.0);\n                if (material == 0) {\n                    setVec(point+vec*rDist+normal, normal+(randVec(seed)-vec3(0.5))*2.0);\n                } else if (material == 1) {\n                    setVec(point+vec*rDist+normal, vec-normal*vec3(2.0)*dot(normal, vec));\n                \n                }\n            }\n        }\n        refsI++;\n    } \n    if (!(rDist<RenderDistance)) {\n        //finC *= vec3(0, 0, 0);\n        finC *= texture(iChannel2, vec).rgb*256.0*2.0;\n    }\n    return finC;\n}\n// - - - - - - - - - - - - - - - - - - - - Display - - - - - - - - - - - - - - - - - - -\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 accu = vec3(0);\n    vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n    float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n    \n    for (int rfdtt = 0; rfdtt < 32; rfdtt += 1) {\n        seed += 1.;\n        vec2 cameraDirection;\n        aspectNorm(fragCoord, vec2(1.0, 1.0));\n        float FoV = 1.0;\n        float RenderDistance = 10000000.0;\n        int maxRefs = 5;\n        float foggy;\n        vec3 cameraPosition;    \n\n        cameraPosition = vec3(0.06972*4., 19.3017*4., -10.851*4.);\n        cameraDirection = vec2(pi, -0.05);\n        foggy = 0.;\n        FoV = 1.8;\n        accu += raytrace(cameraPosition, cameraDirection, FoV, RenderDistance, maxRefs, foggy, seed);\n    }\n    \n    vec4 data = texture( iChannel0, fragCoord/iResolution.xy );\n    if(iFrame==0 || iMouse.z>1.) data = vec4(0.0);\n    data += vec4(accu/32./255.0, 1.0);\n    fragColor = data;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}