{"ver":"0.1","info":{"id":"ddXyW2","date":"1687210283","viewed":50,"name":"f(x) SDF","username":"MonterMan","description":"finding distance from p to f(x)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// comment out to see distance distortion\n#define CORRECT_DISTANCE\n\nfloat func(float x)\n{\n    return 0.5*sin(x*10.0);\n}\n\nfloat dfunc(float x)\n{\n    return cos(x*10.0)*5.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float f = func(uv.x);\n    float df = dfunc(uv.x);\n    \n#ifdef CORRECT_DISTANCE\n    // search for z such that the distance between (z, f(z)) and (x, y) is minimized\n    // assumes local linearity: df(x) ~= df(z)\n    float z = uv.x + df*(uv.y - f) / (1.0 + df*df); // distance correction\n#else\n    float z = uv.x; // no correction\n#endif\n    float dist = length(vec2(z, func(z)) - uv);\n\n    // Output to screen\n    vec3 col = vec3(1.0-smoothstep(0.0, 0.008, dist));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}