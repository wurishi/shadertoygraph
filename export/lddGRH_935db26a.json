{"ver":"0.1","info":{"id":"lddGRH","date":"1448660863","viewed":559,"name":"Night Road","username":"AkshayDhok","description":"\nIn the process of learning distance rayMarching I created this scene.\nModified @XT95 's checker function to create path. Thanks for that!!\nThis shader is result of improvement over my old shader : https://www.shadertoy.com/view/lst3z8\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sky","road","night","ride"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nvec2 sun_position_shift = vec2( 1.0,-0.5);\n\nvec4 SkyColor = vec4(0.3, 0.3, 0.5, 1.0);\n\nfloat ground_height = -0.55;\n\nfloat Brightness = 0.2; \n\n//more steps you take more accurate will be the results\n// less steps color gets fadded\nconst int maxSteps = 10;\n\nfloat sphereRadius = 0.15;\n\n//min considerable distance to break marching \nfloat epsilon = 0.01;\n\n\n//returns distance of point p from sphere of given radius \nfloat distSphere(vec3 p, float radius)\n{\n    //if point is outside the radius it will return +ve\n    // else it will return -ve value\n    return length(p) - radius;\n}\n\n//Standard ray march implementation\nfloat raymarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        //pick a point p from origin along rayDirection\n        //at distance step t. (addition of 2 vectors)\n        vec3 p = rayOrigin + rayDirection * t; \n        \n        //calculate distance of p from sphere\n        float d = distSphere(p, sphereRadius);\n        \n        \n        //increment the step value by distance\n        t += d;\n        \n        //if we are close enough to target pixel. break\n        if(d < epsilon)\n        {\n            break;\n        }\n    }\n    return t;\n}\n\n//Function returns the sky shade besed on uv.y \nvec4 DrawSky(vec2 uv)\n{\n    vec4 color = vec4(0.0, 0.0, 0.3, 1.0);\n    // above 0 is sky below is ground\n    if(uv.y > ground_height)\n    {\n        //adding gradient by adding uv.y value.\n        color = SkyColor + (-uv.y * Brightness); //multiply by brightness\n        \n        //if brightness is high, change in y will be more giving bright color\n    }\n    \n    return color;\n}\n\n//Function responsible for road color\nfloat road( vec3 p )\n{ \n    // draw black for x in range of [-2,2] else draw gray\n    float road =  abs(p.x) < 2.0 ? 0.1 : 0.25;\n    \n    // alternator for strip 1 if z is divisible by 2 else 0\n    float i = mod(floor(p.z),2.0) < 1.0 ? 1.0 : 0.0;\n    \n    //strin is narrower than road \n    float strips =  (abs(p.x) < 0.1) ? 0.25*i : 0.0;\n    \n    return road + strips;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //map uv in 0-1 range\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //shift uv to -1 to 1 range\n    uv = uv * 2.0 - 1.0;\n    //correct aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //screen goes from 0 to 1 in x and y\n    // eye (camera) is at center\n    vec3 eye   = vec3(0, 0, -1);\n    \n    //ray vector starts from origin in direction of uv \n    //as uv covers all the pixels on screen thus ray\n    //goes in all direction in +ve z axis. \n    vec3 ray = normalize(vec3(uv + sun_position_shift,1.0));\n    \n    //origin of ray should be eye position\n    vec3 rayOrigin = normalize(eye);\n\n    \n    float t = raymarch(rayOrigin, ray);\n    \n    vec4 sky = vec4(1.0/t) + DrawSky(uv);\n    \n    //magic numbers 1: 0.2 here define the width of distance road\n    //magic numbers 2: 1.8 here define the number of strips on road\n\tvec3 dir = normalize( vec3(uv.x, uv.y+0.2, 1.8));\n    \n    // dividing x and z by y - this make the road narrow as we go up in y \n    // also adding global time in z to make strips move\n    vec3 path = vec3( road(dir.xzz/dir.y + vec3(0.0, 0.0, -iTime*3.0)));\n    \n    //mixing two images\n    vec3 color = mix(path, sky.xyz, exp(-max(-uv.y*20.0 - 5.0,0.0)) );\n    \n    fragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}