{"ver":"0.1","info":{"id":"Wl3BRS","date":"1612898196","viewed":241,"name":"fish in space","username":"YitingLiu","description":"3d fish in the space using capsule 3d shapes. ","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["3d","light","normal","shape","capsule","primitive"],"hasliked":0,"parentid":"wldBD7","parentname":"shapes combo"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//tutorial https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);//never fall outside of A and B\n    vec3 c= a+t*ab;\n    float d = length(p-c)-r;\n    return d;\n    \n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);//never fall outside of A and B\n    \n    vec3 c= a+t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x,y),0.));\n    float i = min(max(x,y),0.);//performance penalty \n    \n    //make it smoother \n    return e+i;\n    \n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x,p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,1.5,6.,1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float cd = sdCapsule(p, vec3(0,1,6), vec3(1,2,6),.2);\n    float cd1 = sdCapsule(p, vec3(0,2,6), vec3(1,2,6),.5);\n    float cd2 = sdCapsule(p, vec3(0,3,6), vec3(1,2,6),.2);\n    float cd3 = sdCapsule(p, vec3(1,2,6), vec3(1.5,2,6),.2);\n   // float td = sdTorus(p-vec3(0,.5,6),vec2(1.5,.25));\n    //float bd = dBox(p-vec3(-2.5,.6,6),vec3(.5));\n   // float cyld = sdCylinder(p, vec3(0,.3,3), vec3(3,1,5),.2);\n\n    \n    float d = min(cd,planeDist);\n    d = min(d,cd1);\n    d = min(d,cd2);\n    d = min(d,cd3);\n    \n   // d= min(d,td);\n   // d= min(d,bd);\n   // d= min(d,cyld);\n    \n    return d; \n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for (int i =0; i<MAX_STEPS; i++){\n        vec3 p = ro+dO*rd;\n        float dS = GetDist(p);\n        dO +=dS;\n        if (dS<SURF_DIST|| dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n   vec2 e = vec2(.01,0.);\n   float d = GetDist(p);\n   vec3 n = d-vec3(\n           GetDist(p-e.xyy),\n           GetDist(p-e.yxy),\n           GetDist(p-e.yyx));\n   return normalize(n);\n}\n\nfloat GetLight (vec3 p){\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    \n    vec3 l = normalize (lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n   \n    if (d<length(lightPos-p)) dif*=.1;\n     \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(abs(sin(iTime)),2.,0.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.5));\n    \n    float d = RayMarch(ro,rd);\n\n    vec3 p = ro+rd*d;\n    \n    //get diffused light     \n    float dif = GetLight(p);\n    float colDif = 0.5*abs(sin(iTime));\n   \n    col=vec3(colDif,dif/colDif,clamp(dif,0.5,0.8));\n    vec3 t= texture(iChannel0, uv*3.*abs(sin(iTime*0.05))).rgb;    \n    col*=GetNormal(p);\n     col/=GetNormal(p)*t;\n   \n    //col+=t;\n\n    fragColor = vec4(col,1.);\n}\n\n\n","name":"Image","description":"","type":"image"}]}