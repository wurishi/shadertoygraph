{"ver":"0.1","info":{"id":"wtd3W4","date":"1577193330","viewed":214,"name":"calm_night","username":"skaplun","description":"The 'clouds' noise may be precomputed in buffer A. It should speed up the raymarching.\nLooks much better with AA and blur enabled.\nMerry Christmas!","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","sdf","bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define BLURRED_GLOW\n//blur the glow and present\n\nfloat normpdf(in float x, in float sigma){\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#ifdef BLURRED_GLOW\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\tfragColor = vec4(c, 1.0);\n\n    //declare stuff\n    const int mSize = 12;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 5.;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j){\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j){\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i){\n        for (int j=-kSize; j <= kSize; ++j){\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    fragColor = texture(iChannel1, fragCoord.xy/iResolution.xy);\n    fragColor.rgb += final_colour/(Z*Z) * (1. - fragColor.a);\n#else\n    fragColor = texture(iChannel1, fragCoord.xy/iResolution.xy);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opExtrussion(in vec3 p, in float sdf, in float h){\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y), 0.0) + length(max(w,0.0));\n}\n\nvec2 opMin(vec2 a, vec2 b){\n\tif(a.x < b.x) return a; else return b;\n}\n\n// signed distance to a 5-star\nfloat sdStar(in vec2 p, in float r, in float rf){\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n\n    // repeat domain 5x\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    \n    // draw triangle\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n\tfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdMoon(in vec2 p){\n\treturn opSubtraction(length(p - vec2(.15, .075)) - .3,\n                         length(p) - .35);\n}\n\nfloat moon3D(vec3 p){\n\treturn opExtrussion(p, sdMoon(p.xz), .02);\n}\nfloat star3D(vec3 p){\n\treturn opExtrussion(p, sdStar(p.xz, .05, .5), .02);\n}\n\n\nvec2 hash(in vec2 x, float modulo){\n    // Needs to coincide with the wrap multiple (24, in this case) in the \"world\" function.\n    x = mod(x, modulo); \n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noised(in vec2 p, float modulo){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    \n    vec2 ga = hash( i + vec2(0.0,0.0), modulo );\n    vec2 gb = hash( i + vec2(1.0,0.0), modulo );\n    vec2 gc = hash( i + vec2(0.0,1.0), modulo );\n    vec2 gd = hash( i + vec2(1.0,1.0), modulo );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return (va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd));\n}\n\nfloat remappedNoise(in vec2 p, float modulo){\n\treturn .5 + .5 * (noised(p, modulo)/.325);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve with endpoint extension\nvec3 SDBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec2 t = clamp(solveCubic(k.x, k.y, k.z).xy, 0.0, 1.0);\n    // note: 3rd root is actually unnecessary, it's never closest!\n    \n    // [Tom'2017] simplified calculations\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n   \n    // Find closest distance and t\n    vec2 r = (d1 < d2) ? vec2(d1, t.x) : vec2(d2, t.y);\n   \n    // Find on which side (t=0 or t=1) is extension\n    vec2 e = vec2(step(0.,-r.y),step(1.,r.y));\n\n    // Calc. gradient\n    vec2 g = 2.*b*r.y + c;\n   \n    // Calc. extension to t\n    float et = (e.x*dot(-d,g) + e.y*dot(p-C,g))/dot(g,g);\n   \n    // Find closest point on curve with extension\n    vec2 dp = d + (c + b*r.y)*r.y + et*g;\n   \n    // Sign is just cross product with gradient\n    float s =  sign(g.x*dp.y - g.y*dp.x);\n   \n    return vec3(sqrt(r.x), s*length(dp), r.y + et);\n}\n\nfloat shape(in vec2 uv){\n    float result = 1e10;\n    {\n        vec3 db = SDBezier(vec2(.42, -.1), vec2(.45, -.09), vec2(.55, -.11), uv);\n        result = db.x - (.09 + db.z * .01);\n        db = SDBezier(vec2(.55, -.11), vec2(.75, -.2), vec2(.79, .13), uv);\n        result = min(result, db.x - (.1 - pow(abs(db.z) * .05, 1.)));\n        db = SDBezier(vec2(.65, -.11), vec2(.8, -.1), vec2(.91, -.16), uv);\n        result = smin(result, db.x - (.1 - abs(db.z) * .075), .033);\n        db = SDBezier(vec2(.91, -.16), vec2(.85, -.2), vec2(.7, -.36), uv);\n        result = smin(result, db.x - (.04 - abs(db.z) * .03), .05);\n        db = SDBezier(vec2(.42, -.1), vec2(.5, -.25), vec2(.31, -.24), uv);\n        result = smin(result, db.x - (.05 - abs(db.z) * .02), .06);\n        db = SDBezier(vec2(.31, -.24), vec2(.25, -.35), vec2(.15, -.4), uv);\n        result = smin(result, db.x - (.03 - abs(db.z) * .02), .03);\n        db = SDBezier(vec2(.55, -.11), vec2(.75, -.2), vec2(.79, .13), uv);\n        result = min(result, db.x - (.1 - pow(abs(db.z) * .05, 1.)));\n        db = SDBezier(vec2(.42, -.1), vec2(.35, -.02), vec2(.3, -.11), uv);\n        result = smin(result, db.x - .03, .02);\n        db = SDBezier(vec2(.79, .13), vec2(.85, .1), vec2(.9, .09), uv);\n        result = smin(result, db.x - (.05 - abs(db.z) * .033), .02);\n        db = SDBezier(vec2(.79, .13), vec2(.75, .15), vec2(.7, .2), uv);\n        result = smin(result, db.x - (.025 - pow(distance(db.z, .6), 1.5) * .075), .02);\n        db = SDBezier(vec2(.84, .13), vec2(.75, .15), vec2(.875, .3), uv);\n        result = min(result, db.x - (.025 - abs(db.z) * .015));\n        db = SDBezier(vec2(.84, .25), vec2(.82, .29), vec2(.82, .3), uv);\n        result = smin(result, db.x - (.01 - abs(db.z) * .0075), .01);\n        db = SDBezier(vec2(.84, .26), vec2(.875, .26), vec2(.88, .265), uv);\n        result = smin(result, db.x - (.01 - abs(db.z) * .0075), .01);\n        db = SDBezier(vec2(.81, .21), vec2(.78, .22), vec2(.78, .27), uv);\n        result = smin(result, db.x - (.01 - abs(db.z) * .005), .025);\n        db = SDBezier(vec2(.81, .19), vec2(.83, .22), vec2(.87, .21), uv);\n        result = smin(result, db.x - (.01 - abs(db.z) * .005), .025);\n        db = SDBezier(vec2(.42, -.08), vec2(0., -.09), vec2(-.25, .05), uv);\n        result = min(result, db.x - .0125);\n        \n        \n        db = SDBezier(vec2(-.85, -.4), vec2(-.5, -.45), vec2(-.15, -.43), uv);\n        result = min(result, db.x - .02);\n        db = SDBezier(vec2(-.15, -.43), vec2(-.025, -.4), vec2(-.04, -.28), uv);\n        result = min(result, db.x - .02);\n        db = SDBezier(vec2(-.041, -.28), vec2(-.08, -.21), vec2(-.12, -.27), uv);\n        result = min(result, db.x - .02);\n        \n        db = SDBezier(vec2(-.69, -.42), vec2(-.69, -.35), vec2(-.69, -.3), uv);\n        result = min(result, db.x - .02);\n        db = SDBezier(vec2(-.3, -.42), vec2(-.3, -.35), vec2(-.3, -.3), uv);\n        result = min(result, db.x - .02);\n        \n        db = SDBezier(vec2(-.725, -.325), vec2(-.69, -.35), vec2(-.65, -.325), uv);\n        result = min(result, db.x - .025);\n        db = SDBezier(vec2(-.325, -.34), vec2(-.29, -.35), vec2(-.27, -.34), uv);\n        result = min(result, db.x - .025);\n        \n        db = SDBezier(vec2(-.725, -.24), vec2(-.29, -.25), vec2(-.25, -.26), uv);\n        result = min(result, db.x - .09);\n        \n        db = SDBezier(vec2(-.75, -.24), vec2(-.69, 0.01), vec2(-.85, .02), uv);\n        result = smin(result, db.x - .025, .05);\n        \n        db = SDBezier(vec2(-.85, .02), vec2(-.91, -.01), vec2(-.9, -.075), uv);\n        result = smin(result, db.x - .025, .02);\n        result = smin(result, distance(uv, vec2(-.85, -.09)) - .06, .025);\n        \n        db = SDBezier(vec2(-.35, -.15), vec2(-.13, -.2), vec2(-.17, -.06), uv);\n        result = smin(result, db.x - .025, .03);\n        result = smin(result, distance(uv, vec2(-.22, -.06)) - .04, .05);\n        \n        db = SDBezier(vec2(-.7, .1), vec2(-.65, -.11), vec2(-.45, -.07), uv);\n        result = min(result, db.x - .125);\n        \n        db = SDBezier(vec2(-.7, .11), vec2(-.8, .25), vec2(-.86, .13), uv);\n        result = min(result, db.x - .125);\n        \n        db = SDBezier(vec2(-.92, .2), vec2(-.98, .25), vec2(-1.02, .28), uv);\n        result = min(result, db.x - (.033 - pow(distance(db.z, .6), 1.5) * .075));\n        \n        db = SDBezier(vec2(-.92, .2), vec2(-.99, .24), vec2(-1.04, .15), uv);\n        result = min(result, db.x - (.03 - pow(distance(db.z, .6), 1.5) * .1));\n        \n        db = SDBezier(vec2(-.92, .15), vec2(-.99, .15), vec2(-1.02, .1), uv);\n        result = min(result, db.x - (.03 - db.z * .01));\n        \n        db = SDBezier(vec2(-.52, -.07), vec2(-.45, .11), vec2(-.52, .285), uv);\n        result = smin(result, db.x - (.125 - abs(db.z) * .075), .075);\n        \n        db = SDBezier(vec2(-.52, .28), vec2(-.65, .32), vec2(-.67, .4), uv);\n        result = smin(result, db.x - (.05 - abs(db.z) * .04), .02);\n        result = smin(result, distance(uv, vec2(-.67, .43)) - .025, .01);\n        result = smin(result, distance(uv, vec2(-.44, .235)) - .025, .01);\n        result = smin(result, distance(uv, vec2(-.425, .2)) - .0125, .01);\n        result = smin(result, distance(uv, vec2(-.562, .232)) - .015, .01);\n        \n        db = SDBezier(vec2(-.52, .08), vec2(-.35, .02), vec2(-.24, .05), uv);\n        result = min(result, db.x - (.075 - abs(db.z) * .06));\n        result = smin(result, distance(uv, vec2(-.24, .05)) - .025, .05);\n    }\n    \n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (iFrame > 1) discard;\n    fragColor -= fragColor;\n    \n    vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    fragColor.x = shape(uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define BIG_FLOAT 1e5\n#define r(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nconst vec3 POS_MOON = vec3(.5, .09, -.7);\n\nfloat sdCylinder(vec3 p, float c){\n  return length(p.xz)-c;\n}\n\nconst float PI = acos(-1.);\nconst float TAU = PI * 2.;\nvec2 sceneSDF(in vec3 p, in bool clouds, in bool lights, in bool santa) {\n    vec2 res = vec2(BIG_FLOAT);\n    \n    if(clouds){\n        float time = iTime * .1;\n        float i = floor(clamp(abs(p.y), 0., .12)/.02);\n        float ang = atan(p.z, p.x)/TAU + .5;\n        float l = length(p.xz);\n        float baseRad = (.75 - i * .05) * .5;\n        //ang += smoothstep(baseRad, .25, l + i * .37) * .25;\n        //ang += remappedNoise(vec2(ang * 5., l + i * .71), 5.) * .25;// * smoothstep(baseRad, .25, l);\n        float noiseFreq = 12. - i * 1.;\n        float noisedRad = baseRad\n            \t\t\t+ remappedNoise(vec2(ang * noiseFreq + (i+1.) * 2.73, time), noiseFreq) * (.25 - i * .01);\n        res = opMin(res,\n                    vec2(opSubtraction(sdCylinder(p, noisedRad),\n                                       p.y + i * .02), floor(abs(p.y)/.02)));\n        res = opMin(res, vec2(p.y + .12, 6.));\n    }\n\n    if(lights){\n        float l = 1e10;\n        l = min(l, moon3D(p * 2.5 + POS_MOON));\n        l = min(l, star3D(p + vec3(-.3, .03, -.3)));\n        l = min(l, star3D(p * 2. + vec3(-.1, .11, -.8)));\n        l = min(l, star3D(p * 1.75 + vec3(-.2, .11, -.4)));\n        l = min(l, star3D(p * 1.5 + vec3(.6, .03, .3)));\n        l = min(l, star3D(p * 1.25 + vec3(.3, .12, .3)));\n        l = min(l, star3D(p * 1.66 + vec3(.5, .16, .1)));\n\n        res = opMin(res, vec2(l, 7.));\n    }\n    \n    if(santa){\n        float a = radians(20.);\n        vec2 rmpd = p.xz*mat2(cos(a), -sin(a), sin(a), cos(a)) * iResolution.xx/iResolution.xy * vec2(-.8, .8);\n    \tfloat santa = texture(iChannel0, rmpd + vec2(.675, .6)).x;\n        res = opMin(res,\n                    vec2(opExtrussion(p + vec3(0., .04, 0.), santa, .02), 5.));\n    }\n\t\n    return res;\n}\n\nvec2 sceneSDF(in vec3 p){\n\treturn sceneSDF(p, true, true, true);\n}\n\nfloat distToLight(in vec3 p){\n\treturn sceneSDF(p, false, true, false).x;\n}\n\nconst float epsilon = 0.00001;\nvec3 calculateNormals(vec3 pos){\n    vec2 eps = vec2(0.0, epsilon);\n    vec3 n = normalize(vec3(\n    sceneSDF(pos + eps.yxx).x - sceneSDF(pos - eps.yxx).x,\n    sceneSDF(pos + eps.xyx).x - sceneSDF(pos - eps.xyx).x,\n    sceneSDF(pos + eps.xxy).x - sceneSDF(pos - eps.xxy).x));\n    return n;\n}\n\nconst int stepsCnt = 25;\nvec2 castRay(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float stepSize = (end - start)/float(stepsCnt);\n    float t = start;\n    for(int i = 0; i <= stepsCnt; i++){\n        vec3 p = eye + marchingDirection * t;\n        vec2 hit = sceneSDF(p);\n        \n        if(hit.x < stepSize)\n            return vec2(t, hit.y);\n        \n        t += stepSize;\n    }\n    return vec2(-1.);\n}\n\n#define ZERO (min(iFrame,0))\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.015 + 0.05 * float(i)/5.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = sceneSDF(aopos, true, false, true).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.-3.*occ, 0., 1.)*(.5+.5*nor.y);\n}\n\nvec3 colors[8] = vec3[8](\n    vec3(1.), vec3(239., 244., 247.)/255., vec3(108., 190., 240.)/255., vec3(65., 150., 231.)/255.,\n    vec3(15., 75., 137.)/255., vec3(22., 59., 104.)/255., vec3(30., 38., 57.)/255., vec3(254., 234., 136.)/255.);\n\nvec4 render(in vec3 ro, in vec3 rd){\n    vec3 col = vec3(0.);\n    float minD = ( .0 - ro.y)/rd.y;\n    float maxD = (-.121 - ro.y)/rd.y;\n    \n    vec2 res = castRay( ro, rd, minD, maxD );\n    if(res.y >= 0.){\n        vec3 clr = colors[int(res.y)];\n        float t = res.x;\n        vec3 p = ro + t * rd;\n        vec3 normal = calculateNormals(p);\t\n        if(res.y != 7. && dot(vec3(0., 1., 0.), normal) != 0.)\n        \tclr *= max(calcAO(p, normal), .8);\n        \n        float glow = res.y == 7. ? 1. : 0.;\n        return vec4(clr, glow);\n    }\n\treturn vec4(0.);\n}\n\nvec4 color(in vec2 fragCoord){\n\tfloat mousePos = iMouse.y/iResolution.y;\n    vec3 eye = vec3(0., 2., 0.);\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., 0., 0.), vec3(0., 0., 1.)) * viewDir;\n    return render(eye, worldDir);\n}\n\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += clamp(color(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    fragColor /= float(AA * AA);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//glow\nconst vec3 lightClr = vec3(54., 100., 150.)/255.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 t = texture(iChannel0, fragCoord/iResolution.xy);\n    vec3 color = vec3(0.);//t.rgb;\n    for(int i=0; i<5; i++){\n    \tvec4 light = texture(iChannel0, fragCoord/iResolution.xy, float(i));\n        color += lightClr * light.a * (1. - t.a) * 2.5;\n    }\n    fragColor = vec4(color, 1.);\n}","name":"Buf C","description":"","type":"buffer"}]}