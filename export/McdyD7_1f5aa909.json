{"ver":"0.1","info":{"id":"McdyD7","date":"1730779289","viewed":69,"name":"Pendulum Physics v0","username":"8InfinityTaco8","description":"I added Physics to the Pendulum\n\n\nyou can use your mouse to swing the pendulum and even spinn it","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["education","physics","pendulum","multipass"],"hasliked":0,"parentid":"Xc3yWH","parentname":"Pendulum Test"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Use the mouse to grab and throw the pendulum\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 center = vec2(0.0, 0.5); //centered with correct UV scaling\n    \n    // Get pendulum state from Buffer A\n    vec4 state = texture(iChannel0, vec2(0));\n    float angle = state.x;\n    \n    // Calculate pendulum positions\n    float pendulumLength = 0.8;\n    vec2 joint1 = center; // Fixed pivot point\n    vec2 joint2 = joint1 + vec2(pendulumLength * sin(angle), -pendulumLength * cos(angle)); // Bob position\n    \n    // Drawing parameters\n    vec3 color = vec3(0.0);  // Background color\n    float radius = 0.06;     // Joint radius\n    float lineThickness = 0.02;\n\n    // Calculate distances for drawing\n    float distanceToJoint1 = length(uv - joint1);\n    float distanceToJoint2 = length(uv - joint2);\n    \n    // Draw line between the joints\n    float line = 0.0;\n    vec2 lineDir = normalize(joint2 - joint1);\n    vec2 pointOnLine = joint1 + lineDir * clamp(dot(uv - joint1, lineDir), 0.0, length(joint2 - joint1));\n    float distanceToLine = length(uv - pointOnLine);\n\n    // Set the line if it's within the thickness and not over the joints\n    if (distanceToLine < lineThickness && distanceToJoint1 >= radius && distanceToJoint2 >= radius) {\n        line = 1.0;\n    }\n    \n    // Combine colors based on distances to joints and line\n    if (line > 0.0) {\n        color = vec3(0.8, 0.1, 0.1); // Red line\n    } else if (distanceToJoint1 < radius) {\n        color = vec3(0.1, 0.1, 0.8); // Blue pivot\n    } else if (distanceToJoint2 < radius) {\n        color = vec3(0.1, 0.8, 0.1); // Green bob\n    }\n\n    fragColor = vec4(color, 1.0); // Set the fragment color\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Only compute physics in the first pixel\n    if (fragCoord.x >= 1.0 || fragCoord.y >= 1.0) {\n        discard;\n        return;\n    }\n    \n    // Load previous state\n    vec4 state = texture(iChannel0, vec2(0));\n    float angle = state.x;\n    float angularVelocity = state.y;\n    float wasMouseHeld = state.z;\n    \n    // Convert mouse position to same coordinate space as pendulum\n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 center = vec2(0.0, 0.5);\n    \n    // Physics parameters\n    float g = 9.81;\n    float pendulumLength = 0.4;\n    float dampening = 0.995;\n    float dt = 0.016;\n    \n    bool isMouseHeld = iMouse.z > 0.0;\n    \n    if (isMouseHeld) {\n        // When mouse is held, calculate angle from mouse position\n        vec2 mouseVec = mouse - center;\n        angle = atan(mouseVec.x, -mouseVec.y);\n        \n        // Calculate new velocity based on angle change\n        if (wasMouseHeld > 0.5) {\n            angularVelocity = (angle - state.x) / dt;\n        } else {\n            angularVelocity = 0.0;\n        }\n    } else {\n        // When mouse is released, apply physics\n        float angularAccel = -(g/pendulumLength) * sin(angle);\n        angularVelocity += angularAccel * dt;\n        angularVelocity *= dampening;\n        angle += angularVelocity * dt;\n    }\n    \n    // Store state in buffer\n    // x: current angle\n    // y: angular velocity\n    // z: mouse held state\n    // w: unused\n    fragColor = vec4(angle, angularVelocity, isMouseHeld ? 1.0 : 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}