{"ver":"0.1","info":{"id":"tdtSz7","date":"1571714587","viewed":543,"name":"2D SDF Shadows Experiment","username":"FarghaS","description":"Experiment with signed distance fields and shadow casting in a 2D space","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SampleSDF(vec2 SceneCoords)\n{\n    ///////////////////////////\n    // CREATE THE SCENE HERE //\n    ///////////////////////////\n    \n    // COORDINATES //\n    float Tiling = 300.0;\n    float BorderWidth = 50.0;\n    \n    vec2 Resolution = iResolution.xy - vec2(BorderWidth*2.0);\n    vec2 ColumnsAmount = floor(Resolution/Tiling);\n    vec2 ColumnsTiling = Resolution/ColumnsAmount;\n    \n    vec2 Coords = TranslateCoords(SceneCoords, vec2(BorderWidth));\n    vec2 ColumnsCoords = TileCoords(Coords, vec2(ColumnsTiling.x, ColumnsTiling.y));\n    ColumnsCoords = TranslateCoords(ColumnsCoords, vec2(ColumnsTiling.x/2.0, ColumnsTiling.y/2.0));\n\n    \n    // SHAPES //\n    float BorderSDF = BorderSDF(RectSDF(TranslateCoords(SceneCoords, vec2(iResolution.x/2.0, iResolution.y/2.0)), vec2(iResolution.x/2.0, iResolution.y/2.0)), BorderWidth);\n    float ColumnsSDF = CircleSDF(ColumnsCoords, 50.0);\n    \n    \n    // DISTANCE MERGE //\n    float dist = MergeSDF(BorderSDF, ColumnsSDF);\n    //dist = ColumnsSDF;\n    \n    return dist;\n    \n}\n\n// Lighting functions\nfloat CalculateShadows(vec2 position, vec2 lightPosition, float ShadowSize)\n{\n    vec2 direction = normalize(lightPosition - position);\n    float Lightdistance = length(lightPosition - position);\n    \n    float rayProgress = 0.0;\n    float shadow = 999.0;\n    for(int i = 0; i < 32; i++)\n    {\n        float sceneDist = SampleSDF(position + direction * rayProgress);\n        \n        if (sceneDist <= 0.0)\n        {\n            return 0.0;\n        }\n        \n        if (rayProgress > Lightdistance)\n        {\n            return clamp(shadow, 0.0, 1.0);\n        }\n        \n        shadow = min(shadow, (sceneDist/ShadowSize)/(rayProgress / 200.0));\n        rayProgress = rayProgress + sceneDist;\n    }\n    return 0.0;\n}\n\nfloat CalculateLight(vec2 position, vec2 lightPosition, float LightRadius)\n{\n    float Light = (LightRadius - length(position - lightPosition))/LightRadius;\n    Light = pow(clamp(Light, 0.0, 1.0), 6.0);\n    return Light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float dist = SampleSDF(fragCoord);\n    \n    float outShadows = 1.0;\n    float outLight = 1.0;\n    \n    vec2 LightPosition = iMouse.xy;\n    \n    /*\n    vec2 StartPosition = vec2(200.0, 700.0);\n    vec2 EndPosition = vec2(1700.0, 700.0);\n    LightPosition = mix(StartPosition, EndPosition, (sin(iTime * 0.3) + 1.0) * 0.5);\n\t*/\n    \n    outShadows = CalculateShadows(fragCoord, LightPosition, 10.0);\n    outLight = CalculateLight(fragCoord, LightPosition, 2000.0);\n    \n    // RENDER TO SCREEN //\n    vec4 outShape = SDFRenderShape(dist, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    vec4 outLines = SDFRenderLines(dist, 100.0, 2.0, 2.0, 0.5);\n    vec4 outAO    = SDFRenderAO(dist, 100.0 * (1.0 - outLight) * (1.0 - outShadows), vec3(0.0), 0.2);\n    \n    vec4 ShadowPass = outShape * outAO * (mix(0.7, 1.0, outShadows));\n    vec4 LightPass = vec4(1.0) * outLight;\n    \n    fragColor = LightPass * ShadowPass;\n    //fragColor = vec4(1.0) * outAO;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// SOME BASE COORDINATES AND SIGNED DISTANCE FIELD FUNCTIONS //\n\n\n// Transform coordinates functions\nvec2 TranslateCoords(vec2 samplePosition, vec2 offset)\n{\n    return samplePosition - offset;\n}\n\nvec2 RotateCoords(vec2 samplePosition, float rotation)\n{\n    float angle = rotation * PI * 2.0 * -1.0;\n    float sine, cosine;\n    sine = sin(angle);\n\tcosine = cos(angle);\n\treturn vec2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x);\n}\n\nvec2 ScaleCoords(vec2 samplePosition, float scale)\n{\n    return (samplePosition / scale);\n}\n\n\n// Other Cordinates Manipulation functions\nvec2 MirrorCoords(vec2 position, vec2 center, float rotation)\n{\n    position = TranslateCoords(position, center);\n    position = RotateCoords(position, rotation);\n    position.x = abs(position.x);\n    position = RotateCoords(position, -rotation);\n    position = TranslateCoords(position, -center);\n    return position;\n}\n\nvec2 TileCoords(vec2 position, vec2 period)\n{\n    position = mod(position, period);\n    position = position + period;\n    position = mod(position, period);\n    return position;\n}\n\nvec2 MirrorTileCoords(vec2 position, vec2 period)\n{\n    vec2 new_position = mod(position, period);\n    new_position = position + period;\n    new_position = mod(position, period);\n    \n    vec2 cellIndex = position / (period);\n    vec2 flip = floor(abs(mod(cellIndex, 2.0)));\n    \n    position = mix(new_position, period - new_position, flip);\n    \n    return position;\n}\n\nvec2 WobbleCoords(vec2 position, float size, float amount, float offset)\n{\n    offset = mod(offset, PI * 2.0 * size);\n    vec2 wobble = sin(position.yx / size + offset) * amount;\n    vec2 new_position = position + wobble;\n    return new_position;\n}\n\n\n\n// Shapes SDF functions\nfloat CircleSDF( vec2 samplePosition, float radius )\n{\n    return (length(samplePosition) - radius);\n}\n\nfloat RectSDF(vec2 samplePosition, vec2 halfSize)\n{\n    vec2 componentWiseEdgeDistance = (abs(samplePosition) - halfSize);\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);\n    return outsideDistance + insideDistance;\n}\n\n\n// Simple SDF combine functions\nfloat MergeSDF(float shape1, float shape2)\n{\n\treturn min(shape1, shape2);    \n}\n\nfloat IntersectSDF(float shape1, float shape2)\n{\n    return max(shape1, shape2);\n}\n\nfloat SubtractSDF(float base, float subtraction)\n{\n    return IntersectSDF(base, -subtraction);\n}\n\nfloat InterpolateSDF(float shape1, float shape2, float amount)\n{\n    return mix(shape1, shape2, amount);\n}\n\n\n// Rounded SDF combine functions\nfloat RoundMergeSDF(float shape1, float shape2, float radius)\n{\n    vec2 intersectionSpace = vec2(shape1 - radius, shape2 - radius);\n    intersectionSpace = min(intersectionSpace, 0.0);\n    float insideDistance = -length(intersectionSpace);\n    float simpleUnion = MergeSDF(shape1, shape2);\n    float outsideDistance = max(simpleUnion, radius);\n    return insideDistance + outsideDistance;\n}\n\nfloat RoundIntersectSDF(float shape1, float shape2, float radius)\n{\n    vec2 intersectionSpace = vec2(shape1 + radius, shape2 + radius);\n    intersectionSpace = max(intersectionSpace, 0.0);\n    float insideDistance = length(intersectionSpace);\n    float simpleUnion = IntersectSDF(shape1, shape2);\n    float outsideDistance = min(simpleUnion, -radius);\n    return insideDistance + outsideDistance;\n}\n\nfloat RoundSubtractSDF(float base, float subtraction, float radius)\n{\n\treturn RoundIntersectSDF(base, -subtraction, radius);\n}\n\n\n// Chamfered SDF combine functions\nfloat ChamferMergeSDF(float shape1, float shape2, float chamferSize)\n{\n    const float SQRT_05 = 0.70710678118;\n    float simple_merge = MergeSDF(shape1, shape2);\n    float chamfer = (shape1 + shape2) * SQRT_05;\n    chamfer = chamfer - chamferSize;\n    return MergeSDF(simple_merge, chamfer);\n}\n\nfloat ChamferIntersectSDF(float shape1, float shape2, float chamferSize)\n{\n    const float SQRT_05 = 0.70710678118;\n    float simpleIntersect = IntersectSDF(shape1, shape2);\n    float chamfer = (shape1 + shape2) * SQRT_05;\n    chamfer = chamfer + chamferSize;\n    return IntersectSDF(simpleIntersect, chamfer);\n}\n\nfloat ChamferSubtractSDF(float base, float subtraction, float chamferSize)\n{\n    return ChamferIntersectSDF(base, -subtraction, chamferSize);\n}\n\n\n// SDF Border\nfloat BorderSDF(float shape, float radius)\n{\n\treturn abs(shape) - radius;\n}\n\n\n\n\n// Render functions\nvec4 SDFRenderShape(float dist, vec3 InColor, vec3 OutColor)\n{\n    // Antialiasing\n    float distanceChange = fwidth(dist) * 0.5;\n    float antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist);\n    \n    // Render Shape\n    vec4 outColor = mix(vec4(OutColor, 1.0), vec4(InColor, 1.0), antialiasedCutoff);\n    return outColor;\n}\n\nvec4 SDFRenderLines(float dist, float LineDistance, float LineThickness, float SubLines, float SubLineThickness)\n{\n    float distanceChange = fwidth(dist) * 0.5;\n    \n    float majorLineDistance = abs(fract(dist / LineDistance + 0.5) - 0.5) * LineDistance;\n    float majorLines = smoothstep(LineThickness - distanceChange, LineThickness + distanceChange, majorLineDistance);\n    \n    float distanceBetweenSubLines = LineDistance / SubLines;\n    float subLineDistance = abs(fract(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines;\n    float subLines = smoothstep(SubLineThickness - distanceChange, SubLineThickness + distanceChange, subLineDistance);\n    \n    vec4 outColor = vec4(1.0) * majorLines * subLines;\n    \n    return outColor;\n}\n\nvec4 SDFRenderAO(float dist, float AODistance, vec3 AOColor, float AOPower)\n{\n    // Antialiasing\n    float distanceChange = fwidth(dist) * 0.5;\n    float antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist);\n    \n    // Render AO\n    vec3 outsideColor = mix(AOColor, vec3(1.0), clamp(pow(dist/AODistance, AOPower), 0.0, 1.0));\n    vec4 outColor = mix(vec4(outsideColor, 1.0), vec4(1.0), antialiasedCutoff);\n    return outColor;\n}\n","name":"Common","description":"","type":"common"}]}