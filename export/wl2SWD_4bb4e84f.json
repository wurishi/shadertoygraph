{"ver":"0.1","info":{"id":"wl2SWD","date":"1566183190","viewed":174,"name":"Unfettered","username":"Albeforia","description":".","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GAMMA_FACTOR = 2.2;\n\n/**\n * Gamma correction.\n */\nvec3 linearToGamma(vec3 value, float gammaFactor) {\n\treturn pow(value, vec3(1.0 / gammaFactor));\n}\n\n/**\n * ACES tonemapping.\n */\nvec3 tonemapACES(vec3 x) {\n\tconst float a = 2.51;\n\tconst float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n        \n    //col = tonemapACES(col);\n    \n    fragColor = vec4(linearToGamma(col, GAMMA_FACTOR), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//=======================================================================================\n// Constants\n//=======================================================================================\n\nconst float PI = 3.14159265359;\nconst float\tEPSILON = 0.001;\n\nconst int\tVIEW_RAY_MAX_STEPS = 150;\nconst float VIEW_RAY_MAX_LENGTH = 20.0;\n\n#define CENTER vec3(0.0, 0.5, 1.5)\n\n//=======================================================================================\n// Math\n//=======================================================================================\n\nfloat pow2(float x) {\n\treturn x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n\treturn x2 * x2;\n}\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\n//=======================================================================================\n// Transformations\n// Matrices are column-major and already inverted.\n//=======================================================================================\n\nmat4 rotateX(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat4(1, 0, 0, 0,\n                0, c,-s, 0,\n                0, s, c, 0,\n                0, 0, 0, 1);\n}\n\nmat4 rotateY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(c, 0, s, 0,\n                0, 1, 0, 0,\n                -s,0, c, 0,\n                0, 0, 0, 1);\n}\n\nmat4 rotateZ(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(c,-s, 0, 0,\n                s, c, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n}\n\nmat4 translate(vec3 p) {\n\treturn mat4(1,    0,    0,    0,\n                0,    1,    0,    0,\n                0,    0,    1,    0,\n                -p.x, -p.y, -p.z, 1);\n}\n\n//=======================================================================================\n// Struct Definitions\n//=======================================================================================\n\nstruct sRay {\n    vec3\to;\n    vec3\tdir;\n    float\ttMin;\n    float\ttMax;\n};\n\nstruct sHit {\n    vec3\tp;\n    float\tt;\n    int\t\tmid;\n};\n\n/**\n * Used as the return value of sdScene.\n *\n * d:\t\tthe shortest distance from the a point to the scene surface\n * mid:\t\tmaterial index of the surface that has the shortest distance\n */\nstruct sSceneRec {\n\tfloat\td;\n    int\t\tmid;\n};\n\nstruct sPointLight {\n    vec3    color;\n    vec3    position;\n    float   range;\n    float   decay;\n};\n\n//=======================================================================================\n// Light Definitions\n//=======================================================================================\n\nsPointLight gPointLight0 = sPointLight(\n    5.0*vec3(1.0, 0.3, 0.5),\n    CENTER,\n    5.0, 2.0\n);\n\n//=======================================================================================\n// Scene\n//=======================================================================================\n\n/**\n * Construct the scene here. see sSceneRec.\n *\n * p:\ta point in world space\n */\nsSceneRec sdScene(vec3 p) {\n    vec3 pr = (rotateX(0.5*PI) * vec4(p, 1.0)).xyz;\n    sSceneRec p2 = sSceneRec(pr.y, 0);\n\n    return p2;\n}\n\n/**\n * Estimate the normal at surface point p using the gradient of scene SDF.\n *\n * p:\ta point in world space\n */\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)).d - sdScene(vec3(p.x - EPSILON, p.y, p.z)).d,\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)).d - sdScene(vec3(p.x, p.y - EPSILON, p.z)).d,\n        sdScene(vec3(p.x, p.y, p.z + EPSILON)).d - sdScene(vec3(p.x, p.y, p.z - EPSILON)).d\n    ));\n}\n\n//=======================================================================================\n// Lighting\n//=======================================================================================\n\n/**\n * Calculate the decay factor of a punctual light.\n * ref: three.js - bsdfs.glsl::punctualLightIntensityToIrradianceFactor\n */\nfloat punctualLightDecay(float dist, float cutoff, float decay, float r0) {\n\tif(decay > 0.0) {\n\t\tfloat distanceFalloff = r0 / max(pow(dist, decay), 0.01);\n\t\tfloat maxDistanceCutoffFactor = pow2(saturate(1.0 - pow4(dist / cutoff)));\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n\t}\n\treturn 1.0;\n}\n\n/**\n * Calculate the irradiance(E) of a point light.\n *\n * p:\t\t\ta surface point in world space\n * normal:\t\tsurface normal\n * lightDir:    output direction from p to light position\n */\nvec3 pointLightIrradiance(vec3 p, vec3 normal, sPointLight light,\n                          out vec3 lightDir) {\n    vec3 l = light.position - p;\n\tfloat dist = length(l);\n\tlightDir = l / dist;\n    float dotNL = saturate(dot(normal, lightDir));\n    vec3 lightColor = light.color * punctualLightDecay(dist, light.range, light.decay, 1.0);\n\treturn PI * dotNL * lightColor;\n}\n\n//=======================================================================================\n// Participating Media\n//=======================================================================================\n\nconst float VOL_RAY_MARCHING_STEP = 0.05;\nconst float\tVOL_SHADOW_RAY_MAX_STEPS = 4.0;\n\n#define FOG\t\t0.1\n#define HG_g\t0.5\n\n/**\n * Define the media.\n */\nvoid getMedia(vec3 p, out vec3 sigmaS, out vec3 sigmaT) {\n    float size = min(1.35, 0.1*pow2(exp2(2.5*iTime)));\n    float scale = 20.0/(size+0.01);\n    \n    vec3 dir = (rotateX(0.11*PI)*rotateY(0.25*PI*iTime)*\n                vec4((p - CENTER),1.0)).xyz;\n    float l = length(dir);\n    dir = dir/l;\n    float v = size*texture(iChannel0, 0.5+dir.xy*0.16+dir.yy*0.08).x+0.1;\n    sigmaS = vec3( FOG + v*scale * clamp((v-l)/v,0.0,0.5) ) * abs(dir);\n    \n    sigmaT = sigmaS;\n}\n\n/**\n * Isotropic phase function.\n */\nfloat phaseIsotropic(float cosTheta) {\n\treturn 1.0 / (4.0 * PI);\n}\n\n/**\n * HG phase function.\n */\nfloat phaseHG(float cosTheta, float g) {\n\tfloat tmp = 1.0 + pow2(g) - 2.0 * g * cosTheta;\n\treturn (1.0 - pow2(g)) / (4.0 * PI * tmp * sqrt(tmp));\n}\n\n/**\n * Calculate the transmittance.\n */\nvec3 Tr(vec3 a, vec3 dir, float dist) {    \n    float ds = dist / VOL_SHADOW_RAY_MAX_STEPS;\n    vec3 sigmaS, sigmaT;\n    \n    vec3 tau = vec3(0);\n    for (float i = 0.5; i < VOL_SHADOW_RAY_MAX_STEPS; i += 1.0) {\n        vec3 p = a + (i/VOL_SHADOW_RAY_MAX_STEPS) * dir;\n        getMedia(p, sigmaS, sigmaT);\n\n        tau += sigmaT * ds;\n    }\n    \n    return exp(-tau);\n}\n\n/**\n * Calculate the inscattering from point light.\n */\nvec3 inscatterPointLight(const in sRay ray, vec3 p, float ds,\n                         sPointLight light, out vec3 segmentTr) {\n    vec3 sigmaS, sigmaT;\n    getMedia(p, sigmaS, sigmaT);\n    \n\tfloat distToLight = length(light.position - p);\n    vec3 lightDir = (light.position - p) / distToLight;\n    \n    vec3 trLight = Tr(p, lightDir, distToLight);\n    float phase = phaseHG(dot(-lightDir, -ray.dir), HG_g);\n    vec3 lightColor = light.color *\n        punctualLightDecay(distToLight, light.range, light.decay, 1.0);\n    \n    vec3 S = phase * sigmaS * (trLight * lightColor);\n    \n    // should take the Tr inside the segment into account\n    // ref slide 29: http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n    segmentTr = exp(-sigmaT * ds);\n    return (S - S * segmentTr) / sigmaT;\n}\n\n/**\n * Medium-aware ray marching.\n *\n * inscatter:\taccumulated inscattering along the ray\n */\nbool rayMarchVol(const in sRay ray, out sHit hit, out vec3 inscatter,\n                 out vec3 totalTr,\n                 int maxSteps) {\n    float t = ray.tMin;\n    float ds = VOL_RAY_MARCHING_STEP;\n\n    totalTr = vec3(1.0);\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = ray.o + t * ray.dir;\n        sSceneRec rec = sdScene(p);\n        if (rec.d < EPSILON) {\t// hit something\n            hit.p = p;\n            hit.t = t;\n            hit.mid = rec.mid;\n\t\t\treturn true;\n        }\n        \n        // adjust step size if we are close to surface\n        ds = min(rec.d, VOL_RAY_MARCHING_STEP);\n        \n        // accumulate inscattering\n        vec3 segmentTr;\n        inscatter += totalTr * inscatterPointLight(ray, p, ds, gPointLight0, segmentTr);\n        \n        // accumulate transmittance\n        totalTr *= segmentTr;\n        \n        t += ds;\n        if (t >= ray.tMax) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\n//=======================================================================================\n\nvec3 lit(sHit hp, vec3 viewDir) {\n    vec3 normal = getNormal(hp.p);\n    vec3 pointLightDir;\n    vec3 irradiance = pointLightIrradiance(hp.p, normal, gPointLight0, pointLightDir);\n    return irradiance * vec3(0.5, 0.4, 0.2) / PI;\n}\n\n//=======================================================================================\n// Camera\n//=======================================================================================\n\nmat3 viewMatrix(vec3 eye, vec3 target, vec3 up) {\n    vec3 f = normalize(target - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 cameraRay(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = (size.y / 2.0) / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//=======================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //gPointLight0.color = (3.0+3.0*sin(iTime-0.5*PI))*vec3(1.0, 0.3, 0.5);\n    \n    float fov = 60.0;\n    vec3 eye = vec3(0.0, 0.5, 4.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, CENTER, vec3(0.0, 1.0, 0.0));\n\n    sRay viewRay;\n    viewRay.o = eye;\n    viewRay.tMax = VIEW_RAY_MAX_LENGTH;\n\tviewRay.dir = viewToWorld * cameraRay(fov, iResolution.xy, fragCoord);\n    \n    sHit hit;\n\tvec3 col, inscatter;\n    vec3 totalTr;\n    if (rayMarchVol(viewRay, hit, inscatter, totalTr, VIEW_RAY_MAX_STEPS)) {\n\t\tvec3 surface = lit(hit, -viewRay.dir);\n        col = inscatter + totalTr * surface;\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}