{"ver":"0.1","info":{"id":"XXdXzr","date":"1718534977","viewed":47,"name":"Precision-loss noise gen","username":"xld3","description":"Using a custom noise/dithering function that's very cheap.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","precision","dithering"],"hasliked":0,"parentid":"4XK3DG","parentname":"Ziggy zags"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// mouse x affects rotation and wave dist\n// mouse y affects zoom and wave dist\n\n/*\nprecision-loss noise gen, which behaves more like dithering.\n    \nI had a theory that you could magnify the precision loss of division,\nand it seems to have some practical effect.\n    \n...still trying to figure out *what* that effect is and how to use it.\n    \nsee if you can do something cool with it ;)\n*/\nfloat pnoise(float x, float n) {\n    return x * (1. + fract((x/(x+1e-37)))*n);\n}\n\n// mostly adapted from forked shader\nvoid mainImage(out vec4 o, in vec2 f)\n{\n    vec2 M = ((iMouse.z == 1. || iMouse.x != 0.)?\n        2.*iMouse.xy/iResolution.xy-1. // mouse NDC\n    :vec2(0)); // init mouse to 0,0\n    \n    float T = iTime*.1,\n        N = dot(M,M),\n        A = cos(radians(T * 45.))*4. - M.x, // rotation angle\n        B = sin(A),\n        C = cos(A);\n    \n    f = (2.*f/iResolution.xy-1.); // pixel to NDC\n    \n    f *= mat2(C, B, -B, C) // rotate\n    * (2.+.5*cos(T) // zoom\n    + M.y); // + mouse\n    \n    // add noise to pixel coords\n    f = vec2(pnoise(f.x, .1), pnoise(f.y, .1));\n       \n    float W = T + abs(dot(f,f)*4.) + sin(sin(T)*dot(f,f)*4.), // wave\n        v = sin(3.*W + 9.*N); // black edge wave dist\n        \n    o = vec4((.5+.5*cos(W + N + vec3(0,2,4))) // RGB waves\n        *(smoothstep(1.,-1.,(abs(v)-.5)/fwidth(v) )), // Black edges\n        1. // alpha\n    );\n    \n    // add noise to color channels\n    o = vec4(pnoise(o.x, 10.), pnoise(o.y, 10.), pnoise(o.z, 10.), 1.);\n}","name":"Image","description":"","type":"image"}]}