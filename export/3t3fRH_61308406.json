{"ver":"0.1","info":{"id":"3t3fRH","date":"1612187047","viewed":61,"name":"fork-e#71005.0","username":"jorge2017a1","description":"http://glslsandbox.com/e#71005.0","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["forke710050"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//modificado por jorge2017a1\n//http://glslsandbox.com/e#71005.0\nvec2 surfacePosition;\n\n\n#define EPS 0.001\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat sdBox(vec2 p, vec2 b) \n{\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b) \n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCross(vec3 p, float h) {\n\tvec2 b = vec2(h);\n\tfloat da = sdBox(p.xy, b);\n\tfloat db = sdBox(p.yz, b);\n\tfloat dc = sdBox(p.zx, b);\n\treturn min(da, min(db, dc));\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\nfloat ifsCross(vec3 p) \n{\n\t//float d = 1.0 / 0.0;\n    float d = 99999.9;\n\tfloat h = 3.0;\n\n     \n\tfloat m = floor(mod(iTime, 10.0));\n\tint M = int(min(m, 10.0 - m));\n    \n    \n    //int M =2;\n    \n\tfor (int i = 0; i < 3; i++) {\n\t\tif (i >= M) {\n\t\t\tbreak;\n\t\t}\n\t\tvec3 q = mod(p + h, h * 2.0) - h;\n\t\th /= 3.0;\n\t\td = min(d, sdCross(q, h));\n\t}\n\n    float sd2= sdBox(p, vec3(4.5) ) ;\n    \n    d= differenceSDF( sd2,d);\n\n\treturn d;\n}\n\nfloat map(vec3 p) {\n\tp.yz *= rot(radians(30.0));\n\tp.zx *= rot(iTime * 0.5);\n\tfloat db = sdBox(p, vec3(3));\n\tfloat dc = ifsCross(p);\n//\treturn min(db, dc);\n\treturn max(db, -dc);\n}\n\nvec3 getNormal(vec3 p) {\n\tconst vec2 eps = vec2(EPS, 0);\n\tfloat d = map(p);\n\treturn normalize(vec3(\n\t\tmap(p + eps.stt) - d,\n\t\tmap(p + eps.tst) - d,\n\t\tmap(p + eps.tts) - d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    surfacePosition=uv;\n\tvec3 rd = normalize(vec3(surfacePosition, 1));\n\tvec3 ro = vec3(0, 0, -10);\n\tvec3 light = normalize(vec3(1, 2, -3));\n\tfloat dist = 0.0;\n\tfloat bright = 0.0;\n\n\tfor (int i = 0; i < 100; i++)\n    {\n\t\tvec3 p = ro + rd * dist;\n\t\tfloat d = map(p);\n\t\tif (d < EPS) {\n\t\t\tbright = max(dot(light, getNormal(p)), 0.1);\n\t\t\tbreak;\n\t\t}\n\t\tdist += d;\n\t\tif (dist > 30.0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfragColor = vec4(vec3(2,1,1) * bright, 1);\n}","name":"Image","description":"","type":"image"}]}