{"ver":"0.1","info":{"id":"4cKcW1","date":"1731804244","viewed":82,"name":"circles on parabola touch circle","username":"jt","description":"If the static circle is offset by the radius of the animated bouncing circle, then parabola-circle intersection returns positions where circles touch.\nThanks @mla for [url=https://www.shadertoy.com/view/7dSBWz]depressed quartic solver[/url]!\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["intersection","circle","geometry","quartic","parabola","depressed"],"hasliked":0,"parentid":"7lVfD1","parentname":"Parabola Circle Intersection 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/4cKcW1 circles on parabola touch circle, 2024 by jt\n// https://www.shadertoy.com/view/7lVfD1 Parabola Circle Intersection 2 by jt\n// Apply depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n// to https://www.shadertoy.com/view/NtyfD1 Parabola Circle Intersection by jt\n\n// If the static circle is offset by the radius of the animated bouncing circle,\n// then parabola-circle intersection returns positions where circles touch.\n// This could be used to animate exact collision of a bouncing circle.\n\n// Thanks @mla for depressed quartic solver from https://www.shadertoy.com/view/7dSBWz Cyclides\n\n// tags: intersection, circle, geometry, quartic, parabola, depressed\n\n// Potentially relevant links:\n// https://en.wikipedia.org/wiki/Quartic_function\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf (thanks, mla!)\n// https://www.nickalls.org/dick/papers/maths/quartic2009.pdf\n// https://www.maa.org/press/periodicals/convergence/descartes-method-for-constructing-roots-of-polynomials-with-simple-curves-depressed-quartics-and\n\n// NOTE: For a possible OTHER shader, parabola-parabola intersection, from https://www.geogebra.org/m/X2E9Dzvs \"Intersection of a vertical and horizontal parabola\"\n//       \"The intersection points of a vertical and horizontal parabola lie on a circle whose centre's distance from the directrices is the sum of distances of the foci from the directrices (in both the x and y directions.\"\n\n//#define POINTSIZE 0.01\n#define POINTSIZE (5.0/R.y) // resolution-independent\n#define draw_point(q) o *= smoothstep(0.0, POINTSIZE, abs(q))\n#define draw_circle(r, I) draw_point(length(I) - r)\n#define draw_quadratic(A, B, C, I) draw_point(draw_quadratic_helper(A, B, C, I))\n\n#define draw_point_grey(q) o *= (0.5+0.5*smoothstep(0.0, POINTSIZE, abs(q)))\n#define draw_circle_grey(r, I) draw_point_grey(length(I) - r)\n#define draw_quadratic_grey(A, B, C, I) draw_point_grey(draw_quadratic_helper(A, B, C, I))\n\n\nfloat parabola(float A, float B, float C, float x)\n{\n    return A*x*x+B*x+C;\n}\n\nfloat parabola_derivative(float A, float B, float x) // NOTE: C disappears due by derivative\n{\n    return 2.0*A*x+B;\n}\n\nfloat draw_quadratic_helper(float A, float B, float C, vec2 I)\n{\n    return (parabola(A, B, C, I.x)-I.y)/length(vec2(parabola_derivative(A, B, I.x),-1.0)); // divide by length of the gradient to get a constant width line - thanks, mla!\n}\n\n// START depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\nfloat sgn(float x)\n{\n    return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    float x1,x2;\n    float b = -0.5*B;\n    float q = b*b - A*C;\n    if (q < 0.0) return 0;\n    float r = b + sgn(b)*sqrt(q);\n    x1 = C/r;\n    x2 = r/A;\n    res = vec2(x1,x2);\n    return 2;\n}\n\nvec4 eval(float X, float B, float C, float D) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    float B1 = X+B;\n    float C2 = B1*X+C;\n    float DQ = (X+B1)*X + C2;\n    float Q = C2*X + D;\n\n    return vec4(Q, DQ, B1, C2);\n}\n\nfloat qcubic(float B, float C, float D) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    float X = -B/3.0;\n\n    vec4 e = eval(X,B,C,D);\n\n    float r = pow(abs(e.x),1.0/3.0);\n    if (-e.y > 0.0) r = 1.324718*max(r,sqrt(-e.y)); // NOTE: Is 1.324718 here the https://en.wikipedia.org/wiki/Plastic_ratio ?\n    float x0 = X - (e.x < 0.0 ? -r : +r);\n    if (x0 != X)\n    {\n        X = x0;\n        for (int i = 0; i < 4; i++)\n        {\n            e = eval(X,B,C,D);\n            if (e.y == 0.0) break;\n            X -= e.x/e.y;\n        }\n\n        if (X*X > abs(D/X))\n        {\n            e.w = -D/X;\n            e.z = (e.w - C)/X;\n        }\n    }\n\n    vec2 res;\n    if (quadratic(1.0,e.z,e.w,res) == 0) return X;\n\n    X = max(X,res[0]);\n    X = max(X,res[1]);\n\n    return X;\n}\n\nint biquadratic(float p, float r, out vec4 res) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    // Solve x^4 + px^2 + r = 0 (ie. a quadratic equation in x^2)\n    vec2 t;\n    if (quadratic(1.0,p,r,t) == 0) return 0;\n    int n = 0;\n    for (int i = 0; i < 2; i++)\n    {\n        if (t[i] >= 0.0)\n        {\n            float x = sqrt(t[i]);\n            res[n++] = -x;\n            res[n++] = x;\n        }\n    }\n    return n;\n}\n\n// Descartes solver for depressed quartics\n// ie. x^4 + px^2 + qx + r = 0\nint dquartic(float p, float q, float r, out vec4 res) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    if (abs(q) < 0.001) return biquadratic(p,r,res);\n    float A = 2.0*p;\n    float B = p*p-4.0*r;\n    float C = -q*q;\n    float U = qcubic(A,B,C);\n    //assert(U >= 0.0);\n    float u = sqrt(U);\n    float s = -u;\n    float t = 0.5*(p+U+q/u);\n    float v = 0.5*(p+U-q/u);\n    int n1 = quadratic(1.0,s,t,res.xy);\n    int n2 = quadratic(1.0,u,v,res.zw);\n    if (n1 == 0) res.xy = res.zw;\n    return n1+n2;\n}\n\n// END depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n\nvoid mainImage(out vec4 o, vec2 I)\n{\n    vec2 R = iResolution.xy;\n    I = (I+I-R)/R.y;\n\n    o = vec4(1);\n\n    float r0 = 0.1; // radius of moving circle\n\n    float d = mix(0.9, 0.75, cos(iTime/2.0) * 0.5 + 0.5);\n    draw_point(length(I) - d); // circle\n    d += r0;\n    draw_point_grey(length(I) - d); // circle\n\n    float x0 = cos(iTime * 0.2) * d * mix(0.5, 1.0, cos(iTime/3.0) * 0.5 + 0.5);\n    float y0 = sin(iTime * 0.2) * d * mix(-1.5, 0.5, cos(iTime) * 0.5 + 0.5);\n\n    float s = mix(0.2, 2.0, cos(iTime) * 0.5 + 0.5); // scale parabola\n\n    // y = ((x - x0)/s)^2 + y0 by solving x = s*t + x0 for t then plugging into y = t*t + y0\n    // y = x^2/s^2 - 2*x*x0/s^2 + x0^2/s^2 + y0\n    // y = A * x^2 + B * x + C\n    float A = 1.0/(s*s), B = -2.0*x0/(s*s), C = x0*x0/(s*s)+y0;\n    draw_quadratic_grey(A, B, C, I);\n\n    // x = s*t + x0\n    // y = t*t + y0\n    // d^2 = x*x+y*y\n    // d^2 = (s*t+x0)^2 + (t^2+y0)^2\n    // d^2 = s^2*t^2 + 2*s*t*x0 + x0^2 + t^4 + 2*t^2*y0 + y0^2\n    // 0 = t^4 + t^2*(s^2+2*y0) + 2*s*t*x0 + (x0^2+y0^2-d^2)\n    // 0 = t^4 + p * t^2 + q * t + r\n    float p = s*s+2.0*y0;\n    float q = 2.0*s*x0;\n    float r = x0*x0+y0*y0-d*d;\n\n    vec4 roots;\n    int n = dquartic(p, q, r, roots);\n\n    for(int i = 0; i < n; i++)\n    {\n        draw_circle_grey(0.025, I - vec2(s*roots[i]+x0, roots[i]*roots[i]+y0));\n        draw_circle(r0, I - vec2(s*roots[i]+x0, roots[i]*roots[i]+y0));\n    }\n\n    //float t = (fract(iTime/5.0)*2.0-1.0)*2.0;\n    //draw_circle(r0, I - vec2(t,A*t*t+B*t+C));\n}\n","name":"Image","description":"","type":"image"}]}