{"ver":"0.1","info":{"id":"MlKGDV","date":"1476964121","viewed":235,"name":"Memory & Input System","username":"sephirot47","description":"A memory and input system to use in your shaders :D","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["buffer","input","memory"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////\n// Image buffer ////////////////\n////////////////////////////////\n\n/////////////////////////////////////\n// W,A,S,D and ARROW_KEYS for moving\n/////////////////////////////////////\n\n// Channel defines\n#define MEMORY_CHANNEL               iChannel0\n////////////////////////////////\n\n// Memory functions\nvec4 READ(vec2 id) { return texture(MEMORY_CHANNEL, id); }\n////////////////////////////////\n\n// Memory variables ids\nconst vec2 ID_playerPosLeft  = vec2(0.2, 0.1);\nconst vec2 ID_playerPosRight = vec2(0.2, 0.11);\n////////////////////////////////\n\n// Structs and forward declarations\nstruct Player { vec2 pos; bool left; };\nvoid player_init(inout Player player);\nvoid player_draw(in Player p);\n\nstruct Rect { vec2 pos; vec2 size; };\nbool rect_pointInside(in Rect r, in vec2 p);\n////////////////////////////////\n\n// Global variables\nvec2 pixelUv;\nvec4 finalColor;\nPlayer playerLeft, playerRight;\n////////////////////////////////\n\n// Functions - Player\nvoid player_init(inout Player player)\n{\n    vec2 ID_pos = player.left ? ID_playerPosLeft : ID_playerPosRight;\n    player.pos = READ(ID_pos).xy;\n}\nvoid player_draw(in Player p)\n{\n    Rect boundingRect = Rect(vec2(p.pos.x, p.pos.y), vec2(0.05, 0.2));\n    if (rect_pointInside(boundingRect, pixelUv))\n    {\n        finalColor = p.left ? vec4(1,0,0,1) : vec4(0,1,0,1);\n    }\n}\n////////////////////////////////\n\n// Functions - Rect\nbool rect_pointInside(in Rect r, in vec2 p)\n{\n    return p.x >= r.pos.x && p.y >= r.pos.y &&\n           p.x <= r.pos.x + r.size.x && p.y <= r.pos.y + r.size.y;\n}\n////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    pixelUv = fragCoord.xy / iResolution.xy;\n\n    // Read variables\n    playerLeft.left = true;  playerRight.left = false;\n    player_init(playerLeft); player_init(playerRight);\n    //\n\n\n    // Draw stuff\n    finalColor = vec4(0, 0, 0, 1); // Background color\n    player_draw(playerLeft);\n    player_draw(playerRight);\n    //\n\n    fragColor = finalColor;\n    // See memory buffer: \n    // fragColor = texture(MEMORY_CHANNEL, pixelUv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////////\n// Memory BUFFER ///////////////\n////////////////////////////////\n\n// Channel defines\n#define MEMORY_CHANNEL                iChannel0\n#define INPUT_CHANNEL                 iChannel1\n#define PREVIOUS_FRAME_INPUT_CHANNEL  iChannel2\n////////////////////////////////\n\n// Game defines\nconst float playerVelocity = 0.025;\n//\n\n// Memory variables id\nconst vec2 ID_playerPosLeft  = vec2(0.1, 0.1);\nconst vec2 ID_playerPosRight = vec2(0.1, 0.2);\n////////////////////////////////\n\n// Structs and forward declarations\nstruct Player { vec2 pos; bool left; };\nvoid player_init(inout Player player);\nvoid player_writeToMemory(inout Player player);\n////////////////////////////////\n\n// Global variables\nvec2 fragCoordinate;\nvec4 finalColor;\nPlayer playerLeft  = Player(vec2(0.05,  0.5), true);\nPlayer playerRight = Player(vec2(0.9,  0.5), false);\n////////////////////////////////\n\n// Memory functions\n#define FRAG_UV (fragCoordinate.xy / iResolution.xy)\nvec4 READ(vec2 id) { return texture(MEMORY_CHANNEL, id); }\nvoid WRITE(vec2 id, vec4 value) { if (distance(FRAG_UV, id) < 0.005) { finalColor = value; } }\n////////////////////////////////\n\n// Functions - Player\nvoid player_init(inout Player player)\n{\n    vec2 ID_pos = player.left ? ID_playerPosLeft : ID_playerPosRight;\n    player.pos = READ(ID_pos).xy;\n}\nvoid player_writeToMemory(inout Player player)\n{\n    vec2 ID_pos = player.left ? ID_playerPosLeft : ID_playerPosRight;\n    WRITE(ID_pos, vec4(player.pos, 0, 0));\n}\n\n////////////////////////////////\n\n// Key Ids and input functions\nconst int KEY_W = 87; const int KEY_S = 83; const int KEY_SPACE = 32; const int KEY_LEFT = 37; const int KEY_UP = 38; const int KEY_RIGHT = 39; const int KEY_DOWN = 40;\nfloat keyCodeToUvX(int keyCode) { return (float(keyCode)+0.5) / 256.0; }\nbool getKey(int keyCode, sampler2D inputChannel, float uvy) { return texture(inputChannel, vec2(keyCodeToUvX(keyCode), uvy)).r > 0.5; }\nbool getKey(int keyCode) { return getKey(keyCode, INPUT_CHANNEL, 0.25); }\nbool getKeyDown(int keyCode){ bool keyNow = getKey(keyCode); bool keyBefore = getKey(keyCode, PREVIOUS_FRAME_INPUT_CHANNEL, 0.25); return (keyNow && !keyBefore); }\nbool getKeyUp(int keyCode) { bool keyNow = getKey(keyCode); bool keyBefore = getKey(keyCode, PREVIOUS_FRAME_INPUT_CHANNEL, 0.25); return (!keyNow && keyBefore); }\n////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragCoordinate = fragCoord;\n    finalColor = vec4(0,0,0,0); // \"Clean\" value\n\n    if (iTime < 0.1) // First frame\n    {\n        // Let the memory buffer fill, to avoid garbage reads\n    }\n    else // Rest of frames\n    {\n        // Variable loading from memory\n        player_init(playerLeft);\n        player_init(playerRight);\n        //\n\n        // Movement input\n        // PlayerLeft\n        if (getKey(KEY_W))\n        {\n            playerLeft.pos.y += playerVelocity;\n        }\n        else if(getKey(KEY_S))\n        {\n            playerLeft.pos.y -= playerVelocity;\n        }\n\n        // PlayerRight\n        if (getKey(KEY_UP))\n        {\n            playerRight.pos.y += playerVelocity;\n        }\n        else if(getKey(KEY_DOWN))\n        {\n            playerRight.pos.y -= playerVelocity;\n        }\n        //////\n    }\n\n    // Variable writing to memory\n    player_writeToMemory(playerLeft);\n    player_writeToMemory(playerRight);\n    //\n\n    fragColor = finalColor;\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Latest input BUFFER\n// Used to store last input state, to handle more complex input events\n\n// Channel defines\n#define INPUT_CHANNEL iChannel1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(INPUT_CHANNEL, uv);\n}","name":"Buf B","description":"","type":"buffer"}]}