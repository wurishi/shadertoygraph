{"ver":"0.1","info":{"id":"mlyBRy","date":"1702211389","viewed":23,"name":"Wave Equation Sim","username":"wxy_equation","description":"Numerical Wave Equation.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //display the latent image as greyscale\n    float f = unormToFloat(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    fragColor = vec4((tanh(f)+1.)/2.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//encoding functions\nuint packUnorm4x8(vec4 x) \n{\n    x = round(clamp(x, 0., 1.) * 255.);\n    uvec4 r = uvec4(x);\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackUnorm4x8(uint x) \n{\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    vec4 v = vec4(r) / 255.0;\n    return v;\n}\n\nfloat unormToFloat(vec4 x)\n{\n    return uintBitsToFloat(packUnorm4x8(x));\n}\n\nvec4 floatToUnorm(float x)\n{\n    return unpackUnorm4x8(floatBitsToUint(x));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/********************initial conditions********************/\n\n//from texture\n//#define INITIAL_1\n\n//gaussian\n//#define INITIAL_2\nfloat gaussian(vec2 r, float R) {return exp(-0.5*dot(r, r)/(R*R));}\n\n//standing wave\n//#define INITIAL_3\n#define PI 3.141592\n\n//travelling wave\n//#define INITIAL_4\n\n//travelling packet\n#define INITIAL_5\n\n/********************utility functions********************/\n\nconst vec2 Resolution = vec2(800., 450.); //change to fit screen\nvec2 Dim = floor(Resolution/vec2(2., 1.));\n \nfloat rate = 60.;  //update rate (per second)\nfloat c = 10.;     //wave velocity (pixel/second)\n\n//read float from latent image\nfloat fetch(sampler2D tex, vec2 coord)\n{\n    return unormToFloat(texelFetch(tex, ivec2(floor(coord)), 0));\n}\n\n//getting (y, v) pairs from physical coord\n\nvec2 readData(sampler2D tex, vec2 coord)\n{   \n    float y = fetch(tex, coord);\n    float v = fetch(tex, coord+vec2(Dim.x, 0.));\n    return vec2(y, v);\n}\n//or read separately\nfloat readData(sampler2D tex, vec2 coord, bool flag)\n{\n    //flag: y->0, v->1\n    return fetch(tex, flag?coord+vec2(Dim.x, 0.):coord);\n}\n\n/********************computing********************/\n\n//set initial condition\nvec4 initiate(vec2 coord, bool flag)\n{   \n    #ifdef INITIAL_1\n    if(flag) {\n        //set initial v\n        return floatToUnorm(0.);\n    }\n    else {\n        //set initial x\n        //convert greyscale of an image into latent image\n        vec4 color = texelFetch(iChannel1, ivec2(coord), 0);\n        float f = dot(color.xyz, vec3(1.))/3.;\n        return floatToUnorm(f);\n    }  \n    #endif\n    \n    #ifdef INITIAL_2\n    if(flag) return floatToUnorm(0.);\n    else     return floatToUnorm(gaussian(coord-Dim/2., 10.));\n    #endif\n    \n    #ifdef INITIAL_3\n    if(flag) return floatToUnorm(0.);\n    else {\n        vec2 tmp = sin(2.*PI*coord/Dim);\n        return floatToUnorm(tmp.x*tmp.y);\n    }\n    #endif\n    \n    #ifdef INITIAL_4\n    float lambda = 100.;    //wavelength in pixel\n    float k = 2.*PI/lambda; //wave vector\n    \n    if(flag) return floatToUnorm(cos(k*coord.x)*c*k);\n    else     return floatToUnorm(sin(k*coord.x));\n    #endif\n    \n    #ifdef INITIAL_5\n    float lambda = 10.;                    //wavelength in pixel\n    float k = 2.*PI/lambda;                 //wave vector\n    float A = gaussian(coord-Dim/2., 20.);  //amplitude\n    \n    if(flag) return floatToUnorm(A*cos(k*coord.x)*c*k);\n    else     return floatToUnorm(A*sin(k*coord.x));\n    \n    #endif\n}\n\n//time propagation\nmat3 Laplacian = mat3(\n0.,  1., 0.,\n1., -4., 1., \n0.,  1., 0.\n);\nvec4 propagate(vec2 coord, bool flag) \n{          \n    //flag: y->0, v->1\n    if(flag) { \n        //update v       \n        float v = readData(iChannel0, coord, bool(1));\n        float div = 0.;\n        vec2 p;\n        for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            p = mod(coord+vec2(i, j), Dim);\n            div += readData(iChannel0, p, bool(0))*Laplacian[i+1][j+1];\n        }}\n        return floatToUnorm(v+div*c*c/rate);\n    }\n    else {\n        //update y\n        vec2 state = readData(iChannel0, coord);\n        return floatToUnorm(state.x+state.y/rate);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x>2.*Dim.x||fragCoord.y>Dim.y){ \n        //out of bound\n        fragColor = vec4(0.);\n    }\n    else{\n        bool flag = fragCoord.x>Dim.x; //y -> 0,  v -> 1\n        vec2 coord = mod(fragCoord.xy, Dim);\n        if(iFrame==0) \n            fragColor = initiate(coord, flag);\n        else if(bool(iFrame&1)==flag) \n            fragColor = propagate(coord, flag);\n        else \n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}