{"ver":"0.1","info":{"id":"lsGcRV","date":"1522600425","viewed":217,"name":"The chase","username":"CensoredUsername","description":"Raymarching shader, procedural texturing, basic phong lighting with some extra effects. If you've got a beefy machine set AA to 2 to enjoy proper anti aliasing. Party coded @ Revision 2018, code can use some cleanup.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float INFINITY = 1.e20;\nconst float PI       = 3.1415;\n\n// scene globals\nvec3 light_pos;\nvec3 origin;\nvec3 target;\nvec3 up;\n\n// update scene\nvec3 path(float time) {\n    float x = time * 8.;\n    return vec3(x, -2. - 1.5 * cos(x / 7. * PI), sin(iTime / 2.) * 2.);\n}\n\nvoid update_world() {\n    light_pos = vec3(3.5 * cos(iTime / 3.), 3.5 * sin(iTime / 3.), 4.);\n    origin = path(iTime);\n    up = normalize(vec3(0., cos(origin.x / 7. * PI), 6.));\n    light_pos = path(iTime + 1. + 0.8 * cos(iTime / 3.));\n    light_pos.z = light_pos.z * 2.;\n    target = light_pos;\n    target.yz = mix(origin.yz, target.yz, 0.2);\n}\n\n\n// operations\n\nfloat smootherstep(float e0, float e1, float x) {\n    x = clamp((x - e0) / (e1 - e0), 0., 1.);\n    return x * x * x * (x * (x * 6. - 15.) + 10.);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = smootherstep(0., 1., 0.5+0.5*(b-a)/k);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 repeat(vec3 pos, vec3 distance) {\n    return mod(pos + 0.5 * distance, distance) - 0.5 * distance;\n}\n\n// produces n-1 steps of a staircase\nfloat stairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// primitives\n\nfloat plane(vec3 pos) {\n    return pos.z;\n}\n\nfloat sphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat cylinder(vec3 pos, vec3 axis, float radius) {\n    return length(cross(pos, axis)) - radius;\n}\n\n// map function\n\nvec2 map(vec3 pos) {\n    vec3 abspos = pos;\n    pos.z = -abs(pos.z);\n    \n    pos.y += 4. * round(pos.x / 7.);\n    pos = repeat(pos, vec3(7., 8., 100.));\n    \n    return vec2(smin(\n        stairs(\n            cylinder(pos, vec3(0., 0., 1.), 1.),\n            sphere(pos, 2.),\n            2., 8.\n        ),\n        plane(pos + vec3(0., 0., 6. + cos(pos.x / 7. * PI * 4.) * cos(pos.y / 8. * PI * 4.) * 0.5)),\n        3.\n    ) * 0.8, 1.);\n}\n\n// rendering\n\nvec2 march_ray_enhanced(vec3 origin, vec3 direction, float pixel_radius) {\n    // see http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf for details\n    // ray marching parameters\n    const float min_distance = .1;\n    const float max_distance = 500.;\n    const int max_iter = 50;\n    const int max_smooth_iter = 4;\n    \n    // initial conditions\n    float omega = 1.2;\n    float distance = min_distance;\n    float candidate_error = INFINITY;\n    float candidate_distance = 0.;\n    float candidate_material = 0.;\n    float previous_radius = 0.;\n    float advance_size = 0.;\n    \n    int i;\n    for (i = 0; i < max_iter; i++) {\n        // determine distance and material of closest-by object\n        vec2 dist_mat = map(origin + direction * distance);\n        \n        // determine absolute radius for over-relaxation and error checks\n        float radius = abs(dist_mat.x);\n        \n        // checks if we were progressing over-relaxed and if it failed\n        bool failed_over_relaxed_advance = omega != 1.0 && (radius + previous_radius) < advance_size;\n\n        // update the previous radius \n        previous_radius = radius;\n        \n        // calculate error as a screen space angle\n        float error = radius / distance;\n        \n        // determines how far we should advance\n        if (failed_over_relaxed_advance) {\n            // if we failed, we have to step back to where normal advancement would've brought us\n            advance_size -= advance_size * omega;\n            omega = 1.;\n\n        } else {\n            advance_size = dist_mat.x * omega;\n            \n            // was this a better hit than the previous one?\n            if (error < candidate_error) {\n                candidate_distance = distance;\n                candidate_error = error;\n                candidate_material = dist_mat.y;\n            }\n            \n            // did we hit something or the end of the ray\n            if (error < pixel_radius || distance > max_distance) {\n                break;\n            }\n        }\n        \n        // advance\n        distance += advance_size;\n    }\n    \n    if (distance > max_distance) {\n        return vec2(INFINITY, -1.);\n    }\n\n    // post-processing on the hit point: a few iteration steps to get smooth coordinates\n    for (int j = 0; j < max_smooth_iter; j++) {\n        float allowable_error = pixel_radius * candidate_distance;\n        candidate_distance += map(origin + direction * candidate_distance).x - allowable_error;\n    }\n\n    return vec2(candidate_distance, candidate_material);\n}\n\nvec3 estimate_normal(vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.05;\n    \n    // for four points on a cube, none of them\n    // next to another, calculate the change\n    // basically in any axis there are two points at +e and two points at -e\n    // note that length(e) is sqrt(3 * e) for any point to get the actual change\n    // in that axis you should divide by sqrt(3) (1/sqrt(3) = 0.5773)\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat shadow(vec3 p, vec3 light_dir, float mind, float maxd) {\n    float d = mind;\n    float dist;\n    float res = 1.;\n\n    for (int i = 0; i < 10; i++) {\n        vec2 dist_mat = map(p + d * light_dir);\n        dist = dist_mat.x;\n        res = min(res, 4. * dist / d);\n        d += clamp(dist, mind, mind * 10.);\n\n        if (dist < 0.001 || d > maxd) {\n          break;\n        }\n \n    }\n\n    return clamp(res, 0., 1.);\n}\n\n// really cheap occlusion\n// 0.0 = occluded, 1.0 = not occluded\nfloat occlude(vec3 p, vec3 norm, float fewaf) {\n    float dist = .1;\n    float tot = 0.;\n    \n    for (int i = 1; i < 7; i++) {\n        float try_dist = dist * float(i);\n        float d = map(p + norm * try_dist).x;\n        tot += (d / try_dist);\n    }\n    return clamp((tot - 2.) / 4., 0.0, 1.0);\n    \n}\n\nvec3 render(vec3 origin, vec3 direction, float pixel_radius) {\n    // cast our initial ray to determine what we'll hit\n    vec2 dist_mat = march_ray_enhanced(origin, direction, pixel_radius);\n    float distance = dist_mat.x;\n    float material = dist_mat.y;\n    \n    vec3 hit = origin + direction * distance;\n    \n    // calculate a normal vector around the hit point and a reflection vector\n    vec3 normal = estimate_normal(hit);\n    vec3 reflect_dir = reflect(direction, -normal);\n    \n    // return the color (currently just based on total distance travelled through 2 reflections.\n    //return (material > -0.5) ? vec3(10. / (dist_mat.x + reflect_dist_mat.x + rreflect_dist_mat.x)) : vec3(0.);\n    if (material < 0.) {\n        return vec3(0.02, 0.015, 0.01) * 0.5;\n    }\n    \n    // basic phong shading\n    vec3 light_dir = hit - light_pos;\n    vec3 reflect_light_dir = reflect(normalize(light_dir), -reflect_dir);\n\n    float diff = max(0.0, -dot(normal, normalize(light_dir)));\n    float spec = pow(max(0.0, -dot(direction, reflect_light_dir)), 4.) * smoothstep(0., 1., diff * 10.);\n\n    float occ = shadow(hit, -light_dir, 0.01, length(light_dir));\n    float light_intensity = 40. * occ * pow(1. / length(light_dir), 2.);\n\n    vec3 color = vec3(0.01) +\n                 vec3(0.04) * diff * light_intensity +\n                 vec3(0.8)  * spec * light_intensity;\n    \n    // occlusion\n    color *= vec3(occlude(hit, normal, 0.04));\n    \n    // particle effect\n    float z_plane = floor(hit.z * 100.) / 100.;\n\n    float angle = atan(normal.y, normal.x) * ((hash(vec2(z_plane, 8.)) > .5) ? -1. : 1.);\n    float expected_angle = hash(vec2(z_plane, 5.)) * 2. * PI + iTime * 2. * pow(hash(vec2(z_plane, 4.)), 2.);\n    \n    float h = hash(vec2(z_plane, 1.));\n    float angle_from_lead = mod((angle - expected_angle + sin(hit.x * 0.1 * h) - cos(hit.y * 0.13 * h)) / 2. / PI, 1.);\n    \n    float brightness = pow(max(angle_from_lead - 0.9, 0.0) * 10., 4.);\n    float fade = max(0.0, min(1.0, 5. * cos(iTime * 0.1 * hash(vec2(z_plane, 2.))) - 2. + 5. * hash(vec2(z_plane, 3.)) ));\n\n    if (length(normal.xy) > 0.01) {\n        color += brightness * fade * vec3(0.8, 0.5, 0.1) * length(normal.xy) * 2.;\n    }\n    \n    // fog\n    color = mix(vec3(0.02, 0.015, 0.01) * 0.5, color, exp(-distance * 0.1));\n    \n    // sphere glow\n    vec3 sphere_diff = light_pos - origin;\n    float sphere_dist = length(sphere_diff - direction * dot(sphere_diff, direction));\n    color += smoothstep(-3.5, 0., distance - length(sphere_diff)) * min(1.0, exp(-(sphere_dist - 0.6) * 4.)) * vec3(1.);\n    \n    return color;\n}\n\nmat3 look_at(vec3 origin, vec3 target, vec3 reference_up, float tilt) {\n    // note: I'm using a reference frame where Z is upwards, and X/Y a groundplane\n    // direction the camera is looking at.\n    // this function returns a transformation matrix that takes X/Y screenpos + Z depth into that reference frame\n    vec3 direction = normalize(target - origin);\n\n    // construct upwards pointing direction aligned frame\n    vec3 side = normalize(cross(direction, reference_up));\n    vec3 up   = cross(side, direction);\n    \n    // rotate around direction\n    vec3 up_rotated   = cos(tilt) * up   - sin(tilt) * side;\n    vec3 side_rotated = cos(tilt) * side + sin(tilt) * up;\n    \n    // construct reference frame.\n    return mat3(side_rotated, up_rotated, direction);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // calculate scene\n    update_world();\n    \n    // anti-aliasing oversampling\n    const int AA = 1;\n    // screen height / screen distance. 2 = 90deg, 1.15 = 60deg\n    const float FOV_scale = 4.;\n    \n    // normalized cursor location\n    vec2 cursor = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n            \n    // approximate normalized projected pixel size. multiply by distance to get local projected pixel radius\n    // Note that this is only really true for the center pixel, the sphere that fits in pixels further to the\n    // outside gets smaller\n    float pixel_radius = FOV_scale / iResolution.y / 2.;\n    \n    // camera location\n    //vec3 origin = vec3(-10. * cos(cursor.x), -10. * sin(cursor.x), cursor.y * 5.);\n    \n    // camera to world transform matrix\n    mat3 camera = look_at(origin, target, up, 0.);\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            \n            // subpixel coordinates for anti-aliasing\n            vec2 subpixel_coord = -0.5 + (0.5 + vec2(float(i), float(j))) / float(AA);   \n\n            // map pixel location to a -1 to 1 field on the y axis, and an appropriately scaled x axis.\n            // Scale this to control FoV (currently 90 deg)\n            vec2 pixel_coord = FOV_scale * (fragCoord + subpixel_coord - 0.5 * iResolution.xy) / iResolution.y;\n    \n            // translate screenspace to worldspace and normalize pixel coordinate position\n            vec3 direction = normalize(camera * vec3(pixel_coord, 1.));\n\n            // render in that direction\n            color += render(origin, direction, pixel_radius);\n            \n        }\n    }\n    \n    color /= pow(float(AA), 2.);\n    \n    // gamma correct and write to output\n    fragColor = vec4(pow(color, vec3(1. / 2.2)), 1.);\n}","name":"Image","description":"","type":"image"}]}