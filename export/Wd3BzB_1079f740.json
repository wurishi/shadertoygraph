{"ver":"0.1","info":{"id":"Wd3BzB","date":"1605376485","viewed":138,"name":"Julia set distance Lissajous","username":"Atchafalaya","description":"Computing an approximation of the distance to a Julia set with the c parameter following a Lissajous curve.\nInspired by Iñigo Quilez's work and article https://iquilezles.org/articles/distancefractals/distancefractals.htm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","lissajou"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nComputing an approximation of the distance to a Julia set \nwith the c parameter following a Lissajous curve.\n\nInspired by Iñigo Quilez's work and article https://iquilezles.org/articles/distancefractals\nRelated work :\nhttps://www.shadertoy.com/view/wd3BDM\nhttps://www.shadertoy.com/view/3d3BWH\n*/\n\n#define R iResolution\n#define BAILOUT_THRESHOLD 10000.\n#define MAX_ITERATION 512\n#define PI 3.1415\n\nfloat juliaDist(vec2 z, vec2 c)\n{\n    float lz2 = 0.;\n    vec2 dz = vec2(1., 0.);\n    int i = 0;\n    while (i < MAX_ITERATION && lz2 < BAILOUT_THRESHOLD)\n    {\n        dz = 2. * vec2(z.x * dz.x - z.y * dz.y,\n                       z.x * dz.y + z.y * dz.x);\n        z = vec2(z.x * z.x - z.y * z.y,\n                 2. * z.x * z.y)\n            + c;\n        lz2 = dot(z, z);\n        i++;\n    }\n    if (lz2 < BAILOUT_THRESHOLD)\n    {\n        return -1.;\n    }\n    else\n    {\n        float k = pow(2., -float(i));\n\t\treturn sqrt(lz2 / dot(dz, dz)) * (1. - pow(lz2, -k)) / k;\n\n        return sqrt(lz2) * 0.5 * log(lz2) / length(dz);\n    }\n}\n\nvec3 palette(float dist)\n{\n    if (dist < 0.)\n    {\n        return vec3(1., 0.6, 0.);\n    }\n    else \n    {\n        vec3 col = vec3(1., 0.6, 0.) * (0.8 + 0.2 * cos(30. * dist));\n        col *= 1. - (1. / (1. + 25. * dist));\n        col = mix(col, vec3(.8), smoothstep(0.02, 0., dist));\n        return col;\n    }\n}\n\nvec2 lissajous(float u)\n{\n    u *= 2. * PI;\n    return vec2(0.8 * sin(u) + 0.5 * cos(3. * u) + 0.2 * sin(9. * u),\n                0.8 * cos(u + 0.8) - 0.4 * sin(4. * u) + 0.1 * sin(8. * u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - R.xy) / R.x;\n    vec2 mouse = (2. * iMouse.xy - R.xy) / R.x;\n    \n    float zoom = 2.5;\n    uv *= zoom;\n    mouse *= zoom;\n    \n    vec2 c;\n    if (iMouse.z > 0. || iMouse.w > 0.)\n    {\n        c = mouse;\n    }\n    else\n    {\n        c = lissajous(0.07 * iTime);\n    }\n    \n    vec3 col;\n    vec3 colJulia = palette(juliaDist(uv, c));\n    \n    float dist2C = dot(uv - c, uv - c);\n    float pointRadius = 0.005;\n    if (dist2C < pointRadius)\n    {\n        col = vec3(0.1, 0.9, 0.1);\n        col = mix(col, vec3(0.), step(0.75 * pointRadius, dist2C));\n        col = mix(col, colJulia, 1. - exp(500. * (0.75 * pointRadius - dist2C)));\n    }\n    else\n    {\n   \t\tcol = colJulia;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}