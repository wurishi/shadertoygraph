{"ver":"0.1","info":{"id":"4fyXRW","date":"1714852338","viewed":101,"name":"Natural neighbour Interpolation","username":"mrboggieman","description":"Natural neighbour interpolation by weighting neighbouring points that contribute towards the Voronoi cell of the current pixel. Drag mouse to control one of the points\nKey '1' - toggle nearest neighbour / natural neighbour interpolation","likes":4,"published":1,"flags":16,"usePreview":0,"tags":["voronoi","interpolation","delaunay","natural","neighbour","neighbor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Natural neighbour interpolation\n//\n// Extension of https://www.shadertoy.com/view/MfGSRz to perform natural neighbour interpolation\n// A voronoi cell is created for each pixel, each natural neighbour is then weighted based on\n// how much the neighbour's voronoi overlaps the current pixels voronoi\n//\n// This demo is designed to work only with a few sparse points, not dense points\n//\n// Similar to https://gwlucastrig.github.io/TinfourDocs/NaturalNeighborTinfourAlgorithm/index.html\n\n// utils\nconst float EPSILON = 0.0001;\n\nstruct Line {\n   vec2 a;\n   vec2 b;\n};\n\nfloat det2(in vec2 a, in vec2 b) {\n    //return (a.x * b.y) - (a.y * b.x);\n    return determinant(mat2(a, b));\n}\n\nvec2 project(in vec2 a, in vec2 b) {\n    return dot(a, b)/dot(b, b) * b;\n}\n\nvec2 closestPointOnLine(in Line line, in vec2 pos) {\n    return line.a + project(pos - line.a, line.b - line.a);\n}\n\nbool pointInsideLine(in Line line, in vec2 pos) {\n    return det2(pos - line.a, line.b - line.a) < 0.0;\n}\n\nint intersectLines(in Line line1, in Line line2, out vec2 collision) {\n    float c = det2(line1.a, line1.b);\n    float d = det2(line2.a, line2.b);\n    float e = det2(line1.a - line1.b, line2.a - line2.b);\n\n    collision = vec2(\n        det2(vec2(c, line1.a.x - line1.b.x), vec2(d, line2.a.x - line2.b.x)) / e,\n        det2(vec2(c, line1.a.y - line1.b.y), vec2(d, line2.a.y - line2.b.y)) / e\n    );\n\n    // ensure the collision point is in the 0-1 range of our line (must be more efficient way of doing this)\n    if ((dot(collision - line1.a, line1.b - line1.a) < 0.0) || (distance(collision, line1.a) > distance(line1.a, line1.b) + EPSILON)) {\n        return 0;\n    }\n\n    return int(sign(e));\n}\n\nfloat distanceToLine(in Line line, in vec2 pos) {\n    return distance(closestPointOnLine(line, pos), pos);\n}\n\nfloat distanceToLineSegment(in Line line, in vec2 pos) {\n    return distance(clamp(closestPointOnLine(line, pos), min(line.a, line.b), max(line.a, line.b)), pos);\n}\n\n// DEMO\nstruct Point {\n    vec2 pos;\n    vec3 colour;\n};\n\nPoint[] points = Point[](\n  Point(vec2(0.15, 0.25), vec3(0.9, 0.1, 0.3)),\n  Point(vec2(1.5, 0.25), vec3(0.1, 0.9, 0.2)),\n  Point(vec2(0.75, 0.25), vec3(0.9, 0.8, 0.2)), \n  Point(vec2(1.25, 0.5), vec3(0.1, 0.2, 1.0)),\n  Point(vec2(0.9, 0.8), vec3(0.8, 0.3, 0.4)),\n  Point(vec2(0.75, 0.5), vec3(0.9, 0.1, 0.7)),\n  Point(vec2(1.25, 0.75), vec3(0.9, 0.7, 0.6)),\n  Point(vec2(0.5, 0.75), vec3(0.3, 0.4, 0.2)),\n  Point(vec2(1.1, 0.15), vec3(0.7, 0.4, .2))\n);\n\nconst int NUM_POINTS = points.length();\n\nconst int MAX_LINES = NUM_POINTS; // limit of the number of lines in each voronoi cell polygon\n\nstruct AreaLine {\n    Line line;\n    int index;\n};\n\nstruct LineVec {\n    AreaLine[MAX_LINES] lines;\n    int count;\n};\n\n// this methods cuts lines up and produces a new polygon with the cutting line\n// line segments on the negative side of the line are discarded\n// note: the order of lines is not preserved, the cutting line direction is inverted\nLineVec slicePolygon(in LineVec lines, in AreaLine cutting_line) {\n    AreaLine[MAX_LINES] new_lines;\n    int num_new_lines = 0;\n    vec2 in_point;\n    vec2 out_point;\n    bool has_in_point;\n    bool has_out_point;\n    \n    for (int i=0; i<lines.count; i++) {\n        vec2 intersection;\n        AreaLine line = lines.lines[i];\n        int dir = intersectLines(line.line, cutting_line.line, intersection);\n\n        switch (dir) {\n            case 0:\n                // determine if the line is inside or outside by checking the center of the line\n                if (!pointInsideLine(cutting_line.line, mix(line.line.a, line.line.b, 0.5))) {\n                    new_lines[num_new_lines] = line;\n                    num_new_lines++;\n                }\n                break;\n            case -1:\n                // break the line into two keeping the first part\n                new_lines[num_new_lines] = AreaLine(Line(line.line.a, intersection), line.index);\n                num_new_lines++;\n                \n                in_point = intersection;\n                has_in_point = true;\n                break;\n            case 1:\n                // break the line into two keeping the second part\n                new_lines[num_new_lines] = AreaLine(Line(intersection, line.line.b), line.index);\n                num_new_lines++;\n\n                out_point = intersection;\n                has_out_point = true;\n                break;\n        }\n    }\n    \n    if (has_in_point && has_out_point) {\n        new_lines[num_new_lines] = AreaLine(Line(in_point, out_point), cutting_line.index);\n        num_new_lines++;\n    }\n\n    return LineVec(new_lines, num_new_lines);\n}\n\nfloat line_vec_area(in LineVec lines) {\n    float sum = 0.0;\n\n    for(int i = 0; i <lines.count; i++) {\n        Line line = lines.lines[i].line;\n        sum += det2(line.a, line.b);\n    }\n    \n    return sum / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    // allow dragging one of the points\n    if (length(iMouse.xy) > 10.0) {\n        points[4].pos = iMouse.xy / iResolution.y;\n    }\n    \n    // find the closest point\n    Point closest;\n    float closest_distance = 2.0;\n\n    for (int i=0; i < NUM_POINTS; i++) {\n        Point point = points[i];\n        float dist = distance(uv, point.pos);\n        \n        if (dist < closest_distance) {\n            closest = point;\n            closest_distance = dist;\n        }\n    }\n    \n    // if the uv is pretty very close to the nearest point then just return the point colour \n    if (closest_distance < EPSILON) {\n        fragColor = vec4(closest.colour, 0.0);\n        return;\n    }\n    \n    // draw the nearest neighbour if key '1' is on\n    if (texelFetch(iChannel0, ivec2(49, 2), 0).r > 0.0) {\n        fragColor = vec4(closest.colour, 0.0);\n        return;\n    }\n\n    // compute the voronoi cell lines for the current point\n    float width = iResolution.x/iResolution.y;\n    float height = 1.0;\n\n    vec2[] vertices = vec2[](\n        vec2(0.0, 0.0),\n        vec2(width, 0.0),\n        vec2(width, height),\n        vec2(0.0, height)\n    );\n\n    LineVec voronoi_lines;\n    voronoi_lines.count = 4;\n    voronoi_lines.lines[0] = AreaLine(Line(vertices[0], vertices[1]), -1);\n    voronoi_lines.lines[1] = AreaLine(Line(vertices[1], vertices[2]), -1);\n    voronoi_lines.lines[2] = AreaLine(Line(vertices[2], vertices[3]), -1);\n    voronoi_lines.lines[3] = AreaLine(Line(vertices[3], vertices[0]), -1);\n\n    for (int i = 0; i < NUM_POINTS; i++) {\n        //create a line to split the voronoi cell using the line tangent\n        vec2 pos = mix(points[i].pos, uv, 0.5);\n        vec2 tangent_dir = vec2(pos.y - uv.y, uv.x - pos.x);\n        AreaLine split_line = AreaLine(Line(pos, pos + tangent_dir), i);\n\n        // slice the voronoi cell by the tangent of the neighbour\n        voronoi_lines = slicePolygon(voronoi_lines, split_line);\n    }\n\n    // sum the parts instead of computing separately here\n    float point_voronoi_area;// = line_vec_area(voronoi_lines);\n\n    // the points associated to the voronoi lines are the natural neighbours\n    vec3 output_colour;\n\n    for (int i = 0; i < voronoi_lines.count; i++) {\n        AreaLine line = voronoi_lines.lines[i];\n        \n        // ignore boundary lines as they have no associated point\n        if (line.index == -1) {\n            continue;\n        }\n\n        // for each neighbour we need to clip the current point voronoi against the voronoi of the neighbour\n        Point neighbour = points[line.index];\n\n        // create the voronoi for the neighbour\n        LineVec neighbour_voronoi_lines;\n        neighbour_voronoi_lines.count = 4;\n        neighbour_voronoi_lines.lines[0] = AreaLine(Line(vertices[0], vertices[1]), -1);\n        neighbour_voronoi_lines.lines[1] = AreaLine(Line(vertices[1], vertices[2]), -1);\n        neighbour_voronoi_lines.lines[2] = AreaLine(Line(vertices[2], vertices[3]), -1);\n        neighbour_voronoi_lines.lines[3] = AreaLine(Line(vertices[3], vertices[0]), -1);\n\n        // iterate through all of the points and split to create the voronoi cell\n        for (int j = 0; j < NUM_POINTS; j++) {\n            //create a line to split the voronoi cell using the line tangent\n            vec2 pos = mix(points[j].pos, neighbour.pos, 0.5);\n            vec2 tangent_dir = vec2(pos.y - neighbour.pos.y, neighbour.pos.x - pos.x);\n            AreaLine split_line = AreaLine(Line(pos, pos + tangent_dir), j);\n\n            // slice the voronoi by the tangent of the neighbour\n            neighbour_voronoi_lines = slicePolygon(neighbour_voronoi_lines, split_line);\n        }\n        \n        float original_neighbour_voronoi_area = line_vec_area(neighbour_voronoi_lines);\n        \n        // slice the neighbour voronoi with the line between the current point and the neighbour\n        vec2 pos = mix(uv, neighbour.pos, 0.5);\n        vec2 tangent_dir = vec2(pos.y - neighbour.pos.y, neighbour.pos.x - pos.x);\n        AreaLine split_line = AreaLine(Line(pos, pos + tangent_dir), -1);\n\n        neighbour_voronoi_lines = slicePolygon(neighbour_voronoi_lines, split_line);    \n        \n        // we now have the area the neighbour contributes\n        float new_neighbour_voronoi_area = line_vec_area(neighbour_voronoi_lines);\n        float neighbour_voronoi_area = original_neighbour_voronoi_area - new_neighbour_voronoi_area;\n\n        output_colour += (neighbour_voronoi_area * neighbour.colour);\n        point_voronoi_area += neighbour_voronoi_area;\n    }\n\n    fragColor = vec4(output_colour / point_voronoi_area, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}