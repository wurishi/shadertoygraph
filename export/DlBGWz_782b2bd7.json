{"ver":"0.1","info":{"id":"DlBGWz","date":"1673093451","viewed":137,"name":"Central Gradient Looped","username":"spalmer","description":"a way in GLSL ES 3 to prevent inlining of 6 calls to scene map() sdf when computing traditional full central difference gradient of a field.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["gradient","derivative","optimization","centraldifference"],"hasliked":0,"parentid":"NscXR4","parentname":"Tetrahedral Gradient Looped"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IZERO min(0, iFrame)\n\nfloat dscene(vec3 q);\n\n// looped central difference gradient, riffing on Thomas Hooper idea\nvec3 gscene1(vec3 q, float h)\n{\n    vec3 e = vec3(1,0,0), g = e.zzz;\n    for (int i = IZERO + 6; \n            i-- > 0;\n            g += dscene(q + h * e) * e, e = e.zxy)\n        if (i == 2) e = -e;\n    return .5 * g;\n}\n\n// Shane from http://shadertoy.com/view/7ldfzS\nvec3 gscene2(vec3 p, float t) {\n\t\n    vec2 e = vec2(t, 0);\n    float s = 1.;\n    float m[6];\n    vec3[3] f = vec3[3](e.xyy, e.yxy, e.yyx);\n    for (int i = IZERO; i<6; ++i) {\n\t\tm[i] = dscene(p + s*f[i>>1]);\n        s = -s;\n//        if (s>2.) break;\n    }\n    \n    return .5 * vec3(m[0] - m[1], m[2] - m[3], m[4] - m[5]);\n}\n\n// unlooped standard central difference gradient for comparison\nvec3 gscene0(vec3 q, float h)\n{\n    vec2 e = vec2(h, 0);\n    return .5 * (vec3(\n       dscene(q + e.xyy),\n       dscene(q + e.yxy),\n       dscene(q + e.yyx)\n       ) - vec3(\n       dscene(q - e.xyy),\n       dscene(q - e.yxy),\n       dscene(q - e.yyx)\n       ));\n}\n\n// for those unfamiliar with the calculus,\n// that's just partial derivatives combined,\n// one for each coordinate axis, each is\n// simply a first-order divided difference.\n\nfloat dscene(vec3 q)\n{\n    return min(min(length(q) - 2., 6. - length(q)), q.y + 1.)\n        // any ideas to exhibit the technique better? maybe some patterned surface?\n        + dot(sin(q*16.), vec3(1)) * .015\n    ;\n}\n\nvoid mainImage(out vec4 O, vec2 p)\n{\n    O = vec4(1);\n    mat2 S = mat2(sin(.1 * iTime * vec4(1,-1,1,1) + vec2(acos(0.), 0).xyyx));\n    vec3 R = iResolution, P = vec3(0,.5,-5), q,\n    r = normalize(vec3(p - .5*R.xy, R.y));\n    r.xz *= S; P.xz *= S; q = P;\n    for (int i = 96 + IZERO; i-- > 0 && abs(O.a) > .01;\n         q += r * (O.a = dscene(q)));\n    // precision should depend on distance to camera\n    float d = length(q - P), // range\n        precis = d * .001;\n    // normalized gradient (normal) of scene at p\n    vec3 g = //gscene2(q, precis) // can try Shane's\n            gscene1(q, precis) // mine\n        //gscene0(q, precis) // unoptimized\n    , n = normalize(g);\n    //O.rgb *= dot(n, vec3(sqrt(1./3.))) * .5 + .5; // lit\n    O.rgb *= n * .5 + .5;\n//    O.rgb *= exp2(-.1*d); //abs(sin(17.*d)); // test depth\n//    n *= 1.001; //.999; // TEST\n//    O.gb *= exp2(-5e3 * abs(1. - length(n))); // detect unnormalized normals\n}\n\n","name":"Image","description":"","type":"image"}]}