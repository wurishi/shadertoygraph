{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Subpixels antialiased arrow fields\n// Nicolas P. Rougier (http://www.loria.fr/~rougier)\n// Released under BSD license.\n//\n// Inspired by by \"2D vector field visualization\" by Morgan McGuire\n// (https://www.shadertoy.com/view/4s23DG)\n\nvec4 stroke(float distance, float linewidth, float antialias, vec4 stroke)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    if( border_distance > (linewidth/2.0 + antialias) )\n        discard;\n    else if( border_distance < 0.0 )\n        frag_color = stroke;\n    else\n        frag_color = vec4(stroke.rgb*alpha, 1.);\n\n    return frag_color;\n}\n\nvec4 filled(float distance, float linewidth, float antialias, vec4 fill)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = fill;\n    // Within shape\n    else if( signed_distance < 0.0 )\n        frag_color = fill;\n    else\n        // Outside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            discard;\n        else // Line stroke exterior border\n            frag_color = vec4(fill.rgb*alpha, 1.0);\n\n    return frag_color;\n}\n\n// Computes the signed distance from a line\nfloat line_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    return dot(rel_p, vec2(dir.y, -dir.x));\n}\n\n// Computes the signed distance from a line segment\nfloat segment_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    float dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n    float dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n    return max(dist1, dist2);\n}\n\n// Computes the center with given radius passing through p1 & p2\nvec4 circle_from_2_points(vec2 p1, vec2 p2, float radius)\n{\n    float q = length(p2-p1);\n    vec2 m = (p1+p2)/2.0;\n    vec2 d = vec2( sqrt(radius*radius - (q*q/4.0)) * (p1.y-p2.y)/q,\n                   sqrt(radius*radius - (q*q/4.0)) * (p2.x-p1.x)/q);\n    return  vec4(m+d, m-d);\n}\n\nfloat arrow_curved(vec2 texcoord,\n                   float body, float head,\n                   float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n    float height = 0.5;\n\n    vec2 p1 = end - head*vec2(+1.0,+height);\n    vec2 p2 = end - head*vec2(+1.0,-height);\n    vec2 p3 = end;\n\n    // Head : 3 circles\n    vec2 c1  = circle_from_2_points(p1, p3, 1.25*body).zw;\n    float d1 = length(texcoord - c1) - 1.25*body;\n    vec2 c2  = circle_from_2_points(p2, p3, 1.25*body).xy;\n    float d2 = length(texcoord - c2) - 1.25*body;\n    vec2 c3  = circle_from_2_points(p1, p2, max(body-head, 1.0*body)).xy;\n    float d3 = length(texcoord - c3) - max(body-head, 1.0*body);\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    // Outside (because of circles)\n    if( texcoord.y > +(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.y < -(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.x < -(body/2.0 + antialias) )\n         return 1000.0;\n    if( texcoord.x > c1.x ) //(body + antialias) )\n         return 1000.0;\n\n    return min( d4, -min(d3,min(d1,d2)));\n}\n\nfloat arrow_triangle(vec2 texcoord,\n                     float body, float head, float height,\n                     float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n\n    // Head : 3 lines\n    float d1 = line_distance(texcoord, end, end - head*vec2(+1.0,-height));\n    float d2 = line_distance(texcoord, end - head*vec2(+1.0,+height), end);\n    float d3 = texcoord.x - end.x + head;\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    float d = min(max(max(d1, d2), -d3), d4);\n    return d;\n}\n\nfloat arrow_triangle_90(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 1.0, linewidth, antialias);\n}\n\nfloat arrow_triangle_60(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 0.5, linewidth, antialias);\n}\n\nfloat arrow_triangle_30(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 0.25, linewidth, antialias);\n}\n\nfloat arrow_angle(vec2 texcoord,\n                  float body, float head, float height,\n                  float linewidth, float antialias)\n{\n    float d;\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n\n    // Arrow tip (beyond segment end)\n    if( texcoord.x > body/2.0) {\n        // Head : 2 segments\n        float d1 = line_distance(texcoord, end, end - head*vec2(+1.0,-height));\n        float d2 = line_distance(texcoord, end - head*vec2(+1.0,+height), end);\n        // Body : 1 segment\n        float d3 = end.x - texcoord.x;\n        d = max(max(d1,d2), d3);\n    } else {\n        // Head : 2 segments\n        float d1 = segment_distance(texcoord, end - head*vec2(+1.0,-height), end);\n        float d2 = segment_distance(texcoord, end - head*vec2(+1.0,+height), end);\n        // Body : 1 segment\n        float d3 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n        d = min(min(d1,d2), d3);\n    }\n    return d;\n}\n\nfloat arrow_angle_90(vec2 texcoord,\n                     float body, float head,\n                     float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 1.0, linewidth, antialias);\n}\n\nfloat arrow_angle_60(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 0.5, linewidth, antialias);\n}\n\nfloat arrow_angle_30(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 0.25, linewidth, antialias);\n}\n\n\nfloat arrow_stealth(vec2 texcoord,\n                    float body, float head,\n                    float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n    float height = 0.5;\n\n    // Head : 4 lines\n    float d1 = line_distance(texcoord, end-head*vec2(+1.0,-height),\n                                       end);\n    float d2 = line_distance(texcoord, end-head*vec2(+1.0,-height),\n                                       end-vec2(3.0*head/4.0,0.0));\n    float d3 = line_distance(texcoord, end-head*vec2(+1.0,+height), end);\n    float d4 = line_distance(texcoord, end-head*vec2(+1.0,+0.5),\n                                       end-vec2(3.0*head/4.0,0.0));\n\n    // Body : 1 segment\n    float d5 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    return min(d5, max( max(-d1, d3), - max(-d2,d4)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float M_PI = 3.14159265358979323846;\n    const float SQRT_2 = 1.4142135623730951;\n    const float linewidth = 2.0;\n    const float antialias =  1.0;\n\n    const float rows = 8.0;\n    const float cols = 8.0;\n    float body = min(iResolution.x/cols, iResolution.y/rows) / SQRT_2;\n    vec2 texcoord = fragCoord.xy;\n    vec2 size   = iResolution.xy / vec2(cols,rows);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n    texcoord -= center;\n\n    float theta = (iTime/2.0) + 0.05*(center.x / cols + center.y / rows);\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    texcoord = vec2(cos_theta*texcoord.x - sin_theta*texcoord.y,\n                    sin_theta*texcoord.x + cos_theta*texcoord.y);\n\n    float d;\n    if (fragCoord.y < size.y)\n        d = arrow_curved(texcoord, body, 0.25*body, linewidth, antialias);\n    else if (fragCoord.y < 2.0*size.y)\n        d = arrow_stealth(texcoord, body, 0.25*body, linewidth, antialias);\n    else if (fragCoord.y < 3.0*size.y)\n        d = arrow_triangle_90(texcoord, body, 0.15*body, linewidth, antialias);\n    else if (fragCoord.y < 4.0*size.y)\n        d = arrow_triangle_60(texcoord, body, 0.20*body, linewidth, antialias);\n    else if (fragCoord.y < 5.0*size.y)\n        d = arrow_triangle_30(texcoord, body, 0.25*body, linewidth, antialias);\n    else if (fragCoord.y < 6.0*size.y)\n        d = arrow_angle_90(texcoord, body, 0.15*body, linewidth, antialias);\n    else if (fragCoord.y < 7.0*size.y)\n        d = arrow_angle_60(texcoord, body, 0.20*body, linewidth, antialias);\n    else\n        d = arrow_angle_30(texcoord, body, 0.25*body, linewidth, antialias);\n\n    if (fragCoord.x < size.x*cols/2.0)\n        fragColor = filled(d, linewidth, antialias, vec4(1,1,1,1));\n    else\n        fragColor = stroke(d, linewidth, antialias, vec4(1,1,1,1));\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldlSWj","date":"1407009170","viewed":2217,"name":"Arrow types ","username":"rougier","description":"A bunch of arrow styles inspired by \"2D vector field visualization\" by Morgan McGuire (https://www.shadertoy.com/view/4s23DG)","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["visualization","antialias","subpixel","arrow","types"],"hasliked":0,"parentid":"","parentname":""}}