{"ver":"0.1","info":{"id":"lXGSDW","date":"1720284745","viewed":81,"name":"Glowing ball in water","username":"BJ","description":"This was my first time using ray marching, this wasn't the effect i was looking for. But it looks cool!","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","water","rainbow","experimental","neon","cool","relaxing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord / iResolution.xy * 2. -1.;\n    \n    vec3 a = normalize(vec3(uv.x, uv.y, 1.)); // the directional vector.\n\n    float t = 0.; // the distance traveled by the ray\n    vec3 p = vec3(0.,0.,0.); // position of the sphere\n    vec3 c = vec3(sin(iTime+0.2)*4., sin(iTime*1.3+6.3)*6., 10.); // cordinates of the sphere.\n    float f = 0.; // 0 = no collision, 1 = collision.\n    float d = 0.; // distance between the ray and the sphere.\n    \n    for (int i = 0; i < 50; i++) // chance x in ( i < \"x\" ) to change the iterations.\n    {\n\n    d = min(distance(p, c)-2., distance(p.y, -1.5)); // p is the rays position, .\n\n    if (d < 0.01) // if the distance to the sphere is small enough it counts as an collision.\n    {\n    f=1.;\n    break;\n    }\n    \n    p += d*a; // updates the rays position.\n    t += d; // updates the distance traveled.\n    \n    if (t > 10000.) // if the ray has traveled too far it will be no collision.\n    {\n    break;\n    }\n    if (p.y < -1.45) // checks if the ray hits water.\n    {\n    f = 0.4;\n    break;\n    }\n    \n    }\n    \n    vec3 n = normalize(vec3(p.x - c.x, p.y - c.y, p.z - c.z));// sutface normal.\n    vec3 col =vec3(abs(n.x),abs(n.y),abs(n.z)) * f; // visualises the normals on the sphere.\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n \n}","name":"Image","description":"","type":"image"}]}