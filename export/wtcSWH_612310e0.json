{"ver":"0.1","info":{"id":"wtcSWH","date":"1580846769","viewed":407,"name":"deepdiving","username":"Del","description":"deep diving \"Twisted Time\" by dr2 - https://www.shadertoy.com/view/XlsyWH\nI always wondered how he got the text to look so good, after stripping down the code, I now understand the technique!","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["raymarch","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// deep diving the  \"Twisted Time\" interesting (great looking) text technique by dr2 - https://www.shadertoy.com/view/XlsyWH\n// making this public incase anyone else wants to look at the stripped down code\n\nvec3 sunDir, vnCylIn;\nvec2   fntSize, qnFnt, qnTxt;\nfloat dstFar, rngBlk, bCylRad, bCylHt, dCylIn, dCylOut;\nint idTxt;\nconst float pi = 3.14159;\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvoid CylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, ai, b, w, ws, srdy;\n  dCylIn = dstFar;\n  dCylOut = dstFar;\n  vnCylIn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.)\n  {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.)\n    {\n      ai =  1. / a;\n      dCylIn = (- b - ws) * ai;\n      dCylOut = (- b + ws) * ai;\n    }\n    if (a > 0.)\n        s = ro + dCylIn * rd;\n    else\n        s.y = bCylHt;\n    if (abs (s.y) < bCylHt)\n        vnCylIn.xz = s.xz / bCylRad;\n    else if (srdy * ro.y < - bCylHt)\n    {\n      dCylIn = - (srdy * ro.y + bCylHt) / abs (rd.y);\n      if (length (ro.xz + dCylIn * rd.xz) < bCylRad)\n          vnCylIn.y = - srdy;\n      else\n          dCylIn = dstFar;\n    }\n    else\n        dCylIn = dstFar;\n      \n    if (dCylIn < dstFar)\n    {\n      if (a > 0.)\n          s = ro + dCylOut * rd;\n      else\n          s.y = bCylHt;\n      if (abs (s.y) > bCylHt && srdy * ro.y < bCylHt)\n         dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n    }\n  }\n}\n\n//int GetTxChar (int _nc)\n//{\n//    if( _nc>8 ) return 0;\n//    return int[9](0x53,0x48,0x41,\n//                  0x44,0x45,0x52,\n//                  0x54,0x4f,0x59)[_nc];\n//}\n// resorted to this because of the iPhone :)\nint GetTxChar (int _nc)\n{\n    if(_nc==0) return(0x53);\n    if(_nc==1) return(0x48);\n    if(_nc==2) return(0x41);\n    if(_nc==3) return(0x44);\n    if(_nc==4) return(0x45);\n    if(_nc==5) return(0x52);\n    if(_nc==6) return(0x54);\n    if(_nc==7) return(0x4f);\n    if(_nc==8) return(0x59);\n    return 0;\n}\n\nfloat FontTexDf (vec2 p)\n{\n  vec3 tx;\n  float d;\n  ivec2 ip = ivec2 (floor (p));\n  int ic = GetTxChar(idTxt);\n  if (ic != 0)\n  {\n    tx = texture (iChannel0, mod ((vec2 (mod (float (ic), 16.),\n       15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n    qnFnt = vec2 (tx.r, - tx.g);\n    d = tx.b + 1. / 256.;\n  }\n    else d = 1.;\n  return d;\n}\n\n\n// raymarch the text...\nfloat RayMarchText (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 srd, h;\n  float dHit, dLim, d;\n  //if (rd.x == 0.) rd.x = 0.001;\n  //if (rd.y == 0.) rd.y = 0.001;\n  //if (rd.z == 0.) rd.z = 0.001;\n  srd = - sign (rd.xy);\n  rdi = 1. / abs (rd.xyz);\n  dHit = 0.;\n  dLim = rngBlk;\n  ro.xy /= fntSize.x;\n  rd.xy /= fntSize.x;\n  ro.xy += 0.5;\n    \n  for (int j = 0; j < 150; j ++)\n  {\n    p = ro + dHit * rd;\n    p.y = mod(p.y,1.0);\t\t\t\t// repeat :)\n    h = rdi.xy * fract (srd * p.xy);\n    d = max (min (fntSize.x, 1.0) * FontTexDf (p.xy), abs (p.z) - 0.5 * fntSize.y);\n    dHit += min (d, 0.01 + fntSize.x * min (h.x, h.y));\n    if (d < 0.0001 || dHit > dLim)\n        break;\n  }\n  if (d >= 0.0001)\n      dHit = dstFar;\n  return dHit;\n}\n\n// box intersect\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n\n// either we check these for 0... or...\n//  if (rd.x == 0.) rd.x = 0.001;\n//  if (rd.y == 0.) rd.y = 0.001;\n//  if (rd.z == 0.) rd.z = 0.001;\n    \n  v = ro / rd;\n    \n  // ...use hacky \"solution\" to avoid propagating non-finite floats\n  v = clamp(v,-1e30, 1e30);\n    \n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df)\n  {\n    dMin = dn;\n    rngBlk = df - dn;\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n    \n  vec3 col, vn, qtTxt, tro, trd, trdd, q, qt, ds;\n  float dstTxt,  db, d, ang, angTxt, rad;\n  fntSize = vec2 (1.9, 1.);\n  dstTxt = dstFar;\n  tro = ro;\n  trd = rd;\n  rad = 7.;\n  bCylRad = rad + 0.6 * fntSize.x;\n  bCylHt = 3.0;\t\t\t\t\t\t// cylinder height\n  CylHit (ro, rd);\n\n  if (dCylIn < dstFar)\n  {\n    // run through 40 letters, marching each one... ouch!\n    for (float k = 0.; k < 40.; k ++)\n    {\n      idTxt = int (mod (k, 10.));\n      ang = 2. * pi * (1. - k / 40.);\n      qt = - vec3 (rad * sin (ang), 0., rad * cos (ang));\n      q = tro - qt;\n      q.xz = Rot2D (q.xz, ang);\n      trdd = trd;\n      trdd.xz = Rot2D (trdd.xz, ang);\n\n      db = BlkHit (q, trdd, vec3 (0.5 * fntSize.x, 3.0*(0.55 * fntSize.x), 0.55 * fntSize.y));\n      if (db < dstFar)\n      {\n        d = db + RayMarchText(q + db * trdd, trdd);\n        if (d < dstTxt)\n        {\n          dstTxt = d;\n          qtTxt = qt;\n          angTxt = ang;\n          qnTxt = qnFnt;\n        }\n      }\n    }\n  }\n    \n  // do the lighting...\n  col = vec3(0.2,0.3,0.2);\n  if (dstTxt < dstFar)\n  {\n    tro += trd * dstTxt;\n    ds = tro - qtTxt;\n    ds.xz = Rot2D (ds.xz, angTxt);\n    if (abs (ds.z) < 0.49 * fntSize.y)\n    {\n      vn = normalize (vec3 (qnTxt, 0.00001));\n      col = vec3 (0.7, 0.7, 0.7);      // extruded edges colour = grey\n    }\n    else\n    {\n      vn = vec3 (0., 0., sign (ds.z));\n      col = vec3 (1., 0.3, 0.3);      // front&back colour = red\n    }\n    vn.xz = Rot2D (vn.xz, - angTxt);\n    col = col * (0.2 + 0.8 * max (dot (sunDir, vn), 0.)) +\n       0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    //col = mix (col, BgCol (tro, reflect (rd, vn)), 0.7 - 0.5 * abs (dot (rd, vn)));\n  }\n\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    \n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = fract(iTime*0.1)*6.28;\n  el = sin(iTime)*0.1;\n  if (mPtr.z > 0.)\n  {\n    az = 2. * pi * mPtr.x;\n    el = 0.4 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, 0.1 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.1));\n  ro = vuMat * vec3 (0., 0., -14.);\n  sunDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n  dstFar = 100.;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}