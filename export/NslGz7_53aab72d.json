{"ver":"0.1","info":{"id":"NslGz7","date":"1615724546","viewed":252,"name":"Polygon intersect","username":"kastorp","description":"Simple polygon intersection algorithm. \nBased on Oneshade polygon clipping algorithm:   https://www.shadertoy.com/view/sdXGz7 by Oneshade\n","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["triangle","geometry","polygon","algorithm","clipping"],"hasliked":0,"parentid":"sdXGz7","parentname":"Polygon Clipping Algorithm"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nSimple polygon intersection algorithm. \n\nthe core of the code is from ONESHADE \"polygon clipping algorithm\":   https://www.shadertoy.com/view/sdXGz7 by Oneshade\n\nClipping polygon should be counterclockwise and convex\n\n*/\n\n#define MP 12 //maximum polygon size (adjust as needed)\n\n\n\n// Drawing utilities\nvoid drawPoint(inout vec3 pixel, in float unit, in vec2 p, in vec2 pos, in float size, in vec3 color) {\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, length(p - pos) - size));\n}\n\nvoid drawLine(inout vec3 pixel, in float unit, in vec2 p, in vec2 a, in vec2 b, in float thickness, in bool inf, in vec3 color) {\n    vec2 pa = p - a, ba = b - a;\n    float proj = dot(pa, ba) / dot(ba, ba);\n    if (!inf) proj = clamp(proj, 0.0, 1.0);\n    float d = length(pa - ba * proj) - thickness;\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, d));\n}\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\nvoid drawChars(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, int nChars, int[8] chars) {   \n    for(int i=0;i<nChars;i++) drawChar( color,charColor,  p, pos+vec2(i,0)*size*.5, size, chars[i]);\n}\n\n\n//Iq SDF\nfloat sdPolygon( in vec2 p, in vec3[MP] v ,int num)\n{\n    \n    float d = dot(p-v[0].xy,p-v[0].xy);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        vec2 e = v[j].xy - v[i].xy;\n        vec2 w =    p - v[i].xy;\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 cond = bvec3( p.y>=v[i].y,  p.y <v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }  \n    return s*sqrt(d);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    // Previous and current mouse positions\n    vec2 pMouse, mouse;\n    if (iMouse.z > 0.0) {\n        pMouse = (abs(iMouse.zw) - center) / iResolution.y;\n        mouse = (iMouse.xy - center) / iResolution.y;\n    }\n\n    else {\n        float c = cos(iTime), s = sin(iTime);\n        mouse = vec2(c, c * s) * 0.5;\n\n        float pTime = iTime - 1.0;\n        c = cos(pTime), s = sin(pTime);\n        pMouse = vec2(c, c * s) * 0.5;\n    }\n\n    // Normalized screen coordinates, pixel size, and pixel color\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float unit = .004;\n\n    \n    // Original polygon\n    vec3[MP] poly ;   //xy=coords, z=polygon id\n    int pSize=6;\n    for(int i=0;i<pSize;i++) poly[i]=texelFetch(iChannel0,ivec2(0,i+1),0).xyz;\n\n         \n    //define clipping square     \n    int nClipping=5;         \n    vec3[MP] clipping; //xy=coords, z=polygon id\n    for(int i=0;i<nClipping;i++) clipping[i]=texelFetch(iChannel0,ivec2(1,i+1),0).xyz;\n     \n     //  Clipped polygon \n    vec3[MP] clipped; \n    int nClip = int(texelFetch(iChannel0,ivec2(2,0),0).x);\n    for(int i=0;i<nClip;i++) clipped[i]=texelFetch(iChannel0,ivec2(2,i+1),0).xyz;\n    \n     vec3 color = vec3(.2)*step(.5,float(nClip));\n     // Draw poly border\n    color=mix(color,vec3(0,1,0),smoothstep(unit, 0.0,-unit+abs(sdPolygon(uv,poly,pSize))));\n\n    //display clipping square\n    color=mix(color,vec3(0,0,1),smoothstep(unit, 0.0,sdPolygon(uv,clipping ,nClipping)));\n\n    bool inside=true,outside=true;\n    //draw clipped poly\n    if(nClip>0){\n        float dis=sdPolygon(uv,clipped,nClip);\n        color=mix(color,vec3(1,1,0),smoothstep(unit, 0.0,dis));\n        color=mix(color,vec3(1,0,0),smoothstep(unit, 0.0,-unit+abs(dis)));\n        \n        for( int i=0;i<nClip;  i++ ) {\n            drawPoint(color,  unit, uv, clipped[i].xy, unit*3., cos(clipped[i].z*2.+vec3(0,2,4)));\n            drawChar(color, vec3(1.0), uv, clipped[i].xy-vec2(unit*5.), vec2(unit*12.), (i>8?56:49)+i);\n            if(clipped[i].z!=1.) inside=false;\n            if(clipped[i].z!=2.) outside=false;\n\n        }\n        if(outside ) {\n           if(color==vec3(.2)) color*=vec3(1,1,2);\n            drawChars(color, vec3(0), uv, vec2(0.), vec2(unit*12.), 7,int[8](79,85,84,83,73,68,69,0));\n        }\n        else if(inside ) {\n            if(color==vec3(.2)) color*=vec3(1,2,1);\n            drawChars(color, vec3(0), uv, vec2(0.), vec2(unit*12.), 6,int[8](73,78,83,73,68,69,0,0));\n        } \n\n    } \n    \n\n    fragColor = vec4(color , 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nSimple polygon intersection algorithm. \n\nthe core of the code is from ONESHADE \"polygon clipping algorithm\":   https://www.shadertoy.com/view/sdXGz7 by Oneshade\n\nClipping polygon should be counterclockwise and convex\n\n*/\n\n#define MP 12 //maximum polygon size (adjust as needed)\n#define REDUCE 1e-8 //remove redundant vertexes\n#define POLDIR 1 //1=counterclockwise, 0= clockwise\nfloat cross2d(vec3 a, vec3 b) {return cross(vec3(a.xy,0.),vec3(b.xy,0.)).z;  }\nfloat dot2d(vec2 a){return dot(a,a);}\nfloat dot2d(vec3 a){return dot(a.xy,a.xy);}\n\n\n//Oneshade polygon clipping algorithm\nint clipPoly(vec3 clipA , vec3 clipB,in vec3[MP] poly, int num, inout vec3[MP] clipped)\n{\n    vec2 clipTan = clipB.xy - clipA.xy;          // Clip tangent\n    vec2 clipPerp = vec2(-clipTan.y, clipTan.x); // Clip normal\n\n    int nClip = 0;                   // Number of vertices in the clipped polygon\n\n    for (int v=1; v < num + 1; v++) {\n        vec2 e1 = poly[v - 1].xy - clipA.xy, e2 = poly[v % num].xy - clipA.xy;\n        float dot1 = dot(e1, clipPerp), dot2 = dot(e2, clipPerp);\n        if (dot1 >= 0.0) {\n            clipped[nClip] =  poly[v - 1];//e1 + clipA;\n            nClip++;\n        }\n\n        if ((dot1 >= 0.0) != (dot2 >= 0.0)) {\n            // Relative to clipping line\n            vec2 rel1 = vec2(dot(e1, clipTan), dot1);\n            vec2 rel2 = vec2(dot(e2, clipTan), dot2);\n\n            // Solve for zero and transform back to world space\n            float zero = rel1.x - rel1.y / (rel2.y - rel1.y) * (rel2.x - rel1.x);\n            float det = clipTan.x * clipPerp.y - clipTan.y * clipPerp.x;\n            vec2 clipPos = vec2(clipPerp.y, -clipPerp.x) * zero / det + clipA.xy;\n            \n            // Add to clipped vertices\n            clipped[nClip] = vec3(clipPos,\n                dot2d(clipPos-clipA.xy)<.0001?clipA.z:\n                dot2d(clipPos-clipB.xy)<.0001?clipB.z:0.\n                );\n            nClip++;\n        }\n    }\n    return nClip;\n\n}\n\nint intersectPoly(in vec3[MP] poly, int nPoly,in vec3[MP] clipping, int nClipping,  inout vec3[MP] clipped)\n{\n    int nClipT = nPoly, nClip=0;\n    \n    vec3[MP] clippedT=poly;    \n    for(int i=0;i< nClipping;i++)\n    nClipT =clipPoly(  clipping[(i+1-POLDIR)%nClipping],  clipping[(i+POLDIR)%nClipping],  clippedT,  nClipT ,  clippedT);\n    \n\n#ifdef REDUCE\n    for( int i=0;i<nClipT;  i++ ) {      \n       if(          \n            abs(cross2d(\n                clippedT[(i-1+nClipT)%nClipT]-clippedT[i],\n                clippedT[(i+1)%nClipT]-clippedT[i]            \n            ))>REDUCE &&\n           !(dot2d(clippedT[(i-1+nClipT)%nClipT]-clippedT[i])<REDUCE\n             &&  dot2d(clippedT[(i-2+nClipT)%nClipT]-clippedT[(i+1)%nClipT])<REDUCE\n           ) &&           \n           !(dot2d(clippedT[(i+1)%nClipT]-clippedT[i])<REDUCE\n              &&  dot2d(clippedT[(i-1+nClipT)%nClipT]-clippedT[(i+2)%nClipT])<REDUCE\n           )\n       ){\n           clipped[nClip++]=clippedT[i];          \n       }      \n    }\n#else\n    nClip=nClipT;\n    clipped=clippedT;\n#endif    \n    return nClip;\n}\n\n\n\n\n\nvoid mainImage(out vec4 O, in vec2 U) {\n\n ivec2 ui=ivec2(U);\n if(ui.x>=4 || ui.y>12) discard;\n \n    vec2 center = 0.5 * iResolution.xy;\n    vec2 pMouse, mouse;\n    if (iMouse.z > 0.0) {\n        pMouse = (abs(iMouse.zw) - center) / iResolution.y;\n        mouse = (iMouse.xy - center) / iResolution.y;\n    }\n\n    else {\n        float c = cos(iTime), s = sin(iTime);\n        mouse = vec2(c, c * s) * 0.5;\n\n        float pTime = iTime - 1.0;\n        c = cos(pTime), s = sin(pTime);\n        pMouse = vec2(c, c * s) * 0.5;\n    }\n    \n    // Original polygon\n    vec3[MP] poly ;   //xy=coords, z=polygon id\n    int sPoly=6;\n    poly[0]=vec3(.5,-.25,2);\n    poly[1]=vec3(-.5,-.25,2);\n    poly[2]=vec3(-.25,0,2);\n    poly[3]=vec3(-.5,.25,2);\n    poly[4]=vec3(.5,.25,2);\n    poly[5]=vec3(.25, 0,2);\n\n    // Begin clipping\n    vec2 clipA = pMouse, \n         clipB = mouse, // Clipping line control points\n         clipTan = clipB - clipA,                // Clip tangent\n         clipPerp = vec2(-clipTan.y, clipTan.x); // Clip normal\n         \n    //define clipping square     \n    int sClipping=5;         \n    vec3[MP] clipping; //xy=coords, z=polygon id\n    clipping[0]=vec3(clipA,1);\n    clipping[1]=vec3(clipA + clipTan,1);\n    clipping[2]=vec3(clipA + clipTan + clipPerp*.5,1);\n    clipping[3]=vec3(clipA + clipTan*.5 +clipPerp,1);\n    clipping[4]=vec3(clipA + clipPerp*.5,1);\n    \n     // calculate Clipped polygon \n    vec3[MP] clipped; \n    int sClipped = intersectPoly( poly, sPoly,clipping, sClipping,  clipped);\n    \n    \n   \n    vec3[MP] cPoly=poly;\n    if(ui.x==1) cPoly=clipping;\n    if(ui.x==2) cPoly=clipped;\n    \n    int cSize=(ui.x==0? sPoly:ui.x==1? sClipping:sClipped); \n    if(ui.y==0)  O=vec4(cSize);\n    else O=vec4(cPoly[ui.y-1],0);\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}