{"ver":"0.1","info":{"id":"lXsBDX","date":"1729018506","viewed":192,"name":"circular space partitioning","username":"dottedboxguy","description":"circular repetition/partitioning of space via normal quantization, it's pretty expensive but it's what you gotta do to make circles...\nthough i believe it's faster than the one in mercury's sdf lib","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["sdf","spacerepetition","spacepartitioning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PI_INV 0.31830988618\n\n\n// use it as you wish !\n// if you're smart about it you can completely offset the normals based on their ID and still get an accurate DF\nvec2 quantized_circle(vec2 p, float r, float n){\n\n    float angle = atan(p.y, p.x); // angle from the x axis\n    \n    //quantization of the normal's angle.\n    angle *= .5*n*PI_INV;\n    angle = round(angle);\n    angle *= 2.*PI/n;\n    \n    return r*vec2(cos(angle), sin(angle)); //reconstructing the normal\n}\n\n\nfloat scene(vec2 p){\n    vec2 point = quantized_circle(p, 2.5+1.7*cos(iTime*.5+.29), ceil(iTime+1.001));\n    float d = length(p-point);\n    return d - .1;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv*=10.;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m-=.5;\n    m.x *= iResolution.x/iResolution.y;\n    m*=10.;\n\n    float d = scene(uv);\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(80.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.03,abs(d)));\n    \n    float d_m = scene(m);\n    \n    d = length(uv-m)-abs(d_m);\n    \n    col = mix(vec3(.9, .9, .1), col, clamp(abs((d)*20.), 0.,1.));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}