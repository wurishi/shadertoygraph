{"ver":"0.1","info":{"id":"mlsBDl","date":"1694990466","viewed":80,"name":"Stylized Sunset over the Sea","username":"kastanileel","description":"☀️^^","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","waves","water","sin","sine","stylized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 nPlane= vec4(0, 1., 0., 2.2);\nfloat iSpecular = .6;\nfloat iDiffuse = .3;\nfloat iAmbient = .1;\n\n// SDF for ocean\nfloat sdfPlane( vec3 p, vec4 n ){\n\n  // Num of waves\n  const int num_waves = 6;  \n\n  // Modify frequencies and amplitudes to change water\n  float frequencies[num_waves] = float[](.2, .3, .5, .7, 1., 2.);\n  float amplitudes[num_waves] = float[](0.6, 0.4, 0.3, 0.1, 0.004, 0.001);\n\n  // Wave direction\n  vec2 waveDirection = normalize(vec2(.6, .6));\n\n  //calculate wave \n  float result = 0.0;\n  for(int i = 0; i < 6; i++) {\n      float freq = float(i) + 1.;\n      vec2 waveFront = frequencies[i] * vec2(p.x * waveDirection.x, p.z * waveDirection.y) + iTime;\n      result += amplitudes[i] * (sin(2.*waveFront.x)  + sin(2. * waveFront.y)*2.) *.5;\n  }\n  \n  // sdf formula for plane + wave height\n  return dot(p,normalize(n.xyz)) + n.w + result;\n}\n\n\n// SDF for sun\nfloat sdfCircle(vec2 p){\n\n    float radius = .4;\n    vec2 center = vec2(.0, .5);\n    \n    return length(p-center) - radius;\n\n}\n\n\nvec3 getNormalWave(vec3 p){\n\n  vec2 offset = vec2(0.001, 0);\n      \n  float gradX = sdfPlane(p + offset.xyy, nPlane) - sdfPlane(p - offset.xyy, nPlane);\n  float gradY = sdfPlane(p + offset.yxy, nPlane) - sdfPlane(p - offset.yxy, nPlane);\n  float gradZ = sdfPlane(p + offset.yyx, nPlane) - sdfPlane(p - offset.yyx, nPlane);\n\n  return normalize(vec3(gradX, gradY, gradZ));\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 lightRay = normalize(vec3(0., 1.0, -1.));\n    vec3 waterCol = vec3(.1, .2, .8);\n    \n    vec3 col = vec3(.0);\n    \n    //origin of rays\n    const vec3 ro = vec3(0., .7, 8.);\n    //normalized direction of rays\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n    \n    \n    float fogFactor;\n    float totalMarchedDist = .0;\n    bool hit = false;\n    \n    for(int i = 0; i< 200; i ++){\n    \n        float it = float(i);\n        vec3 rayPos = ro + (totalMarchedDist + 0.001 * it *it )* rd;\n        \n        float dist = sdfPlane(rayPos, nPlane);\n        totalMarchedDist += dist;\n        \n        // ray march hit\n        if(dist < .001){\n        \n            // phong shading\n            vec3 normal = getNormalWave(rayPos);\n            float diffuseLight = dot(normal, vec3(lightRay.xy, lightRay.z));\n            float specularLight = dot(reflect(lightRay,normal), normalize(rayPos - ro));\n            specularLight = pow(specularLight, 12.);\n            specularLight = iSpecular * max(specularLight, 0.);\n            diffuseLight = iDiffuse * max(diffuseLight, 0.);\n            \n            float light =   iAmbient + diffuseLight + specularLight;\n            \n            col=waterCol * light;\n            hit = true;\n            \n            if(totalMarchedDist > 160.)\n                hit = false;\n     \n            break;\n        }\n        \n    hit = false;\n    fogFactor = pow(0.0215 *it, 2.5);  \n    \n    }\n   \n    fragColor = vec4(mix(col ,vec3(1., (uv.y * uv.y)/1.1, .0) ,fogFactor) ,1.0);\n    \n    // ray didnt hit plane => calculate sky\n    if(!hit){\n    \n        float d = sdfCircle(uv);\n        d = max(0., d);\n        d = smoothstep(d,0.0f, 0.05f);\n        d = 1.0f-d;\n        \n       \n        vec4 skyCol = vec4(mix(vec3(.1, .1, 1.), vec3(1., .2, 0.1), 1. - (2.*uv.y) + 1.2),.5);\n        fragColor = vec4(mix(vec3(1., (uv.y * uv.y)/.9, .1), skyCol.xyz,1.-d), 1.);\n        \n    } \n}","name":"Image","description":"","type":"image"}]}