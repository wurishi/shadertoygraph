{"ver":"0.1","info":{"id":"7tByzR","date":"1649013770","viewed":68,"name":"My attempt of learning shaders","username":"lukasino1214","description":"Learning shaders","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera {\n    vec3 position;\n    vec3 direction;\n    float canvasPosition; \n} camera;\n\nstruct Sphere {\n    vec3 color;\n    vec3 position;\n    float radius;     \n};\n\n#define NUM_SPHERES 2\nSphere spheres[NUM_SPHERES];\n\nstruct Plane {\n    vec3 position;\n    vec3 normal;\n} plane;\n\nstruct Light {\n\tvec3 direction;    \n} light;\n\nstruct Material {\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n} material;\n\nvoid setupScene() {\n    camera.position = vec3(0., 0., 3.5);\n    camera.direction = vec3(0., 0., -1.);\n    camera.canvasPosition = 2.7;\n    \n    spheres[0].position = vec3(0.5, 0., 2.2);\n    spheres[0].radius = 0.3;\n    spheres[0].color = vec3(0.9, 0.2, 0.3);\n    \n    spheres[1].position = vec3(-0.5, 0., 2.2);\n    spheres[1].radius = 0.3;\n    spheres[1].color = vec3(0.9, 0.2, 0.3);\n    \n    light.direction = normalize(vec3(0., -1., -0.78));\n    \n    material.ambience = 0.2;\n    material.diffuse = 0.7;\n    material.specular = 1.0;\n    material.shininess = 10.0;    \n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1) {\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.) {\n        return false;\n    } \n    \n    if (disc == 0.) {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nbool intersect(vec3 direction, out vec3 surfaceNormal, vec3 position, float radius) {\n    vec3 L = camera.position - position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1)) {\n        float t = t0;\n        if (t1 < t0) {\n            t = t1;\n        }\n        \n        vec3 Phit = camera.position + t * direction;\n        surfaceNormal = normalize(Phit - position);\n        \n        return true;\n    }  \n     \n    return false;\n}\n\nvec3 rayTrace(vec3 direction) {\n    for(int i = 0; i < NUM_SPHERES; i++) {\n        vec3 surfaceNormal;\n\n        if (intersect(direction, surfaceNormal, spheres[i].position, spheres[i].radius)) {\n            float coeff = -dot(light.direction, surfaceNormal);                          \n\n            vec3 reflectedRay = reflect(direction, surfaceNormal);\n            vec3 reflectedColor = texture(iChannel0, reflectedRay).rgb;\n            spheres[i].color = mix(spheres[i].color, reflectedColor, material.specular);\n\n\n            // Phong\n            vec3 ambient = material.ambience * spheres[i].color;\n            vec3 diffuse = material.diffuse * max(coeff, 0.) * spheres[i].color;\n\n            float shininess = pow(max(-dot(direction, reflect(light.direction, surfaceNormal)), 0.), material.shininess);\n            vec3 specular = material.specular * shininess * spheres[i].color;\n\n            return ambient + diffuse + specular;\n        }\n\n    }\n    \n    return texture(iChannel0, direction).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {        \n    setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 direction = normalize(vec3(uv, camera.canvasPosition) - camera.position);\n    \n    spheres[0].position.y = sin(iTime * 2.0) / 4.0;\n    spheres[1].position.y = sin(-iTime * 2.0) / 4.0;\n    \n    \n    light.direction.x = -(iMouse.x / iResolution.x - 0.5);\n    light.direction.y = -(iMouse.y / iResolution.y - 0.5);\n    light.direction = normalize(light.direction);\n    \n    \n    \n    vec3 col = rayTrace(direction);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}