{"ver":"0.1","info":{"id":"lfXGDf","date":"1703616075","viewed":41,"name":"Weird ball","username":"FrederickAmpsUp","description":"ooo fancy\nwhy is this so slow lol","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"ml3czj","parentname":"messing with ray marching"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks to https://www.shadertoy.com/view/ls3GWS\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    \n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    vec3 col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n    \n    fragColor = vec4( col, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\n// Data structures\n\nstruct MarchParams {\n    int steps;\n    float surf,miss;\n};\n\nstruct Ray {\n    vec3 o,d;\n};\nvec3 at(Ray r, float t) { return r.o+r.d*t; }\n\nstruct Interval {\n    float start,end;\n};\n\nstruct Material {\n    vec3 col;\n    vec3 emission;\n    \n    float specular;\n};\n\n// Signed distance functions / ray-marching utils\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(p-c)-r;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 rotateY(in vec3 p, in float t) {\n    float cosT = cos(t), sinT = sin(t);\n    return vec3(p.x * cosT - p.z * sinT, p.y, p.x * sinT + p.z * cosT);\n}\nvec3 translate(in vec3 p, in vec3 t) {\n    return p-t;\n}\nvec3 repeatX(in vec3 p, in float size) {\n    return vec3(p.x - size*round(p.x/size), p.yz);\n}\nvec3 repeatY(in vec3 p, in float size) {\n    return vec3(p.x, p.y - size*round(p.y/size), p.z);\n}\nvec3 repeatZ(in vec3 p, in float size) {\n    return vec3(p.xy, p.z- size*round(p.z/size));\n}\n\nfloat smin(float a, float b, float k) {\n    return 0.5 * ((a + b) - sqrt((a-b)*(a-b)+k));\n}\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat time;\n\n// RNG stuff\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat lerp(float a, float b, float k) { return mix(a,b,k); }\n\nfloat noise( vec3 x ) {\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),\n        lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),\n        lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\nfloat noise(float x) {\n    return noise(vec3(x, 0.0, 0.0));\n}\n\nvec3 woodColor(vec3 p) {\n    // Wood texture parameters\n    float frequency = 5.0;\n    float lacunarity = 2.0;\n    float persistence = 0.5;\n    int octaves = 5;\n\n    // Initial color\n    vec3 color = vec3(0.545, 0.271, 0.075); // Brown color\n\n    // Generate wood texture using Perlin noise\n    for (int i = 0; i < octaves; i++) {\n        float woodNoise = noise(p * frequency * vec3(1.0, 1.0, 0.1));\n        color += woodNoise * vec3(0.15, 0.1, 0.05); // Modulate color based on noise\n        frequency *= lacunarity;\n        p *= lacunarity;\n    }\n\n    // Adjust color intensity\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n// Scene SDF\nfloat map(in vec3 p, out Material mat) {\n    mat.col = vec3(0.61, 0.55, 0.16);\n    mat.emission = vec3(0.0);\n    mat.specular = 0.5;\n    \n    float dist;\n    dist = sdSphere(p, vec3(0,0,0), 1.0);\n    vec3 pRot0 = rotateY(p,             p.y * 2.0 + time);\n    vec3 pRot1 = rotateY(p, 0.25 * PI + p.y * 2.0 + time);\n    vec3 pRot2 = rotateY(p, 0.5  * PI + p.y * 2.0 + time);\n    vec3 pRot3 = rotateY(p, 0.75 * PI + p.y * 2.0 + time);\n    \n    #define CUTOUT_WIDTH 0.1\n\n    dist = smax(dist, -sdBox(pRot0, vec3(CUTOUT_WIDTH, 1.0, 1.0)), 0.001);\n    dist = smax(dist, -sdBox(pRot1, vec3(CUTOUT_WIDTH, 1.0, 1.0)), 0.001);\n    dist = smax(dist, -sdBox(pRot2, vec3(CUTOUT_WIDTH, 1.0, 1.0)), 0.001);\n    dist = smax(dist, -sdBox(pRot3, vec3(CUTOUT_WIDTH, 1.0, 1.0)), 0.001);\n\n    \n    float dstInner = sdSphere(p, vec3(0), 0.95);\n    if (dstInner < dist) {\n        mat.emission = vec3(1.0);\n        mat.specular = 0.0;\n        mat.col = vec3(0.0);\n        dist = dstInner;\n    }\n    \n    if (p.y + 1.0 < dist) {\n        mat.emission = vec3(0.0);\n        mat.col = woodColor(p);\n        mat.specular = 0.0;\n        dist = p.y + 1.0;\n    }\n    \n    return dist;\n}\n\n// Marching function\nfloat march(in MarchParams p, in Ray r, in Interval i, out Material mat, out int stp) {\n    vec3 pos;\n    float t = i.start;\n    for (stp = 0; stp < p.steps; ++stp) {\n        pos = at(r,t);\n        float scene = map(pos, mat);\n        \n        if (scene < p.surf || scene > p.miss || t > i.end) return t;\n        t += scene;\n    }\n    \n    return t;\n}\n\nfloat march(in MarchParams p, in Ray r, in Interval i, out Material mat) {\n    int steps;\n    return march(p, r, i, mat, steps);\n}\n\n// Soft shadows\nfloat shadow(in MarchParams p, in Ray r, in Interval i, in float lightSize) {\n    float res = 1.0;\n    float t = i.start;\n    float maxt = i.end; // field selectors don't work in for loops ig\n    Material mat;\n    for( int i=0; i<p.steps && t<maxt; i++ ) {\n        float h = map(at(r,t), mat);\n        res = min( res, h/(lightSize*t) );\n        t += clamp(h, 0.005, 0.50);\n        if(res<-1.0) break;\n    }\n    res = max(res,-1.0);\n    if (res != res) return 1.0;\n    float final = 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    return final;\n}\n\n// Ambient occlusion\nfloat ambientOcc(vec3 point, vec3 normal, float step_dist, float step_nbr)\n{\n    float occlusion = 1.0f;\n    while(step_nbr > 0.0) {\n        Material _mat;\n        occlusion -= pow(step_nbr * step_dist - (map( point + normal * step_nbr * step_dist, _mat)),2.0) / step_nbr;\n        step_nbr--;\n    }\n\n    return occlusion;\n}\n\n// Get a normal\nvec3 normal(in vec3 pos) {\n    float epsilon = 0.001;\n    Material _col;\n    return normalize(\n        vec3(\n            map(pos + vec3(epsilon, 0, 0), _col) - map(pos - vec3(epsilon, 0, 0), _col),\n            map(pos + vec3(0, epsilon, 0), _col) - map(pos - vec3(0, epsilon, 0), _col),\n            map(pos + vec3(0, 0, epsilon), _col) - map(pos - vec3(0, 0, epsilon), _col)\n        )\n    );\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AMBIENT vec3(.1)\n\n#define LIGHT_POS vec3(3,5,-3)\n#define LIGHT_COL vec3(1.0)\n\n#define LIGHT_BOUNCES 2\n\n// Different maps. Uncommenting these will show different components of the final render.\n//#define AO_MAP\n//#define SHADOW_MAP\n//#define LIGHT_MAP\n//#define COLOR_MAP\n//#define NORMAL_MAP\n//#define POS_MAP\n\nvec3 rayCol(inout Ray r, out Material mat) {\n    MarchParams p = MarchParams(256, 0.00005, 1000.0);\n    \n    int steps;\n    float dist = march(p, r,\n        Interval(0.0, 1000.0), mat, steps);\n        \n    bool hit = dist < p.miss;\n    if (!hit) {\n        return vec3(0.0); // TODO: sky\n    }\n    \n    vec3 hitPos = at(r, dist);\n    vec3 hitNorm = normal(hitPos);\n    \n    r.o = hitPos + hitNorm * 0.005;\n    r.d = reflect(r.d, hitNorm); // bounce ray\n    \n    vec3 col = AMBIENT * mat.col;\n    \n    vec3 dirToLight = normalize(LIGHT_POS - hitPos);\n    \n    float lighting = max(dot(hitNorm, dirToLight), 0.0);\n    float shadows  = shadow(p, Ray(hitPos, dirToLight), Interval(p.surf, 1000.0), 0.2);\n    col += LIGHT_COL * mat.col * lighting * shadows;\n    float ao = max(pow(ambientOcc(hitPos, hitNorm, .006, 20.0), 40.0), 0.1);\n    col *= ao;\n    \n    col += mat.emission;\n    \n#ifdef AO_MAP\n    col = vec3(ao);\n    mat.specular = 0.0;\n    col = pow(col, vec3(2.2));\n#endif\n\n#ifdef SHADOW_MAP\n    col = vec3(shadows);\n    mat.specular = 0.0;\n    col = pow(col, vec3(2.2));\n#endif\n\n#ifdef LIGHT_MAP\n    col = vec3(lighting);\n    mat.specular = 0.0;\n    col = pow(col, vec3(2.2));\n#endif\n\n#ifdef COLOR_MAP\n    col = vec3(mat.col + mat.emission);\n    mat.specular = 0.0;\n    col = pow(col, vec3(2.2));\n#endif\n\n#ifdef NORMAL_MAP\n    col = vec3(hitNorm);\n#endif\n\n#ifdef POS_MAP\n    col = vec3(hitPos);\n    mat.specular = 0.0;\n    col = pow(col, vec3(2.2));\n#endif\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime; // get time in common without errors\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    rayDir = rotateY(rotateY(rotateY(rayDir.xzy, noise(time * 2.0 + 500.0) * 0.1).zxy, sin(iTime) / 3.0 + 0.1).yxz, iTime / 1.5 + 0.5*PI);\n    vec3 camShake = vec3(noise(time), noise(time + 1000.0), noise(time + 2000.0)) * 0.1;\n    Ray r = Ray(vec3(cos(iTime/1.5)*2.5, sin(iTime) / 2.0 + 0.5, sin(iTime/1.5)*2.5) + camShake, rayDir);\n    Material mat;\n    vec3 col = rayCol(r, mat);\n    float accumSpecular = 1.0;\n    \n    for (int bounce = 0; bounce < LIGHT_BOUNCES; bounce++) {\n        accumSpecular *= mat.specular;\n        col += rayCol(r, mat) * accumSpecular;\n    }\n    \n\n    fragColor = vec4(col, 1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}","name":"Buffer A","description":"","type":"buffer"}]}