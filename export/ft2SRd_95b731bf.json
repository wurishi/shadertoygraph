{"ver":"0.1","info":{"id":"ft2SRd","date":"1628469898","viewed":140,"name":"It's Britneys All the Way Down","username":"milkfat","description":"I've been playing around looking for efficient ways of making trees. At this point I realized I had some handy UV coordinates.\n\nVery basic mouse control: X-axis controls the angular multiplier, Y-axis controls the radial base","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["treelogarithmicpolarinfinite"],"hasliked":0,"parentid":"7l2Xz3","parentname":"play 8britney mf 2021/08/06"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SS 3.0  //super sampling\n\n#define iR iResolution\n\nconst float PI = 355./113.;\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x-sin(a)*p.y,sin(a)*p.x+cos(a)*p.y);}\n\nvec4 obj2(vec2 uv)\n{\n    float time = pow(3.0,iTime);\n    uv*=1.5*(iR.x/iR.y);                                      //scale to screen\n    uv.xy = rotate(uv.xy,.05*sin(iTime+atan(uv.x,uv.y)*4.));  //wavy motion \n    float s = sign(uv.x);\n    uv.x=abs(uv.x);                                           //mirror x-axis\n    \n    float a = length(uv)+.5;                        //pixel distance from center\n    if(a>2.0)return vec4(0,0,0,0);                  //mask values beyond infiniti\n    float my = iMouse.y/iR.y;                       //mouse control y-axis\n    my=(iMouse.z>0.0)?1.0-pow(1.0-(my*.3),10.0):.6; \n    float rad = log(2.0-a)/log(my)+1.0;             //number of rings grows logarithmically\n    float am = floor(rad);                          //quantize radius into discrete rings\n    \n    float am2 = pow(2.0,am);                  //number of divisions grows exponentially as rings get larger\n    float mx = iMouse.x/iR.x;                 //mouse control x-axis\n    am2*=(iMouse.z>0.0)?pow(mx,10.0)*10.0:.7;                   \n    float circ = atan(uv.x,uv.y)*am2;         //pixel angle\n    float b0 = round(circ);                   //quantize circumference into discrete slices\n    \n    float u = circ-b0;\n    float v = 1.0-fract(rad);\n    float g = 1.0-2.0*mod(floor(b0),2.0); //two groups (1 and -1)\n    return vec4(u*s+.5,v,1.0,g);\n}\n\nvec4 get_color(vec2 p)\n{\n    vec4 F;\n    vec4 obj = obj2(p);\n    vec2 uv = obj.xy;\n    uv.y=-uv.y;\n    F=texture(iChannel0,fract(uv));\n    \n    F=pow(F,vec4(2.2));\n    F*=obj.z;\n    if(obj.w>0.0)F=vec4(.03,0,0,1.0);\n    return F;\n}\n\nvoid mainImage( out vec4 F, in vec2 C )\n{  \n    F=vec4(0);\n    vec2 uv = (C-vec2(iR.x*.5,0))/iR.xy; //bottom center of screen = (0,0)\n    uv.y*=iR.y/iR.x;                     //square pixels\n    \n    for(float y = 0.0; y < SS; y++) //super sampling\n    {\n        for(float x = 0.0; x < SS; x++)\n        {\n            F+=get_color(uv+vec2((x/SS)/iR.x,(y/SS)/iR.x));\n        }\n    }\n    \n    F/=SS*SS;\n    F=pow(F,vec4(1./2.2));\n    \n    \n}","name":"Image","description":"","type":"image"}]}