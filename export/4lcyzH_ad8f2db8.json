{"ver":"0.1","info":{"id":"4lcyzH","date":"1531440395","viewed":197,"name":"AttemptAtReflections","username":"agordeevw","description":"Raymarching with simple shadows and reflections.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------\n//  Camera\n// ----------------------------------------\n\nstruct Camera\n{\n  float fov;\n  vec3 position;\n  vec3 forward;\n  vec3 up;\n};\n\nconst Camera initialCamera = Camera(\n  90.0f / 180.0f * 3.141526f,\n  vec3(0.6f, 1.0f, 0.6f),\n  normalize(vec3(-1.0f, -1.0f, -1.0f)),\n  normalize(vec3(0.0f, 1.0f, 0.0f)));\n\nCamera camera = Camera(\n  initialCamera.fov,\n  initialCamera.position,\n  initialCamera.forward,\n  initialCamera.up);\n\nvoid updateCamera()\n{\n  float cameraY = 0.5f + 0.4f * sin(0.5f * iTime);\n  const float cameraDistance = 0.70f;\n  camera.position = vec3(cameraDistance * cos(iTime), cameraY, cameraDistance * sin(iTime));\n  camera.forward = normalize(vec3(0.0f, 0.2f, 0.0f) - camera.position);\n}\n\n// ----------------------------------------\n//  Materials\n// ----------------------------------------\n\nstruct Material\n{\n  vec3  diffuse;\n  vec3  specular;\n  float specPower;\n  float reflectance;\n};\n\nconst Material materials[] = Material[](\n  Material(vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 1.0f, 1.0f), 64.0f, 0.75f),\n  Material(vec3(0.8f, 0.0f, 0.15f), vec3(1.0f, 1.0f, 1.0f), 16.0f, 0.0f),\n  Material(vec3(0.1f, 0.1f, 0.1f), vec3(1.0f, 1.0f, 1.0f), 64.0f, 0.85f)\n);\n\n// ----------------------------------------\n//  Lighting\n// ----------------------------------------\nconst vec3 ambient        = vec3(0.05f, 0.05f, 0.05f);\nconst vec3 lightDirection = normalize(vec3(0.0f, -1.0f, -1.0f));\nconst vec3 lightDiffuse   = vec3(1.0f, 1.0f, 1.0f);\nconst vec3 lightSpecular  = vec3(1.0f, 1.0f, 1.0f);\n\nvec3 skyColor(vec3 direction)\n{\n  const vec3 top = vec3(0.2f, 0.4f, 0.8f);\n  const vec3 mid = vec3(1.0f, 1.0f, 1.0f);\n  const vec3 bot = vec3(0.1f, 0.1f, 0.1f);\n  const float topMidLevel = 1.0f;\n  const float midBotLevel = 0.0f;\n  const float botLevel    = -0.2f;\n  \n  if (direction.y > topMidLevel)\n    return top;\n  if (direction.y <= topMidLevel && direction.y > midBotLevel)\n    return mix(mid, top, (direction.y - midBotLevel) / (topMidLevel - midBotLevel));\n  if (direction.y <= midBotLevel && direction.y > botLevel)\n    return mix(bot, mid, (direction.y - botLevel) / (midBotLevel - botLevel));\n  return bot;\n}\n\nvec3 phongDiffuse(vec3 matDiffuse, vec3 lightDir, vec3 normal)\n{\n  return lightDiffuse * matDiffuse * max(dot(-lightDir, normal), 0.0f);\n}\n\nvec3 phongSpecular(vec3 matSpecular, vec3 lightDir, vec3 normal, \n  vec3 cameraDir, float power)\n{\n  return lightSpecular * matSpecular * pow(max(dot(reflect(lightDir, normal), \n    normalize(cameraDir)), 0.0f), power);\n}\n\nvec3 phong(uint matId, vec3 p, vec3 n, vec3 c)\n{\n  return phongDiffuse(materials[matId].diffuse, lightDirection, n)\n    + phongSpecular(materials[matId].specular, lightDirection, n, c - p, materials[matId].specPower);\n}\n\n// ----------------------------------------\n//  SDFs\n// ----------------------------------------\nstruct SDFOut\n{\n  float value;\n  uint  id;\n};\n\nSDFOut opU(SDFOut sdf1, SDFOut sdf2)\n{\n  float res = min(sdf1.value, sdf2.value);\n  if (res == sdf1.value)\n    return SDFOut(res, sdf1.id);\n  else\n    return SDFOut(res, sdf2.id);\n}\n\nSDFOut sphereSdf(uint id, vec3 point, vec3 center, float radius)\n{\n  return SDFOut(length(point - center) - radius, id);\n}\n\nSDFOut boxSdf(uint id, vec3 point, vec3 center, vec3 size)\n{\n  return SDFOut(length(max(abs(point - center) - size, 0.0f)), id);\n}\n\nSDFOut sceneSdf(vec3 point)\n{\n  float sphereShift1 = 0.3f + 0.05f * (1.0f + sin(3.0f * iTime));\n  float sphereShift2 = 0.3f + 0.05f * (1.0f + sin(3.0f * iTime + 0.4f));\n  float sphereShift3 = 0.3f + 0.05f * (1.0f + sin(3.0f * iTime + 0.8f));\n  float sphereShift4 = 0.3f + 0.05f * (1.0f + sin(3.0f * iTime + 1.2f));\n  SDFOut sphere = sphereSdf(0u, point, vec3(0.5f, sphereShift1, 0.0f), 0.15f);\n  SDFOut sphere2 = sphereSdf(0u, point, vec3(-0.5f, sphereShift2, 0.0f), 0.15f);\n  SDFOut sphere3 = sphereSdf(0u, point, vec3(0.0f, sphereShift3, 0.5f), 0.15f);\n  SDFOut sphere4 = sphereSdf(0u, point, vec3(0.0f, sphereShift4, -0.5f), 0.15f);\n  SDFOut platform = boxSdf(1u, point, vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 0.05f, 1.0f));\n  SDFOut pillar = boxSdf(2u, point, vec3(0.0f, 0.0f, 0.0f), vec3(0.25f, 0.1f, 0.25f));\n  SDFOut res = \n    opU(pillar, \n    opU(sphere4, \n    opU(sphere3, \n    opU(sphere2, \n    opU(sphere, platform)))));\n  \n  return res;\n}\n\n// ----------------------------------------\n//  Utility\n// ----------------------------------------\n\nconst float gradientPrecision = 1.e-2f;\n\nvec3 gradient(vec3 p)\n{\n  const float pr = gradientPrecision;\n  const vec3 dx = vec3(pr, 0.0f, 0.0f);\n  const vec3 dy = vec3(0.0f, pr, 0.0f);\n  const vec3 dz = vec3(0.0f, 0.0f, pr);\n  return normalize(vec3(\n    sceneSdf(p + dx).value - sceneSdf(p - dx).value ,\n    sceneSdf(p + dy).value  - sceneSdf(p - dy).value ,\n    sceneSdf(p + dz).value  - sceneSdf(p - dz).value ));\n}\n\n// ----------------------------------------\n//  Raymarching settings\n// ----------------------------------------\n// Uncomment to enable shading:\n#define SHADOWS\n\n// Uncomment to enable reflections:\n#define REFLECTIONS\n\nconst float minRayLength      = 0.01f;\nconst float maxRayLength      = 100.0f;\nconst uint  maxStep           = 128u;\nconst float raycastPrecision  = 0.5f * 1.e-3f;\nconst uint  reflectionCount   = 4u;\n\n// ----------------------------------------\n//  Raycasting\n// ----------------------------------------\nstruct RaycastInfo\n{\n  bool hit;\n  vec3 point;\n  uint id;\n};\n\nvec3 screenRayDirection(Camera camera, vec2 fragPos)\n{\n  float aspectRatio = iResolution.x / iResolution.y;\n  float halfFov = camera.fov * 0.5f;\n  vec3 cameraRight = normalize(cross(camera.forward, camera.up));\n  vec3 direction = camera.forward \n    + (fragPos.y - 0.5f) * 2.0f * normalize(cross(cameraRight, camera.forward)) * tan(halfFov)\n    + (fragPos.x - 0.5f) * 2.0f * cameraRight * tan(halfFov) * aspectRatio;\n\n  return normalize(direction);\n}\n\nRaycastInfo raycast(vec3 origin, vec3 direction)\n{\n  float rayLength = minRayLength;\n  vec3 p = origin + direction * rayLength;\n\n  for (uint i = 0u; i < maxStep; ++i)\n  {\n    SDFOut sdfOut = sceneSdf(p);\n\n    if (sdfOut.value <= raycastPrecision)\n      return RaycastInfo(true, p, sdfOut.id);\n\n    p += sdfOut.value * direction;\n    rayLength += sdfOut.value;\n\n    if (rayLength > maxRayLength)\n      return RaycastInfo(false, p, sdfOut.id);\n  }\n}\n\n// ----------------------------------------\n//  Coloring\n// ----------------------------------------\n\n// Calculate phong and shadows, not considering reflections\nvec3 CalcDirectLighting(RaycastInfo raycastInfo, vec3 from)\n{\n  vec3 ph = phong(raycastInfo.id, raycastInfo.point, gradient(raycastInfo.point), from);\n#ifdef SHADOWS\n  float shadow = 0.0f;\n  RaycastInfo shadowRaycast = raycast(raycastInfo.point, -lightDirection);\n  if (shadowRaycast.hit) shadow = 0.5f;\n    \n  return (1.0f - shadow) * ph;\n#else\n  return ph;\n#endif\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n  updateCamera();\n\n  vec2 fragPos = fragCoord / iResolution.xy;\n  vec3 direction = screenRayDirection(camera, fragPos);\n\n  RaycastInfo pointRaycast = raycast(camera.position, direction);\n  if (pointRaycast.hit)\n  {\n    color = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    \n    color.rgb += CalcDirectLighting(pointRaycast, camera.position);\n\n#ifdef REFLECTIONS\n    vec3 reflectionSourcePoint = pointRaycast.point;\n    vec3 reflectionDir = direction;\n    float reflectance = materials[pointRaycast.id].reflectance;\n    for (uint i = 0u; i < reflectionCount; ++i)\n    {\n      reflectionDir = reflect(reflectionDir, gradient(reflectionSourcePoint));\n      RaycastInfo reflectionRaycast = raycast(reflectionSourcePoint, reflectionDir);\n      if (reflectionRaycast.hit)\n      {\n        color.rgb += reflectance * \n          CalcDirectLighting(reflectionRaycast, reflectionSourcePoint);\n        reflectance *= materials[reflectionRaycast.id].reflectance;\n        reflectionSourcePoint = reflectionRaycast.point;\n      }\n      else\n      {\n        color.rgb += reflectance * skyColor(reflectionDir);\n        break; // out of scene\n      }\n    }\n#endif\n  }\n  else \n  {\n  \tcolor = vec4(skyColor(direction), 1.0f);\n  }\n}","name":"Image","description":"","type":"image"}]}