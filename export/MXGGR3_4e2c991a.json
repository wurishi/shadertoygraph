{"ver":"0.1","info":{"id":"MXGGR3","date":"1717969995","viewed":219,"name":"Sky with dithered raymarching","username":"kornelski","description":"My first attempt at crepuscular rays.\n\nI've seen plenty of volumetric effects with clearly visible steps, and haven't seen anybody dithering them. For ray marching dithering is essentially free, and completely masks the stair effect. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","clouds","scattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_STEPS = 15;\nconst float DITHERING = 0.99;\n\nfloat sample_density(vec2 position);\n\nfloat trace(vec2 position, vec2 light_position, float step_rand) {\n    float step = 1.0 / float(MAX_STEPS);\n    float weight = step * distance(light_position, position);\n    vec2 start = light_position;\n    vec2 vector = position - light_position;\n\n    float total_density = 0.0001;\n    float i = step * step_rand * DITHERING;\n    while (i <= 1.0) {\n        vec2 samp_position = start + vector * i;\n        float density = sample_density(samp_position);\n\n        total_density += density * weight;\n        i += step;\n    }\n    return total_density;\n}\n\nfloat noise(vec2 coord);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    float sun_pos = 11.5 + iTime * 0.08;\n\n    float step_rand = fract(fract(cos(dot(position, vec2(12.9898, 78.233))) * 43758.545312 + fract(iTime * 0.08)));\n    float lit_x = fract((sin(dot(position, vec2(12.9898, 78.233)))) * 43758.545311);\n    float lit_y = fract((cos(dot(position, vec2(78.233, 12.9898)))) * 11003.545312);\n\n    vec2 mix_vec = vec2(sin(sun_pos * 0.34), cos(sun_pos * 0.63)) * 0.33;\n    vec2 light_position = vec2(0.5) + mix_vec;\n    if (iMouse.z > 0.) {\n       light_position = (iMouse.xy/iResolution.xy);\n    }\n    float light_distance = distance(position, light_position);\n    if (light_distance < 1.0 / 100.0) {\n        fragColor = vec4(1.0);\n        return;\n    }\n\n    float fuzz = 46.0; // soft shadows\n    float density_here = sample_density(position);\n    float total_density = trace(position, light_position + DITHERING * vec2((lit_y - 0.5) / fuzz, (lit_x - 0.5) / fuzz), step_rand);\n\n    float scatter = min(1.0, 0.005 * density_here + min(0.5, 0.05 * density_here));\n    vec3 color = pow(mix(vec3(0.0, 0.25, 0.6), vec3(0.5 / total_density), scatter), vec3(1./2.4));\n    fragColor = vec4(color, 1.0);\n}\n\nfloat sample_density(vec2 position) {\n    float slowtime = iTime * 0.015;\n    float p1 = noise(position * 2.0);\n    p1 = p1 * p1;\n    float p2 = noise(position * 1.2458);\n    float p3 = noise(vec2(p1, p2) * 2.5 + position * 3.34);\n    float p4 = noise(position * (p3 + 15.1) + vec2(p2, p3) + slowtime);\n    float p5 = 2.0 * min(p1, p2) * noise(vec2(iTime * 0.2 + position * 18.1 + 9.0 + p4 - p1));\n    float p7 = noise(vec2(position.x + p3 * 0.25, position.y + p2 * 0.2) * 32.1);\n    float p8 = noise(vec2(position.y + p1 * 0.2, slowtime + position.x - p3 * 0.2) * 19.2);\n    float p9 = max(0.0, p1 - 0.07 + p4 * 0.2 + (p8 * p7) * 0.1);\n    float dots = 1.0;\n    float dist = distance(vec2(p2, p4), vec2(0.5));\n    if (dist > 0.39) {\n        dots = (p8 + p7 + p9) * 350.0 * (dist - 0.37);\n    }\n\n    float px = noise(position * 2.3 + 11.1);\n    float pxx = min(p1 * p1, min(p2, (px * px) * (px * px)));\n    float cloud = (pxx * pxx * p3 * p3 * p3) * (p3 + (1.1 - p4) * 13.0 + (1.0 - p7) * 12.0 + p8 * 8.0 + px) * 500.0 * distance(position, vec2(0.5));\n\n    return (cloud * cloud) + 2.6 * dots * (p9 * p2 * (0.1 + p3) * (1.75 + p4) * (1.2 + p5) * (2.0 + min(p7, p8)) + min(1.0 - p7, 1.0 - p8) * 0.0001);\n}\n\nfloat fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat grad(int hash, float x, float y) {\n    int h = hash & 3;\n    float u = h < 2 ? x : y;\n    float v = h < 2 ? y : x;\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nint permutation(int value) {\n    return (value >> 16) ^ (value * 10103) ^ (value * 1231134 + 1) + 13;\n}\n\nfloat noise(vec2 coordx) {\n    vec2 coord = (iMouse.xy/iResolution.xy)*0.125 + coordx;\n    ivec2 i = ivec2(floor(coord));\n    vec2 f = fract(coord);\n\n    vec2 u = vec2(fade(f.x), fade(f.y));\n\n    int a = permutation(i.x) + i.y;\n    int b = permutation(i.x + 1) + i.y;\n\n    int hash0 = permutation(a);\n    int hash1 = permutation(b);\n    int hash2 = permutation(a + 1);\n    int hash3 = permutation(b + 1);\n\n    float g0 = grad(hash0, f.x, f.y);\n    float g1 = grad(hash1, f.x - 1.0, f.y);\n    float g2 = grad(hash2, f.x, f.y - 1.0);\n    float g3 = grad(hash3, f.x - 1.0, f.y - 1.0);\n\n    float lerp_x1 = mix(g0, g1, u.x);\n    float lerp_x2 = mix(g2, g3, u.x);\n\n    return clamp((1.0 + mix(lerp_x1, lerp_x2, u.y)) * 0.5, 0.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}