{"ver":"0.1","info":{"id":"NdGcRt","date":"1655334233","viewed":160,"name":"3d Teminite logo visualizer test","username":"Dubswitcher","description":"Song: Teminite - Work\nAnother SDF learning experiment. Having a lot of fun with this one.","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["test","sdf","music","visualizer","outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Mt2SRh","filepath":"https://soundcloud.com/teminite/work","previewfilepath":"https://soundcloud.com/teminite/work","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 tpt[12] = vec2[12]( // Teminite T vertices\n    vec2(-0.431794,0.364782),\n    vec2(-0.344631,0.212561),\n    vec2(-0.12102,0.212561),\n    vec2(-0.337739,0.344052),\n    vec2(-0.087152,0.219745),\n    vec2(0.079348,0.219745),\n    vec2(0.328652,0.344052),\n    vec2(-0.066869,-0.373959),\n    vec2(0.062312,-0.28978),\n    vec2(0.113216,0.212561),\n    vec2(0.336826,0.212561),\n    vec2(0.42399,0.364782)\n);\n\nstruct sdf {float face; int layer;};\n\n\nmat3 rotation(float x, float y, float z) {\n    float pi = 3.1415923; //precision before exacts break\n    vec3 c = cos(vec3(x,y,z)*pi/2.);\n    vec3 s = sin(vec3(x,y,z)*pi/2.);\n    return mat3(vec3(1, 0, 0),vec3(0, c.x, -s.x),vec3(0, s.x, c.x)) *\n           mat3(vec3(c.y, 0, s.y),vec3(0, 1, 0),vec3(-s.y, 0, c.y)) *\n           mat3(vec3(c.z, -s.z, 0),vec3(s.z, c.z, 0),vec3(0, 0, 1));\n}\n\nfloat extrude(in vec3 p, in float s, in float h)\n{\n    vec2 w = vec2(s, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdPolygon( in vec2 p, in vec2[6] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nsdf scene (vec3 p)\n{\n    vec2 tpoly[6] = vec2[6](tpt[4],tpt[3],tpt[6],tpt[5],tpt[8],tpt[7]);\n    \n    p /= 4.;\n    float t = 1e10;\n    t = min(extrude(p,sdPolygon(p.xy,tpoly),0.1),t);\n    t = min(extrude(p,sdTriangle(p.xy,tpt[0],tpt[1],tpt[2]),0.1),t);\n    t = min(extrude(p,sdTriangle(p.xy,tpt[9],tpt[10],tpt[11]),0.1),t);\n    p *= 4.;\n    \n    return sdf(t,1);\n}\n\nmat3 camera(in vec3 cPos, in vec3 targ, in float roll)\n{\n    vec3 w = normalize(targ - cPos);\n    vec3 u = normalize(cross(w,vec3(sin(roll),cos(roll),0.0)));\n    return mat3(u, normalize(cross(u,w)), w);\n}\n\nstruct rcast{float face; int layer; vec3 global;};\n\nrcast view(vec3 eye, vec3 ray, float prec, float near, float far, int steps, float beat)\n{ // Cam position; Look direction; Precision; Near and Far clipping \n    float hit = prec, trace = near, dist = -1., outline = near;\n    vec3 gpos = vec3(0.);\n    int material = -1;    \n    for(int i = 0; i < steps; i++)\n    {\n        if(hit < prec || trace > far) break;\n        gpos = eye+ray*trace;\n        sdf model = scene(gpos);\n        hit = model.face; trace += hit; material = model.layer;\n    }\n    \n    for(int i = 0; i < steps; i++)\n    {\n        if(hit < prec || outline > far) break;\n        sdf model = scene(eye+ray*outline);\n        hit = model.face - 0.01-(beat/8.); outline += hit; material = model.layer;\n    }\n    if(outline < far && outline > near) {dist = outline; material = 0;} else\n    if(trace < far && trace > near) dist = trace; else material = -1;\n    \n    return rcast(dist-0.01, material, gpos);\n}\n\nvec3 getNorm( in vec3 pos ){\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(pos+0.0005*e).face;\n    }\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 vt = vec2(fragCoord.x/iResolution.x,0.);\n    float st = 0., count = 0.;\n    \n    for (float x = 0.02; x < 0.15; x += 0.01)\n    {\n        st += texture(iChannel0,vec2(x,0.)).r;\n        count += 1.;\n    }\n    st = pow(st/count,4.)/2.;\n    \n    mat3 wobb = rotation(cos(iTime*0.6)*0.05+0.05,\n                         sin(iTime*0.6)*0.08-0.2,\n                         sin(iTime*1.6)*0.08);\n    \n    vec3 eye = vec3(0.,0.,8.) * wobb;\n    vec3 look = vec3(0.);\n    \n    vec3 ray = normalize(camera(eye, look,\n            sin(iTime*1.4+0.3)*0.02)*vec3(uv,1.6+st));\n    \n    float bgd = clamp(distance(uv,vec2(0.))/(st*2.+0.5),0.,1.);\n    bgd = bgd*bgd*(3.-2.*bgd);\n    \n    vec3 col = mix(vec3(0.1,0.6,0.7),vec3(0.1,0.2,0.5),bgd);\n    \n    vec2 sc = fragCoord/iResolution.xy;\n    \n    float wave = texture(iChannel0,vec2(sc.x,1.)).r;\n    wave += (sc.y-0.5)*4.;\n    wave = min(smoothstep(0.4,0.5,wave),smoothstep(0.6,0.5,wave));\n    \n    col += wave*vec3(0.1,0.6,0.3);\n    \n    \n    rcast pix = view(eye, ray, 0.002, 4., 10., 150, st);\n    \n    vec3 bgc = col;\n    \n    if (pix.layer > -1) {\n        if (pix.layer == 1)\n        {\n            vec3 p = pix.global;\n            vec3 n = getNorm(p);\n            vec3 lightD = normalize(vec3(-1.8,2.4,3.)-p);\n            vec3 lookD = -ray;\n            float light = max(dot(lightD,n),0.);\n            float fnorm = max(dot(-ray,n),0.);\n            float ali = max(dot(lightD/lookD,n),0.);\n        \n            float lfn = dot((vec3(0.,0.,1.)-ray)/2.,n);\n        \n            col = vec3(1.);\n            col *= light*vec3(0.9,0.9,1.0); //Diffuse\n            col += light*pow(max(fnorm,0.),8.)/2.; //Silk specular\n            col += pow(1.-fnorm,4.)*vec3(0.6,0.7,1.);\n            \n            float vp = p.y/4.+0.5;\n            float vs = pow(texture(iChannel0,vec2(vp,0.)).r,4.);\n            \n            col += clamp(vec3(0.2,0.5,1.)*vs*(1.-vp*2.+0.3)*2.,0.,1.);\n        } else col = vec3(0.);\n    }\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}