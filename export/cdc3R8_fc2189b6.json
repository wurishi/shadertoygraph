{"ver":"0.1","info":{"id":"cdc3R8","date":"1676951213","viewed":146,"name":"Clouds WIP 2","username":"FifthStateOfMatter","description":"3D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 lightDir = normalize(vec3(10, 10, 10));\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return max(fract((p.x + p.y)*p.z)*2.0 - 1.0, 0.0);\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return max(fract(p.x + p.y)*2.0 - 1.0, 0.0);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return mix(lerpBottomFront, lerpTopFront, frc.y);\n}\n\nfloat fbm(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise3(p*f)*h;\n    for(int i = 0; i < 2; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise3(rotate2D(p, vec2(0, r))*f)*h;\n    }\n    return n/1.0;\n}\n\nfloat fbm2(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 4; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nstruct box{\n    vec3 pos;\n    vec3 size;\n};\n\nbool raytraceBox(vec3 o, vec3 d, out float ct, out float ft, box b){\n    vec3 tMin;\n    vec3 tMax;\n\n    vec3 halfSize = b.size/2.0;\n\n    vec3 lbf = b.pos - halfSize;\n    vec3 rtb = b.pos + halfSize;\n\n    tMin = (lbf - o)/d;\n    tMax = (rtb - o)/d;\n\n    if(tMin.x > tMax.x){\n        float tempT = tMin.x;\n        tMin.x = tMax.x;\n        tMax.x = tempT;\n    }\n\n    if(tMin.y > tMax.y){\n        float tempT = tMin.y;\n        tMin.y = tMax.y;\n        tMax.y = tempT;\n    }\n\n    if(tMin.z > tMax.z){\n        float tempT = tMin.z;\n        tMin.z = tMax.z;\n        tMax.z = tempT;\n    }\n\n    if((tMin.x > tMax.y) || (tMin.y > tMax.x)){\n        return false;\n    }\n\n    if(tMin.y > tMin.x){\n        tMin.x = tMin.y;\n    }\n\n    if(tMax.y < tMax.x){\n        tMax.x = tMax.y;\n    }\n\n    if((tMin.x > tMax.z) || (tMin.z > tMax.x)){\n        return false;\n    }\n\n    if(tMin.z > tMin.x){\n        tMin.x = tMin.z;\n    }\n\n    if(tMax.z < tMax.x){\n        tMax.x = tMax.z;\n    }\n    \n    if(ct < 0.0){\n        return false;\n    }\n    ct = max(tMin.x, 0.0);\n    ft = max(tMax.x, 0.0);\n    return true;\n}\n\nfloat getDensityOnRay(vec3 o, vec3 d, float ct, float ft, int res){\n    float density = 1.0;\n    vec3 samplePos = o + d*ct;\n    float stepLength = (ft - ct)/float(res);\n    vec3 stepDir = stepLength*d;\n    for(int i = 0; i < res; i++){\n        float t = exp(-0.2*fbm(samplePos*vec3(1, 3, 1) + vec3(0, 0, iTime*0.5))*10.0*stepLength);\n        samplePos += stepDir;\n        density *= t;\n    }\n    return density;\n}\n\nbox b1 = box(vec3(0, 1, 0), vec3(600, 1, 600));\n\nfloat displayClouds(vec3 o, vec3 d, float ct, float ft, out float transmittance, int res, vec3 lpos, out vec3 ldir){\n    float density = 0.0;\n    float ldensity = 1.0;\n    transmittance = 0.0;\n    vec3 samplePos = o + d*ct;\n    float stepLength = (ft - ct)/float(res);\n    vec3 stepDir = stepLength*d;\n    for(int i = 0; i < res; i++){\n        ldir = normalize(lpos - samplePos);\n        float lct;\n        float lft;\n        bool raytraceLight = raytraceBox(samplePos, ldir, lct, lft, b1);\n        float dAtPos = fbm(samplePos*vec3(1, 3, 1) + vec3(0, 0, iTime*0.5))*10.0;\n        float inscatteringL = exp(-0.2*dAtPos*stepLength);\n        ldensity *= inscatteringL;\n        \n        float lTransmittance = getDensityOnRay(samplePos, ldir, lct, lft, 3);\n        transmittance += ldensity*lTransmittance*dAtPos*0.2*stepLength;\n        density += (1.0 - inscatteringL)*(1.0 - density);\n        samplePos += stepDir;\n    }\n    return density;\n}\n\nfloat planeSDF(vec3 p, vec3 n, float h){\n    return length((p - h)*n);\n}\n\nfloat sceneSDF(vec3 p){\n    return planeSDF(p, vec3(0, 1, 0), -0.5) - fbm2(p)*0.4;\n}\n\nfloat raymarch(vec3 o, vec3 d, out bool hit){\n    float t = 0.0;\n    hit = false;\n    for(int i = 0; i < 200 && !hit; i++){\n        float s = sceneSDF(o + d*t);\n        t += s;\n        if(abs(s) <= t*0.001 && t >= 0.0) hit = true;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 h){\n    vec2 e = vec2(0, 0.01);\n    return normalize(vec3(\n        sceneSDF(h + e.yxx) - sceneSDF(h - e.yxx),\n        sceneSDF(h + e.xyx) - sceneSDF(h - e.xyx),\n        sceneSDF(h + e.xxy) - sceneSDF(h - e.xxy)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0);\n    vec3 backCol = vec3(0.5, 0.8, 1);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0, 0, -8);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(-0.15, 0)));\n    bool hit;\n    float t = raymarch(o, d, hit);\n    float ct;\n    float ft;\n    bool hitBox = raytraceBox(o, d, ct, ft, b1);\n    ct = min(ct, t);\n    ft = min(ft, t);\n    float transmittance;\n    vec3 ldir;\n    float density = displayClouds(o, d, ct, ft, transmittance, 20, vec3(10, 10, -10), ldir);\n    if(hit){\n        vec3 n = getNormal(o + d*t);\n        backCol = mix(mix(vec3(0.2), vec3(1), smoothstep(0.6, 0.7, n.y - 0.3))*max(dot(ldir, n), 0.1), backCol, 1.0 - exp(-t*0.2));\n    }\n    if(hitBox){\n        col = mix(mix(backCol, vec3(1, 0.9, 0.7)*smoothstep(0.0, 1.0, transmittance), density), backCol, 1.0 - exp(-ct*0.2));\n    }else{\n        col = backCol;\n    }\n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}","name":"Image","description":"","type":"image"}]}