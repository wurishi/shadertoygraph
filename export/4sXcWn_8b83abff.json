{"ver":"0.1","info":{"id":"4sXcWn","date":"1487599882","viewed":561,"name":"tonemapping experiment","username":"madcake","description":"Made by Zevie\nhttps://www.shadertoy.com/view/lslGzl\n\nI added two tonemapping algorithms that I came up with\n(bottom ones)\nsoon i realized i could fit the reinhard curve to match log curve by adjusting coefficients so it's kinda pointless)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tonemapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n \nThis shader experiments the effect of different tone mapping operators.\nThis is still a work in progress.\n \nMore info:\nhttp://slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\nhttp://filmicgames.com/archives/75\nhttp://filmicgames.com/archives/183\nhttp://filmicgames.com/archives/190\nhttp://imdoingitwrong.wordpress.com/2010/08/19/why-reinhard-desaturates-my-blacks-3/\nhttp://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/\nhttp://renderwonk.com/publications/s2010-color-course/\n \n--\nZavie\n \n*/\n \nfloat gamma = 2.2;\n \nvec3 getBaseColor(int i)\n{\n    if (i == 0) return vec3(1.0, 0.4, 0.2);\n    if (i == 1) return vec3(0.4, 1.0, 0.2);\n    if (i == 2) return vec3(0.2, 1.0, 0.4);\n    if (i == 3) return vec3(0.2, 0.4, 1.0);\n    if (i == 4) return vec3(0.4, 0.2, 1.0);\n    if (i == 5) return vec3(1.0, 0.2, 0.4);\n \n    return vec3(1.);\n}\n \nvec3 getBaseColor()\n{\n    float colorPerSecond = 0.5;\n    int i = int(mod(colorPerSecond * iTime, 7.));\n    int j = int(mod(float(i) + 1., 7.));\n \n    return mix(getBaseColor(i), getBaseColor(j), fract(colorPerSecond * iTime));\n}\n \nvec3 linearToneMapping(vec3 color)\n{\n    float exposure = 1.;\n    color = clamp(exposure * color, 0., 1.);\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 simpleReinhardToneMapping(vec3 color)\n{\n    float exposure = 1.5;\n    color *= exposure/(1. + color / exposure);\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n    float toneMappedLuma = luma / (1. + luma);\n    color *= toneMappedLuma / luma;\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)\n{\n    float white = 2.;\n    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n    float toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n    color *= toneMappedLuma / luma;\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 RomBinDaHouseToneMapping(vec3 color)\n{\n    color = exp( -1.0 / ( 2.72*color + 0.15 ) );\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 filmicToneMapping(vec3 color)\n{\n    color = max(vec3(0.), color - vec3(0.004));\n    color = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n \nvec3 Uncharted2ToneMapping(vec3 color)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    float W = 11.2;\n    float exposure = 2.;\n    color *= exposure;\n    color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n    float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n    color /= white;\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 logToneMap(vec3 c){\n    \n    // in my experience limit=2.2 and contrast=0.35 gives nice result\n    // i prefer to leave a lot of highlights\n    // also log curve fades to highlights beautifully\n    // however i raised this parameters to make it look\n    // somewhat identical to other algorithms here\n    \n    // according to my information the dynamic range of\n    // human eye's light perception is around\n    // 2.5 of what monitor can provide\n    // though it's hightly questionable in terms of\n    // both the data and my understanding of it\n    \n    // P.S.\n    // i noticed that applying inverse tonemap transformation to\n    // diffuse textures improves the final render a lot\n    \n    float limit = 2.5;\n    float contrast = 0.3;\n    \n    // do the tone mapping\n    \n    c = log(c + 1.0) / log(limit + 1.0);\n    \n    // clamping for hackyContrast because s_curve\n    // does not behave properly outside [0; 1]\n    // if you want to keep values outside [0; 1]\n    // for example for bloom post-effect\n    // you would need comething better than\n    // hackyContrast()\n    \n    c = clamp(c,0.0,1.0);\n    \n    // hacky contrast s_curve\n    // btw it's a freatapproximation for 1-cos(x*3.14)*0.5\n    \n    c = mix(c, c * c * (3.0 - 2.0 * c), contrast);\n    \n    // this creates pleasant hue shifting\n    // i amplified the effect to demonstrate it more clearly\n    // usually i use it very subtle\n    \n    c = pow(c, vec3(1.05,0.9,1));\n    \n    // gamma correction\n    \n    return pow(c, vec3(1. / gamma));\n}\n\nvec3 limitedPerChannelReinhard(vec3 c){\n    float limit = 4.0;\n    float contrast = 0.6;\n    \n    c *= (c / (limit*limit) + 1.) / (c + 1.);\n    \n    return pow(c, vec3(1. / gamma));\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = getBaseColor();\n \n    float n = 8.;\n    if (uv.x > 0.2)\n    {\n        if (uv.x < 0.6)\n            // blacks\n            color *= (2.5 * uv.x - 0.5);\n        else\n            // whites\n            color *= 15.*(2.5 * uv.x - 1.5) + 1.;\n \n        int i = int(n * (1. - uv.y));\n        if (i == 0) color = linearToneMapping(color);\n        if (i == 1) color = simpleReinhardToneMapping(color);\n        if (i == 2) color = whitePreservingLumaBasedReinhardToneMapping(color);\n        if (i == 3) color = RomBinDaHouseToneMapping(color);\n        if (i == 4) color = filmicToneMapping(color);\n        if (i == 5) color = Uncharted2ToneMapping(color);\n        \n  //below are the ones i added\n        \n     //you can tweak reinhard to look like this\n        if (i == 6) color = logToneMap(color); \n        \n        if (i == 7) color = limitedPerChannelReinhard(color);\n        \n    }\n \n    if (abs(fract(n * uv.y + 0.5) - 0.5) < 0.02)\n        color = vec3(0.);\n    \n   \tvec3 diffC = vec3(1,1,1) - clamp(color,0.0,1.0);\n    float diff = max(diffC.r, max(diffC.g, diffC.g));\n    // color = ((diff > 0.0) && (diff < 0.01)) ? vec3(0,0,0) : color;\n    // this will show tha point where color fades to white\n \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}