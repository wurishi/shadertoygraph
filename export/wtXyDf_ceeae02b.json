{"ver":"0.1","info":{"id":"wtXyDf","date":"1593271630","viewed":313,"name":"Truchet hex tiles","username":"vegardno","description":"Inspired by: https://www.reddit.com/r/generative/comments/hgjq22/circuitous/","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["truchet","hex","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cube_round(vec3 cube)\n{\n    float rx = round(cube.x);\n    float ry = round(cube.y);\n    float rz = round(cube.z);\n\n    float x_diff = abs(rx - cube.x);\n    float y_diff = abs(ry - cube.y);\n    float z_diff = abs(rz - cube.z);\n\n    if (x_diff > y_diff && x_diff > z_diff) {\n        rx = -ry - rz;\n    } else if (y_diff > z_diff) {\n        ry = -rx - rz;\n    } else {\n        rz = -rx - ry;\n    }\n\n    return vec3(rx, ry, rz);\n}\n\nvec2 cube_to_axial(vec3 cube)\n{\n    float q = cube.x;\n    float r = cube.z;\n    return vec2(q, r);\n}\n\nvec3 axial_to_cube(vec2 hex)\n{\n    float x = hex.x;\n    float z = hex.y;\n    float y = -x - z;\n    return vec3(x, y, z);\n}\n\nvec2 hex_round(vec2 hex)\n{\n    return cube_to_axial(cube_round(axial_to_cube(hex)));\n}\n\nconst float size = 20.0;\n\nvec2 pixel_to_pointy_hex(vec2 point)\n{\n    float q = (sqrt(3.0) / 3.0 * point.x - 1.0 / 3.0 * point.y) / size;\n    float r = (2.0 / 3.0 * point.y) / size;\n    return hex_round(vec2(q, r));\n}\n\nvec2 pointy_hex_to_pixel(vec2 hex)\n{\n    float x = size * (sqrt(3.0) * hex.x  +  sqrt(3.0) / 2.0 * hex.y);\n    float y = size * (3.0 / 2.0 * hex.y);\n    return vec2(x, y);\n}\n\nvec2 opModPolarMirrored( in vec2 p, float theta, float offset)\n{\n    float a = atan(p.y, p.x) - offset;\n    a = abs(mod(a + .5 * theta, theta) - .5 * theta);\n    return length(p) * vec2(cos(a), sin(a));\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float scale = 150.;\n    scale = 500. + 450. * cos(radians(1.) * iTime + radians(90.));\n\n    vec2 uv = scale * (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv = rotate(radians(2.) * iTime + radians(10.)) * uv;\n    \n    vec2 hex = pixel_to_pointy_hex(uv);\n    vec2 uv2 = pointy_hex_to_pixel(hex);\n\n    float b = smoothstep(-.1, .1, sin(radians(360.) * rand(floor(hex)) + radians(20.) * iTime));\n    \n    vec2 rel = opModPolarMirrored(uv2 - uv, radians(360.) / 3., radians(30. + 60. * b));\n    float r = abs(length(rel - vec2(size, 0.)) - 10.) - 2.;\n    \n    float d = smoothstep(0., 2. * scale / iResolution.y, r);\n    vec3 col = vec3(d);\n\n    uv = fragCoord / iResolution.xy;\n\tcol *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.18 );\n  \tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}