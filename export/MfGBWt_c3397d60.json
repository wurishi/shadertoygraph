{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\nFire Lissajous -- svenofnine\nhttps://www.shadertoy.com/view/MfGBWt\n\n*/\n\n// Fire gradient - r, g, b and I \"misuse\" the alpha component (a) as an index for the color elements. \nconst vec4[] fire_gradient = vec4 [] ( \n    //    r    g    b    a (=pos in gradient)\n    vec4( 0.0, 0.0, 0.0, 0.0),\n    vec4( 0.1, 0.1, 0.1, 0.1),\n    vec4( 0.3, 0.0, 0.0, 0.2),\n    vec4( 1.0, 0.4, 0.0, 0.5),\n    vec4( 1.0, 1.0, 0.3, 0.7),\n    vec4( 1.0, 1.0, 1.0, 0.8),\n    vec4( 1.0, 1.0, 1.0, 1.0)\n);    \n\n// my function which calculates a color at pos \"pos\" by using the fire_gradient array.\n// First I wanted to pass the gradient as a parameter but then I thought it would be faster to\n// use the const directly instead to improve performance. So it is not neccessary to copy the whole array\n// into a function call for every single pixel. It's my imagination, maybe I am wrong and arrays\n// will be passed by reference like Javascript. We'll see.\nvec3 gradient( in float pos ) {\n    int num_cols = fire_gradient.length();\n    pos = clamp( pos, 0., 1.); // it needs to be in 0..1 range\n    for( int i = 0; i < num_cols-1; i++ ) {\n      if( (pos >= fire_gradient[i].a) && (pos < fire_gradient[i+1].a) ) {\n          return mix( \n              fire_gradient[i].rgb, \n              fire_gradient[i+1].rgb,\n              (pos - fire_gradient[i].a) / (fire_gradient[i+1].a - fire_gradient[i].a)\n          );\n      }\n    }\n    return fire_gradient[ num_cols-1 ].rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // get the brightness from the black and white image in iChannel0\n    float brightness = texture(iChannel0, uv).r;\n    \n    // lookup into the gradient and color the pixel \n    fragColor = vec4 ( gradient(2.*brightness), 1.);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\nFire Lissajous -- svenofnine\nhttps://www.shadertoy.com/view/MfGBWt\n\n*/\n\n#define ar vec2(iResolution.x/iResolution.y, 1.)  // aspect ratio of canvas\n\nconst ivec2 OLD_POS = ivec2(0, 0);    // holds the drawing position at the previous frame to draw \n                                      // line segments from there in current frame.\n\n// graph parameters\nconst float lissajous_x = 3.;\nconst float lissajous_y = 4.;\n\n// graph rotation speed\nconst float rotation_speed = 0.1;\n\n// 8< based on https://www.shadertoy.com/view/MlcGDB\n// draw line segment from A to B with given thickness r, \nfloat segment(in vec2 P, in vec2 A, in vec2 B, in float r) {\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n    // return smoothstep(r, 0.5*r, d);     // original has bright points where segments overlap\n\treturn smoothstep(r, 0.5*r, d)-smoothstep(r,0.,length(h));  \n}\n// 8< end snip\n\n\n// 8< original https://thebookofshaders.com/08/ by @patriciogv\nmat2 rotate2d(float _angle){\n    float s = sin(_angle), c = cos(_angle);\n    return mat2(c,-s,s,c);\n}\n// 8< end snip\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // make unit for line with that's always one pixel on every resolution\n    float unit = 1. / min(iResolution.x, iResolution.y);\n    \n    // normalized position of the current pixel = world coordinates\n    vec2 uv = fragCoord / iResolution.xy * ar;\n    // center coords\n    vec2 center = vec2(.5,.5)*ar;\n    \n    // rotate the world coordinates slowly with time\n    uv -= center;\n    uv = rotate2d( iTime * rotation_speed ) * uv; \n    uv += center;\n    \n    vec2 graph = vec2( cos(iTime*lissajous_x)*0.5, sin(iTime*lissajous_y)*0.5 )*0.70;\n\n    vec4 oldpos_texel = (iFrame > 0 ) ? texelFetch( iChannel0, OLD_POS, 0 ) : vec4( graph, 0., 0.);\n    \n    // READ\n    vec4 pixel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // MANIPULATE\n    // pixel.rgb  = vec3( max( pixel.r, 1. - smoothstep(0., 6.*unit, distance(uv, center+graph) ) ) );      // DOTS\n    pixel.rgb = vec3( max( pixel.r, 1. * segment(uv, center+oldpos_texel.xy, center+graph, 3.*unit) ) );  // LINES\n    \n    fragColor = vec4( pixel.rgb, 1.0);      \n    if( (fragCoord.x > 0.) && (fragCoord.x < float(iResolution.x)) && (fragColor.y>0.) && (fragColor.y<iResolution.y) ) {\n        vec4 p_l = texelFetch(iChannel0, ivec2(fragCoord.x - 1., fragCoord.y), 0);\n        vec4 p_r = texelFetch(iChannel0, ivec2(fragCoord.x + 1., fragCoord.y), 0);\n        vec4 p_tp = texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y+1.), 0);\n        vec4 p_dn = texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y-1.), 0);\n        fragColor = clamp( 0.199 * (p_l + p_r +p_tp + p_dn + fragColor), 0., 1.);\n    }\n    \n    // WRITE\n    fragColor = ( ivec2(fragCoord) == OLD_POS ) ? vec4( graph, 0, 0.) : fragColor; \n  // fragColor = vec4(0.); \n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MfGBWt","date":"1734722691","viewed":157,"name":"Fire Lissajous","username":"Svenofnine","description":"Derived from Buffer Painter 2, here I tried to to draw a lissajous function automatically instead of using the mouse. I added a blur and a gradient color map to make it looking like a firefly. :-)\nEnjoy!","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["fire","gradient","array","lissajous"],"hasliked":0,"parentid":"","parentname":""}}