{"ver":"0.1","info":{"id":"ml2BzG","date":"1694195209","viewed":21,"name":"CVM - Shader 1b","username":"Clementvm","description":"I'm sorry you can't unsee this","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["octahedron","shaded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus1( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdTorus2( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = sin(iTime);\n    float c = cos(iTime);\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c,   s,\n        0.0, -s,  c\n      );\n     \n     mat3 rotZ = mat3(\n        c, s, 0.0,\n    -s, c, 0.0,\n    0.0, 0.0, 1.0\n      ); \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.xy -= 0.5;\n    \n    //this is the background!!!!\n    \n    float circs = length(uv);\n    \n    circs = sin(circs*12.0 + iTime)/8.0;\n    circs = abs(circs);\n    circs = 0.02 / circs;\n    vec3 col = vec3(circs, circs, circs);\n\n    \n    //create a ray!\n    vec3 rayPt = vec3(uv.xy, 0);\n    vec3 rayPtdx = vec3(uv.x + 0.00001, uv.y, 0);\n    vec3 rayPtdy = vec3(uv.x,          uv.y + 0.00001, 0);\n    //orthographic\n    vec3 rayDir = vec3(0,0,1);\n    vec3 eyePos = vec3(0,0,-10);\n    //vec3 rayDir = normalize(vec3(uv.xy, 0) - eyePos);\n    //perspective\n    float t = 0.0, tdx = 0.0, tdy = 0.0; //ray parameter\n    \n    //define the sphere properties\n    //float sphereRadius = 0.10;\n    vec2 torus1Props = vec2(0.2, 0.1);\n    vec3 torus1Pos = vec3(0.0,0.0,5.0);\n    vec2 torus2Props = vec2(0.2, 0.1);\n    vec3 torus2Pos = vec3(0.0,0.0,5.0);\n    vec3 spherePos = vec3(0.0,0.0,5.0);\n    \n    \n    \n    for(int i = 0; i < 35; i++){\n        //calculate a point 5 units along the ray\n        vec3 pos = rayPt + rayDir * t;    \n        vec3 posdx = rayPtdx + rayDir * tdx;\n        vec3 posdy = rayPtdy + rayDir * tdy;\n        \n        //torus + sphere\n        float dist = min(sdSphere(rotX*rotZ*(pos - spherePos), torus1Props.x),\n                         sdTorus1(rotX*(pos - torus1Pos), torus1Props));\n        float distdx = min(sdSphere(rotX*rotZ*(posdx - spherePos), torus1Props.x),\n                           sdTorus1(rotX*(posdx - torus1Pos), torus1Props));\n        float distdy = min(sdSphere(rotX*rotZ*(posdy - spherePos), torus1Props.x),\n                           sdTorus1(rotX*(posdy - torus1Pos), torus1Props));\n                    \n        float dist1 = min(dist,sdTorus2(rotZ*(pos - torus2Pos), torus2Props));\n        float distdx1 = min(distdx,sdTorus2(rotZ*(posdx - torus2Pos), torus2Props));\n        float distdy1 = min(distdy,sdTorus2(rotZ*(posdy - torus2Pos), torus2Props));\n        \n        \n        if(dist1 < 0.001  && distdx1 < 0.001 && distdy1 < 0.001){\n        \n            vec3 lightDir = rayDir;\n            //checking color of surface shape...\n            vec3 col1 = vec3(0.9, 1, 0.8);\n            \n            vec3 torusCol = vec3(col1 + texture(iChannel1, uv+col1.xy).rgb - vec3(0.5));\n            \n            col = torusCol*dot(-lightDir, normalize(cross(posdy - pos, posdx - pos)));\n            col *= col1 + texture(iChannel1, uv+col1.xy).rgb - vec3(0.5);\n                      \n            break;\n        } \n                \n        t = t + dist1;\n        tdx = tdx + distdx1;\n        tdy = tdy + distdy1;\n    }\n    \n    \n    col = mix(col,vec3(texture(iChannel0, uv.xy).rrr),(cos(iTime)-0.5));\n    \n    // Output to screen\n    fragColor = vec4(col,cos(iTime));\n}","name":"Image","description":"","type":"image"}]}