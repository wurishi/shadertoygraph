{"ver":"0.1","info":{"id":"4cSBWV","date":"1725489525","viewed":63,"name":"fast godray post process","username":"BearKirb","description":"asfasfasfahlhlkjsafhlashlkjfahjfa","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf","sdf","sdf","asd","asd","asd","asdf","asf","ad","fa","fa","fa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n\nfloat hash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec3 noisei(vec2 p){\n\n vec2 m=iMouse.xy/iResolution.xy;\n  float siz=1.0;\n  vec3 c = texture(iChannel0,1.0*p*siz).rgb;\n float div=200.0;\n  for(int i=0;i<40;i++){\n  siz*=0.92-(hash(uvec2((p+vec2(i))*iResolution.xy))*0.08);\n  vec4 ad=texture(iChannel0,(((1.0*p-(m))*siz)+(m))).rgba; \nc+=((mix(ad.rgb,vec3(1.0),0.8))/div)*ad.a-0.003;\n\n}\n  return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord/iResolution.xy);\n    vec3 col;\n    vec2 m=iMouse.xy/iResolution.xx;\n\n\tfragColor = vec4(noisei(p),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float random(in vec2 uv)\n{\n    return texture(iChannel0, uv / 64.).r;\n}\n\nfloat Mand(vec3 pos) {\nvec2 q1 = pos.xz - 4.0*round(pos.xz/4.0);\nvec3 q=vec3(q1.x,pos.y,q1.y);\npos=round(pos/4.0)*4.0;\nq+=(vec3(random(vec2(pos.x,pos.y)),random(vec2(pos.y,pos.z)),random(vec2(pos.z,pos.x)))-vec3(0.5))*4.0;\n\treturn length(q)-0.5;\n}\n\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = random(i + vec2(0., 0.));\n    float rb = random(i + vec2(1., 0.));\n    float lt = random(i + vec2(0., 1.));\n    float rt = random(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = .5;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        value += noise(uv) * amplitude;\n        \n        amplitude *= .5;\n        \n        uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Sky(in vec3 ro, in vec3 rd)\n{\n    const float SC = 1e5;\n\n \t// Calculate sky plane\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 cloudCol = vec3(1.);\n    //vec3 skyCol = vec3(.6, .71, .85) - rd.y * .2 * vec3(1., .5, 1.) + .15 * .5;\n    vec3 skyCol = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    // sun\n    vec3 sun = 0.25 * vec3(1.0,0.7,0.4) * pow( sundot,5.0 );\n    sun += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot,64.0 );\n    sun += 0.2 * vec3(1.0,0.8,0.6) * pow( sundot,512.0 );\n    skyCol += sun*2.0;\n    \n    // clouds\n    float t = iTime * 0.5;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n    \n    // horizon\n    skyCol = mix( skyCol, 0.68 * vec3(.418, .394, .372), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return skyCol;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\nfloat sdBox( vec3 p, vec3 b ,float r)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdf(vec3 p){\n\n//float f=sdBox(p,vec3(1.0,0.2,1.0),0.1);\n//f=smin(f,sdTorus(p-vec3(0.0,0.3,0.0),vec2(0.5,0.1)),0.005);\nfloat f= Mand(p);\nreturn f;\n}\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvoid Rotate( inout vec2 vect, vec2 angle )\n{\nvec3 vector = vec3(vect.x,0.0,vect.y);\n\tvect.yx = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvect.xy = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec3 calcNormal(vec3 p) {\nfloat EPSILON = 0.0001;\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n  vec3 po=rd;\n  int breaki=0;\n  float minDist=10000.0;\n    for( int i=0; i<44; i++ )\n    {\n  \n        po -= normalize(rd-ro) * sdf(po);\n        minDist=min(minDist,sdf(po));\n  \n      \n      \n    }\n          if( sdf(po)<0.04){\n        if(distance(po,ro)<0.04){\n            return 1.0;\n            }else{\n            return 0.0;\n            }\n            }\n    return 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 8.0*(fragCoord-iResolution.xy*0.5)/-iResolution.x;\n vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, \n\t\t\t\t0.5 ) ); \n             \n    vec3 pos = vec3(0.0,0.0,-3.0); \n    \n  \n \n    \nvec2 angle = -(iMouse.xy/iResolution.xy-.5)*4.14+vec2(3.14,0.0);\n\tRotate(pos,angle);\n \n\tRotate(ray,angle);\n vec3 cameraPos = pos; \n float it=0.0;\n    fragColor.rgb = Sky(cameraPos,normalize(ray));\n    float cameraPosDist=distance(vec3(0.0,0.0,0.0),cameraPos);\n    for(int x=0;x<60;x++){\n    it++;\n    float h=sdf(pos);\n    if(h<0.0001||h>cameraPosDist+1.0){\n    break;\n    }else{\n    \n    \n    \n    pos+=ray*h;\n    }\n    }\n     fragColor.a = 1.0;\n    if(sdf(pos)<0.01){\n    vec3 light=vec3(-1000.0,10.0,0.0);\n     vec3 normal = calcNormal(pos);\n    vec3 ambient = vec3(0.3,0.23,0.1)/1.1;\n   \n    float d = max(dot(normal,normalize(light-pos)),dot(normal,-normalize(light-pos)));\n    vec3 lambert=ambient*d/(it/20.0);\n    vec3 reflec = Sky(vec3(0.0,0.0,0.0),reflect(ray,normal))/10.4;\n    vec3 spec = vec3(pow(d,32.0))/1.6;\n    fragColor.rgb = max((ambient+lambert)/1.1,(ambient+lambert+spec+reflec));\n fragColor.a = 0.0;\n    }\n   \n}","name":"Buffer A","description":"","type":"buffer"}]}