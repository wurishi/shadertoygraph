{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n\n#define MAX_STEP 64\n#define EPILSON 0.05\n#define NORMAL_EPILSON 0.0001\n\n\n\n\nconst float viewDist = 40.0;\n\nconst float lightDist = 20.0;\nvec4 lightColor;\nvec3 lightPos;\n\nvec3 cameraUp = vec3(0.0,1.0,0.0);\nvec3 cameraRight,cameraPosition,cameraDirection;\n\n\n\n//distance functions\n//take from iq's site https://iquilezles.org/articles/distfunctions\n\nfloat sphere(in vec3 p, in float radius) {//signed\n    return length(p)-radius;\n}\nvec3 sphereNormal(in vec3 p, in float radius) {\n    return normalize(vec3(\n        sphere(vec3(p.x+NORMAL_EPILSON,p.y,p.z),radius)-sphere(vec3(p.x-NORMAL_EPILSON,p.y,p.z),radius),\n        \n\t\tsphere(vec3(p.x,p.y+NORMAL_EPILSON,p.z),radius)-sphere(vec3(p.x,p.y-NORMAL_EPILSON,p.z),radius),\n        \n        sphere(vec3(p.x,p.y,p.z+NORMAL_EPILSON),radius)-sphere(vec3(p.x,p.y,p.z-NORMAL_EPILSON),radius)\n        ));\n}\n\nfloat roundBox(in vec3 p, in vec3 boxExt, in float round) {//unsigned\n    return length(max(abs(p)-boxExt,0.0))-round;\n}\nvec3 roundBoxNormal(in vec3 p, in vec3 boxExt, in float round) {\n    return normalize(vec3(\n        roundBox(vec3(p.x+NORMAL_EPILSON,p.y,p.z), boxExt, round)-roundBox(vec3(p.x-NORMAL_EPILSON,p.y,p.z),boxExt,round),\n        \n\t\troundBox(vec3(p.x,p.y+NORMAL_EPILSON,p.z), boxExt, round)-roundBox(vec3(p.x,p.y-NORMAL_EPILSON,p.z),boxExt,round),\n        \n        roundBox(vec3(p.x,p.y,p.z+NORMAL_EPILSON), boxExt, round)-roundBox(vec3(p.x,p.y,p.z-NORMAL_EPILSON),boxExt,round)\n        ));\n}\n\nfloat box(in vec3 p, in vec3 boxExt) {//unsigned\n    return length(max(abs(p)-boxExt,0.0));\n}\nvec3 boxNormal(in vec3 p, in vec3 boxExt) {\n    return normalize(vec3(\n        box(vec3(p.x+NORMAL_EPILSON,p.y,p.z), boxExt)-box(vec3(p.x-NORMAL_EPILSON,p.y,p.z),boxExt),\n        \n\t\tbox(vec3(p.x,p.y+NORMAL_EPILSON,p.z), boxExt)-box(vec3(p.x,p.y-NORMAL_EPILSON,p.z),boxExt),\n        \n        box(vec3(p.x,p.y,p.z+NORMAL_EPILSON), boxExt)-box(vec3(p.x,p.y,p.z-NORMAL_EPILSON),boxExt)\n        ));\n}\n\n\nfloat raySphere(in vec3 p, in vec3 dir, in float sphereRad) {\n    \n    float c = dot(p, p) - (sphereRad*sphereRad);\n    float b = dot(dir, p);\n\n    float d = b*b - c;\n    float t = -b - sqrt(abs(d));\n    \n    if (!(d < 0.0 || t < 0.0)) {\n        return t;\n    } else {\n    \treturn 0.0;\n    }\n    \n}\n\n\n\n//scene functions \n\nconst vec3 boxPos = vec3(0.0,-4.0,0.0);\nconst vec3 boxExt = vec3(1.0);\n\nvoid scene(in vec3 rayPos, out int hitId, out float hitDist) {\n    float db;\n    \n    //floor\n\thitId = 0;\n    hitDist = abs(rayPos.y+10.0);\n\n    //x+ wall\n    db = abs(rayPos.x+15.0);\n    if (db < hitDist) {\n        hitId = 1;\n        hitDist = db;\n    }\n    \n    //x- wall\n    db = abs(rayPos.x-15.0);\n    if (db < hitDist) {\n        hitId = 2;\n        hitDist = db;\n    }\n    \n    //z+ wall\n    db = abs(rayPos.z+15.0);\n    if (db < hitDist) {\n        hitId = 3;\n        hitDist = db;\n    }\n    \n    //z- wall\n    db = abs(rayPos.z-15.0);\n    if (db < hitDist) {\n        hitId = 4;\n        hitDist = db;\n    }\n    \n    //cube\n    db = box(rayPos-boxPos,boxExt);\n    if (db < hitDist) {\n        hitId = 5;\n        hitDist = db;\n    }\n}\n\n\n\nvoid trace(in vec3 rayStartPos, in vec3 rayStartDir, in float maxDist, out int hitId, out float hitDist) {\n    \n    float s = 0.0,db;\n    vec3 rayPos;\n    \n    for (int i = 0; i < MAX_STEP; i++) {\n        //get new ray pos\n        rayPos = rayStartPos+rayStartDir*s;\n        \n\t\tscene(rayPos,hitId,hitDist);\n        \n        if (hitDist < EPILSON) {\n            hitDist = s;\n            return;\n        }\n        \n\n        s += hitDist;\n        if (s >= maxDist) {\n            break;\n        }\n    }\n    \n    hitDist = maxDist;\n    hitId = -1;//hit id is -1 if nothing is hit\n}\n\n\n\n#define msamp texture(iChannel0,(mod(lightVec.xz,0.5))*0.4).x\n\n\n//LIGHT VOLUMES\n\n\n#define LIGHT_PRECISION 0.2\n#define MAX_LIGHT_STEPS 64\n#define LIGHT_AM 0.05\n#define SHADOW_AM 0.05\n\n\nvec4 traceLightSphere(in vec3 rayStart, in vec3 rayDir, in vec3 end, in vec3 pos, in float rad) {\n    float traceSphere = raySphere(rayStart-pos,rayDir,rad);\n    \n    float endLen = length(rayStart-end);\n    if (traceSphere == 0.0 || endLen < traceSphere) {\n        return vec4(0.0);\n    }\n    \n    float sum = 0.0;\n    vec3 rayPos = rayStart+rayDir*traceSphere;\n    vec3 lightVec;\n        \n    int hitId;\n    float hitDist,atten;\n    \n    for (int i = 0; i < MAX_LIGHT_STEPS; i++) {\n        lightVec = rayPos-pos;\n        atten = length(lightVec);\n        lightVec = normalize(lightVec);\n        trace(rayPos,-lightVec,atten,hitId,hitDist);\n        \n        atten = 1.0-atten/rad;\n        \n        if (hitId == -1) {\n            sum += msamp*LIGHT_AM*atten;\n        } else {\n            sum -= SHADOW_AM*atten;\n        }\n        \n        rayPos += rayDir*LIGHT_PRECISION;\n        if (length(rayStart-rayPos) > endLen || length(pos-rayPos) > rad) {\n            break;\n        }\n    }\n    \n    return vec4(max(0.0,sum))*lightColor;\n}\n\n\n\n\n//main\n\n#define lti max(0.0,dot(lightVec,norm))*atten*lightColor\n\nconst vec2 cameraMoveSpeed = vec2(0.1,0.1);\nconst vec3 cameraMoveDistance = vec3(14.0,4.0,14.0);\n\nconst vec2 CENTER_UV = vec2(0.5,0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //calculate camera\n    cameraPosition = vec3(sin(iTime*cameraMoveSpeed.x)*cameraMoveDistance.x,\n                          cameraMoveDistance.y,\n                          cos(iTime*cameraMoveSpeed.y)*cameraMoveDistance.z);\n    cameraDirection = normalize(-cameraPosition);\n\n    \n    lightPos = vec3(sin(iTime)*5.0,\n                    -4.0,\n                    cos(iTime)*5.0);\n    lightColor = vec4(sin(iTime)*0.5+0.5,\n                      cos(iTime)*0.5+0.5,\n                      sin(iTime*1.4)*0.4+0.4,\n                      1.0);\n                    \n    \n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-CENTER_UV;\n    cUv.x *= iResolution.x/iResolution.y;\n\t\n    //camera vectors\n    cameraRight = cross(cameraDirection,cameraUp);\n    //cameraUp = cross(cameraRight,cameraDirection);\n   \n   \n        \n  \tvec3 rayStartDir = normalize((cUv.x*cameraRight +\n                  \t\t\t\tcUv.y*cameraUp +\n        \t\t  \t\t\t\tcameraPosition + cameraDirection)-cameraPosition);\n    vec3 rayStartPos = cameraPosition;\n    \n    \n\n    //scene\n    \n    int hitId;\n    float hitDist;\n    trace(rayStartPos,rayStartDir,viewDist,hitId,hitDist);\n    \n    if (hitId == -1) {\n        return;\n    }\n    \n    vec3 hitPos = rayStartPos+rayStartDir*hitDist;\n    vec3 lightVec = lightPos-hitPos;\n    lightVec = normalize(lightVec);\n    float atten = max(0.0,1.0-length(lightVec)/lightDist);\n    \n    \n    //volumetric light sphere\n    fragColor = traceLightSphere(rayStartPos,rayStartDir,hitPos,lightPos,12.0);\n    \n    \n    //walls\n    if (hitId < 5) {\n        vec3 norm;\n        \n        if (hitId == 0) {\n            norm = vec3(0.0,1.0,0.0);\n        } else {\n            if (hitId == 1) {\n                norm = vec3(1.0,0.0,0.0);\n            } else {\n                if (hitId == 2) {\n                    norm = vec3(-1.0,0.0,0.0);\n                } else {\n                    if (hitId == 3) {\n                    \tnorm = vec3(0.0,0.0,1.0);\n                    } else {\n                        if (hitId == 4) {\n                            norm = vec3(0.0,0.0,-1.0);\n                        }\n                    }\n                }\n            }\n        }\n        \n        \n        fragColor += vec4(0.2)*lightColor+\n            \t\tmsamp*atten*lti*vec4(0.8);\n        \n        return;\n    }\n    \n    //cube\n    vec3 norm = boxNormal(hitPos-boxPos,boxExt);\n    fragColor += vec4(0.2)*lightColor+\n            msamp*atten*lti*vec4(0.6);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ll3D7","date":"1422665324","viewed":310,"name":"volumetric light show","username":"public_int_i","description":"light show","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","light","volumetric","march","show"],"hasliked":0,"parentid":"","parentname":""}}