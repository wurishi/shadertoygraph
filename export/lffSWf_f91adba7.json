{"ver":"0.1","info":{"id":"lffSWf","date":"1705856100","viewed":189,"name":"CIE 1931 to sRGB gamut mapping","username":"Nazlbit","description":"Animation of CIE 1931 to sRGB gamut mapping on a xyY chromaticity diagram.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["color","space","mapping","srgb","diagram","gamut","cie","chromaticity","1931"],"hasliked":0,"parentid":"ctG3Rz","parentname":"sRGB gamut chromaticity diagram"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://en.wikipedia.org/wiki/CIE_1931_color_space\n// https://en.wikipedia.org/wiki/SRGB\n// http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html\n// https://en.wikipedia.org/wiki/Standard_illuminant#Illuminant_E\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// https://bottosson.github.io/posts/gamutclipping/\n\nconst vec2 diagram_range = vec2(0.8, 0.9);\n\nfloat g(const float x, const float a, const float b, const float c)\n{\n    float d = x - a;\n    d *= (x < a) ? b : c;\n    return exp(-0.5 * d * d);\n}\n\nvec3 wl2xyz_CIE1931(const float w){\n    float x = 1.056 * g(w, 599.8, 0.0264, 0.0323) + 0.362 * g(w, 442.0, 0.0624, 0.0374) - 0.065 * g(w, 501.1, 0.049, 0.0382);\n    float y = 0.821 * g(w, 568.8, 0.0213, 0.0247) + 0.286 * g(w, 530.9, 0.0613, 0.0322);\n    float z = 1.217 * g(w, 437.0, 0.0845, 0.0278) + 0.681 * g(w, 459.0, 0.0385, 0.0725);\n    return vec3(x,y,z);\n}\n\nconst mat3 XYZ_WGRGB = mat3( 1.4628067, -0.1840623, -0.2743606,\n                            -0.5217933,  1.4472381,  0.0677227,\n                             0.0349342, -0.0968930,  1.2884099);\n\nconst vec3 white_d50 = vec3(0.3457, 0.3585, 1.);\nconst vec3 red_wgrgb = vec3(0.7350, 0.2650, 0.258187);\nconst vec3 green_wgrgb = vec3(0.1150, 0.8260, 0.724938);\nconst vec3 blue_wgrgb = vec3(0.1570, 0.0180, 0.016875);\n\nconst mat3 XYZ2SRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                           -0.9692660, 1.8760108, 0.0415560,\n                           0.0556434, -0.2040259, 1.0572252);\n\nconst vec3 white_d65 = vec3(0.3127, 0.329, 1.);\nconst vec3 red_srgb = vec3(0.64, 0.33, 0.2126);\nconst vec3 green_srgb = vec3(0.3, 0.6, 0.7152);\nconst vec3 blue_srgb = vec3(0.15, 0.06, 0.0722);\n\nfloat linear2gamma(const float x)\n{\n    return x > 0.0031308 ? 1.055 * pow(x, 1.0/2.4) - 0.055 : 12.92 * x;\n}\n\nvec3 linear2gamma(const vec3 x)\n{\n    return vec3(linear2gamma(x.r), linear2gamma(x.g), linear2gamma(x.b));\n}\n\nfloat grid(vec2 uv)\n{\n    const float grid_step = 0.05;\n    float pixel_size = 1.0/iResolution.y;\n    vec2 range = diagram_range + pixel_size;\n    if(uv.x < -pixel_size || uv.y < -pixel_size || uv.x > range.x || uv.y > range.y)\n    {\n        return 0.0;\n    }\n    vec2 uv_grid = round(uv / grid_step);\n    uv_grid = uv_grid * grid_step;\n    vec2 d = abs(uv - uv_grid) / pixel_size;\n    return max(1. - min(d.x, d.y), 0.);\n}\n\nvec3 xyz2xyY(vec3 xyz)\n{\n    return vec3(xyz.xy / (xyz.x + xyz.y + xyz.z), xyz.y);\n}\n\nvec3 xyY2xyz(vec3 xy)\n{\n    return vec3(xy.x / xy.y, 1.0, (1.0 - xy.x - xy.y) / xy.y) * xy.z;\n}\nvec3 project_to_gamut(const vec3 xyY, const vec3 white, const vec3 red, \n                          const vec3 green, const vec3 blue)\n{\n    vec3 primaries[] = vec3[](red, green, blue);\n    vec3 prev = blue;\n    vec2 d0 = normalize(xyY.xy - white.xy);\n    for(int i = 0; i < 3; ++i)\n    {\n        vec2 d1 = white.xy - prev.xy;\n        vec2 d2 = primaries[i].xy - prev.xy;\n        float t1 = (d1.x *  d0.y - d1.y * d0.x) / (d2.x * d0.y - d2.y * d0.x);\n        float t2 = (d2.x * t1 - d1.x) / d0.x;\n        if(t1 >= 0. && t1 <= 1. && t2 >= 0.)\n        {\n            vec2 mix_xy = white.xy + d0 * t2;\n            float mix_Y = prev.z * primaries[i].z * mix_xy.y * (prev.y - primaries[i].y) / (prev.z * primaries[i].y * (prev.y - mix_xy.y) - primaries[i].z * prev.y * (primaries[i].y - mix_xy.y));\n            return vec3(mix_xy, mix_Y);\n        }\n        prev = primaries[i];\n    }\n    return vec3(0.0);\n}\n\nfloat inside_cie1931_color_space(const vec2 xy, const vec2 white)\n{\n    const int num_samples = 101;\n    const float range_min = 440.;\n\tconst float range_max = 640.;\n    vec2 uv_to_white = white - xy;\n    vec2 d3 = normalize(uv_to_white); // a vector from uv to the cie xyz space center (white point).\n    vec2 prev_xy = xyz2xyY(wl2xyz_CIE1931(range_max)).xy;\n    float smallest_dist = 1.0;\n    for(int i = 0; i < num_samples; ++i)\n    {\n        float w = range_min + (range_max - range_min) * (float(i) / float(num_samples - 1));\n        vec2 cie1931_xy = xyz2xyY(wl2xyz_CIE1931(w)).xy;\n        vec2 d1 = cie1931_xy - prev_xy;\n        vec2 d2 = xy - prev_xy;\n        // Find the intersection point of the edge segment and d3.\n        float t1 = (d1.x * d2.y - d1.y * d2.x) / (d3.x * d1.y - d3.y * d1.x);\n        float t2 = (d2.x + d3.x * t1) / d1.x;\n        if(t2 >= 0. && t2 < 1. && t1 < smallest_dist)\n        {\n            smallest_dist = t1;\n        }\n        prev_xy = cie1931_xy;\n    }\n    return smallest_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Transform the UV coordinates to align the diagram to the center of the screen.\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    xy -= 0.5;\n    xy.x *= iResolution.x / iResolution.y;\n    xy += diagram_range * 0.5;\n\n    // Gamut mapping\n    float dist = inside_cie1931_color_space(xy, white_d65.xy);\n    vec2 white_to_xy = xy - white_d65.xy;\n    float w_to_cie_edge_dist = length(white_to_xy) - dist;\n    vec3 proj = project_to_gamut(xy.xyy, white_d65, red_srgb, green_srgb, blue_srgb);\n    float w_to_srgb_edge_dist = length(proj.xy - white_d65.xy);\n    float ratio = w_to_srgb_edge_dist / w_to_cie_edge_dist;\n    vec2 mapped_xy = white_d65.xy + white_to_xy * ratio;\n    float mix_factor = iMouse.z > 0. ? clamp((iMouse.x / iResolution.x - 0.05) / 0.9, 0., 1.) : sqrt((1. - cos(iTime)) * 0.5);\n    mapped_xy = mix(xy, mapped_xy, mix_factor);\n\n    // Calculate the XYZ color from the diagram coordinates.\n    vec3 xyz = xyY2xyz(vec3(mapped_xy, 1.));\n    \n    // Switch from CIE XYZ color space to sRGB color space.\n    vec3 srgb = xyz * XYZ2SRGB;\n\n    // Normalize the color so that the sum of the RGB components is 1.\n    xyz = xyY2xyz(vec3(mapped_xy, 1. / (srgb.r + srgb.g + srgb.b)));\n    \n    srgb = xyz * XYZ2SRGB;\n\n    // Negative values are outside the sRGB gamut.\n    float srgb_mix_factor = float(min(min(srgb.x, srgb.y), srgb.z) > 0.);\n\n    float cie_1931_mix_factor = clamp(1. - dist * iResolution.y * 0.5, 0., 1.);\n    vec3 cie_1931 = clamp(srgb, 0., 1.) * 0.4;\n\n    const vec3 background = vec3(0);\n    const vec3 grid_color = vec3(1);\n    vec3 result = background;\n    result = mix(result, cie_1931, cie_1931_mix_factor);\n    result = mix(result, grid_color, grid(xy));\n    result = mix(result, srgb, srgb_mix_factor);\n\n    result = linear2gamma(result);\n    fragColor = vec4(result, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}