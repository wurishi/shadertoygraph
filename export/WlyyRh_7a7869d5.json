{"ver":"0.1","info":{"id":"WlyyRh","date":"1610411837","viewed":154,"name":"Thin layer BRDF","username":"athibaul","description":"Trying out the BRDF of a thin layer, as presented in \"Samurai shading in Ghost of Tsushima\"","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["shading","brdf","samurai","thinlayer","tsushima"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// BRDF of a thin layer, \n// as presented in \"Samurai shading in Ghost of Tsushima\"\n// https://youtu.be/LC8VedwibkI?t=1118\n\n#define PI 3.1415926\n#define ONE_OVER_4PI (1./(4.*PI))\n\n#define R(th) mat2(cos(th),sin(th),-sin(th),cos(th))\n\nfloat sdPeach(vec3 p)\n{\n    float dip = pow(clamp(1.-sqrt(p.x*p.x+0.002),0.,1.), 4.);\n    dip *= 0.08*pow(max(p.y+0.5,0.),2.);\n    dip += 0.3*pow(max(1.-length(p.xy), 0.), 3.);\n    float radius = 1.0 - dip;\n    return length(p) - radius;\n}\n\nfloat map(vec3 p)\n{\n    float plane = p.z + 1.0;\n    vec3 q = p-vec3(-1.5,0,-0.15);\n    q.xy *= R(-0.3);\n    q.xz *= R(-0.1);\n    float ball1 = sdPeach(q);\n    q = (p-vec3(1.5,0,-0.15));\n    q.xy *= R(0.6);\n    q.xz *= R(0.2);\n    float ball2 = sdPeach(q);\n    return min(min(plane, ball1), ball2);\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    float d, t=0.;\n    for(int i=0; i<256; i++)\n    {\n        d = map(ro+t*rd);\n        if(d < 0.001 || t > 100.) break;\n        t += d*0.7;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = 0.002*vec2(1,-1);\n    return normalize(\n         e.xxx*map(p+e.xxx)\n        +e.xyy*map(p+e.xyy)\n        +e.yxy*map(p+e.yxy)\n        +e.yyx*map(p+e.yyx));\n}\n\nfloat calcLayerDensity(vec3 p, vec3 n)\n{\n    if(p.z < -0.99)\n    {\n        // Floor\n        //return mod(floor(p.x)+floor(p.y)+sin(p.x+p.y*0.62)+cos(p.x*0.8-p.y), 1.5);\n        float tex = texture(iChannel0, p.xy*0.1).r + texture(iChannel0, p.xy*0.1618).r;\n        return tex * 0.2;\n    }\n    else if(p.x < 0.)\n    {\n        // Ball 1\n        p *= 0.5;\n        // Trilinear mapping\n        float texXY = texture(iChannel0, p.xy).r;\n        float texYZ = texture(iChannel0, p.yz).r;\n        float texZX = texture(iChannel0, p.zx).r;\n        n = n*n; n=n*n;\n        n /= (n.x+n.y+n.z);\n        float tex = texYZ*n.x + texZX*n.y + texXY*n.z;\n        tex = smoothstep(0.1,0.6,tex);\n        return 0.05+0.2*tex;\n    }\n    else\n    {\n        // Ball 2\n        return 0.0001;\n    }\n}\n\nvec3 calcDiffuseCol(vec3 p, vec3 n)\n{\n    if(p.z > -0.99)\n    {\n        // Ball 1\n        p *= 0.1;\n        // Trilinear mapping\n        float texXY = texture(iChannel0, p.xy).r;\n        float texYZ = texture(iChannel0, p.yz).r;\n        float texZX = texture(iChannel0, p.zx).r;\n        n = n*n; n=n*n;\n        n /= (n.x+n.y+n.z);\n        float tex = texYZ*n.x + texZX*n.y + texXY*n.z;\n        return vec3(0.7,0.1,0.05)*0.7 + vec3(0.3,0.4,0.0)*smoothstep(0.1,0.7,tex);\n    }\n    return vec3(0.945,0.894,0.612)*0.5;\n}\n\nfloat calcShadow(vec3 p, vec3 rd, float len)\n{\n    return step(len, raymarch(p,rd));\n}\n\nvec3 BRDFThinScatteringLayer(vec3 V, vec3 L, vec3 N, float density, vec3 albedo,\n    out vec3 baseLayerAttenuation)\n{\n    // Compute the BRDF of a thin scattering layer, as in\n    // \"Samurai Shading in Ghost of Tsushima\"\n    // https://youtu.be/LC8VedwibkI?t=1118\n    float LdotN = max(dot(L,N), 0.001);\n    float VdotN = max(dot(V,N), 0.001);\n    float LdotV = max(dot(L,V), 0.001);\n    float phaseFunction = ONE_OVER_4PI; // Uniform\n    float numerator = 1. - exp(-density*(VdotN+LdotN)/(LdotN*VdotN));\n    vec3 brdf = albedo * phaseFunction * numerator/(VdotN+LdotN);\n    \n    // Compute the base layer attenuation due to traversing the scattering layer\n    float Pp = exp(-density/LdotN);\n    float Pe = exp(-density/VdotN);\n    float Ps = 0.5;\n    baseLayerAttenuation = (Pp + albedo*(1.-Pp)*Ps) * Pe;\n    \n    return brdf * LdotN;\n}\n\n\n// Ambient Occlusion computation adapted from iq\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor, float scale )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + scale*0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)/scale*sca;\n        sca *= 0.95;\n        if( occ>0.5 ) break;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\n}\n\n\n\n\nvec3 shadeSurface(vec3 p, vec3 n, vec3 rd, vec3 lightPos, vec3 lightCol)\n{\n    vec3 lightDir = normalize(lightPos - p);\n    float lightDist = length(lightPos - p);\n    vec3 col = vec3(0.);\n    vec3 diffuseCol = calcDiffuseCol(p,n);\n    float falloff = 1./(lightDist*lightDist + 0.1);\n    float ao = calcAO(p,n,5.0);\n    \n    // Not sure about the normalization\n    vec3 diffuse = max(dot(n, lightDir), 0.)*ONE_OVER_4PI * lightCol * diffuseCol * falloff;\n    col += diffuse;\n    \n    // Specular, not really physically-based\n    // More or less Blinn-Phong inspired\n    vec3 halfVector = normalize(-rd + lightDir);\n    float HdotN = max(dot(halfVector, n), 0.);\n    float fre = 0.04 + 0.96*pow(max(1.-dot(-rd,halfVector),0.),5.);\n    //return vec3(fre);\n    // I tuned exponent and intensity for a nice look,\n    // but don't expect it to be energy-preserving.\n    vec3 specular = pow(HdotN, 10.) * lightCol * ONE_OVER_4PI * 0.03;\n    col += specular*fre;\n    \n    // Shade the thin surface layer\n    vec3 baseLayerAttenuation;\n    vec3 albedo = vec3(0.5);\n    float density = calcLayerDensity(p,n);\n    vec3 thinLayer = BRDFThinScatteringLayer(-rd, lightDir, n, density, albedo, baseLayerAttenuation) * falloff * lightCol;\n    \n    if(density < 0.01) baseLayerAttenuation = vec3(1.0);\n    col = col*baseLayerAttenuation + thinLayer;\n    \n    col *= ao; // Shouldn't do that, but I don't have enough courage to add soft shadows.\n    return col;\n}\n\nvec3 shade(vec3 ro, vec3 rd)\n{\n    float t = raymarch(ro, rd);\n    vec3 col;\n    if(t < 100.)\n    {\n        vec3 p = ro+t*rd;\n        vec3 n = normal(p);\n        //col = 0.5+0.5*n;\n        \n        col  = shadeSurface(p, n, rd, vec3(10,10,8), 2000.*vec3(1.1,1.0,0.9));\n        col += shadeSurface(p, n, rd, vec3(-10,10,0), 600.*vec3(0.9,1.0,1.1));\n        col += shadeSurface(p, n, rd, vec3(0,-10,3), 500.*vec3(1.0,1.0,0.9));\n    }\n    else\n    {\n        //col = skyColor(rd);\n        //col = 0.5+0.5*rd;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    \n    float th = iTime*0.5+1.5;\n    vec3 ro = vec3(5.*cos(th),5.*sin(th),2);\n    vec3 camFwd = normalize(vec3(0)-ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    vec3 rd = normalize(camFwd + 0.5*(uv.x*camRight+uv.y*camUp));\n\n    vec3 col = shade(ro, rd);\n    \n    //col = 1.-exp(-col);\n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col *= 1.0;\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}