{"ver":"0.1","info":{"id":"tddBRH","date":"1604488306","viewed":186,"name":"Chmutov Surfaces","username":"gPlatl","description":"Collection of algebraic Chmutov surfaces.\nAdditional rotate the surface with your mouse.\nPress key 1 .. 6 to select other surfaces degrees,  'c' color,  't' texture.","likes":16,"published":1,"flags":16,"usePreview":0,"tags":["implicit","surface","chebyshev","algebraic","chmutov"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------\n// ChmutovSurfaces_Image.glsl  \n//\n// https://www.shadertoy.com/view/tddBRH\n//  \n//   v1.0  2020-11-06  initialize Chmutov Surfaces\n//\n// a fork of https://www.shadertoy.com/view/MtyfRK \n// see also  https://www.shadertoy.com/view/3t3yD2\n//\n// tags: implicit, algebraic, chebyshev, chmutov, surface \n//\n// key commands:\n//  1..6 select surface degree\n//   'c' change color scheme\n//   't' change texture scheme\n//   'n' change normal calculation\n//\n//------------------------------------------------\n// references:\n//   https://math.ucr.edu/home/baez/diary/january_2017.html\n//   https://cults3d.com/en/3d-model/various/surface-de-chmutov-math\n//------------------------------------------------\n     \n// uncomment to select function\n//#define FAST\n#define QUALITY\n\n// set to 1 might stress your compiler!\n#define H_CHMUTOV 0\n\nconst float PI =  3.141592654;\n\n// (T)Chebyshev polynomials:  T(2n,x) = T(n,x)*T(n,x)-1\n// https://en.wikipedia.org/wiki/Chebyshev_polynomials\n// https://de.wikipedia.org/wiki/Tschebyschow-Polynom\n\nfloat  T4(float x) { float x2=x*x; return     1.0+x2*( -8.0+x2*8.0); }\nfloat  T5(float x) { float x2=x*x; return x*( 5.0+x2*(-20.0+x2*16.0)); }\nfloat  T6(float x) { float x2=x*x; return    -1.0+x2*( 18.0+x2*( -48.0+x2*32.0)); }\nfloat  T7(float x) { float x2=x*x; return x*(-7.0+x2*( 56.0+x2*(-112.0+x2*64.0))); }\nfloat  T8(float x) { float x2=x*x; return     1.0+x2*(-32.0+x2*(+160.0+x2*(-256.0+x2*128.0))); }\nfloat  T9(float x) { float x2=x*x; return x*( 9.0+x2*(-120.+x2*( 432.0+x2*(-576.0+x2*256.0)))); }\nfloat T10(float x) { float x2=x*x; return    -1.0+x2*( 50.0+x2*(-400.0+x2*(1120.0+x2*(-1280.0+x2*512.0)))); }\n\n//float T7 (float x) { return 2.0*x* T6(x) -  T5(x); }\n//float T8 (float x) { return 2.0*x* T7(x) -  T6(x); }\n//float T10(float x) { return 2.0*x* T9(x) -  T8(x); }\n  float T11(float x) { return 2.0*x*T10(x) -  T9(x); }\n  float T12(float x) { return 2.0*x*T11(x) - T10(x); }\n  float T13(float x) { return 2.0*x*T12(x) - T11(x); }\n  float T14(float x) { return 2.0*x*T13(x) - T12(x); }\n  float T15(float x) { return 2.0*x*T14(x) - T13(x); }\n  float T16(float x) { return 2.0*x*T15(x) - T14(x); }\n\nfloat Chmutov4 (vec3 p) { return T4 (p.x)+T4 (p.y)+T4 (p.z)+1.0; }\nfloat Chmutov6 (vec3 p) { return T6 (p.x)+T6 (p.y)+T6 (p.z)+1.0; }\nfloat Chmutov8 (vec3 p) { return T8 (p.x)+T8 (p.y)+T8 (p.z)+1.0; }\nfloat Chmutov10(vec3 p) { return T10(p.x)+T10(p.y)+T10(p.z)+1.0; }\nfloat Chmutov12(vec3 p) { return T12(p.x)+T12(p.y)+T12(p.z)+1.0; }\nfloat Chmutov14(vec3 p) { return T14(p.x)+T14(p.y)+T14(p.z)+1.0; }\n\n// these functions need more compilation time!\n#if H_CHMUTOV\n float Chmutov16(vec3 p) { return T16(p.x)+T16(p.y)+T16(p.z)+1.0; }\n \nfloat T17(float x) { return 2.0*x*T16(x) - T15(x); }\n float T18(float x) { return 2.0*x*T17(x) - T16(x); }\n float Chmutov18(vec3 p) { return T18(p.x)+T18(p.y)+T18(p.z)+1.0; }\n\n float T19(float x) { return 2.0*x*T18(x) - T17(x); }\n float T20(float x) { return 2.0*x*T19(x) - T18(x); }\n float Chmutov20(vec3 p) { return T20(p.x)+T20(p.y)+T20(p.z)+1.0; }\n#endif\n\n//------------------------------------------------\n// get javascript keycode:  http://keycode.info/\n//------------------------------------------------\nbool ReadKey(int key, bool toggle)\n{\n  return 0.5 < texture(iChannel3\n    ,vec2((float(key)+0.5) / 256.0, toggle ? 0.75 : 0.25)).x;\n}\n//------------------------------------------------\nbool keyOn(int code) \n{ return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0; }\n\n//----------------------------------------------------------\n// javascript keycodes: http://keycode.info/\n// key testing:    https://www.shadertoy.com/view/llVSRm\n//----------------------------------------------------------\nconst int KEY_SPACE = 32;\n\nconst int KEY_0  = 48;\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\nconst int KEY_4  = 52;\nconst int KEY_5  = 53;\nconst int KEY_6  = 54;\nconst int KEY_7  = 55;\nconst int KEY_8  = 56;\nconst int KEY_9  = 57;\n\nconst int CHAR_C = 67;\nconst int CHAR_G = 71;\nconst int CHAR_N = 78;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\n\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\n\nint mainDemo = 0;  \n\n//------------------------------------------------\n// rotate p about given angle t \n//------------------------------------------------\nvec2 rotate(vec2 p, float t)  \n{ \n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t); \n}\n//------------------------------------------------\nvec3 map(vec3 p) {\n  p.xz = rotate(p.xz, 0.1*iTime);\n  return p;\n}\n//------------------------------------------------\nfloat Fun(vec3 p) \n{\n  if      (mainDemo == 1) return Chmutov4 (map(p));\n  else if (mainDemo == 2) return Chmutov6 (map(p));\n  else if (mainDemo == 3) return Chmutov8 (map(p));\n  else if (mainDemo == 4) return Chmutov10(map(p));\n  else if (mainDemo == 5) return Chmutov12(map(p));\n  else if (mainDemo == 6) return Chmutov14(map(p));\n#if H_CHMUTOV\n  else if (mainDemo == 7) return Chmutov16(map(p));\n  else if (mainDemo == 8) return Chmutov18(map(p));\n  else if (mainDemo == 9) return Chmutov20(map(p));\n#endif\n  else                    return Chmutov12(map(p));\n}\n\n//------------------------------------------------\n// Compute gradient & normal\n//------------------------------------------------\nvec3 normal(vec3 p)\n{    \n  float eps = 1e-3;\n  vec2 delta = vec2(eps,0.0);\n  float a = Fun(p);\n  vec3 n = vec3(0);  \n  if (keyOn(CHAR_N)) \n    n = vec3(Fun(p + delta.xyy), Fun(p + delta.yxy), Fun(p + delta.yyx)) - a;\n  // two sided numeric derivative\n  else n = vec3(Fun(p + delta.xyy) - Fun(p - delta.xyy),\n                Fun(p + delta.yxy) - Fun(p - delta.yxy),\n                Fun(p + delta.yyx) - Fun(p - delta.yyx));\n  float grad = abs(length(n));\n  return normalize(n);\n}\n//------------------------------------------------\n// get surface color\n//------------------------------------------------\nvec3 selectColor(vec3 q, vec3 eye, vec3 n) \n{\n  vec3 col = vec3(0.8, 0.7, 0.2);  // yellow\n\n  if (keyOn(CHAR_C)) \n//  col = 0.5+0.5*n;           // normal.rgb\n    col *= 0.6+0.4*n.z;        // shading\n\n  else if (keyOn(CHAR_T)) \n  {                            // Octamap\n    vec3 p = (reflect(eye,n));\n    p /= dot(p, vec3(1));\n    col = (texture(iChannel1, p.xy).rgb);\n    col *= 0.5 + 0.5*abs(n.z); // shading\n  }\n  else                         // cubemap color   \n    col = texture(iChannel0, map(reflect(eye,n))).rgb;\n\n  return col;  \n}\n//------------------------------------------------\n// solution parameters\n//------------------------------------------------\n#if defined FAST\n const int iterations = 100;     // Maximum number of iterations\n const float maxincrease = 1.1;  // Largest allowed step increase.\n#elif defined QUALITY\n const int iterations = 300;     // Maximum number of iterations\n const float maxincrease = 1.03; // Largest allowed step increase.\n#else\n const int iterations = 150;     // Maximum number of iterations\n const float maxincrease = 1.06; // Largest allowed step increase.\n#endif\n\nconst float maxstep = 1.0;     // The largest step that can be taken.\nconst float minstep = 0.001;   // The smallest step\nconst float initstep = 0.1;\n\nbool solve(vec3 p0, vec3 r, out float k) \n{\n  float k0 = 0.0, k1;\n  float a0 = Fun(p0), a1;\n  bool bracketed = false;\n  bool found = false;\n  float step = initstep;\n  vec3 p;\n  float expected = 0.0;\n  for (int i = 0; i < iterations; i++) {\n    if (bracketed) {\n      // Once we are bracketed, just use bisection\n      if (k1-k0 < minstep) {\n        found = true;\n        break;\n      }\n      float k2 = (k0 + k1)/2.0;\n      //x = x0+k2*a, y = y0+k2*b, z = z0+k2*c, w = 1.0;\n      p = p0+k2*r;\n      float a2 = Fun(p);\n      if (a0*a2 <= 0.0) \n      {      k1 = k2; a1 = a2; }\n      else { k0 = k2; a0 = a2; }\n    } else {\n      k1 = k0 + step;\n      p = p0 + k1*r;\n      a1 = Fun(p);\n      //The idea here is to try and correct the\n      // step size by seeing how close we are to\n      // the curve, but it doesn't seem to work\n      // very well.\n      float q = abs((a1-expected)/(a1+expected));\n      if (false && expected != 0.0 && q > 0.25) {\n        step *= 0.5;\n        expected = a0 + 0.5*(expected - a0);\n      } else if (a0*a1 <= 0.0) {\n        // We can hit exactly 0 - this counts as bracketed.\n        bracketed = true;\n      } else {\n        float step0 = step;\n        step = a1*step/(a0-a1);\n        step = abs(step);\n        step = min(step,maxstep);\n        // Don't grow step by more than a certain amount\n        // A better strategy should be possible\n        // Detect overstepping & retreat maybe.\n        step = max(step,minstep);\n        step = min(step,maxincrease*step0);\n        if (a1 <= a0) expected = 0.0;\n        else expected = a1 + step*(a1-a0)/(k1-k0);\n        k0 = k1; a0 = a1;\n      }\n    }\n  }\n  if (!found) return false;\n  k = 0.5*(k0+k1);\n  return true;\n}\n//------------------------------------------------\n// calculate surface: p0: origin, r: direction \n//------------------------------------------------\nvec3 surface(vec3 p0, vec3 r) \n{\n  float k;\n  if (!solve(p0,r,k))  // get distance factor k\n    return vec3(0);\n\n  vec3 p = p0 + k*r;   // get position\n  vec3 n = normal(p);  // get normal at position p   \n  vec3 eye = r.xyz;    \n  if (dot(eye,n) > 0.0) n *= -1.0;  // point normal towards eye\n  return selectColor(p, eye, n);\n}\n//------------------------------------------------\n// rotate surface\n//------------------------------------------------\nvec3 transform(vec3 p) \n{\n  if (iMouse.x > 0.0) {\n    vec2 angles = (2.0*iMouse.xy-iResolution.xy)/iResolution.xy*PI;\n    p.yz = rotate(p.yz, angles.y);\n    p.zx = rotate(p.zx,-angles.x);\n  }\n  p.yz = rotate(p.yz,iTime * 0.06);\n  p.zx = rotate(p.zx,-iTime * 0.1);\n  return p;\n}\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n  mainDemo = 0;\n  if      (ReadKey(KEY_1, false)) mainDemo = 1;\n  else if (ReadKey(KEY_2, false)) mainDemo = 2;\n  else if (ReadKey(KEY_3, false)) mainDemo = 3;\n  else if (ReadKey(KEY_4, false)) mainDemo = 4;\n  else if (ReadKey(KEY_5, false)) mainDemo = 5;\n  else if (ReadKey(KEY_6, false)) mainDemo = 6;\n  else if (ReadKey(KEY_7, false)) mainDemo = 7;\n  else if (ReadKey(KEY_8, false)) mainDemo = 8;\n  else mainDemo = 1 + int(7.*fract(iTime / 50.));\n      \n  // Projection parameters\n  vec2 p = 3.0 * (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n  float camera = 8.0;\n  vec3 p0 = vec3(0.0,0.0,camera);\n  vec3 r = normalize(vec3(p.x, p.y, -camera));\n\n  p0 = transform(p0);\n  r = transform(r);\n  fragColor = vec4(surface(p0,r),1);\n}\n","name":"Image","description":"","type":"image"}]}