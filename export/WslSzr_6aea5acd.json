{"ver":"0.1","info":{"id":"WslSzr","date":"1550498409","viewed":155,"name":"vonronoi mystery glass","username":"Myro","description":"quick glass-like animated vonroi pattern ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","color","animated","glass","pattern","fragment","mystery","vonronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"vonronoise\" from iq - https://www.shadertoy.com/view/Xd23Dh\n// More info here: https://iquilezles.org/articles/voronoise\n\n// ell noise    u=0,v=0\n// voronoi      u=1,v=0\n// perlin noise u=0,v1=\n// voronoise    u=1,v=1\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat vonronoi(vec2 x) {\n\treturn iqnoise(x,0.7,0.0);\n}\n\nfloat noise(vec2 x) {\n\treturn iqnoise(x,0.0,1.0);\n}\n\nfloat vonronoise(vec2 x) {\n\treturn iqnoise(x,1.0,1.0);\n}\n// ---------------------------------------\n\n// 3D noise from iq https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n// ----------------------------------------\n\n\n// noise but with intensity & contrast control\n// i : intensity, a-b : step begin & end, x : your coordinate : h 3D component (time)\nfloat noiseStep(float i, float a, float b, vec2 x, float h) {\n    float d = 0.2*(b-a);\n\treturn 1.0-i+(smoothstep(a-d, b+d, noise(vec3(x,h))*(i)));\n}\n\n// cosine palette by iq\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette (float t) {\n    return cosineColor( t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n}\n// ---------------------------------------\n\n// ORIGINAL TO THIS SHADER\n\nconst float dx = 0.12;\n\nfloat vonronoistroke(vec2 uv) {\n    float h = vonronoi(uv);\n    float d = 0.0;\n    d -= 0.5*vonronoi(uv+vec2(0,dx));\n    d -= 0.5*vonronoi(uv+vec2(dx,0));\n    h += d;\n    h*=10.0;\n    return abs(h);\n}\n\nconst float rotSpeed= 0.1;\n\nfloat glassFragment (vec2 uv) {\n    float rotAngle = rotSpeed * iTime;\n    mat2 rotmat = mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n    mat2 invrotmat = mat2(cos(-rotAngle), -sin(-rotAngle), sin(-rotAngle), cos(-rotAngle));\n\treturn clamp(vonronoistroke(uv * invrotmat) / (1.0 + 5.0*vonronoistroke(3.0*uv * rotmat)),0.0,1.0);\n}\n\nfloat height(vec2 uv) {\n\treturn 0.05+(noiseStep(0.95,0.55,0.6,uv*0.8, iTime*0.5)-0.1) * glassFragment(uv);\n}\n\n// retuns a color for a given point on the map, and time offset\nvec3 getColor (vec2 uv) {\n\treturn palette(height(uv))*(0.1+height(uv)*0.9);\n}\n\nconst float SCALE = 20.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized screen pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec2 mapuv = uv;// coordinate on the map\n    \n    if (iMouse.y <= 0.0) mapuv *= SCALE*0.5;\n    else mapuv *= SCALE *iMouse.y / iResolution.y;\n    \n    // vignette & vertical gradient\n    float postfx = -0.2*(length(uv)*length(uv)-0.1);\n    // Output to screen\n    fragColor = vec4(getColor(mapuv) + postfx,1.0);\n}","name":"Image","description":"","type":"image"}]}