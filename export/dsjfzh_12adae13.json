{"ver":"0.1","info":{"id":"dsjfzh","date":"1689445717","viewed":113,"name":"Colored Glass Maze flythrough","username":"Pelegefen","description":"Glass Maze, saw some cool glass on a trip to Venice, decided to try and make something inspired by it.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glass","infinite","maze","flythrough"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 256\n#define MAX_DIST 3.5\n#define SURF_DIST .0001\n#define MIN_DIST .8\n#define TAU 6.283185\n#define PI 3.141592\n\n#define S smoothstep\n\n\nfloat manhattanDistance(vec2 p1, vec2 p2)\n {\n \t\tfloat d1 = abs(p1.x - p2.x);\n \t\tfloat d2 = abs(p1.y - p2.y);\n\n \t\treturn d1 + d2;\n}\nfloat manhattanDistance(vec3 p1, vec3 p2)\n {\n \t\tfloat d1 = abs(p1.x - p2.x);\n \t\tfloat d2 = abs(p1.y - p2.y);\n \t\tfloat d3 = abs(p1.z - p2.z);\n \t\treturn d1 + d2 + d3;\n}\nfloat mtLength(vec3 p)\n{\n return manhattanDistance(vec3(0), p);\n}\n\nfloat mtLength(vec2 p)\n{\n return manhattanDistance(vec2(0), p);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k )\n {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n }\n\n vec3 opTwist( vec3 p , float am)\n{\n    float  c = cos(am*p.y+am);\n    float  s = sin(am*p.y+am);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\nfloat hash13(vec3 p) {\n    p = fract(p * 433.14);\n    p += dot(p, p.yzx + 19.19);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec3 hash33(vec3 p) {\n    p = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz+33.33);\n    return fract((p.xxy + p.yxx)*p.zyx);\n}\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphereM(vec3 p, float r) {\n    return mtLength(p) - r;\n}\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0)) + min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0)) + min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0)) + min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec3 Transform(vec3 p)\n{\n\tp *= .5;\n\tfloat t = sin(iTime / 10000.);\n\tp = opTwist(p, length(p) * t);\n\n\tfloat tm = iTime * .1;\n\t   p.y += sin(((iTime * TAU) * .1) + 5.) * .5;\n\t   p.x -= sin(((iTime * TAU) * .1) + 5.) * .5;\n     p.xz -= tm;\n     return p;\n}\n\n\nvec3 Id(vec3 p)\n{\n    return floor(p);\n}\n\n\nfloat GetDist(vec3 p) {\n\n    vec3 po = p;\n\t   p = Transform(p);\n\n    vec3 pr = fract(p) - .5;\n\n\n    vec3 id = Id(p) -.5;\n    float rand = hash13(id);\n    float sphereSpeed = sin(iTime - rand * 518.);\n    if(mod(id.y + id.x + id.z, 2.) == 0.) pr.xyz = pr.xzy;\n\n    vec3 ty = pr;\n    ty.y *=  1. +\n    \tfract(rand * 62.422 + 46.54853);\n    float tor = sdTorus(ty, vec2(.2,.01));\n\n    float d = tor;\n\n    float frameBox =\n    \tsdBoxFrame(pr, vec3(.45,.45,.45),.05) -.01;\n    \td = min(d, frameBox);\n\n    vec3 sMove =  vec3(0., sphereSpeed * .25, 0);\n    float sphere =\n    \tsdSphere(pr - sMove, .1);\n    float sphereM =\n    \t\tsdSphereM(pr - sMove, .1);\n\n    float ball = mix(sphere, sphereM,\n    \t 1. - abs(sphereSpeed));\n\n\n      d = smin(d, ball,  rand * .7);\n\n    \tfloat nearFade = sdSphere(po, MIN_DIST);\n\n    \treturn float(opSmoothSubtraction(nearFade,d,.1)) * .6;\n}\n\n\n\nfloat RayMarchRef(vec3 ro,\n\t vec3 rd,\n\t float side,\n\t   int div)\n\t    {\n\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS / div; i++) {\n        vec3 p = ro + rd * dO;\n\n        float dS = GetDist(p) * side;\n        dO += dS;\n        if(dO > MAX_DIST)\n        {\n           break;\n        }\n        else if(abs(dS) < SURF_DIST)\n        {\n        \t break;\n        }\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n {\n\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 GetColor(vec3 ro ,\n\t vec3 n,\n\t  float d)\n{\n  vec3 p = Transform(ro);\n\n  vec3 id = Id(p);\n\n  float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n\n  vec3 rnd = hash33(id);\n  vec3 colored = fract(rnd);\n  float shade = dif ;\n\n  colored *= shade;\n\n  return colored ;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3(0., .006, -.01);\n    ro.yz *= Rot(-m.y * PI + 1.);\n    ro.xz *= Rot(-m.x * TAU + PI);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0, 0, 0.), .35);\n    vec3 col = texture(iChannel0,rd, 0.).rgb;\n\n    float d = RayMarchRef(ro, rd, 1., 1);\n\n    float IOR = 1.45; // index of refraction\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n        \n        vec3 mr = GetColor(p,n,d);\n\n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n*SURF_DIST*3.;\n        float dIn = RayMarchRef(pEnter, rdIn, -1.,1); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 rdOut = refract(rdIn, nExit, IOR);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        \n        col = texture(iChannel0, rdOut).rgb;\n        float dif = dot(n, normalize(vec3(1, 2, 3))) * .5 + .5;\n        vec3 pRef = p + n*SURF_DIST*3.;\n\n        d = RayMarchRef(pRef, r, 1., 2);\n        if(d<MAX_DIST)\n        {\n            p = pRef + r * d;\n            n = GetNormal(p);\n            vec3 clr = GetColor(p,n,d);\n      \n            mr += clr;\n        }\n        else\n        {\n            mr += texture(iChannel0,r, 0.).rgb;\n        }\n\n        \n        col = mix(col, mr.rgb, dif);\n    }\n\n    col = pow(col, vec3(.4545));    // gamma correction\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}