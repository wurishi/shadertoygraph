{"ver":"0.1","info":{"id":"lXXyz4","date":"1725902823","viewed":45,"name":"void_V3","username":"TRASHTRASH","description":"more details to a classic design","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["visuals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//by Joshua deLorimier\n// Function to create a true hexagon\nfloat hexDist(vec2 p, float size) {\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return max(dot(p, vec2(0.8660254, 0.5)), p.y) - size; // 0.8660254 = sqrt(3)/2\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates (fragCoord is pixel position)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Centered coordinates in range [-1.0, 1.0]\n    vec2 p = (uv - 0.5) * 2.0;\n\n    // Hexagon parameters\n    float baseSize = 0.01; // Base size for the smallest hexagon\n    float sizeIncrement = 0.03; // Amount by which each hexagon size increases\n    float outlineThickness = 0.01; // Smaller value for sharper transition\n    float outlineControl = 0.02; // Base size for outline\n    float numHexagons = 50.0; // Number of hexagons\n    float glowIntensity = 0.08; // Increased intensity of the glow\n    float glowRadius = 0.001; // Smaller radius for more concentrated glow\n    float contrastPower = 2.5; // Increased power to boost highlights further\n    float brightnessMultiplier = 1.8*1.2; // Multiplier to further brighten the hexagons\n\n    // Separate variables to control the speed of the rotation and distortion\n    float rotationSpeed = 0.5 * 1.5;   // Controls the speed of hexagon rotation\n    float distortionSpeed = 0.5 * 5.0; // Controls the speed of the optical distortion\n\n    // Initialize the background color\n    vec3 bgColor = vec3(0.0); // Black background\n\n    // Distance from the center (used for brightness)\n    float centerDist = length(p);\n\n    // Optical flow distortion effect\n    float timeFlow = iTime * distortionSpeed;\n\n    // Optical flow field for distortion (flowing sine wave pattern)\n    vec2 flowField = vec2(\n        sin(uv.y * 10.0 + timeFlow) * 0.02, // Horizontal distortion\n        cos(uv.x * 10.0 + timeFlow) * 0.02  // Vertical distortion\n    );\n\n    // Apply flowField to UV coordinates to distort the scene\n    vec2 distortedUV = uv + flowField;\n\n    // Recalculate centered coordinates after distortion\n    vec2 p_distorted = (distortedUV - 0.5) * 2.0;\n\n    // Loop over each hexagon\n    vec3 color = bgColor; // Default to background color\n    for (float i = 0.0; i < numHexagons; i++)\n    {\n        // Offset each hexagon's time by `i` for animation effect\n        float timeOffset = i * 0.15; // Adjust the offset as needed\n        float angle = iTime * rotationSpeed + timeOffset; // Rotation angle based on time and offset\n\n        // Increment size for each hexagon\n        float size = baseSize + i * sizeIncrement;\n\n        // Rotation matrix for hexagon\n        float cosA = cos(angle);\n        float sinA = sin(angle);\n        vec2 p_rot = vec2(\n            cosA * p_distorted.x - sinA * p_distorted.y,\n            sinA * p_distorted.x + cosA * p_distorted.y\n        );\n\n        // Calculate the true hexagon distance using the hexDist function\n        float hexDistance = hexDist(p_rot, size);\n\n        // Sharp outline calculation using combined smoothstep and step functions\n        float outline = smoothstep(outlineControl - outlineThickness, outlineControl, hexDistance) -\n                        smoothstep(outlineControl, outlineControl + outlineThickness, hexDistance);\n\n        // Brightness increases as distance from the center increases\n        float brightness = smoothstep(0.0, 0.5, centerDist);\n\n        // Apply a stronger contrast boost\n        brightness = pow(brightness, contrastPower);\n\n        // Apply brightness multiplier to further enhance brightness\n        brightness *= brightnessMultiplier;\n\n        // Determine fill and outline colors\n        vec3 fillColor = vec3(1.0) * brightness; // Brighter on the edges\n        vec3 outlineColor = vec3(0.0); // Black outline\n\n        // Mix fill and outline colors\n        vec3 hexColor = mix(fillColor, outlineColor, outline);\n\n        // Stronger Glow Effect\n        float glow1 = smoothstep(glowRadius, glowRadius + 0.05, hexDistance) * glowIntensity;\n        float glow2 = smoothstep(glowRadius + 0.05, glowRadius + 0.15, hexDistance) * (glowIntensity * 0.5); // Second layer of glow for strength\n        vec3 glowColor = vec3(1.0, 0.9, 0.6) * (glow1 + glow2); // Brighter and warmer glow\n\n        // Combine hexagon color with glow\n        hexColor += glowColor;\n\n        // Combine hexagon color with background\n        color = mix(color, hexColor, outline);\n    }\n\n    // Final color output\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}