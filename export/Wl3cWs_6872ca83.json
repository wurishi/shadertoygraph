{"ver":"0.1","info":{"id":"Wl3cWs","date":"1610212665","viewed":121,"name":"Lennard Jones carpet","username":"savegor","description":"Next step of \"Concentration of attention\". Just added individual color for each particle.\nUse mouse to interact with particles (particles are fixed before first interaction).","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["particles","lennardjones"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Concentration of attention\" by savegor. https://shadertoy.com/view/3ldcDS\n// 2021-01-08 18:28:10\nfloat has_particle(particle cell_state, vec2 cell_pos) {\n    vec2 diff = abs(cell_state.pos - cell_pos);\n\treturn float(diff.x < 0.5 && diff.y < 0.5);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragCoord += 2.0 * CELL_SIZE;\n    vec3 glow = vec3(0.0);\n    \n    for(float dx = -2.0; dx < 2.01; dx ++) {\n        for(float dy = -2.0; dy < 2.01; dy ++) {\n            vec2 cell_pos = floor(fragCoord * SCALE) + vec2(dx + 0.5, dy + 0.5) ;\n            vec2 uv = cell_pos / iResolution.xy;\n            particle p = unpack(texture(iChannel0, uv));\n            float dist = distance(fragCoord, p.pos * CELL_SIZE);            \n            glow += 0.23 / dist * p.color * has_particle(p, cell_pos);\n        }\n    }\n    \n    fragColor = vec4(glow, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nbool has_particle(particle cell_state, vec2 cell_pos) {\n    vec2 diff = abs(cell_state.pos - cell_pos);\n\treturn diff.x < 0.5 && diff.y < 0.5;    \n}\n\nvec2 calc_accel(particle p, vec2 other_p_cell) {\n    vec2 cell_uv = other_p_cell / iResolution.xy;\n    particle other_p = unpack(texture(iChannel0, cell_uv));\n    \n    float particle_in_cell = float(has_particle(other_p, other_p_cell));\n    \n    vec2 diff = p.pos - other_p.pos;\n    \n    float sqr_dist = dot(diff, diff);\n    float dist = sqrt(sqr_dist);\n    \n    // Lennard Jones potential\n    // r_m = 2^(1/6) sigma\n    const float sigma = 2.5 / 1.122462;\n    const float epsilone = 0.5;\n    \n    // (sigma / r)^2\n    float rat_sqr = sigma * sigma / sqr_dist;\n    \n    float pow6_rat = rat_sqr * rat_sqr * rat_sqr;\n    float pow12_rat = pow6_rat * pow6_rat;\n    \n    vec2 diff_norm = diff / dist;\n    \n    float smooth_switch = smoothstep(dist, 3.0, 2.0);\n    \n    float force = epsilone * (pow12_rat - pow6_rat) * smooth_switch;\n    \n    force = clamp(force, -F_MAX, F_MAX);\n    \n    \n    return particle_in_cell * force * diff_norm * smooth_switch;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cur_cell = fragCoord;\n    \n    int x = int(cur_cell.x);\n    int y = int(cur_cell.y);\n    if(iFrame == 0 && x % 2 == 0 && y % 2 == 0) {\n        particle p;\n        p.pos = fragCoord.xy;\n        p.vel = vec2(0.0);\n        p.color = vec3(float((x + 1232) % 256) / 255.0,\n                       float((y + 7328) % 256) / 255.0,\n                       float((x + y) % 256) / 255.0);\n        p.color += vec3(0.5);\n        \n        fragColor = pack(p);\n    }\n    else {\n        \n        particle cur_state = unpack(texture(iChannel0, fragCoord / iResolution.xy));\n        particle next_state = particle(vec2(0.0), vec2(0.0), vec3(0.0));\n\n        if(iFrame % 2 == 0) {\n\t\t\t\n            if(has_particle(cur_state, fragCoord)) {\n                // COLLISION\n                // calculate the repulsion from particles\n                // in the outer boundary:\n                //\n                // * * * * *\n                // *       *\n                // *   O < O\n                // *   ^   *\n                // * * O * *\n                // \n                vec2 accel = vec2(0.0);\n                \n                for(float i = -3.0; i < 3.01; i += 1.0) {\n                    for(float j = -3.0; j < 3.01; j += 1.0) {\n                        if(abs(i) > 0.1  || abs(j) > 0.1) {\n                        \taccel += calc_accel(cur_state, fragCoord + vec2(i, j));\n                        }\n                    }\n                }\n\t\t\t\t\n\n                cur_state.vel += accel;\n                \n                // MOUSE FORCE\n                vec2 mouse_pos = iMouse.xy * SCALE;\n                if(iMouse.z > 0.0) {\n                    vec2 mouse_diff = mouse_pos - cur_state.pos;\n                    float mouse_dist = dot(mouse_diff, mouse_diff);\n                    \n                    cur_state.vel += mouse_diff / mouse_dist;\n                \n                }\n                \n                // FRICTION\n                cur_state.vel *= 0.97;\n                \n                 // velocity normalization\n                float velocity = length(cur_state.vel);\n                float new_vel = clamp(velocity, 0.0, 0.5);\n                cur_state.vel = cur_state.vel / velocity * new_vel;\n                \n                fragColor = pack(cur_state);\n            }\n        }\n        else {\n            // MOTION\n            // simulation the particle propagation from the \n            // neighbouring cells into current one:\n            //\n            //  ____________________\n            // |      |      |      |\n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      |\n            // |  O---|->    |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      | \n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            //\n\n            \n            // 1) cur state is empty (we could add here a check for boundaries)\n            if(!has_particle(cur_state, cur_cell)) {\n                \n                int count = 0;\n                \n                for(int i = 0; i < 8; ++i) {\n                    vec2 nb_cell = cur_cell + SHIFTS[i];\n\n                    particle nb_state = unpack(texture(iChannel0, nb_cell / iResolution.xy));\n\t\t\t\t\t\n                    // position of particle moved from the neighboring cell\n                    vec2 nb_pos_after_move = nb_state.pos + nb_state.vel;\n\t\t\t\t\t\n                    // diff from the current cell to the neighbouring cell particle\n                    vec2 nb_particle_diff = abs(cur_cell - nb_pos_after_move);\n\n                    if(nb_particle_diff.x < 0.5 &&\n                       nb_particle_diff.y < 0.5 ) {\n                        count++;\n                        next_state.pos = nb_pos_after_move; // coord\n                        next_state.vel = nb_state.vel;    // velocity\n                        next_state.color = nb_state.color;\n                    }\n                }\n                \n                float can_move = float(count == 1);\n                next_state.pos *= can_move;\n                fragColor = pack(next_state);\n            }\n            // 2) cur state is not empty\n            else {\n                // if the current particle move away from the \n                // current cell we need to additional check\n                // that this particle is the nearest to the next one\n                \n                vec2 target_pos = cur_state.pos + cur_state.vel;\n                vec2 target_cell = floor(target_pos) + vec2(0.5, 0.5);\n                                \n                // if we the particle in the current cell\n                if(distance(target_cell, cur_cell) < 0.1) {\n                    next_state.pos = target_pos;\n                    next_state.vel = cur_state.vel;\n                    next_state.color = cur_state.color;\n                }\n                //try to move to the next cell\n                else {                    \n                    vec2 cell_shift = cur_cell - target_cell;\n                                        \n                    int count = 0;\n                    \n                    for(int i = 0; i < 8; ++i) {\n                        vec2 nb_cell = target_cell + SHIFTS[i];\n                        \n                        particle nb_state = unpack(texture(iChannel0, nb_cell / iResolution.xy));\n\n                        vec2 nb_pos_after_move = nb_state.pos + nb_state.vel;\n\t\t\t\t\t\t\n                        vec2 nb_particle_diff = abs(target_cell - nb_pos_after_move);\n\n                        count += int(nb_particle_diff.x < 0.5 && nb_particle_diff.y < 0.5);\n\n                    }\n                    \n                    particle target_state = unpack(texture(iChannel0, target_cell / iResolution.xy));\n\n                    float unable_move = float(count != 1 || has_particle(target_state, target_cell));\n                    \n                    next_state = particle(cur_state.pos, cur_state.vel * 0.6, cur_state.color);\n                    \n                    next_state.pos *= unable_move;\n                    next_state.vel *= unable_move;\n                }\n                \n                fragColor = pack(next_state);\n\n            }\n            \n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float F_MAX = 0.8;\nconst float CELL_SIZE = 2.0;\nconst float SCALE = 1.0 / CELL_SIZE;\n\nconst uint UINT16MAX = 65535u;\nconst float UINT16MAXF = 65534.0;\nconst float INV_UINT16MAXF = 1.0 / 65534.0;\n\nconst float RED_MUL = 255.0;\nconst float GREEN_MUL = 256.0 * 255.0;\nconst float BLUE_MUL = 256.0 * 256.0 * 255.0;\n\nconst vec2 SHIFTS[8] = vec2[8](\n    vec2(-1, -1),\n    vec2(-1,  0),\n    vec2(-1,  1),\n    vec2(0,  -1),\n    vec2(0,   1),\n    vec2(1,  -1),\n    vec2(1,   0),\n    vec2(1,   1)\n);\n\n\nstruct particle {\n    // red and green\n    vec2 pos;\n    // blue\n    vec2 vel; //from x, y in [-0.5, 0.5]: float -> uint -> uint/65535, uint%65535\n    // alpha\n    vec3 color; // color\n};\n\nparticle unpack(vec4 data) {\n    particle p;\n    p.pos = data.rg;\n    \n    uint blue = floatBitsToUint(data.b);\n\n    p.vel = vec2(float(blue / UINT16MAX) * INV_UINT16MAXF - 0.5,\n                 float(blue % UINT16MAX) * INV_UINT16MAXF - 0.5);\n    \n    uint alpha = floatBitsToUint(data.a);\n    p.color.r = float(alpha % 256u) / 255.0;\n\n    alpha /= 256u;\n    p.color.g = float(alpha % 256u) / 255.0;\n\n    alpha /= 256u;\n    p.color.b = float(alpha % 256u) / 255.0;\n            \n    return p;\n}\n\nvec4 pack(particle p) {\n    vec4 data;\n    data.rg = p.pos;\n\n    vec2 vel = clamp(p.vel, -0.5, 0.5) + vec2(0.5);\n    vel *= UINT16MAXF;\n    data.b = uintBitsToFloat(uint(vel.x) * UINT16MAX + uint(vel.y));\n    p.color = clamp(p.color, 0.0, 1.0);\n    float color = p.color.r * RED_MUL + p.color.g * GREEN_MUL + p.color.b * BLUE_MUL;\n    data.a = uintBitsToFloat(uint(color));\n    \n    return data;\n}\n","name":"Common","description":"","type":"common"}]}