{"ver":"0.1","info":{"id":"cd3Xzf","date":"1680172399","viewed":59,"name":"HW4 Aurora WIP","username":"lukawa","description":"Auroras","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","random","auroras"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R              iResolution\n#define Aspect         (R.x / R.y)\n#define UNIT           (1.0 / R.y)\n#define PI             3.1415926535\n#define coohomColor vec3(26.0/255.0,122.0/255.0,248.0/255.0) //背景颜色\n#define N              60.0\n#define theta       3.14 * 0.005 // 指针角度\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat rand (in float i) {\n    return fract(sin(dot(vec2(i,3452.2232),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// 旋转矩阵\nmat2 rot(float angle){\n    return mat2(\n        cos(angle),-sin(angle),\n        sin(angle),cos(angle)\n    );\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n    vec2 u = smoothstep(0.,1.0,f);\n\n    // Mix 4 coorners percentages\n    float x1 = mix(a,b,u.x);\n    float x2 = mix(c,d,u.x);\n    float y = mix(x1,x2,u.y);\n    return y;\n}\n\n\nfloat fbm ( in vec2 st,int octaves) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .4;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 _rot = rot(0.5);\n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(st*2.5);\n        st = _rot * st * 1.3 + shift;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat land_fbm(vec2 st, int octaves)\n{\n\tfloat value = 0.0;\n    float amp = .5;\n\tfloat m = 0.0;\n\t\n\tfor(int i=0; i<octaves; i++)\n    {\n        amp *= 0.5;\n\t\tvalue += amp*noise(st);\n        st = st * 2.0;\n\t\tm += amp;\n        //等价写法：\n        //float freq = pow(2.0, float(i));\n\t\t//float amp  = pow(0.5, float(i));\n\t\t//value += noise(freq * st) * amp;\n\t\t//m += amp;\n\t}\n\t\n\treturn value/m;\n}\n\n// Simple Perlin mountains \nvec3 renderLand(vec2 st)\n{\n    float i = floor(st.x);\n    float f = fract(st.x);\n    \n\tfloat y = land_fbm(vec2(20.0*st.x, 0.1), 2);\n\t\n\tif (st.y < y*.1+0.1)\n\t\treturn vec3(0.0);\n\t\n    vec3 col = vec3(.6*pow(st.y-1.,2.0));\n    // 这里用mix过渡效果不好\n    //col = mix(vec3(.5),vec3(0),st.y);\n    //return col\n    \n    vec2 sub_st = st*1000.0;\n\tif (random(floor(sub_st)) < .01)\n    {\n        //根据整数部分生成的随机值\n        float s1 = random(floor(sub_st)*floor(sub_st));\n        //每个sample中的小点与中心点的距离，max表示sample的中心点\n        float s2 = max(1.-2.*distance(vec2(0.5),fract(sub_st)), 0.0);\n        //最终效果：每个整数点的中心位置亮度为1.0\n\t\treturn col + vec3(s1*s2);\n    }\n\n\treturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    //st.x *= Aspect;\n    \n    vec3 color = vec3(0.0);\n    // Landscape\n\tcolor += renderLand(st);\n    //vec2(st.x+sin(iTime),st.y)\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.*iTime,1);\n    q.y = fbm( st + vec2(1.),2);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 10.0*q + vec2(1.7,9.2)+ 0.15*iTime, 6);\n    r.y = fbm( st + 10.0*q + vec2(8.3,2.8)+ 0.1*iTime, 6);\n\n    float f = fbm(st+r,6);\n\n    color = mix(vec3(0.10,0.919608,0.666667),\n        color,\n        clamp((f*f)*4.0,0.0,1.0));\n    \n    \n    \n   \n    // Output to screen\n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}