{"ver":"0.1","info":{"id":"MlcyWr","date":"1676605984","viewed":86,"name":"Infinite seamless texture","username":"nilrem","description":"Endless seamless non-repeating same-properties texture from example\nPaper: https://hal.inria.fr/hal-01824773\nOriginal by FabriceNeyret2: https://www.shadertoy.com/view/MdyfDV (this is just a more verbose version)\nZoom via vertical mouse drag, G for grid","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["noise","textons","byexample"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 smoothTexture( int channel, vec2 uv )\n{\n    vec2 size = iChannelResolution[ channel ].xy;\n\tvec2 xy   = uv * size + 0.5;\n\tvec2 ixy  = floor( xy );\n\tvec2 fxy  = fract( xy );\n\t      xy  = ixy + fxy*fxy     * ( 3.0 - 2.0*fxy );\n       // xy  = ixy + fxy*fxy*fxy * ( fxy * ( fxy*6.0 - 15.0 ) + 10.0 );\n\t      xy  = (xy - 0.5) / size;\n    \n    vec4 result;\n    \n    switch( channel )\n    {\n        case 0 : { result = texture( iChannel0, xy ); break; }\n        case 1 : { result = texture( iChannel1, xy ); break; }\n        case 2 : { result = texture( iChannel2, xy ); break; }\n        case 3 : { result = texture( iChannel3, xy ); break; }\n    }\n    \n\t//return texture( sampler, xy );\n    return result;\n}\n \nvec4 smoothTextureGrad( int channel, vec2 uv, vec2 Gx, vec2 Gy )\n{\n    vec2 size = iChannelResolution[ channel ].xy;\n\tvec2 xy   = uv * size + 0.5;\n\tvec2 ixy  = floor( xy );\n\tvec2 fxy  = fract( xy );\n\t      xy  = ixy + fxy*fxy     * ( 3.0 - 2.0*fxy );\n       // xy  = ixy + fxy*fxy*fxy * ( fxy * ( fxy*6.0 - 15.0 ) + 10.0 );\n\t      xy  = (xy - 0.5) / size;\n\n    vec4 result;\n    \n    switch( channel )\n    {\n        case 0 : { result = textureGrad( iChannel0, xy, Gx, Gy ); break; }\n        case 1 : { result = textureGrad( iChannel1, xy, Gx, Gy ); break; }\n        case 2 : { result = textureGrad( iChannel2, xy, Gx, Gy ); break; }\n        case 3 : { result = textureGrad( iChannel3, xy, Gx, Gy ); break; }\n    }\n    \n\t//return texture( sampler, xy );\n    return result;\n}\n\nvec2 smoothTexCoord( vec2 uv, vec2 size )\n{\n    vec2   xy  = uv * size + 0.5;\n\tvec2  ixy  = floor( xy );\n\tvec2  fxy  = fract( xy );\n\t       xy  = ixy + fxy*fxy     * ( 3.0 - 2.0*fxy );\n        // xy  = ixy + fxy*fxy*fxy * ( fxy * ( fxy*6.0 - 15.0 ) + 10.0 );\n\t       xy  = (xy - 0.5) / size;\n    return xy;\n}\n\n//#define SMOOTH_TEXTURE\n//#define SMOOTH_TEXTURE_BOTCHED\n\n// ---------------------------------------------------------------------\n// With only 3 texture fetches, generates endless seamless non-repeating \n// same-properties texture from example. ( in the paper: +1 LUT fetch\n// to handle non-Gaussian correlated color histograms).\n\n// Simple implementation of our HPG'18 \n// \"High-Performance By-Example Noise using a Histogram-Preserving Blending Operator\"\n// https://hal.inria.fr/hal-01824773\n// ( color-histogram Gaussianisation not possible in shadertoy ;-) ). \n// ---------------------------------------------------------------------\n\n#define CON 1      // contrast preserving interpolation. cf https://www.shadertoy.com/view/4dcSDr\n#define Z   8.     // patch scale inside example texture\n\n#define rnd22(p)    fract(sin((p) * mat2(127.1,311.7,269.5,183.3) )*43758.5453)\n\nvec2 rnd22_( vec2 i )\n{\n    return fract( i * 1. * vec2(0.55455, 0.308517) );\n}\n\n#define srgb2rgb(V) pow( max(V,0.), vec4( 2.2 )  )          // RGB <-> sRGB conversions\n#define rgb2srgb(V) pow( max(V,0.), vec4(1./2.2) )\n\n// --- texture patch associated to vertex I in triangular/hexagonal grid. key 'P'\n// (textureGrad handles MIPmap through patch borders)\n//#define C(I)  ( keyToggle(16) ? vec4( I==P, I==P+vec2(1,0), I==P+vec2(0,1), 1 ) \\\n//                              : srgb2rgb( textureGrad(iChannel0, U/Z-rnd22(I) ,Gx,Gy)) - m*float(CON) )\n\n//#define C(I)  ( srgb2rgb( textureGrad(iChannel0, U/Z-rnd22(I) ,Gx,Gy)) - m*float(CON) )\n\nvec4 C( vec2 I, vec2 U, vec2 Gx, vec2 Gy, vec4 m )\n{\n    #ifdef SMOOTH_TEXTURE_BOTCHED\n      return srgb2rgb( smoothTextureGrad(   0, U/Z - rnd22(I), Gx, Gy ) ) - m*float(CON);\n    #else\n      return srgb2rgb( textureGrad( iChannel0, U/Z - rnd22(I), Gx, Gy ) ) - m*float(CON);\n    #endif\n}\n\n\n// --- for tests\n//#define C(I)     ( srgb2rgb( texture(iChannel0, U/8.-rnd22(I)) ) - m*float(CON) )\n//#define C(I)     ( srgb2rgb( textureGrad(iChannel0, U/Z-rnd22(I) ,Gx,Gy)) - m*float(CON) )\n//#define C(I)     H(I)\n//#define C(I)     vec4( I==P, I==P+vec2(1,0), I==P+vec2(0,1), 1 )\n\n#define S(v)       smoothstep( p,-p, v )                    // antialiased drawing\n#define hue(v)   ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) ) // from https://www.shadertoy.com/view/ll2cDc\n#define H(I)       hue( (I).x + 71.3*(I).y )\n\n//#define keyToggle(c) ( texelFetch( iChannel3, ivec2(64+c,2), 0 ).x > 0. ) // keyboard. from https://www.shadertoy.com/view/llySRh\n#define keyToggle(c)   ( texture( iChannel3, vec2( 64 + c, 2 ) / vec2(255,2), 0.0 ).x > 0. ) // keyboard. from https://www.shadertoy.com/view/llySRh\n\n\n#define PIXEL_SIZE .7\n\n// ---------------------------------------------------------------------\nvoid mainImage( out vec4 O, vec2 u )\n{\n    mat2 M0   = mat2( 1,0, .5,sqrt(3.)/2. ),\n          M   = inverse( M0 );                            // transform matrix <-> tilted space\n     \n     \n    vec2  R   = iResolution.xy,\n          z   = 2. * iMouse.xy / R - 0.5 + .42;\n     \n    float Ut  = 4.*z.y + 1.;\n          if( z.y == 0. )  { Ut = 2.; }\n          Ut  = exp2( Ut );\n    \n    float time = iTime * 0.1;\n    \n    vec2  U   = ( 2.*u - R ) / R.y * Z/8. * Ut + vec2( 2. * time ),\n          V   = M * U,                                     // pre-hexa tilted coordinates\n          I   = floor(V),                                  // hexa-tile id\n          P   = floor( M * vec2(2.*time) );                // center tile (to show patches)\n    float p   = PIXEL_SIZE * dFdy(U.y);                    // pixel size (for antialiasing)\n    vec2  Gx  = dFdx(U/Z);\n    vec2  Gy  = dFdy(U/Z);                                 // (for cross-borders MIPmap)\n    vec4  m   = srgb2rgb( texture( iChannel0, U, 99. ) );  // mean texture color\n    \n    vec3  F   = vec3( fract(V), 0 );\n          F.z = 1.0 - F.x - F.y;                           // local hexa coordinates\n    vec3  A;\n    vec3  W;\n    \n    if ( F.z > 0. )\n    {\n        O = ( W.x=       F.z ) * C( I            , U, Gx, Gy, m )      // smart interpolation\n          + ( W.y=       F.y ) * C( I + vec2(0,1), U, Gx, Gy, m )      // of hexagonal texture patch\n          + ( W.z=       F.x ) * C( I + vec2(1,0), U, Gx, Gy, m );     // centered at vertex\n    }\n    else                                               // ( = random offset in texture )\n    {\n        O = ( W.x =    - F.z ) * C( I + 1.0      , U, Gx, Gy, m )\n          + ( W.y = 1. - F.y ) * C( I + vec2(1,0), U, Gx, Gy, m )\n          + ( W.z = 1. - F.x ) * C( I + vec2(0,1), U, Gx, Gy, m );\n    }\n\n    #if CON    \n      O = m + O/length(W);  // contrast preserving interp. cf https://www.shadertoy.com/view/4dcSDr\n    #endif\n    \n    O = clamp( rgb2srgb(O), 0., 1.);\n    if (m.g==0.) O = O.rrrr;                           // handles B&W (i.e. \"red\") textures\n    \n    if (keyToggle(7)) O = mix( O, vec4(1), S(min(W.x,min(W.y,W.z))-p) ); // key 'G'; show grid   \n  //O = mix(O, H(floor(V+.5)), S(length(M0*(fract(V+.5)-.5))-.1));       // show nodes\n}","name":"Image","description":"","type":"image"}]}