{"ver":"0.1","info":{"id":"tttSzs","date":"1581597651","viewed":543,"name":"Menger Sponge Raytraced","username":"phi16","description":"raytracing menger sponge by tree traversal / cyclic camera motion (simply a loop)","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 dmin(vec4 x, float y, vec3 n) {\n\tif(x.w < 0.0) return vec4(n,y);\n    else if(y < 0.0) return x;\n    return x.w < y ? x : vec4(n,y);\n}\nfloat square(vec3 p, vec3 v) {\n    if(p.z < 0.0 || v.z > 0.0) return -1.0;\n    float t = - p.z / v.z;\n    vec3 c = p + v * t;\n    if(abs(c.x) < 1.0 && abs(c.y) < 1.0) return t;\n    else return -1.0;\n}\nvec4 cube(vec3 p, vec3 v, float flip) {\n\tvec4 dist = vec4(-1);\n    vec3 u = vec3(0,0,1) * flip;\n    dist = dmin(dist, square(p.xyz-u,v.xyz), vec3(0,0,1));\n    dist = dmin(dist, square(p.zxy-u,v.zxy), vec3(0,1,0));\n    dist = dmin(dist, square(p.yzx-u,v.yzx), vec3(1,0,0));\n    dist = dmin(dist, square(-p.xyz-u,-v.xyz), vec3(0,0,-1));\n    dist = dmin(dist, square(-p.zxy-u,-v.zxy), vec3(0,-1,0));\n    dist = dmin(dist, square(-p.yzx-u,-v.yzx), vec3(-1,0,0));\n    return dist;\n}\n\nvec3 scene(vec3 p, vec3 v) {\n    vec3 empty = vec3(0.1);\n    vec4 t;\n    int count = 0;\n    ivec3 l = ivec3(0);\n    bool hole = false;\n    if(abs(p.x) < 1. && abs(p.y) < 1. && abs(p.z) < 1.) {\n        for(int i=0;i<18;i++) {\n            vec3 c = p;\n            ivec3 e = clamp(ivec3(c * 3. / 2. + 1.5), 0, 2);\n            l = l * 3 + e;\n            vec3 o = vec3(e - 1) * 2.0 / 3.0;\n            p = (p - o) * 3.0;\n            count++;\n            ivec3 u = e;\n            hole = false;\n            if(u.x == 1 && u.y == 1) hole = true;\n            if(u.y == 1 && u.z == 1) hole = true;\n            if(u.z == 1 && u.x == 1) hole = true;\n            if(hole) break;\n        }\n    }\n    for(int i=0;i<18;i++) {\n        if(!hole) {\n            t = cube(p,v,1.);\n            if(t.w < 0.) return empty;\n            vec3 c = p + v * t.w;\n            ivec3 e = clamp(ivec3(c * 3. / 2. + 1.5), ivec3(0), ivec3(2));\n            l = l * 3 + e;\n            vec3 o = vec3(e - 1) * 2.0 / 3.0;\n            p = (p - o) * 3.0;\n            count++;\n        } else {\n            t = cube(p,v,-1.);\n            if(t.w < 0.) return empty;\n            for(int j=0;j<10;j++) {\n                ivec3 e = (l%3+3)%3;\n                bool up = false;\n                if(t.x < -0.5 && e.x == 2) up = true;\n                if(t.y < -0.5 && e.y == 2) up = true;\n                if(t.z < -0.5 && e.z == 2) up = true;\n                if(t.x > 0.5 && e.x == 0) up = true;\n                if(t.y > 0.5 && e.y == 0) up = true;\n                if(t.z > 0.5 && e.z == 0) up = true;\n                if(up) {\n                    vec3 o = vec3(e - 1) * 2.0 / 3.0;\n                    p = p / 3.0 + o;\n                    l /= 3;\n                    count--;\n                    if(count == 0) return empty;\n                } else break;\n            }\n            l -= ivec3(t.xyz);\n            p += t.xyz * 2.;\n        }\n        ivec3 u = l%3;\n        hole = false;\n        if(u.x == 1 && u.y == 1) hole = true;\n        if(u.y == 1 && u.z == 1) hole = true;\n        if(u.z == 1 && u.x == 1) hole = true;\n        if(count >= 7) break;\n    }\n    vec3 wp = (p+v*t.w) / pow(3.,7.); // what\n    vec3 lv = normalize(vec3(-1,2,-0.5));\n    return (wp*0.3+0.7) * (normalize(t.xyz)*0.3+0.7) * (dot(t.xyz,lv)*0.5+0.5);\n}\n\nvec3 image(vec2 uv) {\n    vec3 dir = normalize(vec3(uv*0.7,-1));\n    float vignetting = pow(mix(-dir.z,1.,0.5),10.0)*3.0;\n    float gt = iTime/2.;\n    \n    // Uniform Catmull-Rom spline\n    vec3 p0 = vec3(0,5,2);\n    vec3 p1 = vec3(0,0,1);\n    vec3 p2 = vec3(0,1./3.,-2./3.);\n    vec3 p3 = vec3(0,8./9.,-5./9.);\n    float t = fract(gt);\n    float a = 0.0;\n    float t0 = 0.;\n    float t1 = pow(distance(p0,p1),a) + t0;\n    float t2 = pow(distance(p1,p2),a) + t1;\n    float t3 = pow(distance(p2,p3),a) + t2;\n    float tt = mix(t1,t2,t);\n    vec3 a1 = ((t1-tt)*p0 + (tt-t0)*p1) / (t1-t0);\n    vec3 a2 = ((t2-tt)*p1 + (tt-t1)*p2) / (t2-t1);\n    vec3 a3 = ((t3-tt)*p2 + (tt-t2)*p3) / (t3-t2);\n    vec3 b1 = ((t2-tt)*a1 + (tt-t0)*a2) / (t2-t0);\n    vec3 b2 = ((t3-tt)*a2 + (tt-t1)*a3) / (t3-t1);\n    vec3 c  = ((t2-tt)*b1 + (tt-t1)*b2) / (t2-t1);\n    vec3 eye = c;\n    float r = t*3.1415926535/2. - 0.1;\n    dir.yz *= mat2(cos(r),-sin(r),sin(r),cos(r));\n   \n    float m = floor(gt)*3.1415926535/2.;\n    eye.yz *= mat2(cos(m),-sin(m),sin(m),cos(m));\n    dir.yz *= mat2(cos(m),-sin(m),sin(m),cos(m));\n    return scene(eye,dir) * vignetting;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y*2.;\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++) {\n        for(int j=0;j<2;j++) {\n            col += image(uv + vec2(i,j)/iResolution.y/2.) / 4.;\n        }\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}