{"ver":"0.1","info":{"id":"wlcBDl","date":"1613668687","viewed":744,"name":"Ground truth ambient occlusion","username":"Shcherbakov","description":"Sample from stream: https://www.youtube.com/watch?v=YFPV0rZoXnE&t=1s&ab_channel=GraphicsMonster","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["gtao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\nconst float PI = 3.14159;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map( in vec3 p )\n{\n    p -= vec3(1.5, 0, 2);\n    float k = 10.0 * (sin(iTime)); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q.xyz, vec2(0.8, 0.35));\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    float res = -1.0;\n    float h = 1.0;\n    for( int i=0; i<64; i++ )\n    {\n    if( h<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = t;\n        t += h;\n    }\n  if( t>10.0 ) res=-1.0;\n    return res;\n}\n\nfloat integrateArc(float h1, float h2, float n) {\n    return 0.25 * (-cos(2.0 * h1 - n) + cos(n) + 2.0 * h1 * sin(n))\n        + 0.25 * (-cos(2.0 * h2 - n) + cos(n) + 2.0 * h2 * sin(n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-15, -15, 10), vec3(-15, 15, 10), vec3(15, 15, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-15, -15, 10), vec3(15, 15, 10), vec3(15, -15, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    float intersectionSpecular;\n\n    vec2 screenUV = fragCoord / iResolution.xy;\n    vec4 gbuffer = texture(iChannel0, screenUV);\n    int encodedColor = int(gbuffer.x);\n    intersectionColor = vec3((encodedColor >> 16) & 0xFF, (encodedColor >> 8) & 0xFF, encodedColor & 0xFF) / 255.0;\n    intersectionNormal.z = cos(gbuffer.z);\n    intersectionNormal.x = cos(gbuffer.y) * sin(gbuffer.z);\n    intersectionNormal.y = sin(gbuffer.y) * sin(gbuffer.z);\n    intersectionDist = gbuffer.w;\n    intersectionPos = intersectionDist * viewVec + cameraPos;\n    \n    float ao = texture(iChannel2, screenUV).r;\n\n    vec3 lighting = intersectionColor * SKY_COLOR;\n\n    lighting += max(0.0, dot(intersectionNormal, -SUN_DIR)) * intersectionColor;\n    fragColor.rgb = lighting * ao;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map( in vec3 p )\n{\n    p -= vec3(1.5, 0, 2);\n    float k = 10.0 * (sin(iTime)); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q.xyz, vec2(0.8, 0.35));\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    float res = -1.0;\n    float h = 1.0;\n    for( int i=0; i<64; i++ )\n    {\n    if( h<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = t;\n        t += h;\n    }\n  if( t>10.0 ) res=-1.0;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-15, -15, 10), vec3(-15, 15, 10), vec3(15, 15, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-15, -15, 10), vec3(15, 15, 10), vec3(15, -15, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    const int SAMPLES_COUNT = 4;\n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    float intersectionSpecular;\n    for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n        float hitDist = ray_sphere_intersection(SPHERES[i], cameraPos, viewVec);\n        if (hitDist < intersectionDist) {\n            intersectionDist = hitDist;\n            intersectionColor = SPHERES[i].color;\n            intersectionPos = cameraPos + viewVec * intersectionDist;\n            intersectionNormal = normalize(intersectionPos - SPHERES[i].pos);\n            intersectionSpecular = SPHERES[i].specular;\n        }\n    }\n\n    for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n        float hitDist = ray_triangle_intersection(TRIANGLES[i], cameraPos, viewVec);\n        if (hitDist < intersectionDist) {\n            intersectionDist = hitDist;\n            intersectionColor = TRIANGLES[i].color;\n            intersectionPos = cameraPos + viewVec * intersectionDist;\n            intersectionNormal = TRIANGLES[i].normal;\n            intersectionSpecular = TRIANGLES[i].specular;\n        }\n    }\n    \n    float sdf = intersect(cameraPos, viewVec);\n    if (sdf > 0.0 && sdf < intersectionDist) {\n        intersectionDist = sdf;\n        intersectionColor = vec3(1, 0, 0);\n        intersectionPos = (cameraPos + sdf * viewVec);\n        intersectionNormal = calcNormal(intersectionPos);\n        intersectionSpecular = 0.0;\n    }\n\n    fragColor.w = intersectionDist;\n    intersectionColor *= 255.0;\n    fragColor.x = float(\n        (int(intersectionColor.x) << 16)\n        | (int(intersectionColor.y) << 8)\n        | (int(intersectionColor.z))\n    );\n    fragColor.y = atan(intersectionNormal.y, intersectionNormal.x);\n    fragColor.z = acos(intersectionNormal.z);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\nconst float PI = 3.14159;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map( in vec3 p )\n{\n    p -= vec3(1.5, 0, 2);\n    float k = 10.0 * (sin(iTime)); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q.xyz, vec2(0.8, 0.35));\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    float res = -1.0;\n    float h = 1.0;\n    for( int i=0; i<64; i++ )\n    {\n    if( h<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = t;\n        t += h;\n    }\n  if( t>10.0 ) res=-1.0;\n    return res;\n}\n\nfloat integrateArc(float h1, float h2, float n) {\n    return 0.25 * (-cos(2.0 * h1 - n) + cos(n) + 2.0 * h1 * sin(n))\n        + 0.25 * (-cos(2.0 * h2 - n) + cos(n) + 2.0 * h2 * sin(n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-15, -15, 10), vec3(-15, 15, 10), vec3(15, 15, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-15, -15, 10), vec3(15, 15, 10), vec3(15, -15, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    float intersectionSpecular;\n\n    vec2 screenUV = fragCoord / iResolution.xy;\n    vec4 gbuffer = texture(iChannel0, screenUV);\n    int encodedColor = int(gbuffer.x);\n    intersectionColor = vec3((encodedColor >> 16) & 0xFF, (encodedColor >> 8) & 0xFF, encodedColor & 0xFF) / 255.0;\n    intersectionNormal.z = cos(gbuffer.z);\n    intersectionNormal.x = cos(gbuffer.y) * sin(gbuffer.z);\n    intersectionNormal.y = sin(gbuffer.y) * sin(gbuffer.z);\n    intersectionDist = gbuffer.w;\n    intersectionPos = intersectionDist * viewVec + cameraPos;\n    \n    int SAMPLES_COUNT = 10;\n    float radius = 10.0;\n    \n    float rotations[6] = float[6]( 60.0, 300.0, 180.0, 240.0, 120.0, 0.0 );\n    \n    float offsets[4] = float[4](0.0, 0.5, 0.25, 0.75);\n    \n    ivec2 scrPos = ivec2(fragCoord);\n    float spatialDirection = (1.0 / 16.0) * float((((scrPos.x + scrPos.y) & 0x3) << 2) + (scrPos.x & 0x3));\n    float spatialOffset = (1.0 / 4.0) * float((scrPos.y - scrPos.x) & 0x3);\n    float direction = (spatialDirection + rotations[iFrame % 6] / 360.0) * 2.0 * PI;\n    vec2 rotation = vec2(sin(direction), cos(direction));\n    float offset = offsets[(iFrame / 6) % 4] + spatialOffset;\n    \n    float h1 = -2.0;\n    for (int i = 0; i < SAMPLES_COUNT; ++i) {\n        vec2 uv_pos = fragCoord + rotation * (float(i + 1) / float(SAMPLES_COUNT) * radius + offset);\n        uv_pos /= iResolution.xy;\n        vec4 gbufferSample = texture(iChannel0, uv_pos);\n        vec2 fragCoordSample = (uv_pos * iResolution.xy - iResolution.xy * 0.5) / iResolution.x;\n        vec3 view = normalize(vec3(fragCoordSample, 1.0));\n        vec3 pos = view * gbufferSample.w + cameraPos;\n        vec3 dir = normalize(pos - intersectionPos);\n        h1 = max(h1, dot(dir, -viewVec));\n    }\n    h1 = -acos(h1);\n    \n    float h2 = -2.0;\n    for (int i = 0; i < SAMPLES_COUNT; ++i) {\n        vec2 uv_pos = fragCoord - rotation * float(i + 1) / float(SAMPLES_COUNT) * radius;\n        uv_pos /= iResolution.xy;\n        vec4 gbufferSample = texture(iChannel0, uv_pos);\n        vec2 fragCoordSample = (uv_pos * iResolution.xy - iResolution.xy * 0.5) / iResolution.x;\n        vec3 view = normalize(vec3(fragCoordSample, 1.0));\n        vec3 pos = view * gbufferSample.w + cameraPos;\n        vec3 dir = normalize(pos - intersectionPos);\n        h2 = max(h2, dot(dir, -viewVec));\n    }\n    h2 = acos(h2);\n    \n    float n = acos(dot(intersectionNormal, -viewVec));\n    h1 = n + max(h1 - n, -PI / 2.0);\n    h2 = n + min(h2 - n, PI / 2.0);\n    float vd = integrateArc(h1, h2, n);\n\n    fragColor.rgb = vec3(vd);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\nconst float PI = 3.14159;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map( in vec3 p )\n{\n    p -= vec3(1.5, 0, 2);\n    float k = 10.0 * (sin(iTime)); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q.xyz, vec2(0.8, 0.35));\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    float res = -1.0;\n    float h = 1.0;\n    for( int i=0; i<64; i++ )\n    {\n    if( h<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = t;\n        t += h;\n    }\n  if( t>10.0 ) res=-1.0;\n    return res;\n}\n\nfloat integrateArc(float h1, float h2, float n) {\n    return 0.25 * (-cos(2.0 * h1 - n) + cos(n) + 2.0 * h1 * sin(n))\n        + 0.25 * (-cos(2.0 * h2 - n) + cos(n) + 2.0 * h2 * sin(n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-15, -15, 10), vec3(-15, 15, 10), vec3(15, 15, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-15, -15, 10), vec3(15, 15, 10), vec3(15, -15, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    float intersectionSpecular;\n\n    vec2 screenUV = fragCoord / iResolution.xy;\n    vec4 gbuffer = texture(iChannel0, screenUV);\n    int encodedColor = int(gbuffer.x);\n    intersectionColor = vec3((encodedColor >> 16) & 0xFF, (encodedColor >> 8) & 0xFF, encodedColor & 0xFF) / 255.0;\n    intersectionNormal.z = cos(gbuffer.z);\n    intersectionNormal.x = cos(gbuffer.y) * sin(gbuffer.z);\n    intersectionNormal.y = sin(gbuffer.y) * sin(gbuffer.z);\n    intersectionDist = gbuffer.w;\n    intersectionPos = intersectionDist * viewVec + cameraPos;\n    \n    float raw_ao = texture(iChannel1, screenUV).r;\n    float ao = 0.0;\n    float weights = 0.0;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            float sample_ao = texture(iChannel1, screenUV + vec2(i, j) / iResolution.xy).r;\n            float sample_depth = texture(iChannel0, screenUV + vec2(i, j) / iResolution.xy).w;\n            float weight = clamp(10.0 / abs(sample_depth - intersectionDist), 0.0, 1.0);\n            weights += weight;\n            ao += sample_ao * weight;\n        }\n    }\n    ao /= weights;\n    \n    float historyAO = texture(iChannel2, screenUV).r;\n\n    ao = mix(ao, historyAO, 0.9);\n    fragColor.rgb = vec3(ao);\n}","name":"Buffer C","description":"","type":"buffer"}]}