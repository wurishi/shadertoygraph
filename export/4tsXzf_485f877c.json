{"ver":"0.1","info":{"id":"4tsXzf","date":"1438625869","viewed":915,"name":"Sphere Tracing 101","username":"fab","description":"Example sphere tracer, from the following blog post: http://fabricecastel.github.io/blog/03-08-2015/main.html","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["example","simple","sphere","tracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// camera attributes\n// cameraDirection and cameraUp MUST be normalized\n// (ie. their length must be equal to 1)\nconst vec3 cameraPosition = vec3(0.0, 0.0, 10.0);\nconst vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\nfloat distanceToNearestSurface(vec3 p){\n    return length(p) - 1.0;\n}\n\nbool intersectsWithWorld(vec3 p, vec3 dir){\n  \tfloat dist = 0.0;\n    float nearest = 0.0;\n    bool hit = false;\n    for(int i = 0; i < 20; i++){\n        float nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < 0.01){\n            hit = true;\n            break;\n        }\n        dist += nearest;\n    }\n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    // generate the ray for this pixel\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    float collidedWithWorld = 0.0;\n    if(intersectsWithWorld(cameraPosition, rayDirection))\n        collidedWithWorld = 1.0;\n    \n\tfragColor = vec4(collidedWithWorld, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}