{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"volume","id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define PI 3.14159265359\n#define maxDist 10.\n#define nStep 35\n#define nStepLight 4\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nuint integerMod(uint x, uint y)\n{\n    return x - x/y;\n}\n\nfloat saturate(float i)\n{\n    return clamp(i,0.,1.);\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat noise (vec3 x)\n{\n    //smoothing distance to texel https://iquilezles.org/articles/texture\n    x*=32.;\n    x += 0.5;\n    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tx = f+i;    \n    x-=0.5;\n    \n    return texture( iChannel0, x/32.0 ).x;\n}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\n\nfloat fbm( vec3 p ) { // in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\nvec3 camera (vec2 ndc, vec3 camPos, float f, vec3 lookAt)\n{\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = cross(vec3(0.,1,0.), forward);\n    vec3 up = normalize(cross (forward, right));\n   \tright = normalize(cross (up, forward));\n    vec3 rd = up * ndc.y + right * ndc.x + f*forward;\n\treturn rd;\n}\n\n\nfloat map (vec3 p)\n{\n   \n    mat4x4 rot = rotationMatrix(vec3(0.,1,0), 00.2*PI*p.y);\n    vec3 oldP =p;\n    p = (rot* vec4(p,0.)).xyz;\n    float density = 3.5;\n    float invFct = 1./oldP.y;\n    float n = fbm ((p+vec3 (0.,-iTime,0.))*.04 ) ; //Fractal noise\n    //center part\n    float radius = invFct * 2.; \n    float v1 =  1. - smoothstep(radius,radius+3.25*n ,length(oldP.xz));\n   \n    //peripherial part\n\tradius = invFct*8.;\n \tfloat v2 =smoothstep(radius,radius+1.  ,length(oldP.xz)) - smoothstep(radius+1.,radius+2.,length(oldP.xz));\n    v2 = saturate( v2 - smoothstep (radius,radius+2.*n  ,length(oldP.xz)))* saturate(.07*oldP.y);\n \t   \n    return density *saturate(v1+v2)+ smoothstep(0.,1.,1.-length(oldP/10.))*0.025;\n}\n\nfloat lightMarch(vec3 ro, vec3 lightPos)\n{\n    \n    vec3 rd = lightPos-ro;\n    float d = length (rd);\n    rd = rd/d;\n    float t = 0.;\n    float stepLength = d/ float(nStepLight);\n    float densitySum = 0.;\n    float sampleNoise;\n    int i = 0;\n    for (; i < nStepLight; i++)\n    {\n    \tsampleNoise = map ( ro + t * rd);\n       \n        densitySum += sampleNoise;\n        \n        t += stepLength;\n    }    \n    return exp(- d * (densitySum / float(i)));\n}\n\nvec3 calculateLight(vec3 samplePos, vec3 lightPos, vec3 lightColor, float lightStr)\n{\n        float sampleLight = lightMarch (samplePos, lightPos);\n        float distToLight = length(lightPos-samplePos)+1.;\n        vec3 light = lightColor * lightStr * (1./(distToLight*distToLight)) * sampleLight;\n\n    \treturn light;\n}\n\nvec3 march(vec3 ro, vec3 rd, float dither, float var)\n{\n    float value = 0.;\n    float densitySum = 0.;\n    float stepLength = maxDist / float(nStep);\n    vec3 color = vec3(0.02,0.01,0.2)*0.1;\n    float t = dither;\n\n    for (int i = 0; i < nStep; i++)\n    {\n        \n        vec3 samplePos = ro + t * rd ; \n    \tfloat sampleNoise = map (samplePos);\n        densitySum += sampleNoise;\n    \t\n        //light1\n        vec3 lightPos1 = vec3 (-5.,5.0,-5);         \n        vec3 light1 = calculateLight(samplePos, lightPos1, vec3 (0.6,0.25,0.15), 20.);\n        \n        //light2\n        vec3 lightPos2 = vec3 (-5.,5.,5.);\n        vec3 light2 = calculateLight(samplePos, lightPos2, vec3 (0.1 ,1.,0.6),20.);\n     \t    \n        vec3 ambientColor = vec3 (0.025,0.025,0.005)*0.4;\n        \n        color += exp(- t*(densitySum/float(i+1)))  * sampleNoise *(ambientColor + light1 + light2) ;\n        \n        t +=  stepLength * var;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n   \tuv *=1.5;\n    uv.x-=0.25;\n    vec2 ndc = uv * 2. - 1.;\n    ndc.x *=iResolution.x/iResolution.y;\n  \n    vec2 mouse = iMouse.xy/iResolution.xy;\n      \n    vec3 lookAt = vec3(0.,2.,0.);\n   \n    float mY = (1.-mouse.y) *5. +2.; //Remap zoom \n    \n    vec3 cameraPos = vec3((mY*cos(-mouse.x*2.*PI)), 4., (mY*sin(-mouse.x * 2.*PI)));\n    \n    vec3 rd = camera(ndc, cameraPos, 1.0,lookAt);\n    \n    float var = length(rd)/1.0; //to get constant z in samples, but reduce extreme rays definition\n    var = 1.; //not used here\n    rd = normalize (rd);\n\n    float dither = 0.3*hash1(   uint(fragCoord.x+iResolution.x*fragCoord.y) + \n                                uint(iResolution.x*iResolution.y) * integerMod(uint(iFrame), 32u));\n                                \n    vec3 col = march(cameraPos, rd, dither,var);\n\n    fragColor = vec4(col, 1.0f);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mt3fWS","date":"1540982775","viewed":2005,"name":"Tornado !","username":"hamtarodeluxe","description":"An other use of https://www.shadertoy.com/view/llycW1\nI think the 3D hash I use for the dithering has a weird redundant pattern? (fixed by using a 1D integer hash on index of X, Y, Frame)\nUse the mouse to move around :-)","likes":83,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volume","cloud","lighting","smoke","tornado"],"hasliked":0,"parentid":"","parentname":""}}