{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n#define MAX_RAY_STEPS 80\n#define MAX_RAY_DISTANCE 100.0\n#define DISTANCE_EPSILON 0.012\n#define PI 3.141592\n\n\nvec3 tonemap(vec3 c)\n{\n    return pow(c, vec3(2.4));\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    float ca = cos(angle);\n    float ica = 1.0 - ca;\n    float sa = sin(angle);\n    \n\treturn mat3(ca + axis.x*axis.x * ica, axis.x*axis.y*ica - axis.z*sa, axis.x*axis.z*ica + axis.y*sa,\n                axis.y*axis.x*ica + axis.z*sa, ca + axis.y*axis.y*ica, axis.y*axis.z*ica - axis.x*sa,\n                axis.z*axis.x*ica - axis.y*sa, axis.z*axis.y*ica + axis.x*sa, ca + axis.z*axis.z*ica);\n\n}\n //[0->1->0]\nfloat linearInterval(vec2 interval, float t)\n{\n    float intervalC = interval.x +  (interval.y - interval.x) * 0.5;\n    return step(t, intervalC) * smoothstep(interval.x, intervalC, t) + step(intervalC,t) * (1.0 - smoothstep(intervalC, interval.y, t));\n     \n}\n\nvec3 fold(vec3 p, vec4 plane)\n{\n\treturn p - 2.0 * min(0.0, dot(p, plane.xyz) + plane.a) * plane.xyz;    \n}\n\nfloat opComplement(float a, float b)\n{\n\treturn max(-a,b);    \n}\n\nvec2 estimateDistance(vec3 p, float phase)\n{\n    \n    const float scale = 2.0;\n    const int n = 16;\n    const vec2 rotInterv = vec2(0.08,1.92);\n    const vec2 transInterval = vec2(0.9, 1.1);\n    float repr = pow(scale, -float(n));\n    const float size = 3.0;\n    \n    //calculate current point rotation\n    float t = linearInterval(rotInterv, phase);\n   \tmat3 rot = rotationMatrix(normalize(vec3(1.2, 0.5, 3.0)), PI * 0.6 * t) \n        * rotationMatrix(normalize(vec3(0.2, 0.5, 0.0)), PI * 0.4 * t);\n    \n    //fractal1\n    vec3 fp1 = p;\n    fp1.xz = -abs(fp1.xz);\n    fp1.y = abs(fp1.y);\n\n\tfor( int i = 0; i < n; ++i)\n    {\n        \n        fp1 = rot * fp1;\n    \tfp1 = fold(fp1, vec4(0.7, 0.7, 0.0, size));\n        fp1 = fold(fp1, vec4(0.7, 0.0, -0.7, size));\n        fp1 = fold(fp1, vec4(0.0, -0.7,  0.7, size));\n        \n\n        fp1 = fp1*scale;\n    }\n\t\n    //fractal2 (sierpinski tetrahedrons)     \n    vec3 fp2 = p;\n    fp2 = -abs(fp2);\n\n\tfor( int i = 0; i < n; ++i)\n    {\n        \n        fp2 = rot * fp2;\n    \tfp2 = fold(fp2, vec4(0.7, 0.7, 0.0, size));\n        fp2 = fold(fp2, vec4(0.7, 0.0, 0.7, size));\n        fp2 = fold(fp2, vec4(0.0, 0.7, 0.7, size));\n        \n\n        fp2 = fp2*scale;\n    }\n    \n    //merge\n    t = smoothstep(transInterval.x, transInterval.y, phase);\n    float fd1 = length(fp2) * repr;\n\tfloat fd2 = opComplement( length(p) - 0.6,length(fp1) * repr); \n    vec2 fd = vec2(t * fd1 + (1.0 - t)*fd2, 0.0);\n    \n    \n    \n    return fd;              \n}\n\nvec3 calculateNormal(vec3 p, float phase)\n{\n    const vec3 e = vec3( 0.002, 0.0, 0.0);\n    \n    \n\treturn normalize(vec3( estimateDistance(p + e,phase).x - estimateDistance(p - e,phase).x,\n                 estimateDistance(p + e.yxz, phase).x - estimateDistance(p - e.yxz, phase).x,\n               estimateDistance(p + e.zyx, phase).x - estimateDistance(p - e.zyx, phase).x));    \n}\n\n\n\n\nvec3 raymarch(vec3 ro, vec3 rd, float phase)\n{\n\tfloat d = 0.0;\n    float didHit = -1.0;\n    float lastId = -1.0;\n    int steps;\n    for(int i = 0; i < MAX_RAY_STEPS; ++i)\n    {\n        \n    \tvec2 dist = estimateDistance( ro + rd * d, phase);\n        if(dist.x < DISTANCE_EPSILON)\n        {\n            \n            didHit = 1.0;\n        \tbreak;\n        }\n        d += dist.x;\n        lastId = dist.y;\n        if(d > MAX_RAY_DISTANCE)\n        {\n            didHit = -1.0;\n            d = MAX_RAY_DISTANCE;\n            break;\n        }\n        steps = i;\n    }\n    return vec3(d * didHit, lastId, float(steps));\n}\n\n\n\nvec3 calculateColor(vec3 ro, vec3 rd, float phase)\n{\n    vec3 g1 = vec3(0.9, 0.4, 0.1);\n    vec3 g2 = vec3(0.1, 0.7, 0.3);\n    \n    const vec3 fc = vec3(0.4, 0.4, 0.4);\n    \n\tvec3 res = raymarch(ro, rd, phase);\n\n   \n    vec3 c = vec3( 0.0, 0.0, 0.0);\n    if(res.x > 0.0)\n    {\n        vec3 p = ro + rd * res.x;\n    \tvec3 n = calculateNormal(p, phase);\n\t\tc += clamp(0.0, 1.0, dot(n, -rd)) * fc;\n    }\n    \n    //add glow\n    float t = smoothstep(0.0, 2.0, phase);\n    vec3 g = mix(g1,g2,t);\n    c +=  (res.z / float(MAX_RAY_STEPS)) * g * 3.5;\n    \n    \n\treturn c;    \n}\n\n\n\nvec3 viewCoordinatesToRayDir(vec3 eyeDir, vec3 eyeUp,  float fovy, float near, float aspect, vec2 screen_coord) \n{\n\n\tfloat projY = tan(fovy * 0.5) * 2.0 * near;\n\tfloat projX = projY * aspect;\n  \n\n\tvec3 right = normalize( cross(eyeDir, eyeUp) );\n  \n\n\tfloat dx = projX * (screen_coord.x - 0.5);\n\tfloat dy = projY * (screen_coord.y - 0.5);\n  \n\treturn normalize( eyeDir * near + dx * right + dy * eyeUp);\n}\n\nvec3 sphericalToCartesian(float polar, float azimuth, float r)\n{\n\tfloat sinp = sin(polar);\n    float sina = sin(azimuth);\n    float cosp = cos(polar);\n    float cosa = cos(azimuth);\n    \n    return vec3( r * cosa * sinp , r * sina * sinp,  r * cosp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vp = fragCoord.xy / iResolution.xy;\n    \n    vec2 mp = iMouse.xy / iResolution.xy;\n   \n    float phase = cos(iTime * 0.2 + PI * 0.5) + 1.0;\n    \n    float camRad = mix(3.3, 12.0, 1.0 - mp.y);\n    \n    float azimuth = mp.x * 2.0 * PI + PI*0.5;\n    float polar = 0.6 * PI;\n    \n    vec3 eyePos = sphericalToCartesian(polar,azimuth,camRad);\n    vec3 eyeDir = normalize(-eyePos);\n    vec3 eyeUp = normalize(sphericalToCartesian(polar+ 0.5 * PI, azimuth , camRad));\n    float near = 0.1;\n    float fovy = radians(60.0);\n    float aspect =iResolution.x / iResolution.y;\n    \n    \n    vec3 rd = viewCoordinatesToRayDir(eyeDir, eyeUp, fovy, near, aspect, vp);\n    vec3 ro = eyePos;\n    \n    fragColor = vec4(tonemap(calculateColor(ro,rd,phase)), 1.0); \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlX3W8","date":"1421409559","viewed":287,"name":"sierpinski_twister","username":"Mana","description":"basic fractal with some animation.\nMouse y zooms, mouse x rotates","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal"],"hasliked":0,"parentid":"","parentname":""}}