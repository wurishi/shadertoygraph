{"ver":"0.1","info":{"id":"NdVfRD","date":"1657765355","viewed":86,"name":"Shiny Glob SDF","username":"mattdeeds","description":"Ray marching on eight spheres with soft min.\n\nI exit the marching when the step in the z-direction is below some resolution.  This makes rendering things that are far away a little cheaper.  Performance is still pretty poor though.  This causes scalloping","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","shine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kMaxDepth 10.0\n#define kMaxSteps 32\n#define kPixelRatio 50.0\n\nfloat sdfSphere(in vec3 pos, in vec3 center, in float radius) {\n  return length(pos - center) - radius;\n}\n\nfloat smoothMin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - h * h * h * k * 1.0 / 6.0;\n}\n\nfloat sdf(in vec3 pos) {\n  float t = iTime * 0.5;\n  vec3 centers[8] = vec3[8](\n    vec3(0.5 * cos(t + 12.3), 0.5 * sin(1.1 * t + 12.3), 3.0),\n    vec3(0.5 * cos(t + 23.1), 0.5 * sin(1.2 * t + 23.1), 3.0),\n    vec3(0.5 * cos(t + 31.2), 0.5 * sin(1.3 * t + 31.2), 3.0),\n    vec3(0.5 * cos(t + 21.3), 0.5 * sin(1.4 * t + 21.3), 3.0),\n    \n    vec3(1.0 * sin(t + 12.3), 1.0 * cos(1.1 * t + 12.3), 6.0),\n    vec3(1.0 * sin(t + 23.1), 1.0 * cos(1.2 * t + 23.1), 6.0),\n    vec3(1.0 * sin(t + 31.2), 1.0 * cos(1.3 * t + 31.2), 6.0),\n    vec3(1.0 * sin(t + 21.3), 1.0 * cos(1.4 * t + 21.3), 6.0)\n    \n    \n    );\n    \n\n  float distance = 1e12;\n\n  for (int i = 0; i < centers.length(); ++i) {\n    distance = smoothMin(distance, sdfSphere(pos, centers[i], 0.2), 1.0);\n  }\n \n  return distance;\n}\n\n\nvec2 getDepth(in vec3 ray_start, in vec3 ray_direction, in float max_depth) {\n  float depth = 0.0;\n  for (int i = 0; i < kMaxSteps; ++i) {\n    float d = sdf(ray_start + ray_direction * depth);\n    depth += d;\n    if (d < depth / kPixelRatio) {\n      \n      return vec2(depth, float(i));\n    }\n    if (depth >= max_depth) {\n      return vec2(max_depth, float(i));\n    }\n  }\n  return vec2(depth, float(kMaxSteps));\n}\n\nvec3 getGradient(in vec3 pos) {\n  const vec2 epsilon = vec2(0.01, 0.0);\n  vec3 g = vec3(\n    sdf(pos + epsilon.xyy) - sdf(pos - epsilon.xyy), \n    sdf(pos + epsilon.yxy) - sdf(pos - epsilon.yxy), \n    sdf(pos + epsilon.yyx) - sdf(pos - epsilon.yyx));\n  g = normalize(g);\n  return g;\n}\n\nvec3 getReflection(in vec3 inbound, in vec3 normal) {\n  return -inbound - 2.0 * (dot(-inbound, normal) * normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  const vec3 light = normalize(vec3(0.0, -1.0, -0.5));\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)  / iResolution.y;\n    \n    vec3 view = normalize(vec3(uv / 2.0, 1.0));\n    \n    vec2 ds = getDepth(vec3(0.0), view, kMaxDepth);\n    float depth = ds.x;\n    vec3 grad = getGradient(view * depth);\n    vec3 glow = vec3(0.8, 0.9, 1.0) * pow(ds.y / float(kMaxSteps), 4.2);\n    \n    vec3 refl = getReflection(-light, grad);\n    vec3 shine = vec3(2.0 * pow(max(0.0, dot(refl, view)), 9.0));\n    vec3 diff = vec3(1.0, 0.3, 0.1) * dot(light, grad);\n\n    vec3 col = glow;\n    if (depth < kMaxDepth) {\n      col += shine + diff;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}