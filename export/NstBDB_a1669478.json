{"ver":"0.1","info":{"id":"NstBDB","date":"1657289731","viewed":172,"name":"Hexagonal Grid Study 01","username":"Oneleven","description":"A simple study of hexagonal grid based on existing implementations\nTo spice things up I've also divided hexagons by triangular grid \nThere is noticeable AA issues but I don't have time to fix them now. Help is always welcomed, though","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["grid","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n\n//Minimal Hexagonal Shader/Grid by leftofzen \n//https://www.shadertoy.com/view/wtdSzX\nconst vec2 helper = vec2(1, 1.7320508); \n\nvec4 getHex(vec2 uv)\n{    \n    vec4 hexID = floor(vec4(uv, uv - vec2(.5, 1))/helper.xyxy) + .5;\n    vec4 hexUV = vec4(uv - hexID.xy*helper, uv - (hexID.zw + .5)*helper);\n    \n    return dot(hexUV.xy, hexUV.xy) < dot(hexUV.zw, hexUV.zw)\n        ? vec4(hexUV.xy, hexID.xy) \n        : vec4(hexUV.zw, hexID.zw + .5);    \n}\n\nfloat getHexDF(vec2 uv)\n{    \n    uv = abs(uv);\n    return max(dot(uv, helper*0.5), uv.x);\n}\n\nfloat getHexSegment(vec2 uv)\n{\n    float segIndex = atan(uv.x, uv.y)/(PI*2.0)+0.5;\n    return floor(segIndex*6.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    // GetHexGrid\n    float zoom = sin(iTime*0.5)*2.0 + 8.0;\n    vec4 hexGrid = getHex(uv*zoom + vec2(0.55, 0.2)*iTime);\n    float hexDF = getHexDF(hexGrid.xy); // Edge distance.\n    float hexSegment = getHexSegment(hexGrid.xy);\n\n    // Colorize\n    float feather = 2.0/iResolution.y + 0.1;\n    vec3 col = vec3(0.0); \n    \n    float direction = dot(hexGrid.zw, vec2(1.0, 2.0)) * 0.1;\n    \n    float progressX = sin(iTime + PI*mod(hexSegment, 5.0) + direction)       *0.5+0.4;\n    float progressY = sin(iTime + PI*mod(hexSegment, 5.0) + direction + 0.15)*0.5+0.4;\n    float progressZ = sin(iTime + PI*mod(hexSegment, 5.0) + direction + 0.3) *0.5+0.4;\n    \n    col.x = 1.0 - smoothstep(progressX, progressX + feather, hexDF);\n    col.y = 1.0 - smoothstep(progressY, progressY + feather, hexDF);\n    col.z = 1.0 - smoothstep(progressZ, progressZ + feather, hexDF);\n    \n    //Debug\n    //col = vec3(hexDF);\n    //col = vec3(hexSegment)/6.0;\n    \n    fragColor = vec4(col, 1);    \n}","name":"Image","description":"","type":"image"}]}