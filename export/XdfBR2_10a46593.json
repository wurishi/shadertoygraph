{"ver":"0.1","info":{"id":"XdfBR2","date":"1496998040","viewed":102,"name":"test glass","username":"Tenderz","description":"Just testing some graphics","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415; \n\nvec2 rot2D(vec2 p, float angle) \n{\n    float s = sin(angle);\n    float c = cos(angle);\n     \n    return p * mat2(c,s,-s,c);   \n}\n \nfloat sphere(vec3 p, vec3 pos, float radius)\n{\n    vec3 delta = pos-p;\n    delta.xz = rot2D(delta.xz, iTime*1.2);\n    float rz = atan(delta.y,delta.x);\n    radius += cos(rz*3.0)*0.05+((cos(iTime*10.0)*0.5+0.5)*0.05);\n    \n    float d = max(0.0, length(delta)-radius);\n    return d;\n}\n \nfloat f(vec3 p)\n{\n    return sphere(p, vec3(0,0,0), 1.0);\n}\n \nvec3 computeNormal(vec3 p)\n{\n    float e = 0.05;\n    vec3 n;\n    n.x = f(p+vec3(e,0,0)) - f(p-vec3(e,0,0));\n    n.y = f(p+vec3(0,e,0)) - f(p-vec3(0,e,0));\n    n.z = f(p+vec3(0,0,e)) - f(p-vec3(0,0,e));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - vec2(1,1);\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    float rotation = iMouse.x/iResolution.x * pi*2.0;\n    float orbitRadius = 3.0;\n    vec3 eye = vec3(cos(rotation), 0, sin(rotation)) * orbitRadius;\n    \n    vec3 direction = vec3(uv.xy * 0.5,-1);\n    direction = normalize(direction);\n    direction.xz = rot2D(direction.xz, -rotation+pi*0.5);\n    \n    // Camera rotation\n    //direction.xz = rot2D(direction.xz, -iMouse.x/iResolution.x * pi*2.0+pi);\n     \n    float dist = 0.0;\n    float stepSize = 0.01;\n    vec4 final = vec4(0,0,0,0);\n    vec3 normal = vec3(0,0,0);\n    int t = 0;\n     \n    for(;dist < 5.0; dist += stepSize)\n    {\n        vec3 pos = eye + direction * dist;\n        float v = f(pos);\n        if(v < 0.05)\n        {\n            t = 1;\n            normal = computeNormal(pos);\n        }\n    }\n     \n    if(t == 0)\n    {\n        final = texture(iChannel0, direction);\n    }\n    else\n    {\n        vec3 ld = normalize(vec3(-3,3,-3));\n        vec4 matColor = vec4(1,1,1,1) * max(0.0,dot(ld, normal));\n      \n        float nAir = 1.0;\n        float nMat = 1.158;\n        float cosN1 = dot(direction, normal);\n        float sinN1 = cos(pi*0.5-cosN1);\n        float sinN2 = sinN1/nMat/nAir;\n        float r = sinN2/sinN1;\n         \n        vec3 normalOut = direction * r + (-normal) * (1.0-r);\n        vec4 bg = texture(iChannel0, normalOut);\n        final = bg * (1.0-matColor.a) + matColor * matColor.a;\n        final *= vec4(2,0.7,0.7,1);\n        //final.r = sinN2;\n        final.a = 1.0;\n    }\n     \n    fragColor = final;\n}","name":"Image","description":"","type":"image"}]}