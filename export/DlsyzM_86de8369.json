{"ver":"0.1","info":{"id":"DlsyzM","date":"1690536716","viewed":67,"name":"1.2.2 Raymarcher (TAA)","username":"Envy24","description":"Better TAA from: https://www.shadertoy.com/view/3sfBWs\nTop: with TAA; Bottom: without TAA.\nDrag sphere with mouse.\nStill bad with constant motion, but better then previous version.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","antialiasing","distance","field","temporal","taa"],"hasliked":0,"parentid":"dtlyz4","parentname":"1.2.1 Raymarcher (simple TAA)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TEX0(TC)                  ( texture(iChannel0, (TC)) )\n#define TEX1(TC)                  ( texture(iChannel1, (TC)) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), false),\n         MP =\n             iMouse.xy == vec2(0) ?\n                 vec2(0) :\n                 map_to_centered_ndc(iMouse.xy, 1., vec2(0), false);\n\n    float t = \n        iMouse.xy == vec2(0) ?\n            0.99 :\n            iMouse.x/iResolution.x;\n    O = \n        NDC.y < MP.y ?\n            TEX0(SC/iResolution.xy) :\n            TEX1(SC/iResolution.xy);\n    // Horisontal line.\n    O = mix(O, vec4(0,0,0,1), smoothstep(2./iResolution.y, 0., horizontal_lineSDF(NDC, MP.y)));   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_MISS_DIST    ( 1e4 )\n#define MIN_HIT_DIST     ( 1e-4 )\n#define MAX_NUM_OF_STEPS ( 300. )\n\n// Data structures.\nstruct RAY\n{\n    vec3 origin;\n    vec3 direction;\n};\nstruct HIT\n{\n    float hit_dist;\n    bool hit_something;\n};\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// SDFs\nfloat sphereSDF_L2(in vec3 P, in vec3 C, in float r) { return length(C - P)-r; }\n\n/* SCENE */\n#define MX         ( iMouse.xy == vec2(0) ? 0. : iMouse.x/iResolution.x*2. - 1.  )\n#define SPHERE_X   ( iMouse.z > 0. ? MX : sin(iTime*0.3) )\n#define SPHERE_POS ( vec3(MX, 0, 4) )\n#define SPHERE_R   ( 0.9 ) \nfloat find_closest_scene_object(in vec3 marching_point)\n{\n    return sphereSDF_L2(marching_point, SPHERE_POS, SPHERE_R);\n}\n/* SCENE */\n\nHIT ray_march(\n    RAY ray,\n    float max_num_of_steps,\n    float max_distance,\n    float surface_distance) \n{\n    float marched_distance = 0.0; // Distance marched from ray origin.\n    float minimal_distance = 0.0; // Current distance to closest object.\n\n    bool quit = false, hit = false;\n\n    for (float step = 0.; (step < max_num_of_steps) && (quit == false) && (hit == false); step += 1.)\n    {\n        // Calculate current coordinates at ray.\n        vec3 marching_point = ray.origin + ray.direction * marched_distance;\n\n        // Find distance to closest object to point.\n        minimal_distance = find_closest_scene_object(marching_point);\n\n        // March.\n        marched_distance += minimal_distance;\n\n        hit = minimal_distance < surface_distance; // Hit some object?\n        quit = marched_distance > max_distance;    // Marched into infinity?\n    }\n\n    return HIT(marched_distance, hit);  \n}\n\n/* You can see how this works in 2d here:\n   https://www.shadertoy.com/view/slyBRc */\nvec3 approximate_normal(in vec3 P)\n{\n    const float delta = .01;          \n    // Sample distance function at hit point and three nearby points.\n    float s0 = find_closest_scene_object(P),\n          s1 = find_closest_scene_object(P + vec3(delta, 0, 0)),\n          s2 = find_closest_scene_object(P + vec3(0, delta, 0)),\n          s3 = find_closest_scene_object(P + vec3(0, 0, delta));\n    // Calculate finite differencies.    \n    float dfdx = s1 - s0,\n          dfdy = s2 - s0,\n          dfdz = s3 - s0;\n    // Approximate gradient/normal direction.\n    return normalize(vec3(dfdx, dfdy, dfdz));\n}\n\nvec3 light(RAY ray, HIT hit)\n{\n    vec3 color = vec3(1,0,0),\n         light_pos = vec3(0,1,-10),\n         hp = ray.origin + ray.direction * hit.hit_dist,\n         normal = approximate_normal(hp),\n         light_dir = normalize(light_pos - hp);\n    return \n        hit.hit_something == true ?\n            color * max(dot(light_dir, normal), 0.) :\n            (normalize(hp) + vec3(1)) * 0.5;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 jitter = halton(iFrame % 16 + 1);\n    //vec2 jitter = HASH(SC.x*iTime, SC.y*iTime)*0.5;\n    vec2 NDC = map_to_centered_ndc(SC+jitter, 1., vec2(0), false);\n\n    RAY ray;\n    /* Axis-aligned orthographic camera *\n    ray.origin = vec3(NDC, -4.0),\n    ray.direction = normalize(vec3(0., 0., 1.0));         \n    /* Axis-aligned perspective camera */\n    ray.origin = vec3(0.0, 0.0, -4.0),\n    ray.direction = normalize(vec3(NDC*0.125, 1.0));\n    /**/\n         \n    // March through scene.\n    HIT hit = ray_march(ray, MAX_NUM_OF_STEPS, MAX_MISS_DIST, MIN_HIT_DIST);                     \n    O = vec4(light(ray, hit), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some seeds.\n    const uint s0 = 123u;\n    const uint s1 = 456u;\n    const uint s2 = 789u;\n\n    // Mix coordinates.\n    uint v0 = y * s2 + x;\n    uint v1 = x * s2 + y;\n\n    // Calculate hash.\n\tv0 += s1; v0 *= 445593459u; v0 ^= s0;\n    v1 += s1; v1 *= 445593459u; v1 ^= s0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(v0 * v0 * v0) * 4.6566128730773926e-10f - 1.0f,\n            float(v1 * v1 * v1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH(x, y)                ( hash2to2(uint(x), uint(y)) )\n\nfloat horizontal_lineSDF(vec2 NDC, float x0) { return abs(NDC.y-x0); }\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton(int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return (a.zw - vec2(0.5))*0.9; // output ranges ( [-0.5; 0.5][-0.5; 0.5]) * 0.9\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(SC), 0) )\n\n// Resolve step for TAA.\n\n// source: https://www.shadertoy.com/view/3sfBWs\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    // C - cantral sample,\n    // OC - old (from previous frame) central sample,\n    // N - one of possible 8 neighbours.\n\n    vec3 C = TEXF0(SC).rgb, minN = C, maxN = C;\n    for (int y = -1; y <= 1; ++y)\n        for (int x = -1; x <= 1; ++x)\n        {\n            // Skip central pixel?\n            if (x == 0 && y == 0) { continue; }\n            \n            vec3 N = TEXF0(SC + vec2(x, y)).rgb;\n            minN = min(minN, N); maxN = max(maxN, N);\n        }\n        \n    vec3 OC = clamp(TEXF1(SC).rgb, minN, maxN);\n\n    float t = iMouse.z > 0. ? 0.7 : 0.9;\n\n    C =\n        iFrame == 0 ?\n            C :\n            C*(1.-t) + OC*t; // lerp or mix.\n            \n    O = vec4(C, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}