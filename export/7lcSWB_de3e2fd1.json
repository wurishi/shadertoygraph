{"ver":"0.1","info":{"id":"7lcSWB","date":"1639678690","viewed":150,"name":"Vinyl","username":"Sebm","description":"Simple Vinyl","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["music"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ring(vec2 position, float radius1, float radius2, float eps)\n{\n    float dist = length(position);\n    \n    return smoothstep(radius1 - eps, radius1 + eps, dist) * smoothstep(radius2 + eps, radius2 - eps, dist);\n} \n\n\nfloat hole(vec2 position, float radius, float eps)\n{\n    float dist = length(position);\n    \n    return smoothstep(radius - eps, radius + eps, dist);\n} \n\n\nvec4 turningDisk(vec2 position, vec3 baseColor, float eps)\n{\n    float th = -iTime * 2.0 * PI * 10./60.;\n    \n    float th0 = atan(position.y, position.x);\n    position *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    float d1 = length(position);\n    float th1 = atan(position.y, position.x);\n       \n    vec4 finalColor = vec4(baseColor, 0.0);\n    \n    float disk = ring(position, 0.45, 0.9, eps);\n    float whiteRing = ring(position, 0.2, 0.3, eps);\n    float artworkRing = ring(position, 0.04, 0.25, eps);\n       \n    float lightIntensity = 0.3;\n    float albedo = clamp(6. + 6.* sin(d1*80.), 0., 1.) * (lightIntensity + 0.05 * noise(4. * th1 + 0.5 * d1/eps) * sin(th1) + 0.1 * noise(0.5 * d1/eps));\n    float lighting = pow(1.0 - abs(sin(1.0 + th0)), 1.) + 0.1;\n    \n    finalColor += albedo * lighting * disk * 0.3;\n    finalColor += whiteRing * 0.08;\n    finalColor += artworkRing;\n    \n    float blackBackground = hole(position, 0.9, eps);\n    finalColor += blackBackground;\n   \n    return finalColor;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float eps = 1.5/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float everySecond = mod(iTime, 1.0);\n    float flashTime = exp(-everySecond*4.);\n    \n    vec3 baseColor = mix(vec3(0.2,0.2,1.0), vec3(0.8,0.5,1.0), flashTime);\n    \n    vec2 position = uv - vec2(0,0);\n    \n    vec4 diskCol = turningDisk(position, baseColor, eps);\n    \n    vec3 artwork = texture(iChannel0, uv / 0.35).rgb;\n    //col += artwork * 0.01;\n    \n    col = mix(col, diskCol.xyz, diskCol.a);\n    \n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nfloat rand(float p)\n{\n    // Hash function\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    //sf = sf*sf*sf*(sf*(sf*6.0-15.0)+10.0); // quintic curve\n    // see https://iquilezles.org/articles/texture\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n","name":"Common","description":"","type":"common"}]}