{"ver":"0.1","info":{"id":"wsGczd","date":"1603481387","viewed":150,"name":"corona2","username":"deaths_angel","description":"v2 https://www.shadertoy.com/view/wsyyzt","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["field","spikes","accumulation","virus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tFiery Spikeball\n\t---------------\n\n\tMaking some modifications to Duke's \"Cloudy Spikeball\" port to produce a fiery version.\n\n\tI trimmed the original shader down a bit, changed the weighting slightly, made a couple of \n\tsacrifices to the spike shape to tighten up the distance equation, etc.\n\n\n\tCloudy Spikeball - Duke\n\thttps://www.shadertoy.com/view/MljXDw\n\n    // Port from http://glslsandbox.com/e#1802.0, with some modifications.\n    //--------------\n    // Posted by Las\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\t// By the way, the demo is really good. Definitely worth watching.\n\n\n*/\n\n\nmat2 rM; // Rotation matrix.\nvec2 a;\n\n// IQ's noise\nfloat pn(in vec3 p){\n\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0 - 2.0*p);\n    vec2 uv = (ip.xy + vec2(37.0, 17.0)*ip.z) + p.xy;\n    uv = texture(iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n    return mix(uv.x, uv.y, p.z);\n}\n\n// FBM\nfloat fpn(vec3 p){\n    return pn(p*.6125)*0.1*max(1.,cos(iTime)) + pn(p*.125)*0.3*sin(iTime) + pn(p*.25)*.65*sin(iTime);\n}\n\n// Spikeball. Using 16 hardcoded points, reflected to give 32 spikes in all.\nfloat spikeball(vec3 p) {\n   \n    // Ball\n    float d = length(p) - 0.6;\n\tfloat ao = (0.5 * (cos(iTime) + 1.));\n    //    float o = (0.035 * ao * ao);\n    float o = 0.0;\n    // Spikes\n    p = normalize(p);\n    vec4 b = max(max(max(\n        abs(vec4(dot(p,vec3(0.526 + o,0.000,0.851)), dot(p,vec3(-0.526,0.000,0.851)),dot(p, vec3(0.851,0.526,0.000)), dot(p,vec3(-0.851,0.526,0.000)))),\n        abs(vec4(dot(p,vec3(0.357+o,0.934,0.000)), dot(p,vec3(-0.357+o,0.934,0.000)), dot(p, vec3(0.000,0.851,0.526)), dot(p,vec3(0.000,-0.851,0.526))))),\n                     abs(vec4(dot(p,vec3(0.000,0.357 + o,0.934)), dot(p,vec3(0.000,-0.357 - o,0.934)), dot(p, vec3(0.934,0.000,0.357)), dot(p,vec3(-0.934,0.000,0.357))))),\n                 abs(vec4(dot(p,vec3(0.577 + o,0.577 + o,0.577 + o)), dot(p,vec3(-0.577,0.577,0.577)), dot(p, vec3(0.577,-0.577,0.577)), dot(p,vec3(0.577,0.577,-0.577)))));\n    b.xy = max(b.xy, b.zw);\n    b.x = pow(max(b.x, b.y), 64.);\n\n\n    return d - exp2(b.x*(sin(iTime+1.)*0.25 + 0.75));\n}\n\n\n// Distance function.\nfloat map(vec3 p) {\n    \n    \n    //float c = cos(iTime), s = sin(iTime);\n    //p.xy=c*p.xy+s*vec2(p.y, -p.x); // Rotate p.xy\n    //p.xz=c*p.xz+s*vec2(p.z, -p.x); // Rotate p.xz\n    \n    // Performs the same as above. \"rM\" is produced just once, before the raymarching loop.\n    // I think it'd be faster, but GPUs are strange, so who knows.\n    // Duke tells me that \"r *= rM\" can break in some older browsers. Hence, the longhand.\n    p.xy = p.xy*rM;\n    p.xz = p.xz*rM;\n\n    return spikeball(p) +  fpn(p*50. + iTime*15.)*0.8;\n}\n\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1400. + 1000.*i + 200. * (0.5 * (1. + sin(iTime))); // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4 * (0.5 * (sin(iTime) + 1.)), 7.6, 7.4* (0.5 * (cos(iTime) + 1.)) ); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0 - exp(-2e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  \n   // p: position on the ray\n   // rd: direction of the ray\n   //\n   // Trimmed \"rd\" down. Plus, moved \"ro\" back 6 units to get rid of the \"p.z += 6\" line\n   // in the distance equation. Also, reversed the Z-coordinates, because it's a personal preference.\n   vec3 rd = normalize(vec3((fragCoord.xy - 0.5*iResolution.xy)/iResolution.y, 1.));\n   vec3 ro = vec3(0., 0., -8.);\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld = 0., td = 0., w;\n\n   // t: length of the ray\n   // d: distance function\n   float d = 1., t = 0.;\n   \n   // Distance threshold.\n   const float h = .01;\n    \n   // total color\n   vec3 tc = vec3(0.);\n    \n    \n   // Setting up the matrix outside of the loop, which might save a few cycles.\n   float cs = cos(iTime*0.4), si = sin(iTime*0.4);\n   rM = mat2(cs, si, -si, cs);\n    //p.xy=c*p.xy+s*vec2(p.y, -p.x); // Rotate p.xy\n    //p.xz=c*p.xz+s*vec2(p.z, -p.x); // Rotate p.xz\n    \n   // Tidied the raymarcher up a bit. Plus, got rid some redundancies... I think.\n\n   // rm loop\n   for (int i=0; i<64*64*64; i++) {\n\n      // Loop break conditions. Seems to work, but let me know if I've \n      // overlooked something. The middle break isn't really used here, but\n      // it can help in certain situations.\n      if(td>(1. - 1./200.) || d<0.001*t || t>1200.)break;\n       \n      // evaluate distance function\n      // Took away the \"0.5\" factor, and put it below. \n      d = map(ro + t*rd); \n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      //const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 1./100.;  // Different weight distribution.\n      td += w + 1./200.;\n\n      \n      // enforce minimum stepsize\n      d = max(d, 0.04); // Increased the minimum, just a little.\n      \n      // step forward\n      t += d*0.5;\n      \n   }\n\n   // Fire palette.\n   tc = firePalette(tc.x);\n    \n   // No gamma correction. It was a style choice, but usually, you should have it.   \n   fragColor = vec4(tc, 1.0); //vec4(tc.x+td*2., ld*3., 0, tc.x);\n}","name":"Image","description":"","type":"image"}]}