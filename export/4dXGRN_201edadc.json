{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// A quick test of several repeated objects with different repetition offsets.\n//\n// Version 1.0 (2013-03-19)\n// Simon Stelling-de San Antonio\n// \n// Many thanks to Inigo Quilez (iq) for articles and example source codes.\n\nvec3 camo;\nvec3 camd;\n\nfloat maxcomp( vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat repeatedSphere( vec3 p, vec3 c, float s )\n{\n  return length( mod(p,c)-0.5*c ) - s;\n}\n\nfloat repeatedBox( vec3 p, vec3 c, float b, float r )\n{\n  return length(max(abs(mod(p,c)-0.5*c)-b,0.0))-r;\n}\n\nfloat repeatedGrid( vec3 p, vec3 c, float b )\n{\n  vec3 d = abs(mod(p,c)-0.5*c)-b;\n  return min(min(max(d.x,d.y), max(d.x,d.z)), max(d.y,d.z));\n}\n\nfloat repeatedCone( vec3 p, vec3 c, vec2 cone )\n{\n  vec3 q = mod(p,c)-0.5*c;\n  // \"cone\" must be normalized\n  float qq = length(q.xy);\n  return max( dot(cone,vec2(qq,q.z)),  // cone\n              length(q)-0.125 // sphere\n            );\n}\n\nvoid attributedUnion( inout vec2 c, float d, float a)\n{\n  if (d < c.x) {\n    c.x = d;\n    c.y = a;\n  }\n}\n\nvoid attributedIntersection( inout vec2 c, float d, float a)\n{\n  if (d > c.x) {\n    c.x = d;\n    c.y = a;\n  }\n}\n\nvec2 map( vec3 p, float camtime )\n{\n  vec2 ret = vec2(min(\n                        // repeatedSphere(p, vec3(2.0), 0.25),\n                        // repeatedBox(p, vec3(0.811), 0.071, 0.031)  ),\n                        repeatedBox(p, vec3(1.2), 0.071, 0.031),\n                        max( repeatedGrid(p, vec3(1.2), 0.0271),\n                             repeatedBox(p+0.05,  vec3(0.1), 0.015, 0.0035)\n                           )\n                        //repeatedBox(p, vec3(0.524), 0.041, 0.017)\n                ), 1.0);\n\n  attributedUnion(ret, repeatedCone(vec3(p.x, p.y, p.z - camtime), \n                                    vec3(1.611, 1.9, 5.0), \n                                    normalize(vec2(1.0, 0.3))), \n                       2.0);\n\n  attributedUnion(ret, max( repeatedSphere(p+0.25, vec3(2.0), 0.25),\n                            repeatedSphere(p, vec3(0.1), 0.046)\n                          ), 3.0);\n\n  attributedIntersection(ret, -sdSphere(p - camo, 0.03), -1.0);\n  return ret;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, float camtime)\n{\n  float t = 0.0;\n  vec2 res = vec2(-1.0, 0.0);\n  bool search = true;\n  for(int i=0; i<40; i++) {\n    if (search) {\n      vec2 d = map(ro + rd*t, camtime);\n      if (d.x < 0.001) {\n        res = vec2(t, d.y);\n        if (d.x < 0.0001) {\n          search = false;\n        }\n      }\n      t += d.x;\n    }\n  }\n  return res;\n}\n\nvec3 calcNormal(in vec3 pos, float camtime)\n{\n  vec2 eps = vec2(0.002, 0.0);\n  vec3 nor;\n  nor.x = map(pos+eps.xyy,camtime).x - map(pos-eps.xyy,camtime).x;\n  nor.y = map(pos+eps.yxy,camtime).x - map(pos-eps.yxy,camtime).x;\n  nor.z = map(pos+eps.yyx,camtime).x - map(pos-eps.yyx,camtime).x;\n  return normalize(nor);\n}\n\nvec3 getCam(float t)\n{\n  return (3.91+1.51*cos(0.61*t))\n   * vec3(0.01+2.51*sin(0.25*t),\n          0.12+1.05*cos(0.17*t),\n          0.04+2.51*cos(0.25*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camtime = 0.4*iTime;\n\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= (iResolution.x / iResolution.y);\n\n    // camera\n    vec3 ro = getCam(camtime);\n    camo = ro;\n//  vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 ww = normalize(getCam(camtime+0.25) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n    camd = rd;\n\n    float sh = 0.0;\n    vec2 hit = intersect(ro,rd,camtime);\n    if (hit.x > 0.0) {\n      vec3 pos = ro + hit.x*rd;\n      rd = calcNormal(pos,camtime);\n      ro = pos;\n      sh = clamp( pow(2.0/length(pos - camo), 2.0), 0.0, 1.0);\n    }\n\n    // light\n    vec3 light = normalize(vec3(1.0,0.9,0.3));\n    float lif = dot(rd,light);\n    float li1 = pow( max( lif,0.0), 3.1);\n    float li2 = pow( max(-lif,0.0), 3.1);\n    // color\n    vec3 col;\n    if (hit.y < 0.0) {\n      col = vec3(1.0, sin(ro.x*30.0+ro.y*24.0+ro.z*16.0)*0.4+0.5, 0.0); // yellow-red\n    } else {\n      if (hit.y == 2.0) {\n        col = vec3(0.7, 0.7, 0.7); // silver bullets\n      } else {\n        col = sin(ro*3.0*hit.y)*0.25+0.25;\n      }\n      col = mix(col, vec3(1.0        ), li1); // add light1 (white)\n      col = mix(col, vec3(0.0,0.1,0.3), li2); // add light2 (dark blue)\n    }\n    // fog color\n    float shf = dot(camd,light);\n    float sh1 = pow( max( shf,0.0), 3.1);\n    vec3 shcol = mix(vec3(0.5,0.6,0.7), vec3(1.0,0.9,0.7), sh1);\n    col = mix(shcol, col, sh); // add fog\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dXGRN","date":"1363732081","viewed":2620,"name":"Infinite repetition","username":"ssdsa","description":"Several repeated objects with different repetition offsets, drawn by simple ray marching. Also colored fog that looks like colored by sun light.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","repetition","fog"],"hasliked":0,"parentid":"","parentname":""}}