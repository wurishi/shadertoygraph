{"ver":"0.1","info":{"id":"lttcRM","date":"1532074416","viewed":201,"name":" five-pointed star ","username":"ssssssilver","description":"pentagram","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pentagram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //动态背景颜色\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    fragColor=vec4(col,1.0);\n    //点的图层\n    vec4 layers[5];\n    float d=iTime*10.0;\n    //保存五个点 从1开始\n    vec2 degree[6];\n    //for循环创建五个点\n    for(int i=0;i<=4;i++)\n    {\n        //保存点\n        //坐标上圆边上的点的坐标(cos(r),sin(r)) r为弧度\n        degree[i+1]=vec2(cos(d*pi/180.0),sin((d*pi)/180.0));\n        //绘制点\n        setlayer(layers,i,circle(uv,degree[i+1],0.06,_FrontColor));\n        //圆上的五角星，每个点相隔72度\n        d+=72.0;\n    } \n    //for循环画五条线\n    for(int i=1;i<6;i++){\n\t\tvec2 point1=vec2(0.0,0.0);\n        //判断连线的位置 即当前点的隔一个点\n\t\tif(i<=2)\n\t\t{\n\t\t\tpoint1=degree[i+3];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpoint1=degree[i-2];\n\t\t}\n        //画线\n\t\tvec4 temp=line(uv,degree[i],point1,0.02);\n        //混合线的图层\n\t\tfragColor=mix(fragColor,temp,temp.a);\n\n\t}\n    //混合点的图层\n   for (int i = 4; i >= 0; i--) {\n        fragColor = mix(fragColor, layers[i], layers[i].a);\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 _OutlineColor = vec4(1.0,1.0,1.0,1.0);\nvec4 _FrontColor = vec4(1,0,0,1.0);\n\nfloat pi=3.14159;\n\nfloat _Antialias=0.01;\n\n\n\n//画线\nvec4 line(vec2 pos, vec2 point1, vec2 point2, float width) {\n    //分别求出点二到点一以及当前点到点一的向量\n    vec2 dir0 = point2 - point1;\n    vec2 dir1 = pos - point1;\n    //dot()方法返回两个向量的点积 如果向量垂直返回0，平行返回1 相反返回-1\n    //clamp()方法限制返回0到1 截出线段，不然会返回直线\n    //这公式返回点到线上的距离\n    float h = clamp(dot(dir1, dir0)/dot(dir0, dir0), 0.0, 1.0);\n    //判断点是否在线的两边范围内\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    //平滑处理\n    float w = fwidth(0.5*d) * 2.0;\n    //画线的外边\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.-smoothstep(-w, w, d - _Antialias));\n    //画线\n    vec4 layer1 = vec4(_FrontColor.rgb, 1.-smoothstep(-w, w, d));\n   \t//混合两个图层\n    return mix(layer0, layer1, layer1.a);\n}\n\n//画点\nvec4 circle(vec2 pos, vec2 center, float radius, vec4 color) {\n    //求点是否在圆的半径内\n    float d = length(pos - center) - radius;\n    //fwidth(x) ==abs(ddx(x)) + abs(ddy(x))，对点求偏导，这种处理能让数据变平滑\n    float w = fwidth(0.5*d) * 2.0;\n    //图层0 画圆外边框\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.0-smoothstep(-w, w, d - _Antialias));\n    //图层1 画内圆\n    vec4 layer1 = vec4(color.rgb, 1.0-smoothstep(0.0, w, d));\n    //混合两个图层并返回\n    return mix(layer0, layer1, layer1.a);\n}\n//根据index来保存图层的颜色值\nvoid setlayer(inout vec4 layer[5],int index,vec4 val){\n\tif(index==0)\n        layer[0]=val;\n    if(index==1)\n        layer[1]=val;\n    \tif(index==2)\n        layer[2]=val;\n    if(index==3)\n        layer[3]=val;\n    if(index==4)\n        layer[4]=val;\n}\n","name":"Common","description":"","type":"common"}]}