{"ver":"0.1","info":{"id":"4tcfDl","date":"1542807827","viewed":126,"name":"Sponge Test","username":"Sobaya","description":"test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 light = vec3(5,2.6,3.2) * 5.;\n\nconst float epsilon = 0.001;\nconst float screen_width = 2.;\nconst float screen_height = 2.;\nconst float screen_depth= 2.;\n\nfloat sdBox3( vec3 p, vec3 b ) {\n    p = abs(p) - b;\n    return min(max(p.x, max(p.y, p.z)), length(max(vec3(0), p)));\n}\n \nfloat distSponge(vec3 p) {\n    p = abs(p);\n    float d = sdBox3(p, vec3(1));\n    float s = 1.;\n    for (int i = 0; i < 3; i++) {\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d ) {\n          d = c;\n        }\n    }\n    return d;\n}\n \nfloat dist(vec3 p) {\n    vec3 xvec = normalize(vec3(1,2,4));\n    vec3 yvec = vec3(0,1,0);\n    vec3 zvec = normalize(cross(xvec, yvec));\n    yvec = normalize(cross(zvec, xvec));\n    mat3 r = mat3(xvec, yvec, zvec);\n    float d = distSponge(r * p);\n    d = min(d, distSponge(r * r * (p - vec3(3,1,0))));\n    d = min(d, p.y + 1.5);\n    return d;\n}\n \nvec3 getNormal(vec3 p) {\n\tvec3 result;\n\tresult.x = dist(p + vec3(epsilon, 0, 0)) - dist(p - vec3(epsilon, 0, 0));\n\tresult.y = dist(p + vec3(0, epsilon, 0)) - dist(p - vec3(0, epsilon, 0));\n\tresult.z = dist(p + vec3(0, 0, epsilon)) - dist(p - vec3(0, 0, epsilon));\n\treturn normalize(result);\n}\n\nvec3 rayMarch(vec3 cv, vec3 p) {\n\tfor (int j = 0; j < 64; j++) {\n\t\tfloat d = dist(p);\n\t\tif (abs(d) < epsilon)\n\t\t\tbreak;\n\t\tp += d * cv;\n\t}\n    return p;\n}\n\nfloat shadow(vec3 p) {\n    const float k = 20.;\n    float res = 1.;\n    vec3 v = normalize(light-p);\n    float t = 0.01;\n    float ph = 1e20;\n    for (int i = 0; i < 32; i++) {\n\t\tfloat h = dist(p + t * v);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        \n        if (res < epsilon) break;\n        if (t > 100.) break;\n\t}\n    return res;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 tc = fragCoord - iResolution.xy * .5;\n    tc /= iResolution.y;\n    vec3 eye = vec3(1, 3, 5.);\n    vec3 yvec = vec3(0, 1, 0);\n    vec3 n = normalize(vec3(0, 1., 0));\n    float angle = 1. * iTime;\n    float c = cos(angle);\n    float s = sin(angle);\n    mat4 matrix;\n\tmatrix[0][0] = n[0]*n[0]*(1.-c)+c;\n\tmatrix[0][1] = n[0]*n[1]*(1.-c)-n[2]*s;\n\tmatrix[0][2] = n[2]*n[0]*(1.-c)+n[1]*s;\n\tmatrix[1][0] = n[0]*n[1]*(1.-c)+n[2]*s;\n\tmatrix[1][1] = n[1]*n[1]*(1.-c)+c;\n\tmatrix[1][2] = n[1]*n[2]*(1.-c)-n[0]*s;\n\tmatrix[2][0] = n[2]*n[0]*(1.-c)-n[1]*s;\n\tmatrix[2][1] = n[1]*n[2]*(1.-c)+n[0]*s;\n\tmatrix[2][2] = n[2]*n[2]*(1.-c)+c;\n    eye = (matrix * vec4(eye, 1.)).xyz;\n    yvec = (matrix * vec4(yvec, 1.)).xyz;\n    vec3 zvec = normalize(eye);\n    vec3 xvec = normalize(cross(yvec, zvec));\n    yvec = normalize(cross(zvec, xvec));\n\tvec3 cv = normalize(screen_width * tc.x * xvec + screen_height * tc.y * yvec - zvec * screen_depth);\n    vec3 p = rayMarch(cv, eye);\n\tfloat d = dist(p);\n\tif (d < epsilon) {\n        float intensity = texture(iChannel0, p.xz * 0.1).r;\n        vec3 color = vec3(intensity);\n        \n        \n\t\tvec3 normal = getNormal(p);\n        float dif = max(0., dot(normal, normalize(light - p)));\n        dif *= shadow(p);\n         \n        \n        float len = length(p - eye);\n        float fog = len * 0.02;\n        \n        color = color * dif + fog;\n        \n        fragColor = vec4(color, 1.);\n\t} else {\n\t\tfragColor = vec4(1);\n\t}\n   // fragColor += sin(iTime);\n}","name":"Image","description":"","type":"image"}]}