{"ver":"0.1","info":{"id":"NlSyRd","date":"1650061405","viewed":216,"name":"Moduli Of Right Angled Hexagons","username":"stevejtrettel","description":"There is a 3-parameter family of tilings of the hyperbolic plane by right angled hexagons.  This shader computes them!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolicgeometry","coxetergroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//default is drawn in poincare disk:\n//switch to upper half plane?\nbool halfPlane=false;\n\n\n//a hyperbolic hexagon is determined\n//by three alternating side lengths.\n//choose any 3 positive real numbers here\n//to draw the hexagon of your choice!\nvec3 chooseRepresentation(){\n  \n    float l = asinh(sqrt(3.));\n\n    float A = l+0.2*sin(iTime);\n    float B = l+0.3*sin(iTime/2.);\n    float C = l+0.4*sin(iTime/3.);\n    \n    return vec3(A,B,C);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n//------------------------------------------\n//Useful Constants\n//------------------------------------------\n\nfloat PI = 3.14159;\nfloat sqrt2 = sqrt(2.);\nfloat sqrt3 = sqrt(3.);\nvec2 I = vec2(0.,1.);\n\n//floating point infinity:\n//the funciton isinf() tests if a value is infinite, returning a boolean\nfloat infty = 1./0.;\n\n\n\n//------------------------------------------\n//Useful Colors\n//------------------------------------------\n\nvec3 lightBlue = vec3(170,210,255)/255.;\nvec3 medBlue = vec3(120, 170, 250)/255.;\nvec3 darkBlue = vec3(110, 155, 240)/255.;\n\nvec3 lightPurple = vec3(170,210,255)/255. + vec3(0.2,0,0);\nvec3 medPurple = vec3(120, 170, 250)/255. + vec3(0.3,0,0);\nvec3 darkPurple = 0.7*(vec3(110, 155, 240)/255. + vec3(0.3,0,0));\n\nvec3 lightGreen = vec3(149, 245, 181)/255.;\nvec3 medGreen = vec3(149, 245, 181)/255.;\n\nvec3 pink = vec3(255, 117, 133)/255.;\n\n\n//----------------------------------------------\n//------------------------------------------\n//SETUP\n//------------------------------------------\n//----------------------------------------------\n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizeCoords( vec2 fragCoord ){\n\n    // Normalized the pixel coordinates from 0 to 1\n    //fragCoord is a vector of integers, giving the pixel on the screen\n    //its (0,0) in the top left, increasing down and to the right.\n    //iResolution is a uniform giving the total number of pixels across x,y\n    //the bottom right corner of the screen has pixel coordinates (iResolution.x, iResolution.y)\n\n\n    //dividing fragCoord by iResolution results in coordinates running from (0,0) to (1,1)\n    vec2 uv =fragCoord/iResolution.xy;\n\n    //translate so coordinates run (-0.5, 0.5)\n    uv = uv - vec2(0.5);\n\n    //preserve original aspect ratio\n    float aspect = iResolution.y/iResolution.x;\n    uv = vec2(1,aspect)*uv;\n\n    //rescale however you like\n    uv = 4.*uv;\n\n    return uv;\n}\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//COMPLEX NUMBERS\n//------------------------------------------\n//----------------------------------------------\n\n//points in the hyperbolic plane are represented by vec2(x,y)\n//these can be added, subtracted and scalar multiplied by built-in operations\n//these can be multiplied and inverted (as complex numbers) using the following\n\n\n//turn a real number into a complex number\nvec2 toC( float x ){\n    return vec2(x,0);\n}\n\n\n\n//complex multiplication\nvec2 mult( vec2 z, vec2 w )\n{\n    float re = z.x*w.x - z.y*w.y;\n    float im = z.x*w.y + z.y*w.x;\n\n    vec2 res = vec2(re, im);\n    return res;\n}\n\n\n//complex conjugation, negates imaginary party\nvec2 conj( vec2 z )\n{\n    vec2 res = vec2(z.x,-z.y);\n    return res;\n}\n\n\n//inverse of the complex number z\nvec2 invert( vec2 z )\n{\n    float mag2 = dot(z,z);\n    vec2 res = conj(z)/mag2;\n    return res;\n}\n\n\n//compute the quotient z/w\nvec2 divide( vec2 z, vec2 w )\n{\n    return mult(z,invert(w));\n}\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//CONVERSIONS BETWEEN MODELS\n//------------------------------------------\n//----------------------------------------------\n\n\n//------------------------------------------\n//Poincare Disk Model\n//------------------------------------------\n\n\n//check if you are inside the unit disk or not\nbool insidePD( vec2 z )\n{\n    //returns true if the inequality is satisfied, falso otherwise\n    return dot(z,z)<1.;\n}\n\n\n\n//apply the mobius transformation taking a point to UHP\n//this is the map z -> (iz+1)/(z+i)\nvec2 toHP( vec2 z ){\n\n    vec2 num = z+I;\n    vec2 denom = mult(I,z)+toC(1.);\n    vec2 res = divide(num,denom);\n    return res;\n}\n\n\n\n\n\n\n\n\n\n//------------------------------------------\n//Upper Half Plane Model\n//------------------------------------------\n\n//check if you are in the upper half plane or not\nbool insideHP( vec2 z )\n{\n    //returns true if the inequality is satisfied, falso otherwise\n    return z.y>0.;\n}\n\n\n//take a point in the upper half plane and map it to the disk\n//this is the transformation z -> (z-i)/(z+i)\nvec2 toPD(vec2 z){\n    vec2 num = z-I;\n    vec2 denom = z+I;\n    vec2 res = divide(num,denom);\n    return res;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//Upper Half Plane\n//------------------------------------------\n//----------------------------------------------\n\n//this is a general mobius transformation applied to points in upper half space\n//do the mobius transformation ((a,b),(c,d)).z\nvec2 applyMobius(vec4 mob, vec2 z){\n    float a=mob.x;\n    float b=mob.y;\n    float c=mob.z;\n    float d=mob.w;\n\n    vec2 num = a*z+toC(b);\n    vec2 denom = c*z + toC(d);\n\n    vec2 res = divide(num,denom);\n\n    return res;\n\n}\n\n\n\n\n//return result of the isometry in stab(infty) which sends origin to p, applied to z\nvec2 originToP(vec2 p, vec2 z){\n    float x = p.x;\n    float y = p.y;\n\n    //expand by y\n    z = y*z;\n    \n    //slide by x\n    z=z+vec2(x,0);\n    \n    //together this took (0,1) to (0,y) to (x,y)\n    return z;\n}\n\n\nvec2 pToOrigin(vec2 p, vec2 z){\n    float x = p.x;\n    float y = p.y;\n    float r = x;\n\n    //slide by x\n    z = z - vec2(x, 0.);\n\n    //divide by y\n    z = z/y;\n\n    //now; p has been moved to (x,y)->(0,y)->(0,1)\n    //which is the origin of UHP\n    return z;\n}\n\n\n\n\n\n\n//------------------------------------------\n//Points\n//------------------------------------------\n// a point is just a vec2, thought of as a complex number;\n//no special structure here\n\n\n//measure the distance to a point\nfloat dist(vec2 z, vec2 p){\n\n    //just directly using distance function in UH\n    vec2 rel = z-p;\n    float num = dot(rel,rel);\n    float denom = 2.*z.y*p.y;\n    return acosh(1.+num/denom);\n\n}\n\n\n\n\n\n\n//------------------------------------------\n//Geodesics\n//------------------------------------------\n\n\n//a geodesic is encoded by remembering its two boundary points\n//these are real numbers (or the constant infty)\nstruct Geodesic{\n//first endpoint\n    float p;\n//second endpoint\n    float q;\n};\n\n\n\n//check if a geodesic is a line\nbool isLine( Geodesic geo ) {\n    return isinf(geo.p)||isinf(geo.q);\n}\n\n\n\n\n//check if a geodesic is a line, and return its endpoint\nbool isLine( Geodesic geo, out float endpt ) {\n\n    //if p is infinity, q is the real endpoint\n    if(isinf(geo.p)){\n        endpt = geo.q;\n        return true;\n    }\n\n    //if q is infinity, p is the real endpoint\n    else if ( isinf(geo.q) ){\n        endpt = geo.p;\n        return true;\n    }\n\n    //if neither is infinity, its not a line\n    return false;\n}\n\n\n\n\n\n//reflect in the geodesic geo\nvec2 reflectIn(vec2 z, Geodesic geo){\n\n    float endpt;\n\n    //if its a line, do one thing\n    if(isLine(geo,endpt)){\n        z.x -= endpt;\n        z.x *= -1.;\n        z.x += endpt;\n        return z;\n    }\n\n    //else, if its a circle do something else\n    else{\n        float center = (geo.p+geo.q)/2.;\n        float radius = abs((geo.p-geo.q))/2.;\n\n        z.x -= center;\n        z /= radius;\n        z /= dot(z,z);\n        z *= radius;\n        z.x += center;\n\n        return z;\n    }\n}\n\n\n\n//measure the distance to a geodesic\nfloat dist(vec2 z, Geodesic geo){\n\n    float endpt;\n\n    //if its a vertical line\n    if(isLine(geo,endpt)){\n        //translate to the origin\n        z.x-=endpt;\n        //measure distance as angle\n        float secTheta=length(z)/abs(z.y);\n        return acosh(secTheta);\n    }\n\n    //otherwise, its a circle\n    else{\n\n        //build mobius transformation taking geo to (0,infty)\n        vec4 mob=vec4(1.,-geo.p,1.,-geo.q);\n        z = applyMobius(mob, z);\n\n        //now measure the distance to this vertical line\n        //measure distance as angle\n        float secTheta=length(z)/abs(z.y);\n        return acosh(secTheta);\n    }\n}\n\n\n\n\n\n\n\n\n//------------------------------------------\n//Half Spaces\n//------------------------------------------\n\n\n//a half space is bounded by a geodesic,\n//and is all the area on one side of it\n//side is - if it contains a portion of the real line (bounded area in model)\n//side is + if it contains infinity\nstruct HalfSpace{\n    Geodesic bdy;\n    float side;\n};\n\n\n\n//inside checks if you are in a half space or not:\nbool inside(vec2 z, HalfSpace hs){\n\n    float endpt;\n\n    //if the half space is bounded by a line:\n    if( isLine( hs.bdy, endpt ) ){\n\n        //is point to the right (+) or left (-) of the boundary?\n        float side = sign(z.x - endpt);\n\n        //check if this is inside (+) or outside (-) the halfspace\n        return side*hs.side>0.;\n    }\n\n    //otherwise, the half space is bounded by a circle\n    //endpoint was never assigned so dont use it\n    else{\n\n        float center = (hs.bdy.p+hs.bdy.q)/2.;\n        float radius = abs((hs.bdy.p-hs.bdy.q))/2.;\n\n        //get relative position\n        vec2 rel = z-toC(center);\n        //get radius\n        float dist2 = dot(rel,rel);\n\n        //get inside (+) or outside (-) circle\n        float side = sign(dist2-radius*radius);\n\n        //return true (+) if in half space, false if not\n        return side*hs.side>0.;\n    }\n}\n\n\n\n\n//reflect into a half space:\n//if you are inside already, do nothing\n//if you are outside, reflect in the boundary\n//parity is +-1, if we do a reflection we multiply it by -1.\nvec2 reflectIn( vec2 z, HalfSpace hs, inout float parity) {\n    if(!inside(z,hs)){\n        vec2 res = reflectIn(z,hs.bdy);\n        parity*=-1.;\n        return res;\n    }\n\n    return z;\n}\n\n\n\n\n\n//------------------------------------------\n//Right Angled Hexagons\n//------------------------------------------\n\n//a  right angled pentagon is the intersection of 5 orthognal half spaces\n//we will call these a, b, c, d, and e\nstruct Hexagon{\n    HalfSpace a;\n    HalfSpace b;\n    HalfSpace c;\n    HalfSpace d;\n    HalfSpace e;\n    HalfSpace f;\n};\n\n\n\n\nbool inside(vec2 z, Hexagon H){\n    //check if you are inside all six half-spaces\n    return inside(z,H.a)&&inside(z,H.b)&&inside(z,H.c)&&inside(z,H.d)&&inside(z,H.e)&&inside(z,H.f);\n}\n\n\n\n//reflect in each side of the triangle,\n//if the point is on the wrong side of the half space\nvec2 reflectIn(vec2 z, Hexagon H, inout float parity){\n    z = reflectIn(z, H.a, parity);\n    z = reflectIn(z, H.b, parity);\n    z = reflectIn(z, H.c, parity);\n    z = reflectIn(z, H.d, parity);\n    z = reflectIn(z, H.e, parity);\n    z = reflectIn(z, H.f, parity);\n    return z;\n}\n\n\n\n//iteratively reflect until you end up in the domain\n//report the parity of the number of flips:\nvec2 moveInto(vec2 z, Hexagon H, out float parity){\n\n    parity=1.;\n\n    for(int i=0;i<50;i++){\n        z=reflectIn(z,H,parity);\n        if(inside(z,H)){\n            break;\n        }\n    }\n\n    return z;\n\n}\n\n\n\nfloat dist( vec2 z, Hexagon H){\n    float d;\n    d = dist(z, H.a.bdy);\n    d = min(d, dist(z, H.b.bdy));\n    d = min(d, dist(z, H.c.bdy));\n    d = min(d, dist(z, H.d.bdy));\n    d = min(d, dist(z, H.e.bdy));\n    d = min(d, dist(z, H.f.bdy));\n    return d;\n}\n\n\n\nHexagon createHexagon(float x, float y, float z){\n\n    //sinh and cosh of the original side lengths\n    float cx = cosh(x);\n    float cy = cosh(y);\n    float cz = cosh(z);\n\n    float sx = sinh(x);\n    float sy = sinh(y);\n    float sz = sinh(z);\n\n    //compute the opposing side lengths\n    float cX = (cx+cy*cz)/(sy*sz);\n    float cY = (cy+cx*cz)/(sx*sz);\n    float cZ = (cz+cx*cy)/(sx*sy);\n\n    float X = acosh(cX);\n    float Y = acosh(cY);\n    float Z = acosh(cZ);\n\n    float sX = sinh(X);\n    float sY = sinh(Y);\n    float sZ = sinh(Z);\n\n\n    //start computing the edges:\n\n    //to the right of the vertical line\n    HalfSpace a = HalfSpace(Geodesic(0.,infty),1.);\n\n    //above the unit circle\n    HalfSpace b = HalfSpace(Geodesic(-1.,1.),1.);\n\n    //below the circle at height Y above unit circle\n    HalfSpace f = HalfSpace(Geodesic(exp(Y),-exp(Y)),-1.);\n\n    //above the circle which is translate of vertical line along unit circle by dist x\n    HalfSpace c = HalfSpace(Geodesic(tanh(x/2.),1./tanh(x/2.)),1.);\n\n    //above the circle that is a translate by z along unit circle, then by Y along vertical geodesic\n    HalfSpace e = HalfSpace(Geodesic(exp(Y)*tanh(z/2.),exp(Y)/tanh(z/2.)),1.);\n\n    //the final circle is the minimizing geodesic between the sides c and e:\n    //this side is the image of the vertical line after translating D along unit circle, then h along vertical geodesic\n    float cD = sx*sZ;\n    float D = acosh(cD);\n    float sD = sinh(D);\n\n    float sh = cZ/sD;\n    float h = asinh(sh);\n\n    HalfSpace d = HalfSpace(Geodesic(exp(h)*tanh(D/2.),exp(h)/tanh(D/2.)),1.);\n\n    //finally we have the complete hexagon\n    Hexagon H = Hexagon(a,b,c,d,e,f);\n    return H;\n}\n\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//PRODUCING THE IMAGE\n//------------------------------------------\n//----------------------------------------------\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //the vector that will store our final color:\n    vec3 color=vec3(0);\n    //an overall scaling factor to lighten/darken the image\n    float adjustment = 1.;\n\n    // Normalized pixel coordinates\n    vec2 z = normalizeCoords( fragCoord );\n    vec2 mouse = normalizeCoords(iMouse.xy);\n    \n    \n    \n    if(halfPlane){\n         //this is actually easier to compute: we just begin automatially with the half plane\n        //need to shift downwards\n        z=z+vec2(0,1.);\n        mouse=mouse+vec2(0,1.);\n    \n        //turn down the exposure if in lower half plane\n        if(z.y<0.){\n            adjustment=0.2;\n        }\n        \n        //move the origin of PD to mouse location\n       z = pToOrigin(mouse,z);\n    }\n    \n    //the default view: start from the poincare disk\n    else{\n         //rotate slowly around the center of the poincare disk for fun\n        float c=cos(iTime/50.);\n        float s=sin(iTime/50.);\n        mat2 rot = mat2(c,s,-s,c);\n        z=rot*z;\n\n        //check if insidePD\n        //if not, turn down the exposure\n        if(!insidePD(z)){\n            adjustment =0.2;\n        }\n\n       //move to upper half plane for computations\n       z = toHP(z);\n       vec2 mouseHP = toHP(mouse);\n        \n       //move the origin of PD to mouse location\n      if(iMouse.z>0.){\n       z=pToOrigin(mouse,z);\n       }\n       \n       \n        //transform things so that the pentagon's \"center\" is in the middle\n        vec2 cent = vec2(-0.5,0.65)+0.05*vec2(sin(iTime/3.),sin(iTime/2.));\n        z=pToOrigin(cent, z);\n    }\n   \n    \n    //create a geometric representataion of the right angled pentagon\n    vec3 rep = chooseRepresentation();\n    Hexagon P = createHexagon(rep.x,rep.y,rep.z);\n\n    \n    //set background color of the disk\n    color = darkBlue;\n\n    \n    //color the fundamental domain\n    if(inside(z,P)){\n        color=pink;\n    }\n\n    \n    //reflect all other points into the fundamental domain:\n    //color orientation preserving and revesing pentagons depending on parity\n    float parity=1.;\n    vec2 w = moveInto(z,P,parity);\n    if(parity==-1.){\n        color=medBlue;\n    }\n    \n    \n    //color the edges of the pentagonal tiling\n    float d = dist(w, P);\n    if(d<0.015){color=lightPurple;}\n\n\n\n    //take the computed color and apply the adjustment\n    color = adjustment*color;\n    //output to the computer screen\n    fragColor=vec4(color,1);\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}