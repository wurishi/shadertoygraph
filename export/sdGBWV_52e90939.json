{"ver":"0.1","info":{"id":"sdGBWV","date":"1658856303","viewed":75,"name":"Ray marching testing - Goby","username":"Goby56","description":"Testing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define HIT_DIST 0.001\n\nfloat ClosestObject(vec3 point) {\n    vec4 sphere = vec4(0, sin(0.8*iTime)+0.5, 8, 2);\n    float sphereDist = length(point-sphere.xyz)-sphere.w;\n    float planeDist = point.y;\n    \n    //return sphereDist;\n    return min(sphereDist, planeDist);\n}\n\nvec2 DE(vec3 pos)\n{\n\tfloat Iterations = 64.;\n    float Bailout = 2.;\n    float Power = 6. - 4.*cos(iTime/16.);\n    \n    vec3 trap = vec3(0,0,0);\n    float minTrap = 1e10;\n    \n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n        \n        minTrap = min(minTrap, z.z);\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\t//z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z = zr*vec3( cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta) );\n\t\tz+=pos;\n\t}\n\treturn vec2(0.5*log(r)*r/dr, minTrap);\n}\n\nvec2 MarchRay(vec3 origin, vec3 direction) {\n    float distFromOrigin = 0.;\n    \n    float steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 point = origin + direction * distFromOrigin;\n        float distToScene = ClosestObject(point);\n        distFromOrigin += distToScene;\n        \n        if (distFromOrigin>MAX_DIST || distToScene<HIT_DIST) {\n            steps = float(i);\n            break;\n        }\n    }\n    \n    return vec2(distFromOrigin, steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 camera = vec3(0, 1, 0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1));\n    \n    \n    vec2 result = MarchRay(camera, rayDir);\n    float dist = result.x;\n    float steps = result.y;\n    \n    col = vec3(steps/float(MAX_STEPS));\n     \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}