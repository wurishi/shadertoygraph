{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/////////////////////////////////////////////////\n// Variable Conversions\n\n\n/////////////////////////////////////////////////\n// SD Objects\n\nfloat sdPlane( vec3 p, vec4 n ){ return dot(p,n.xyz) + n.w + 0.1*sin(p.z*3.0)*sin(p.x*3.0); }\n\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - 0.1;\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdTorus( vec3 p, vec2 t ) {\n\tvec2 c = vec2(sin(iTime), cos(iTime)); // Rotate!!!\n\tp.yz = vec2(c.y*p.y - c.x*p.z, c.x*p.y + c.y*p.z);\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n/////////////////////////////////////////////////\n// Raymarching Functions\n\n// Objects\n\nfloat ground;\nvec3 ground_pos = vec3(0.0, -0.55, 0.0);\nconst vec3 ground_color = vec3(0.8);\n\nfloat box1;\nvec3 box1_pos;\nconst vec3 box1_dim = vec3(0.5);\nconst vec3 box1_color = vec3(0.1, 0.5, 1.0);\n\nfloat box2;\nvec3 box2_pos = vec3(-2.0, 0.0, 0.0);\nconst vec3 box2_dim = vec3(0.1, 5.5, 3.0);\nconst vec3 box2_color = vec3(1.0);\n\nfloat box3;\nvec3 box3_pos = vec3(-2.0, 0.0, -2.0);\nconst vec3 box3_dim = vec3(20.5, 10.5, 0.1);\nconst vec3 box3_color = vec3(0.0,0.0,0.0);\n\nfloat torus;\nvec3 torus_pos;\nconst vec2 torus_dim = vec2(0.7, 0.1);\nconst vec3 torus_color = vec3(0.0, 0.6, 0.0);\n\nfloat sphere1;\nvec3 sphere1_pos;\nconst float sphere1_radius = 0.5;\nconst vec3 sphere1_color = vec3(1.0, 0.1, 0.1);\n\nfloat sphere2;\nvec3 sphere2_pos;\nconst float sphere2_radius = 0.5;\nconst vec3 sphere2_color = vec3(0.9, 0.1, 1.0);\n\n// 2nd Nearest\nfloat d2;\nvec3 d2_pos = vec3(0.);\nfloat d2_weight = 0.0;\n\n// Only Scene Distance Info\nfloat scene(vec3 p){\n\tfloat d = 1e10;\n\t\n\tground = sdPlane(p - ground_pos, vec4(0., 1., 0., 0.));\n\tbox1 = sdBox(p - box1_pos, box1_dim);\n\tbox2 = sdBox(p - box2_pos, box2_dim);\n\tbox3 = sdBox(p - box3_pos, box3_dim);\n\tsphere1 = sdSphere(p - sphere1_pos, sphere1_radius);\n\tsphere2 = sdSphere(p - sphere2_pos, sphere2_radius);\n\ttorus = sdTorus(p - torus_pos, torus_dim);\n\t\n\td = min(d, ground);\n\td = min(d, box1);\n\td = min(d, box2);\n\td = min(d, box3);\n\td = min(d, sphere1);\n\td = min(d, sphere2);\n\td = min(d, torus);\n\t\n\treturn d;\n}\n\nvec3 scene_color(vec3 p){ // Disjoint function so you only evaluate colors once\n\tfloat d = 1e10;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tif (ground < d){\n\t\tcol = ground_color;\n\t\td = ground;\n\t}\n\t\n\tif (box1 < d){\n\t\tcol = box1_color;\n\t\td = box1;\n\t}\n\t\n\tif (box2 < d){\n\t\tcol = box2_color;\n\t\td = box2;\n\t}\n\t\n\tif (box3 < d){\n\t\t////////////////////////\n\t\t\n        float aspect = iResolution.x/iResolution.y;\n\t\tvec4 tex =  texture(iChannel0, mod(p.xy * 0.15 * vec2(1.0, aspect), 1.0));\n\t\tcol = box3_color + (tex*tex + tex*0.5).xyz; // Higher Contrast!\n\t\td = box3;\n\t}\n\t\n\tif (sphere1 < d){\n\t\tcol = sphere1_color;\n\t\td = sphere1;\n\t}\n\t\n\tif (sphere2 < d){\n\t\tcol = sphere2_color;\n\t\td = sphere2;\n\t}\n\t\n\tif (torus < d){\n\t\tcol = torus_color;\n\t\td = torus;\n\t}\n\t\n\treturn col;\n}\n\n// Interpolated Scene Color Info\nvec3 scene_color_lerp(vec3 p){\n\tvec3 col;\n\tfloat d = 1e10;\n\t\n\tfloat ground_weight = 0.0;\n\tfloat box1_weight = 0.0;\n\tfloat box2_weight = 0.0;\n\tfloat box3_weight = 0.0;\n\tfloat sphere1_weight = 0.0;\n\tfloat sphere2_weight = 0.0;\n\tfloat torus_weight = 0.0;\n\t\n\t#define epsmod 0.0105\n\t#define GI 0.7\n\n\t// Conditions to prevent self illumination\n\tif (ground > epsmod + ground_pos.y) ground_weight = GI/(ground + 1.5);\n\tif (box1 > epsmod) box1_weight = GI/(box1 + 1.0);\n\tif (box2 > epsmod) box2_weight = GI/(box2 + 1.0);\n\tif (box3 > epsmod) box3_weight = GI/(box3 + 1.0);\n\tif (sphere1 > epsmod) sphere1_weight = GI/(sphere1 + 1.0);\n\tif (sphere2 > epsmod) sphere2_weight = GI/(sphere2 + 1.0);\n\tif (torus > epsmod) torus_weight = GI/(torus + 1.0);\n\t\n\tcol =\n\t\tground_color  * ground_weight  + \n\t\tbox1_color * box1_weight + \n\t\tbox2_color * box2_weight + \n\t\tbox3_color * box3_weight + \n\t\tsphere1_color * sphere1_weight + \n\t\tsphere2_color * sphere2_weight + \n\t\ttorus_color * torus_weight;\n\t\n\treturn col*col*col*0.15;\n}\n\nvec3 normal(vec3 p) {\n\tconst float epsilon = 0.01;\n    return normalize( vec3(scene( vec3(p.x + epsilon, p.y, p.z)) - scene( vec3(p.x - epsilon, p.y, p.z)) , scene( vec3(p.x, p.y + epsilon, p.z)) - scene( vec3(p.x, p.y - epsilon, p.z)), scene( vec3(p.x, p.y, p.z + epsilon)) - scene( vec3(p.x, p.y, p.z - epsilon))));\n}\n\nvec3 normalWide(vec3 p) {\n\tconst float epsilon = 0.07;\n    return normalize( vec3(scene( vec3(p.x + epsilon, p.y, p.z)) - scene( vec3(p.x - epsilon, p.y, p.z)) , scene( vec3(p.x, p.y + epsilon, p.z)) - scene( vec3(p.x, p.y - epsilon, p.z)), scene( vec3(p.x, p.y, p.z + epsilon)) - scene( vec3(p.x, p.y, p.z - epsilon))));\n}\n\nfloat cell_shade = 0.0;\n\nvec3 intersect(in vec3 ro, in vec3 rd) {\n\t#define start_distance 0.01\n    float d, t = start_distance, t2 = 0.;\n    for (int i = 0; i < 128; i++) {\n\t\td = scene(t*rd + ro);\n\t\t//if (d < 0.01) return(t*rd + ro); \t// Bug: Return/Break doesn't work\n\t\t\n\t\t#define CELL_SHADE_WIDTH 0.05\n\t\tif ( abs(d) <= CELL_SHADE_WIDTH && t2 < start_distance) t2 = t;\n\t\tt += d;\n    }\n\n\tif (abs(t - t2) < .4) cell_shade = 1.0;;\n\n\treturn t*rd + ro;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd){\n    float res = 1.0, t = 0.15; // t=0.15 -> no banding on my stock x.org drivers\n    for(int s = 0; s < 16; ++s){\n        float h = scene(ro + rd*t);\n        if(h < 0.01) return 0.0;\n        res = min( res, 2.0*h/t );\n        t += h*0.9;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    box1_pos = vec3(sin(iTime - 2.5), 0.6 - sin(iTime)*0.2, -cos(iTime - 2.5));\n    torus_pos = vec3(sin(iTime - 4.5), 0.3, -cos(iTime - 4.5));\n    sphere1_pos = vec3(sin(iTime), 0.0, -cos(iTime));\n    sphere2_pos = vec3(sin(iTime)*5. + 2.5, 2.0 - sin(iTime), -cos(iTime));\n\n    \n\tvec3 col = vec3(1.0);\n    float aspect = iResolution.x/iResolution.y;\n\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tvec3 rd = normalize(vec3(aspect * p.x, p.y, -2.0));\n\tvec3 ro = vec3(1.0 + 0.5*(10.0*iMouse.x/iResolution.x), 0.0 + 0.5*(2.0*iMouse.y/iResolution.y), 5.0);\n\t\n\tvec3 pos, n, n2, pos2, color_mix;\n\n\tpos = intersect(ro, rd);\n\t\n\tn = normal(pos);\n\tcol = scene_color(pos);\n\tvec3 gi = scene_color_lerp(pos);\n\t\n\tconst vec3 lightPos = vec3(5.0, 10.0, 5.0);\n\tconst float shininess = 100.0;\n\tvec3 l = normalize(lightPos - pos);\n    vec3 v = normalize(ro - pos);\n    vec3 h = normalize(v + l);\n    float diff = dot(n, l);\n    float spec = max(0.0, pow(dot(n, h), shininess)) * float(diff > 0.0);\n    //diff = max(0.0, diff);\n    diff = 0.5+0.5*diff;\n\tfloat ao = ambientOcclusion(pos, n);\n\tfloat shadow = softshadow(pos, normalize(lightPos));\n\n    float fresnel = pow(1.0 - dot(n, v), 5.0);\n\n\tcolor_mix = vec3(diff*(0.5+0.5*shadow)*ao*(col+gi) + spec);\n\n\t// May cause issues in some cases\n\tif (abs(dot(n,normalWide(pos)))<0.95) cell_shade = 0.0; // Cell shade if surface normal is sufficiently different from local(wide) normal\n\t\n\tfragColor = vec4(color_mix * cell_shade, 1.0);\n\t\n\t// View Fake GI\n\t//fragColor = vec4(gi * cell_shade, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldlGR8","date":"1363111817","viewed":1010,"name":"RM Cell Shading","username":"tz","description":"Basically checks if any object comes within a secondary threshold, and if it does then it cell shades it. Also cell shades if the surface normal is sufficiently different from the local normal.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["cellshading","cheap","globalillumination"],"hasliked":0,"parentid":"","parentname":""}}