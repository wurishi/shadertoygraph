{"ver":"0.1","info":{"id":"llVfD3","date":"1544373676","viewed":161,"name":"voxel kaiware","username":"kaiware007","description":"voxel kaiware","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// voxel kaiware\n//\n// Original Raymarching code(CalcNormal, CalcAO)\n// Deformed by XBE\n// https://www.shadertoy.com/view/XdfSDB\n\n#define SQRT3\t1.73205080757\n#define KAIWARE_SIZE 2.5\n\nfloat voxelResolution = 0.1;\n\n// Distance functions by iq\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdKaiware(vec3 p, float sc)\n{\n\t\n\t// scale\n\tp = p / sc;\n\n\t// head - 頭部\n\tfloat d1 = sdRoundBox(p, vec3(1, 0.8, 1), 0.1);\n\n\t// beak - くちばし\n\tfloat d2_0 = sdRoundBox(p - vec3(0, -0.2, 0.7), vec3(0.8, 0.25, 0.4), 0.1);\n\tfloat d2_1 = sdRoundBox(p - vec3(0, -0.0, 0.7), vec3(1.1, 0.35, 1.1), 0.0);\n\tfloat d2_2 = sdRoundBox(p - vec3(0, -0.4, 0.7), vec3(1.1, 0.35, 1.1), 0.0);\n\tfloat d2_3 = sdRoundBox(p - vec3(0, -0.2, 0.7), vec3(0.75, 0.1, 0.35), 0.1);\n\n\tfloat d2_top = max(d2_0, d2_1);\n\tfloat d2_bottom = max(d2_0, d2_2);\n\tfloat d2 = min(min(d2_top, d2_bottom), d2_3);\n\n\t// stem - はっぱの茎\n\tfloat d3_0 = sdCapsule(p, vec3(0, 0.5, 0), vec3(0, 0.75, 0), 0.05);\n\t// leaf - 葉っぱ\n\tfloat d3_1 = sdEllipsoid(p - vec3(0.2, 0.75, 0), vec3(0.2, 0.025, 0.1));\n\tfloat d3_2 = sdEllipsoid(p - vec3(-0.2, 0.75, 0), vec3(0.2, 0.025, 0.1));\n\tfloat d3 = min(d3_0, min(d3_1, d3_2));\n\n\t// eyes - 目\n\tfloat d4_0 = sdCapsule(p, vec3(0.2, 0.25, 0.6), vec3(0.4, 0.2, 0.6), 0.025);\n\tfloat d4_1 = sdCapsule(p, vec3(-0.2, 0.25, 0.6), vec3(-0.4, 0.2, 0.6), 0.025);\n\tfloat d4 = min(d4_0, d4_1);\n\n\t// combine - 合成\n\tfloat sum = max(min(min(d1, d2), d3), -d4);\n\n\tsum *= sc;\n\n\treturn sum;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 repeat(vec3 p, vec3 size)\n{\n    return mod(p, size) - 0.5 * size;\n}\n\n// Distance to the voxel\nfloat distVoxel (in vec3 p) {\n\n\t// Rounded box\n\tconst float voxelRadius = 0.1;\n\treturn length (max (abs (p) - 0.5 + voxelRadius, 0.0)) - voxelRadius;\n}\n\nfloat map( in vec3 pos )\n{    \n    \n    pos *= voxelResolution;\n    \n    //pos = repeat(pos, vec3(KAIWARE_SIZE * 2.5));\n\n    //pos = rotate(pos, iTime * -0.5, vec3(0,1,0));\n    \n    float l = sdKaiware(pos, KAIWARE_SIZE);\n    \n    // Scaling\n\tl /= voxelResolution;\n    \n    return l;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n\tvec2 h = vec2 (0.001, -0.001);\n\tvec3 n;\n    p = fract (p + 0.5) - 0.5;\n    n = h.xxx * distVoxel (p + h.xxx) +\n        h.xyy * distVoxel (p + h.xyy) +\n        h.yxy * distVoxel (p + h.yxy) +\n        h.yyx * distVoxel (p + h.yyx);\n\n\treturn normalize (n);\n}\n\n// Distance to the (voxelized?) scene\nbool raymarch(inout vec3 p, in vec3 ray, out float dist, out vec3 norm)\n{\n\tfloat rayLength = 0.0;\n\tfloat rayLengthInVoxel = 0.0;\n\tfloat rayLengthCheckVoxel = 0.0;\n\tvec3 raySign = sign (ray);\n\tvec3 rayDeltaVoxel = raySign / ray;\n    float epsilon = 0.001;\n\tfloat maxdist = 250.0 / voxelResolution;\n\tfloat marched = 0.0;\n\tfloat delta = 2.*epsilon;\n    float rayLengthMax = maxdist / voxelResolution;\n    dist = -1.0;\n    \n\tfor (float rayStep = 0.0; rayStep < 128.0; ++rayStep) {\n\t\tif (rayLength < rayLengthInVoxel) {\n\t\t\tdelta = distVoxel (fract (p + 0.5) - 0.5);\n\t\t\tif (delta < epsilon) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (rayLength < rayLengthCheckVoxel) {\n            \n\t\t\tvec3 rayDelta = (0.5 - raySign * (fract (p + 0.5) - 0.5)) * rayDeltaVoxel;\n\t\t\tfloat dNext = min (rayDelta.x, min (rayDelta.y, rayDelta.z));\n            delta = map(floor (p + 0.5));\n\t\t\tif (delta < 0.0) {\n\t\t\t\trayDelta = rayDeltaVoxel - rayDelta;\n\t\t\t\tdelta = max (rayLengthInVoxel - rayLength, epsilon - min (rayDelta.x, min (rayDelta.y, rayDelta.z)));\n\t\t\t\trayLengthInVoxel = rayLength + dNext;\n\t\t\t} else {\n\t\t\t\tdelta = epsilon + dNext;\n\t\t\t}\n\t\t} else {\n            delta = map(p);\n            if (delta < SQRT3 * 0.5) {\n                rayLengthCheckVoxel = rayLength + abs (delta) + SQRT3 * 0.5;\n                delta = max (rayLengthInVoxel - rayLength + epsilon, delta - SQRT3 * 0.5);\n            }\n\t\t}\n\t\trayLength += delta;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += delta * ray;\n\t}\n    bool res = false;\n    if(delta < epsilon)\n    {\n    \tnorm = calcNormal(p);\n\t\tdist = marched;\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = distVoxel( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n\tfloat dist = 0.;\n\tvec3 nor = vec3(0.,0.,0.);\n\t//\n\tvec3 lig = normalize( vec3(0.6, 0.7, 0.5) );\n    vec3 sky = vec3(0.32,0.36,0.4) - rd.y*0.4;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tsky += vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n\tsky *= 0.9;\n\t//\n    if ( raymarch(ro, rd, dist, nor) )\n    {\n        vec3 pos = ro + dist*rd;\n\n\t\tcol = vec3(0.65, 1.0, 0.3);\n        \n        float ao = calcAO( pos, nor );\n\t\t//float ao = 1.;\n        \n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.20*amb*vec3(0.20,0.22,0.26)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.00*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(0.8)*vec3(1.00,0.70,0.60)*spe + 0.2*fre*(0.5+0.5*col);\n\t\tcol = mix( col, sky, 1.0-exp(-0.0025*dist*dist*dist) );\n\t}\n\telse\n\t{\n\t\tcol = sky;\n\t}\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n    voxelResolution = mix(0.05, 0.25, (sin(iTime * 0.25) * 0.5 + 0.5));\n    \n    float rotSpeed = iTime * 0.7;\n    \n    float camDist = exp(sin(iTime * -0.2) * 4.0 ) * 0.05 + KAIWARE_SIZE * 2.0;\n    //float camDist = 15.;\n    \n    // camera\n    //vec3 ro = vec3( 0., 0.75, -15. ) / voxelResolution;\n    //vec3 ro = vec3( 0., 0., 0. ) / voxelResolution;\n    vec3 ro = vec3(cos(rotSpeed) * camDist, sin(iTime * 0.5) * KAIWARE_SIZE, sin(rotSpeed) * camDist) / voxelResolution;\n    \n    // target\n\tvec3 ta = vec3(0., 0., 0.);\n\t//vec3 ta = ro + vec3(cos(rotSpeed) * camDist, sin(iTime * 0.5) * KAIWARE_SIZE * 10., sin(rotSpeed) * camDist) / voxelResolution;\n    \n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\tcol = sqrt(col);\n\t\n\tfragColor=vec4( clamp(col,0.,1.), 1.0 );\n}","name":"Image","description":"","type":"image"}]}