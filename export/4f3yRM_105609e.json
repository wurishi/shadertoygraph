{"ver":"0.1","info":{"id":"4f3yRM","date":"1730427714","viewed":354,"name":"csc attractor","username":"ChunderFPV","description":"Fun with cosecant waves.","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","wave","blur","trigonometry","cosmic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// blend\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 b = texture(iChannel0, U/iResolution.xy),\n         c = texture(iChannel1, U/iResolution.xy);\n    C = tanh(b + c*c);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define A(v) mat2(cos(m.v*3.1416 + vec4(0, -1.5708, 1.5708, 0)))  // rotate\n#define O(x,a,b) ((cos(x*6.2832)*.5+.5)*(a-b)+b)                  // oscillate x between a & b\n#define H(v) O(radians(vec3(-40, 30, 70))+v, 1., 0.)              // hue\n\n// hex coords (by Fabrice)\nvec2 hex(vec2 u)\n{\n    vec2 o = vec2(.5, .866),\n         a = mod(u,   o+o)-o,\n         b = mod(u-o, o+o)-o;\n    return dot(a,a) < dot(b,b) ? a : b;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float t = 1. + iTime/60.,\n          n = 4e2/6.2832,      // points per wavelength\n          f = O(t, 20., 25.),  // wave spacing\n          i = 0., d = i, s, b, k, w, j;\n    \n    vec2 R = iResolution.xy,\n         m = (iMouse.z > 0.) ? (iMouse.xy - R/2.)/R.y: vec2(0);\n    \n    vec3 u = normalize(vec3(U - R/2., R.y*.8)),\n         c = vec3(0), p, q;\n    \n    u.yz *= A(y);  // pitch\n    u.xz *= A(x);  // yaw\n    \n    for (; i++<75.;) // raymarch\n    {\n        p = u*d;\n        b = p.y/n/6.2832*3.;                         // color coords\n        p.y -= n*(t-.7);                             // move y with wave\n        j = sin(p.z/50. -t*50.);                     // tube movement\n        if (j < -.95) q = p, w = .1;                 // tubes\n        else   q = round(p), w = .0;                 // points\n        \n        p.xz -= 1./sin(q.y/n +t+vec2(0, 1.5708))*n;  // wave xz\n        //p.xz -= round(p.xz/f)*f;                   // square tile\n        p.xz = hex(p.xz/f)*f;                        // hex tile\n        s = length(p - q*vec3(0,1,0))-w;             // add to scene\n        \n        c += 2.*min(.01/s, exp(-s/.1))               // black & white\n           * O(b, 1.5, .2)                           // shade\n           * H(b*2.);                                // color\n        \n        if (s < 1e-3 || d > 1e3) break;              // limits\n        d += s*.3;  // small steps to reduce clipping\n    }\n    \n    C = vec4(min(c + c*c, 1.), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// radial blur\n// I'm getting some occasional flashes from the jitter.  Fix needed.\n\n// jitter method from https://www.shadertoy.com/view/MXlyW8\nfloat hash12(vec2 u)\n{\n\tvec3 p = fract(u.xyx*.1031);\n    p += dot(p, p.yzx+33.33);\n    return fract((p.x+p.y)*p.z);\n}\n\n#define H(a) (cos(radians(vec3(0, 60, 120))+(a)*6.2832)*.5+.5)  // hue\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float l = 15.,  // scale loop\n          s = 1.,   // step size\n          b = .3,   // brightness\n          a = .5,   // mipmap aa\n          j = hash12(U + iTime),  // jitter\n          i = 0., k = i, d;\n    \n    vec2 R = iResolution.xy,\n         m = (iMouse.z > 0.) ? 2.-iMouse.xy/R*3.: vec2(.5),\n         u = U/R, v;\n    \n    vec3 c = texture(iChannel0, u, a).rgb*.8;\n    \n    for (i; i<l; i++)\n        d = 1.-i/l,  // used for incremental darkening and color\n        c += b * texture(iChannel0, u-(u-m)*(k+j)/l, a).rgb * sqrt(d) * H(d),\n        k += s;\n    \n    v = fwidth(u)/abs(u-round(u));  // vignette\n    c -= max(v.x, v.y);  // darken screen edges\n    \n    C = vec4(max(c, 0.), 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// frame blur (TAA)\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float s = .8;  // blur strength\n    C = texture(iChannel1, U/iResolution.xy)*s\n      + texture(iChannel0, U/iResolution.xy)*(1.-s);\n}","name":"Buffer C","description":"","type":"buffer"}]}