{"ver":"0.1","info":{"id":"ddjfDR","date":"1689616273","viewed":108,"name":"Points and lines","username":"cosmo_brain","description":"there are points\nthere are lines\nit looks kinda cool","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["lines","points"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (3.1415926*2.)\n#define PI 3.1415926\n#define S(a, b, t) smoothstep(a, b, t)\n\nvec2 rotate(vec2 v, float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    mat2x2 rotation = mat2x2(c, s, -s, c);\n    return rotation*v;\n}\n\nfloat map(float v, float min1, float max1, float min2, float max2) {\n    return (v-min1)/(max1-min1) * (max2-min2) + min2;\n}\n\nfloat taperBox(vec2 uv, float bottomWidth, float topWidth, float height, float offset, float blur) {\n    float percentageUp = (uv.y+height/2.)/height;\n    float width = mix(bottomWidth, topWidth, percentageUp);\n    float currentOffset = mix(-offset/2., offset/2., percentageUp);\n    float leftRight = smoothstep(blur, -blur, abs(uv.x-currentOffset)-width/2.);\n    float topBottom = smoothstep(blur, -blur, abs(uv.y)-height/2.);\n    return leftRight*topBottom;\n}\n\nfloat circle(vec2 uv, float radius, float blur) {\n    return smoothstep(blur, -blur, length(uv)-radius);\n}\n\nfloat semicircle(vec2 uv, float radius, float blur) {\n    return S(-blur, blur, uv.y)*S(blur, -blur, length(uv)-radius);\n}\n\nfloat roundedRectangle(vec2 uv, float width, float thickness, float blur) {\n    float rectangle = taperBox(uv, width, width, thickness, 0.0, blur);\n    float right = circle(uv-vec2(width/2., 0.0), thickness/2., blur);\n    float left = circle(uv-vec2(-width/2., 0.0), thickness/2., blur);\n    return max(max(rectangle, right), left);\n}\n\nfloat rectangle(vec2 uv, float width, float thickness, float blur) {\n    return taperBox(uv, width, width, thickness, 0.0, blur);\n}\n\nvoid colour(inout vec3 col, vec3 colour, float influence) {\n    col = mix(col, colour, influence);\n}\n\nfloat ellipse(vec2 uv, float width, float height, float blur) {\n    return S(blur, -blur, length(vec2(uv.x/width, uv.y/height))-1.);\n}\n\nfloat outline(float influence, float blur) {\n    return map(abs(influence-.5), 0., .5, 1., 1.-1./blur);\n}\n\nfloat random(inout float seed) {\n    float result = abs(fract(sin(seed*2314.341239+2.1938)*12.1234920));\n    seed = abs(fract(sin(seed*293.1920304+102.392483)*295.123957));\n    return result;\n}\n\n// project-specific functions here\nfloat random2(vec2 seed) {\n    seed = fract(seed * vec2(233.34, 851.73));\n    seed += dot(seed, seed+23.45);\n    return fract(seed.x*seed.y);\n}\n\n// noramlised [-1, 1]-ish\nfloat randomPath(float t) {\n    return sin(t*12.1943)*.5 + sin(t*4.1938+1.234);\n}\n\nvec2 cellBall(vec2 id, float t) {\n    float seed = random2(id);\n    return vec2(randomPath(seed+random(seed)+t)*.35, randomPath(seed+random(seed)+t)*.35);\n    // return vec2(0.);\n}\n\nvec4 Layer(vec2 uv, float t, float fade, float blur) {\n    float strength = 0.;\n    vec3 col = vec3(0.);\n\n    float cellWidth = .1;\n    vec2 id = floor(uv/cellWidth) - .5;\n    vec2 inneruv = 2. * (fract(uv/cellWidth) - .5);\n    float seed = id.x*id.y;\n\n    vec2 centre = cellBall(id, t);\n    float ballGlow = circle(inneruv-centre, map(sin((t+random(seed))*45.3), -1., 1., .05, .2), blur*50.);\n    float ball = circle(inneruv-centre, .1, blur);\n    strength = max(strength, max(ball, ballGlow));\n    col = mix(col, vec3(1.), ballGlow);\n    col = mix(col, vec3(1.), ball);\n    \n    vec2 idOffsets[4];\n    idOffsets[0] = vec2( 0.,  1.);\n    idOffsets[1] = vec2( 1., -1.);\n    idOffsets[2] = vec2( 1.,  0.);\n    idOffsets[3] = vec2( 1.,  1.);\n    for (float cidy = id.y-1.; cidy <= id.y+1.; cidy += 1.) {\n        for (float cidx = id.x-1.; cidx <= id.x+1.; cidx += 1.) {\n            vec2 cid = vec2(cidx, cidy);\n            for (int i=0; i<4; i++) {\n                vec2 centre = (cid + cellBall(cid, t)/2. + .5 + .5)*cellWidth;\n                vec2 target = (cid+idOffsets[i] + cellBall(cid+idOffsets[i], t)/2. + .5 + .5)*cellWidth;\n                vec2 offset = target - centre;\n                float angle = atan(offset.y, offset.x);\n\n                float distance = length(offset);\n                float line = rectangle(rotate(uv-(target+centre)/2., -angle), distance, map(distance, 0., 0.05, 0.005, 0.0), blur);\n                strength = max(strength, line);\n                col = mix(col, vec3(245, 231, 37)/255., line);\n            }\n        }\n    }\n    \n    return vec4(col, strength*fade);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime*.1;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float blur = 0.001;\n    float outlineBlur = 1.;\n\n    vec3 col = vec3(0.);\n    \n    vec4 layer;\n    float seed = 0.;\n    for (float i=0.; i<1.; i += 1./3.) {\n        float progress = fract(t + i);\n        layer = Layer(rotate(uv, -t)*map(progress, 0., 1., 1., 1./4.) - vec2(random(seed)), t, 1. - 4. * (progress-.5)*(progress-.5), map(progress, 0., 1., blur, blur*20.));\n        col = mix(col, layer.rgb, layer.a);\n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}