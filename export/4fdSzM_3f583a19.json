{"ver":"0.1","info":{"id":"4fdSzM","date":"1713731888","viewed":104,"name":"Perlin noise cube","username":"grinova","description":"4D Perlin noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fragCoord       fragCoord\n#define t               iTime\n#define si              iResolution.xy\n\n#define POSITIV_COLOR   vec3(1.0, 0.0, 1.0)\n#define NEGATIVE_COLOR  vec3(0.0, 1.0, 1.0)\n\n#define START_OCTAVE    0\n#define END_OCTAVE      2\n\nvec2 map(vec3 p) {\n    float d = max(abs(p.x), max(abs(p.y), abs(p.z))) - 1.0;\n\n    float noise = 0.0;\n    if (d < 0.0) {\n        for (int i = START_OCTAVE; i <= END_OCTAVE; i++) {\n            float segments = float(1 << i);\n            float divider = float(1 << (i - START_OCTAVE));\n            float n = perlin_noise(vec4(p * segments, t * 0.5));\n            noise += n / divider;\n        }\n    }\n\n    return vec2(d, noise);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 g = fragCoord.xy;\n\n    float cd = 2.5;\n    vec3 ro = vec3(cd * cos(t * 0.5), 0, cd * sin(t * 0.5));\n    vec3 rov = normalize(-ro);\n    vec3 u =  normalize(cross(vec3(0, 1, 0), rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec2 uv = (g + g - si) / min(si.x, si.y);\n    vec3 rd = mat3(u, v, rov) * vec3(uv, 1.0);\n\n    float positive = 0.0;\n    float negative = 0.0;\n    float d = 0.;\n    float s = 1.;\n    for(int i=0; i < 400; i++) {\n        if (s < 0.01 || d > 80.) {\n            break;\n        }\n\n        vec2 m = map(ro + rd * d);\n\n        float dist = length(rd * d);\n        m.y *= 0.005 * dist;\n        positive += m.y * step(0.0, m.y);\n        negative += m.y * step(m.y, 0.0);\n\n        s = max(m.x, 0.02);\n\n        d += s * 0.5;\n   \t}\n\n    vec3 color = (\n        POSITIV_COLOR * positive -\n        NEGATIVE_COLOR * negative\n    ) * 4.0;\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 random4(vec4 p4) {\n    p4 = fract(p4 * vec4(443.897, 441.423, .0973, .1099));\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract( (p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfloat quintic(float v) {\n    return v * v * v * (v * (v * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlin_noise(vec4 p) {\n    vec4 i = floor(p);\n    vec4 f = fract(p);\n\n    float iz[2];\n    for (int n = 0; n < 2; n ++) {\n        float iy[2];\n        for (int m = 0; m < 2; m ++) {\n            float ix[2];\n            for (int k = 0; k < 2; k ++) {\n                float g[2];\n                for (int j = 0; j < 2; j ++) {\n                    vec4 r = random4(i + vec4(j, k, m, n)) * 2.0 - 1.0;\n                    g[j] = dot(normalize(r), f - vec4(j, k, m, n));\n                }\n                ix[k] = mix(g[0], g[1], quintic(f.x));\n            }\n            iy[m] = mix(ix[0], ix[1], quintic(f.y));\n        }\n        iz[n] = mix(iy[0], iy[1], quintic(f.z));\n    }\n    float iw = mix(iz[0], iz[1], quintic(f.w));\n\n    return iw;\n}\n","name":"Common","description":"","type":"common"}]}