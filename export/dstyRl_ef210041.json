{"ver":"0.1","info":{"id":"dstyRl","date":"1695370071","viewed":222,"name":"music visualization 3d_00","username":"bhxj","description":"一个球。\n\n感谢 pyBlob 的留言，非常有用的建议。","likes":10,"published":1,"flags":64,"usePreview":0,"tags":["3d","disco"],"hasliked":0,"parentid":"dtsBDl","parentname":"music visualization 3d_0"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4ddGD7","filepath":"https://soundcloud.com/virtual-riot/virtual-riot-did-i-mention-i","previewfilepath":"https://soundcloud.com/virtual-riot/virtual-riot-did-i-mention-i","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat texture_fftw(float uvx, float freq_step, float count)\n{\n    float freq = 0.0;\n    for (float offset = 0.0; offset < freq_step * (count + 0.1); offset += freq_step)\n    {\n        freq += texture(iChannel0, vec2(offset + uvx, 0.0)).r;\n    }\n    freq /= (count + 1.0);\n    freq = freq * freq;\n    return freq;\n}\n\nfloat texture_fftw2(float uvx, float freq_step, float count)\n{\n    float freq = 0.0;\n    for (float offset = 0.0; offset < freq_step * (count + 0.1); offset += freq_step)\n    {\n        freq += texture(iChannel0, vec2(fract(offset + uvx), 0.0)).r;\n    }\n    freq /= (count + 1.0);\n    freq = freq * freq;\n    return freq;\n}\nfloat texture_fftw3(float uvx, float freq_step, float count)\n{\n    float freq = 0.0;\n    float total = 0.0;\n    float mid_factor = count * 0.5;\n    for (float offset = 0.0; offset < freq_step * (count + 0.1); offset += freq_step)\n    {\n        float fatcor = mid_factor - abs(offset/freq_step - mid_factor) + 1.0;\n        //fatcor = pow(fatcor, 1.2);\n        freq += fatcor * texture(iChannel0, vec2(fract(offset + uvx), 0.0)).r;\n        total += fatcor;\n    }\n    freq /= total;\n    freq = freq * freq;\n    return freq;\n}\nfloat texture_fftw4(float uvx, float freq_step, float count)\n{\n    float freq = 0.0;\n    float total = 0.0;\n    float mid_factor = count * 0.5;\n    for (float offset = 0.0; offset < freq_step * (count + 0.1); offset += freq_step)\n    {\n        float fatcor = mid_factor - abs(offset/freq_step - mid_factor) + 1.0;\n        //fatcor = pow(fatcor, 1.2);\n        freq += fatcor * texture(iChannel0, vec2(fract(offset + uvx), 0.75)).r;\n        total += fatcor;\n    }\n    freq /= total;\n    freq = freq * freq;\n    return freq;\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat radius = 1.0;\nfloat sdf(vec3 p)\n{\n    float ret = sdSphere(p, radius);\n    return ret;\n}\n\n\nconst float EPSILON=.0001;\nfloat rayMarch(vec3 eye,vec3 ray,float end,int maxIter)\n{\n    float depth=0.;\n    for(int i=0;i<maxIter;i++)\n    {\n        vec3 pos = eye + depth*ray;\n        float dist = sdf(pos);\n        depth += dist;\n        if(dist < EPSILON || dist >= end)\n        {\n            break;\n        }\n    }\n    return depth;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float eps = 0.0001;\n    const vec3 h = vec3(eps,0.0,0.0);\n    return normalize(\n        vec3(sdf(p + h.xyy)-sdf(p - h.xyy),\n             sdf(p + h.yxy)-sdf(p - h.yxy),\n             sdf(p + h.yyx)-sdf(p - h.yyx)));\n}\n\nconst float PI = 3.141592653;\nconst float HPI = PI * 0.5;\nconst float DPI = PI * 2.0;\n\n//感谢 pyBlob\nvec2 xyz_to_gis(vec3 pos)\n{\n\tfloat lat = atan(pos.z, length(pos.xy));\n\tfloat lon = atan(pos.y, pos.x);\n\t\n\treturn vec2(lon, lat);\n}\n\nvec3 gis_to_xyz(vec2 pos)\n{\t\t\n\tfloat cos_lat = cos(pos.y);\n\tfloat rad_lon = pos.x;\n\treturn vec3(\n\t\tcos_lat * cos(rad_lon),\n\t\tcos_lat * sin(rad_lon),\n\t\tsin(pos.y));\n}\nvec3 rotate_X(vec3 pos, float rad)\n{\n\tfloat cos_v = cos(rad);\n\tfloat sin_v = sin(rad);\n\tmat3 rotateX = mat3(1.0, 0.0   , 0.0  ,\n\t                    0.0, cos_v , sin_v,\n\t                    0.0, -sin_v, cos_v );\n\treturn rotateX * pos;\n}\nvec3 rotate_Y(vec3 pos, float rad)\n{\n\tfloat cos_v = cos(rad);\n\tfloat sin_v = sin(rad);\n\tmat3 rotateY = mat3(cos_v, 0.0, -sin_v,\n\t                    0.0  , 1.0, 0.0   ,\n\t                    sin_v, 0.0, cos_v  );\n\treturn rotateY * pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    vec2 view_offset = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n    vec3 ray;\n    vec3 view_pos;\n    float near_dis = 3.5;\n    if(true)\n    {   \n        radius = 1.35;\n        float fov = (45.0 / 180.0) * PI;    \n        view_offset = view_offset * near_dis * tan(fov * 0.5);  \n        view_pos = vec3(0.0, 0.0, near_dis);  \n        ray = vec3(view_offset, 0.0) - view_pos;\n        ray = normalize(ray);\n    }\n    else\n    {\n        view_pos = vec3(view_offset, near_dis);  \n        ray = vec3(view_offset, 0.0) - view_pos;\n        ray = normalize(ray);\n    }\n    \n    //感谢 pyBlob\n    //暂时没看懂,相信总会懂的\n    if (iMouse.x > 0.)\n    {\n        vec4 v = abs(iMouse) - iResolution.xyxy / 2.;\n        // turn forward by v.xy (drag position), turn back by v.zw (click position)\n        mat2 R = mat2(v.x,v.y,-v.y,v.x) * mat2(v.z,-v.w,v.w,v.z) / length(v.xy) / length(v.zw);\n        view_pos.yz *= R;\n        ray.yz *= R;\n    }\n    \n    vec3 pos;\n    //vec3 normal;\n    float end = 20.0;\n    int   maxIter = 256;\n    float depth = rayMarch(view_pos,ray,end,maxIter);\n    bool hit = false;\n    if(depth < end)\n    {\n        pos = view_pos + depth * ray;\n        hit = true;\n        //normal = calcNormal(pos);\n        \n    } \n\n\n    vec3 xyx_pos = rotate_X(pos.xyz, HPI);\n\tvec2 gis_pos = xyz_to_gis(xyx_pos);\n\n\tfloat frame0 = 0.015;\n\tfloat frame1 = 0.135;\n    float frameN0 = 0.015;\n\tfloat frameN1 = 0.165;\n    \n\tvec2 grid;\n    vec2 gis_uv;\n    float fftw = 0.0;\n\tvec2 normaloffset;\n\tfloat rotate = 0.18 * iTime;\n\t\n\tvec3 V = -ray;\n\tvec3 RN;\n\tvec3 RBT;\n\tvec3 RT;\n    \n    float step_count = 64.0;\n    if(hit)\n\t{\n\t\tvec2 step_rad = vec2(DPI / step_count, DPI / step_count);\n\t\tvec2 gis = (gis_pos + vec2(rotate, 0.0)) / step_rad;\n\t\t\n\t\tfloat v_lon = fract(gis.x);\n\t\tgrid.x = smoothstep(frame0, frame1, v_lon) - smoothstep(1.0 - frame1, 1.0 - frame0, v_lon);\n\t\tfloat v_lat = fract(gis.y);\n\t\tgrid.y = smoothstep(frame0, frame1, v_lat) - smoothstep(1.0 - frame1, 1.0 - frame0, v_lat);\n\t\t\n\t\t\n\t\t\n\t\t//tbn\n\t\t{\n            vec2 gis_temp = (floor(gis) + vec2(0.5)) * step_rad;\n\t\t\tvec3 pos = gis_to_xyz(gis_temp - vec2(rotate, 0.0));\n\t\t\tpos = rotate_X(pos, -HPI);\n\t\t\tRN = normalize(pos);\n\t\t\t\n\t\t\tvec3 top_pos = gis_to_xyz(gis_temp - vec2(rotate, 0.029));\n\t\t\ttop_pos = rotate_X(top_pos, -HPI);\n\t\t\t\n\t\t\tRBT = normalize(top_pos - pos);\n\t\t\tRT = normalize( cross(RBT, RN) );\n\t\t\t\n\t\t}\n\t\t//normal offset\n\t\t{\n\t\t\t//left (-1.0, 0.0) \n\t\t\tfloat left = -1.0 + smoothstep(frameN0, frameN1, v_lon);\n\t\t\tleft *= max(sign( v_lon - frameN0 ), 0.0);\n\t\t\tleft *= max(sign( frameN1 - v_lon ), 0.0);\n\t\t\t//right (0.0, 1.0) \n\t\t\tfloat right = smoothstep(1.0 - frameN1, 1.0 - frameN0, v_lon);\n\t\t\tright *= max(sign( v_lon - (1.0 - frameN1) ), 0.0);\n\t\t\tright *= max(sign( (1.0 - frameN0) - v_lon), 0.0);\n\t\t\t\n\t\t\tnormaloffset.x = left + right;\n\t\t\t\n\t\t\t//bottom (-1.0, 0.0)\n\t\t\tfloat bottom = -1.0 + smoothstep(frameN0, frameN1, v_lat);\n\t\t\tbottom *= max(sign( v_lat - frameN0 ), 0.0);\n\t\t\tbottom *= max(sign( frameN1 - v_lat ), 0.0);\n\t\t\t//top  (0.0, 1.0) \n\t\t\tfloat top = smoothstep(1.0 - frameN1, 1.0 - frameN0, v_lat);\n\t\t\ttop *= max(sign( v_lat - (1.0 - frameN1) ), 0.0);\n\t\t\ttop *= max(sign( (1.0 - frameN0) - v_lat), 0.0);\n\t\t\t\n\t\t\tnormaloffset.y = bottom + top;\n\t\t}\n        //fftw\n        {\n            vec2 gis_temp = floor(gis) * step_rad;\n            gis_uv.x = fract((gis_temp.x + PI) / DPI) * 2.0;\n            gis_uv.x = fract(gis_uv.x);\n            //if(gis_uv.x > 1.0)\n            {\n                //gis_uv.x = 2.0 - gis_uv.x;\n            }\n            gis_uv.y = gis_temp.y / PI + 0.5;\n            //fftw = texture_fftw(gis_uv.x, 0.125 / (step_count * 0.5), 8.0);\n            \n            //fftw = texture_fftw3(gis_uv.x, 0.25 / (step_count * 0.5), 16.0);\n            fftw = texture_fftw4(gis_uv.x, 0.25 / (step_count * 0.5), 2.0);\n            \n            //fftw = 0.2 +  fftw * 0.6;\n        }\n\t}\n\tif(hit)\n\t{\n        /*\n        vec3 N = RN;\n        {\n            vec2 offset = 1.0 - 2.0 * (abs(normaloffset) - 0.5);\n            offset *= sign(normaloffset);\n            \n            N += (offset.x * RT + offset.y * RBT) * 0.09;\n            N = normalize(N);\n        }\n        vec3 R = reflect(-V, N);\n        */\n\t\tvec3 R = reflect(-V, normalize( RN + normaloffset.x * RT * 0.5 + normaloffset.y * RBT * 0.5) );\n\t\tvec3 color_ref_cube = texture(iChannel1, R).rgb;     \n\t\t//color_ref_cube *= texture(iChannel2, gis_uv).rgb;\n        color_ref_cube *= color_ref_cube;\n       \n        \n        color_ref_cube = pow(color_ref_cube, vec3(1.0, 2.0, 2.0));\n\t\tif(abs((0.3 +  fftw * 0.4) - gis_uv.y) + 0.001 < 1.0 / step_count)\n        {\n            if(true)\n            {\n                vec3 color0 = vec3(0.0, 0.5, 1.0);\n                vec3 color1 = vec3(0.0, 1.0, 1.0);\n                vec3 color2 = vec3(0.0, 1.0, 0.0);\n                vec3 color3 = vec3(1.0, 1.0, 0.0);\n                //vec3 color4 = vec3(1.0, 0.0, 0.0);\n                vec3 color4 = vec3(1.0, 0.5, 0.0);\n\n                vec3 color_led = color0 * (1.0 - smoothstep(0.0, 0.2, fftw));   \n                color_led +=     color1 * (smoothstep(0.0, 0.2, fftw) - smoothstep(0.2, 0.4, fftw));   \n                color_led +=     color2 * (smoothstep(0.2, 0.4, fftw) - smoothstep(0.4, 0.6, fftw));   \n                color_led +=     color3 * (smoothstep(0.4, 0.6, fftw) - smoothstep(0.6, 0.8, fftw));   \n                color_led +=     color4 * (smoothstep(0.6, 0.8, fftw));\n                //color_ref_cube = mix(color_ref_cube, color_led, grid.x * grid.y);\n                color_ref_cube = color_led;\n            }\n            else\n            {\n                //color_ref_cube = mix(color_ref_cube, vec3(0.3, 1.0, 0.0), grid.x * grid.y);\n                color_ref_cube = vec3(0.3, 1.0, 0.0);\n            }\n        }\t\n\t\t\n        \n        color_ref_cube *= grid.x;\n\t\tcolor_ref_cube *= grid.y;\n        \n\n\t\tcolor += color_ref_cube;\n        \n        color += 0.40 * vec3(abs(sin(iTime)),\n                             abs(sin(iTime + HPI)),\n                             abs(sin(iTime + PI))) * (1.0 - grid.x) * (1.0 - grid.y); \n\t}\n    else\n    {\n        color += texture(iChannel1, ray).rgb;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}