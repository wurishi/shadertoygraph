{"ver":"0.1","info":{"id":"XX2yRh","date":"1726942289","viewed":57,"name":"new Tower of Hanoi 02","username":"shadertoyjiang","description":"汉诺塔\nThe colors have no basis; they’re just randomly put together, yet somehow look a bit nice.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tower","gray","code","hanoi","nonrecursive"],"hasliked":0,"parentid":"l3Byzh","parentname":"Non-recursive Tower of Hanoi  01"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024-9-22\n// 无递归汉诺塔\n// https://zhuanlan.zhihu.com/p/36124395?utm_id=0\n\n\n// tower hight 2 <= N <= 30\n#define N 9\n// speed\n#define time       (iTime * 12.)\n// color debug\n#define CLR 225\n\n\n// Subscript conversion 2040  0129 定义未加括号\n#define idx(j, i)  ((j) * (N + 1) + (i)) \nconst int A = 0, B = 1, C = 2;\nint tower[3 * N + 3];\n\nfloat sdLine(vec2 a, vec2 b, vec2 p) {\n        b -= a;\n        p -= a;\n        return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\nvec3 color(int i) {\n        return fract(float(i + CLR) * vec3(34.5678, 56.6789, 78.7891));\n}\n// Gray code decoding, a time-consuming process\nint grayDecoding(int gry) {\n        int c = 0, dec = 0;\n        for (int i = N - 1; i >= 0; i--) {\n                c = c ^ (gry >> i & 1);\n                dec = dec + dec + c;\n        }\n        return dec;\n}\nvoid honoiTower(int stp) {\n        // STP determines the state of the Tower of Hanoi\n        // Here, there is actually no algorithm for solving the Tower of Hanoi; \n        // it is directly translated from Gray code. \n        // Each Gray code corresponds to a specific state of the Tower of Hanoi. \n        // The arrangement of Gray codes coincides with the sequence of moves in the Tower of Hanoi.\n        // gray encoding\n        stp = min(stp % ((1 << N) + 155), 1 << N); // 2119 可循环 time loops\n        //stp = min(stp  , 1<<N);                     // 2055 不循环 only do one round\n        int gry = stp ^ (stp >> 1);\n        // first, convert it to Gray code. Here, the goal is to find out which peg each of the N disks should be placed on, or to determine which disks are on a specific peg.\n        int who, head;\n        int buf[N + 1]; // 写成 buf[N];          \n        for (int i = N - 1; i >= 0; i--) {\n                int have = gry >> i & 1;\n                if (have > 0) {\n                        if (i == N - 1) {\n                                who = C;\n                        } else if (i == N - 2) {\n                                who = B;\n                        } else {\n                                int m = grayDecoding(head >> 1) % 3; // 计算量大，\n                                //who = 1+(m-1)*(((N +i+1)%2)*2-1);\n                                who = 1 + (m - 1) * (1 - ((N + i) % 2) * 2);\n                                if (who < 2) who = 1 - who;\n                        }\n                } else if (i == N - 1) {\n                        who = A;\n                }\n                \n                buf[i + 1] = who;\n                head = head * 2 + have;\n        }\n        // Place N disks from largest to smallest on each peg.\n        // Based on which disks are on which pegs, actually construct the Tower of Hanoi. Since the smaller disks are always on top, there is only one unique way to place them.\n        for (int i = N; i > 0; i--) {\n                who = buf[i]; \n                int p = ++tower[idx(who, 0)];\n                tower[idx(who, p)] = i;\n        }\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n        vec2 R = iResolution.xy,\n                u = float(N) * ((U + U - R) / R.y + vec2(0, .6)),\n                p = vec2(abs(u.x), u.y);\n        // Construct the Tower of Hanoi based on (a specific step)\n        honoiTower(int(iFrame));\n        // draw axis\n        O = vec4(.38);\n        float axis = (R.x / R.y) * float(N) * 0.6;\n        float d = sdLine(vec2(-1, 0), vec2(axis * 1.5, 0), p);\n        d = min(d, sdLine(vec2(0, 0), vec2(0, N) * 1.1, p));\n        d = min(d, sdLine(vec2(axis, 0), vec2(axis, float(N) * 1.1), p));\n        O -= 20. * exp(-20. * (d - .22));   \n        // draw plate\n        int iy = int(round(u.y));\n        int ix = int(round(u.x / axis)) + 1;\n        if (iy > 0 && iy <= N && ix > -1 && ix < 3) {\n                if (tower[idx(ix, 0)] >= iy) {\n                        int id = tower[idx(ix, iy)];\n                        vec2 f = u - vec2(ix - 1, iy) * vec2(axis, 1);\n                        float wd = mix(axis * .5 * .25, axis * .5 * .9, float(id) / float(N));\n                        d = length(max(abs(f) - vec2(wd, .2), 0.)) - .295;\n                        if (d < 0.) O.xyz = color(id) + length(f * .12) + sign(f.y) * f.y * f.y; // f.y;\n                }\n        }\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}