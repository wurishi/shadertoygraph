{"ver":"0.1","info":{"id":"MffyW2","date":"1721763537","viewed":117,"name":"Toasting Bread - hw9","username":"Morevita","description":"A Work-in-Progress Shader ï¼Œsimulates toasting bread.\n\nReference: \nhttps://iquilezles.org/articles/distfunctions/\nhttps://inspirnathan.com/posts/53-shadertoy-tutorial-part-7\nhttps://www.shadertoy.com/view/4djSRW\nhttps://pin.it/64zwCjxAZ. ","likes":20,"published":1,"flags":8,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***\n\nA Work-in-Progress Shader.\n\nThis shader simulates toasting bread, and the reference image can be found here:\nhttps://pin.it/64zwCjxAZ.\n\n(Possible) TODO List:\n\n- [DONE] The noise for the bread has not been fixed yet.\n- Toasting and smoke effects.\n- [DONE] More realistic speed animation (currently using the sin(iTime) function to simulate back-and-forth motion).\n- [DONE] The \"Ding~\" sound of the toast being done.\n\n***/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\n\nconst float PRECISION = 1e-4;\nconst float MAX_DIST = 100.0;\nconst float MIN_DIST = 0.0;\nconst float PI = 3.1415926;\n\n/////\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b + r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h)\n{\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat sdRoundedCylinderY(vec3 p, float ra, float rb, float h)\n{\n    vec2 d = vec2(length(p.xy) - 2.0 * ra + rb, abs(p.z) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\n/////\n\n\n\n/////\nstruct Material\n{\n    vec3 ambientColor;  // k_a * i_a\n    vec3 diffuseColor;  // k_d * i_d\n    vec3 specularColor; // k_s * i_s\n    float alpha;        // shininess\n};\n\nstruct Surface\n{\n    int id;   // id of object\n    float sd; // signed distance\n    Material mat;\n};\n\nvec3 rgb(float r, float g, float b)\n{\n    return vec3(r / 256., g / 256., b / 256.);\n}\n\nvec3 toastTime()\n{\n\n    float t = fract(iTime / 12.)* 80.;\n    vec3 state;\n    \n    if (t <= 10.) // button down\n    { \n        state = vec3(1.,1.- t/5.,0.);\n    }\n    else if (t > 10. && t < 40.) // toasting...\n    {\n        state = vec3(2., -1.,(t-10.)/30.);\n    }\n    else if (t >= 40. && t <= 44.)  // jump up!\n    {\n        state = vec3(3., -1. + 2.05* sin((t-40.)/3.*PI/2.) ,1.); \n    }\n    \n    else // finished\n    {\n        state = vec3(4., 1.,1.);\n    }\n    \n\n    return state; \n}\n\nMaterial whiteplastic()\n{\n    vec3 aCol = 0.6 * rgb(256., 210., 173.);\n    vec3 dCol = 0.7 * rgb(255., 231., 200.);\n    vec3 sCol = 0.4 * rgb(255., 231., 200.);\n    float a = 2.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial yellowplastic()\n{\n    vec3 aCol = 0.7 * rgb(251., 154., 50.);\n    vec3 dCol = 0.8 * rgb(251., 164., 50.);\n    vec3 sCol = 0.3 * rgb(251., 80., 80.);\n    float a = 8.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial innerbread()\n{\n    vec3 aCol = 0.6 * rgb(251., 220., 190.);\n    vec3 dCol = 0.6 * rgb(245., 245., 245.);\n    vec3 sCol = 0.3 * rgb(251., 200., 80.);\n    float a = 1.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial breadcrust()\n{\n    vec3 aCol = 0.6 * rgb(231., 134., 30.);\n    vec3 dCol = 0.6 * rgb(251., 164., 50.);\n    vec3 sCol = 0.3 * rgb(251., 80., 80.);\n    float a = 5.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p)\n{\n    vec3 aCol = rgb(170., 142., 118.);\n    // aCol += -0.45+ vec3(1. + 0.7 * mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n    vec3 dCol = vec3(0.3);\n    vec3 sCol = vec3(0);\n    float a = 1.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2)\n{\n    if (obj2.sd < obj1.sd)\n        return obj2;\n    return obj1;\n}\n\nSurface opSubtraction(Surface obj1, Surface obj2)\n{\n    if (obj1.sd > -obj2.sd)\n        return obj1;\n    return Surface(obj2.id, -obj2.sd, obj2.mat);\n}\n\nSurface opSmoothUnion(Surface obj1, Surface obj2, float k)\n{\n    float d1 = obj1.sd;\n    float d2 = obj2.sd;\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    float d3 = mix(d2, d1, h) - k * h * (1.0 - h);\n    return Surface(obj1.id, d3, obj1.mat);\n}\n\nSurface opSmoothSubtraction(Surface obj1, Surface obj2, float k)\n{\n    float d1 = obj1.sd;\n    float d2 = obj2.sd;\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    float d3 = mix(d1, -d2, h) + k * h * (1.0 - h);\n    return Surface(obj1.id, d3, obj1.mat);\n}\n\nSurface scene(vec3 p)\n{\n    \n    vec3 st = toastTime();\n    float pos = st.y;\n    float color = st.z;\n    \n    Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n\n    Surface sBotton = Surface(2, sdRoundedCylinderY(p - vec3(.5, -.2, 1.1), .1, 0.03, 0.045), yellowplastic());\n    Surface sBox = Surface(3, sdRoundBox(p - vec3(0, -0.05, 0), vec3(1.3, 0.85, 1.), 0.2), whiteplastic());\n\n    Surface co = opUnion(sFloor, sBotton); // closest object\n\n    Surface sSupport = Surface(4, sdRoundedCylinder(vec3(abs(p.x), p.y, abs(p.z)) - vec3(.9, -.9, .8), .05, 0.03, 0.045), yellowplastic());\n\n    Surface sSide = Surface(3, sdRoundBox(p - vec3(1.3, -0.05, 0), vec3(.4, 0.4, .15), 0.05), whiteplastic());\n    Surface sTop1 = Surface(3, sdRoundBox(vec3(p.x, p.y, abs(p.z)) - vec3(0, 0.3, .3), vec3(.8, .8, .15), 0.05), whiteplastic());\n\n    sBox = opSmoothSubtraction(sBox, sSide, 0.05);\n    sBox = opSmoothSubtraction(sBox, sTop1, 0.05);\n\n    Surface sSwitch = Surface(3, sdRoundBox(p - vec3(1.35, 0.35 * pos, 0), vec3(.1, .1, .3), 0.05), yellowplastic());\n\n    //\n\n    Surface sBread1 = Surface(5, sdRoundBox(vec3(p.x, p.y, abs(p.z)) - vec3(0, 0.7 + 0.7 * pos, 0.3), vec3(0.6, .7, 0.13), 0.1), innerbread());\n    Surface sBread2 = Surface(5, sdRoundBox(vec3(p.x, p.y, abs(p.z)) - vec3(0, 1.3 + 0.7 * pos, 0.3), vec3(0.8, 0.2, 0.1), 0.2), innerbread());\n    Surface sWhiteBread = opSmoothUnion(sBread1, sBread2, 0.4);\n\n    Surface sBread3 = Surface(5, sdRoundBox(vec3(p.x, p.y, abs(p.z)) - vec3(0, 0.7 + 0.7 * pos, 0.3), vec3(0.75, .8, 0.12), 0.2), breadcrust());\n    Surface sBread4 = Surface(5, sdRoundBox(vec3(p.x, p.y, abs(p.z)) - vec3(0, 1.35 + 0.7 * pos, 0.3), vec3(0.9, 0.3, 0.1), 0.3), breadcrust());\n    Surface sBreadCrust = opSmoothUnion(sBread3, sBread4, 0.37);\n\n    Surface sCut = Surface(5, sdBox(p - vec3(0, 0.6, 0.6), vec3(1, 3, 0.2)), innerbread());\n\n    sBreadCrust = opSmoothSubtraction(sBreadCrust, sWhiteBread, 0.05);\n    sWhiteBread = opSubtraction(sWhiteBread, sCut);\n\n    // Thanks to lz 's advice!\n    sWhiteBread.sd += 0.02 * clamp(1., 0., texture(iChannel0, 3.* vec2(p.x, p.y - 0.7*pos)).r);\n    sBreadCrust.sd += 0.01 * clamp(1., 0., texture(iChannel0, 2.* vec2(p.x, p.y - 0.7*pos)).r);\n    \n    sBreadCrust.mat.ambientColor =  0.6 * rgb(231., 134., 30.)-(0.5*color*rgb(121.,84.,30.));\n    \n    //sWhiteBread.sd += 0.02 * clamp(1., 0., texture(iChannel0, p.xy * 3.).r);\n    //sBreadCrust.sd += 0.01 * clamp(1., 0., texture(iChannel0, p.xy * 2.).r);\n\n    //\n\n    co = opUnion(co, sBox);\n    co = opUnion(co, sSupport);\n    co = opUnion(co, sSwitch);\n\n    co = opUnion(co, sWhiteBread);\n    co = opUnion(co, sBreadCrust);\n   \n\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd)\n{\n    float depth = MIN_DIST;\n    Surface co;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        co = scene(p);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > MAX_DIST)\n            break;\n    }\n\n    co.sd = depth;\n\n    return co;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * scene(p + e.xyy).sd +\n        e.yyx * scene(p + e.yyx).sd +\n        e.yxy * scene(p + e.yxy).sd +\n        e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint)\n{\n    vec3 cd = normalize(lookAtPoint - cameraPos);  // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr));            // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat)\n{\n    // ambient\n    vec3 ambient = mat.ambientColor;\n\n    // diffuse\n    float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n    vec3 diffuse = mat.diffuseColor * dotLN;\n\n    // specular\n    float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n    vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n    return ambient + diffuse + specular;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n    float res = 1.0;\n    float t = mint;\n\n    for (int i = 0; i < 16; i++)\n    {\n        float h = scene(ro + rd * t).sd;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = rgb(120., 104., 91.);\n    vec3 col = vec3(0);\n\n    vec3 lp = vec3(-1, 0, -1); // lookat point (aka camera target)\n    vec3 ro = vec3(3, 2, 5);\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n    Surface co = rayMarch(ro, rd); // closest object\n\n    if (co.sd > MAX_DIST)\n    {\n        col = backgroundColor;\n    }\n    else\n    {\n        vec3 p = ro + rd * co.sd;    // point on surface found by ray marching\n        vec3 normal = calcNormal(p); // surface normal\n\n        // light #1\n        vec3 lightPosition1 = vec3(-4, 7, 6);\n        vec3 lightDirection1 = normalize(lightPosition1 - p);\n        float lightIntensity1 = 0.65;\n\n        // light #2\n        vec3 lightPosition2 = vec3(4, 2, 1);\n        vec3 lightDirection2 = normalize(lightPosition2 - p);\n        float lightIntensity2 = 0.3;\n\n        // final color of object\n        col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat);\n        col += lightIntensity2 * phong(lightDirection2, normal, rd, co.mat);\n\n        if (co.sd < 0.5 * MAX_DIST)\n        {\n            float dif = clamp(dot(normal, lightDirection1), -1., 1.);\n            float softshadow = clamp(softShadow(p, lightDirection1, 100. * PRECISION, length(p - lightPosition1)), -1., 1.);\n            col += -0.1 + 0.2 * dif * softshadow;\n        }\n\n        col = mix(col, backgroundColor, 1.0 - exp(-0.0003 * co.sd * co.sd * co.sd));\n        \n    }\n    col += 0.1 * mix(rgb(136., 90., 60.), rgb(120., 120., 0.), uv.y);\n    \n\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//noise ref: https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 8.0\n\nvec2 mainSound( int samp, float time )\n{\n    float frequency = 4250.0;  \n    float duration = 0.5;      \n    float amplitude = 2.;  \n    float t = mod(time, duration);\n    \n    float wave = 0.0;\n    \n    if (mod(time,12.)>6. && mod(time,12.)< 6.5) {\n        wave = amplitude * sin(2. * 3.14159265359 * frequency * t);\n\n        // Exponential decay envelope\n        float envelope = exp(-10.0 * t);\n        wave *= envelope;\n        return vec2( wave, 1.0);;\n    }\n    \n    \n    if (mod(time,12.)>3. && mod(time,12.)< 5.9){\n    vec2 audio = vec2(0.0);\n    for (float v = 0.0; v < ITERATIONS; v++)\n    {\n\t\taudio += hash22(iSampleRate * vec2(time + v, time*1.423 + v)) * 2.0 - 1.0;\n    }\n    audio /= float(ITERATIONS);\n    \n    vec2 noise = audio*.2 * smoothstep(0.0, 2.0, time) * smoothstep(60.0, 50.0, time)* ((mod(time,12.)-3.)/6.);\n\n    return noise;\n    }\n    \n    \n    return vec2(0.);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"//noise ref: https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"}]}