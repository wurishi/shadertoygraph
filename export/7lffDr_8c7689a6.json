{"ver":"0.1","info":{"id":"7lffDr","date":"1650724149","viewed":290,"name":"Blending Geometry","username":"Rrrrichard","description":"Happy to see how it is finally presented!\n\nWritten by Rrrrichard(Zhehao Li) in a \"2-hour shader challenge\" with roommates on 2022/04/23 ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blend","smoothmin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ==========================================================\n// Written by Rrrrichard(Zhehao Li) \n// in a \"2-hour shader challenge\" with roommates on 2022/04/23 \n// \n// Copyright Zhehao Li, 2022 \n// You cannot use this work in any commercial product, \n// website or project. You cannot sell this Work \n// and you cannot mint NFTs of it.\n// \n// ==========================================================\n\n#define MAX_STEPS 100\n#define MAX_DIST 100. \n#define EPS .001\nvec3 rotate(vec3 v, float a, float b, float c)\n{\n    //rotational matrix from wikipedia\n    vec3 new_v = vec3(\n        cos(b)*cos(c)*v.x \n            + (sin(a)*sin(b)*cos(c) - cos(a)*sin(c))*v.y \n            + (cos(a)*sin(b)*cos(c) + sin(a)*sin(c))*v.z,\n            \n        cos(b)*sin(c)*v.x \n            + (sin(a)*sin(b)*sin(c) + cos(a)*cos(c))*v.y \n            + (cos(a)*sin(b)*sin(c) - sin(a)*cos(c))*v.z,\n            \n        -sin(b)*v.x + sin(a)*cos(b)*v.y + cos(a)*cos(b)*v.z\n    );\n    return new_v; \n}\n\nfloat smoothMin(float dstA, float dstB, float k)\n{\n    // Key to blend sdf of geometry \n    float h = max(k - abs(dstA - dstB), 0.) / k; \n    return min(dstA, dstB) - h*h*h*k * 1. / 6.0; \n}\n\nfloat sphereDist(vec3 point, vec4 sphere)\n{\n    float sphere_dist = length(point - sphere.xyz)-sphere.w;\n    return sphere_dist;\n}\n\nfloat cubeDist(vec3 eye, vec3 centre, vec3 size)\n{\n    eye = rotate(eye, 0., 0.3*sin(iTime), 0.5*cos(iTime));\n    vec3 o = abs(eye-centre) -size;\n    float ud = length(max(o,0.));\n    float n = max(max(min(o.x,0.),min(o.y,0.)), min(o.z,0.));\n    return ud+n;\n}\n\nfloat torusDist(vec3 eye, vec3 centre, float r1, float r2)\n{   \n    eye = rotate(eye, 0.2*sin(iTime), 0.02, 0.3*cos(iTime));\n    vec2 q = vec2( length( (eye-centre).xz )-r1, eye.y-centre.y);\n    return length(q)-r2;\n}\n\n\nfloat GetSceneDistance(vec3 point, out int obj)\n{\n    vec4 sphere = vec4(0.+sin(iTime), 1.+sin(0.5*iTime), 6.+3.*cos(iTime), 0.4+0.2*clamp(cos(0.2*iTime), 0., 1.)); // (xyz, radius)\n    vec4 sphere2 = vec4(0.+2.5*cos(iTime), 1.+0.5*sin(0.5*iTime), 6.+2.*sin(iTime), 0.5+0.2*clamp(sin(0.2*iTime), 0., 1.)); // (xyz, radius)\n    vec3 cube_centre = vec3(0.+2.*sin(iTime),1.+sin(iTime),10.+ 2. * sin(iTime));\n    vec3 cube_size = vec3(1, 1,1);    \n    vec3 torus_centre = vec3(1.+0.2*cos(iTime), 0.7+ 0.2*sin(iTime), 7.+sin(iTime)); \n    float torus_r1 = 0.5;\n    float torus_r2 = 0.2; \n\n    float sphere_dist = sphereDist(point, sphere);\n    float sphere2_dist = sphereDist(point, sphere2);\n    float cube_dist = cubeDist(point, cube_centre, cube_size);\n    float torus_dist = torusDist(point, torus_centre, torus_r1, torus_r2);\n    //float torus2_dist = torusDist(point, torus2_centre, 0.5, 0.2, 3.);\n\n    //float cube2_dist = cubeDist(point, cube_centre+ 5.* cos(0.2 * iTime)*sin(0.1*iTime), 0.5 * cube_size);\n    \n    float plane_dist = abs(point.y + 1.); \n    //float plane2_dist = abs(point.x -50.); \n    //float plane3_dist = abs(point.x + 50.); \n    \n    float k = 2.; \n    float d = \n        //smoothMin(\n        smoothMin(\n        smoothMin(\n        smoothMin(\n           smoothMin(sphere_dist, plane_dist,k), \n           sphere2_dist, k),\n            cube_dist, k),\n           torus_dist,k);\n           //torus2_dist,k);\n    \n    // Here, Check which obj the ray marches to. \n    float eps = 0.55;\n    if( abs(sphere_dist - d) < eps)\n        obj = 1;\n    else if ( abs(sphere2_dist - d) < eps)\n        obj = 2;\n    else if ( abs(cube_dist - d) < eps)\n        obj = 3;\n    else if(abs(torus_dist - d) < eps)\n        obj = 4;\n    else \n        obj = 0;\n    return d; \n}\n\nfloat RayMarch(vec3 ray_origin, vec3 ray_dir, out int obj)\n{\n    float d = 0.; \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + ray_dir * d;\n        float ds = GetSceneDistance(p, obj); \n        d += ds; \n        if(d > MAX_DIST || ds < EPS) \n            break;  // hit object or out of scene\n    }\n    return d; \n}\n\nvec3 GetNormal(vec3 point)\n {\n    int obj;\n    float d = GetSceneDistance(point, obj); \n    vec2 e = vec2(0.001, 0); \n    vec3 n = d - vec3(\n        GetSceneDistance(point - e.xyy, obj),\n        GetSceneDistance(point - e.yxy, obj),\n        GetSceneDistance(point - e.yyx, obj)\n    );\n    \n    return normalize(n); \n}\n\nfloat GetLight(vec3 point)\n{    \n    vec3 light_pos = vec3(2, 6, 5); \n    light_pos += vec3(sin(iTime), 0, cos(iTime));\n    vec3 to_light = normalize(light_pos - point); \n    vec3 normal = GetNormal(point); \n    \n    float intensity = 0.6;\n    float light = intensity * clamp(dot(to_light, normal), 0., 1.); \n    \n    int obj;\n    float d = RayMarch(point+normal*2.*EPS, to_light, obj);\n    \n    if (d < length(light_pos - point))\n        light *= 0.3;\n    \n    return light;\n}\n\nvec3 getColor(vec2 uv, vec3 ray_origin)\n{\n    int obj;\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1.));\n    float d = RayMarch(ray_origin, ray_dir, obj);\n    \n    vec3 point = ray_origin + d * ray_dir;\n       \n    float diffuse_light = GetLight(point); \n    \n    vec3 col = vec3(diffuse_light);\n    \n    // Decide color based on type of object. \n    if(obj == 0) // ground and background\n        col += 0.2 + 0.3*cos(iTime+uv.xyx+vec3(0,2,4));\n       // col += 0.7* vec3(1.+0.1*sin(iTime), 0.6+ 0.05*cos(iTime), 1.+0.01*cos(iTime));\n    else if(obj == 1) // sphere\n        col += vec3(0.1, 0.4, 0);\n    else if(obj == 2) // sphere 2\n        col += vec3(0, 0.3, 0.5);\n    else if(obj == 3) // cube \n        col += vec3(0.8, 0.4, 0);\n    //else if(obj == 4) // torus\n    else\n        col += vec3(0.7, 0, 0.3);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.x;\n\n    // Time varying pixel color\n    vec3 ray_origin = vec3(0, 1, -2);\n   \n    vec3 col = getColor(uv, ray_origin);\n    //vec3 col2 = getColor(vec2(uv.x,uv.y+1.), ray_origin);\n    //vec3 col3 = getColor(vec2(uv.x+1.,uv.y), ray_origin);\n    //vec3 col4 = getColor(vec2(uv.x-0.5,uv.y), ray_origin);\n    //vec3 col5 = getColor(vec2(uv.x,uv.y-0.5), ray_origin);\n   \n    //vec3 col = (col1 + col2 + col3 + col4 + col5) / 5.0;\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}