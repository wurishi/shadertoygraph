{"ver":"0.1","info":{"id":"4cXSz8","date":"1725554917","viewed":61,"name":"魔方Rubik's cube","username":"shadertoyjiang","description":"Rubik's cube \n魔方Rubik's 2： https://www.shadertoy.com/view/XfXXRH","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["cube","rubiks"],"hasliked":0,"parentid":"ctKBRz","parentname":"白框  478c"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024年1月10日  \n// 魔方Rubik's 2： https://www.shadertoy.com/view/XfXXRH\n\n#define N normalize\n\n#define M(g, a) p.g*=mat2(cos(a+vec4(0,11,33,0)));\n\n//float d,h=1e5,i,j;\nvec4 clr;\n\n/*float m(vec3 p)\n{       \n        //return length(c)-1.;\n        \n        \n        float j,h=1e5;//, t =iTime;\n\n        //M(xy,.3)\n\n        M(yz,iTime)\n \n        M(xz,.6)\n        \n        /*\n                                              \n        clr=vec4(1.3);\n        \n        vec3 q=p,o=abs(p),w=p;\n        \n        float c=max(o.x,max(o.y,o.z));\n        \n        q=sign(q);\n        q*=1.-sign(abs(o-c));\n        \n        \n        \n        float d3 = length(p)-1.45;\n        \n        \n\n        p = abs(p);\n\n        vec3 r = round(p-max(p-1.,0.));\n        \n        \n        // 27 个小方体距离\n        float d1 = length(max(abs(p-r)-.35, 0.))-.15;\n        \n        w = w - r*sign(w) - q * .2  ;\n        \n        float d2=length(max(abs(w)-.3, 0.))-.05;\n        \n        \n        if(d2<d1)clr.rgb=q*.5+.5;\n        \n        \n        \n        \n        \n        return min(min(d1,d2),d3);\n        \n        * /\n        \n        \n        vec3 o = abs(p), q , i;\n\n\n\n        float d1,d2,d3, c;\n\n\n\n        // 中心球，防止光线对穿\n\n        d1 = length(p)-1.45; \n\n\n\n        // 魔方体\n\n        i = round(o - max(o-1., 0.)) * sign(p);\n\n        d2 = length(max(abs(p-i)-.4, 0.))-.1;\n\n        \n\n        \n\n        // o 与最靠近p中最长分量的坐标轴 共线。\n\n        c = max(o.x,max(o.y,o.z));\n\n        q = sign(p) * (1. - sign(abs( o - c )));\n\n        \n\n        // 色斑块\n\n        o = p - i - q * .15;\n\n        d3 = length(max(abs(o)-.35, 0.)) - .05;\n\n\n\n        // 颜色\n\n        clr = d3 < d2 \n\n            ? vec4(q*.5+.5,1)\n\n            : vec4(1.3)\n\n            ;\n\n        \n\n        return min(d1,min(d2,d3));\n\n}*/\n\n\nfloat m(vec3 p)//rubiks(vec3 p)\n{\n        // 按 yz 面旋转 alp 角度\n        float alp = iTime;\n        p.yz = p.yz * mat2(cos(alp), -sin(alp), sin(alp), cos(alp));\n        // 按 y 轴旋转 0.6 弧度\n        alp = 0.6;\n        p.xz = p.xz * mat2(cos(alp), -sin(alp), sin(alp), cos(alp));\n        \n        // 第一个物体距离(d1)：一个半径1.45 的球，我自己用来加在魔方中间好看点。\n        float d1 = length(p)-1.45;\n        \n        // 画第二个物体魔方的距离(d2)\n        \n        // 折叠到第一象限\n        vec3 absp = abs(p);\n        \n        // 这里取决于魔方大小，只是用来求中心cent，中间量，没啥特别意思。\n        vec3 diff = absp - max(absp - 1., 0.);\n        // 用取整函数 round() 来让算中心，在魔方（各分量）内部时，实际求中心，可能是 0或1 (0< absp -0 < 1)， 而在外部时，中心统一为1 ：( absp - (absp - 1) = 1 )\n        vec3 cent = round( diff ); \n        // 因为是用折叠来求的，cent 在第一象限，现在加上符号，指出它实际在八个象限的哪一个\n        cent = cent * sign(p);   \n        \n        // 减去最近的中心，因为这个最近，其它的不用算了。\n        vec3 diff2 = p - cent;\n        \n        // 得出魔方体的距离 d2， 这是求长方体距离的公式，iq 的博客里有。 0.4+0.1 = 0.5 我分成两个，0.4 用来计算方体，好让剩下的 0.1生成圆角。\n        // 为了方体，我假定小方块的大小是1 , 比如某一个小方块的x坐标是 -0.5 到 0.5 它的中心是 0，另一个小方块占的位置是 0.5到1.5，它的中心是 1.\n        float d2 = length(max(abs(diff2)-.4,0.))-.1;\n        \n        // 现在求每个小方体表面的颜色，我用小方块来让着色区域凸起，好看一点.\n        // 小方块的凸出方向应该在“长的分量轴”方向。所以现在找那个最长的分量\n        float lng = max(absp.x, max(absp.y, absp.z));\n        \n        // 这个的意思是使最长的分量变为 0, 其它两个分量变为不是0的数\n        vec3 diff3 = absp - lng;\n        \n        // 这句的意思是将上面一句 0 变为1 ，非0则变为 0,   也就是现在只有最长轴有值。 我用了abs()\n        vec3 ofs = 1. - sign(abs(diff3));\n        \n        // 上面三句可以这样代替： \n        // ofs = step(absp.yzx, absp)*step(absp.zxy, absp);\n        \n        // 添上符号，以x 方向来说，不是两个都向右偏， 一个要向右偏，一个要向左偏，方向不同，所以要加符号。\n        ofs = ofs * sign(p);\n        \n        // 实际上跟重做魔方的小方块一样，只不过是加上了一个偏移 ofs 使它突出表面。\n        vec3 diff4 = p - cent - ofs*.15;  // = diff2 - ofs\n\n        // 又是画一个方块\n        float d3 = length(max(abs(diff4)-0.35, 0.))-0.05;\n        \n        // 判断颜色，因为光子最终会落在最近的物体上，所以哪个距离小用哪个的颜色\n        if(d3<d2) clr = vec4(ofs*.5+.5,1);\n        else      clr = vec4(1.3);\n        \n        return min(d1, min(d2, d3));\n}\n\n\n\n\n\n\nvoid mainImage(out vec4 O,vec2 v)\n{               \n        vec2 R = iResolution.xy,\n\n             u = (v+v-R) / R.y ;\n\n        vec3 r = N(vec3(u, 3)), o, e, n,sun=vec3(-.5,.8,-.4);  //N() -3\n\n        float i,d;\n       \n        o.z=-8.;\n                \n        for( e.y=d=.001 ;i++< 2e2   && d>=e.y ;) // and (t+=d)<20.\n        \n               d = m(o+=r*d*.5);\n\n        n= N(vec3(m(o+e.yxx),m(o+e),m(o+e.xxy))-d);\n\n        //O = O*0.+ .6+.3*dot(n,sun);\n                                                                                                                               \n\n       \n       \n       \n       //\n       float dt = dot(normalize(sun),normalize(n) );\n       \n       O *=0.;\n       if(i<=2e2)\n       {\n            O = clr * (+.18 * max(0., dt) + .5);\n\n            O += pow(max(0., dt), 200.) * .8;\n       }\n}\n       \n       \n       \n       \n       \n       \n","name":"Image","description":"","type":"image"}]}