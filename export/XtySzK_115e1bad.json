{"ver":"0.1","info":{"id":"XtySzK","date":"1484875278","viewed":524,"name":"myFirstWaterShader","username":"lovelyH","description":"I finally made shader witch more or less look like a water.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sea","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// uncoment for height quality\n//#define HQ\n\n/// epsilon\n#define E 0.001\n\n\n\n/// rotate point p around OX\nvec3 rotRX( vec3 p, float l ){\n\tfloat sl= sin(l), cl= cos(l);\n\treturn vec3(\n\t\tp.x,\n\t\tcl*p.y-sl*p.z,\n\t\tsl*p.y+cl*p.z\n\t);\n}\n\n\n\n/// height map\nfloat mapH(vec2 p){\n\tfloat r= 0.0;\n\n\tfloat h= 0.5;\n\tfloat ph= 0.5;\n\tbool am0=true;\n\n#ifdef HQ\n\tfor( int a=0;a<9;a++)\n#else\n\tfor( int a=0;a<7;a++)\n#endif\n\t{\n\t\tvec2 p2= p;\n\t\tif(!am0){\n\t\t\tp2.x= p.y;\n\t\t\tp2.y= p.x;\n\t\t}\n\t\tp2*=ph;\n\n\t\t/// wave argument\n\t\tfloat v= p2.x;\n\t\tv= p2.y + sin(p2.x) + iTime;\n\n\t\t/// wave 0.0 to 1.0\n\t\tv= sin(v) * (0.75 - 0.25*sin(2.0*v));\n\t\tv= 0.5*v -0.5;\n\t\tv= v*v;\n\t\t\n\t\t/// add to final\n\t\tr += h*v;\n\n\t\t/// change scalars\n\t\th *= 0.44;\n\t\tph *= 2.0;\n\n\t\t/// a%2\n\t\tam0 = !am0;\n\t}\n\n\t/// return final value\n\treturn r;\n}\n\n\n\n/// position of the sun (witch look like a moon, fine with me)\nconst vec3 sunPos= vec3(5, 40, 50 );\n\n\n\n/// sky color basing on direction ray\nvec3 getSkyColor(vec3 dir){\n\treturn mix(\n\t\tvec3(0.01,0.01,0.13),\n\t\tvec3(0.5,0.5,0.5),\n\t\tclamp(2.0*dir.z,0.0,1.0)\n\t);\n}\n\n\n\n/// render by throwing ray from sp point in dir direction\nvec3 render(vec3 sp, vec3 dir){\n\n\t/// search hit point p2\n\t/// v2 = distance from camera\n\t/// h2 = height of water in hit point\n\tfloat v1,v2,v3;\n\tv1= 0.0;\n\tv3= 100.0;\n\tv2= (v1+v2)/2.0;\n\tfloat h1,h2,h3;\n\tvec3 p1,p2,p3;\n\th1= mapH( (p1=sp+v1*dir).xy );\n\tif( !( h1 <= p1.z ) ){\n\t\treturn vec3(1,0,0);\n\t}\n\th3= mapH( (p3=sp+v3*dir).xy );\n\tif( !( p3.z <= h3 ) ){\n\t\treturn getSkyColor(dir);\n\t}\n\tfor( int a=0;a<0x200;a++){\n\t\tv2= 0.05*v1+0.95*v3;\n\t\tp2= sp+v2*dir;\n\t\th2= mapH(p2.xy);\n\t\tif( h2 < p2.z ){\n\t\t\tv1= v2;\n\t\t}else{\n\t\t\tv3= v2;\n\t\t}\n\t}\n\n\t/// normal\n\tvec3 nor= normalize( vec3(\n\t\t(h2-mapH(p2.xy + vec2(E,0) )),\n\t\t(h2-mapH(p2.xy + vec2(0,E) )),\n\t\tE\n\t) );\n\n\t/// sun reflect\n\tvec3 sunDir= normalize( sunPos - p2 );\n\tfloat sunRef= clamp( dot( nor, reflect(sunDir,-dir) ), 0.0, 1.0 );\n\tsunRef= 1.0+2.0*pow( sunRef, 1024.0 );\n\n\t/// final color\n\treturn \n\t\tmix(\n\t\t\t/// see color\n\t\t\tvec3(.1,clamp(0.25+0.5*h2,0.0,1.0),0.99)\n\t\t\t* (0.5+0.5*dot( -dir, nor ))\n\t\t\t* (0.5+0.5*dot( vec3(0,0,1), nor ))\n\t\t\t* sunRef\n\t\t,\n\t\t\t/// sky color\n\t\t\tgetSkyColor(dir)\n\t\t,\n\t\t\t/// fog\n\t\t\t0.0\n\t\t\t+clamp((v2-20.0)/80.0,0.0,1.0)\n\t\t)\n\t;\n}\n\n\n\n/// main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 sp= vec3( 0.0, 0.0, 2.0 );\n\tvec3 dir= normalize( vec3( uv.x, 4.0, uv.y ) );\n\tdir= rotRX( dir, -0.05*3.1415 );\n\n\tfragColor = vec4( render(sp,dir), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}