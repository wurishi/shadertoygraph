{"ver":"0.1","info":{"id":"MfjSzK","date":"1706834573","viewed":83,"name":"interactive 2D simplex noise","username":"IlyaBelyy","description":"An interactive experiment how does choice of gradients affect simplex noise.\n\nUse mouse to set gradients.\nSee keyboard commands in the comments\n\nSame for perlin https://www.shadertoy.com/view/MfBSzG","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["2d","noise","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nUse mouse to adjust gradient vectros\n\nKeyboard:\n    r - reset all gradients to random\n    n - toggle gradient normalisation\n    q - toggle gradient snapping to main directions\n    0 - diplay zero isoline\n    g - display grid\n*/\n\nfloat arrow(vec2 from, vec2 dir, vec2 p)\n{\n    if (dot(p - from, dir) < 0.0) return 0.0;\n    if (2.0 * length(p - from) > length(dir)) return 0.0;\n\n    vec2 tangent = normalize(vec2(-dir.y, dir.x));\n    return smoothstep(2.0 * fwidth(p.x), 0.0, abs(dot(p - from, tangent)));\n}\n\nvec2 load_gradient(vec2 p, bool norm_mode, bool snap_mode)\n{\n    vec2 grad = texelFetch(iChannel0, ivec2(p), 0).xy;\n\n    if (snap_mode) {\n#if 1 // snap to 8 directions\n        if (norm_mode) return normalize(round(normalize(grad)));\n        return length(grad) * normalize(round(normalize(grad)));\n#else // snap to 4 directions\n        if (abs(grad.x) < abs(grad.y)) grad.x = 0.0;\n        else grad.y = 0.0;\n#endif\n    }\n\n    return norm_mode ? normalize(grad) : grad;\n}\n\nfloat weight_gradient(vec2 g, vec2 xy)\n{\n    float t = 0.5 - dot(xy, xy);\n    if (t <= 0.0) return 0.0;\n    t *= t;\n    return t * t * dot(g, xy);\n}\n\n// https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/simplexnoise.pdf\nfloat simplex(vec2 p, bool norm_mode, bool snap_mode)\n{\n    // Skew the input space to determine which simplex cell we're in\n    float s = (p.x + p.y) * F2;\n    vec2 ij = floor(p + s);\n\n    float t = (ij.x + ij.y) * G2;\n    // Unskew the cell origin back to (x,y) space\n    // The x,y distances from the cell origin\n    vec2 xy0 = p - (ij - t);\n\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    // Offsets for second (middle) corner of simplex in (i,j) coords\n    vec2 ij1 = (xy0.x > xy0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Offsets for middle corner in (x,y) unskewed coords\n    vec2 xy1 = xy0 - ij1 + G2;\n    // Offsets for last corner in (x,y) unskewed coords\n    vec2 xy2 = xy0 - 1.0 + 2.0 * G2;\n\n    vec2 g0 = load_gradient(ij, norm_mode, snap_mode);\n    vec2 g1 = load_gradient(ij + ij1, norm_mode, snap_mode);\n    vec2 g2 = load_gradient(ij + vec2(1.0, 1.0), norm_mode, snap_mode);\n\n    // Calculate the contribution from the three corners\n    float n0 = weight_gradient(g0, xy0);\n    float n1 = weight_gradient(g1, xy1);\n    float n2 = weight_gradient(g2, xy2);\n    return 70.0 * (n0 + n1 + n2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = screen_to_pos(fragCoord, iResolution);\n    bool norm_mode = texelFetch(iChannel1, ivec2(78,2), 0).x == 0.0;\n    bool snap_mode = texelFetch(iChannel1, ivec2(81,2), 0).x != 0.0;\n\n    float n = simplex(p, norm_mode, snap_mode);\n    fragColor.rgb = vec3(0.5 * n + 0.5);\n\n    // highlight zero value\n    if (texelFetch(iChannel1, ivec2(48,2), 0).x == 0.0) {\n        fragColor.rgb += vec3(smoothstep(fwidth(n), 0.0, abs(n)));\n        //fragColor.g += smoothstep(fwidth(n), 0.0, abs(n - 0.25));        \n        //fragColor.b += smoothstep(fwidth(n), 0.0, abs(n + 0.25));\n    }\n    \n    float s = (p.x + p.y) * F2;\n\n    // grid\n    if (texelFetch(iChannel1, ivec2(71,2), 0).x != 0.0) {\n        vec2 grid = smoothstep(0.0, 2.0*fwidth(p.x), abs(fract(p + s)));\n        fragColor.rgb += vec3(1.0 - min(grid.x, grid.y));\n    }\n\n    // gradient\n    vec2 grad = load_gradient(round(p + s), norm_mode, snap_mode);\n    grad = grad + F2 * (grad.x + grad.y);\n    fragColor.r += arrow(round(p + s), grad, p + s);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float F2 = 0.5*(sqrt(3.0)-1.0);\nconst float G2 = (3.0-sqrt(3.0))/6.0;\n\nvec2 screen_to_pos(vec2 p, vec3 resolution)\n{\n    return 4.1 * p / resolution.y;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/XlXcW4\nvec2 hash( vec2 v )\n{\n    uvec2 x = uvec2(v);\n    const uint k = 1103515245U;\n    x = ((x>>8U)^x.yx)*k;\n    x = ((x>>8U)^x.yx)*k;\n    x = ((x>>8U)^x.yx)*k;\n    \n    v = vec2(x)*(1.0/float(0xffffffffU));\n    return 2.0 * v - vec2(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 grad = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n\n    // set random gradints on start or if 'r' is pressed\n    if (all(equal(grad, vec2(0.0))) || iFrame == 0 || texelFetch(iChannel1, ivec2(82,1), 0).x > 0.) {\n        grad = hash(fragCoord + vec2(iFrame) + vec2(30.0, 0.0));\n    } else {\n        if (iMouse.z > 0.0) {\n            // set the closest gradient towards mouse\n            vec2 mouse = screen_to_pos(iMouse.xy, iResolution);\n            mouse = mouse + F2 * (mouse.x + mouse.y);\n            if (round(mouse) == floor(fragCoord)) {\n                grad = 2.0 * (mouse - floor(fragCoord));\n                float l = length(grad);\n                if (l > 1.0) grad /= l;\n            }\n        }\n    }\n\n    fragColor = vec4(grad, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}