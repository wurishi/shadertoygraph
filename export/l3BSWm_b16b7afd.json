{"ver":"0.1","info":{"id":"l3BSWm","date":"1710680118","viewed":84,"name":"[phreax] flow","username":"phreax","description":"Based on my previous shader: https://www.shadertoy.com/view/l3jSWR","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow","polyhedra","iridescent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2024\n\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define BUMP_EPS 0.004\n#define sabsk(x, k) sqrt(x * x + k * k)\n#define sabs(x) (sabsk(x, .1))\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\n\nfloat tt, g_mat, fadeIn;\nvec3 ro;\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\n//  some 2d noise for dithering\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\n// ortho normal basis \nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\n// Zucconi's spectral palette\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\n// spectral palette by wavelength\nvec3 waveSpectrum(float w){\n\n    if(w > 700.0 || w < 400.0){\n        return vec3(0);\n    }\n    \n\tfloat x = fract((w - 400.0)/ 300.0);\n    \n\tvec3 col = spectral_zucconi6(x);\n\n    // Undo gamma\n    col = invGamma(col);\n\n    return col;\n}\n\n\n// physical based diffraction grating\nvec3 diffraction(vec3 rd, vec3 n, vec3 td, vec3 l, float d) {\n\n    vec3 col = vec3(0);\n\n    float cos_ThetaL = dot(l, td);\n    float cos_ThetaV = dot(rd, td);\n   \n    float u = abs(cos_ThetaL - cos_ThetaV);\n    \n    if(u == 0.) {\n        return vec3(0);\n    }\n    \n    for(float i=1.; i < 2.; i++) {\n        float wavelength = u * d / i;\n        col += waveSpectrum(wavelength);\n    }\n    col = clamp(col, vec3(0), vec3(1));\n    return col;\n}\n\n\n// from https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n\nfloat box(vec3 p, vec3 r) {\n  vec3 d = abs(p) - r;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n\n\n\nvec2 toPolar(vec2 p)\n{\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 fromPolar(vec2 p)\n{\n return vec2(cos(p.y) * p.x , sin(p.y) * p.x);\n}\n\n\nfloat pMod(float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn p;\n}\n\n#define PHI 1.618033988749895\n#define SQR2 1.4152135\n#define ISQR2 1./SQR2\n\n// Million thanks to https://mercury.sexy/hg_sdf\nconst vec3 GDFVectors[19] = vec3[](\n\tnormalize(vec3(1, 0, 0)),\n\tnormalize(vec3(0, 1, 0)),\n\tnormalize(vec3(0, 0, 1)),\n\n\tnormalize(vec3(1, 1, 1 )),\n\tnormalize(vec3(-1, 1, 1)),\n\tnormalize(vec3(1, -1, 1)),\n\tnormalize(vec3(1, 1, -1)),\n\n\tnormalize(vec3(0, 1, PHI+1.)),\n\tnormalize(vec3(0, -1, PHI+1.)),\n\tnormalize(vec3(PHI+1., 0, 1)),\n\tnormalize(vec3(-PHI-1., 0, 1)),\n\tnormalize(vec3(1, PHI+1., 0)),\n\tnormalize(vec3(-1, PHI+1., 0)),\n\n\tnormalize(vec3(0, PHI, 1)),\n\tnormalize(vec3(0, -PHI, 1)),\n\tnormalize(vec3(1, 0, PHI)),\n\tnormalize(vec3(-1, 0, PHI)),\n\tnormalize(vec3(PHI, 1, 0)),\n\tnormalize(vec3(-PHI, 1, 0))\n);\n\n\n\nfloat fGDF(vec3 p, float r, int begin, int end) {\n\tfloat d = 0.;\n\tfor (int i = begin; i <= end; ++i)\n\t\td = max(d, abs(dot(p, GDFVectors[i])));\n\treturn d - r;\n}\n\n\nfloat dodecahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 13, 18);\n}\n\n\nfloat icosahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 12);\n}\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\n// smooth noise\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\nfloat g_glow;\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvec3 g_p;\nvec3 transformDode( vec3 p) {\n   //p.xz *= rot(.2*tt);\n  // p.xy *= rot(.4*tt);\n   return p;\n}\nvec3 opIcosahedralSymmetry( vec3 p )\n{    \n    // const float c = cos(PI/5.), s=sqrt(0.75-c*c);\n    // cos(PI/5.) = 0.80901699437\n    // const vec3 n = vec3(-0.5, -c, s);\n    const vec3 n = vec3(-0.5, -0.809, 0.309); \n    p = abs(p);\n    for (int i=0;i<3;i++) {\n        float side = dot(p, n);\n        if ( side > 0.0 ) break;\n        p -= 2.*min(0., side)*n;\n        if (i!=2) p.xy = abs(p.xy);\n    }\n    return p;\n}    \n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// adapted from https://www.shadertoy.com/view/Nsd3Wl\nfloat sdDodecahedron(vec3 p) {\n    p = opIcosahedralSymmetry(p);\n    vec3 q = p - ICOMIDEDGE;      // move\n    q.xz *= rot(DODEDIHEDRAL*.5); // rotate\n    // rounded edge\n    vec3 vtx = vec3(-q.x,q.y - Y_TO_DODE_VERTEX,q.z);\n    // onioning and rounding\n    float dDode = abs(length(max(vtx, -.04))+min(vtx.z, 0.)-.01)-.05; \n    float dist = dDode;\n    float dBalls = length(vtx-vec3(round(vtx.z*10.0)/20.0,0.0,0.1))-.03;\n    float dCorners = length(p - ICOMIDFACE * 1.24)-.12; \n    //dist = smin(dist,dBalls,.07);\n    // Holes are centered on the dodecaheron's faces center\n    vec2 pCenter = vec2(q.x - X_TO_DODE_CENTER,q.y);\n    float dHole = length( pCenter ) - .2;    \n\n    dist = smax(dist,-(dHole), .02);\n    return dist;\n}\n\n\nfloat sdDodecahedronBig(vec3 p) {\n    p = opIcosahedralSymmetry(p);\n    vec3 q = p - ICOMIDEDGE;      // move\n    q.xz *= rot(DODEDIHEDRAL*.5); // rotate\n    // rounded edge\n    vec3 vtx = vec3(-q.x,q.y - Y_TO_DODE_VERTEX,q.z);\n    // onioning and rounding\n    float dDode = abs(length(max(vtx, -.02))+min(vtx.z, 0.)-.01)-.025; \n    float dist = dDode;\n    float dBalls = length(vtx-vec3(round(vtx.z*10.0)/20.0,0.0,0.1))-.03;\n    float dCorners = length(p - ICOMIDFACE * 1.24)-.12; \n    //dist = smin(dist,dBalls,.07);\n    // Holes are centered on the dodecaheron's faces center\n    vec2 pCenter = vec2(q.x - X_TO_DODE_CENTER,q.y);\n    float dHole = length( pCenter ) - .3;\n\n     dist = smax(dist, -(dHole), .011);\n    return dist;\n}\n\nfloat sdIcosahedron(vec3 p) {\n    p = opIcosahedralSymmetry(p);\n    vec3 q = p - ICOMIDEDGE;     // move\n    q.yz *= rot(ICODIHEDRAL*.5); // rotates the coordinates to have XY plan aligned with a ICO face's plan\n    // rounded edge\n    vec3 vtx = vec3(q.x - X_TO_ICO_VERTEX,-q.y,q.z);\n    float dIco = abs(length(max(vtx, 0.04))+min(vtx.z, 0.)-.10) -.04;\n    // Circles are centered on the icosahedron's faces\n    float dBigHole = abs(length(q.xy - vec2(0.0,Y_TO_ICO_CENTER))-.2) -.05;\n    // Smaller circles are centered somewhere between the middle of the face and the vertex of the Ico\n    float dSmallHole = abs(abs(length( q.xy - mix(vec2(0.0,Y_TO_ICO_CENTER),vec2(X_TO_ICO_VERTEX,0.0),.60) ) - .07)-.025)-.010;\n    // little chains of spheres on the edges\n    float dBalls = length(q-vec3(round(q.x*20.0)/20.0,0.0,0.1))-.03;\n    // Corners of the Ico\n    q = p - ICOVERTEX * 1.3;      // move\n    q.xz *= rot(DODEDIHEDRAL*.5); // rotate\n    float dCorners = length(q)-.04*(1.0+.5*sin(q.z*50.0));    \n    // combine\n    float dist = dIco;\n    float dCarvings = min(dBigHole, dCorners);\n    //dist += 0.008*smoothstep(0.01,-0.01,dCarvings);\n    dist = smax(dist, -dCarvings, .02);\n   // dist = smin(dist,dCorners-.13,.1);\n   // dist = min(dist,dBalls);\n    return dist;\n}\n\nfloat sdIcosahedronBig(vec3 p) {\n    p = opIcosahedralSymmetry(p);\n    vec3 q = p - ICOMIDEDGE;     // move\n    q.yz *= rot(ICODIHEDRAL*.5); // rotates the coordinates to have XY plan aligned with a ICO face's plan\n    // rounded edge\n    vec3 vtx = vec3(q.x - X_TO_ICO_VERTEX,-q.y,q.z);\n    float dIco = abs(length(max(vtx, 0.04))+min(vtx.z, 0.)-.10) -.03;\n    // Circles are centered on the icosahedron's faces\n    float dBigHole = length(q.xy - vec2(0.0,Y_TO_ICO_CENTER))-.25;\n    // Smaller circles are centered somewhere between the middle of the face and the vertex of the Ico\n    vec3 qb = q;\n    q.xy -=  mix(vec2(0.0,Y_TO_ICO_CENTER),vec2(X_TO_ICO_VERTEX,0.0),.55);\n    q.xy = toPolar(q.xy);\n    q.x *= .5*sin(q.y*.32);\n    q.xy = fromPolar(q.xy);\n    float dSmallHole = abs(abs(abs(length( q.xy ) - .07)-.025)-.011)-0.002;\n    q = qb;\n    // little chains of spheres on the edges\n    float dBalls = length(q-vec3(round(q.x*20.0)/20.0,0.0,0.1))-.03;\n    // Corners of the Ico\n    q = p - ICOVERTEX * 1.27;      // move\n    q.xz *= rot(DODEDIHEDRAL*.5); // rotate\n    float dCorners = length(q)-.05;    \n    // combine\n    float dist = dIco;\n    float dCarvings = min(dBigHole, dSmallHole);\n    //dist += 0.008*smoothstep(0.01,-0.01,dCarvings);\n        dist = smax(dist, -dBigHole, .02);\n    dist = smax(dist, -dSmallHole, .004);\n\n    dist = smin(dist,dCorners,.02);\n    //dist = min(dist,dBalls);\n    return dist;\n}\n\nfloat moebius(vec3 p) {\n\n    p.y += mix(.0, -5., sin(.75*tt));\n    \n    p.xz *= rot(.2*tt);\n      p.xy *= rot(.1*sin(4.3*tt));\n    \n    #ifdef KALEIDOSCOPIC\n    p = kalei(p);\n    #endif\n\n    float r = 2.2;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n    \n\n    float rev = 1.5;\n    float a = atan(p.z, p.x);\n    \n    \n \n    cp *= rot(rev*a+.3*tt);\n\n    cp *= rot(.5*tt);\n        cp= abs(cp) - mix(.01, .14, SIN(tt));\n   \n    return rect(cp.xy, vec2(.03), .01)*.8;\n}\n\n// capped cylinder\nfloat cylc( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat sdDancers(vec3 p) {\n\n    vec2 q = toPolar(p.xz);\n      \n\n    q.x += 1.3*sin(p.y*.2 + 3.*tt);\n\n    //q.z += cos(p.y*.2 + 5.*tt + n21(vec2(sId)));\n    p.xz = fromPolar(q);\n    p *= 1.2;\n    float N = 8.;\n    float sId = pModPolar(p.xz, N);\n    p.x -= 12.;\n    \n    float sring = 2.;\n    vec3 pm = p;\n\n    float ring = moebius(pm/sring)*sring;\n    \n      g_glow += .04/(1.9+pow(abs(ring), 4.)*100.);\n   // return ring;\n\n    //p.xz *= rot(p.y*.15+.5*tt);\n\n    q = toPolar(p.xz);\n    // q.y += 1.*sin(p.y*.2 + 4.*tt);\n    //q.z += cos(p.y*.2 + 5.*tt + n21(vec2(sId)));\n    p.xz = fromPolar(q);\n\n\n    p.x += sin(p.y*.2 + 4.*tt + n21(vec2(sId)));\n    p.z += cos(p.y*.2 + 5.*tt + n21(vec2(sId)));\n\n    //p.xz *= rot(PI*1./5.+.2*tt);\n\n    float len  = 8.;\n    p.y = -abs(p.y)+len/2. + 1.5;;\n    vec3 dId;\n    float s = 1.2;//mix(.3, .7, SIN(.5*tt));\n    float num = 4.;\n\n    float lId = pModInterval1(p.y, s, -len/2., len/2.);\n\n    float cId = pModPolar(p.xz, 5.);\n\n    float cm = smoothstep(-.7, .5, lId/len)*(.6+.3*SIN(.4*tt));\n    \n    p.x -= 2.9*cm;\n     \n    pModPolar(p.xz, 5.);\n    \n    p.x -= 1.9*cm;\n    \n\n   // float cs = s*mix(.02, .3, SIN(1.5*(lId/(num))+1.*tt));\n    float cs = s*mix(.05, .4, cm* SIN(4.5*(lId/(num)+1.*PI*sId/N)+5.*tt));\n   //float d = box(p, vec3(cs)) - 0.3*cs;\n    float d = dodecahedron(p, cs) - 0.3*cs;\n    \n    d = min(ring, d);\n    d /= 1.2;\n    return d;\n}\n\nfloat sdSnake(vec3 p) {\n\n    float s = .6;\n    \n    p /= s;\n    float len = 6.;\n \n    p.xz *= rot(2.*tt);\n    \n     \n    vec2 pp = toPolar(p.xz);\n    \n    pp.x += sin(pp.y);\n    pp.y = abs(pp.y)-2.6;\n    \n    float lId = pModInterval1(pp.y, .15, -len/2., len/2.);\n \n    float cm = smoothstep(-.8, .5, lId/len)*.8;\n \n    p.xz = fromPolar(pp);\n    p.x -= 15. + 1.5*sin(2.*lId/len+4.*tt) + 0.*SIN(tt);\n    \n   \n    p.xy *= rot(0.4*lId/len+tt);\n    float ds = box(p, vec3(2., 2., .5)*cm) - .35;\n    return ds*s;\n}\n\nfloat map(vec3 p) {   \n\n    vec3 bp = p;\n    \n   // float dancers = sdDancers(p);\n    float d = 100000.;\n\n    float dg = abs(length(p) - 1.5);\n    g_glow += .9/(.3+pow(abs(dg), 4.)*50.);\n\n     p.xz *= rot(.4*tt);\n\n    float ds = sdSnake(p);\n    \n    p.xz *= rot(.45*PI);\n    p.yz *= rot(.5*PI);\n    \n    ds = min(ds, sdSnake(p));\n    d = min(d, ds);\n    /*\n       p.xz *= rot(.7*PI);\n     p.yz *= rot(.2*PI);\n    ds = min(ds, sdSnake(p));\n    */\n    d = min(d, ds);\n    \n    if(d <= ds) g_mat = 1.;\n  \n    \n    p = bp;\n    \n    float s = 5.;\n    p = transformDode(p);\n    float dode = dodecahedron(p, 4.);\n \n    p.xy *= rot(.3*tt);\n    dode = sdDodecahedron(p/s/1.1)*s*1.1;\n    float ico = sdIcosahedron(p/s)*s;\n    \n    float dm = smoothstep(0.4, .7, SIN(.9*tt));\n    dode = mix(dode, ico, .6);\n\n    if(dode < d) g_mat = 1.0;\n\n    \n    d = min(d, dode);\n    \n    p = bp;\n    float bg = sdIcosahedronBig(p/20.)*20.;\n  \n   \n    if(bg < d) g_mat = 2.;\n   d = min(d, bg);\n    //if(dancers < d) g_mat = 0.;\n    //d = min(d, dancers);\n\n   \n    // collision detection\n    d = smax(d, -(length(ro-bp)-1.), 0.1);\n\n    return d*.7;\n\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat gridSurf( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*2., 1.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor) {\n    \n    const float eps = BUMP_EPS;\n    float ref = gridSurf(p);                 \n    vec3 grad = vec3( gridSurf(vec3(p.x-eps, p.y, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y-eps, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n}\n\n// iq's shadow function\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\n// why not put the raymarcher in a separate function (;\nvec3 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n\n        \n        t += d;\n        p += rd*d;\n        if(abs(d) < 0.001 || t > 80.) break;\n    }\n    \n   // g_p = p;\n    \n    return vec3(t, mat, d);\n}\n\n\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 rdToCol(vec3 rd) {\n    // Ray direction as color\n    vec3 col = .5*rd + .5;\n\n    col *= vec3(1.2, .7, 1.);\n\n    return col;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    \n    // camera system\n    vec3 f = normalize(l - p),  // forward vector\n         r = normalize(cross(vec3(0, 1, 0), f)), // right vector\n         u = cross(f, r), // up vector\n         c = p + f * z, // center of virtual screen\n         i = c + uv.x * r + uv.y * u, // intersection with screen\n         rd = normalize(i - p);  // ray direction\n         \n    return rd;\n    \n}\n\n// Shane awesome work below\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 coeffs = vec3(0.299*SIN(tt), 0.587, 0.114*SIN(.7*tt));\n    vec3 g = coeffs*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), coeffs) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\nvoid cam(inout vec3 p) {\n   p.xz *= rot(.6*tt+.5*PI);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    tt = .5*iTime-PI;\n\n    vec3  lp = vec3(5., 0., -5),\n          lp2 = vec3(-4., 0., -7);\n\n\n    fadeIn = smoothstep(1., 7., iTime);   \n    //uv = uv.yx;\n    vec3 col;\n    \n    float zoom = smoothstep(.1, .9, SIN(.6*tt));\n    ro = vec3(.0, 3.+1.*sin(.3*tt), -36.+17.*zoom);\n    vec3 lookat = vec3(0, 0, 0), p;\n\n    cam(ro);\n    cam(lp);\n    cam(lp2);\n\n   \n   // ro.yz *= rot(.3*tt);\n    vec3 rd = getRayDir(uv, ro, lookat, .8);\n           \n    \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n     \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.106,0.255,0.275);\n    vec3 c2 = vec3(0.165,0.051,0.286);\n    \n    // light color\n    vec3 lc1 = vec3(0.745,0.761,0.976);\n    vec3 lc2 = vec3(0.573,0.922,0.969);\n    \n    \n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : mix(1000., 250., zoom);\n        vec3 rm = raymarch(ro, rd, steps);\n        \n        float glow = g_glow;\n        mat = rm.y;\n        \n        \n        vec3 p = ro + rm.x*rd;\n      \n        vec3 p2 = p;\n        \n        //p = g_p;\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n    \n      \n            if(mat >= 1.) {\n                  vec3 q = transformDode(p);\n      \n                 // n = texBump(iChannel1,q*.05,n,.005);\n                 // n = texBump(iChannel3,q*.5,n,.002);\n            }\n      //  n = texBump(iChannel1,p2*.1,n,.01);\n        //  n = texBump(iChannel3,p*.4,n,.002);\n        if(rm.z < 0.001) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l2), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n            \n            float shd=softshadow( p, l2+l, 2., 5. );\n       \n            float sss = smoothstep(0., 1., map(p + l * .3)) / .4;\n            float sss2 = smoothstep(0., 1., map(p + l2 * .3)) / .4;\n\n\n            vec3 n2 = n;\n            n2.xy += noise(p.xy) * .5 - .025;\n            n2 = normalize(n2);\n            float height = atan(n2.y, n2.x);\n\n            vec3 iri = spectral_zucconi6(height*1.11)*smoothstep(.8, .2, abs(n2.z))-.02;\n\n            if(mat < 2.)  {\n               col += ( (dif+.4*sss)*lc1 + (.4*sss2+dif2)*lc2) + .1*iri;\n             }\n          \n          \n            //col += texture(iChannel1, 2.*p.xz).rgb;\n      \n            float ao = calcAO(p, n);\n       \n            \n            col *= mix(col, col*ao, .8);\n            if(mat < 3.) {\n                rd = reflect(rd, n);\n                \n                // rd.yz *= rot(PI*.6 + .4*tt);\n                rd.yz = rd.zy;\n         \n                vec3 refl = texture(iChannel0, rd).rgb;\n                vec3 refl2 = rdToCol(rd);\n             \n                refl = invGamma(refl);\n                refl2 = invGamma(refl2);\n               \n                refl *= mix(vec3(1), spectral_zucconi6(n.x*n.y*3.), .4); // reflect rainbows too\n                col = mix(col, .6*refl.rgb, .6);\n                \n                col *= mix(refl2*.5, vec3(1), .8);\n               \n          \n                t = rm.x;\n              \n                float fog = 1.-exp(-t*t*0.00007);\n \n        \n                col = mix(col, vec3(0.510,0.969,0.961), fog);\n               // if(t > 20.) col *= .2;;\n              \n            } \n            \n            \n            col = mix(col*shd, col, .5);;\n            \n            if(mat == 2.) col *= .8;\n            if(mat == 1.) col *= .8;\n\n        } else {\n            col =  mix(c1+.2, c2-.2, (pow(dot(uv, uv), .8)))*.5+.1; // background\n            \n            col *= .4;\n           //col += .6;\n            \n            col = invGamma(col);\n\n        } \n        \n        float glow_v = 1.2-smoothstep(.0, 1., SIN(3.*tt));\n        col += .3*g_glow*vec3(0.702,1.000,0.871); // inner\n    }\n    \n    \n\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv));\n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    \n    col = pow(col*1.8, vec3(1.4))*2.5;\n    col = gamma(col); // gamma\n    \n    \n    fragColor = vec4(col, 1.0 - t * 0.03);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n  Awesome geomtry tricks by sylvain69780 , I'm still trying to comprehend\n  \n  \n  from https://www.shadertoy.com/view/Nsd3Wl\n  \n  the idea get vectors for the edges and vertices, \n  to create rounded edges, holes in the faces, etc.\n*/\n\n\n// Normal of a plan having a dihedral angle of PI/3 with the YZ plan and PI/5 with the XZ plane\nconst float CP = cos(3.1415/5.), SP=sqrt(0.75-CP*CP);\nconst vec3  P35 = vec3(-0.5, -CP, SP);\n\n// Dihedral angles of the Dode. and Ico.\n// This probably can be obtained using linera algebra calculations\n// https://en.wikipedia.org/wiki/Table_of_polyhedron_dihedral_angles\n\nconst float ICODIHEDRAL  = acos(sqrt(5.)/3.);  \nconst float DODEDIHEDRAL = acos(sqrt(5.)/5.);\n\n// below are the directions from the origin limiting the coordniate's domain after folding space\n// trivial, this is the Z axis\nconst vec3 ICOMIDEDGE = vec3(0,0,1); \n// direction in the XZ plan, the ICO vertex on this line\n// I think this is also the normal of a DODE face\nconst vec3 ICOVERTEX  = normalize(vec3(SP,0.0,0.5)); \n// direction in the YZ plan, you will find the DODE vertex on this line\n// I think this is also the normal of an ICO face\nconst vec3 ICOMIDFACE = normalize(vec3(0.0,SP,CP));  \n/*\n\n    This represents the up view of a Rhombic face at z = 1 \n    This can help to draw some figures on the faces\n\n                Y_TO_DODE_VERTEX\n                Y_TO_ICO_CENTER (after ICODIHEDRAL rotation on X axis)\n                \n                         ** \n                      ********\n                   ***   **    ***\n                ***      **       ***\n             ***         **          ***\n          ***            **             ***\n       ***               **                ***\n    ***                  ** (0,0)             ***\n ***************************************************  X_TO_ICO_VERTEX\n    ***                  **                   ***    X_TO_DODE_CENTER (after DODEDIHEDRAL rotation on Y axis)\n       ***               **                ***\n          ***            **             ***\n             ***         **          ***\n                ***      **       ***\n                   ***   **    ***\n                      ********\n                         ** \n\n*/\n\nconst float X_TO_ICO_VERTEX  = length(cross(ICOMIDEDGE,ICOVERTEX))/dot(ICOMIDEDGE,ICOVERTEX);\nconst float Y_TO_DODE_VERTEX = length(cross(ICOMIDEDGE,ICOMIDFACE))/dot(ICOMIDEDGE,ICOMIDFACE);\nconst float X_TO_DODE_CENTER = X_TO_ICO_VERTEX*cos(DODEDIHEDRAL*.5);\nconst float Y_TO_ICO_CENTER  = Y_TO_DODE_VERTEX*cos(ICODIHEDRAL*.5);","name":"Common","description":"","type":"common"}]}