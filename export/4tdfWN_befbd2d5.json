{"ver":"0.1","info":{"id":"4tdfWN","date":"1643797377","viewed":139,"name":"Fluid RK 2","username":"bitblast","description":"Fluid simulation","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["fluidsimulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Channel 0: velocity / density\n// Channel 1: color\n\n//#define SHOW_DENSITY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = bufferScale(iResolution);\n    //scale = 1.0;\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(col, 1.0);\n#ifdef SHOW_DENSITY\n    vec2 uv = fragCoord/iResolution.xy * scale;\n    vec3 velMass = texture(iChannel1, uv).xyz;\n    fragColor = vec4(velMass.xy, velMass.z * 0.5, 1.0).zzzw;\n#endif\n    \n    /*float massHighlight = clamp((velMass.z - 3.0) * 0.05, 0.0, 1.0);\n    //vec3 result = mix(col, vec3(1.0), massHighlight);\n    vec3 result = (1.0 + massHighlight) * col;\n    fragColor = vec4(result, 1.0);*/\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Velocity + Pressure\n\nconst float DIST_FACTOR = 4.0;\nconst int KERNEL_RAD = 3;\nconst float VELOCITY_ATTENUATION_FACT = 0.995; // Closer to 1 -> more liquid\nconst float VOLUME_ATTENUATION_FACT = 0.999;\nconst float FLOW_STRENGTH = 0.333; //0.1;\nconst float FLOW_FACT = 0.5 * 0.25 * FLOW_STRENGTH;\nconst float MAX_VOLUME = 6.0;\n\nvec2 mouseVelocity(vec2 fragCoord, float scale)\n{\n    if (iMouse.z < 0.0)\n    \treturn vec2(0, 0);\n    \n    vec3 prevM = scale * texture(iChannel1, vec2(0.0 / iResolution.x, 0.5)).xyz;\n    if (prevM.z < 0.0)\n    \treturn vec2(0, 0);\n    \n    vec2 cur = scale *  iMouse.xy; // scale * texture(iChannel1, vec2(0.0 / iResolution.x, 0.5)).xy;\n    vec2 prev = prevM.xy;\n    vec2 delta = cur - prev;\n    float dlen = length(delta);\n    if (dlen < 0.0001)\n        return vec2(0, 0);\n    \n    float maxDist = DIST_FACTOR * sqrt(dlen);\n    float dist;\n    if (dot(fragCoord - cur, delta) >= 0.0)\n        return vec2(0, 0);\n    if (dot(fragCoord - prev, delta) <= 0.0)\n        return vec2(0, 0);\n    \n    vec2 normRot = 1.0 / dlen * vec2(-delta.y, delta.x);\n    dist = abs(dot(normRot, fragCoord - cur));\n    if (dist > maxDist)\n        return vec2(0, 0);\n    \n    float stren = 0.5 * (1.0 + cos(clamp(dist / maxDist, 0.0, 1.0) * PI));\n    stren = 1.0;\n    return stren * delta;\n}\n\nvec2 reflectSample(inout vec2 uv, vec2 dim)\n{\n    vec2 sgn = vec2(1.0, 1.0);\n    if (uv.x < 0.0)\n    {\n        uv.x = -uv.x;\n        sgn.x = -sgn.x;\n    }\n    else if (uv.x > dim.x)\n    {\n        uv.x = 2.0 * dim.x - uv.x;\n        sgn.x = -sgn.x;\n    }\n    if (uv.y < 0.0)\n    {\n        uv.y = -uv.y;\n        sgn.y = -sgn.y;\n    }\n    else if (uv.y > dim.y)\n    {\n        uv.y = 2.0 * dim.y - uv.y;\n        sgn.y = -sgn.y;\n    }\n    return sgn;\n}\n\nvec3 gather(vec2 fragCoord, vec2 dim)\n{\n    vec4 accumulated = vec4(0.0); // XY: velocity, Z: resulting mass, W: total mass flowing\n    vec3 own = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    vec2 dimUV = dim / iResolution.xy;\n    for (int xoi = -KERNEL_RAD; xoi <= KERNEL_RAD; ++xoi)\n    {\n        for (int yoi = -KERNEL_RAD; yoi <= KERNEL_RAD; ++yoi)\n        {\n            int idist = abs(xoi) + abs(yoi);\n            vec2 off = vec2(xoi, yoi);\n            vec2 loc = fragCoord + off;\n            vec3 smpl;\n            if (idist == 0)\n                smpl = own;\n            /*else if (loc.x < 0.0 || loc.y < 0.0)\n                smpl = vec3(0.0, 0.0, 1.0);*/\n            else\n            {\n                vec2 uv = loc / iResolution.xy;\n                vec2 sgn = reflectSample(uv, dimUV);\n                smpl = texture(iChannel0, uv).xyz;\n                smpl.xy *= sgn;\n            }\n            vec2 fact2 = max(1.0 - abs(off + smpl.xy), 0.0);\n            float facMass = fact2.x * fact2.y * smpl.z;\n            accumulated.xy += facMass * smpl.xy; \n            accumulated.zw += facMass;\n            if (idist == 1)\n            {\n                float flowMass = FLOW_FACT * (smpl.z - own.z); // Positive = inflow\n                if (flowMass > 0.0)\n                \taccumulated.xy += flowMass * (-off + smpl.xy); // Inflow: Add flow velocity + source velocity\n                else\n                    accumulated.xy -= -flowMass * accumulated.xy; // Outflow: remove velocity from own\n                accumulated.w += flowMass;\n                accumulated.z += flowMass;\n            }\n        }\n    }\n    if (accumulated.w < 0.01)\n        accumulated.xy = vec2(0.0);\n    else\n        accumulated.xy /= accumulated.w;\n    accumulated.z = max(accumulated.z, 0.0);\n    \n    return accumulated.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = bufferScale(iResolution);\n    int width = int(ceil(iResolution.x * scale));\n    int height = int(ceil(iResolution.y * scale));\n    if (iTime <= 0.17 || fragCoord.x >= float(width) || fragCoord.y >= float(height) || texture(iChannel2, vec2(82.5 / 256.0, 0.166666)).x > 0.5)\n    \tfragColor = vec2(0.0, 1.0).xxyy;\n    else\n    {\n        vec3 result = gather(fragCoord, vec2(width, height));\n        result = mix(vec2(0.0, 1.0).xxy, result, vec2(VELOCITY_ATTENUATION_FACT, VOLUME_ATTENUATION_FACT).xxy);\n        result.xy += mouseVelocity(fragCoord, scale);\n        float maxv = 0.5 * float(KERNEL_RAD);\n        float lenSqr = dot(result.xy, result.xy);\n        if (lenSqr > maxv * maxv)\n            result.xy = maxv / sqrt(lenSqr) * result.xy;\n        result.z = min(MAX_VOLUME, result.z);\n        if (isnan(result.x) || isnan(result.y) || isnan(result.z) || result.z < 0.0)\n            fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n        else\n        \tfragColor = vec4(result, 1.0);\n        //fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\nconst float MAX_Y_RES = 128.0;\nfloat bufferScale(vec3 iResolution)\n{\n    if (iResolution.y < MAX_Y_RES)\n        return 1.0;\n    else\n        return MAX_Y_RES / iResolution.y;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Mouse position previous frames\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x <= 0.5)\n    \tfragColor = vec4(iMouse.xyz, 1.0);\n    else\n    \tfragColor = vec4(texture(iChannel0, (fragCoord - vec2(1.0, 0.0)) / iResolution.xy).xy, 0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float SIZE_REL = 0.04;\nconst vec2 NORM = vec2(0.5, sqrt(3.0));\nconst vec2 NEG_NORM = vec2(-0.5, sqrt(3.0));\n\n\nvec3 initAt(vec2 fragCoord)\n{\n    float oneOverSize = 1.0 / (SIZE_REL * iResolution.y);\n    vec2 rel = fragCoord * oneOverSize;\n    if (rel.x < 0.0)\n        rel.x += 2.0 * ceil(-rel.x * 0.5);\n    if (rel.y < 0.0)\n        rel.y += 2.0 * ceil(-rel.y * 0.5);\n    int cnt = 0;\n    if (mod(rel.x, 2.0) >= 1.0)\n        ++cnt;\n    if (mod(rel.y, 2.0) >= 1.0)\n        cnt += 2;\n    /*if (mod(dot(rel, NORM), 2.0) >= 1.0)\n++cnt;\nif (mod(dot(relFromRight, NORM), 2.0) >= 1.0)\n++cnt;*/\n\n    if(cnt == 0)\n        return vec3(1.0,0.5,0.0);\n    else if(cnt == 1)\n        return vec3(0.0,1.0,0.5);\n    else if(cnt == 2)\n        return vec3(0.5,0.0,1.0);\n\telse\n    \treturn vec3(0.0,0.5,1.0);\n}\n\nvec3 sampleColor(vec2 coordPix)\n{\n    //if (coordPix.x >= 0.0 && coordPix.x < iResolution.x && coordPix.y >= 0.0 && coordPix.y < iResolution.y)\n    \treturn texture(iChannel0, coordPix / iResolution.xy).rgb;\n    /*else\n        return initAt(coordPix);*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iTime < 0.33333 || texture(iChannel2, vec2(82.5 / 256.0, 0.166666)).x > 0.5)\n    {\n        fragColor = vec4(initAt(fragCoord), 1.0);\n    }\n    else\n    {\n    \tfloat scale = bufferScale(iResolution);\n    \tvec2 uv = fragCoord/iResolution.xy * scale;\n    \tvec3 velMass = texture(iChannel1, uv).xyz / scale;\n        //velMass= vec3(0.0);\n    \tfragColor = vec4(sampleColor(fragCoord - velMass.xy), 1.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}