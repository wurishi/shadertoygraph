{"ver":"0.1","info":{"id":"clscW2","date":"1691726610","viewed":143,"name":"A Snowy Night","username":"andrew741","description":"A nighttime snowstorm under the light of a faint moon.\n\nUse the mouse to look around.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sky","moon","night","falling","storm","snow","white","dark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// layer parameters (for the snowflakes)\n#define CellSize vec2(0.05)\n#define OffsetStrength 1.\n#define Itterations 20.\n\n// moon parameters\n#define MoonPosition vec2(0.8, 0.4)\n\n// cloud parsmeters\n#define CloudSeed 0.\n\n// colors\n#define AmbientColor vec3(0.1, 0.1, 0.15)\n#define MoonColor vec3(0.8)\n\n// the matrix for the hash function (weights from the origonal Hash function)\n#define HashMat  mat3( vec3(127.1,311.7, 74.7), vec3(269.5,183.3,246.1),vec3(113.5,271.9,124.6))\n#define HashMat2 mat2( vec2(127.1, 311.7), vec2(269.5, 183.3))\n\n// this hash is from someone elses shader (with some modifactions)\nvec3 Hash(vec3 p) {  return fract(sin(p * HashMat ) * 43758.5453123) * 2. - 1.;  }\nvec2 Hash(vec2 p) {  return fract(sin(p * HashMat2) * 43758.5453123) * 2. - 1.;  }\n\n// from another persons shader\nfloat Perlin(vec3 x)\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = Hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = Hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = Hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = Hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = Hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = Hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = Hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = Hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n// multiple layers of perlin noise (to provide more detial to it)\nfloat Fractal(vec3 p)\n{\n    float perlin  = Perlin(p      ) * 0.4 ;\n    perlin       += Perlin(p * 2. ) * 0.27;\n    perlin       += Perlin(p * 4. ) * 0.17;\n    perlin       += Perlin(p * 8. ) * 0.1 ;\n    perlin       += Perlin(p * 16.) * 0.06;\n    return pow(max(perlin * 2. - 0.05, 0.), 0.5);\n}\n\n// the main shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // getting the uv coord\n    float zoom = 8.;\n    vec2 tUv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 mouseOffset = smoothstep(0., 1., iMouse.xy/iResolution.xy) * vec2(10., 4.);\n    vec2 uv = tUv * zoom;\n    \n    // getting the offset for the snowflakes\n    float wind = Perlin(vec3(iTime) * 0.1) * 0.5 + 0.5;\n    vec2 offset = vec2(0.5 * iTime + wind * 8., iTime);\n    \n    // rendering the sky\n    float moonPos = length(tUv - MoonPosition);\n    float moonMask = smoothstep(1.5, 0., moonPos) * 0.25;\n    float cloudCover = Perlin(vec3(uv * vec2(0.2, 0.3) + vec2(iTime * 0.2, 0.), CloudSeed));\n    cloudCover = max(cloudCover, 0.) * 4.;\n    float cloudMask = clamp(smoothstep(0.75, 0., length((tUv - MoonPosition + vec2(0., 0.1))*vec2(1., 2.))), 0., 1.);\n    vec3 skyColor = AmbientColor + moonMask;\n    vec3 col = skyColor;\n    \n    // rendering the moon\n    float moon = smoothstep(0.2, 0.175, moonPos);\n    col = mix(col, MoonColor, moon);\n    col += (cloudCover*cloudMask)*0.25;\n    \n    // itterating over all the layers of snow\n    for (float i = 0.; i < 1.; i+=1./Itterations)\n    {\n        // getting the noise offset for snowflakes\n        float noise = Perlin(vec3(iTime*0.2, i*Itterations, -i*Itterations)) * 0.5 + 0.5;\n        \n        // getting the position\n        vec2 np = uv + mouseOffset*i*2. + offset*i;\n        vec2 cellSize = CellSize + i*1.5;\n        vec2 cellPos = mod(np, cellSize) - cellSize*0.5;\n        vec2 cell = floor(np / cellSize);\n        \n        // itterating over surounding cells to prevent clipping of the snowflakes\n        for (float x = -1.; x < 2.; x++)\n        {\n            for (float y = -1.; y < 2.; y++)\n            {\n                // getting the offset\n                vec3 hash = Hash(vec3(cell + vec2(x, y), i*Itterations));\n                float r = (hash.z * 0.5 + 0.5) * (i*0.5+0.25) * 0.1;\n\n                // generating the snowflake\n                float blur = (i*i*i*i*i*i) * 0.1;\n                col += (moonMask*0.75 + 0.75) * 1.5 * (i) * vec3(smoothstep(r + blur, r - blur*1.5, length(cellPos - hash.xy*OffsetStrength*noise - vec2(x, y)*cellSize)));\n            }\n        }\n    }\n    \n    // the final color\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}