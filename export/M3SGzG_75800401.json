{"ver":"0.1","info":{"id":"M3SGzG","date":"1708565858","viewed":43,"name":"Level 3 - 15 to 25","username":"JetJayy","description":" Medium to high complexity\n Example: interpolating between an animated gradient via custom functions","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["graphicsassignment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //normalized coordinates\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    //camera settings\n    vec3 camPos = vec3(0.0, 1.0, -3.0);\n    vec3 camDir = normalize(vec3(uv, 1.0));\n\n    //light position and color\n    vec3 lightPos = vec3(2.0, 4.0, -3.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    //floor\n    float floorDist = -1.0 - camPos.y;\n    float tFloor = floorDist / camDir.y;\n\n    //sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 1.0;\n    vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n\n    vec3 spherePos = camPos + tFloor * camDir;\n    vec3 sphereToCam = camPos - sphereCenter;\n\n    float a = dot(camDir, camDir);\n    float b = 2.0 * dot(sphereToCam, camDir);\n    float c = dot(sphereToCam, sphereToCam) - sphereRadius * sphereRadius;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    float tSphere = 1000.0;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        if (t1 > 0.0 && t1 < tSphere) tSphere = t1;\n        if (t2 > 0.0 && t2 < tSphere) tSphere = t2;\n    }\n\n    vec3 color = vec3(0.0);\n\n    if (tSphere < tFloor) {\n\n        //intersection withsphere\n        vec3 intersectionPoint = camPos + tSphere * camDir;\n        vec3 normal = normalize(intersectionPoint - sphereCenter);\n        vec3 toLight = normalize(lightPos - intersectionPoint);\n\n        //lighting\n        float diffuse = max(dot(normal, toLight), 0.0);\n\n        color = sphereColor * diffuse * lightColor;\n    } else {\n        //floor\n        vec3 intersectionPoint = camPos + tFloor * camDir;\n        vec3 normal = vec3(0.0, 1.0, 0.0);\n        vec3 toLight = normalize(lightPos - intersectionPoint);\n\n\n        float diffuse = max(dot(normal, toLight), 0.0);\n\n        color = vec3(0.5) * diffuse * lightColor;\n    }\n\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}