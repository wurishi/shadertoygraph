{"ver":"0.1","info":{"id":"MsByDW","date":"1492599037","viewed":260,"name":"Graprog Finals","username":"Anderson","description":"8 procedural shader\n- Scottish Tartan 1 \n- Mondrian Painting (Rothko Painting)\n- Art installations\n- Pollock Painting\n- My Creature\n- Scottish Tartan 2\n- Lava\n- HUD","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Change pattern from 1 - 8\n#define PATTERN 1\n\n#define PI 3.14159265358\n#define TWO_PI 6.28318530716\n\nfloat random (in vec2 uv) {\n    return fract(sin(dot(uv.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec3 rect(vec2 uv, vec2 width, vec2 height, vec3 color, vec3 fbm)\n{\n    return (smoothstep(height.x,height.x+0.05,uv.y) - \n            smoothstep(height.y,height.y+0.05,uv.y)) * \n           (smoothstep(width.x,width.x+0.05,uv.x) - \n            smoothstep(width.y,width.y+0.05,uv.x)) * color * fbm;\n}\n\nvec3 polygon(vec2 uv, vec2 pos, int N, float size, vec3 colour)\n{\n    uv -= pos;\n    \n    float a = atan(uv.x,uv.y) + PI;\n\tfloat r = TWO_PI / float(N);\n    \n    float dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    vec3 color = vec3(1.0 - step(size,dist)) * colour;\n    \n    return color;\n}\n\nvec3 circleA(vec2 uv, vec2 pos, float radius,vec3 colour)\n{\n    float value = step(distance(pos,uv), radius);\n    \n    return vec3(value) * colour;\n}\n\nvec3 circleB(vec2 uv, vec2 pos, float radius,vec3 colour)\n{\n    return smoothstep(distance(uv,pos),\n                      distance(uv,pos),radius) * colour;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = 1.5;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = vec2(0,0);\n    vec3 color = vec3(0);\n    \n    // color used\n    vec3 red = vec3(1,0,0);\n    vec3 blue = vec3(0,0,1);\n    vec3 yellow = vec3(1,1,0);\n    vec3 green = vec3(0,1,0);\n    vec3 white = vec3(1,1,1);\n    vec3 black = vec3(0,0,0);\n    vec3 cyan = vec3(0,0.65,1);\n\tvec3 darkCyan = vec3(0,0.545,0.545);\n    \n    #if PATTERN == 1 \n    //------------------------------------------------------------------------------------------------------\n    uv.x *= ratio;\n    uv *= 5.;\n    uv = fract(uv);\n\n    float yellowTile = 0.;\n    float blueTile = 0.;\n    float greenTile = 0.;\n    float redTile = 0.;\n\n    blueTile = step(0.40, uv.x) - step(0.60, uv.x);\n\tblueTile += step(0.40, uv.y) - step(0.60, uv.y);\n\n    yellowTile = step(0.16, uv.x) - step(0.17, uv.x);\n    yellowTile += step(0.33, uv.x) - step(0.34, uv.x);\n    yellowTile += step(0.66, uv.x) - step(0.67, uv.x);\n    yellowTile += step(0.83, uv.x) - step(0.84, uv.x);\n    \n    yellowTile += step(0.16, uv.y) - step(0.17, uv.y);\n    yellowTile += step(0.33, uv.y) - step(0.34, uv.y);\n    yellowTile += step(0.66, uv.y) - step(0.67, uv.y);\n    yellowTile += step(0.83, uv.y) - step(0.84, uv.y);\n\n    redTile = step(0.24, uv.x) - step(0.25, uv.x);\n    redTile += step(0.75, uv.x) - step(0.76, uv.x);\n    \n    redTile += step(0.24, uv.y) - step(0.25, uv.y);\n    redTile += step(0.75, uv.y) - step(0.76, uv.y);\n    \n    greenTile = step(0.0, uv.x) - step(0.1, uv.x);\n    greenTile += step(0.9, uv.x) - step(1.0, uv.x);\n    \n    greenTile += step(0.0,uv.y) - step(0.1, uv.y);\n    greenTile += step(0.9, uv.y) - step(1.0, uv.y);\n      \n    uv *= rotate2d(radians(45.0));\n    \n    for (float i = 0.0; i < 2.; i += 0.071)\n    {\n        if (blueTile + 2. != greenTile && greenTile + 2. != blueTile)\n        {\n    \t\tgreenTile -= step(0.0 + i,uv.y) - step(.05 + i,uv.y);\n        \tblueTile -= step(0.0 + i,uv.y) - step(.05 + i,uv.y);\n        }\n    }\n    \n    color = mix(color, vec3(0,0,0.4), vec3(blueTile));\n\n    color = mix(color, vec3(0,0.4,0), vec3(greenTile));\n                \n    color = mix(color, vec3(0.75,0,0), vec3(redTile - noise(uv * 75.2)));\n    \n    color = mix(color, vec3(0.65,0.65,0) , vec3(yellowTile- noise(uv * 55.2)));\n\n    #elif PATTERN == 2 \n    //------------------------------------------------------------------------------------------------------\n    color += rect(uv,vec2(0.0,0.18),vec2(0.475,1.0),red,vec3(fbm(uv * 36.)));\n    \n    color += rect(uv,vec2(0.21,0.50),vec2(0.475,0.715),yellow,vec3(fbm(uv * 26.)));\n\n    color += rect(uv,vec2(0.0,0.50),vec2(0.0,0.425),white,vec3(fbm(uv * 13.)));\n\n    color += rect(uv,vec2(0.21,0.50),vec2(0.765,1.0),white,vec3(fbm(uv * 18.)));\n\n    color += rect(uv,vec2(0.53,0.73),vec2(0.14,1.0),blue,vec3(fbm(uv * 2.)));\n\n    color += rect(uv,vec2(0.76,1.0),vec2(0.765,1.0),yellow,vec3(fbm(uv * 37.)));\n\n    color += rect(uv,vec2(0.53,1.0),vec2(0.0,0.09),yellow,vec3(fbm(uv * 22.)));\n\n    color += rect(uv,vec2(0.76,1.0),vec2(0.14,0.375),red,vec3(fbm(uv * 30.)));\n\n    color += rect(uv,vec2(0.76,1.0),vec2(0.425,0.715),white,vec3(fbm(uv * 45.)));\n    \n    color = mix(color, vec3(0.6,0.4,0.3),random(uv)*.25);\n    \n    color -= (noise(uv*vec2(200.,28.) - noise(uv*vec2(750.,45.))) * 0.5);\n    color -= vec3(snoise(uv*vec2(800. , 7.5)) - snoise(uv*vec2(21 , 2.)))* .2;\n\n    #elif PATTERN == 3 \n    //------------------------------------------------------------------------------------------------------   \n    uv *= 3.;\n    uv.x *= ratio;\n    uv = fract(uv);\n\n    float value = snoise(uv * 17.5);\n    color = mix(color, vec3(0.5,0.3,0.4),vec3(value));\n    \n    color += circleB(uv,vec2(0.472*ratio,0.74),.21, yellow) * snoise(uv* 32. + iTime);\n    color -= circleB(uv,vec2(0.472*ratio,0.74),.20 * abs(cos(iTime * .4)), white) * noise(uv);\n    \n    color += circleB(uv,vec2(0.14*ratio,0.74),.21, blue) * snoise(uv* 46. - iTime);\n    color -= circleB(uv,vec2(0.14*ratio,0.74),.20 * abs(sin(iTime * .5)), white) * noise(uv);\n\n    color += circleB(uv,vec2(0.525*ratio,0.26),.21, green) * snoise(uv* 29. - iTime);\n    color -= circleB(uv,vec2(0.525*ratio,0.26),.20 * abs(cos(iTime * .3)), white) * noise(uv);\n    \n    color += circleB(uv,vec2(0.19*ratio,0.26),.21 , red) * snoise(uv* 23. + iTime);\n    color -= circleB(uv,vec2(0.19*ratio,0.26),.20 * abs(sin(iTime * .6)), white) * noise(uv* 45.);\n    \n    #elif PATTERN == 4 \n    //------------------------------------------------------------------------------------------------------\n    float value = (snoise(uv * 62.8) - noise(uv * 82.)) * random(uv)* 3.3;\n    \n    color = mix(vec3(1,.647,0), blue, vec3(value));\n    \n    color = mix(color, vec3(0.24,0.523,0.9), noise(uv* 124.) * 1.3);\n\n    color = mix(color, vec3(0.543,0.23,0.24), vec3(0.25,0.44,0.26));\n    \n    color -= (noise(uv* 101.6) - noise(uv * 50.9)) * .5;\n\n    value = distance(uv,vec2(0.5,0.5));\n    \n    color -= vec3(value);\n\n    #elif PATTERN == 5 \n    //------------------------------------------------------------------------------------------------------\n    uv.x *= ratio;\n    \n    pos = vec2(0.5 * ratio, 0.5);\n    float value = 0.;\n    \n    color = vec3(.529,.807,.921);\n        \n    uv.x += iTime;\n    \n    // Sky\n    value = snoise(uv.xy * 1.2) * .33;\n    color = mix(vec3(.529,.807,.921), white, vec3(value));\n    \n    uv.x -= iTime;\n    \n    // Noise\n    float a = noise(uv * 11. + iTime) * 0.1;\n    \n    // water\n    a = noise(uv * 11.8 + iTime) * 0.05;\n    value = step(0.0,uv.y)- step(0.1 + a,uv.y);\n    color = mix(color, blue, vec3(value));\n\n    uv.x += sin(iTime) * .1;\n    uv.y += cos(iTime) * .1;\n    \n    // lower body\n    uv -= pos;\n    uv *= rotate2d(radians(50.0));\n    uv += pos;\n    \n    value = step(0.76,uv.x)- step(0.78,uv.x);\n    value *= step(0.35,uv.y) - step(0.45,uv.y);\n    color = mix(color, vec3(0.2,0.2,1), vec3(value));\n    \n    uv -= pos;\n    uv *= rotate2d(radians(310.0));\n    uv += pos;\n    \n    // center body\n    uv -= pos;\n    uv *= rotate2d(radians(45.0));\n    uv += pos;\n    \n    value = step(0.68 + a,uv.x) - step(0.8,uv.x);\n    value *= step(0.4,uv.y) - step(0.7,uv.y);\n    color = mix(color, vec3(0.1,0.4,0.2), vec3(value));\n    \n    // hand\n    value = step(0.76, uv.x) - step(0.77, uv.x);\n    value *= step(0.56, uv.y) - step(0.64, uv.y);\n    \n    color = mix(color, vec3(1,0.898,0.698), vec3(value));\n    color = mix(color, vec3(1,0.898,0.698), circleA(uv,vec2(0.765,.56),0.01,white));\n    \n    uv -= pos;\n    uv *= rotate2d(radians(315.0));\n    uv += pos;\n    \n\t// Cape\n    uv -= pos;\n    uv *= rotate2d(radians(-20.0));\n    uv += pos;  \n    \n    value = step(0.59 - a,uv.y) - step(0.62 + a,uv.y);\n    value *= step(0.55 + a,uv.x) - step(0.92,uv.x);\n\tcolor = mix(color,vec3(0.1,0.3,.4),  vec3(value));\n    \n    uv -= pos;\n    uv *= rotate2d(radians(-340.0));\n    uv += pos;  \n    \n    // Head\n    uv -= pos;\n    color = mix(color, vec3(1,0.898,0.698), circleA(uv,vec2(0.15,0.2),0.1,white));\n    color = mix(color, black, circleA(uv,vec2(0.2,0.22),0.02,white));\n    uv += pos;\n\n    #elif PATTERN == 6 \n    //------------------------------------------------------------------------------------------------------\n    uv.x *= ratio;\n    uv *= 2.;\n    uv = fract(uv);\n        \n    color = vec3(0.392,0.584,0.929);\n    \n    float blueTile = 0.;\n    float redTile = 0.;\n    float whiteTile = 0.;\n    float greenTile = 0.;\n    \n    blueTile = step(0.04, uv.x) - step(0.05, uv.x);\n    blueTile += step(0.16, uv.x) - step(0.33, uv.x);\n    blueTile += step(0.35, uv.x) - step(0.36, uv.x);\n    blueTile += step(0.38, uv.x) - step(0.39, uv.x);\n    blueTile += step(0.61, uv.x) - step(0.62, uv.x);\n    blueTile += step(0.64, uv.x) - step(0.65, uv.x);\n    blueTile += step(0.67, uv.x) - step(0.84, uv.x);\n    blueTile += step(0.95, uv.x) - step(0.96, uv.x);\n    \n    blueTile += step(0.04, uv.y) - step(0.05, uv.y);\n    blueTile += step(0.16, uv.y) - step(0.33, uv.y);\n    blueTile += step(0.35, uv.y) - step(0.36, uv.y);\n    blueTile += step(0.38, uv.y) - step(0.39, uv.y);\n    blueTile += step(0.61, uv.y) - step(0.62, uv.y);\n    blueTile += step(0.64, uv.y) - step(0.65, uv.y);\n    blueTile += step(0.67, uv.y) - step(0.84, uv.y);\n    blueTile += step(0.95, uv.y) - step(0.96, uv.y);\n    \n    whiteTile = step(0.17, uv.x) - step(0.18, uv.x);\n    whiteTile += step(0.19, uv.x) - step(0.20, uv.x);\n    whiteTile += step(0.29, uv.x) - step(0.30, uv.x);\n    whiteTile += step(0.31, uv.x) - step(0.32, uv.x);\n    whiteTile += step(0.68, uv.x) - step(0.69, uv.x);\n    whiteTile += step(0.70, uv.x) - step(0.71, uv.x);\n    whiteTile += step(0.80, uv.x) - step(0.81, uv.x);\n    whiteTile += step(0.82, uv.x) - step(0.83, uv.x);\n    \n    whiteTile += step(0.17, uv.y) - step(0.18, uv.y);\n    whiteTile += step(0.19, uv.y) - step(0.20, uv.y);\n    whiteTile += step(0.29, uv.y) - step(0.30, uv.y);\n    whiteTile += step(0.31, uv.y) - step(0.32, uv.y);\n    whiteTile += step(0.68, uv.y) - step(0.69, uv.y);\n    whiteTile += step(0.70, uv.y) - step(0.71, uv.y);\n    whiteTile += step(0.80, uv.y) - step(0.81, uv.y);\n    whiteTile += step(0.82, uv.y) - step(0.83, uv.y);\n\n    redTile = step(0.225, uv.x) - step(0.265, uv.x);\n    redTile += step(0.735, uv.x) - step(0.775, uv.x);\n        \n    redTile += step(0.225, uv.y) - step(0.265, uv.y);\n    redTile += step(0.735, uv.y) - step(0.775, uv.y);\n\n    greenTile = step(0.24, uv.x) - step(0.25, uv.x);\n    greenTile += step(0.75, uv.x) - step(0.76, uv.x);\n    \n    greenTile += step(0.24, uv.y) - step(0.25, uv.y);\n    greenTile += step(0.75, uv.y) - step(0.76, uv.y);\n\n    color = mix(color, vec3(0,0,0.65), vec3(blueTile * noise(uv* 224.3)));\n    \n    color = mix(color, white, vec3(whiteTile));\n    \n    color = mix(color, vec3(0.6,0,0), vec3(redTile));\n    \n    color = mix(color, vec3(0,0.5,0), vec3(greenTile * noise(uv * 121.5)));\n    \n    #elif PATTERN == 7 \n    //------------------------------------------------------------------------------------------------------\n    float value = snoise(uv * 13.2) + noise(uv * 63.);\n    \n    color = vec3(value);\n    \n    color = mix(color, red, vec3(value) + random(uv * 232.2));\n    \n    uv.y += iTime * .1;\n    \n    color -= (noise(uv* 35.6) - snoise(uv * 20.9)) * .2;\n    \n    #elif PATTERN == 8 \n    //------------------------------------------------------------------------------------------------------\n    uv.x *= 1.75;\n    \n    pos = vec2(0.85,0.5);\n\n    uv -= pos;\n    uv *= rotate2d(-iTime/3.);\n    uv += pos;\n    \n    color = circleB(uv,pos,.47,darkCyan);\n    color -= circleB(uv,pos,.45,darkCyan);\n    \n    for(int i = 0; i < 8; i++)\n    {\n    \tuv -= pos;\n    \tuv *= rotate2d(radians(-45.));\n    \tuv += pos;\n    \n    \tcolor = mix(color, darkCyan, polygon(uv,vec2(0.85,0.88),4,0.08,white));\n        color -= polygon(uv,vec2(0.85,0.97),4,0.01,white);\n        color -= polygon(uv,vec2(0.85,0.95),4,0.01,white);\n        color -= polygon(uv,vec2(0.85,0.93),4,0.01,white);\n        color -= polygon(uv,vec2(0.85,0.91),4,0.01,white);\n    }\n    \n    color = mix(color, black, circleB(uv,pos,.40,white));\n    \n    color += circleB(uv,pos,.50, darkCyan);\n    color -= circleB(uv,pos,.496, darkCyan);\n    \n    uv -= pos;\n    uv *= rotate2d(iTime/3.);\n    uv += pos;\n    \n    color = mix(color, vec3(0,0.1,0.1),circleB(uv,pos,.39, white * noise(uv * 165.6 + iTime * 5.)));\n    color -= circleB(uv,pos,.305, vec3(0,0.1,0.1));\n    \n    color += circleB(uv,pos,.36, vec3(0,0.41,0.41));\n    color -= circleB(uv,pos,.354, vec3(0,0.41,0.41));\n    color += circleB(uv,pos,.34, vec3(0,0.41,0.41));\n    color -= circleB(uv,pos,.335, vec3(0,0.41,0.41));\n    \n    color += circleB(uv,pos,.14, cyan);\n    color -= circleB(uv,pos,.13, cyan);\n    \n    uv -= pos;\n    uv *= rotate2d(iTime);\n    uv += pos;\n    \n    color = mix(color, black, circleB(uv,vec2(0.85,0.6),.08, white));\n    color = mix(color, black, circleB(uv,vec2(0.95,0.44),.08, white));\n    color = mix(color, black, circleB(uv,vec2(0.75,0.44),.08, white));\n    \n    for(int i = 0; i < 3; i++)\n    {\n    \tcolor = mix(color, vec3(0,0.9,1), polygon(uv,vec2(0.85,0.72),3,0.03,white));\n    \tcolor = mix(color, black, polygon(uv,vec2(.85,0.705),3,0.025,white));\n        color = mix(color, vec3(0,0.6,0.9), polygon(uv,vec2(.85,0.69),3,0.025,white));\n    \tcolor = mix(color, black, polygon(uv,vec2(0.85,0.675),3,0.02,white));\n        color = mix(color, vec3(0,0.9,1), polygon(uv,vec2(0.85,0.66),3,0.02,white));\n        \n        uv -= pos;\n    \tuv *= rotate2d(radians(180.0));\n    \tuv += pos;\n        \n    \tcolor = mix(color, vec3(0,0.9,1), polygon(uv,vec2(0.85,0.45),3,0.01,white));\n    \t\n        uv -= pos;\n    \tuv *= rotate2d(radians(180.0));\n    \tuv += pos;\n        \n    \tuv -= pos;\n    \tuv *= rotate2d(radians(120.0));\n    \tuv += pos;\n    }\n    \n    #endif\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}