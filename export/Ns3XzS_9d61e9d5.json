{"ver":"0.1","info":{"id":"Ns3XzS","date":"1634279697","viewed":31,"name":"Portal Corridor","username":"FrostBT","description":"Ray marchers with portals.\n\nThe \"other world\" is just whenever light passes through a portal.\nNote that the \"other world\" has it's colors swizzled to demonstrate how lighting works through portals.\n\nBased on https://www.shadertoy.com/view/XlGBW3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","portal","noneuclidean"],"hasliked":0,"parentid":"ss3SR7","parentname":"Ray Marched Portals"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n//\n// Modified by FrostBT\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON .001\n#define P_DIST 30.\n#define PORTAL_WIDTH 1.3\n#define PORTAL_HEIGHT 1.\n\n#define NUM_WORLDS 3.\n#define NUM_LIGHTS 4\nvec3[] lightDirs = vec3[NUM_LIGHTS] (\n    vec3(.7, .2, 1),\n    vec3(-.7, .3, 1),\n    vec3(1, .4, -1),\n    vec3(-1, .2, -1)\n);\n\nvec3[NUM_LIGHTS] skyLights = vec3[NUM_LIGHTS] (\n    vec3(1.),\n    vec3(1.2),\n    vec3(.5),\n    vec3(.2)\n);\n\nvec3[NUM_LIGHTS] GetLightCols(int world) {\n    if (world == 0) {\n        return vec3[NUM_LIGHTS] (\n            vec3(1.2, .7, .4),\n            vec3(.8, .8, 1.),\n            vec3(.5, .3, .3),\n            vec3(.1));\n    } else if (world == 1) {\n        return vec3[NUM_LIGHTS] (\n            vec3(.4, .7, 1.2),\n            vec3(1., .8, .8),\n            vec3(.3, .3, .5),\n            vec3(.1));\n    } else {\n        return vec3[NUM_LIGHTS] (\n            vec3(.4, .7, 1.2),\n            vec3(1., .8, .8),\n            vec3(.3, .3, .5),\n            vec3(.1));\n    }\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat sdSphere(vec3 p, float s) {\n    return length(p)-s;\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/XdBBzR\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k ) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdFrame(vec3 p) {\n    float d = MAX_DIST;\n    p.z = mod(p.z + P_DIST *.5, P_DIST) - P_DIST * .5;\n    p.x = -abs(p.x);\n    p.y -= PORTAL_HEIGHT*2.;\n    d = min(d, sdBox(p + vec3(PORTAL_WIDTH, 0, 0), vec3(.1, PORTAL_HEIGHT*2., .1)));\n    d = min(d, sdBox(p + vec3(0, -PORTAL_HEIGHT*2., 0), vec3(PORTAL_WIDTH+.1, .1, .1)));\n    \n    // Greebles\n    d = min(d, sdBox(p + vec3(PORTAL_WIDTH+.1, 1.9, 0), vec3(.3, .1, .2)));\n    d = min(d, sdBox(p + vec3(PORTAL_WIDTH, -.6, 0), vec3(.2, .1, .2)));\n    d = min(d, sdBox(p + vec3(PORTAL_WIDTH, -1., 0), vec3(.2, .1, .2)));\n    d = min(d, sdBox(p + vec3(PORTAL_WIDTH, -1.4, 0), vec3(.2, .1, .2)));\n    d = min(d, sdBox(p + vec3(PORTAL_WIDTH+.1, -1.8, 0), vec3(.3, .1, .2)));\n    d = min(d, sdBox(p + vec3(0, -2.2, 0), vec3(PORTAL_WIDTH+.7, .1, .2)));\n    return d;\n}\n\nfloat sdColumn(vec3 p) {\n    float d = MAX_DIST;\n    p.y = -abs(p.y - 16.) + 16.;\n    d = min(d, sdBox(p - vec3(0, .2, 0), vec3(2, .2, 2)));\n    d = min(d, sdBox(p - vec3(0, .6, 0), vec3(1.6, .2, 1.6)));\n    d = min(d, sdBox(p - vec3(0, 1., 0), vec3(1.2, .2, 1.2)));\n    d = min(d, sdBox(p - vec3(0, 8, 0), vec3(1, 8, .5)));\n    d = min(d, sdBox(p - vec3(0, 8, 0), vec3(.5, 8, 1)));\n    return d;\n}\n\nfloat sdTree(vec3 p) {\n  return 0.;\n}\n\nfloat sdBody(vec3 p) {\n    float d = MAX_DIST;\n    d = min(d, sdBox(p + vec3(0, -1.9, 0), vec3(.2, 2.5, p.y*.2 + .8)) - .4);\n    return d;\n}\n\nfloat intersectPlane(\n        vec3 rayOrigin,\n        vec3 rayDirection,\n        vec3 planeNormal,\n        vec3 planeOrigin) {\n    rayOrigin.z = mod(rayOrigin.z, P_DIST);\n    float denom = dot(planeNormal, rayDirection);\n    vec3 p0l0 = planeOrigin - rayOrigin;\n    return dot(p0l0, planeNormal) / denom;\n}\n\nbool intersectPortal(\n        vec3 rayOrigin,\n        vec3 rayDirection,\n        vec3 planeOrigin,\n        float t) {\n    rayOrigin.z = mod(rayOrigin.z, P_DIST);\n\n    if (t < 0.) {\n      return false;\n    }\n    \n    vec3 p = rayOrigin - planeOrigin + rayDirection * t;\n\n    return abs(p.x) < PORTAL_WIDTH && abs(p.y) < PORTAL_HEIGHT*2.;\n}\n\nfloat worldZeroDist(vec3 op) {\n    float d = MAX_DIST;\n    { // Columns\n        vec3 p = op;\n        p.z = mod(p.z + 5., 10.) - 5.;\n        p.x = -abs(p.x) + 10.;\n        d = min(d, sdColumn(p));\n        d = max(d, -abs(op.y - 16.) + (sin(iTime*.5 + op.z*.1) + 1.)*4.);\n    }\n    \n    d = min(d, op.y);\n    d = min(d, sdFrame(op));\n    return d;\n}\n\nfloat worldOneDist(vec3 op) {\n    float d = MAX_DIST;\n    \n    { // Building\n        vec3 p = op;\n        p.x = -abs(p.x) + 10. + sin(iTime*.5 + p.z*.1);\n        \n        p.z = mod(p.z + 5., 10.) - 5.;\n        \n        d = min(d, sdBox(p, vec3(2., .2, 2.)));\n        d = min(d, sdBox(p - vec3(0, .2, 0), vec3(1.8, .2, 1.8)));\n        d = min(d, sdBox(p - vec3(0, .4, 0), vec3(1.6, .2, 1.6)));\n        \n        // Walls\n        p.y = mod(p.y + 1.5, 3.) - 1.5;\n        \n        d = min(d, sdBox(p, vec3(.1, 10., 2.5)));\n        d = min(d, sdBox(p, vec3(1., 10., 1.)));\n        \n        \n        // Pattern\n        p.x = abs(p.x);\n        p.y = abs(p.y);\n        p.z = mod(p.z, 10.) - 5.;\n\n        d = min(d, sdBox(p, vec3(.05, 1.2, 1.2)));\n        \n        d = max(d, -sdBox(p - vec3(0, 0, -1), vec3(.2, .4, .4)));\n        d = max(d, -sdBox(p - vec3(0, 0, 1), vec3(.2, .4, .4)));\n        d = max(d, -sdBox(p - vec3(0, 1, 0), vec3(.2, .4, .4)));\n        \n        d = max(d, -sdBox(p - vec3(0, .8, .8), vec3(.2, .2, .2)));\n        d = max(d, -sdBox(p - vec3(0, .8, -.8), vec3(.2, .2, .2)));\n        \n        d = min(d, sdBox(p, vec3(.05, .1, 10.)));\n        d = min(d, sdBox(p, vec3(.05, 3., .1)));\n        \n        d = max(d, -sdBox(p, vec3(.2, .4, .4)));\n        \n    }\n    d = min(d, sdFrame(op));\n    d = min(d, op.y);\n    return d;\n}\n\nfloat worldTwoDist(vec3 op) {\n    float d = MAX_DIST;\n    d = min(d, sdFrame(op));\n    { // Ground\n        vec3 p = op;\n        p.z = mod(p.z + P_DIST*.5, P_DIST) - P_DIST*.5;\n        p.y += 1.;\n        d = min(d, sdBox(p, vec3(1.,1.,P_DIST)));\n    }\n    return d;\n}\n\nfloat GetDist(vec3 p, int world) {\n    float d = MAX_DIST;\n\n    int zeroSelect = max(0, -abs(world - 0) + 1);\n    d = min(d, mix(MAX_DIST, worldZeroDist(p), float(zeroSelect)));\n\n    int oneSelect = max(0, -abs(world - 1) + 1);\n    d = min(d, mix(MAX_DIST, worldOneDist(p), float(oneSelect)));\n\n    int twoSelect = max(0, -abs(world - 2) + 1);\n    d = min(d, mix(MAX_DIST, worldTwoDist(p), float(twoSelect)));\n    \n    return d-0.02;\n}\n\nmat3 RayMarch(vec3 ro, vec3 rd, int world) {\n\tfloat dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        // Calculate step.\n    \tvec3 p = ro + rd*dO;\n        if (rd.z > 0.) {\n          p.z -= P_DIST;\n        }\n        float dS = GetDist(p, world);\n        \n        // Determine if we passed through a portal.\n        float offset = max(0., sign(dot(rd, vec3(0, 0, 1)))*P_DIST);\n        vec3 portal_center = vec3(0, PORTAL_HEIGHT*2., offset);\n        float t = intersectPlane(p, rd, vec3(0, 0, 1), portal_center);\n        if (intersectPortal(p, rd, portal_center, t) && t < dS) {\n          float s = sign(dot(rd, vec3(0, 0, 1)));\n          // ro.z -= P_DIST * s;\n          dS = t + EPSILON;\n          world = int(mod(float(world) + s, NUM_WORLDS));\n        }\n        \n        // Determine if we should stop.\n        dO += dS;\n        if (dO>MAX_DIST) {\n            dO = MAX_DIST;\n            break;\n        } else if (dS<EPSILON) {\n            break;\n        }\n    }\n    \n    mat3 result;\n    result[0] = vec3(ro + rd * dO);\n    result[1] = vec3(dO, 0, 0);\n    result[2] = vec3(world, 0, 0);\n        \n    return result;\n}\n\nvec3 GetNormal(vec3 p, int world) {\n\tfloat d = GetDist(p, world);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, world),\n        GetDist(p-e.yxy, world),\n        GetDist(p-e.yyx, world));\n    \n    return normalize(n);\n}\n\nvec2 GetSun(vec3 p, vec3 lightAngle, int world) {\n    vec3 l = normalize(lightAngle);\n    vec3 n = GetNormal(p, world);\n    \n    // Shadow\n    float dif = clamp(dot(n, l), 0., 1.);\n    mat3 hit = RayMarch(p+n*EPSILON*2., l, world);\n    float d = hit[1].x;\n    if(d < MAX_DIST) {\n        dif *= 0.1;\n    }\n\n    return vec2(dif, hit[2].x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1., iTime);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    // Distance\n    mat3 hit = RayMarch(ro, rd, int(mod(ro.z / P_DIST, NUM_WORLDS)));\n    vec3 p = hit[0];\n    float d = hit[1].x;\n    int world = int(hit[2].x);\n\n    vec3 lights = vec3(0);\n    for (int iLight = 0; iLight < NUM_LIGHTS; iLight++) {\n      vec2 contrib = GetSun(p, lightDirs[iLight], world);\n      lights += GetLightCols(int(contrib.y))[iLight] * contrib.x;\n    }\n    col = vec3(lights);\n    \n    \n    // Sky color\n    vec3 sky = vec3(0);\n    for (int iLight = 0; iLight < NUM_LIGHTS; iLight++) {\n      float amount = clamp(dot(rd, lightDirs[iLight]), 0., 1.);\n      sky += amount * GetLightCols(world)[iLight];\n    }\n    \n    // Fade off\n    col = mix(col, sky, pow(d/MAX_DIST, 2.));\n    \n    // Gamma correction\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}