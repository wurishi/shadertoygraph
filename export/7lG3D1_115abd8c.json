{"ver":"0.1","info":{"id":"7lG3D1","date":"1637605962","viewed":173,"name":"[ConcoursJFIG2021] GrasseJasmin2","username":"webanck","description":"A forked and revised version of the submission to the Shadertoy contest of the jFIG 2021 at https://www.shadertoy.com/view/NldGR8\nAdded:\n- MIS between diffuse BSDF and solar disk illumination\n- double sided BSDF to the flower","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["flower","glass","spheretracing","pathtracing","caustic","jfig","perfume","jasmin","grasse"],"hasliked":0,"parentid":"NldGR8","parentname":" [ConcoursJFIG2021] GrasseJasmin"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EXPOSURE_FACTOR 2.\n#define GAMMA_FACTOR 1.3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelUV = fragCoord/iResolution.xy;\n    vec4 pixelValue = texture(iChannel0, pixelUV);\n    \n    if(EXPOSURE_FACTOR > 0.0)\n\t\tpixelValue.xyz = vec3(1.0) - exp(-pixelValue.xyz * EXPOSURE_FACTOR);\n\t\t\n\tpixelValue.xyz = pow(pixelValue.xyz, vec3(GAMMA_FACTOR));\n    fragColor = pixelValue;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define CONTROL_CAMERA true\n#define SKY true\n#define SUN true\n#define SAMPLES_PER_FRAME 4u\n#define BOUNCES 10u\n#define BIFACE true\n\n#define NO_MIS 0u\n#define BALANCED_MIS 1u\n#define SMART_MIS 2u\nconst uint MIS_TYPE = BALANCED_MIS;\n\nconst float PI = 3.14;\n#define SUN_DIRECTION normalize(vec3(-1.))\n//#define SUN_DIRECTION vec3(0., -1., 0.)\nconst float SUN_INTENSITY = 314.;\n#define SUN_COLOR vec3(249, 231, 42)/256.\nconst float SUN_APPARENT_RATIO = 0.02;\n\n//Raymarching intersections.\nconst uint NB_STEPS = 128u;\nconst float EPSILON = 0.001;\nconst float MAX_DEPTH = 1.;\nconst float JACOBIAN_FACTOR = 1.1;\n\n//#define ZERO 0\n#define ZERO (min(int(iTime),0))\n#define ZEROu (uint(min(int(iTime),0)))\n\n\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat min3(vec3 v) { return min(min(v.x, v.y), v.z); }\nfloat sqr(float x) { return x*x; }\n\nvec2 rotate(in float rads, in vec2 p)\n{\n\tfloat c = cos(rads);\n\tfloat s = sin(rads);\n\treturn vec2(\n\t\tc*p.x - s*p.y,\n\t\ts*p.x + c*p.y\n\t);\n}\nvec3 rotateZ(in float rads, in vec3 p)\n{\n\treturn vec3(rotate(rads, p.xy), p.z);\n}\nvec3 rotateX(in float rads, in vec3 p)\n{\n\treturn rotateZ(rads, p.yzx).zxy;\n}\nvec3 rotateY(in float rads, in vec3 p)\n{\n\treturn rotateZ(rads, p.zxy).yzx;\n}\n\n//-----------------------\nconst bool CORRELATED_SAMPLES = false;\n//https://www.pcg-random.org/\nuint pcg(inout uint state)\n{\n\tstate = state * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\nuint randState = 0u;\nvoid initRandState(const float time, const uvec2 pixel, const uvec2 resolution, const uint iteration)\n{\n\tuint i = iteration;\n\tif(CORRELATED_SAMPLES)\n\t\trandState = i;\n\telse\n\t\trandState = pixel.x + resolution.x*(pixel.y + resolution.y*i);\n}\nfloat randUniform()\n{\n\treturn fract(float(pcg(randState)) / 4294967296.);\n}\n\n//-----------------------\n\n\n//https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n//https://www.shadertoy.com/view/Xsl3Dl\nfloat noise( in vec3 p )\n{\n\tvec3 i = floor( p );\n\tvec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n\treturn mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n\t\t\t\t\t\t  dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n\t\t\t\t\t mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n\t\t\t\t\t\t  dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n\t\t\t\tmix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n\t\t\t\t\t\t  dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n\t\t\t\t\t mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n\t\t\t\t\t\t  dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3  ba = b - a;\n\tvec3  pa = p - a;\n\tfloat baba = dot2(ba);\n\tfloat paba = dot(pa, ba);\n\tfloat x = length(pa*baba-ba*paba) - r*baba;\n\tfloat y = abs(paba-baba*0.5)-baba*0.5;\n\tfloat x2 = x*x;\n\tfloat y2 = y*y*baba;\n\n\tfloat d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n\treturn sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n\tvec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\t// sampling independent computations (only depend on shape)\n\tvec3  ba = b - a;\n\tfloat l2 = dot2(ba);\n\tfloat rr = r1 - r2;\n\tfloat a2 = l2 - rr*rr;\n\tfloat il2 = 1.0/l2;\n\n\t// sampling dependant computations\n\tvec3 pa = p - a;\n\tfloat y = dot(pa, ba);\n\tfloat z = y - l2;\n\tfloat x2 = dot2( pa*l2 - ba*y );\n\tfloat y2 = y*y*l2;\n\tfloat z2 = z*z*l2;\n\n\t// single square root!\n\tfloat k = sign(rr)*rr*rr*x2;\n\tif( sign(z)*a2*z2 > k ) return sqrt(x2 + z2)*il2 - r2;\n\tif( sign(y)*a2*y2 < k ) return sqrt(x2 + y2)*il2 - r1;\n\treturn (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n\tvec3 ba = b - a; vec3 pa = p - a;\n\tvec3 cb = c - b; vec3 pb = p - b;\n\tvec3 dc = d - c; vec3 pc = p - c;\n\tvec3 ad = a - d; vec3 pd = p - d;\n\tvec3 nor = cross( ba, ad );\n\t\n\treturn sqrt(\n\t\t(sign(dot(cross(ba,nor),pa)) +\n\t\tsign(dot(cross(cb,nor),pb)) +\n\t\tsign(dot(cross(dc,nor),pc)) +\n\t\tsign(dot(cross(ad,nor),pd))<3.0)\n\t\t?\n\t\tmin( min( min(\n\t\tdot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n\t\tdot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n\t\tdot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n\t\tdot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n\t\t:\n\t\tdot(nor,pa)*dot(nor,pa)/dot2(nor)\n\t);\n}\nvoid opCheapBend(inout vec3 p, in float k)\n{\n\tfloat c = cos(k*p.x);\n\tfloat s = sin(k*p.x);\n\tmat2  m = mat2(c,-s,s,c);\n\tp = vec3(m*p.xy,p.z);\n}\n\n\nfloat sphereD(in vec3 p)\n{\n\treturn length(p) - 1.;\n}\nfloat sphereD(in vec3 c, in float r, in vec3 p)\n{\n\treturn length(p - c) - r;\n}\n//a disk of unit radius in the xy plane\nfloat diskD(in vec3 p)\n{\n\tfloat r2 = dot2(p.xy);\n\t//Projection in the disk, closest is disk surface.\n\tif(r2 < 1.0) return abs(p.z);\n\t\n\t//Projection out of disk, closest is distance to circle.\n\tfloat r = sqrt(r2);\n\tfloat h = r - 1.0;\n\treturn sqrt(h*h + sqr(p.z));\n}\nvec3 diskP(in vec3 p)\n{\n\tfloat r2 = dot2(p.xy);\n\t//Projection in the disk, closest is disk surface.\n\tif(r2 < 1.0) return vec3(p.xy, sign(p.z));\n\t\n\t//Projection out of disk, closest is distance to circle.\n\tfloat r = sqrt(r2);\n\treturn vec3(cos(r), sin(r), sign(p.z));\n}\n\n//----------------------------------------------------\n#define TABLE 0u\n#define FLASK 1u\n#define LABEL 2u\n#define PISTIL 3u\n#define PETAL 4u\n#define STEM 6u\n#define CAP 8u\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 uv;\n\tvec3 p;\n\tuint m;\n\tvec3 n;\n};\n\nHit petal(in float r, in vec3 p, in vec3 wp, in uint i)\n{\n\t//scale\n\tvec3 scaling = r*vec3(1, 0.5, 1.);\n\tp /= scaling;\n\t//shift\n\tp.x -= 1.;\n\n\tfloat noiseWarp = 0.3*(noise(vec3(7.*wp.xy, 0.)));\n\tfloat r1 = distance(vec2(-1., 0.), p.xy);\n\tfloat centerWarp = exp(-r1 * 2.);\n\tp.z -= centerWarp - 2.*max(0., 1. - centerWarp)*noiseWarp;\n\t\n\tp.xz += vec2(-0.2, 0.1)*exp2(-abs(p.y)); //middle ridge and pointy end\n\n\tHit hit;\n\thit.d = diskD(p)*min3(scaling);\n\thit.uv = diskP(p);\n\thit.m = PETAL;\n\n\treturn hit;\n}\n\n\n//flower in the xy plane\nconst uint NB_PETALS = 5u;\nHit jasminD(in float r, in vec3 p, in vec3 wp)\n{\n\tp = rotateY(0.5*PI, p);\n\topCheapBend(p, 1.);\n\tp = rotateZ(0.23*PI, p);\n\tp = rotateY(-0.5*PI, p);\n\n\tHit hit;\n\thit.d = 2.*r;\n\tfor(uint i = 0u; i < NB_PETALS; i++)\n\t{\n\t\tvec3 q = rotateZ(2.*PI*float(i)/float(NB_PETALS), p);\n\t\tHit newHit = petal(r, q, p, i);\n\t\tif(newHit.d < hit.d)\n\t\t\thit = newHit;\n\t}\n\n\tfloat sd = sphereD(vec3(0., 0., 0.28*r), 0.01, p);\n\tif(sd < hit.d)\n\t{\n\t\thit.d = sd;\n\t\thit.m = PISTIL;\n\t}\n\n\tsd = sdRoundCone(p, vec3(0., 0., 0.6*r), vec3(0., 0., 3.*r), 0.25*r, 0.2*r);\n\tif(sd < hit.d)\n\t{\n\t\thit.d = sd;\n\t\thit.m = STEM;\n\t}\n\n\treturn hit;\n}\n\n//https://github.com/ssloy/tinyraytracer/wiki/Part-3:-shadertoy\n#define JFIGW 32u\n#define JFIGH 18u\nuint[] jfig_bitfield = uint[](\n\t0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,\n\t//2020\n\t//0x0u, 0x30e30e0u, 0x4904900u, 0x49e49e0u, 0x4824820u, 0x31e31e0u, 0x0u,0x0u,0x0u\n\t//hello 2021!\n\t  0x0u, 0x40e30e0u, 0x4104900u, 0x41e49e0u, 0x4024820u, 0x41e31e0u, 0x0u,0x0u,0x0u\n);\nbool jfig(in vec2 uv)\n{\n\tuvec2 ij = uvec2(uv * vec2(JFIGW, JFIGH));\n\tuint id = ij.x + (JFIGH-1u-ij.y)*JFIGW;\n\tif(id>=JFIGW*JFIGH) return false;\n\treturn 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nHit map(in vec3 p)\n{\n\tHit hit;\n\thit.d = 1000.;\n\tfloat d;\n\n\t//Table.\n\td = diskD(rotateX(0.5*PI, p*3.) - vec3(0., 0., -0.35)) / 3.;\n\tif(d < hit.d)\n\t{\n\t\thit.d = d;\n\t\thit.m = TABLE;\n\t}\n\n\t//Flask.\n\tp = rotateY(-0.2*PI, p); //small rotation of the flask\n\tvec3 halfDiag = vec3(0.1, 0.1, 0.05);\n\td = sdRoundBox(p, halfDiag, 0.01);\n\tif(d < hit.d)\n\t{\n\t\thit.d = d;\n\t\thit.m = FLASK;\n\t}\n\n\t//Label.\n\tfloat xmin = -0.8;\n\tfloat xmax =  0.8;\n\tfloat ymin = -0.8;\n\tfloat ymax =  0.5;\n\tfloat z = -1.25;\n\tvec3 pa = vec3(xmin, ymin, z) * halfDiag;\n\tvec3 pb = vec3(xmin, ymax, z) * halfDiag;\n\tvec3 pc = vec3(xmax, ymax, z) * halfDiag;\n\tvec3 pd = vec3(xmax, ymin, z) * halfDiag;\n\td = udQuad(p, pa, pb, pc, pd);\n\tif(d < hit.d)\n\t{\n\t\thit.d = d;\n\t\thit.m = LABEL;\n\t\thit.uv.xy = (p.xy/halfDiag.xy - vec2(xmin, ymin))/vec2(xmax - xmin, ymax - ymin);\n\t\thit.uv.x = 1. - hit.uv.x;\n\t}\n\n\t//Cap.\n\tfloat h = 0.5*halfDiag.y;\n\tp.y -= halfDiag.y;\n\td = sdCylinder(p, vec3(0), vec3(0., h, 0.), halfDiag.z);\n\tif(d < hit.d)\n\t{\n\t\thit.d = d;\n\t\thit.m = CAP;\n\t\thit.uv = p;\n\t}\n\n\t//Flower\n\tfloat radius = 0.15;\n\tp.y += 2.*halfDiag.y;\n\tp.y -= radius/3. - 0.009;\n\tp.x -= 2.*halfDiag.x;\n\tp.z += 1.5*halfDiag.z;\n\tp = rotateY(-2.1*PI, p);\n\tp = rotateZ(-0.04*PI, p);\n\tp *= 3.;\n\tHit jHit = jasminD(radius, p, p);\n\tjHit.d /= 3.;\n\tif(jHit.d < hit.d)\n\t\thit = jHit;\n\n\treturn hit;\n}\n\nvec3 shade(in Hit hit)\n{\n\tswitch(hit.m)\n\t{\n\t\tcase TABLE:\n\t\t\treturn 2.*vec3(32.5, 15.6, 0.)/256.;\n\t\tcase LABEL:\n\t\t\treturn vec3(jfig(hit.uv.xy));\n\t\tcase PISTIL:\n\t\t\treturn vec3(1., 1., 0.);\n\t\tcase FLASK:\n\t\tcase PETAL:\n\t\tcase CAP:\n\t\tcase STEM:\n\t\t\treturn vec3(1.);\n\t\tdefault:\n\t\t\treturn vec3(0);\n\t}\n}\n\nvec3 randomDirection(in float u, in float v)\n{\n\tfloat longitude = 2.*PI*u;\n\tfloat colatitude = acos(2.*v - 1.);\n\tfloat hRadius = sin(colatitude);\n\treturn vec3(\n\t\thRadius*cos(longitude),\n\t\tcos(colatitude),\n\t\thRadius*sin(longitude)\n\t);\n}\nfloat sphereCapArea(in float angle)\n{\n\treturn 2.*PI * (1. - cos(angle));\n}\n//sample sphere cap of given angle at top of z axis\nvec3 randomSphereCapDirection(in float u, in float v, in float angle, out float pdf)\n{\n\tfloat longitude = 2.*PI*u;\n\tfloat colatitude = acos(1. - v*(1. - cos(angle)));\n\tfloat hRadius = sin(colatitude);\n\t\n\tpdf = 1./sphereCapArea(angle);\n\t\n\treturn vec3(\n\t\thRadius*cos(longitude),\n\t\thRadius*sin(longitude),\n\t\tcos(colatitude)\n\t);\n}\n//sample sphere cap at any axis\nvec3 randomSphereCapDirection(in float u, in float v, in vec3 direction, in float angle, out float pdf)\n{\n\tfloat longitude = atan(direction.y, direction.x);\n\tfloat colatitude = acos(direction.z);\n\t\n\t//3 vectors forming the base (dtheta, dphi, dr)\n\tfloat cc = cos(colatitude);\n\tfloat sc = sin(colatitude);\n\tfloat cl = cos(longitude);\n\tfloat sl = sin(longitude);\n\tvec3 dtheta = vec3(\n\t\t-sl,\n\t\tcl,\n\t\t0\n\t);\n\tvec3 dphi = vec3(\n\t\tcc*cl,\n\t\tcc*sl,\n\t\t-sc\n\t);\n\tvec3 dr = vec3(\n\t\tsc*cl,\n\t\tsc*sl,\n\t\tcc\n\t);\n\t//define the transformation matrix\n\tmat3 m = mat3(dtheta, dphi, dr);\n\t\n\treturn m * randomSphereCapDirection(u, v, angle, pdf);\n}\nvec3 randomHemisphereDirection(in vec3 up, in float u, in float v)\n{\n\tvec3 direction = randomDirection(u, v);\n\treturn dot(direction, up) > 0. ? direction : -direction;\n}\nvec3 randomLambertianReflection(in vec3 normal, in float u, in float v)\n{\n\tvec3 vec = (normal + randomDirection(u, v));\n\t//Avoiding degenerated case.\n\treturn length(vec) < 0.001 ? normal : normalize(vec);\n}\n\n\n//----------------------------------------------------\n\n\n\n\nbool isSunDirection(in vec3 direction)\n{\n\treturn dot(-SUN_DIRECTION, direction) > (1. - 0.5*SUN_APPARENT_RATIO);\n}\nvec3 sunlight(in vec3 direction)\n{\n\treturn isSunDirection(direction) ? SUN_COLOR*SUN_INTENSITY : vec3(0.);\n}\nvec3 background(in vec3 d)\n{\n\tvec3 light = vec3(0.);\n\n\t//sky\n\tfloat t = 0.5*(d.y + 1.);\n\tvec3 skylight = (1. - t)*vec3(1.) + t*vec3(.5, .7, 1.);\n\tif(SKY)\n\t\tlight += skylight;\n\n\tif(SUN)\n\t\tlight += sunlight(d);\n\n\treturn light;\n}\n\t//0.05*PI is the smallest angle without loss of energy\nfloat randomSunlightPdf(in vec3 direction)\n{\n\treturn isSunDirection(direction) ? 1./sphereCapArea(max(0.05, SUN_APPARENT_RATIO*0.5)*PI) : 0.;\n}\nvec3 randomSunlightDirection(in float u, in float v, out float pdf, in vec3 n)\n{\n\treturn randomSphereCapDirection(u, v, -SUN_DIRECTION, max(0.05, SUN_APPARENT_RATIO*0.5)*PI, pdf);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n\tvec4 kk;\n\t// inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n\tvec3 n = vec3(0.0);\n\tfor( int i=ZERO; i<4; i++ )\n\t{\n\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\tn += e*map(pos+eps*e).d;\n\t}\n\treturn normalize(n);\n}\n\nbool intersect(in vec3 ro, in vec3 rd, out Hit hit)\n{\n\tfloat t = 0.;\n\tfor(uint i = ZEROu; i < NB_STEPS && t < MAX_DEPTH; i++)\n\t{\n\t\tvec3 intersection = ro + t*rd;\n\t\thit = map(intersection);\n\t\thit.p = intersection;\n\t\t\n\t\tif(abs(hit.d) < EPSILON) return true;\n\t\t\n\t\tt += abs(hit.d)/JACOBIAN_FACTOR;\n\t}\n\treturn false;\n}\n\n// Use Schlick's approximation for reflectance.\nfloat reflectance(in float cosine, in float n1, in float n2)\n{\n\tfloat r0 = sqr((n1 - n2)/(n1 + n2));\n\treturn r0 + (1. - r0)*pow((1. - cosine), 5.);\n}\nfloat reflectance(float cosine, float ratio)\n{\n\treturn reflectance(cosine, 1., ratio);\n}\n\nbool scatter(inout vec3 ro, inout vec3 rd, in Hit hit, inout vec3 attenuation, inout vec3 pdf)\n{\n\tif(dot2(hit.n) < 0.5) return false;\n\tvec3 color = shade(hit);\n\tswitch(hit.m)\n\t{\n\t\t//Diffuse materials.\n\t\tcase PISTIL:\n\t\tcase PETAL:\n\t\tcase STEM: if(BIFACE)\n\t\t{\n\t\t\tbool backFace = dot(rd, hit.n) > 0.;\n\t\t\t//bool backFace = hit.d < 0.;\n\t\t\tif(backFace) //swap for backface\n\t\t\t{\n\t\t\t\thit.n = -hit.n;\n\t\t\t}\n            const float transmittance = 0.1;\n            float pPassThrough = transmittance/(transmittance + 1.);\n\t\t\tif(randUniform() < pPassThrough)\n\t\t\t{\n\t\t\t\thit.n = -hit.n;\n                while(abs(map(hit.p).d) < EPSILON)\n                    hit.p += hit.n*EPSILON;\n                //hit.p += hit.n*5.*EPSILON;\n                Hit newHit = map(hit.p);\n                if(abs(newHit.d) < EPSILON || newHit.m == TABLE) return false;\n                \n\t\t\t\tattenuation *= transmittance;\n                pdf *= transmittance;\n\t\t\t}\n            else\n            {\n                attenuation *= 1. - pPassThrough;\n                pdf *= 1. - pPassThrough;\n            }\n\t\t}\n\t\tcase TABLE:\n\t\tcase LABEL:\n\t\t{\n\t\t\tfloat skylightPdf = 0.;\n\t\t\tfloat bsdfPdf = 0.;\n\t\t\tvec3 bounceDirection;\n\n\t\t\tfloat c0;\n\t\t\tswitch(MIS_TYPE)\n\t\t\t{\n\t\t\t\tcase NO_MIS: c0 = 0.;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BALANCED_MIS: c0 = 0.5;\n\t\t\t\t\tbreak;\n\t\t\t\t//Rough estimation of relative importance between sunlight and skylight.\n\t\t\t\tcase SMART_MIS:\n\t\t\t\t{\n\t\t\t\t\tconst float skyWeight = 1.;\n\t\t\t\t\tfloat sunWeight = SUN_INTENSITY*max(0., dot(hit.n, -SUN_DIRECTION));\n\t\t\t\t\tfloat skyImportance = 2.*PI;\n\t\t\t\t\tfloat sunImportance = SUN_INTENSITY*sphereCapArea(SUN_APPARENT_RATIO*0.5*PI);\n\t\t\t\t\tc0 = sunImportance/(skyImportance + sunImportance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloat c1 = 1. - c0;\n\n\t\t\t//Sunlight strategy.\n\t\t\tif(randUniform() < c0)\n\t\t\t{\n\t\t\t\t//bounceDirection = -SUN_DIRECTION;\n\t\t\t\t//skylightPdf = randomSunlightPdf(bounceDirection);\n\t\t\t\t//\n\t\t\t\tbounceDirection = randomSunlightDirection(randUniform(), randUniform(), skylightPdf, hit.n);\n\t\t\t\tbsdfPdf = max(0., dot(hit.n, bounceDirection)/PI);\n\n\t\t\t\tfloat p0 = c0*skylightPdf;\n\t\t\t\tfloat p1 = c1*bsdfPdf;\n\t\t\t\tfloat ps = p0 + p1;\n\t\t\t\tpdf *= p0;\n\t\t\t\tattenuation *= p0/ps;\n\t\t\t}\n\t\t\t//BSDF strategy.\n\t\t\telse\n\t\t\t{\n\t\t\t\tbounceDirection = randomLambertianReflection(hit.n, randUniform(), randUniform());\n\t\t\t\tbsdfPdf = dot(hit.n, bounceDirection)/PI;\n\t\t\t\tskylightPdf = randomSunlightPdf(bounceDirection);\n\n\t\t\t\tfloat p0 = c0*skylightPdf;\n\t\t\t\tfloat p1 = c1*bsdfPdf;\n\t\t\t\tfloat ps = p0 + p1;\n\t\t\t\tpdf *= p1;\n\t\t\t\tattenuation *= p1/ps;\n\t\t\t}\n\n\t\t\tfloat d = max(0., dot(hit.n, bounceDirection));\n\t\t\t//if(d <= 0.) return false;\n\n\t\t\tattenuation *= d / PI * color;\n\t\t\tro = hit.p + hit.n*2.*EPSILON;\n\t\t\trd = bounceDirection;\n\t\t\treturn true;\n\t\t}\n\t\t//Glass.\n\t\tcase FLASK:\n\t\tcase CAP:\n\t\t{\n\t\t\tconst float airRefractionIndex = 1.;\n\t\t\tconst float glassRefractionIndex = 1.5;\n\t\t\tfloat refractionIndexRatio = airRefractionIndex/glassRefractionIndex;\n\t\t\t\n\t\t\tbool backFace = dot(rd, hit.n) > 0.;\n\t\t\t//bool backFace = hit.d < 0.;\n\t\t\tif(backFace) //swap for backface\n\t\t\t{\n\t\t\t\trefractionIndexRatio = 1./refractionIndexRatio;\n\t\t\t\thit.n = -hit.n;\n\t\t\t}\n\t\t\t\n\t\t\tfloat cosTheta = dot(-rd, hit.n);\n\t\t\tfloat sinTheta = sqrt(1. - sqr(cosTheta));\n\t\t\tfloat reflectedRatio = sinTheta * refractionIndexRatio > 1. ? 1. : reflectance(cosTheta, refractionIndexRatio);\n\t\t\t\n\t\t\t//Total internal reflection, or both reflection and refraction but with Schlik's approximation giving the reflectance (that cancels out by stochastic selection).\n\t\t\tif(reflectedRatio == 1. || reflectedRatio > randUniform())\n\t\t\t{\n\t\t\t\tattenuation *= reflectedRatio;\n\t\t\t\tpdf *= reflectedRatio;\n\t\t\t\trd = reflect(rd, hit.n);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tattenuation *= (1. - reflectedRatio);\n\t\t\t\tpdf *= (1. - reflectedRatio);\n\t\t\t\trd = refract(rd, hit.n, refractionIndexRatio);\n\t\t\t}\n\t\t\t\n\t\t\tro = hit.p - hit.n*2.*EPSILON;\n\t\t\tattenuation *= color;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//----------------------------------------------------\n\nmat3 observerViewMatrix(in vec2 mouseUV)\n{\n\tvec2 shift = vec2(0., -0.5);\n\tif(mouseUV == vec2(0., 0.))\n\t\tshift += vec2(0.5);\n\tfloat a = (shift.x + mouseUV.x)*PI*2.;\n\tfloat b = (shift.y + mouseUV.y)*PI;\n\t\n\tvec3 camera = vec3(cos(b)*sin(a), sin(b), cos(b)*cos(a));\n\t//Z vector\n\tvec3 up = normalize(cross(cross(camera, vec3(0, 1, 0)), camera));\n\t//Y vector\n\tvec3 x = normalize(cross(up, camera));\n\t\n\tconst float depth = 0.5;\n\treturn depth*mat3(x, up, camera);\n}\nvoid pixelRay(in vec2 ij, out vec3 ro, out vec3 rd)\n{\n\t//Towards -Z.\n\tro = vec3(0, 0, 1);\n\tvec2 q = (ij - 0.5*iResolution.xy)/iResolution.y;\n\trd = normalize(vec3(q, 0) - ro);\n\n\tmat3 view = observerViewMatrix(CONTROL_CAMERA ? iMouse.xy/iResolution.xy : vec2(0.));\n\tro = view[2];\n\trd = normalize(view*rd);\n}\n\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = vec4(vec3(0.), 1.);\n\n\tvec3 ro;\n\tvec3 rd;\n\tpixelRay(fragCoord.xy + vec2(randUniform(), randUniform()), ro, rd);\n\tvec3 attenuation = vec3(1.);\n\tvec3 pdf = vec3(1.);\n\n\tfor(uint b = BOUNCES; b > ZEROu; b--)\n\t{\n\t\tHit hit;\n\t\tif(!intersect(ro, rd, hit))\n\t\t{\n\t\t\tfragColor.xyz += attenuation/pdf * background(rd);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\thit.n = calcNormal(hit.p - rd*2.*EPSILON, 0.0001);\n\t\t\n\t\t\n\t\tif(!scatter(ro, rd, hit, attenuation, pdf))\n\t\t\tbreak;\n\t}\n}\n\n\n\n//----------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoordv)\n{\n    vec2 pixel = fragCoordv;\n\n    vec4 oldColor = texelFetch(iChannel0, ivec2(fragCoordv), 0);\n    if(iMouse.z > 0.) oldColor = vec4(0.);\n\tfor(uint i = ZEROu; i < SAMPLES_PER_FRAME; i++)\n\t{\n\t\tinitRandState(iTime, uvec2(pixel), uvec2(iResolution.xy), uint(oldColor.w));\n\t\t\n\t\tvec4 newColor;\n\t\trender(newColor, pixel);\n        \n        //Avoid degenerate paths.\n\t\tif(any(isnan(newColor)) || any(lessThan(newColor, vec4(0.))))\n\t\t\tcontinue;\n\n\t\tfloat count = oldColor.a + newColor.a;\n\t\toldColor = vec4(oldColor.rgb + (newColor.rgb - oldColor.rgb) / count, count);\n        fragColor = oldColor;\n\t}\n\n\t\n\tfragColor = oldColor;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}