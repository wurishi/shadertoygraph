{"ver":"0.1","info":{"id":"sd3fzn","date":"1655919413","viewed":81,"name":"Cubic Bezier SDF With L1 Metric","username":"Envy24","description":"Cubic Bezier SDF With L1 Metric of P(t)=P0*(1-t)^3+P1t(1-t)^2+P2t^2(1-t)+P3t^3.\nhttps://www.desmos.com/calculator/37b9jf9dir // contains errors","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","distance","linear","equation","segment","parametric","metric","l1"],"hasliked":0,"parentid":"NscBzr","parentname":"Quadratic Bezier SDF With L1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 3. )\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define INITIALLY_FAR               9e30\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\n/* Solution from https://www.desmos.com/calculator/37b9jf9dir */\n#define P(t) (P0*(1.-t)*(1.-t)*(1.-t)+3.*P1*t*(1.-t)*(1.-t)+3.*P2*t*t*(1.-t)+P3*t*t*t)\nfloat cubicBezierSegmentSDF_L1(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3)\n{\n    float minSqDist = INITIALLY_FAR;\n    \n    vec2 A =   -P0+3.*P1-3.*P2+P3,\n         B = 3.*P0-6.*P1+3.*P2,\n         C =      -3.*P0+3.*P1,\n         D =         P0-NDC;\n    \n    const int N = 4;\n    const int M = 4;\n    float coef[N*M] = float[N*M](\n          A.x,          B.x,          C.x,     D.x,\n          A.y,          B.y,          C.y,     D.y,         \n          0.0, 3.*(A.x+A.y), 2.*(B.x+B.y), C.x+C.y,\n          0.0, 3.*(A.x-A.y), 2.*(B.x-B.y), C.x-C.y\n    );\n      \n    vec2 T[3];\n       \n    for (int eq = 0; eq < N; ++eq)\n    {\n        float coef_[4] = float[4](\n            coef[eq*M], coef[eq*M+1], coef[eq*M+2], coef[eq*M+3]\n        );\n        \n        int num = solve(T, coef_);\n    \n        for (int i = 0; i < num; ++i)\n        {\n            float p = clamp(T[i].x, 0.0, 1.0);\n\n            minSqDist = min(minSqDist, L1(P(p), NDC));\n        }\n    }\n\n    float R = sinOSC(0.0, 0.3, iTime);\n    return minSqDist - R;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3,\n    vec3 color)\n{\n    float unit = 7.0 / iResolution.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false) :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.0;\n            //vec2(0);\n    \n    //M=vec2(1, -1);\n      \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L1(NDC, M) - abs(cubicBezierSegmentSDF_L1(M, P0, P1, P2, P3));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float offs = sinOSC(-0.5, 0.5, iTime * 0.5);\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n    \n    vec2 P0 = vec2(-2.0, 0.0) * 0.65; \n    vec2 P1 = vec2(-8.0, 2.0);\n    vec2 P2 = vec2(4.0, -2.0);\n    vec2 P3 = vec2(2.0, 0.0) * 0.65;\n    \n    //vec2 P0 = vec2(-2.0, -1.0); \n    //vec2 P1 = vec2(-2.0, 2.0);\n    //vec2 P2 = vec2(2.0, 2.0);\n    //vec2 P3 = vec2(1.0, 0.0);\n    \n    P0 = rotateAroundZ(P0, iTime * 0.1) + vec2(2.*offs, -offs);\n    P1 = rotateAroundZ(P1, iTime * 0.9) + vec2(-12.*offs, 0.0);\n    P2 = rotateAroundZ(P2, iTime * 0.9) + vec2(8.*offs, -3.*offs);\n    P3 = rotateAroundZ(P3, iTime * 0.1) + vec2(-offs*offs, 1.5*offs);\n    \n    float minDist = cubicBezierSegmentSDF_L1(NDC, P0, P1, P2, P3);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_circle(NDC, P0, P1, P2, P3, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\n/*\n    Calculates cube root with Newton-Raphson method.\n*/\nfloat cubeRoot(const float x)\n{\n    float xc = x;\n    float xxc = x * x;\n\n    for (int i = 0; i < 2; ++i)\n    {\n        xc = (2.0 * xc + x / xxc) * 0.33333333333333331;\n        xxc = xc * xc;\n    }\n\n    return xc;\n}\n\n/*\n    Return value:\n        0 - two complex roots;\n        1 - one real root, but root[0] == root[1];\n        2 - two real roots;\n*/\nint solveQuadratic(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n\n    if (discriminant < 0.0)\n    {\n        float INVa = 1.0 / (2. * coefs[0]);\n        float SQRT = sqrt(-discriminant);\n\n        roots[0].x = -coefs[1] * INVa;\n        roots[0].y = SQRT * INVa;\n        roots[1].x = -coefs[1] * INVa;\n        roots[1].y = -SQRT * INVa;\n\n        return 0;\n    }\n\n    if (discriminant == 0.0)\n    {\n        float Re = -coefs[1] / (2. * coefs[0]);\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = Re;\n        roots[1].y = 0.0;\n\n        return 1;\n    }\n\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;\n    roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa;\n    roots[1].y = 0.0;\n\n    return 2;\n}\n\n/*\n    Return value:\n        0 - no roots when A==0, B==0, C==0;\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicVieta(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float a = coef[1] / coef[0];\n    float b = coef[2] / coef[0];\n    float c = coef[3] / coef[0];\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(Q);\n        float Re = signR * sqrtQ * cosh(phi);\n        float Im = sqrtQ * sinh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(abs(Q));\n        float Re = signR * sqrtQ * sinh(phi);\n        float Im = sqrtQ * cosh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        float Re = -cubeRoot(c - a * a * a / 27.0) - a / 3.0;\n        float Im = sqrt(abs(a - 3.0 * Re) * (a + Re) - 4.0 * b) * 0.5;\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = -(a + Re) * 0.5;\n        roots[1].y = Im;\n        roots[2].x = -(a + Re) * 0.5;\n        roots[2].y = Im;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\nint solve_cubic(\n    out vec2 roots[3],\n    float a,\n    float b,\n    float c,\n    float d)\n{\n    // To monic cubic.\n    float inv_a = 1./ a;\n    b *= inv_a; c *= inv_a; d *= inv_a; a = 1.;\n\n    // Helper constants and variables.\n    float TAU = 6.2831853071795862,   // 2. * PI\n          inv3 = 0.33333333333333331, // 1. / 3.\n          sqrt3 = 1.7320508075688772, // sqrt(3)\n          g = c * inv3,\n          h = b * inv3;        \n    \n    // Solve depressed cubic.\n    float q = g - (b * b) * inv3 * inv3,\n          r = (c * b - 3. * d) * inv3 * .5 - (b * b * b) * inv3 * inv3 * inv3,\n          qqq = q*q*q;\n\n    if (r * r + qqq > 0.) // One real root?\n    {\n        float A = pow(abs(r) + sqrt(r * r + qqq), inv3),\n              k = q / A,\n              t1 = r >= 0. ? A - k : k - A;\n\n        float x2 = -t1 * .5 - h,\n              y2 = (sqrt3 * .5) * (A + k);\n\n        roots[0] = vec2(t1 - h, 0.);\n        roots[1] = vec2(x2, y2);\n        roots[2] = vec2(x2, -y2);\n\n        return 1;\n    }\n    \n    // Three real roots.\n    float theta = q < 0. ? acos(r / sqrt(-qqq)) : 0.,\n        phi1 = theta * inv3,\n        phi2 = phi1 - TAU * inv3,\n        phi3 = phi1 + TAU * inv3,\n        n = 2. * sqrt(-q);\n\n    roots[0] = vec2(n * cos(phi1) - h, 0.);\n    roots[1] = vec2(n * cos(phi2) - h, 0.);\n    roots[2] = vec2(n * cos(phi3) - h, 0.);\n    // roots sorted in descending order: z0 >= z1 >= z2\n\n    return 3;\n}\n\nint solve(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    // Quadratic equation?\n    if (coef[0] == 0.0)\n    {\n        // Linear equation?\n        if (coef[1] == 0.0)\n        {\n            // Constant?\n            if (coef[2] == 0.0) { return 0; }\n            \n            // Solve linear.\n            roots[0].x = -coef[3]/coef[2];\n            roots[0].y = 0.0;\n\n            return 1;\n        }\n        \n        vec2 r[2];\n        float c[3] = float[3](\n            coef[1],\n            coef[2],\n            coef[3]\n        );\n        \n        int num = solveQuadratic(r, c);\n        roots[0] = r[0];\n        roots[1] = r[1];\n        \n        return num;\n    }\n    \n    //return solveCubicVieta(roots, coef);\n    return solve_cubic(roots, coef[0], coef[1], coef[2], coef[3]);\n}","name":"Common","description":"","type":"common"}]}