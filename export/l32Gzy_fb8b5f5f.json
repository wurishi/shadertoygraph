{"ver":"0.1","info":{"id":"l32Gzy","date":"1708610680","viewed":41,"name":"bear*","username":"BenaoudiaIlicia","description":"bear*","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2023.02.06\n// Eric Galin\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m,vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  ro=vec3(2.,10.,10.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  rd=normalize(p.x*u+p.y*v+le*w);\n}\n\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\nfloat Inter(float a,float b)\n{\n  return max(a,b);\n}\n\nfloat diff(float a,float b)\n{\n  return max(a,-b);\n}\n\n\n// Primitives\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n// Plane\n// p : point\n// c : centre du plan\n// n : normale du plan\nfloat Plane(vec3 p,vec3 c, vec3 n) {\n    return dot(p-c,n);\n}\n\n//cercle\nfloat Cercle (vec3 p ,vec3 c ,vec3 n ,float R){\n   float h= dot(p-c,n);\n   float m= sqrt(length(p-c)*length(p-c)-h*h);\n   float l=m-R;\n   float d= sqrt(h*h+l*l);\n  return d;\n\n}\n//Tore\n\nfloat Tore ( vec3 p, vec3 c , vec3 n, float R , float r ){\nreturn Cercle ( p,c,n,R)-r;\n}\n\n//Segment\n//   p : le point \n//   a : le premier point du segment\n//   b : le deuxième point du segment\nfloat Segment (vec3 p,vec3 a ,vec3 b){\n vec3 n= ((b-a)/length(b-a));\n if (dot(p-a,n)<0.){\n     return length (p-a);\n     }\n if(dot(p-b,n)>0.){\n     return length (p-b);\n     }\n  float d=sqrt(length(p-a)*length(p-a) - dot(p-a,n)*dot(p-a,n));\n return d;\n }\n \n//Capsule\n//   p : le point\n//   a : le premier point de l'axe de la capsule\n//   b : le deuxième point de l'axe de la capsule\n//   r : le rayon de la capsule\n\n float Capsule (vec3 p,vec3 a ,vec3 b, float r) {\n  return Segment(p,a,b)-r;\n  }\n  \n//Disque \nfloat Disque (vec3 p ,vec3 c ,vec3 n ,float R)\n{ float h= dot(p-c,n);\n  float m= sqrt(length(p-c)*length(p-c)-h*h);\n  if (m<R){\n   return h;\n  }\n  return Cercle (p,c,n,R);\n  }\n\n\n\n\n//Box \n// p : le point\n// a : le coin inférieur gauche de la boîte\n// b : le coin supérieur droit de la boîte\n\nfloat Box(vec3 p,vec3 a,vec3 b)\n{\n    float XPos = Plane(p, b, vec3(1.0, 0.0, 0.0));\n    float XNeg = Plane(p, a, vec3(-1.0, 0.0, 0.0));\n    float YPos = Plane(p, b, vec3(0.0, 1.0, 0.0));\n    float YNeg = Plane(p, a, vec3(0.0, -1.0, 0.0));\n    float ZPos = Plane(p, b, vec3(0.0, 0.0, 1.0));\n    float ZNeg = Plane(p, a, vec3(0.0, 0.0, -1.0));\n\n    float box= Inter(XPos, Inter(XNeg, Inter(YPos, Inter(YNeg, Inter(ZPos, ZNeg)))));\n    return box;\n}\n\n\n//Cylindre\n// p : le point\n// a : le premier point de l'axe du cylindre\n// b : le deuxième point de l'axe du cylindre\n// r : le rayon du cylindre\nfloat Cylindre (vec3 p, vec3 a ,vec3 b, float r)\n{ \n     float p1=Plane(p,a,a-b);\n     float p2=Plane(p,b,b-a);\n     float ca= Capsule (p,a,b,r);\n     return Inter(p1,Inter(ca,p2));\n}\n\n\n//bear\n// p : le point\n// cc : centre du corps de l'ours, avec un rayon rc\n// ab1, bb1 : points de début et de fin du premier bras de l'ours, avec un rayon rb1\n// ab2, bb2 : points de début et de fin du deuxième bras de l'ours, avec un rayon rb2\n// ap1, bp1 : points de début et de fin de la première jambe de l'ours, avec un rayon rp1\n// ap2, bp2 : points de début et de fin de la deuxième jambe de l'ours, avec un rayon rp2\n// co1, co2 : centres des oreilles de l'ours, avec un rayon ro1 et ro2\n// ce1, ce2 : centres des yeux de l'ours, avec un rayon re1 et re2\n// ct1 : centre de la tête de l'ours, avec un rayon rt1\n// cn : centre du nez de l'ours, avec un rayon rn\n// cq : centre de la queue de l'ours, avec un rayon rq\n// abox, bbox : coins de la boîte entourant l'ours\n// ct : centre du tore autour de l'ours, avec un rayon Rt et un rayon rt\n// nt : direction de l'axe du tore\n\nfloat bear(vec3 p, \n           vec3 cc, float rc, \n           vec3 ab1, vec3 bb1, float rb1, \n           vec3 ab2, vec3 bb2, float rb2, \n           vec3 ap1, vec3 bp1, float rp1, \n           vec3 ap2, vec3 bp2, float rp2, \n           vec3 co1, float ro1, \n           vec3 co2, float ro2, \n           vec3 ce1, float re1, \n           vec3 ce2, float re2, \n           vec3 ct1, float rt1,\n           vec3 cn, float rn,\n           vec3 cq, float rq,\n           vec3 abox,vec3 bbox,\n           vec3 ct, vec3 nt, float Rt , float rt\n           ) {\n    float corps = Sphere(p, cc, rc);\n    float bras1 = Capsule(p, ab1, bb1, rb1);\n    float bras2 = Capsule(p, ab2, bb2, rb2);\n    float pied1 = Capsule(p, ap1, bp1, rp1);\n    float pied2 = Capsule(p, ap2, bp2, rp2);\n    float oreille1 = Sphere(p, co1, ro1);\n    float oreille2 = Sphere(p, co2, ro2);\n    float oeil1 = Sphere(p, ce1, re1);\n    float oeil2 = Sphere(p, ce2, re2);\n    float tete = Sphere(p, ct1, rt1);\n    float nez=Sphere(p, cn, rn);\n    float queue=Sphere(p, cq, rq);\n    float box=Box(p,abox,bbox);\n    float tore=Tore(p,ct,nt,Rt,rt);\n    \n   \n    float bear = Union(corps, Union(bras1, Union(bras2, Union(pied1, Union(pied2, Union(oreille1, Union(oreille2, Union(oeil1, Union(oeil2, Union(tete, Union(nez, Union(queue, Union(box,tore)))))))))))));\n    return bear;\n\n}\n\n\n\n\n\n\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{   \n  \n   float bear=bear(\n    p,  \n    vec3(0.0,0.0,0.0), 1.0,  // Centre et rayon du corps\n    vec3(1, 0.0, 0.0), vec3(1.2, 0., 0.0), 0.3,  // Bras 1 \n    vec3(-1., 0.0, 0.0), vec3(-1.2, 0.0, 0.0), 0.3,  // Bras 2 \n    vec3(-0.5, 0.0, -1.0), vec3(-0.5, 0.0, -1.5), 0.3,  // Pied 1 \n    vec3(0.5, 0.0, -1.0), vec3(0.5, 0.0, -1.5), 0.3,  // Pied 2 \n    vec3(0.6, 0.0, 1.7), 0.3,  // Oreille 1 \n    vec3(-0.6, 0.0, 1.7), 0.3,  // Oreille 2 \n    vec3(0.2, 0.4, 1.7), 0.11,  // Oeil 1 \n    vec3(-0.2, 0.4, 1.7), 0.11,  // Oeil 2 \n    vec3(0.0, 0., 1.2), 0.7,   // Tête\n    vec3(0.0, 0.6, 1.5), 0.09 ,// nez\n    vec3(0.0,-0.8,-0.55), 0.25,// queue\n    vec3(-1.,-1.,-3.5),vec3(1.,1.,-1.6),//Box\n    vec3(0.0, 0.0, 0.), vec3(0.0,1.0, 0.), 2.5, 0.1 //tore\n   \n);\n\n    return bear;\n\n}\n\n\n// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  float v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z))-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z))-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps))-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float e,out bool h,out int s)\n{\n  h=false;\n  \n  // Start at the origin\n  float t=0.;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=object(p);\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),d.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  bool h;\n  int s;\n  float t=SphereTrace(p+Epsilon*n,l,100.,h,s);\n  if(!h)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p,vec3 n,vec3 e)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  \n  // Ambient color\n  vec3 ambient=.25+.25*background(n);\n  \n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n  \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n  \n  // Specular\n  vec3 r=reflect(e,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit; \n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Position\n    vec3 p=ro+t*rd;\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    // Shade object with light\n    rgb=Shade(p,n,rd);\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n","name":"Image","description":"","type":"image"}]}