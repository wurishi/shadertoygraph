{"ver":"0.1","info":{"id":"tsVGRw","date":"1569932349","viewed":199,"name":"Raymarching marbles","username":"Anskiere","description":"-","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxDist = 200.;\nconst float planeDist = 2.;\n\nfloat rand11(float x)\n{\n    return fract(sin(x * 35.7313) * 437.5453);\n}\n\nvec2 rand12(float x)\n{\n    vec2 res;\n\n    res.x = rand11(x);\n    res.y = rand11(res.x);\n\n    return res;\n}\n\nvec3 rand13(float x)\n{\n    vec3 res;\n\n    res.x = rand11(x);\n    res.y = rand11(res.x);\n    res.z = rand11(res.y);\n\n    return res;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp((a - b)/k + 0.5, 0., 1.);\n    float m = h * (1. - h) * 0.5 * k;\n    float r = mix(a, b, h) - m;\n    return r;\n}\n\nvec3 cameraPos()\n{\n    float time = float(iFrame)/30.;\n    float t = time * 0.05;\n\n    vec3 res = vec3(sin(t), 1, -cos(t)) * 9.;\n\n    return res;\n}\n\nvec3 getRay(vec2 uv)\n{\n    vec3 cam = cameraPos();\n    vec3 origin = vec3(0, 0, 0);\n    vec3 look = normalize(origin - cam);\n    vec3 upGlob = vec3(0,1,0);\n    vec3 right = normalize(cross(upGlob, look));\n    vec3 camUp = normalize(-cross(right, look));\n\n    vec3 p = cam + camUp * uv.y + right * uv.x;\n    p += look * planeDist;\n\n    vec3 res = p - cam;\n    return normalize(res);\n}\n\nfloat getSphere(vec3 p, float size, vec3 origin)\n{\n    return length(p - origin) - size;\n}\n\nfloat getSphere(vec3 p, float size)\n{\n    return getSphere(p, size, vec3(0,0,0));\n}\n\nfloat saw(float x)\n{\n    return 2.* abs(fract(x - 0.5) - 0.5);\n}\n\nfloat dispSaw(vec3 p)\n{\n    float res = saw(p.x) * saw(p.y) * saw(p.z);\n    return res;\n}\n\nfloat X(float time, vec3 p, int i, int count, float state)\n{\n    float fi = float(i);\n    float a = fi / float(count) * 6.282;\n\n    vec3 posA = vec3(cos(a), 0, sin(a));\n    posA *= 2.2;\n    vec3 posB;\n\n    float t = time*2. + 1000.;\n    vec3 rand = rand13(fi + 100.);\n    posB = cos(t * rand);\n\n    vec3 pos = mix(posA, posB, state);\n    float res = getSphere(p - pos, .7);\n    smin(res, getSphere(p - pos, .7), .6);\n\n    return res;\n}\n\nfloat getSd(vec3 p)\n{   \n\n    float time = float(iFrame)/30.;\n\n    float st = fract(time*.1);\n    float state = \n        smoothstep(.0, .1, st) *\n        smoothstep(.8, .7, st);\n    // state = 0.;\n    \n    int count = 6;\n    float res = X(time, p, 0, count, state);\n    \n    for (int i = 1; i < count; i++)\n    {\n        float x = X(time, p, i, count, state);\n        res = smin(res, x, state*1.5);\n    }\n\n    res -= cos(length(p)*30. - iTime*10.)*0.015*(1. - state);\n\n    return res;\n}\n\n// from https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p )\n{\n\tconst float h = 0.01;\n\tvec2 k = vec2(1,-1);\n\n\treturn normalize(k.xyy*getSd(p + k.xyy*h) + k.yyx*getSd(p + k.yyx*h)\n                     + k.yxy*getSd(p + k.yxy*h) + k.xxx*getSd(p + k.xxx*h));\n}\n\nfloat raymarch(vec3 sp, vec3 ray, out float closestDist)\n{\n    float depth = 0.;\n\tclosestDist = getSd(sp);\n    \n    for(int i = 0; i < 50; i++)\n    {\n        vec3 p = sp + ray * depth;\n        float dist = getSd(p);\n\t\t\t\n        closestDist = min(closestDist, dist);\n        \n        if (dist < 0.01)\n            return depth + dist;\n\n        depth += dist;\n\n        if (depth >= maxDist)\n            return maxDist;\n    }\n\n    return maxDist;\n}\n\nfloat raymarch(vec3 sp, vec3 ray)\n{\n    float res, closestDist;\n    \n    return raymarch(sp, ray, closestDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = getRay(uv);\n    vec3 camPos = cameraPos();\n    float closestDist;\n    float d = raymarch(camPos, ray, closestDist);\n\n    vec3 col;\n\n    \n    float emission;\n    \n    if (d >= maxDist)\n    {\n        col = texture(iChannel0, ray).rgb;\n        emission = 1. - closestDist;\n    \temission = clamp(emission, 0., 1.);\n        emission = pow(emission, 16.);\n    \n    col += emission;\n    }\n    else\n    {\n        vec3 sphereColor = vec3(0.15);\n        vec3 intP = cameraPos() + d*ray;\n        vec3 n = calcNormal(intP);\n        vec3 lightDir = normalize(vec3(1));\n        float dd = dot(n, lightDir);\n\n        vec3 res = sphereColor * dd;\n\n        vec3 refRay = reflect(ray, n);\n        vec3 refl = texture(iChannel1, refRay).rgb;\n\n        float fresnel = 1. - clamp(dot(n, -ray), 0., 1.);\n\n        res += refl * fresnel;\n\n        col = res;\n    }\n    \n    col = pow(col, vec3(0.75));    \n    col += emission;\n    fragColor = vec4(col,0);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float remap(float a, float b, float c, float d, float x)\n{\n    \n    float k = (x - a)/(b - a);\n    return c + (d - c) * k;\n}","name":"Common","description":"","type":"common"}]}