{"ver":"0.1","info":{"id":"clXXD7","date":"1674835854","viewed":167,"name":"Duck taking a bath","username":"ianertson","description":"A duck taking a bath.\n(At least an attempt at modeling a duck).\n\nYou can rotate around using the mouse.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raymarch","duck"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define ZERO (min(0, int(iTime)))\n\n#define ENTITY_NONE 0\n#define ENTITY_GROUND 1\n#define ENTITY_BOX 2\n#define ENTITY_WATER 3\n#define ENTITY_BOX_FLOOR 4\n#define ENTITY_DUCK 5\n#define ENTITY_DUCK_NOSE 6\n\nfloat noise(vec2 uv, float freq, float warp) {\n    float n = 0.0;\n    n += textureLod(iChannel3, (uv*freq) + ((n*warp) * freq), 1.).r; freq *= 2.0; warp *= 0.5;\n    n += textureLod(iChannel3, (uv*freq) + ((n*warp) * freq), 2.).r; freq *= 2.0; warp *= 0.5;\n    n += textureLod(iChannel3, (uv*freq) + ((n*warp) * freq), 3.).r; freq *= 2.0; warp *= 0.5;\n    n += textureLod(iChannel3, (uv*freq) + ((n*warp) * freq), 3.).r; freq *= 2.0; warp *= 0.5;\n    n += textureLod(iChannel3, (uv*freq) + ((n*warp) * freq), 3.).r; freq *= 2.0; warp *= 0.5;\n    n += textureLod(iChannel3, (uv*freq) + ((n*warp) * freq), 3.).r; freq *= 2.0; warp *= 0.5;\n    n += textureLod(iChannel2, (uv*freq) + ((n*warp) * freq), 3.).r; freq *= 2.0; warp *= 0.5;\n    return n / 7.0;\n}\n\n#define SKIP_CAP 4\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec3 reflectDir;\n    vec2 uv;\n    float dist;\n    float depth;\n    int entity;\n    \n    int skips[SKIP_CAP];\n    int nr_skips;\n};\n\nvoid dataSkip(inout Data data, int skip) {\n    data.skips[data.nr_skips++] = skip;\n}\n\nbool shouldSkip(in int skips[SKIP_CAP], in int nr_skips, int skip) {\n    for (int i = 0; i < nr_skips; i++) if (skips[i] == skip) return true;\n    return false;\n}\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.);\n    data.normal = vec3(0.);\n    data.uv = vec2(0.);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.entity = 0;\n    data.reflectDir = vec3(0.);\n    data.nr_skips = 0;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat planeSDF(vec3 p, vec3 n) {\n    return dot(p, n)+1.;\n}\n\nfloat waterSDF(vec3 p) {\n    vec2 uv = p.xz * 0.1;\n    float n0 = noise(uv, 0.09, 0.02)*0.05;\n    \n    float oT = T*0.01;\n    vec2 offset = vec2(cos(oT+n0), sin(oT+n0))*2.;\n    \n    float n1 = noise(uv + offset, 0.09, 0.02);\n    float n2 = noise((uv*n1)+offset, 0.01, 0.003);\n    \n    vec2 offset2 = vec2(sin(oT+n1), cos(oT+n2));\n    \n    float n3 = noise((uv)+offset2, 0.01, 0.003);\n    \n    float n = (n1+n2+n3)/3.0;\n    \n    n *= 0.2;\n    \n    p.y -= n;\n\n    float plane = planeSDF(p, vec3(0, 1, 0))-1.35;\n    return plane / (1.0 + n);\n}\n\nfloat basketSDF(vec3 p, vec3 s, inout int entity, in int skips[SKIP_CAP], in int nr_skips) {\n    float a = boxSDF(p, s);\n    float b = boxSDF(p+vec3(0.0, -0.5, 0.0), vec3(s.x*0.8, s.y*0.9, s.z*0.8));\n    \n    float t = waterSDF(p);\n    if (t < a) t = FAR; // slice plane so that it's only visible inside the box\n    float box = max(a, -b);\n    \n    entity = ENTITY_BOX;\n    if (t < box && !shouldSkip(skips, nr_skips, ENTITY_WATER)) entity = ENTITY_WATER;\n    \n    return min(t, box);\n}\n\nfloat sphereSDF(vec3 p, float radius) { return length(p) - radius; }\n\nfloat duckSDF(vec3 p, inout int entity) {\n    vec3 pBody = p;\n    vec3 pHead = p;\n    vec3 pNose = p;\n    \n    pHead.xy *= 1.05;\n    pHead.z *= 0.9;\n    pBody.x *= 1.2;\n        \n    float body = sphereSDF(pBody + vec3(0.0, -0.6, 0.0), 0.08);\n    float head = sphereSDF(pHead + vec3(0.0, -0.7, 0.07), 0.04);\n    float nose = sphereSDF(pHead + vec3(0.0, -0.7, 0.11), 0.01);\n    \n    entity = ENTITY_DUCK;\n    float headBody = min(body, head);\n    if (nose < headBody) entity = ENTITY_DUCK_NOSE;\n    \n    return min(nose, headBody);\n}\n\nfloat getDist(vec3 p, inout int entity, in int skips[SKIP_CAP], in int nr_skips) {\n\n    int boxPart = 0;\n    float ground = planeSDF(p, vec3(0, 1, 0));\n    vec3 boxPos = vec3(0, -0.1, 0);\n    float box = basketSDF(p + boxPos , vec3(0.5), boxPart, skips, nr_skips);\n    float boxFloor = boxSDF(p + vec3(0.0, 0.6, 0.0), vec3(2., 0.4, 2.));\n    int duckPart = 0;\n    \n    float duckY = (0.5+(0.5*cos(T*3.)))*0.05;\n    float duck = duckSDF(p + vec3(0., duckY+0.02, 0.), duckPart);\n    \n    float minDist = FAR;\n    \n    entity = ENTITY_NONE;\n    \n    if (ground < minDist && !shouldSkip(skips, nr_skips, ENTITY_GROUND)) { minDist = ground; entity = ENTITY_GROUND; }\n    if (box < minDist && !shouldSkip(skips, nr_skips, boxPart)) { minDist = box; entity = boxPart; }\n    if (boxFloor < minDist && !shouldSkip(skips, nr_skips, ENTITY_BOX_FLOOR)) { minDist = boxFloor; entity = ENTITY_BOX_FLOOR; }\n    if (duck < minDist && !shouldSkip(skips, nr_skips, duckPart)) { minDist = duck; entity = duckPart; }\n    \n    return minDist;\n}\n\nvec3 getNormal(vec3 p, inout int entity, in int[SKIP_CAP] skips, in int nr_skips) {\n    vec2 e = vec2(0.01, 0.0);\n    return normalize(getDist(p, entity, skips, nr_skips) - vec3(\n        getDist(p - e.xyy, entity, skips, nr_skips),\n        getDist(p - e.yxy, entity, skips, nr_skips),\n        getDist(p - e.yyx, entity, skips, nr_skips)\n    ));\n}\n\nvec2 getUv(in Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    float dotup = abs(dot(n, vec3(0, 1, 0)));\n    float dotLR = abs(dot(n, vec3(1, 0, 0)));\n    float dotBF = abs(dot(n, vec3(0, 0, 1)));\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xz, dotup);\n    uv = mix(uv, p.xy, dotBF);\n    uv = mix(uv, p.zy, dotLR);\n    return uv;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(p, data.entity, data.skips, data.nr_skips);\n        \n        dist += next;\n        \n        if (abs(next) <= NEAR || abs(next) >= FAR) break;\n    }\n    \n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    data.normal = getNormal(p, data.entity, data.skips, data.nr_skips);\n    data.uv = getUv(data);\n    data.dist = dist;\n    data.depth = abs(dist) / FAR;\n    \n    return true;\n}\n\n// Thanks iq: https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k, in Data data )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        int entity = 0;\n        float h = getDist(ro + rd*t, entity, data.skips, data.nr_skips);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 getAlbedoWater(in Data data) { return vec3(0.2, 0.4, 0.8); }\n\nvec3 getAlbedoDuck(in Data data) { return vec3(0.6, 0.6, 0.1); }\n\nvec3 getAlbedo(in Data data) {\n    switch (data.entity) {\n        case ENTITY_GROUND: return texture(iChannel0, data.uv).rgb; break;\n        case ENTITY_BOX: return texture(iChannel1, data.uv).rgb; break;\n        case ENTITY_BOX_FLOOR: return texture(iChannel1, data.uv).rgb; break;\n        case ENTITY_WATER: return getAlbedoWater(data); break;\n        case ENTITY_DUCK: return getAlbedoDuck(data); break;\n    }\n    \n    return vec3(1.0, 0.0, 0.0);\n}\n\nbool render(vec3 ro, vec3 rd, inout Data data, inout vec3 col) {\n    vec3 blue = vec3(0.2, 0.4, 0.8) / M_PI;\n    \n    vec3 L = normalize(vec3(1, 2, -3));\n    \n    bool hit = false;\n    if (march(ro, rd, data)) {\n        hit = true;\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo;\n        vec3 normal = data.normal;\n        vec3 viewdir = normalize(data.point - ro);\n        vec3 reflectDir = normalize(reflect(viewdir, normal));\n        data.reflectDir = reflectDir;\n        \n        float NdotL = max(0.0, dot(normal, L));\n        \n        col += diffuse * NdotL;\n        data.nr_skips = 0;\n        dataSkip(data, data.entity);\n        col *= softshadow(data.point, L, NEAR, FAR, 16.0, data);\n    }\n    \n    float dotup = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    col += mix(vec3(1.0), blue, min(dotup*3., 1.0)) *clamp(data.depth, 0.0, 1.0);\n    \n    return hit;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 lookAt = point;\n    float zoom = 1.;\n    vec3 camForward = normalize(lookAt - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        rd.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float moveT = T*0.5;\n        \n        ro.xz *= rot(moveT);\n        ro.y += 1.5;\n        \n        ro.y += (0.5+(0.5*sin(moveT)))*2.;\n        ro.z += (0.2+(0.5*cos(moveT)))*2.;\n        \n        rd = look(uv, vec3(0.), ro);\n    }\n    \n    rd = normalize(rd);\n    \n    vec3 nextCol = vec3(0.);\n    Data data;\n    dataInit(data);\n    bool hit = render(ro, rd, data, nextCol);\n    col += nextCol;\n    if (hit && (data.entity == ENTITY_BOX_FLOOR || data.entity == ENTITY_WATER)) {    \n        vec3 refCol = vec3(0.);\n        Data refData;\n        dataInit(refData);\n        dataSkip(refData, data.entity);\n        \n        if (data.entity == ENTITY_WATER) {\n            dataSkip(refData, ENTITY_BOX);\n        }\n        bool hit = render(data.point, data.reflectDir, refData, refCol);\n        col += refCol;\n    }\n    \n    col /= vec3(0.4938) + col;\n    col = pow(col, vec3(1.0 / 1.4));\n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}