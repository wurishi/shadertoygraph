{"ver":"0.1","info":{"id":"XdGcRz","date":"1520740227","viewed":98,"name":"first marcher","username":"expertmouser","description":"originally written in OSX \"Fragment\", which uses different input/output stuff, hence the funky adapter stuff.\ni think i don't understand something about normals & SDFs.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 oColor;\nvec2 vTexcoord;\nfloat iGlobalTime;\nfloat iAspect;\n\n\nconst float kMaxFloat = 1000000000.; // lol\n\nconst float maxDist  = 2.0;\n\nconst float floorAmt    = -0.02;\nconst float floorHeight = 3.;\n\nconst float PI = 3.14159265359;\nconst float degToRad = PI * 2.0 / 360.0;\nconst float radToDeg = 360.0 / PI / 2.0;\n\nvec3 rotZ(vec3 v, float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return vec3( v.x * s - v.y * c,\n               v.x * c + v.y * s,\n               v.z);\n}\n\nvec3 rotY(vec3 v, float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return vec3( v.x * s - v.z * c,\n               v.y,\n               v.x * c + v.z * s);\n}\n\nvec4 sdfSphere(vec3 p) {\n  float f = iGlobalTime * 0.1;\n  p = rotY(p, f * 2.);\n  vec3 q = p;\n  const float overallDistortionMagnitude = 17.;\n  const float mag2 = .2;\n  const float freq = 20.;\n  float mag = sin(iGlobalTime * 0.1) * overallDistortionMagnitude;\n  q.x += cos(p.z         * mag * 0.9 + f) * 0.1;\n  q.y += sin(p.z         * mag * 0.8 + f) * 0.1;\n  q.z += sin((p.x * p.y) * mag * 1.0 + f * 10.) * 0.1;\n  float dx = sin(p.z * freq) * mag2;\n  float dy = sin(p.x * freq) * mag2;\n  float dz = sin(p.y * freq) * mag2;\n  dx *= dx * dx * dx;\n  dy *= dy * dy * dy;\n  dz *= dz * dz * dz;\n  q.x += dx;\n  q.y += dy;\n  q.z += dz;\n  return vec4(length(q) - 0.75, p.x, p.y, p.z);\n}\n\nvec4 sdfSceneSingle(vec3 p) {\n  vec4 ret = sdfSphere(p);\n  return ret;\n}\n\nvec4 sdfSceneDual(vec3 p) {\n  float sep = 1.25;\n  p.x += sep / 2.;\n  vec4 ret1 = sdfSphere(p);\n  p.x -= sep;\n  vec4 ret2 = sdfSphere(p);\n  vec4 ret;\n  if (ret1.x < ret2.x) {\n    ret = ret1;\n  }\n  else {\n    ret = ret2;\n  }\n  return ret;\n}\n\nvec4 sdfScene(vec3 pt) {\n  return sdfSceneSingle(pt);\n}\n\nvec3 sdfNormal(vec3 p) {\n  const float epsilon = 0.001;\n  vec3 v = vec3(\n    sdfScene(vec3(p.x + epsilon, p.y, p.z)).x - sdfScene(vec3(p.x - epsilon, p.y, p.z)).x,\n    sdfScene(vec3(p.x, p.y + epsilon, p.z)).x - sdfScene(vec3(p.x, p.y - epsilon, p.z)).x,\n    sdfScene(vec3(p.x, p.y, p.z + epsilon)).x - sdfScene(vec3(p.x, p.y, p.z - epsilon)).x\n  );\n\n  return normalize(v);\n}\n\nbool approximatelyEqualEps(float a, float b, float epsilon) {\n  float d = abs(a - b);\n  return d < epsilon ? true : false;\n}\n\nbool approximatelyEqual(float a, float b) {\n  const float epsilon = 0.0001;\n  return approximatelyEqualEps(a, b, epsilon);\n}\n\n// todo: generalize to any plane\nvec3 intersectRayXZPlane(vec3 pt, vec3 dir) {\n  if (approximatelyEqual(dir.y, 0.)) {\n    return vec3(kMaxFloat, 0, kMaxFloat);\n  }\n\n  float s = pt.y / dir.y;\n  return pt + dir * s;\n}\n\nfloat subfloor(vec3 groundPt) {\n  groundPt = rotY(groundPt, 45.0 * degToRad);\n  groundPt += vec3(\n    sin(iGlobalTime * 0.12  ) * 10.,\n    1,\n    sin(iGlobalTime * 0.1211) * 10.\n  );\n  float f = sin(groundPt.x * 1.2) * sin(groundPt.z * 1.2);\n  f *= f * f;\n  return f * 1.9 + 1.5;\n}\n\nfloat floorCheck(vec3 pt, vec3 rayDir) {\n  rayDir = rotY(rayDir, iGlobalTime * 0.031);\n  vec3 floorOffset = vec3(0, floorHeight, iGlobalTime * -4.1);\n  vec3 groundPt = intersectRayXZPlane(pt + floorOffset, rayDir);\n  float f = sin(groundPt.x) + sin(groundPt.z) - sin(iGlobalTime * 0.51) * 0.8;\n  float rf;\n  if (approximatelyEqualEps(f, 0., 0.07)) {\n    rf = 0.18;\n  }\n  else if (f < 0.) {\n    rf = 0.12;\n  }\n  else {\n    rf = subfloor(groundPt) * 0.1;\n  }\n\n  return rf;\n}\n\nvoid otherMain(void)\n{\n  vec3  lightDir = normalize(vec3(iMouse.x / iResolution.x * 2.0 - 1.0, iMouse.y / iResolution.y * 2.0 - 1.0, -0.2));\n\n  lightDir = normalize(vec3(\n    cos(iGlobalTime * 1.13) * 2.0,\n    sin(iGlobalTime * 1.13) * 2.0,\n    sin(iGlobalTime * 0.5 ) * 1.2));\n\n  vec3  camPos = vec3(0, 0, -4.0);\n  float screenDist = 3.5;\n\n  vec2 tmp = vTexcoord * 2.0 - 1.0;\n  vec3 pxlPos;\n  if (iAspect > 1.0) {\n    pxlPos = vec3(tmp.x * iAspect, tmp.y, camPos.z + screenDist);\n  }\n  else {\n    pxlPos = vec3(tmp.x, tmp.y / iAspect, camPos.z + screenDist);\n  }\n\n  vec3 rayDir = normalize(pxlPos - camPos);\n\n  float maxZ = pxlPos.z + maxDist;\n\n  vec3 pt = pxlPos;\n\n  float finalDist;\n\n  int steps = 0;\n\n  bool hitSomething = false;\n\n  const float skyBrightness = 0.2;\n\n  oColor = vec4(skyBrightness);\n\n\n  while (length(pt) < maxZ) {\n    vec4 sdf = sdfScene(pt);\n    finalDist = sdf.x;\n    if (finalDist <= 0.0001) {\n      hitSomething = true;\n      vec3  n = sdfNormal(pt);\n      float d = dot(n, lightDir);\n      vec3 refl = reflect(rayDir, n);\n      float edgeness = 1. - abs(dot(n, rayDir));\n      float rf = 0.;\n      if (refl.y < floorAmt) {\n        rf = floorCheck(pt, refl) * 0.6;\n      }\n      oColor = vec4(\n        (sin(sdf.w * 60.) * 0.2 + 0.7) * d,\n        (sin(sdf.x * 80.) * 0.2 + 0.7) * d,\n        (sin(sdf.y * 60.) * 0.2 + 0.6) * d,\n        1.0);\n      oColor = vec4(\n        max(oColor.x, rf),\n        max(oColor.y, rf),\n        max(oColor.z, rf),\n        1\n      );\n      float e = edgeness;\n      e = e * e * e * e;\n      e = e * e;\n      oColor -= vec4(e);\n      break;\n    }\n    const float minStep = 0.002;\n    float step = max(finalDist * 0.5, minStep);\n    // pt.z += step;\n    pt += rayDir * step;\n  }\n\n  if (!hitSomething) {\n    if (rayDir.y < floorAmt) {\n      float rf = floorCheck(camPos, rayDir);\n      oColor = vec4(rf, rf, rf, 1);\n\n    }\n  }\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    iAspect     = iResolution.x / iResolution.y;\n    iGlobalTime = iTime;\n    vTexcoord = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    otherMain();\n    fragColor = oColor;\n}","name":"Image","description":"","type":"image"}]}