{"ver":"0.1","info":{"id":"WsX3zj","date":"1546800711","viewed":141,"name":"Infiniballs ray marching","username":"Censacrof","description":"My frist shader.\n\nInspired by:\n   - https://youtu.be/svLzmFuSBhk (CodeParade)\n   - https://youtu.be/PGtv-dBi2wE (The Art of Code)\n\nBoth are very good channels, i suggest to check them out.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shading","trippy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define SPHERE vec4(0, 0, 0, 1)\n#define PLANE_HEIGHT -2.\nstruct distResult { float apparent; float real; };\ndistResult getDist(vec3 p)\n{\n    vec4 sphere = SPHERE; //+ vec4(0, 0, sin(iTime), 0);\n    \n    float dsA = length(loop(p, vec3(-5), vec3(5)) - sphere.xyz) - sphere.w;\n    float dsR = length(p - sphere.xyz) - sphere.w;\n    \n    float dp = length(p.y - PLANE_HEIGHT);\n    //return min(ds, dp);\n    \n    return distResult(dsA, dsR);\n}\n\nvec3 getNormal(vec3 p) {\n\tdistResult dRes = getDist(p);\n    float d = dRes.apparent;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).apparent,\n        getDist(p-e.yxy).apparent,\n        getDist(p-e.yyx).apparent);\n    \n    return normalize(n);\n}\n\n\n\n#define COLLISION_DISTANCE 0.001\nstruct rayMarchResult { vec3 endPos; bool collided; float totDist; float apparentDist; };\nrayMarchResult rayMarch(vec3 p, vec3 dir, float max_dist, int max_steps)\n{\n    distResult dRes;\n    float totDist = 0.;\n    bool collided = false;\n\tfor (int i = 0; i < max_steps; i++)\n    {\n        dRes = getDist(p);\n    \tfloat dist = dRes.apparent;\n        \n        if (dist < COLLISION_DISTANCE) {\n            collided = true;\n        \tbreak;\n        }\n        \n        if (dist > max_dist)\n            break;\n        \n        p += dir * dist;\n        totDist += dRes.real;\n    }\n    \n    return rayMarchResult(p, collided, totDist, dRes.apparent);\n}\n\n\nvec4 lightColor = vec4(1., 1., 1., 1.);\nvec3 lightDirection = vec3(1., 1., 1.);\nvec3 lightPosition = vec3(0, 5, 5);\nfloat lightRadius = 10.;\nfloat lightAmbient = 0.01;\nfloat getLightIntensity(vec3 p)\n{\n    float lightIntensity = 0.;\n    float lightDist = length(lightPosition - p);\n    vec3 dir = normalize(lightPosition - p);\n    rayMarchResult marchRes = rayMarch(\n        p + dir * (COLLISION_DISTANCE * 4.), \n        dir,\n        100.,\n        25\n    );\n    \n    if (!marchRes.collided && marchRes.totDist > lightDist)\n    {\n        lightIntensity = dot(dir, getNormal(p))* clamp(lightRadius / length(marchRes.endPos - lightPosition), 0., 1.);\n    }\n    \n    return clamp(\n     \tlightIntensity,\n        lightAmbient,\n        1.\n    );\n    \n\t/*//directional light\n\treturn clamp(\n     \tdot(lightDirection, getNormal(p)),\n        lightAmbient,\n        1.\n    );*/\n}\n\n#define PI 3.14159265359\n#define PI_HALVS 1.57079632679\n\n#define MAX_STEPS 100\n#define MAX_DIST 30.\nvec3 screenOffset = vec3(0., 0., 1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(vec3(0.), 1.);    \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 uv3d = vec3(uv, 0) + screenOffset; \n    \n    vec2 uvMouse = (iMouse.xy-.5*iResolution.xy)/min(iResolution.x, iResolution.y);    \n    \n    mat4 transform = translationMatrix(vec3(0, 0, iTime * 10.)) * \n        rotationMatrix(vec3(0, 0, 1), sin(iTime) / 8.) *\n        rotationMatrix(vec3(0, 1, 0), uvMouse.x * PI);\n                       \n    vec3 cameraPos = (transform * vec4(0, 0, 0, 1.)).xyz;\n    uv3d = (transform * vec4(uv3d, 1)).xyz;\n    vec3 dir = normalize(uv3d - cameraPos);\n    \n    \n    lightPosition = cameraPos + vec3(cos(iTime), 0, sin(iTime)) * 50.;//(transform * vec4(lightPosition, 1)).xyz; // += vec3(sin(iTime), sin(iTime), cos(iTime));\n    //lightColor = vec4(hsv2rgb(vec3(sin(iTime / 2.) * 0.2 + 0.5, 1, 1)), 1);\n    //lightRadius += clamp(sin(iTime / 2.), 0., 1.) * 50.;\n    \n    rayMarchResult marchRes = rayMarch(\n        cameraPos,\n        dir,\n        MAX_DIST,\n        MAX_STEPS\n    );\n    \n    if (marchRes.collided) // if ray collided\n    {\n        fragColor = lightColor * getLightIntensity(marchRes.endPos);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\nmat4 translationMatrix(vec3 t)\n{\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                t.x, t.y, t.z, 1.0);\n}\n\n\nvec3 loop(vec3 p, vec3 _min, vec3 _max)\n{    \n    return mod(p, _max - _min) + _min;\n}","name":"Common","description":"","type":"common"}]}