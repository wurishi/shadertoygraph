{"ver":"0.1","info":{"id":"XXcXWM","date":"1719088866","viewed":59,"name":"Box Box Intersection","username":"PrzemyslawZaworski","description":"Calculation of intersection between boxes, using Separating Axis Theorem. Unfortunately there is a bug somewhere, because code doesn't work properly for some rotations.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["collision","intersection","box","obb","abb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rotations\n\nmat3 RotationX(float x) \n{\n\treturn mat3(1.0,0.0,0.0,0.0,cos(x),sin(x),0.0,-sin(x),cos(x));\n}\n\nmat3 RotationY(float y) \n{\n\treturn mat3(cos(y),0.0,-sin(y),0.0,1.0,0.0,sin(y),0.0,cos(y));\n}\n\nmat3 RotationZ(float y) \n{\n\treturn mat3(cos(y),sin(y),0.0,-sin(y),cos(y),0.0,0.0,0.0,1.0);\n}\n\n// Intersection\n\nstruct Box\n{\n    vec3 position;\n    vec3 halfSize;\n    mat3 rotation;\n};\n\nvec2 GetInterval(Box box, vec3 axis)\n{\n    vec3 p = box.position;\n    vec3 e = box.halfSize;\n    mat3 m = box.rotation;\n    vec3 a[3];\n    a[0] = m[0];\n    a[1] = m[1];\n    a[2] = m[2];\n    vec3 vertices[8];\n    vertices[0] = p + a[0] * e.x + a[1] * e.y + a[2] * e.z;\n    vertices[1] = p - a[0] * e.x + a[1] * e.y + a[2] * e.z;\n    vertices[2] = p + a[0] * e.x - a[1] * e.y + a[2] * e.z;\n    vertices[3] = p + a[0] * e.x + a[1] * e.y - a[2] * e.z;\n    vertices[4] = p - a[0] * e.x - a[1] * e.y - a[2] * e.z;\n    vertices[5] = p + a[0] * e.x - a[1] * e.y - a[2] * e.z;\n    vertices[6] = p - a[0] * e.x + a[1] * e.y - a[2] * e.z;\n    vertices[7] = p - a[0] * e.x - a[1] * e.y + a[2] * e.z;\n    vec2 result;\n    result.x = result.y = dot(axis, vertices[0]);\n    for (int i = 1; i < 8; ++i)\n    {\n        float projection = dot(axis, vertices[i]);\n        result.x = min(result.x, projection);\n        result.y = max(result.y, projection);\n    }\n    return result;\n}\n\nbool Intersection(Box box1, Box box2)\n{\n    mat3 m1 = box1.rotation;\n    mat3 m2 = box2.rotation;\n    vec3 axes[15];\n    axes[0]  = m1[0];\n    axes[1]  = m1[1];\n    axes[2]  = m1[2];\n    axes[3]  = m2[0];\n    axes[4]  = m2[1];\n    axes[5]  = m2[2];\n    axes[6]  = cross(axes[0], axes[3]);\n    axes[7]  = cross(axes[0], axes[4]);\n    axes[8]  = cross(axes[0], axes[5]);\n    axes[9]  = cross(axes[1], axes[3]);\n    axes[10] = cross(axes[1], axes[4]);\n    axes[11] = cross(axes[1], axes[5]);\t\n    axes[12] = cross(axes[2], axes[3]);\n    axes[13] = cross(axes[2], axes[4]);\n    axes[14] = cross(axes[2], axes[5]);\n    for (int i = 0; i < 15; ++i)\n    {\n        vec2 a = GetInterval(box1, axes[i]);\n        vec2 b = GetInterval(box2, axes[i]);\n        bool overlapOnAxis = ((b.x <= a.y) && (a.x <= b.y));\n        if (overlapOnAxis == false)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Raymarching\n\nfloat BoxSDF(vec3 p, Box box)\n{\n    vec3 q = abs(box.rotation * (p - box.position)) - box.halfSize;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat Map(vec3 p, Box box1, Box box2)\n{\n    float a = BoxSDF(p, box1);\n    float b = BoxSDF(p, box2);\n    return min(a, b);\n}\n\nvec4 Lighting(vec3 p, float e, Box box1, Box box2)\n{\n    vec3 l = normalize(vec3(1, 1, -1));\n    float c = (Map(p + l * e, box1, box2) - Map(p, box1, box2)) / e;\n    return vec4(clamp(c, 0.1, 1.0));\n}\n\nvec4 Raymarching(vec3 p, vec3 rd, Box box1, Box box2)\n{\n    for (int i = 0; i < 64; i++)\n    {\n        float t = Map(p, box1, box2);\n        if (t<0.001) return Lighting(p, 0.001, box1, box2);         \n        p += t * rd;\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.3, 0.2, -4.5);\n    vec3 rd = normalize(vec3(uv, 2.0));   \n    Box box1 = Box(vec3(-1.3,0.0,0.0), vec3(1.0), RotationZ(sin(iTime * 0.5)));   \n    Box box2 = Box(vec3( 1.3,0.0,0.0), vec3(1.0), RotationZ(cos(iTime * 0.5)));      \n    bool intersection = Intersection(box1, box2);\n    vec4 color = Raymarching(ro, rd, box1, box2);    \n    fragColor = intersection ? color * 4.0 : color;\n}","name":"Image","description":"","type":"image"}]}