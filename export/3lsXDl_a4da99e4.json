{"ver":"0.1","info":{"id":"3lsXDl","date":"1564650111","viewed":165,"name":"Mostly Grey","username":"peet","description":"Just a little optical illusion test. 6 RGB spheres mixing.\nUsing IQ's colourspace conversion functions to saturate/desaturate some pixels","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","optical","illusion","grey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n// Trying out some raymarching, and combining it with Schlicks Approximation //////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_EPSILON 0.01\n#define MARCH_ITERATIONS 40\n\n#define SMOOTH_DIST 0.5\n#define MAT_CHANGE 0.1\n\n#define TOO_FAR 10000.0\n\n#define REFLECT_ITERATIONS 2\n#define EPSILON 0.0001\n#define MSAA 3.0\n\n#define NUM_SPHERES 6\n\n#define HURRY_UP 1.5\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    Material mat;\n};\n    \nstruct Light {\n    vec3 dir;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\n    \n///////////////////////////////////////////////////////////////////////////////////\n        \nSphere g_spheres[NUM_SPHERES];\n\nLight g_light = Light(normalize(vec3(1.0, -1.0, 1.0)), vec3(150.0, 100.0, 50.0));\n\n///////////////////////////////////////////////////////////////////////////////////\n\nconst float eps = 0.0000001;\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nvec3 rgb2hsl( vec3 col )\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + eps)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              // H\n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + eps),  // S\n                 (minc+maxc)*0.5 );                           // L\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF's & other spatial query functions\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sphereSDF(Sphere sphere, vec3 p) \n{\n    return length(sphere.pos - p) - sphere.radius;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    float mindist = TOO_FAR;\n    for (int i=0; i<NUM_SPHERES; i++)\n    {\n        float dist = sphereSDF(g_spheres[i], p);\n        dist = opSmoothUnion(mindist, dist, SMOOTH_DIST);\n        if (dist < mindist)\n        {\n        \tmindist = dist;    \n        }\n    }\n      \n\treturn mindist;\n}\n\nMaterial materialAt(vec3 p)\n{\n    float mindist = TOO_FAR;\n    float weight = 1.0f;\n    Material mat = Material(vec3(0.0), 0.0, 0.0);\n    \n    for (int i=0; i<NUM_SPHERES; i++)\n    {\n        float dist = sphereSDF(g_spheres[i], p);\n        if (dist < SMOOTH_DIST)\n        {\n            float scale = (SMOOTH_DIST-dist)/SMOOTH_DIST;\n       \n        \tmat.colour += g_spheres[i].mat.colour * scale;                    \n        \tmat.diffuse += g_spheres[i].mat.diffuse * scale;                    \n        \tmat.specular += g_spheres[i].mat.specular * scale;                    \n            mindist = dist;\n        }\n    }\n        \n    if (mindist<SMOOTH_DIST)\n        return mat;\n    else\n\t\treturn g_NoMaterial;\n}\n\nResult resultSDF(vec3 p)\n{\n    Result result;\n\tresult.normal.x = sceneSDF(p + vec3(EPSILON, 0.0, 0.0)) - sceneSDF(p);\n\tresult.normal.y = sceneSDF(p + vec3(0.0, EPSILON, 0.0)) - sceneSDF(p);\n\tresult.normal.z = sceneSDF(p + vec3(0.0, 0.0, EPSILON)) - sceneSDF(p);\n    result.normal = normalize(result.normal);\n    result.mat = materialAt(p);\n    result.pos = p;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch query, returning intersection point, normal, surface colour\n\nResult raymarch_query(Ray ray)\n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), g_NoMaterial);\n\tfor (int i=0; i<MARCH_ITERATIONS; i++)\n    {\n    \tfloat signeddist = sceneSDF(ray.pos);\n        \n        ray.pos += signeddist*ray.dir*1.4;       \n    }\n    result = resultSDF(ray.pos);\n    return result;\n}\n\nvec3 raymarch(Ray inputray)\n{\n    const float exposure = 1e-2;\n    const float gamma = 2.2;\n    const float intensity = 100.0;\n    const vec3 ambient = vec3(0.1, 0.1, 0.1) *1.0* intensity / gamma;\n\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    vec3 mask = vec3(1.0, 1.0, 1.0);\n    vec3 fresnel = vec3(1.0, 1.0, 1.0);\n    \n    Ray ray=inputray;\n        \n    for (int i=0; i<REFLECT_ITERATIONS; i++)\n    {\n        Result result = raymarch_query(ray);\n\n        if (result.mat.diffuse==0.0)\n        {\n            vec3 spotlight = vec3(1e4) * pow(clamp(dot(ray.dir, -g_light.dir),0.0,1.0), 250.0);\n\n            colour += mask * (ambient + spotlight); \n            break;\n        }\n        else\n        {              \n            vec3 r0 = result.mat.colour.rgb * result.mat.specular;\n            float hv = clamp(dot(result.normal, -ray.dir), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;            \n                        \n            colour += clamp(dot(result.normal, -g_light.dir), 0.0, 1.0) * g_light.colour\n                * result.mat.colour.rgb * result.mat.diffuse\n                * (1.0 - fresnel) * mask / fresnel;\n                        \n            Ray reflectray;\n            reflectray.pos = result.pos + result.normal*MARCH_EPSILON*2.0f;\n            reflectray.dir = reflect(ray.dir, result.normal);\n            ray = reflectray;\n        }\n    }\n        \n    colour.xyz = vec3(pow(colour * exposure, vec3(1.0 / gamma)));    \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// initialise all the primitives\n\nvoid setupscene()\n{   \n    // scene definition    \n    for (int i=0; i<NUM_SPHERES; i++)\n    {\n        vec3 origin;\n        origin.x = 2.0 - perlin(HURRY_UP*iTime*0.212, float(i) + 1.0)*4.0;\n        origin.y = 2.0 - perlin(HURRY_UP*iTime*0.341, float(i) + 2.0)*4.0;\n        origin.z = 4.0 + perlin(HURRY_UP*iTime*0.193, float(i) + 3.0)*2.0;\n        float radius = 1.0;\n        \n        g_spheres[i].pos = origin;\n        g_spheres[i].radius = radius;\n        g_spheres[i].mat = Material(vec3(1.0), 1.0, 0.1);        \n    }    \n    \n    g_spheres[0].mat.colour = vec3(1.0, 0.0, 0.0);\n    g_spheres[1].mat.colour = vec3(0.0, 1.0, 0.0);\n    g_spheres[2].mat.colour = vec3(0.0, 0.0, 1.0);\n    g_spheres[3].mat.colour = vec3(1.0, 0.0, 0.0);\n    g_spheres[4].mat.colour = vec3(0.0, 1.0, 0.0);\n    g_spheres[5].mat.colour = vec3(0.0, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop, iterate over the pixels, doing MSAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n\tsetupscene();\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float factor = 1.0/(MSAA*MSAA);\n    \n    for (float x=0.0; x<MSAA; x++)\n    {\n        for (float y=0.0; y<MSAA; y++)\n        {\n            vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            uv.x += (1.0/(iResolution.x*MSAA))*x;\n            uv.y += (1.0/(iResolution.y*MSAA))*y;\n            \n            Ray ray;\n            ray.pos = vec3(0.0, 0.0, 0.0);\n            ray.dir = uv.xyx;\n            ray.dir.z = 1.0;\n            ray.dir = normalize(ray.dir);\n\n            fragColor.xyz += raymarch(ray)*factor;\n        }        \n    }\n    \n    float amount = 0.5 + sin(iTime)*0.5;\n    \n    if ((floor(mod(fragCoord.y, 8.0)) != 0.0) && (floor(mod(fragCoord.x, 8.0)) != 0.0) && amount>0.1)\n    {\n        fragColor.xyz = rgb2hsv(fragColor.xyz);\n        fragColor.y=0.0;\n        fragColor.xyz = hsv2rgb(fragColor.xyz);\n    }\n    else\n    {\n        fragColor.xyz = rgb2hsv(fragColor.xyz);\n        fragColor.y=1.0;\n        fragColor.xyz = hsv2rgb(fragColor.xyz);        \n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"}]}