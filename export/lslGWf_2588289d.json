{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define MARCH_STEPS 48\n#define REFLECT_STEPS 32\n#define EPSILON 0.2\n#define PI 3.141592653\n\n\nvec3 place_pos = vec3(10.0,0.0,40.0);\n\nvec3 get_light_pos()\n{\n    return vec3(100.0*sin(iTime),200.0,300.0*cos(iTime));\n    //return vec3(100.0,200.0,300.0);\n}\n\nstruct Obj\n{\n\tfloat m_dist;\n\tint m_obj_idx;//0:floor 1:wall 2:piano body 3:w keys 4:b keys  5: sound board 6:gold mat 7:string\n};\n\nvoid Choose(in Obj obj1, in Obj obj2, out Obj obj)\n{\n\tif (obj1.m_dist> obj2.m_dist)\n\t{\n\t\tobj = obj2;\n\t}\n\telse\n\t{\n\t\tobj = obj1;\n\t}\n}\n\nfloat LightIntensity(in vec3 world_pos)\n{\n\tfloat temp = length(get_light_pos() - world_pos);\n\treturn 1.0 / (pow(temp, 1.5)*0.0002);\n}\n//------------------------------------------------------\nfloat Combine(float re1, float re2)\n{\n\tif (re1<0.0 || re2 <0.0)\n\t\treturn max(re1, re2);\n\treturn sqrt(re1*re1 + re2*re2);\n}\n\nfloat Subtract(float re1, float sub)\n{\n\tif (sub>0.0)\n\t\treturn re1;\n\treturn max(-sub, re1);\n}\n\nfloat MapBox(in vec3 pos, in vec3 half_size)\n{//center at (0,0,0)\n\tvec3 v = abs(pos)-half_size;\n\t\n\tif (v.x<0.0 || v.y <0.0 || v.z<0.0)\n\t\treturn max(max(v.x, v.y), v.z);\n\treturn length(v);\n}\n\nfloat MapBoxSim(in vec3 pos, in vec3 half_size)//no inside info\n{//center at (0,0,0)\n\treturn length(max(abs(pos)-half_size,0.0))-0.1;\n}\n\nfloat MapRoundBox(in vec3 pos, in vec3 half_size, in float r)//no inside info\n{\n\treturn length(max(abs(pos)-half_size,0.0))-r;\n}\n\nfloat Map2Box(in vec3 pos, in vec2 top_half_size, in vec2 bottom_half_size, in float half_h)\n{//center at (0,0,0)\n\tfloat y = abs(pos.y) - half_h;\n\tfloat p = pos.y*0.5/half_h + 0.5;\n\tp = clamp(p, 0.0,1.0);//bottom---top\n\tfloat x = abs(pos.x) - mix(bottom_half_size.x, top_half_size.x, p);\n\tfloat z = abs(pos.z) - mix(bottom_half_size.y, top_half_size.y, p);\n\t\n\tif (x<0.0 || y <0.0 || z<0.0)\n\t\treturn max(max(x, y), z);\n\treturn sqrt(x*x + y*y + z*z);\n}\n\nfloat MapCylinder(in vec3 pos, in float r, in float half_h)\n{\n\tfloat y = abs(pos.y) - half_h;\n\tfloat rr = length(pos.xz) - r;\n\treturn Combine(y, rr);\n}\n//-------------------------------------------------------------------------------------------\n//unit 100 == 1 meter\nvoid MapFloor(in vec3 world_pos, out Obj obj)\n{\n\tfloat dist = 150.0-abs(world_pos.y - 150.0);\n\tif (dist <= EPSILON)\n\t{\n\t\tobj.m_obj_idx = 0;\n\t}\n\t\n\tobj.m_dist = dist;\n}\n\nvoid MapWall(in vec3 world_pos, out Obj obj)\n{\t\n\tfloat x_dist = 200.0 - abs(world_pos.x);\n\tfloat z_dist = 300.0 - abs(world_pos.z);\n\tfloat dist = min(x_dist, z_dist);\n\tif (dist <= EPSILON)\n\t{\n\t\tobj.m_obj_idx = 1;\n\t}\n\tobj.m_dist = dist;\n}\n\n\nfloat MapPianoBodyShapeDist(in float x, in float y)\n{\n\tif (y > 118.0)\n\t{//semi circle\n\t\treturn sqrt((x+30.0)*(x+30.0)+(y-118.0)*(y-118.0)) - 45.0;\n\t}\n\tif (y>42.0)\n\t{\n\t\t//box\n\t\tfloat vx = -x - 75.0;\n\t\t//sin shape\n\t\tfloat sinv = sin(((y - 42.0)/76.0 + 0.5) * PI);\n\t\tsinv = x - (sinv*30.0 + 45.0);\n\t\t\n\t\tif (x<-30.0)\n\t\t{\n\t\t\treturn vx;\n\t\t}\n\t\treturn max(sinv, vx);\n\t}\n\tfloat xx = abs(x) - 75.0;\n\treturn Combine(xx, 42.0-y);\n}\n\nfloat MapCover0(in vec3 pos)\n{\n\tfloat re = MapPianoBodyShapeDist(-pos.x, pos.z);\n\tfloat re_2 = abs(pos.y) - 1.0;\n\treturn Combine(re, re_2);\n}\nfloat MapBody(in vec3 pos)\n{\n\tfloat re = MapPianoBodyShapeDist(-pos.x, pos.z);\n\tfloat re_2 = abs(pos.y) - 15.0;\n\treturn Combine(re, re_2);\n}\n\nvoid MapPianoBody(in vec3 world_pos, out Obj obj)\n{\n\tvec3 pos = world_pos + place_pos;\n\t\n\t//backfoot\n\tfloat re = Map2Box(pos - vec3(30.0, 40.0, 155.0), vec2(15.0,3.2), vec2(3.0,3.0), 35.0);\n\t\n\t//foot1\n\tfloat re_2 = Map2Box(pos - vec3(-67.0, 40.0, 12.0), vec2(5.0,12.5), vec2(3.0,3.0), 35.0);\n\tre = min(re, re_2);\n\t//foot2\n\tre_2 = Map2Box(pos - vec3(67.0, 40.0, 12.0), vec2(5.0,12.5), vec2(3.0,3.0), 35.0);\n\tre = min(re, re_2);\n\t\n\t//pedal box\n\tre_2 = MapBoxSim(pos - vec3(0.0, 10.0, 12.0), vec3(14.0,5.0,5.0));\n\tre = min(re, re_2);\n\t//pedal box2\n\tre_2 = Map2Box(pos - vec3(0.0, 42.5, 14.0), vec2(14.0,4.0), vec2(5.0,2.0), 35.0);\n\tre = min(re, re_2);\n\t\n\t//keyboard bottom\n\tre_2 = MapBoxSim(pos - vec3(0.0, 74.5, -9.0), vec3(75.0, 4.5, 9.0));\n\tre = min(re, re_2);\n\t\n\t//keyboard two side\n\tre_2 = MapBoxSim(pos - vec3(68.0, 77.0, -9.0), vec3(7.0, 7.0, 9.0));\n\tre = min(re, re_2);\n\tre_2 = MapBoxSim(pos - vec3(-70.0, 77.0, -9.0), vec3(5.0, 7.0, 9.0));\n\tre = min(re, re_2);\n\t\n\t{//open cover\n\t\tvec3 pos_trans = pos + vec3(-75, -99.0, 0.0);\n\t\tfloat angle = abs(fract((iTime +0.05)*0.05)-0.5);\n\t\tfloat sinv = sin(angle);\n\t\tfloat cosv = cos(angle);\n\t\tpos_trans.xy = pos_trans.xy * mat2(cosv, -sinv, sinv, cosv);\n\t\tpos_trans.x += 75.0;\n\t\tre_2 = MapCover0(pos_trans);\n\t\tre = min(re, re_2);\n\t\t\n\t\tre_2 = MapBoxSim(pos_trans - vec3(0.0, 3.0, 63.0), vec3(75.0, 1.0, 21.0));\n\t\tre = min(re, re_2);\n\t}\n\t\n\t{\n\t\tvec3 pos_temp = pos - vec3(0.0,83.0,21.0);\n\t\tfloat x = abs(pos_temp.x) - 75.0;\n\t\tfloat y = abs(pos_temp.y) - 13.0;\n\t\tfloat z = abs(pos_temp.z) - 21.0;\n\t\tz = Combine(x,z);//use to cal color\n\t\tif (pos_temp.z>0.0 && pos_temp.z<22.0)\n\t\t{\n\t\t\tz = x;\n\t\t}\n\t\tz = abs(z + 4.0) - 4.0;\n\t\tre_2 = Combine(z, y);\n\t\tre = min(re, re_2);\n\t\t\n\t\tpos_temp = pos - vec3(0.0,83.0,0.0);\n\t\ty = MapPianoBodyShapeDist(-pos_temp.x, pos_temp.z);//use to cal color\n\t\tif (pos_temp.z >40.0 && pos_temp.z<44.0)\n\t\t{\n\t\t\ty = abs(pos_temp.x) - 75.0;\n\t\t}\n\t\ty = abs(y + 4.0) - 4.0;\n\t\tz = abs(pos_temp.y) - 13.0;\n\t\tre_2 = Combine(y, z);\n\t\tre = min(re, re_2);\n\t\n\t\tif (re <= EPSILON)\n\t\t{\n\t\t\tobj.m_obj_idx = 2;\n\t\t}\n\t}\n\tobj.m_dist = re;\n}\n\nvoid MapBodySoundboard(in vec3 world_pos, out Obj obj)\n{\n\tvec3 pos = world_pos + place_pos -  vec3(0.0,80.0,-10.0);\n\tfloat re_3 = MapPianoBodyShapeDist(-pos.x, pos.z);\n\tfloat re_2 = abs(pos.y) - 6.0;\n\tfloat re = Combine(re_3, re_2) + 4.0;\n\t\n\tif (re< EPSILON)\n\t{\n\t\tobj.m_obj_idx = 5;\n\t}\n\tobj.m_dist = re;\n}\n\nvoid MapGoldObjs(in vec3 world_pos, out Obj obj)\n{\n\tvec3 pos = world_pos + place_pos;\n\t\n\t//wheel\n\tfloat re = MapCylinder((pos-vec3(-67.0, 3.0, 12.0)).xzy, 2.5, 5.0);\n\tfloat re_2 = MapCylinder((pos-vec3(67.0, 3.0, 12.0)).zxy, 2.5, 5.0);\n\tre = min(re, re_2);\n\tre_2 = MapCylinder((pos-vec3(30.0, 3.0, 155.0)).xzy, 2.5, 5.0);\n\tre = min(re, re_2);\n\t\n\t//pedal\n\tre_2 = MapBoxSim(pos - vec3(0.0,7.0,3.0), vec3(2.0, 0.5, 5.0));\n\tre = min(re, re_2);\n\tre_2 = MapBoxSim(pos - vec3(9.0,7.0,3.0), vec3(2.0, 0.5, 5.0));\n\tre = min(re, re_2);\n\tre_2 = MapBoxSim(pos - vec3(-9.0,7.0,3.0), vec3(2.0, 0.5, 5.0));\n\tre = min(re, re_2);\n\t\n\t//inner box\n\tre_2 = MapBoxSim(pos - vec3(0.0, 80.0, 18.0), vec3(70.0, 10.0, 14.0));\n\tre = min(re, re_2);\n\t\n\t//inner\n\t{\n\t\tvec3 pos_1 = pos -  vec3(0.0,85.0,0.0);\n\t\tfloat re_3 = MapPianoBodyShapeDist(-pos_1.x, pos_1.z);\n\t\tfloat re_2 = abs(pos_1.y) - 14.0;\n\t\tre_2 = Combine(re_3, re_2) + 10.0;\n\t\t\n\t\tfloat sinv = sin(-0.66);\n\t\tfloat cosv = cos(-0.66);\n\t\tpos_1.x -= 40.0;\n\t\tpos_1.z -=30.0;\n\t\tpos_1.xz = pos_1.xz * mat2(cosv, -sinv, sinv, cosv);\n\t\tre_3 = MapBox(pos_1, vec3(110.0,25.0,60.0));\n\t\tre_2 = Subtract(re_2, re_3);\n\t\tre_2 += 3.0;\n\t\t\n\t\t//line\n\t\tre_3 = MapBoxSim(pos - vec3(-59.0, 85.0, 27.0), vec3(1.0, 10.0, 23.0));\n\t\tre_2 = min(re_2, re_3);\n\t\tre_3 = MapBoxSim(pos - vec3(-30.0, 85.0, 40.0), vec3(1.0, 10.0, 36.0));\n\t\tre_2 = min(re_2, re_3);\n\t\tre_3 = MapBoxSim(pos - vec3(-4.0, 85.0, 50.0), vec3(1.0, 10.0, 46.0));\n\t\tre_2 = min(re_2, re_3);\n\t\tre_3 = MapBoxSim(pos - vec3(26.0, 85.0, 70.0), vec3(1.0, 10.0, 66.0));\n\t\tre_2 = min(re_2, re_3);\n\t\tre_3 = MapBoxSim(pos - vec3(62.0, 85.0, 75.0), vec3(1.0, 10.0, 71.0));\n\t\tre_2 = min(re_2, re_3);\n\t\t\n\t\t//hole\n\t\tre_3 = MapCylinder(pos - vec3(-42.0, 85.0, 60.0), 4.0, 10.0);\n\t\tre_2 = Subtract(re_2, re_3);\n\t\tre_3 = MapCylinder(pos - vec3(-17.0, 85.0, 82.0), 5.0, 10.0);\n\t\tre_2 = Subtract(re_2, re_3);\n\t\tre_3 = MapCylinder(pos - vec3(9.0, 85.0, 115.0), 6.0, 10.0);\n\t\tre_2 = Subtract(re_2, re_3);\n\t\t\n\t\tre = min(re, re_2);\n\t}\n\t\n\tif (re< EPSILON)\n\t{\n\t\tobj.m_obj_idx = 6;\n\t}\n\tobj.m_dist = re;\n}\n\nvoid MapString(in vec3 world_pos, out Obj obj)\n{\n\tvec3 pos = world_pos + place_pos - vec3(0.0, 85.0,80.0);\n\t\n\tfloat re = MapBox(world_pos + place_pos - vec3(0.0, 85.0,80.0), vec3(56.5,0.001,54.0));\n\t\n\tfloat sinv = sin(-0.66);\n\tfloat cosv = cos(-0.66);\n\tpos.z -= 80.0;\n\tpos.xz = pos.xz * mat2(cosv, -sinv, sinv, cosv);\n\tfloat re_2 = MapBox(pos, vec3(130.0,25.0,60.0));\n\tre = Subtract(re, re_2);\n\t\n\tif (re< EPSILON)\n\t{\n\t\tre_2 = (world_pos.x + 56.5)/113.0*88.0;\n\t\tre_2 = abs(fract(re_2) - 0.5);\n\t\tif (re_2 < 0.499)\n\t\t\tre = max(re, re_2*2.5681818181818181818181818181818);\n\t}\n\t\n\tif (re< EPSILON)\n\t{\n\t\tobj.m_obj_idx = 7;\n\t}\n\tobj.m_dist = re;\n}\n\nvoid MapBlackKeys(in vec3 world_pos, out Obj obj)\n{\n\tvec3 pos = world_pos + place_pos - vec3(-2.0, 82.75, -5.0);\n\tfloat re = MapBoxSim(pos, vec3(63.0, 0.75, 5.0));\n\t\n\tif (re <= EPSILON)\n\t{\n\t\tfloat x = clamp(pos.x/126.0 + 0.5, 0.0, 1.0);//0--1\n\t\tif (x<0.03175)//high pitch clamp\n\t\t{\n\t\t\tre = max(re, (0.03175-x)*126.0);\n\t\t}\n\t\telse if (x> 0.984)//low pitch clamp\n\t\t{\n\t\t\tre = max(re, (1.0-x)*126.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx = clamp(x-0.02, 0.0,1.0);\n\t\t\tx = fract(x*7.4285714285714285714285714285714);//group num\n\t\t\tif (x<0.1)//#A -- B\n\t\t\t\tre = max(re, (0.1-x)*7.4285714285714285714285714285714);\n\t\t\telse if (x>0.8861)//C---#C\n\t\t\t\tre = max(re, (x -0.8861)*7.4285714285714285714285714285714);\n\t\t\telse if (x>0.16 && x < 0.2476)//#G -- #A\n\t\t\t\tre = max(re, (0.2038-abs(x-0.2038))*7.4285714285714285714285714285714);\n\t\t\telse if (x>0.3343 && x< 0.395)//#F --- #G\n\t\t\t\tre = max(re, (0.36465-abs(x-0.36465))*7.4285714285714285714285714285714);\n\t\t\telse if (x>0.4817 && x< 0.6408)//#D -- #F\n\t\t\t\tre = max(re, (0.56125-abs(x-0.56125))*7.4285714285714285714285714285714);\n\t\t\telse if (x>0.7452 && x< 0.8159)//#C-- #D\n\t\t\t\tre = max(re, (0.78055-abs(x-0.78055))*7.4285714285714285714285714285714);\n\t\t}\n\t}\n\t\n\tif (re <= EPSILON)\n\t{\n\t\tobj.m_obj_idx = 4;\n\t}\n\tobj.m_dist = re;\n}\n\nvoid MapWhiteKeys(in vec3 world_pos, out Obj obj)\n{\n\tvec3 pos = world_pos + place_pos - vec3(-2.0, 80.5, -7.5);\n\tfloat re = MapBoxSim(pos, vec3(63.0, 1.5, 7.5));\n\tif (re <= EPSILON)\n\t{\n\t\tobj.m_obj_idx = 3;\n\t}\n\tobj.m_dist = re;\n}\n//--------------------------------------------------------------------------------------------\nvoid ReflectMap(in vec3 world_pos, out Obj obj)//just used duiring reflect rendering\n{\n\tObj obj_2;\n\tobj_2.m_obj_idx = -1;\n\t\n\tMapFloor(world_pos, obj);\n\tMapWall(world_pos, obj_2);\n\tChoose(obj, obj_2, obj);\n\t\n\tMapWhiteKeys(world_pos, obj_2);\n\tChoose(obj, obj_2, obj);\n\t\n\tMapBlackKeys(world_pos, obj_2);\n\tChoose(obj, obj_2, obj);\n\t\n\tMapBodySoundboard(world_pos,obj_2);\n\tChoose(obj, obj_2, obj);\n\t\n\tMapString(world_pos,obj_2);\n\tChoose(obj, obj_2, obj);\n\t\n\tMapGoldObjs(world_pos, obj_2);\n\tChoose(obj, obj_2, obj);\n}\n\n//negative means inside\nvoid Map(in vec3 world_pos, out Obj obj)//all rendering\n{\n\tObj obj_2;\n\tobj_2.m_obj_idx = -1;\n\t\n\tReflectMap(world_pos, obj);\n\tMapPianoBody(world_pos, obj_2);\n\tChoose(obj, obj_2, obj);\n}\n\nvoid GetNormal(in vec3 pos, in vec3 cam_up, in vec3 cam_right, in vec3 cam_forward, in Obj obj, out vec3 normal)\n{\n\tObj obj_copy = obj;\n\tvec3 pos_up = pos + cam_up * EPSILON;\n\tvec3 pos_down = pos - cam_up * EPSILON;\n\tvec3 pos_left = pos - cam_right * EPSILON;\n\tvec3 pos_right = pos + cam_right * EPSILON;\n\t\n\t//up\n\tobj_copy.m_obj_idx = -1;\n\tMap(pos_up, obj_copy);\n\tpos_up += cam_forward * obj_copy.m_dist;\n\t\n\t//down\n\tobj_copy.m_obj_idx = -1;\n\tMap(pos_down, obj_copy);\n\tpos_down += cam_forward * obj_copy.m_dist;\n\t\n\t//left\n\tobj_copy.m_obj_idx = -1;\n\tMap(pos_left, obj_copy);\n\tpos_left += cam_forward * obj_copy.m_dist;\n\t\n\t//right\n\tobj_copy.m_obj_idx = -1;\n\tMap(pos_right, obj_copy);\n\tpos_right += cam_forward * obj_copy.m_dist;\n\t\n\tnormal = normalize(cross(pos_right-pos_left, pos_up-pos_down));\n}\n\nvoid Reflect(in vec3 dir, in vec3 pos, out Obj obj, out vec3 reflect_pos)\n{\n\tfloat march_len = 1.0;\n\tfor (int i=0; i< REFLECT_STEPS; ++i)\n\t{\n\t\treflect_pos = pos + dir * march_len;\n\t\tReflectMap(reflect_pos, obj);\n\t\tif (obj.m_dist<= EPSILON)\n\t\t{\n\t\t\treflect_pos += dir * obj.m_dist;\n\t\t\tbreak;\n\t\t}\n\t\tmarch_len += obj.m_dist;\n\t}\n}\n\nvec3 GetColorDiffuse(in Obj obj, in vec3 world_pos, in float c)\n{\n\tif (obj.m_obj_idx == 0)\n\t{\n\t\treturn texture(iChannel0, fract(world_pos.xz * 0.015)).rgb * c;\n\t}\n\telse if (obj.m_obj_idx == 1)\n\t{\n\t\tfloat x_dist = 200.0 - abs(world_pos.x);\n\t\tfloat z_dist = 300.0 - abs(world_pos.z);\n\t\tif (x_dist > z_dist)\n\t\t{\n\t\t\treturn texture(iChannel1, fract(world_pos.xy * 0.05)).rgb * c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn texture(iChannel1, fract(world_pos.zy * 0.05)).rgb * c;\n\t\t}\n\t}\n\telse if (obj.m_obj_idx == 2)\n\t{\n\t\treturn vec3(0.02*c, 0.02*c, 0.02*c);\n\t}\n\telse if (obj.m_obj_idx == 3)\n\t{\n\t\tfloat x = clamp((world_pos.x+place_pos.x+2.0)/126.0 + 0.5, 0.0, 1.0) * 52.0;\n\t\tx = 0.5 - abs(fract(x) - 0.5);\n\t\tif (x<0.05)\n\t\t\tc*=x*20.0;\n\t\treturn vec3(1.0*c, 1.0*c, 0.90*c);\n\t}\n\telse if (obj.m_obj_idx == 4)\n\t{\n\t\treturn vec3(0.03*c, 0.03*c, 0.03*c);\n\t}\n\telse if (obj.m_obj_idx == 5)\n\t{\n\t\tfloat sinv = sin(0.7);\n\t\tfloat cosv = cos(0.7);\n\t\tvec2 uv = world_pos.xz * mat2(cosv, -sinv, sinv, cosv);\n\t\tuv.x = sin(uv.x*0.1);\n\t\tuv.y = sin(uv.y*0.002);\n\t\treturn texture(iChannel2, uv ).rgb * c;\n\t}\n\telse if (obj.m_obj_idx == 6)\n\t\treturn vec3(0.31,0.2,0.09)*c;//idx == 6\n\treturn vec3(0.31,0.31,0.31)*c;\n}\n\nvec3 GetColor(in Obj obj, in vec3 world_pos, in vec3 dir, in vec3 cam_up, in vec3 cam_forward, in vec3 cam_right)\n{\n\tfloat c = LightIntensity(world_pos);\n\tvec3 re = GetColorDiffuse(obj, world_pos, c);\n\t\n\t//specular\n\tvec3 normal = vec3(1.0,0.0,0.0);\n\tGetNormal(world_pos, cam_up, cam_right, cam_forward, obj, normal);\n\tvec3 ref_dir = normalize(reflect(dir, normal));\n\tfloat spec = dot(normalize(get_light_pos() - world_pos), ref_dir);\n\tspec = max(0.0,spec);\n\t\n\t//\n\t\n\tif (obj.m_obj_idx == 2)\n\t{\n\t\tspec *= 1.01;\n\t\tspec = pow(spec, 32.0);\n\t\tre += vec3(spec, spec, spec);\n\t\t\n\t\tObj obj_r;\n\t\tobj_r.m_obj_idx = -1;\n\t\tobj_r.m_dist = 9999.9;\n\t\tvec3 reflect_pos = world_pos;\n\t\tReflect(ref_dir, world_pos, obj_r, reflect_pos);\n\t\tfloat cc = LightIntensity(reflect_pos);\n\t\tvec3 reflect_color = GetColorDiffuse(obj_r, reflect_pos, cc);\n\t\t\n\t\tfloat brdf = 1.2- dot(ref_dir, normal);\n\t\tbrdf = pow(brdf, 4.0);\n\n\t\tre += reflect_color * brdf;\n\t}\n\telse if (obj.m_obj_idx !=4 && obj.m_obj_idx !=0 && obj.m_obj_idx !=1)\n\t{\n\t\tspec *= 1.11;\n\t\tspec = pow(spec, 10.0);\n\t\tre += vec3(spec, spec, spec);\n\t}\n\treturn re;\n}\n\nvec4 Render(in vec3 cam_pos, in vec3 cam_up, in vec3 cam_forward, in vec3 cam_right, in vec2 vp_pos)\n{\n\tObj obj;\n\tobj.m_obj_idx = -1;\n\tobj.m_dist = 9999.9;\n\t\n\tvec3 dir = normalize(cam_forward + vp_pos.x * cam_right + vp_pos.y * cam_up);\n\tvec3 pos;\n\tfloat march_len = 10.0;\n\tfor (int i=0; i< MARCH_STEPS; ++i)\n\t{\n\t\tpos = cam_pos + dir * march_len;\n\t\tMap(pos, obj);\n\t\tif (obj.m_dist<= EPSILON)\n\t\t{\n\t\t\tpos += dir * obj.m_dist;\n\t\t\tbreak;\n\t\t}\n\t\tmarch_len += obj.m_dist;\n\t}\n\t\n\tif (obj.m_obj_idx == -1)\n\t\treturn vec4(0.0,0.0,0.0, 1.0);\n\t\n\tvec3 color = GetColor(obj, pos, dir, cam_up, cam_forward, cam_right);\n\treturn vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.y / iResolution.x;\n\tconst float fov = 35.0 * 0.017453292519943295;\n\t\n\t//[-1,1]\n\tvec2 vp_pos = (fragCoord.xy/ iResolution.xy - 0.5) * 2.0;\n\t//x[-1,1] y[-h/w, h/w]\n\tvec2 vp_pos2 = vp_pos * vec2(1.0, aspect);\n\t\n\tfloat t = iTime * 0.3;\n\tvec3 cam_pos = vec3(sin(t)*140.0, 130.0+45.0*sin(0.33*t+9.876), cos(t+2.333333)*140.0);\n\t//vec3 cam_pos = vec3(sin(6094.7)*140.0, 175.0, cos(6094.7+2.333333)*140.0);\n\tvec3 target = vec3(0,75,0);//look at (0,75,0)\n\tvec3 cam_forward = normalize(target - cam_pos);\n\tvec3 cam_up = vec3(0.0,1.0,0.0);\n\tvec3 cam_right = normalize(cross(cam_forward, cam_up));\n\tcam_up = cross(cam_right, cam_forward);\n\t\n\tfragColor = Render(cam_pos, cam_up, cam_forward, cam_right, vp_pos2);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslGWf","date":"1391510923","viewed":763,"name":"my piano","username":"jedi_cy","description":"my kawai rx-2 grand piano","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","beginner","practice"],"hasliked":0,"parentid":"","parentname":""}}