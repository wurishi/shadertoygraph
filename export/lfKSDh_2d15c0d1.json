{"ver":"0.1","info":{"id":"lfKSDh","date":"1715128323","viewed":62,"name":"AK FYP23: Experimental Fireball","username":"AKHC","description":"Experimental fireball visual effect using gyroid pattern. Utilises previously made particle system, as well as lighting and modelling techniques from the Alien Orb shader, as well as raymarching distortion + palette experiments.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n#define TAU 6.283185\n\n#define SHELLTHICK 0.03\n\n#define stutterwave ((sin(T/2.*5.+sin(T*10.)*.2)) + 2.0)  / 2.\n//sin(x*5.+sin(x*20.)*.2)\n\nfloat ballGyroid(vec3 p, float scale)\n{\n    //p.yz *= Rot(T / 2.);\n    p.xz *= Rot(T * 2.2);\n\n    p *= scale;\n    float gyr = abs(0.7 * dot(sin(p), cos(p.yzx)) / scale) - 0.02;\n    return gyr;\n}\n\nfloat ballGyroidAlt(vec3 p, float scale)\n{\n    p.yz *= Rot(T * 2.);\n    p.xz *= Rot(sin(T * 1.2));\n    \n    p *= scale;\n    float gyr = abs(0.18 * dot(sin(p.zxy), cos(p.yzx)) / scale) - 0.02;\n    return gyr;\n}\n\n\nvec3 twistPoint(vec3 p, float scale)\n{\n    float k = sin(T * 4.) * scale; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n\n\n\nfloat Glitter(vec2 p, float a) //a = phase of the sparkle\n{\n    p *= 10.;\n    vec2 id = floor(p);\n    p = fract(p) - 0.5;    \n    float n = Hash21(id);\n    float disc = length(p);\n    float m = S(.3 * n,.0,disc);\n    \n    m *= pow((sin(a + fract(n*10.) * TAU) * 0.5) + .5, 100.);\n    return m;\n}\n\n\n#define GROUNDMOVE -T*3.\n\nfloat GetDist(vec3 p) {\n    float sphere1 = sdSphere(p, 1. * stutterwave);\n    sphere1 = abs(sphere1) - SHELLTHICK;\n    \n    float sphere2 = sdSphere(p, 0.7 * stutterwave);\n    sphere2 = abs(sphere2) - SHELLTHICK;\n\n    //float sphere2 = length(p) - 0.8;\n    \n    float gyr1 = ballGyroid(twistPoint(p, 2.), 10.);\n    float gyr2 = ballGyroidAlt(p, 10.);\n    \n    \n    sphere1 = smax(sphere1, gyr1, abs(sin(iTime)*0.025) + 0.025);\n    sphere2 = smax(sphere2, gyr2, abs(sin(iTime)*0.025) + 0.025);\n    \n    //float ground = p.y + 1.;\n    vec3 q = p*5.;\n    q.y += sin(.7) * 1.4;\n    \n    \n    q.z -= T * 2.;\n    float y = abs(dot(sin(q), cos(q.yzx))) * .1;\n\n\n    float onion = min(sphere1, sphere2);\n    \n    \n    \n    //displace test\n    \n    //float testSphere = sdSphere(p, 1.);\n   \n    //float un = dispPrim(testSphere, p, sin(iTime) * 0.3);\n   \n   \n    float sphereParts = sdParticleSystem(p, T, stutterwave);\n   \n    onion = smin(onion, sphereParts, 0.2);\n   \n    return onion;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\nvec3 RayPlane(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n    float t = max(0., dot(p-ro, n) / dot(rd, n)); //distance from plane\n    return ro + rd * t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float centerDist = dot(uv, uv); // center distance squared\n\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.y = max(-0.9,ro.y);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n\n    //old god rays\n    float a = atan(uv.x, uv.y); //-pi to pi, loops correctly in a trig function\n    float sb = sin(a * 11. - T) * cos(a*7.+T) * sin(a*5.+T*.2); //prime numbers don't easly fall on top of each other\n    sb *= S(0.0, 0.4, centerDist);\n    //col += palette1(fract(sb)) / 5.; //fracting this looks cool\n    float f = fract(sb);\n    col += vec3(f/1.2, f/5., f/3.) * palette1(iTime) / 2.;\n\n    //material rendering\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 lightDir = vec3(1,2,3);\n        float dif = dot(n, lightDir)*.5+.5;\n        float cd = length(p); //distance from origin\n        col = palette1(d);\n        \n        if(cd > 1. + SHELLTHICK + 0.005) //if distance is larger than radius of ball\n        {\n        \n            \n        }\n        else \n        {\n            float sss = .05/centerDist;\n            sss*=sss;\n            \n            float s = ballGyroid((p+sin(p*10. + T)) * 0.6, 10.);\n            \n            sss *= S(-0.03, 0., s);\n        }\n    }\n    \n    //2d lght\n    //center light    \n    float light = .003 / centerDist * (sin(T * 5.) + 2.) / 2.;\n    \n    //center glare\n    float s = ballGyroid(normalize(ro), 10.);\n    float glow = 0.003 / centerDist * (sin(T * 5.) + 2.) / 2.;;\n    \n    \n    //volumetrics  \n    vec3 pp = RayPlane(ro, rd, vec3(0), normalize(ro));\n    float sbb = ballGyroid(normalize(pp), 10.);\n    \n    \n    float b = atan(uv.y,uv.x);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction    \n    col += Glitter(uv, 1.);\n    \n    //vignette\n    //col *= (1. - centerDist * 1.2);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hash13(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, vec3(1.0, 19.0, 57.0));\n    return normalize((fract(sin(p3) * 43758.5453) * 2.0 - 1.0) * 0.1);\n}\n\nfloat Hash21(vec2 p)\n{\n    p = fract(p*vec2(123.34, 234.53));\n    p += dot(p, p+23.4);\n    return fract(p.x*p.y);\n}\n\nfloat hash11(float p, float range) { //0 to range\n     // Bias towards positive x-direction\n    // 13-bit hash function by inigo quilez - https://www.shadertoy.com/view/4dS3Wd\n    vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, vec3(1.0, 19.0, 57.0));\n    return fract(sin(p3.x) * 43758.5453) * range;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n  return mix (b, a, h) - k*h*(1.-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n  k = -k;\n  float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n  return mix (b, a, h) - k*h*(1.-h);\n}\n\n\nfloat dispPrim(float primitive, vec3 p, float freq)\n{\n    float f = freq;\n    float s = 1.;\n    return (primitive + sin(p.x*f)*sin(p.y * f)*sin(p.z * f) * s)/2.;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdOct( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdParticleSystem(in vec3 p, float T, float scale)\n{\n    //float disp = sin(5. * p.x * sin(T)) * sin(5. * p.y * sin(T + 1.)) * sin(5.0 * p.z * cos(T)) * 0.25; \n    p -= vec3(0,-0.,0);\n    \n    float rad = 0.1;    \n    float onion = sdSphere(p + vec3(T / 10.), rad * scale);\n   \n    for(float i = 0.; i < 100.; i++)\n    {\n        vec3 randDir = hash13(i/130.);\n        randDir.y = -abs(randDir.y) - 0.5;\n     \n        float randSpeed = (hash11(i/281., 1.) + 1.) * 3.;\n        \n        float randLifeTime = hash11(i/44., 2.) * 4.;\n    \n        float timeCurve = smoothstep(0., 1., fract(T/randSpeed));\n        vec3 xForm = p + randDir * timeCurve * randLifeTime ; //smoothstep(0., 1., fract(iTime)) * 4.;\n        \n        float disp2 = sin(5. * xForm.x * sin(T)) * sin(5. * xForm.y * sin(T + 1.)) * sin(5.0 * xForm.z * cos(T)) * 0.25;\n        \n        float newSphere = sdSphere(xForm, rad * (1.-timeCurve) * scale);\n        onion = smin(onion, newSphere, 0.5);\n    }\n\n    return onion;\n}\n\n\nvec3 palette1( in float t)\n{\n    vec3 a = vec3(0.756, 0.054, 0.590);\n    vec3 b = vec3(0.787, 0.227, 0.048);\n    vec3 c = vec3(1.195, 0.263, 0.702);\n    vec3 d = vec3(2.939, 0.116, 3.415);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}","name":"Common","description":"","type":"common"}]}