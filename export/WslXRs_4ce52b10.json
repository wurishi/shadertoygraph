{"ver":"0.1","info":{"id":"WslXRs","date":"1553785541","viewed":93,"name":"attempt at drawing a \"map\"","username":"BlueLightning42","description":"personal test...\nI want to figure out how to set up collisions with the different cell types","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["map"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define NO_DETAILS\n\nvec3 createForground(in vec2 st){\n    #ifndef NO_DETAILS\n    return texture(iChannel0, (fbm(vec2(st.x+ sin(iTime*1.5)*.1, st.y+ sin(iTime*1.4+1.5)*.15))*.5+st.xy) / iResolution.xy * 500.).rgr * .9;\n\t#endif\n    return vec3(.3,.2,.132);\n}\n\nvec3 createBackground(in vec2 st){\n    #ifndef NO_DETAILS\n    float dis = (1.0-distance(vec2(st.x-.5+sin(iTime*.9)*.1,st.y-.5+sin(iTime*1.5)*.1), vec2(0.0)));\n    return texture(iChannel1, st.xy / iResolution.xy * 2000.).rgb * pow(dis,5.0);\n\t#endif\n    return vec3(.8,.8,.9);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 bg = createBackground(uv);\n    vec3 fg = createForground(uv);\n    // fix grid so cells are square/centered\n\tvec2 p = uv * 14.0;\n\tp.x *= 1.5;\n\tp.x -= 3.5;\n      \n\tvec2 ipos = floor(p);\n\tvec2 fpos = fract(p);\n    \n    vec2 point = vec2(.5);\n    \n    \n\tfloat a = cellType(fpos, map[indexFromBuff(ipos)]);\n    #ifndef NO_DETAILS\n\ta += draw_rocks(fragCoord/iResolution.xy);\n    #endif\n    \n\tdraw(bg,fg,a);\n\n    // Output to screen\n    fragColor = vec4(bg,a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// dumbest possible way to save \"map\" data \n// but I can't for the life of me figure out how to send data to the shader\n// for a larger implementation this would be cpu side/stored in a file \n//14x 14 grid\nconst int map[196] = int[196](\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,5,0,0,4,5,0,0,0,1,1,1,1,\n1,5,0,0,0,0,0,0,0,0,1,1,1,1,\n1,0,0,0,0,0,0,0,0,0,1,1,1,1,\n1,0,0,0,0,0,0,0,0,0,1,1,1,1,\n1,0,0,0,0,0,0,0,0,0,1,1,1,1,\n1,0,0,0,0,0,0,0,0,0,1,5,4,1,\n1,0,0,0,0,0,0,0,0,0,0,0,0,1,\n1,0,0,0,0,0,0,0,0,0,0,0,0,1,\n1,0,0,0,0,0,2,3,0,0,0,0,0,1,\n1,3,0,0,2,1,1,5,0,0,0,0,0,1,\n1,1,1,1,1,1,5,0,0,2,1,1,1,1,\n1,1,1,1,1,1,0,0,2,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1\n);\n\nvoid draw(inout vec3 bg, in vec3 fg, in float a){\n    bg = mix(bg, fg, clamp(a, 0.0, 1.0));\n}\n\n\nfloat cellType(in vec2 st, in int type){\n    if(type == 0){ // ◻\n        return 0.0;\n    }else if(type == 1){ // ◼\n        return 1.0;\n    }else if(type == 2){ // ◢\n        return step(-st.x+st.y,0.0);\n    }else if(type == 3){ // ◣\n        return step(st.x+st.y,1.0);\n    }else if(type == 4){ // ◥\n        return step(-st.x-st.y,-1.0);\n    }else if(type == 5){ // ◤\n        return step(st.x-st.y,0.0);\n    }\n    \n}\n\n\n\n\nint indexFromBuff(in vec2 st){\n    return st.x <= 14.0 && st.x >= 0.0 ? int((13.-st.y)*14.+st.x) : 0;\n}\n\nfloat rand( in vec2 st ){\n    return fract(sin(dot(st, vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat rand( in float st, in float seed ){\n    return fract(sin(dot(vec2(st,seed), vec2(12.9898,78.233)))*43758.5453123);\n}\n\n\n//lazy details added randomly\nfloat draw_rocks(in vec2 st){\n\tfloat a = 0.0;\n \tst -= .13;\n    a += step(-rand(st.y,2.)*0.02-.078, -st.x);\n\tfloat rad = distance(st, vec2(0.0));\n    rad += rand(floor(atan(st.y/st.x)*40.0), .2);\n    \n\ta -= step(rad*2.0, .3)*2.;\n    st.x -= .6;\n    st.y -= .43;\n\trad = distance(st, vec2(0.0));\n    rad *= clamp(1.0-rand(floor(atan(st.y/st.x)*10.0), .2),0.4,1.);\n    a += step(rad, .02);\n    \n    st.y -= .2;\n    st.x -= .07;\n    \n    rad += rand(floor(atan(st.y/st.x)*80.0), .5);\n    \n\ta -= step(rad*2.0, .3)*2.;\n\treturn a;\n}\n\n\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\n\n\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"}]}