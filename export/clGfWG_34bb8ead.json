{"ver":"0.1","info":{"id":"clGfWG","date":"1702411044","viewed":48,"name":"Many floating spheres","username":"Gippogrife","description":"floating spheres","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SDF_DISTANCE .01\n#define RAYMARCH_STEPS 100\n#define MAX_DISTANCE 50.0\n\nconst int NUM_SPHERES = 15;\n\nstruct Ray {\n    vec3 direction;\n    vec3 origin;\n};\n\nvec2 random2D(vec2 st) {\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n              dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat smoothUnion(float distance1, float distance2, float k) {\n    float h = max(k - abs(distance1 - distance2), 0.0);\n    return min(distance1, distance2) - h * h * 0.25 / k;\n}\n\nfloat sphereDistance(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\nmat3 rotateZ(float angle) {\n    float sinAngle = sin(angle);\n    float cosAngle = cos(angle);\n    return mat3(vec3(cosAngle, sinAngle, .0),\n                vec3(-sinAngle, cosAngle, .0),\n                vec3(.0, .0, 1.));\n}\n\nfloat getMinSceneDistanceFromPoint(vec3 point) {\n    vec4 spheres[NUM_SPHERES];\n    \n    for (int i = 0; i < NUM_SPHERES; i++) {\n        spheres[i] = vec4(2.0 * sin(0.5 * iTime + float(i)), 1.0, 6.0 + 2.0 * cos(0.5 * iTime + float(i)), 0.4);\n        spheres[i].xyz *= rotateZ(0.2 * float(iTime) * float(i));\n    }\n\n    float minDistance = MAX_DISTANCE;\n\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        minDistance = smoothUnion(minDistance, sphereDistance(point - spheres[i].xyz, spheres[i].w), 0.5);\n    }\n\n    return minDistance;\n}\n\nfloat rayMarch(Ray ray) {\n    float distance_0 = 0.0;\n    for (int i = 0; i < RAYMARCH_STEPS; i++) {\n        vec3 target = ray.origin + ray.direction * distance_0;\n        float distance = getMinSceneDistanceFromPoint(target);\n        distance_0 += distance;\n        if (distance_0 > MAX_DISTANCE || distance < SDF_DISTANCE) {\n            return distance_0;\n        }\n    }\n}\n\nfloat gradientNoise(vec2 coordinates) {\n    vec2 integerPart = floor(coordinates);\n    vec2 fractionPart = fract(coordinates);\n    vec2 unit = fractionPart * fractionPart * (3.0 - 2.0 * fractionPart);\n    float valueA = dot(random2D(integerPart), fractionPart);\n    float valueB = dot(random2D(integerPart + vec2(1.0, 0.0)), fractionPart - vec2(1.0, 0.0));\n    float valueC = dot(random2D(integerPart + vec2(0.0, 1.0)), fractionPart - vec2(0.0, 1.0));\n    float valueD = dot(random2D(integerPart + vec2(1.0, 1.0)), fractionPart - vec2(1.0, 1.0));\n    return mix(mix(valueA, valueB, unit.x), mix(valueC, valueD, unit.x), unit.y);\n}\n\nfloat fractalBrownianMotion(vec2 coordinates) {\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    float total = 0.0;\n    float totalAmplitude = 0.0;\n    int octaves = 3;\n    float persistence = 0.5;\n    float lacunarity = 2.0;\n\n    for (int i = 0; i < octaves; i++) {\n        float noise = gradientNoise(coordinates * frequency + iTime * 0.5);\n        total += amplitude * noise;\n        totalAmplitude += amplitude;\n        frequency *= lacunarity;\n        amplitude *= persistence;\n    }\n\n    return total / totalAmplitude;\n}\n\nvec3 calculateShading(vec3 point) {\n    vec3 lightPosition = vec3(-5.0, 5.0, 2.0);\n    lightPosition.x += 4.0 * sin(iTime);\n    vec3 lightDirection = normalize(lightPosition - point);\n    float distance = getMinSceneDistanceFromPoint(point);\n    vec2 epsilon = vec2(0.01, 0);\n    vec3 normal = normalize(distance - vec3(getMinSceneDistanceFromPoint(point - epsilon.xyy),\n                                           getMinSceneDistanceFromPoint(point - epsilon.yxy),\n                                           getMinSceneDistanceFromPoint(point - epsilon.yyx)));\n    float diffuseContribution = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    float brownianColor = fractalBrownianMotion(point.xz) * 0.5 + 0.5;\n    vec3 colorSpectrum = abs(vec3(sin(iTime), cos(iTime), cos(iTime) + sin(iTime)));\n    float scaledBrownian = brownianColor * 0.5 + 0.5;\n    vec3 sphereColor = mix(colorSpectrum, vec3(scaledBrownian), 0.5);\n    vec3 finalColor = sphereColor * diffuseContribution;\n    Ray shadowRay;\n    shadowRay.origin = point + normal * SDF_DISTANCE * 2.0;\n    shadowRay.direction = lightDirection;\n    float shadowFactor = rayMarch(shadowRay);\n    return finalColor * 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y - (0.2, 0.2);\n    Ray ray;\n    ray.direction = normalize(vec3(uv.x, uv.y, 1.0));\n    ray.origin = vec3(0.0, 1.0, 0.0);\n    float distance = rayMarch(ray);\n    if (distance < MAX_DISTANCE) {\n        vec3 hitPoint = ray.origin + ray.direction * distance;\n        vec3 diffuse = calculateShading(hitPoint);\n        fragColor = vec4(vec3(diffuse), 1.0);\n    } else {\n        vec3 backgroundColor = vec3(uv.xy, 1.0);\n        fragColor = vec4(vec3(abs(cos(iTime)), abs(sin(iTime)), 1.0) / 4.0 + 0.1, 0.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}