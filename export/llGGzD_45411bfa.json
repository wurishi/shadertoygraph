{"ver":"0.1","info":{"id":"llGGzD","date":"1473505911","viewed":240,"name":"Double kifs","username":"stduhpf","description":"A basic kif with spheres replaced by others basic kifs","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fr_it 8\n\n#define axis vec3(2,1,0)\n\n#define axis2 vec3(0,1,2)\n\n#define mainshape vec3(.2)\n\n#define mainshape2 vec3(.04)\n\n#define scaling vec3(2)\n\n#define speed .4\n\n#define speed2 -.23\n\n#define dotsize .005\n\n#define camera_distance 2.\n#define pseudo_fov .75\n#define viewdist 5.\n\n#define prec .0001\n#define raymaxit 300\n\nmat3 r(float a, vec3 m)\n{\n    m= normalize(m);\n    float c = cos(a),s=sin(a);\n    return mat3(c+(1.-c)*m.x*m.x,\n                (1.-c)*m.x*m.y-s*m.z,\n                (1.-c)*m.x*m.z+s*m.y,\n                (1.-c)*m.x*m.y+s*m.z,\n                c+(1.-c)*m.y*m.y,\n                (1.-c)*m.y*m.z-s*m.x,\n                (1.-c)*m.x*m.z-s*m.y,\n                (1.-c)*m.y*m.z+s*m.x,\n                c+(1.-c)*m.z*m.z);\n}\n\nfloat ifs(vec3 p,float t, vec3 m,vec3 s)\n{\n    mat3 rot=r(t,m);\n    for(int i =0;i<fr_it;i++)\n    {\n        p= abs(p)-s;\n        p*=rot;\n        s/=scaling;\n      }\n return length(p)-dotsize ;    \n}  \nvec2 map(vec3 p)\n{\n    float t = iTime*speed;\n    //t = 0.;  //modulo 2pi : when the center of faces are flat\n    vec3 m =axis;\n    vec3 s =mainshape;\n    mat3 rot=r(t,m);\n    for(int i =0;i<fr_it;i++)\n    {\n        p= abs(p)-s;\n        p*=rot;\n        s/=scaling;\n      }\n return vec2(ifs(p,iTime*speed2,axis2,mainshape2),1) ;    \n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.01,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd,float n)\n{\n    float f=0.;\n    for(int i = 0; i <raymaxit; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<prec)\n                return vec2(f,h.x);\n               \tif(f > n)\n           break;\n            f+=h.x;\n    }\n    return vec2(0);\n}\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float f=0.01;\n    float e = 1.;\n    for(int i = 0; i <raymaxit; i++)\n    {\n        float d = map(ro+f*rd).x;\n        \n            if(d<.00001)\n            {\n                e=0.;\n             break;\n            }\n            f+=d;\n        e=min(e,8.*d/f);\n    }\n    return clamp(e,0.,1.);\n}\n\n\n\nfloat ao(vec3 p, vec3 n,float d)\n{\n    float h = map(p+d*n).x;\n    return d/(d+(d-h));\n}\n\n\nvoid mainImage( out vec4 fcol, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.x- vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    mse*=8.;\n    if(iMouse.xy==vec2(0))\n        mse*=0.;\nmat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nmat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n\n    vec3 ro = vec3(0,0,-camera_distance)*rdroty*rdrotx;\n    vec3 rd = normalize(vec3(uv,pseudo_fov))*rdroty*rdrotx;\n    float m =0.;\n    vec2 i = intersect(ro,rd,viewdist);\n    vec3 ld = normalize(vec3(1,1,-1));\n    \n    m+=.02/distance(rd,ld);\n    if(i.x>0.)\n    {\n    vec3 pos = ro+i.x*rd;\n    vec3 nor = normal(pos); \n    float amb =ao(pos,nor,.03);//cheap fake ambiant occlusion\n        m=amb;\n        float sh =shadow(pos,ld); //softshadows\n        m*=max(.1,dot(nor,ld)*sh); //aplly lighting\n        rd = reflect(rd,nor);\n    m+=.02/distance(rd,ld)*sh;; //specular highlighting\n        \n    }\n   \n    vec3 col = vec3(m);\n    fcol = vec4(col,m);\n}","name":"Image","description":"","type":"image"}]}