{"ver":"0.1","info":{"id":"csKyDz","date":"1695991598","viewed":54,"name":"WMO Weather codes","username":"Mesrine","description":"WMO Weather interpretation codes icons. I would like to implement transitions also from code to code. \nI am planning to use these shaders in an application. \nFollowing the design from https://worldweather.wmo.int/en/wxicons.html\n\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["icons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\nfloat Circle(vec2 uv,vec2 p, float r,float blur)\n{\n        float d = length(uv-p);\n        float c = smoothstep(r,r-blur,d);\n        return c;\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\nfloat sunlight(vec2 uv, vec2 p,float dcenter,float width, float height,\nfloat rep,float blur)\n{\n    float angle=2.0*PI/rep;\n    float f=0.0; \n    for(float a=0.0;a<rep;a++ )\n    {\n       f+=1.0-smoothstep(-blur,blur,\n    sdOrientedBox(uv,p+dcenter*vec2(cos(angle*a),sin(angle*a)),\n    p+(dcenter+height)*vec2(cos(angle*a),sin(angle*a)),width));\n\n    }\n\n    \n    return f;\n}\n\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nfloat cloud(vec2 uv, vec2 p,float width,float height,float blur)\n{\n    float f=1.0-smoothstep(-blur,blur,\n    sdRoundedBox(uv-p,vec2(width,height/2.5),vec4(min(width,height)*0.4)));\n    f+=Circle(uv,p+vec2(-width*0.33,height/2.1),width/2.2,blur);\n    f+=Circle(uv,p+vec2(width*0.33,height/2.1),width/2.9,blur);\n    return clamp(f,0.0,1.0);\n}\nfloat sun(vec2 uv, vec2 p,float radius, float lightstart,\nfloat lightheight,float lightwidth,float lightnumber,float blur)\n{\n    float f=Circle(uv,p,radius,blur);\n    f+=sunlight(uv,p,lightstart,lightwidth,lightheight,lightnumber,0.01);\n    return clamp(f,0.0,1.0);\n}\n\nfloat moon(vec2 uv, vec2 p,float radius,float angle,float blur)\n{\n    float f=Circle(uv,p,radius,blur);\n    f-=Circle(uv,p+0.6*radius*vec2(cos(angle),sin(angle)),radius,blur);\n    return clamp(f,0.0,1.0);\n}\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\nvec3 code_0_am(vec2 uv)\n{\n    float fsun=sun(uv,vec2(0.0),0.3+0.007*sin(3.0*iTime),0.35,\n    0.15+0.01*sin(3.0*iTime),0.1,9.0,0.02);\n    vec3 suncolor=vec3(0.58, 0.97, 0.02)*fsun;\n    return suncolor;\n}\nvec3 code_0_pm(vec2 uv)\n{\n    float fsun=moon(uv,vec2(0.0),0.4+0.007*sin(3.0*iTime),\n    0.4+0.1*sin(3.0*iTime),0.01);\n    float star1=1.0-smoothstep(-0.01,0.01,sdStar5(uv-vec2(-0.55,-0.2),0.1+0.01*sin(2.0*iTime),0.48));\n    float star2=1.0-smoothstep(-0.01,0.01,sdStar5(uv-vec2(0.2,0.35),0.05/(1.0+abs(sin(1.1*iTime))),0.48));\n    vec3 suncolor=vec3(0.58, 0.97, 0.02)*(fsun+star1+star2);\n    \n    return suncolor;\n}\nvec3 code_1_am(vec2 uv)\n{\n    float fsun=sun(uv,vec2(0.17,0.10),0.2+0.007*sin(3.0*iTime),0.25,\n    0.08+0.007*sin(3.0*iTime),0.05,9.0,0.01);\n    vec3 suncolor=vec3(0.58, 0.97, 0.02)*fsun;\n    float fcloud=cloud(uv,vec2(0.0,-0.2)+\n    vec2(0.01*sin(3.0*iTime),0.0),0.4,0.4,0.01);     \n    vec3 cloudcolor=vec3(0.97, 0.97, 0.97)*fcloud;\n    return mix(suncolor,cloudcolor,fcloud);\n}\nvec3 code_1_pm(vec2 uv)\n{\n    float fsun=moon(uv,vec2(0.17,0.15),0.3+0.007*sin(3.0*iTime),\n    0.6+0.1*sin(3.0*iTime),0.01);\n    float star1=1.0-smoothstep(-0.01,0.01,sdStar5(uv-vec2(-0.35,-0.0),0.1+0.01*sin(2.0*iTime),0.48));\n    float star2=1.0-smoothstep(-0.01,0.01,sdStar5(uv-vec2(0.3,0.3),0.05/(1.0+abs(sin(1.1*iTime))),0.48));\n    vec3 suncolor=vec3(0.58, 0.97, 0.02)*(fsun+star1+star2);\n    float fcloud=cloud(uv,vec2(0.0,-0.2)+\n    vec2(0.01*sin(3.0*iTime),0.0),0.4,0.4,0.01);     \n    vec3 cloudcolor=vec3(0.97, 0.97, 0.97)*fcloud;\n    return mix(suncolor,cloudcolor,fcloud);\n}\nvec3 code_2_am(vec2 uv)\n{\n    float fsun=sun(uv,vec2(0.17,0.10),0.2+0.007*sin(3.0*iTime),0.25,\n    0.08+0.007*sin(3.0*iTime),0.05,9.0,0.01);\n    vec3 suncolor=vec3(0.58, 0.97, 0.02)*fsun;\n    float fcloud=cloud(uv,vec2(-0.1,-0.2)+\n    vec2(0.01*sin(3.0*iTime),0.0),0.3,0.3,0.01);\n    fcloud+=cloud(uv,vec2(0.3,-0.1)+\n    vec2(0.01*cos(3.0*iTime),0.0),0.3,0.3,0.01);\n    fcloud=clamp(0.0,1.0,fcloud);\n    \n    float fcloud2=cloud(uv,vec2(0.2,-0.2)+\n    vec2(0.02*cos(4.0*iTime),0.0),0.2,0.2,0.01);\n    vec3 cloudback=vec3(0.57, 0.47, 0.85)*fcloud;\n    vec3 cloudfront=vec3(0.97, 0.97, 0.95)*fcloud2;\n    vec3 cloudcolor=mix(cloudback,cloudfront,fcloud2);\n    return mix(suncolor,cloudcolor,clamp(0.0,1.0,fcloud+fcloud2));\n}\nvec3 code_2_pm(vec2 uv)\n{\n    float fsun=moon(uv,vec2(0.17,0.15),0.3+0.007*sin(3.0*iTime),\n    0.6+0.1*sin(3.0*iTime),0.01);\n    float star1=1.0-smoothstep(-0.01,0.01,sdStar5(uv-vec2(-0.3,-0.0),0.1+0.01*sin(2.0*iTime),0.48));\n    float star2=1.0-smoothstep(-0.01,0.01,sdStar5(uv-vec2(0.3,0.3),0.05/(1.0+abs(sin(1.1*iTime))),0.48));\n    vec3 suncolor=vec3(0.58, 0.97, 0.02)*(fsun+star1+star2);\n    float fcloud=cloud(uv,vec2(-0.1,-0.2)+\n    vec2(0.01*sin(3.0*iTime),0.0),0.3,0.3,0.01);\n    fcloud+=cloud(uv,vec2(0.3,-0.1)+\n    vec2(0.01*cos(3.0*iTime),0.0),0.3,0.3,0.01);\n    fcloud=clamp(0.0,1.0,fcloud);\n    \n    float fcloud2=cloud(uv,vec2(0.2,-0.2)+\n    vec2(0.02*cos(4.0*iTime),0.0),0.2,0.2,0.01);\n    vec3 cloudback=vec3(0.57, 0.47, 0.85)*fcloud;\n    vec3 cloudfront=vec3(0.97, 0.97, 0.95)*fcloud2;\n    vec3 cloudcolor=mix(cloudback,cloudfront,fcloud2);\n    return mix(suncolor,cloudcolor,clamp(0.0,1.0,fcloud+fcloud2));\n}\nvec3 code_3(vec2 uv)\n{\n    float fcloud=cloud(uv,vec2(-0.1,-0.2)+\n    vec2(0.01*sin(3.0*iTime),0.0),0.3,0.3,0.01);\n    fcloud+=cloud(uv,vec2(0.3,-0.1)+\n    vec2(0.01*cos(3.0*iTime),0.0),0.3,0.3,0.01);\n    fcloud=clamp(0.0,1.0,fcloud);\n    \n    vec3 cloudback=vec3(0.57, 0.47, 0.85)*fcloud;\n    \n    \n    return cloudback;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n\n    //float f=sun(uv,vec2(0.0),0.4,0.45,0.25,0.15,10.0,0.01);\n    //float f= moon(uv,vec2(0.0),0.4,0.45,0.01);\n    \n    vec2 p=vec2(0.0);\n    float blur=0.01;\n    float width=0.4;\n    float height=0.4;\n    \n    float fsun=sun(uv,p+vec2(0.15,0.2),0.2+0.007*sin(3.0*iTime),0.25,\n    0.08+0.007*sin(3.0*iTime),0.05,9.0,blur);\n    float fcloud=cloud(uv,p+vec2(0.01*sin(3.0*iTime),0.0),width,height,blur);\n    \n    \n    \n    \n    vec3 cloudcolor=vec3(0.57, 0.47, 0.85)*fcloud;\n    \n    //vec3 color=mix(suncolor,cloudcolor,fcloud);\n    vec3 color=code_0_am(uv);\n    color=code_0_pm(uv);\n    //color=code_1_am(uv);\n    //color=code_1_pm(uv);\n    //color=code_2_am(uv);\n    color=code_2_pm(uv);\n    //color=code_3(uv);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}