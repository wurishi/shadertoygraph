{"ver":"0.1","info":{"id":"XcycWR","date":"1731672176","viewed":58,"name":"ShaderAmp  [SH18] BabyToy","username":"ArthurTent","description":"Rotate with mouse\nExample on YT: https://www.youtube.com/watch?v=8FmvUGyTrwc\nShaderAmp version is currently available in 'dev/more-shaders' branch.\nhttps://github.com/ArthurTent/ShaderAmp/tree/dev/more-shaders/dist/shaders","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["baby","human","boy","sh18","fetus","womb"],"hasliked":0,"parentid":"lldyWn","parentname":"[SH18] BabyToy"},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/lldyWn\n// Modified by ArthurTent\n// I've merged the buffer A and common buffer into Image, \n// added the stars and made some parts react to audio (look for FFT usage in the code)\n// Created by BigWings\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define FFT(a) pow(texelFetch(iChannel0, ivec2(a, 0), 0).x, 5.)\nfloat snd = 0.;\nconst float PI = 3.1415926;\n\n// MIT Licensed hash From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        //q*= snd/10.;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.65;\n}\nvoid camera(vec2 fragCoord, out vec3 ro, out vec3 rd, out mat3 t)\n{\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    //rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    rd = normalize(vec3(fragCoord, 1.0));\n\n    ro = vec3(0.0, 0.0, -15.);\n\n    //float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));\n    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y))+sin(iTime/20.);\n    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * (PI*2.0));\n    //m.y = -m.y;\n    m.y = sin(m.y*0.5)*0.3 + 0.5;\n\n    //vec2 sm = sin(m)*sin(iTime), cm = cos(m)*(1.+sin(iTime));\n    vec2 sm = sin(m)*(1.+sin(iTime/10.)/2.), cm = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cm.y, sm.y, 0.0, -sm.y, cm.y);\n    mat3 rotY = mat3(cm.x, 0.0, -sm.x, 0.0, 1.0, 0.0, sm.x, 0.0, cm.x);\n\n    t = rotY * rotX;\n\n    ro = t * ro;\n    rd = t * rd;\n\n    rd = normalize(rd);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat N2(vec2 p) {\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nvec3 N23(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 N23(float x, float y) {return N23(vec2(x, y));}\n\n\n\nfloat SmoothNoise(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n\n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n\n    return mix(top, bot, m.y);\n}\n\nfloat LayerNoise(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)*.5;\n    c += SmoothNoise(uv*16.)*.25;\n    c += SmoothNoise(uv*32.)*.125;\n    c += SmoothNoise(uv*65.)*.0625;\n\n    return c / 2.;\n}\n\nvec3 SmoothNoise3(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n\n    vec3 top = mix(N23(id.x, id.y), N23(id.x+1., id.y), m.x);\n    vec3 bot = mix(N23(id.x, id.y+1.), N23(id.x+1., id.y+1.), m.x);\n\n    return mix(top, bot, m.y);\n}\n\nvec3 LayerNoise3(vec2 uv) {\n    vec3 c = SmoothNoise3(uv*4.);\n    c += SmoothNoise3(uv*8.)*.5;\n    c += SmoothNoise3(uv*16.)*.25;\n    c += SmoothNoise3(uv*32.)*.125;\n    c += SmoothNoise3(uv*65.)*.0625;\n\n    return c / 2.;\n}\n\n\n/*\nfloat dEllipsoid(vec3 p, vec3 a, vec3 b, float r) {\n\tfloat d1 = length(p-a);\n    float d2 = length(p-b);\n    float d3 = length(a-b);\n    return mix(d1, d2, .5)-.5*d3-r;\n}*/\n\n\n// [SH18] BabyToy - by Martijn Steinrucken aka BigWings 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Takes a while to compile and needs a powerful graphics card to get a decent framerate.\n// mouse.x = rotate, mouse.y=light\n//\n// I did a rough sketch in Blender, using only spheres, to lay down the basics.\n//\n// I hacked in some decent translucency of the feet and hands that show a hint of the bones\n// at the cost of only one extra map call. Make sure you move the light down and have the\n// angle right to see it.\n//\n// Code is a bit of a mess and could probably be optimized more but it will never be perfect\n// and at some point you just gotta ship it. Hope you like!\n//\n// Music Mountain and Cloud - Thy Veils\n// https://soundcloud.com/thyveils/mountain-and-cloud\n// Heartbeat sound:\n// https://soundcloud.com/elderalcantara/heartbeat-sound\n//\n// Video of the effect can be found here:\n// https://youtu.be/czO9fTwVSYg\n\n// shows the baby without bubble deformation etc\n//#define DEVELOPER\n\n// I'm using bounding volumes for the head hands and feet so it doesn't\n// have to evaluate all the toes, nails wrinkles etc, if its still far away\n// should be faster..\n#define USE_BOUNDING_VOLUMES\n\n// turns on my hacky sub surface scattering implementation on the feet and hands\n#define USE_SSS\n\n\n// raymarch settings\n#define MIN_DIST .1\n#define MAX_DIST 8.\n#define MAX_STEPS 200.\n#define SURF_DIST .005\n\nfloat Map(vec3 p);\n\n\n// started out with this struct, not really using most of it so for this shader the\n// castray function could probably just return a vec4\nstruct de {\n    vec3 p;\n    vec3 rp;\n    float dm; \t\t// minimum passing distance\n    float mat;\n    float i;\t\t// number of iters before break\n};\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\n// like sdCapsule but this can vary width and smoothing along the length of it\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r1, float r2, float s1, float s2, float d )\n{\n\tvec3 pa = p-a, ba = b-a;\n    float t = dot(pa,ba)/dot(ba,ba);\n\tfloat h = clamp( t, 0.0, 1.0 );\n\td = smin(d, length( pa - ba*h ) - mix(r1, r2, S(0.,1.,h)), mix(s1, s2, h))*.98;\n\n    return d;\n}\n\n// I was trying to get more toe definition so I added an additional tweakable notch\n// Turns out that for the toes it didn't really work but it gave nice wrinkles at the\n// bottom of the foot. Lucky accident!\nfloat ToeCaps(vec3 p, vec3 a, vec3 b, float r1, float r2, float s1, float s2, float d, float x, float y, float k )\n{\n\tvec3 pa = p-a, ba = b-a;\n    float t = dot(pa,ba)/dot(ba,ba);\n\tfloat h = clamp( t, 0.0, 1.0 );\n\td = smin(d, length( pa - ba*h ) - mix(r1, r2, S(0.,1.,h)), mix(s1, s2, h))*.98;\n\n    float g = 1.-min(1., abs(h-x)*k);\n    d -= g*g*g*g*y;\n    return d;\n}\n\nvec3 GetRay(vec2 uv, vec3 p, vec3 lookat, vec3 up, float zoom) {\n    vec3 f = normalize(lookat-p),\n         r = normalize(cross(up, f)),\n         u = cross(f, r),\n         c = p+f*zoom,\n         i = c + r*uv.x + u*uv.y;\n\n    return normalize(i-p);\n}\n\n/*\nvec3 GetNormal( vec3 p ) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Map(p+eps.xyy) - Map(p-eps.xyy),\n\t    Map(p+eps.yxy) - Map(p-eps.yxy),\n\t    Map(p+eps.yyx) - Map(p-eps.yyx) );\n\treturn normalize(nor);\n}*/\n#define ZERO 0\n// Faster compilation by preventing inlining of Map function\n// Thanks IQ!\nvec3 GetNormal( vec3 p )\n{\n    const float eps = 0.01;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Map(p+eps*e);\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat dHand(vec3 p, vec3 pWrist) {\n    #ifdef USE_BOUNDING_VOLUMES\n    float handDist = length(p-(pWrist+vec3(.1,.35,.4)));\n    if(handDist>.95) return handDist-.65;\n    #endif\n\n    vec3 pThumb = pWrist+vec3(-.34, 0.43,.4);\n    vec3 piFinger = pWrist+vec3(-.13, .72,.64);\n    vec3 pmFinger = pWrist+vec3(.09, .74,.62);\n    vec3 prFinger = pWrist+vec3(.3, .68,.52);\n    vec3 pPinky = pWrist+vec3(.49, .54,.36);\n\n    pWrist -= vec3(0,-.1,.05);\n    float s1 = .05;\n    float s2 = .1;\n\n    float d = MAX_DIST;\n\n    d = Capsule(p, pWrist+vec3(0,0,0), pThumb, .2, .13, s1, s2, d);\n    d = Capsule(p, pThumb, pThumb+vec3(0,0,.2), .13, .12, .06, .01, d);\n    d = smin(d, length(pThumb+vec3(0.05,-.1,.2)-p)-.08, .1);\n\n    d = Capsule(p, pWrist+vec3(0,.0,0), piFinger, .2, .12, s1, s2, d);\n    d = Capsule(p, piFinger, piFinger+vec3(0,0,.2), .12, .11, .03, .01, d);\n    d = smin(d, length(piFinger+vec3(0.,-.1,.2)-p)-.08, .1);\n\n    d = Capsule(p, pWrist+vec3(0,.0,0), pmFinger, .2, .13, s1, s2, d);\n    d = Capsule(p, pmFinger, pmFinger+vec3(.025,0,.2), .12, .11, .03, .01, d);\n    d = smin(d, length(pmFinger+vec3(0.075,-.1,.2)-p)-.08, .1);\n\n    d = Capsule(p, pWrist+vec3(0,.0,0), prFinger, .2, .13, s1, s2, d);\n    d = Capsule(p, prFinger, prFinger+vec3(.05,0,.2), .12, .11, .03, .01, d);\n    d = smin(d, length(prFinger+vec3(0.075,-.1,.28)-p)-.08, .1);\n    d = min(d,  length(prFinger+vec3(0.08,-.08,.285)-p)-.08);\n\n    d = Capsule(p, pWrist+vec3(0,.0,0), pPinky, .2, .13, s1, s2, d);\n    d = Capsule(p, pPinky, pPinky+vec3(0.075,0,.2), .12, .11, .03, .01, d);\n    d = smin(d, length(pPinky+vec3(0.075,-.1,.28)-p)-.08, .1);\n     d = min(d, length(pPinky+vec3(0.08,-.08,.285)-p)-.08);\n\n    return d;\n}\n\nfloat dFoot(vec3 p, vec3 pAnkle) {\n    #ifdef USE_BOUNDING_VOLUMES\n    float footDist = length(p-(pAnkle+vec3(-.1,.6,.1)));\n    if(footDist>1.) return footDist-.75;\n    #endif\n\n    vec3 g = p;\n    p -= pAnkle;\n    vec3 pToe1 = vec3(-.6, 1.02,.21);\n    vec3 pToe2 = vec3(-.42, 1.15,.07);\n    vec3 pToe3 = vec3(-.24, 1.17,-.01);\n    vec3 pToe4 = vec3(-.05, 1.13,-.13);\n    vec3 pToe5 = vec3(.15, 1.02,-.24);\n\n    float d = ToeCaps(p, vec3(0), pToe1, .2, .13, .25, .05, MAX_DIST, .85, -.01, 8.);\n    d = ToeCaps(p, vec3(0), pToe2, .2, .1, .25, .05, d, .5, -.02, 8.);\n    d = ToeCaps(p, vec3(0), pToe3, .2, .1, .25, .05, d, .35, -.01, 6.);\n    d = ToeCaps(p, vec3(0), pToe4, .2, .1, .25, .04, d, .25, -.01, 6.);\n    d = Capsule(p, vec3(.2,.1,0), pToe5, .18, .09, .25, .07, d);\n\n    vec3 h = vec3(.05, .02, .0);\n\n    d = smin(d, length(p-(pToe5+vec3(.02, .02, .02)))-.08, .05);\n\n\n    float toeNails = length(pToe1-p-vec3(.05,0,.1)*.5)-.09;\n    toeNails = min(toeNails, length(pToe2-p-vec3(.05,0,.1)*.4)-.07);\n    toeNails = min(toeNails, length(pToe3-p-vec3(.05,0,.1)*.35)-.07);\n    toeNails = min(toeNails, length(pToe4-p-vec3(.05,0,.1)*.35)-.07);\n\n    d = smin(d, toeNails, .01);\n\n    return d;\n}\n\nfloat dHead(vec3 p) {\n    #ifdef USE_BOUNDING_VOLUMES\n    float headDist = length(p-vec3(-2.3,1.36,0));\n    if(headDist > 2.) return (headDist-1.6);\n    #endif\n\n    // head\n    vec3 hp = p-vec3(-2.71,1.36,0);\n    float d = length((hp)*vec3(1,1,1.2))-1.2;\t\t\t\t// back of head\n    d = smin(d, length(p-vec3(-2.06,1.71,0))-.94, .5);\t\t// forehead\n    d = smin(d, length(p-vec3(-1.83,1.02,0))-.94,.1);\t\t// jaws etc\n\n     // ears\n    vec3 tp = p-vec3(-2.27, .73, -.95);\n    tp.z -= tp.x*.4;\n    tp.z -= S(.9, .0, p.y)*.1;\n    tp.x += -.25*S(.3, -.4, tp.y+.1);\n    float dEar = length(tp.xy-vec2(.1, 0));\n    float ear = sdCylinder(tp.xzy-vec3(0,.18,0), vec2(.25, .15));\n    ear += cos(dEar*30.-3.)*.01;\n    ear = smin(ear, sdTorus(tp.xzy, vec2(.25, .043)), .05);\n    d = smin(d, ear*.8, .05);\n\n\n    d = smin(d, .12-length(p-vec3(-2.05, .7, -.94)), -.07);\n   // d = smin(d, .08-length(p-vec3(-2.0, .7, -.75)), -.04);\n\n\n    // eyes\n    vec3 ep = p-vec3(-1.37,1.46,-.4);\n    float ed = length(ep)-.3;\n    float slitFade = S(-.79, -.5, p.z);\n    slitFade *= S(-.1, -.5, p.z);\n    ed += S(.05*slitFade, 0., abs(ep.y-abs(ep.x*.6)))*.02*slitFade;\n    d = smin(d, ed, .1);\n\n    // mouth\n    float md = length((p-vec3(-.78,.9,0))*vec3(1,1,.4))-.09;\n    float noseGutter = cos(p.z*30.)*.2*S(.3, .0, -p.z)*.15*S(.85, 1.3, p.y);\n    md = smin(-md, length(p-vec3(-1.25,.98,0))-.56+noseGutter, -.075);\n    d = smin(d, md,.1+pow(abs(cos(iTime*.25)), 10.)*.175);\n\n    // nose\n    d = Capsule(p, vec3(-.9,1.37,0), vec3(-1.26,1.59,0), .2, .15, .1, .3, d);\n    float nd = length(p-vec3(-.83, 1.27, -.12))-.05;\n    d = smin(d, length(p-vec3(-.9,1.3,-.16))-.12,.1);\n    d = smin(-nd, d, -.14);\n\n    d = smin(d, length(p-vec3(-1.17,.611,0))-.348,.05);\t\t// chin\n\n    return d;\n}\n\nfloat dCord(vec3 p) {\n    #ifdef USE_BOUNDING_VOLUMES\n    float cordDist = sdCapsule(p, vec3(1, -1, 0), vec3(1, 5., 0),.01);\n    if(cordDist>.5 && p.y<4.) return (cordDist-.35);\n    #endif\n\n    vec3 up = p-vec3(1, -1, 0);\n    float g = p.y * 2.;\n    float r = .13+S(4., 6., p.y)*2.5;\n    up = p+vec3(sin(g), 0, cos(g))*.2;\n    float d = sdCapsule(up, vec3(1, -1, 0), vec3(1, 5., 0), r);\n    float a = atan(up.x-1., up.z);\n    d += sin(a*3.+p.y*7.)*.03;\n\n    return d*.8;\n}\n\nfloat dBody(vec3 p) {\n    #ifdef USE_BOUNDING_VOLUMES\n\tif(p.y>0.7) return p.y+.2;\n    if(abs(p.z)>1.5) return abs(p.z)-1.1;\n    #endif\n\n    float d = length(p-vec3(-2.16,.2,0))-.758;\t\t// neck\n    d -= abs(sin(p.x*-4.+p.y*20.))*.0075*S(0., 1., p.y+.25);\n\n    d = smin(d, length(p-vec3(-1.49,-.63,0))-.947,.25);\t\t// chest\n    d = smin(d, length(p-vec3(-.52,-1.09,0))-1.063,.35);\t// chest/body\n    d = smin(d, length(p-vec3(.41,-1.37,0))-1.09,.35);\t\t// belly\n     d -= abs(sin(p.x*8.+p.z*-2.))*.03*S(1., 0., abs(p.x+.2));\n    return d;\n}\n\nfloat Map(vec3 p) {\n    float d;\n    float m = iMouse.y/iResolution.y - .5;\n    float side = step(p.z, 0.)-.5;\n    vec3 offs = vec3(side, side*.2, -0.5);\n    float t= iTime;\n    float j = sin(t+sin(t));\n    offs.xy *= .5*j;\n\n    vec3 pm = vec3(p.x, p.y, -abs(p.z));\n\n    d = dHead(pm);\n    d = smin(d, dBody(pm), .1);\n    d = smin(d, dCord(p), .1);\n\n    // arm\n    vec3 pShoulder = vec3(-1.79,-.75,-1)+vec3(.2,.1,0);\n    vec3 pElbow = vec3(-.37, -1.05,-1.39);\n    vec3 pWrist = vec3(-.02, .33,-.92)+offs;\n    d = Capsule(pm, pShoulder, pElbow, .57, .45, .4, .1, d);\n    d = Capsule(pm, pElbow, pWrist, .43, .31, .05, .05, d);\n    d = smin(d, dHand(pm, pWrist), .1);\n\n    // leg\n    vec3 pHip = vec3(1.05, -1.87,-.35);\n    vec3 pKnee = vec3(.82, -0.87,-1.39);\n    vec3 pAnkle = vec3(1.86, -0.03,-.42)+offs;\n    d = Capsule(pm, pHip, pKnee, .69, .43, .05, .01, d);\n    d = Capsule(pm, pKnee, pAnkle, .43, .34, .05, .05, d);\n    d = smin(d, dFoot(pm, pAnkle), .1);\n\n    // genitals\n    d = smin(d, length(vec3(1.5, -1.52, 0)-p)-.22, .075);\n    d = smin(d, length(vec3(1.62, -1.25, 0)-p)-.07, .1);\n\n    return d;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = Map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\n\nde CastRay(vec3 ro, vec3 rd) {\n    vec3 p = ro + MIN_DIST*rd;\n    float dS;\n    float dC = 0.;\n    float mat = 0.;\n    float dM = MAX_DIST;\n\n    float m = iMouse.y/iResolution.y -.5;\n\n\n    dC = MIN_DIST;\n    for(float i=0.;i<MAX_STEPS; i++) {\n    \tp = ro + dC * rd;\n\n        dS = Map(p);\n\n        if(dS<SURF_DIST || dC>MAX_DIST)\n            break;\n\n        dM = min(dM, dS);\n        dC += dS;\n    }\n\n    if(dS<SURF_DIST)\n        mat = 1.;\n\n    de o;\n    o.p = p;\n    o.dm = dM;\n    o.mat = mat;\n    //o.i = i;\n\n    return o;\n}\n\nvec3 Background(vec2 uv, vec3 ro, vec3 rd) {\n\tfloat d = length(uv-vec2(0., .2));\n\n    vec3 col = vec3(1., .4, .3);\n    //col *= S(.8, .0, d)*1.5;//(1.5+sin(iTime)*.5);\n    col *= S(.8, .0, d)*1.5*(FFT(50)*.5+.5);//*(1.5+sin(iTime)*.5)*(FFT(50)*.5+.5);\n\n    //col *= FFT(25)*.5+.5;\n    return col;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 s, float r) {\n    float t = dot(s-ro, rd);\n    vec3 p = ro+rd*t;\n    float y = length(s-p);\n    if(y<r) {\n        float x = sqrt(r*r-y*y);\n        return vec2(t-x, t+x);\n    }\n    return vec2(-1, -1);\n}\n\nvec3 Render(vec2 uv, vec3 ro, vec3 rd) {\n\n    ro.x += sin(rd.x*5.+iTime)*.1;\t\t\t\t// bend rays to get some waviness\n    ro.y += sin(rd.y*6.+iTime)*.1;\n\n    vec3 bg = Background(uv, ro, rd);\n    vec3 col = bg;\n\n    vec3 pBubble = vec3(.13, 1.42, .0);\n    vec2 s = RaySphere(ro, rd, pBubble, 4.075);\t// get intersection with the bubble\n    if(s.x==-1.) {\t\t\t\t\t\t\t\t// if there is no intersection, then just render background\n        col = col.bgr*(1.+sin(iTime)*.2);\n        col *= 1.-FFT(50);\n        //col *= 1.-texture(iChannel0, (uv+.5)*.7).x*.4;\n        return col;\t\t\t\t\t\t\t\t// .. and we are done!\n    }\n\n\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    #ifdef DEVELOPER\n    vec3 nb = vec3(0);\n    #else\n\n    ro = ro+s.x*rd;\t\t\t\t\t\t\t\t// forward ray to boundary of bubble\n    vec3 nb = normalize(ro-pBubble);\t\t\t// bubble normal\n\tfloat fresnel = 1.-max(0., -dot(nb, rd));\t// falloff on sides of bubble\n    #endif\n\n    de result = CastRay(ro, normalize(rd-nb*.5)); // bend ray inwards a bit to get refraction effect\n\n    if(result.mat>0.) {\n\n        vec3 n = GetNormal(result.p);\n\n\n        vec3 light = normalize(vec3(1,1,1));\n\n        #ifdef DEVELOPER\n        return vec3(dot(n, light));\n        #endif\n        float lh = m.x<.03||m.x>.97?(-cos(iTime*.2)*.5+.5):m.y;\n        light = vec3(1., 6.*lh, 0.)-result.p;\n        float l = min(1., 5./dot(light, light));\n\n        float dif = max(0., dot(n, normalize(light)));\n\n\n        float ao = calcAO(result.p, n);\t\t // IQs ambient occlusion\n        dif = max(dif, .2)*ao*2.*l;\n        float bfresnel = max(0., -dot(n, rd)); // get fresnel falloff of baby\n\n\n        vec3 baseCol = vec3(1., .4, .2);\n        // modeling the earhole looked problematic due to fresnel, so I just render a dark spot there\n        float earHole = length(vec3(result.p.x,result.p.y,abs(result.p.z))-vec3(-2.03, .7, .8));\n        earHole = S(.05, .1, earHole);\n        baseCol *= mix(.3, 1., earHole);\n\n        col = mix(col, dif * baseCol, bfresnel);\n\n\n        float d = length(result.p-ro);\t// distance from front of bubble along eye ray\n        d = S(2., 7., d);\t\t\t\t// add some distance fade\n        col = mix(col, bg, d);\n        col = mix(col, bg, S(3., 6., result.p.y)); // fade bottom of bubble black\n\n        // cheap sub surface scattering\n\t\t#ifdef USE_SSS\n        float sss = 1.-Map(result.p+rd*.1)/-.1;\t\t// advance ray a bit past hit point\n\n        float sssMask = S(2.7,.0,length(light));\t// only show sss when close to light\n        float angleFade = abs(nb.b);\t\t\t\t// mask unflattering angle\n        col.r += max(0.,sss)*sssMask*angleFade;\t\t// add sss only in red channel\n\t\t#endif\n\n\n    }\n\n    #ifndef DEVELOPER\n\n\n    vec3 rimCol = pow(fresnel, 3.)*S(1., .9, fresnel)*vec3(1., .55, .5);\n    rimCol *= S(.6, .0, -rd.y);\n    col += rimCol;\n\n\n    #endif\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int max_freq = 100;\n    for(int i=1; i < max_freq; i++){\n        snd +=FFT(i)*float(i);\n    }\n    snd /=float(max_freq*20);\n    vec2 cam_uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n\t//camera + rd for stars\n    vec3 ro = vec3(0.0);//rd = vec3( 0.0 );\n\tvec3 rd = normalize(vec3(cam_uv,-1.5));\n    mat3 t3 = mat3(1.0);\n\tcamera(cam_uv, ro, rd, t3);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime*2.;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n\n\tt *= m.x<.03||m.x>.97 ? .2 : 0.;\n    vec3 cPos = vec3(sin(m.x*6.283+t), .2, cos(m.x*6.283+t))*6.;\n    vec3 cLookat = vec3(0);\n    cLookat = vec3(-0,1.42,0);\n\n    #ifdef DEVELOPER\n    float zoom = 1.;\n    #else\n    float zoom = .5;\n    #endif\n\n    vec3 up = vec3(0, 1, 0);\n    vec3 eyeRay = GetRay(uv, cPos, cLookat, up, zoom);\n\n    rd.x+=sin(iTime/1000.)*2.;\n\tvec3 bg = stars(rd)*(1.+30.*snd);\n    vec3 col = Render(uv, cPos, eyeRay);\n    col += -0.25+FFT(50);\n    fragColor = vec4(col,1.0);\n\tfragColor+=vec4(bg, 1.);\n}","name":"Image","description":"","type":"image"}]}