{"ver":"0.1","info":{"id":"fsXyWl","date":"1642859960","viewed":186,"name":"Béziér text rendering","username":"stegu","description":"I resurrected this 2006 code from RSL to show how you can render antialiased text defined by Béziér curve descriptions taken from a PostScript typeface. The keyword is \"implicitization\". Drag vertically to zoom in on the text. The view is 2-D.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["bezier","text","antialias","font","implicit","typeface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n// Center the unit square in the middle of the viewport,\n// assuming nothing about the aspect ratio\nvec2 st = (gl_FragCoord.xy - 0.5*max(vec2(0.0), (iResolution.xy-iResolution.yx)))\n    / min(iResolution.x, iResolution.y);\n\nfloat zoom = pow(0.5, 8.0*max(0.0, iMouse.y-20.0)/iResolution.y);\nfloat time = iTime -2.0 + 4.0*(iMouse.x/iResolution.x);\nvec2 pan = sqrt(zoom)*vec2(0.4*sin(time), 0.2*sin(time*sqrt(5.0)));\nst = zoom*(st-vec2(0.5, 0.10)) + vec2(0.5, 0.10) + pan;\n\n// Define some colors we will use for this surface.\n// These are (were) the correct, official colors for the Aqsis logo.\n// Only \"bgcolor\" may be changed. It can be set to black, white\n// or any gray tone far enough from (0.6, 0.6, 0.6).\nvec3 bgcolor = vec3(1.0,1.0,1.0); // vec3(0.282, 0.282, 0.282);\nvec3 ringcolor = vec3(0.6, 0.6, 0.6);\nfloat ringalpha = 0.6;\nvec3 ballcolor = vec3(0.2, 0.4, 0.8);\nfloat ballalpha = 0.66;\n\n// The text should be black on a light background, white on dark.\n// On mid-tones, use the alternative that looks best for the occasion.\nvec3 textcolor = vec3(0.0, 0.0, 0.0); // vec3(1.0, 1.0, 1.0);\n\n// The logo part of the shader draws a pattern of size 370x370 units.\n// Rescale the texture coordinates to match that.\nfloat x = st.s * 370.0;\nfloat y = st.t * 370.0;\n\n// Calculate normalised distances to the ring contours\nfloat outerdist = (x-185.0)*(x-185.0)/164.0/164.0 + (y-185.0)*(y-185.0)/89.0/89.0;\nfloat innerdist = (x-185.0)*(x-185.0)/124.0/124.0 + (y-200.0)*(y-200.0)/63.0/63.0;\nfloat gapdist = (x-283.0)*(x-283.0)/48.0/48.0 + (y-136.0)*(y-136.0)/48.0/48.0;\nouterdist = (sqrt(outerdist) - 1.0) * 164.0/370.0;\ninnerdist = (sqrt(innerdist) - 1.0) * 124.0/370.0;\ngapdist = (sqrt(gapdist) - 1.0) * 48.0/370.0;\nfloat ring = 1.0-aastep(0.0, outerdist); // Big ring outline\nring *= aastep(0.0, innerdist); // Hole in big ring\nring *= aastep(0.0, gapdist); // Gap in big ring\n\n// Calculate normalised distances to the three circles\nfloat bigballdist = (x-283.0)*(x-283.0)/36.0/36.0 + (y-136.0)*(y-136.0)/36.0/36.0;\nfloat mediumballdist = (x-235.0)*(x-235.0)/18.0/18.0 + (y-180.0)*(y-180.0)/18.0/18.0;\nfloat smallballdist = (x-202.0)*(x-202.0)/9.0/9.0 + (y-200.0)*(y-200.0)/9.0/9.0;\nbigballdist = (sqrt(bigballdist) - 1.0) * 36.0/370.0;\nmediumballdist = (sqrt(mediumballdist) - 1.0) * 18.0/370.0;\nsmallballdist = (sqrt(smallballdist) - 1.0) * 9.0/370.0;\nfloat balls = (1.0-aastep(0.0, bigballdist)); // Big ball\nballs += (1.0-aastep(0.0, mediumballdist)); // Medium ball\nballs += (1.0-aastep(0.0, smallballdist)); // Small ball\n\nvec3 ringmixcolor = bgcolor * (1.0-ringalpha) + ringcolor * ringalpha;\nvec3 ballmixcolor = bgcolor * (1.0-ballalpha) + ballcolor * ballalpha;\n\nfloat text = aqsistext_mask(st*1.5+vec2(-0.25,-0.14));\n\nvec3 mixcolor;\nmixcolor = mix(bgcolor, ringmixcolor, ring);\nmixcolor = mix(mixcolor, ballmixcolor, balls);\nmixcolor = mix(mixcolor, textcolor, text);\n\nfragColor = vec4(mixcolor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n* A shader function ported from my Renderman SL shader\n* \"aqsislogo.sl\" - a shader to draw the Aqsis renderer\n* logo in 2D, with text in the proper typeface, using\n* cubic Bezier contours taken from a PostScript font.\n*\n* Author: Stefan Gustavson 2006-02-05 (looong ago)\n* Ported to GLSL by the original author in 2022-01-22\n*\n* As far as I know, this was the world’s first SL-only\n* rendering of (reasonably) general Bezier outlines.\n* I would not be surprised if it was also the last.\n* This is not a great idea for CPU-based software shading,\n* but it's potentially useful for parallel execution.\n* Hence this resurrection. Do with it as you like - I\n* hereby place this code in the public domain.\n*\n* My old write-up of this from 2006 is available from here:\n* https://weber.itn.liu.se/~stegu/aqsis/implicitBeziers.pdf\n*\n* This shader does analytic antialiasing by explicit gradient\n* calculations, to avoid artifacts at the boundaries between\n* the hard and inherently AA-hostile if/else conditionals.\n* Despite its complexity, it executes reasonably fast.\n* Most of the heavy math in is inside conditionals, and for\n* each evaluation, only a small part of the code is executed.\n*\n* This was submitted as an entry to the wonderfully light-hearted\n* Pixar-hosted evening session \"Stupid RenderMan Tricks\"\n* at Siggraph 2006, but it didn't get selected for presentation.\n* It was probably too stupid even for that setting. :)\n*/\n\n// A conveniently anti-aliased step() using auto derivatives,\n// in the style of RSL filterstep() and its OSL namesake aastep()\nfloat aastep(float threshold, float value) {\n\tfloat afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n\treturn smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// Evaluate a general cubic polynomial with coefficients from an array\nfloat cubic(float Pc[10], vec2 xy) {\n\tfloat x = xy.x;\n\tfloat y = xy.y;\n\treturn ((Pc[0]*x + Pc[1]*y + Pc[4])*x + Pc[7])*x + Pc[9]\n\t\t+ ((Pc[2]*x + Pc[3]*y + Pc[6])*y + Pc[5]*x + Pc[8])*y;\n//\tThe expression above is an optimized version of this:\n//  return Pc[0]*x*x*x + Pc[1]*x*x*y + Pc[2]*x*y*y + Pc[3]*y*y*y\n//\t+ Pc[4]*x*x + Pc[5]*x*y + Pc[6]*y*y + Pc[7]*x + Pc[8]*y + Pc[9];\n}\n\n// Calculate the gradient magnitude of the polynomial\nfloat gradmag(float Pc[10], vec2 xy) {\n\tfloat x = xy.x;\n\tfloat y = xy.y;\n\tfloat gx = (3.0*Pc[0]*x + 2.0*Pc[1]*y + 2.0*Pc[4])*x\n\t\t+ (Pc[2]*y + Pc[5])*y + Pc[7];\n\tfloat gy = (Pc[1]*x + Pc[5])*x + Pc[8]\n\t\t+ (2.0*Pc[2]*x + 3.0*Pc[3]*y + 2.0*Pc[6])*y;\n//  The expressions above are optimized versions of these:\n//\tfloat gx = 3.0*Pc[0]*x*x + 2.0*Pc[1]*x*y + Pc[2]*y*y + 2.0*Pc[4]*x + Pc[5]*y + Pc[7];\n//\tfloat gy = Pc[1]*x*x + 2.0*Pc[2]*x*y + 3.0*Pc[3]*y*y + Pc[5]*x + 2.0*Pc[6]*y + Pc[8];\n\treturn sqrt(gx*gx + gy*gy);\n}\n\n// These symbolic names for constants makes the code\n// at least somewhat less unreadable.\n#define min_x 66.0\n#define min_y 230.0\n#define max_x 774.0\n#define max_y 367.0\n#define mid_y 304.0\n#define Amid_x 173.38\n#define Ay0 -45.6\n#define Ay1 45.35\n#define Ay2 -22.5\n#define Ay3 -11.47\n#define Ax0 -43.0\n#define Ax1 43.0\n#define Alegw 2364.7\n#define AQw 1000.0\n#define QS 429.0\n#define Qmid_x 336.8\n#define Qy0 -42.3\n#define Qy1 -61.9\n#define Qtailw 588.0\n#define Qxtemp1 2.42\n#define Qxtemp2 32.38\n#define SI 574.0\n#define S1mx 497.34\n#define Sy1 -20.72\n#define Sy2 21.78\n#define Sx0 -60.34\n#define Sx1 57.13\n#define S2mx 688.52\n#define IS 617.0\n#define Ix0 583.46\n#define Ix1 608.34\n#define Iy0 258.83\n#define Iy1 349.13\n\n// For any point (s,t) in the unit square, return 1 if it is\n// inside any part of the text, 0 otherwise, with edge AA.\n\nfloat aqsistext_mask(vec2 st) {\n\n// These are the implicit \"inside-outside\" polynomials, obtained by\n// implicitization of a number of hand-tuned Bezier segments.\nfloat Qc1[10] = float[]( // Outer contour for Q\n-2.515456e+000, -1.46821248e+002, -2.856536928e+003,\n-1.8525482136e+004, -3.138538013868060e+006, 4.184088320992688e+006,\n-9.080414450785264e+006, -1.916338893062538e+008, -3.555433156037660e+008,\n3.913333377932780e+010\n);\nfloat Qc2[10] = float[]( // Inner contour for Q\n3.176523e+000, -1.3030227e+002, 1.7816841e+003,\n-8.120601e+003, -8.709029702512207e+005, 8.446794868238396e+005,\n-1.940215343163121e+006, -3.388764263479087e+007, -4.866920986486877e+007,\n4.913481392003620e+009\n);\nfloat Sc1a[10] = float[]( // Outer contour for upper left part of S\n-1.560896e+000, -1.07661456e+002, -2.475285372e+003,\n-1.8970074963e+004, -4.203757925723708e+005, -1.008869191772405e+005,\n-7.395343386686108e+005, 1.021959972815947e+007, 4.231012854331020e+007,\n1.619176102444687e+009\n);\nfloat Sc1b[10] = float[]( // Inner contour for upper left part of S\n1.2812904e+001, 2.37531528e+002, 1.467823032e+003,\n3.023464536e+003, 1.205445041712036e+004, -6.328299537503940e+004,\n-7.180880134607939e+004, 3.392372672377217e+005, -1.514004847128142e+006,\n2.064460489533454e+006\n);\nfloat Sc2a[10] = float[]( // Outer contour for upper right part of S\n-3.73248e-001, -5.7822336e+001, -2.985881184e+003,\n-5.1395862232e+004, -2.631670560009098e+000, 3.699543764663996e+005,\n7.819825232895721e+006, -1.079471991752684e+007, -3.985480538763968e+008,\n6.793959228746701e+009\n);\nfloat Sc2b[10] = float[]( // Inner contour for upper right part of S\n2.352637e+000, -5.7206226e+001, 4.63671516e+002,\n-1.252726552e+003, -1.846763602109960e+003, -6.592559436540401e+003,\n1.285963272360889e+005, -3.864184150032301e+005, -7.438671069995483e+006,\n1.621462796641338e+008\n);\nfloat Sc3a[10] = float[]( // Outer contour for middle left part of S\n5.053029696e+003, -4.1183958816e+004, 1.11887888112e+005,\n-1.01325045528e+005, -3.5722167794334e+005, -9.000108087994801e+005,\n5.756484950751777e+006, 1.383060896290501e+007, 2.711575485516367e+008,\n1.126225316211760e+009\n);\nfloat Sc3b[10] = float[]( // Inner contour for middle left part of S\n3.84240583e+002, -2.440218393e+003, 5.165744301e+003,\n-3.645153819e+003, 1.73990343969e+004, -3.924885612033014e+004,\n4.897977973740215e+003, 1.641019444597991e+006, 1.507638564822112e+007,\n-1.138439458260446e+008\n);\nfloat Sc4a[10] = float[]( // Outer contour for middle right part of S\n-6.612913133e+003, 4.3989788694e+004, -9.7541555964e+004,\n7.2095179528e+004, -3.900824717933405e+005, 1.178804479406984e+005,\n1.696167582980258e+006, -4.879382691530628e+007, -5.122662213495559e+008,\n3.782558913476014e+009\n);\nfloat Sc4b[10] = float[]( // Inner contour for middle right part of S\n-2.509911279e+003, 1.1452509081e+004, -1.7418937653e+004,\n8.831234763e+003, 1.364069703129298e+005, -9.938912235713974e+004,\n-1.704812004398699e+005, -8.481654673763756e+006, -6.854711509977910e+007,\n-3.141699222699289e+008\n);\nfloat Sc5a[10] = float[]( // Outer contour for lower left part of S\n-1.1089567e+001, 1.40534154e+002, -5.93646516e+002,\n8.35896888e+002, 2.227940722530032e+003, -3.338964917802015e+004,\n9.913940441721011e+004, -2.470532821691856e+005, 6.859080825118593e+006,\n1.916457264647791e+008\n);\nfloat Sc5b[10] = float[]( // Inner contour for lower left part of S\n-1.0e+000, 8.271e+001, -2.2803147e+003,\n2.0956092093e+004, -1.640258734248e+004, 4.888192197095951e+004,\n2.539159491029130e+006, 5.028775045349196e+006, 1.189107392873075e+008,\n1.992721536814904e+009\n);\nfloat Sc6a[10] = float[]( // Outer contour for lower right part of S\n1.194389981e+003, 5.50477569e+003, 8.4569127e+003,\n4.330747e+003, 5.079518640874504e+005, 2.042561801719503e+006,\n1.952816523506253e+006, 7.791598981763187e+007, -6.508484938309293e+007,\n-7.029013111518749e+009\n);\nfloat Sc6b[10] = float[]( // Inner contour for lower right part of S\n8.615125e+000, 1.89490725e+002, 1.389290535e+003,\n3.395290527e+003, -2.161032396471031e+004, 2.697558897572927e+004,\n8.647800264089205e+003, -9.382476414227656e+005, -3.404335509997699e+006,\n3.871235795097654e+007\n);\n\n// A less convenient aastep, using a separately computed step width\n#define AASTEP(a,w,x) smoothstep((a-0.5*w),(a+0.5*w),(x))\n\n// AA'd threshold of an implicit cubic polynomial, with the\n// polynomial normalised to have a unit length gradient near 0.0\n#define AACUBIC(Pc,xy) AASTEP(0.0, stepwidth, cubic(Pc,xy)/gradmag(Pc,xy))\n\nvec2 xy_global; // global coordinates\nvec2 xy; // local coordinates\nfloat mask1, mask2, mask3, mask4, pattern; // temporary variables\n// Scale unit square to cover our somewhat arbitrary bounding box\n// (The units were originally \"points\" in a full-page PostScript file)\nxy_global = st * 708.0 + vec2(66.0, 230.0);\n\n// Calculate an approximate stepwidth in (x,y) space.\n// (This could be done better in an anisotropic, pattern-specific manner\n// by first transforming the specific gradient vector to screen space\n// and checking its length there, but this is a lot simpler and works OK.)\nfloat stepwidth = fwidth(length(xy_global));\n\n// If outside bbox\nif((xy_global.x < min_x) || (xy_global.x > max_x)\n\t|| (xy_global.y < min_y) || (xy_global.y > max_y)) {\n\tpattern = 0.0; // Outside bounding box, no shapes here\n}\nelse {\n// We are inside the bounding box, and need to test for\n// intersections with the letters\n\txy.y = xy_global.y - mid_y; // transform to local y coordinate system\n\tfloat Ax = xy_global.x - Amid_x; // transform to local x coordinate for A\n\tfloat A2 = -90.95*Ax - 69.82*xy.y + 4468.2875; // Sloping decision boundary between A and Q\n\tif(A2 > -AQw) { // We are to the left of the Q, so draw the A\n\t\txy.x = Ax; // local x coordinate for A\n\t\tfloat A1 = 90.95*xy.x - 69.82*xy.y + 4467.8315;\n\t\tmask1 = min(AASTEP(Ay0, stepwidth, xy.y),\n\t\t\t1.0 - AASTEP(Ay1, stepwidth, xy.y)); // top and bottom\n\t\tmask2 = min(AASTEP(Ay2, stepwidth, xy.y),\n\t\t\t1.0 - AASTEP(Ay3, stepwidth, xy.y)); // horizontal bar\n\t\tfloat gradmagA = sqrt(90.95*90.95 + 69.82*69.82); // Constant gradient, same for A1 and A2\n\t\tif(xy.x < 0.0) { // left half\n\t\t\tmask3 = min(mask1, min(AASTEP(0.0, stepwidth, A1/gradmagA),\n\t\t\t\t1.0-AASTEP(Alegw/gradmagA, stepwidth, A1/gradmagA))); // left leg\n\t\t\tmask4 = min(mask2, step(Ax0, xy.x)); // left limit of horizontal bar\n\t\t\tpattern = max(mask3, mask4);\n\t\t}\n\t\telse { // right half\n\t\t\tmask3 = min(mask1, min(AASTEP(0.0, stepwidth, A2/gradmagA),\n\t\t\t\t1.0-AASTEP(Alegw/gradmagA, stepwidth, A2/gradmagA))); // right leg\n\t\t\tmask4 = min(mask2, 1.0-step(Ax1, xy.x)); // right limit of horizontal bar\n\t\t\tpattern = max(mask3, mask4);\n\t\t}\n\t}\n\telse if(xy_global.x < QS) { // We are to the left of the first S, so draw Q\n\t\txy.x = xy_global.x - Qmid_x; // transform to local x coordinate for Q\n\t\tif(xy.x < 0.0) { // left half\n\t\t\tif(xy.y < 0.0) { // bottom left quarter\n\t\t\t\tmask1 = min(1.0 - AACUBIC(Qc2, -xy), AACUBIC(Qc1, -xy));\n\t\t\t}\n\t\t\telse { // top left quarter\n\t\t\t\tmask1 = min(1.0 - AACUBIC(Qc2, vec2(-xy.x, xy.y)),\n\t\t\t\tAACUBIC(Qc1, vec2(-xy.x, xy.y)));\n\t\t\t}\n\t\t}\n\t\telse { // right half\n\t\t\tif(xy.y < 0.0) { // bottom right quarter\n\t\t\t\tmask1 = min(1.0 - AACUBIC(Qc2, vec2(xy.x, -xy.y)),\n\t\t\t\tAACUBIC(Qc1, vec2(xy.x, -xy.y)));\n\t\t\t}\n\t\t\telse { // top right quarter\n\t\t\t\tmask1 = min(1.0 - AACUBIC(Qc2, xy), AACUBIC(Qc1, xy));\n\t\t\t}\n\t\t}\n\t\tfloat Q1 = 19.6*xy.x + 35.02*xy.y + 1433.914;\n\t\tfloat gradQ1 = sqrt(19.6*19.6 + 35.02*35.02);\n\t\tmask2 = min(min(step(Qy1, xy.y), 1.0 - AASTEP(Qy0, stepwidth, xy.y)),\n\t\t\tmin(AASTEP(0.0, stepwidth, Q1/gradQ1),\n\t\t\t1.0 - AASTEP(Qtailw/gradQ1, stepwidth,Q1/gradQ1)));\n\t\tpattern = max(mask1, mask2); // Add the little “tail” for Q\n\t}\n\telse if(xy_global.x < SI) { // We are to the left of the I, so draw the first S\n\t\txy.x = xy_global.x - S1mx; // transform to local x coordinate for first S\n\t\tif(xy.x < 0.0) { // left half\n\t\t\tif(xy.y < Sy1) { // bottom left part\n\t\t\t\tmask1 = min(AACUBIC(Sc5a, xy), 1.0 - AACUBIC(Sc5b, xy));\n\t\t\t\t\tpattern = min(mask1, AASTEP(Sx0, stepwidth, xy.x));\n\t\t\t}\n\t\t\telse if(xy.y < Sy2) { // middle left part\n\t\t\t\tpattern = min(AACUBIC(Sc3a, xy),\n\t\t\t\t\t1.0 - AACUBIC(Sc3b, xy));\n\t\t\t}\n\t\t\telse { // upper left part\n\t\t\t\tpattern = min(AACUBIC(Sc1a, xy), AACUBIC(Sc1b, xy));\n\t\t\t}\n\t\t}\n\t\telse { // right half\n\t\t\tif(xy.y < Sy1) { // bottom right part\n\t\t\t\tpattern = min(1.0 - AACUBIC(Sc6a, xy),\n\t\t\t\t1.0 - AACUBIC(Sc6b, xy));\n\t\t\t}\n\t\t\telse if(xy.y < Sy2) { // middle right part\n\t\t\t\tpattern = min(AACUBIC(Sc4a, xy),\n\t\t\t\t1.0 - AACUBIC(Sc4b, xy));\n\t\t\t}\n\t\t\telse { // upper right part\n\t\t\t\tmask1 = min(AACUBIC(Sc2a, xy), 1.0 - AACUBIC(Sc2b, xy));\n\t\t\t\tpattern = min(mask1, 1.0 - AASTEP(Sx1, stepwidth, xy.x));\n\t\t\t}\n\t\t}\n\t}\n\telse if(xy_global.x < IS) { // We are to the left of the second S, do draw the I (a simple box)\n\t\tpattern = min(min(AASTEP(Ix0, stepwidth, xy_global.x),\n\t\t\t\t\t\t1.0 - AASTEP(Ix1, stepwidth, xy_global.x)),\n\t\t\t\t\tmin(AASTEP(Iy0, stepwidth, xy_global.y),\n\t\t\t\t\t\t1.0 - AASTEP(Iy1, stepwidth, xy_global.y)));\n\t}\n\telse { // We are far out to the right, so draw the second S\n\t\txy.x = xy_global.x - S2mx; // transform to local x coordinate for second S\n\t\t// From here on, the code is identical to the first S.\n\t\tif(xy.x < 0.0) { // left half\n\t\t\tif(xy.y < Sy1) { // bottom left part\n\t\t\t\tmask1 = min(AACUBIC(Sc5a, xy), 1.0 - AACUBIC(Sc5b, xy));\n\t\t\t\tpattern = min(mask1, AASTEP(Sx0, stepwidth, xy.x));\n\t\t\t}\n\t\t\telse if(xy.y < Sy2) { // middle left part\n\t\t\t\tpattern = min(AACUBIC(Sc3a, xy), 1.0 - AACUBIC(Sc3b, xy));\n\t\t\t}\n\t\t\telse { // upper left part\n\t\t\t\tpattern = min(AACUBIC(Sc1a, xy), AACUBIC(Sc1b, xy));\n\t\t\t}\n\t\t}\n\t\telse { // right half\n\t\t\tif(xy.y < Sy1) { // bottom right part\n\t\t\t\tpattern = min(1.0 - AACUBIC(Sc6a, xy),\n\t\t\t\t\t1.0 - AACUBIC(Sc6b, xy));\n\t\t\t}\n\t\t\telse if(xy.y < Sy2) { // middle right part\n\t\t\t\tpattern = min(AACUBIC(Sc4a, xy), 1.0 - AACUBIC(Sc4b, xy));\n\t\t\t}\n\t\t\telse { // upper right part\n\t\t\t\tmask1 = min(AACUBIC(Sc2a, xy), 1.0 - AACUBIC(Sc2b, xy));\n\t\t\t\tpattern = min(mask1, 1.0 - AASTEP(Sx1, stepwidth, xy.x));\n\t\t\t}\n\t\t}\n\t}\n}\nreturn pattern;\n}\n\n","name":"Common","description":"","type":"common"}]}