{"ver":"0.1","info":{"id":"Wst3WM","date":"1568682713","viewed":221,"name":"Pix'island","username":"Draedrus","description":"Island, test on upsampling/downsampling application in shadertoy","likes":3,"published":1,"flags":96,"usePreview":0,"tags":["island","upsampling","downsampling","seagulls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @author Pierre-Marie Plans\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*FAC;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4ts3WS","filepath":"https://soundcloud.com/valkyrie-sound/coastal-with-gulls#t=10:50","previewfilepath":"https://soundcloud.com/valkyrie-sound/coastal-with-gulls#t=10:50","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// @author Pierre-Marie Plans\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec3 opCheapBend( in vec3 p , float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec2 mapI(vec3 p)\n{\n    float l = .1*length(p.xz-vec2(0., 5.));\n    l = sdEllipsoid(p, vec3(3.5, 1., 3.5));\n    //vec3 q = opCheapBend(p, 0.8);\n    l = min(l, sdVerticalCapsule(p, 5., 0.1));\n    float c = udTriangle(p, vec3(-.0, 5., 0.), vec3(-.2, 3., -.4), vec3(.2, 5., 0.));\n    c = min(c, udTriangle(p, vec3(-.4, 5., 0.4), vec3(.0, 3., 0.4), vec3(.0, 5., .0)));\n    c = min(c, udTriangle(p, vec3(.4, 3., -.05), vec3(.0, 4., .15), vec3(.0, 5.5, -.05)));\n    // top\n    c = min(c, udTriangle(p, vec3(.8, 4., -.05), vec3(.0, 4.5, .15), vec3(.0, 5., -.05)));\n    c = min(c, udTriangle(p, vec3(.0, 4.5, -.05), vec3(.0, 5.0, .15), vec3(-1., 3.5, -.05)));\n    // seagulls\n    float m = udTriangle(p-vec3(cos(iTime), 5.5, sin(iTime)), vec3(-.2, .2, 0.), vec3(.2, .2, .0), vec3(.0, -.2, .0));\n    m = min(m, udTriangle(p-1.3*vec3(cos(iTime+0.5), 5.5, sin(iTime+0.5)), vec3(-.2, .2, 0.), vec3(.2, .2, .0), vec3(.0, -.2, .0)));\n    m = min(m, udTriangle(p-1.2*vec3(cos(iTime+1.5), 4.5, sin(iTime+1.5)), vec3(-.2, .2, 0.), vec3(.2, .2, .0), vec3(.0, -.2, .0)));\n    vec2 r=min(l, c)==l?vec2(l, I):vec2(c, C);\n    r = min(r.x, m)==r.x?r:vec2(m, M);\n    return r;\n}\n\nvec2 mapW(vec3 p)\n{\n    return vec2(p.y+0.2*smoothstep(0., 1., sin(length(p)+0.5*iTime)), W);\n    return vec2(p.y+sin(length(p))*0.4*fbm(0.4*p.xz+0.4*iTime)+0.2*fbm(0.4*p.xz-0.4*iTime), W);\n}\n\n#define RM(ro, rd, _m, m_, map, _o) \\\n{ \\\n    _o = vec2(_m, -1.); \\\n    for(int i = 0; i < 120; ++i) \\\n    { \\\n    \tvec3 p = ro+rd*_o.x; \\\n        vec2 m = map(p); \\\n        if(m.x<0.01 || _o.x>FAR) break; \\\n        _o.x += .5*m.x; \\\n        _o.y = m.y; \\\n    } \\\n} \\\n\nfloat F(float n1, float n2, float o)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-o)*(1.0-o)*(1.0-o)*(1.0-o)*(1.0-o);\n}\n\nfloat bdistrib(float r, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * r * r * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (r * r * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x<RES.x && fragCoord.y<RES.y)\n    {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/RES;\n        uv = -1.+2.*uv;\n        vec2 mv = iMouse.xy*0.1;\n        vec3 ro = vec3(0., 2., -10.);//vec3(cos(mv.x), 2., sin(mv.x));\n        //ro.xz *= 10.;\n        vec3 w = normalize(vec3(0., 3., 0.)-ro);\n        vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n        vec3 v = normalize(cross(u, w));\n        vec3 rd = normalize(u*uv.x+v*uv.y+1.5*w);\n\n        vec2 di; RM(ro, rd, 0.1, 100., mapI, di);\n        vec2 dw; RM(ro, rd, 0.1, 100., mapW, dw);\n        vec3 n;\n        vec2 d = min(di.x, dw.x)==di.x?di:dw;\n        vec3 pi = ro+rd*di.x;\n        vec3 pw = ro+rd*dw.x;\n        vec3 p = ro+rd*d.x;\n\t\tvec3 L = normalize(vec3(0., 0.05, 0.5));\n        // Time varying pixel color\n        vec3 col = vec3((FAR-d.x)/FAR);\n        float Li = dot(rd, L);\n        col = mix(vec3(0.1, 0.5, 1.0), vec3(0.8, 0.4, 0.6), pow(Li, 4.));\n        if(d.x<FAR)\n        {\n            if(d.y==W)\n            {\n                {\n                    float e=0.001;\n                    n.y = mapW(p).x;\n                    n.x = mapW(p+vec3(e, 0., 0.)).x - n.y;\n                    n.z = mapW(p+vec3(e, 0., 0.)).x - n.y;\n                    n.y = e;\n                    n = normalize(n);\n                }\n                float Ni = max(0., dot(normalize(rd+L), n));\n                float _F = F(1.37, 1., Ni);\n                float D = clamp((di.x-dw.x)*0.5, 0., 1.);\n                float rfl = dot(reflect(rd, n), L);\n                col = mix(\n                    bdistrib(0.56, rfl)*mix(vec3(0.1, 0.5, 1.0), vec3(0.8, 0.4, 0.6), pow(rfl, 4.))\n                    , mix(vec3(0.3, 0.6, 0.6), vec3(0.1, 0.3, 0.4), D)\n                    , 1.-_F);\n                col = mix(col, vec3(Ni), 1.-D);\n            }\n            else\n            {\n                float e=0.001;\n                n.y = mapI(p).x;\n                n.x = mapI(p+vec3(e, 0., 0.)).x - n.y;\n                n.z = mapI(p+vec3(e, 0., 0.)).x - n.y;\n                n.y = e;\n                n = normalize(n);\n            }\n            if(d.y==I) col *= vec3(1., 1., 0.);\n            if(d.y==C) col *= vec3(0., 1., 0.);\n            if(d.y==I || d.y==C)\n            {\n                col *= max(0., dot(normalize(rd+L), n));\n                col += exp(-(FAR-d.x)/FAR*4.)*dot(reflect(rd, n), L);\n            }\n            if(d.y==M)\n            {\n                col = Li*vec3(1.);\n            }\n        }\n        \n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// @author Pierre-Marie Plans\n\n#define FAC 75./iResolution.y\n#define RES (FAC*iResolution.xy)\n#define FAR 200.\n#define W 0.\n#define N -1.\n#define I 1.\n#define C 2.\n#define M 3.\n\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat snoise(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*snoise(uv); uv*=2.001;\n    total += 0.2500*snoise(uv); uv*=2.003;\n    total += 0.1250*snoise(uv); uv*=2.002;\n    total += 0.0625*snoise(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"}]}