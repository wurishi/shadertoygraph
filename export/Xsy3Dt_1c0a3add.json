{"ver":"0.1","info":{"id":"Xsy3Dt","date":"1456946726","viewed":502,"name":"Covariance Matrix Visualizer","username":"Cellulose","description":"Use your mouse!!<br/>Designed to help me understand \"covariance matrices\", which describe gaussian distributions.  These are used in Kalman Filters, an essential technique in robotics control systems.<br/>You can also model ellipsoids with them!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["math","covariance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n\n/*\n\tA covariance matrix is always diagonally symmetric and \"positive-semidefinite\".\n\n\tValues in the diagonals indicate the variance of different \n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Decide our distribution's characteristics based on user interaction\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float\n        spread  = 0.25,\n        stretch = pow(2.0, 3.0*mouse.y-1.5),\n        yVar    = spread * stretch,\n        xVar    = spread / stretch,\n        xyCoVar = spread * (1.8*mouse.x-0.9);\n    \n    //The covariance matrix -- we don't actually use it to visualize!\n    mat2 mCov = mat2(\n    \txVar,    xyCoVar,\n    \txyCoVar, yVar);\n    \n    //Compute the inverse covariance matrix for rendering\n    float dCov = (xVar*yVar-xyCoVar*xyCoVar);\n    mat2 mCovInv = mat2(\n        yVar    /dCov, -xyCoVar/dCov,\n        -xyCoVar/dCov, xVar    /dCov);\n    \n    //What position in the standard normal distribution does this pixel map to?\n    vec2 loc = 2.0 * (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    vec2 stdPos = mCovInv * loc;\n    \n    //Visualize the probability density\n    float density = exp(-.5*dot(stdPos, stdPos));\n    \n    //...Plus some little ellipses for each standard deviation away from the mean\n    float ringPhase = PI*max(length(stdPos),.5);\n    float ring = pow(cos(ringPhase)*cos(ringPhase), 8.0)\n        * (.5+.5*cos(atan(stdPos.y,stdPos.x)*13.0*floor(length(stdPos)+.5)));\n    \n    fragColor = vec4(density+.3*ring, density, density, 1.0);\n}","name":"Image","description":"","type":"image"}]}