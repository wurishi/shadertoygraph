{"ver":"0.1","info":{"id":"sd2BzD","date":"1645790672","viewed":79,"name":"Penumbra LUT texture","username":"WorkingJoe","description":"Generates a LUT for the occlusion within a shadow for usage in a soft LoS shader. The LUT is in polar coordinates. Distance from the occluder changing with X, the angle from the occluder changes with Y.  ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Amount of light points sampled (includes top half of disk)\nconst int lightPoints = 2048;\n\n// Radius of the light\nconst float lightRadius = .05;\n\n// Distance of the occluder from the origin on the X axis\nconst float occluderDistance = .25;\n\n// Maximum distance from at which the shadow is evaluated\n// (the output tex X ranges from the occluder to the occluder plus this distance)\nconst float rayLength = 1.;\n\n// Angle from the occluder at which the shadow is evaluated\n// (the output tex Y ranges from 0 to this angle)\nconst float penumbraAngle = 0.15;\n\n// This shader calculates the light level in the penumbra of a shadow\n// The light source is at the world origin.\n// The occluder extends down from the X acis and to the right from the occluder distance.\n// The light level is calculated by testing for each point in the shadow the line of sight to points\n// in the lower half of the light's radius (all points in the upper half would hit). \n// The points chosen lie on the lower half of a vogel disk.\n\nfloat getDiskRays(vec2 worldPos)\n{\n    float lightLevel = 0.;\n    int lightCount = 0;\n    \n    for (int i = 0; i < lightPoints; i++)\n    {\n        // Vogel disk sampling\n        float theta = 2.4 * float(i);\n        float r = sqrt((float(i) + 0.5) / float(lightPoints));\n        vec2 u = r * vec2(cos(theta), sin(theta));\n        \n        // Discard samples in the top half circle\n        if(u.y > 0.) continue; \n        \n        // Calculate light position of bottom half\n        vec2 lightPos = u * lightRadius;\n        lightCount++;\n        \n        // Increase the light level if there is LoS\n        // Think of this as evaluating a a linear equation from the light to the point in the shadow \n        // at the X coordinate of the occluder. There is LoS if this line is above the X axis at this point.\n        lightLevel += step(0., lightPos.y+(worldPos.y-lightPos.y)/(worldPos.x-lightPos.x)*(occluderDistance-lightPos.x));      \n        \n    }\n    lightLevel /= float(lightCount);     \n    \n    return lightLevel;\n}\n\nfloat getLight(vec2 uv)\n{\n    float r = occluderDistance + uv.x*rayLength;\n    float angle =  uv.y*penumbraAngle;\n    // angle =  uv.y*atan(lightRadius/occluderDistance); // uncomment for auto-scaling the angle\n    vec2 worldPos = r*vec2(cos(angle), sin(angle));\n    return getDiskRays(worldPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float light = getLight(uv);\n    \n    // Output to screen\n    fragColor = vec4(vec3(light),1.);\n}\n\n","name":"Image","description":"","type":"image"}]}