{"ver":"0.1","info":{"id":"tdy3zD","date":"1584146154","viewed":74,"name":"Raytracer #3 -- TheRealJoe","username":"TheRealJoe24","description":"I think i have finally made a good raytracer! Used in reflections contest.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T_FAR 1000.\n\n#define LIGHT_DIR   0\n#define LIGHT_POINT 1\n#define LIGHT_AMB   2\n\nconst vec3 BACKGROUND_COL = vec3(0.2,0.2,0.5);\n\nstruct HitData {\n    float t1;\n\tfloat t2;\n\tvec3 p1;\n    vec3 p2;\n    vec3 n;\n    bool hit;\n};\n    \nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Sphere {\n\tvec3 c;\n    float r;\n    vec3 col;\n    float specular;\n    float reflective;\n    float alpha;\n};\n    \nstruct Light {\n\tvec3 p;\n    float intensity;\n    int type;\n};\n\nmat3 rotateX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n    \t1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\nSphere nullSphere = Sphere(vec3(0),0.,BACKGROUND_COL,0.,0.,0.);\n    \nHitData iSphere(Ray r, Sphere sphere) {\n\tHitData data;\n\tvec3 co = r.o-sphere.c;\n    float a = dot(r.d,r.d);\n    float b = 2.*dot(r.d,co);\n    float c = dot(co,co) - sphere.r*sphere.r;\n    float delta = b*b - 4.*a*c;\n    if (delta < 0.) data.hit = false;\n    else {\n        data.t1 = (-b-sqrt(delta)) / (2.*a);\n        data.t2 = (-b+sqrt(delta)) / (2.*a);\n        data.p1 = r.o + data.t1*r.d;\n        data.n = normalize(data.p1-sphere.c);\n\t\tdata.hit = true;\n    }\n    return data;\n}\n\nSphere traceSingleRay(Ray r, out HitData o_hitData) {\n\tSphere spheres[3] = Sphere[3](\n    \tSphere(vec3(1.5,0,5),1.,vec3(1,0,0),200.,0.,1.),\n        Sphere(vec3(-1.5,0,5),1.,vec3(1,1,1),100.,0.,1.),\n        Sphere(vec3(0,-5001,1),5000.,vec3(1,0,1),-1.,0.6,1.)\n    );\n    Sphere hitSphere = nullSphere;\n    float t = T_FAR;\n    o_hitData = HitData(T_FAR,T_FAR,vec3(0),vec3(0),vec3(0),false);\n    for (int i = 0; i < spheres.length(); i++) {\n    \tSphere sphere = spheres[i];\n        HitData hitData = iSphere(r,sphere);\n        if (hitData.hit && hitData.t1 < t && hitData.t1 > 0.001) {\n        \tt = hitData.t1;\n            o_hitData = hitData;\n            hitSphere = sphere;\n        }\n        \n        /*if (hitData.hit && hitData.t2 < t && hitData.t2 > 0.001) {\n        \tt = hitData.t2;\n            o_hitData = hitData;\n            hitSphere = sphere;\n        }*/\n    }\n    return hitSphere;\n}\n\nfloat computeLighting(vec3 p, vec3 n, vec3 rd, float specular, Sphere sphere) {\n\tfloat intensity = 0.;\n    \n    Light lights[3] = Light[3](\n    \tLight(vec3(1,2,5),0.5,LIGHT_POINT),\n        Light(vec3(1,0,-1),0.25,LIGHT_DIR),\n\t\tLight(vec3(0),0.25,LIGHT_AMB)\n    );\n    \n    for (int i = 0; i < lights.length(); i++) {\n    \tLight light = lights[i];\n        if (light.type != LIGHT_AMB) {\n            vec3 l;\n            if (light.type == LIGHT_POINT)\n            \tl = normalize(light.p-p);\n            else if (light.type == LIGHT_DIR)\n                l = light.p;\n            \n            HitData shadowData;\n            Sphere shadowSphere = traceSingleRay(Ray(p,normalize(p-light.p)),shadowData);\n            //if (!shadowData.hit || sphere != shadowSphere || light.type == LIGHT_DIR) {\n                float d = clamp(dot(n,l),0.,1.);\n                if (d > 0.)\n                    intensity += light.intensity*d/(length(n)*length(l));\n\n                if (specular != -1.) {\n                    vec3 r = 2.*n*dot(n,l) - l;\n                    d = dot(r,-rd);\n                    if (d > 0.)\n                        intensity += light.intensity*pow(d/(length(r)*length(-rd)),specular);\n                }\n            //}\n        } else {\n        \tintensity += light.intensity;\n        }\n    }\n    \n    return intensity;\n}\n\nvec3 traceReflection(Ray ray, HitData hitData, Sphere hitSphere) {\n\tvec3 col = vec3(0);\n    float r = 0.;\n    float rlight = 1.;\n    Sphere reflectedSphere;\n    for (int i = 0; i < 1; i++) {\n    \tray.d = reflect(ray.d,hitData.n);\n        Ray ref = Ray(hitData.p1,ray.d);\n        HitData refHitData;\n        reflectedSphere = traceSingleRay(ref,refHitData);\n        if (reflectedSphere.reflective <= 0. && reflectedSphere != nullSphere) {\n        \trlight = computeLighting(refHitData.p1, refHitData.n, ref.d, reflectedSphere.specular, hitSphere);\n            //col += hitSphere.col*(1.-hitSphere.reflective)+(reflectedSphere.col*hitSphere.reflective*rlight);\n            r += hitSphere.reflective;\n            if (hitSphere.alpha >= 1.)\n                col = hitSphere.col*computeLighting(hitData.p1, hitData.n, ref.d, hitSphere.specular, hitSphere)*(1.-r)+(reflectedSphere.col*r*rlight);\n            else\n                col = BACKGROUND_COL;\n            if (reflectedSphere.reflective <= 0.) break;\n            hitSphere = reflectedSphere;\n            hitData = refHitData;\n    \t}\n    }\n    return col;\n}\n\nmat3 rotateY(float a) {\n\treturn mat3(\n    \tcos(a), 0, sin(a),\n        0, 1, 0, \n        -sin(a), 0, cos(a)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = BACKGROUND_COL;\n    //vec3 col = texture(iChannel0,uv).xyz;\n    \n    vec3 ro = vec3(cos(iTime)*5.,1,sin(iTime)*5.+5.);\n    //vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv,1))*rotateX(sin(iTime*0.5)*0.2)*rotateY(-3.14/2.-iTime);\n    Ray r = Ray(ro,rd);\n    HitData hitData;\n    Sphere hitSphere = traceSingleRay(r,hitData);\n    \n    if (hitData.hit) {\n        if (hitSphere.reflective > 0.) {\n            //col = traceReflection(r,hitData,hitSphere);\n            col = vec3(0);\n            float r = 0.;\n            float rlight = 0.;\n            Sphere reflectedSphere;\n            for (int i = 0; i < 1; i++) {\n                rd = reflect(rd,hitData.n);\n                Ray ref = Ray(hitData.p1,rd);\n                HitData refHitData;\n                reflectedSphere = traceSingleRay(ref,refHitData);\n                float rlight = 1.;\n                if (reflectedSphere.reflective <= 0. && reflectedSphere != nullSphere)\n                    rlight = computeLighting(refHitData.p1, refHitData.n, ref.d, reflectedSphere.specular, hitSphere);\n                //col += hitSphere.col*(1.-hitSphere.reflective)+(reflectedSphere.col*hitSphere.reflective*rlight);\n                r += hitSphere.reflective;\n                if (hitSphere.alpha >= 1.)\n                \tcol = hitSphere.col*computeLighting(hitData.p1, hitData.n, ref.d, hitSphere.specular, hitSphere)*(1.-r)+(reflectedSphere.col*r*rlight);\n                else\n                \tcol = BACKGROUND_COL;\n                if (reflectedSphere.reflective <= 0.) break;\n                hitSphere = reflectedSphere;\n                hitData = refHitData;\n            }\n        } else if (hitSphere.alpha < 1.) {\n            Ray ref = Ray(hitData.p2,refract(rd,hitData.n,0.2));\n            HitData refHitData;\n        \tSphere refractedSphere = traceSingleRay(ref,refHitData);\n            if (refHitData.hit)\n            \tcol = refractedSphere.col*computeLighting(hitData.p1, hitData.n, r.d, hitSphere.specular, hitSphere);\n        }\n        else {\n            float light = computeLighting(hitData.p1, hitData.n, r.d, hitSphere.specular, hitSphere);\n            col = hitSphere.col*light;\n        }\n    }\n    \n    //if (fragCoord.x > iResolution.x/2.-1. && fragCoord.x < iResolution.x/2.+1.) col = vec3(1,0,0);\n\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}