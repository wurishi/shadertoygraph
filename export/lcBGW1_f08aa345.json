{"ver":"0.1","info":{"id":"lcBGW1","date":"1704149787","viewed":42,"name":"ewdlop's parametric curve","username":"ewdlop","description":"parametric curve","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["parametriccurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    // Adjust the frequency and phase of the sine and cosine functions\n    float frequency = 2.;\n    float time = iTime; // Assuming iTime is a uniform representing elapsed time\n\n    for(int i = 0; i < 10; i++)\n    {\n        float t = float(i) * 0.001 + time * 0.1; // Adjust t for a smooth curve and animate it\n        float y = cos(3. * frequency * 3.1415 * t) * 0.5; // Scale and translate y\n        float x = sin(2. * frequency * 3.1415 * t) * 0.5; // Scale and translate x\n\n        // Check if the pixel is close to the point on the curve\n        if (length(uv - vec2(x,y)) < 0.01) {\n            col += vec3(1,0,0); // Incrementally color it red\n        }\n    }\n    \n    for(int i = 0; i < 1000; i++)\n    {\n        float t = float(i) * 0.001; // Adjust t for a smooth curve and animate it\n        float y = cos(3. * frequency * 3.1415 * t) * 0.5; // Scale and translate y\n        float x = sin(2. * frequency * 3.1415 * t) * 0.5; // Scale and translate x\n\n        // Check if the pixel is close to the point on the curve\n        if (length(uv - vec2(x,y)) < 0.01) {\n            col += vec3(0,abs(uv.x),abs(uv.y)); // Incrementally color\n        }\n   }\n\n    col = clamp(col, 0.0, 1.0); // Ensure color components are within valid range\n\n    fragColor = vec4(col,1.0); // Set the color of the pixel\n}\n","name":"Image","description":"","type":"image"}]}