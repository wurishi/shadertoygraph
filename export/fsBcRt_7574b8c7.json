{"ver":"0.1","info":{"id":"fsBcRt","date":"1705585144","viewed":217,"name":"Nemo Music Visualizer","username":"TambakoJaguar","description":"I created this music visualizer a long time ago, but didn't finish it because SoundCloud didn't work. Now it works, I put my latest house track on it.\nI saw a quite similar visualizer on youtube videos and decided to recreate it.\nComments welcome!","likes":17,"published":1,"flags":96,"usePreview":0,"tags":["3d","music","animated","visualizer","graph","display","pixels","soundcloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void init()\n{    \n    lamp = Lamp(vec3(-60., -20, 70.), vec3(1., 1., 1.), 2.7, 0.01);\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat box(vec3 position, vec3 halfSize, float cornerRadius)\n{\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(max(position.x, position.y), position.z), 0.0) - cornerRadius;\n}\n\n// From https://www.shadertoy.com/view/stcGRX\nfloat map(vec3 pos)\n{\n    return box(pos - device_offset, device_size.xyz, device_size.w);\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.08;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 60; ++i)\n    {\n    \tpos = ray*t + cam;\n        dist = map(pos);\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*0.99;\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2);\n    }\n    return normalize(n);\n}\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    //return pow(texture(iChannel0, ray).rgb, vec3(1./gamma));\n    \n    float angle = atan(ray.x, ray.z);\n    \n    float gval;\n    if (ray.y<0.)\n        gval = 0.3 + abs(ray.y)*0.6*(0.8-0.2*cos(3.*pi*angle));\n    else\n        gval = 0.3 + (1. - ray.y)*0.6*(0.6+0.4*cos(3.*pi*angle));\n        \n    return vec3(gval);\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   vec2 tpos = pos.xy*vec2(-0.08, 0.12) + vec2(0.5, 0.3);\n   if (tpos.x<-screen_border || tpos.x>1. + screen_border || tpos.y<-screen_border || tpos.y>1. + screen_border)\n       return device_color;\n   else if (tpos.x<0. || tpos.x>1. || tpos.y<0. || tpos.y>1.)\n       return disp_color;\n   else\n       return texture(iChannel1, tpos).rgb;\n\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{   \n    float specint, specshin;\n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    vec2 tpos = pos.xy*vec2(-0.08, 0.12) + vec2(0.5, 0.3);\n    if (tpos.x<-screen_border || tpos.x>1. + screen_border || tpos.y<-screen_border || tpos.y>1. + screen_border)\n    {\n        specint = specint_device;\n        specshin = specshin_device;\n    }\n    else\n    {\n        specint = specint_display;\n        specshin = specshin_display;\n    }\n    if (dot(norm, campos - pos) > 0.0)\n    col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nvoid setCamera()\n{\n   float time2 = iTime*0.5;\n\n   campos.x = 12.*cos(time2);\n   campos.y = 5.*sin(time2*1.4);\n   campos.z = 14.;\n   \n   camtarget = vec3(0., 1.5, 0.);\n\n   camdir = camtarget - campos; \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampShading(lamp, norm, pos, col, objnr);\n    }\n    else\n        col = background_color; //getSkyColor(ray);\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    \n    // Simple \"sky\" reflection\n    vec2 tpos = traceinf.pos.xy*vec2(-0.08, 0.12) + vec2(0.5, 0.3);\n    if (length(traceinf.pos)<maxdist/2. && tpos.x>-screen_border && tpos.x<1. + screen_border && tpos.y>-screen_border && tpos.y<1. + screen_border)\n    {    \n        vec3 norm = traceinf.norm;\n        vec3 refray = reflect(ray, norm);\n        vec3 sky = getSkyColor(refray);\n        float rf = fresnel(ray, norm, 3.7);\n        col = mix(col, sky, rf);\n    }\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    #ifdef test_graph\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n    #else\n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {    vec2 uv = fragCoord/iResolution.xy;\n        vec4 sc = texture(iChannel0, uv);\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsd3Rs","filepath":"https://soundcloud.com/tambako/shine","previewfilepath":"https://soundcloud.com/tambako/shine","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 sc = texture(iChannel0, uv);\n    vec4 ba = texture(iChannel1, uv);\n    sc.y = max(sc.x, ba.y - peek_graph_decay*0.001);\n    fragColor = sc;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n\"Nemo Music Visualizer\" by Emmanuel Keller aka Tambako - January 2024\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n\n\n   ToDo:\n   - Wave should have round pixels\n   - Reflective \"studio\" pattern\n   - Lower part of display: red text with free text scrolling (set scrolling speed)\n*/\n\n// The settings of the graph\n\n#define peek_graph\n#define wave_graph\n//#define test_graph\n#define show_text\n//#define rgb_pixels\n\nconst float graph_intenity = 1.2;\n\nconst float fa_scale = 0.8; \nconst float nbbands = 128.;\nconst float bar_smoothness = 1.2;\n\n#ifdef rgb_pixels\nconst float pix_per_band = 1.*3.;\nconst float pix_ratio = 0.6*3.;\n#else\nconst float pix_per_band = 1.;\nconst float pix_ratio = 0.6;\n#endif\nconst float pix_size = 1.12;\nconst float pix_smoothness = 0.4;\n\n\nconst float peek_graph_int = 0.25;\nconst float peek_graph_decay = 6.;\n\nconst float wave_thickess = 0.015;\nconst vec3 wave_color = vec3(0.5, 0.6, 1.);\n\nconst vec3 pix_color = vec3(0.07, 0.08, 0.13);\nconst vec3 disp_color = vec3(0.03, 0.06, 0.03);\nconst vec3 device_color = vec3(0.35, 0.4, 0.45);\nconst vec3 background_color = vec3(0.5);\n\nconst vec4 device_size = vec4(7., 5.5, 2.6, 0.08);\nconst vec3 device_offset = vec3(0., 1., -2.);\n\nconst float screen_border = 0.023;\n\nconst vec2 charSpacingFac = vec2(.52, .95);\nconst float text_height = 15.;\nconst vec3 text_color = vec3(0.9, 0.15, 0.1);\nconst vec3 text_bg_color = vec3(0.0);\nconst float scroll_speed = 1.35;\nconst float scroll_width = 12.5;\n\n#define pi 3.14159265359\n\n#define specular\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.35;\n\n// Specular options\nconst float specint_display = 0.28;\nconst float specshin_display = 500.;\nconst float specint_device = 0.14;\nconst float specshin_device = 5.;\n\n// Tracing options\nconst float normdelta = 0.0005;\nconst float maxdist = 50.;\n\nconst float gamma = 1.7;\n\n// Campera options\nvec3 campos;\nvec3 camtarget;\nvec3 camdir;\nfloat fov = 3.1;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n    \nLamp lamp;\n\nint aai;\nint aaj;\n\n#define al(i) 65 + int(hash(float(i)*742.5)*26.)\n\n#define _a if (idx==chi) char = 97; chi++;\n#define _b if (idx==chi) char = 98; chi++;\n#define _c if (idx==chi) char = 99; chi++;\n#define _d if (idx==chi) char = 100; chi++;\n#define _e if (idx==chi) char = 101; chi++;\n#define _f if (idx==chi) char = 102; chi++;\n#define _g if (idx==chi) char = 103; chi++;\n#define _h if (idx==chi) char = 104; chi++;\n#define _i if (idx==chi) char = 105; chi++;\n#define _j if (idx==chi) char = 106; chi++;\n#define _k if (idx==chi) char = 107; chi++;\n#define _l if (idx==chi) char = 108; chi++;\n#define _m if (idx==chi) char = 109; chi++;\n#define _n if (idx==chi) char = 110; chi++;\n#define _o if (idx==chi) char = 111; chi++;\n#define _p if (idx==chi) char = 112; chi++;\n#define _q if (idx==chi) char = 113; chi++;\n#define _r if (idx==chi) char = 114; chi++;\n#define _s if (idx==chi) char = 115; chi++;\n#define _t if (idx==chi) char = 116; chi++;\n#define _u if (idx==chi) char = 117; chi++;\n#define _v if (idx==chi) char = 118; chi++;\n#define _w if (idx==chi) char = 119; chi++;\n#define _x if (idx==chi) char = 120; chi++;\n#define _y if (idx==chi) char = 121; chi++;\n#define _z if (idx==chi) char = 122; chi++;\n\n#define _A if (idx==chi) char = 65; chi++; \n#define _B if (idx==chi) char = 66; chi++; \n#define _C if (idx==chi) char = 67; chi++; \n#define _D if (idx==chi) char = 68; chi++; \n#define _E if (idx==chi) char = 69; chi++; \n#define _F if (idx==chi) char = 70; chi++; \n#define _G if (idx==chi) char = 71; chi++; \n#define _H if (idx==chi) char = 72; chi++; \n#define _I if (idx==chi) char = 73; chi++; \n#define _J if (idx==chi) char = 74; chi++;\n#define _K if (idx==chi) char = 75; chi++;\n#define _L if (idx==chi) char = 76; chi++; \n#define _M if (idx==chi) char = 77; chi++; \n#define _N if (idx==chi) char = 78; chi++; \n#define _O if (idx==chi) char = 79; chi++; \n#define _P if (idx==chi) char = 80; chi++; \n#define _Q if (idx==chi) char = 81; chi++; \n#define _R if (idx==chi) char = 82; chi++; \n#define _S if (idx==chi) char = 83; chi++; \n#define _T if (idx==chi) char = 84; chi++; \n#define _U if (idx==chi) char = 85; chi++; \n#define _V if (idx==chi) char = 86; chi++; \n#define _W if (idx==chi) char = 87; chi++; \n#define _X if (idx==chi) char = 88; chi++; \n#define _Y if (idx==chi) char = 89; chi++; \n#define _Z if (idx==chi) char = 90; chi++;\n\n#define _0 if (idx==chi) char = 48; chi++;\n#define _1 if (idx==chi) char = 49; chi++;\n#define _2 if (idx==chi) char = 50; chi++;\n#define _3 if (idx==chi) char = 51; chi++;\n#define _4 if (idx==chi) char = 52; chi++;\n#define _5 if (idx==chi) char = 53; chi++;\n#define _6 if (idx==chi) char = 54; chi++;\n#define _7 if (idx==chi) char = 55; chi++;\n#define _8 if (idx==chi) char = 56; chi++;\n#define _9 if (idx==chi) char = 57; chi++;\n\n#define _SP if (idx==chi) char = 32; chi++;\n#define _PT if (idx==chi) char = 46; chi++;\n#define _QU if (idx==chi) char = 34; chi++;\n\n#define _Title _QU _S _h _i _n _e _QU _SP _b _y _SP _T _a _m _b _a _k _o","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float getChar(vec2 uv, int ch)\n{\n    ch-= 127;\n    vec2 uv2 = mod(uv, charSpacingFac*1./16.);\n    uv2.y-= 0.5;\n    vec2 offset = vec2(0.012+mod(float(ch-1), 16.)/16., -float(ch/16)/16.-0.003);\n    vec2 pos = uv2 + offset;\n    return texture(iChannel1, pos).r;\n}\n\nfloat textTexture(vec2 uv)\n{\n   int idx = int(uv.x*16./charSpacingFac.x)+1000*int(uv.y*16./charSpacingFac.y); \n    \n   int char = 32;\n   int chi = 0;\n    \n   _Title\n    \n   return char==32?0.0:getChar(uv, char);\n}\n\nvec3 getGraph(vec2 pos, float gint, vec3 graph_color, float lwidth)\n{\n    vec2 uv = pos/iResolution.xy;\n    vec2 uv2 = pos/iResolution.xx;\n    \n    float freqlevel = fa_scale*gint;\n    \n    vec2 pix_scale = vec2(1., 1./pix_ratio)*nbbands*pix_per_band;\n    uv.y = (floor(uv.y*pix_scale.y*iResolution.y/iResolution.x))/(pix_scale.y*iResolution.y/iResolution.x);\n    \n    float cl;\n    if (lwidth==0.)\n       cl = smoothstep(freqlevel, freqlevel - 0.01*bar_smoothness, uv.y);\n    else\n       cl = smoothstep(freqlevel, freqlevel - 0.01*bar_smoothness, uv.y)\n          - smoothstep(freqlevel - lwidth, freqlevel - 0.01*bar_smoothness - lwidth, uv.y);\n    \n    vec2 cuv = 2.*fract(uv2*pix_scale) - vec2(1.);\n    float cv = smoothstep (cl*pix_size, cl*pix_size - pix_size*pix_smoothness, length(cuv));\n    \n    vec3 col = cv*graph_color;\n    #ifdef rgb_pixels\n    float pixc = mod(floor(uv.x*pix_scale.x), 3.);  \n    if (pixc==0.) col = vec3(col.r, 0., 0.);\n    if (pixc==1.) col = vec3(0, col.g, 0.);\n    if (pixc==2.) col = vec3(0, 0., col.b);\n    #endif\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef show_text\n    float pix_scale_y = (1./pix_ratio)*nbbands*pix_per_band;\n    fragCoord.y*= 1. - 1./pix_scale_y*text_height;\n    fragCoord.y-= text_height*iResolution.x/pix_scale_y;\n    #endif\n\n    vec2 uv = fragCoord/iResolution.xy;\n    #ifdef rgb_pixels\n    float xpost = floor(uv.x*nbbands*3.)/(nbbands*3.);\n    float xpos = floor(uv.x*nbbands)/nbbands;\n    #else\n    float xpost = floor(uv.x*nbbands)/nbbands;\n    float xpos = floor(uv.x*nbbands)/nbbands;\n    #endif\n    \n    vec3 graph_color = vec3(0.);\n    #ifdef show_text\n    if (uv.y<0.)\n    {\n        float ypos = floor(uv.y*pix_scale_y*iResolution.y/iResolution.x)/(pix_scale_y*iResolution.y/iResolution.x);\n        vec2 uvt = vec2(mod(xpost*9. + scroll_speed*iTime, scroll_width), ypos*5.6)/text_height;\n        float cv = textTexture(uvt);\n        graph_color = mix(text_bg_color, text_color, cv);\n    }\n    else\n    {\n    #endif\n        graph_color.r = pow(smoothstep(0., 0.4, uv.y/fa_scale), 0.2);\n        graph_color.g = pow(smoothstep(1., 0.4, uv.y/fa_scale), 0.6);\n        graph_color.b = 0.;\n    #ifdef show_text        \n    }\n    #endif\n    \n    float pixint = 2.;\n    vec3 pix_col = getGraph(fragCoord, pixint, pix_color, 0.);\n    \n    float gint1 = texture(iChannel0, vec2(xpos, 0.25)).x;\n    vec3 col1 = getGraph(fragCoord, gint1, graph_color, 0.);\n    \n    #ifdef peek_graph\n    float gint2 = texture(iChannel0, vec2(xpos, 0.25)).y;\n    vec3 col2 = peek_graph_int*getGraph(fragCoord, gint2, graph_color, 0.);\n    #else\n    vec3 col2 = vec3(0.);\n    #endif\n    \n    #ifdef wave_graph\n    float gint3c = texture(iChannel0, vec2(xpos, 0.75)).x;\n    float gint3r = texture(iChannel0, vec2(xpos+1./nbbands, 0.75)).x;\n    float gint3r2 = texture(iChannel0, vec2(xpos+2./nbbands, 0.75)).x;\n    float gint3l = texture(iChannel0, vec2(xpos-1./nbbands, 0.75)).x;\n    float gint3l2 = texture(iChannel0, vec2(xpos-2./nbbands, 0.75)).x;\n    float gint3 = 0.4*gint3c + 0.2*gint3r + 0.2*gint3l + 0.1*gint3r2 + 0.1*gint3l2;\n    vec3 wave = getGraph(fragCoord, gint3, wave_color, wave_thickess);\n    #else\n    vec3 wave = vec3(0.);\n    #endif\n    \n    vec3 col = disp_color + pix_col + graph_intenity*max(wave, max(col1, col2));\n    fragColor = vec4(col, 0.);\n}","name":"Buffer B","description":"","type":"buffer"}]}