{"ver":"0.1","info":{"id":"XtsXRM","date":"1435380606","viewed":478,"name":"Neon Cubes","username":"rubixcom","description":"Having fun with Raymarching. Please feel free to point out the mistakes, as I am very new to this :-P","likes":7,"published":1,"flags":1,"usePreview":0,"tags":["raymarching","cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sphere( vec3 p, float r )\n{\n  return length(p)-r;\n}\n\nfloat map(vec3 p)\n{\n  return max(udRoundBox(p, vec3(.8,.8,.8), .2), -sphere(p, 1.2*sin(iTime))) ;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.01*t; // use 0.1 for correct and 0.01 for cool\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 rayVector(in vec3 position, in vec3 target, in vec2 fragCoord)\n{\n    vec3 eye = normalize(target - position);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(eye, up);\n    up = cross(eye,right);\n\n    mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                \t\t\t right.y, up.y, eye.y,\n                \t\t\t right.z, up.z, eye.z);\n\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    uv.y = -uv.y;\n    float focalDistance = 1.0 + .3 * sin(iTime* .25);\n    return (normalize(vec3(uv.x,uv.y,focalDistance)) * cameraMatrix)* .9;\n}\n\n\nvec4 shade(in vec3 pos, in vec3 normal, in vec3 cameraVector, in vec3 lightPos, in vec4 lightColor, in vec4 surface)\n{\n    vec3 light = normalize(lightPos - pos);\n    float dotlight = dot(normal,light);\n\n    vec3 cameraReflected = normalize(reflect(cameraVector,normal));\n    float spec = 0.0;\n    if (dot(cameraReflected,light) < 0.0)\n        spec = min(1.0,pow(dot(cameraReflected,light),2.0));\n    return (surface\n        * vec4(0.2+dotlight) * lightColor\n        + vec4(0.5*spec)) * 60.0/length(lightPos - pos); // Sphere color\n}\n\nvec4 march(in vec3 ro, in vec3 rd, mat3 rotation, vec3 shapeLoc, vec3 light) \n{\n    \n    vec4 color = vec4(0.0); // Sky color\n\n    float t = 0.0;\n    const int maxSteps = 40;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        \n        vec3 po = p + vec3(0.0,8.0*iTime,0.0);\n        \n        vec3 pm = mod(po,6.0) + 2.0 * mod(vec3(0.,float(int(po.y/6.)),0.),2.) - shapeLoc;        \n\n        pm = rotation * pm;\n        \n        float d = map(pm);\n        \n        if(d < 0.01)\n        {\n            vec3 normal = calcNormal(pm, t);\n\t\t\tcolor = shade(p, normal,-rd, light,\n                          vec4(.5 + .25*sin(t+iTime),.5 + .25*cos(t+iTime),0.0,0.0), \n                          texture(iChannel0, normal));\n            break;\n        }\n\n        t += d;\n    }\n\n    return color;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 shapeLoc = vec3(3.0,3.0,3.0);\n    vec3 light = ro;\n    \n    mat3 rotation = mat3(cos(iTime),-sin(iTime), 0.,\n                  sin(iTime),cos(iTime), 0.,\n                   0.,0.,1.);\n    \n    fragColor = march(ro, rd, rotation, shapeLoc, light);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 shapeLoc = vec3(3.0,3.0,3.0);\n    vec3 cameraLoc = vec3(4.0 * sin(iTime), 6.0 + 4.0 * sin(0.4*iTime) , 4.0 * cos(iTime)) + shapeLoc;\n    vec3 cameraTarget = shapeLoc;// + vec3(0.0,1.+1.*sin(iTime*.01),0.0);\n    vec3 light = cameraLoc;\n    \n    vec3 ro = cameraLoc;\n    vec3 rd = rayVector(cameraLoc, cameraTarget, fragCoord);\n    \n    mat3 rotation = mat3(cos(iTime),-sin(iTime), 0.,\n                  sin(iTime),cos(iTime), 0.,\n                   0.,0.,1.);\n    \n    fragColor = march(ro, rd, rotation, shapeLoc, light);\n}","name":"Image","description":"","type":"image"}]}