{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\niResolution frag->position !=p =op\n\n:m light [ 0.81 0.80 0.70 ] ;\n:m dark [ 0.19 0.15 0.06 ] ;\n\np time .37 * sin 2 ** 3 * abs .5 + * time 2 / sin 2 * rotate-2d [ time .17 * time .37 * ] 5 * + =p\n&snoise-2d p gradient =v\n1 op [ .1 .2 ] - length - abs v 2 ** * 0 v 0 < select =spec\nlight dark v 1 + 2 / mix spec abs .3 * + ->fragcolor\n*/\n\nvec2 rotate_2d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec3 permute(vec3 x) {\n\treturn mod((x * 34. + 1.) * x, 289.);\n}\nfloat snoise_2d(vec2 v) {\n\tvec4 C = vec4(.211324865405187, .366025403784439, -.577350269189626, .024390243902439);\n\tvec2 i = floor(dot(v, C.yy) + v);\n\tvec2 x0 = v - i + dot(i, C.xx);\n\tvec2 i1 = x0.x > x0.y ? vec2(1., 0.) : vec2(0., 1.);\n\tvec4 x12 = x0.xyxy + C.xxzz - vec4(i1, 0., 0.);\n\ti = mod(i, 289.);\n\tvec3 p = permute(permute(vec3(0., i1.y, 1.) + i.y) + i.x + vec3(0., i1.x, 1.));\n\tvec3 m = max(.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\n\tm = m * m * m * m;\n\tvec3 x = 2. * fract(p * C.www) - 1.;\n\tvec3 h = abs(x) - .5;\n\tvec3 ox = floor(x + .5);\n\tvec3 a0 = x - ox;\n\tm = (1.79284291400159 - .85373472095314 * (a0 * a0 + h * h)) * m;\n\treturn dot(m, vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw)) * 130.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 var_0 = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tvec2 p = var_0;\n\tvec2 op = var_0;\n\tp = rotate_2d(p * (abs(pow(sin(iTime * .37), 2.) * 3.) + .5), sin(iTime / 2.) * 2.) + vec2(iTime * .17, iTime * .37) * 5.;\n\tvec2 h = vec2(.00001, 0.);\n\tfloat v = snoise_2d(p) / abs(length(vec2(snoise_2d(p + h) - snoise_2d(p - h), snoise_2d(p + h.yx) - snoise_2d(p - h.yx)) / (2. * h.x)));\n\tfloat spec = v < 0. ? abs(1. - length(op - vec2(.1, .2))) * pow(v, 2.) : 0.;\n\tfragColor = vec4(mix(vec3(.81, .80, .70), vec3(.19, .15, .06), (v + 1.) / 2.) + abs(spec) * .3, 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdBSWy","date":"1415402889","viewed":255,"name":"Grey Matter","username":"daeken","description":"Simplex noise rendered to look like brains.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["simplex","shaderforth","brains"],"hasliked":0,"parentid":"","parentname":""}}