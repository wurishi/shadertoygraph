{"ver":"0.1","info":{"id":"wsKfzK","date":"1607591625","viewed":178,"name":"First Raymarcher - Eliott Moret","username":"eliottmoret","description":"My first raymarcher","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x,0.0,1.0);\n}\n\nvec3 ACESFilm(vec3 x)\n{\nfloat a = 2.51f;\nfloat b = 0.03f;\nfloat c = 2.43f;\nfloat d = 0.59f;\nfloat e = 0.14f;\nreturn saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\n//SDFs\nvec2 sdSphere(vec3 p, vec3 pos, float radius, float id){\n    return vec2(length(p-pos)-radius, id);\n}\n\nvec2 sdBox( vec3 p, vec3 b , float id)\n{\n  vec3 q = abs(p) - b;\n  return vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), id);\n}\n\n//Merges\nvec2 Union(vec2 d1, vec2 d2){\n    return vec2((d1.x<d2.x) ?  d1 : d2);\n}\n\nvec2 Map(vec3 p){\n\t\n    vec2 d;\n    vec2 sphere01 = sdSphere(p, vec3(-3.,1.,6.), 1., 0.);\n    vec2 sphere02 = sdSphere(p, vec3(3.,1.,6.), 1., 1.);\n    vec2 sphere03 = sdSphere(p, vec3(0.,1.,8.), 1., 3.);\n    vec2 box01 = sdBox(p - vec3(0.,-1.0,5.), vec3(40.,1.0,40.), 2.);\n    \n    \n    vec2 planeDist = vec2(p.y,2.);\n    \n    d = Union(sphere01, sphere02);\n    d = Union(d, sphere03);\n    d = Union(d, box01);\n    //d = Union(d, planeDist);\n    return vec2(d);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd){    \n    float dO=0.;\n    float id;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n\n    \tvec3 p = ro + dO*rd;\n        float dS = Map(p).x;\n        id = Map(p).y;\n        dO += dS;\n        \n        if(dO>MAX_DIST) id = -1.;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, id);\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = Map(p).x;\n    vec2 eps = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n    Map(p-eps.xyy).x,\n    Map(p-eps.yxy).x,\n    Map(p-eps.yyx).x);\n    \n    return normalize(n);\n}\n\nvoid GetMats(in float id, out vec3 col, out float spec, out float refl){\n    if(id==0.){\n        col = vec3(0.1,0.01,0.01);\n        spec = 0.4;\n        refl = 0.5;\n    }\n    else if (id==1.){\n        col = vec3(0.02,0.2,0.02);\n        spec = 0.;\n        refl = 0.2;\n    }\n    else if (id==2.){\n        col = vec3(0.1,0.1,0.1);\n        spec = 0.2;\n        refl = 0.1;\n    }\n    else if (id==3.){\n        col = vec3(0.2,0.1,0.0);\n        spec = 0.2;\n        refl = 0.5;\n    }\n}\n\n\n\nvec3 GetLight(vec3 p, vec3 viewDir, vec3 n, float dist, float id){\n\n    vec3 col = vec3(0.,0.,0.);\n    vec3 lightCol = vec3(1.5,1.5,1.2) * 4.;\n    float spec = 0.;\n    float refl = 0.;\n    \n    GetMats(id, col, spec, refl);\n    \n    \n\tvec3 lightPos = vec3(0,4,6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)) * 3.;\n    \n    vec3 l = normalize(lightPos-p);\n    float ldist = length(lightPos-p) * 0.25;\n    float atten = 1./(ldist*ldist) * 1.;\n    \n    //NdotL\n    float dif = max(dot(n, l), 0.0);\n    \n    float fresnel = 1.-(dot(normalize(-viewDir), n));\n    //fresnel *= fresnel;\n    \n    vec3 reflectionVec = reflect(viewDir, n);\n    vec3 cube = texture(iChannel0, reflectionVec, 4.).rgb * refl * fresnel;\n    cube *= smoothstep(15.,10., dist);\n    \n    //Cast shadows\n    float d = RayMarch(p + n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .05;\n    \n    \n    dif *= atten;\n    \n    //Specular\n    spec = pow(clamp(dot(reflect(l,n), viewDir),0.,1.), 16.)*spec;\n          \n    //Ambient\n    vec3 ambCol = vec3(0.38,0.45,0.6);\n\n    \n    //Final surface\n    vec3 surf = col*(dif+cube)*lightCol + spec*dif ;\n    //if(length(p) < 100.) surf += ambCol*0.3;\n    \n    //surf += reflCol*refl;\n    \n    return surf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    float camRot = ((iMouse.x/iResolution.x))*3.1415*2.;\n    float camZ = (iMouse.y/iResolution.y)*5.;\n    \n    vec3 ro = vec3(0,2.,6.);\n    ro.z += camZ;\n    ro += vec3(sin(camRot),0., cos(camRot)) * 6.;\n    \n    \n    vec3 lookat = vec3(0.,1.,6.);    \n    vec3 forward = normalize(lookat-ro);\n    vec3 right = cross(forward, vec3(0.,-1.,0.));\n    vec3 up = cross(forward,right);\n    \n    float zoom = 0.5;\n    \n    vec3 rd = normalize(forward * zoom + uv.x * right + uv.y * up);\n    \n    vec2 DistId = RayMarch(ro, rd);\n    vec3 p = ro + rd * DistId.x;\n    \n    vec3 n = GetNormal(p);\n    vec3 dif = GetLight(p, rd, n, DistId.x, DistId.y);\n    \n\tcol = vec3(dif);\n    \n    //fog\n    vec3 fogCol = vec3(0.5,0.4,0.7);\n    float fog = pow(clamp(DistId.x/40. - .1,0.,0.2),2.)*1.;\n    col.rgb = mix(col.rgb, fogCol, fog);\n    \n    col.rgb  = pow(col.rgb, vec3(1./2.2));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}