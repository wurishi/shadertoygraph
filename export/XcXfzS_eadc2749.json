{"ver":"0.1","info":{"id":"XcXfzS","date":"1723903871","viewed":35,"name":"hyperbolic sphere","username":"romeosoft","description":"This shader creates a visually captivating hyperbolic sphere effect on the screen. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolicsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis shader creates a visually captivating hyperbolic sphere effect on the screen. \nBy combining hyperbolic geometry with time-varying color patterns, \nthe shader produces dynamic visual output that simulates the appearance of a hyperbolic space. \nThe shader normalizes pixel coordinates, calculates distances using the hyperbolic sine function (sinh), \nand employs trigonometric functions to generate vibrant colors based on the fragment's position relative to the hyperbolic sphere. \nAdditionally, it uses a smooth visibility function to enhance the spherical effect, making the visualization more engaging and aesthetically pleasing. \nThis implementation showcases the power of shader programming in creating complex and visually appealing graphics using mathematical principles.\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Convert to range (-1, 1)\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n\n    // Parameters for the hyperbolic sphere\n    float time = iTime * 0.5;\n    float radius = 100.0; // Radius of the hyperbolic sphere\n\n    // Calculate the hyperbolic distance\n    float d = length(uv) * 5.5;\n\n    // Use sinh to create hyperbolic space effect\n    float hyperbolicDist = sinh(d) - radius; // Adjust the distance with sinh\n    \n    float theta = atan(uv.y, uv.x);\n    \n    vec3 col = vec3(0.5) + 0.5 * vec3(\n    sin(hyperbolicDist * 0.5 + time) * sin(sin(theta*2.0) * d),\n    cos(hyperbolicDist * 0.5 + time) * cos(cos(theta*4.0) * d),\n    sin(hyperbolicDist * 0.5 + time) * sin(cos(theta*8.0) * d));\n\n    // Determine the visibility based on the distance to create a spherical effect\n    float visibility = smoothstep(-0.1, 0.1, -hyperbolicDist);\n\n    // Output to screen\n    fragColor = vec4(col * visibility, 1.0);\n}","name":"Image","description":"","type":"image"}]}