{"ver":"0.1","info":{"id":"X3BGD1","date":"1708404911","viewed":266,"name":"Pulsating Flesh","username":"Toasty1007","description":" Cool but gross looking scene using a simple FBM function with basic lighting techniques applied. Made in collaboration with @DominicKarma.","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["flesh","pulsation","writhing"],"hasliked":0,"parentid":"X3SGD1","parentname":"Writhe"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Specific FBM function taken from https://twitter.com/TheMirzaBeig/status/1644437603263868933\n\n// Modify variables that affect how the scene looks.\n#define ITERATIONS 28.\n#define FREQUENCY_MULTIPLIER 1.18\n#define DIFFUSE_STRENGTH 20.\n#define SPECULAR_SHININESS 50.\n#define DIFFUSE_FRESNEL_BIAS 1.\n#define SPECULAR_FRESNEL_BIAS 4.\n#define FLUID_STRENGTH 0.5\n#define ROTATION 5.\n#define LURCHINIESS 1.5\n#define SPEED 2.\n\n// Modify lighting colors.\n#define AMBIENT_COLOR vec3(1., 0.05, 0.2) * 0.02\n#define DIFFUSE_COLOR vec3(1., 0.0, 0.2)\n#define DIFFUSE_HIGHLIGHT_COLOR vec3(1., 0.35, 0.2) * 1.\n#define SPECULAR_COLOR vec3(1., 0.8, 0.8) * 0.4\n#define FRESNEL_COLOR vec3(1., 0.05, 0.2)\n\n// Toggle texture/lighting features.\n#define USE_FLUID true\n#define USE_DIFFUSE true\n#define USE_DIFFUSE_HIGHLIGHTS true\n#define USE_SPECULAR_HIGHLIGHTS true\n#define USE_FRESNEL true\n#define USE_AMBIENT true\n\nmat2 RM2D(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat aperiodicSin(float x)\n{\n    float eOver2 = 1.3591409;\n    float pi = 3.141592;\n    return sin(eOver2 * x + 1.04) * sin(pi * x);\n}\n\n// Creates freaky shapes.\nfloat FBM(vec2 uv)\n{\n    vec2 n, q, u = vec2(uv-.5);\n    float centeredDot = dot(u,u);\n    float frequency = 15. - (0.5 - centeredDot) * 8.0;\n    float result = 0.;\n    mat2 matrix = RM2D(ROTATION);\n\n    for (float i = 0.; i < ITERATIONS; i++)\n    {\n        u = matrix * u;\n        n = matrix * n;\n        q = u * frequency + iTime * SPEED + aperiodicSin(iTime * LURCHINIESS -centeredDot * 1.2) * 0.4 * LURCHINIESS + i + n;\n        result += dot(cos(q) / frequency, vec2(2., 2.));\n        n -= sin(q);\n        frequency *= FREQUENCY_MULTIPLIER;\n    }\n    return result;\n}\n\nfloat CalculateDiffuseLight(vec3 normal, vec3 lightDirection)\n{\n    float maxBrightness = 0.3;\n    return pow(max(dot(normal, lightDirection), 0.0), DIFFUSE_STRENGTH) * maxBrightness;\n}\n\nfloat CalculateSpecularLight(vec3 normal, vec3 lightDirection, vec3 currentPosition)\n{\n    vec3 lightSource = vec3(0.9, 0.1, 1.0);\n    vec3 reflectedDirection = reflect(-lightDirection, normal);  \n\tvec3 viewDirection = normalize(lightSource - currentPosition);\n    return pow(max(dot(viewDirection, reflectedDirection), 0.0), SPECULAR_SHININESS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the UVs of the fragment, correcting the aspect ratio in the process.\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.xx + 0.5;\n    uv = (uv - 0.5) * 2.2 * 0.5 + 0.5;\n    \n    // Modify the UVs based on the mouse position.\n    vec2 mouseMovement = (iMouse.xy / iResolution.xy - 0.5);\n    uv += mouseMovement * clamp(0.2 / length(mouseMovement) + 0.2, 0., 1.);\n\n    // Calculate the base noise value from the FBM. This may initially be outside of the traditional 0-1 range of values.\n    float noise = FBM(uv);\n    float originalNoise = noise;\n    \n    // Clamp the noise to a 0-1 range.\n    noise = clamp(noise, 0.0, 1.0);\n    // Store the current position UVs as a vector3 instead of a vector2.\n    vec3 currentPosition = vec3(uv, 1.);\n    \n    // Calculate the base light values for diffuse lighting.\n    vec3 lightSource = vec3(0.76, 0.7, 0.);\n    vec3 lightDirection = normalize(currentPosition - lightSource);\n    \n    // Calculate fluid noise values that give texture to the dark parts of the texture.\n    if (USE_FLUID)\n    {\n        float fluidViscosity = 681.72;\n        float fluidNoiseAngle = originalNoise * 13.05 + iTime * 0.78;\n        vec2 fluidOffset = vec2(cos(fluidNoiseAngle) + originalNoise * 14.0, sin(fluidNoiseAngle) + iTime * 5.5) / fluidViscosity;\n        float fluidNoise = pow(texture(iChannel0, uv * 0.12 + fluidOffset).x, 5.5 * FLUID_STRENGTH) * 0.27;\n        noise += fluidNoise * smoothstep(0.4, 0.0, noise);\n    }\n    \n    // Calculate the normal of the current pixel based on the derivatives of the noise with respect to both spatial axes.\n    vec3 normal = normalize(vec3(dFdx(noise), dFdy(noise), clamp(originalNoise * 0.01, 0., 1.)));\n\n    // Calculate brightness, using both specular and diffuse lighting models.\n    float brightness = CalculateDiffuseLight(normal, lightDirection);// + CalculateSpecularLight(normal, lightDirection, currentPosition);\n    \n    // Schlick Fresnel\n    lightSource = vec3(0.9, 0.1, 1.0);\n    vec3 viewDirection = normalize(lightSource - currentPosition);\n    vec3 fresnelNormal = normal;\n\tfresnelNormal.xz *= 1.;\n\tfresnelNormal = normalize(fresnelNormal);\n\tfloat base = 1. - dot(viewDirection, fresnelNormal);\n\tfloat exponential = pow(base, 0.2);\n\tfloat R = exponential + DIFFUSE_FRESNEL_BIAS * (1. - exponential);\n\tR *= 0.05;\n\tvec3 fresnel = FRESNEL_COLOR * clamp(R, 0.04, 1.);\n    \n    // More fresnel but for the specular highlights.\n    base = 1. - clamp(dot(viewDirection, reflect(-lightDirection, normal)), 0., 1.);\n\texponential = pow(base, 0.2);\n\tR = exponential + SPECULAR_FRESNEL_BIAS * (1.0 - exponential);\n            \n    // Combine the brightness and noise values into a single coherent color.\n    if (USE_DIFFUSE)\n        noise += brightness;\n    \n    // Add them all to the final color.\n    fragColor = vec4(noise * DIFFUSE_COLOR.r, DIFFUSE_COLOR.g, noise * DIFFUSE_COLOR.b, 1.0);\n    if (USE_DIFFUSE_HIGHLIGHTS)\n        fragColor += vec4(DIFFUSE_HIGHLIGHT_COLOR * brightness, 0.0);\n    if (USE_SPECULAR_HIGHLIGHTS)\n        fragColor += vec4(SPECULAR_COLOR * CalculateSpecularLight(normal, lightDirection, currentPosition), 1.) * R;\n    if (USE_FRESNEL)\n        fragColor += vec4(fresnel, 1.);\n    if (USE_AMBIENT)\n        fragColor += vec4(AMBIENT_COLOR, 1.);\n}","name":"Image","description":"","type":"image"}]}