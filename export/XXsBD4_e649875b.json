{"ver":"0.1","info":{"id":"XXsBD4","date":"1728403034","viewed":93,"name":"repulsive distribution 2d","username":"elenzil","description":"2D electrostatic-style distribution of points on an SDF.\nDoesn't handle local minima.\nMouse click = no inertia.\nFrom discussion in OneShade's [url=https://www.shadertoy.com/view/sssfWM]Repelling Points on Sphere[/url]","likes":16,"published":3,"flags":32,"usePreview":0,"tags":["distribution","repulsion","charge"],"hasliked":0,"parentid":"43lBW8","parentname":"draft - repulsive distribution"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"      float gT;         // set in main\n      float gLineWidth; // set in main\n      float gAAEps;     // set in main\n      \nconst vec4  kPartFill1 = vec4(0  , 0  , 0, 0.8);\nconst vec4  kPartFill2 = vec4(0.7, 0.2, 0, 0.8);\nconst vec4  kPartStrk  = vec4(1  , 1  , 1, 1.0);\nconst float kPartRad   = 0.05;\n\nvec3 gDebugRGB = vec3(0);\n\nvoid draw(inout vec3 rgb, in float d, in vec4 fill, in vec4 stroke, in float sw) {\n\n    float f = smoothstep(gAAEps, -gAAEps,     d - sw);\n    float s = smoothstep(gAAEps, -gAAEps, abs(d) - sw);\n    \n    rgb = mix(rgb, fill.rgb  , f * fill.w);\n    rgb = mix(rgb, stroke.rgb, s * stroke.w);\n}\n      \nvoid drawPart(inout vec3 rgb, in vec2 p, in Part part, in uint ndx) {\n    float d = length(p - part.pos) - kPartRad;\n    vec4 fill = (iMouse.z > 0.0 ? kPartFill1 : kPartFill2);\n    draw(rgb, d, fill, kPartStrk, gLineWidth);\n}\n\nvoid drawParts(inout vec3 rgb, in vec2 p) {\n    for (uint n = 0u; n < uint(kPointCount); ++n) {\n        vec4 tex = texelFetch(iChannel0, ivec2(n, 0), 0);\n        Part part;\n        part.pos = tex.xy;\n        part.vel = tex.zw;\n        drawPart(rgb, p, part, n);\n    }\n}\n\n// Based on IQ's colorings:\n// https://www.shadertoy.com/view/4cG3R1\nvec3 col(float d) {\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    col = mix( col, vec3(0.3), 0.7);\n    return col;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime;\n    gLineWidth = 2.0/RES.y;\n    gAAEps     = 3.0/RES.y;\n    vec2 p     = VIEWFROMSCREEN     (XY );\n    vec2 M     = mouse(iMouse.xy, RES, iTime);\n    vec2 m     = VIEWFROMSCREEN     (M);\n    \n    float ds = sdScene(p, m, iTime);\n\n    vec3 rgb = col(ds);\n    \n    draw(\n        rgb,\n        sdMouse(p, m, iTime),\n        vec4(vec3(0.35), 0.4),\n        vec4(vec3(0.45), 1.0),\n        gLineWidth\n    );\n        \n    draw(rgb,\n         ds,\n        vec4(vec3(0.2 ), 0.7),\n        vec4(vec3(0.9 ), 1.0),\n        gLineWidth * 4.0\n    );\n    \n    drawParts(rgb, p);\n    \n    RGBA.rgb  = rgb;\n    RGBA.rgb += gDebugRGB;\n    \n    // housekeeping\n    RGBA.rgb *= 1.0 - pow(LENGTHSQR(XY/RES - 0.5) * 1.5, 3.0);\n    RGBA.a    = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst int   kPointCount = 20;\nconst float kGain       = 0.7;\nconst float kDamping    = 0.1;\nconst float kSpeedMax   = 1e1;\nconst float kZoom       = 0.8;\n\n\n//----------------------------------------------\n\nstruct Part {\n    vec2 pos;\n    vec2 vel;\n};\n\n\n\nconst vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / kZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \n#define LENGTHSQR(a) ( dot((a), (a)) )\n\n\n\n\n\n//--------------------------------------------------------------\n// Hash functions\n// From https://www.jcgt.org/published/0009/03/02/\n// xxhash (https://github.com/Cyan4973/xxHash)\n//   From https://www.shadertoy.com/view/Xt3cDn\nuint xxhash32(uint p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p + PRIME32_5;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\n// From https://www.jcgt.org/published/0009/03/02/\n// xxhash (https://github.com/Cyan4973/xxHash)\n//   From https://www.shadertoy.com/view/Xt3cDn\nuint xxhash32(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\n//--------------------------------------------------------------\n// Utilities\n\n// Convert a uint to a float in [0, 1].\n// Loses information.\nfloat U2F(uint a) {\n    return float(a) / float(0xffffffffu);\n}\n\nfloat xxhash32f(uint p) {\n    return U2F(xxhash32(p));\n}\n\n//--------------------------------------------------------------\n\nmat2 rot2(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n\n//--------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n// https://iquilezles.org/articles/distfunctions3d\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n// convert native iMouse to a mouse with presets for the bottom-left.\nvec2 mouse(in vec2 m, in vec2 res, in float t) {\n\n    vec2 mp = res - m;\n\n    if (min(dot(mp, mp), dot(m, m)) < 50.0 * 50.0) {\n        return vec2((cos(t * 1.00) * 0.4 + 0.5) * res.x,\n                    (sin(t * 1.12) * 0.4 + 0.5) * res.y);\n    }\n    else {\n        return m;\n    }\n}\n\n// the portion of the scene controlled by the mouse.\n// this is subtracted from the rest of the scene SDF.\nfloat sdMouse(in vec2 p, in vec2 m, in float t) {\n    float d = 1e9;\n    \n    vec2 q = p - m;\n    q *= rot2(t);\n    \n    d = sdBox(q, vec2(0.5 - 0.1)) - 0.1;\n    // d = max(d, -(length(q) - 0.4));\n\n    #if 0\n    // a smaller box counter-rotating\n    q = p - -m;\n    q *= rot2(-t);\n    d = min(d, sdBox(q, vec2(0.3)));\n    #endif\n    \n    return d;\n}\n\nfloat sdScene(in vec2 p, in vec2 m, in float t) {\n    float d = 1e9;\n    \n    d = min(d, sdTorus(vec3(p.x, 0.0, p.y), vec2(0.8, 0.2)));\n    d = max(d, -sdMouse(p, m, t));\n    \n    return d;\n}\n\nvec2 gradScene(in vec2 p, in vec2 m, in float t, out float d) {\n    const float eps = 0.001;\n    vec2 g;\n    \n    g.x = sdScene(p + v01.yx * eps, m, t) - sdScene(p - v01.yx * eps, m, t);\n    g.y = sdScene(p + v01.xy * eps, m, t) - sdScene(p - v01.xy * eps, m, t);\n    d   = sdScene(p, m, t);\n    g = d * normalize(g);\n    return g;\n}\n\n// Follow the gradient.\n// This ends up getting stuck in local minima.\nvoid constrain(inout vec2 p, in vec2 m, in float t) {\n    for (uint n = 0u; n < 20u; ++n) {\n        float d;\n        p -= gradScene(p, m, t, d);\n        if (d < 0.001) {\n            break;\n        }\n    }\n}\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    if (IJ.x >= kPointCount || IJ.y > 0) {\n        discard;\n    }\n    \n    vec2 M     = mouse(iMouse.xy, RES, iTime);\n    vec2 m     = VIEWFROMSCREEN     (M);\n\n    \n    Part part;\n    \n    if (iFrame <= 5) {\n        int t = int(iTime * 10000.0);\n        part.pos = vec2(\n            xxhash32f(uint(IJ.x + 123 + t)),\n            xxhash32f(uint(IJ.x - 123 + t))\n        );\n        part.pos = part.pos * 2.0 - 1.0;\n        constrain(part.pos, m, iTime);\n        part.vel = vec2(0.0);\n    }\n    else {\n        vec4 tex = texelFetch(iChannel0, IJ, 0);\n        part.pos = tex.xy;\n        part.vel = tex.zw;\n    }\n    \n    // update velocity\n    vec2 vs = vec2(0);\n    for (int n = 0; n < kPointCount; ++n) {\n        if (n == IJ.x) {\n            continue;\n        }\n        vec2 otherPos = texelFetch(iChannel0, ivec2(n, 0), 0).xy;\n        vec2 v = otherPos - part.pos;\n        vec2 vn = normalize(v);\n        float rr = dot(v, v);\n        vs -= vn / rr;\n    }\n    \n    // todo: account for iTimeDelta in damping.\n    vs /= float(kPointCount - 1);\n    part.vel = part.vel * (1.0 - kDamping);\n    if (iMouse.z > 0.0) {\n        part.vel *= 0.0;\n    }\n    part.vel += vs * kGain;\n    \n    float speed = length(part.vel);\n    part.vel = part.vel * min(kSpeedMax, speed) / speed;\n        \n    \n    part.pos += part.vel * iTimeDelta;\n    \n    constrain(part.pos, m, iTime);\n\n    RGBA = vec4(part.pos, part.vel);\n}","name":"Buffer A","description":"","type":"buffer"}]}