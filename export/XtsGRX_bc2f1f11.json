{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// --- thanks to iq for all the ray-marching sdf info and awesomeness\n\nvec3 op_u(vec3 d1, vec3 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvoid sphere_fold(inout vec3 p, inout float dr, float m_rad_sq, float f_rad_sq, float m_rad_sq_inv)\n{\n    float r_sq = dot(p, p);\n    if (r_sq < m_rad_sq)\n    {\n        float t = f_rad_sq * m_rad_sq_inv;\n        p *= t;\n        dr *= t;\n    }\n    else if (r_sq < f_rad_sq)\n    {\n        float t = f_rad_sq / r_sq;\n        p *= t;\n        dr *= t;\n    }\n}\n\nvoid box_fold(inout vec3 p, float fold_limit)\n{\n    p = clamp(p, -fold_limit, fold_limit) * 2.0 - p;\n}\n\n// estimators return (dist, mat_id, custom_value)\n\nvec3 estimator_mandelbox(vec3 p, float scale, float m_rad_sq, float f_rad_sq, float fold_limit, float mat_id)\n{\n    vec3 off = p;\n    float dr = 1.0;\n    float dist = 1e20;\n    float mrs_inv = 1.0 / m_rad_sq;\n    for (int i = 0; i < 10; ++i)\n    {\n        box_fold(p, fold_limit);\n        sphere_fold(p, dr, m_rad_sq, f_rad_sq, mrs_inv);\n\n        p = scale * p + off;\n        dr = dr * abs(scale) + 1.0;\n        vec3 ot = p - vec3(0.5);\n        dist = min(dist, dot(ot, ot));\n    }\n    return vec3(length(p) / abs(dr), mat_id, sqrt(dist));\n}\n\nvec3 mod_pos(vec3 p, float a, float b)\n{\n    p.zx = mod(p.zx, a) - b;  \n    return p;\n}\n\nvec3 estimate(vec3 p)\n{\n    vec3 p_mb = mod_pos(p, 4.4, 2.2);\n   \tvec3 res_mb = estimator_mandelbox(p_mb, -2.5, 0.1, 2.5, 1.0, 0.2);\n    // second\n    vec3 p_pl = p;\n    p_pl.y += 4.0;\n    p_pl = mod_pos(p_pl, 2.0, 1.0);\n    vec3 res_pl = estimator_mandelbox(p_pl, -1.5, 0.3, 2.9, 1.0, 0.1);\n\n    return op_u(res_mb, res_pl);\n\n}\n\nvec4 ray_march(vec3 origin, vec3 direction)\n{\n    float total_distance = 0.0;\n    int steps_total = 0;\n    float orbit_trap;\n    float material = -1.0;\n    float dist;\n    for (int steps = 0; steps < 100; ++steps)\n    {\n        vec3 point = origin + total_distance * direction;\n        vec3 res = estimate(point);\n        dist = res.x;\n        \n        if (dist < 0.003)\n            break;\n        \n        total_distance += dist;\n        steps_total++;\n        \n        orbit_trap = res.z;\n        material = res.y;\n    }\n    float ao = float(steps_total) / 200.0;\n    return vec4(total_distance, material, ao, orbit_trap);\n}\n\nvec3 compute_normal(vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 pos00 = (pos + eps.xyy);\n    vec3 pos01 = (pos - eps.xyy);\n    vec3 pos10 = (pos + eps.yxy);\n    vec3 pos11 = (pos - eps.yxy);\n    vec3 pos20 = (pos + eps.yyx);\n    vec3 pos21 = (pos - eps.yyx);\n\tvec3 normal = vec3(estimate(pos00).x - estimate(pos01).x, \n                       estimate(pos10).x - estimate(pos11).x, \n                       estimate(pos20).x - estimate(pos21).x);\n\treturn normalize(normal);\n}\n\nvec3 render(vec3 origin, vec3 direction, vec2 uv)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec4 res = ray_march(origin, direction);\n    \n    vec3 light_dir = normalize(vec3(-0.6, -0.7, 0.5));\n    float lg = length(uv - vec2(0.0));\n    vec3 bg = exp(-vec3(5.0 - lg * 0.8, lg, lg * 0.5) * 2.0);\n    color = bg;\n    \n    if (res.y > 0.0)\n    {\n        vec3 new_pos = origin + res.x * direction;\n        float ao = 1.0 - res.z;   \n        if (res.y == 0.2)\n        {  \n            vec3 normal = compute_normal(new_pos);\n            \n            vec3 h = normalize(light_dir - direction);\n            float noh = clamp(dot(normal, h), 0.0, 1.0); \n            float voh = clamp(dot(-direction, h), 0.0, 1.0);\n            float nol = clamp(dot(normal, light_dir), 0.0, 1.0);\n            float nol_i = clamp(dot(normal, normalize(light_dir * vec3(-1.0, 0.0, -1.0))), 0.0, 1.0);\n\n            float roughness = 0.54;\n            float alphaSq = roughness * roughness * roughness * roughness;\n            float denom = noh * noh * (alphaSq - 1.0) + 1.0;\n            float D = alphaSq / (3.1416 * denom * denom);\n\n            vec3 f0 = vec3(0.664, 0.824, 0.850);\n            vec3 F = f0 + (1.0 - f0) * exp2((-5.55473 * voh - 6.98316) * voh);  \n\n            vec3 spec = D * F;\n            \n            vec3 diff = nol * vec3(0.01, 0.49, 0.70) *  pow(vec3(ao), vec3(1.5, 1.2, 1.0));\n            diff *= spec;\n            diff += nol_i * vec3(0.41, 0.12, 0.16);\n            diff *= vec3(cos(res.w * 0.71) * 0.5 + 0.5, sin(res.w * 0.01) * 0.01 + 0.5, 0.54);\n            color = diff * ao;\n        }\n        else\n        {\n            vec3 diff = vec3(cos(res.w * 0.71) * 0.7 + 0.3, sin(res.w * 0.11) * 0.5 + 0.5, 0.54);\n            color = diff * ao * ao * ao * vec3(1.64, 1.27, 0.99) * pow(vec3(ao),vec3(1.0, 1.2, 1.5));\n        }\n        \n        float fog_factor = 0.1;\n        float fog = 1.0 - exp(-res.x * fog_factor);\n        color = mix(color, bg, fog);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offsets[5];\n    offsets[0] = vec2(0.0, 0.0);\n    offsets[1] = vec2(0.25, 0.0);\n    offsets[2] = vec2(-0.25, -0.0);\n    offsets[3] = vec2(0.0, 0.25);\n    offsets[4] = vec2(0.0, -0.25);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    vec3 cam_pos = vec3(0.0  , sin(0.1  + 2.0 * mo.y), -iTime);\n    vec3 cam_up = normalize(vec3(0.0, 0.8, 0.2));\n    vec3 cam_right = vec3(1.0, 0.0, 0.0);\n    vec3 cam_forward = normalize(cross(cam_up, cam_right));\n    float focal_length = 2.77;\n    vec3 color = vec3(0.0);\n    \n    const int numSamples = 1;\n    for (int i = 0; i < numSamples; ++i)\n    {\n        vec2 coords_ss = (fragCoord.xy + offsets[i]) / iResolution.xy;\n    \tvec2 coords_cs = 2.0 * coords_ss - 1.0;\n   \t \tcoords_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 ray_d = normalize(cam_forward * focal_length + cam_right * coords_cs.x + cam_up * coords_cs.y);\n    \tvec3 ray_o = cam_pos;\n    \n        color += render(ray_o, ray_d, coords_cs);\n    }\n    \n    color /= float(numSamples);\n\tcolor = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XtsGRX","date":"1423839200","viewed":642,"name":"machine city","username":"raziel","description":"Messing around with mandelbox fractals.  Thanks to iq for all the sdf resources. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","ray","marching","mandelbox","ggx"],"hasliked":0,"parentid":"","parentname":""}}