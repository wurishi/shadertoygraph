{"ver":"0.1","info":{"id":"wlcXRH","date":"1666357648","viewed":224,"name":"sdf test (-_-;)","username":"gaz","description":"Shader for practice that I wrote before.\n","likes":23,"published":1,"flags":0,"usePreview":1,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO min(iFrame, 0)\n#define PI acos(-1.0)\n#define TAU PI*2.0\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nbool BBSW=true;\n#define BB(bb,off,e)if (BBSW&&any(greaterThan(abs(p), bb)))\\\n\treturn length(max(abs(p-off)-bb,0.0))+float[](0.2,0.0005)[e];\n    \n\nvec3 rot3d(vec3 p,vec3 a,float t)\n{\n    vec3 v = cross(a,p);\n    return cross(v, a)*cos(t)+v*sin(t)+a*dot(p, a);   \n}\n\nvec3 pointAt(vec3 p, vec3 d, vec3 up)\n{\n    vec3 u = normalize(cross(d,up));\n    return p*mat3(u,cross(u,d),d);\n}\n\nmat3 pointAtM(vec3 d, vec3 up)\n{\n    vec3 u = normalize(cross(d,up));\n    return mat3(u,cross(u,d),d);\n}\n\nmat3 pointAtZ(vec3 d, float a)\n{\n    vec3 up=vec3(sin(a),cos(a),0);\n    vec3 side = normalize(cross(d,up));\n    return mat3(side,cross(side,d),d);\n}\n\nmat3 pointAtY(vec3 d, float a)\n{\n    vec3 up=vec3(sin(a),0,cos(a));\n    vec3 side = normalize(cross(d,up));\n    return mat3(side,d,cross(side,d));\n}\n\nmat3 pointAtX(vec3 d, float a)\n{\n    vec3 up=vec3(0,cos(a),sin(a));\n    vec3 side = normalize(cross(d,up));\n    return mat3(d,cross(side,d),side);\n}\n\n\n\n//https://www.shadertoy.com/view/4dtXRn\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\n\n// https://www.shadertoy.com/view/ltf3W2\nfloat SAbs(float x, float k)\n{\n    return sqrt(x * x + k);\n}\n\nfloat SRamp1(float x, float k)\n{\n    return 0.5 * (x - SAbs(x, k));\n}\n\nfloat SMin1(float a, float b, float k)\n{\n    return a + SRamp1(b - a, k);\n}\n\n#define sabs(a) SAbs(a,0.005)\n#define smin(a,b) SMin1(a,b,0.003)\n\nvec2 pFold(vec2 p,float n)\n{\n    float h=floor(log2(n));\n    float a =TAU*exp2(h)/n;\n    for(int i=0;i<int(h)+2;i++)\n    {\n        vec2 v = vec2(-cos(a),sin(a));  \n        p-=2.0*smin(0.0,dot(p,v))*v;\n        a*=0.5;\n    }\n    return p;\n}\n\nvec2 pMod(vec2 p, float r)\n{\n    float a = mod(atan(p.y, p.x), TAU / r) - 0.5 * TAU / r;\n    return length(p) * vec2(sin(a), cos(a));\n}\n\n\nfloat lengthN(in vec2 p, in float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat roundBox(vec3 p, vec3 size, float r){\n   return length(p-clamp(p,-size,size))-r;\n}\n\n\n\n\nfloat deGround(in vec3 p)\n{\n    return p.y;\n}\n\n\n//Springs of Arbitrary Profile \n// https://www.shadertoy.com/view/ttB3DV\n\n//// SPRING DISTANCE FUNCTION ////\nvec3 closestPointOnCylinder(vec3 p, vec2 dim) {\n    return vec3(normalize(p.xy)*dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));\n}\n\nfloat spring(vec3 p) {\n    float radius = 0.5;\n    float height = 5.0 + sin(iTime);\n    float coils = 10.0/(height/3.141);\n\n    vec3 pc = closestPointOnCylinder(p, vec2(radius, height));\n\n    float distToCyl = distance(p, pc);\n\tfloat distToCoil = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    \n    vec2 springCoords = vec2(distToCyl, distToCoil);\n    \n    //the multiplication factor is here to reduce the chance of the ray jumping through the back spring\n    return (length(springCoords)-.1);// * ( max(radius/2.0-abs(length(p.xy)-radius), 0.0)*0.3 + 0.7);\n}\n\n\n// https://www.shadertoy.com/view/3lSXDG\n// https://www.shadertoy.com/view/lssBDM\nvec2 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0)\n    { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec2(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*sqrt(3.0);//1.732050808;\n    return vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\nvec3 opBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{   \n    b = mix(b + vec2(1e-4), b, abs(sign(b * 2.0 - a - c)));\n    vec2 A = b - a, B = a - b * 2.0 + c, C = A * 2.0, D = a - p;\n    vec3 k = vec3(3.*dot(A,B),2.*dot(A,A)+dot(D,B),dot(D,A)) / dot(B,B);      \n    vec2 to = solveCubic(k.x, k.y, k.z);\n    vec2 t = clamp(to, 0.0, 1.0);\n    vec2 dp1 = D + (C + B*t.x)*t.x;\n    vec2 dp2 = D + (C + B*t.y)*t.y;\n    float d1 = dot(dp1, dp1);\n    float d2 = dot(dp2, dp2);\n    vec3 h = (d1 < d2) ? vec3(d1, t.x, to.x) : vec3(d2, t.y, to.y);\n    vec2 g = normalize(2.*B*h.y + C);\n    p -= mix(mix(a, b, h.y), mix(b, c, h.y), h.y);\n    float y = g.x*p.y-g.y*p.x;\n    float x = sqrt(abs(h.x-y*y))*sign(h.y-0.5);\n    return vec3(x,y,h.z);\n}\n\nvec4 opBezier(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n\tvec3 w = normalize(cross(a-b, b-c));\n\tvec3 v = normalize(cross(w, a-b));\n\tvec3 u = cross(w,v);\n    mat3 m = mat3(u,v,w);\n    a *= m, b *= m, c *= m, p *= m;\n    vec3 bz = opBezier(p.xy,a.xy,b.xy,c.xy);\n    return vec4(p.z,bz.yxz);\n}\n\nfloat co(vec3 p)\n{\n \tvec3 a=vec3(-2,0,0);\n    vec3 b=vec3(0,2.0+sin(iTime*1.5)*0.8,0);\n    vec3 c=vec3(2,1,sin(iTime*0.8)*2.0);\n\tvec4 bz=opBezier(p,a,b,c);\n    \n    bz.z-=clamp(bz.z,-0.5,2.);\n    return length(bz.xyz)-0.3;\n}\n\nfloat deTaper(vec3 p)\n{\n\t//p.xy*=rotate(iTime*0.5);\n    //p.yz*=rotate(iTime*0.3);\n    p = pointAt(p,vec3(0.577),vec3(0,1,0));\n    float t= clamp(p.y,-2.0,2.0)/2.0;\n    t=p.y;\n    p.y-=clamp(p.y,-2.0,2.0);\n    float s=t*t*0.5+0.3; \n    s=sin(t*10.+sin(t*5.))*0.05+.3;\n    return length(p)-s;\n    return length(p-clamp(p,vec3(-s,-0.5,-s),vec3(s,0.5,s)))-0.1;\n}\n\n// https://www.pouet.net/topic.php?which=7931&page=5\nvec2 opBend(vec2 p, float k, float g) \n{\n    float sgn = sign(k);\n\tfloat r = sgn/max(abs(k),1e-3);\n    k = abs(k);\n\tvec2 d = sgn*vec2(p.x, r-p.y);\n\tfloat a = -atan(d.x, d.y);\n    float b = clamp(a, -g*k, g*k) ;\n\tfloat s = b*r;\n\treturn mix(\n\t\tvec2(s, -sgn*(length(d)-abs(r))),\n\t\tvec2(s, r)-sgn*d*rot(b),\n\t\tabs(sign(a-b))\n\t);  \n}\n\nvec2 opBend(vec2 p, float k)\n{\n    float sgn = sign(k);\n    float r = 1.0/max(abs(k),1e-3);\n    vec2 d= vec2(p.x, r-p.y*sgn);\n    return vec2(atan(d.x,d.y)*r,sgn*(length(d)-r));\n}\n\n\nfloat deTarget(vec3 p)\n{\n    p.y -=2.5;\n    BB(vec3(3,3,1),vec3(0),0)\n    float de =1e9;\n    p.xy*=rot(iTime*1.5);\n    vec2 d2 = vec2(abs(length(p.xy)-1.5)-0.3, \n                   abs(p.z)-(0.25+smoothstep(1.6,1.7,length(p.xy))*0.05 ));\n    de = min(de, length(max(d2,0.0))-0.05);\n    d2 = vec2(abs(length(p.xy)-0.45)-0.15, abs(p.z)-(0.25));\n    de = min(de, length(max(d2,0.0))-0.05);\n    vec3 q = p;\n    q.xy = pMod(q.xy,5.0);\n    q.y -= 0.8;\n    de = min(de, roundBox(q,vec3(0.2,0.3,0.1),0.1));\n    q = p;\n    q.xy = pMod(q.xy,20.0);\n    q.y -= 2.;\n    \n    float h=0.2;\n\tfloat t=clamp((q.y+h)/(2.0*h),0.,1.);\n\tq.y-=clamp(q.y,-h,h);\n    \n    \n    \n    de = smin(de, roundBox(q,vec3(0.2-0.1*t,0.0,0.2-0.05*t),0.05));\n    return de;\n}\n\nfloat test(vec3 p)\n{\n            p.y -=2.5;\n\t//p.xy*=rotate(iTime*0.5);\n    //p.yz*=rotate(iTime*0.3);\n    \n    p.zy=opBend(p.zy, sin(iTime)*PI*0.1,1.5);\n    \n    BB(vec3(1,1,5.5),vec3(0),0)\n    \n    float radius = 0.5;\n    float height = 10.;//5.0 + sin(iTime);\n    float coils = 16.0/(height/3.141);\n\n    vec3 pc = closestPointOnCylinder(p, vec2(radius, height));\n\n    float distToCyl = distance(p, pc);\n\tfloat distToCoil = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    \n    vec2 springCoords = vec2(distToCyl, distToCoil);\n    return length(springCoords)-.1;\n    \n    \n    return spring(p.zyx);\n    //p.xy=opBend(p.xy, sin(iTime)*PI*0.5);\n\tp.x-=clamp(p.x,-3.0,2.5);\n    return (length(p)-0.3)*0.8;    \n\n\n}\n\nfloat dePolygon(vec2 p,float n) \n{\n  float s = TAU/n;\n  float a = round(atan(p.x,p.y)/s)*s;\n  return dot(p,vec2(sin(a),cos(a)));\n}\n\nfloat deBolt(vec3 p)\n{\n    BB(vec3(2,2,4),vec3(0,0,2),0)\n    //length(max(vec2(d2,abs(p.z)-t),0.0))-r;\n    float d2=dot(pFold(p.xy,6.),vec2(0,1))-1.5;\n    float de= length(max(vec2(d2,abs(p.z)-0.5),0.0))-0.1;\n    \n    de=min(de,length(max(vec2(length(p.xy)-0.7,abs(p.z-clamp(p.z,0.0,3.2))),0.0))-0.1);\n    \n    float radius = 0.7;\n    float height = 4.5;\n    float coils = 16.0;//18.0/(height/3.141);\n    \n    //vec3(normalize(p.xy)*dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));\n\tvec3 pc=vec3(normalize(p.xy)*radius, clamp(p.z, 0.0, 3.0));\n    \n    //vec3 pc = closestPointOnCylinder(p, vec2(radius, height));\n\n    float distToCyl = distance(p, pc);\n\tfloat distToCoil = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    \n    vec2 springCoords = vec2(distToCyl, distToCoil);\n    \n    //the multiplication factor is here to reduce the chance of the ray jumping through the back spring\n    de= min(de,dot(abs(springCoords),vec2(0.7071))-.2);// \n    \n    return de;\n   \n}\n\nfloat deNut(vec3 p)\n{\n    //length(max(vec2(d2,abs(p.z)-t),0.0))-r;\n    float d2=dot(pFold(p.xy,6.),vec2(0,1))-1.5;\n    float de= length(max(vec2(d2,abs(p.z)-0.5),0.0))-0.1;\n    \n    de=smax(de,-(length(max(vec2(length(p.xy)-0.7,abs(p.z-clamp(p.z,-3.0,3.2))),0.0))-0.1),8.0);\n    \n    float radius = 0.7;\n    float height = 4.5;\n    float coils = 16.0;//18.0/(height/3.141);\n    \n    //vec3(normalize(p.xy)*dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));\n\tvec3 pc=vec3(normalize(p.xy)*radius, clamp(p.z, -1.0, 1.0));\n    \n    //vec3 pc = closestPointOnCylinder(p, vec2(radius, height));\n\n    float distToCyl = distance(p, pc);\n\tfloat distToCoil = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    \n    vec2 springCoords = vec2(distToCyl, distToCoil);\n    \n    //the multiplication factor is here to reduce the chance of the ray jumping through the back spring\n    de= max(de,-(dot(abs(springCoords),vec2(0.7071))-.2));// \n    \n    return de;\n   \n}\n\nfloat deRing(vec3 p)\n{\n    p.x-=clamp(p.x,-1.0,1.0);\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\n}\n\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\nfloat deChain(vec3 p)\n{\n    p=pointAt(p.xzy,normalize(vec3(1)),vec3(0,1,0));\n    p.xy+=3.0;\n    float de = 1e9;\n    vec3 q;\n    q=p;\n    q.x=opRepLim(q.x,6.0,8.0);\n    de=min(de, deRing(q));\n    q=p;\n    q.x-=3.0;\n    q.x=opRepLim(q.x,6.0,8.0);\n    de=min(de, deRing(q.xzy));\n    return de;\n}\n\n\nfloat map2(in vec3 p)\n{\n    float de=1e9;\n    de= min(deNut(p-vec3(1.5,3,1)),deBolt(p-vec3(-1.5,2,-1)));\n    de = min(de, deTarget(p-vec3(5,0,0)));    \n    de = min(de,deGround(p));\n    de = min(de,spring(p-vec3(-5,2,0)));\n    de = min(de,co(p-vec3(0,2,5)));\n    de = min(de,deTaper(p-vec3(0,2,-5)));\n    de = min(de,test(p));\n    de = min(de,deChain(p));\n    \n    return de;\n}\n\nvec3 pos[1] =vec3[](vec3(1.5,3,1));\nmat3 mat[1] =mat3[](mat3(1));\nint ID=0;\n#define DMIN(d) if(de>d){de=d;ID=idx;}idx++;\n#define CO (p-pos[idx])*mat[idx]\nfloat map(in vec3 p)\n{\n    \n    float de=1e9;\n    int idx=0;\n    DMIN(deNut(CO))\n    \n    \n    \n    de= min(de,deBolt(p-vec3(-1.5,2,-1)));\n    de = min(de, deTarget(p-vec3(5,0,0)));    \n    de = min(de,deGround(p));\n    de = min(de,spring(p-vec3(-5,2,0)));\n    de = min(de,co(p-vec3(0,2,5)));\n    de = min(de,deTaper(p-vec3(0,2,-5)));\n    de = min(de,test(p));\n    de = min(de,deChain(p));\n    \n    return de;\n}\n\nvec3 doColor(in vec3 p)\n{\n    if (deGround(p)<0.001) return mix(0.6*texture(iChannel0, p.xz*0.15).xxx,\n    \t\tvec3(0.4,0.6,0.2), 0.3);\n    \n    return vec3(0.9, 0.6, 0.2);\n}\n\nvec3 calcNormal(vec3 p )\n{\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++)\n    {\n        vec3 e = 0.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n        n += e * map(p + e);\n    }\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 5.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    mat[0]=pointAtM(vec3(0.5773),vec3(0,1,0));\n    \n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.1+0.5*uv.y*uv.y);\n    vec3 ro = vec3(0.0, 4.0,8.5);\n    ro.xz *= rot(iTime * 0.2);\n    vec3 ta = vec3(0.0,3,0.0);\n    vec3 w = normalize(ta-ro);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = cross(u,w);\n    vec3 rd = mat3(u,v,w)*normalize(vec3(uv, 2.0));\n    float maxd = 30.0;\n    float t = 0.0, h;\n    for(int i = 0; i < 64; i++)\n    {\n        t += h = map(ro+rd*t);\n        if(h<0.001 || t>maxd) break;\n    }\n    if(t<maxd)\n    {\n        BBSW=false;\n        vec3 p = ro+t*rd;\n        vec3 n = calcNormal(p);\n\t\tcol = doColor(p);\n        vec3 li = normalize(vec3(2.0, 3.0, 3.0));\n        float dif = clamp(dot(n, li), 0.0, 1.0);\n        \n        dif *= softshadow(p, li);\n        col *= max(dif, 0.3);\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 60.0);\n        col = mix( col, vec3(0.0), 1.0-exp( -0.01*t*t ) );\n\t\tcol = pow(col, vec3(0.6));\n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}