{"ver":"0.1","info":{"id":"tlKyR3","date":"1611470302","viewed":139,"name":"2d ellipse from 3d disk","username":"dahart","description":"Computing the 2d image plane ellipse parameters (center, major/minor axis) from an arbitrarily oriented 3d circular disk, using a geometric construction. This shader is buggy - it has failure cases. And there are MUCH easier ways to do this!!!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["projection","ellipse","perspective","disk","geometric","construction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n// The perspective projection of a 3d disk onto an image plane is generally an ellipse,\n// but the ellipse center and axes do not necessarily correspond \n// to the disk's projected center or any projected axes.\n//\n// This shader demonstrates one way to compute the 2d image plane ellipse parameters \n// (center, major/minor axis) \n// from an arbitrarily oriented 3d circular disk, using a geometric construction. \n// \n// This shader is buggy - it has failure cases. \n// And there are MUCH easier ways to do this!!!\n// This method is not practical, it is only an exercise in geometric constructions.\n// For a much better method, see mattz's \"transforming ellipses\"\n// https://www.shadertoy.com/view/MlGGz3\n// \n//\n// Construction is from: \n// http://www.math.nus.edu.sg/~graeme/Geometry/Circle_in_Perspective/construct_axes.html\n// Additional ellipse properties via:\n// https://archive.org/details/constructivegeom00eagluoft/page/138\n//\n\n\nconst float hfov = 120.; // perspective intentionally extreme\nconst float dist = 7.;\nconst float mouseFactor = 24.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    const int numDots = 50;\n    Dot dots[numDots];\n    \n    for (int i = 0; i < numDots; i++) {\n        vec3 p = ( .5 - texelFetch( iChannel0 , ivec2(i, 0), 0 ).xyz );\n        vec3 n = normalize( .5 - texelFetch( iChannel0 , ivec2(i, 1), 0 ).xyz );\n        dots[i] = Dot(\n            20. * p,      // position\n            normalize(n), // normal\n            1.,           // radius\n            vec3(1,0,1)   // color\n        );\n    }\n    \n    vec3 m = mouseFactor * vec3(iMouse.xy / iResolution.xy - .501, 0);\n    float time = iTime + dot(m, vec3(1.));// / 100.;\n    g_seed = float(base_hash(uvec2(fragCoord)))/float(0xffffffffU)+time;\n\n    float margin = .5 * (iResolution.x - iResolution.y);\n\tvec2 uv = (fragCoord.xy - X.xy*margin) / iResolution.yy;\n\n    vec3 lookfrom = vec3(0, 0, -dist);\n    vec3 lookat   = vec3(0);\n    vec3 up       = vec3(0., 1., 0.);\n    float aspect  = 1.;\n\n    Camera cam = Camera_make(lookfrom, lookat, up, hfov, aspect);\n    \n\tRay r = Camera_getRay(cam, uv);\n    \n    // sphere center\t\n    vec3 col = vec3(0.18);\n\n    // raytrace\n\tfloat tmin = 9e9;\t\n\tbool hit = false;\n    int mat = MAT_BG;\n    vec3 cemin, u, v;\n    float pt, t;\n    vec2 st;\n    vec3 tsr;\n    \n    const vec3 white = vec3(1);\n    const vec3 gray = 0.18 * white;\n    \n\n        \n    {\n        Dot d;\n        d.p = 3.*vec3(1,1,-1);\n        d.r = 2.;\n        mat3 rot = rotationMatrix(Y, m.x) * rotationMatrix(X, m.y);\n        mat3 irot = inverse(rot);\n        d.n = rot * -Z;\n        u = rot * d.r * X;\n        v = rot * d.r * Y;\n\n        t = ellipseIntersect( r.o, r.d, d.p, d.n, u, v);\n        if (t > 0. && t < tmin) { \n            tmin = t; mat = MAT_COL; \n            vec3 hp = r.o + t * r.d - d.p;\n            vec3 lp = irot * hp;\n            col = fract(lp);\n        }\n\n        #if 0\n        t = sphereIntersect( r.o, r.d, d.p + u, 0.25, 1e-4, tmin );\n        if (t > 0. && t < tmin) { col = X; mat = MAT_COL; tmin = t; }\n\n        t = sphereIntersect( r.o, r.d, d.p + v, 0.25, 1e-4, tmin );\n        if (t > 0. && t < tmin) { col = Z; mat = MAT_COL; tmin = t; }\n        #endif\n        \n        vec2 u2;\n        u2 = Camera_p3_2_uv(cam, d.p + u); if (length(uv - u2.xy) < 0.01) col = gray + X/2.;\n        u2 = Camera_p3_2_uv(cam, d.p + v); if (length(uv - u2.xy) < 0.01) col = gray + Y/2.;\n        u2 = Camera_p3_2_uv(cam, d.p); if (length(uv - u2.xy) < 0.01) col = gray;\n\n\n    // http://www.math.nus.edu.sg/~graeme/Geometry/Circle_in_Perspective/construct_axes.html\n    // https://archive.org/details/constructivegeom00eagluoft/page/138\n    //\n    //\n    // step 1: center\n    //\n    // Choose two of the points A,B on the ellipse for which we know the tangent \n    // mark the midpoint M and mark the point X where the tangent lines intersect.\n    // Draw a line from the intersection of the tangents through Mab. \n    // This line Lab will pass through the centre of the ellipse.\n    // \n    // Repeat the construction with a different pair of points C,D on the ellipse \n    // to obtain another line Z passing through the centre.\n    // The line Lcd passing through Z and the midpoint Mcd of CD, \n    // The intersection of Lab and Lcd is the centre O of the ellipse.\n\n    \tvec3 A = d.p + rot * d.r * X;\n        vec3 B = d.p + rot * d.r * Y;\n        vec3 Xab = d.p + rot * d.r * (X+Y);\n        vec3 Xpab = Camera_p3_2_plane(cam, Xab);\n        \n        const float s2 = sqrt(2.)/2.;\n        vec3 C = d.p + rot * d.r * -X;\n        vec3 D = d.p + rot * d.r * -Y;\n        vec3 Xcd = d.p + rot * d.r * (-X-Y);\n        vec3 Xpcd = Camera_p3_2_plane(cam, Xcd);\n\n        vec3 Ap = Camera_p3_2_plane(cam, A);\n        vec3 Bp = Camera_p3_2_plane(cam, B);\n        vec3 Cp = Camera_p3_2_plane(cam, C);\n        vec3 Dp = Camera_p3_2_plane(cam, D);\n        \n        vec3 Mpab = (Ap + Bp) / 2.;\n        vec3 Mpcd = (Cp + Dp) / 2.;\n        \n\n        vec3 Op = lineInt(Mpab, Xpab, Mpcd, Xpcd);\n        vec2 Ouv = Camera_p3_2_uv(cam, Op);\n\n        #if 1\n        {\n            vec4 tn = iCylinder(r.o, r.d, Mpab, Xpab, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = X+Z; mat = MAT_COL; tmin = t; }\n        }\n        {\n            vec4 tn = iCylinder(r.o, r.d, Mpcd, Xpcd, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = X+Z; mat = MAT_COL; tmin = t; }\n        }\n        {\n            vec4 tn = iCylinder(r.o, r.d, Op, Xpab, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = X+Y; mat = MAT_COL; tmin = t; }\n        }\n        {\n            vec4 tn = iCylinder(r.o, r.d, Op, Xpcd, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = X+Y; mat = MAT_COL; tmin = t; }\n        }\n        {\n            vec4 tn = iCylinder(r.o, r.d, Ap, Bp, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = Z+Y; mat = MAT_COL; tmin = t; }\n        }\n        {\n            vec4 tn = iCylinder(r.o, r.d, Cp, Dp, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = Z+Y; mat = MAT_COL; tmin = t; }\n        }\n\t\tif (length(uv - Ouv) < .01) col = vec3(1.);        \n        #endif\n\n    \n    // step 2: conjugate diameters\n\t// Draw a line through O which is parallel to AB. \n    // This is the diameter of the ellipse which is conjugate to OX. \n    // In the same way, construct the line through O which is parallel to CD. \n    // This is conjugate to the diameter OZ.\n        \n        vec3 Xpab_Op_dir = Xpab - Op;\n        vec3 Xpab_conj_dir = Bp - Ap;\n        if (dot(Xpab_conj_dir, Xpab_Op_dir) < 0.) Xpab_conj_dir = -Xpab_conj_dir;\n        vec3 Xpcd_conj_dir = Dp - Cp;\n        if (dot(Xpcd_conj_dir, Xpab_Op_dir) < 0.) Xpcd_conj_dir = -Xpcd_conj_dir;\n        \n        vec3 O_Xpab_conj = Op + Xpab_conj_dir;\n        vec3 O_Xpcd_conj = Op + Xpcd_conj_dir;\n\n        #if 1\n        {\n            vec4 tn = iCylinder(r.o, r.d, Op-Xpab_conj_dir, Op+Xpab_conj_dir, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = Z; mat = MAT_COL; tmin = t; }\n        }\n        {\n            vec4 tn = iCylinder(r.o, r.d, Op-Xpcd_conj_dir, Op+Xpcd_conj_dir, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = Y+Z; mat = MAT_COL; tmin = t; }\n        }\n        #endif\n\n        \n   \t// step 3: Construct the involution relating pairs of conjugate diameters\n\t// The conjugate diameters of an ellipse form conjugate pairs of lines\n    // in the pencil of lines through the centre O. \n    // These lines are related by an involution on this pencil. \n    // An involution is determined by two pairs of lines, \n    // and so we can construct this involution from the \n    // two pairs of conjugate diameters constructed above.\n\t//\n    // There are a number of ways to construct this involution. \n    // For the next step (see below) it will be useful to construct this involution on a circle. \n    // Draw a circle passing through the point O. \n    // For convenience we will choose X as the centre of the circle, but any point will do.\n    //\n\t// Let S1 and S2 be the intersection points of \n    // one pair of conjugate diameters with the circle, \n    // and let T1 and T2 be the intersection points of the other pair.\n\t//\n\t// The centre R of the involution is the intersection of S1S2 and T1T2. \n    // Therefore, given any line through R intersecting the circle at U1 and U2, \n    // the lines OU1 and OU2 are a pair of conjugate diameters.\n        \n        vec2 Xab_uv = Camera_p3_2_uv(cam, Xpab);\n        vec2 Xcd_uv = Camera_p3_2_uv(cam, Xpcd);\n        vec2 O_uv   = Camera_p3_2_uv(cam, Op);\n        vec2 S1_uv = Xab_uv + (Xab_uv - O_uv);\n        \n        vec2 O_Xab_conj_uv = Camera_p3_2_uv(cam, O_Xpab_conj);\n        vec2 O_Xcd_conj_uv = Camera_p3_2_uv(cam, O_Xpcd_conj);\n\n        float rad = length(Xab_uv - O_uv);\n        vec2 S2_uv = lineOnCircleInt(Xab_uv, rad, O_uv, O_Xab_conj_uv);\n\n        vec3 S1_p = Camera_uv_2_plane(cam, S1_uv);\n        vec3 S2_p = Camera_uv_2_plane(cam, S2_uv);\n                \n        vec2 T1_uv = lineOnCircleInt(Xab_uv, rad, O_uv, O_Xcd_conj_uv);\n        vec2 T2_uv = lineOnCircleInt(Xab_uv, rad, O_uv, Camera_p3_2_uv(cam, Mpcd));\n\n        vec3 T1_p = Camera_uv_2_plane(cam, T1_uv);\n        vec3 T2_p = Camera_uv_2_plane(cam, T2_uv);\n\n\n        #if 1\n        if (length(uv - Xab_uv) < length(O_uv - Xab_uv)) col += vec3(.1);\n        {\n            vec4 tn = iCylinder(r.o, r.d, Op, O_Xpab_conj, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = X; mat = MAT_COL; tmin = t; }\n            tn = iCylinder(r.o, r.d, Op, O_Xpcd_conj, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = X; mat = MAT_COL; tmin = t; }\n        }\n        if (length(uv - S1_uv) < 0.01) col = X;\n        if (length(uv - S2_uv) < 0.01) col = Y;\n        if (length(uv - T1_uv) < 0.01) col = X+Y+Z/2.;\n        if (length(uv - T2_uv) < 0.01) col = X+Y/2.+Z;\n        {\n            vec4 tn = iCylinder(r.o, r.d, S1_p, S2_p, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = X+Y; mat = MAT_COL; tmin = t; }\n        }\n        {\n            vec4 tn = iCylinder(r.o, r.d, T1_p, T2_p, 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = Z; mat = MAT_COL; tmin = t; }\n        }\n        #endif\n        \n\n        \n    //\n    //\n    // step 4: Construct the major and minor axes\n\t// The major/minor axes are the pair of conjugate diameters \n    // which intersect at right angles (they are unique \n    // in the general case where the ellipse is not a circle). \n    // If two lines intersect the point O on the circle at right angles, \n    // then the other intersection points M1 and M2 on the circle \n    // must lie on opposite sides of a diameter of the circle. \n    // Since M1 and M2 are related by the involution constructed above, \n    // then this diameter must pass through R (the centre of involution). \n    // Therefore, the diameter is the line RX \n    // and the points M1 and M2 are the intersection points of RX with the circle.\n        \n\t\tvec2 R_uv = lineInt(\n            vec3(S1_uv,0), vec3(S2_uv,0), \n            vec3(T1_uv,0), vec3(T2_uv,0)).xy;\n\n        vec2 M1_uv, M2_uv;\n        lineCircleInt(Xab_uv, rad, Xab_uv, R_uv, M1_uv, M2_uv);\n\n        #if 1\n        if (length(uv - R_uv) < 0.02) col = X;\n        if (length(uv - M1_uv) < 0.01) col = Y;\n        if (length(uv - M2_uv) < 0.01) col = Z;\n        {\n            vec4 tn = iCylinder(r.o, r.d, Op, Camera_uv_2_plane(cam, M1_uv), 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = Z; mat = MAT_COL; tmin = t; }\n        }\n        {\n            vec4 tn = iCylinder(r.o, r.d, Op, Camera_uv_2_plane(cam, M2_uv), 0.01);\n            if (tn.x > 0. && tn.x < tmin) { col = Z; mat = MAT_COL; tmin = t; }\n        }\n        #endif\n        \n        float Ot = planeIntersect(r.o, Op-r.o, d.p, d.n);\n        vec3 O = r.o + Ot * (Op - r.o);\n        \n        vec3 M1_p = Camera_uv_2_plane(cam, M1_uv);\n        vec3 M1_d = M1_p - r.o ;\n        float M1_t = planeIntersect(r.o, M1_d, d.p, d.n);\n        vec3 M1 = r.o + M1_t * M1_d;\n        vec3 M11, M12;\n        lineCircleInt3(d.p, d.r, O, M1, M11, M12);\n        if (dot(M11-O, M1-O) > 0.) M1 = M11; else M1 = M12;\n        M1_p = Camera_p3_2_plane(cam, M1);\n\n        vec3 M2_p = Camera_uv_2_plane(cam, M2_uv);\n        vec3 M2_d = M2_p - r.o;\n        float M2_t = planeIntersect(r.o, M2_d, d.p, d.n);\n        vec3 M2 = r.o + M2_t * M2_d;\n        vec3 M21, M22;\n        lineCircleInt3(d.p, d.r, O, M2, M21, M22);\n        if (dot(M21-O, M2-O) > 0.) M2 = M21; else M2 = M22;\n        M2_p = Camera_p3_2_plane(cam, M2);\n\t\t\n        if (1==1) {\n        \tfloat t;\n            t = sphereIntersect( r.o, r.d, M1, 0.25, 1e-4, tmin );\n            if (t > 0. && t < tmin) { col = Y; mat = MAT_COL; tmin = t; }\n        \tt = sphereIntersect( r.o, r.d, M2, 0.25, 1e-4, tmin );\n            if (t > 0. && t < tmin) { col = X; mat = MAT_COL; tmin = t; }\n        }\n        \n        if (1==1) {\n            float t1 = ellipseIntersect( r.o, r.d, Op, cam.w, M1_p - Op, M2_p - Op);\n            float t2 = ellipseIntersect( r.o, r.d, Op, cam.w, .9*(M1_p - Op), .9*(M2_p - Op));\n            if (t1 > 0. && t1 < tmin && t2 < 0.) {\n                tmin = t; mat = MAT_COL;\n                col *= .2;\n            }\n\n        }\n\n\t\tfragColor = vec4(col, 1.);\n    \treturn;\n    }\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\nconst vec3 nop = vec3(-1,0,1);\n\n// https://www.shadertoy.com/view/XlGcWD\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nuint base_hash(uvec2 p) {    p = 1103515245U*((p >> 1U)^(p.yx));    uint h32 = 1103515245U*((p.x)^(p.y>>3U));    return h32^(h32 >> 16);}\nfloat g_seed;\nfloat hash1(inout float seed) {    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));    return float(n)/float(0xffffffffU);}\nvec2  hash2(inout float seed) {    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));    uvec2 rz = uvec2(n, n*48271U);    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);}\nvec3  hash3(inout float seed) {    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));    uvec3 rz = uvec3(n, n*16807U, n*48271U);    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);}\n\n\nstruct Dot {\n    vec3 p;\n    vec3 n;\n    float r;\n    vec3 c;\n};\n\n#define MAT_BG    0\n#define MAT_COL   1\n#define MAT_DISC  2\n#define MAT_ELL   3\n#define MAT_EP_2D 4\n#define MAT_EP_3D 5\n\n\n\n// Pixar's JGT paper.   Produces two tangent vectors that\n// are an orthonormal basis b1, b2, n\nvoid branchlessONB(in vec3 n, out vec3 b1, out vec3 b2) {\n    float sn = sign(n[2]);\n    float a = -1. / (sn + n[2]);\n    float b = n[0] * n[1] * a;\n    b1 = vec3(1. + sn * n[0] * n[0] * a, sn * b, -sn * n[0]);\n    b2 = vec3(b, sn + n[1] * n[1] * a, -n[1]);\n}\n\n\n// https://www.shadertoy.com/view/4lcSRn\n// returns vec4(float:t, vec3:normal)\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, radius\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return vec4( t, (oc+t*rd - ba*y/baba)/ra );\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return vec4( t, ba*sign(y)/baba );\n    }\n\n    return vec4(-1.0);\n}\n\n\n// https://iquilezles.org/articles/intersectors\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra, float tmin, float tmax )\n{\n    vec2 tt = sphIntersect(ro, rd, ce, ra);\n    bool hit = false;\n    if (tt.x > tmin && tt.x < tmax) { hit = true; tmax = tt.x; }\n    if (tt.y > tmin && tt.y < tmax) { hit = true; tmax = tt.y; }\n    return (hit) ? tmax : -1.;\n}\n\n\n// dot( ro + t rd - p, n ) = 0\n// (ro + t rd - p) . n = 0\n// ro . n + t rd . n - p . n = 0\n// t rd . n = p . n - ro . n\n// t rd . n = (p - ro) . n\n// t = (p - ro) . n / rd . n\nfloat planeIntersect(in vec3 ro, in vec3 rd, in vec3 p, in vec3 n) {\n    return dot(n, p - ro) / dot(n, rd);\n}\n\n// vector projection of unit vectors; result is parallel to b \n// result is not unit\nvec3 projectUAtoUB(vec3 a, vec3 b) { return dot(a, b) * b; }\n\n// vector rejection of unit vectors; result is perpendicular to a (returns b component orthogonal to a)\n// result is not unit\nvec3 rejectUAfromUB(vec3 a, vec3 b) { return b - projectUAtoUB(b, a); }\n\n// intersection of two lines in 3d\nvec3 lineInt(vec3 a1, vec3 a2, vec3 b1, vec3 b2) {\n    vec3 ad = normalize(a2 - a1);\n    vec3 bd = normalize(b2 - b1);\n    vec3 ap = rejectUAfromUB(ad, bd);\n    // solve (b1 + t(b2-b1) - a1) . ap = 0;\n    // b1.ap + t(b2-b1).ap - a1.ap = 0\n    // t(b2-b1).ap = a1.ap - b1.ap\n    // t = (a1-b1).ap / (b2-b1).ap\n    float t = dot(a1 - b1, ap) / dot(b2 - b1, ap);\n    return b1 + t * (b2 - b1);\n}\n\n\nfloat ellipseIntersect(vec3 ro, vec3 rd, vec3 p, vec3 n, vec3 u, vec3 v) {\n    float t = planeIntersect(ro, rd, p, n);\n    vec3 pt = ro + t * rd;\n    float r = dot(pt - p, normalize(u)) / length(u);\n    float s = dot(pt - p, normalize(v)) / length(v);\n    if ( r * r + s * s > 1. ) return -1.; // no intersection\n    return t;\n}\n                       \nstruct Ray { vec3 o; vec3 d; };\nvec3 Ray_at_t(Ray r, float t) { return r.o + t * r.d; }\n\nstruct Camera {\n    vec3 origin;\n    vec3 u, v, w;\n    float hfov;\n    float aspect;\n    float width;\n    float height;\n    vec3 ll;\n};\n\nCamera Camera_make(vec3 lookfrom, vec3 lookat,\n                   vec3 vup, float hfovDeg,\n                   float aspect)\n{\n    Camera cam;\n    cam.aspect = aspect;\n    cam.hfov = radians(hfovDeg);\n    cam.width  = 2. * tan(cam.hfov / 2.);\n    cam.height = cam.width / aspect;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookat - lookfrom);\n    cam.u = normalize(cross(vup  , cam.w));\n    cam.v = normalize(cross(cam.w, cam.u));\n    cam.ll = cam.origin + cam.w - (cam.width/2.) * cam.u - (cam.height/2.) * cam.v;\n    return cam;\n}\n\n\n\nRay Camera_getRay(Camera cam, vec2 uv) {\n    return Ray(cam.origin, \n               normalize(cam.ll + uv.x * cam.width * cam.u + uv.y * cam.height * cam.v - cam.origin));\n}\n\nvec3 Camera_p3_2_plane(Camera cam, vec3 p) {\n    vec3 q = p - cam.origin;\n    float t = planeIntersect(cam.origin, q, cam.origin+cam.w, cam.w);\n    vec3 cp = cam.origin + t * q;\n    return cp;\n}\n\nvec3 Camera_uv_2_plane(Camera cam, vec2 uv) {\n    return cam.ll + uv.x * cam.u * cam.width + uv.y * cam.v * cam.height;\n}\n\nvec2 Camera_p3_2_uv(Camera cam, vec3 p) {\n    vec3 q = p - cam.origin;\n    float t = planeIntersect(cam.origin, q, cam.origin+cam.w, cam.w);\n    vec3 cp = cam.origin + t * q - cam.ll;\n    vec2 uv = vec2( dot(cam.u, cp)/cam.width, dot(cam.v, cp)/cam.height );\n    return uv;\n}\n\n// 2d line circle intersection, where one point of line (p1) is on the circle\n// so the result is the other intersection point\nvec2 lineOnCircleInt(vec2 C, float r, vec2 p1_on_C, vec2 p2) {\n    // solve length(p1 + t(p2-p1) - C) = r for t\n    // d = p2 - p1\n    // q = p1 - C\n    // length(td+q) = r\n    // (td + q).(td + q) = r*r\n    // tt*d.d + t*2d.q + q.q - r*r = 0\n    // solve quadratic where a=d.d, b=2d.q, c=q.q-r*r\n    vec2 d = p2 - p1_on_C;\n    vec2 q = p1_on_C - C;\n    float a = dot(d, d); // cannot be negative\n    float b = 2. * dot(d, q); // can be negative\n    float c = dot(q, q) - r*r; // probably zero. always zero?\n    // x = (-b +- sqrt(b*b - 4ac)) / 2a\n    // since one point is on line, discrim must be >= 0\n    float discrim = max(0., b * b - 4. * a * c);\n    //discrim = sqrt(discrim);\n    discrim = b;\n    float t1 = ( -b - discrim ) / (2. * a);\n    float t2 = ( -b + discrim ) / (2. * a);\n    //vec2 a1 = p1_on_C + t1 * d;\n    //vec2 a2 = p1_on_C + t2 * d;\n    //float d1 = dot(a1-p2, a1-p2);\n    //float d2 = dot(a2-p2, a2-p2);\n    //if (d1 > d2) return a1;\n    //return a2;\n    float t = t1;\n    //if (t2 > t1) t = t2; // answer should be the one closest to p2\n    return p1_on_C + t * d;\n}\n\n\n// 2d line circle intersection. input line must intersect circle\nvoid lineCircleInt(vec2 C, float r, vec2 p1, vec2 p2, out vec2 a1, out vec2 a2) {\n    // solve length(p1 + t(p2-p1) - C) = r for t\n    // d = p2 - p1\n    // q = p1 - C\n    // length(td+q) = r\n    // (td + q).(td + q) = r*r\n    // tt*d.d + t*2d.q + q.q - r*r = 0\n    // solve quadratic where a=d.d, b=2d.q, c=q.q-r*r\n    vec2 d = p2 - p1;\n    vec2 q = p1 - C;\n    float a = dot(d, d); // cannot be negative\n    float b = 2. * dot(d, q); // can be negative\n    float c = dot(q, q) - r*r;\n    // x = (-b +- sqrt(b*b - 4ac)) / 2a\n    // since line intersects circle, discrim must be >= 0\n    float discrim = max(0., b * b - 4. * a * c);\n    discrim = sqrt(discrim);\n    float t1 = ( -b - discrim ) / (2. * a);\n    float t2 = ( -b + discrim ) / (2. * a);\n    a1 = p1 + t1 * d;\n    a2 = p1 + t2 * d;\n}\n\n\n// 3d line circle intersection. input line must intersect circle\nvoid lineCircleInt3(vec3 C, float r, vec3 p1, vec3 p2, out vec3 a1, out vec3 a2) {\n    // solve length(p1 + t(p2-p1) - C) = r for t\n    // d = p2 - p1\n    // q = p1 - C\n    // length(td+q) = r\n    // (td + q).(td + q) = r*r\n    // tt*d.d + t*2d.q + q.q - r*r = 0\n    // solve quadratic where a=d.d, b=2d.q, c=q.q-r*r\n    vec3 d = p2 - p1;\n    vec3 q = p1 - C;\n    float a = dot(d, d); // cannot be negative\n    float b = 2. * dot(d, q); // can be negative\n    float c = dot(q, q) - r*r;\n    // x = (-b +- sqrt(b*b - 4ac)) / 2a\n    // since line intersects circle, discrim must be >= 0\n    float discrim = max(0., b * b - 4. * a * c);\n    discrim = sqrt(discrim);\n    float t1 = ( -b - discrim ) / (2. * a);\n    float t2 = ( -b + discrim ) / (2. * a);\n    a1 = p1 + t1 * d;\n    a2 = p1 + t2 * d;\n}\n\n\n// make a rotation matrix. axis must be unit length\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n","name":"Common","description":"","type":"common"}]}