{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\nBuffer Mandala Painter -- svenofnine / Erfurt 2024\nhttps://www.shadertoy.com/view/XfKfzc\n\nI had a lot fun extending my Basic Buffer Painter and practice dealing with efficient data storage in texels of a buffer.\nAnd my second goal was to describe as a reference how this works, there is a lot of inspiration out there,\nso I wanted to give some back, too.\n\n\nKeyboard Shortcuts\n==================\n\nSpace - clear canvas\n\nN - toggle cursor (white circle)\n\nM - toggle mirroring\n\n1,2,3,4,5,6 - change brush size\n\nQ,W,E,R,T,Y/Z,U,I,O,P - change colour\n\nA=3,S=6,D=12,F=24,G=9,H=5,J=10,K=7,L=14 - change axis symmetry\n\n*/\n\n// draws a circle with radius \"radius\" and with of 2*epsilon (falloff on two sides)\nvec3 gridcircle( float value, float radius, float epsilon ) {\n    return 1.*( vec3( smoothstep( radius-epsilon, radius, value ) - smoothstep(radius, radius+epsilon, value ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // read data for cursor\n    vec4 toggles_texel = (iFrame > 0 ) ? texelFetch( iChannel0, POS_ARMS_TOGGLES, 0 ) : vec4( 0.12, 1., 0., 0.);\n    bool show_cursor = ( toggles_texel.b > 0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center = iResolution.xy/2.;\n\n    vec4 col = texture(iChannel0, uv);\n\n    // add a cursor circle, with distance of mouse to center as radius\n    if( show_cursor )\n        col += vec4( gridcircle( distance(fragCoord, center), distance(iMouse.xy, center), 1. ), 0.);\n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\nBuffer Mandala Painter -- svenofnine / Erfurt 2024\nhttps://www.shadertoy.com/view/XfKfzc\n\nBuffer A - holds the painting and all variables\n*/\n\nvec3 draw_dot( vec2 center, vec2 uv, float brush_size, vec3 brush_color ){\n    return vec3(1. - smoothstep( 0., brush_size, distance(center, uv) )) * brush_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get canvas at Position fragCoord from Buffer1 / iChannel0\n    vec4 pixel = (iFrame > 0) ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4( 0.,0.,0.,1.);\n    // get data from special texels\n    vec4 clear_texel = (iFrame > 0) ? texelFetch( iChannel0, POS_CLEAR_TOGGLE, 0 ) : vec4( 0. );\n    vec4 size_texel = (iFrame > 0) ? texelFetch( iChannel0, POS_BRUSH_SIZE, 0 ) : vec4( 0.02, 0., 0., 0.);\n    vec4 color_texel = (iFrame > 0 ) ? texelFetch( iChannel0, POS_BRUSH_COLOR, 0 ) : vec4( 1., 0.5, 0., 1.);\n    vec4 toggles_texel = (iFrame > 0 ) ? texelFetch( iChannel0, POS_ARMS_TOGGLES, 0 ) : vec4( 0.12, 1., 1., 0.);\n    vec4 key_state = vec4(0.);\n    \n    // Geometry\n    vec2 center = iResolution.xy / 2.;            // the center pos in px   \n    vec2 rel_mouse = iMouse.xy - center;          // mouse pos in px\n    float angle = atan(rel_mouse.y, rel_mouse.x); // angle from center to mouse pos\n    float dist = length(rel_mouse);               // distance from center to mouse pos\n    \n    // if user wants to clear the canvas (keys 1..6)\n    if( clear_texel.r > 0. ) {\n      pixel.rgb = vec3(0.);\n      clear_texel.r = clamp(0., 1., clear_texel.r - 0.5 );\n    }\n    key_state = texelFetch( iChannel1, ivec2(KEY_SPACE,1), 0 );  // Space Key to clear canvas\n    if( key_state.r > 0. ) clear_texel.r = 1.0; \n    \n    // if user wants to change the brush size (keys 1..6)\n    if ( texelFetch( iChannel1, ivec2(KEY_1,1), 0 ).x > 0. ) size_texel.r = 0.01;\n    if ( texelFetch( iChannel1, ivec2(KEY_2,1), 0 ).x > 0. ) size_texel.r = 0.02;\n    if ( texelFetch( iChannel1, ivec2(KEY_3,1), 0 ).x > 0. ) size_texel.r = 0.03;\n    if ( texelFetch( iChannel1, ivec2(KEY_4,1), 0 ).x > 0. ) size_texel.r = 0.05;\n    if ( texelFetch( iChannel1, ivec2(KEY_5,1), 0 ).x > 0. ) size_texel.r = 0.08;\n    if ( texelFetch( iChannel1, ivec2(KEY_6,1), 0 ).x > 0. ) size_texel.r = 0.13;\n    float brush_size = size_texel.r * 100.;\n\n    // if user wants to change colours\n    if ( texelFetch( iChannel1, ivec2(KEY_Q,1), 0 ).x > 0. ) color_texel = vec4( 1. , 0. , 0. , 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_W,1), 0 ).x > 0. ) color_texel = vec4( 1. , 0. , 0. , 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_E,1), 0 ).x > 0. ) color_texel = vec4( 0.5, 0. , 1. , 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_R,1), 0 ).x > 0. ) color_texel = vec4( 0. , 1. , 0.5, 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_T,1), 0 ).x > 0. ) color_texel = vec4( 1. , 0.5, 1. , 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_Y,1), 0 ).x > 0. ) color_texel = vec4( 0.5, 0. , 0. , 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_Z,1), 0 ).x > 0. ) color_texel = vec4( 0.5, 0. , 0. , 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_U,1), 0 ).x > 0. ) color_texel = vec4( 0. , 0.5, 0. , 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_I,1), 0 ).x > 0. ) color_texel = vec4( 0. , 0. , 0.5, 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_O,1), 0 ).x > 0. ) color_texel = vec4( 0.5, 0.5, 0.5, 1. );\n    if ( texelFetch( iChannel1, ivec2(KEY_P,1), 0 ).x > 0. ) color_texel = vec4( 0. , 0. , 0. , 1. );\n    vec3 brush_color = color_texel.rgb;\n    \n    // if user wants to change the count of drawing points\n    if ( texelFetch( iChannel1, ivec2(KEY_A,1), 0 ).x > 0. ) toggles_texel.r = 0.03;\n    if ( texelFetch( iChannel1, ivec2(KEY_S,1), 0 ).x > 0. ) toggles_texel.r = 0.06;\n    if ( texelFetch( iChannel1, ivec2(KEY_D,1), 0 ).x > 0. ) toggles_texel.r = 0.09;\n    if ( texelFetch( iChannel1, ivec2(KEY_F,1), 0 ).x > 0. ) toggles_texel.r = 0.12;\n    if ( texelFetch( iChannel1, ivec2(KEY_G,1), 0 ).x > 0. ) toggles_texel.r = 0.24;\n    if ( texelFetch( iChannel1, ivec2(KEY_H,1), 0 ).x > 0. ) toggles_texel.r = 0.04;\n    if ( texelFetch( iChannel1, ivec2(KEY_J,1), 0 ).x > 0. ) toggles_texel.r = 0.08;\n    if ( texelFetch( iChannel1, ivec2(KEY_K,1), 0 ).x > 0. ) toggles_texel.r = 0.05;\n    if ( texelFetch( iChannel1, ivec2(KEY_L,1), 0 ).x > 0. ) toggles_texel.r = 0.10;\n    \n    // if user toggles mirroring\n    if ( texelFetch( iChannel1, ivec2(KEY_M,1), 0 ).x > 0. ) toggles_texel.g = 1. - toggles_texel.g;   // mirror\n    \n    // if user toggles the white circle\n    if ( texelFetch( iChannel1, ivec2(KEY_N,1), 0 ).x > 0. ) toggles_texel.b = 1. - toggles_texel.b;   // cursor circle\n    float count_arms = floor(toggles_texel.r*100.);\n    float count_arms_step = float( 6.28318530718 / count_arms );\n    bool mirror = ( toggles_texel.g > 0.5 );\n    \n    // draw a bit with current setup\n    if( iMouse.z > 0.5 ) {\n        for( float i = 0.; i < count_arms; i+=1. ){\n            float a = angle + i*count_arms_step;\n            pixel.rgb += 1. * draw_dot( vec2(center.x + dist*cos(a), center.y + dist*sin(a) ), fragCoord, brush_size, brush_color );\n            if( mirror ) {\n                a = -a - 0.5*count_arms_step;\n                pixel.rgb += 1. * draw_dot( vec2(center.x + dist*cos(a), center.y + dist*sin(a)), fragCoord, brush_size, brush_color );\n            }\n        }\n    }\n\n    fragColor = vec4( pixel.rgb, 1.0); \n    \n    // Save data back to texels\n    // derived from the Pacman Game, https://www.shadertoy.com/view/Ms3XWN, Buffer A, Line 81\n    fragColor = ( ivec2(fragCoord) == POS_CLEAR_TOGGLE ) ? clear_texel : fragColor;\n    fragColor = ( ivec2(fragCoord) == POS_BRUSH_SIZE ) ? size_texel : fragColor;\n    fragColor = ( ivec2(fragCoord) == POS_BRUSH_COLOR ) ? color_texel : fragColor;    \n    fragColor = ( ivec2(fragCoord) == POS_ARMS_TOGGLES ) ? toggles_texel : fragColor;  \n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"/*\nBuffer Mandala Painter -- svenofnine / Erfurt 2024\nhttps://www.shadertoy.com/view/XfKfzc\n\nCommon Tab - keyboard and texel IDs\n*/\n\n// codes found with Keycode Viewer by fb36ca4: https://www.shadertoy.com/view/4tt3Wn\nconst int KEY_SPACE = 32;   // clear canvas with space\n\n// keys for different brush sizes (fibonacci ...)\nconst int KEY_1 = 49;   // brush size 1.0\nconst int KEY_2 = 50;   // brush size 2.0\nconst int KEY_3 = 51;   // brush size 3.0\nconst int KEY_4 = 52;   // brush size 5.0\nconst int KEY_5 = 53;   // brush size 8.0\nconst int KEY_6 = 54;   // brush size 13.0\n\n// keys for different colours\nconst int KEY_Q = 81;   // gold (startup)\nconst int KEY_W = 87;   // surprise\nconst int KEY_E = 69;   // surprise\nconst int KEY_R = 82;   // surprise\nconst int KEY_T = 84;   // surprise\nconst int KEY_Y = 90;   // surprise\nconst int KEY_Z = 89;   // the same as Y for people like me who use a german keyboard\nconst int KEY_U = 85;   // surprise\nconst int KEY_I = 73;   // surprise\nconst int KEY_O = 79;   // surprise\nconst int KEY_P = 80;   // black\n\n// keys for changing the count of radial axis\nconst int KEY_A = 65;    // 3\nconst int KEY_S = 83;    // 6\nconst int KEY_D = 68;    // 12\nconst int KEY_F = 70;    // 24\nconst int KEY_G = 71;    // 9\nconst int KEY_H = 72;    // 5\nconst int KEY_J = 74;    // 10\nconst int KEY_K = 75;    // 7\nconst int KEY_L = 76;    // 14\n\n// toggles\nconst int KEY_M = 77;    // toggle mirroring on radial axis\nconst int KEY_N = 78;    // toggle circle cursor\n\n// positions of my storage texels\nconst ivec2 POS_CLEAR_TOGGLE = ivec2(0, 0);  // stores 1.0 at r value for clearing screen\nconst ivec2 POS_BRUSH_COLOR = ivec2(1, 0);   // current color\nconst ivec2 POS_BRUSH_SIZE = ivec2(2, 0);    // current size\nconst ivec2 POS_ARMS_TOGGLES = ivec2(3, 0);  // arm count (number of simultaneous drawings) and two toggles\n\n// Common and useful calculations\n#define ar vec2(iResolution.x/iResolution.y, 1.)  // aspect ratio of canvas\n#define unit float(1. / min(iResolution.x, iResolution.y))\n\n\n\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XfKfzc","date":"1734390279","viewed":83,"name":"Buffer Mandala Painter","username":"Svenofnine","description":"I made a fun project based on my previous shader. It's for drawing mandalas! First I recommend to go to full screen. Then try to draw. With space key you can clear the canvas and with letter and number keys you can do a lot more (see Common tab). Enjoy!","likes":3,"published":3,"flags":48,"usePreview":0,"tags":["test","mouse","interactive","drawing","mandala"],"hasliked":0,"parentid":"XcKfRc","parentname":"Basic Buffer Painter"}}