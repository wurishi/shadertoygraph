{"ver":"0.1","info":{"id":"DtdSWn","date":"1685270336","viewed":76,"name":"omg another fractal","username":"TheJinxedArtist","description":"Another fractal visualizer, essentially just copied from Pezza's Work on youtube:\nhttps://www.youtube.com/@PezzzasWork\n\nAlso someone please help I cant anti-alias to save my life ;-;","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fractal","julia","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Uncomment this to use very simple Anti-Aliasing\n#define USE_ANTI_ALIASING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float px = 1.0 / iResolution.y; //Single pixel\n    \n    //Half pixel works better for this version of anti-aliasing\n    px /= 2.0;\n\n    vec3 col = vec3(0);\n    \n#ifdef USE_ANTI_ALIASING\n    //Single pixel blur for simple Anti-Aliasing, looks terrible but works for now\n    col += texture(iChannel0, uv + vec2(0.0, px)).rgb;\n    col += texture(iChannel0, uv - vec2(0.0, px)).rgb;\n    col += texture(iChannel0, uv - vec2(px, 0.0)).rgb;\n    col += texture(iChannel0, uv + vec2(px, 0.0)).rgb;\n    col /= 4.0;\n#else\n    col = texture(iChannel0, uv).rgb;\n#endif\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Uncomment this to see my own modification\n//I have no clue if anyone has done this before\n//But it looks cool so yea\n\n#define USE_JULIA_FRACTAL\n\n//Compute next iteration of the fractal\nvec2 ComputeNext(vec2 current, vec2 constant)\n{\n\tfloat zr = current.x * current.x - current.y * current.y;\n\tfloat zi = 2.0 * current.x * current.y;\n    \n#ifdef USE_JULIA_FRACTAL\n    //Julia Set\n\treturn vec2(zr, zi) + constant;\n#else\n    //My own modification\n    return vec2(zr, zi) + zr * zi + constant;\n#endif\n}\n\nfloat mod2(vec2 z)\n{\n    return z.x * z.x + z.y * z.y;\n}\n\n//Generate the base fractal (smoothed)\nfloat ComputeIterations(vec2 z0, vec2 constant, int max_iteration)\n{\n\tvec2 zn = z0;\n\tint iteration = 0;\n\twhile(mod2(zn) < 4.0 && iteration < max_iteration)\n\t{\n\t\tzn = ComputeNext(zn, constant);\n\t\titeration++;\n\t}\n\tfloat mod = sqrt(mod2(zn));\n\tfloat smooth_iteration = float(iteration) - log2(max(1.0, log2(mod)));\n\treturn smooth_iteration;\n}\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //Create some values\n    float t = iTime * 0.5;\n    int iterations = 100;\n    \n    //Generate fractal\n    float fractal = ComputeIterations(uv * 2.0, vec2(sin(t), cos(t)), iterations);\n    \n    //Create colours\n    const vec3 c0 = vec3(36, 21, 61) / 255.0; //Dark purple\n    const vec3 c1 = vec3(255, 7, 110) / 255.0; //Hot pink\n    const vec3 c2 = vec3(230, 192, 106) / 255.0; //Pale yellow\n    \n    //Colour the fractal\n    float p = fractal / float(iterations);\n    vec3 c = mix(mix(c0, c1, p / 0.5), mix(c1, c2, (p - 0.5) / (1.0 - 0.5)), step(0.5, p));\n    c = mix(vec3(0), c, clamp(p / 0.1 + 0.5, 0.0, 1.0));\n    \n    //Return the final colour\n    fragColor = vec4(c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Uncomment this to apply my 0-1 tonemapper\n#define USE_CUSTOM_TONEMAP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n#ifdef USE_CUSTOM_TONEMAP\n    //One of my own algorithms for tonemapping 0-1 values while keeping the 0-1 range\n    \n    //First convert to linear space (approx)\n    col = pow(col, vec3(2.2));\n    //Next use Inverse Tonemapping (clamped)\n    col = min((col + col) / (1.0 - col), vec3(100.0));\n    //Now the image can be tonemapped, I'll use Stephen Hill's ACES\n    col = ACESFitted(col);\n    //Finally, convert back into sRGB (approx)\n    col = pow(col, vec3(0.4545));\n#endif\n    \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}