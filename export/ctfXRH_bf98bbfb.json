{"ver":"0.1","info":{"id":"ctfXRH","date":"1674244346","viewed":76,"name":"Shot photon noise explainer 1","username":"jean80it","description":"Shot photon noise explainer 1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shotphotonnoiseexplainer1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is part of several I wrote to create animations\n// to support a presentation about noise.\n// it is not supposed to be \"proof\" for anything, but to provide \n// good visualization of some concepts to help intuition.\n\n\n#define sqr(x) (x * x)\n\nfloat AAK = 0.001;  // anti aliasing constant: \n                    // determines how wide is transition \n                    // between inside and outside of an SDF\n                    // while drawing\n\nfloat sdCircle(vec2 uv, vec2 center, float r)\n{\n    return distance(center, uv) - max(0.0, r);\n}\n\nfloat drawSdMask(float sd)\n{\n    return smoothstep(AAK, -AAK, sd);\n}\n\nvoid drawSd(float sd, inout vec3 c, vec3 newCol)\n{\n    float m = drawSdMask(sd);\n    c = mix(c, newCol, m);\n}\n\nvoid drawSd(float sd, inout vec3 c, vec3 newCol, float alpha)\n{\n    float m = drawSdMask(sd) * alpha;\n    c = mix(c, newCol, m);\n}\n\nfloat sdSimpleRoundedBox( in vec2 p, in vec2 b, float r)\n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nvec3 gradient(float sd, float r1, float r2, vec3 col1, vec3 col2)\n{\n    return sqrt(mix(col1 * col1, col2 * col2, smoothstep(r1, r2, sd)));\n}\n\nvec3 circularGradient(vec2 uv, vec2 center, float r1, float r2, vec3 col1, vec3 col2)\n{\n    return gradient(sdCircle(uv, center, 0.0), r1, r2, col1, col2);\n}\n\nvec2 translate(vec2 p, vec2 newPos)\n{\n    return p - newPos;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n    mat2 r = mat2(\n        cos(a), sin(a),\n        -sin(a), cos(a)\n        );\n        \n    return p * r;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\nfloat getChaos(float t)\n{\n    return round((sin(t * 25.0) * sin(t * 13.0) * sin(t * 0.3)) * 0.5 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1), aspect correct\n    vec2 uv = fragCoord/iResolution.y;\n    float rEdge = iResolution.x / iResolution.y;\n\n    // configuration\n    float particleSize = 0.1;\n    vec2 gradDispl = particleSize * vec2(0.25, 0.25);\n    float gradSize = particleSize * 1.5;\n    \n    vec3 colLightYellow = vec3(1.0, 1.0, 0.0);\n    vec3 colDarkYellow = vec3(1.0, 0.61, 0.0);\n    \n    \n     vec3 colBackground = clamp(sqrt(mix(sqr(vec3(0.25, 0.2, 0.1)), \n                                   sqr(vec3(0.1, 0.22, 0.3)), \n                                   uv.y + uv.x / 2.0)),\n                                   0.0, 1.0);\n\n    vec3 col = colBackground;\n    \n    float time = iTime * 3.0;\n    \n    float t = (time - fract(time)) * 0.1;\n    float randSeed = getChaos(t);\n    \n    vec2 pos = vec2(fract(time) * 2.0 , 0.5 + randSeed);\n    \n    drawSd(sdCircle(uv, pos, particleSize),\n            col,\n            circularGradient(uv, pos + gradDispl, 0.00, gradSize, colLightYellow, colDarkYellow));\n    \n    drawSd(sdSimpleRoundedBox(translate(uv, vec2(rEdge - 0.02, 0.5)), vec2(0.01, 0.3), 0.01),\n            col, \n            mix(vec3(1.0, 0.0, 0.0), vec3(0.0), getChaos(t - 0.1)));\n    \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}