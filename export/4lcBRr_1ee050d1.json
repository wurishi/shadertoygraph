{"ver":"0.1","info":{"id":"4lcBRr","date":"1538720712","viewed":149,"name":"test048iy053986","username":"saidwho12","description":"pohird-y","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["96849ye0"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    fragColor = sqrt(texelFetch(iChannel0, ivec2(fragCoord), 0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ITER_MAX 128\n#define RAY_T_MAX 1000.0\n#define RAY_T_MIN 0.01\n#define EPSILON 1e-3\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define SQRT_2 sqrt(2.0)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\nfloat sdSphere(in vec3 p, in float r) { return length(p)-r; }\nfloat sdBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdBox2(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCappedCylinder(in vec3 p, in vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nmat2 rot2(in float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 rot3(in float a, in vec3 v) {\n\treturn mat3(a);\n}\n\n#define MAT_STANDARD 1\n#define MAT_EMISSIVE 2\n#define MAT_REFRACT 3\n#define MAT_TILING 4\n\nstruct Material {\n\tvec3 albedo;\n    vec3 specular;\n    float roughness;\n    int type;\n};\n\nconst vec3 dialectricSpecular = vec3(0.04, 0.04, 0.04);\nconst vec3 goldSpecular = vec3(1.0, 0.77, 0.34);\n\nconst Material materials[3] = Material[3](\n    Material(vec3(0.2), dialectricSpecular, 1.0, MAT_STANDARD),\n    Material(vec3(0.5), dialectricSpecular, 1.0, MAT_STANDARD),\n    Material(vec3(0.5, 0.4, 0.2), dialectricSpecular, 1.0, MAT_TILING)\n);\n\n#define DOME_THICKNESS .85\n\n// c [0;1], bottom dome cutoff\nfloat roof(in vec3 p, in float r, in float repetitions, in float c) {\n\tfloat t = sdSphere(p, r);\n    float rr = r/repetitions;\n    c = clamp(c, 0., 1.);\n    \n    vec3 p0 = p;\n    pModPolar(p0.xz, repetitions);\n    t = min(t, sdCappedCylinder(p0.xzy, vec2(r + rr * .2, rr * 0.3)));\n    t = min(t, sdCappedCylinder(p0.xzy, vec2(r + rr * .07, rr * .7)));\n    t = min(t, sdCappedCylinder(p, vec2(rr * .05, r * 1.66)));\n    p0 = p;\n    p0.xz = rot2(radians(360.) / repetitions * .5) * p0.xz;\n    pModPolar(p0.xz, repetitions);\n    t = max(t, -sdCappedCylinder(vec3(p0.zx, p0.y + r * c), vec2(rr * 1.75, r * 2.)));\n    t = max(t, -sdSphere(p, 1.0 - rr * DOME_THICKNESS));\n    return max(t, -p.y - r * c);\n}\n\nfloat pillar(in vec3 p, in vec2 h, in float repetitions, in float w) {\n    vec3 p0 = p;\n    vec3 b = vec3(h.x, .05 * h.y, h.x) * 1.44;\n    p0.xz = rot2(radians(360.) * p0.y * h.y * w) * p0.xz;\n    h.x += .07 * h.x * abs(sin(atan(p0.x, p0.z) * .5 * repetitions));\n    return .8 * min(sdCappedCylinder(p, h), sdBox(vec3(p.x, abs(p.y) - (h.y - .5 * b.y), p.z), b));\n}\n\n#define time iTime * 0.1\n\nstruct SDFInfo {\n\tfloat r;\n    int mat_id;\n};\n   \n// TODO: fix radius input parameter\nSDFInfo arch(in vec3 p, in float r, in float rep) {\n\tSDFInfo info;\n    //p.xy = rot2(iTime) * p.xy;\n    //p.xz = rot2(radians(360.) * time) * p.xz;\n    //p.yz = rot2(iTime * 0.5) * p.yz;\n    \n    //float t = roof(p, 1., floor(iMouse.x / iResolution.x * 12.0), .5);\n    float rr = r / rep;\n    vec3 p0 = p;\n    pModPolar(p0.xz, rep);\n    \n    float h0 = 1.2;\n    float co = .5; // Cutoff [0;1]\n    float t0 = roof(p - vec3(0,h0,0), r, rep, co);\n    // Find pillar offset from center\n    // r0 is radius of the cutoff\n    float b = r * co;\n    float r0 = sqrt(r*r - b*b);\n    r0 -= (rr * DOME_THICKNESS) * .5;\n    \n    // Find pillar height from dome center\n    h0 -= b;\n    float h1 = .5 * h0;\n    \n    float t1 = pillar(p0 - vec3(r0, h1, 0), vec2(.08, h1), 12., 2.0);\n    \n    //vec3 p0 = p;\n  \t//t = min(t, sdBox(p0 - vec3(0,2,0), vec3(0.2)));\n    \n    info.r = min(t0,t1);\n\t\n    if(info.r == t0) {\n    \tinfo.mat_id = 0;\n    } else if(info.r == t1) {\n    \tinfo.mat_id = 1;\n    }\n    \n    return info;\n}\n\nSDFInfo f(in vec3 p) {\n    SDFInfo info;\n    SDFInfo info1 = arch(p, 1.0, 8.0);\n    info.r = min(info1.r, p.y);\n    if(info.r == p.y) {\n    \tinfo.mat_id = 2;\n\t} else {\n    \tinfo.mat_id = info1.mat_id;\n    }\n    return info;\n}\n\nvec3 n(in vec3 p) {\n\treturn normalize(vec3(\n    \tf(vec3(p.x + EPSILON, p.yz)).r - f(vec3(p.x - EPSILON, p.yz)).r,\n    \tf(vec3(p.x, p.y + EPSILON, p.z)).r - f(vec3(p.x, p.y - EPSILON, p.z)).r,\n    \tf(vec3(p.xy, p.z + EPSILON)).r - f(vec3(p.xy, p.z - EPSILON)).r\n    ));\n}\n\nstruct HitInfo {\n    float t;\n\tvec3 p, normal;\n    Material mat;\n};\n\nfloat trace(in vec3 o, in vec3 d, float pixelRadius, bool forceHit) {\n    float omega = 1.1;\n\tfloat t = RAY_T_MIN;\n    float candidate_error = RAY_T_MAX;\n    float candidate_t = RAY_T_MIN;\n    float previousRadius = 0.0, stepLength = 0.0;\n    float functionSign = sign(f(o).r);\n    for (int i = 0; i < ITER_MAX; ++i) {\n        float signedRadius = functionSign * f(o+d*t).r;\n        float radius = abs(signedRadius);\n        \n    \tbool sorFail = omega > 1.0 && (radius + previousRadius) < stepLength;\n        \n        if (sorFail) {\n            stepLength -= omega * stepLength;\n        \tomega = 1.0;\n        }\n        else {\n        \tstepLength = signedRadius * omega;\n        }\n        \n        previousRadius = radius;\n        float error = radius / t;\n        \n        if (!sorFail && error < candidate_error) {\n        \tcandidate_t = t;\n        \tcandidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > RAY_T_MAX)\n        \tbreak;\n        t += stepLength;\n    }\n    if ((t > RAY_T_MAX || candidate_error > pixelRadius) && !forceHit) return RAY_T_MAX;\n    return candidate_t;\n}\n\n    \nbool hit(in vec3 o, in vec3 d, inout HitInfo info) {\n\tfloat t = trace(o, d, 1.0 / length(iResolution.xy), false);\n    if(t == RAY_T_MAX) {\n    \treturn false;\n    }\n    \n    info.t = t;\n    info.p = o+d*info.t;\n    info.normal = n(info.p);\n    info.mat = materials[f(o+d*t).mat_id];\n    \n    if(info.mat.type == MAT_TILING) {\n        vec2 uv = fract(info.p.xz * 5.0);\n        vec2 p = uv * 2.0 - 1.0;\n        float r = min(sdBox2(p, vec2(SQRT_2 * .5)),\n                      sdBox2(rot2(radians(45.0)) * p, vec2(SQRT_2 * .5)));\n        float l = clamp(cos(32.0 * radians(360.0) * abs(r)),0.0,1.0) * exp(-12.0 * abs(r));\n        info.mat.specular = r < 0.0 ? dialectricSpecular : goldSpecular;\n\n        info.mat.albedo = max(vec3(r < 0.0 ? 3.0 : 1.0)\n                              //- clamp(exp(-3.0 * abs(t * 32.0)), EPSILON, 1.0)\n                              - l\n                              , 0.0);\n        info.mat.roughness = r < 0.0 ? 1.0 : 0.4;\n    }\n    \n    return true;\n}\n\n#define BOUNCES_COUNT 8\n#define SAMPLES_COUNT 1\n\nvec2 uv = vec2(0);\nfloat seed = 0.0;\n\nfloat Rand() {\n    seed++;\n\treturn hash13(vec3(uv, hash11(seed*1e-7) ));\n}\n\nvec3 RandDirectionSize(vec3 normal, float size) {\n\tfloat theta = Rand() * TAU;\n    float cosT = Rand();\n    float sinT = sqrt(1.0 - cosT * cosT);\n\tvec3 tangent = normalize(cross(normal.yzx, normal));\n    vec3 binormal = cross(normal, tangent);\n\treturn normalize((tangent * cos(theta) + binormal * sin(theta)) * sinT * size + normal * cosT);\n}\n\nvec3 color(in vec3 o, in vec3 d) {\n\tvec3 color = vec3(0.0);\n    vec3 falloff = vec3(1.0);\n    \n    for(int i = 0; i < BOUNCES_COUNT; i++) {\n        HitInfo info;\n        if(hit(o,d,info)) {\n            //color = info.normal * 0.5 + 0.5;\n            vec3 V = -d;\n            vec3 N = info.normal;\n            vec3 R = reflect(d, N);\n            float roughness = clamp(info.mat.roughness, 0.0, 1.0);\n            d = RandDirectionSize(R, roughness);\n            o = info.p + d * EPSILON;\n            float dotNL = max(dot(N,d),0.0);\n            falloff *= info.mat.albedo * dotNL;\n        } else {\n        \tcolor = falloff * texture(iChannel1, d).rgb;\n        \tbreak;\n        }\n    }\n    return color;\n}\n\nvec3 spherical(in vec2 p) {\n    float cT = cos(p.x), cP = cos(p.y), sT = sin(p.x), sP = sin(p.y);\n\treturn vec3(-sP*sT, cP, sP*cT);\n}\n\n#define P(x) (2.*x - iResolution.xy) / iResolution.y\n#define MOUSE_SENSITIVITY .25\n#define ORBIT_RADIUS 2.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 R = iResolution.xy;\n    uv = fragCoord / R;\n    seed = iTime;\n    \n    vec2 m = P(iMouse.xy);\n    if(iMouse.xy == vec2(0)) {\n    \tm.y = .65;\n    }\n    m.y *= .7;\n    \n    vec3 lookAt = vec3(0,1,0);\n    vec3 o = spherical(m * radians(360.) * vec2(1,2) * MOUSE_SENSITIVITY) * ORBIT_RADIUS + lookAt;\n    vec3 forward = normalize(lookAt - o);\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    \n    vec3 col = vec3(0);\n    \n    for(int i = 0; i < SAMPLES_COUNT; i++) {\n    \tvec2 p = P(fragCoord + vec2(Rand(), Rand()));\n        vec3 d = normalize(forward + p.x * right + p.y * up);\n    \tcol += color(o, d);\n    }\n    \n    col /= float(SAMPLES_COUNT);\n    \n    fragColor = vec4(0);\n    vec4 inColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    \n    if(iMouse.z > 0.0) {\n        fragColor.w = float(iFrame);\n    } else {\n    \tfragColor.w = inColor.w;\n    }\n    \n    float factor = 1.0/(float(iFrame+1)-inColor.w);\n    fragColor.rgb = mix(inColor.rgb, col, factor);\n    //fragColor.rgb = vec3(factor);\n}","name":"Buffer A","description":"","type":"buffer"}]}