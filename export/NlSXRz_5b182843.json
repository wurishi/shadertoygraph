{"ver":"0.1","info":{"id":"NlSXRz","date":"1626882470","viewed":90,"name":"Simple blue wave","username":"Canysway","description":"studying raymarching.. :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define PI 3.141592\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n  \n    vec2 u = smoothstep(0.,1.,f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n\nfloat dPlane(vec3 p, vec3 n){\n    return dot(p, normalize(n));  // make plane with nomral vector\n}\n\n\nfloat GetDist(vec3 p){\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    p.xz *= Rot(-m.x*PI);\n    float planeDist = dPlane(p, vec3(0., 1., 0.)) - .4 * noise(vec2(p.x, p.z + iTime)) * sin(p.z + iTime * 2.5);\n    return planeDist;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx)\n    );\n    return normalize(n);\n}\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(d0 > MAX_DIST || dS < SURF_DIST) break;\n    }\n\n    return d0;\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0., 5., 6.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float diffuse = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n*SURF_DIST * 2., l); \n    if(d<length(lightPos-p)) diffuse *= .05;\n    return diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    vec3 cam = vec3(0., 3., 0.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    float d = RayMarch(cam, rd);\n    if (d < MAX_DIST){\n        vec3 p = cam + rd* d;\n        float diffuse = GetLight(p);\n        col = vec3(diffuse);\n    }\n    col = pow(col, vec3(.4545));\n    float a = clamp(0., 1., col.r);\n    col = mix(vec3(1.), vec3(0., col.g * .4, col.b * .5), a);\n    // col = mix(vec3(3., 1., .5) * col, col, smoothstep(.0, .01, clamp(0., 1., col.r)));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}