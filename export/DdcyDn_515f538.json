{"ver":"0.1","info":{"id":"DdcyDn","date":"1702366238","viewed":28,"name":"LCG sub-sequence test reflection","username":"stagakis","description":"This shader tests the case of an LCG random number generator used for 2D point generation after a conditioned 2D point generation and checks for biases. This is used in direction generation in pathtracer.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["lcg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ^^ [Buffer A] is what you're looking for\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint seed;\n\n#define USE_NEW_INSTEAD_OF_LCG 1\n\nfloat rand(inout uint seed) {\n#if USE_NEW_INSTEAD_OF_LCG\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n#else\n    uint LCG_A = 1664525u;\n    uint LCG_C  = 1013904223u;\n    \n    seed = (LCG_A * seed + LCG_C);\n#endif\n\treturn float(seed>>8)/exp2(24.0f);\n}\n\nvec2 get_random_dir(inout uint seed) {\n#if 1\n    float x = rand(seed);\n    float y = rand(seed);\n    return fract(vec2(x,y) );\n#else\n    //code from https://www.shadertoy.com/view/4dtBWH\n    //return fract(p0 + float(n)*vec2(0.754877669, 0.569840296));\n    vec2 return_val = fract(vec2(seed*12664745u, seed*9560333u)/exp2(24.));\t// integer mul to avoid round-off\n    seed++;\n    return return_val;\n#endif\n}\n\n\nfloat shade(vec2 p) {\n\treturn 1. - smoothstep(0., 0.00001, dot(p, p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor.rgb = vec3(0.);\n    seed = uint(iFrame);\n\n    vec2 p = get_random_dir(seed);\n    \n    //If you hit a small disc in the center of the screen, then resample.\n    //That's how the ray bounce is simulated\n    if(length(p - vec2(0.5,0.5)) < 0.1){\n        p = get_random_dir(seed);\n        fragColor.rgb += shade(p - uv);\n    }\n    \n    vec3 prev_color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    fragColor.rgb += texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    fragColor.a   = 0.1;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}