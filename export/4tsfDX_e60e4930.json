{"ver":"0.1","info":{"id":"4tsfDX","date":"1515592464","viewed":127,"name":"filtre de convolution","username":"Simeon","description":"Ici on teste et on compare différents filtres sur des images","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["filter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define KERNEL_SIZE 9\n\n\n\n\n\n/*//F1 flou gaussien de rayon 1 (le 1/16 est la pour garder la même luminosité)\nconst float kernel[KERNEL_SIZE] = float[KERNEL_SIZE]( 1.0/16.0, 2.0/16.0, 1.0/16.0,\n                                                      2.0/16.0, 4.0/16.0, 2.0/16.0,\n                                                      1.0/16.0, 2.0/16.0, 1.0/16.0);*/\n/*//F2 filtre moyenneur (flou uniforme)\nconst float kernel[KERNEL_SIZE] = float[KERNEL_SIZE]( 1.0/9.0, 1.0/9.0, 1.0/9.0,\n                                                      1.0/9.0, 1.0/9.0, 1.0/9.0,\n                                                      1.0/9.0, 1.0/9.0, 1.0/9.0);*/\n\n/*//F3 Contours (dérivé)\nconst float kernel[KERNEL_SIZE] = float[KERNEL_SIZE]( 0.0, 1.0, 0.0,\n                                                      1.0, -4.0, 1.0,\n                                                      0.0, 1.0, 0.0);*/\n\n/*//F3 Contours (dérivé)\nconst float kernel[KERNEL_SIZE] = float[KERNEL_SIZE]( 0.0, 1.0, 0.0,\n                                                      1.0, -4.0, 1.0,\n                                                      0.0, 1.0, 0.0);*/\n\n/*//F4\nconst float kernel[KERNEL_SIZE] = float[KERNEL_SIZE]( 2.0, 0.0, 0.0,\n                                                      1.0, -1.0, 0.0,\n                                                      0.0, 0.0, -1.0);*/\n\n/*//F5 rend plus nette\nconst float kernel[KERNEL_SIZE] = float[KERNEL_SIZE]( -1.0, -1.0, -1.0,\n                                                      -1.0, 9.0, -1.0,\n                                                      -1.0, -1.0, -1.0);*/\n\n/*//F6 contours horizontaux\nconst float kernel[KERNEL_SIZE] = float[KERNEL_SIZE]( 1.0, 2.0, 1.0,\n                                                      0.0, 0.0, 0.0,\n                                                      -1.0, -2.0, -1.0);*/\n\n//F7 contours verticaux (dérivé)\nconst float kernel[KERNEL_SIZE] = float[KERNEL_SIZE]( -1.0, 0.0, 1.0,\n                                                      -2.0, 0.0, 2.0,\n                                                      -1.0, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sortie = vec4(0,0,0,1);\n    //Récupère la texture de channel0\n    \n    // ... appliquer le filtre ...\n    iChannelResolution[0];\n    iChannelResolution[1];\n    for(int u = -1; u <= 1; u++){\n        for(int v = -1; v <= 1; v++){\n            sortie += kernel[(u+1) + 3*(v+1)] * texture(iChannel0, uv + vec2(u,v)/iChannelResolution[0].xy);\n        }\n    }   \n    \n   \tfragColor = sortie;\n}\n","name":"Image","description":"","type":"image"}]}