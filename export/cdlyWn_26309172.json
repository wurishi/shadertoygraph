{"ver":"0.1","info":{"id":"cdlyWn","date":"1686733620","viewed":52,"name":"Quad SDF With L2 Metric","username":"Envy24","description":"Ugly and not optimized, but easy to rewrite for L1 and Linf metrics)\nSome expalanation can be found here in comments: https://www.shadertoy.com/view/dslcWn\n\nOptimized implementation for convex quads: https://www.shadertoy.com/view/7dSGWK","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","convex","quad","metric","non","l2"],"hasliked":0,"parentid":"dsXXzX","parentname":"SDF template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE ( 1. )\n#define ORIGIN      ( vec2(0) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n/*\n    SDF\n*/\nfloat theta(vec2 l, vec2 r)\n{\n    // cos(theta) = dot(l, r) / |l| * |r|.\n    float tDot = l.x * r.x + l.y * r.y;\n    float tModuleL = sqrt(l.x * l.x + l.y * l.y);\n    float tModuleR = sqrt(r.x * r.x + r.y * r.y);\n    float cosTheta = tDot / (tModuleL * tModuleR);\n    return acos(cosTheta) * 57.29577957f;\n}\nfloat quadSDF_L2(\n    vec2 NDC,\n    vec2 A,\n    vec2 B,\n    vec2 C,\n    vec2 D)\n{\n    float R = sinOSC(0.0, 0.1, iTime);\n\n    /*Case 1: Non-convex quad, \"visible\" intersection point. */\n    vec2 V[4] = vec2[4](A, B, C, D);    \n    for (int i = 0; i < 4; ++i)\n    {\n        vec2 a = V[i],\n             b = V[(i + 1) & 3],\n             c = V[(i + 2) & 3],\n             d = V[(i + 3) & 3];\n             \n        vec2 roots = segment_segment_intersection(b, c, d, a);\n    \n        if (roots.x >= 0. && roots.x <= 1. && roots.y >= 0. && roots.y <= 1.) {\n            vec2 I = b+(c-b)*roots.x;\n            return min(\n                triangleSDF_L2(NDC, a, b, I, R),\n                triangleSDF_L2(NDC, d, c, I, R));\n        } \n    }\n\n    vec2 AB = B - A,   \n         BC = C - B,\n         CD = D - C,\n         DA = A - D;\n\n    /*Minimal distance for cases 2,3*/\n    float min_dist = segmentSDF_L2(NDC, A, B, 0.);\n          min_dist = min(min_dist, segmentSDF_L2(NDC, B, C, 0.));\n          min_dist = min(min_dist, segmentSDF_L2(NDC, C, D, 0.));\n          min_dist = min(min_dist, segmentSDF_L2(NDC, D, A, 0.));\n          \n    float t0 = theta(AB, BC),\n          t1 = theta(BC, CD),\n          t2 = theta(CD, DA),\n          t3 = theta(DA, AB),\n          tmin = min(t0, min(t1, min(t2, t3)));\n          \n    float d = 0.; // Used only for sign.\n    \n    /*Case 2: Non-convex quad, \"invisible\" intersection point*/\n    if (tmin == t0 || tmin == t2)\n    {\n        d = min(\n             triangleSDF_L2(NDC, A, B, D, 0.),\n             triangleSDF_L2(NDC, D, B, C, 0.));\n        \n        float sign_ = d <= 0.001 ? -1. : 1.;\n        return sign_*min_dist - R;\n    }\n    if (tmin == t1 || tmin == t3)\n    {\n        d = min(\n             triangleSDF_L2(NDC, A, B, C, 0.),\n             triangleSDF_L2(NDC, C, A, D, 0.));\n        \n        float sign_ = d <= 0.001 ? -1. : 1.;\n        return sign_*min_dist - R;\n    }\n    \n    /*Case 3: Convex quad.*/\n    d = min(\n          triangleSDF_L2(NDC, A, B, C, R),\n          triangleSDF_L2(NDC, C, D, A, R));\n        \n    float sign_ = d <= 0.001 ? -1. : 1.;\n    return sign_*min_dist - R;\n}\n/*\n    SDF\n*/\n\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.6, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(4./iResolution.y, 0., abs(dist)) );\n}\n\nvec3 add_metric(vec2 NDC, vec2 A, vec2 B, vec2 C, vec2 D, vec3 color)\n{\n    float unit = 4.0 / iResolution.y,\n          half_pi = 1.5707963267948966,\n          T = iTime * 0.5;\n          \n    vec2 M = \n        iMouse.z > 0. ?\n            map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false) :\n            ORIGIN + cos(T+vec2(0., -half_pi))*SCENE_SCALE;\n            //vec2(0);\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(L2(NDC, M) - abs(quadSDF_L2(M, A, B, C, D)))));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float T = iTime*0.5;\n    vec2 A=rotz(-T*0.15)*vec2(-0.75, -0.55), B=rotz(-T*0.5)*vec2(0.75, 0.75)+vec2(sin(T))*0.5,\n         C=rotz(T*0.25)*vec2(-0.1, -0.75), D=rotz(T*0.25)*vec2(0.1, 0.75)-vec2(sin(T))*0.5;\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n    float minDist = quadSDF_L2(NDC, A, B, C, D);\n    \n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n         color = add_metric(NDC, A, B, C, D, color);\n         \n#define UNIT                      (  8.0 / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC, A, 0.02))); // Red    - A\n    color = mix(color, vec3(0,1,0), SMAA(diskSDF_L2(NDC, B, 0.02))); // Green  - B\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, C, 0.02))); // Blue   - C\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, D, 0.02))); // Purple - D\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nmat2 rotz(float rad)\n{\n    vec2 cs = vec2(cos(rad), sin(rad));\n    mat2 M = mat2( // row order\n         cs.x, -cs.y,\n         cs.y,  cs.x);\n    return transpose(M); // column order\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\nfloat triangleSDF_L2(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    float r)\n{\n    float minDist = min(segmentSDF_L2(NDC, P1, P0, 0.), segmentSDF_L2(NDC, P1, P2, 0.));\n          minDist = min(                   minDist, segmentSDF_L2(NDC, P2, P0, 0.));\n    \n    vec3 BARY = inverse(mat3(\n                     P0.x, P0.y, 1.0,\n                     P1.x, P1.y, 1.0,\n                     P2.x, P2.y, 1.0)) * vec3(NDC.x, NDC.y, 1);\n                     \n    return \n        BARY.x >= 0.0 && BARY.y >= 0.0 && BARY.z >= 0.0 ?\n            -(minDist + r) :\n             minDist - r;\n}\n\n/* Source: https://www.shadertoy.com/view/cdjXRG */\n// Pseudo-scalar vector multiplication\n//float cross_2d(vec2 L, vec2 R) { return L.x*R.y - L.y*R.x; }\nfloat cross_2d(vec2 L, vec2 R) { return determinant(mat2(L, R)); }\nvec2 segment_segment_intersection(vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    /* Variant 1: *\n    float a = P1.x - P0.x, // A.x\n          b = P3.x - P2.x, // B.x\n          \n          c = P1.y - P0.y, // A.y\n          d = P3.y - P2.y, // B.y\n          \n          e = P2.x - P0.x, // C.x\n          f = P2.y - P0.y; // C.y        \n    return vec2(\n        (e*d-b*f)/(a*d-b*c),\n        (c*e-a*f)/(a*d-c*b) );\n        \n    /* Variant 2: *\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / (A.x*B.y-A.y*B.x);\n    return vec2(\n        (B.y*C.x-B.x*C.y)*inv,\n        (A.y*C.x-A.x*C.y)*inv);\n        \n    /* Variant 3: */\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / cross_2d(A, B);\n    return vec2(\n        cross_2d(C, B)*inv,\n        cross_2d(C, A)*inv);\n}","name":"Common","description":"","type":"common"}]}