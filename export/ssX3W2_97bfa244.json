{"ver":"0.1","info":{"id":"ssX3W2","date":"1616539077","viewed":350,"name":"Bee Waggle Dance","username":"sylvain69780","description":"5 bees discovered a source of Nectar.\nLet's go to the dance floor !\nThat's the way bees communicate.\nZoom with the mouse for a better observation.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","honeycomb","bee"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Bee Waggle Dance\n    ----------------\n\n    Did you know that a bee has 5 eyes ?\n    The three ocelli are simple eyes that discern light intensity, \n    while each of the two large compound eyes contains about 6,900 facets \n    and is well suited for detecting movement.\n\n    Related references:\n    \n    Hexagonal Maze Flow - Shane\n    https://www.shadertoy.com/view/llSyDh\n    \n    Fork of \"Minimal Hexagonal Grid\" - Shane. \n    https://shadertoy.com/view/Xljczw\n    \n    2D distance functions - IQ\n    https://iquilezles.org/articles/distfunctions2d\n    \n    Making a smiley in ShaderToy - BigWings aka The Art of Code\n    https://youtu.be/ZlNnrpM0TRg\n    \n    Hexagonal Truchet Weaving - BigWings\n    https://www.shadertoy.com/view/llByzz\n\n*/\n\n#define T iTime\n#define S smoothstep\n#define sat(x) clamp(x,0.0,1.0)\n#define AA(d,r,pix) smoothstep( .75, -.75, (d)/(pix)-(r))   // antialiased draw. r >= 1.\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.173, 289.927)))*43758.5453); }\n\nfloat remap01 (float a,float b, float t) {\n    return sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nmat2 rot(float a) {\n    float s=sin(a),\n          c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n// Half of a Vesica, circle on the top\n// In fact, no need of Egg shape SDF if you add some rounding\n// My suggestion is to remove sdEgg from THE catalog, may be replace by this one \nfloat sdHalfVesica(vec2 p, float r, float d, float rnd)\n{\n    p.x = abs(p.x);\n    float b = sqrt(r*r-d*d);\n    float dist =  p.y < 0.0 ? length(p)-(r-d) :\n           ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n    return dist-rnd;\n}\n\n// half of Vesica again, circle on the right (need rouning to avoid sharp edges)\nfloat sdHalfVesica2(vec2 p, float r, float d, float rnd)\n{\n    float b = sqrt(r*r-d*d);\n    float dist =  p.x > 0.0 ? length(p)-b :\n           ((abs(p.y)-b)*d>abs(p.x)*b) ? length(abs(p)-vec2(0.0,b))\n                             : length(abs(p)-vec2(-d,0.0))-r;\n    return dist-rnd;\n}\n\n// Fabrice https://www.shadertoy.com/view/llySRh\nvec4 blendOver (vec4 A, vec4 B) {\n        return (A + (1.-A.a)*B); // \n}\n\n// Inspired by The Art of Code : https://www.youtube.com/watch?v=ZlNnrpM0TRg\n\nvec4 Abdomen(vec2 uv,float pix) {\n    float d = sdHalfVesica((uv-vec2(0.0,clamp(uv.y,-0.05,0.0)))*vec2(1.0,-1.0),.4,.33,.03); \n    vec4 col = AA(d,0.0,pix)*vec4(0.8,0.8,0.0,1.0);\n    // black bands\n    float tri = uv.y < -0.05 ? abs(fract(uv.y*10.0-.1+cos(6.*uv.x))-0.5)*4.0 : 0.0;\n    vec4 band = S(0.6,1.0,tri)*vec4(0.1,0.05,0.05,1.0)*col.a;\n    col = blendOver(band,col);\n    // shading\n    float edgeShade = remap01(0.0,0.09,-d);       \n    col.rgb*=edgeShade;\n    // glow\n    vec4 glow = S(.1,0.0,d)*vec4(0.4,0.8,0.3,1.0)*.3;\n    col = blendOver(col,glow);\n    return col;\n}\n\n\n\nvec4 Wings1(vec2 uv,float pix,float a,float time) {\n    a*=1.8;\n    uv.x=abs(uv.x)-.07;\n    uv.y-=.20;\n    uv*=rot(a+.1*(1.0+sin(a*2.8+time*20.)));\n    uv.y-=-.24;    \n    float d = sdVesica(uv,0.365,0.3)-.03;        \n    // borders\n    float t = S(0.02,0.01,abs(d));\n    float band = max(0.0,cos((uv.x-uv.y)*50.0));\n    t = max(t,band);\n    // blend\n    vec4 col = AA(d,0.0,pix)*vec4(0.5,0.5,0.7,1.0)*.2;\n    col = blendOver(AA(d,0.0,pix)*(vec4(vec3(0.2,0.1,0.03)*remap01(0.03,0.0,abs(d)),1.0)*t),col);\n    \n    return col;\n}\n\nvec4 Wings2(vec2 uv,float pix,float a, float time) {\n    a*=.8;\n    uv.x=abs(uv.x)-.07;\n    uv.y-=.20;\n    uv*=rot(a+.1*(1.0+sin(time*20.)));\n    uv.y-=-.18;    \n    float d = sdVesica(uv,0.300,0.26)-.03;        \n    // borders\n    float t = S(0.02,0.01,abs(d));\n    float band = max(0.0,cos((uv.x-uv.y)*50.0));\n    t = max(t,band);\n    // blend\n    vec4 col = AA(d,0.0,pix)*vec4(0.5,0.5,0.7,1.0)*.2;\n    col = blendOver(AA(d,0.0,pix)*(vec4(vec3(0.2,0.1,0.03)*remap01(0.03,0.0,abs(d)),1.0)*t),col);\n    return col;\n}\n\nvec4 Thorax(vec2 uv,float pix) {\n    float d = sdHalfVesica2((uv-vec2(0.0,0.177)).yx,.1,.09,.04); \n    vec4 col = AA(d,0.0,pix)*vec4(0.8,0.8,0.0,1.0);\n    // shading\n    float edgeShade = remap01(0.0,0.05,-d);   \n    col.rgb*=edgeShade;\n    // glow\n    vec4 glow = S(0.0,-0.05,d)*vec4(0.4,0.8,0.3,1.0)*.3;\n    col = blendOver(glow,col);\n    return col;\n}\n\nvec4 Head(vec2 uv,float pix) {\n    float d = length(uv-vec2(clamp(uv.x,-.030,.030),0.0))-.041; \n    d = min(d, length(uv-vec2(0.0,0.02))-.03);\n    vec4 col = AA(d,0.0,pix)*vec4(0.8,0.8,0.0,1.0);\n    // shading\n    float edgeShade = remap01(0.0,0.04,-d);  \n    col.rgb*=edgeShade;\n    return col;\n}\n\nvec4 Eyes(vec2 uv,float pix) {\n    uv.x=abs(uv.x)-.044;\n    float d = sdVesica((uv-vec2(0.0,0.29))*rot(-.1),.03,.025)-.025;\n    vec4 col = AA(d,0.0,pix)*vec4(0.8,0.3,0.0,1.0);\n    // shading\n    float edgeShade = remap01(0.0,0.04,-d);  \n    col.rgb*=edgeShade;\n    return col;\n}\n\n// Inigo\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec4 Antenna(vec2 uv,float pix) {\n    uv.x = abs(uv.x);\n    uv-=vec2(.024,0.33);\n    float a=0.0; //1.-S(-blur,blur,d-0.02);\n    float l=0.05;\n    float bend=3.14*.15+0.2*sin(T*3.0);\n    float r=l/bend;\n    vec2 sc=vec2(sin(bend),cos(bend));\n    vec2 start = uv-vec2(r,0.0);\n    float d=sdArc(start,sc,sc,r,0.007);\n    vec4 col = AA(d,0.0,pix)*vec4(0.8,0.8,0.0,1.0);\n    // shading\n    float edgeShade = remap01(0.0,0.007,-d);  \n    col.rgb*=edgeShade*.3;\n    return vec4(col);    \n}\n\nvec4 Legs(vec2 uv,float pix,float time) {\n    float side = sign(uv.x);\n    uv -= vec2(0.0,.20);\n    uv.x = abs(uv.x);\n    uv -= vec2(.05,0.0);\n    float move = S(.5,.9,sin(time+3.14))*side*(.5-S(-2.2,2.2,sin(time*20.0)))*.2;\n    uv *= rot(3.14*.25-move);\n    uv.y +=sin(uv.x*6.28*6.*(1.0+move))*.01;\n    float d = length(uv-vec2(clamp(uv.x,0.0,0.2*(1.0-move)),0.0))-0.01;\n    vec4 col = AA(d,0.0,pix)*vec4(0.8,0.3,0.0,1.0);\n    // shading\n    float edgeShade = remap01(0.0,0.007,-d);  \n    col.rgb*=edgeShade*.3;\n    return vec4(col);    \n}\n\nvec4 Legs2(vec2 uv,float pix,float time) {\n    float side = -sign(uv.x);\n    uv -= vec2(0.0,.19);\n    uv.x = abs(uv.x);\n    uv -= vec2(.05,0.0);\n    float move = S(.5,.9,sin(time+3.14))*side*(.5-S(-2.2,2.2,sin(time*20.0)))*.2;\n    uv *= rot(-3.14*.35+move);\n    uv.y +=cos(uv.x*6.28*3.5*(1.0+move))*.01;\n    float d = length(uv-vec2(clamp(uv.x,0.0,0.4*(1.0-move)),0.0))-0.01;\n    vec4 col = AA(d,0.0,pix)*vec4(0.8,0.3,0.0,1.0);\n    // shading\n    float edgeShade = remap01(0.0,0.007,-d);  \n    col.rgb*=edgeShade*.3;\n    return vec4(col);    \n}\n\nvec4 Legs3(vec2 uv,float pix,float time) {\n    float side = -sign(uv.x);\n    uv -= vec2(0.0,.19);\n    uv.x = abs(uv.x);\n    uv -= vec2(.05,0.0);\n    float move = S(.5,.9,sin(time+3.14))*side*(.5-S(-2.2,2.2,sin(time*20.0)))*.2;\n    uv *= rot(-3.14*.15-move);\n    uv.y +=cos(uv.x*6.28*6.*(1.0-move))*.01;\n    float d = length(uv-vec2(clamp(uv.x,0.0,0.2*(1.0+move)),0.0))-0.01;\n    vec4 col = AA(d,0.0,pix)*vec4(0.8,0.3,0.0,1.0);\n    // shading\n    float edgeShade = remap01(0.0,0.007,-d);  \n    col.rgb*=edgeShade*.3;\n    return vec4(col);    \n}\n\nvec4 Bee ( vec2 uv, float blur, float time ) {\n    if ( length(uv)>.7 ) return vec4(0);\n    float a = 1.0;\n    a=S(.9,.5,sin(time+3.14));\n    vec4 col=vec4(0);\n    col = blendOver(Legs(uv,blur,time),col);\n    col = blendOver(Legs2(uv,blur,time),col);\n    col = blendOver(Legs3(uv,blur,time),col);\n    col = blendOver(Antenna(uv-vec2(0.0,0.0),blur),col);\n    vec2 uv2 = uv;\n    uv2 -= vec2(0.0,.4-.33+.03);\n    uv2 *= rot(cos(time)*.25+cos(time*15.0)*.5*S(0.1,0.6,-sin(time)));\n    uv2 += vec2(0.0,.4-.33+.03);\n    uv2 -= vec2(0.0,0.03);\n    col = blendOver(Abdomen((uv2),blur),col);\n    col = blendOver(Thorax(uv,blur),col);\n    col = blendOver(Head(uv-vec2(0.0,0.28),blur),col);\n    col = blendOver(Eyes(uv-vec2(0.0,0.0),blur),col);\n    col = blendOver(Wings2(uv-vec2(0.0,0.0),blur,a,time),col);\n    col = blendOver(Wings1(uv-vec2(0.0,0.0),blur,a,time),col);\n    return col;\n}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 BeePath(float time) {\n    vec2 pos = vec2(0.0);\n    float turn = sign(sin(time*.5));\n    pos = .7*vec2(turn*smin(cos(time)-.7,0.0,.1),1.9*sin(time));\n    return pos;\n}\n\n\nvec3 BeeMoving(float time) {\n    vec3 pos = vec3(0);\n    pos.xy = BeePath(time);\n    vec2 dir = BeePath(time+.1)-pos.xy;\n    pos.z = -atan(dir.x,dir.y);\n    return pos;\n}\n\n\n// Fabrice https://www.shadertoy.com/view/lsKSRt\n// Fork of \"Minimal Hexagonal Grid\" by Shane. https://shadertoy.com/view/Xljczw\nconst vec2 s = vec2(1, 1.7320508);\nfloat hex(in vec2 p){\n    p = abs(p);\n    return max(dot(p, s*.5), p.x); // Hexagon.\n}\n\nvec4 getHex(vec2 p){\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nvec3 Honeycomb(vec2 uv,float pix) {\n    vec4 h = getHex(uv);\n    float rnd = hash21(h.zw);\n    vec2 disp = vec2(.01*sin(6.28*rnd),.01*cos(6.28*rnd))*sin(iTime*15.)*S(.8,1.0,cos(iTime+6.28*rnd));\n    float d = hex(h.xy-disp)-.45;\n    vec2 center = h.xy-disp;\n    float d2 = dot(center,center);\n    vec3 hue = ( .6 + .6 * cos( 6.3*(rnd)  + vec3(0,23,21)  ) );\n    vec3 inner = vec3(0.8,0.7,0.02)*0.8*S(.5,0.,d2);\n    inner = mix(inner,hue*hue,.5*S(.25,0.,d2)*S(.0,.5,sin(iTime*3.14+rnd*6.28)+.1));\n    vec4 col = AA(d,0.0,pix)*vec4(inner,1.0);\n    vec4 c = vec4(0.8,0.3,0.0,1.0)*.5;\n    float band = .5*sin((uv.y+uv.x)*3.14159*40.);\n    c += c*band;\n    c.rbg *=0.2+0.8*d/0.05;\n    col = blendOver(col,c);\n    return col.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    float pix = 2.0/iResolution.y;    \n    \n\tvec2 m = iMouse.xy/iResolution.xy;   \n    if ( iMouse.x > 0.0 ) {\n        m=2.0*iMouse.xy/iResolution.xy-1.0;\n        uv.x -=m.x;\n        uv *= (4. + 3.0*m.y)/4.0;\n        pix *= (4. + 3.0*m.y)/4.0;\n    }\n    \n    vec3 col=vec3(.7);\n    col = Honeycomb(uv*2.,pix*2.);\n    for ( int i = 0 ; i < 5 ; i++ ) {\n        vec2 p = uv;\n        float time = T+float(i)*3.14*2.4;\n        vec3 pos = BeeMoving(time+3.14/2.);\n        p*=rot(-3.14*.5);\n        p.y -= -.10;\n        p -= pos.xy*0.7;\n        p *= rot(pos.z);\n        p.y -= -.2;\n        vec4 layer = Bee(p,pix,time);\n        float shadow = Bee((p-S(.9,.5,sin(time+3.14))*vec2(-.1,-.1))*(.8+.2*S(.5,.9,sin(time+3.14))),pix*2.0,time).a;\n        col-=.5*col*shadow;\n        col = blendOver(layer,vec4(col,1.0)).rgb;    \n    }\n    // gamma\n    col = sqrt(col);\n    fragColor=vec4(col,0.0);\n}\n","name":"Image","description":"","type":"image"}]}