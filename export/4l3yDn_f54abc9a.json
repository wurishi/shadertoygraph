{"ver":"0.1","info":{"id":"4l3yDn","date":"1532161939","viewed":122,"name":"Path tracing spheres","username":"KAJAJJJ","description":"Simple path tracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RENDER_DIST 1000.0\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define INV_PI 0.31830988618\n#define INV_TWO_PI 0.15915494309\n#define EPS 0.0001\n#define NUM_SAMPLES 4\n#define NUM_SPHERES 5\n\n//#define USE_RAYMARCHING\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Intersection\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int material_id;\n};\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n};\n\n    \nstruct Scene\n{\n    Sphere spheres[NUM_SPHERES];\n};\n    \nstruct Camera\n{\n    vec3 origin;\n    vec3 forward;\n    vec3 up;\n    float focal_length;\n};\n\n// Util functions\n\n// Sampling\nint g_seed;\n\nint Hash(int x)\n{\n    x = (x ^ 61) ^ (x >> 16);\n    x = x + (x << 3);\n    x = x ^ (x >> 4);\n    x = x * 0x27d4eb2d;\n    x = x ^ (x >> 15);\n    x = 1103515245 * x + 12345;\n    return x;\n}\n\nvoid Rand_Init(int seed)\n{\n    g_seed = seed;\n}\n\nfloat Rand_GetFloat01()\n{\n    g_seed = Hash(g_seed);\n    return float(g_seed) * 2.3283064365386963e-10;\n}\n\nvec2 Rand_Sample2D()\n{\n    return vec2(Rand_GetFloat01(), Rand_GetFloat01());\n}\n\nvec3 Rand_Sample3D()\n{\n    return vec3(Rand_GetFloat01(), Rand_GetFloat01(), Rand_GetFloat01());\n}\n\nvec3 Rand_SampleHemisphereCosine(vec3 n)\n{\n    float phi = TWO_PI * Rand_GetFloat01();\n    float sin_theta_sqr = Rand_GetFloat01() * 0.5 + 0.5;\n    float sin_theta = sqrt(sin_theta_sqr);\n\n    vec3 axis = abs(n.x) > 0.001 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n    vec3 t = normalize(cross(axis, n));\n    vec3 s = cross(n, t);\n\n    return normalize(s*cos(phi)*sin_theta + t*sin(phi)*sin_theta + n*sqrt(1.0 - sin_theta_sqr));\n}\n\n// Time\nfloat GetTime()\n{\n\treturn iTime;   \n}\n\n// Ray functions\nRay Ray_Init(vec3 origin, vec3 dir)\n{\n    Ray ray;\n    ray.origin = origin;\n    ray.dir = dir;\n    return ray;\n}\n\n// Camera functions\nvec2 g_frag_coord;\n\nRay Camera_CreateRay(in Camera camera)\n{\n    vec2 cam_sample = ((g_frag_coord + Rand_Sample2D() - 0.5) / iResolution.xy - 0.5);\n    cam_sample.x *= iResolution.x / iResolution.y;\n    vec3 right = cross(camera.forward, camera.up);\n    vec3 dir = normalize(camera.focal_length * camera.forward + cam_sample.x * right + cam_sample.y * camera.up);\n\n    return Ray_Init(camera.origin, dir);\n}\n\nbool Sphere_Occluded(in Sphere sphere, in Ray ray)\n{\n    vec3 ray_to_center = ray.origin - sphere.origin;\n\tfloat b = dot(ray.dir, ray_to_center);\n\tfloat c = dot(ray_to_center, ray_to_center) - sphere.radius * sphere.radius;\n    if (c > 0.0 && b > 0.0)\n    {\n        return false;\n    }\n    \n\tfloat d = b * b - c;\n\n    if (d < 0.0)\n\t{\n\t\treturn false;\n    }\n    \n\tfloat t = -b - sqrt(d);\n    \n    if (t < 0.0)\n    {\n    \treturn false;\n    }\n    \n\treturn true;\n}\n\n// Primitive intersection\nbool Sphere_Intersect(in Sphere sphere, in Ray ray, inout Intersection isect)\n{\n\tvec3 ray_to_center = ray.origin - sphere.origin;\n\tfloat b = dot(ray.dir, ray_to_center);\n\tfloat c = dot(ray_to_center, ray_to_center) - sphere.radius * sphere.radius;\n    if (c > 0.0 && b > 0.0)\n    {\n        return false;\n    }\n    \n\tfloat d = b * b - c;\n\n    if (d < 0.0)\n\t{\n\t\treturn false;\n    }\n    \n\tfloat t = -b - sqrt(d);\n    \n    if (t < 0.0 || t > isect.t)\n    {\n    \treturn false;\n    }\n    \n    isect.t = t;\n    isect.pos = ray.origin + ray.dir * t;\n    isect.normal = normalize(isect.pos - sphere.origin);\n    isect.material_id = 0;\n    \n\treturn true;\n}\n\nbool Plane_Occluded(vec3 normal, float dist, in Ray ray)\n{    \n    float t = (-dot(normal, ray.origin) + dist) / dot(normal, ray.dir);\n    \n    if (t < 0.0)\n    {\n        return false;\n    }\n    \n    return true;\n}\n\nbool Plane_Intersect(vec3 normal, float dist, in Ray ray, inout Intersection isect)\n{    \n    float t = (-dot(normal, ray.origin) + dist) / dot(normal, ray.dir);\n    \n    if (t < 0.0 || t > isect.t)\n    {\n        return false;\n    }\n    \n    isect.t = t;\n    isect.pos = ray.origin + ray.dir * t;\n    isect.normal = normal;\n    isect.material_id = 1;\n\n    return true;\n}\n\nvec3 GammaToLinear(vec3 value)\n{\n    return pow(value, vec3(2.2));\n}\n\nvec3 LinearToGamma(vec3 value)\n{\n    return pow(value, vec3(1.0 / 2.2));\n}\n\n// Scene functions\nvoid Scene_Init(inout Scene scene)\n{\n    scene.spheres[0].origin = vec3(0.0, 0.0, 1.0);\n    scene.spheres[0].radius = 1.0;\n    scene.spheres[1].origin = vec3(3.0, 2.0, sin(GetTime()) + 1.5);\n    scene.spheres[1].radius = 0.5;\n    scene.spheres[2].origin = vec3(2.0, -2.0, sin(GetTime() * 1.04) + 1.5);\n    scene.spheres[2].radius = 0.5;\n    scene.spheres[3].origin = vec3(-2.0, 2.0, sin(GetTime() * 2.0) + 1.5);\n    scene.spheres[3].radius = 0.5;\n    scene.spheres[4].origin = vec3(-3.0, -2.0, sin(GetTime() * 1.5) + 1.5);\n    scene.spheres[4].radius = 0.5;\n}\n\n#ifndef USE_RAYMARCHING\nbool Scene_Occluded(in Scene scene, in Ray ray)\n{\n    bool occluded = false;\n    \n    for (int i = 0; i < NUM_SPHERES; ++i)\n    {\n        occluded = occluded || Sphere_Occluded(scene.spheres[i], ray);\n    }\n\n    occluded = occluded || Plane_Occluded(vec3(0.0, 0.0, 1.0), 0.0, ray);\n    \n    return occluded;\n        \n}\n\nvoid Scene_Intersect(in Scene scene, in Ray ray, inout Intersection isect)\n{\n    isect.t = MAX_RENDER_DIST;\n    \n    for (int i = 0; i < NUM_SPHERES; ++i)\n    {\n        Sphere_Intersect(scene.spheres[i], ray, isect);\n    }\n\n    Plane_Intersect(vec3(0.0, 0.0, 1.0), 0.0, ray, isect);\n\n}\n#else\n\nfloat Sphere_Distance(in Sphere sphere, vec3 pos)\n{\n    return length(sphere.origin - pos) - sphere.radius;\n}\n\nfloat Plane_Distance(vec3 normal, float dist, vec3 pos)\n{\n  return dot(pos, normal) + dist;\n}\n\nfloat Scene_Distance(in Scene scene, inout Intersection isect)\n{\n    return min(\n        Sphere_Distance(scene.spheres[0], isect.pos),\n        min(\n        Sphere_Distance(scene.spheres[1], isect.pos),\n        min(\n        Sphere_Distance(scene.spheres[2], isect.pos),\n        min(\n        Sphere_Distance(scene.spheres[3], isect.pos),\n        min(\n        Sphere_Distance(scene.spheres[4], isect.pos),\n        Plane_Distance(vec3(0.0, 0.0, 1.0), 0.0, isect.pos)\n        )))));\n}\n\nvoid Scene_Intersect(in Scene scene, in Ray ray, inout Intersection isect)\n{\n    const int maxstep = 64;\n\n    isect.t = 0.0;\n\n    for (int i = 0; i < maxstep; ++i)\n    {\n        isect.pos = ray.origin + ray.dir * isect.t;\n        float dist = Scene_Distance(scene, isect);\n        isect.normal = vec3(0.0, 0.0, 1.0);\n        isect.t += dist;\n        \n        if (dist < 0.001 || isect.t > MAX_RENDER_DIST)\n        {\n            return;\n        }\n\n    }\n}\n\n#endif\n\nvec3 SampleSky(vec3 dir)\n{\n    return pow(texture(iChannel0, dir.xzy).xyz, vec3(2.2)) * 2.0;\n}\n\nvec3 PathTrace(in Scene scene)\n{\n    Intersection isect;\n    Camera camera;\n    camera.origin = vec3(cos(GetTime() * 0.25) * 6.0, sin(GetTime() * 0.25) * 6.0, sin(GetTime() * 0.125) + 2.0);\n    camera.forward = -normalize(camera.origin);\n    camera.up = vec3(0.0, 0.0, 1.0);\n    camera.focal_length = 1.0;\n    Ray ray = Camera_CreateRay(camera);\n    \n    vec3 throughput = vec3(1.0);\n    vec3 radiance = vec3(0.0);\n    \n    for (int i = 0; i < 5; ++i)\n    {\n        Scene_Intersect(scene, ray, isect);\n        //return (isect.t > MAX_RENDER_DIST) ? vec3(1.0) : vec3(0.0);\n    \tif (isect.t >= MAX_RENDER_DIST)\n        {\n            radiance += throughput * SampleSky(ray.dir);\n            break;\n        }\n        vec3 wo = ray.dir;\n        \n        vec3 wi;\n        if (isect.material_id == 0)\n        {\n            if (Rand_GetFloat01() * 0.5 + 0.5 < 0.5)\n            {\n        \t\twi = reflect(wo, isect.normal);\n            }\n            else\n            {\n        \t\twi = Rand_SampleHemisphereCosine(isect.normal);\n            }\n        }\n        else\n        wi = Rand_SampleHemisphereCosine(isect.normal);\n        \n        vec3 kd;\n        if (isect.material_id == 0) kd = vec3(0.6, 0.25, 0.1);\n        if (isect.material_id == 1) kd = GammaToLinear(texture(iChannel1, isect.pos.xy / 4.0).xyz);\n        \n        throughput *= kd;\n        \n        ray = Ray_Init(isect.pos + wi * EPS, wi);\n        \n    }\n        \n    return radiance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    g_frag_coord = fragCoord;\n\n\n    Rand_Init(int(fragCoord.x * iResolution + fragCoord.y)\n              + Hash(int(GetTime() * 548923.78))\n             );\n    \n    Scene scene;  \n    Scene_Init(scene);\n\n    for (int i = 0; i < NUM_SAMPLES; ++i)\n    fragColor.xyz += PathTrace(scene);\n    fragColor.xyz /= float(NUM_SAMPLES);\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"}]}