{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Wythoff Platonic Solids by spalmer http://shadertoy.com/view/XcVfzh\n\n// CCA NC-BY-SA 3.0 unported license\n\n// http://wikipedia.org/wiki/Wythoff_construction\n\n// platonic solids, the Wythoff way.\n\n// fork of Platonic DOP http://shadertoy.com/view/md2cWy\n\n// got inspired by http://shadertoy.com/view/McGfRR\n// fabrice & mla discussions\n// goal is to eliminate most of the \"magic constants\" \n// leaving only integer Schwarz triangle indices\n\n// tyvm @mattz for showing the way!\n\n// rendering is spherecast cone marching for edge AA\n// with simple environment map reflection.\n\n\nconst float size = 1.;\nconst float eyed = size * 2.3; // how far eye is back from origin\n\n\n#define IZERO min(0, iFrame)\n\nconst float pi = radians(180.);\n\n// macros for compile time constants\n#define rot(c) mat2(cos((c) + .5 * pi * vec4(0,-1,1,0)))\n\n#define split(e0, e1) normalize(cross(e0, e1))\n\n// originally was using compile time constant points;\n// now switching by various means,\n// so, ComputeWythoff() using global variables for now\n// the globals are for convenience for the dshape interface\nvec3 P0, P1, P2; // P0 = edge midpoint, P1 = face center, P2 = face vertex\nvec3 E0, E1, E2; // clip edge normals\nvec3 N; // normal\nfloat L; // plane distance from origin\n/*\nE0,1,2 are the normals of the great-circles for clipping sph tri edges\n\nP0,1,2 are the vertices of the right sixth-triangle:\n0 = an edge midpoint, 1 = a face center, 2 = a face vertex\n\nN = face normal\n\nL = origin distance\n I only know offhand for octahedron: sqrt(1./3.) * size\n      apparently tetrahedron is actually (1./3.) * size\nL = size gives all the vertices poofed to the unit sphere, \nso \"folds\" the triangles around the sphere, we don't want that.\n\n//ivec3 W;\nW is the Wythoff number for the construction\n.z here is always 2 (right angles due to splitting main tri in half each way)\nso the 2 means one of the angles is a right angle\nand .y is always 3 for platonic stuff (because it can't also be 2)\nthere are really only very few integer possibilities that make sense\n\naha.  their \"triangle\" is actually a right triangle\nwhich is 1/6 of one of the equilateral face triangles.\nso I was off by factor of 2 due to that.\n\n//vec3 A;\nA describes the vertex angles of spherical sixth-triangle, \nwhich also happens to correspond to angle between great circles\n\n*/\n\nvoid ComputeWythoff()\n{\n    // alternate among all the interesting (to me currently)\n    // integer platonic solids (no duals or snubs .. yet!)\n    int whichkind = 0; // choose\n    whichkind = int(floor(iTime * .2)) % 4; // animate\n    ivec3 W;\n    W = ivec3[] ( ivec3(5,3,2), ivec3(3,5,2), ivec3(3,3,2), ivec3(4,3,2) )\n        [whichkind];\n    //W = ivec3(5,3,2); //3,3,2); //3,5,2); //4,3,2); // hard-code\n\n    // angles\n    vec3 A = pi / vec3(W);\n\n    // normals of great circle clip planes from vertex angles\n    E0 = vec3(0,1,0); // why Y?  others use X or Z.\n    \n    // @mattz solved the linear system:\n    float cx = cos(A.x), sx = sin(A.x),\n          cy = cos(A.y), cz = cos(A.z);\n    E1 = vec3(0, -cx, sx); //vec3(E0.x, E0.yz * rot(A.x - pi)); //\n    vec2 Et = vec2(cy, (cz + cx * cy) / sx);\n    E2 = vec3(sqrt(1. - dot(Et, Et)), -Et);\n\n    // points from edges\n    P0 = split(E1, E2);\n    P1 = split(E2, E0);\n    P2 = split(E0, E1);\n\n    // we know the face center point!\n    N = normalize(P1);\n\n    // compute from vertices\n    L = dot(P2, N) * size;\n}\n\n/*\n@mattz helped me grok some stuff!\nI'm still using his spherical computation above\n\nsee\n\nWythoff construction http://shadertoy.com/view/ldXczX\nWythoff explorer http://shadertoy.com/view/Md3yRB\n*/\n\n// be very careful with negative signs here: (can produce strange stellations or break the mirroring)\n// I tried to straighten out the negative signs.\n// some of the signs are due to the orientation of edge clip planes.\n// TODO should just reformulate from fundamentals, if I can learn it well enough  \n    \n// I tried many variations before figuring his out:\n    //E2 = vec3(E1.xz * rot(A.y), E1.y).xzy; // ok\n    //E2 = vec3(E0.xy * rot(-A.y), E0.z); // seems only would work for right-angle tris such as octahedron\n    \n// see also @knighty Polyhedron again http://shadertoy.com/view/XlX3zB\n//  float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n//\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n// not even normalized!!!  wth?  why 0.75 when computing sine from cosine?!\n// didn't work for me\n\n// simply conditional reflect(), returns condition\nbool Flop(inout vec3 q, vec3 n)\n{\n    float d = dot(q, n);\n    bool f = d < 0.;\n    if (f) q -= 2. * d * n;\n    return f;\n}\n\n// can use q -= 2. * min(0., d) * n; avoid minor branch.\n// but need flip count for demo texturing!\n\nconst int nflips = 5; // 5 flips handles everything this toy shows\nvoid Mirror(inout vec3 q)\n{\n    for (int f = nflips; f-- > 0; ) {\n        Flop(q, E0);\n        Flop(q, E1);\n        Flop(q, E2);\n    }\n}\n/*\nvoid Mirror_mattz(inout vec3 q)\n{\n    Flop(q, E0); // mattz way - doesn't work for me\n    for (int f = nflips; f-- > 0; ) {\n        //Flop(q, E0);\n        Flop(q, E1);\n        Flop(q, E2);\n    }\n    Flop(q, E0); // mattz way\n}\n// idk if we need to do E0 every time; mattz doesn't...\n// knighty uses abs() and only one Flop, somehow, and it works.\nvoid Mirror_knighty(inout vec3 q)\n{\n    for (int f = nflips; f-- > 0; ) {\n        q.yz = abs(q.yz); //q.xz = abs(q.xz); //q.xy = abs(q.xy); // knighty way - doesn't work for me\n        //Flop(q, E0);\n        //Flop(q, E1);\n        Flop(q, E2);\n    }\n} \n//Mirror_knighty(q); //Mirror_mattz(q); //\n*/\n// just for showing the pattern:\nbool Parity(vec3 q)\n{\n    bool parity = false;\n    for (int f = nflips; f-- > 0; ) {\n        if (Flop(q, E0)) parity = !parity;\n        if (Flop(q, E1)) parity = !parity;\n        if (Flop(q, E2)) parity = !parity;\n    }\n    return parity;\n}\n\nfloat dshape(vec3 q)\n{\n    Mirror(q);\n    // all points around sphere have been \n    // reflected into the spherical triangle.\n    // just take plane distance\n    return dot(q, N) - L;\n}\n// TODO can measure edge, corner vert distances after folding\n\n// the SDF is bad and should feel bad\n// lacking the edge and corner voronoi regions,\n// those currently overestimate\n// so needs the .7 kludge \n// but toy works ok anyway with or without\nfloat dscene(vec3 q)\n{\n    return dshape(q); // * .7; //\n}\n\n //min(.., e + 3. - length(q) + dot(sin(q * 32.), vec3(1)) * .0002); // old bg container\n\n// looped tetrahedral\nvec3 gscene(vec3 q, float h)\n{\n    vec3 e = vec3(1,0,0), g = e.zzz;\n    for (int i = IZERO + 6; \n            i-- > 0;\n            g += dscene(q + h * e) * e, e = e.zxy)\n        if (i == 2) e = -e;\n    return .5 * g;\n}\n\n// cone marcher, returns coverage, sets q to best sample position\nfloat march(inout vec3 q, vec3 r, int n, float e, float tmax)\n{\n    vec3 m = q;\n    float t = 0., d = 1., od = 99., best = 1e5, tb = 0.;\n    for (int i = IZERO + n; \n         i-- > 0 && d > t * e && t < tmax;\n        ) \n    {\n         d = dscene(m);\n         if (d > od) // only if moving away\n         {\n             if (od < 2. * t * e)\n             if (od * tb < best * t) //d / t < best / tb)\n             if (best > .5 * tb * e) // use prior sample if it was > 50%\n             {\n                 best = od; tb = t - od;\n             }\n             // these shapes are convex, can early out\n             if (best < .5 * tb * e) \n             {\n                 q += tb * r;\n                 return clamp(2. - best / (tb * e), 0., 1.);\n             }\n         }\n         t += d;\n         m = t * r + q;\n         od = d;\n    }\n    float cov = 0.;\n    if (d > t * e && best < 2. * tb * e) \n    {\n        q += tb * r; \n        d = best; \n        cov = clamp(2. - d / (tb * e), 0., 1.); \n    }\n    else \n    {\n        q = m - d * r; // back off to match partial case\n        cov = float(t < tmax);\n    }\n    return cov;\n}\n\nfloat doRay(inout vec3 q, vec3 r, out vec3 n, out float cov)\n{\n    vec3 o = q;\n    cov = march(q, r, 96, .5 / iResolution.y, eyed + size);\n    float d = length(q - o),\n        precis = d * 1.5 / iResolution.y;\n    q -= 1.5 * precis * r; // back off even more for normal computation\n    // can't get clean normals for interior edges due to bad SDF\n    vec3 g = cov > 0. ? gscene(q, precis) : vec3(1);\n    n = normalize(g);\n    return d;\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    ComputeWythoff(); // init globals by Wythoff number\n    vec3 r = iResolution, n, f = vec3(0,0,1);\n    float t0 = .3 * sin(.1 * iTime), t1 = .05 * iTime;\n    if (iMouse.z > 0.)\n        t1 = -2. * pi * (abs(iMouse.x) - .5 * r.x) / r.x,\n        t0 = -.8 * pi * (abs(iMouse.y) - .5 * r.y) / r.y;\n    r = vec3(p - .5 * r.xy, min(r.x, r.y));\n    mat2 rx = rot(t0), ry = rot(t1);\n    r.zy *= rx; r.zx *= ry;\n    f.zy *= rx; f.zx *= ry;\n    r = normalize(r);\n    f = normalize(f);\n    vec3 hp = -eyed * f;\n    float cov;\n    float t = doRay(hp, r, n, cov);\n    bool bg = cov == 0.; //t > e + size;\n    o = vec4(1);\n    if (cov < 1.) {\n        vec3 c = textureLod(iChannel0, r, 0.).rgb; // env\n        c *= c;\n        o.rgb = c;\n    }\n    if (!bg) {\n        bool gparity = false;\n        vec3 mp = hp;\n        gparity = Parity(mp);\n        vec3 E = reflect(r, n),\n            c = textureLod(iChannel0, E, 1.).rgb; // mirror reflection\n        c *= c;\n        c *= mix(.5, 1., float(gparity));\n        c.b *= .3; // \"golden\"\n        o.rgb = mix(o.rgb, c, cov);\n    }\n    o = sqrt(o); // \"gamma\"\n}\n\n        //if (cov < 1.) cf = vec3(1,0,1); // debug coverage\n// the reflection can seem confusing.. unsure if I got it 100% right.\n //(bg ? 1. : -1.) * reflect(r, n); // visuals are confusing because I paint the background with reflection\n        //Mirror(mp, gparity); // / size; //float dunused = dscene(hp); // recompute parity side-effect at hit point\n        //o = vec4(n * .5 + .5,1);\n\n// TODO maybe 4 viewports, one for each platonic solid\n// TODO edge AA would be nice.\n// TODO fix edge/corner distances, the SDF overestimates a bit\n\n    //2,2,2); //3,2,2); // hacks that only made sense when I was confused\n// I got 2,2,2 to make an octahedron, makes sense...\n// easiest case though, and only because bad computation.\n// iirc 3,2,2 made a cube at one point.\n\n// angles sum total > pi on a unit sphere\n// unit octahedra has 8 spherical triangles with 90 degree corners\n// summing to 270 degrees (vs. 180 for flat triangle)\n\n// unused idea:\n// count edges, total, going around sphere:\n//  icosa and dodeca have 4 long, 4 short, and 4 medium\n//  octa has 4 long, 4 short OR 8 medium so short + long = 2*medium I guess, here\n//  tetra has 2 long, 2 short, and 2 medium\n// if I could solve that, could solve based on tau somehow.\n// but would need to know all those angles.\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcVfzh","date":"1733920532","viewed":84,"name":"Wythoff Platonic Solids","username":"spalmer","description":"investigating Wythoff construction technique for platonic solids","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["polyhedra","platonic","schwarz","wythoff"],"hasliked":0,"parentid":"md2cWy","parentname":"Platonic DOP"}}