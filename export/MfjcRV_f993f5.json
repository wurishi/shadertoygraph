{"ver":"0.1","info":{"id":"MfjcRV","date":"1725115257","viewed":53,"name":"Mirror balls on tiled ground","username":"TomCarbon","description":"Move the camera with the mouse :\n - x for the angle around the scene\n - y for the distance to the scene\n\nWIP!\nThere were better versions in the past iterations... it's \"work in progress\"!\nThat is to say, I'm breaking and fixing things round after round...","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tiledground","reflectiveball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime + 10.92;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n\n    vec3 ro = vec3(3.2, 1.6, 1.6);\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n    float fov = 0.9;\n\n    float ma = 1.84;\n    float md = 2.36;\n    if (iMouse.z > 0.5)\n    {\n        ma = (0.7 + (iMouse.x / iResolution.x)) * 6.28;\n        md = (1.2 - (iMouse.y / iResolution.y)) * 4.0;\n    }\n    else\n    {\n        ma = t;\n        md = 3.0 + 1.5 * cos(t);\n    }\n    ro.xz = md * vec2(cos(ma), sin(ma));\n\n\n    vec3 zz = normalize(lookAt - ro);\n    vec3 xx = cross(zz, vec3(0, 1, 0));\n    vec3 yy = cross(xx, zz);    \n    vec3 rd = normalize(uv.x * xx + uv.y * yy + fov * zz);\n\n    vec3 color;\n\n//#if 0\n//    if (uv.x < 0.)\n//    {\n    // new version (fixing in progress)\n//    color = getPixel(ro, rd);\n    vec3 overColor = getPixel(ro, rd);\n//#else\n//} else {\n    // old version\n    for (uint bounces = 0u; bounces < kMaxBounces; ++bounces)\n    {\n        vec2 hit;\n\n        float d = 0.0;\n        vec3 p;\n        for (uint i = 0u; i < kMaxSteps; ++i)\n        {\n            p = ro + d * rd;\n            hit = sdScene(p);\n            d += hit.distance;\n\n            if (hit.distance <= kMinSurface || d >= kMaxDist)\n                break;\n        }\n\n        vec3 diffuse = getEnvironmentColor(rd);\n        vec3 n = getNormal(p);\n\n        vec3 l = normalize(lightPos - p);\n        float diff = clamp(dot(n, l), 0.0, 1.0);\n\n        float shadowFactor = multiShadow(p, lightPos, lightSize);\n\n        vec3 viewDir = normalize(ro - p);\n        vec3 halfDir = normalize(l + viewDir);\n        float spec = clamp(pow(dot(n, halfDir), shininess), 0.0, 1.0);\n        vec3 specular = shadowFactor * spec * specularColor;\n\n        if (d > kMaxDist)\n        {\n            color = getEnvironmentColor(rd);\n            break;\n        }\n\n        diffuse = shadowFactor * diff * lightColor;\n\n        if (hit.object == kObjectPlane)\n        {\n            color = getTileColor(p) * diffuse + specular;\n            break;\n        }\n        else if (hit.object == kObjectSphere)\n        {\n            vec3 r = reflect(rd, n);\n            vec3 reflectionColor = getEnvironmentColor(r);\n\n            color = mix(reflectionColor, diffuse, 0.4) + specular;\n\n            ro = p + n * kMinSurface;\n            rd = r;\n        }\n    }\n    color += overColor;\n//    }\n//#endif\n\n    // gamma\n    color = pow(color, vec3(1.0 / 1.2));\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst uint kMaxBounces = 3u;\n\nconst uint kMaxSteps = 255u;\nconst float kMaxDist = 100.0;\nconst float kMinSurface = 0.001;\n\n\nconst vec3 lightPos = vec3(5.0, 6.0, 5.0);\nconst vec2 lightSize = vec2(2.0);\nconst vec3 lightColor = vec3(1.0, 0.9, 0.8);\n\nconst float shininess = 64.0;\nconst vec3 specularColor = vec3(1.0, 1.0, 1.0);\n\nconst uint kNumShadowSamples = 4u;\n\n\nconst float kObjectNone = 0.0;\nconst float kObjectSphere = 1.0;\nconst float kObjectPlane = 2.0;\n\n#define object x\n#define distance y\n\nfloat sdSphere(vec3 p, vec4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\nvec3 getTileColor(vec3 p)\n{\n    float checker = mod(floor(p.x) + floor(p.z), 2.0);\n    return vec3(checker);\n}\n\nvec3 getEnvironmentColor(vec3 dir)\n{\n    return mix(vec3(0.6, 0.7, 0.8), vec3(0.2, 0.3, 0.4), dir.y);\n}\n\n\nvec2 sdScene(vec3 p)\n{\n    float sd = p.y;\n    vec2 o = vec2(kObjectPlane, sd);\n\n    sd = sdSphere(p, vec4(0.0, 1.0, 0.0, 1.0));\n    if (sd < o.y)\n        o = vec2(kObjectSphere, sd);\n\n    sd = sdSphere(p, vec4(-1.5, 0.5, -1.0, 0.5));\n    if (sd < o.y)\n        o = vec2(kObjectSphere, sd);\n    sd = sdSphere(p, vec4(2.5, 1.0, -1.0, 1.0));\n    if (sd < o.y)\n        o = vec2(kObjectSphere, sd);\n\n    return o;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.01);\n\n    float d = sdScene(p).y;\n    vec3 n = d - vec3(\n        sdScene(p - e.yxx).y,\n        sdScene(p - e.xyx).y,\n        sdScene(p - e.xxy).y\n    );\n\n    return normalize(n);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float d = 0.0;\n    for (uint i = 0u; i < kMaxSteps; ++i)\n    {\n        vec3 p = ro + d * rd;\n\n        vec2 res = sdScene(p);\n        if (res.y < kMinSurface)\n            return 0.0;\n\n        d += res.y;\n        if (d > kMaxDist)\n            break;\n    }\n\n    return 1.0;\n}\n\nfloat multiShadow(vec3 p, vec3 lightPos, vec2 lightSize)\n{\n    float shadowFactor = 0.0;\n\n    for (uint i = 0u; i < kNumShadowSamples; ++i)\n    {\n        for (uint j = 0u; j < kNumShadowSamples; ++j)\n        {\n            vec2 offset = vec2(float(i) / float(kNumShadowSamples), float(j) / float(kNumShadowSamples)) - 0.5;\n            vec3 samplePos = lightPos + vec3(offset * lightSize, 0.0);\n            vec3 toLight = normalize(samplePos - p);\n            shadowFactor += shadow(p + getNormal(p) * kMinSurface, toLight);\n        }\n    }\n\n    return shadowFactor / float(kNumShadowSamples * kNumShadowSamples);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, float min, float max)\n{\n    float d = min;\n    for (uint i = 0u; i < kMaxSteps; ++i)\n    {\n        vec3 p = ro + d * rd;\n\n        vec2 hit = sdScene(p);\n        if (hit.distance <= kMinSurface)\n            return vec2(hit.object, d);\n\n        d += hit.distance;\n        if(d >= max)\n            break;\n    }\n    \n    return vec2(kObjectNone, d);\n}\n\nvec3 getPixel(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0);\n    vec3 diffuseColor = vec3(0);\n    for (uint bounces = 0u; bounces < kMaxBounces; ++bounces)\n    {\n        vec2 hit = rayMarch(ro, rd, 0.0, kMaxDist);\n\n        vec3 p = ro + hit.distance * rd;\n        vec3 n = getNormal(p);\n\n        vec3 l = normalize(lightPos - p);\n\n//        vec3 diffuseColor = getObjectColor(hit.object, p);\n        float diffuse = clamp(dot(n, l), 0.0, 1.0);\n\n        float shadowFactor = multiShadow(p, lightPos, lightSize);\n\n        vec3 viewDir = normalize(ro - p);\n        vec3 halfDir = normalize(l + viewDir);\n        float specular = clamp(pow(dot(n, halfDir), shininess), 0.0, 1.0);\n\n        if (hit.object == kObjectPlane)\n        {\n            diffuseColor += getTileColor(p);\n            break;\n        }\n        else if (hit.object == kObjectSphere)\n        {\n            vec3 r = reflect(rd, n);\n/*            vec3 reflectionColor = getEnvironmentColor(r);\n\n            diffuseColor = mix(reflectionColor, diffuseColor, 0.4);\n*/\n            // next reflection round\n            ro = p + n * kMinSurface;\n            rd = r;\n        }\n        else\n        {\n            diffuseColor += getEnvironmentColor(rd);\n            break;\n        }\n        \n//        color = mix(color, diffuseColor * diffuse + specularColor * specular, 0.8);               \n        color = diffuseColor * diffuse + specularColor * specular;\n    }\n    \n    return color;\n}\n","name":"Common","description":"","type":"common"}]}