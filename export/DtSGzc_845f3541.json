{"ver":"0.1","info":{"id":"DtSGzc","date":"1673602543","viewed":159,"name":"Magical Ice Cold Cavern","username":"deamonpog","description":"Ray casting into 3d random number generator\nJoin me travelling thorugh icy world, melting our way in....","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","effects","rng"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//MIT License Copyright (c) 2023 Chathura Jayalath\n\n// WIP\n\n// ACCURACY_THRESHOLD:\n// Increase this value for high performance\n// Decrease this value for high quality\n#define ACCURACY_THRESHOLD 0.01\n\n#define FOV       45.0\n#define FAR_CLIP  100.0\n#define NEAR_CLIP 0.1\n\n#define TIMER iTime * 0.1\n\n#define TAU 6.283185\n#define PI  3.141593\n\n// Sin and Cos function correction for low end devices\n#define SIN(x) (sin(mod(x,TAU)))\n#define COS(x) (cos(mod(x,TAU)))\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 fw;\n    vec3 up;\n    vec3 rt;\n    float scrDist;\n};\n\nCamera InitCamera(vec3 initPos);\nvoid yawCam(float angle, inout Camera cam);\nvoid pitchCam(float angle, inout Camera cam);\nvec3 GetPixelRay(Camera cam, vec2 uv);\n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat N31(vec3 p)\n{\n    return fract(SIN(p.x * 997.0 + p.y * 9011.0 + p.z * 20551.0) * 1051.0);\n}\n\nvec3 smoothedge3(vec3 p)\n{\n    return p * p * (3.0 - 2.0 * p);\n}\n\nfloat SmoothNoise31(vec3 uvw)\n{\n    vec3 col = vec3(0);\n    \n    vec3 luv = fract(uvw * 4.0);\n    luv = smoothedge3(luv);\n    vec3 id = floor(uvw * 4.0);\n    \n    float xdir1 = mix(N31(id + vec3(0,0,0)),\n                      N31(id + vec3(1,0,0)),\n                      luv.x );\n    float xdir2 = mix(N31(id + vec3(0,1,0)),\n                      N31(id + vec3(1,1,0)),\n                      luv.x );\n    float xydir1 = mix(xdir1, xdir2, luv.y);\n                      \n    float xdir3 = mix(N31(id + vec3(0,0,1)),\n                      N31(id + vec3(1,0,1)),\n                      luv.x );\n    float xdir4 = mix(N31(id + vec3(0,1,1)),\n                      N31(id + vec3(1,1,1)),\n                      luv.x );\n    float xydir2 = mix(xdir3, xdir4, luv.y);\n    \n    float xyzdir = mix(xydir1, xydir2, luv.z);\n    \n    return xyzdir;\n}\n\nfloat SmoothNoiseOctave31(vec3 uvw)\n{\n    float v = 2.0;\n    float col = SmoothNoise31(uvw * v * 2.0);\n    col += SmoothNoise31(uvw * v * 4.0) * 0.5;\n    col += SmoothNoise31(uvw * v * 8.0) * 0.25;\n    col += SmoothNoise31(uvw * v * 16.0) * 0.125;\n    \n    col /= 1.5;\n    return col;\n}\n\nfloat GetFieldValue(vec3 p)\n{\n    return SmoothNoise31(p);\n}\n\nvec3 GetNorm(vec3 p, float v)\n{\n    vec2 e = vec2(0, 0.0001);\n    vec3 norm = vec3(GetFieldValue(p + e.yxx),\n                     GetFieldValue(p + e.xyx),\n                     GetFieldValue(p + e.xxy));\n    return normalize(norm - v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    Camera cam = InitCamera(vec3(0, 0.8, 1));\n    yawCam(0.001 * SIN(TIMER), cam);\n    cam.pos += cam.fw * TIMER;\n    pitchCam(0.1 * SIN(0.05 + TIMER * 5.0), cam);\n    yawCam(0.1 * SIN(TIMER * 5.0), cam);\n    \n    vec3 rdir = GetPixelRay(cam, uv);\n    \n    float dt = ACCURACY_THRESHOLD;\n    vec3 pos;\n    float distT;\n    float value;\n    for(distT = dt; distT < FAR_CLIP; distT += dt)\n    {\n        pos = cam.pos + rdir * distT;\n        float v = GetFieldValue(pos);\n        if(0.7 < v && distT > NEAR_CLIP)\n        {\n            value = v;\n            break;\n        }\n    }\n    \n    vec3 norm = GetNorm(pos, value);\n    vec3 lightDir = normalize(vec3(0, 0.2, -1));\n    vec3 lightCol = vec3(0.9, 0.2, 0.1);\n    vec3 diffuse = lightCol * dot(norm, lightDir);\n    vec3 ambient = vec3(0.2) * length(norm);\n    vec3 halfVector = normalize(lightDir - rdir);\n    float NdotHv = saturate(dot(norm, halfVector));\n    vec3 specular = lightCol * pow(NdotHv, 100.0);\n    \n    vec3 col = (ambient + diffuse  + distT * value * pos.y) * vec3(0.7,0.86,0.98) + specular;\n\n    fragColor = vec4(col,1.0);\n}\n\nCamera InitCamera(vec3 p)\n{\n    vec3 f = vec3(0,0,1);\n    vec3 u = vec3(0,1,0);\n    vec3 r = vec3(1,0,0);\n    float sd = 0.5 / tan(FOV * PI / 180.0);\n    return Camera(p, f, u, r, sd);\n}\n\nvoid pitchCam(float a, inout Camera cam)\n{\n    float s = SIN(a), c = COS(a);\n    mat3 m = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    cam.fw = cam.fw * m;\n    cam.rt = cam.rt * m;\n    cam.up = cam.up * m;\n}\n\nvoid yawCam(float a, inout Camera cam)\n{\n    float s = SIN(a), c = COS(a);\n    mat3 m = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    cam.fw = cam.fw * m;\n    cam.rt = cam.rt * m;\n    cam.up = cam.up * m;\n}\n\nvec3 GetPixelRay(Camera cam, vec2 uv)\n{\n    vec3 pixelPosCS =  cam.fw * cam.scrDist + cam.up * uv.y + cam.rt * uv.x;\n    return normalize(pixelPosCS);\n}\n","name":"Image","description":"","type":"image"}]}