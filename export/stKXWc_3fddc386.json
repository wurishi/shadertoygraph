{"ver":"0.1","info":{"id":"stKXWc","date":"1641462999","viewed":182,"name":"Implicit curves rasterization 3","username":"Envy24","description":"Solution for problem in this shader: https://www.shadertoy.com/view/slVXWV\n\nOther solutions: \nhttps://www.shadertoy.com/view/7lVXDK\nhttps://www.shadertoy.com/view/slVSWV","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["curves","derivatives","dfdx","dfdy","function","plot","implicit","rasterization","fwidth","isocurves","patrial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                       iResolution\n#define AR                    ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define NZMY                  ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD           ( iMouse.z > 0.0 )\n\n#define XMIN     -2.0\n#define XMAX     2.0\n#define YMIN     -2.0\n#define YMAX     2.0\n\n//#define FUNCTION unit_circle          \n#define FUNCTION heart_curve\n//#define FUNCTION heart_curve2\n//#define FUNCTION devil_curve\n//#define FUNCTION electric_motor_curve\n\n//#define FUNCTION random_curve_0006\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float xStep = (XMAX - XMIN) / (R.x - 1.0);\n    float yStep = (YMAX - YMIN) / (R.y - 1.0);\n\n    float mouse = \n        LMB_IS_HOLD == true ?\n            NZMY :\n            0.0;\n    \n    float dist = // evaluate function at (x, y)\n        mouse + FUNCTION(\n            (XMIN + floor(SC.x) * xStep) * AR,\n            YMIN + floor(SC.y) * yStep);\n   \n    // dFdx emulation\n    float rdist = // evaluate function at (x + 1, y)\n        mouse + FUNCTION(\n            (XMIN + floor(SC.x + 1.0) * xStep) * AR,\n            YMIN + floor(SC.y) * yStep);\n    float dx = rdist - dist;\n    \n    // dFdy emulation\n    float bdist = // evaluate function at (x, y + 1)\n        mouse + FUNCTION(\n            (XMIN + floor(SC.x) * xStep) * AR,\n            YMIN + floor(SC.y - 1.0) * yStep);\n    float dy = bdist - dist;\n\n    // fwidth emulation\n    float //fWidth = abs(dx) + abs(dy);     // L1-norm, same as fwidth\n          fWidth = sqrt(dx*dx + dy*dy);     // L2-norm\n          //fWidth = max(abs(dx), abs(dy)); // Linf-norm\n    \n    float intensity = abs(dist)/fWidth;\n    \n    //float intensity = abs(dist)/fwidth(dist);                       // native\n    //float intensity = abs(dist)/(abs(dFdx(dist))+abs(dFdy(dist)));  // native fwidth, but with dFdx and dFdy\n    //float intensity = abs(fract(dist)-0.5)/fwidth(dist);            // source: https://www.shadertoy.com/view/ssXXWN  isocurves      \n    //float intensity = abs(dist)/(fWidth+0.1);                       // looks interesting\n    //float intensity = abs(fract(dist)-0.5)/fWidth*0.01;             // and this\n    //float intensity = abs(dist)/fWidth*0.01;                        // and this too\n       \n    O = vec4(intensity);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* xRange=[-1.0; 1.0] yRange=[-1.0; 1.0] */\nfloat unit_circle( float x, float y )\n{\n    return x*x + y*y - 1.0;\n}\n\n/* source: https://www.desmos.com/calculator/pi5ofejgt0?lang=ru\n   xRange=[-2.0; 2.0] yRange=[-2.0; 2.0]    */\nfloat heart_curve(float x, float y)\n{\n    float term = x*x + y*y - 1.0;\n    return term * term * term - x*x * y*y*y;\n}\n\n/* xRange=[-1.5; 1.5] yRange=[-1.5; 2.0] */\nfloat heart_curve2(float x, float y)\n{\n    float term = y - pow(x * x, 1.0 / 3.0);\n    return x * x + term * term - 1.0;\n}\n\n/* source: https://mathworld.wolfram.com/DevilsCurve.html\n   xRange=[-2.0; 2.0] yRange=[-2.0; 2.0]     */\nfloat devil_curve(float x, float y)\n{\n    return y * y * (y * y - 1.0) - x * x * (x * x - 2.0);\n}\n\n/* source: https://mathworld.wolfram.com/DevilsCurve.html \n   xRange=[-12.5; 12.5] yRange=[-12.5; 12.5]     */\nfloat electric_motor_curve(float x, float y)\n{\n    return y * y * (y * y - 100.0) - x * x * (x * x - 96.0);\n}\n\n/* xRange=[-2.0; 2.0] yRange=[-2.0; 2.0] */\nfloat random_curve_0000(float x, float y)\n{\n    return sin(x*x + y*y)-y*y;\n}\n\n/* xRange=[-4.0; 4.0] yRange=[-4.0; 4.0] */\nfloat random_curve_0001(float x, float y)\n{\n    float xx = x * x;\n\n    return xx * sin(xx + xx) - y*y;\n}\n\n/* xRange=[-2.0; 2.0] yRange=[-2.0; 2.0] */\nfloat random_curve_0002(float x, float y)\n{\n    return x * x * sin(32.0 * (x - y)) * tan(x + y) - y * y * y;\n}\n\n/* source: https://www.desmos.com/calculator/pi5ofejgt0?lang=ru\n   xRange=[-40.0; 40.0] yRange=[-40.0; 40.0]    */\nfloat random_curve_0003(float x, float y)\n{\n    return x * x * x + y * y - 6.0 * x * y;\n}\n\n/* xRange=[-10.0; 10.0] yRange=[-10.0; 10.0] */\nfloat random_curve_0004(float x, float y)\n{\n    return sin(0.5 * (x*x - y*y)) + cos(0.5 * (y*y - x*x));\n}\n\n/* xRange=[-10.0; 10.0] yRange=[-10.0; 10.0] */\nfloat random_curve_0005(float x, float y)\n{\n    return (x*x - y*y*y) -(y*y - x*x*x)*(y*y - x*x*x);\n}\n\n/* xRange=[-2.0; 2.0] yRange=[-2.0; 2.0] */\nfloat random_curve_0006(float x, float y)\n{\n    return (x*x - x*y*x) -(y*y - x*y*x)/(y*y + y*x*x);\n}","name":"Common","description":"","type":"common"}]}