{"ver":"0.1","info":{"id":"wlBcWt","date":"1595698609","viewed":171,"name":"raymarching simplex noise","username":"CoolerZ","description":"Raymarching throuhg simplex noise in 3d.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","simplex","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBased on http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\nThe pdf gives details and code for both perlin and simplex noise in Java.\n*/\n#define R2 .6\n#define A .5\n#define F 1.\n\nconst vec3[] grad = vec3[](\n    vec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\n\tvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\n\tvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1)\n);\n\nconst int perm[] = int[](151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180);\n\nint hash(ivec3 p)\n{\n    return perm[p.x+perm[p.y+perm[p.z]]]%12;\n}\n\nvec3 skew(vec3 p)\n{\n    return p+(p.x+p.y+p.z)/3.;\n}\n\nvec3 unskew(vec3 p)\n{\n    return p-(p.x+p.y+p.z)/6.;\n}\n\nfloat simplex3d(vec3 xyz)\n{\n    vec3 ijk = floor(skew(xyz));\n    vec3 XYZ0 = unskew(ijk);\n\n    vec3 xyz0 = xyz - XYZ0;\n\n    // vec3 ijk1, ijk2;\n\n    vec3 ijk1 =\n        float(xyz0.x >= xyz0.y && xyz0.x >= xyz0.z)*vec3(1,0,0) +\n        float(xyz0.y >= xyz0.x && xyz0.y >= xyz0.z)*vec3(0,1,0) +\n        float(xyz0.z >= xyz0.x && xyz0.z >= xyz0.y)*vec3(0,0,1);\n\n    vec3 ijk2 =\n        float(xyz0.x < xyz0.y && xyz0.x < xyz0.z)*vec3(0,1,1) +\n        float(xyz0.y < xyz0.x && xyz0.y < xyz0.z)*vec3(1,0,1) +\n        float(xyz0.z < xyz0.x && xyz0.z < xyz0.y)*vec3(1,1,0);\n\n    /*\n    if(xyz0.x >= xyz0.y)\n    {\n        if(xyz0.y >= xyz0.z)\n        {\n            ijk1 = vec3(1,0,0);\n            ijk2 = vec3(1,1,0);\n        }\n        else if(xyz0.x >= xyz0.z)\n        {\n            ijk1 = vec3(1,0,0);\n            ijk2 = vec3(1,0,1);\n        }\n        else\n        {\n            ijk1 = vec3(0,0,1);\n            ijk2 = vec3(1,0,1);\n        }\n    }\n    else\n    {\n        if(xyz0.y < xyz0.z)\n        {\n            ijk1 = vec3(0,0,1);\n            ijk2 = vec3(0,1,1);\n        }\n        else if(xyz0.x < xyz0.z)\n        {\n            ijk1 = vec3(0,1,0);\n            ijk2 = vec3(0,1,1);\n        }\n        else\n        {\n            ijk1 = vec3(0,1,0);\n            ijk2 = vec3(1,1,0);\n        }\n    }\n\t*/\n\n    vec3 xyz1 = xyz0 - unskew(ijk1);\n    vec3 xyz2 = xyz0 - unskew(ijk2);\n    vec3 xyz3 = xyz0 - unskew(vec3(1,1,1));\n\n   \tivec3 IJK = ivec3(ijk) & 0xFF;\n    int gi0 = hash(IJK);\n    int gi1 = hash(IJK + ivec3(ijk1));\n    int gi2 = hash(IJK + ivec3(ijk2));\n    int gi3 = hash(IJK + ivec3(1,1,1));\n\n    float n0 = pow(max(R2 - dot(xyz0, xyz0), 0.), 4.)*dot(grad[gi0], xyz0);\n    float n1 = pow(max(R2 - dot(xyz1, xyz1), 0.), 4.)*dot(grad[gi1], xyz1);\n    float n2 = pow(max(R2 - dot(xyz2, xyz2), 0.), 4.)*dot(grad[gi2], xyz2);\n    float n3 = pow(max(R2 - dot(xyz3, xyz3), 0.), 4.)*dot(grad[gi3], xyz3);\n\n    return 32.*(n0+n1+n2+n3);\n}\n\nfloat noise(vec3 pos)\n{\n    float x0 = A*simplex3d(pos*F);\n    float x1 = A*A*simplex3d(pos*F*2.);\n    float x2 = A*A*A*simplex3d(pos*F*4.);\n    float x3 = A*A*A*A*simplex3d(pos*F*8.);\n    float x4 = A*A*A*A*A*simplex3d(pos*F*16.);\n\n    return 4.*(x0 + x1 + x2 + x3 + x4);\n}\n\n#define MAX_ITERS 100\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv *= 4.;\n    // vec3 camera_pos = vec3(2.*cos(iTime), 0., 2.*sin(iTime));\n    // vec3 camera_pos += vec3(0., 0., 2.+sin(iTime));\n    // vec3 camera_lookat = vec3(0.);\n    vec3 camera_pos = vec3(0., 0., -iTime);\n    vec3 camera_lookat = camera_pos + vec3(0., 0., -1.);\n    vec3 camera_forward = normalize(camera_lookat - camera_pos);\n    vec3 world_up = vec3(0., 1., 0.);\n    vec3 camera_right = normalize(cross(camera_forward, world_up));\n    vec3 camera_up = normalize(cross(camera_right, camera_forward));\n    float focal_dist = 1.;\n    vec3 pixel_pos = camera_pos + focal_dist*camera_forward + uv.x*camera_right + uv.y*camera_up;\n\n    vec3 ray_o = camera_pos;// pixel_pos;\n    vec3 ray_d = normalize(pixel_pos - camera_pos);\n\n    vec3 acc = vec3(0.);\n    vec3 d = vec3(0.);\n\n    for(int i=0; i<MAX_ITERS; i++)\n    {\n        acc.x += noise(ray_o + d.x*ray_d);\n        acc.y += noise(ray_o + d.y*ray_d);\n        acc.z += noise(ray_o + d.z*ray_d);\n        d += vec3(0.01, 0.02, 0.04);\n        if(acc.x > 100.)break;\n    }\n\n    // vec3 col = vec3(simplex3d(vec3(uv, iTime)));\n    vec3 col = vec3(acc*.01);\n    // vec3 col = pow(acc*.05, vec3(4.));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}