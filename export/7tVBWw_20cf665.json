{"ver":"0.1","info":{"id":"7tVBWw","date":"1727794657","viewed":177,"name":"Blocks Symmetric 3D","username":"spalmer","description":"Trying bricks on arbitrary mortar shapes.\nControlled by Mouse+Arrows+PgUp/Dn+WASD+C+Space.\nG toggles gravity & fly/walk modes.","likes":14,"published":1,"flags":48,"usePreview":1,"tags":["collision","raymarch","camera","pattern","brick","hypertexture","detail","walk","fly"],"hasliked":0,"parentid":"wlfcz2","parentname":"Walk Camera"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://shadertoy.com/view/7tVBWw\n// 3d version of http://shadertoy.com/view/slVfWD\n// Fork of Walk Camera at http://shadertoy.com/view/wlfcz2\n// Fork of Fly Camera at http://shadertoy.com/view/tdsfR4\n// example bonding patterns to try to make:  http://wikipedia.org/wiki/Brickwork\n\n// made back a year or two ago, got stuck debugging some artifacts and slowdowns,\n// just now got it working well enough to show anybody.  :D\n// perhaps others can assist working out remaining kinks.\n\n// I did other Brickwork Details, but this one tries to prevent partial bricks\n// while keeping bricks placed only near the general arbitrary shape,\n// using a more detail-object-oriented approach somewhat like Detail Spheres.\n\n// some common terminology I should adopt for this:\n// for description purposes I use H, W, L to mean height, width, length\n// respectively with H smallest and L longest edge dimensions.\n// faces: header, stretcher, bed  are the  WxH, LxH, and WxL sides respectively\n// header, stretcher, soldier, sailor, rowlock, shiner refer to which way\n// bricks are oriented with regard to the exposed wall face.\n// a bat is a brick that has been cut down its length in a certain proportion.\n// so a half bat is half a brick.\n// there are also other bizarro ways to cut bricks, I won't delve into.\n// A leaf is a half-thick sort of quasi-wall which only bonds in\n// 2 dimensions; a one-brick-thick wall consists of two interbonded\n// leafs and is as thick total as the length of a brick.  Practically\n// all load-bearing or self-standing brickwork of any complexity\n// is built bonded in some fashion where the two 'leaf' faces\n// (and any interior bricks for really thick walls) are\n// intertwined together periodically in some fashion.\n// There are many different styles.\n// long story short:  visit the Wikipedia page and be amazed\n// at the variety and complexity of brickwork engineering.\n// Leaf exposed faces and interior faces that aren't bonded,\n// are the only places you would typically encounter\n// mortar perpends that are directly atop one another,\n// otherwise they usually strive to incorporate some overlap\n// between courses ('layers' stacked upwards).  \n// Often see more unbonded courses down low, and\n// more frequent bonded courses up high, where lateral\n// peeling strain forces seem more problematic.\n// Such overlap frustrates my efforts to find 'realistic'\n// brickwork patterns that don't have such offsets,\n// or other custom fitting deviations from some global pattern.\n// Or even designs (bonds) that don't involve cutting bricks.\n// Like, any realistic 'general' pattern would result in \n// some faces needing partially-cut-away bricks.\n// In fact, the most fundamental 'brick unit' for my grid tiling\n// purposes may be like a quarter-brick or something even smaller.\n\n// I'm going with half-brick (half-bat?) units presently,\n// with the blocks having equal W and H dimensions\n// L = 2 * W = 2 * H\n\nconst float\n    fogdensity = .002,\n    maxdepth = 6e3, //1e2 //3.4e38 //8.5e4 //\n    shfalloff = 2., //.5 // exponent of curve\n    shd = 10., //8. //4. //16. //24. // soft shadow trace distance\n    sc = 3.2,  // soft shadow crispness\n    sfuzz = .0, //.05 // HACK fade contribution with scan range - HACK for penumbra (not mixed correctly though, so doesn't really work well)\n    aod = .12, // ao distance - looks pretty bad w 1 sample if much larger, but should at least be as big as the mortar gaps\n    ambient = .5, // balance between ambient and direct light\n    nitebrite = .06, // how dark the lighting gets at night, essentially night time ambient light level\n    lfloor = .02; // lighting floor, limits how deep shadows can get, fake global ambient\n \n\nconst vec3\n    csun = vec3( 1., .95, .79), // light color\n    csky = vec3(.11, .33, .99); // fake, gets dimmed by sun angle though\n \n\nconst int marchsteps = 96; //72; //64; //128; //\n\nconst int shadowsteps = 12; //24; //32; //16; //8; //\n\nvec3 sunDir = vec3(0,.86,.5); // maybe animated in setupTime\n\n// compute material (albedo for now) from id\nvec4 Material(int i, vec3 p, vec3 n, float d)\n{\n    float tscale = 96.;\n    vec4 a;\n    vec3 t = abs(sin(tscale * p + .25 * tau));\n    float f = dot(1. - n * n, t) // triplanar texture\n          * exp2(-4. * tscale / iResolution.y * d) * .25 // distance fade\n          + .5,\n        e = .1*f; // don't want any black components, desaturate a bit\n    switch (i) {\n        default:\n        case mSky:   a = vec4(e,e,e,0); break;\n        case mGray:  a = vec4(f,.9*f,.8*f,1); break;\n        //case mRed:   a = vec4(f,e,e,1); break;\n        case mGreen: a = vec4(e,.7*f,e,1); break;\n        //case mBlue:  a = vec4(e,e,f,1); break;\n        case mBrown: a = vec4(.7*f,.5*f,.3*f,16); break;\n    }\n    return a;\n}\n         \nfloat Shadow(vec3 p, vec3 n, vec3 l, float hd, float d, float rnd, int ssteps)\n{\n    float nl = max(0., dot(n, l)),\n        ao = /*sqrt*/(clamp((Scene(p + n * aod).d - hd) / aod, 0., 1.));\n    // FIXME the ambient leaks in corners\n    if (nl > 1e-4) {\n    \tvec3 sht = sunDir * shd,\n    \t    hp = p + n * .002; // self-shadow bias hit position\n        int iters = max(1, int(rnd + float(ssteps) / (1.+.002*d)));\n        float sh = 1.; // min shadow factor found so far\n        for (int i = iters; i-- > 0; ) {\n    \t\tfloat f = (float(i) + 1.) / float(iters),\n    \t\t// must distribute the samples nonlinearly\n\t\t\t// to support long shadow trace distances.\n\t\t\t// need more samples close to the receiver.\n\t\t\t    ff = f * f,\n\t\t\t    v = max((Scene(p + sht * ff).d - hd + sfuzz * f) * sc / shd / nl / ff, 0.);\n\t\t\tsh = min(sh, v); //sh = min(sh, v * (2.-f)); //sh *= mix(v, 1., f); //sh *= v; //\n        }\n        // hoisted sqrt and part of clamp out of loop\n        sh = /*sqrt*/(min(sh, 1.));\n        sh = pow(sh, shfalloff);\n\t    nl *= sh; // fake soft shadow attenuates direct lighting\n    }\n    float ah = mix(n.y, 1., .5) * ambient; // hemisphere ambient\n    nl *= 1. - ambient; // leave room for ambient factor\n    nl += ah * ao; // hemi ambient only where not occluded\n    nl = clamp(nl, 0., 1.);\n    // must have some minimum lighting floor to prevent harsh black ao in shadows\n    nl = mix(nl, 1., lfloor); // after clamping\n    return nl;\n}\n\nvec3 Light(int m, vec3 p, vec3 v, float d, float rnd)\n{\n    float h = 3e-4 * (d + 1.), //2e-3 * clamp(d, .01, 100.) //\n        hd;\n    vec3 n = SceneNormal(p, h, hd, IZERO);\n    vec4 mat = Material(m, p, n, d);\n    vec3 albedo = mat.rgb,\n        c = albedo;\n    float nl = Shadow(p, n, sunDir, hd, d, rnd, shadowsteps + IZERO),\n        fogscale = fogdensity, // / dmax * 8.5e4; // TODO scale by dmax somehow?\n        fexp = exp2(-fogscale * d),\n        specp = mat.a,\n        nv = dot(-v, sunDir),\n    //  nlb = dot(n, sunDir),\n        nh = dot(n, normalize(sunDir + v));\n    c *= nl * mix(sunDir.y, 1., .5 + .5 * nitebrite);\n    if (m != mSky)\n        c += max(0., nl) * .25 * .038 * pow(max(0., nh), specp) * specp;\n    vec3 cfog = (csky // fake optical depth for atmo, fake sky coloration, inscatter color\n        + (1. - fexp) * .7 * pow(clamp(1. - abs(v.y), 0., 1.), 8.) // fake all the things!  distant horizon fog\n        ) * mix(sunDir.y, 1., .5 + .25 * nitebrite)\n        + .87 * pow(max(0., nv * .5 + .5), 16.); // fake mie, sun halo\n    c = mix(cfog, c, fexp)*csun; // simple fog Beer's law (not spectral, extinction&inscatter fused)\n    c = clamp(c, 0., specp + 1.);\n    return c;\n}\n\nvec3 Render(vec3 ro, vec3 rd, float rnd, out float depth)\n{\n    float thresh = 2./iResolution.y; // tuned for perf, not quality\n    Marched mr = March(ro, rd, thresh, maxdepth, marchsteps + IZERO);\n    float hd = Scene(mr.t * rd + ro).d; // distance at hit point\n    Rescue(mr, ro, rd, hd, maxdepth); // HACK\n    float t = mr.t; // trace depth to first hit\n    int m = mr.m;\n    vec3 hp = ro + rd * t,\n        c = Light(m, hp, -rd, t, rnd);\n    //c *= n * .5 + .5; // DEBUG hit normal\n    depth = mr.t;\n    \n    if (m == mSky && rd.y < 0. && t < maxdepth) \n        c = vec3(1,0,0);\n    return c;\n}\n\n// vogel disc based super sampler\n// handles depth of field, blur, antialiasing effects\nvec3 RenderSS(vec3 ro, vec3 evel, vec2 q, mat3 cam, float hfovy,\n       int supersamples, float focuscos, float focaldepth,\n       float rnd)\n{\n\tconst float phi = .5*(sqrt(5.) + 1.),\n        temporal = 0., //12. // temporal jitter animation rate?\n        ssgamma = .45; // really does help!\n\tvec3 c;// = vec3(0);\n    float s = sqrt(max(0., 1. - focuscos*focuscos)),\n        tot; // = 0.;\n\tfor (int i = supersamples; --i >= 0; ) {\n\t\tfloat f = (float(i) + .5) / float(supersamples), //float(i) / (float(supersamples) - .5) //\n\t\t    a = phi * tau * (f + rnd + temporal*fract(iTime)),\n\t\t    omff = 1., //exp2(-4. * f * s) //1.-f*f //sqrt(f) //\n            od;\n\t\tvec2 vogeldisc = sin(a + vec2(.25*tau, 0)) * sqrt(f) * s;\n\t\tvec3 vd = normalize(vec3(q + vogeldisc, 1. / tan(hfovy))),\n\t\t    rd = normalize(cam * vd), // view ray\n\t\t    vj = cam * vec3(vogeldisc,0), // vogel disc jitter in world space\n\t\t    vp = ro - evel * f * iTimeDelta - vj * (1. * focaldepth),\n\t\t    rc = Render(vp, rd, fract(rnd + f), od);\n        rc = pow(rc, vec3(ssgamma));\n\t\tc.rgb += rc * omff; \n        tot += omff;\n\t} // may even want to blend these *after* gamma correction\n    c /= tot;\n    c = pow(c, vec3(1./ssgamma));\n\treturn c;\n}\n/*\n    // SDF debugging overlay\nvec4 gDebug = vec4(0);\nvec3 gDebugAt;\n\n    vec3 rd = cam[2], ok;\n    gDebugAt = ro + .5 * rd + .4 * vec3(q,0).xzy;\n    //vec3 rr = Render(ro, rd, .5, ok);\n    Hit hr = Scene(gDebugAt);\n    //if (hr.d <= 1./iResolution.y)\n    //    gDebug.r += .5;\n    gDebug.a = step(q.x, 0.); //q.x < 0.;\n    if (q.x < 0.) //all(lessThan(q, vec2(0)))\n        gDebug.rgb = (hr.d < 0. ? vec3(1.,.8,.5) : vec3(.5,.8,1.)) * (cos(hr.d*iResolution.y/2.)*.45+.55);\n    if (hr.d > 0.) { // I only really care about the outside\n        float nd;\n        vec3 sn = SceneNormal(gDebugAt, .012, nd, IZERO);\n        Hit hr2 = Scene(gDebugAt - normalize(sn * vec3(1,1e-9,1)) * hr.d);\n        gDebug.b += max( hr2.d, 0.) * 5.; // underestimated = ok\n        gDebug.r += max(-hr2.d, 0.) * 5.; // overestimated = bad\n    }\n    if (isnan(hr.d)) gDebug.rgb = vec3(1,0,1);\n    if (isinf(hr.d)) gDebug.rgb = vec3(1,1,0);\n    if (isinf(hr.d) && hr.d < 0.) gDebug.rgb = vec3(1,0,0); // OMG NO\n    c = mix(c, gDebug.rgb, gDebug.a);\n    //c += gDebug.rgb;\n*/\n\nvoid SetupTime(float t)\n{\n    time = t; // enable for animation of brickwork (which causes problems I should fix)\n\t//float sunangle = .9; //.1*time; //\n\t//sunDir = normalize(vec3(.2,1,1)*sin(vec3(sunangle)+vec3(0,0,.25*tau))); //vec3(.1, .9,.2)); //\n}\n\n// maybe should think of a better idea, but it's multipurpose DoF and SSAA and temporal motion blur\n// so at least we get some mileage out of the extra work done tracing and lighting the scene multiple times\nconst int SSAA = 1; //2; //3; //4; // how strong is your GPU?\n\nvec3 Draw(vec2 p, float rnd)\n{\n\tState state;\n\tvec2 R = iResolution.xy;\n\tivec2 i = ivec2(p);\n\tLoadState(state, BufA, ivec2(R));\n    SetupTime(iTime);\n\tvec2 q = (p + p - R) / R.y;\n\tmat3 view = Camera(state.eyeaim);\n\tfloat hfovy = tau/14., //radians(30.) //\n\t    blur = .4, //1.4, // pixels ??!\n\t    foclen = 1.,\n\t    focus = cos(hfovy * blur/iResolution.y) //.99998 //\n\t    ;\n\tint ss = SSAA + IZERO;\n    // attempting to scale by resolution,\n    // automatically reducing samples as needed.\n    // only smaller windows will get the full count.\n    //ss = max(1, int(float(ss) * min(1., 720. / R.y) + .5));\n\tss = max(ss, 1);\n\t//if (iTimeDelta >= .034) ss = 1;\n    float od;\n//    return Render(state.eyepos, normalize(view * vec3(q, 1./sin(hfovy))), rnd, od); // No SSAA\n\treturn RenderSS(state.eyepos, state.eyevel, q, view,\n\t   hfovy, ss, focus, foclen, rnd);\n}\n\n#define BluNoiz iChannel3\n#define BNzRes  iChannelResolution[3].xy\n\nfloat rnoise(vec2 p)\n{\n\treturn fetch(BluNoiz, ivec2(p) & ivec2(BNzRes-1.)).x; // blue noise is great\n    // TODO needs animated\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    float rnd = rnoise(p);\n\tvec3 c = Draw(p, rnd);\n\tc = pow(c, vec3(.4545)); // to approx sRGB gamut\n\tc += exp2(-8.) * (rnd - .5); // dither\n\to = vec4(c, 1);\n}\n\n//\tvec4 data = fetch(BufA, ivec2(p)); c = data.rgb; // + data.a; // DEBUG show buffer A\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// forked from http://shadertoy.com/view/slVfWD\n// and http://shadertoy.com/view/wlfcz2\n// see http://shadertoy.com/view/7ttfWf where much of this framework started out\n// but split off since this doesn't involve any hashes or colorization or much of the complexity\n\n// enable gravity feature\n#define WALK 1\n// enable antigravity feature\n#define FLY  1\n// camera fixed if neither is enabled\n#define COLLISION 1\n\n\n#define IZERO min(iFrame, 0)\n\n\nconst float tau = radians(360.); //2. * acos(-1.); //6.28318531; //\n\n// cos,sin of full turns angle\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y,\n                cs.y, cs.x);\n}\n\n// Rodrigues' formula rotation by \n// arbitrary unit axis and radian angle\nvec3 prot(vec3 p, vec3 axis, float angle) \n{\n    float c = cos(angle), s = sin(angle);\n    return c * p\n        + (1.-c) * dot(p, axis) * axis\n        + s * cross(p, axis);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nbool isodd(float f)\n{\n    return fract(.5 * /*floor*/(f)) >= .5;\n}\n// checkerboard\nbool isodd(vec2 f)\n{\n//    f = floor(f); return (int(f.x+f.y)&1) != 0;\n    return fract(.5*(floor(f.x) + floor(f.y))) >= .5;\n}\n// 3D checkerboard\nbool isodd(vec3 f)\n{\n//    f = floor(f); return (int(f.x+f.y+f.z)&1) != 0;\n    return fract(.5*(floor(f.x) + floor(f.y) + floor(f.z))) >= .5;\n}\n/*\nfloat cellId(inout vec3 k)\n{\n    k = floor(k);\n    return k.z + 67. * k.y + 123. * k.x; // 'unique' linear id, runs bottom to top, left to right\n    // resulting id is even if the cell is even, and odd if the cell is odd.. I think!\n}\n*/\nfloat smin(float a, float b, float k)\n{\n\tfloat h = a - b;\n    return .5 * (a + b - sqrt(h * h + k));\n}\n// sqrt version is apparently best\nfloat smax(float a, float b, float k)\n{\n\treturn -smin(-a, -b, k);\n}\n\nfloat dsphere(vec3 q, float r) // r is radius\n{\n    return length(q) - r;\n}\n// iq approach; e is box half-extent\nfloat dbox(vec3 q, vec3 e)\n{\n    q = abs(q) - e;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\n/*\nfloat dbox(vec3 s, vec3 poof)\n{\n    vec3 a = abs(s) - poof;\n\t//return all(lessThan(q, vec3(0))) \n    //    ? max(max(q.x,q.y),q.z)\n    //    : length(max(q, 0.));\n    //return min(0., max(q.x, max(q.y, q.z))) + length(max(q, 0.)); // iq way\n    //return all(lessThan(a, vec3(0))) ? max(a.x, max(a.y, a.z)) : length(max(a,vec3(0)));\n    return min(max(a.x, max(a.y, a.z)), 0.) + length(max(a, vec3(0)));\n}\n*/\n\nfloat hash(vec3 q)\n{\n    return fract(dot(q, q.yzx * (sqrt(5.) - q.zyx)));\n}\n\nconst float\n// FIXME somehow handles bwidth == 1.0 or bwidth == 2.0\n// but FAILS for almost any bwidth in between, such as 1.5\n    bwidth = 2.,\n    fillet = .1,\n    mortar = .02,\n    mdepth = .025,\n    blayerthick = .471, // room between mortar and LOD boundary where bricks may appear\n    smth = 3e-4; // roundness argument to smin, smax\n// smth seems to botch the SDF if smin or smax used\n    \nfloat halfblock(vec3 q, vec3 t)\n{\n    //return dbox(q, t - fillet - mortar) - fillet;\n    float d = dbox(q + vec3(fillet+mortar,0,0), t - fillet - mortar + vec3(fillet+mortar,0,0)) - fillet;\n    //max(q.x - .5, d); // FIXME CSG botches the SDF a little\n    return d;\n}\n\nfloat block(vec3 q, vec3 t)\n{\n    return dbox(q, t - fillet - mortar) - fillet;\n    //vec3 k = floor(q), f = q - k,\n    // d3 = f - t;\n    //float d = dbox(d3, vec3(.9*w,w,.9*w));\n    //return d - .125;\n}\n\n/*\nfloat cell1(float q)\n{\n    return fract(q) - .5;\n}\n\nvec2 cell2(vec2 q, vec2 t)\n{\n    if (isodd(q.y + t)) q.x += .5;\n    return vec2(cell1(q.x), cell1(q.y));\n}\n// currently not actually used by blocksSparse\nvec3 cell3(vec3 q, vec3 t)\n{\n    if (isodd(q.z + t)) q.y += .5;\n    if (isodd(q.y + t)) q.x += .25;\n    return vec3(cell1(q.x), cell1(q.y), cell1(q.z));\n}\n\nfloat cell(vec3 q, vec3 t)\n{\n    vec3 d3 = cell3(q, t);\n    return cornerize(d3);\n}\n*/\n\n// developed at March 3D http://shadertoy.com/view/tlGXDK\n// it's like an infinite brick tile intended as a CSG mask for some other SDF\n/*float dbrickwork(vec3 q)\n{\n    const float s = 12.;\n    q *= s;\n    q *= .5;\n    q = fract(q) - .5;\n    if (q.y > 0.) q.xz = q.zx;\n    q.z += .25 * (2. * floor(2. * q.x) + floor(2. * q.y));\n    q.z = fract(q.z) - .5;\n    //q.xy = abs(q.xy);\n    q *= 2.;\n    q.xy = fract(q.xy) - .5;\n    float d = (dBox(q, vec3(.5,.5,1) - .03) - .01) / s;\n    return d;\n}*/\n// TODO what I want to do instead is use that technique\n// to simply locate the center of a block\n// and/or compute its size (rotation too complicated, just stretch)\n// idk, I could do other layered rotated tilings\n// that one could be refactored, in fact.\n// locates the brick q is inside\n// then just put a roundbox or whatever there.\n// assumed q is already scaled to the scale of the bricks\n// where a brick is 1.0 unit long.\n/*\n// TODO want to move this into the blocksSparse* functions\n// or, preferably, make them use this exclusively\n// or have this return enough information that they\n// might handle the stacking offsets and rotations there\n// unlikely!  Those were originally supposed to query this\n// for each brick, I was just trying to optimize there\n// but if I'm rotating bricks etc. then that leads to confusion\n// this is all so complicated anyway by now I should go back to 2D\n// and find a way to do it with rotated half-bricks instead\n// then each cell could contain an entire half-brick,\n// much less confusing than what I have now.  Surely!\n\n// this old way resulted in duplicating much of the logic in blocksSparse, didn't help enough\n// doesn't handle bwidth anyway\nvoid brickwork(vec3 q, out vec3 bpos, out vec3 bsize)\n{\n    vec3 i = floor(q),\n        w = vec3(.25,.25,.5);\n    bool oddx = (int(i.x) & 2) != 0; \n    bool oddy = (int(i.y) & 2) != 0; // idk why off by x2\n    //if (oddy) i.xz = i.zx;\n    bpos = i + .5; //.5 * ((i * 2.) + .5);\n    //if ((int(i.x) & 2) != 0)\n    //    bpos.z += .5;\n\n    if (oddx) // idk if works w new blocksSparse\n        bpos.z += .5 //, w.xz = w.zx, bpos.xz = bpos.zx\n        ;\n    bsize = w; // - .0;\n}\n*/\n//const float w = .4;\n\n\nconst float grid = 5.0;\n\n// SDF of shape limiting where blocks can be\nfloat blockLowDetail(vec3 q);\n\nvec3 blockLowDetailGradient(vec3 q);\n\nbool hasBlock(vec3 q);\n\n/*\nfloat blocksSparse0(vec3 f)\n{\n    f -= vec3(0,0.*grid,10); // position the shape\n    //f *= vec3(.75,1.5,1); // scale the blocks into \"bricks\" (HACK b/c warps the gradient nonlinearly FIXME)\n    vec3 m = floor(f);\n    float d = 1.;\n    for (int k = 2; k >= -1; k--)\n    for (int j = 2; j >= -1; j--)\n    for (int i = 2; i >= -1; i--)\n    {\n        vec3 t = vec3(i,j,k);\n        if (isodd(m.z+t.z)) t.x += .5;\n        if (isodd(m.y+t.y)) t += vec3(-.0, 0,.5);\n        if (!hasBlock(m + t))\n            continue;\n        float r = block(f, t);\n        if (r < d) { d = r; }\n    }\n    // HACK to make empty space away from the blocks not completely flat gradient, mostly; trying to always under-estimate a bit to get marchers into the zone near the blocks\n    if (d >= 1.)\n        d = max(1., blockLowDetail(f / grid) * grid - 6.25);\n    d /= 1.414; // HACK fixup the scale best we can\n    return d;\n}\n\n// this actually kind of working, wow\n// still not perfect, when blocks go all the way to the cell bounds\n// still need to scan at least some neighbor cells TODO\n// let me work on the blocks and arrangement first\nfloat blocksSparse2(vec3 f)\n{\n    //f *= grid;\n    vec3 c, z;\n    brickwork(f, c, z);\n    //c /= grid;\n    //z /= grid;\n    float db0 = dbox(f - c, z - fillet - mortar) - fillet,\n        dbound = blockLowDetail(f / grid) * grid,\n        clpd = (hasBlock(c) ? db0 : .25 - db0),\n        lmtd = smin(dbound + mdepth, db0, smth),\n        d = smax(dbound - .0, lmtd, smth);\n        //d = hasBlock(c) \n        //    ? smax(    db0, dbound, smth) \n        //    : smax(.25-db0, dbound, smth);\n    return d;\n}\n\nfloat blocksSparse3(vec3 f)\n{\n    float\n        dbound = blockLowDetail(f / grid) * grid,\n        dlod = dbound - .46;\n    if (dbound > 2.4)\n        return dlod;\n    vec3 c, z;\n    brickwork(f, c, z);\n    float d = dbound + mdepth;\n    for (int k = 4; k-- > -2; )\n    for (int j = 3; j-- > -2; )\n    for (int i = 4; i-- > -2; )\n    {\n        vec3 t = 2. * vec3(z) * vec3(i,j,k) + c;\n        bool odd = (j & 1) != 0;\n        if (odd)\n            t.z -= z.z;\n        if (!hasBlock(t))\n            continue;\n        float r = block(f - t, z); //dbox(f - t, z - fillet - mortar) - fillet; //\n        if (d > r) d = r;\n        if (odd) {\n            t.x += 2. * z.x;\n            if (hasBlock(t)) {\n                float r = block(f - t, z); //dbox(f - t, z - fillet - mortar) - fillet; //\n                if (d > r) d = r;\n            }\n        }\n    }\n    if (d > 2.)\n        d = dlod;\n    return d;\n}\n\nfloat blocksSparse(vec3 f)\n{\n    float dbound = blockLowDetail(f / grid) * grid,\n        dlod = dbound - .994;\n    if (dbound > 2.5)\n        return dlod;\n    vec3 c, // = bid(f),\n        z; // = .5 * vec2(bwidth, 1);\n    //if (isodd(f.y))\n    //    f.xz = f.zx;\n    brickwork(f, c, z);\n    //if (isodd(f.y))\n    //    c.xz = c.zx, z.xz = z.zx;\n    float d = dbound + mdepth;    \n    for (int k = 4; k-- > -2; )\n    for (int j = 4; j-- > -2; )\n    for (int i = 3; i-- > -2; )\n    {\n        vec3 t = 2. * vec3(z) * vec3(i,j,k) + c;\n        bool odd = false && (j & 1) != 0;\n        //if (odd) \n        //    t.xz = t.zx;\n        //    t.x -= z.x;\n        if (hasBlock(odd ? t.zyx : t)) {\n            float r = block(\n                odd ? (f - t).zyx : \n                f - t, \n                //odd ? z.zyx :\n                z);\n            if (d > r) d = r;\n        }\n        //if (odd) {\n        //    t.x += 2. * z.x;\n        //    if (hasBlock(t)) {\n        //        float r = block(f - t, z);\n        //        if (d > r) d = r;\n        //    }\n        //}\n    }\n    if (d > 1.99) d = dlod;  // switch to LOD\n    return d;\n}\n*/\n/*\n// think I may have finally found a technique\n// I can live with, that scales to 3D interleaved\n// criss-crossed without boggling my damn mind!  :D\n\nfloat blockLayer(vec3 f, mat4x4 layerToDetail)\n{\n    //float dbound = blockLowDetail(f / grid) * grid,\n    //    dlod = dbound - .975;\n    //if (dbound > 3.)\n    //    return dlod;\n    vec3 c, // = floor(f / 2.) * 2. + .5, //bid(f),\n        z = .5 * vec3(bwidth, 1, 1),\n        spc = 2. * vec3(1,1,2);\n    float d = 3.4e38; //dbound + mdepth;\n    //int l = 0; //for (int l = 3; (l -= 2) >= -1; )   // which layer\n    for (int k = 3; (k -= 2) >= -1; ) { // which row\n        c = floor(f / spc) * spc + .5\n            + float(k) * vec3(1, 0, 1) * spc * z\n            //+ float(l) * vec3(0, 1, 0) * spc * z.y\n            ;\n        for (int j = 2; j-- > -1; )\n        for (int i = 2; i-- > -1; )\n        {\n            vec3 t = vec3(i,0,j) * spc * z + c,\n                det = (layerToDetail * vec4(t, 1)).xyz; // * layerToDetail \n            if (hasBlock(det)) {\n                float r = block(f - t, z);\n                if (d > r) d = r;\n            }\n        }\n    }\n    //if (d > 2.5) d = dlod;  // switch to LOD\n    return d;\n}\n\n// two rows of blocks, offset, optionally interleaved\nfloat blockLayerXZ(vec3 q, mat4x4 l2d)\n{\n    float d = 3.4e38,\n        il = 1.; // half-skewed vs. straight columned\n    vec3 v = vec3(il * .5 * bwidth, 0, 1),\n        xf = l2d[3].xyz;\n    for (int l = 3; (l -= 2) >= -1; ) {  //int l = 0; { // scan which layer(s) above/below\n        vec3 x = .5 * v + vec3(0,l,0);\n        //x = x * (mat3(l2d)); //transpose\n        vec3 f = q - x;\n        l2d[3].xyz = xf + x * (mat3(l2d)); //transpose\n        //    l2d[3].xyz -= vec3(0, 0, .5).zyx; // = -f; //f; //inverse(mat3(l2d)) * f; //\n        d = min(d, blockLayer(f, l2d));\n        f += v;\n        l2d[3].xyz -= v * (mat3(l2d)); //transpose\n        //    l2d[3].xyz += vec3(0, 0, 1.).zyx;\n        d = min(d, blockLayer(f, l2d));\n    }\n    return d;\n}\n\n    // FIXME think failure to scan above and below \n    // is why blocks currently get clipped off strangely\n    // unsure if would be easier in blockLayer, blockLayerXZ, or here\n    // surely not here!  currently in blockLayerXZ since that was the least complex part\n    //for (int j = 3; j-- > -2; k ^= 1) {\n    //int k = int(isodd(f.y));\n    //}\n    //for (int j = 3; j-- > -2; k ^= 1) {\n        \n    //}\n// the simplest way I can think of to solve all this\n// is to scan two layers of blocks\n// in fact I could probably redo whole thing in terms\n// of a single row of blocks, with alternating columns shifted\n// and alternating layers turned\n// then just scan few columns out, few rows out, few layers out\nfloat blocksSparse5(vec3 f)\n{\n    float dbound = blockLowDetail(f / grid) * grid,\n        dlod = dbound - .172,\n        mbound = dbound + mdepth,\n        d = 3.4e38; //mbound; //\n    if (dbound > 3.)\n        return dlod;\n    bool swiz = true && bwidth != 1.;\n    // need a mat4x4 transform + offset per layer\n    // sent to the blockLayer function\n    // so it knows how to map back to \"blockLowDetail space\"\n    mat4 l2d = mat4(1);\n    float h = swiz ? sqrt(1. + bwidth * bwidth) : 0.; // align block layers\n    vec3 o = vec3(.25 * h, 1., .25 * h);\n    f -= .5*o;\n    l2d[3].xyz = .5*o; // = -f; //f; //inverse(mat3(l2d)) * f; //\n    d = min(d, blockLayerXZ(f, l2d));\n    f += o;\n    l2d[3].xyz -= o; // = -f;\n    if (swiz) {\n        // 'rotate' alternate layers\n        f.xz = f.zx;\n        // loop all rows doesn't work, just 3 does.  hrmm.  fun w matrices!\n        int m = 3; //for (int m = 4; m-- > 0; ) //\n            l2d[m].xz = l2d[m].zx;\n        vec4 tmp = l2d[2]; l2d[2] = l2d[0]; l2d[0] = tmp; // swap x,z\n        // so.  Just swap x,z rows, not columns.  but\n        // that also results in need to swap x,z of translation\n    }\n    d = min(d, blockLayerXZ(f, l2d));\n    f -= .5*o;\n    // FIXME would love to use smoothmin/max here for the mortar blend\n    // but it really wrecks the SDF in a bad way\n    d = min(d, mbound); //smin(d, mbound, smth); //\n    if (d > 1.5) d = dlod;  // switch to LOD\n    d = max(d, dlod); //smax(d, dlod, smth); //\n    return d;\n}\n// it's working now, well enough.  works for bwidth == 1.0 or 2.0 anyway\n// as intended, it's interleaving columns and turning layers,\n// but I find this leads to very strange looking walls,\n// at least without half-block pieces to fill in the gaps.\n// unsure if I'll like the patterning even with half-bricks.\n// in any case, doing half-bricks seems like it would lend\n// itself to an even simpler way of doing the sdf.\n// so all this might wind up having been an experiment just\n// to find out that I should really support half-bricks.\n// an easy way to test that is to modify the hasBlock fn\n// to test both halves, is just rely highly on CSG clipping\n// to some boxy blockLowDetail shape\n \n// going back to simpler tile decomposition and half-blocks\n// also decided to remove the mortar and LOD and clipping and stuff\n// from here and put in caller Scene; TODO must fixup the other ones now\nfloat blocksSparse6(vec3 f)\n{\n    float \n    //    dbound = blockLowDetail(f / grid) * grid,\n//        dlod = dbound - blayerthick,\n//        mbound = dbound + mdepth,\n        d = 3.4e38; //mbound; //\n    //if (dbound > 2.)\n    //    return dlod;\n    bool o = isodd(f);\n    bool y = isodd(f.y);\n    vec3 z = vec3(.5), c = floor(f) + .5;\n    for (int k = 2; k-- > -1; )\n    for (int j = 2; j-- > -1; )\n    for (int i = 2; i-- > -1; )\n    {\n        vec3 t = 2. * z * vec3(i,j,k) + c;\n        if (!hasBlock(t))\n            continue;\n        bool odd = ((i^j^k) & 1) != int(o);\n        vec3 off = f - t;\n        if ((j & 1) == int(y))\n            off.xz = off.zx; // swizzling layers mainly causes problems\n        if (odd)\n            off.x = -off.x;\n        float r = halfblock(off, z);\n        if (d > r) d = r;\n    }\n    // FIXME would love to use smoothmin/max here for the mortar blend\n    // but it really wrecks the SDF in a bad way\n    //d = min(d, mbound); //smin(d, mbound, smth); //\n    //if (d > 1.) d = dlod;  // switch to LOD\n    //d = max(d, dlod); //smax(d, dlod, smth); //\n    return d;\n}\n*/\n// so this worked out ok, BUT\n// (of course there's a but)\n// the only side that seems to work out 'pretty'\n// is the top.  Sure, we could rotate this\n// to align with whatever wall,\n// and shift it so the brick pattern shows\n// the way we want, for each wall face,\n// but surely there must be some way to \n// do a brick that's more robust,\n// handles wall face alignment more automatically.\n\n// this is working real well now, \n// so long as the walls are aligned\n// w the global coordinate axes!\n// To me, it looks a lot like some of the common\n// bonding patterns, but from any direction.\n// so it's not realistic at all.\n// relies on visual trickery near the corners.\n// I guess now that I really look at it,\n// this design seems to lack any real bonding\n// strategy whatsoever, would rely on cutting\n// bricks at the corners in real life, and result\n// in unbonded leafs, not true bonded walls.\n// the fact that it 'joins' at the corners\n// makes it seem like it's at least kind of bonded,\n// there at the very ends of the walls.\nfloat blocksSparse7(vec3 f)\n{\n    vec3 g = abs(blockLowDetailGradient(f / grid));\n    // depending on largest component of g, realign\n    mat3 T = mat3(1); vec3 tmp;\n         if (g.x > max(g.y, g.z))\n        tmp = T[2], T[2] = T[0], T[0] = tmp;\n    else if (g.z > max(g.y, g.x)) \n        tmp = T[2], T[2] = T[1], T[1] = tmp;\n    f = f * T;\n    // initializing d to something gigantic results in -inf problems because caller scales and then unscales by grid size\n    float d = 3.4e4; //3.4e38; // at Xe5 starts getting precision problems somehow\n    bool o = isodd(f);\n    bool y = isodd(f.y);\n    vec3 z = vec3(.5), c = floor(f) + .5;\n    // scanning 3x3x3 = 27 cells is already pretty strenuous on GPU;\n    // really cannot handle 5^3, tanks FPS\n    for (int k = 2; k-- > -1; )\n    for (int j = 2; j-- > -1; )\n    for (int i = 2; i-- > -1; )\n    {\n        vec3 t = 2. * z * vec3(i,j,k) + c;\n        if (!hasBlock(T * t))\n            continue;\n        bool odd = ((i^j^k) & 1) != int(o);\n        vec3 off = f - t;\n        if (odd)\n            off.x = -off.x;\n        float r = halfblock(off, z);\n        if (d > r) d = r;\n    }\n    return d;\n}\n\n// TODO @jt suggests Flemish Bond, I should try it!\n// Would need queen closers on alternating courses, to\n// make the leafs / wall faces flush ('lap' or correct overlap).\n// I suppose I can just ignore those, but will end up\n// with weird half-gaps and such eventually if I do.\n\n// material ids\nconst int\n    mSky   = 0,\n    mGray  = 1,\n    mGreen = 2,\n    mBrown = 3;\n//   mRed   = 4,\n//   mBlue  = 5,\n\n\nstruct Hit\n{\n    float d; // signed distance to surface\n    int m; // material id\n};\n/* TODO other convenient quantities\ninclude local texture coordinate\n*/\n// HACK so Common tab can access this uniform;\n// iTime must be copied here at start of mainImage!\nfloat time; // for animating the scene\n//void SetupScene(float t) { time = t; }\n// is position of center of block inside the shape?\n// we kind of want blocks wherever they would be touching the mortar\nbool hasBlock(vec3 q)\n{\n    float d = blockLowDetail(q / grid);\n    // FIXME should be a factor of blayerthick?\n    return d <= .43 * blayerthick //.28 //.25 //.125 //0. //\n        && hash(q) > 1. - 3.9 * (.28 - d) // some random gaps\n        ;\n}\n// where should bricks be placed?  inside this sdf.\nfloat blockLowDetail(vec3 q)\n{\n    //return length(q - vec3(0,3,0)) - 6.;\n    // torus to exclude blocks\n    //return -.875 //-.375 //-.275 //-.125 //\n    //    + (length(q) - 2.375);\n    q += vec3(.127, 0, .127) * sin(vec3(.012, 0, .013) * time);\n    q.x += 6.17; // shift to detect problems w coord transforms\n    q.y -= 2.475;\n    q.z += .175;\n    return max(\n        max(\n        min(abs(dbox(q, vec3(15.5,2.75,15.5))), abs(dbox(q, vec3(9.5,2.5,9.5)))) - .5, // slightly rounded hollow boxy 'square' torus, a different way\n         -dbox(q, vec3(8.4,5.5,8.4))),\n        -dbox(q, vec3(19,2.45,2))); // the doorway\n    //return max(\n    //    max(dbox(q, vec3(15.5,3.5,15.5)), 1.-dbox(q, vec3(9.5,5.5,9.5))) - .5, // slightly rounded hollow boxy 'square' torus\n    //    -dbox(q, vec3(19,3,2))); // hopefully will have better SDF for collision\n    //return max(abs(max(abs(max(abs(q.x), abs(q.z)) - 12.175), abs(q.y - .5)) - 2.51) - .375, // hollow boxy 'square' torus\n    //    - dbox(q - vec3(0,.75,0), vec3(19,3,2))); // FIXME you can tell from the collision that it really screws up the SDF\n    //return max(abs(max(abs(q.x), abs(q.z))-12.375), abs(q.y)) - 3.1875; // boxy 'square' torus\n    //return length(vec2(abs(max(abs(q.x), abs(q.z)) - 12.375), q.y)) - 3.1875; // roundy 'square' torus\n    //return length(vec2(abs(length(q.xz)-12.375), q.y)) - 3.1875;\n}\n/* // really slow for some reason and the botched distances cause problems\n    float m = exp2(-.5 * (q.y + 1.) * (q.y + 1.));\n    return q.y\n     + mix(.0,\n       1./2.  * dot(sin(1./8. * q), vec3(1))\n     + 1./4.  * dot(sin(1./4. * q), vec3(1))\n     //+ 1./8.  * dot(sin(1./2. * q), vec3(1))\n     , m);\n*/     \n\nvec3 blockLowDetailGradient(vec3 q)\n{\n\tvec3 g, o = vec3(0,0,3e-2);\n\tvec4 s; float d;\n\tfor (int i = 4; i-- > 0; o = vec3(o.yz, 0))\n\t\ts[i] = blockLowDetail(q + o);\n\tg = s.yzw - (d = s.x);\n\treturn g;\n} // no point normalizing if we only check the largest component anyway\n\nHit Scene(vec3 q)\n{\n    float dp = q.y, // ground plane +Y\n        dlow = blockLowDetail(q),\n        dlod = dlow - blayerthick / grid,\n        dbound = dlod - 1.4 * blayerthick / grid;\n        //mbound = dbound + mdepth,\n        //d = 3.4e38; //mbound; //\n    //return Hit(dbound, mGray);\n    //return Hit(dlod, mGreen);\n    if (dbound > 1.5 / grid) // FIXME this depends on range of the actual SDF; 2. clips pretty closely\n        return Hit(min(dp, dbound), mGreen); //dp < dlod ? mGreen : mBrown); //mGray); // LOD early out\n    float //r = .5, // ball radius\n        //tr = .5, // torus radius\n        //tz = 1.5, // torus size\n        //db = dsphere(p - vec3(0,r,0), r), // non-moving ball above origin\n        //dx = dbox(p - vec3(0,.7,-7.5), vec3(6,.3,.3)), // large box for testing collision\n        //dr = dtubey(p - vec3(0,-.0125,0), vec4(64,.0,.625,.125)), // large low cylindrical tube around origin\n        //dc = 3.4e38, // other stuff\n        dk =\n            //blocksSparse\n            //blocksSparse0\n            //blocksSparse2\n            //blocksSparse3\n            //blocksSparse4\n            //blocksSparse5\n            //blocksSparse6\n            blocksSparse7 \n                (q * grid) / grid,\n        //dlod = blockLowDetail(p),\n        dmortar = dlod + mdepth / grid;\n        dlod -= blayerthick / grid;\n    if (abs(dk) > 2e2)\n        dk = dbound; // no data = use boundshape\n//    return Hit(dmortar, mGreen); //dk; //\n    //dmortar = smax(dmortar, - 4e-4 - dk, smth); // smooth the mortar to the bricks, ruins SDF\n    //dk = smin(dmortar + 4e-4, dk, smth); // doesn't make sense to smooth the bricks to the mortar\n    //dk = smax(dk, dlod, smth); //if (dk < dlod) dk = dlod; // clip  FIXME smax would be problematic\n    dk = smax(dk, dbound, smth); //max(dk, dbound); // clip to boundary just in case\n    //dx = min(dx, dr);\n    //db = min(db, \n    //   dsphere(p - prot(vec3(0,r,2.*r), vec3(0,1,0), .5*time), r)); // ball above origin    \n    //dc = min(dc, dtubey((p - vec3(10,tz+tr,0)).yzx, vec4(tz,0,0,0)) - tr); // big torus to stress shadows\n\t//dc = min(dc, dtubey((p - vec3(-10,tz + .1,0)).zxy, vec4(tz,tz,.1,0)) - 0.);\n    Hit h; // = Hit(3.4e38, mSky);\n    h = Hit(dp, mGreen);\n    //if (h.d > db) h = Hit(db, mRed);\n    //if (h.d > dx) h = Hit(dx, mGreen);\n    //if (h.d > dc) h = Hit(dc, mBlue);\n//    if (h.d > dmortar) h = Hit(dmortar, mGray); //mBrown); //\n    if (h.d > dk) h = Hit(dk, dk < dbound ? mGreen : mBrown);\n    dmortar = smin(dmortar, dk + 5e-3, smth);\n    if (h.d > dmortar) h = Hit(dmortar, mGray);\n    return h;\n}\n\n// bounding clip plane height for entire scene - nothing is taller than this\nconst float hmax = 10.;\n\n// loop using uniform to limit compile time bloat with complex scene\nvec3 SceneNormal(vec3 p, float h, out float d, int izero)\n{\n\tvec3 n, o = vec3(0,0,h);\n\tvec4 s;\n\tfor (int i = izero+4; i-- > 0; o = vec3(o.yz, 0))\n\t\ts[i] = Scene(p + o).d;\n\tn = s.yzw - (d = s.x);\n\tif (dot(n,n) < 1e-7) n = vec3(0,1,0);\n\telse n = normalize(n);\n\treturn n;\n}\n\n\nstruct Marched \n{\n\tfloat t;   // distance to intersection\n\tint m;     // material id\n\tfloat nmd; // nearest miss distance\n};\n\n#define TRY_IT 0\n\nMarched March(vec3 ro, vec3 rd, float thresh, float dmax, int iters)\n{\n\tMarched c = Marched(dmax, mSky, dmax);\n\tint i = iters;\n\tfloat t = 0.;\n\twhile (i-- > 0) {\n\t\tvec3 mp = ro + rd * t;\n\t\tHit h = Scene(mp);\n\t\tfloat d = h.d, ad = abs(d);\n\t\tt += d;\n\t\t#if !TRY_IT\n        // is @shadertoyjiang correct?\n        c.m = h.m, c.nmd = h.d;\n        #endif\n\t\tif (rd.y >= 0. && (ad > dmax\n\t\t\t|| mp.y > hmax))\n\t\t\tbreak; //t = dmax;\n\t\tif (ad < thresh * t || t >= dmax)\n\t\t\tbreak;\n\t}\n    #if TRY_IT\n    // is @shadertoyjiang correct?\n\tc.m = Scene(ro + rd * t).m;\n    #endif\n\tc.t = t = clamp(t, 0., dmax);\n\t//if (abs(c.nmd) > thresh * 2. * t) \n\t//\tc.m = mSky;\n\t//if (c.m == mSky)\n\t//\tc.t = dmax; // caller won't be able to tell how far it got though\n\treturn c;\n}\n\n// HACK rescue failed marches for planar scenes\nvoid Rescue(inout Marched c, vec3 ro, vec3 rd, float d, float tmax)\n{\n    if (ro.y > 0. && (rd.y >= 0.)) { // || d > 2e-2 * c.t\n        if (d > 8e-3 * c.t) { //c.t > 5. && \n        c.t = tmax;\n        c.m = mSky;\n        }\n    } else if (d > 7e-2 * c.t) {\n        c.t = ro.y / -rd.y;\n        c.m = mGreen;\n        c.nmd = 0.;\n    }\n}\n\n\n// Walk Camera stuff\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution; // window resolution\n    vec3 eyepos;\n    vec3 eyevel;\n    vec2 eyeaim;\n    vec2 aimbase; // involved in mouse lookaround\n    bool mbdown; // mouse button was down?\n};\n\nconst int\n  slotResMBD     = 0, // w unused\n  slotEyePos     = 1, // w unused\n  slotEyeVel     = 2, // w unused\n  slotAzElBase   = 3, // azimuth and elevation of aim, also recorded on mouse up\n  slotCount      = 4;\n\n\nbool IsStatePixel(ivec2 i, ivec2 R)\n{\n   \treturn i.y == R.y-1 && i.x >= R.x-1-slotCount;\n}\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResMBD].xy);\n    state.mbdown = data[slotResMBD].z > .5;\n    state.eyepos = data[slotEyePos].xyz;\n    state.eyevel = data[slotEyeVel].xyz;\n    state.eyeaim = data[slotAzElBase].xy;\n    state.aimbase = data[slotAzElBase].zw;\n}\n\n// only needed in Buffer A\n// but mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) { // IsStatePixel(p)\n      case slotResMBD:\n        c = vec4(R, state.mbdown ? 1. : 0., 0);\n        break;\n      case slotEyePos:\n        c = vec4(state.eyepos, 0.);\n        break;\n      case slotEyeVel:\n        c = vec4(state.eyevel, 0.);\n        break;\n      case slotAzElBase:\n        c = vec4(state.eyeaim, state.aimbase);\n        break;\n      default:\n        break;\n    }\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float \n    eyeradius = .25, // collision size\n    eyespeed = 8.,   // eye max velocity; shift doubles it\n    eyespin = 2.,    // spin rate per mouse uv\n    eyesmooth = .05, // just a little is plenty\n    eyeh = 1.5,      //0. //.75 - eyeradius // eye height above floor\n    eyeacc = 3.,     // eye acceleration\n    eyeldamp = 4.,   // eye contact friction\n    eyevdamp = .1;   // eye air resistance\n\nconst vec3 grav = vec3(0,-9.8,0); // gravity force\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    vec2 turn; // keyboard turning\n    float dt; // delta time seconds\n    bool button;\n    bool attract;\n    // debug features TODO\n};\n\nconst int // http://keyjs.dev\n    KEY_SPACE = 32,\n    KEY_SHIFT = 16,\n    KEY_C     = 67,\n    KEY_W     = 87,\n    KEY_A     = 65,\n    KEY_S     = 83,\n    KEY_D     = 68,\n    KEY_Z     = 90,\n    KEY_Q     = 81,\n    KEY_O     = 79,\n    KEY_E     = 69,\n    KEY_G     = 71,\n    KEY_COMMA = 188,\n    KEY_LEFT  = 37, // arrow keys\n    KEY_RIGHT = 39,\n    KEY_UP    = 38,\n    KEY_DOWN  = 40,\n    KEY_PGUP  = 33,\n    KEY_PGDN  = 34,\n// key bindings to local directions\n// can be customized as necessary\n #if 0\n    // AZERTY ZQSD\n    KEY_FW    = KEY_Z,\n    KEY_LF    = KEY_Q,\n    KEY_BW    = KEY_S,\n    KEY_RT    = KEY_D,\n #elif 0\n    // DVORAK ,AOE\n    KEY_FW    = KEY_COMMA,\n    KEY_LF    = KEY_A,\n    KEY_BW    = KEY_O,\n    KEY_RT    = KEY_E,\n #else\n    // QWERTY WASD\n    KEY_FW    = KEY_W,\n    KEY_LF    = KEY_A,\n    KEY_BW    = KEY_S,\n    KEY_RT    = KEY_D,\n #endif\n// FIXME up/down controls probably not great for\n// non-QWERTY layouts, but can swap to PGUP/DN\n    KEY_UW    = KEY_SPACE, // up\n    KEY_DW    = KEY_C,     // down\n// FIXME turn keys will only really work for QWERTY\n    KEY_TURNL = KEY_Q, // KEY_DEL\n    KEY_TURNR = KEY_E  // KEY_END\n//  KEY_F     = 70,\n//  KEY_R     = 82,\n//  KEY_V     = 86,\n//  KEY_X     = 88,\n//  KEY_TAB   = 9\n  ;\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n\n#define Kbd      iChannel3\n\nfloat key(int vk)\n{\n    return step(.5, fetch(Kbd, ivec2(vk, 0)).x);\n}\n\nbool option(int vk)\n{\n    return fetch(Kbd, ivec2(vk, 2)).x > .5;\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    inp.attract = !inp.button && dot(inp.mouse, inp.mouse) < 4.;\n    if (inp.attract) { // icon?\n        inp.mouse.x = .02*iTime; // slow spin\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    }\n    inp.move =\n      vec3(key(KEY_RT) - key(KEY_LF)\n         , key(KEY_UW) - key(KEY_DW)\n         , key(KEY_FW) - key(KEY_BW))\n    + vec3(key(KEY_RIGHT) - key(KEY_LEFT)\n         , key(KEY_PGUP ) - key(KEY_PGDN)\n         , key(KEY_UP   ) - key(KEY_DOWN)) // arrows alternate controls\n      ;\n    inp.turn = vec2(key(KEY_TURNR) - key(KEY_TURNL), 0);\n    inp.dt = iTimeDelta;\n}\n// vertically-oriented capsule as collision shape\n// ofs = half-seg-offset from center to one end of the core segment,\n// radius of capsule segment poof\n// HACK just tests closest of a string of spheres along the capsule\nvoid CollideCapsule(inout vec3 pos, vec3 ofs, float radius)\n{\n    vec3 p = pos, no; float d = 3.4e38;\n\tint ncapsph = IZERO + 5; //7; //9; //3; //\n\tfor (float d2, st = 2./float(ncapsph), j = -1.; j <= 1.; j += st) {\n\t\tvec3 ns = SceneNormal(p + j * ofs, .1*radius, d2, IZERO);\n\t\tif (d2 < d) { d = d2; no = ns; }\n\t}\n\tpos -= no * min(0., d  - radius);\n}\n\nbool CollideEye(inout vec3 p)\n{\n\tfloat eh = .5 * eyeh - eyeradius;\n\tvec3 po = p; // HACK not best way to detect collision; too late anyway\n\t// FIXME should actually distribute the movement throughout all these iterations - see fixes in Plumbing Maze\n\t// multiple collision iterations to prevent tunnelling at low fps\n\tfor (int i = 3; --i >= 0; ) { // repeating helps with getting stuck in crevices\n\t\tp.y -= eh; // capsule center is below the eyes\n\t\tCollideCapsule(p, vec3(0,eh,0), eyeradius);\n\t\tp.y += eh;\n//\t\tpos.y = max(pos.y, radius + abs(ofs.y)); // HACK prevent going beneath ground plane just in case\n\t} // FIXME the response when stepping up onto steps can be extremely bouncy\n\treturn dot(po-p,po-p) > 1e-8; // must be very sensitive; probably breaks at high fps\n}\n\nvoid MoveCamera(inout State state, Inputs inp) \n{\n    if (FLY==0 && WALK==0) return;\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed, dt = inp.dt;\n    spd *= 1. + key(KEY_SHIFT);\n    vec3 op = state.eyepos\n    , move = inp.move * dt * spd \n    , p = op\n    ;\n    bool usegravity = !option(KEY_G) // 'G' = 71\n    , walking = WALK!=0 && (FLY==0 || usegravity)\n    , flying = (FLY!=0 && !walking); //FLY!=0 && (WALK==0 || !usegravity)    \n    if (walking) {\n        move = view * move; // to world space\n\t\t// should not be able to fly simply by looking down or up,\n        // so remove portion of input directed along gravity vector\n        move -= grav * dot(move, grav) / dot(grav, grav);\n        // TODO reduce air control - need grounded state\n        // gravity requires velocity state\n    \tstate.eyevel += dt * grav; // gravity force - wrong for Euler integration\n        state.eyevel += 2. * dt * dt * grav; // correction for above issue - unsure if right\n        state.eyevel += move * eyeacc; // control force\n        state.eyevel *= exp2(-dt*vec3(eyeldamp,eyevdamp,eyeldamp)); // damping\n    \tp += dt * state.eyevel; // momentum\n    } else if (flying) {\n     \tp += view * move;\n    }\n    bool collided = false;\n  #if COLLISION    \n    collided = CollideEye(p);\n    // TODO save collided to grounded state?\n  #endif\n    state.eyepos = p;\n    state.eyevel = (p - op) / max(1e-7, dt);\n    float evl2 = dot(state.eyevel, state.eyevel);\n    state.eyevel *= isnan(evl2) ? 0. : evl2 > 5e3 ? .5 : 1.;\n    if (walking && collided && inp.move.y > 0. && dot(state.eyevel, grav) >= 0.)\n        state.eyevel -= .5*grav; // up is jump // TODO sqrt (.5*h)\n}\n\nvoid TurnCamera(inout State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution)\n    , oa = state.eyeaim\n    , a = oa;\n    if (state.mbdown && inp.button)\n        a = (inp.mouse - abs(iMouse.zw)) / R * vec2(2) + state.aimbase;\n    a += inp.turn * mix(.5, 1., key(KEY_SHIFT)) * inp.dt;\n    a.x = fract(a.x);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    if (dot(inp.turn,inp.turn) < 1e-3) // only if not key turning, because that doesn't work well\n    \ta = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate mouse aim\n    else\n    // key turning should update the aimbase,\n    // to prevent it snapping back when the mouse is next clicked.\n        state.aimbase = state.eyeaim;\n    state.eyeaim = a;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(0,eyeh+.5*eyeradius,-4);\n        state.aimbase = \n        state.eyeaim = vec2(0.,.5);\n        state.mbdown = false;\n    } else { // update state\n        MoveCamera(state, inp);\n\t    TurnCamera(state, inp);\n        if (state.mbdown && !inp.button) // on mouse up\n    \t    state.aimbase = state.eyeaim; // record aim base\n        state.mbdown = inp.button;\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    time = iTime; // SetupTime\n    ivec2 R = ivec2(iResolution),\n        i = ivec2(p);\n    bool init = iFrame == 0;\n    if (!init && i.y < R.y-1 || i.x < R.x-slotCount) discard; // big optimization\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n\t// Usually prior data is loaded and passed through unchanged.\n    vec4 c = fetch(BufA, i);\n    SaveState(c, state, i);\n    o = c;\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}