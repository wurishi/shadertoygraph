{"ver":"0.1","info":{"id":"4tjSRK","date":"1445307144","viewed":230,"name":"[CIS565 2015F]Raymarching","username":"zammie","description":"https://github.com/zammiez/Project5-GLSL-Ray-Marcher\n\nAcknowledgements:\n\n* {McGuire}\n  Morgan McGuire, Williams College.\n  *Numerical Methods for Ray Tracing Implicitly Defined Surfaces* (2014).\n  [PDF](http://graphics.cs.williams.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["project5byziweizong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Some Codes are Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// More info here: https://iquilezles.org/articles/distfunctions\n\n#define Debug_Normal 0\n#define Debug_SurfDist 0\n#define Debug_iterNum 0\n#define NaiveMarch 0\n#define SoftShadow 1\n#define showMS 1\n#define HeightMap 1\t//height: iChannel0\n#define AO_Test 0\n#define withAO 0\n\nconst int Iter_Naive = 2000;\nconst int Iter_ST =80000;\nconst int leve_MergeSponge = 4;\nfloat pre_naive = 0.01;\nfloat pre_ST = 5.0e-4;//0.0000006;\n    \nint itrNum = 0;\nfloat dist = 0.0;\n\nvec3 TransP(vec3 pos, vec3 T, vec3 R, vec3 S)\n{\n    float c1 = cos(R.x);\n    float c2 = cos(R.y);\n    float c3 = cos(R.z);\n    float s1 = sin(R.x);\n    float s2 = sin(R.y);\n    float s3 = sin(R.z);\n    mat4 RotMat = mat4(\tc2*c3,\tc1*s3+c3*s1*s2,\ts1*s3-c1*c3*s2,\t0,\n                      \t-c2*s3,\tc1*c3-s1*s2*s3,\tc3*s1+c1*s2*s3,\t0,\n                      \ts2,\t\t-c2*s1,\t\t\tc1*c2,\t\t\t0,\n                      \t0,\t\t0,\t\t\t\t0,\t\t\t\t1);\n    mat4 inv_R = mat4(\tc2*c3,\t-c2*s3,\ts2,\t0,\n                     \tc1*s3+c3*s1*s2,\tc1*c3-s1*s2*s3,-c2*s1,0,\n                     \ts1*s3-c1*c3*s2,c3*s1+c1*s2*s3,c1*c2,0,\t\n                     \t0,0,0,1);\n    mat4 inv_T = mat4(1,0,0,0,\n                      0,1,0,0,\n                      0,0,1,0,\n                      -T.x,-T.y,-T.z,1);\n    mat4 inv_S = mat4(1.0/S.x,0,0,0,\n                      0,1.0/S.y,0,0,\n                      0,0,1.0/S.z,0,\n                      0,0,0,1);\n    \n    mat4 inv_M = inv_S*inv_R*inv_T;\n    \n    vec4 localPos = inv_M*vec4(pos,1.0);\n    \n    return localPos.xyz;\n}\n\nfloat sdPlane_height(vec3 p,float s,float repeat)\n{\n\treturn p.y - s*length(texture( iChannel0, repeat*p.xz, 0.0 ).xyz);\n}\n\nvec4 Plane_Terrian(vec3 p,float s,float repeat)\n{\n    vec3 col = vec3(0.8,0.8,0.8);\n    col = vec3(0.1)+1.5*texture( iChannel0, repeat*p.xz, 0.0 ).xyz;\n    float dist = p.y - s*length(texture( iChannel0, repeat*p.xz, 0.0 ).xyz);\n    return vec4(clamp(col,0.0,1.0),dist);\n}\n\n\n/*\nfloat sdBox(vec3 p,vec3 s)\n{\n    vec3 d = abs(p)-s;\n    return length(max(d,vec3(0.0)));\n}*/\n\nfloat sdBox(vec3 p,vec3 s,float r)\n{\n    vec3 d = abs(p)-s;\n    return length(max(d,vec3(0.0)))-r;\n}\n\nfloat sdCylinder(vec3 p,float h, float r)\n{\n    return max( length(vec2(p.x,p.z))-r,max(abs(p.y)-h,0.0)); \n}\n\nfloat sdCylinderRing(vec3 p,float h, float ro,float ri)\n{\n    float r = length(vec2(p.x,p.z));\n    float dxz = r-ro;\n    dxz = max(dxz, ri-r);\n    \n    return max( dxz,max(abs(p.y)-h,0.0)); \n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nvec4 MergeSponge(float boundDist,vec3 pos)\n{  \n    float s = 1.0;\n    vec3 col = vec3(1.0,0.1,0.2);\n    float t = abs(mod(iTime/2.0,2.8)-1.4)+0.1;\n    for(int m=0;m<leve_MergeSponge;m++)\n    {\n        //vec3 a = abs(mod((pos)*s, 2.0)-1.0)-0.5;\n        //vec3 a = abs(mod((pos)*s, 2.0))-vec3(0.5);\n        vec3 a = abs(mod(pos*s,2.0)-1.0)-(t/3.0)*2.0;\n        float dx = min(a.x,a.y);\n        float dy = min(a.y,a.z);\n        float dz = min(a.z,a.x);\n        \n        s*=3.0;\n        \n        float c = max(dx,max(dy,dz))/s;\n\n        if(c>boundDist)\n        {\n            col.r*=0.5;\n            col.g*=2.4;\n            col.b*=2.6;\n            boundDist = c;\n        }\t        \n    }\n    return vec4(clamp(col,0.01,1.0),boundDist);\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n\treturn (d1.w<d2.w) ? d1 : d2;\n}\n\n\nvec4 map(in vec3 pos)\n{\n\n#if HeightMap\n    //vec4 plane = vec4(vec3(0.6,0.6,0.6),sdPlane_height(pos,0.2,0.1));\n    vec4 plane = Plane_Terrian(pos,0.4,0.1);\n    return plane;\n#else\n    vec4 plane = vec4(vec3(float(floor(mod(pos.x*2.0,2.0))==floor(mod(pos.z*2.0,2.0)))*0.4+0.5), sdPlane(pos));\n#endif\n    \n#if AO_Test\n    vec4 rCube1 = vec4(vec3(0.95,0.95,0.9), sdBox(TransP(pos,vec3(0.0,0.05,0.0),vec3(0),vec3(2.0)),vec3(0.5,0.1,0.5),0.05));\n    vec4 rCube2 = vec4(vec3(0.95,0.95,0.9), sdBox(TransP(pos,vec3(0.0,0.35,0.0),vec3(0),vec3(2.0)),vec3(0.25,0.1,0.25),0.05));\n    vec4 sphere1 = vec4(vec3(0.95,0.95,0.9), sdSphere(TransP(pos,vec3(0.0,0.9,0.0),vec3(0),vec3(2.0)),0.15));\n  \n    vec4 res = opU(rCube1,rCube2);\n    res = opU(res,sphere1);\n    res = opU(res,plane);\n        \n#else\n    vec3 Ts = vec3(0,0.2,-1.2);\n    vec3 Rs = vec3(0.0,0.4,0.0);\n    vec3 Ss = vec3(1,1,1);\n    vec4 sphere = vec4(vec3(1.0,1.0 ,0.55), Ss.x*Ss.y*Ss.z*sdSphere(TransP(pos,Ts,Rs,Ss), 0.3));\n    vec4 cylinder = vec4(vec3(1.5,0.9,0.8),sdCylinder(TransP(pos,vec3(-1.2,0.2,0),vec3(-0.3,0.0,0.3),vec3(1)),0.2,0.2));\n    vec4 cylRing = vec4(vec3(0.98,0.5,0.75),sdCylinderRing(TransP(pos,vec3(1.0,0.4,-0.8),vec3(1.5,0.0,0.4),vec3(1)),0.1,0.3,0.25));\n    vec4 roundCube = vec4(vec3(0.7,0.5,1),sdBox(TransP(pos,vec3(1.0,0.4,-0.8),vec3(1.2,0.72,1.0),vec3(1)),vec3(0.03,0.33,0.03),0.06));\n    vec4 cube = vec4(vec3(0.3,0.75,1),sdBox(TransP(pos,vec3(-0.6,0.19,-0.6),Rs,vec3(1)),vec3(0.2,0.2,0.2),0.0));\n\n//MS.rgb*=5.0;\n    \n   vec4 res = opU(sphere,plane);\n\tres = opU(res,cube);\n    res = opU(res,cylinder);\n    res = opU(res,cylRing);\n    res = opU(res,roundCube);\n    \n#endif\n\n#if showMS\n    float sc = 0.6;\n    float sc3 = sc*sc*sc;\n    vec3 lclP = TransP(pos,vec3(0.0,1.0,0.0),vec3(0.3,0.2,0.0),vec3(sc));\n    vec4 bound = vec4(vec3(0.5,0.6,1),sc3*sdBox(lclP,vec3(1.0,1.0,1.0),0.05));\n    //vec4 bound = vec4(vec3(0.5,0.6,1),sdSphere(TransP(pos,vec3(0.0,0.0,0),vec3(0),vec3(1)),2.0));\n    vec4 MS = MergeSponge(bound.w,lclP);\n    res = opU(res,MS);\n   // res = opU(res,cone);\n#endif\n    return res;\n}\n\nvec3 calcNormal(vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).w - map(pos-eps.xyy).w,\n        map(pos+eps.yxy).w - map(pos-eps.yxy).w,\n        map(pos+eps.yyx).w - map(pos-eps.yyx).w );\n    return normalize(nor);\n}\n\nvec4 castRay_Naive(in vec3 ro, in vec3 rd)\n{\n\tfloat tmin = 1.0;\n\tfloat tmax = 20.0;\n\n\tfloat t = tmin;\n\tvec3 m = vec3(-1, -1, -1);\n\tfor (int i = 0; i<Iter_Naive; i++)\n\t{\n\t\tvec4 res = map(ro + rd*t);\n        dist = length(rd*t);\n        m = res.xyz;\n\t\tif (res.w<pre_naive)\n\t\t{\n\t\t\t//m = calcNormal(ro + rd*t);//res.xyz;\n            itrNum = i;\n\t\t\tbreak;\n\t\t}\n\t\telse if (t>tmax)\n\t\t{\n\t\t\tm = vec3(0.8, 0.9, 1.0);\n            dist = 1000.0;\n            itrNum = i;\n\t\t\tbreak;\n\t\t}\n\t\telse m = vec3(0.5, 0.5, 1.0);\n        \n\t\tt += pre_naive;\n\t}\n\n\tif (t>tmax) t = -1.0;\n\treturn vec4(m, t);\n}\n\nvec4 castRay_ST(in vec3 ro, in vec3 rd)\n{\n\tfloat tmin = 1.0;\n\tfloat tmax = 20.0;\n\n\tfloat t = tmin;\n\tvec3 m = vec3(0.7, 0.4, 0.1);\n\tfor (int i = 0; i<Iter_ST; i++)\n\t{\n\t\tvec4 res = map(ro + rd*t);\n        dist = length(rd*t);\n        \n        if (res.w<pre_ST)\n        {\n            itrNum = i;\n            m = res.xyz;\n            break;\n        }\n        else if(t>tmax)\n        {\n            m = vec3(0.8, 0.9, 1.0);\n            dist = 1000.0;\n            break;\n        }\n        else m = vec3(0.5, 0.5, 1.0);\n\t\tt += res.w;\n\t\t\n        //m = calcNormal(ro + rd*t);\n\t}\n\n\tif (t>tmax) t = -1.0;\n\treturn vec4(m, t);\n}\n\nfloat Shadow( vec3 ro, vec3 rd )\n{\n\n    float res = 1.0; \n    float t = 0.02;\n    rd = normalize(rd);\n#if SoftShadow\t//soft shadow\n    //rd = rd-ro;\n    bool ifBreak = false;\n    for( int i=0; i<40; i++ )\n    {\n\t\tfloat dist = map( ro + rd*t ).w;\n        res = min( res, 8.0*dist/t );\n        if(dist<0.0001||t>10.0)\n        {\n            ifBreak = true;\n            itrNum += i;\n            break;\n        }      \n        //t+=\n        t += clamp(dist,0.0,0.05);\n    }\n    if(!ifBreak) itrNum+=40;\n#else   //sharp shadow   \n    vec3 d = rd;//+vec3(0.0,0.0,0.0)-ro;\n    for( int i=0; i<40; i++ )\n    {\n        float dist = map(ro+d*t).w;\n        res = dist;\n        \n        t+=dist;//clamp( dist, 0.0002, 0.005 );\n        if(dist<0.002||t>10.0) break;\n    }\n#endif\n    return clamp( res, 0.2, 1.0 );\n\n}\n\nfloat calcAO(vec3 p,vec3 nor)\n{\n    float ao = 0.0;\n    float scale = 1.0;\n    for(int i=0;i<5;i++)\n    {\n        float dirScale = 0.01+0.03*float(i);\n        vec3 stepP = p+nor*dirScale;\n        float dist = map(stepP).w;\n        ao += -(dist-dirScale)*scale;\n        scale*=0.75;\n    }\n#if withAO\n    return clamp(1.0-5.5*ao,0.0,1.0);\n#endif\n    return 1.0;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\t// TODO\n    vec3 col = vec3(0.8, 0.9, 1.0);\n    float itrTotal = 1.0;\n    \n#if NaiveMarch\n    itrTotal = float(Iter_Naive)/3.0;\n    vec4 res = castRay_Naive(ro,rd);\n#elif HeightMap\n    itrTotal = float(Iter_Naive)/3.0;\n    vec4 res = castRay_Naive(ro,rd);\n#else\n    itrTotal = float(Iter_Naive)/3.0;\n    vec4 res = castRay_ST(ro, rd);\n#endif\n    //*\n\tfloat t = res.w;    \n    vec3 nor = calcNormal(ro + rd*t);\n\tvec3 m = res.xyz;\n\tif (t>-0.5)  // Ray intersects a surface\n\t{ \n\t\tcol = m;\n        vec3  light = normalize( vec3(-0.6, 0.7, -0.5) );\n        float shadow = Shadow(ro+t*rd,light);\n        float diffuse = clamp( dot( nor, light ), 0.0, 1.0 );\n        float ambient = clamp(dot(nor,normalize(-rd)),0.0,1.0)*calcAO(ro+t*rd,nor);\n        diffuse*=shadow;\n        vec3 brdf =  (0.2*ambient + 0.9*diffuse)*vec3(1.0,1,1);\n        col = col*brdf;\n#if Debug_Normal\n        col = nor;\n#elif Debug_SurfDist\n        col = vec3(1.0-dist/8.0);\n#elif Debug_iterNum\n        //col = vec3(1.0-float(itrNum)/40.0);\n        col = vec3(1.2-float(itrNum)*2.0/float(itrTotal),abs(0.2-float(itrNum)*1.1/float(itrTotal)),1.0);\n#endif\n        \n    }//*/\n    \n\treturn vec3(clamp(col, 0.0, 1.0));\n\t//return rd;  // camera ray direction debug view\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\t// Starter code from iq's Raymarching Primitives\n\t// https://www.shadertoy.com/view/Xds3zN\n\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Starter code from iq's Raymarching Primitives\n\t// https://www.shadertoy.com/view/Xds3zN\n\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\n\tfloat time = 15.0 + iTime;\n\n\t// camera\n\tvec3 ro = vec3(\n\t\t-0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n\t\t1.0 + 2.0 * mo.y,\n\t\t0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n\tvec3 ta = vec3(-0.5, -0.4, 0.5);\n\n\t// camera-to-world transformation\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\n\t// ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n\t// render\n\t//vec3 col = vec3 (0.0,0.0,0.0);\n    vec3 col = render(ro, rd);\n\n\t//col = pow(col, vec3(0.4545));\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}