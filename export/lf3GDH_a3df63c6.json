{"ver":"0.1","info":{"id":"lf3GDH","date":"1711622006","viewed":54,"name":"3 triangles 2 rotating ","username":"ArtemZh","description":"triangles","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define myPi 3.141592654f\n#define Eps 1e-6\n#define maxZ 100.0\nconst int n = 3; // число фигур\nvec3 colAr[n] = vec3[n](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0)); // цвета фигур\nvec3 BGcol = vec3(0.0, 0.0, 0.0); // цвет фона\nfloat zAr[n] = float[n](3.0, 2.0, 1.0); // z-координаты плоских фигур\nint inds[n+1] = int[n+1](0, 3, 6, 9); // массив индексов вершин для начала каждого полигона\nconst int m = 9; // число вершин, обновлено для трех треугольников\nvec2 polygons[m]; // массив координат вершин (крайних точек) полигонов\n\n// Функция инициализации полигонов\nvoid initPolygons(out vec2 polygons[m], in float time){\n    // Первый треугольник\n    polygons[0] = vec2(0.5 + 0.1*sin(time), 0.5 + 0.1*cos(time));\n    polygons[1] = vec2(0.4 + 0.1*sin(time), 0.2 + 0.1*cos(time));\n    polygons[2] = vec2(0.6 + 0.1*sin(time), 0.2 + 0.1*cos(time));\n    // Второй треугольник\n    polygons[3] = vec2(0.3, 0.7);\n    polygons[4] = vec2(0.2, 0.5);\n    polygons[5] = vec2(0.4, 0.5);\n    // Третий треугольник, который тоже будет двигаться\n    polygons[6] = vec2(0.7 - 0.1*sin(time), 0.7 - 0.1*cos(time));\n    polygons[7] = vec2(0.6 - 0.1*sin(time), 0.5 - 0.1*cos(time));\n    polygons[8] = vec2(0.8 - 0.1*sin(time), 0.5 - 0.1*cos(time));\n}\n\n// Функция определения принадлежности точки полигону\nbool inPolygon(in vec2 p, in int num){\n    bool inside = false;\n    for(int i = inds[num], j = inds[num + 1] - 1; i < inds[num + 1]; j = i++){\n        if((polygons[i].y > p.y) != (polygons[j].y > p.y) &&\n           (p.x < (polygons[j].x - polygons[i].x) * (p.y - polygons[i].y) / (polygons[j].y - polygons[i].y) + polygons[i].x)){\n            inside = !inside;\n        }\n    }\n    return inside;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy; // нормализация координат\n    initPolygons(polygons, iTime); // Инициализация полигонов\n    vec3 col = BGcol; // Инициализация цвета фона\n    float closestZ = maxZ; // Инициализация максимальной глубины\n\n    for(int i = 0; i < n; i++){\n        if(inPolygon(uv, i) && zAr[i] < closestZ){\n            closestZ = zAr[i];\n            col = colAr[i];\n        }\n    }\n\n    fragColor = vec4(col, 1.0); // Вывод результата\n}","name":"Image","description":"","type":"image"}]}