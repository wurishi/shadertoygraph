{"ver":"0.1","info":{"id":"csfSz7","date":"1722124337","viewed":78,"name":"Fresnel Approximations","username":"olano","description":"Testing for approximations to Fresnel reflectance","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// sphere parameters\nconst float radius = 0.4;\t\t// sphere radius\nconst float eyedist = 1.0;\t\t// distance of view from sphere\nconst float PI = radians(180.);\t// common trig constant\n\n// view from pair of mouse positions in 0-1\nvoid View(vec2 mouse, vec2 spos, vec2 dims, out vec3 eye, out vec3 ray) \n{\n    vec2 angles = mouse * vec2(2.*PI,PI);\n    float Cx = cos(angles.x), Sx = sin(angles.x);\n    float Cy = cos(angles.y), Sy = sin(angles.y);\n\n    mat3 view;\n    view[2] = vec3(-Sx*Sy, Cy, -Cx*Sy);\n    view[0] = normalize(vec3(-view[2].z, 0, view[2].x));\n    view[1] = normalize(cross(view[0], view[2]));\n    \n    eye = view[2] * eyedist;\n    ray = normalize(view * vec3((spos - 0.5 * dims) / dims.y, -1));\n}\n\n// Reconstruction of approximate HDR environment from https://www.shadertoy.com/view/ldcBzX\n// note that this color is roughly gamma corrected (by squaring)\n// will need to do the inverse of that (sqrt) on the ultimate color\nvec3 GetEnvMapB(vec3 rayDir) {\n    // Make sure this texture is set to the \"St. Peter's Basilica\" cubemap.\n    vec3 tex = texture(iChannel0, rayDir).xyz;\n    tex = tex * tex;  // gamma correct - gamma 2.0\n    // redish sky color.\n    vec3 light = vec3(1.0, 0.9, 0.9)*max(0.0, rayDir.y);\n    vec3 texp = pow(tex, vec3(14.0));\n    light *= texp;  // Masked into the existing texture's sky\n    return (tex + light*56.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fetch current settings from state texture\n    vec4 state = texelFetch(iChannel1, ivec2(1), 0);\n    vec2 mouse = state.xy;\n    FRES = int(state.z);\n    vec2 cursor  = TextSize*fragCoord/iResolution.y - vec2(0,TextSize.y-1.5);\n    \n    // camera pose from mouse location, or centered if unitialized\n    vec3 eye, ray;\n    View(mouse, fragCoord, iResolution.xy, eye, ray);\n    vec3 V = -ray;\n\n    // background \n    fragColor.rgb = GetEnvMapB(ray);\n\n    // check for intersection against sphere at 0,0,0\n\tfloat b = dot(ray, eye);\n\tfloat d = b*b - dot(eye, eye) + radius * radius;\n    if (d >= 0.) {\n        // sphere intersection point\n        d = sqrt(d);\n        float near = -d - b, far = d - b;\n        vec3 N = normalize(eye + near * ray);\n        vec3 R = reflect(ray, N);\n        vec3 H = normalize(V + R);\n        \n        float n = 1.5;    // index of refraction\n        float F0 = (n-1.)/(n+1.); F0 *= F0;  // Fresnel at normal incidence\n        float c = max(0., dot(N,V));         // cosine of angle of incidence\n        \n        // reflection and refraction\n        vec3 refl = GetEnvMapB(reflect(ray, N));\n        fragColor.rgb = GetEnvMapB(refract(ray, N, 1./n));\n        \n        float Fresnel = F0;\n        if (FRES == FRES_FULL) {\n            float g = sqrt(n*n + c*c - 1.0);\n            float a = (g-c) / (g+c);\n            float b = ((g+c)*c - 1.0) / ((g-c)*c + 1.0);\n            Fresnel = 0.5 * a*a * (1.0 + b*b);\n        }\n        else if (FRES == FRES_SCHLICK)\n            Fresnel = F0 + (1. - F0)*pow(1. - c, 5.);\n            \n        else if (FRES == FRES_EXP)\n            Fresnel = F0 + (1. - F0)*(1.00296 * exp2(-8.04263*c) - 0.00296);\n        \n        fragColor.rgb = mix(fragColor.rgb, refl, Fresnel);  \n    }\n\n    // Output to screen with text overlay\n    vec4 text = texelFetch(iChannel1, ivec2(fragCoord), 0);    \n    fragColor = vec4(mix(sqrt(fragColor.rgb), text.rgb, text.a), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// which Fresnel approximation to use\nconst int FRES_CONSTANT = 0;\nconst int FRES_FULL     = 1;\nconst int FRES_SCHLICK  = 2;\nconst int FRES_EXP      = 3;\nint FRES;\n\n// text font size\nconst vec2 TextSize = vec2(15,20);\n\n//////////////////////////////////////////////////////////////////////\n// print functoins based on Fabrice Neyret's https://www.shadertoy.com/view/llySRh\nint char_id = -1; vec2 char_pos, cursor; \nvec2 char(vec2 p, int c) {\n    if (p.x>.25 && p.x<.75 && p.y>.1 && p.y<.85)\n        char_id = c, char_pos = p;\n    return p - vec2(0.5,0);\n}\nfloat draw_char(sampler2D tex) {\n    int c = char_id; vec2 p = char_pos;\n    char_id = -1;\n    if (c < 0) return 0.;\n    return textureGrad(tex, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dFdx(p/16.),dFdy(p/16.) ).x;\n}\nvoid pInt(vec2 p, int n, int digits) {\n    if (n < 0) {\n        char(p, 45); p.x-=0.5;\n        digits -= 1;\n    }\n\tint a = abs(n);\n    for (int i = digits-1; i>=0; i--) {\n        char(p - .5*vec2(i,0), n!=0 && a==0 ? 32 : 48+(a%10));\n        a /=  10;\n    }\n}\nvoid pFloat(vec2 p, float n, int intDigits, int fracDigits) {\n    if (isinf(n)) {\n        char(p, 73);char(p-vec2(.5,0), 110);char(p-vec2(1,0), 102);\n        return;\n    }\n    if (isnan(n)) {\n        char(p, 78);char(p-vec2(.5,0), 97);char(p-vec2(1,0), 78);\n        return;\n    }\n    n += 0.5 * pow(10., -float(fracDigits));\n    pInt(p,int(n),intDigits); p.x -= 0.5 * float(intDigits);\n    char(p, 46); p.x -= .5;\n    pInt(p,int(abs(n)*pow(10.,float(fracDigits))), fracDigits);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// maximum text label width\nconst int maxLabel = 8;\n\n// mode prints were generated in git bash on windows with a command like:\n// for i in $(echo -n \"text\" | od -td1 -An ); do printf 'p = char(p,%3d);\\n' $i ; done\nvoid printConstant(vec2 p) {\n    p = char(p, 67);\n    p = char(p,111);\n    p = char(p,110);\n    p = char(p,115);\n    p = char(p,116);\n    p = char(p, 97);\n    p = char(p,110);\n    p = char(p,116);\n}\n\nvoid printFresnel(vec2 p) {\n    p = char(p, 70);\n    p = char(p,114);\n    p = char(p,101);\n    p = char(p,115);\n    p = char(p,110);\n    p = char(p,101);\n    p = char(p,108);\n}\n\nvoid printSchlick(vec2 p) {\n    p = char(p, 83);\n    p = char(p, 99);\n    p = char(p,104);\n    p = char(p,108);\n    p = char(p,105);\n    p = char(p, 99);\n    p = char(p,107);\n}\n\nvoid printExp2(vec2 p) {\n    p = char(p, 69);\n    p = char(p,120);\n    p = char(p,112);\n    p = char(p, 50);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fetch current settings from state texture\n    vec4 state = texelFetch(iChannel0, ivec2(1), 0);\n    vec2 mouse = iMouse.xy == vec2(0) ? vec2(0.5) : state.xy;\n    FRES = int(state.z);\n\n    bool mouseDown = iMouse.z > 0.;\n    \n    // positions scaled by text size\n    vec2 textbase  = TextSize*fragCoord/iResolution.y;\n    ivec2 textMouse = ivec2(TextSize*iMouse.xy/iResolution.y);\n    \n    // print or change current setting\n    printConstant(textbase - vec2(0, FRES_CONSTANT));\n    if (mouseDown && textMouse.x <= maxLabel && textMouse.y <= FRES_CONSTANT) {\n        FRES = FRES_CONSTANT;\n        mouseDown = false;\n    }\n    fragColor = mix(fragColor, \n                    vec4(1,1,FRES!=FRES_CONSTANT,1), \n                    draw_char(iChannel1));\n\n    printFresnel(textbase - vec2(0, FRES_FULL));\n    if (mouseDown && textMouse.x <= maxLabel && textMouse.y <= FRES_FULL) {\n        FRES = FRES_FULL;\n        mouseDown = false;\n    }\n    fragColor = mix(fragColor, \n                    vec4(1,1,FRES!=FRES_FULL,1), \n                    draw_char(iChannel1));\n\n    printSchlick(textbase - vec2(0, FRES_SCHLICK));\n    if (mouseDown && textMouse.x <= maxLabel && textMouse.y <= FRES_SCHLICK) {\n        FRES = FRES_SCHLICK;\n        mouseDown = false;\n    }\n    fragColor = mix(fragColor, \n                    vec4(1,1,FRES!=FRES_SCHLICK,1), \n                    draw_char(iChannel1));\n\n    printExp2(textbase - vec2(0, FRES_EXP));\n    if (mouseDown && textMouse.x <= maxLabel && textMouse.y <= FRES_EXP) {\n        FRES = FRES_EXP;\n        mouseDown = false;\n    }\n    fragColor = mix(fragColor, \n                    vec4(1,1,FRES!=FRES_EXP,1), \n                    draw_char(iChannel1));\n    \n    // haven't consumed mouse event, use for position\n    if (mouseDown) mouse = iMouse.xy / iResolution.xy;\n    \n    // save out state\n    if (ivec2(fragCoord) == ivec2(1)) fragColor = vec4(mouse, FRES,0);\n}","name":"Buffer A","description":"","type":"buffer"}]}