{"ver":"0.1","info":{"id":"4t33W4","date":"1469151361","viewed":286,"name":"Em Tee Vee","username":"steverock","description":"Playing with edge detection","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","edge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat3 sobel = mat3(\n    -1, 0, 1,\n    -2, 0, 2,\n    -1, 0, 1\n);\n\nmat2 rot2(float rads) {\n    return mat2( cos(rads), -sin(rads), sin(rads), cos(rads) );\n}\n\nfloat osc(float lo, float hi, float period)\n{\n    float b = (lo + hi) / 2.0;\n    float a = (hi - lo) / 2.0;\n    return b + a * sin(iTime * 6.3 / period);\n}\n\nvec2 vorhash( vec2 p )\n{\n\treturn texture( iChannel1, (p+0.5)/100.0, -100.0 ).xy;\n}\n\nvec2 animOrigin(vec2 o) {\n    //return o;\n\treturn 0.5 + 0.5*sin( iTime*0.5 + 6.2831*o );\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j)); // snapped offset\n\t\tvec2 o = vorhash( n + g ); // nonsnapped offset offset\n        o = animOrigin(o);\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    // second pass: distance to borders\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = vorhash( n + g );\n        o = animOrigin(o);\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.000001 )\n\t\t{\n        \t// distance to line\t\t\n        \tfloat d = dot( 0.5*(mr+r), normalize(r-mr) );\n\t        md = min( md, d );\n\t\t}\n    }\n\n    return vec3( md /* dist to edge */, mr /* delta to center */ );\n}\n\n\nvec4 getEdgeColor(vec2 uv)\n{\n    return vec4(uv,0.5+0.5*sin(iTime),1.0);\n}\n\nvec4 greyscale(vec4 rgba) {\n    return vec4( vec3(length(rgba.rgb)), rgba.a );\n}\n\nvec4 voroInput(vec2 uv)\n{\n    uv = mod(uv * 2.0, 1.0);\n\n    float d = 0.01;\n    vec2 g = vec2(0.0);\n    for( int i = 0;  i < 3; i++ ) {\n        for( int j = 0; j < 3; j++ ) {\n            vec2 duv = vec2( float(j-1) * d, float(i-1) * d );\n           \tfloat src = length(texture( iChannel0, uv + duv ));\n            g += vec2(\n                sobel[i][j] * src,\n                sobel[j][i] * src );\n        }\n    }\n    \n    vec4 nonedgeColor = greyscale(texture(iChannel0, uv));\n    vec4 edgeColor = getEdgeColor(uv);\n    float edgeness = length(g);\n    \n    float lowthresh = 0.5;\n    float smoothness = 0.8;\n    return mix( nonedgeColor, edgeColor, smoothstep(lowthresh, lowthresh+smoothness, edgeness) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    float rotDegs = 5.0 * sin(iTime * 6.3 / 5.0);\n    uv = rot2(rotDegs*3.14/180.0) * uv;\n    \n    float vorPeriod = osc(0.001, 0.015, 5.0);\n    float vorFreq = 1.0 / vorPeriod;\n    vec2 vsUv = vorFreq*uv;\n    vec3 v = voronoi( vsUv );\n    vec2 center = v.yz + vsUv;\n    //return vec4(vec3(v.x), 1.0);\n    uv = mod(center/vorFreq, 1.0);\n    fragColor = voroInput(uv);\n        \n}","name":"Image","description":"","type":"image"}]}