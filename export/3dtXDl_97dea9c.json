{"ver":"0.1","info":{"id":"3dtXDl","date":"1573141487","viewed":83,"name":"Raymarching [1] Intro","username":"camelcoder","description":"Raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sd_sphere(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\n// Fractal magic we ain't going to talk about\nfloat sd_mandelbulb(vec3 p, float Power, float Bailout)\n{\n\tvec3 z = p;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\n\t\t// convert to polar coordinates\n\t\t/*float theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);*/\n\t\tfloat theta = asin( z.z/r );\n\t\tfloat phi = atan( z.y,z.x );\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3( cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta) );\n\t\t//z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=p;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat map(vec3 pos)\n{\n    // create floor\n    float d = pos.y - -0.5;\n \n    vec3 p = pos;\n    \n    p.xz += vec2(sin(iTime), cos(iTime));\n    \n    d = min(d, sd_sphere(p, 0.5));\n    d = min(d, sd_sphere(p - vec3(0.3, 0.3, 0), 0.25));\n    d = min(d, sd_sphere(p - vec3(-0.3, 0.3, 0), 0.25));\n\t\n    // float s = sin(iTime * 0.25);\n    // float c = cos(iTime * 0.25);\n    // p.xz *= mat2(c, -s, s, c);\n\n    // d = min(d, sd_mandelbulb(p, (sin(iTime * 0.25) + 1.1) * 8.0, 4.0));\n    \n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    fragCoord *= 2.0;\n\tvec2 p = (fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -2.0); // ray origin\n    vec3 rd = normalize(vec3(p, 1.5)); // ray direction\n    \n    vec3 col = vec3(0);\n    \n    /**\n     * Raymarch\n     **/\n    \n    int steps = 0;\n    float total = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        steps = i;\n        vec3 pos = ro + total * rd;\n        \n        float dist = map(pos);\n        \n        if (dist < 0.001) break; // to close\n        total += dist;\n        if (total > 20.0) { // to far\n            total *= -1.0;\n            break;\n        }\n    }\n    col = vec3(total * 0.25) // depth\n        + (float(steps) / 100.0); // edges\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}