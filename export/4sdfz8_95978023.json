{"ver":"0.1","info":{"id":"4sdfz8","date":"1524106545","viewed":11928,"name":"Lake in highland","username":"FishMan","description":"move mouse to look around","likes":80,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","noise","cloud","water","terrian","lake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// create by JiepengTan 2018-04-18  email: jiepengtan@gmail.com\n\nvec3 _BaseWaterColor = (vec3(22.,79.,86.)/255.);\nvec3 _LightWaterColor= (vec3(0.,214.,10.)/255.);\n\nconst float SC = 10.;\nfloat waterHeight = 100.;\nfloat waterTranDeep = 10.;\nvec3 lightDir = normalize( vec3(0.5,0.6,0.) );\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n               -0.80,  0.36, -0.48,\n               -0.60, -0.48,  0.64 );\n\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(3.0-2.0*f);\n  \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nfloat FBM( in vec3 p )\n{\n    float n = 0.0;\n    n += 0.50000*Noise( p*1.0 );\n    n += 0.25000*Noise( p*2.0 );\n    n += 0.12500*Noise( p*4.0 );\n    n += 0.06250*Noise( p*8.0 );\n    n += 0.03125*Noise( p*16.0 );\n    return n/0.984375;\n}\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.15* spd;\n    vec2 sc = ro.xz + rd.xz*((3.)*40000.0-ro.y)/rd.y;\n    vec2 p = 0.00002*sc;\n    float f = 0.0;\n  \tfloat s = 0.5;\n  \tfloat sum =0.;\n  \tfor(int i=0;i<5;i++){\n    \tp += t;t *=1.5;\n    \tf += s*textureLod( iChannel0, p/256.0, 0.0).x; p = m2*p*2.02;\n    \tsum+= s;s*=0.6;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, 0.5*smoothstep(0.5,0.8,val) );\n    return col;\n}\n\nfloat WaterMap( vec3 pos ) {\n    return FBM( vec3( pos.xz, iTime*0.3 )) * 1.;\n}\n\nvec3 WaterNormal(vec3 pos,float rz){\n    float EPSILON =rz*rz* 0.002;\n    vec3 dx = vec3( EPSILON, 0.,0. );\n    vec3 dz = vec3( 0.,0., EPSILON );\n      \n    vec3  normal = vec3( 0., 1., 0. );\n    float bumpfactor = 0.3 * pow(1.-clamp((rz)/1000.,0.,1.),6.);//\n    \n    normal.x = -bumpfactor * (WaterMap(pos + dx) - WaterMap(pos-dx) ) / (2. * EPSILON);\n    normal.z = -bumpfactor * (WaterMap(pos + dz) - WaterMap(pos-dz) ) / (2. * EPSILON);\n    return normalize( normal ); \n}\n\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0,0.0,0.0);  \n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n    \n     // sky      \n    col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.4*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(1.0,0.95,1.0),1.);\n            // .\n    col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col;\n}\nfloat TerrainH( in vec2 x ) {\n    \n\tvec2  p = x*0.03/SC;\n    float a = 0.0;\n    float b = 0.5;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        float n = Noise3D(vec3(p,0.));\n        a += b*n;\n\t\tb *= 0.5;\n        p *=m2* 2.0;\n    }\n\treturn SC*30.0*a;\n}\n\n\n\nfloat InteresctTerrial( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n    for( int i=0; i<256; i++ ) \n    {\n        vec3 p = ro + t*rd;\n        float h = p.y - TerrainH( p.xz );\n        if( h<(0.002*t) || t>tmax ) break;\n        t += 0.9*h;\n    }\n    return t; \n}\n\nfloat SoftShadow(in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.001;\n    for( int i=0; i<80; i++ )\n    {\n        vec3  p = ro + t*rd;\n        float h = p.y - TerrainH( p.xz );\n        res = min( res, 16.0*h/t );\n        t += h;\n        if( res<0.001 ||p.y>(SC*20.0) ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\nvec3 CalcTerrianNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( TerrainH(pos.xz-eps.xy) - TerrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            TerrainH(pos.xz-eps.yx) - TerrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 RayMarchTerrial(vec3 ro,vec3 rd,float rz){\n    vec3 col = vec3(0.,0.,0.);\n    vec3 pos = ro + rz * rd;\n    vec3 nor = CalcTerrianNormal(pos,rz);\n\n    vec3 ref = reflect( rd, nor );\n    float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n    vec3 hal = normalize(lightDir-rd);\n\tcol = vec3(0.08,0.05,0.03);\n    // lighting     \n    float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n    float dif = clamp( dot( lightDir, nor ), 0.0, 1.0 );\n    float bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-lightDir.x, 0.0, lightDir.z ) ), nor ), 0.0, 1.0 );\n\n    //shadow\n    float sh = 1.0; \n  \n    vec3 lin  = vec3(0.0,0.0,0.0);\n    lin += dif*vec3(7.00,5.00,3.00)*1.3;\n    lin += amb*vec3(0.40,0.60,1.00)*1.2;\n    lin += bac*vec3(0.40,0.50,0.60);\n    col *= lin;\n  \n    // fog\n    float fo = 1.0-exp(-pow(0.001*rz/SC,1.5));\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);// + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n    col = mix( col, fco, fo );\n  return col;\n}\n\n#define mouse (iMouse.xy / iResolution.xy)\nvec3 InitCam(in vec2 fragCoord ){\n    float time = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  \tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0,-0.03):mo;\n\tmo.x *= iResolution.x/iResolution.y * 3.14159;\n\t\n\n    mo.x += smoothstep(0.6,1.,0.5+0.5)-1.5;\n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*2.-0.2+sin(1.57)*0.1,sin(mo.x)));\n    vec3 rightdir = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*1.+eyedir);\n\treturn rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxT = 10000.;\n    float minT = 0.1;\n    vec3 col  = vec3 (0.,0.,0.);\n    float waterT = maxT;\n    \n    vec3 ro = vec3(-79.,104., -4.0);\n\tvec3 rd = InitCam(fragCoord);\n\t\n    if(rd.y <-0.01){\n      \tfloat t = -(ro.y - waterHeight)/rd.y;\n      \twaterT = min(waterT,t);\n    }\n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n\n    float rz = InteresctTerrial(ro,rd,minT,maxT);\n    float fresnel = 0.;\n    vec3 refractCol = vec3(0.,0.,0.);\n    bool reflected = false;\n    \n    // hit the water\n    if(rz >= waterT && rd.y < -0.01){\n        vec3 waterPos = ro + rd * waterT; \n        vec3 nor = WaterNormal(waterPos,waterT);\n        float ndotr = dot(nor,-rd);\n        fresnel = pow(1.0-abs(ndotr),6.);\n        float diff = pow(dot(nor,lightDir) * 0.4 + 0.6,3.);\n        // get the water col \n        vec3 waterCol = _BaseWaterColor + diff * _LightWaterColor * 0.12; \n        float transPer = pow(1.0-clamp( rz - waterT,0.,waterTranDeep)/waterTranDeep,3.);\n        vec3 bgCol = RayMarchTerrial(ro,rd + nor* clamp(1.-dot(rd,-nor),0.,1.),rz);\n        refractCol = mix(waterCol,bgCol,transPer);\n\t\t//reset the reflect dir and position\n        ro = waterPos;\n        rd = reflect( rd, nor);\n        rz = InteresctTerrial(ro,rd,minT,maxT);\n        reflected = true;\n        col = refractCol;\n    }\n    if(rz >= maxT){\n        col = RayMarchCloud( ro, rd);\n    }else{\n        col = RayMarchTerrial(ro,rd,rz);\n    }\n    if( reflected == true ) {\n        col = mix(refractCol,col,fresnel);\n        float spec=  pow(max(dot(rd,lightDir),0.0),128.) * 3.;\n        col += vec3(spec,spec,spec);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}